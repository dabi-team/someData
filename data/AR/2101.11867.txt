1
2
0
2

n
a
J

8
2

]
h
t
-
l
c
u
n
[

1
v
7
6
8
1
1
.
1
0
1
2
:
v
i
X
r
a

Simulating low-energy neutrino interactions with MARLEY

S. Gardinera,b

aFermi National Accelerator Laboratory, P.O. Box 500, Batavia, IL 60510, USA
bUniversity of California, Davis, One Shields Avenue, Davis, CA 95616, USA

Abstract

Monte Carlo event generators are a critical tool for the interpretation of data obtained by
neutrino experiments. Several modern event generators are available which are well-suited to the
GeV energy scale used in studies of accelerator neutrinos. However, theoretical modeling diﬀerences
make their immediate application to lower energies diﬃcult. In this paper, I present a new event
generator, MARLEY, which is designed to better address the simulation needs of the low-energy
(tens of MeV and below) neutrino community. The code is written in C++14 with an optional
interface to the popular ROOT data analysis framework. The current release of MARLEY (version
∗
1.2.0) emphasizes simulations of the reaction 40Ar(νe, e−)40K
but is extensible to other channels
with suitable user input. This paper provides detailed documentation of MARLEY’s implementation
and usage, including guidance on how generated events may be analyzed and how MARLEY may be
interfaced with external codes such as Geant4. Further information about MARLEY is available on
the oﬃcial website at http://www.marleygen.org.

Keywords: event generator, neutrino-nucleus scattering, tens-of-MeV

PROGRAM SUMMARY
Program Title: MARLEY 1.2.0
Developer’s respository link: http://github.com/MARLEY-MC/marley
Licensing provisions: GNU General Public License 3.0
Programming language: C++14
External routines/libraries used: GNU Scientiﬁc Library [1, 2] (required), ROOT [3, 4] (optional)
Nature of problem: Simulation of neutrino-nucleus scattering events at energies of tens-of-MeV and below
Solution method: Initial two-to-two scattering kinematics are sampled using the allowed approximation
diﬀerential cross section and tables of precomputed nuclear matrix elements. Subsequent de-excitations of
the remnant nucleus are simulated using a Monte Carlo implementation of the Hauser-Feshbach statistical
model and tabulated γ-ray decay schemes for discrete nuclear levels.
Restrictions: Input data are provided with the code that are suitable for producing simulations of the
charged-current reaction 40Ar(νe, e−)40K∗, coherent elastic neutrino-nucleus scattering on spin-zero target
nuclei, and neutrino-electron elastic scattering on any atomic target. Preparation of new reaction input
ﬁles (whose format is documented in appendix B) would enable other reaction channels and nuclear targets
to be handled by the existing code framework. Although there is no maximum neutrino energy enforced by

∗Corresponding author.

E-mail address: gardiner@fnal.gov

Preprint submitted to Computer Physics Communications

January 29, 2021

 
 
 
 
 
 
the code itself, realistic neutrino-nucleus scattering events may be generated up to roughly 50 MeV. Above
this energy, the eﬀects of forbidden nuclear transitions, which are neglected in the current treatment of the
cross sections (see section 2.1), become increasingly important.

1. Introduction

Monte Carlo event generators are a widely-used tool in nuclear and particle physics. These
computer programs implement probabilistic models of physics processes and produce corresponding
sets of events: lists of particles (represented by their charges, 4-momenta, etc.) involved in simulated
interactions.

While helpful as an aid to theoretical calculations, event generators are also often used by
experiments for designing detectors, estimating eﬃciencies and backgrounds, assessing systematic
uncertainties, and interpreting the results of measurements. Examples of event generators include
PYTHIA [5] and Herwig [6] for high-energy particle collisions, HYDJET++ [7] for relativistic heavy
ion collisions speciﬁcally, FREYA [8] for ﬁssion, and DECAY4 [9] for radioactive decays of unstable
isotopes.

For studies of neutrinos, much community eﬀort has been directed toward the development of
event generators suitable for use by accelerator-based experiments at facilities like J-PARC [10]
and Fermilab [11]. These experiments employ beams of primarily muon-ﬂavor neutrinos which are
produced over a broad energy range between the low hundreds of MeV to the tens of GeV. Neutrino
scattering on atomic nuclei is the primary means of detection, and several modern event generators
provide widely-used models of the relevant physics, including GENIE [12], GiBUU [13], NEUT [14],
and NuWro [15].

Although important diﬀerences exist between each of these generators, all share a similar concep-
tual treatment of neutrino-nucleus interactions. Each scattering event on a complex nucleus is taken
to involve a neutrino striking a single bound nucleon.1 A removal energy and initial 3-momentum
are assigned to the struck nucleon using a model of the nuclear ground state. Traditionally this is
done using a variant of the Fermi gas model (e.g., that of ref. [17]), but implementations of more
sophisticated treatments, such as the Correlated Basis Function approach [18, 19], are beginning to
become available [20].

With the initial state fully deﬁned, the generator then simulates production of the particles that
emerge from the neutrino-nucleon interaction vertex. A variety of models must be used at this stage
due to competition between multiple nucleon-level processes (e.g, quasi-elastic and deep inelastic
scattering) which may occur at accelerator neutrino energies.

Because they are subject to the strong force, outgoing hadrons from the primary neutrino
interaction will often rescatter within the nuclear medium. These ﬁnal-state interactions (FSIs)
can have a pronounced eﬀect on the kinematics and multiplicities of the hadrons that ultimately
exit the nucleus.
Intranuclear hadron transport and FSIs are handled in GENIE, NEUT, and
NuWro using variations of the intranuclear cascade (INC) model [21–23]. This model assumes that
propagation of a hadron h through the nucleus may be described in terms of a mean free path

λ(h, E, r) =

1
ρ(r) σhN (E)

,

(1)

1Two particle-two hole interactions, which involve a pair of nucleons, are included in modern generators [16] but

neglected here for simplicity. I likewise neglect coherent processes, which involve the nucleus as a whole.

2

where E is the hadron energy, r is its radial position within the nucleus, and ρ is the number density
of nucleons. The total cross section for h scattering on a free nucleon, σhN , may be used directly
but is typically modiﬁed with approximate corrections for nuclear eﬀects.

The GiBUU code simulates intranuclear hadron transport using a semi-classical model which
considers the time evolution of the phase space density for each hadronic species. The equations
describing the behavior of distinct kinds of hadrons are coupled through the common nuclear
mean ﬁeld and through a collision term which represents the inﬂuence of FSIs. The numerical
implementation adopts a test-particle ansatz to solve the relativistic Boltzmann-Uehling-Uhlenbeck
(BUU) equation. Extensive documentation of GiBUU’s treatment of various nuclear reactions,
including neutrino-nucleus scattering, is available in refs. [13, 24]. The INC models used by other
generators for FSIs may largely be regarded as approximate simpliﬁcations of the BUU approach
[25, sec. 2].

When all produced particles either escape the nucleus or are re-absorbed by it, the hadron
transport stage of the simulation is complete. This typically marks the end of the physics workﬂow
needed to generate a single neutrino-nucleus scattering event. The ﬁnished events may be used both
for standalone calculations of kinematic distributions and as input to later stages of an experiment’s
detector simulation chain.2

In addition to accelerator-based neutrino oscillation experiments, there is also worldwide interest
in pursuing detailed measurements of lower-energy (tens-of-MeV and below) neutrinos produced by
supernovae [27–29], by the Sun [30, 31], and by terrestrial facilities via pion and muon decays at
rest [32–36]. Several distinct reaction modes will enable neutrino detection in these measurements.
Elastic scattering on electrons and protons [37] is ﬂavor-blind but produces signal events down to
arbitrarily low neutrino energies. Coherent elastic neutrino-nucleus scattering (CEvNS), a neutral-
current (NC) process in which a neutrino scatters oﬀ of a complex nucleus and leaves it in its ground
state [38], shares these properties and was recently observed for the ﬁrst time by the COHERENT
experiment [39, 40]. Apart from reactions involving complex nuclei, the only inelastic channel
available at tens-of-MeV energies is charged-current (CC) absorption of ¯νe on free protons via the
inverse beta decay (IBD) reaction3

¯νe + p

n + e+ .

(2)

→
The IBD cross section is precisely known [41, 42] and dominates the expected signal for supernova
neutrinos in water Cherenkov and liquid scintillator detectors [28].

The low-energy neutrino interaction modes listed so far do not present any special diﬃculties
from an event generator perspective. Relatively simple expressions are adequate to compute diﬀer-
ential cross sections for all but the most precise calculations of these processes, and, with the recent
addition of a CEvNS model [43], the GENIE event generator currently provides an implementation
of all of them that may be suitable for use by low-energy neutrino experiments.

In contrast to other low-energy processes, inelastic neutrino scattering on all but the lightest
complex nuclei (e.g., deuterium) is theoretically cumbersome, requiring an elaborate treatment of
nuclear physics in order to fully describe the interactions. Despite the signiﬁcant challenges involved,
however, obtaining realistic simulations of low-energy inelastic neutrino-nucleus scattering is highly
desirable for a variety of scientiﬁc applications. Principal among these is detection of low-energy

2Ref. [26] describes a GENIE-based example used by the NOvA experiment.
3The analogous reaction νe + n → p + e− is also possible. However, it is not practical for use in a neutrino detector

due to the instability of free neutrons.

3

astrophysical neutrinos by the upcoming Deep Underground Neutrino Experiment (DUNE) [44].
Thanks to the experiment’s planned use of four ten-kiloton liquid argon time projection chambers
(LArTPCs), DUNE has the potential to perform detailed measurements of these neutrinos via the
charged-current reaction

νe + 40Ar

e− + 40K

∗

.

(3)

(4)

→
This process is anticipated to provide most of the signal in DUNE for the neutrino burst associated
with a galactic core-collapse supernova, granting the experiment the potential for unique sensitivity
among large detectors to the νe component of the supernova neutrino ﬂux [45, 46]. DUNE also
shows substantial promise as a detector for studying solar neutrinos [30].

Primary sensitivity to low-energy νe is shared with DUNE by the 79-ton Helium and Lead
Observatory (HALO) [47–49], but in this case the detection technique is indirect. Inelastic neutrino
reactions on lead nuclei, such as

νe + 208Pb

∗
e− + 208Bi

,

→
will sometimes lead to the production of neutrino-induced neutrons (NINs) via de-excitations of the
residual nucleus. HALO’s lead neutrino target is instrumented with 3He-based neutron counters,
which will be used to search for NINs in the event of a nearby core-collapse supernova. Due to its
widespread use as a radiation shielding material, lead is also a potential source of background NINs
in precision CEvNS measurements. To better constrain theoretical modeling of this background,
the COHERENT experiment is pursuing direct measurements of NIN production on lead, iron, and
copper [35].

Beyond the examples mentioned here, inelastic scattering on a variety of other nuclear targets
is of interest either as a means of low-energy neutrino detection4 or as a source of background.
Additional nuclei for which models of these processes have been studied in detail include carbon
[51–56], oxygen [57–61], molybdenum [62–67], and xenon [68–70], among others [71–78].

Despite the successes of standard neutrino event generators in describing accelerator neutrino
data, their prevailing treatment of inelastic neutrino-nucleus scattering is likely to be inadequate
when applied to interactions at energies of tens of MeV and below. This is due in part to approxima-
tions made in their modeling of nuclear structure. For few-MeV neutrinos, inelastic neutrino-nucleus
cross sections are governed by the energetically-accessible transitions to low-lying discrete energy
levels of the daughter nucleus. At somewhat higher energies, excitations of collective vibrational
modes of the nucleus, known as giant resonances [79, 80], also begin to play a major role. Both
of these details are entirely missing from the conventional Fermi gas model of the nuclear ground
state. While these deﬁciencies of the Fermi gas model become less problematic as the neutrino
energy increases to several hundred MeV and beyond, it has been pointed out that low-energy
1 GeV neutrino-nucleus
nuclear excitations are still expected to exert a noticeable inﬂuence on
diﬀerential cross sections at very forward scattering angles [81, 82].

∼

A second modeling diﬀerence that limits the suitability of typical neutrino event generators for
the low-energy regime is the description of hadronic ﬁnal-state interactions. Rather than taking an
INC- or BUU-like dynamical approach to FSIs, in which intranuclear scattering is explicitly mod-
eled, typical low-energy calculations [60, 83–90] opt instead for a statistical treatment, in which only
bulk properties of the nuclear system (such as its excitation energy and spin-parity) are employed

4The pioneering Homestake solar neutrino experiment famously employed the 37Cl(νe, e−)37Ar reaction for this

purpose [50].

4

to predict its behavior. The latter strategy is usually justiﬁed by assuming that the struck nucleon
from the primary neutrino interaction will scatter repeatedly within the nuclear medium without
being directly knocked out. These multiple intranuclear collisions lead to the transferred energy be-
ing widely shared among the constituent nucleons and thus to thermal equilibration: de-excitations
of the resultant compound nucleus may be treated independently of the manner in which it was
formed.

While theoretical predictions of neutrino-nucleus cross sections at high (low) energies tend to
rely exclusively on a dynamical (statistical) model of FSIs, a more complete treatment may be
achieved by combining the two approaches. The current release of GiBUU enables such calculations
by providing an optional interface to the Statistical Multifragmentation Model (SMM) [91] code.
Disintegration of the residual nucleus is simulated by SMM in a post-processing step which takes
otherwise complete GiBUU events as input. Although the two codes have been used together to
examine other processes [92–95], their joint application to neutrino interactions remains unstudied.
At present, native support for statistical nuclear de-excitation models in the other three neutrino
generators mentioned above is limited to some simple approximations used in GENIE’s treatment
of nucleon emission [96]. However, oﬃcial GENIE interfaces to INCL++ [97, 98] and to the Bertini
Cascade implementation [99] in Geant4 [100, 101] are in the late stages of development [102, 103].
These will provide enhancements to GENIE FSI modeling which are similar in scope to those
obtained with SMM for GiBUU. Unoﬃcial interfaces are also being explored by outside groups, with
at least one attempt [104] having been made to apply the TALYS [105, 106] nuclear de-excitation
model to events generated using both GENIE and NuWro.

Although interfacing with these external tools provides an FSI treatment more compatible
with standard low-energy approaches, a key omission remains problematic. With the exception
of TALYS, the usual conﬁgurations of all of the remaining codes5 lack a means of simulating dis-
crete γ-ray transitions between low-lying nuclear energy levels.6 Gamma-rays created in this way
represent a major component of the ﬁnal state for inelastic scattering of solar neutrinos on complex
nuclei. For inelastic NC reactions, de-excitation γ-rays may often be the only ﬁnal-state particles
which are experimentally observable.

In this work, I present a new neutrino event generator, MARLEY,7 which implements a model
of inelastic neutrino-nucleus scattering designed speciﬁcally for the low-energy regime. The early
version of MARLEY described herein is primarily focused on simulations of charged-current absorption
of νe on 40Ar [108]. However, preparation of additional input data would allow other reaction
channels and nuclear targets to be handled without diﬃculty within the existing code framework.
Section 2 provides an overview of the theoretical treatment of neutrino scattering used in MARLEY.
Section 3 presents the MARLEY approach to random sampling, which makes ample use of modern
improvements to the C++ language and, as discussed in section 3.3, implements a new inverse
transform sampling algorithm [109] in a physics event generator for the ﬁrst time. Section 4 discusses
the MARLEY event generation workﬂow and implementation details. Sections 5–7 outline how to

5Initializing the main Geant4 Bertini Cascade class (G4CascadeInterface) using non-default settings [99, sec. 4.1]

may enable simulation of discrete γ-ray emission via the G4ExcitationHandler class [107].

6I note, however, that both GENIE and NEUT directly implement simple models of de-excitation γ-ray production

that are speciﬁc to 16O.

7MARLEY is an acronym for Model of Argon Reaction Low Energy Yields. Although originally conceived as a
tool to simulate the speciﬁc process 40Ar(νe, e−)40K∗, MARLEY is moving toward becoming a more general-purpose
low-energy neutrino interaction generator.

5

install, conﬁgure, run, and interpret the output of the code. Section 8 explains how MARLEY can be
interfaced with external software toolkits, using the popular Geant4 [100, 101] particle transport
package as an example. Finally, section 9 considers prospects for future improvements to MARLEY.

2. MARLEY treatment of neutrino scattering

This section provides a brief overview of the physics models currently implemented in MARLEY,

with more details available in ref. [108]. Natural units ((cid:126) = c = 1) are used throughout.

As has been done in many previous calculations of low-energy neutrino cross sections [60, 83–90],
MARLEY treats neutrino-nucleus scattering events as proceeding via a two-step process. In the ﬁrst
step, a two-to-two scattering reaction involving the neutrino and the target nucleus is simulated,
and the ﬁnal nucleus is left in a state with a well-deﬁned excitation energy, spin, and parity. In
the second step, which is handled independently from the ﬁrst, the ﬁnal nucleus de-excites. At low
excitation energies, where discrete level data are available, the de-excitations are modeled using
tabulated γ-ray branching ratios. At higher excitation energies, where the ﬁnal nucleus becomes
unbound, the formation of a compound nucleus is assumed, and the decay widths for all open
channels are calculated using the Hauser-Feshbach statistical model [110].

2.1. Nuclear 2

2 scattering model

→

→

0) and the slow-nucleon limit (in which

To simulate two-to-two neutrino-nucleus scattering processes at low energies, MARLEY 1.2.0 evalu-
ates the nuclear matrix elements in the long-wavelength limit (in which the four-momentum transfer
0, where pN is the initial 3-momentum
q
/mN
|
of the struck nucleon and mN is its mass). The combination of these two limits is sometimes re-
ferred to as the allowed approximation. Under this approach, the diﬀerential cross section in the
center-of-momentum (CM) frame for a transition to a particular nuclear ﬁnal state is given by the
expression

pN

→

|

dσ
d cos θ(cid:96)

=

G2
F
2 π FCC

Ei Ef
s

(cid:20)

E(cid:96)

p(cid:96)
|

|

(cid:21)

(cid:20)(cid:16)

1 + β(cid:96) cos θ(cid:96)

B(F) +

1

β(cid:96) cos θ(cid:96)

B(GT)

.

(5)

(cid:17)

(cid:16)

(cid:17)

(cid:21)

1
3

−

Here GF is the Fermi constant, Mandelstam s is the square of the total energy in the CM frame, and
Ei (Ef ) is the total energy of the initial (ﬁnal) nucleus. The ﬁnal-state lepton has total energy E(cid:96),
3-momentum p(cid:96), speed β(cid:96) =
/E(cid:96), and scattering angle θ(cid:96), which is deﬁned with respect to the
|
incident neutrino direction. The ﬁrst factor in square brackets, Ei Ef /s, arises due to nuclear recoil
and is often neglected. The symbol
FCC is used to introduce extra factors needed when computing
the cross section for charged-current scattering. Discussion of
The spin-reduced Fermi and Gamow-Teller nuclear matrix elements may be written in the form

FCC is deferred to section 2.1.2.

p(cid:96)
|

B(F)

g2
V
2Ji + 1

≡

B(GT)

g2
A
2Ji + 1

≡

Jf

Jf

(cid:10)

(cid:12)
(cid:12)
(cid:12)

(cid:13)
(cid:13)

F

O

(cid:13)
(cid:13)
GT

O

2

Ji

(cid:11)(cid:12)
(cid:12)
(cid:12)
Ji

2

(6)

(7)

(cid:12)
(cid:12)
where gV (gA) is the vector (axial-vector) weak coupling constant of the nucleon, and Ji (Jf ) is the
(cid:12)
initial (ﬁnal) nuclear spin. The Fermi matrix element B(F) is subject to the spin-parity selection
rule

(cid:11)(cid:12)
(cid:12)
(cid:12)

(cid:13)
(cid:13)

(cid:13)
(cid:13)

(cid:10)

B(F) = 0 unless Jf = Ji and Πf = Πi

(8)

6

where Πi (Πf ) is the initial (ﬁnal) nuclear parity. The Gamow-Teller matrix element B(GT) likewise
obeys the selection rule

The Fermi (

F) and Gamow-Teller (

B(GT) = 0 unless

Ji

|

1
| ≤

Jf

Ji + 1 and Πf = Πi .

−
GT) operators from eqs. (6) and (7) are deﬁned for

≤

(9)

charged-current and neutral-current scattering processes via the relations

O

O

A
n=1 t±(n) CC

F

O

≡ 


(cid:80)
QW / 2

NC

A
n=1 σ(n) t±(n) CC

GT

O

(cid:80)

≡ 


A
n=1 σ(n) t3(n) NC

(10)



where σ is the Pauli vector, A is the nucleon number, and the isospin lowering (raising) operator
t− (t+) should be chosen8 for an incident neutrino (antineutrino). The symbol t3 denotes the third
component of isospin, and an operator suﬃxed by (n) is understood to act only on the nth nucleon.
The weak nuclear charge QW for a nucleus with neutron number N and proton number Z is given
in terms of the weak mixing angle θW by



(cid:80)

−
2.1.1. Coherent elastic neutrino-nucleus scattering

−

QW = N

[1

4 sin2 θW ] Z .

(11)

For NC reactions on a spin-zero (Ji = 0) target nucleus, the diﬀerential cross section from
eq. (5) reduces to a particularly simple form when describing scattering that leaves the nucleus in
its ground state. The Gamow-Teller selection rule (eq. (9)) ensures that B(GT) vanishes identically,
while the Fermi matrix element for the ground-state-to-ground-state transition becomes

For this special case, eq. (5) may be rewritten in terms of the lab-frame kinetic energy Tf of the
recoiling ground-state nucleus as

B(F) =

V Q2
g2
W
4

.

(12)

dσCEvNS
dTf

=

G2

W g2
F Q2
4π

V M

R(s)

1
(cid:20)

Tf
T max
f

−

(cid:21)

(13)

where M is the mass of the nuclear target. The maximum value of Tf allowed by the reaction
kinematics is given in terms of the initial lab-frame neutrino energy Eν by

T max
f =

2E2
ν
2Eν + M

.

(14)

This process is known as coherent elastic neutrino-nucleus scattering (CEvNS) [38, 39]. The

nuclear recoil correction factor

R(s)

(s + M 2)2
4s2

≡

(15)

is usually neglected9 in the CEvNS literature (see, e.g., [111]). Due to its adoption of the allowed
approximation, the MARLEY treatment of CEvNS currently does not include a q2-dependent nuclear
form factor that accounts for imperfect coherence in the cross section [112].

8I take the neutron to be the isospin-up state of the nucleon, i.e., t−|n(cid:11) = |p(cid:11).
9Approximating R(s) ≈ 1 is accurate to zeroth order in Eν /M .

7

2.1.2. Coulomb corrections
In eq. (5), the symbol

deﬁned by

FCC is used to include extra factors needed solely for CC scattering. It is

Vud
|
1

2 FC CC
NC

|

FCC ≡ (cid:40)

(16)

where Vud is the Cabibbo–Kobayashi–Maskawa matrix element connecting the up and down quarks.
The Coulomb correction factor FC accounts for the electromagnetic interaction between the outgo-
ing lepton and nucleus in an approximate way. Three prescriptions for computing FC are available
in MARLEY: the Fermi function, the eﬀective momentum approximation (EMA), and the modiﬁed
eﬀective momentum approximation (MEMA).

Fermi function. For very low energies of the outgoing lepton (such as those observed in beta decay),
using the Fermi function [113, 114] as the Coulomb correction factor is a standard approach. A
minor complication emerges, however, because the derivation of the Fermi function10 assumes that
the ﬁnal nucleus is at rest, while the diﬀerential cross section in eq. (5) is evaluated in the CM
frame and accounts for nuclear recoil. To work around this discrepancy, MARLEY uses the relative
speed βrel of the two ﬁnal-state particles [116]

(k(cid:48)

βrel =

(cid:113)

·

p(cid:48))2

k(cid:48)

·

−
p(cid:48)

m2

(cid:96) m2
f

γrel

≡

β2
rel

1

−

−1/2

,

(17)

(cid:0)

(cid:1)

to evaluate the Fermi function in the rest frame of the ﬁnal nucleus using the Lorentz-invariant
expression

FFermi =

2(1 + S)

Γ(1 + 2S)

2 (2 γrel βrel m(cid:96) R)2S−2 e−π η

Γ (S

|

iη)

2 .
|

−

(18)

(cid:2)

(cid:3)

In eqs. (17) and (18), p(cid:48), mf , and Zf denote the 4-momentum, mass, and proton number of the
ﬁnal nucleus. Likewise, k(cid:48), m(cid:96), and z(cid:96) represent the 4-momentum, mass, and electric charge (in
units of the elementary charge) of the ﬁnal-state lepton. The quantity S is deﬁned in terms of the
ﬁne structure constant α by

while

S

≡

R

≈

α2Z 2
f

1

−

(cid:113)
1.2 A1/3 fm
(cid:126) c

is the nuclear radius (in natural units), and the Sommerfeld parameter η is given by

10See, e.g., ref. [115].

η =

α Zf z(cid:96)
βrel

.

8

(19)

(20)

(21)

(22)

(23)

Eﬀective momentum approximation. For higher energies of the outgoing lepton, the Fermi function
is known to overestimate the magnitude of the Coulomb corrections, and an alternative approach
called the eﬀective momentum approximation (EMA) becomes more appropriate [117]. Let the
symbol K (E) denote the momentum (total energy) of the outgoing lepton in the rest frame of the
ﬁnal nucleus:

Then the eﬀective values of these variables

E

≡

γrel m(cid:96)

K

≡

βrel E .

K eﬀ

≡

E 2

eﬀ −

m2
(cid:96)

E eﬀ

E

≡

−

VC(0),

(cid:113)

are those that exist in the presence of the nuclear Coulomb potential, which is taken to be that at
the center of a uniformly-charged sphere:

In the MARLEY implementation of the EMA, the Coulomb correction factor is given by the ratio11

VC(0)

3 Zf z(cid:96) α
2 R

.

≈

(24)

FEMA

K eﬀ
K

.

≡

(25)

Modiﬁed eﬀective momentum approximation. In ref. [117], an adjustment to the standard EMA
prescription is proposed which improves the accuracy of the approximation in cases where the ﬁnal
lepton mass cannot be neglected. Under this modiﬁed eﬀective momentum approximation (MEMA),
the Coulomb correction factor deﬁned in eq. (25) is replaced by

FMEMA =

K eﬀ E eﬀ
K E

.

(26)

Default behavior. The ﬁnal-state Coulomb interaction increases the charged-current cross section
for neutrinos and decreases it for antineutrinos. Because the (M)EMA is known to overestimate the
size of this eﬀect at low energies while the Fermi function does the same at high energies, previous
calculations [63, 118] have adopted a simple prescription for combining the two approaches: in any
particular case, adopt the method that yields the smallest Coulomb correction. For MARLEY, this
amounts to deﬁning the Coulomb correction factor FC by

FC

FFermi
FFermi
−
|
FMEMA otherwise

≡ (cid:40)

<

1

|

|

FMEMA

1
|

−

(27)

Although eq. (27) represents the default MARLEY approach to Coulomb corrections, this behavior
may be altered by the user in the job conﬁguration ﬁle (see section 6.7.5).

11The original EMA treatment also involves the use of an eﬀective value of the 4-momentum transfer while com-
puting the scattering amplitude. However, since the nuclear matrix elements in eq. (5) are already evaluated in the
limit of zero momentum transfer, MARLEY neglects this additional correction.

9

2.1.3. Total cross section

With the deﬁnitions given above, integration of eq. (5) over cos θ(cid:96) becomes trivial, leading to

the total cross section

σ =

G2
F
π FCC

Ei Ef
s

(cid:20)

E(cid:96)

p(cid:96)
|

|

(cid:21)

B(F) + B(GT)

(cid:20)

.
(cid:21)

(28)

2.2. Nuclear de-excitation model

De-excitations from high-lying nuclear levels are simulated in MARLEY using the Hauser-Feshbach
statistical model (HFSM) [110]. This model assumes that the decaying nuclear state may be
adequately described as a thermally-equilibrated compound nucleus with a deﬁnite excitation energy
(Ex), spin (J), and parity (Π). In the MARLEY HFSM implementation, emissions of γ-rays and light
nuclear fragments (1
4) are treated as a sequence of binary decays while ﬁssion, production
≤
of heavy nucleon clusters (A

5), and simultaneous multiparticle evaporation are neglected.

≤

A

≥

2.2.1. Nuclear fragment emission

According to the HFSM, the distribution of ﬁnal excitation energies E(cid:48)

x that may result from
the emission of a fragment a (with parity πa and separation energy Sa) from the compound nucleus
is described by the diﬀerential decay width

dΓa
dE(cid:48)
x

=

1
2 π ρi(Ex, J, Π)

(cid:96)max

(cid:96)+s

J+j

T(cid:96)j(ε) ρf (E(cid:48)

x, J (cid:48), Π(cid:48))

(29)

(cid:88)j=|(cid:96)−s|
where J (cid:48) is the ﬁnal nuclear spin; s, (cid:96), and j are the spin, orbital, and total angular momentum
quantum numbers of the emitted fragment;

(cid:88)J (cid:48)=|J−j|

(cid:96)=0
(cid:88)

−
is the value of the ﬁnal-state nuclear parity needed to enforce parity conservation; and ε is the
total kinetic energy of the decay products in the rest frame of the initial nucleus. The maximum
accessible ﬁnal-state excitation energy

Π(cid:48) = (

1)(cid:96) πa Π

(30)

is related to the total kinetic energy ε via

E(cid:48) max
x

= Ex

Sa

−

ε = E(cid:48) max
x

E(cid:48)
x.

−

(31)

(32)

The functions ρi and ρf represent the density of nuclear levels in the vicinity of the initial and ﬁnal
states, while the transmission coeﬃcient T(cid:96)j quantiﬁes how readily the fragment may be emitted
from the nucleus. Because the value of T(cid:96)j at ﬁxed ε falls oﬀ rapidly with increasing (cid:96), MARLEY
truncates the inﬁnite sum over orbital angular momenta using an upper limit (cid:96)max. By default,
(cid:96)max = 5 is used. This value may be adjusted by the user as described in section 6.7.4.

At low excitation energies, where individual nuclear levels can be resolved, MARLEY treats the
level density ρf as a sum of delta functions, with one term per level. For a speciﬁc nuclear level,
the partial decay width for emission of fragment a may be written in the form

Γa =

1
2 π ρi(Ex, J, Π)

J+J (cid:48)

j+s

(cid:88)j=|J−J (cid:48)|

(cid:88)(cid:96)=|j−s|

δ(cid:96)
π T(cid:96)j(ε)

10

(33)

where the symbol δ(cid:96)
zero if it is not.

π, which enforces parity conservation, is equal to one if eq. (30) is satisﬁed and

At higher excitation energies, MARLEY computes ρf according to the Back-shifted Fermi gas
model (BFM) from version 3 of the Reference Input Parameter Library (RIPL-3) [119]. The “BFM
eﬀective” values of the level density parameters for this model are adopted from a global ﬁt of nuclear
level data for 289 nuclides reported in ref. [120]. A full description of the BFM as implemented in
MARLEY is given in appendix B of ref. [108]. The initial level density ρi is always evaluated according
to the BFM regardless of excitation energy.

, E(cid:48) max
x

The partial decay width for a transition to the continuum of nuclear levels via emission of
a fragment a may be computed by integrating eq. (29) over the ﬁnal excitation energy interval
[E(cid:48) min,c
is taken by MARLEY to be the excitation
x
energy of the highest tabulated discrete nuclear level for the nuclide of interest. In cases where no
such level data are available, the continuum is taken to start at the nuclear ground state (E(cid:48) min,c
=
0).

]. The lower bound of the continuum E(cid:48) min,c

x

x

2.2.2. Fragment transmission coeﬃcients

The fragment transmission coeﬃcients T(cid:96)j that appear in eqs. (29) and (33) are computed by

numerically solving the radial Schr¨odinger equation

d2
dr2 + k 2

(cid:96)((cid:96) + 1)
r2

−

k 2
ε U

−

(cid:20)
where u(cid:96)j is the fragment’s radial wavefunction,

(r, εlab, (cid:96), j)

u(cid:96)j(r) = 0

(cid:21)

εlab =

ε2 + 2 (ma + M (cid:48)) ε
2M (cid:48)

is its kinetic energy in the rest frame of the ﬁnal nucleus,12 and

k =

(cid:115)

(2 ma + εlab) M (cid:48)2 εlab
(ma + M (cid:48))2 + 2 M (cid:48) εlab

(34)

(35)

(36)

is the magnitude of its 3-momentum in the rest frame of the initial nucleus. In eqs. (35) and (36),
ma (M (cid:48)) denotes the mass of the emitted fragment (ﬁnal nucleus).

The optical potential

used by MARLEY for nucleon emission is the global parameterization of
Koning and Delaroche [121]. For complex nuclear fragments, a folding approach similar to that of
Madland [122] is used to construct the optical potential by weighting the individual neutron and
proton potentials. More details about the MARLEY nuclear optical potential are available in appendix
C of ref. [108].

U

Far from the nucleus, the optical potential approaches the Coulomb potential, and the fragment

radial wavefunction approaches the limiting form

lim
r→∞

u(cid:96)j(r) =

i
2

(cid:2)

H −

(cid:96) (η, k r)

S(cid:96)j

(cid:105)

− (cid:104)

H +

(cid:96) (η, k r)

(cid:3)

(37)

12The label lab for this quantity reﬂects it status as the laboratory-frame kinetic energy in the time-reversed

process wherein the fragment is absorbed to form the compound nucleus. See appendix A of ref. [108].

11

where H ±

(cid:96) are the Coulomb wavefunctions [123, ch. 33]. The Sommerfeld parameter

is evaluated in terms of the proton number z (Z (cid:48)) of the emitted fragment (ﬁnal nucleus) and the
relative speed

z Z (cid:48) α
βrel

η

≡

(38)

The energy-averaged S-matrix element
coeﬃcient T(cid:96)j via

S(cid:96)j
(cid:104)

βrel =

(cid:112)

(cid:105)

ε2
lab + 2 ma εlab
ma + εlab

.

(39)

that appears in eq. (37) is related to the transmission

(40)
, MARLEY ﬁrst obtains a numerical solution u(cid:96)j(r) of eq. (34) using Numerov’s
To approximate
(cid:105)
method [124–126]. This method computes u(cid:96)j iteratively on a regular grid with ﬁxed radial step
size ∆. If one deﬁnes the function a(cid:96)j(r) to be equal to the non-derivative terms enclosed in square
brackets in eq. (34), i.e.,

S(cid:96)j
(cid:104)

− |(cid:104)

S(cid:96)j

T(cid:96)j

≡

(cid:105)|

1

2 .

−
then the Numerov solution (accurate to order ∆4) un

≡

−

a(cid:96)j(r)

k 2

(cid:96)((cid:96) + 1)
r2

k 2
ε U

(r, εlab, (cid:96), j),

is given by the recurrence relation

rn = n ∆

un =

(2

−

and boundary conditions

10 h an−1) un−1

(1 + h an−2) un−2

−

(1 + h an)

u(cid:96)j(rn) at the nth grid point

≈

n

0, 1, 2, . . .

∈{

}

(41)

(42)

(43)

(44)

(45)

0.

n

2

≥

1, with a0

The MARLEY calculation of

proceeds through iterations of the Numerov method until the

a(cid:96)j(rn) for n

≡

≥

≡

Here I have deﬁned the abbreviations h

ﬁrst grid point rA is encountered such that

≡

S(cid:96)j

(cid:104)

(cid:105)

that is, the diﬀerence between the nuclear optical potential
falls below a small threshold Vthresh.
encountered such that

and the Coulomb potential VC
Iterations continue further until a second grid point rB is

U

(cid:12)
(cid:12)

(cid:12)
(cid:12)

(rA)

U

−

VC(rA)

≤

Vthresh ,

(46)

In MARLEY 1.2.0, the parameter values ∆ = 0.1 fm / (cid:126) c, Vthresh = 1 keV and

rB

rA .

≥ S

(47)

= 1.2 are used.

Comparing the full solution obtained in this way to the asymptotic form from eq. (37) at rA

S

and rB leads to the expression

S(cid:96)j

(cid:104)

(cid:105) ≈

u(cid:96)j(rA) H −(η, k rB)
u(cid:96)j(rA) H +(η, k rB)

u(cid:96)j(rB) H −(η, k rA)
u(cid:96)j(rB) H +(η, k rA)

.

(48)

−
−

Numerical values of the Coulomb wavefunctions are obtained by interfacing with the GNU Scientiﬁc
Library [1, 2].

12

u0 = 0
u1 = ∆(cid:96)+1.
∆2/12 and an

2.2.3. Gamma-ray emission

In the Hauser-Feshbach formalism, γ-ray emission is described by the diﬀerential decay width

dΓγ
dE(cid:48)
x

=

1
2 π ρi(Ex, J, Π)

λmax

J+λ

TXλ(Eγ) ρf (E(cid:48)

x, J (cid:48), Π(cid:48))

(49)

(cid:88)J (cid:48)=|J−λ| (cid:88)Π(cid:48)∈{−1,1}

E(cid:48)

x is the energy of the emitted γ-ray,13 and

−

λ=1
(cid:88)
Ex

where λ

≥

1 is the multipolarity, Eγ

≈

X =

(cid:40)

E Π = (
M Π = (

1)λ Π(cid:48)
1)λ+1 Π(cid:48)

−
−

(50)

labels the type of transition as either electric (E) or magnetic (M). The inﬁnite sum over multipo-
larities in eq. (49) is truncated at λmax. The default cutoﬀ value λmax = 5 may be conﬁgured by
the user as described in section 6.7.4.

The calculation of the level densities ρi and ρf is identical to the approach used for nuclear
fragment emission (see section 2.2.1). In particular, the level density ρf used for γ-ray transitions
to discrete levels is once again treated as a sum of delta functions. The partial decay width for
γ-ray emission to a particular nuclear level then becomes

Γγ =

1
2 π ρi(Ex, J, Π)

J+J (cid:48)

(cid:88)λ=max(1,|J−J (cid:48)|)

TXλ(Eγ) .

(51)

If J + J (cid:48) < 1, the width Γγ vanishes.

Similarly to the fragment emission case, calculation of the partial decay width for γ-ray tran-
sitions to the continuum of nuclear levels is performed by integrating eq. (49) over the interval
, E(cid:48) max
[E(cid:48) min,c
is handled as in section 2.2.1, while the upper
x
x
bound becomes

]. The continuum lower bound E(cid:48) min,c

x

E(cid:48) max
x

= Ex .

(52)

2.2.4. Gamma-ray transmission coeﬃcients

The transmission coeﬃcients TXλ that appear in eqs. (49) and (51) are typically expressed in

terms of a strength function fXλ(Eγ) such that

In MARLEY 1.2.0, the expression used to evaluate the strength function

TXλ(Eγ) = 2 π E2λ+1

γ

fXλ(Eγ) .

fXλ(Eγ) =

σXλ
(2λ + 1) π2

Xλ E3−2λ
Γ2
γ
E2
Xλ)2 + E2

γ Γ2

(E2

γ −

(cid:20)
is taken from the RIPL-3 Standard Lorentzian model [119]. According to this model, γ-ray emis-
sions of type Xλ are assumed to take place via de-excitation of the corresponding giant multipole
resonance, which has centroid excitation energy EXλ, width ΓXλ, and peak cross section σXλ. A
full listing of the values of these parameters is given in Table II of ref. [108].

Xλ (cid:21)

(53)

(54)

13Although MARLEY uses the approximate expression for Eγ given here to compute γ-ray decay widths, corrections

for nuclear recoil are handled exactly when the actual emission is simulated.

13

Neutrino

νe
¯νe
νµ, ντ
¯νµ, ¯ντ

g1
1/2 + sin2 θW
sin2 θW
1/2 + sin2 θW
sin2 θW

−

g2
sin2 θW
1/2 + sin2 θW
sin2 θW
1/2 + sin2 θW

−

Table 1: Coupling constants used in calculations of neutrino-electron elastic scattering. Values are given in terms of
the weak mixing angle θW .

2.3. Neutrino-electron elastic scattering

In addition to neutrino-nucleus scattering, MARLEY is also capable of simulating neutrino-electron
elastic scattering. For a target atom with proton number Z, the diﬀerential cross section in the
CM frame for this process is computed according to

dσ
d cos θν

=

F E2
2ZG2
ν
π

g2
1 +
(cid:20)

g1 g2 m2
e
s

(cos θν

−

1) + g2
2

1 +

(cid:18)

m2
e
s

−

1
2

1

(cid:104)

(cid:105)(cid:104)

cos θν

1

−

2

(cid:105)(cid:19)

(cid:21)

(55)

where me is the electron mass and Eν (θν) is the energy (scattering angle) of the neutrino. The
coupling constants g1 and g2 depend on the neutrino species and are given in table 1. Electron
binding energies are neglected.

3. Random sampling implementation

Like any other Monte Carlo event generator, MARLEY must make extensive use of pseudorandom
numbers and produce samples from a variety of discrete and continuous probability distributions.
With the advent of C++11, a suite of high-quality random number generation tools were adopted
as part of the C++ standard library [127], and MARLEY relies heavily on these new features. All
random numbers used by MARLEY are obtained using the C++ standard library object std::mt19937
64, which provides a 64-bit implementation of the Mersenne Twister algorithm developed by M.
Matsumoto and T. Nishimura [128, 129].

3.1. Discrete distributions

All sampling from discrete distributions is handled using instances of the C++ standard library
object std::discrete distribution. In cases where the sampling weights for each possible out-
come already exist in memory, the usual method for initializing this object is to supply iterators
that point to the beginning and end of a collection of sampling weights. For example, line 5 of the
code snippet14

1

2

# include < random >
# include < vector >

14The examples given in this section make use of a C++17 feature (class template argument deduction) in order
to avoid code clutter that is unimportant for a conceptual understanding. In the MARLEY 1.2.0 source code, the std::
discrete distribution and marley::IteratorToMember class templates are used in a manner that is compatible
with C++14.

14

3

4

5

6

7

8

9

10

11

12

std :: vector < double > weights = { 1. , 2. };
std :: d is cr e t e_d is t r i but ion dist1 ( weights . begin () , weights . end () ) ;

initializes a std::discrete distribution object dist1 which will sample int values of 0 (1) with
probability 1/3 (2/3).

When the sampling weights are stored as object data members, however, initializing the dis-
tribution becomes more complicated. In particular, a na¨ıve attempt using the approach from the
example above

struct A {

A ( double w ) : weight ( w ) {}
double weight ;

};

std :: vector <A > As = { A (1.) , A (2.) };
std :: d i sc r et e _d ist r i b ut ion dist2 ( As . begin () , As . end () ) ;

triggers a compilation error on line 12. Because the iterators returned by As.begin() and As.end()
refer to objects of type A instead of the weights (of type double), they cannot be used to initialize
dist2.

MARLEY works around this diﬃculty by implementing the iterator to member interface pro-
posed by T. Becker [130]. This interface converts an iterator that points to an object (A) into an
iterator that points to one of that object’s data members (weight).
In this example, including
the appropriate MARLEY header ﬁle (include/marley/IteratorToMember.hh) and replacing line
12 with

12

13

14

marley :: IteratorToMember w_begin ( As . begin () , & A :: weight ) ;
marley :: IteratorToMember w_end ( As . end () , & A :: weight ) ;
std :: d i sc r et e _d ist r i b ut ion dist2 ( w_begin , w_end ) ;

compiles successfully and yields the same sampling behavior for dist2 as for dist. For cases in
which the input iterators refer to object pointers instead of the objects themsleves, MARLEY provides
a similar interface via the marley::IteratorToPointerMember class template, which is compatible
with both bare (e.g., A*) and smart pointers (e.g., std::unique ptr<A>).

This approach is used in several places in the MARLEY source code to initialize discrete distri-
butions using sampling weights stored as object data members, e.g., relative intensities owned by
marley::Gamma objects representing distinct γ-ray de-excitations from a particular nuclear energy
level.

3.2. Continuous 1D distributions: accept/reject approach

To sample from continuous one-dimensional distributions, MARLEY implements two general schemes,

both of which take the bounds of a sampling interval [a, b] and an arbitrary probability density func-
tion f (x) (for which no particular normalization is assumed) as input. The ﬁrst scheme uses a simple
rejection method which relies on an accurate knowledge of the global maximum fmax of f (x) within
the sampling interval. If fmax is known in advance, it may be supplied along with the other input
parameters. Otherwise, it is estimated within a speciﬁed tolerance by minimizing
f (x) using
Brent’s method [131]. Once the value of fmax has been obtained, pairs of uniformly-distributed
f (x), at
variables x
which point the sampled x value is accepted.

[0, fmax] are repeatedly sampled. This continues until y

[a, b] and y

≤

−

∈

∈

15

3.3. Continuous 1D distributions: inverse transform approach

In cases where the global maximum fmax is unknown and its estimation via Brent’s method is
either unreliable (because a local maximum may be found instead of the global one) or ineﬃcient
(because f is computationally expensive to evaluate), MARLEY employs a second sampling scheme
based on the “fast inverse transform sampling” algorithm originally proposed in ref. [109]. Although
MARLEY uses numerical techniques similar to those in the original Matlab code [132], which was
written as an extension of the Chebfun package [133, 134], the C++ implementation described herein
is original. To the author’s knowledge, MARLEY represents the ﬁrst application of this algorithm to
physics event generation.

3.3.1. Algorithm

To obtain a random sample x from f (x) using inverse transform sampling, MARLEY ﬁrst constructs
,

a polynomial approximant ˜f of f using a grid of N + 1 ordered pairs (xj, fj) for j
where the xj are the Chebyshev points of the second kind

0, 1, . . . , N

∈ {

}

a + b + (b

xj =

−

a) cos(πj/N )
2

(56)

and the fj are the function values

(57)
At points other than the xj (where fj is used directly), the polynomial approximant ˜f is given by
the barycentric formula [135]

f (xj).

fj

≡

˜f (x)

with weights

N

≡ 

j=0
(cid:88)



1) j wN
(
j
−
xj
x

−

fj

N

(





(cid:44) 


j=0
(cid:88)

1) j wN
j
−
xj 
x

−



1/2

j = 0 or j = N

1

otherwise.

wN

j ≡ 


(58)

(59)

The fj are related to the coeﬃcients αk that appear in an N th order expansion of f in Chebyshev
polynomials Tk, i.e.,



f (x)

N

≈

k=0
(cid:88)

wN

k αk Tk(u(x))

u(x)

2

≡

a
a

x
b

−
−

(cid:18)

1,

−

(cid:19)

by the type-I discrete cosine transform (DCT-I)

αk =

f0 + (

1)kfN

+

−
N

2
N

N −1

j=1
(cid:88)
To approximate the cumulative density function (CDF)

fj cos

πjk
N

.

(cid:19)

(cid:18)

F (z)

z

≡

a
(cid:90)

f (x) dx, z

[a, b]

∈

16

(60)

(61)

(62)

(63)

(64)

(65)

(66)

MARLEY uses the formulas

T1(y) + 1

y

−1

(cid:90)

Tk(u) du = 



1
4 [T2(y)

−
Tk+1(y)

1]

k+1 −

1
2

(cid:104)

Tk−1(y)
k−1

+ (−1)k+1
k2−1

(cid:105)

k = 0

k = 1

k

2

≥

to integrate eq. (60) term-by-term, yielding an (N + 1)th order Chebyshev expansion

F (z)

≈

N +1

k=0
(cid:88)

wN +1
k

βk Tk(u(z))

where the coeﬃcients βk are given by

βk =

a

b

−
2

Bk

(cid:19)

(cid:18)

with

Bk

≡

N

1) j
j2

αj(
1

−
−

j=2
(cid:80)
αk+1)

α0

−

1
2 α1 + 2

1
2k (αk−1
1
2k αk−1

−

k = 0

k > 0 and k < N

k = N or k = N + 1.






One may obtain a polynomial approximant ˜F of the cumulative density function F by applying a
second DCT-I (which is its own inverse) to the expansion coeﬃcients βk:

β0 + (

F(cid:96) =

1)(cid:96)βN +1
−
2

N

+

βk cos

k=1
(cid:88)

πk(cid:96)
N + 1

.

(cid:19)

(cid:18)

Using the N + 1 Chebyshev points

x(cid:96) =

a + b + (b

−

a) cos(π(cid:96)/[N + 1])

2

,

(67)

(68)

one may approximate F (x) for any x
and N

N + 1.

[a, b] using eq. (58) with the substitutions f

F , j

(cid:96),

→

→

∈

→

With the approximate CDF ˜F (x) constructed in this manner, MARLEY obtains a random sample
[0, 1]. Bisection is then used to ﬁnd the

x from f (x) by generating a uniform random number ξ
sampled value of x

[a, b] which satisﬁes the relation

∈

∈

3.3.2. Validation

ξ = ˜F (x)

˜F (b) .

(cid:14)

(69)

Figure 1 shows an application of this sampling technique to the modeling of compound nuclear
decays in MARLEY. In the left-hand plot, the black histogram shows the spectrum of proton kinetic
p + 39Ar to the excitation energy
energies Tp obtained from a simulation of 200,000 decays 40K
continuum of the daughter 39Ar nucleus. The initial 40K state had excitation energy Ex = 45 MeV

→

17

Figure 1: Validation of MARLEY’s inverse transform sampling algorithm using simulations of proton (left) and γ-ray
(right) emission to the continuum from a highly-excited 40K state.

and spin-parity J π = 4+. Decay modes other than proton emission to the continuum were switched
oﬀ for simplicity, and the kinetic energy Tp is reported in the rest frame of the mother 40K nucleus.
The contents of each histogram bin are normalized to provide a calculation of the diﬀerential decay
width dΓp/dTp, where the average value of this quantity in the wth bin is approximated by the
Monte Carlo estimator

dΓp
dTp (cid:29)w ≈

(cid:28)

nw Γp
Nevents ∆Tw
p

.

(70)

Here Nevents = 200,000 is the total number of simulated decay events, nw is the number of these
that fall within the wth bin, ∆Tw
p is the width of the wth bin, and Γp is the total width for proton
emission to the continuum.

The blue curve shows a direct calculation of the diﬀerential decay width via

dΓp
dTp

=

M
M (cid:48)

dΓp
dE(cid:48)
x

(71)

where M (M (cid:48)) is the mass of the initial (ﬁnal) nucleus and dΓp/dE(cid:48)
x is evaluated according to
eq. (29) with the fragment species a = p. The agreement seen between the exact calculation and
the simulated events is achieved by sampling the latter from a CDF constructed using a Chebyshev
polynomial approximant to dΓp/dE(cid:48)
x with grid size N = 64. The polynomial approximant with
N = 64 and the exact calculation are indistinguishable on the scale of the plot. For reference, a
lower-order (N = 4) Chebyshev polynomial approximation to the distribution is also shown by the
dotted purple line.

The right-hand plot in ﬁg. 1 shows simulation results obtained using an identical procedure,
γ + 40K is considered using the diﬀerential width from
except that the decay process 40K
eq. (49). Three lower-order Chebyshev approximants are shown which provide improved agreement
with the exact calculation as the grid size N grows.

→

3.3.3. Implementation details

Although the barycentric interpolation scheme described here is used in MARLEY solely for in-
verse transform sampling, the C++ implementation is very general and may ﬁnd useful applications

18

0246810121416182022240.000.200.400.600.801.001.201.401.60×10−2Tp(MeV)dΓp/dTpN=4EventsExact051015202530350.000.200.400.600.801.001.201.401.60×10−5Eγ(MeV)dΓγ/dEγN=4N=8N=16EventsExactelsewhere. The marley::ChebyshevInterpolatingFunction class constructs the polynomial inter-
polant ˜f for an arbitrary input function f (x), represented by a std::function<double(double)>.
If the grid size N is not speciﬁed in the constructor, then an adaptive technique is used to choose a
grid size suﬃciently large to represent f (x) at close to machine precision. Starting with N = 2, the
value of N is doubled (and the Chebyshev expansion coeﬃcients are recomputed) until the stopping
criterion

αm < 2 ε max(α0, α1, . . . , αN )

m = N, N

1

−

(72)

(with machine epsilon ε) is satisﬁed or N reaches a large maximum value. The evaluate(double
x) member function returns the value of ˜f (x), and the cdf() member function returns a new marley
::ChebyshevInterpolatingFunction representing ˜F (x). The DCT-I calculations in eqs. (61)
and (67) are carried out using the fast Fourier transform C library FFTPACK4 [136], which is included
in the MARLEY source code distribution. This library is based on the original FFTPACK Fortran code
developed by P. Swarztrauber [137, 138].

No simultaneous sampling of multiple variables from a joint probability distribution is needed

to implement the physics models in the current version of MARLEY.

4. Event generation workﬂow

The ﬂowchart in ﬁg. 2 illustrates the procedure used by MARLEY to generate events. In the fol-
lowing paragraphs, each stage in the process will be described. Unless otherwise noted by providing
an explicit namespace speciﬁer (e.g., std::), all C++ classes referred to using typewriter font in
this section are deﬁned within the marley namespace.

4.1. Generator initialization

At the beginning of an event generation job, a JSONConfig object is used to parse and in-
terpret the settings stored in a conﬁguration ﬁle (whose format is described in section 6). The
create generator member function is then used to construct a Generator object which handles
the actual simulation of events. The steps below are followed to initialize the Generator.

4.1.1. Set random number seed

If the user has speciﬁed an integer value for the random number seed in the conﬁguration ﬁle (see
section 6.1), then this value is used to initialize a std::mt19937 64 object owned by the Generator.
If not, then the system time since the Unix epoch is used as a seed.

4.1.2. Set neutrino direction

By default, MARLEY generates events in a reference frame in which the incident neutrino is
traveling in the positive z direction.
If the user has speciﬁed a diﬀerent neutrino direction (see
section 6.2), then this information is passed to a ProjectileDirectionRotator object owned by
the Generator. A rotation matrix is precalculated which will allow the coordinate system to be
appropriately transformed at the end of each iteration of the event loop.

19

2
0

Figure 2: Illustration of the workﬂow used by MARLEY to generate neutrino-nucleus scattering events.

4.1.3. Deﬁne incident neutrino spectrum

Based on the user’s description of the neutrino energy spectrum (see section 6.5), one of several
derived classes of the NeutrinoSource abstract base class is instantiated and stored as a member
of the Generator object. In typical MARLEY use cases, the NeutrinoSource describes the energy
distribution of incident neutrinos. This behavior is desirable so that the energy spectrum P (Eν)
of reacting neutrinos

P (Eν) =

φ(Eν) σ(Eν)

Emax
ν
Emin
ν

φ(Eν) σ(Eν) dEν

Emin

ν ≤

Eν

≤

Emax
ν

(73)

(cid:82)

where φ(Eν) is the NeutrinoSource spectrum and σ(Eν) is the total cross section, is fully consistent
with the MARLEY physics models. In unusual situations where cross section weighting is not wanted
(e.g., event generation with a uniform distribution of reacting neutrino energies), it may be disabled
in the job conﬁguration ﬁle as described in section 6.7.3. This corresponds to the substitution
σ(Eν)

1 in eq. (73).

→

4.1.4. Conﬁgure reactions

→

Each distinct 2

2 scattering mode that may be simulated during a MARLEY job is represented by
an object that implements the abstract base class Reaction. This class includes member functions
called total xs and diff xs, which respectively compute (in units of MeV−2 per target atom)
the reaction total cross section σr(Eν) and diﬀerential cross section d σr(Eν)/d cos θ(cid:96), where θ(cid:96) is
the lepton scattering angle in the CM frame. The create event member function simulates the
scattering process using these quantities (see sections 4.2.3 and 4.2.4) and returns the results in a
newly-created Event object.

Based on the set of one or more scattering modes enabled by the user in the conﬁguration ﬁle (see
section 6.4), a vector of pointers to Reaction objects is initialized during job startup and stored
as the reactions member of the Generator. This vector is populated by calls to the factory
method Reaction::load from file, which processes a reaction speciﬁcation given in an input
ﬁle (see section 6.4 and appendix B). After all reaction input ﬁles have been fully processed, the
abundance-weighted sum σ(Eν) of the total cross sections σr(Eν) for all of the enabled reactions
is used together with the NeutrinoSource spectrum φ(Eν) to construct the probability density
function for reacting neutrino energies P (Eν) shown in eq. (73). The weights needed to compute
σ(Eν) are the nuclide fractions in the neutrino target, as described in section 4.1.6.

In MARLEY 1.2.0, two concrete derived classes of Reaction are implemented. The Nuclear
Reaction class implements the neutrino-nucleus scattering model described in section 2.1, while
the ElectronReaction class does the same for the neutrino-electron elastic scattering model from
section 2.3.

While simulating a neutrino-nucleus scattering event, MARLEY represents the nuclear state in
terms of the following quantities: the proton number Z, nucleon number A, excitation energy
above the ground state Ex, total spin J, and parity Π. The values of these variables are tracked
2 scattering (section 4.2) and during simulation of
throughout the event loop, both during 2
nuclear de-excitations (section 4.3).

→

A distinction is made in MARLEY between bound versus unbound nuclear states. A nuclear state
is considered to be unbound if the excitation energy Ex exceeds the separation energy for at least
4. Separation energies are computed using atomic and
one nuclear fragment with mass number A
particle mass data from refs. [139, 140] tabulated in the ﬁle data/mass table.js. The singleton

≤

21

class MassTable provides a C++ API for accessing and manipulating these data. If an atomic mass
value is not tabulated for a particular nuclide, the MassTable class computes an estimate using a
formula for the liquid-drop model mass excess developed by Myers and Swiatecki [120, 141].

→

A set of transition matrix elements to the ﬁnal nuclear states that may be populated by means of
2 neutrino-nucleus scatter are represented in MARLEY by a vector of MatrixElement objects.
a 2
Each of these objects is labeled as either a Fermi or Gamow-Teller matrix element (see section 2.1)
using the type member variable, while the strength member stores the corresponding B(F) or
B(GT) value. These quantities are given in the reaction input ﬁle together with the ﬁnal nuclear
excitation energy, which is stored as the MatrixElement member level energy . A Nuclear
Reaction is constructed using a std::shared ptr to a vector of MatrixElement objects, allowing
shared ownership between multiple reactions as appropriate.

While parsing an input ﬁle repesenting a neutrino-nucleus reaction, the static method Reaction
::load from file constructs one MatrixElement object for each listed nuclear transition. After the
full list of transitions has been processed, a StructureDatabase object owned by the Generator
is consulted to determine whether discrete level data are available for the ﬁnal-state nucleus of
interest. The ﬁrst such query will trigger loading of these data in the form of DecayScheme objects
as described in section 4.1.5. If a suitable DecayScheme is available, then every MatrixElement
which represents a transition to a bound nuclear ﬁnal state is matched to a Level object owned
by the DecayScheme. This matching is performed by selecting the Level whose excitation energy
most closely matches the value of the MatrixElement’s member variable level energy . Duplicate
matches occurring for two MatrixElement objects belonging to the same NuclearReaction will
lead to an exception being thrown. A successful match will result in the MatrixElement’s member
variable final level being loaded with a pointer to the matched Level. If the spin-parity of the
matched Level is not compatible with the relevant selection rules (from either eq. (8) or eq. (9)),
then a warning message will be printed to the screen.

Matching of this kind is not performed for MatrixElement objects representing transitions to
unbound nuclear states. In such cases (or when an appropriate DecayScheme is not available), a
null pointer is assigned to the final level member.

4.1.5. Load nuclear structure data

To simulate nuclear transitions at low excitation energies, MARLEY relies on tabulated nuclear
structure data ﬁles. These ﬁles contain listings of discrete nuclear energy levels and branching ratios
for γ-ray transitions between them. The ﬁle format is documented in appendix A.

For MARLEY 1.2.0, the recommended structure data ﬁles are largely taken (with reformatting)
from version 1.6 of the TALYS nuclear reaction code [105, 106]. The data are organized by element
in the folder data/structure/. This folder also includes a text ﬁle named nuclide index.txt
which serves as an index for the entire dataset: each line of the text ﬁle has the format

NucPDG

DataFileName

where NucPDG is an integer PDG code (see section 7.1) representing a nuclear species and DataFile
Name is the name of the corresponding ﬁle (assumed to appear in data/structure/) in which its
discrete level data are given.

A StructureDatabase object owned by the Generator provides an interface for accessing and
manipulating nuclear structure data within MARLEY. The StructureDatabase manages a lookup
table indexed by nuclear PDG code that stores pointers to DecayScheme objects. Each Decay
Scheme represents a table of nuclear levels and γ-ray branching ratios for a particular nuclide. A

22

fully-initialized DecayScheme owns one Level object for every discrete level listed for the nuclide
of interest in the associated structure data ﬁle. Each Level itself owns one Gamma object for each
listed γ-ray transition that may originate from it.

External access to the DecayScheme objects is provided by the StructureDatabase member
function get decay scheme. This function takes a nuclear PDG code or a (Z, A) pair as input.
If a corresponding DecayScheme already exists in the lookup table, a pointer to it is immediately
returned. If a suitable DecayScheme has not been constructed yet, the StructureDatabase consults
the nuclide index (which is automatically loaded from nuclide index.txt when needed and cached
for repeated use) in an attempt to ﬁnd a matching structure data ﬁle. If a match is found, Decay
Scheme objects are constructed and added to the lookup table for every nuclide listed in the ﬁle. A
pointer to the requested DecayScheme is then returned if it was successfully loaded. A null pointer
is stored in the lookup table and returned when the attempt to load the requested DecayScheme
fails.

Additional information indexed by nuclear PDG code is also stored in the StructureDatabase,
including (1) ground-state nuclear spin-parities15 loaded from the ﬁle data/structure/gs spin
parity table.txt and (2) three varieties of objects (represented by the abstract base classes Level
DensityModel, OpticalModel, and GammaStrengthFunctionModel) used to compute quantities of
In MARLEY 1.2.0,
interest for the Hauser-Feshbach statistical model (see sections 2.2 and 4.3.1).
these three abstract base classes each have a single concrete implementation which is used for
calculations.16 The BackshiftedFermiGasModel class is derived from LevelDensityModel and
computes nuclear level densities (e.g., ρi and ρf in eq. (29)) as described in section 2.2.1. The
KoningDelarocheOpticalModel class is derived from OpticalModel and computes nuclear frag-
ment transmission coeﬃcients using the procedure outlined in section 2.2.2. Finally, the Standard
LorentzianModel class is derived from GammaStrengthFunctionModel and computes the γ-ray
strength function from eq. (54) as described in section 2.2.4.

Beyond the nuclide-speciﬁc items managed by the StructureDatabase, there are also two set-
tings which are common to all nuclei: the cutoﬀ values (cid:96)max and λmax used to truncate the sums
in eq. (29) and eq. (49), respectively, (see sections 2.2.1, 2.2.3 and 6.7.4) and a list (elements of
which are represented by the Fragment class) of the nuclear fragments to consider when simulating
decays using the Hauser-Feshbach model.

4.1.6. Deﬁne target

In a MARLEY simulation, the isotopic composition of the material illuminated by the incident
neutrinos is represented by a Target object owned by the Generator. In the absence of an explicit
list of abundances speciﬁed by the user (see section 6.3), MARLEY assumes equal amounts of each
nuclide that appears in the initial state of at least one conﬁgured Reaction. Using the information
stored in the Target object, the Generator computes the abundance-weighted total cross section
per target atom via

σ(Eν) =

fr σr(Eν)

(74)

where fr is the nuclide fraction for the initial-state atom involved in the rth Reaction.

r
(cid:88)

15Also obtained from nuclear structure data ﬁles included with TALYS 1.6
16A second GammaStrengthFunctionModel implementation, WeisskopfSingleParticleModel, is preserved in the

code base for historical interest but has been deprecated.

23

4.1.7. Enable/disable nuclear de-excitations

By default, MARLEY simulates both the prompt 2

2 scattering reaction and the subsequent
nuclear de-excitations for every event. In applications where only the prompt reaction is important,
the user may disable de-excitations as described in section 6.7.2. The choice of whether or not to
simulate de-excitations is represented as a boolean member variable owned by the Generator object.

→

4.2. Event loop: 2

2 scattering

→

After the Generator object has been fully initialized, the marley command-line executable
enters an event loop. This loop iterates until a ﬁxed number of events requested by the user (see
section 6.6) has been reached or the loop is interrupted (by an error condition or by the user pressing
ctrl+C). A single event loop iteration corresponds to a call to the Generator member function
create event. This function returns an Event object constructed according to the following steps.

4.2.1. Neutrino energy selection

In the ﬁrst step of the event loop, the Generator employs rejection sampling (see section 3.2)
to select a reacting neutrino energy from the probability distribution P (Eν) deﬁned in eq. (73). By
default, Brent’s method is used during the ﬁrst event loop iteration to obtain a numerical estimate
Pmax of the maximum value of the probability density function P (Eν). The value of Pmax is cached
and reused during neutrino energy sampling for subsequent events.

In cases where Brent’s method fails to converge to the global maximum of P (Eν), the resulting
distribution of Eν in the generated events will be biased, with too few events produced in energy
regions where P (Eν) is larger than Pmax. At the start of each pass through the event loop, MARLEY
veriﬁes that all values of P (Eν) computed during rejection sampling never exceed Pmax.
If the
cached value of Pmax is ever found to be an underestimate of the true global maximum, an error
message is printed (see listing 2 in section 5.4.1 for an example), and the value of Pmax is updated
to match the largest value of P (Eν) encountered.

Users can override the default use of Brent’s method by supplying their own values of Pmax in
the job conﬁguration ﬁle. Instructions for doing so can be found in section 6.7.7. For convenience in
troubleshooting, the error message printed by MARLEY in response to a rejection sampling problem
contains a recommended value of Pmax to use in this way.

4.2.2. Reaction mode sampling

Once a reacting neutrino energy Eν has been chosen, the Generator samples a speciﬁc reaction

mode r from the discrete probability distribution

P (r) =

fr σr(Eν)
σ(Eν)

.

(75)

Control then passes to the create event member function of the rth Reaction object owned by
the Generator. This function handles selection of 2
2 scattering kinematics and initializes an
Event object.

→

4.2.3. Selection of a nuclear transition

If the sampled reaction mode involves scattering on a nuclear target, then simulation of the
2 reaction is handled by the NuclearReaction class, and the outgoing nucleus may

prompt 2

→

24

be left in one of potentially many ﬁnal states. A speciﬁc ﬁnal state is chosen for a nuclear reaction
by selecting a MatrixElement according to the discrete distribution

P (Λ) =

σr(Eν, Λ)
σr(Eν)

(76)

where σr(Eν, Λ) is the partial reaction cross section computed for the Λth MatrixElement owned
by the NuclearReaction of interest. That is, σr(Eν, Λ) is given by the expression in eq. (28) with
the quantity B(F) + B(GT) set equal to the strength member of the Λth MatrixElement. The
total cross section σr(Eν) is obtained by summing over all of the owned MatrixElement objects
which represent energetically-accessible nuclear transitions:

σr(Eν) =

σr(Eν, Λ)

(77)

Λ
(cid:88)

If the sampled MatrixElement has been matched to a known discrete nuclear Level (i.e., if its
member pointer final level is non-null, see section 4.1.4), then the excitation energy, spin, and
parity of the ﬁnal nucleus are determined directly from the Level object.

If a match is not available (e.g., because the associated nuclear state is unbound), then the
ﬁnal nuclear excitation energy Ex is set equal to the sampled MatrixElement’s member variable
level energy . The ﬁnal-state spin J and parity Π are determined according to the selection rules
given in either eq. (8) or eq. (9) as appropriate for the MatrixElement type.
In the case of a
Gamow-Teller transition involving an initial nucleus with nonzero spin (as determined using the
table of ground-state spin-parities managed by the StructureDatabase, see section 4.1.5), multiple
J values will satisfy the spin selection rule in eq. (9). In such cases, MARLEY 1.2.0 makes a rough
approximation: equipartition of spin is assumed, and a deﬁnite value of J is sampled from the
discrete distribution

P (J) =

ρ(Ex, J, Π)
K ρ(Ex, K, Π)

(78)

where ρ (which is calculated using the same level density treatment as in section 2.2.1) is the density
of ﬁnal-state nuclear levels with spin J and parity Π in the vicinity of excitation energy Ex. In
eq. (78), the sum in the denominator runs over all ﬁnal spin values K that satisfy the Gamow-Teller
spin selection rule from eq. (9).

(cid:80)

4.2.4. Outgoing lepton direction

Due to the simple kinematics of 2

2 scattering, the 4-momenta of the outgoing particles
are fully determined by specifying their masses (including the ﬁnal nuclear excitation energy) and
the direction of the outgoing lepton. This direction is represented in MARLEY using the lepton’s
azimuthal scattering angle φ(cid:96) and polar scattering cosine cos θ(cid:96), both measured with respect to the
incident neutrino direction in the center-of-momentum (CM) frame.

→

For all reactions currently implemented in MARLEY 1.2.0, the diﬀerential cross section is indepen-
dent of φ(cid:96), and the value of this variable is therefore sampled uniformly on the half-open interval
[0, 2π).

For neutrino-nucleus reactions, a value of cos θ(cid:96) is obtained via rejection sampling (see sec-

tion 3.2) on the interval [

−

1, 1] from the probability density function

P (cos θ(cid:96)) =

1
σr(Eν, Λ)

dσr(Eν, Λ)
d cos θ(cid:96)

(79)

25

where d σr(Eν, Λ) / d cos θ(cid:96) is the CM-frame diﬀerential cross section for the reaction r proceeding
via a nuclear transition described by the Λth MatrixElement. This diﬀerential cross section is
computed as in eq. (5), except that only one of the two matrix element terms is used. For a Fermi
transition, B(F) is set equal to the strength member variable of the MatrixElement, while B(GT)
is set to zero. For Gamow-Teller transitions, the reverse is done. In the case of neutrino-electron
elastic scattering, rejection sampling is still performed using the distribution from eq. (79), but the
diﬀerential cross section is calculated as in eq. (55).

For nuclear transitions proceeding purely via a Fermi or Gamow-Teller operator, the angular

dependence in the CM frame reduces to (see eq. (5))

P (cos θ(cid:96))

1 + β(cid:96) cos θ(cid:96)
∝ (cid:40)
1

−

1
3 β(cid:96) cos θ(cid:96) Gamow-Teller

Fermi

(80)

∈

where β(cid:96)
[0, 1] is the speed of the outgoing lepton. The linear expressions seen here for either case
allow the maximum of the distribution (needed for rejection sampling) to be found analytically.
Nuclear transitions that do not correspond to one of these two cases are neglected in the current
version of MARLEY. The maximum of the cos θ(cid:96) distribution for neutrino-electron elastic scattering
is also found analytically.

After a CM frame direction is sampled for the outgoing lepton, the active Reaction initializes
Particle objects with the initial and ﬁnal 4-momenta for the 2
2 scattering event. The values
of these in the laboratory frame are stored in a newly-constructed Event object together with the
excitation energy and spin-parity of the ﬁnal energy level of the target.

→

At this point, program control passes back to the Generator, which applies two additional
operations to the Event object before the event loop is complete. Once an Event object has
been created by a Reaction, further operations on it are handled by derived instances of the
EventProcessor abstract base class. These deﬁne a member function called process event which
takes references to the Event and to the Generator as arguments.

4.3. Event loop: Nuclear de-excitations

For reactions involving a transition to an excited state of a nuclear target, the subsequent de-
excitations are simulated using an EventProcessor called NucleusDecayer. This class manages a
de-excitation loop that is initialized using the proton number (Z), nucleon number (A), excitation
energy (Ex), spin (J), and parity (Π) of the outgoing nuclear state stored in the Event object.
The values of these variables are updated during each iteration of the de-excitation loop, which
simulates a sequence of binary decays until the nuclear ground state (Ex = 0) is reached.

Each binary decay step begins with a check to determine whether the current nuclear state is

bound or unbound (see section 4.1.4).

4.3.1. Unbound nuclear states

In the case of an unbound nuclear state, the NucleusDecayer constructs a HauserFeshbachDecay
object, which provides a Monte Carlo implementation of the Hauser-Feshbach statistical model (see
section 2.2) for decays of a compound nucleus. Upon construction, the HauserFeshbachDecay ob-
ject uses the properties of the initial nuclear state (Z, A, Ex, J, Π) and information from the
Generator’s owned StructureDatabase to initialize a member vector of pointers to ExitChannel
objects.

26

The abstract base class ExitChannel represents a nuclear de-excitation via emission of a γ-
ray or a particular nuclear fragment. Two pairs of abstract derived classes virtually inherit from
ExitChannel. The classes in the ﬁrst pair, DiscreteExitChannel and ContinuumExitChannel,
specialize to handling transitions to a speciﬁc discrete nuclear level and to the continuum, respec-
tively. The classes in the second pair, FragmentExitChannel and GammaExitChannel, respectively
represent de-excitations involving fragment and γ-ray emission. Concrete ExitChannel objects be-
long to a class that inherits from exactly one member of each pair, with the four possibilities being
FragmentDiscreteExitChannel, FragmentContinuumExitChannel, GammaDiscreteExitChannel,
and GammaContinuumExitChannel.

Every ExitChannel object owns a member variable called width , which is initialized during
construction with the partial decay width of interest (in MeV−1) via a call to the protected mem-
ber function compute total width. The FragmentDiscreteExitChannel and GammaDiscreteExit
Channel classes implement this function using the expressions from eqs. (33) and (51), respectively.
The FragmentContinuumExitChannel and GammaContinuumExitChannel classes both share the
ContinuumExitChannel::compute total width implementation, which integrates the diﬀerential
decay width over the energetically-accessible continuum (see sections 2.2.1 and 2.2.3) to obtain the
width value

Γu =

E(cid:48) max
x

dΓu
dE(cid:48)
x

E(cid:48) min,c

x

(cid:90)
p, n, d, t, h, α, γ

dE(cid:48)
x

(81)

. The numerical integration is per-
where the emitted particle species u
formed using Clenshaw-Curtis quadrature [142] by an instance of the Integrator class. Eval-
uation of the diﬀerential decay width dΓu/dE(cid:48)
x is delegated to the pure virtual member func-
tion differential width, which is implemented in FragmentContinuumExitChannel and Gamma
ContinuumExitChannel according to the expressions given in eq. (29) and eq. (49), respectively.

∈ {

}

When the HauserFeshbachDecay object has been fully initialized, its owned vector of Exit
Channel pointers will include an individual object derived from DiscreteExitChannel for each
accessible transition to a discrete nuclear level present in the StructureDatabase.
It will also
contain a pointer to a single object derived from ContinuumExitChannel for each particle species
that may be emitted via a transition to the continuum.

To simulate a binary decay step, the NucleusDecayer calls the do decay method of the new
HauserFeshbachDecay object. This causes a particular ExitChannel e to be sampled with proba-
bility

P (e) =

.

(82)

Γe
β Γβ

(cid:80)

Here Γe is the partial width for the eth ExitChannel (given by the width member variable) and
the sum in the denominator runs over all of the owned ExitChannel objects. Control then passes
to the do decay member function of the sampled ExitChannel to determine the properties of the
ﬁnal nuclear state. If a DiscreteExitChannel has been sampled, the ﬁnal nuclear excitation energy
(E(cid:48)

x), spin (J (cid:48)), and parity (Π(cid:48)) are retrieved from the associated Level object.
For a ContinuumExitChannel, a ChebyshevInterpolatingFunction approximation to the dif-
ferential decay width dΓu/dE(cid:48)
, E(cid:48) max
]
x
via inverse transform sampling (see section 3.3). The diﬀerential decay width is then evaluated
(via a call to the differential width member function) for the selected ﬁnal excitation energy
E(cid:48)
x. Each individual term τb in the diﬀerential decay width sum (see either eq. (29) or eq. (49) as
appropriate for the emitted particle species) is stored in a SpinParityWidth object together with

x is used to select a ﬁnal excitation energy E(cid:48)

[E(cid:48) min,c
x

x ∈

27

its corresponding J (cid:48) and Π(cid:48) values. The ﬁnal nuclear spin-parity is determined by choosing the bth
SpinParityWidth object with probability

P (b) =

τb
c τc

=

τb
dΓu/dE(cid:48)
x

(83)

where the diﬀerential decay width in the denominator is evaluated at the sampled value of E(cid:48)
x.

Once values of the variables deﬁning the ﬁnal nuclear state (E(cid:48)

x, J (cid:48), and Π(cid:48)) have been de-
termined, the procedure required to complete an iteration of the event loop (see section 4.3.3) is
similar to that used for decays of bound nuclear levels.

(cid:80)

4.3.2. Bound nuclear states

If the nucleus is in a bound excited state, i.e., it has a nonzero excitation energy Ex which
is below all of the nuclear fragment emission thresholds, then the NucleusDecayer consults the
StructureDatabase to determine whether a DecayScheme has been previously conﬁgured for the
nuclide of interest (see section 4.1.5).
If this is the case, then simulation of the remaining de-
excitations is delegated to the DecayScheme member function do cascade. During each binary
decay step handled by this function, a γ-ray transition γj originating from the current Level is
chosen with probability

P (γj) =

Ij
k Ik

(84)

where Ij is the relative intensity of the jth Gamma owned by the current Level and the sum in the
denominator runs over all of the owned Gamma objects. The properties of the ﬁnal nuclear state,
known immediately from the Level pointed to by the sampled Gamma object (via its end level
member variable) are used to complete the de-excitation loop iteration as described in section 4.3.3.
If a suitable DecayScheme cannot be found in the StructureDatabase, then MARLEY follows the

(cid:80)

same procedure as for unbound nuclear levels (see section 4.3.1).

4.3.3. Finishing a de-excitation step

At the end of each iteration of the de-excitation loop, a direction for the emitted γ-ray or nuclear
fragment is chosen by sampling a polar cosine cos θ and an azimuthal angle φ isotropically in the
rest frame of the decaying nucleus. This information is used together with the daughter particle
PDG codes and masses to initialize two new Particle objects via a call to the utility function
marley kinematics::two body decay. This function handles the elementary kinematical calcula-
tions needed to obtain the outgoing particle 4-momenta in the laboratory frame. The Particle
representing the emitted γ-ray or fragment is appended to the vector of ﬁnal particles owned by the
Event object being processed. The Particle representing the daughter nucleus, on the other hand,
replaces the mother nucleus Particle in the Event. After these adjustments have been made to
the Event object and the values of the variables tracked in the de-excitation loop (Z, A, Ex, J, Π)
have been updated, simulation of the current binary decay step is complete.

The de-excitation loop will continue to simulate additional binary decay steps until the nuclear
ground state is reached, or, in cases where no discrete level data are available for a particular
ﬁnal-state nucleus, until the excitation energy falls below the cutoﬀ E cut

x = 1 keV.

4.4. Event loop: Rotation of coordinates

For convenience during internal calculations, all MARLEY events are initially generated in a frame
in which the incident neutrino direction lies along the positive z axis. If the user has speciﬁed a

28

diﬀerent neutrino direction in the job conﬁguration ﬁle (see section 6.2), then an instance of the
ProjectileDirectionRotator class (which inherits from EventProcessor) is used to process the
Event after the de-excitation loop terminates. All particle 3-momenta in the event are rotated into
a new reference frame in which the neutrino is traveling along the direction speciﬁed by the user.
After this rotation is applied, generation of the new MARLEY event is complete.

5. Installation and usage

The current release of MARLEY has been tested on both Linux and macOS platforms and is
expected to work in any Unix-like environment in which the prerequisites are installed. Building
and running MARLEY on Windows is not currently supported. The installation instructions presented
in this section assume use of the Bash shell [143] and the availability of several standard command-
line tools.

5.1. Prerequisites

The following prerequisites are required to build the MARLEY source code:

• A C++-14-compliant compiler. Two compilers are oﬃcially supported:

– The GNU Compiler Collection (GCC) [144], version 4.9.4 or greater
– The Clang frontend for the LLVM compiler infrastructure [145], version 3.5.2 or greater

• GNU Make [146]

• The GNU Scientiﬁc Library (GSL) [1, 2]

On Linux architectures, all of these prerequisites will likely be available for installation through
the standard package manager. On macOS, the use of Homebrew [147] to install GSL is recom-
mended. This may be done by executing the terminal command

brew install gsl

after Homebrew has been installed on the target system.

Although it is not required in order to build or use MARLEY, the popular ROOT data analysis
framework [3, 4] provides convenient tools for plotting and analyzing simulation results. Users who
wish to use the optional interface between the two codes (see sections 7.2.4, 7.3.4 and 7.3.5) should
ensure that ROOT is installed before building MARLEY.

Other than GSL, MARLEY’s only required external dependencies are the C++ standard library

and the symbols deﬁned in the dirent.h and sys/stat.h headers of the C POSIX library [148].

5.2. Obtaining and building the code

The source code for MARLEY 1.2.0 may be downloaded as a compressed archive ﬁle from the
releases webpage (https://github.com/MARLEY-MC/marley/releases). Both zip and tar.gz
ﬁle formats are available. After downloading the source code, the user should unpack the archive
ﬁle in the desired installation folder. For the tar.gz format, this may be done via the command

tar xvfz marley -1.2.0. tar . gz

After unpacking the source code, the user may build MARLEY by navigating to the build/ subdirec-
tory and invoking GNU Make:

29

cd marley -1.2.0/ build
make

At build time, MARLEY veriﬁes that GSL is installed by checking for the presence of the gsl-config
script on the system path. Similarly, the optional MARLEY interface to ROOT is automatically en-
abled or disabled based on whether root-config script is present. Users who have an existing
installation of ROOT but desire to build MARLEY without ROOT support may manually disable the
interface by setting the IGNORE ROOT variable while invoking make, e.g., via

make IGNORE_ROOT = yes

If the build is successful, then executing

./ marley -- version

from within the build/ folder should yield the following console output:

MARLEY ( Model of Argon Reaction Low Energy Yields ) 1.2.0
Copyright ( C ) 2016 -2020 Steven Gardiner
License : GNU GPL version 3 <\ protect \ vrule width0pt \ protect \ href { http : //

opensource . org / licenses / GPL -3.0}{ http :// opensource . org / licenses / GPL
-3.0} >

This is free software : you are free to change and redistribute it .

Users wishing to contribute improvements to MARLEY may prefer to clone the oﬃcial source code
repository instead of downloading a release archive ﬁle. Instructions for doing so are available in
the “developer documentation” section of the oﬃcial website [149].

5.3. Conﬁguring the runtime environment

At runtime, the marley command-line executable relies on the system environment variable
MARLEY to store the path to the root folder of the source code. If generation of events is attempted
without this variable being set, then the program will halt after printing the error message

[ ERROR ]: The MARLEY environment variable is not set . Please set it ( e . g . ,

by sourcing the setup_marley . sh script ) and try again .

Although the user may manually set the value of the MARLEY variable, use of the Bash shell script
setup marley.sh to conﬁgure the system environment is recommended. In addition to storing the
path to the source code, this script makes several other changes to environment variables for user
convenience, including adding the build/ folder to the system search paths for executables17 and
dynamic libraries.18 The setup marley.sh script appears in the root source code folder and should
be executed (“sourced”) using the source command. From within the build/ folder, for example,
one should source the script via

source ../ setup_marley . sh

Sourcing the setup script does not produce any console output. The instructions given in the
remainder of this section assume that the setup marley.sh script has already been run in the
current terminal session.

17The PATH environment variable
18Either the LD LIBRARY PATH (Linux) or the DYLD LIBRARY PATH (macOS) environment variable

30

5.4. Running a simulation

The typical procedure for running a MARLEY simulation is to invoke the executable via a command

of the form19

marley CONFIG_FILE

where CONFIG FILE is the name (with any needed path speciﬁcation) of a job conﬁguration ﬁle.
Section 6 gives a full description of the ﬁle format and conﬁguration parameters. Three example
job conﬁguration ﬁles are included with MARLEY in the examples/config/ folder:

annotated.js A heavily-commented example that provides documentation of the conﬁguration ﬁle

format similar to the contents of section 6

COPY ME.js An example intended to serve as the basis for new job conﬁguration ﬁles written by

users

minimal.js An example of the simplest possible job conﬁguration: default settings are used for all

parameters except those that must be explicitly speciﬁed

As it executes, the marley program will print a variety of logging messages to the screen. Several
rows at the bottom of the screen are reserved for a status display that tracks the progress of the
simulation. Listing 1 shows the format of the status display. Following the ﬁrst two rows, which
report the current event count and the elapsed time since the simulation began, zero or more rows
record the total amount of data written to each output ﬁle. The ﬁnal row displays an estimate of
the time at which the simulation job will be completed.

Event Count = 4001/10000 (40.0% complete , 300.4 events / s )
Elapsed time : 00:00:13 ( Estimated total run time : 00:00:33)
Data written to events . ascii 3.80 MB
MARLEY is estimated to terminate on Mon Jun

1 23:54:52 2020 CDT

Listing 1: Example status display printed by the marley executable

If it becomes necessary to end the simulation before all requested events have been generated,
the user may interrupt program execution by pressing ctrl+C. In response, the marley executable
will terminate gracefully after writing the current event to any open output ﬁles. As discussed in
section 6.6, two of the available output ﬁle formats allow for a simulation job interrupted in this
way to be resumed from where it left oﬀ.

5.4.1. Troubleshooting rejection sampling problems

To select the energy Eν of the reacting neutrino in each event, MARLEY employs the rejection
sampling technique discussed in section 3.2 and the probability density function P (Eν) given in
section 4.1.3. The validity of the technique depends on obtaining an accurate estimate of the global
maximum Pmax of P (Eν) within the sampling region of interest. Underestimates of Pmax will lead
to bias in the neutrino energy distribution of the simulated events, while signiﬁcant overestimates
will adversely impact sampling eﬃciency.

19The marley executable may also be invoked with the command-line option --marley. This is best done using a

terminal window set to display at least 80 columns and 53 rows in a small font.

31

Although numerical estimation of Pmax in MARLEY is reasonably robust for a variety of realistic
neutrino spectra, it is not foolproof: there exist pathological energy distributions (e.g., those with
multiple sharp peaks) for which automatic detection of the global maximum often fails. To protect
against this problem, MARLEY checks that each calculation of P (Eν) performed during neutrino
energy sampling yields a value that does not exceed Pmax.
If a value larger than Pmax is ever
encountered, a set of warning and error messages similar to those in listing 2 will be printed to
the screen. A new estimate of Pmax, given by the problematic value of P (Eν) increased by a small
“safety factor,” will be adopted in subsequent event generation.

1

2

3

4

5

6

7

[ WARNING ]: PDF value f ( x ) = 0.00133991 at x = 48.9882 exceeded the

estimated maximum fmax = 0.001 during rejection sampling
[ WARNING ]: A new estimate fmax = 0.00135331 will now be adopted .
[ ERROR ]: Estimation of the maximum PDF value failed when using a rejection

method to sample reacting neutrino energies .

This may occur when , e . g . , an incident neutrino flux is used that includes

multiple sharp peaks .

To avoid biasing the energy distribution , please rerun the simulation after

adding the following line to the MARLEY job configuration file :
energy_pdf_max : 0.00135331 ,

If this error message persists after raising energy_pdf_max to a relatively

high value , please contact the MARLEY developers for troubleshooting

help .

Listing 2: Example warning and error messages printed in response to a rejection sampling problem encountered
when selecting reacting neutrino energies

While this adaptive approach to improving estimation of Pmax may resolve rejection sampling
problems in the later part of the simulation, it cannot correct for bias in the energy distribution
of the events that have already been generated. A simple strategy for overcoming this diﬃculty is
for the user to restart the simulation from the beginning. By adding a line to the job conﬁguration
ﬁle containing the energy pdf max key (see section 6.7.7) and the improved estimate of Pmax
recommended by the rejection sampling error message (see line 6 of listing 2), automatic estimation
of Pmax will be disabled in favor of adopting the user-speciﬁed value.

For severe underestimations of Pmax, several repetitions of this “interrupt and rerun” strategy
(each with a larger value of energy pdf max than the one before) may be needed before correct
If rejection sampling errors persist across multiple ﬁx attempts, or if the
behavior is achieved.
corrected value of Pmax results in prohibitively slow performance, a diﬀerent approach to running
the simulation (e.g., splitting a problematic spectrum into energy regions which are handled by
separate MARLEY jobs) should be pursued.

5.5. The marley-config utility

For a variety of applications, e.g., analyzing the standard MARLEY output ﬁles (section 7.3) and
interfacing MARLEY with external codes (section 8.1), it may be desirable to make use of MARLEY
classes within an external C++ program. To facilitate compilation of such programs, a Bash script
named marley-config is placed in the build/ folder whenever MARLEY is successfully built.20 This
script may be queried to obtain various pieces of information about the build.

20The marley-config script is loosely patterned after pkg-config [150]. Similar scripts are used by ROOT, GENIE,

GSL, and Geant4.

32

Option

Directory contents

Relative path

--bindir
--datadir
--incdir
--libdir
--srcdir
--topdir

executables
input data
header ﬁles
libraries
source ﬁles
top-level MARLEY directory

build/
data/
include
build/
src/
./

Table 2: Directory options recognized by the marley-config script

Each marley-config query is executed by providing the script with one or more command-line
options, each beginning with a preﬁx of two hyphens (--). The command-line options may appear
If the --help option is present on the command line, then
in any order and may be repeated.
all other arguments are ignored, and a multi-line usage message is printed. All other recognized
options produce console output that will be combined into a single line and printed in the order
that the corresponding options appeared on the command line.

Three categories of command-line options are recognized by the marley-config script. The
compilation options are used to retrieve compiler ﬂags (compatible with both GCC and Clang)
and other helpful information for building external programs that link to the MARLEY shared li-
braries (see section 5.5.1). Brief descriptions of the four compilation options currently recognized
by marley-config are given below.

--cflags Prints the C++ compiler ﬂags needed to build code that includes MARLEY header ﬁles. If
MARLEY has been built with ROOT support, then the compiler ﬂags will include -DUSE ROOT,
which deﬁnes the preprocessor macro USE ROOT. This macro may be used together with the
preprocessor directives #ifdef or #ifndef to test for ROOT-dependent MARLEY features in
compiled code. An example is given in section 5.5.1.

--cxx-std Prints the version of the C++ Standard used by the compiler when MARLEY was built.
The format used is the same as for parameters passed via the -std ﬂag to the compiler. For
example, if MARLEY was built using the -std=c++14 ﬂag, then marley-config will print c++14
for this option.

--libs Prints the compiler ﬂags needed for linking to the MARLEY shared libraries

--use-root Prints the string yes if MARLEY was built with ROOT support and no if it was not

The directory options are used to print the full paths to various subfolders of the MARLEY in-
stallation. Table 2 lists the available directory options in the ﬁrst column. The second and third
columns list, respectively, a description of the directory’s contents and its path relative to the root
MARLEY folder. For an installation of MARLEY in which the top-level directory of the source code is
/home/marley, executing

marley - config -- topdir -- incdir -- bindir

will produce the output

/ home / marley / home / marley / include / home / marley / build

33

A ﬁnal marley-config option category, the version options, may be used to identify the installed
version of MARLEY. Two options in this category are currently recognized by the marley-config
script: --git-revision and --version.

The --git-revision option is used to print a unique hash value reported by Git at build time.
If MARLEY was built using a cloned Git repository (see section 5.2), and the git executable is present
on the system path when GNU Make is invoked, then the hash identiﬁer for the latest commit will
be retrieved21 and saved in the marley-config script. If uncommitted changes exist in the Git
index or working tree when MARLEY is built, then the string -dirty will be appended to the hash
value. In cases where a hash value is unavailable (e.g., because MARLEY was installed without cloning
a Git repository), the marley-config script will print the string unknown version in response to
this option.

If a tagged release of MARLEY was built,22 then the --version option may be used to print the
corresponding version number (e.g., 1.2.0). Otherwise, the output produced by marley-config
in response to --version is the same as for --git-revision.

5.5.1. Compiling programs using marley-config

To illustrate usage of the marley-config utility, three simple C++ programs that employ MARLEY
classes are provided in the folder examples/executables/minimal/. Each one of these may be
compiled using GCC by executing a command of the form
g ++ -o EXECUTABLE_NAME $ ( marley - config -- cflags -- libs ) SOURCE_NAME

from within examples/executables/minimal/. Here EXECUTABLE NAME is the desired ﬁle name
for the compiled executable and SOURCE NAME is the name of one of the example C++ source ﬁles.
The marley-config script may also be used in a Makefile as part of a more complicated build.
Interested users should consult the ﬁles examples/executables/build/Makefile and examples/
marg4/build/Makefile for concrete examples.

// Standard library includes
#include < iostream >

// MARLEY includes
#include " marley / MassTable . hh "

constexpr int Z = 18; // Ar
constexpr int A = 40;

int main () {

const marley :: MassTable & mt = marley :: MassTable :: Instance () ;
double mass_Ar40 = mt . get_atomic_mass ( Z , A ) ;

std :: cout << " MARLEY was " ;
#ifndef USE_ROOT

std :: cout << " not " ;

#endif

21Via the command git rev-parse --short HEAD
22This is determined by the presence of a ﬁle named .VERSION in the top-level MARLEY folder at build time.

34

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

std :: cout << " built with ROOT support .\ n " ;

std :: cout << " The atomic mass of 40 Ar is " << mass_Ar40 << " MeV / c ^2\ n " ;

return 0;

}
Listing 3: The C++ source code for examples/executables/minimal/mass 40Ar.cc, a trivial example program that
uses the marley::MassTable class

Listing 3 shows the source code for mass 40Ar.cc, one of the three example programs included
in examples/executables/minimal/. The other two, efr.cc and evgen.cc, are discussed in
sections 7.3.1 and 8.1, respectively. On lines 12–13 of listing 3, a constant reference to the singleton
instance of the marley::MassTable class is retrieved and used to compute the atomic mass of 40Ar.
Lines 15–19 print a message to standard output indicating whether MARLEY was built with ROOT
support. The USE ROOT preprocessor macro mentioned in section 5.5 is used to determine whether
line 17 should be included in the compiled program. A ﬁnal message containing the atomic mass
of 40Ar is printed to standard output on line 21.

6. Generator conﬁguration

Before entering the event loop, the MARLEY executable reads in various settings (see section 4.1)
from a job conﬁguration ﬁle. The format of the job conﬁguration ﬁle is based on JavaScript Object
Notation (JSON) [151], which represents data structures as a nested hierarchy of key-value pairs.
A JSON object is an unordered set of key-value pairs surrounded by curly braces (
). Each key is
an arbitrary string delimited by double quotes ("") and separated from its corresponding value by
a colon. Each value may be a JSON object itself, a double-quoted string, a number, an array, or
one of the words true, false, or null (without surrounding quotes). A JSON array is an ordered
collection of values surrounded by square brackets ([]). Elements of an array need not have the
same data type, e.g., the values true and 1.05 may be members of the same array. Array elements
are separated by commas, as are object key-value pairs. A valid JSON document is itself an object
and is thus delimited by a pair of curly braces.

{}

For the convenience of users, the job conﬁguration ﬁle format used by MARLEY permits three

minor deviations from the JSON standard:

• Single-word keys (no whitespace) may be given without surrounding double quotes.

• C++-style comments (// and /* */) are allowed anywhere in the ﬁle.

• A trailing comma is allowed after the ﬁnal element in objects and arrays.

A ﬁlename extension of .js is recommended for MARLEY job conﬁguration ﬁles because the default
JavaScript syntax highlighting used by many text editors is well-suited to the JSON-like format.23
To parse job conﬁguration ﬁles, MARLEY relies on a modiﬁed version of the SimpleJSON library
[152], which was incorporated into the code base as the class marley::JSON. An example MARLEY

23Some email services do not allow the attachment of ﬁles with the .js extension. To enable sharing of a MARLEY
job conﬁguration ﬁle via email, it is usually suﬃcient to change the ﬁlename extension to .txt before attaching the
ﬁle.

35

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

job conﬁguration ﬁle is shown in listing 4. Explanations of each parameter needed to fully conﬁgure
the generator are given in the following subsections.

// The full configuration is enclosed in a set of curly braces
{

// Random number seed
seed : 123456 ,

// Incident neutrino direction
direction : { x : 0.0 , y : 0.0 , z : 1.0 } ,

// Target specification
target : {

nuclides : [ 1000180400 ] ,
atom_fractions : [ 1.0 ] ,

} ,

// Reaction input files
reactions : [ " v e 4 0 A r C C _ B h a t t a c h a r y a 20 0 9 . react " , " ES . react " ] ,

// Neutrino source specification
source : {

neutrino : " ve " , // The source produces electron neutrinos
type : " monoenergetic " ,
// MeV
energy : 15.0 ,

} ,

// Settings for MARLEY command - line executable
execu tab le_se tti n gs : {

// The number of events to generate
events : 10000 ,

// Event output configuration
output : [ { file : " events . ascii " , format : " ascii " , mode : " overwrite " }

] ,

} ,

}

Listing 4: Example MARLEY job conﬁguration ﬁle

6.1. Random number seed

The optional seed key may be used to specify an integer seed for the random number generator.
Any value corresponding to a C++ long int (guaranteed by the standard to be at least 32 bits
long) may be used as a seed. This includes negative integers, although users should note that
these will be reinterpreted as unsigned integers by MARLEY. If the seed key is omitted from the job
conﬁguration ﬁle, then the current Unix time will be used as the random number seed.

6.2. Neutrino direction

For simplicity, MARLEY initially generates all events in a frame where the incident neutrino is
traveling along the positive z direction (see section 4.4). However, it is often useful to simulate events

36

for neutrinos traveling in an arbitrary direction in the lab frame. This functionality is enabled via
use of the direction key to deﬁne a lab-frame direction 3-vector for the incident neutrinos. The
Cartesian components of this vector are speciﬁed as shown on line 7 of listing 4. They need not
have any particular normalization, but at least one component must be nonzero. If the direction
key is omitted, then the positive z direction is assumed.

In certain special cases, e.g., studies of the Diﬀuse Supernova Neutrino Background (DSNB)
[153], it may be desirable to generate MARLEY events with an isotropic distribution of initial neutrino
directions. This behavior may be enabled by providing the string "isotropic" as the value for the
direction key instead of a direction 3-vector.

6.3. Target composition

The nuclidic composition of the neutrino target material in a MARLEY simulation may be speciﬁed
by deﬁning a JSON object in the job conﬁguration ﬁle labeled with the target key. The JSON
object must deﬁne two arrays of equal size. The ﬁrst of these, which is labeled with the nuclides
key, includes one or more nuclear PDG codes (see section 7.1) with one code per species. The
second array, which is labeled with the atom fractions key, contains the corresponding nuclide
fractions in the target material. After being automatically normalized to sum to unity, these will
be used as the abundance weights fr that appear in eqs. (74) and (75). If any of the elements of
the atom fractions array is negative, MARLEY will halt and print an error message.

Lines 10–13 of listing 4 provide an example conﬁguration for a neutrino target composed of
pure 40Ar. If the target key is omitted from the job conﬁguration ﬁle, then the default behavior
mentioned in section 4.1.6 will be used: every distinct nuclide that appears in the initial state of
at least one conﬁgured reaction (see section 6.4) will be included in the neutrino target with equal
abundance.

6.4. Reactions

To deﬁne the set of neutrino scattering processes that should be considered in a MARLEY sim-
ulation, the user must specify a list of reaction input ﬁles as a JSON string array labeled by the
reactions key. This key is required to be present in all MARLEY job conﬁguration ﬁles. For neutrino-
nucleus reactions, each reaction input ﬁle provides the values of the allowed nuclear matrix elements
B(F) and B(GT) needed to compute the diﬀerential cross section in eq. (5) for a particular tar-
get nucleus and interaction mode. For neutrino-electron elastic scattering, the reaction input ﬁle
provides a list of nuclides for which this process should be enabled. Details of the ﬁle format are
discussed in appendix B.

In MARLEY 1.2.0, the code is capable of simulating reactions belonging to four distinct interaction
modes: charged-current neutrino-nucleus scattering (ν CC), charged-current antineutrino-nucleus
scattering (¯ν CC), neutral-current (anti)neutrino-nucleus scattering (NC), and (anti)neutrino-electron
elastic scattering (ES). As shown in eq. (10), the nuclear scattering modes may be distinguished by
the isospin operator that appears in the nuclear matrix elements (e.g., t− for ν CC).

6.4.1. Example reaction input ﬁles

Three example reaction input ﬁles for ν CC on 40Ar, intended for use in simulations of the
process 40Ar(νe, e−)40K
, are included in the data/react folder as part of the standard MARLEY
distribution. At high excitation energies, all three ﬁles include the same set of theoretical matrix

∗

37

elements taken from a QRPA24 calculation by Cheoun, Ha, and Kajino [154]. At low excitation
energies, the ﬁles contain diﬀerent sets of nuclear matrix elements extracted from experimental
data. The references used to obtain the data-driven matrix elements for each ﬁle are as follows:
ve40ArCC Bhattacharya1998.react Measurement of 40Ti β+ decay reported in ref. [155]

ve40ArCC Liu1998.react Independent 40Ti β+ decay measurement reported in ref. [156]

ve40ArCC Bhattacharya2009.react Forward-angle (p,n) scattering data reported in ref. [157].

A description of the data evaluation procedure used to prepare these ﬁles is available in ref. [108,
sec. III].

Two other reaction input ﬁles are included in the data/react folder. The ﬁle ES.react enables
simulations of neutrino-electron scattering on an atomic 40Ar target. Simulation of this process for
other nuclides may be enabled in ES.react by appending additional nuclear PDG codes.

The ﬁle CEvNS40Ar.react provides a simple example of an NC conﬁguration. Although MARLEY
is capable of simulating inelastic NC reactions if provided with suitable input, CEvNS40Ar.react
includes only one B(F) matrix element appropriate for simulating coherent elastic neutrino nu-
cleus scattering on 40Ar (see section 2.1.1). Altering the nuclear PDG code given in this ﬁle (see
appendix B) will immediately enable this process to be simulated for any spin-zero target nucleus.

6.4.2. Conﬁguration example

Line 16 of listing 4 provides an example reactions setting that enables ν CC and ES reactions
on 40Ar to be simulated simultaneously. As shown in the example, a full path speciﬁcation is not
needed for ﬁles that appear in the $
MARLEY
is the value of
}
{
the MARLEY environment variable at runtime (see section 5.3). If multiple ﬁles representing the same
reaction mode and the same target nuclide are listed for the reactions key, a warning message will
be printed and only the conﬁguration from the ﬁrst such ﬁle will be used in the simulation.

/data/react/ folder, where $
MARLEY
}
{

Every element of the reactions array must be a simple string literal containing a single ﬁle
name. The use of wildcard characters, regular expressions, and environment variables is not cur-
rently allowed by the MARLEY job conﬁguration ﬁle format.

6.5. Neutrino source

The required source key allows the user to provide a description of the incident neutrino energy
spectrum using a JSON object. This object must always contain at least two keys: neutrino and
type.

The neutrino key represents the neutrino species to be used as the projectile. This may be

speciﬁed using either an integer PDG code or a string, as shown in table 3.

The type key may be used to request one of several built-in neutrino spectra or to indicate to
MARLEY that a user-deﬁned spectrum should be used. In the latter case, users should typically not
apply any cross section weighting themselves to the neutrino spectrum, as MARLEY will weight the
incident spectrum using the appropriate reaction cross section at runtime (see section 4.1.3). In
unusual cases where this behavior is not desirable, the user may disable cross section weighting by
following the procedure described in section 6.7.3.

The following paragraphs describe each of the allowed options for the type key, together with

any additional parameters needed for each source type.

24Quasiparticle Random Phase Approximation

38

Neutrino PDG code

string

νe
¯νe
νµ
¯νµ
ντ
¯ντ

12
12
14
14
16
16

−

−

−

"ve"
"vebar"
"vu"
"vubar"
"vt"
"vtbar"

Table 3: Allowed values for the neutrino key in the neutrino source speciﬁcation

6.5.1. Monoenergetic

A neutrino source whose type is mono or monoenergetic always produces a neutrino with a
ﬁxed energy Eν. This energy is speciﬁed in MeV using the energy key. Lines 19–23 of listing 4
provide an example conﬁguration for a monoenergetic νe source with Eν = 15 MeV.

6.5.2. Fermi-Dirac distribution

The fermi-dirac or fd source type emits neutrinos whose energies are drawn from a Fermi-
Dirac distribution with temperature T (MeV) and pinching parameter η. The incident neutrino
spectrum is given by

φ(Eν) =

C E2
ν

T 4

1 + exp

Eν
T −

η

Emin

ν ≤

Eν

≤

Emax
ν

where C is a normalization constant chosen so that

(cid:0)

(cid:1)(cid:3)

(cid:2)

Emax
ν

Emin
ν

(cid:90)

φ(Eν) dEν = 1.

1

2

3

4

5

6

7

8

source : {

type : " fermi - dirac " ,
neutrino : " ve " ,
Emin : 0 ,
Emax : 60 ,
temperature : 3.5 ,
eta : 4

// Minimum neutrino energy ( MeV )
// Maximum neutrino energy ( MeV )
// Temperature ( MeV )
// Pinching parameter ( default 0)

} ,

Listing 5: Example Fermi-Dirac source speciﬁcation

(85)

(86)

The values of the parameters Emin
, T , and η are speciﬁed using the keys Emin, Emax,
temperature, and eta, respectively. Omitting the eta key will yield the default value η = 0. The
other three parameters must be given explicitly. Listing 5 shows an example Fermi-Dirac source
speciﬁcation in which the parameter values Emin
ν = 60 MeV, T = 3.5 MeV, and
η = 4 have been chosen.

ν = 0 MeV, Emax

, Emax
ν

ν

The form for the pinched Fermi-Dirac distribution used by MARLEY is based on that of the

“Livermore model” of the supernova neutrino energy spectrum [158].

39

6.5.3. “Beta ﬁt” spectrum

The beta-fit or bf source type produces neutrinos with energies drawn from the spectrum

φ(Eν) = C

Eν

Eν

β−1

exp

source : {

(cid:0)

(cid:14)(cid:10)

(cid:11)(cid:1)

β Eν

Eν

(cid:14)(cid:10)

(cid:11)(cid:1)

−

(cid:0)

type : " beta - fit " ,
neutrino : " ve " ,
Emin : 0 ,
Emax : 60 ,
Emean : 15 , // Mean neutrino energy ( MeV )
beta : 3.0 , // Pinching parameter ( default 4.5)

// Minimum neutrino energy ( MeV )
// Maximum neutrino energy ( MeV )

} ,

1

2

3

4

5

6

7

8

Emin

ν ≤

Eν

≤

Emax
ν

(87)

Listing 6: Example “beta ﬁt” source speciﬁcation

with mean neutrino energy
ization constant C is chosen to satisfy eq. (86).

Eν
(cid:104)

(cid:105)

(MeV) and dimensionless pinching parameter β

0. The normal-

≥

ν

, Emax
ν

The values of the parameters Emin

, and β are speciﬁed using the keys Emin, Emax,
Eν
Emean, and beta, respectively. Omitting the beta key will yield the default value β = 4.5. The other
three parameters must be given explicitly. Negative β values are unphysical and will cause MARLEY
to halt and issue an error message. Listing 6 shows an example “beta ﬁt” source speciﬁcation in
which the parameter values Emin
= 15 MeV, and β = 3 have
been chosen.

ν = 0 MeV, Emax

= 60 MeV,

Eν
(cid:104)

(cid:105)

(cid:105)

(cid:104)

ν

,

The “beta ﬁt” distribution has been employed in a recent theoretical study [159] of supernova
neutrino detection and is equivalent to the widely-used “Garching model” parameterization of
supernova neutrino spectra [160]. The sole diﬀerence between the two parameterizations is in the
convention for the pinching parameter. The Garching model employs a parameter α and makes the
substitution β
1, the distributions used by the two approaches
are identical.

α + 1 in eq. (87). For α = β

→

−

6.5.4. Muon decay-at-rest

The decay-at-rest or dar source type emits neutrinos according to a Michel spectrum for

a muon decaying at rest in the lab frame. For a νe source (corresponding to the decay µ+
e+ + νe + ¯νµ), the energy spectrum is given by [161]

→

φ(Eν) = 96 E2

ν m−4

µ (mµ

2Eν)

−

0 < Eν < mµ/2.

(88)

where mµ is the muon mass. A ¯νµ source has the spectrum

φ(Eν) = 16 E2

ν m−4

µ (3mµ

4Eν)

−

0 < Eν < mµ/2.

(89)

1

2

3

4

source : {

type : " dar " ,
neutrino : " ve " ,

} ,

Listing 7: Example muon decay-at-rest source speciﬁcation

40

Production of ¯νe and νµ (from µ−
e−+¯νe+νµ) may also be simulated using a dar neutrino source.
Because the decay kinematics fully determine the shape of the Michel spectrum, no additional input
parameters are needed for this source type. Listing 7 shows an example conﬁguration for a muon
decay-at-rest νe source.

→

Neutrinos from muon decay-at-rest produced at facilities like the Oak Ridge Spallation Neutron
Source (SNS) [162] and the Fermilab Neutrinos at the Main Injector (NuMI) beamline [36] oﬀer a
valuable opportunity to study neutrino-nucleus scattering at tens-of-MeV energies with a terrestrial
source.

6.5.5. Histogram

The histogram or hist source type allows the user to deﬁne the incident neutrino spectrum as

a histogram with one or more energy bins.

source : {

type : " histogram " ,
neutrino : " ve " ,
E_bin_lefts : [ 7. , 8. , 9. ] , // Low edges of energy bins ( MeV )
weights : [ 0.2 , 0.5 , 0.3 ] ,
Emax : 10. ,

// Bin weights ( dimensionless )
// Upper edge of the final bin ( MeV )

} ,

Listing 8: Example histogram source speciﬁcation

The n bins are speciﬁed by their lower edges Eν(k) and weights W (k) for k

.
}
Within bin k,
incident neutrino energies are distributed uniformly on the half-closed interval
[Eν(k), Eν(k + 1)). Weights that do not sum to unity will be automatically renormalized by the
code. The keys E bin lefts and weights are used to provide JSON arrays of Eν(k) and W (k)
values, respectively. The sizes of these arrays must be equal and are used by MARLEY to determine
the bin count n. The energy bin edges Eν(k) must be given in increasing order. The upper edge of
the ﬁnal energy bin Eν(n + 1) must also be speciﬁed using the key Emax.

1, 2, . . . , n

∈ {

Listing 8 shows an example histogram source speciﬁcation in which three equally-spaced bins

are deﬁned between 7 and 10 MeV.

6.5.6. Grid

The grid source type emits neutrinos with energies drawn from a tabulated probability density
function φ(Eν). To deﬁne this function, a grid of at least two monotonically increasing Eν values
is speciﬁed as a JSON array via the energies key. The corresponding φ(Eν) values (which need
not be normalized by the user to integrate to unity) must also be given in an array of the same size
using the prob densities key.

source : {

type : " grid " ,
neutrino : " ve " ,
energies : [ 10. , 15. , 20. ] ,
prob_densities : [ 0. , 1. , 0. ] ,
rule : " lin " , // Interpolation rule (" lin " default )

// Energy grid points ( MeV )
// Probability densities

} ,

Listing 9: Example grid source speciﬁcation

41

1

2

3

4

5

6

7

1

2

3

4

5

6

7

Rule

Interpretation

"const"
"lin"
"linlog"
"loglin"
"log"

histogram-like
linear in both Eν and φ(Eν)
linear in Eν, logarithmic in φ(Eν)
logarithmic in Eν, linear in φ(Eν)
logarithmic in both Eν and φ(Eν)

Table 4: Allowed values of the rule key for the grid neutrino source type.

To evaluate φ(Eν) at energies between the grid points, MARLEY employs an interpolation rule
speciﬁed by the rule key. The default "lin" rule (linear in both Eν and φ) is typically most useful,
but MARLEY is also capable of interpolating logarithmically along one or both axes. A "const"
interpolation rule is also available which treats φ(Eν) as a step function at each energy grid point.
Table 4 lists all allowed values of the rule key together with their interpretations.

Listing 9 shows an example grid source speciﬁcation which deﬁnes a symmetric triangular dis-

tribution between 10 and 20 MeV.

6.5.7. TH1 and TGraph

1

2

3

4

5

6

7

8

9

If MARLEY’s optional interface to the ROOT [3] data analysis framework is enabled (see section 5),

then two additional neutrino source types, th1 and tgraph, are allowed.

source : {

type : " th1 " ,
neutrino : " ve " ,
tfile : " my_root_file . root " ,

// Name of the ROOT file
// containing the TH1 object

namecycle : " MyHist " ,

// Name under which the TH1 object appears
// in the file ( used to retrieve it )

} ,

Listing 10: Example th1 source speciﬁcation

The th1 type takes a one-dimensional ROOT histogram object (of C++ type TH1) as input and
converts it into a histogram neutrino source using MARLEY’s native representation of the distribu-
tion.25 The tgraph source type is similar, except that it converts a ROOT TGraph object into a
grid neutrino source.

To use either of the th1 or tgraph source types, the user must provide the name of an in-
put ROOT ﬁle (including any needed path speciﬁcation) using the tfile key. The string value
given for the namecycle key, which must also be provided, will be used by MARLEY in a call to
TDirectoryFile::Get(const char* namecycle) in order to retrieve the object of interest from
the input ROOT ﬁle. Units of MeV should always be used for neutrino energies when preparing a
TH1 or TGraph object for use with MARLEY.

25Both histogram and grid neutrino sources are implemented using the marley::InterpolationGrid class.

42

Listing 10 shows an example th1 source speciﬁcation which uses a neutrino energy histogram

named "MyHist" stored in a ROOT ﬁle in the working directory called my root file.root.

6.6. Executable settings

The optional executable settings key is used to provide a JSON object that controls the
marley command-line executable. However, the entirety of the executable settings will be ignored
if the conﬁguration ﬁle is used to initialize MARLEY in a diﬀerent context (e.g., from within a Geant4
application that links to the MARLEY shared libraries, see section 8).

Within the executable settings object, the events key is used to specify the number of events
that the marley executable should generate before terminating. Because the MARLEY JSON parser
expects the associated value to be an integer literal, using scientiﬁc notation to specify the number
If the events key is omitted, a
of events (e.g., 1e4 instead of 10000) is not currently allowed.
default value of 1000 will be assumed.

The output key in the executable settings object is used to describe zero or more output ﬁles
that will receive the generated events. The corresponding value should be a JSON array containing
one JSON object per output ﬁle. Each object in the array should deﬁne the following keys:

ﬁle The name of the output ﬁle (with any needed path speciﬁcation).

format The format to use when storing events in the output ﬁle. Valid values for this key are
"ascii", "hepevt", "json", and (if MARLEY’s ROOT interface is active) "root". Descriptions
of each of the allowed output ﬁle formats are given in section 7.2.

mode The approach that the marley executable should use if the output ﬁle is not initially empty.
For the ASCII and HEPEVT formats, valid values are "overwrite" (erase any previously
existing ﬁle contents) and "append" (continue output immediately after any existing ﬁle
contents). For the JSON and ROOT formats, valid values are "overwrite" and "resume". If
the "resume" mode is chosen, the generator will restore its previous state from an incomplete
run (e.g., a run that was interrupted by the user by pressing ctrl+C) that was saved to the
output ﬁle and continue from where it left oﬀ. If the "resume" mode is selected for more than
one output ﬁle, then MARLEY will halt and print an error message.

Two additional keys may be used in speciﬁc contexts:

force Boolean value used only for the "overwrite" mode. If it is true, then the marley executable
will not prompt the user before overwriting existing data. If this key is omitted, a value of
false is assumed.

indent Nonnegative integer value used only for the JSON output format. It represents the number
of spaces that should be used as a tab stop when pretty-printing the JSON output. If this
key is omitted, all unnecessary whitespace will be suppressed. This default behavior results
in the most compact JSON-format output ﬁles.

If the output key in the executable settings object is omitted entirely, then the default conﬁg-
uration

output : [ { file : " events . ascii " , format : " ascii " , mode : " overwrite " } ]

will be used.

Lines 26–32 of listing 4 deﬁne an example executable settings object that includes the default

settings described in this section.

43

6.7. Less commonly-used parameters

Although the job conﬁguration ﬁle shown in listing 4 provides usage examples for all of the
key-value pairs typically needed to deﬁne a MARLEY simulation, a number of additional parameters
are recognized by the conﬁguration parser.26 These parameters, which are intended for advanced
users or for addressing unusual situations, are documented in the remainder of this section.

6.7.1. Logging

The singleton marley::Logger class provides rudimentary support for writing diagnostic mes-
sages to zero or more output streams including standard output, standard error, and plaintext log
ﬁles. This is done in a prioritized way by conﬁguring a logging level for each output stream. Mes-
sages are likewise categorized by a logging level. In order of severity, the logging levels recognized
by marley::Logger are debug, info, warning, error, and disabled, with the last available for
output streams but not for messages. When a message with logging level MSG LEVEL is passed by
MARLEY to the Logger, the message will be ignored by all streams whose logging levels are more
severe than MSG LEVEL. The message will be written to all other conﬁgured streams.

Nearly all output written to the terminal by the marley executable is handled by the Logger

class. The main exception is the status display discussed in section 5.4 (see listing 1).

The default behavior of the Logger class may be adjusted via the optional log key in the job
conﬁguration ﬁle. This key is used to specify an array of JSON objects with one element per output
stream. Each object in the array may deﬁne the following keys:

ﬁle A string giving the name of a text ﬁle that will receive the output logging messages. If the
string value is "stdout" ("stderr"), then the messages will be written to standard output
(standard error) rather than a text ﬁle.

level A string specifying the logging level that should be used as a threshold for writing messages
to the stream. Valid values are "debug", "info", "warning", "error", and "disabled".

overwrite A boolean value indicating whether new messages should be appended to the end of the
output ﬁle (false) or whether any previously existing ﬁle contents should be erased (true).
This key is ignored when writing to standard output and standard error. A default value of
false is assumed when this key is not present.

If the log key is omitted from the job conﬁguration ﬁle, then MARLEY will use default settings
equivalent to

log : [ { file : " stdout " , level : " info " } ]

6.7.2. Disabling simulation of nuclear de-excitations

→

As described in section 2, MARLEY models neutrino-nucleus scattering as proceeding via a prompt
2 reaction and a subsequent sequence of zero or more binary decays of the remnant nucleus.
2
For certain calculations,27 it may be convenient to simulate events in which only the primary 2
2
scattering process is considered. This behavior may be enabled in the job conﬁguration ﬁle by
using the optional do deexcitations key together with a boolean value.
If the accompanying
value is true, then the MARLEY event loop will proceed normally, and nuclear de-excitations will be
simulated. If it is false, then the de-excitation loop will be skipped.

→

26That is, the marley::JSONConfig class
27For example, those in which only the ﬁnal-state lepton is of interest

44

6.7.3. Disabling cross-section weighting of the neutrino spectrum

∝

By default, MARLEY samples the reacting neutrino energy Eν for each event from a probability
σ(Eν) φ(Eν), where σ(Eν) is the abundance-weighted total cross section
density function P (Eν)
and φ(Eν) is the incident neutrino spectrum (see section 4.1.3). For some use cases, it may be
desirable to sample Eν directly from φ(Eν) without any cross-section weighting. This may be
achieved by adding the optional weight flux key, which takes a boolean value, to the contents
of the source JSON object (section 6.5). If the weight flux value is set to true, then Eν will
be sampled from the usual probability density function P (Eν). If the weight flux value is set to
false, then Eν will be drawn directly from φ(Eν).

6.7.4. Orbital angular momentum and multipolarity cutoﬀs

When computing diﬀerential decay widths for nuclear fragment (γ-ray) emission from a com-
pound nucleus, MARLEY truncates the inﬁnite sum over orbital angular momenta (multipolarities)
that appears in eq. (29) (eq. (49)) by imposing a cutoﬀ value (cid:96)max (λmax). The user may mod-
ify the default value ((cid:96)max = λmax = 5) by including two keys in the job conﬁguration ﬁle. The
fragment lmax key is used to specify a nonnegative integer which will be used as the maximum or-
bital angular momentum (cid:96)max to consider in nuclear fragment emission. Similarly, the gamma lmax
key is used to specify a positive integer which will serve as the maximum multipolarity λmax con-
sidered in γ-ray emission.

6.7.5. Coulomb correction factor

As described in section 2.1.2, MARLEY accounts for ﬁnal-state Coulomb eﬀects in charged-current
neutrino-nucleus interactions by the inclusion of a Coulomb correction factor FC in the expression
for the diﬀerential cross section. By default, this factor is computed according to eq. (27), which
uses the smaller of the two corrections given by the Fermi function (eq. (18)) and the modiﬁed
eﬀective momentum approximation (MEMA, eq. (26)). The MARLEY prescription for the Coulomb
correction factor may be controlled in the job conﬁguration ﬁle by use of the coulomb mode key.
The following string values are allowed for this key:

"none" No Coulomb corrections will be applied (FC = 1 in all cases).

"Fermi" The Fermi function deﬁned in eq. (18) will always be used to compute the Coulomb

correction factor (FC = FFermi).

"EMA" The eﬀective momentum approximation (EMA) will be used for Coulomb corrections (FC =

FEMA, see eq. (25)).

"MEMA" The modiﬁed eﬀective momentum approximation (MEMA) will be used for Coulomb cor-

rections (FC = FMEMA, see eq. (26)).

"Fermi-EMA" The Fermi function will be compared to the EMA, and the approach that yields the
smaller correction (i.e., the FC value closer to unity) will be used. The Coulomb correction
factor FC is calculated as in eq. (27) with the substitution FMEMA

FEMA.

→

"Fermi-MEMA" Similar to "Fermi-EMA", except that the MEMA is used instead of the EMA. The
Coulomb correction factor FC is calculated as in eq. (27). This is MARLEY’s default approach.

45

6.7.6. Status update interval

As discussed in section 5.4, the marley executable prints a text-based status display at the
bottom of the screen. By default, this display is updated after each set of nupdate = 100 events has
been generated. The user may modify the value of nupdate by adding the status update interval
key to the executable settings object in the job conﬁguration ﬁle (see section 6.6). Only positive
integer values of nupdate may be speciﬁed for this key.

6.7.7. Manually specifying a maximum value of the neutrino energy PDF

To select a reacting neutrino energy for each event, MARLEY relies on rejection sampling from
the probability density function given in eq. (73). In situations where automatic estimation of the
global maximum Pmax of this PDF is found to be inadequate, MARLEY will print a set of messages
to alert the user (see section 5.4.1). These messages will include an improved estimate of Pmax
(see line 6 of listing 2) which may be manually supplied by the user in the job conﬁguration ﬁle
as a ﬂoating-point value associated with the energy pdf max key. Doing so will disable numerical
estimation of Pmax in favor of using the speciﬁed value, which may help to resolve some rejection
sampling problems.

6.7.8. Keys speciﬁc to mardumpxs

Several job conﬁguration ﬁle keys are available to modify the default behavior of the mardumpxs
utility described in section 7.4.2. They are otherwise ignored by MARLEY. The mardumpxs-speciﬁc
keys are listed below together with their interpretations:

xsec dump pdg Labels an integer value that speciﬁes the PDG code (see the second column of
table 3) for the projectile of interest. If this key is not present, then a νe (PDG code 12) is
assumed by mardumpxs.

xsec dump KEmin Used to set the minimum projectile kinetic energy (MeV) that should be included

in the output. By default, mardumpxs sets the minimum kinetic energy to 0 MeV.

xsec dump KEmax Used to set the maximum projectile kinetic energy (MeV) that should be included
in the output. By default, mardumpxs sets the maximum kinetic energy to 100 MeV.

xsec dump steps Used to set the number of equally-spaced points at which the total cross section
should be evaluated as a function of projectile kinetic energy. Only positive integer values are
allowed. If this key is absent, then mardumpxs will use a default value of 10,000.

7. Interpreting the output

The neutrino scattering events generated by the marley command-line executable may be saved
to disk in four distinct output formats. Section 6.6 explains how one or more of these output
formats may be selected by the user in the job conﬁguration ﬁle. Following a brief discussion of the
particle numbering scheme used by MARLEY in section 7.1, documentation for each of the output
ﬁle formats is provided in section 7.2. Section 7.3 presents a C++-based API which may be used
to parse all of the standard output formats via a uniﬁed interface. Section 7.4 provides guidance
on how histograms of quantities of interest from the generated events may be converted into easily
interpretable physics distributions, e.g., diﬀerential cross sections and event rates.

46

PDG code

Particle

11

12

13

14

13

14

22

2112

2212

1000010020

1000010030

1000020030

1000020040

e−

νe
µ−

νµ
τ −

ντ

γ

n

p

d

t

h

α

Table 5: The most commonly encountered PDG codes used by MARLEY to identify kinds of particles.

7.1. Particle numbering scheme

Like many other modern physics event generators, MARLEY identiﬁes particle species using a
standard set of integer codes deﬁned by the Particle Data Group (PDG) [163, sec. 44, pp. 661–
664]. Each kind of particle is assigned a unique positive integer, and the corresponding antiparticle
is assigned a negative integer with the same absolute value. These PDG codes are used by MARLEY
both internally and in output ﬁles.

Table 5 provides the interpretation of the most common PDG codes that appear in MARLEY
events. In general, a nucleus with proton number Z and mass number A is labeled with the PDG
code

PID = 10,000 Z + 10 A + 1,000,000,000 .
(90)
The only two exceptions to the rule given in eq. (90) are for a free neutron and 1H, which are
represented by the codes 2112 and 2212, respectively.

7.2. Output ﬁle formats

In the current version of MARLEY, generated events may be saved to disk using four possible ﬁle

formats:

ASCII The native text-based format for MARLEY events.

HEPEVT A legacy format for interfacing event generators with each other and with other soft-
ware. Despite its relative age and emergence in the speciﬁc context of QCD event generation
for Large Electron-Positron Collider experiments [164], compatibility with this format is main-
tained in many modern high energy physics software tools. Examples include the HepMC3

47

[165] event record library and (via its TextFileGen module) the LArSoft toolkit discussed in
section 8.3.

JSON In addition to serving as the input language for MARLEY job conﬁguration ﬁles (with slight
extensions to the standard grammar, see section 6 for details), JSON is also available as an
output ﬁle format.

ROOT If MARLEY’s interface to ROOT is active, a binary representation of the full marley::Event
objects may be saved to disk in an output TTree. A simpliﬁed “ﬂat” form of the ROOT output
that can be read without recourse to the MARLEY shared libraries may also be produced using
the marsum command-line tool (see section 7.3.5).

7.2.1. ASCII ﬁle format

An ASCII-format output ﬁle begins with the line

FluxAvgXsec

in which FluxAvgXsec is the ﬂux-averaged total reaction cross section in natural units (MeV−2/atom,
see section 7.4). This line is followed by one or more event records, each of which begins with the
header

Ni Nf Ex twoJ P

where Ni (Nf) is the number of particles in the initial (ﬁnal) state. The three remaining ﬁelds in
the event header report properties of the recoiling nucleus immediately following the prompt 2
2
scattering reaction. The quantity Ex is the excitation energy (MeV), twoJ is an integer equal to
two times the total spin,28 and P is a single character representing either positive (+) or negative
(-) parity.

→

Following the event header, each of the Ni initial-state particles is described by a single line of

the form

PDG Etot Px Py Pz M Q

where PDG is the PDG code (see section 7.1) identifying the particle species and Etot, Px, Py, and
Pz are the Cartesian components of the particle 4-momentum (in MeV). The particle mass M (MeV)
and (net) electric charge Q (in units of the elementary charge) are also included in each line. To
complete the event record, Nf lines describing the ﬁnal-state particles appear in the same format
used for the initial-state particles.

To preserve full numerical precision when converting back and forth between marley::Event
objects held in memory and ASCII-format event ﬁles, all ﬂoating point numbers are output in
scientiﬁc notation with the required number of base-10 digits needed to uniquely represent all
distinct values of the C++ type double.29 However, this level of precision is not enforced by the
code when reading events as input from an ASCII ﬁle.

28This allows representation of half-integer spins using a C++ int
29This number is called std::numeric limits<double>::max digits10 in the C++ standard library.

48

1
2
3

4

5

6

7

8

5 . 9 8 3 6 8 8 6 7 4 4 7 2 6 72 6 4 e -19
2 4 3 . 7 9 7 4 8 0 00 0 0 0 0 0 0 0 1 9 e +00 2 +
12 1 . 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 e +01 0 . 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 e +00 0 . 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 e +00

1 . 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 e +01 0 . 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 e +00 0

1000180400 3 . 7 2 2 47 2 2 5 4 3 1 5 1 80 9 1 e +04 0 . 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 e +00 0 . 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 e +00

0 . 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 e +00 3 . 7 2 2 4 7 2 2 5 4 3 1 5 1 8 0 9 1 e +04 0

11 5 . 2 0 6 90 8 8 6 8 1 5 2 6 67 4 0 e +00 -4.63535385338761508 e +00 1 . 3 5 7 0 65 4 6 7 3 0 5 7 9 31 4 e +00

-1.87687187323011373 e +00 5 . 1 0 9 9 8 9 2 76 4 5 9 0 7 7 0 8 e -01 -1

1000190400 3 . 7 2 2 57 1 7 5 0 6 8 0 4 40 8 9 e +04 4 . 9 8 0 6 6 1 8 48 7 9 1 4 3 8 4 7 e +00 -2.27058729207187593 e +00

9 . 2 8 45 6 4 1 0 7 6 7 7 41 8 5 8 e +00 3 . 7 2 2 5 7 1 5 9 4 6 5 1 6 2 4 7 6 e +04 1

22 1 . 5 3 6 94 3 5 2 4 3 4 6 2 06 6 2 e +00 -1.11400145523226901 e +00 9 . 5 0 7 5 17 5 8 1 0 0 7 5 6 62 8 e -01

4 . 6 6 11 9 3 5 0 8 5 1 7 38 2 2 3 e -01 0 . 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 e +00 0

22 2 . 2 6 1 18 3 9 5 4 9 0 6 7 39 8 5 e +00 7 . 6 8 6 9 3 4 5 98 2 8 4 4 5 8 3 5 e -01 -3.72299333346743089 e -02

2 . 1 2 61 8 8 4 1 4 7 0 0 95 3 5 4 e +00 0 . 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 e +00 0

9
10

2 3 1 . 0 3 9 6 4 2 00 0 0 0 0 0 0 0 0 9 e +01 2 +
12 2 . 9 9 3 04 8 8 5 5 4 9 5 1 12 9 0 e +01 0 . 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 e +00 0 . 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 e +00

2 . 9 9 30 4 8 8 5 5 4 9 5 11 2 9 0 e +01 0 . 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 e +00 0

11

1000180400 3 . 7 2 2 47 2 2 5 4 3 1 5 1 80 9 1 e +04 0 . 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 e +00 0 . 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 e +00

0 . 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 e +00 3 . 7 2 2 4 7 2 2 5 4 3 1 5 1 8 0 9 1 e +04 0

12

11 1 . 8 5 2 23 4 7 7 9 5 4 3 2 07 2 1 e +01 -9.86795370224160173 e +00 -1.55256312663347771 e +01

-2.09630900945355991 e +00 5 . 1 0 9 9 8 9 2 76 4 5 9 0 7 7 0 8 e -01 -1

13

1000190390 3 . 6 2 9 40 2 6 0 7 4 3 9 2 90 3 0 e +04 -1.74322423197586254 e +01 -4.21863040207651636 e +01

5 . 8 5 22 5 7 7 1 2 3 6 2 73 1 4 7 e +01 3 . 6 2 9 3 9 5 0 18 7 7 2 9 0 7 5 0 e +04 1

14

2112 9 . 4 2 1 0 4 6 09 5 1 8 4 2 6 4 0 0 e +02 2 . 7 3 0 0 1 9 6 0 2 2 0 00 2 2 8 9 e +01 5 . 7 7 1 1 9 35 2 8 7 0 9 9 9 4 07 e +01

-2.64957795592226226 e +01 9 . 3 9 5 6 5 3 7 86 5 3 3 3 9 7 3 5 e +02 0

Listing 11: Example ASCII-format output ﬁle

×

×

10−19 MeV−2 = 2.330

Listing 11 shows an example MARLEY output ﬁle in ASCII format. Line 1 gives the value of
10−40 cm2 for the ﬂux-averaged total cross section. Line 2 begins
5.984
the record for the ﬁrst event, which involves a transition to the 40K nuclear level with an excitation
energy of 3.797 MeV above the ground state and spin-parity 1+. Lines 3–4 describe the initial
state: a 10 MeV νe traveling in the +z direction toward a 40Ar atom at rest. Lines 5–8 describe the
ﬁnal-state particles: a 5.2 MeV electron, the recoiling 40K ion, and two de-excitation γ-rays with
energies of 1.54 and 2.26 MeV. The second and ﬁnal event in the ﬁle, which appears on lines 9–14,
involves a νe-40Ar collision which produces an electron, a 39K ion, and a neutron.

7.2.2. HEPEVT ﬁle format

For the sake of brevity, only those aspects of the HEPEVT format needed to interpret MARLEY
output are discussed in this section. A full description of the HEPEVT standard is available in
ref. [164, pp. 327–330].

A HEPEVT-format output ﬁle consists of one or more text-based event records. Each of these

records begins with the header

NEVHEP NHEP

where NEVHEP is the event number (untracked by MARLEY and thus always set to zero) and NHEP
is the number of particles in the event. The header is followed by NHEP lines, each representing a
single particle. These have the format

ISTHEP IDHEP JMOHEP1 JMOHEP2 JDAHEP1 JDAHEP2 PHEP1 PHEP2 PHEP3 PHEP4 PHEP5

VHEP1 VHEP2 VHEP3 VHEP4

where ISTHEP is an integer code identifying the particle status and IDHEP is the PDG particle
In agreement with the HEPEVT standard, MARLEY uses status code 1 for the ﬁnal-
ID code.
state particles and 3 for the initial-state particles, the latter of which are not considered part of

49

→

j

≤

≤

the event history [164]. The JMOHEP1, JMOHEP2, JDAHEP1, and JDAHEP2 entries record the indices
NHEP) of particles in the event record that correspond to the ﬁrst mother, second
j (1
mother, ﬁrst daughter, and last daughter of the current particle, respectively. These indices are
set to zero in cases where they do not apply (e.g., a particle which has not decayed will have
JDAHEP1 = JDAHEP2 = 0). Entries PHEP1 through PHEP3 record the x, y, and z components of the
particle 3-momentum, while PHEP4 gives the total energy and PHEP5 gives the particle mass (all
in GeV). Entries VHEP1 through VHEP3 store the x, y, and z positions of the particle production
vertex (mm), and VHEP4 gives the production time (mm/c).

Because MARLEY currently treats all nuclear de-excitations as instantaneous and does not perform
any particle tracking, VHEP1 through VHEP4 are always identically zero in HEPEVT output ﬁles.
Intermediate de-excitation steps are also not currently stored in the event record, so JMOHEP1,
JMOHEP2, JDAHEP1, and JDAHEP2 are also identically zero in most cases.

In addition to the initial- and ﬁnal-state particles, MARLEY adds a dummy particle with ISTHEP =
11 to each HEPEVT event record. All data ﬁelds are zero for this particle except for (1) JMOHEP1,
which contains the nuclear spin multiplied by two, (2) JMOHEP2, which reports the parity of the nu-
cleus as an integer, (3) PHEP4, which gives the excitation energy of the nucleus (MeV), and (4) PHEP5,
which records the ﬂux-averaged total cross section (see section 7.4) in units of MeV−2 / atom. As
is the case for the ASCII format, the excitation energy, spin, and parity values refer to the nuclear
state that existed immediately after the initial 2

2 scattering reaction.

0 7
3 12 0 0 0 0 0. 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 e +00 0 . 0 0 0 0 00 0 0 0 0 0 0 0 0 0 00 e +00 1 .0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 2 e -02

1 . 0 0 0 00 0 0 0 0 0 0 0 0 0 00 2 e -02 0 .0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 e +00 0. 0. 0. 0.

3 1000180400 0 0 0 0 0 . 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 e +00 0 . 0 00 0 0 0 0 0 0 0 0 0 00 0 0 0 e +00 0 . 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 e +00

3 . 7 2 2 47 2 2 5 4 3 1 5 1 8 06 1 e +01 3 .7 2 2 4 7 2 2 5 4 31 5 1 8 0 6 1 e +01 0. 0. 0. 0.

11 0 2 1 0 0 0 . 00 0 0 0 0 0 0 0 0 0 00 0 0 0 0 e +00 0 . 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 e +00 0 . 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 e +00

3 . 7 9 7 48 0 0 0 0 0 0 0 0 0 01 9 e +00 5 .9 8 3 6 8 8 6 7 4 47 2 6 7 2 6 4 e -19 0. 0. 0. 0.

1 11 0 0 0 0 -4.63535385338761496 e -03 1 . 3 5 7 0 6 5 46 7 3 0 5 7 9 3 2 0 e -03 -1.87687187323011366 e -03

5 . 2 0 6 90 8 8 6 8 1 5 2 6 6 74 9 e -03 5 .1 0 9 9 8 9 2 7 6 45 9 0 7 7 1 0 e -04 0. 0. 0. 0.

1 1000190400 0 0 0 0 4 . 9 8 0 6 6 1 84 8 7 9 1 4 3 8 1 2 e -03 -2.27058729207187593 e -03 9 .2 8 4 5 6 4 1 0 7 6 77 4 1 9 4 2 e -03

3 . 7 2 2 57 1 7 5 0 6 8 0 4 4 07 7 e +01 3 .7 2 2 5 7 1 5 9 4 65 1 6 2 4 5 9 e +01 0. 0. 0. 0.

1 22 0 0 0 0 -1.11400145523226908 e -03 9 . 5 0 7 5 1 7 58 1 0 0 7 5 6 6 5 5 e -04 4 . 6 6 11 9 3 5 0 8 5 1 7 38 2 0 6 e -04

1 . 5 3 6 94 3 5 2 4 3 4 6 2 0 66 8 e -03 0 .0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 e +00 0. 0. 0. 0.

1 22 0 0 0 0 7. 6 8 6 9 3 4 5 9 82 8 4 4 5 8 0 8 e -04 -3.72299333346743093 e -05 2 . 1 2 61 8 8 4 1 4 7 0 0 95 3 4 7 e -03

2 . 2 6 1 18 3 9 5 4 9 0 6 7 4 00 0 e -03 0 .0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 e +00 0. 0. 0. 0.

0 6
3 12 0 0 0 0 0. 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 e +00 0 . 0 0 0 0 00 0 0 0 0 0 0 0 0 0 00 e +00 2 .9 9 3 0 4 8 8 5 5 4 95 1 1 2 8 3 e -02

2 . 9 9 3 04 8 8 5 5 4 9 5 1 1 28 3 e -02 0 .0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 e +00 0. 0. 0. 0.

3 1000180400 0 0 0 0 0 . 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 e +00 0 . 0 00 0 0 0 0 0 0 0 0 0 00 0 0 0 e +00 0 . 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 e +00

3 . 7 2 2 47 2 2 5 4 3 1 5 1 8 06 1 e +01 3 .7 2 2 4 7 2 2 5 4 31 5 1 8 0 6 1 e +01 0. 0. 0. 0.

11 0 2 1 0 0 0 . 00 0 0 0 0 0 0 0 0 0 00 0 0 0 0 e +00 0 . 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 e +00 0 . 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 e +00

1 . 0 3 9 64 2 0 0 0 0 0 0 0 0 00 9 e +01 5 .9 8 3 6 8 8 6 7 4 47 2 6 7 2 6 4 e -19 0. 0. 0. 0.

1 11 0 0 0 0 -9.86795370224160216 e -03 -1.55256312663347770 e -02 -2.09630900945356009 e -03

1 . 8 5 2 23 4 7 7 9 5 4 3 2 0 72 4 e -02 5 .1 0 9 9 8 9 2 7 6 45 9 0 7 7 1 0 e -04 0. 0. 0. 0.

1 1000190390 0 0 0 0 -1.74322423197586264 e -02 -4.21863040207651613 e -02 5 . 8 52 2 5 7 7 1 2 3 6 2 73 1 6 0 e -02

3 . 6 2 9 40 2 6 0 7 4 3 9 2 9 03 1 e +01 3 .6 2 9 3 9 5 0 1 8 77 2 9 0 7 3 8 e +01 0. 0. 0. 0.

1 2112 0 0 0 0 2 . 7 3 0 01 9 6 0 2 2 0 0 0 23 0 3 e -02 5. 7 7 1 1 9 3 5 2 8 70 9 9 9 4 0 0 e -02 -2.64957795592226236 e -02

9 . 4 2 1 04 6 0 9 5 1 8 4 2 6 45 0 e -01 9 .3 9 5 6 5 3 7 8 6 53 3 3 9 7 7 8 e -01 0. 0. 0. 0.

Listing 12: Example HEPEVT-format output ﬁle

Listing 12 shows an example MARLEY output ﬁle in HEPEVT format. The same two events from

the ASCII-format example ﬁle (see listing 11) are used for easy comparison of the formats.

7.2.3. JSON ﬁle format

Unlike MARLEY job conﬁguration ﬁles, which allow a few non-standard JSON language extensions
(see section 6 for details), the JSON-format output ﬁles fully conform to the standard grammar.

50

1
2

3

4

5

6

7

8

9
10

11

12

13

14

15

Each output ﬁle includes two top-level keys: events, which is associated with an array of event
objects, and gen state, which stores a JSON object representation of the generator state at the
moment that the ﬁle was created.

Each element of the events array is a JSON object containing ﬁve key-value pairs. The ﬁrst
three of these, Ex, twoJ, and parity, provide the excitation energy (MeV), two times the total
spin, and the parity of the ﬁnal nucleus after the initial 2
2 scattering reaction but before any
de-excitations have taken place. The other two keys, initial particles and final particles,
are used store arrays of particles represented as JSON objects. Each particle object deﬁnes the
following keys: (1) charge: the (net) electric charge in units of the elementary charge, (2) pdg:
the PDG code identifying the particle type, (3) E: the total energy, (4) px: the x momentum
component, (5) py: the y momentum component, (6) pz: the z momentum component, and
(7) mass: the particle mass. The particle 4-momentum components and mass are all given in
natural units (MeV).

→

The gen state JSON object includes several key-value pairs. The config key refers to a
JSON object which reproduces the full contents (except for comments) of the job conﬁguration
ﬁle used to generate the events. The event count, flux avg xsec, and seed keys label the total
number of events generated at the time the ﬁle was written, the ﬂux-averaged total cross section
(MeV−2 / atom, see section 7.4), and the integer random number seed used to initialize the event
generator. A ﬁnal key, generator state string, records a string representation of the internal
state of the std::mt19937 64 object used by MARLEY to obtain pseudorandom numbers.

An example MARLEY output ﬁle in JSON format (example.json) is included in the supplemental

materials.

7.2.4. ROOT ﬁle format

If MARLEY has been built against the appropriate shared libraries from the ROOT data analysis
toolkit (see section 5), then the marley command-line executable may also produce output ﬁles in
the standard ROOT compressed binary format.

Within a ROOT-format output ﬁle, access to the generated events is managed by an instance
of the ROOT TTree class, which provides a hierarchical data structure for storing many objects
belonging to the same C++ type. In general, a TTree may own one or more branches (represented
by the TBranch class), each of which owns one or more leaves (represented by TLeaf). Branches
may be read from a ﬁle independently of one another, allowing for eﬃcient access to elements of a
large dataset stored in a suitably-organized TTree [166].

The ROOT-format output ﬁles generated by MARLEY contain a single TTree called MARLEY event
tree. This TTree contains a single branch called event, which stores one marley::Event object
per tree entry. Although direct access to the events is possible by manipulating the MARLEY event
tree, use of the simpliﬁed C++ API described in section 7.3 is recommended instead.

In addition to the MARLEY events themselves, four pieces of metadata are stored in a ROOT-

format output ﬁle:

MARLEY conﬁg (std::string) A JSON-format string which stores the contents (except for com-

ments) of the job conﬁguration ﬁle used to generate the events (see section 6)

MARLEY state (std::string) Serialized internal state (obtained using the stream insertion op-
erator <<) of the std::mt19937 64 object (see section 3) owned by the marley::Generator
object used to create the events

51

MARLEY seed (std::string) A string representation of the integer random number seed used to

initialize the simulation

MARLEY ﬂux avg xsec (TParameter<double>) The ﬂux-averaged total cross section (MeV−2 / atom)

needed to normalize physics distributions computed from the events (see section 7.4)

In listing 13, an example C++ function is shown which retrieves all of these metadata objects from
a ﬁle called events.root and prints their contents to standard output.

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

// Standard library includes
# include < iostream >
# include < string >

// ROOT includes
# include " TFile . h "
# include " TParameter . h "

void print_metadata () {

TFile event_file ( " events . root " , " read " ) ;

std :: string * config = NULL ;
std :: string * state = NULL ;
std :: string * seed = NULL ;
TParameter < double >* xsec = NULL ;

event_file . GetObject ( " MARLEY_config " , config ) ;
event_file . GetObject ( " MARLEY_state " , state ) ;
event_file . GetObject ( " MARLEY_seed " , seed ) ;
event_file . GetObject ( " MARLEY_flux_avg_xsec " , xsec ) ;

std :: cout << " MARLEY configuration : " << * config << ’\ n ’;
std :: cout << " Generator internal state : " << * state << ’\ n ’;
std :: cout << " Random number seed : " << * seed << ’\ n ’;
std :: cout << " Flux - averaged total cross section : " << xsec - > GetVal ()

<< " MeV ^{ -2} / atom \ n " ;

}

Listing 13: Example access to MARLEY metadata stored in a ROOT-format output ﬁle

The ROOT output ﬁles described above may be converted into an alternative “ﬂat” format
which is readable by ROOT without a need for the MARLEY shared libraries. This is done by
running the marsum command-line tool described in section 7.3.5.

7.3. C++ analysis API

Although the ﬁle format descriptions given in section 7.2 should be suﬃcient to enable processing
of MARLEY events using any programming language, a C++ API allowing manipulation of events
stored in any of the standard output formats has been developed for the convenience of users. The

52

API is usable within compiled code as well as via the interactive C++ interpreters included with
ROOT.30

7.3.1. The EventFileReader class

Programmatic access to MARLEY event records stored in a ﬁle is provided by the marley::Event
FileReader class. The constructor of this class takes as its sole argument a std::string containing
the name (including any needed path speciﬁcation) of the ﬁle to be parsed. Events may be read
one-by-one from the ﬁle using the stream extraction operator >>, which returns a boolean value
indicating whether a new event was successfully loaded.

Listing 14 shows the source code for examples/executables/minimal/efr.cc, an example C++
program that illustrates the recommended usage of the EventFileReader class. Line 12 creates a
new EventFileReader object that will read MARLEY events from a ﬁle whose name is given as the ﬁrst
command-line argument when the program is run. The while loop on lines 19–21 streams all events
in the ﬁle to standard output, where they will be printed in ASCII format. Line 15 contains a call
to the EventFileReader member function flux averaged xsec, which returns the ﬂux-averaged
total cross section (see section 7.4) used to generate the events in units of 10−42 cm2 / atom. Passing
a boolean value of true to this function will cause it to return the cross section in natural units
(MeV−2 / atom) instead.

# include < iostream >

# include " marley / Event . hh "
# include " marley / EventFileReader . hh "

int main ( int argc , char ** argv ) {

if ( argc < 2 ) return 1;

std :: string input_file_name ( argv [1] ) ;

marley :: EventFileReader efr ( input_file_name ) ;
marley :: Event event ;

double avg_xsec = efr . flux_averaged_xsec () ;
std :: cout << " flux - averaged total cross section = "

<< avg_xsec << " * 10^{ -42} cm ^2 / atom \ n " ;

while ( efr >> event ) {

std :: cout << event << ’\ n ’;

}

return 0;

}
Listing 14: The source code for examples/executables/minimal/efr.cc, an example C++ program that uses the
marley::EventFileReader class

30The CINT [167] interpreter is distributed with version 5 of ROOT, while version 6 uses Cling [168].

53

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

To build the efr.cc example program, it is necessary to link the executable to the MARLEY
shared library. This is most easily done using the marley-config script with the syntax described
in section 5.5.1.

The EventFileReader class can parse MARLEY output ﬁles written in the ASCII, HEPEVT,
and JSON formats. If MARLEY has been built against ROOT (see section 5), then support for the
ROOT output format in addition to the others is available via the RootEventFileReader class.
This class is derived from EventFileReader and implements an identical user interface. Making
RootEventFileReader on lines 4 and 12 of listing 14 will
the replacement EventFileReader
yield a program that is capable of reading events from any MARLEY output ﬁle. Compiling this
modiﬁed program requires linking to the shared library containing the MARLEY interface to ROOT.
The build command given in section 5.5.1 will automatically include the necessary compiler ﬂags
for linking to ROOT if MARLEY was successfully built with ROOT support.

→

7.3.2. Accessing information from an event record

As discussed in section 2, MARLEY conceives of each scattering event as consisting of a primary
2 reaction possibly followed by nuclear de-excitations. The particle content of the primary

2
reaction may be written in the general form

→

a + b

c + d

(91)

→
where particles a, b, c, and d, are respectively termed the projectile, target, ejectile, and residue.
Where a mass diﬀerence exists, MARLEY chooses the projectile (ejectile) to be the lighter of the two
particles in the initial (ﬁnal) state. Otherwise, the choice is arbitrary. All four-vector components
stored in a MARLEY event record are expressed in the laboratory frame, i.e., the rest frame of the
target.

A full MARLEY event record is represented in the code itself by the marley::Event class. In-
stances of this class own two vectors of pointers to marley::Particle objects, with one (initial
particles ) describing the initial state and the other (final particles ) describing the ﬁnal
state. Within the initial particles vector, the ﬁrst and second elements always correspond to
the projectile and target, respectively. A similar ordering (ejectile followed by residue) is enforced
for the ﬁrst two elements of the final particles vector. If present, elements of final particles
beyond the second correspond to nuclear de-excitation products, which are listed in the order that
they were emitted. If nuclear de-excitations were enabled in the simulation (as they are by default,
see section 4.1.7), then the Particle object for the residue stores its properties after it has reached
the ground state.

The Event class provides the following member functions for accessing Particle objects stored

in the event record:

projectile(), target(), ejectile(), residue() Returns a reference to a speciﬁc particle involved in the

primary 2

→

2 reaction

get initial particles() Returns a reference to the owned vector of initial particles

get ﬁnal particles() Returns a reference to the owned vector of ﬁnal particles

initial particle count() Returns the number of initial-state particles in the event

ﬁnal particle count() Returns the number of ﬁnal-state particles in the event

54

initial particle(size t idx) Returns a constant reference to the initial-state particle at position idx

ﬁnal particle(size t idx) Returns a constant reference to the ﬁnal-state particle at position idx

The Particle class stores a 4-momentum (represented as a C-style array of type double[4])
together with variables representing particle properties. It implements the following member func-
tions for data retrieval:

charge() Electric charge (in units of the proton charge)

mass() Mass (MeV)

pdg code() PDG code [163, sec. 44, pp. 661–664] representing the particle species

px() 3-momentum x-component (MeV)

py() 3-momentum y-component (MeV)

pz() 3-momentum z-component (MeV)

kinetic energy() Kinetic energy (MeV)

total energy() Total energy (MeV)

All of these functions return a value of type double except for pdg code(), which returns an int.
In addition to Particle objects, the Event class also stores information about the state of the
2 reaction. Access to this information is

residue immediately after its creation by the prompt 2
provided by these member functions:

→

Ex() Initial residue excitation energy (double, MeV), measured with respect to its own ground

state

twoJ() Two times the initial residue spin (int)

parity() Initial residue parity (marley::Parity)

1. It may be converted to a boolean (true

The Parity object returned by Event::parity() provides a type-safe representation of a parity
1) or integer representation
value
via an explicit cast. A Parity object may also be converted to a char value (+
1)
via the member function to char().

+1, false

+1, -

↔ −

↔ −

↔

↔

±

Full technical documentation for the Event, Particle, and Parity classes is available on the
oﬃcial MARLEY website [149]. Similar HTML documentation may be automatically generated for
oﬄine use from the MARLEY source code using Doxygen [169]. After Doxygen has been installed,
one may build the MARLEY API documentation ﬁles by executing

make doxygen

from within the build/ folder. The generated documentation may then be viewed using any web
browser by opening the ﬁle docs/ build/html/doxygen/index.html

55

7.3.3. Executable example: marprint

The marprint program (examples/executables/marprint.cc) included with MARLEY provides
a detailed example of how the C++ analysis API may be used in compiled code. After instantiating
either an EventFileReader or a RootEventFileReader object (depending on whether MARLEY was
built against ROOT), the program prints all information stored in each event to standard output
using a human-readable format. Usage examples for many of the functions listed in section 7.3.2
are provided within the marprint.cc source ﬁle. After sourcing the setup marley.sh script, one
may build the marprint example program via the commands
cd $ { MARLEY }/ build
make marprint

The marprint executable takes the names of one or more ﬁles containing MARLEY events as command-
line arguments. For example, one may print all of the events stored in the ﬁles /home/events1.ascii
and /home/events2.json by executing

marprint / home / events1 . ascii / home / events2 . json

Listing 15 shows the printout generated by marprint while parsing the ﬁrst event given in the
example ASCII-format output ﬁle shown above (listing 11).

*** Event 0 has 2 initial particles and 4 final particles . ***
The residual nucleus initially had excitation energy 3.79748 MeV and spin - parity 1+
Initial particles

particle with PDG code = 12 has total energy 10 MeV ,

3 - momentum = (0 MeV , 0 MeV , 10 MeV ) ,
mass = 0 MeV , and charge = 0 times the proton charge .

particle with PDG code = 1000180400 has total energy 37224.7 MeV ,

3 - momentum = (0 MeV , 0 MeV , 0 MeV ) ,
mass = 37224.7 MeV , and charge = 0 times the proton charge .

Final particles

particle with PDG code = 11 has total energy 5.20691 MeV ,
3 - momentum = ( -4.63535 MeV , 1.35707 MeV , -1.87687 MeV ) ,
mass = 0.510999 MeV , and charge = -1 times the proton charge .
particle with PDG code = 1000190400 has total energy 37225.7 MeV ,

3 - momentum = (4.98066 MeV , -2.27059 MeV , 9.28456 MeV ) ,
mass = 37225.7 MeV , and charge = 1 times the proton charge .

particle with PDG code = 22 has total energy 1.53694 MeV ,
3 - momentum = ( -1.114 MeV , 0.950752 MeV , 0.466119 MeV ) ,
mass = 0 MeV , and charge = 0 times the proton charge .
particle with PDG code = 22 has total energy 2.26118 MeV ,

3 - momentum = (0.768693 MeV , -0.0372299 MeV , 2.12619 MeV ) ,
mass = 0 MeV , and charge = 0 times the proton charge .

Listing 15: Example output generated by the marprint program

The commands needed to build marprint (and a second example program, mardumpxs, described
in section 7.4.2) against the MARLEY shared libraries are given in the Makefile located in the folder
examples/executables/build/. Users are encouraged to adapt this Makefile for building their
own C++ programs that interface with MARLEY.

7.3.4. Example ROOT macros

As a second example of the MARLEY analysis API, several ROOT macros, i.e., programs in-
tended to be run using the interactive C++ interpreter distributed with ROOT, are provided in the
examples/macros/ folder. Although RootEventFileReader and the other MARLEY classes are fully

56

compatible with version 6 of ROOT, version 5 lacks support for C++11 features, which are used
extensively by MARLEY. To work around this problem, MARLEY provides a class called MacroEvent
FileReader which is usable within macros written for both versions 5 and 6 of ROOT. This class
provides the same interface to MARLEY events as RootEventFileReader, but the use of C++ syntax
that is incompatible with ROOT 5 has been hidden from the interpreter.

In order to correctly interact with MARLEY classes, ROOT requires precompiled dictionaries to
be loaded at runtime. These are stored in the MARLEY ROOT shared library. To avoid the need
for users to manually load the MARLEY class dictionaries at the start of each ROOT interpreter
session, a startup script called mroot is placed in the build/ folder whenever MARLEY is successfully
built against ROOT. After sourcing the setup marley.sh setup script (see section 5.3), issuing the
command

mroot

will start the interactive ROOT interpreter and automatically load the MARLEY class dictionaries.
For version 5 of ROOT, only the Event, Particle, Parity, and MacroEventFileReader classes
(all deﬁned within the marley namespace) may be used within an mroot session. For ROOT 6, all
MARLEY classes will be available if the appropriate header ﬁles are loaded via #include statements.
The README.md ﬁle in the examples/macros/ folder gives brief descriptions of each of the
example ROOT macros together with usage instructions. Users are encouraged to adopt these
macros as a starting point for implementing their own calculations.

7.3.5. “Flat” ROOT ﬁles: the marsum utility

Although they are expected to be suitable for many applications, the standard ROOT-format
output ﬁles generated by MARLEY (see section 7.2.4) have two important limitations: (1) They are
only fully readable in environments in which both ROOT and MARLEY are installed, and (2) Each
Event object to be analyzed must be loaded from disk in its entirety.

To address these limitations, MARLEY provides a command-line utility called marsum, which
takes as input one or more ﬁles containing MARLEY events stored in any of the standard output
formats. The marsum program creates a new ﬁle in which many quantities of interest from the
input events have been saved as individual branches of a ROOT TTree. Following a successful
build of MARLEY with ROOT support (see section 5), the marsum executable will be present in the
build/ folder. Assuming that the setup marley.sh script has already been sourced, one may
execute the command

marsum myout . root / home / events1 . root / home / events2 . ascii

to create a new ﬁle called myout.root in the working directory. This ﬁle will contain a single
ROOT TTree named mst (for “MARLEY summary tree”31) with one entry for each event present in
the two input ﬁles (/home/events1.root and /home/events2.ascii). The mst TTree will contain
the following branches:

pdgv (int) Projectile PDG code

Ev (double) Projectile total energy (MeV)

31This output format was inspired by the similar “gst” TTree produced by the gntpc utility distributed with

GENIE [170, sec. 7.6.2, pp. 112–115].

57

KEv (double) Projectile kinetic energy (MeV)

pxv (double) Projectile 3-momentum x-component (MeV)

pyv (double) Projectile 3-momentum y-component (MeV)

pzv (double) Projectile 3-momentum z-component (MeV)

pdgt (int) Target PDG code

Mt (double) Target mass (MeV)

pdgl (int) Ejectile PDG code

El (double) Ejectile total energy (MeV)

KEl (double) Ejectile kinetic energy (MeV)

pxl (double) Ejectile 3-momentum x-component (MeV)

pyl (double) Ejectile 3-momentum y-component (MeV)

pzl (double) Ejectile 3-momentum z-component (MeV)

pdgr (int) Residue PDG code

Er (double) Residue total energy (MeV)

KEr (double) Residue kinetic energy (MeV)

pxr (double) Residue 3-momentum x-component (MeV)

pyr (double) Residue 3-momentum y-component (MeV)

pzr (double) Residue 3-momentum z-component (MeV)

Ex (double) Initial residue excitation energy (MeV)

twoJ (int) Two times the initial residue spin

parity (int) Initial residue parity

np (int) Number of de-excitation products

pdgp (int[np] ) De-excitation product PDG codes

Ep (double[np] ) De-excitation product total energies (MeV)

KEp (double[np] ) De-excitation product kinetic energies (MeV)

pxp (double[np] ) De-excitation product 3-momentum x-components (MeV)

pyp (double[np] ) De-excitation product 3-momentum y-components (MeV)

pzp (double[np] ) De-excitation product 3-momentum z-components (MeV)

xsec (double) Flux-averaged total cross section (10−42 cm2 / atom)
The “ﬂat” ﬁle created in this way will be readable by ROOT without the need to load the MARLEY
class dictionaries. Individual branches may also be loaded and plotted (e.g., via the TTree::Draw
member function) without the need to manipulate the event as a whole.

58

7.4. Converting event distributions to physics quantities

The theoretical predictions made by an event generator like MARLEY may most usefully be com-
pared to competing calculations and experimental data in the form of cross sections and event
rates. To see how these quantities may be obtained from a set of simulated events, ﬁrst note that
the expression given in eq. (73) for the probability density P (Eν) of the energy Eν of a reacting
neutrino may be rewritten in the form

P (Eν) =

φ(Eν) σ(Eν)
σ
(cid:104)

Φ

(cid:105)

where

is the total neutrino ﬂux and

Emax
ν

Φ

≡

Emin
ν

(cid:90)

φ(Eν) dEν

σ

(cid:104)

(cid:105) ≡

1
Φ

Emax
ν

φ(Eν) σ(Eν) dEν

Emin
ν

(cid:90)

(92)

(93)

(94)

is the (abundance-weighted) ﬂux-averaged total cross section. Let x denote an arbitrary, continuously-
distributed observable that is computable from a MARLEY event record. Then, for a single event,
the probability Pj that x falls within the jth bin x

[xj, xj+1) is given by

∈

Emax
ν

xj+1

Pj =

P (Eν)

Emin
ν

(cid:90)

xj

(cid:90)

P (x

Eν) dx dEν =
|

1
σ
(cid:104)

xj+1

xj

(cid:105) (cid:90)

(cid:28)

dσ
dx

(cid:29)

dx

where

P (x

Eν) =
|

1
σ(Eν)

dσ(Eν)
dx

(95)

(96)

is the conditional probability density of x at ﬁxed neutrino energy, dσ(Eν)/dx is the total diﬀerential
cross section with respect to x, and

dσ
dx

(cid:28)

≡

(cid:29)

1
Φ

Emax
ν

φ(Eν)

Emin
ν

(cid:90)

dσ(Eν)
dx

dEν

(97)

is the ﬂux-averaged total diﬀerential cross section. A Monte Carlo estimator for the average value
of this quantity in the jth bin may be obtained via

xj+1

dσ
dx

(cid:28)

(cid:29)j ≡

1
∆xj (cid:90)

xj

dσ
dx

(cid:28)

(cid:29)

dx

≈

fj
σ
(cid:104)
(cid:105)
∆xj

,

(98)

≡

xj+1

xj is the bin width and fj = nj/N is the ratio of the nj events that fall within
where ∆xj
the jth bin to the total number N of simulated events. Recognizing that nj follows a binomial
distribution allows for an estimate of the associated Monte Carlo statistical uncertainty (standard
deviation) via

−

dσ
dx

SD

(cid:32)(cid:28)

(cid:29)j(cid:33) ≈

σ
(cid:105)
(cid:104)
∆xj N (cid:114)

(N

−

nj) nj
N

.

(99)

59

The results from eqs. (98) and (99) may readily be extended to multiple dimensions. For a Monte
Carlo calculation of an n-dimensional diﬀerential cross section, simply let ∆xj denote the product
of the n widths of the jth bin in the n-dimensional phase space.

For a discrete observable, similar expressions may be used with the bin width ∆xj omitted.
The ﬂux-averaged partial cross section
(cid:105)j to produce events fulﬁlling a criterion j (e.g., involving
emission of a single neutron) is estimated from the simulation results via
fj, where
fj = nj/N is the fraction of simulated events satisfying the criterion. The statistical uncertainty
of this estimator is approximated by the expression on the right-hand side of eq. (99) with the
substitution ∆xj

(cid:105)j ≈ (cid:104)

σ
(cid:104)

1.

σ

σ

(cid:104)

(cid:105)

→

7.4.1. Examples

Figure 3 shows the results of two example calculations of physics observables performed using
MARLEY events and the procedure outlined in section 7.4. The histograms shown in the left and
106 events each.
right panels of ﬁg. 3 were computed using independent simulations of N = 2
To produce the left-hand plot, coherent elastic neutrino-nucleus scattering (CEvNS) on 40Ar was
simulated for ¯νµ produced by µ+ decays at rest (see section 6.5.4). A histogram describing the
distribution of the kinetic energy Tf of the recoiling ﬁnal-state nucleus was prepared from the
simulated events using a uniform bin width ∆Tf = 1.5 keV. The event counts nj from each bin
were renormalized according to eq. (98) to yield a Monte Carlo estimator for the mean value of the
ﬂux-averaged diﬀerential cross section in the jth bin:

×

dσ
dTf (cid:29)j ≈

(cid:28)

nj
σ
(cid:104)
(cid:105)
N ∆Tf

.

(100)

σ

= 26.69

10−40 cm2/ 40Ar is the MARLEY prediction for the CEvNS ﬂux-averaged total
Here
cross section. Equation (100) gives the expression used to obtain the content of each histogram bin
shown in the left-hand plot of ﬁg. 3. Based on eq. (99), an estimate of the statistical uncertainty

×

(cid:105)

(cid:104)

dσ
dTf (cid:29)j(cid:33) ≈
associated with each bin was also calculated but is small on the scale of the plot.

σ
(cid:105)
(cid:104)
N ∆Tf (cid:114)

nj) nj
N

(cid:32)(cid:28)

SD

(N

−

(101)

A similar procedure was used to obtain the distribution shown in the right-hand plot of ﬁg. 3,
but the quantity of interest is Te, the kinetic energy of the electron produced in the charged-current
reaction 40Ar(νe, e−)40K
. The simulation of this process was carried out using the reaction input
ﬁle ve40ArCC Bhattacharya1998.react (see section 6.4.1). The incident neutrino spectrum was
deﬁned using the Fermi-Dirac source shown in listing 5, which was treated as a toy model of
the time-integrated νe ﬂux at Earth produced by a core-collapse supernova. The ﬂux-averaged
diﬀerential cross section was converted into a diﬀerential event rate via

∗

(cid:28)
where a total time-integrated ﬂux32 of Φ = 1.0
1032 atoms in 10 kt of pure 40Ar.
1.5

×

×

d
N
dTe

= Φ

ntargets

dσ
dTe (cid:29)
1011 νe / cm2 was assumed. There are ntargets =

(102)

32The quoted value is a rough estimate for a core-collapse supernova at 10 kpc from Earth.

60

Figure 3: Example MARLEY calculations of physics observables. LEFT: The ﬂux-averaged diﬀerential cross section
for muon decay-at-rest ¯νµ undergoing coherent elastic neutrino-nucleus scattering on 40Ar. RIGHT: The diﬀerential
event rate for charged-current absorption of supernova νe on 10 kt of pure 40Ar. The Fermi-Dirac neutrino source
from listing 5 was used as a toy model of the time-integrated supernova νe spectrum.

7.4.2. Energy-dependent total cross sections: mardumpxs

One of the observables predicted by MARLEY that allows the most straightforward comparison to
other theoretical models is the (abundance-weighted) total cross section as a function of neutrino
energy σ(Ev). While a Monte Carlo estimate of this quantity may be computed from generated
events33 using the approach described in section 7.4, σ(Eν) is exactly calculable given only the
neutrino target composition (see section 4.1.6) and the information stored in the reaction input
ﬁle(s) (see section 4.1.4). For the convenience of users, an example C++ program called mardumpxs
(examples/executables/mardumpxs.cc) is provided with MARLEY that produces tables of σ(Eν).
Assuming that the setup marley.sh script has already been sourced (see section 5.3), one may
build mardumpxs by executing the commands
cd $ { MARLEY }/ build
make mardumpxs

The mardumpxs executable takes the name of an output ﬁle followed by the name of a MARLEY job
conﬁguration ﬁle (see section 6) as command-line arguments. For example, the command

mardumpxs xsec_table . txt config . js

will write a table of σ(Eν) values to the output ﬁle xsec table.txt after conﬁguring MARLEY
according to the settings given in config.js. Each line of the output ﬁle will have the format

where KE is the projectile kinetic energy34 in MeV and XSec is the abundance-weighted total reaction
cross section σ(Eν) (see section 4.1.6) in 10−42 cm2 / atom.

KE XSec

33Speciﬁcally, this involves generating events using a uniform neutrino energy spectrum φ(Eν ) and then construct-

ing a histogram of the neutrino energy distribution.

34Since MARLEY treats neutrinos as massless, this is the same as the total energy Eν . Kinetic energy is used by

mardumpxs in anticipation of extensions to MARLEY involving massive projectiles.

61

00.020.040.060.080.10.120.140100200300400500600700Tf(MeV)(cid:10)dσ/dTf(cid:11)ﬂux(10−40cm2/MeV/40Ar)Events0510152025303540455055010203040Te(MeV)dN/dTe(events/MeV/10kt40Ar)EventsBy default, mardumpxs assumes a νe projectile and produces a table of 10,000 cross section
values using a regularly-spaced energy grid between 0 and 100 MeV. This behavior may be altered
using mardumpxs-speciﬁc keys in the job conﬁguration ﬁle, as described in section 6.7.8.

8. Interfacing MARLEY with external tools

While it is hoped that MARLEY’s capabilities as a standalone software package will be beneﬁcial
to the low-energy neutrino physics community, interfacing the generator with external codes has
the potential to greatly extend its usefulness. This is particularly true for neutrino detection exper-
iments, which typically rely on end-to-end simulations of neutrino production, neutrino interactions
in and around the detector, ﬁnal-state particle propagation, and the detector electronics response
in order to interpret their measurements. For some applications, simply passing MARLEY output ﬁles
as input to the next stage of a multi-step simulation may be satisfactory. In other contexts, direct
calls to MARLEY functions by a client code may be more appropriate.

Section 8.1 presents the recommended approach to generating MARLEY events within an external
C++ application, which involves use of the marley::JSONConfig and marley::Generator classes.
An example application of this kind, marg4, is discussed in section 8.2. The marg4 program produces
MARLEY events and tracks the ﬁnal-state particles through a simple geometry using the popular
Geant4 [100, 101] particle transport code. Section 8.3 then brieﬂy discusses the MARLEY interface
included in the LArSoft [171–174] toolkit.

8.1. C++ event generation API

The core functionality of MARLEY is encapsulated for use by external applications in the form
of the marley::Generator class. While a Generator object may be instantiated and conﬁgured
without reference to a ﬁle, doing so is not recommended in most situations.
Instead, users are
encouraged to construct Generator objects indirectly by means of the create generator member
function of the marley::JSONConfig class. The constructor of JSONConfig takes a single string
argument containing the name of a MARLEY job conﬁguration ﬁle. The contents of this ﬁle are
parsed and used to initialize a Generator object during a subsequent call to JSONConfig::create
generator. With the exception of the parameters described in section 6.6 (which are unique to the
marley command-line executable), all conﬁguration options listed in section 6 will be recognized
and respected by the JSONConfig class. Once a fully-initialized Generator object has been created,
a single neutrino scattering event may be simulated and returned as a marley::Event object by
calling the create event member function. A new event will be generated with each call to this
function.

Listing 16 shows the source code for examples/executables/minimal/evgen.cc, an example
C++ program that uses the recommended event generation API. On line 13, a JSONConfig object
called cfg is constructed using settings from the job conﬁguration ﬁle /home/config.js. The
settings parsed by cfg are then used to create a Generator object called gen on line 14. A simple
event loop is deﬁned on lines 16–19 and iterates until ten events have been generated (line 17) and
printed in ASCII format to standard output (line 18). The evgen.cc example program may most
easily be compiled by using the marley-config script as described in section 5.5.1.

1

2

3

4

// Standard library includes
# include < iostream >

// MARLEY includes

62

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

# include " marley / Event . hh "
# include " marley / Generator . hh "
# include " marley / JSONConfig . hh "

constexpr int NUM_EVENTS = 10;

int main () {

marley :: JSONConfig cfg ( " / home / config . js " ) ;
marley :: Generator gen = cfg . create_generator () ;

for ( int j = 0; j < NUM_EVENTS ; ++ j ) {
marley :: Event ev = gen . create_event () ;
std :: cout << ev << ’\ n ’;

}

}

Listing 16: Minimal working example of a C++ program that generates MARLEY events

In cases where handling of ROOT-dependent conﬁguration ﬁle parameters (see, e.g., section 6.5.7)
is desired, the RootJSONConfig class should be used instead of JSONConfig . This amounts to
RootJSONConfig on lines 7 and 13 of listing 16. Assuming
making the replacement JSONConfig
that MARLEY has been built with ROOT support, the compilation command given in section 5.5.1
will automatically link to the required ROOT libraries.

→

8.2. Interfacing MARLEY with Geant4

The C++-based Geant4 software framework provides a large suite of tools for simulating particle
propagation through matter. In the main function of a typical Geant4 application, a G4RunManager
object is constructed and used to drive the simulation. Before the simulation can begin, the
G4RunManager must be initialized with pointers to three objects, each of which is derived from
a distinct abstract base class deﬁned by Geant4. The three required classes used to initialize the
run manager are

G4VUserDetectorConstruction Deﬁnes the geometry and material composition of the world
volume (and zero or more subvolumes) through which the simulated particles will be tracked

G4VUserPhysicsList Deﬁnes the particle species and physics processes to be included in the

simulation

G4VUserPrimaryGeneratorAction Deﬁnes a member function, GeneratePrimaries, which
will be used to populate each new event with the starting locations, momenta, etc. of all
primary particles to be tracked

In addition to these required classes, pointers to objects that instantiate optional user action classes
may also be registered with the run manager. These allow user-deﬁned functions to be executed
at various stages of the simulation. Further details about general Geant4 application development
are available in ref. [175].

63

8.2.1. The marg4 Geant4 application

The folder examples/marg4/ contains the source code for marg4, an example Geant4 application
that uses MARLEY events as a source of primary particles. The world volume is deﬁned by the
DetectorConstruction class and consists of a single uniform sphere of liquid argon with a radius
of 10 m and centered on the origin. A built-in Geant4 physics list suitable for MeV-scale particle
transport, QGSP BIC HP, is constructed using a factory method in examples/marg4/src/marg4.cc.
As a trivial example of a user action, an EventAction object is used to print the current event
count to standard output at the beginning of every hundredth event.

An example of a direct interface between MARLEY and Geant4 is provided by the MarleyPrimary
GeneratorAction class, which is derived from G4VUserPrimaryGeneratorAction. The constructor
of this class takes a single std::string argument containing the name of a MARLEY job conﬁguration
ﬁle. This ﬁle name is used to create either a JSONConfig or a RootJSONConfig object, with the
latter being chosen if the USE ROOT preprocessor macro is deﬁned (see section 5.5). The member
variable marley generator , which is a Generator object, is then initialized using the parameters
from the conﬁguration ﬁle.

Listing 17 shows the GeneratePrimaries member function deﬁned by the MarleyPrimary
GeneratorAction class. This function is called once during initialization of each Geant4 event.
On line 4, a new G4PrimaryVertex object is created at the spacetime origin. All primary particles
which are associated with it will begin their Geant4 trajectories at the same 4-position. After a sin-
gle marley::Event object is created on listing 17, each of its ﬁnal-state particles is converted into a
new G4PrimaryParticle by the loop deﬁned on lines 14–28. Line 27 associates each fully-initialized
G4PrimaryParticle with the primary vertex deﬁned previously, and line 33 adds the completed
primary vertex to the current G4Event object. Propagation of the primary particles obtained from
the MARLEY event is simulated by Geant4 after the GeneratePrimaries function returns.

void M a r l e y P r i m a r y G e n e r a t o r A c t i o n :: Gen eratePrimaries ( G4Event * anEvent )
{

// Create a new primary vertex at the spacetime origin .
G4PrimaryVertex * vertex = new G4PrimaryVertex (0. , 0. , 0. , 0.) ; // x ,y ,z ,

t0

// Generate a new MARLEY event using the owned marley :: Generator object
marley :: Event ev = mar ley_generator_ . create_event () ;

// This line , if uncommented , will print the event in ASCII format
// to standard output
// std :: cout << ev << ’\n ’;

// Loop over each of the final particles in the MARLEY event
for ( const auto & fp : ev . get_final_particles () ) {

// Convert each one from a marley :: Particle into a G4PrimaryParticle .
// Do this by first setting the PDG code and the 4 - momentum components .
G4Primary Particle * particle = new G4PrimaryParticle ( fp - > pdg_code () ,

fp - > px () , fp - > py () , fp - > pz () , fp - > total_energy () ) ;

// Also set the charge of the G4Primary Particle appropriately
particle - > SetCharge ( fp - > charge () ) ;

64

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

// Add the fully - initialized G4P rimaryParticle to the primary vertex
vertex - > SetPrimary ( particle ) ;

}

// The primary vertex has been fully populated with all final - state

particles

// from the MARLEY event . Add it to the G4Event object so that Geant4 can
// begin tracking the particles through the simulated geometry .
anEvent - > AddPrimaryVertex ( vertex ) ;

}
Listing 17: Deﬁnition of the GeneratePrimaries member function of the MarleyPrimaryGeneratorAction class. This
listing is an excerpt from the ﬁle examples/marg4/src/MarleyPrimaryGeneratorAction.cc included with MARLEY.

8.2.2. Building and running marg4

Building the example marg4 program requires the geant4-config utility (included as part of a
standard Geant4 installation) to be present on the system’s executable search path. Additionally,
use of the QGSP BIC HP physics list mentioned above requires installation of the data ﬁles belong-
ing to the Geant4 Neutron Data Library (G4NDL) [176, 177]. These ﬁles, which are available
for download from the Geant4 website (https://geant4.web.cern.ch/support/download), are
required for high-precision (HP) tracking of low-energy neutrons by Geant4. The use of Geant4’s
HP treatment of neutron transport is strongly recommended for propagation of neutrino-induced
neutrons from MARLEY events.

Assuming that the setup marley.sh script has already been sourced (see section 5.3), the marg4

executable may be built against Geant4 via the commands
cd $ { MARLEY }/ build
make marg4

The marg4 executable takes the number of desired events followed by the name of a MARLEY job
conﬁguration ﬁle as its command-line arguments. For example, invoking the program via

marg4 500 / home / myconfig . js

will simulate 500 Geant4 events. Each of these events will contain a single primary vertex populated
with the ﬁnal-state particles from one MARLEY event. The MARLEY events will be generated using
the job conﬁguration given in the ﬁle /home/myconfig.js.

The marg4 program is provided as a simple usage example for the API described in section 8.1.
As such, it does not produce any output other than logging messages from both MARLEY and
Geant4. Interested users are encouraged to copy and modify the marg4 source code to meet their
needs. Information from the marley::Event objects themselves may be accessed using the member
functions described in section 7.3.2. The functions needed to extract quantities of interest from the
Geant4 simulation are documented in ref. [175].

8.3. LArSoft interface

The liquid argon software toolkit (LArSoft) provides a ﬂexible simulation, reconstruction, and
analysis framework designed for liquid argon time projection chamber (LArTPC) experiments.

65

Based on the art event-processing framework [178], LArSoft has been adopted as a key part of the
software infrastructure for various experimental collaborations, including ArgoNeuT [179], LArIAT
[180], MicroBooNE [181], ICARUS [182], SBND [183], and DUNE [184].

The LArSoft source code is hosted on GitHub and split into multiple respositories, each of
which provides a particular type of functionality. The larsim respository (https://github.com/
LArSoft/larsim) includes, among other things, interfaces to external physics event generators
for neutrino interactions (e.g., GENIE) and for other processes (e.g., the cosmic-ray generators
CORSIKA [185] and CRY [186]).

Version 6.04.00 of LArSoft was the ﬁrst35 to include a direct larsim interface to MARLEY con-
tributed by the present author.36 Ever since the initial version of the interface was added, MARLEY
has been included as part of the standard LArSoft distribution. A detailed description of the LAr-
Soft interface to MARLEY, which is more sophisticated than the examples given in section 8.1 and
section 8.2, is beyond the present scope. However, brief descriptions of the relevant C++ classes de-
ﬁned in the larsim source code (see the larsim/EventGenerator/MARLEY/ subfolder of the larsim
repository) are given below. All four of these classes are deﬁned within the evgen namespace used
by LArSoft for event generation.

ActiveVolumeVertexSampler Used to sample neutrino vertex positions uniformly over the ac-
tive volume(s) of a detector. The approach used by this class is only suitable for simulations in
which (1) the detector is uniformly illuminated by the incident neutrino ﬂux, and (2) neutrino
interactions occurring outside the detector active volume(s) are not of interest.

MarleyGen Creates neutrino scattering events in the native LArSoft format using the Active

VolumeVertexSampler and MARLEYHelper classes

MARLEYHelper Implements the low-level interface between MARLEY and LArSoft. At the be-
ginning of a simulation job, this class initializes a marley::Generator object by converting
a LArSoft conﬁguration given in the Fermilab Hierarchical Conﬁguration Language (FHiCL)
[188] to the JSON-like format (see section 6) used by MARLEY. With the exception of the “ex-
ecutable settings” described in section 6.6, all MARLEY job conﬁguration ﬁle parameters are
available for use via FHiCL.

This class also provides a member function (create MCTruth) which generates a MARLEY
event and stores a representation of it in an instance of the simb::MCTruth class. The simb
::MCTruth class is used by LArSoft as a generator-agnostic event record.

MarleyTimeGen Similar to MarleyGen, but provides experimental support for generating events

using a time-dependent neutrino spectrum

Further technical details about these and other LArSoft classes are available in the LArSoft

Doxygen documentation (https://nusoft.fnal.gov/larsoft/doxsvn/html/index.html).

35Ref. [187] incorrectly identiﬁes the initial LArSoft version as 6.03.00. This number refers instead to the corre-

sponding version of the larsim subpackage.

36The ﬁrst MARLEY version to be included in LArSoft was 0.9.5, an August 2016 public beta release.

66

9. Prospects for future development

This work describes a new Monte Carlo event generator, MARLEY, suitable for simulating tens-
of-MeV neutrino scattering on complex nuclei. The release of MARLEY 1.2.0, the ﬁrst version of the
code to be documented with the present level of detail, represents a signiﬁcant milestone. However,
active, open-source development of MARLEY is ongoing, and contributions from the community are
encouraged. To coordinate development eﬀorts, those interested in contributing improvements to
MARLEY are asked to contact the author at the earliest opportunity.

Potential avenues for future development of MARLEY include the following:

• Preparation of additional reaction input ﬁles. In addition to new scattering modes (inelastic
NC and ¯νe CC) for 40Ar, the addition of input ﬁles for several other nuclides will likely be of
immediate interest. These include but are not limited to

1. 12C and 16O, both of which make small but non-negligible contributions to the total event
rate in hydrocarbon (e.g., NOvA [189]) and water Cherenkov (e.g., Super-Kamiokande
[190]) supernova neutrino detectors

2. The stable lead isotopes (especially 208Pb), which serve as the target material for the

HALO [47, 48] detector

3. The stable iron and copper isotopes (especially 56Fe and 63Cu), which, together with
lead, are under study by the COHERENT [35] experiment in an eﬀort to understand
low-energy neutrino-induced neutron production

• Inclusion of forbidden transitions in the MARLEY neutrino-nucleus cross section model. These
are currently neglected via the allowed approximation. Recent theoretical calculations using
a Continuum Random Phase Approximation (CRPA) approach [191, 192] indicate that the
forbidden contributions can have a signiﬁcant impact on both the total cross section and the
kinematic distributions of the outgoing lepton.

• Addition of new keys to the job conﬁguration ﬁle format to allow variations of model parame-
ters, e.g., those used by the nuclear optical model. With some related enhancements to other
parts of the code, e.g., storage of the full de-excitation history in the MARLEY event record,
these variations could be used to assess theoretical uncertainties on MARLEY predictions via
event reweighting. An approach of this kind is commonly used by accelerator neutrino exper-
iments. Documentation of the GENIE event reweighting framework, for example, is given in
ref. [170, ch. 9, pp. 129–154].

• Improvements to the MARLEY treatment of nuclear de-excitations. These could include

– Realistic angular distributions for the de-excitation products (instead of the isotropic

emission that is currently assumed)

– Storage of particle emission times in the event record. Related updates could also be
made to the nuclear structure data format to allow measured discrete level lifetimes to
be listed.

– Competition of internal conversion with γ-ray emission
– Pre-equilibrium emission of nuclear fragments
– Modeling of neutrino-induced ﬁssion

67

• Creation of new subclasses of marley::Reaction to simulate events for projectiles other than
neutrinos. Processes likely to be of interest include electron-nucleus scattering and beyond
the Standard Model reactions like nuclear absorption of MeV-scale dark matter [193].

• Implementation of a tool to facilitate comparisons of MARLEY model predictions with cross
section measurements from low-energy neutrino experiments. This could potentially be ac-
complished by adding low-energy datasets and a MARLEY interface to the NUISANCE [194]
framework used by the accelerator neutrino community.

• Simulation of events within a detector geometry in which both the target material and the
incident neutrino ﬂux are spatially non-uniform. This may most easily be achieved by inter-
facing MARLEY with ﬂux and geometry navigation drivers present in an existing generator (see
ref. [170, sec. 6] for a description of GENIE’s). A “community based” version of these tools,
independent of any particular generator, has also been proposed [195].

10. Acknowledgements

I am grateful to Myung-Ki Cheoun for providing the QRPA Gamow-Teller matrix elements which
∗
are used to compute 40Ar(νe, e−)40K
cross sections at high excitation energies (see section 6.4.1
and ref. [108]). I also thank the authors of the TALYS code for sharing their nuclear level data ﬁles
under the GNU General Public License.

Vishvas Pandey provided helpful feedback on a draft of this paper, and I thank Robert Svoboda,
Ramona Vogt, and Michael Mulhearn for their comments on the PhD thesis [187] which served as
the ﬁrst formal description of MARLEY. I am also indebted to Sam Hedges and Erin Conley for their
tests of the MARLEY 1.2.0 release candidate.

My work to develop MARLEY while at the University of California, Davis was supported in part
by the John Jungerman-Charles Soderquist Graduate Fellowship and by the DOE National Nuclear
Security Administration through the Nuclear Science and Security Consortium under award number
DE-NA0003180.

This manuscript has been authored by Fermi Research Alliance, LLC under Contract No. DE-
AC02-07CH11359 with the U.S. Department of Energy, Oﬃce of Science, Oﬃce of High Energy
Physics.

A. Nuclear structure data ﬁle format

The MARLEY nuclear structure data ﬁles mentioned in section 4.1.5 contain tables of nuclear
energy levels and γ-ray branching ratios for one or more nuclides. Each table follows a whitespace-
delimited format that begins with the header

Z A num_levels

in which Z is the proton number, A is the mass number, and num_levels is the number of tabulated
nuclear levels. The header is followed by data blocks for each level in order of increasing excitation
energy. Each block begins with the line

Ex twoJ Pi num_gammas

68

where Ex is the level excitation energy (MeV), twoJ is two times the level spin (the factor of two
allows half-integer spins to be represented by an integer), and Pi is the parity (denoted by the
character + or -). The data block for a level terminates with a set of lines describing each available
γ-ray transition (for a total of num_gammas transitions). Each of these lines has the format

E_gamma RI Lf_index

where E_gamma is the energy of the emitted γ-ray (MeV) and RI is the relative intensity of the
transition. Although the relative intensities in the oﬃcial MARLEY structure data ﬁles are normalized
to sum to unity, this is not required. The parameter Lf_index gives the position of the ﬁnal
nuclear level accessed by the transition, with Lf_index = 0 corresponding to the ﬁrst listed level
(presumably the ground state).

1

2

3

4

5

6

7

8

9

10

17 43 5

0 1 + 0
0.329 3 + 1
0.329 1 0
0.944 5 + 1
0.615 1 1

1.34 5 + 1
1.34 1 0
1.829 7 + 1
0.885 1 2

Listing 18: Example MARLEY nuclear structure data ﬁle

Listing 18 shows the table for 43Cl which appears in the structure data ﬁle data/structure/
Cl.dat included with MARLEY. Five nuclear levels appear in the table, each (apart from the ground
state) having one listed γ-ray transition. Although the lines giving the nuclide header, level de-
scriptions, and γ-ray descriptions are shown here with diﬀerent indentations to improve readability,
this is not required by the ﬁle format.

B. Reaction input ﬁle format

The reaction input ﬁles mentioned in section 6.4 provide information needed for MARLEY to
conﬁgure cross section calculations according to eq. (5) (for neutrino-nucleus scattering) or eq. (55)
(for neutrino-electron elastic scattering). Any line of a reaction input ﬁle that begins with a #
character will be treated as a comment and ignored by the parser. The ﬁrst line of the ﬁle that is
not a comment contains a header of the form

ProcessType NucPDG

where ProcessType is an integer code representing the reaction mode and NucPDG is a nuclear PDG
code (see section 7.1) identifying the target nuclide involved in the initial state. Table B.6 lists the
allowed values of ProcessType in the second column together with their corresponding reaction
modes and isospin operators. In the ﬁrst column, the symbol A is used as a stand-in for any target
nucleus. The third column lists the elements of the enumerated type used in the source code to
represent each reaction mode.

For reaction input ﬁles describing neutrino-electron elastic scattering (ProcessType = 3), only
the header shown above is required to be present. If the user wishes to enable simulation of this

69

Reaction mode
A(ν, (cid:96)−)
A(¯ν, (cid:96)+)
A(ν, ν) or A(¯ν, ¯ν)
e−(ν, ν) or e−(¯ν, ¯ν)

ProcessType integer

ProcessType enum Isospin operator

0
1
2
3

NeutrinoCC
AntiNeutrinoCC
NC
NuElectronElastic

t−
t+
t3 or 1
none

Table B.6: Reaction mode labeling scheme used in MARLEY 1.2.0. The integer labels used in reaction input ﬁles are
represented in the source code by the marley::Reaction::ProcessType enumerated type.

process for multiple atomic targets, additional values of NucPDG may be included on subsequent
lines. Listing 19 shows an example reaction input ﬁle which instructs MARLEY to simulate neutrino-
electron elastic scattering for the three stable isotopes of argon: 36Ar, 38Ar, and 40Ar.

1

2

3

3 1000180360
1000180380
1000180400

Listing 19: Example MARLEY reaction input ﬁle for neutrino-electron elastic scattering

For neutrino-nucleus reaction modes, each line of the input ﬁle following the header is used to
specify the value of a reduced matrix element describing a transition to a particular ﬁnal nuclear
level. These lines are whitespace-delimited and have the format

Ex B type

where Ex is the excitation energy of the ﬁnal level (MeV, measured with respect to the ground
state of the residual nucleus), B is the corresponding value of either B(F) or B(GT), and type is
an integer code that represents whether B should be interpreted as a value of B(F) (type = 0) or
of B(GT) (type = 1). The matrix elements must be listed in order of increasing Ex in the reaction
input ﬁle. If this is not the case, then MARLEY will halt with the error message

[ ERROR ]: Invalid reaction dataset . Level energies must be unique and must

be given in ascending order .

when the ﬁle is used.

In most cases, the matrix element values given in the reaction input ﬁle should be computed
using the full expressions shown in eq. (6) and eq. (7). This includes, e.g., any assumed value of
the axial-vector coupling constant gA. The sole exception is the Fermi matrix element for neutral-
current scattering, which should be listed with a factor of Q2
W /4 removed. For an NC transition to
the ground state of a spin-zero nucleus, B(F ) = g2

V Q2
Listing 20 shows an excerpt from the reaction input ﬁle data/react/ve40ArCC Bhattacharya
1998.react, which tabulates nuclear matrix elements for CC neutrino-argon scattering. Two
B(GT) values (0.90 and 1.50) are given, both for ﬁnal states between 2 and 3 MeV above the
40K ground state.

W /4, but B = g2

V = 1.

1

2

3

0 1000180400
2.289868 0.90 1
2.730357 1.50 1

Listing 20: Example MARLEY reaction matrix element data ﬁle

70

References

[1] M. Galassi, B. Gough, GNU Scientiﬁc Library: Reference Manual, Network Theory, 2009.

[2] GSL - GNU Scientiﬁc Library, https://www.gnu.org/software/gsl/, 2019. Last accessed

on 27 January 2021.

[3] R. Brun, F. Rademakers, ROOT — An object oriented data analysis framework, Nucl.
Instrum. Methods Phys. Res. A 389 (1997) 81–86. doi:10.1016/S0168-9002(97)00048-X.

[4] ROOT Data Analysis Framework, https://root.cern.ch, 2021. Last accessed on 27 January

2021.

[5] T. Sj¨ostrand, S. Ask, J. R. Christiansen, R. Corke, N. Desai, P. Ilten, S. Mrenna, S. Prestel,
C. O. Rasmussen, P. Z. Skands, An introduction to PYTHIA 8.2, Comput. Phys. Commun.
191 (2015) 159–177. doi:10.1016/j.cpc.2015.01.024. arXiv:1410.3012.

[6] J. Bellm, S. Gieseke, D. Grellscheid, S. Pl¨atzer, M. Rauch, C. Reuschle, P. Richardson,
P. Schichtel, M. H. Seymour, A. Si´odmok, A. Wilcock, et al., Herwig 7.0/Herwig++
3.0 release note, Eur. Phys. J. C 76 (2016) 196. doi:10.1140/epjc/s10052-016-4018-8.
arXiv:1512.01178.

[7] I. Lokhtin, L. Malinina, S. Petrushanko, A. Snigirev, I. Arsene, K. Tywoniuk, Heavy ion
event generator HYDJET++ (HYDrodynamics plus JETs), Comput. Phys. Commun. 180
(2009) 779–799. doi:10.1016/j.cpc.2008.11.015. arXiv:0809.2708.

[8] J. Verbeke, J. Randrup, R. Vogt, Fission Reaction Event Yield Algorithm, FREYA — For
event-by-event simulation of ﬁssion, Comput. Phys. Commun. 191 (2015) 178–202. doi:10.
1016/j.cpc.2015.02.002.

[9] O. A. Ponkratenko, V. I. Tretyak, Y. G. Zdesenko, Event generator DECAY4 for simulating
double-beta processes and decays of radioactive nuclei, Phys. At. Nucl. 63 (2000) 1282–1287.
doi:10.1134/1.855784. arXiv:nucl-ex/0104018.

[10] S. Nagamiya, Introduction to J-PARC, Prog. Theor. Exp. Phys. 2012 (2012). doi:10.1093/

ptep/pts025, 02B001.

[11] A. Fava, J. L. Raaf, P. Shanahan, L. Suter, Z. Pavlovic, J. Zennamo, R. Zwaska, Sta-
tus of Fermilab’s Neutrino Facilities, 2018. URL: https://indico.cern.ch/event/765096/
contributions/3296027/, input submitted to the European Particle Physics Strategy Up-
date 2018–2020.

[12] C. Andreopoulos, et al., The GENIE Neutrino Monte Carlo Generator, Nucl. Instrum.
Methods A614 (2010) 87–104. doi:10.1016/j.nima.2009.12.009. arXiv:0905.2517.

[13] O. Buss, T. Gaitanos, K. Gallmeister, et al., Transport-theoretical description of nuclear

reactions, Phys. Rep. 512 (2012) 1–124. doi:10.1016/j.physrep.2011.12.001.

[14] Y. Hayato, A neutrino interaction simulation program library NEUT, Acta Phys. Pol. B
40 (2009) 2477–2489. URL: http://www.actaphys.uj.edu.pl/fulltext?series=Reg&vol=
40&page=2477.

71

[15] T. Golan, J. Sobczyk, J. ˙Zmuda, NuWro: the Wroc(cid:32)law Monte Carlo generator of neutrino
interactions, Nucl. Phys. B - Proc. Suppl. 229-232 (2012) 499. doi:10.1016/j.nuclphysbps.
2012.09.136.

[16] T. Katori, Meson exchange current (MEC) models in neutrino interaction generators, AIP

Conf. Proc. 1663 (2015) 030001. doi:10.1063/1.4919465. arXiv:1304.6014.

[17] A. Bodek, J. L. Ritchie, Fermi-motion eﬀects in deep-inelastic lepton scattering from nuclear

targets, Phys. Rev. D 23 (1981) 1070–1091. doi:10.1103/PhysRevD.23.1070.

[18] O. Benhar, A. Fabrocini, S. Fantoni, The nucleon spectral function in nuclear matter, Nucl.

Phys. A 505 (1989) 267–299. doi:10.1016/0375-9474(89)90374-6.

[19] O. Benhar, A. Fabrocini, S. Fantoni, I. Sick, Spectral function of ﬁnite nuclei and scattering
of GeV electrons, Nucl. Phys. A 579 (1994) 493–517. doi:10.1016/0375-9474(94)90920-2.

[20] G. B. King, K. Mahn, L. Pickering, N. Rocco, Comparing event generator predictions and
ab initio calculations of ν-12C neutral-current quasielastic scattering at 1 GeV, Phys. Rev. C
101 (2020) 065502. doi:10.1103/PhysRevC.101.065502. arXiv:2002.02626.

[21] S. Dytman, Final state interactions in neutrino-nucleus experiments, Acta Phys. Polon. B 40

(2009) 2445–2460. URL: https://www.actaphys.uj.edu.pl/R/40/9/2445/pdf.

[22] W. Y. Ma, E. S. P. Guerra, M. Yu, A. Fiorentini, T. Feusels, Current status of ﬁnal-state
interaction models and their impact on neutrino-nucleus interactions, J. Phys.: Conf. Ser.
888 (2017) 012171. doi:10.1088/1742-6596/888/1/012171.

[23] T. Golan, C. Juszczak, J. T. Sobczyk, Eﬀects of ﬁnal-state interactions in neutrino-
nucleus interactions, Phys. Rev. C 86 (2012) 015505. doi:10.1103/PhysRevC.86.015505.
arXiv:1202.4197.

[24] https://gibuu.hepforge.org/trac/wiki/Paper, 2020. Last accessed on 27 January 2021.

[25] U. Mosel, Neutrino event generators: foundation, status and future, J. Phys. G: Nucl. Part.

Phys. 46 (2019) 113001. doi:10.1088/1361-6471/ab3830. arXiv:1904.11506.

[26] A. Aurisano, C. Backhouse, R. Hatcher, N. Mayer, J. Musser, R. Patterson, R. Schroeter,
A. Sousa, The NOvA simulation chain, J. Phys.: Conf. Ser. 664 (2015) 072002. doi:10.1088/
1742-6596/664/7/072002.

[27] G. G. Raﬀelt,

Nucl.
Phys. B Proc. Suppl. 221 (2011) 218–229. doi:10.1016/j.nuclphysbps.2011.09.006.
arXiv:astro-ph/0701677.

Supernova neutrino observations: What can we learn?,

[28] K. Scholberg, Supernova neutrino detection, Annu. Rev. Nucl. Part. Sci. 62 (2012) 81–103.

doi:10.1146/annurev-nucl-102711-095006. arXiv:1205.6003.

[29] S. Horiuchi, J. P. Kneller, What can be learned from a future supernova neutrino detec-
tion?, J. Phys. G: Nucl. Part. Phys. 45 (2018) 043002. doi:10.1088/1361-6471/aaa90a.
arXiv:1709.01515.

72

[30] F. Capozzi, S. W. Li, G. Zhu, J. F. Beacom, DUNE as the next-generation solar neutrino
experiment, Phys. Rev. Lett. 123 (2019) 131803. doi:10.1103/PhysRevLett.123.131803.
arXiv:1808.08232.

[31] P. Bakhti, M. Rajaee, Sensitivities of future solar neutrino observatories to nonstandard
neutrino interactions, Phys. Rev. D 102 (2020) 035024. doi:10.1103/PhysRevD.102.035024.
arXiv:2003.12984.

[32] R. Harnik, K. J. Kelly, P. A. N. Machado, Prospects of measuring oscillated decay-at-rest
neutrinos at long baselines, Phys. Rev. D 101 (2020) 033008. doi:10.1103/PhysRevD.101.
033008. arXiv:1911.05088.

[33] F. Suekane,

Hunt

for Sterile Neutrinos:

Decay at Rest Experiments

(2016).

arXiv:1604.06190.

[34] C. Rott, Status of JSNS2 - J-PARC Sterile Neutrino Search at J-PARC Spallation Neutron

Source, J. Phys.: Conf. Ser. 1468 (2020) 012176. doi:10.1088/1742-6596/1468/1/012176.

[35] D. Akimov, J. B. Albert, et al. (COHERENT Collaboration), COHERENT 2018 at the

Spallation Neutron Source (2018). arXiv:1803.09183.

[36] C. Grant, B. Littlejohn, Opportunities with decay-at-rest neutrinos from decay-in-ﬂight neu-

trino beams (2015). arXiv:1510.08431.

[37] J. F. Beacom, W. M. Farr, P. Vogel, Detection of supernova neutrinos by neutrino-
proton elastic scattering, Phys. Rev. D 66 (2002) 033001. doi:10.1103/PhysRevD.66.033001.
arXiv:hep-ph/0205220.

[38] D. Z. Freedman, Coherent eﬀects of a weak neutral current, Phys. Rev. D 9 (1974) 1389–1392.

doi:10.1103/PhysRevD.9.1389.

[39] D. Akimov, J. B. Albert, P. An, et al. (COHERENT Collaboration), Observation of coherent
elastic neutrino-nucleus scattering, Science 357 (2017) 1123–1126. doi:10.1126/science.
aao0990. arXiv:1708.01294.

[40] D. Akimov, J. B. Albert, P. An, C. Awe, P. S. Barbeau, B. Becker, V. Belov, I. Bernardi,
M. A. Blackston, L. Blokland, et al. (COHERENT Collaboration), First measurement of
coherent elastic neutrino-nucleus scattering on argon, Phys. Rev. Lett. 126 (2021) 012002.
doi:10.1103/PhysRevLett.126.012002. arXiv:2003.10630.

[41] A. M. Ankowski,

Improved estimate of the cross section for inverse beta decay (2016).

arXiv:1601.06169.

[42] A. Strumia, F. Vissani, Precise quasielastic neutrino/nucleon cross-section, Phys. Lett. B 564

(2003) 42–54. doi:10.1016/S0370-2693(03)00616-6. arXiv:astro-ph/0302055.

[43] M. Roda, GENIE v3.02.00, GENIE docDB #215, 2020. Talk given at the October 2020

GENIE User Forum.

[44] B. Abi, R. Acciarri, et al. (DUNE Collaboration), Deep Underground Neutrino Experi-
ment (DUNE), Far Detector Technical Design Report, Volume II: DUNE Physics (2020).
arXiv:2002.03005.

73

[45] B. Abi, R. Acciarri, M. Acero, G. Adamov, D. Adams, M. Adinolﬁ, Z. Ahmad, J. Ahmed,
T. Alion, S. A. Monsalve, et al. (DUNE Collaboration), Supernova neutrino burst detection
with the Deep Underground Neutrino Experiment (2020). arXiv:2008.06647.

[46] A. Ankowski, J. Beacom, O. Benhar, S. Chen, et al., Supernova physics at DUNE (2016).

arXiv:1608.07853.

[47] C. A. Duba, F. Duncan, J. Farine, et al., HALO – the helium and lead observatory for
supernova neutrinos, J. Phys. Conf. Ser. 136 (2008) 042077. doi:10.1088/1742-6596/136/
4/042077.

[48] K. Zuber, HALO, a supernova neutrino observatory, Nucl. Part. Phys. Proc. 265-266 (2015)

233–235. doi:10.1016/j.nuclphysbps.2015.06.059.

[49] Helium and Lead Observatory: Astronomically patient, https://www.snolab.ca/halo,

2012. Last accessed on 27 January 2021.

[50] R. Davis, D. S. Harmer, K. C. Hoﬀman, Search for neutrinos from the sun, Phys. Rev. Lett.

20 (1968) 1205–1209. doi:10.1103/PhysRevLett.20.1205.

[51] T. Suzuki, A. B. Balantekin, T. Kajino, S. Chiba, Neutrino-13C cross sections at supernova
neutrino energies, J. Phys. G: Nucl. Part. Phys. 46 (2019) 075103. doi:10.1088/1361-6471/
ab1c11. arXiv:1904.11291.

[52] A. R. Samana, F. Krmpoti´c, N. Paar, C. A. Bertulani, Neutrino and antineutrino charge-
exchange reactions on 12C, Phys. Rev. C 83 (2011) 024303. doi:10.1103/PhysRevC.83.
024303. arXiv:1005.2134.

[53] T. Suzuki, S. Chiba, T. Yoshida, T. Kajino, T. Otsuka, Neutrino-nucleus reactions based on
new shell model Hamiltonians, Phys. Rev. C 74 (2006) 034307. doi:10.1103/PhysRevC.74.
034307. arXiv:nucl-th/0608056.

[54] A. C. Hayes, I. S. Towner, Shell-model calculations of neutrino scattering from 12C, Phys.
Rev. C 61 (2000) 044603. doi:10.1103/PhysRevC.61.044603. arXiv:nucl-th/9907049.

[55] C. Volpe, N. Auerbach, G. Col`o, T. Suzuki, N. Van Giai, Microscopic theories of
neutrino-12C reactions, Phys. Rev. C 62 (2000) 015501. doi:10.1103/PhysRevC.62.015501.
arXiv:nucl-th/0001050.

[56] E. Kolbe, K. Langanke, P. Vogel, Weak reactions on 12C within the continuum random phase
approximation with partial occupancies, Nucl. Phys. A 652 (1999) 91–100. doi:10.1016/
S0375-9474(99)00152-9. arXiv:nucl-th/9903022.

[57] M. S. Reen, M. Sakuda, T. Sudo, A. Tamii, K. Nakazato, T. Suzuki, H. Suzuki, Estimation
of γ-ray production from neutral-current neutrino-carbon and -oxygen inelastic reactions in-
duced by supernova neutrinos, JPS Conf. Proc. 31 (2020) 011014. doi:10.7566/JPSCP.31.
011014.

[58] K. Nakazato, T. Suzuki, M. Sakuda, Charged-current scattering oﬀ the 16O nucleus as a
detection channel for supernova neutrinos, Prog. Theor. Exp. Phys. 2018 (2018) 123E02.
doi:10.1093/ptep/pty134. arXiv:1809.08398.

74

[59] T. Suzuki, S. Chiba, T. Yoshida, K. Takahashi, H. Umeda, Neutrino-nucleus reactions on
16O based on new shell-model Hamiltonians, Phys. Rev. C 98 (2018) 034613. doi:10.1103/
PhysRevC.98.034613. arXiv:1807.02367.

[60] K. Langanke, P. Vogel, E. Kolbe,

Signal for supernova νµ and ντ neutrinos in water
ˇCerenkov detectors, Phys. Rev. Lett. 76 (1996) 2629. doi:10.1103/physrevlett.76.2629.
arXiv:nucl-th/9511032.

[61] E. Kolbe, K. Langanke, S. Krewald, F.-K. Thielemann, Inelastic neutrino scattering on nuclei
and neutrino-nucleosynthesis, Phys. Rep. 227 (1993) 37–46. doi:10.1016/0370-1573(93)
90055-I.

[62] E. Ydrefors, J. Suhonen, Charged-current neutrino-nucleus scattering oﬀ 95,97Mo, Phys. Rev.

C 87 (2013) 034314. doi:10.1103/PhysRevC.87.034314.

[63] E. Ydrefors, J. Suhonen, Charged-current neutrino-nucleus scattering oﬀ the even molybde-
num isotopes, Adv. High Energy Phys. 2012 (2012) 373946. doi:10.1155/2012/373946.

[64] E. Ydrefors, K. Balasi, T. Kosmas, J. Suhonen, Detailed study of the neutral-current
neutrino–nucleus scattering oﬀ the stable Mo isotopes, Nucl. Phys. A 896 (2012) 1–23.
doi:10.1016/j.nuclphysa.2012.10.001.

[65] K. Balasi, E. Ydrefors, T. Kosmas, Theoretical study of neutrino scattering oﬀ the stable
even Mo isotopes at low and intermediate energies, Nucl. Phys. A 868-869 (2011) 82–98.
doi:10.1016/j.nuclphysa.2011.08.003.

[66] H. Ejiri, J. Engel, N. Kudomi, Supernova-neutrino studies with 100Mo, Phys. Lett. B 530

(2002) 27–32. doi:10.1016/S0370-2693(02)01349-7. arXiv:astro-ph/0112379.

[67] H. Ejiri, J. Engel, R. Hazama, P. Krastev, N. Kudomi, R. G. H. Robertson, Spectroscopy
of double-beta and inverse-beta decays from 100Mo for neutrinos, Phys. Rev. Lett. 85 (2000)
2917–2920. doi:10.1103/PhysRevLett.85.2917. arXiv:nucl-ex/9911008.

[68] S. Haselschwardt, B. Lenardo, P. Pirinen, J. Suhonen, Solar neutrino detection in liquid
xenon detectors via charged-current scattering to excited states, Phys. Rev. D 102 (2020)
072009. doi:10.1103/PhysRevD.102.072009. arXiv:2009.00535.

[69] P. Pirinen, J. Suhonen, E. Ydrefors, Charged-current neutrino-nucleus scattering oﬀ Xe

isotopes, Phys. Rev. C 99 (2019) 014320. doi:10.1103/PhysRevC.99.014320.

[70] P. C. Divari, Cross sections of charged current neutrino scattering oﬀ 132Xe for the supernova

detection, Adv. High Energy Phys. 2013 (2013) 143184. doi:10.1155/2013/143184.

[71] N. Shul’gina, B. Danilin, Charged- and neutral-current disintegration of the 6Li nucleus by
solar neutrino and reactor antineutrino, Nucl. Phys. A 554 (1993) 137–157. doi:10.1016/
0375-9474(93)90362-2.

[72] R. S. Raghavan, New prospects for real-time spectroscopy of low energy electron neutrinos

from the sun, Phys. Rev. Lett. 78 (1997) 3618–3621. doi:10.1103/PhysRevLett.78.3618.

75

[73] W. Almosly, B. G. Carlsson, J. Dobaczewski, J. Suhonen, J. Toivanen, P. Vesely, E. Ydrefors,
Charged-current neutrino and antineutrino scattering oﬀ 116Cd described by Skyrme forces,
Phys. Rev. C 89 (2014) 024308. doi:10.1103/PhysRevC.89.024308.

[74] W. Almosly, E. Ydrefors, J. Suhonen, Neutrino scattering oﬀ the stable cadmium isotopes:
neutral-current processes, J. Phys. G: Nucl. Part. Phys. 42 (2014) 025106. doi:10.1088/
0954-3899/42/2/025106.

[75] H. Ejiri, S. R. Elliott, Charged current neutrino cross section for solar neutrinos, and back-
ground to ββ(0ν) experiments, Phys. Rev. C 89 (2014) 055501. doi:10.1103/PhysRevC.89.
055501. arXiv:1309.7957.

[76] P. C. Divari, Supernova neutrino scattering oﬀ gadolinium even isotopes in water Cherenkov
detectors, J. Cosmol. Astropart. Phys. 2018 (2018) 029–029. doi:10.1088/1475-7516/2018/
09/029. arXiv:1808.01677.

[77] P. C. Divari, Supernova neutrino scattering oﬀ gadolinium odd isotopes in water Cherenkov
detectors, J. Cosmol. Astropart. Phys. 2020 (2020) 008–008. doi:10.1088/1475-7516/2020/
07/008. arXiv:2004.12189.

[78] A. Vyborov, L. Inzhechik, G. Koroteev, Y. S. Lutostansky, V. Tikhonov, A. Fazliakhmetov,
Cross sections for solar-neutrino capture by the 76Ge nucleus and high-lying Gamow—Teller
resonances, Phys. At. Nucl. 82 (2019) 477–482. doi:10.1134/S1063778819050132.

[79] M. Harakeh, A. Woude, Giant Resonances: Fundamental High-frequency Modes of Nu-
clear Excitation, Oxford science publications, Oxford University Press, 2001. URL: https:
//books.google.com/books?id=ux0JhIdbGT8C.

[80] K. Goeke, J. Speth, Theory of giant resonances, Annu. Rev. Nucl. Part. Sci. 32 (1982) 65–115.

doi:10.1146/annurev.ns.32.120182.000433.

[81] V. Pandey, N. Jachowicz, M. Martini, R. Gonz´alez-Jim´enez, J. Ryckebusch, T. Van Cuyck,
N. Van Dessel, Impact of low-energy nuclear excitations on neutrino-nucleus scattering at
MiniBooNE and T2K kinematics, Phys. Rev. C 94 (2016) 054609. doi:10.1103/PhysRevC.
94.054609. arXiv:1607.01216.

[82] V. Pandey, N. Jachowicz, T. Van Cuyck, J. Ryckebusch, M. Martini, Low-energy ex-
citations and quasielastic contribution to electron-nucleus and neutrino-nucleus scatter-
ing in the continuum random-phase approximation, Phys. Rev. C 92 (2015) 024606.
doi:10.1103/PhysRevC.92.024606. arXiv:1412.4624.

[83] K. Balasi, K. Langanke, G. Mart´ınez-Pinedo, Neutrino–nucleus reactions and their role for
supernova dynamics and nucleosynthesis, Prog. Part. Nucl. Phys. 85 (2015) 33–81. doi:10.
1016/j.ppnp.2015.08.001. arXiv:1503.08095v1.

[84] E. Kolbe, K. Langanke, S. Krewald, F.-K. Thielemann,

Inelastic neutrino scattering on
12C and 16O above the particle emission threshold, Nucl. Phys. A 540 (1992) 599–620.
doi:10.1016/0375-9474(92)90175-j.

76

[85] E. Kolbe, T. S. Kosmas, Recent highlights on neutrino-nucleus interactions, in: Symmetries
in intermediate and high energy physics, Springer, Berlin, Heidelberg, 2000, pp. 199–225.
doi:10.1007/BFb0109652.

[86] E. Kolbe, K. Langanke,

trino detectors,
arXiv:nucl-th/0003060.

Role of ν-induced reactions on lead and iron in neu-
Phys. Rev. C 63 (2001) 025802. doi:10.1103/PhysRevC.63.025802.

[87] E. Kolbe, Semileptonic weak interactions in nuclei within continuum RPA, Nucl. Phys. A

719 (2003) C135–C143. doi:10.1016/s0375-9474(03)00983-7.

[88] M.-K. Cheoun, E. Ha, T. Hayakawa, S. Chiba, K. Nakamura, T. Kajino, G. J. Mathews,
Neutrino induced reactions for ν-process nucleosynthesis of 92Nb and 98Tc, Phys. Rev. C 85
(2012) 065807. doi:10.1103/physrevc.85.065807. arXiv:1108.4229.

[89] A. Bandyopadhyay, P. Bhattacharjee, S. Chakraborty, K. Kar, S. Saha, Detecting super-
nova neutrinos with iron and lead detectors, Phys. Rev. D 95 (2017) 065022. doi:10.1103/
PhysRevD.95.065022. arXiv:1607.05591.

[90] D. Vale, T. Rauscher, N. Paar, Hybrid method to resolve the neutrino mass hierarchy by
supernova (anti)neutrino induced reactions, J. Cosmol. Astropart. Phys. 2016 (2016) 007.
doi:10.1088/1475-7516/2016/02/007. arXiv:1509.07342.

[91] J. Bondorf, A. Botvina, A. Iljinov, I. Mishustin, K. Sneppen, Statistical multifragmentation

of nuclei, Phys. Rep. 257 (1995) 133–221. doi:10.1016/0370-1573(94)00097-M.

[92] T. Gaitanos, H. Lenske, U. Mosel, Fragment formation in proton induced reactions within a
BUU transport model, Phys. Lett. B 663 (2008) 197–201. doi:10.1016/j.physletb.2008.
04.011. arXiv:0712.3292.

[93] T. Gaitanos, H. Lenske, U. Mosel, Formation of hypernuclei in high energy reactions within
a covariant transport model, Phys. Lett. B 675 (2009) 297–304. doi:10.1016/j.physletb.
2009.04.038. arXiv:0904.2106.

[94] T. Gaitanos, H. Lenske, U. Mosel, Production of fragments with and without strangeness
within a combined BUU + SMM approach, Prog. Part. Nucl. Phys. 62 (2009) 439–444.
doi:10.1016/j.ppnp.2008.12.036. arXiv:0811.3506.

[95] A. B. Larionov, M. Strikman, Slow-neutron production as a probe of hadron formation in high-
energy γ∗A reactions, Phys. Rev. C 101 (2020) 014617. doi:10.1103/PhysRevC.101.014617.
arXiv:1812.08231.

[96] S. Dytman, Final state interaction models in neutrino-nucleus cross sections, AIP Conf. Proc.

1189 (2009) 51–59. doi:10.1063/1.3274190.

[97] S. Leray, D. Mancusi, P. Kaitaniemi, J. C. David, A. Boudard, B. Braunn, J. Cugnon, Exten-
sion of the Li`ege Intra Nuclear Cascade model to light ion-induced collisions for medical and
space applications, J. Phys.: Conf. Ser. 420 (2013) 012065. doi:10.1088/1742-6596/420/1/
012065.

77

[98] INCL the Li`ege Intranuclear Cascade model, http://irfu.cea.fr/dphn/Spallation/incl.

html, 2014. Last accessed on 27 January 2021.

[99] D. Wright, M. Kelsey, The Geant4 Bertini Cascade, Nucl. Instrum. Methods Phys. Res. A

804 (2015) 175–188. doi:10.1016/j.nima.2015.09.058.

[100] S. Agostinelli, J. Allison, K. Amako, et al., Geant4–a simulation toolkit, Nucl. Instrum.

Methods Phys. Res. A 506 (2003) 250–303. doi:10.1016/S0168-9002(03)01368-8.

[101] Geant4: A simulation toolkit, https://geant4.web.cern.ch, 2021. Last accessed on 27

January 2021.

[102] S. Dytman, FSI overview, GENIE docDB #188, 2020. Talk given at the March 2020 GENIE

User Forum.

[103] R. Hatcher, Non-Physics Aspects of the Integration of INCL++ and Geant4 into GENIE FSI,

GENIE docDB #174, 2019.

[104] J. Cheng, Y.-F. Li, L.-J. Wen, S. Zhou, Neutral-current background induced by at-
I. model predictions (2020).

mospheric neutrinos at large liquid-scintillator detectors:
arXiv:2008.04633.

[105] A. J. Koning, S. Hilaire, M. C. Duijvestijn, TALYS-1.0, in: O. Bersillon, F. Gunsing, E. Bauge,
R. Jacqmin, S. Leray (Eds.), Proceedings of the International Conference on Nuclear Data
for Science and Technology, EDP Sciences, 2007, pp. 211–214. doi:10.1051/ndata:07767.

[106] A. J. Koning, D. Rochman, Modern nuclear data evaluation with the TALYS code system,

Nucl. Data Sheets 113 (2012) 2841–2934. doi:10.1016/j.nds.2012.11.002.

[107] J. M. Quesada, V. Ivanchenko, A. Ivanchenko, Recent developments in pre-equilibrium and
de-excitation models in Geant4, Prog. Nucl. Sci. Tech. 2 (2011) 936–941. doi:10.15669/pnst.
2.936.

[108] S. Gardiner, Nuclear de-excitations in low-energy charged-current νe scattering on 40Ar

(2020). arXiv:2010.02393.

[109] S. Olver, A. Townsend, Fast inverse transform sampling in one and two dimensions (2013).

arXiv:1307.1223.

[110] W. Hauser, H. Feshbach, The inelastic scattering of neutrons, Phys. Rev. 87 (1952) 366.

doi:10.1103/PhysRev.87.366.

[111] M. Lindner, W. Rodejohann, X.-J. Xu, Coherent neutrino-nucleus scattering and new
neutrino interactions, J. High Energy Phys. 2017 (2017). doi:10.1007/JHEP03(2017)097.
arXiv:1612.04150.

[112] S. Kerman, V. Sharma, M. Deniz, H. T. Wong, J.-W. Chen, H. B. Li, S. T. Lin, C.-P. Liu,
Q. Yue (TEXONO Collaboration), Coherency in neutrino-nucleus elastic scattering, Phys.
Rev. D 93 (2016) 113006. doi:10.1103/PhysRevD.93.113006. arXiv:1603.08786.

[113] E. Fermi, Versuch einer Theorie der β-Strahlen. I., Z. Phys. 88 (1934) 161–177. doi:10.1007/

BF01351864, in German.

78

[114] F. L. Wilson, Fermi’s theory of beta decay, Am. J. Phys. 36 (1968) 1150. doi:10.1119/1.

1974382, English translation of [113].

[115] F. Hoyle, R. H. Fowler, β-transitions in a coulomb ﬁeld, Proc. R. Soc. A 166 (1938) 249–269.

doi:10.1098/rspa.1938.0091.

[116] M. Cannoni, Lorentz invariant relative velocity and relativistic binary collisions, Int. J. Mod.

Phys. A 32 (2017) 1730002. doi:10.1142/S0217751X17300022. arXiv:1605.00569.

[117] J. Engel, Approximate treatment of lepton distortion in charged-current neutrino scat-
tering from nuclei, Phys. Rev. C 57 (1998) 2004–2009. doi:10.1103/PhysRevC.57.2004.
arXiv:nucl-th/9711045.

[118] C. Volpe, N. Auerbach, G. Col`o, N. Van Giai,

Charged-current neutrino-
Phys. Rev. C 65 (2002) 044603. doi:10.1103/PhysRevC.65.044603.

208Pb reactions,
arXiv:nucl-th/0103039.

[119] R. Capote, M. Herman, P. Obloˇzinsk`y, P. Young, S. Goriely, T. Belgya, A. Ignatyuk, A. J.
Koning, S. Hilaire, V. A. Plujko, et al., RIPL – Reference Input Parameter Library for
calculation of nuclear reactions and nuclear data evaluations, Nucl. Data Sheets 110 (2009)
3107–3214. doi:10.1016/j.nds.2009.10.004.

[120] A. J. Koning, S. Hilaire, S. Goriely, Global and local level density models, Nucl. Phys. A 810

(2008) 13–76. doi:10.1016/j.nuclphysa.2008.06.005.

[121] A. Koning, J. Delaroche, Local and global nucleon optical models from 1 keV to 200 MeV,

Nucl. Phys. A 713 (2003) 231–310. doi:10.1016/S0375-9474(02)01321-0.

[122] D. Madland, Recent results in the development of a global medium-energy nucleon-nucleus
optical-model potential,
in: Proceedings of a Specialists’ Meeting on Preequilibrium Nu-
clear Reactions, 1988, pp. 103–110. URL: https://www.oecd-nea.org/science/docs/1988/
neandc1988-245-u.pdf.

[123] NIST Digital Library of Mathematical Functions, Release 1.0.26 of 2020-03-15, 2020. URL:
http://dlmf.nist.gov/, F. W. J. Olver, A. B. Olde Daalhuis, D. W. Lozier, B. I. Schneider,
R. F. Boisvert, C. W. Clark, B. R. Miller, B. V. Saunders, H. S. Cohl, and M. A. McClain,
eds.

[124] B. V. Noumerov, A method of extrapolation of perturbations, Mon. Not. R. Astron. Soc. 84

(1924) 592–602. doi:10.1093/mnras/84.8.592.

[125] B. Numerov, Note on the numerical integration of d2x/dt2 = f (x, t), Astron. Nachr. 230

(1927) 359–364. doi:10.1002/asna.19272301903.

[126] J. Thijssen, Computational Physics, 2 ed., Cambridge University Press, 2007. URL: http:

//books.google.com/books?vid=ISBN9780521833462.

[127] W. E. Brown, Random number generation in C++11, http://www.open-std.org/jtc1/
sc22/wg21/docs/papers/2013/n3551.pdf, 2013. Last accessed on 27 January 2021.

79

[128] M. Matsumoto, T. Nishimura, Mersenne Twister: A 623-dimensionally equidistributed uni-
form pseudo-random number generator, ACM Trans. Model. Comput. Simul. 8 (1998) 3–30.
doi:10.1145/272991.272995.

[129] T. Nishimura, Tables of 64-bit Mersenne twisters, ACM Trans. Model. Comput. Simul. 10

(2000) 348–357. doi:10.1145/369534.369540.

[130] T. Becker,

STL & generic programming: writing your own iterators, C/C++ Users
J. 19 (2001) 51–57. URL: https://web.archive.org/web/20140811092434/https:
//collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/CUJ/
2001/0108/becker/becker.htm.

[131] R. P. Brent, An algorithm with guaranteed convergence for ﬁnding a minimum of a function
in: Algorithms for Minimization without Derivatives, Prentice-Hall, 1973,

of one variable,
pp. 61–80. URL: https://books.google.com/books?id=Ee5QAAAAMAAJ.

[132] S. Olver, A. Townsend, Inverse transform sampling MATLAB implementation, https://

github.com/dlfivefifty/InverseTransformSampling, 2013.

[133] T. A. Driscoll, N. Hale, L. N. Trefethen, Chebfun Guide, Pafnuty Publications, 2014. URL:

http://www.chebfun.org/docs/guide/.

[134] Z. Battles, L. Trefethen, An extension of MATLAB to continuous functions and operators,
SIAM J. Sci. Comput 25 (2004) 1743–1770. URL: http://www.chebfun.org/publications/
chebfun_paper.pdf. doi:10.1137/S1064827503430126.

[135] J. Berrut, L. Trefethen, Barycentric Lagrange interpolation, SIAM Rev. 46 (2004) 501–
517. URL: https://people.maths.ox.ac.uk/trefethen/barycentric.pdf. doi:10.1137/
S0036144502417715.

[136] A. Fernandes, P. N. Swarztrauber, R. Valent, FFTPACK4: Fast Fourier Transform, https:
//people.sc.fsu.edu/~jburkardt/c_src/fftpack4/fftpack4.html, 2019. Last accessed
on 27 January 2021.

[137] P. N. Swarztrauber, Vectorizing the FFTs,

in: G. Rodrigue (Ed.), Parallel Computations,
Computational Techniques, Academic Press, 1982, pp. 51–83. URL: https://books.google.
com/books?id=ur7SBQAAQBAJ.

[138] P. N. Swarztrauber, FFTPACK, http://www.netlib.org/fftpack, 2021. Last accessed on

27 January 2021.

[139] P. J. Mohr, B. N. Taylor, D. B. Newell, CODATA recommended values of the fundamental
physical constants: 2010, Rev. Mod. Phys. 84 (2012) 1527–1605. URL: https://physics.
nist.gov/cuu/Constants/Preprints/lsa2010.pdf. doi:10.1103/RevModPhys.84.1527.

[140] G. Audi, M. Wang, A. Wapstra, F. Kondev, M. MacCormick, X. Xu, B. Pfeiﬀer, The
AME2012 atomic mass evaluation, Chin. Phys. C 36 (2012) 1287–1602. doi:10.1088/
1674-1137/36/12/002.

[141] W. D. Myers, W. J. Swiatecki, Nuclear masses and deformations, Nucl. Phys. 81 (1966) 1–60.

doi:10.1016/0029-5582(66)90639-0.

80

[142] C. W. Clenshaw, A. R. Curtis, A method for numerical integration on an automatic com-
puter, Numer. Math. 2 (1960) 197–205. URL: http://www.digizeitschriften.de/dms/
resolveppn/?PID=GDZPPN001163442. doi:10.1007/BF01386223.

[143] GNU Bash, http://gnu.org/software/bash/, 2020. Last accessed on 27 January 2021.

[144] GCC, the GNU Compiler Collection, https://gcc.gnu.org/, 2021. Last accessed on 27

January 2021.

[145] Clang: a C language family frontend for LLVM, https://clang.llvm.org/, 2021. Last ac-

cessed on 27 January 2021.

[146] GNU Make, https://www.gnu.org/software/make/, 2020. Last accessed on 27 January

2021.

[147] Homebrew: The Missing Package Manager for macOS (or Linux), https://brew.sh/, 2021.

Last accessed on 27 January 2021.

[148] IEEE Standard for

Information Technology–Portable Operating System Interface
(POSIX(R)) Base Speciﬁcations, Issue 7, 2018. doi:10.1109/IEEESTD.2018.8277153, IEEE
Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008).

[149] S. Gardiner, MARLEY User Guide, https://www.marleygen.org, 2021. Last accessed on 27

January 2021.

[150] pkg-conﬁg, https://www.freedesktop.org/wiki/Software/pkg-config/, 2018. Last ac-

cessed on 27 January 2021.

[151] T. Bray, The JavaScript Object Notation (JSON) data interchange format, 2017. doi:10.

17487/RFC8259.

[152] N. Semmel, SimpleJSON, https://github.com/nbsdx/SimpleJSON, 2016.

[153] J. F. Beacom, The diﬀuse supernova neutrino background, Annu. Rev. Nucl. Part. Sci. 60

(2010) 439–462. doi:10.1146/annurev.nucl.010909.083331. arXiv:1004.3311.

[154] M.-K. Cheoun, E. Ha, T. Kajino, High-lying excited states in Gamow Teller strength and
their roles in neutrino reactions, The European Physical Journal A 48 (2012) 137. doi:10.
1140/epja/i2012-12137-y.

[155] M. Bhattacharya, A. Garc´ıa, N. I. Kaloskamis, E. G. Adelberger, H. E. Swanson, R. Anne,
M. Lewitowicz, M. G. Saint-Laurent, W. Trinder, C. Donzaud, et al., Neutrino absorption
eﬃciency of an 40Ar detector from the β decay of 40Ti, Phys. Rev. C 58 (1998) 3677–3687.
doi:10.1103/PhysRevC.58.3677.

[156] W. Liu, M. Hellstr¨om, R. Collatz, J. Benlliure, L. Chulkov, D. C. Gil, F. Farget, H. Grawe,
Z. Hu, N. Iwasa, et al., β decay of 40Ti and 41Ti and implication for solar-neutrino detection,
Phys. Rev. C 58 (1998) 2677–2688. doi:10.1103/PhysRevC.58.2677.

[157] M. Bhattacharya, C. D. Goodman, A. Garc´ıa, Weak-interaction strength from charge-
exchange reactions versus β decay in the A = 40 isoquintet, Phys. Rev. C 80 (2009) 055501.
doi:10.1103/PhysRevC.80.055501.

81

[158] T. Totani, K. Sato, H. E. Dalhed, J. R. Wilson, Future detection of supernova neu-
trino burst and explosion mechanism, Astrophys. J. 496 (1998) 216. doi:10.1086/305364.
arXiv:astro-ph/9710203.

[159] M.-Y. Huang, X.-H. Guo, B.-L. Young, Detection of supernova neutrinos at spallation
neutron sources, Chin. Phys. C 40 (2016) 073102. doi:10.1088/1674-1137/40/7/073102.
arXiv:1511.00806.

[160] M. T. Keil, G. G. Raﬀelt, H.-T. Janka, Monte Carlo study of supernova neutrino spectra for-
mation, Astrophys. J. 590 (2003) 971–991. doi:10.1086/375130. arXiv:astro-ph/0208035.

[161] T. S. Kosmas, D. K. Papoulias, M. T´ortola, J. W. F. Valle, Probing light sterile neutrino
signatures at reactor and Spallation Neutron Source neutrino experiments, Phys. Rev. D 96
(2017) 063013. doi:10.1103/PhysRevD.96.063013. arXiv:1703.00054.

[162] A. Bolozdynya, F. Cavanna, Y. Efremenko, G. Garvey, et al., Opportunities for neutrino

physics at the Spallation Neutron Source: a white paper (2012). arXiv:1211.5199.

[163] P. A. Zyla, R. M. Barnett, J. Beringer, O. Dahl, D. A. Dwyer, D. E. Groom, C.-J. Lin,
K. S. Lugovsky, E. Pianori, D. J. Robinson, et al. (Particle Data Group), Review of Particle
Physics, Prog. Theor. Exp. Phys. 2020 (2020). doi:10.1093/ptep/ptaa104, 083C01.

[164] T. Sj¨ostrand, QCD generators,

in: G. Altarelli, R. Kleiss, C. Verzegnassi (Eds.), Z
Physics at LEP 1, volume 3, Event generators and software, 1989, pp. 143–340. URL:
http://inspirehep.net/record/288141/files/.

[165] A. Buckley, P. Ilten, D. Konstantinov, L. L¨onnblad, J. Monk, W. Pokorski, T. Przedzinski,
A. Verbytskyi, The HepMC3 event record library for Monte Carlo event generators, Comput.
Phys. Commun. 260 (2021) 107310. doi:10.1016/j.cpc.2020.107310. arXiv:1912.08005.

[166] Trees in ﬁve steps, https://ph-root-2.cern.ch/d/trees-five-steps.html, 2018. Last

accessed on 27 January 2021.

[167] M. Goto, CINT: C++ Interpreter, http://www.hanno.jp/gotom/Cint.html, 2015. Last ac-

cessed on 27 January 2021.

[168] V. Vassilev, P. Canal, A. Naumann, L. Moneta, P. Russo, Cling – The New Interactive
Interpreter for ROOT 6, J. Phys. Conf. Ser. 396 (2012) 052071. doi:10.1088/1742-6596/
396/5/052071.

[169] D. van Heesch, Doxygen, https://www.doxygen.nl/, 2021. Last accessed on 27 January

2021.

[170] C. Andreopoulos, C. Barry, S. Dytman, H. Gallagher, T. Golan, R. Hatcher, G. Perdue,
J. Yarba, The GENIE neutrino Monte Carlo generator: physics and user manual (2015).
arXiv:1510.05494.

[171] E. D. Church, LArSoft: A software package for liquid argon time projection drift chambers

(2013). arXiv:1311.6774.

82

[172] E. Snider, G. Petrillo, LArSoft: toolkit for simulation, reconstruction and analysis of liq-
uid argon TPC neutrino detectors, J. Phys.: Conf. Ser. 898 (2017) 042057. doi:10.1088/
1742-6596/898/4/042057.

[173] R. Pordes, E. Snider, The liquid argon software toolkit (LArSoft): Goals, status and plan, in:
38th International Conference on High Energy Physics (ICHEP2016), 2017. doi:10.22323/1.
282.0182, PoS(ICHEP2016)182.

[174] LArSoft collaboration: Software for LArTPCs, https://larsoft.org, 2021. Last accessed

on 27 January 2021.

[175] Geant4

book

for

application

developers,

geant4-userdoc/UsersGuides/ForApplicationDeveloper/html/index.html,
Last accessed on 27 January 2021.

http://geant4-userdoc.web.cern.ch/
2020.

[176] E. Mendoza, D. Cano-Ott, Update of the evaluated neutron cross section libraries for the
Geant4 code, Technical Report INDC(NDS)-0758, International Atomic Energy Agency
(IAEA), 2018. URL: https://www-nds.iaea.org/publications/indc/indc-nds-0758/.

[177] E. Mendoza, D. Cano-Ott, C. Guerrero, R. Capote, New Evaluated Neutron Cross Sec-
tion Libraries for the GEANT4 Code, Technical Report INDC(NDS)-0612, International
Atomic Energy Agency (IAEA), 2012. URL: https://www-nds.iaea.org/publications/
indc/indc-nds-0612/.

[178] C. Green, J. Kowalkowski, M. Paterno, M. Fischler, L. Garren, Q. Lu, The art framework,

J. Phys. Conf. Ser. 396 (2012) 022020. doi:10.1088/1742-6596/396/2/022020.

[179] C. Anderson, M. Antonello, B. Baller, et al. (ArgoNeuT Collaboration), The ArgoNeuT
detector in the NuMI low-energy beam line at Fermilab, J. Instrum. 7 (2012) P10019–P10019.
doi:10.1088/1748-0221/7/10/p10019. arXiv:1205.6747.

[180] R. Acciarri, C. Adams, J. Asaadi, et al. (LArIAT Collaboration), The Liquid Argon In
A Testbeam (LArIAT) experiment, J. Instrum. 15 (2020) P04026–P04026. doi:10.1088/
1748-0221/15/04/p04026. arXiv:1911.10379.

[181] R. Acciarri, C. Adams, R. An, A. Aparicio, et al. (MicroBooNE Collaboration), Design and
construction of the MicroBooNE detector, J. Instrum. 12 (2017) P02017–P02017. doi:10.
1088/1748-0221/12/02/p02017. arXiv:1612.05824.

[182] C. Rubbia, M. Antonello, P. Aprili, et al. (ICARUS Collaboration), Underground operation
of the ICARUS T600 LAr-TPC: ﬁrst results, J. Instrum. 6 (2011) P07011–P07011. doi:10.
1088/1748-0221/6/07/p07011.

[183] N. McConkey, SBND: Status of the Fermilab Short-Baseline Near Detector, J. Phys. Conf.

Ser. 888 (2017) 012148. doi:10.1088/1742-6596/888/1/012148.

[184] B. Abi, R. Acciarri, M. Acero, G. Adamov, D. Adams, M. Adinolﬁ, Z. Ahmad, J. Ahmed,
T. Alion, S. A. Monsalve, et al. (DUNE Collaboration), Volume I. Introduction to
J. Instrum. 15 (2020) T08008–T08008. doi:10.1088/1748-0221/15/08/t08008.
DUNE,
arXiv:2002.02967.

83

[185] D. Heck, J. Knapp, J. Capdevielle, G. Schatz, T. Thouw, CORSIKA: A Monte Carlo code to
simulate extensive air showers, Technical Report FZKA-6019, Institut f¨ur Kernphysik, 1998.
doi:10.5445/IR/270043064.

[186] C. Hagmann, D. Lange, D. Wright, Cosmic-ray shower generator (CRY) for Monte Carlo
in: 2007 IEEE Nuclear Science Symposium Conference Record, volume 2,

transport codes,
2007, pp. 1143–1146. doi:10.1109/NSSMIC.2007.4437209.

[187] S. Gardiner, Nuclear Eﬀects in Neutrino Detection, Ph.D. thesis, University of California,

Davis, 2018. doi:10.5281/zenodo.3903986.

[188] R. Putz, Speciﬁcation of the Fermilab Hierarchical Conﬁguration Language, https://cdcvs.
fnal.gov/redmine/attachments/download/6639/grammar.pdf, 2012. Last accessed on 27
January 2021.

[189] M. Acero, P. Adamson, G. Agam, L. Aliaga, T. Alion, V. Allakhverdian, N. Anﬁmov, A. An-
toshkin, E. Arrieta-Diaz, L. Asquith, et al. (NOvA Collaboration), Supernova neutrino detec-
tion in NOvA, J. Cosmol. Astropart. Phys. 2020 (2020) 014–014. doi:10.1088/1475-7516/
2020/10/014. arXiv:2005.07155.

[190] M. Ikeda, A. Takeda, Y. Fukuda, et al. (Super-Kamiokande Collaboration), Search for super-
nova neutrino bursts at Super-Kamiokande, Astrophys. J. 669 (2007) 519–524. doi:10.1086/
521547. arXiv:0706.2283.

[191] N. Van Dessel, N. Jachowicz, A. Nikolakopoulos, Forbidden transitions in neutral- and
charged-current interactions between low-energy neutrinos and argon, Phys. Rev. C 100
(2019) 055503. doi:10.1103/PhysRevC.100.055503. arXiv:1903.07726.

[192] N. Van Dessel, A. Nikolakopoulos, N. Jachowicz, Lepton kinematics in low-energy neutrino-
argon interactions, Phys. Rev. C 101 (2020) 045502. doi:10.1103/PhysRevC.101.045502.
arXiv:1912.10714.

[193] J. A. Dror, G. Elor, R. McGehee, Directly detecting signals from absorption of fermionic
dark matter, Phys. Rev. Lett. 124 (2020) 181301. doi:10.1103/PhysRevLett.124.181301.
arXiv:1905.12635.

[194] P. Stowell, C. Wret, C. Wilkinson, L. Pickering, et al., NUISANCE: a neutrino cross-section
generator tuning and comparison framework, J. Instrum. 12 (2017) P01016–P01016. doi:10.
1088/1748-0221/12/01/p01016. arXiv:1612.07393.

[195] J. Barrow, M. Betancourt, L. Cremonesi, S. Dytman, et al., Summary of workshop on common

neutrino event generator tools (2020). arXiv:2008.06566.

84

