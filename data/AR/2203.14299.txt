Adversarial Representation Sharing: A Quantitative and Secure
Collaborative Learning Framework

Jikun Chen
cjk7989@sjtu.edu.cn
Shanghai Jiao Tong University

Feng Qiang
f.qiang@gmail.com

Na Ruanâˆ—
naruan@cs.sjtu.edu.cn
Shanghai Jiao Tong University

2
2
0
2

r
a

M
7
2

]

R
C
.
s
c
[

1
v
9
9
2
4
1
.
3
0
2
2
:
v
i
X
r
a

ABSTRACT
The performance of deep learning models highly depends on the
amount of training data. It is common practice for todayâ€™s data hold-
ers to merge their datasets and train models collaboratively, which
yet poses a threat to data privacy. Different from existing methods
such as secure multi-party computation (MPC) and federated learn-
ing (FL), we find representation learning has unique advantages in
collaborative learning due to the lower communication overhead
and task-independency. However, data representations face the
threat of model inversion attacks. In this article, we formally define
the collaborative learning scenario, and quantify data utility and
privacy. Then we present ARS, a collaborative learning framework
wherein users share representations of data to train models, and
add imperceptible adversarial noise to data representations against
reconstruction or attribute extraction attacks. By evaluating ARS in
different contexts, we demonstrate that our mechanism is effective
against model inversion attacks, and achieves a balance between
privacy and utility. The ARS framework has wide applicability. First,
ARS is valid for various data types, not limited to images. Second,
data representations shared by users can be utilized in different
tasks. Third, the framework can be easily extended to the vertical
data partitioning scenario.

KEYWORDS
privacy, collaborative learning, adversarial examples, quantification,
trade-off

1 INTRODUCTION
Deep learning has made great progress in a variety of fields, such as
computer vision, natural language processing and recommendation
systems. This impressive success largely attributes to the increas-
ing amount of available computation and datasets [9]. Companies
and institutions require large-scale data to build stronger machine
learning systems, whereas data is generally held by distributed
parties. Therefore, it is a common practice for multiple parties to
share data and train deep learning models collaboratively [23]. In
most of collaborative training scenarios, users provide their local
data to cloud computing services or share data with others, which
brings privacy concerns.

Due to security considerations and privacy protection regula-
tions, it is inappropriate to exchange data among different organi-
zations. Obviously, sharing raw data directly may cause a leakage
of private and sensitive information contained in datasets. For in-
stance, if some hospitals hope to integrate their patientsâ€™ informa-
tion to establish models for disease detection, they must carefully
protect the identity of patients from being obtained and abused by

âˆ—Corresponding author.

any partner or possible eavesdropper. The problem of "data islands"
requires a privacy-preserving collaborative framework.

Generally speaking, privacy-preserving collaborative learning
can be grouped under two approaches. Earlier works focus on
MPC, which ensures that multiple users can jointly calculate a cer-
tain function while keeping their inputs secret without the trusted
third party. In a joint learning framework, data in local devices
are encrypted by cryptographic tools before being shared [1, 21].
Cryptographic methods contain garbled circuits (GC) [32], secret
sharing (SS) [24], homomorphic encryption (HE) [7], etc. However,
current cryptographic approaches can just perform several types
of operations, and only propose friendly alternatives to some of
non-linear functions [21]. Moreover, encryption often causes high
computation and communication cost.

Shokri et al. [29] proposed a distributed stochastic gradient de-
scent algorithm to replace the sharing training data framework. The
method is now well known as federated learning (FL) [11] and has
a wide application in practice. In FL, a cloud server builds a global
deep learning model. For each training iteration, the server ran-
domly sends the model to a part of client devices. The clients then
optimize the model locally, and send the updates back to the server
to aggregate them. Only parameters of the model are communi-
cated, while the training data is retained by the local device, which
ensures the privacy. Some recent works combine federated learning
with other information security mechanisms (e.g., differential pri-
vacy) to further improve privacy [8]. However, the communication
cost between each local device and the central server is high. After
each iteration of training process, each user needs to keep their
local deep learning model synchronized.

Different from the above approaches, we consider representa-
tion learning [2] to solve this problem. The idea is inspired by deep
neural networks, which embed inputs into real feature vectors (rep-
resentations). Containing high-level features of the original data,
latent representations is efficient to various downstream machine
learning tasks [9]. The motivation is that both MPC and FL conduct
collaborative learning with limited task-applicability. Once the ma-
chine learning task changes, the entire training process needs to
be executed again, which incurs high communication cost. Com-
paratively speaking, data representations are task-independent and
thus has unique potential in joint learning. Some recent works have
studied privacy-preserving data representations [13, 30], but few of
them gave further discussion on the collaborative learning scenario.
The primary problem in privacy representations learning field is to
defend against model inversion attacks[12, 20], which aims to train
inverse models to reconstruct original inputs or extract private
attributes from shared data representations.

In this article, we propose ARS (for Adversarial Representa-
tion Sharing), a decentralized collaborative learning framework

 
 
 
 
 
 
based on data representations. Our work contains two levels: (i)
a collaborative learning framework wherein users share data rep-
resentations instead of raw data for further training; and (ii) an
imperceptible adversarial noise added to shared data representa-
tions to defend against model inversion attacks. ARS helps joint
learning participants "encode" their data locally, then add adver-
sarial noise to representations before sharing them. The published
adversarial latent representation can defend against reconstruction
attacks, thereby ensuring privacy.

Owning to the good qualities of latent representations, ARS has
wide applicability. First, ARS is valid for various data types as train-
ing samples, not limited to images. Second, ARS is task-independent.
Shared data representations are reusable for various tasks. Third,
prior joint learning frameworks are commonly designed under sce-
narios of horizontal data partitioning (in which datasets of users
share the same feature space but differ in sample ID space), whereas
ARS can easily extended its framework to the vertical data parti-
tioning scenario (in which datasets of different users share the same
sample Ids but differ in feature columns) [31].

Based on the collaborative learning framework, we apply adver-
sarial example noise [10] to protect shared representations from
model inversion attacks. The intuition is that adding special-designed
small perturbations on shared data representations can confuse the
adversaries so that they cannot reconstruct the original data or par-
ticular private attributes from the obfuscated latent representations.
By simulating the behavior of attackers, we generate adversarial
noise for potential inverse models. The noise is added to data repre-
sentations before sharing them, in order to make it hard to recover
the original inputs. In the meantime, the scale of these perturba-
tions are too small to influence data utility. We propose defense
strategies against reconstruction attacks and attribute extraction
attacks respectively.

The main contributions of our work are summarized as follows:

â€¢ We propose ARS, a new paradigm for collaborative frame-
work which is based on representation learning. Different
from MPC and FL, ARS is decentralized and has wide appli-
cability.

â€¢ We introduce adversarial noise to defend against model in-
version attacks. To the best of our knowledge, we are the
first to apply adversarial examples to ensure privacy in col-
laborative learning.

â€¢ We evaluate our mechanism on multiple datasets and aspects.
The results demonstrate that ARS achieves a balance between
privacy and utility. We further discuss the limitations and
challenges of our work.

The remainder of the paper is organized as follows. We first
review related work in Section 2. Then we introduce how ARS
achieves collaborative learning from an overall perspective in Sec-
tion 3, and detail how adversarial noise is applied to defend against
model inversion attacks and ensure privacy in Section 4. Experi-
mental results are shown in Section 5. In Section 6, we discuss the
details and challenges of the work. Finally, we conclude the work
in Section 7.

2

2 RELATED WORK
2.1 Privacy-Preserving Representation

Learning

To avoid privacy leakage in collaborative learning, some previous
works focus on learning privacy-preserving representations [6, 30].
Latent representations retain the abstract features of data, which
can be used for further analysis like classification or regression.
Generally, the distribution of data representations can be learned
by unsupervised latent variable model, such as autoencoders [22].
Meanwhile, the original information of data can not be directly
inferred from representations. For example, in natural language
processing, words are transformed into vectors by embedding net-
works, which is called word2vec [3]. Without embedding networks,
it is difficult to recover original words from embedding vectors.

However, data representations are still vulnerable to model inver-
sion attacks [12]. Adversaries can build reconstruction networks to
recover original data or reveal some attributes of data from shared
representations, even though they have no knowledge of the struc-
ture or parameters of the feature extraction models [12, 20]. For
example, they can recover face samples, or infer gender, age and
other personal information from shared representations of face
images, which were only supposed to be used for training face
recognition models.

In order to defend against inversion attacks, recent works fo-
cus on adversarial training [30] or generative adversarial networks
(GANs) [13]. Attackersâ€™ behaviors are simulated by another neu-
ral network while learning privacy representations of data, and
the two networks compete against each other to improve the ro-
bustness of representations. However, since itâ€™s hard to achieve a
balance between the attacker models and defender models during
training [26], these methods may cost much time in the pretreat-
ing phase. Ferdowsi et al. [6] generate privacy representations by
producing sparse codemaps. The above defense methods could be
applied to collaborative learning, but the authors didnâ€™t give a fur-
ther discussion on this scenario. In addition, all these methods are
task-oriented. When the task of shared data changes, they need to
generate new task-oriented data representation again.

2.2 Adversarial Examples
Adversarial examples are perturbed inputs designed to fool machine
learning models [10]. Formally, we denote by ğ‘“ : X â†’ {1, . . . , ğ‘›} a
classifier. For an input ğ‘¥ âˆˆ X and a label ğ‘™ = ğ‘“ (ğ‘¥), we call a vector
ğ‘Ÿ an adversarial noise if it satisfies:

âˆ¥ğ‘Ÿ âˆ¥ â‰¤ ğœ–, ğ‘“ (ğ‘¥ + ğ‘Ÿ ) â‰  ğ‘™,

where ğœ– is a small hyper-parameter to adjust the scale of noise.

Adversarial examples have strong transferability. Some works
[18] have shown that adversarial examples generated for a model
can often confuse another model. This property is used to execute
transferability based attacks [25]. Even if an attacker has no knowl-
edge about the details of a target model, it can still craft adversarial
examples successfully by attacking a substitute model. Therefore,
adversarial examples have become a significant threat to machine
learning models [10, 27].

Except for treating adversarial examples as threats, some works
utilize the properties of adversarial examples to protect userâ€™s pri-
vacy [28]. In this work, we also use adversarial noise to defend
against machine learning based inferring attacks. To the best of our
knowledge, we are the first to apply adversarial examples to data
sharing mechanisms for collaborative learning.

3 OVERVIEW OF ARS FRAMEWORK
ARS achieves collaborative learning by helping users share data
representations instead of raw data to train models. In this section,
we first present a joint learning scenario, and propose standards for
evaluating the effectiveness of a framework. Then we introduce how
ARS works in the whole collaborative learning process. Specifically,
how participants encoder their data into latent representations,
how to share data representations with others, and how shared
data is used for various machine learning tasks.

3.1 Collaborative Learning Scenario
Consider the scenario where ğ¾ parties share local data for collab-
orative training. Note that data belonging to distributed parties
can be partitioned horizontally (which means datasets shares same
feature space but differ in sample ID space) or vertically (which
means datasets shares different same feature space while sample
ids are same). For simplicity, we assume data is partitioned hori-
zontally (extension to vertical data partitioning in Section 4.4). The
dataset of the ğ‘–-th party is represented as {(ğ‘‹ğ‘–, ğ‘Œğ‘– )} = {(ğ‘¥ 1
ğ‘– , ğ‘¦1
ğ‘– ),
(ğ‘¥ 2
ğ‘– ) is a pair of training sample
and corresponding label, and ğ‘ğ‘– is the number of samples. The goal
of each participant is to encode their data ğ‘‹ğ‘– into representations
ğ‘ğ‘– = {ğ‘§1
ğ‘– }, and finally train deep learning models on
ğ‘1, ğ‘2, . . . , ğ‘ğ¾ which is published by all the data owners.

)}, where (ğ‘¥ ğ‘—

ğ‘– ), . . . , (ğ‘¥ ğ‘ğ‘–

ğ‘– , . . . , ğ‘§ğ‘ğ‘–

ğ‘– , ğ‘¦ ğ‘—

, ğ‘¦ğ‘ğ‘–
ğ‘–

ğ‘– , ğ‘¦2

ğ‘– , ğ‘§2

ğ‘–

To privacy concerns, participants have to defend against model
inversion attacks that reconstruct original inputs from latent repre-
sentations. Furthermore, there might be some sensitive features or
attributes in training samples. Any label of a training sample can
become the machine learning object or a private attribute, depend-
ing on the particular user and tasks. For example, when building a
disease detection model, the illness of each patient can be a public
label, while the identity information such as gender, age should be
private. We denote by ğ‘€ the number of private attributes that the
ğ‘–-th party has, and denote the set of labels of ğ‘˜-th private attributes
by ğ´ğ‘–ğ‘˜ = {ğ‘1
ğ‘–ğ‘˜ }, where ğ‘˜ âˆˆ {1, 2, . . . , ğ‘€ }. Attackers can
ğ‘–ğ‘˜
also conduct attribute extraction attacks to recover these private
attributes.

, . . . , ğ‘ğ‘ğ‘–

, ğ‘2
ğ‘–ğ‘˜

We highlight the following notations which are important to our

discussion.

â€¢ (ğ‘‹ğ‘–, ğ‘Œğ‘– ): original training set of user ğ‘–, and label set depending

on deep learning tasks.

ğ‘– ): the ğ‘—-th sample and corresponding label of user ğ‘–.

ğ‘– , ğ‘¦ ğ‘—
: value (label) of the ğ‘˜-th private attribute of ğ‘¥ ğ‘—
ğ‘– .

â€¢ (ğ‘¥ ğ‘—
â€¢ ğ‘ ğ‘—
ğ‘–ğ‘˜
â€¢ Enc(Â·): feature extractor which encode inputs into latent

representations.

â€¢ ğœƒEnc: parameters of the model Enc.
â€¢ ğ‘§ ğ‘—

ğ‘– : latent representation of the ğ‘—-th sample and label of user
ğ‘– = Enc(ğ‘¥ ğ‘—
ğ‘–, which satisfies ğ‘§ ğ‘—
ğ‘– ).

3

â€¢ ğ¶ (Â·): downstream deep learning model which takes {(ğ‘ğ‘–, ğ‘Œğ‘– )}ğ¾
ğ‘–=1

as the training set.

â€¢ Dec(Â·): (theoretical) inverse model of Enc, which maps rep-

resentations to reconstruction of inputs.

â€¢ SDec(Â·): decoder trained by adversaries to conduct model
inversion attacks, aiming to reconstruct inputs from shared
data representations.

3.2 Quantitative Criteria of ARS Mechanism
Formally, given a sample set ğ‘‹ and a label set ğ‘Œ , the main goal of
data sharing in ARS is to design a mapping Enc : X âˆ’â†’ Z that has
"nice" properties. These properties consists of utility and privacy
of shared data representations as follows.

3.2.1 Utility. After obtaining the shared data, each user can use
dataset {(ğ‘1, ğ‘Œ1), (ğ‘2, ğ‘Œ2), . . . , (ğ‘ğ¾ , ğ‘Œğ¾ )} to train downstream deep
learning model ğ¶ : Z âˆ’â†’ Y, such as classifiers to predict the label
ğ‘¦ from ğ‘§. Data utility requires the accuracy to approach the results
of models trained directly on {(ğ‘‹ğ‘–, ğ‘Œğ‘– )}ğ¾
ğ‘–=1. Therefore, Enc and ğ¶
should be optimized by minimizing the following expectation:

Eğ‘¥,ğ‘¦âˆ¼ğ‘ (ğ‘¥ ğ‘¦)

(cid:16)(cid:12)
(cid:12)
(cid:12)

Eğ‘§âˆ¼ğ‘Enc (ğ‘§ |ğ‘¥) [ğ‘ğ¶ (ğ‘¦|ğ‘§)] âˆ’ ğ‘ (ğ‘¦|ğ‘¥)

(cid:17)

(cid:12)
(cid:12)
(cid:12)

,

(1)

which ensures that encoding data into representations will not lose
much data utility.

3.2.2 Privacy. Privacy characterizes the difficulty of finding a model
Dec : Z âˆ’â†’ X to recover raw data, such as visualization informa-
tion of inputs of picture type. Without loss of generality, we focus
on reconstruction attacks (attribute extraction attacks is discussed
in Section 4.4). Therefore, ARS minimizes privacy leakage L, which
can be defined as reconstruction loss:

L = Lğ‘… = âˆ’

1
ğ‘

ğ‘
âˆ‘ï¸

ğ‘—=1

(cid:16)
ğ‘¥ ğ‘— , Dec(Enc(ğ‘¥ ğ‘— ))

(cid:17)

,

D

(2)

where distance function D (Â·, Â·) is used to describe the similarity
of original and reconstructed samples. In practice, the distance
function is often defined as ğ‘™ğ‘ norm. In computer vision, distance
between two images can also be measured as PSNR or SSIM [14].
If we consider attribute extraction attacks, we similarly use fea-
ture loss to indicate how possible an attacker can predict private
features successfully. Note that we donâ€™t adopt the error between
the true value of private attributes and prediction results of at-
tackers, in case adversaries break the defense by just flipping their
results. Instead, we calculate the distance between the prediction
result and a fixed vector. The feature loss corresponding to the ğ‘˜-th
privacy attribute is defined as:

Lğ´ğ‘˜ =

1
ğ‘

ğ‘
âˆ‘ï¸

ğ‘—=1

(cid:16)
ğ‘Ÿğ‘˜, ğ¹ğ‘˜ (Enc(ğ‘¥ ğ‘— ))

(cid:17)

,

D

(3)

where ğ‘Ÿğ‘˜ is a fixed vector generated randomly, whose size is the
same as ğ‘ğ‘–ğ‘˜ . ğ¹ğ‘˜ is a corresponding attribute extraction network
trained by adversaries. Low Lğ´ğ‘˜
implies meaningless prediction
results. In this condition, the encoding system minimizes the overall
generalization loss:

L = ğœ†0Lğ‘… +

ğ‘€
âˆ‘ï¸

ğ‘˜=1

ğœ†ğ‘˜ Lğ´ğ‘˜

,

(4)

Figure 1: An overview of our basic encoding-based privacy-preserving data sharing mechanism.

where (cid:205)ğ‘€
privacy requirements.

ğ‘˜=0 ğœ†ğ‘˜ = 1. The value of ğœ†ğ‘˜ is assigned depending on usersâ€™

For example, model ğ¶ : Z âˆ’â†’ Y can be trained by minimize
the empirical risk:

3.3 The ARS Collaborative Learning

Framework

We apply autoencoder [22], an unsupervised neural network to
learn data representations. Autoencoder can be divided into an
encoder part and a decoder part. The encoder transforms inputs
into latent representations, while the decoder map representations
to reconstruction of inputs with size smaller than inputs. The op-
timization target of the autoencoder is to minimize the difference
between original inputs and reconstructed ones. Since the encoder
compress the feature space, latent representations are wished to
remain high-level features of input data [5].

As shown in Fig. 1, the ARS collaborative learning framework

consists of three phases:

â€¢ Encoder publishing phase. In this phase, a common encoder
Enc is trained and published to all participants. The user
having permission to train Enc is called initiator, who can
be selected randomly, or the party owning the most amount
of data. The mechanism in which users shares the same
encoder is to ensure that each column of representation
vectors shared by any user expresses a specific meaning.
Suppose that user ğ‘¡ is chosen, it first trains an autoencoder
on its local dataset and then publish the encoder part (Enc),
as:

ğ‘ğ‘¡
âˆ‘ï¸

1
ğœƒEnc, ğœƒDec = arg min
ğ‘ğ‘¡
ğœƒEnc,ğœƒDec
ğ‘¡ = Dec(Enc(ğ‘¥ ğ‘—
Â¯ğ‘¥ ğ‘—

where

ğ‘—=1
ğ‘¡ )).

(cid:16)
ğ‘¥ ğ‘—
ğ‘¡ , Â¯ğ‘¥ ğ‘—

ğ‘¡

(cid:17)

,

D

(5)

â€¢ Data sharing phase. After the common encoder Enc is pub-
lished, user ğ‘– encode its data into representations as: ğ‘§ ğ‘—
ğ‘– =
Enc(ğ‘¥ ğ‘—
ğ‘– ). Then it shares the pair {(ğ‘ğ‘–, ğ‘Œğ‘– )} with the other
parties. (In fact, users generate noise ğ›¿ for each data rep-
resentation, then publish Ë†ğ‘§ = ğ‘§ + ğ›¿ instead of ğ‘§ to defend
against model inversion attacks. See Section 4).

â€¢ Collaborative learning phase. Finally, each participant can use
ğ‘–=1 to train deep learning models locally.

the pairs {(ğ‘ğ‘–, ğ‘Œğ‘– )}ğ¾

4

Ë†ğ‘…(ğ¶) =

1
ğ‘

ğ‘
âˆ‘ï¸

ğ‘—=1

L (ğ‘¦ ğ‘— , ğ¶ (ğ‘§ ğ‘— )),

(6)

where ğ‘ is the amount of (ğ‘§, ğ‘¦) pairs shared by all users, and
L is the loss function of model ğ¶.

The ARS framework provides data utility from two aspects. First,
accuracy of the deep learning task (i.e. prediction of label ğ‘¦) is en-
sured. Equation (1) can be explained as: for any ğ‘¥ sampled from the
input distribution and its ground truth label ğ‘¦, we aim to maximize
Eğ‘§âˆ¼ğ‘Enc (ğ‘§ |ğ‘¥) [ğ‘ğ¶ (ğ‘¦|ğ‘§)] to make it close to ğ‘ (ğ‘¦|ğ‘¥) (which should be
slightly less than 1). The goal is equivalent to minimize the gener-
alization error of ğ¶:

ğ‘…(ğ¶) = Eğ‘¥,ğ‘¦âˆ¼ğ‘ (ğ‘¥ ğ‘¦)

(cid:2)Eğ‘§âˆ¼ğ‘Enc (ğ‘§ |ğ‘¥) [L (ğ‘¦, ğ¶ (ğ‘§))](cid:3) .

(7)

Empirically, models with less empirical risk (training error) nor-
mally has less generalization error as well. ARS reduces ğ‘…(ğ¶) by
decreasing Ë†ğ‘…(ğ¶) in the collaborative learning phase. If dataset
{ğ‘‹ğ‘–, ğ‘Œğ‘– }ğ¾
ğ‘–=1 is representative and Enc is well trained, the joint learn-
ing framework will not lose much accuracy.

Second, shared data representations are adaptive to various tasks.
Since Enc is trained without any supervision or knowledge about
collaborative learning tasks, we have ğ‘ (ğ‘§|ğ‘¥) = ğ‘ (ğ‘§|ğ‘¥ğ‘¦) indicating
that latent representations are task-independent. Meanwhile, data
representations are valid for downstream tasks, which can be ex-
plained by a basic idea that learning about the input distribution
helps with learning about the mapping from inputs to outputs [9].
A well trained autoencoder remains high level features of inputs,
which are also useful for supervised learning tasks.

4 ADVERSARIAL NOISE MECHANISM
AGAINST INVERSION ATTACKS

This section discusses the privacy of ARS. We first define a threat
model caused by model inversion attacks. Then we describe how
adversarial noise protects data representations from the inversion
attacks. Finally, we extend ARS to the scenarios of vertical data
partitioning and attribute extraction attacks.

Figure 2: Model inversion attack to reconstruct samples.

Figure 3: Adding adversarial noise on latent representations.

4.1 Threat Model
The main threat of ARS collaborative learning is model inversion
attacks. Although private information of raw data is hidden into
representations, it may still be recovered by reconstruction models,
like Dec trained by initiator in the encoder publishing phase. For
simplicity, we firstly focus on reconstruction attacks, and extend
our method to overcome attribute extraction attacks in Section 4.4.
The threat model defines adversaries who act like curious partic-
ipants and try to recover the original input ğ‘¥ from data represen-
tation ğ‘§ = Enc(ğ‘¥) for private information. Like other participants,
adversaries can obtain data representations shared by users and
have query access to the published encoder Enc, but have no knowl-
edge about the architecture and parameters of Enc. Nonetheless,
adversaries can still exploit query feedback of Enc to carry out
black-box attacks and acquire substitute decoders of Dec. For in-
stance, if user ğ‘– with data {(ğ‘‹ğ‘–, ğ‘Œğ‘– )} is an attacker, it can generate
latent representations by querying ğ‘§ ğ‘—
ğ‘– ) for ğ‘ğ‘– times. Then
it can build a substitute decoder SDec : Z âˆ’â†’ X as Figure 2 shows.
SDec can be optimized by minimizing the distance between original
and recovered samples:

ğ‘– = Enc(ğ‘¥ ğ‘—

ğœƒSDec = arg min

ğœƒSDec

1
ğ‘ğ‘–

ğ‘ğ‘–
âˆ‘ï¸

ğ‘—=1

(cid:16)
ğ‘– , SDec(Enc(ğ‘¥ ğ‘—
ğ‘¥ ğ‘—

ğ‘– ))

(cid:17)

.

D

(8)

This kind of attack can be regarded as chosen-plaintext attack
(CPA) from the cryptographic point of view. The reconstruction
ability of model inversion attacks is strong when training samples
of victims and attackers has similar distribution. In the following,
we propose the adversarial noise mechanism to defend against the
inversion attacks.

4.2 Adding Adversarial Noise
The strategy to defense against inversion attacks comes from a
simple idea: adding an intentionally designed small noise on latent
representations before sharing them. On the one hand, the scale of the
noise vector is so small that it would not reduce the utility of shared
data representations. On the other hand, we hope adding noise on
data representations can make data reconstructed by SDec different
enough from the original inputs. Inspired by adversarial examples,
we let users add adversarial noise to latent representations in set ğ‘ ,
and share the set of adversarial examples Ë†ğ‘ instead, as shown in
Figure 3.

According to some researches [25], adversarial examples have
strong transferability. Empirically, if Ë†ğ‘ successfully fools the de-
coder from which it is generated, then it is likely to cause another
decoder with similar decision boundary to recover samples that are
very different from the original inputs. The properties of adversar-
ial noise determine its ability to protect the privacy of shared data
representations even if the scale of noise is small.

The method to generate effective adversarial noise consists of
two steps. A participant first trains a substitute decoder SDec locally
by simulating reconstruction attacks; then it generates adversarial
noise for ğ‘ to make SDec invalid. Adversarial noise is generated
through iterative fast gradient sign method (I-FGSM) [10], which
sets the direction of adversarial noise to the gradient of objective
function Lğ‘… with respect to ğ‘§. The adversarial latent representation
Ë†ğ‘§ is calculated as:

Ë†ğ‘§ (ğ‘¡ +1) = Ë†ğ‘§ (ğ‘¡ ) + ğ›¼ Â· sign (cid:16)
Ë†ğ‘§ (1) = ğ‘§,

ğ‘¡ = 1, . . . , ğ‘›,

(cid:16)
ğ‘¥, SDec( Ë†ğ‘§ (ğ‘¡ ) )

âˆ‡ğ‘§ D
Ë†ğ‘§ = Ë†ğ‘§ (ğ‘›+1),

(cid:17)(cid:17)

,

(9)

where ğ›¼ is a hyper-parameter regulating the scale of noise in each
iteration and ğ‘› is the iteration time. The adversarial noise on ğ‘§ can
be denoted as:

ğ›¿ğ‘… = Ë†ğ‘§ âˆ’ ğ‘§.
(10)
In consideration of data utility, the difference between ğ‘§ and Ë†ğ‘§
should not be so great, otherwise Ë†ğ‘§ would lose most of the features
of ğ‘¥. Therefore, given an encoded vector ğ‘§, we must ensure that
|ğ›¿ğ‘… | = | Ë†ğ‘§ âˆ’ ğ‘§| â‰¤ ğœ–, where ğœ– is a hyper-parameter to be chosen. Next
we prove that adversarial noise in Equation (9) satisfies the privacy
budget.

Proposition 1. Given ğœ– âˆˆ Râˆ—, ğ‘› âˆˆ Nâˆ—. Suppose ğ›¼ = ğœ–

ğ‘› , then
adversarial data representation Ë†ğ‘§ defined by Equation (9) satisfies:
| Ë†ğ‘§ âˆ’ ğ‘§| â‰¤ ğœ–.

âˆ‡ğ‘§ D

Proof. For any iteration step ğ‘¡ âˆˆ {1, . . . , ğ‘›}, we have:
Ë†ğ‘§ (ğ‘¡ +1) âˆ’ Ë†ğ‘§ (ğ‘¡ ) (cid:12)
(cid:12)
(cid:17)(cid:17)(cid:12)
(cid:12)
ğ›¼ Â· sign (cid:16)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12) =
(cid:12)
(cid:12)
(cid:12)
(cid:12)
sign (cid:16)
= ğ›¼
(cid:12)
(cid:12)
= ğ›¼ .
Therefore, |ğ›¿ğ‘… | = | Ë†ğ‘§ âˆ’ ğ‘§| = | Ë†ğ‘§ (ğ‘›+1) âˆ’ Ë†ğ‘§ (1) | â‰¤ (cid:205)ğ‘›
ğ‘› Â· ğ›¼ = ğœ–.

(cid:16)
ğ‘¥, SDec( Ë†ğ‘§ (ğ‘¡ ) )
(cid:17)(cid:17)(cid:12)
(cid:12)
(cid:12)

(cid:16)
ğ‘¥, SDec( Ë†ğ‘§ (ğ‘¡ ) )

âˆ‡ğ‘§ D

ğ‘¡ =1 | Ë†ğ‘§ (ğ‘¡ +1) âˆ’ Ë†ğ‘§ (ğ‘¡ ) | =
â–¡

Proposition 1 shows that if we set ğ›¼ to ğœ–

ğ‘› in Equation (9), then
the scale of adversarial noise will be limited to ğœ–. Here ğœ– is called

5

defense intensity, which determines the utility and privacy of repre-
sentations.

4.3 Adding Masked Adversarial Noise
Ë†ğ‘ can mislead most of decoders trained from pairs {(ğ‘, ğ‘‹ )} due to
the transferability of adversarial examples. However, model inver-
sion can still occur if attackers apply adversarial training [10] (also
called data enhancement) to build SDecâ€² : Ë†Z âˆ’â†’ X. Suppose an
attacker (user ğ‘–) aims to execute a reconstruction attack. In the data
sharing phase, the attacker first trains SDec on its local data ğ‘‹ğ‘– by
optimizing Equation (8). Then it transforms ğ‘‹ğ‘– into representations
ğ‘ğ‘– and adding adversarial noise to them as Equation (9) shows.
After that, the attacker can train SDecâ€² on {( Ë†ğ‘ğ‘–, ğ‘‹ğ‘– )} as:

ğœƒSDecâ€² = arg min

ğœƒSDecâ€²

1
ğ‘ğ‘–

ğ‘ğ‘–
âˆ‘ï¸

ğ‘—=1

(cid:16)
ğ‘– , SDecâ€²( Ë†ğ‘§ ğ‘—
ğ‘¥ ğ‘—
ğ‘– )

(cid:17)

.

D

(11)

To defend against model inversion attack with data enhancement,
we propose noise masking, a simple and effective method to make
participants perturb data representations in unique ways. Each
user possess a mask vector (denoted by m) with the same size as
data representations. All dimensions of m are randomly initialized
to either 0 or 1, in order to mask some dimensions of calculated
gradients and thus allow users to perturb other dimensions of
representations. The process of generating masked adversarial noise
on representation ğ‘§ is expressed as:

Ë†ğ‘§ (ğ‘¡ +1) = Ë†ğ‘§ (ğ‘¡ ) +

ğ‘¡ = 1, . . . , ğ‘›,

ğœ–
Â· sign (cid:16)
ğ‘›
Ë†ğ‘§ (1) = ğ‘§,

(cid:16)
ğ‘¥, SDec( Ë†ğ‘§ (ğ‘¡ ) )

m Â· âˆ‡ğ‘§ D
Ë†ğ‘§ = Ë†ğ‘§ (ğ‘›+1) .

(cid:17)(cid:17)

,

(12)

The value of a vector m is held by its owner secretly, which leads
attackers to train substitute models on data representations that
are perturbed in a significant different way from representations of
target users with high probability. We discuss whether and when
the masks are effective in Section 6.1, and prove that mask vectors
with sufficiently large dimension are difficult to crack through brute
force. Therefore, ARS with noise masking can be considered safe
enough. Algorithm 1 shows the overall process of generating data
representations in ARS.

4.4 Extension
4.4.1 Attribute Exaction Attacks. In addition to reconstruction at-
tacks, user ğ‘– acting as an adversary can also train a classifier ğ¹ğ‘˜ :
Z âˆ’â†’ Ağ‘˜ on its local pairs {(ğ‘ğ‘–, ğ´ğ‘–,ğ‘˜ )}, as:

ğœƒğ¹ğ‘˜ = arg min

ğœƒğ¹ğ‘˜

1
ğ‘ğ‘–

ğ‘ğ‘–
âˆ‘ï¸

ğ‘—=1

D

(cid:16)
ğ‘ ğ‘—
ğ‘–ğ‘˜

, ğ¹ğ‘˜ (ğ‘§ ğ‘—
ğ‘– )

(cid:17)

,

(13)

where ğ‘˜ âˆˆ {1, 2, . . . , ğ‘€ } is the index of the target private attribute.
After that, the attacker can conduct attribute extraction attacks by
predicting the ğ‘˜-th private attribute from shared data representa-
tions.

The strategy to overcome the feature leakage is similar to the
above method. To preserve the ğ‘˜-th private attribute, users should
first train a classifier ğ¹ğ‘˜ locally, and then craft adversarial noise on
. Here we simply apply FGSM
ğ‘ to maximize the feature loss Lğ´ğ‘˜

Algorithm 1: ARS Data Sharing Method for User ğ‘–
Input: training samples ğ‘‹ğ‘– = {ğ‘¥ 1
Output: representations Ë†ğ‘ğ‘– = { Ë†ğ‘§1

ğ‘– , . . . , ğ‘¥ ğ‘ğ‘–
ğ‘– }
ğ‘– , . . . , Ë†ğ‘§ğ‘ğ‘–
ğ‘– }

ğ‘– , ğ‘¥ 2
ğ‘– , Ë†ğ‘§2

1 initialize Enc, ğœ–, ğ‘›, mğ‘– ;
2 ğ‘ğ‘– = {ğ‘§1
ğ‘– , ğ‘§2
3 update SDec via:

ğ‘– , . . . , ğ‘§ğ‘ğ‘–

ğ‘– }, where ğ‘§ ğ‘—

ğ‘– = Enc(ğ‘¥ ğ‘—
ğ‘– );

ğœƒSDec = arg minğœƒSDec

1
ğ‘ğ‘–

(cid:205)ğ‘ğ‘–

ğ‘—=1 D

(cid:16)
ğ‘– , SDec(ğ‘§ ğ‘—
ğ‘¥ ğ‘—
ğ‘– )

(cid:17);

5

4 for ğ‘— = 1 to ğ‘ğ‘– do
Ë†ğ‘§ ğ‘—
ğ‘– = ğ‘§ ğ‘—
ğ‘– ;
for ğ‘˜ = 1 to ğ‘› do
ğ‘– = Ë†ğ‘§ ğ‘—
Ë†ğ‘§ ğ‘—

ğ‘– + ğœ–

7

6

ğ‘› Â· sign (cid:16)

mğ‘– Â· âˆ‡ğ‘§ D

(cid:16)
ğ‘¥, SDec( Ë†ğ‘§ ğ‘—
ğ‘– )

(cid:17)(cid:17);

end

8
9 end
10 return Ë†ğ‘ğ‘– = { Ë†ğ‘§1

ğ‘– , Ë†ğ‘§2

ğ‘– , . . . , Ë†ğ‘§ğ‘ğ‘–

ğ‘– };

method as:

ğ›¿ğ´ğ‘˜ = âˆ’ğœ– Â· sign (cid:16)

âˆ‡ğ‘§ D

(cid:16)
ğ‘Ÿğ‘˜, ğ¹ğ‘˜ (Enc(ğ‘¥ ğ‘— ))

(cid:17)(cid:17)

,

(14)

where ğ›¿ğ‘˜ is the adversarial noise to preserve the ğ‘˜-th private at-
tribute. The purpose is to keep prediction results close to a certain
vector ğ‘Ÿğ‘˜ , regardless of inputs, thus lead the prediction to meaning-
less results.

Consequently, the overall adversarial noise of an arbitrary par-

ticipant ğ‘– can be calculated as:

ğ›¿ğ‘– = ğœ†0ğ›¿ğ‘… +

ğ‘€
âˆ‘ï¸

ğœ†ğ‘˜ğ›¿ğ´ğ‘˜

,

(15)

ğ‘˜=1
where (cid:205)ğ‘€
ğ‘˜=0 ğœ†ğ‘˜ = 1, so that |ğ›¿ğ‘– | â‰¤ ğœ–. Experimental results in Section
5.3 show that letting ğœ†0 = 1
2ğ‘€ (ğ‘˜ â‰¥ 1) may be a good choice
to ensure the defense against data leakage and feature leakage at
the same time.

2 , ğœ†ğ‘˜ = 1

4.4.2 Vertical Data Partitioning. In the second extension, we gen-
eralize ARS to the vertical data partitioning scenario. For simplicity,
we suppose that datasets are aligned on IDs, and each participant
owns ğ‘ samples. In the training phase, user ğ‘– trains Encğ‘– on its lo-
ğ‘– }, then calculate ğ‘§ ğ‘—
cal dataset ğ‘‹ğ‘– = {ğ‘¥ 1
ğ‘– ) and
share Ë†ğ‘§ ğ‘—
ğ‘– = ğ‘§ ğ‘—
ğ‘– . One of the users share labels ğ‘Œ = {ğ‘¦1, ğ‘¦2, . . . , ğ‘¦ğ‘ }.
Different from horizontal data partition, a common encoder is un-
used, so Encğ‘– does not need to be shared.

ğ‘– = Encğ‘– (ğ‘¥ ğ‘—

ğ‘– , . . . , ğ‘¥ ğ‘

ğ‘– +ğ›¿ ğ‘—

ğ‘– , ğ‘¥ 2

To train downstream models collaboratively, data representa-
tions shared by each users are concatenated as ğ‘¤ ğ‘— = concat( Ë†ğ‘§ ğ‘—
1,
2, . . . , Ë†ğ‘§ ğ‘—
Ë†ğ‘§ ğ‘—
ğ¾ ). Afterwards, any user ğ‘– who has sufficient computational
power is able to train model ğ¶ğ‘– on {(ğ‘Š , ğ‘Œ )} locally.

5 EXPERIMENTS
In this section, we evaluate ARS by simulating a multi-party collab-
orative learning scenario. We present the performance of ARS in
privacy preserving, as well as compare it with other joint learning
frameworks, and then study the effectiveness of our mechanism in
protecting private attributes.

6

5.1 Experiment Settings
5.1.1 Datasets. The experiments are conducted on three datasets:
MNIST [17] and CelebA [19] for horizontal data partitioning, and
Adult [4] from UCI Machine Learning Repository for vertical data
partitioning. MNIST consists of 70000 handwritten digits, the size
of each image is 28 Ã— 28. CelebA is a face dataset with more than
200K images, each with 40 binary attributes. Each image is resized
to 96 Ã— 96 Ã— 3. Adult dataset is census information, and the given
task is to determine whether a person makes over $50,000 a year
basing on 13 attributes including "age", "workclass", "education". In
our experiments, the inputs are mapped into real vectors with 133
feature columns.

Scenario. We simulate horizontal data partitioning scenarios
5.1.2
where the number of participants ğ¾ = 5 in MNIST, and ğ¾ = 3
in CelebA. Each participant is randomly assigned 10000 examples
as a local dataset. When conducting experiments on MNIST, the
common encoder Enc and each userâ€™s substitute decoder SDec are
implemented by three-layer ReLU-based fully connected neural
networks. On CelebA, Enc and SDec are implemented by four-layer
convolutional neural networks. In the data sharing phase, the itera-
tion time ğ‘› is set to 10. We suppose that attackers execute adversar-
ial training attacks (data enhancement) for two types of objectives:
to recover original samples (see Section 5.2), or to extract private
attributes (see Section 5.3). In the collaborative learning phase, the
tasks are set as training classifiers on shared data representations
{ Ë†ğ‘ğ‘– }ğ¾
ğ‘–=1. The labels are 10-dimensional one-hot codes in MNIST,
and 2-dimensional vectors corresponding to binary attributes in
CelebA.

We also present a vertical data partitioning scenario on Adult
dataset in Section 5.2.4. Each user holds 20000 aligned samples,
while the number of column vectors owned by different users is
kept as close as possible. The encoders and substitute decoders
are implemented by four-layer ReLU-based fully connected neural
networks. An adversary owning 5000 partial inputs would like to
attack the user who possess the same feature columns of samples.
All above tasks can be regarded as case studies of collaborative
learning in the real world. For example, companies can share pri-
vacy representations of photos to train face recognition models;
enterprises may cooperate with each other to draw more compre-
hensive customer personas.

5.1.3 Privacy Metrics. We consider three metrics to measure D (ğ‘¥, Â¯ğ‘¥),
which reflects the privacy leakage caused by reconstruction attacks.
According to a common practice that represents D (ğ‘¥, Â¯ğ‘¥) as ğ‘™ğ‘ norm,
we define D (ğ‘¥, Â¯ğ‘¥) as âˆ¥ğ‘¥ âˆ’ Â¯ğ‘¥ âˆ¥2. This metric is also well known as
MSE (Mean Square Error). PSNR (Peak Signal-to-Noise Ratio) and
SSIM (Structural Similarity Index) [14] reflects pixel level difference
between original and reconstructed images, and are highly consis-
tent with human perceptual capability, so they are also applicable
for evaluating privacy leakage. The metrics are widely adopted in
related researches, which allows us to compare their results with
ours directly. To measure the privacy of private attributes, we sim-
ulate attacks on these attributes and record the proportion that the
predictions are equal to the fixed vector.

7

(a) MNIST, Accuray

(b) MNIST, MSE

(c) CelebA, Accuray

(d) CelebA, MSE

Figure 4: Classification accuracy and reconstruction loss ver-
sus ğœ–.

(a)

(b)

(c)

Figure 5: Digit images and corresponding reconstructed im-
ages. (a) Original input images. (b) Reconstructed images cor-
responding to data representations without noise. (c) Recon-
structed images corresponding to representations with ad-
versarial noise (ğœ– = 50).

5.2 Protecting Privacy Against Reconstruction

Attacks

5.2.1 Defense Intensity. We firstly evaluate the utility and privacy
of ARS with different defense intensity ğœ–. Figure 4 reports the ac-
curacy of the classifier trained on shared data representations to
evaluate the utility, and MSE of reconstructed images to evaluate
privacy. Experiments are conducted on both MNIST and CelebA
datasets. On CelebA, the task is to predict the attribute "Male". We
set up another method as a baseline, which generates random noise
with uniform distribution instead of adversarial noise. Observe
that with the increase of ğœ–, the reconstruction loss becomes higher,
which indicates that adversarial noise with a larger scale makes it
more difficult to filch private information from shared representa-
tions. When measuring the utility of shard data, we find that when
ğœ– becomes larger, the accuracy decreases slightly from 97.2% to
89.3% in MNIST, and from 93.7% to 84.3% in CelebA. The variety of

(a) Original Images

(b) ğœ– = 0

(c) ğœ– = 25

(d) ğœ– = 50, no mask

(e) ğœ– = 50

(f) ğœ– = 100

Figure 6: Face images and corresponding reconstructed images. Images in column (a) are raw data. Column (b), (c), (e), (f)
corresponds to adversarial latent representations with different ğœ–. Column (d) corresponds to adversarial representations (ğœ– =
50) without noise masking.

MSE and accuracy with the scale of noise illustrates the trade-off
between utility and privacy of shared data.

5.2.2 Visualization of Reconstructed Images. We then explore the
effectiveness of adversarial noise defense by displaying the im-
ages under reconstruction attacks. Figure 5 compares digit images
recovered from adversarial latent representations with the unde-
fended version, and illustrates that ğœ– = 50 can well ensure data
privacy. This preliminarily proves the privacy of the adversarial
noise mechanism.

We further study the influence of different ğœ– in CelebA. Figure 6
shows the reconstructed images corresponding to data representa-
tions adding several kinds of noise. If adversarial noise is not used,
the reconstructed image restores almost all private information of
faces. When ğœ– is set to 50, the recovered faces lose most of the fea-
tures used to determine identity. When ğœ– = 100, the reconstructed
images become completely unrecognizable. For further discussion,
we present the result when ğœ– = 50, while the adversarial noise is
not masked. As shown in the column (d) of Figure 6, the faces do get
blurry, but some features with private information are still retained.
The experiments present satisfactory performance of adversarial
noise on latent representations. If defense intensity is set to a suffi-
ciently small value, the shared data can maintain high utility and
privacy. In a real application, data utility is expected to be as higher
as possible while privacy is well preserved. We choose ğœ– = 50 as
a suitable defense intensity in both datasets in the following ex-
periments, because of its high privacy and acceptable classification
accuracy, which is 92.8% in MNIST, and 88.3% in CelebA.

5.2.3 Comparison with Existing Mechanisms. We first evaluate data
utility by comparing ARS with mainstream joint learning frame-
works on MNIST. Table 1 summarizes the performance of these

8

methods in terms of important metrics such as classification ac-
curacy and communication cost. SecureML [21] is a two-party
computation (2PC) collaborative learning protocol based on secret
sharing and garbled circuits. Differential private federated learning
[8] (which we call DPFL) approximates the aggregation results with
a randomized mechanism to protect datasets against differential
attacks. As shown in the table, the classification accuracy of ARS
reaches a level similar to that of MPC and FL based methods, when
we regard ğœ– = 50 as a compromise between utility and privacy.
Note that ARS is designed for general scenarios rather than specific
datasets or tasks, and better results can be achieved by using more
complex models or fine tuning hyper-parameters. Moreover, ARS
has a low communication cost. We denote by ğ‘ the average number
of training samples owned by each party, by ğ‘‘ the dimension of
the original data, by ğµ the batch size, by ğ‘¡ the number of epochs to
train models, by ğ‘Š the number of parameters in a model, and by â„
the dimension of latent representations. Since the iteration times to
train a deep learning model using stochastic gradient descent (SGD)
method depends on the number of training samples, otherwise the
model will be underfitted, the complexity of ğ¸ should not be lower
than ğ‘ , it is easy to prove that ARS has the lowest communication
complexity among the three methods.

We next evaluate the privacy of ARS by simulating reconstruc-
tion attacks. Since PSNR and SSIM are widely adopted by the lat-
est researches in this field, we also calculate these two metrics as
privacy leakage, and compare ARS with two state-of-the-art data
sharing mechanisms: generative adversarial training based sharing
mechanism [30] and SCA based sharing mechanism [6]. Similar to
ARS, both of them learn representations of data. The experiment
is conducted on CelebA. Table 2 reports the privacy leakage of the
mechanisms. As we can see, ARS performs better than the other two

Table 1: Comparison of ARS and mainstream methods on important metrics.

Framework

Basic Method

Reported Accuracy on MNIST Communication Cost per Server

SecureML

MPC

DPFL

ARS

Federated Learning

Representation Learning

93.4%

â‰¤ 92% (ğ¾ â‰¤ 1000)
92.8% (ğœ– = 50)

âª° ğ‘‚ (ğ‘ Â· ğ¾ Â· ğ‘‘ + (ğµ + ğ‘‘) Â· ğ‘¡)
ğ‘‚ (ğ¾ Â· ğ‘Š Â· ğ‘¡)
ğ‘¶ (ğ‘µ Â· ğ‘² Â· ğ’‰)

frameworks in PSNR, even when ğœ– = 50. When ğœ– increases to 100,
SSIM of ARS also reaches the best result of the three mechanisms.

Table 2: Privacy of different representation based mecha-
nisms.

ARS

ARS

Baseline

(ğœ– = 50)

(ğœ– = 100)

(ğœ– = 50)

[30]

[6]

PSNR

SSIM

9.932
0.531

5.748

0.101

15.527

15.445

12.31

0.728

0.300

0.25

5.2.4 Vertical Data Partitioning. We next evaluate the performance
of ARS on Adult dataset under the vertical data partitioning scenario.
In Table 3, we divide the totally 133 feature columns of samples as
evenly as possible among three users, then present the prediction
accuracy (Acc), ğ¹1-score, and robustness to reconstruction attacks
of the collaborative learning system with different numbers of
participants. To confirm the effectiveness of the inversion attack,
we show the accuracy of adversarial training based reconstruction
from data representations without adversarial noise (Adv. Tr.). Here
we suppose that encoders used to generate data representations
can be obtained by adversaries. To estimate the privacy of ARS, we
present the reconstruction accuracy on concatenated adversarial
latent representations (Rec. Acc). We observe that large number
of collaborating users leads to higher prediction accuracy and ğ¹1-
score of the downstream classification model, and when the noise
scales up, the reconstruction accuracy drops to less than 50%. So we
demonstrate the great utility and privacy of ARS under the vertical
data partitioning scenario.

5.3 Preserving Privacy of Attributes
In this section, we evaluate ARS on a stronger assumption that
users have some private attributes to protect. We assess the ef-
fectiveness of defense against attribute extraction attacks by how
close the extracted features are to a fixed vector given by users.
The experiments are conducted on CelebA. For all participants, we
set predicting attribute "High Cheekbones" as the collaborative
learning task, while selecting "Male" and "Smiling" as private at-
tributes. Then we let each user train attribute extraction network
ğ¹ğ‘˜ corresponding to the ğ‘˜-th private attribute, which is similar to
the adv-training decoder attack. We choose some typical values of
ğœ† to generate adversarial noise, and set the fixed vector ğ‘Ÿ = (1, 0)
since the outputs of classifiers are two-dimensional vectors. Then
we record the proportion that the predicted private attribute ğ¹ğ‘˜ ( Ë†ğ‘§)

(a) ğœ†ğ· = 1, ğœ†1 = ğœ†2 = 0

(b) ğœ†ğ· = 0.5, ğœ†1 = ğœ†2 = 0.25

(c) ğœ†ğ· = ğœ†1 = ğœ†2 = 0.33

(d) ğœ†ğ· = 0, ğœ†1 = ğœ†2 = 0.5

(e) ğœ†ğ· = 0, ğœ†1 = 1, ğœ†2 = 0

(f) ğœ†ğ· = ğœ†1 = 0.5, ğœ†2 = 0

Figure 7: Proportion that the predictions of private at-
tributes are equal to a given fixed vector.

is equal to ğ‘Ÿ to estimate the ability of ARS to mislead attribute
extraction models.

We analyze the effect of different compositions of adversarial
noise by changing ğœ† as illustrated in Figure 7. (a-d) show that with
the increase of ğœ†ğ‘˜ , the probability that predictions of the ğ‘˜-th at-
tribute are equal to ğ‘Ÿ becomes higher. Note that sometimes the
equating rate gets lower when ğœ– increases to 100, this may be
caused by influence of the other components of adversarial noise.
(e-f) demonstrate that the weight of a noise ğ›¿ğ‘˜ has a great effect
on the privacy of the ğ‘˜-th attribute. Our further experiment shows
that the accuracy of attack classifiers can be close to 50% when
ğœ– = 50.

We further show that the accuracy of classifiers for preserved
attributes is close to 50%. Figure 8 presents the accuracy of classifiers

9

Table 3: Results with different numbers of data owners on the vertical data partitioning scenario.

ğœ–

0

10

25

50

Acc

78.9%

78.9%

78.5%

78.5%

K=1

K=2

K=3

ğ¹1-score Adv. Tr. Rec. Acc
97.4%
87.2%

97.3%

87.1%

86.8%

86.9%

97.2%

96.7%

92.8%

77.5%

45.4%

32.6%

Acc

82.2%

81.6%

81.2%

81.5%

ğ¹1-score Adv. Tr. Rec. Acc
97.6%
88.7%

97.3%

88.1%

87.7%

88.2%

97.4%

93.4%

91.7%

82.8%

61.3%

46.2%

Acc

84.6%

83.8%

83.6%

83.5%

ğ¹1-score Adv. Tr. Rec. Acc
97.7%
89.9%

97.5%

89.3%

89.5%

89.6%

97.2%

96.7%

93.6%

84.7%

55.9%

36.1%

for three attributes, two of which are private. With the increase of
ğœ†ğ‘˜ , the accuracy corresponding to the ğ‘˜-th attribute approaches
50% if ğœ†ğ‘˜ > 0. In addition, when ğœ– is set to 100, the classification
accuracy of the second private attribute "Smiling" has a significant
drop even if ğœ†2 = 0, this again proves the trade-off between utility
and privacy of shared data.In summary, ARS is shown to be effective
against attribute extraction attacks with acceptable privacy budget
ğœ–.

Table 4: PSNR of different composition of noise and ğœ–.

(ğœ†ğ·, ğœ†1, ğœ†2)

ğœ– = 0

ğœ– = 25

ğœ– = 50

ğœ– = 75

ğœ– = 100

(1.0, 0.0, 0.0)
(0.5, 0.25, 0.25)
(0.33, 0.33, 0.33)
(0.0, 0.5, 0.5)

22.617

15.274

22.492

18.363

22.497

19.408

8.812

12.033
14.473

7.456

10.261

6.720

9.522

11.976

10.671

22.482

20.827

19.109

15.004

13.179

(a) ğœ†ğ· = 1, ğœ†1 = ğœ†2 = 0

(b) ğœ†ğ· = 0.5, ğœ†1 = ğœ†2 = 0.25

(c) ğœ†ğ· = ğœ†1 = ğœ†2 = 0.33

(d) ğœ†ğ· = 0, ğœ†1 = ğœ†2 = 0.5

(e) ğœ†ğ· = 0, ğœ†1 = 1, ğœ†2 = 0

(f) ğœ†ğ· = 0.5, ğœ†1 = 0.5, ğœ†2 = 0

Figure 8: Classification accuracy on three attributes, with
variable value of ğœ– and ğœ†. "Male" and "Smiling" are private
attributes.

We next evaluate the reconstruction error under the same sce-
nario. As we can see in Table 4, larger ğœ– and ğœ†ğ· lead to greater de-
fense against reconstruction attacks. If we consider ğ‘ƒğ‘†ğ‘ ğ‘… = 12.033

10

an acceptable privacy leakage since it is smaller than the results
of similar representation sharing works [30] and [6] we compared
in Section 5.2.3, then ğœ†ğ· = 1
2 , ğœ†ğ‘˜ = 1
2ğ‘€ is a good choice to defend
against reconstruction and attribute extraction attacks at the same
time.

5.4 Task-Independence Study
Another advantage of ARS mechanism is that the encoder publish-
ing phase is independent of the collaborative learning phase. Most
of the up-to-date joint learning frameworks are task-oriented. For
example, in the FederatedAveraging algorithm, a server builds a
global model according to a specific task, and communicate the
parameters with clients. For prior data sharing frameworks, the net-
works to extract latent representations of data are usually trained
with the task-oriented models (such as classifiers). The accuracy
of models trained from these representations is regarded as a part
of optimization objective functions of feature extracting networks.
Task-dependence causes low data utilization. If parties in an existing
collaborative learning framework have a new deep learning task,
they have to build another framework and train feature extracting
networks once again, which results in a heavy cost to transform
data and train deep learning models.

In the ARS mechanism, apart from private attributes that are
protected, the representation generating process is independent of
deep learning tasks. We set up a series of experiments on CelebA
to demonstrate this property. We select five of the forty attributes
in CelebA and set a binary classification for each attribute, none
of them are private to users. In the collaborative learning phase,
participants train five classification networks on the latent repre-
sentations. Each classifier corresponding to an attribute. Since the
MSE loss is only related to the encoder, but not to deep learning
tasks, we only focus on classification accuracy. Table 5 shows the
results with various scale of noise.

Table 5: Classification accuracy in different tasks. For each
of the five attributes from CelebA dataset, we train classi-
fiers to predict whether the label is positive or negative from
Ë†ğ‘§ generated by the same public encoder.

For any ğ‘›-dimensional mask vectors m1 and m2, we denote the
Hamming distance between them as ğ» (m1, m2), and define the
ğ‘›âˆ’ğ» (m1,m2)
overlapping rate between m1 and m2 as ğ‘œ (m1, m2) =
.
ğ‘›
Then we have

Attribute

ğœ– = 0

ğœ– = 25

ğœ– = 50

ğœ– = 75

ğœ– = 100

Heavy Makeup

86.4% 85.7%

High Cheekbones

80.6% 84.2%

Male

Smiling

91.7% 91.7%

88.0% 84.7%

Wearing Lipstick

90.2% 80.6%

85.0%

80.1%

90.0%

87.9%

86.7%

87.5%

82.8%

89.3%

87.5%

85.0%

85.9%

82.1%

88.3%

84.3%

82.8%

As shown in the results, classification accuracy is higher than
73%, which indicates acceptable correctness. Only the accuracy
of predicting the attribute "Mouth Slightly Open" is lower than
80% with the increase of ğœ–. The results demonstrate that ARS is
task-independent. If there are demands for data sharing, the ini-
tiator can just train the public autoencoder, without considering
how data representations would be used. For participants, the only
remarkable thing is to determine their private attributes, and gen-
erate adversarial noise to preserve these attributes. This property
prevents the utility of latent representations from being limited
to specific tasks, and ensures the robustness of shared data. Rep-
resentations generated by users independently can achieve good
performance in various tasks if the value of hyper-parameter ğœ–
is chosen well. Consequently, ARS can preserve privacy during
the data sharing process, while maintaining the utility of data in
collaborative learning.

6 DISCUSSION
6.1 Discussions on Noise Masking
We focus on the security of noise masking mechanism by studying
whether it can defend against brute-force searching attacks. An at-
tacker can randomly enumerate several mask vectors, train inverse
models on representations with these mask vectors respectively
and take the vector that performs best in reconstructing othersâ€™
data as a good approximation of the victimâ€™s mask. We explore ex-
perimentally the relationship between the reconstruction loss Lğ‘…
and the overlapping rate of masks held by attackers and defenders,
which equals to the Hamming distance of the mask vectors divided
by their dimension. The experiment is conducted on MNIST, with
settings stated in Section 5. As Table 6 illustrates, a higher over-
lapping rate leads to a higher risk of privacy leakage. So weâ€™ll next
study the overlapping of masks.

Table 6: Reconstruction loss with various overlapping rate
of masks held by attackers and defenders.

Overlapping Rate

0%

25%

50%

75%

100%

ğœ– = 50
ğœ– = 100

0.119

0.101

0.082

0.048

0.021

0.179

0.156

0.128

0.09

0.025

11

P [ğ‘› âˆ’ ğ» (m1, m2) = ğ‘–] =

1
2ğ‘›

(cid:19)

,

(cid:18)ğ‘›
ğ‘–

(16)

which means that ğ‘‹ = ğ‘› âˆ’ ğ» (m1, m2) âˆ¼ ğµ(ğ‘›, 0.5).

Suppose ğ‘¡ is a real number such that 1

2 < ğ‘¡ â‰¤ 1, then from the
De Moivre-Laplace theorem, the probability that m1 and m2 have
ğ‘¡ Â· ğ‘› bits different is:

lim
ğ‘›â†’âˆ
= lim
ğ‘›â†’âˆ

P [ğ‘œ (m1, m2) â‰¥ ğ‘¡]
P [ğ‘¡ğ‘› â‰¤ ğ‘› âˆ’ ğ» (m1, m2) â‰¤ ğ‘›]

(cid:34)

(2ğ‘¡ âˆ’ 1)

âˆš

ğ‘› â‰¤

= lim
ğ‘›â†’âˆ

P

ğ‘‹ âˆ’ 1
2ğ‘›
âˆš
1
ğ‘›
2

(cid:35)

âˆš
ğ‘›

â‰¤

(17)

âˆš

ğ‘›

âˆ«

eâˆ’ ğ‘¥ 2

2 dğ‘¥

âˆš

âˆš

(2ğ‘¡ âˆ’1)
ğ‘›
ğ‘›) âˆ’ Î¦((2ğ‘¡ âˆ’ 1)

âˆš

ğ‘›)

= lim
ğ‘›â†’âˆ

1
2ğœ‹

= lim
ğ‘›â†’âˆ

Î¦(

= 0.

Therefore, if the dimension ğ‘› is large enough, the probability
that the overlapping rate of two random ğ‘›-dimensional vectors is
larger than ğ‘¡ approaches to 0 for âˆ€ 1
2 < ğ‘¡ â‰¤ 1. Moreover, we consider
ğœ– = 50 as an acceptable privacy budget for preserving information
of data. That is to say, an attack is considered successful if the
overlapping rate of masks held by the attacker and user should
be greater than a real number ğ‘¡, where 1
2 < ğ‘¡ â‰¤ 1. When the
dimension of latent representations is large enough, the privacy
of usersâ€™ data can be guaranteed. For example, the dimension of
latent representations is 256. If we accept 75% as overlapping rate,
then we have P [ğ‘œ (m1, m2) â‰¥ 0.75] â‰¤ 2.449 Ã— 10âˆ’16, which means
that the privacy of data can be considered well preserved by mask
mechanism.

6.2 Future Work
Although ARS shows good performance in our given scenarios, this
mechanism still has some limitations. In the horizontal data parti-
tioning scenario, all users generate data representations through
the same feature extraction network, which is called the common
encoder. This requires the selected initiator to have a sufficient
amount of representative data. In practice, however, participants in
joint learning may lack enough training samples, or the data of each
user may not be independent and identically distributed (non-IID)
[15]. This leads the common encoder to be overfitted, so that it will
no longer be valid for all users. To cope with this problem, we tried
to let the parties train their own encoders on the local datasets,
while ensuring that the latent representations have the same dis-
tribution. For example, each user applies variational autoencoder
(VAE) [16] to constrain data representations to the standard nor-
mal distribution. Nevertheless, it is difficult to guarantee that the
same dimension of representations generated by different encoders
expresses the same semantic. Therefore, aggregation of the shared
data representations will no longer make sense.

In this study, we relax the hypothesis of the data owners, re-
quiring at least one party has sufficient training samples, and the
samples of each participant have identical distribution. This assump-
tion in accordance with the realistic B2C (business to customer)
settings, where the initiator can be an enterprise with a certain
accumulation of data. It can initiate data sharing with individual
users and provide pre-trained feature extraction models to them.
Future work will be dedicated to collaborative learning on non-IID
data, and we believe domain adaptation of data representations is a
viable solution to this problem.

We also introduce task-independence of the shared data, and how
this property can help to reduce communication cost. In this work,
data representations are extracted by unsupervised autoencoders
to avoid task-orientation, yet some prior knowledge such as the
available labels of data is underutilized. A possible area of future
work is multi-task learning [33], where the given tasks or training
labels can be made full use of and contribute to each clientâ€™s different
local problems. Related studies may bring higher utility of data to
task-independent collaborative learning.

7 CONCLUSION
In this work, we propose ARS, a privacy-preserving collaborative
learning framework. Users share representations of data to train
downstream models. Adversarial noise is used to protect shared
data from model inversion attacks. We evaluate our mechanism
and demonstrate that adding masked adversarial noise on latent
representations has a great effect in defending against reconstruc-
tion and attribute extraction attacks, while maintaining almost the
same utility as MPC and FL based training. Compared with some
prior data sharing mechanisms, ARS outperforms them in privacy
preservation. Besides, ARS is task-independent, and requires no
centralized control. Our work can be applied to collaborative learn-
ing scenarios, and provides a new idea on the research of data
sharing and joint learning frameworks.

REFERENCES
[1] Nitin Agrawal, Ali Shahin Shamsabadi, Matt J Kusner, and AdriÃ  GascÃ³n. 2019.
QUOTIENT: two-party secure neural network training and prediction. In Pro-
ceedings of the 2019 ACM SIGSAC Conference on Computer and Communications
Security. 1231â€“1247.

[2] Yoshua Bengio, Aaron Courville, and Pascal Vincent. 2013. Representation
learning: A review and new perspectives. IEEE transactions on pattern analysis
and machine intelligence 35, 8 (2013), 1798â€“1828.

[3] Kenneth Ward Church. 2017. Word2Vec. Natural Language Engineering 23, 1

(2017), 155â€“162.

[4] Dheeru Dua and Casey Graff. 2017. UCI Machine Learning Repository. http:

//archive.ics.uci.edu/ml

[5] Dumitru Erhan, Aaron Courville, Yoshua Bengio, and Pascal Vincent. 2010. Why
does unsupervised pre-training help deep learning?. In Proceedings of the thir-
teenth international conference on artificial intelligence and statistics. JMLR Work-
shop and Conference Proceedings, 201â€“208.

[6] Sohrab Ferdowsi, Behrooz Razeghi, Taras Holotyak, Flavio P. Calmon, and Slava
Voloshynovskiy. 2020. Privacy-Preserving Image Sharing via Sparsifying Layers
on Convolutional Groups. ICASSP (2020).

[7] Craig Gentry. 2009. Fully homomorphic encryption using ideal lattices. In Proceed-
ings of the forty-first annual ACM symposium on Theory of computing. 169â€“178.
[8] Robin C. Geyer, Tassilo J. Klein, and Moin Nabi. 2017. Differentially Private
Federated Learning: A Client Level Perspective. arXiv preprint arXiv:1712.07557
(2017).

[9] Ian Goodfellow, Yoshua Bengio, and Aaron Courville. 2016. Deep learning. MIT

press.

[10] Ian Goodfellow, Jonathon Shlens, and Christian Szegedy. 2015. Explaining and

harnessing adversarial examples. ICLR (2015).

12

[11] Andrew Hard, Kanishka Rao, Rajiv Mathews, Swaroop Ramaswamy, FranÃ§oise
Beaufays, Sean Augenstein, Hubert Eichner, ChloÃ© Kiddon, and Daniel Ram-
age. 2018. Federated learning for mobile keyboard prediction. arXiv preprint
arXiv:1811.03604 (2018).

[12] Zecheng He, Tianwei Zhang, and Ruby B Lee. 2019. Model inversion attacks
against collaborative inference. In Proceedings of the 35th Annual Computer Secu-
rity Applications Conference. 148â€“162.

[13] Briland Hitaj, Giuseppe Ateniese, and Fernando Perez-Cruz. 2017. Deep Models
Under the GAN: Information Leakage from Collaborative Deep Learning. In
Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications
Security. 603â€“618.

[14] Alain Hore and Djemel Ziou. 2010. Image quality metrics: PSNR vs. SSIM. In
2010 20th international conference on pattern recognition. IEEE, 2366â€“2369.
[15] Peter Kairouz, H Brendan McMahan, Brendan Avent, AurÃ©lien Bellet, Mehdi Ben-
nis, Arjun Nitin Bhagoji, Kallista Bonawitz, Zachary Charles, Graham Cormode,
Rachel Cummings, et al. 2021. Advances and open problems in federated learning.
Foundations and TrendsÂ® in Machine Learning 14, 1â€“2 (2021), 1â€“210.

[16] Diederik P Kingma and Max Welling. 2013. Auto-encoding variational bayes.

arXiv preprint arXiv:1312.6114 (2013).

[17] Yann LeCun. 1998. The mnist database of handwritten digits. http://yann.lecun.

com/exdb/mnist/.

[18] Yanpei Liu, Xinyun Chen, Chang Liu, and Dawn Song. 2017. Delving into Trans-
ferable Adversarial Examples and Black-box Attacks. In ICLR 2017 : International
Conference on Learning Representations 2017.

[19] Ziwei Liu, Ping Luo, Xiaogang Wang, and Xiaoou Tang. 2014. Deep Learning
Face Attributes in the Wild. 2015 IEEE International Conference on Computer
Vision (ICCV) (2014), 3730â€“3738.

[20] Aravindh Mahendran and Andrea Vedaldi. 2015. Understanding deep image rep-
resentations by inverting them. In Proceedings of the IEEE conference on computer
vision and pattern recognition. 5188â€“5196.

[21] Payman Mohassel and Yupeng Zhang. 2017. Secureml: A system for scalable
privacy-preserving machine learning. In 2017 IEEE Symposium on Security and
Privacy (SP). IEEE, 19â€“38.

[22] Andrew Ng et al. 2011. Sparse autoencoder. CS294A Lecture notes 72, 2011 (2011),

1â€“19.

[23] Olga Ohrimenko, Felix Schuster, CÃ©dric Fournet, Aastha Mehta, Sebastian
Nowozin, Kapil Vaswani, and Manuel Costa. 2016. Oblivious multi-party machine
learning on trusted processors. In 25th {USENIX} Security Symposium ({USENIX}
Security 16). 619â€“636.

[24] Pascal Paillier. 1999. Public-key cryptosystems based on composite degree resid-
uosity classes. In International Conference on the Theory and Applications of
Cryptographic Techniques. Springer, 223â€“238.

[25] Nicolas Papernot, Patrick McDaniel, Ian Goodfellow, Somesh Jha, Z Berkay
Celik, and Ananthram Swami. 2017. Practical black-box attacks against machine
learning. In Proceedings of the 2017 ACM on Asia conference on computer and
communications security. ACM, 506â€“519.

[26] Tim Salimans, Ian Goodfellow, Wojciech Zaremba, Vicki Cheung, Alec Radford,
and Xi Chen. 2016. Improved techniques for training gans. In Advances in neural
information processing systems. 2234â€“2242.

[27] Pouya Samangouei, Maya Kabkab, and Rama Chellappa. 2018. Defense-GAN:
Protecting Classifiers Against Adversarial Attacks Using Generative Models. In
ICLR 2018 : International Conference on Learning Representations 2018.

[28] Mahmood Sharif, Sruti Bhagavatula, Lujo Bauer, and Michael K. Reiter. 2016.
Accessorize to a Crime: Real and Stealthy Attacks on State-of-the-Art Face Recog-
nition. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and
Communications Security. 1528â€“1540.

[29] Reza Shokri and Vitaly Shmatikov. 2015. Privacy-preserving deep learning. In
Proceedings of the 22nd ACM SIGSAC conference on computer and communications
security. ACM, 1310â€“1321.

[30] Taihong Xiao, Yi-Hsuan Tsai, Kihyuk Sohn, Manmohan Chandraker, and Ming-
Hsuan Yang. 2020. Adversarial Learning of Privacy-Preserving and Task-Oriented
Representations. AAAI (2020).

[31] Qiang Yang, Yang Liu, Tianjian Chen, and Yongxin Tong. 2019. Federated machine
learning: Concept and applications. ACM Transactions on Intelligent Systems and
Technology (TIST) 10, 2 (2019), 1â€“19.

[32] Andrew Chi-Chih Yao. 1986. How to generate and exchange secrets. In 27th
Annual Symposium on Foundations of Computer Science (sfcs 1986). IEEE, 162â€“167.
[33] Yu Zhang and Qiang Yang. 2021. A survey on multi-task learning. IEEE Transac-

tions on Knowledge and Data Engineering (2021).

