9
1
0
2

b
e
F
3
1

]

O
R
.
s
c
[

1
v
7
0
1
5
0
.
2
0
9
1
:
v
i
X
r
a

A framework for synchronizing a team of aerial
robots in communication-limited environments∗

J.M. D´ıaz-B´a˜nez†
S. Bereg ¶

L.E. Caraballo ‡
I. Maza (cid:107)

A. Ollero ∗∗

M.A. Lopez §

November 11, 2021

Abstract

This paper addresses a synchronization problem that arises when a
team of aerial robots (ARs) need to communicate while performing as-
signed tasks in a cooperative scenario. Each robot has a limited com-
munication range and ﬂies within a previously assigned closed trajectory.
When two robots are close enough, a communication link may be es-
tablished, allowing the robots to exchange information. The goal is to
schedule the ﬂights such that the entire system can be synchronized for
maximum information exchange, that is, every pair of neighbors always
visit the feasible communication link at the same time. We propose an
algorithm for scheduling a team of robots in this scenario and propose a
robust framework in which the synchronization of a large team of robots is
assured. The approach allows us to design a fault-tolerant system that can
be used for multiple tasks such as surveillance, area exploration, search-
ing for targets in a hazardous environment, and assembly and structure
construction, to name a few.

Keywords: Cooperative system, decentralized robots, synchronization, com-

munication coordination, communication constraints.

1

Introduction

Multi-agent systems based on mobile robots are ideally suited to perform co-
operative missions in a cost-eﬃcient manner ([8, 6]). These missions include
monitoring, surveillance, structure assembly, and exploration, to name but a

∗This paper is based in part on a conference paper by the authors ([11]).
†Department of Applied Mathematics II, University of Seville, Spain.
‡Department of Applied Mathematics II, University of Seville, Spain.
§Department of Computer Science, University of Denver, USA.
¶Department of Computer Science, University of Texas at Dallas, USA.
(cid:107)Department of Systems Engineering and Automatic Control, University of Seville, Spain.
∗∗Department of Systems Engineering and Automatic Control, University of Seville, Spain.

1

 
 
 
 
 
 
few. The use of a team of mobile robots presents advantages when considering
mission execution time due to the parallelization of the tasks, fault tolerance
and reduced uncertainty due to the possibility of overlapping information com-
ing from the perception systems of diﬀerent robots. These solutions are specially
convenient for tasks which are too dangerous, or diﬃcult for humans to perform.
The coordination between two or more robots in the team is important for
team performance, to prevent collisions between robots occupying the same
space, and to maintain proximity in order to perform a task cooperatively ([20,
3, 26]). Applications scenarios include:

•

•

•

Communication between robots exploring or monitoring an area, where
the robots should be close enough in order to satisfy underlying commu-
nication range constraints.

Cooperative perception of the same target to decrease uncertainty ([17]).
Here the robots should be simultaneously in given positions and orienta-
tions to have the target in the ﬁeld of view of the sensors.

Cooperative actuation. The robots should be coordinated to perform a
task cooperatively, such as joint transportation of a load or joint assembly,
avoiding waiting times.

High level communication is required in cooperative systems that perform
a task in a decentralized manner. Also, the robustness of a cooperative sys-
tem depends on the reliable communication between the agents involved.
In
many scenarios, direct communication among all the agents can not be guaran-
teed (large workspace with respect to the communication range of the system’s
members, for instance).
In such scenarios, a cooperative task imposes com-
munication constraints in which communication links are available only when
neighboring robots reside within a small communication range ([7, 21]). This is
the situation we consider in this paper.

Consider a team of n robots which are periodically traveling along prede-
termined closed trajectories while performing an assigned task. Each of the
agents needs to communicate information about its operation to other agents,
but the communication interfaces have a limited range. Hence, when two agents
are within communication range, a communication link is established, and in-
formation is exchanged.
If two neighboring agents can exchange information
periodically, we say that they are “synchronized”. In this paper we consider
the following synchronization problem: given the path geometries of a group of
agents, schedule their movement along their trajectories so that every pair of
neighboring agents is synchronized.

The synchronization problem arises naturally in missions of surveillance or
monitoring ([18, 1]), in structure assembly while the robots are loading and plac-
ing parts in a structure ([5]), or even in the exploration process looking for parts
to be assembled as performed in the ARCAS project (http://www.arcas-project.eu),
to name but a few applications. In fact, its eventual solution may ﬁnd many
applications beyond the initial problems posed here.

2

The solution proposed in this paper ensures maximum information exchange
of a heterogeneous team of robots with limited communication range. Notice
that the synchronization problem is even more relevant in aerial robots due to:

•

•

Rotorcraft robots (i.e. helicopters or multirotor systems) have very de-
manding energy requirements that limit the ﬂight endurance. Then, hov-
ering, which is very energy demanding, waiting for other aerial robots to
communicate or to perform cooperatively a task, should be minimized by
means of synchronization.

The synchronization of ﬁxed wing aircraft imposes more strict constraints
when they should meet to interchange information due to the velocity of
these aircrafts that may lead to communication losses when using short
range communication devices.

Additionally, the short communication range between aerial robots, and un-
manned aerial vehicles in general, is interesting from the point of view of security.
In fact, this short range communication may avoid communication jamming,
which is a signiﬁcant threat in the practical application of unmanned aerial ve-
hicles ([23]). Therefore, in this paper we focus the synchronization problem in
teams of aerial robots (ARs), but the results are applicable to general multi-
robot systems.

To illustrate some of the issues arising in the synchronization problem con-
sider a situation like that shown in Figure 1 (3 robots with possible commu-
nication links between every pair of trajectories). Suppose, for simplicity, that
the three ARs are ﬂying with constant speed along trajectories with the same
length in the same direction (clockwise or counterclockwise). How do we guar-
antee that each pair of ARs is synchronized, i.e., that each pair of neighbors
arrives at the communication link at the same time? Under these conditions, it
is easy to see that the three pairs of robots can not be synchronized if the sum
of the lengths of the internal paths is less than the length of the total trajectory
of a robot.

At ﬁrst glance, one may think that the problem can be solved by adjusting
speeds in order to force all meetings at the communication links or by waiting for
a neighbor that has not arrived yet. Unfortunately, this approach is impractical
in many real scenarios when sudden changes in speed are not possible. In any
case, both accelerations and time wasted by waiting for a neighbor reduces the
performance of the system.

In next section we present previous work related to the coordination and
In Section 3 we deﬁne formally the
communication of multi-robot systems.
problem. In Section 4 we present conditions to guarantee the synchronization
in a simpliﬁed model and we describe a scheduling so that the system is syn-
chronized. Section 5 presents an algorithm to compute the described scheduling
using the previous theoretical results. A generalization of the results from the
simpliﬁed model to more realistic scenarios is presented in Section 6. Section
7 presents computational results for some cases. In Section 8 we introduce a
new concept, that of starvation, to describe a phenomenon characterized by

3

Figure 1: Simple scenario of the synchronization problem.

the permanent loss of synchronization for one or more active ARs and propose
some strategies to prevent this problem. Finally in Section 9 we present the
conclusions of our study and describe some future research.

2 Related work

As far as we know, the problem addressed in this paper has not been solved
before. In this section, we give a brief review of related papers. The distributed
and decentralized coordination of a team of aerial robots under communication
constraints has been studied in many speciﬁc cases, fundamentally in surveil-
lance and monitoring missions. [10] and [2] present strategies to monitor coop-
eratively the perimeter of a forest ﬁre using a team of small unmanned aerial
vehicles with communication constraints. In this scenario, the team of robots
operates on the ﬁre perimeter and there is a single trajectory (that can change
dynamically) for all the agents. Therefore, two robots moving in opposite di-
rections always meet, so assigning diﬀerent directions to the members of the
team and changing direction alternately in every meeting event generates the
necessary encounters between every pair of neighboring agents.

[13] present a technique to explore unknown areas using a cooperative team
of robots. The strategy is based in a data structure called Sensor-based Random
Graph (SRG) where the members of team store environment data, the robots
are constantly exploring to add new data to the SRG. When two robots meet
at a point (fortuitously) they share information and generate new collision free
motion plans to explore the potential unknown regions. Clearly, this technique
does not solve our synchronization problem due to the meetings being fortuitous.
[14] consider the problem of satisfying communication demands in a multi-
agent system where several robots cooperate on a task and a ﬁxed subset of
the agents act as mobile routers. The goal is to position the team of robotic
routers to provide communication coverage to the remaining client robots. The

4

authors present an adaptive solution to allow for dynamic environments and
variable client demands. The main diﬀerence with our problem is that we do not
require a team of router robots to provide connectivity. In our setting the global
communication is guaranteed with intermittent information exchange between
neighboring robots while they perform there subtasks.

[25] propose a strategy called X Synchronization (XS) to use autonomous,
mobile and cooperative sensor nodes in search missions. The idea is to divide
the area to be explored, a rectangle, for simplicity, into n strips, one for each
robot, and then to execute a lane based search. The communication links are
in the common borders between two consecutive strips. The data ﬂow from
the leftmost and rightmost agents to the center agent, and the decision control
ﬂow from the center to the sides of the team. This technique is interesting but,
unfortunately it can not be applied to solve the problem for general workspaces
(no strips possible) with irregular trajectories. The communication graph of
this technique is just a line and the communication link is established between
consecutive agents.

[22] present an integrated algorithm for task allocation and motion planning
that keeps the connectivity of the cooperative team of robots. The members of
the team have limited communication range but the distance between the agents
does not admit disconnections. The tasks are assigned to the robots and the
motion paths are computed under this restrictions. This strategy is not feasible
for us because in our situation we are assuming large workspaces where it is
not possible to establish a persistent communication network using as nodes the
operating agents of the system.

In previous work, the authors have implemented and applied early versions
of our algorithms for the coordination of aerial robots in some simple scenarios
for area exploration and surveillance missions ([1, 9]). In this paper, we expand
and formally present the theoretical results and algorithms that guarantee the
synchronization of a team of mobile robots with limited communication range
and show how to use our approach in a fault-tolerant cooperative system. Sim-
ulations are performed using a group of ARs to demonstrate the eﬀectiveness
of the proposed strategy.

3 Problem formulation

The ingredients of the general problem considered here are the following:

•

•

•

A team of n aerial robots need to share information while cooperating in
the execution of a task in a decentralized way.

Each vehicle Vi has a ﬁxed communication range ri and ﬂies with a con-
stant altitude and speed in a speciﬁed closed trajectory Pi. The routes
are disjoint, eliminating concerns about collisions.

A communication link (bridge) exists between the trajectories of vehicles
Vi and Vj if and only if the minimum distance between the trajectories

5

. The two vehicles may exchange
does not exceed the value min
}
information at all times when the distance between them is less than or
equal to min
{

ri, rj

ri, rj

.
}

{

•

•

•

•

We refer to the unique segment connecting two trajectories Pi and Pj with
as the communica-
length of minimum distance not exceeding min
{
tion link between the trajectories.

ri, rj

}

We say that two robots are neighbors if there exists a communication
link between them; and two neighbors are synchronized if they visit the
communication link at the same time.

A multi-robot system is synchronized if each pair of neighbors is synchro-
nized.

Given two synchronized robots Vi and Vj, the communication region of
Vi and Vj, is given by the two connected arcs Rij and Rji on Pi and Pj
respectively such that when Vi ﬂies on Rij and Vj ﬂies on Rji, the distance
. Two cases arise, depending
ri, rj
between Vi and Vj is kept within min
{
on whether the two neighbors ﬂy in opposite directions, one clockwise
(CW) and the other counter-clockwise (CCW), or in the same direction.
Figure 2a shows the latter case while Figure 2b illustrates the former.
Notice that the two cases aﬀect diﬀerently the length of the arcs Rij and
Rji. We will later see that they also impact diﬀerently the robustness of
the system.

}

•

In a synchronized system the vehicles establish communication when they
enter the corresponding communication region without stopping.

(a) One direction

(b) Two directions

Figure 2: Representation of the communication region between two robots Vi
and Vj (gray region): (a) ARs ﬂying in the same direction and (b) ARs ﬂying
in opposite directions. Notice that both ﬁgures use the same communication
range (r = min

ri, rj

{

).
}

The Synchronization Problem: Given a set of n Aerial Robots (ARs),
each performing part of a cooperative task within a closed trajectory, and ex-
changing information with a ﬁxed communication range, schedule the ﬂight tra-
jectories such that the number of synchronized AR pairs is maximized. When

6

......PiPjr|{z}......|{z}PiPjrthis number equals the number of communication links, the system is fully syn-
chronized.

First, observe that under a general model, even the synchronization between
two robots cannot be guaranteed. Consider, for example, a system consisting of
only two ARs, each ﬂying at constant speed with a very small communication
range. Then, if the ratio of the two trajectory lengths is not rational, a synchro-
nized ﬂight is not possible. Typically, the methods used in the literature achieve
synchronization by changing the speeds of the ARs by small amounts, i.e., they
allow for the possibility of one vehicle “waiting” for the other. Unfortunately,
this simple approach is only feasible for two vehicles. For a team of cooperative
ARs, a more delicate theoretical study is required.

The following questions need to be answered in order to implement an eﬃ-
cient and robust multi-robot coordinated system: (i) When can a cooperative
multi-robot system be synchronized without changing the robot speeds? and
(ii) in case of a robot failure, can the schedules be slightly altered in order to
complete the global task in a new synchronized system?

This paper aims to answer the above two questions. Based on theoretical
results on a simpliﬁed model, we propose an algorithm that is eﬃcient and robust
in the face of catastrophic robot failures where the synchronization of a large
team of ARs is assured. Although the application scenario highlighted here is
the exploration of an unknown environment by a system of ARs, the proposed
concepts and methodologies can be useful in other multi-robot applications.

4 Theoretical results in a simpliﬁed model

The general methodology we are proposing is to ﬁrst obtain strong results on a
simpliﬁed, albeit not entirely practical model, and then to adapt the newly ac-
quired theoretical knowledge to more general and realistic models. Accordingly,
we discuss how to extend the approach for the simple model to others models in
Section 5 where we consider, for example, heterogeneous vehicles, non-circular
routes, etc.

Let us consider a simpliﬁed model for which the basic results can be stated.
In this simpliﬁed model all aerial robots move in equal and pairwise disjoint
circular trajectories at the same speed with the same communication range.
Let C1, C2, . . . , Cn be the pairwise disjoint unit circles representing the ﬂight
trajectories of the n robots and let r be the communication range (normalized
to be consistent with the circles of unit radius).

In the system two AR’s can potentially share information if the distance
between their corresponding trajectories is at most r (see Figure 3). In order
to model the ensuing communication constraints we deﬁne the communication
graph of the system with respect to range r as a planar graph G(r) = (V, E(r))
whose vertices are the circle centers and whose edges connect two centers if their
distance is less or equal to 2 + r (see Figure 4). We denote by (i, j) the edge
that connects the centers of the circles Ci and Cj.

7

In the analysis that follows, it will be convenient to denote the position of an
AR by the angle, measured from the positive horizontal axis, that its position
makes on the unit circle (see Figure 3). Fix an arbitrary edge (i, j) of E(r). The
link position of i with respect to j, denoted by φij, is the angle at which the AR
in Ci is closest to Cj. Clearly, if φij is deﬁned, so is φji and φji = π + φij. Then,
two neighbors i and j are synchronized if both arrive at the same time to their
link positions φij and φji, respectively. Notice that the number of synchronized
pairs is bounded by
. Because of our model assumptions, two synchronized
neighbors “meet” each other repeatedly every 2π units of travel.

E(r)
|
|

Figure 3: The simple model. Robots i and j can share information if the distance
between Ci and Cj is less or equal to r. φij (resp. φji) is the angle at which i
(resp. j) is closest to j’s trajectory (resp. i’s trajectory).

Figure 4: Representation of a set C1, C2, . . . , C9 of unit circles and the under-
lying communication graph.

Since the ARs move at constant speed, it suﬃces to know the starting posi-
tion and movement direction of an AR in order to compute its position at any
time. Thus, we can deﬁne a ﬂight schedule of a team of ARs as the set of start-
ing positions and directions of the ARs involved. If the number of synchronized
pairs in a ﬂight schedule is

, we say that the team is fully synchronized.

E(r)
|
|

8

CiCj|{z}rφjiφij124678953φ64φ46φ21φ124.1 Flying in the same direction

In this subsection we derive conditions that ensure full synchronization of the
team when all ARs are ﬂying in the same direction (CW or CCW). Without
loss of generality, we assume that the direction of ﬂight is counter-clockwise.
We want to compute the starting angles α1, α2, . . . , αn corresponding to the
vehicles V1, V2, . . . , Vn such that if (i, j)
E(r) then Vi and Vj reach φij and
φji, respectively, at the same time. The following result gives us the key to
establish suﬃcient conditions for the existence of a synchronization strategy:

∈

Lemma 1. Let G(r) = (V, E(r)) be a communication graph in the simpliﬁed
model. If (i, j)
E(r) and Vi is synchronized with Vj and Vk then
αj = αk.

E(r), (i, k)

∈

∈

Proof. Without loss of generality, assume αi = φij and αj = φji, i.e., both Vi
and Vj start at their link position, allowing them to monitor each other. We
now need to compute αk so that when Vi is at φik, Vk is at φki (see Figure 5).
Thus,

αk = φki
= (φki
= αj

−

−

φij)

(φik
φik) + φij = π + φij = φji

−

Figure 5: If Vi is synchronized with Vj and Vk then αk = αj.

Using Lemma 1 we derive the following corollary:

Corollary 2. Let G(r) = (V, E(r)) be the communication graph in the simpliﬁed
model. Cycles of odd length in G(r) cannot be synchronized.

∈

E(r) then φij

= φji and, consequently, αi

Proof. Recall that if (i, j)
= αj.
that can be syn-
Vi0 , Vi1, . . . , Vi2c , Vi0(cid:105)
Suppose that G contains an odd cycle
(cid:104)
1, . . . , α(cid:48)
chronized with starting angles α(cid:48)
2c, respectively. Since the two neigh-
bors of any vertex in the cycle must share the same starting angle (Lemma 1), it
follows that, as we move around the cycle, starting angles alternate between α(cid:48)
0
and α(cid:48)
1. This forces two neighbors (say Vi0 and Vi2c) to have the same starting
angle, a contradiction.

0, α(cid:48)

9

kijφkiφikφijφji(cid:54)
(cid:54)
Now we are ready to prove the main result for the simpliﬁed model when

the robots move in the same direction.

Theorem 3. Let G(r) = (V, E(r)) be communication graph of n robots ﬂying
in the same direction and with the same speed and communication range r. The
system can be fully synchronized if and only if G(r) is bipartite. Moreover, the
condition αi = π + αj for every (i, j)
E(r) ensures synchronization of the
team.

∈

Proof. If G(r) is not bipartite then it contains an odd cycle and by Corol-
lary 2, the team cannot be fully synchronized. If G(r) is bipartite then it is
two-colorable. After a white-black coloration of the graph we set an arbitrary
position β for all white ARs and set π + β for the black ones. Let (i, j) be any
edge of E(r). Then Vi is white and Vj is black or vice versa. Since φji = π + φij,
the starting positions of Vi and Vj are antipodal. (see Figure 6). In fact, if Vi
and Vj start in antipodal positions (αj = π + αi), and maintain the same speed
and direction, they will be occupy antipodal positions and, consequently, will
repeatedly reach the link position at the same time.

Figure 6: This Figure illustrates the start position of two synchronized neighbors
in G(r).

4.2 Flying in opposite directions

In this subsection we derive conditions that ensure full synchronization of the
team when the members of every pair of neighbors ﬂy in opposite directions.
Note that such a model can only be deployed on bipartite communication graphs.
In this case, the partition of the ARs according to direction of ﬂight (CW or
CCW) corresponds exactly to the partite sets of the bipartite communication
graph. This model is important because it will allow us to provide a certain
degree of robustness while preserving full synchronization (see subsection 4.3).
Let (i, j) be an edge in E(r) and lij be the supporting line of the edge (i, j).
We denote by βij the angle of the line lij measured from the positive horizontal
axis.

10

αiαjφijφjirirjLemma 4. Let G(r) = (V, E(r)) be the communication graph in the simpliﬁed
model. Let (i, j) be an edge in E(r) and consider the ARs Vi and Vj moving in
opposite directions. Then, Vi and Vj are synchronized iﬀ αj = 2βij

π.

αi

−

±

Proof. The angles formed by positions αj and αi with lij are equal. Let α(cid:48)
i
be the symmetrical position of αi obtained by reﬂecting αi with respect to lij.
Translating the position αj from Cj to Ci we see that αj and α(cid:48)
i are antipodal,
i.e., they diﬀer by 180◦ (see Figure 7).

α(cid:48)

i = βij
= 2βij

−

(αi
αi

−

βij)

−

To derive αj we simply add or subtract π to α(cid:48)
i.

Figure 7: The position α(cid:48)
the opposite of α(cid:48)
i.

i is the symmetric of αi respect lij. The position αj is

Theorem 5. Let G(r) = (V, E(r)) be a communication graph in the simpliﬁed
model. Suppose that G(r) is bipartite and that every pair of neighbors are sched-
uled to ﬂy in opposite directions. Then the system is fully synchronized if and
only if all even cycles

in Gr satisfy:

Vi1, Vi2, . . . , Vi2k , Vi1 (cid:105)
(cid:104)
βi4i5 +
βi2i3 + βi3i4 −

· · ·

+ βi2k

1i2k −

−

βi2ki1 = 2mπ

βi1i2 −
N.

with m

∈

Proof. Let αi1 be the starting position of Vi1 . We can use Lemma 4 to compute
π
the starting position of the remaining ARs (arbitrarily using +π instead of

−

11

αiα0iαjαjCiCjβijlijas described in the lemma):

αi2 = 2βi2i1 −
αi3 = 2βi3i2 −
αi4 = 2βi4i3 −
...
αi2k = 2βi2ki2k
αi1 = 2βi1i2k −

−

αi1 + π
2βi2i1 + αi1
2βi3i2 + 2βi2i1 −
...

αi1 + π
...
2 + . . .

2βi2k
1 −
2βi2ki2k

−

1i2k
1 + . . .

−

−

αi1 + π
2βi2i1 + αi1

−

−

(1)

From Equation 1 we obtain

2βi1i2k −

2βi2ki2k

−

1 + . . .

−

2βi2i1 = 0 (mod 2π)

4.3 Robustness

We now address the issue of robustness of the synchronized system. Imagine that
one member V of the team becomes unavailable because of failure or because
it needs to leave the system temporarily (for instance, to refuel). First, let us
consider the latter scenario. We want to minimize the detrimental eﬀect of the
departing AR on global system performance. Then, a simple strategy consists of
repeatedly “swapping with a neighbor” until V leaves the system as illustrated
in Figure 8. The best moment to make a swap with a neighbor is when the
ARs involved arrive to a link position (this is, indeed, another advantage of
a synchronized system). However, if all ARs ﬂy in the same direction, the
kinematic constraints of the aerial vehicles can prevent making a swap with a
neighbor (see Figure 9a). However, the swap is not a problem if neighbors are
ﬂying in opposite directions. In this case, the neighboring robots can interchange
their routes with a smooth maneuver (see Figure 9b). Consider now the case
of catastrophic failure, where one (or more) robots fail and can no longer move.
Under the assumption that robots which fail do not block live robots, we can
solve easily the problem while maintaining the set of trajectories. In this case,
one or more live neighbors can assume the tasks of the inoperative robots by
using the same routes. Moreover, a new robot can be inserted in the system
by using the swap strategy as explained above. In both cases, the system can
be restored by means of local changes and this ensures the robustness of the
approach.

The following theorem establishes a non-redundancy property of ARs occu-
pying the trajectory of a fallen neighbor by assuming the following conditions:
(i) All ARs require the same time to complete a tour in any trajectory, and (ii)
The time required to switch trajectories (at a link position) is negligible, which
should be possible by slightly increasing or decreasing the speed.

Theorem 6. In a synchronized system allowing swaps in case of failures, each
trajectory is occupied at most by one AR.

12

Proof. Assume, for the sake of contradiction, that there exists a trajectory Pi
occupied by two ARs j and k who entered Pi trough φji and φki, respectively.
An AR may enter a neighbor’s trajectory when it arrives to a link position and
the neighbor assigned to the trajectory is not there. Thus, j and k could not have
entered Pi at the same time because i cannot be at φij and φik simultaneously.
Suppose that k entered last, then when k arrives at φki, j is ﬂying in Pi and
has reached φik (by previous conditions). As a consequence, k does not enter
in Pi because it detects that Pi is occupied by j, a contradiction.

Figure 8: The AR 6 can leave the system swapping with 3, 4 and 5 in this order.

(a) One direction

(b) Two directions

Figure 9: Swapping by using one or two directions. The swapping paths in (b)
is smoother than in (a).

5 The synchronization algorithm

The synchronization algorithm consists of several stages, described below.

5.1 Computing the communication graph

Notice that, in the simpliﬁed model, the communication graph is actually the
intersection graph of a set of enlarged trajectories, namely, the set of disks of

13

1345678910112CiCjCiCjradius 1 + r/2 with the same trajectory centers. Therefore, the intersection
graph can be computed in linear time ([4]).

5.2 Computing the maximum bipartite subgraph

We can test the bipartiness of the communication graph in linear time. If it is
bipartite we are done, else a reasonable strategy is to use a bipartite subgraph
with the maximum number of edges. Finding the maximum bipartite subgraph
of a topological graph is an NP-complete problem ([16]). However, such a sub-
graph can be found in polynomial time when the input graph is planar ([15]).
Alternatively, there exist various approximation algorithms that can be useful
in practice (see for instance [12]).

It should be noted that the condition of planarity is not overly restrictive.
Many applications produce planar communication graphs. Indeed, robot trajec-
tories can be changed (and even shortened) to avoid double crossings. Moreover,
we can assume that robots cannot turn at sharp angles. As a consequence, the
communication range r is typically much smaller that the “width” of the curve
and no crossing occurs.

5.3

Scheduling the ﬂights with opposite directions.

Algorithm 1, shown below, preprocesses the trajectories and computes the start-
ing positions of all ARs in the team. The input values are: the list of the pairwise
disjoint unit circles (C), the communication range of the ARs (r) and the tour
time (T ), and the output values are: the list of starting positions of the ARs
(SPos), the list of the (initial) directions of movement of the ARs (dirs) and
a structure M that contains synchronization information (M [i, j] stores the re-
gion of communication between the C[i] and C[j] if it exists and it is used in
the synchronization).

Algorithm 2 runs onboard of the ARs and takes as input the list of the
disjoint unit circles (C), index of the assigned trajectory (i), the structure M
produced by Algorithm 1, the initial position (α = SPos[i]), the directions of
movement (d = dirs[i]), the performance starting time (t) and an abstract data
structure with the info about the general task an local subtasks to perform
(wPlan). The algorithm also uses auxiliary subroutines: ﬂightPlan (compute
a ﬂight plan), load (load the ﬂight plan in the navigation system), doWork
(do the abstract task), openConnections (open the interface of communication),
closeConnections (close the interface of communication), shareInfo (share stored
information with the corresponding neighbor) and getNeighborIndex (obtain
index in S of a neighbor trajectory).

14

Algorithm 1: Preprocessing to deploy ARs team

input : C, r, T
output: SP os, dirs, M

underGraph(C, r);
G
if not G is bipartite then

←

G

maxBiSubgraph(G);

if not G is synchronizable then
maxSynchSubgraph(G);

G

←

←

←
←

f irst(V (G));
v
q
queue();
q.enqueue(v);
analyzed
SP os
dirs
list[V (G)];
←
SP os[v]
0;
true;
dirs[v]
while not q is empty do

;
← {}
list[V (G)];

←

←

←

w
←
m
←
forall a
if a

q.dequeue();
G.getN eighbors(w);

m do
∈
analyzed then
(cid:54)∈
analyzed.add(a);
βw,v
←
SP os[a]
dirs[a]
q.enqueue(a);

←

←

angleOf (< w, v >);
βw,v
2
not dirs[w];

−

∗

SP os[w]

π;

−

encode(G);
M
return SP os, dirs, M ;

←

6 Generalization to non-circular trajectories and

heterogeneous robots

So far we have assumed homogeneous robots, with equal speeds and fuel capac-
ities. In this section we describe how to extend the results under a more general
and more realistic setting. Let us consider a team of n ARs with diﬀerent ca-
pabilities and performing their corresponding tasks through arbitrary disjoint
closed trajectories

Naturally, we have some control on the speeds of the ARs as they can ac-
celerate or decelerate to increase or decrease their speed. The speed can even
change on diﬀerent sections of the same trajectory. The key to generalizing
the synchronization scheme used in the simple theoretical model is to force all

P1, . . . , Pn
{

.
}

15

Algorithm 2: Onboard execution
input: C, i, M, α, d, t, wP lan

ﬂy to assigned trajectory C[i];
locate in position α;
wait until cT ime = t;
wA
C[i]
}
f P lan
load(f P lan);

← {

←

;

f lightP lan(M, wP lan, t, α, d, wA);

while not ABORT do

doW ork(wP lan, cT ime, cP os);
if entering in communication region then

openConnections();
f

f alse;

←

if within communication region then

getN eighborIndex(M, cP os);

ni
if detect a neighbor then

←

←

f
true;
shareInf o();
if C[ni]
∈
wA
←
f P lan

wA then
split(wA, C[ni]);

←

f lightP lan(M, wP lan,

cT ime, cP os, d, wA);

load(f P lan);

if coming out communication region then

closeConnections();
if not f and C[ni]

wA then

join(wA, S[ni]);

(cid:54)∈

wA
←
f P lan

←

f lightP lan(M, wP lan,

cT ime, cP os, d, wA);

load(f P lan);

members of the team to take (approximately) the same time to make a tour
of their respective trajectories. In the ideal theoretical model two neighboring
ARs reach the communication link at the same time. In a real implementation
of these strategies, however, we need to allow for some margin of error in order
to guarantee robustness. This can be accomplished by having each AR compare
its current and target locations at regular time intervals, and adjust its speed,
if necessary, in order to resynchronize. We refer to the time that an AR takes
to make a tour as the system period.

We can use the communication links to partition a trajectory Pi into sec-
j tj = T , from this

tions and assign each of them a travel time tj such that

(cid:80)

16

assignment we can compute the required speeds in each section. Once we know
the required speed for each section, it suﬃces to know the starting position and
movement direction of an AR in order to compute its position at any time.
So, the problem in the general case is: given a system period T , partition the
trajectories into sections, assign a time to each section so that the cumulative
time of all sections is T , and compute the initial position for every AR in its
trajectory such that the system is synchronized.

The construction of the communication graph is similar to the case of the
simpliﬁed model. We include a node in the communication graph for each
trajectory Pi and include an edge between two nodes if the minimum distance
between the respective trajectories is within the communication range. (Note
that we allow at most one edge between two nodes. If there are multiple pairs
of points on two trajectories whose distances are within the communication
threshold we choose the closest pair.) To compute the edges we can use known
algorithms from computational geometry (e.g., [24, 19]) to eﬃciently ﬁnd the
minimum distance between two polygons. Then, let S =
be a
set of disjoint closed trajectories assigned to a team of n ARs. Also, let G =
(V, E) be the computed communication graph on S using the communication
range ri of each AR. Borrowing notation from previous sections, we use φij
to denote the location of Pi closest to Pj, for (i, j)
E. (Note that in the
generalization φij is not an angle as in circular model, but rather a location in
the curve Pi that can be parameterized to a value in [0, 2π) if so desired).

P1, P2, . . . , Pn

∈

}

{

Let T denote the system period. If the communication graph is a tree, then
considering each trajectory as consisting of a single section, we obtain that the
speed in each trajectory Pi is constant and equal to the ratio li/T where li is
the length of Pi. Then ﬁxing arbitrary the initial position of a AR i, we can
compute the initial position of every neighbor of i as follows. Let j be a neighbor
of i and suppose i takes t units of time to reach φij from its starting position.
Thus i and j are synchronized if j takes t units of time to reach φji from its
starting position (see Figure 10). Note that the computed initial position for j
depends on its chosen direction of movement. It is easy to see that in this way
we can compute the initial positions for all ARs in the synchronized system. If
the communication graph contains cycles, this simple approach does not work
because considering each trajectory as a single section forces the ARs to use
constant speed (possibly diﬀerent from each other) 1.

Figure 11 shows a cycle in the communication graph, if we know the starting
position of 1 we can compute the starting position of 2, then of 3, and so on
until we have computed the starting position of k using the starting position of
1. But having done this, ARs 1 and k are not necessarily synchronized. We
k
describe conditions that help us determine when a cycle can be synchronized
with ARs ﬂying in the same direction or with neighbors in opposite directions.
First, we introduce notation needed for the rest of this section. Let ti (resp.
ri) be the time it takes the AR i to travel the inside (resp. outside) section of

−

1However, it easy to see that the same approach that worked for unit circles would work
here if we parameterize position to a value in [0, 2π) and allow the ARs to change its speed
to cover diﬀerent distances in physical space but equal distance in parameter space.

17

Figure 10: The dashed-dotted stroke is the section of trajectory to take to
achieve φij and φji respectively. Both should use the same amount of time (t)
to achieve the link position.

its trajectory in the cycle (see Figure 11). We use ellapsed time to describe the
location of ARs as follows: φij + t denotes the position of i obtained by moving
CCW from φij during t units of time. Analogously, φij
t denotes the position
of i obtained by moving CW from φij during t units of time.

−

Figure 11: A cycle in the communication graph.

Theorem 7. Let P1, P2, . . . , Pk be k trajectories that form a cycle in the com-
munication graph. Let T be the system period. If the ARs are ﬂying in the same
N such
direction the cycle can be synchronized if and only if there exists z
that:

∈

t1 + t2 +
r1 + r2 +

· · ·

· · ·

+ tk = zT and
z)T.
+ rk = (k

−

Proof. In the equations below we use αi to denote the starting position of AR
i in Pi. Without loss of generality, suppose that the ARs ﬂy CCW and that

18

ijφijφjittt1t2t3tk−1tkrkrk−1r1r2r3φ1kφ21φ32φk−1,k−2φk,k−1α1 = φ1k. Computing α2, α3, . . . , αk we obtain the following result:

t2

t1
t1 −

α1 = φ1k
α2 = φ21 −
α3 = φ32 −
...
...
αk = φk,k−1 −
Obviously, having that i is synchronized with i + 1 for 1
can be synchronized if and only if α1 = φ1k
we deduce that t1 + t2 +
i
that ti < T for all 1

t2 − · · · −

k, then

t1 −

−

tk−1

· · ·
≤
≤
t1 + t2 +

+ tk = zT z

∈

N, (0 < z < k)

· · ·

Since ti + ri = T then

(t1 + r1) + (t2 + r2) +

+ (tk + rk) = kT

· · ·

The diﬀerence between (3) and (2) is

r1 + r2 +

+ rk = (k

z)T.

−

· · ·

i < k then the cycle
≤
tk = φ1k, from here
t2 − · · · −
+ tk is a multiple of T because φij = φij + T . Note

t1 −

(2)

(3)

(4)

Note that k is not necessarily an even number, but in the simpliﬁed model
+ tk is a multiple of T only if k is even. This is consistent with the

t1 + t2 +
bipartition requirement.

· · ·

Let us now consider the case of neighbors ﬂying in opposite directions. In

this case, the communication graph must be bipartite.

Theorem 8. Let P1, P2, . . . , P2k be 2k trajectories that form a cycle in the
communication graph. Let T be the system period. If the neighbors are ﬂying
N
in opposite directions the cycle can be synchronized if and only if exists z
such that:

∈

t1 + r2 + t3 +
r1 + t2 + r3 +

+ t2k−1 + r2k = zT and
z)T
+ r2k−1 + t2k = (2k

· · ·

· · ·

−

Proof. In the equations we use αi to denote the starting position of AR i in its
trajectory. Without loss of generality, suppose that α1 = φ1k and that AR 1 is
ﬂying CCW. Computing α2, α3, . . . , αk we obtain the following result:

α1 = φ1k
α2 = φ21 + t1
α3 = φ32 −
...

t1 −

...

r2

α2k−1 = φ2k−1,2k−2 −

t1 −

α2k = φ2k,2k−1 + t1 + r2 +

r2 − · · · −
· · ·

r2k−2
+ r2k−2 + t2k−1

19

Obviously, having that i is synchronized with i+1 for 1
cycle can be synchronized if and only if α1 = φ1k
t1−
from here we conclude that t1 + r2 +
· · ·
2k, then
φij = φij + T . Note that ti < T for all 1

i < 2k implies that the
r2k = φ1k,
+ t2k−1 + r2k is a multiple of T because

≤
r2−· · ·−

t2k−1−

−

i

t1 + r2 +

· · ·

+ t2k−1 + r2k = zT z

Since ti + ri = T then

≤

≤

N, (0 < z < 2k)

∈

(t1 + r1) + (t2 + r2) +

+ (t2k + r2k) = 2kT

· · ·

The diﬀerence between (6) and (5) is

r1 + t2 +

+ r2k−1 + t2k = (2k

z)T.

· · ·
An analogous result is obtained if AR 1 is ﬂying CW.

−

6.1 Application to a case study

(5)

(6)

(7)

In this subsection we present an example of how to apply our strategy (using
opposite directions) to a communication graph that is neither a tree nor an odd
cycle. By decomposing the communication graph into a collection of cycles and
trees, the approach used here can be similarly adapted to other complex con-
ﬁgurations. Figure 12a shows the trajectories and the chosen edges of our case
study. Notice that we have irregular trajectories of diﬀerent lengths, so, using
the same speed for all the ARs is not possible for a fully synchronized system.
We may consider assigning diﬀerent and constant speeds for each trajectory
such that all the ARs take the same time in a tour, but this does not guar-
antee synchronization either because the communication graph has two cycles,
2, 7, 8, 5 and 2, 5, 8, 6, 4, 3. We can solve the problem by a careful application
of Theorem 8. This requires that we extend our notation to cover trajectory
sections.

We denote by t

j,l the time spent to travel in trajectory i from the link
position shared with trajectory j to the link position shared with trajectory
j,l can be
l (following the assigned direction), see the Figure 12b. Note that t
j,k ).
l,k = t
j,l + t
Applying Theorem 8 to cycle 2, 7, 8, 5 we obtain the following equations:

l,j = T where T is the period (also t

diﬀerent from t

l,j , and t

j,l + t

(i)

(i)

(i)

(i)

(i)

(i)

(i)

(i)

t

(2)

7,5 + t

(7)

(8)

8,2 + t

5,7 + t

(5)

2,8 = z1T

(2)

t

5,3 + t

(2)

3,7

+ t

(7)

2,8 +

t

(8)

7,6 + t

(8)

6,5

(cid:16)

(cid:17)
N, 0 < z1 < 4.

(cid:16)

(cid:17)

(5)

+ t

8,2 = (4

z1)T

−

with z1 ∈

From cycle 2, 5, 8, 6, 4, 3 we obtain:

t

(2)

5,3 + t

(5)

(8)

8,2 + t

6,5 + t

(6)

4,8 + t

(4)

3,6 + t

(3)

2,4 = z2T

(2)

3,7 + t

(2)

7,5

t

(cid:16)

+ t

(cid:17)

(5)

2,8 +
+t

(6)

(8)

(8)

t

7,6

5,7 + t
6,3 + t

(4)

(3)
(cid:17)
4,2

(cid:16)
8,4 + t

= (6

z2)T

−

20

(8)

(9)

(10)

(11)

(a)

(b)

Figure 12: (a) Example of a general scenario. (b) Time spent while traveling
various trajectory sections.

with z2 ∈

N, 0 < z2 < 6.

Also we have that:

(2)

(2)

(8)

(8)

t
7,5 + t
5,3 + t
7,6 + t
5,7 + t
t
t
2,4 + t
8,4 + t
t

(3)

(6)

(2)

(8)

3,7 = T
6,5 = T
4,2 = T
4,8 = T

(3)

(6)

(5)

(5)

(5)

t
2,8 + t
8,2 + t
t
3,6 + t
t

(4)

(5)

8,2 = T
2,8 = T
6,3 = T

(4)

(12)

(i)

We proceed by assigning values to each t

j,k fulﬁlling the constraints (8), (9),
(10), (11) and (12). Also, we must try to assign time values so as to keep small
diﬀerences in speed for various trajectory sections. By doing this, we reduce
the accelerations and decelerations of the ARs in the mission and keep ﬂight
behavior realistic. If we do not keep this in mind while working with a group of
heterogeneous ARs, it may happen that some time during the mission an AR
must travel a subtrajectory with a speed that can not be reached.

Using a heuristic algorithm we obtain the following feasible assignation:

(2)

t
t

7,5 = 0.40T
5,7 = 0.28T

(8)

(2)
t
5,3 = 0.18T
(8)
7,6 = 0.50T
t

(2)
t
3,7 = 0.42T
(8)
6,5 = 0.22T
t

(3)

t
t
t
t
t

(4)

(5)

4,2 = 0.40T
3,6 = 0.30T
8,2 = 0.34T
8,4 = 0.64T
2,8 = 0.34T

(7)

(6)

(3)
t
2,4 = 0.60T
(4)
6,3 = 0.70T
t
(5)
t
2,8 = 0.66T
(6)
t
4,8 = 0.36T
(7)
8,2 = 0.66T
t

After that, ﬁxing a value T such that every AR can reach the associated speed
to each subtrajectory (length of the subtrajectory/assigned time to the subtra-
jectory). Having the times (and the speeds) at each subtrajectory, setting an

21

123546782735t(2)3,7t(2)7,5t(2)5,3initial position for an AR, we can constructively compute the initial position for
every AR in the communication graph.

We implemented a simulation of an example that leads us to the commu-
nication graph of the Figure 12a, a video is available at https://www.youtube.
com/watch?v=T0V6tO80HOI illustrating all the phases of the algorithm.

7 Simulation and computational results

×

×

Consider the cooperative surveillance of an area by means of a team of small
ﬁxed wing aerial robots. The area can be divided into a grid with cells of
300m
300m. Each cell is assigned to a member of the team. The robots are
equipped with an on-board camera Panasonic DMC-GH2. The chosen focal
36.87◦. The
length of the camera is 14mm, thus the ﬁeld of view is 53.13◦
robots are programmed to ﬂy at a constant altitude of 90m (to prevent the
obstruction of commercial air traﬃc) and at a constant speed of 12m/s. From
this altitude the covered area by the camera is approximately 45m
30m and
objects are distinguishable over 0.06m (the targets to detect should be grater
300m cell we can use a back and forth closed
than 0.06m). To cover a 300m
trajectory as shown in Figure 13, note that the farthest points to the trajectory
are at a distance of 20.5m, so in these critic points we have a margin of deviation
2m. Thus, every point can be watched by the camera in
on the route of
some instant during the tour. (A˜nadir aqu´ı, si consideran necesario, algo sobre
“kinematic contraints”. En esta trayectoria todos los cambios de direcci´on est´an
sobre arcos de circunferencia de al menos 16.67m de radio como muestra la
ﬁgura, por tanto los UAV deben ser capaces de girar sobre un c´ırculo de 16.67m
de radio a 12m/s para que sea una trayectoria realmente factible)

×

×

±

The robots have very constrained communication due to security reasons.
Then, the only possibility to communicate the information is to synchronize the
robots in such a way that two robots meet in adjacent cells. The objective is to
synchronize the system in such a way that all the robots transmit the collected
information in spite of robot failures and leaving for refueling as mentioned in
Section 3. In our scenario the link position between two adjacent trajectories is
at the middle point of the common side between the corresponding cells. The
distance between two neighboring trajectories in the link position is 25m, close
enough to share information using the on-board wiﬁ equipment and suﬃciently
far to avoid collisions, see Figure 13. The proposed trajectory is symmetrical,
so an aerial robot makes the same route traveling from any link position to
the next link position. Note that a grid using these trajectories in the cells is
equivalent to a grid using circular trajectories, see Figure 14. Therefore, if a
team of UAVs is monitoring a region divided into a grid, one robot per cell, such
that every pair of neighbors is ﬂying in opposite directions at the same constant
altitude and the same constant speed using our back and forth trajectories,
then, using by Theorem 5 the system can be synchronized. The communication
region between two neighboring UAVs has a length of 100m (see Figure 13), so
ﬂying at 12m/s they have 8.33s to share information with relative speed between

22

Figure 13: Two neighboring cells and two synchronized UAVs. Using red stroke
feasible trajectories to cover the cells. The UAV in the left cell is ﬂying in
CCW direction while the UAV in the right cell is ﬂying in CW direction. The
communication region between them is shaded in gray and has a length of 100m.
The UAVs have been magniﬁed to make them look better.

them of 0m/s. The Figure 15 illustrates this scenario.

(a)

(b)

Figure 14: Equivalence between a grid using our back and forth trajectories and
a grid using circular trajectories. Note that a segment of trajectory between two
consecutive link points in (a) corresponds to a segment between two consecutive
points in (b).

The length of the proposed covering trajectories is approximately 3609.79m,
thus an UAV spent 300.82s to make a tour in its cell. Simulations were per-
formed to validate the proposed approach. We used the model with circular
trajectories and assuming that the period of an AR is 300s in order to simplify
the generation of test cases. We ran each simulation for 15 000s. We consid-
ered two measures to evaluate the performance of the system: the broadcast
time (BT), that is, the time it takes for a message issued by a robot to reach
the full team, and the abandoned time (AT), deﬁned as the interval of time in

23

3 grid region where
Figure 15: A synchronized team of UAVs patrolling a 3
×
300m. Each UAV is ﬂying in its cell over
the dimensions of the cells are 300m
a trajectory as shown in the Figure 13. They are ﬂying at the same constant
altitude of 90m with constant speed of 12m/s. The UAVs have been magniﬁed
to make them look better.

×

×

×

which a trajectory is not attended by any AR. Table 1 shows the results of the
experiments. The ﬁrst three cases correspond to communication graphs with a
grid structure of size 3
3, the following three correspond to a grid structure of
3 and The other cases correspond to graphs randomly generated. A ran-
size 5
dom graph is generated constructively, suppose that we have a connected graph
formed by m circles, to increase the graph we select a random circle c and a
random ray r from the center of c, then the new circle is placed with center on
r such that it is disjoint with the other circles and keeping the connection in
the graph. Thus, from a graph of m nodes we have constructed a graph with
m + 1 nodes. With this idea starting with one circle we can construct graphs of
any numbers of nodes. The ﬁrst column in the Table 1 shows the initial number
of ARs; the second column, the number of fallen ARs (selected randomly); the
third, the broadcast time; and the last shows the maximum abandoned times
during the simulation. All the results correspond to the average of 10 simula-
tions with the same parameters. The code of the simulation was written using
the Python language.

Table 1 shows that our method is robust. The broadcast time does not
grow signiﬁcantly even if close to 50% of the robots fail. Thus, the system is
fault-tolerant. Also, it is worth noting the importance of a large number of

24

17.97m12.50m|{z}31.25m20.23m17.82m12.50m|{z}31.25m16.67mAAAACBABGrid 3
3
×
Grid 3
3
×
Grid 3
3
×
Grid 5
3
×
Grid 5
3
×
Grid 5
3
×
Random
Random
Random
Random
Random
Random

N◦ ARs N◦ F. ARs Avg. BT(s) Max. AT(s)
0.00
157.87
277.50
0.00
260.63
607.50
0.00
327.00
777.75
0.00
285.75
869.63

348.71
394.46
482.33
543.30
595.50
658.43
786.34
812.48
1027.20
890.63
1099.16
1306.05

9
9
9
15
15
15
10
10
10
15
15
15

0
2
4
0
3
7
0
2
5
0
3
7

Table 1: Simulations results using a circular model.

communication links in the graph. In grid conﬁgurations, all the cycles meet
the hypothesis of Theorem 5 and we can use all the links in the communication
graph. However, in random graphs the probability to generate cycles fulﬁlling
such hypothesis is low. In this case, the algorithm computes the feasible maximal
subgraph losing many communication links. For random graphs, the abandoned
time measure shows a decrease in performance. Finding strategies to improve
the results gives us a promising line of research. From here the importance to
continue this research line to ﬁnd strategies to tackle these cases.

8 Starvation avoidance

In this section we introduce a new concept corresponding to a phenomenon that
may arise when one or more robots leave the system. Consider the communi-
cation graphs in Figure 16. If the white ARs fail or otherwise leave the system,
the two surviving ARs (shown in solid) fail to meet one another resulting in
a permanent loss of synchronization. We say that an AR starves if indepen-
dent of how much longer it remains in ﬂight, it permanently fails to encounter
other ARs at any communication link. If some ARs leave the system and the
remaining ARs are starving we say that the system falls into starvation.

Another example is illustrated in Figure 17. By removing the white ARs
the system falls into starvation and, if later, ARs a and b also fail, then the
trajectories P1, P2 and P3 are abandoned forever.

Let G be a (bipartite) communication graph of size n. For the sake of ro-
bustness, we are interested in preserving the following properties in the presence
of AR failures: (i) all trajectories are covered (ii) a broadcast sent from any AR
reaches all surviving ARs (i.e., there are no starving ARs).

One idea to break starvation is to abandon the deterministic policy of switch-
ing to a neighboring trajectory whenever the AR responsible for that trajectory

25

(a)

(b)

Figure 16: Examples of systems in starvation. If the white robots fail, the solid
ones permanently fail to synchronize.

is not found. Instead, the AR decides with probability p to switch to the neigh-
boring trajectory or not. Another strategy is to only allow migration on edges
of a subgraph of the communication graph, ideally one that is “resistant” to
starvation. An ideal choice is a Hamiltonian trajectory (at least when it can be
found) as starvation is not possible in this case. In other words, no ARs can
possibly starve in a chain provided there are at least two active ARs. A diﬀerent
topology with good properties is that of a spanning tree. For instance, it is easy
to see that by permanently anchoring an AR in a leaf node one can guarantee
that there are no starving ARs. In general, a graph has multiple spanning trees.
One that is easy to compute is the depth-ﬁrst-search (DFS) tree.

8.1 Testing strategies to avoid starvation

In this subsection we present some computational results to compare the afore-
mentioned strategies. The period of an AR is 80s (this is the time spent by
an UAV to make a tour in a circular trajectory of radius 150m ﬂying at a
speed of 11.78m/s) and we ran each simulation for 4 000s. We use the following
strategies:

•

•

•

alw (when an AR arrives to a link position and its neighbor is not there
then AR switches to its neighbor’s trajectory).

rand (when an AR arrives to a link position and its neighbor is not there
then AR switches trajectories with probability 1/2).

dfs (when an AR arrives to a link position and its neighbor is not there
then AR switches trajectories if this edge is in the DFS tree with root a
predeﬁned node in the graph. In the case of grids the resulting DFS from
the top-left vertex is a Hamiltonian-trajectory).

The measures to compare the strategies are the following:

26

12Figure 17: Starvation and abandoned trajectories. The system begins to move
at the drawn points.

Max. ST(s) Avg. CT Max. AT(s) Avg. BT(s)
183.16
156.80
135.46

7.44
9.44
11.11

64
224
504

115
195
175

alw
dfs
rand

Table 2: Grid 3

×

3, removing 4 ARs randomly.

•

•

•

Max. ST: maximum interval of time in which a robot is starving.

Avg. CT: average of completed tours on each trajectory, this is an
indicator of the performance in each trajectory.

Max. AT: the maximum interval of time in which a trajectory is not
attended by any AR.

Avg. BT: average of the broadcast time.

•
We start testing these strategies with grid graphs and random graphs re-
moving randomly about half of the robots. Observe that in Figures 16 and 17
this number of failures is needed in order to produce starvation.

The results are shown in Tables 2, 3 and 4. Note that we obtain the same
results using alw and dfs in the statistics of the random graphs. The reason

Max. ST(s) Avg. CT Max. AT(s) Avg. BT(s)
186.24
178.98
216.41

6.93
9.87
11.13

124
144
724

115
115
234

alw
dfs
rand

Table 3: Grid 5

×

3, removing 7 ARs randomly.

27

4abP1P2P3is that the bipartite subgraph fulﬁlling Theorem 8 is a tree, so, all the edges
of the communication graph are in the DFS-tree. In neither of these cases the
system falls into starvation (apparently, starvation is improbable when removing
ARs randomly). Also, our initial strategy (alw) obtains better results than the
others in these random cases, showing robustness (with respect to starvation)
in most cases.

(a)

(b)

Figure 18: Random graphs, the bipartite subgraphs fulﬁlling Theorem 8 are
trees.

(alw/dfs)1
rand1
(alw/dfs)2
rand2

Max. ST(s) Avg. CT Max. AT(s) Avg. BT(s)
238.36
422.18
518.20
789.82

11.10
10.10
9.35
11.45

118
1398
239
1144

224
603
535
900

Table 4: (1)-Figure 18a removing 5 ARs randomly and (2)-Figure 18b removing
10 ARs randomly.

Let us now consider other instances of starvation and discuss how the above

strategies behave in these cases.

Figures 19a and 19b show two other cases when if the white ARs leave the
system, then the team falls into starvation. Table 5 shows the behavior of the
strategies in the graphs of the Figures 16a, 16b and 19a after the white ARs
leave the system. The strategies alw and dfs have the same results because
these graph are trees. In these cases the system falls into starvation. Using the
probabilistic strategy, we obtain better results. Note that using the alw or dfs
the trajectories are visited more frequently, but the broadcast time is inﬁnity
(that is, starvation occurs).

The following tables show the results in the example graphs with cycles
(Figures 17 and 19b), and then using the dfs strategy we obtain some interesting
results. The maximum starvation time is lower in both cases when using dfs.

28

(a)

(b)

Figure 19: Starvation samples. If the white nodes are removed the system falls
into starvation.

(alw/dfs)1
rand1
(alw/dfs)2
rand2
(alw/dfs)3
rand3

Max. ST(s) Avg. CT Max. AT(s) Avg. BT(s)

4000
422
4000
535
4000
395

6.25
12.50
8.00
13.60
8.33
11.00

64
571
144
1084
65
844

∞
97.44

∞
138.76

∞
163.58

Table 5: (1)-Figure 16a, (2)-Figure 16b and (3)-Figure 19a
.

The number of completed tours is higher using dfs in the ﬁrst case (Table 6),
while rand performs better in the second case (Table 7). Finally, with respect
to broadcast time, dfs shows better performance in the second case, while rand
is a better choice for the ﬁrst case.

Summarizing, our results suggest that if we use a strategy with a high rate
of exchange between the trajectories, both the number of completed tours tends
to decrease and the abandoned time tends to decrease. This property could
be an important factor when deciding what strategy to use because in some
scenarios it could be very important that the ARs make completed tours in the
trajectories (for example in monitoring missions). Finally, it is worth noting
that obtaining higher levels of communication in the team, that is, minimizing
the broadcast time, depends on the topology of the graph as well as the selected

Max. ST(s) Avg. CT Max. AT(s) Avg. BT(s)

alw
dfs
rand

4000
155
275

0.00
10.14
8.71

24
144
384

∞
158.77
147.14

Table 6: Results corresponding to Figure 17.

29

35Max. ST(s) Avg. CT Max. AT(s) Avg. BT(s)

alw
dfs
rand

4000
235
415

0.00
9.38
13.38

24
184
564

∞
177.23
223.90

Table 7: Results corresponding to Figure 19b.

strategy to use.

9 Conclusions and Future Research

In this paper we introduce a strategy to synchronize a team of ARs and describe
an approach to reestablish synchronization in the case when some ARs leave the
system. We also introduce a new concept, that of starvation, in order to describe
a phenomenon characterized by the permanent loss of synchronization for one
or more active robots and propose various strategies to prevent it to ensure the
fault-tolerance of the system.

A solution in a simpliﬁed theoretical setting is presented ﬁrst, and then
adapted to a more realistic scenario. Our simulations suggest that this line of
research is promising. The work can be generalized to solve practical problems in
several directions, including: (i) the trajectories can overlap and share multiple
communication links that provide extra opportunities for information exchange;
(ii) instead of failure, we can consider the inability of an agent to maintain its
schedule along its trajectory; (iii) the implementation of real experiments in a
multi-UAV testbed space.

Acknowledgments

This work was initiated at the VI Spanish Workshop on Geometric Optimiza-
tion, El Roc´ıo, Huelva, Spain, held June 18-22, 2012. We thank the other
participants of that workshop –C. Cort´es, M. Fort, P. P´erez-Lantero, J. Urru-
tia, I. Ventura and R. Zuazua– for helpful discussions and contributing to a fun
and creative atmosphere.

Funding

This work has been supported by the ARCAS Project, funded by the Euro-
pean Commission under the FP7 ICT Programme (ICT-2011-287617) and the
CLEAR Project (DPI201 1-28937-C02-01), funded by the Ministerio de Ciencia
e Innovaci´on of the Spanish Government.

This project has received funding from the European Union’s
Horizon 2020 research and innovation programme under the
Marie Sk(cid:32)lodowska-Curie grant agreement No 734922.

30

References

[1] J.J. Acevedo, B. C. Arrue, J.M. D´ıaz-B´a˜nez, I. Ventura, I. Maza, and
A. Ollero. One-to-one coordination algorithm for decentralized area par-
tition in surveillance missions with a team of aerial robots. Journal of
Intelligent and Robotic Systems, 74(1-2):269–285, 2014.

[2] K Alexis, G Nikolakopoulos, A Tzes, and L Dritsas. Coordination of heli-
copter uavs for aerial forest-ﬁre surveillance. In Applications of intelligent
control to engineering systems, pages 169–193. Springer, 2009.

[3] Kostas E Bekris, Devin K Grady, Mark Moll, and Lydia E Kavraki. Safe
distributed motion coordination for second-order systems with diﬀerent
planning cycles. The International Journal of Robotics Research, 31(2):129–
150, 2012.

[4] Jon L. Bentley, Donald F. Stanat, and E.Hollins Williams Jr. The complex-
ity of ﬁnding ﬁxed-radius near neighbors. Information Processing Letters,
6(6):209 – 212, 1977.

[5] M Bernard, K Kondak, and G. Hommel. Load transportation system based
on autonomous small size helicopters. Aeronautical Journal, 114(1153):191–
198, 2010.

[6] Antonio Bicchi, Antonio Danesi, Gianluca Dini, Silvio La Porta, Lucia Pal-
lotino, Ida M Savino, and Ricardo Schiavi. Heterogeneous wireless multi-
robot systems. Robotics and Automation, IEEE Magazine on, 15(1):62–70,
2008.

[7] Wolfram Burgard, Mark Moors, Cyrill Stachniss, and Frank E Schnei-
der. Coordinated multi-robot exploration. Robotics, IEEE Transactions
on, 21(3):376–386, 2005.

[8] Y Uny Cao, Alex S Fukunaga, and Andrew Kahng. Cooperative mobile
robotics: Antecedents and directions. Autonomous robots, 4(1):7–27, 1997.

[9] L.E. Caraballo, J.J. Acevedo, J.M. D´ıaz-B´a˜nez, B.C. Arrue, I. Maza, and
A. Ollero. The block-sharing strategy for area monitoring missions using a
decentralized multi-uav system. In Unmanned Aircraft Systems (ICUAS),
2014 International Conference on, pages 602–610. IEEE, May 2014.

[10] David W Casbeer, Derek B Kingston, Randal W Beard, and Timothy W
McLain. Cooperative forest ﬁre surveillance using a team of small un-
manned air vehicles. International Journal of Systems Science, 37(6):351–
360, 2006.

[11] J.M. D´ıaz-B´a˜nez, L.E. Caraballo, Lopez M.A., Bereg S., I. Maza, and
A. Ollero. The synchronization problem for information exchange between

31

aerial robots under communication constraints. In Robotics and Automa-
tion (ICRA), 2015 International Conference on, pages 4650–4655. IEEE,
2015.

[12] David Eppstein. Arboricity and bipartite subgraph listing algorithms. Inf.

Process. Lett., 51(4):207–211, 1994.

[13] Antonio Franchi, Luigi Freda, Giuseppe Oriolo, and Marilena Vendittelli.
The sensor-based random graph method for cooperative robot exploration.
Mechatronics, IEEE/ASME Transactions on, 14(2):163–175, 2009.

[14] Stephanie Gil, Swarun Kumar, Dina Katabi, and Daniela Rus. Adap-
tive communication in multi-robot systems using directionality of signal
strength. The International Journal of Robotics Research, 34(7):946–968,
2015.

[15] F. Hadlock. Finding a maximum cut of a planar graph in polynomial time.

SIAM Journal on Computing, 4:221–225, 1975.

[16] R. Karp. Reducibility among combinatorial problems. In R. Miller and
J. Thatcher, editors, Complexity of Computer Computations, pages 85–103.
Plenum Press, 1972.

[17] Anibal Ollero and et al. Architecture and perception issues in the comets
multi-uav project. multiple eyes in the skies. Robotics and Automation,
IEEE Magazine, 12(2):46–57, 2005.

[18] Fabio Pasqualetti, Antonio Franchi, and Francesco Bullo. On cooperative
patrolling: Optimal trajectories, complexity analysis, and approximation
algorithms. Robotics, IEEE Transactions on, 28(3):592–606, 2012.

[19] S. Quinlan. Eﬃcient distance computation between non-convex objects. In
Robotics and Automation, International Conference on, pages 3324–3329.
IEEE, 1994.

[20] C. Rizzo, D. Tardioli, D. Sicignano, L. Riazuelo, J. L. Villarroel, and
L. Montano. Signal-based deployment planning for robot teams in tunnel-
like fading environments. The International Journal of Robotics Research,
32(12):1381–1397, 2013.

[21] Weihua Sheng, Qingyan Yang, Jindong Tan, and Ning Xi. Distributed
multi-robot coordination in area exploration. Robotics and Autonomous
Systems, 54(12):945–955, 2006.

[22] D. Tardioli, A.R. Mosteo, L. Riazuelo, J.L. Villarroel, and L. Montano.
Enforcing network connectivity in robot team missions. The International
Journal of Robotics Research, 29(4):460–480, 2010.

[23] Kimon P Valavanis and George J Vachtsevanos. Handbook of Unmanned

Aerial Vehicles. Springer, 2015.

32

[24] C. Wang and E.P. Chan. Finding the minimum visible vertex distance
between two non-intersecting simple polygons. In Computational Geometry,
2nd Annual Symposium on, pages 34–42. ACM, 1986.

[25] Seokhoon Yoon and Chunming Qiao. A New Search Algorithm using Au-
tonomous and Cooperative Multiple Sensor Nodes. In IEEE INFOCOM,
pages 937–945, 2007.

[26] Robert Zlot and Anthony Stentz. Market-based multirobot coordination for
complex tasks. The International Journal of Robotics Research, 25(1):73–
101, 2006.

33

