1
2
0
2

y
a
M
8
2

]

C
D
.
s
c
[

2
v
7
2
7
3
0
.
5
0
8
1
:
v
i
X
r
a

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

NICOLAS NICOLAOU, Algolysis Ltd, Limassol, Cyprus
VIVECK CADAMBE, Pennsylvania State University, US
N. PRAKASH, Intel Corp.
ANDRIA TRIGEORGI, University of Cyprus, Nicosia, Cyprus
KISHORI M. KONWAR, MURIEL MEDARD, and NANCY LYNCH, Massachusetts Institute of

Technology, USA

Emulating a shared atomic, read/write storage system is a fundamental problem in distributed computing. Replicating atomic objects

among a set of data hosts was the norm for traditional implementations (e.g., [8]) in order to guarantee the availability and accessibility

of the data despite host failures. As replication is highly storage demanding, recent approaches suggested the use of erasure-codes to

offer the same fault-tolerance while optimizing storage usage at the hosts. Initial works focused on a fix set of data hosts. To guarantee

longevity and scalability, a storage service should be able to dynamically mask hosts failures by allowing new hosts to join, and failed

host to be removed without service interruptions. This work presents the first erasure-code based atomic algorithm, called ARES, which

allows the set of hosts to be modified in the course of an execution. ARES is composed of three main components: (i) a reconfiguration

protocol, (ii) a read/write protocol, and (iii) a set of data access primitives. The design of ARES is modular and is such to accommodate

the usage of various erasure-code parameters on a per-configuration basis. We provide bounds on the latency of read/write operations,

and analyze the storage and communication costs of the ARES algorithm.

ACM Reference Format:

Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch. 2021. ARES:

Adaptive, Reconfigurable, Erasure coded, Atomic Storage . 1, 1 (May 2021), 34 pages. https://doi.org/10.1145/nnnnnnn.nnnnnnn

1 INTRODUCTION

Distributed Storage Systems (DSS) store large amounts of data in an affordable manner. Cloud vendors deploy hundreds

to thousands of commodity machines, networked together to act as a single giant storage system. Component failures

of commodity devices, and network delays are the norm, therefore, ensuring consistent data-access and availability

at the same time is challenging. Vendors often solve availability by replicating data across multiple servers. These

services use carefully constructed algorithms that ensure that these copies are consistent, especially when they can be

accessed concurrently by different operations. The problem of keeping copies consistent becomes even more challenging

This work was partially funded by the Center for Science of Information NSF Award CCF-0939370, NSF Award CCF-1461559, AFOSR Contract Number:
FA9550-14-1-0403, NSF CCF-1553248 and RPF/POST-DOC/0916/0090.
Authors‚Äô addresses: Nicolas Nicolaou, nicolas@algolysis.comAlgolysis Ltd, Limassol, Cyprus; Viveck Cadambe, vxc12@engr.psu.eduPennsylvania State
University, US; N. Prakash, prakashn@mit.eduIntel Corp.; Andria Trigeorgi, aatrige01@cs.ucy.ac.cyUniversity of Cyprus, Nicosia, Cyprus; Kishori M.
Konwar, kishori@csail.mit.edu; Muriel Medard, medard@mit.edu; Nancy Lynch, lynch@csail.mit.eduMassachusetts Institute of Technology, USA.

Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or
distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work
owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to
lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org.

¬© 2021 Association for Computing Machinery.
Manuscript submitted to ACM

Manuscript submitted to ACM

1

 
 
 
 
 
 
2Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

when failed servers need to be replaced or new servers are added, without interrupting the service. Any type of service

interruption in a heavily used DSS usually translates to immense revenue loss.

The goal of this work is to provide an algorithm for implementing strongly consistent (i.e., atomic/linearizable),

fault-tolerant distributed read/write storage, with low storage and communication footprint, and the ability to reconfigure

the set of data hosts without service interruptions.

Replication-based Atomic Storage. A long stream of work used replication of data across multiple servers to implement

atomic (linearizable) read/write objects in message-passing, asynchronous environments where servers (data hosts) may

crash fail [7, 8, 17‚Äì19, 21, 22, 34]. A notable replication-based algorithm appears in the work by Attiya, Bar-Noy and

Dolev [8] (we refer to as the ABD algorithm) which implemented non-blocking atomic read/write data storage via logical

timestamps paired with values to order read/write operations. Replication based strategies, however, incur high storage

and communication costs; for example, to store 1,000,000 objects each of size 1MB (a total size of 1TB) across a 3 server
system, the ABD algorithm replicates the objects in all the 3 servers, which blows up the worst-case storage cost to 3TB.
Additionally, every write or read operation may need to transmit up to 3MB of data (while retrieving an object value of
size 1MB), incurring high communication cost.

Erasure Code-based Atomic Storage. Erasure Coded-based DSS are extremely beneficial to save storage and communi-
cation costs while maintaining similar fault-tolerance levels as in replication based DSS [13]. Mechanisms using an [ùëõ, ùëò]
erasure code splits a value ùë£ of size, say 1 unit, into ùëò elements, each of size 1
ùëò units, creates ùëõ coded elements of the
ùëõ
ùëò units. So the [ùëõ = 3, ùëò = 2] code in the
same size, and stores one coded element per server, for a total storage cost of
previous example will reduce the storage cost to 1.5TB and the communication cost to 1.5MB (improving also operation
latency). Maximum Distance Separable (MDS) codes have the property that value ùë£ can be reconstructed from any ùëò out
of these ùëõ coded elements; note that replication is a special case of MDS codes with ùëò = 1. In addition to the potential
cost-savings, the suitability of erasure-codes for DSS is amplified with the emergence of highly optimized erasure coding

libraries, that reduce encoding/decoding overheads [3, 9, 38]. In fact, an exciting recent body of systems and optimization

works [4, 28, 38, 41‚Äì44, 46] have demonstrated that for several data stores, the use of erasure coding results in lower

latencies than replication based approaches. This is achieved by allowing the system to carefully tune erasure coding

parameters, data placement strategies, and other system parameters that improve workload characteristics ‚Äì such as load

and spatial distribution. A complementary body of work has proposed novel non-blocking algorithms that use erasure

coding to provide an atomic storage over asynchronous message passing models [10, 12, 13, 16, 29, 30, 45]. Since erasure

code-based algorithms, unlike their replication-based counter parts, incur the additional burden of synchronizing the
access of multiple pieces of coded-elements from the same version of the data object, these algorithms are quite complex.

Reconfigurable Atomic Storage. Configuration refers to the set of storage servers that are collectively used to host
the data and implement the DSS. Reconfiguration is the process of adding or removing servers in a DSS. In practice,

reconfigurations are often desirable by system administrators [6], for a wide range of purposes, especially during system

maintenance. As the set of storage servers becomes older and unreliable they are replaced with new ones to ensure

data-durability. Furthermore, to scale the storage service to increased or decreased load, larger (or smaller) configurations

may be needed to be deployed. Therefore, in order to carry out such reconfiguration steps, in addition to the usual read
and write operations, an operation called reconfig is invoked by reconfiguration clients. Performing reconfiguration
of a system, without service interruption, is a very challenging task and an active area of research. RAMBO [33] and

DynaStore [5] are two of the handful of algorithms [14, 20, 23, 27, 39, 40] that allows reconfiguration on live systems; all

these algorithms are replication-based.

Manuscript submitted to ACM

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

3

Despite the attractive prospects of creating strongly consistent DSS with low storage and communication costs, so far,

no algorithmic framework for reconfigurable atomic DSS employed erasure coding for fault-tolerance, or provided any

analysis of bandwidth and storage costs. Our paper fills this vital gap in algorithms literature, through the development of
novel reconfigurable approach for atomic storage that use erasure codes for fault-tolerance. From a practical viewpoint,

our work may be interpreted as a bridge between the systems optimization works [4, 28, 38, 41‚Äì44, 46] and non-blocking
erasure coded based consistent storage [10, 12, 13, 16, 29, 30, 45]. Specifically, the use of our reconfigurable algorithms

would potentially enable a data storage service to dynamically shift between different erasure coding based parameters

and placement strategies, as the demand characteristics (such as load and spatial distribution) change, without service

interruption.

Our Contributions. We develop a reconfigurable, erasure-coded, atomic or strongly consistent [25, 32] read/write

storage algorithm, called ARES. Motivated by many practical systems, ARES assumes clients and servers are separate
processes * that communicate via logical point-to-point channels.

In contrast to the, replication-based reconfigurable algorithms [5, 14, 20, 23, 27, 33, 39, 40], where a configuration

essentially corresponds to the set of servers that stores the data, the same concept for erasure coding need to be much
more involved. In particular, in erasure coding, even if the same set of ùëõ servers are used, a change in the value of ùëò
defines a new configuration. Furthermore, several erasure coding based algorithms [12, 16] have additional parameters

that tune how many older versions each server store, which in turn influences the concurrency level allowed. Tuning of

such parameters can also fall under the purview of reconfiguration.

To accommodate these various reconfiguration requirements, ARES takes a modular approach. In particular, ARES
uses a set of primitives, called data-access primitives (DAPs). A different implementation of the DAP primitives may be

specified in each configuration. ARES uses DAPs as a ‚Äúblack box‚Äù to: (i) transfer the object state from one configuration

to the next during reconfig operations, and (ii) invoke read/write operations on a single configuration. Given the DAP
implementation for each configuration we show that ARES correctly implements a reconfigurable, atomic read/write

storage.

Algorithm

CASGC [11]

SODA [29]
ORCAS-A [16]
ORCAS-B [16]
ABD [8]
RAMBO [33]
DYNASTORE [5]
SMARTMERGE [27]

ARES (this paper)

#rounds
/write
3

#rounds
/read
2

2
3
3
2
2
‚â• 4
2

2

2
‚â• 2
3
2
2
‚â• 4
2

2

Reconfig.

No

No
No
No
No
Yes
Yes
Yes

Yes

Repl. or
EC
EC

EC
EC
EC
Repl.
Repl.
Repl.
Repl.

EC

Storage cost

read bandwidth

write bandwidth

(ùõø + 1) ùëõ
ùëò
ùëõ
ùëò
ùëõ
‚àû
ùëõ
‚â• ùëõ
‚â• ùëõ
‚â• ùëõ
(ùõø + 1) ùëõ
ùëò

ùëõ
ùëò
(ùõø + 1) ùëõ
ùëò
ùëõ
‚àû
2ùëõ
‚â• ùëõ
‚â• ùëõ
‚â• ùëõ
(ùõø + 1) ùëõ
ùëò

ùëõ
ùëò
ùëõ2
ùëò
ùëõ
‚àû
ùëõ
‚â• ùëõ
‚â• ùëõ
‚â• ùëõ
ùëõ
ùëò

Table 1. Comparison of ARES with previous algorithms emulating atomic Read/Write Memory for replication (Repl.) and
erasure-code based (EC) algorithms. ùõø is the maximum number of concurrent writes with any read during the course of an
execution of the algorithm. In practice, ùõø < 4 [13].

The DAP primitives provide ARES a much broader view of the notion of a configuration as compared to replication-

based algorithms. Specifically, the DAP primitives may be parameterized, following the parameters of protocols used

for their implementation (e.g., erasure coding parameters, set of servers, quorum design, concurrency level, etc.). While

transitioning from one configuration to another, our modular construction, allows ARES to reconfigure between different

*In practice, these processes can be on the same node or different nodes.

Manuscript submitted to ACM

4Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

sets of servers, quorum configurations, and erasure coding parameters. In principle, ARES even allows to reconfigure

between completely different protocols as long as they can be interpreted/expressed in terms of the primitives; though in

this paper, we only present one implementation of the DAP primitives to keep the scope of the paper reasonable. From a

technical point of view, our modular structure makes the atomicity proof of a complex algorithm (like ARES) easier.

An important consideration in the design choice of ARES, is to ensure that we gain/retain the advantages that come

with erasure codes ‚Äì cost of data storage and communication is low ‚Äì while having the flexibility to reconfigure the system.

Towards this end, we present an erasure-coded implementation of DAPs which satisfy the necessary properties, and are
used by ARES to yield the first reconfigurable, erasure-coded, read/write atomic storage implementation, where read
and write operations complete in two-rounds. We provide the atomicity property and latency analysis for any operation
in ARES, along with the storage and communication costs resulting from the erasure-coded DAP implementation. In

particular, we specify lower and upper bounds on the communication latency between the service participants, and
we provide the necessary conditions to guarantee the termination of each read/write operation while concurrent with
reconfig operations.

Table 1 compares ARES with a few well-known erasure-coded and replication-based (static and reconfigurable) atomic

memory algorithms. From the table we observe that ARES is the only algorithm to combine a dynamic behavior with the

use of erasure codes, while reducing the storage and communcation costs associated with the read or write operations.

Moreover, in ARES the number of rounds per write and read is at least as good as in any of the remaining algorithms.

Document Structure. Section 2 presents the model assumptions and Section 3, the DAP primitives. In Section 4, we

present the implementation of the reconfiguration and read/write protocols in ARES using the DAPs. In Section 5, we

present an erasure-coded implementation of a set of DAPs, which can be used in every configuration of the ARES

algorithm. Section 7 provides operation latency and cost analysis, and Section 8 the DAP flexibility. Section 9 presents an

experimental evaluation of the proposed algorithms. We conclude our work in Section 10. Due to lack of space omitted

proofs can be found in [36].

2 MODEL AND DEFINITIONS

A shared atomic storage, consisting of any number of individual objects, can be emulated by composing individual atomic
memory objects. Therefore, herein we aim in implementing a single atomic read/write memory object. A read/write object
takes a value from a set V. We assume a system consisting of four distinct sets of processes: a set W of writers, a set R
of readers, a set G of reconfiguration clients, and a set S of servers. Let I = W ‚à™ R ‚à™ G be the set of clients. Servers host
data elements (replicas or encoded data fragments). Each writer is allowed to modify the value of a shared object, and

each reader is allowed to obtain the value of that object. Reconfiguration clients attempt to introduce new configuration of

servers to the system in order to mask transient errors and to ensure the longevity of the service. Processes communicate
via messages through asynchronous, and reliable channels.

Configurations. A configuration, with a unique identifier from a set C, is a data type that describes the finite set of
servers that are used to implement the atomic storage service. In our setting, each configuration is also used to describe
the way the servers are grouped into intersecting sets, called quorums, the consensus instance that is used as an external

service to determine the next configuration, and a set of data access primitives that specify the interaction of the clients
and servers in the configuration (see Section 3). More formally, a configuration, ùëê ‚àà C, consists of: (ùëñ) ùëê.ùëÜùëíùëüùë£ùëíùëüùë† ‚äÜ S: a
set of server identifiers; (ùëñùëñ) ùëê.ùëÑùë¢ùëúùëüùë¢ùëöùë†: the set of quorums on ùëê.ùëÜùëíùëüùë£ùëíùëüùë†, s.t. ‚àÄùëÑ1, ùëÑ2 ‚àà ùëê.ùëÑùë¢ùëúùëüùë¢ùëöùë†, ùëÑ1, ùëÑ2 ‚äÜ ùëê.ùëÜùëíùëüùë£ùëíùëüùë†
and ùëÑ1 ‚à© ùëÑ2 ‚â† ‚àÖ; (ùëñùëñùëñ) ùê∑ùê¥ùëÉ (ùëê): the set of primitives (operations at level lower than reads or writes) that clients in I may
Manuscript submitted to ACM

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

5

invoke on ùëê.ùëÜùëíùëüùë£ùëíùëüùë†; and (ùëñùë£) ùëê.ùê∂ùëúùëõ: a consensus instance with the values from C, implemented and running on top of the
servers in ùëê.ùëÜùëíùëüùë£ùëíùëüùë†. We refer to a server ùë† ‚àà ùëê.ùëÜùëíùëüùë£ùëíùëüùë† as a member of configuration ùëê. The consensus instance ùëê.ùê∂ùëúùëõ in
each configuration ùëê is used as a service that returns the identifier of the configuration that follows ùëê.

Executions. An algorithm ùê¥ is a collection of processes, where process ùê¥ùëù is assigned to process ùëù ‚àà I ‚à™ S. The state,
of a process ùê¥ùëù is determined over a set of state variables, and the state ùúé of ùê¥ is a vector that contains the state of each
process. Each process ùê¥ùëù implements a set of actions. When an action ùõº occurs it causes the state of ùê¥ùëù to change, say
from some state ùúéùëù to some different state ùúé ‚Ä≤
ùëù . We call the triple ‚ü®ùúéùëù, ùõº, ùúé ‚Ä≤
ùëù ‚ü© a step of ùê¥ùëù . Algorithm ùê¥ performs a step,
when some process ùê¥ùëù performs a step. An action ùõº is enabled in a state ùúé if ‚àÉ a step ‚ü®ùúé, ùõº, ùúé ‚Ä≤‚ü© to some state ùúé ‚Ä≤. An
execution is an alternating sequence of states and actions of ùê¥ starting with the initial state and ending in a state. An
execution ùúâ fair if enabled actions perform a step infinitely often. In the rest of the paper we consider executions that are
fair and well-formed. A process ùëù crashes in an execution if it stops taking steps; otherwise ùëù is correct or non-faulty. We
assume a function ùëê.F to describe the failure model of a configuration ùëê.

Reconfigurable Atomic Read/Write Objects. A reconfigurable atomic object supports three operations: read(),
write(ùë£) and reconfig(ùëê). A read() operation returns the value of the atomic object, write(ùë£) attempts to modify the value
of the object to ùë£ ‚àà V, and the reconfig(ùëê) that attempts to install a new configuration ùëê ‚àà C. We assume well-formed
executions where each client may invoke one operation (read(), write(ùë£) or reconfig(ùëê)) at a time.

An implementation of a read/write or a reconfig operation contains an invocation action (such as a call to a procedure)
and a response action (such as a return from the procedure). An operation ùúã is complete in an execution, if it contains both
the invocation and the matching response actions for ùúã; otherwise ùúã is incomplete. We say that an operation ùúã precedes
an operation ùúã ‚Ä≤ in an execution ùúâ, denoted by ùúã ‚Üí ùúã ‚Ä≤, if the response step of ùúã appears before the invocation step of ùúã ‚Ä≤
in ùúâ. Two operations are concurrent if neither precedes the other. An implementation ùê¥ of a read/write object satisfies
the atomicity (linearizability [25]) property if the following holds [32]. Let the set Œ† contain all complete read/write
operations in any well-formed execution of ùê¥. Then there exists an irreflexive partial ordering ‚â∫ satisfying the following:

A1. For any operations ùúã1 and ùúã2 in Œ†, if ùúã1 ‚Üí ùúã2, then it cannot be the case that ùúã2 ‚â∫ ùúã1.
A2. If ùúã ‚àà Œ† is a write operation and ùúã ‚Ä≤ ‚àà Œ† is any read/write operation, then either ùúã ‚â∫ ùúã ‚Ä≤ or ùúã ‚Ä≤ ‚â∫ ùúã.
A3. The value returned by a read operation is the value written by the last preceding write operation according to ‚â∫ (or

the initial value if there is no such write).

Storage and Communication Costs. We are interested in the complexity of each read and write operation. The complexity
of each operation ùúã invoked by a process ùëù, is measured with respect to three metrics, during the interval between the
invocation and the response of ùúã: (ùëñ) number of communication round, accounting the number of messages exchanged
during ùúã, (ùëñùëñ) storage efficiency (storage cost), accounting the maximum storage requirements for any single object at the
servers during ùúã, and (ùëñùëñùëñ) message bit complexity (communication cost) which measures the size of the messages used
during ùúã.

We define the total storage cost as the size of the data stored across all servers, at any point during the execution of

the algorithm. The communication cost associated with a read or write operation is the size of the total data that gets

transmitted in the messages sent as part of the operation. We assume that metadata, such as version number, process ID,

etc. used by various operations is of negligible size, and is hence ignored in the calculation of storage and communication
cost. Further, we normalize both costs with respect to the size of the value ùë£; in other words, we compute the costs under
the assumption that ùë£ has size 1 unit.

Manuscript submitted to ACM

6Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

Erasure Codes. We use an [ùëõ, ùëò] linear MDS code [26] over a finite field Fùëû to encode and store the value ùë£ among
the ùëõ servers. An [ùëõ, ùëò] MDS code has the property that any ùëò out of the ùëõ coded elements can be used to recover
(decode) the value ùë£. For encoding, ùë£ is divided into ùëò elements ùë£1, ùë£2, . . . ùë£ùëò with each element having size 1
ùëò (assuming
size of ùë£ is 1). The encoder takes the ùëò elements as input and produces ùëõ coded elements ùëí1, ùëí2, . . . , ùëíùëõ as output,
i.e., [ùëí1, . . . , ùëíùëõ] = Œ¶([ùë£1, . . . , ùë£ùëò ]), where Œ¶ denotes the encoder. For ease of notation, we simply write Œ¶(ùë£) to mean
[ùëí1, . . . , ùëíùëõ]. The vector [ùëí1, . . . , ùëíùëõ] is referred to as the codeword corresponding to the value ùë£. Each coded element ùëêùëñ
also has size 1
ùëò . In our scheme we store one coded element per server. We use Œ¶ùëñ to denote the projection of Œ¶ on to the ùëñth
output component, i.e., ùëíùëñ = Œ¶ùëñ (ùë£). Without loss of generality, we associate the coded element ùëíùëñ with server ùëñ, 1 ‚â§ ùëñ ‚â§ ùëõ.

Tags. We use logical tags to order operations. A tag ùúè is defined as a pair (ùëß, ùë§), where ùëß ‚àà N and ùë§ ‚àà W, an ID of a
writer. Let T be the set of all tags. Notice that tags could be defined in any totally ordered domain and given that this
domain is countably infinite, then there can be a direct mapping to the domain we assume. For any ùúè1, ùúè2 ‚àà T we define
ùúè2 > ùúè1 if (ùëñ) ùúè2.ùëß > ùúè1.ùëß or (ùëñùëñ) ùúè2.ùëß = ùúè1.ùëß and ùúè2.ùë§ > ùúè1.ùë§.

3 DATA ACCESS PRIMITIVES

In this section we introduce a set of primitives, we refer to as data access primitives (DAP), which are invoked by the
clients during read/write/reconfig operations and are defined for any configuration ùëê in ARES. The DAPs allow us: (ùëñ) to
describe ARES in a modular manner, and (ùëñùëñ) a cleaner reasoning about the correctness of ARES.

We define three data access primitives for each ùëê ‚àà C: (ùëñ) ùëê.put-data(‚ü®ùúè, ùë£‚ü©), via which a client can ingest the tag value
pair ‚ü®ùúè, ùë£‚ü© in to the configuration ùëê; (ùëñùëñ) ùëê.get-data(), used to retrieve the most up to date tag and vlaue pair stored in the
configuration ùëê; and (ùëñùëñùëñ) ùëê.get-tag(), used to retrieve the most up to date tag for an object stored in a configuration ùëê.
More formally, assuming a tag ùúè from a set of totally ordered tags T , a value ùë£ from a domain V, and a configuration ùëê
from a set of identifiers C, the three primitives are defined as follows:

DEFINITION 1 (DATA ACCESS PRIMITIVES). Given a configuration identifier ùëê ‚àà C, any non-faulty client process
ùëù may invoke the following data access primitives during an execution ùúâ, where ùëê is added to specify the configuration
specific implementation of the primitives:

ùê∑1: ùëê.get-tag() that returns a tag ùúè ‚àà T ;
ùê∑2: ùëê.get-data() that returns a tag-value pair (ùúè, ùë£) ‚àà T √ó V,
ùê∑3: ùëê.put-data(‚ü®ùúè, ùë£‚ü©) which accepts the tag-value pair (ùúè, ùë£) ‚àà T √ó V as argument.

In order for the DAPs to be useful in designing the ARES algorithm we further require the following consistency

properties. As we see later in Section 6, the safety property of ARES holds, given that these properties hold for the DAPs

in each configuration.

PROPERTY 1 (DAP CONSISTENCY PROPERTIES). In an execution ùúâ we say that a DAP operation in an execution ùúâ
is complete if both the invocation and the matching response step appear in ùúâ. If Œ† is the set of complete DAP operations
in execution ùúâ then for any ùúô, ùúã ‚àà Œ†:

C1 If ùúô is ùëê.put-data(‚ü®ùúèùúô, ùë£ùúô ‚ü©), for ùëê ‚àà C, ‚ü®ùúèùúô, ùë£ùúô ‚ü© ‚àà T √ó V, and ùúã is ùëê.get-tag() (or ùëê.get-data()) that returns

ùúèùúã ‚àà T (or ‚ü®ùúèùúã , ùë£ùúã ‚ü© ‚àà T √ó V) and ùúô completes before ùúã is invoked in ùúâ, then ùúèùúã ‚â• ùúèùúô .

C2 If ùúô is a ùëê.get-data() that returns ‚ü®ùúèùúã , ùë£ùúã ‚ü© ‚àà T √ó V, then there exists ùúã such that ùúã is ùëê.put-data(‚ü®ùúèùúã , ùë£ùúã ‚ü©) and ùúô

did not complete before the invocation of ùúã. If no such ùúã exists in ùúâ, then (ùúèùúã , ùë£ùúã ) is equal to (ùë°0, ùë£0).

Manuscript submitted to ACM

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

7

In Section 5 we show how to implement a set of DAPs, where erasure-codes are used to reduce storage and communi-

cation costs. Our DAP implementation satisfies Property 1.

As noted earlier, expressing ARES in terms of the DAPs allows one to achieve a modular design. Modularity enables

the usage of different DAP implementation per configuration, during any execution of ARES, as long as the DAPs
implemented in each configuration satisfy Property 1. For example, the DAPs in a configuration ùëê may be implemented
using replication, while the DAPs in the next configuration say ùëê ‚Ä≤, may be implemented using erasure-codes. Thus, a
system may use a scheme that offers higher fault tolerance (e.g. replication) when storage is not an issue, while switching

to a more storage efficient (less fault-tolerant) scheme when storage gets limited.

In Section 8, we show that the presented DAPs are not only suitable for algorithm ARES, but can also be used to
implement a large family of atomic read/write storage implementations. By describing an algorithm ùê¥ according to a
simple algorithmic template (see Algorithm 7), we show that ùê¥ preserves safety (atomicity) if the used DAPs satisfy
Property 1, and ùê¥ preserves liveness (termination), if every invocation of the used DAPs terminate, under the failure
model assumed.

4 THE ARES PROTOCOL

In this section, we describe ARES. In the presentation of ARES algorithm we decouple the reconfiguration service

from the shared memory emulation, by utilizing the DAPs presented in Section 3. This allows ARES, to handle both

the reorganization of the servers that host the data, as well as utilize a different atomic memory implementation per

configuration. It is also important to note that ARES adopts a client-server architecture and separates the reader, writer and

reconfiguration processes from the server processes that host the object data. More precisely, ARES algorithm comprises
of three major components: (ùëñ) The reconfiguration protocol which consists of invoking, and subsequently installing new
configuration via the reconfig operation by recon clients. (ùëñùëñ) The read/write protocol for executing the read and write
operations invoked by readers and writers. (ùëñùëñùëñ) The implementation of the DAPs for each installed configuration that
respect Property 1 and which are used by the reconfig, read and write operations.

4.1 Implementation of the Reconfiguration Service.

In this section, we describe the reconfiguration service in ARES. The service relies on an underlying sequence of

configurations (already proposed or installed by reconfig operations), in the from of a ‚Äúdistributed list‚Äù, which we refer to
as the global configuration sequence (or list) Gùêø. Conceptually, Gùêø represents an ordered list of pairs ‚ü®ùëê, ùë†ùë°ùëéùë°ùë¢ùë†‚ü©, where ùëê
is a configuration identifier (ùëê ‚àà C), and a binary state variable ùë†ùë°ùëéùë°ùë¢ùë† ‚àà {ùêπ, ùëÉ } that denotes whether ùëê is finalized (ùêπ ) or is
still pending (ùëÉ). Initially, Gùêø contains a single element, say ‚ü®ùëê0, ùêπ ‚ü©, which is known to every participant in the service.
To facilitate the creation of Gùêø, each server in ùëê.ùëÜùëíùëüùë£ùëíùëüùë† maintains a local variable ùëõùëíùë•ùë°ùê∂ ‚àà {C ‚à™ {‚ä•}} √ó {ùëÉ, ùêπ }, which
is used to point to the configuration that follows ùëê in Gùêø. Initially, at any server ùëõùëíùë•ùë°ùê∂ = ‚ü®‚ä•, ùêπ ‚ü©. Once ùëõùëíùë•ùë°ùê∂ it is set to a
value it is never altered. As we show below, at any point in the execution of ARES and in any configuration ùëê, the ùëõùëíùë•ùë°ùê∂
variables of the non-faulty servers in ùëê that are not equal to ‚ä• agree, i.e., {ùë†.ùëõùëíùë•ùë°ùê∂ : ùë† ‚àà ùëê.ùëÜùëíùëüùë£ùëíùëüùë† ‚àß ùë†.ùëõùëíùë•ùë°ùê∂ ‚â† ‚ä•} is either
empty of has only one element.

Clients discover the configuration that follows a ‚ü®ùëê, ‚àó‚ü© in the sequence by contacting a subset of servers in ùëê.ùëÜùëíùëüùë£ùëíùëüùë† and
collecting their ùëõùëíùë•ùë°ùê∂ variables. Every client in I maintains a local variable ùëêùë†ùëíùëû that is expected to be some subsequence
ùë• (a caret over some name) to denote state
of Gùêø. Initially, at every client the value of ùëêùë†ùëíùëû is ‚ü®ùëê0, ùêπ ‚ü©. We use the notation (cid:98)
variables that assume values from the domain {C ‚à™ {‚ä•}} √ó {ùëÉ, ùêπ }.

Manuscript submitted to ACM

8Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

Reconfiguration clients may introduce new configurations, each associated with a unique configuration identifier from
C. Multiple clients may concurrently attempt to introduce different configurations for same next link in Gùêø. ARES uses
consensus to resolve such conflicts: a subset of servers in ùëê.ùëÜùëíùëüùë£ùëíùëüùë†, in each configuration ùëê, implements a distributed
consensus service (such as Paxos [31], RAFT [37]) , denoted by ùëê.ùê∂ùëúùëõ.

The reconfiguration service consists of two major components: (ùëñ) sequence traversal, responsible of discovering a

recent configuration in Gùêø, and (ùëñùëñ) reconfiguration operation that installs new configurations in Gùêø.

Algorithm 1 Sequence traversal at each process ùëù ‚àà I of algorithm ARES.

procedure read-config(ùë†ùëíùëû)

until ‚àÉùëÑ, ùëÑ ‚àà ùëê.ùëÑùë¢ùëúùëüùë¢ùëöùë† s.t. ùëüùëíùëêùëñ receives ùëõùëíùë•ùë°ùê∂ùë† from

2:

4:

6:

8:

ùúá = max( { ùëó : ùë†ùëíùëû [ ùëó ].ùë†ùë°ùëéùë°ùë¢ùë† = ùêπ })
ùëê ‚Üê ùë†ùëíùëû [ùúá ]
(cid:98)
while (cid:98)
ùëê ‚Üêget-next-config((cid:98)
(cid:98)
if (cid:98)

ùëê ‚â† ‚ä• do

ùëê.ùëê ùëì ùëî)

ùëê ‚â† ‚ä• then
ùúá ‚Üê ùúá + 1
ùë†ùëíùëû [ùúá ] ‚Üê (cid:98)
ùëê
put-config(ùë†ùëíùëû [ùúá ‚àí 1].ùëê ùëì ùëî, ùë†ùëíùëû [ùúá ])

10:

end while
return ùë†ùëíùëû

12: end procedure

‚àÄùë† ‚àà ùëÑ

16:

18:

if ‚àÉùë† ‚àà ùëÑ s.t. ùëõùëíùë•ùë°ùê∂ùë† .ùë†ùë°ùëéùë°ùë¢ùë† = ùêπ then

return ùëõùëíùë•ùë°ùê∂ùë†

else if ‚àÉùë† ‚àà ùëÑ s.t. ùëõùëíùë•ùë°ùê∂ùë† .ùë†ùë°ùëéùë°ùë¢ùë† = ùëÉ then

return ùëõùëíùë•ùë°ùê∂ùë†

20:

else

return ‚ä•
22: end procedure

procedure put-config(ùëê, ùëõùëíùë•ùë°ùê∂)

24:

send (WRITE-CONFIG, ùëõùëíùë•ùë°ùê∂) to each ùë† ‚àà ùëê.ùëÜùëíùëü ùë£ùëíùëüùë†
until ‚àÉùëÑ, ùëÑ ‚àà ùëê.ùëÑùë¢ùëúùëüùë¢ùëöùë† s.t. ùëüùëíùëêùëñ receives ACK from

procedure get-next-config(ùëê)

‚àÄùë† ‚àà ùëÑ

14:

send (READ-CONFIG) to each ùë† ‚àà ùëê.ùëÜùëíùëü ùë£ùëíùëüùë†

26: end procedure

Sequence Traversal. Any read/write/reconfig operation ùúã utilizes the sequence traversal mechanism to discover the
latest state of the global configuration sequence, as well as to ensure that such a state is discoverable by any subsequent
operation ùúã ‚Ä≤. See Fig. 1 for an example execution in the case of a reconfig operation. In a high level, a client starts
by collecting the ùëõùëíùë•ùë°ùê∂ variables from a quorum of servers in a configuration ùëê, such that ‚ü®ùëê, ùêπ ‚ü© is the last finalized
configuration in that client‚Äôs local ùëêùë†ùëíùëû variable (or ùëê0 if no other finalized configuration exists). If any server ùë† returns
a ùëõùëíùë•ùë°ùê∂ variable such that ùëõùëíùë•ùë°ùê∂.ùëê ùëì ùëî ‚â† ‚ä•, then the client (ùëñ) adds ùëõùëíùë•ùë°ùê∂ in its local ùëêùë†ùëíùëû, (ùëñùëñ) propagates ùëõùëíùë•ùë°ùê∂ in a
quorum of servers in ùëê.ùëÜùëíùëüùë£ùëíùëüùë†, and (ùëñùëñùëñ) repeats this process in the configuration ùëõùëíùë•ùë°ùê∂.ùëê ùëì ùëî. The client terminates when
all servers reply with ùëõùëíùë•ùë°ùê∂.ùëê ùëì ùëî = ‚ä•. More precisely, the sequence parsing consists of three actions (see Alg. 1):

get-next-config(ùëê): The action get-next-config returns the configuration that follows ùëê in Gùêø. During get-next-config(ùëê),
a client sends READ-CONFIG messages to all the servers in ùëê.ùëÜùëíùëüùë£ùëíùëüùë†, and waits for replies containing ùëõùëíùë•ùë°ùê∂ from a
quorum in ùëê.ùëÑùë¢ùëúùëüùë¢ùëöùë†. If there exists a reply with ùëõùëíùë•ùë°ùê∂.ùëê ùëì ùëî ‚â† ‚ä• the action returns ùëõùëíùë•ùë°ùê∂; otherwise it returns ‚ä•.

put-config(ùëê, ùëê ‚Ä≤): The put-config(ùëê, ùëê ‚Ä≤) action propagates ùëê ‚Ä≤ to a quorum of servers in ùëê.ùëÜùëíùëüùë£ùëíùëüùë†. During the action,
the client sends (WRITE-CONFIG, ùëê ‚Ä≤) messages, to the servers in ùëê.ùëÜùëíùëüùë£ùëíùëüùë† and waits for each server ùë† in some quorum
ùëÑ ‚àà ùëê.ùëÑùë¢ùëúùëüùë¢ùëöùë† to respond.

read-config(ùë†ùëíùëû): A read-config(ùë†ùëíùëû) sequentially traverses the installed configurations in order to discover the latest
state of the sequence Gùêø. At invocation, the client starts with the last finalized configuration ‚ü®ùëê, ùêπ ‚ü© in the given ùë†ùëíùëû (Line
A1:2), and enters a loop to traverse Gùêø by invoking get-next-config(), which returns the next configuration, assigned
ùëê is appended at the end of the sequence ùë†ùëíùëû; (b) a put-config action is invoked to inform a
to (cid:98)
quorum of servers in ùëê.ùëÜùëíùëüùë£ùëíùëüùë† to update the value of their ùëõùëíùë•ùë°ùê∂ variable to (cid:98)
ùëê = ‚ä• the loop terminates and the action
read-config returns ùë†ùëíùëû.
Manuscript submitted to ACM

ùëê ‚â† ‚ä•, then: (a) (cid:98)

ùëê. While (cid:98)

ùëê. If (cid:98)

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

9

Algorithm 2 Reconfiguration protocol of algorithm ARES.

at each reconfigurer ùëüùëíùëêùëñ

2: State Variables:

ùëêùë†ùëíùëû []ùë†.ùë° .ùëêùë†ùëíùëû [ ùëó ] ‚àà C √ó {ùêπ, ùëÉ } with members:

return ùë†ùëíùëû

20: end procedure

4: Initialization:

ùëêùë†ùëíùëû [0] = ‚ü®ùëê0, ùêπ ‚ü©

6: operation reconfig(c)
if ùëê ‚â† ‚ä• then

8:

10:

ùëêùë†ùëíùëû ‚Üêread-config(ùëêùë†ùëíùëû)
ùëêùë†ùëíùëû ‚Üê add-config(ùëêùë†ùëíùëû, ùëê)
update-config(ùëêùë†ùëíùëû)
ùëêùë†ùëíùëû ‚Üê finalize-config(ùëêùë†ùëíùëû)

12: end operation

procedure add-config(ùë†ùëíùëû, ùëê)

14:

16:

18:

ùúà ‚Üê |ùë†ùëíùëû |
ùëê‚Ä≤ ‚Üê ùë†ùëíùëû [ùúà ].ùëê ùëì ùëî
ùëë ‚Üê ùëê‚Ä≤.ùê∂ùëúùëõ.ùëùùëüùëúùëùùëúùë†ùëí (ùëê)
ùë†ùëíùëû [ùúà + 1] ‚Üê ‚ü®ùëë, ùëÉ ‚ü©
put-config(ùëê‚Ä≤, ‚ü®ùëë, ùëÉ ‚ü©)

procedure update-config(ùë†ùëíùëû)

22:

ùúá ‚Üê max( { ùëó : ùë†ùëíùëû [ ùëó ].ùë†ùë°ùëéùë°ùë¢ùë† = ùêπ })
ùúà ‚Üê |ùë†ùëíùëû |

24: ùëÄ ‚Üê ‚àÖ

for ùëñ = ùúá : ùúà do

26:

28:

‚ü®ùë°, ùë£ ‚ü© ‚Üê ùë†ùëíùëû [ùëñ ].ùëê ùëì ùëî.get-data()
ùëÄ ‚Üê ùëÄ ‚à™ { ‚ü®ùúè, ùë£ ‚ü© }

‚ü®ùúè, ùë£ ‚ü© ‚Üê maxùë° { ‚ü®ùë°, ùë£ ‚ü© : ‚ü®ùë°, ùë£ ‚ü© ‚àà ùëÄ }
ùë†ùëíùëû [ùúà ].ùëê ùëì ùëî.put-data( ‚ü®ùúè, ùë£ ‚ü©)

30: end procedure

32:

34:

procedure finalize-config(ùë†ùëíùëû)

ùúà = |ùë†ùëíùëû |
ùë†ùëíùëû [ùúà ].ùë†ùë°ùëéùë°ùë¢ùë† ‚Üê ùêπ
put-config(ùë†ùëíùëû [ùúà ‚àí 1].ùëê ùëì ùëî, ùë†ùëíùëû [ùúà ])
return ùë†ùëíùëû

36: end procedure

Algorithm 3 Server protocol of algorithm ARES.

at each server ùë†ùëñ in configuration ùëêùëò

8: end receive

2: State Variables:

ùúè ‚àà N √ó W, initially, ‚ü®0, ‚ä•‚ü©

4: ùë£ ‚àà ùëâ , intially, ‚ä•

ùëõùëíùë•ùë°ùê∂ ‚àà C √ó {ùëÉ, ùêπ }, initially ‚ü®‚ä•, ùëÉ ‚ü©

6: Upon receive (READ-CONFIG) ùë†ùëñ , ùëêùëò from ùëû

send ùëõùëíùë•ùë°ùê∂ to ùëû

10:

12:

Upon receive (WRITE-CONFIG, ùëê ùëì ùëîùëáùëñùëõ) ùë†ùëñ , ùëêùëò from ùëû
if ùëõùëíùë•ùë°ùê∂.ùëê ùëì ùëî = ‚ä• ‚à® ùëõùëíùë•ùë°ùê∂.ùë†ùë°ùëéùë°ùë¢ùë† = ùëÉ then

ùëõùëíùë•ùë°ùê∂ ‚Üê ùëê ùëì ùëîùëáùëñùëõ

send ACK to ùëû

end receive

Reconfiguration operation. A reconfiguration operation reconfig(ùëê), ùëê ‚àà C, invoked by any reconfiguration client ùëüùëíùëêùëñ ,
attempts to append ùëê to Gùêø. The set of server processes in ùëê are not a part of any other configuration different from ùëê. In
a high-level, ùëüùëíùëêùëñ first executes a sequence traversal to discover the latest state of Gùêø. Then it attempts to add the new
configuration ùëê, at the end of the discovered sequence by proposing ùëê in the consensus instance of the last configuration in
the sequence. The client accepts and appends the decision of the consensus instance (that might be different than ùëê). Then
it attempts to transfer the latest value of the read/write object to the latest installed configuration. Once the information is
transferred, ùëüùëíùëêùëñ finalizes the last configuration in its local sequence and propagates the finalized tuple to a quorum of
servers in that configuration. The operation consists of four phases, executed consecutively by ùëüùëíùëêùëñ (see Alg. 2):

read-config(ùë†ùëíùëû): The phase read-config(ùë†ùëíùëû) at ùëüùëíùëêùëñ , reads the recent global configuration sequence as described in

the sequence traversal.

add-config(ùë†ùëíùëû, ùëê): The add-config(ùë†ùëíùëû, ùëê) attempts to append a new configuration ùëê to the end of ùë†ùëíùëû (client‚Äôs view
of Gùêø). Suppose the last configuration in ùë†ùëíùëû is ùëê ‚Ä≤ (with status either ùêπ or ùëÉ), then in order to decide the most recent
configuration, ùëüùëíùëêùëñ invokes ùëê ‚Ä≤.ùê∂ùëúùëõ.ùëùùëüùëúùëùùëúùë†ùëí (ùëê), on the consensus object associated with configuration ùëê ‚Ä≤. Let ùëë ‚àà C be
Manuscript submitted to ACM

10Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

Fig. 1. Illustration of an execution of the reconfiguration steps.
the configuration identifier decided by the consensus service. If ùëë ‚â† ùëê, this implies that another (possibly concurrent)
reconfiguration operation, invoked by a reconfigurer ùëüùëíùëê ùëó ‚â† ùëüùëíùëêùëñ , proposed and succeeded ùëë as the configuration to follow
ùëê ‚Ä≤. In this case, ùëüùëíùëêùëñ adopts ùëë as it own propose configuration, by adding ‚ü®ùëë, ùëÉ‚ü© to the end of its local ùëêùë†ùëíùëû (entirely
ignoring ùëê), using the operation put-config(ùëê ‚Ä≤, ‚ü®ùëë, ùëÉ‚ü©), and returns the extended configuration ùë†ùëíùëû.

update-config(ùë†ùëíùëû): Let us denote by ùúá the index of the last configuration in the local sequence ùëêùë†ùëíùëû, at ùëüùëíùëêùëñ , such
that its corresponding status is ùêπ ; and ùúà denote the last index of ùëêùë†ùëíùëû. Next ùëüùëíùëêùëñ invokes update-config(ùëêùë†ùëíùëû), which
gathers the tag-value pair corresponding to the maximum tag in each of the configurations in (cid:155)ùëêùë†ùëíùëû[ùëñ] for ùúá ‚â§ ùëñ ‚â§ ùúà,
and transfers that pair to the configuration that was added by the add-config action. The get-data and put-data DAPs
are used to transfer the value of the object to the new configuration, and they are implemented with respect to the
configuration that is accessed. Suppose ‚ü®ùë°ùëöùëéùë• , ùë£ùëöùëéùë• ‚ü© is the tag value pair corresponding to the highest tag among the
responses from all the ùúà ‚àí ùúá + 1 configurations. Then, ‚ü®ùë°ùëöùëéùë• , ùë£ùëöùëéùë• ‚ü© is written to the configuration ùëë via the invocation of
(cid:156)ùëêùë†ùëíùëû [ùúà].ùëê ùëì ùëî.put-data(‚ü®ùúèùëöùëéùë• , ùë£ùëöùëéùë• ‚ü©).

finalize-config(ùëêùë†ùëíùëû): Once the tag-value pair is transferred, in the last phase of the reconfiguration operation, ùëüùëíùëêùëñ
executes finalize-config(ùëêùë†ùëíùëû), to update the status of the last configuration in ùëêùë†ùëíùëû, say ùëë = (cid:156)ùëêùë†ùëíùëû [ùúà].ùëê ùëì ùëî, to ùêπ . The
reconfigurer ùëüùëíùëêùëñ informs a quorum of servers in the previous configuration ùëê = (cid:156)ùëêùë†ùëíùëû[ùúà ‚àí 1].ùëê ùëì ùëî, i.e. in some ùëÑ ‚àà
ùëê.ùëÑùë¢ùëúùëüùë¢ùëöùë†, about the change of status, by executing the put-config(ùëê, ‚ü®ùëë, ùêπ ‚ü©) action.

Server Protocol. Each server responds to requests from clients (Alg. 3). A server waits for two types of messages:
READ-CONFIG and WRITE-CONFIG. When a READ-CONFIG message is received for a particular configuration ùëêùëò , then
the server returns ùëõùëíùë•ùë°ùê∂ variables of the servers in ùëêùëò .ùëÜùëíùëüùë£ùëíùëüùë†. A WRITE-CONFIG message attempts to update the ùëõùëíùë•ùë°ùê∂
variable of the server with a particular tuple ùëê ùëì ùëîùëáùëñùëõ. A server changes the value of its local ùëõùëíùë•ùë°ùê∂.ùëê ùëì ùëî in two cases: (i)
ùëõùëíùë•ùë°ùê∂.ùëê ùëì ùëî = ‚ä•, or (ii) ùëõùëíùë•ùë°ùê∂.ùë†ùë°ùëéùë°ùë¢ùë† = ùëÉ.

Fig. 1 illustrates an example execution of a reconfiguration operation recon(ùëê5). In this example, the reconfigurer ùëüùëíùëêùëñ
goes through a number of configuration queries (read-next-config) before it reaches configuration ùëê4 in which a quorum
of servers replies with ùëõùëíùë•ùë°ùê∂.ùëê ùëì ùëî = ‚ä•. There it proposes ùëê5 to the consensus object of ùëê4 (ùëê4.ùê∂ùëúùëõ.ùëùùëüùëúùëùùëúùë†ùëí (ùëê5) on arrow
10), and once ùëê5 is decided, recon(ùëê5) completes after executing finalize-config(ùëê5).

4.2 Implementation of Read and Write operations.

The read and write operations in ARES are expressed in terms of the DAP primitives (see Section 3). This provides the

flexibility to ARES to use different implementation of DAP primitives in different configurations, without changing the

Manuscript submitted to ACM

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

11

Algorithm 4 Write and Read protocols at the clients for ARES.

2:

4:

6:

8:

10:

12:

14:

16:

18:

20:

22:

Write Operation:

at each writer ùë§ùëñ
State Variables:
ùëêùë†ùëíùëû []ùë†.ùë° .ùëêùë†ùëíùëû [ ùëó ] ‚àà C √ó {ùêπ, ùëÉ } with members:
Initialization:
ùëêùë†ùëíùëû [0] = ‚ü®ùëê0, ùêπ ‚ü©

24: Read Operation:

26:

28:

at each reader ùëüùëñ
State Variables:
ùëêùë†ùëíùëû []ùë†.ùë° .ùëêùë†ùëíùëû [ ùëó ] ‚àà C √ó {ùêπ, ùëÉ } with members:
Initialization:
ùëêùë†ùëíùëû [0] = ‚ü®ùëê0, ùêπ ‚ü©

operation write(ùë£ùëéùëô), ùë£ùëéùëô ‚àà ùëâ
ùëêùë†ùëíùëû ‚Üêread-config(ùëêùë†ùëíùëû)
ùúá ‚Üê max( {ùëñ : ùëêùë†ùëíùëû [ùëñ ].ùë†ùë°ùëéùë°ùë¢ùë† = ùêπ })
ùúà ‚Üê |ùëêùë†ùëíùëû |
for ùëñ = ùúá : ùúà do

ùúèùëöùëéùë• ‚Üê max(ùëêùë†ùëíùëû [ùëñ ].ùëê ùëì ùëî.get-tag(), ùúèùëöùëéùë• )

‚ü®ùúè, ùë£ ‚ü© ‚Üê ‚ü®‚ü®ùúèùëöùëéùë• .ùë°ùë† + 1, ùúîùëñ ‚ü©, ùë£ùëéùëô ‚ü©
ùëëùëúùëõùëí ‚Üê ùëì ùëéùëôùë†ùëí
while not ùëëùëúùëõùëí do

ùëêùë†ùëíùëû [ùúà ].ùëê ùëì ùëî.put-data( ‚ü®ùúè, ùë£ ‚ü©)
ùëêùë†ùëíùëû ‚Üêread-config(ùëêùë†ùëíùëû)
if |ùëêùë†ùëíùëû | = ùúà then
ùëëùëúùëõùëí ‚Üê ùë°ùëüùë¢ùëí

else

ùúà ‚Üê |ùëêùë†ùëíùëû |

end while
end operation

30:

operation read( )

ùëêùë†ùëíùëû ‚Üêread-config(ùëêùë†ùëíùëû)
ùúá ‚Üê max( { ùëó : ùëêùë†ùëíùëû [ ùëó ].ùë†ùë°ùëéùë°ùë¢ùë† = ùêπ })
ùúà ‚Üê |ùëêùë†ùëíùëû |
for ùëñ = ùúá : ùúà do

‚ü®ùúè, ùë£ ‚ü© ‚Üê max(ùëêùë†ùëíùëû [ùëñ ].ùëê ùëì ùëî.get-data(), ‚ü®ùúè, ùë£ ‚ü©)

ùëëùëúùëõùëí ‚Üê false
while not ùëëùëúùëõùëí do

ùëêùë†ùëíùëû [ùúà ].ùëê ùëì ùëî.put-data( ‚ü®ùúè, ùë£ ‚ü©)
ùëêùë†ùëíùëû ‚Üêread-config(ùëêùë†ùëíùëû)
if |ùëêùë†ùëíùëû | = ùúà then
ùëëùëúùëõùëí ‚Üê ùë°ùëüùë¢ùëí

else

ùúà ‚Üê |ùëêùë†ùëíùëû |

end while
return ùë£
end operation

32:

34:

36:

38:

40:

42:

44:

46:

basic structure of ARES. At a high-level, a write (or read) operation is executed where the client: (ùëñ) obtains the latest
configuration sequence by using the read-config action of the reconfiguration service, (ùëñùëñ) queries the configurations,
in ùëêùë†ùëíùëû, starting from the last finalized configuration to the end of the discovered configuration sequence, for the latest
‚ü®ùë°ùëéùëî, ùë£ùëéùëôùë¢ùëí‚ü© pair with a help of get-tag (or get-data) operation as specified for each configuration, and (ùëñùëñùëñ) repeatedly
propagates a new ‚ü®ùë°ùëéùëî‚Ä≤, ùë£ùëéùëôùë¢ùëí ‚Ä≤‚ü© pair (the largest ‚ü®ùë°ùëéùëî, ùë£ùëéùëôùë¢ùëí‚ü© pair) with put-data in the last configuration of its local
sequence, until no additional configuration is observed. In more detail, the algorithm of a read or write operation ùúã is as
follows (see Alg. 4):

A write (or read) operation is invoked at a client ùëù when line Alg. 4:8 (resp. line Alg. 4:31) is executed. At first, ùëù

issues a read-config action to obtain the latest introduced configuration in Gùêø, in both operations.

If ùúã is a write ùëù detects the last finalized entry in ùëêùë†ùëíùëû, say ùúá, and performs a ùëêùë†ùëíùëû [ ùëó].ùëêùëúùëõùëì .get-tag() action, for
ùúá ‚â§ ùëó ‚â§ |ùëêùë†ùëíùëû| (line Alg. 4:9). Then ùëù discovers the maximum tag among all the returned tags (ùúèùëöùëéùë• ), and it increments
the maximum tag discovered (by incrementing the integer part of ùúèùëöùëéùë• ), generating a new tag, say ùúèùëõùëíùë§. It assigns ‚ü®ùúè, ùë£‚ü©
to ‚ü®ùúèùëõùëíùë§, ùë£ùëéùëô‚ü©, where ùë£ùëéùëô is the value he wants to write (Line Alg. 4:13).

if ùúã is a read, ùëù detects the last finalized entry in ùëêùë†ùëíùëû, say ùúá, and performs a ùëêùë†ùëíùëû[ ùëó].ùëêùëúùëõùëì .get-data() action, for
ùúá ‚â§ ùëó ‚â§ |ùëêùë†ùëíùëû| (line Alg. 4:32). Then ùëù discovers the maximum tag-value pair (‚ü®ùúèùëöùëéùë• , ùë£ùëöùëéùë• ‚ü©) among the replies, and
assigns ‚ü®ùúè, ùë£‚ü© to ‚ü®ùúèùëöùëéùë• , ùë£ùëöùëéùë• ‚ü©.

Once specifying the ‚ü®ùúè, ùë£‚ü© to be propagated, both reads and writes execute the ùëêùë†ùëíùëû[ùúà].ùëê ùëì ùëî.put-data(‚ü®ùúè, ùë£‚ü©) action,
where ùúà = |ùëêùë†ùëíùëû|, followed by executing read-config action, to examine whether new configurations were introduced
in Gùêø. The repeat these steps until no new configuration is discovered (lines Alg. 4:15‚Äì21, or lines Alg. 4:37‚Äì43). Let

Manuscript submitted to ACM

12Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

ùëêùë†ùëíùëû‚Ä≤ be the sequence returned by the read-config action. If |ùëêùë†ùëíùëû‚Ä≤| = |ùëêùë†ùëíùëû| then no new configuration is introduced, and
the read/write operation terminates; otherwise, ùëù sets ùëêùë†ùëíùëû to ùëêùë†ùëíùëû‚Ä≤ and repeats the two actions. Note, in an execution of
ARES, two consecutive read-config operations that return ùëêùë†ùëíùëû‚Ä≤ and ùëêùë†ùëíùëû‚Ä≤‚Ä≤ respectively must hold that ùëêùë†ùëíùëû‚Ä≤ is a prefix of
ùëêùë†ùëíùëû‚Ä≤‚Ä≤, and hence |ùëêùë†ùëíùëû‚Ä≤| = |ùëêùë†ùëíùëû‚Ä≤‚Ä≤| only if ùëêùë†ùëíùëû‚Ä≤ = ùëêùë†ùëíùëû‚Ä≤‚Ä≤. Finally, if ùúã is a read operation the value with the highest tag
discovered is returned to the client.

Discussion ARES shares similarities with previous algorithms like RAMBO [24] and the framework in [40]. The

reconfiguration technique used in ARES ensures the prefix property on the configuration sequence (resembling a blockchain

data structure [35]) while the array structure in RAMBO allowed nodes to maintain an incomplete reconfiguration history.

On the other hand, the DAP usage, exploits a different viewpoint compared to [40], allowing implementations of atomic

read/write registers without relying on strong objects, like ranked registers [15].

5 IMPLEMENTATION OF THE DAPS

In this section, we present an implementation of the DAPs, that satisfies the properties in Property 1, for a configuration ùëê,
with ùëõ servers using a [ùëõ, ùëò] MDS coding scheme for storage. We implement an instance of the algorithm in a configuration
of ùëõ server processes. We store each coded element ùëêùëñ , corresponding to an object at server ùë†ùëñ , where ùëñ = 1, ¬∑ ¬∑ ¬∑ , ùëõ. The
implementations of DAP primitives used in ARES are shown in Alg. 5, and the servers‚Äô responses in Alg. 6.

Algorithm 5 DAP implementation for ARES.

at each process ùëùùëñ ‚àà I

2: procedure c.get-tag()

4:

6:

send (QUERY-TAG) to each ùë† ‚àà ùëê.ùëÜùëíùëü ùë£ùëíùëüùë†
until ùëùùëñ receives ‚ü®ùë°ùë† ‚ü© from (cid:6) ùëõ+ùëò
2
ùë°ùëöùëéùë• ‚Üê max( {ùë°ùë† : received ùë°ùë† from ùë† })
return ùë°ùëöùëéùë•
end procedure

(cid:7) servers in ùëê.ùëÜùëíùëü ùë£ùëíùëüùë†

8: procedure c.get-data()

send (QUERY-LIST) to each ùë† ‚àà ùëê.ùëÜùëíùëü ùë£ùëíùëüùë†
until ùëùùëñ receives ùêøùëñùë†ùë°ùë† from each server ùë† ‚àà Sùëî s.t. |Sùëî | =

10:

(cid:7) and Sùëî ‚äÇ ùëê.ùëÜùëíùëü ùë£ùëíùëüùë†

(cid:6) ùëõ+ùëò
2
ùëá ùëéùëîùë† ‚â•ùëò

‚àó = set of tags that appears in ùëò lists

12:

14:

16:

ùëëùëíùëê = set of tags that appears in ùëò lists with values

ùëá ùëéùëîùë† ‚â•ùëò
ùëöùëéùë• ‚Üê maxùëá ùëéùëîùë† ‚â•ùëò
ùë° ‚àó
‚àó
ùëöùëéùë• ‚Üê maxùëá ùëéùëîùë† ‚â•ùëò
ùë°ùëëùëíùëê
ùëëùëíùëê
if ùë°ùëëùëíùëê
ùëöùëéùë• = ùë° ‚àó
ùëöùëéùë• then
ùë£ ‚Üê decode value for ùë°ùëëùëíùëê
ùëöùëéùë•

return ‚ü®ùë°ùëëùëíùëê
18: end procedure

ùëöùëéùë• , ùë£ ‚ü©

procedure c.put-data(‚ü®ùúè, ùë£ ‚ü©))

20:

22:

ùëêùëúùëëùëí-ùëíùëôùëíùëöùë† = [ (ùúè, ùëí1), . . . , (ùúè, ùëíùëõ) ], ùëíùëñ = Œ¶ùëñ (ùë£)
send (PUT-DATA, ‚ü®ùúè, ùëíùëñ ‚ü©) to each ùë†ùëñ ‚àà ùëê.ùëÜùëíùëü ùë£ùëíùëüùë†
until ùëùùëñ receives ACK from (cid:6) ùëõ+ùëò
2

(cid:7) servers in ùëê.ùëÜùëíùëü ùë£ùëíùëüùë†

end procedure

Each server ùë†ùëñ stores one state variable, ùêøùëñùë†ùë°, which is a set of up to (ùõø + 1) (tag, coded-element) pairs. Initially the set

at ùë†ùëñ contains a single element, ùêøùëñùë†ùë° = {(ùë°0, Œ¶ùëñ (ùë£0)}. Below we describe the implementation of the DAPs.

tags in their ùêøùëñùë†ùë°ùë†, and awaits responses from

ùëê.get-tag(): A client, during the execution of a ùëê.get-tag() primitive, queries all the servers in ùëê.ùëÜùëíùëüùë£ùëíùëüùë† for the highest
servers. A server upon receiving the GET-TAG request, responds to

(cid:108) ùëõ+ùëò
2
the client with the highest tag, as ùúèùëöùëéùë• ‚â° max(ùë°,ùëê) ‚ààùêøùëñùë†ùë° ùë°. Once the client receives the tags from
the highest tag ùë° and returns it .

(cid:109)

(cid:108) ùëõ+ùëò
2

servers, it selects

(cid:109)

ùëê.put-data(‚ü®ùë°ùë§, ùë£‚ü©): During the execution of the primitive ùëê.put-data(‚ü®ùë°ùë§, ùë£‚ü©), a client sends the pair (ùë°ùë§, Œ¶ùëñ (ùë£)) to
each server ùë†ùëñ ‚àà ùëê.ùëÜùëíùëüùë£ùëíùëüùë†. When a server ùë†ùëñ receives a message (PUT-DATA, ùë°ùë§, ùëêùëñ ) , it adds the pair in its local ùêøùëñùë†ùë°, trims
the pairs with the smallest tags exceeding the length (ùõø + 1) of the ùêøùëñùë†ùë° , and replies with an ack to the client. In particular,
ùë†ùëñ replaces the coded-elements of the older tags with ‚ä•, and maintains only the coded-elements associated with the (ùõø + 1)
Manuscript submitted to ACM

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

13

Algorithm 6 The response protocols at any server ùë†ùëñ ‚àà S in ARES for client requests.

at each server ùë†ùëñ ‚àà S in configuration ùëêùëò

end receive

2: State Variables:

ùêøùëñùë†ùë° ‚äÜ T √ó Cùë† , initially { (ùë°0, Œ¶ùëñ (ùë£0)) }

4:

Upon receive (QUERY-TAG) ùë†ùëñ , ùëêùëò from ùëû

ùúèùëöùëéùë• = max(ùë°,ùëê ) ‚ààùêøùëñùë†ùë° ùë°
Send ùúèùëöùëéùë• to ùëû

6: end receive

Upon receive (QUERY-LIST) ùë†ùëñ , ùëêùëò from ùëû

Send ùêøùëñùë†ùë° to ùëû

8:

10:

12:

14:

16:

Upon receive (PUT-DATA, ‚ü®ùúè, ùëíùëñ ‚ü©) ùë†ùëñ , ùëêùëò from ùëû

ùêøùëñùë†ùë° ‚Üê ùêøùëñùë†ùë° ‚à™ { ‚ü®ùúè, ùëíùëñ ‚ü© }
if |ùêøùëñùë†ùë° | > ùõø + 1 then

ùúèùëöùëñùëõ ‚Üê min{ùë° : ‚ü®ùë°, ‚àó‚ü© ‚àà ùêøùëñùë†ùë° }

/* remove the coded value and retain the tag */

ùêøùëñùë†ùë° ‚Üê ùêøùëñùë†ùë° \ { ‚ü®ùúè, ùëí ‚ü© : ùúè = ùúèùëöùëñùëõ ‚àß ‚ü®ùúè, ùëí ‚ü© ‚àà ùêøùëñùë†ùë° }
ùêøùëñùë†ùë° ‚Üê ùêøùëñùë†ùë° ‚à™ { (ùúèùëöùëñùëõ, ‚ä•) }

Send ACK to ùëû

18: end receive

highest tags in the ùêøùëñùë†ùë° (see Line Alg. 6:16). The client completes the primitive operation after getting acks from
servers.

(cid:109)

(cid:108) ùëõ+ùëò
2

ùëê.get-data(): A client, during the execution of a ùëê.get-data() primitive, queries all the servers in ùëê.ùëÜùëíùëüùë£ùëíùëüùë† for their
local variable ùêøùëñùë†ùë°, and awaits responses from
servers, it selects
the highest tag ùë°, such that: (ùëñ) its corresponding value ùë£ is decodable from the coded elements in the lists; and (ùëñùëñ) ùë° is the
highest tag seen from the responses of at least ùëò ùêøùëñùë†ùë°ùë† (see lines Alg. 5:11-14) and returns the pair (ùë°, ùë£). Note that in the
case where anyone of the above conditions is not satisfied the corresponding read operation does not complete.

servers. Once the client receives ùêøùëñùë†ùë°ùë† from

(cid:108) ùëõ+ùëò
2

(cid:108) ùëõ+ùëò
2

(cid:109)

(cid:109)

5.1 Safety (Property 1) proof of the DAPs

Correctness. In this section we are concerned with only one configuration ùëê, consisting of a set of servers ùëê.ùëÜùëíùëüùë£ùëíùëüùë†. We
assume that at most ùëì ‚â§ ùëõ‚àíùëò
servers from ùëê.ùëÜùëíùëüùë£ùëíùëüùë† may crash. Lemma 2 states that the DAP implementation satisfies
2
the consistency properties Property 1 which will be used to imply the atomicity of the ARES algorithm.

THEOREM 2 (SAFETY). Let Œ† a set of complete DAP operations of Algorithm 5 in a configuration ùëê ‚àà C, c.get-tag,

c.get-data and c.put-data, of an execution ùúâ. Then, every pair of operations ùúô, ùúã ‚àà Œ† satisfy Property 1.

PROOF. As mentioned above we are concerned with only configuration ùëê, and therefore, in our proofs it suffices to
examine only one configuration. Let ùúâ be some execution of ARES, then we consider two cases for ùúã for proving property
ùê∂1: ùúã is a get-tag, or ùúã is a get-data primitive.

(cid:109)

(cid:108) ùëõ+ùëò
2

servers that responds to ùëêùúô , during ùúô. Denote by ùëÜùúã the set of

Case (ùëé): ùúô is ùëê.put-data(‚ü®ùúèùúô, ùë£ùúô ‚ü©) and ùúã is a ùëê.get-tag() returns ùúèùúã ‚àà T . Let ùëêùúô and ùëêùúã denote the clients that invokes
(cid:109)
(cid:108) ùëõ+ùëò
2

ùúô and ùúã in ùúâ. Let ùëÜùúô ‚äÇ S denote the set of
servers that responds to ùëêùúã , during ùúã. Let ùëá1 be a point in execution ùúâ after the completion of ùúô and before the invocation
of ùúã. Because ùúã is invoked after ùëá1, therefore, at ùëá1 each of the servers in ùëÜùúô contains ùë°ùúô in its ùêøùëñùë†ùë° variable. Note that,
once a tag is added to ùêøùëñùë†ùë°, it is never removed. Therefore, during ùúã, any server in ùëÜùúô ‚à© ùëÜùúã responds with ùêøùëñùë†ùë° containing
ùë°ùúô to ùëêùúã . Note that since |ùëÜùúô | = |ùëÜùúã | =
ùëöùëéùë• at ùëêùúã , during ùúã is at least as large as
ùë°ùúô , i.e., ùë°ùúã ‚â• ùë°ùúô . Therefore, it suffices to prove our claim with respect to the tags and the decodability of its corresponding
value.

implies |ùëÜùúô ‚à© ùëÜùúã | ‚â• ùëò, and hence ùë°ùëëùëíùëê

(cid:108) ùëõ+ùëò
2

(cid:109)

Case (ùëè): ùúô is ùëê.put-data(‚ü®ùúèùúô, ùë£ùúô ‚ü©) and ùúã is a ùëê.get-data() returns ‚ü®ùúèùúã , ùë£ùúã ‚ü© ‚àà T √ó V. As above, let ùëêùúô and ùëêùúã be
the clients that invokes ùúô and ùúã. Let ùëÜùúô and ùëÜùúã be the set of servers that responds to ùëêùúô and ùëêùúã , respectively. Arguing
Manuscript submitted to ACM

14Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

as above, |ùëÜùúô ‚à© ùëÜùúã | ‚â• ùëò and every server in ùëÜùúô ‚à© ùëÜùúã sends ùë°ùúô in response to ùëêùúô , during ùúã, in their ùêøùëñùë†ùë°‚Äôs and hence
ùë°ùúô ‚àà ùëá ùëéùëîùë† ‚â•ùëò
. Now, because ùúã completes in ùúâ, hence we have ùë° ‚àó
ùëëùëíùëê so
‚àó
ùë°ùúã ‚â• maxùëá ùëéùëîùë† ‚â•ùëò
ùëëùëíùëê = maxùëá ùëéùëîùë† ‚â•ùëò
‚àó ‚â• ùë°ùúô . Note that each tag is always associated with its corresponding value ùë£ùúã , or the
corresponding coded elements Œ¶ùë† (ùë£ùúã ) for ùë† ‚àà S.

ùëöùëéùë• . Note that maxùëá ùëéùëîùë† ‚â•ùëò

‚àó ‚â• maxùëá ùëéùëîùë† ‚â•ùëò

ùëöùëéùë• = ùë°ùëëùëíùëê

Next, we prove the ùê∂2 property of DAP for the ARES algorithm. Note that the initial values of the ùêøùëñùë†ùë° variable in
each servers ùë† in S is {(ùë°0, Œ¶ùë† (ùë£ùúã ))}. Moreover, from an inspection of the steps of the algorithm, new tags in the ùêøùëñùë†ùë°
variable of any servers of any servers is introduced via put-data operation. Since ùë°ùúã is returned by a get-tag or get-data
operation then it must be that either ùë°ùúã = ùë°0 or ùë°ùúã > ùë°0. In the case where ùë°ùúã = ùë°0 then we have nothing to prove. If ùë°ùúã > ùë°0
then there must be a put-data(ùë°ùúã , ùë£ùúã ) operation ùúô. To show that for every ùúã it cannot be that ùúô completes before ùúã, we
adopt by a contradiction. Suppose for every ùúã, ùúô completes before ùúã begins, then clearly ùë°ùúã cannot be returned ùúô, a
‚ñ°
contradiction.

Liveness. To reason about the liveness of the proposed DAPs, we define a concurrency parameter ùõø which captures all
the put-data operations that overlap with the get-data, until the time the client has all data needed to attempt decoding
a value. However, we ignore those put-data operations that might have started in the past, and never completed yet, if
their tags are less than that of any put-data that completed before the get-data started. This allows us to ignore put-data
operations due to failed clients, while counting concurrency, as long as the failed put-data operations are followed by
a successful put-data that completed before the get-data started. In order to define the amount of concurrency in our
specific implementation of the DAPs presented in this section the following definition captures the put-data operations
that overlap with the get-data, until the client has all data required to decode the value.

DEFINITION 3 (VALID get-data OPERATIONS). A get-data operation ùúã from a process ùëù is valid if ùëù does not crash

until the reception of

responses during the get-data phase.

(cid:109)

(cid:108) ùëõ+ùëò
2

DEFINITION 4 (put-data CONCURRENT WITH A VALID get-data). Consider a valid get-data operation ùúã from a
process ùëù. Let ùëá1 denote the point of initiation of ùúã. For ùúã, let ùëá2 denote the earliest point of time during the execution
responses. Consider the set Œ£ = {ùúô : ùúô is any put-data operation that completes before
when ùëù receives all the
ùúã is initiated}, and let ùúô ‚àó = arg maxùúô ‚ààŒ£ ùë°ùëéùëî(ùúô). Next, consider the set Œõ = {ùúÜ : ùúÜ is any put-data operation that starts
before ùëá2 such that ùë°ùëéùëî(ùúÜ) > ùë°ùëéùëî(ùúô ‚àó)}. We define the number of put-data concurrent with the valid get-data ùúã to be the
cardinality of the set Œõ.

(cid:108) ùëõ+ùëò
2

(cid:109)

Termination (and hence liveness) of the DAPs is guaranteed in an execution ùúâ, provided that a process no more than
ùëì servers in ùëê.ùëÜùëíùëüùë£ùëíùëüùë† crash, and no more that ùõø put-data may be concurrent at any point in ùúâ. If the failure model is
satisfied, then any operation invoked by a non-faulty client will collect the necessary replies independently of the progress
of any other client process in the system. Preserving ùõø on the other hand, ensures that any operation will be able to decode
a written value. These are captured in the following theorem:

THEOREM 5 (LIVENESS). Let ùúâ be well-formed and fair execution of DAPs, with an [ùëõ, ùëò] MDS code, where ùëõ is
the number of servers out of which no more than ùëõ‚àíùëò
2 may crash, and ùõø be the maximum number of put-data operations
concurrent with any valid get-data operation. Then any get-data and put-data operation ùúã invoked by a process ùëù
terminates in ùúâ if ùëù does not crash between the invocation and response steps of ùúã.

PROOF. Note that in the read and write operation the get-tag and put-data operations initiated by any non-faulty client
always complete. Therefore, the liveness property with respect to any write operation is clear because it uses only get-tag
Manuscript submitted to ACM

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

15

(cid:109)

(cid:108) ùëõ+ùëò
2

(cid:109)

(cid:108) ùëõ+ùëò
2

and put-data operations of the DAP. So, we focus on proving the liveness property of any read operation ùúã, specifically,
the get-data operation completes. Let ùúâ be and execution of ARES and let ùëêùúî and ùëêùúã be the clients that invokes the write
operation ùúî and read operation ùúã, respectively.

Let ùëÜùúî be the set of

servers that responds to ùëêùúî , in the put-data operations, in ùúî. Let ùëÜùúã be the set of

servers that responds to ùëêùúã during the get-data step of ùúã. Note that in ùúâ at the point execution ùëá1, just before the execution
of ùúã, none of the write operations in Œõ is complete. Observe that, by algorithm design, the coded-elements corresponding
to ùë°ùúî are garbage-collected from the ùêøùëñùë†ùë° variable of a server only if more than ùõø higher tags are introduced by subsequent
writes into the server. Since the number of concurrent writes |Œõ|, s.t. ùõø > |Œõ| the corresponding value of tag ùë°ùúî is not
garbage collected in ùúâ, at least until execution point ùëá2 in any of the servers in ùëÜùúî .

Therefore, during the execution fragment between the execution points ùëá1 and ùëá2 of the execution ùúâ, the tag and
coded-element pair is present in the ùêøùëñùë†ùë° variable of every in ùëÜùúî that is active. As a result, the tag and coded-element pairs,
(cid:109)
(ùë°ùúî, Œ¶ùë† (ùë£ùúî )) exists in the ùêøùëñùë†ùë° received from any ùë† ‚àà ùëÜùúî ‚à© ùëÜùúã during operation ùúã. Note that since |ùëÜùúî | = |ùëÜùúã | =
hence |ùëÜùúî ‚à© ùëÜùúã | ‚â• ùëò and hence ùë°ùúî ‚àà ùëá ùëéùëîùë† ‚â•ùëò
ùëëùëíùëê , the set of decode-able tag, i.e., the value ùë£ùúî can be decoded by ùëêùúã in
ùúã, which demonstrates that ùëá ùëéùëîùë† ‚â•ùëò
ùëöùëéùë• via a contradiction: we assume
ùëëùëíùëê . Now, consider any tag ùë°, which exists due to our assumption, such that, ùë° ‚àà ùëá ùëéùëîùë† ‚â•ùëò
‚àó > maxùëá ùëéùëîùë† ‚â•ùëò
maxùëá ùëéùëîùë† ‚â•ùëò
,
ùë° ‚àâ ùëá ùëéùëîùë† ‚â•ùëò
ùëëùëíùëê and ùë° > ùë°ùëëùëíùëê
ùëöùëéùë• in their ùêøùëñùë†ùë° variables to ùëêùúã .
Note that since ùëò > ùëõ/3 hence |ùëÜùúî ‚à© ùëÜùëò
ùúã ‚â† ‚àÖ. Then ùë° must be in some servers in ùëÜùúî at
ùëá2 and since ùë° > ùë°ùëëùëíùëê
ùëöùëéùë• ‚â• ùë°ùúî . Now since |Œõ| < ùõø hence (ùë°, ‚ä•) cannot be in any server at ùëá2 because there are not enough
concurrent write operations (i.e., writes in Œõ) to garbage-collect the coded-elements corresponding to tag ùë°, which also
holds for tag ùë° ‚àó
‚ñ°
ùëëùëíùëê , a contradiction.

ùúã ‚äÇ ùëÜ be any subset of ùëò servers that responds with ùë° ‚àó

ùëëùëíùëê ‚â† ‚àÖ. Next we want to argue that ùë° ‚àó

ùëöùëéùë• . In that case, ùë° must be in ùëá ùëéùëî ‚â•ùëò

(cid:7) ‚â• 1, i.e., ùëÜùúî ‚à© ùëÜùëò

ùëöùëéùë• . Let ùëÜùëò

ùëöùëéùë• = ùë°ùëëùëíùëê

+ (cid:6) ùëõ+1
3

(cid:108) ùëõ+ùëò
2

(cid:108) ùëõ+ùëò
2

ùúã | ‚â•

(cid:109)

‚àó

6 CORRECTNESS OF ARES

In this section, we prove that ARES correctly implements an atomic, read/write, shared storage service. The correctness

of ARES highly depends on the way the configuration sequence is constructed at each client process. Also, atomicity is
ensured if the DAP implementation in each configuration ùëêùëñ satisfies Property 1. Thus, we begin by showing some critical
properties preserved by the reconfiguration service proposed in ARES in subsection 6.1, and then we proof the correctness

of ARES in subsection 6.2 when those properties hold and the DAPs used in each configuration satisfy Property 1.

We proceed by first introducing some definitions and notation, that we use in the proofs that follow.

Notations and definitions. For a server ùë†, we use the notation ùë†.ùë£ùëéùëü |ùúé to refer to the value of the state variable ùë£ùëéùëü , in
ùë†, at a state ùúé of an execution ùúâ. If server ùë† crashes at a state ùúéùëì in an execution ùúâ then ùë†.ùë£ùëéùëü |ùúé ‚âú ùë†.ùë£ùëéùëü |ùúéùëì for any state
variable ùë£ùëéùëü and for any state ùúé that appears after ùúéùëì in ùúâ.

We define as the tag of a configuration ùëê the smallest tag among the maximum tags found in each quorum of ùëê. This
is essentially the smallest tag that an operation may witness when receiving replies from a single quorum in ùëê. More
formally:

DEFINITION 6 (TAG OF A CONFIGURATION). Let ùëê ‚àà C be a configuration, ùúé be a state in some execution ùúâ then we
define the tag of ùëê at state ùúé as ùë°ùëéùëî(ùëê)|ùúé ‚âú minùëÑ ‚ààùëê.ùëÑùë¢ùëúùëüùë¢ùëöùë† maxùë† ‚ààùëÑ (ùë†.ùë°ùëéùëî|ùúé ). We drop the suffix |ùúé , and simply denote
as ùë°ùëéùëî(ùëê), when the state is clear from the context.

Next we provide the notation to express the configuration sequence witnessed by a process ùëù in a state ùúé (as ùëù.ùëêùë†ùëíùëû|ùúé ),

ùëù
ùëù
the last finalized configuration in that sequence (as ùúá (c
ùúé )), and the length of that sequence (as ùúà (c
ùúé )). More formally:

Manuscript submitted to ACM

16Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

ùëù
ùúé for ùëù.ùëêùë†ùëíùëû|ùúé , i.e., the
DEFINITION 7. Let ùúé be any point in an execution of ARES and suppose we use the notation c
ùëù
ùëù
ùëù
ùëù
ùúé ) ‚âú |c
ùúé ) ‚âú max{ùëñ : c
ùëêùë†ùëíùëû variable at process ùëù at the state ùúé. Then we define as ùúá (c
ùúé [ùëñ].ùë†ùë°ùëéùë°ùë¢ùë† = ùêπ } and ùúà (c
ùúé |, where
ùëù
ùëù
ùúé | is the length of the configuration vector c
|c
ùúé .

Last, we define the prefix operation on two configuration sequences.

DEFINITION 8 (PREFIX ORDER). Let x and y be any two configuration sequences. We say that x is a prefix of y,

denoted by x ‚™Øùëù y, if x[ ùëó].ùëê ùëì ùëî = y[ ùëó].ùëê ùëì ùëî, for all ùëó such that x[ ùëó] ‚â† ‚ä•.

6.1 Reconfiguration Protocol Properties

In this section we analyze the properties that we can achieve through our reconfiguration algorithm. In high-level, we do

show that the following properties are preserved:

i configuration uniqueness: the configuration sequences in any two processes have identical configuration at any

place ùëñ,

ii sequence prefix: the configuration sequence witnessed by an operation is a prefix of the sequence witnessed by

any succeeding operation, and

iii sequence progress: if the configuration with index ùëñ is finalized during an operation, then a configuration ùëó, for

ùëó ‚â• ùëñ, will be finalized for a succeeding operation.

The first lemma shows that any two configuration sequences have the same configuration identifiers in the same

indexes.

LEMMA 9. For any reconfigurer ùëü that invokes an reconfig(ùëê) action in an execution ùúâ of the algorithm, If ùëü chooses
to install ùëê in index ùëò of its local ùëü .ùëêùë†ùëíùëû vector, then ùëü invokes the ùê∂ùëúùëõùë† [ùëò ‚àí 1].ùëùùëüùëúùëùùëúùë†ùëí (ùëê) instance over configuration
ùëü .ùëêùë†ùëíùëû [ùëò ‚àí 1].ùëê ùëì ùëî.

PROOF. It follows directly from the algorithm.

‚ñ°

LEMMA 10. If a server ùë† sets ùë†.ùëõùëíùë•ùë°ùê∂ to ‚ü®ùëê, ùêπ ‚ü© at some state ùúé in an execution ùúâ of the algorithm, then ùë†.ùëõùëíùë•ùë°ùê∂ = ‚ü®ùëê, ùêπ ‚ü©

for any state ùúé ‚Ä≤ that appears after ùúé in ùúâ.

PROOF. Notice that a server ùë† updates its ùë†.ùëõùëíùë•ùë°ùê∂ variable for some specific configuration ùëêùëò in a state ùúé only when it
receives a WRITE-CONF message. This is either the first WRITE-CONF message received at ùë† for ùëêùëò (and thus ùëõùëíùë•ùë°ùê∂ = ‚ä•),
or ùë†.ùëõùëíùë•ùë°ùê∂ = ‚ü®‚àó, ùëÉ‚ü© and the message received contains a tuple ‚ü®ùëê, ùêπ ‚ü©. Once the tuple becomes equal to ‚ü®ùëê, ùêπ ‚ü© then ùë† does
not satisfy the update condition for ùëêùëò , and hence in any state ùúé ‚Ä≤ after ùúé it does not change ‚ü®ùëê, ùêπ ‚ü©.
‚ñ°

LEMMA 11 (CONFIGURATION UNIQUENESS). For any processes ùëù, ùëû ‚àà I and any states ùúé1, ùúé2 in an execution ùúâ, it

ùëù
must hold that c
ùúé1

ùëû
[ùëñ].ùëê ùëì ùëî = c
ùúé2

ùëù
[ùëñ].ùëê ùëì ùëî, ‚àÄùëñ s.t. c
ùúé1

ùëû
[ùëñ].ùëê ùëì ùëî, c
ùúé2

[ùëñ].ùëê ùëì ùëî ‚â† ‚ä•.

ùëù
PROOF. The lemma holds trivially for c
ùúé1

ùëû
[0].ùëê ùëì ùëî = c
ùúé2

[0].ùëê ùëì ùëî = ùëê0. So in the rest of the proof we focus in the case

where ùëñ > 0. Let us assume w.l.o.g. that ùúé1 appears before ùúé2 in ùúâ.

According to our algorithm a process ùëù sets ùëù.ùëêùë†ùëíùëû [ùëñ].ùëê ùëì ùëî to a configuration identifier ùëê in two cases: (i) either it
received ùëê as the result of the consensus instance in configuration ùëù.ùëêùë†ùëíùëû [ùëñ ‚àí 1].ùëê ùëì ùëî, or (ii) ùëù receives ùë†.ùëõùëíùë•ùë°ùê∂.ùëê ùëì ùëî = ùëê
from a server ùë† ‚àà ùëù.ùëêùë†ùëíùëû [ùëñ ‚àí 1].ùëê ùëì ùëî.ùëÜùëíùëüùë£ùëíùëüùë†. Note here that (i) is possible only when ùëù is a reconfigurer and attempts
to install a new configuration. On the other hand (ii) may be executed by any process in any operation that invokes the

read-config action. We are going to proof this lemma by induction on the configuration index.
Manuscript submitted to ACM

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

17

Base case: The base case of the lemma is when ùëñ = 1. Let us first assume that ùëù and ùëû receive ùëêùëù and ùëêùëû, as the
result of the consensus instance at ùëù.ùëêùë†ùëíùëû [0].ùëê ùëì ùëî and ùëû.ùëêùë†ùëíùëû [0].ùëê ùëì ùëî respectively. By Lemma 9, since both processes
want to install a configuration in ùëñ = 1, then they have to run ùê∂ùëúùëõùë† [0] instance over the configuration stored in their
local ùëêùë†ùëíùëû [0].ùëê ùëì ùëî variable. Since ùëù.ùëêùë†ùëíùëû [0].ùëê ùëì ùëî = ùëû.ùëêùë†ùëíùëû[0].ùëê ùëì ùëî = ùëê0 then both ùê∂ùëúùëõùë† [0] instances run over the same
configuration ùëê0 and thus by the aggreement property the have to decide the same value, say ùëê1. Hence ùëêùëù = ùëêùëû = ùëê1 and
ùëù.ùëêùë†ùëíùëû [1].ùëê ùëì ùëî = ùëû.ùëêùë†ùëíùëû [1].ùëê ùëì ùëî = ùëê1.

Let us examine the case now where ùëù or ùëû assign a configuration ùëê they received from some server ùë† ‚àà ùëê0.ùëÜùëíùëüùë£ùëíùëüùë†.
According to the algorithm only the configuration that has been decided by the consensus instance on ùëê0 is propagated
to the servers in ùëê0.ùëÜùëíùëüùë£ùëíùëüùë†. If ùëê1 is the decided configuration, then ‚àÄùë† ‚àà ùëê0.ùëÜùëíùëüùë£ùëíùëüùë† such that ùë†.ùëõùëíùë•ùë°ùê∂ (ùëê0) ‚â† ‚ä•, it
holds that ùë†.ùëõùëíùë•ùë°ùê∂ (ùê∂0) = ‚ü®ùëê1, ‚àó‚ü©. So if ùëù or ùëû set ùëù.ùëêùë†ùëíùëû [1].ùëê ùëì ùëî or ùëû.ùëêùë†ùëíùëû[1].ùëê ùëì ùëî to some received configuration, then
ùëù.ùëêùë†ùëíùëû [1].ùëê ùëì ùëî = ùëû.ùëêùë†ùëíùëû [1].ùëê ùëì ùëî = ùëê1 in this case as well.

ùëû
[ùëò] = c
ùúé2

[ùëò] for some ùëò, ùëò ‚â• 1.

ùëù
Hypothesis: We assume that c
ùúé1
Induction Step: We need to show that the lemma holds for ùëñ = ùëò + 1. If both processes retrieve ùëù.ùëêùë†ùëíùëû[ùëò + 1].ùëê ùëì ùëî
and ùëû.ùëêùë†ùëíùëû [ùëò + 1].ùëê ùëì ùëî through consensus, then both ùëù and ùëû run consensus over the previous configuration. Since
ùëù
[ùëò] then both process will receive the same decided value, say ùëêùëò+1, and
according to our hypothesis c
ùúé1
hence ùëù.ùëêùë†ùëíùëû[ùëò + 1].ùëê ùëì ùëî = ùëû.ùëêùë†ùëíùëû [ùëò + 1].ùëê ùëì ùëî = ùëêùëò+1. Similar to the base case, a server in ùëêùëò .ùëÜùëíùëüùë£ùëíùëüùë† only receives the
configuration ùëêùëò+1 decided by the consensus instance run over ùëêùëò . So processes ùëù and ùëû can only receive ùëêùëò+1 from some
server in ùëêùëò .ùëÜùëíùëüùë£ùëíùëüùë† so they can only assign ùëù.ùëêùë†ùëíùëû[ùëò + 1].ùëê ùëì ùëî = ùëû.ùëêùë†ùëíùëû[ùëò + 1].ùëê ùëì ùëî = ùëêùëò+1 at Line A2:8. That completes
‚ñ°
the proof.

ùëû
[ùëò] = c
ùúé2

Lemma 11 showed that any two operations store the same configuration in any cell ùëò of their ùëêùë†ùëíùëû variable. It is not
known however if the two processes discover the same number of configuration ids. In the following lemmas we will
show that if a process learns about a configuration in a cell ùëò then it also learns about all configuration ids for every index
ùëñ, such that 0 ‚â§ ùëñ ‚â§ ùëò ‚àí 1.

ùëù
LEMMA 12. In any execution ùúâ of the algorithm , If for any process ùëù ‚àà I, c
ùúé [ùëñ] ‚â† ‚ä• in some state ùúé in ùúâ, then
ùëù
ùúé‚Ä≤ [ùëñ] ‚â† ‚ä• in any state ùúé ‚Ä≤ that appears after ùúé in ùúâ.
c

ùëù
‚àó [ùëñ] either after the invocation of a consensus instance, or while executing the
PROOF. A value is assigned to c
read-config action. Since any configuration proposed for installation cannot be ‚ä• (A2:7), and since there is at least one
configuration proposed in the consensus instance (the one from ùëù), then by the validity of the consensus service the
ùëù
ùëù
decision will be a configuration ùëê ‚â† ‚ä•. Thus, in this case c
‚àó [ùëñ] is
‚àó [ùëñ] cannot be ‚ä•. Also in the read-config procedure, c
ùëù
ùúé [ùëñ] ‚â† ‚ä• at state ùúé then it cannot become ‚ä• in any
assigned to a value different than ‚ä• according to Line A2:8. Hence, if c
state ùúé ‚Ä≤ after ùúé in execution ùúâ.
‚ñ°

ùëù
LEMMA 13. Let ùúé1 be some state in an execution ùúâ of the algorithm. Then for any process ùëù, if ùëò = ùëöùëéùë• {ùëñ : c
ùúé1

[ùëñ] ‚â† ‚ä•},

ùëù
then c
ùúé1

[ ùëó] ‚â† ‚ä•, for 0 ‚â§ ùëó < ùëò.

ùëù
[ùëò] ‚â† ‚ä•, then ùëù assigned ùëêùëò to c
ùúé1

ùëù
PROOF. Let us assume to derive contradiction that there exists ùëó < ùëò such that c
ùúé1

[ ùëó + 1] ‚â† ‚ä•.
ùëù
[ùëò], say ùëêùëò . Since
Consider first that ùëó = ùëò ‚àí 1 and that ùúé1 is the state immediately after the assignment of a value to c
ùúé1
ùëù
[ùëò] in one of the following cases: (i) ùëêùëò was the result of the consensus instance,
c
ùúé1
or (ii) ùëù received ùëêùëò from a server during a read-config action. The first case is trivially impossible as according to
ùëù
Lemma 9 ùëù decides for ùëò when it runs consensus over configuration c
[ùëò ‚àí 1].ùëê ùëì ùëî. Since this is equal to ‚ä•, then we
ùúé1
Manuscript submitted to ACM

ùëù
[ ùëó] = ‚ä• and c
ùúé1

18Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

ùëù
assigned c
ùúé1

ùëù
[ùëò] = ùëêùëò in Line A1:8. The
cannot run consensus over a non-existent set of processes. In the second case, ùëù assigns c
ùúé1
ùëù
value ùëêùëò was however obtained when ùëù invoked get-next-config on configuration c
[ùëò ‚àí 1].ùëê ùëì ùëî. In that action, ùëù sends
ùúé1
ùëù
[ùëò ‚àí 1].ùëê ùëì ùëî.ùëÜùëíùëüùë£ùëíùëüùë† and waits until a quorum of servers replies. Since we
READ-CONFIG messages to the servers in c
ùúé1
[ùëò] = ùëêùëò it means that get-next-config terminated at some state ùúé ‚Ä≤ before ùúé1 in ùúâ, and thus: (a) a quorum
ùëù
ùúé‚Ä≤ [ùëò ‚àí 1].ùëê ùëì ùëî.ùëÜùëíùëüùë£ùëíùëüùë† replied, and (b) there exists a server ùë† among those that replied with ùëêùëò . According
of servers in c
ùëù
[ùëò ‚àí 1] = ‚ä• at ùúé1. So if state ùúé ‚Ä≤ is before ùúé1 in ùúâ, then by Lemma 12, it follows that
to our assumption however, c
ùúé1
ùëù
ùúé‚Ä≤ [ùëò ‚àí 1] = ‚ä•. This however implies that ùëù communicated with an empty configuration, and thus no server replied to ùëù.
c
This however contradicts the assumption that a server replied with ùëêùëò to ùëù.

Since any process traverses the configuration sequence starting from the initial configuration ùëê0, then with a simple
‚ñ°

ùëù
induction and similar reasoning we can show that c
ùúé1

[ ùëó] ‚â† ‚ä•, for 0 ‚â§ ùëó ‚â§ ùëò ‚àí 1.

We can now move to an important lemma that shows that any read-config action returns an extension of the configura-
tion sequence returned by any previous read-config action. First, we show that the last finalized configuration observed by
any read-config action is at least as recent as the finalized configuration observed by any subsequent read-config action.

ùëù
ùúé ) = ùëò for some process ùëù, then for any element
LEMMA 14. If at a state ùúé of an execution ùúâ of the algorithm ùúá (c

ùëù
ùëù
ùëù
0 ‚â§ ùëó < ùëò, ‚àÉùëÑ ‚àà c
ùúé [ ùëó + 1].
ùúé [ ùëó].ùëê ùëì ùëî) = c
ùúé [ ùëó].ùëê ùëì ùëî.ùëÑùë¢ùëúùëüùë¢ùëöùë† such that ‚àÄùë† ‚àà ùëÑ, ùë†.ùëõùëíùë•ùë°ùê∂ (c

PROOF. This lemma follows directly from the algorithm. Notice that whenever a process assigns a value to an element

of its local configuration (Lines A1:8 and A2:17), it then propagates this value to a quorum of the previous configuration
ùëù
ùúé‚Ä≤ [ ùëó] in some state ùúé ‚Ä≤ in ùúâ, then ùëù may assign a
(Lines A1:9 and A2:18). So if a process ùëù assigned ùëê ùëó to an element c
ùëù
ùëù
ùëù
ùúé‚Ä≤ [ ùëó]) occurs. During put-config action, ùëù
ùúé‚Ä≤ [ ùëó ‚àí 1].ùëê ùëì ùëî, c
ùúé‚Ä≤‚Ä≤ [ ùëó + 1] only after put-config(c
value to the ùëó + 1 element of c
ùëù
ùëù
ùëù
ùëù
ùúé‚Ä≤ [ ùëó], for
ùúé [ùëò] ‚â† ‚ä•, then ùëù propagated each c
ùúé‚Ä≤ [ ùëó ‚àí 1].ùëê ùëì ùëî.ùëÑùë¢ùëúùëüùë¢ùëöùë†. Hence, if c
ùúé‚Ä≤ [ ùëó] in a quorum ùëÑ ‚àà c
propagates c
ùëù
‚ñ°
0 < ùëó ‚â§ ùëò to a quorum of servers ùëÑ ‚àà c
ùúé‚Ä≤ [ ùëó ‚àí 1].ùëê ùëì ùëî.ùëÑùë¢ùëúùëüùë¢ùëöùë†. And this completes the proof.

LEMMA 15 (SEQUENCE PREFIX). Let ùúã1 and ùúã2 two completed read-config actions invoked by processes ùëù1, ùëù2 ‚àà I
respectively, such that ùúã1 ‚Üí ùúã2 in an execution ùúâ. Let ùúé1 be the state after the response step of ùúã1 and ùúé2 the state after
the response step of ùúã2. Then c

‚™Øùëù c

ùëù1
ùúé1

ùëù2
ùúé2 .

PROOF. Let ùúà1 = ùúà (c
ùëù2
[ùëñ].ùëê ùëì ùëî = c
ùúé2

ùëù1
c
ùúé1
if we can show that ùúà1 ‚â§ ùúà2 then the lemma follows.

) and ùúà2 = ùúà (c

ùëù2
ùúé2

ùëù1
ùúé1

[ùëñ].ùëê ùëì ùëî. Also from Lemma 13 we know that for 0 ‚â§ ùëó ‚â§ ùúà1, c

). By Lemma 11 for any ùëñ such that c

ùëù1
ùúé1

[ùëñ] ‚â† ‚ä• and c

ùëù2
ùúé2
[ ùëó] ‚â† ‚ä•, and 0 ‚â§ ùëó ‚â§ ùúà2, c

[ùëñ] ‚â† ‚ä•, then
ùëù2
[ ùëó] ‚â† ‚ä•. So
ùúé2

ùëù1
ùúé1

ùëù1
ùúé1

Let ùúá = ùúá (c

[ ùëó].ùëê ùëì ùëî.ùëÑùë¢ùëúùëüùë¢ùëöùë†, for 0 ‚â§ ùëó < ùúà1, such that ‚àÄùë† ‚àà ùëÑ, ùë†.ùëõùëíùë•ùë°ùê∂ = c

ùëù2
ùúé‚Ä≤ ) be the last finalized element which ùëù2 established in the beginning of the read-config action ùúã2 (Line
A2:2) at some state ùúé ‚Ä≤ before ùúé2. It is easy to see that ùúá ‚â§ ùúà2. If ùúà1 ‚â§ ùúá then ùúà1 ‚â§ ùúà2 and the lemma follows. Thus, it
remains to examine the case where ùúá < ùúà1. Notice that since ùúã1 ‚Üí ùúã2 then ùúé1 appears before ùúé ‚Ä≤ in execution ùúâ. By
[ ùëó + 1]. Since
Lemma 14, we know that by ùúé1, ‚àÉùëÑ ‚àà c
ùúá < ùúà1, then it must be the case that ‚àÉùëÑ ‚àà c
[ùúá + 1]. But by Lemma
ùëù2
ùúé‚Ä≤ [ùúá].ùëê ùëì ùëî. Let ùëÑ ‚Ä≤ be the quorum that replies to the read-next-config occurred in ùëù2, on
11, we know that c
[ùúá + 1] to
configuration c
ùëù1
ùëù2 during ùúã2. Since c
[ùúá + 1], and repeats the process in the configuration
ùúé1
ùëù2
[ ùëó].ùëê ùëì ùëî, for ùúá ‚â§ ùëó < ùúà1, has a quorum of servers with ùë†.ùëõùëíùë•ùë°ùê∂, then by a
‚àó [ùúá + 1].ùëê ùëì ùëî. Since every configuration c
c
simple induction it can be shown that the process will be repeated for at least ùúà1 ‚àí ùúá iterations, and every configuration
ùëù2
[ ùëó], for 0 ‚â§ ùëó ‚â§ ùúà1. Hence ùúà1 ‚â§ ùúà2 and the lemma follows
ùúé‚Ä≤‚Ä≤ [ ùëó] = c
c
‚ñ°
in this case as well.

ùëù2
ùúé‚Ä≤ [ùúá].ùëê ùëì ùëî. By definition ùëÑ ‚à© ùëÑ ‚Ä≤ ‚â† ‚àÖ, thus there is a server ùë† ‚àà ùëÑ ‚à© ùëÑ ‚Ä≤ that sends ùë†.ùëõùëíùë•ùë°ùê∂ = c

[ùúá].ùëê ùëì ùëî.ùëÑùë¢ùëúùëüùë¢ùëöùë† such that ‚àÄùë† ‚àà ùëÑ, ùë†.ùëõùëíùë•ùë°ùê∂ = c

[ ùëó], at some state ùúé ‚Ä≤‚Ä≤ before ùúé2. Thus, c

[ùúá + 1] ‚â† ‚ä• then ùëù2 assigns c

ùëù2
‚àó [ùúá + 1] = c

[ùúá].ùëê ùëì ùëî = c

[ ùëó] = c

ùëù1
ùúé1

ùëù1
ùúé1

ùëù1
ùúé1

ùëù1
ùúé1

ùëù1
ùúé1

ùëù2
ùúé2

ùëù1
ùúé1

ùëù1
ùúé1

ùëù1
ùúé1

ùëù1
ùúé1

Manuscript submitted to ACM

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

19

Thus far we focused on the configuration member of each element in ùëêùë†ùëíùëû. As operations do get in account the status
of a configuration, i.e. ùëÉ or ùêπ , in the next lemma we will examine the relationship of the last finalized configuration as
detected by two operations. First we present a lemma that shows the monotonicity of the finalized configurations.

LEMMA 16. Let ùúé and ùúé ‚Ä≤ two states in an execution ùúâ such that ùúé appears before ùúé ‚Ä≤ in ùúâ. Then for any process ùëù must

ùëù
ùëù
ùúé ) ‚â§ ùúá (c
hold that ùúá (c
ùúé‚Ä≤).

ùëù
ùúé [ùëò].ùë†ùë°ùëéùë°ùë¢ùë† = ùêπ at a state ùúé, then ùëù
PROOF. This lemma follows from the fact that if a configuration ùëò is such that c
ùëù
ùëù
ùúé‚Ä≤ [ ùëó].ùëê ùëì ùëî such that ùëó ‚â• ùëò. But c
ùúé‚Ä≤ [ ùëó].ùëê ùëì ùëî is the last finalized
will start any future read-config action from a configuration c
ùëù
ùëù
configuration at ùúé ‚Ä≤ and hence ùúá (c
‚ñ°
ùúé‚Ä≤) ‚â• ùúá (c
ùúé ).

LEMMA 17 (SEQUENCE PROGRESS). Let ùúã1 and ùúã2 two completed read-config actions invoked by processes
ùëù1, ùëù2 ‚àà I respectively, such that ùúã1 ‚Üí ùúã2 in an execution ùúâ. Let ùúé1 be the state after the response step of ùúã1 and ùúé2 the
state after the response step of ùúã2. Then ùúá (c

) ‚â§ ùúá (c

).

ùëù1
ùúé1

ùëù2
ùúé2

) and hence ùúá1 ‚â§ ùúá (c

) as well.

ùëù2
ùúé2

ùëù1
ùúé1

PROOF. By Lemma 15 it follows that c

ùëù1
ùúé1

), such that ùúá1 ‚â§ ùúà1, be the last element in c

ùúá1 = ùúá (c
element which ùëù2 obtained in Line A1:2 during ùúã2 such that c
and since ùúé2 is after ùúé ‚Ä≤, then by Lemma 16 ùúá2 ‚â§ ùúá (c

ùëù2
ùúé2

ùëù1
ùúé1 is a prefix of c

ùëù1
ùúé1 , where c

ùëù1
ùëù2
ùúé2 . Thus, if ùúà1 = ùúà (c
ùúé1

ùëù2
ùúé2
[ùúá1].ùë†ùë°ùëéùë°ùë¢ùë† = ùêπ . Let now ùúá2 = ùúá (c

), ùúà1 ‚â§ ùúà2. Let
ùëù2
ùúé‚Ä≤ ), be the last
ùëù2
ùúé‚Ä≤ [ùúá2].ùë†ùë°ùëéùë°ùë¢ùë† = ùêπ in some state ùúé ‚Ä≤ before ùúé2. If ùúá2 ‚â• ùúá1,

) and ùúà2 = ùúà (c

ùëù1
ùúé1

ùëù1
ùúé1

ùëù1
ùúé1

ùëù1
ùúé1 is a prefix in terms of configurations of the c

It remains to examine the case where ùúá2 < ùúá1. Process ùëù1 sets the status of c

ùëù1
ùúé1
[ùúá1].ùëê ùëì ùëî, ùêπ ‚ü© to a quorum of servers in c

[ùúá1] to ùêπ in two cases: (i) either when
[ùúá1].ùëê ùëì ùëî, ùêπ ‚ü© from some server ùë† during a read-config
finalizing a reconfiguration, or (ii) when receiving an ùë†.ùëõùëíùë•ùë°ùê∂ = ‚ü®c
[ùúá1 ‚àí 1].ùëê ùëì ùëî before completing.
action. In both cases ùëù1 propagates the ‚ü®c
ùëù2
We know by Lemma 15 that since ùúã1 ‚Üí ùúã2 then c
ùúé2 . So it must be the
ùëù2
case that ùúá2 < ùúá1 ‚â§ ùúà (c
). Thus, during ùúã2, ùëù2 starts from the configuration at index ùúá2 and in some iteration performs
ùúé2
[ùúá1 ‚àí 1].ùëê ùëì ùëî. Since ùúã1
get-next-config in configuration c
completed before ùúã2, then it must be the case that ùúé1 appears before ùúé ‚Ä≤ in ùúâ. However, ùëù2 invokes the get-next-config
operation in a state ùúé ‚Ä≤‚Ä≤ which is either equal to ùúé ‚Ä≤ or appears after ùúé ‚Ä≤ in ùúâ. Thus, ùúé ‚Ä≤‚Ä≤ must appear after ùúé1 in ùúâ. From that it
follows that when the get-next-config is executed by ùëù2 there is already a quorum of servers in c
[ùúá1 ‚àí 1].ùëê ùëì ùëî, say ùëÑ1,
[ùúá1].ùëê ùëì ùëî, ùêπ ‚ü©from ùëù1. Since, ùëù2 waits from replies from a quorum of servers from the same configuration,
that received ‚ü®c
say ùëÑ2, and since the ùëõùëíùë•ùë°ùê∂ variable at each server is monotonic (Lemma 10), then there is a server ùë† ‚àà ùëÑ1 ‚à© ùëÑ2, such
) ‚â• ùúá1 in this case
that ùë† replies to ùëù2 with ùë†.ùëõùëíùë•ùë°ùê∂ = ‚ü®c
‚ñ°
as well. This completes our proof.

[ùúá1 ‚àí 1]. According to Lemma 11, c

[ùúá1].ùëê ùëì ùëî, ùêπ ‚ü©, and hence ùúá (c

[ùúá1].ùëê ùëì ùëî, ùêπ ‚ü©. So, c

[ùúá1 ‚àí 1].ùëê ùëì ùëî = c

[ùúá1] gets ‚ü®c

ùëù1
ùúé1

ùëù2
ùúé2

ùëù2
ùúé2

ùëù2
ùúé2

ùëù1
ùúé1

ùëù2
ùúé2

ùëù2
ùúé2

ùëù1
ùúé1

ùëù1
ùúé1

Using the previous Lemmas we can conclude to the main result of this section.

THEOREM 18. Let ùúã1 and ùúã2 two completed read-config actions invoked by processes ùëù1, ùëù2 ‚àà I respectively, such
that ùúã1 ‚Üí ùúã2 in an execution ùúâ. Let ùúé1 be the state after the response step of ùúã1 and ùúé2 the state after the response step of
ùúã2. Then the following properties hold:
ùëù2
(ùëé) Configuration Consistency: c
ùúé2
ùëù2
(ùëè) Sequence Prefix: c
ùúé2 , and
(ùëê) Sequence Progress: ùúá (c
) ‚â§ ùúá (c

[ùëñ].ùëê ùëì ùëî, for 1 ‚â§ ùëñ ‚â§ ùúà (c

[ùëñ].ùëê ùëì ùëî = c

ùëù1
ùúé1

ùëù1
ùúé1

ùëù1
ùúé1

),

)

‚™Øùëù c
ùëù1
ùúé1

ùëù2
ùúé2

PROOF. Statements (ùëé), (ùëè) and (ùëê) follow from Lemmas 11, 15, and 16.

‚ñ°

Manuscript submitted to ACM

20Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

6.2 Atomicity Property of ARES

Given the properties satisfied by the reconfiguration algorithm of ARES in any execution, we can now proceed to examine

whether our algorithm satisfies the safety (atomicity) conditions. The propagation of the information of the distributed

object is achieved using the get-tag, get-data, and put-data actions. We assume that the DAP used satisfy Property 1 as

presented in Section 3, and we will show that, given such assumption, ARES satisfies atomicity.

We begin with a lemma stating that if a reconfiguration operation retrieves a configuration sequence of length ùëò during

its read-config action, then it installs/finalizes the ùëò + 1 configuration in the global configuration sequence.

LEMMA 19. Let ùúã be a complete reconfiguration operation by a reconfigurer ùëüùëê in an execution ùúâ of ARES. if ùúé1 is the
) at a state ùúé2

state in ùúâ following the termination of the read-config action during ùúã, then ùúã invokes a finalize-config(cùëüùëê
ùúé2
in ùúâ, with ùúà (cùëüùëê
ùúé2

) = ùúà (cùëüùëê
ùúé1

) + 1.

PROOF. This lemma follows directly from the implementation of the reconfig operation. Let ùúã be a reconfiguration
operation reconfig(ùëê). At first, ùúã invokes a read-config to retrieve a latest value of the global configuration sequence, cùëüùëê
ùúé1 ,
in the state ùúé1 in ùúâ. During the add-config action, ùúã proposes the addition of ùëê, and appends at the end of cùëüùëê
ùúé1 the decision
ùëë of the consensus protocol. Therefore, if cùëüùëê
ùúé1 is extended by ‚ü®ùëë, ùëÉ‚ü© (Line A 2:17), and hence the add-config action returns
a configuration sequence cùëüùëê
does not change during the update-config action,
ùúé‚Ä≤
1
) = ùúà (cùëüùëê
then cùëüùëê
) + 1 and
ùúé‚Ä≤
ùúé‚Ä≤
1
1
‚ñ°
the lemma follows.

is passed to the finalize-config action at state ùúé2, and hence cùëüùëê
ùúé2

with length ùúà (cùëüùëê
ùúé‚Ä≤
1

) + 1. As ùúà (cùëüùëê
ùúé‚Ä≤
1

. Thus, ùúà (cùëüùëê
ùúé2

) = ùúà (cùëüùëê
ùúé1

) = ùúà (cùëüùëê
ùúé1

= cùëüùëê
ùúé‚Ä≤
1

The next lemma states that only some reconfiguration operation ùúã may finalize a configuration ùëê at index ùëó in a
configuration sequence ùëù.ùëêùë†ùëíùëû at any process ùëù. To finalize ùëê, the lemma shows that ùúã must witness a configuration
sequence such that its last finalized configuration appears at an index ùëñ < ùëó in the configuration sequence ùëù.ùëêùë†ùëíùëû. In other
words, reconfigurations always finalize configurations that are ahead from their latest observed final configuration, and it

seems like ‚Äújumping‚Äù from one final configuration to the next.

ùëù
ùúé [ ùëó].ùë†ùë°ùëéùë°ùë¢ùë† = ùêπ for some process ùëù ‚àà I,
LEMMA 20. Suppose ùúâ is an execution of ARES. For any state ùúé in ùúâ, if c
ùúé‚Ä≤) during ùúã at

then there exists a reconfig operation ùúã by a reconfigurer ùëüùëê ‚àà G, such that (i) ùëüùëê invokes finalize-config(cùëüùëê
some state ùúé ‚Ä≤ in ùúâ, (ii) ùúà (cùëüùëê

ùúé‚Ä≤) = ùëó, and (iii) ùúá (cùëüùëê

ùúé‚Ä≤) < ùëó.

PROOF. A process sets the status of a configuration ùëê to ùêπ in two cases: (i) either during a finalize-config(ùë†ùëíùëû) action
such that ùúà (ùë†ùëíùëû) = ‚ü®ùëê, ùëÉ‚ü© (Line A2:33), or (ii) when it receives ‚ü®ùëê, ùêπ ‚ü© from a server ùë† during a read-next-config action.
Server ùë† sets the status of a configuration ùëê to ùêπ only if it receives a message that contains ‚ü®ùëê, ùêπ ‚ü© (Line A3:10). So, (ii) is
possible only if ùëê is finalized during a reconfig operation.

ùëù
ùúé [ ùëó].ùëê ùëì ùëî. To do so, process ùëüùëê invokes
Let, w.l.o.g., ùúã be the first reconfiguration operation that finalizes c
ùúé‚Ä≤ [ ùëó].ùëê ùëì ùëî.
ùúé‚Ä≤ and hence ùúà (cùëüùëê
ùúé‚Ä≤) = ùëó. Also, by Lemma 20 it follows that
ùúé‚Ä≤‚Ä≤ in some state ùúé ‚Ä≤‚Ä≤ that appeared before ùúé ‚Ä≤ in ùúâ, such that
ùúé‚Ä≤‚Ä≤ to
‚ñ°

ùëù
finalize-config(cùëüùëê
ùúé [ ùëó].ùëê ùëì ùëî = cùëüùëê
) during ùúã, at some state ùúé ‚Ä≤ that appears before ùúé in ùúâ. By Lemma 11, c
ùúé‚Ä≤
1
Since, ùëüùëê finalizes cùëüùëê
ùúé‚Ä≤ [ ùëó], then this is the last entry of cùëüùëê
the read-config action of ùúã returned a configuration cùëüùëê
ùúé‚Ä≤). Since by definition, ùúá (cùëüùëê
ùúà (cùëüùëê
ùúé‚Ä≤‚Ä≤) = ùúá (cùëüùëê
result in cùëüùëê

ùúé‚Ä≤‚Ä≤), then ùúá (cùëüùëê
ùúé‚Ä≤) < ùëó as well and the lemma follows.

ùúé‚Ä≤‚Ä≤) < ùëó. However, since only ‚ü®ùëê, ùëÉ‚ü© is added to cùëüùëê

ùúé‚Ä≤‚Ä≤) ‚â§ ùúà (cùëüùëê
ùúé‚Ä≤). Therefore, ùúá (cùëüùëê

ùúé‚Ä≤, then ùúá (cùëüùëê

ùúé‚Ä≤‚Ä≤) < ùúà (cùëüùëê

We now reach an important lemma of this section. By ARES, before a read/write/reconfig operation completes

it propagates the maximum tag it discovered by executing the put-data action in the last configuration of its local
configuration sequence (Lines A2:18, A4:16, A4:38). When a subsequent operation is invoked, it reads the latest

Manuscript submitted to ACM

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

21

configuration sequence by beginning from the last finalized configuration in its local sequence and invoking read-data to
all the configurations until the end of that sequence. The lemma shows that the latter operation will retrieve a tag which is

higher than the tag used in the put-data action of any preceding operation.

LEMMA 21. Let ùúã1 and ùúã2 be two completed read/write/reconfig operations invoked by processes ùëù1 and ùëù2 in I,
in an execution ùúâ of ARES, such that, ùúã1 ‚Üí ùúã2. If ùëê1.put-data(‚ü®ùúèùúã1
, ùë£ùúã1 ‚ü©) is the last put-data action of ùúã1 and ùúé2 is the
state in ùúâ after the completion of the first read-config action of ùúã2, then there exists a ùëê2.put-data(‚ü®ùúè, ùë£‚ü©) action in some
), such that (i) it completes in a state ùúé ‚Ä≤ before ùúé2 in ùúâ, and (ii)
configuration ùëê2 = c
ùúè ‚â• ùúèùúã1 .

[ùëò].ùëê ùëì ùëî, for ùúá (c

) ‚â§ ùëò ‚â§ ùúà (c

ùëù2
ùúé2

ùëù2
ùúé2

ùëù2
ùúé2

ùëù1
ùúé1

ùëù2
ùúé2

[ùúà (c

) ‚â§ ùúà (c

PROOF. Note that from the definitions of ùúà (¬∑) and ùúá (¬∑), we have ùúá (c
, ùë£ùúã1 ‚ü©) and ùúé ‚Ä≤

ùëù2
). Let ùúé1 be the state in ùúâ after the
ùúé2
1 be the state in ùúâ following the response step of ùúã1. Since any operation
completion of ùëê1.put-data(‚ü®ùúèùúã1
ùëù1
ùúé1 , and hence ùëê1 =
executes put-data on the last discovered configuration then ùëê1 is the last configuration found in c
ùëù2
ùëù1
ùëù1
), since ùúã2 (and thus
) ‚â§ ùúá (c
c
ùúé2
ùúé1
ùúé1
its first read-config action) is invoked after ùúé ‚Ä≤
1 (and thus after the last read-config action during ùúã1). Hence, combining
ùëù2
the two implies that ùúá (c
).
ùúé2
Therefore, it remains to examine whether the last finalized configuration witnessed by ùëù2 appears before or after ùëê1, i.e.:
(ùëé) ùúá (c

). Now from the last implication and the first statement we have ùúá (c

)].ùëê ùëì ùëî. By Lemma 16 we have ùúá (c

) and by Lemma 17 we have ùúá (c

) and (ùëè) ùúá (c

) ‚â§ ùúá (c

) ‚â§ ùúà (c

) ‚â§ ùúá (c

) ‚â§ ùúà (c

) > ùúà (c

ùëù1
ùúé‚Ä≤
1

ùëù1
ùúé‚Ä≤
1

ùëù1
ùúé1

ùëù2
ùúé2

ùëù1
ùúé1

).

ùëù2
ùúé2

ùëù1
ùúé1

ùëù1
ùúé1

ùëù2
ùúé2

ùëù1
ùúé1

ùëù2
ùúé2 value returned by read-config at ùëù2 during the execution of ùúã2
Case (ùëé): Since ùúã1 ‚Üí ùúã2 then, by Theorem 18, c
ùëù1
ùëù1
ùëù2
) ‚â§ ùúà (c
). Since ùëê1 is the last
) ‚â§ ùúà (c
ùúé2 . Therefore, ùúà (c
‚™Øùëù c
satisfies c
ùúé1
ùúé1
ùëù1
ùëù1
). So if we take ùëê2 = ùëê1 then the ùëê1.put-data(‚ü®ùúèùúã1
ùúé1 , then it has index ùúà (c
, ùë£ùúã1 ‚ü©) action trivially satisfies
configuration in c
ùúé1
both conditions of the lemma as: (i) it completes in state ùúé1 which appears before ùúé2, and (ii) it puts a pair ‚ü®ùúè, ùë£‚ü© such that
ùúè = ùúèùúã1 .

), and hence in this case ùúá (c

) ‚â§ ùúà (c

ùëù2
ùúé2

ùëù2
ùúé2

ùëù2
ùúé2

Case (ùëè): This case is possible if there exists a reconfiguration client ùëüùëê that invokes reconfig operation ùúå, during which
it executes the finalize-config(cùëüùëê
). Let ùúé be the state immediately
after the read-config of ùúå. Now, we consider two sub-cases: (ùëñ) ùúé appears before ùúé1 in ùúâ, or (ùëñùëñ) ùúé appears after ùúé1 in ùúâ.

‚àó ) that finalized configuration with index ùúà (cùëüùëê

‚àó ) = ùúá (c

ùëù2
ùúé2

ùëù1
ùúé1

ùëù2
ùúé2

ùúé = c

ùúé ‚â∫ùëù c

ùëù1
ùúé1 , or cùëüùëê

ùúé ) + 1 ‚â§ ùúà (c

‚àó ) = ùúà (cùëüùëê

Now suppose, that cùëüùëê

ùëù1
ùúé1 . Then it follows that ùúà (cùëüùëê

ùëù1
ùúé1 due to Lemma 15. Suppose cùëüùëê

Subcase (ùëè)(ùëñ): Since read-config at ùúé completes before the invocation of last read-config of operation ùúã1 then, either
ùëù1
cùëüùëê
ùúé1 , then according to Lemma 19 ùëüùëê executes finalize-config
ùúé ‚â∫ùëù c
ùëù2
on configuration sequence cùëüùëê
‚àó with ùúà (cùëüùëê
ùúé ) + 1. If however,
ùúé2
ùëù1
ùëù1
cùëüùëê
ùúé1 , then ùúà (cùëüùëê
ùúé ) < ùúà (c
) ‚â§ ùúà (c
) which contradicts our
ùúé ‚â∫ùëù c
ùúé1
initial assumption for this case that ùúá (c

ùúé ) + 1. Since ùúà (cùëüùëê
ùëù1
ùúé1

), then ùúá (c
ùëù2
ùúé2

) = ùúà (cùëüùëê
ùëù1
ùúé1

) and thus ùúà (cùëüùëê
ùëù2
) > ùúà (c
ùúé2

‚àó ) = ùúá (c
). This implies that ùúá (c
). So this sub-case is impossible.
ùëù2
ùúé2

) + 1 in this case. Since ùúé1 is
) = ùúà (c
ùúé = c
the state after the last put-data during ùúã1, then if ùúé ‚Ä≤
1 is the state after the completion of the last read-config of ùúã1 (which
ùëù1
. So, during its last read-config process ùëù1 does not read the
= c
follows the put-data), it must be the case that c
ùúé1
ùëù1
)+1. This means that the put-config completes in ùúå at state ùúéùúå after ùúé ‚Ä≤
configuration indexed at ùúà (c
1 and the update-config
ùúé1
ùúå after ùúéùúå with a configuration sequence cùëüùëê
operation is invoked at state ùúé ‚Ä≤
. During the update operation ùúå invokes get-data
ùúé‚Ä≤
ùúå
operation in every configuration cùëüùëê
). Notice that ùúà (cùëüùëê
) ‚â§ ùëñ ‚â§ ùúà (cùëüùëê
) = ùúá (c
ùúé‚Ä≤
ùúé‚Ä≤
ùúé‚Ä≤
ùúå
ùúå
ùúå
moreover the last configuration of cùëüùëê
ùúé‚Ä≤
ùúå
and hence ùúá (cùëüùëê
ùúé‚Ä≤
ùúå

[ùëñ].ùëê ùëì ùëî, for ùúá (cùëüùëê
) = ùúà (c
ùúé‚Ä≤
ùúå
was just added by ùúå and it is not finalized. From this it follows that ùúá (cùëüùëê
ùúé‚Ä≤
ùúå

). Therefore, ùúå executes get-data in configuration cùëüùëê
ùúé‚Ä≤
ùúå

) + 1 and
),
). Since ùëù1 invoked

ùëù1
ùúé1
) < ùúà (cùëüùëê
ùúé‚Ä≤
ùúå

[ ùëó].ùëê ùëì ùëî for ùëó = ùúà (c

), and that ùúá (c

ùúé ) = ùúà (c

) ‚â§ ùúà (c

ùëù1
ùúé‚Ä≤
1

ùëù1
ùúé1

ùëù1
ùúé1

ùëù2
ùúé2

ùëù1
ùúé1

ùëù1
ùúé1

Manuscript submitted to ACM

22Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

, ùë£ùúã1 ‚ü©) at the same configuration ùëê1, and completed in a state ùúé1 before ùúé ‚Ä≤

put-data(‚ü®ùúèùúã1
ùúå , then by C1 of Property 1, it
follows that the get-data action will return a tag ùúè ‚â• ùúèùúã1 . Therefore, the maximum tag that ùúå discovers is ùúèùëöùëéùë• ‚â• ùúè ‚â• ùúèùúã1 .
ùëù2
Before invoking the finalize-config action, ùúå invokes ùëê1.put-data(‚ü®ùúèùëöùëéùë• , ùë£ùëöùëéùë• )‚ü©. Since ùúà (cùëüùëê
), and since by
ùúé2
ùúé‚Ä≤
ùúå
ùëù2
Lemma 11, then the action put-data is invoked in a configuration ùëê2 = c
[ ùëó].ùëê ùëì ùëî such that ùëó = ùúá (c
). Since the
ùúé2
read-config action of ùúã2 observed configuration ùúá (c
), then it must be the case that ùúé2 appears after the state where the
finalize-config was invoked and therefore after the state of the completion of the put-data action during ùúå. Thus, in this
case both properties are satisfied and the lemma follows.

) = ùúá (c

ùëù2
ùúé2

ùëù2
ùúé2

Subcase (ùëè)(ùëñùëñ): Suppose in this case that ùúé occurs in ùúâ after ùúé1. In this case the last put-data in ùúã1 completes before the
invocation of the read-config in ùúå in execution ùúâ. Now we can argue recursively, ùúå taking the place of operation ùúã2, that
ùúá (cùëüùëê
). Note that there are
finite number of operations invoked in ùúâ before ùúã2 is invoked, and hence the statement of the lemma can be shown to hold
‚ñ°
by a sequence of inequalities.

ùúé ) and therefore, we consider two cases: (ùëé) ùúá (cùëüùëê

) and (ùëè) ùúá (cùëüùëê

ùúé ) ‚â§ ùúà (cùëüùëê

ùúé ) ‚â§ ùúà (c

ùúé ) > ùúà (c

ùëù1
ùúé1

ùëù1
ùúé1

The following lemma shows the consistency of operations as long as the DAP used satisfy Property 1.

LEMMA 22. Let ùúã1 and ùúã2 denote completed read/write operations in an execution ùúâ, from processes ùëù1, ùëù2 ‚àà I
respectively, such that ùúã1 ‚Üí ùúã2. If ùúèùúã1 and ùúèùúã2 are the local tags at ùëù1 and ùëù2 after the completion of ùúã1 and ùúã2 respectively,
then ùúèùúã1 ‚â§ ùúèùúã2 ; if ùúã1 is a write operation then ùúèùúã1

< ùúèùúã2 .

PROOF. Let ‚ü®ùúèùúã1

, ùë£ùúã1 ‚ü© be the pair passed to the last put-data action of ùúã1. Also, let ùúé2 be the state in ùúâ that follows the
completion of the first read-config action during ùúã2. Notice that ùúã2 executes a loop after the first read-config operation
ùëù2
ùëù2
and performs ùëê.get-data (if ùúã2 is a read) or ùëê.get-tag (if ùúã2 is a write) from all ùëê = c
).
ùúé2
ùúé2
By Lemma 21, there exists a ùëê ‚Ä≤.put-data(‚ü®ùúè, ùë£‚ü©) action by some operation ùúã ‚Ä≤ on some configuration ùëê ‚Ä≤ = c
[ ùëó].ùëê ùëì ùëî, for
ùëù2
), that completes in some state ùúé ‚Ä≤ that appears before ùúé2 in ùúâ. Thus, the get-data or get-tag invoked
ùúá (c
ùúé2
[ ùëó].ùëê ùëì ùëî, occurs after state ùúé2 and thus after ùúé ‚Ä≤. Since the DAP primitives used satisfy C1 and C2 of Property
by ùëù2 on c
1, then the get-tag action will return a tag ùúè ‚Ä≤
ùúã2 or a get-data action will return a pair ‚ü®ùúè ‚Ä≤
‚â• ùúè. As ùëù2 gets
ùúã2
the maximum of all the tags returned, then by the end of the loop ùëù2 will retrieve a tag ùúèùëöùëéùë• ‚â• ùúè ‚Ä≤
ùúã2

) ‚â§ ùëó ‚â§ ùúà (c
ùëù2
ùúé2

) ‚â§ ùëñ ‚â§ ùúà (c
ùëù2
ùúé2

[ùëñ].ùëê ùëì ùëî, for ùúá (c

‚ü©, with ùúè ‚Ä≤
ùúã2

‚â• ùúè ‚â• ùúèùúã1 .

, ùë£ ‚Ä≤
ùúã2

ùëù2
ùúé2

ùëù2
ùúé2

If now ùúã2 is a read, it returns ‚ü®ùúèùëöùëéùë• , ùë£ùëöùëéùë• ‚ü© after propagating that value to the last discovered configuration. Thus,
ùúèùúã2 ‚â• ùúèùúã1 . If however ùúã2 is a write, then before propagating the new value the writer increments the maximum timestamp
> ùúèùúã1 in this
discovered (Line A4:13) generating a tag ùúèùúã2
‚ñ°
case.

> ùúèùëöùëéùë• . Therefore the operation ùúã2 propagates a tag ùúèùúã2

And the main result of this section follows:

THEOREM 23 (ATOMICITY). In any execution ùúâ of ARES, if in every configuration ùëê ‚àà Gùêø, ùëê.get-data(), ùëê.put-data(),

and ùëê.get-tag() satisfy Property 1, then ARES satisfy atomicity.

As algorithm ARES handles each configuration separately, then we can observe that the algorithm may utilize a

different mechanism for the put and get primitives in each configuration. So the following remark:

REMARK 24. Algorithm ARES satisfies atomicity even when the implementaton of the DAPs in two different configu-
rations ùëê1 and ùëê2 are not the same, given that the ùëêùëñ .get-tag, ùëêùëñ .get-data, and the ùëêùëñ .put-data primitives in each ùëêùëñ satisfy
Property 1.

Manuscript submitted to ACM

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

23

7 PERFORMANCE ANALYSIS OF ARES

A major challenge in reconfigurable atomic services is to examine the latency of terminating read and write operations,

especially when those are invoked concurrently with reconfiguration operations. In this section we provide an in depth

analysis of the latency of operations in ARES. Additionally, a storage and communication analysis is shown when ARES

utilizes the erasure-coding algorithm presented in Section 5, in each configuration.

7.1 Latency Analysis

Liveness (termination) properties cannot be specified for ARES, without restricting asynchrony or the rate of arrival

of reconfig operations, or if the consensus protocol never terminates. Here, we provide some conditional performance
analysis of the operation, based on latency bounds on the message delivery. We assume that local computations take

negligible time and the latency of an operation is due to the delays in the messages exchanged during the execution. We
measure delays in time units of some global clock, which is visible only to an external viewer. No process has access to
the clock. Let ùëë and ùê∑ be the minimum and maximum durations taken by messages, sent during an execution of ARES, to
reach their destinations. Also, let ùëá (ùúã) denote the duration of an operation (or action) ùúã. In the statements that follow,
we consider any execution ùúâ of ARES, which contains ùëò reconfig operations. For any configuration ùëê in an execution
of ARES, we assume that any ùëê.ùê∂ùëúùëõ.propose operation, takes at least ùëáùëöùëñùëõ (ùê∂ùëÅ ) time units.

Let us first examine what is the action delays based on the boundaries we assume. It is easy to see that actions
put-config, read-next-config perform two message exchanges thus take time 2ùëë ‚â§ ùëá (ùúô) ‚â§ 2ùê∑. From this we can derive
the delay of a read-config action.

LEMMA 25. Let ùúô be a read-config operation invoked by a non-faulty reconfiguration client ùëüùëê, with the input
ùúé ) + 1) ‚â§ ùëá (ùúô) ‚â§

ùúé‚Ä≤ respectively. Then the delay of ùúô is: 4ùëë (ùúà (cùëüùëê

ùúé‚Ä≤) ‚àí ùúá (cùëüùëê

ùúé and cùëüùëê

argument and returned values of ùúô as cùëüùëê
4ùê∑ (ùúà (cùëüùëê
ùúé ) + 1).

ùúé‚Ä≤) ‚àí ùúá (cùëüùëê

From Lemma 25 it is clear that the latency of a read-config action depends on the number of configurations installed

since the last finalized configuration known to the recon client.

Given the latency of a read-config, we can compute the minimum amount of time it takes for ùëò configurations to be

installed.

The following lemma shows the maximum latency of a read or a write operation, invoked by any non-faulty client.

From ARES algorithm, the latency of a read/write operation depends on the delays of the DAPs operations. For our

analysis we assume that all get-data, get-tag and put-data primitives use two phases of communication. Each phase
consists of a communication between the client and the servers.

LEMMA 26. Suppose ùúã, ùúô and ùúì are operations of the type put-data, get-tag and get-data, respectively, invoked by
some non-faulty reconfiguration clients, then the latency of these operations are bounded as follows: (ùëñ) 2ùëë ‚â§ ùëá (ùúã) ‚â§ 2ùê∑;
(ùëñùëñ) 2ùëë ‚â§ ùëá (ùúô) ‚â§ 2ùê∑; and (ùëñùëñùëñ) 2ùëë ‚â§ ùëá (ùúì ) ‚â§ 2ùê∑.

In the following lemma, we estimate the time taken for a read or a write operation to complete, when it discovers ùëò

configurations between its invocation and response steps.

LEMMA 27. Consider any execution of ARES where at most ùëò reconfiguration operations are invoked. Let ùúéùë† and ùúéùëí
be the states before the invocation and after the completion step of a read/write operation ùúã, in some fair execution ùúâ of
ARES. Then we have ùëá (ùúã) ‚â§ 6ùê∑ (ùëò + 2) to complete.

Manuscript submitted to ACM

24Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

PROOF. Let ùúéùë† and ùúéùëí be the states before the invocation and after the completion step of a read/write operation ùúã by ùëù
respectively, in some execution ùúâ of ARES. By algorithm examination we can see that any read/write operation performs
the following actions in this order: (ùëñ) read-config, (ùëñùëñ) get-data (or get-tag), (ùëñùëñùëñ) put-data, and (ùëñùë£) read-config. Let
ùúé1 be the state when the first read-config, denoted by read-config1, action terminates. By Lemma 25 the action will take
time:

ùëù
ùëá (read-config1) ‚â§ 4ùê∑ (ùúà (c
ùúé1

ùëù
) ‚àí ùúá (c
ùúéùë† ) + 1)

ùëù
ùëù
The get-data action that follows the read-config (Lines Alg. 4:34-35) also took at most (ùúà (c
) ‚àí ùúá (c
ùúéùë† ) + 1) time units,
ùúé1
given that no new finalized configuration was discovered by the read-config action. Finally, the put-data and the second
ùëù
ùëù
read-config actions of ùúã may be invoked at most (ùúà (c
ùúéùëí ) ‚àí ùúà (c
) + 1) times, given that the read-config action discovers
ùúé1
one new configuration every time it runs. Merging all the outcomes, the total time of ùúã can be at most:

ùëù
ùëù
ùëù
ùúéùë† ) + 1) + 2ùê∑ (ùúà (c
ùëá (ùúã) ‚â§ 4ùê∑ (ùúà (c
) ‚àí ùúá (c
ùúé1
ùúé1
(cid:105)
(cid:104)
ùëù
ùëù
ùúéùëí ) ‚àí ùúá (c
ùúà (c
ùúéùë† ) + 2

‚â§ 6ùê∑

‚â§ 6ùê∑ (ùëò + 1)

ùëù
ùëù
ùëù
ùúéùëí ) ‚àí ùúà (c
ùúéùë† ) + 1) + (4ùê∑ + 2ùê∑)(ùúà (c
) ‚àí ùúá (c
ùúé1

) + 1)

ùëù
ùëù
ùúéùë† ) ‚â§ ùëò + 1 since there can be at most ùëò new configurations installed. and the result of the lemma
ùúéùëí ) ‚àí ùúá (c
where ùúà (c
‚ñ°
follows.

It remains now to examine the conditions under which a read/write operation may ‚Äúcatch up‚Äù with an infinite number

of reconfiguration operations. For the sake of a worst case analysis we will assume that reconfiguration operations suffer
the minimum delay ùëë, whereas read and write operations suffer the maximum delay ùê∑ in each message exchange. We first
show how long it takes for ùëò configurations to be installed.

LEMMA 28. Let ùúé be the last state of a fair execution of ARES, ùúâ. Then ùëò configurations can be installed to cùúé , in time

ùëá (ùëò) ‚â• 4ùëë (cid:205)ùëò

ùëñ=1

ùëñ + ùëò (ùëáùëöùëñùëõ (ùê∂ùëÅ ) + 2ùëë) time units.

PROOF. In ARES a reconfig operation has four phases: (ùëñ) read-config(ùëêùë†ùëíùëû), reads the latest configuration se-
quence, (ùëñùëñ) add-config(ùëêùë†ùëíùëû, ùëê), attempts to add the new configuration at the end of the global sequence Gùêø, (ùëñùëñùëñ)
update-config(ùëêùë†ùëíùëû), transfers the knowledge to the added configuration, and (ùëñùë£) finalize-config(ùëêùë†ùëíùëû) finalizes the
added configuration. So, a new configuration is appended to the end of the configuration sequence (and it becomes visible

to any operation) during the add-config action. In turn, the add-config action, runs a consensus algorithm to decide on the
added configuration and then invokes a put-config action to add the decided configuration. Any operation that is invoked
after the put-config action observes the newly added configuration.

Notice that when multiple reconfigurations are invoked concurrently, then it might be the case that all participate to the

same consensus instance and the configuration sequence is appended by a single configuration. The worst case scenario

happens when all concurrent reconfigurations manage to append the configuration sequence by their configuration. In

brief, this is possible when the read-config action of each reconfig operation appears after the put-config action of another
reconfig operation.

More formally we can build an execution where all reconfig operations append their configuration in the configuration
sequence. Consider the partial execution ùúâ that ends in a state ùúé. Suppose that every process ùëù ‚àà I knows the same
ùëù
ùúé = cùúé . Also let the last finalized operation in cùúé be the last configuration of the sequence, e.g.
configuration sequence, c
ùëù
ùúé0 . We extend ùúâ0 by a series of reconfig
ùúá (cùúé ) = ùúà (cùúé ). Notice that cùúé can also be the initial configuration sequence c
operations, such that each reconfiguration ùëüùëêùëñ is invoked by a reconfigurer ùëüùëñ and attempts to add a configuration ùëêùëñ . Let

Manuscript submitted to ACM

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

25

Fig. 2. Successful reconfig operations.

ùëüùëê1 be the first reconfiguration that performs the following actions without being concurrent with any other reconfig
operation:

‚Ä¢ read-config starting from ùúá (cùúé )
‚Ä¢ add-config completing both the consensus proposing ùëê1 and the put-config action writing the decided configuration

Since ùëüùëê1 its not concurrent with any other reconfig operation, then is the only process to propose a configuration in
ùúá (cùúé ), and hence by the consensus algorithm properties, ùëê1 is decided. Thus, cùúé is appended by a tuple ‚ü®ùëê1, ùëÉ‚ü©.

Let now reconfiguration ùëüùëê2 be invoked immediately after the completion of the add-config action from ùëüùëê1. Since
the local sequence at the beginning of ùëüùëê2 is equal to cùúé , then the read-config action of ùëüùëê2 will also start from ùúá (cùúé ).
Since, ùëüùëê1 already propagated ùëê1 to ùúá (cùúé ) during is put-config action, then ùëüùëê2 will discover ùëê1 during the first iteration
of its read-config action, and thus it will repeat the iteration on ùëê1. Configuration ùëê1 is the last in the sequence and thus
the read-config action of ùëüùëê2 will terminate after the second iteration. Following the read-config action, ùëüùëê2 attempts to
add ùëê2 in the sequence. Since ùëüùëê1 is the only reconfiguration that might be concurrent with ùëüùëê2, and since ùëüùëê1 already
completed consensus in ùúá (cùúé ), then ùëüùëê2 is the only operation to run consensus in ùëê1. Therefore, ùëê2 is accepted and ùëüùëê2
propagates ùëê2 in ùëê1 using a put-config action.

So in general we let configuration ùëüùëêùëñ to be invoked after the completion of the add-config action from ùëüùëêùëñ‚àí1. As a
result, the read-config action of ùëüùëêùëñ performs ùëñ iterations, and the configuration ùëêùëñ is added immediately after configuration
ùëêùëñ‚àí1 in the sequence. Figure 2 illustrates our execution construction for the reconfiguration operations.

It is easy to notice that such execution results in the worst case latency for all the reconfiguration operations
ùëüùëê1, ùëüùëê2, . . . , ùëüùëêùëñ . As by Lemma 25 a read-config action takes at least 4ùëë time to complete, then as also seen in
Figure 2, ùëò reconfigs may take time ùëá (ùëò) ‚â• (cid:205)ùëò
ùëñ=1 [4ùëë ‚àó ùëñ + (ùëáùëöùëñùëõ (ùê∂ùëÅ ) + 2ùëë)]. Therefore, it will take time ùëá (ùëò) ‚â•
4ùëë (cid:205)ùëò
‚ñ°

ùëñ + ùëò (ùëáùëöùëñùëõ (ùê∂ùëÅ ) + 2ùëë) and the lemma follows.

ùëñ=1

The following theorem is the main result of this section, in which we define the relation between ùëáùëöùëñùëõ (ùê∂ùëÅ ), ùëë and ùê∑

so to guarantee that any read or write issued by a non-faulty client always terminates.

THEOREM 29. Suppose ùëáùëöùëñùëõ (ùê∂ùëÅ ) ‚â• 3(6ùê∑ ‚àí ùëë), then any read or write operation ùúã completes in any execution ùúâ of

ARES for any number of reconfiguration operations in ùúâ.

Manuscript submitted to ACM

26Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

PROOF. By Lemma 28, ùëò configurations may be installed in: ùëá (ùëò) ‚â• 4ùëë (cid:205)ùëò
ùëñ + ùëò (ùëáùëöùëñùëõ (ùê∂ùëÅ ) + 2ùëë). Also by Lemma
ùëñ=1
(cid:17)
(cid:16)
ùëù
ùëù
ùëù
ùëù
27, we know that operation ùúã takes at most ùëá (ùúã) ‚â§ 6ùê∑
ùúéùëí ) ‚àí ùúá (c
. Assuming that ùëò = ùúà (c
ùúéùëí ) ‚àí ùúá (c
ùúà (c
ùúéùë† ), the
ùúéùë† ) + 2
total number of configurations observed during ùúã, then ùúã may terminate before a ùëò + 1 configuration is added in the
configuration sequence if 6ùê∑ (ùëò + 2) ‚â§ 4ùëë (cid:205)ùëò
. And that
‚ñ°
completes the lemma.

ùëñ + ùëò (ùëáùëöùëñùëõ (ùê∂ùëÅ ) + 2ùëë) then we have ùëë ‚â• 3ùê∑

ùëáùëöùëñùëõ (ùê∂ùëÅ )
2(ùëò+2)

ùëò ‚àí

ùëñ=1

7.2 Storage and Communication Costs for ARES.

Storage and Communication costs for ARES highly depends on the DAP that we use in each configuration. For our

analysis we assume that each configuration utilizes the algorithms and the DAPs presented in Section 5.

Recall that by our assumption, the storage cost counts the size (in bits) of the coded elements stored in variable ùêøùëñùë†ùë° at
each server. We ignore the storage cost due to meta-data. For communication cost we measure the bits sent on the wire

between the nodes.

LEMMA 30. The worst-case total storage cost of Algorithm 5 is (ùõø + 1) ùëõ
ùëò .

PROOF. The maximum number of (tag, coded-element) pair in the ùêøùëñùë†ùë° is ùõø + 1, and the size of each coded element is
‚ñ°

ùëò while the tag variable is a metadata and therefore, not counted. So, the total storage cost is (ùõø + 1) ùëõ
1
ùëò .

We next state the communication cost for the write and read operations in Aglorithm 5. Once again, note that we ignore

the communication cost arising from exchange of meta-data.

LEMMA 31. The communication cost associated with a successful write operation in Algorithm 5 is at most ùëõ
ùëò .

PROOF. During read operation, in the get-tag phase the servers respond with their highest tags variables, which are
ùëò each, and hence the
ùëõ
ùëò . Therefore, we have the worst case communication cost of a write operation is
‚ñ°

metadata. However, in the put-data phase, the reader sends each server the coded elements of size 1
total cost of communication for this is
ùëõ
ùëò .

LEMMA 32. The communication cost associated with a successful read operation in Algorithm 5 is at most (ùõø + 2) ùëõ
ùëò .

PROOF. During read operation, in the get-data phase the servers respond with their ùêøùëñùë†ùë° variables and hence each such
ùëò . In the put-data phase, the reader
ùëõ
ùëò . Therefore,
‚ñ°

list is of size at most (ùõø + 1) 1
sends each server the coded elements of size 1
ùëò each, and hence the total cost of communication for this is
we have the worst case communication cost of a read operation is (ùõø + 2) ùëõ
ùëò .

ùëò , and then counting all such responses give us (ùõø + 1) ùëõ

From the above Lemmas we get.

THEOREM 33. The ARES algorithm has: (i) storage cost (ùõø + 1) ùëõ

ùëò , (ii) communication cost for each write at most to

ùëò , and (iii) communication cost for each read at most (ùõø + 2) ùëõ
ùëõ
ùëò .

8 FLEXIBILITY OF DAPS

In this section, we argue that various implementations of DAPs can be used in ARES. In fact, via reconfig operations,
one can implement a highly adaptive atomic DSS: replication-based can be transformed into erasure-code based DSS;

increase or decrease the number of storage servers; study the performance of the DSS under various code parameters, etc.
The insight to implementing various DAPs comes from the observation that the simple algorithmic template ùê¥ (see Alg. 7)
Manuscript submitted to ACM

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

27

for reads and writes protocol combined with any implementation of DAPs, satisfying Property 1 gives rise to a MWMR

atomic memory service. Moreover, the read and writes operations terminate as long as the implemented DAPs complete.

Algorithm 7 Template ùê¥ for the client-side read/write steps.

2:

4:

operation read()

‚ü®ùë°, ùë£ ‚ü© ‚Üê ùëê.get-data()
ùëê.put-data( ‚ü®ùë°, ùë£ ‚ü©)
return ‚ü®ùë°, ùë£ ‚ü©
end operation

6: operation write(ùë£)
ùë° ‚Üê ùëê.get-tag()
ùë°ùë§ ‚Üê ùëñùëõùëê (ùë° )
ùëê.put-data( ‚ü®ùë°ùë§, ùë£ ‚ü©)

8:

10: end operation

A read operation in ùê¥ performs ùëê.get-data() to retrieve a tag-value pair, ‚ü®ùúè, ùë£‚ü© from a configuration ùëê, and then it
performs a ùëê.put-data(‚ü®ùúè, ùë£‚ü©) to propagate that pair to the configuration ùëê. A write operation is similar to the read but
before performing the put-data action it generates a new tag which associates with the value to be written. The following
result shows that ùê¥ is atomic and live, if the DAPs satisfy Property 1 and live.

THEOREM 34 (ATOMICITY OF TEMPLATE ùê¥). Suppose the DAP implementation satisfies the consistency properties
ùê∂1 and ùê∂2 of Property 1 for a configuration ùëê ‚àà C. Then any execution ùúâ of algorithm ùê¥ in configuration ùëê is atomic and
live if each DAP invocation terminates in ùúâ under the failure model ùëê.F .

PROOF. We prove the atomicity by proving properties ùê¥1, ùê¥2 and ùê¥3 presented in Section 2 for any execution of the

algorithm.

Property ùê¥1: Consider two operations ùúô and ùúã such that ùúô completes before ùúã is invoked. We need to show that it

cannot be the case that ùúã ‚â∫ ùúô. We break our analysis into the following four cases:

Case (ùëé): Both ùúô and ùúã are writes. The ùëê.put-data(‚àó) of ùúô completes before ùúã is invoked. By property C1 the tag ùúèùúã
returned by the ùëê.get-data() at ùúã is at least as large as ùúèùúô . Now, since ùúèùúã is incremented by the write operation then ùúã puts
a tag ùúè ‚Ä≤

ùúã and hence we cannot have ùúã ‚â∫ ùúô.

ùúã such that ùúèùúô < ùúè ‚Ä≤

Case (ùëè): ùúô is a write and ùúã is a read. In execution ùúâ since ùëê.put-data(‚ü®ùë°ùúô, ‚àó‚ü©) of ùúô completes before the ùëê.get-data()
of ùúã is invoked, by property C1 the tag ùúèùúã obtained from the above ùëê.get-data() is at least as large as ùúèùúô . Now ùúèùúô ‚â§ ùúèùúã
implies that we cannot have ùúã ‚â∫ ùúô.

Case (ùëê): ùúô is a read and ùúã is a write. Let the id of the writer that invokes ùúã we ùë§ùúã . The ùëê.put-data(‚ü®ùúèùúô, ‚àó‚ü©) call of ùúô
completes before ùëê.get-tag() of ùúã is initiated. Therefore, by property C1 get-tag(ùëê) returns ùúè such that, ùúèùúô ‚â§ ùúè. Since ùúèùúã
is equal to ùëñùëõùëê (ùúè) by design of the algorithm, hence ùúèùúã > ùúèùúô and we cannot have ùúã ‚â∫ ùúô.

Case (ùëë): Both ùúô and ùúã are reads. In execution ùúâ the ùëê.put-data(‚ü®ùë°ùúô, ‚àó‚ü©) is executed as a part of ùúô and completes before

ùëê.get-data() is called in ùúã. By property C1 of the data-primitives, we have ùúèùúô ‚â§ ùúèùúã and hence we cannot have ùúã ‚â∫ ùúô.

Property ùê¥2: Note that because the tag set T is well-ordered we can show that A2 holds by first showing that every
write has a unique tag. This means that any two pair of writes can be ordered. Note that a read can be ordered w.r.t. any

write operation trivially if the respective tags are different, and by definition, if the tags are equal the write is ordered

before the read.

Observe that two tags generated from different writers are necessarily distinct because of the id component of the tag.
Now if the operations, say ùúô and ùúã are writes from the same writer then, by well-formedness property, the second operation
will witness a higher integer part in the tag by property C1, and since the ùëê.get-tag() is followed by ùëê.put-data(‚àó). Hence
ùúã is ordered after ùúô.

Manuscript submitted to ACM

28Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

Property ùê¥3: By C2 the ùëê.get-data() may return a tag ùúè, only when there exists an operation ùúã that invoked a
ùëê.put-data(‚ü®ùúè, ‚àó‚ü©). Otherwise it returns the initial value. Since a write is the only operation to put a new tag ùúè in the
‚ñ°
system then Property ùê¥3 follows from C2.

8.1 Representing Known Algorithms in terms of data-access primitives

A number of known tag-based algorithms that implement atomic read/write objects (e.g., ABD [8], FAST[17] ), can be

expressed in terms of DAP. In this subsection we demonstrate how we can transform the very celebrated ABD algorithm

[8].

MWABD Algorithm. The multi-writer version of the ABD can be transformed to the generic algorithm Template ùê¥.
Algorithm 8 illustrates the three DAP for the ABD algorithm. The get-data primitive encapsulates the query phase of
MWABD, while the put-data primitive encapsulates the propagation phase of the algorithm.

Algorithm 8 Implementation of DAP for ABD at each process ùëù using configuration ùëê

2:

4:

6:

8:

10:

20:

22:

24:

26:

Data-Access Primitives at process ùëù:
procedure c.put-data(‚ü®ùúè, ùë£ ‚ü©))

send (WRITE, ‚ü®ùúè, ùë£ ‚ü©) to each ùë† ‚àà ùëê.ùëÜùëíùëü ùë£ùëíùëüùë†
until ‚àÉùëÑ,ùëÑ‚ààùëê.ùëÑùë¢ùëúùëüùë¢ùëöùë† s.t. ùëù receives ACK from ‚àÄùë† ‚àà ùëÑ

end procedure

procedure c.get-tag()

send (QUERY-TAG) to each ùë† ‚àà ùëê.ùëÜùëíùëü ùë£ùëíùëüùë†
until ‚àÉùëÑ , ùëÑ ‚àà ùëê.ùëÑùë¢ùëúùëüùë¢ùëöùë† s.t.

ùëù receives ‚ü®ùúèùë† , ùë£ùë† ‚ü© from ‚àÄùë† ‚àà ùëÑ

ùúèùëöùëéùë• ‚Üê max( {ùúèùë† : ùëù received ‚ü®ùúèùë† , ùë£ùë† ‚ü© from ùë† })

Primitive Handlers at server ùë†ùëñ in configuration ùëê:

Upon receive (QUERY-TAG) from ùëû

send ùúè to ùëû

end receive

Upon receive (QUERY) from ùëû

send ‚ü®ùúè, ùë£ ‚ü© to ùëû

end receive

12:

14:

16:

18:

28:

30:

32:

return ùúèùëöùëéùë•
end procedure

procedure c.get-data()

send (QUERY) to each ùë† ‚àà ùëê.ùëÜùëíùëü ùë£ùëíùëüùë†
until ‚àÉùëÑ , ùëÑ ‚àà ùëê.ùëÑùë¢ùëúùëüùë¢ùëöùë† s.t.

ùëù receives ‚ü®ùúèùë† , ùë£ùë† ‚ü© from ‚àÄùë† ‚àà ùëÑ

ùúèùëöùëéùë• ‚Üê max( {ùúèùë† : ùëüùëñ received ‚ü®ùúèùë† , ùë£ùë† ‚ü© from ùë† })
return { ‚ü®ùúèùë† , ùë£ùë† ‚ü© : ùúèùë† = ùúèùëöùëéùë• ‚àß ùëù received ‚ü®ùúèùë† , ùë£ùë† ‚ü© from ùë† }

end procedure

Upon receive (WRITE, ‚ü®ùúèùëñùëõ, ùë£ùëñùëõ ‚ü©) from ùëû

if ùúèùëñùëõ > ùúè then

‚ü®ùúè, ùë£ ‚ü© ‚Üê ‚ü®ùúèùëñùëõ, ùë£ùëñùëõ ‚ü©

send ACK to ùëû

end receive

Let us now examine if the primitives satisfy properties C1 and C2 of Property 1. We begin with a lemma that shows

the monotonicity of the tags at each server.

LEMMA 35. Let ùúé and ùúé ‚Ä≤ two states in an execution ùúâ such that ùúé appears before ùúé ‚Ä≤ in ùúâ. Then for any server ùë† ‚àà S it

must hold that ùë†.ùë°ùëéùëî|ùúé ‚â§ ùë†.ùë°ùëéùëî|ùúé‚Ä≤.

PROOF. According to the algorithm, a server ùë† updates its local tag-value pairs when it receives a message with a
‚ñ°

higher tag. So if ùë†.ùë°ùëéùëî|ùúé = ùúè then in a state ùúé ‚Ä≤ that appears after ùúé in ùúâ, ùë†.ùë°ùëéùëî|ùúé‚Ä≤ ‚â• ùúè.

In the following two lemmas we show that property C1 is satisfied, that is if a put-data action completes, then any

subsequent get-data and get-tag actions will discover a higher tag than the one propagated by that put-data action.

LEMMA 36. Let ùúô be a ùëê.put-data(‚ü®ùúè, ùë£‚ü©) action invoked by ùëù1 and ùõæ be a ùëê.get-tag() action invoked by ùëù2 in a

configuration ùëê, such that ùúô ‚Üí ùõæ in an execution ùúâ of the algorithm. Then ùõæ returns a tag ùúèùõæ ‚â• ùúè.
Manuscript submitted to ACM

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

29

PROOF. The lemma follows from the intersection property of quorums. In particular, during the ùëê.put-data(‚ü®ùúè, ùë£‚ü©)
action, ùëù1 sends the pair ‚ü®ùúè, ùë£‚ü© to all the servers in ùëê.ùëÜùëíùëüùë£ùëíùëüùë† and waits until all the servers in a quorum ùëÑùëñ ‚àà ùëê.ùëÑùë¢ùëúùëüùë¢ùëöùë†
reply. When those replies are received then the action completes.

During a ùëê.get-data() action on the other hand, ùëù2 sends query messages to all the servers in ùëê.ùëÜùëíùëüùë£ùëíùëüùë† and waits until
all servers in a quorum ùëÑ ùëó ‚àà ùëê.ùëÑùë¢ùëúùëüùë¢ùëöùë† (not necessarily different than ùëÑùëñ ) reply. By definition ùëÑùëñ ‚à© ùëÑ ùëó ‚â† ‚àÖ, thus any
server ùë† ‚àà ùëÑùëñ ‚à© ùëÑ ùëó reply to both ùúô and ùõæ actions. By Lemma 35 and since ùë† received a tag ùúè, then ùë† replies to ùëù2 with a tag
‚ñ°
ùúèùë† ‚â• ùúè. Since ùõæ returns the maximum tag it discovers then ùúèùõæ ‚â• ùúèùë† . Therefore ùúèùõæ ‚â• ùúè and this completes the proof.

With similar arguments and given that each value is associated with a unique tag then we can show the following

lemma.

LEMMA 37. Let ùúã be a ùëê.put-data(‚ü®ùúè, ùë£‚ü©) action invoked by ùëù1 and ùúô be a ùëê.get-data() action invoked by ùëù2 in a
configuration ùëê, such that ùúã ‚Üí ùúô in an execution ùúâ of the algorithm. Then ùúô returns a tag-value ‚ü®ùúèùúô, ùë£ùúô ‚ü© such that ùúèùúô ‚â• ùúè.

Finally we can now show that property C2 also holds.

LEMMA 38. If ùúô is a ùëê.get-data() that returns ‚ü®ùúèùúã , ùë£ùúã ‚ü© ‚àà T √ó V, then there exists ùúã such that ùúã is a

ùëê.put-data(‚ü®ùúèùúã , ùë£ùúã ‚ü©) and ùúô ‚Üõ ùúã.

PROOF. This follows from the facts that (i) servers set their tag-value pair to a pair received by a put-data action, and
(ii) a get-data action returns a tag-value pair that it received from a server. So if a ùëê.get-data() operation ùúô returns a
tag-value pair ‚ü®ùúèùúã , ùë£ùúã ‚ü©, there should be a server ùë† that replied to that operation with ‚ü®ùúèùúã , ùë£ùúã ‚ü©, and ùë† received ‚ü®ùúèùúã , ùë£ùúã ‚ü© from
‚ñ°
some ùëê.put-data(‚ü®ùúèùúã , ùë£ùúã ‚ü©) action, ùúã. Thus, ùúã can proceed or be concurrent with ùúô, and hence ùúô Ã∏‚Üí ùúã.

9 EXPERIMENTAL EVALUATION

The theoretical findings suggest that ARES is an algorithm to provide robustness and flexibility on shared memory

implementations, without sacrificing strong consistency. In this section we present a proof-of-concept implementation of

ARES and we run preliminary experiments to get better insight on the efficiency and adaptiveness of ARES. In particular,

our experiments measure the latency of each read, write, and reconfig operations, and examine the persistence of
consistency even when the service is reconfigured between configurations that utilize different shared memory algorithms.

9.1 Experimental Testbed

We ran experiments on two different setups: (i) simulated locally on a single machine, and (ii) on a LAN. Both type of
experiments run on Emulab [2], an emulated WAN environment testbed used for developing, debugging, and evaluating

the systems. We used nodes with two 2.4 GHz 64-bit 8-Core E5-2630 "Haswell" processors and 64 GB RAM. In both

setups we used an external implementation of Raft[] consensus algorithms, which was used for the service reconfiguration

and was deployed on top of small RPi devices. Small devices introduced further delays in the system, reducing the speed

of reconfigurations and creating harsh conditions for longer periods in the service.

Local Experimental Setup: The local setup was used to have access to a global synchronized clock (the clock of the

local machine) in order to examine whether our algorithm preserves global ordering and hence atomicity even when

using different algorithms between configurations. Therefore, all the instances are hosted on the same physical machine

avoiding the skew between computer clocks in a distributed system. Furthermore, the use of one clock guarantees that

when an event occurs after another, it will assign a later time.

Manuscript submitted to ACM

30Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

Distributed Experimental Setup: The distributed experiments in Emulab enabled the examination of the performance

of the algorithm in a close to real environment. For the deployment and remote execution of the experimental tasks on the
Emulab, we used Ansible Playbooks [1]. All physical nodes were placed on a single LAN using a DropTail queue with

the default traffic parameters, i.e. 100 Mb bandwidth, and no delay or packet loss. Each physical machine runs one server

or client process. This guarantees a fair communication delay between a client and a server node.

Node Types: In all experiments, we use three distinct types of nodes, writers, readers and servers. Their main role is

listed below:

‚Ä¢ writer ùë§ ‚àà ùëä ‚äÜ ùê∂ : a client that sends write requests to all servers and waits for a quorum of the servers to reply
‚Ä¢ reader ùëü ‚àà ùëÖ ‚äÜ ùê∂: a client that sends read requests to servers and waits for a quorum of the servers to reply
‚Ä¢ reconfigurer ùëî ‚àà ùê∫ ‚äÜ ùê∂: a client that sends reconfiguration requests to servers and waits for a quorum of the

servers to reply

‚Ä¢ server ùë† ‚àà ùëÜ: a server listens for read and write requests, it updates its object replica according to the atomic shared

memory and replies to the process that originated the request.

Performance Metric: The metric for evaluating the algorithms is the operational latency. This includes both commu-

nication and computational delays. The operation latency is computed as the average of all clients‚Äô average operation

latencies. For better estimations, each experiment in every scenario was repeated 3 times.

9.2 Experimental Scenarios

In this section, we describe the scenarios we constructed and the settings for each of them. In our scenarios we constructed

the DAPs and used two different atomic storage algorithms in ARES: (i) the erasure coding based algorithm presented in

Section 5, and (ii) the ABD algorithm (see Section 8.1).

Erasure Coding: The type of erasure coding we use is (n,k)-Reed-Solomon code, which guarantees that any k of n coded

fragments is enough to reassemble the original object. The parameter k is the number of encoded data fragments, n is the

total number of servers and m is the number of parity fragments, i.e. n-k. A high number of m and consequently a small

number of k means less redundancy.

Fixed Parameters: In all scenarios the number of servers is fixed to 10. The number of writers and the value of delta are

set to 5; delta being the maximum number of concurrent put-data operations. The parity value of the EC algorithm is set

to 2, in order to minimize the redundancy; leading to 8 data servers and 2 parity servers.

It is worth mentioning that the quorum size of the EC algorithm is (cid:6) 10+8
2

(cid:7) = 9, while the quorum size of ABD algorihtm
(cid:5) + 1 = 6. In relation to the EC algorithm, we can conclude that the parameter k is directly proportional to the

is (cid:4) 10
2
quorum size. But as the value of k and quorum size increase, the size of coded elements decreases.
Distributed Experiments: For the distributed experiments we use a stochastic invocation scheme in which readers,

writers and reconfigurers pick a random time between intervals to invoke their next operations. Respectively the intervals
are [1...ùëüùêºùëõùë°], [1..ùë§ùêºùëõùë°] and [1..ùëüùëíùëêùëúùëõùêºùëõùë°], where ùëüùêºùëõùë°, ùë§ùêºùëõùë° = 2ùë†ùëíùëê and ùëüùëíùëêùëúùëõùêºùëõùë° = 15ùë†ùëíùëê. In total, each writer performs
60 writes, each reader 60 reads and the reconfigurer if any 6 reconfigurations.

In particular, we present four types of scenarios:

‚Ä¢ File Size Scalability (Emulab): The first scenario is made to evaluate how the read and write latencies are affected
by the size of the shared object. There are two separated runs, one for each examined storage algorithm. The

number of readers is fixed to 5, without any reconfigurers. The file size is doubled from 1 MB to 128 MB.

Manuscript submitted to ACM

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

31

‚Ä¢ Reader Scalability (Emulab): This scenario is constructed to compare the read and write latency of the system
with two different storage algorithms, while the readers increase. In particular, we execute two separate runs, one

for each storage algorithm. We use only one reconfigurer which requests recon operations that lead to the same

shared memory emulation and server nodes. The size of the file used is 4 MB.

‚Ä¢ Changing Reconfigurations (Emulab): In this scenario, we evaluate how the read and write latencies are affected
when increasing the number of readers, while also changing the storage algorithm. We run two different runs

which differ in the way the reconfigurer chooses the next storage algorithm: (i) the reconfigurer chooses randomly

between the two storage algorithms, and (ii) the reconfigurer switches between the two storage algorithms. The

size of the file used, in both scenarios, is 4 MB.

‚Ä¢ Consistency Persistence (Local): In this scenario we run multiple client operations in order to check if the data is
consistent across servers. The number of readers is set to 5. The readers and writers invoke their next operations
without any time delay, while the reconfigurer waits 15ùë†ùëíùëê for the next invocation. In total, each writer performs
500 writes, each reader 500 reads and the reconfigurer 50 reconfigurations. The size of the file used is 4 MB.

9.3 Experimental Results

In this section, we present and explain the evaluation results of each scenario. As a general observation, the ARES

algorithm with the EC storage provides data redundancy with a lower communicational and storage cost compared to the

ABD storage that uses a strict replication technique.

File Size Scalability Results: Fig. 3(a) shows the results of the file size scalability experiments. The read and write

latencies of both storage algorithms remain in low levels until 16 MB. In bigger sizes we observe the latancies of all

operations to grow significantly. It is worth noting that the fragmentation applied by the EC algorithm, benefits its write

operations which follow a slower increasing curve than the rest of the operations. From the rest the reads seem to the one

to suffer the worst delay hit, as they are engaged in more communication phases. Nevertheless, the larger messages sent

by ABD result in slower read operations.

Reader Scalability Results: The results of reader scalability experiments can be found in Fig. 3(b). The read and write

latencies of both algorithms remain almost unchanged, while the number of readers increases. This indicates that the

system does not reach a state where it can not handle the concurrent read operations. Still, the reduced message size of

read and write operation in EC keep their latencies lower than the coresponding latencies of ABD. On the other hand, the

reconfiguration latency in both algorithms witnesses wild fluctuations between about 1 sec and 4 sec. This is probably due

to the unstable connection in the external service which handles the reconfigurations.

Changing Reconfigurations Results: Fig. 3(c) illustrates the results of experiments with the random storage change.

While, in Fig. 3(d), we can find the results of the experiments when the reconfigurer switches between storage algorithms.

During both experiments, there are cases where a single read/write operation may access configurations that implement

both ABD and EC algorithms, when concurrent with a recon operation. Thus, the latencies of such operations are

accounted in both ABD and EC latencies. As we mentioned earlier, our choice of k minimizes the coded fragment size

but introduces bigger quorums and thus larger communication overhead. As a result, in smaller file sizes, the ARES may

not benefit so much from the coding, bringing the delays of the two storage algorithms closer to each other. It is again

obvious that the reconfiguration delays is higher than the delays of all other operations.

Consistency Persistence Results: Though ARES protocol is provably strongly consistent, it is important ensure that our

implementation is correct. Validating strong consistency of an execution requires precise clock synchronization across all

processes, so that one can track operations with respect to a global time. This is impossible to achieve in a distributed

Manuscript submitted to ACM

32Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

(a)

(c)

(b)

(d)

Fig. 3. Simulation results.

system where clock drift is inevitable. To circumvent this, we deploy all the processes in a single beefy machine so that

every process observers the same clock running in the same physical machine.

Our checker gathers data regarding an execution, and this data includes start and end times of all the operations, as well

as other parameters like logical timestamps used by the protocol. The checker logic is based on the conditions appearing

in Lemma 13.16 [32], which provide a set of sufficient conditions for guaranteeing strong consistency. The checker

validates strong consistency property for every atomic object individually for the execution under consideration.

10 CONCLUSIONS

We presented an algorithmic framework suitable for reconfigurable, erasure code-based atomic memory service in

asynchronous, message-passing environments. We provided experimental results of our initial prototype that can store

multiple objects. We also provided a new two-round erasure code-based algorithm that has near optimal storage cost,

and Moreover, this algorithm is suitable specifically where during new configuration installation the object values passes

directly from servers in older configuration to those Future work will involve adding efficient repair and reconfiguration

using regenerating codes.

Manuscript submitted to ACM

ARES: Adaptive, Reconfigurable, Erasure coded, Atomic Storage

33

REFERENCES

[1] Ansible. https://www.ansible.com/overview/how-ansible-works.
[2] Emulab network testbed. https://www.emulab.net/.
[3] Intel storage acceleration library (open source version). https://goo.gl/zkVl4N.
[4] ABEBE, M., DAUDJEE, K., GLASBERGEN, B., AND TIAN, Y. Ec-store: Bridging the gap between storage and latency in distributed erasure coded

systems. In 2018 IEEE 38th International Conference on Distributed Computing Systems (ICDCS) (July 2018), pp. 255‚Äì266.

[5] AGUILERA, M. K., KEIDAR, I., MALKHI, D., AND SHRAER, A. Dynamic atomic storage without consensus. In Proceedings of the 28th ACM

symposium on Principles of distributed computing (PODC ‚Äô09) (New York, NY, USA, 2009), ACM, pp. 17‚Äì25.

[6] AGUILERA, M. K., KEIDARY, I., MALKHI, D., MARTIN, J.-P., AND SHRAERY, A. Reconfiguring replicated atomic storage: A tutorial. Bulletin of

the EATCS 102 (2010), 84‚Äì081.

[7] ANTA, A. F., NICOLAOU, N., AND POPA, A. Making ‚Äúfast‚Äù atomic operations computationally tractable. In International Conference on Principles

Of Distributed Systems (2015), OPODIS‚Äô15.

[8] ATTIYA, H., BAR-NOY, A., AND DOLEV, D. Sharing memory robustly in message passing systems. Journal of the ACM 42(1) (1996), 124‚Äì142.
[9] BURIHABWA, D., FELBER, P., MERCIER, H., AND SCHIAVONI, V. A performance evaluation of erasure coding libraries for cloud-based data stores.

In Distributed Applications and Interoperable Systems (2016), Springer, pp. 160‚Äì173.

[10] CACHIN, C., AND TESSARO, S. Optimal resilience for erasure-coded byzantine distributed storage.
International Conference on (Los Alamitos, CA, USA, 2006), IEEE Computer Society, pp. 115‚Äì124.

In Dependable Systems and Networks,

[11] CADAMBE, V. R., LYNCH, N., M√âDARD, M., AND MUSIAL, P. A coded shared atomic memory algorithm for message passing architectures. In

Network Computing and Applications (NCA), 2014 IEEE 13th International Symposium on (Aug 2014), pp. 253‚Äì260.

[12] CADAMBE, V. R., LYNCH, N. A., M√âDARD, M., AND MUSIAL, P. M. A coded shared atomic memory algorithm for message passing architectures.

Distributed Computing 30, 1 (2017), 49‚Äì73.

[13] CHEN, Y. L. C., MU, S., AND LI, J. Giza: Erasure coding objects across global data centers. In Proceedings of the 2017 USENIX Annual Technical

Conference (USENIX ATC ‚Äô17) (2017), pp. 539‚Äì551.

[14] CHOCKLER, G., GILBERT, S., GRAMOLI, V., MUSIAL, P. M., AND SHVARTSMAN, A. A. Reconfigurable distributed storage for dynamic networks.

Journal of Parallel and Distributed Computing 69, 1 (2009), 100‚Äì116.

[15] CHOCKLER, G., AND MALKHI, D. Active disk paxos with infinitely many processes. Distributed Computing 18, 1 (2005), 73‚Äì84.
[16] DUTTA, P., GUERRAOUI, R., AND LEVY, R. R. Optimistic erasure-coded distributed storage. In DISC ‚Äô08: Proceedings of the 22nd international

symposium on Distributed Computing (Berlin, Heidelberg, 2008), Springer-Verlag, pp. 182‚Äì196.

[17] DUTTA, P., GUERRAOUI, R., LEVY, R. R., AND CHAKRABORTY, A. How fast can a distributed atomic read be? In Proceedings of the 23rd ACM

symposium on Principles of Distributed Computing (PODC) (2004), pp. 236‚Äì245.

[18] FAN, R., AND LYNCH, N. Efficient replication of large data objects. In Distributed algorithms (2003), F. E. Fich, Ed., vol. 2848 of Lecture Notes in

Computer Science, pp. 75‚Äì91.

[19] FERN√ÅNDEZ ANTA, A., HADJISTASI, T., AND NICOLAOU, N. Computationally light ‚Äúmulti-speed‚Äù atomic memory. In International Conference on

Principles Of Distributed Systems (2016), OPODIS‚Äô16.

[20] GAFNI, E., AND MALKHI, D. Elastic Configuration Maintenance via a Parsimonious Speculating Snapshot Solution. In International Symposium on

Distributed Computing (2015), Springer, pp. 140‚Äì153.

[21] GEORGIOU, C., NICOLAOU, N. C., AND SHVARTSMAN, A. A. On the robustness of (semi) fast quorum-based implementations of atomic shared
memory. In DISC ‚Äô08: Proceedings of the 22nd international symposium on Distributed Computing (Berlin, Heidelberg, 2008), Springer-Verlag,
pp. 289‚Äì304.

[22] GEORGIOU, C., NICOLAOU, N. C., AND SHVARTSMAN, A. A. Fault-tolerant semifast implementations of atomic read/write registers. Journal of

Parallel and Distributed Computing 69, 1 (2009), 62‚Äì79.

[23] GILBERT, S. RAMBO II: Rapidly reconfigurable atomic memory for dynamic networks. Master‚Äôs thesis, MIT, August 2003.
[24] GILBERT, S., LYNCH, N., AND SHVARTSMAN, A. RAMBO II: Rapidly reconfigurable atomic memory for dynamic networks. In Proceedings of

International Conference on Dependable Systems and Networks (DSN) (2003), pp. 259‚Äì268.

[25] HERLIHY, M. P., AND WING, J. M. Linearizability: a correctness condition for concurrent objects. ACM Transactions on Programming Languages

and Systems 12, 3 (1990), 463‚Äì492.

[26] HUFFMAN, W. C., AND PLESS, V. Fundamentals of error-correcting codes. Cambridge university press, 2003.
[27] JEHL, L., VITENBERG, R., AND MELING, H. Smartmerge: A new approach to reconfiguration for atomic storage. In International Symposium on

Distributed Computing (2015), Springer, pp. 154‚Äì169.

[28] JOSHI, G., SOLJANIN, E., AND WORNELL, G. Efficient redundancy techniques for latency reduction in cloud systems. ACM Transactions on

Modeling and Performance Evaluation of Computing Systems (TOMPECS) 2, 2 (2017), 12.

[29] KONWAR, K. M., PRAKASH, N., KANTOR, E., LYNCH, N., M√âDARD, M., AND SCHWARZMANN, A. A. Storage-optimized data-atomic algorithms
for handling erasures and errors in distributed storage systems. In 2016 IEEE International Parallel and Distributed Processing Symposium (IPDPS)
(May 2016), pp. 720‚Äì729.

Manuscript submitted to ACM

34Nicolas Nicolaou, Viveck Cadambe, N. Prakash, Andria Trigeorgi, Kishori M. Konwar, Muriel Medard, and Nancy Lynch

[30] KONWAR, K. M., PRAKASH, N., LYNCH, N., AND M√âDARD, M. Radon: Repairable atomic data object in networks. In The International Conference

on Distributed Systems (OPODIS) (2016).

[31] LAMPORT, L. The part-time parliament. ACM Transactions on Computer Systems 16, 2 (1998), 133‚Äì169.
[32] LYNCH, N. Distributed Algorithms. Morgan Kaufmann Publishers, 1996.
[33] LYNCH, N., AND SHVARTSMAN, A. RAMBO: A reconfigurable atomic memory service for dynamic networks. In Proceedings of 16th International

Symposium on Distributed Computing (DISC) (2002), pp. 173‚Äì190.

[34] LYNCH, N. A., AND SHVARTSMAN, A. A. Robust emulation of shared memory using dynamic quorum-acknowledged broadcasts. In Proceedings of

Symposium on Fault-Tolerant Computing (1997), pp. 272‚Äì281.

[35] NAKAMOTO, S. Bitcoin: A peer-to-peer electronic cash system.
[36] NICOLAOU, N., CADAMBE, V., KONWAR, K., PRAKASH, N., LYNCH, N., AND M√âDARD, M. Ares: Adaptive, reconfigurable, erasure coded,

atomic storage. CoRR abs/1805.03727 (2018).

[37] ONGARO, D., AND OUSTERHOUT, J. In search of an understandable consensus algorithm. In Proceedings of the 2014 USENIX Conference on

USENIX Annual Technical Conference (Berkeley, CA, USA, 2014), USENIX ATC‚Äô14, USENIX Association, pp. 305‚Äì320.

[38] RASHMI, K., CHOWDHURY, M., KOSAIAN, J., STOICA, I., AND RAMCHANDRAN, K. Ec-cache: Load-balanced, low-latency cluster caching with

online erasure coding. In OSDI (2016), pp. 401‚Äì417.

[39] SHRAER, A., MARTIN, J.-P., MALKHI, D., AND KEIDAR, I. Data-centric reconfiguration with network-attached disks. In Proceedings of the 4th

Int‚Äôl Workshop on Large Scale Distributed Sys. and Middleware (LADIS ‚Äô10) (2010), p. 22‚Äì26.

[40] SPIEGELMAN, A., KEIDAR, I., AND MALKHI, D. Dynamic Reconfiguration: Abstraction and Optimal Asynchronous Solution. In 31st International

Symposium on Distributed Computing (DISC 2017) (2017), vol. 91, pp. 40:1‚Äì40:15.

[41] WANG, S., HUANG, J., QIN, X., CAO, Q., AND XIE, C. Wps: A workload-aware placement scheme for erasure-coded in-memory stores. In

Networking, Architecture, and Storage (NAS), 2017 International Conference on (2017), IEEE, pp. 1‚Äì10.

[42] XIANG, Y., LAN, T., AGGARWAL, V., AND CHEN, Y.-F. R. Multi-tenant latency optimization in erasure-coded storage with differentiated services.

In 2015 IEEE 35th International Conference on Distributed Computing Systems (ICDCS) (2015), IEEE, pp. 790‚Äì791.

[43] XIANG, Y., LAN, T., AGGARWAL, V., CHEN, Y.-F. R., XIANG, Y., LAN, T., AGGARWAL, V., AND CHEN, Y.-F. R. Joint latency and cost

optimization for erasure-coded data center storage. IEEE/ACM Transactions on Networking (TON) 24, 4 (2016), 2443‚Äì2457.

[44] YU, Y., HUANG, R., WANG, W., ZHANG, J., AND LETAIEF, K. B. Sp-cache: load-balanced, redundancy-free cluster caching with selective partition.
In Proceedings of the International Conference for High Performance Computing, Networking, Storage, and Analysis (2018), IEEE Press, p. 1.
[45] ZHANG, H., DONG, M., AND CHEN, H. Efficient and available in-memory kv-store with hybrid erasure coding and replication. In 14th USENIX

Conference on File and Storage Technologies (FAST 16) (Santa Clara, CA, 2016), USENIX Association, pp. 167‚Äì180.

[46] ZHOU, P., HUANG, J., QIN, X., AND XIE, C. Pars: A popularity-aware redundancy scheme for in-memory stores. IEEE Transactions on Computers

(2018), 1‚Äì1.

Manuscript submitted to ACM

