7
1
0
2

b
e
F
8

]

V
C
.
s
c
[

1
v
4
1
5
2
0
.
2
0
7
1
:
v
i
X
r
a

Monocular LSD-SLAM integration
within AR System

Building a system similar to the HoloLens by integrating
LSD-SLAM into our AR Oculus Rift stereo engine for
realworld camera tracking

Markus H¨oll, Vincent Lepetit

Inst. for Computer Graphics and Vision
Graz University of Technology, Austria

Technical Report
ICG–CVARLab-TR–ICGCVARLab-TR003
Graz, February 9, 2017

contact: Markus H¨oll mhoell@student.tugraz.at

 
 
 
 
 
 
Abstract

In this paper, we cover the process of integrating Large-Scale Direct Simulta-
neous Localization and Mapping (LSD-SLAM) [1] algorithm into our exist-
ing AR stereo engine, developed for our modiﬁed ”Augmented Reality Ocu-
lus Rift”. With that, we are able to track one of our realworld cameras
which are mounted on the rift, within a complete unknown environment.
This makes it possible to achieve a constant and full augmentation, syn-
chronizing our 3D movement (x, y, z) in both worlds, the real world and
the virtual world. The development for the basic AR setup using the Ocu-
lus Rift DK1 and two ﬁsheye cameras is fully documented in our previ-
ous paper [2]. After an introduction to image-based registration, we detail
the LSD-SLAM algorithm and document our code implementing our inte-
gration. The AR stereo engine with Oculus Rift support can be accessed
via the GIT repository https: // github. com/ MaXvanHeLL/ ARift. git and
the modiﬁed LSD-SLAM project used for the integration is available here
https: // github. com/ MaXvanHeLL/ LSD-SLAM. git .

Keywords: Technical report, ICG, LSD-SLAM, Tracking, AR, Augmented
Reality, HoloLens, 3D Localization, Integration, Engine, Virtual Reality, Com-
puter Vision, VR, Computer Graphics

Contents

Abstract

1 Introduction

1.1 Building upon our AR Oculus Rift System . . . . . . . . . . .

1

2
3

2 Theory

2.1 Vision in Augmented Reality . . . . . . . . . . . . . . . . . . .
Image Registration . . . . . . . . . . . . . . . . . . . . . . . .
2.2
2.2.1 Feature Based Rigid Registration . . . . . . . . . . . .
Surface Based Rigid Registration . . . . . . . . . . . .
2.2.2
Intensity Based Rigid Registration (Voxel Similarity) .
2.2.3

4
4
5
6
7
8
2.3 Simultaneous Localization and Mapping . . . . . . . . . . . . 10
2.3.1 Feature-based monocular SLAM . . . . . . . . . . . . . 10
. . . . . . . . . . . . 11
2.3.2 Dense monocular SLAM (Direct)
2.4 Monocular LSD-SLAM . . . . . . . . . . . . . . . . . . . . . . 12
Semi-Dense . . . . . . . . . . . . . . . . . . . . . . . . 12
2.4.1
2.4.2 Large-Scale . . . . . . . . . . . . . . . . . . . . . . . . 13
2.4.3 Complete Algorithm . . . . . . . . . . . . . . . . . . . 13

3 Implementation

14
3.1 Calibration . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
3.2 Engine Integration . . . . . . . . . . . . . . . . . . . . . . . . 15
Initialization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
3.3
3.4 Render Loop Update . . . . . . . . . . . . . . . . . . . . . . . 18
3.5 Undistortion ShaderBuﬀer for LSD-SLAM . . . . . . . . . . . 23
3.6 LSD-SLAM Code Modiﬁcations . . . . . . . . . . . . . . . . . 26
lsd slam::IDSuEyeCameraStreamThread . . . . . . . . 27
3.7 Light Shading Model - Rendering Equation . . . . . . . . . . . 30
3.8 New Engine Conﬁgurations
. . . . . . . . . . . . . . . . . . . 30
3.9 New Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

3.6.1

4 Conclusion

5 Future Work

31

34

1

1

Introduction

Simultaneous localization and mapping (SLAM) is one of the hardest and
most important ﬁelds in computer vision. As pointed out by Montemerlo
[3], SLAM is a fundamental problem of autonomous robots and therefore it
plays a key role in robotics aswell as in augmented reality.

The challenge here is to aswell localize a robot within an unknown area of
unknown scale and compute an internal global environment map for tracking.
With computer vision, it is possible to solve that problem by creating a map
of the environment in form of a 3D model. The camera images of the moving
robot are used to observe the environment containing all the visible objects
and structures. The creation of the map has to be done online, since it is
neccessary to simultaneous localize the robot and update the global 3D map,
frame by frame. The whole algorithm has a high computational complexity
which makes it very challenging to achieve a suﬃenctly high framerate for
an accurate tracking.

In Augmented Reality (AR), registration is one the most essential com-
ponents. Since we were using the Oculus Rift as an Head-Mounted-Display
(HMD), we had to capture the real world using undistorted camera images
and render both camera streams onto the intern HMD screen. To achieve
a stereoscopic view, we have used two ﬁsh-eye cameras IDS uEye UI-122-
1LE-C-HQ. Both of them are positioned on the front plate of the Rift. Using
this Virtual Reality (VR) device, we could achieve a full-view AR immersion,
since we are able to blend holograms everywhere at the intern screen with
the real world. The development of our previous AR system is documented
in our previous paper [2].

Microsoft’s new promising HoloLens is based on similar principles.
It
renders virtual objects onto the screen located within the lenses and tracks
the 3D position in world space using the mounted camera. However, since
the lenses of the HoloLens are transparent, there is no need for a digital
camera stream. On the downside, the HoloLens can augment only a small
area of the real world ﬁeld-of-view (FOV), located in the center of the screen.
In section 2, we talk about Image Registration since this is a fundamental
knowledge of SLAM systems. For illustration, we show some examples from
the ﬁeld of Medical Image Analysis. Then we cover SLAM methods in general
and go into more detail about the monocular LSD-SLAM.

Section three 3 shows some implementation details about the integration

and modiﬁcations, which have been done.

In section 4 we summarize the experiences made during development and

show some results. In section 5, we list some possible future work.

2

1.1 Building upon our AR Oculus Rift System

Considering our previous basic AR system [2] with a modiﬁed Oculus Rift,
and our own DirectX stereo engine, we were able to render and animate 3D
graphic models super-imposed to the images captured by the cameras.

Figure 1: Results from our previously built AR system ”Augmented Reality
Oculus Rift”. Image taken from [2].

Using the Oculus Rift’s internal gyro sensor, the augmentations could
move consistently with the orientation of the user’s head. But what makes
AR systems really interesting, is a complete augmentation of the holograms
into realworld space. To give a good illusion of augmentation, it is neccessary
to consider translation motions as well.

Figure 2: Hardware Modiﬁcations on Oculus Rift DK1 for ”Augmented Re-
ality Oculus Rift”. Image property of Markus H¨oll

3

2 Theory

2.1 Vision in Augmented Reality

Building large-scale, accurate, responsive, and robust AR systems in real-
time is challenging. What makes AR systems complex in computation is the
real-world camera tracking, especially in large-scale areas without having
information about the environment.

According to [4], the majority of AR systems (in 2007) operated with a
prior knowledge of the environment the camera is located in. One possibility
is to place a marker, maybe a card or a chessboard into the scene with known
position like shown in [5]. By observing the marker, its prior known 3D
world position can be used to measure the location of the observing camera
in relation to the object in world space. The huge downside in approaches
like that is, it is only possible to yield location and rotation of the camera
while measuring the marker. That means, augmentation is not possible when
the camera is currently not observing and measuring the object with prior
known world coordinates.

Figure 3: Relationship between marker coordinates and estimated camera
coordinates. Image taken from [5].

Compared to these marker-based approaches, we wanted to integrate an
extensible tracking, without having any prior information about the environ-
ment to fully augment reality. This need of extensible tracking opens the
door to SLAM systems.

How do we know about the 3D pose of the Rift in an entirely prior
unknown environment, frame-by-frame in real-time? The answer is an algo-
rithm called Monocular LSD-SLAM, introduced by Engel et al [1]. It covers
the process of recovering geometrical information from images. The camera
could also be mounted on a robot and used for autonomous navigation. As
an input sensor, we use the camera images. The underlying process of re-
lating images to each other in LSD-SLAM is called Image Registration and
is explained further in the next section with some illustrative examples from

4

Medical Image Analysis.

2.2

Image Registration

The term Image Registration deﬁnes the process of determining a one-to-one
mapping or transformation between the coordinates in one space and those
in another, such that points in the two spaces that correspond to the same
point are mapped to each other.
It is about to ﬁnd a function, aligning
a moving image with a second ﬁxed image, such that a deﬁned similarity
measure is maximized. This underlying process can also be seen as part of
LSD-SLAM, it registers images to each other to retrieve information about
similarity transform sim(3) of our observed camera keyframes, achieved by
image-aligning.

Figure 4: Nuclear Medicine: X-ray co-registered with corresponding bone
scan. Image taken from [6].

In this section, we talk shortly about the principal methods of Image
Registration. We lean here mainly on the book Medical Image Registration
from Hill [6]. In Medical Image Analysis, images from anatomical changing
patients or diﬀerent sensors need to be registered to achieve Image Fusion
and / or improve Image Guided Surgery based on AR systems.

5

Figure 5: Bottom: Slice of Image Fusion from CT and MR Volumes Top
Left: CT TopRight: MR. Image taken from [6].

Image Registration can be done by four diﬀernt methods. Three of them
belong to rigid registration which are shortly explained here. Since nonlinear
(nonrigid) registrations are not as relevant in our case, we skip them for the
sake of this paper. The complexity of the methods increase in descending
listing order.

2.2.1 Feature Based Rigid Registration

Placing anatomic or geometric landmarks on the human body makes it easy
to identify these features (ﬁducials) in diﬀerent images. Since the markers
are very clearly to identify on every image, even if the images come from
diﬀerent sensors (CT-MR), the algorithm is straight forward by solving the
Procrustes Problem with Point-Based Registration. Given two sets of N
corresponding points P and Q, ﬁnd the similarity transformation (scale factor
s, rotation matrix R and translation vector P) that minimizes the mean
squared distance between the points:

EP rocrustes =

1
Np

N
(cid:88)

i=1

(cid:107)sRpi + t − qi(cid:107)2
2

(1)

6

Figure 6: Identify corresponding feature points (placed landmarkers on the
human head). Image taken from [6].

2.2.2 Surface Based Rigid Registration

A good gemoetrical feature of an object is represented by its boundary. This
approach can align large number of points in images but segmentation is
necessary for surface extraction. The extracted surface is represented either
as a point set, triangle set or as level set. Given a set of Np surface points
{pi} and a surface Q, it is about to ﬁnd the rigid-body transformation T,
where T is rotation matrix R and translation vector t that minimizes the
mean squared distance between the points and the surface:

d(T ) =

1
Np

Np
(cid:88)

i=1

(cid:107)T (pi) − qi(cid:107)2
2

qi = C(T (pi), Q)...C = correspondencef unction

Iterative Closest Point algorithm yields the solution for this problem.

(2)

(3)

7

Figure 7: Surface P: data shape (contour) and Surface Q: model shape (high-
resolution scan). Image taken from [6].

2.2.3

Intensity Based Rigid Registration (Voxel Similarity)

Intensity Based approaches are more complex, but also more powerful since
more information is used. Voxel Similarity measures must distinguish be-
tween Single-modality registration and Multi-modality registration. The
terms deﬁnes if the input images come from the same sensor, or diﬀerent
sensors. Depending on the domain, it is important to use suitable similarity
assumptions. When speaking of LSD-SLAM, the scene consists of constantly
changing intensities, but the sensor hardware (camera) stays the same.

• Single-Modality means images are retrieved from the same sensor,
e.g. CT-CT, MR-MR, PET-PET. etc. The main approach is to search
a transformation T, which is determined by iteratively minimizing a
voxel-based dissimilarity measure C. With Single-Modal, two diﬀerent
similarity assumptions about the intensity can be made, ”Identity” and
”Linear” which form the similarity metric.

Identity as a similarity assumption means, that the image intensity
only diﬀers by a Gaussian noise. The similarity metric of the Sum Of
Squared Diﬀerences (SSD) can be used.

C(x; T ) =

1
Np

(cid:88)

voxeli

(IA(xi) − IB(T (xi)))2

(4)

Though, it is sensitive to outliers, where the Sum Of Absolute Diﬀer-
ences (SAD) is better suited.

8

Linear assumes a linear relationship between image intensities. As a
similarity metric, the Normalized Cross Correlction (CC) is used.

CC(x; T ) =

(cid:80)[(IA(x) − µA)(IB(T (x)) − µB)]
(cid:112)(cid:80)(IA(x) − µA)2 (cid:80)(IB(T (x)) − µB)2

(5)

• Multi-Modality (MR-CT, MR-PET, CT-PET, etc) assumes that im-
age intensities are related by some unknown function or statistical re-
lationship which is not known a-priori.
Images are considered as a
(pixel-wise) probability distributions which can be estimated using a
histogram. Knowing this, it is possible to create 2D Joint Histograms
and retrieve knowledge about the Joint Probability p(a, b) of a pixel
having intensity a in one image and intensity b in another image.

Figure 8: 2D Joint Probability distribution of intensities for aligned MR and
FDG PET volumes (left), misaligned with a 2mm translation (middle) and
misaligned with a 5mm translation (right). Image taken from [6].

The amount of information in combined images A and B is described
by the Joint Entropy. Registration is achieved by minimizing the joint
entropy between both images. However, it is highly sensitive to the
overlap of two images.

H(A, B) = −

(cid:88)

(cid:88)

a

b

p(a, b)log2p(a, b)

(6)

Mutual Information on the other hand, describes how well an image
can be explained by another image and can be expressed in terms of
marginal and joint probability distributions:

I(A, B) =

(cid:88)

(cid:88)

a

b

p(a, b)log2

p(a, b)
p(a)p(b)

(7)

9

Registration can be achieved by maximizing the Mutual Information
between both images. Normalizing the Mutual Information leads to an
independent term of this expression:

I(A, B) =

H(A) + H(B)
H(A, B)

(8)

To optimize Voxel Similarity based techniques, Multi-Resolution opti-
mazation leads to an acceleration.

2.3 Simultaneous Localization and Mapping

The task of localization solves the problem of estimating the 3D pose of a
robot within an unkown environment. Mapping means computing a map
of the environment in which the robot is located in. The map is then used
as a reference for estimating 3D position. In principal, it is the same what
humans do when trying to navigate within an unknown environment. Speak-
ing of localization and mapping, means speaking of two diﬀerent problems.
However, as Davison [7] also pointed out, solving one of them requires solving
both of them. Diﬀerent SLAM approches are listet below.

2.3.1 Feature-based monocular SLAM

In feature-based monocular methods, the process of retrieving geometric in-
formation from images is splint into sequential tasks. The algorithm tries as
a ﬁrst step to extract feature observations from the input (image). From a set
of keypoint obversations, it is then possible to estimate 3D pose of the cur-
rent keypoint features and thus the camera world-coordinates by matching
the features with the set of keypoint observations. This means, all the other
image information except of the exctracted and observed features are thrown
away, approaching however real-time performance since the complexity of the
problem is reduced to the keypoint features.

The successful project MonoSLAM from Davison [7] uses feature-based

SLAM within a probabilistic framework running at a framerate of 30 Hz.

10

Figure 9: Detected feature patches of interest in camera stream (left) and
visualized in world space coordinate system (right). Image taken from [7].

However, Engel [1] clearly states out the big drawback on this method.
Only features who match the deﬁned feature type can be extracted (corners,
line segments).

2.3.2 Dense monocular SLAM (Direct)

This intensity-based approach improves over the feature-based SLAM method
by using all the information available in the image. It uses some measure
derived directly from the intensity of the image pixels which leads to more
information about the geometry. New image frames are tracked using whole-
image alignment. There is no need for feature extraction as in the previous
method. Due to the dense information, tracking accuracy and robustness is
widely improved over feature-based methods. That makes direct methods
very valuable for robotics or augmented reality systems.

The downside is the costly computation. As a comparison, the dense
depthmap is similar to the output of a RGB-D camera shown in the following
ﬁgure.

Figure 10: Left: keypoint depthmap Center: dense depthmap Right:
RGB-D camera. Image taken from [8].

11

2.4 Monocular LSD-SLAM

With Monocular Large-Scale Semi Dense SLAM, Engel [1, 8] proposed in
2013 the propably ﬁrst feautreless real-time approach for monocular visual
odometry, running with real-time framerates on a CPU which cuts out the
need for high-parallel performance GPU hardware. The algorithm intro-
duces 2 additional fundamental aspects. One is the estimation of semi-dense
depthmaps which improves performance sigiﬁcantly over dense depthmaps.
The second characteristic is then given by the large scale capability of the
algorithm.

The algorithm generates an intern global map, frame by frame, using
direct image alignment to estimate the camera’s 3D world position. This
global map consists of keyframes as vertices with 3D similarity transform
sim(3), represented as a pose graph. For each localization estimation, the
most up-to-date depthmap from the camera’s recent keyframe is used as a
reference for aligning the new captured image after motion movement.

Figure 11: Camera trajectory with LSD-SLAM on medium scale, showing
some estimated semi-dense keyframe depthmaps. Image taken from [1].

2.4.1 Semi-Dense

The key idea behind this approach is not to build a dense depthmap using
all intensities within the images, but to estimate a semi-dense inverse depth
map for the current observed keyframe. The semi-dense inverse depthmap
is modeled by using a Gaussian probability distribution which models one

12

inverse depth hypothesis per pixel. The depthmap is estimated each frame
and updated with a variable-baseline stere comparison.

Figure 12: Left: original captured camera image. Right: semi-dense depth
map (LSD-SLAM). Image taken from [8].

2.4.2 Large-Scale

This characteristic of Monocular LSD-SLAM solves one of the biggest chal-
lenges in SLAM because world scale can not be observed and it changes
during runtime. As depth or stereo cameras are very limited in scale, to pro-
vide realible measurements, LSD-SLAM enables a smooth switch between
diﬀerent scales within the world. The scale problem is solved by using in-
herent correlation between scene depth and tracking accuracy. Keyframes
have to be scaled such that the mean inverse depth is one and edges between
keyframes are estimated as elements of sim(3) allowing to detect scale-drift.

Figure 13: Two diﬀerent scenes showing scale-diﬀerences. The keyframe’s
camera viewport is displayed in red rectangles. Image taken from [1].

2.4.3 Complete Algorithm

To give an overview about the LSD-SLAM algorithm from Engel [1], we
summarize the components shortly. The algorithm has 3 main components,

13

tracking, depth map estimation and map optimization, illustrated in
ﬁgure 14

Figure 14: Illustration of the complete LSD-SLAM algorithm. Image taken
from [1].

• Tracking executes the task of permanently tracking new camera im-
ages. The rigid body pose se(3) of each current keyframe is estimated
by using the pose of the previous frame as a reference.

• Depth map estimation computes the semi-dense depth of each cur-
rent keyframe by ﬁltering over many per-pixel, small-baseline stereo
comparisons. It uses tracked frames, and reﬁnes the current keyframe.
In the case the camera’s motion was too large by moving too far, a new
keyframe is initialized which replaces the old keyframe. The replace-
ment is done by projecting points from existing, close-by keyframes
onto the new keyframe.

• Map optimization triggers when a new keyframe is replaced instead
of depth reﬁnement. It’s purpose is to update the global map with the
new tracked keyframe. Loop closures and scale-drift are detected by
estimating a similarity transform sim(3) to close-by existing keyframes
with scale-aware, direct sim(3)-image alignment.

3

Implementation

The project is now split into 2 Visual Studio projects, each accessible on
Github. The basic AR engine with Oculus Rift support can be accessed

14

via https://github.com/MaXvanHeLL/ARift.git and the modiﬁed LSD-
SLAM project for the integration is uploaded here https://github.com/
MaXvanHeLL/LSD-SLAM.git.

3.1 Calibration

Here we recap shortly the camera calibration process, documented in our
previous paper [2]. We have used the omnidirectional camera model from
Scaramuzza [9] and have written an undistortion shader in HLSL for our
engine. Thus, we could bypass the undistortion step for the LSD-SLAM, and
beneﬁt from a performance boost, since the undistortion shader runs highly
parallel on the GPU. We have computed the calibration with a polynomial
function of ﬁfth order. Distortion coeﬃcients are already integrated in the
projection function F.

Fprojection = a0 + a1p + a2p2 + a3p3 + a4p4 + a5p5

(9)

If the undistortion, integrated in the LSD-SLAM project, is desired, the
camera matrix has to be built with focal lengths and optical centers measured
in pixels.

CameraM atrixpinhole =





fx
0
0

0
fy
0





cx
cy
1

Also the distortion coeﬃcients are neccessary.

Distortioncoef f icients = (k1, k2, p1, p2, k3)

(10)

Both, the camera matrix and the distortion coeﬃcients are held in the ﬁle

out camera data.xml, located in the data directory of the project root.

3.2 Engine Integration

In our previous paper [2] we documented our complete AR stereo engine so
far. In this section, we give an overview of the major new components due
to the LSD-SLAM integration.

The core of the integration is represented by the new class LsdSlam3D,
illustrated in ﬁgure 15. It can be seen as an API to the dedicated Visual
Studio project of LSD-SLAM and holds for us the important information
about the camera’s real world position and rotation.

15

Figure 15: LSD-SLAM code integration. Image property of Markus H¨oll.

Since the GraphicsAPI is constantly synchronizing the virtual camera
with the now fully tracked LSD-SLAM camera, we added a mutex to ensure
stable synchronization and guarantee always clean and valid data informa-
tion.

Additionally, we have added another mutex, used for the camera images.
Since the camera stream is running in another thread, we also synchronized
the data exchange between the image capturing and SLAM operation.

3.3

Initialization

In the main function we set up all the needed LSD-SLAM properties. First
of all, the CvCapture property, which holds information about the tracked
monocular camera. The camera is referenced wit an ID, starting from 0 to
ascending order. Also the capture frame dimensions are set here with 640 x
480.

After that, we initialize the camera stream thread, used by LSD-SLAM.
Since we modiﬁed the original lsd slam::OpenCVImageStreamThread, we
introduced a new one called lsd slam::IDSuEyeCameraStreamThread.
The slight modiﬁcations to our custom input stream are documented in sec-
tion 3.6.

Now we are about to set the monocular camera buﬀer to the IDSuEye-
CameraStreamThread. The camera stream thread will from now on con-

16

stantly read out the frames stored in the undistortion buﬀer, retrieved from
the HLSL shader.

To complete the initalization, we allocate our new introduced LsdSlam3D
API object where we will retrieve the desired 3D camera translation and ro-
tation as an output.

1 int main ( int , char **)
2 {
3
4
5
6
7

// init DirectX Graphics , Cameras and OculusHMD
[...]

CvCapture * capture = cvCaptureFromCAM ( LsdSlam_CAM )
cvSetCaptureProperty ( capture ,

CV_CAP_PROP_FRAME_WIDTH , 640) ;

cvSetCaptureProperty ( capture ,

CV_CAP_PROP_FRAME_HEIGHT , 480) ;

lsd_slam :: IDSuEyeCameraStreamThread * inputStream =
new lsd_slam :: IDSuEyeCameraStreamThread () ;

inputStream - > setCameraCapture ( capture ) ;
if ( LsdSlam_UNDISTORTION ) // use undistorted imgs
inputStream - > setIDSuEyeCameraStream (

undistBuffer_ , undistBufferMutex_ , true ) ;

else // use raw images

inputStream - > setIDSuEyeCameraStream ( cont .

camInput_ - > lsdslamBuffer_ , cont . camInput_
- > lsdslamMutex_ , false ) ;

inputStream - > run () ;

// Init LSD - SLAM with outputstream and inputstream
lsd_slam :: Output3DWrapper * outputStream = new
lsd_slam :: LsdSlam3D ( inputStream - > width () ,
inputStream - > height () ) ;

lsd_slam :: LiveSLAMWrapper slamNode ( inputStream ,

outputStream ) ;

dx11 - > setLsdSlamTracking AndMap ping ( outputStream ) ;

8

9
10

11
12
13

14
15

16
17
18
19

20

21
22 }

17

3.4 Render Loop Update

Some program controls allow us to switch between LSD-SLAM rotation and
gyro sensor rotation from the Oculus Rift, aswell as to decide if we want
to use LSD-SLAM translation or only the virtual head camera. Since we
can set those controls individually, the Frame() function has been modiﬁed
accordingly:

1 bool GraphicsAPI :: Frame ()
2 {
3

// [ Lsd - Slam ] Virtual Camera Update
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

if ( LsdSlam_Rotation )

updateLsdSlam3DRotation () ;

else

OculusMotion () ;

// [ Lsd - Slam ] Virtual Camera Update
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

if ( LsdSlam_Translation )

updateLsdSlam3DPosition () ;

else

headCamera_ - > SetPosition ( ariftcontrol_ - >
cameraPositionX_ , ariftcontrol_ - >
cameraPositionY_ , ariftcontrol_ - >
cameraPositionZ_ ) ;

// Render the virtual scene .
Render () ;

4
5
6
7
8
9

10
11
12
13

14
15
16
17 }

As the name suggests, the updateLsdSlam3DRotation() method up-
dates internally the virtual camera rotation matrix with the one retrieved
from LSD-SLAM. Also we convert the Eigen::MatrixXd* to our matching
coordinate system convention.

// waits internally or throws error code
if (! acquireLsdSlam 3D Ro ta tionMutex () )

1 void GraphicsAPI :: updateLsdSlam3DRotation ()
2 {
3
4
5
6
7

XMFLOAT3X3 cam . Rot . Matrix = {};

return ;

18

if ( lsdslam3D_ )
{

Eigen :: MatrixXd * riftRot . Matrix = dynamic_cast <

lsd_slam :: LsdSlam3D * >( lsdslam3D_ ) ->
getRiftRotation3D () ;

cam . Rot . Matrix . _11 = (* riftRot . Matrix ) (0 ,0) ;
cam . Rot . Matrix . _12 = (* riftRot . Matrix ) (1 ,0) ;
cam . Rot . Matrix . _13 = (* riftRot . Matrix ) (2 ,0) ;
cam . Rot . Matrix . _21 = (* riftRot . Matrix ) (0 ,1) ;
cam . Rot . Matrix . _22 = (* riftRot . Matrix ) (1 ,1) ;
cam . Rot . Matrix . _23 = (* riftRot . Matrix ) (2 ,1) ;
cam . Rot . Matrix . _31 = (* riftRot . Matrix ) (0 ,2) ;
cam . Rot . Matrix . _32 = (* riftRot . Matrix ) (1 ,2) ;
cam . Rot . Matrix . _33 = (* riftRot . Matrix ) (2 ,2) ;

cam . Rot . Matrix . _32 *= ( -1) ;
cam . Rot . Matrix . _23 *= ( -1) ;
cam . Rot . Matrix . _12 *= ( -1) ;
cam . Rot . Matrix . _21 *= ( -1) ;

}

headCamera_ - > LsdSlamRotationMatrix_ =

rotationMatrix ;

releas eL sdSlam3DRotat io nM ut ex () ;

8
9
10

11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27

28
29
30 }

What happens in updateLsdSlam3DTranslation() is basically a smooth

3D movement implementation and a reference comparison with LSD-SLAM
data. We store a lsdslam reference which is directly compared with the
accurat retrieved riftPosition from LSD-SLAM . Since we wanted to achieve
a smooth movement we have added some thresholding value to erase small
correction errors. Further we invented a scaling factor for the movement, to
be not as limited and scale in diﬀerent worlds accordingly. Of course, when
we don’t have a lsdslam reference yet, we are in the initialization phase
and just store the current position as the origin reference.

1 void GraphicsAPI :: updateLsdSlam3DPosition ()
2 {
3
4
5

// waits internally or throws error code
if (! acquireLsdSlam 3D Po si tionMutex () )

return ;

19

6
7
8
9
10
11
12

13
14
15
16
17
18
19
20
21

22

23
24
25

26
27

28

29

30
31
32
33
34
35

36

bool pos_x_changed = false ;
bool pos_y_changed = false ;
bool pos_z_changed = false ;

// calling LsdSlam3D API internally
lsd_slam :: LsdSlam3D :: RiftPosition3D * riftPosition

= getLsdSlam3DPosition () ;

if ( lsdslam_init_ == true )
{

lsdslam_ref . x = riftPosition - > x ;
lsdslam_ref . y = riftPosition - > y ;
lsdslam_ref . z = riftPosition - > z ;
lsdslam_init_ = false ;

}

XMFLOAT3 camera_position = headCamera_ - >

GetPosition () ;

float move_direction = headCamera_ - >

headToEyeOffset_ . rotationY_ * 0.0174532925 f ;

// [ Move ] Forward / Backward --- -- - ---- ---- ---- -
if (( riftPosition - > z > ( lsdslam_reference_ . z +

LsdSlam_Threshold ) ) ) // Move Forwards

{

float distance = riftPosition - > z -

lsdslam_reference_ . z ;

float new_position_x = ( camera_position . x ) +

sinf ( move_direction ) * ( distance *
LsdSlam_ScaleFactor ) ;

float new_position_z = ( camera_position . z ) +

cosf ( move_direction ) * ( distance *
LsdSlam_ScaleFactor ) ;

headCamera_ - > SetPositionX (( new_position_x ) ) ;
headCamera_ - > SetPositionZ (( new_position_z ) ) ;
pos_x_changed = true ;
pos_z_changed = true ;

}
else if (( riftPosition - > z < ( lsdslam_reference_ . z

- LsdSlam_Threshold ) ) ) // Move Backwards

{

20

37

38

39

40
41
42
43
44
45
46

47
48

49

50

51
52
53
54
55
56
57

58
59

60

61

float distance = lsdslam_reference_ . z -

riftPosition - > z ;

float new_position_x = ( camera_position . x ) -

sinf ( move_direction ) * ( distance *
LsdSlam_ScaleFactor ) ;

float new_position_z = ( camera_position . z ) -

cosf ( move_direction ) * ( distance *
LsdSlam_ScaleFactor ) ;

headCamera_ - > SetPositionX (( new_position_x ) ) ;
headCamera_ - > SetPositionZ (( new_position_z ) ) ;
pos_x_changed = true ;
pos_z_changed = true ;

}
// [ Strafe ] Left / Right - ---- - -- - --- ---- ---
if (( riftPosition - > x > ( lsdslam_reference_ . x +

LsdSlam_Threshold ) ) ) // Strafe Right

{

float distance = riftPosition - > x -

lsdslam_reference_ . x ;

float new_position_x = ( camera_position . x ) +

cosf ( move_direction ) * ( distance *
LsdSlam_ScaleFactor ) ;

float new_position_z = ( camera_position . z ) +

sinf ( move_direction ) * ( distance *
LsdSlam_ScaleFactor ) ;

headCamera_ - > SetPositionX (( new_position_x ) ) ;
if (! pos_z_changed )

headCamera_ - > SetPositionZ (( new_position_z ) ) ;

pos_x_changed = true ;
pos_z_changed = true ;

}
else if (( riftPosition - > x < ( lsdslam_reference_ . x

- LsdSlam_Threshold ) ) ) // Strafe Left

{

float distance = lsdslam_reference_ . x -

riftPosition - > x ;

float new_position_x = ( camera_position . x ) -

cosf ( move_direction ) * ( distance *
LsdSlam_ScaleFactor ) ;

float new_position_z = ( camera_position . z ) -

sinf ( move_direction ) * ( distance *

21

LsdSlam_ScaleFactor ) ;

headCamera_ - > SetPositionX (( new_position_x ) ) ;
if (! pos_z_changed )

headCamera_ - > SetPositionZ (( new_position_z ) ) ;

pos_x_changed = true ;
pos_z_changed = true ;

}
// [ Fly ] Up / Down --- -- -- --- -- -- ---- -
if (( riftPosition - > y > ( lsdslam_reference_ . y +

LsdSlam_Threshold ) ) ) // Down

{

float distance = riftPosition - > y -

lsdslam_reference_ . y ;

float new_position_y = ( camera_position . y ) -

(

distance * LsdSlam_ScaleFactor ) ;

headCamera_ - > SetPositionY (( new_position_y ) ) ;
pos_y_changed = true ;

}
else if (( riftPosition - > y < ( lsdslam_reference_ . y

- LsdSlam_Threshold ) ) ) // Up

{

}

float distance = lsdslam_reference_ . y -

riftPosition - > y ;

float new_position_y = ( camera_position . y ) + (

distance * LsdSlam_ScaleFactor ) ;

headCamera_ - > SetPositionY (( new_position_y ) ) ;
pos_y_changed = true ;

// update LsdSlam Reference Position
if ( pos_x_changed )

lsdslam_reference_ . x = riftPosition - > x ;

if ( pos_y_changed )

lsdslam_reference_ . y = riftPosition - > y ;

if ( pos_z_changed )

lsdslam_reference_ . z = riftPosition - > z ;

releaseLsdSlam3DPositionMutex () ;

62
63
64
65
66
67
68
69

70
71

72

73
74
75
76

77
78

79

80
81
82
83
84
85
86
87
88
89
90
91
92
93 }

22

3.5 Undistortion ShaderBuﬀer for LSD-SLAM

Since we have used our own undistortion images retrieved from our frag-
ment shader, we had to adapt the region-of-interest (ROI) of the undis-
torted images to ensure that we only pass fully valid image data to our
lsd slam::IDSuEyeCameraStreamThread.

After the undistortion, our image buﬀer itself holds of course black bor-
ders which correct the distortion, illustrated in ﬁgure 16. With the parameter
camID we can control which of our cameras we want to use for the LSD-
SLAM, which changes also the ROI parameters due to undistortion.

Figure 16: Undistortion mapping and ROI extraction.
Markus H¨oll.

Image property of

The undistorted images were so far fully placed in the GPU memory,
since they were computed from our fragment shader. Therefore, we had to
setup an explicit mapped CPU access to copy data from the GPU memory.
After we have copied the image data to from the GPU, we converted the
images’ data buﬀer to an IplImage* frame where we then can extract the
correct ROI, depending on which camera we use for tracking.

For the last step, we resized the image to 640 x 480 which are the sug-
gested dimensions for LSD-SLAM and copy the images to the image buﬀer.

1 void GraphicsAPI :: UndistortionForLsdSlam ( int camID )
2 {
3
4

ID3D11Resource * renderBuffer ;
if ( camID == 1)

23

5

6
7

8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23

24

25
26
27
28

29

30
31

32

33

renderTextureLeft_ - > GetRenderTargetView () ->

GetResource (& renderBuffer ) ;

else

renderTextureRight_ - > GetRenderTargetView () ->

GetResource (& renderBuffer ) ;

D3D11_TEXTURE2D_DESC texDesc ;
texDesc . ArraySize = 1;
texDesc . BindFlags = 0;
texDesc . CPUAccessFlags = D3D11_CPU_ACCESS_READ ;
texDesc . Format = DXGI_FORMA T_R8G8B8A8_UNORM ;
texDesc . Width = screenWidth_ ;
texDesc . Height = screenHeight_ ;
texDesc . MipLevels = 1;
texDesc . MiscFlags = 0;
texDesc . SampleDesc . Count = 1;
texDesc . SampleDesc . Quality = 0;
texDesc . Usage = D3D11_USAGE_STAGING ;

ID3D11Texture2D * undistortedShaderTex ;
device_ - > CreateTexture2D (& texDesc , 0 , &

undistortedShaderTex ) ;

devicecontext_ - > CopyResource ( undistortedShaderTex ,

renderBuffer ) ;

// Map Resource From GPU to CPU
D3D11_MAPPED_SUBRESOURCE mappedResource ;
if ( FAILED ( devicecontext_ - > Map (

undistortedShaderTex , 0 , D3D11_MAP_READ , 0 , &
mappedResource ) ) )
std :: cout << " Error : (cid:32) [ CAM (cid:32) 2] (cid:32) could (cid:32) not (cid:32) Map (cid:32)

Rendered (cid:32) Camera (cid:32) ShaderResource (cid:32) for (cid:32)
Undistortion " << std :: endl ;

unsigned char * buffer = new unsigned char [(

screenWidth_ * screenHeight_ * CAMERA_CHANNELS )
];

unsigned char * mappedData = reinterpret_cast <
unsigned char * >( mappedResource . pData ) ;
memcpy ( buffer , mappedData , ( screenWidth_ *

screenHeight_ * 4) ) ;

24

34
35
36
37

38
39
40
41
42
43
44
45
46
47
48

49
50

51
52
53
54
55

56
57

58
59
60
61

62
63
64
65
66

devicecontext_ - > Unmap ( undistortedShaderTex , 0) ;

// OpenCV IplImage * Convertion
IplImage * frame = cvCreateImageHeader ( cvSize (
screenWidth_ , screenHeight_ ) , IPL_DEPTH_8U ,
CAMERA_CHANNELS ) ;

frame - > imageData = ( char *) buffer ;
cvSetData ( frame , buffer , frame - > widthStep ) ;
cv :: Mat mymat = cv :: Mat ( frame , true ) ;

// Extract ROI
cv :: Rect roi ;
switch ( camID )
{

case 1: // Left Camera
if ( HMD_DISTORTION )

roi = cv :: Rect (300 , 230 , screenWidth_ - 300 ,

screenHeight_ - 410) ;

else

roi = cv :: Rect (10 , 170 , screenWidth_ - 10 ,

screenHeight_ - 250) ;

break ;

case 2: // Right Camera
if ( HMD_DISTORTION )

roi = cv :: Rect (5 , 230 , screenWidth_ - 170 ,

screenHeight_ - 450) ;

else

roi = cv :: Rect (5 , 150 , screenWidth_ - 10 ,

screenHeight_ - 290) ;

break ;

default :

roi = cv :: Rect (0 , 0 , screenWidth_ ,

screenHeight_ ) ;

}
cv :: Mat roi_mat = mymat ( roi ) ;

// Resize for LSD - SLAM 640 x480
IplImage * resized_ipl = cvCreateImage ( cvSize (640 ,

480) , IPL_DEPTH_8U , CAMERA_CHANNELS ) ;

25

IplImage * ipl_roi = new IplImage ( roi_mat ) ;
cvResize (( IplImage *) ipl_roi , resized_ipl ,

CV_INTER_LINEAR ) ;

cv :: Mat lsdslam_image = cv :: Mat ( resized_ipl , true )

;

WaitForSingleObject ( undistortedShaderMutex_ ,

INFINITE ) ;

memcpy ( undistortedShaderBuffer_ , lsdslam_image .

data , (640 * 480 * CAMERA_CHANNELS ) ) ;

ReleaseMutex ( undistortedShaderMutex_ ) ;

if (! undistortionReady_ )

undistortionReady_ = true ;

if ( undistortedShaderTex )

undistortedShaderTex - > Release () ;

if ( buffer )

delete ( buffer ) ;

if ( resized_ipl )

cvReleaseImage (& resized_ipl ) ;

if ( ipl_roi )

delete ( ipl_roi ) ;

67
68

69

70
71

72

73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89 }

3.6 LSD-SLAM Code Modiﬁcations

Generally, the camera capturing and undistortion process is implemented in
the OpenCVImageStreamThread but we already mentioned above that
we have used our own undistortion, retrieved from our undistortion shader
and supply LSD-SLAM with a buﬀer of those undistorted images. We show
the code modiﬁcations within the LSD-SLAM project itself. For this purpose,
we introduced a new class lsd slam::IDSuEyeCameraStreamThread.

26

3.6.1

lsd slam::IDSuEyeCameraStreamThread

The constructor makes it pretty clear which data is neccessary. The camer-
aBuﬀer and cameraMutex are pointers to instances where the thread should
read data from. We just copy the data from cameraBuﬀer to the internally
used frameBuﬀer .

iDSuEyeFrame is the ﬁnal data type on which LSD-SLAM is processing
on and resizedFrame is needed in some cases when the image dimensions
are not 640 x 480.

Finally, use shaderUndistortion just tells us if we want to use the undis-
torted images supplied by our shader, or might want to use raw image data
or something else for any reason.

1

2
3
4
5
6
7
8
9

IDSuEyeCameraStreamThread ::

IDSuEyeCameraStreamThread ()

{

}

cameraBuffer_ = 0;
cameraMutex_ = 0;
frameBuffer_ = 0;
iDSuEyeFrame_ = 0;
resizedFrame_ = 0;
use_shaderUndistortion_ = false ;

This method- setIDSuEyeCameraStream() - is called in the conﬁg-
uration phase directly from main, to set the corresponding pointers and
conﬁgs for camera streaming.

1

void IDSuEyeCameraStreamThread ::

setIDSuEyeCameraStream ( unsigned char *
cameraBuffer , void * cameraMutex , bool
use_shaderUndistortion )

2 {
3
4
5
6
7
8
9
10
11

cameraBuffer_ = cameraBuffer ;
cameraMutex_ = cameraMutex ;
use_shaderUndistortion_ = use_shaderUndistortion ;

if ( use_shaderUndistortion_ )

frameBuffer_ = new char [ LsdSlam_BUFFER_LENGTH ];

else
{

frameBuffer_ = new char [ CAMERA_BUFFER_LENGTH ];

27

12

resizedFrame_ = cvCreateImage ( cvSize (

LsdSlam_CAM_WIDTH , LsdSlam_CAM_HEIGHT ) ,
IPL_DEPTH_8U , CAMERA_CHANNELS ) ;

}

13
14 }

The run() method is calling the actual runtime loop of the thread.

1 void IDSuEyeCameraStreamThread :: run ()
2 {
3
4

boost :: thread thread ( boost :: ref (* this ) ) ;

}

In the beginning before the Loop starts, we check if we have valid camera
objects and jump then into the runtime loop, which overrides the actual
image streaming to the LSD-SLAM. In case of using the undistortiion images
from the shader, there is not much happening here since everything has been
prepared previously from the GraphicsAPI.

However, if we might want to use the image raw data for tracking or
something else, we have to sample the images to ﬁt the suggested dimensions.

1 void IDSuEyeCameraStreamThread :: operator () ()
2 {
3
4
5
6

WaitForSingleObject ( cameraMutex_ , INFINITE ) ;
if (! cameraBuffer_ || ! cameraMutex_ )
{

assert ( " NO (cid:32) valid (cid:32) IDSuEye (cid:32) Camerabuffer (cid:32) found (cid:32) for (cid:32)

7
8
9
10
11
12
13
14
15

16
17
18
19

Tracking (cid:32) and (cid:32) Mapping " ) ;

return ;

}
ReleaseMutex ( cameraMutex_ ) ;
while (1)
{

TimestampedMat bufferItem ;
bufferItem . timestamp = Timestamp :: now () ;

// Use Undistortion provided by our Fragment

Shader ROI (640 x 480)
if ( use_shaderUndistortion_ )
{

WaitForSingleObject ( cameraMutex_ , INFINITE ) ;
memcpy ( frameBuffer_ , cameraBuffer_ ,

LsdSlam_BUFFER_LENGTH ) ;

28

ReleaseMutex ( cameraMutex_ ) ;
iDSuEyeFrame_ = cvCreateImageHeader ( cvSize (
LsdSlam_CAM_WIDTH , LsdSlam_CAM_HEIGHT ) ,
IPL_DEPTH_8U , CAMERA_CHANNELS ) ;

iDSuEyeFrame_ - > imageData = frameBuffer_ ;
iDSuEyeFrame_ - > imageDataOrigin = iDSuEyeFrame_

- > imageData ;

}

else // use raw image data from cams (752 x 480)
{

WaitForSingleObject ( cameraMutex_ , INFINITE ) ;
memcpy ( frameBuffer_ , cameraBuffer_ ,

CAMERA_BUFFER_LENGTH ) ;
ReleaseMutex ( cameraMutex_ ) ;
iDSuEyeFrame_ = cvCreateImageHeader ( cvSize (

CAMERA_WIDTH , CAMERA_HEIGHT ) , IPL_DEPTH_8U ,

CAMERA_CHANNELS ) ;

iDSuEyeFrame_ - > imageData = frameBuffer_ ;
iDSuEyeFrame_ - > imageDataOrigin = iDSuEyeFrame_

- > imageData ;

iDSuEyeFrame_ = ResizeFrame ( iDSuEyeFrame_ ,
LsdSlam_CAM_WIDTH , LsdSlam_CAM_HEIGHT ) ;

}
bufferItem . data = iDSuEyeFrame_ ;
imageBuffer - > pushBack ( bufferItem ) ;

}
exit (0) ;

20
21

22
23

24
25
26
27
28

29
30

31
32

33

34
35
36
37
38
39 }

A short method for re-sampling an IplImage to the desired image dimen-

sions. In our case, we would downsample from 752 x 480 to 640 x 480.

1
2 IplImage * IDSuEyeCameraStreamThread :: ResizeFrame (

IplImage * src_frame , int new_width , int
new_height )

3 {
4

5

if ( new_width != LsdSlam_CAM_WIDTH || new_height

!= LsdSlam_CAM_HEIGHT )
resizedFrame_ = cvCreateImage ( cvSize ( new_width ,
new_height ) , src_frame - > depth , src_frame - >
nChannels ) ;

29

6

cvResize ( src_frame , resizedFrame_ , CV_INTER_LINEAR

) ;

return resizedFrame_ ;

7
8 }

3.7 Light Shading Model - Rendering Equation

As a very small gimmick, we also modiﬁed our fragment shader from the
previously used Lambert Shading to a Phong Shading model. This reﬂection
model can be implemented without any eﬀort actually but gives quite a more
realistic look to the holograms due to the reﬂection term which yields specular
highlights. Since it is still a local illumination model, an approximation of
global illumination in form of an ambient light term is added to the rendering
equation.

Generally, the shading model has 3 components, a diﬀuse illumination
kd, a specular reﬂection component ks and an ambient term ka. This gives
a formal expression like 11.

IShadingM odel = Idif f use + Iambient + Ispecular.

(11)

Formulating the model more precisely for each component, we get the

render equation according to formula 12.

IP hongShading = kaIa + Idirect(Kd((cid:126)L · (cid:126)N ) + ks((cid:126)V · (cid:126)R)n)

(12)
(cid:126)L is a vector from the surface point to the emmitting light source. (cid:126)N
is the normal vector of the surface point. (cid:126)V stands for a direction vector,
pointing towards the observer (viewer) and (cid:126)R is the direction of the reﬂected
light which the light ray takes from this surface point on.

3.8 New Engine Conﬁgurations

A list of new conﬁguration mechanics, added during the integration process:

• LsdSlam Threshold - conﬁgures a threshold which eliminates smaller

correction errors in the tracking

• LsdSlam ScaleFactor - conﬁgure the scaling from the virtual move-

ment, retrieved from LSD-SLAM

• LsdSlam UNDISTORTION - provide LSD-SLAM with undistorted shader

images

30

• LsdSlam Translation - use translation from LSD-SLAM or not

• LsdSlam Rotation - use rotation from LSD-SLAM or Oculus Rift’s

gyro sensor

• VSYNC ENABLED - enables / disables vertical synchronization

3.9 New Libraries

• LSD-SLAM

• OpenCV

• boost

• g2o

4 Conclusion

We are really satisﬁed with the results. The integration process actually
worked quite good, however it was still some coding work to adapt the en-
gine for the use of LSD-SLAM. That’s mainly because we have used an
omnidirectional camera model for our high degree ﬁsheye-lenses to compute
the calibration. And since we already computed the undistortion with a
fragment shader in HLSL we wanted to use them for LSD-SLAM aswell. So
basically, we had to tweak the image streaming to the algorithm and could
not use the prepared OpenCVImageStreamThread.

The project was shown also at the OpenLAB-Night 2016 of the In-
stitute for Computer Graphics and Computer Vision (ICG) at TU
Graz. The guests could try it out and we received alot of good feedback.
The people showed alot of interest in the project and generally in AR itself.
Tracking the real-world camera and synchronizing it’s 3D movement with
It still feels exciting to walk
the virtual head camera worked pretty well.
towards 3D holograms which are augmented in the real world, going around
them and crouch to see them from below.

The following ﬁgures show some ﬁnal tracking results. The digimon model
and texture ﬁle from the result images are taken from web source models-
resource.com under educational usage purposes. The chessboard which some-
times is in the scene was only used for camera calibration.

31

Figure 17: Results: near distance. Image property of Markus H¨oll

Figure 18: Results: crouching, near distance. Image property of Markus
H¨oll

32

Figure 19: Results: far distance. Image property of Markus H¨oll

Figure 20: Results: side view, walking around. Image property of Markus
H¨oll

33

5 Future Work

We want to focus now on the interaction with virtual objects. The motiva-
tion is an interaction system in AR which feels more natural like using our
hands and interacting with virtual objects the same way or at least similar
as we do with real objects. We expect that to increase the immersion of AR
signiﬁcantly. However, we strongly consider a hardware upgrade since the
Oculus Rift DK1 is pretty old already and the display’s resolution is very
low. We will use the HoloLens for this project and see how it feels like if
we change the interaction system of it with our own one.
It will be very
interesting to see how that works out and if we might also use some func-
tionality of the interaction from the HoloLens, like maybe using the ”Gaze”
raycaster for highlighting the virtual objects but further interacting with our
hand gestures or totally bypass the whole interaction and only use the new
one.

To capture our hand skeleton, we will use the Leap Motion controller
which is using structured light for measurement. The Leap Motion has al-
ready a VR mount to install it on the front plate of VR HMDs. Since that
could be tricky on the HoloLens, a custom mount might be the better choice.
What might be more tricky is the communication between the HoloLens and
the Leap Motion, since we will need to set up a remote communication be-
tween them due to the fact that the USB ports of the HoloLens can not be
used for periphery devices appearantly. Another challenge will be to trans-
late the coordinates from the Leap Motion’s coordinate system to the AR
space of the HoloLens and compute a ﬁne hand gesture detection and collision
resolution on virtual objects.

34

References

[1] J. Engel, T. Sch¨ops, and D. Cremers, “Lsd-slam: Large-scale di-
rect monocular slam,” in Computer Vision–ECCV 2014, pp. 834–849,
Springer, 2014. ii, 4, 11, 12, 13, 14

[2] M. H¨oll, N. Heran, and V. Lepetit, “Augmented reality oculus rift,” arXiv

preprint arXiv:1604.08848, 2016. ii, 2, 3, 15

[3] M. Montemerlo, S. Thrun, D. Koller, B. Wegbreit, et al., “Fastslam: A
factored solution to the simultaneous localization and mapping problem,”
in Aaai/iaai, pp. 593–598, 2002. 2

[4] G. Klein and D. Murray, “Parallel tracking and mapping for small ar
workspaces,” in Mixed and Augmented Reality, 2007. ISMAR 2007. 6th
IEEE and ACM International Symposium on, pp. 225–234, IEEE, 2007.
4

[5] H. Kato and M. Billinghurst, “Marker tracking and hmd calibration for a
video-based augmented reality conferencing system,” in Augmented Re-
ality, 1999.(IWAR’99) Proceedings. 2nd IEEE and ACM International
Workshop on, pp. 85–94, IEEE, 1999. 4

[6] D. L. Hill, P. G. Batchelor, M. Holden, and D. J. Hawkes, “Medical image
registration,” Physics in medicine and biology, vol. 46, no. 3, p. R1, 2001.
5, 6, 7, 8, 9

[7] A. J. Davison, I. D. Reid, N. D. Molton, and O. Stasse, “Monoslam:
Real-time single camera slam,” IEEE transactions on pattern analysis
and machine intelligence, vol. 29, no. 6, pp. 1052–1067, 2007. 10, 11

[8] J. Engel, J. Sturm, and D. Cremers, “Semi-dense visual odometry for a
monocular camera,” in Proceedings of the IEEE international conference
on computer vision, pp. 1449–1456, 2013. 11, 12, 13

[9] D. Scaramuzza, A. Martinelli, and R. Siegwart, “A toolbox for easily
calibrating omnidirectional cameras,” in Intelligent Robots and Systems,
2006 IEEE/RSJ International Conference on, pp. 5695–5701, IEEE,
2006. 15

35

