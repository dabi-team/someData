4D Spatio-Temporal ConvNets: Minkowski Convolutional Neural Networks

Christopher Choy
chrischoy@stanford.edu

JunYoung Gwak
jgwak@stanford.edu

Silvio Savarese
ssilvio@stanford.edu

9
1
0
2

n
u
J

3
1

]

V
C
.
s
c
[

4
v
5
5
7
8
0
.
4
0
9
1
:
v
i
X
r
a

Abstract

In many robotics and VR/AR applications, 3D-videos are
readily-available sources of input (a continuous sequence of
depth images, or LIDAR scans). However, these 3D-videos
are processed frame-by-frame either through 2D convnets
or 3D perception algorithms in many cases. In this work, we
propose 4-dimensional convolutional neural networks for
spatio-temporal perception that can directly process such
3D-videos using high-dimensional convolutions. For this,
we adopt sparse tensors [8, 9] and propose the generalized
sparse convolution which encompasses all discrete convo-
lutions. To implement the generalized sparse convolution,
we create an open-source auto-differentiation library for
sparse tensors that provides extensive functions for high-
dimensional convolutional neural networks.1 We create 4D
spatio-temporal convolutional neural networks using the
library and validate them on various 3D semantic segmen-
tation benchmarks and proposed 4D datasets for 3D-video
perception. To overcome challenges in the high-dimensional
4D space, we propose the hybrid kernel, a special case of the
generalized sparse convolution, and the trilateral-stationary
conditional random ﬁeld that enforces spatio-temporal con-
sistency in the 7D space-time-chroma space. Experimentally,
we show that convolutional neural networks with only gen-
eralized sparse convolutions can outperform 2D or 2D-3D
hybrid methods by a large margin.2 Also, we show that
on 3D-videos, 4D spatio-temporal convolutional neural net-
works are robust to noise, outperform 3D convolutional
neural networks and are faster than the 3D counterpart in
some cases.

1. Introduction

In this work, we are interested in 3D-video perception.
A 3D-video is a temporal sequence of 3D scans such as a
video from a depth camera, a sequence of LIDAR scans,
or a multiple MRI scans of the same object or a body part
(Fig. 1). As LIDAR scanners and depth cameras become

1https://github.com/StanfordVL/MinkowskiEngine
2At the time of submission, we achieved the best performance on Scan-

Net [5] with 67.9% mIoU

1

Figure 1: An example of 3D video: 3D scenes at different
time steps. Best viewed on display.

1D: Line

2D: Square

3D: Cube

4D: Tesseract

Figure 2: 2D projections of hypercubes in various dimen-
sions

more affordable and widely used for robotics applications,
3D-videos became readily-available sources of input for
robotics systems or AR/VR applications.

However, there are many technical challenges in using 3D-
videos for high-level perception tasks. First, 3D data requires
heterogeneous representations and processing those either
alienates users or makes it difﬁcult to integrate into larger
systems. Second, the performance of the 3D convolutional
neural networks is worse or on-par with 2D convolutional
neural networks. Third, there are limited number of open-
source libraries for fast large-scale 3D data.

To resolve most, if not all, of the challenges in the high-
dimensional perception, we adopt a sparse tensor [8, 9] for
our problem and propose the generalized sparse convolu-
tions. The generalized sparse convolution encompasses all
discrete convolutions as its subclasses and is crucial for
high-dimensional perception. We implement the generalized
sparse convolution and all standard neural network functions
in Sec. 4 and open-source the library.

We adopt the sparse representation for several reasons.
Currently, there are various concurrent works for 3D percep-
tion: a dense 3D convolution [5], pointnet-variants [22, 23],
continuous convolutions [11, 15], surface convolutions [20,
29], and an octree convolution [24]. Out of these representa-
tions, we chose a sparse tensor due to its expressiveness and
generalizability for high-dimensional spaces. Also, it allows

 
 
 
 
 
 
homogeneous data representation within traditional neural
network libraries since most of them support sparse tensors.
Second, the sparse convolution closely resembles the stan-
dard convolution (Sec. 3) which is proven to be successful
in 2D perception as well as 3D reconstruction [4], feature
learning [33], and semantic segmentation [30].

Third, the sparse convolution is efﬁcient and fast. It only
computes outputs for predeﬁned coordinates and saves them
into a compact sparse tensor (Sec. 3). It saves both memory
and computation especially for 3D scans or high-dimensional
data where most of the space is empty.

Thus, we adopt the sparse representation for the our
problem and create the ﬁrst large-scale 3D/4D networks or
Minkowski networks.3 We named them after the space-time
continuum, Minkowski space, in Physics.

However, even with the efﬁcient representation, merely
scaling the 3D convolution to high-dimensional spaces re-
sults in signiﬁcant computational overhead and memory con-
sumption due to the curse of dimensionality. A 2D convo-
lution with kernel size 5 requires 52 = 25 weights which
increases exponentially to 53 = 125 in a 3D cube, and 625 in
a 4D tesseract (Fig. 2). This exponential increase, however,
does not necessarily lead to better performance and slows
down the network signiﬁcantly. To overcome this challenge,
we propose custom kernels with non-(hyper)-cubic shapes
using the generalized sparse convolution.

Finally, the predictions from the 4D spatio-temporal
generalized sparse convnets are not necessarily consistent
throughout the space and time. To enforce consistency, we
propose high-dimensional conditional random ﬁelds deﬁned
in a 7D trilateral space (space-time-color) with a stationary
pairwise consistency function. We use variational inference
to convert the conditional random ﬁeld to differentiable re-
current layers which can be implemented in as a 7D general-
ized sparse convnet and train both the 4D and 7D networks
end-to-end.

Experimentally, we use various 3D benchmarks that cover
both indoor [5, 2] and outdoor spaces [27, 25]. First, we
show that networks with only generalized sparse 3D conv
nets can outperform 2D or hybrid deep-learning algorithms
by a large margin.4 Also, we create 4D datasets from Syn-
thia [27] and Varcity [25] and report ablation studies of
temporal components. Experimentally, we show that the
generalized sparse conv nets with the hybrid kernel outper-
form sparse convnets with tesseract kernels. Also, the 4D
generalized sparse convnets are more robust to noise and
sometimes more efﬁcient in some cases than the 3D counter-
part.

3At the time of submission, our proposed method was the ﬁrst very deep

3D convolutional neural networks with more than 20 layers.

4We achieved 67.9% mIoU on the ScanNet benchmark outperforming
all algorithms including the best peer-reviewed work [6] by 19% mIoU at
the time of submission.

2. Related Work

The 4D spatio-temporal perception fundamentally re-
quires 3D perception as a slice of 4D along the temporal
dimension is a 3D scan. However, as there are no previ-
ous works on 4D perception using neural networks, we will
primarily cover 3D perception, speciﬁcally 3D segmenta-
tion using neural networks. We categorized all previous
works in 3D as either (a) 3D-convolutional neural networks
or (b) neural networks without 3D convolutions. Finally, we
cover early 4D perception methods. Although 2D videos are
spatio-temporal data, we will not cover them in this paper as
3D perception requires radically different data processing,
implementation, and architectures.

3D-convolutional neural networks. The ﬁrst branch of
3D-convolutional neural networks uses a rectangular grid
and a dense representation [30, 5] where the empty space is
represented either as 0 or the signed distance function. This
straightforward representation is intuitive and is supported
by all major public neural network libraries. However, as
the most space in 3D scans is empty, it suffers from high
memory consumption and slow computation. To resolve this,
OctNet [24] proposed to use the Octree structure to represent
3D space and convolution on it.

The second branch is sparse 3D-convolutional neural net-
works [28, 9]. There are two quantization methods used for
high dimensions: a rectangular grid and a permutohedral
lattice [1]. [28] used a permutohedral lattice whereas [9]
used a rectangular grid for 3D classiﬁcation and semantic
segmentation.

The last branch is 3D pseudo-continuous convolutional
neural networks [11, 15]. Unlike the previous works, they
deﬁne convolutions using continuous kernels in a continuous
space. However, ﬁnding neighbors in a continuous space is
expensive, as it requires KD-tree search rather than a hash
table, and are susceptible to uneven distribution of point
clouds.

Neural networks without 3D convolutions. Recently,
we saw a tremendous increase in neural networks without
3D convolutions for 3D perception. Since 3D scans consist
of thin observable surfaces, [20, 29] proposed to use 2D
convolutions on the surface for semantic segmentation.

Another direction is PointNet-based methods [22, 23].
PointNets use a set of input coordinates as features for a
multi-layer perceptron. However, this approach processes
a limited number of points and thus a sliding window for
cropping out a section from an input was used for large
spaces making the receptive ﬁeld size rather limited. [14]
tried to resolve such shortcomings with a recurrent network
on top of multiple pointnets, and [15] proposed a variant of
3D continuous convolution for lower layers of a PointNet
and got a signiﬁcant performance boost.

4D perception. The ﬁrst 4D perception algorithm [18]
proposed a dynamic deformable balloon model for 4D car-

diac image analysis. Later, [16] used a 4D Markov Ran-
dom Fields for cardiac segmentation. Recently, a "Spatio-
Temporal CNN" [34] combined a 3D-UNet with a 1D-
AutoEncoder for temporal data and applied the model
for auto-encoding brain fMRI images, but it is not a 4D-
convolutional neural network.

In this paper, we propose the ﬁrst high-dimensional con-
volutional neural networks for 4D spatio-temporal data, or
3D videos and the 7D space-time-chroma space. Compared
with other approaches that combine temporal data with a
recurrent neural network or a shallow model (CRF), our net-
works use a homogeneous representation and convolutions
consistently throughout the networks. Instead of using an
RNN, we use convolution for the temporal axis since it is
proven to be more effective in sequence modeling [3].

3. Sparse Tensor and Convolution

In traditional speech, text, or image data, features are
extracted densely. Thus, the most common representations
of these data are vectors, matrices, and tensors. However,
for 3-dimensional scans or even higher-dimensional spaces,
such dense representations are inefﬁcient due to the sparsity.
Instead, we can only save the non-empty part of the space
as its coordinates and the associated features. This repre-
sentation is an N-dimensional extension of a sparse matrix;
thus it is known as a sparse tensor. There are many ways
to save such sparse tensors compactly [31], but we follow
the COO format as it is efﬁcient for neighborhood queries
(Sec. 3.1). Unlike the traditional sparse tensors, we augment
the sparse tensor coordinates with the batch indices to dis-
tinguish points that occupy the same coordinate in different
batches [9]. Concisely, we can represent a set of 4D coor-
}i or as a matrix C and a set
dinates as
C
fi}i or as a matrix F . Then, a
of associated features
{
sparse tensor can be written as

(xi, yi, zi, ti)
{

=

=

F

t1

b1

y1

x1

z1
...
xN yN zN tN bN

f T
1
...
f T
N

, F = 



(1)












C = 




where bi and fi are the batch index and the feature associated
to the i-th coordinate. In Sec. 6, we augment the 4D space
with the 3D chromatic space and create a 7D sparse tensor
for trilateral ﬁltering.

3.1. Generalized Sparse Convolution

In this section, we generalize the sparse convolution [8, 9]
for generic input and output coordinates and for arbitrary ker-
nel shapes. The generalized sparse convolution encompasses
not only all sparse convolutions but also the conventional
be an N in-dimensional
dense convolutions. Let xin
RD (a
input feature vector in a D-dimensional space at u
D-dimensional coordinate), and convolution kernel weights

RN in

u ∈

∈

×

×

∈

N out

RKD

N in
be W
spatial weights with K D matrices of size N out
i
for
}i|
in D-dimension is

. We break down the weights into
N in as Wi
= K D. Then, the conventional dense convolution

×

|{

xout

u =

D(K)

(cid:88)i
∈V

Wixin

u+i for u

D,

Z

∈

(2)

D(K) is the list of offsets in D-dimensional hyper-
where
1, 0, 1
. The
cube centered at the origin. e.g.
}
generalized sparse convolution in Eq. 3 relaxes Eq. 2.

1(3) =

{−

V

V

xout

u =

D(u,
(cid:88)i
∈N

C

in)

Wixin

u+i for u

out

∈ C

(3)

D

C

C

C

N

in.

i
{

∈ C

∈ N

in) =

N
D(u,

where
u + i
and
}
|
offsets from the current center, u, that exist in

D is a set of offsets that deﬁne the shape of a kernel
in, i
as the set of
in and
out are predeﬁned input and output coordinates of sparse
C
tensors. First, note that the input coordinates and output co-
ordinates are not necessarily the same. Second, we deﬁne the
D. This
shape of the convolution kernel arbitrarily with
generalization encompasses many special cases such as the
dilated convolution and typical hypercubic kernels. Another
interesting special case is the "sparse submanifold convolu-
D(K). If we
tion" [9] when we set
C
N
D(K), the generalized
D =
set
sparse convolution becomes the conventional dense convolu-
out as multiples of a
tion (Eq. 2). If we deﬁne the
C
D(K), we have a strided dense
natural number and
convolution.

out = ZD and

in and

in and

out =

D =

D =

in =

N

N

N

V

V

V

C

C

C

C

4. Minkowski Engine

In this section, we propose an open-source auto-
differentiation library for sparse tensors and the generalized
sparse convolution (Sec. 3). As it is an extensive library with
many functions, we will only cover essential forward-pass
functions.

4.1. Sparse Tensor Quantization

The ﬁrst step in the sparse convolutional neural network
is the data processing to generate a sparse tensor, which con-
verts an input into unique coordinates, associated features,
and optionally labels when training for semantic segmen-
tation. In Alg. 1, we list the GPU function for this pro-
cess. When a dense label is given, it is important that we
ignore voxels with more than one unique labels. This can
be done by marking these voxels with IGNORE_LABEL.
First, we convert all coordinates into hash keys and ﬁnd all
unique hashkey-label pairs to remove collisions. Note that
SortByKey, UniqueByKey, and ReduceByKey are all
standard Thrust library functions [19]. The reduction func-
tion f ((lx, ix), (ly, iy)) => (IGNORE_LABEL, ix) takes

larly except that the role of input and output coordinates is
reversed.

RN

Nf ,

×

4.3. Max Pooling

Algorithm 1 GPU Sparse Tensor Quantization

×

D, features Fp ∈

+ , quantization step size vl

RN

∈

Inputs: coordinates Cp ∈
ZN
target labels l
ﬂoor(Cp / vl)
C (cid:48)p ←
hash(C (cid:48)p), i
k
←
((i(cid:48), l(cid:48)), k(cid:48))
(i(cid:48)(cid:48), (k(cid:48)(cid:48), l(cid:48)(cid:48)))
(l(cid:48)(cid:48)(cid:48), i(cid:48)(cid:48)(cid:48))
return C (cid:48)p[i(cid:48)(cid:48)(cid:48), :], Fp[i(cid:48)(cid:48)(cid:48), :], l(cid:48)(cid:48)(cid:48)

←

←

←

sequence(N)
SortByKey((i, l), key=k)

UniqueByKey(i(cid:48), key=(k(cid:48), l(cid:48)))
ReduceByKey((l(cid:48)(cid:48), i(cid:48)(cid:48)), key=k(cid:48)(cid:48), fn=f )

←

label-key pairs and returns the IGNORE_LABEL since at
least two label-key pairs in the same key means there is a
label collision. A CPU-version works similarly except that
all reduction and sorting are processed serially.

4.2. Generalized Sparse Convolution

C

C

out given the input coordinates

The next step in the pipeline is generating the output co-
in (Eq. 3). When
ordinates
used in conventional neural networks, this process requires
only a convolution stride size, input coordinates, and the
stride size of the input sparse tensor (the minimum distance
between coordinates). The algorithm is presented in the
supplementary material. We create this output coordinates
out
dynamically allowing an arbitrary output coordinates
for the generalized sparse convolution.

C

Next, to convolve an input with a kernel, we need a map-
ping to identify which inputs affect which outputs. This
mapping is not required in conventional dense convolutions
as it can be inferred easily. However, for sparse convolu-
tion where coordinates are scattered arbitrarily, we need to
specify the mapping. We call this mapping the kernel maps
and deﬁne them as pairs of lists of input indices and output
D. Finally, given the
}i for i
indices, M =
input and output coordinates, the kernel map, and the kernel
weights Wi, we can compute the generalized sparse convolu-
D (Alg. 2)
tion by iterating through each of the offset i
where I[n] and O[n] indicate the n-th element of the list of

(Ii, Oi)
{

∈ N

∈ N

Algorithm 2 Generalized Sparse Convolution
Require: Kernel weights W, input features F i, output fea-

ture placeholder F o, convolution mapping M,

1: F o
0 // set to 0
←
2: for all Wi, (Ii, Oi)
Wi[F i
Ftmp ←
3:
Ftmp + [F o
Ftmp ←
Oi[2], ..., F o
[F o
5:
6: end for

Oi[1], F o

∈
Ii[1], F i

4:

(W, M) do
Ii[2], ..., F i

Oi[1], F o
Oi[n]]

Oi[2], ..., F o
Ftmp

←

Ii[n]] // (cu)BLAS
Oi[n]]

{

∈ N

Ii}i and
{

Unlike dense tensors, on sparse tensors, the number of
input features varies per output. Thus, this creates non-
trivial implementation for a max/average pooling. Let I
and O be the vector that concatenated all
Oi}i
D respectively. We ﬁrst ﬁnd the number of in-
for i
puts per each output coordinate and indices of the those
inputs. Alg. 3 reduces the input features that map to the
same output coordinate. Sequence(n) generates a se-
quence of integers from 0 to n - 1 and the reduction function
f ((k1, v1), (k2, v2)) = min(v1, v2) which returns the mini-
mum value given two key-value pairs. MaxPoolKernel
is a custom CUDA kernel that reduces all features at a spec-
iﬁed channel using S(cid:48), which contains the ﬁrst index of I
that maps to the same output, and the corresponding output
indices O”.

Algorithm 3 GPU Sparse Tensor MaxPooling
Input: input feature F , output mapping O
(I(cid:48), O(cid:48))
S
←
S(cid:48), O”
return MaxPoolKernel(S(cid:48), I(cid:48), O”, F )

ReduceByKey(S, key=O(cid:48), fn=f )

Sequence(length(O(cid:48)))

SortByKey(I, key=O)

←

←

4.4. Global / Average Pooling, Sum Pooling

An average pooling and a global pooling layer compute
the average of input features for each output coordinate for
average pooling or one output coordinate for global pool-
ing. This can be implemented in multiple ways. We use
a sparse matrix multiplication since it can be optimized on
hardware or using a faster sparse BLAS library.
In par-
ticular, we use the cuSparse library for sparse matrix-
matrix (cusparse_csrmm) and matrix-vector multiplica-
tion (cusparse_csrmv) to implement these layers. Simi-
lar to the max pooling algorithm, M is the (I, O) input-to-
output kernel map. For the global pooling, we create the
kernel map that maps all inputs to the origin and use the
same Alg. 4. The transposed pooling (unpooling) works
similarly.

On the last line of the Alg. 4, we divide the pooled fea-
tures by the number of inputs mapped to each output. How-
ever, this process could remove density information. Thus,
we propose a variation that does not divide the number of
inputs and named it the sum pooling.

indices I and O respectively and F i
n are also n-th
input and output feature vectors respectively. The transposed
generalized sparse convolution (deconvolution) works simi-

n and F o

4.5. Non-spatial Functions

For functions that do not require spatial information (co-
ordinates) such as ReLU, we can apply the functions directly

Algorithm 4 GPU Sparse Tensor AvgPooling

Input: mapping M = (I, O), features F , one vector 1
SM = coo2csr(row=O, col=I, val=1)
F (cid:48) = cusparse_csrmm(SM , F )
N = cusparse_csrmv(SM , 1)
return F (cid:48)/N

to the features F . Also, for batch normalization, as each
row of F represents a feature, we could use the 1D batch
normalization function directly on F .

5. Minkowski Convolutional Neural Networks

In this section, we introduce 4-dimensional spatio-
temporal convolutional neural networks for spatio-temporal
perception. We treat the time dimension as an extra spatial
dimension and create networks with 4-dimensional convo-
lutions. However, there are unique problems arising from
high-dimensional convolutions. First, the computational cost
and the number of parameters in the networks increase ex-
ponentially as we increase the dimension. However, we
experimentally show that these increases do not necessarily
lead to better performance. Second, the networks do not
have an incentive to make the prediction consistent through-
out the space and time with conventional cross-entropy loss
alone.

To resolve the ﬁrst problem, we make use of a special
property of the generalized sparse convolution and propose
non-conventional kernel shapes that not only save memory
and computation, but also perform better. Second, to enforce
spatio-temporal consistency, we propose a high-dimensional
conditional random ﬁeld (7D space-time-color space) that
ﬁlters network predictions. We use variational inference to
train both the base network and the conditional random ﬁeld
end-to-end.

5.1. Tesseract Kernel and Hybrid Kernel

The surface area of 3D data increases linearly to time and
quadratically to the spatial resolution. However, when we
use a conventional 4D hypercube, or a tesseract (Fig. 2), for
a convolution kernel, the exponential increase in the number
of parameters leads to over-parametrization, overﬁtting, as
well as high computational-cost and memory consumption.
Instead, we propose a hybrid kernel (non-hypercubic, non-
permutohedral) to save computation. We use the arbitrary
D of the generalized sparse convolution to
kernel offsets
N
implement the hybrid kernel.

The hybrid kernel is a combination of a cross-shaped ker-
nel a conventional cubic kernel (Fig. 3). For spatial dimen-
sions, we use a cubic kernel to capture the spatial geometry
accurately. For the temporal dimension, we use the cross-
shaped kernel to connect the same point in space across time.

We experimentally show that the hybrid kernel outperforms
the tesseract kernel both in speed and accuracy.

Cross

Hypercross

Cube

Hypercube

Hybrid

Figure 3: Various kernels in space-time. The red arrow
indicates the temporal dimension and the other two axes are
for spatial dimensions. The third spatial dimension is hidden
for better visualization.

5.2. Residual Minkowski Networks

The generalized sparse convolution allows us to deﬁne
strides and kernel shapes arbitrarily. Thus, we can create
a high-dimensional network only with generalized sparse
convolutions, making the implementation easier and generic.
In addition, it allows us to adopt recent architectural in-
novations in 2D directly to high-dimensional networks. To
demonstrate, we create a high-dimensional version of a resid-
ual network on Fig. 4. For the ﬁrst layer, instead of a 7
7
2D convolution, we use a 5
1 generalized sparse con-
5
×
volution. However, for the rest of the networks, we follow
the original network architecture.

×

×

×

5

For the U-shaped variants, we add multiple strided sparse
convolutions and strided sparse transpose convolutions with
skip connections connecting the layers with the same stride
size (Fig. 5) on the base residual network. We use multiple

Figure 4: Architecture of ResNet18 (left) and MinkowskiNet18
(right). Note the structural similarity. × indicates a hypercubic
kernel, + indicates a hypercross kernel. (best viewed on display)

Sparse Conv 3×3×3+3, 256Sparse Conv 3×3×3+3, 64Sparse Conv 3×3×3+3, 64Sparse Conv 3×3×3+3, 64Sparse Conv 3×3×3+3, 64Sparse Conv 3×3×3+3, 128Sparse Conv 3×3×3+3, 128Sparse Conv 3×3×3+3, 128Sparse Conv 3×3×3+3, 128Sparse Conv 5×5×5×1, 64poolSparse Conv 3×3×3+3, 256Sparse Conv 3×3×3+3, 256Sparse Conv 3×3×3+3, 256Sparse Conv 3×3×3+3, 512Sparse Conv 3×3×3+3, 512Sparse Conv 3×3×3+3, 512Sparse Conv 3×3×3+3, 512LinearConv 3×3, 256Conv 3×3, 64Conv 3×3, 64Conv 3×3, 64Conv 3×3, 64Conv 3×3, 128Conv 3×3, 128Conv 3×3, 128Conv 3×3, 128Conv 7×7, 64poolConv 3×3, 256Conv 3×3, 256Conv 3×3, 256Conv 3×3, 512Conv 3×3, 512Conv 3×3, 512Conv 3×3, 512LinearFigure 5: Architecture of MinkowskiUNet32. × indicates a hypercubic kernel, + indicates a hypercross kernel. (best viewed on display)

variations of the same architecture for semantic segmentation
experiments.

6. Trilateral Stationary-CRF

For semantic segmentation, the cross-entropy loss is ap-
plied for each pixel or voxel. However, the loss does not
enforce consistency as it does not have pair-wise terms. To
make such consistency more explicit, we propose a high-
dimensional conditional random ﬁeld (CRF) similar to the
one used in image semantic segmentation [35]. In image
segmentation, the bilateral space that consists of 2D space
and 3D color is used for the CRF. For 3D-videos, we use
the trilateral space that consists of 3D space, 1D time, and
3D chromatic space. The color space creates a "spatial"
gap between points with different colors that are spatially
adjacent (e.g., on a boundary). Thus, it prevents informa-
tion from "leaking out" to different regions. Unlike con-
ventional CRFs with Gaussian edge potentials and dense
connections [13, 35], we do not restrict the compatibility
function to be a Gaussian. Instead, we relax the constraint
and only apply the stationarity condition.

To ﬁnd the global optima of the distribution, we use the
variational inference and convert a series of ﬁxed point up-
date equations to a recurrent neural network similar to [35].
We use the generalized sparse convolution in 7D space to
implement the recurrence and jointly train both the base
network that generates unary potentials and the CRF end-to-
end.

6.1. Deﬁnition

Let a CRF node in the 7D (space-time-chroma) space
be xi and the unary potential be φu(xi) and the pairwise
7(xi).
potential as φp(xi, xj) where xj is a neighbor of xi,
The conditional random ﬁeld is deﬁned as

N

P (X) =

1
Z

exp

i
(cid:88)



φu(xi) +



φp(xi, xj)



7(xi)

(cid:88)j
∈N



where Z is the partition function; X is the set of all nodes;
and φp must satisfy the stationarity condition φp(u, v) =
RD. Note that we use the
φp(u + τu, v + τv) for τu, τv ∈
camera extrinsics to deﬁne the spatial coordinates of a node
xi in the world coordinate system. This allows stationary
points to have the same coordinates throughout the time.

6.2. Variational Inference

The optimization arg maxX P (X) is intractable. Instead,
we use the variational inference to minimize divergence
between the optimal P (X) and an approximated distribution
Q(X). Speciﬁcally, we use the mean-ﬁeld approximation,
Q =
i Qi(xi) as the closed form solution exists. From the
Theorem 11.9 in [12], Q is a local maximum if and only if

(cid:81)

Qi(xi) =

1
Zi

exp

X

E
i∼

−

Q

−

φu(xi) +

i 

φp(xi, xj)



.

7(xi)

(cid:88)j
∈N

−

i and Q


X
i indicate all nodes or variables except for the i-
th one. The ﬁnal ﬁxed-point equation is Eq. 4. The derivation
is in the supplementary material.



−

Q+

i (xi) =

1
Zi

exp




φu(xi) +

(cid:88)j
∈N

xj
7(xi) (cid:88)

φp(xi, xj)Qj(xj)




(4)

6.3. Learning with 7D Sparse Convolution





Interestingly, the weighted sum φp(xi, xj)Qj(xj) in
Eq. 4 is equivalent to a generalized sparse convolution in
the 7D space since φp is stationary and each edge between
7. Thus, we convert ﬁxed
xi, xj can be encoded using
point update equation Eq. 4 into an algorithm in Alg. 5.

N

Algorithm 5 Variational Inference of TS-CRF
Require: Input: Logit scores φu for all xi; associated coor-

dinate Ci, color Fi, time Ti
Q0(X) = exp φu(X), Ccrf = [C, F, T ]
for n from 1 to N do

˜Qn = SparseConvolution((Ccrf, Qn
Qn = Softmax(φu + ˜Qn)

end for
return QN

1), kernel=φp)

−

Finally, we use φu as the logit predictions of a 4D
Minkowski network and train both φu and φp end-to-end
using one 4D and one 7D Minkowski network using Eq. 5.

∂L
∂φp

=

N

n
(cid:88)

∂L
∂Qn+

∂Qn+
∂φp

,

∂L
∂φu

=

N

n
(cid:88)

∂L
∂Qn+

∂Qn+
∂φu

(5)

Sparse Conv 3×3×3+3, 256Sparse Conv 3×3×3+3, 64Sparse Conv 3×3×3+3, 64Sparse Conv 3×3×3+3, 64Sparse Conv 3×3×3+3, 64Sparse Conv 3×3×3+3, 128Sparse Conv 3×3×3+3, 128Sparse Conv 3×3×3+3, 128Sparse Conv 3×3×3+3, 128Sparse Conv 5×5×5×1, 64poolSparse Conv 3×3×3+3, 256Sparse Conv 3×3×3+3, 256Sparse Conv 3×3×3+3, 256Sparse Conv 3×3×3+3, 512Sparse Conv 3×3×3+3, 512Sparse Conv 3×3×3+3, 512Sparse Conv 3×3×3+3, 512Sparse Conv 1×1×1×1, LABELS Sparse Conv 2×2×2×1, /2 Sparse Conv 2×2×2×1, /2 Sparse Conv 2×2×2×1, /2 Sparse Conv Tr 2×2×2×1, ×2Sparse Conv 3×3×3+3, 512Sparse Conv 3×3×3+3, 512Sparse Conv 3×3×3+3, 512Sparse Conv 3×3×3+3, 512Sparse Conv Tr 2×2×2×1, ×2Sparse Conv Tr 2×2×2×1, ×2Sparse Conv 3×3×3+3, 512Sparse Conv 3×3×3+3, 512Sparse Conv 3×3×3+3, 512Sparse Conv 3×3×3+3, 5127. Experiments

Table 1: 3D Semantic Label Benchmark on ScanNet† [5]

To validate the proposed high-dimensional networks, we
ﬁrst use multiple standard 3D benchmarks for 3D semantic
segmentation. It allows us to gauge the performance of the
high-dimensional networks with the same architecture with
other state-of-the-art methods. Next, we create multiple 4D
datasets from 3D datasets that have temporal sequences and
analyze each of the proposed components for ablation study.

7.1. Implementation

We implemented the Minkowski Engine (Sec. 4) using
C++/CUDA and wrap it with PyTorch [21]. Data is prepared
in parallel data processes that load point clouds, apply data
augmentation, and quantize them with Alg. 1 on the ﬂy. For
non-spatial functions, we use the PyTorch functions directly.

7.2. Training and Evaluation

We use Momentum SGD with the Poly scheduler to train
networks from learning rate 1e-1 and apply data augmenta-
tion including random scaling, rotation around the gravity
axis, spatial translation, spatial elastic distortion, and chro-
matic translation and jitter.

For evaluation, we use the standard mean Intersection
over Union (mIoU) and mean Accuracy (mAcc) for metrics
following the previous works. To convert voxel-level pre-
dictions to point-level predictions, we simply propagated
predictions from the nearest voxel center.

7.3. Datasets

ScanNet. The ScanNet [5] 3D segmentation benchmark
consists of 3D reconstructions of real rooms. It contains
1.5k rooms, some repeated rooms captured with different
sensors. We feed an entire room to a MinkowskiNet fully
convolutionally without cropping.

Stanford 3D Indoor Spaces (S3DIS). The dataset [2]
contains 3D scans of six ﬂoors of three different buildings.
We use the Fold #1 split following many previous works. We
use 5cm and 2cm voxel for the experiment.

RueMonge 2014 (Varcity).

The RueMonge 2014
dataset [25] provides semantic labels for a multi-view 3D re-
construction of the Rue Mongue. To create a 4D dataset, we
crop the 3D reconstruction on-the-ﬂy to generate a temporal
sequence. We use the ofﬁcial split for all experiments.

Synthia 4D. We use the Synthia dataset [27] to create 3D
video sequences. We use 6 sequences of driving scenarios
in 9 different weather conditions. Each sequence consists
of 4 stereo RGB-D images taken from the top of a car. We
back-project the depth images to the 3D space to create 3D
videos. We visualized a part of a sequence in Fig. 1.

We use the sequence 1-4 except for sunset, spring, and
fog for the train split; the sequence 5 foggy weather for
validation; and the sequence 6 sunset and spring for the test.

Method mIOU

ScanNet [5] 30.6
SSC-UNet [10] 30.8
PointNet++ [23] 33.9
ScanNet-FTSDF 38.3
SPLATNet [28] 39.3
TangetConv [29] 43.8
SurfaceConv [20] 44.2
3DMV‡ [6] 48.4
3DMV-FTSDF‡ 50.1
PointNet++SW 52.3

MinkowskiNet42 (5cm) 67.9

SparseConvNet [10]† 72.5
MinkowskiNet42 (2cm)† 73.4

†: post-CVPR submissions. ‡: uses 2D images additionally. Per
class IoU in the supplementary material. The parenthesis next to
our methods indicate the voxel size.

In total, the train/val/test set contain 20k/815/1886 3D scenes
respectively.

Since the dataset is purely synthetic, we added various
noise to the input point clouds to simulate noisy observations.
We used elastic distortion, Gaussian noise, and chromatic
shift in the color for the noisy 4D Synthia experiments.

7.4. Results and Analysis

Table 2: Segmentation results on the 4D Synthia dataset

Method

3D MinkNet20
3D MinkNet20 + TA

mIOU mAcc

76.24 89.31
77.03 89.20

75.34 89.27
4D Tesseract MinkNet20
4D MinkNet20
77.46 88.013
4D MinkNet20 + TS-CRF 78.30 90.23
4D MinkNet32 + TS-CRF 78.67 90.51

TA denotes temporal averaging. Per class IoU in the supplementary
material.

ScanNet & Stanford 3D Indoor The ScanNet and the
Stanford Indoor datasets are one of the largest non-synthetic
datasets, which make the datasets ideal test beds for 3D
segmentation. We were able to achieve +19% mIOU on
ScanNet, and +7% on Stanford compared with the best-
published works by the CVPR deadline. This is due to the
depth of the networks and the ﬁne resolution of the space. We
trained the same network for 60k iterations with 2cm voxel
and achieved 72.1% mIoU on ScanNet after the deadline.
For all evaluation, we feed an entire room to a network and
process it fully convolutionally.

Table 3: Segmentation results on the noisy Synthia 4D dataset

IoU

Building

Road

Sidewalk

Fence

Vegetation

Pole

Car

Trafﬁc Sign

Pedestrian

Lanemarking

Trafﬁc Light

mIoU

3D MinkNet42
3D MinkNet42 + TA

4D Tesseract MinkNet42
4D MinkNet42

87.954
87.796

89.957
88.890

97.511
97.068

96.917
97.720

78.346
78.500

81.755
85.206

84.307
83.938

82.841
84.855

96.225
96.290

96.556
97.325

94.785
94.764

96.042
96.147

87.370
85.248

91.196
92.209

42.705
43.723

52.149
61.794

66.666
62.048

51.824
61.647

52.665
50.319

70.388
55.673

55.353
54.825

57.960
56.735

76.717
75.865

78.871
79.836

TA denotes temporal averaging. As the input pointcloud coordinates are noisy, averaging along the temporal dimension introduces noise.

Table 4: Stanford Area 5 Test (Fold #1) (S3DIS) [2]

Method mIOU mAcc

Figure 6: Visualizations of 3D (top), and 4D networks (bottom) on
Synthia. A road (blue) far away from the car is often confused as
sidewalks (green) with a 3D network, which persists after temporal
averaging. However, 4D networks accurately captured it.

PointNet [22] 41.09 48.98
SparseUNet [9] 41.72 64.62
SegCloud [30] 48.92 57.35
60.7
71.3
PointCNN [15] 57.26 63.86
66.5

TangentConv [29]
3D RNN [32]

52.8
53.4

SuperpointGraph [14] 58.04

MinkowskiNet20 62.60 69.62
MinkowskiNet32 65.35 71.71

Per class IoU in the supplementary material.

Figure 7: Visualization of Scannet predictions. From the top, a
3D input pointcloud, a network prediction, and the ground-truth.

4D analysis The RueMongue dataset is a small dataset
that ranges one section of a street, so with the smallest net-
work, we were able to achieve the best result (Tab. 5). How-
ever, the results quickly saturate. On the other hand, the
Synthia 4D dataset has an order of magnitude more 3D scans
than any other datasets, so it is more suitable for the ablation
study.

We use the Synthia datasets with and without noise for
3D and 4D analysis and results are presented in Tab. 2 and

Figure 8: Visualization of Stanford dataset Area 5 test results.
From the top, RGB input, prediction, ground truth.

Tab. 3. We use various 3D and 4D networks with and without
TS-CRF. Speciﬁcally, when we simulate noise in sensory
inputs on the 4D Synthia dataset, we can observe that the
4D networks are more robust to noise. Note that the number
of parameters added to the 4D network compared with the
3D network is less than 6.4 % and 6e-3 % for the TS-CRF.
Thus, with a small increase in computation, we could get

Table 5: RueMonge 2014 dataset (Varcity) TASK3 [25]

References

Method

MV-CRF [26]
Gradde et al. [7]
RF+3D CRF [17]
OctNet (2563) [24]
SPLATNet (3D) [28]

mIOU

42.3
54.4
56.4
59.2
65.4

3D MinkNet20
66.46
66.56
4D MinkNet20
4D MinkNet20 + TS-CRF 66.59

The performance saturates quickly due to the small training set. Per
class IoU in the supplementary material.

a more robust algorithm with higher accuracy. In addition,
when we process temporal sequence using the 4D networks,
we could even get small speed gain as we process data in
a batch mode. On Tab. 6, we vary the voxel size and the
sequence length and measured the runtime of the 3D and 4D
networks, as well as the 4D networks with TS-CRF. Note
that for large voxel sizes, we tend to get small speed gain on
the 4D networks compared with 3D networks.

Table 6: Time (s) to process 3D videos with 3D and 4D MinkNet,
the volume of a scan at each time step is 50m× 50m × 50m

Voxel Size

0.6m

0.45m

0.3m

Video Length (s) 3D 4D 4D-CRF 3D 4D 4D-CRF 3D 4D 4D-CRF

3
5
7

0.18 0.14
0.31 0.23
0.43 0.31

0.17
0.27
0.38

0.25 0.22
0.41 0.39
0.58 0.61

0.27
0.47
0.74

0.43 0.49
0.71 0.94
0.99 1.59

0.59
1.13
2.02

8. Conclusion

In this paper, we propose a generalized sparse convolu-
tion and an auto-differentiation library for sparse tensors
and the generalized sparse convolution. Using these, we
create 4D convolutional neural networks for spatio-temporal
perception. Experimentally, we show that 3D convolutional
neural networks alone can outperform 2D networks and 4D
perception can be more robust to noise.

9. Acknowledgements

Toyota Research Institute ("TRI") provided funds to assist
the authors with their research but this article solely reﬂects
the opinions and conclusions of its authors and not TRI
or any other Toyota entity. We acknowledge the support
of the System X Fellowship and the companies sponsored:
NEC Corporation, Nvidia, Samsung, and Tencent. Also, we
want to acknowledge the academic hardware donation from
Nvidia.

[1] Andrew Adams, Jongmin Baek, and Myers Abraham Davis.
Fast high-dimensional ﬁltering using the permutohedral lat-
tice. In Computer Graphics Forum, volume 29, pages 753–
762. Wiley Online Library, 2010. 2

[2] Iro Armeni, Ozan Sener, Amir R. Zamir, Helen Jiang, Ioannis
Brilakis, Martin Fischer, and Silvio Savarese. 3d semantic
parsing of large-scale indoor spaces. In Proceedings of the
IEEE International Conference on Computer Vision and Pat-
tern Recognition, 2016. 2, 7, 8

[3] Shaojie Bai, J Zico Kolter, and Vladlen Koltun. An empirical
evaluation of generic convolutional and recurrent networks
for sequence modeling. arXiv preprint arXiv:1803.01271,
2018. 3

[4] Christopher B Choy, Danfei Xu, JunYoung Gwak, Kevin
Chen, and Silvio Savarese. 3d-r2n2: A uniﬁed approach for
single and multi-view 3d object reconstruction. In Proceed-
ings of the European Conference on Computer Vision (ECCV),
2016. 2

[5] Angela Dai, Angel X. Chang, Manolis Savva, Maciej Halber,
Thomas Funkhouser, and Matthias Nießner. Scannet: Richly-
annotated 3d reconstructions of indoor scenes. In Proc. Com-
puter Vision and Pattern Recognition (CVPR), IEEE, 2017. 1,
2, 7

[6] Angela Dai and Matthias Nießner. 3dmv: Joint 3d-multi-view
prediction for 3d semantic scene segmentation. In Proceed-
ings of the European Conference on Computer Vision (ECCV),
2018. 2, 7

[7] Raghudeep Gadde, Varun Jampani, Renaud Marlet, and Peter
Gehler. Efﬁcient 2d and 3d facade segmentation using auto-
context. IEEE transactions on pattern analysis and machine
intelligence, 2017. 9

[8] Benjamin Graham. Spatially-sparse convolutional neural
networks. arXiv preprint arXiv:1409.6070, 2014. 1, 3
[9] Ben Graham. Sparse 3d convolutional neural networks.

British Machine Vision Conference, 2015. 1, 2, 3, 8

[10] Benjamin Graham, Martin Engelcke, and Laurens van der
Maaten. 3D semantic segmentation with submanifold sparse
convolutional networks. CVPR, 2018. 7

[11] P. Hermosilla, T. Ritschel, P-P Vazquez, A. Vinacua, and
T. Ropinski. Monte carlo convolution for learning on non-
uniformly sampled point clouds. ACM Transactions on
Graphics (Proceedings of SIGGRAPH Asia 2018), 2018. 1, 2
[12] Daphne Koller and Nir Friedman. Probabilistic Graphical
Models: Principles and Techniques - Adaptive Computation
and Machine Learning. The MIT Press, 2009. 6

[13] Philipp Krähenbühl and Vladlen Koltun. Efﬁcient inference
In
in fully connected crfs with gaussian edge potentials.
Advances in Neural Information Processing Systems 24, 2011.
6

[14] Loic Landrieu and Martin Simonovsky. Large-scale point
cloud semantic segmentation with superpoint graphs. arXiv
preprint arXiv:1711.09869, 2017. 2, 8

[15] Yangyan Li, Rui Bu, Mingchao Sun, and Baoquan Chen.
Pointcnn. arXiv preprint arXiv:1801.07791, 2018. 1, 2, 8

of 3d point clouds. International Conference on 3D Vision
(3DV), 2017. 2, 8

[31] Parker Allen Tew. An investigation of sparse tensor formats
for tensor libraries. PhD thesis, Massachusetts Institute of
Technology, 2016. 3

[32] Xiaoqing Ye, Jiamao Li, Hexiao Huang, Liang Du, and Xi-
aolin Zhang. 3d recurrent neural networks with context fusion
for point cloud semantic segmentation. In The European Con-
ference on Computer Vision (ECCV), September 2018. 8
[33] A. Zeng, S. Song, M. Nießner, M. Fisher, J. Xiao, and T.
Funkhouser. 3dmatch: Learning the matching of local 3d
geometry in range scans. In CVPR, 2017. 2

[34] Yu Zhao, Xiang Li, Wei Zhang, Shijie Zhao, Milad Makkie,
Mo Zhang, Quanzheng Li, and Tianming Liu. Modeling 4d
fmri data via spatio-temporal convolutional neural networks
(st-cnn). arXiv preprint arXiv:1805.12564, 2018. 3

[35] Shuai Zheng, Sadeep Jayasumana, Bernardino Romera-
Paredes, Vibhav Vineet, Zhizhong Su, Dalong Du, Chang
Huang, and Philip H. S. Torr. Conditional random ﬁelds as
recurrent neural networks. In Proceedings of the 2015 IEEE
International Conference on Computer Vision (ICCV), 2015.
6

[16] Maria Lorenzo-Valdés, Gerardo I Sanchez-Ortiz, Andrew G
Elkington, Raad H Mohiaddin, and Daniel Rueckert. Segmen-
tation of 4d cardiac mr images using a probabilistic atlas and
the em algorithm. Medical Image Analysis, 8(3):255–265,
2004. 3

[17] Andelo Martinovic, Jan Knopp, Hayko Riemenschneider, and
Luc Van Gool. 3d all the way: Semantic segmentation of
urban scenes from start to end in 3d. In Proceedings of the
IEEE Conference on Computer Vision and Pattern Recogni-
tion, 2015. 9

[18] Tim McInerney and Demetri Terzopoulos. A dynamic ﬁ-
nite element surface model for segmentation and tracking
in multidimensional medical images with application to car-
diac 4d image analysis. Computerized Medical Imaging and
Graphics, 19(1):69–83, 1995. 2

[19] Nvidia. Thrust: Parallel algorithm library. 3
[20] Hao Pan, Shilin Liu, Yang Liu, and Xin Tong. Convolutional
neural networks on 3d surfaces using parallel frames. arXiv
preprint arXiv:1808.04952, 2018. 1, 2, 7

[21] Adam Paszke, Sam Gross, Soumith Chintala, Gregory
Chanan, Edward Yang, Zachary DeVito, Zeming Lin, Al-
ban Desmaison, Luca Antiga, and Adam Lerer. Automatic
differentiation in pytorch. 2017. 7

[22] Charles Ruizhongtai Qi, Hao Su, Kaichun Mo, and Leonidas J.
Guibas. Pointnet: Deep learning on point sets for 3d classiﬁ-
cation and segmentation. arXiv preprint arXiv:1612.00593,
2016. 1, 2, 8

[23] Charles Ruizhongtai Qi, Li Yi, Hao Su, and Leonidas J
Guibas. Pointnet++: Deep hierarchical feature learning on
point sets in a metric space. In Advances in Neural Informa-
tion Processing Systems, 2017. 1, 2, 7

[24] Gernot Riegler, Ali Osman Ulusoy, and Andreas Geiger. Oct-
net: Learning deep 3d representations at high resolutions. In
Proceedings of the IEEE Conference on Computer Vision and
Pattern Recognition, 2017. 1, 2, 9

[25] Hayko Riemenschneider, András Bódis-Szomorú, Julien
Weissenberg, and Luc Van Gool. Learning where to classify in
multi-view semantic segmentation. In European Conference
on Computer Vision. Springer, 2014. 2, 7, 9

[26] Hayko Riemenschneider, András Bódis-Szomorú, Julien
Weissenberg, and Luc Van Gool. Learning where to classify in
multi-view semantic segmentation. In European Conference
on Computer Vision, 2014. 9

[27] German Ros, Laura Sellart, Joanna Materzynska, David
Vazquez, and Antonio M. Lopez. The synthia dataset: A
large collection of synthetic images for semantic segmenta-
tion of urban scenes. In The IEEE Conference on Computer
Vision and Pattern Recognition (CVPR), 2016. 2, 7

[28] Hang Su, Varun Jampani, Deqing Sun, Subhransu Maji, Van-
gelis Kalogerakis, Ming-Hsuan Yang, and Jan Kautz. Splat-
net: Sparse lattice networks for point cloud processing. arXiv
preprint arXiv:1802.08275, 2018. 2, 7, 9

[29] Maxim Tatarchenko*, Jaesik Park*, Vladlen Koltun, and
Qian-Yi Zhou. Tangent convolutions for dense prediction
in 3D. CVPR, 2018. 1, 2, 7, 8

[30] Lyne P Tchapmi, Christopher B Choy, Iro Armeni, JunYoung
Gwak, and Silvio Savarese. Segcloud: Semantic segmentation

Thesupplementarymaterialfor4DSpatio-TemporalConvNets:MinkowskiConvolutionalNeuralNetworks1.MinkowskiEngineInthissection,weprovidedetailedbreakdownsoffewalgorithmsinthemainpaperaswellasthecoordinateinitializationandthehashfunction.Pleasenotethattheactualimplementationmaynotfaithfullyreﬂectthealgorithmspresentedhereforoptimization.1.1.SparseQuantizationFirst,weprovideline-by-linecommentsforthesparsequantizationalgorithm.Overall,thealgorithmﬁndsuniquevoxelsandcreateslabelsassociatedwiththem.Iftherearedifferentlabelswithinthesamevoxel,weassigntheIGNORE_LABEL.Thisallowsthenetworktoignorethecross-entropylossforthosevoxelsduringtraining.TheAlg.1startsbyconvertingallcoordinatestohashkeysandgeneratingasequencei,whichisusedtoidentifytheoriginalindices.Next,wesortthesequence,labelpairsbythehashkey(L5).ThiswillplaceindicesandlabelsthatfallintothesamecelltobeadjacentintheGPUmemory.Next,wereducetheindexsequencewiththekey-labelpair(L6).Thisstepwillcollapseallpointswiththesamelabels.However,iftherearedifferentlabelswithinthesamecell,wewillhaveatleasttwokey-labelpairsinthesamecell.Thus,inL7,weusethereductionfunctionf((lx,ix),(ly,iy))=>(IGNORE_LABEL,ix)willsimplyassignIGNORE_LABELtothecell.Finally,weusethereduceduniqueindicesi000toreturnuniquecoordinates,features,andtransformedlabels.Algorithm1GPUSparseTensorQuantization1:Inputs:coordinatesCp∈RN×D,featuresFp∈RN×Nf,targetlabelsl∈ZN+,quantizationstepsizevl2:C0p←ﬂoor(Cp/vl)3:k←hash(C0p)4:i←sequence(N)5:((i0,l0),k0)←SortByKey((i,l),key=k)6:(i00,(k00,l00))←UniqueByKey(i0,key=(k0,l0))7:(l000,i000)←ReduceByKey((l00,i00),key=k00,fn=f)8:returnC0p[i000,:],Fp[i000,:],l0001.2.CoordinateHashingWeusedavariationofFowler–Noll–Vohashfunction,FNV64-1A,andmodiﬁeditforcoordinatesinint32.WelistthealgorithminAlg.2.1.3.CreatingoutputcoordinatesTheﬁrststepinthegeneralizedsparseconvolutionisdeﬁningtheoutputcoordinatesCout.Inmostcases,weusethesamecoordinatesfortheoutputcoordinates.However,whenweuseastridedconvolutionorastridedpooling,weusetheAlg.3tocreatenewoutputcoordinates.Fortransposedstridedconvolutions,weusethesamecoordinateswiththesameinput-stridetopreservetheorderofthecoordinates.1Algorithm2CoordinateHashingRequire:Inputs:coordinatec∈ZDinint321:functionHASH(c)2:h=UINT64(14695981039346656037)3:forallci∈cdo4:h=h⊕UINT32(ci)5:h=h×UINT64(1099511628211)6:endfor7:returnh8:endfunctionAlgorithm3CreateoutputcoordinatesRequire:inputstridesi,layerstridesl,inputcoordinatesC1:functionCREATEOUTPUTCOORDINATES(C,si,sl)2:ifsl>1then3:s←sl×si4:C0←{}//Createanemptyset5:forallci∈Cdo6:c←bci/sc×s7:ifcisnotinC0then8:AppendctoC09:endif10:endfor11:returnC012:else13:returnC14:endif15:endfunction2.DerivationoftheTrilateralStationary-ConditionalRandomFieldFixedPointUpdateEquationTheTS-CRFoptimizationargmaxXP(X)isintractable.Instead,weusethevariationalinferencetominimizedivergencebetweentheoptimalP(X)andanapproximateddistributionQ(X).Commonly,thedivergenceismeasuredusingtheI-projection:D(QkP),thenumberofbitslostwhencodingadistributionQusingP.Tosimplifytheapproximateddistribution,weusethemean-ﬁeldapproximation,Q=QiQi(xi)astheclosedformsolutionexists.FromtheTheorem11.9in[4],QisalocalmaximumifandonlyifQi(xi)=1ZiexpEX−i∼Q−iφu(xi)+Xj∈N(xi)φp(xi,xj)(1).whereX−iandQ−iindicateallvariablesexceptforthei-thvariable.Qi(xi)=1ZiexpEX−i∼Q−iφu(xi)+Xj∈N(xi)φp(xi,xj)(2)=1ZiexpEX−i∼Q−iφu(xi)+EX−i∼Q−iXj∈N(xi)φp(xi,xj)(3)=1Ziexpφu(xi)+Xj∈N(xi)Ej∈N(xi)φp(xi,xj)(4)=1Ziexpφu(xi)+Xj∈N(xi)Xxjφp(xi,xj)Qj(xj)(5)Thus,theﬁnalﬁxed-pointupdateequationisQ+i(xi)=1Ziexpφu(xi)+Xj∈N(xi)Xxjφp(xi,xj)Qj(xj)(6).3.ExperimentsandAnalysisWepresentper-classIoUnumbersforallexperimentsandmorequalitativeresults.WealsovisualizetheentireRueMongue2014(Varcity)datasetonFig.1.ThedatasetisquitesmallfordeeplearningsotheMinkowskiNetworksresultsareallsaturatedaround66%mIoU.Figure1:VisualizationoftheRueMonge2014datasetground-truth.Thelefthalfofthepointcloudisthetrainingsetandtherighthalfisthetestset(Black:IGNORE_LABEL).Table1:ScanNet[1]3DSegmentationBenchmarkResultsMethodbathbedbksfcabchaircntrcurtdeskdoorﬂoorothrpicrefshowsinksofatabtoilwallwindmIoUScanNet[1]20.336.650.131.152.421.10.234.218.978.614.510.224.515.231.834.830.046.043.718.230.6SSC-UNet[3]35.329.027.816.655.316.928.614.714.890.818.26.42.31.835.436.334.554.668.527.830.8PointNet++[9]58.447.845.825.636.025.024.727.826.167.718.311.721.214.536.434.623.254.852.325.233.9ScanNet+SDF29.749.143.235.861.227.411.641.126.590.422.97.925.018.532.051.038.554.859.739.438.3SPLATNet[11]47.251.160.631.165.624.540.532.819.792.722.70.00.124.927.151.038.359.369.926.739.3TangetConv[12]43.764.647.436.964.535.325.828.227.991.829.814.728.329.448.756.242.761.963.335.243.8SurfaceConv[7]50.562.238.034.265.422.739.736.727.692.424.019.835.926.236.658.143.564.066.839.844.23DMV[2]48.453.864.342.460.631.057.443.337.879.630.121.453.720.847.250.741.369.360.253.948.43DMV-FTSDF55.860.842.447.869.024.658.646.845.091.139.416.043.821.243.254.147.574.272.747.750.1MinkowskiNet42(5cm)81.173.473.964.180.441.375.969.654.593.851.814.162.375.768.072.368.489.682.165.167.9MinkowskiNet42(2cm)83.780.480.072.184.346.083.564.759.795.354.221.474.691.270.577.164.087.684.267.272.1Testlabelsnotavailablepublicly.Allnumbersfromhttp://kaldir.vc.in.tum.de/scannet_benchmark/.Entrieswithoutcitationarefromunpublishedworks.‡:uses2Dimagesadditionally.Table2:ResultsontheStanford3DIndoorSpacesDatasetArea5Test(Fold#1)(S3DIS)MethodceilingﬂoorwallbeamclmnwindwdoorchairtablebkcasesofaboardcluttermIOUmAccPointNet[8]88.8097.3369.800.053.9246.2610.7652.6158.9340.285.8526.3833.2241.0948.98SegCloud[13]90.0696.0569.860.0018.3738.3523.1275.8970.4058.4240.8812.9641.6048.9257.35TangentConv*[12]90.4797.6673.990.020.6638.9831.3477.4969.4357.2738.5448.7839.7952.860.73DRNN[15]95.298.677.40.89.8352.727.976.878.358.627.439.151.053.471.3PointCNN[6]92.3198.2479.410.0017.6022.7762.0980.5974.3966.6731.6762.0556.7457.2663.86SuperpointGraph[5]89.3596.8778.120.042.8148.9361.5884.6675.4169.8452.602.152.2258.0466.5PCCN[14]90.2696.2075.890.275.9869.4963.4566.8765.6347.2868.9159.1046.2258.2767.01MinkowskiNet2091.5598.4984.990.826.4746.1855.8288.9980.5271.7448.2962.9857.7262.6069.62MinkowskiNet3291.7598.7186.190.034.0648.9062.4489.8281.5774.8847.2174.4458.5765.3571.71*DatafromtheauthorsTable3:Semanticsegmentationresultsonthe4DSynthiadatasetMethodBldnRoadSdwlkFenceVegittnPoleCarT.SignPedstrnBicyclLaneT.LightmIOUmAccMinkNet2089.39497.68469.42586.51998.10697.25693.49779.45092.2740.00044.60966.69176.2489.31MinkNet20+TA88.09697.79078.32987.08896.54097.48694.20378.83192.4890.00046.40767.07177.0389.1984DMinkNet2090.12598.26273.46787.18799.09997.50294.01079.04192.6220.00050.00668.13877.4688.0134DTesseractMinkNet2089.34697.29160.71286.45198.00096.63293.19174.90691.0300.00047.11369.34375.33589.2724DMinkNet20+TS-CRF89.43898.29179.93886.25498.70797.14295.04581.59291.5400.00054.59667.06778.3090.234DMinkNet32+TS-CRF89.69498.63286.89387.80198.77697.28494.03980.29292.3000.00049.29969.06078.6790.51Table4:SemanticsegmentationresultsontheRueMongue[10](Varcity)datasetMethodwindowwallbalconydoorroofskyshopmIOU3DMinkNet2061.97880.81364.30347.25661.48676.90172.49866.4624DMinkNet2061.93881.59165.39435.08968.55480.54672.84666.5654DMinkNet20+TS-CRF62.60081.82163.59940.79566.22980.46470.63966.592InputRGBpointcloudPredictionresultGround-truthlabelFigure2:Visualizationofthe4DSynthiapredictionsandgroundtruthlabels.InputRGBpointcloudPredictionresultGround-truthlabelFigure3:VisualizationoftheRueMonge2014datasetTASK3results. F O X W W H U E H D P E R D U G E R R N F D V H F H L O L Q J F K D L U F R O X P Q G R R U I O R R U V R I D W D E O H Z D O O Z L Q G R Z 3 U H G L F W H G  O D E H O F O X W W H U E H D P E R D U G E R R N F D V H F H L O L Q J F K D L U F R O X P Q G R R U I O R R U V R I D W D E O H Z D O O Z L Q G R Z * U X Q G  W U X W K  O D E H O                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Figure4:TheconfusionmatrixoftheMinkowskiNet32predictionsontheStanforddatasetArea5(Fold#1).InputRGBpointcloudPredictionresultGround-truthlabelFigure5:VisualizationoftheStanforddatasetArea5testresult.inputrgb3D3DGTdiff4D4DGTdiffgroundtruthFigure6:Visualizationofthenoisy4DSynthiadatasetandpredictions.InputRGBpointcloudPredictionresultGround-truthlabelFigure7:VisualizationofMinkNetpredictionsontheScannetvalidationset.References[1]AngelaDai,AngelX.Chang,ManolisSavva,MaciejHalber,ThomasFunkhouser,andMatthiasNießner.Scannet:Richly-annotated3dreconstructionsofindoorscenes.InProc.ComputerVisionandPatternRecognition(CVPR),IEEE,2017.3[2]AngelaDaiandMatthiasNießner.3dmv:Joint3d-multi-viewpredictionfor3dsemanticscenesegmentation.InProceedingsoftheEuropeanConferenceonComputerVision(ECCV),2018.3[3]BenGraham.Sparse3dconvolutionalneuralnetworks.BritishMachineVisionConference,2015.3[4]DaphneKollerandNirFriedman.ProbabilisticGraphicalModels:PrinciplesandTechniques-AdaptiveComputationandMachineLearning.TheMITPress,2009.2[5]LoicLandrieuandMartinSimonovsky.Large-scalepointcloudsemanticsegmentationwithsuperpointgraphs.arXivpreprintarXiv:1711.09869,2017.4[6]YangyanLi,RuiBu,MingchaoSun,andBaoquanChen.Pointcnn.arXivpreprintarXiv:1801.07791,2018.4[7]HaoPan,ShilinLiu,YangLiu,andXinTong.Convolutionalneuralnetworkson3dsurfacesusingparallelframes.arXivpreprintarXiv:1808.04952,2018.3[8]CharlesRuizhongtaiQi,HaoSu,KaichunMo,andLeonidasJ.Guibas.Pointnet:Deeplearningonpointsetsfor3dclassiﬁcationandsegmentation.arXivpreprintarXiv:1612.00593,2016.4[9]CharlesRuizhongtaiQi,LiYi,HaoSu,andLeonidasJGuibas.Pointnet++:Deephierarchicalfeaturelearningonpointsetsinametricspace.InAdvancesinNeuralInformationProcessingSystems,2017.3[10]HaykoRiemenschneider,AndrásBódis-Szomorú,JulienWeissenberg,andLucVanGool.Learningwheretoclassifyinmulti-viewsemanticsegmentation.InEuropeanConferenceonComputerVision.Springer,2014.4[11]HangSu,VarunJampani,DeqingSun,SubhransuMaji,VangelisKalogerakis,Ming-HsuanYang,andJanKautz.Splatnet:Sparselatticenetworksforpointcloudprocessing.arXivpreprintarXiv:1802.08275,2018.3[12]MaximTatarchenko*,JaesikPark*,VladlenKoltun,andQian-YiZhou.Tangentconvolutionsfordensepredictionin3D.CVPR,2018.3,4[13]LynePTchapmi,ChristopherBChoy,IroArmeni,JunYoungGwak,andSilvioSavarese.Segcloud:Semanticsegmentationof3dpointclouds.InternationalConferenceon3DVision(3DV),2017.4[14]ShenlongWang,SimonSuo,Wei-ChiuMa3AndreiPokrovsky,andRaquelUrtasun.Deepparametriccontinuousconvolutionalneuralnetworks.InProceedingsoftheIEEEConferenceonComputerVisionandPatternRecognition,pages2589–2597,2018.4[15]XiaoqingYe,JiamaoLi,HexiaoHuang,LiangDu,andXiaolinZhang.3drecurrentneuralnetworkswithcontextfusionforpointcloudsemanticsegmentation.InTheEuropeanConferenceonComputerVision(ECCV),September2018.4