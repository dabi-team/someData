8
1
0
2

b
e
F
3
2

]

O
L
.
s
c
[

1
v
9
6
4
8
0
.
2
0
8
1
:
v
i
X
r
a

Parameterized veriﬁcation of synchronization in
constrained reconﬁgurable broadcast networks⋆

Balasubramanian A.R.1, Nathalie Bertrand2, and Nicolas Markey2

1 Chennai Mathematical Institute – Chennai (India)
2 Univ. Rennes, Inria, CNRS, IRISA – Rennes (France)

Abstract. Reconﬁgurable broadcast networks provide a convenient for-
malism for modelling and reasoning about networks of mobile agents
broadcasting messages to other agents following some (evolving) commu-
nication topology. The parameterized veriﬁcation of such models aims
at checking whether a given property holds irrespective of the initial
conﬁguration (number of agents, initial states and initial communica-
tion topology). We focus here on the synchronization property, asking
whether all agents converge to a set of target states after some execu-
tion. This problem is known to be decidable in polynomial time when no
constraints are imposed on the evolution of the communication topology
(while it is undecidable for static broadcast networks).
In this paper we investigate how various constraints on reconﬁgurations
aﬀect the decidability and complexity of the synchronization problem.
In particular, we show that when bounding the number of reconﬁgured
links between two communications steps by a constant, synchronization
becomes undecidable; on the other hand, synchronization remains decid-
able in PTIME when the bound grows with the number of agents.

1

Introduction

There are numerous application domains for networks formed of an arbitrary
number of anonymous agents executing the same code: prominent examples are
distributed algorithms, communication protocols, cache-coherence protocols, and
biological systems such as populations of cells or individuals, etc. The automated
veriﬁcation of such systems is challenging [15,12,8,3]: its aim is to validate at
once all instances of the model, independently of the (parameterized) number of
agents. Such a problem can be phrased in terms of inﬁnite-state-system veriﬁca-
tion. Exploiting symmetries may lead to eﬃcient algorithms for the veriﬁcation
of relevant properties [7].

Diﬀerent means of interactions between agents can be considered in such
networks, depending on the application domain. Typical examples are shared
variables [13,10,4], rendez-vous [12], and broadcast communications [9,6]. In this
paper, we target ad hoc networks [6], in which the agents can broadcast messages

⋆ This work has been supported by the Indo-French research unit UMI Relax, and by

ERC project EQualIS (308087).

 
 
 
 
 
 
simultaneously to all their neighbours, i.e., to all the agents that are within their
radio range. The number of agents and the communication topology are ﬁxed
once and for all at the beginning of the execution. Parameterized veriﬁcation of
broadcast networks checks if a speciﬁcation is met independently of the number
of agents and communication topology. It is usually simpler to reason about the
dual problem of the existence of an initial conﬁguration (consisting of a network
size, an initial state for each agent, and a communication topology) from which
some execution violates the given speciﬁcation.

Several types of speciﬁcations have been considered in the literature. We focus
here on coverability and synchronization: does there exist an initial conﬁguration
from which some agent (resp. all agents at the same time) may reach a particular
set of target states. Both problems are undecidable; decidability of coverability
can be regained by bounding the length of simple paths in the communication
topology [6].

In the case of mobile ad hoc networks (MANETs), agents are mobile, so that
the communication links (and thus the neighbourhood of each agent) may evolve
over time. To reﬂect the mobility of agents, Delzanno et al. studied reconﬁgurable
broadcast networks [6,5]. In such networks, the communication topology can
change arbitrarily at any time. Perhaps surprisingly, this modiﬁcation not only
allows for a more faithful modelling of MANETs, but it also leads to decidability
of both the coverability and the synchronization problems [6]. A probabilistic
extension of reconﬁgurable broadcast networks has been studied in [1,2] to model
randomized protocols.

A drawback of the semantics of reconﬁgurable broadcast networks is that they
allow arbitrary changes at each reconﬁguration. Such arbitrary reconﬁgurations
may not be realistic, especially in settings where communications are frequent
enough, and mobility is slow and not chaotic. In this paper, we limit the impact
of reconﬁgurations in several ways, and study how those limitations aﬀect the
decidability and complexity of parameterized veriﬁcation of synchronization.

More speciﬁcally, we restrict reconﬁgurations by limiting the number of
changes in the communication graph, either by considering global constraints (on
the total number of edges being modiﬁed), or by considering local constraints
(on the number of updates aﬀecting each individual node). We prove that syn-
chronization is decidable when imposing constant local constraints, as well as
when imposing global constraints depending (as a divergent function) on the
number of agents. On the other hand, imposing a constant global bound makes
synchronization undecidable. We recover decidability by bounding the maximal
degree of each node by 1.

2 Broadcast networks with constrained reconﬁguration

In this section, we ﬁrst deﬁne reconﬁgurable broadcast networks; we then intro-
duce several constraints on reconﬁgurations along executions, and investigate
how they compare one to another and with unconstrained reconﬁgurations.

2

q0

??a

!!a

??a

q5

q1

q7

!!c

!!b

!!d

q6

q2

q8

??c

q3

??d

q4

Fig. 1. Example of a broadcast protocol

q0

q0

q0

??a

q5

!!a

q1

B

R

??a

q7

q5

q1

q7

q5

!!b

q2

B

R

q7

q5

q2

q7

!!c

q6

??c

q3

B

R

q7

q6

q3

q7

q6

??d

q4

B

!!d

q8

Fig. 2. Sample execution under reconﬁgurable semantics, synchronizing to {q4, q6, q8}
(B-transitions are communications steps, R are reconﬁguration steps).

2.1 Reconﬁgurable broadcast networks

Deﬁnition 1. A broadcast protocol is a tuple P = (Q, I, Σ, ∆) where Q is a
ﬁnite set of control states; I ∈ Q is the set of initial control states; Σ is a ﬁnite
alphabet; and ∆ ⊆ (Q × {!!a, ??a | a ∈ Σ} × Q) is the transition relation.

A (reconﬁgurable) broadcast network is a system made of several copies of
a single broadcast protocol P. Conﬁgurations of such a network are undirected
graphs whose each node is labelled with a state of P. Transitions between con-
ﬁgurations can either be reconﬁgurations of the communication topology (i.e.,
changes in the edges of the graph), or a communication via broadcast of a mes-
sage (i.e., changes in the labelling of the graph). Figures 1 and 2 respectively
display an example of a broadcast protocol and of an execution of a network
made of three copies of that protocol.

Formally, we ﬁrst deﬁne undirected labelled graphs. Given a set L of labels,
an L-graph is an undirected graph G = (N, E, L) where N is a ﬁnite set of nodes;
E ⊆ P2(N)3 (notice in particular that such a graph has no self-loops); ﬁnally,
L : N → L is the labelling function. We let GL denote the (inﬁnite) set of L-
labelled graphs. Given a graph G ∈ GL, we write n ∼ n′ whenever {n, n′} ∈ E
and we let NeighG(n) = {n′ | n ∼ n′} be the neighbourhood of n, i.e. the set of
nodes adjacent to n. For a label ℓ, we denote by |G|ℓ the number of nodes in G
labelled by ℓ. Finally L(G) denotes the set of labels appearing in nodes of G.

The semantics of a reconﬁgurable broadcast network based on broadcast pro-
tocol P is an inﬁnite-state transition system T (P). The conﬁgurations of T (P)

3 For a ﬁnite set S and 1 ≤ k ≤ |S|, we let Pk(S) = {T ⊆ S | |T | = k}.

3

are Q-labelled graphs. Intuitively, each node of such a graph runs protocol P,
and may send/receive messages to/from its neighbours. A conﬁguration (N, E, L)
is said initial if L(N) ⊆ I. From a conﬁguration G = (N, E, L), two types of steps
are possible. More precisely, there is a step from (N, E, L) to (N′, E′, L′) if one of
the following two conditions holds:

(reconﬁguration step) N′ = N and L′ = L: a reconﬁguration step does not
change the set of nodes and their labels, but may change the edges arbitrarily;
(communication step) N′ = N, E′ = E, and there exists n ∈ N and a ∈ Σ
such that (L(n), !!a, L′(n)) ∈ ∆, and for every n′, if n′ ∈ NeighG(n), then
(L(n′), ??a, L′(n′)) ∈ ∆, otherwise L′(n′) = L(n′): a communication step re-
ﬂects how nodes evolve when one of them broadcasts a message to its neigh-
bours.

An execution of the reconﬁgurable broadcast network is a sequence ρ = (Gi)0≤i≤r
of conﬁgurations such that for any i < r, there is a step from Gi to Gi+1 and ρ
strictly alternates communication and reconﬁguration steps (the latter possibly
being trivial). An execution is initial if it starts from an initial conﬁguration.

An important ingredient that we heavily use in the sequel is juxtaposition
of conﬁgurations and shuﬄing of executions. The juxtaposition of two con-
ﬁgurations G = (N, E, L) and G′ = (N′, E′, L′) is the conﬁguration G ⊕ G′ =
(N ⊎ N′, E ⊎ E′, L⊕), in which L⊕ extends both L and L′: L⊕(n) = L(n) if n ∈ N
and L⊕(n) = L′(n) if n ∈ N′. We write G2 for the juxtaposition of G with itself,
and, inductively, GN for the juxtaposition of GN −1 with G. A shuﬄe of two ex-
j )0≤j≤r′ is an execution ρ⊕ from G0 ⊕ G′
ecutions ρ = (Gi)0≤i≤r and ρ′ = (G′
0
to Gr ⊕ G′
r′ obtained by interleaving ρ and ρ′. Note that a reconﬁguration step
in ρ⊕ may be composed of reconﬁgurations from both ρ and ρ′. We write ρ ⊕ ρ′
for the set of shuﬄe executions obtained from ρ and ρ′.

Natural decision problems for reconﬁgurable broadcast networks include check-
ing whether some node may reach a target state, or whether all nodes may syn-
chronize to a set of target states. More precisely, given a broadcast protocol P
and a subset F ⊆ Q, the coverability problem asks whether there exists an initial
execution ρ that visits a conﬁguration G with L(G) ∩ F 6= ∅, and the synchro-
nization problem asks whether there exists an initial execution ρ that visits a
conﬁguration G with L(G) ⊆ F . For unconstrained reconﬁgurations, we have:

Theorem 2 ([6,5,11]). The coverability and synchronization problems are de-
cidable in PTIME for reconﬁgurable broadcast protocols.

Remark 1. The synchronization problem was proven decidable in [6], and PTIME
membership was given in [11, p. 41]. The algorithm consists in computing the
set of states of P that are both reachable (i.e., coverable) from an initial con-
ﬁguration and co-reachable from a target conﬁguration. This can be performed
by applying iteratively the algorithm of [5] for computing the set of reachable
states (with reversed transitions for computing co-reachable states).

4

Example 1. Consider the broadcast protocol of Fig. 1 with I = {q0}. From each
state, unspeciﬁed message receptions lead to an (omitted) sink state; this way,
each broadcast message triggers a transition in all the neighbouring copies.

For that broadcast protocol, one easily sees that it is possible to synchronize
to the set {q4, q6, q8}. Moreover, three copies are needed and suﬃcient for that
objective, as witnessed by the execution of Fig. 2. The initial conﬁguration has
three copies and two edges. If the central node broadcasts a, the other two nodes
receive, one proceeding to q5 and the other to q7. Then, we assume the commu-
nication topology is emptied before the same node broadcasts b, moving to q2.
Finally the node in q5 connects to the one in q2 to communicate on c and then
disconnects, followed by a similar communication on d initiated by the node in q7.

2.2 Natural constraints for reconﬁguration

Allowing arbitrary changes in the network topology may look unrealistic. In or-
der to address this issue, we introduce several ways of bounding the number of
reconﬁgurations after each communication step. For this, we consider the follow-
ing natural pseudometric between graphs, which for simplicity we call distance.

Deﬁnition 3. Let G = (N, E, L) and G′ = (N′, E′, L′) be two L-labelled graphs.
The distance between G and G′ is deﬁned as

dist(G, G′) = |E ∪ E′ \ (E ∩ E′)|

when N = N′ and L = L′, and dist(G, G′) = 0 otherwise.

Setting the “distance” to 0 for two graphs that do not agree on the set of nodes
or on the labelling function might seem strange at ﬁrst. This choice is motivated
by the deﬁnition of constraints on executions (see below) and of the number of
reconﬁgurations along an execution (see Section 2.3). Other distances may be of
interest in this context; in particular, for a ﬁxed node n ∈ N, we let distn(G, G′)
be the number of edges involving node n in the symmetric diﬀerence of E and E′
(still assuming N = N′ and L = L′).

Constant number of reconﬁgurations per step. A ﬁrst natural constraint on re-
conﬁguration consists in bounding the number of changes in a reconﬁguration
step by a constant number. Recall that along executions, communication and
reconﬁguration steps strictly alternate.

Deﬁnition 4. Let k ∈ N. An execution ρ = (Gi)0≤i≤r of a reconﬁgurable broad-
cast network is k-constrained if for every index i < r, it holds dist(Gi, Gi+1) ≤ k.

Example 1 (Contd). For the synchronization problem, bounding the number of
reconﬁgurations makes a diﬀerence. The sample execution from Fig. 2 is not 1-
constrained, and actually no 1-constrained executions of that broadcast protocol
can synchronize to {q4, q5, q6}. This can be shown by exhibiting and proving an
invariant on the reachable conﬁgurations (see Lemma 10).

5

Beyond constant number of reconﬁgurations per step. Bounding the number of
reconﬁgurations per step by a constant is somewhat restrictive, especially when
this constant does not depend on the size of the network. We introduce other
kinds of constraints here, for instance by bounding the number of reconﬁgura-
tions by k on average along the execution, or by having a bound that depends
on the number of nodes executing the protocol.

For a ﬁnite execution ρ = (Gi)0≤i≤r of a reconﬁgurable broadcast network,
we write nb comm(ρ) for the number of communication steps along ρ (notice that
⌊r/2⌋ ≤ nb comm(ρ) ≤ ⌈r/2⌉ since we require strict alternation between recon-
ﬁguration and communication steps), and nb reconf(ρ) for the total number of
edge reconﬁgurations in ρ, that is nb reconf(ρ) = Pr−2

i=0 dist(Gi, Gi+1).

Deﬁnition 5. Let k ∈ N. An execution ρ of a reconﬁgurable broadcast network
is said k-balanced if it starts and ends with a communication step, and satisﬁes
nb reconf(ρ) ≤ k · (nb comm(ρ) − 1).

This indeed captures our intuition that along a k-balanced execution, reconﬁgu-
rations on average update less than k links.

Finally, we will also consider two relevant ways to constrain reconﬁgurations
depending on the size of the network: ﬁrst locally, bounding the number of
reconﬁgurations per node by a constant; second globally, bounding the total
number of reconﬁgurations by a function of the number of nodes.

We ﬁrst bound reconﬁgurations locally.

Deﬁnition 6. Let k ∈ N. An execution ρ = (Gi)0≤i≤r of a reconﬁgurable broad-
cast network is k-locally-constrained, if, for every node n and for every index
i < r, distn(Gi, Gi+1) ≤ k.

One may also bound the number of reconﬁgurations globally using bounding

functions, that depend on the number of nodes in the network:
Deﬁnition 7. Let f : N → N be a function. An execution ρ = (Gi)0≤i≤r of a
reconﬁgurable broadcast network is f -constrained, if, writing n for the number
of nodes in G0, it holds dist(Gi, Gi+1) ≤ f (n) for any i < r.
Notice that if f is the constant function n ∈ N 7→ k for some k ∈ N, f -constrained
executions coincide with k-constrained ones, so that our terminology is non-
ambiguous. Other natural bounding functions are non-decreasing and diverging.
This way, the number of possible reconﬁgurations tends to inﬁnity when the
network size grows, i.e. ∀n. ∃k. f (k) ≥ n.

Remark 2. Coverability under constrained reconﬁgurations is easily observed to
be equivalent to coverability with unconstrained reconﬁgurations: from an uncon-
strained execution, we can simply juxtapose extra copies of the protocol, which
would perform extra communication steps so as to satisfy the constraint. When
dealing with synchronization, this technique does not work since the extra copies
would also have to synchronize to a target state. As a consequence, we only focus
on synchronization in the rest of this paper.

6

2.3 Classiﬁcation of constraints

In this section, we compare our restrictions. We prove that, for the synchro-
nization problem, k-locally-constrained and f -constrained reconﬁgurations, for
diverging functions f , are equivalent to unconstrained reconﬁgurations. On the
other hand, we prove that k-constrained reconﬁgurations are equivalent to k-
balanced reconﬁgurations, and do not coincide with unconstrained reconﬁgura-
tions.

Equivalence between unconstrained and locally-constrained reconﬁgurations. In this
section, we handle the case of f -constraints and k-local constraints, showing that
they never prevent synchronization.

Lemma 8. Let P be a broadcast protocol, F ⊆ Q be a target set, and f be a
non-decreasing diverging function. If the reconﬁgurable broadcast network deﬁned
by P has an initial execution synchronizing in F , then it has an f -constrained
initial execution synchronizing in F .

Proof. We ﬁrst prove the lemma for the identity function Id. More precisely,
we prove that for an execution ρ = (Gi)0≤i≤n, of the reconﬁgurable broadcast
network, there exists a Id-constrained execution ρ′ = (G′
j )0≤j≤m, whose last
transition (if any) is a communication step, and such that for any control state q,
|Gn|q = |G′
m|q. We reason by induction on the length of the execution. The claim
is obvious for n = 0. Suppose the property is true for all naturals less than or
equal to some n ∈ N, and consider an execution ρ = (Gi)0≤i≤n+1. The induction
hypothesis ensures that there is an f -constrained execution ρ′ = (G′
j )0≤j≤m
with |Gn|q = |G′
m|q for all q. If the last transition from Gn to Gn+1 in ρ is a
reconﬁguration step, then the execution ρ′ witnesses our claim. Otherwise, the
transition from Gn to Gn+1 is a communication step, involving a broadcasting
node n of Gn labelled with q, and receiving nodes n1 to nr of Gn, respectively
m also contains a node n′ labelled with q
labelled with q1 to qr. By hypothesis, G′
m in ρ′:
and r nodes n′
we ﬁrst reconﬁgure the graph so that NeighG′
i | 0 ≤ i ≤ r}, which
requires changing at most |G0| − 1 links, and then perform the same broadcast/
receive transitions as between Gn and Gn+1.

r, labelled with q1 to qr. We then add two steps after G′

(n′) = {n′

1 to n′

m+1

For the general case of the lemma, suppose f is a non-decreasing diverging
function. Further, let ρ = (Gi)0≤i≤n be an Id-constrained execution, and pick k
such that f (k · |G0|) ≥ |G0|. Consider the initial conﬁguration Gk
0, made of k
copies of G0, and the execution, denoted ρk, made of k copies of ρ running
independently from each of the k copies of G0 in Gk
0. Each reconﬁguration step
(cid:3)
involves at most |G0| links, so that ρk is f -constrained.

Lemma 9. Let P be a broadcast protocol with F ⊆ Q a target set. If the recon-
ﬁgurable broadcast network deﬁned by P has an initial execution synchronizing
in F , then it has a 1-locally-constrained initial execution synchronizing in F .

7

Proof. Let ρ = (Gi)0≤i≤n be an execution of the reconﬁgurable broadcast network
deﬁned by P that starts and ends with a communication step (hence n is odd)
and synchronizing to F .

We write (s2i)0≤2i≤n−1 for the sequence of communication steps in ρ, such
that s2i is the step from G2i to G2i+1. Similarly, (s2i+1)1≤2i+1≤n−2 is the sequence
of reconﬁguration steps. For each of them, we let r2i+1 = dist(G2i+1, G2i+2) be
the number of reconﬁgured edges, and (e2i+1,j )1≤j≤r2i+1 be the sequence (in ar-
bitrary order) of edges of G2i+1 involved in the reconﬁguration step s2i+1. We de-
compose step s2i+1 into r2i+1 atomic reconﬁgurations steps (sj

2i+1)1≤j≤r2i+1 .

Let r = max{r2i+1 | 1 ≤ 2i + 1 ≤ n − 2} be the maximum number of recon-
ﬁgured edges in a reconﬁguration step in ρ. We exhibit a 1-locally-constrained
execution starting from conﬁguration Gr
n, hence synchronizing
in F . Each of the r components of Gr
0 will perform the same sequence of steps
as along ρ, with the reconﬁguration steps being split into consecutive atomic re-
conﬁguration steps; the extra components will be used to insert communication
steps between consecutive reconﬁguration steps.

0 and ending in Gr

More precisely, the execution decomposes in three parts:

– the ﬁrst part runs as follows: roughly, it is made of r pairs of communication/
reconﬁguration steps. At step 1 ≤ i ≤ r, the i-th component performs tran-
sition s0; then each component 1 ≤ j ≤ i performs atomic reconﬁguration
step si+1−j
1
In case some of the ﬁrst i components are in positions to perform a new
communication transition, they perform this communication step right after
the communication step of the i-th component;

(the other components remain idle).

– the second part is similar, but each of them performs an atomic reconﬁgu-
ration during reconﬁguration steps; again, extra communication steps may
have to be inserted for components that are in positions to do so;

– the third part starts when the ﬁrst component performs its last communica-
tion step. This component has reached its ﬁnal conﬁguration Gn, and stops
there. The other components continue as before until they in turn reach their
(cid:3)
ﬁnal conﬁguration. This way, the whole system ends up in Gr
n.

k-constrained and k-balanced reconﬁgurations. We prove here that k-constrained
and k-balanced reconﬁgurations are equivalent w.r.t. synchronization, and that
they are strictly stronger than our other restrictions. We begin with the latter:

Lemma 10. There exists a broadcast protocol P and a set F ⊆ Q of target
states for which synchronization is possible from some initial conﬁguration when
unconstrained reconﬁgurations are allowed, and impossible, from every initial
conﬁguration when only 1-constrained reconﬁgurations are allowed.

Proof. For the protocol of Example 1, we already observed the synchronization
was possible (with three copies of the protocol), and Figure 2 displays an example
of a 2-constrained initial execution synchronizing in its target set {q4, q6, q8}.

8

We now prove that no initial conﬁgurations can lead to synchronization when
only using 1-constrained reconﬁgurations. Assuming otherwise, we pick a syn-
chonizing execution; we write x, y and z for the number of copies of the protocol
that end up in q4, q6 and q8, respectively. Obviously, the total number of com-
munication steps is 2x + y + z, so that the total number of reconﬁgurations must
be at most 2x + y + z − 1. Now, when a process arrives in q5, it is linked to a
process in q1, and this link has to be removed before message b can be broadcast.
The same holds for those processes arriving in q7, and a similar argument applies
for processes entering q2 and q3. It follows that a synchronizing execution has
to perform at least 2x + y + z reconﬁgurations (as reconﬁgurations are atomic),
(cid:3)
which yields a contradiction.

As can be observed in the execution of Fig. 2, our deﬁnition of k-constrained
executions is weak, and allows reconﬁgurations involving less than k edges in the
communication graph; it even allows trivial reconﬁgurations, hence consecutive
broadcasts. A strong version of k-constrained executions can be deﬁned, where
exactly k edges have to be updated during reconﬁguration phases.

One easily proves that both notions are equivalent (for the synchronization
problem): from a (weakly) k-constrained synchronizing execution, one can build
a strongly k-constrained synchronizing execution by taking several extra copies
of the graph describing the topology, in which we can add, and then remove,
edges in order to always perform exactly k changes in the topology. Actually,
we have:

Lemma 11. Let P be a broadcast protocol, F ⊆ Q be a target set, and k ∈ N.
If the reconﬁgurable broadcast network deﬁned by P has a 1-constrained initial
execution synchronizing in F , then it has a k-constrained initial execution syn-
chronizing in F .

Proof. Consider a 1-constrained initial execution ρ = (Gi)0≤i<n synchronizing
in F . Let m be an even number larger than or equal to k + 2. We build a
k-constrained initial execution ρ′ = (G′
j )0≤j<mn by mimicking m copies of ρ
running in parallel. This execution starts from L0≤j<m G0. Consider a pair of
consecutive steps of ρ, made of a communication step followed by a 1-constrained
reconﬁguration step. It goes from G2i to G2i+2, for some i. We associate with this
pair of steps m/2 pairs of steps from L0≤j<m G2i to L0≤j<m G2i+2. For this, we
consider two copies of G2i at a time (so that there remains at least k auxiliary
copies): the ﬁrst of the two selected copies performs the communication step,
followed by the 1-constrained reconﬁguration step. In order to make the latter
step k-constrained, we perform a set of k − 1 (arbitrary) reconﬁgurations in the
remaining k auxiliary copies of G2i. Then the second of the two selected copies
performs the communication step, followed by a 1-constrained reconﬁguration
step, which is made k-constrained by reversing the k − 1 arbitrary reconﬁgura-
tions performed previously. This way, two copies have moved to G2i+2, which the
remaining m − 2 copies are still in G2i and can in turn apply the same strategy.

9

The last communication step of ρ is handled similarly, but it is not coupled
with a reconﬁguration step; we may need up to k auxiliary copies to perform a
(cid:3)
k-constrained reconﬁguration step.

Corollary 12. Let P be a broadcast protocol, F ⊆ Q be a target set, and k ∈ N.
The reconﬁgurable broadcast network deﬁned by P has a (weakly) k-constrained
initial execution synchronizing in F (where reconﬁgurations may change at most
k links), if, and only if, it has a strongly k-constrained initial execution synchro-
nizing in F (where each reconﬁguration step modiﬁes exactly k links).

We now prove the main result of this section:

Theorem 13. Let P be a broadcast protocol and F ⊆ Q. There exists a k-
constrained initial execution synchronizing in F if, and only if, there exists a
k-balanced initial execution synchronizing in F .

Proof. The left-to-right implication is simple: if there is a k-constrained initial ex-
ecution synchronizing in F , w.l.o.g. we can assume that this execution starts and
ends with a communication step; moreover, each reconﬁguration step contains
at most k edge reconﬁgurations, so that the witness execution is k-balanced.

Let ρ = (Gi)0≤i≤n be a k-balanced execution synchronizing in F and starting
and ending with communication steps (hence n is odd). We deﬁne the poten-
tial (pi)0≤i≤n of ρ as the sequence of n + 1 integers obtained as follows:

– p0 = 0;
– p2i+1 = p2i + k for i ≤ (n − 1)/2 (this corresponds to a communication step);
– p2i+2 = p2i+1 − dist(G2i+1, G2i+2) for i ≤ (n − 1)/2 − 1 (reconﬁguration step).

That ρ is k-balanced translates as pn−1 ≥ 0: the sequence (pi)0≤i≤n stores the
value of k · nb comm(ρ≤i) − nb reconf(ρ≤i) for each preﬁx ρ≤i of ρ; being k-
balanced means that pn ≥ k, and since the last step is a communication step,
this in turn means pn−1 ≥ 0. On the other hand, in order to be k-constrained,
it is necessary (but not suﬃcient) to have pi ≥ 0 for all 0 ≤ i ≤ n.

We build a k-constrained execution by shuﬄing several copies of ρ. We actu-
ally begin with the case where k = 1, and then extend the proof to any k. We ﬁrst
compute how many copies we need. For this, we split ρ into several phases, based
on the potential (pi)0≤i≤n deﬁned above. A phase is a maximal segment of ρ≤n−1
(the preﬁx of ρ obtained by dropping the last (communication) step) along which
the sign of the potential is constant (or zero): graphs Gi and Gj are in the same
phase if, and only if, for all i ≤ l ≤ l′ ≤ j, it holds pl · pl′ ≥ 0. We decompose ρ as
the concatenation of phases (ρj)0≤j≤m; since ρ is k-balanced, m is even, and ρ0,
ρm, and all even-numbered phases are non-negative phases (i.e., the potential
is non-negative along those executions), while all odd-numbered executions are
non-positive phases. Also, all phases end with potential zero, except possibly
for ρm. See Fig. 3 for an example of a decomposition into phases.

10

Lemma 14. For any phase ρi = Gbi · · · Gei of a 1-balanced execution ρ =
G0 · · · Gn, there exists κi ≤ (ei − bi)/2 such that for any N ∈ N, there exists
a 1-constrained execution from Gκi

0 ⊕ GN

1 ⊕ GN
ei .

bi to Gκi

Proof. We handle non-negative and non-positive phases separately. In a non-
negative phase, we name repeated reconﬁguration step any reconﬁguration step
that immediately follows another (possibly from the previous phase) reconﬁgu-
ration step (so that if there are four consecutive reconﬁguration steps, the last
three are said repeated); similarly, we name repeated communication step any
communication step that is immediately followed (possibly in the next phase)
by another communication step (hence the ﬁrst three of fours consecutive com-
munication steps are repeated).

We ﬁrst claim that any non-negative phase contains at least as many repeated
communication steps as it contains repeated reconﬁguration steps. Indeed, any
non-repeated communication step in a non-negative phase is necessarily followed
by a non-repeated reconﬁguration step, and conversely, and non-negative phases
have at least as many communication steps as they have reconﬁguration steps.
As a consequence, we can number all repeated reconﬁguration steps from 1
(earliest) to κi (latest), for some κi, and similarly for repeated communication
steps. Clearly enough, in a non-negative phase, for any 1 ≤ j ≤ κi, the repeated
communication step numbered j occurs before the repeated reconﬁguration step
carrying the same number.

We now build our 1-constrained execution from Gκi

0 ⊕GN

bi to Gκi

1 ⊕GN

ei . We be-

gin with a ﬁrst part, where only the components starting from Gbi move:

– the ﬁrst copy starting in Gbi follows the execution ρi until reaching the
repeated reconﬁguration step number 1. That reconﬁguration step cannot be
performed immediately as it follows another reconﬁguration step. Notice that
during this stage, this copy has taken at least one repeated communication
step, numbered 1;

– the second copy then follows ρi until reaching its ﬁrst repeated communica-
tion step (which must occur before the ﬁrst repeated reconﬁguration step).
It takes this communication step, then allowing the ﬁrst copy to perform its
ﬁrst repeated reconﬁguration step;

– this simulation continues, each time having the l + 1-st copy of the system
taking its j-th repeated communication step in order to allow the l-th copy
to perform its j-th repeated reconﬁguration step. Non-repeated steps can
always be performed individually by each single copy. Also, the ﬁrst copy
may always take repeated communication steps not having a corresponding
reconﬁguration step, as in the ﬁrst stage of this part.

Notice that the number of copies involved in this process is arbitrary. The process
lasts as long as some copies may advance within phase ρi. Hence, when the
process stops, all copies of the original system either have reached the end of ρi,
or are stopped before a repeated reconﬁguration step. For the copies in the latter
situation, we use the copies starting from G0. It remains to prove that having κi
such copies is enough to make all processes reach the end of ρi.

11

potential

➀

➁

➀

➁

➀

nonpositive phase

nonnegative phase

➁

➀

➂

➁

➀

➂

nonnegative
phase

Fig. 3. Phases of a 1-balanced execution, and correspondence between repeated commu-
nication steps (loosely dotted blue steps) and repeated reconﬁguration steps (densely
dotted red steps)

For this, we ﬁrst assume that the potential associated with ρi ends with
value zero. This must be the case of all phases except the last one, which we
handle after the general case. We ﬁrst notice that in the execution we are cur-
rently building, any repeated communication step performed by any (but the
very ﬁrst) copy that started from Gbi is always followed by a repeated reconﬁgu-
ration step. Similarly, non-repeated communication steps of any copy is followed
by a non-repeated broadcast step of the same copy. As a consequence, the poten-
tial associated with the global execution we are currently building never exceeds
the total number of repeated communication steps of performed by the ﬁrst
copy; hence it is bounded by κi, whatever the number N of copies involved. As a
consequence, at most κi communication steps are suﬃcient in order to advance
all copies that started from Gbi to the end of ρi.

Finally, the case of the last phase ρm (possibly ending with positive potential)
is easily handled, as it has more communication steps than reconﬁguration steps.
(cid:3)

The proof for non-positive phases is similar.

Pick a 1-balanced execution ρ = G0 · · · Gn, and decompose it into phases
ρ1 · · · ρm. For each phase ρi, we write κi for the total number of repeated recon-
ﬁguration steps, and we let κ = P1≤i≤m κi for the total number of repeated
reconﬁguration steps along ρ. Notice that κ ≤ n/2.

Lemma 15. For every 1-balanced execution ρ = G0 · · · Gn, and for every N ∈ N,
there exists a 1-constrained execution from GN

1 ⊕ GκN

em to GN +κN

n

.

Proof. The copies starting from Gem only have to perform a single communication
step in order to reach Gn. These steps will be used to allow reconﬁgurations for
the N copies mimicking ρ. Each of the N copies as to perform at most κ repeated
reconﬁguration steps, hence it needs at most κ external communication steps to
(cid:3)
reach the end of ρ.

Combining the above two lemmas, we obtain the following proposition, which

reﬁnes the statement of the Theorem 13:

Proposition 16. For every 1-balanced execution ρ = G0 · · · Gn and every N ≥
κ2 + κ, there exists a 1-constrained execution from GN

0 to GN
n .

12

Proof. Pick N ≥ κ2 + κ, and consider N copies of G0. We take N − κ such
copies, and apply Lemma 14 to each phase ρi of ρ, each time involving κi of the
remaining κ copies. In the end, we have κ copies in G1 and N − κ copies in Gem .
We then apply Lemma 15, using κ2 of the copies in Gem in order to move our κ
copies from G1 to Gn. The remaining N − κ − κ2 copies still in Gem can ﬁnally
(cid:3)
move to Gn, completing the execution.

We ﬁnally extend this result to k > 1. In this case, splitting ρ into phases
is not as convenient as when k = 1: indeed, a non-positive phase might not end
with potential zero (because communication steps make the potential jump by
k units). Lemma 14 would not hold in this case.

We circumvent this problem by ﬁrst shuﬄing k copies of ρ in such a way
that reconﬁgurations can be gathered into groups of size exactly k. This way,
we can indeed split the resulting execution into non-negative and non-positive
phases, always considering reconﬁgurations of size exactly k; we can then apply
the techniques above in order to build a synchronizing k-constrained execution.
(cid:3)
This completes our proof.

3 Parameterized synchronization under reconﬁguration

constraints

3.1 Undecidability for k-constrained reconﬁguration

Although synchronization is decidable in PTIME [6,11] for reconﬁgurable broad-
cast networks, the problem becomes undecidable when reconﬁgurations are k-
constrained.

Theorem 17. The synchronization problem is undecidable for reconﬁgurable
broadcast networks under k-constrained reconﬁgurations.

Proof. We prove this undecidability result for 1-constrained reconﬁgurations, by
giving a reduction from the halting problem for Minsky machines [14]. We begin
with some intuition. The state space of our protocol has two types of states:

– control states encode the control state of the 2-counter machine;
– counter states are used to model counter values: for each counter cj ∈
{c1, c2}, we have a state zeroj and a state onej. The value of counter cj
in the simulation will be encoded as the number of edges in the communi-
cation topology between the control node and counter nodes in state onej;
moreover, we will require that control nodes have no communication links
with counter nodes in state zeroj.
Incrementations and decrementations can then be performed by creating a
link with a node in zeroj and sending this node to onej, or sending a onej-
node to zeroj and removing the link.

In order to implement this, we have to take care of the facts that we may have
several control nodes in our network, that we may have links between two control

13

nodes or between two counter nodes, or that links between control nodes and
counter nodes may appear or disappear at random. Intuitively, those problems
will be handled as follows:

– we cannot avoid having several control nodes; instead, given a synchronizing
execution of the broadcast protocol, we will select one control node and show
that it encodes a correct execution of the 2-counter machine;

– in order to reach a synchronizing conﬁguration, the selected control node
will have to perform at least as many reconﬁguration steps as broadcast
steps. Because we consider 1-constrained runs, it will perform exactly the
same number of reconﬁguration steps as broadcast steps, so that no useless/
unexpected reconﬁgurations may take place during the simulation;

– control nodes will periodically run special broadcasts that would send any
connected nodes (except nodes in state onej) to a sink state, thus preventing
synchronization. This way, we ensure that that particular control node is
clean. Initially, we require that control nodes have no connections at all.

We now present the detailed construction, depicted at Fig. 4 to 7. Each state
of the protocol is actually able to synchronize with all the messages; all nodes
′ and donei, which will be part of
with no outgoing transitions (i.e., nodes zeroj
the target set) actually carry a self-loop synchronizing on all messages; all other
transitions that are not drawn lead to an (omitted) sink state, which is not part
of the target set.

Let us explain the intended behaviour of the incrementation module of Fig. 5:
when entering the module, our control node n in state L is linked to c1 counter
nodes in state one1 and to c2 counter nodes in state one2; it has no other links.
Moreover, all auxiliary nodes are either in state freei or in state donei. Run-
ning through the incrementation module from L will use one counter node m in
state zeroj (which is used to eﬀectively encode the increase of counter cj) and
four auxiliary nodes a1 (initially in state free1), a2 (in state free2), and a3 and a′
3
(in state free3).

The execution then runs as follows:

– a link is created between the control node n and the ﬁrst auxiliary node a1,

followed by a message exchange !!i-init;

– a link is created between n and m, and node a1 broadcasts !!fr1;
– a link is created between n and a2, and n broadcasts !!i-askj, which is received

by both a2 and m;

– a link is created between n and a3; node m sends its acknowledgement !!i-ackj

to n;

– a link is created between n and a′

3; node n sends !!i-okj , received by m, a2,

a3 and a′
3;

– the link between n and a1 is removed, and a2 sends !!fr2;
– the link between n and a2 is removed, and a3 sends !!fr3;
– the link between n and a3 is removed, and a′
3 sends !!fr3;
– ﬁnally, the link between n and a′

3 is removed, and n sends !!i-exit.

14

!!start

M0

L1

!!i-exit

M1

L2

M2

M ′
2

Fig. 4. Global view of the part of the protocol for control nodes

!!i-init

i1

L

??fr1

i2

!!i-askj

??i-ackj

i3

i4

!!i-okj

i5

??fr2

i6

??fr3

i7

??fr3

!!i-exit

M

incrementation module

decrementation/zero-test module

!!d-askj

L

!!t-ask

j

d1

t1

??d-ackj

!!d-okj

d2

d3

??fr4

d4

??fr5

d5

??fr5

??t-ackj

t2

!!t-okj

t3

??fr5

??fr5

t4

!!d-exit

!!t-exit

M

M ′

Fig. 5. Modules for simulating incrementation and decrementation/zero test

zeroj

??i-okj

??i-askj

!!i-ackj

??i-okj

onej

??d-okj

??d-askj

!!d-ackj

??d-okj

′

zeroj

??i-init, ??i-ask∗, ??i-ok∗, ??i-exit, ??d-exit

Fig. 6. The part of the protocol for counter nodes

??i-init

free1

??i-askj

??i-okj

free2

free3

free5

??i-okj

??d-okj

??t-okj

!!fr1

!!fr3

!!fr5

done1

!!fr2

done3

done5

free4

??t-ask1

??d-askj

??t-ask2

done2

!!t-ack1

??d-okj

!!t-ack2

??t-ok1

??t-ok2

!!fr4

done4

Fig. 7. Parts of the protocol for auxiliary nodes

Figure 8 depicts this sequence of steps graphically.

After this sequence of steps, node n has an extra link to a counter node in
state onej, which indeed corresponds to incrementing counter cj. Moreover, no
nodes have been left in an intermediary state. A similar analysis can be done for
the second module, which implements the zero-test and decrementation. This
way, we can prove that if the two-counter machine has a halting computation,

15

onej

onej

zero1

onej

onej

zero1

onej

onej

i
-

a

c

k

onej

onej

one1

onej

onej

free3

free3

free2

L

free1

free3

i2

free3

free2

fr1

done1

free3

free3

done1

i4

i6

done2

r

f

2

done1

done3

done3

f

r

3

done2

M

free3

free3

free2

free1

free3

free3

free2

L

i2

done1

free3

free3

i4

done1

i6

M

done2

done1

done3

done3

done2

onej

onej

zero1

onej

onej

zero1

onej

onej

onej

onej

one1

onej

onej

free3

free3

free2

i1

i-init

free3

free3

done1

i3

i5

onej

onej

zero1

onej

onej

i
-

a

s

k

onej

onej

i
-

o

k

free3

free3

free2

free3

free3

free2

done1

onej

onej

zero1

onej

onej

onej

onej

i1

i3

i5

done1

one1

done1

one1

onej

onej

one1

onej

onej

done3

done2

i7

done1

one1

done3

done2

fr3

i7

done1

free3

free3

free2

onej

onej

L

done1

one1

done1

one1

free1

one1

Fig. 8. The 18 steps of an incrementation of counter c1

then there is an initial conﬁguration of our broadcast protocol from which there
is an execution synchronizing in the set F formed of the halting control state
and states onej, zeroj

′ and donei.

It now remains to prove the other direction. More precisely, we prove that
from a 1-constrained synchronizing execution of the protocol, we can extract a
synchronizing execution in some normal form, from which we derive a halting
execution of the two-counter machine.

Fix a 1-constrained synchronizing execution of the broadcast network. First
notice that when a control node n reaches some state L (the ﬁrst node of an incre-
mentation or decrementation module), it may only be linked to counter nodes in
state onej: this is because states L can only be reached by sending !!i-exit, !!d-exit,
!!t-exit, or !!start. The former two cases may only synchronize with counter nodes
in state onej; in the other two cases, node n may be linked to no other node.
Hence, for a control node n to traverse an incrementation module, it must get

16

links to four auxiliary nodes (in order to receive the four fr messages), those four
links must be removed (to avoid reaching the sink state), and an extra link has
to be created in order to receive message i-ackj . In total, traversing an incremen-
tation module takes nine communication steps and at least nine reconﬁguration
steps. Similarly, traversing a decrementation module via any of the two branches
takes at least as many reconﬁguration steps as communication steps. In the end,
taking into account the initial !!start communication step, if a control node n
is involved in Bn communication steps, it must be involved in at least Bn − 1
reconﬁguration steps.

Assume that every control node n is involved in at least Bn reconﬁguration
steps: then we would have at least as many reconﬁguration steps as communica-
tion steps, which in a 1-constrained execution is impossible. Hence there must
be a control node n0 performing Bn0 communication steps and exactly Bn0 − 1
reconﬁguration steps. As a consequence, when traversing an incrementation mod-
ule, node n0 indeed gets connected to exactly one new counter node, which in-
deed must be in state onej when n0 reaches the ﬁrst state of the next module.
Similarly, traversing a decrementation/zero-test module indeed performs the ex-
pected changes. It follows that the sequence of steps involving node n0 encodes
(cid:3)
a halting execution of the two-counter machines.

The 1-constrained executions in the proof of Theorem 17 have the additional
property that all graphs describing conﬁgurations are 2-bounded-path conﬁgu-
rations. For K ∈ N a conﬁguration G is a K-bounded-path conﬁguration if the
length of all simple paths in G is bounded by K. Note that a constant bound
on the length of simple paths implies that the diameter (i.e. the length of the
longest shortest path between any pair of vertices) is itself bounded. The synchro-
nization problem was proved to be undecidable for broadcast networks without
reconﬁguration when restricting to K-bounded-path conﬁgurations [6]. In com-
parison, for reconﬁgurable broadcast networks under k-constrained reconﬁgura-
tions, the undecidability result stated in Theorem 17 can be strengthened into:

Corollary 18. The synchronization problem is undecidable for reconﬁgurable
broadcast networks under k-constrained reconﬁgurations when restricted either
to bounded-path conﬁgurations, or to bounded-diameter conﬁgurations.

3.2 Decidability results

f -constrained and k-locally-constrained reconﬁgurations. From the equivalence
(w.r.t. synchronization) of k-locally-constrained, f -constrained and unconstrained
executions (Lemmas 9 and 8), and thanks to Theorem 2, we immediately get:

Corollary 19. Let k ∈ N and f : N → N be a non-decreasing diverging func-
tion. The synchronization problem for reconﬁgurable broadcast networks under k-
locally-constrained (resp. f -constrained) reconﬁgurations is decidable in PTIME.

17

Bounded degree topology. We now return to k-constrained reconﬁgurations, and
explore restrictions that allow one to recover decidability of the synchronization
problem. We further restrict k-constrained reconﬁgurations by requiring that the
degree of nodes remains bounded, by 1; in other terms, communications corre-
spond to rendez-vous between the broadcasting node and its single neighbour.

Theorem 20. The synchronization problem is decidable for reconﬁgurable broad-
cast networks under k-constrained reconﬁguration when restricted to 1-bounded-
degree topologies.

Proof. The proof is by reduction to the reachability problem for Petri nets, which
is known to be decidable [?,?,?]. Let P = (Q, q0, Σ, ∆) be a broadcast protocol,
where Q = {q1, q2, · · · , qn}. With P, we associate a Petri net N running in
three phases: the initialization phase sets the net into a marking encoding some
initial conﬁguration of the network; during the simulation phase, N simulates the
execution of the reconﬁgurable broadcast network; ﬁnally, in a checking phase,
it will make sure that all nodes have reached a target state.

The Petri net N has three types of nodes:

– for each state qi ∈ Q, a place pi is used to represent isolated nodes (i.e. having
no neighbour in the communication graph) in state qi. In the simulation
phase of our encoding, the number of tokens in pi will correspond to the
number of isolated nodes in state qi;

– for any pair of states (qi, qj) (possibly with qi = qj), a place pi,j is used to
represent pairs of connected nodes, one in state qi and the other in state qj.
Since we consider 1-bounded-degree topologies, those nodes may not have
additional connections. Again, the simulation phase of our encoding will
maintain the correspondence between the number of links between nodes
in qi and qj and the number of tokens in place pi,j;

– ﬁnally, N has k + 4 auxiliary places: four places start, simul, check and end
indicate the diﬀerent phases, while the other k places {reconfi | 1 ≤ i ≤ k}
are used to constrain the number of reconﬁgurations.

The transitions can be split in three groups, according to the phases they

correspond to:

– in order to initiate the simulation, transitions from place start will place
tokens in places p0 and p0,0, thereby encoding an initial conﬁguration of the
network. This is performed via three transitions:

• transition ti
• transition ti
• transition ti

1 with •ti
2 with •ti
s with •ti

1 = {start} and ti
• = {start, p0};
1
2 = {start} and ti
• = {start, p0,0};
2
s = {start} and ti
• = {simul}.
s

– the simulation phase starts when there is a token in simul; it then proceeds
by simulating communication steps and reconﬁguration steps, alternately.
Communication steps are easily simulated:

• either an isolated node in some state qi performs a transition δ =
δ = {simul, pi}
• = {reconf1, pj}. Place reconf1 indicates that the next step in the

(qi, !!a, qj), which can be simulated by a transition ts
and ts
δ
simulation will be the ﬁrst (of possibly up to k) reconﬁguration step;

δ with •ts

18

• a communication step may also take place between two connected nodes.
Then for any two transitions δ = (qi, !!a, qj) and δ′ = (qm, ??a, qn), we
have a transition ts

δ,δ′ = {simul, pi,m} and ts

• = {reconf1, pj,n}.

δ,δ′ with •ts

δ,δ′

When a token is in a reconﬁguration place, reconﬁguration steps may take
place. Atomic reconﬁgurations may either create links between two isolated
nodes, or break links between connected nodes:

• for any pair of states qi and qj, we have transitions trm

i↔j , for 1 ≤ m ≤ k,
creating a new link between nodes in state qi and qj. Such transitions
may occur at any of the k atomic steps of reconﬁgurations: •trm
i↔j =
{reconfm, pi, pj} and trm
• = {reconfm+1, pi,j}, for any 1 ≤ m ≤ k (with
the convention that reconfk+1 = simul);

i↔j

• conversely, breaking a link between nodes in states qi and qj is en-
• =

i6↔j = {reconfm, pi,j} and trm

coded by transitions trm
i6↔j such that •trm
{reconfm+1, pi, pj}, for any 1 ≤ m ≤ k.

i6↔j

• ﬁnally, we allow reconﬁgurations of less than k links by adding transi-
• =

tions from reconfm to simul, for each m: •trm
{simul}.
We also allow ending the simulation phase by adding a transition that
moves the token from simul to check.

end = {reconfm} and trm

end

– In the checking phase, we aim at checking that all nodes are in a target
state. To this aim, place check absorbs all tokens in places that correspond
to target states, that is places pi whose associated state qi is a target state,
as well as places pi,j for which both qi and qj are target states. Hence, for
each qi ∈ F , we have a transition tc
i with •tc
• = {check}.
Similarly, for any two states qi and qj in F , we have a transition tc
i,j with
•tc
• = {check}.

i = {check, pi} and tc
i

i.j = {check, pi,j} and tc
i,j

By construction, the reconﬁgurable broadcast network deﬁned by the broad-
cast protocol P has a k-constrained 1-bounded-degree execution from some ini-
tial conﬁguration if, and only if, the Petri net N has an execution from the initial
marking with a single token in start to the marking with a single token in end.
(cid:3)
We thus reduced to reachability of Petri nets, hence yielding decidability.

4 Conclusion

Restricting reconﬁgurations in reconﬁgurable broadcast networks is natural to
better reﬂect mobility when communications are frequent enough and the move-
ment of nodes is not chaotic. In this paper, we studied how constraints on the
number of reconﬁgurations (at each step and for each node, at each step and
globally, or along an execution) change the semantics of networks, in partic-
ular with respect to the synchronization problem, and aﬀect its decidability.
Our main results are the equivalence of k-constrained and k-balanced semantics,
the undecidability of synchronization under k-constrained reconﬁgurations, and
its decidability when restricting to 1-bounded-degree topologies.

As future work, we propose to investigate, beyond the coverability and syn-
chronization problems, richer objectives such as cardinality reachability prob-
lems as in [5]. Moreover, for semantics with constrained reconﬁgurations that

19

are equivalent to the unconstrained one as far as the coverability and synchro-
nization problems are concerned, it would be worth studying the impact of the
reconﬁguration restrictions (e.g. k-locally-constrained or f -constrained) on the
minimum number of nodes for which a synchronizing execution exists, and on
the minimum number of steps to synchronize.

References

1. Nathalie

Bertrand,

Paulin

Fournier,

and

Playing with probabilities in reconﬁgurable broadcast networks.
LNCS 8412, p. 134–148. Springer, 2014.

Arnaud

Sangnier.
In FoSSaCS’14,

2. Nathalie

Bertrand,

Sangnier.
Distributed local strategies in broadcast networks. In CONCUR’15, LIPIcs 42, p.
44–57. LZI, 2015.

Fournier,

Arnaud

Paulin

and

3. Roderick Bloem, Swen Jacobs, Ayrat Khalimov, Igor Konnov, Sasha Rubin, Hel-
mut Veith, and Josef Widder. Decidability of Parameterized Veriﬁcation, Synthesis
Lectures on Distributed Computing Theory. Morgan & Claypool Publishers, 2015.
4. Patricia Bouyer, Nicolas Markey, Mickael Randour, Arnaud Sangnier, and Daniel
Stan. Reachability in networks of register protocols under stochastic schedulers.
In ICALP’16, LIPIcs 55, p. 106:1–106:14. LZI, 2016.

5. Giorgio Delzanno, Arnaud Sangnier, Riccardo Traverso, and Gianluigi Zavattaro.

On the complexity of parameterized reachability in reconﬁgurable broadcast networks.
In FSTTCS’12, LIPIcs 18, p. 289–300. LZI, 2012.

6. Giorgio

Delzanno,

Sangnier,
Parameterized veriﬁcation of ad hoc networks.
p. 313–327. Springer, 2010.

Arnaud

and
Zavattaro.
In CONCUR’10, LNCS 6269,

Gianluigi

7. E. Allen Emerson and A. Prasad Sistla. Symmetry and model checking. Formal

Methods in System Design, 9(1-2):105–131, 1996.

8. Javier Esparza. Keeping a crowd safe: On the complexity of parameterized veriﬁcation (invited talk).

In STACS’14, LIPIcs 25, p. 1–10. LZI, 2014.

9. Javier

Esparza,

Alain

Finkel,

and

Richard

On the veriﬁcation of broadcast protocols.
Comp. Soc. Press, 1999.

In LICS’99, p. 352–359.

Mayr.
IEEE

10. Javier

Esparza,

Pierre

Ganty,

and

Rupak

Parameterized veriﬁcation of asynchronous shared-memory systems.
LNCS 8044, p. 124–140. Springer, 2013.

Majumdar.
In CAV’13,

11. Paulin Fournier. Parameterized veriﬁcation of networks of many identical processes.

Th`ese de doctorat, Universit´e Rennes 1, France, 2015.

12. Steven M. German and A. Prasad Sistla. Reasoning about systems with many processes.

Journal of the ACM, 39(3):675–735, 1992.

13. Matthew Hague.

Parameterised pushdown systems with non-atomic writes.

In FSTTCS’11, LIPIcs 13, p. 457–468. LZI, 2011.

14. Marvin Minsky. Computation: Finite and Inﬁnite Machines. Prentice Hall, 1967.
15. Ichiro Suzuki. Proving properties of a ring of ﬁnite-state machines. Information

Processing Letters, 28(4):213–214, 1988.

20

