REALIZA√á√ÉO DO MAPA LOG√çSTICO EM FPGA USANDO PADR√ÉO PONTO FIXO DE 32 BITS 

DIEGO A. SILVA1, EDUARDO B. PEREIRA1, ERIVELTON G. NEPOMUCENO1.  

1.  Laborat√≥rio de Estudos em Sistemas Aut√¥nomos e Inteligentes, Departamento de Engenharia El√©trica, 

Universidade Federal de S√£o Jo√£o del-Rei 
Pra√ßa Frei Orlando, 170 ‚Äì Centro ‚Äì 36307-352 ‚Äì S√£o Jo√£o del-Rei, MG, Brasil 
E-mails: diego.augusto.silva95@gmail.com, ebento@ufsj.edu.br, nepomuce-
no@ufsj.edu.br 

Abstract‚éØ This article presents a design of the logistic map by means of FPGA (Field Programmable Gate 
Array) under fixed-point standard and 32-bits of precision. The design was carried out with Altera Quartus 
platform. The hardware description language VHDL-93 has been adopted and the results were simulated 
by means of Altera ModelSim package. The main of the project was to produce a chaotic system with a low 
energy and time cost. Using the VHDL, it was possible to use only 1439 logical gates from 114480 availa-
ble.  The  Lyapunov  exponent  has  been  calculated  with  good  agreement  with  literature  reference,  which 
shows the effectiveness the proposed method. 

Keywords‚éØ FPGA, Logistic Map, Fixed Point Standard, Round Modes, Chaos Theory. 

Resumo‚éØ Este artigo apresenta a implementa√ß√£o do mapa log√≠stico usando FPGA (Field Programmable Gate Array) no padr√£o 
de 32 bits com ponto fixo. O projeto foi desenvolvido utilizando o software Quartus da Altera. Utilizou-selinguagem de descri-
√ß√£o de hardware VHDL-93 e a simula√ß√£o do resultado final foi feita no software ModelSim, tamb√©m da Altera. O projeto teve 
como  elemento  norteador  a  proposi√ß√£o  de  um  sistema  ca√≥tico  com  baixo  consumo  de  energia  e  tempo.  Usando  a  linguagem 
VHDL, foi poss√≠vel utilizar apenas 1439 portas l√≥gicas de um total de 114480. O expoente de Lyapunov calculado e apresentou 
boa concord√¢ncia com os valores presentes na literatura, confirmando o √™xito do projeto. 

Palavras-chave‚éØ FPGA, Mapa Log√≠stico, Padr√£o Ponto Fixo, Modos de Arredondamento, Teoria do Caos.

1    Introdu√ß√£o  

Sistemas  ca√≥ticos  s√£o  sistemas  n√£o-lineares  de-
termin√≠sticos cujo comportamento din√¢mico aparenta 
evoluir no tempo de maneira aleat√≥ria. Essa din√¢mica 
complexa √© extremamente sens√≠vel √† varia√ß√£o de suas 
condi√ß√µes  iniciais  e  param√©tricas.  Diversos  sistemas 
de √°reas do conhecimento distintas apresentam com-
portamento  ca√≥tico,  como  por  exemplo  na  Biologia, 
Ci√™ncias  Sociais,  Engenharia  e  Economia  (May, 
1976). 

 Na d√©cada de 1990, descobriu-se a possibilidade 
de  sincronizar  dois  sistemas  ca√≥ticos  id√™nticos  com 
condi√ß√µes  iniciais  diferentes,  com  aplica√ß√µes  em 
√°reas  como  telecomunica√ß√µes,  simula√ß√µes  e  cripto-
grafia (Pecora and Carroll, 1990). Desde ent√£o,  uma 
parte  da  comunidade  cient√≠fica  da  √°rea  de  sistemas 
ca√≥ticos dedica seus esfor√ßos no intuito de represen-
tar o comportamento ca√≥tico em sistemas eletr√¥nicos.  
As  implementa√ß√µes  de  sistemas  ca√≥ticos  utili-
zando-se circuitos est√£o sujeitas a fatores como tem-
peratura, umidade e envelhecimento de componentes 
que  s√£o  capazes  de  gerar  varia√ß√µes  nos  par√¢metros 
destes  sistemas.  Para  evitar  esse  tipo  de  problema, 
alguns  pesquisadores  passaram  a  utilizar  implemen-
ta√ß√µes digitais dos mesmos, as quais s√£o mais robus-
tas com rela√ß√£o a varia√ß√£o de par√¢metros. Dentre as 
implementa√ß√µes  em 
implementa√ß√µes  digitais,  as 
Field  Programmable  Gate  Array  (FPGA)  v√™m  sur-
gindo  como  uma  alternativa  competitiva,  uma  vez 
que  se  tratam  de  dispositivos  flex√≠veis  e  que  conso-
mem  baixas  quantidades  de  pot√™ncia  (Aseeri  et  al, 

2002).  Atratores  de  Chen  (Sadoudi  et  al,  2009),  L√º 
(Sadoudi  et  al,  2009)  e  Lorenz  (De  Micco  and  Lar-
rondo,  2011)  foram  implementados  por  meio  de  um 
FPGA. 

Estas implementa√ß√µes em meio digital v√™m sen-
do  estudadas  em  uma  grande  quantidade  de  traba-
lhos, tanto na constru√ß√£o de aplica√ß√µes em hardware 
quanto em simula√ß√µes computacionais. Por√©m, devi-
do  ao  fato  de  esses  sistemas  utilizarem  representa-
√ß√µes  num√©ricas  finitas  as  √≥rbitas  apresentadas  s√£o 
diferentes  das  obtidas  via  representa√ß√£o  matem√°tica 
infinita. Galias (2013) adverte sobre a necessidade de 
avaliar esses erros, e a propaga√ß√£o deles em fun√ß√µes 
recursivas  pode  ocasionar  em  uma  grande  perda  de 
confiabilidade em resultados de simula√ß√µes. Persohn 
& Povinelli (2016) alertaram sobre como desconside-
rar  as  limita√ß√µes  provenientes  de  representa√ß√µes 
finitas  em  aplica√ß√µes  de  criptografia  pode  levar  √† 
realiza√ß√£o  de  sistemas  inseguros.  Alguns  trabalhos, 
como Nepomuceno (2014) e Nepomuceno e Martins 
(2016),  apresentam  estrat√©gias  que  podem  ser  utili-
zadas para avaliar o quanto uma simula√ß√£o pode ser 
afetada  por  esses  tipos  de  erros,  criando  m√©todos 
atrav√©s dos quais pode-se rejeitar o resultado de uma 
simula√ß√£o ap√≥s certo ponto. 

Uma das poss√≠veis aplica√ß√µes de sistemas ca√≥ti-
cos  est√°  na  gera√ß√£o  de  n√∫meros  aleat√≥rios  e  cripto-
grafia (Dabal & Pelka, 2014), (Dabal & Pelka, 2011), 
(Pande  &  Zambreno,  2011).  Com  o  crescimento  do 
n√∫mero  de  aplica√ß√µes  em  sistemas  embarcados,  um 
aspecto  que  deseja-se  investigar  nesse  trabalho  √©  a 
obten√ß√£o de um sistema ca√≥tico realizado em FPGA 

que reduza consumo de energia e tempo realizado no 
processamento.  Nesse  sentido,  pretende-se  avaliar  o 
comportamento do mapa log√≠stico (May, 1976; Paiva 
et al, 2016), um dos mais conhecidos e investigados 
sistemas ca√≥ticos da literatura, utilizando um n√∫mero 
menor de bits, 32, do que o usual 64 e arquitetura de 
padr√£o  ponto  fixo,  ao  inv√©s  de  ponto  flutuante.  A 
representa√ß√£o em padr√£o ponto fixo em 32-bits apre-
senta  menor  utiliza√ß√£o  de  √°rea  e  baixo  consumo  de 
pot√™ncia.  Ser√°  analisada  a  resposta  dessa  arquitetura 
para  condi√ß√µes conhecidas na  literatura  por apresen-
tarem comportamentos ca√≥ticos utilizando dois dife-
rentes  modos  de  arredondamento  e  utilizando  o  ex-
poente de Lyapunov como m√©todo para verificar se o 
sistema  continua  a  apresentar  caos.  Todo  o  projeto 
foi  desenvolvido  utilizando  o  software  Quartus¬©  II 
17.0 Lite da Altera¬©, sendo todo realizado utilizando 
linguagem  de  descri√ß√£o  de  hardware  VHDL-93.  A 
arquitetura proposta ser√° simulada atrav√©s do softwa-
re ModelSim-Intel FPGA 10.5b. O software Matlab¬Æ 
foi utilizado para a elabora√ß√£o dos gr√°ficos compara-
tivos entre os diferentes resultados obtidos. A arqui-
tetura desenvolvida possui como vantagens o fato de 
ser  extremamente  flex√≠vel,  podendo  facilmente  ser 
modificada ou ter alguma melhoria adicionada, utili-
zar  uma  quantidade  baixa  de  recursos  de  hardware, 
permitir um total controle sobre o fluxo de informa-
√ß√£o  ao  longo  de  todas  as  opera√ß√µes  do  sistema  e 
representar  o  comportamento  ca√≥tico  do  Mapa  Lo-
g√≠stico  em  uma  representa√ß√£o  de  32  bits  em  Padr√£o 
Ponto  Fixo,  ao  inv√©s  de  usar  as  representa√ß√µes  em 
Ponto Flutuante de 64 bits utilizadas nas arquiteturas 
de processadores atuais e que consomem uma maior 
quantidade de √°rea e pot√™ncia. 

2   Conceitos preliminares 

2.1 Mapa Log√≠stico  

O  mapa  log√≠stico  √©  uma  fun√ß√£o  recursiva  que, 
para uma condi√ß√£o inicial ùë•0, fornece uma sequ√™ncia 
num√©rica de sa√≠da de acordo com  

ùë•ùëõ+1 = ùëüùë•ùëõ(1 ‚àí ùë•ùëõ) 

(1) 

em  que  ùëõ  ‚àà ‚Ñµ  e ùë•ùëõ  e  ùëü  ‚àà ùëÖ,  de  tal  forma  que 0 ‚â§
ùë•ùëõ ‚â§ 1 e 0 < ùëü ‚â§ 4 (May, 1976). √Ä medida que ùëü se 
aproxima  de  4  o  comportamento  do  sistema  vai  se 
tornando  ca√≥tico.  Diferentes  condicionamentos  de 
(1), isto √©, formula√ß√µes  matematicamente equivalen-
tes,  e  formas  diferentes  de  arredondamento  podem 
levar a sequ√™ncias num√©ricas diferentes para mesmos 
valores de ùëü e ùë•0 em representa√ß√µes finitas (Paiva et 
al,  2016).  A  equa√ß√£o  (1)  ser√°  implementada  a  partir 
de uma unidade que realiza o produto dos resultados 
das opera√ß√µes (1 ‚àí ùë•ùëõ) e (ùëüùë•ùëõ), realizadas em para-
lelo.  O  hardware  possui  configura√ß√£o  que  suporta 
truncamento e arredondamento para o +‚àû. Todas as 
opera√ß√µes ser√£o realizadas em Padr√£o Ponto Fixo 32-
bits.  

2.2 Expoentes de Lyapunov 

O expoente de Lyapunov √© um n√∫mero utilizado 
para  analisar  a  sensibilidade  de  um  sistema  √†s  suas 
condi√ß√µes iniciais. O c√°lculo do expoente de  Lyapu-
nov para uma fun√ß√£o em tempo discreto √© dado pela 
por 

ùúÜ =

1
ùëÅ

ùëÅ‚àí1
‚àë|ln ùëì‚Ä≤(ùë•ùëõ)|
ùëñ=0

(2) 

onde  ùëÅ  √©  a  quantidade  de  elementos  calculados 
para a s√©rie ùëì(ùë•ùëõ), e ùëì‚Ä≤(ùë•ùëõ) √© a primeira derivada da 
fun√ß√£o que representa a s√©rie. Para o Mapa Log√≠stico, 
tem-se que ùëì(ùë•ùëõ) √© dado pela equa√ß√£o (1) e ùëì‚Ä≤(ùë•ùëõ) √© 
dado pela equa√ß√£o (3). 

ùëì‚Ä≤(ùë•ùëõ) = ùëü(1 ‚àí 2ùë•ùëõ) 

(3) 

O  valor  de  ùëü  ir√° determinar  o expoente  de  Lya-
punov do Mapa Log√≠stico. Para os casos em que ùúÜ >
0,  os  pontos  da  sequ√™ncia  se  afastam  exponencial-
mente  da  condi√ß√£o  inicial,  o  que  indica  comporta-
mento ca√≥tico (Monteiro, 2006) . 

2.3 Field Programmable Gate Arrays 

Os Field Programmable Gate Array (FPGA) s√£o 
dispositivos baseados em  um arranjo contendo c√©lu-
las  l√≥gicas  e  uma  rede  de  interconex√£o  que  podem 
ser  configurados  para  realizar  fun√ß√µes  espec√≠ficas, 
cujas  combina√ß√µes  podem  sintetizar  projetos  com 
alto  n√≠vel  de  complexidade.  Essa  configura√ß√£o  ge-
ralmente  √©  feita  atrav√©s  do  uso  de  HDLs  (hardware 
description  languages).  Muitos  desses  dispositivos 
possuem blocos de mem√≥ria e circuitos multiplicado-
res embarcados. Nos √∫ltimos anos, os FPGAs aumen-
taram  muito  em  capacidade, podendo  conter  bilh√µes 
de  transistores.  Devido  √†  sua  flexibilidade  e  a  esse 
aumento  de  capacidade  muitos  projetistas  v√™m  ado-
tando  os  FPGAs  em  seus  projetos,  uma  vez  que  os 
mesmos permitem a s√≠ntese de circuitos complexos a 
custos baixos e em curtos espa√ßos de tempos, atrav√©s 
do uso de softwares CAD oferecidos por fabricantes 
como a Altera¬© e a Xilinx¬© (Hamacher et al, 2012). 

2.4 Ferramentas de programa√ß√£o e simula√ß√£o volta-
das para projetos em FPGA 

Desenvolver projetos para FPGA √© um processo 
que  demanda  transforma√ß√µes  e  algoritmos  de  otimi-
za√ß√£o  complexos.  Com  o  intuito  de  automatizar  al-
guns passos dessa tarefa, softwares com ferramentas 
espec√≠ficas foram desenvolvidos pelos fabricantes de 
FPGA.  O  Quartus  II¬©  √©  um  software  desenvolvido 
pela  Altera¬©,  o  qual  cont√©m  uma  cole√ß√£o  de  ferra-
mentas  voltadas  para  projetos  em  FPGA.  Dentre  as 
fun√ß√µes  que  podem  ser  realizadas  por  meio  dele 
pode-se  destacar  a  constru√ß√£o  de  projetos  e  c√≥digos 
com  descri√ß√£o  em  HDL,  cria√ß√£o  de  modelos  para 
simula√ß√£o,  an√°lise  de  restri√ß√µes  temporais,  compila-

 
 
 
 
 
 
 
 
 
 
 
 
√ß√£o  do  projeto  e  configura√ß√£o  f√≠sica  do  FPGA.  O 
ModelSim-Intel  FPGA  10.5b  √©  um  software  desen-
volvido pela MentorGraphics¬© cujo intuito √© realizar 
simula√ß√µes de descri√ß√µes em HDL. Estas simula√ß√µes 
permitem  verificar  se  o  hardware  descrito  funciona 
apropriadamente, atingindo os requerimentos especi-
ficados (Chu, 2011). 

3   Metodologia 

A  seguir,  a  metodologia  abordada  no  projeto  √© 
apresentada  em  quatro  subse√ß√µes,  sendo  que  as  tr√™s 
primeiras  apresentam  a  implementa√ß√£o  em  FPGA  e 
na √∫ltima os m√©todos de avalia√ß√£o dos resultados. O 
hardware  desenvolvido  foi  dividido  em  duas  unida-
des  b√°sicas:  Uma  unidade  de  controle,  formada  por 
um contador de itera√ß√µes e uma  m√°quina de estados 
finitos,  e  uma  unidade  operativa  que  implementa  a 
equa√ß√£o  (1).  Todas  as  opera√ß√µes  s√£o  realizadas  em 
Padr√£o Ponto Fixo de 32 bits, onde s√£o utilizados 16 
bits para a parte inteira e 16 bits para a parte fracio-
n√°ria.  O  hardware  possui  configura√ß√£o  que  suporta 
truncamento e arredondamento para o +‚àû. 

3.1 Unidade Operativa do Mapa Log√≠stico 

A parte principal da implementa√ß√£o em FPGA √© 
mostrada na Figura 1. Nela temos uma unidade ope-
racional  principal  denominada  UOML  (Unidade 
Operativa  do  Mapa  Log√≠stico).  O  principal  objetivo 
dessa  unidade  √©  efetuar  as  opera√ß√µes  em  (1).  Essa 
unidade  cont√©m  sinais  que  indicam  ocorr√™ncia  de 
overflow  e  underflow,  o_over  e  o_under  respectiva-
mente e o  sinal o_done, que indica  quando uma ite-
ra√ß√£o completa de (1) √© calculada.  As entradas ùëñ_ùëü e 
ùëñ_ùë•ùëõ‚àí1,  recebem  o  coeficiente  ùëü  da  equa√ß√£o  (1)  e  o 
valor mais atualizado da sequ√™ncia num√©rica, respec-
tivamente. A entrada i_round √© respons√°vel por fixar 
o  modo  de  arredondamento  utilizado  pelo  sistema, 
sendo ‚Äò1‚Äô para arredondamento para o +‚àû positivo e 
‚Äò0‚Äô  para  truncamento.  O  sinal  denominado  i_ready 
habilita  o  in√≠cio  da  opera√ß√£o  do  bloco,  sendo  este 
controlado  por  uma  m√°quina  de  estados  finitos.  Na 
Figura  1,  tamb√©m  √©  mostrado  o  registrador  Xn,  que 
tem  como  fun√ß√£o  armazenar  o  valor  atual  de  sa√≠da, 
o_xn e realizar a realimenta√ß√£o para a pr√≥xima itera-
√ß√£o da UOML. A implementa√ß√£o conta tamb√©m com 
uma  estrutura  de  roteamento  por  multiplexa√ß√£o, 
composta pelos elementos MUX1 e MUX2, os quais 
s√£o  controlados  atrav√©s  dos  estados  da  unidade  de 
controle  e  pelo  sinal  o_done,  sendo  esta  estrutura 
respons√°vel por variar os valores na entrada do regis-
trador Xn. Os sinais i_clk e i_rst representam o clock 
do  sistema  e  uma  entrada  reset  ass√≠ncrona,  respecti-
vamente. A cada novo c√°lculo realizado pela UOML 
a sua entrada ùëñ_ùë•ùëõ‚àí1 √© atualizada com o valor calcu-
lado  em  sua  itera√ß√£o  anterior,  correspondente  ao 
valor mais recente armazenado no registrador Xn. 

Figura 1: Arquitetura da implementa√ß√£o em FPGA 

3.2 Unidade de Multiplica√ß√£o e Convers√£o 

A  multiplica√ß√£o  aritm√©tica  entre  dois  n√∫meros 
bin√°rios,  com  A  e  B  bits,  respectivamente,  ir√°  gerar 
um resultado com A + B bits (Hamacher et al, 2012). 
Para  um  sistema  que  realiza  a  multiplica√ß√£o  de  dois 
n√∫meros  com  32  bits  o  resultado  ter√°  64  bits.  Isso 
n√£o  √©  desej√°vel  para  um  sistema  que  realiza  opera-
√ß√µes em 32 bits e que est√° fazendo constante reuso de 
resultados de outras opera√ß√µes e itera√ß√µes anteriores. 
Para evitar isso, foi adicionado uma unidade de con-
vers√£o  de  64  para  32  bits  em  s√©rie  com  cada  opera-
√ß√£o de multiplica√ß√£o. Essa unidade possui uma l√≥gi-
ca  combinacional  cujo  objetivo  √©  gerar  sinais  que 
indiquem presen√ßa de overflow ou underflow durante 
a convers√£o. Caso haja  overflow  o n√∫mero converti-
do  ser√°  saturado  e  se  houver  underflow  a  convers√£o 
resultar√°  em  zero.  Para  melhor  uso  dos  recursos  da 
placa,  que  possui  multiplicadores  embarcados  de  9-
bits,  as  multiplica√ß√µes  foram  realizadas  atrav√©s  da 
decomposi√ß√£o  dos  n√∫meros  de  32  bits  em  partes 
iguais  de  16  bits,  cujos  produtos  foram  computados 
em  paralelo  por  pipeline.  Essa  configura√ß√£o  utiliza 
mais  multiplicadores,  por√©m  melhora  a  performance 
do  sistema  com  rela√ß√£o  √†  frequ√™ncia  m√°xima  de 
opera√ß√£o.  Essas  unidades  multiplicadoras  em  s√©rie 
com  os  conversores  s√£o  chamadas  de  Unidades  de 
Multiplica√ß√£o  e  Convers√£o.  A  UOML  possui  duas 
dessas unidades. 

3.3 Unidade de Controle 

Al√©m  da  UOML,  h√°  tamb√©m  uma  unidade  de 
controle  constitu√≠da  por  uma  m√°quina  de  estados 
finitos, cujo fluxograma √© apresentado na Figura 3, e 
um contador de 11 bits, cujo objetivo √© determinar a 
quantidade  de  itera√ß√µes  do  Mapa  Log√≠stico  a  serem 
realizadas,  variando  de  0  a  2047.  A  m√°quina  possui 
quatro  diferentes  estados:  idle,  op,  done_it  e  do-
ne_all.  A  Figura  2  mostra  todos  os  estados,  bem 
como todos os processos, decis√µes e transi√ß√µes rela-
tivos a cada um.  Os ret√¢ngulos escuros representam 
os  estados,  enquanto  os  mais  claros  representam 
processos  e  os  losangos  se  relacionam  √†s  decis√µes. 
As transi√ß√µes s√£o representadas pelas setas. 

 
 
 
 
 
 
 
 
 
os casos analisados, de acordo com a equa√ß√£o (2), e 
os mesmos ser√£o comparados com valores j√° conhe-
cidos  da  literatura.    A  frequ√™ncia  m√°xima  de  opera-
√ß√£o  do  hardware  foi  comparada  com  outras  imple-
menta√ß√µes presentes na literatura. 

4 Resultados 

Para realizar os testes com o hardware proposto-
foram adotados os valores ùëü = 4   e  ùë•0 = 0,1. O sis-
tema  foi  configurado  para  realizar  150  itera√ß√µes. 
Primeiramente,  o  projeto  foi  compilado  utilizando  o 
software Quartus II¬©17.0 Lite da Altera¬©. A Tabela 
1 mostra a utiliza√ß√£o de recursos f√≠sicos e a frequ√™n-
cia  de  opera√ß√£o  m√°xima  do  hardware,  tomando  co-
mo  base  o  FPGA  Cyclone  IV  EP4CE115F29C7, 
presente  na  placa  DE2-115.  Pode-se  perceber  que  a 
quantidade  de  recursos  utilizada  √©  apenas  uma  pe-
quena  por√ß√£o  dos  que  est√£o  dispon√≠veis  no  FPGA. 
Com  rela√ß√£o  √†s  restri√ß√µes  temporais  o  hardware 
proposto  n√£o  apresentaria  problemas  ao  ser  imple-
mentado na placa, uma vez que a frequ√™ncia m√°xima 
de  opera√ß√£o  √©  de  166,83  MHz,  maior  que  a  de  50 
MHz dispon√≠vel na placa.  

Tabela 1 ‚Äì Informa√ß√µes sobre o consumo de recursos e 

frequ√™ncia m√°xima de opera√ß√£o do hardware proposto. 
Recursos 
da Placa 
114480 
532 

Consumo do 
hardware 
1471 
16 

Elementos l√≥gicos 
Multiplicadores de 9-
bits 
Registradores  
Frequ√™ncia m√°xima de 
opera√ß√£o 
Bits de mem√≥ria 
Consumo de pot√™ncia 

1358 
166,83 MHz 

114480 
50 MHz 

320 

3981312 

171,47mW 

A Tabela 2 mostra um comparativo entre as fre-
qu√™ncias  m√°ximas  de  opera√ß√£o  obtidas  em  imple-
menta√ß√µes  presentes  na  literatura  e  a  obtida  neste 
trabalho,  junto  com  o  n√∫mero  de  bits  utilizados  por 
cada uma em Padr√£o Ponto Fixo. O presente trabalho 
foi desenvolvido em uma placa da Altera¬©, enquanto 
os  demais  foram  desenvolvidos  em  placas  da  Xi-
linx¬©.  Uma  vez  que  a  organiza√ß√£o  interna  dos 
FPGAs  desses  fabricantes  s√£o  diferentes  n√£o  foram 
feitas compara√ß√µes com rela√ß√£o aos recursos utiliza-
dos  pelas  implementa√ß√µes.  Atrav√©s  da  Tabela  2, 
pode-se  perceber  que  a  implementa√ß√£o  do  trabalho 
atual  √©  competitiva  com  rela√ß√£o  √†s  demais,  por√©m 
ainda  pode  ser  melhorada  com  rela√ß√£o  √†  precis√£o, 
uma  vez  que  (Dabal  &  Pelka,  2014)  e  (Pande  & 
Zambreno,  2011)  utilizam  64  bits,  e  com  rela√ß√£o  √† 
frequ√™ncia m√°xima de opera√ß√£o, uma vez que (Dabal 
&  Pelka,  2014)  conseguiram  um  valor  maior  que  o 
apresentado no presente trabalho. 

Tabela 2 ‚Äì Compara√ß√£o entre frequ√™ncias m√°ximas de 
opera√ß√£o de diferentes implementa√ß√µes presentes na literatu-
ra. 

Figura 2: Fluxograma da m√°quina de estados finitos. 

Durante  o  estado  idle,  a  m√°quina  se  encontra 
inativa, esperando um sinal de entrada de start apre-
sentar um n√≠vel l√≥gico ‚Äò1‚Äô. Nesse estado o registrador 
Xn  est√°  conectado  √†  condi√ß√£o  inicial ùë•0,  enquanto  o 
contador  counter  e  o  sinal  ready  est√£o  zerados.  O 
sinal ready est√° ligado √† entrada i_ready da UOML. 
Uma vez que o a condi√ß√£o start = ‚Äò1‚Äô √© satisfeita, h√° 
a transi√ß√£o para o estado op. 

No estado op √© realizada a opera√ß√£o da UOML. 
Caso  o  contador  atinja  seu  valor  m√°ximo  pr√©-
estabelecido, It_Max, ocorre a transi√ß√£o para o estado 
done_all.  Uma  vez  que  o  contador  ainda  n√£o  tenha 
alcan√ßado  seu  valor  m√°ximo,  toda  vez  que  ocorrer 
um  pulso  do  sinal  o_done,  que  indica  quando  a 
UOML terminou sua opera√ß√£o, o registrador  Xn ser√° 
conectado  ao  mais  recente  valor  calculado  pela 
UOML e a m√°quina ir√° para o estado done_it. 

O  estado  done_it  serve  somente  para  realizar  a 
transi√ß√£o entre duas itera√ß√µes consecutivas. No esta-
do  done_all  √©  gerado  um  pulso  de  meio  ciclo  de 
clock indicando que todas as itera√ß√µes est√£o comple-
tas, seguido por uma transi√ß√£o ao estado idle. 

3.4 Avalia√ß√£o do hardware proposto 

O hardware proposto foi avaliado em termos da 
utiliza√ß√£o de  recursos do FPGA,  frequ√™ncia  m√°xima 
de opera√ß√£o e consumo de pot√™ncia, os quais podem 
ser obtidos atrav√©s do software  Quartus II¬©, atrav√©s 
de  gr√°ficos  contendo  as  formas  de  onda  dos  sinais 
mais  importantes  do  sistema,  obtidos  via  simula√ß√£o 
em  VHDL-93  utilizando  o  software  ModelSim¬©,  e 
an√°lise de um gr√°fico com a s√©rie temporal obtido via 
Matlab¬Æ  utilizando  dados  exportados  pela  simula-
√ß√£o. Ser√£o calculados os expoentes de Lyapunov para 

 
 
 
 
 
 
 
Trabalho analisado 

Atual 
(Dabal & Pelka, 2011) 
(Dabal & Pelka, 2014) 
(Pande & Zambreno, 
2011) 

Frequ√™ncia 
m√°xima de 
Opera√ß√£o 
166,83 MHz 
76,1 MHz 
233 MHz 
93 MHz 

N√∫mero 
de Bits 

32 
32 
64 
64 

Ap√≥s a compila√ß√£o do  projeto, foram realizadas 
duas  simula√ß√µes  utilizando  o  software  ModelSim-
Intel FPGA 10.5b. A primeira simula√ß√£o foi realiza-
da  utilizando  modo  de  arredondamento  para  o  +‚àû, 
enquanto  a  segunda  utilizou  do  truncamento.  As 
simula√ß√µes  geraram  sa√≠das  sob  a  forma  de  arquivos 
de texto contendo informa√ß√µes relativas √†s 150 itera-
√ß√µes adotadas. Esses arquivos foram processados via 
Matlab¬Æ, fornecendo as sa√≠das gr√°ficas presentes nas 
Figuras 3 e  4, as quais comparam as sequ√™ncias nu-
m√©ricas  para  ambos  os  casos.  A  Figura  3  avalia  as 
primeiras  50  itera√ß√µes,  ficando  √≥bvio  que  ap√≥s  20 
itera√ß√µes  as  duas  √≥rbitas  j√°  come√ßam  a  apresentar 
consider√°veis  diferen√ßas,  o  que  pode  ser  explicado 
pela  grande  sensibilidade  desses  sistemas  a  uma 
pequena  varia√ß√£o  dos  par√¢metros  causada  por  dife-
ren√ßa  nos  modos  de  arredondamento.  Na  Figura  4, 
onde  s√£o  mostradas  150  itera√ß√µes,  fica  ainda  mais 
n√≠tida a influ√™ncia do modo de arredondamento. 

Figura 3: S√©rie temporal para as primeiras 50 itera√ß√µes. 

ta em (Mendes e Nepomuceno, 2016) que permite o 
c√°lculo com um n√∫mero menor de dados e √© robusta 
quanto  ao  uso  de  n√∫meros  de  bits  inferior  a  64.  Os 
expoentes  foram  calculados  para  ùëÅ = 150.  Anali-
sando-se  a  tabela  pode-se  perceber  que  os  valores 
para ambas as  s√©ries se aproximam do valor espera-
do, logo o sistema reproduz o comportamento ca√≥ti-
co do Mapa Log√≠stico. 

Tabela 3 ‚Äì Compara√ß√£o entre o expoente de Lyapunov 

esperado pela literatura e os calculados atrav√©s das s√©ries 
obtidas. 

Caso analisado 

Literatura 
S√©rie com arredondamento 
S√©rie com truncamento 

Expoente de Lya-
punov 
0,6931 
0,6979 
0,7031 

5   Conclus√£o 

Neste  artigo,  √©  apresentada  a implementa√ß√£o  do 
Mapa Log√≠stico em FPGA de modo a ilustrar a pos-
sibilidade  de  implementa√ß√£o  de  sistemas  que  apre-
sentam  din√¢mica  ca√≥tica  em  sistemas  digitais.  √â 
apresentada  a  implementa√ß√£o  da  equa√ß√£o  (1)  para 
m√©todos  de  tratamento  de  casas  decimais,  arredon-
damento e truncamento. Os resultados  mostram, por 
meio  do  expoente  de  Lyapunov,  que  a  implementa-
√ß√£o  em  FPGA  mostra  a  din√¢mica  ca√≥tica  esperada 
pelo Mapa Log√≠stico. Para cada m√©todo de represen-
ta√ß√£o  das  casas  a  s√©rie  converge  diferentemente  ao 
longo do tempo, devido √† sensibilidade dos sistemas 
ca√≥ticos  √†s  varia√ß√µes  param√©tricas.  A  arquitetura 
possui  como  vantagens  o  fato  de  consumir  uma 
quantidade  baixa  dos  recursos  de  hardware,  consu-
mindo pouco mais que 1% dos elementos l√≥gicos do 
FPGA utilizado, ser extremamente flex√≠vel, podendo 
facilmente  ser  modificada  ou  melhorada,  e  permitir 
ao  projetista  um  total  controle  sobre  o  fluxo  de  in-
forma√ß√µes ao longo de todo o sistema. Para o futuro, 
espera-se  expandir  a  realiza√ß√£o  do  Mapa  Log√≠stico 
em  FPGAs  utilizando  outras  precis√µes  num√©ricas  e 
diferentes  condicionamentos  da  equa√ß√£o,  realizar  a 
comunica√ß√£o  da  arquitetura  com  outros  dispositivos 
e testar aplica√ß√µes pr√°ticas como a gera√ß√£o de n√∫me-
ros pseudoaleat√≥rios. 

Agradecimentos 

Figura 4: S√©rie temporal para as primeiras 150 itera√ß√µes. 

Os  autores  agradecem  o  apoio  financeiro  das  ag√™n-
cias Fapemig, Capes e CNPq. 

A  Tabela  3  mostra  os  expoentes  de  Lyapunov 
para os casos analisados. Para o caso em que  ùëü = 4, 
o  expoente  de  Lyapunov  tende  a  ln 2,  que  √©  aproxi-
madamente  igual  a 0,6931.  Para  o  c√°lculo  do  expo-
ente de Lyapunov foi utilizada a metodologia propos-

Refer√™ncias Bibliogr√°ficas 

Aseeri,  M.  A.,  Sobhi,  M.  I.  and  Lee,  P  (2002).  Lo-
renz  Chaotic  Model  using  Field  Programmable 
Gate Array, Midwest Symposium on Circuit and 
Systems. 

 
 
 
 
 
 
 
 
 
 
 
 
 
Sadoudi, S., Assaz, M. S., Djeddou, M. and Benssa-
lah, M (2009). An FPGA Real-time implementa-
tion  of  the  Chen‚Äôs  chaotic  system  for  securing 
chaotic communications, International Journal of 
Nonlinear  Science,  Vol.  7  (2009),  No.  4,  pp. 
467-474. 

Sadoudi, S., Tanougast, C., Assaz, M. S., Dadanche, 
A  (2009).  Real-time  implementation  of  L√º‚Äôs 
chaotic  generation  for  Cipher  Embedded  Sys-
tems,  International  Symposium  of  Signals,  Cir-
cuits and Sytems, 1-4. 

Chu,  P.  P  (2011).  Embedded  SOPC  Design  with 
NIOS  II  processor  and  VHDL  Examples,  John 
Wiley & Sons, Hoboken, New Jersey, USA. 
Dabal, P. and Pelka, R. (2011). A chaos-based pseu-
do-random  bit  generator  implemented  in  FPGA 
device, 14th International Symposium on Design 
and  Diagnostics  of  Electronic  Circuits  &  Sys-
tems, 151-154. 

Dabal, P. and Pelka, R. (2014). A study on fast pipe-
lined pseudo-random generator based on chaotic 
logistic  map,  17th  International  Symposium  on 
Design and Diagnostics of Electronic Circuits & 
Systems, 195-200. 

De  Micco,  L.  and  Larrondo,  H.  A  (2011).  FPGA 
Implementation  of  a  chaotic  oscillator  using 
RK4-Method,  VII  Southern  Conference  on  Pro-
grammable Logic, 185-190. 

Galias, Z (2013). The dangers of rounding errors for 
simulations  and  analysis  of  nonlinear  circuits 
and systems - and how avoid them, IEEE Trans-
actions on circuits and Systems Magazine, 13(3), 
35-52. 

Hamacher, C., Vranesic, Z., Zaky, S. and Manjikian, 
N  (2012).  Computer  Organization  and  Embed-
ded  Systems,  6th  Edition,  The  McGraw-Hiill 
Companies, New York, USA. 

Nepomuceno,  E.  G.  and  Martins,  S.  A  (2016).  A 
lower bound error for free-run simulation of the 
polynomial  NARMAX,  Systems  Science  & 
Control Engineering, 4:1, 50-58. 

Nepomuceno,  E.  G.  (2014).  Convergence  of  recur-
sive functions on computers, The Journal of En-
gineering pp. 1-3. 

May,  R.  M.  (1976).  Simple  mathematical  models 
with  very  complicated  dynamics,  The  Journal 
Nature (261): 459-467. 

Mendes, E. M. A. M. and Nepomuceno E. G (2016). 
A very simple method to calculate the (positive) 
Largest  Lyapunov  Exponent  using  interval  ex-
tensions, International Journal of Bifurcation and 
Chaos, December 2016, Vol. 26, No. 13. 

Monteiro,  L.  H.  A  (2006).  Sistemas  Din√¢micos,  2¬™ 
ed, Editora Livraria da F√≠sica, S√£o Paulo, SP. 
Paiva, B. P. O., Nepomuceno, E. G. and Amaral, G. 
F. V (2016). Considera√ß√µes sobre a influ√™ncia do 
condicionamento  e  do  arredondamento  na  ob-
ten√ß√£o de S√©ries Temporais da Equa√ß√£o Log√≠sti-
ca,  In  Anais  do  CBA  2016  ‚Äì  XXI  Congresso 
Brasileiro de Autom√°tica. 

Pande, A. and Zambreno, J (2011). A chaotic encryp-
tion  scheme  for  real-time  embedded  systems: 
design  and  implementation,  Telecommunication 
Systems, 2011. 

Pecora, L. M. and Carroll, T. L (1990). Synchroniza-
tion in chaotic systems, Phys. Rev. Lett., vol. 64, 
no.8, pp. 821-824. 

Persohn, K. J. and Povinelli,  R. J (2016). Analyzing 
logistic  map  pseudorandom  number  generators 
for periodicity induced by finite precision float-
ing point representation, Chaos, Solitons & Frac-
tals (45): 238-245. 

 
 
