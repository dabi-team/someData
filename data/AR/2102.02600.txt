Springer Nature 2021 LATEX template

2
2
0
2

g
u
A
0
3

]

O
L
.
s
c
[

4
v
0
0
6
2
0
.
2
0
1
2
:
v
i
X
r
a

A formalization of Dedekind domains and
class groups of global ﬁelds

Anne Baanen1*, Sander R. Dahmen2, Ashvni Narayanan3
and Filippo A. E. Nuccio Mortarino Majno di Capriglio4
1Department of Computer Science, Vrije Universiteit
Amsterdam, Amsterdam, The Netherlands.
2Department of Mathematics, Vrije Universiteit Amsterdam,
Amsterdam, The Netherlands.
3London School of Geometry and Number Theory, London,
United Kingdom.
4Univ Lyon, Universit´e Jean Monnet Saint-´Etienne, CNRS UMR
5208, Institut Camille Jordan, F-42023 Saint-´Etienne, France.

*Corresponding author(s). E-mail(s): t.baanen@vu.nl;
Contributing authors: s.r.dahmen@vu.nl;
a.narayanan20@imperial.ac.uk; ﬁlippo.nuccio@univ-st-etienne.fr;

Abstract

Dedekind domains and their class groups are notions in commutative
algebra that are essential in algebraic number theory. We formalized
these structures and several fundamental properties, including number
theoretic ﬁniteness results for class groups, in the Lean prover as part
of the mathlib mathematical library. This paper describes the formaliza-
tion process, noting the idioms we found useful in our development and
mathlib’s decentralized collaboration processes involved in this project.

1 Introduction

In its basic form, number theory studies properties of the integers Z and its
fraction ﬁeld, the rational numbers Q. For the sake of generalization, as well
as for providing powerful techniques to answer questions about the original

1

 
 
 
 
 
 
Springer Nature 2021 LATEX template

2

Dedekind domains and class groups

objects Z and Q, it is worthwhile to study ﬁnite extensions of Q, called number
ﬁelds, as well as their rings of integers (Section 2), whose relations mirror the
way Q contains Z as a subring. In this paper, we describe our project aiming
at formalizing these notions and some of their important properties. Our goal
is not to get to the deﬁnitions and properties as quickly as possible; rather,
we lay the foundations for future work, as part of a natural and more general
theory.

In particular, our project resulted in formalized deﬁnitions and elementary
properties of number ﬁelds and their rings of integers (Section 4.3), Dedekind
domains (Section 5), and the ideal class group and class number (Section 8).
Apart from the very basics concerning number ﬁelds, these concepts were not
formalized before as far as we know. We note that a formal deﬁnition of the
class number is an essential requirement for the use of theorem provers in
modern number theory research. The main proofs that we formalized show
that two deﬁnitions of Dedekind domains are equivalent (Section 5.3), that
the ring of integers of a number ﬁeld is a Dedekind domain (Section 7) and
that the class group of the ring of integers of a number ﬁeld is ﬁnite (Section
8). In fact, most of our results for number ﬁelds are also obtained in the more
general setting of global ﬁelds.

Our work is developed as part of the mathematical library mathlib [1] for
the Lean 3 theorem prover [2]. The formal system of Lean is a dependent type
theory augmented with quotient types and classical reasoning, both of which
are commonly used in mathlib (Section 3). As we ﬁnished parts of our work, we
contributed these to mathlib. We, in turn, used results contributed by others
after the start of the project. At several points, we had just merged a for-
malization into mathlib that another contributor needed, immediately before
they contributed a result that we needed. Due to the decentralized organiza-
tion and ﬂuid nature of contributions to mathlib, its contents are built up of
many diﬀerent contributions from over 250 diﬀerent authors. Attributing each
formalization to a single set of main authors would not do justice to all others
whose additions and tweaks are essential to its current use. Therefore, we will
make clear whether a contribution is part of our project or not, but we will
not stress who we consider to be the main authors.

The source ﬁles of the formalization have been contributed to mathlib. We
have preserved the development branch that this paper is based on1. We also
maintain a repository2 containing the source code referred to in this paper.

This paper is an extended version of a paper published in the ITP 2021
conference proceedings [3]. The additions to this paper, apart from several
clariﬁcations and enhancements throughout the text, mainly concern the
following.

• Code samples throughout have been updated to reﬂect parts of our for-
malization contributed to mathlib after the previous publication and to
incorporate changes in mathlib after contribution.

1https://github.com/leanprover-community/mathlib/tree/dedekind-domain-dev
2https://github.com/lean-forward/class-number-journal

Springer Nature 2021 LATEX template

Dedekind domains and class groups

3

• Instead of only considering class groups of Dedekind domains, we brieﬂy
describe class groups for general domains; see the end of Section 2 and
Section 8.1.

• The new Section 3 gives a more detailed explanation of Lean as used in

mathlib, in particular the use of typeclasses and bundling.

• We discuss deﬁnitional equality in Lean in the context of overlapping

typeclass instances in Section 4.1.

• The further evolution of fraction rings in mathlib is discussed at the end of

Section 4.5.

• We elaborate on invertibility and unique factorization of ideals in Dedekind

domains in Sections 5.2 and 5.4.

• We give more details on the proof of ﬁniteness of the class group and its

formalization in Section 8.2.

• We elaborate on future directions in Section 9.2, including research relying

on the formalization described here.

2 Mathematical background

Let us now introduce some of the main objects we study, described informally.
We assume some familiarity with basic ring and ﬁeld theory.

∈

∈
Z is not a square. Similarly, adding a cubic root 3√d of some d

A number ﬁeld K is a ﬁnite extension of the ﬁeld Q, and as such has the
structure of a ﬁnite dimensional vector space over Q; its dimension is called
the degree of K. The easiest example is Q itself, and the two-dimensional
cases are given by the quadratic number ﬁelds Q(√d) =
Q
}
Z
where d
which is not a cube leads to the number ﬁeld Q( 3√d): it has degree 3 but not
all cubic number ﬁelds arise in this way. An example of a cubic number ﬁeld
that is not of this form, and that will occupy us later for other interesting
features, is Q(α0) =
, where α0 is the unique real
0 : a, b, c
{
0 + α2
number satisfying α3
2α0 + 8 = 0. In general, taking any root α of an
irreducible polynomial of degree n over Q yields a number ﬁeld of degree n,
1αn
namely Q(α) =
, and, up to
isomorphism, all number ﬁelds of degree n arise in this way.

c0 + c1α + . . . + cn

1 : c0, c1, . . . , cn

a + bα0 + cα2

a + b√d : a, b

1 ∈

0 −

Q

Q

∈

∈

{

{

}

}

−

−

−

The ring of integers
closure of Z in K, namely

OK of a number ﬁeld K is deﬁned as the integral

OK :=

x

{

∈

K : f (x) = 0 where f

Z[x] is a monic polynomial
}

,

∈

where we recall that a polynomial is called monic if its leading coeﬃcient
OK is a ring, this
equals 1. While it might not be immediately obvious that
follows from general algebraic properties of integral closures. Some examples
OK = Z back.
of rings of integers are the following. Taking K = Q, we get
For K = Q(i) = Q(√
1) we get that
OK is the ring of Gaussian integers
−
. But for K = Q(√5) we do not simply get Z[√5] =
Z
Z[i] =
}
{
∈
Z[√5]
OK, since the golden ratio ϕ := (1 + √5)/2
a + b√5 : a, b
as
{
}
satisﬁes the monic polynomial equation ϕ2
1 = 0; hence by deﬁnition,
ϕ
−

a + bi : a, b
Z

−

∈

6∈

Springer Nature 2021 LATEX template

4

Dedekind domains and class groups

−

{

∈

Z

−

properties still hold in

a + bϕ : a, b
∈
}
a+ bα0 + c(α0 + α2
0)/2 : a, b, c

OK = Z[ϕ] =
ϕ
∈ OK. It turns out that
. Finally, if
K = Q(α0) with α0 as before, then
Z
OK =
,
{
}
illustrating that explicitly writing down
OK can quickly become complicated.
Further well-known rings of integers are the Eisenstein integers Z[(1+√
3)/2]
and the ring Z[√2].
Thinking of

OK as a generalization of Z, it is natural to ask which of its
OK and, when this fails, if a reasonable weakening does.
An important property of Z is that it is a principal ideal domain (PID),
meaning that every ideal is generated by one element. This implies that every
nonzero nonunit element can be written as a ﬁnite product of prime elements,
which is unique up to reordering and multiplying by
1. A ring where this
holds is called a unique factorization domain, or UFD. For example, 6 can be
3) =
factored in primes in 4 equivalent ways, namely 6 = 2
(
2). In fact, the previously mentioned examples of rings of integers
−
are UFDs, but this is certainly not true for all rings of integers. For example,
unique factorization does not hold in
5] : it is easy to prove
5) provide two essentially diﬀerent3
3 and 6 = (1 + √
that 6 = 2
ways to factor 6 into prime elements of Z[√

OQ(√
√
−

5) = Z[√

3 = 3

2 = (

(
−

(
−

5)(1

5].

3)

2)

−

±

−

−

−

−

·

·

·

·

·

As it turns out, there is a way to weaken this notion of unique factorization
in a meaningful way. Namely, by considering factorization of ideals instead
OK, a beautiful
of elements; given a number ﬁeld K, with ring of integers
and classical result by Dedekind shows that every nonzero ideal of
OK can be
factored as a product of prime ideals in a unique way, up to reordering.
Although unique factorization in terms of ideals is of great importance,
it is still interesting, and sometimes necessary, to also consider factorization
properties in terms of elements. We have already mentioned that unique fac-
torization in Z follows from the fact that every ideal is generated by a single
element. Now, it is convenient to extend the notion of ideals of Z to that
of fractional ideals. These are additive subgroups of Q of the form 1
d I with
I an ideal of Z and d a nonzero integer. When the distinction is important,
Z as an integral ideal. The nonzero fractional ide-
we refer to an ideal I
als of Z naturally form a multiplicative group (whereas, for instance, there is
(2Z) = (1)). The statement that every
no integral ideal I
ideal is generated by a single element translates to the fact that the quotient
group of nonzero fractional ideals modulo Q× is trivial (where a
Q× corre-
sponds to 1
b aZ, and the multiplicative group of invertible elements of a ring R
is denoted by R×).

Z such that I

b ∈

⊆

⊆

∗

It turns out that this quotient group can be deﬁned for every ring of inte-
gers
OK. The fundamental theoretical notion beneath this construction is that
of Dedekind domains: these are integral domains D which are Noetherian
(every ideal of D is ﬁnitely generated), integrally closed (if an element x in
the fraction ﬁeld Frac D of D is a root of a monic polynomial with coeﬃcients
D), and of Krull dimension at most 1 (every nonzero
in D, then actually x

∈

3By “essentially diﬀerent” we mean that one factorization cannot be obtained from the other

via multiplication by units.

Springer Nature 2021 LATEX template

Dedekind domains and class groups

5

prime ideal of D is maximal). It can be proved that the nonzero fractional
ideals of a Dedekind domain D form a group under multiplication, and that
the quotient of this group by the image of the natural embedding of (Frac D)×
is called the (ideal ) class group
lD. For later reference, fractional ideals gen-
C
erated by one element of Frac D are called principal fractional ideals, so the
image of the natural embedding of (Frac D)× consists exactly of the nonzero
principal fractional ideals.

What is arithmetically crucial is the theorem ensuring that the ring of
OK of every number ﬁeld K is a Dedekind domain, and that in this
integers
K is actually ﬁnite. In particular,
K can be seen
case the class group
as “measuring” how far ideals of
OK are from being generated by a single
element and, consequently, as a measure of the failure of unique factorization.
K is called the class number of K. Intuitively, then, the smaller
The order of
the class number, the fewer factorizations are possible. In particular, the class
number of K is equal to 1 if and only if

l
C

l
C

l
C

O

O

O

The statements in the previous paragraph also hold for function ﬁelds,
namely ﬁelds which are ﬁnite extensions of Fq(t) = Frac Fq[t], where Fq[t]
stands for the ring of univariate polynomials (in a free variable t) with coef-
ﬁcients in a ﬁnite ﬁeld Fq with q elements. Recall that when q is a prime
number, Fq is simply the ﬁeld Z/qZ. A ﬁeld which is either a number ﬁeld or
a function ﬁeld is called a global ﬁeld.

OK is a UFD.

The concept of class group actually not only makes sense for Dedekind
domains but more generally for (at least) any integral domain R as follows.
While the nonzero fractional ideals of R in general need not be a group, they
do form a commutative monoid. Hence, the invertible fractional ideals of R
form a group, and the class group of R (denoted
lR) is now deﬁned as the
C
quotient of this group by the image of the natural embedding of (Frac R)×.

In upcoming sections we will describe the formalization of the above

concepts as part of mathlib.

3 Lean and mathlib

The formal system of Lean is a dependent type theory based on the calcu-
lus of inductive constructions. This means that each element e has a unique
type t, written e : t. The natural number 0 has type N, and the rational 0
has type Q. One can then identify 0 : N with 0 : Q using a map N → Q
called a coercion (denoted by the arrow ↑ or left implicit); that is, (0 : Q) =
↑(0 : N). Types have types too, for example N : Type. The full hierarchy
consists of an impredicative universe Prop sitting at the bottom of a noncumu-
lative chain Prop : Type : Type 1 : Type 2 : ... ; “an arbitrary Type u”
is abbreviated as Type*. Propositions correspond to elements of Prop, while a
(veriﬁed) proof of the proposition P : Prop corresponds to an element p : P.
In addition to these features commonly found in a dependent type theory, Lean

Springer Nature 2021 LATEX template

6

Dedekind domains and class groups

provides proof irrelevance, quotient types and classical reasoning. Proof irrele-
vance means that for any proposition P : Prop, any two proofs p1 p2 : P are
judged equal by the system. These features are all commonly used in mathlib.
Lean uses typeclass inference to automatically infer properties of certain
objects. If we deﬁne a structure with the keyword class, then one can supply
values for the class that Lean will automatically infer, by tagging these with
instance. As an example, consider a ring R with a subring S. The instance
subring.to ring says that S is also a ring. Consequently, one can now use
lemmas about rings for S without having to invoke subring.to ring. We
put the implicit arguments to be inferred by the typeclass system in square
brackets. Other implicit arguments remain in curly brackets, while explicit
arguments go in round brackets. As an example, consider:

theorem pow_succ {M : Type u} [monoid M] (a : M) (n : N) :

a ^ (n + 1) = a * a ^ n

When invoking this theorem, one must provide the explicit arguments a, which
has type M, and a natural number n. As a result, Lean can determine the value
of M through uniﬁcation and can then use the typeclass system to infer a value
for [monoid M].

The ﬂagship general-purpose mathematical library for Lean is mathlib;
other libraries are available for more specialized purposes. Organizationally,
mathlib is characterized by a distributed and decentralized community of con-
tributors, a willingness to refactor its basic deﬁnitions, and a preference for
small, yet complete, contributions over larger projects added all at once. In
this project, as part of the development of mathlib, we followed this philoso-
phy by contributing pieces of our work as they were ﬁnished. In turn, we used
other mathlib contributors’ results as they were made available.

There is a variety of tactics available in mathlib such as simp (simpli-
ﬁes the main goal target using lemmas tagged with the attribute [simp]),
library search (tries to close the current goal by applying a lemma from the
library) and ring (proves equality of polynomial expressions over commutative
(semi)rings). Lean uses these to simplify the statement or to close the goal.
These are very eﬃcient when working with proofs that are calculation heavy,
or that follow from a small number of easy (or mathematically trivial) steps.

3.1 Use of typeclasses and bundling

Typeclasses were originally introduced in Haskell as a mechanism for operator
overloading [4], and are used throughout Lean’s core library and mathlib to
endow types with mathematical structures consisting of both operators and
their properties [1]. When the elaborator sees a function with an instance
parameter being applied, such as the [monoid M] parameter of pow succ a
n, a Prolog-like search is started to automatically synthesize a suitable value
for this parameter. Each of the local parameters and the declarations marked
as instance is tested in turn to see if their type matches the expected type
of the instance synthesis. All instance parameters of candidate instances are

Springer Nature 2021 LATEX template

Dedekind domains and class groups

7

themselves recursively inferred, until either a suitable term is constructed or
no more candidates remain; an error is raised in the latter case [5, Section
10]. Compared to Haskell’s, Lean’s typeclasses have few structural restrictions:
notably, classes and instances can depend on any term, instances may overlap,
classes can apply to multiple types and can have functional dependencies.

In our development, we followed the common practice in mathlib of provid-
ing structure on a type, whenever such a structure exists canonically, through
typeclasses. The informal notion of providing a certain mathematical structure
on a type should not be confused with the structure keyword formally declar-
ing a structure type whose elements are tuples. To confuse matters further,
Lean implements typeclasses as structure types, where the typeclass instances
are tuples of the typeclass’s ﬁelds. Typeclasses provided us a way to treat uni-
formly situations that are informally considered the same, as we discuss in
Sections 4.1 and 4.2. Our reliance on typeclasses did not cause any noticeable
slowness in proof checking: there was no instance that should be found but
could not due to timeouts.

A central consideration in formalizing deﬁnitions for mathlib is choosing
the appropriate amount of bundling: determining whether information about
an object should be carried by the object itself (bundled), or passed as a
separate value (unbundled) [6]. For example, the is number field typeclass
of Section 4 is considered to have unbundled inheritance from the field class
because instances of these classes are passed in separate parameters, while
it has bundled inheritance from char zero and finite dimensional since
both are included as ﬁelds of the structure. Similarly, the formalization of
admissible absolute values discussed in Section 8.2 features a bundled structure
absolute value which includes a map along with proofs stating that this map
is an absolute value, and an unbundled structure is admissible which takes
the absolute value map as a separate parameter.

Unbundling has an advantage in expressivity: because each property of an
object is passed in a separate parameter, modifying one hypothesis requires
modifying one parameter. In contrast, bundling hypotheses means that each
subset of hypotheses requires its own structure declaration; any results proved
for a given structure have to be made available for other structures manually
or through automation such as typeclass inference. The advantage here is that
bundled structures result in simpler parameter lists, since fully unbundling the
field class would result in each of its 38 structure ﬁelds becoming a separate
parameter.

Technical considerations play another important role in choosing the level
of bundling: bundled properties are easily found by automation compared to
unbundled properties which require a search of the local context, bundled
inheritance between classes can only be applied when the two classes have the
same type parameters, while long unbundled inheritance chains cause expo-
nentially large terms, resulting in slowdowns and high memory consumption.
Although there is no general rule governing bundling, in general mathlib prefers

Springer Nature 2021 LATEX template

8

Dedekind domains and class groups

to bundle if possible, unbundling only when the additional properties are all
Prop-valued and are not involved in long inheritance chains.

4 Number ﬁelds, global ﬁelds and rings of

integers

We refer the reader to Section 2 for the mathematical background needed in
this section.

We formalized number ﬁelds as the following typeclass:

class is_number_field (K : Type*) [field K] : Prop :=
[to_char_zero : char_zero K]
[to_finite_dimensional : finite_dimensional Q K]

The class keyword declares a structure type (in other words, a type of record)
and enables typeclass inference for terms of this type; we describe the use of
typeclasses in mathlib in Section 3.1. Round brackets mark parameters that
must explicitly be supplied by the user, such as (K : Type*), while square
brackets mark instance parameters inferred by the typeclass system, such as
[field K]. The condition [to char zero : char zero K] states that K has
characteristic zero, so the unique ring homomorphism Z
K is an embedding.
This implies that there is a Q-algebra structure on K (found by typeclass
instance synthesis), endowing K with the Q-vector space structure used in the
hypothesis [to finite dimensional : finite dimensional Q K].

→

Similarly, we deﬁned the class of function ﬁelds over a ﬁnite ﬁeld Fq as:

class function_field (Fq F : Type*) [field Fq] [field F] :

Prop :=

[to_algebra : algebra (ratfunc Fq) F]
[to_finite_dimensional : finite_dimensional (ratfunc Fq) F]

The hypothesis [to algebra : algebra (ratfunc Fq) F] witnesses that F
is a ﬁeld extension of the ﬁeld Fq(t) of rational functions over Fq, where
Fq is any ﬁeld (although in our applications we will insist that Fq be actu-
ally ﬁnite). Again, the condition that this extension is ﬁnite is written using
the finite dimensional typeclass. We present a more detailed analysis of
algebra in Section 4.1 and of fraction ﬁelds including ratfunc in Section 4.5.
For now, we point out that there are many ﬁelds K that are isomorphic to the
ﬁeld of rational functions Fq(t); we provided a theorem function field iff
that shows that the choice of K does not matter. Note that there is no require-
ment that the ﬁeld Fq is ﬁnite, since this is not needed to state the conditions
on F. We instead add a [fintype Fq] hypothesis only to those results that
require ﬁniteness.

4.1 Field extensions

The deﬁnition of is number field illustrates our treatment of ﬁeld extensions.
A ﬁeld L containing a subﬁeld K is said to be a ﬁeld extension L/K. Often

Springer Nature 2021 LATEX template

Dedekind domains and class groups

9

we encounter towers of ﬁeld extensions: we might have that Q is contained
in K, K is contained in L, L is contained in an algebraic closure K of K,
and K is contained in C. We might formalize this situation by viewing Q, K,
L and K as sets of complex numbers C and deﬁning ﬁeld extensions as subset
relations between these subﬁelds. This way, no coercions need to be inserted
in order to map elements of one ﬁeld into a larger ﬁeld. Unfortunately, we
can only avoid coercions as far as we are able to stay within one largest ﬁeld.
For example, the deﬁnition of complex numbers depends on many results for
rational numbers, which would need to be proved again, or transported, for
the subﬁeld of C isomorphic to Q.

Instead, we formalized results about ﬁeld extensions through parametriza-
tion. The ﬁelds K and L can be arbitrary types and the hypothesis “L is
a ﬁeld extension of K” is represented by an instance parameter [algebra K
L] denoting a K-algebra structure on L. The algebra structure provides us
with a ring homomorphism algebra map K L : K
L; this map is injective
because K and L are ﬁelds. In other words, ﬁeld extensions are given by their
embeddings.

→

There are multiple possible K-algebra structures for a ﬁeld L and Lean does
not enforce uniqueness of typeclass instances, but the mathlib maintainers try
to ensure all instances that can be inferred are deﬁnitionally equal. Deﬁnitional
equality is a syntactical notion of equality found in dependent type theories
that reﬂects the possibility of computation: for example, the term 2 + 2 : N
is deﬁnitionally equal to 4. Whenever Lean can infer the deﬁnitional equality
of two terms (the terms are said to unify), one can be substituted for the
other. Thus, ensuring deﬁnitional equality for instances means that overlapping
instances will not lead to conﬂicts when one instance is expected and another
is found.

4.2 Scalar towers

The main drawback of using arbitrary embeddings to represent ﬁeld extensions
is that we need to prove that these maps commute. For example, we might
start with a ﬁeld extension L/Q, then deﬁne a subﬁeld K of L, resulting in
a tower of extensions L/K/Q. In such a tower, the map Q
L should be
equal to the composition Q
L. Such an equality cannot
always be achieved by deﬁning the map Q
L to be this composition: in the
example, the deﬁnition of the map Q

K depends on the map Q

K followed by K

The solution in mathlib is to parametrize over all three maps, as long
as there is also a proof of coherence: a hypothesis of the form “L/K/F
is a tower of ﬁeld extensions” is translated into three instance parameters
[algebra F K], [algebra K L] and [algebra F L], along with a parameter
[is scalar tower F K L] expressing that the maps commute.

→

→

→

→

→

→

L.

The is scalar tower typeclass derives its name from its applicability to

any three types among which scalar multiplication operations exist:

class is_scalar_tower (M N α : Type*)

Springer Nature 2021 LATEX template

10

Dedekind domains and class groups

[has_scalar M N] [has_scalar N α] [has_scalar M α] : Prop :=

(smul_assoc :

∀

(x : M) (y : N) (z : α), (x

y)

·

·

z = x

(y

·

·

z))

·

For example, if R is a ring, A is an R-algebra and M an A-module, we can
state that M is also an R-module by adding a [is scalar tower R A M]
parameter. Since x
y for an R-algebra A is deﬁned as algebra map R A x *
y, applying smul assoc for each x : K with y = (1 : L) and z = (1 : F ) shows
that the algebra maps indeed commute in a tower of ﬁeld extensions L/K/F .
Common is scalar tower instances are declared in mathlib, such as for the
B when S is a R-subalgebra of A and B is an A-algebra such
maps R
that is scalar tower R A B; this also implies that the maps R
A
form a tower. The eﬀect is that almost all coherence proof obligations are
automated through typeclass instance synthesis. Only when deﬁning a new
algebra structure were we required to supply the is scalar tower instances
ourselves.

→

→

→

→

S

S

4.3 Rings of integers

When K is a number ﬁeld (deﬁned as a ﬁeld satisfying is number field), the
OK of integers in K is deﬁned as the integral closure of Z in K. This is
ring
the subring containing those x : K that are a root of a monic polynomial with
coeﬃcients in Z:

def number_field.ring_of_integers (K : Type*) [field K]

[is_number_field K] : subalgebra Z K :=

integral_closure Z K

where integral closure was already deﬁned in mathlib. When K is a function
OK analogously as integral closure
ﬁeld over the ﬁnite ﬁeld Fq, we deﬁned
(Fq[X]) K.
Since the integers Z are integrally closed in Q, this construction of the
ring of integers of the number ﬁeld Q is isomorphic, but not deﬁnitionally
equal, to Z. To avoid dealing with these isomorphisms, and also to treat the
two deﬁnitions of rings of integers on an equal footing, we introduced a type-
class is integral closure A R B stating that A is the integral closure of R
in B, and worked with a generic is integral closure instance instead of the
speciﬁc ring of integers construction when possible.

4.4 Subobjects

The ring of integers is one example of a subobject, such as a subﬁeld, subring
or subalgebra, deﬁned through a characteristic predicate. In mathlib, subob-
jects are “bundled”, in the form of a structure comprising the carrier set and
proofs showing the carrier set is closed under the relevant operations. Bundled
subobjects provide similar beneﬁts to those of bundled morphisms; the choice
for the latter is explained in the mathlib overview paper [1]. Where the algebra

Springer Nature 2021 LATEX template

Dedekind domains and class groups

11

and is scalar tower typeclasses provide an interface generalizing over multi-
ple equivalent deﬁnitions, subobjects provide a speciﬁc implementation of that
interface in the form of a subtype.

Two new subobjects that we deﬁned in our development were subfield as
well as intermediate field. We deﬁned a subﬁeld of a ﬁeld K as a subset of K
that contains 0 and 1 and is closed under addition, negation, multiplication
and taking inverses. If L is a ﬁeld extension of K, we deﬁned an intermediate
ﬁeld as a subﬁeld of L that is also a K-subalgebra: in other words, a subﬁeld
that contains the image of algebra map K L. Other examples of subobjects
available in mathlib are submonoids, subgroups and submodules (with ideals
as a special case of submodules); all of these are provided with an instance of
the set like typeclass that supplies notation such as a membership relation
“x

∈
The new deﬁnitions found immediate use: soon after we contributed our
deﬁnition of intermediate field to mathlib, the Berkeley Galois theory group
used it in a formalization of the primitive element theorem. Soon after the
primitive element theorem was merged into mathlib, we used it in our develop-
ment of the trace form. This anecdote illustrates the decentralized development
style of mathlib, with diﬀerent groups and people building on each other’s
results in a collaborative process.

S”.

Through the set like typeclass, subobjects can be coerced to types, by
sending a subobject S to the subtype of all elements of S. By putting type-
class instances on this subtype, we could reason about inductively deﬁned
rings such as Z and subrings such as integral closure Z K uniformly. If
S : subfield K, there is a ring embedding, the map that sends x : S to K
S, and we registered this map as an algebra S K
by “forgetting” that x
instance, also allowing us to treat ﬁeld extensions of the form Q
C and
subﬁelds uniformly. Similarly, for F : intermediate field K L, we deﬁned
the corresponding algebra K F, algebra F L and is scalar tower K F L
instances.

→

∈

4.5 Fields of fractions

∼

(aα, bα) for all α

The fraction ﬁeld Frac R of an integral domain R can be deﬁned explicitly as
a quotient type as follows: starting from the type of pairs (a, b) with a, b
∈
= 0, one quotients by the equivalence relation generated by
R such that b
= 0 : R, writing the equivalence class of (a, b) as a
b .
(a, b)
It can easily be proved that the ring structure on R extends uniquely to a ﬁeld
structure on Frac R; in mathlib this construction is called fraction ring R,
and is used to deﬁne the ﬁeld of rational functions K(X) = ratfunc K. When
R = Z, this yields the traditional description of Q as the set of equivalence
classes of fractions, where 2

can serve as the ﬁeld of fractions for the same ring. Consider the ﬁeld

The drawback of this construction is that there are many other ﬁelds that
C :
, which is isomorphic to Frac(Z[i]) but not deﬁnitionally equal
ℜ
to it. Indeed, the mathlib deﬁnition of the rational numbers Q is a product type,

Q,

Q

ℑ

∈

∈

∈

}

{

z

z

z

3 = −
−

4
6 , etc.

6
6
Springer Nature 2021 LATEX template

12

Dedekind domains and class groups

not a quotient type, so we would not be able to treat Q as the ﬁeld of fractions
of Z in this setup. Any properties proven for Q would have to be repeated for
Frac(Z), using transfer lemmas stating these properties are preserved by the
isomorphism between Q and Frac(Z).

The strategy used in mathlib is to rather allow for many diﬀerent fraction
ﬁelds of our given integral domain R — as ﬁelds K with a suitable [algebra
R K] instance, where the map algebra map R K witnesses that all elements K
are “fractions” of elements of R — and to parametrize every result over the
choice of K. The conditions on the R-algebra structure on K are encoded as a
typeclass is fraction ring R K. In the deﬁnition used by mathlib, a fraction
ring is a special case of a ring localization, which is deﬁned for any com-
mutative ring R. Diﬀerent localizations restrict the denominators to diﬀerent
multiplicative submonoids of R

0

.

→

The conditions on algebra map R K imply that K is the smallest ﬁeld,
up to isomorphism, containing R, expressed by the following unique mapping
A is an injective map to a ring A such that g(x) has
property. If g : R
= 0 : R, then it can be extended uniquely
a multiplicative inverse for all x
A compatible with algebra map R K and g. In particular,
to a map K
given is fraction ring R K1 and is fraction ring R K2, we can derive an
K2. The construction of Frac R then results in a ﬁeld of
isomorphism K1 ≃
fractions (with an instance is fraction ring R (fraction ring R)) rather
than the ﬁeld of fractions.

→

\ {

}

The above description of fraction ﬁelds is the third such formalization in
mathlib. The ﬁrst version consisted of a quotient type quotient ring R, con-
structed similarly to the current deﬁnition of fraction ring R. Due to the
aforementioned drawback — namely, that this provided no easy way to view Q
as the ﬁeld of fractions of Z, for instance — this was refactored to use a
characteristic predicate instead.

→

The second version deﬁned K to be the ﬁeld of fractions of R if there
existed an injective fraction map f : R
K, which is a ring homomor-
phism witnessing that all elements of K are “fractions” of elements of R; the
map and its properties were bundled as a type fraction map R K. Results
on fraction ﬁelds were parametrized over a choice of fraction map f . This
made it possible to view Q as the fraction ﬁeld of Z, by providing a suitable
map called int.fraction map : fraction map Z Q. This came at a price:
informally, at any given stage of one’s reasoning, the ﬁeld K is ﬁxed and the
map f : R
K is applied implicitly, just viewing every x : R as x : K. It
K as an inclusion of R-subalgebras, because
is now impossible to view R
the map f is needed explicitly to give the R-algebra structure on K. As a
workaround, mathlib used a type synonym codomain f := K and instantiated
the R-algebra structure given by f on this synonym. Again we encountered a
distinction between Q “itself” and Frac(Z) = codomain int.fraction map,
still requiring the transfer of results such as typeclass instances.

→

≤

The most recent version is the one described above. Inspired by our
success in using the algebra typeclass to denote inclusions of rings, we

6
Springer Nature 2021 LATEX template

Dedekind domains and class groups

13

unbundled the explicit (f : fraction map R K) parameters into an instance
parameter [algebra R K] that speciﬁes the map, and an instance parameter
[is fraction ring R K] that speciﬁes the conditions satisﬁed by the map.
Separating out these parameters ﬁnally allowed us to painlessly view Q as the
fraction ring of Z while preserving the original Z-algebra structure on Q.

4.6 Representing monogenic ﬁeld extensions

∈

In Section 2 we have informally said that every number ﬁeld K can be written
as K = Q(α) for a root α of an irreducible polynomial P
Q[X]. This can
be made precise in several ways. For instance, one can consider a large ﬁeld L
L
(of characteristic 0) where P splits completely, then choose a root α
and let K = Q(α) be the smallest subﬁeld of L containing α. Or, one can
consider the quotient ring Q[X]/P and observe that this is a ﬁeld where the
X (mod P ) yields an
class X (mod P ) is a root of P . The assignment α
L leads
isomorphism of the two ﬁelds, but any other choice of a root α′
to another isomorphism Q(α′) ∼= Q[X]/P . Although mathematically we often
tacitly identify these constructions, there is no canonical representation of the
monogenic extensions of Q, those which can be obtained by adjoining a single
root of one polynomial.

7→

∈

∈

The same continues to hold if we replace the base ﬁeld Q with another
ﬁeld F , thus considering extensions of the form F (α), now requiring that α
be a root of some P
F [X]. Various constructions of F (α) have already
been formalized in mathlib. The ability to switch between these representa-
tions is important: sometimes K and F are ﬁxed and we want an arbitrary α;
sometimes α is ﬁxed and we want an arbitrary type representing F (α).

∈

To ﬁnd a uniform way to reason about all these deﬁnitions, we chose to
formalize the notion of power basis to represent monogenic ﬁeld extensions:
1 : K (viewing K as a F -vector
this is a basis of the form 1, α, α2, . . . , αn
space). We deﬁned a structure type bundling the information of a power basis.
Omitting some generalizations not needed in this paper, the deﬁnition reads:

−

structure power_basis (F K : Type*) [field F] [field K]

[algebra F K] :=

(gen : K) (dim : N) (basis : basis (fin dim) F K)
(basis_eq_pow :

i, basis i = gen ^ (i : N))

∀

We formalized that the previously deﬁned notions of monogenic ﬁeld extensions
are equivalent to the existence of a power basis.

With the power basis structure, we gained the ability to parametrize our
results, being able to choose the F and K in a monogenic ﬁeld extension K/F ,
or being able to choose the α generating F (α) (by setting the gen ﬁeld to α).
To specialize a result from an arbitrary K with a power basis over F to a
speciﬁc construction of K = F (α), one can apply the result to the power basis
pb generated by α and rewrite power basis.gen pb = α.

Springer Nature 2021 LATEX template

14

Dedekind domains and class groups

5 Dedekind domains

The right setting to study algebraic properties of number ﬁelds are Dedekind
domains. We formalized fundamental results on Dedekind domains, including
the equivalence of two deﬁnitions of Dedekind domains.

5.1 Deﬁnitions

There are various equivalent conditions, used at various times, for an integral
domain D to be a Dedekind domain. The following three have been formalized
in mathlib:

• is dedekind domain D: D is a Noetherian integral domain, integrally closed

in its fraction ﬁeld and has Krull dimension at most 1;

• is dedekind domain inv D: D is an integral domain and nonzero frac-
tional ideals of D have a multiplicative inverse (we discuss the notion and
formalization of fractional ideals in Section 5.2);

• is dedekind domain dvr D: D is a Noetherian integral domain and the
localization of D at each nonzero prime ideal is a discrete valuation ring.

Note that ﬁelds are Dedekind domains according to these conventions.

The mathlib community chose is dedekind domain as the main deﬁni-
tion, since this condition is usually the one checked in practice [7]. The
other two equivalent deﬁnitions were added to mathlib, but before formal-
izing the proof that they are indeed equivalent. Having multiple deﬁnitions
allowed us to do our work in parallel without depending on unformalized
results. For example, the proof of unique ideal factorization in a Dedekind
domain initially assumed is dedekind domain inv D, and the proof that the
OK is a Dedekind domain concluded is dedekind domain
ring of integers
(ring of integers K). After the equivalence between is dedekind domain
D and is dedekind domain inv D was formalized, we could easily replace
usages of is dedekind domain inv with is dedekind domain.

The conditions is dedekind domain and is dedekind domain inv require
a fraction ﬁeld K, although the truth value of the predicates does not depend
on the choice of K. For ease of use, we let the type of is dedekind domain
depend only on the domain D by instantiating K in the deﬁnition as
fraction ring D. From now on, we ﬁx a fraction ﬁeld K of D.

class is_dedekind_domain (D : Type*)

[comm_ring D] [is_domain D] :=

(is_noetherian_ring : is_noetherian_ring D)
(dimension_le_one : dimension_le_one D)
(is_integrally_closed : is_integrally_closed D)

Applications of is dedekind domain can choose a speciﬁc fraction ﬁeld

through the following lemma exposing the alternate deﬁnition:

lemma is_dedekind_domain_iff [is_fraction_ring D K] :

is_dedekind_domain D

↔

Springer Nature 2021 LATEX template

Dedekind domains and class groups

15

is_noetherian_ring D

dimension_le_one D

{x : K}, is_integral D x

∧

(y : D), algebra_map D K y = x

→

∀

∃

∧

We marked is dedekind domain as a typeclass by using the keyword class
rather than structure, allowing the typeclass system to automatically infer
the Dedekind domain structure when an appropriate instance is declared, such
as for PIDs or for rings of integers.

5.2 Fractional ideals

The notion which is pivotal to the deﬁnition of the ideal class group of a
Dedekind domain is that of fractional ideals: given any integral domain R
with a ﬁeld of fractions F , we deﬁne is fractional as a predicate on R-
submodules J of F , informally as “there is an x : R with xJ
R”. For a
Dedekind domain, nonzero fractional ideals form a group under multiplication.
As seen in Section 4.5, this notion depends on the ﬁeld F as well as on the
embedding f := algebra map R F. A more precise way of stating the above
condition is then f (x)J
f (R). We formalized the deﬁnition of fractional
ideals of R contained in F as a type fractional ideal R F, whose elements
consist of an R-submodule of F along with a proof of is fractional. The
structure of fractional ideals does not depend on the choice of a fraction ﬁeld,
which we formalized as an isomorphism fractional ideal.canonical equiv
between two types of fractional ideals on R, corresponding to diﬀerent ﬁelds
of fractions.

⊆

⊆

We deﬁned the addition, multiplication and intersection operations on frac-
tional ideals, by showing that the corresponding operations on submodules
map fractional ideals to fractional ideals. We also formalized that these oper-
ations give a commutative semiring structure on the type of fractional ideals.
For example, multiplication of fractional ideals is deﬁned as

lemma is_fractional.mul (I J : submodule R F)

is_fractional R I
is_fractional R (I * J) := _ -- proof omitted

is_fractional R J

→

→

instance : has_mul (fractional_ideal R F) :=
λ I J,
h
is_fractional.mul I.is_fractional J.is_fractional

I * J : submodule R F,

h

ii

Deﬁning the quotient of two fractional ideals requires slightly more work.
R, the

A. Given ideals I, J

Consider any R-algebra A and an injection R ֒
A is deﬁned by the property
submodule I/J

→

≤

≤

lemma submodule.mem_div_iff_forall_mul_mem {x : A}

{I J : submodule R A} :
x

I / J

y

J, x * y

∈

↔ ∀

∈

I

∈

Beware that the notation 1/I might be misleading here: indeed, for general
1/I = 1 might not hold. As an example, one
integral domains, the equality I

∗

Springer Nature 2021 LATEX template

16

Dedekind domains and class groups

1 consists of the elements a = p
C[X, Y ] for all b

can consider the ideal (X, Y ) in C[X, Y ], which is not a Dedekind domain: by
q : Frac(cid:0)C[X, Y ](cid:1) with the
deﬁnition, (X, Y )−
(X, Y ). This last condition is equivalent
property that a
Y are in C[X, Y ] and thus the denominator
X and a
to requiring that both a
C×. It follows
q of a must be divisible both by X and by Y , so actually q
∈
1 = (X, Y ) ( 1 =
that (X, Y )−
(X, Y )−
C[X, Y ].

1 = C[X, Y ], and in particular (X, Y )

∈

∈

∗

∗

∗

∗

b

On the other hand, we formalized that the equality I
Dedekind domains (Section 5.3) as the following lemma:

∗

1/I = 1 holds for

theorem fractional_ideal.mul_inv_cancel [is_dedekind_domain D]

{I : fractional_ideal D F} (hne : I

= 0) : I * (1 / I) = 1

1 = 1/I. In fact, we deﬁne this notation even
This justiﬁes the notation I −
1 = 0. This ﬁts the pattern of the type-
for the ideal 0, by declaring that 0−
class group with zero in mathlib, consisting of groups endowed with an extra
element 0 whose inverse is again 0.

Moreover, mathlib used to deﬁne a/b := a
1, but our deﬁnition of
1 = 1/I would cause circularity. This led us to a major refactor of this
I −
core deﬁnition. In particular, we had to weaken the deﬁnitional equality to a
proposition; this involved many small changes throughout mathlib4.

b−

∗

5.3 Equivalence of the deﬁnitions

We now describe how we proved and formalized that the two deﬁnitions
is dedekind domain and is dedekind domain inv of being a Dedekind
K a
domain are equivalent. Let D be a Dedekind domain, and let f : D
fraction map to a ﬁeld of fractions K of D.

→

To show that is dedekind domain inv implies is dedekind domain, we
follow the proof given by Fr¨ohlich in [8, Chapter 1, Section 2, Proposition 1.2.1].
A constant challenge that was faced while coding this proof was already men-
tioned in Section 4.5, namely the fact that elements of the domain must be
traced along the inclusion into the chosen ﬁeld of fractions. The proofs for
being integrally closed and of dimension being less than or equal to 1 are fairly
straightforward.

Formalizing the Noetherian condition was the most challenging. Fr¨ohlich
1 for any nonempty
considers elements a1, . . . , an ∈
fractional ideal I, satisfying Pi aibi = 1. Observe now that, in mathlib, the
deﬁnition of the product A
B of two fractional ideals A, B is a special case
of the product of two submodules, and therefore it is deﬁned as

I and b1, . . . , bn ∈

I −

∗

submodule.has_mul = {mul := λ (A B : submodule D K),

(a : A), submodule.map ((algebra.lmul D K) a.val) B}

B as the smallest (i. e., the
Unraveling this deﬁnition, we see that it deﬁnes A
inﬁmum with respect to set-theoretic inclusion as order relation) submodule

∗

⊔

4The pull requests are available as https://github.com/leanprover-community/mathlib/pull/

5302 and https://github.com/leanprover-community/mathlib/pull/5303.

6
Springer Nature 2021 LATEX template

Dedekind domains and class groups

17

·

·

∗

∗

∗

∈

∈

A

B for a

A, where a

∈
bi, for ai ∈

B must be a ﬁnite sum Pi ai ∗

containing all submodules a
B is the range of the function
λ b : B, a
b. However, it is quite challenging to formalize that an element of
A
B. Instead, we show
A and bi ∈
that, for every element x
B such
B, there are ﬁnite sets T
span (T * T’), formalized as submodule.mem span mul finite-
that x
of mem mul. Now considering a nonzero integral ideal I of the ring D, by
(1 : fractional ideal D K) =
deﬁnition of invertibility we can write 1
1 such that 1
1. Hence, we obtain ﬁnite sets T
I * I−
I −
T ′. We used the norm cast tactic [9] to
is contained in the D-span of T
resolve most coercions but this tactic did not solve coercions coming from the
inclusion algebra map D K. With coercions, the actual statement of the latter
expression in Lean is ↑T’

1, which reads

I and T ′

↑↑(↑I)−

A, T ′

⊆

⊆

⊂

⊂

∈

∗

⊆

(T’ : set K)
: set K)

⊆

(((I : fractional_ideal D K)−

1 : submodule D K)

From the existence of T and T ′ we concluded that I is indeed ﬁnitely generated,
thus ﬁnishing the proof.

The theorem fractional ideal.mul inv cancel proves the converse,
namely that is dedekind domain implies is dedekind domain inv. The clas-
sical proof consists of three steps: ﬁrst, every maximal ideal M
D, seen as
a fractional ideal, is invertible; second, every nonzero ideal is invertible, using
that it is contained in a maximal ideal; third, the fact that every fractional
ideal J satisﬁes xJ
D and a suitable ideal
I
D implies that every fractional ideal is invertible, concluding the proof
that nonzero fractional ideals form a group. The third step was easy, build-
ing upon the material developed for the general theory of fractional ideal.
Concerning the ﬁrst two, we found that passing from the case where M is max-
imal to the general case required more code than directly showing invertibility
of arbitrary nonzero ideals. The formal statement reads

I for a suitable element x

≤

⊆

⊆

∈

lemma coe_ideal_mul_inv [is_dedekind_domain D]

(I : ideal D) (hI0 : I
(

= 0) :
1 : fractional_ideal D K) = 1

I)−

I * (
↑
↑

from where it becomes apparent that we had to repeatedly distinguish between
I : ideal D, and its coercion ↑I : fractional ideal D K although these
objects, from a mathematical point of view, are identical.

The formal proof of this result relies on the lemma exists not mem one-
of ne bot, which says that for every non-trivial ideal 0 ( I ( D, there
exists an element in the ﬁeld K which is not integral (so, not in 1 :
1. The proof begins by invoking that
fractional ideal D K) but lies in I −
every nonzero ideal in the Noetherian ring D contains a product of nonzero
prime ideals. This result was not previously available in mathlib. The dimen-
sion condition shows its full force when applying this lemma: each prime
1, being nonzero, will be maximal because the
ideal in the product I
Krull dimension of D is at most 1; from this, exists not mem one of ne bot
follows easily. Having the above lemma at our disposal, we were able to

I −

∗

6
Springer Nature 2021 LATEX template

18

Dedekind domains and class groups

1

∗

I −

= D, we can ﬁnd an element x

= 0 is invertible by arguing by contradiction: if
prove that every ideal I
1
1)−
I
thanks to exists not mem one of ne bot; some easy algebraic manipulation
then implies that x is actually integral over D. Since D is integrally closed,
D, contradicting the construction of x. Combining these results gives the
x
equivalence between the two conditions for being a Dedekind domain.

D which is in (I

I −

K

∈

∈

∗

\

5.4 Unique ideal factorization

As brieﬂy indicated before, we also formalized a proof that in a Dedekind
domain every nonzero ideal can be expressed as a product of prime ideals in a
unique way up to the order of the factors. In fact, for an integral domain, every
nonzero ideal is a product of prime ideals if and only if all nonzero fractional
ideals are invertible; the uniqueness follows separately. We have formalized
one direction of this equivalence, a proof of the converse can be found in [10,
Chapter 5, §6, Theorem 10].

We formalized the unique ideal factorization property of a Dedekind
domain D by instantiating a unique factorization monoid structure on its
ideals.

instance ideal.unique_factorization_monoid :

unique_factorization_monoid (ideal D)
In mathlib, unique factorization domains are actually a special case of
unique factorization monoids (UFMs). A commutative monoid R with an
absorbing element 0 and injective multiplication is deﬁned to be a UFM, if the
relation “x properly divides y” is well-founded (implying that every element
can be factored as a product of irreducibles) and an element of R is prime if
and only if it is irreducible (implying uniqueness of the factorization). Exam-
ples in mathlib of UFMs are the unique factorization domains N and Z as well
as, for any UFM α, the quotient of α by the subgroup of invertible elements
associates α. With much of the necessary deﬁnitions and properties already
formalized, the formalization of this unique factorization result has been done
in well under 100 lines of Lean code. One of the main mathematical ingredi-
ents (interesting in its own right) is that for ideals in a Dedekind domain, to
divide is to contain:

lemma ideal.dvd_iff_le {I J : ideal D} : (I

J)

|

J

I

↔

≤

Similarly, to strictly contain is to properly divide, so the well-foundedness
condition of UFMs is exactly the property that a Dedekind domain is Noethe-
rian. In order to show that all irreducible elements of the monoid of nonzero
prime ideals in D are prime elements, we formalized that irreducible ideals in
a Dedekind domain are maximal and therefore prime (note that prime ideals
of a Dedekind domain D coincide with prime elements of the monoid of its
nonzero ideals); the converse holds in every monoid.

We note that the unique factorization result, or actually an easy corollary
thereof, is an important ingredient in our ﬁniteness proof for the class group
of rings of integers, as we will elaborate on in Section 8.2.

6
6
Springer Nature 2021 LATEX template

Dedekind domains and class groups

19

6 Principal ideal domains are Dedekind

As an example of our deﬁnitions, we discuss in some detail our formalization
of the fact that a principal ideal domain is a Dedekind domain. In the same
way that unique factorization domains are generalized in mathlib to unique
factorization monoids, there is no explicit deﬁnition of PIDs in mathlib. Rather,
it is split up into multiple hypotheses. One uses [comm ring R] [is domain
R] [is principal ideal ring R] to denote a PID R, where is domain is a
typeclass asserting that the ring is nontrivial and there are no zero divisors,
and is principal ideal ring is a typeclass deﬁned for all commutative rings:

class is_principal_ideal_ring (R : Type*) [comm_ring R] :=
(principal :

(I : ideal R), is_principal I)

∀

Our

proof

[comm ring R] [is domain R]
[is principal ideal ring R] imply is dedekind domain R was relatively
short:

hypotheses

that

the

instance principal_ideal_ring.to_dedekind_domain (R : Type*)
[comm_ring R] [is_domain R] [is_principal_ideal_ring R] :
is_dedekind_domain R :=

principal_ideal_ring.is_noetherian_ring,
h
dimension_le_one.principal_ideal_ring R,
unique_factorization_monoid.is_integrally_closed
i

The Noetherian property of a Dedekind domain followed easily by the pre-
viously deﬁned lemma principal ideal ring.is noetherian ring, since, by
deﬁnition, each ideal in a principal ideal ring is ﬁnitely generated (by a single
element).

We proved the lemma dimension le one.principal ideal ring, which
is an instantiation of the existing result is prime.to maximal ideal, showing
that a nonzero prime ideal in a PID is maximal. The latter lemma uses the
characterization that I is a maximal ideal if and only if any strictly larger ideal
J ) I is the full ring R. If I is a nonzero prime ideal and J ) I in the PID R,
we see that a generator j of J is a divisor of any generator i of I. Since I is
I, contradicting the assumption that J ) I,
prime, this implies that either j
or i = 0, contradicting that I is nonzero, or ﬁnally that j is a unit, implying
J = R as desired.

∈

The ﬁnal condition of a PID being integrally closed was the most chal-
lenging. We used the previously deﬁned instance principal ideal ring.to -
unique factorization monoid to deduce that a PID is a unique factorization
monoid (UFM), to instantiate our proof that every UFD is integrally closed.
In a PID, the Noetherian property implies that the division relation is well-
founded, and principal ideal ring.irreducible iff prime shows that
irreducible elements and prime elements coincide. To prove that an irreducible
element p is prime, the proof uses that prime elements generate prime ideals
and irreducible elements of a PID generate maximal ideals. Since all maximal
ideals are prime ideals, the ideal generated by p is maximal, hence prime, thus

Springer Nature 2021 LATEX template

20

Dedekind domains and class groups

p is prime. We proved the lemma irreducible of prime, which shows the
converse holds in any commutative monoid with zero.

To show that a UFM is integrally closed, we ﬁrst formalized the Ratio-
nal Root Theorem, named denom dvd of is root, which states that for a
polynomial p : R[X] and an element of the fraction ﬁeld x : Frac R such
that p(x) = 0, the denominator of x divides the leading coeﬃcient of p. If
x is integral with minimal polynomial p, the leading coeﬃcient is 1, there-
fore the denominator is a unit and x is an element of R. This gave us the
required lemma unique factorization monoid.integrally closed, which
states that the integral closure of R in its fraction ﬁeld is R itself.

7 Rings of integers are Dedekind domains

An important classical result in algebraic number theory is that the ring of
integers of a number ﬁeld K, deﬁned as the integral closure of Z in K, is a
Dedekind domain. We formalized a stronger result: given a Dedekind domain D
and a ﬁeld of fractions F , if K is a ﬁnite separable extension of F , then
the integral closure of D in K is a Dedekind domain with fraction ﬁeld K.
Our approach was adapted from Neukirch [7, Theorem 3.1]. Throughout this
section, let D be a Dedekind domain with a ﬁeld of fractions F , K a ﬁnite,
separable ﬁeld extension of F and let S denote the integral closure of D in K.
ﬁeld
frac-
of
tions
is an instance
is fraction ring of finite extension D F K : is fraction ring S K.
The main content of is fraction ring of finite extension consisted of
showing that all elements x : K can be written as y/z for elements y
S,
z
S; the standard proof of this fact (see [11, Theorem 15.29]) formalized
⊆
∈
readily.

step was
integral

show that K is

closure, namely,

a
there

that

ﬁrst

The

the

for

to

D

∈

We could then show that the integral closure of D in K is a Dedekind
domain, by proving it is integrally closed in K, has Krull dimension at most
1 and is Noetherian. The fact that the integral closure is integrally closed was
immediate.

To show the Krull dimension is at most 1, we needed to develop basic going-
up theory for ideals. In particular, we showed that an ideal I in an integral
extension is maximal if it lies over a maximal ideal, and used a result already
available in mathlib that a prime ideal I in a ring extension lies over a prime
ideal.

lemma is_maximal_of_is_integral_of_is_maximal_comap

[algebra R S] (hRS : algebra.is_integral R S)
(I : ideal S) [is_prime I]
(hI : is_maximal (comap (algebra_map R S) I)) : is_maximal I

theorem is_prime.comap (f : R

+* S) (I : ideal S)

[hI : is_prime I] : is_prime (comap f I)

→

The ﬁnal condition, that the integral closure S of D in L is a Noethe-
rian ring, required the most work. We started by following the ﬁrst half of

Springer Nature 2021 LATEX template

Dedekind domains and class groups

21

Dummit and Foote [11, Theorem 15.29], so that it suﬃced to ﬁnd a non-
degenerate bilinear form B such that all integral x, y : K satisfy B(x, y)
∈
integral closure D K. We then formalized the results in Neukirch [7,
Sections 2.5–2.8] to show that the trace form is a bilinear form satisfying these
requirements.

7.1 The trace form

In the notation from the previous section, consider the bilinear map lmul :=
λ x y : K, x * y. The trace of the linear map lmul x is called the algebra
trace TrK/F (x) of x. We deﬁned the algebra trace as a linear map, in this case
from K to F :

noncomputable def trace : K
→l[F] F :=
linear_map.comp (linear_map.trace F K)

(to_linear_map (lmul F K))

This deﬁnition was marked noncomputable since linear map.trace makes a
case distinction on the existence of a ﬁnite basis, choosing an arbitrary ﬁnite
basis if one exists (since the value of linear map.trace does not depend on
this choice) and returning 0 otherwise. This latter case did not occur in our
development.

We deﬁned the trace form to be an F -bilinear form on K, mapping x, y : K

to TrK/F (xy).

noncomputable def trace_form : bilin_form F K :=
{ bilin := λ x y, trace F K (x * y), .. /- proofs omitted -/ }

In the following,

let L/K/F be a tower of ﬁnite extensions of
ﬁelds, namely we assume [algebra F K] [algebra K L] [algebra F L]
[is scalar tower F K L], as described in Section 4.2.

The value of the trace depends on the choice of F and K; we formalized
this as lemmas trace algebra map x : trace F K (algebra map F K x) =
finrank F K * x as well as trace trace x : trace F K (trace (K L x))
= trace F L x; here finrank F K is the degree of the ﬁeld extension K/F .
These results followed by direct computation.

To compute TrK/F (x), it therefore suﬃces to consider the trace of x in the
smallest ﬁeld containing x and F , which is the monogenic extension F (x) dis-
cussed in Section 4.6. There is a nice formula for the trace in F (x), although the
terms in this formula are elements in a larger ﬁeld L (such as the splitting ﬁeld
of minpoly F x, the minimal polynomial of x over F ). In formalizing this for-
mula, we ﬁrst mapped the trace to L using the embedding algebra map F L,
which gave the following statement:

lemma power_basis.trace_gen_eq_sum_roots (pb : power_basis F K)

(h : polynomial.splits (algebra_map F L) (minpoly F pb.gen)) :
algebra_map F L (trace F K pb.gen) =

sum (roots (map (algebra_map F L) (minpoly F pb.gen)))

Springer Nature 2021 LATEX template

22

Dedekind domains and class groups

We formulated the lemma in terms of the power basis, since we needed to use
it for F (x) here and for an arbitrary ﬁnite separable extension L/K later in
the proof.

The elements of roots (map (algebra map F L) (minpoly F pb.gen))
are called conjugates of x in L. Each conjugate of x is integral since it
is a root of the same monic polynomial, and integer multiples and sums
of integral elements are integral. Combining trace gen eq sum roots and
trace algebra map showed that the trace of x is an integer multiple (namely
finrank F(x) L) of a sum of conjugate roots, hence we concluded that the
trace (and trace form) of an integral element is also integral.

Finally, we showed that the trace form is nondegenerate, following Neu-
kirch [7, Proposition 2.8]. Since K/F is a ﬁnite, separable ﬁeld extension, it
has a power basis pb generated by an element x : K. Letting xk denote the
k-th conjugate of x in an algebraically closed ﬁeld L/K/F , the main diﬃ-
culty was in checking the equality Pk xi+j
k = TrK/F (xi+j ). Directly applying
trace gen eq sum roots was tempting, since we had a sum over conjugates of
powers on both sides. However, the two expressions did not precisely match:
the left hand side is a sum of conjugates of x, where each conjugate is raised
to the power i + j, while the conclusion of trace gen eq sum roots resulted
in a sum over conjugates of xi+j .

Instead, the paper proof switched here to an equivalent deﬁnition of conju-
gate: the conjugates of x in L are the images (counted with multiplicity) of x
under each embedding σ : F (x)
L that ﬁxes F . This equivalence between
the two notions of conjugate was contributed to mathlib by the Berkeley group
in the week before we realized we needed it. Mapping trace gen eq sum roots
through the equivalence gave TrK/F (x) = Pσ σ x. Since each σ is a ring homo-
morphism, σ xi+j = (σ x)i+j , so the conjugates of xi+j are the (i + j)-th
powers of conjugates of x, which concluded the proof.

→

8 Class group and class number

8.1 The class group

Recall from Section 2 that the ideal class group
lD of a Dedekind domain D
C
is the quotient of the group of nonzero fractional ideals of D by the nonzero
principal fractional ideals. More generally, given an integral domain R with
fraction ﬁeld K, we can deﬁne the class group
lR as the quotient of the
C
invertible fractional ideals by the nonzero principal fractional ideals. We for-
malized this in Lean by ﬁrst deﬁning a map to principal ideal R K : K×
→ (fractional ideal R K)×, and deﬁned the class group as

def class_group (R K : Type*) [comm_ring R] [is_domain R]

[field K] [algebra R K] [is_fraction_ring R K] :=

(fractional_ideal R K)× / (range (to_principal_ideal R K))

Here, R× for a semiring R denotes the multiplicative group of its invertible
elements. Recall from Section 5.2 that in the general case of an integral domain

Springer Nature 2021 LATEX template

Dedekind domains and class groups

23

R the type of fractional ideals of R is endowed with the structure of a commuta-
tive semiring. Therefore, the quotient of the abelian group (fractional ideal
R K)× by the subgroup of nonzero principal fractional ideals is well-deﬁned. In
the case where R is a Dedekind domain, we provided a map class group.mk0
sending nonzero integral ideals of R to the corresponding class in the class
group.

8.2 Finiteness results

In general, Dedekind domains can have inﬁnite class groups: in fact, a cele-
brated result by Claborn shows that for every abelian group G, there exists a
lD ∼= G (see [12, Theorem 7]). For an extreme —
Dedekind domain D with
C
but somewhat classical — example, the Dedekind domain

D = C[X, Y ]/(Y 2

X 3

−

X

−

−

1)

has class group isomorphic to C/Z2. However, as discussed in Section 2, the
rings of integers of global ﬁelds have ﬁnite class groups.

O

l
C

We let K be a number ﬁeld and let K ′ be a function ﬁeld, with ring of
OK ′ (we ﬁx a choice of a model Fq[t]), respectively. Most
integers
OK and
K available in a modern textbook (see [7, Theo-
proofs of the ﬁniteness of
rems 4.4, 5.3, 6.3]) depend on Minkowski’s lattice point theorem, a result from
the geometry of numbers (which has been formalized in Isabelle/HOL [13]).
l
OK′ is quite involved and does
Extending this proof to show the ﬁniteness of
C
OK′ . Our formalization instead
l
not result in a uniform proof for
C
K , where
adapted and generalized a classical approach to the ﬁniteness of
the use of Minkowski’s theorem is replaced by the pigeonhole principle. We
have made available online an informal writeup of the proof, used in the formal-
ization eﬀorts5. The classical approach seems to go back to Kronecker and can
be found, for instance, in [14]. We note that some other “uniform” approaches
can be found in [15] and [16].

K and

l
C

l
C

O

O

Let D be an Euclidean domain: in particular, it will be a PID and hence a
Dedekind domain. Given a fraction ﬁeld F of D, let K be a ﬁnite separable ﬁeld
extension of F . We formalized, in the theorem class group.fintype of -
admissible of finite, that the integral closure S of D in K has a ﬁnite
class group whenever D has an “admissible” absolute value abs. This notion
originated in our project from the adaptation and generalization of the classical
ﬁniteness proof in interaction with the formalization eﬀorts. Very informally,
the admissibility conditions require that the remainder operator % produces
values that are not too far apart. More precisely, and in more “ordinary”
mathematical notation, writing mod instead of % and x
for the absolute
value function D
→
• we have a function card : R>0 →

x
|
Z, the latter is called admissible if both:

7→ |

N;

5https://github.com/lean-forward/class-number-journal/blob/jar-reviews/FiniteClassGroup.

pdf

Springer Nature 2021 LATEX template

24

Dedekind domains and class groups

• for all ǫ

D
into at most card(ǫ) parts, such that all x, y

, and ﬁnite subsets A

R>0, b

− {

∈

∈

0

}

⊂

D, we can partition A

A in the same part satisfy

∈

x mod b

|

y mod b

< ǫ

b

.

|

|

|

−

To formalize this, we made minor modiﬁcations like turning card into a total
function on R and turning A into an n-tuple (noting that in this setting there
is no need to forbid repetition of elements within the n-tuple). This resulted
in the following predicate classifying admissible absolute values abv:

structure is_admissible (abv : absolute_value D Z) extends

is_euclidean abv :=

(card : R

N) (exists_partition’ :

→

(n : N) {ε : R} (hε : 0 < ε) {b : D} (hb : b
(t : fin n

fin (card ε)),

∀
(A : fin n

D),

= 0)

→
i0 i1, t i0 = t i1 →

∃

∀
(abv (A i1 % b - A i0 % b) : R) < abv b

→

ε)

·

The is euclidean abv predicate asserts that the absolute value abv : D → Z
respects the remainder operator of the Euclidean domain D, in particular abv
(a % b) < abv b.

7→ |

, applied in practice, is that for all ǫ

x
|
∈
Dn such that for all i = 1, . . . , n we have

The above condition formalizes and generalizes an intermediate result in
paper proofs of the ﬁniteness of the class group; the diﬀerent proofs for number
ﬁelds and function ﬁelds (still assuming K/F separable) become the same after
this point. The direct consequence (by the pigeonhole principle) of admissibil-
N,
ity of x
Dn containing more than card(ǫ)n elements, there exist dis-
and all subsets A
tinct x, y
.
b
|
We used division with remainder to replace the fractional part operator on F
in the classical proof, which was essential to incorporate function ﬁelds, and at
the same time allowed our proof to stay entirely within D to avoid coercions.
In a similar way to the algebra trace of Section 7.1, we deﬁned the norm of
an element x : S as the determinant of the linear map lmul x. We used the
admissibility of abs to ﬁnd a ﬁnite set finset approx of elements of D, such
that the following generalization of [14, Theorem 12.2.1] holds.

xi mod b

yi mod b

R>0, b

< ǫ

− {

, n

D

−

∈

∈

∈

∈

}

0

|

|

|

theorem exists_mem_finset_approx’ (a b : S) (hb : b
finset_approx),

(q : S) (r

= 0) :

∃
abv (algebra.norm D (r

∈

a - q * b)) < abv (algebra.norm D b)

·

Translated back into more “ordinary” mathematical notation, this theorem
tells us that, for all a, b
ﬁnset approx, such that

S with b nonzero, there exist q

S and r

∈

∈

∈

NormS/D(ra

|

qb)
|

−

<

NormS/D(b)
|

.

|

After this, the classical approach mentioned above formalized smoothly:
J, where M is

we show that each class in

lK contains an ideal J with M
C

∈

6
6
Springer Nature 2021 LATEX template

Dedekind domains and class groups

25

the product of all elements of finset approx, hence M is nonzero. Since the
ideals of the Dedekind domain S have unique factorization, the nonzero ideal
spanned by M has only ﬁnitely many divisors. To contain is to divide
M
h
in Dedekind domains, so there are only ﬁnitely many ideals J with M
J.
lK is ﬁnite under the condition of the existence of
Thus, we concluded that
C
an admissible absolute value on D.

∈

i

|

f

∈
Fq[t] and a set A′

|deg := qdeg f for f

It remained to deﬁne an admissible absolute value for Z and Fq[t]. On
Z, the usual Archimedean absolute value fulﬁlls the requirements by setting
card ǫ to be 1
ǫ , rounded up. Since remainders mod b can be chosen to lie in
the interval [0, b[, partitioning this interval into card ǫ intervals of length ǫb
induces the desired partition.
For Fq[t], we showed that
Fq[t] is an admissible
Fq[t] of remainders
absolute value. Fix a polynomial b
modulo b. Since the coeﬃcients of polynomials in Fq[t] are elements of a ﬁnite
set of cardinality q, and the degree of each f
A′ is strictly less than deg b, for
each c there are only qc distinct values for the c coeﬃcients of the monomials
A′
of degree deg b
c up to deg b
∈
−
|deg < qdeg b
g)
coincide, then
logq ǫ(cid:7)
|deg. By setting card ǫ = (cid:6)
−
−
−
ǫ, we can partition A′ into card ǫ subsets based on highest
so that q−
coeﬃcients, so that elements of each partition are within distance ǫ
|deg as
desired.
We concluded that when K is a global ﬁeld, restricting to separable exten-
sions of Fq(t) in the function ﬁeld case (but see the remark below), the class
group is ﬁnite:

1. If the highest coeﬃcients of f, g
c = q−

|
card ǫ

−
(f

≤

⊂

∈

∈

b

b

|

|

c

noncomputable instance : fintype

(class_group (number_field.ring_of_integers K) K) :=

class_group.fintype_of_admissible_of_finite Q K

absolute_value.abs_is_admissible

noncomputable instance : fintype

(class_group (function_field.ring_of_integers Fq F) F) :=

class_group.fintype_of_admissible_of_finite (ratfunc Fq) F

polynomial.card_pow_degree_is_admissible

Finally, we deﬁned number field.class number and function field.

class number as the cardinality of the respective class groups.

We remark that it is possible to get rid of the [is separable F K] assump-
tion above. For instance, using that any function ﬁeld K, given as ﬁnite
K such that K/Fq(s) is a ﬁnite and sep-
extension of Fq(t), contains an s
arable extension; see for example [17, Corollary 4.4 in Chapter VIII] (noting
that Fq is perfect and K has transcendence degree 1 over Fq). One then also
needs to show that the ﬁniteness of the class group of the integral closure of
Fq[s] in K is preserved upon replacing Fq[s] by Fq[t]. A trivial way to get rid
of the assumption in the statement above is to simply move it to our deﬁnition
of function ﬁeld. While this would be mathematically consistent by the result
just cited, we did not opt to do this (for instance showing a ﬁnite extension

∈

Springer Nature 2021 LATEX template

26

Dedekind domains and class groups

of a function ﬁeld is a function ﬁeld would become nontrivial). Alternatively,
one could aim at dropping the separability condition in the formalized result
mentioned in the ﬁrst paragraph of Section 7. Having a formalization of this
generalization would be interesting in its own right. This approach would
also still need the adaptation of some of the details in the ﬁnal steps for the
ﬁniteness of the class group in the admissible case.

We rounded oﬀ our development by determining the class number in
the simplest possible case: the rational numbers Q. First, we formalized the
theorem class number eq one iff, stating that the class number of K is 1
if and only if
OK is a principal ideal domain. After deﬁning the isomorphism
rat.ring of integers equiv showing
Q is Z, we could use the fact that Z
is a PID to conclude that the class number of Q is equal to 1:

O

theorem rat.class_number : number_field.class_number Q = 1 :=
class_number_eq_one_iff.mpr

(is_principal_ideal_ring.of_surjective _

rat.ring_of_integers_equiv.symm.surjective)

9 Discussion

9.1 Related work

Broadly speaking, one could see our formalization work as part of num-
ber theory. There are several formalization results in this direction. Most
notably, Eberl formalized a substantial part of analytic number theory in
Isabelle/HOL [18]. Narrowing somewhat to a more algebraic setting, Cano,
Cohen, D´en`es, M¨ortberg and Siles formalized in Coq constructive deﬁni-
tions in ring theory, with a particular focus on factorization properties and
with applications to algebraic notions like well-founded divisibility and Krull
dimension [19]. Moreover, de Lima, Galdino, Borges Avelar and Ayala-Rinc´on
recently formalized in PVS basic notions regarding ring theory, with a particu-
lar focus on quotients: isomorphism theorems, the Chinese remainder theorem
and the deﬁnitions of prime and maximal ideals [20]. We are not aware of
any other formal developments of fractional ideals, Dedekind domains or class
groups of rings of integers.

There are many libraries formalizing basic notions of commutative algebra
such as ﬁeld extensions and ideals, including the Mathematical Components
library in Coq [21], the algebraic library for Isabelle/HOL [22], the set.mm
database for MetaMath [23] and the Mizar Mathematical Library [24]. The
ﬁeld of algebraic numbers, or more generally algebraic closures of arbitrary
ﬁelds, are also available in many provers. For example, Blot [25] formalized
algebraic numbers in Coq, Cohen [26] constructed the subﬁeld of real algebraic
numbers in Coq, Thiemann, Yamada and Joosten [27] formalized algebraic
numbers in Isabelle/HOL, Carneiro [28] in MetaMath, and Watase [29] in
Mizar. To our knowledge, the Coq Mathematical Components library is the

Springer Nature 2021 LATEX template

Dedekind domains and class groups

27

only formal development beside ours speciﬁcally dealing with number ﬁelds [21,
field/algnum.v].

Apart from the general theory of algebraic numbers, there are formaliza-
tions of speciﬁc rings of integers. For instance, the Gaussian integers Z[i] have
been formalized in Isabelle/HOL by Eberl [30], in MetaMath by Carneiro [31]
and in Mizar by Futa, Mizushima, and Okazaki [32]. Eberl’s Isabelle/HOL
formalization deserves special mention in this context since it introduces tech-
niques from algebraic number theory, deﬁning the integer-valued norm on Z[i]
and classifying the prime elements of Z[i].

An application of our work is the formalization of the ad`elic ring of a
global ﬁeld in Lean (Mar´ıa In´es de Frutos-Fern´andez, [33]). In particular, the
author formalized adic valuations on Dedekind domains, and also proved a
correspondence between id`ele and ideal class groups. Our work on Dedekind
domains and class groups was an essential building block for this project.

Finally, since our project became available in the mathlib library, a team led
by Brasca has begun formalizing Fermat’s Last Theorem for regular primes.
Fermat’s Last Theorem is the assertion that, for all integers n

3,

≥

x, y, z

∀

Z,

∈

xn + yn = zn =

⇒

x

y

·

·

z = 0.

(FLTn)

It is immediate to see that, for positive integers n and m, if n divides m, then
the validity of (FLTn) implies that of (FLTm). Therefore, also taking into
account that (FLT4) was already dealt with by Fermat himself, it suﬃces to
only consider exponents that are odd prime numbers.

Now, an odd prime number p is said to be regular if it does not divide the
lQ(ζp) of the number ﬁeld obtained by adjoining to Q
C
= 1 or,

order of the class group
a primitive pth root of unity ζp; the latter means that ζp
equivalently, that ζp is a root of the irreducible polynomial

p = 1 and ζp 6

X p
X

1
−
1
−

= X p

−

1 + X p

−

2 +

+ X + 1.

· · ·

A classical result, due to Kummer’s work in 1847, is that (FLTp) is true for
every regular prime number p. This is the result Brasca and his team have
begun formalizing in Lean 3 in the on-going work [34], and it evidently requires
the ﬁniteness of the class group in order to deﬁne the notion of a regular prime
as above6. Moreover, most arguments occurring in Kummer’s proof pertain to
the structure of the ring of integers Z[ζp] =
Q(ζp) as a Dedekind domain, and
our work lies at the core of the formalization of these structures.

O

6It is actually possible to simply deﬁne a regular prime only in terms of divisibility of some
Bernoulli numbers, instead of mentioning class groups. But this deﬁnition would at any rate need
to be translated in terms of class numbers in order to implement Kummer’s proof.

Springer Nature 2021 LATEX template

28

Dedekind domains and class groups

9.2 Future directions

Having formalized various basic results of algebraic number theory, there are
several natural directions for future work, including formalizing some of the
following results.

• The group of units of the ring of integers

×K has rank r + s

×K in a number ﬁeld K is ﬁnitely
generated, or even Dirichlet’s unit theorem [7, Theorem 7.4], stating that
1 and that its torsion subgroup is the cyclic group of
O
roots of unity in K. Here r denotes the number of real embeddings of K
and s the number of conjugate pairs of complex non-real embeddings of K.
The ﬁnite generation result also holds in function ﬁelds, again with a precise
description of the rank and of the torsion.

O

−

• Other ﬁniteness results in algebraic number theory, most notably Hermite’s
theorem about the existence of ﬁnitely many number ﬁelds, up to isomor-
phism, with bounded discriminant [7, Theorem 2.16]. While this could be
done without interpreting the primes dividing the discriminant as the primes
that ramify in the number ﬁeld, it would certainly be interesting to set up
some basic ramiﬁcation theory: on the one hand, this would also prove essen-
tial for many other developments and, on the other, it would allow to prove
a version of Hermite’s theorem stating that, up to isomorphism, there are
only ﬁnitely many number ﬁelds with bounded degree and restricted rami-
ﬁcation. As usual, there are analogous results in the function ﬁeld setting,
though they are less straightforward. One reason for this is that the nonde-
generacy of the trace form from Section 7.1 does not hold any more when
the separability condition is dropped.

• Class number computations, starting with, say, quadratic number ﬁelds.
This could be a step towards the veriﬁcation of correctness of number-
theoretic software, such as KASH/KANT [35] and PARI/GP [36]. Along the
same lines, unit group computations would also be of much interest, most
1 generators for the free part
notably the explicit computation of r + s
of
×K. Restricting to quadratic ﬁelds, we see that the rank is positive (and
equal to 1) if and only if the ﬁeld is of the shape Q(√d) for some positive
integer d that is not a square. Finding a generator can be done by using
continued fractions, of which the basics are already implemented in Lean by
Kevin Kappelmann, though certifying that a given (perhaps externally com-
puted) element is indeed a generator could also be done without continued
fractions.

O

−

• Applications of algebraic number theory to solving Diophantine equations,
such as determining all pairs of integers (x, y) such that y2 = x3 + D for
Z. It would be interesting to deal with some values of D
some nonzero D
where no elementary techniques are available and where factorization in the
ring of integers of Q(√D), along with information about the class number,
could solve the equation.

∈

Springer Nature 2021 LATEX template

Dedekind domains and class groups

29

9.3 Conclusion

In this project, we conﬁrmed the rule that the hardest part of formalization is
to get the deﬁnitions right. Once this is accomplished, the paper proof (some-
times ﬁrst adapted with formalization in mind) almost always translates into a
formal proof without too much eﬀort. In particular, we regularly had to invent
abstractions to treat instances of the “same” situation uniformly. Instead of
ﬁxing a canonical representation, be it F
L as subﬁelds or the ﬁeld of
fractions Frac R, or the monogenic K(α), we found that making the essence of
the situation an explicit parameter, as in is scalar tower, is fraction ring
or power basis, allows to treat equivalent viewpoints uniformly without the
need for transferring results.

K

⊆

⊆

The formalization eﬀorts described in this paper cannot be cleanly sep-
arated from the development of mathlib as a whole. The decentralized
organization and highly integrated design of mathlib meant that we could
contribute our formalizations as we completed them, resulting in a quick inte-
gration into the rest of the library. Other contributors building on these results
often extended them to meet our requirements, before we could identify that
we needed them, as the anecdote in Section 4.4 illustrates. In other words, the
low barriers for contributions ensured mutually beneﬁcial collaboration.

Quantifying the ratio between the length of our formal proofs and their
paper counterparts in an accurate and meaningful way will be very diﬃcult as
background assumptions and levels of detail varied signiﬁcantly. We actually
did not always literally follow some written text, but deviated from the paper
mathematics (often discussed orally, on blackboards, through Zulip, etc.) on
many occasions. An important aspect we had to take into account was to con-
sistently combine diﬀerent descriptions of mathematical objects from diﬀerent
sources. The formalization project described in this paper resulted in the con-
tribution of thousands of lines of Lean code involving hundreds of declarations.
A rough estimate concerning the former would be that about ﬁve thousand
lines of project speciﬁc code were added, and about half of that number of
lines of more generic background code. We validated existing design choices
used in mathlib, refactored those that did not scale well and contributed our
own set of designs. The real achievement was not to complete each proof, but
to build a better foundation for formal mathematics.

Acknowledgements. We would like to thank Jasmin Blanchette and
the anonymous reviewers for useful comments on previous versions of the
manuscript, which found their way into this paper.
A. N. would like to thank Prof. Kevin Buzzard for his constant support and
encouragement, and for introducing her to the other co-authors.
A. N. and F. N. wish to express their deepest gratitude to Anne Baanen for
the generosity shown along all stages of the project. Without Anne’s never-
ending patience, it would have been impossible for them to contribute to this
project, and to overcome several diﬃculties.

Springer Nature 2021 LATEX template

30

Dedekind domains and class groups

Finally, we would like to thank the whole mathlib community for invaluable
advice all along the project.

Declarations.

Funding

Anne Baanen was funded by NWO Vidi grant No. 016.Vidi.189.037, Lean
Forward.
Sander R. Dahmen was funded by NWO Vidi grant No. 639.032.613, New
Diophantine Directions.
Ashvni Narayanan was funded by EPSRC Grant EP/S021590/1 (UK).

Conﬂicts of interest

The authors have no conﬂicts of interest to declare that are relevant to the
content of this article.

Availability of data and material
See Code availability.

Code availability
Full source code of the formalization is maintained as part of mathlib, https://
github.com/leanprover-community/mathlib. Copies of the source ﬁles relevant
to this paper are available in a separate repository at https://github.com/
lean-forward/class-number-journal.

Authors’ contributions

All authors contributed to the formalization project as well as to the extended
version. All authors commented on previous versions of the manuscript.

References

[1] The mathlib Community: The Lean mathematical library. In: Blanchette,
J., Hrit,cu, C. (eds.) CPP 2020, pp. 367–381. ACM, New York, USA
(2020). https://doi.org/10.1145/3372885.3373824

[2] de Moura, L., Kong, S., Avigad, J., van Doorn, F., von Raumer, J.: The
Lean theorem prover (system description). In: Felty, A.P., Middeldorp, A.
(eds.) Automated Deduction - CADE-25. LNCS, vol. 9195, pp. 378–388.
Springer, Cham (2015). https://doi.org/10.1007/978-3-319-21401-6 26

[3] Baanen, T., Dahmen, S.R., Ashvni N., Nuccio Mortarino Majno di
Capriglio, F.A.E.: A Formalization of Dedekind Domains and Class
Groups of Global Fields. In: Cohen, L., Kaliszyk, C. (eds.) ITP 2021.
LIPIcs, vol. 193, pp. 5–1519. Schloss Dagstuhl – Leibniz-Zentrum f¨ur
Informatik, Dagstuhl, Germany (2021). https://doi.org/10.4230/LIPIcs.
ITP.2021.5. https://drops.dagstuhl.de/opus/volltexte/2021/13900

Springer Nature 2021 LATEX template

Dedekind domains and class groups

31

[4] Wadler, P., Blott, S.: How to make ad-hoc polymorphism less ad hoc.
In: Principles of Programming Languages. POPL ’89, pp. 60–76. ACM,
Austin, TX, USA (1989). https://doi.org/10.1145/75277.75283

[5] Avigad, J., de Moura, L., Kong, S.: Theorem Proving in Lean. Carnegie
Mellon University, Pittsburgh, PA, USA (2021). Release 3.23.0, https://
leanprover.github.io/theorem proving in lean/

[6] Baanen, T.: Use and abuse of instance parameters in the Lean mathe-
matical library. CoRR abs/2202.01629 (2022) 2202.01629. Accepted for
publication at ITP 2022, Haifa, Israel.

[7] Neukirch, J.: Algebraic Number Theory. Fundamental Principles of Math-
ematical Sciences, vol. 322, p. 571. Springer, Cham (1999). https://doi.
org/10.1007/978-3-662-03983-0. Translated from the 1992 German orig-
inal and with a note by Norbert Schappacher, With a foreword by G.
Harder

[8] Fr¨ohlich, A.: Local ﬁelds. In: Algebraic Number Theory (Proc. Instruc-
tional Conf., Brighton, 1965), pp. 1–41. Thompson, Washington, D.C.
(1967)

[9] Lewis, R.Y., Madelaine, P.: Simplifying casts and coercions (extended
abstract). In: Fontaine, P., Korovin, K., Kotsireas, I.S., R¨ummer, P.,
Tourret, S. (eds.) Practical Aspects of Automated Reasoning. CEUR
Workshop Proceedings, vol. 2752, pp. 53–62. CEUR-WS.org, Aachen,
Germany (2020). http://ceur-ws.org/Vol-2752/paper4.pdf

[10] Zariski, O., Samuel, P.: Commutative Algebra, Volume I. The University
Series in Higher Mathematics, p. 329. D. Van Nostrand Company, Inc.,
Princeton, NJ, USA (1958)

[11] Dummit, D.S., Foote, R.M.: Abstract Algebra, 3rd edn., p. 932. John

Wiley & Sons, Inc., Hoboken, NJ, USA (2004)

[12] Claborn, L.: Every abelian group is a class group. Paciﬁc Journal of
Mathematics 18(2), 219–222 (1966). https://doi.org/pjm/1102994263

[13] Eberl, M.: Minkowski’s theorem. Archive of Formal Proofs (2017).
proof

https://isa-afp.org/entries/Minkowskis Theorem.html, Formal
development

[14] Ireland, K., Roosen, M.: A Classical Introduction to Modern Number

Theory, 2nd edn. Springer, Cham (1990)

[15] Artin, E., Whaples, G.: Axiomatic characterization of ﬁelds by the
product formula for valuations. Bull. Amer. Math. Soc. 51(7), 469–492

Springer Nature 2021 LATEX template

32

Dedekind domains and class groups

(1945)

[16] Stasinski, A.: A uniform proof of the ﬁniteness of the class group of a
global ﬁeld. Amer. Math. Monthly 128(3), 239–249 (2021). https://doi.
org/10.1080/00029890.2021.1855036

[17] Lang, S.: Algebra, 3rd edn. Graduate Texts in Mathematics, vol. 211, p.
914. Springer, Cham (2002). https://doi.org/10.1007/978-1-4613-0041-0.
https://doi.org/10.1007/978-1-4613-0041-0

[18] Eberl, M.: Nine chapters of analytic number theory in Isabelle/HOL.
In: Harrison, J., O’Leary, J., Tolmach, A. (eds.) ITP 2019. LIPIcs, vol.
141, pp. 16–11619. Schloss Dagstuhl – Leibniz-Zentrum f¨ur Informatik,
Dagstuhl, Germany (2019). https://doi.org/10.4230/LIPIcs.ITP.2019.16

[19] Cano, G., Cohen, C., D´en`es, M., M¨ortberg, A., Siles, V.: Formalized
linear algebra over elementary divisor rings in Coq. Logical Methods
in Computer Science 12(2) (2016). https://doi.org/10.2168/LMCS-12(2:
7)2016

[20] de Lima, T.A., Galdino, A.L., Avelar, A.B., Ayala-Rinc´on, M.: Formaliza-
tion of ring theory in PVS: isomorphism theorems, principal, prime and
maximal ideals, Chinese remainder theorem. J. Automat. Reason. 65(8),
1231–1263 (2021). https://doi.org/10.1007/s10817-021-09593-0

[21] Mahboubi, A., Tassi, E.: The Mathematical Components Libraries.
Zenodo, Gen`eve, Switzerland (2017). https://doi.org/10.5281/zenodo.
4457887

[22] Ballarin (editor), C., Aransay, J., Baillon, M., de Vilhena, P.E., Hohe, S.,
Kamm¨uller, F., Paulson, L.C.: The Isabelle/HOL Algebra Library. http://
isabelle.in.tum.de/dist/library/HOL/HOL-Algebra/index.html

[23] Megill, N.D., Wheeler, D.A.: Metamath: A Computer Language for Math-
ematical Proofs. Lulu Press, Morrisville, NC, USA (2019). http://us.
metamath.org/downloads/metamath.pdf

[24] Grabowski, A., Kornilowicz, A., Schwarzweller, C.: On algebraic hierar-
chies in mathematical repository of Mizar. In: Ganzha, M., Maciaszek,
L., Paprzycki, M. (eds.) Proceedings of the 2016 Federated Conference on
Computer Science and Information Systems. ACSIS, vol. 8, pp. 363–371
(2016)

[25] Blot, V.: Basics for algebraic numbers and a proof of Liouville’s theorem

in C-CoRN. MSc internship report (2009)

[26] Cohen, C.: Construction of real algebraic numbers in Coq. In: Beringer,

Springer Nature 2021 LATEX template

Dedekind domains and class groups

33

L., Felty, A.P. (eds.) ITP 2012. Lecture Notes in Computer Science, vol.
7406, pp. 67–82. Springer, Cham (2012). https://doi.org/10.1007/978-3-
642-32347-8 6

[27] Thiemann, R., Yamada, A., Joosten, S.: Algebraic numbers

in
Isabelle/HOL. Archive of Formal Proofs (2015). https://isa-afp.org/
entries/Algebraic Numbers.html, Formal proof development

[28] Carneiro, M.: Deﬁnition df-aa. http://us.metamath.org/mpeuni/df-aa.

html

[29] Watase, Y.: Algebraic numbers. Formalized Mathematics 24(4), 291–299

(2016). https://doi.org/10.1515/forma-2016-0025

[30] Eberl, M.: Gaussian integers. Archive of Formal Proofs (2020). https://
isa-afp.org/entries/Gaussian Integers.html, Formal proof development

[31] Carneiro, M.: Deﬁnition df-gz. http://us.metamath.org/mpeuni/df-gz.

html

[32] Futa, Y., Mizushima, D., Okazaki, H.: Formalization of Gaussian inte-
gers, Gaussian rational numbers, and their algebraic structures with
Mizar. In: 2012 International Symposium on Information Theory and Its
Applications, pp. 591–595 (2012)

[33] de Frutos-Fern´andez, M.I.: Formalizing the Ring of Ad`eles of a
Global Field. arXiv (2022). https://doi.org/10.48550/ARXIV.2203.16344.
https://arxiv.org/abs/2203.16344

[34] Brasca, R., et al.: The ring of integers of a cyclotomic ﬁeld. https://
leanprover-community.github.io/blog/posts/the-ring-of-integers-of-a-
cyclotomic-ﬁeld/. Accessed 2022-06-20.

[35] Pohst, M.E., et al.: The Computer Algebra System KASH/KANT. http://

www.math.tu-berlin.de/∼kant

[36] The PARI Group: PARI/GP Version 2.11.2. Univ. Bordeaux (2019). The

PARI Group. http://pari.math.u-bordeaux.fr/

