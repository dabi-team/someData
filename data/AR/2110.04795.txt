2
2
0
2

r
p
A
7
1

]

R
C
.
s
c
[

2
v
5
9
7
4
0
.
0
1
1
2
:
v
i
X
r
a

Group Signatures and Accountable Ring
Signatures from Isogeny-based Assumptions

Kai-Min Chung1, Yao-Ching Hsieh1, Mi-Ying (Miryam) Huang2,
Yu-Hsuan Huang1,3, Tanja Lange4, and Bo-Yin Yang1

1 Academia Sinica, Taiwan
2 University of Southern California, United States
3 Centrum Wiskunde & Informatica, The Netherlands
4 Eindhoven University of Technology, The Netherlands
kmchung@iis.sinica.edu.tw, ychsieh@ntu.edu.tw, miying.huang@usc.edu,
Yu-Hsuan.Huang@cwi.nl, byyang@iis.sinica.edu.tw, tanja@hyperelliptic.org

Abstract. Group signatures are an important cryptographic primitive
providing both anonymity and accountability to signatures. Accountable
ring signatures (ARS) combine features from ring signatures (RS) and
group signatures (GS), and can be directly transformed into either of
both. While there exist extensive works on constructing GS from vari-
ous post-quantum assumptions, there has not been any research using
isogeny-based assumptions. In this work, we propose the ﬁrst isogeny-
based GS, which is a direct result of our isogeny-based ARS. Our schemes
are based on the decisional CSIDH assumption (D-CSIDH) and are
proven secure under the quantum random oracle model (QROM). This
work is also the ﬁrst post-quantum ARS and GS that are proven QROM-
secure.

1

Introduction

Group signatures. Group signatures (GS), ﬁrst proposed by Chaum and van
Heyst [15], are signature schemes that permit signing by a group, a set of players
chosen by a prescribed group manager. Each of the players can generate publicly
veriﬁable signatures on behalf of the group while keeping itself anonymous to
everyone except the group manager. The group manager has the authority to
open, i.e. to reveal the signer’s identity from a signature with its master secret
key.

Since their proposal, there have been numerous works devoted to group signa-
tures. Many of them aimed to give reﬁnements and extensions to the primitive.
Some of these extensions, such as separating the opening authority from the

Author list in alphabetical order; see https://www.ams.org/profession/leaders/culture/CultureStatement04.pdf.
Date: 2021.10.10.

 
 
 
 
 
 
manager [3,12], or additionally requiring a “Judge” functionality to verify open-
ing results [3], are widely adopted in the formulation for many succeeding works.
Nevertheless, in this work, we will focus on the formulation which contains only
fundamental components of a group signature.

Accountable ring signatures. An important line of research on group signa-
tures studies variants with dynamic groups. In contrast to the original formula-
tion where only static groups are supported [2, 15], a dynamic group signature
allows a group to be updated after the setup stage. The notion of partially dy-
namic group signatures was formulated by Bellare, Shi, and Zhang [3] and
Kiayias and Yung [25], where parties can join a group but cannot be removed.
There are also many works that achieve group signatures with removal of group
members, as early as [10, 39].

Accountable ring signatures (ARS), ﬁrst proposed by Xu and Yung [42], pro-
vides the “dynamic property for groups” in a diﬀerent aspect. ARS, while having
a “ring signature” [37] within its name, can also be viewed as a variant of group
signatures where groups are fully dynamic but not authenticated. In an ARS
scheme, the manager no longer has any control over the group. Instead, a signer
can freely decide which master public key to use and which group to sign for,
and its identity can then be opened by the corresponding master secret key.
Though seemingly incomparable to a standard group signature, an ARS scheme
can in fact trivially imply a group signature scheme, simply by ﬁxing the group
at the setup stage. Later, Bootle, Cerulli, Chaidos, Ghadaﬁ, Groth, and Petit [9]
proposed a stringent formulation for ARS, along with a provable construction
based on the DDH assumption. It is further shown in [8] that such a stringent
ARS scheme can be generally transformed to a fully dynamic group signature
scheme.

Group signatures from post-quantum assumptions. In the past decade,
there has been increasing attention on the importance of post-quantum secu-
rity for cryptographic primitives. Various attempts emerged to construct group
signatures based on cryptographic assumptions that resist quantum attacks.
Gordon, Katz, and Vaikuntanathan ﬁrst gave a group signature construction
from lattice-based assumptions [23]. This was followed by several constructions
of lattice-based group signatures, either for static groups [28, 34] or dynamic
groups [31, 32]. There have also been a few attempts on constructing group sig-
natures from other classes of post-quantum assumptions, such as code-based
assumptions [20] or hash-based assumptions [1]. However, to the best of our
knowledge, none of these are from isogeny-based assumptions, which is the main
focus of this work.

We also note that current constructions of accountable ring signatures are
based on either pre-quantum assumptions (DDH [9], q-SDH [29]) or primitives
in the absence of post-quantum constructions (i

[27]).

Our results. As a main result, we construct accountable ring signatures from
isogeny-based assumptions in the quantum random oracle model (QROM). More-
over, since they can be easily transformed into group signatures and ring signa-

O

2

tures5 (RS) while preserving its QROM securities, we achieve various milestones
listed below.

– In terms of ARS and GS, this is the ﬁrst isogeny-based and the ﬁrst QROM-

secure proposal.6

– In terms of RS, this is the ﬁrst isogeny-based proposal proven QROM-secure.

On top of it, we propose the notion of openable sigma protocol, which is an inter-
mediate primitive for constructing ARS. Such primitive is simple yet ﬁt well with
the Fiat-Shamir methodology. A (secure) openable sigma protocol give rise to
ARS when Fiat-Shamir transformed. Furthermore, we show that typical (addi-
tional) requirement for a QROM-secure signature, the unique response property,
suﬃces to provide a QROM-secure ARS.

We base our construction on the decisional CSIDH assumption (D-CSIDH).
From an abstract viewpoint, D-CSIDH is a natural generalization of DDH which
is built over the weaker group-action structure.

Due to the lack of the homomorphic property in group-action assumptions,
it is usually infeasible to transform results obtained from group-based assump-
tions to those from group-action-based assumptions. Our work demonstrates the
possibility of constructing advanced cryptographic primitives with group-action-
based assumptions, despite its limited properties.

Our construction of ARS does not satisfy some of the (too) stringent deﬁni-
tions, such as that provided in [9]. Nevertheless, our construction already suﬃces
to imply a group signature, with fully dynamic control over the group members.
Therefore, we believe our work would be a meaningful starting point for the
study of advanced isogeny-based signatures.

Concurrent works. Independent and concurrent to our work, [4,30] also man-
aged to construct isogeny-based group signatures, with the former based on
the accountable ring signatures as we do, and the latter based on the so-called
collusion-resistant revocable ring signatures.

Indeed, updated soon after, we have achieved the QROM security, whereas
neither of [4,30] do. Since the queried random function models a cryptographic
hash function, an adversary could then build its quantum circuit with the addi-
tional power to make the queries in superposition. This justiﬁes QROM securities
to be more desirable compared to their classical counterpart. Below listed what
has been achieved qualitatively between our works and a previous relevant work
that is also in the scope of advanced isogeny-based signatures.

5 ARS⇒RS is trivial, by throwing away the opening functionality.
6 To the best of our knowledge, relevant post-quantum proposals for ARS/GS only

claim their security in the classical random oracle model.

3

Table 1: Milestones of Isogeny-based Advanced Signatures

QROM security Functionality

[5]
×
Our work X
[4]
[30]

×
×

RS
ARS + RS + GS
ARS + GS
CR-RRS + GS

Timeline
previous

concurrent
concurrent

1.1 Technical overview

In this overview, we assume some familiarity for sigma protocols and the Fiat-
Shamir transformation [22].

Signatures based on isogeny class group action. Stolbunov [40] gave a
ﬁrst attempt toward an isogeny-based signature scheme in his thesis. His scheme
applies the Fiat-Shamir transformation [22] to the sigma protocol of Couveignes
[16]. While Couveignes’ protocol is structurally similar to the discrete log based
protocol by Chaum and van Heyst [15], its challenge space cannot be extended
as in Schnorr’s protocol [38]. Parallel repetition is thus necessary for Stolbunov’s
signature scheme.

∈

O

O

O

Cl(

) and secret s

Later, following the proposal of an eﬃcient class group action implementation
by CSIDH [13], SeaSign [21] and CSI-FiSh [6] separately gave eﬃcient signature
constructions based on Stolbunov’s approach. One main contribution of their
works is that they overcome the lack of canonical representation for elements
in the class group Cl(
). In Stolbunuov’s scheme, the signer would reveal rs
for r $
Cl(
). However, since r and s are represented
←−
as element wise bounded vectors in the CSIDH representation, a naive repre-
sentation for rs does not hide the information of s. To cope with this issue,
SeaSign proposed a solution using the Fiat-Shamir with abort technique [33],
while CSI-FiSh computes the whole class group structure and its relation lattice
for a speciﬁc parameter set, CSIDH-512. In this work, we will adopt the latter
approach, where we can simply assume canonical representation for elements in
Cl(

O
Recently, Beullens, Katsumata, and Pintore [5] showed how to construct
an isogeny-based ring signature with the sigma protocol for an OR-relation.
Our work similarly starts with a sigma protocol which additionally supports an
opening operation. We want a sigma protocol that takes n statements and a
master public key as inputs, computes a proof for one of the statements and
embeds the “identity” of the proved statement into the transcript so that it can
be extracted with the master secret key. As the ﬁrst step, we will discuss how
we can embed information for opening into the transcript.

).

Embedding opening information. In a group signature scheme, the informa-
tion for the signer’s identity must be somehow embedded into the signature, so
that the master can open it. One natural approach to embed opening informa-

4

tion is to encrypt the information with the master public key. Such an approach
is proven successful in a few previous works on group signatures [7, 9]. However,
since the opening information is now a ciphertext under the master key, a veri-
ﬁer can only check the validity of the ciphertext via homomorphic operations or
NIZK. Unfortunately, unlike group-based assumptions, it is not yet known how
to achieve such homomorphic property from the weaker group action structure
given by isogeny-based assumptions. There is also no isogeny-based NIZK con-
struction in the literature. Thus, we will have to come up with a structurally
simpler way to encode our opening information.

In light of this, we construct our opening functionality in a very naive way.
For a signature with group/ring size n and a master secret key sm for opening,
we embed the signer identity by one DDH tuple and n
1 dummies. Namely,
the opening information is in the form

−

τ = ((r1E, r2E, . . . , rnE), rkEm), where r1, . . . , rn

$
←−

G and Em = smE ,

which embeds the signer’s identity k
[n] through position, and is extractable
for the manager holding sm. Note that such τ keeps all its elements in the form
of curves/set elements, hence the veriﬁer can do further group action on τ for
consistency checking. This circumvents the previous diﬃculty, but with the cost
of a larger payload.

∈

Openable sigma protocol. To construct a group signature/accountable ring
signature scheme through Fiat-Shamir transformation, we ﬁrst introduce an in-
termediate primitive called openable sigma protocol. We refer the reader to
Section 3 for more details.

The formulation of the openable sigma protocol looks similar to the standard
OR sigma protocol. They both take n statements and one witness as input.
However, there is a major diﬀerence between them. The OR sigma protocol is
a proof of knowledge for the OR-relation. The openable sigma protocol, on the
other hand, is a proof of knowledge for the relation of the kth statement, where
k is chosen at the proving stage and embedded in the ﬁrst message com, and can
then be extracted by the master secret key sm.

For our openable sigma protocol, the special soundness would thus require an
extractor that extracts the kth witness which matches the opening result. Such
a stronger extractor is crucial for proving unforgeability for group signatures, in
which we transform a forger for party k into the extractor for the kth witness.
Extractors for standard OR sigma protocols cannot provide such reduction.

Also, unlike an OR sigma protocol, an openable sigma protocol cannot get
anonymity directly from the HVZK property, as the proving statement is now
embedded in com. To achieve anonymity, we need an extra property computa-
tional witness indistinguishability (CWI) which states that, for an honest master
key pair (mpk, msk), the proof for the k1th statement is indistinguishable from
the proof for the k2th statement. This promises that when transformed to signa-
tures, the signer would be anonymous as long as the manager has not colluded.

5

The construction of our openable sigma protocol is built on top of the pre-
vious identity embedding component. For statements E1 . . . , En along with the
kth witness sk s.t. Ek = skE and the master key pair (sm, Em = smE), the
opening information in our protocol is set to

τ = (Eβ , EOpen) = ((r1E1, r2E2, . . . , rnEn), rkskEm), r1, . . . , rn

$
←−

G

As argued earlier, the manager can extract k from τ with sm. To complete a
proof of knowledge protocol, we use two challenges (ch = 1, 2) to extract the
knowledge of each ri, and use another two challenges (ch = 3, 4) to extract
Eβ and dEm = EOpen.” This gives us a four challenge
“some d = rksk s.t. dE
openable sigma protocol with a corresponding special soundness property. We
detail the full construction and the security proof in Section 3.

∈

Rewinding, reprogramming, and Fiat-Shamir transformation. From a
series of parallel repetitions of sigma protocols with multi-special soundness, hash
functions are queried in order to decide the next challenges. This transforms an
interactive protocol to an non-interactive one. In order to argue the soundness
of such non-interactive protocol, various techniques are adopted. Classically, by
using the improved forking lemma, such an adversary breaking non-interactive
soundness could be rewound multiple times, in order to collect multiple outputs
and extract a secret from it. In the quantum setting, each-time measuring an
output corrupts the internal state potentially, and would require a diﬀerent set
of techniques. A recently developed technique measure-and-reprogram [17] gives
a non-trivial reduction from non-interactive soundness to the interactive ones.
Then, by means of generalized Unruh’s rewinding, one can again rewind the in-
teractive adversary and use it to extract a secret. In the non-interactive setting,
the transcripts from both are mostly the same, with the challenge sampled diﬀer-
ently. With the hash input being “random enough,” a recent technique adaptive
reprogramming [24] help one shows indistinguishability between these scenarios.

From our 4-challenge sigma protocol with opening property, we immediately
obtain an identiﬁcation scheme with a soundness error 3
4 . It may be tempting to
claim that we can achieve soundness ( 3
4 )λ through a λ repetition. Unfortunately,
this is not the case because each parallel session can be independently generated
with a diﬀerent witness, and some of the witnesses might be validly owned by
the adversary. As a concrete example, in a λ-parallel protocol, an adversary
that owns 3 keys can generate λ/4
1 honest parallel sessions on behalf of each
key, and then cheat on only λ/4 + 3 sessions to achieve a successful forgery. The
succeeding probability is ( 3
4 )λ. Thus, for an adversary owning
1) + 1 = O(nAλ) repetition to ensure that,
nA keys, we would need t = nA(λ
any adversary that wishes to successfully prove for an honest identity would
need to cheat on at least λ parallel sessions, and the success probability is thus
at most ( 3

−
4 )λ/4+3 instead of ( 3
−

4 )λ.

With an identiﬁcation scheme with a negligible soundness error, we can now
apply the Fiat-Shamir transformation and obtain a signature scheme. With the

6

improved forking lemma [11] detailed in Section 2.4, a forging adversary A that
can with non-negligible probability generate accepting tuples of (com, ch, resp)
would imply an algorithm B that generates 4 accepting tuples with identical
com and distinct ch. Note that as we are applying the forking lemma on a t-
parallel protocol, obtaining 4 distinct challenges does not immediately imply
extraction. For instance, the forking lemma may output 4 distinct vectors of
length t, while on every position i
[t] the four vectors are not completely
distinct, resulting in an extraction fail on every parallel session. Nevertheless,
we can easily show that, under polynomial many rewinds on the random oracle,
the probability of the existence of such “bad” vector tuples among all queries
is negligible. Thus, we can successfully extract witnesses with non-negligible
probability, which immediately implies unforgeability.

∈

2 Preliminary

2.1 Isogeny and class group action

E

O

O

At the bottom level of our construction is the so-called isogeny class group action,
which considers a commutative class group Cl(
) acting on the set of supersin-
, πp) up to Fp isomorphisms. The group action is free
gular elliptic curves
ℓℓp(
)
and transitive: for every E1, E2 ∈ E
O
aE1. For the use of cryptography, we note that computing the
such that E2 ∼=Fp
action is eﬃcient, while extracting a from the end-point curves is considered in-
tractable. This introduces a hard-to-compute relation, while regarding the curves
as public keys, and the group element a as secret. Note that validating the public
key is eﬃcient because it is eﬃcient to validate the supersingularity of a curve.
We refer readers to Appendix C for a guided walk through.

, πp), there is exactly one a

ℓℓp(

Cl(

O

∈

Hardness assumptions. Hardness for the group action inverse problem (GAIP)
in Deﬁnition 1 is commonly assumed for the above-mentioned group action,
which has been shown useful on constructing signature schemes such as CSI-
FiSh [6] and SeaSign [21].

Deﬁnition 1 (Group Action Inverse Problem (GAIP)). On inputs E1, E2 ∈
ℓℓp(
E

) such that E2 ∼=Fp

, πp), ﬁnd a

E1.

Cl(

O

O

∈

a

·

In this work, we need to assume hardness for a weaker problem, the deci-
sional CSIDH problem (abbreviated as D-CSIDH7) in Deﬁnition 2, which was
considered already in [16, 40], and is the natural generalization of the decisional
Diﬃe-Hellman problem for group actions.

Deﬁnition 2 (Decisional CSIDH (D-CSIDH) / DDHAP). For E

, πp), distinguish the two distributions

ℓℓp(
E
7 This problem is called the decisional Diﬃe-Hellman group action problem (DDHAP)

O

∈

in [40].

7

– (E, aE, bE, cE), where a, b, c $
←−
– (E, aE, bE, abE), where a, b $
←−

Cl(
Cl(

O

),

).

O

1 . . . len

We note that for typical cryptographic constructions such as CSIDH, addi-
tional heuristic assumptions are required to sample a random element from the
class group (as in Deﬁnition 2). This is because the “CSIDH-way” for doing this
bi, and the resulting
is by sampling exponents (e1, . . . , en) satisfying
distribution for ideals le1
). To get
rid of such heuristics, one could instead work with speciﬁc parameters, where a
bijective (yet eﬃcient) representation of ideals is known. For instance, in [6], the
) is computed, including a full generating set of ideals l1, . . . , ln
structure of Cl(
and the entire lattice Λ :=
. Evaluating the group
action is just a matter of approximating a closest vector and then evaluating
the residue as in CSIDH. In this work, we will be working with such a “perfect”
representation of ideals, unless otherwise speciﬁed.

∀
n is generally non-uniform within Cl(

(e1, . . . , en)
|

le1
1 . . . len

n = id

ei| ≤

i :

O

O

{

}

|

As a remark, we note that the D-CSIDH problem for characteristic p = 1
mod 4 is known to be broken [14]. Nevertheless, the attack is not applicable to
the standard CSIDH setting where p = 3 mod 4.

2.2 Group action DDH

In this section, we give an abstract version of the CSIDH group action. Such
formulation will simplify our further construction and security proof.

A commutative group action

Eλ) with security parameter λ (we
GAλ = (Gλ,
will omit the subscripts for simplicity) is called a DDH-secure group action if
the following holds:

– G acts freely and transitively on
– DDHAP is hard on

.

E

advantage for A distinguishing the following two distributions is negl(λ).

GAλ. i.e., for any eﬃcient adversary A and E

∈ E

, the

(E, aE, bE, cE), a, b, c $
←−
(E, aE, bE, abE), a, b $
←−

G

G

•

•

As a side remark, the GAIP problem is also hard on a DDH-secure group action.

For a DDH-secure group action, we can also have a natural parallel extension

for DDHAP. Such extension is also discussed in [19].

Deﬁnition 3 (Parallelized-DDHAP (P-DDHAP)). Given E
guish the two distributions

∈ E

, distin-

– (aE,

– (aE,

biE

biE

}i∈[m],
}i∈[m],

{

{

{

{

ciE

abiE

}i∈[m]), where a,
{
}i∈[m]), where a,

bi}i∈[m],
{
bi}i∈[m]
{

ci}i∈[m]
$
G.
←−

$
←−

G,

8

By a simple hybrid argument, we can easily see that if DDHAP is ǫ-hard,
then P-DDHAP is mǫ hard. To see this, note that a single DDHAP can be turned
into a P-DDHAP as (aE,

ribE

}i∈[m]) for
In the following we will use this in the form (aE,
{
}i∈[m]).

}i∈[m],

}i∈[m],

cia−1E

ricE

ciE

{

{

{

{

(aE,

{
biE

ri}i∈[m]
}i∈[m],

$
←−

{

G.
}i∈[m])

ciE

≈c

2.3 Sigma protocol

×

⊆

X

A sigma protocol is a three message public coin proof of knowledge protocol. For
a relation R
W , where X is the space of statements and W is the space of
witnesses, a sigma protocol for R consists of two proving algorithm P1, P2 and
(com, st) outputs the ﬁrst prover message
a verifying algorithm V . P1(x, w)
com, named commitment, and a state st for P2. The second message ch $
←− C
from veriﬁer, named challenge, honestly samples a challenge from the challenge
resp outputs the third message resp, named re-
space
sponse. The verifying algorithm V (x, com, ch, resp)
0(reject)/1(accept) out-
puts whether the veriﬁer accepts the transcript. A sigma protocol should satisfy
several properties. We refer readers to Appendix D for further details.

. Finally, P2(st, ch)

→

→

→

C

2.4 The forking lemma

A sigma-protocol-based signature naturally allows witness extraction from the
special soundness property. Through extracting the witness from signature forg-
eries, one can reduce the unforgeability property to the hardness of computing
the witness. However, the main gap between special soundness and unforge-
ability is that special soundness needs multiple related transcripts to extract
the witness, while a signature forging adversary only provides one. The forking
lemma [35] is thus proposed to close this gap. For our particular application, as
elaborated in Appendix E.1, a generalized variant is adopted for the classical
analysis.

2.5 Group signature

A group signature scheme consists of one manager and n parties. The manager
can set up a group and provide secret keys to each party. Every party is al-
lowed to generate signatures on behalf of the whole group. Such signatures are
publicly veriﬁable without revealing the corresponding signers, except the man-
ager can open signers’ identities with his master secret key. We refer readers to
Appendix F for group signature syntax and formal deﬁnitions.

2.6 Accountable ring signature

Accountable ring signatures (ARS) are a natural generalization for both group
signatures and ring signatures. Compared to a group signature, ARS gives the

9

power of group decision to the signer. On signing, the signer can sign for an
arbitrary group (or ring, to ﬁt the original naming), and can decide a master
independent from the choice of the group. The master can open the identity of
the signer among the group without needing to participate in the key generation
of parties in the ring. Note that accountable ring signatures directly imply group
signatures, simply by ﬁxing the group and the master party at the key generation
step. Thus, ARS can be viewed as a more ﬂexible form of group signature.

Syntax. An accountable ring signature scheme
algorithms.

ARS

consists of the following

– MKeygen(1λ)
– Keygen(1λ)

(mpk, msk) generates master public key/secret key pair.
→
(pk, sk) generates public key/secret key pair for group mem-

bers.

→

– Sign(mpk, S =

m for a set S with some secret key skid for id

pki}i∈R, m, skid)
pki}i∈R, m, σ)
Verify outputs 1 if veriﬁcation passes and 0 otherwise.

– Verify(mpk, S =

R.

→

→

∈

{

σ generates a signature σ for message

1/0 veriﬁes whether (m, σ) is valid.

– Open(msk, S =

S
∈
for which the matching secret key was used to generate the signature σ. It
outputs id =

when the opening fails. (i.e. when σ is malformed)

reveals the identity pk

∪ {⊥}

pk

→

∈

S

{

⊥

{
pki}i∈R, m, σ)

|

| ≤

M
. We also deﬁne

, the master public key space to be

We deﬁne the message space to be
Km and
the public key space to be
KPm to be the set of all master key
K
pairs (mpk, msk), and
to be the set of all public/private key pairs (pk, sk).
For simplicity, we keep the parameter λ implicit for the before-mentioned key
spaces, and additionally require public keys to be all distinct for a set S of size
S

poly(λ).

KP

An accountable ring signature scheme should satisfy the following security

properties.

Correctness. An ARS is said to be correct if every honest signature can be
correctly veriﬁed and opened.

Deﬁnition 4. An accountable ring signature scheme
master key pair (mpk, msk)
public keys S such that pk

∈ KPm, any key pair (pk, sk)
S,
∈

ARS

∈ KP

is correct if for any
, and any set of

Pr

acc=1∧out=pk :

(cid:20)

σ←Sign(mpk,S,m,sk),
acc←Verify(mpk,S,m,σ),
out←Open(msk,S,m,σ)

(cid:21)

> 1

−

negl(λ).

Anonymity. An ARS is said to be anonymous if no adversary can determine
the signer’s identity within the set of signers of a signature without using the
master secret key.

10

Deﬁnition 5. An accountable ring signature scheme
any PPT adversary A and any two key pairs (pk0, sk0), (pk1, sk1)

ARS

is anonymous if for

,

∈ KP

Pr

1

←

ASign∗(mpk•,•,•,sk0),mpk•(x)
i

−

Pr

1

←

h

(cid:12)
(cid:12)
with each query Sign∗(mpkν , S, m, skb) returning an honest signature only when
(cid:12)
S and otherwise abort, where each master key pairs (mpkν, mskν)
both pk0, pk1 ∈
MKeygen(1λ) are sampled honestly.

i(cid:12)
(cid:12)
(cid:12)

h

←

ASign∗(mpk•,•,•,sk1),mpk• (x)

negl(λ) ,

≤

Remark 1. As we do not forbid x to contain information about the secret keys,
adversaries in Deﬁnition 5 are referred to as being under the full key exposure.

Unforgeability. An ARS is said to be unforgeable if no adversary can forge a
valid signature that fails to open or opens to some non-corrupted party, even if
the manager has also colluded.

We model this property with the unforgeability game GUF

nh . Among nh honest
keys pairs, the adversary A can call the signing oracle to obtain honest signatures,
or call the corruption oracle to obtain the secret keys of the honest parties. The
adversary wins if it outputs a valid signature that opens to a non-corrupted
party or fails to open. We abuse the notation ski ∈

Hon if pki ∈

Hon.

GUF

A,nh : Unforgeability game
[nh], (pki, ski)

Keygen(1λ). Let Hon =

{
ASign(•,•,•,ski∈Hon),Corrupt(•)(Hon)

i
1:
∀
∈
←
2: (S, m∗, σ∗)
Corrupt(pki) returns ski for pki ∈
3: A wins if (m∗, σ∗) is not an output of Sign, 1
Open(msk, S, m, σ∗) satisﬁes pk
pk

←

{

pki}i∈[nh], Cor =
Hon and stores query pki in list Cor

{}

.

Verify(mpk, S, m∗, σ∗) and
Hon

Cor

}

←
∈ {⊥} ∪

\

←

Deﬁnition 6. An accountable ring signature scheme
any PPT adversary A, any valid master key pair (mpk, msk)
nh = poly(λ)

ARS

is unforgeable if for
∈ KPm and any

Pr[A wins GUF

A,nh (mpk, msk)] < negl(λ).

Transforming ARS to GS. As mentioned earlier, an accountable ring signa-
ture can be viewed as a generalization of a group signature. We give here the
to a group signature scheme
general transformation from an ARS scheme

ARS

The algorithms of the group signature scheme

ARS are detailed as follows:

GS

ARS.

GS

– GKeygen(1λ, 1n):
1: (mpk, msk)

← ARS

.MKeygen(1λ)

11

2:

i
∀
∈
(mpk, S)

[n], (pki, ski)

3: return (gpk,

← ARS
ski}i∈[n], msk)

{

– GSign(gpk = (mpk, S), m, skk)

.Keygen(1λ), Let S =

pki}i∈[n] and gpk =

{

1: return σ

.Sign(mpk, S, m, skk)

– GVerify(gpk = (mpk, S), m, σ):

← ARS

1: return σ

.Verify(mpk, S, m, σ)

← ARS

– GOpen(gpk = (mpk, S), msk, m, σ):
.Open(msk, S, m, σ)
S or

1: pk
2: return k s.t. pk = pkk ∈

← ARS

⊥

otherwise

Note that the transformation only changes the formulation of the setup stage.
transfer directly to the induced group

Thus, the security properties from
signature scheme

ARS .

ARS

GS

3 Openable OR-sigma protocol

In this section, we will introduce the openable sigma protocol, which is an inter-
mediate primitive toward group signatures and accountable ring signatures. We
will ﬁrst give some intuition on how we formulate this primitive, and then give
a formal deﬁnition and construction from DDH-hard group actions.

3.1 Intuition

A typical construction of a Fiat-Shamir based signature starts from a sigma pro-
tocol. As introduced in Section 2.3, the three message protocol (com, ch, resp)
only requires special soundness, which is, informally speaking, weaker than the
unforgeability property in the sense that multiple transcripts are required in or-
der to break the underlying hardness. The forking lemma closes this gap with the
power of rewinding and random oracle programming. As stated in Section 2.4,
the lemma takes a forger that outputs a single forgery and gives an algorithm
that outputs multiple instances of valid (com, chj, respj)’s. This gives a transfor-
mation from a signature breaker to a witness extractor, bridging the two security
notions.

For our accountable ring signature, we thus plan to follow the previous
roadmap. We design a sigma protocol that supports an extra “opening” prop-
erty. Our openable sigma protocol takes n statements as input, and additionally
requires the prover to take a master public key mpk as input on generating the
ﬁrst message com. The function Open, with the master secret key msk, can then
extract the actual statement to which the proving witness corresponds to. For a
com generated from statement (x1, . . . , xn) and witness wi with (xi, wi)
R, we
have xi = Open(com, msk). As our target is a signature scheme, (xi, wi) would

∈

12

be set to public key/secret key pairs, and thus the open function outputs the
signer’s identity.

To achieve the stronger security property of ARS after the Fiat-Shamir trans-
formation, our openable sigma protocol needs to have modiﬁed security prop-
erties correspondingly. For special soundness, we would not be satisﬁed with
extracting only “one of the witnesses,” instead we need to build an extractor
that extracts a witness which matches the opening result. Such a stronger ex-
tractor will allow us to extract secret keys from adversaries that can impersonate
other players. For honest veriﬁer zero knowledge (HVZK), we require the tran-
script to be ZK even when given the master secret key msk. This is crucial for
proving that the impersonating attack cannot succeed even with a corrupted
manager. Note that when given msk, one cannot hope to hide the signer’s iden-
tity, so we only require ZK against the signer’s witness. The formulation for the
HVZK simulator thus takes the signer identity as input. Finally, we need an ex-
tra property to provide anonymity for the signer, which we named computational
witness indistinguishability (CWI). CWI requires that, given honest master key
pairs, the transcript generated from two diﬀerent witnesses/identities should be
indistinguishable. This property is formulated as the indistinguishability of two
signing oracles.

3.2 Deﬁnition

An openable sigma protocol Σλ with security parameter λ is deﬁned with re-
spect to two relations. A base relation (x, s)
W , and an eﬃciently
samplable opening relation MKeygen(1λ)
m. We will omit
the superscripts λ when there is no ambiguity. We also deﬁne the or-relation for
R
xi}i∈[n], s)
R. (
{
The openable sigma protocol Σ contains the following four algorithms.

Rn if and only if all xi are distinct and

Rλ
×
⊂
(mpk, msk)

[n] s.t. (xi, s)

∈
→

i
∃

Rλ

X

∈

∈

∈

∈

– Commit(xm,
{
xi}i∈[n], s)

xi}i∈[n], s)
∈

on (
{
with Resp and will be kept implicit for convenience.

(com, st) generates a commitment com based
Rn. Commit also generates a state st which is shared

→

resp computes a response resp relative

– Resp(xm,

to a challenge ch $

– Verify(xm,

→

{

←− C

xi}i∈[n], s, com, ch, st)
.
xi}i∈[n], com, ch, resp)
{
xi}i∈[n], com)

x

is valid. Verify outputs 1 if the veriﬁcation passes and 0 otherwise.

– Open(sm,

R,
where s is the witness used to generate the commitment com. It outputs
x =

when the opening fails. (i.e. when com is malformed)

reveals some (x, s)

∈ {

→

∈

{

→
xi}i∈[n] ∪ {⊥}

1/0 veriﬁes whether a tuple (com, ch, resp)

⊥

A (secure) openable OR sigma protocol should also satisfy the following prop-
erties.

13

Deﬁnition 7 (High min-entropy). An openable sigma protocol Σ is of high
min-entropy if the for any possible commitment com0

Pr[Commit(x)

com = com0]

negl(λ)

≤

→

Deﬁnition 8 (Correctness). An openable sigma protocol Σ is correct if for
all n = poly(λ), (xm, sm)
xi}i∈[n]
xi}i∈[n], s)
such that (x, s)

Rm, (
{

Rn, ch

, and x

∈ C

∈ {

R,

∈

∈

∈

Pr

acc = 1



∧

id = x :

com←Commit(xm,{xi}i∈[n],s),
resp←Resp(xm,{xi}i∈[n],s,com,ch),
acc←Verify({xm,{xi}i∈[n],com,ch,resp),
id←Open(sm,{xi}i∈[n],com)

1

−



≥

negl(λ).





Deﬁnition 9 (µ-Special Soundness). An openable sigma protocol Σ is µ-
special sound if for all n = poly(λ) there exists an eﬃcient extractor Ext such
respj}j∈[µ]) such
that, for all (xm, sm)
that each chj ∈ C

Rm and any (
{

xi}i∈[n], com,

are distinct, then

chj}j∈[µ],

∈

{

{

Pr

(∀j∈[µ], accj =1)∧
(x=⊥∨(x,s) /∈R)

:

(cid:20)

∀j∈C, accj←Ver(xm,{xi}i∈[n],com,chj ,respj ),
x←Open(sm,{xi}i∈[n],com),
s←Ext({xi}i∈[n],com,{chj }j∈[µ],{respj }j∈[µ])(cid:21)

= 0.

(1)

Deﬁnition 10 (Statistical Honest Veriﬁer Zero Knowledge / sHVZK).
An openable sigma protocol Σ is statistical HVZK if there exists an eﬃcient
simulator Sim such that, for any xm ∈
xi}i∈[n] such that (x, s)
{

Xm, any (
{

xi}i∈[n], s)

Rn, and x

R,

∈

∈

∈
Trans(xm,

xi}i∈[n], s)

{

≈s Sim(xm,

xi}i∈[n], x)

{

where Trans outputs honest transcript (com, ch, resp) generated honestly by Commit
and Resp with honestly sampled ch $

.

←− C

Deﬁnition 11 (Computational Witness Indistinguishability / CWI).
An openable sigma protocol Σ is computational witness indistinguishable with
respect to an eﬃcient instance generator MKeygen(1λ)
Rm,
R and any eﬃcient adversary A, with mpk•(ν)
if for any two (xi, si), (xj , sj)
returning mpkν ←
Pr

ATrans∗(mpk•,•,sj ),mpk• (x)

MKeygen for each ν, we have

(mpk, msk)

Pr

→

∈

∈

1

1

negl(λ)

←

ATrans∗(mpk•,•,si),mpk• (x)
i

−

h

(cid:12)
h
(cid:12)
where Trans∗(mpkν, S, sk) for whichever k
(cid:12)
(com, ch, resp) tuple from Σ if both xi, xj ∈

←

i, j

returns an honest transcript

∈ {
S and aborts otherwise.

}

≤

i(cid:12)
(cid:12)
(cid:12)

3.3 Construction

Here, we give our construction to an openable or sigma protocol ΣGA,λ for
be some
relations from our DDH-secure group action

). We let E

GAλ = (G,

E

∈ E

14

ﬁxed element in
E0 : y2 = x3 + x for simplicity. Let the relation RE =

. When implemented with CSIDH, we can choose the curve
G.

G

a

E

(aE, a)
|

{

∈

} ⊂ E ×

For our ΣGA, we deﬁne its opening relation Rm = RE, with the natural
instance generator MKeygen(1λ) that samples a $
G and outputs (aE, a).
←−
Rn
Ei}i∈[n], s)
The base relation is also set to RE. For inputs Em ∈ E
and (
{
with any n = poly(λ), the algorithms for ΣGA are constructed as follow.

∈

{

i}i∈[n], b, l = ∆k∆′
∆′
kbs)
Eβ
Eα
i }i∈[n], τ (
i }i∈[n],
{
Ei}i∈[n], s, com, ch, st):

Eγ
i }i∈[n]), EOpen, ECheck), st)
) as a lazy convention of sending a permuted list
}

{

{

R.

G

←−

{

– Commit(Em,
1: set k

Ei}i∈[n], s)
[n] s.t. (Ek, s)
∈
i}i∈[n], b $
∆′

{
sym(n)
[n] : Eα
i
[n] : Eβ
i
[n] : Eγ

∈
∆i}i∈[n],
2:
{
3: τ $
←−
i
4:
∈
∀
i
5:
∈
∀
i
6:
∈
∀
7: EOpen := ∆k∆′
8: ECheck := ∆k∆′
9: st = (
∆i}i∈[n],
{
10: return (com, st) = ((
{

We use τ (
•

{
– Resp(Em,

i = ∆i∆′

τ is a random permutation
{
}
:= ∆iEi
iEα
:= ∆′
i := bEβ
i = ∆i∆′
ksEm
kbsEm = bEOpen

iEi
ibEi

return resp :=

return resp :=

1: if ch = 1 then
2:
3: if ch = 2 then
4:
5: if ch = 3 then
6:
7: if ch = 4 then
8:

return resp := b

∆i}i∈[n]
∆′

i}i∈[n]

{

{

– Verify(Em,

{

{

∈

i
∀

i = ∆iEi

return resp := l = ∆k∆′

kbs
Ei}i∈[n], com, ch, resp):
Ei}i∈[n] or
[n] : Eα

1: return 0 if
{
2: if ch = 1 then
check
3:
4: if ch = 2 then
check
5:
6: if ch = 3 then
check
7:
∈
check ECheck = bEOpen
8:
9: if ch = 4 then
10:
11:
12: return 1 if all checks pass

sym(n) s.t. τ ′(
{

i
∀
∈
τ ′
∃

i = Eβ

[n] : ∆′

iEα

i

check ECheck = lEm
Eγ
i }i∈[n]) s.t. Eγ = lE
Eγ
check
∃
pki}i∈[n], com):

∈
Ei}i∈[n] :=

τ (
{

{

{

– Open(sm := msk,
[n] do

1: for i

∈

15

Eβ
i }i∈[n] are not all distinct

bEβ

i }i∈[n]) = τ (
{

Eγ
i }i∈[n])

if smEβ

i = EOpen then

return Ei

2:
3:
4: return

⊥

The construction of our openable sigma protocol looks complicated, but the
intuition is simple. The core section of the message com is (Eβ, EOpen), which
allows opening. The other parts of com are to ensure that the opening section is
honestly generated. Eα along with the challenge/response pair on ch = 1, 2 al-
i’s, ensuring that Eβ is honestly generated. (Eγ, ECheck)
lows extraction for ∆i∆′
along with the challenge/response pair on ch = 3, 4 veriﬁes the relation between
Eβ and EOpen. By using a permuted Eγ, the CWI property is preserved through
such a veriﬁcation process. Combined together, we complete the proof of knowl-
edge protocol.

Theorem 1. ΣGA is an openable sigma protocol with RE being both the opening
relation and the base relation

3.4 Security

The proof for Theorem 1 is broken down into proving each of the required prop-
erties.

Lemma 1. ΣGA is correct

n

Proof. By the deﬁnition of Commit and Verify, any honestly generated (com, ch, resp)
Eβ
based on (
Ei}i∈[n], s)
i }i∈[n] is
{
pairwise distinct. Since
is free and transitive, there is a unique g
G s.t.
∈
gEi = Ej . Thus, Eβ
j )−1∆i∆′
i = g, which happens with
negligible probability since all ∆’s are honestly sampled. Hence with probability
1

∈
GA
i = Eβ
j if and only if (∆j∆′

Rn will be accepted as long as the set

Eβ
i }i∈[n] are all distinct, and hence Verify accepts.
∈

For the function Open, note that if (Em, sm)

R, then
k = EOpen. As argued previously,
EOpen = ∆k∆′
Eβ
negl(λ), and k would be unique if
i }i∈[n] are all distinct with probability 1
{
this is the case. Thus the probability that Open outputs Ek is overwhelming,
concluding the proof that ΣGA is correct.

kssmE, hence smEβ

ksEm = ∆k∆′

Rm and (Ek, s)

negl(λ), the set

−

−

∈

{

{

·

Lemma 2. ΣGA is 4-special sound

Proof. For any Em ∈ E
Eβ
Eα
com = (
i }i∈[n], σ(
i }i∈[n],
{
{

Ei}i∈[n], com,
and any (
{
Eγ
i }i∈[n]), and
{

{

respj}j∈C) where
{
respj}j∈[4] = (
{

∆i}i∈[n],

∆′
i}i∈[n], b, l).

{

16

Suppose that
←
tion of Verify, we can get the following equations:

Ver(Em,

Ei}i∈[n], com, j, respj), then by the deﬁni-

[4], 1

j
∀

∈

{

{

Eβ
Ei}i∈[n],
i }i∈[n] are both pairwise distinct sets
{
i = ∆iEi, Eβ
iEα
i = ∆′
[n] : Eα
i
i
∈
∀
bEβ
τ ′
sym(n) s.t. τ ′(
i }i∈[n]) = τ (
∈
∃
{
{
Eγ
i }i∈[n]) s.t. Eγ = lE
Eγ
τ (
∃
∈
{
ECheck = lEm = bEOpen

Eγ
i }i∈[n])






∈

Thus, there exists a unique k
kbEk, which means l(∆k∆′

[n] such that lE = bEβ
kb)−1E = Ek. This implies that (Ek, l(∆k∆′

∆k∆′
RE. Furthermore, we also have EOpen = b−1lEm = smb−1lE = smEβ
Ei}i∈[n], com). Thus Open does not output
plies that Ek ←
these observations, we can easily construct the extractor Ext(com,
[n] for k satisfying lE = bEβ
which simply searches through k
s = l(∆k∆′

kb)−1. This concludes the proof that ΣGA is 4-special sound.

k =
kb)−1)
k . This im-
. From
⊥
respj}j∈C),
k , then output

k = ∆′

Open(sm,

kbEα

∈

{

{

∈

Lemma 3. ΣGA is statistically honest veriﬁer zero-knowledge.

Proof. The construction of Sim is given in the following algorithm. We will show
that Sim is in fact a perfect simulator for Trans.

}

{

←− {

sym(n)

Ei}i∈[n], Ek)
1, 2, 3, 4

Sim(Em,
1: ch $
2: b $
G, τ $
←−
←−
3: if ch = 1 then
∆i}i∈[n],
4:
{
{
[n] : Eα
i
5:
i
∈
∀
[n] : Eβ
i
6:
i
∀
∈
EOpen := ∆kDkEm
7:
8: else if ch = 2, 3, 4 then
$
←−

$
Di}i∈[n]
←−
:= ∆iEi
:= ∆iDiE

Di}i∈[n],
{
i
∈
∀

∆′
{
[n] : Eα
i

i}i∈[n]
:= DiE

9:
10:

G

G

iEα
i

i
∀

[n] : Eβ
:= ∆′
i
11:
i
∈
∀
EOpen := Dk∆′
kEm
12:
:= bEβ
[n] : Eγ
13:
i
i
∈
14: if ch = 1, 2, 3 then
ECheck := bEOpen
15:
16: else if ch = 4 then
l := ∆kDkb
17:
ECheck
18:
19: return

km := lEm

(com, ch, resp) with the
same deﬁnition as honest Commit
and Resp

GA

Since

G s.t. siE = Ei. In Sim1, we can thus set ∆′

is free and transitive, for every Ei ∈ E

, there exists a unique
in case ch = 1
si ∈
and ∆i = Dis−1
is uniformly
random, Sim generates identical distributions for ∆’s as Trans. Thus the output
distribution of Sim should also be identical to the real transcript. Checking that
veriﬁcation passes for all cases shows that Sim is a perfect simulator.

in case ch = 2, 3, 4. Since the distribution of Dis−1

i = Dis−1

i

i

i

17

Lemma 4. ΣGA is computational witness indistinguishable with respect to the
natural instance generator MKeygen, (assuming DDHAP is hard for

).

GA

Here we will ﬁnally use the fact that

is DDH-hard. We will prove this
theorem through two hybrids. We highlight the changes between Trans and
Hyb1 and between Hyb1 and Hyb2 with diﬀerent colors for easier comparison.

GA

Lemma 5. For any eﬃcient adversary A with mpk•(ν) generating mpkν from
(mpkν, mskν )

MKeygen(1λ) for each ν, regardless of s

Gλ, we have

←

∈

1

←

Pr

ATrans(mpk•,•,s),mpk• (x)
(cid:12)
i
(cid:12)
where Hyb1 is as speciﬁed below.
(cid:12)

h

−

Pr

1

h

←

AHyb1(mpk•,•,s),mpk• (x)

i(cid:12)
(cid:12)
(cid:12)

negl(λ) ,

≤

Hyb1(Em,
1: ch $
2: set k

Ei}i∈[n], s)
{
1, 2, 3, 4
}
[n] s.t. (Ek, s)
i}i∈[n], b $
∆′
i = ∆iEi, Eβ
i = bEβ

←− {
∈
∆i}i∈[n],
3:
{
4: τ $
←−
i
5:
∈
∀
i
6:
∈
∀

{
sym(n)
[n] : Eα
[n] : Eγ

←−

∈

i

R.

G

i = ∆′

iEα
i

7: r $
G, EOpen = rE
←−
8: if ch = 1, 2, 3 then
ECheck = bEOpen
9:
10: else if ch = 4 then
l = ∆k∆′
11:
12: set resp honestly w.r.t ch
13: return (com, ch, resp)

kbs, ECheck = lEm

∈

Ei}i∈[n], s)

Proof. Each query input of Trans and Hyb1 is of form (Em,
Ei}i∈[n], s) where
(
Rn and Em is the curve correspoinding to the random master
{
public key. We ﬁrst note that the diﬀerence between honest transcript Trans
and Hyb1 is that Hyb1 replaces honest EOpen with rE for a random r
G. For
ch

= 4, ECheck is also replaced accordingly to EOpen.
We will prove the indistinguishability of (com, ch, resp)

∈

{

Hyb1 for each diﬀerent challenge ch
set k s.t. (Ek, s)

R, as in both Trans and Hyb1

∈ C

∈
For ch′ = 1, we have resp′ =

identical to Trans. We thus focus on the com′ part.

∆i}i∈[n], which is honestly generated and thus

{

separately. In the following proof, we

←

←

Trans and (com′, ch′, resp′)

By the hardness of P-DDHAP, for random ∆′

G, we have

(Em, ∆′

kE, ∆′

kEm)

≈c (Em, ∆′

k, r $
←−
kE, rE)

18

6
Hence, for random ∆k, ∆′
ECheck), we have

k, b, r $
←−

G and honestly generated (Em, Eβ

k , Eγ

k , EOpen,

(Em, Eβ
k , Eγ
=(Em, ∆ks(∆′
≈c(Em, ∆ks(∆′
k , Eγ
=(Em, Eβ

k , EOpen, ECheck)
kE), ∆kbs(∆′
kE), ∆kbs(∆′
k , r′E, br′E)

kEm), ∆kbs(∆′
kE), ∆ks(∆′
kE), ∆ks(rE), ∆kbs(rE))

kEm))

Where LHS is the output com from Trans, restricted to the variables dependent
on sm or ∆′
k. RHS is the corresponding partial output from Hyb1. As the
remaining parts of Trans and Hyb1 are equivalent, this equation shows that
the output distributions of Trans and Hyb1 are indistinguishable for ch = 1.

For the case ch = 2, 3, the indistinguishability can be proved in a simi-

lar fashion. Notice again that for random ∆k, r $
←−
(Em, ∆kE, rE). Thus for random ∆k, ∆′
G

k, b, r $
←−

G, (Em, ∆kE, ∆kEm)

≈c

k , Eβ

(Em, Eα

k , Eγ
=(Em, s(∆kE), ∆′
≈c(Em, s(∆kE), ∆′
k , Eγ
=(Em, Eα

k , Eβ

k , EOpen, ECheck)
ks(∆kE), ∆′
ks(∆kE), ∆′
k , r′E, br′E)

kbs(∆kE), ∆′
kbs(∆kE), ∆′

ks(∆kEm), ∆′
ks(rE), ∆′

kbs(rE))

kbs(∆kEm))

For the case ch = 4, we would need a slight change. First we recall the fact
G
i = (bsi)−1Di gives

is free and transitive, for every Ei there exists a unique si ∈

that, since
Di}i∈[n], b $
s.t. siE = Ei. Thus, sampling
{
∆′
i}i∈[n].
us a uniformly distributed

G and letting ∆′

GA

←−

{
Now, again from P-DDHAP, for random b, r $
←−
≈c (Em, b−1E, rE)

(Em, b−1E, b−1Em)

G,

Thus, for random

(Em,
=(Em,

=(Em,
≈c(Em,
=(Em,

{
{

{

{

{

Eα
i }i∈[n],
{
∆iEi}i∈[n],
∆iEi}i∈[n],
∆iEi}i∈[n],
Eα
i }i∈[n],
{

←−

Di}i∈[n], b, r $
∆i}i∈[n],
{
{
Eγ
Eβ
i }i∈[n], EOpen, ECheck, l)
i }i∈[n],
{
∆i∆′
iEi}i∈[n],
{
{
∆iDi(b−1E)
}i∈[n],
∆iDi(b−1E)
}i∈[n],
{
{
Eγ
Eβ
i }i∈[n], r′E, ECheck, l)
i }i∈[n],

ibEi}i∈[n], ∆k∆′
∆iDiE
{

∆iDiE

∆i∆′

{

{

G where Di = ∆′

ibsi, we have

kskEm, ∆k∆′

kbskEm, ∆k∆′

kbsk)
}i∈[n], ∆kDk(b−1Em), ∆kDkEm, ∆kDk)
}i∈[n], ∆kDk(rE), ∆kDkEm, ∆kDk)

Finally, since both ch and ch′ are sampled randomly in

1, 2, 3, 4
}
conclude that Trans and Hyb1 are computationally indistinguishable.

{

, we can

19

Lemma 6. For any eﬃcient adversary A with mpk•(ν) generating mpkν from
(mpkν, mskν )

MKeygen(1λ) for each ν, regardless of s

Gλ, we have

←

∈

1

←

Pr

AHyb1(mpk•,•,s),mpk• (x)
(cid:12)
i
(cid:12)
where Hyb2 is as deﬁned below.
(cid:12)

h

−

Pr

1

h

←

AHyb2(mpk•,•,s),mpk• (x)

i(cid:12)
(cid:12)
(cid:12)

negl(λ) ,

≤

Hyb2(Em,
1: ch $
2: set k

Ei}i∈[n], s)
{
1, 2, 3, 4
}
[n] s.t. (Ek, s)
i}i∈[n], b $
∆′
i = ∆iEi, Eβ

{
sym(n)
[n] : Eα
G, EOpen = rE

←− {
∈
∆i}i∈[n],
3:
{
4: τ $
←−
i
5:
∈
∀
6: r $
←−

←−

∈

R.

G

i = ∆′

iEα
i

∈

i = bEβ

7: if ch = 1, 2, 3 then
ECheck = bEOpen
8:
[n] : Eγ
i
9:
∀
10: else if ch = 4 then
11:
12:
13: set resp honestly w.r.t ch
14: return (com, ch, resp)

G, Eγ
i
∀
l = rk, ECheck = lEm

[n] : ri

$
←−

∈

i

i = riE

Proof. The hybrids Hyb1 and Hyb2 diﬀer only in the case ch = 4, in which we
replace the whole Eγ with random curves, ECheck and l are also changed corre-
Di}i∈[n], b $
spondingly. As in the previous proof, we use the fact that sampling
G and letting ∆′

←−

By P-DDHAP, for random b,

i = (bsi)−1Di gives us uniformly random (
{
ri}i∈[n]\{k},

{
∆′
i}i∈[n], b)

(b−1E,
≈c(b−1E,

{

{

DiE

riE

Di}i∈[n]\{k},
{
}i∈[n]\{k},
}i∈[n]\{k},
{

{
Dib−1E
{
Dib−1E

}i∈[n]\{k})
}i∈[n]\{k})

For simplicity, we let S = [n]

where Di = ∆′
ibsi, and (Em,
{
the elements output from Hyb1, we have

{

k
\{
}
Eα
i }i∈[n],

. Now, for random
{
i }i∈S, Eβ
Eγ
Eβ
i }i∈S,

∆i}i∈[n],
Di}i∈[n], b,
{
k , Eγ
k , ECheck, l) are

{

{

ri}i∈S

(Em,

=(Em,

≈c(Em,

=(Em,

{

Eβ
Eα
i }i∈S,
i }i∈[n],
{
{
∆i(Dib−1E)
∆iEi}i∈[n],
{
{
∆kDkE, ∆kDkEm, ∆kDk)
∆i(Dib−1E)
∆iEi}i∈[n],
{
{
∆kDkE, ∆kDkEm, ∆kDk)
Eβ
i }i∈S,

Eα
i }i∈[n],

{

{

{

i }i∈S, Eβ
Eγ
}i∈S,
{

k , ECheck, l)

k , Eγ
∆i(DiE)

}i∈S, ∆kDk(b−1E),

}i∈S,

∆i(riE)

}i∈S, ∆kDk(b−1E),

{

iEi}i∈S, Eβ
r′

k , Eγ

k , ECheck, l)

20

k , ECheck, l) = (r′

Finally we let r′
k , Eγ

k = ∆kDk, which is obviously independent from all other r′
i,
then (Eβ
kb−1 gives fresh
kE, r′
randomness since b is now independent from all other elements in RHS. Thus
RHS perfectly ﬁts the distribution for Hyb2. This concludes that Hyb1 and
Hyb2 are computationally indistinguishable.

k). Note that r′

kb−1E, r′

kEm, r′

Lemma 7. For any Em ∈
Rn then
(
{

Ei}i∈[n], sk1 )

∈

Xm,

Ei}i∈[n] ∈

{

X n, and sk0 , sk1 s.t. both (
{

Ei}i∈[n], sk0 ),

Hyb2(Em,

Ei}i∈[n], sk0) = Hyb2(Em,

{

Ei}i∈[n], sk1 )

{

{

Ei}i∈[n], sk0 ) = Hyb2(Em,

Ei}i∈[n], sk1 )
Proof. We always have Hyb2(Em,
for ch = 1, 2, 3, as every elements in the output is generated independently
from k. For ch = 4, we can give a deeper look on elements in (com, resp) =
(Eα, Eβ, Eγ, EOpen, ECheck, l). The part (Eα, Eβ, EOpen) is generated indepen-
dent from k, and the part (Eγ, ECheck, l) is of the form (τ (
}i∈[n]), rkEm, rk).
{
Since τ is a random permutation and ri’s are independent randomness, the two
}i∈[n]), rk1 Em, rk1 ) are ob-
distributions (τ (
{
Ei}i∈[n], sk1 ).
viously identical. Hence Hyb2(Em,
{

}i∈[n]), rk0 Em, rk0 ) and (τ (
riE
{
Ei}i∈[n], sk0 ) = Hyb2(Em,
{

riE

riE

{

Finally, by combining Lemma 5, Lemma 6, and Lemma 7, we conclude that
for any eﬃcient adversary A with mpk• and Trans∗ deﬁned as usual, and any
si, sj ∈
1
Pr

ATrans∗(mpk•,•,sj ),mpk• (x)

Gλ, we have

Pr

1

h

←

ATrans∗(mpk•,•,si),mpk• (x)
(cid:12)
i
(cid:12)
by restricting the query inputs (Em,
(cid:12)
Rn for whichever k
is indeed an openable sigma protocol.

∈ {

i, j

}

{

←

−
Ei}i∈[n], sk) to those (
{

h

i(cid:12)
(cid:12)
Ei}i∈[n], si), (
(cid:12)
{

. This concludes the proof of Lemma 4, and thus ΣGA

negl(λ) ,

≤
Ei}i∈[n], sj)

∈

4 Constructing accountable ring signatures

In this section, we will show how to obtain an accountable ring signature scheme
from our openable sigma protocol. The construction can be decomposed into two
parts. We ﬁrst take multiple parallel repetitions to the protocol for soundness
ampliﬁcation, then we apply the Fiat-Shamir transformation on the parallelized
protocol to obtain the full construction. One subtle issue is that since every
sigma protocol in the parallel repetition is generated independently, each parallel
session of the transcript may open to a diﬀerent party. Hence, we need an opening
function for the parallelized protocol which returns the majority output over the
opening results of the parallel sessions.

21

4.1 Construction

More generally, we are going to construct our ARS scheme
ARS Σ by performing
Fiat-Shamir transformed to the protocol Σ⊗t where the number of repetitions t
is determined on-the-ﬂy. Let IGλ and MIGλ be some hard instance generator of Σ
for the base and opening relations respectively, with the validity of the instances
being publicly veriﬁable. The construction of

ARS Σ is detailed as follows.
ARS GA :=

Remark 2. This can later be instantiated to
ARS ΣGA,λ by choosing
Σ := ΣGA,λ to be our previously constructed protocol over the group action
Eλ), and t := 2λn for n members. In our construction of ΣGA,
GAλ = (Gλ,
the opening relation and the base relation are both set to RE. Thus, when
transformed to an ARS scheme, we can have an identical generator for master
, where
key pairs and party key pairs, and identical key spaces
IGλ and MIGλ generate sE for some randomly sampled s

KPm = RE =
Gλ.

KP

←

– MKeygen(1λ):

1: return (mpk, msk)

– Keygen(1λ):

MIGλ

←

1: return (pk, sk)
– Sign(mpk, S, m, sk)

←

IGλ

∈

j
∀

[t], (comj, stj)

1: decide t according to instantiation
2:
3: (ch1, . . . , cht)
4:
5: return σ = (com, resp) := ((com1, . . . , comt), (resp1, . . . , respt))

H(com1, . . . , comt, m)
Σ.Resp(mpk, S, sk, comj, chj, stj)

ΣGA.Commit(mpk, S, sk)

←

∈

j
∀

←
[t], respj ←
– Verify(mpk, S, m, σ):

S

1: t = 2λ
|
|
2: parse σ = (com, resp)
3: ch := H(com, m)
4: check
[t] : 1
5: return 1 if all checks pass

j
∀

←

∈

Σ.Verify(mpk,

– Open(msk, S, m, σ):

pki}i∈[n], comj, chj, respj)

{

1: decide t according to instantiation
2: parse σ = (com, ch, resp)
[t], outj ←
3:
∈
4: pk = Maj(
{

outj}j∈[t])

j
∀

Σ.Open(msk, S, comi)

{

Maj outputs the majority element from its input
list. In case of ties, it outputs a random choice of the majority elements.

}

5: return pk

Theorem 2. Let Σ be a secure openable sigma protocol being O(1)-special sound.
ARS Σ is secure by setting the number of repetitions t :=
Then, the derived
Θ(nλ) for n members. If Σ is furthermore perfect-unique-response, then
ARS Σ
is QROM-secure.

22

Proof. See Section 4.2 for the proof. This is concluded directly from Theorem 3.

From Section 3.4 we know that ΣGA is a secure openable sigma protocol
being 4-special sound, and by applying the transformation from Section 2.6, we
immediately get the following corollaries.

Corollary 1.

Corollary 2.

ARS GA is a QROM-secure ARS scheme, if DDHAP is hard.
ARS GA is a QROM-secure GS scheme, if DDHAP is hard.

GS

This completes our construction of both an accountable ring signature scheme

and a group signature scheme.

Remark 3. One additional beneﬁt of using class group action as the key relation
is that honest public keys can be eﬃciently veriﬁed. As discussed in Section 2.1,
, πp) is a valid public key since the group action is transitive,
ℓℓp(
any Ei ∈ E
and furthermore any Ei /
, πp) can be eﬃciently detected. This prevents
the possibility of malformed master key or malformed public keys, which is a
potential attacking interface of an ARS scheme.

ℓℓp(

∈ E

O

O

4.2 Security

For the proof of Theorem 2 we again break down the theorem into proving each
security property. For proving the unforgeability, we ﬁrst consider the classical
ROM only. Then, by the same spirit but swapping to a more involved secret key
extraction, we obtain the unforgeability in QROM.

Lemma 8. Let Σ be a secure openable sigma protocol, then

ARS Σ is correct.

|

|

S

∈

. Let σ

∈ KPm, any key pair (pk, sk)
S, we directly have (mpk, msk)

Proof. For any master key pair (mpk, msk)
,
∈ KP
and any set of public keys S such that pk
Rm
∈
∈
and (S, sk)
Sign(mpk, S, m, sk) be an honest signa-
Rn where n =
←
ture on message m and ring S. Notice that in an honest execution of Sign, each
comj and respj is honestly generated according to Σ. Thus by the correctness of
Σ, we know for ch := H(com, m) and every j
negl(λ),
Σ.Open(mpk, S, comj).
Σ.Verify(mpk, S, comj, chj, respj) and pk
that 1
←
negl(λ),
negl(λ) = 1
t
Hence we directly obtain that, with probability 1
−
Open(msk, S, m, σ). This
we have that 1
←
concludes the proof that

Verify(mpk, S, m, σ) and pk
ARS Σ is correct.

[t] with probability 1

←

←

−

−

∈

·

Lemma 9. Let Σ be a secure openable sigma protocol, then
mous in ROM.

ARS Σ is anony-

23

H

ARS Σ follows immediately from the CWI property of
Proof. The anonymity of
Σ. For any adversary A with at most Q queries to the random oracle, it can have
= negl(λ) advantage on distinguishing Sign∗ and (Trans∗)t. And
at most Q/
≈c Trans∗(mpk, S, skid1). Hence
by CWI from Σ, we have Trans∗(mpk, S, skid0 )
≈c Sign∗(mpk, S, skid1 ), which
we can directly conclude that Sign∗(mpk, S, skid0 )
ARS Σ is anonymous.
proves that

|

|

Lemma 10. Let Σ be a secure openable sigma protocol being O(1)-special sound,
with the instance relations being hard (to extract a witness), then by setting the
number of parallel repetitions to t = Θ(nλ), where n is the number of members,
ARS Σ is unforgeable in the classical ROM.

We refer readers to E.2 for the proof.

4.3 QROM security

To start oﬀ, we show the anonymity ﬁrst.

Lemma 11. Let Σ be an openable sigma protocol that is of high min-entropy
and computationally unique response. Then

ARS Σ is anonymous in QROM.

,

•

, skk) for whichever k

Proof. Let A be any eﬃcient adversary trying to distinguish the signing oracles
Sign∗(mpk•,
with additional access to QRO
∈ {
H and mpk•. A can be simulated by A2, if further given the power to access
both the QRO H and the augmented signing oracle Sign∗
, skk), which
returns the entire transcript (com, ch, resp) used within the underlying sigma
protocol.

2(mpk•,

i, j

•

}

·

·

,

We try to simulate A2 via another eﬃcient adversary A3 in order to dis-
tinguish the signing oracles, but without access to H. Instead, B will need to
simulate the oracle locally, via Zhandry’s compressed oracle technique.

– BSign∗

2(mpk•,•,skk)(x):

else if the next step of A2 queries QRO H then

if the next step of A2 is local computation then

simulate the local computation

queries H similarly

1: while A2 not terminated yet do
2:
3:
4:
5:
6:
7:
8:
9:
10:
11: return the output of A2

the next step of A2 queries Sign∗
{
queries (com, ch, resp)
program H(mpkν, m, S, com) := ch
send back (com, ch, resp) to the simulation

Sign∗

else

←

2(mpkν, S, m, skk)
}

2(mpkν, S, m, skk)

24

Sign∗
2 (mpk•,•,•,skk), where we use
To help us argue that A
2
” as a short-hand notation for computational indistinguishability, we derive
“
≈
a distinguisher D against the adaptive reprogramming games REPROb as in [24,
Fig. 2].

2 (mpk•,•,•,skk),H

BSign∗

≈

– DREPROGRAM(ski, skj):

if the next step of A2 is local computation then

else if the next step of A2 queries QRO H then

simulate the local computation

1: while A2 not terminated yet do
2:
3:
4:
5:
6:
7:
8:

queries H similarly

else

2(mpkν, S, m, skk)
}

the next step of A2 queries Sign∗
{
let p be the distribution of generating ﬁxed x′ := (mpkν, S, m) and
Sign∗
the transcript (com, ch, resp)
(x, x′)
REPROGRAM(p)
parse x =: (com, ch, resp)
send back (com, ch, resp) to the simulation

2(mpkν, S, m, skk)

←

←

9:
10:
11:
12: return the output of A

Where the terms are as speciﬁed in [24]. The output distribution of REPROD
0 and
REPROD
1 are identical to A2 and B respectively. And by the high min-entropy,
the distribution p in each query is of high marginal entropy on the variable x.
Thus, as in [24, Theorem 1], we have

Sign∗
A
2

2 (mpk•,•,•,skk),H

REPROD

0 ≈

REPROD

1 ≈

≈

BSign∗

2 (mpk•,•,•,skk)

Next, we simulate B by itself, but instead given access to Trans∗(mpk•,
, skk).
We note the diﬀerence between a signing oracle and a transcript oracle is that,
the former generate the same challenge if the corresponding (mpkν, m, S, com) is
the same, but since com is of high min-entropy, this happens with only negligible
probability.

•

BSign∗

2 (mpk•,•,•,skk)

BTrans∗(mpk•,•,skk) .

≈

Then, by the computational witness indistinguishability,

BTrans∗(mpk•,•,ski)

≈

BTrans∗(mpk•,•,skj ) .

Putting things together, the proof is concluded

ASign∗(mpk•,•,•,ski),H
BTrans∗(mpk•,•,skj )

≈

Sign∗
A
2
BSign∗

≈

≈

2 (mpk•,•,•,ski),H

2 (mpk•,•,•,ski)

2 (mpk•,•,•,skj )

2(mpk•,•,•,skj ),H

≈

BSign∗
Sign∗
A
2

BTrans∗(mpk•,•,ski)
ASign∗(mpk•,•,•,skj ),H .

≈

≈

≈

25

The key to lifting Lemma 10 into QROM, is a quantum extraction technique.
The classical forking lemma, which measures out part of the transcript before
rewinding, may ruin the internal quantum state of the adversary, and therefore
does not trivially apply to the quantum setting.

Note that our underlying openable sigma protocol satisﬁes the crucial perfect
unique response property. This enables us to adopt the measure-and-reprogram
technique in [18]. Let
ARS Σ be the ARS produced by performing the Fiat-
Shamir transform to an underlying openable sigma protocol Σ with t-repetitions.
The overall reasoning goes as follows:

– Similar to the proof of Lemma 10, the signing oracle can be eﬃciently sim-

ulated by the adversary, and thus does not help forging a signature.

– As will be explained in Lemma 13, any adversary forging an ARS can be
transformed into an adversary against the soundness of the t-repetition pro-
tocol Σ⊗t.

– Applying generalized Unruh’s rewinding, such adversary can then be used

to extract the secret key of an incriminated honest member.

∈

[n]

∪ {⊥}

For the sake of analysis, we then derive the sigma protocols Σ⊗t
k
k
the adversary is going to incriminate. Indeed, the unforgeability of
FS[Σ⊗t
k ]
an ARS reduces to the simultaneous unforgeability across
From there, the unforgeability of each FS[Σ⊗t
is reduced to the one against no-message attacks via standard results.

one for each
as in Deﬁnition 12. This is in order to capture the target k whom
ARS Σ as
}k∈[n]∪{⊥}.
k ] against chosen-message attacks

{

Deﬁnition 12. Let Σ⊗t be a t-repetition openable sigma protocol, with t deter-
mined on-the-ﬂy. For each k
consists of
the following components.

, the k-th sub-protocol Σ⊗t
k

∪ {⊥}

[n]

∈

– Σ⊗t

k .Commit(x, sk) :
1: parse x =:
2: parse aug =: (xm, sm, S)
(cid:0)
3: return com, st

xk,

{

xi, si}i∈[n]\{k}, aug
Σ⊗t.Commit(xm, S, sk)

(cid:1)

←

Σ⊗t.

C

– Σ⊗t

– ch
←
– Σ⊗t
k .Resp(x, sk, com, ch, st) :
1: return resp
k .Verify(x, com, ch, resp):
1: check 1
←
2: check xk ←
3: return 1 if all check pass

←

{

We take convention that x⊥ :=

Σ⊗t.Verify(xm, S, sk, com, ch, resp)
Σ⊗t.Open(sm, S, com)
.

⊥

}

Σ⊗t.Resp(xm, S, sk, com, ch, st)

The corresponding non-interactivization FS∗[Σ⊗t
where we also explicitly spell out here.

k ] is deﬁned as in Appendix B,

26

k ].Keygen(1λ):
[n] : (pki, ski)

– FS∗[Σ⊗t
i
1:
∀
2: pk := (
{
3: return (pk, skk)

∈

←
pki, ski}i∈[n]\{k}, pkk)

FS[Σ⊗t].Keygen(1λ)

,

)
}

⊥

⊥

– FS∗[Σ⊗t

{

{

k .Resp(x, skk, com, ch, st)

pki, ski}i∈[n]\{k}, aug
k .Commit(x, skk)
(cid:1)

We take convention that (pk⊥, sk⊥) := (
k ].Sign(pk, aug, m, skk):
1: parse aug =: (mpk, msk, S)
pkk,
2: x :=
3: (com, st) := Σ⊗t
(cid:0)
4: ch := H(m, com)
5: resp := Σ⊗t
6: return σ := (com, resp, aug)
k ].Verify(pk, m, σ):
1: parse σ =: (com, resp, aug)
pkk,
2: x :=
3: aug =: (mpk, msk, S)
4: check mpk
5: 1
6: return 1 if all check pass

pki, ski}i∈[n]\{k}, aug

k .Verify(x, com, ch, resp)

(cid:0)
Σ⊗t

msk

←

∼

{

(cid:1)

– FS∗[Σ⊗t

Corollary 3. FS∗[Σ⊗t

k ] can be equivalently deﬁned as follows.

i
∀

k ].Keygen(1λ):
[n] : (pki, ski)

– FS∗[Σ⊗t
1:
∈
2: (mpk, msk)
3: pk := (pkk,
4: return (pk, skk)

← ARS Σ.Keygen(1λ)

← ARS Σ.MKeygen(1λ)
pki, ski}i∈[n]\{k})
{
We take convention that (pk⊥, sk⊥) := (
k ].Sign(pk, aug, m, skk):

{

– FS∗[Σ⊗t

,

)
}

⊥

⊥

– FS∗[Σ⊗t

{

parse pk =: (pkk,
parse aug =: (mpk, msk, S)
return σ

pki, ski}i∈[n]\{k})
← ARS Σ.Sign(mpk, S, m, skk)

k ].Verify(pk, m, σ):
parse σ =: (com, resp, aug)
parse aug =: (mpk, msk, S)
parse pk =: (pkk,
σ′ := (com, resp)
check mpk
← ARS Σ.Verify(mpk, S, m, skk)
check 1
check pkk ← ARS Σ.Open(msk, S, m, σ′)
return 1 if all check pass

pki, ski}i∈[n]\{k})

msk

∼

{

Lemma 12. Let Σ be an openable sigma protocol. Consider any eﬃcient ad-
versary A against FS∗[Σ⊗t]. There exists eﬃcient adversaries Ak, one for each

27

[n]

k

∈

\ {⊥}

, against FS∗[Σ⊗t

k ] such that

Pr

A wins GUF
A,n

(cid:2)

≤

(cid:3)

Xk∈[n]∪{⊥}

AdvsUF−CMA
FS∗[Σ⊗t
k ]

(Ak) ,

where the advantage is as deﬁned in Appendix B.

Corollary 4. Let Σ be an openable sigma protocol being perfect HVZK, perfect-
unique-response, and having high min-entropy (as deﬁned in [26, Deﬁnition 2.6].
ARS Σ. There exists eﬃcient adver-
Consider any eﬃcient adversary A against
saries Ak, one for each k

, against FS∗[Σ⊗t

k ] such that

[n]

∈
A wins GUF
A,n

\ {⊥}

Pr

(cid:2)

AdvUF−NMA
FS[Σ⊗t
k ]

(Ak) + negl ,

≤

(cid:3)

Xk∈[n]∪{⊥}

where the advantage is as deﬁned in Appendix B.

Proof. This is obtained by applying Theorem 4 to the bound in Lemma 12.

Proof of Lemma 12. We note in each respective unforgeability game, A is given
, ski) for arbitrary i
access to the ARS signing oracle
[n],
,
,
ARS Σ.Sign(
•
∈
•
•
while each Ak is given FS∗[Σ⊗t
, skk)
, skk)
,
≈ ARS Σ.Sign(
•
•
•
due to Corollary 3. For queries where i
= k, Ak simulates the oracle on its own,
since the secret key ski is already given as input. We thus deﬁne Ak as follows.

k ].Sign(pk,

•

•

,

,

{

(pk, m):

k ].Sign(pk,•,•,skk)

FS∗[Σ⊗t
– A
k
1: parse pk =: (mpk, msk,
2: while A not terminated do
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:

the next step queries

if i = k then

queries H the same way

abort

else

else

{
if i = k then

aug := (mpk, msk, S)
query FS∗[Σ⊗t

else

14:
15:
16:
17:
18:

pki, ski}i∈[n]\{k}, pkk)

if the next step of A is local computation then

simulate the local computation

else if the next step of A queries H then

else if the next step of A queries Cor(pki) for some i

[n] then

∈

send back ski as the query output

ARS Σ.Sign(mpk, S, m, ski) for some i

[n]

}

∈

k ].Sign(pk, aug, m, skk) and send back the outcome

compute the query

ARS Σ.Sign(mpk, S, m, ski) on its own

28

6
Consider, within the simulation of Ak, in case of any successful forgery by A,
the produced signature σ∗ must open to some pkk for k
, taking
. Furthermore, if σ∗ is opened to pkk, then the
the convention that pk⊥ :=
simulated A must not query Cor(pkk) thus Ak would not abort and will make a
successful forgery against FS∗[Σ⊗t
k ]. By union bound, this concludes the proof.

∪ {⊥}

[n]

⊥

∈

Lemma 13. Let Σ be a perfect-unique-response sigma protocol with a super-
polynomially large challenge space. For any k
, consider any eﬃcient
∪ {⊥}
adversary Ak against FS∗[Σ⊗t
k ]. There exists eﬃcient adversaries Bk against
Σ⊗t
k

such that

[n]

∈

AdvUF−NMA
FS∗[Σ⊗t
k ]
q2

Ω



(Ak)

negl

Pr

≤



−

out = 1






where the right-hand side will be written as the soundness advantage Advsound
Σ⊗t
k




(Bk).

(pk,skk)←Σ⊗t

k .Keygen(1λ)
(com,|sti)←Bk.Commit(x,sk)

resp←Bk.Resp(ch,|sti)

k .Verify(x,com,ch,resp)

,



k .C ;
out←Σ⊗t

ch←Σ⊗t
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

Proof. We adopt the generic (measure-and-reprogram) transformation in [18,
Section 3.3] onto Ak as follows. Suppose A in total has q quantum queries to
the random oracle H. The algorithm Bk simulates H by itself via Zhandry’s
compressed oracle technique.

– Bk.Commit(x, sk):
[q];

←

1: i
2: simulate A until the i-th query
3: measure the querying register with outcome a =: (m, com)

The working state collapses to
{
st
|

ψ

ψ

|

i}

i

, x0)
:= (
4:
i
|
5: return (com,
FS[Σ⊗t
– ch
k ].
←
– Bk.Resp(ch,
0, 1

):
i

C
st

|

|
}

st

)
i

← {

simulate A for the next query

1: b
2: if b = 1 then
3:
4: program H(x) := ch
5: simulate the rest of A and obtain a forgery σ =: (com′, resp)
6: return resp

Note that, in order to clean up the interface, the veriﬁcation Σ⊗t
can be thought of as a predicate on the intermediate random variables (a, resp),
and A could have kept a copy of x′ so that at the end (a, resp) instead of σ is
produced. By applying [18, Theorem 2], the proof is concluded.

k .Verify(x, com, ch, resp)

Finally, we are going to extract the secret from such adversary Bk. The
idea goes as follows. Consider the number of repetitions t = (n + 1)κ, where

29

κ(λ) is some parameter to be determined later. By the pigeonhole principle,
there must be at least κ commitments opened to xk. Furthermore, since the
opening result at each repetition is ﬁxed by the commitment, for a µ-special
sound protocol, obtaining µ accepted responses for distinct challenges against
the same commitment suﬃces to extract a secret s
si}i∈[n] where s = sk
[n]. Our goal is therefore, by means of rewinding Bk, collecting µ such
for k
responses in at least one of the κ repetitions.

∈ {

∈

Lemma 14. Let Σ be a µ-special sound openable sigma protocol of n members,
with additional parameters κ such that the number of repetitions is decided by
t = (n + 1)κ where n is the number of members. For any eﬃcient adversary Ak
against Σ⊗t
there exists an eﬃcient extractor Extk producing a secret such that
k

Advsound
Σ⊗t
k

(Ak)2µ−1

exp

−

κ
−
µµ

(cid:18)

≤

(cid:19)

Pr

s=sk if k∈[n]
s∈{si}i∈[n] if k=⊥
h

s

←

,

Extk(x)
i

where x = (xk,
tion 12, with sk being the corresponding secret witness to xk.

xi, si}i∈[n]\{k}, xm, sm, S) is an instance as deﬁned in Deﬁni-

{

(cid:12)
(cid:12)
(cid:12)

Proof. We adopt the generalized Unruh’s rewinding, as mentioned in [18, Lemma 29].
The extraction goes as follows:

– Extk(x):

|

)

i

C

→

stj

st0

(com,

6:
7:

stj−1
st′

1: simulate Ak.Commit(x, sk)
2: for j
3:
4:
5:

[µ] do
∈
Σ⊗t
chj ←
k .
Ak.Resp(chj,
respj ←
|
The state collapses to
{
Ak.Resp(chj,
rewind
i ←
Each com, chj and respj consists of commitments
{
chij
}i∈[t] and responses
{
respectively.
}
[t] do
chij }j∈[µ] = µ and
←

chij}j∈[µ],

Σ.Sim(com,

∈
if #
{

return s

8: for i
9:
10:
11: abort

resp

V

{

|

|

)
i
j−1i}
st′
|
}i∈[t] in all of i-th repetition for i

comi}i∈[t], challenges
[t]

j−1i

)†

∈

{

j∈[µ] Σ.Verify(comi, chij, respij) = 1 then
respij}j∈[µ])

{

{

Assoiciate Pi, where i = ch runs through the challenge space Σ⊗t
, with the
k .
projector induced by computing Ak.Resp, measuring and getting an outcome
resp, and then uncompute Ak.Resp such that 1
Σ.Verify(com, ch, resp). The
bound in [18, Lemma 29] corresponds to

←

C

outj = 1

Pr





^j∈[µ]

com=com0;

∀j∈[µ]:

outj←Σ⊗t.Verify(com,chj ,respj )
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)



30

(pk,skk)←Σ⊗t

k .Keygen(1λ)
(com,|sti)←Bk.Commit(x,sk)

resp←Bk.Resp(ch,|sti)

k .Verify(x,com,ch,resp)

com=com0

Pr 

≥

k .C ;
out←Σ⊗t

out = 1(cid:12)
ch←Σ⊗t
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)




2µ−1

,






for each prescribed com0. The conditioning on both sides can be gotten rid of
by Jensen’s inequality,

Pr

∈

[µ] : 1

j
∀
(cid:2)
be the set of indices collecting i

←

Σ⊗t.Verify(com, chj, respj)

I

Let
mentioned earlier, by the pigeonhole principle, we have #
chj}j∈[t] is independent with com,

∈

{

(cid:3)

I ≥

Advsound
Σ⊗t
k

(Ak)2µ−1 .

≥

(2)

[t] such that comi is opened to k. As
κ for certain. Since

Pr[Extk(x) aborts]

≤

≤

Pr

com0
X

∀i∈[t]:
#{chij }j∈[µ]<µ
h

κ

C
µ

− (cid:0)

(cid:1)Cµ

!

1

com0  
X

com = com0
(cid:12)
(cid:12)
(cid:12)

Pr[com = com0]

Pr[com = com0]

i

≤

exp

κ
−
µµ

(cid:19)

(cid:18)

,

(3)

where C := #Σ.
with union bound, the proof is concluded.

C

is the size of the challenge space. Combining Equation (1), (2), (3)

Theorem 3. Let Σ be an openable sigma protocol being correct, µ-special sound,
statistical HVZK, perfect-unique-response, computationally witness indistinguish-
able, and having high min-entropy where the number of repetitions is decided by
t = (n+ 1)κ for n members and exp (
ARS Σ
with a hard instance generator is unforgeable in QROM.

κ/µµ) is negligible. Then the ARS

−

Proof. Combining Lemma 13, 14 and Corollary 4, the proof is concluded.

5 Discussion

Our setting has premised an honest manager, as the opening result is only avail-
able to the manager. A corrupted manager can thus incriminate any party as
the signer of an arbitrary signature. Many previous works on group signatures
then provide an extra judging function allowing the manager to generate a pub-
licly veriﬁable proof for its opening results. Due to the majority voting that we
have adopted in our opening design, we do not know yet how to construct a
proof for the exact opening output. Nevertheless, we are able to provide, see
Appendix A, a weaker variant where the manager proves the following: a suf-
ﬁcient number of sessions within a signature is opened to the claimed signer
k. This is essentially proving for multiple sessions that smEβ
k = EOpen (as in
Section 3.3), which is done with a slight twist to Couveignes’ sigma protocol.
Though weaker, this notion is still meaningful as it also prevents a corrupted
manager from incriminating honest non-signers. We will leave the construction
supporting a full-ﬂedged judging function to future work.

31

Acknowledgments

Authors were supported by Taiwan Ministry of Science and Technology Grant
109-2221-E-001-009-MY3, Sinica Investigator Award (AS-IA-109-M01), Execu-
tive Yuan Data Safety and Talent Cultivation Project (AS-KPQ-109-DSTCP),
and Young Scholar Fellowship (Einstein Program) of the Ministry of Science
and Technology (MOST) in Taiwan, under grant number MOST 110-2636-E-
002-012, and by the Netherlands Organisation for Scientiﬁc Research (NWO)
under grants 628.001.028 (FASOR) and 613.009.144 (Quantum Cryptanalysis
of Post-Quantum Cryptography), and by the NWO funded project HAPKIDO
(Hybrid Approach for quantum-safe Public Key Infrastructure Development for
Organisations), and by the NSF CAREER award 2141536. This work was car-
ried out while the ﬁfth author was visiting Academia Sinica, she is grateful for
the hospitality.

References

1. R. E. Bansarkhani and R. Misoczki. G-Merkle: A Hash-Based Group Signature
Scheme from Standard Assumptions. In PQCrypto, volume 10786 of Lecture Notes
in Computer Science, pages 441–463. Springer, 2018.

2. M. Bellare, D. Micciancio, and B. Warinschi. Foundations of Group Signatures:
Formal Deﬁnitions, Simpliﬁed Requirements, and a Construction Based on Gen-
eral Assumptions. In EUROCRYPT, volume 2656 of Lecture Notes in Computer
Science, pages 614–629. Springer, 2003.

3. M. Bellare, H. Shi, and C. Zhang. Foundations of Group Signatures: The Case of
Dynamic Groups. In CT-RSA, volume 3376 of Lecture Notes in Computer Science,
pages 136–153. Springer, 2005.

4. W. Beullens, S. Dobson, S. Katsumata, Y-F Lai, and F. Pintore. Group signatures
and more from isogenies and lattices: Generic, simple, and eﬃcient. Cryptology
ePrint Archive, 2021.

5. W. Beullens, S. Katsumata, and F. Pintore. Calamari and Falaﬂ: Logarithmic
In ASIACRYPT (2),
(Linkable) Ring Signatures from Isogenies and Lattices.
volume 12492 of Lecture Notes in Computer Science, pages 464–492. Springer,
2020.

6. W. Beullens, T. Kleinjung, and F. Vercauteren. CSI-FiSh: Eﬃcient Isogeny Based
In ASIACRYPT (1), volume

Signatures Through Class Group Computations.
11921 of Lecture Notes in Computer Science, pages 227–247. Springer, 2019.

7. D. Boneh, X. Boyen, and H. Shacham. Short Group Signatures.

In CRYPTO,
volume 3152 of Lecture Notes in Computer Science, pages 41–55. Springer, 2004.
8. J. Bootle, A. Cerulli, P. Chaidos, E. Ghadaﬁ, and J. Groth. Foundations of Fully
Dynamic Group Signatures. In ACNS, volume 9696 of Lecture Notes in Computer
Science, pages 117–136. Springer, 2016.

9. J. Bootle, A. Cerulli, P. Chaidos, E. Ghadaﬁ, J. Groth, and C. Petit. Short Ac-
In ESORICS (1), volume 9326 of

countable Ring Signatures Based on DDH.
Lecture Notes in Computer Science, pages 243–265. Springer, 2015.

10. E. Bresson and J. Stern. Eﬃcient Revocation in Group Signatures. In Public Key
Cryptography, volume 1992 of Lecture Notes in Computer Science, pages 190–206.
Springer, 2001.

32

11. E. F. Brickell, D. Pointcheval, S. Vaudenay, and M. Yung. Design Validations for
Discrete Logarithm Based Signature Schemes. In Public Key Cryptography, volume
1751 of Lecture Notes in Computer Science, pages 276–292. Springer, 2000.

12. J. Camenisch and M. Michels. A Group Signature Scheme with Improved Ef-
In ASIACRYPT, volume 1514 of Lecture Notes in Computer Science,

ﬁciency.
pages 160–174. Springer, 1998.

13. W. Castryck, T. Lange, C. Martindale, L. Panny, and J. Renes. CSIDH: An
Eﬃcient Post-Quantum Commutative Group Action. In ASIACRYPT (3), volume
11274 of Lecture Notes in Computer Science, pages 395–427. Springer, 2018.
14. W. Castryck, J. Sot´akov´a, and F. Vercauteren. Breaking the Decisional Diﬃe-
Hellman Problem for Class Group Actions Using Genus Theory. In CRYPTO (2),
volume 12171 of Lecture Notes in Computer Science, pages 92–120. Springer, 2020.
15. D. Chaum and E. van Heyst. Group Signatures. In EUROCRYPT, volume 547 of

Lecture Notes in Computer Science, pages 257–265. Springer, 1991.

16. J. Couveignes. Hard Homogeneous Spaces. Cryptology ePrint Archive, Report

2006/291, 2006.

17. J. Don, S. Fehr, C. Majenz, and C. Schaﬀner. Security of the ﬁat-shamir transfor-
mation in the quantum random-oracle model. In Annual International Cryptology
Conference, pages 356–383. Springer, 2019.

18. J. Don, S. Fehr, C. Majenz, and C. Schaﬀner. Security of the Fiat-Shamir Trans-
formation in the Quantum Random-Oracle Model. In CRYPTO (2), volume 11693
of Lecture Notes in Computer Science, pages 356–383. Springer, 2019.

19. A. El Kaafarani, S. Katsumata, and F. Pintore. Lossy CSI-FiSh: Eﬃcient Signature
Scheme with Tight Reduction to Decisional CSIDH-512. In Public Key Cryptog-
raphy (2), volume 12111 of Lecture Notes in Computer Science, pages 157–186.
Springer, 2020.

20. M. F. Ezerman, H. Tae Lee, S. Ling, K. Nguyen, and H. Wang. A Provably
Secure Group Signature Scheme from Code-Based Assumptions. In ASIACRYPT
(1), volume 9452 of Lecture Notes in Computer Science, pages 260–285. Springer,
2015.

21. L. De Feo and S. D. Galbraith. SeaSign: Compact Isogeny Signatures from Class
Group Actions. In EUROCRYPT (3), volume 11478 of Lecture Notes in Computer
Science, pages 759–789. Springer, 2019.

22. A. Fiat and A. Shamir. How to Prove Yourself: Practical Solutions to Identiﬁcation
and Signature Problems. In CRYPTO, volume 263 of Lecture Notes in Computer
Science, pages 186–194. Springer, 1986.

23. S. D. Gordon, J. Katz, and V. Vaikuntanathan. A Group Signature Scheme from
Lattice Assumptions. In ASIACRYPT, volume 6477 of Lecture Notes in Computer
Science, pages 395–412. Springer, 2010.

24. A. B. Grilo, K. H¨ovelmanns, A. H¨ulsing, and C. Majenz. Tight adaptive repro-
gramming in the qrom. In International Conference on the Theory and Application
of Cryptology and Information Security, pages 637–667. Springer, 2021.

25. A. Kiayias and M. Yung. Secure scalable group signature with dynamic joins and

separable authorities. Int. J. Secur. Networks, 1(1/2):24–45, 2006.

26. E. Kiltz, V. Lyubashevsky, and C. Schaﬀner. A concrete treatment of ﬁat-shamir
signatures in the quantum random-oracle model. In Annual International Confer-
ence on the Theory and Applications of Cryptographic Techniques, pages 552–586.
Springer, 2018.

27. S. Kumawat and S. Paul. A New Constant-Size Accountable Ring Signature
In Inscrypt, volume 10726 of Lecture Notes

Scheme Without Random Oracles.
in Computer Science, pages 157–179. Springer, 2017.

33

28. F. Laguillaumie, A. Langlois, B. Libert, and D. Stehl´e. Lattice-Based Group Sig-
In ASIACRYPT (2), volume 8270 of

natures with Logarithmic Signature Size.
Lecture Notes in Computer Science, pages 41–61. Springer, 2013.

29. R. W. F. Lai, T. Zhang, S. S. M. Chow, and D. Schr¨oder. Eﬃcient Sanitizable
Signatures Without Random Oracles. In ESORICS (1), volume 9878 of Lecture
Notes in Computer Science, pages 363–380. Springer, 2016.

30. Y-F Lai and S. Dobson. Collusion resistant revocable ring signatures and group
signatures from hard homogeneous spaces. Cryptology ePrint Archive, 2021.
31. Benoˆıt Libert, S. Ling, F. Mouhartem, K. Nguyen, and H. Wang. Signature
Schemes with Eﬃcient Protocols and Dynamic Group Signatures from Lattice
Assumptions. In ASIACRYPT (2), volume 10032 of Lecture Notes in Computer
Science, pages 373–403, 2016.

32. S. Ling, K. Nguyen, H. Wang, and Y. Xu. Lattice-Based Group Signatures: Achiev-
ing Full Dynamicity with Ease. In ACNS, volume 10355 of Lecture Notes in Com-
puter Science, pages 293–312. Springer, 2017.

33. V. Lyubashevsky. Fiat-Shamir with Aborts: Applications to Lattice and Factoring-
Based Signatures. In ASIACRYPT, volume 5912 of Lecture Notes in Computer
Science, pages 598–616. Springer, 2009.

34. P. Q. Nguyen, J. Zhang, and Z. Zhang. Simpler Eﬃcient Group Signatures from
Lattices. In Public Key Cryptography, volume 9020 of Lecture Notes in Computer
Science, pages 401–426. Springer, 2015.

35. D. Pointcheval and J. Stern. Security Proofs for Signature Schemes.

In EU-
ROCRYPT, volume 1070 of Lecture Notes in Computer Science, pages 387–398.
Springer, 1996.

36. D. Pointcheval and J. Stern. Security Arguments for Digital Signatures and Blind

Signatures. J. Cryptol., 13(3):361–396, 2000.

37. R. L. Rivest, A. Shamir, and Y. Tauman. How to Leak a Secret. In ASIACRYPT,
volume 2248 of Lecture Notes in Computer Science, pages 552–565. Springer, 2001.
38. Claus-Peter Schnorr. Eﬃcient Signature Generation by Smart Cards. J. Cryptol.,

4(3):161–174, 1991.

39. D. X. Song. Practical forward secure group signature schemes.

In CCS, pages

225–234. ACM, 2001.

40. A. Stolbunov. Cryptographic Schemes Based on Isogenies. PhD thesis, 01 2012.
41. J. V´elu. Isog´enies entre courbes elliptiques. CR Acad. Sci. Paris, S´eries A, 273:305–

347, 1971.

42. S. Xu and M. Yung. Accountable Ring Signatures: A Smart Card Approach. In

CARDIS, volume 153 of IFIP, pages 271–286. Kluwer/Springer, 2004.

A Judging the opening

As a natural byproduct of our construction, we could also empower the manager
to generate a proof π additionally from Open that could be publicly veriﬁed
using an additional algorithm Judge as (re)deﬁned below:

– Open(msk, S =

∗: The rede-
pki}i∈[n], m, σ)
ﬁned open algorithm not only reveals signer identity pk but also produces a
publicly veriﬁable proof π for it.

(pk, π)

∪ {⊥}

× {

0, 1

→

(S

∈

{

}

)

34

– Judge(mpk, S =

→
accepts if the manager opened correctly,

{

pki}i∈[n], σ, pk, π)

acc

0, 1

}

∈ {

: The judge algorithm

Note that in Section 3.3, the opening within the sigma protocol is done by
picking the index k such that smEβ
k = EOpen. A manager could therefore prove
this equality in a Schnorr-like manner, re-starting from the sigma protocol ΣGA
with three additional algorithms JCommit, JResp, JVerify.

– JCommit(sm := msk,

Ei}i∈[n] :=

{

pki}i∈[n], com):

{

Eγ
i }i∈[n]), EOpen, ECheck)
as a lazy convention of sending a permuted list
}

Eβ
i }i∈[n], τ (
{

Eα
i }i∈[n],

{

We use τ (
•

)

{

(EJudge, Eb′
(cid:16)
Ei}i∈[n], jcom, jch, jst):

m), (b′, sm)
(cid:17)

1: b′ $
G
←−
2: parse com = (
{

3: EJudge := b′EOpen
4: Eb′
m := b′smE
5: return (jcom, jst) =

– JResp(Em,

{
1: parse jst = (b′, sm)
2: if jch = 0 then
3:
4: if jch = 1 then
5:

return jresp := b′

return jresp := l′ = b′sm
– JVerify(Em := mpk,
Ei}i∈[n] :=
{
{
Eβ
Eα
1: parse com = (
i }i∈[n], τ (
i }i∈[n],
{
{
{
2: parse jcom = (EJudge, Eb′
m)
3: if jch = 0 then
check EJudge = b′EOpen
4:
check Eb′
5:
6: if jch = 1 then
7:
8:
9: return 1 if all check pass

check EJudge = l′Eβ
k
check Eb′

m = b′Em

m = l′E

pki}i∈[n], Ek := pk, com, jcom, jch, jresp):
Eγ
i }i∈[n]), EOpen, ECheck)

For each run of Commit

(com, st), we have to do additionally ι repetitions
of JCommit (and thus ιt repetitions in total) to conﬁrm that it is opened to the
k-th signer with negl(ι) probability. Similar as before, the Fiat-Shamir transform
is applied for non-interactivity as follows.

→

S

{
; ι = λ

pki}i∈[n], m, σ)

– Open(msk, S =
1: t = 2λ
|
|
2: parse σ = (com, resp)
[t], outj ←
j
3:
∈
∀
[t], jcomi,j ←
[ι]
(i, j)
4:
∈
∀
×
5: jch :=
jchi,j }(i,j)∈[ι]×[t] ←
{
[t], (jrespi,j , jsti,j )
[ι]
(i, j)
6:
∈

×

∀

ΣGA.Open(msk, S, comi)

ΣGA.JCommit(msk,
H(σ,

{
jcomi,j}(i,j)∈[ι]×[t])
{
ΣGA.JResp(Em,
{
←

Ei}i∈[n], comj)

Ei}i∈[n], jcomi,j, jchi,j, jsti,j)

35

case of ties, Maj outputs a random choice of the marjority elements.

Maj outputs the majority element of a set. In

}

7: pk = Maj(
{

outj}j∈[t])
jcomi,j , jrespi,j}(i,j)∈[ι]×[t]

{

8: π :=
{
9: return (pk, π)

– Judge(mpk, S =

pki}i∈[n], σ, pk, π):

{

|

⊥

; ι = λ

1: return 0 if pk =
2: t = 2λ
S
|
3: parse σ = (com, ch, resp)
4: parse π =
5: jch :=
j
6:
∈
∀
7: return 1 if

jchi,j }(i,j)∈[ι]×[t] ←
j∈[t] joutj ≥
V

{
[t], joutj ←

{

λ

P

jcomi,j, jrespi,j}(i,j)∈[ι]×[t]

H(σ,
i∈[ι] ΣGA.JVerify(mpk,

jcomi,j}(i,j)∈[ι]×[t])
{

{

Ei}i∈[n], pk, comj, jcomi,j, jchi,j , jrespi,j)

Eoutj , jcomi,j, jchi,j, jrespi,j}(i,j)∈[ι]×J

J ⊆

[t] is adaptively chosen. So long as we have

Here, a corrupted manager gets to selectively generate a partial proof
where
λ, the
judged proof is accepted. This does not prevent the manager from generating
accepted proofs that open to diﬀerent members when #
> 1, which could
{
happen if the corresponding signature is generated by multiple colluding signers.
Otherwise, incriminating an honest non-signer would require to make up at least
λ valid sessions of Commit, which will succeed with only negligible probability,
poly(λ) and valid master key pair
i.e. for any PPT adversary A, any nh ≤
(mpk, msk)
Pr[A wins GJUF

{
j∈J joutj ≥

∈ KPm,

P
Eoutj }

negl(λ),

≤

n

A,nh ]
where the judging unforgeability game GJUF

≤

A,nh is as speciﬁed below.

GJUF

A,nh : Judging unforgeability game

Keygen(1λ). Let Hon =

{
ASign(•,•,•,ski∈Hon),Corrupt(•)(Hon)

pki}i∈[nh], Cor =
Hon and stores query pki in list Cor

{}

.

[nh], (pki, ski)

i
1:
∀
∈
←
2: (S, m∗, σ∗)
Corrupt(pki) returns ski for pki ∈
(pk, π)
Judge(mpk, S, σ, pk, π).

←

←

{

Open(msk, S, m, σ∗) satisﬁes pk

3: A wins if (m∗, σ∗) is not an output of Sign, 1

Verify(mpk, S, m∗, σ∗),

←
∈ {⊥} ∪

Hon

\

Cor, and 1

←

}

B Fiat-Shamir transform with augmented input

In this section, we talk about a natural way to generalize the Fiat-Shamir trans-
fomration into a broader class of signatures, in which a signer can have an
augmented input aug on its choice. This is in order to capture that, in our ac-
countable ring signature (ARS) scheme, a signer gets to choose some subset S
of members and the master mpkν before signing a message. In principle, such

36

generalization allows a broader class of attack, but as we will discuss later, some
standard results generalize as well.

Given a sigma protocol Σ, deﬁne the augmented Fiat-Shamir transform

FS∗[Σ], as the following signature scheme:

– Keygen(1λ):

1: return (pk, sk)

generator of a hard relation.

←

{

}

– Sign(pk, aug, m, sk):

G

Generate the key pair as usual, by some instance

1: w := sk
2: x := (pk, aug)

{

Associate the witness with the secret key as usual.

Squeeze in the augmented input aug into the statement

}

{

Σ.Commit(x, w)

x.
}
3: com, st
4: ch := H(m, com)
5: resp
Σ.Resp(x, com, ch, st)
6: return σ := (com, resp, aug)

←

←

– Verify(pk, m, σ):

1: parse σ =: (com, resp, aug)
2: x := (pk, aug)
3: ch := H(m, com)
4: return acc

←

Σ.Verify(x, com, ch, resp)

Correspondingly, the unforgeability games against chosen message attacks GsUF−CMA
FS∗[Σ],A (λ)
and GUF−CMA
, sk),
FS∗[Σ],A(λ) now allows adversary A to query the signing oracle Sign(pk,
•
as follows. Note that, for any choices of augmented inputs aug1 and aug2, the
equality Sign(pk, aug1, m, sk) = Sign(pk, aug2, m, sk), would imply aug1 = aug2.
Therefore the strong unforgeability game deﬁned below is without ambiguity.

•

,

GsUF−CMA

FS∗[Σ],A (λ): Strong unforgeability game against chosen-message attacks

←

Keygen(1λ)
ASign(pk,•,•,sk)(pk)

1: (pk, sk)
2: (m∗, σ∗)
3: check σ∗ is not an oracle output of Sign using the message m∗
4: check 1
5: A wins if all check pass

Verify(pk, m∗, σ∗)

←

←

GsUF−CMA

FS∗[Σ],A (λ): Weak unforgeability game against chosen-message attacks

←

Keygen(1λ)
ASign(pk,•,•,sk)(pk)

1: (pk, sk)
2: σ∗
3: check σ∗ is not an oracle output of Sign
4: check 1
5: A wins if all check pass

Verify(pk, m∗, σ∗)

←

←

37

GUF−NMA

FS∗[Σ],A(λ): Unforgeability game against no-message attacks

1: (pk, sk)
2: (m∗, σ∗)
←
3: A wins if 1

←

Keygen(1λ)
A(pk)

Verify(pk, m∗, σ∗)

←

Although FS∗[Σ] may be exposed to a stronger attack, it doesn’t seem to
provide any additional handle to the adversary if there is no access to the signing
oracle. As opposed to the chosen-message attacks, this is often referred to as the
no-message attacks, which is described above following the standard deﬁnition.
In line with Corollary 5, if the regular Fiat-Shamir signature FS[Σ] is UF-NMA
secure, then so is FS∗[Σ].

Corollary 5. Let Σ be a sigma protocol. Then for any eﬃcient adversary A
against FS∗[Σ], there is an eﬃcient adversary B against FS[Σ] such that

AdvUF−NMA
FS∗[Σ]

(A)

≤

AdvUF−NMA
FS[Σ]

(B) ,

where the advantages are as deﬁned in [26, Section 2.4].

Proof. B simply simulates A in order to produce a FS∗[Σ]-forgery σ =: (com, resp, aug)
for the message m, and then produce (com, resp) as a FS[Σ]-signature of the mes-
sage (m, aug). The signature is FS∗[Σ]-valid if σ is FS[Σ]-valid.

Other than that, we note that one of the standard results is a reduction from
sUF-CMA security to UF-NMA. Indeed, this can then be generalized as follows.

Lemma 15. Let Σ be a sigma protocol that is of high entropy, statstical HVZK.
Then for any eﬃcient algorithm A(x) making queries to the signing oracle
FS∗[Σ].Sign(pk,
, sk) and the QRO H, there is an eﬃcient simulator B(x)
without access to the oracles such that for any eﬃcient predicate V (y)

•

•

,

Pr

acc = 1

AFS∗[Σ].Sign(pk,•,•,sk),H (x)→y
V (y)→acc

Pr

acc = 1

B(x)→y
V (y)→acc

negl

≤

−

i

h

(cid:12)
(cid:12)
(cid:12)

i(cid:12)
(cid:12)
(cid:12)

h

(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)

Proof. The proof is similar as in the proof of Lemma 11 we can always simu-
late A via A2 with the signing oracle further augmented to (com, ch, resp, aug)
Sign2(pk,
but not the QRO H. A3 will need to simulate H on its own.

←
, sk). Next, we simulate A2 via A3 making queries only to Sign2(pk,
•

•

•

,

, sk)

,

•

– ASign2(pk,•,•,sk)

(x):
3
1: while A2 not terminated do
2:
3:

queries (com, ch, resp, aug)

if the next step queries Sign2(pk, aug, m, sk) then

Sign2(pk, aug, m, sk)

←

38

program H(m, com) := ch
send back (com, ch, resp, aug) to the simulation

4:
5:
6:
7:
8: return the output of A2

else

simulate the same procedure

Since Σ is of high min-entropy, via [24, Theorem 1] we obtain

V

Sign2(pk,•,•,sk),H
A
2

(x)

Sign2(pk,•,•,sk)
A
3

(x)

.

V

≈

(cid:17)

(cid:16)

(cid:16)

Then, we simulate A3 using A4 querying Trans(
•
lying sigma protocol.

) the transcript of the under-

(cid:17)

(x):

– ATrans(•)
4
1: while A2 not terminated do
2:
3:
4:
5:
6:
7:
8: return the output of A3 .

else

simulate the same procedure

if the next step queries Sign2(pk, aug, m, sk) then

x′ := (pk, aug)
(com, ch, resp)
send back σ := (com, ch, resp, aug) to the simulation

Σ.Trans(x′)

←

The output distribution only diﬀers at the situation where the same com occurs
twice from Trans. Due to the high min-entropy, this only happens with negligible
probability.

Finally, due to the statistical HVZK property, B simulates A4 by changing
the queries of Trans to using the simulator of the sigma protocol directly. Such
eﬀect to the output distribution is only negligible. Putting things together, we
get

V

≈

AFS∗[Σ].Sign(pk,•,•,sk),H (x)
(cid:17)
(cid:16)
V
V

(x)

ASign2(pk,•,•,sk)
(cid:16)

≈

(cid:17)

3

≈

(cid:16)

2

V

ASign2(pk,•,•,sk),H
(cid:16)
ATrans(•)

(x)

4

(cid:17)

V (B(x)) .

(x)

≈

(cid:17)

Theorem 4. Let Σ be a sigma protocol that is of high entropy, perfect-unique-
response, and statistical HVZK, then for any eﬃcient adversary A there is an
eﬃcient adversary B such that

AdvUF−CMA
FS∗[Σ]
AdvsUF−CMA
FS∗[Σ]

(A)

(A)

≤

≤

AdvUF−NMA
FS∗[Σ]
AdvUF−NMA
FS∗[Σ]

(B) + negl

(B) + negl

(4)

(5)

Proof. By setting the predicate in Lemma 15 to the veriﬁcation FS[Σ]∗.Verify(pk, m,
we obtain the adversary B with success probability negligibly close.

),

•

39

C Isogeny class group action

Here we brieﬂy cover the basics for elliptic curve isogenies. For simplicity, we
consider a working (ﬁnite) ﬁeld Fq with characteristic p > 3. An isogeny φ be-
E2 deﬁned over an algebraic closure ¯Fq is a surjective
tween elliptic curves E1 →
homomorphism between the groups of rational points E1(¯Fq)
E2(¯Fq) with a
ﬁnite kernel. If, additionally, φ is assumed separable, i.e. the induced extension
¯Fp(E1) is sepa-
of function ﬁelds φ∗ : ¯Fq(E2) ֒
¯Fq(E1) by ¯Fp(E2)
E2
rable, then for any ﬁnite subgroup H
≤
having H as its kernel, and the co-domain curve is furthermore uniquely de-
termined up to isomorphisms (in ¯Fq). We refer to the co-domain curve as the
quotient curve, denoted E1/H. A corresponding isogeny could be computed us-
ing Velu’s formula speciﬁed in [41], which works by expanding the coordinates
of Q = φ(P ) as follows,

f
◦
E1(¯Fp), there is an isogeny φ : E1 →

→

→

7→

∈

∋

φ

f

x(Q) = x(P ) +

(x(P + R)

XR∈H\{0}

y(Q) = y(P ) +

(y(P + R)

XR∈H\{0}

x(R)) ,

y(R)) .

−

−

The separable degree degsep φ is deﬁned as the separable degree for φ∗, which co-
incides with the size of its kernel # ker φ, and since any isogeny could be acquired
πk
p where
by precomposing Frobenius maps to a separable isogeny, i.e. of form φ
◦
=
φ is separable, we can (equivalently) deﬁne the (full) degree deg
πpk
φ
degsep(φ)pk. From now on, we will assume separability of isogenies unless other-
wise speciﬁed, and therefore deg φ = degsep φ in this case.

◦

(cid:0)

(cid:1)

For large degree φ, when both domain E1 and co-domain E2 (supersingular)
curves are prescribed, it could be hard to determine the kernel (and thus φ). The
current best-known (generic) quantum algorithm is claw ﬁnding, which takes
˜O

operations.

deg(φ)1/3

(cid:0)

(cid:1)

One important structure for isogenies is the so-called isogeny class group ac-
tion, which was ﬁrst used for cryptographic constructions by [16, 40], and was
viewed as a weaker alternative for discrete logarithm. However, although theo-
retically feasible, the instantiated group action used to rely heavily on techniques
regarding the so-called modular polynomials, which is computationally expensive
in practice. Later on, improvements in the Commutative SIDH (CSIDH) [13]
scheme got rid of these techniques. Concretely, the space X is instantiated as a
/ ∼=Fp acted by their ideal
set
ℓℓp(
class group Cl(
= Endp(E) where
O
Q tensored as a Z-module is identical regardless of the
, πp) but
E
ℓℓp(
O
). The additional parameter πp denotes
ℓℓp(
choice of E
the p-power Frobenius πp : (x, y)
) are equivalence
classes a of ideals of the (partial) endomorphism ring
). Any such
ideal class a
, πp)

O
⊳ Endp(
) therefore acts on the curves by sending E

E/Fp supersingular elliptic curves
{
}
) of the Fp-rational endomorphism ring

(xp, yp). Elements of Cl(

O ⊗
, πp) thus so is Cl(

, πp) =

ℓℓp(

∈ E

∈ E

Cl(

7→

O

O

O

O

J

E

O
∈ E

O

∈

O

40

J

to the quotient curve a
equivalence class a and E[

·

E := E/E[

] where

a is a representative of the

] =

f ∈J ker f is the simultaneous kernel of

J

J ∈

T

i :

The working base ﬁeld Fp for CSIDH is carefully selected such that p =
1 where each ℓi > 2 is a small prime generally referred to as an Elkies
ℓn −
4ℓ1 · · ·
prime. This allows one to generate a heuristically large enough sub-covering
le1
1 . . . len
) where each prescribed bi is small8 and each l±1
of Cl(
bi}
ei| ≤
n |∀
{
O
. The indices (e1, . . . , en) thus represent the ideal
1, ℓii
πp ∓
is the class of ideal
h
len
class le1
n , making it easier to compute the co-domain curve. In particular,
i
for a curve E
πp −
h
1, ℓii

, πp) and any choice of ℓi, the curve li ·

] is computed by sampling a generator of the kernel,

E := E/E[

ℓℓp(

∈ E

· · ·

O

|

i

.

J

E[

πp −
h

] = E(Fp)[ℓi] =

1, ℓii

P

{

E(Fp)
|

∈

ℓiP = 0

,

}

which is a one dimensional Z/ℓ-linear eigen-subspace of πp within the ℓi-torsion
Et)t where the
E[ℓi]. For the opposite direction, one can compute l−1
superscript t is referred to as the quadratic twist of the speciﬁed curve, by taking
the convention that the curve is ﬁxed when its j-invariant is 1728, or equivalently,
this can be done by sampling from the other Z/ℓi-linear eigen-subspace of πp in
E[ℓi], which sits in the quadratic extension E(Fp2 ).

E = (li ·

·

i

O

O

E1 = E2. Finally, elements in

ℓℓp(
, πp), there exists a unique a

We also list here some well-known properties for the considered class group
action. First, the class group Cl(
) commutes, which is a direct result of the fact
that the Fp-rational endomorphism ring Endp(E) commutes. Second, as noted
in [13, Theorem 7], Cl(
, πp), which means
) acts freely and transitively on
O
) such that
ℓℓp(
that for all E1, E2 ∈ E
a
, πp) can be eﬃciently veriﬁed. We note
O
·
that a curve E is supersingular if and only if it has p + 1 points over Fp. This
4√p
can be eﬃciently tested by ﬁnding some P
dividing p + 1. A random point P sampled from E(Fp) satisﬁes such a condition
with high probability if E is supersingular, and whether it does can be veriﬁed
= 0, then ord(P ) does not divide p + 1 and E is
eﬃciently as follows. If (p + 1)P
ordinary. Otherwise, we can perform the so-called batch co-factor multiplication
computing Pi = p+1
P for each i, by using convention that ℓ0 = 4. This allows
ℓi
us to determine ord(P ) =

E(Fp) with order ord(P )

O
∈

ℓℓp(

Cl(

O

≥

∈

E

E

i ord(Pi).

Q

For typical cryptographic constructions such as CSIDH, additional heuristic
assumptions are required to sample a random element from the class group (as
in Deﬁnition 2). This is because the “CSIDH-way” for doing this is by sampling
bi, and the resulting distribution
exponents (e1, . . . , en) satisfying
for ideals le1
1 . . . len
). To get rid of such
heuristics, one could instead work with speciﬁc parameters, where a bijective
(yet eﬃcient) representation of ideals is known. For instance, in [6], the structure
) is computed, including a full generating set of ideals l1, . . . , ln and the
of Cl(
n = id
entire lattice Λ :=
. Evaluating the group action is
}
just a matter of approximating a closest vector and then evaluating the residue as

i :
n is generally non-uniform within Cl(

(e1, . . . , en)
|

le1
1 . . . len

ei| ≤

O

O

∀

{

|

8 For CSIDH-512 [13] proposes b1 = · · · = bn = 5.

41

6
in CSIDH. In this work, we will be working with such a “perfect” representation
of ideals, unless otherwise speciﬁed.

As a remark, we note that the D-CSIDH problem for characteristic p = 1
mod 4 is known to be broken [14]. Nevertheless, the attack is not applicable to
the standard CSIDH setting where p = 3 mod 4.

D Sigma protocol

A sigma protocol should satisfy the following three properties.

Deﬁnition 13. (Correctness) A sigma protocol is correct if for any (x, w)
the probability

∈

R,

Pr

(com, st)

h
is negligible.

P1(x, w), ch $

←− C

←

, resp

←

P2(st, ch), 0

←

V (x, com, ch, resp)

i

Deﬁnition 14. (Honest Veriﬁer Zero Knowledge/HVZK) Let Trans(x, w)
→
(com, ch, resp) be a function that honestly executes the sigma protocol and outputs
a transcript. We say that the sigma protocol is HVZK if there exists a simulator
(com, ch, resp) such that the output distribution of Trans(x, w) and
Sim(x)
Sim(x) is indistinguishable.

→

Deﬁnition 15. (µ-special soundness) A sigma protocol is µ-special sound if
there exist an eﬃcient extractor Ext such that, for any set of µ transcripts
with the same (x, com), denoted as (x, com,
respi}i∈[µ]), where every
chi is distinct, the probability

chi}i∈[µ],

{

{

Pr

(x, s) /
∈

h

is negligible.

R

i
∧ ∀

∈

[µ], acci = 1 :

∀i∈[µ], acci←V (x,com,chi,respi),
s←Ext(x,com,{chi}i∈[µ],{respi}i∈[µ])

i

Here, we formulate a more general form of special soundness. While most
sigma protocol constructions in the literature adopt 2-special soundness, any
µ-special sound protocol with constant µ can be similarly transformed into a
signature scheme, simply by applying more rewinding trials.

E Analysis in classical ROM

E.1 The forking lemma

The concept of the forking lemma is as follows. In the random oracle model,
let A be an adversary that can with non-negligible probability generate valid

42

transcripts (m, com, ch, resp) with ch = H(m, com). Since H is a random oracle,
for some (m, com), A should be able to succeed on suﬃciently many diﬀerent ch′
from H in order to achieve an overall non-negligible success probability. If we
can rewind and rerun A with diﬀerent oracle outputs on H(m, com), we should
be able to get multiple accepting transcripts.

→

To dig a little bit deeper, we can construct an eﬃcient algorithm B that runs
(m, com, ch, resp) has at most Q oracle queries.
A as a subroutine, where A
The tuple (m, com) should, with all but negligible probability, be among one
of the Q queries. B ﬁrst guesses the critical query i
[Q], the index where
Qi = (m, com) is being queried. Then, B replays A with ﬁxed random tape,
ﬁxed oracle outputs for the ﬁrst i
1 queries, and fresh random oracle outputs
for the remaining queries. If the query guess i and ﬁxed randomness are “good,”
which should happen with non-negligible probability, then among suﬃciently
many retries we should get t successful outputs of A, which are transcripts with
identical (m, com) with distinct challenges ch’s. For a rigorous proof, we refer
the reader to [35, 36] for the forking lemma with 2 transcripts and [11] for a
µ-transcript version.

−

∈

Here, we give a reformulated version of the improved forking lemma proposed
by [11]. We renamed the variables to ﬁt our notion and restricted parameters to
the range that is suﬃcient for our proof.

H

Theorem 5. (The Improved Forking Lemma [11], Reformulated) Let A be a
probabilistic polynomial-time algorithm and Sim be a probabilistic polynomial-
time simulator which can be queried by A. Let H be a random oracle with image
2λ. If A can output some valid tuple (m, com, ch, resp) with non-
size
1/poly(λ) within less than Q queries to the random
negligible probability ε
oracle, then with O(Qµ log µ/ε) rewinds of A with diﬀerent random oracles, A
will, with at least constant probability, output µ valid tuples (m, com, chi, respi)
with identical (m, com) and pairwise distinct chi’s.

| ≥

≥

|

E.2 Proof of Lemma 10

Proof. Assume that there exists an eﬃcient adversary A that wins GUF
on some valid key pair (mpk, msk)
∈ KPm with non-negligible probability. We
aim to show that we can construct some algorithm AEXT which runs A as a
subroutine and extract an un-corrupted secret key.

A,nh (mpk, msk)

As it doesn’t hurt for a signing oracle to produce the challenges, let’s abuse
the notation as say the signing oracle returns not only the signature, but also
those corresponding challenges. First, we replace the Sign oracle with a sim-
ulator, so that AEXT can emulate the oracle responses to A. We consider a
modiﬁed game GUF,1
Hon)
A,nh
by a simulator Sim(
•

which replaces the signing oracle Sign(
•

Hon), where Sim is deﬁned as follows:

, ski ∈

•

•

•

•

,

,

,

,

– Sim(mpk, S, m, pk

∈

, pki ∈
S):

43

1: decide t correspondingly
2: for j
3: program H(com1, . . . , comt, m) := (ch1, . . . , cht)
4: return σ = (com, ch, resp) := ((com1, . . . , comt), (ch1, . . . , cht), (resp1, . . . , respt))

[t], (comj, chj, respj)

ΣGA.Sim(mpk, S, pk

S)

←

∈

∈

Since Σ.Sim is a statistical HVZK simulator, any adversary with Q = poly(λ)
queries to H cannot distinguish Sign from Sim with non-negligible probability.
Thus A should also win GUF,1
A,nh
Now, since A wins GUF,1
A,nh

that out∗
Open(msk, R, m, σ∗) satisﬁes out∗ = pki ∈
wins with non-negligible probability with out∗ =
that A wins with non-negligible probability with out∗ = pkk ∈
with these cases separately.

(mpk, msk) only if it outputs some (R, m∗, σ∗) such
, either A
, or there exists some k such
Hon. We deal

with non-negligible probability.

Hon or out∗ =

←

⊥

⊥

{

⊥

(pki, ski)

We ﬁrst prove that there cannot exist eﬃcient A⊥ that wins GUF,1
A,nh

(mpk, msk)
with non-negligible probability with out∗ =
. If such A⊥ exists, we can con-
struct an algorithm B that honestly generates
}i∈[nh] and runs A⊥
{
with input Hon =
pki}i∈[nh]. The oracle Corrupt can be perfectly emulated
by B since B holds every ski. With non-negligible probability, A⊥ will output
valid (S, m, σ = (com, ch, resp)) such that
Open(msk, S, m, σ). By applying
the improved forking lemma (Theorem 5), with r = O(Q/ε) rewinds of A⊥, it
would, with constant probability, output four valid signatures (S, m, σ1, . . . , σ4)
with identical com and pairwise distinct chc, and that
Open(msk, S, m, σc)
[4]. We now claim that with high probability, we can ﬁnd some par-
for all c
allel session j
j are
distinct. Note that this is not trivially true, as the forking lemma only promises
that ch1, . . . , ch4 are pairwise distinct as vectors, so they might not be pairwise
distinct on any index j.

Σ.Open(msk, S, comj) and ch1

j , . . . , ch4

[t] such that

⊥←

⊥←

⊥←

∈

∈

Let T be the set of indices j where

Σ.Open(msk, S, comj). Since

Open(msk, S, m, σ), by the deﬁnition of Open,
output among the t parallel sessions. Thus
T
four challenges ch′1
that ch′1
the probability that they are good on T is 1

⊥←
must be (one of) the majority
λ. We say that
t/(
|
T such
are good on T if there exists some j
j are distinct. For 4 independently random challenges in [4]t,
(1

(4!/44))|T | = 1

j , . . . , ch′4

, . . . , ch′4

negl(λ).

⊥
| ≥

+ 1)

⊥←

≥

∈

S

|

|

−

−

−

Unfortunately, the challenges ch1, . . . , ch4 obtained from rewinding A are not
necessarily independent. To cope with this, we will need the fact that in each
rewind of A, the valid ch is a new random output from the new random oracle
H. Thus, the ﬁnally output 4-tuple ch1, . . . , ch4 must be a subset of r = O(Q/ε)
independent random samples from [4]t. By the union bound, the probability that
negl(λ). Thus
all 4-tuples in the r samples are good on T is 1
T such that ch1
negl(λ).
we can ﬁnd j

negl(
|
j are distinct with probability 1

j , . . . , ch4

−

≥

−

r
4

T

1

)

|

(cid:0)

(cid:1)

∈

j , . . . , ch4
For such j, we without loss of generality let (ch1
j , . . . , resp4
[4], 1
c
∀

j ). Now B achieves

consider (S, comj, resp1

∈

←

−
j ) = (1, . . . , 4) and

Σ.Verify(S, comj, c, respc

j),

44

and
erty of Σ and brings a contradiction. Hence such A⊥ cannot exist.

Σ.Open(msk, S, comj). Thus B violates the 4-special soundness prop-

⊥←

Now we consider the case where some Ak wins GUF,1
A,nh

(mpk, msk) with non-
negligible probability with out∗ = pkk. We will show that if such Ak exists, we
can build AEXT from Ak.

We ﬁrst do some modiﬁcation on the Corrupt oracle by considering the game
A,nj ,k(mpk, msk, pk) which, on top of GUF,1
, applies the following modiﬁcation:

A,nh

GUF,2

1. Set (pkk, skk) = (pk,

). Other (pki, ski)’s are generated honestly for i

[nh]

⊥
2. Replace the oracle Corrupt() with Corrupt∗

\ {

k

}

k(), which aborts when pkk is

∈

queried and otherwise honestly outputs as Corrupt.

3. Change the winning condition to: A wins if (m∗, σ∗) is not an output of
Open(msk, S, m, σ∗). In

Verify(mpk, S, m∗, σ∗) and pk = pkk ←
Sign, 1
other words, we restrict to the case that A wins with out∗ = pkk.

←

∈ E

Note that for Ak to win GUF,1
A,nh

(mpk, msk) with out∗ = pkk, it cannot query
Corrupt(pkk), thus Ak should also win GUF
A,2,k(mpk, msk, pk) with non-negligible
probability, 1/nh times as likely, for pk honestly generated from Keygen. By
the construction of Keygen, it is equivalent to sampling a random Ech

.

{

{

(pki, ski)

Now, for Ak winning GUF,2

A,nh,k(mpk, msk, pk) with non-negligible probability,
we can similarly construct an algorithm B that honestly generates nh −
1 key
pki}i∈[nh] where pkk =
}i∈[nh]\{k} and runs Ak with input Hon =
pairs
pk. Then again by applying the improved forking lemma, with the same probabil-
ity, r = O(Q/ε) rewinds of Ak will output four valid signatures (S, m, σ1, . . . , σ4)
with identical com and pairwise distinct chc, so that pk
Open(msk, S, m, σc)
[4]. Again by the same argument as in the case of A⊥, we can with
for all c
ΣGA.Open(msk, S, comj) and
high probability ﬁnd some j
ch1

∈
j , . . . , ch4
Now, without loss of generality let (ch1

j ) = (1, . . . , 4) and consider
(S, comj, resp1
j , . . . , resp4
[4], 1
j),
c
∀
and that the challenge statement pk
ΣGA.Open(msk, S, comj). Thus by the
4-special soundness property of ΣGA, we can extract the matching secret key
sk

ΣGA.Verify(S, comj, c, respc

∈
←
j , . . . , resp4

←
From the previous arguments, we see that if such eﬃcient Ak exists, then

ΣGA.Ext(S, comj, resp1

j ), such that (pk, sk)

j are distinct.

[t] such that pk

j ). We have

j , . . . , ch4

RE.

←

←

←

∈

∈

we can obtain an algorithm B based on Ak that, on inputting random pk

, output sk such that (pk, sk)

∈
RE with non-negligible probability. Thus,
PK
we successfully construct a secret extractor from adversary A that wins the
unforgeability game, which concludes the proof that our
ARS Σ is unforgeable
assuming the instance relations are hard (to extract witness) for Σ.

∈

Remark 4. For instantiation where Σ = ΣGA, this extractor breaks GAIP as
, we simply run B twice
follows, when obtaining random challenges E1, E2 ∈ E

45

to get s1, s2 such that s1E = E1, s2E = E2, then we directly obtain E2 =
(s1s−1

2 )E1.

F Group signature

A group signature scheme consists of one manager and n parties. The manager
can set up a group and provide secret keys to each party. Every party is allowed
to generate signatures on behalf of the whole group. Any party can verify the
signature for the group without knowing the signer, while the manager party
can open the signer’s identity with his master secret key.

Syntax. A group signature scheme

GS

consists of the following four algorithms.

– GKeygen(1λ, 1n)

{

→

(gpk,

N is the number of parties in the group, and outputs (gpk,

ski}i∈[n], msk): The key generation algorithm
GKeygen takes 1λ and 1n as inputs where λ is the security parameter and
ski}i∈[n], msk)
n
where gpk is the public key for the group, ski being the secret key of the i-th
[n], and msk is the master secret key held by the manager
player for each i
for opening.

∈

∈

{

– GSign(gpk, m, skk)

σ: The signing algorithm GSign takes a secret key

skk and a message m as inputs, and outputs a signature σ of m using skk.

→

– GVerify(gpk, m, σ)

: The veriﬁcation algorithm GVerify takes
the public key gpk, a message m, and a candidate signature σ as inputs, and
outputs either 1 for accept or 0 for reject.

0, 1

∈ {

→

}

y

– GOpen(gpk, msk, m, σ)

[n]: The open algorithm GOpen takes the
public key gpk, the manager’s master secret key msk, a message m, and a
signature σ as inputs, and outputs an identity k or abort with output

→

∈

k

.

⊥

A group signature scheme should satisfy the following security properties.

Correctness. A group signature scheme is said to be correct if every honest
signature can be correctly veriﬁed and opened.

Deﬁnition 16. A group signature scheme
(gpk,

GKeygen(1κ, 1n), any i

is correct if for any tuple of keys
[n] and any message m,

GS

ski}i∈[n], msk)

{

←

∈

Pr

acc=1∧out=i :

(cid:20)

σ←GSign(gpk,m,ski),
acc←GVerify(gpk,m,σ),
out←GOpen(gpk,msk,m,σ)(cid:21)

> 1

−

negl(λ)

Anonymity. A group signature is said to be anonymous if no adversary can
determine the signer’s identity among the group of signers given a signature,
without using the master’s secret key (msk).

46

Deﬁnition 17. A group signature scheme
adversary A and any n = poly(λ),

GS

is anonymous if for any PPT

Pr[1

GAnon

A,0 (λ, n)]

Pr[1

−

←

GAnon

A,1 (λ, n)]

←
where the game GAnon

(cid:12)
(cid:12)

A,b (λ, n) is deﬁned below.

negl(λ),

≤

(cid:12)
(cid:12)

GAnon

A,b (λ, n): Anonymity game
1: (gpk,
ski}i∈[n], msk)
←
ski}i∈[n])
A(gpk,
2: (st, i0, i1)
{
3: b
0, 1
← {
AGSign(gpk,·,skib )(st)
4: return out

←
}

{

GKeygen(1λ, 1n)

←

Unforgeability. A group signature is said to be unforgeable if no adversary can
forge a valid signature that fails to open or opens to some non-corrupted parties,
even if the manager has also colluded.

Deﬁnition 18. A group signature scheme
adversary A and any n = poly(λ),

GS

is unforgeable if for any PPT

Pr[A wins GUF

A (λ, n)] < negl(λ),

where the game GUF

A (λ, n) is deﬁned below.

GUF

A (λ, n): Unforgeability game
ski}i∈[n], msk)
1: (gpk,
2: (m∗, σ∗)

{

GKeygen(1λ, 1n), Cor =

{}
AGSign(gpk,•,ski /∈Cor),Corrupt(•)(gpk, msk)

←

Corrupt(i) returns ski stores query i in list Cor

←

{

3: A wins if (m∗, σ∗) is not an output of GSign, 1

GVerify(gpk, m∗, σ∗)

}
←
Cor

and i

GOpen(gpk, msk, m∗, σ∗) satisﬁes i /
∈

←

47

