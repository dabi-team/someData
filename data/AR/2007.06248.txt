0
2
0
2

l
u
J

3
1

]

O
L
.
s
c
[

1
v
8
4
2
6
0
.
7
0
0
2
:
v
i
X
r
a

Complexity of Veriﬁcation and Synthesis of
Threshold Automata ⋆

A. R. Balasubramanian, Javier Esparza, and Marijana Lazi´c

Technical University of Munich, Germany

Abstract. Threshold automata are a formalism for modeling and ana-
lyzing fault-tolerant distributed algorithms, recently introduced by Kon-
nov, Veith, and Widder, describing protocols executed by a ﬁxed but
arbitrary number of processes. We conduct the ﬁrst systematic study
of the complexity of veriﬁcation and synthesis problems for threshold
automata. We prove that the coverability, reachability, safety, and live-
ness problems are NP-complete, and that the bounded synthesis problem
is Σ2
p complete. A key to our results is a novel characterization of the
reachability relation of a threshold automaton as an existential Pres-
burger formula. The characterization also leads to novel veriﬁcation and
synthesis algorithms. We report on an implementation, and provide ex-
perimental results.

Keywords: Threshold automata, distributed algorithms, parameterized
veriﬁcation

1

Introduction

Many concurrent and distributed systems consist of an arbitrary number of
communicating processes. Parameterized veriﬁcation investigates how to prove
them correct for any number of processes [1].

Parameterized systems whose processes are indistinguishable and ﬁnite state
are often called replicated systems. A global state of a replicated system is com-
pletely determined by the number of processes in each state. Models of replicated
systems diﬀer in the communication mechanism between processes. Vector Ad-
dition Systems (VAS) and their extensions [12,8,10,2] can model rendez-vous,
multiway synchronization, global resets and broadcasts, and other mechanisms.
The decidability and complexity of their veriﬁcation problems is well understood
[11,9,25,1,2].

Transition guards of VAS-based replicated systems are local : Whether a tran-
sition is enabled or not depends only on the current states of a ﬁxed number of
processes, independent of the total number of processes. Konnov et al. observed
in [16] that local guards cannot model fault-tolerant distributed algorithms. In-
deed, in such algorithms often a process can only make a step if it has received

⋆ This project has received funding from the European Research Council (ERC) under
the European Union’s Horizon 2020 research and innovation programme under grant
agreement No 787367 (PaVeS).

 
 
 
 
 
 
a message from a majority or some fraction of the processes. To remedy this,
they introduced threshold automata, a model of replicated systems with shared-
variable communication and threshold guards, in which the value of a global
variable is compared to an aﬃne combination of the total numbers of processes
of diﬀerent types. In a number of papers, Konnov et al. have developed and im-
plemented veriﬁcation algorithms for safety and liveness of threshold automata
[16,17,19,15,18]. Further, Kukovec et al. have obtained decidability and undecid-
ability results [20] for diﬀerent variants of the model. However, contrary to the
VAS case, the computational complexity of the main veriﬁcation problems has
not yet been studied.

We conduct the ﬁrst systematic complexity analysis of threshold automata.
In the ﬁrst part of the paper we show that the parameterized coverability and
reachability problems are NP-complete. Parameterized coverability asks if some
conﬁguration reachable from some initial conﬁguration puts at least one process
in a given state, and parameterized reachability asks if it puts processes in ex-
actly a given set of states, leaving all other states unpopulated. The NP upper
bound is a consequence of our main result, showing that the reachability rela-
tion of threshold automata is expressible in existential Presburger arithmetic.
In the second part of the paper we apply this expressibility result to prove that
the model checking problem of Fault-Tolerant Temporal Logic (ELTLFT) [19] is
NP-complete, and that the problem of synthesizing the guards of a given au-
tomaton, studied in [22], is Σ2
p complete. The last part of the paper reports
on an implementation of our novel approach to the parameterized (safety and
liveness) veriﬁcation problems. We show that it compares favorably to ByMC,
the tool developed in [18].

Due to lack of space most proofs have been moved to the Appendix.

2 Threshold Automata

We introduce threshold automata, illustrating the deﬁnitions on the example of
Figure 2, a model of the Byzantine agreement protocol of Figure 1.

Environments. Threshold automata are deﬁned relative to an environment
Env = (Π, RC , N ), where Π is a set of parameters ranging over N0, RC ⊆ NΠ
0 is
a resilience condition expressible as an integer linear formula, and N : RC → N0
is a linear function. Intuitively, a valuation of Π determines the number of pro-
cesses of diﬀerent kinds (e.g., faulty) executing the protocol, and RC describes
the admissible combinations of parameter values. Finally, N associates to a each
admisible combination, the number of copies of the automaton that are going to
run in parallel, or, equivalently, the number of processes explicitly modeled. In
a Byzantine setting, faulty processes behave arbitrarily, and so we do not model
them explicitly; in this case, the system consists of one copy of the automaton
for every correct process. In the crash fault model, processes behave correctly
until they crash, they must be modeled explicitly, and the system has a copy of
the automaton for each process, faulty or not.

2

s e n t ECHO b e f o r e

then send ECHO to a l l

i f myvali = 1
and not

1 v a r myvali ∈ {0, 1}
2 v a r accepti ∈ {false, true} ← false
3
4 w h i l e t r u e do (in one atomic step)
5
6
7
8
9
10
11
12
13
14
15
16
17 od

received ECHO from a t
t + 1 d i s t i n c t p r o c e s s e s
and not
s e n t ECHO b e f o r e

received ECHO from a t
n − t d i s t i n c t p r o c e s s e s

then send ECHO to a l l

then accepti ← true

i f

i f

l e a s t

l e a s t

Fig. 1. Pseudocode of a reliable broadcast
protocol from [27] for a correct process i,
where n and t denote the number of pro-
cesses, and an upper bound on the number
of faulty processes. The protocol satisﬁes its
speciﬁcation (if myval i = 1 for every cor-
rect process i, then eventually accept j =
true for some correct process j) if t < n/3.

sl1 : ⊤

ℓ0

ℓ1

r2:γ17→x++
r 1 : ⊤ 7→ x + +

sl2:⊤

sl3:⊤

r3 : γ2

ℓ3

ℓ2

Fig. 2. Threshold automaton modeling
the body of the loop in the protocol from
Fig. 1. Symbols γ1, γ2 stand for the thresh-
old guards x ≥ (t+1)−f and x ≥ (n−t)−
f , where n and t are as in Fig. 1, and f is
the actual number of faulty processes. The
shared variable x models the number of
ECHO messages sent by correct processes.
Processes with myval i = b (line 1) start
in location ℓb (in green). Rules r1 and r2
model sending ECHO at lines 7 and 12.
The self-loop rules sl1, . . . , sl3 are stutter-
ing steps.

Example 1. In the threshold automaton of Figure 2, the parameters are n, f ,
and t, describing the number of processes, the number of faulty processes, and
the maximum possible number of faulty processes, respectively. The resilience
condition is the set of triples (in, if , it) such that in/3 > it ≥ if ; abusing lan-
guage, we identify it with the constraint n/3 > t ≥ f . The function N is given
by N (n, t, f ) = n − f , which is the number of correct processes.

Threshold automata. A threshold automaton over an environment Env is a
tuple TA = (L, I, Γ, R), where L is a nonempty, ﬁnite set of local states (or
locations), I ⊆ L is a nonempty subset of initial locations, Γ is a set of global
variables ranging over N0, and R is a set of transition rules (or just rules),
formally described below.

A transition rule (or just a rule) is a tuple r = (from, to, ϕ, u), where from
and to are the source and target locations, ϕ : Π ∪ Γ → {true, false} is a con-
junction of threshold guards, and u : Γ → {0, 1} is an update. We often let
r.from, r.to, r.ϕ, r.u denote the components of r. Intuitively, r states that a pro-
cess can move from from to to if the current values of Π and Γ satisfy ϕ, and
when it moves it updates the current valuation g of Γ by performing the up-

3

date g := g + u. Since all components of u are nonnegative, the values of global
variables never decrease. A threshold guard ϕ has one of the following two forms:

– x ≥ a0 + a1 · p1 + . . . + a|Π| · p|Π|, called a rise guard, or
– x < a0 + a1 · p1 + . . . + a|Π| · p|Π|, called a fall guard,

where x ∈ Γ is a shared variable, p1, . . . , p|Π| ∈ Π are the parameters, and
a0, a1, . . . , a|Π| ∈ Q are rational coeﬃcients. Since global variables are initialized
to 0, and they never decrease, once a rise (fall) guard becomes true (false) it
stays true (false). We call this property monotonicity of guards. We let Φrise,
Φfall, and Φ denote the sets of rise guards, fall guards, and all guards of TA.

Example 2. The rule r2 of Figure 2 has ℓ0 and ℓ2 as source and target locations,
x ≥ (t + 1) − f as guard, and the number 1 as update (there is only one shared
variable, which is increased by one).

Conﬁgurations and transition relation. A conﬁguration of TA is a triple
σ = (κ, g, p) where κ : L → N0 describes the number of processes at each
location, and g ∈ N|Γ |
and p ∈ RC are valuations of the global variables and
ℓ∈L κ(ℓ) = N (p) always holds. A conﬁguration
the parameters. In particular,
is initial if κ(ℓ) = 0 for every ℓ /∈ I, and g = 0. We often let σ.κ, σ.g, σ.p denote
the components of σ.

P

0

A conﬁguration σ = (κ, g, p) enables a rule r = (from, to, ϕ, u) if κ(from) >
0, and (g, p) satisﬁes the guard ϕ, i.e., substituting g(x) for x and p(pi) for pi in
ϕ yields a true expression, denoted by σ |= ϕ. If σ enables r, then TA can move
from σ to the conﬁguration r(σ) = (κ′, g′, p′) deﬁned as follows: (i) p′ = p, (ii)
g′ = g + u, and (iii) κ = κ + vr, where vr(from) = −1, vr(to) = +1, and vr = 0
otherwise. We let σ → r(σ) denote that TA can move from σ to r(σ).

Schedules and paths. A schedule is a (ﬁnite or inﬁnite) sequence of rules. A
schedule τ = r1, . . . , rm is applicable to conﬁguration σ0 if there is a sequence of
conﬁgurations σ1, . . . , σm such that σi = ri(σi−1) for 1 ≤ i ≤ m, and we deﬁne
τ (σ0) := σm. We let σ ∗−→ σ′ denote that τ (σ) = σ′ for some schedule τ , and say
that σ′ is reachable from σ. Further we let τ · τ ′ denote the concatenation of two
schedules τ and τ ′, and, given µ ≥ 0, let µ · τ the concatenation of τ with itself
µ times.

A path or run is a ﬁnite or inﬁnite sequence σ0, r1, σ1, . . . , σk−1, rk, σk, . . . of
alternating conﬁgurations and rules such that σi = ri(σi−1) for every ri in the
sequence. If τ = r1, . . . , r|τ | is applicable to σ0, then we let path(σ0, τ ) denote
the path σ0, r1, σ1, . . . , r|τ |, σ|τ | with σi = ri(σi−1), for 1 ≤ i ≤ |τ |. Similarly, if
τ is an inﬁnite schedule. Given a path path(σ, τ ), the set of all conﬁgurations in
the path is denoted by Cfgs(σ, τ ).

3 Coverability and Parameterized Coverability

We say that conﬁguration σ covers location ℓ if σ.κ(ℓ) > 0. We consider the
following two coverability questions in threshold automata:

4

Deﬁnition 1 ((Parameterized) coverability). The coverability problem con-
sists of deciding, given a threshold automaton TA, a location ℓ and an initial
conﬁguration σ0, if some conﬁguration reachable from σ0 covers ℓ. The param-
eterized coverability problem consists of deciding, given TA and ℓ, if there is an
initial conﬁguration σ0 and a conﬁguration reachable from σ0 that covers ℓ.

Sometimes we also speak of the non-parameterized coverability problem, in-
stead of the coverability problem, to avoid confusion. We show that both prob-
lems are NP-hard, even when the underlying threshold automaton is acyclic. In
the next section, we show that the reachability and parameterized reachability
problems (which subsume the corrersponding coverability problems) are both in
NP.

Theorem 1. Parameterized coverability in threshold automata is NP-hard, even
for acyclic threshold automata with only constant guards (i.e., guards of the form
x ≥ a0 and x < a0).

Proof. (Sketch.) We prove NP-hardness of parameterized coverability by a re-
duction from 3-SAT. The reduction is as follows: (See Figure 3 for an illustrative
example). Let ϕ be a 3-CNF formula with variables x1, . . . , xn. For every vari-
able xi we will have two shared variables yi and ¯yi. For every clause Cj, we
will have a shared variable cj. Intuitively, each process begins at some state
ℓi and then moves to either ⊤i or ⊥i by ﬁring either (ℓi, ⊤i, ¯yi < 1, yi++) or
(ℓi, ⊥i, yi < 1, ¯yi++) respectively. Moving to ⊤i (⊥i resp.) means that the pro-
cess has guessed the value of the variable xi to be true (false resp). Once it has
chosen a truth value, it then increments the variables corresponding to all the
clauses which it satisﬁes and moves to a location ℓmid. If it happens that all the
guesses were correct, a ﬁnal rule gets unlocked and processes can move from ℓmid
to ℓF . The key property we need to show is that if some process moves to ⊤i then
no other process can move to ⊥i (and vice versa). This is indeed the case because
if a process moves to ⊤i from ℓi, it would have ﬁred the rule (ℓi, ⊤i, ¯yi < 1, yi++)
which increments the shared variable yi, and so falsiﬁes the guard of the corre-
sponding rule (ℓi, ⊥i, yi < 1, ¯yi++), and therefore no process can ﬁre it. Similarly,
if (ℓi, ⊥i, yi < 1, ¯yi++) is ﬁred, no process can ﬁre (ℓi, ⊤i, ¯yi < 1, yi++).

A modiﬁcation of the same construction proves

Theorem 2. The coverability problem is NP-hard even for acyclic threshold au-
tomata with only constant rise guards (i.e., guards of the form x ≥ a0).

Constant rise guards. Theorem 2 puts strong constraints to the class of TAs
for which parameterized coverability can be polynomial, assuming P 6= NP. We
identify an interesting polynomial case.

Deﬁnition 2. An environment Env = (Π, RC , N ) is multiplicative for a TA
if for every µ ∈ N>0 (i) for every valuation p ∈ RC we have µ · p ∈ RC and
N (µ · p) = µ · N (p), and (ii) for every guard ϕ := x 2 a0 + a1p1 + a2p2 + . . . akpk
in TA (where 2 ∈ {≥, <}), if (y, q1, q2, . . . , qk) is a (rational) solution to ϕ then
(µ · y, µ · q1, . . . , µ · qk) is also a solution to ϕ.

5

ℓ1

ℓ2

ℓ3

¯y 1 < 1 7→ y 1++

y1 < 1 7→ ¯y1++
¯y 2 < 1 7→ y 2++

y2 < 1 7→ ¯y3++
¯y 3 < 1 7→ y 3++

y3 < 1 7→ ¯y3++

⊤1

⊥1

⊤2

⊥2

⊤3

⊥3

c1++

c2++
c 1 ++ ∧ c 2 ++
c 1 + +

+

+

2

c

ℓmid

c1 ≥ 1 ∧ c2 ≥ 1

ℓF

Fig. 3. Threshold automaton TAϕ corresponding to the formula ϕ = (x1 ∨ ¬x2 ∨ x3) ∧
(¬x1 ∨ ¬x2 ∨ ¬x3). Note that setting x1 to true and x2 and x3 to false satisﬁes ϕ.
Let σ0 be the initial conﬁguration obtained by having 1 process in each initial location
ℓi, 1 ≤ i ≤ 3, and 0 in every other location. From ℓ1 we increment y1 and from ℓ2 and
ℓ3 we increment ¯y2 and ¯y3 respectively, thereby making the processes go to ⊤1, ⊥2, ⊥3
respectively. From there we can move all the processes to ℓmid, at which point the last
transition gets unlocked and we can cover ℓF .

Multiplicativity is a very mild condition. To the best of our knowledge, all al-
gorithms discussed in the literature, and all benchmarks of [19], have multiplica-
tive environments. For example, in Figure 2, if the resilience condition t < n/3
holds for a pair (n, t), then it also holds for (µ · n, µ · t); similarly, the function
N (n, t, f ) = n − f also satisﬁes N (µ · n, µ · t, µ · f ) = µ · n − µ · f = µ · N (n, t, f ).
Moreover, if x ≥ t + 1 − f holds in σ, then we also have µ · x ≥ µ · t + 1 − µ · f
in µ · σ. Similarly for the other guard x ≥ n − t − f .

This property allows us to reason about multiplied paths in large systems.
Namely, condition (ii) from Deﬁnition 2 yields that if a rule is enabled in σ, it
is also enabled in µ · σ. This plays a crucial role in Section 5 where we need
the fact that a counterexample in a small system implies a counterexample in a
large system.

Theorem 3. Parameterized coverability of threshold automata over multiplica-
tive environments with only constant rise guards is P-complete.

Proof. (Sketch.) P-hardness is proved by giving a logspace-reduction from the
Circuit Value problem ([21]) which is well known to be P-hard. In the following,
we sketch the proof of inclusion in P.

Let TA = (L, I, Γ, R) be a threshold automaton over a multiplicative envi-
ronment Env = (Π, RC , N ) such that the guard of each transition in R is a
L of locations that can be reached by
constant rise guard. We construct the set
at least one process, and the set of transitions
R that can occur, from at least
one initial conﬁguration. We initialize two variables XL and XR by XL := I and
XR := ∅, and repeatedly update them until a ﬁxed point is reached, as follows:
– If there exists a rule r = (ℓ, ℓ′, true, u) ∈ R \ XR such that ℓ ∈ XL, then set

b

b

XL := XL ∪ {ℓ′} and XR := XR ∪ {r}.

6

– If there exists a rule r = (ℓ, ℓ′, (∧1≤i≤q xi ≥ ci), u) ∈ R \ XR such that ℓ ∈
i, ϕi, ui) ∈

XL, and there exists rules r1, r2, . . . , rq such that each ri = (ℓi, ℓ′
XR and ui[xi] > 0, then set XL := XL ∪ {ℓ′} and XR := XR ∪ {r}.

We prove in the Appendix that after termination XL =

L holds. Intuitively,
multiplicativity ensures that if a reachable conﬁguration enables a rule, there are
reachable conﬁgurations from which the rule can occur arbitrarily many times.
This shows that any path of rules constructed by the algorithm is executable.

b

4 Reachability

We now consider reachability problems for threshold automata. Formally, we
consider the following two versions of the reachability problem:

Deﬁnition 3 ((Parameterized) reachability). The reachability problem con-
sists of deciding, given a threshold automaton TA, two sets L=0, L>0 of locations,
and an initial conﬁguration σ0, if some conﬁguration σ reachable from σ0 sat-
isﬁes σ.κ(ℓ) = 0 for every ℓ ∈ L=0 and σ.κ(ℓ) > 0 for every ℓ ∈ L>0. The pa-
rameterized reachability problem consists of deciding, given TA and L=0, L>0, if
there is an initial conﬁguration σ0 such that some σ reachable from σ0 satisﬁes
σ.κ(ℓ) = 0 for every ℓ ∈ L=0 and σ.κ(ℓ) > 0 for every ℓ ∈ L>0.

Notice that the reachability problem clearly subsumes the coverability prob-
lem and hence, in the sequel, we will only be concerned with proving that both
problems are in NP. This will be a consequence of our main result, showing
that the reachability relation of threshold automata can be characterized as an
existential formula of Presburger arithmetic. This result has several other con-
sequences. In Section 5 we use it to give a new model checking algorithm for the
fault-tolerant logic of [19]. In Section 7 we report on an implementation whose
runtime compares favorably with previous tools.

Reachability relation as an existential Presburger formula. Fix a thresh-
old automaton TA = (L, I, Γ, R) over an environment Env . We construct an
existential Presburger arithmetic formula φreach with (2|L| + 2|Γ | + 2|Π|) free
variables such that φreach (σ, σ′) is true iff σ′ is reachable from σ.

Let the context of a conﬁguration σ, denoted by ω(σ), be the set of all rise
guards that evaluate to true and all fall guards that evaluate to false in σ. Given
a schedule τ , we say that the path path(σ, τ ) is steady if all the conﬁgurations
it visits have the same context. By the monotonicity of the guards of threshold
automata, path(σ, τ ) is steady iff its endpoints have the same context, i.e., iff
ω(σ) = ω(τ (σ)). We have the following proposition:

Proposition 1. Every path of a threshold automaton with k guards is the con-
catenation of at most k+1 steady paths.

Using this proposition, we ﬁrst construct a formula φsteady such that φsteady (σ, σ′)
holds iff there is a steady path path(σ, τ ) such that τ (σ) = σ′.

7

The formula φsteady . For every rule r ∈ R, let xr be a variable ranging over
non-negative integers. Intuitively, the value of xr will represent the number of
times r is ﬁred during the (supposed) path from σ to σ′. Let X = {xr}r∈R. We
construct φsteady step by step, specifying necessary conditions for σ, σ′ and X
to satisfy the existence of the steady path, which in particular implies that σ′ is
reachable from σ.

Step 1. σ and σ′ must have the same values of the parameters, which must satisfy
the resilience condition, the same number of processes, and the same context:

φbase (σ, σ′) ≡ σ.p = σ′.p ∧ RC (σ.p) ∧ N (σ.p) = N (σ′.p) ∧ ω(σ) = ω(σ′).

1, . . . , inℓ
bℓ

Step 2. For a location ℓ ∈ L, let outℓ
aℓ be all outgoing rules from ℓ and
let inℓ
be all incoming rules to ℓ. The number of processes in ℓ after the
execution of the path is the initial number, plus the incoming processes, minus
the outgoing processes. Since xr models the number of times the rule r is ﬁred,
we have

1, . . . , outℓ

φL(σ, σ′, X) ≡

aℓ

bℓ

ℓ∈L
^





i=1
X

xinℓ

i

−

xoutℓ

j

j=1
X

= σ′.κ(ℓ) − σ.κ(ℓ)





Step 3. Similarly, for the shared variables we must have:

φΓ (σ, σ′, X) ≡

z∈Γ  
^

r∈R
X

(xr · r.u[z]) = σ′.g[z] − σ.g[z]

!

Step 4. Since path(σ, τ ) must be steady, if a rule is ﬁred along path(σ, τ ) then
its guard must be true in σ and so

φR(σ, X) ≡

xr > 0 ⇒ (σ |= r.ϕ)

r∈R
^

Step 5. Finally, for every rule r that occurs in path(σ, τ ), the path must contain
a “ﬁreable” chain leading to r, i.e., a set of rules S = {r1, . . . , rs} ⊆ R such that
all rules of S are executed in path(σ, τ ), there is a process in σ at r1.from, and
the rules r1, . . . , rs form a chain leading from r1.from to r.from. We capture this
by the constraint

φappl(σ, X) ≡

xr > 0 ⇒

r∈R
^





S={r1,r2,...,rs}⊆R
_

φr
chain (S, σ, X)





where

φr
chain (S, σ, X) ≡

xr > 0 ∧ σ.κ(r1.from) > 0 ∧

ri−1.to = ri.from ∧ rs = r

r∈S
^

^1<i≤s

8

Combining the steps. Deﬁne φsteady (σ, σ′) as follows:

φsteady (σ, σ′) ≡ φbase (σ, σ′) ∧

∃X ≥ 0. φL(σ, σ′, X) ∧ φΓ (σ, σ′, X) ∧ φR(σ, X) ∧ φappl(σ, X) .

where ∃X ≥ 0 abbreviates ∃xr1 ≥ 0, . . . , ∃xr|R| ≥ 0. By our discussion, it is
clear that if there is a steady path leading from σ to σ′, then φsteady (σ, σ′) is
satisﬁable. The following theorem proves the converse.

Theorem 4. Let TA be a threshold automaton and let σ, σ′ ∈ Σ be two con-
ﬁgurations. Formula φsteady (σ, σ′) is satisﬁable if and only if there is a steady
schedule τ with τ (σ) = σ′.

Observe that, while φsteady has exponential length in TA when constructed
na¨ıvely (because of the exponentially many disjunctions in φappl), its satisﬁability
is in NP. Indeed, we ﬁrst non-deterministically guess one of the disjunctions for
each conjunction of φappl and then check in nondeterministic polynomial time
that the (polynomial sized) formula with only these disjuncts is satisﬁable. This
is possible because existential Presburger arithmetic is known to be in NP [14].

The formula φreach . By Proposition 1, every path from σ to σ′ in a threshold
automaton with a set Φ of guards can be written in the form

σ = σ0

∗−→ σ′

0 → σ1

∗−→ σ′

1 → σ2 . . . σK

∗−→ σ′

K = σ′

∗−→ σ′

i is a steady path for each 0 ≤ i ≤ K. It is easy
where K = |Φ| + 1, and σi
to see from the deﬁnition of the transition relation between conﬁgurations that
we can construct a polynomial sized existential Presburger formula φstep such
that φstep(σ, σ′) is true iﬀ σ′ can be reached from σ by ﬁring at most one rule.
Thus, we deﬁne φreach (σ, σ′) to be

∃σ0, σ′

0, . . . , σK, σ′

σ0 = σ ∧ σ′

K = σ′ ∧

K 

φsteady (σi, σ′

i) ∧

^0≤i≤K

^0≤i≤K−1

φstep(σ′

i, σi+1)







Theorem 5. Given a threshold automaton TA, there is an existential Presburger
formula φreach such that φreach (σ, σ′) holds iff σ ∗−→ σ′.

As deciding the truth of existential Presburger formulas is in NP, we obtain:

Corollary 1. The reachability and parameterized reachability problems are in NP.

Remark 1. In [15] an algorithm was given for parameterized reachability of
threshold automata in which the updates of all rules contained in loops are
equal to 0. Our algorithm does not need this restriction.

9

5 Safety and Liveness

We recall the deﬁnition of Fault-Tolerant Temporal Logic (ELTLFT), the fragment
of LTL used in [19] to specify and verify properties of a large number of fault-
tolerant algorithms. ELTLFT has the following syntax, where S ⊆ L is a set of
locations and guard ∈ Φ is a guard:

ψ ::= pf | G ψ | F ψ | ψ ∧ ψ
pf ::= cf | gf ⇒ cf

cf ::= S = 0 | ¬(S = 0) | cf ∧ cf
gf ::= guard | gf ∧ gf | gf ∨ gf

An inﬁnite path path(σ, τ ) starting at σ = (κ, g, p), satisﬁes S = 0 if κ(ℓ) = 0 for
every ℓ ∈ S, and guard if (g, p) satisﬁes guard . The rest of the semantics is stan-
dard. The negations of speciﬁcations of the benchmarks [5,27,3,23,24,13,7,4,26]
can be expressed in ELTLFT, as we are interested in ﬁnding possible violations.

Example 3. One speciﬁcation of the algorithm from Figure 1 is that if myval i = 1
for every correct process i, then eventually accept j = true for some correct
process j. In the words of the automaton from Figure 2, a violation of this
property would mean that initially all correct processes are in location ℓ1, but
no correct process ever reaches location ℓ3. In ELTLFT we write this as

{ℓ0, ℓ2, ℓ3} = 0 ∧ G ({ℓ3} = 0) .

This has to hold under the fairness constraint

G F

(cid:18)

((x ≥ t + 1 ∨ x ≥ n − t) ⇒ {ℓ0} = 0) ∧ {ℓ1} = 0 ∧ (x ≥ n − t ⇒ {ℓ2} = 0)

.
(cid:19)
As we have self-loops at locations ℓ0 and ℓ2, a process could stay forever in one
of these two states, even if it has collected enough messages, i.e., if x ≥ t + 1
or x ≥ n − t. This is the behavior that we want to prevent with such a fairness
constraint. Enough sent messages should force each process to progress, so the
location eventually becomes empty. Similarly, as the rule leading from ℓ1 has a
trivial guard, we want to make sure that all processes starting in ℓ1 eventually
(send a message and) leave ℓ1 empty, as required by the algorithm.

In this section we study the following problem:

Deﬁnition 4 (Parameterized safety and liveness). Given a threshold au-
tomaton TA and a formula ϕ in ELTLFT, check whether there is an initial conﬁg-
uration σ0 and an inﬁnite schedule τ applicable to σ0 such that path(σ0, τ ) |= ϕ.

Since parameterized coverability is NP-hard, it follows that parameterized
safety and liveness is also NP-hard. We prove that for automata with multiplica-
tive environments (see Deﬁnition 2) parameterized safety and liveness is in NP.

Theorem 6. Parameterized safety and liveness of threshold automata with
multiplicative environments is in NP.

10

F b
F c

a

G F e

loopst

loopend

a

b

c

d

e

Fig. 4. The cut graph of a formula F (a ∧ F b ∧ F c ∧ G d ∧ G F e) (left) and one lasso
shape for a chosen topological ordering a ≤ F b ≤ F c ≤ loopst ≤ G F e ≤ loopend (right).

The proof, which can be found in the Appendix, is very technical, and we
only give a rough sketch here. The proof relies on two notions introduced in [19].
First, it is shown in [19] that every ELTLFT formula is equivalent to a formula in
normal form of shape φ0 ∧ F φ1 ∧ · · · ∧ F φk ∧ G φk+1, where φ0 is a propositional
formula and φ1, . . . , φk+1 are themselves in normal form. Further, formulas can
be put in normal form in polynomial time. The second notion introduced in [19]
is the cut graph Gr(ϕ) of a formula in normal form. For our sketch it suﬃces to
know that Gr(ϕ) is a directed acyclic graph with two special nodes loopst and
loopend , and every other node is a subformula of ϕ in normal form (see Figure 4).
For a formula ϕ ≡ φ0 ∧ F φ1 ∧ · · · ∧ F φk ∧ G φk+1, we will say that its local
proposition is φ0 and its global proposition is the local proposition of φk+1. It is
shown in [19] that, given ϕ = φ0 ∧F φ1 ∧· · ·∧F φk ∧G φk+1, some inﬁnite path sat-
isﬁes ϕ iff there exists a topological ordering v0, v1, . . . , vc = loopst, vc+1, . . . , vl =
loopend of the cut graph and a path σ0, τ0, σ1, . . . , σc, τc, . . . , σl−1, τl−1, σl such
that, roughly speaking, (among other technical conditions) every conﬁguration
σi satisﬁes the local proposition of vi and every conﬁguration in Cfgs(σi, τi)
satisﬁes the global proposition of every vj where j ≤ i.

Using multiplicativity and our main result that reachability is deﬁnable in
existential Presburger arithemtic, we show that for every proposition p, we can
construct an existential formula φp(σ, σ′) such that: If there is a path between σ
and σ′, all of whose conﬁgurations satisfy p, then φp(σ, σ′) is satisﬁable. Further,
if φp(σ, σ′) is satisﬁable, then there is a path between 2 · σ and 2 · σ′ all of whose
conﬁgurations satisfy p. (Here 2 · σ = ((2 · σ.κ), (2 · σ.g), (2 · σ.p))). Then, once
we have ﬁxed a topological ordering V = v0, . . . , vl, (among other conditions),
we check if there are conﬁgurations σ0, . . . , σl such that for every i, σi satisﬁes
the local proposition of vi and for every j ≤ i, φpj (σi, σi+1) is satisﬁable where
pj is the global proposition of vj. Using multiplicativity, we then show that this
procedure is suﬃcient to check if the given speciﬁcation ϕ is satisﬁed.

Our algorithm consists therefore of the following steps: (1) bring ϕ in nor-
mal form; (2) construct the cut graph Gr(ϕ); (3) guess a topological ordering
of the nodes of Gr(ϕ); (4) for the guessed ordering, check in nondeterministic
polynomial time if the required sequence σ0, . . . , σl exists.

Remark 2. From an algorithm given in [19] one can infer that parameterized
safety and liveness is in NP for threshold automata with multiplicative environ-
ments, where all cycles are simple, and rules in cycles have update 0. (The NP
bound was not explicitly given in [19].) Our algorithm only requires multiplica-
tivity.

11

6 Synthesis of Threshold Guards

We study the bounded synthesis problem for constructing parameterized thresh-
old guards in threshold automata satisfying a given speciﬁcation.

Sketch threshold automata. Let an indeterminate be a variable that can take
values over rational numbers. We consider threshold automata whose guards
can contain indeterminates. More precisely, a sketch threshold automaton is a
tuple TA = (L, I, Γ, R), just as before, except for the following change. Recall
that in a threshold automaton, a guard is an inequality of one of the following
two forms:

x ≥ a0 + a1 · p1 + . . . + a|Π| · p|Π| or x < a0 + a1 · p1 + . . . + a|Π| · p|Π|

where a0, a1, . . . , a|Π| are rational numbers. In a sketch threshold automaton,
some of the a0, a1, . . . , a|Π| can be indeterminates. Moreover, indeterminates
can be shared between two or more guards.

Given a sketch threshold automaton TA and an assignment µ to the indeter-
minates, we let TA[µ] denote the threshold automaton obtained by substituting
the indeterminates by their values in µ. We deﬁne the bounded synthesis problem:

Given: An environment Env, a sketch threshold automaton TA with
indeterminates v1, . . . , vm, a formula ϕ of ELTLFT, and a polynomial p.
Decide: Is there an assignment µ to v1, . . . , vm of size O(p(|TA| + |ϕ|))
(i.e., the vector (µ(v1), . . . , µ(vm)) of rational numbers can be encoded
in binary using O(p(|TA| + |ϕ|)) bits) such that TA[µ] satisﬁes ¬ϕ (i.e.,
such that for every initial conﬁguration σ0 in TA[µ], every inﬁnite run
starting from σ0 satisﬁes ¬ϕ)?

We say that an assignment µ to the indeterminates makes the environment
multiplicative if the conditions of Deﬁnition 2 are satisﬁed after plugging in the
assignment µ in the automaton. In the following, we will only be concerned with
assignments which make the environment multiplicative.

Since we can guess an assignment in polynomial time, by Theorem 6 it follows

Theorem 7. Bounded synthesis is in Σp
2 .

By a reduction from the Σ2-SAT problem, we also provide a matching lower bound.

Theorem 8. Bounded synthesis is Σp

2 -complete.

The synthesis problem is deﬁned as the bounded synthesis problem, but
lifting the constraint on the size of µ. While we do not know the exact complexity
of the synthesis problem, we can show that, for a large and practically motivated
class of threshold automata introduced in [22], the synthesis problem reduces to
the bounded synthesis problem. We proceed to describe and motivate the class.

12

The parameter variables of fault-tolerant distributed algorithms usually con-
sist of a variable n denoting the number of processes running the algorithm
and various “failure” variables for the number of processes exhibiting diﬀerent
kinds of failures (for example, a variable t1 might be used to specify the number
of Byzantine failures, a variable t2 for crash failures, etc.). The following three
observations are made in [22]:

(1) The resilience condition of these algorithms is usually of the form n >
k
i=1 δiti where ti are parameter variables and δi are natural numbers.
(2) Threshold guards typically serve one of two purposes: to check if at least
P
a certain fraction of the processes sends a message (for example, x > n/2
ensures that a strict majority of processes has sent a message), or to bound
the number of processes that crash.

(3) The coeﬃcients of the guards are rational numbers with small denominators

(typically at most 3).

By (2), the structure of the algorithm guarantees that the value of a variable
x never goes beyond n, the number of processes. Therefore, given a threshold
guard template x ⊲⊳ u · π + v, where u is a vector of indeterminates, π is a vector
of parameter variables, v is an indeterminate, and ⊲⊳ is either ≥ or <, we are only
interested in assignments µ of u and v which satisfy 0 ≤ µ(u)·ν(π)+µ(v) ≤ n for
every valuation ν(π) of π respecting the resilience condition. Guards obtained by
instantiating guard templates with such a valuation µ are called sane guards [22].
The following result is proved in [22]: Given a resilience condition n >
k
i=1 δiti, and an upper bound D on the denominator of the entries of µ (see
(1) and (3) above), the numerators of the entries of µ are necessarily of polyno-
P
mial size in k, δ1, . . . , δk. Therefore, the synthesis problem for sane guards and
bounded denominator, as introduced in [22], reduces to the bounded synthesis
problem, and so it can be solved in Σp
2 time. Moreover, the reduction used in
Theorem 8 to prove Σp
2 -hardness yields sketch threshold automata with sane
guards, and so the the synthesis problem for sane guards and bounded denomi-
nator is also Σp

2 -complete.

7 Experimental Evaluation

Following the techniques presented in this paper, we have veriﬁed a number of
threshold-based fault-tolerant distributed algorithms.

Benchmarks. Consistent broadcast (strb) [27] is given in Figure 1 and its thresh-
old automaton is depicted in Figure 2. The algorithm is correct if in any execution
either all correct processes or none set accept to true; moreover, if all correct
processes start with value 0 then none of them accept, and if all correct processes
start with value 1 then they all accept. The algorithm is designed to tolerate
Byzantine failures of less than one third of processes, that is, if n > 3t. Folklore
Reliable Broadcast (frb) [5] that tolerates crash faults and Asynchronous Byzan-
tine agreement (aba) [3] satisfy the same speciﬁcations as consistent broadcast,
under the same resilience condition.

13

Input

Case

Threshold
automaton

nbacg

nbacr

aba

aba

cbc

cbc

cbc

cbc

cf1s

cf1s

cf1s

cf1s

c1cs

c1cs

c1cs

c1cs

bosco

bosco

bosco

bosco

(if more than one)

Case 1

Case 2

Case 1

Case 2

Case 3

Case 4

Case 1

Case 2

Case 3

hand-coded TA

Case 1

Case 2

Case 3

hand-coded TA

Case 1

Case 2

Case 3

hand-coded TA

|L|

24

77

37

61

164

73

304

161

41

41

68

9

101

70

101

9

28

40

32

8

|R|

64

1031

202

425

2064

470

6928

2105

280

280

696

26

1285

650

1333

30

152

242

188

20

Time, seconds

Our tool

ByMC

11.84

490.79

251.71

2856.63

MLE

2521.12

MLE

MLE

50.5

55.88

266.56

7.17

1428.51

1709.4

TLE

37.72

58.11

157.61

59

20.95

10.29

1081.07

751.89

TLE

MLE

36.57

MLE

MLE

55.87

281.69

7939.07

2737.53

TLE

11169.24

MLE

TLE

89.64

942.87

104.03

510.32

Table 1. The experiments were run on a machine with Intel® CoreTM i5-7200U CPU
with 7.7 GiB memory. The time limit was set to be 5 hours and the memory limit was
set to be 7 GiB. TLE (MLE) means that the time limit (memory limit) exceeded for
the particular benchmark.

Non-blocking atomic commit (nbacr) [24] and (nbacg) [13] deal with faults
using failure detectors. We model this by introducing a special location such that
a process is in it if and only if it suspects that there is a failure of the system.

Condition-based consensus (cbc) [23] reaches consensus under the condition
that the diﬀerence between the numbers of processes initialized with 0 and 1
diﬀer by at least t, an upper bound on the number of faults. We also check
algorithms that allow consesus to be achieved in one communication step, such
as cfcs [7], c1cs [4], as well as Byzantine One Step Consensus bosco [26].

Evaluation. Table 1 summarizes our results and compares them with the results
obtained using the ByMC tool [18]. Due to lack of space, we have omitted those
experiments for which both ByMC and our tool took less than 10 seconds.

14

We implemented our algorithms in Python and used Z3 as a back-end SMT
solver for solving the constraints over existential Presburger arithmetic. Our
implementation takes as input a threshold automaton and a speciﬁcation in
ELTLFT and checks if a counterexample exists. We apply to the latest version of
the benchmarks of [18]. Each benchmark yields two threshold automata, a hand-
coded one and one obtained by a data abstraction of the algorithm written in
Parametric Promela. For automata of the latter kind, due to data abstraction, we
have to consider diﬀerent cases for the same algorithm. We test each automaton
against all speciﬁcations for that automaton.

Our tool outperforms ByMC in all automata with more than 30 states, with
the exception of the second case of cbc. It performs worse in most small cases,
however in these cases, both ByMC and our tool take less than 10 seconds.
ByMC works by enumerating all so-called schemas of a threhold automaton,
and solving a SMT problem for each of them; the number of schemas can grow
exponentially in the number of guards. Our tool avoids the enumeration. Since
the number of schemas for the second case of cbc is just 2, while the second case
of aba and third case of cf1s have more than 3000, avoiding the enumeration
seems to be key to our better performance.

8 Conclusions

In this paper we have addressed the complexity of the most important veriﬁca-
tion and synthesis problems for threshold automata. In particular, we have shown
that the coverability and reachability problems, as well as the model checking
problem for the fault-tolerant temporal logic ELTLFT are all NP-complete, and
that the bounded synthesis problem is Σp
2 -complete. These results are a con-
sequence of a novel characterization of the reachability relation of threshold
automata as an existential formula of Presburger arithmetic.

References

1. Roderick Bloem, Swen Jacobs, Ayrat Khalimov, Igor Konnov, Sasha Rubin, Hel-
mut Veith, and Josef Widder. Decidability of Parameterized Veriﬁcation. Synthesis
Lectures on Distributed Computing Theory. Morgan & Claypool Publishers, 2015.
2. Michael Blondin, Christoph Haase, and Filip Mazowiecki. Aﬃne extensions of
integer vector addition systems with states. In CONCUR, volume 118 of LIPIcs,
pages 14:1–14:17. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 2018.
3. Gabriel Bracha and Sam Toueg. Asynchronous consensus and broadcast protocols.

J. ACM, 32(4):824–840, 1985.

4. Francisco Vilar Brasileiro, Fab´ıola Greve, Achour Most´efaoui, and Michel Raynal.
In PaCT, volume 2127 of LNCS, pages

Consensus in one communication step.
42–50, 2001.

5. Tushar Deepak Chandra and Sam Toueg. Unreliable failure detectors for reliable

distributed systems. J. ACM, 43(2):225–267, 1996.

6. Giorgio Delzanno, Arnaud Sangnier, Riccardo Traverso, and Gianluigi Zavattaro.
On the complexity of parameterized reachability in reconﬁgurable broadcast net-
works. In FSTTCS 2012, pages 289–300, 2012.

15

7. Dan Dobre and Neeraj Suri. One-step consensus with zero-degradation. In DSN,

pages 137–146, 2006.

8. Catherine Dufourd, Alain Finkel, and Philippe Schnoebelen. Reset nets between
decidability and undecidability. In ICALP, volume 1443 of Lecture Notes in Com-
puter Science, pages 103–115. Springer, 1998.

9. Javier Esparza. Decidability and complexity of petri net problems - An introduc-

tion. In Petri Nets, volume 1491 of LNCS, pages 374–428. Springer, 1996.

10. Javier Esparza, Alain Finkel, and Richard Mayr. On the veriﬁcation of broadcast

protocols. In LICS, pages 352–359. IEEE Computer Society, 1999.

11. Javier Esparza and Mogens Nielsen. Decidability issues for petri nets - A survey.

Bulletin of the EATCS, 52:244–262, 1994.

12. Steven M. German and A. Prasad Sistla. Reasoning about systems with many

processes. J. ACM, 39(3):675–735, 1992.

13. Rachid Guerraoui. Non-blocking atomic commit in asynchronous distributed sys-

tems with failure detectors. Distributed Computing, 15(1):17–25, 2002.

14. Christoph Haase. A survival guide to presburger arithmetic. ACM SIGLOG News,

5(3):67–82, 2018.

15. Igor Konnov, Marijana Lazic, Helmut Veith, and Josef Widder. Para2: parameter-
ized path reduction, acceleration, and SMT for reachability in threshold-guarded
distributed algorithms. Formal Methods in System Design, 51(2):270–307, 2017.

16. Igor Konnov, Helmut Veith, and Josef Widder. On the completeness of bounded
model checking for threshold-based distributed algorithms: Reachability. In CON-
CUR, volume 8704 of LNCS, pages 125–140, 2014.

17. Igor Konnov, Helmut Veith, and Josef Widder. On the completeness of bounded
model checking for threshold-based distributed algorithms: Reachability. Informa-
tion and Computation, 252:95–109, 2017.

18. Igor Konnov and Josef Widder. Bymc: Byzantine model checker. In ISoLA (3),

volume 11246 of LNCS, pages 327–342. Springer, 2018.

19. Igor V. Konnov, Marijana Lazic, Helmut Veith, and Josef Widder. A short coun-
terexample property for safety and liveness veriﬁcation of fault-tolerant distributed
algorithms. In POPL 2017, pages 719–734, 2017.

20. Jure Kukovec, Igor Konnov, and Josef Widder. Reachability in parameterized
systems: All ﬂavors of threshold automata. In CONCUR, pages 19:1–19:17, 2018.
21. Richard E. Ladner. The circuit value problem is log space complete for p. SIGACT

News, 7(1):1820, 1975.

22. Marijana Lazi´c, Igor Konnov, Josef Widder, and Roderick Bloem. Synthesis of dis-
tributed algorithms with parameterized threshold guards. In OPODIS, volume 95
of LIPIcs, pages 32:1–32:20, 2017.

23. Achour Most´efaoui, Eric Mourgaya, Philippe Raipin Parv´edy, and Michel Raynal.
Evaluating the condition-based approach to solve consensus. In DSN, pages 541–
550, 2003.

24. Michel Raynal. A case study of agreement problems in distributed systems: Non-

blocking atomic commitment. In HASE, pages 209–214, 1997.

25. Sylvain Schmitz and Philippe Schnoebelen. The power of well-structured systems.

CoRR, abs/1402.2908, 2014.

26. Yee Jiun Song and Robbert van Renesse. Bosco: One-step Byzantine asynchronous

consensus. In DISC, volume 5218 of LNCS, pages 438–450, 2008.

27. T.K. Srikanth and Sam Toueg. Simulating authenticated broadcasts to derive

simple fault-tolerant algorithms. Dist. Comp., 2:80–94, 1987.

16

APPENDIX

A Detailed proofs from Section 3

The intuition behind the proof of theorem 1 has been discussed in section 3.
Here we provide the formal proof of the theorem.

The reduction for theorem 1 is given by means of the following deﬁnition,

since the same construction will be used later on.

Deﬁnition 5. Given a 3-CNF formula ϕ = C1 ∧ C2 ∧ · · · ∧ Cm over variables
x1, . . . , xn, we deﬁne its threshold automaton TAϕ = (L, I, V, R) and the asso-
ciated environment Env ϕ as follows: (see an illustrative example in Figure 3)

– Env ϕ = (Π, RC , N ) where Π consists of a single parameter k, RC is simply

true and N (k) = k.

– The set of locations is L = {ℓ1, . . . , ℓn, ⊤1, . . . , ⊤n, ⊥1, . . . , ⊥n, ℓmid, ℓF }.
– The set of initial locations is I = {ℓ1, . . . , ℓn}.
– The variable set contains shared variables V = {y1, . . . , yn, ¯y1, . . . , ¯yn, c1, . . . , cm}.
– The set of rules R contains:

• For every 1 ≤ i ≤ n, we have (ℓi, ⊤i, ¯yi < 1, yi++) ∈ R and (ℓi, ⊥i, yi <

1, ¯yi++) ∈ R.

• For every 1 ≤ i ≤ n, we have (⊤i, ℓmid, true, cj1

++ ∧ . . . ∧ cjs

++) ∈ R

where Cj1 , . . . , Cjs are all the clauses that xi appears in.

• For every 1 ≤ i ≤ n, we have (⊥i, ℓmid, true, cj1

++ ∧ . . . ∧ cjs

++) ∈ R

where Cj1 , . . . , Cjs are all the clauses that ¬xi appears in.

• (ℓmid, ℓF , φ, 0) ∈ R, where φ = c1 ≥ 1 ∧ . . . ∧ cm ≥ 1.

Remark: Note that the constructed threshold automaton is acyclic and has
only constant guards, i.e., only guards of the form x ≥ a0 or x < a0 for some
a0 ∈ N0.

A simple consequence of the above deﬁnition is the following lemma. It states
that once some process moves to ⊤i (resp. ⊥i) no process can move to ⊥i (resp.
⊤i).

Lemma 1. Let ϕ be a 3-CNF formula over variables x1, . . . , xn, and let its
corresponding threshold automaton be TAϕ. If σ0 is an initial conﬁguration and
τ is a schedule applicable to σ0 then the following holds for every i ∈ {1, . . . , n}
: If there exists σ ∈ Cfgs(σ0, τ ) with σ.κ[⊤i] ≥ 1 (resp. σ.κ[⊥i] ≥ 1), then for
every σ′ ∈ Cfgs(σ0, τ ) it holds that σ′.κ[⊥i] = 0, (resp. σ′.κ[⊤i] = 0).

Proof. Let path(σ0, τ ) = σ0, t1, σ1, . . . , σ|τ |−1, t|τ |, σ|τ |. Let i ∈ {1, . . . , n} and
let σp be the ﬁrst conﬁguration in the path such that σp.κ[⊤i] ≥ 1. Hence
tp−1 = (ℓi, ⊤i, ¯yi < 1, yi++). This means that σp−1.g[ ¯yi] = 0 and so the rule
(ℓi, ⊥i, yi < 1, ¯yi++) could not have been ﬁred before σp−1. Since this rule was
never ﬁred before σp−1 it follows that σq.κ[⊥i] = 0 for all q ≤ p. Also, notice
that σp.g[yi] ≥ 1 and so the rule (ℓi, ⊥i, yi < 1, ¯yi++) cannot be ﬁred after σp.
Consequently we get that σq.κ[⊥i] = 0 for all q > p. The other claim is proven
in a similar manner as well.

17

A.1 Proof of Theorem 1

Proof. We reduce from 3-SAT. Let ϕ = C1 ∧ C2 ∧ · · · ∧ Cm be a 3-CNF formula
over variables x1, . . . , xn and consider the threshold automaton TAϕ and the
environment Env ϕ as described in Deﬁnition 5. We show that ϕ is satisﬁable if
and only if there is a path path(σ0, τ ) such that the conﬁguration τ (σ0) covers
ℓF .

(⇒) Suppose ϕ is satisﬁable and υ is a truth assignment that satisﬁes ϕ. We

deﬁne an initial conﬁguration σ0 and a schedule τ as follows.

The initial conﬁguration σ0 has one process in each of the initial locations

ℓ1, . . . , ℓn. As usual, all shared variables initially have value 0.

The schedule τ is deﬁned as follows. For each i ∈ {1, . . . , n}, if υ(xi) = true
we ﬁre the rule (ℓi, ⊤i, ¯yi < 1, yi++), and if υ(xi) = false then we ﬁre the rule
(ℓi, ⊥i, yi < 1, ¯yi++). As all these guards initially evaluate to true, these n rules
are applicable to σ0 (in any order), and lead to the (same) conﬁguration σ1 such
that σ1.κ[⊤i] ≥ 1 if and only if υ(xi) = true and σ1.κ[⊥i] ≥ 1 if and only if
υ(xi) = false, and all the other locations are empty. Note that by construction,
for each non-empty location from σ1, there is exactly one outgoing rule. There-
fore, the rest of the schedule is formed in the only possible way, that is, each
process moves to ℓmid and increments the corresponding shared variable(s) along
that rule.

Since each clause Cj evaluates to true under the assignment υ, every shared
variable cj is incremented at least once. Hence the guard of the rule leading to ℓF
becomes true, and so each process can move to ℓF , thereby covering ℓF .

(⇐) Suppose there is an initial conﬁguration σ0 and a schedule τ such that
τ (σ0) = σ and σ.κ[ℓF ] ≥ 1. We construct the truth assignment υ as follows: for
each i ∈ {1, . . . , n} we deﬁne υ(xi) = true if ⊤i was visited along the path, i.e.,
if there is σ′ ∈ Cfgs(σ0, τ ) with σ′.κ[⊤i] ≥ 1; similarly we deﬁne υ(xi) = false,
if there is σ′ ∈ Cfgs(σ0, τ ) with σ′.κ[⊥i] ≥ 1. If there is an i such that neither
⊤i nor ⊥i was visited by path(σ0, τ ), then we deﬁne υ(xi) = true. Lemma 1
implies that υ is a well-deﬁned truth assignment. By construction, it is easy to
see that υ satisﬁes ϕ.

A.2 Proof of Theorem 2

Proof. Once again we give a reduction from 3-SAT. Let ϕ be a 3-CNF for-
mula over variables x1, . . . , xn. We consider the threshold automaton TAϕ as
described in Deﬁnition 5 and remove all the guards and updates on any rule
that leaves any initial location. Formally, for every i ∈ {1, . . . , n}, we replace the
rule (ℓi, ⊤i, ¯yi < 1, yi++) with (ℓi, ⊤i, true, 0). Similarly, we replace (ℓi, ⊥i, yi <
1, ¯yi++) with (ℓi, ⊥i, true, 0). The rest of the rules in TAϕ are retained as they
are. We will denote this new threshold automaton by TA′

ϕ.

We deﬁne the initial conﬁguration σ0 such that there is exactly one process
in each initial state ℓi (as usual, all other locations are empty and all shared
variables have values 0).

18

(⇒) Suppose ϕ can be satisﬁed with assignment υ. Notice that in this case,

we already described a path from σ0 covering ℓF in the previous proof.

(⇐) Suppose ℓF can be covered from σ0. Let path(σ0, τ ) be a path along which
ℓF is covered. Deﬁne υ to be the following truth assignment for ϕ: υ(xi) = true
if the rule (ℓi, ⊤i, true, 0) was ﬁred in the schedule τ , υ(xi) = false if the rule
(ℓi, ⊥i, true, 0) was ﬁred in the schedule τ , and υ(xi) = true if neither of these
rules were ﬁred. Since the automaton is acyclic and there is only one process
at ℓi, both (ℓi, ⊤i, true, 0) and (ℓi, ⊥i, true, 0) cannot be ﬁred and so this is
a well-deﬁned assignment. It can then be easily veriﬁed that υ is a satisfying
assignment for ϕ.

A.3 Proof of Theorem 3

Proof. For proving P-hardness, we give a logspace reduction from the Circuit
Value Problem (CVP) which is known to be P-complete [21]. The reduction we
present is similar to the reduction given in Proposition 1 of

[6].

CVP is deﬁned as follows: Given a boolean circuit C with n input variables
and m gates, and a truth assignment υ for the input variables, check if υ evaluates
to 1 on the circuit C.

We represent each binary gate g as a tuple (◦, s1, s2), where ◦ ∈ {∧, ∨}
denotes the operation of g, and s1, s2 ∈ {x1, . . . , xn, g1, . . . , gm} are the inputs
to g. In a similar fashion, each unary gate g is represented as a tuple (¬, s). By
convention, g1 is always the output gate.

Based on this we present the following reduction: (See Figure 5 for an il-
lustrative example). Let C be a boolean circuit with input variables x1, . . . , xn
and gates g1, . . . , gm, and let υ be a truth assignment that for every xi, assigns
υ(xi) = bi ∈ {0, 1}. We deﬁne the threshold automaton TAC,v = (L, I, V, R)
and the environment Env C,v = (Π, RC , N ) as follows:

– Env C,v = (Π, RC , N ) where Π consists of a single parameter k, RC is simply

true and N (k) = k.

– The set of locations is L = {ℓ0, ℓ1, , . . . , ℓn, ℓg1 , ℓ′
– The set of initial locations is I = {ℓ0, ℓg1 , ℓg2, . . . , ℓgm},
n, g0
– The set of shared variables is V = {x0
– The set of rules R contains:
• a rule (ℓi−1, ℓi, true, xbi
i
• a rule (ℓ′
• rules (ℓg, ℓ′

++), for every 1 ≤ i ≤ n
1 ≥ 1, 0), where g1 is the output gate,

1 ≥ 1 ∧ sb2
(◦, s1, s2), and for every (b1, b2) ∈ {0, 1}2,

g1 , ℓF , g1
g, sb1

1, . . . , x0

n, x1

1, x1

g1, . . . , ℓgm, ℓ′

gm, ℓF },

1, g1

1, . . . , g0

m, g1

m}

2 ≥ 1, gb1◦b2 ++), for every binary gate g =

g, sb ≥ 1, g¬b++), for every unary gate g = (¬, s), and for every

• rules (ℓg, ℓ′
b ∈ {0, 1}.

It can be easily checked that if σ0 is an initial conﬁguration and τ is a schedule
such that τ (σ0) = σ then σ.g[xb
i ] ≥ 1 iﬀ b = bi and σ.g[gb] ≥ 1 iﬀ the gate g
outputs b when the input variables are given the assignment υ. Consequently,
the state ℓF can be covered if and only if the circuit evaluates to 1 on the given
assignment. Since the reduction can be clearly accomplished in logspace it follows
that the coverability problem for this case is P-hard.

19

x1
1++

x1
2++

x1
3++

ℓ1

ℓ2

ℓ3

∀b, b′ ∈ {0, 1}2, xb

1 ≥ 1 ∧ gb′

2 ≥ 1 7→ gb∧b′

1

∀b, b′ ∈ {0, 1}2, gb

3 ≥ 1 ∧ xb′

3 ≥ 1 7→ gb∨b′

2

∀b ∈ {0, 1}, xb

2 ≥ 1 7→ g¬b

3 ++

g1
1 ≥ 1

ℓF

++

++

ℓ′
g1

ℓ′
g2

ℓ′
g3

ℓ0

ℓg1

ℓg2

ℓg3

Fig. 5. Threshold automaton TAC,v corresponding to the circuit x1 ∧ (¬x2 ∨ x3) with
gates g1 = (∧, x1, g2), g2 = (∨, g3, x3), g3 = (¬, x2) and assignment υ(x1) = 1, υ(x2) =
1, υ(x3) = 1. (For brevity, we have denoted all the four transitions possible between ℓg1
and ℓ′
g1 with a single transition quantifying over all the four possible choices. Similar
notation is employed for the other transitions as well.) The assignment υ is a satisfying
assignment of the circuit C, and it is easy to see that if the initial conﬁguration has one
process in each of the initial locations ℓ0, ℓg1 , ℓg2 , ℓg3 , then there is (only) one possible
path from that conﬁguration, and it covers ℓF .

A polynomial time algorithm: Let TA = (L, I, V, R) be a threshold automaton
such that each transition in R only has constant rise guards (i.e., guards of the
form x ≥ a0 for some a0 ∈ N0). Let Env = (Π, RC , N ) be an environment
which is multiplicative (See deﬁnition 2). Clearly a guard of the form x ≥ 0 is
redundant and so we assume that if x ≥ c is a guard in some rule in TA, then
c > 0.

Given two conﬁgurations σ = (κ, g, p) and σ′ = (κ′, g′, p′) let σ + σ′ be the
conﬁguration (κ + κ′, g + g′, p + p′). Similarly given c ∈ N0 let c · σ be the
conﬁguration (c · κ, c · g, c · p). Since the automaton has only constant rise guards
it follows that

r is enabled at σ =⇒ r is enabled at σ + σ′ for any conﬁguration σ′

(1)

We prove that coverability in this case is in P by means of a saturation
algorithm which begins with the set of initial locations and ﬁnishes with the set
of all possible coverable locations. This algorithm is similar to the one mentioned
in [6].

We initialize two variables XL and XR by XL := I and XR := ∅, and

repeatedly update them until a ﬁxed point is reached, as follows:

– If there exists a rule r = (ℓ, ℓ′, true, u) ∈ R \ XR such that ℓ ∈ XL, then set

XL := XL ∪ {ℓ′} and XR := XR ∪ {r}.

– If there exists a rule r = (ℓ, ℓ′, (∧1≤i≤q xi ≥ ci), u) ∈ R \ XR such that ℓ ∈
i, ϕi, ui) ∈

XL, and there exists rules r1, r2, . . . , rq such that each ri = (ℓi, ℓ′
XR and ui[xi] > 0, then set XL := XL ∪ {ℓ′} and XR := XR ∪ {r}.

20

L, X 1

L, X 0

L , X m

By means of this algorithm we get a sequence of sets (X 0

R) ⊆
R ), one for each iteration. We say that a rule r ∈ R can possibly
∗
−→ σ and σ enables r.
L contains exactly the set of coverable locations and

· · · ⊆ (X m
occur if there is some initial conﬁguration σ0 such that σ0
We will now show that X m
X m

R contains exactly the set of rules which can possibly occur.

R) ⊆ (X 1

First we show by induction on i, that if ℓ ∈ X i

L then ℓ is coverable and
R then r can possibly occur. The claim is clearly true for the base
L = {ℓ′} and
R = {r}. Let c be the maximum constant appearing in any of the guards

if r ∈ X i
case of i = 0. Suppose the claim is true for some i. Let X i+1
X i+1
of any of the rules of TA.

R \X i

\ X i

L

By construction, there are two possible cases:

– r is of the form r = (ℓ, ℓ′, true, u) such that ℓ ∈ X i

L. By inductive hypothesis
ℓ is coverable. It is then clear that ℓ′ is coverable and also that r can possibly
occur.

– r is of the form r = (ℓ, ℓ′, (∧1≤j≤q xj ≥ cj), u) such that ℓ ∈ X i

L. We have

to show that

ℓ′ is coverable and r can possibly occur

(2)

j, ϕj, uj) ∈ X i

∗−→ σj such that σj enables rj .
0 + · · · + σq

By construction of the algorithm, for each j ∈ {1, . . . , q}, there exists rj =
(ℓj, ℓ′
R such that uj[xj] > 0. By inductive hypothesis, ℓ is
∗−→ σℓ such that σ.κ[ℓ] ≥ 1. Once again, by
coverable and so there exists σℓ
0
inductive hypothesis, for each j, the rule rj can possibly occur and so there
exists σj
0
Let σ0 = c · (σℓ
0) and let σmid = (c · (σℓ + σ1 + · · · + σq)). Since
the environment is multiplicative, σ0 is a valid initial conﬁguration. It is
∗−→ σmid.
then easy to see (by repeated applications of observation 1) that σ0
Notice that, by observation 1, r1, . . . , rq are all enabled at σmid and also
that σmid[ℓ1] ≥ c, . . . σmid[ℓq] ≥ c. By ﬁring each of r1, . . . , rq exactly c many
times, we can arrive at a conﬁguration σ where r is enabled. Now ﬁring r
from σ covers ℓ′. Hence ℓ′ is coverable and r can possibly occur thereby
proving (2).

0 + σ1

For the converse direction, suppose σ0 is an initial conﬁguration such that
∗
−→ σ and σ covers some location ℓ and enables some rule r. By an easy
σ0
induction on the length of the path between σ0 and σ we can establish that
ℓ ∈ X m

L and r ∈ X m
R .

B Detailed proofs from Section 4

In the following, when we say that φsteady (σ, σ′) holds with assignment {yr}r∈R
(where each yr is a natural number), we mean that the formula φ(σ, σ′) is true
when each variable xr is assigned the value yr. Given two assignments Y =
{yr}r∈R and Z = {zr}r∈R we say that Z < Y iﬀ
r∈R yr. Further
for an assignment Y = {yr}r∈R and a location ℓ we say that there is a ﬁreable

r∈R zr <

P

P

21

cycle at ℓ with respect to Y iﬀ there exists rules T = {t1, . . . , tm} such that
yt1 > 0, . . . , ytm > 0, ti.to = ti+1.from for all i < m, and tm.to = t1.from = ℓ.
The following two lemmas are important properties of the formula φsteady .

Lemma 2. Let φsteady (σ, σ′) be true with the assignment Y = {yr}r∈R. Suppose
yt > 0 and σ[t.from] > 0 for some rule t. If there are no ﬁreable cycles at t.from
with respect to Y , then φsteady (t(σ), σ′) is true with an assignment Z where
Z < Y .

Lemma 3. Let φsteady (σ, σ′) be true with the assignment Y = {yr}r∈R. Suppose
σ[ℓ] > 0 and suppose there is a ﬁreable cycle {t1, . . . , tm} at ℓ with respect to Y .
Then φsteady (t1(σ), σ′) is true with an assignment Z where Z < Y .

We will ﬁrst see how using these two lemmas, we can prove Theorem 4. Then

we will present the proofs of these two lemmas.

B.1 Proof of Theorem 4

Proof. It is clear from our discussion during the construction of the formula
φsteady that if there is a steady run from σ to σ′ then φsteady (σ, σ′) is true.
Hence, we will only show that this is a suﬃcient condition.

Let φsteady (σ, σ′) be true with the assignment {yr}r∈R. We induct on the

value of

r∈R yr.

P

Base Case. It can be easily veriﬁed that ∀r ∈ R. yr = 0 if and only if σ = σ′.
Hence, if all yr are zero, then σ = σ′ and so we are done. This constitutes the
base case of the induction.

Induction Hypothesis. Let us ﬁx values Y = {yr}r∈R, such that not all
of them are zero. We assume that if φsteady (c, c′) holds for some conﬁgurations c
and c′ with the assignment Z = {zr}r∈R such that Z < Y , then there is a steady
schedule τ such that τ (c) = c′.

Induction Step. Assume now that φsteady (σ, σ′) holds with the assignment
Y = {yr}r∈R. We show here that there exists a steady schedule τ such that
τ (σ) = σ′, using the following idea: (i) we construct a conﬁguration σ′′ that is
reachable from σ in one step, i.e., we show that there is a transition t such that
t(σ) = σ′′, and (ii) we prove that φsteady (σ′′, σ′) holds for an assignment {zr}r∈R
such that {zr}r∈R < {yr}r∈R. By applying our induction hypothesis, there is
a schedule ρ with ρ(σ′′) = σ′. We would then have τ = t · ρ as the required
schedule.

Let us construct σ′′. By the assumption, there is a rule r′ ∈ R such that
yr′ > 0. As φsteady (σ, σ′) holds with the assignment Y = {yr}r∈R, φappl(σ, Y ) is
true and therefore there must be a set of rules S = {r1, . . . , rs} ⊆ R such that
φr′
chain (S, σ, Y ) holds, that is,

σ.κ[r1.from] > 0 ∧

yri > 0 ∧

ri−1.to = ri.from ∧ rs = r′

^1≤i≤s

^1<i≤s

Let r = r1 and let ℓ = r.from. If there is no ﬁreable cycle at ℓ with respect to
Y , then by Lemma 2 we have that φsteady (r(σ), σ′) is true with an assignment

22

Z < Y and so we can deﬁne σ′′ = r(σ). Otherwise, if {t1, . . . , tm} is a ﬁreable
cycle at ℓ then by Lemma 3 we have that φsteady (t1(σ), σ′) is true with an
assignment Z < Y and so we can deﬁne σ′′ = t1(σ). Hence we can construct the
required σ′′ in either case and so the proof is complete.

Now we will prove the Lemmas 2 and 3.

B.2 Proof of Lemma 2

Proof. Let ℓ := t.from. Since yt > 0, from φR(σ, Y ) we obtain that σ |= t.ϕ. As
we have σ.κ[t.from] = σ.κ[ℓ] > 0 we know that t is enabled at σ. Hence we set
σ′′ = t(σ) and let Z = {zr}r∈R be the following assignment: zr = yr if r 6= t
and zr = yr − 1 if r = t. It can be easily checked that all of the following holds:
φbase (σ′′, σ′) ∧ φL(σ′′, σ′, Z) ∧ φΓ (σ′′, σ′, Z) ∧ φR(σ′′, Z). Therefore, we only need
to prove that φappl(σ′′, Z) holds.

Fix any arbitrary rule r ∈ R such that zr > 0. We now have to show that

there exists a set of rules S′ = {r′

1, . . . , r′

s′ } ⊆ R such that

σ′′.κ[r′

1.from] > 0 ∧

zr′

i

> 0 ∧

^1≤i≤s′

^1<i≤s′

i−1.to = r′
r′

i.from ∧ r′

s′ = r

Since zr > 0, it follows that yr > 0. Since φappl(σ, Y ) holds, it follows that

there exists a set of rules S = {r1, . . . , rs} ⊆ R such that

σ.κ[r1.from] > 0 ∧

yri > 0 ∧

ri−1.to = ri.from ∧ rs = r

We consider three cases:

^1≤i≤s

^1<i≤s

– Suppose σ′′.κ[r1.from] > 0 and suppose zri > 0 for every 1 ≤ i ≤ s. Then

we can simply set S′ := S.

– Suppose there exists i such that zri = 0. Hence zri 6= yri and this immedi-
ately implies that ri = t. Since σ′′ was obtained from σ by ﬁring t, it follows
that σ′′.κ[t.to] = σ′′.κ[ri.to] = σ′′.κ[ri+1.from] > 0. It is then easy to see
that we can set S′ := {ri+1, . . . , rs}.

– Suppose σ′′.κ[r1.from] = 0. We can assume that zri > 0 for every 1 ≤ i ≤ s
as otherwise the previous case applies. Since σ′′ was obtained from σ by ﬁring
t, it follows that r1.from = t.from = ℓ. Let inℓ
1, . . . , outℓ
b
be the set of incoming and outgoing rules at ℓ in the threshold automaton.
We further split this into two more cases:

a and outℓ

1, . . . , inℓ

• There exists i such that zinℓ

> 0. Let r′′ = inℓ
that yr′′ > 0. Hence there exists a set S′′ = {r′′

i

i. Since zr′′ > 0 it follows
1 , . . . , r′′
s′′ } ⊆ R such that

σ.κ[r′′

1 .from] > 0 ∧

yr′′

i

> 0 ∧

^1≤i≤s′′

^1<i≤s′′

i−1.to = r′′
r′′

i .from ∧ r′′

s′′ = r′′

Since ℓ is not part of any ﬁreable cycle with respect to Y and since
r′′.to = ℓ it follows that r′′
1 .from] > 0 =⇒

1 .from 6= ℓ. Hence σ.κ[r′′

23

σ′′.κ[r′′
with respect to Y , it follows that r′′
i > 0. Hence we can set S′ := {r′′
zr′′
• There does not exist i such that zinℓ

1 .from] > 0. Once again, since ℓ is not part of any ﬁreable cycle
i > 0 =⇒

i 6= t for any i. Therefore yr′′
1 , . . . , r′′
s′′ , r1, . . . , rs}.

> 0. We show that this case cannot
happen. Recall that the assignment Z satisﬁes the formula φL(σ′′, σ′, Z).
In particular,

i

a

b

zinℓ

i

−

zoutℓ

i

= σ′.κ[ℓ] − σ′′.κ[ℓ]

i=1
X

i=1
X
= 0 for all i, 1 ≤ i ≤ a. Also zr1 > 0 and r1 is
By assumption, zinℓ
(by deﬁnition) an outgoing transition from l. Hence the left hand side of
the equation is strictly less than 0. Since σ′′.κ[ℓ] = 0, it follows that the
right hand side of the equation is bigger than or equal to 0, which gives
rise to a contradiction.

i

B.3 Proof of Lemma 3

Proof. Suppose ℓ is part of some ﬁreable cycle with respect to Y , i.e., there
exists rules T = {t1, . . . , tm} such that yt1 > 0, . . . , ytm > 0, ti.to = ti+1.from
for all i < m, and tm.to = t1.from = ℓ. Let t = t1. Since yt > 0, from φR(σ, Y )
we obtain that σ |= t.ϕ. As we have σ.κ[t.from] = σ.κ[ℓ] > 0 we know that t
is enabled at σ. Hence we set σ′′ = t(σ) and let Z = {zr}r∈R be the following
assignment: zr = yr if r 6= t and zr = yr − 1 if r = t. It can be easily checked that
all of the following holds: φbase (σ′′, σ′)∧φL(σ′′, σ′, Z)∧φΓ (σ′′, σ′, Z)∧φR(σ′′, Z).
Therefore, we only need to prove that φappl(σ′′, Z) holds.

Fix any arbitrary rule r ∈ R such that zr > 0. We now have to show that

there exists a set of rules S′ = {r′

1, . . . , r′

s′ } ⊆ R such that

σ′′.κ[r′

1.from] > 0 ∧

zr′

i

> 0 ∧

^1≤i≤s′

^1<i≤s′

r′
i−1.to = r′

i.from ∧ r′

s′ = r

Since zr > 0, it follows that yr > 0. Since φappl(σ, Y ) holds, it follows that

there exists a set of rules S = {r1, . . . , rs} ⊆ R such that

σ.κ[r1.from] > 0 ∧

yri > 0 ∧

ri−1.to = ri.from ∧ rs = r

^1≤i≤s
We now consider three cases:

^1<i≤s

– Suppose σ′′.κ[r1.from] > 0 and suppose zri > 0 for every 1 ≤ i ≤ s. Then

we can simply set S′ := S.

– Suppose there exists i such that zri = 0. Hence zri 6= yri and this immedi-
ately implies that ri = t. Since σ′′ was obtained from σ by ﬁring t, it follows
that σ′′.κ[t.to] = σ′′.κ[ri.to] = σ′′.κ[ri+1.from] > 0. It is then easy to see
that we can set S′ := {ri+1, . . . , rs}.

24

– Suppose σ′′.κ[r1.from] = 0. We can assume that zri > 0 for every 1 ≤
i ≤ s as otherwise the previous case applies. Since σ′′ was obtained from
σ by ﬁring t, it follows that r1.from = t.from = ℓ = tm.to. Notice that
σ′′.κ[t.to] = σ′′.κ[t2.from] > 0 and also that zti = yti > 0 for all i > 1.
Hence we can set S′ := {t2, . . . , tm, r1, . . . , rs}.

Remark: Notice that, in the course of proving Theorem 4, we have actually
proved something much stronger. For a schedule τ and a rule r, let τ (r) denote
the number of times r is present in the schedule τ . Analysing our proof of
Theorem 4, it is easy to notice the following:

Lemma 4. If τ is a steady schedule between σ and σ′ then φsteady (σ, σ′) holds
with assignment {τ (r)}r∈R. Further, if φsteady (σ, σ′) holds with assignment {yr}r∈R
then it is possible to create a steady schedule τ between σ and σ′ such that
τ (r) = yr for all rules r.

B.4 Proof of Theorem 5

Proof. Let σ and σ′ be two conﬁgurations. First we will show that deciding
if there is a steady schedule τ such that τ (σ) = σ′ can be done in NP. From
Theorem 4 we know there is a steady schedule from σ to σ′ if and only if
the existential Presburger formula φsteady (σ, σ′) is true. However the formula
φsteady (σ, σ′) is exponential in size when constructed naively. But the exponential
dependence comes only from the constraint φappl which can be easily reduced to a
polynomial dependence as follows: For each rule t we guess a set S = {rt
1, . . . , rt
s}
and check that rt
i+1.to for all i < s. Once that is done, we
replace φappl with

s = t and rt

i .from = rt

xt > 0 =⇒ σ[rt

1.f rom] > 0 ∧ xrt

1

> 0 ∧ · · · ∧ xrt

s > 0

t∈R
^

It is then clear that φsteady (σ, σ′) is true if and only if at least one of our
guesses is true. Now we have reduced it to a polynomial sized existential Pres-
burger arithemtic formula which we can decide in NP (See [14]). This shows that
checking whether there is a steady schedule from σ to σ′ is in NP.

Now suppose we want to check if there is a (general) run from σ to σ′. By
Proposition 1, every path can be written as the concatenation of at most K
steady paths where K = |Φrise| + |Φfall| + 1. Hence it suﬃces to check if there is
a run of the form

σ = σ0

∗−→ σ′

0 → σ1

∗−→ σ′

1 → σ2 . . . σK

∗−→ σ′

K = σ′

such that the context of each σi is the same as the context of σ′
i. With this in
mind, we deﬁne φstep(η, η′) as the formula φsteady (η, η′), except we do not enforce
that η and η′ have the same context and we enforce that the existential variables
r∈R xr ≤ 1. It is easy to see that φstep(η, η′)
{xr}r∈R obey the constraint

P

25

is true iﬀ η′ can be reached from η in at most one step. Hence if we deﬁne
φreach(σ, σ′) to be

∃ σ0, σ′

0, . . . , σK , σ′

K 

σ0 = σ ∧ σ′

K = σ′ ∧

φsteady (σi, σ′

i) ∧

φstep(σ′

i, σi+1)



^0≤i≤K

^0≤i≤K−1



(3)
then it is clear that there is a run from σ to σ′ iﬀ φreach (σ, σ′) is satisﬁed. To
decide if φreach(σ, σ′) is true, we eliminate the exponentially sized disjunctions
in φsteady as before and check that the resulting (polynomial sized) formula is
satisﬁable.



The proof of Theorem 5 is complete. However, for future purposes, we mod-
ify the formula φreach(σ, σ′) slightly, so that it holds some extra information.
Notice that in equation 3, for each rule r, there is an existential variable xi
r ap-
pearing in the subformula φsteady (σi, σ′
i) and there is also an existential variable
yi
r appearing in the subformula φstep (σ′
i, σi+1). We introduce a new existential
r. Using
r +
variable sumr and enforce the constraint sumr =
Lemma 4 we can easily prove that

K−1
i=0 yi

K
i=0 xi

P

P

Lemma 5. The following are true:

– Suppose φreach(σ, σ′) is true with the assignment {zr}r∈R to the existential
variables {sumr}r∈R. Then there is a schedule τ between σ and σ′ such that
τ (r) = zr for all rules r.

– Conversely, if τ is a schedule between σ and σ′, then it is possible to satisfy

φreach(σ, σ′) by setting {τ (r)}r∈R to the variables in {sumr}r∈R.

For liveness properties, this lemma will prove very useful.

B.5 Proof of Corollary 1

Proof. Recall that, in the parameterized reachability problem, we are given two
sets L=0, L>0 of locations, and we want to decide if there is an initial conﬁg-
uration σ0, and some conﬁguration σ reachable from σ0 such that it satisﬁes
σ.κ[ℓ] = 0 for every ℓ ∈ L=0 and σ.κ[ℓ] > 0 for every ℓ ∈ L>0. The non-
parameterized reachability problem is similar, except the initial conﬁguration
σ0 is also given as part of the input.

By Theorem 5 we know that there is a formula φreach in existential Presburger
arithmetic with (2|L| + 2|Γ | + 2|Π|) free variables such that φreach (σ, σ′) is
true iﬀ there is a run between σ and σ′. For parameterized reachability, we
modify the formula φreach so that the free variables become existential variables.
For non-parameterized reachability, we modify φreach so that the free variables
corresponding to the ﬁrst conﬁguration is ﬁxed to σ0 and the free variables
corresponding to the second conﬁguration become existential variables. Finally,
in both the cases, we specify that the second conﬁguration must satisfy the
constraints according to the sets L=0 and L>0. It is then clear that by checking
if the constructed formula is satisﬁable, we can solve both the problems in NP.

26

C Detailed proofs from Section 5

We break down the proof of Theorem 6 into various parts. As a preliminary step,
we introduce the notion of a lasso path.

C.1 Lasso paths and cut graphs

Similar to model checking ﬁnite systems, we ﬁrst show that if a path of the
threshold automaton satisﬁes the ELTLFT formula ϕ, then there is an “ulti-
mately periodic” path which also satisﬁes ϕ.

For a schedule τ let [τ ] denote the set of all rules which appear in τ . We have

the following deﬁnition:

Deﬁnition 6. A path path(σ, τ ′) is called a lasso path if τ ′ can be decomposed
as ρ ◦ τ ω such that if we let σ1 = ρ(σ) and σ2 = (ρ ◦ τ )(σ) then

– σ1.κ = σ2.κ.
– If r ∈ [τ ] such that r.u[x] > 0 then for all rules r′ ∈ [τ ], x does not appear

in any of the fall guards of r′.

Proposition 2. If path(σ′, τ ′) satisﬁes a formula ϕ in ELTLFT then there is a
lasso path which satisﬁes ϕ.

Proof. We do not give details on Buchi automata and product construction, as
these are well-known.

The formula ϕ in ELTLFT can be thought of as an LTL formula over the atomic
propositions pf and hence there is a Buchi automaton Bϕ = (Q, 2pf , Q0, ∆, F )
which recognizes exactly those sequence of propositions which satisfy ϕ.

Fix a threshold automaton TA = (L, I, V, R). Let Σ be the set of all conﬁgu-
rations of TA, I be the set of all initial conﬁgurations of TA and T ⊆ Σ × R × Σ
be the transition relation between the conﬁgurations. Let Sys(TA) = (Σ, I, T ).
We can then construct the standard product construction Sys(TA) × Bϕ, where
there is a transition ((σ, q), p, (σ′, q′)) iﬀ (q, p, q′) ∈ ∆, (σ, r, σ′) ∈ T for some rule
r and σ |= p. A path (σ0, q0), (σ1, q1), . . . is an accepting path iﬀ it visits a state
in Σ × F inﬁnitely often.

Let P A = (σ0, q0), (σ1, q1), . . . be an inﬁnite accepting path in Sys(TA) × Bϕ.
in Sys(TA). Let V ⊆ Γ be the
This gives rise to a path P = σ0, r0, σ1, r1, . . .
set of all variables which are inﬁnitely often incremented along P . Since these
variables are inﬁnitely often incremented, it follows that there exists i such that
for all j ≥ i, rj does not have any fall guards with any of the variables in V . Since
the number of processes does not change during the course of a path and since
the number of states in F is ﬁnite, by combining all of the above facts, it follows
that we can ﬁnd an inﬁnite subsequence of P A of the form (σi1 , qi1 ), (σi2 , qi2 ), . . .
such that

– q = qi1 = qi2 = . . . and q ∈ F

27

– σi1 .κ = σi2 .κ = . . .
– For every j, σij .g[x] < σij+1 .g[x] iﬀ x ∈ V
– For every i1 ≤ j ≤ i2, the rule rj does not have any fall guards with any of

the variables in V .

Let ρ = r1 ◦ r2 ◦ · · · ◦ ri1−1 and let τ = ri1 ◦ ri1+1 ◦ · · · ◦ ri2−1. It can be
veriﬁed (using all the points given above) that path(σ0, ρ ◦ τ ω) is a lasso path
which satisﬁes ϕ.

Hence it suﬃces to concentrate on lasso paths in the future. To prove our
theorem, we also need the notion of a cut graph of a formula ϕ. However, for
our purposes, it suﬃces to know that the cut graph Gr(ϕ) of a formula ϕ is
a directed acyclic graph which consists of two distinguished vertices loopst and
loopend and every other vertex is labelled by a (normal) sub-formula of ϕ.

For a formula ϕ ≡ φ0 ∧F φ1 ∧· · ·∧F φk ∧G φk+1 in normal form, let prop(ϕ) =
φ0. The following lemma (proved in [19]) connects the notion of a lasso path and
the cut graph. Intuitively, it says that a lasso path satisﬁes a formula ϕ iﬀ
it can be “cut” into ﬁnitely many pieces such that (1) the endpoints of each
piece satisfy some (propositional) formula dictated by the cut-graph and (2) all
the conﬁgurations between any two endpoints satisfy some other (propositional)
formula as dictated by the cut-graph.
Lemma 6. A lasso path path(σ0, ρ ◦ τ ω) satisﬁes a formula ϕ ≡ φ0 ∧ F φ1 ∧ · · · ∧
F φk ∧ G φk+1 iﬀ there is a topological ordering

v1, v2, . . . , vc−1, vc = loopst, vc+1, . . . , vl−1, vl = loopend

of its cut graph and a ﬁnite path

σ0, τ0, σ1, τ1, . . . σc, τc, . . . σl−1, τl−1, σl

such that the following holds: If each vi (other than vc and vl) is of the form
0 ∧ F φi
φi

1 ∧ · · · ∧ F φi

ki ∧ G φi

ki+1, then

– σ0 is an initial conﬁguration, and τi(σi) = σi+1 for every 0 ≤ i < l.
– τ0 ◦ τ1 · · · ◦ τc−1 = ρ ◦ τ K for some K and τc ◦ · · · ◦ τl−1 = τ
– σ0 (cid:15) φ0 and Cfgs(σ0, τ0) (cid:15) prop(φk+1).
– For every i /∈ {c, l}, we have σi (cid:15) φi
0.
0≤j≤i prop(φj
– If i < c, then Cfgs(σi, τi) (cid:15)
0≤j<l prop(φj
– If i ≥ c, then Cfgs(σi, τi) (cid:15)
We note the subtle but important diﬀerence in the indices between the last
kj+1), but when

0≤j≤i prop(φj

kj +1).
kj +1).

two points. When i < c, we require Cfgs(σi, τi) (cid:15)
0≤j<l prop(φj
i ≥ c, we require Cfgs(σi, τi) (cid:15)

V
V

kj+1).
V

Remark: In [19] the above lemma was only proven for automata where there
are no updates in a cycle, but virtually the same proof also holds for the general
case.

V

Combining Proposition 2 and Lemma 6, we get the following lemma.

28

Corollary 2. The formula ϕ ≡ φ0 ∧ F φ1 ∧ · · · ∧ F φk ∧ G φk+1 is satisﬁable if
and only if there is a topological ordering <Gr

v1, v2, . . . , vc−1, vc = loopst, vc+1, . . . , vl−1, vl = loopend

of its cut graph and a ﬁnite path P

σ0, τ0, σ1, τ1, . . . σc, τc, . . . σl−1, τl−1, σl

such that the following holds: If each vi (other than vc and vl) is of the form
0 ∧ F φi
φi

1 ∧ · · · ∧ F φi

ki ∧ G φi

ki+1, then

– σ0 is an initial conﬁguration, σc.κ = σl.κ and τi(σi) = σi+1 for every i < l.
– If r ∈ [τc ◦ τc+1 · · · ◦ τl−1] such that r.u[x] > 0 then for every rule r′ ∈

[τc ◦ τc+1 · · · ◦ τl−1], x does not appear in any of the fall guards of r′.

– σ0 (cid:15) φ0 and Cfgs(σ0, τ0) (cid:15) prop(φk+1).
– For every i /∈ {c, l}, we have σi (cid:15) φi
0.
0≤j≤i prop(φj
– If i < c, then Cfgs(σi, τi) (cid:15)
0≤j<l prop(φj
– If i ≥ c, then Cfgs(σi, τi) (cid:15)

V

kj +1).
kj +1).

If such a topological ordering <Gr and such a path P exists then we call the pair
(<Gr, P ) a witness to the formula ϕ.

V

This ﬁnishes the ﬁrst part of the proof of theorem 6.

C.2 Roadmap

Before we move on to the next part, we give some intuition. Notice that for
(<Gr, P ) to be a witness for ϕ, among other restrictions, it has to satisfy some
reachability conditions (σi+1 = τi(σi)), some safety conditions (σi (cid:15) φ) as well as
some liveness conditions (Cfgs(σi, τi) (cid:15) φ). Our strategy for the next part is the
following: Intuitively, the main hindrance for us to apply our main result (that
the reachability relation is existential Presburger deﬁnable) here are the liveness
conditions. Here is where the multiplicativity condition comes into picture. For
a propositional formula p, we will deﬁne an existential Presburger arithmetic
formula φp with the following properties:

– If there is a path from σ to σ′ such that all the conﬁgurations in the path

satisfy p then φp(σ, σ′) will be true.

– If φp(σ, σ′) is true then there is a path from 2 · σ to 2 · σ′ such that all the

conﬁgurations in the path satisfy p.

Using this newly deﬁned formula φp and some additional tricks, we then show
that for a topological ordering <Gr, we can write a formula φlive such that φlive
will be satisﬁed iﬀ there is a path P such that (<Gr, P ) is a witness to the given
speciﬁcation.

29

C.3 The usefulness of multiplicativity

First, given a path P from σ0 to σm, we deﬁne a lifted path lift(P ) between
2 · σ and 2 · σm.

0, t0, σ1, τ1, σ′
Deﬁnition 7. Suppose σ0, τ0, σ′
is a path such that each τi is a steady schedule between σi and σi+1 and each ti
is a rule such that σ′
i and σi+1 have diﬀerent contexts. Its corresponding lifted
path lift(P ) is deﬁned by 2 · σ0, 2 · τ0, 2 · σ′
0, 2 · t0, 2 · σ1, 2 · τ1, . . . , 2 · tm−1, 2 · σm.

1, t1, . . . , σm−1, τm−1, σ′

m−1, tm−1, σm

Using multiplicativity it is easy to verify that lift(P ) is a valid path from

2 · σ0 to 2 · σm.

We say that a path P = σ0, τ0, σ1, . . . , σm, τm satisﬁes a proposition p if all

the conﬁgurations in P satisfy p. We now prove the following lemma:

Lemma 7. Let p be a propositional pf -formula as given in ELTLFT. Then there
exists an existential Presburger formula φp such that

– If there is a path P from σ to σ′ such that P satisﬁes p then φp(σ, σ′) will

be true.

– If φp(σ, σ′) is true then there is a path P from σ to σ′ such that the lifted

path lift(P ) from 2 · σ to 2 · σ′ satisﬁes p.

Proof. Recall that by theorem 5 that the reachability relation φreach(σ, σ′) is

∃ σ0, σ′

0, . . . , σK , σ′

K 

σ0 = σ ∧ σ′

K = σ′ ∧

φsteady (σi, σ′

i) ∧

^0≤i≤K

^0≤i≤K−1

φstep(σ′

i, σi+1)







i and φstep(σ′

where K = |Φ|+1, φsteady(σi, σ′

i) is true iﬀ there is a steady schedule between
σi and σ′
i in at most
one step. Further recall that for each rule r there is an existential variable sumr
which denotes the number of times the rule r is ﬁred in the run between σ and
σ′.

i, σi+1) is true iﬀ σi+1 can be reached from σ′

Let p be a pf -formula as given in ELTLFT. Depending on the structure of p we
introduce a diﬀerent formula for φp(σ, σ′): In each case, it will be immediately
clear that if there is a path P from σ to σ′ satisfying p, then φp(σ, σ′) is true. For
this reason, we will only discuss how to prove the other direction of the claim
(namely, if φp(σ, σ′) is true then there is a path P from σ to σ′ such that the
lifted path lift(P ) from 2 · σ to 2 · σ′ satisﬁes p.)

– p := (S = 0) for some S ⊆ L. In this case, we construct φp from φreach as
i), we add the following con-

follows: To each of the formulas φsteady (σi, σ′
straint

σi.κ[ℓ] = 0 ∧

σ′
i.κ[ℓ] = 0 ∧

sumr = 0

(4)

ℓ∈S
^

ℓ∈S
^

ℓ∈S
^

r∈Inℓ
^

where Inℓ denotes the set of all incoming transitions to ℓ. By using Lemma 5
it is clear that if φp(σ, σ′) is true then there is a path P between σ and σ′

30

such that all the conﬁgurations in the path P satisfy p. Consequently, it is
then easy to verify that all the conﬁgurations in the lifted path lift(P ) also
satisfy p.

– p := ¬(S = 0) for some S ⊆ L. In this case, we construct φp from φreach as
i) we add the following constraint

follows: To each of the formulas φsteady (σi, σ′

σi.κ[ℓ] > 0 ∧

σ′
i.κ[ℓ] > 0

(5)

ℓ∈S
_

ℓ∈S
_

0, . . . , σK, σ′

Using Lemma 5 it is then clear that if φp(σ, σ′) is true then there exists a
path between σ and σ′ such that each of the intermediate conﬁgurations
σ0, σ′
K satisfy p. By a careful inspection of the corresponding
lifted path lift(P ) it can be veriﬁed that every conﬁguration in the lifted
path satisﬁes p.
– p := (S′ = 0) ∧

S∈T ¬(S = 0). In this case, to each φsteady(σi, σ′

i) we add

V

σi.κ[ℓ] = 0 ∧

σ′
i.κ[ℓ] = 0 ∧

sumr = 0 ∧

ℓ∈S′
^

ℓ∈S′
^

ℓ∈S′
^

r∈Inℓ
^

σi.κ[ℓ] > 0

∧

σ′
i.κ[ℓ] > 0

(6)

!

ℓ∈S
_
– p := (g =⇒ c) where g is a gf -formula and c := (S′ = 0) ∧

ℓ∈S
_

S∈T
^

S∈T
^

is a cf -formula. In this case, to each φsteady(σi, σ′

!

S∈T ¬(S = 0)

i) we add the constraint
V

(σi |= g) =⇒ φc

(7)

where φc is the constraint given by equation (6).

Given a path P , let P (r) denote the number of times the rule r appears in

P . Notice that once again we have proved something stronger.

Lemma 8. Let p be a propositional formula in ELTLFT. Then,

– If there is a path P between σ and σ′ satisfying p then it is possible to satisfy

φp(σ, σ′) by setting {P (r)}r∈R to the variables {sumr}r∈R.

– Suppose φp(σ, σ′) is satisﬁable. Then there is path P between σ and σ′ such
that P (r) = sumr for every rule r and the lifted path lift(P ) satisﬁes p.

C.4 Proof of Theorem 6

Using the above lemma, we now give a proof of Theorem 6. The proof proceeds
by encoding the conditions mentioned in Corollary 2.

Let ϕ ≡ φ0

k0 ∧G φ0
For this reason, we ﬁrst guess and ﬁx a topological ordering <Gr

1 ∧· · ·∧F φ0

k0+1. We want to guess a witness (<Gr, P ).

0 ∧F φ0

v1, v2, . . . , vc = loopst, vc+1, . . . , vl = loopend

31

 
 
of the cut graph Gr(ϕ). Let each vi (apart from vc and vl) be of the form
0 ∧ F φi
φi

1 ∧ · · · ∧ F φi

ki ∧ G φi

ki+1.

We will write a formula φlive with existential variables decribing l+1 conﬁgu-
rations σ0, σ1, . . . , σc, . . . , σl. We will now show to enforce each of the conditions
mentioned by Corollary 2 as a formula in existential Presburger arithmetic. (For
ease of presentation, we provide the steps in an order diﬀerent from the one in
Corollary 2)

First condition: σ0 is an initial conﬁguration and σc.κ = σl.κ: Clearly this can
be encoded as an existential Presbuger formula.

Second condition: For each i /∈ {c, l}, σi (cid:15) φi
i is a propositional
pf formula, this constraint can once again be encoded as an existential Presbuger
formula.

0 : Since each φ0

Third condition: For each i < c, the path between σi and σi+1 must satisfy
0≤j≤i prop(φj
kj +1). We enforce this condition

0≤j≤i prop(φj

kj +1) : Let pi :=

by putting the constraint
V

V

φpi (σi, σi+1)

(8)

Fourth condition: For each i ≥ c, the path between σi and σi+1 must satisfy
0≤j≤l prop(φj
kj +1). We enforce this condition

0≤j≤l prop(φj

kj +1) : Let pi :=

by putting the constraint
V

V

φpi (σi, σi+1)

(9)

Fifth condition:
If r is a rule which is ﬁred in the schedule between σc and σl
such that r.u[x] > 0 for some shared variable x, then for every rule r′ which is
ﬁred in the schedule between σc and σl, x should not appear in any of the fall
guards of r′ : Recall that for every 0 ≤ i < l and for every rule r, the formula
φpi (σi, σi+1) (as deﬁned in 8 and 9) has an existential variable sumi
r which
denotes the number of times the rule r has been ﬁred in the schedule between
σi and σi+1. Hence to enforce this condition, we put the following constraint:















sumi

r > 0



∧ r.u[x] > 0 ∧ r′ ∈ F allx

=⇒

sumi

r′ = 0





r,r′∈R,x∈V
^
Here F allx denote the set of all rules which have a fall guard with the variable

c≤i<l
^

c≤i<l
_













x.

Let φlive be the above formula. From the construction of the formula and
Lemma 8 it is clear that if (<Gr, P ) is a witness then φlive is satisﬁable. On the
other hand, suppose φlive is satisﬁable. We therefore get a sequence of conﬁgu-
rations η0, . . . , ηl satisfying the formula φlive. By Lemma 8 we get that for every
i, there is a path Pi between ηi and ηi+1 such that Pi(r) = sumi
r for every rule
r and the lifted path lift(Pi) satisﬁes the proposition pi. It is then easy to see
that the pair (<Gr, Q) where Q is given by,

32

lift(P0), lift(P1), . . . , lift(Pl−1)

is a witness.

It then follows that model-checking formulas in ELTLFT is in NP.

D Detailed proofs of Section 6

Proof of theorem 7

Proof. Given a sketch threshold automaton TA, formula ϕ, and polynomial p,
we ﬁrst guess in polynomial time an assignment µ. Clearly we can check if µ
makes the environment multiplicative in NP as the conditions of deﬁnition 2 can
be encoded as a(n) (integer) linear program. Using Theorem 6, we can decide
if all executions of TA[µ] satisfy ¬ϕ in co-non-deterministic polynomial time in
TA[µ]. So we get a Σp

2 procedure for the bounded synthesis problem.

Proof of theorem 8

The upper bound follows from Theorem 7 and so we only prove the lower bound
here, by giving a reduction from the Σ2-3-SAT problem, which is well-known to
be Σp

2 -hard.

Let ∃x1, . . . , xm ∀y1, . . . , yk φ(x, y) be a Σ2-3-SAT formula where φ(x, y) is
in disjunctive normal form. We construct a threshold automaton as follows: (See
Figure D for an illustrative example)

Let Env = (Π, RC , N ) be the environment where Π consists of a single

variable n, RC is simply n ≥ 1 and N is the identity function.

The sketch threshold automaton TA is constructed as follows: For every vari-
able xi we will have a location ℓxi. Further we will also have a start location
ℓx0. Let a, b1, . . . , bm, ¯b1, . . . , ¯bm be shared variables. Our construction will en-
sure that a will never be incremented. Let v1, . . . , vm be indeterminates which
will appear in the threshold guards. Between ℓxi−1 and ℓxi there are two rules
of the form (ℓxi−1, ℓxi, a < vi · n, bi++) and (ℓxi−1, ℓxi, a ≥ vi · n, ¯bi++). Since a
will never be incremented (and hence always stay 0), it follows that depending
on the value that vi is assigned to, exactly one of these two rules can be ﬁred.

For every variable yi we will have a location ℓyi and two other locations
ℓzi, ℓ ¯zi. Further we will also have a location ℓy0 and a transition (ℓxm, ℓy0, true, 0).
Let c1, . . . , ck, ¯c1, . . . , ¯ck be shared variables. From ℓyi−1 there are two rules,
(ℓyi−1, ℓzi, true, ci++) and (ℓyi−1, ℓ ¯zi, true, ¯ci++). Intuitively, ﬁring the ﬁrst rule
corresponds to making yi to be true and ﬁring the second rule corresponds to
making it false. We will ensure that if two diﬀerent processes ﬁre two diﬀerent
rules from ℓyi−1 then all the processes get stuck: We add two rules (ℓzi, ℓyi, ci ≥
n, 0) and (ℓ ¯zi, ℓyi, ¯ci ≥ n, 0). These two rules ensure that if two diﬀerent processes
ﬁred two diﬀerent rules from the location ℓyi−1 then they all get stuck and cannot
progress to ℓyi.

33

For a variable xi, let var(xi) = bi and var( ¯xi) = ¯bi. Similarly for a variable
yi, let var(yi) = ci and var( ¯yi) = ¯ci. Now for every disjunct D = p ∧ q ∧ r that
appears in φ(x, y) we have the following transition from ℓyk to a new location
ℓF : (ℓyk , ℓF , var(p) ≥ 1 ∧ var(q) ≥ 1 ∧ var(r) ≥ 1, 0). Finally both ℓyk and ℓF
have self-loops with no guards.

Let the above sketch threshold automaton be TA. Let ϕ′ be the following

formula:

var(p) ≥ 1 ∧ var(q) ≥ 1 ∧ var(r) ≥ 1







_(p∧q∧r)∈φ(x,y)



and let ϕ be the following formula: (F G (ϕ′ =⇒ ℓyk = 0)) ∧ (G ℓF = 0). The
ﬁrst part of ϕ says that if any one of the rules between ℓyk and ℓF get unlocked
at some point, then all the processes leave ℓyk (and subsequently go to ℓF ). The
second part of ϕ says that no process ever reaches ℓF . Hence ϕ can be satisﬁed
by a path iﬀ there is a process in ℓyk but none of the outgoing rules from ℓyk are
unlocked.

We notice the following observation about the constructed threshold automa-
ton: Let µ be any assignment to the indeterminates. In any inﬁnite run of TA[µ] at
least one process reaches the location ℓyk. Further, in any run in which some pro-
cess reaches the location ℓyk , the run satisﬁes the following: For every 1 ≤ i ≤ m,
either all conﬁgurations of the run have bi = 0 or all conﬁgurations of the run
have ¯bi = 0. Similarly for every 1 ≤ j ≤ k, either all conﬁgurations of the run
have ci = 0 or all conﬁgurations of the run have ¯ci = 0.

Let p be the identity function. We now show that there exists an assignment
to the indeterminates {vi} (using p(|TA|+|ϕ|) many bits) such that ¬ϕ is satisﬁed
by every inﬁnite run iﬀ the formula ∃x1, . . . , xm ∀y1, . . . , yn φ(x, y) is true.

Suppose there exists an assignment µ to the indeterminates {vi} such that
¬ϕ is true for every inﬁnite run starting from every initial conﬁguration in the
threshold automaton TA[µ]. Consider the following assignment ν for the variables
xi: ν(xi) = true if µ(vi) > 0 and ν(xi) = false if µ(vi) = 0. It is now an easy
check that the formula ∀y1 . . . yn φ(ν(x), y) is true.

Suppose the formula ∃x1, . . . , xm ∀y1, . . . , yn φ(x, y) is true. Let ν be an
assignment to the variables {xi} such that ∀y1 . . . yn φ(ν(x), y) is true. Consider
an assignment µ to the indeterminates {vi} as follows: µ(vi) = 1 if ν(xi) = true
and µ(vi) = 0 if ν(xi) = false. It is once again easy to check that ¬ϕ is true
for every inﬁnite run starting from every initial conﬁguration in the threshold
automaton TA[µ].

34

ℓz1

++
c1

a < v1 · n 7→ b1++

a < v2 · n 7→ b2++

ℓx0

ℓx1

ℓx2

true

ℓy0

a ≥ v1 · n 7→ ¯b1++

a ≥ v2 · n 7→ ¯b2++

c

¯

1

+

+

ℓ ¯z1

c

1

≥

n

ℓy1

n

≥

¯c1

b1 ≥ 1 ∧ c1 ≥ 1 ∧ ¯c1 ≥ 1

ℓF

¯b1 ≥ 1 ∧ ¯b2 ≥ 1 ∧ c1 ≥ 1

Fig. 6. Threshold automaton corresponding to the formula ∃x1, x2 ∀y1 (x1 ∧ y1 ∧ ¯y1) ∨
( ¯x1 ∧ ¯x2 ∧ y1)

35

