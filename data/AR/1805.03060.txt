CloudAR: A Cloud-based Framework for Mobile
Augmented Reality

Wenxiao ZHANG, Sikun LIN, Farshid Hassani Bijarbooneh, Hao Fei CHENG, and Pan HUI, Fellow, IEEE

1

8
1
0
2

y
a
M
8

]

M
M

.
s
c
[

1
v
0
6
0
3
0
.
5
0
8
1
:
v
i
X
r
a

Abstract—Computation capabilities of recent mobile devices
enable natural feature processing for Augmented Reality (AR).
However, mobile AR applications are still faced with scalability
and performance challenges. In this paper, we propose CloudAR,
a mobile AR framework utilizing the advantages of cloud and
edge computing through recognition task ofﬂoading. We explore
the design space of cloud-based AR exhaustively and optimize the
ofﬂoading pipeline to minimize the time and energy consumption.
We design an innovative tracking system for mobile devices which
provides lightweight tracking in 6 degree of freedom (6DoF)
and hides the ofﬂoading latency from users’ perception. We
also design a multi-object image retrieval pipeline that executes
fast and accurate image recognition tasks on servers. In our
evaluations, the mobile AR application built with the CloudAR
framework runs at 30 frames per second (FPS) on average with
precise tracking of only 1∼2 pixel errors and image recognition
of at least 97% accuracy. Our results also show that CloudAR
outperforms one of the leading commercial AR framework in
several performance metrics.

Index Terms—augmented reality, tracking,

image retrieval,

mobile computing, cloud computing, edge computing.

I. INTRODUCTION

Augmented Reality (AR) is a natural way of interaction
between the real world and digital virtual world. For a
typical AR application, it recognizes the surrounding objects
or surfaces and overlays information on top of the camera
view with a 3D renderer. Currently, mobile Augmented Reality
(MAR) is the most practical AR platform as mobile devices
are widely used in our daily life, and many mobile AR
SDKs (e.g., Apple ARKit [1], Google ARCore [2], Vuforia
[3]) are released to enable fast development of AR Apps.
However, mobile devices are still suffering from the inherent
problems of mobile platforms (e.g., limited computation power
and battery life), which restrict their performance in practical
AR applications. Some works [4], [5], [6] have showed the
tracking, and rendering capabilities of mobile
recognition,
devices, nevertheless, like most of the AR applications in the
market, they are working in simple scenarios, displaying some

W. ZHANG is with the Department of Computer Science and Engineering,
the Hong Kong University of Science and Technology, Hong Kong. E-mail:
wzhangal@cse.ust.hk

S. LIN is with the Department of Computer Science, University of Cali-

fornia, Santa Barbara. E-mail: sikun@ucsb.edu

F. H. Bijarbooneh is with the Department of Computer Science and
Engineering, the Hong Kong University of Science and Technology, Hong
Kong. E-mail: farshidhss@ust.hk

H. F. CHENG is with the Department of Computer Science and Engineer-

ing, University of Minnesota, U.S.. E-mail: cheng635@umn.edu

P. HUI is with the Department of Computer Science and Engineering,
the Hong Kong University of Science and Technology, Hong Kong, and the
Department of Computer Science, University of Helsinki, Finland. E-mail:
panhui@cse.ust.hk

ﬁxed contents based on detected surfaces, and limiting their
usage in gaming or simple demonstration.

The key enabler of practical AR applications is context
awareness, with which AR applications recognize the objects
and incidents within the vicinity of the users to truly assist
their daily life. Large-scale image recognition is a crucial
component of context-aware AR systems, leveraging the vision
input of mobile devices and having extensive applications in
retail, education, tourism, advertisement, etc.. For example, an
AR assistant application could recognize road signs, posters,
or book covers around users in their daily life, and overlays
useful information on top of those physical images.

Despite the promising beneﬁts, large-scale image recogni-
tion encounters major challenges on the mobile platform. First,
large-scale image recognition requires the storage of large
image dataset, and the corresponding annotation contents are
also huge in scale and size. Second, the image recognition task
itself is computation intensive and consumes a lot of time and
energy [7]. According to a study [8], it takes on average longer
than 2 seconds to ﬁnish object recognition on a mobile CPU
(Snapdragon 800).

By utilizing cloud image recognition, cloud-based AR sys-
tems1 [9], [10], [11] are able to ﬁll the gap between context-
aware AR experience and insufﬁcient mobile capabilities.
Similar to web applications, context-aware AR applications
should communicate with the cloud to ofﬂoad the image
recognition tasks and retrieve useful information. However,
cloud-based systems suffers from the ofﬂoading latency, which
consists of both the network transferring delay and server
processing time. Results of the recognition requests are always
returned after a moment, during which the users are likely
to move their hands. Unlike typical web applications, AR
applications have to align the recognition results precisely with
the physical world. The cloud recognition latency makes the
results mismatch with the current view, as shown in Figure 1,
and damages the quality of experience (QoE) signiﬁcantly.

With the inevitable ofﬂoading latency, mobile AR appli-
cations should handle the outdated result properly. Existing
in solving this mismatching
cloud-based AR systems fail
problem. They either ask the users to hold their hands steady to
coarsely match the result with the current view, or neglect the
performance constraints and real-time interaction requirement
of mobile devices.

To address the scalability and latency issues in MAR appli-
cations, we propose CloudAR, a cloud-based MAR framework
with both an innovative mobile client design and a powerful

1We use cloud-based system to refer to both edge servers and cloud servers.

 
 
 
 
 
 
2

II. RELATED WORK

A. On-device mobile Augmented Reality

To precisely overlay annotation contents on top of the
physical environment, a typical AR application calculates the
physical camera pose and aligns the renderer’s virtual camera
accordingly for each frame, where the pose is in 6 degree of
freedom (3 degree of translation and 3 degree of rotation).
The derived camera pose can be either relative to an image,
or absolute in the environment.

Typical mobile AR SDKs can be divided into two cate-
gories: a) traditional SDKs (e.g., Wikitude [12], Vuforia [3],
Blippar [13] with their basic functions) that heavily utilize
computer vision technologies for marker-based AR, which
recognize a marker ﬁrst and track the relative camera pose
to the marker for each frame; b) emerging AR SDKs (e.g.,
Google ARCore [2], Apple ARKit [1]) that bring marker-less
AR onto the mobile platform, which calculate an absolute pose
of the camera in the environment with visual-inertial odometry
(VIO) [14], [15].

For marker-based AR, Nate et al. [4] proposes a mobile
system to recognize and estimate 6DoF pose of planar shapes,
and applies recursive tracking to achieve interactive frame rate.
Wagner et al. modiﬁes SIFT and Ferns to make them suitable
for mobile platforms [5], and builds a system to detect and
track multiple objects on a mobile phone [6]. Global object
pose estimation and device localization are also implemented
on the mobile platform [16], [17].

For marker-less AR, both ARCore and ARKit

leverage
feature points from the monocular camera and motion data
from the inertial measurement unit (IMU) to track the pose
of the mobile device in 3D. Their tracking capability is more
ﬂexible and scalable compared to marker-based AR.

B. Cloud-based Mobile Augmented Reality

Google Goggles [18] lets a user search by taking a picture.
If Goggles ﬁnds it in its database, useful information will
be provided. The systems in [9], [10] try to address the
scalability problem and integrates the tracking system with
image retrieval techniques on a PC, but they cannot handle the
mismatching problem. A similar system is described in [11],
where extra information like region of interest (ROI) of the
object is required from the user to initialize the recognition and
tracking. Overlay [19] also utilizes server for image retrieval,
and they requires the user to hold the camera still to let
annotation display in a coarsely correct position. VisualPrint
[20] is another cloud-based mobile augmented reality system
which uploads extracted features instead of raw images or
video stream to save network usage.

Compared to existing cloud-based AR systems,

the
CloudAR framework handles the ofﬂoading latency properly
and practically, and minimizes the overall latency and energy
consumption.

C. Image Retrieval Techniques

To detect and extract features from an image, SIFT [21],
and SURF [22] provide good results with robust scale and

(a) Server recognizes images in the request frame.

(b) Results mismatch with the current view.

Fig. 1: Mismatching problem in cloud-based AR caused by
cloud recognition latency.

image recognition pipeline running on cloud servers. One
major advantage of CloudAR is that it solves the mismatching
problem with an innovative tracking system running on the
mobile client, where the historical
tracking status of the
request frame is recorded and ﬁnally utilized by the tracker
to compute a corrected position of the physical image after
receiving the result. With our ﬁne-grained AR ofﬂoading
pipeline, AR applications developed with CloudAR support
large-scale image recognition with the guarantee of high QoE.
We achieve this with the following contribution:

• A lightweight mobile tracking system that provides pre-
cise 6 degree-of-freedom (6DoF) multi-object tracking,
hides mismatching of the recognition result from user’s
perception, and achieves real-time performance at 30
frames-per-second (FPS).

• A multi-object cloud image recognition pipeline that
provides low-latency, high-accuracy multi-image recog-
nition, as well as pose estimation services.

• A ﬁne-grained cloud ofﬂoading pipeline that minimizes
the overall recognition latency and mobile energy con-
sumption, and a systematic evaluation with comparison
to a popular commercial MAR SDK.

The remainder of this paper is organized as following:
Section II introduces the existing work on MAR systems and
latency compensation techniques. Section III discusses the
design choices of CloudAR. Section IV gives an overview
of the system architecture. Section V and VI describe the
mobile client design and server design, respectively. The
implementation details and the experimental results are shown
in Section VII. Finally, the conclusion is given in Section VIII.

rotation invariant, and CNN features [23] provide state-of-
the-art representation accuracy. However, these approaches are
slow. Combined with binary descriptors, corner feature points
detectors such as Harris corner detector [24], FAST [25], and
AGAST [26] are faster choices.

To further retrieve or classify images, one image can be
encoded into a single vector. The authors in [27] introduce
the bag-of-visual-words (BOV) model. The authors in [28],
[29], [30] present Fisher kernel encoding as a statistically more
accurate representation than k-means clustering used in BOV.
In recent years, Fisher Vector (FV) is widely used in image
retrieval with good performance as shown in [31], [32]. The
authors in [33], [34] propose LSH for fast nearest neighbor
search, and many improvements are proposed in [35], [36],
[37].

D. Latency Hiding Techniques

Volker Strumpen et al. presentes a latency hiding protocol
for asynchronous message passing in UNIX environments
[38]. With this protocol distributed parallel computing can be
utilized in applications.

Outatime [39] is a mobile cloud gaming system which
delivers real-time gaming interactivity. The basic approach
combines input prediction with speculative execution to render
multiple possible frame outputs which could occur in a round
trip time of future. Kahawai [40] is another mobile gaming
systems which aims at providing high-quality gaming quality
by ofﬂoading a portion of the GPU computation to server-side
infrastructure. In contrast with previous thin-client approaches
which require a server-side GPU to render the entire content,
Kahawai uses collaborative rendering to combine the output
of a mobile GPU and a server-side GPU into the displayed
output.

TYH Chen et al. [41] tries to solve the ofﬂoading latency
problem on mobile by caching frames during the ofﬂoading
tracker on the frames upon
procedure and running visual
receiving the result. Up-to-date position of the objects can be
found with their approach, but this method may cause instant
computationally intensive demands. Meanwhile, their object
tracking system is 2D based which cannot give the 6DoF poses
of objects.

Different from those existing methods, CloudAR targets
speciﬁcally at latency compensation under the scenario of AR,
which is more challenging as the latency problem is more
sensitive with the alignment of virtual and physical world
and the physical environment is less predictable. CloudAR
provides seamless real-time user experiences while keeping
the mobile client as lightweight as possible.

III. BACKGROUND AND DESIGN CHOICES

In this section, we explore the design space of the cloud-
based AR systems, and discuss the advantages and disadvan-
tages of possible solutions to motivate the design of CloudAR.

A. Is VIO a good solution for context-aware AR?

3

independent of the detection of speciﬁc markers, providing a
more ﬂexible and scalable tracking capability when compared
with traditional marker-based AR. However, VIO cannot rec-
ognize the surrounding objects and get context information.
Most of existing AR Apps powered by ARCore or ARKit
work on the detected horizontal surfaces (e.g., table, ﬂoor) for
gaming or demonstration.

To learn the tracking performance of ARCore, especially in
the scenario of tracking recognized image, we build an AR
App based on ARCore, which recognizes one image stored in
the App and tracks it afterwards. The App is deployed on a
Samsung Galaxy S8 smartphone, which is a ﬂagship model
and well-calibrated for ARCore. The tracking results of four
representative sequences are shown in Figure 2, from which
we ﬁnd several problems of VIO-based AR systems:

VIO tracking of markers are inaccurate and unstable.
As shown in Figure 2, ARCore tracking results are not accurate
in the cases of camera tilt, rotation and scaling, with obvious
mismatching between the physical image and the tracking
result. Unstable tracking results arise frequently as well, where
the annotated image edges hop during tracking as shown in
the second half of sequence (b), and this is not a rare case
as hopping happens in four out of ten repeated attempts. As
VIO tracking combines both the visual and inertial outputs, the
noisy and biased inertial measurements are the main reason for
this unsatisfying performance.

VIO needs good initialization. Upon loading of the App,
a initialization procedure is needed before the tracker would
work. The initialization usually takes few seconds, and the user
has to hold and move the phone for a few seconds. On the
contrary, visual-based tracker used in marker-based AR would
start working instantly upon loading without an initialization.
VIO cannot track moving objects. Unlike the tracking
of object’s relative pose in visual tracking systems, typical
VIO systems are supposed to work in a rigid environment,
where the localization procedure locates the devices’ pose and
ignores moving objects, as shown in sequence (d) of Figure
2. Although some existing work have addressed the moving
object tracking problem [42], [43] in simultaneous localization
and mapping (SLAM) systems, these methods make major
modiﬁcations of the SLAM pipeline, which add up to the
overall complexity and is not currently supported by ARCore
or ARKit.

tracking,

VIO needs physical size of recognized image. Without
considering the dynamic object
the static object
tracking of VIO is different from that of visual tracker as
well. Visual tracker works with the relative pose and size of
the physical object and annotation contents, so that the cloud
recognition service would return the pose of the image object
without caring about the real size of the image. However, as
the odometry unit of VIO systems is in actual physical size, the
tracking of static objects needs the physical size of the image
as well, which is not possible to infer on the cloud server and
not trivial to get on the mobile client. In this App developed
with ARCore, we have to manually input the physical size of
the image, which limits its pervasive usage.

ARKit and ARCore hit the market, and the technology
underneath, VIO locates mobile devices in the environment

With the shortages shown above, a VIO based solution
is not adequate in context-aware AR with image recognition

4

Fig. 2: Results of ARCore tracking in four scenarios: (a) view changing; (b) camera rotation; (c) scaling caused by forward
and backward movement; (d)object moving. The red edges are the tracking results on the mobile client.

Fig. 3: Typical mobile AR pipeline.

functionalities. Marker-based AR performs better in terms of
accuracy, robustness, ease of use, and availability for image
tracking at the current stage.

B. Marker-based AR pipeline

A typical pipeline of marker-based mobile AR systems has
7 building blocks, as shown in Figure 3. It starts with Frame
Preprocessing that shrinks the size of a camera frame, e.g.,
by downscaling it from a higher resolution to a lower one.
The next step is Object Detection that checks the existence of
targets in the camera view of a mobile device and identiﬁes
the regions of interest (ROI) for the targets. It will then apply
Feature Extraction to extract feature points from each ROI
and Object Recognition to determine the original image stored
in a database of to-be-recognized objects. Template Matching
veriﬁes the object-recognition result by comparing the target
object with the recognized original image. It also calculates the
pose of a target (i.e., position and orientation). Object Tracking
takes the above target pose as its initial input and tracks target
object between frames in order to avoid object recognition
for every frame. Finally, Annotation Rendering augments the
recognized object by rendering its associated content.

C. Latency Compensation Choices

As the cloud recognition latency is inevitable, cloud-based
AR systems need to handle this latency properly so that the
annotation contents can be aligned with the physical objects
precisely. For marker-based AR, there are two ways to hide
the latency.

Template Matching

Mobile Client Cloud Server

Time Consumption(ms)
Energy Consumption(uAh)

438.2 ± 96.5
276.0 ± 60.9

57.62 ± 6.14
N/A

TABLE I: Time and energy consumption for template match-
ing with SIFT features on a Xiaomi Mi5 phone and a cloud
server, respectively. The value after ± is the standard deviation
(for 20 experimental runs).

One possible solution is that the server sends the original
image back and the client executes template matching to
calculate the current pose of the image. However, template
matching is not a trivial task on mobile, which consumes
much time and energy when compared with cloud execution,
as shown in Table I. Executing template matching on the server
reduces the overall pipeline latency signiﬁcantly. On the other
hand, even if template matching is executed on the client, the
time consumption of template matching would also make the
mismatching happen, as several frames have passed during the
template matching procedure.

Another solution is tracking the image movement during
the cloud recognition procedure, as tracking is much more
light-weight compared to template matching. With the tracked
image pose transformation during the cloud recognition pro-
cedure, the recognition result can be corrected accordingly
to match the current view. A previous work Glimpse [41]
proposes to solve the mismatching problem with tracking
as well, but Glimpse caches selected frames during cloud
recognition and starts tracking after receiving the result, with
the recognition result utilized as the tracking initial input.
However, this design would erupt processing burden on the
mobile device, and the tracking of a sequence of frames takes
long time and causes mismatching as well.

As a result, our system disperse the tracking processing
during the cloud recognition procedure. Our design achieves
overall low latency while keeping the mobile client lightweight
and ﬂuent.

5

Fig. 4: CloudAR overview showing the data ﬂow and the main
components of the mobile client and the server.

IV. SYSTEM DESIGN OVERVIEW

Figure 4 shows an overview of the system architecture, that
includes the mobile client and the cloud server. Following is
a brief description of the overall procedure:

On the mobile client, visual tracker gets the camera video
feed and starts extracting and tracking feature points within
view once the application is launched. Unlike [11], our system
would not require the user to input the region of interest (ROI),
and camera stream is the only input of the whole framework.
Therefore, the visual tracker simply tracks feature points of
the entire frame at this time. An object recognition request
is sent to server to recognize target objects inside the camera
frame.

The server creates worker threads to process the received
request. These worker threads handle the receiving and send-
ing messages on the network, as well as performing the visual
tasks.

The result is then sent back to the mobile client, including
poses and identity information of the recognized objects. With
tracker is able to calculate
feature points tracking, visual
the location transition of any speciﬁc area inside the frames.
Therefore the current poses of the objects can be derived from
the result, which are poses of objects within the request frame.
These poses are further utilized by the content renderer to
render virtual contents.

This process repeats periodically under visual

tracker’s
scheduling, thus new objects are recognized and augmented
continuously.

V. MOBILE CLIENT DESIGN

The mobile client mainly works on tracking and contents
rendering, with the heavy image recognition tasks ofﬂoaded to
the cloud. Since the main working ﬂow is already described
in Section IV, here we focus on introducing these functional
modules on mobile client and their working principles.

A. Visual Tracker

Visual tracker carries out the core logic of mobile client,
scheduling the execution of other modules. We design our
own feature point based tracking method for mainly two
reasons. First, in CloudAR tracking starts without a ROI or the

Fig. 5: Visual
tracker pipeline. The sequence above in
grayscale stands for the feature point extraction and tracking
pipeline, where each number indicates the feature points set
number; the sequence below in color stands for the objects
pose initialization and update pipeline, where K stands for a
key frame, C stands for a continuous frame, and R stands for
a result frame.

object position, and the renderer needs precise 6DoF results
rather than simple rectangle bounding boxes to position virtual
contents in a 3D space. Feature point based tracking gives us
the ﬂexibility to do these calculations. Second, visual tracker
must achieve a high FPS on the mobile client, and feature point
based tracking (e.g., optical ﬂow [44]) is lightweight enough
to fulﬁll this requirement.

We decouple the feature tracking and object pose estimation
tasks into two separate pipelines, as shown in Figure 5. The
ﬁrst pipeline works on feature point extraction and tracking
for the whole frame, while the second pipeline works on pose
initialization and update for recognized objects.

The feature point extraction and tracking pipeline, basis
of visual tracker, starts processing the camera frames upon
launching of the mobile client. A sufﬁcient amount of feature
points are extracted by the algorithm proposed in [45] at the
beginning, composing a feature points set, and the coordinates
of these feature points in following frames are updated via
optical ﬂow.

To support multi-object tracking, as shown in Figure 6, an
array called “bitmap” is also generated at the beginning, whose
length is exactly the same as the number of feature points. This
array is used to record the existence and group belonging of
each feature point, where for each array element, “0” means
the corresponding feature point is lost during the tracking
process, and other positive value (e.g., object ID) indicates
the corresponding feature point drops inside the contour of a
speciﬁc object. After feature point extraction in the ﬁrst frame,
all bitmap values are initialized to 1 to indicate the existence
of these feature points, but the group belongings of them are
uncertain yet.

In visual tracker, a group of feature points are extracted
and tracked, but it is a rare case for visual tracker to use
the same set of feature points from the beginning to the end.
Feature points regeneration may happen under two conditions.
First, when new objects are recognized by the server. This
indicates either new objects have moved into the camera view,
or the camera view has changed dramatically. Second, when
the number of feature points decreases to a certain threshold.
This is caused by lost of some feature points during tracking,

6

Fig. 6: Multi-object tracking of CloudAR. The red and green boundaries are the output of the visual tracker.

or by camera view changing as well.

B. Content Renderer

When a camera frame meets any of these conditions, a new
set of feature points are extracted from this frame. The beneﬁt
of this design is that for any pair of consecutive frames, there
are always enough number of corresponding feature points
from same feature points set, which enables uninterrupted
object pose estimation.

The object pose initialization and update pipeline,
working on top of the former pipeline, starts from the ﬁrst
ofﬂoading result. Considering any pair of frames, if we know
the old pose of an object and the old locations of feature points
within its contour, we can calculate the new pose of the object
with the new locations of these feature points using geometric
transformation.

As shown in Figure 5, 30 camera frames compose one
logical cycle of this pipeline. Based on their functionalities,
camera frames can be divided into three categories: key frames,
continuous frames and result frames. The ﬁrst frame of each
cycle is a key frame, where a recognition request is sent.
At the same time, visual tracker keeps a copy of the current
feature points. After several continuous frames, the recognition
result is received, and that frame becomes a result frame. The
preserved feature points from key frame, together with feature
points from result frame, are used to calculate the new poses
of the recognized objects within result frame.

In visual tracker, target objects would go through three
states: a) position initialization, as described above; b) position
tracking, via geometric transformation between consecutive
continuous frames; c) position update, with new recognition
results from latter result frames. We design the logical cycle
for the two reasons. First, new target objects may appear
continuously within view. Apparently, cold start latency for
recognizing new objects can be shortened by increasing the of-
ﬂoading frequency, but the logical cycle time should be longer
than ofﬂoading latency. We choose 30 frames (∼ 1 second)
as the cycle length considering the ofﬂoading latency under
different networks. Second, drift problem should always be
taken into consideration during the tracking process, making
augmented contents move away from right position gradually.
With regular recognition requests, positions of objects can
be corrected with recent recognition result, which is more
accurate.

With the cooperation of this two pipelines, ofﬂoading delay
between the key frame and the result frame is hidden from the
perception of users, making our proposed tracking method es-
pecially suitable for MAR applications under cloud ofﬂoading
scenario.

Content renderer is the output module of CloudAR. A 3D
graphics engine is integrated to render the virtual contents
with 6DoF poses of objects, so the virtual contents would
attach precisely to physical objects in a 3D world space. For
each camera frame, the graphics engine updates the virtual
contents based on the output of visual tracker, where for each
object a homography is ﬁrst calculated to ﬁnd the 2D transition
between the reference image and the target image, and the 2D
position is later casted into a 3D spatial pose.

C. Network Module

Network module is the messager between client and server.
UDP, as a connection-less protocol, saving the overhead of
handshaking dialogues, becomes our choice. Packet losses may
happen as UDP is an unreliable communication method, but
our system tolerates packet loss naturally: cloud recognitions
happen periodically, and new recognition result can be re-
ceived very soon in next cycle. Even if a reliable network
protocol is used for visual task requests, the results could
come late due to the re-transmission of lost packets, which
is not acceptable in this real time system. CloudAR uses non-
blocking UDP in independent threads so that the client and
server will not be blocked for network issues.

VI. SERVER DESIGN

In mobile AR systems, continuous visual processing tasks is
nearly impossible in real-time on current devices. In CloudAR
framework, we utilize cloud and edge servers as a processing
center for those heavy computer vision tasks, which enables
the mobile and wearable clients to provide ﬂuent AR experi-
ence and abundant contents.

A. Task Manager

Upon launching an AR application, the mobile client will
communicate with the server to initialize the cloud service. On
server side, task manager creates three threads for processing
continuous requests from each incoming client: one requests
receiving thread, one visual processing thread and one results
sending thread.

B. Visual Task Processor

Visual

task processor fulﬁlls visual requests, extracting
desired information out of camera frames. In our approach,
image features are used for retrieving corresponding image
from the dataset.

7

Fig. 8: Image recognition pipeline. One frame is ﬁrst seg-
mented into multiple images, on which image retrieval tech-
niques are applied to ﬁnd nearest neighbors. Finally, template
matching with neighbors veriﬁes the results and calculates
positions of the segmented images.

Vector (FV). Encoded FVs will be L2 and power normalized,
and all FVs of the dataset images will be stored and go through
Locality Sensitive Hashing (LSH) to create hash tables for
faster retrieval.

After building up the dataset, server can take the responsibil-
ity for recognition tasks. Segmented individual patches will be
simultaneously re-sized into similar scale to the reference im-
ages, and encoded into FVs through the procedures mentioned
above. The parameters for the BMM model used for query
patch Fisher encoding is the same as that used for encoding
reference images, which have been already calculated. By LSH
tables and stored FVs, we will ﬁnd the nearest neighbors of
the segmented patches. Five nearest neighbors will be found
for each patch, and feature matching would be used to select
the correct one from the ﬁve.

Feature matching is the last step to verify the result of
image retrieval and calculate a 6DOF pose of the target. For
each segmented patch, with the feature descriptors from both
the patch and the nearest neighbors, feature matcher can ﬁnd
the corresponding feature pairs. If enough number of matches
are found for any neighbor, we pick that neighbor as the
recognition result and start pose estimation. We calculate the
homography of the target within camera view, which stands
for a 2D position transition, and return only simple corner
positions to the task manager for sending it back to the mobile
client. If there are not enough good matches for all ﬁve nearest
neighbors in the dataset, the patch will be discarded and no
result will be returned.

VII. IMPLEMENTATION AND EVALUATION

tracker

We implement

the mobile client on the Android plat-
implemented with
form. The mobile visual
is
OpenCV4Android2 library, and the 3D renderer is a modiﬁed
Rajawali3 library. The cloud server side is implemented in
C++ based on Linux platform. OpenCV 4 library is used
for multi-scale AGAST feature points detection and FREAK
descriptor extraction. FALCONN5 library is used for building

2http://opencv.org/platforms/android.html
3https://github.com/Rajawali/Rajawali
4http://opencv.org
5https://falconn-lib.org

(a) Camera frame input sent
from the client to the server.

(b) Areas with high pixel vari-
ance are highlighted.

(c) Identiﬁed areas before noise
reduction as binary image.

(d) The objects of interest are
identiﬁed and segmented.

Fig. 7: Procedures of the image segmentation.

1) Image Segmentation: Upon receiving an incoming cam-
era frame from the client, the server will proceed to perform
the image processing tasks. To reduce system load and speed
up the process,
image segmentation is carried out on the
camera frame before retrieving information from it. The image
segmentation identiﬁes and extracts the segments in images
that contain the image objects, while removing the background
in the process. This effectively ensures each query patch
contains at most one reference.

The segmentation process is shown in Figure 7. We ﬁrst
apply Gaussian blur to the raw image to reduce noise. Then
we apply a sliding window that iterates through the image, and
compute the variance in pixel color values for each window.
The areas with variance higher than a constant threshold are
ﬂagged as positive, while the areas with low variance are
ﬂagged as negative since they are likely to be part of the
background. This results in a binary image, and we further
clean it up by applying an erosion followed by a dilation. The
processed image would contain polygons outlining the located
objects. The system can then extract the images of the objects
by cutting the polygons from the raw image.

2) Image Retrieval: The overall image retrieval pipeline is
shown in Figure 8. To build the dataset, we need to detect key
points and extract corresponding features from each reference
image. As the reference images for building the dataset and
the query images getting from camera frames need to be
handled through the same procedure, we need to consider
the processing speed. Multi-scale AGAST[26] detector and
FREAK[46] binary feature descriptors are used, and we adopt
Fisher encoding built upon binary features for accurate and
real-time performance. To do Fisher encoding on binary fea-
tures, we ﬁrst need to build a Bernoulli mixture model (BMM),
which is built upon the collection of all descriptors of the
dataset images. After getting parameters of the BMM model,
descriptors of an image can be encoded into a single Fisher

8

movement, rotation, scaling, and tilt. The results are shown in
Figure 10.

We record the positions of the poster’s four corners in each
frame given by the tracker, and obtain the ground truth by
manually labeling corners for all frames. There are two com-
mon ways to measure the tracking accuracy: a) intersection
over union (IOU), which considers the bounding boxes of
both the tracking result and the ground truth, and it is deﬁned
as the proportion of intersection area within the union area
of the two boxes; b) pixel error, which is deﬁned as the
pixel distance on screen between the center of the tracking
result and that of the ground truth. As our tracking method
provides ﬁne-grained 6DoF results, the bounding boxes are
irregular quadrilaterals, whose intersection area and union area
are complex to calculate. Instead, the center of each bounding
box is more convenient to ﬁnd, which is the intersection point
of the two diagonals of the box. For this reason, we use pixel
error as the evaluation metrics in this part. The results are
shown in Figure 11, where the pixel errors in all scenarios
are as low as 1 or 2 for most of the time. The worst case is
rotation, but the pixel errors are still under 5.

Also the rotation scenario shows a trend of drift, which is
common in incremental tracking. However, our system handles
the drift problem as the mobile client sends recognition
requests periodically, and revises the position in tracking with
the recognition results accordingly. This design guarantees that
drift in tracking will last no longer than 30 frames in the worst
case.

2) Tracking Speed: The time consumption of tracking each
frame is composed of four parts: time to down sample the
frame, time to calculate the optical ﬂow of feature points, time
to estimate the poses of objects, and idle time waiting for next
data. Since we use feature points based method in tracking,
the amount of points would inﬂuence the performance and
delay of tracker. To learn the impact of this factor, we measure
the time consumptions of tracking camera frames with four
different numbers of feature points, which are 60, 120, 180 and
240, correspondingly. For each case, we record the timestamps
of different parts for 500 frames.

The results are shown in Figure 12. There is a clear trend
that the time consumption of tracking one frame increases with
the number of feature points, and the optical ﬂow calculation
part results in this time variance. To guarantee a 30 FPS perfor-
mance of the tracker, the upper limit of the time consumption
on each frame is 33.34ms. We can see that all four cases satisfy
this requirement on average, and non-qualiﬁed only in worst
cases with 240 feature points. We conclude that our visual
tracker ensures a real-time performance with the amount of
feature points less than or equal to 180.

C. Ofﬂoading Latency

Ofﬂoading latency is deﬁned as the time period from the
moment obtaining request camera frame data to the moment
displaying ofﬂoading result, which is composed of three parts:
delay of client, including the time to compose request and
calculate new poses after receiving the result; delay of server,
including the time to parse request and recognize image; delay

Fig. 9: The PosterAR App running our CloudAR framework.
The App utilizes our framework to retrieve poster information
and overlay movie trailers on the camera stream.

LSH tables and ﬁnding approximate nearest neighbor of FVs.
We also rely on OpenMP6 for parallel processing.

We develop an AR application called PosterAR using our
CloudAR framework. When a user steps into a cinema, he/she
does not have a clear idea about which movie to watch. At
this time the user can launch the PosterAR App, point the
camera to the posters, and watch a trailer of that movie. The
play buttons and movie trailers are strictly overlaid according
to the homography of the posters, so that they are precisely
coupled as if there is a virtual video wall.

The running examples of Poster App are shown in Figure 9.
On the left the user is holding the phone against two movie
posters and the App augments trailers on top of the posters.
On the middle and right, movie trailers are played in 3D
world space once the user presses the play button. In this
section, we collect relevant data from PosterAR to evaluate
the performance of our framework.

A. Experiment Setup

On the client side, the PosterAR App runs on a Xiaomi
MI5 with a quad core CPU and 4GB RAM. On the server
side, we deploy servers on both local PC and Google Cloud
Platform, considering the requirements of edge computing and
cloud computing. The local PC is conﬁgured with an Intel i7-
5820k CPU (6 cores @3.3GHz) and 32GB RAM, and we
create a WiFi Access Point on the PC so that the phone is
directly connected to the local server. This setup reﬂects the
scenario of edge computing as the processing components are
placed nearby in the LTE tower or local router within one hop
distance of the mobile device. Meanwhile, the virtual machine
on Google Cloud is conﬁgured with 8 vCPUs and 32GB RAM.
We conduct our experiments with respect to mobile tracking
performance, ofﬂoading latency, and image retrieval accuracy.

B. Tracking Performance

Visual tracker is the key component of the CloudAR frame-
work, whose performance affects directly the user’s perceived
experience. In this section, we evaluate the performance of vi-
sual tracker with respect to the tracking accuracy and tracking
speed.

1) Tracking Accuracy: An important indicator of the track-
ing performance is the quality of 6DoF tracking, which is
crucial in providing a seamless AR experience. We design four
common tracking scenarios to evaluate the performance: fast

6http://openmp.org

9

Fig. 10: Four common scenarios of camera movement: (a) fast movement with motion blur; (b) camera rotate; (c) scaling
caused by forward and backward movement; (d) tilt caused by changing view. The green edges are labeled with tracking
results from the mobile client.

(a) Fast Movement - Pixel errors.

(b) Rotation - Pixel errors.

(c) Scaling - Pixel errors.

(d) Tilt - Pixel errors.

Fig. 11: Tracking accuracy in pixel errors. Our visual tracker
performs good in all four scenarios of camera movement with
little pixel errors.

of network, including the round trip time of the datagram
packets.

In this section, we measure both the local ofﬂoading latency
and the cloud ofﬂoading latency with the PosterAR App. For
each ofﬂoading scenario, 200 ofﬂoading tasks are generated
and recorded.

1) Latency Distribution: Figure 13a is the CDF of overall
ofﬂoading latency for two ofﬂoading scenarios, and local
ofﬂoading scenario tends to have a lower latency than cloud
ofﬂoading scenario. 60% of the local ofﬂoading tasks are
ﬁnished before 300ms, and 97% of them are ﬁnished before
500ms. On the contrary, only 35% of the cloud ofﬂoading
tasks are ﬁnished before 500ms, but all of them are ﬁnished
before 850ms. (We also measure the latency of cloud of-
ﬂoading scenario under 4G connection in Section VII-E3.)
Figure 13b is the distribution of ofﬂoading latency in passed
frame numbers, which represents the number of frames that
has passed (processed by visual tracker) before the ofﬂoading

Fig. 12: Time consumption for tracking one frame with
different amount of feature points. The results are averaged
over 200 runs with standard derivation shown in black line.

(a) CDF of ofﬂoading latency for
both local ofﬂoading scenario and
cloud ofﬂoading scenario.

(b) Distribution of ofﬂoading la-
tency in passed frames.

Fig. 13: Delay of ofﬂoading for both local scenario and
cloud scenario with 200 runs. Compared with cloud ofﬂoading
scenario,
local ofﬂoading scenario tends to have a lower
latency, as shown in both latency time and passed frames.

results are showed to user. For local ofﬂoading scenario, 60%
of the results are showed within 8 frames after the starting
points of ofﬂoading, and 100% of them are showed within
16 frames. Meanwhile, the distribution of cloud ofﬂoading

10

If the query images are passed directly into the feature ex-
traction stage without segmentation, then the resulting retrieval
mean Average Precision (mAP) is around 0.76 for top-5 NN
(nearest neighbor), and around 0.61 if we only check one most
nearest neighbor, as shown by the “without segmentation” line
in Figure 15. The relative low mAP is mainly caused by multi-
target existence within one query image, or random scattered
noise in the background.

Given good segmentation results, the retrieval can achieve
good accuracy for top-5 NN. In our experiment, all patches
will be re-sized into a 400×400 resolution. From Figure 15
we can see that in most cases, we only need to examine
the most nearest neighbor during the matching step to get
the correct result, and the expectation of examined neighbor
number is close to 1. The high-resolution line corresponds to
a patch size of at least 400×400 pixels. The mid-resolution
line corresponds to having segmented patches with size around
200×200 pixels, and the small-resolution line corresponds to
patch size of 100×100 pixels. During our experiment, more
than 90% segmented incoming frames can correctly retrieve
their corresponding images in the dataset.

E. Performance Comparison with Vuforia

Vuforia is a leading commercial AR framework that sup-
ports cloud recognition, and CloudAR focuses on cloud-based
AR solutions. Therefore, we compare several performance
metrics of cloud recognition functionalities between CloudAR
and Vuforia.

To setup the experiment, we download the ofﬁcial
CloudReco App from Vuforia. This App performs image
recognition tasks by ofﬂoading, receives results and displays
augmented contents to user. On the Android side of Vuforia,
we do essential instrumentation on CloudReco to log analysis
data and inﬂuence the performance as little as possible. On the
server side of Vuforia, we create a image database with their
web services. Since Vuforia supports only one-by-one image
uploading, we create a database with only 100 images. For our
PosterAR App, we use the previous setup mentioned before,
and the cloud server hosted on Google Cloud Platform is used
to pursue a fair comparison. Both WiFi and 4G connections
of the phone are used to evaluate the performance of the two
frameworks under different network conditions.

1) Data Usage: Data transmission is always involved in
ofﬂoading, so we want
to compare the data trafﬁc usage
for the two frameworks. Through our network monitoring
of the CloudReco App, we ﬁnd out that cloud recognitions
in Vuforia framework are implemented with Https requests.
With this knowledge, we setup a man-in-the-middle (MITM)
proxy using Fiddler8 and decrypt all the recognition requests
and responses of the CloudReco App. Our key ﬁnding is that
each request body contains a JPEG ﬁle of the current camera
frame, and each response body contains another JPEG ﬁle
of the recognized original image from database. Since there
are only 100 images in our created Vuforia demo database,
we use this 100 images to trigger cloud recognition tasks on
both frameworks. The average request sizes of the PosterAR
App and the CloudReco App are 11.58KB and 16.24KB

Fig. 14: Components of latency for both local ofﬂoading sce-
nario and cloud ofﬂoading scenario. The results are averaged
over 200 runs.

Fig. 15: Image retrieval mean Average Precision (mAP) for
matching 1-5 nearest neighbors (NN) with or without seg-
mentation under different scales.

scenario looks like a normal distribution, and we come to the
same conclusion as before that cloud ofﬂoading scenario has
a longer latency than local ofﬂoading scenario, as the mean of
this “normal distribution” is 15 frames.

Figure 14 shows the components of latency for both sce-
narios. The part compose request takes around 60ms, where
encoding raw frame data into a small image ﬁle spends most
of this time. The uplink latency and downlink latency parts
in local ofﬂoading scenario are much shorter than that in
cloud ofﬂoading scenario. Parse task is the ﬁrst part of time
spent on server to parse the request as well as control the
processing. Recognition is the second part of time spent on
server, including the time to segment the camera frame, ﬁnd
nearest neighbor, match and verify the result. For both parse
task and recognition, the local server processes faster than
the cloud server, showing that the local server has a better
processing capability. Process result is the time that the client
processes the result and displays it to user.

From the requirements of visual

the whole of-
ﬂoading procedure should ﬁnish within 30 frames (1 second).
The results from ﬁgure 14 prove that our ofﬂoading pipeline
fulﬁlls this requirement under both local and cloud ofﬂoading
scenarios.

tracker,

D. Image Retrieval Accuracy

We collect several hundreds of movie posters online, com-
bining with some data from Stanford Mobile Visual Search
Dataset [47] to form 1000 reference images. Query sets are
photoed by Mi5’s back camera, together with several query
sets from [47].

11

On the contrary, Vuforia cloud ofﬂoading has a much longer
latency, especially under 4G connection. For Vuforia cloud
ofﬂoading under WiFi connection, only 30 percent of the
ofﬂoading tasks are ﬁnished with 1 second, and the worst
case takes around 1.6 seconds. It is worth to mention that
there is not much difference in the network accessing latency
of Vuforia and CloudAR cloud servers, with RTTs of 48
ms and 36 ms, respectively under WiFi connection. Vuforia
cloud ofﬂoading under 4G connection has a noticeable poorer
performance, with only 50 percent of the ofﬂoading tasks are
ﬁnished within 2 seconds, and the worst case takes as long
as 4.4 seconds. This poor performance of Vuforia under 4G
possibly comes from the combination of large result size and
lossy 4G connection, which turns into a long cold-start latency.
4) Multi-target Recognition Support: CloudAR framework
supports multi-target recognition from the design of mobile
visual tracker and cloud image recognition pipeline, and a
running example of recognizing multiple targets is showed in
ﬁgure 9. In CloudAR framework, most of the computation bur-
den of recognizing multiple target is ofﬂoaded to server, and
the mobile client only processes simple tasks like calculating
the bounding boxes with ofﬂoading results. On the contrary,
the CloudReco App does not support multi-target recognition,
and only one target within camera view is recognized every
time. Even if multi-target cloud recognition is supported under
the current Vuforia ofﬂoading design, multiple original images
would make the results quite huge, and the heavy feature ex-
traction and template matching processes for multiple images
on mobile would ruin the user experience.

VIII. CONCLUSION

In this paper, we presented CloudAR, a cloud-based AR
framework which targets at solving the large-scale multiple
image recognition and real-time augmenting problems on
mobile and wearable devices. We proposed an innovative
tracker running on mobile to hide the ofﬂoading latency from
user’s perception, and a multi-object image retrieval pipeline
running on server. Our evaluation showed that the AR App
built with CloudAR performs effectively in terms of seam-
less AR experience and robustness. We further showed that
our framework has high tracking accuracy, high recognition
accuracy, low overall ofﬂoading latency, and high runtime
performance.

ACKNOWLEDGMENT

This work was supported in part by the General Research
Fund from the Research Grants Council of Hong Kong under
Grant 26211515 and in part by the Innovation and Technol-
ogy Fund from the Hong Kong Innovation and Technology
Commission under Grant ITS/369/14FP.

REFERENCES

[1] Apple Inc., “Introducing ARKit: Augmented Reality for iOS,” https:
//developer.apple.com/arkit/, 2017, [accessed on 20-October-2017].

[2] Google,

“ARCore

Overview,”

https://developers.google.com/ar/

discover/, 2017, [accessed on 20-October-2017].

[3] “Vuforia,” https://www.vuforia.com, 2017, [accessed on 20-October-

2017].

(a) FPS of Apps with ofﬂoading
built with CloudAR and Vuforia.

(b) CDF of ofﬂoading latency for
both CloudAR and Vuforia with
200 runs.

Fig. 16: Performance comparison Of CloudAR and Vuforia in
terms of FPS and ofﬂoading latency.

correspondingly, as both of them are sending compressed
camera frame to the cloud. However, the average result sizes
of the two Apps differ hugely. In CloudAR, the results contain
only coordinates of the bounding boxes and other identity
information of the images, so we make the result a ﬁxed size
of only 400 bytes. In Vuforia, the average size of ofﬂoading
results is 33.48KB, showing that Vuforia consumes much more
data trafﬁc than CloudAR in each ofﬂoading task.

2) Runtime FPS: FPS reﬂects the runtime performance of
the Apps, which has straightforward inﬂuence on the user
perceived experience. Ofﬂoading procedure is an extra burden
onto the mobile device besides frame-by-frame tracking, so
we want to learn how would ofﬂoading inﬂuence the FPS.

The ofﬂoading procedure of the PosterAR App is periodical,
but the CloudReco App would trigger an ofﬂoading task when
there is no recognized object in the current frame. Imagine a
scenario where the user scans through a series of posters on the
wall, and periodical ofﬂoading happens in both frameworks.
To simulate this scenario, we make a slideshow of the images
on the screen and point the phone’s camera to the screen when
the two Apps are launched. The slideshow has a ﬁxed change
interval of 2 seconds, and we record the runtime FPS of both
Apps. A typical fragment of the result is shown in ﬁgure 16a.
We can see that the FPS of the CloudReco App will decrease
signiﬁcantly upon receiving a result, and we perceive obvious
non-smooth frames during the experiment. In comparison, the
PosterAR App runs at a much stable FPS with little jitters
around 30. As the ofﬂoading result of Vuforia is the original
image, feature extraction and matching are executed on the
client, which are computationally intensive for mobile devices
that decrease the FPS signiﬁcantly.

3) Ofﬂoading Latency: We use the same scenario in mea-
suring FPS to trigger 200 ofﬂoading tasks for both CloudAR
and Vuforia under WiFi and 4G connections, and the ofﬂoad-
ing latency results are shown in ﬁgure 16b. We have already
seen the CDF of CloudAR cloud ofﬂoading latency under
WiFi connection in previous section, and the CDF of that
latency under 4G connection has a similar pattern with it, with
slightly longer latency but still guaranteed to ﬁnish within 1
second. These latency results of CloudAR cloud ofﬂoading
prove that our periodical ofﬂoading design works with cloud
servers under both WiFi and 4G connections.

[4] N. Hagbi, O. Bergig, J. El-Sana, and M. Billinghurst, “Shape recognition
and pose estimation for mobile augmented reality,” in Mixed and Aug-
mented Reality, 2009. ISMAR 2009. 8th IEEE International Symposium
on.

IEEE, 2009, pp. 65–71.

[5] D. Wagner, G. Reitmayr, A. Mulloni, T. Drummond, and D. Schmalstieg,
“Real-time detection and tracking for augmented reality on mobile
phones,” IEEE transactions on visualization and computer graphics,
vol. 16, no. 3, pp. 355–368, 2010.

[6] D. Wagner, D. Schmalstieg, and H. Bischof, “Multiple target detection
and tracking with guaranteed framerates on mobile phones,” in Mixed
and Augmented Reality, 2009. ISMAR 2009. 8th IEEE International
Symposium on.

IEEE, 2009, pp. 57–64.

[7] X. Yang and K. T. Cheng, “Mobile image search: Challenges and
methods,” in Mobile Cloud Visual Media Computing. Springer, 2015,
pp. 243–262.

[8] M. Shoaib, S. Venkataramani, X.-S. Hua, J. Liu, and J. Li, “Exploiting
on-device image classiﬁcation for energy efﬁciency in ambient-aware
systems,” in Mobile Cloud Visual Media Computing. Springer, 2015,
pp. 167–199.

[9] J. Pilet and H. Saito, “Virtually augmenting hundreds of real pictures:
An approach based on learning, retrieval, and tracking,” in 2010 IEEE
Virtual Reality Conference (VR).

IEEE, 2010, pp. 71–78.

[10] S. Gammeter, A. Gassmann, L. Bossard, T. Quack, and L. Van Gool,
“Server-side object recognition and client-side object tracking for mobile
augmented reality,” in 2010 IEEE Computer Society Conference on
Computer Vision and Pattern Recognition-Workshops.
IEEE, 2010,
pp. 1–8.

[11] J. Jung, J. Ha, S.-W. Lee, F. A. Rojas, and H. S. Yang, “Efﬁcient mobile
ar technology using scalable recognition and tracking based on server-
client model,” Computers & Graphics, vol. 36, no. 3, pp. 131–139, 2012.
[12] “Wikitude,” https://www.wikitude.com/, 2017, [Online; accessed 04-

August-2017].

[13] “Blippar,” https://blippar.com, 2017, [accessed on 20-October-2017].
[14] M. Li and A. I. Mourikis, “High-precision, consistent ekf-based visual-
inertial odometry,” The International Journal of Robotics Research,
vol. 32, no. 6, pp. 690–711, 2013.

[15] S. Leutenegger, S. Lynen, M. Bosse, R. Siegwart, and P. Furgale,
“Keyframe-based visual–inertial odometry using nonlinear optimiza-
tion,” The International Journal of Robotics Research, vol. 34, no. 3,
pp. 314–334, 2015.

[16] J. Ventura, C. Arth, G. Reitmayr, and D. Schmalstieg, “Global localiza-
tion from monocular slam on a mobile phone,” IEEE transactions on
visualization and computer graphics, vol. 20, no. 4, pp. 531–539, 2014.
[17] C. Arth, C. Pirchheim, J. Ventura, and V. Lepetit, “Global 6dof
pose estimation from untextured 2d city models,” arXiv preprint
arXiv:1503.02675, 2015.

[18] G. Inc., “Google Goggles,” https://play.google.com/store/apps/details?

id=com.google.android.apps.unveil&hl=en, 2010.

[19] P. Jain, J. Manweiler, and R. Roy Choudhury, “Overlay: Practical mobile
augmented reality,” in Proceedings of the 13th Annual International
Conference on Mobile Systems, Applications, and Services. ACM, 2015,
pp. 331–344.

[20] ——, “Low bandwidth ofﬂoad for mobile ar,” in Proceedings of the 12th
International on Conference on emerging Networking Experiments and
Technologies. ACM, 2016, pp. 237–251.

[21] D. G. Lowe, “Object recognition from local scale-invariant features,” in
Computer vision, 1999. The proceedings of the seventh IEEE interna-
tional conference on, vol. 2.

Ieee, 1999, pp. 1150–1157.

[22] H. Bay, T. Tuytelaars, and L. Van Gool, “Surf: Speeded up robust
features,” in European conference on computer vision. Springer, 2006,
pp. 404–417.

[23] A. Krizhevsky, I. Sutskever, and G. E. Hinton, “Imagenet classiﬁcation
with deep convolutional neural networks,” in Advances in neural infor-
mation processing systems, 2012, pp. 1097–1105.

[24] C. Harris and M. Stephens, “A combined corner and edge detector.” in

Alvey vision conference, vol. 15. Citeseer, 1988, p. 50.

[25] E. Rosten, R. Porter, and T. Drummond, “Faster and better: A machine
learning approach to corner detection,” IEEE transactions on pattern
analysis and machine intelligence, vol. 32, no. 1, pp. 105–119, 2010.

[26] E. Mair, G. D. Hager, D. Burschka, M. Suppa, and G. Hirzinger,
“Adaptive and generic corner detection based on the accelerated segment
test,” in European conference on Computer vision. Springer, 2010, pp.
183–196.

[27] G. Csurka, C. Dance, L. Fan, J. Willamowski, and C. Bray, “Visual
categorization with bags of keypoints,” in Workshop on statistical
learning in computer vision, ECCV, vol. 1, no. 1-22.
Prague, 2004,
pp. 1–2.

12

[28] T. S. Jaakkola, D. Haussler et al., “Exploiting generative models in
discriminative classiﬁers,” Advances in neural information processing
systems, pp. 487–493, 1999.

[29] F. Perronnin, J. S´anchez, and T. Mensink, “Improving the ﬁsher kernel
for large-scale image classiﬁcation,” in European conference on com-
puter vision. Springer, 2010, pp. 143–156.

[30] H. Jegou, F. Perronnin, M. Douze, J. S´anchez, P. Perez, and C. Schmid,
“Aggregating local image descriptors into compact codes,” IEEE Trans-
actions on Pattern Analysis and Machine Intelligence, vol. 34, no. 9,
pp. 1704–1716, 2012.

[31] F. Perronnin, Y. Liu, J. S´anchez, and H. Poirier, “Large-scale image
retrieval with compressed ﬁsher vectors,” in Computer Vision and
Pattern Recognition (CVPR), 2010 IEEE Conference on.
IEEE, 2010,
pp. 3384–3391.

[32] M. Douze, A. Ramisa, and C. Schmid, “Combining attributes and ﬁsher
vectors for efﬁcient image retrieval,” in Computer Vision and Pattern
Recognition (CVPR), 2011 IEEE Conference on.
IEEE, 2011, pp. 745–
752.

[33] P. Indyk and R. Motwani, “Approximate nearest neighbors: towards
removing the curse of dimensionality,” in Proceedings of the thirtieth
annual ACM symposium on Theory of computing. ACM, 1998, pp.
604–613.

[34] A. Gionis, P. Indyk, R. Motwani et al., “Similarity search in high
dimensions via hashing,” in VLDB, vol. 99, no. 6, 1999, pp. 518–529.
[35] M. Datar, N. Immorlica, P. Indyk, and V. S. Mirrokni, “Locality-sensitive
hashing scheme based on p-stable distributions,” in Proceedings of the
twentieth annual symposium on Computational geometry. ACM, 2004,
pp. 253–262.

[36] A. Andoni and P. Indyk, “Near-optimal hashing algorithms for approx-
imate nearest neighbor in high dimensions,” in 2006 47th Annual IEEE
Symposium on Foundations of Computer Science (FOCS’06).
IEEE,
2006, pp. 459–468.

[37] B. Kulis and K. Grauman, “Kernelized locality-sensitive hashing for
scalable image search,” in 2009 IEEE 12th international conference on
computer vision.

IEEE, 2009, pp. 2130–2137.

[38] V. Strumpen and T. L. Casavant,

Implementing communication
latency hiding in high-latency computer networks. Berlin, Heidelberg:
Springer Berlin Heidelberg, 1995, pp. 86–93. [Online]. Available:
https://doi.org/10.1007/BFb0046614

[39] K. Lee, D. Chu, E. Cuervo, J. Kopf, Y. Degtyarev, S. Grizan, A. Wol-
man, and J. Flinn, “Outatime: Using speculation to enable low-latency
continuous interaction for mobile cloud gaming,” in Proceedings of the
13th Annual International Conference on Mobile Systems, Applications,
and Services. ACM, 2015, pp. 151–165.

[40] E. Cuervo, A. Wolman, L. P. Cox, K. Lebeck, A. Razeen, S. Saroiu,
and M. Musuvathi, “Kahawai: High-quality mobile gaming using gpu
ofﬂoad,” in Proceedings of the 13th Annual International Conference on
Mobile Systems, Applications, and Services. ACM, 2015, pp. 121–135.
[41] T. Y.-H. Chen, L. Ravindranath, S. Deng, P. Bahl, and H. Balakrishnan,
“Glimpse: Continuous, real-time object recognition on mobile devices,”
in Proceedings of the 13th ACM Conference on Embedded Networked
Sensor Systems. ACM, 2015, pp. 155–168.

[42] C.-C. Wang, C. Thorpe, and S. Thrun, “Online simultaneous localization
and mapping with detection and tracking of moving objects: Theory and
results from a ground vehicle in crowded urban areas,” in Robotics and
Automation, 2003. Proceedings. ICRA’03. IEEE International Confer-
ence on, vol. 1.

IEEE, 2003, pp. 842–849.

[43] C.-C. Wang, C. Thorpe, S. Thrun, M. Hebert, and H. Durrant-Whyte,
“Simultaneous localization, mapping and moving object tracking,” The
International Journal of Robotics Research, vol. 26, no. 9, pp. 889–916,
2007.

[44] B. D. Lucas, T. Kanade et al., “An iterative image registration technique
with an application to stereo vision.” in IJCAI, vol. 81, no. 1, 1981, pp.
674–679.

[45] J. Shi and C. Tomasi, “Good features to track,” in Computer Vision
and Pattern Recognition, 1994. Proceedings CVPR’94., 1994 IEEE
Computer Society Conference on.

IEEE, 1994, pp. 593–600.

[46] A. Alahi, R. Ortiz, and P. Vandergheynst, “Freak: Fast retina keypoint,”
in Computer vision and pattern recognition (CVPR), 2012 IEEE con-
ference on.

IEEE, 2012, pp. 510–517.

[47] V. R. Chandrasekhar, D. M. Chen, S. S. Tsai, N.-M. Cheung, H. Chen,
G. Takacs, Y. Reznik, R. Vedantham, R. Grzeszczuk, J. Bach et al., “The
stanford mobile visual search data set,” in Proceedings of the second
annual ACM conference on Multimedia systems. ACM, 2011, pp. 117–
122.

13

Wenxiao ZHANG received the bachelor’s degree
in computer science and technology from the De-
partment of Computer Science and Technology at
Zhejiang University, China, in 2014. He is currently
working toward the PhD degree in the Department
of Computer Science and Engineering at The Hong
Kong University of Science and Technology and
a member of Symlab. His main research interests
include the areas of mobile computing, edge com-
puting, and augmented reality.

Sikun LIN received the bachelor’s and master’s
degrees in computer science and engineering from
the Department of Computer Science and Engi-
neering at the Hong Kong University of Science
and Technology, Hong Kong, in 2015 and 2017,
respectively. She is currently working toward the
PhD degree in the Department of Computer Science
at University of California, Santa Barbara, U.S.. Her
main research interests include the areas of computer
vision and human-computer interaction.

Farshid Hassani Bijarbooneh received the master’s
and PhD degrees in computer science from the De-
partment of Information Technology at the Uppsala
University, Sweden, in 2009 and 2015, respectively.
In 2015−2017, he was a postdoctoral researcher
with the Hong Kong University of Science and
Technology, Hong Kong. He is currently working
as Senior Developer at Assessio and Co-founder
of SpaceFox Studio, Stockholm. His main research
interests include the areas of mobile computing,
wireless sensor networks, and augmented reality.

Hao Fei CHENG received the bachelor’s degree in
computer science and engineering from the Depart-
ment of Computer Science and Engineering at the
Hong Kong University of Science and Technology,
Hong Kong, in 2015. He is currently working toward
the PhD degree in the Department of Computer
Science and Engineering at University of Minnesota,
U.S.. His main research interests include the areas of
social computing and human-computer interaction.

Pan HUI has been the Nokia Chair of Data Sci-
ence and a professor of computer science at the
University of Helsinki since September 2017. He
also has been a faculty member of the Department
of Computer Science and Engineering at the Hong
Kong University of Science and Technology since
2013 and an adjunct professor of social computing
and networking at Aalto University Finland since
2012. He was a senior research scientist and then
a Distinguished Scientist for Telekom Innovation
Laboratories (T-labs) Germany from 2008 to 2015.
He also worked for Intel Research Cambridge and Thomson Research Paris
while he was pursuing his PhD at the University of Cambridge. He is an
IEEE Fellow, an associate editor for IEEE Transactions on Mobile Computing
and IEEE Transactions on Cloud Computing, a guest editor for the IEEE
Communication Magazine, and an ACM Distinguished Scientist.

