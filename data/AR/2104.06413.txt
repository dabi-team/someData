1
2
0
2

r
p
A
9
2

]

R
S
.
h
p
-
o
r
t
s
a
[

2
v
3
1
4
6
0
.
4
0
1
2
:
v
i
X
r
a

MNRAS 000, 1â€“18 (2015)

Preprint 3 May 2021

Compiled using MNRAS LATEX style ï¬le v3.0

SpaceHub: A high-performance gravity integration toolkit for few-body
problems in astrophysics

Yi-Han Wang,1â˜… Nathan W. C. Leigh,3,4 Bin Liu,5,6 Rosalba Perna1,2
1Department of Physics and Astronomy, Stony Brook University, Stony Brook, NY, 11794, USA
2Center for Computational Astrophysics, Flatiron Institute, 162 5th Avenue, New York, NY 10010, USA
3Departamento de Astronomia, Facultad de Ciencias Fisicas y Matematicas, Universidad de Concepcion, Concepcion, Chile
4Department of Astrophysics, American Museum of Natural History, Central Park West and 79th Street, New York, NY 10024
5Niels Bohr International Academy, Niels Bohr Institute, Blegdamsvej 17, 2100 Copenhagen, Denmark
6Cornell Center for Astrophysics and Planetary Science, Department of Astronomy, Cornell University, Ithaca, NY 14853, USA

Accepted XXX. Received YYY; in original form ZZZ

ABSTRACT
We present the open source few-body gravity integration toolkit SpaceHub. SpaceHub oï¬€ers a variety of algorithmic methods,
including the unique algorithms AR-Radau, AR-Sym6, AR-ABITS and AR-chain+ which we show out-perform other methods
in the literature and allow for fast, precise and accurate computations to deal with few-body problems ranging from interacting
black holes to planetary dynamics. We show that AR-Sym6 and AR-chain+, with algorithmic regularization, chain algorithm,
active round-oï¬€ error compensation and a symplectic kernel implementation, are the fastest and most accurate algorithms to
treat black hole dynamics with extreme mass ratios, extreme eccentricities and very close encounters. AR-Radau, the ï¬rst
regularized Radau integrator with round oï¬€ error control down to 64 bits ï¬‚oating point machine precision, has the ability to
handle extremely eccentric orbits and close approaches in long-term integrations. AR-ABITS, a bit eï¬ƒcient arbitrary precision
method, achieves any precision with the least CPU cost compared to other open source arbitrary precision few-body codes. With
the implementation of deep numerical and code optimization, these new algorithms in SpaceHub prove superior to other popular
high precision few-body codes in terms of performance, accuracy and speed.

Key words: gravitation â€“ methods: numerical â€“ stars: black holes â€“ stars: kinematics and dynamics â€“ planetary systems

1 INTRODUCTION

Few-body gravity integrators are fundamental to the study of black
hole and planetary dynamics. The resulting simulations capture the
time evolution of the orbital dynamics, evolving the system forward
in time due to pair-wise gravitational interactions. One of the primary
challenges these integrators face is accurately capturing the integra-
tion of eccentric orbits and close approaches between particles. This
is because the integrations require extreme accuracy and precision in
the vicinity of the singularity, where the distance ğ‘Ÿ between particles
becomes very small, which is made challenging due to the 1/ğ‘Ÿ2 scal-
ing characteristic of the Newtonian gravitational acceleration. The
most obvious solution is to choose a very small time step ğ‘Ÿ â†’ 0, but
this can be very time consuming computationally.

The introduction of regularization techniques to handle the com-
putations in the vicinity of the singularity revolutionized the ï¬eld
of gravitational dynamics. This stimulated the development of a
number of mathematical transformations that can be implemented
to improve accuracy and precision. One prominent example in-
cludes Kustaanheimo-Stiefel (KS) regularization and applying the
KS transformation to the perturbed two-body problem. Aarseth &
Zare (1974); Heggie (1974); Zare (1974) then introduced this trans-

â˜… E-mail: yihan.wang.1@stonybrook.edu

Â© 2015 The Authors

formation into general N-body problems, and Levison & Duncan
(1994) applied it to planetary dynamics. Later on, new Logarithmic
Hamiltonian regularization with a leapfrog scheme was invented by
Mikkola & Tanikawa (1999a,b) and Preto & Tremaine (1999). This
method can accurately and eï¬ƒciently capture the dynamics in the
vicinity of the singularity using a regularized equation of motion,
but the method becomes invalid in the limit of extremely large mass
ratios. To overcome this challenge, Mikkola & Aarseth (2002) in-
troduced the time-transformed leapfrog scheme, which allows for
an arbitrary regularization mass coeï¬ƒcient function to deal with
extreme mass ratios during close approaches.

All regularized methods that include the algorithmic regularization
introduced by Mikkola & Merritt (2008) are based on the leapfrog
scheme, since it can maintain the symplectic nature of the system
when adaptive stepping is not implemented. Because the method is
symplectic, it adheres to Hamiltonâ€™s equations and time-reversibility
is preserved. However, the leapfrog method is only a second order
method, and going to higher orders can greatly improve accuracy and
precision. Consequently, the rational Bulirsch-Stoer(BS) extrapola-
tion (Gragg 1965; Press et al. 1986) was introduced into the regular-
ization method. This extrapolation method can eï¬ƒciently construct
higher order methods that adhere to the leapfrog scheme. With the
BS extrapolation and regularization techniques now developed, ef-
ï¬cient high precision integrations can be performed that accurately

 
 
 
 
 
 
2 Wang et al.

treat extremely eccentric orbits and very close pair-wise particle ap-
proaches. These problems correspond to prompt events, which may
or may not occur repeatedly. But what if long term integrations are
required, where such close pair-wise approaches do occur regularly?
Indeed, the computations become more challenging as longer time
scale integrations are needed. Examples include extremely eccentric
systems that require integrating over many orbits, such as the grav-
itational wave-induced inspiral of eccentric binaries down to the
kilo-Hertz level, high eccentricity tidal dissipation, and so on. The
reason problems arise is because, for integration methods based on
extrapolation, the higher order extrapolation reduces the truncation
error but the round oï¬€ error becomes signiï¬cant due to the ï¬nite bit
ï¬‚oating-point number arithmetic. The resulting large round oï¬€ errors
can severely reduce the precision and destroy the long term perfor-
mance of high precision methods. Therefore, reducing and properly
managing round oï¬€ errors is essential in high precision integration
methods.

For systems where extreme approaches between particles arise,
the close value subtraction of the ï¬‚oating-point numbers that de-
ï¬ne the positions of the particles causes several signiï¬cant digits
to be lost. This introduces round oï¬€ errors into the integrations. To
solve this problem, a chain coordinate system (Mikkola & Aarseth
1993) was invented to evaluate the relative distances during close
encounters. With this, the relative distances between particles are
directly replaced by the chain coordinates, thus avoiding the close
value subtraction. However, the chain coordinates need to be recon-
structed and updated after each time step. The problem that arises
here is that frequent chain coordinate updates involve large quanti-
ties of ï¬‚oating-point arithmetic and introduces extra round oï¬€ errors
into long term integrations. Branched tree coordinates are more opti-
mized for maintaining the shortest relative position between particles
and can alleviate this problem. Rantala et al. (2020) implemented the
minimum spanning tree in their AR-Chain based code MSTAR, and
showed that branched tree coordinates are more eï¬ƒcient, with less
round oï¬€ error accumulation than chain coordinates in the large-N
(âˆ¼ 400) regime.

Close value subtractions are not the only source of round oï¬€ er-
rors that can aï¬€ect long term integration performance. In BS-based
methods, round oï¬€ errors propagate and can be magniï¬ed through the
extrapolation table. With higher order extrapolations, the round oï¬€
errors become more signiï¬cant. Theoretically, the BS extrapolation
can achieve arbitrarily high order, but it can only achieve 14-16th
order for double precision ï¬‚oating-point numbers. Consequently,
even if the BS extrapolation is very eï¬ƒcient in achieving higher or-
der symplectic methods such as the leapfrog scheme, the precision
is limited by the extrapolation. More importantly, the extrapolation
process is not time symmetric, which breaks the symplectic nature of
the system even if ï¬xed time steps are adopted. Therefore, alternative
methods are needed to achieve higher order results and maintain time
symmetry.

For long term integrations, where many time steps are needed,
another source of round oï¬€ error becomes non-negligible. During
the integration, small incremental steps can be used to better evolve
speciï¬cally physical quantities in each step. But this can introduce
large diï¬€erence additions between ï¬‚oating-point numbers, which will
in turn introduce signiï¬cant round oï¬€ errors into the integration due
to the ï¬nite bit truncation. This kind of round oï¬€ error accumulates
continuously over the course of the integration. To alleviate this prob-
lem, Quinn & Tremaine (1990) proposed an active round oï¬€ error
compensation method in ï¬‚oating-point number arithmetic. This was
introduced into the Gauss-Radau (Everhart 1985) scheme by Rein
& Spiegel (2014), which proved useful in slowing down the round

MNRAS 000, 1â€“18 (2015)

oï¬€ error accumulation in long term integrations. However, the raw
Gauss-Radau method is cumbersome in dealing with extreme eccen-
tricities and very close pair-wise encounters, causing the integrations
to lose signiï¬cant precision for these speciï¬c problems.

In this paper, we present a new few-body gravity integration
toolkit called SpaceHub. It contains various previously developed
algorithms in addition to several new and novel techniques which
improve the speed, accuracy and precision of the calculations even
further. This includes state-of-the-art algorithms that can eï¬ƒciently
deal with both extreme eccentricities and extreme mass ratios even
for long term integrations. Problems which have already been inves-
tigated using this code include interactions between compact object
binaries and supermassive black hole binaries (Wang et al. 2018,
2019a,b; Liu et al. 2019a,b), formation of black hole binaries in
dense star clusters (Perna et al. 2019), interactions between stars and
planetary systems (Wang et al. 2020b,a,c).

The paper is organized as follows. In Section 2, we introduce
and brieï¬‚y review several previously developed few body integration
techniques, including the regularization algorithm, the chain algo-
rithm, active error compensation and the Bulirsch-Stoer extrapola-
tion. We explicitly highlight our improvements to those techniques,
and introduce three new methods in SpaceHub to accomplish this
goal. In Section 3, we discuss how SpaceHub can easily construct
new algorithms and our optimization implementations to improve
performance. In section 4, we present various tests of our newly
developed algorithms in SpaceHub, and compare to other popular
high precision few body codes. We summarize our main results and
present our conclusions in Section 5.

2 REVIEW OF HIGH PRECISION FEW-BODY

INTEGRATION METHODS

There are several integration methods, including AR-Chain, IAS15
and Brutus, that can achieve very high precision with low relative
energy errors. In this section we will review these integration schemes
and point out any shortcomings of the integration methods. This will
help provide a broader context to then present the improvements
made by SpaceHub which will be discussed in Sec. 3.

2.1 AR-chain

For the N-body problem in the small-N regime, stochastic close pair-
wise approaches and high eccentricity orbits in collisional systems
can signiï¬cantly hurt the integration accuracy. Due to the strong inter-
action around the closest approach, very small time steps are required
to properly resolve the dynamics in the vicinity of the singularity in
conventional step control methods. But increasing the number of
time steps severely slows down the integration and, especially for
longer term integrations, more ï¬‚oating point arithmetic introduces
more round oï¬€ errors. In the past few decades, several methods have
been invented to tackle this problem, including KS regularization,
the Logarithmic Hamiltonian method (LogH) (Mikkola & Tanikawa
1999a,b; Preto & Tremaine 1999), the time-transformed leapfrog
(TTL) regularization scheme(Mikkola & Aarseth 2002) and general-
ized midpoint regularization (GAR)(Stetter 1968). By transforming
the equations of motion, the combination of all of these regulariza-
tion methods can eï¬ƒciently resolve close pair-wise approaches and
high eccentricity orbits. Mikkola & Merritt (2008) gathered all the
three regularization schemes (LogH, TTL and GAR) to form the Al-
gorithmic Regularization scheme in his AR-chain algorithm to deal
with velocity-dependent problems for extreme eccentricity cases and

close pair-wise approaches between particles. Here we brieï¬‚y review
the regularization methods implemented in AR-chain.

independent variables ğœ” and Î© to perform the require transformations
in the equations of motion,

Few-body toolkit SpaceHub

3

2.1.1 LogH regularization

For systems with equations of motion for each particle,
ğ‘‘xğ‘–
ğ‘‘ğ‘¡
ğ‘‘vğ‘–
ğ‘‘ğ‘¡

= gğ‘– + fğ‘–

= vğ‘–

(1)

(2)

where xğ‘–, vğ‘–, gğ‘– and fğ‘– are, respectively, the position, velocity, Newto-
nian acceleration and other accelerations in addition to the Newtonian
one acting on particle ğ‘–. The LogH regularization scheme introduces
additional quantities, namely ğ‘‡, ğ‘ˆ and ğµ, to transform the equations
of motion during the integration. Here, ğ‘‡ is the total kinetic energy
of the system, ğ‘ˆ is the absolute value of the total Newtonian potential
energy of the system and ğµ is the binding energy of the system,

ğ‘‡

=

ğ‘ˆ =

âˆ‘ï¸

ğ‘–
âˆ‘ï¸

ğ‘–< ğ‘—

1
2

ğ‘šğ‘–v2
ğ‘– ,

ğ‘šğ‘–ğ‘š ğ‘—
|xğ‘– âˆ’ x ğ‘— |

,

ğµ = ğ‘ˆ âˆ’ ğ‘‡ .

(3)

(4)

(5)

Thus, the regularized algorithm can be described in the time-
symmetric leap-frog form as follows

D(â„):

K(â„):

ğ‘‡

=

âˆ‘ï¸

ğ‘šğ‘–v2
ğ‘–

1
2
ğ‘–
â„/(ğ‘‡ + ğµ)

=

ğ‘‘ğ‘¡
ğ‘¡ â†’ ğ‘¡ + ğ‘‘ğ‘¡
xğ‘– â†’ xğ‘– + vğ‘– ğ‘‘ğ‘¡

ğ‘ˆ =

âˆ‘ï¸

ğ‘šğ‘–ğ‘š ğ‘—
|xğ‘– âˆ’ x ğ‘— |

ğ‘‘ğ‘¡

=

ğ‘–< ğ‘—
â„/ğ‘ˆ

ğµ â†’ ğµ âˆ’

ğ‘‘ğ‘¡

2

âˆ‘ï¸

ğ‘–

ğ‘šğ‘–vğ‘– Â· fğ‘–

vğ‘– â†’ vğ‘– + (gğ‘– + fğ‘–)ğ‘‘ğ‘¡

ğµ â†’ ğµ âˆ’

ğ‘‘ğ‘¡

2

âˆ‘ï¸

ğ‘–

ğ‘šğ‘–vğ‘– Â· fğ‘–

(6)

(7)

(8)

(9)

(10)

(11)

(12)

(13)

(14)

Then, a complete one step integration can be constructed as
D(â„/2)K(â„)D(â„/2) or K(â„/2)D(â„)K(â„/2), where â„ is the time
step.

2.1.2 TTL regularization

For systems with extreme particle mass ratios, the regularization
ğ‘šğ‘– ğ‘š ğ‘—
function ğ‘ˆ = (cid:205)ğ‘–< ğ‘—
|xğ‘–âˆ’x ğ‘— | and ğ‘‡ + ğµ in the LogH method can end up
being dominated by the most massive pair of particles in the system.
Therefore, even if close encounters between extreme mass ratio pairs
occur during the integration, it can happen that the step size is not
being properly regularized.

In order to compensate for this, instead of using ğ‘ˆ and ğ‘‡ + ğµ as
the regularization functions, Mikkola & Aarseth (2002) proposed two

Î© =

ğ‘‘ğœ”
ğ‘‘ğ‘¡

=

âˆ‘ï¸

ğ‘–< ğ‘—

âˆ‘ï¸

ğ‘–

Î©ğ‘– ğ‘—
|xğ‘– âˆ’ x ğ‘— |

ğœ•Î©
ğœ•xğ‘–

Â· vğ‘–, ğœ”(0) = Î©(0) ,

(15)

(16)

where Î©ğ‘– ğ‘— is a function of the particle masses. Conventionally, Î©ğ‘– ğ‘— =
ğ‘šğ‘–ğ‘š ğ‘— can be adopted, which is mathematically equivalent to the
LogH method. However, alternative choices can be made, such as
the mass averaged function,

Î©ğ‘– ğ‘—

=

(cid:26) Ëœğ‘š2
0

if ğ‘šğ‘–ğ‘š ğ‘— < ğœ– Ëœğ‘š2
otherwise .

(17)

With this kind of regularization function, the contribution from small
mass pairs becomes more dominant in the regularization function
such that close encounters between low-mass particles can be cor-
rectly captured. Here, Ëœğ‘š2 = (cid:205)ğ‘–< ğ‘— 2ğ‘šğ‘–ğ‘š ğ‘— /(ğ‘ (ğ‘ âˆ’ 1)) is the mean
mass of the system with N particles and ğœ– is a parameter to set the
threshold where only particle pairs with mass products small enough
can contribute to the regularization function. In this way, large mass
pairs do not contribute to the regularization; hence the contribution
of the small mass pairs in the regularization function will not be
overwhelmed due to the contribution from large mass pairs. Mikkola
& Aarseth (2002) suggested the value of ğœ– to be 10âˆ’3 in order to
correctly capture the small mass pair interactions.

The leap-frog scheme with TTL regularization can be written in

form of D(â„):

=

ğ‘‘ğ‘¡
â„/ğœ”
ğ‘¡ â†’ ğ‘¡ + ğ‘‘ğ‘¡
xğ‘– â†’ xğ‘– + vğ‘– ğ‘‘ğ‘¡

K(â„):

Î© =

ğ‘‘ğ‘¡

=

Î©ğ‘– ğ‘—
|xğ‘– âˆ’ x ğ‘— |

âˆ‘ï¸

ğ‘–< ğ‘—
â„/Î©

2

ğ‘‘ğ‘¡

âˆ‘ï¸

ğœ” â†’ ğœ” +

ğœ•Î©
ğœ•xğ‘–
vğ‘– â†’ vğ‘– + (gğ‘– + fğ‘–)ğ‘‘ğ‘¡
ğœ•Î©
ğœ•xğ‘–

ğœ” â†’ ğœ” +

âˆ‘ï¸

ğ‘‘ğ‘¡

2

ğ‘–

ğ‘–

(18)

(19)

(20)

(21)

(22)

(23)

(24)

(25)

Â· vğ‘–

Â· vğ‘–

with ğœ”(0) = Î©(0).

2.1.3 Generalized midpoint method

To construct a leapfrog scheme, the variables on the right side of the
equations of motion should be independent of the variables on the
left side. However, if the external acceleration fğ‘– is velocity depen-
dent, then the kick step becomes problematic. In this case, vğ‘– needs
implicit iteration on both sides of the equation which breaks the time
symmetry of the leapfrog scheme,

vğ‘– â†’ vğ‘– + (gğ‘– + fğ‘– (vğ‘–, ...))ğ‘‘ğ‘¡ .

(26)

In order to preserve the time symmetry of the leapfrog scheme, Stetter
(1968); Mikkola & Aarseth (2002) introduced the pseudo-velocity wğ‘–
in the kick-step procedure in order to to maintain the time symmetry.

MNRAS 000, 1â€“18 (2015)

4 Wang et al.

For systems with equations of motion of the form

ğ‘‘xğ‘–
ğ‘‘ğ‘¡
ğ‘‘vğ‘–
ğ‘‘ğ‘¡

= vğ‘–

= gğ‘– + fğ‘– (x) + fğ‘–,ğ‘£ (x, v)

(27)

(28)

where fğ‘– (x) is the external velocity-independent acceleration and
fğ‘–,ğ‘£ (x, v) are the external velocity-dependent accelerations,
the
leapfrog scheme can be constructed in the following way for the
LogH method,

D(â„):

K(â„):

ğ‘‡

=

âˆ‘ï¸

ğ‘šğ‘–v2
ğ‘–

1
2
ğ‘–
â„/(ğ‘‡ + ğµ)

=

ğ‘‘ğ‘¡
ğ‘¡ â†’ ğ‘¡ + ğ‘‘ğ‘¡
xğ‘– â†’ xğ‘– + vğ‘– ğ‘‘ğ‘¡

ğ‘šğ‘–ğ‘š ğ‘—
|xğ‘– âˆ’ x ğ‘— |

ğ‘ˆ =

âˆ‘ï¸

ğ‘–< ğ‘—
ğ‘‘ğ‘¡ = â„/ğ‘ˆ

Kğ‘£ (ğ‘‘ğ‘¡/2):

vğ‘– â†’ vğ‘– + (gğ‘– + fğ‘– + fğ‘–,ğ‘£ (x, w))

ğ‘‘ğ‘¡

2

Kğ‘¤ (ğ‘‘ğ‘¡):

wğ‘– â†’ wğ‘– + (gğ‘– + fğ‘– + fğ‘–,ğ‘£ (x, v))ğ‘‘ğ‘¡
ğµ â†’ ğµ âˆ’ ğ‘‘ğ‘¡ âˆ‘ï¸
ğ‘–

ğ‘šğ‘–vğ‘– Â· (fğ‘– + fğ‘–,ğ‘£ (x, v))

Kğ‘£ (ğ‘‘ğ‘¡/2):

vğ‘– â†’ vğ‘– + (gğ‘– + fğ‘– + fğ‘–,ğ‘£ (x, w))

ğ‘‘ğ‘¡

2

(29)

(30)

(31)

(32)

(33)

(34)

(35)

(36)

(37)

(38)

that

Note

wğ‘– (0)=vğ‘– (0).
step
with
Kv (ğ‘‘ğ‘¡/2)Kw (ğ‘‘ğ‘¡)Kv (ğ‘‘ğ‘¡/2)
as
can
Kw (ğ‘‘ğ‘¡/2)Kv (ğ‘‘ğ‘¡)Kw (ğ‘‘ğ‘¡/2). The same scheme can also be
obtained for the TTL method with external velocity-dependent
accelerations.

sub-leapfrog

constructed

also

the

be

2.1.4 Chain coordinates

The AR-chain method was invented to deal with close encounters
and extremely eccentricity orbits, thus the relative positions between
particles in the integrated system can be very small. To evaluate the
acceleration between close particles, the relative position between
two close particles is needed. This calculation requires a close value
subtraction arithmetic between two ï¬‚oating-point numbers, which
can cause fast round oï¬€ error accumulation. To solve this problem
Mikkola & Aarseth (1990); Mikkola & Aarseth (1993) introduced the
chain coordinates into the few-body integration, where the relative
positions between particles are calculated from the initial conditions
and converted to chain coordinates. Instead of evolving the original
Cartesian coordinates, the relative positions (i.e., chain coordinates)
will be evolved. Since the chain coordinates are constructed in a way
that the shortest few relative positions are always kept in the chain, the
close value subtraction between close positions can be replaced by the
chain coordinates directly. This coordinate transformation can reduce
the round oï¬€ errors from close value subtractions between ï¬‚oating-
point numbers, thus giving better error control in the integration. The

MNRAS 000, 1â€“18 (2015)

ğ‘‡11

(cid:45)
ğ‘‡21 â† ğ‘‡22
(cid:45)

(cid:45)

ğ‘‡31 â† ğ‘‡32 â† ğ‘‡33

(cid:45)

(cid:45)
ğ‘‡41 â† ğ‘‡42 â† ğ‘‡43 â† ğ‘‡44
...
...

(cid:45)

...

...

Table 1. Gragg-Bulirsch-Stoer extrapolation table.

transformation from Cartesian coordinates to chain coordinates can
be written as

Xğ‘˜ = xğ‘–ğ‘˜+1 âˆ’ xğ‘–ğ‘˜
Vğ‘˜ = vğ‘–ğ‘˜+1 âˆ’ vğ‘–ğ‘˜

(39)

(40)

with ğ‘˜ = 1, 2, ..., ğ‘ âˆ’ 1 and ğ‘– is the index of the Cartesian coordinates
in chain coordinates. Then the inverse transformation can be written
as

Ëœxğ‘–1
Ëœxğ‘–ğ‘˜+1
Ëœvğ‘–1
Ëœvğ‘–ğ‘˜+1

= 0

=

Ëœxğ‘–ğ‘˜ + Xğ‘˜

= 0

=

Ëœvğ‘–ğ‘˜ + Vğ‘˜

followed by a reduction to the centre of mass reference frame

Ëœxcm =

Ëœvcm =

x ğ‘—

v ğ‘—

=

=

ğ‘š ğ‘—

ğ‘š ğ‘—

âˆ‘ï¸

ğ‘—
âˆ‘ï¸

ğ‘—

âˆ‘ï¸

ğ‘—
âˆ‘ï¸

ğ‘š ğ‘— Ëœx ğ‘— /

ğ‘š ğ‘— Ëœv ğ‘— /

ğ‘—
Ëœx ğ‘— âˆ’ Ëœxcm
Ëœv ğ‘— âˆ’ Ëœvcm.

The equations of motion of the chain coordinates are then

ğ‘‘Xğ‘˜
ğ‘‘ğ‘¡
ğ‘‘Vğ‘˜
ğ‘‘ğ‘¡

= Vğ‘˜ ,

ğ‘˜ = 1, 2, ..., ğ‘ âˆ’ 1

= gğ‘–ğ‘˜+1 âˆ’ gğ‘–ğ‘˜ + fğ‘–ğ‘˜+1 âˆ’ fğ‘–ğ‘˜ + fğ‘–ğ‘˜+1,ğ‘£ âˆ’ fğ‘–ğ‘˜ ,ğ‘£ .

(41)

(42)

(43)

(44)

(45)

(46)

(47)

(48)

(49)

(50)

With the new equations of motion, every position subtraction r ğ‘— ğ‘˜
between x ğ‘— and xğ‘˜ (where ğ‘— and ğ‘˜ are the chain coordinates indices)
is

r ğ‘— ğ‘˜ =

Â±(xğ‘˜ âˆ’ x ğ‘— )
Â±X ğ‘—
Â±(X ğ‘— + X ğ‘—+1)

ï£±ï£´ï£´ï£²
ï£´ï£´
ï£³

if ğ‘˜ > ğ‘— Â± 2 (far pair)
if ğ‘˜ = ğ‘— Â± 1 (close pair)
if ğ‘˜ = ğ‘— Â± 2 (intermediate pair) .

(51)

2.1.5 Gragg-Bulirsch-Stoer extrapolation

The algorithmic regularization and chain coordinates can be con-
structed in the form of the leapfrog scheme. However, by itself, the
leapfrog method is only a two order method. This makes it ineï¬ƒ-
cient in achieving high precision. To tackle this problem and achieve
high precision, higher order methods are usually needed. The Gragg-
Bulirsch-Stoer extrapolation (Gragg 1965; Bulirsch & Stoer 1966;
Press et al. 1986) can construct higher order results from a series of
lower order results through an extrapolation table: For integrations
with macro step ğ», the ï¬rst column of Table 1 will be ï¬lled with ba-
sic lower order methods with ğ‘›ğ‘– sub-steps â„ğ‘›ğ‘– = ğ»/ğ‘›ğ‘–. Then higher

order results can be constructed recursively by extrapolation,

ğ‘‡ğ‘–, ğ‘— = ğ‘‡ğ‘–, ğ‘—âˆ’1 +

ğ‘‡ğ‘–, ğ‘—âˆ’1 âˆ’ ğ‘‡ğ‘–âˆ’1, ğ‘—âˆ’1
(ğ‘›ğ‘–/ğ‘›ğ‘–âˆ’ ğ‘—+1)2 âˆ’ 1

.

(52)

If the basic lower order method (such as the leapfrog scheme) is only
in even powers of the time-step, the ï¬nal extrapolated result ğ‘‡ğ‘˜,ğ‘˜ has
ğ‘ + 2(ğ‘˜ âˆ’ 1)-th order precision, where ğ‘ is the order of the basic
integration method used in the ï¬rst column. If the basic integration
method is non-symmetric in time, then ğ‘‡ğ‘˜,ğ‘˜ has ğ‘ + ğ‘˜ âˆ’ 1-th order
precision. Therefore, GBS extrapolation is eï¬ƒcient in constructing
higher order methods for time symmetric integration schemes like
leapfrog. Since the regularization chain algorithm can be written in
the form of a time-symmetric leapfrog scheme, where all odd powers
of the time-steps vanish, the GBS extrapolation is adopted in the
original AR-chain (Mikkola & Merritt 2008) to achieve higher order
accuracy and precision.

2.2 IAS15

IAS15 (Rebound, Rein & Spiegel 2014) is a Gauss-Radau based in-
tegration method with improvements on step size control and round
oï¬€ error reduction. For few-body problems without high eccentric-
ities and close pair-wise encounters, it performs very well in terms
of maintaining low relative energy errors and minimizing long term
unbiased round oï¬€ error accumulation (Brouwer 1937; Brouwer &
Clemence 2013). In this subsection, we will brieï¬‚y introduce the the
Gauss-Radau method and the main improvements implemented in
IAS15.

2.2.1 Gauss-Radau integration

Everhart (1985) introduced a modiï¬ed 15th order Runge-Kutta
method with Gauss-Radau spacings to achieve very high precision
in few-body problems. This method solves the general equation

ğ‘¦(cid:48)(cid:48) = ğ¹ (ğ‘¦, ğ‘¦(cid:48), ğ‘¡).

(53)

In celestial mechanics, ğ‘¦ denotes the positions of the particles, thus
ğ¹ denotes the accelerations. Everhart (1985) expanded the equation
into a truncated Taylor series,

ğ‘¦(cid:48)(cid:48)|â„ âˆ¼ ğ‘¦(cid:48)(cid:48)

0 + ğ‘1ğ‘¡ + ğ‘2ğ‘¡2 + ... + ğ‘7ğ‘¡7 .

(54)

Using the dimensionless time-step â„ = ğ‘¡/ğ‘‘ğ‘¡ and ğ‘ğ‘– = ğ‘ğ‘–ğ‘¡ğ‘–, the
equation can be rewritten as

ğ¹ = ğ‘¦(cid:48)(cid:48)|â„ =âˆ¼ ğ‘¦(cid:48)(cid:48)

0 + ğ‘1â„ + ğ‘2â„2 + ... + ğ‘7â„7 .

(55)

After ğ‘¦(cid:48)(cid:48) is found at â„1=0, the value of ğ‘ğ‘– can be found recursively at
each time step. This is done by evaluating ğ‘¦(cid:48)(cid:48) at a series of suitably
chosen Gauss-Radau spacings â„1, â„2, ...â„8 within the interval of â„
between 0 and 1. Then, at the end of the macro step h, the accel-
erations ğ‘¦(cid:48)(cid:48) can be approximated by this Taylor series. The corre-
sponding ğ‘¦(cid:48) (velocity) and ğ‘¦ (position) values can thus be calculated
analytically by integrating ğ‘¦(cid:48)(cid:48) over ğ‘‘ğ‘¡,

ğ‘¦(cid:48)|â„ âˆ¼ ğ‘¦(cid:48)

0 + â„ğ‘‘ğ‘¡

(cid:18)

ğ‘¦(cid:48)(cid:48)
0 +

(cid:18)

â„

ğ‘0 +

(cid:18)

2â„
3

(cid:19)(cid:19)(cid:19)

ğ‘1 + ...

(56)

ğ‘¦|â„ âˆ¼ ğ‘¦0 + ğ‘¦(cid:48)
0

â„ğ‘‘ğ‘¡ +

(cid:18)

ğ‘¦(cid:48)(cid:48)
0 +

(cid:18)

â„

3

ğ‘0 +

(cid:18)

â„

2

(cid:19) (cid:19)(cid:19)

.(57)

ğ‘1 + ...

2
â„2ğ‘‘ğ‘¡2

2

Few-body toolkit SpaceHub

5

The ğ‘ğ‘– are evaluated at each step by repeatedly iterating over the
Gauss-Radau spacing â„ğ‘–, where

ğ‘1 = ğ¶71ğ‘”7 + ğ¶61ğ‘”6 + ğ¶51ğ‘”5 + ... + ğ¶11ğ‘”1
ğ‘2 = ğ¶72ğ‘”7 + ğ¶62ğ‘”6 + ... + ğ¶22ğ‘”2
ğ‘3 = ğ¶73ğ‘”7 + ... + ğ¶33ğ‘”3
...
ğ‘7 = ğ¶77ğ‘”7

(58)

(59)

and
ğ‘”1 = (ğ‘¦(cid:48)(cid:48)|â„2 âˆ’ ğ‘¦(cid:48)(cid:48)|â„1 )ğ‘…21
ğ‘”2 = ((ğ‘¦(cid:48)(cid:48)|â„3 âˆ’ ğ‘¦(cid:48)(cid:48)|â„1 )ğ‘…31 âˆ’ ğ‘”1)ğ‘…32
ğ‘”3 = (((ğ‘¦(cid:48)(cid:48)|â„4 âˆ’ ğ‘¦(cid:48)(cid:48)|â„1 )ğ‘…41 âˆ’ ğ‘”1)ğ‘…42 âˆ’ ğ‘”2)ğ‘…43
...
ğ‘”7 = (...(((ğ‘¦(cid:48)(cid:48)|â„8 âˆ’ ğ‘¦(cid:48)(cid:48)|â„1 )ğ‘…81 âˆ’ ğ‘”1)ğ‘…82 âˆ’ ğ‘”2)ğ‘…43... âˆ’ ğ‘”6)ğ‘…87
where ğ¶ğ‘– ğ‘— and ğ‘…ğ‘– ğ‘— are constants that can be calculated from â„ğ‘–.
This expansion of ğ‘¦(cid:48)(cid:48) up to ğ‘¡7 with Gauss-Radau spacing has high
precision, reaching 15th order.

2.2.2 Active round oï¬€ error reduction

For higher order integration methods, the truncation error can be
eï¬ƒciently reduced by shrinking the step size. However, the round
oï¬€ error from the arithmetic of ï¬nite bit ï¬‚oating point numbers
becomes dominant in high precision integration methods. Therefore,
by increasing the order of the integration method or shrinking the
step size we cannot obtain more precise solutions. On the contrary,
shrinking the step size means more ï¬‚oating point arithmetic that will
accumulate more round oï¬€ errors, leading to less accurate solutions.
For ï¬nite bit ï¬‚oating-point numbers with N mantissa bits, the relative
number precision is
eps = 2âˆ’( ğ‘ âˆ’1)

(60)

for double precision ï¬‚oating-point numbers with 53 mantissa bits,
this is âˆ¼ 2.2Ã—10âˆ’16. Thus, for double precision ï¬‚oating-point number
arithmetic, any relative value in the results smaller than eps will be
rounded away.

Other than the round oï¬€ error from close value subtractions dis-
cussed in Section 2.1.4, another arithmetic operations can introduce
large round oï¬€ errors due to large diï¬€erence additions, i.e., adding a
small number to a large number. In large diï¬€erence addition, the re-
sult of the calculation is of the same order as the large number. Hence,
the rounding away aspect operates at the order of epsÃ— |large number|.
Since the absolute value of the small number is much smaller than
the large number, the rounded away part can be a signiï¬cant compo-
nent of the small number. Consequently, the result loses considerable
accuracy.

Indeed, in numerical integrations, these large diï¬€erence additions

are needed in each step as we keeping evolving the variable ğœ‰

ğœ‰ â†’ ğœ‰ +

ğ‘‘ğœ‰
ğ‘‘ğ‘¡

ğ‘‘ğ‘¡

(61)

where

ğ‘‘ ğœ‰
ğ‘‘ğ‘¡ ğ‘‘ğ‘¡ is usually small compared to ğœ‰.

To achieve higher precision, reducing the round oï¬€ error be-
comes essential. Quinn & Tremaine (1990) introduced into celestial
mechanics the active round oï¬€ error reduction invented by Kahan
(1965). Rein & Spiegel (2014) then implemented it in IAS15.

For ï¬‚oating-point number arithmetic, the result of each operation

MNRAS 000, 1â€“18 (2015)

6 Wang et al.

will be rounded adopting a certain round oï¬€ strategy. For example,
consider the result of

ğœ‰ + ğ‘‘ğœ‰ â†’ rnd[ğœ‰ + ğ‘‘ğœ‰]

(62)

where rnd is a certain round oï¬€ strategy. What is interesting is that
the round oï¬€ error cause by rnd can also be estimated under the
ï¬‚oating-point number arithmetic, where

err+ (ğœ‰, ğ‘‘ğœ‰) âˆ¼ rnd[rnd[rnd[ğœ‰ + ğ‘‘ğœ‰] âˆ’ ğœ‰] âˆ’ ğ‘‘ğœ‰]

Although,

err+ (ğœ‰, ğ‘‘ğœ‰) < eps Ã— rnd[ğœ‰ + ğ‘‘ğœ‰]

(63)

(64)

it can be comparable to ğ‘‘ğœ‰. Since in the integration ğ‘‘ğœ‰ at diï¬€erent
ğ‘¡ will be continuously added to the ğœ‰, the round oï¬€ error from the
last step can be compensated in the next step by subtracting the error
from ğ‘‘ğœ‰. A complete active round oï¬€ error compensation process
can be described as

ğœ‰1 = rnd[ğœ‰0 + ğ‘‘ğœ‰0]
err+ (ğœ‰0, ğ‘‘ğœ‰0) = rnd[rnd[ğœ‰1 âˆ’ ğœ‰0] âˆ’ ğ‘‘ğœ‰0]
ğ‘‘ğœ‰1 = rnd[ğ‘‘ğœ‰1 âˆ’ err+ (ğœ‰0, ğ‘‘ğœ‰0)]
ğœ‰2 = rnd[ğœ‰1 + ğ‘‘ğœ‰1]
err+ (ğœ‰1, ğ‘‘ğœ‰1) = rnd[rnd[ğœ‰2 âˆ’ ğœ‰1] âˆ’ ğ‘‘ğœ‰1]
ğ‘‘ğœ‰2 = rnd[ğ‘‘ğœ‰2 âˆ’ err+ (ğœ‰1, ğ‘‘ğœ‰1)]
...

(65)

(66)

(67)

(68)

(69)

(70)

By this means, the round oï¬€ error can be reduced by 1-2 orders of
magnitude. This is essential in high precision integration methods
trying to minimize round oï¬€ errors.

2.3 Arbitrary precision integration

For integration methods with high precision, other than reducing
the round oï¬€ error with limited mantissa bit ï¬‚oating point numbers,
another way to increase the precision of the integration method is to
lower the eps in Equation 60. The most straightforward way to do this
is to increase the mantissa bit number N, i.e. use longer bit ï¬‚oating-
point numbers. In this way, one can achieve any precision by using
longer and longer bit ï¬‚oating-point numbers. However, the length
of the CPU register is limited. Thus, the arithmetic between non-
standard ï¬‚oating point numbers can be extremely slow compared to
the arithmetic between standard ï¬‚oating point numbers.

Since the GBS extrapolation can simply construct arbitrarily
higher orders, using longer bit ï¬‚oating point numbers in this method
can easily achieve arbitrary precision. Brutus (Boekholt & Portegies
Zwart 2015) implemented this method by adopting the arbitrary bit
ï¬‚oating point number.

3 SPACEHUB LIBRARY

In this section, we describe several novel features implemented in
SpaceHub, and quantify how each of these novel algorithms improve
performance, in particular accuracy, precision and speed, relative to
previous methods discussed in the previous section. This is done by
considering the time evolution of two example cases, namely the
earth-moon-sun system and a highly eccentric binary composed of
two solar mass stars with an initial semi-major axis of 1 AU.

MNRAS 000, 1â€“18 (2015)

ğœ–
-ğœ–
ğœ–
-ğœ–
ğœ–
-ğœ–
ğœ–
-ğœ–
...

-1.6ğœ–
2.6ğœ–
-3.6ğœ–
4.6ğœ–
-5.5ğœ–
6.5ğœ–
-7.5ğœ–
...

3.1ğœ–
-5.6ğœ–
9.1ğœ–
-13.6ğœ–
19.1ğœ–
-25.6ğœ–
...

-6.2ğœ–
11.9ğœ–
-21.2ğœ–
35.0ğœ–
-54.3ğœ–
...

12.7ğœ–
-25.3ğœ–
47.7ğœ–
-84.1ğœ–
...

-26.4ğœ–
54.1ğœ–
-105.6ğœ–
...

55.8ğœ–
-116.3ğœ–
...

-119.0ğœ–
...

Table 2. Round oï¬€ error propagation in the Bulirsch-Stoer extrapolation with
step sequence ğ‘›ğ‘– = 2ğ‘–.

ğœ–
-ğœ–
ğœ–
-ğœ–
ğœ–
-ğœ–
ğœ–
-ğœ–
...

-1.7ğœ–
2.6ğœ–
-2.1ğœ–
2.3ğœ–
-2.6ğœ–
3.0ğœ–
-2.7ğœ–
...

3.1ğœ–
-3.0ğœ–
3.0ğœ–
-3.6ğœ–
4.6ğœ–
-4.4ğœ–
...

-3.3ğœ–
3.4ğœ–
-4.1ğœ–
5.4ğœ–
-5.5ğœ–
...

3.5ğœ–
-4.3ğœ–
5.7ğœ–
-5.9ğœ–
...

-4.3ğœ–
5.8ğœ–
-6.1ğœ–
...

5.8ğœ–
-6.2ğœ–
...

-6.2ğœ–
...

Table 3. Round oï¬€ error propagation with optimal step sequence in the BS
extrapolation.

3.1 AR-ABITS: Regularized arbitrary precision algorithm

As with Brutus, using extended mantissa bit ï¬‚oating-point numbers
can reduce the eps in Equation 60. Thus, it can achieve arbitrary
precision by increasing the bit length. However, the round oï¬€ error
will also propagate and accumulate through the extrapolation table in
Table 1. As the order of the GBS extrapolation increases, the round
oï¬€ will accumulate faster and faster. Thus the additional mantissa bits
becomes less and less eï¬ƒcient in increasing the integration accuracy.
Therefore, reducing the round oï¬€ error in GBS extrapolation is also
important in order to achieve the same precision with less mantissa
bits and less CPU time.

3.1.1 Improvement on GBS extrapolation

In the BS extrapolation, higher order methods can be obtained from
lower order methods by extrapolation, as described in Equation 52.
However, the round oï¬€ error will also propagate and accumulate
through the extrapolation table. If the round oï¬€ error from the base
integration method is ğœ–, âˆ’ğœ–, ğœ–, ... in the ï¬rst column, then the round
oï¬€ error propagation with the extensively used step sequence ğ‘›ğ‘– =
2ğ‘– suggested by Deuï¬‚hard (1983) will behave as in Table 2. As
shown in the table, ğ‘‡8,8 with 16th order precision magniï¬ed the
round oï¬€ error to become 100 times larger. Thus, we will lose at
least 2 signiï¬cant digits from the extrapolation. This becomes more
problematic for higher order extrapolations, as required by arbitrary
precision integration methods with extremely low tolerance.

To reduce the round oï¬€ error in the extrapolation process,
there are two ï¬ne-tunings that can be performed on the extrap-
olations. The ï¬rst is a step sequence choice. The step sequences
ğ‘›ğ‘– = 1, 2, 3, 5, 8, 12, 17, 25, 36, 51, 73, ...(Fukushima 1996) is better
than the extensively used sequence ğ‘›ğ‘– = 2ğ‘–, where the extrapolation
coeï¬ƒcient reduces the round-oï¬€ error propagation. Table 3 shows
the error propagation with the new step sequence. We see that it per-
forms much better than the original sequence suggested by Deuï¬‚hard
(1983).

The second method to reduce the round oï¬€ error in the extrapola-

tion process is to extrapolate the raw increment ğ‘‘ğœ‰ of the integration
instead of the integrated result ğœ‰. Since the GBS extrapolation is
linear, it is possible to do the following
Î”ğ‘‡ğ‘–, ğ‘—âˆ’1 âˆ’ Î”ğ‘‡ğ‘–âˆ’1, ğ‘—âˆ’1
(ğ‘›ğ‘–/ğ‘›ğ‘–âˆ’ ğ‘—+1)2 âˆ’ 1

Î”ğ‘‡ğ‘–, ğ‘— = Î”ğ‘‡ğ‘–, ğ‘—âˆ’1 +

(71)

.

Because the raw increment ğ‘‘ğœ‰ is usually tiny compared to the in-
tegrated results, the round of error in the ï¬rst column of Table 1
is âˆ¼ eps Ã— |ğ‘‘ğœ‰ | instead of âˆ¼ eps Ã— |ğœ‰ |. Then, the round oï¬€ error
accumulated from the extrapolation table will be smaller than the
error accumulated from the direct extrapolation. We note, however,
that the initial Î”ğ‘‡ğ‘–,1 should be the raw increment evaluated from the
basic integrator, not from the subtraction of ğ‘‡ğ‘–,1 (ğ») âˆ’ ğ‘‡ğ‘–,1 (0). The
close value subtraction will introduce additional round oï¬€ errors and
will signiï¬cantly degrade the advantage of this method.

3.1.2 Algorithmic regularization in arbitrary precision integrations

The GBS standalone is not eï¬ƒcient in solving extremely eccentric
orbits and very close pair-wise encounters. Thus, in SpaceHub we
implement the algorithmic regularized arbitrary precision method
AR-ABITS to deal with extremely eccentric orbits and very close
encounters with arbitrary precision.

We ï¬nd that the ï¬ne-tuned regularized GBS extrapolation works
eï¬ƒciently for arbitrary bits ï¬‚oating-point numbers. The upper panel
of Figure 1 shows the relative energy error as a function of the
relative tolerance ğœ‚ for the GBS method in Brutus and the AR-
ABITS method in SpaceHub. The integration is performed on a sun-
earth-moon system for 100 moon orbits. For a relative tolerance ğœ‚,
ğ‘ = 4 Ã— [log10 (ğœ‚)]ï¬‚oor + 32 mantissa bits for ï¬‚oating-point numbers
will be used as suggested by Brutus. We can see from the upper
panel that, for the same ï¬‚oating-point number bits and tolerance ğœ‚, the
BS extrapolation in SpaceHub can achieve 1-2 orders of magnitude
higher precision than Brutus. With our regularization improvements
and our special treatment for reducing round-oï¬€ errors, we achieve
even better precision in AR-ABITS. This trend becomes even more
signiï¬cant for low ğœ‚, as round oï¬€ errors become more problematic
in higher order extrapolations.

The bottom panel of Figure 1 shows the error scaling of Brutus
and AR-BITS. With the same choice of mantissa bits, we see that
for a non-eccentric sun-earth-moon system, AR-BITS (green solid
line) achieves the same precision but with a CPU time several times
faster than in Brutus (orange solid line). For eccentric systems with
e=0.9999, AR-BITS (blue dotted line) achieves the same precision
but with a CPU time one to two orders of magnitude faster than with
Brutus (red dotted line). To conclude, we ï¬nd that AR-BITS is much
more bit/time eï¬ƒcient in both eccentric and circular systems.

Our improvement on the GBS extrapolation can be applied to any
algorithm based on GBS extrapolation, and is ideal for integrations
requiring high precision with lower round oï¬€ errors.

3.2 AR-chain+: Improved AR-chain

In the following, we will describe the improvements of AR-chain+
which make it superior to AR-chain.

3.2.1 Improvement on the chain coordinate transformation

In the original chain coordinates transformation, for system with N
Cartesian coordinates, the transformed chain coordinates has N-1

Few-body toolkit SpaceHub

7

Figure 1. Arbitrary precision methods in SpaceHub and Brutus. Upper
panel: Root mean square relative error as a function of the relative integration
tolerance for integrations of the sun-earth-moon system for 100 moon orbits.
Bottom panel: Root mean square relative error as a function of CPU time
for integration of the sun-earth-moon system for 100 moon orbits (solid
line), and for the integration of 100 orbits of an eccentric sun-earth two
body system with e=0.9999 (dashed line). The mantissa bit is chosen from
4 Ã— [log10 ( ğœ‚) ]ï¬‚oor + 32 as suggested by Brutus.

1
2

ğ‘šğ‘–v2

coordinates as described in Equation 49. In the inverse transforma-
tion, the centre of mass reduction is necessary when calculating the
kinetic energy ğ‘‡ = (cid:205)ğ‘–
ğ‘– , which is required by the regulariza-
tion method. For direct summation N-body integration in the large-N
regime, most of the CPU time is used to evaluate the acceleration,
since the cost of acceleration evaluation scales with ğ‘‚(N2). Thus,
the cost of centre of mass reduction that scales with ğ‘‚(N) is negligi-
ble. However, in the small-N regime, the cost of the centre of mass
reduction can be signiï¬cant.
Unlike the original

transformation between (x1, ..., xğ‘ ) â†”
(X1, ..., Xğ‘ âˆ’1), we propose a new modiï¬ed transformation such that
the centre of mass reduction can be eliminated. Indeed, a bÄ³ective
mapping between (x1, ..., xğ‘ ) â†” (X1, ..., Xğ‘ ) can be constructed,
where

Xğ‘˜

Xğ‘

Vğ‘˜

Vğ‘

= xğ‘–ğ‘˜+1 âˆ’ xğ‘–ğ‘˜
= xğ‘–1
= vğ‘–ğ‘˜+1 âˆ’ vğ‘–ğ‘˜
= vğ‘–1

ğ‘˜ = 1, 2, ..., ğ‘ âˆ’ 1

ğ‘˜ = 1, 2, ..., ğ‘ âˆ’ 1

(72)

(73)

(74)

(75)

MNRAS 000, 1â€“18 (2015)

10281024102010161012tolerance 103510311027102310191015RMS E/EAR-ABITS(SpaceHub)BS(Brutus)100101102CPU time [s]10341029102410191014109RMS E/EAR-ABITSBrutusAR-ABITS(ecc)Brutus(ecc)8 Wang et al.

Figure 2. The CPU time of the improved chain transformation ğ‘‡new versus
the old chain transformation as a function of the particle number N.

and

xğ‘–1
xğ‘–ğ‘˜+1
vğ‘–1
vğ‘–ğ‘˜+1

= Xğ‘
= xğ‘˜ + Xğ‘˜

= Vğ‘
= vğ‘˜ + Vğ‘˜

ğ‘˜ = 1, 2, ..., ğ‘ âˆ’ 1

ğ‘˜ = 1, 2, ..., ğ‘ âˆ’ 1

with equations of motion

ğ‘‘Xğ‘˜
ğ‘‘ğ‘¡
ğ‘‘Vğ‘˜
ğ‘‘ğ‘¡

ğ‘˜
ğ‘‘Vğ‘
ğ‘‘ğ‘¡

= Vğ‘˜ ,

ğ‘˜ = 1, 2, ..., ğ‘

= gğ‘–ğ‘˜+1 âˆ’ gğ‘–ğ‘˜ + fğ‘–ğ‘˜+1 âˆ’ fğ‘–ğ‘˜ + fğ‘–ğ‘˜+1,ğ‘£ âˆ’ fğ‘–ğ‘˜ ,ğ‘£
= 1, 2, ..., ğ‘ âˆ’ 1

= gğ‘–1 + fğ‘–1 + fğ‘–1,ğ‘£ .

(76)

(77)

(78)

(79)

(80)

(81)

(82)

(83)

This transformation preserves the centre of mass reduction without
the need for any additional acceleration evaluation.

Figure 2 shows the relative CPU time cost of this new transfor-
mation compared to the old transformation, as a function of the
particle number N. In the small-N regime, the new transformation
that eliminates the centre of mass reduction can save signiï¬cantly on
computational run time. In the large N-regime, since the acceleration
evaluation takes up most of the CPU time, the two transformations
are almost identical in CPU cost.

3.2.2 Introducing the active round oï¬€ error compensation into

AR-chain

Other than the round oï¬€ error reduction in GBS extrapolation, the
active round oï¬€ error reduction can also be used in the AR-chain
algorithm.

Instead of implementing the active compensation process dur-
ing a certain step of the algorithm as described in Equation 65
and avoid writing the compensation procedure everywhere, we im-
plement several new ï¬‚oating point number types that execute the
active compensation automatically. Speciï¬cally, three additional
ï¬‚oating-point number types in both 32 and 64 bit, namely Kahan
number(ï¬‚oat_k, double_k), Neumaier number(ï¬‚oat_p, double_p)
and Klein number(ï¬‚oat_e, double_e), with diï¬€erent active error com-
pensation strategies are implemented in SpaceHub as base ï¬‚oating
point number types. In those ï¬‚oating-point number types, the opera-
tor â€™+=â€™ can automatically perform the active compensation process.

MNRAS 000, 1â€“18 (2015)

Figure 3. Integration on the sun-earth-moon system with 1000 moon orbits.
5000 equal spaced relative energy error during the 1000 orbits are outputted
to calculate the root mean square relative energy error. This ï¬gure shows
the rms relative energy error as a function of the relative tolerance ğœ‚ for
Mikkolaâ€™s AR-chain, AR-chain in SpaceHub and AR-Chain+.

Therefore, any algorithm in SpaceHub taking these ï¬‚oating point
data types can directly activate the active round oï¬€ error compensa-
tion. The cost for this implementation is a higher cache latency and
double sized memory to save the error from last addition. However,
in the small-N regime, these costs are not signiï¬cant.

Usually, the active round oï¬€ error compensation can reduce the
round oï¬€ error by 1-2 order of magnitude. However, we found that
in AR-chain, the eï¬€ect is signiï¬cantly degraded by the chain coordi-
nates. After each step, to make sure that the shortest relative position
is kept in the chain coordinates, the chain coordinates may need
to be updated. Once the chain coordinates update is required, then
the chain coordinates ğ‘‹ğ‘˜,new need to be reconstructed from ğ‘‹ğ‘˜,old.
Therefore, the round oï¬€ error err+ (ğ‘‹ğ‘›, ğ‘‘ğ‘‹ğ‘›) calculated from the last
step, which is computed for ğ‘‹ğ‘˜,old, becomes incorrect if applied to
ğ‘‹ğ‘˜,new. Thus, if the chain update is frequent during the integration,
the active round oï¬€ error compensation will be interrupted and then it
becomes less useful. The branching coordinates proposed by Rantala
et al. (2020), that need fewer coordinates updates has the potential to
solve this problem. We will investigate this in the future.

We integrate the sun-earth-moon system with 1000 moon orbits
with the original Mikkolaâ€™s AR-chain, AR-chain in SpaceHub and
AR-Chain+ with diï¬€erent relative error tolerance ğœ‚. Figure 3 shows
the rms relative energy error as a function of ğœ‚.

3.3 AR-Sym6+: Algorithmic regularized higher order

symplectic method

The original AR-chain uses the leapfrog scheme as the basic algo-
rithm. Due to its time symmetry, it does very well in conserving
the total energy of the Hamiltonian system. However, the leapfrog
scheme alone is just a second order method that, when used alone,
is rarely suï¬ƒciently accurate. Therefore, to achieve higher precision,
AR-chain adopts the GBS extrapolation scheme which can eï¬ƒciently
construct higher order methods from lower order methods. However,

05101520number of particles N0.750.800.850.900.95Tnew/Told101410121010108106rtol 101410121010108RMS E/EAR-chainAR-chain+AR-chain(Mikkola)the round-oï¬€ errors from the BS method can be signiï¬cant due to
the extrapolation process. Several measures can be taken to reduce
them, but the reduction can be limited if higher order methods are
included. Therefore, theoretically, even BS extrapolation can achieve
arbitrarily high order accuracy. However, we ï¬nd that, for most cases
of interest, 13th to 15th order works best for double precision ï¬‚oat-
ing point numbers. Higher order extrapolations will be capped by the
round oï¬€ error. More importantly, the extrapolation can break the
time symmetry of the leapfrog scheme, and can signiï¬cantly aï¬€ect
the relative energy error in the round oï¬€ error regime. For integra-
tion methods based on the BS extrapolation with double precision
FP numbers as the arithmetic type, the relative energy error for short
time integration is usually at the level of 10âˆ’13 due to the extrapola-
tion. As discussed before, the active error compensation can reduce
the error further to âˆ¼ 10âˆ’14, but it becomes hard to achieve higher
precision under the BS extrapolation scheme.

Using higher order symplectic methods to replace the BS extrapo-
lation has been mentioned in Mikkola & Merritt (2008). However, to
date, there have been no implementations of higher order symplectic
methods with algorithmic regularization. Beneï¬ting from the code
architecture of SpaceHub, we can easily glue diï¬€erent algorithms
together, and introduce the regularization and chain algorithm into
the higher order symplectic method. Without the rational extrapola-
tion, the time symmetry of the symplectic method can be preserved.
Thus, this new method can eï¬ƒciently deal with extreme eccentricity
systems and very close pair-wise approaches with even higher pre-
cision. More importantly, with regularization, it is possible to use
ï¬xed step sizes to solve the time evolution of extremely eccentric
systems. The ï¬xed step size regularized method maintains the time
symmetry while avoiding these issues arising from the extrapolation.
Consequently, we can achieve higher precision in the round oï¬€ error
regime (i.e., when round oï¬€ errors dominate the growth of the total
energy error budget).

3.3.1 Error estimation

For an integration method of order ğ‘˜, the numerical integration ğ¼ğ‘› ( ğ‘“ )
on ğ‘“ for total step length ğ» with ğ‘› intermediate steps has an error
that scales as

Few-body toolkit SpaceHub

9

3.3.2 Step size control

As discussed above, for an integration method of order ğ‘˜, the global
truncation error scales as âˆ¼ ğ» ğ‘˜ , where ğ» is the step size. For inte-
grations working in the asymptotic regime, we have

âˆ¼

ğ» ğ‘˜

new
errornew

ğ» ğ‘˜
old
errorold
To get the converged result in the next step, i.e errornew < 1, the
simplest way to chose the step size in the next step would be just

(88)

ğ»new = ğ»old (

1
errorold

)1/ğ‘˜ .

(89)

However, the integration would not always work eï¬€ectively in the
asymptotic regime especially, but also in the round oï¬€ error regime,
where the round oï¬€ error becomes non-negligible compared to the
truncation error. Thus, more complicated error/step control might be
needed.

In control theory, the Proportionalâ€“Integralâ€“Derivative (PID) con-
troller is believed to be eï¬ƒcient and useful in performing continuous
error controlling. In SpaceHub, the PI step size controller that ap-
plies proportional and integral feedback to the integration system is
the default step size controller, where the new step will be given by
(cid:19)ğ¶ğ¼ /ğ‘˜

ğ»new = ğ‘†1

(cid:18) ğ‘†2
error

(cid:19)ğ¶ğ‘ƒ/ğ‘˜ (cid:18) error
ğ‘†2

ğ»old ,

(90)

where ğ¶ğ‘ƒ, ğ¶ğ¼ are, respectively, the coeï¬ƒcients of proportionality
and the integral feedback part. The speciï¬c values of ğ¶ğ‘ƒ and ğ¶ğ¼
are problem-dependent but a general value could be ğ¶ğ‘ƒ = 0.7 and
ğ¶ğ¼ = 0.4 (Press et al. 2002). The variables ğ‘†1 and ğ‘†2 are the safe
factors, which tend to be few percents smaller than one to make sure
the new step size has higher probability to get a converged result.
To avoid varying the step size rapidly, a time step limiter is applied
to the ğ»new calculation. The new step size is constrained within the
range
ğ‘†1/ğ‘˜
3
ğ‘†4
where ğ‘†3 = 0.02 and ğ‘†4 = 4.

ğ»new
ğ»old

(cid:18) 1
ğ‘†3

(cid:19)1/ğ‘˜

(91)

<

<

(84)

3.3.3 Choosing the order of the Symplectic methods

ğ¸ğ‘› ( ğ‘“ ) = |ğ¼ğ‘› ( ğ‘“ ) âˆ’ ğ¹ | âˆ¼ ğ¶

(cid:19) ğ‘˜

,

(cid:18) ğ»
ğ‘›

where ğ¹ is the unknown true value of the integration and ğ¶ is a
constant. To estimate ğ¸ğ‘› ( ğ‘“ ), we can do additional integrations on ğ‘“
with ğ‘š(> ğ‘›) steps. The error for ğ¼ğ‘š ( ğ‘“ ) is

ğ¸ğ‘š ( ğ‘“ ) = |ğ¼ğ‘š ( ğ‘“ ) âˆ’ ğ¹ | âˆ¼ ğ¶

(cid:19) ğ‘˜

(cid:18) ğ»
ğ‘š

=

ğ¸ğ‘› ( ğ‘“ )
(ğ‘š/ğ‘›) ğ‘˜

.

Then we can estimate the error of the integration ğ¼ğ‘š ( ğ‘“ ),

ğ¸ğ‘š âˆ¼

1
(ğ‘š/ğ‘›) ğ‘˜ âˆ’ 1

|ğ¼ğ‘š âˆ’ ğ¼ğ‘› | .

(85)

(86)

To obtain a converged result with tolerance ğœ–, a sequence of step
numbers ğ‘›1, ğ‘›2, ..., ğ‘› ğ‘— can be performed such that the dimensionless
error is less than unity,

error =

|ğ¼ğ‘› ğ‘— âˆ’ ğ¼ğ‘› ğ‘—âˆ’1 |
[(ğ‘› ğ‘— /ğ‘› ğ‘—âˆ’1) ğ‘˜ âˆ’ 1]|ğ¼ğ‘›ğ‘˜ |ğœ–

< 1 .

(87)

From our experiments, we ï¬nd that the choice of ğ‘› ğ‘— for eï¬ƒcient
convergence and speed works well for ğ‘› ğ‘— = 2 ğ‘— with ğ‘— = 1, 2, ....

Yoshida (1990) gives an eï¬ƒcient way to construct higher order sym-
plectic methods recursively using lower order symplectic methods
via the Baker-Campbell-Hausdorï¬€ formula. From Yoshida (1990), if
a symmetric integrator of order 2ğ‘›, ğ‘†2ğ‘› (ğœ) is already known, a 2ğ‘› + 2
th order integrator can be obtained via the product
ğ‘†2ğ‘›+2 = ğ‘†2ğ‘› (ğ‘§1ğœ)ğ‘†2ğ‘› (ğ‘§0ğœ)ğ‘†2ğ‘› (ğ‘§1ğœ)
where ğ‘§0 and ğ‘§1 satisfy
ğ‘§0 + 2ğ‘§1 = 1, ğ‘§2ğ‘›+1
(93)
Then, starting from the 2nd order leapfrog scheme with ğ‘†2 (ğœ) =
ğ· (ğœ/2)ğ¾ (ğœ)ğ· (ğœ/2), higher order symplectic integrators can be con-
structed recursively. In SpaceHub, we implement symplectic meth-
ods up to 10th order.

+ 2ğ‘§2ğ‘›+1
1

= 0 .

(92)

0

For symplectic integrators using the regularization chain method,
we test from 6th order to 10th order. From our experiments, we ï¬nd
that the 6th order method (hereafter called AR-sym6) works best in
terms of precision with decent convergence speed for 64 bits FP data
type. Using the higher order symplectic methods directly without
extrapolation preserves the time symmetry of the integration. Thus,

MNRAS 000, 1â€“18 (2015)

10 Wang et al.

separately. To solve the equations of motion of the regularized sys-
tem with the Gauss-Radau method, a general coordinate is required
where,
y = (r, v, ğœ”, ğµ, ğ‘¡)

(102)

such that y|â„ can be expanded into
ğ‘‘y
ğ‘‘â„

+ b1â„ + b2â„2 + ... + b7â„7

ğ‘‘y
ğ‘‘â„

âˆ¼

(cid:12)
(cid:12)
(cid:12)
(cid:12)â„

(cid:12)
(cid:12)
(cid:12)
(cid:12)0

where
(cid:12)
ğ‘‘y
(cid:12)
(cid:12)
ğ‘‘â„
(cid:12)0

= (

ğ‘‘r
ğ‘‘â„

,

ğ‘‘v
ğ‘‘â„

,

ğ‘‘ğœ”
ğ‘‘â„

,

ğ‘‘ğµ
ğ‘‘â„

,

ğ‘‘ğ‘¡
ğ‘‘â„

)

(103)

(104)

The same process as Equation 58 and 59 can be performed to calcu-
late the bğ‘–. Then the general coordinates at the end of the step ğ‘‘ğ‘¡ can
be obtained by analytically integrating Equation 103.
(cid:18)
â„

(cid:19) (cid:19)(cid:19)

(cid:18)

y|â„ âˆ¼ y|0 + â„ğ‘‘ğ‘¡

(cid:18) ğ‘‘y
ğ‘‘ğ‘¡

(cid:12)
(cid:12)
(cid:12)
(cid:12)0

+

2

b1 +

2â„
3

b2 + ...

(105)

Figure 4. Same as Figure 3, but testing the AR-sym6+.

it achieves much higher precision relative to the original AR-chain,
using the active round oï¬€ error compensation.

We integrate the sun-earth-moon system with 1000 moon orbits
with the original Mikkolaâ€™s AR-chain, AR-chain in SpaceHub and
AR-Sym6+ with diï¬€erent relative error tolerance ğœ‚. Figure 4 shows
the rms relative energy error as a function of ğœ‚.

3.4 AR-Radau+: introducing algorithmic regularization into

Gauss-Radau integration

Gauss-Radau spacings are useful in solving few-body problems ac-
curately, especially after the active round oï¬€ error compensation
was implemented in Rebound. However, the normal Gauss-Radau
method is not eï¬ƒcient/accurate enough to solve extremely eccentric
orbits as well as close encounters because tiny steps are required to
solve the trajectories at the point of closest approach. To solve this
problem while keeping the advantages of the Gauss-Radau stepping,
we introduce the algorithmic regularization into the Gauss-Radau
method.

The equations of motion of the regularized system are ï¬rst order
diï¬€erential equations. For a system with Hamiltonian ğ», the LogH
method gives the equations of motion as,

ğ‘‘ğ‘¡/ğ‘‘â„ = 1/(ğ‘‡ + ğµ)
ğ‘‘r/ğ‘‘â„ = v/(ğ‘‡ + ğµ)
ğ‘‘v/ğ‘‘â„ = a/ğ‘ˆ
ğ‘‘ğµ/ğ‘‘â„ = ğœ•ğ»/ğœ•ğ‘¡/ğ‘ˆ ,

while the TTL method gives the equations of motion as,

ğ‘‘ğ‘¡/ğ‘‘â„ = 1/ğœ”
ğ‘‘r/ğ‘‘â„ = v/ğœ”
ğ‘‘v/ğ‘‘â„ = a/Î©
ğ‘‘ğœ”/ğ‘‘â„ = ğœ•Î©/ğœ•ğ‘¡/Î© .

(94)

(95)

(96)

(97)

(98)

(99)

(100)

(101)

They work smoothly with the leap-frog based method because ad-
vancing the velocity and position are divided into â€™kickâ€™ and â€™driftâ€™

MNRAS 000, 1â€“18 (2015)

The chain algorithm can also be constructed by replacing the
equations of motion for r and v with equations of motion for X and
V, as described in Equation 49.

Similar to previous subsections, we integrate two systems with
diï¬€erent relative error tolerance ğœ‚. The ï¬rst test integrates the sun-
earth-moon system with 1000 moon orbits and the second test inte-
grates an eccentric two body orbit with ğ‘€1 = 1ğ‘€(cid:12), ğ‘€2 = 1ğ‘€âŠ•, a =
1 AU and e = 0.9999 with 1000 orbits. The IAS15 does not provide
API to change the ğœ‚, thus the ğœ‚ is ï¬xed at the default value 10âˆ’16.

The upper panel of Figure 4 shows the rms relative energy error
as a function of ğœ‚ for the IAS15 and AR-Radau+ methods for the
sun-earth-moon system. The bottom panel shows the same results
for the eccentric two body system.

4 PERFORMANCE TESTS FOR REAL ASTROPHYSICAL

SYSTEMS

In this section we test the precision and performance of the inte-
gration methods adopted in SpaceHub, and compare them to other
high-precision few-body codes, including Brutus, Rebound, ABIE1,
Mikkolaâ€™s AR-chain, and so on.

All tests are performed on an Intel-i7-8700k CPU under a Linux
OS with GCC-10.2.0. All codes are compiled with the -O3 compile
optimization option. Table 4 shows the algorithms tested in each
section.

4.1 Precision & Performance Tests

For the precision and performance tests, only the Newtonian inter-
actions will be included. The precision indicator, speciï¬cally the
relative energy error, will be evaluated as
ğ›¿ğ¸
ğ¸
with ğ¸ = ğ‘‡ âˆ’ ğ‘ˆ. For algorithms with regularization, to decrease the
round-oï¬€ errors from the potential energy calculations, the estimation
becomes(Mikkola & Merritt 2008)

|ğ¸ (ğ‘¡) âˆ’ ğ¸ (0)|
|ğ¸ (0)|

(ğ‘¡) =

(106)

| log(

ğ‘‡ + ğµ
ğ‘ˆ

)| = | log(1 +

ğ›¿ğ¸
ğ‘ˆ

)| âˆ¼

|ğ›¿ğ¸ |
ğ‘ˆ

,

(107)

1 ABIE is a new GPU-accelerated direct N-body code. The integrator adopted
in these simulations is a 15th-order Gauss-Radau algorithm with an adaptive
timestep scheme. The algorithm is particularly optimized for close encounters.

101410121010108106rtol 101510131011109RMS E/EAR-chainAR-sym6+AR-chain(Mikkola)Few-body toolkit SpaceHub

11

algorithm

code

setups

link

Bulirsch-Stoer
AR-Chain
AR-Chain+
AR-Radau+
AR-sym6+
AR-ABITS
IAS15
Radau
Bulirsch-Stoer
AR-chain

SpaceHub
SpaceHub
SpaceHub
SpaceHub
SpaceHub
SpaceHub
Rebound
ABIE
Brutus
Mikkola

rtol = 10âˆ’14, atol = 0
rtol = 10âˆ’14, atol = 0
rtol = 10âˆ’14, atol = 0
code ï¬xed default
rtol = 10âˆ’14, atol = 0
rtol = 10âˆ’14, atol = 0
code ï¬xed default
code ï¬xed default
rtol = 10âˆ’14, atol = 0
rtol = 10âˆ’14, atol = 0

source code
source code
source code
source code
source code
source code
source code
source code
source code
source code

Table 4. Tested algorithms

Since every integration method can be well-tuned for a speciï¬c
problem, it can be tricky to do proper comparisons between dif-
ferent integration methods. However, for each integration method
included in SpaceHub, there are always default parameters, the so
called â€™out-of-the-boxâ€™ parameters, which help control the integra-
tion ï¬‚ow and which vary among diï¬€erent integration schemes. To
make the comparisons as normalized as possible, we use the out-of-
the-box parameters for all integration methods when performing all
comparison tests in order to ensure a fair comparison between the dif-
ferent methods adopted in diï¬€erent codes (e.g., REBOUND, ABIE, etc.).
One should also note that the basic math functions like â€™powâ€™, â€™sinâ€™,
â€™cosâ€™ etc. in the standard math library are not platform-independent.
Thus, algorithm (including ABIE, Mikkolaâ€™s AR-chain and Brutus)
that use those math functions become platform-independent as well.
The test results could be slightly diï¬€erent on diï¬€erent platforms. A
platform-independent math library will be implemented in the next
version of the SpaceHub.

4.1.1 The Earth-Moon-Sun System

We now pay attention to a simple sun-earth-moon system that is easy
to integrate for every method. The integrated system consists of the
sun, the earth and the moon. We integrate the system for 1000 moon
orbits using adaptive time stepping, and quantify the performance of
each method.

Figure 6 shows the precision and CPU wall time for each method.
The left panel shows the relative energy error of each method as
a function of time, the middle panel shows the CPU wall time for
each method and the right panel shows the rms relative energy er-
ror versus CPU time. From the ï¬gure, we can see that the imple-
mentation of AR-chain in SpaceHub is âˆ¼ 2 âˆ’ 2.5 times faster than
Mikkolaâ€™s implementation. The AR-Chain+ is slightly slower but
comes along with with slightly higher precision. The Radau method
in ABIE reaches the same precision but signiï¬cantly slower than the
AR-Chain-based methods in SpaceHub. The IAS15, a Radau method
with improvements implemented by Rein & Spiegel (2014), achieves
higher precision near the machine precision with the same speed
as the Radau method in ABIE. The algorithmic regularized Radau
method in SpaceHub and the algorithmic regularized 6th symplectic
methods have better round oï¬€ error control for this problem, and thus
yield even higher precision computations than IAS15. The algorith-
mic regularized 6th order symplectic method is signiï¬cantly slower
than the other two due to its extra integration for error evaluation at
each step. The AR-Radau method, with extended double sized coor-
dinates and extra regularization function evaluation (which mainly
spends its time on evaluating U) at each time step is only slightly

MNRAS 000, 1â€“18 (2015)

Figure 5. Upper panel: Same test as in Figure 3 for IAS15 and AR-Radau+.
Bottom panel: Test of 1000 orbits on the two body eccentric system with a =
1 AU and e = 0.9999 consists of ğ‘€1 = 1ğ‘€(cid:12) and ğ‘€2 = 1ğ‘€âŠ•. The IAS15
does not provide API to change the ğœ‚, thus the ğœ‚ is ï¬xed as default 10âˆ’16.

where ğµ is deï¬ned in Equation 5 as the binding energy that will
be evaluated at ğ‘¡ = 0 and will continue to evolve in time with the
ğ›¿ğ¸
ğ¸ (ğ‘¡) com-
regularized system. For each test, 5000 equally spaced
putations will be outputted during the integration and the root mean
square (RMS) error is calculated as

RMS

ğ›¿ğ¸
ğ¸

=

âˆšï¸‚

ğ‘
âˆ‘ï¸

ğ‘–

ğ›¿ğ¸
ğ¸

(

(ğ‘¡ğ‘–))2/ğ‘ .

(108)

For our performance tests, the CPU wall time is measured from
the best performance test of 5 repeat runs with the same initial con-
ditions. This is done to avoid CPU interruption by other processes
operating in the background. The wall time only quantiï¬es the time
evolution within the main loop of the integration scheme, and ig-
nores all initialization and ï¬nalization procedures in order to obtain
normalized comparisons between the diï¬€erent algorithms. The IOs
need non-negligible CPU time in short term performance tests. To
precisely measure the wall time of diï¬€erent algorithms in our per-
formance tests, all outputs are turned oï¬€. The test ï¬le and initial
conditions for our test cases can be found at SpaceHub-Tests. Tests
of other codes are performed using the code links provided above
with the same initial conditions.

101510131011109107rtol 101610151014RMS E/EAR-Radau+IAS15(REBOUND)101510131011109107rtol 1015101410131012RMS E/EAR-Radau+IAS15(REBOUND)12 Wang et al.

slower than IAS15 for this test case. For arbitrary precision methods
with non-standard ï¬‚oating-point types, we see that the algorithmic
regularized arbitrary bits (AR-ABITS) method is faster and far more
accurate than Brutus, as previously discussed.

4.1.2 Extremely eccentric systems

For our second test case, we analyze a two body system with extreme
eccentricity e=0.9999 and semi-major axis a = 1 AU. The central
object has a mass of 1 ğ‘€(cid:12) and the test particle has a mass of 1
ğ‘€âŠ•. We integrate the system for 1000 orbits. This test is designed
to quantify how the diï¬€erent integration methods are able to han-
dle extremely eccentric orbits and very close pair-wise approaches
between particles.

As in Figure 6, we can see from Figure 7 that this system becomes
challenging to integrate for methods without regularization. We ï¬nd
that the BS method accumulates errors quickly, rapidly reaching up
to âˆ¼ 10âˆ’8. The Radau method in ABIE can steadily maintain the
error at the level of âˆ¼ 10âˆ’10 for this integration duration. IAS15
behaves the best as a non-regularized method, keeping the error
near âˆ¼ 10âˆ’12, which is near the limit for non-regularized methods
ğœ–/(1 âˆ’ ğ‘’max) âˆ¼ 10âˆ’16/(1 âˆ’ 0.9999). For methods with regulariza-
tion, we ï¬nd that all integration schemes maintain a precision below
10âˆ’13 for this problem over the course of the integration duration.
As for the simple test on the sun-earth-moon system, the AR-chain
in SpaceHub is roughly two times faster than Mikkolaâ€™s AR-chain.
Unlike this previous test case, the AR-chain+ method has nearly the
same precision as AR-chain. For this test case, the AR-chain+ method
achieves one order of magnitude higher precision. This is because
there is no chain update in the two body system, such that the active
error compensation can precision compensate the error from the last
step in order to correct the coordinates for the next step. For systems
with frequent chain updates, where the chain coordinates change
frequently, the active error compensation become less useful. The
AR-Radau method achieves 3 orders higher precision than IAS15
for this problem with faster speed. The AR-sym6 method reaches an
energy error of âˆ¼ 10âˆ’14 roughly ten times faster than IAS15. AR-
ABITS is therefore better at dealing with extreme eccentricities and
close encounters, achieving 4 orders of magnitude higher precision
with a run time that is roughly 40 times faster than Brutus for this
test problem.

This test displays the advantage of the regularization schemes in
dealing with extreme eccentricities and close encounters. With reg-
ularization, we can always get better results with faster speed. In
SpaceHub, one can introduce the regularization algorithm in any
method provided that it is used the â€™regularized systemâ€™ as the inte-
gration scheme.

4.1.3 Outer Solar System

Next, we test the outer solar system. We consider four planets: Jupiter,
Saturn, Uranus and Neptune and evolve the system for 1000 Jupiter
orbits.

From Figure 8, we can see that for this system in which there is
no strong interaction, even the BS method in SpaceHub can achieve
10âˆ’14. There are not many advantages in introducing the regulariza-
tion and chain because there is no close encounter or close position
subtraction. Therefore, the AR-chain dose not show better precision
than the BS method. But both of them show great precision due to
the improvements on BS extrapolation. Similarly as in the previous
two tests, AR-chain in SpaceHub is 2-2.5 times faster than Mikkolaâ€™s

MNRAS 000, 1â€“18 (2015)

implementation. The AR-chain+ shows one order higher precision
than AR-chain in this case because the chain update is not as fre-
quent as in the sun-earth-moon system. Therefore, the active error
compensation could do a better job on reducing the round oï¬€ error.
AR-Radau, AR-sym6 perform slightly better than IAS15 in this case,
but AR-sym6 is 2 times slower due to its extra evaluation for error
estimation.

The arbitrary precision AR-ABITS and Brutus with 88 mantissa
bits show signiï¬cant error accumulation in the test case. These cases
become ineï¬ƒcient in both precision and speed. However, they are
designed to achieve extremely high precision by adopting double
precision machine precision. One can always achieve higher precision
by using more mantissa bits.

4.1.4 Lidov-Kozai system

In this section, we move on to quantifying the performance of the
diï¬€erent integration methods considered in this system for a three-
body system undergoing Lidov-Kozai oscillations.

We have already tested extremely eccentric systems, but these
are only two-body systems and some algorithms oï¬€er advantages
tailored for solving the two-body problem more precisely. To make
our tests more robust, we now test a hierarchical three-body system
undergoing strong Lidov-Kozai cycles. The system consists of an
inner binary with component masses ğ‘š1 = 1ğ‘€(cid:12) and ğ‘š2 = 1ğ‘€(cid:12) and
the initial orbital parameters ğ‘1 = 10 au and ğ‘’1 = 10âˆ’3. The mass
of the outer tertiary is ğ‘š3 = 1ğ‘€(cid:12) with ğ‘2 = 100 au and ğ‘’2 = 0.5
initially. The initial inclination angle between the inner and outer
orbital planes is ğ‘–tot = 96.7â—¦. The maximum ğ‘’1 (ğ‘¡) reached in this
system is larger than 0.999999. We integrate the system up to 105
years, which corresponds to approximately 6 quadrupole LK cycles.
From Figure 9, we see that this three-body system is challeng-
ing to model precisely and accurately for some methods. During the
integration, the step size of the Radau method in ABIE shrinks to
10âˆ’14 years as the eccentricity of the inner binary reaches its max-
imum value. Consequently, it takes an excessively long time for the
integration to complete. The IAS15 in Rebound cannot maintain its
high precision after the ï¬rst eccentricity excitation. The precision
drops to 10âˆ’10 for this test case. However, we ï¬nd that methods with
regularization, including AR-Radau and AR-sym6+, can maintain an
error of âˆ¼ 10âˆ’13. The AR-chain method from Mikkola is three times
slower. The arbitrary precision integration method characteristic of
AR-ABITS in SpaceHub behaves much better that than Brutus in
terms of both speed and precision.

4.2 Long time integration

For our ï¬nal test case, we perform a long term integration test using
the new algorithms in SpaceHub. We integrate the same system as
described in Section 4.1.4 up to 5Ã—109 years, which corresponds
to 1.5Ã—108 orbits of the inner binary and 3 million quadrupole
LK cycles. The maximum eccentricity of the system is higher than
0.999999.

From Figure 10, we see that the relative energy error of IAS15
instantly increases around 1000 orbits, where the eccentricity of the
inner orbit of the hierarchical triple reaches its ï¬rst maximum in the
ï¬rst LK cycle. For regularized algorithms that include AR-Chain+,
AR-Radau+ and AR-sym6+ in SpaceHub, the relative energy error
is maintained at 10âˆ’13. As the integration continues, IAS15 has
several signiï¬cant error jumps due to the high eccentricity of the
LK cycles. It becomes completely unreliable around 105 orbits as

Few-body toolkit SpaceHub

13

Figure 6. Relative energy error and performance tests on the sun-earth-moon system. The integration duration is 1000 moon orbits. Left panel: Relative energy
errors for diï¬€erent integration methods in SpaceHub (without parentheses) as a function of the number of orbital periods and for diï¬€erent integration methods
adopted in other codes (with the names of the codes indicated in parentheses). Middle panel: CPU wall time for each integration method. Right Panel: Root mean
square relative energy error (accumulated over time) versus CPU wall time. The relative tolerance is 10âˆ’14 and the absolute tolerance is 0 for methods that can
be adjusted. All methods use IEEE-754 double precision ï¬‚oating point numbers, except for â€™AR-ABITSâ€™ and â€™BS(Brutus)â€™. â€™AR-ABITSâ€™ and â€™BS(Brutus)â€™ use
88 mantissa bits and non-standard extended ï¬‚oating-point numbers. Methods with bold-faced font are new unique methods in SpaceHub. The initial conditions
and performance test descriptions can be found at https://github.com/YihanWangAstro/SpaceHub/tree/master/test/regression_test.

Figure 7. Similar test to Figure 6 but on an extremely eccentric two body system. The central body has a mass of 1 ğ‘€(cid:12) and the orbiting body has a mass of
1 ğ‘€âŠ• with an initial semi-major axis of 1 au and an initial eccentricity of 0.9999. The integration duration is 1000 orbits.

the relative energy error grows to 1. The relative energy error of
the regularized algorithms in SpaceHub accumulate from largely
reduced but inevitable round-oï¬€ errors. For this case, the AR-Radau+
and AR-sym6+ behave similar to AR-Chain+, which was unexpected
as we anticipated the latter method to perform better. Indeed, with
some extra exploration, we ï¬nd that in most of the cases, the relative
energy errors are at the same order in the long term integration. It
depends on the individual nature of speciï¬c problems, but the chain
algorithm and active error compensation have signiï¬cantly diï¬€erent
impacts on the long term round-oï¬€ error. Thus, these method can
standout in our tests by âˆ¼ 1 order of magnitude. However, they all can

maintain higher precision and do a better job than other integrator
schemes in long term integrations for extremely high eccentricity
systems.

5 IMPLEMENTATION OF PAIR-WISE EXTERNAL

FORCES

In this section, we describe SpaceHubâ€™s implementation of all non-
Newtonian forces, including tidal dissipation and Post-Newtonian
corrections to account for general relativistic eï¬€ects.

MNRAS 000, 1â€“18 (2015)

02004006008001000orbits10211020101910181017101610151014E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)Bulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)101100101CPU time [s]0.070.080.100.490.710.380.3446.6216.180.21101100101CPU time [s]10181017101610151014RMS E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)53 mantissa bits machine precision02004006008001000orbits1016101410121010108E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)Bulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)101100101102CPU time [s]0.200.040.041.600.262.151.05156.564.020.09101100101102CPU time [s]10141013101210111010109108RMS E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)14 Wang et al.

Figure 8. Similar test to Figure 6 but applied to the outer solar system. The system consists of a central body with a total mass of the inner solar system and
four outer planets Jupiter, Saturn, Uranus and Neptune. The integration duration is 1000 Jupiter orbits.

Figure 9. Similar test to Figure 6 but for a Lidov-Kozai system. The system consists of an inner binary with component masses ğ‘š1 = 1ğ‘€(cid:12) and ğ‘š2 = 1ğ‘€(cid:12)
and an initial semi-major axis and eccentricity of, respectively, ğ‘1 = 10 au and ğ‘’1 = 10âˆ’3. The outer tertiary has mass ğ‘š3 = 1ğ‘€(cid:12) with an orbit having an initial
semi-major axis and eccentricity of ğ‘2 = 100 au and ğ‘’2 = 0.5. The inclination between the inner and outer orbit is 96.7â—¦ initially. The integration duration is
105 years, which corresponds to roughly 6 LK cycles. In this test, the step size of the Radau method in ABIE shrinks to 10âˆ’14 years, implying a very long time
to ï¬nish the integration test. Thus, ABIE failed in this test.

5.1 Static tidal forces

Here we describe our implementation of equilibrium tidal forces
based on the weak friction model, where the tides are assumed to
take on an equilibrium shape with a constant time lag. In this model,
the tidal force exerted on body ğ‘šğ‘– with radius ğ‘…ğ‘– is implemented as
(Hut 1981)

Then, the acceleration ğ‘ğ‘– due to the tidal dissipation exerted by

body ğ‘šğ‘– on body ğ‘š ğ‘— , and vice versa, can be written

ağ‘–

a ğ‘—

= Ftid/ğ‘š ğ‘—
= Ftid/ğ‘šğ‘– .

(110)

(111)

For the tidal force in the radial direction ğ¹ğ‘Ÿ , the angular momentum
of the two body system is conserved as

F = âˆ’3ğº

ğ‘š2
ğ‘—
ğ‘Ÿ2

(cid:18) ğ‘…ğ‘–
ğ‘Ÿ

(cid:19)5

(cid:18)

ğ‘˜

1 + 3

(cid:19)

ğœ

Ë†r

(cid:164)ğ‘Ÿ
ğ‘Ÿ

(109)

â„ = ğœ‡

âˆšï¸ƒ

ğº ğ‘€ğ‘(1 âˆ’ ğ‘’2) ,

(112)

where ğ‘Ÿ, ğ‘˜ and ğœ are, respectively, the apsidal motion constant and
lag time, the relative distance between ğ‘š ğ‘— and ğ‘šğ‘–, the tidal apsidal
motion constant and the tidal time lag.

where ğœ‡ = ğ‘šğ‘–ğ‘š ğ‘— /(ğ‘šğ‘– + ğ‘š ğ‘— ) is the reduced mass of the two-body
system, ğ‘€ = ğ‘šğ‘– + ğ‘š ğ‘— is the total mass, ğ‘ is the semi-major axis of
the orbit and ğ‘’ is the eccentricity. There are two eï¬€ects included in

MNRAS 000, 1â€“18 (2015)

02004006008001000orbits10171016101510141013E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)Bulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)101100101102CPU time [s]0.090.090.110.461.170.610.53129.6125.170.24101100101102CPU time [s]101510141013RMS E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)050010001500200025003000orbits101510131011109107E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)BS(Brutus)AR-ABITSAR-chain(Mikkola)Bulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)100101102CPU time [s]0.260.230.301.802.254.03281.9343.370.69100101102CPU time [s]1013101210111010109108107106RMS E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)BS(Brutus)AR-ABITSAR-chain(Mikkola)Few-body toolkit SpaceHub

15

Figure 10. An integration of the same Lidov-Kozai system as in Figure 9 but up to 5 Ã— 109 years, which is about 1.6Ã—108 inner orbits periods. This test is
performed on Stony Brookâ€™s Seawulf cluster on an Intel Xeon Gold 6148 CPU with GCC-9.2.0 compiler.

this tidal force, the ï¬rst is the tidal dissipation of the orbital energy,
where the orbital energy

ğ¸orb = âˆ’ğº

ğ‘šğ‘–ğ‘š ğ‘—
2ğ‘

dissipates at a rate of

(113)

(cid:164)ğ¸orb = âˆ’

9
2

where

ğº2 (ğ‘šğ‘– + ğ‘š ğ‘— )ğ‘š2

ğ‘— ğ‘…5

ğ‘– ğ‘˜ğœğ‘âˆ’9 (1 âˆ’ ğ‘’2)âˆ’15/2ğ‘’2 ğ‘“1 (ğ‘’2) (114)

ğ‘“1 (ğ‘’2) = 1 +

15
2

ğ‘’2 +

15
8

ğ‘’4 +

ğ‘’6 .

5
64

(115)

Due to conservation of angular momentum, one obtains (cid:164)ğ‘(ğ‘¡ â†’
+âˆ) = (cid:164)ğ‘’(ğ‘¡ â†’ +âˆ) = 0 and

ğ‘’(ğ‘¡ â†’ +âˆ) = 0
ğ‘(ğ‘¡ â†’ +âˆ) = ğ‘0 (1 âˆ’ ğ‘’2
0)
(117)
where ğ‘0 and ğ‘’0 are the initial semi-major axis and eccentricity,
respectively.

(116)

The second eï¬€ect due to this force is the periastron percession,

5.2 Post-Newtonian corrections and general relativistic eï¬€ects

In this section, we describe SpaceHubâ€™s treatment of general rel-
ativistic eï¬€ects via the inclusion of Post-Newtonian terms in our
estimates for the gravitational acceleration.

The Post-Newtonian approximation in general relativity is of the

general form

ğ¹GR = ğ‘âˆ’2ğ¹1PN + ğ‘âˆ’4ğ¹2PN + ğ‘âˆ’5ğ¹2.5PN

(119)

where ğ‘âˆ’2ğ¹1PN contributes most of the periastron precession mo-
tion, ğ‘âˆ’4ğ¹2PN contributes a correction proportional to (ğ‘£/ğ‘)2 and
ğ‘âˆ’5ğ¹2.5PN contributes almost all of the gravitational radiation. The
force exerted on particle ğ‘– is (Damour & Deruelle 1985; Soï¬€el 1989),

ğ¹1PN =

ğºğ‘šğ‘–ğ‘š ğ‘—
ğ‘Ÿ2
ğºğ‘šğ‘–
ğ‘Ÿ

+5

(cid:26)

(cid:20)

n

âˆ’ ğ‘£2

ğ‘– âˆ’ 2ğ‘£2

ğ‘— + 4ğ‘£ğ‘–ğ‘£ ğ‘— +

(ğ‘›ğ‘£ ğ‘— )2

3
2

(cid:21)

ğºğ‘š ğ‘—
ğ‘Ÿ

+ 4

+ v[4ğ‘›ğ‘£ğ‘– âˆ’ 3ğ‘›ğ‘£ ğ‘— ]

(cid:27)

(120)

where the pericentre will precess at a rate given by
1 + 3
2

ğ‘’4

ğ‘…5
ğ‘–
ğ‘5

ğ‘˜ğ‘›

ğ‘’2 + 1
8
(1 âˆ’ ğ‘’2)5

(cid:164)ğœ”tide =

15
2

ğ‘š ğ‘—
ğ‘šğ‘–
âˆšï¸ƒ

where ğ‘› =

ğº (ğ‘šğ‘– + ğ‘š ğ‘— )/ğ‘3 is the mean motion of the binary orbit.

Figure 11 shows examples of the orbital evolution including the
tidal force, where the binary consists of two 1 ğ‘€(cid:12) mass stars. The
primary star is treated as a point mass, while the secondary star has
a radius of 1 ğ‘… (cid:12) with ğ‘˜ = 0.75 and ğœ = 0.25 years. The initial semi-
major axis of the binary is 1 au, and we test diï¬€erent eccentricities,
speciï¬cally 0.6 to 0.89, 0.9 and 0.91.

The upper left panel of Figure 11 shows the pericentre precession
rate for diï¬€erent initial eccentricities as a function of time. We see
that the numerical result agrees closely with the analytic prediction
given by Equation 118. The bottom left panel shows the absolute
diï¬€erence between the numerical and the analytic results. The upper
right panel of Figure 11 shows the orbital energy decay rate due
to tidal dissipation calculated form the numerical simulations and
compared to the analytic results obtained from Equation 114. The
bottom right panel shows the corresponding relative error of the
dissipation rate.

(118)

ğ¹2PN =

ğºğ‘šğ‘–ğ‘š ğ‘—
ğ‘Ÿ2

(cid:26)

(cid:20)

n

âˆ’ 2ğ‘£4

ğ‘— + 4ğ‘£2

ğ‘— (ğ‘£ğ‘–ğ‘£ ğ‘— ) âˆ’ 2(ğ‘£ğ‘–ğ‘£ ğ‘— )2 +

3
2

ğ‘– (ğ‘›ğ‘£ ğ‘— )2
ğ‘£2

+

+

9
2
ğºğ‘šğ‘–
ğ‘Ÿ

ğ‘— (ğ‘›ğ‘£ ğ‘— )2 âˆ’ 6(ğ‘£ğ‘–ğ‘£ ğ‘— )(ğ‘›ğ‘£ ğ‘— )2 âˆ’
ğ‘£2

(cid:18)

âˆ’

15
4

ğ‘£2
ğ‘– +

5
4

ğ‘£2

ğ‘— âˆ’

5
2

ğ‘£ğ‘–ğ‘£ ğ‘— +

(ğ‘›ğ‘£ğ‘–)2

15
8

(ğ‘›ğ‘£ ğ‘— )4

39
2
ğºğ‘š ğ‘—
ğ‘Ÿ

(cid:18)

âˆ’39(ğ‘›ğ‘£ğ‘–)(ğ‘›ğ‘£ ğ‘— ) +

(ğ‘›ğ‘£ ğ‘— )2

(cid:19)

+

17
2

4ğ‘£2

ğ‘— âˆ’ 8ğ‘£ğ‘–ğ‘£ ğ‘—

+2(ğ‘›ğ‘£ğ‘–)2 âˆ’ 4(ğ‘›ğ‘£ğ‘–)(ğ‘›ğ‘£ ğ‘— ) âˆ’ 6(ğ‘›ğ‘£ ğ‘— )2

(cid:19) (cid:21)

(cid:20)

+v

ğ‘– (ğ‘›ğ‘£ ğ‘— ) + 4ğ‘£2
ğ‘£2

ğ‘— (ğ‘›ğ‘£ğ‘–) âˆ’ 5ğ‘£2

ğ‘— (ğ‘›ğ‘£ ğ‘— ) âˆ’ 4(ğ‘£ğ‘–ğ‘£ ğ‘— )(ğ‘›ğ‘£ğ‘–)

9
2
ğºğ‘š ğ‘—
ğ‘Ÿ

+4(ğ‘£ğ‘–ğ‘£ğ‘–)(ğ‘›ğ‘£ ğ‘— ) âˆ’ 6(ğ‘›ğ‘£ğ‘–)(ğ‘›ğ‘£ ğ‘— )2 +

(ğ‘›ğ‘£ ğ‘— )3

ğºğ‘šğ‘–
ğ‘Ÿ

+

(cid:18)

âˆ’

(cid:18)

n

âˆ’

+

ğº2
ğ‘Ÿ2

63
4

57
4

ğ‘›ğ‘£ğ‘– +

(cid:19)

+

ğ‘›ğ‘£ ğ‘—

55
4

(cid:18)

âˆ’ 2ğ‘›ğ‘£ğ‘– âˆ’ 2ğ‘›ğ‘£ ğ‘—

(cid:19)(cid:21)

ğ‘š2

ğ‘– âˆ’ 9ğ‘š2

ğ‘— âˆ’

(cid:19) (cid:27)

ğ‘šğ‘–ğ‘š ğ‘—

69
2

(121)

MNRAS 000, 1â€“18 (2015)

100102104106108orbits10141011108105102101E/EIAS15(REBOUND)AR-chain+AR-Radau+AR-sym6+16 Wang et al.

Figure 11. Test of the pericenter precession and orbital energy dissipation from the static tidal force. The system consists of two 1ğ‘€(cid:12) stars in a binary with
semi-major axis 1 au. Diï¬€erent eccentricities are selected, speciï¬cally 0.6, 0.89, 0.9 and 0.91. The primary star is treated as a point mass particle that does not
exert tides, while the secondary star exerts tides with apsidal motion constant ğ‘˜ = 0.75 and time lag ğœ = 0.25 years. Left panels: Pericenter precession rate for
diï¬€erent eccentricities obtained from the simulations and compared to the analytic results obtained from Equation 118. Right panels: Orbital energy dissipation
rate calculated from the simulations and compared to the analytic approximation given by Equation 114.

ğ¹2.5PN = ğ‘šğ‘–

4
5
(cid:34)

(cid:26)

ğº2ğ‘šğ‘–ğ‘š ğ‘—
ğ‘Ÿ3

(cid:20)

n(ğ‘›ğ‘£)

3ğ‘£2 âˆ’ 6

ğºğ‘šğ‘–
ğ‘Ÿ

+

(cid:21)

ğºğ‘š ğ‘—
ğ‘Ÿ

52
3

+v

âˆ’ ğ‘£2 + 2

ğºğ‘šğ‘–
ğ‘Ÿ

âˆ’ 8

(cid:21) (cid:27)

ğºğ‘š ğ‘—
ğ‘Ÿ

(122)

where n = Ë†r is the unit vector pointing from particle ğ‘— to particle ğ‘–,
and v = vğ‘– âˆ’ v ğ‘— where vğ‘– and vğ‘– are the velocities of particles ğ‘– and ğ‘—,
respectively. For simplicity, we have denoted the dot product of the
two vectors x1 and x2 as ğ‘¥1ğ‘¥2. To obtain the force exerted on particle
ğ‘—, we simply exchange the subscripts ğ‘– and ğ‘— in the above equations.
Note that the direction of n and v will change as well.

Figure 12 shows an example of the time evolution of the relative
orbital phase for an identical solar mass binary with an initial semi-
major axis of 0.1 AU. We include Post-Newtonian terms up to ï¬rst
order, and observe the resulting pericentre advance due to GR pre-
cession. The solid lines in the upper panel show the precession angle
as a function of time assuming diï¬€erent eccentricities. The dashed
line is calculated from the analytic equation

Î”ğœ”GR,analytic =

24ğœ‹3ğ‘2
ğ‘‡ 2ğ‘2 (1 âˆ’ ğ‘’2)

ğ‘¡
ğ‘‡

(123)

where ğ‘‡ is the period of the binary and ğ‘ is the speed of light. The
bottom panel shows the diï¬€erence between the analytic approxima-
tion and our simulation results as a function of time. Note that the

MNRAS 000, 1â€“18 (2015)

relative diï¬€erence between the two remains bounded and does not
grow in time.

Figure 13 shows the time evolution of the orbital parameters for
a tight eccentric black hole binary with component masses ğ‘€1 =
30ğ‘€(cid:12) and ğ‘€2 = 50ğ‘€(cid:12) and an initial semi-major axis equal to 0.01
AU. We include Post-Newtonian terms up to 2.5th order and observe
the subsequent evolution driven by gravitational wave radiation. The
solid lines in the upper panels show the orbital decay rate as a function
of time. The bottom panels show the relative diï¬€erence between our
simulated results and the analytic approximation. We see that the
relative diï¬€erence in the semi-major axis remains less than 10âˆ’6
AU/year âˆ¼ 5 mm/s, and the relative diï¬€erence in the eccentricity
remains less than 10âˆ’5/ year. The analytic approximation cosely
follows Peterâ€™s Equation (Peters 1964).

ğ‘‘ğ‘
ğ‘‘ğ‘¡

ğ‘‘ğ‘’
ğ‘‘ğ‘¡

(cid:12)
(cid:12)
(cid:12)
(cid:12)GW
(cid:12)
(cid:12)
(cid:12)
(cid:12)GW

= âˆ’

64
5

= âˆ’

304
15

ğº3ğ‘š1ğ‘š2 (ğ‘š1 + ğ‘š2)
ğ‘5ğ‘3 (1 âˆ’ ğ‘’2)7/2
ğº3ğ‘š1ğ‘š2 (ğ‘š1 + ğ‘š2)ğ‘’
ğ‘5ğ‘4 (1 âˆ’ ğ‘’2)5/2

(1 +

73
24

ğ‘’2 +

37
96

ğ‘’4)(124)

(1 +

121
304

ğ‘’2).

(125)

6 CONCLUSIONS

We have developed the deeply optimized high precision open source
few-body toolkit SpaceHub. In this code, several state-of-the-art al-

0200040006000800010000t [yr]0.00.20.40.60.81.0tide [yr1]1e5e=0.6e=0.89e=0.9e=0.91analytic0200040006000800010000t [yr]1011109107tide,err [yr1]0200040006000800010000t [yr]6420Eorb [ yr1]1e4e=0.6e=0.89e=0.9e=0.91analytic0200040006000800010000t [yr]0.000.010.02|Eorb|/|Eorb| Few-body toolkit SpaceHub

17

from this, we introduce regularization into the arbitrary precision
method, which makes it even more eï¬ƒcient in dealing with highly
eccentric systems.

In section 3.2, we discuss the original algorithmic regulariza-
tion chain algorithm AR-chain. In this section, we propose an im-
proved chain coordinate transformation that eliminates the centre-of-
mass reduction. This saves non-negligible CPU time in the few-body
regime, and introduces the active round oï¬€ error compensation into
the AR-chain to form the AR-chain+ method. The new algorithm
is faster and more accurate in the high precision regime, where the
round oï¬€ error is non-negligible.

In Section 3.3, we discuss regularization in higher order symplec-
tic methods. The AR-sym6+ algorithm, a sixth-order regularized
symplectic method with active round oï¬€ error compensation, makes
it possible to accurately and eï¬ƒciently solve extremely eccentric
systems and very close pair-wise encounters with ï¬xed step size.
Consequently, the symplectic nature of the evolving system is pre-
served.

In Section 3.4, we introduce regularization into the Gauss-Radau
method using extended general coordinates. With the regularization
and active round oï¬€ error compensation, the AR-Radau+ algorithm
becomes more eï¬ƒcient in solving the time evolution of extremely
eccentric orbits than the original Gauss-Radau method. At the same
time, it preserves the advantages of the original method in long time
integrations.

SpaceHub is fully open source. All of the new state-of-the-art al-
gorithms discussed above can be accessed via GitHub at https:
//yihanwangastro.github.io/SpaceHubWeb/. Together with
the implementation of additional pair-wise interactions, such as tidal
and Post-Newtonian forces, not to mention a myriad of other per-
formance and optimization tools, SpaceHub undoubtedly competes
with, challenges and even surpasses the most commonly used codes
and gravity integrators used in the ï¬eld today for dealing with astro-
physical problems ranging from extrasolar planetary systems, black
hole binaries, etc., in terms of not only accuracy and precisions but
also speed.

ACKNOWLEDGEMENTS

N.W.C.L. gratefully acknowledges support from the Chilean govern-
ment via Fondecyt Iniciacion Grant 11180005, and acknowledges
ï¬nancial support from Millenium Nucleus NCN19_058 (TITANs).
Bin Liu gratefully acknowledges support from the European Unionâ€™s
Horizon 2020 research and innovation program under the Marie
Sklodowska-Curie grant agreement No. 847523 â€˜INTERACTIONSâ€™.
RP gratefully acknowledges support from NSF award AST-2006839.

DATA AVAILABILITY STATEMENTS

Data are available in a repository and can be accessed via https:
//yihanwangastro.github.io/SpaceHubWeb/.

REFERENCES

Aarseth S. J., Zare K., 1974, Celestial Mechanics, 10, 185
Boekholt T., Portegies Zwart S., 2015, Computational Astrophysics and Cos-

mology, 2, 2

Brouwer D., 1937, AJ, 46, 149
Brouwer D., Clemence G. M., 2013, Methods of celestial mechanics. Elsevier
Bulirsch R., Stoer J., 1966, Numerische Mathematik, 8, 1

MNRAS 000, 1â€“18 (2015)

Figure 12. Test of the general relativistic precession adopting only the ï¬rst
order Post-Newtonian term. The binary consists of two identical solar mass
stars with an initial semi-major axis of 0.1 AU. The eccentricities are initially
set to 0.6, 0.9, 0.95 and 0.99, as indicated by the diï¬€erent colours in the
insets. Upper panel: Calculation results from SpaceHub using the AR-Chain+
method. The dashed black line shows the theoretical expectation for each
value of the eccentricity as described by Equation 123. Bottom panel: The
relative diï¬€erence between the results of our computations and the analytic
expectation, as a function of time.

gorithms are provided that are applicable to a variety of astrophysi-
cal few-body problems. The new algorithms include: an algorithmic
regularization chain with active round oï¬€ error compensation AR-
Chain+, a regularized arbitrary precision algorithm AR-ABITS, a
regularized higher order symplectic method with active round oï¬€ er-
ror compensation AR-sym6+ and a regularized Gauss-Radau method
with active round oï¬€ error compensation AR-Radau+. By comparing
to popular high precision few-body codes via various applications to
the time evolution of various astrophysical test cases, we show that
SpaceHub consistently provides the most precise, accurate and fastest
algorithm for most speciï¬c astrophysical problems of interest in the
few-body limit.

We begin by brieï¬‚y reviewing the existing Bulirsch-Stoer-based
high precision integration methods and Gauss-Radau-based meth-
ods, and discuss the improvements we have made on these algo-
rithms. In Section 3.1, we discuss the arbitrary precision method
with extended ï¬‚oating point precision. We then go on to discuss our
implementation and improvements in our new regularized arbitrary
precision method AR-ABITS. The AR-ABITS method achieves ar-
bitrary precision based on the GBS extrapolation. By adopting an
optimal extrapolation step sequence and a ï¬ne-tuned extrapolation
process, the round oï¬€ error can be signiï¬cantly reduced with the
provided bits ï¬‚oating-point numbers. We show that to achieve the
same arbitrary precision, AR-BITS is roughly 1-2 orders of magni-
tude faster than the popular arbitrary precision code Brutus. Apart

020406080100t [yr]0.00.20.40.60.8GR [rad]e=0.99e=0.95e=0.9e=0.6analytic020406080100t [yr]108106104102GR,err [rad]e=0.99e=0.95e=0.9e=0.618 Wang et al.

Figure 13. Test of the orbital evolution due to gravitational wave radiation using up to 2.5th order in the Post-Newtonian terms. The binary has component
masses of 30 M(cid:12) and 50 M(cid:12) with an initial semi-major axis equal to 0.01 AU. The eccentricities are initially set to 0.894, 0.896, 0.898 and 0.9, as indicated
by the colour scheme deï¬ned in each inset. Upper panels: Calculation results from SpaceHub using the AR-Chain+ method and the analytic results calculated
from Equations 124 and 125.Bottom panels: The relative diï¬€erence between the results of our computations and the analytic expectation, as a function of time.

Quinn T., Tremaine S., 1990, The Astronomical Journal, 99, 1016
Rantala A., Pihajoki P., Mannerkoski M., Johansson P. H., Naab T., 2020,

Monthly Notices of the Royal Astronomical Society, 492, 4131

Rein H., Spiegel D. S., 2014, MNRAS
Soï¬€el M. H., 1989, Relativity in Astrometry, Celestial Mechanics and

Geodesy

Stetter F., 1968, Mathematics of Computation, 22, 661â€“661
Wang Y.-H., Leigh N., Yuan Y.-F., Perna R., 2018, MNRAS, 475, 4595
Wang Y.-H., Leigh N., Sesana A., Perna R., 2019a, MNRAS, 482, 3206
Wang Y.-H., Leigh N. W. C., Sesana A., Perna R., 2019b, MNRAS, 490, 2627
Wang Y.-H., Perna R., Leigh N. W. C., 2020a, MNRAS, 496, 1453
Wang Y.-H., Perna R., Leigh N. W. C., 2020b, ApJ, 891, L14
Wang Y.-H., Leigh N. W. C., Perna R., Shara M. M., 2020c, ApJ, 905, 136
Yoshida H., 1990, Physics Letters A, 150, 262
Zare K., 1974, Celestial Mechanics, 10, 207

This paper has been typeset from a TEX/LATEX ï¬le prepared by the author.

Damour T., Deruelle N., 1985, Annales de lâ€™I.H.P. Physique thÃ©orique, 43,

107

Deuï¬‚hard P., 1983, Numerische Mathematik, 41, 399
Everhart E., 1985, International Astronomical Union Colloquium, 83, 185
Fukushima T., 1996, AJ, 112, 1298
Gragg W. B., 1965, SIAM Journal on Numerical Analysis, 2, 384
Heggie D. C., 1974, Celestial Mechanics, 10, 217
Hut P., 1981, A&A, 99, 126
Kahan W., 1965, Commun. ACM, 8, 40
Levison H. F., Duncan M. J., 1994, Icarus, 108, 18
Liu B., Lai D., Wang Y.-H., 2019a, ApJ, 881, 41
Liu B., Lai D., Wang Y.-H., 2019b, ApJ, 883, L7
Mikkola S., Aarseth S. J., 1990, Celestial Mechanics and Dynamical Astron-

omy, 47, 375

Mikkola S., Aarseth S. J., 1993, Celestial Mechanics and Dynamical Astron-

omy, 57, 439

Mikkola S., Aarseth S., 2002, Celestial Mechanics and Dynamical Astronomy,

84, 343

Mikkola S., Merritt D., 2008, The Astronomical Journal, 135, 2398
Mikkola S., Tanikawa K., 1999a, Celestial Mechanics and Dynamical As-

tronomy, 74, 287

Mikkola S., Tanikawa K., 1999b, MNRAS, 310, 745
Perna R., Wang Y.-H., Farr W. M., Leigh N., Cantiello M., 2019, ApJ, 878,

L1

Peters P. C., 1964, Physical Review, 136, B1224
Press W. H., Flannery B. P., Teukolsky S. A., 1986, Numerical recipes. The

art of scientiï¬c computing

Press W. H., Teukolsky S. A., Vetterling W. T., Flannery B. P., 2002, Numer-

ical recipes in C++ : the art of scientiï¬c computing

Preto M., Tremaine S., 1999, AJ, 118, 2532

MNRAS 000, 1â€“18 (2015)

0204060t [yr]1.11.00.90.8da/dt [au yr1]1e4e=0.894e=0.896e=0.898e=0.9analytic0204060t [yr]1010109108107106da/dterr [au yr1]0204060t [yr]8642de/dt [yr1]1e3e=0.894e=0.896e=0.898e=0.9analytic0204060t [yr]109108107106105de/dterr [yr1]