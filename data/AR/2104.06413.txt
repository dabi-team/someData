1
2
0
2

r
p
A
9
2

]

R
S
.
h
p
-
o
r
t
s
a
[

2
v
3
1
4
6
0
.
4
0
1
2
:
v
i
X
r
a

MNRAS 000, 1‚Äì18 (2015)

Preprint 3 May 2021

Compiled using MNRAS LATEX style Ô¨Åle v3.0

SpaceHub: A high-performance gravity integration toolkit for few-body
problems in astrophysics

Yi-Han Wang,1‚òÖ Nathan W. C. Leigh,3,4 Bin Liu,5,6 Rosalba Perna1,2
1Department of Physics and Astronomy, Stony Brook University, Stony Brook, NY, 11794, USA
2Center for Computational Astrophysics, Flatiron Institute, 162 5th Avenue, New York, NY 10010, USA
3Departamento de Astronomia, Facultad de Ciencias Fisicas y Matematicas, Universidad de Concepcion, Concepcion, Chile
4Department of Astrophysics, American Museum of Natural History, Central Park West and 79th Street, New York, NY 10024
5Niels Bohr International Academy, Niels Bohr Institute, Blegdamsvej 17, 2100 Copenhagen, Denmark
6Cornell Center for Astrophysics and Planetary Science, Department of Astronomy, Cornell University, Ithaca, NY 14853, USA

Accepted XXX. Received YYY; in original form ZZZ

ABSTRACT
We present the open source few-body gravity integration toolkit SpaceHub. SpaceHub oÔ¨Äers a variety of algorithmic methods,
including the unique algorithms AR-Radau, AR-Sym6, AR-ABITS and AR-chain+ which we show out-perform other methods
in the literature and allow for fast, precise and accurate computations to deal with few-body problems ranging from interacting
black holes to planetary dynamics. We show that AR-Sym6 and AR-chain+, with algorithmic regularization, chain algorithm,
active round-oÔ¨Ä error compensation and a symplectic kernel implementation, are the fastest and most accurate algorithms to
treat black hole dynamics with extreme mass ratios, extreme eccentricities and very close encounters. AR-Radau, the Ô¨Årst
regularized Radau integrator with round oÔ¨Ä error control down to 64 bits Ô¨Çoating point machine precision, has the ability to
handle extremely eccentric orbits and close approaches in long-term integrations. AR-ABITS, a bit eÔ¨Écient arbitrary precision
method, achieves any precision with the least CPU cost compared to other open source arbitrary precision few-body codes. With
the implementation of deep numerical and code optimization, these new algorithms in SpaceHub prove superior to other popular
high precision few-body codes in terms of performance, accuracy and speed.

Key words: gravitation ‚Äì methods: numerical ‚Äì stars: black holes ‚Äì stars: kinematics and dynamics ‚Äì planetary systems

1 INTRODUCTION

Few-body gravity integrators are fundamental to the study of black
hole and planetary dynamics. The resulting simulations capture the
time evolution of the orbital dynamics, evolving the system forward
in time due to pair-wise gravitational interactions. One of the primary
challenges these integrators face is accurately capturing the integra-
tion of eccentric orbits and close approaches between particles. This
is because the integrations require extreme accuracy and precision in
the vicinity of the singularity, where the distance ùëü between particles
becomes very small, which is made challenging due to the 1/ùëü2 scal-
ing characteristic of the Newtonian gravitational acceleration. The
most obvious solution is to choose a very small time step ùëü ‚Üí 0, but
this can be very time consuming computationally.

The introduction of regularization techniques to handle the com-
putations in the vicinity of the singularity revolutionized the Ô¨Åeld
of gravitational dynamics. This stimulated the development of a
number of mathematical transformations that can be implemented
to improve accuracy and precision. One prominent example in-
cludes Kustaanheimo-Stiefel (KS) regularization and applying the
KS transformation to the perturbed two-body problem. Aarseth &
Zare (1974); Heggie (1974); Zare (1974) then introduced this trans-

‚òÖ E-mail: yihan.wang.1@stonybrook.edu

¬© 2015 The Authors

formation into general N-body problems, and Levison & Duncan
(1994) applied it to planetary dynamics. Later on, new Logarithmic
Hamiltonian regularization with a leapfrog scheme was invented by
Mikkola & Tanikawa (1999a,b) and Preto & Tremaine (1999). This
method can accurately and eÔ¨Éciently capture the dynamics in the
vicinity of the singularity using a regularized equation of motion,
but the method becomes invalid in the limit of extremely large mass
ratios. To overcome this challenge, Mikkola & Aarseth (2002) in-
troduced the time-transformed leapfrog scheme, which allows for
an arbitrary regularization mass coeÔ¨Écient function to deal with
extreme mass ratios during close approaches.

All regularized methods that include the algorithmic regularization
introduced by Mikkola & Merritt (2008) are based on the leapfrog
scheme, since it can maintain the symplectic nature of the system
when adaptive stepping is not implemented. Because the method is
symplectic, it adheres to Hamilton‚Äôs equations and time-reversibility
is preserved. However, the leapfrog method is only a second order
method, and going to higher orders can greatly improve accuracy and
precision. Consequently, the rational Bulirsch-Stoer(BS) extrapola-
tion (Gragg 1965; Press et al. 1986) was introduced into the regular-
ization method. This extrapolation method can eÔ¨Éciently construct
higher order methods that adhere to the leapfrog scheme. With the
BS extrapolation and regularization techniques now developed, ef-
Ô¨Åcient high precision integrations can be performed that accurately

 
 
 
 
 
 
2 Wang et al.

treat extremely eccentric orbits and very close pair-wise particle ap-
proaches. These problems correspond to prompt events, which may
or may not occur repeatedly. But what if long term integrations are
required, where such close pair-wise approaches do occur regularly?
Indeed, the computations become more challenging as longer time
scale integrations are needed. Examples include extremely eccentric
systems that require integrating over many orbits, such as the grav-
itational wave-induced inspiral of eccentric binaries down to the
kilo-Hertz level, high eccentricity tidal dissipation, and so on. The
reason problems arise is because, for integration methods based on
extrapolation, the higher order extrapolation reduces the truncation
error but the round oÔ¨Ä error becomes signiÔ¨Åcant due to the Ô¨Ånite bit
Ô¨Çoating-point number arithmetic. The resulting large round oÔ¨Ä errors
can severely reduce the precision and destroy the long term perfor-
mance of high precision methods. Therefore, reducing and properly
managing round oÔ¨Ä errors is essential in high precision integration
methods.

For systems where extreme approaches between particles arise,
the close value subtraction of the Ô¨Çoating-point numbers that de-
Ô¨Åne the positions of the particles causes several signiÔ¨Åcant digits
to be lost. This introduces round oÔ¨Ä errors into the integrations. To
solve this problem, a chain coordinate system (Mikkola & Aarseth
1993) was invented to evaluate the relative distances during close
encounters. With this, the relative distances between particles are
directly replaced by the chain coordinates, thus avoiding the close
value subtraction. However, the chain coordinates need to be recon-
structed and updated after each time step. The problem that arises
here is that frequent chain coordinate updates involve large quanti-
ties of Ô¨Çoating-point arithmetic and introduces extra round oÔ¨Ä errors
into long term integrations. Branched tree coordinates are more opti-
mized for maintaining the shortest relative position between particles
and can alleviate this problem. Rantala et al. (2020) implemented the
minimum spanning tree in their AR-Chain based code MSTAR, and
showed that branched tree coordinates are more eÔ¨Écient, with less
round oÔ¨Ä error accumulation than chain coordinates in the large-N
(‚àº 400) regime.

Close value subtractions are not the only source of round oÔ¨Ä er-
rors that can aÔ¨Äect long term integration performance. In BS-based
methods, round oÔ¨Ä errors propagate and can be magniÔ¨Åed through the
extrapolation table. With higher order extrapolations, the round oÔ¨Ä
errors become more signiÔ¨Åcant. Theoretically, the BS extrapolation
can achieve arbitrarily high order, but it can only achieve 14-16th
order for double precision Ô¨Çoating-point numbers. Consequently,
even if the BS extrapolation is very eÔ¨Écient in achieving higher or-
der symplectic methods such as the leapfrog scheme, the precision
is limited by the extrapolation. More importantly, the extrapolation
process is not time symmetric, which breaks the symplectic nature of
the system even if Ô¨Åxed time steps are adopted. Therefore, alternative
methods are needed to achieve higher order results and maintain time
symmetry.

For long term integrations, where many time steps are needed,
another source of round oÔ¨Ä error becomes non-negligible. During
the integration, small incremental steps can be used to better evolve
speciÔ¨Åcally physical quantities in each step. But this can introduce
large diÔ¨Äerence additions between Ô¨Çoating-point numbers, which will
in turn introduce signiÔ¨Åcant round oÔ¨Ä errors into the integration due
to the Ô¨Ånite bit truncation. This kind of round oÔ¨Ä error accumulates
continuously over the course of the integration. To alleviate this prob-
lem, Quinn & Tremaine (1990) proposed an active round oÔ¨Ä error
compensation method in Ô¨Çoating-point number arithmetic. This was
introduced into the Gauss-Radau (Everhart 1985) scheme by Rein
& Spiegel (2014), which proved useful in slowing down the round

MNRAS 000, 1‚Äì18 (2015)

oÔ¨Ä error accumulation in long term integrations. However, the raw
Gauss-Radau method is cumbersome in dealing with extreme eccen-
tricities and very close pair-wise encounters, causing the integrations
to lose signiÔ¨Åcant precision for these speciÔ¨Åc problems.

In this paper, we present a new few-body gravity integration
toolkit called SpaceHub. It contains various previously developed
algorithms in addition to several new and novel techniques which
improve the speed, accuracy and precision of the calculations even
further. This includes state-of-the-art algorithms that can eÔ¨Éciently
deal with both extreme eccentricities and extreme mass ratios even
for long term integrations. Problems which have already been inves-
tigated using this code include interactions between compact object
binaries and supermassive black hole binaries (Wang et al. 2018,
2019a,b; Liu et al. 2019a,b), formation of black hole binaries in
dense star clusters (Perna et al. 2019), interactions between stars and
planetary systems (Wang et al. 2020b,a,c).

The paper is organized as follows. In Section 2, we introduce
and brieÔ¨Çy review several previously developed few body integration
techniques, including the regularization algorithm, the chain algo-
rithm, active error compensation and the Bulirsch-Stoer extrapola-
tion. We explicitly highlight our improvements to those techniques,
and introduce three new methods in SpaceHub to accomplish this
goal. In Section 3, we discuss how SpaceHub can easily construct
new algorithms and our optimization implementations to improve
performance. In section 4, we present various tests of our newly
developed algorithms in SpaceHub, and compare to other popular
high precision few body codes. We summarize our main results and
present our conclusions in Section 5.

2 REVIEW OF HIGH PRECISION FEW-BODY

INTEGRATION METHODS

There are several integration methods, including AR-Chain, IAS15
and Brutus, that can achieve very high precision with low relative
energy errors. In this section we will review these integration schemes
and point out any shortcomings of the integration methods. This will
help provide a broader context to then present the improvements
made by SpaceHub which will be discussed in Sec. 3.

2.1 AR-chain

For the N-body problem in the small-N regime, stochastic close pair-
wise approaches and high eccentricity orbits in collisional systems
can signiÔ¨Åcantly hurt the integration accuracy. Due to the strong inter-
action around the closest approach, very small time steps are required
to properly resolve the dynamics in the vicinity of the singularity in
conventional step control methods. But increasing the number of
time steps severely slows down the integration and, especially for
longer term integrations, more Ô¨Çoating point arithmetic introduces
more round oÔ¨Ä errors. In the past few decades, several methods have
been invented to tackle this problem, including KS regularization,
the Logarithmic Hamiltonian method (LogH) (Mikkola & Tanikawa
1999a,b; Preto & Tremaine 1999), the time-transformed leapfrog
(TTL) regularization scheme(Mikkola & Aarseth 2002) and general-
ized midpoint regularization (GAR)(Stetter 1968). By transforming
the equations of motion, the combination of all of these regulariza-
tion methods can eÔ¨Éciently resolve close pair-wise approaches and
high eccentricity orbits. Mikkola & Merritt (2008) gathered all the
three regularization schemes (LogH, TTL and GAR) to form the Al-
gorithmic Regularization scheme in his AR-chain algorithm to deal
with velocity-dependent problems for extreme eccentricity cases and

close pair-wise approaches between particles. Here we brieÔ¨Çy review
the regularization methods implemented in AR-chain.

independent variables ùúî and Œ© to perform the require transformations
in the equations of motion,

Few-body toolkit SpaceHub

3

2.1.1 LogH regularization

For systems with equations of motion for each particle,
ùëëxùëñ
ùëëùë°
ùëëvùëñ
ùëëùë°

= gùëñ + fùëñ

= vùëñ

(1)

(2)

where xùëñ, vùëñ, gùëñ and fùëñ are, respectively, the position, velocity, Newto-
nian acceleration and other accelerations in addition to the Newtonian
one acting on particle ùëñ. The LogH regularization scheme introduces
additional quantities, namely ùëá, ùëà and ùêµ, to transform the equations
of motion during the integration. Here, ùëá is the total kinetic energy
of the system, ùëà is the absolute value of the total Newtonian potential
energy of the system and ùêµ is the binding energy of the system,

ùëá

=

ùëà =

‚àëÔ∏Å

ùëñ
‚àëÔ∏Å

ùëñ< ùëó

1
2

ùëöùëñv2
ùëñ ,

ùëöùëñùëö ùëó
|xùëñ ‚àí x ùëó |

,

ùêµ = ùëà ‚àí ùëá .

(3)

(4)

(5)

Thus, the regularized algorithm can be described in the time-
symmetric leap-frog form as follows

D(‚Ñé):

K(‚Ñé):

ùëá

=

‚àëÔ∏Å

ùëöùëñv2
ùëñ

1
2
ùëñ
‚Ñé/(ùëá + ùêµ)

=

ùëëùë°
ùë° ‚Üí ùë° + ùëëùë°
xùëñ ‚Üí xùëñ + vùëñ ùëëùë°

ùëà =

‚àëÔ∏Å

ùëöùëñùëö ùëó
|xùëñ ‚àí x ùëó |

ùëëùë°

=

ùëñ< ùëó
‚Ñé/ùëà

ùêµ ‚Üí ùêµ ‚àí

ùëëùë°

2

‚àëÔ∏Å

ùëñ

ùëöùëñvùëñ ¬∑ fùëñ

vùëñ ‚Üí vùëñ + (gùëñ + fùëñ)ùëëùë°

ùêµ ‚Üí ùêµ ‚àí

ùëëùë°

2

‚àëÔ∏Å

ùëñ

ùëöùëñvùëñ ¬∑ fùëñ

(6)

(7)

(8)

(9)

(10)

(11)

(12)

(13)

(14)

Then, a complete one step integration can be constructed as
D(‚Ñé/2)K(‚Ñé)D(‚Ñé/2) or K(‚Ñé/2)D(‚Ñé)K(‚Ñé/2), where ‚Ñé is the time
step.

2.1.2 TTL regularization

For systems with extreme particle mass ratios, the regularization
ùëöùëñ ùëö ùëó
function ùëà = (cid:205)ùëñ< ùëó
|xùëñ‚àíx ùëó | and ùëá + ùêµ in the LogH method can end up
being dominated by the most massive pair of particles in the system.
Therefore, even if close encounters between extreme mass ratio pairs
occur during the integration, it can happen that the step size is not
being properly regularized.

In order to compensate for this, instead of using ùëà and ùëá + ùêµ as
the regularization functions, Mikkola & Aarseth (2002) proposed two

Œ© =

ùëëùúî
ùëëùë°

=

‚àëÔ∏Å

ùëñ< ùëó

‚àëÔ∏Å

ùëñ

Œ©ùëñ ùëó
|xùëñ ‚àí x ùëó |

ùúïŒ©
ùúïxùëñ

¬∑ vùëñ, ùúî(0) = Œ©(0) ,

(15)

(16)

where Œ©ùëñ ùëó is a function of the particle masses. Conventionally, Œ©ùëñ ùëó =
ùëöùëñùëö ùëó can be adopted, which is mathematically equivalent to the
LogH method. However, alternative choices can be made, such as
the mass averaged function,

Œ©ùëñ ùëó

=

(cid:26) Àúùëö2
0

if ùëöùëñùëö ùëó < ùúñ Àúùëö2
otherwise .

(17)

With this kind of regularization function, the contribution from small
mass pairs becomes more dominant in the regularization function
such that close encounters between low-mass particles can be cor-
rectly captured. Here, Àúùëö2 = (cid:205)ùëñ< ùëó 2ùëöùëñùëö ùëó /(ùëÅ (ùëÅ ‚àí 1)) is the mean
mass of the system with N particles and ùúñ is a parameter to set the
threshold where only particle pairs with mass products small enough
can contribute to the regularization function. In this way, large mass
pairs do not contribute to the regularization; hence the contribution
of the small mass pairs in the regularization function will not be
overwhelmed due to the contribution from large mass pairs. Mikkola
& Aarseth (2002) suggested the value of ùúñ to be 10‚àí3 in order to
correctly capture the small mass pair interactions.

The leap-frog scheme with TTL regularization can be written in

form of D(‚Ñé):

=

ùëëùë°
‚Ñé/ùúî
ùë° ‚Üí ùë° + ùëëùë°
xùëñ ‚Üí xùëñ + vùëñ ùëëùë°

K(‚Ñé):

Œ© =

ùëëùë°

=

Œ©ùëñ ùëó
|xùëñ ‚àí x ùëó |

‚àëÔ∏Å

ùëñ< ùëó
‚Ñé/Œ©

2

ùëëùë°

‚àëÔ∏Å

ùúî ‚Üí ùúî +

ùúïŒ©
ùúïxùëñ
vùëñ ‚Üí vùëñ + (gùëñ + fùëñ)ùëëùë°
ùúïŒ©
ùúïxùëñ

ùúî ‚Üí ùúî +

‚àëÔ∏Å

ùëëùë°

2

ùëñ

ùëñ

(18)

(19)

(20)

(21)

(22)

(23)

(24)

(25)

¬∑ vùëñ

¬∑ vùëñ

with ùúî(0) = Œ©(0).

2.1.3 Generalized midpoint method

To construct a leapfrog scheme, the variables on the right side of the
equations of motion should be independent of the variables on the
left side. However, if the external acceleration fùëñ is velocity depen-
dent, then the kick step becomes problematic. In this case, vùëñ needs
implicit iteration on both sides of the equation which breaks the time
symmetry of the leapfrog scheme,

vùëñ ‚Üí vùëñ + (gùëñ + fùëñ (vùëñ, ...))ùëëùë° .

(26)

In order to preserve the time symmetry of the leapfrog scheme, Stetter
(1968); Mikkola & Aarseth (2002) introduced the pseudo-velocity wùëñ
in the kick-step procedure in order to to maintain the time symmetry.

MNRAS 000, 1‚Äì18 (2015)

4 Wang et al.

For systems with equations of motion of the form

ùëëxùëñ
ùëëùë°
ùëëvùëñ
ùëëùë°

= vùëñ

= gùëñ + fùëñ (x) + fùëñ,ùë£ (x, v)

(27)

(28)

where fùëñ (x) is the external velocity-independent acceleration and
fùëñ,ùë£ (x, v) are the external velocity-dependent accelerations,
the
leapfrog scheme can be constructed in the following way for the
LogH method,

D(‚Ñé):

K(‚Ñé):

ùëá

=

‚àëÔ∏Å

ùëöùëñv2
ùëñ

1
2
ùëñ
‚Ñé/(ùëá + ùêµ)

=

ùëëùë°
ùë° ‚Üí ùë° + ùëëùë°
xùëñ ‚Üí xùëñ + vùëñ ùëëùë°

ùëöùëñùëö ùëó
|xùëñ ‚àí x ùëó |

ùëà =

‚àëÔ∏Å

ùëñ< ùëó
ùëëùë° = ‚Ñé/ùëà

Kùë£ (ùëëùë°/2):

vùëñ ‚Üí vùëñ + (gùëñ + fùëñ + fùëñ,ùë£ (x, w))

ùëëùë°

2

Kùë§ (ùëëùë°):

wùëñ ‚Üí wùëñ + (gùëñ + fùëñ + fùëñ,ùë£ (x, v))ùëëùë°
ùêµ ‚Üí ùêµ ‚àí ùëëùë° ‚àëÔ∏Å
ùëñ

ùëöùëñvùëñ ¬∑ (fùëñ + fùëñ,ùë£ (x, v))

Kùë£ (ùëëùë°/2):

vùëñ ‚Üí vùëñ + (gùëñ + fùëñ + fùëñ,ùë£ (x, w))

ùëëùë°

2

(29)

(30)

(31)

(32)

(33)

(34)

(35)

(36)

(37)

(38)

that

Note

wùëñ (0)=vùëñ (0).
step
with
Kv (ùëëùë°/2)Kw (ùëëùë°)Kv (ùëëùë°/2)
as
can
Kw (ùëëùë°/2)Kv (ùëëùë°)Kw (ùëëùë°/2). The same scheme can also be
obtained for the TTL method with external velocity-dependent
accelerations.

sub-leapfrog

constructed

also

the

be

2.1.4 Chain coordinates

The AR-chain method was invented to deal with close encounters
and extremely eccentricity orbits, thus the relative positions between
particles in the integrated system can be very small. To evaluate the
acceleration between close particles, the relative position between
two close particles is needed. This calculation requires a close value
subtraction arithmetic between two Ô¨Çoating-point numbers, which
can cause fast round oÔ¨Ä error accumulation. To solve this problem
Mikkola & Aarseth (1990); Mikkola & Aarseth (1993) introduced the
chain coordinates into the few-body integration, where the relative
positions between particles are calculated from the initial conditions
and converted to chain coordinates. Instead of evolving the original
Cartesian coordinates, the relative positions (i.e., chain coordinates)
will be evolved. Since the chain coordinates are constructed in a way
that the shortest few relative positions are always kept in the chain, the
close value subtraction between close positions can be replaced by the
chain coordinates directly. This coordinate transformation can reduce
the round oÔ¨Ä errors from close value subtractions between Ô¨Çoating-
point numbers, thus giving better error control in the integration. The

MNRAS 000, 1‚Äì18 (2015)

ùëá11

(cid:45)
ùëá21 ‚Üê ùëá22
(cid:45)

(cid:45)

ùëá31 ‚Üê ùëá32 ‚Üê ùëá33

(cid:45)

(cid:45)
ùëá41 ‚Üê ùëá42 ‚Üê ùëá43 ‚Üê ùëá44
...
...

(cid:45)

...

...

Table 1. Gragg-Bulirsch-Stoer extrapolation table.

transformation from Cartesian coordinates to chain coordinates can
be written as

Xùëò = xùëñùëò+1 ‚àí xùëñùëò
Vùëò = vùëñùëò+1 ‚àí vùëñùëò

(39)

(40)

with ùëò = 1, 2, ..., ùëÅ ‚àí 1 and ùëñ is the index of the Cartesian coordinates
in chain coordinates. Then the inverse transformation can be written
as

Àúxùëñ1
Àúxùëñùëò+1
Àúvùëñ1
Àúvùëñùëò+1

= 0

=

Àúxùëñùëò + Xùëò

= 0

=

Àúvùëñùëò + Vùëò

followed by a reduction to the centre of mass reference frame

Àúxcm =

Àúvcm =

x ùëó

v ùëó

=

=

ùëö ùëó

ùëö ùëó

‚àëÔ∏Å

ùëó
‚àëÔ∏Å

ùëó

‚àëÔ∏Å

ùëó
‚àëÔ∏Å

ùëö ùëó Àúx ùëó /

ùëö ùëó Àúv ùëó /

ùëó
Àúx ùëó ‚àí Àúxcm
Àúv ùëó ‚àí Àúvcm.

The equations of motion of the chain coordinates are then

ùëëXùëò
ùëëùë°
ùëëVùëò
ùëëùë°

= Vùëò ,

ùëò = 1, 2, ..., ùëÅ ‚àí 1

= gùëñùëò+1 ‚àí gùëñùëò + fùëñùëò+1 ‚àí fùëñùëò + fùëñùëò+1,ùë£ ‚àí fùëñùëò ,ùë£ .

(41)

(42)

(43)

(44)

(45)

(46)

(47)

(48)

(49)

(50)

With the new equations of motion, every position subtraction r ùëó ùëò
between x ùëó and xùëò (where ùëó and ùëò are the chain coordinates indices)
is

r ùëó ùëò =

¬±(xùëò ‚àí x ùëó )
¬±X ùëó
¬±(X ùëó + X ùëó+1)

Ô£±Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥
Ô£≥

if ùëò > ùëó ¬± 2 (far pair)
if ùëò = ùëó ¬± 1 (close pair)
if ùëò = ùëó ¬± 2 (intermediate pair) .

(51)

2.1.5 Gragg-Bulirsch-Stoer extrapolation

The algorithmic regularization and chain coordinates can be con-
structed in the form of the leapfrog scheme. However, by itself, the
leapfrog method is only a two order method. This makes it ineÔ¨É-
cient in achieving high precision. To tackle this problem and achieve
high precision, higher order methods are usually needed. The Gragg-
Bulirsch-Stoer extrapolation (Gragg 1965; Bulirsch & Stoer 1966;
Press et al. 1986) can construct higher order results from a series of
lower order results through an extrapolation table: For integrations
with macro step ùêª, the Ô¨Årst column of Table 1 will be Ô¨Ålled with ba-
sic lower order methods with ùëõùëñ sub-steps ‚Ñéùëõùëñ = ùêª/ùëõùëñ. Then higher

order results can be constructed recursively by extrapolation,

ùëáùëñ, ùëó = ùëáùëñ, ùëó‚àí1 +

ùëáùëñ, ùëó‚àí1 ‚àí ùëáùëñ‚àí1, ùëó‚àí1
(ùëõùëñ/ùëõùëñ‚àí ùëó+1)2 ‚àí 1

.

(52)

If the basic lower order method (such as the leapfrog scheme) is only
in even powers of the time-step, the Ô¨Ånal extrapolated result ùëáùëò,ùëò has
ùëù + 2(ùëò ‚àí 1)-th order precision, where ùëù is the order of the basic
integration method used in the Ô¨Årst column. If the basic integration
method is non-symmetric in time, then ùëáùëò,ùëò has ùëù + ùëò ‚àí 1-th order
precision. Therefore, GBS extrapolation is eÔ¨Écient in constructing
higher order methods for time symmetric integration schemes like
leapfrog. Since the regularization chain algorithm can be written in
the form of a time-symmetric leapfrog scheme, where all odd powers
of the time-steps vanish, the GBS extrapolation is adopted in the
original AR-chain (Mikkola & Merritt 2008) to achieve higher order
accuracy and precision.

2.2 IAS15

IAS15 (Rebound, Rein & Spiegel 2014) is a Gauss-Radau based in-
tegration method with improvements on step size control and round
oÔ¨Ä error reduction. For few-body problems without high eccentric-
ities and close pair-wise encounters, it performs very well in terms
of maintaining low relative energy errors and minimizing long term
unbiased round oÔ¨Ä error accumulation (Brouwer 1937; Brouwer &
Clemence 2013). In this subsection, we will brieÔ¨Çy introduce the the
Gauss-Radau method and the main improvements implemented in
IAS15.

2.2.1 Gauss-Radau integration

Everhart (1985) introduced a modiÔ¨Åed 15th order Runge-Kutta
method with Gauss-Radau spacings to achieve very high precision
in few-body problems. This method solves the general equation

ùë¶(cid:48)(cid:48) = ùêπ (ùë¶, ùë¶(cid:48), ùë°).

(53)

In celestial mechanics, ùë¶ denotes the positions of the particles, thus
ùêπ denotes the accelerations. Everhart (1985) expanded the equation
into a truncated Taylor series,

ùë¶(cid:48)(cid:48)|‚Ñé ‚àº ùë¶(cid:48)(cid:48)

0 + ùëé1ùë° + ùëé2ùë°2 + ... + ùëé7ùë°7 .

(54)

Using the dimensionless time-step ‚Ñé = ùë°/ùëëùë° and ùëèùëñ = ùëéùëñùë°ùëñ, the
equation can be rewritten as

ùêπ = ùë¶(cid:48)(cid:48)|‚Ñé =‚àº ùë¶(cid:48)(cid:48)

0 + ùëè1‚Ñé + ùëè2‚Ñé2 + ... + ùëè7‚Ñé7 .

(55)

After ùë¶(cid:48)(cid:48) is found at ‚Ñé1=0, the value of ùëèùëñ can be found recursively at
each time step. This is done by evaluating ùë¶(cid:48)(cid:48) at a series of suitably
chosen Gauss-Radau spacings ‚Ñé1, ‚Ñé2, ...‚Ñé8 within the interval of ‚Ñé
between 0 and 1. Then, at the end of the macro step h, the accel-
erations ùë¶(cid:48)(cid:48) can be approximated by this Taylor series. The corre-
sponding ùë¶(cid:48) (velocity) and ùë¶ (position) values can thus be calculated
analytically by integrating ùë¶(cid:48)(cid:48) over ùëëùë°,

ùë¶(cid:48)|‚Ñé ‚àº ùë¶(cid:48)

0 + ‚Ñéùëëùë°

(cid:18)

ùë¶(cid:48)(cid:48)
0 +

(cid:18)

‚Ñé

ùëè0 +

(cid:18)

2‚Ñé
3

(cid:19)(cid:19)(cid:19)

ùëè1 + ...

(56)

ùë¶|‚Ñé ‚àº ùë¶0 + ùë¶(cid:48)
0

‚Ñéùëëùë° +

(cid:18)

ùë¶(cid:48)(cid:48)
0 +

(cid:18)

‚Ñé

3

ùëè0 +

(cid:18)

‚Ñé

2

(cid:19) (cid:19)(cid:19)

.(57)

ùëè1 + ...

2
‚Ñé2ùëëùë°2

2

Few-body toolkit SpaceHub

5

The ùëèùëñ are evaluated at each step by repeatedly iterating over the
Gauss-Radau spacing ‚Ñéùëñ, where

ùëè1 = ùê∂71ùëî7 + ùê∂61ùëî6 + ùê∂51ùëî5 + ... + ùê∂11ùëî1
ùëè2 = ùê∂72ùëî7 + ùê∂62ùëî6 + ... + ùê∂22ùëî2
ùëè3 = ùê∂73ùëî7 + ... + ùê∂33ùëî3
...
ùëè7 = ùê∂77ùëî7

(58)

(59)

and
ùëî1 = (ùë¶(cid:48)(cid:48)|‚Ñé2 ‚àí ùë¶(cid:48)(cid:48)|‚Ñé1 )ùëÖ21
ùëî2 = ((ùë¶(cid:48)(cid:48)|‚Ñé3 ‚àí ùë¶(cid:48)(cid:48)|‚Ñé1 )ùëÖ31 ‚àí ùëî1)ùëÖ32
ùëî3 = (((ùë¶(cid:48)(cid:48)|‚Ñé4 ‚àí ùë¶(cid:48)(cid:48)|‚Ñé1 )ùëÖ41 ‚àí ùëî1)ùëÖ42 ‚àí ùëî2)ùëÖ43
...
ùëî7 = (...(((ùë¶(cid:48)(cid:48)|‚Ñé8 ‚àí ùë¶(cid:48)(cid:48)|‚Ñé1 )ùëÖ81 ‚àí ùëî1)ùëÖ82 ‚àí ùëî2)ùëÖ43... ‚àí ùëî6)ùëÖ87
where ùê∂ùëñ ùëó and ùëÖùëñ ùëó are constants that can be calculated from ‚Ñéùëñ.
This expansion of ùë¶(cid:48)(cid:48) up to ùë°7 with Gauss-Radau spacing has high
precision, reaching 15th order.

2.2.2 Active round oÔ¨Ä error reduction

For higher order integration methods, the truncation error can be
eÔ¨Éciently reduced by shrinking the step size. However, the round
oÔ¨Ä error from the arithmetic of Ô¨Ånite bit Ô¨Çoating point numbers
becomes dominant in high precision integration methods. Therefore,
by increasing the order of the integration method or shrinking the
step size we cannot obtain more precise solutions. On the contrary,
shrinking the step size means more Ô¨Çoating point arithmetic that will
accumulate more round oÔ¨Ä errors, leading to less accurate solutions.
For Ô¨Ånite bit Ô¨Çoating-point numbers with N mantissa bits, the relative
number precision is
eps = 2‚àí( ùëÅ ‚àí1)

(60)

for double precision Ô¨Çoating-point numbers with 53 mantissa bits,
this is ‚àº 2.2√ó10‚àí16. Thus, for double precision Ô¨Çoating-point number
arithmetic, any relative value in the results smaller than eps will be
rounded away.

Other than the round oÔ¨Ä error from close value subtractions dis-
cussed in Section 2.1.4, another arithmetic operations can introduce
large round oÔ¨Ä errors due to large diÔ¨Äerence additions, i.e., adding a
small number to a large number. In large diÔ¨Äerence addition, the re-
sult of the calculation is of the same order as the large number. Hence,
the rounding away aspect operates at the order of eps√ó |large number|.
Since the absolute value of the small number is much smaller than
the large number, the rounded away part can be a signiÔ¨Åcant compo-
nent of the small number. Consequently, the result loses considerable
accuracy.

Indeed, in numerical integrations, these large diÔ¨Äerence additions

are needed in each step as we keeping evolving the variable ùúâ

ùúâ ‚Üí ùúâ +

ùëëùúâ
ùëëùë°

ùëëùë°

(61)

where

ùëë ùúâ
ùëëùë° ùëëùë° is usually small compared to ùúâ.

To achieve higher precision, reducing the round oÔ¨Ä error be-
comes essential. Quinn & Tremaine (1990) introduced into celestial
mechanics the active round oÔ¨Ä error reduction invented by Kahan
(1965). Rein & Spiegel (2014) then implemented it in IAS15.

For Ô¨Çoating-point number arithmetic, the result of each operation

MNRAS 000, 1‚Äì18 (2015)

6 Wang et al.

will be rounded adopting a certain round oÔ¨Ä strategy. For example,
consider the result of

ùúâ + ùëëùúâ ‚Üí rnd[ùúâ + ùëëùúâ]

(62)

where rnd is a certain round oÔ¨Ä strategy. What is interesting is that
the round oÔ¨Ä error cause by rnd can also be estimated under the
Ô¨Çoating-point number arithmetic, where

err+ (ùúâ, ùëëùúâ) ‚àº rnd[rnd[rnd[ùúâ + ùëëùúâ] ‚àí ùúâ] ‚àí ùëëùúâ]

Although,

err+ (ùúâ, ùëëùúâ) < eps √ó rnd[ùúâ + ùëëùúâ]

(63)

(64)

it can be comparable to ùëëùúâ. Since in the integration ùëëùúâ at diÔ¨Äerent
ùë° will be continuously added to the ùúâ, the round oÔ¨Ä error from the
last step can be compensated in the next step by subtracting the error
from ùëëùúâ. A complete active round oÔ¨Ä error compensation process
can be described as

ùúâ1 = rnd[ùúâ0 + ùëëùúâ0]
err+ (ùúâ0, ùëëùúâ0) = rnd[rnd[ùúâ1 ‚àí ùúâ0] ‚àí ùëëùúâ0]
ùëëùúâ1 = rnd[ùëëùúâ1 ‚àí err+ (ùúâ0, ùëëùúâ0)]
ùúâ2 = rnd[ùúâ1 + ùëëùúâ1]
err+ (ùúâ1, ùëëùúâ1) = rnd[rnd[ùúâ2 ‚àí ùúâ1] ‚àí ùëëùúâ1]
ùëëùúâ2 = rnd[ùëëùúâ2 ‚àí err+ (ùúâ1, ùëëùúâ1)]
...

(65)

(66)

(67)

(68)

(69)

(70)

By this means, the round oÔ¨Ä error can be reduced by 1-2 orders of
magnitude. This is essential in high precision integration methods
trying to minimize round oÔ¨Ä errors.

2.3 Arbitrary precision integration

For integration methods with high precision, other than reducing
the round oÔ¨Ä error with limited mantissa bit Ô¨Çoating point numbers,
another way to increase the precision of the integration method is to
lower the eps in Equation 60. The most straightforward way to do this
is to increase the mantissa bit number N, i.e. use longer bit Ô¨Çoating-
point numbers. In this way, one can achieve any precision by using
longer and longer bit Ô¨Çoating-point numbers. However, the length
of the CPU register is limited. Thus, the arithmetic between non-
standard Ô¨Çoating point numbers can be extremely slow compared to
the arithmetic between standard Ô¨Çoating point numbers.

Since the GBS extrapolation can simply construct arbitrarily
higher orders, using longer bit Ô¨Çoating point numbers in this method
can easily achieve arbitrary precision. Brutus (Boekholt & Portegies
Zwart 2015) implemented this method by adopting the arbitrary bit
Ô¨Çoating point number.

3 SPACEHUB LIBRARY

In this section, we describe several novel features implemented in
SpaceHub, and quantify how each of these novel algorithms improve
performance, in particular accuracy, precision and speed, relative to
previous methods discussed in the previous section. This is done by
considering the time evolution of two example cases, namely the
earth-moon-sun system and a highly eccentric binary composed of
two solar mass stars with an initial semi-major axis of 1 AU.

MNRAS 000, 1‚Äì18 (2015)

ùúñ
-ùúñ
ùúñ
-ùúñ
ùúñ
-ùúñ
ùúñ
-ùúñ
...

-1.6ùúñ
2.6ùúñ
-3.6ùúñ
4.6ùúñ
-5.5ùúñ
6.5ùúñ
-7.5ùúñ
...

3.1ùúñ
-5.6ùúñ
9.1ùúñ
-13.6ùúñ
19.1ùúñ
-25.6ùúñ
...

-6.2ùúñ
11.9ùúñ
-21.2ùúñ
35.0ùúñ
-54.3ùúñ
...

12.7ùúñ
-25.3ùúñ
47.7ùúñ
-84.1ùúñ
...

-26.4ùúñ
54.1ùúñ
-105.6ùúñ
...

55.8ùúñ
-116.3ùúñ
...

-119.0ùúñ
...

Table 2. Round oÔ¨Ä error propagation in the Bulirsch-Stoer extrapolation with
step sequence ùëõùëñ = 2ùëñ.

ùúñ
-ùúñ
ùúñ
-ùúñ
ùúñ
-ùúñ
ùúñ
-ùúñ
...

-1.7ùúñ
2.6ùúñ
-2.1ùúñ
2.3ùúñ
-2.6ùúñ
3.0ùúñ
-2.7ùúñ
...

3.1ùúñ
-3.0ùúñ
3.0ùúñ
-3.6ùúñ
4.6ùúñ
-4.4ùúñ
...

-3.3ùúñ
3.4ùúñ
-4.1ùúñ
5.4ùúñ
-5.5ùúñ
...

3.5ùúñ
-4.3ùúñ
5.7ùúñ
-5.9ùúñ
...

-4.3ùúñ
5.8ùúñ
-6.1ùúñ
...

5.8ùúñ
-6.2ùúñ
...

-6.2ùúñ
...

Table 3. Round oÔ¨Ä error propagation with optimal step sequence in the BS
extrapolation.

3.1 AR-ABITS: Regularized arbitrary precision algorithm

As with Brutus, using extended mantissa bit Ô¨Çoating-point numbers
can reduce the eps in Equation 60. Thus, it can achieve arbitrary
precision by increasing the bit length. However, the round oÔ¨Ä error
will also propagate and accumulate through the extrapolation table in
Table 1. As the order of the GBS extrapolation increases, the round
oÔ¨Ä will accumulate faster and faster. Thus the additional mantissa bits
becomes less and less eÔ¨Écient in increasing the integration accuracy.
Therefore, reducing the round oÔ¨Ä error in GBS extrapolation is also
important in order to achieve the same precision with less mantissa
bits and less CPU time.

3.1.1 Improvement on GBS extrapolation

In the BS extrapolation, higher order methods can be obtained from
lower order methods by extrapolation, as described in Equation 52.
However, the round oÔ¨Ä error will also propagate and accumulate
through the extrapolation table. If the round oÔ¨Ä error from the base
integration method is ùúñ, ‚àíùúñ, ùúñ, ... in the Ô¨Årst column, then the round
oÔ¨Ä error propagation with the extensively used step sequence ùëõùëñ =
2ùëñ suggested by DeuÔ¨Çhard (1983) will behave as in Table 2. As
shown in the table, ùëá8,8 with 16th order precision magniÔ¨Åed the
round oÔ¨Ä error to become 100 times larger. Thus, we will lose at
least 2 signiÔ¨Åcant digits from the extrapolation. This becomes more
problematic for higher order extrapolations, as required by arbitrary
precision integration methods with extremely low tolerance.

To reduce the round oÔ¨Ä error in the extrapolation process,
there are two Ô¨Åne-tunings that can be performed on the extrap-
olations. The Ô¨Årst is a step sequence choice. The step sequences
ùëõùëñ = 1, 2, 3, 5, 8, 12, 17, 25, 36, 51, 73, ...(Fukushima 1996) is better
than the extensively used sequence ùëõùëñ = 2ùëñ, where the extrapolation
coeÔ¨Écient reduces the round-oÔ¨Ä error propagation. Table 3 shows
the error propagation with the new step sequence. We see that it per-
forms much better than the original sequence suggested by DeuÔ¨Çhard
(1983).

The second method to reduce the round oÔ¨Ä error in the extrapola-

tion process is to extrapolate the raw increment ùëëùúâ of the integration
instead of the integrated result ùúâ. Since the GBS extrapolation is
linear, it is possible to do the following
Œîùëáùëñ, ùëó‚àí1 ‚àí Œîùëáùëñ‚àí1, ùëó‚àí1
(ùëõùëñ/ùëõùëñ‚àí ùëó+1)2 ‚àí 1

Œîùëáùëñ, ùëó = Œîùëáùëñ, ùëó‚àí1 +

(71)

.

Because the raw increment ùëëùúâ is usually tiny compared to the in-
tegrated results, the round of error in the Ô¨Årst column of Table 1
is ‚àº eps √ó |ùëëùúâ | instead of ‚àº eps √ó |ùúâ |. Then, the round oÔ¨Ä error
accumulated from the extrapolation table will be smaller than the
error accumulated from the direct extrapolation. We note, however,
that the initial Œîùëáùëñ,1 should be the raw increment evaluated from the
basic integrator, not from the subtraction of ùëáùëñ,1 (ùêª) ‚àí ùëáùëñ,1 (0). The
close value subtraction will introduce additional round oÔ¨Ä errors and
will signiÔ¨Åcantly degrade the advantage of this method.

3.1.2 Algorithmic regularization in arbitrary precision integrations

The GBS standalone is not eÔ¨Écient in solving extremely eccentric
orbits and very close pair-wise encounters. Thus, in SpaceHub we
implement the algorithmic regularized arbitrary precision method
AR-ABITS to deal with extremely eccentric orbits and very close
encounters with arbitrary precision.

We Ô¨Ånd that the Ô¨Åne-tuned regularized GBS extrapolation works
eÔ¨Éciently for arbitrary bits Ô¨Çoating-point numbers. The upper panel
of Figure 1 shows the relative energy error as a function of the
relative tolerance ùúÇ for the GBS method in Brutus and the AR-
ABITS method in SpaceHub. The integration is performed on a sun-
earth-moon system for 100 moon orbits. For a relative tolerance ùúÇ,
ùëÅ = 4 √ó [log10 (ùúÇ)]Ô¨Çoor + 32 mantissa bits for Ô¨Çoating-point numbers
will be used as suggested by Brutus. We can see from the upper
panel that, for the same Ô¨Çoating-point number bits and tolerance ùúÇ, the
BS extrapolation in SpaceHub can achieve 1-2 orders of magnitude
higher precision than Brutus. With our regularization improvements
and our special treatment for reducing round-oÔ¨Ä errors, we achieve
even better precision in AR-ABITS. This trend becomes even more
signiÔ¨Åcant for low ùúÇ, as round oÔ¨Ä errors become more problematic
in higher order extrapolations.

The bottom panel of Figure 1 shows the error scaling of Brutus
and AR-BITS. With the same choice of mantissa bits, we see that
for a non-eccentric sun-earth-moon system, AR-BITS (green solid
line) achieves the same precision but with a CPU time several times
faster than in Brutus (orange solid line). For eccentric systems with
e=0.9999, AR-BITS (blue dotted line) achieves the same precision
but with a CPU time one to two orders of magnitude faster than with
Brutus (red dotted line). To conclude, we Ô¨Ånd that AR-BITS is much
more bit/time eÔ¨Écient in both eccentric and circular systems.

Our improvement on the GBS extrapolation can be applied to any
algorithm based on GBS extrapolation, and is ideal for integrations
requiring high precision with lower round oÔ¨Ä errors.

3.2 AR-chain+: Improved AR-chain

In the following, we will describe the improvements of AR-chain+
which make it superior to AR-chain.

3.2.1 Improvement on the chain coordinate transformation

In the original chain coordinates transformation, for system with N
Cartesian coordinates, the transformed chain coordinates has N-1

Few-body toolkit SpaceHub

7

Figure 1. Arbitrary precision methods in SpaceHub and Brutus. Upper
panel: Root mean square relative error as a function of the relative integration
tolerance for integrations of the sun-earth-moon system for 100 moon orbits.
Bottom panel: Root mean square relative error as a function of CPU time
for integration of the sun-earth-moon system for 100 moon orbits (solid
line), and for the integration of 100 orbits of an eccentric sun-earth two
body system with e=0.9999 (dashed line). The mantissa bit is chosen from
4 √ó [log10 ( ùúÇ) ]Ô¨Çoor + 32 as suggested by Brutus.

1
2

ùëöùëñv2

coordinates as described in Equation 49. In the inverse transforma-
tion, the centre of mass reduction is necessary when calculating the
kinetic energy ùëá = (cid:205)ùëñ
ùëñ , which is required by the regulariza-
tion method. For direct summation N-body integration in the large-N
regime, most of the CPU time is used to evaluate the acceleration,
since the cost of acceleration evaluation scales with ùëÇ(N2). Thus,
the cost of centre of mass reduction that scales with ùëÇ(N) is negligi-
ble. However, in the small-N regime, the cost of the centre of mass
reduction can be signiÔ¨Åcant.
Unlike the original

transformation between (x1, ..., xùëÅ ) ‚Üî
(X1, ..., XùëÅ ‚àí1), we propose a new modiÔ¨Åed transformation such that
the centre of mass reduction can be eliminated. Indeed, a bƒ≥ective
mapping between (x1, ..., xùëÅ ) ‚Üî (X1, ..., XùëÅ ) can be constructed,
where

Xùëò

XùëÅ

Vùëò

VùëÅ

= xùëñùëò+1 ‚àí xùëñùëò
= xùëñ1
= vùëñùëò+1 ‚àí vùëñùëò
= vùëñ1

ùëò = 1, 2, ..., ùëÅ ‚àí 1

ùëò = 1, 2, ..., ùëÅ ‚àí 1

(72)

(73)

(74)

(75)

MNRAS 000, 1‚Äì18 (2015)

10281024102010161012tolerance 103510311027102310191015RMS E/EAR-ABITS(SpaceHub)BS(Brutus)100101102CPU time [s]10341029102410191014109RMS E/EAR-ABITSBrutusAR-ABITS(ecc)Brutus(ecc)8 Wang et al.

Figure 2. The CPU time of the improved chain transformation ùëánew versus
the old chain transformation as a function of the particle number N.

and

xùëñ1
xùëñùëò+1
vùëñ1
vùëñùëò+1

= XùëÅ
= xùëò + Xùëò

= VùëÅ
= vùëò + Vùëò

ùëò = 1, 2, ..., ùëÅ ‚àí 1

ùëò = 1, 2, ..., ùëÅ ‚àí 1

with equations of motion

ùëëXùëò
ùëëùë°
ùëëVùëò
ùëëùë°

ùëò
ùëëVùëÅ
ùëëùë°

= Vùëò ,

ùëò = 1, 2, ..., ùëÅ

= gùëñùëò+1 ‚àí gùëñùëò + fùëñùëò+1 ‚àí fùëñùëò + fùëñùëò+1,ùë£ ‚àí fùëñùëò ,ùë£
= 1, 2, ..., ùëÅ ‚àí 1

= gùëñ1 + fùëñ1 + fùëñ1,ùë£ .

(76)

(77)

(78)

(79)

(80)

(81)

(82)

(83)

This transformation preserves the centre of mass reduction without
the need for any additional acceleration evaluation.

Figure 2 shows the relative CPU time cost of this new transfor-
mation compared to the old transformation, as a function of the
particle number N. In the small-N regime, the new transformation
that eliminates the centre of mass reduction can save signiÔ¨Åcantly on
computational run time. In the large N-regime, since the acceleration
evaluation takes up most of the CPU time, the two transformations
are almost identical in CPU cost.

3.2.2 Introducing the active round oÔ¨Ä error compensation into

AR-chain

Other than the round oÔ¨Ä error reduction in GBS extrapolation, the
active round oÔ¨Ä error reduction can also be used in the AR-chain
algorithm.

Instead of implementing the active compensation process dur-
ing a certain step of the algorithm as described in Equation 65
and avoid writing the compensation procedure everywhere, we im-
plement several new Ô¨Çoating point number types that execute the
active compensation automatically. SpeciÔ¨Åcally, three additional
Ô¨Çoating-point number types in both 32 and 64 bit, namely Kahan
number(Ô¨Çoat_k, double_k), Neumaier number(Ô¨Çoat_p, double_p)
and Klein number(Ô¨Çoat_e, double_e), with diÔ¨Äerent active error com-
pensation strategies are implemented in SpaceHub as base Ô¨Çoating
point number types. In those Ô¨Çoating-point number types, the opera-
tor ‚Äô+=‚Äô can automatically perform the active compensation process.

MNRAS 000, 1‚Äì18 (2015)

Figure 3. Integration on the sun-earth-moon system with 1000 moon orbits.
5000 equal spaced relative energy error during the 1000 orbits are outputted
to calculate the root mean square relative energy error. This Ô¨Ågure shows
the rms relative energy error as a function of the relative tolerance ùúÇ for
Mikkola‚Äôs AR-chain, AR-chain in SpaceHub and AR-Chain+.

Therefore, any algorithm in SpaceHub taking these Ô¨Çoating point
data types can directly activate the active round oÔ¨Ä error compensa-
tion. The cost for this implementation is a higher cache latency and
double sized memory to save the error from last addition. However,
in the small-N regime, these costs are not signiÔ¨Åcant.

Usually, the active round oÔ¨Ä error compensation can reduce the
round oÔ¨Ä error by 1-2 order of magnitude. However, we found that
in AR-chain, the eÔ¨Äect is signiÔ¨Åcantly degraded by the chain coordi-
nates. After each step, to make sure that the shortest relative position
is kept in the chain coordinates, the chain coordinates may need
to be updated. Once the chain coordinates update is required, then
the chain coordinates ùëãùëò,new need to be reconstructed from ùëãùëò,old.
Therefore, the round oÔ¨Ä error err+ (ùëãùëõ, ùëëùëãùëõ) calculated from the last
step, which is computed for ùëãùëò,old, becomes incorrect if applied to
ùëãùëò,new. Thus, if the chain update is frequent during the integration,
the active round oÔ¨Ä error compensation will be interrupted and then it
becomes less useful. The branching coordinates proposed by Rantala
et al. (2020), that need fewer coordinates updates has the potential to
solve this problem. We will investigate this in the future.

We integrate the sun-earth-moon system with 1000 moon orbits
with the original Mikkola‚Äôs AR-chain, AR-chain in SpaceHub and
AR-Chain+ with diÔ¨Äerent relative error tolerance ùúÇ. Figure 3 shows
the rms relative energy error as a function of ùúÇ.

3.3 AR-Sym6+: Algorithmic regularized higher order

symplectic method

The original AR-chain uses the leapfrog scheme as the basic algo-
rithm. Due to its time symmetry, it does very well in conserving
the total energy of the Hamiltonian system. However, the leapfrog
scheme alone is just a second order method that, when used alone,
is rarely suÔ¨Éciently accurate. Therefore, to achieve higher precision,
AR-chain adopts the GBS extrapolation scheme which can eÔ¨Éciently
construct higher order methods from lower order methods. However,

05101520number of particles N0.750.800.850.900.95Tnew/Told101410121010108106rtol 101410121010108RMS E/EAR-chainAR-chain+AR-chain(Mikkola)the round-oÔ¨Ä errors from the BS method can be signiÔ¨Åcant due to
the extrapolation process. Several measures can be taken to reduce
them, but the reduction can be limited if higher order methods are
included. Therefore, theoretically, even BS extrapolation can achieve
arbitrarily high order accuracy. However, we Ô¨Ånd that, for most cases
of interest, 13th to 15th order works best for double precision Ô¨Çoat-
ing point numbers. Higher order extrapolations will be capped by the
round oÔ¨Ä error. More importantly, the extrapolation can break the
time symmetry of the leapfrog scheme, and can signiÔ¨Åcantly aÔ¨Äect
the relative energy error in the round oÔ¨Ä error regime. For integra-
tion methods based on the BS extrapolation with double precision
FP numbers as the arithmetic type, the relative energy error for short
time integration is usually at the level of 10‚àí13 due to the extrapola-
tion. As discussed before, the active error compensation can reduce
the error further to ‚àº 10‚àí14, but it becomes hard to achieve higher
precision under the BS extrapolation scheme.

Using higher order symplectic methods to replace the BS extrapo-
lation has been mentioned in Mikkola & Merritt (2008). However, to
date, there have been no implementations of higher order symplectic
methods with algorithmic regularization. BeneÔ¨Åting from the code
architecture of SpaceHub, we can easily glue diÔ¨Äerent algorithms
together, and introduce the regularization and chain algorithm into
the higher order symplectic method. Without the rational extrapola-
tion, the time symmetry of the symplectic method can be preserved.
Thus, this new method can eÔ¨Éciently deal with extreme eccentricity
systems and very close pair-wise approaches with even higher pre-
cision. More importantly, with regularization, it is possible to use
Ô¨Åxed step sizes to solve the time evolution of extremely eccentric
systems. The Ô¨Åxed step size regularized method maintains the time
symmetry while avoiding these issues arising from the extrapolation.
Consequently, we can achieve higher precision in the round oÔ¨Ä error
regime (i.e., when round oÔ¨Ä errors dominate the growth of the total
energy error budget).

3.3.1 Error estimation

For an integration method of order ùëò, the numerical integration ùêºùëõ ( ùëì )
on ùëì for total step length ùêª with ùëõ intermediate steps has an error
that scales as

Few-body toolkit SpaceHub

9

3.3.2 Step size control

As discussed above, for an integration method of order ùëò, the global
truncation error scales as ‚àº ùêª ùëò , where ùêª is the step size. For inte-
grations working in the asymptotic regime, we have

‚àº

ùêª ùëò

new
errornew

ùêª ùëò
old
errorold
To get the converged result in the next step, i.e errornew < 1, the
simplest way to chose the step size in the next step would be just

(88)

ùêªnew = ùêªold (

1
errorold

)1/ùëò .

(89)

However, the integration would not always work eÔ¨Äectively in the
asymptotic regime especially, but also in the round oÔ¨Ä error regime,
where the round oÔ¨Ä error becomes non-negligible compared to the
truncation error. Thus, more complicated error/step control might be
needed.

In control theory, the Proportional‚ÄìIntegral‚ÄìDerivative (PID) con-
troller is believed to be eÔ¨Écient and useful in performing continuous
error controlling. In SpaceHub, the PI step size controller that ap-
plies proportional and integral feedback to the integration system is
the default step size controller, where the new step will be given by
(cid:19)ùê∂ùêº /ùëò

ùêªnew = ùëÜ1

(cid:18) ùëÜ2
error

(cid:19)ùê∂ùëÉ/ùëò (cid:18) error
ùëÜ2

ùêªold ,

(90)

where ùê∂ùëÉ, ùê∂ùêº are, respectively, the coeÔ¨Écients of proportionality
and the integral feedback part. The speciÔ¨Åc values of ùê∂ùëÉ and ùê∂ùêº
are problem-dependent but a general value could be ùê∂ùëÉ = 0.7 and
ùê∂ùêº = 0.4 (Press et al. 2002). The variables ùëÜ1 and ùëÜ2 are the safe
factors, which tend to be few percents smaller than one to make sure
the new step size has higher probability to get a converged result.
To avoid varying the step size rapidly, a time step limiter is applied
to the ùêªnew calculation. The new step size is constrained within the
range
ùëÜ1/ùëò
3
ùëÜ4
where ùëÜ3 = 0.02 and ùëÜ4 = 4.

ùêªnew
ùêªold

(cid:18) 1
ùëÜ3

(cid:19)1/ùëò

(91)

<

<

(84)

3.3.3 Choosing the order of the Symplectic methods

ùê∏ùëõ ( ùëì ) = |ùêºùëõ ( ùëì ) ‚àí ùêπ | ‚àº ùê∂

(cid:19) ùëò

,

(cid:18) ùêª
ùëõ

where ùêπ is the unknown true value of the integration and ùê∂ is a
constant. To estimate ùê∏ùëõ ( ùëì ), we can do additional integrations on ùëì
with ùëö(> ùëõ) steps. The error for ùêºùëö ( ùëì ) is

ùê∏ùëö ( ùëì ) = |ùêºùëö ( ùëì ) ‚àí ùêπ | ‚àº ùê∂

(cid:19) ùëò

(cid:18) ùêª
ùëö

=

ùê∏ùëõ ( ùëì )
(ùëö/ùëõ) ùëò

.

Then we can estimate the error of the integration ùêºùëö ( ùëì ),

ùê∏ùëö ‚àº

1
(ùëö/ùëõ) ùëò ‚àí 1

|ùêºùëö ‚àí ùêºùëõ | .

(85)

(86)

To obtain a converged result with tolerance ùúñ, a sequence of step
numbers ùëõ1, ùëõ2, ..., ùëõ ùëó can be performed such that the dimensionless
error is less than unity,

error =

|ùêºùëõ ùëó ‚àí ùêºùëõ ùëó‚àí1 |
[(ùëõ ùëó /ùëõ ùëó‚àí1) ùëò ‚àí 1]|ùêºùëõùëò |ùúñ

< 1 .

(87)

From our experiments, we Ô¨Ånd that the choice of ùëõ ùëó for eÔ¨Écient
convergence and speed works well for ùëõ ùëó = 2 ùëó with ùëó = 1, 2, ....

Yoshida (1990) gives an eÔ¨Écient way to construct higher order sym-
plectic methods recursively using lower order symplectic methods
via the Baker-Campbell-HausdorÔ¨Ä formula. From Yoshida (1990), if
a symmetric integrator of order 2ùëõ, ùëÜ2ùëõ (ùúè) is already known, a 2ùëõ + 2
th order integrator can be obtained via the product
ùëÜ2ùëõ+2 = ùëÜ2ùëõ (ùëß1ùúè)ùëÜ2ùëõ (ùëß0ùúè)ùëÜ2ùëõ (ùëß1ùúè)
where ùëß0 and ùëß1 satisfy
ùëß0 + 2ùëß1 = 1, ùëß2ùëõ+1
(93)
Then, starting from the 2nd order leapfrog scheme with ùëÜ2 (ùúè) =
ùê∑ (ùúè/2)ùêæ (ùúè)ùê∑ (ùúè/2), higher order symplectic integrators can be con-
structed recursively. In SpaceHub, we implement symplectic meth-
ods up to 10th order.

+ 2ùëß2ùëõ+1
1

= 0 .

(92)

0

For symplectic integrators using the regularization chain method,
we test from 6th order to 10th order. From our experiments, we Ô¨Ånd
that the 6th order method (hereafter called AR-sym6) works best in
terms of precision with decent convergence speed for 64 bits FP data
type. Using the higher order symplectic methods directly without
extrapolation preserves the time symmetry of the integration. Thus,

MNRAS 000, 1‚Äì18 (2015)

10 Wang et al.

separately. To solve the equations of motion of the regularized sys-
tem with the Gauss-Radau method, a general coordinate is required
where,
y = (r, v, ùúî, ùêµ, ùë°)

(102)

such that y|‚Ñé can be expanded into
ùëëy
ùëë‚Ñé

+ b1‚Ñé + b2‚Ñé2 + ... + b7‚Ñé7

ùëëy
ùëë‚Ñé

‚àº

(cid:12)
(cid:12)
(cid:12)
(cid:12)‚Ñé

(cid:12)
(cid:12)
(cid:12)
(cid:12)0

where
(cid:12)
ùëëy
(cid:12)
(cid:12)
ùëë‚Ñé
(cid:12)0

= (

ùëër
ùëë‚Ñé

,

ùëëv
ùëë‚Ñé

,

ùëëùúî
ùëë‚Ñé

,

ùëëùêµ
ùëë‚Ñé

,

ùëëùë°
ùëë‚Ñé

)

(103)

(104)

The same process as Equation 58 and 59 can be performed to calcu-
late the bùëñ. Then the general coordinates at the end of the step ùëëùë° can
be obtained by analytically integrating Equation 103.
(cid:18)
‚Ñé

(cid:19) (cid:19)(cid:19)

(cid:18)

y|‚Ñé ‚àº y|0 + ‚Ñéùëëùë°

(cid:18) ùëëy
ùëëùë°

(cid:12)
(cid:12)
(cid:12)
(cid:12)0

+

2

b1 +

2‚Ñé
3

b2 + ...

(105)

Figure 4. Same as Figure 3, but testing the AR-sym6+.

it achieves much higher precision relative to the original AR-chain,
using the active round oÔ¨Ä error compensation.

We integrate the sun-earth-moon system with 1000 moon orbits
with the original Mikkola‚Äôs AR-chain, AR-chain in SpaceHub and
AR-Sym6+ with diÔ¨Äerent relative error tolerance ùúÇ. Figure 4 shows
the rms relative energy error as a function of ùúÇ.

3.4 AR-Radau+: introducing algorithmic regularization into

Gauss-Radau integration

Gauss-Radau spacings are useful in solving few-body problems ac-
curately, especially after the active round oÔ¨Ä error compensation
was implemented in Rebound. However, the normal Gauss-Radau
method is not eÔ¨Écient/accurate enough to solve extremely eccentric
orbits as well as close encounters because tiny steps are required to
solve the trajectories at the point of closest approach. To solve this
problem while keeping the advantages of the Gauss-Radau stepping,
we introduce the algorithmic regularization into the Gauss-Radau
method.

The equations of motion of the regularized system are Ô¨Årst order
diÔ¨Äerential equations. For a system with Hamiltonian ùêª, the LogH
method gives the equations of motion as,

ùëëùë°/ùëë‚Ñé = 1/(ùëá + ùêµ)
ùëër/ùëë‚Ñé = v/(ùëá + ùêµ)
ùëëv/ùëë‚Ñé = a/ùëà
ùëëùêµ/ùëë‚Ñé = ùúïùêª/ùúïùë°/ùëà ,

while the TTL method gives the equations of motion as,

ùëëùë°/ùëë‚Ñé = 1/ùúî
ùëër/ùëë‚Ñé = v/ùúî
ùëëv/ùëë‚Ñé = a/Œ©
ùëëùúî/ùëë‚Ñé = ùúïŒ©/ùúïùë°/Œ© .

(94)

(95)

(96)

(97)

(98)

(99)

(100)

(101)

They work smoothly with the leap-frog based method because ad-
vancing the velocity and position are divided into ‚Äôkick‚Äô and ‚Äôdrift‚Äô

MNRAS 000, 1‚Äì18 (2015)

The chain algorithm can also be constructed by replacing the
equations of motion for r and v with equations of motion for X and
V, as described in Equation 49.

Similar to previous subsections, we integrate two systems with
diÔ¨Äerent relative error tolerance ùúÇ. The Ô¨Årst test integrates the sun-
earth-moon system with 1000 moon orbits and the second test inte-
grates an eccentric two body orbit with ùëÄ1 = 1ùëÄ(cid:12), ùëÄ2 = 1ùëÄ‚äï, a =
1 AU and e = 0.9999 with 1000 orbits. The IAS15 does not provide
API to change the ùúÇ, thus the ùúÇ is Ô¨Åxed at the default value 10‚àí16.

The upper panel of Figure 4 shows the rms relative energy error
as a function of ùúÇ for the IAS15 and AR-Radau+ methods for the
sun-earth-moon system. The bottom panel shows the same results
for the eccentric two body system.

4 PERFORMANCE TESTS FOR REAL ASTROPHYSICAL

SYSTEMS

In this section we test the precision and performance of the inte-
gration methods adopted in SpaceHub, and compare them to other
high-precision few-body codes, including Brutus, Rebound, ABIE1,
Mikkola‚Äôs AR-chain, and so on.

All tests are performed on an Intel-i7-8700k CPU under a Linux
OS with GCC-10.2.0. All codes are compiled with the -O3 compile
optimization option. Table 4 shows the algorithms tested in each
section.

4.1 Precision & Performance Tests

For the precision and performance tests, only the Newtonian inter-
actions will be included. The precision indicator, speciÔ¨Åcally the
relative energy error, will be evaluated as
ùõøùê∏
ùê∏
with ùê∏ = ùëá ‚àí ùëà. For algorithms with regularization, to decrease the
round-oÔ¨Ä errors from the potential energy calculations, the estimation
becomes(Mikkola & Merritt 2008)

|ùê∏ (ùë°) ‚àí ùê∏ (0)|
|ùê∏ (0)|

(ùë°) =

(106)

| log(

ùëá + ùêµ
ùëà

)| = | log(1 +

ùõøùê∏
ùëà

)| ‚àº

|ùõøùê∏ |
ùëà

,

(107)

1 ABIE is a new GPU-accelerated direct N-body code. The integrator adopted
in these simulations is a 15th-order Gauss-Radau algorithm with an adaptive
timestep scheme. The algorithm is particularly optimized for close encounters.

101410121010108106rtol 101510131011109RMS E/EAR-chainAR-sym6+AR-chain(Mikkola)Few-body toolkit SpaceHub

11

algorithm

code

setups

link

Bulirsch-Stoer
AR-Chain
AR-Chain+
AR-Radau+
AR-sym6+
AR-ABITS
IAS15
Radau
Bulirsch-Stoer
AR-chain

SpaceHub
SpaceHub
SpaceHub
SpaceHub
SpaceHub
SpaceHub
Rebound
ABIE
Brutus
Mikkola

rtol = 10‚àí14, atol = 0
rtol = 10‚àí14, atol = 0
rtol = 10‚àí14, atol = 0
code Ô¨Åxed default
rtol = 10‚àí14, atol = 0
rtol = 10‚àí14, atol = 0
code Ô¨Åxed default
code Ô¨Åxed default
rtol = 10‚àí14, atol = 0
rtol = 10‚àí14, atol = 0

source code
source code
source code
source code
source code
source code
source code
source code
source code
source code

Table 4. Tested algorithms

Since every integration method can be well-tuned for a speciÔ¨Åc
problem, it can be tricky to do proper comparisons between dif-
ferent integration methods. However, for each integration method
included in SpaceHub, there are always default parameters, the so
called ‚Äôout-of-the-box‚Äô parameters, which help control the integra-
tion Ô¨Çow and which vary among diÔ¨Äerent integration schemes. To
make the comparisons as normalized as possible, we use the out-of-
the-box parameters for all integration methods when performing all
comparison tests in order to ensure a fair comparison between the dif-
ferent methods adopted in diÔ¨Äerent codes (e.g., REBOUND, ABIE, etc.).
One should also note that the basic math functions like ‚Äôpow‚Äô, ‚Äôsin‚Äô,
‚Äôcos‚Äô etc. in the standard math library are not platform-independent.
Thus, algorithm (including ABIE, Mikkola‚Äôs AR-chain and Brutus)
that use those math functions become platform-independent as well.
The test results could be slightly diÔ¨Äerent on diÔ¨Äerent platforms. A
platform-independent math library will be implemented in the next
version of the SpaceHub.

4.1.1 The Earth-Moon-Sun System

We now pay attention to a simple sun-earth-moon system that is easy
to integrate for every method. The integrated system consists of the
sun, the earth and the moon. We integrate the system for 1000 moon
orbits using adaptive time stepping, and quantify the performance of
each method.

Figure 6 shows the precision and CPU wall time for each method.
The left panel shows the relative energy error of each method as
a function of time, the middle panel shows the CPU wall time for
each method and the right panel shows the rms relative energy er-
ror versus CPU time. From the Ô¨Ågure, we can see that the imple-
mentation of AR-chain in SpaceHub is ‚àº 2 ‚àí 2.5 times faster than
Mikkola‚Äôs implementation. The AR-Chain+ is slightly slower but
comes along with with slightly higher precision. The Radau method
in ABIE reaches the same precision but signiÔ¨Åcantly slower than the
AR-Chain-based methods in SpaceHub. The IAS15, a Radau method
with improvements implemented by Rein & Spiegel (2014), achieves
higher precision near the machine precision with the same speed
as the Radau method in ABIE. The algorithmic regularized Radau
method in SpaceHub and the algorithmic regularized 6th symplectic
methods have better round oÔ¨Ä error control for this problem, and thus
yield even higher precision computations than IAS15. The algorith-
mic regularized 6th order symplectic method is signiÔ¨Åcantly slower
than the other two due to its extra integration for error evaluation at
each step. The AR-Radau method, with extended double sized coor-
dinates and extra regularization function evaluation (which mainly
spends its time on evaluating U) at each time step is only slightly

MNRAS 000, 1‚Äì18 (2015)

Figure 5. Upper panel: Same test as in Figure 3 for IAS15 and AR-Radau+.
Bottom panel: Test of 1000 orbits on the two body eccentric system with a =
1 AU and e = 0.9999 consists of ùëÄ1 = 1ùëÄ(cid:12) and ùëÄ2 = 1ùëÄ‚äï. The IAS15
does not provide API to change the ùúÇ, thus the ùúÇ is Ô¨Åxed as default 10‚àí16.

where ùêµ is deÔ¨Åned in Equation 5 as the binding energy that will
be evaluated at ùë° = 0 and will continue to evolve in time with the
ùõøùê∏
ùê∏ (ùë°) com-
regularized system. For each test, 5000 equally spaced
putations will be outputted during the integration and the root mean
square (RMS) error is calculated as

RMS

ùõøùê∏
ùê∏

=

‚àöÔ∏Ç

ùëÅ
‚àëÔ∏Å

ùëñ

ùõøùê∏
ùê∏

(

(ùë°ùëñ))2/ùëÅ .

(108)

For our performance tests, the CPU wall time is measured from
the best performance test of 5 repeat runs with the same initial con-
ditions. This is done to avoid CPU interruption by other processes
operating in the background. The wall time only quantiÔ¨Åes the time
evolution within the main loop of the integration scheme, and ig-
nores all initialization and Ô¨Ånalization procedures in order to obtain
normalized comparisons between the diÔ¨Äerent algorithms. The IOs
need non-negligible CPU time in short term performance tests. To
precisely measure the wall time of diÔ¨Äerent algorithms in our per-
formance tests, all outputs are turned oÔ¨Ä. The test Ô¨Åle and initial
conditions for our test cases can be found at SpaceHub-Tests. Tests
of other codes are performed using the code links provided above
with the same initial conditions.

101510131011109107rtol 101610151014RMS E/EAR-Radau+IAS15(REBOUND)101510131011109107rtol 1015101410131012RMS E/EAR-Radau+IAS15(REBOUND)12 Wang et al.

slower than IAS15 for this test case. For arbitrary precision methods
with non-standard Ô¨Çoating-point types, we see that the algorithmic
regularized arbitrary bits (AR-ABITS) method is faster and far more
accurate than Brutus, as previously discussed.

4.1.2 Extremely eccentric systems

For our second test case, we analyze a two body system with extreme
eccentricity e=0.9999 and semi-major axis a = 1 AU. The central
object has a mass of 1 ùëÄ(cid:12) and the test particle has a mass of 1
ùëÄ‚äï. We integrate the system for 1000 orbits. This test is designed
to quantify how the diÔ¨Äerent integration methods are able to han-
dle extremely eccentric orbits and very close pair-wise approaches
between particles.

As in Figure 6, we can see from Figure 7 that this system becomes
challenging to integrate for methods without regularization. We Ô¨Ånd
that the BS method accumulates errors quickly, rapidly reaching up
to ‚àº 10‚àí8. The Radau method in ABIE can steadily maintain the
error at the level of ‚àº 10‚àí10 for this integration duration. IAS15
behaves the best as a non-regularized method, keeping the error
near ‚àº 10‚àí12, which is near the limit for non-regularized methods
ùúñ/(1 ‚àí ùëímax) ‚àº 10‚àí16/(1 ‚àí 0.9999). For methods with regulariza-
tion, we Ô¨Ånd that all integration schemes maintain a precision below
10‚àí13 for this problem over the course of the integration duration.
As for the simple test on the sun-earth-moon system, the AR-chain
in SpaceHub is roughly two times faster than Mikkola‚Äôs AR-chain.
Unlike this previous test case, the AR-chain+ method has nearly the
same precision as AR-chain. For this test case, the AR-chain+ method
achieves one order of magnitude higher precision. This is because
there is no chain update in the two body system, such that the active
error compensation can precision compensate the error from the last
step in order to correct the coordinates for the next step. For systems
with frequent chain updates, where the chain coordinates change
frequently, the active error compensation become less useful. The
AR-Radau method achieves 3 orders higher precision than IAS15
for this problem with faster speed. The AR-sym6 method reaches an
energy error of ‚àº 10‚àí14 roughly ten times faster than IAS15. AR-
ABITS is therefore better at dealing with extreme eccentricities and
close encounters, achieving 4 orders of magnitude higher precision
with a run time that is roughly 40 times faster than Brutus for this
test problem.

This test displays the advantage of the regularization schemes in
dealing with extreme eccentricities and close encounters. With reg-
ularization, we can always get better results with faster speed. In
SpaceHub, one can introduce the regularization algorithm in any
method provided that it is used the ‚Äôregularized system‚Äô as the inte-
gration scheme.

4.1.3 Outer Solar System

Next, we test the outer solar system. We consider four planets: Jupiter,
Saturn, Uranus and Neptune and evolve the system for 1000 Jupiter
orbits.

From Figure 8, we can see that for this system in which there is
no strong interaction, even the BS method in SpaceHub can achieve
10‚àí14. There are not many advantages in introducing the regulariza-
tion and chain because there is no close encounter or close position
subtraction. Therefore, the AR-chain dose not show better precision
than the BS method. But both of them show great precision due to
the improvements on BS extrapolation. Similarly as in the previous
two tests, AR-chain in SpaceHub is 2-2.5 times faster than Mikkola‚Äôs

MNRAS 000, 1‚Äì18 (2015)

implementation. The AR-chain+ shows one order higher precision
than AR-chain in this case because the chain update is not as fre-
quent as in the sun-earth-moon system. Therefore, the active error
compensation could do a better job on reducing the round oÔ¨Ä error.
AR-Radau, AR-sym6 perform slightly better than IAS15 in this case,
but AR-sym6 is 2 times slower due to its extra evaluation for error
estimation.

The arbitrary precision AR-ABITS and Brutus with 88 mantissa
bits show signiÔ¨Åcant error accumulation in the test case. These cases
become ineÔ¨Écient in both precision and speed. However, they are
designed to achieve extremely high precision by adopting double
precision machine precision. One can always achieve higher precision
by using more mantissa bits.

4.1.4 Lidov-Kozai system

In this section, we move on to quantifying the performance of the
diÔ¨Äerent integration methods considered in this system for a three-
body system undergoing Lidov-Kozai oscillations.

We have already tested extremely eccentric systems, but these
are only two-body systems and some algorithms oÔ¨Äer advantages
tailored for solving the two-body problem more precisely. To make
our tests more robust, we now test a hierarchical three-body system
undergoing strong Lidov-Kozai cycles. The system consists of an
inner binary with component masses ùëö1 = 1ùëÄ(cid:12) and ùëö2 = 1ùëÄ(cid:12) and
the initial orbital parameters ùëé1 = 10 au and ùëí1 = 10‚àí3. The mass
of the outer tertiary is ùëö3 = 1ùëÄ(cid:12) with ùëé2 = 100 au and ùëí2 = 0.5
initially. The initial inclination angle between the inner and outer
orbital planes is ùëñtot = 96.7‚ó¶. The maximum ùëí1 (ùë°) reached in this
system is larger than 0.999999. We integrate the system up to 105
years, which corresponds to approximately 6 quadrupole LK cycles.
From Figure 9, we see that this three-body system is challeng-
ing to model precisely and accurately for some methods. During the
integration, the step size of the Radau method in ABIE shrinks to
10‚àí14 years as the eccentricity of the inner binary reaches its max-
imum value. Consequently, it takes an excessively long time for the
integration to complete. The IAS15 in Rebound cannot maintain its
high precision after the Ô¨Årst eccentricity excitation. The precision
drops to 10‚àí10 for this test case. However, we Ô¨Ånd that methods with
regularization, including AR-Radau and AR-sym6+, can maintain an
error of ‚àº 10‚àí13. The AR-chain method from Mikkola is three times
slower. The arbitrary precision integration method characteristic of
AR-ABITS in SpaceHub behaves much better that than Brutus in
terms of both speed and precision.

4.2 Long time integration

For our Ô¨Ånal test case, we perform a long term integration test using
the new algorithms in SpaceHub. We integrate the same system as
described in Section 4.1.4 up to 5√ó109 years, which corresponds
to 1.5√ó108 orbits of the inner binary and 3 million quadrupole
LK cycles. The maximum eccentricity of the system is higher than
0.999999.

From Figure 10, we see that the relative energy error of IAS15
instantly increases around 1000 orbits, where the eccentricity of the
inner orbit of the hierarchical triple reaches its Ô¨Årst maximum in the
Ô¨Årst LK cycle. For regularized algorithms that include AR-Chain+,
AR-Radau+ and AR-sym6+ in SpaceHub, the relative energy error
is maintained at 10‚àí13. As the integration continues, IAS15 has
several signiÔ¨Åcant error jumps due to the high eccentricity of the
LK cycles. It becomes completely unreliable around 105 orbits as

Few-body toolkit SpaceHub

13

Figure 6. Relative energy error and performance tests on the sun-earth-moon system. The integration duration is 1000 moon orbits. Left panel: Relative energy
errors for diÔ¨Äerent integration methods in SpaceHub (without parentheses) as a function of the number of orbital periods and for diÔ¨Äerent integration methods
adopted in other codes (with the names of the codes indicated in parentheses). Middle panel: CPU wall time for each integration method. Right Panel: Root mean
square relative energy error (accumulated over time) versus CPU wall time. The relative tolerance is 10‚àí14 and the absolute tolerance is 0 for methods that can
be adjusted. All methods use IEEE-754 double precision Ô¨Çoating point numbers, except for ‚ÄôAR-ABITS‚Äô and ‚ÄôBS(Brutus)‚Äô. ‚ÄôAR-ABITS‚Äô and ‚ÄôBS(Brutus)‚Äô use
88 mantissa bits and non-standard extended Ô¨Çoating-point numbers. Methods with bold-faced font are new unique methods in SpaceHub. The initial conditions
and performance test descriptions can be found at https://github.com/YihanWangAstro/SpaceHub/tree/master/test/regression_test.

Figure 7. Similar test to Figure 6 but on an extremely eccentric two body system. The central body has a mass of 1 ùëÄ(cid:12) and the orbiting body has a mass of
1 ùëÄ‚äï with an initial semi-major axis of 1 au and an initial eccentricity of 0.9999. The integration duration is 1000 orbits.

the relative energy error grows to 1. The relative energy error of
the regularized algorithms in SpaceHub accumulate from largely
reduced but inevitable round-oÔ¨Ä errors. For this case, the AR-Radau+
and AR-sym6+ behave similar to AR-Chain+, which was unexpected
as we anticipated the latter method to perform better. Indeed, with
some extra exploration, we Ô¨Ånd that in most of the cases, the relative
energy errors are at the same order in the long term integration. It
depends on the individual nature of speciÔ¨Åc problems, but the chain
algorithm and active error compensation have signiÔ¨Åcantly diÔ¨Äerent
impacts on the long term round-oÔ¨Ä error. Thus, these method can
standout in our tests by ‚àº 1 order of magnitude. However, they all can

maintain higher precision and do a better job than other integrator
schemes in long term integrations for extremely high eccentricity
systems.

5 IMPLEMENTATION OF PAIR-WISE EXTERNAL

FORCES

In this section, we describe SpaceHub‚Äôs implementation of all non-
Newtonian forces, including tidal dissipation and Post-Newtonian
corrections to account for general relativistic eÔ¨Äects.

MNRAS 000, 1‚Äì18 (2015)

02004006008001000orbits10211020101910181017101610151014E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)Bulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)101100101CPU time [s]0.070.080.100.490.710.380.3446.6216.180.21101100101CPU time [s]10181017101610151014RMS E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)53 mantissa bits machine precision02004006008001000orbits1016101410121010108E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)Bulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)101100101102CPU time [s]0.200.040.041.600.262.151.05156.564.020.09101100101102CPU time [s]10141013101210111010109108RMS E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)14 Wang et al.

Figure 8. Similar test to Figure 6 but applied to the outer solar system. The system consists of a central body with a total mass of the inner solar system and
four outer planets Jupiter, Saturn, Uranus and Neptune. The integration duration is 1000 Jupiter orbits.

Figure 9. Similar test to Figure 6 but for a Lidov-Kozai system. The system consists of an inner binary with component masses ùëö1 = 1ùëÄ(cid:12) and ùëö2 = 1ùëÄ(cid:12)
and an initial semi-major axis and eccentricity of, respectively, ùëé1 = 10 au and ùëí1 = 10‚àí3. The outer tertiary has mass ùëö3 = 1ùëÄ(cid:12) with an orbit having an initial
semi-major axis and eccentricity of ùëé2 = 100 au and ùëí2 = 0.5. The inclination between the inner and outer orbit is 96.7‚ó¶ initially. The integration duration is
105 years, which corresponds to roughly 6 LK cycles. In this test, the step size of the Radau method in ABIE shrinks to 10‚àí14 years, implying a very long time
to Ô¨Ånish the integration test. Thus, ABIE failed in this test.

5.1 Static tidal forces

Here we describe our implementation of equilibrium tidal forces
based on the weak friction model, where the tides are assumed to
take on an equilibrium shape with a constant time lag. In this model,
the tidal force exerted on body ùëöùëñ with radius ùëÖùëñ is implemented as
(Hut 1981)

Then, the acceleration ùëéùëñ due to the tidal dissipation exerted by

body ùëöùëñ on body ùëö ùëó , and vice versa, can be written

aùëñ

a ùëó

= Ftid/ùëö ùëó
= Ftid/ùëöùëñ .

(110)

(111)

For the tidal force in the radial direction ùêπùëü , the angular momentum
of the two body system is conserved as

F = ‚àí3ùê∫

ùëö2
ùëó
ùëü2

(cid:18) ùëÖùëñ
ùëü

(cid:19)5

(cid:18)

ùëò

1 + 3

(cid:19)

ùúè

ÀÜr

(cid:164)ùëü
ùëü

(109)

‚Ñé = ùúá

‚àöÔ∏É

ùê∫ ùëÄùëé(1 ‚àí ùëí2) ,

(112)

where ùëü, ùëò and ùúè are, respectively, the apsidal motion constant and
lag time, the relative distance between ùëö ùëó and ùëöùëñ, the tidal apsidal
motion constant and the tidal time lag.

where ùúá = ùëöùëñùëö ùëó /(ùëöùëñ + ùëö ùëó ) is the reduced mass of the two-body
system, ùëÄ = ùëöùëñ + ùëö ùëó is the total mass, ùëé is the semi-major axis of
the orbit and ùëí is the eccentricity. There are two eÔ¨Äects included in

MNRAS 000, 1‚Äì18 (2015)

02004006008001000orbits10171016101510141013E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)Bulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)101100101102CPU time [s]0.090.090.110.461.170.610.53129.6125.170.24101100101102CPU time [s]101510141013RMS E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)050010001500200025003000orbits101510131011109107E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)BS(Brutus)AR-ABITSAR-chain(Mikkola)Bulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)Radau(ABIE)BS(Brutus)AR-ABITSAR-chain(Mikkola)100101102CPU time [s]0.260.230.301.802.254.03281.9343.370.69100101102CPU time [s]1013101210111010109108107106RMS E/EBulirsch-StoerAR-chainAR-chain+AR-Radau+AR-sym6+IAS15(REBOUND)BS(Brutus)AR-ABITSAR-chain(Mikkola)Few-body toolkit SpaceHub

15

Figure 10. An integration of the same Lidov-Kozai system as in Figure 9 but up to 5 √ó 109 years, which is about 1.6√ó108 inner orbits periods. This test is
performed on Stony Brook‚Äôs Seawulf cluster on an Intel Xeon Gold 6148 CPU with GCC-9.2.0 compiler.

this tidal force, the Ô¨Årst is the tidal dissipation of the orbital energy,
where the orbital energy

ùê∏orb = ‚àíùê∫

ùëöùëñùëö ùëó
2ùëé

dissipates at a rate of

(113)

(cid:164)ùê∏orb = ‚àí

9
2

where

ùê∫2 (ùëöùëñ + ùëö ùëó )ùëö2

ùëó ùëÖ5

ùëñ ùëòùúèùëé‚àí9 (1 ‚àí ùëí2)‚àí15/2ùëí2 ùëì1 (ùëí2) (114)

ùëì1 (ùëí2) = 1 +

15
2

ùëí2 +

15
8

ùëí4 +

ùëí6 .

5
64

(115)

Due to conservation of angular momentum, one obtains (cid:164)ùëé(ùë° ‚Üí
+‚àû) = (cid:164)ùëí(ùë° ‚Üí +‚àû) = 0 and

ùëí(ùë° ‚Üí +‚àû) = 0
ùëé(ùë° ‚Üí +‚àû) = ùëé0 (1 ‚àí ùëí2
0)
(117)
where ùëé0 and ùëí0 are the initial semi-major axis and eccentricity,
respectively.

(116)

The second eÔ¨Äect due to this force is the periastron percession,

5.2 Post-Newtonian corrections and general relativistic eÔ¨Äects

In this section, we describe SpaceHub‚Äôs treatment of general rel-
ativistic eÔ¨Äects via the inclusion of Post-Newtonian terms in our
estimates for the gravitational acceleration.

The Post-Newtonian approximation in general relativity is of the

general form

ùêπGR = ùëê‚àí2ùêπ1PN + ùëê‚àí4ùêπ2PN + ùëê‚àí5ùêπ2.5PN

(119)

where ùëê‚àí2ùêπ1PN contributes most of the periastron precession mo-
tion, ùëê‚àí4ùêπ2PN contributes a correction proportional to (ùë£/ùëê)2 and
ùëê‚àí5ùêπ2.5PN contributes almost all of the gravitational radiation. The
force exerted on particle ùëñ is (Damour & Deruelle 1985; SoÔ¨Äel 1989),

ùêπ1PN =

ùê∫ùëöùëñùëö ùëó
ùëü2
ùê∫ùëöùëñ
ùëü

+5

(cid:26)

(cid:20)

n

‚àí ùë£2

ùëñ ‚àí 2ùë£2

ùëó + 4ùë£ùëñùë£ ùëó +

(ùëõùë£ ùëó )2

3
2

(cid:21)

ùê∫ùëö ùëó
ùëü

+ 4

+ v[4ùëõùë£ùëñ ‚àí 3ùëõùë£ ùëó ]

(cid:27)

(120)

where the pericentre will precess at a rate given by
1 + 3
2

ùëí4

ùëÖ5
ùëñ
ùëé5

ùëòùëõ

ùëí2 + 1
8
(1 ‚àí ùëí2)5

(cid:164)ùúîtide =

15
2

ùëö ùëó
ùëöùëñ
‚àöÔ∏É

where ùëõ =

ùê∫ (ùëöùëñ + ùëö ùëó )/ùëé3 is the mean motion of the binary orbit.

Figure 11 shows examples of the orbital evolution including the
tidal force, where the binary consists of two 1 ùëÄ(cid:12) mass stars. The
primary star is treated as a point mass, while the secondary star has
a radius of 1 ùëÖ (cid:12) with ùëò = 0.75 and ùúè = 0.25 years. The initial semi-
major axis of the binary is 1 au, and we test diÔ¨Äerent eccentricities,
speciÔ¨Åcally 0.6 to 0.89, 0.9 and 0.91.

The upper left panel of Figure 11 shows the pericentre precession
rate for diÔ¨Äerent initial eccentricities as a function of time. We see
that the numerical result agrees closely with the analytic prediction
given by Equation 118. The bottom left panel shows the absolute
diÔ¨Äerence between the numerical and the analytic results. The upper
right panel of Figure 11 shows the orbital energy decay rate due
to tidal dissipation calculated form the numerical simulations and
compared to the analytic results obtained from Equation 114. The
bottom right panel shows the corresponding relative error of the
dissipation rate.

(118)

ùêπ2PN =

ùê∫ùëöùëñùëö ùëó
ùëü2

(cid:26)

(cid:20)

n

‚àí 2ùë£4

ùëó + 4ùë£2

ùëó (ùë£ùëñùë£ ùëó ) ‚àí 2(ùë£ùëñùë£ ùëó )2 +

3
2

ùëñ (ùëõùë£ ùëó )2
ùë£2

+

+

9
2
ùê∫ùëöùëñ
ùëü

ùëó (ùëõùë£ ùëó )2 ‚àí 6(ùë£ùëñùë£ ùëó )(ùëõùë£ ùëó )2 ‚àí
ùë£2

(cid:18)

‚àí

15
4

ùë£2
ùëñ +

5
4

ùë£2

ùëó ‚àí

5
2

ùë£ùëñùë£ ùëó +

(ùëõùë£ùëñ)2

15
8

(ùëõùë£ ùëó )4

39
2
ùê∫ùëö ùëó
ùëü

(cid:18)

‚àí39(ùëõùë£ùëñ)(ùëõùë£ ùëó ) +

(ùëõùë£ ùëó )2

(cid:19)

+

17
2

4ùë£2

ùëó ‚àí 8ùë£ùëñùë£ ùëó

+2(ùëõùë£ùëñ)2 ‚àí 4(ùëõùë£ùëñ)(ùëõùë£ ùëó ) ‚àí 6(ùëõùë£ ùëó )2

(cid:19) (cid:21)

(cid:20)

+v

ùëñ (ùëõùë£ ùëó ) + 4ùë£2
ùë£2

ùëó (ùëõùë£ùëñ) ‚àí 5ùë£2

ùëó (ùëõùë£ ùëó ) ‚àí 4(ùë£ùëñùë£ ùëó )(ùëõùë£ùëñ)

9
2
ùê∫ùëö ùëó
ùëü

+4(ùë£ùëñùë£ùëñ)(ùëõùë£ ùëó ) ‚àí 6(ùëõùë£ùëñ)(ùëõùë£ ùëó )2 +

(ùëõùë£ ùëó )3

ùê∫ùëöùëñ
ùëü

+

(cid:18)

‚àí

(cid:18)

n

‚àí

+

ùê∫2
ùëü2

63
4

57
4

ùëõùë£ùëñ +

(cid:19)

+

ùëõùë£ ùëó

55
4

(cid:18)

‚àí 2ùëõùë£ùëñ ‚àí 2ùëõùë£ ùëó

(cid:19)(cid:21)

ùëö2

ùëñ ‚àí 9ùëö2

ùëó ‚àí

(cid:19) (cid:27)

ùëöùëñùëö ùëó

69
2

(121)

MNRAS 000, 1‚Äì18 (2015)

100102104106108orbits10141011108105102101E/EIAS15(REBOUND)AR-chain+AR-Radau+AR-sym6+16 Wang et al.

Figure 11. Test of the pericenter precession and orbital energy dissipation from the static tidal force. The system consists of two 1ùëÄ(cid:12) stars in a binary with
semi-major axis 1 au. DiÔ¨Äerent eccentricities are selected, speciÔ¨Åcally 0.6, 0.89, 0.9 and 0.91. The primary star is treated as a point mass particle that does not
exert tides, while the secondary star exerts tides with apsidal motion constant ùëò = 0.75 and time lag ùúè = 0.25 years. Left panels: Pericenter precession rate for
diÔ¨Äerent eccentricities obtained from the simulations and compared to the analytic results obtained from Equation 118. Right panels: Orbital energy dissipation
rate calculated from the simulations and compared to the analytic approximation given by Equation 114.

ùêπ2.5PN = ùëöùëñ

4
5
(cid:34)

(cid:26)

ùê∫2ùëöùëñùëö ùëó
ùëü3

(cid:20)

n(ùëõùë£)

3ùë£2 ‚àí 6

ùê∫ùëöùëñ
ùëü

+

(cid:21)

ùê∫ùëö ùëó
ùëü

52
3

+v

‚àí ùë£2 + 2

ùê∫ùëöùëñ
ùëü

‚àí 8

(cid:21) (cid:27)

ùê∫ùëö ùëó
ùëü

(122)

where n = ÀÜr is the unit vector pointing from particle ùëó to particle ùëñ,
and v = vùëñ ‚àí v ùëó where vùëñ and vùëñ are the velocities of particles ùëñ and ùëó,
respectively. For simplicity, we have denoted the dot product of the
two vectors x1 and x2 as ùë•1ùë•2. To obtain the force exerted on particle
ùëó, we simply exchange the subscripts ùëñ and ùëó in the above equations.
Note that the direction of n and v will change as well.

Figure 12 shows an example of the time evolution of the relative
orbital phase for an identical solar mass binary with an initial semi-
major axis of 0.1 AU. We include Post-Newtonian terms up to Ô¨Årst
order, and observe the resulting pericentre advance due to GR pre-
cession. The solid lines in the upper panel show the precession angle
as a function of time assuming diÔ¨Äerent eccentricities. The dashed
line is calculated from the analytic equation

ŒîùúîGR,analytic =

24ùúã3ùëé2
ùëá 2ùëê2 (1 ‚àí ùëí2)

ùë°
ùëá

(123)

where ùëá is the period of the binary and ùëê is the speed of light. The
bottom panel shows the diÔ¨Äerence between the analytic approxima-
tion and our simulation results as a function of time. Note that the

MNRAS 000, 1‚Äì18 (2015)

relative diÔ¨Äerence between the two remains bounded and does not
grow in time.

Figure 13 shows the time evolution of the orbital parameters for
a tight eccentric black hole binary with component masses ùëÄ1 =
30ùëÄ(cid:12) and ùëÄ2 = 50ùëÄ(cid:12) and an initial semi-major axis equal to 0.01
AU. We include Post-Newtonian terms up to 2.5th order and observe
the subsequent evolution driven by gravitational wave radiation. The
solid lines in the upper panels show the orbital decay rate as a function
of time. The bottom panels show the relative diÔ¨Äerence between our
simulated results and the analytic approximation. We see that the
relative diÔ¨Äerence in the semi-major axis remains less than 10‚àí6
AU/year ‚àº 5 mm/s, and the relative diÔ¨Äerence in the eccentricity
remains less than 10‚àí5/ year. The analytic approximation cosely
follows Peter‚Äôs Equation (Peters 1964).

ùëëùëé
ùëëùë°

ùëëùëí
ùëëùë°

(cid:12)
(cid:12)
(cid:12)
(cid:12)GW
(cid:12)
(cid:12)
(cid:12)
(cid:12)GW

= ‚àí

64
5

= ‚àí

304
15

ùê∫3ùëö1ùëö2 (ùëö1 + ùëö2)
ùëê5ùëé3 (1 ‚àí ùëí2)7/2
ùê∫3ùëö1ùëö2 (ùëö1 + ùëö2)ùëí
ùëê5ùëé4 (1 ‚àí ùëí2)5/2

(1 +

73
24

ùëí2 +

37
96

ùëí4)(124)

(1 +

121
304

ùëí2).

(125)

6 CONCLUSIONS

We have developed the deeply optimized high precision open source
few-body toolkit SpaceHub. In this code, several state-of-the-art al-

0200040006000800010000t [yr]0.00.20.40.60.81.0tide [yr1]1e5e=0.6e=0.89e=0.9e=0.91analytic0200040006000800010000t [yr]1011109107tide,err [yr1]0200040006000800010000t [yr]6420Eorb [ yr1]1e4e=0.6e=0.89e=0.9e=0.91analytic0200040006000800010000t [yr]0.000.010.02|Eorb|/|Eorb| Few-body toolkit SpaceHub

17

from this, we introduce regularization into the arbitrary precision
method, which makes it even more eÔ¨Écient in dealing with highly
eccentric systems.

In section 3.2, we discuss the original algorithmic regulariza-
tion chain algorithm AR-chain. In this section, we propose an im-
proved chain coordinate transformation that eliminates the centre-of-
mass reduction. This saves non-negligible CPU time in the few-body
regime, and introduces the active round oÔ¨Ä error compensation into
the AR-chain to form the AR-chain+ method. The new algorithm
is faster and more accurate in the high precision regime, where the
round oÔ¨Ä error is non-negligible.

In Section 3.3, we discuss regularization in higher order symplec-
tic methods. The AR-sym6+ algorithm, a sixth-order regularized
symplectic method with active round oÔ¨Ä error compensation, makes
it possible to accurately and eÔ¨Éciently solve extremely eccentric
systems and very close pair-wise encounters with Ô¨Åxed step size.
Consequently, the symplectic nature of the evolving system is pre-
served.

In Section 3.4, we introduce regularization into the Gauss-Radau
method using extended general coordinates. With the regularization
and active round oÔ¨Ä error compensation, the AR-Radau+ algorithm
becomes more eÔ¨Écient in solving the time evolution of extremely
eccentric orbits than the original Gauss-Radau method. At the same
time, it preserves the advantages of the original method in long time
integrations.

SpaceHub is fully open source. All of the new state-of-the-art al-
gorithms discussed above can be accessed via GitHub at https:
//yihanwangastro.github.io/SpaceHubWeb/. Together with
the implementation of additional pair-wise interactions, such as tidal
and Post-Newtonian forces, not to mention a myriad of other per-
formance and optimization tools, SpaceHub undoubtedly competes
with, challenges and even surpasses the most commonly used codes
and gravity integrators used in the Ô¨Åeld today for dealing with astro-
physical problems ranging from extrasolar planetary systems, black
hole binaries, etc., in terms of not only accuracy and precisions but
also speed.

ACKNOWLEDGEMENTS

N.W.C.L. gratefully acknowledges support from the Chilean govern-
ment via Fondecyt Iniciacion Grant 11180005, and acknowledges
Ô¨Ånancial support from Millenium Nucleus NCN19_058 (TITANs).
Bin Liu gratefully acknowledges support from the European Union‚Äôs
Horizon 2020 research and innovation program under the Marie
Sklodowska-Curie grant agreement No. 847523 ‚ÄòINTERACTIONS‚Äô.
RP gratefully acknowledges support from NSF award AST-2006839.

DATA AVAILABILITY STATEMENTS

Data are available in a repository and can be accessed via https:
//yihanwangastro.github.io/SpaceHubWeb/.

REFERENCES

Aarseth S. J., Zare K., 1974, Celestial Mechanics, 10, 185
Boekholt T., Portegies Zwart S., 2015, Computational Astrophysics and Cos-

mology, 2, 2

Brouwer D., 1937, AJ, 46, 149
Brouwer D., Clemence G. M., 2013, Methods of celestial mechanics. Elsevier
Bulirsch R., Stoer J., 1966, Numerische Mathematik, 8, 1

MNRAS 000, 1‚Äì18 (2015)

Figure 12. Test of the general relativistic precession adopting only the Ô¨Årst
order Post-Newtonian term. The binary consists of two identical solar mass
stars with an initial semi-major axis of 0.1 AU. The eccentricities are initially
set to 0.6, 0.9, 0.95 and 0.99, as indicated by the diÔ¨Äerent colours in the
insets. Upper panel: Calculation results from SpaceHub using the AR-Chain+
method. The dashed black line shows the theoretical expectation for each
value of the eccentricity as described by Equation 123. Bottom panel: The
relative diÔ¨Äerence between the results of our computations and the analytic
expectation, as a function of time.

gorithms are provided that are applicable to a variety of astrophysi-
cal few-body problems. The new algorithms include: an algorithmic
regularization chain with active round oÔ¨Ä error compensation AR-
Chain+, a regularized arbitrary precision algorithm AR-ABITS, a
regularized higher order symplectic method with active round oÔ¨Ä er-
ror compensation AR-sym6+ and a regularized Gauss-Radau method
with active round oÔ¨Ä error compensation AR-Radau+. By comparing
to popular high precision few-body codes via various applications to
the time evolution of various astrophysical test cases, we show that
SpaceHub consistently provides the most precise, accurate and fastest
algorithm for most speciÔ¨Åc astrophysical problems of interest in the
few-body limit.

We begin by brieÔ¨Çy reviewing the existing Bulirsch-Stoer-based
high precision integration methods and Gauss-Radau-based meth-
ods, and discuss the improvements we have made on these algo-
rithms. In Section 3.1, we discuss the arbitrary precision method
with extended Ô¨Çoating point precision. We then go on to discuss our
implementation and improvements in our new regularized arbitrary
precision method AR-ABITS. The AR-ABITS method achieves ar-
bitrary precision based on the GBS extrapolation. By adopting an
optimal extrapolation step sequence and a Ô¨Åne-tuned extrapolation
process, the round oÔ¨Ä error can be signiÔ¨Åcantly reduced with the
provided bits Ô¨Çoating-point numbers. We show that to achieve the
same arbitrary precision, AR-BITS is roughly 1-2 orders of magni-
tude faster than the popular arbitrary precision code Brutus. Apart

020406080100t [yr]0.00.20.40.60.8GR [rad]e=0.99e=0.95e=0.9e=0.6analytic020406080100t [yr]108106104102GR,err [rad]e=0.99e=0.95e=0.9e=0.618 Wang et al.

Figure 13. Test of the orbital evolution due to gravitational wave radiation using up to 2.5th order in the Post-Newtonian terms. The binary has component
masses of 30 M(cid:12) and 50 M(cid:12) with an initial semi-major axis equal to 0.01 AU. The eccentricities are initially set to 0.894, 0.896, 0.898 and 0.9, as indicated
by the colour scheme deÔ¨Åned in each inset. Upper panels: Calculation results from SpaceHub using the AR-Chain+ method and the analytic results calculated
from Equations 124 and 125.Bottom panels: The relative diÔ¨Äerence between the results of our computations and the analytic expectation, as a function of time.

Quinn T., Tremaine S., 1990, The Astronomical Journal, 99, 1016
Rantala A., Pihajoki P., Mannerkoski M., Johansson P. H., Naab T., 2020,

Monthly Notices of the Royal Astronomical Society, 492, 4131

Rein H., Spiegel D. S., 2014, MNRAS
SoÔ¨Äel M. H., 1989, Relativity in Astrometry, Celestial Mechanics and

Geodesy

Stetter F., 1968, Mathematics of Computation, 22, 661‚Äì661
Wang Y.-H., Leigh N., Yuan Y.-F., Perna R., 2018, MNRAS, 475, 4595
Wang Y.-H., Leigh N., Sesana A., Perna R., 2019a, MNRAS, 482, 3206
Wang Y.-H., Leigh N. W. C., Sesana A., Perna R., 2019b, MNRAS, 490, 2627
Wang Y.-H., Perna R., Leigh N. W. C., 2020a, MNRAS, 496, 1453
Wang Y.-H., Perna R., Leigh N. W. C., 2020b, ApJ, 891, L14
Wang Y.-H., Leigh N. W. C., Perna R., Shara M. M., 2020c, ApJ, 905, 136
Yoshida H., 1990, Physics Letters A, 150, 262
Zare K., 1974, Celestial Mechanics, 10, 207

This paper has been typeset from a TEX/LATEX Ô¨Åle prepared by the author.

Damour T., Deruelle N., 1985, Annales de l‚ÄôI.H.P. Physique th√©orique, 43,

107

DeuÔ¨Çhard P., 1983, Numerische Mathematik, 41, 399
Everhart E., 1985, International Astronomical Union Colloquium, 83, 185
Fukushima T., 1996, AJ, 112, 1298
Gragg W. B., 1965, SIAM Journal on Numerical Analysis, 2, 384
Heggie D. C., 1974, Celestial Mechanics, 10, 217
Hut P., 1981, A&A, 99, 126
Kahan W., 1965, Commun. ACM, 8, 40
Levison H. F., Duncan M. J., 1994, Icarus, 108, 18
Liu B., Lai D., Wang Y.-H., 2019a, ApJ, 881, 41
Liu B., Lai D., Wang Y.-H., 2019b, ApJ, 883, L7
Mikkola S., Aarseth S. J., 1990, Celestial Mechanics and Dynamical Astron-

omy, 47, 375

Mikkola S., Aarseth S. J., 1993, Celestial Mechanics and Dynamical Astron-

omy, 57, 439

Mikkola S., Aarseth S., 2002, Celestial Mechanics and Dynamical Astronomy,

84, 343

Mikkola S., Merritt D., 2008, The Astronomical Journal, 135, 2398
Mikkola S., Tanikawa K., 1999a, Celestial Mechanics and Dynamical As-

tronomy, 74, 287

Mikkola S., Tanikawa K., 1999b, MNRAS, 310, 745
Perna R., Wang Y.-H., Farr W. M., Leigh N., Cantiello M., 2019, ApJ, 878,

L1

Peters P. C., 1964, Physical Review, 136, B1224
Press W. H., Flannery B. P., Teukolsky S. A., 1986, Numerical recipes. The

art of scientiÔ¨Åc computing

Press W. H., Teukolsky S. A., Vetterling W. T., Flannery B. P., 2002, Numer-

ical recipes in C++ : the art of scientiÔ¨Åc computing

Preto M., Tremaine S., 1999, AJ, 118, 2532

MNRAS 000, 1‚Äì18 (2015)

0204060t [yr]1.11.00.90.8da/dt [au yr1]1e4e=0.894e=0.896e=0.898e=0.9analytic0204060t [yr]1010109108107106da/dterr [au yr1]0204060t [yr]8642de/dt [yr1]1e3e=0.894e=0.896e=0.898e=0.9analytic0204060t [yr]109108107106105de/dterr [yr1]