A Framework for Automating Deployment and Evaluation of
Blockchain Networks

Nguyen Khoi Trana, M. Ali Babara,b, Andrew Waltersc

aThe University of Adelaide, South Australia, Australia
bCyber Security Cooperative Research Centre, Australia
cDefence Science and Technology Group, Australia

2
2
0
2

l
u
J

4
2

]
E
S
.
s
c
[

2
v
7
4
6
0
1
.
3
0
2
2
:
v
i
X
r
a

Abstract

A blockchain network is a distributed system established by mutually distrusting participants to operate a blockchain,
enabling them to manage critical information such as account balances or asset ownership without a centralised third
party. Blockchain network deployment and evaluation have become prevalent due to the emerging blockchain use cases
by enterprises, governments, and Internet of Things (IoT) applications, which demand private blockchains rather than
participating in public ones. A blockchain network architecture drives deployment and evaluation activities. Nevertheless,
practitioners must learn and perform error-prone activities to transform architecture into a blockchain network and
evaluate it. Therefore, it is beneﬁcial to automate these activities so that practitioners can focus on the architecture
design, a valuable and hard-to-automate activity. The key challenges of such an automation framework are keeping
up with the advances in blockchain technologies and the increasing complexity of blockchain network architecture.
This paper proposes NVAL, a software framework that implements a novel architecture-driven, community-supported
approach to automate blockchain network deployment and evaluation. NVAL accepts blockchain network architecture
as input.
It supports complex multi-channel blockchain networks, an increasingly prevalent architecture for private
blockchain. The framework keeps up with blockchain technologies by leveraging platform-speciﬁc automation programs
developed by a practitioner community via runtime composition to handle new networks. We evaluated NVAL with a
case study and showed that the framework requires only seven automation programs to deploy 65 blockchain networks
with 12 diverse architectures and generate 295 evaluation datasets. Furthermore, it consumes only 95.5 ms to plan and
orchestrate the deployment and evaluation, which is minuscule compared to the total time required for deploying and
benchmarking a blockchain network.

Keywords: Blockchain, Distributed Ledger, Deployment, Evaluation, Automation, Framework

1. Introduction

A blockchain can be deﬁned as a secure database and a
replicated state machine operated by a distributed network
of mutually distrusting participants [1, 2, 3]. It helps par-
ticipants to maintain and update shared state information,
such as account balances or asset ownership, without rely-
ing on a centralised third party [4]. The database contains
transactions that describe state updates such as transfer-
ring currency between accounts. The state machine pro-
cesses transactions to calculate a new state, such as new
account balances after currency transfer [3]. Both block-
chain’s database and state machine are replicated across
participants and synchronised by a fault tolerant consensus
protocol [5], ensuring that participants can access the state
information and detect divergence by others. By embed-
ding data and logic into blockchain’s transactions, state
variables, and state machines, participants conduct busi-
ness processes without appointing a third party, reducing

Email address: nguyen.tran@adelaide.edu.au (Nguyen Khoi

Tran)

the failure risks and insider threats [6, 7]. Blockchains have
been leveraged successfully for ﬁnancial use cases such as
cryptocurrency (digital cash) [8], digital assets [9], and de-
centralised ﬁnance platforms [10]. Blockchains have also
been used as a secure timestamping service to prove the
existence and authenticity of documents and a means for
resisting information censorship [8]. Most of the described
use cases utilise global public blockchains such as Ethereum
and Bitcoin. However, there are emerging use cases by en-
terprises, governments, edge computing, and the Internet
of Things (IoT) [11, 12] where public blockchains fail to
provide the necessary performance, scalability, and con-
ﬁdentiality [13]. Therefore, there has been an increasing
demand for permissioned or private blockchains. For in-
stance, when conducting the ﬁrst blockchain-based Letter-
of-Credit (LC) transaction between Vietnam and Korea on
July 3, 2019, HSBC utilised a private blockchain based on
R3’s Corda platform [14] rather than a public one.

A distributed system established by mutually distrust-
ing participants to run a blockchain is known as a block-
chain network [15]. It is made up of distributed computers

Preprint submitted to Journal of Network and Computer Applications

July 26, 2022

 
 
 
 
 
 
running a blockchain client, which is a software implemen-
tation of a blockchain protocol. Public blockchains run
on public blockchain networks that emerge without coor-
dination anonymous Internet users. Private blockchains
are operated by private blockchain networks, which can
be designed, deployed, and evaluated to ensure they ﬁt an
intended use case and hardware infrastructure [15, 2]. Let
us elaborate on the design, deployment, and evaluation of
blockchain networks with the following scenario.

Motivating Scenario: Multiple research labs from dif-
ferent universities wish to connect their robotic testbeds
to form a joint experimentation platform to expand the
scope of their experiments. For instance, researchers can
use the platform to validate a robot coordination mecha-
nism across multiple enviroments by assigning tasks to and
receiving experiment data from edge agents such as un-
crewed ground vehicles (UGV), uncrewed aerial vehicles
(UAV), and uncrewed underwater vehicles (UUV) from
other testbeds. A joint experimentation platform raises
various security requirements: edge agents must verify
the authenticity of incoming mission objectives [16], re-
searchers must verify the integrity and provenance (his-
tory) of the experiment data [17], and infrastructure own-
ers must track researchers’ requests for auditing. The in-
formation necessary for the above requirements constitutes
the platform’s state (e.g., tasking status of a robot) and
the state updates (e.g., a researcher assigning a task to
a robot). Participants can maintain such information se-
curely without hiring a third party or appointing a leader
to operate a centralised service by leveraging a private
blockchain. Doing so requires establishing a private block-
chain network. Participants can control all aspects of the
network, such as where to deploy its constituing blockchain
clients and how to conﬁgure them. Participants can even
split the network into separate blockchain channels that
store diﬀerent information and run diﬀerent blockchain
protocols. For instance, an inter-lab channel connecting
powerful workstations can employ a secure but resource-
intensive blockchain protocol whilst intra-lab channels be-
tween robots and base stations within a testbed can lever-
age a lightweight blockchain protocol (e.g.,
[18]). The
described multi-channel heterogeneous blockchain network
architecture is increasingly prevalent in edge computing
and IoT blockchain use cases [11, 2] as it oﬀers practition-
ers a lot of ﬂexibility to ﬁne-tune their blockchain network.
A blockchain network architecture becomes an opera-
tional network via the blockchain network deployment pro-
cess, which involves provisioning and conﬁguring block-
chain clients according to the architecture [19]. Network
deployment can be followed by blockchain network evalu-
ation, the assessment of the blockchain network’s quality
attributes such as latency and throughput via benchmarks
[20], or simulations [21, 22, 23, 24]. The faster participants
iterate over deployment and evaluation, the more they can
reﬁne their architectures within limited time and resources
[25]. Unfortunately, blockchain network deployment and
evaluation are time-consuming, error-prone, and depen-

dent on platform-speciﬁc knowledge [26, 27]. Therefore,
it is beneﬁcial to improve the eﬀectiveness and eﬃciency
of blockchain network deployment and evaluation via au-
tomation. In fact, “one-click deployment” is a highly de-
manded tool for development and testing according to a re-
cent survey on the state of practice of blockchain-oriented
software engineering [28].

Existing literature reports various approaches and tools
for automating blockchain network deployment and eval-
uation. Practitioners can utilise generic IT automation
tools such as Ansible1 and Terraform2 to perform repeti-
tive activities such as provisioning and starting blockchain
clients across computers to reduce time and implementa-
tion errors. However, generic tools fail to reduce complex-
ity because practitioners must manually transform block-
chain network architectures into tools’ instructions. A re-
cent study on DevOps practices in blockchain-based soft-
ware engineering found little evidence of real-world utilisa-
tion of generic automation tools [29]. Blockchain-speciﬁc
automation frameworks such as PlaTIBART [30], Hyper-
ledger Composer [31] and Hyperledger Bevel [32] (for-
merly known as the Blockchain Automation Framework)
and MixBytes Tank [33] have been proposed to address
the limitation of generic automation tools. Blockchain-
as-a-Service (BaaS) platforms such as uBaaS [26], Nut-
BaaS [19], AWS Managed Blockchain, Azure BaaS, and
IBM Blockchain Platform are cloud services that also
provide “one-click deployment” to provision blockchain
networks on cloud-based virtual machines. While these
tools and services are better than generic automation
tools at abstracting the complexity, we found that most
require low-level and technology-speciﬁc speciﬁcations
(Compose, Bevel, PlaTIBART) or overly-simpliﬁed archi-
tectural models (BaaS platforms), making them too com-
plex or restrictive to users. Moreover, we found that their
applicability and longevity also suﬀer from the following
limitations:

• Lack of support for heterogeneous multi-channel block-
chain networks, a complex blockchain network archi-
tecture that is gaining popularity in blockchain use
cases that involve edge computing and IoT [11, 2].
The heterogeneity of this architecture stands in stark
contrast to the lack of support for multi-channel
topology and multi-technology-per-network of most
current tools and services.

• Limited scope of the supported blockchain platforms.
Blockchain platforms can be considered concrete im-
plementations of blockchain protocols, providing soft-
ware clients and utilities for deploying or participating
in a blockchain network [11]. We found that most of
the current tools only support a few prominent block-
chain platforms. Hyperledger Bevel, the state-of-the-

1https://www.ansible.com
2https://www.terraform.io

2

Figure 1: Users, Workﬂows, and Components of NVAL Framework

art tool with the largest scope at the time of writ-
ing, supports only four blockchain platforms: Fab-
ric, Corda, Indy, and Quorum. Meanwhile, a re-
cent empirical study [34] of 3,664 GitHub reposito-
ries reveals 71 blockchain platforms. Should these
platforms be supported by an automation tool, they
would greatly expand the blockchain network design
options for practitioners and help them establish more
optimal blockchain networks for their use cases. Un-
fortunately, we believe that the current automation
approach which targets speciﬁc blockchain platforms
and relies on a core developer group to approve exten-
sion (e.g., via GitHub pull requests), might not scale
and keep up with the advances in blockchain technol-
ogy. In fact, one of the earlier automation tools for the
Fabric blockchain platform, called Hyperledger Com-
poser, was deprecated in 2021 as Fabric matures.

This paper proposes NVAL (Network Deployment and
Evaluation framework), a software framework that imple-
ments a novel architecture-driven, community-supported
approach to automate the deployment and evaluation of
blockchain networks. The framework is driven by block-
chain network architecture speciﬁcations that describe
high-level design decisions (e.g., network topology, proto-
col choice) and support heterogeneous multi-channel net-
works. Instead of focusing on a few blockchain platforms
and relying on the open-source contribution for exten-
sion, NVAL leverages the existing platform-speciﬁc au-
tomation programs developed by a practitioner commu-
nity by combining them at runtime according to the given
blockchain network architecture for deployment and evalu-
ation. This approach was motivated by many open-source
automation scripts for blockchain networks. As of Febru-
ary 2022, we found 52 open-source GitHub repositories on
automated blockchain network deployment using Ansible,

67 repositories using Terraform, and 35 repositories using
other scripting languages. Most blockchain platforms also
provide deployment instructions in their documentation,
which can be transformed into automation scripts. By
leveraging the automation programs emerging from the
community, we aim to help NVAL keep up with the ad-
vances in blockchain technology that could outpace any
team working alone on the framework.

Let us elaborate on NVAL’s operation and utility via
the motivating scenario. Figure 1 presents an overview of
the framework’s users and workﬂow. NVAL beneﬁts block-
chain network architects and operators, who are members
of the participating research labs appointed to design and
deploy a private blockchain network. Architects gather
requirements (e.g., available hardware, required latency
and throughput, the required level of availability, threat
models) and leverage the existing architectural knowledge
(e.g., [15, 2]) to develop potential blockchain network ar-
chitectures. Operators deploy and evaluate the given ar-
chitectures with the help of NVAL. In order to leverage
the framework, operators deploy an NVAL instance on a
workstation that can access all computers participating
in a blockchain network. Operators start a workﬂow by
submitting a request that contains a blockchain network
architecture and a list of evaluation metrics for measuring
(Step 1). NVAL parses and transforms the request into
an actionable digital artefact (Step 2). The framework
relies on an action pool containing automation programs
(actions) contributed by contributors via open-source or
inner-source channels (Step 3 and Step 4) to process the
request. NVAL leverages its action pool (Step 5) to con-
struct an execution plan that describes a sequence and
inputs of service calls to actions in the pool (Step 6). The
framework applies actions according to the plan (Step 7) to
deploy and evaluate a blockchain network (Step 8). NVAL

3

InfrastructureNVALBC ArchitectsBC OperatorsContributorSpecifyarchitecture and evaluation requestContributeactionPlanfor deployment & evaluationApplyExecutethe plan to deploy and evaluate a blockchain network1268Lab 1Lab 2Lab N…InterfaceTransforminto digital artefactPlannerInformthe planning processOrchestratorAction PoolRetrieve architecture and kernel3457Phase 1: Capturing Blockchain Network Architecture as Digital ArtefactsContribution: BND Meta-model (Section 4)Phase 2: Capturing the automation programs as composable software servicesContribution: Composable Actions (Section 5)Phase 3: Planning and conducting deployment and evaluationContribution: State-space search for planning (Section 6)returns URLs to access the deployed blockchain network
and some datasets containing the required evaluation met-
rics following a successful execution. If NVAL cannot re-
solve a plan, it declares the request unsatisﬁable.

NVAL realises the stated approach with three novel
elements. We propose a novel domain-speciﬁc meta-
model called Blockchain Network Design (BND) to cap-
ture heterogeneous multi-channel blockchain network ar-
chitectures. We propose the concept and architecture of
composable actions to encapsulate and combine the exist-
ing automation programs to process new blockchain net-
work architectures speciﬁed using BND. Finally, we pro-
pose a planning approach based on a state-space search
algorithm to match individual blockchain channels from
a given blockchain network architecture with composable
actions and construct an execution plan for deployment
and evaluation. We demonstrated and evaluated the feasi-
bility of NVAL by conducting a case study on an architec-
ture development project that utilised an NVAL proof-of-
concept system to evaluate diverse blockchain network ar-
chitectures empirically. The results show that NVAL suc-
cessfully leverages seven automation programs to deploy
65 blockchain networks with 12 diverse architectures and
generate 295 evaluation datasets. Furthermore, we found
that NVAL requires only a tenth of a second (95.5 ms) to
plan and orchestrate the deployment and evaluation. This
ﬁgure is minuscule compared to the total time required
for deploying and evaluating a blockchain network, which
ranges from 7 to 14 minutes. The contributions of this
paper are:

• We conceptualise and design the architecture of
NVAL, a software framework for automating block-
chain network deployment and evaluation. NVAL
supports multi-channel heterogeneous blockchain
networks and provides user-driven,
community-
supported extensibility to address the limitations of
the current approaches.

• We propose Blockchain Network Design (BND), a
meta-model for capturing blockchain network archi-
tecture as digital artefacts to guide the automated
deployment.

• We conceptualise and design the architecture of Com-
posable Actions, which encapsulates the existing au-
tomation programs into portable software compo-
nents for runtime composition.

• We propose an automated planning approach for
matching blockchain network architectures with com-
posable actions and constructing execution plans.

• We demonstrated and evaluated NVAL via a case

study, showing its applicability and eﬃciency.

2. Background

2.1. Blockchain Network

A blockchain is a share-write database and a secure
computing engine operated by mutually-distrusting par-
ties [5, 35].
Its operation is based on the consensus be-
tween participants rather than a central authority [6]. Ev-
ery participant hosts and controls some blockchain nodes,
which are computers running a software implementation of
a blockchain protocol. Blockchain nodes form a peer-to-
peer system called a blockchain network to operate and se-
cure a blockchain. Interactions between blockchain nodes
follow a blockchain consensus protocol that dictates how
they agree on the validity and order of blockchain transac-
tions. The Proof-of-Work (PoW) protocol, also known as
Nakamoto consensus [4], is one of the most popular block-
chain consensus protocols for public blockchain networks.
This protocol allows anonymous Internet users to operate
a blockchain securely and resists Sybil attacks, where a
participant creates multiple fake identities to inﬂuence the
consensus process. As PoW-based protocols tend to re-
quire signiﬁcant computing resources, private blockchain
networks generally rely on alternative consensus protocols
such as Proof-of-Authority (PoA), Raft [36], or Practi-
cal Byzantine Fault Tolerance (pBFT) [37]. Cachin and
Vukolic [5] provides a survey of prominent consensus pro-
tocols.

Blockchain nodes within a blockchain network can as-
sume diﬀerent roles, which give them diﬀerent degrees of
autonomy and control over a blockchain and demand dif-
ferent amounts of computing resources [15]:

• Full Nodes hold complete blockchain replicas. They
can verify transactions and execute software scripts
embedded in transactions, also known as smart con-
tracts.

• Mining Nodes participate in a consensus protocol to
process and append transactions. Mining nodes are
usually full nodes, but not the other way around.

• Lightweight Nodes hold only ledger metadata and
must rely on trusted full nodes to verify transactions.
They trade security and independence for reduced
resource consumption.

• Remote Nodes are end-user clients responsible for
crafting and signing transactions on behalf of human
or machine users. They are also known as wallets.

• Network Interfaces oﬀer APIs for remote nodes to in-

teract with a blockchain.

Blockchain networks can be segmented into channels
[15], which connect diﬀerent subsets of blockchain nodes
and maintains separate ledgers. Channels in the same
network do not necessarily use the same blockchain con-
sensus protocol. For instance, the motivating scenario in

4

Section 1 introduced a multi-channel heterogeneous block-
chain network that contains an inter-lab channel running a
resource intensive protocol and multiple intra-lab channels
utilizing lightweight protocols.

2.2. Design Decisions and Architecture of a Blockchain

Network

Private blockchain networks can be designed and de-
ployed in a controlled manner to ensure their ﬁtness for
purpose. For instance, a blockchain network’s architect
can decide to split the network into channels to create a
separation between diﬀerent user groups or business pro-
cesses. An architect can also decide how mining nodes are
assigned to participants, reﬂecting participants’ authority.
By controlling the blockchain network’s topology, conﬁgu-
ration, and deployment, an architect can ﬁne-tune quality
attributes of the network such as performance, resource
consumption, availability, and security [15, 2].

Tran et al. deﬁned a design space of blockchain network
with 19 types of decisions [11], which can be organized into
four types

• Topological design decisions capture the overall shape
of a blockchain network. They include how a network
is segmented into channels and the number of block-
chain nodes per channel.

• Organizational design decisions capture the assign-
ment of blockchain nodes to participants. This as-
signment reﬂects participants’ governance power and
authorization level in the network.

• Consensus design decisions capture the type and con-
ﬁguration of the consensus protocols used by block-
chain channels in the network.

• Deployment design decisions capture the mapping be-
tween blockchain nodes and targeted hardware infras-
tructure.

The architecture of a blockchain network is the collec-
tion of its design decisions. Architecture speciﬁcations can
capture blockchain network architectures as digital arte-
facts that computers can understand and implement. In
this paper, we denote the language for writing such speci-
ﬁcations as a meta-model of blockchain network architec-
ture.

3. Approach

a

novel

NVAL

leverages

architecture-driven,
community-supported approach to automate the de-
ployment and evaluation of
complex multi-channel
blockchain networks. This approach consists of three
phases presented in Figure 1.

The ﬁrst phase is capturing the abstract and implicit
blockchain network architectures as concrete artefacts that
NVAL can understand and process. This phase requires

5

a meta-model that deﬁnes concepts and relationships nec-
essary for architects to describe blockchain network archi-
tectures. We found that the existing view models (4+1
[38]) and notations (Uniﬁed Modelling Language (UML))
lack a standardised way to describe blockchain network
architectures,
leading to ambiguity. Moreover, the ex-
isting view models tend to scatter the design decisions
across multiple views, increasing the complexity of cap-
turing and understanding design decisions and could lead
to inconsistencies. Therefore, we propose a novel domain-
speciﬁc meta-model for capturing blockchain network ar-
chitectures called Blockchain Network Design (BND). The
meta-model deﬁnes standardised concepts, relations, and
architectural structures for modelling blockchain network
architectures based on an existing design space [15]. Ev-
ery blockchain network architecture speciﬁed using BND
simultaneously describes organisational, logical, and phys-
ical aspects of a blockchain network, thus mitigating the
problem of scattering design decisions across multiple
views. Section 4 introduces BND in details.

The second phase is capturing the automation programs
as composable software services that NVAL can combine
to deploy and evaluate multi-channel heterogeneous block-
chain networks. We denote the captured automation pro-
grams as composable actions. Operators can develop ac-
tions from scratch or refactor them from existing inner-
source or open-source automation scripts. Realising the
composable action concept raises two challenges: (1) deﬁn-
ing action scopes such that composition is possible and (2)
minimising eﬀort in developing composable actions. Sec-
tion 5 introduces our architectural solution for composable
actions.

The third phase is planning and conducting the deploy-
ment and evaluation of incoming requests, which contain
blockchain network architectures and lists of metrics to
measure. We regard the action planning for a request as a
search task on its implicit state-space with the goal state
being the successful deployment and evaluation of a re-
quested blockchain network. This decision stems from the
following observations:

• Every request has a state, reﬂecting whether (1) it has
been veriﬁed, (2) its channels have been deployed, and
(3) its requested metrics have been measured.

• Suitable function calls to actions transit requests be-
tween states. These function calls receive fragments of
requests, such as architectural speciﬁcations of block-
chain channels, as inputs. The suitability of these
calls depends on whether the functions can process
the inputs and whether a request is at a state where
such calls are required. For instance, if a requested
blockchain network has not been deployed, it is too
early to invoke evaluation actions.

• The execution plan of a request is, therefore, a se-

quence of action calls that leads to a goal state.

• A request’s state space is implicit because it depends
on NVAL’s action pool when it starts to plan for a
request. If the state-space of a request is exhausted
before reaching a goal state, then the request is un-
satisﬁable with the current action pool.

We propose to employ a state-space search approach [39]
to solve the action planning problem of NVAL. A state-
space search is an eﬀective approach because an agent
(NVAL) has (1) full observability over the states, (2) has
a set of actions with deterministic eﬀects, and (3) can de-
termine whether a state satisﬁes the goal. The main idea
of state-space search is to systematically traverse the state
space to ﬁnd a goal state with a search algorithm such as
breadth-ﬁrst search. The path taken by the search algo-
rithms becomes the execution plan. Section 6 presents the
problem formulation and solution in details.

4. Blockchain Network Design Meta-model

The Blockchain Network Design (BND) meta-model de-
scribes blockchain network architectures as directed prop-
erty graphs. This approach is motivated by the following
observations about the design decisions underlying block-
chain network architectures. Observations (1) to (3) show
that blockchain network architecture can be modelled as
a directed graph whose nodes and edges carry additional
properties (a property graph). Observation (4) shows that
a blockchain network architecture must also contain the or-
ganisational and physical structures around a blockchain
network to provide a context for design decisions.

1. Some design decisions involve adding new connec-
tions between entities. For instance, the assignment
of blockchain nodes to participants can be conceptu-
alised as connections or links between them, specify-
ing “assigned-to” relationships.

2. Some design decisions add both connections and en-
tities. For instance, describing a blockchain network
topology requires introducing entities such as block-
chain nodes and channels. Describing a topology also
requires introducing connections between nodes and
channels, specifying “participate-in” relationships.
3. Some design decisions also involve assigning at-
tributes to existing entities and connections. For in-
stance, the type and conﬁguration of consensus pro-
tocols can be captured as attributes of a “blockchain
channel” entity. Similarly, node type (full, mining,
lightweight, remote, interface) can be modelled as an
attribute of a “blockchain node” entity.

4. Some design decisions require information beyond the
control of an architect. For instance, the decision
to deploy a blockchain node on a server requires in-
formation about the server, such as its speciﬁcation
and network address. Similarly, the decision to as-
sign a blockchain node to a participant requires de-
tails about the participant and possibly its involved

business processes. The architect controls neither the
server nor the participant yet requires to add details
to the architecture to provide context for design deci-
sions.

Meta-model: The BND meta-model deﬁnes six ver-
tex types and ﬁve edge types that architects can use to
build property graphs that represent concrete blockchain
network architectures. Figure 2 presents the types of ver-
tices and edges making up the BND meta-model. The
vertices describe the necessary entities for specifying de-
sign decisions, including blockchain nodes (BNode), block-
chain channels, computing node (Node), computer net-
work (Net), participants, and processes. The edges de-
scribe the relationships between entities. For example,
an in-channel edge connecting a blockchain node and a
blockchain channel shows that the node participates in the
channel. Vertices and edges can carry additional prop-
erties such as computer hardware architecture, network
bandwidth, blockchain node types, and consensus proto-
col conﬁgurations. Architects leverage vertices, edges, and
properties to capture all the design decisions deﬁned in the
blockchain network design space [11] and develop block-
chain network architectures. In this paper, we denote the
resulting property graphs representing blockchain network
architectures as BND models. They can be serialised as
JSON or XML documents for consumption by a software
system like NVAL.

The resulting BND models describe three perspectives of
blockchain network architectures simultaneously: organi-
sational, physical, and logical (Table 2c). The organisa-
tional structure of a blockchain network captures its organ-
isational context and requirements, describing how partic-
ipants collaborate and their authority level. The physical
structure describes the underlying computing infrastruc-
ture available for running a blockchain network, captur-
ing a network’s physical contraints. The organisational
and physical structures shape the design decisions cap-
tured in the logical structure, which describes a blockchain
network’s topology, the deployment of its nodes, and the
assignment of its nodes to participants.

Example: Let us demonstrate the meta-model with an
exemplary BND model of a two-channel blockchain net-
work in the context of the motivating example (Figure 3).
The blockchain network serves ﬁve participants within the
same lab, including a researcher (denoted as Lab 1) and
four robots (Robot 1 to Robot 4). These participants col-
laborate on a process (Provenance) that secures and up-
dates the historical records (provenance) of mission objec-
tives and corresponding data. The Lab 1 participant also
participate in another process called Data Registry with
other labs (not shown in the ﬁgure for brevity). The de-
tails regarding participants and processes are captured in
the organisational structure of a BND model, forming the
organisational context and requirements.

The blockchain network in Figure 3 operates on
a hardware infrastructure consisting of a workstation

6

Vertex Type

Properties

Description

Blockchain Node (BNode) Node ID, Node type (Full, Mining, Lightweight, Remote) A deployed and operational node in a blockchain network

Blockchain Channel

Channel ID, Consensus Protocol

A logical channel of a blockchain network consisting of multiple blockchain nodes maintaining
the same ledger

Process

Participant

Description

A business process or technical process that drives the deployment of a blockchain network

Description, Multiplicity (Individual or multiple users)

A process participant, which can be an individual or an organisation

Computing Node (Node)

Host name, hardware architecture, OS

A computer that runs a blockchain node

Computer Network (Net)

Net ID, network type, bandwidth

A wired or wireless network that connects computing nodes

(a) Vertices

Edge Type

From Vertices To Vertices Properties

Description

Participate-in-Process Participant

Control-BNode

Participant

In-Channel

Deploy-on-Node

In-Network

BNode

BNode

Node

Process

BNode

Channel

Node

Role, Authorisation Level

Representing a participant’s involvement, role, and authorisation level in a process

Representing the ownership and control of a participant over a blockchain node

Representing that a blockchain node works in a logical channel

Representing that a blockchain node is deployed on a computing node

Network

Network interface metadata (e.g., host address) Representing that a computer is attached to a wired or wireless network

Architectural Structure

Included Vertices

Included Edges

Description

(b) Edges

Organisational

Participants, Processes

Participate-in-Process

Nodes, Networks

In-Network

Physical

Logical

Describing relationships and power dynamics between participants, which act as con-
straints of a blockchain network architecture

Describing a targeted hardware infrastructure for deploying a blockchain network,
which presents constraints of a blockchain network architecture

BNodes, Channels

In-Channel, Control-BNode, Deploy-on-Node Describing a blockchain network’s topology and providing the necessary information

to deploy it

(c) Architectural structures

Figure 2: BND meta-model for modelling blockchain network architecture

The blockchain network described in Figure 3 contains
two channels. The ﬁrst channel, Intra-lab, serves the
Provenance process. The channel contains ﬁve blockchain
nodes (1-1 to 1-5) that are assigned to ﬁve participants
and deployed on ﬁve computers. The second channel,
Inter-lab, serves the Data Registry process. Its block-
chain nodes are distributed across all participating labs.
One of its nodes, 2-1, is assigned to Lab 1 participant and
deployed on the Workstation. Details regarding the type
of blockchain nodes and the conﬁguration of the block-
chain channels can be further speciﬁed in the properties of
relevant entities, which we omit from the ﬁgure for brevity
and clarity. The logical structure of a BND model captures
these design decisions.

Modelling Architecture with BND: Before design-
ing a blockchain network, architects must gather require-
ments regarding the organisational structure that a block-
chain network serves. They also need the details regard-
ing the underlying hardware infrastructure. Based on the
gathered information, architects ﬁll up a BND model’s
organisational and physical structures. Afterwards, ar-
chitects can capture their design decisions in the logical
structure as follows:

• Topological design decisions describe how a block-
chain network is segmented into channels and the
number of blockchain nodes per channel. Opera-
tors specify these decisions by (1) adding blockchain

Figure 3: An exemplary BND model of a two-channel blockchain
network running on a cluster of ﬁve computing nodes.

(Workstation) and four onboard computers of the robots
(Onboard 1 to Onboard 4). The workstation and onboard
computers connect via an Intra-lab Network such as a
local Wiﬁ network. The workstation also connects to other
labs’ workstations via an Inter-lab Network. The phys-
ical structure of a BND model captures details regarding
the hardware, forming the physical context and require-
ments.

7

Net:Intra-lab NetworkNode: Onboard 1Proc: DataRegistryParticipant: Lab 1Bnode:1-1Channel: Inter-labNet:Inter-lab NetworkNode: Onboard 2Node: Onboard 3Node: Onboard 4Node: WorkstationBnode:1-2Bnode:1-3Bnode:1-4Bnode:1-5Channel: Intra-labBnode:2-1Participant: Robot 1Participant: Robot 2Participant: Robot 3Participant: Robot 4Proc: ProvenanceLogical StructureOrganisationalStructurePhysical StructureParticipate-In-ProcessControl-BNodeIn-ChannelDeploy-on-NodeIn-NetworkIn-Channelnodes,
and (3) adding
In-Channel edges between nodes and their channels.

(2) adding channels,

• Organisational design decisions capture the assign-
ment of blockchain nodes to participants. The type of
the assigned blockchain node reﬂects a participant’s
authorisation level. Operators specify these decisions
by (1) adding Control-BNode edges between partic-
ipants and blockchain nodes and (2) specifying the
type of blockchain nodes by setting the NodeType
property of blockchain nodes.

• Consensus design decisions capture the type and con-
ﬁguration of the consensus protocol used by block-
chain channels in the network. Operators specify
these decisions by setting the ConsensusProtocol
property of channels.

• Deployment design decisions capture how blockchain
nodes are deployed on targeted hardware infrastruc-
ture. Operators specify these decisions by adding
Deploy-on-Node edges between blockchain nodes and
computing nodes.

Parsing Architecture with BND: BND enables
NVAL to process multi-channel blockchain networks in
a channel-by-channel fashion. Let us demonstrate how
NVAL parses the exemplary BND model presented in Fig-
ure 3 for deployment. The logical structure of the BND
model reveals to NVAL that it needs to deploy two block-
chain channels (Inter-lab and Intra-lab). Let us take
a closer look at the Intra-lab channel. By following
its In-Channel edges, NVAL can identify the blockchain
nodes that it needs to establish (BNode 1-1 to BNode
1-5). By following the Deploy-on-Node edges of the
blockchain nodes, NVAL learns where to deploy the block-
chain nodes (Workstation and Onboard 1 to Onboard
4). By inspecting the properties of the Intra-lab chan-
nel, NVAL learns the type of required blockchain plat-
form and conﬁgurations. By inspecting the properties of
the computing nodes, NVAL learns that it needs to de-
ploy blockchain clients on a powerful workstation running
an X64-based processor and multiple resource-constrained
onboard computers running ARM-v7 processors. The in-
formation regarding the required blockchain platform and
the hardware architecture form the requirements used by
NVAL to look for suitable automation programs. For
instance, assuming that the Intra-lab channel utilises
the Proof-of-Authority (PoA) variant of Ethereum, NVAL
must look for automation programs that can deploy and
conﬁgure PoA Ethereum clients on both X64-based and
ARMv7-based computers. A similar parsing and process-
ing can be performed for the other channel.

The ability to parse and comprehend blockchain net-
work architectures also facilitates new architecture valida-
tion capabilities. For instance, veriﬁers can be developed
to leverage heuristic or formal analyses to detect miscon-
ﬁgurations, such as deploying a resource-intensive mining
node on a resource-constrained onboard computer.

5. Composable Actions

NVAL deploys and evaluates blockchain networks by
reusing and combining existing automation programs, de-
noted as composable actions, according to the given block-
chain network architectures. NVAL acquires composable
actions via inner-source (codes from previous projects) or
open-source channels (codes from the community). This
section presents our proposed scope and architecture of
composable actions to facilitate their development and
reuse.

Action Scope: Balancing reusability and abstraction
was our goal when deﬁning the scope of composable ac-
tions. Based on our experience in developing and refactor-
ing automation scripts for blockchain networks, we pro-
posed to scope NVAL’s actions into three types corre-
sponding to three types of activities conducted by NVAL.
Table 1 presents the interface and description features of
three action types that NVAL leverages to deploy and eval-
uate blockchain networks. NVAL requires the automa-
tion programs contributed by operators via inner-source
or open-source channels to conform to these interfaces for
interoperability.

• Deployers encapsulate the automation logic to deploy
and conﬁgure one blockchain channel. They receive a
fragment of a BND model describing a channel as in-
put. NVAL distinguishes and chooses deployers based
on the type of blockchain platforms they support, the
types of hardware architecture and operating systems
they can work with, and whether they can work with
multiple types of hardware architecture within one
channel (e.g., X64-based and ARMv7-based hosts).

• Evaluators encapsulate the automation logic to mea-
sure speciﬁc evaluation metrics from one blockchain
channel. They receive a list of required metrics and a
BND fragment of the targeted blockchain channel as
inputs. NVAL distinguishes and chooses evaluators
based on the metrics they can measure and the types
of blockchain platforms they can work with.

• Veriﬁers encapsulate reusable veriﬁcations of incom-
ing requests, such as schema validation and consis-
tency checking. Veriﬁers are optional actions. We in-
troduced them to capture the potential analyses pro-
vided by BND models.

Action Architecture: How to ensure NVAL can un-
derstand and execute actions, regardless of their underly-
ing technology, whilst minimising the complexity and im-
plementation eﬀort facing action contributors? We address
these challenges by proposing a kernel-based microservice
architecture for NVAL’s actions. From NVAL’s perspec-
tive, every action is a self-contained black box accessibly
only via a predeﬁned service interface that conforms to
ones speciﬁed in Table 1, ensuring that NVAL can under-
stand and invoke actions. Every action is packaged and

8

Table 1: Interface and description features of NVAL’s actions

Action Type

Inputs

Outputs

Description Features

Deployer

BND fragments that describe a blockchain chan-
nel

An operational blockchain network channel

Supporting blockchain platform
Supporting types of hardware architecture and OS
Supporting mixed hardware architecture

Evaluator

A list of required metrics
BND fragments of the required channels

A dataset containing evaluation results

Supporting metrics
Supporting blockchain platform

Veriﬁer

A request (BND instance and a list of requested
metrics)

One of the following:
- No problem
- Recommendations
- Warnings
- Errors

Description of the veriﬁcation written in natural language

delivered as a software container that contains all neces-
sary libraries and tools, such as Ansible or Hyperledger
Caliper, allowing NVAL to host and operate actions with-
out managing their dependencies.

Developing actions as containerised services undoubt-
edly introduces additional complexity beyond the scope
and focus of contributors. We leverage a kernel-based ar-
chitecture to abstract the complexity and ensure the com-
pliance of the service implementation. Speciﬁcally, we di-
vide the codebase of composable actions into kernel space
and contributor space (Figure 5). The contributor space
contains automation scripts (e.g., Ansible playbooks) and
the necessary tools to execute the scripts (e.g., Ansible).
The kernel space handles service interface implementation
and operation. A bridging module connects kernel and
contributor spaces, translating NVAL’s service requests to
automation script calls. NVAL provides abstract bridg-
ing modules (Figure 5) that contributors can extend to
develop concrete bridging modules.

From a contributor’s perspective, the development pro-

cess of action is as follows:

1. Determining the type of action to develop based on

Table 1

2. Refactoring or developing automation programs ac-

cording to the deﬁned scope
3. Acquiring the kernel from NVAL
4. Developing a bridging module by subclassing a suit-
able abstract module (DeplCore, EvaluatorCore,
VerifierCore) and implement its abstract functions
(e.g., deployHandler(), teardownHandler()). At
runtime, NVAL calls these functions though the ser-
vice interface to reach the automation programs. By
implementing these functions, contributors control
how NVAL uses their automation programs.

5. Filling in the action metadata in the bridging module
6. Packaging the service interface, the bridging module,
the automation programs, and necessary utilities into
a container. The kernel can provide a template for
conducting this step.

Rationale and Counter-Example: The action
scopes are informed by our experiences in developing au-
tomation scripts for blockchain networks. Let us consider

the following a counter-example automation script we de-
veloped for the exemplary BND model above. The script
received a list of computing hosts as input. Each list
entry speciﬁes a blockchain node’s network address and
channel. The counter-example script instructs Ansible,
an automation tool, to (1) deploy one Inter-lab chan-
nel using the PoW Ethereum platform, (2) deploy multi-
ple Intra-lab channels with the PoA Ethereum platform,
and (3) benchmark all channels using Hyperledger Caliper.
From NVAL’s perspective, the described automation script
is an overly large action that simultaneously performs mul-
tiple tasks. We made the following observations:

1. Overly large action scopes hamper reuse: For in-
stance, we cannot reuse the counter-example script to
deploy and evaluate PoA Ethereum channels in a dif-
ferent blockchain network directly because its ability
to deploy PoA Ethereum channels is tightly coupled
with deploying PoW Ethereum channels and running
Caliper benchmarks.

2. Overly small scopes hamper abstraction: For instance,
if we narrow down actions to speciﬁc technical steps
such as building and deploying an Ethereum client,
operators would need an in-depth understanding of
In other words, we
Ethereum to use these actions.
lose the abstraction of implementation details, which
is NVAL’s primary goal.

3. Deploying and evaluating channels are atomic activi-
ties. From an operator’s perspective, deployment and
evaluation are either successful or failed.
In other
words, it does not matter to them whether the failure
happens at the ﬁrst compilation step or the last pro-
visioning step. Therefore, the scope of actions must
cover an entire deployment or evaluation step to pre-
serve their abstraction.

4. Channels divide the work on a multi-channel block-
chain network into independent units. For instance,
we can break the deployment and evaluation of a
three-channel blockchain network into three parts;
each deploys and evaluates one channel. The same
procedure can be used for all channels if they employ
similar blockchain technology and request the same
evaluation metrics.

5. Actions can be distinguished by what channels they

9

Figure 4: Architecture of a composable action for NVAL

can act on and how they do so. For instance, a de-
ployment action might be able to build and deploy
Ethereum nodes only on computers with an ARMv7
processor. This information helps NVAL match this
action with blockchain network architectures that fea-
ture Ethereum protocol and low-power computers
running ARMv7 chips.

The observations (1) to (3) show that deployment and
evaluation of individual channels are atomic activities
for handling heterogeneous multi-channel blockchain net-
works. Observation (4) shows that we need to reduce
action scopes to individual blockchain network channels
rather than an entire network to increase their reusability.
Finally, observation (5) shows us how to describe actions
to enable their reuse. The proposed action scopes in Table
1 were developed based on these ﬁve observations.

Composable Actions in Action Let us demonstrate
how the counter-example automation script can be refac-
tored into composable actions. Based on the scopes de-
ﬁned in Table 1, the script can be refactored into three
following actions:

• Deployer 1 specialises in PoW Ethereum. Assum-
ing that it only works with computers running X64-
based processors, we can denote this deployer as
Depl(P oWE th,X64,T rue), meaning it supports PoW
Ethereum, X64-based hosts and can work with infras-
tructure containing multiple host types.

• Deployer 2 specialises in PoA Ethereum.

As-
suming that
can deploy on both ARMv7
and X64 hosts, we can denote this deployer as
Depl(P oAE th,ARM v7∧X64,T rue).

it

• Evaluator 1 specialises in measuring performance
metrics
from
Ethereum channels using the Caliper benchmark
suite. We denote this evaluator as Eval(P erf,Eth).

latency and throughput

such as

NVAL can leverage these actions to handle the ex-
The

emplary BND model presented in Figure 3.

10

Inter-lab channel matches with the Deployer 1
(Depl(P oWE th,X64,T rue)) because the channel runs the
PoW Ethereum platform and is deployed on a workstation
running X64-based processors, thus requiring the capabil-
ities that Deployer 1 provides. The Intra-lab channel
matches with Deployer 2 (Depl(P oAE th,ARM v7∧X64,T rue)).
The evaluator can be applied to both channels. The exe-
cution plan for the exemplary BND model is as follows:

1. Depl(P oWE th,X64,T rue)(Inter − lab)
2. Depl(P oAE th,ARM v7∧X64,T rue)(Intra − lab)
3. Eval(P erf,Eth)(Inter − lab)
4. Eval(P erf,Eth)(Intra − lab)

6. Action Planning with State Space Search

Action planning denotes the process of ﬁnding a suitable
sequence of action calls to deploy and evaluate a requested
blockchain network archiecture.

Problem Formulation: We regard the action plan-
ning for a request as a search task on its implicit state-
space with the goal state being the successful deployment
and evaluation of a requested blockchain network. We for-
malise the state-space search problem for action planning
as follows.

Deﬁnition 6.1 (Request). A request (R) from an opera-
tor contains a blockchain network architecture for deploy-
ment and a list of metrics to measure from the deployed
network. A request consists of multiple n deployment and
m evaluation request components that can be tracked and
resolved separatedly: R = (D, E). A deployment request
component is an individual blockchain channel to deploy.
An evaluation request components is a list of metrics to
measure from a channel. The state of a request is denoted
as SR.

Deﬁnition 6.2 (Action). An action is a function that (1)
receives a request component, (2) carries out a correspond-
ing task, and (3) returns a new request state. NVAL has
three action types: veriﬁer (Eq. 2), deployers (Eq. 3), and

NVALSoftware ContainerImplemented by the contributorKernel (Provided by NVAL)Operating SystemLibraries and DependenciesDependencies of automation logicService InterfaceBridgingModuleAutomation LogicAbstract ModuleConcrete ModuleRequestResponseFigure 5: Abstract classes for implementing a bridging module in a NVAL action

evaluators (Eq. 4). The set of actions that NVAL can ac-
cess to plan and resolve a request is denoted as an action
pool (A) (Eq. 1).

deployed and evaluated. The remaining n + m elements
describe the status of individual request components, in-
cluding failed (-1), in-progress (0), and successful (1). The
initial state of every request is an all-zero tuple. Its goal
state is an all-one tuple.

A = {V er, Depl, Eval}
V er = {ver|ver : R (cid:55)→ B}
Depl = {depl|depl : D (cid:55)→ SR}
Eval = {eval|eval : E (cid:55)→ SR}

(1)

(2)

(3)

(4)

Deﬁnition 6.3 (Action Planning). The action planning
problem can be formalised as follows: given a request
R, generate an action sequence AR = ((a, input)|a ∈
A, input ∈ R) such that the request’s state SR becomes
a goal state after applying AR.

Approach: We apply state-space search to solve the
action planning problem. The main idea is employing
a search algorithm (e.g., depth-ﬁrst search, breadth-ﬁrst
search) to systematically explore a request’s state space to
ﬁnd a goal state. The path taken by the search algorithms
to reach a goal state becomes the execution plan. The
traversal of a request’s state space requires a state space
model and a set of state transition functions that we deﬁne
below.

Request’s State Model: Following [39], we model a re-
quest’s state space as a tree whose nodes represent the
request’s states and edges represent action calls (a, input).
A request’s state SR is a tuple with 3 + n + m elements
(Eq. 5). The ﬁrst three elements (v, d, e) describe a re-
quest’s overall status, showing whether it has been veriﬁed,

SR = (v, d, e, req)
req ∈ {−1, 0, 1}n+m

v ∈ B

d, e ∈ {−1, 0, 1}

(5)

(6)

(7)

(8)

State Transition Functions: The following state transi-
tion functions control how a search algorithm traverse a
request’s state space.

ACTIONS(s) determines the possible out-going edges for
each state. Each out-going edge represents an action call
(a, input). The function returns action calls according to
the following rules:

• If v is 0, return all veriﬁers (V er)

• If d is 0, return all deployers (Depl) with deploy-
ment request components as their input. For instance,
if a given blockchain network architecture contains
two channels (ch1, ch2), and NVAL has two deploy-
ers (PoW(), PoA()), then ACTION(s) returns four ac-
tions: PoW(ch1), PoW(ch2), PoA(ch1), PoA(ch2).

• If d is 1 and e is 0, return all evaluators (Eval) with
evaluation request components as their input, simi-
larly to the above example with deployers.

11

RESULT(s, a) determines the destination of an out-going
edge. In other words, it returns a new state that captures
the results of applying an action a to an initial state s.
The results of this function are according to the following
rules:

• If a ∈ V er, the veriﬁcation state v is set to 1 to indi-

cate that the veriﬁcation has been planned.

• If a ∈ Depl, the new state depends on whether the
deployer in a can handle a given request component.
This assessment is done by matching the deployer’s
descriptive features with the channel’s characteristics
(e.g., matching the type of supported blockchain plat-
forms with the type of requested blockchain platform).
If a deployer can handle a given deployment request
component, then the request component’s status in
S p
R is set to 1, indicating that deployment has been
planned. If all deployment request components have
been planned, the overall deployment state d is up-
dated to 1.

• If a ∈ Eval, the new state depends on whether the
evaluator in a can handle a given evaluation request
component.
If it can, then the status of the rele-
vant request component is set to 1, indicating that
evaluation has been planned. If all evaluation request
components have been planned, the overall evaluation
state e would also be updated to 1.

STEP-COST(s, a) returns the cost of applying an action a
on a state s. This cost can represent an action’s resource
consumption (CPU time, memory, network bandwidth),
time delay, reliability, or ﬁnancial costs. For simplicity,
we set the STEP-COST uniformly to be one, which means
the total cost of an execution plan is the number of actions
taken. Future works could explore other STEP-COST to
improve the eﬃciency of the state space search.

IS-GOAL(s) determines whether a given state s is the goal
state. It returns true if all values of a state tuple S p
R is 1.
If the state space is exhausted before IS-GOAL(s) returns
true, the request is deemed unsatisﬁable.

Figure 6a depicts how a breadth-ﬁrst search algorithm
leverages the state transition functions to traverse the
state space to search for a goal state. The node object
represents a node in the state tree, which contains a state
vector (s) and a set of actions leading to it. The POP()
removes and returns the last item from an array.

State-space Search in Action: We describe an ex-
ample that shows how NVAL plans to deploy and evaluate
the exemplary BND model described in Section 4 (Figure
3). Recall that the exemplary BND model contains an
inter-lab channel and an intra-lab channel, which we de-
note as ch1 and ch2. The ﬁrst channel (ch1) uses a PoW
Ethereum variant to connect workstations of the collab-
orating labs (X64-based computers). The other channel
(ch2) is an intra-lab channel that uses a PoA Ethereum

variant to connect robots (ARMv7-based computers) and
workstations (X64-based computers) within a lab. Sup-
pose that an operator wants performance metrics (latency
and throughput) from ch1 and ch2 and resource consump-
In total, the described request
tion metrics from ch2.
can be broken down into two deployment request com-
ponents and three evaluation request components. Figure
6 presents the request components and the action pool
available for NVAL to deploy and evaluate the exemplary
request.

The state tuple of the sample request consists of eight
components (three general states (v, d, e), two deploy-
ment requests, and three evaluation requests). The re-
quest is initially assigned with an all-zero state tuple
(0, 0, 0, 0, 0, 0, 0, 0). The breadth-ﬁrst search algorithm
presented in Figure 6a was employed to traverse the state
space. Let’s consider the expansion of the initial state as
an example.

1. IS-GOAL(s) is applied on the initial state. It returns

false, allowing the search to continue.

2. ACTIONS(s) is applied on the initial state to identify
all available actions. Because v is 0, all veriﬁers are
returned as possible actions.

3. RESULT(s, a) is applied on the starting state
It returns a new state
reﬂecting that veriﬁcation has

and the veriﬁer action.
(1, 0, 0, 0, 0, 0, 0, 0),
been planned.

4. STEP-COST(s, a) assigns the cost of the veriﬁcation
to be 1, indicating that one action has been planned.

The traversal continues until reaching a goal state. All
actions leading to that state becomes the experiment plan
for the given request. Figure 6 depicts the state tree and
the search process.

7. Evaluation

This section presents a case study that aims to evaluate
and demonstrate the feasibility of NVAL in a targeted us-
age scenario. We validated the framework’s feasibility in
two aspects. Firstly, we demonstrated that NVAL could
combine a small set of composable actions to deploy and
evaluate a larger set of complex blockchain network archi-
tectures. Secondly, we demonstrated that NVAL does not
incur signiﬁcant overheads to the deployment and evalu-
ation process. We formulated these aspects of feasibility
into the following research questions:

• RQ1: How eﬀective is NVAL at orchestrating actions
for deploying and evaluating diverse blockchain net-
work architectures?

• RQ2: What is the degree to which NVAL can reuse

actions across requests?

• RQ3: What is the processing time overheads incurred

by NVAL?

12

Figure 6: Action planning algorithm and an exemplary planning run

We chose the case study method to evaluate and demon-
strate NVAL’s feasibility because it is a powerful and ﬂex-
ible research method to investigate a contemporary phe-
nomenon in its context [40, 41]. The studied phenomenon
is the feasibility of NVAL. The context in which we study
NVAL’s feasibility is an architecture development project
that employs a proof-of-concept system of NVAL to exper-
iment with various blockchain network architectures. For
clarity, we use the term case to denote the architecture
development project (context) and the term case study or
study to denote the evaluation of NVAL via analysing the
case. We collected data from the experiment results and
NVAL’s logs by the end of the case as empirical evidence
to answer the research questions. The following sections
elaborate on the case, the methodology, and the results.

7.1. Case Description

Context: Recall that in the motivating scenario, mul-
tiple collaborating research labs wish to leverage a private
blockchain to interconnect their robotic testbeds to form

a joint experimentation platform. The labs must estab-
lish a private blockchain network that bridges various or-
ganisations’ clouds, workstations, and robots to leverage
a private blockchain. Such a network has various poten-
tial architectures [2], which oﬀer diﬀerent trade-oﬀs be-
tween quality attributes such as performance (transaction
latency and throughput), resource consumption, availabil-
ity, and security.

The case of our study is an architecture development
project that emerged from this context. It aimed to iden-
tify an optimal blockchain network architecture for the
joint experimentation platform by empirically evaluating
potential architectures using a surrogate testbed infras-
tructure. The testbed resembles a scaled version of the
joint experimentation platform. The project includes 13
experiments, each of which involves the deployment and
benchmarking of a potential blockchain network architec-
ture. The experiments were repeated ﬁve times, bringing
the total number of deployed blockchain deployed chan-
nels to 150, constituting 65 blockchain networks. Most
of the deployed blockchain channels produce two evalu-

13

(a) Planning Algorithm based on Breath-first Search(b) A request’s state space during planningRequest ComponentsAction Poolation datasets (performance and resource consumption),
bringing the total number of datasets to 295. Due to the
massive workload, the authors were involved in the project
to employ NVAL to support the experiments.

Surrogate Testbed Infrastructure: The surrogate
testbed infrastructure is a scaled version of the joint ex-
perimentation platform. The testbed is deployed and op-
erated by the authors to conduct experiments in a con-
trolled environment. Figure 7 presents the testbed, which
contains two device clusters representing separate robotic
testbeds from two research labs. Each cluster contains
four edge devices, which are resource-constrained comput-
ers (Raspberry Pi 3B+ and Raspberry Pi 4) represent-
ing robots’ onboard controllers. Each cluster contains a
powerful workstation acting as a cluster head or base sta-
tion. The testbed also includes a workstation representing
a remote cloud infrastructure that the research labs in the
motivating scenario might utilise for data storage and pro-
cessing. Upon this testbed infrastructure, experiments on
blockchain network architectures were conducted.

Experimented Architectures: Twelve potential
blockchain network architectures were deployed and eval-
uated by NVAL. Table 2 presents a detailed breakdown
of these architectures in terms of their constituting block-
chain channels, where channels’ full nodes are deployed
(coverage), where channels’ mining nodes locate, and the
type of blockchain consensus protocol that channels use.
The experimented architectures are complex and heteroge-
neous, featuring both single-channel (D4 to D6) and multi-
channel topology (D1 to D3 and D7 to D12) and deploying
blockchain nodes on both X64-based computers (base sta-
tion) and ARMv7-based computers (edge agents).

Table 2: Blockchain network architectures deployed and evaluated
by NVAL in the case study

ﬁer to deploy and evaluate the above blockchain network
architectures. Table 3 presents the scopes of these ac-
tions. The authors constructed all the composable ac-
tions by refactoring existing automation programs pre-
viously developed for an IT automation tool called An-
sible. DeplPoA was the ﬁrst developed deployer, resem-
bling the counter-example described in Section 5. The
deployer was reﬁned and extended to support more block-
chain platforms (Ethereum Proof-of-Work) and hardware
architecture (ARMv7), creating DeplPoA x64 ARM and
DeplPoW x64 ARM. EvalPerformanceEthereum evaluator
is capable of conducting performance benchmarks using
the Hyperledger Caliper suite and measuring resource con-
sumption of the underlying hardware using Prometheus. It
supports both PoA and PoW variants of Ethereum. The
Verifier action is capable of validating incoming deploy-
ment requests against a schema to detect syntactical is-
sues.

The action pool of NVAL also contains DeplBaseline
and EvalBaseline, which are special actions for determin-
ing the baseline resource consumption level of the testbed
infrastructure. The baseline deployer deploys a unique
blockchain channel called “baseline”, which does not con-
tain any active blockchain node. The baseline evaluator
It measures the
only works with “baseline” channels.
resource consumption metrics of nodes underlying these
channels over a long period.

Table 3: Action Pool

Deployer

Supporting Platform

Supporting Arch

DeplPoA
DeplPoA x64 ARM
DeplPoW x64 ARM
DeplBaseline

X64
Ethereum PoA (Clique)
Ethereum PoA (Clique)
Mixed X64 & ARM
Ethereum PoW (Ethash) Mixed X64 & ARM
Mixed X64 & ARM
Baseline

Evaluators

Arch ID Channel ID Coverage

Miner Location

Consensus

Supporting Platform

Supporting Metrics

Ch1, Ch2

Within edge clusters

Edge devices

Ch1, Ch2

Within edge clusters

Fog nodes

Ch1, Ch2

Within edge clusters

Fog nodes

Across device clusters Fog nodes

Across device clusters Fog nodes

Ethereum PoA

Ethereum PoA

Ethereum PoW

Ethereum PoA

Ethereum PoW

EvalPerformanceEthereum Ethereum
EvalBaseline

Baseline

Resource Consumption & Performance
Resource Consumption

Veriﬁers

Approach

Technique

Veriﬁer

Structural veriﬁcation

Schema validation

D1

D2

D3

D4

D5

D6

D7

D8

D9

D10

D11

D12

Ch1

Ch1

Ch1

Ch1, Ch2
Ch3

Ch1, Ch2
Ch3

Ch1, Ch2
Ch3

Ch1, Ch2
Ch3

Ch1, Ch2
Ch3
Ch4

Ch1, Ch2
Ch3
Ch4

Across device clusters Fog nodes & Edge devices Ethereum PoA

Within edge clusters
Fog nodes
Across device clusters Fog nodes

Within edge clusters
Fog nodes
Across device clusters Fog nodes

Cloud
Within edge clusters
Across device clusters Cloud

Within edge clusters
Cloud
Across device clusters Cloud

Within edge clusters
Fog node
Across device clusters Fog node
Across device clusters Cloud

Within edge clusters
Fog node
Across device clusters Fog node
Across device clusters Cloud

Ethereum PoA
Ethereum PoA

Ethereum PoW
Ethereum PoW

Ethereum PoA
Ethereum PoA

Ethereum PoW
Ethereum PoW

Ethereum PoA
Ethereum PoA
Ethereum PoA

Ethereum PoW
Ethereum PoW
Ethereum PoA

NVAL’s Action Pool: The proof-of-concept system
contained four deployers, two evaluators, and one veri-

14

7.2. Proof-of-Concept Implementation and Deployment

We developed and deployed a NVAL proof-of-concept
system to conduct the case study. Figure 7 depicts the
deployment structure of a NVAL instance:

• NVAL Server hosts the framework’s software compo-
nents. It exposes functionality as Web services via a
RESTful API. We used the Open API Speciﬁcation
version 3.0 to model the API and employed the Swag-
ger Codegen utility to generate the service interface
automatically from the speciﬁcation. Javascript and
NodeJS runtime environment were used to implement
NVAL’s components.

Figure 7: Deployment Structure of NVAL Proof-of-Concept System and the Surrogate Testbed Infrastructure

• Operator’s Computer hosts the client-facing software
for creating BND models, submitting requests to
NVAL and monitoring the experiments (i.e., deploy-
ment and evaluation of a blockchain network). We
developed the web application with ReactJS and
react-digraph3 libraries.

• Target hardware infrastructures consist of computers
and networks used for deploying and evaluating block-
chain networks (Figure 7). NVAL server can reach
these computers via SSH.

Both the NVAL server and the client-facing software are
deployed on a mobile workstation equipped with a quad-
core processor and 16GB of memory.

7.3. Evaluation Metrics

We collected data to answer the research questions from
experiment results and log ﬁles generated by NVAL’s
proof-of-concept system. We calculate the following met-
rics based on the data to quantify the eﬀectiveness and
eﬃciency of NVAL.

Execution Success Rate: Success rate is the ratio be-
tween successful experiment runs and the total number of
experiments. An experiment is successful if NVAL applies
correct actions in a proper order to deploy a blockchain
network correctly and retrieve all the requested perfor-
mance metrics. The success rate is determined from the
experiment results and used to answer RQ1. A high suc-
cess rate indicates that NVAL is eﬀective at deploying and
evaluating blockchain networks.

Per Action Utilisation Rate: The utilisation rate of
an action quantiﬁes the degree to which NVAL can reuse
it across multiple requests. This metric is used to answer
RQ2. We calculated the utilisation rate from the experi-
ment results in two following ways:

3https://github.com/uber/react-digraph

15

Figure 8: Snippet of a log ﬁle generated by NVAL framework

• Ratio between the number of experiments in which
an action participates and the total number of exper-
iments

• Ratio between the number of times NVAL invokes an
action, and the total number of action calls NVAL
performs across the experiments

Processing Time Overheads: This metric quantiﬁes
the amount of experiment time spent on NVAL-speciﬁc ac-
tivities such as creating execution plans and invoking ac-
tions. We calculated this metric by analysing the NVAL’s
log ﬁles that show us starting and ending times of every
activity conducted within NVAL (Figure 8). This metric
is used to answer RQ3. Lower overheads indicate a higher
level of eﬃciency.

NVAL ServerOperator’s ComputerNodeJS RuntimeBrowserBND EditorNVAL DashboardPrometheusServiceAPINVALOrchestratorPlannerModule MngExp MngInfra MngNVAL CoreEvaluatorsVerifiersDeployersEvaluatorsVerifiersDeployersNVAL ModulesHTTPTCP/IPCloudFogEdge DevicesRaspberry Pi 3B+Raspberry Pi 4Mini PCMini PCClusterClusterPrivate CloudTCP/IPSurrogateTestbedInfrastructure7.4. Results

RQ1 - The Eﬀectiveness of NVAL: NVAL frame-
work successfully planned and conducted ﬁve rounds of 13
experiments (twelve architecture and one baseline), lead-
ing to the deployment and evaluation of 150 blockchain
channels, constituting 65 blockchain networks. All eval-
uation datasets were usable and free of anomalies. We
also did not observe any false-negative from the planning
mechanism as the action pool was adequate to satisfy all
the given requests. Given these observations, we reached
the following conclusion for RQ1:

Experiment overhead is caused by activities related to
recording, planning, and orchestrating the deployment and
evaluation. This overhead incurs whenever an experiment
is conducted. We found the experiment overhead to be
around a tenth of a second (95.5 ms), which is minuscule
compared to the time required to deploy and benchmark a
blockchain network, ranging from 7 to 14 minutes. Based
on these ﬁndings, we reached the following conclusion for
RQ3:

RQ3: NVAL’s overheads are negligible compared to the
time required to deploy and evaluate blockchain networks.

RQ1: Given an adequate action pool, NVAL plan and
conduct experiments accurately for 100% of the given ex-
periment requests.

8. Discussions

RQ2 - Utilisation Rate of Composable Actions:
NVAL’s action pool served 365 invocations across ﬁve
rounds of 13 experiments. Table 9a presents the utilisa-
tion rate of each action across the experiments. Table 9b
breaks down the utilisation of each action, showing the
number of times it was called across the experiments.

The data shows that actions with broad functional
scopes can support (i.e., being utilised by) more exper-
iments. For instance, 92% of the experiments utilised
EvalPerformanceEthereum because it can measure both
performance and resource consumption, and it supports
both protocol variants of Ethereum. Critical actions that
are universally applicable, such as Verifier have al-
most perfect reusability with NVAL. On the other hand,
actions with low demand and limited scopes, such as
DeplBaseline and EvalBaseline, had a low utilisation
rate.

An interesting observation from the data is that multi-
ple actions with limited scopes can be combined to cover as
many or even more experiments than larger actions. For
instance, the DeplPoA deployer supports only 23% of the
experiments by itself. However, the combination of three
deployers working together was able to deploy all 12 block-
chain network architectures. This observation suggested
the feasibility of NVAL’s automation approach of reusing
and combining existing automation programs to support
future requests. We reached the following conclusion for
RQ2:

RQ2: NVAL can reuse an action pool to deploy and eval-
uate new blockchain networks. It can orchestrate a small
set of actions to serve a substantially larger set of requests.

RQ3 - Processing Time Overheads: Figure 10
presents the durations of various activities conducted by
NVAL. The time spent on all activities beside VERIFY,
DEPLOY, and EVALUATION are considered overhead. The
overhead can be classiﬁed into bootstrap overhead and ex-
periment overhead. Bootstrap overhead is caused by the
LOAD-MODULES activity that is performed once when NVAL
boots. We found bootstrap overhead to be around half a
second (441 ms).

8.1. Beneﬁts and Usage Scenario

The NVAL framework provides practitioners and re-
searchers with the ability to rapidly deploy and evalu-
ate heterogeneous multi-channel blockchain networks. By
leveraging BND meta-model, composable actions, and
state-space search, the framework can deploy and evalu-
ate blockchain network directly based on their architecture
whilst abstracting procedural details and low-level conﬁg-
urations from users. This architecture-driven automation
approach beneﬁts practitioners and researchers by allow-
ing them to focus on desiging blockchain network archi-
tecture, a valuable and hard-to-automate activity. Au-
tomation of implementation and conﬁguration steps also
prevent errors such as missing steps and misconﬁgurations,
reducing time and eﬀort in blockchain network deployment
and evaluation. Another beneﬁt of NVAL is the captur-
ing and sharing of procedural knowledge regarding deploy-
ment and evaluation activities. By capturing this knowl-
edge explicitly as software artefacts (composable actions)
rather than documents, practitioners and researchers can
version control, test, reﬁne, and employ the knowledge
rapidly across multiple organisations. Finally, by enabling
practitioners to rapidly deploy and evaluate their block-
chain network architectures, NVAL can shorten the feed-
back loop and enable practitioners to conduct more design
iterations, which ultimately lead to better architectures
[25].

Unlike existing blockchain automation framework and
services, NVAL oﬀers practitioners complete control and
transparency over the framework’s capability. NVAL is
designed such that it can be deployed and operated by
individual practitioners on consumer hardware, as demon-
strated in the case study. These practitioners maintain a
complete control over the capability of their NVAL ins-
tances as they can choose the actions making up the ac-
tion pool of their instances. The kernel-based approach
employed in these composable actions facilitate the devel-
opment and sharing of new NVAL’s capabilities, without
relying on permission or approval from any central author-
ity such as service providers or project maintainers. These
mechanisms together enable NVAL to keep up with the

16

Number of utilising experiments Utilisation rate

DeplBaseline
EvalBaseline
DeplPoA
DeplPoW X64 ARM
DeplPoA X64 ARM
EvalPerformanceEthereum
Veriﬁer

1
1
3
5
5
12
13

8%
8%
23%
38%
38%
92%
100%

(a) Utilisation of actions in terms of experiment participation

Baseline D4 D6 D5 D3 D2 D1 D10 D7 D9 D8 D11 D12 Grand Total

DeplBaseline
EvalBaseline
DeplPoA
DeplPoA X64 ARM
DeplPoW X64 ARM
Veriﬁer
EvalPerformanceEthereum

Grand Total

1
1

1

3

1

1
1

3

1

1
1

3

1
1
1

3

2
1
2

5

2

1
2

5

2

1
2

5

3
1
3

7

3

1
3

7

3

1
3

7

3
1
3

7

2
2

1
4

9

4
1
4

9

1
1
8
8
13
13
29

73

The presented invocation counts are from one experiment round. Five rounds were conducted.

(b) Utilisation rate of actions in terms of total invocations

Figure 9: Utilisation level of actions in the case

ever changing landscape of blockchain technology, increas-
ing its transparency and longevity.

8.2. NVAL and Beyond

The case study has shown NVAL’s eﬀectiveness in
reusing and composing a small pool of automation pro-
grams to deploy and evaluate diverse and complex block-
chain network architectures. However, our approach and
the current implementation still have some drawbacks.
This section analyses these drawbacks and presents some
potential solutions, constituting future research.

Firstly, because NVAL reuses existing automation pro-
grams to deploy and evaluate blockchain networks, its ca-
pability is limited by the breadth of actions it can ac-
cess. Therefore, the prime challenge of NVAL is ensuring
a steady supply of composable actions for both existing
and emerging blockchain technologies. The interfaces and
the kernel-based architecture proposed in Section 5 lay a
foundation for practitioners to capture and share their pro-
cedural knowledge as composable actions. Future research
could focus on the automated transformation of the exist-
ing automation scripts and natural language instructions
into composable actions. As of February 2022, we found
52 open-source repositories on automated blockchain net-
work deployment with Ansible, 67 repositories with Ter-
raform, and 35 repositories with other scripting languages
on GitHub. The oﬃcial documentation of many block-
chain implementations also provide instructions for de-

ploying private networks4. These automation scripts and
tutorials represent raw materials for NVAL’s actions.

Secondly, the current version of NVAL does not feature
extensive veriﬁcations of the contributed actions beyond
manual inspections by practitioners. The rationale of this
design is the assumption that actions primarily come from
trusted inner-sources, and the community veriﬁes open-
source actions before they reach an end-user. This model
might not scale when NVAL’s actions proliferate and in-
creasingly become targets of malicious actors who want to
leverage them as an attack vector to infrastructures. Fu-
ture research could develop a resilient and decentralised
registry for discovering and reporting malicious actions.
The STEP-COST() function could leverage the ratings from
this registry to adjust the planning procedure.

Thirdly, the current version of NVAL only employs Uni-
code strings and a substring detection mechanism to de-
scribe and match actions with architectural speciﬁcations
written in BND. For instance, if a blockchain channel is de-
ployed on X64-based computers and uses Ethereum PoW
blockchain protocol, NVAL would match the channel with
any action containing X64 and PoW in its meta-data. The
case study demonstrated that the simple approach is ef-
fective in matching channels with actions based on their
functionality. However, substring detection might not be
adequate for sophisticated action matching that takes into

4https://geth.ethereum.org/docs/interface/

private-network

17

Avg. Duration (milisec.) Max Duration (milisec.)

Std. Dev (milisec.)

STORE-EXP-RECORD
VERIFY
ORCHESTRATION-OVERHEADS
CREATE-EXP-RECORD
PLANNING-OVERHEADS
LOAD-MODULES
DEPLOY
EVALUATION

0.48
2.49
5.66
42
47.37
441
40377
440864

3
18
28
78
85
761
164084
791532

0.62
2.94
4.99
9.23
19.38
80.68
25187.3
169850.88

(a) Durations of activities carried out by NVAL

ACTUAL-DEPLOYMENT-EVALUATION
TOTAL-OVERHEADS

436675
95.5 (0.022%)

861352
176

168265.33
29.9

Avg. Duration (milisec.) Max Duration (milisec.)

Std. Dev. (milisec.)

(b) Total overheads of NVAL against the actual runtime

Figure 10: Durations of NVAL activities and the framework’s overheads.

consideration non-functional attributes of actions such as
performance, reliability, and security. Future research
could explore sematic descriptions and matching mech-
anisms. For instance, ontologies could replace the Uni-
code string to extend the description of actions to cover
non-functional requirements. Ontology-based query can
replace substring detection in matching channels with ac-
tions.

Finally, NVAL currently does not automatically feed the
execution phase’s output to the planning phase. Practi-
tioners must inspect the logs manually when a deployment
fails and determine whether the failure is due to an ex-
ception or an action’s failure. If they detect that a com-
posable action is the root cause, they need to remove it
from the pool manually. Future research could explore
techniques from self-adaptive software systems, such as
MAPE-K feedback loops [42] to enable NVAL to observe
and update its action pool automatically.

8.3. Threats to Validity
8.3.1. Construct validity

Construct validity concerns whether our case study de-
sign successfully assesses NVAL’s eﬀectiveness and eﬃ-
ciency in real-world usage. We mitigated this threat by
following an established guideline [41], which requires that
case selection and data collection follow research objec-
tives.

The selected case supports our research objectives be-
cause (1) it is a real-world use case of NVAL, (2) it requires
the rapid deployment and evaluation of many blockchain
networks, and (3) these blockchain networks have diverse
and complex multi-channel architectures.

The data collection process was also driven by the objec-
tives of assessing NVAL’s eﬀectiveness and eﬃciency. We
chose success and failure rates to quantify NVAL’s eﬀec-
tiveness because these metrics reﬂect the framework’s abil-
ity to correctly use an existing action pool to deploy and

evaluate blockchain networks. We chose time overheads to
quantify NVAL’s eﬃciency because time is the most tan-
gible and signiﬁcant resource that NVAL consumes, given
that it is not computing-intensive.

8.3.2. External validity

External validity concerns whether the eﬀectiveness and
eﬃciency that NVAL shows in the case study can be gener-
alized. Whilst the case study method does not aim to pro-
vide statistically signiﬁcant conclusions [41], we attempted
to broaden the generalization of our results by choosing
a case that features diverse blockchain network architec-
tures extracted from the literature. The variety of net-
work topology and the inclusion of edge devices and fog
nodes expand our generalization scope beyond enterprise
blockchain use cases, covering the emerging use cases in
cyber-physical systems and edge computing.

8.3.3. Reliability

Reliability concerns whether case study results depends
on the researchers carrying out the study. We mitigated
threats to reliability by the following strategies. Firstly,
we avoided subjective data such as NVAL’s usability and
focused on objective data gathered from the source code
and runtime logs. Secondly, we only employed commod-
ity hardware for NVAL and the experiment infrastructure
to prevent skewing the eﬃciency results due to exclusive,
high-performing computers.

9. Related Work

This paper addresses the problem of automating block-
chain network deployment and evaluation, which con-
tributes to the Blockchain Oriented Software Engineering
(BOSE) research [43, 44, 45] and aligns with three re-
search areas: blockchain network architecture, blockchain
network deployment, and evaluation.

18

Table 4: Comparison between NVAL and the existing automation frameworks

Automation Framework Description

Technology

Input

Support Het-
erogeneous
Blockchain
Networks

Support Eval-
uation

Supported Blockchain Im-
plementations

Supported In-
frastructures

End-user Ex-
tensibility

NodeJS

Business network models (as-
sets, participants, identities)

HL Fabric

Cloud

HL Composer

PlaTIBART (Walker et
al., 2017)

Malik et al., 2019

Utility for deploying business
abstraction such as assets over
an existing HL Fabric network.
Depricated in 08/2021.
A platform for
deploying
Ethereum clients wrapped
by software agents that han-
dle monitoring and oﬀ-chain
communication.
An automation script for de-
ploying and conﬁguring an HL
Sawtooth client on a computer.

Python + SSH

Shell script

uBaaS (Lu et al., 2019)

Deployment-as-a-Service
for
private and consortium block-
chain networks

Infrastructure-as-
Code

Domain-speciﬁc
description
of Ethereum network con-
ﬁgurations and placement of
Ethereum nodes

Practitioners manually place
the script on relevant comput-
ers and specify node type ot the
script.
Network-speciﬁc conﬁgurations
(e.g., PoW diﬃculty level) and
IP address for each blockchain
node.
Unspeciﬁed

Yes

Unspeciﬁed

Python + Ansible

NutBaaS (Zheng et al.,
2019)
MixBytes Tank

MADT

HL Bevel

NVAL

One-click network deployment
based on user-deﬁned proﬁles
A benchmark suite that can de-
ploy blockchain nodes on pri-
vate clouds in addition to run-
ning benchmarks
A large-scale IP network sim-
ulator that supports deploy-
ment of distributed applica-
tions (blockchain networks)
Utility for deploying container-
ised blockchain network on any
Kubernetes cluster

Architecture-driven,
community-supported
framework for automat-
ing
network
deployment and evaluation

blockchain

NodeJS + Any
for
technology
automation
pro-
grams

Python

Simulated network conﬁgura-
tion

Ansible + Helm +
Kubernetes

low-level

and
Mostly
technology-speciﬁc
conﬁg-
urations (consensus type, port,
network address, etc.)

high-
Platform-agnostic,
level architecture speciﬁ-
cations

Go-Ethereum

Any

HL Sawtooth

Any

Ethereum, HL Fabric

Cloud

Ethereum, HL Fabric, File-
coin
Polkadot, Haya

Cloud

Cloud

Any

Corda, HL Fabric, HL Indy,
Quorum

Cloud

Yes

Yes

Yes

Yes

Any (Prototype support
Ethereum with Ethash
and Clique)

Any

Yes

9.1. Blockchain Network Deployment

Automated blockchain network deployment has been in-
vestigated by both academia [30, 27, 26, 19, 46] and indus-
try [31, 32, 33, 47] to abstract the time-consuming [27],
and error-prone deployment process [26], allowing prac-
titioners to focus on application development instead of
learning networks and protocols [19]. Automation has also
been sought to make blockchain network deployment re-
peatable to support regression tests [30] and continuous
delivery [46].

Hyperledger Composer [31] is amongst the ﬁrst tools
that recognise and address the complexity of establishing
a private blockchain. It helps practitioners implement or-
ganisational design decisions by providing them with mod-
els and tools to deploy business abstractions such as assets
and participants on an existing Hyperledger Fabric net-
work. The Composer was deprecated in 2021.

The automation tools released after Composer have
shifted their focus to blockchain networks’
logical and
physical design decisions. Many of these tools feature
some form of domain-speciﬁc languages to capture the
topology and conﬁgurations of the requested blockchain
networks. The PlaTIBART platform [30] is among the
ﬁrst to tackle blockchain network deployment, focusing on
Ethereum. It proposes a domain-speciﬁc language to de-
scribe Ethereum’s conﬁgurations, such as network ID and
mining diﬃculty level. A Python-based network manager
uses the conﬁguration ﬁles to deploy Ethereum networks
for-
on connected computers. Hyperledger Bevel
merly known as the Blockchain Automation Framework,
is a state-of-the-art tool for rapidly deploying production-

[32],

ready blockchain networks, supporting Fabric, Corda,
Indy, and Quorum blockchain protocols.
It uses An-
sible, Helm, and Kubernetes to rapidly provision con-
tainerised blockchain networks on any Kubernetes cluster.
Bevel’s inputs are low-level and technology-speciﬁc conﬁg-
urations such as consensus types, network addresses and
ports. Gorski et al. [46] proposed an approach similar to
Bevel, but relying on UML deployment models rather than
domain-speciﬁc models as inputs. Malik et al.
[27] by-
passed blockchain network conﬁguration ﬁles by proposing
a shell script that practitioners manually place on targeted
computers and invoke to deploy blockchain nodes. Alter-
[48] proposed an algorithm automate
natively, Li et al.
the design and deployment of blockchain network based
on the characteristics of sensor data and the underlying
edge computing network.

Many Blockchain-as-a-Service (BaaS) platforms such as
uBaaS [26], NutBaaS [19], RBaaS [49], AWS Managed
Blockchain, Azure BaaS, and IBM Blockchain Platform
also provide deployment automation as a prominent fea-
ture. They generally provide a “one-click deployment”
utility for spawning a blockchain network across cloud-
based virtual machines. This deployment utility is gen-
erally vendor-locked in terms of the supported blockchain
technologies and computing nodes [26, 49]. Few oﬀer any
form of extensibility besides promised ﬁrst-party exten-
sions. A recent study on DevOps practices for blockchain-
based software engineering found that while BaaS usage
is becoming more common, vendor-speciﬁc limitations in
terms of the supported blockchain platforms and hardware
limit their adoption in blockchain-based software projects

19

[29].

A few blockchain benchmark tools also support block-
chain network deployment. For instance, MixBytes Tank
[33] helps practitioners deploy a private Polkadot or Haya
blockchain on private clouds before running a benchmark.
MADT [47] is a Python-based network simulator that al-
lows practitioners to deploy a private blockchain on the
simulated network for development and evaluation.

Table 4 compares NVAL with the existing work. NVAL
shares the core approach with PlaTIBART and Bevel,
which involves capturing blockchain network architec-
tures as digital artefacts and employing a centralised net-
work manager to realise the requested blockchain net-
works. Unlike the existing system, NVAL’s meta-model
(Section 4) enables architects to specify blockchain net-
work architectures at a design-decision-level rather than
a platform-conﬁguration-level and allows them to capture
multi-channel heterogeneous blockchain network architec-
ture. The ﬂexibility of blockchain network architecture
input is facilitated by community-contributed automation
programs (Section 5) and an automated planning approach
(Section 6). As demonstrated in the case study, NVAL can
combine multiple automation programs to process complex
multi-channel heterogeneous blockchain networks at run-
time. Moreover, end-users such as blockchain network op-
erators can control and extend the framework’s capability
by acquiring and adding actions to their NVAL instance
rather than relying on a project owner or service provider.
Besides deployment, NVAL also supports evaluation au-
tomation by introducing the evaluator action type to cap-
ture evaluation automation tasks and embedding evalua-
tion requests and states into NVAL’s planning procedure.
Finally, the case study demonstrates that NVAL only re-
quires SSH connections to target computers to deploy and
evaluate blockchain networks. Therefore, it can support
any infrastructure rather than be constrained to a speciﬁc
cloud.

9.2. Blockchain Network Architecture

This paper also contributes to the architectural research
of blockchain applications and networks. This line of re-
search started from the recognition of blockchain as a
software connector type that bridges software components
across organisations in a decentralised and trustless man-
ner [7, 50]. Recent research on the software architecture
aspects of blockchains has focused on architectural tactics
[51] and patterns [52] to design on-blockchain smart con-
tracts and the software systems surrounding them.

Whilst blockchain networks are also software systems,
research on blockchain network architectures have received
less focus. Xu et al.
[13] proposed a taxonomy of block-
chain networks to support practitioners in choosing a
blockchain for their use cases. Tran et al. [2] was amongst
the ﬁrst to investigate the possible design decisions in
establishing a blockchain network. Recent research has
identiﬁed design patterns of blockchain networks for edge

computing use cases, highlighting the prevalence of multi-
channel heterogeneous blockchain networks [2].

This paper advances the research on blockchain net-
work architecture by proposing a meta-model for cap-
turing blockchain network architectures as computer-
understandable artefacts. This meta-model is based on
the design decisions identiﬁed by Tran et al.
[2]. Future
research, such as formal veriﬁcation and recommendation
of blockchain network architecture, can leverage the pro-
posed meta-model.

9.3. Blockchain Network Evaluation

Blockchain network evaluation can be classiﬁed into
benchmark and simulation. Benchmarks assess a block-
chain network’s quality after deployment by subjecting the
network to standardised workloads and measuring qual-
ity attributes of interest. Benchmarks can be conducted
manually as demonstrated on the Quorum [53] and Red
Belly [54], and Fabric [55] blockchain platforms. As propri-
etary benchmarks can be diﬃcult to compare, researchers
and industry have developed blockchain benchmark suites.
BLOCK BENCH [20] is among the earliest benchmark au-
tomation suites. It provides workloads for benchmarking
both end-to-end performance and individual layers such
[56] ex-
as consensus and processing. Pongnumkui et al.
tended the idea of BLOCK BENCH but emphasised the
impact of workload size on the computing layer of block-
chain nodes. Zheng et al.
[57] proposed an alternative
monitoring framework that analyses the logs generated by
Ethereum clients to infer their performance in real-time.
Beyond performance, researchers have also applied bench-
marks to assess the correlation between CPU consumption
and blockchain’s rewards [58], and bandwidth requirement
for real-time use cases [59]. A survey of blockchain bench-
mark suites is available in [60].

Simulations assess the qualities of a blockchain network
before deployment. They are helpful in scenarios where
deploying a blockchain network prototype is impractical.
The existing simulators [21, 22, 23, 24] vary broadly in
simulation parameters and predicted indicators. However,
their inputs are primarily reﬂections of the architectures
of blockchain networks that they need to simulate.

NVAL does not oﬀer new simulators or benchmarks.
However, it oﬀers a platform for integrating and employ-
ing simulators and benchmark suites. Speciﬁcally, simu-
lators and benchmark suites can be encapsulated as com-
posable actions and integrated into NVAL’s action pool.
The bridging modules of these actions can transform ar-
chitectural speciﬁcations (BND fragments) into the input
expected by the enclosed simulators or benchmark suites.

10. Conclusion

This paper introduces NVAL, a software framework that
automatically deploys and evaluates blockchain networks
based on architectural speciﬁcations. This framework en-
ables practitioners and researchers to focus on designing

20

blockchain networks and reduces the time and eﬀort con-
sumed by implementation mistakes and misconﬁgurations.
NVAL operates by breaking down complex multi-channel
blockchain networks into logical channels and leveraging
the existing automation programs contributed by practi-
tioners to deploy and evaluate these channels individually.
We propose a novel meta-model to capture blockchain net-
work architectures, a novel concept and architecture to
capture automation programs, and a state-space search ap-
proach to match architectures with actions and construct
execution plans automatically. A real-world case study
with 65 blockchain networks featuring 12 diverse architec-
tures shows that NVAL can accurately deploy and evaluate
blockchain networks with negligible time overheads.

We plan to extend NVAL by introducing semantic de-
scriptions to actions and BND models to enable more so-
phisticated semantic-based matching between actions and
architectures. We also aim to explore AI-based techniques
to build actions automatically from the existing open-
source deployment scripts and natural language instruc-
tions. These solutions aim to further improve the longevity
and eﬀectiveness of NVAL as an all-in-one solution for re-
searchers and practitioners to deploy and evaluate complex
blockchain networks.

Acknowledgements

We would like to thank Chadni, Fattah, and Shaw from
the Center for Research on Engineering Software Tech-
nologies (CREST) as well as anonymous reviewers for the
insightful and constructive comments.

References

[1] E. Androulaki, A. Barger, V. Bortnikov, C. Cachin, K. Chris-
tidis, A. De Caro, D. Enyeart, C. Ferris, G. Laventman,
Y. Manevich, et al., Hyperledger fabric: a distributed oper-
ating system for permissioned blockchains, in: Proceedings of
the thirteenth EuroSys conference, 2018, pp. 1–15.

[2] N. K. Tran, M. A. Babar, Taxonomy of edge blockchain
Software Architecture, Springer In-
doi:10.1007/

network designs,
ternational Publishing, 2021, pp. 172–180.
978-3-030-86044-812.

in:

[3] G. Wood, et al., Ethereum: A secure decentralised generalised
transaction ledger, Ethereum project yellow paper 151 (2014)
(2014) 1–32.

[4] S. Nakamoto, Bitcoin whitepaper, URL: https://bitcoin.

org/bitcoin. pdf-(: 17.07. 2019).

[5] C. Cachin, M. Vukoli’c, Blockchain consensus protocols in the

wild, arXiv preprint arXiv:1707.01873.

[6] V. Buterin, The meaning of decentralization, Vitalik Buterin’s

Blog.
URL
the-meaning-of-decentralization-a0c92b76a274

https://medium.com/@VitalikButerin/

[7] X. Xu, C. Pautasso, L. Zhu, V. Gramoli, A. Ponomarev, A. B.
Tran, S. Chen, The blockchain as a software connector, in: 2016
13th Working IEEE/IFIP Conference on Software Architecture
(WICSA), IEEE, 2016, pp. 182–191.

[8] M. Swan, Blockchain: Blueprint for a new economy, ” O’Reilly

Media, Inc.”, 2015.

[9] L. Kugler, Non-fungible tokens and the future of art, Commu-

nications of the ACM 64 (9) (2021) 19–20.

21

[10] E. Avgouleas, A. Kiayias, The architecture of decentralised ﬁ-
nance platforms: A new open ﬁnance paradigm, SSRN Elec-
tronic Journaldoi:10.2139/ssrn.3666029.

[11] N. K. Tran, M. A. Babar, J. Boan, Integrating blockchain and
internet of things systems: A systematic review on objectives
and designs, Journal of Network and Computer Applications
173 (2021) 102844. doi:10.1016/j.jnca.2020.102844.

[12] L. Pawczuk, J. Holdowsky, R. Massey, B. Hansen, Deloitte’s
2020 global blockchain survey from promise to reality, Deloitte
Insights (2020) 1–44.

[13] X. Xu, I. Weber, M. Staples, L. Zhu, J. Bosch, L. Bass,
C. Pautasso, P. Rimba, A taxonomy of blockchain-based sys-
tems for architecture design, in: 2017 IEEE International Con-
ference on Software Architecture (ICSA), IEEE, 2017. doi:
10.1109/icsa.2017.33.

[14] R. G. Brown, The corda platform: An introduction, Retrieved

27 (2018) 2018.

[15] N. K. Tran, M. A. Babar, Anatomy, concept, and design space
of blockchain networks, in: 2020 IEEE International Conference
on Software Architecture (ICSA), IEEE, 2020. doi:10.1109/
icsa47634.2020.00020.

[16] X. Liang, J. Zhao, S. Shetty, D. Li, Towards data assurance
and resilience in IoT using blockchain, in: MILCOM 2017 -
2017 IEEE Military Communications Conference (MILCOM),
IEEE, 2017. doi:10.1109/milcom.2017.8170858.

[17] A. Ramachandran, M. Kantarcioglu, SmartProvenance,

in:
Proceedings of the Eighth ACM Conference on Data and Ap-
plication Security and Privacy, ACM, 2018.
doi:10.1145/
3176258.3176333.

[18] E. Bandara, D. Tosh, P. Foytik, S. Shetty, N. Ranasinghe, K. D.
Zoysa, Tikiri—towards a lightweight blockchain for IoT, Future
Generation Computer Systems 119 (2021) 154–165. doi:10.
1016/j.future.2021.02.006.

[19] W. Zheng, Z. Zheng, X. Chen, K. Dai, P. Li, R. Chen, Nut-
BaaS: A blockchain-as-a-service platform, IEEE Access 7 (2019)
134422–134433. doi:10.1109/access.2019.2941905.

[20] T. T. A. Dinh, J. Wang, G. Chen, R. Liu, B. C. Ooi, K.-L.
Tan, BLOCKBENCH, in: Proceedings of the 2017 ACM In-
ternational Conference on Management of Data, ACM, 2017.
doi:10.1145/3035918.3064033.

[21] R. Yasaweerasinghelage, M. Staples, I. Weber, Predicting la-
tency of blockchain-based systems using architectural modelling
in: 2017 IEEE International Conference on
and simulation,
Software Architecture (ICSA), IEEE, 2017. doi:10.1109/icsa.
2017.22.

[22] B. Wang, S. Chen, L. Yao, B. Liu, X. Xu, L. Zhu, A simula-
tion approach for studying behavior and quality of blockchain
in: Lecture Notes in Computer Science, Springer
networks,
International Publishing, 2018, pp. 18–31.
doi:10.1007/
978-3-319-94478-42.

[23] H. Zhang, C. Jin, H. Cui, A method to predict the performance
and storage of executing contract for ethereum consortium-
blockchain, in: Lecture Notes in Computer Science, Springer
International Publishing, 2018, pp. 63–74.
doi:10.1007/
978-3-319-94478-45.

[24] Y. Aoki, K. Otsuki, T. Kaneko, R. Banno, K. Shudo, SimBlock:
A blockchain network simulator, in:
IEEE INFOCOM 2019
- IEEE Conference on Computer Communications Workshops
(INFOCOM WKSHPS), IEEE, 2019. doi:10.1109/infcomw.
2019.8845253.

[25] L. Bass, P. Clements, R. Kazman, Software architecture in prac-

tice, Addison-Wesley Professional, 2003.

[26] Q. Lu, X. Xu, Y. Liu, I. Weber, L. Zhu, W. Zhang, uBaaS:
A uniﬁed blockchain as a service platform, Future Genera-
tion Computer Systems 101 (2019) 564–575. doi:10.1016/j.
future.2019.05.051.

[27] A. A. Malik, D. K. Tosh, U. Ghosh, Non-intrusive deployment of
blockchain in establishing cyber-infrastructure for smart city, in:
2019 16th Annual IEEE International Conference on Sensing,
Communication, and Networking (SECON), IEEE, 2019. doi:
10.1109/sahcn.2019.8824921.

Rbaas: A robust blockchain as a service paradigm in cloud-edge
collaborative environment, IEEE Access 10 (2022) 35437–35444.
doi:10.1109/ACCESS.2022.3161744.

[50] X. Xu, I. Weber, M. Staples, Architecture for Blockchain Appli-
cations, Springer International Publishing, 2019. doi:10.1007/
978-3-030-03035-3.

[51] F. Wessling, V. Gruhn, Engineering software architectures of
blockchain-oriented applications, in: 2018 IEEE International
Conference on Software Architecture Companion (ICSA-C),
IEEE, 2018. doi:10.1109/icsa-c.2018.00019.

[52] X. Xu, C. Pautasso, L. Zhu, Q. Lu, I. Weber, A pattern collec-
tion for blockchain-based applications, in: Proceedings of the
23rd European Conference on Pattern Languages of Programs,
ACM, 2018. doi:10.1145/3282308.3282312.

[53] A. Baliga, I. Subhod, P. Kamat, S. Chatterjee, Performance
evaluation of the quorum blockchain platform, arXiv preprint
arXiv:1809.03421.

[54] T. Crain, C. Natoli, V. Gramoli, Evaluating the red belly block-

chain, arXiv preprint arXiv:1812.11747.

[55] C. Wickboldt, Benchmarking a blockchain-based certiﬁcation

storage system, Tech. rep. (2019).

[56] S. Pongnumkul, C. Siripanpornchana, S. Thajchayapong, Per-
formance analysis of private blockchain platforms in varying
workloads, in: 2017 26th International Conference on Computer
Communication and Networks (ICCCN), IEEE, 2017, pp. 1–6.
[57] P. Zheng, Z. Zheng, X. Luo, X. Chen, X. Liu, A detailed and
real-time performance monitoring framework for blockchain sys-
tems, in: 2018 IEEE/ACM 40th International Conference on
Software Engineering: Software Engineering in Practice Track
(ICSE-SEIP), IEEE, 2018, pp. 134–143.

[58] A. Aldweesh, M. Alharby, E. Solaiman, A. van Moorsel, Perfor-
mance benchmarking of smart contracts to assess miner incen-
tives in ethereum, in: 2018 14th European Dependable Com-
puting Conference (EDCC), IEEE, 2018, pp. 144–149.

[59] A. Meeuw, S. Schopfer, F. Wortmann, Experimental bandwidth
benchmarking for p2p markets in blockchain managed micro-
grids, Energy Procedia 159 (2019) 370–375.

[60] R. Wang, K. Ye, C.-Z. Xu, Performance benchmarking and op-
timization for blockchain systems: A survey, in: International
Conference on Blockchain, Springer, 2019, pp. 171–185.

[28] A. Bosu, A. Iqbal, R. Shahriyar, P. Chakraborty, Understanding
the motivations, challenges and needs of blockchain software
developers: a survey, Empirical Software Engineering 24 (4)
(2019) 2636–2673. doi:10.1007/s10664-019-09708-7.

[29] M. W¨ohrer, U. Zdun, Devops

for ethereum blockchain
smart contracts, in: 2021 IEEE International Conference on
Blockchain (Blockchain), 2021, pp. 244–251.
doi:10.1109/
Blockchain53845.2021.00040.

[30] M. A. Walker, A. Dubey, A. Laszka, D. C. Schmidt, PlaTI-
BART, in: Proceedings of the 4th Workshop on Middleware and
Applications for the Internet of Things - M4IoT textquotesin-
gle17, ACM Press, 2017. doi:10.1145/3152141.3152392.

[31] Hyperledger,

Hyperledger

composer,

https://github.com/hyperledger/composer (2019).

[32] Hyperledger,

Hyperledger

babel,

https://github.com/hyperledger/bevel (2021).

[33] MixBytes, Mixbytes tank, https://github.com/mixbytes/tank

(2021).

[34] A. Das, G. Uddin, G. Ruhe, An empirical study of block-
chain repositories in githubarXiv:2205.08087, doi:10.1145/
3530019.3530041.

[35] G.

Greenspan,
than

Private

blockchains

are
databases,

“just”

more
https://www.multichain.com/blog/2015/10/private-
blockchains-shared-databases/ (Oct. 2015).
URL
private-blockchains-shared-databases/

shared

https://www.multichain.com/blog/2015/10/

[36] P.-L. Aublin, S. B. Mokhtar, V. Qu´ema, Rbft: Redundant
byzantine fault tolerance,
in: 2013 IEEE 33rd International
Conference on Distributed Computing Systems, IEEE, 2013,
pp. 297–306.

[37] M. Castro, B. Liskov, et al., Practical byzantine fault tolerance,

in: OsDI, Vol. 99, 1999, pp. 173–186.

[38] P. B. Kruchten, The 4+ 1 view model of architecture, IEEE

software 12 (6) (1995) 42–50.

[39] S. J. Russell, Artiﬁcial intelligence a modern approach, Pearson

Education, Inc., 2010.

[40] R. K. Yin, Case study research: Design and methods, Vol. 5,

sage, 2009.

[41] P. Runeson, M. H¨ost, Guidelines for conducting and report-
ing case study research in software engineering, Empirical
Software Engineering 14 (2) (2008) 131–164.
doi:10.1007/
s10664-008-9102-8.

[42] IBM, An architectural blueprint for autonomic computing, IBM

White Paper 31 (2006) (2006) 1–6.

[43] S. Porru, A. Pinna, M. Marchesi, R. Tonelli, Blockchain-
oriented software engineering: Challenges and new directions,
in: 2017 IEEE/ACM 39th International Conference on Soft-
ware Engineering Companion (ICSE-C), IEEE, 2017.
doi:
10.1109/icse-c.2017.142.

[44] P. Chakraborty, R. Shahriyar, A. Iqbal, A. Bosu, Understanding
the software development practices of blockchain projects, in:
Proceedings of the 12th ACM/IEEE International Symposium
on Empirical Software Engineering and Measurement, ACM,
2018. doi:10.1145/3239235.3240298.

[45] M. Ortu, M. Orru, G. Destefanis, On comparing software qual-
ity metrics of traditional vs blockchain-oriented software: An
empirical study,
in: 2019 IEEE International Workshop on
Blockchain Oriented Software Engineering (IWBOSE), IEEE,
2019. doi:10.1109/iwbose.2019.8666575.

[46] T. G´orski, Towards continuous deployment for blockchain, Ap-

plied Sciences 11 (24). doi:10.3390/app112411745.
URL https://www.mdpi.com/2076-3417/11/24/11745
[47] MADT, Madt, https://github.com/dltcspbu/madt (2020).
[48] G. Li, Y. Dong, J. Li, X. Song, Strategy for dynamic block-
chain construction and transmission in novel edge computing
networks, Future Generation Computer Systems 130 (2022) 19–
32. doi:https://doi.org/10.1016/j.future.2021.12.005.
URL https://www.sciencedirect.com/science/article/pii/
S0167739X21004866

[49] Z. Cai, G. Yang, S. Xu, C. Zang, J. Chen, P. Hang, B. Yang,

22

