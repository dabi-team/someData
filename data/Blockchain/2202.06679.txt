Liveness and Latency of
Byzantine State-Machine Replication

Manuel Bravo
Informal Systems, Madrid, Spain

Gregory Chockler
University of Surrey, UK

Alexey Gotsman
IMDEA Software Institute, Madrid, Spain

Abstract

Byzantine state-machine replication (SMR) ensures the consistency of replicated state in the presence
of malicious replicas and lies at the heart of the modern blockchain technology. Byzantine SMR
protocols often guarantee safety under all circumstances and liveness only under synchrony. However,
guaranteeing liveness even under this assumption is nontrivial. So far we have lacked systematic
ways of incorporating liveness mechanisms into Byzantine SMR protocols, which often led to subtle
bugs. To close this gap, we introduce a modular framework to facilitate the design of provably live
and eﬃcient Byzantine SMR protocols. Our framework relies on a view abstraction generated by a
special SMR synchronizer primitive to drive the agreement on command ordering. We present a
simple formal speciﬁcation of an SMR synchronizer and its bounded-space implementation under
partial synchrony. We also apply our speciﬁcation to prove liveness and analyze the latency of three
Byzantine SMR protocols via a uniform methodology. In particular, one of these results yields what
we believe is the ﬁrst rigorous liveness proof for the algorithmic core of the seminal PBFT protocol.

2012 ACM Subject Classiﬁcation Theory of computation → Distributed computing models

Keywords and phrases Replication, blockchain, partial synchrony, liveness

Funding This work was partially supported by an ERC Starting Grant RACCOON and by a research
grant from Nomadic Labs and the Tezos Foundation.

Acknowledgements We thank the following people for comments that helped improve the paper:
Lăcrămioara Aştefănoaei, Hagit Attiya, Alysson Besani, Armando Castañeda, Peter Davies, Dan
O’Keeﬀe, Idit Keidar, Giuliano Losa, Alejandro Naser, and Eugen Zălinescu.

1

Introduction

Byzantine state-machine replication (SMR) [51] ensures the consistency of replicated state
even when some of the replicas are malicious. It lies at the heart of the modern blockchain
technology and is closely related to the classical Byzantine consensus problem. Unfortunately,
no deterministic protocol can guarantee both safety and liveness of Byzantine SMR when
the network is asynchronous [32]. A common way to circumvent this while maintaining
determinism is to guarantee safety under all circumstances and liveness only under synchrony.
This is formalized by the partial synchrony model [25, 31], which stipulates that after some
unknown Global Stabilization Time (GST) the system becomes synchronous, with message
delays bounded by an unknown constant δ and process clocks tracking real time. Before GST
messages can be lost or delayed, and clocks at diﬀerent processes can drift apart.

Historically, researchers have paid more attention to safety of Byzantine SMR protocols
than their liveness. For example, while the seminal PBFT protocol came with a detailed
safety proof [22, §A], the nontrivial mechanisms ensuring its liveness were only given a

2
2
0
2

t
c
O
5

]

C
D
.
s
c
[

3
v
9
7
6
6
0
.
2
0
2
2
:
v
i
X
r
a

 
 
 
 
 
 
2

Liveness and Latency of Byzantine State-Machine Replication

brief informal justiﬁcation [24, §4.5.1], which did not cover their most critical properties.
However, ensuring liveness under partial synchrony is far from trivial, as illustrated by
the many liveness bugs found in existing protocols [2, 4, 8, 12, 21]. In particular, classical
failure detectors and leader oracles [25, 33] are of little help: while they have been widely
used under benign failures [37, 38, 46], their implementations under Byzantine failures are
either impractical [42] or detect only restricted failure types [29, 39, 45]. As an alternative, a
textbook by Cachin et al. [19] proposed a leader oracle-like abstraction that accepts hints
from the application to identify potentially faulty processes. However, as we explain in §8
and §F, their speciﬁcation of the abstraction is impossible to implement, and in fact, the
consensus algorithm constructed using it in [19] also suﬀers from a liveness bug.

Recent work on ensuring liveness has departed from failure detectors and instead revisited
the approach of the original DLS paper [31]. This exploits the common structure of Byzantine
consensus and SMR protocols under partial synchrony: such protocols usually divide their
execution into views, each with a designated leader process that coordinates the protocol
execution. If the leader is faulty, the processes switch to another view with a diﬀerent
leader. To ensure liveness, an SMR protocol needs to spend suﬃcient time in views that are
entered by all correct processes and where the leader correctly follows the protocol. The
challenge of achieving such view synchronization is that, before GST, clocks can diverge and
messages that could be used to synchronize processes can get lost or delayed; even after GST,
Byzantine processes may try to disrupt attempts to bring everybody into the same view.
View synchronizers [16, 47, 48, 56] encapsulate mechanisms for dealing with this challenge,
allowing them to be reused across protocols.

View synchronizers have been mostly explored in the context of (single-shot) Byzantine
consensus. In this case a synchronizer can just switch processes through an inﬁnite series of
views, so that eventually there is a view with a correct leader that is long enough to reach a
decision [16, 48]. However, using such a synchronizer for SMR results in suboptimal solutions.
For example, one approach is to use the classical SMR construction where each command
is decided using a separate black-box consensus instance [51], implemented using a view
synchronizer. However, this would force the processes in every instance to iterate over the
same sequence of potentially bad views until the one with a correct leader and suﬃciently
long duration could be reached. As we discuss in §8, other approaches for implementing
SMR based on this type of synchronizers also suﬀer from drawbacks.

To minimize the overheads of view synchronization, instead of automatically switching
processes through views based on a ﬁxed schedule, implementations such as PBFT allow
processes to stay in the same view for as long as they are happy with its performance. The
processes can then reuse a single view to decide multiple commands, usually with the same
leader. To be useful for such SMR protocols, a synchronizer needs to allow the processes
to control when they want to switch views via a special advance call. We call such a
primitive an SMR synchronizer, to distinguish it from the less ﬂexible consensus synchronizer
introduced above. This kind of synchronizers was ﬁrst introduced in [47, 48], but only used
as an intermediate module to implement a consensus synchronizer.

In this paper we show that SMR synchronizers can be directly exploited to construct
eﬃcient and provably live SMR protocols and develop a general blueprint that enables such
constructions. In more detail:

We propose a formal speciﬁcation of an SMR synchronizer (§3), which is simpler and
more general than prior proposals [47, 48]. It is also strictly stronger than the consensus
synchronizer of [16], which can be obtained from the SMR synchronizer at no extra cost.
Informally, our speciﬁcation guarantees that (a) the system will move to a new view if

M. Bravo, G. Chockler, and A. Gotsman

3

enough correct processes call advance, and (b) all correct processes will enter the new
view, provided that for long enough, no correct process that enters this view asks to
leave it. These properties enable correct processes to iterate through views in search of a
well-behaved leader, and to synchronize in a view they are happy with.

We give an SMR synchronizer implementation and prove that it satisﬁes our speciﬁcation
(§3.1). Unlike prior implementations [48], ours tolerates message loss before GST while
using only bounded space; in practice, this feature is essential to defend against denial-of-
service attacks. We also provide a precise latency analysis of our synchronizer, quantifying
how quickly all correct processes enter the next view after enough of them call advance.

We demonstrate the usability of our synchronizer speciﬁcation by applying it to construct
and prove the correctness of several SMR protocols. First, we prove the liveness of a
variant of PBFT using an SMR synchronizer (§4-5): to the best of our knowledge, this is
the ﬁrst rigorous proof of liveness for PBFT’s algorithmic core. The proof establishes a
strong liveness guarantee that implies censorship-resistance: every command submitted by
a correct process will be executed. The use of the synchronizer speciﬁcation in the proof
allows us to abstract from view synchronization mechanics and focus on protocol-speciﬁc
reasoning. This reasoning is done using a reusable methodology based on showing that
the use of timers in the SMR protocol and the synchronizer together establish properties
similar to those of failure detectors. The methodology also handles the realistic ways in
which protocols such as PBFT adapt their timeouts to the unknown message delay δ. We
demonstrate the generality of our methodology by also applying it to a version of PBFT
with periodic leader changes [27, 54, 55] and a HotStuﬀ-like protocol [56] (§7).

We exploit the latency bounds for our synchronizer to establish both bad-case and
good-case bounds for variants of PBFT implemented on top of it (§6). Our bad-case
bound assumes that the protocol starts before GST; it shows that after GST all correct
processes synchronize in the same view within a bounded time. This time is proportional
to a conservatively chosen constant ∆ that bounds post-GST message delays in all
executions [40, 49]. Our good-case bound quantiﬁes decision latency when the protocol
starts after GST and matches the lower bound of [5].

2

System Model

We consider a system of n = 3f + 1 processes. At most f of these can be Byzantine (aka
faulty), i.e., can behave arbitrarily. The rest of the processes are correct and we denote their
set by C. We call a set Q of 2f + 1 processes a quorum and write quorum(Q). We assume
standard cryptographic primitives [19, §2.3]: processes can communicate via authenticated
point-to-point links, sign messages using digital signatures, and use a collision-resistant hash
function hash(). We denote by hmii a message m signed by process pi.

We consider a partial synchrony model [25, 31]: for each execution of the protocol, there
exist a time GST and a duration δ such that after GST message delays between correct
processes are bounded by δ; before GST messages can get arbitrarily delayed or lost. As
in [25], we assume that the values of GST and δ are unknown to the protocol. This reﬂects the
requirements of practical systems, whose designers cannot accurately predict when network
problems leading to asynchrony will stop and what the latency will be during the following
synchronous period. We also assume that processes have hardware clocks that can drift
unboundedly from real time before GST, but do not drift thereafter.

4

Liveness and Latency of Byzantine State-Machine Replication

1. Monotonicity. A process enters increasing views:

∀i, v, v0. Ei(v)↓ ∧ Ei(v0)↓ =⇒ (v < v0 ⇐⇒ Ei(v) < Ei(v0))

2. Validity. A process only enters v + 1 if some correct process has attempted to advance from v:

∀i, v. Ei(v + 1)↓ =⇒ Aﬁrst(v)↓ ∧ Aﬁrst(v) < Ei(v + 1)

3. Bounded Entry. For some V and d, if a process enters a view v ≥ V and no process attempts
to advance to a higher view within time d, then all correct processes will enter v within d:
∃V, d. ∀v ≥ V. Eﬁrst(v)↓ ∧ ¬(Aﬁrst(v) < Eﬁrst(v) + d) =⇒ (∀pi ∈ C. Ei(v)↓) ∧ Elast(v) ≤ Eﬁrst(v) + d

4. Startup. Some correct process will enter view 1 if f + 1 processes call advance:

(∃P ⊆ C. |P | = f + 1 ∧ (∀pi ∈ P. Ai(0)↓)) =⇒ Eﬁrst(1)↓

5. Progress. If a correct process enters a view v and, for some set P of f + 1 correct processes, any
process in P that enters v eventually calls advance, then some correct process will enter v + 1:
∀v. Eﬁrst(v)↓ ∧ (∃P ⊆ C. |P | = f + 1 ∧ (∀pi ∈ P. Ei(v)↓ =⇒ Ai(v)↓)) =⇒ Eﬁrst(v + 1)↓

Figure 1 SMR synchronizer speciﬁcation.

3

SMR Synchronizer Speciﬁcation and Implementation

We consider a synchronizer interface deﬁned in [47, 48], which here we call an SMR syn-
chronizer. Let View = {1, 2, . . .} be the set of views, ranged over by v; we use 0 to denote
an invalid initial view. The synchronizer produces notiﬁcations new_view(v) at a process,
telling it to enter view v. To trigger these, the synchronizer allows a process to call a function
advance(), which signals that the process wishes to advance to a higher view. We assume that
a correct process does not call advance twice without an intervening new_view notiﬁcation.
Our ﬁrst contribution is the SMR synchronizer speciﬁcation in Figure 1, which is simpler
and more general than prior proposals [47, 48] (see §8 for a discussion). The speciﬁcation
relies on the following notation. Given a view v entered by a correct process pi, we denote
by Ei(v) the time when this happens; we let Eﬁrst(v) and Elast(v) denote respectively the
earliest and the latest time when some correct process enters v. We denote by Ai(v) the
time when a correct process pi calls advance while in v, and let Aﬁrst(v) and Alast(v) denote
respectively the earliest and the latest time when this happens. Given a partial function f ,
we write f (x)↓ if f (x) is deﬁned, and f (x)↑ if f (x) is undeﬁned.

The Monotonicity property in Figure 1 ensures that views can only increase at a given
process. Validity ensures that a process may only enter a view v + 1 if some correct process
has called advance in v. This prevents faulty processes from disrupting the system by forcing
view changes. As a corollary of Validity we can prove that, if a view v0 is entered by some
correct process, then so are all the views v preceding v0.

(cid:73) Proposition 1. ∀v, v0. 0 < v < v0 ∧ Eﬁrst(v0)↓ =⇒ Eﬁrst(v)↓ ∧ Eﬁrst(v) < Eﬁrst(v0).

Proof. Fix v0 ≥ 2 and assume that a correct process enters v0, so that Eﬁrst(v0)↓. We prove
by induction on k that ∀k = 0..(v0 − 1). Eﬁrst(v0 − k)↓ ∧ Eﬁrst(v0 − k) ≤ Eﬁrst(v0). The base
case of k = 0 is trivial. For the inductive step, assume that the required holds for some
k. Then by Validity there exists a time t < Eﬁrst(v0 − k) at which some correct process pj
attempts to advance from v0 − k − 1. But then pj’s view at t is v0 − k − 1. Hence, pj enters
v0 − k − 1 before t, so that Eﬁrst(v0 − k − 1) < t < Eﬁrst(v0 − k) ≤ Eﬁrst(v0), as required. (cid:74)

Bounded Entry ensures that, if some process enters view v, then all correct processes will
do so within at most d time units of each other (d = 2δ for our implementation). This only
holds if within d no process attempts to advance to a higher view, as this may make some

M. Bravo, G. Chockler, and A. Gotsman

5

1 when the process starts or timer expires

2

advance();

3 upon new_view(v)
4

stop_timer(timer);
start_timer(timer, τ );

5

Figure 2 A simple client of the SMR synchronizer.

processes skip v and enter a higher view directly. Bounded Entry also holds only starting
from some view V, since we may not be able to guarantee it for views entered before GST.
Startup ensures that some correct process enters view 1 if f + 1 processes call advance.
Given a view v entered by a correct process, Progress determines conditions under which
some correct process will enter the next view v + 1. This will happen if for some set P of
f + 1 correct processes, any process in P entering v eventually calls advance. Note that even
a single advance call at a correct process may lead to a view switch (reﬂecting the fact that
in implementations faulty processes may help this correct process). Startup and Progress
ensure that the synchronizer must switch if at least f + 1 correct processes ask for this. We
now illustrate a typical pattern of their use, which we later apply to PBFT (§5). To this
end, we consider a simple client in Figure 2, where in each view a process sets a timer for a
ﬁxed duration τ and calls advance when the timer expires. Using Startup and Progress we
prove that this client keeps switching views forever as follows.

(cid:73) Proposition 2. In any execution of the client in Figure 2: ∀v. ∃v0. v0 > v ∧ Eﬁrst(v0)↓.

Proof. Since all correct processes initially call advance, by Startup some correct process
eventually enters view 1. Assume now that the proposition is false, so that there is a
maximal view v entered by any correct process. Let P be any set of f + 1 correct processes
and consider an arbitrary process pi ∈ P that enters v. When this happens, pi sets the
timer for the duration τ . The process then either calls advance when timer expires, or
In the latter case v0 > v by Monotonicity, which is
enters a new view v0 before this.
impossible. Hence, pi eventually calls advance while in v. Since pi was chosen arbitrarily,
(cid:74)
∀pi ∈ P. Ei(v)↓ =⇒ Ai(v)↓. Then by Progress we get Eﬁrst(v + 1)↓: a contradiction.

Similarly to Figure 2, we can use an SMR synchronizer satisfying the properties in
Figure 1 to implement a consensus synchronizer [16, 48] without extra overhead. This lacks
an advance call and provides only the new_view notiﬁcation, which it keeps invoking at
increasing intervals so that eventually the there is a view long enough for the consensus
protocol running on top to decide. We obtain a consensus synchronizer if in Figure 2
we propagate the new_view notiﬁcation to the consensus protocol and set the timer to an
unboundedly increasing function of views instead of a constant τ . In §A we show that the
resulting consensus synchronizer satisﬁes the speciﬁcation proposed in [16].

3.1 A Bounded-Space SMR Synchronizer

We now present a bounded-space algorithm that implements the speciﬁcation in Figure 1
under partial synchrony for d = 2δ. Our implementation reuses algorithmic techniques from a
consensus synchronizer of Bravo et al. [16]. However, it supports a more general abstraction,
and thus requires a more intricate correctness proof and latency analysis (§3.2).

When a process calls advance (line 1), the synchronizer does not immediately move to the
next view v0, but disseminates a WISH(v0) message announcing its intention. A process enters

6

Liveness and Latency of Byzantine State-Machine Replication

1 function advance()
2

send WISH(max(view + 1, view+))
to all;
advanced ← true;

3

9 when received WISH(v) from pj
prev_v, prev_v+ ← view, view+;
10
if v > max_views[j] then max_views[j] ← v;
view ← max{v | ∃k. max_views[k] = v ∧

12

11

4 periodically

. every ρ time units

5

6

7

8

if advanced then

send WISH(max(view + 1, view+))
to all;

else if view+ > 0 then

send WISH(view+) to all;

13

14

15

16

17

18

|{j | max_views[j] ≥ v}| ≥ 2f + 1};

view+ ← max{v | ∃k. max_views[k] = v ∧

|{j | max_views[j] ≥ v}| ≥ f + 1};

if view+ = view ∧ view > prev_v then

trigger new_view(view);
advanced ← false;
if view+ > prev_v+ then

send WISH(view+) to all

Figure 3 A bounded-space SMR synchronizer. All counters are initially 0.

a new view once it accumulates a suﬃcient number of WISH messages supporting this. A
naive synchronizer design could follow Bracha broadcast [15]: enter a view v0 upon receiving
2f + 1 WISH(v0) messages, and echo WISH(v0) upon receiving f + 1 copies thereof; the latter
is needed to combat equivocation by Byzantine processes. However, in this case the process
would have to track all newly proposed views for which < 2f + 1 WISHes have been received.
Since messages sent before GST can be lost or delayed, this would require unbounded space.
To reduce the space complexity, in our algorithm a process only remembers the highest
view received from each process, kept in an array max_views (line 11). Variables view and
view+ respectively hold the (2f + 1)st highest and the (f + 1)st highest views in max_views
(lines 12-13). These variables never decrease and always satisfy view ≤ view+.

The process enters the view stored in view when this variable increases (line 15). A process
thus enters v only if it receives 2f + 1 WISHes for views ≥ v, and a process may be forced to
switch views even if it did not call advance; the latter helps lagging processes to catch up.
The variable view+ increases when the process receives f + 1 WISHes for views ≥ view+, and
thus some correct process wishes to enter a new view ≥ view+. In this case we echo view+
(line 18), to help other processes switch views and satisfy Bounded Entry and Progress.

The guard view+ = view in line 14 ensures that a process does not enter a “stale” view
such that another correct process already wishes to enter a higher one. Similarly, when
the process calls advance, it sends a WISH for the maximum of view + 1 and view+ (line 2).
Thus, if view = view+, so that the values of the two variables have not changed since the
process entered the current view, then the process sends a WISH for the next view (view + 1).
Otherwise, view < view+, and the process sends a WISH for the higher view view+. Finally,
to deal with message loss before GST, a process retransmits the highest WISH it sent every ρ
time units, according to its local clock (line 4). Depending on whether the process has called
advance in the current view (tracked by advanced), the WISH is computed as in lines 18 or 2.
Our SMR synchronizer requires only O(n) variables for storing views. Proposition 1 also
ensures that views entered by correct processes do not skip values, which limits the power of
the adversary to exhaust their allocated space (similarly to [11]).

3.2 SMR Synchronizer Correctness and Latency Bounds

The following theorem (proved in §B) states the correctness of our synchronizer as well as
and its performance properties. In §6 we apply the latter to bound the latency of Byzantine
SMR protocols. Given a view v that was entered by a correct process pi, we let Ti(v) denote

M. Bravo, G. Chockler, and A. Gotsman

7

the time at which pi either attempts to advance from v or enters a view > v; we let Tlast(v)
denote the latest time when a correct process does so. We assume that every correct process
eventually attempts to advance from view 0 unless it enters a view > 0, i.e., ∀pi ∈ C. Ti(0)↓.

(cid:73) Theorem 3. Consider an execution with an eventual message delay δ. The algorithm
in Figure 3 satisﬁes the properties in Figure 1 for d = 2δ and V = max{v | (Eﬁrst(v)↓ ∧
Eﬁrst(v) < GST + ρ) ∨ v = 0} + 1 if Aﬁrst(0) < GST, and V = 1, otherwise. Furthermore:

A. ∀v. Eﬁrst(v)↓ ∧ Aﬁrst(0) < GST =⇒ Elast(v) ≤ max(Eﬁrst(v), GST + ρ) + 2δ.
(

B. ∀v. Eﬁrst(v + 1)↓ =⇒ Elast(v + 1) ≤

max(Tlast(v), GST + ρ) + δ,
Tlast(v) + δ,

if Aﬁrst(0) < GST;
otherwise.

The theorem gives a witness for V in Bounded Entry: it is the next view after the highest
one entered by a correct process at or before GST+ρ (or 1 if no view was entered). Property A
bounds the latest time any correct process can enter a view that has been previously entered
by a correct process. It is similar to Bounded Entry, but also handles views < V. Property B
reﬁnes Progress: while the latter guarantees that the synchronizer will enter v + 1 if enough
processes ask for this, the former bounds the time by which this will happen.

4

PBFT Using an SMR Synchronizer

We now demonstrate how an SMR synchronizer can be used to implement Byzantine SMR.
More formally, we implement Byzantine atomic broadcast [19], from which SMR can be
implemented in the standard way [51]. This allows processes to broadcast values, and we
assume an application-speciﬁc predicate to indicate whether a value is valid [20] (e.g., a
block in a blockchain is invalid if it lacks correct signatures). We assume that all values
broadcast by correct processes in a single execution are valid and unique. Then Byzantine
atomic broadcast is deﬁned by the following properties:

Integrity. Every process delivers a value at most once.
External Validity. A correct process delivers only values satisfying valid().
Ordering. If a correct process p delivers x1 before x2, then another correct process q
cannot deliver x2 before x1.
Liveness.
If a correct process broadcasts or delivers x, then eventually all correct
processes will deliver x. (Note that this implies censorship-resistance: the service cannot
selectively omit values submitted by correct processes.)

The PBFT-light protocol. We implement Byzantine atomic broadcast in a PBFT-light
protocol (Figures 4-6), which faithfully captures the algorithmic core of the seminal Practical
Byzantine Fault Tolerance protocol (PBFT) [23]. Whereas PBFT integrated view synchro-
nization functionality with the core SMR protocol, PBFT-light delegates this to an SMR
synchronizer, and in §5 we rigorously prove its liveness when using any synchronizer satisfying
our speciﬁcation. When using the synchronizer in Figure 3, the protocol also incurs only
bounded space overhead (see §C.4 for details).

We base PBFT-light on the PBFT protocol with signatures and, for simplicity, omit
the mechanisms for managing checkpoints and watermarks; these can be easily added
without aﬀecting liveness. The protocol works in a succession of views produced by the
synchronizer. A process stores its current view in curr_view. Each view v has a ﬁxed leader
leader(v) = p((v−1) mod n)+1 that is responsible for totally ordering values submitted for
broadcast; the other processes are followers, which vote on proposals made by the leader.

8

Liveness and Latency of Byzantine State-Machine Replication

1 function start()
2

if curr_view = 0 then advance();

20 when received hPREPREPARE(v, k, x)ij
21

pre: pj = leader(v) ∧ curr_view = v ∧

3 when a timer expires

4

5

6

7

8

stop_all_timers();
advance();
status ← advanced;
dur_delivery ← dur_delivery + τ ;
dur_recovery ← dur_recovery + τ ;

9 function broadcast(x)
pre: valid(x);
10
send hBROADCAST(x)ii to all

11

periodically until x is delivered

12 when received BROADCAST(x)
13

pre: valid(x) ∧ status = normal ∧

(timer_delivery[x] not active) ∧
(∀k. k ≤ last_delivered =⇒
commit_log[k] 6= x);
start_timer(timer_delivery[x],

dur_delivery);

send hFORWARD(x)ii to

leader(curr_view);

14

15

16 when received FORWARD(x)
17

pre: valid(x) ∧ status = normal ∧
pi = leader(curr_view) ∧
∀k. log[k] 6= x;

18

19

send hPREPREPARE(curr_view,

next, x)ii to all;
next ← next + 1;

status = normal ∧ phase[k] = start ∧
valid(x) ∧ (∀k0. log[k0] 6= x)
(log, phase)[k] ← (x, preprepared);
send hPREPARE(v, k, hash(x))ii to all;

22

23

24 when received {hPREPARE(v, k, h)ij | pj ∈ Q} = C

for a quorum Q

pre: curr_view = v ∧ phase[k] = preprepared ∧
status = normal ∧ hash(log[k]) = h;

(prep_log, prep_view, cert, phase)[k] ←
(log[k], curr_view, C, prepared);

send hCOMMIT(v, k, h)ii to all;

25

26

27

28 when received {hCOMMIT(v, k, h)ij | pj ∈ Q} = C

for a quorum Q

29

30

31

pre: curr_view = v ∧ phase[k] = prepared ∧

status = normal ∧ hash(prep_log[k]) = h;
(commit_log, phase)[k] ← (log[k], committed);
broadcast hDECISION(commit_log[k], k, C);

32 when commit_log[last_delivered + 1] 6= ⊥
33

last_delivered ← last_delivered + 1;
if commit_log[last_delivered] 6= nop then

deliver(commit_log[last_delivered])

stop_timer(

timer_delivery[commit_log[last_delivered]]);

if last_delivered = init_log_length ∧
status = normal then

stop_timer(timer_recovery);

34

35

36

37

38

39 when received DECISION(x, k, C)
40

pre: commit_log[k] 6= ⊥ ∧

∃v. committed(C, v, k, hash(x));

41

commit_log[k] ← x;

Figure 4 Normal operation of PBFT-light at a process pi.

Processes store the sequence of (unique) values proposed by the leader in a log array; at the
leader, a next counter points to the ﬁrst free slot in the array. Processes monitor the leader’s
behavior and ask the synchronizer to advance to another view if they suspect that the leader
is faulty. A status variable records whether the process is operating as normal in the current
view (normal) or is changing the view.

Normal protocol operation. A process broadcasts a valid value x using a broadcast
function (line 9). This keeps sending the value to all processes in a BROADCAST message until
the process delivers the value, to tolerate message loss before GST. When a process receives
a BROADCAST message with a new value (line 12), it forwards the value to the leader in a
FORWARD message. This ensures that the value reaches the leader even when broadcast by a
faulty process, which may withhold the BROADCAST message from the leader. (We explain
the timer set in line 14 later.) When the leader receives a new value x in a FORWARD message
(line 16), it sends a PREPREPARE message to all processes (including itself) that includes x
and its position in the log, generated from the next counter. Processes vote on the leader’s
proposal in two phases. Each process keeps track of the status of values going through the

M. Bravo, G. Chockler, and A. Gotsman

9

vote in an array phase, whose entries initially store start.

When a process receives a proposal x for a position k from the leader of its view v (line 20),
it ﬁrst checks that phase[k] = start, so that it has not yet accepted a proposal for the
position k in the current view. It also checks that the value is valid and distinct from all values
it knows about. The process then stores x in log[k] and advances phase[k] to preprepared.
Since a faulty leader may send diﬀerent proposals for the same position to diﬀerent processes,
the process next communicates with others to check that they received the same proposal.
To this end, it disseminates a PREPARE message with the position and the hash of the value x
it received. The process handles x further once it gathers a set C of PREPARE messages from
a quorum matching the value (line 24), which we call a prepared certiﬁcate and check using
the prepared predicate in Figure 6. In this case the process stores the value in prep_log[k],
the certiﬁcate in cert[k], and the view in which it was formed in prep_view[k]. At this point
we say that the process prepared the proposal, as recorded by setting its phase to prepared.
It is easy to show that processes cannot prepare diﬀerent values at the same position and
view, since each correct process can send only one corresponding PREPARE message.

Having prepared a value, the process disseminates a COMMIT message with its hash. Once
the process gathers a quorum of matching COMMIT messages (line 28), it stores the value in a
commit_log array and advances its phase to committed: the value is now committed. The
protocol ensures that correct processes cannot commit diﬀerent values at the same position,
even in diﬀerent views. We call a quorum of matching COMMIT messages a commit certiﬁcate
and check it using the committed predicate in Figure 6. A process delivers committed values
in the commit_log order, with last_delivered tracking the position last delivered position.

To satisfy the Liveness property of atomic broadcast, similarly to [12], PBFT-light allows
a process to ﬁnd out about committed values from other processes directly. When a process
commits a value (line 28), it disseminates a DECISION message with the value, its position
k in the log and the commit certiﬁcate (line 31). A process receiving a DECISION with a
valid certiﬁcate saves the value in commit_log[k], which allows it to be delivered (line 32).
The DECISION messages are disseminated via reliable broadcast ensuring that, if one correct
process delivers the value, then so do all others. To implement this, each process could
periodically resend the DECISION messages it has (omitted from the pseudocode). A more
practical implementation would only resend information that other processes are missing.
As proved in [31], such periodic resends are unavoidable in the presence of message loss.

View initialization. When the synchronizer tells a process to move to a new view v (line 42),
the process sets curr_view to v, which ensures that it will no longer accept messages from
prior views. It also sets status to initializing, which means that the process is not yet ready
to order values in the new view. It then sends a NEW_LEADER message to the leader of v with
the information about the values it has prepared so far and their certiﬁcates1.

The new leader waits until it receives a quorum of well-formed NEW_LEADER messages,
as checked by the predicate ValidNewLeader (line 48). Based on these, the leader computes
the initial log of the new view, stored in log0. Similarly to Paxos [44], for each index k the
leader puts at the kth position in log0 the value prepared in the highest view (line 50). The
resulting array may contain empty or duplicate entries. To resolve this, the leader writes nop
into empty entries and those entries for which there is a duplicate prepared in a higher view
(line 53). The latter is safe because one can show that no value could have been committed

1 In PBFT this information is sent in VIEW-CHANGE messages, which also play a role similar to WISH
messages in our synchronizer (Figure 3). In PBFT-light we opted to eschew VIEW-CHANGE messages to
maintain a clear separation between view synchronization internals and the SMR protocol.

10

Liveness and Latency of Byzantine State-Machine Replication

42 upon new_view(v)
43

stop_all_timers();
curr_view ← v;
status ← initializing;
send hNEW_LEADER(curr_view, prep_view,
prep_log, cert)ii to leader(curr_view);

start_timer(timer_recovery, dur_recovery);

44

45

46

47

48 when received {hNEW_LEADER(v, prep_viewj,

prep_logj, certj)ij | pj ∈ Q} = M
for a quorum Q

49

pre: pi = leader(v) ∧ curr_view = v ∧

50

51

status = initializing ∧
∀m ∈ M. ValidNewLeader(m);

forall k do

if ∃pj0 ∈ Q. prep_viewj0 [k] 6= 0 ∧
∀pj ∈ Q. prep_viewj[k] ≤ prep_viewj0 [k]
then log0[k] ← prep_logj0 [k];

52

next ← max{k | log0[k] 6= ⊥};

53

54

55

56

forall k = 1..(next − 1) do

if log0[k] = ⊥ ∨ ∃k0. k0 6= k ∧
log0[k0] = log0[k] ∧ ∃pj0 ∈ Q. ∀pj ∈ Q.
prep_viewj0 [k0] > prep_viewj[k] then

log0[k] ← nop

send hNEW_STATE(v, log0, M )ii to all;

57 when received hNEW_STATE(v, log0, M )ij = m
58

pre: status = initializing ∧

curr_view = v ∧ ValidNewState(m);

59

60

61

62

63

64

65

66

log ← log0;
forall {k | log[k] 6= ⊥} do

phase[k] ← preprepared;
send hPREPARE(v, k, hash(log[k]))ii

to all;
status ← normal;
init_log_length ← max{k | log[k] 6= ⊥};
if init_log_length ≤ last_delivered then

stop_timer(timer_recovery);

Figure 5 View-initialization protocol of PBFT-light at a process pi.

prepared(C, v, k, h) ⇐⇒ ∃Q. quorum(Q) ∧ C = {hPREPARE(v, k, h)ij | pj ∈ Q}

committed(C, v, k, h) ⇐⇒ ∃Q. quorum(Q) ∧ C = {hCOMMIT(v, k, h)ij | pj ∈ Q}

ValidNewLeader(hNEW_LEADER(v, prep_view, prep_log, cert)i_) ⇐⇒

∀k. (prep_view[k] > 0 =⇒ prep_view[k] < v ∧ prepared(cert[k], prep_view[k], k, prep_log[k]))
ValidNewState(hNEW_STATE(v, log0, M )ii) ⇐⇒ pi = leader(v) ∧ ∃Q, prep_view, prep_log, cert.

quorum(Q) ∧ M = {hNEW_LEADER(v, prep_viewj, logj, certj)ij | pj ∈ Q} ∧
(∀m ∈ C. ValidNewLeader(m)) ∧ (log0 is computed from M as per lines 50-55)

Figure 6 Auxiliary predicates for PBFT-light.

in such entries in prior views. Finally, the leader sends a NEW_STATE message to all processes,
containing the initial log and the NEW_LEADER messages from which it was computed (line 56).
A process receiving a NEW_STATE ﬁrst checks its correctness by redoing the leader’s
computation (ValidNewState, line 57). If the check passes, the process overwrites its log
with the new one and sets status to normal. It also sends PREPARE messages for all log
entries, to commit them in the new view. A more practical implementation would include a
checkpointing mechanism, so that a process restarts committing previous log entries only
from the last stable checkpoint [23]; this mechanism can be easily added to PBFT-light.

Triggering view changes. We now describe when a process calls advance, which is key to
ensure liveness (§5). This happens either on start-up (line 2) or when the process suspects
that the current leader is faulty. To this end, the process monitors the leader’s behavior
using timers; if one of these expires, the process calls advance and sets status to advanced
(line 3). First, the process checks that each value it receives is delivered promptly: e.g.,
to guard against a faulty leader censoring certain values. For a value x this is done using
timer_delivery[x], set for a duration dur_delivery when the process receives BROADCAST(x)
(lines 14). The timer is stopped when the process delivers x (line 36). A process also checks
that the leader initializes a view quickly enough: e.g., to guard against the leader crashing
during the initialization. Thus, when a process enters a view it starts timer_recovery for a

M. Bravo, G. Chockler, and A. Gotsman

11

duration dur_recovery (line 47). The process stops the timer when it delivers all values in the
initial log (lines 38 and 66). The above checks may make a process suspect a correct leader
if the timeouts are initially set too small with respect to the message delay δ, unknown to
the process. To deal with this, a process increases dur_delivery and dur_recovery each time a
timer expires, which signals that the current view is not operating normally (lines 7-8).

5

Proving the Liveness of PBFT

Assume that PBFT-light is used with a synchronizer satisfying the speciﬁcation in Figure 1;
to simplify the following latency analysis we let d = 2δ, as for the synchronizer in Figure 3.
We now prove that the protocol satisﬁes the Liveness property of Byzantine atomic broadcast;
we defer the proof of the other properties to §C.1. To the best of our knowledge, this is the
ﬁrst rigorous proof of liveness for the algorithmic core of PBFT: as we elaborate in §8, the
liveness mechanisms of PBFT came only with a brief informal justiﬁcation, which did not
cover their most critical properties [24, §4.5.1]. Our proof is simpliﬁed by the use of the
synchronizer speciﬁcation, which allows us to abstract from view synchronization mechanics.
We prove the liveness of PBFT-light by showing that the protocol establishes properties
reminiscent of those of failure detectors [25]. First, similarly to their completeness property,
we prove that every correct process eventually attempts to advance from a bad view in which
no progress is possible (e.g., because the leader is faulty).

(cid:73) Lemma 4. Assume that a correct process pi receives BROADCAST(x) for a valid value x
while in a view v. If pi never delivers x and never enters a view higher than v, then it
eventually calls advance in v.

The lemma holds because in PBFT-light each process monitors the leader’s behavior
using timers, and we defer its easy proof to §C.2. Our next lemma is similar to the eventual
accuracy property of failure detectors. It stipulates that if the timeout values are high enough,
then eventually any correct process that enters a good view (with a correct leader) will never
attempt to advance from it. Let dur_recoveryi(v) and dur_deliveryi(v) denote respectively
the value of dur_recovery and dur_delivery at a correct process pi while in view v.

(cid:73) Lemma 5. Consider a view v ≥ V such that Eﬁrst(v) ≥ GST and leader(v) is correct. If
dur_recoveryi(v) > 6δ and dur_deliveryi(v) > 4δ at each correct process pi that enters v, then
no correct process calls advance in v.

Before proving the lemma, we informally explain the rationale for the bounds on timeouts
in it, using the example of dur_recovery. The timer timer_recovery is started at a process
pi when this process enters a view v (line 47), and is stopped when the process delivers
all values inherited from previous views (lines 38 or 66). The two events are separated
by 4 communication steps of PBFT-light, exchanging messages of the types NEW_LEADER,
NEW_STATE, PREPARE and COMMIT (Figure 7). However, 4δ would be too small a value
for dur_recovery. This is because the leader of v sends its NEW_STATE message only after
receiving a quorum of NEW_LEADER messages, and diﬀerent processes may enter v and send
their NEW_LEADER messages at diﬀerent times (e.g., pi and pj in Figure 7). Hence, dur_recovery
must additionally accommodate the maximum discrepancy in the entry times, which is d = 2δ
by the Bounded Entry property. Then to ensure that pi stops the timer before it expires, we
require dur_recoveryi(v) > 6δ. As the above reasoning illustrates, Lemma 5 is more subtle
than Lemma 4: while the latter is ensured just by the checks in the SMR protocol, the former
relies on the Bounded Entry property of the synchronizer.

12

Liveness and Latency of Byzantine State-Machine Replication

Figure 7 An illustration of the proof of Lemma 5.

Another subtlety about Lemma 5 is that the δ used in its premise is a priori unknown.
Hence, to apply the lemma in the liveness proof of PBFT-light, we have to argue that, if
correct processes keep changing views due to lack of progress, then all of them will eventually
increase their timeouts high enough to satisfy the bounds in Lemma 5. This is nontrivial due
to the fact that, as in the original PBFT [22, §2.3.5], in our protocol the processes update
their timeouts independently, and may thus disagree on their durations. For example, the
ﬁrst correct process pi to detect a problem with the current view v will increase its timeouts
and call advance (line 3). The synchronizer may then trigger new_view notiﬁcations at
other correct processes before they detect the problem as well, so that their timeouts will
stay unchanged (line 42). One may think that this allows executions in which only some
correct processes keep increasing their timeouts until they are high enough, whereas others
are forever stuck with timeouts that are too low, invalidating the premise of Lemma 5. The
following lemma rules out such scenarios and also trivially implies Lemma 5. It establishes
that, in a suﬃciently high view v with a correct leader, if the timeouts at a correct process
pi that enters v are high enough, then this process cannot be the ﬁrst one to initiate a
view change. Hence, for the protocol to enter another view, some other process with lower
timeouts must call advance and thus increase their durations (line 3).

(cid:73) Lemma 6. Let v ≥ V be such that Eﬁrst(v) ≥ GST and leader(v) is correct, and consider
a correct process pi that enters v. If dur_recoveryi(v) > 6δ and dur_deliveryi(v) > 4δ then pi
is not the ﬁrst correct process to call advance in v.

Proof. Since Eﬁrst(v) ≥ GST, messages sent by correct processes after Eﬁrst(v) get delivered
to all correct processes within δ and process clocks track real time. By contradiction, assume
that pi is the ﬁrst correct process to call advance in v. This happens because a timer expires
at pi. Here we only consider the case when it is timer_recovery, and handle timer_delivery
in §C.2. A process starts timer_recovery when it enters the view v (line 47), and hence, at
Eﬁrst(v) at the earliest (Figure 7). Because pi is the ﬁrst correct process to call advance in
v and dur_recoveryi(v) > 6δ, no correct process calls advance in v until after Eﬁrst(v) + 6δ.
Then by Bounded Entry all correct processes enter v by Eﬁrst(v) + 2δ. Also, by Validity no
correct process can enter v + 1 until after Eﬁrst(v) + 6δ, and by Proposition 1 the same holds
for any view > v. Thus, all correct processes stay in v at least until Eﬁrst(v) + 6δ.

When a correct process enters v, it sends a NEW_LEADER message to the leader of v, which
happens by Eﬁrst(v)+2δ. When the leader receives such messages from a quorum of processes,

leader(v)Elast(v)NEW_LEADER(v)NEW_LEADER(v)NEW_STATE(v)NEW_STATE(v)PREPARECOMMIT2𝛿𝛿𝛿𝛿𝛿pipjEfirst(v)start timer_recoverystop timer_recoveryM. Bravo, G. Chockler, and A. Gotsman

13

it broadcasts a NEW_STATE message. Thus, by Eﬁrst(v) + 4δ all correct processes receive this
message and set status = normal. If at that point init_log_length ≤ last_delivered at pi,
then the process stops timer_recovery (line 66), which contradicts our assumption. Hence,
init_log_length > last_delivered. When a correct process receives NEW_STATE, it sends PREPARE
messages for all positions ≤ init_log_length (line 62). It then takes the correct processes at
most 2δ to exchange the sequence of PREPARE and COMMIT messages that commits the values
at all positions ≤ init_log_length. Thus, by Eﬁrst(v) + 6δ the process pi commits and delivers
(cid:74)
all these positions, stopping timer_recovery (line 38): a contradiction.

(cid:73) Theorem 7. PBFT-light satisﬁes the Liveness property of Byzantine atomic broadcast.

Proof. Consider a valid value x broadcast by a correct process. We ﬁrst prove that x is
eventually delivered by some correct process. Assume the contrary. We show:

(cid:66) Claim 1. Every view is entered by some correct process.

Proof. Since all correct processes call start (line 1), by Startup a correct process eventually
enters some view. We now show that correct processes keep entering new views forever
(analogously to the proof of Proposition 2 in §3). Assume that this is false, so that there
exists a maximal view v entered by any correct process. Let P be any set of f + 1 correct
processes and consider an arbitrary process pi ∈ P that enters v. The process that broadcast
x is correct, and thus keeps broadcasting x until the value is delivered (line 11). Since x is
never delivered, pi is guaranteed to receive x while in v. Then by Lemma 4, pi eventually
calls advance while in v. Since pi was picked arbitrarily, we have ∀pi ∈ P. Ei(v)↓ =⇒ Ai(v)↓.
Then by Progress we get Eﬁrst(v + 1)↓, which yields a contradiction. Thus, correct processes
(cid:67)
keep entering views forever. The claim then follows from Proposition 1.

Let view v1 be the ﬁrst view such that v1 ≥ V and Eﬁrst(v1) ≥ GST; such a view exists
by Claim 1. The next claim is needed to show that all correct processes will increase their
timeouts high enough to satisfy the bounds in Lemma 5.

(cid:66) Claim 2. Every correct process calls the timer expiration handler (line 3) inﬁnitely often.

Proof. Assume the contrary and let Cﬁn and Cinf be the sets of correct processes that call
the timer expiration handler ﬁnitely and inﬁnitely often, respectively. Then Cﬁn 6= ∅, and
by Claim 1 and Validity, Cinf
6= ∅. The values of dur_delivery and dur_recovery increase
unboundedly at processes from Cinf , and do not change after some view v2 at processes from
Cﬁn. By Claim 1 and since leaders rotate round-robin, there is a view v3 ≥ max{v2, v1} with
a correct leader such that any process pi ∈ Cinf that enters v3 has dur_deliveryi(v3) > 4δ and
dur_recoveryi(v3) > 6δ. By Claim 1 and Validity, at least one correct process calls advance
in v3; let pl be the ﬁrst process to do so. Since v3 ≥ v2, pl cannot be in Cﬁn because none of
(cid:67)
these processes increase their timers in v3. Then pl ∈ Cinf , contradicting Lemma 6.

By Claims 1 and 2, there exists a view v4 ≥ v1 with a correct leader such that some correct
process enters v4, and for any correct process pi that enters v4 we have dur_deliveryi(v4) > 4δ
and dur_recoveryi(v4) > 6δ. By Lemma 5, no correct process calls advance in v4. Then, by
Validity, no correct process enters v4 + 1, which contradicts Claim 1. This contradiction
shows that x must be delivered by a correct process. Then, since the protocol reliably
broadcasts committed values (line 31), all correct processes will also eventually deliver x. (cid:74)

14

Liveness and Latency of Byzantine State-Machine Replication

6

Latency Bounds for PBFT

Assume that PBFT-light is used with our SMR synchronizer in Figure 3. We now quantify
its latency using the bounds for the synchronizer in Theorem 3, yielding the ﬁrst detailed
latency analysis for a PBFT-like protocol. Due to space constraints we defer proofs to §C.3.
To state our bounds, we assume the existence of a known upper bound ∆ on the maximum
value of δ in any execution [40, 49], so that we always have δ < ∆. In practice, ∆ provides
a conservative estimate of the message delay during synchronous periods, which may be
much higher than the maximal delay δ in a particular execution. We modify the protocol in
Figure 4 so that in lines 7-8 it does not increase dur_recovery and dur_delivery above 6∆ and
4∆, respectively. This corresponds to the bounds in Lemma 5 and preserves the protocol
liveness. Finally, we assume that periodic handlers (line 4 in Figure 3 and line 11 in Figure 4)
are executed every ρ time units, and that the latency of reliable broadcast in line 31 under
synchrony is ≤ δ + ρ (this corresponds to an implementation that just periodically retransmits
DECISION messages).

We quantify the latency of PBFT-light in both bad and good cases. For the bad case we
assume that the protocol starts during the asynchronous period. Given a value x broadcast
before GST, we quantify how quickly after GST all correct processes deliver x. For simplicity,
we assume that timeouts are high enough at GST and that leader(V) is correct.

(cid:73) Theorem 8. Assume that before GST all correct processes start executing the protocol and
one of them broadcasts x. Let V be deﬁned as in Theorem 3 and assume that leader(V) is
correct and at GST each correct process has dur_recovery > 6δ and dur_delivery > 4δ. Then
all correct processes deliver x by GST + ρ + max{ρ + δ, 6∆} + 4∆ + max{ρ, δ} + 7δ.

Although the latency bound looks complex, its main message is simple: PBFT-light
recovers after a period of asynchrony in bounded time. This time is dominated by multiples
of ∆; without the assumption that leader(V) is correct it would also be multiplied by f due
to going over up to f views with faulty leaders. In §C.3 we show the bound using the latency
guarantees of our synchronizer (Properties A and B in Theorem 3).

We now consider the case when the protocol starts during the synchronous period, i.e.,
after GST. The following theorem quantiﬁes how quickly all correct processes enter the ﬁrst
functional view, which in this case is view 1. If leader(1) is correct, it also quantiﬁes how
quickly a broadcast value x is delivered by all correct processes. The bound takes into account
the following optimization: in view 1 the processes do not need to exchange NEW_LEADER
messages. Then, after the systems starts up, the protocol delivers values within 4δ, which
matches an existing lower bound of 3δ for the delivery time starting from the leader [5].

(cid:73) Theorem 9. Assume that all correct processes start the protocol after GST with
dur_recovery > 5δ and dur_delivery > 4δ. Then the V deﬁned in Theorem 3 is equal to
1 and Elast(1) ≤ Tlast(0) + δ. Furthermore, if a correct process broadcasts x at t ≥ GST and
leader(1) is correct, then all correct processes deliver x by max{t, Tlast(0) + δ} + 4δ.

7

Additional Case Studies

To demonstrate the generality of SMR synchronizers, we have also used it to ensure the
liveness of two other protocols. First, we handle a variant of PBFT that periodically forces a
leader change, as is common in modern Byzantine SMR [27, 54, 55]. In this protocol a process
calls advance not only when it suspects the current leader to be faulty, but also when it
delivers B values proposed by this leader (for a ﬁxed B). Second, we have applied the SMR

M. Bravo, G. Chockler, and A. Gotsman

15

synchronizer to a variant of the above protocol that follows the approach of HotStuﬀ [56].
The resulting protocol adds an extra communication step to the normal path of PBFT
in exchange for reducing the communication complexity of leader change. Due to space
constraints, we defer the details about these two protocols to §D and §E. Their liveness proofs
follow the methodology we proposed for PBFT-light, establishing analogs of Lemmas 4-6.

For PBFT with periodic leader rotation we have also established latency bounds when
using the synchronizer in Figure 3 (see §D). The most interesting one (Theorem 56) demon-
strates the beneﬁt of PBFT’s mechanism for adapting timeouts to an unknown δ: recall that
in PBFT a process only increases its timeouts when a timer expires, which means that the
current view does not operate normally (§4). We show that, since the protocol does not
increase its timeouts in good views (with correct leaders and under synchrony), it pays a
minimal latency penalty to recover the ﬁrst time it encounters a bad leader – the initial
value of dur_recovery. This contrasts with the simplistic way of adapting the timeouts to an
unknown δ by increasing them in every view: in this case, as the protocol keeps changing
views, the timeouts would eventually increase up to the maximum (determined by ∆), and
the protocol would have to wait that much to recover from a faulty leader.

8

Related Work and Discussion

Failure detectors. Failure detectors and leader oracles [25, 33] have been widely used for
implementing consensus and SMR under benign failures [37,38,46], but their implementations
under Byzantine failures are either impractical [42] or detect only restricted failure types [29,39,
45]. Another approach was proposed in a textbook by Cachin et al. [19]. This relies on a leader-
based Byzantine Epoch-Change (BEC) abstraction, which accepts “complain” hints from the
application suggesting that the trust in the current leader should be revoked. However, like
the classical leader oracles, BEC requires all correct processes to eventually trust the same
correct leader, which is impossible to achieve in Byzantine settings. In fact, the BEC-based
Byzantine consensus algorithm in §5.6.4 of [19] suﬀers from a liveness bug, which we describe
in §F. The bug has been conﬁrmed with one of the textbook’s authors [18].

Although our advance is similar to “complain”, we use it to implement a weaker abstrac-
tion of an SMR synchronizer. We then obtain properties similar to accuracy and completeness
of failure detectors by carefully combining SMR-level timers with uses of advance (Lem-
mas 4-5). Also, while [19] does not specify constraints on the use of “complain” (see §F), we
give a complete characterization of advance and show its suﬃciency for solving SMR.

BFT-SMaRt [13, 53] built on the ideas of [19] to propose an abstraction of validated and
provable (VP) consensus, which allows its clients to control leader changes. Although the
overall BFT-SMaRt protocol appears to be correct, its liveness proof sketch suﬀers from
issues with rigor similar to those of [19]. In particular, the conditions on how to change the
leader in VP-Consensus to ensure its liveness were underspeciﬁed (again, see §F).

Emulating synchrony. Alternative abstractions avoid dependency on the speciﬁcs of a
failure model by simulating synchrony [14, 26, 34, 41]. The ﬁrst such abstraction is due
to Awerbuch [10] who proposed a family of synchronizer algorithms emulating a round-
based synchronous system of top of an asynchronous network with reliable communication
and processes. The ﬁrst such emulation in a failure-prone partially synchronous system
It relied on an expensive clock synchronization
was introduced in the DLS paper [31].
protocol, which interleaved its messages with every step of a high-level consensus algorithm
implemented on top of it. Later work proposed more practical solutions, which reduce
the synchronization frequency by relying on either timers [30] or synchronized hardware

16

Liveness and Latency of Byzantine State-Machine Replication

clocks [3, 7, 35] (the latter can be obtained using one of the existing fault-tolerant clock
synchronization algorithms [28,52]). However, the DLS model emulates communication-closed
rounds, i.e., eventually, a process in a round r receives all messages sent by correct processes
in r. This property rules out optimistically responsive [50, 56] protocols such as PBFT, which
can make progress as soon as they receive messages from any quorum.

Consensus synchronizers. To address the shortcoming of DLS rounds, recent work proposed
a more ﬂexible abstraction (“consensus synchronizer” in §3) that switches processes through
an inﬁnite series of views [16, 48, 56]. In contrast to rounds, each view may subsume multiple
communication steps. Although consensus synchronizers can be used for eﬃcient single-shot
Byzantine consensus [16], using them for SMR results in suboptimal implementations. A
classical approach is to decide on each SMR command using a separate black-box consensus
instance [51]. However, implementing the latter using a consensus synchronizer would force
the processes in every instance to iterate over the same sequence of potentially bad views
until the one with a correct leader and suﬃciently long duration could be reached.

An alternative approach was proposed in HotStuﬀ [56]. This SMR protocol is driven by
a pacemaker, which keeps generating views similarly to a consensus synchronizer. Within
each view HotStuﬀ runs a voting protocol that commits a block of client commands in a
growing hash chain. Although the voting protocol is optimistically responsive, committing
the next block is delayed until the pacemaker generates a new view, which increases latency.
The cost the pacemaker may incur to generate a view is also paid for every single block.

SMR synchronizers.
In contrast to the above approaches, SMR synchronizers allow the
application to initiate view changes on demand via an advance call. As we show, this aﬀords
SMR protocols the ﬂexibility to judiciously manage their view synchronization schedule: in
particular, it prevents the timeouts from growing unnecessarily (§7) and avoids the overheads
of further view synchronizations once a stable view is reached (Lemma 5, §5).

The ﬁrst synchronizer with a new_view/advance interface, which here we call an SMR
synchronizer, was proposed by Naor et al. [47, 48]. They used it as an intermediate module in
a communication-eﬃcient implementation of a consensus synchronizer. The latter is suﬃcient
to ensure the liveness of HotStuﬀ [56] via either of the two straightforward SMR constructions
we described above. The speciﬁcation of the new_view/advance module of Naor et al. was
only used as a stepping stone in the proof of their consensus synchronizer, and as a result, is
more low-level and complex than our SMR synchronizer speciﬁcation. Naor et al. did not
investigate the usability of the SMR synchronizer abstraction as a generic building block
applicable to a wide range of Byzantine SMR protocols – a gap we ﬁll in this paper. Finally,
they only handled a simpliﬁed version of partial synchrony where messages are never lost and
δ is known a priori, whereas our SMR synchronizer implementation handles partial synchrony
in its full generality. This implementation builds on the consensus synchronizer of Bravo et
al. [16]. However, its correctness proof and performance analysis are more intricate, since
the timing of the view switches is not ﬁxed a priori, but driven by external advance inputs.
Aştefănoaei et al. [6] proposed another framework for implementing Byzantine SMR
protocols, based on DLS rounds. This uses a simple synchronizer that does not exchange
any messages: it recovers from a period of asynchrony by progressively increasing round
durations until they are long enough for all correct processes to overlap in the same round.
This way of view synchronization rules out optimistically responsive SMR protocols and does
not bound the time to reach a decision after GST, as we do.

SMR liveness proofs. PBFT [22–24] is a seminal protocol whose design choices have been
widely adopted [36, 43, 54, 55]. To the best of our knowledge, our proof in §5 is the ﬁrst one

M. Bravo, G. Chockler, and A. Gotsman

17

to formally establish its liveness. An informal argument given in [24, §4.5.1] mainly justiﬁes
liveness assuming all correct processes enter a view with a correct leader and stay in that
view for suﬃciently long. It does not rigorously justify why such a view will be eventually
reached, and in particular, how this is ensured by the interplay between SMR-level timeout
management and view synchronization (§5). Liveness mechanisms were also omitted from
the formal speciﬁcation of PBFT by an I/O-automaton [22, 24].

Bravo et al. [16] have applied consensus synchronizers to several consensus protocols,
including a single-shot version of PBFT. These protocols and their proofs and are much
more straightforward than the full SMR protocols we consider here. In particular, since a
consensus synchronizer keeps switching processes between views regardless of whether their
leaders are correct, the proof of the single-shot PBFT in [16] does not need to establish
analogs of completeness and accuracy (Lemmas 4 and 5) or deal with the fact that processes
may disagree on timeout durations (Lemma 6).

Byzantine SMR protocols often integrate view synchronization into the core protocol,
enabling white-box optimizations [1, 9, 17, 23]. Our work does not rule out this approach, but
allows making it more systematic: we can ﬁrst develop eﬃcient mechanisms for view syn-
chronization independently from SMR protocols, and do white-box optimizations afterwards.

References

1 DiemBFT v4: State machine replication in the Diem blockchain.

https://developers.diem.com/papers/diem-consensus-state-machine-replication-in-the-diem-
blockchain/2021-08-17.pdf.

2

3

4

5

6

Incorrect by construction-CBC Casper isn’t live.
https://derekhsorensen.com/docs/CBC_Casper_Flaw.pdf.

Ittai Abraham, Srinivas Devadas, Danny Dolev, Kartik Nayak, and Ling Ren. Synchronous
Byzantine agreement with expected O(1) rounds, expected O(n2) communication, and optimal
resilience. In Conference on Financial Cryptography and Data Security (FC), 2019.

Ittai Abraham, Guy Gueta, Dahlia Malkhi, Lorenzo Alvisi, Ramakrishna Kotla, and Jean-
Philippe Martin. Revisiting fast practical Byzantine fault tolerance. arXiv, abs/1712.01367,
2017.

Ittai Abraham, Kartik Nayak, Ling Ren, and Zhuolun Xiang. Good-case latency of Byzantine
broadcast: a complete categorization. In Symposium on Principles of Distributed Computing
(PODC), 2021.

Lăcrămioara Aştefănoaei, Pierre Chambart, Antonella Del Pozzo, Thibault Rieutord, Sara
Tucci-Piergiovanni, and Eugen Zălinescu. Tenderbake - a solution to dynamic repeated
consensus for blockchains. In Symposium on Foundations and Applications of Blockchain
(FAB), 2021.

7 Dan Alistarh, Seth Gilbert, Rachid Guerraoui, and Corentin Travers. Generating fast indulgent
algorithms. In International Conference on Distributed Computing and Networking (ICDCN),
2011.

8 Yackolley Amoussou-Guenou, Antonella Del Pozzo, Maria Potop-Butucaru, and Sara Tucci-
Piergiovanni. Correctness of Tendermint-core blockchains. In Conference on Principles of
Distributed Systems (OPODIS), 2018.

9 Yackolley Amoussou-Guenou, Antonella Del Pozzo, Maria Potop-Butucaru, and Sara Tucci-
Piergiovanni. Dissecting Tendermint. In Conference on Networked Systems (NETYS), 2019.

10

Baruch Awerbuch. Complexity of network synchronization. J. ACM, 32(4):804–823, 1985.

11 Rida A. Bazzi and Yin Ding. Non-skipping timestamps for Byzantine data storage systems.

In Symposium on Distributed Computing (DISC), 2004.

18

Liveness and Latency of Byzantine State-Machine Replication

12 Christian Berger, Hans P. Reiser, and Alysson Bessani. Making reads in BFT state machine
replication fast, linearizable, and live. In Symposium on Reliable Distributed Systems (SRDS),
2021.

13 Alysson Neves Bessani, João Sousa, and Eduardo Adílio Pelinson Alchieri. State machine
replication for the masses with BFT-SMART. In Conference on Dependable Systems and
Networks (DSN), 2014.

14 Martin Biely, Josef Widder, Bernadette Charron-Bost, Antoine Gaillard, Martin Hutle, and
André Schiper. Tolerating corrupted communication. In Symposium on Principles of Distributed
Computing (PODC), 2007.

15 Gabriel Bracha. Asynchronous Byzantine agreement protocols. Inf. Comput., 75(2):130–143,

1987.

16 Manuel Bravo, Gregory Chockler, and Alexey Gotsman. Making Byzantine consensus live. In

17

Symposium on Distributed Computing (DISC), 2020.
Ethan Buchman, Jae Kwon, and Zarko Milosevic. The latest gossip on BFT consensus. arXiv,
abs/1807.04938, 2018.

18 Christian Cachin. Personal communication. 2022.
19 Christian Cachin, Rachid Guerraoui, and Luís E. T. Rodrigues. Introduction to Reliable and

Secure Distributed Programming (2 ed.). Springer, 2011.

20 Christian Cachin, Klaus Kursawe, Frank Petzold, and Victor Shoup. Secure and eﬃcient
asynchronous broadcast protocols. In International Cryptology Conference (CRYPTO), 2001.
21 Christian Cachin and Marko Vukolić. Blockchain consensus protocols in the wild (keynote

talk). In Symposium on Distributed Computing (DISC), 2017.

22 Miguel Castro. Practical Byzantine Fault Tolerance. PhD thesis, Massachusetts Institute of

Technology, 2001.

23 Miguel Castro and Barbara Liskov. Practical Byzantine fault tolerance. In Symposium on

Operating Systems Design and Implementation (OSDI), 1999.

24 Miguel Castro and Barbara Liskov. Practical Byzantine fault tolerance and proactive recovery.

ACM Transactions on Computer Systems, 20(4):398–461, 2002.

25 Tushar Deepak Chandra and Sam Toueg. Unreliable failure detectors for reliable distributed

26

systems. J. ACM, 43(2):225–267, 1996.
Bernadette Charron-Bost and André Schiper. The Heard-Of model: computing in distributed
systems with benign faults. Distributed Comput., 22(1):49–71, 2009.

27 Allen Clement, Edmund Wong, Lorenzo Alvisi, Mike Dahlin, and Mirco Marchetti. Making
In Symposium on Networked

Byzantine fault tolerant systems tolerate Byzantine faults.
Systems Design and Implementation (NSDI), 2009.

28 Danny Dolev, Joseph Y. Halpern, Barbara Simons, and Ray Strong. Dynamic fault-tolerant

clock synchronization. J. ACM, 42(1):143–185, 1995.

29 Assia Doudou, Benoît Garbinato, and Rachid Guerraoui. Abstractions for devising Byzantine-
resilient state machine replication. In Symposium on Reliable Distributed Systems (SRDS),
2000.

30 Cezara Dragoi, Josef Widder, and Damien Zuﬀerey. Programming at the edge of synchrony.

Proc. ACM Program. Lang., 4(OOPSLA), 2020.

31 Cynthia Dwork, Nancy A. Lynch, and Larry J. Stockmeyer. Consensus in the presence of

partial synchrony. J. ACM, 35(2):288–323, 1988.

32 Michael J. Fischer, Nancy A. Lynch, and Mike Paterson. Impossibility of distributed consensus

33

34

35

with one faulty process. J. ACM, 32(2):374–382, 1985.
Felix C. Freiling, Rachid Guerraoui, and Petr Kuznetsov. The failure detector abstraction.
ACM Comput. Surv., 43(2):9:1–9:40, 2011.
Eli Gafni. Round-by-round fault detectors: Unifying synchrony and asynchrony. In Symposium
on Principles of Distributed Computing (PODC), 1998.
Seth Gilbert, Rachid Guerraoui, and Dariusz R. Kowalski. On the message complexity of
indulgent consensus. In Symposium on Distributed Computing (DISC), 2007.

M. Bravo, G. Chockler, and A. Gotsman

19

36 Guy Golan-Gueta, Ittai Abraham, Shelly Grossman, Dahlia Malkhi, Benny Pinkas, Michael K.
Reiter, Dragos-Adrian Seredinschi, Orr Tamir, and Alin Tomescu. SBFT: A scalable and
decentralized trust infrastructure. In Conference on Dependable Systems and Networks (DSN),
2019.

37 Rachid Guerraoui. Indulgent algorithms (preliminary version). In Symposium on Principles

of Distributed Computing (PODC), 2000.

38 Rachid Guerraoui and Michel Raynal. The information structure of indulgent consensus. IEEE

Transactions on Computers, 53(4):453–466, 2004.

39 Andreas Haeberlen and Petr Kuznetsov. The fault detection problem. In Conference on

Principles of Distributed Systems (OPODIS), 2009.

40 Amir Herzberg and Shay Kutten. Fast isolation of arbitrary forwarding faults. In Symposium

41

on Principles of Distributed Computing (PODC), 1989.
Idit Keidar and Alexander Shraer. Timeliness, failure-detectors, and consensus performance.
In Symposium on Principles of Distributed Computing (PODC), 2006.

42 Kim Potter Kihlstrom, Louise E. Moser, and P. M. Melliar-Smith. Byzantine fault detectors

for solving consensus. The Computer Journal, 46(1):16–35, 2003.

43 Ramakrishna Kotla, Lorenzo Alvisi, Mike Dahlin, Allen Clement, and Edmund Wong. Zyzzyva:
Speculative Byzantine fault tolerance. ACM Trans. Comput. Syst., 27(4):7:1–7:39, 2010.
44
Leslie Lamport. The part-time parliament. ACM Trans. Comput. Syst., 16(2):133–169, 1998.
45 Dahlia Malkhi and Michael Reiter. Unreliable intrusion detection in distributed computations.

In Workshop on Computer Security Foundations (CSFW), 1997.

46 Achour Mostéfaoui and Michel Raynal. Solving consensus using Chandra-Toueg’s unreliable
failure detectors: A general quorum-based approach. In Symposium on Distributed Computing
(DISC), 1999.

47 Oded Naor, Mathieu Baudet, Dahlia Malkhi, and Alexander Spiegelman. Cogsworth: Byzantine

view synchronization. In Cryptoeconomics Systems Conference (CES), 2020.

48 Oded Naor and Idit Keidar. Expected linear round synchronization: The missing link for

linear Byzantine SMR. In Symposium on Distributed Computing (DISC), 2020.

49 Rafael Pass and Elaine Shi. Hybrid consensus: Eﬃcient consensus in the permissionless model.

In Symposium on Distributed Computing (DISC), 2017.

51

50 Rafael Pass and Elaine Shi. Thunderella: Blockchains with optimistic instant conﬁrmation.
In Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT),
2018.
Fred B. Schneider. Implementing fault-tolerant services using the state machine approach: A
tutorial. ACM Comput. Surv., 22(4):299–319, 1990.
Barbara Simons, Jennifer Welch, and Nancy Lynch. An overview of clock synchronization. In
Fault-Tolerant Distributed Computing, 1986.
João Sousa. Byzantine State Machine Replication for the Masses. PhD thesis, University of
Lisbon, 2017.

52

53

54 Chrysoula Stathakopoulou, Tudor David, and Marko Vukolić. Mir-BFT: High-throughput

BFT for blockchains. arXiv, abs/1906.05552, 2019.

55 Giuliana Santos Veronese, Miguel Correia, Alysson Neves Bessani, and Lau Cheuk Lung. Spin
one’s wheels? Byzantine fault tolerance with a spinning primary. In Symposium on Reliable
Distributed Systems (SRDS), 2009.

56 Maofan Yin, Dahlia Malkhi, Michael K. Reiter, Guy Golan-Gueta, and Ittai Abraham. HotStuﬀ:
BFT consensus with linearity and responsiveness. In Symposium on Principles of Distributed
Computing (PODC), 2019.

20

Liveness and Latency of Byzantine State-Machine Replication

A

Constructing a Consensus Synchronizer from an SMR Synchronizer

1 function start()
2

advance();

3 upon new_view(v)
4

stop_timer(timer_view);
start_timer(timer_view, F (v));
trigger new_consensus_view(v);

5

6

7 when timer_view expires
8

advance();

Figure 8 A consensus synchronizer from an SMR synchronizer.

I. ∀i, v, v0. Ei(v)↓ ∧ Ei(v0)↓ =⇒ (v < v0 ⇐⇒ Ei(v) < Ei(v0))
II. Eﬁrst(V) ≥ GST
III. ∀i. ∀v ≥ V. pi ∈ C =⇒ Ei(v)↓
IV. ∀v ≥ V. Elast(v) ≤ Eﬁrst(v) + d
V. ∀v ≥ V. Eﬁrst(v + 1) > Eﬁrst(v) + F (v)

Figure 9 Consensus synchronizer speciﬁcation [16], holding for some V ∈ View.

A consensus synchronizer produces a stream of notiﬁcations new_consensus_view(v) at
each correct process, telling it to enter a view v. A process can ensure that the synchronizer
has started operating by calling a special start() function. We assume that each correct
process eventually calls start(), unless it gets a new_consensus_view notiﬁcation ﬁrst. For
a consensus protocol to terminate, its processes need to stay in the same view for long enough
to complete the message exchange leading to a decision. Since the message delay δ after GST
is unknown to the protocol, we need to increase the view duration until it is long enough
for the protocol to terminate. To this end, the synchronizer is parameterized by a function
deﬁning this duration – F : View ∪ {0} → Time, which is monotone, satisﬁes F (0) = 0, and
increases unboundedly:

∀θ. ∃v. ∀v0. v0 ≥ v =⇒ F (v0) > θ.

(1)

Figure 8 shows how we can construct a consensus synchronizer from an SMR synchronizer.
Upon a start() call, the consensus synchronizer just tells the underlying SMR synchronizer
to advance (line 1). When the SMR synchronizer tells the process to enter a view v (line 3),
the consensus synchronizer produces the corresponding new_consensus_view(v) notiﬁcation.
It also sets a timer timer_view for the duration F (v). When the timer expires (line 7), the
consensus synchronizer tells the SMR synchronizer to advance.

Figure 9 presents the speciﬁcation of a consensus synchronizer proposed in [16]. This
relies on the following notation, analogous to the one used for SMR synchronizers. Given
a view v for which a correct process pi received a new_consensus_view(v) notiﬁcation, we
denote by Ei(v) the time when this happens; we let Eﬁrst(v) and Elast(v) denote respectively
the earliest and the latest time when some correct process receives a new_consensus_view(v)
notiﬁcation. Like an SMR synchronizer, a consensus synchronizer must guarantee that
views only increase at a given process (Property I). A consensus synchronizer ensures view
synchronization only starting from some view V, entered after GST (Property II). Starting

M. Bravo, G. Chockler, and A. Gotsman

21

from V, correct processes do not skip any views (Property III), enter each view v ≥ V within
at most d of each other (Property IV) and stay there for a determined amount of time: until
F (v) after the ﬁrst process enters v (Property V). We next prove the following theorem,
showing that the consensus synchronizer in Figure 8 satisﬁes these properties.

(cid:73) Theorem 10. The consensus synchronizer in Figure 8 satisﬁes Properties I-V in Figure 9,
provided the SMR synchronizer it uses satisﬁes the properties in Figure 1.

The implementation in Figure 8 ensures the following proposition, which we tacitly use

in our proof.

(cid:73) Proposition 11. ∀i, v. Ei(v) = Ei(v).

(cid:73) Proposition 12. ∀v. ∃v0. v0 > v ∧ Eﬁrst(v0)↓.

Proof. Analogous to Proposition 2.

(cid:74)

(cid:73) Lemma 13. If a correct process enters a view v > 0 and Eﬁrst(v) ≥ GST, then for all
v0 > v, no correct process attempts to advance from v0 − 1 before Eﬁrst(v) + F (v).

Proof. Suppose by contradiction that there exists a time t0 < Eﬁrst(v) + F (v) and a correct
process pi such that pi attempts to advance from v0 − 1 > v − 1 at t0. Since v0 ≥ v + 1 > 1,
at t0 the process pi executes the handler at line 7 and the last view it entered is v0 − 1. Since
pi.timer_view is not enabled at t0, pi must have entered v0 − 1 at least F (v) before t0 according
to its local clock. Since v0 − 1 ≥ v, by Proposition 1, we have Eﬁrst(v0 − 1) ≥ Eﬁrst(v) ≥ GST.
Therefore, given that the clocks of all correct processes progress at the same rate as real time
after GST, we get

Eﬁrst(v) ≤ Eﬁrst(v0 − 1) ≤ t0 − F (v0 − 1).

Hence,

t0 ≥ Eﬁrst(v) + F (v0 − 1).

Since F is non-decreasing and v0 − 1 ≥ v, we have F (v0 − 1) ≥ F (v), so that

t0 ≥ Eﬁrst(v) + F (v),

which contradicts our assumption that t0 < Eﬁrst(v) + F (v). This contradiction shows the
(cid:74)
required.

Proof of Theorem 10. Property I follows from Monotonicity of the SMR synchronizer. Let
V be the view from Bounded Entry and let V 0 be the minimal view such that V 0 ≥ V,
Eﬁrst(V 0) ≥ GST and F (V 0) ≥ 2δ. Such a view exists by (1) and Proposition 12. Then
Property II holds for V = V 0. By Propositions 1 and 12, a correct process enters every view
v ≥ V 0. By Proposition 1, v ≥ V 0 implies

Eﬁrst(v) ≥ Eﬁrst(V 0) ≥ GST.

(2)

Since F is a non-decreasing function, F (v) ≥ 2δ. Thus, by Lemma 13 and Bounded Entry, all
correct processes enter v, and Elast(v) ≤ Eﬁrst(v) + 2δ, which validates Properties III and IV
for V = V 0. To prove Property V, ﬁx a view v ≥ V 0. Since a correct process enters view
v + 1, by Validity, there exist a time t < Eﬁrst(v + 1) at which some correct process attempts
to advance from v. By (2), Eﬁrst(v) ≥ GST. Then by Lemma 13 we get t ≥ Eﬁrst(v) + F (v),
(cid:74)
so that Eﬁrst(v + 1) > t ≥ Eﬁrst(v) + F (v), as required.

22

Liveness and Latency of Byzantine State-Machine Replication

B

Correctness and Performance of the Synchronizer Algorithm

B.1 Proof of the Synchronizer Correctness

The local view of a process pi at time t, denoted LVi(t), is the latest view entered by pi at or
before t, or 0 if pi has not entered any views by then.

(cid:73) Lemma 14. For all t and v ≥ 0, if a correct process sends WISH(v + 1) at t, then there
exists a time t0 ≤ t such that some correct process attempts to advance from v at t0.

Proof. We ﬁrst prove the following auxiliary proposition:

∀pi. ∀v. pi is correct ∧ pi sends WISH(v + 1) at t =⇒

∃t0 ≤ t. ∃v0 ≥ v. ∃pj. pj is correct ∧ pj attempts to advance from v0 at t0.

(3)

By contradiction, assume that a correct process pi sends WISH(v + 1) at t, but for all t0 ≤ t
and all v0 ≥ v, no correct process attempts to advance from v0 at t0. Consider the earliest
time tk when some correct process pk sends a WISH(vk) with vk ≥ v + 1, so that tk ≤ t.

Since pk sends WISH(vk) at tk, either vk = pk.view+(tk) or pk.view(tk) = pk.view+(tk) =
vk − 1, and in the latter case pk executes either line 2 or line 6. If pk.view+(tk) = vk ≥ v + 1,
then pk.max_views(tk) includes f +1 entries ≥ vk ≥ v +1, and therefore, there exists a correct
process pl that sent WISH(v0) with v0 ≥ v + 1 at tl < tk, contradicting the assumption that tk
is the earliest time when this can happen. Suppose that pk.view(tk) = pk.view+(tk) = vk − 1
and at tk, pk executes either line 2 or line 6. Then LVk(tk) = vk − 1. If pk executes line 2
at tk, then since LVk(tk) = vk − 1, pk attempts to advance from vk − 1 ≥ v at tk ≤ t,
contradicting our assumption that no such attempt can occur. Suppose now that pk executes
the code in line 6 at tk. If vk > 1, then since pk.view(tk) = pk.view+(tk) = vk − 1, we know
that Ek(vk − 1) is deﬁned and satisﬁes Ek(vk − 1) < tk. Let t0
k = Ek(vk − 1) if vk > 1, and
k) = false.
t0
k = 0 otherwise. Then pk.view(t0
Since pk.advanced(tk) = true, there exists a time t00
k ≤ tk and pk calls
k. Since both pk.view and pk.view+ are non-decreasing, and both are equal
advance() at t00
to vk − 1 at t00
k as well as tk, pk.view(t00
k) = vk − 1,
which implies that at t00
k < tk ≤ t, pk attempts to advance from vk − 1 ≥ v, contradicting our
assumption that no such attempt can happen. Thus, (3) holds.

k) = vk − 1 and pk.advanced(t0

k) = vk − 1. Thus, LVk(t00

k) = pk.view+(t00

k) = pk.view+(t0

k such that t0

k < t00

We now prove the lemma. Let t and v be such that some correct process sends WISH(v + 1)
at t. By (3), there exists a correct process that attempts to advance from a view ≥ v at or
before t. Let t0 be the earliest time when some correct process attempts to advance from
a view ≥ v, and let pj be this process and v0 ≥ v be the view from which pj attempts to
advance at t0. Thus, at t0, pj executes the code in line 2 and LVj(t0) = v0 ≥ v. Hence, there
exists an earlier time at which pj.view+ = pj.view = v0. Since pj.view+ is non-decreasing,
pj.view+(t0) ≥ v0. If pj.view+(t0) > v0, then given that v0 ≥ v, pj.view+(t0) ≥ v + 1. Thus,
there exists a correct process pk and time t00 < t0 such that pk sent WISH(v00) with v00 ≥ v + 1
to pj at t00. By (3), there exists a time ≤ t00 < t0 at which some correct process attempts
to advance from a view ≥ v00 − 1 ≥ v, which is impossible. Thus, pj.view+(t0) = v0. Since
LVj(t0) = v0, we have pj.view(t0) = pj.view+(t0) = v0 ≥ v. By the deﬁnitions of view and
view+, v0 is both the lowest view among the highest 2f + 1 views in pj.max_views(t0), and
the lowest view among the highest f + 1 views in pj.max_views(t0). Hence, pj.max_views(t0)
includes f + 1 entries equal to v0, and therefore, there exists a correct process pk such that

pj.view(t0) = pj.view+(t0) = pj.max_views[k](t0) = v0 ≥ v − 1.

(4)

M. Bravo, G. Chockler, and A. Gotsman

23

Also, for all correct processes pl, pj.max_views[l](t0) < v + 1: otherwise, some correct process
sent WISH(v00) with v00 ≥ v + 1 at t00 < t0, and therefore, by (3), some correct process
attempted to advance from a view ≥ v earlier than t0, which is impossible. Thus,

pj.view(t0) = pj.view+(t0) = pj.max_views[k](t0) < v + 1.

Together with (4), this implies

pj.view(t0) = pj.view+(t0) = v.

Hence, LVj(t0) = v, and therefore, pj attempts to advance from v at t0. Thus, v0 = v and
(cid:74)
t0 ≤ t, as required.

(cid:73) Lemma 15. Validity holds: ∀i, v. Ei(v + 1)↓ =⇒ Aﬁrst(v)↓ ∧ Aﬁrst(v) < Ei(v + 1).
Proof. Since pi enters a view v + 1, we have pi.view(Ei(v + 1)) = pi.view+(Ei(v + 1)) = v + 1.
By the deﬁnitions of view and view+, v + 1 is both the lowest view among the highest 2f + 1
views in pi.max_views(Ei(v + 1)), and the lowest view among the highest f + 1 views in
pi.max_views(Ei(v + 1)). Hence, pi.max_views(Ei(v + 1)) includes f + 1 entries equal to v + 1.
Then there exists a time t0 < Ei(v + 1) at which some correct process sends WISH(v + 1).
Hence, by Lemma 14, there exists a time t ≤ t0 < Ei(v + 1) at which some correct process
(cid:74)
attempts to advance from v.

(cid:73) Lemma 16. For all times t and views v > 0, if a correct process sends WISH(v) at t, then
there exists a time t0 ≤ t such that some correct process attempts to advance from view 0 at
t0.

Proof. Consider the earliest time tk ≤ t at which some correct process pk sends WISH(vk)
for some view vk. By Lemma 14, there exists a time tj ≤ tk at which some correct process
attempts to advance from vk − 1 ≥ 0, and therefore, sends WISH(vk) at tj. Since tk is the
earliest time when this could happen, we have tj = tk. Also, if vk − 1 > 0, then Ek(vk − 1)
is deﬁned, and hence, by Lemma 15, some correct process attempts to advance from vk − 2
by sending WISH(vk − 1) earlier than tj = tk, which cannot happen. Thus, vk = 1 and at tk,
(cid:74)
pk attempts to advance from 0, as required.

(cid:73) Proposition 17. Let pi be a correct process. Then:
1. ∀v.∀t. pi sends WISH(v) at t =⇒ v ∈ {pi.view+(t), pi.view+(t) + 1}.
2. ∀v.∀t. pi sends WISH(v) at t ∧ v = pi.view+(t) + 1 =⇒
pi.view+(t) = pi.view(t) ∧ pi.advanced(t) = true.

(cid:73) Lemma 18. For all views v, v0 > 0, if a correct process sends WISH(v) before sending
WISH(v0), then v ≤ v0.

Proof. Let s and s0 such that s < s0 be the times at which a correct process pi sends
WISH(v) and WISH(v0) messages, respectively. We show that v0 ≥ v. By Proposition 17(1),
v ∈ {pi.view+(s), pi.view+(s) + 1} and v0 ∈ {pi.view+(s0), pi.view+(s0) + 1}. Hence, if v =
pi.view+(s) or v0 = pi.view+(s0) + 1, then we get v ≤ v0 from the fact that pi.view+ is non-
decreasing. It thus remains to consider the case when v = pi.view+(s)+1 and v0 = pi.view+(s0).
In this case by Proposition 17(2), pi.view+(s) = pi.view(s) and pi.advanced(s) = true. We
now consider several cases depending on the line at which WISH(v0) is sent.

WISH(v0) is sent at lines 2 or 6. Then v0 = pi.view+(s0) = max(pi.view(s0)+1, pi.view+(s0)).
Since pi.view is non-decreasing, we get pi.view+(s0) ≥ pi.view(s0) + 1 > pi.view(s0) ≥
pi.view(s) = pi.view+(s). Hence, pi.view+(s0) > pi.view+(s), and therefore, v0 =
pi.view+(s0) ≥ pi.view+(s) + 1 = v, as required.

24

Liveness and Latency of Byzantine State-Machine Replication

WISH(v0) is sent at line 8. Then pi.advanced(s0) = false. Since pi.advanced(s) = true,
there exists a time s00 such that s < s00 < s0 and pi enters a view at s00. By the view
entry condition pi.view(s00) > pi.prev_v(s00). Since pi.view is non-decreasing, we get
pi.view+(s0) ≥ pi.view(s0) ≥ pi.view(s00) > pi.view(s) = pi.view+(s). Thus, pi.view+(s0) >
pi.view+(s) and therefore, v0 = pi.view+(s0) ≥ pi.view+(s) + 1 = v, as required.
WISH(v0) is sent at line 18. Then pi.view+(s0) > pi.prev_v+(s0) ≥ pi.view+(s), and
therefore, v0 = pi.view+(s0) ≥ pi.view+(s) + 1 = v, as required.

(cid:74)

In order to cope with message loss before GST, every correct process retransmits the
highest WISH it sent every ρ time units, according to its local clock (lines 4-8). Eventually,
one of these retransmissions will occur after GST, and therefore, there exists a time by which
all correct processes are guaranteed to send their highest WISHes at least once after GST.
The earliest such time, GST, is deﬁned as follows:

(

GST =

GST + ρ,

Aﬁrst(0),

if Aﬁrst(0) < GST;
otherwise.

From this deﬁnition it follows that

GST ≥ GST.

(5)

Lemma 19 below formalizes the key property of GST.

(cid:73) Lemma 19. For all correct processes pi, times t ≥ GST, and views v, if pi sends WISH(v)
at a time ≤ t, then there exists a view v0 ≥ v and a time t0 such that GST ≤ t0 ≤ t and pi
sends WISH(v0) at t0.

Proof. Let s ≤ t be the time at which pi sends WISH(v). We consider two cases. Suppose
ﬁrst that Aﬁrst(0) ≥ GST. By Lemma 16, s ≥ Aﬁrst(0), and therefore, GST ≤ s ≤ t. Thus,
choosing t0 = s and v0 = v validates the lemma. Suppose next that Aﬁrst(0) < GST. Then by
the deﬁnition of GST, t ≥ GST + ρ. If s ≥ GST, then GST ≤ s ≤ t, and therefore, choosing
t0 = s and v0 = v validates the lemma. Assume now that s < GST. Since after GST the
pi’s local clock advances at the same rate as real time, there exists a time s0 satisfying
GST ≤ s0 ≤ t such that pi executes the periodic retransmission code in lines 4-8 at s0. We
now show that

pi.advanced(s0) ∨ pi.view+(s0) > 0.

(6)

Since pi already sent a WISH message at s < GST ≤ s0, by the structure of the code,

pi.advanced(s) ∨ pi.view+(s) > 0.

If pi.view+(s) > 0, then since pi.view+ is non-decreasing, pi.view+(s0) > 0, and therefore, (6)
holds. Assume now that pi.advanced(s). If pi.advanced(s0), then (6) holds too. We therefore
consider the case when ¬pi.advanced(s0). Then there exists a time s ≤ s00 ≤ s0 at which
pi enters the view pi.view(s00) > 0. Hence, pi.view+(s0) ≥ pi.view+(s00) ≥ pi.view(s00) > 0,
validating (6). Thus, (6) holds in all cases. Therefore, at s0 the process pi sends WISH(v0) for
some view v0. By Lemma 18, v0 ≥ v, and above we established GST ≤ s0 ≤ t, as required. (cid:74)

(cid:73) Lemma 20. Consider a view v > 0 and assume that v is entered by a correct process. If
Eﬁrst(v) ≥ GST, and no correct process attempts to advance from v before Eﬁrst(v) + 2δ, then
all correct processes enter v and Elast(v) ≤ Eﬁrst(v) + 2δ.

M. Bravo, G. Chockler, and A. Gotsman

25

Proof. If some correct process attempts to advance from a view v0 > v before Eﬁrst(v) + 2δ,
then by Proposition 1, some correct process must also enter the view v + 1. By Lemma 15,
this implies that some correct process attempts to advance from v before Eﬁrst(v) + 2δ,
contradicting the lemma’s premise. Thus, no correct process attempts to advance from any
view v0 ≥ v before Eﬁrst(v) + 2δ, and therefore, by Lemma 14, no correct process can send
WISH(v0) with v0 > v earlier than Eﬁrst(v) + 2δ. Once any such WISH(v0) is sent, it will take
a non-zero time until it is received by any correct process. Thus, we have:

(*) no correct process receives WISH(v0) with v0 > v from a correct process until after

Eﬁrst(v) + 2δ.

Let pi be a correct process that enters v at Eﬁrst(v). By the view entry condition,
pi.view(Eﬁrst(v)) = v, and therefore pi.max_views(Eﬁrst(v)) includes 2f + 1 entries ≥ v. At
least f + 1 of these entries belong to correct processes, and by (*), none of them can be > v.
Hence, there exists a set C of f + 1 correct processes, each of which sends WISH(v) to all
processes before Eﬁrst(v).

Since Eﬁrst(v) ≥ GST, by Lemma 19, every pj ∈ C also sends WISH(v0) with v0 ≥ v at
some time sj such that GST ≤ sj ≤ Eﬁrst(v). Then by (*) we have v0 = v. It follows that
each pj ∈ C is guaranteed to send WISH(v) to all correct processes between GST and Eﬁrst(v).
Since all messages sent by correct processes after GST are guaranteed to be received by all
correct processes within δ of their transmission, by Eﬁrst(v) + δ all correct processes will
receive WISH(v) from at least f + 1 correct processes.

Consider an arbitrary correct process pj and let tj ≤ Eﬁrst(v) + δ be the earliest time
by which pj receives WISH(v) from f + 1 correct processes. By (*), no correct process sends
WISH(v0) with v0 > v before tj < Eﬁrst(v) + 2δ. Thus, pj.max_views(tj) includes at least f + 1
entries equal to v and at most f entries > v, so that pj.view+(tj) = v. Then pj sends WISH(v)
to all processes no later than tj ≤ Eﬁrst(v) + δ. Since Eﬁrst(v) ≥ GST, by Lemma 19, pj also
sends WISH(v0) with v0 ≥ v in-between GST and Eﬁrst(v) + δ. By (*), v0 = v, and therefore,
pj must have sent WISH(v) to all processes sometime between GST and Eﬁrst(v) + δ. Hence,
all correct processes are guaranteed to send WISH(v) to all correct processes between GST
and Eﬁrst(v) + δ.

Consider an arbitrary correct process pk and let tk ≤ Eﬁrst(v) + 2δ be the earliest time
by which pk receives WISH(v) from all correct processes. Then by (*), all entries of correct
processes in pk.max_views(tk) are equal to v. Since there are at least 2f + 1 correct processes:
(i) at least 2f + 1 entries in pk.max_views(tk) are equal to v, and (ii) one of the f + 1 highest
entries in pk.max_views(tk) is equal to v. From (i), pk.view+(tk) ≥ pk.view(tk) ≥ v, and from
(ii), pk.view(tk) ≤ pk.view+(tk) ≤ v. Therefore, pk.view(tk) = pk.view+(tk) = v, so that pk
enters v no later than tk ≤ Eﬁrst(v) + 2δ. We have thus shown that by Eﬁrst(v) + 2δ, all
(cid:74)
correct processes enter v, as required.

(cid:73) Lemma 21. Startup holds: suppose there exists a set P of f + 1 correct processes such
that ∀pi ∈ P. Ai(0)↓; then eventually some correct process enters view 1.

Proof. Assume by contradiction that there exists a set P of f + 1 correct processes such
that ∀pi ∈ P. Ai(0)↓, and no correct process enters the view 1. By Proposition 1, the latter
implies

∀v0 > 0. Eﬁrst(v0)↑ .

Then by Lemma 14 we have

∀t. ∀v0 > 1. ∀pi. ¬(pi sends WISH(v0) at t ∧ pi is correct).

(7)

(8)

26

Liveness and Latency of Byzantine State-Machine Replication

Let T1 = max(GST, Alast(0)). Since there exists a set P of f + 1 correct processes that
attempt to advance from view 0, each pi ∈ P sends WISH(vi) with vi > 0 before T1. Since
T1 ≥ GST, by Lemma 19, there exists a view v0
i ≥ 1 and a time si such that GST ≤ si ≤ T1
and pi sends WISH(v0
i = 1. Since the links are reliable after GST, the
WISH(1) sent by pi at si will be received by all correct processes.

i) at si. By (8), v0

Thus, there exists a time T2 ≥ T1 ≥ GST by which all correct processes have received
WISH(1) from all processes in P . Fix an arbitrary correct process pj. Since all process in P
are correct, all entries in pj.max_views(T2) associated with the processes in P are equal to
1. Since |P | = f + 1, pj.max_views(T2) includes at least f + 1 entries ≥ 1, and therefore,
pj.view+(T2) ≥ 1. Hence, pj sends WISH(vj) with vj ≥ 1 no later than T2. Since T2 ≥ GST,
by Lemma 19 there exists a view v0
j ≥ 1 and a time sj such that GST ≤ sj ≤ T2 and pj
sends WISH(v0
j) at sj. By (8), v0
j = 1. Since the links are reliable after GST, the WISH(1) sent
by pj will be received by all correct processes.

Thus, there exists a time T3 ≥ T2 ≥ GST by which all correct processes have received
WISH(1) from all correct processes. Fix an arbitrary correct process pk. By (8), all entries of
correct processes in pk.max_views(T3) are equal to 1. Since there are at least 2f + 1 correct
processes: (i) at least 2f +1 entries in pk.max_views(T3) are equal to 1, and (ii) one of the f +1
highest entries in pk.max_views(T2) is equal to 1. From (i), pk.view+(T2) ≥ pk.view(T2) ≥ 1,
and from (ii), pk.view(T2) ≤ pk.view+(T2) ≤ 1. Hence, pk.view(T2) = pk.view+(T2) = 1, and
(cid:74)
therefore, pk enters view 1 by T2, contradicting (7).

(cid:73) Lemma 22. Progress holds: consider a view v > 0 that is entered by a correct process,
and suppose there exists a set P of f + 1 correct processes such that

∀pi ∈ P. Ei(v)↓ =⇒ Ai(v)↓;

(9)

then eventually some correct process enters v + 1.

Proof. Assume by contradiction that the required does not hold. Then, there exists a view
v > 0 such that some correct process enters v, (9) holds, and no correct process enters the
view v + 1. By Proposition 1, the latter implies that

∀v0 > v. Eﬁrst(v0)↑ .

Thus, by Lemma 14, we have

∀t. ∀v0 > v + 1. ∀pi. ¬(pi sends WISH(v0) at t ∧ pi is correct).

(10)

(11)

Let T1 = max(GST, Eﬁrst(v)). Since some correct process entered v by T1, there exists a
set C consisting of f + 1 correct processes all of which sent WISH(v0) with v0 ≥ v before T1.
Consider pi ∈ C and let ti ≤ T1 be a time such that at ti the process pi sends WISH(vi) with
vi ≥ v. Since T1 ≥ GST, by Lemma 19, there exists a view v0
i ≥ vi and a time si such that
GST ≤ si ≤ T1 and pi sends WISH(v0
i) at si. By (11), we have v0
i ∈ {v, v + 1}. Since the links
are reliable after GST, the WISH(v0
i) sent by pi at si will be received by all correct processes.
Thus, there exists a time T2 ≥ T1 ≥ GST by which all correct processes have received
WISH(v0) with v0 ∈ {v, v + 1} from all processes in C. Consider an arbitrary correct process
pj. By (11), the entry of every process in C in pj.max_views(T2) is equal to either v or v + 1.
Since |C| ≥ f + 1 and all processes in C are correct, pj.max_views(T2) includes at least
f + 1 entries ≥ v. Thus, pj.view+(T2) ≥ v, and therefore, pj sends WISH(vj) with vj ≥ v no
later than at T2. By (11), vj ∈ {v, v + 1}. Since T2 ≥ GST, by Lemma 19, there exists a
view v0
j) at sj. By (11),

j ≥ v and a time sj such that GST ≤ sj ≤ tj and pj sends WISH(v0

M. Bravo, G. Chockler, and A. Gotsman

27

v0
j ∈ {v, v + 1}. Since the links are reliable after GST, the WISH(v0
received by all correct processes.

j) sent by pj at sj will be

Thus, there exists a time T3 ≥ T2 ≥ GST by which all correct processes have received
WISH(v0) such that v0 ∈ {v, v + 1} from all correct processes. Consider an arbitrary correct
process pk, and suppose that pk is a member of the set P stipulated by the lemma’s premise.
Then at T3, all entries of correct processes in pk.max_views are ≥ v. By (11), each of these
entries is equal to either v or v + 1. Since at least 2f + 1 processes are correct: (i) at
least 2f + 1 entries in pk.max_views(T3) are ≥ v, and (ii) one of the f + 1 highest entries
in pk.max_views(T3) is ≤ v + 1. From (i), pk.view+(T3) ≥ pk.view(T3) ≥ v, and from (ii),
pk.view(T3) ≤ pk.view+(T3) ≤ v + 1. Hence, pk.view(T3), pk.view+(T3) ∈ {v, v + 1}. Since no
correct process enters v + 1, pk.view(T3) and pk.view+(T3) cannot be both simultaneously
equal to v +1. Thus, pk.view(T3) = v, and either pk.view+(T3) = v or pk.view+(T3) = v +1. If
pk.view+(T3) = v+1, then pk has sent WISH(vk) with vk = v+1 when pk.view+ has ﬁrst become
equal to v + 1 sometime before T3. On the other hand, if pk.view(T3) = pk.view+(T3) = v,
then pk has entered v at some time t ≤ T3. Since pk ∈ P , by (9), there exists a time t0 ≥ t
such that pk attempts to advance from v at t0, and therefore, sends WISH(vk) with vk ≥ v + 1
at t0. By (11), vk ≤ v + 1, and therefore, vk = v + 1. Thus, there exists a time tk ≥ T3
by which pk sends WISH(v + 1) to all processes. Since tk ≥ T3 ≥ GST, by Lemma 19, there
k ≥ v + 1 and a time sk such that GST ≤ sk ≤ tk and pk sends WISH(v0
exists a view v0
k) at
sk. By (11), v0
k = v + 1. Since the links are reliable after GST, the WISH(v + 1) sent by pk
will be received by all correct processes.

Thus, there exists a time T4 ≥ T3 ≥ GST by which all correct processes have received
WISH(v + 1) from all processes in P . Fix an arbitrary correct process pl. Since all process
in P are correct, by (11), all entries in pl.max_views(T4) associated with the processes in P
are equal to v + 1. Since |P | = f + 1, pl.max_views(T4) includes at least f + 1 entries equal
to v + 1, and therefore, pl.view+(T4) ≥ v + 1. Hence, pl sends WISH(vl) with vl ≥ v + 1 no
later than T4. Since T4 ≥ GST, by Lemma 19 there exists a view v0
l ≥ v + 1 and a time sl
such that GST ≤ sl ≤ T4 and pl sends WISH(v0
l = v + 1. Since the links
are reliable after GST, the WISH(v + 1) sent by pl will be received by all correct processes.
Thus, there exists a time T5 ≥ T4 ≥ GST by which all correct processes have received
WISH(v + 1) from all correct processes. Fix an arbitrary correct process pm. By (11), all
entries of correct processes in pm.max_views(T5) are equal to v + 1. Since there are at
least 2f + 1 correct processes: (i) at least 2f + 1 entries in pm.max_views(T5) are equal
to v + 1, and (ii) one of the f + 1 highest entries in pm.max_views(T5) is equal to v + 1.
From (i), pm.view+(T5) ≥ pm.view(T5) ≥ v + 1, and from (ii), pm.view(T5) ≤ pl.view+(T5) ≤
v + 1. Hence, pm.view(T5) = pm.view+(T5) = v + 1, and therefore, pm enters v + 1 by T5,
(cid:74)
contradicting (10).

l) at sl. By (11), v0

(cid:73) Theorem 23. Consider an execution with an eventual message delay δ. Then in this
execution the algorithm in Figure 3 satisﬁes the properties in Figure 1 for d = 2δ.

Proof. Monotonicity is satisﬁed trivially, and Validity, Startup, and Progress are given by
Lemmas 15, 21, and 22, respectively. To prove Bounded Entry, let

V = max{v | Eﬁrst(v)↓ ∧ Eﬁrst(v) < GST} + 1.

(12)

Then ∀v ≥ V. Eﬁrst(v)↓ =⇒ Eﬁrst(v) ≥ GST. Thus, by Lemma 20, Bounded Entry holds for
(cid:74)
d = 2δ, as required.

28

Liveness and Latency of Byzantine State-Machine Replication

B.2 Proof of the Synchronizer Performance Properties

The following lemma bounds the latency of entering v as a function of the time by which all
correct processes have sent such WISHes.

(cid:73) Lemma 24. For all views v > 0 and times s, if all correct processes pi send WISH(vi) with
vi ≥ v no later than at s, and some correct process enters v, then Elast(v) ≤ max(s, GST) + δ.

Proof. Fix an arbitrary correct process pi that sends WISH(vi) with vi ≥ v to all processes
at time ti ≤ s ≤ max(s, GST). Since max(s, GST) ≥ GST, by Lemma 19 there exists a time
t0
i such that GST ≤ t0
i) with v0
i ≥ vi ≥ v to all
processes. Since t0
i) from pi no later than at
t0
i + δ ≤ max(s, GST) + δ.

i, pi sends WISH(v0
i ≥ GST, all correct processes receive WISH(v0

i ≤ max(s, GST) and at t0

i) with with v0

Consider an arbitrary correct process pj and let tj ≤ max(s, GST) + δ be the earliest
time by which pj receives WISH(v0
i ≥ v from each correct processes pi. Thus, at
tj, the entries of all correct processes in pj.max_views are occupied by views ≥ v. Since at
least 2f + 1 entries in pj.max_views belong to correct processes, the (2f + 1)th highest entry
is ≥ v. Thus, pj.view(tj) ≥ v. Since pj.view is non-decreasing, there exists a time t0
j ≤ tj
at which pj.view ﬁrst became ≥ v. If pj.view(t0
j) = v, then pj enters v at
j) > v. Since both pj.view and pj.view+
t0
j. Otherwise, either pj.view(t0
are non-decreasing, pj will never enter v after t0
j. Thus, a correct process cannot enter v
after max(s, GST) + δ. Since by the lemma’s premise, some correct process does enter v,
(cid:74)
Elast(v) ≤ max(s, GST) + δ, as needed.

j) > v or pj.view+(t0

j) = pj.view+(t0

The next lemma gives an upper bound on the duration of time a correct process may

spend in a view before sending a WISH for a higher view.

(cid:73) Lemma 25. Let pk be a correct process that enters a view v. Then pk sends WISH(vk) with
vk ≥ v + 1 no later than at Tlast(v).

Proof. Suppose that pk enters a view v > 0 at time GST ≤ sk ≤ Elast(v). Then

pk.view(sk) = pk.view+(sk) = v.

By the deﬁnition of Tlast(v), there exists a time s0

k such that

sk ≤ s0

k ≤ Tlast(v),

k, then pk sends WISH(vk) with vk = max(pk.view(s0

k) ≥ v. Thus, vk ≥ v + 1, as required. On the other hand,

and at s0
advance from v at s0
Since both pk.view and pk.view+ are non-decreasing, we have pk.view(s0
pk.view+(s0
ters a view v0 > v at s0
pk.view+(s0
pk.view+ must have changed its value from v to v00
sk < s00
k. Thus, the condition in line 17 holds at s00
k ≤ s0
with vk ≥ v + 1 at s00
max(Elast(v), GST) + F (v), as required.

k, pk either attempts to advance from v or enters a view v0 > v. If pk attempts to
k)).
k) ≥ v and
if pk en-
k) > pk.view(sk) = v and therefore,
k) ≥ v + 1. Since pk.view+ is non-decreasing and pk.view+(sk) = v,
k ≥ v + 1 at some time s00
k such that
k, which means that pk sends WISH(vk)
k. Thus, in all cases, pk sends WISH(vk) with vk ≥ v + 1 no later than at
(cid:74)

k, then v0 = pk.view(s0

k) + 1, pk.view+(s0

k) ≥ pk.view(s0

The next lemma bounds the time by which every correct process either enters a view

v > 0, or sends a WISH messages with a view > v.

M. Bravo, G. Chockler, and A. Gotsman

29

(cid:73) Lemma 26. Consider a view v > 0 such that some correct process enters v. Then, for all
times t, if t ≥ max(Eﬁrst(v), GST), then Elast(v) ≤ t + 2δ and for all correct processes pk, if
pk never enters v, then, by Elast(v), pk sends WISH(vk) with vk ≥ v + 1 to all processes.

Proof. Since v > 0, Eﬁrst(v)↓, and t ≥ Eﬁrst(v), there exists a correct process pl such that
pl entered v and El(v) ≤ t. By the view entry condition, pl.view(El(v)) = v, and therefore
pl.max_views(El(v)) includes 2f + 1 entries ≥ v. Since f + 1 of these entries belong to correct
processes, there exists a set C of f + 1 correct processes pi, each of which sent WISH(vi) with
vi ≥ v to all processes before El(v) ≤ t. Since t ≥ GST, by Lemma 19, pi sends WISH(v0
i)
with v0
i ≥ vi ≥ v sometime between GST and t. Since after GST every message sent by a
correct process is received by all correct processes within δ of its transmission, the above
implies that by t + δ every correct process receives a WISH(v0
i ≥ v from each process
pi ∈ C.

i) with v0

Consider an arbitrary correct process pj and let tj ≤ t + δ be the earliest time by which
pj receives WISH(vi) with vi ≥ v from each process pi ∈ C. Thus, for all processes pi ∈ C,
pj.max_views[i](tj) ≥ v. Since |C| = f + 1, the (f + 1)th highest entry in pj.max_views[i](tj)
is ≥ v, and therefore, pj.view+(tj) ≥ v. Then each correct process pj sends WISH(vj) with
vj ≥ v to all correct processes no later than tj ≤ t + δ. Since t + δ > t ≥ GST and, and some
correct process entered v, by Lemma 24,

Elast(v) ≤ t + 2δ.

(13)

j) with v0

In addition, by Lemma 19, there exists a time t0
j ≤ t + δ and pj sends
WISH(v0
j ≥ vj ≥ v at t0
j. Since a message sent by a correct process after GST is
received by all correct processes within δ of its transmission, all correct processes must have
received WISH(v0

j ≥ v from each correct process pj in-between GST and t + 2δ.

j such that GST ≤ t0

j) with v0

Suppose that pk never enters v, and let tk be the earliest time ≥ GST by which pk
receives WISH(v0
j) from each correct process pj; we have tk ≤ t + 2δ. Since v0
j ≥ v, and there
are 2f + 1 correct processes, pk.max_views(tk) includes at least 2f + 1 entries ≥ v. Thus,
pk.view(tk) ≥ v. Since pk never enters v, we have either pk.view+(tk) ≥ pk.view(tk) ≥ v + 1
or pk.view(tk) = v ∧ pk.view+(tk) ≥ v + 1. Thus, pk.view+(tk) ≥ v + 1 and therefore, pk sends
WISH(vk) with vk ≥ v + 1 by tk ≤ t + 2δ, which combined with (13) validates the lemma. (cid:74)

We are now ready to prove the SMR synchronizer performance bounds.

(cid:73) Theorem 27. The SMR synchronizer in Figure 3 satisﬁes Property A.

Proof. Consider a view v such that Eﬁrst(v)↓, and let t = max(Eﬁrst(v), GST). Since
Aﬁrst(0) < GST, by the deﬁnition of GST, GST = GST + ρ. Thus, t = max(Eﬁrst(v), GST + ρ).
(cid:74)
By Lemma 26, Elast(v) ≤ t + 2δ = max(Eﬁrst(v), GST + ρ) + 2δ, as needed.

(cid:73) Theorem 28. The SMR synchronizer in Figure 3 satisﬁes Property B.

Proof. Consider a view v ≥ 0 such that Eﬁrst(v + 1)↓. If v = 0, then since we assume for all
correct processes pi, Ti(0)↓, by Lemma 25, all correct processes send WISH(v0) with v0 ≥ 0 to
all processes no later than at Tlast(0). Thus, by Lemma 24, Elast(1) ≤ max(Tlast(0), GST) + δ.
If Aﬁrst(0) < GST, then GST = GST + ρ, and therefore, Elast(1) ≤ max(Tlast(0), GST + ρ) + δ.
Otherwise, GST = Aﬁrst(0) ≤ Tlast(0), so that Elast(1) ≤ Tlast(0) + δ. Thus, the theorem
holds for v = 0.

Suppose that v > 0. Since some correct process enters v + 1, by Proposition 1, some
correct process enters view v as well. Consider a correct process pk. If pk enters v, then

30

Liveness and Latency of Byzantine State-Machine Replication

by Lemma 26, Ek(v) ≤ max(Eﬁrst(v), GST) + 2δ, and therefore, by Lemma 25, pk sends
WISH(vk) with vk ≥ v + 1 no later than at

Tlast(v) > max(Eﬁrst(v), GST) + 2δ.

(14)

On the other hand, if pk never enters v, then by Lemma 26, pk sends WISH(vk) with
vk ≥ v + 1 than at max(Eﬁrst(v), GST) + 2δ. Thus, every correct process pk sends WISH(vk)
with vk ≥ v + 1 no later than

max(Tlast(v), max(Eﬁrst(v), GST) + 2δ),

which by (14), implies that all correct processes send a WISH message with a view ≥ v + 1 no
later than Tlast(v). Thus, by Lemma 24, we have

Elast(v + 1) ≤ max(Tlast(v), GST) + δ.

(15)

If Aﬁrst(0) < GST, then GST = GST + ρ, and therefore, (15) implies that Elast(v + 1) ≤
max(Tlast(v), GST + ρ) + δ, as required. Otherwise, GST = Aﬁrst(v) ≤ Tlast(v), which by (15)
(cid:74)
implies that Elast(v + 1) ≤ Tlast(v) + δ, validating the theorem.

Proof of Theorem 3. Follows from Theorems 23, 27, and 28.

(cid:74)

C

Additional Material about PBFT-light

C.1 Proof of Safety for PBFT-light

Let us write wf(C) (for well-formed) if the set of correctly signed messages C were generated
in the execution of the protocol. In PBFT-light, committing a value requires preparing it,
which implies

(cid:73) Proposition 29.

∀k, v, C, h. committed(C, v, k, h) ∧ wf(C) =⇒ ∃C 0. prepared(C 0, v, k, h) ∧ wf(C 0).

Furthermore, the validity checks in the protocol ensure that any prepared value is valid:

(cid:73) Proposition 30. ∀k, v, C, x. prepared(C, v, k, hash(x)) ∧ wf(C) =⇒ valid(x).

The above two propositions imply

(cid:73) Corollary 31. PBFT-light satisﬁes External Validity.

(cid:73) Proposition 32. The variables curr_view and prep_view[k] (for any k) at a correct process
never decrease and we always have prep_view[k] ≤ curr_view.

(cid:73) Proposition 33.

∀k, v, C, C 0, x, x0. prepared(C, v, k, hash(x)) ∧ prepared(C 0, v, k, hash(x0)) ∧

wf(C) ∧ wf(C 0) =⇒ x = x0.

Proof. By contradiction, suppose that x 6= x0. Because a prepared certiﬁcate consists of
at least 2f + 1 PREPARE messages and there are 3f + 1 processes in total, there must be a
correct process that sent two PREPARE messages with diﬀerent hashes for the same position
(cid:74)
and view. But this is impossible due to the check on the check on phase in line 21.

M. Bravo, G. Chockler, and A. Gotsman

31

(cid:73) Lemma 34. If m = hNEW_STATE(v0, log0, M )ileader(v0)
ValidNewState(m), then

is a sent message such that

∀k, k0. log0[k] = log0[k0] 6∈ {⊥, nop} =⇒ k = k0.

Proof. We prove the statement of the lemma by induction on v0. Assume this holds for all
v0 < v∗; we now prove it for v0 = v∗. Let

M = {hNEW_LEADER(v0, prep_viewj, logj, certj)ij | pj ∈ Q}

for some quorum Q. By contradiction, assume that for some k, k0 and x we have k 6= k0,
log0[k] = log0[k0] = x 6∈ {⊥, nop}. Since ValidNewState(m), log0 is computed from M as per
lines 50-55. Then due to the loop at line 53, for some i, i0 ∈ Q we have logi[k] = logi0[k0] = x
and prep_viewi[k] = prep_viewi0[k0] = v for some v such that 0 < v < v0. Hence, for some C
and C 0 we have

prepared(C, v, k, hash(x)) ∧ prepared(C 0, v, k0, hash(x)) ∧ wf(C) ∧ wf(C 0).

Because a prepared certiﬁcate consists of at least 2f +1 PREPARE messages and there are 3f +1
processes in total, there must be a correct process that sent messages PREPARE(v, k, hash(x))
and PREPARE(v, k0, hash(x)). But this is impossible because by the induction hypothesis,
the process starts the view v with a log without duplications (except nops), and does not
add duplicate entries due to the check at line 21. This contradiction demonstrates the
(cid:74)
required.

(cid:73) Corollary 35.

∀x, v, k, k0, C, C 0. prepared(C, v, k, hash(x)) ∧ prepared(C 0, v, k0, hash(x)) ∧
wf(C) ∧ wf(C 0) ∧ x 6= nop =⇒ k = k0.

Proof. Assume the contrary. Because a prepared certiﬁcate consists of at least 2f +1 PREPARE
messages and there are 3f + 1 processes in total, there must be a correct process that sent
messages PREPARE(v, k, hash(x)) and PREPARE(v, k0, hash(x)). But this is impossible because
by Lemma 34, the process starts the view v with a log without duplications (except nops), and
does not add duplicate entries due to the check at line 21. This contradiction demonstrates
(cid:74)
the required.

(cid:73) Lemma 36. Fix k, v, v0, C and x, and assume

committed(C, v, k, hash(x)) ∧ wf(C) ∧ v0 > v.

∀C 0, x0. prepared(C 0, v0, k, hash(x0)) ∧ wf(C 0) =⇒ x = x0.
∀C 0, k0. x 6= nop ∧ prepared(C 0, v0, k0, hash(x)) ∧ wf(C 0) =⇒ k = k0.

Proof. We prove the statement of the lemma by induction on v0. Assume this holds for all
v0 < v∗; we now prove it for v0 = v∗. Thus, we have

∀C 00, k00, v00. v < v00 < v0 ∧x 6= nop∧prepared(C 00, v00, k00, hash(x))∧wf(C 00) =⇒ k = k00. (16)

The induction hypothesis also implies

∀C 00, x00, v00. v < v00 < v0 ∧ prepared(C 00, v00, k, hash(x00)) ∧ wf(C 00) =⇒ x = x00.

32

Liveness and Latency of Byzantine State-Machine Replication

Furthermore, by Propositions 33 and 29 we have

∀C 00, x00. prepared(C 00, v, k, hash(x00)) ∧ wf(C 00) =⇒ x = x00,

so that overall we get

∀C 00, x00, v00. v ≤ v00 < v0 ∧ prepared(C 00, v00, k, hash(x00)) ∧ wf(C 00) =⇒ x = x00.

(17)

Assume now that prepared(C 0, v0, k, hash(x0)) and wf(C 0). Then a correct process that sent
the corresponding PREPARE message must have received a message m = NEW_STATE(v0, log0, M )
from the leader of v0 satisfying ValidNewState(m). Let

M = {hNEW_LEADER(v0, prep_viewj, logj, certj)ij | pj ∈ Q}

for some quorum Q. Since ValidNewState(m), we have ∀m0 ∈ M. ValidNewLeader(m0), so
that

∀pj ∈ Q. prep_viewj < v0 ∧

(prep_viewj 6= 0 =⇒ prepared(certj, prep_viewj, k, hash(logj[k])) ∧ wf(certj)).

From this and (17) we get that

∀pj ∈ Q. prep_viewj ≥ v =⇒ logj[k] = x.

(18)

Since committed(C, v, k, hash(x)), a quorum Q0 of processes sent COMMIT(v, k, hash(x)).
The quorums Q and Q0 have to intersect in some correct process pi, which has thus sent both
COMMIT(v, k, hash(x)) and NEW_LEADER(v0, prep_viewi, logi, certi). Since v < v0, this process
pi must have sent the COMMIT message before the NEW_LEADER message. Before sending
COMMIT(v, k, hash(x)) the process set prep_view[k] to v (line 26). Then by Proposition 32
process pi must have had prep_view[k] ≥ v when it sent the NEW_LEADER message. Hence,
prep_viewi[k] ≥ v > 0 and max{prep_viewj0[k] | pj0 ∈ Q} ≥ v. Then from (18) we get

∀pj ∈ Q. prep_viewj[k] = max{prep_viewj0[k] | pj0 ∈ Q} =⇒ logj[k] = x.

(19)

Assume now that x 6= nop, but log0[k] = nop due to line 55. Then

∃k0. k0 6= k ∧ log0[k0] = x ∧ ∃pj ∈ Q. ∀pj0 ∈ Q. prep_viewj[k0] > prep_viewj0[k]

and v0 > prep_viewj[k0] > prep_viewi[k] ≥ v. Since ValidNewState(m), for some C 00 we have
prepared(C 00, prep_viewj[k0], k0, hash(x)) and wf(C 00). Then by (16) we have k = k0, which
yields a contradiction. This together with (19) and ValidNewState(m) implies log0[k] = x, as
required.

Assume now x 6= nop, prepared(C 0, v0, k0, hash(x)) and wf(C 0). Then a correct pro-
cess that sent the corresponding PREPARE message must have received a message m =
NEW_STATE(v0, log0, M ) from the leader of v0 satisfying ValidNewState(m). As before, we can
show log0[k] = x. By Lemma 34, the process starts the view v0 with a log without duplications
(except nops), and does not add duplicate entries due to the check at line 21. Hence, we
(cid:74)
must have k0 = k, as required.

(cid:73) Corollary 37. PBFT-light satisﬁes Ordering.

M. Bravo, G. Chockler, and A. Gotsman

33

Proof. By contradiction, assume that Ordering is violated. Then for some k, two correct pro-
cesses execute the handler in line 32 for last_delivered = k−1 so that commit_log[k] = x at one
process and commit_log[k] = x0 at the other, where x 6= x0. Then committed(C, v, k, hash(x))
and committed(C 0, v0, k, hash(x0)) for some well-formed C and C 0. By Proposition 29 we have
prepared(C0, v, k, hash(x)) and prepared(C 0
0, v0, k, hash(x0)) for some well-formed C0 and C 0
0.
Without loss of generality assume v ≤ v0. If v = v0, then x = x0 by Proposition 33. If v < v0,
(cid:74)
then x = x0 by Lemma 36. In either case we get a contradiction.

(cid:73) Corollary 38. PBFT-light satisﬁes Integrity.

Proof. By contradiction, assume that Integrity is violated. Then for some k, k0 such
that k 6= k0and x 6= nop, a correct process executes the handler in line 32 ﬁrst in
a view v for last_delivered = k − 1 and commit_log[k] = x and then in a view v0 for
last_delivered = k0 − 1 and commit_log[k0] = x. We must have committed(C, v, k, hash(x))
and committed(C 0, v0, k0, hash(x0)) for some well-formed C and C 0. By Proposition 29 we
have prepared(C0, v, k, hash(x)) and prepared(C 0
0, v0, k0, hash(x0)) for some well-formed C0 and
0. Without loss of generality assume v ≤ v0. If v = v0, then we get a contradiction by
C 0
(cid:74)
Corollary 35. If v < v0, then we get a contradiction by Lemma 36.

C.2 Additional Details for the Proof of Liveness of PBFT-light

Proof of Lemma 4. We know that at some point pi enters view v, and at this moment it
starts timer_recovery. If the timer expires, then pi calls advance in v, as required. Assume
that timer_recovery does not expire at pi. Then pi stops the timer at lines 4, 38, 66 or 43.
The latter is impossible, as this would imply that pi enters a higher view. If pi stops the
timer at line 4, then it calls advance in v, as required. Assume now that pi stops the timer
at lines 38 or 66. This implies that pi sets status = normal at some point while in v. If
pi sets status = advanced while in v, then it calls advance in v, as required. Thus, it
remains to consider the case when pi sets status = normal at some point while in v and
does not change it while in this view. Since pi receives BROADCAST(x) for a valid value x
while in a view v, the handler at line 12 is executed at some point. At this point pi starts
timer_delivery[x]. If the timer expires, then pi calls advance in v, as required. Otherwise pi
stops the timer at lines 4, 36 or 43. The last two are impossible, as this would imply that pi
enters a higher view or that x is delivered. In the remaining case pi calls advance in v, as
(cid:74)
required.

x,
that
The remaining case in the proof of Lemma 6. Assume
timer_delivery[x] expires at pi
in v. The process starts timer_delivery[x] when it re-
ceives BROADCAST(x) and it has not yet delivered x (line 14). Let t be the time when this
happens; then t ≥ Eﬁrst(v) (Figure 10). Because pi is the ﬁrst correct process to call
advance in v and dur_deliveryi(v) > 4δ, no correct process calls advance in v until after
t + 4δ. Then by Bounded Entry all correct processes enter v by Eﬁrst(v) + 2δ. Furthermore,
by Validity no correct process can enter v + 1 until after t + 4δ, and by Proposition 1 the
same holds for any view > v. Thus, all correct processes stay in v at least until t + 4δ.

value

some

for

The process pi has status = normal at t, so that by this time pi has handled the
NEW_STATE message from the leader of v. Thus, all correct processes receive NEW_STATE by
t+δ. Since t ≥ Eﬁrst(v) and all correct processes enter v by Eﬁrst(v)+2δ, all correct processes
handle NEW_STATE by t + 2δ. When a process handles NEW_STATE(v, _, _), it sends PREPARE
messages for all positions ≤ init_log_length. Therefore, by t + 2δ all correct processes send
PREPARE for all positions ≤ init_log_length.

34

Liveness and Latency of Byzantine State-Machine Replication

Figure 10 An illustration of the bound on dur_delivery in Lemma 5.

When pi starts timer_delivery[x], it sends FORWARD(x) to leader(v), which receives the
message no later than t + δ. Consider ﬁrst the case when leader(v) has x in its log at position
k ≤ init_log_length when it receives FORWARD(x). Then all correct processes send PREPARE for
all positions ≤ k by t + 2δ. Assume now that, when the leader receives FORWARD(x), either
x 6∈ log or for some k > init_log_length we have log[k] = x. In the former case the leader
sends PREPREPARE(v, k, x) to all processes. In the latter case, due to lines 52 and 19, the
leader has already sent PREPREPARE(v, k, x) to all processes. Thus, in either case the leader
sends PREPREPARE(v, k, x) no later than t + δ. Hence, due to lines 52 and 19, the leader
sends a PREPREPARE for all positions from init_log_length + 1 up to k no later than t + δ, and
all correct processes receive these messages no later than t + 2δ. We have established that
all correct processes have handled NEW_STATE(v, _, _) by t + 2δ. Then all correct processes
handle the PREPREPARE messages for positions from init_log_length + 1 up to k by t + 2δ,
i.e., they send a PREPARE for each of these positions. Furthermore, we have established that
all correct processes send a PREPARE message for each position ≤ init_log_length by t + 2δ.
Therefore, all correct processes send PREPARE for each position ≤ k by t + 2δ. It then takes
them at most 2δ to exchange the corresponding sequence of PREPARE and COMMIT messages.
Hence, all correct processes receive COMMIT for all positions ≤ k by t + 4δ.

Assume that when pi receives all these COMMIT messages, it has last_delivered < k. Then pi
delivers x by t + 4δ. Since pi’s timer_delivery[x] has not expired by then, the process stops the
timer, which contradicts our assumption. Therefore, when pi receives all the COMMIT messages
for positions ≤ k, it has last_delivered ≥ k, so that pi has already delivered a value x0 at this
position. Then pi must have formed a certiﬁcate C 0 such that committed(C 0, v0, k, hash(x0)).
By Proposition 29, for some well-formed certiﬁcate C 00 we have prepared(C 00, v0, k, hash(x0)).
Since all correct processes stay in v until t + 4δ, we must have v0 ≤ v. If v = v0, then by
Proposition 33 we get x = x0. If v0 < v, then by Lemma 36 we get x = x0. Hence, pi delivers
x. By line 12, pi does not start timer_delivery[x] if x has already been delivered. Since pi
started the timer at t, it has to deliver x at some point after t and no later than t + 4δ. Since
pi’s timer_delivery[x] has not expired by then, the process stops the timer, which contradicts
(cid:74)
our assumption. Therefore, timer_delivery cannot expire at pi.

BROADCAST(x)leader(v)Elast(v)NEW_LEADER(v)NEW_STATE(v)NEW_STATE(v)PREPARE(x)2𝛿𝛿𝛿PREPREPARE(x)PREPREPARE(x)Efirst(v)FORWARD(x)COMMIT(x)pipjstart timer_deliverystop timer_deliveryM. Bravo, G. Chockler, and A. Gotsman

35

C.3 Proof of the Latency Bounds for PBFT-light

To show the bound, we take advantage of the latency guarantees of our synchronizer
(Theorem 3). In more detail, the bound has to account for an unfavorable scenario where the
last view V − 1 of the asynchronous period is not operational (e.g., not all correct processes
enter it). In this case, to deliver x the protocol ﬁrst needs to bring all correct processes into
the same view V. To bound the time required for that, we ﬁrst use Property A to determine
the latest time when a correct process can enter V − 1: GST + ρ + 2δ. We then add the time
such a process may spend in V − 1 before it detects that x is taking too long to get delivered
and call advance: max{ρ + δ, 6∆} + 4∆, where 6∆ and 4∆ come from the maximal timeout
values. The ﬁrst clause of Property B then shows that all correct processes will enter V
within an additional δ, i.e., Elast(V) ≤ GST + ρ + max{ρ + δ, 6∆} + 4∆ + 3δ. Finally, we
add the time for x to be delivered in V: max{ρ, δ} + 4δ.

We now proceed with the formal proof.

(cid:73) Lemma 39. If a correct process delivers a value x at t, then all correct processes deliver x
by max{t + δ, GST + ρ + δ}.

We omit the easy proof of the lemma.

(cid:73) Lemma 40. If a correct process pi enters a view v, then the earliest time it may call
advance is Ei(v) + min{dur_recoveryi(v), dur_deliveryi(v)}.

Proof. A process calls advance in a view if a timer expires. Assume ﬁrst that timer_recovery
expires. The process pi starts timer_recovery when it enters the view v. Thus, if timer_recovery
expires, then pi calls advance at Ei(v) + dur_recoveryi(v). Assume now that timer_delivery[x]
expires for some value x. The earliest time pi may start this timer is Ei(v). Then the
earliest time pi may call advance in this case is Ei(v) + dur_deliveryi(v). Thus, pi cannot
(cid:74)
call advance in v before Ei(v) + min{dur_recoveryi(v), dur_deliveryi(v)}, as required.

(cid:73) Lemma 41. Assume that a correct process pi that enters v receives BROADCAST(x) at
t ≥ Ei(v) for a valid value x. Assume that pi does not deliver x until after max{t, Ei(v) +
dur_recoveryi(v)} + dur_deliveryi(v). Then Ti(v)↓ and

Ti(v) ≤ max{t, Ei(v) + dur_recoveryi(v)} + dur_deliveryi(v).

Proof. We know that at some point pi enters view v, and at this moment it starts
timer_recovery. If the timer expires, then pi calls advance in v by Ei(v) + dur_recoveryi(v),
as required. Assume that timer_recovery does not expire at pi. Then pi stops the timer
If pi stops the timer at line 4, then it calls advance in v by
at lines 4, 38, 66 or 43.
Ei(v) + dur_recoveryi(v), as required.
If pi stops the timer at line 43, then it enters a
higher view by Ei(v) + dur_recoveryi(v), as required. Assume now that pi stops the timer
at lines 38 or 66. This implies that pi sets status = normal by Ei(v) + dur_recoveryi(v)
while in v. If pi calls advance or enters a higher view by max{t, Ei(v) + dur_recoveryi(v)},
we get the required. Assume that this is not the case. Then pi sets status = normal
and receives x by max{t, Ei(v) + dur_recoveryi(v)}. Since pi has not delivered x by
max{t, Ei(v)+dur_recoveryi(v)}, by this point pi starts timer_delivery[x]. If the timer expires,
then pi calls advance in v by max{t, Ei(v) + dur_recoveryi(v)} + dur_deliveryi(v), as required.
Otherwise pi stops the timer at lines 4, 36 or 43. If pi stops the timer at line 43, then it enters a
higher view by max{t, Ei(v)+dur_recoveryi(v)}+dur_deliveryi(v), as required. If pi stops the

36

Liveness and Latency of Byzantine State-Machine Replication

timer at line 36, then it delivers x by max{t, Ei(v)+dur_recoveryi(v)}+dur_deliveryi(v), which
is impossible. In the remaining case pi calls advance in v by max{t, Ei(v)+dur_recoveryi(v)}+
(cid:74)
dur_deliveryi(v), as required.

(cid:73) Lemma 42. Assume that all correct processes start executing PBFT-light before GST. If
V = 1 in Theorem 3, then Eﬁrst(V)↓ and Elast(V) ≤ GST + ρ + δ.

Proof. By Theorem 3, if V = 1, then GV(GST) = 0. Since all correct processes start
executing the protocol before GST, then all correct processes attempt to advance from view 0
and Tlast(0) < GST. By Startup, Eﬁrst(V)↓. Applying the ﬁrst clause of Property B, we get
Elast(V) ≤ max{Tlast(0), GST + ρ + δ}. Since Tlast(0) < GST, then Elast(V) ≤ GST + ρ + δ,
(cid:74)
as required.

(cid:73) Lemma 43. Consider a view v ≥ V such that Eﬁrst(v) ≥ GST and leader(v) is correct.
Assume that a correct process pj broadcast a value x before Eﬁrst(v). If dur_recoveryi(v) > 6δ
and dur_deliveryi(v) > 4δ at each correct process pi that enters v, then all correct processes
deliver x by Elast(v) + max{ρ, δ} + 4δ.

Proof. By Lemma 5, no correct process calls advance in v. Therefore, by Validity, no
correct process enters v + 1, and by Proposition 1 the same holds for any view > v. By
Bounded Entry, all correct processes enter v. Assume that pj delivers x by Elast(v) + ρ.
Then by Lemma 39 all correct processes deliver x by max{Elast(v) + ρ + δ, GST + ρ + δ}.
Since Eﬁrst(v) ≥ GST, we get Elast(v) + ρ + δ ≥ GST + ρ + δ. Thus, all correct processes
deliver x by Elast(v) + ρ + δ, as required.

Consider now the case when pj does not deliver x by Elast(v) + ρ. Then pj retransmits
x between GST and GST + ρ ≤ Elast(v) + ρ, so that leader(v) receives x by Elast(v) +
ρ + δ. When a process enters v, it sends NEW_LEADER to leader(v). The leader receives
2f + 1 of these messages by Elast(v) + δ and sends a NEW_STATE message to all processes.
A process handles NEW_STATE by Elast(v) + 2δ and sets its status to normal. Since no
process calls advance in v, every correct process has status = normal after handling
NEW_STATE onwards. We have established that leader(v) receives x by Elast(v) + ρ + δ. Then
leader(v) sets status = normal and receives x by t ≤ Elast(v) + max{ρ, δ} + δ. Assume that
leader(v) has delivered x by Elast(v) + max{ρ, δ} + δ. Then by Lemma 39 all correct process
deliver x by max{Elast(v) + max{ρ, δ} + 2δ, GST + ρ + δ}. Since Eﬁrst(v) ≥ GST, we get
Elast(v) + max{ρ, δ} + 2δ ≥ GST + ρ + δ. Thus, in this case all correct processes deliver x by
Elast(v) + max{ρ, δ} + 2δ, as required.

Assume now that leader(v) has not delivered x by t. Consider ﬁrst then case when
leader(v) already has x in its log at t because x was prepared in a previous view. Then all
correct processes send PREPARE(v, k, hash(x)) for a position k by Elast(v) + 2δ. Consider now
the case when leader(v) either has x in its log at t because it was already proposed in v; or
leader(v) does not have it. In this case, it follows that leader(v) sends PREPREPARE(v, k, x) to
all correct processes by t, which all correct processes receive by t + δ. When a correct process
receives PREPREPARE(v, k, x), it sends PREPARE(v, k, hash(x)). Thus, all correct process send
PREPARE(v, k, hash(x)) by t + δ. Since t ≤ Elast(v) + max{ρ, δ} + δ. Then, in both cases,
all correct processes send PREPARE(v, k, hash(x)) by Elast(v) + max{ρ, δ} + 2δ. It then takes
the correct processes at most 2δ to exchange the sequence of PREPARE and COMMIT messages
that commit x. Therefore, all correct processes commit x by Elast(v) + max{ρ, δ} + 4δ.
Let pi be a correct process. Because leader(v) is correct, we can show that last_delivered ≥
k − 1 at pi by Elast(v) + max{ρ, δ} + 4δ. If last_delivered = k − 1, then pi delivers x by
Elast(v) + max{ρ, δ} + 4δ. If last_delivered > k − 1 at pi by Elast(v) + max{ρ, δ} + 4δ, then

M. Bravo, G. Chockler, and A. Gotsman

37

we can show that pi has already delivered x before. Since pi was picked arbitrarily, we can
conclude that all correct processes deliver x by Elast(v) + max{ρ, δ} + 4δ, as required. (cid:74)

Proof of Theorem 8. Let pj be the correct process that broadcast x, and let V be deﬁned as
in Theorem 3. Assume ﬁrst that V > 1. We have Aﬁrst(0) < GST and Eﬁrst(V − 1) < GST + ρ.
Then by Property A,

Elast(V − 1) ≤ GST + ρ + 2δ.

(20)

If at least one correct process pi delivers x by GST + ρ + 2δ + max{ρ + δ, 6∆} + 4∆, then by
Lemma 39, all correct processes deliver x by GST + ρ + 3δ + max{ρ + δ, 6∆} + 4∆, as required.
Assume now that no correct process pi delivers x by GST + ρ + 2δ + max{ρ + δ, 6∆} + 4∆. In
particular, this implies that pj has not delivered x by GST + 2ρ + 2δ, so that it retransmits x
between GST + ρ + 2δ and GST + 2ρ + 2δ. Consider a correct process pi that enters V − 1 and
let ti be the time when this process receives the BROADCAST(x) retransmission from pj; then

ti ≤ GST + 2ρ + 3δ

and by (20),

ti > GST + ρ + 2δ ≥ Ei(V − 1).

We now obtain:

(21)

(22)

max{ti, Ei(V − 1) + dur_recoveryi(V − 1)} +
dur_deliveryi(V − 1)

≤ max{ti, Ei(V − 1) + 6∆} + 4∆

≤ max{GST + 2ρ + 3δ, Ei(V − 1) + 6∆} + 4∆
≤ max{GST + 2ρ + 3δ, GST + ρ + 2δ + 6∆} + 4∆
= GST + ρ + 2δ + max{ρ + δ, 6∆} + 4∆

since dur_recoveryi(V − 1) ≤ 6∆
and dur_deliveryi(V − 1) ≤ 4∆
by (21)
by (20)

Then, since we assume that no correct process delivers x by GST+ρ+2δ+max{ρ+δ, 6∆}+4∆,
by (22) and Lemma 41 we get Ti(V − 1)↓. Thus, pi either calls advance in V − 1 or enters a
higher view. If at least one correct process enters a view higher than V, then by Proposition 1,
Eﬁrst(V)↓. If all correct processes that enter V − 1 call advance, then by Progress we get
Eﬁrst(V)↓ as well. By Lemma 41, we also have

Ti(V − 1) ≤ max{ti, Ei(V − 1) + dur_recoveryi(V − 1)} + dur_deliveryi(V − 1) ≤

GST + ρ + 2δ + max{ρ + δ, 6∆} + 4∆

for any correct process pi that enters V − 1. Applying the ﬁrst clause of Property B, we get

Elast(V) ≤ max{Tlast(V − 1), GST + ρ} + δ ≤ GST + ρ + 3δ + max{ρ + δ, 6∆} + 4∆. (23)

Thus, if V > 1, then either all correct processes deliver x by GST + ρ + 2δ + max{ρ +
δ, 6∆} + 4∆, or Eﬁrst(V)↓ and (23) holds. Furthermore, if V = 1, then by Lemma 42,
Eﬁrst(V)↓ and Elast(V) ≤ GST + ρ + δ. We have thus established that either all correct
processes deliver x by GST + ρ + 2δ + max{ρ + δ, 6∆} + 4∆, or Eﬁrst(V)↓ and (23) holds. In
the latter case, by Lemma 43, all correct processes deliver x by Elast(V) + max{ρ, δ} + 4δ,
and by (23),

Elast(V) + max{ρ, δ} + 4δ ≤ GST + ρ + max{ρ + δ, 6∆} + 4∆ + max{ρ, δ} + 7δ,

as required.

(cid:74)

38

Liveness and Latency of Byzantine State-Machine Replication

(cid:73) Lemma 44. Assume that V = 1 in Theorem 3, Eﬁrst(1) ≥ GST and leader(1) is correct.
If dur_recoveryi(1) > 5δ and dur_deliveryi(1) > 4δ at each correct process pi that enters 1,
then no correct process calls advance in v.

We omit the proof of this lemma. It is virtually identical to that of Lemma 5, considering
the special case of v = V = 1 and the optimization by which in view 1 the processes do not
exchange NEW_LEADER messages.

(cid:73) Lemma 45. Assume that V = 1 in Theorem 3, Eﬁrst(1) ≥ GST and leader(1) is correct.
Assume that a correct process pj broadcast a value x at t ≥ GST. If dur_recoveryi(1) > 5δ
and dur_deliveryi(1) > 4δ at each correct process pi that enters 1, then all correct processes
deliver x by max{t, Elast(1)} + 4δ.

Proof. By Lemma 44, no correct process calls advance in 1. Therefore, by Validity, no
correct process enters 2, and by Proposition 1 the same holds for any view > 1. By Bounded
Entry, all correct processes enter 1.

When leader(1) enters view 1, it sends a NEW_STATE message to all processes. A process
handles NEW_STATE by Elast(1) + δ and sets its status to normal. The leader(1) receives x
by t + δ. The leader will send PREPREPARE(1, k, x) when it has received x and has status =
normal, i.e., by max{t, Elast(1)} + δ. All correct processes receive PREPREPARE(1, k, x) by
max{t, Elast(1)} + 2δ. It then takes the correct processes at most 2δ to exchange the sequence
of PREPARE and COMMIT messages that commit x. Therefore, all correct processes commit x by
max{t, Elast(1)} + 4δ. Let pi be a correct process. Because leader(1) is correct, we can show
that last_delivered ≥ k − 1 at pi by max{t, Elast(1)} + 4δ. If last_delivered = k − 1, then pi
delivers x by max{t, Elast(1)}+4δ. In case last_delivered > k−1 at pi by max{t, Elast(1)}+4δ,
we can show that pi has already deliver x before. Since pi was picked arbitrarily, we can
(cid:74)
conclude that all correct processes deliver x by max{t, Elast(1)} + 4δ, as required.

Proof of Theorem 9. When a correct process starts the protocol, it calls advance from
view 0 unless it has already entered a higher view. If all correct processes call advance
from view 0 when they start the protocol, then by Startup we get Eﬁrst(1)↓. If at least
one correct process does not call advance from view 0 because it has already entered a
higher view, then by Proposition 1 we also get Eﬁrst(1)↓. Since all correct processes start
the protocol after GST, we have Aﬁrst(0) > GST. Thus, applying the second clause of
Property B, we get Elast(1) ≤ Tlast(0) + δ. Furthermore, by Theorem 3 we get V = 1.
Hence, Elast(V) ≤ Tlast(0) + δ, as required. By Lemma 45, all correct processes deliver x by
(cid:74)
max{t, Elast(V)} + 4δ ≤ max{t, Tlast(0) + δ} + 4δ, as required.

C.4 Space Requirements of PBFT-light

Since the synchronizer is not guaranteed to switch processes between views all at the same
time, a process in a view v may receive a message from a higher view v0 > v, which needs
to be stored in case the process ﬁnally switches to v0. If implemented naively, this would
require a process to store unboundedly many messages. Instead, we allow a process to store,
for each message type and sender, only the message of this type received from this sender
that has the highest view. We can easily adapt the liveness proof of PBFT-light to take this
into account. In the proof, when we argue that a process handles a message m in a view v at
a given time t, we establish before that no correct process has entered a greater view by t.
This implies that no correct process has sent a message for a view > v by t. Thus, m will
not be discarded at correct processes before t, which is enough to ensure that liveness is not
violated. Recall that our synchronizer from §3 uses only bounded space. Thus, PBFT-light

M. Bravo, G. Chockler, and A. Gotsman

39

with this synchronizer requires space proportional to the number of requests submitted by
clients. This is appropriate for blockchain applications, where a process participating in the
SMR protocol needs to store the blockchain and candidate blocks anyway.

D PBFT with Leader Rotation Using an SMR Synchronizer

We now demonstrate how an SMR synchronizer can be used to implement Byzantine
SMR protocols that periodically force a leader change [27, 54, 55]. Figures 11-12 give an
implementation of such a variant of PBFT, which we call PBFT-rotation. As in PBFT-light,
processes monitor the behavior of the leader and ask the synchronizer to advance to another
view if they suspect that the leader is faulty. To ensure that leaders periodically rotate,
processes also call advance once they deliver B values proposed by the current leader. Thus,
the leader of a view v is responsible for ﬁlling in the slots in the log from (v − 1) · B + 1 to
(v − 1) · B + B.

A process broadcasts a valid value x using a broadcast function (line 9). As in PBFT-
light, this keeps sending the value to all processes in a BROADCAST message until the current
process delivers the value. When a process receives a BROADCAST message with a new value
(line 12), it appends the value to a queue of values pending to be broadcast. When the leader
has new values in its queue and has not yet exhausted the range of log slots it is allowed
to ﬁll (line 15), it selects the ﬁrst new value in the queue and proposes it by calling the
propagate function (line 21). The processes then handle the proposal as in PBFT-light.
When a process delivers a value, the process removes it from the queue of pending values
(line 42). If this is the value is in the last slot allocated to the current leader, the process
also calls advance to request a leader change (line 46).

A follower monitors the leader’s behavior using two timers,

timer_delivery and
timer_recovery, which are similar to the corresponding timers in PBFT-light, but slightly
diﬀerent. The (single) timer timer_delivery checks that new values are delivered at regular
intervals: a process sets timer_delivery for a duration determined by dur_delivery when it
delivers a value and the current leader has not yet exhausted the slots allocated to it (line 50);
the process stops the timer when it delivers the next value (line 82). If a correct leader does
not have anything to propose during a ﬁxed time interval T , the leader proposes a nop. The
leader ensures this using a timer timer_broadcast (lines 25 and 19). The above mechanism
protects against a faulty leader not making any proposals. However, it allows a faulty leader
to omit some of the values submitted by clients. The overall protocol nevertheless protects
against censorship because leaders periodically rotate, and thus the protocol will go through
inﬁnitely many views with correct leaders. Since values to be broadcast are sent to all
processes (line 11) and are handled in the order of arrival (line 14), each value will eventually
be proposed by a correct leader.

Finally, timer_recovery is used to check that the leader initializes a view quickly enough.
Like in PBFT-light, a process starts this timer for a duration determined by dur_recovery
when it enters a new view (line 59). Unlike in PBFT-light, a process stops the timer when it
receives a NEW_STATE message with the initial log from the leader (line 73). In PBFT-light the
timer is stopped only after delivering all the values in the initial log, but in PBFT-rotation
the deliver of these values is checked by timer_delivery.

The Integrity, External Validity and Ordering properties of PBFT-rotation are proved in

the same way as for PBFT-light (§C.1).

40

Liveness and Latency of Byzantine State-Machine Replication

1 function start()
2

if curr_view = 0 then advance();

26 when received hPREPREPARE(v, k, x)ij
27

pre: pj = leader(v) ∧ curr_view = v ∧

3 when timer_delivery or timer_recovery

expires

4

5

6

7

8

stop_all_timers();
advance();
status ← advanced;
dur_delivery ← dur_delivery + τ ;
dur_recovery ← dur_recovery + τ ;

9 function broadcast(x)
pre: valid(x);
10
send hBROADCAST(x)ii to all
periodically until x is
delivered

11

12 when received BROADCAST(x)
pre: valid(x) ∧ x 6∈ queue ∧
13

(∀k. k ≤ last_delivered =⇒
commit_log[k] 6= x);
queue ← append(queue, x);

14

15 when pi = leader(curr_view) ∧

status = normal ∧
next ≤ curr_view · B ∧
∃x ∈ queue. ∀k. log[k] 6= x
x ← the ﬁrst value in queue that

is not in log;

stop_timer(timer_broadcast);
propagate(x);

16

17

18

19 when timer_broadcast expires
20

propagate(nop);

21 function propagate(x)
22

send hPREPREPARE(curr_view,

next, x)ii to all;
next ← next + 1;
if next ≤ curr_view · B then

start_timer(timer_broadcast, T )

23

24

25

status = normal ∧ phase[k] = start ∧
k ≤ v · B ∧ valid(x) ∧ (∀k0. log[k0] 6= x);

28

29

(log, phase)[k] ← (x, preprepared);
send hPREPARE(v, k, hash(x))ii to all;

30 when received {hPREPARE(v, k, h)ij | pj ∈ Q} = C

for a quorum Q

pre: curr_view = v ∧ phase[k] = preprepared ∧
status = normal ∧ hash(log[k]) = h;

(prep_log, prep_view, cert, phase)[k] ←
(log[k], curr_view, C, prepared);

send hCOMMIT(v, k, h)ii to all;

31

32

33

34 when received {hCOMMIT(v, k, h)ij | pj ∈ Q} = C

for a quorum Q

35

36

37

pre: curr_view = v ∧ phase[k] = prepared ∧

status = normal ∧ hash(prep_log[k]) = h;
(commit_log, phase)[k] ← (log[k], committed);
broadcast hDECISION(commit_log[k], k, C);

38 when commit_log[last_delivered + 1] 6= ⊥
39

last_delivered ← last_delivered + 1;
if commit_log[last_delivered] 6= nop then

40

41

42

43

44

45

46

47

48

49

50

deliver(commit_log[last_delivered])

remove(queue, commit_log[last_delivered]);
if status = normal then

if last_delivered = curr_view · B then

stop_all_timers();
advance();
status ← advanced;

else if last_delivered > (curr_view − 1) · B then

stop_timer(timer_delivery);
start_timer(timer_delivery, dur_delivery);

51 when received DECISION(x, k, C)
52

pre: commit_log[k] 6= ⊥ ∧

∃v. committed(C, v, k, hash(x));

53

commit_log[k] ← x;

Figure 11 Normal protocol operation of PBFT-rotation at a process pi.

D.1 Proof of Liveness for PBFT-rotation

Assume that PBFT-rotation is used with an SMR synchronizer satisfying the speciﬁcation in
Figure 1; to simplify the following latency analysis, we assume d = 2δ, as for the synchronizer
in Figure 3. We now prove that the protocol satisﬁes the Liveness property of Byzantine
atomic broadcast. First, due to the periodic leader rotation mechanism in PBFT-rotation,
we can prove that it satisﬁes Proposition 2, stating that processes keep entering views forever.
The proof is similar to the one in §3, using the properties of the SMR synchronizer and the
following lemma, analogous to Lemma 4 in the proof of PBFT-light. The lemma shows that
a correct process stuck in a view will eventually call advance, either because it has delivered
a full batch of values or because one of its timers has expired.

M. Bravo, G. Chockler, and A. Gotsman

41

54 upon new_view(v)
55

56

57

58

59

stop_all_timers();
curr_view ← v;
status ← initializing;
send hNEW_LEADER(curr_view, prep_view,
prep_log, cert)ii to leader(curr_view);

start_timer(timer_recovery,

dur_recovery);

60 when received

{hNEW_LEADER(v, prep_viewj,
prep_logj, certj)ij | pj ∈ Q} = M
for a quorum Q

61

pre: pi = leader(v) ∧ curr_view = v ∧

status = initializing ∧
∀m ∈ M. ValidNewLeader(m));

62

63

64

65

forall k do

if ∃pj0 ∈ Q. prep_viewj0 [k] 6= 0 ∧
(∀pj ∈ Q. prep_viewj[k] ≤
prep_viewj0 [k]) then

log0[k] ← prep_logj0 [k]

next ← (v − 1) · B + 1;

66

67

68

69

70

forall k = 1..(next − 1) do

if log0[k] = ⊥ ∨
∃k0. k0 6= k ∧ log0[k0] = log0[k] ∧
∃pj0 ∈ Q. ∀pj ∈ Q.
prep_viewj0 [k0] > prep_viewj[k] then

log0[k] ← nop

send hNEW_STATE(v, log0, M )ii to all;
start_timer(timer_broadcast, T );

71 when received hNEW_STATE(v, log0, M )ij = m
72

pre: status = initializing ∧

curr_view = v ∧ ValidNewState(m);

stop_timer(timer_recovery);
log ← log0;
if last_delivered ≥ curr_view · B then

advance();
status ← advanced;

else

forall {k | log[k] 6= ⊥} do

phase[k] ← preprepared;
send hPREPARE(v, k, hash(log[k]))ii

to all;

start_timer(timer_delivery, dur_delivery);
status ← normal;

73

74

75

76

77

78

79

80

81

82

83

Figure 12 View-initialization protocol of PBFT-rotation at a process pi.

(cid:73) Lemma 46. Assume that a correct process pi enters a view v. If pi never enters a view
higher than v, then it eventually calls advance in v.

Proof. We prove the proposition by contradiction: assume that pi does not call advance
while in v. When a timer expires, a correct process calls advance. Thus, no timer expires at
pi while in v. This implies that pi receives a NEW_STATE message from leader(v) and stops
timer_recovery. If last_delivered ≥ curr_view · B when pi handles the NEW_STATE message,
then it calls advance, which is impossible. Thus, pi has last_delivered < curr_view · B when
it handles the NEW_STATE message. Therefore, it starts timer_delivery. Since no timer expires
at pi while in v, then pi must stop timer_delivery before it expires. The process pi stops
timer_delivery in lines 45, 49 and 55. We consider each one of these in turn. If timer_delivery is
stopped at line 45, then pi calls advance, which is impossible. If timer_delivery is stopped at
line 55, then pi enters a view > v, which is impossible. Therefore, pi must stop timer_delivery
by executing line 49. In this case pi has delivered a value at a position k > (curr_view − 1) · B.
After stopping timer_delivery at line 49, pi starts timer_delivery again. Every time pi executes
line 49, it increases last_delivered by one (line 39). Given that this is the only place where
last_delivered is assigned, we can conclude that last_delivered never decreases. Then pi cannot
be restarting timer_delivery indeﬁnitely. Eventually, the variable last_delivered at pi will be
equal to curr_view · B, in which case pi will execute line 45. But we have established that pi
cannot execute line 45, which reaches a contradiction. Hence, pi calls advance while in v, as
(cid:74)
required.

(cid:73) Lemma 47. In any execution of PBFT-rotation: ∀v. ∃v0. v0 > v ∧ Eﬁrst(v0)↓.

Proof. Since all correct processes call advance at the beginning, by Startup some correct

42

Liveness and Latency of Byzantine State-Machine Replication

process eventually enters view 1. Assume now that the proposition is false, so that there
exists a maximal view v entered by any correct process. Let P be any set of f + 1 correct
processes and consider an arbitrary process pi ∈ P that enters v. Since no correct process
enters a view v0 > v, by Lemma 46, pi calls advance in v. Since pi was picked arbitrarily,
we have ∀pi ∈ P. Ei(v)↓ =⇒ Ai(v)↓. Then by Progress we get Eﬁrst(v + 1)↓, which yields a
(cid:74)
contradiction.

(cid:73) Lemma 48. In any execution of PBFT-rotation: ∀v. v > 0 =⇒ Eﬁrst(v)↓.

Proof. Follows from Lemma 47 and Proposition 1.

(cid:74)

Let V 0 be the minimal view such that V 0 ≥ V (for the V from Figure 1) and Eﬁrst(V 0) ≥
GST; such a view exists by Lemma 48. Hence, starting from V 0, process clocks track real time
and messages sent by correct processes are delivered within δ. We denote by dur_deliveryi(v)
and dur_recoveryi(v) respectively the value of the dur_delivery and dur_recovery variable at a
correct process pi while in view v. We now prove a lemma analogous to Lemma 6 in the
proof of PBFT-light. It shows that, in any view v ≥ V 0 with a correct leader, if the timeouts
at a correct process pi that enters v are long enough and some timer expires at pi, then this
process cannot be the ﬁrst to initiate a view change.

(cid:73) Lemma 49. Let v ≥ V 0 be a view such that leader(v) is correct, and let pi be a correct process
that enters v. Assume that dur_deliveryi(v) > max{4δ, T + 3δ} and dur_recoveryi(v) > 4δ. If
a timer expires at pi in v, then pi is not the ﬁrst correct process to call advance in v.

The proof relies on the following technical lemma.

(cid:73) Lemma 50. Let v be a view such that leader(v) is correct and sends NEW_STATE(v, log0, _).
Let pi be a correct process that enters v. Assume that pi does not leave v or call advance in
v before t1, processes NEW_STATE(v, log0, _) at t2 and receives m = PREPREPARE(v, k, x) from
leader(v) at t3 < t1. Then pi processes m at t = max{t2, t3}.

Proof. The process pi processes a PREPREPARE message if the conditions in line 27 are
satisﬁed. Since leader(v) sends m, we have pj = leader(v) and valid(x). By line 65 and line 15,
leader(v) only proposes values for positions between (v − 1) · B + 1 and v · B. Then k ≤ v · B.
By line 27, in any view v0 < v, pi can only have accepted proposals for k0 ≤ (v − 1) · B.
Then, when pi enters v, it has phase[k00] = start for all k00 > (v − 1) · B. Furthermore,
by line 23, the leader does not propose a value for the same position twice. Then it is
guaranteed that phase[k] = start from Ei(v) until pi processes m or leaves v. Furthermore,
when pi enters v, it sets curr_view = v. This holds at least until pi leaves v, which cannot
happen before t1. Thus, we have that phase[k] = start and curr_view = v from Ei(v) until
pi processes m or leaves v.

When pi processes NEW_STATE(v, log0, _), it sets status = normal and log = log0, which is
the initial log of leader(v). Since, leader(v) is correct, any value proposed by leader(v) is not
in its log. Thus, we have that status = normal and ∀k0. log[k0] 6= x at pi from the moment
pi processes NEW_STATE(v, log0, _), i.e., from t2, until pi processes m or leaves v.

Therefore, after processing NEW_STATE(v, log0, _) and before processing m or leaving v,
the conditions in line 27 are satisﬁed. Since t3 < t1, then pi processes m. If t3 < t2, then pi
processes m at t2. Otherwise, it processes it at t3. Hence, pi processes m at t = max{t2, t3},
(cid:74)
as required.

Proof of Lemma 49. Since v ≥ V 0, we have Eﬁrst(v) ≥ GST, so that all messages sent by
correct processes after Eﬁrst(v) get delivered to all correct processes within δ and process

M. Bravo, G. Chockler, and A. Gotsman

43

clocks track real time. We now make a case split on which timer expires at pi in v. We
ﬁrst consider the case of timer_recovery. By contradiction, assume that pi is the ﬁrst correct
process to call advance in v. The process starts its timer_recovery when it enters a view
(line 54), and hence, at Eﬁrst(v) at the earliest. Because pi is the ﬁrst correct process to call
advance in v and dur_recoveryi(v) > 4δ at pi, no correct process calls advance in v until
after Eﬁrst(v) + 4δ. Then by Bounded Entry all correct processes enter v by Eﬁrst(v) + 2δ.
Furthermore, by Validity no correct process can enter v + 1 until after Eﬁrst(v) + 4δ, and
by Proposition 1, the same holds for any view > v. Thus, all correct processes stay in v
at least until Eﬁrst(v) + 4δ. When a correct process enters a view, it sends a NEW_LEADER
message to the view’s leader, and when the leader receives a quorum of such messages,
it sends a NEW_STATE message. Since Elast(v) ≤ Eﬁrst(v) + 2δ, leader(v) is guaranteed to
receive NEW_LEADER message from a quorum of processes and send a NEW_STATE message to
all processes by Eﬁrst(v) + 3δ. Thus, all correct processes receive the NEW_STATE message by
Eﬁrst(v) + 4δ. In particular, this is the case for pi. Since pi’s timer_recovery has not expired
by then, the process stops the timer, which contradicts our assumption.

We now consider the case when timer_delivery expires at pi in v. We again prove it
by contradiction: assume that pi is the ﬁrst correct process to call advance in v. The
process starts its timer_delivery after handling the leader’s NEW_STATE(v, _, _) message if
last_delivered < v·B or after delivering a value whose position k in log is such that (v−1)·B <
k < v · B. We only consider the former case; the latter is analogous. Let t1 be the
time when pi starts the timer_delivery that expires and let t2 be the ﬁrst time when a
correct process calls advance in v. We have assumed that timer_delivery expires at pi in v,
dur_deliveryi(v) > max{4δ, T + 3δ} and pi is the ﬁrst correct process that calls advance in v.
Hence, t2 > t1 + max{4δ, T + 3δ}. Then by Validity no correct process can enter v + 1 by t2,
and by Proposition 1, the same holds for any view > v. Furthermore, t1 ≥ Eﬁrst(v). Then
by Bounded Entry all correct processes enter v by t1 + 2δ.

All correct processes receive the leader’s NEW_STATE(v, _, _) by t1 + δ. Therefore, they
handle it by t1 + 2δ: once they have received it and entered v.
If a correct process
has last_delivered ≥ v · B by the time it handles the leader’s NEW_STATE(v, _, _), then
it calls advance. We have established that no correct process calls advance until after
t1 + max{4δ, T + 3δ}. Since all correct processes handle the leader’s NEW_STATE(v, _, _) by
t1 + 2δ, then all correct processes have last_delivered < v · B by the time they handle the
leader’s NEW_STATE(v, _, _). Thus, all correct processes send a PREPARE for all positions
≤ (v − 1) · B by t1 + 2δ. It then takes them at most 2δ to exchange the sequence of PREPARE
and COMMIT message leading to commit all positions ≤ (v − 1) · B. Since t1 + 4δ < t2, all
correct processes have last_delivered ≥ (v − 1) · B by t1 + 4δ.

Assume that leader(v) sends NEW_STATE(v, _, _) at t3. Since at this time, leader(v) starts
timer_proposal, the leader makes a new proposal no later than t3 + T . Thus, all correct
processes receive the corresponding message PREPREPARE(v, k, _) from leader(v) by t3+T +δ <
t1 + T + δ. Since leader(v) is correct, k = (v − 1) · B + 1 (line 65). Let t4 be the time when all
correct processes handle m. By Lemma 50, t4 ≤ max{t1 + 2δ, t1 + T + δ}. Then it takes them
at most 2δ to exchange the sequence of PREPARE and COMMIT message leading to commit.
Thus, all correct processes receive COMMIT(v, k, _) by t4 + 2δ. We have earlier established
that t2 > t1 + max{4δ, T + 3δ}. Then t2 > max{t4 + 2δ, t1 + 4δ}. Since no correct process
leaves v by t2 and by t1 + 4δ the process pi has last_delivered ≥ (v − 1) · B, then by this
time pi executes the handler in line 38 for the position k. Since k = (v − 1) · B + 1, then pi
(cid:74)
executes line 49 and stops timer_delivery, which contradicts our assumption.

44

Liveness and Latency of Byzantine State-Machine Replication

Using Lemma 49, we can establish two key facts necessary to prove the liveness of
PBFT-light, which are stated by the lemma below. Fact 1 is analogous to Lemma 5 in the
proof of PBFT-light. It establishes that in any view v ≥ V 0 where the leader is correct and
the timeouts at all correct processes are high enough, some correct process will deliver a full
batch of values. Fact 2 rules out the scenarios discussed at the end of §4, in which some
processes increase their timeouts suﬃciently while others do not. It establishes that in a
view v ≥ V 0 with a correct leader that does not operate normally (no correct process delivers
a full batch of values), a process pi with suﬃciently high timeouts cannot be the ﬁrst one to
call advance. This means some other process with lower timeouts will have to initiate the
view change, and thus increase its timeouts.

(cid:73) Lemma 51. Consider a view v ≥ V 0 such that leader(v) is correct.
1. If dur_deliveryi(v) > max{4δ, T + 3δ} and dur_recoveryi(v) > 4δ at each correct processes
pi that enters v, then some correct process calls advance in v due to delivering a full
batch of values (line 46).

2. Assume that no correct process calls advance in v due to delivering a full batch of
values (line 46). If pi is a correct process that enters v and we have dur_deliveryi(v) >
max{4δ, T + 3δ} and dur_recoveryi(v) > 4δ, then pi cannot be the ﬁrst correct process to
call advance in v.

Proof. By Lemma 48, a correct process eventually enters view v + 1. Then by Validity there
must exist a correct process that calls advance while in v. Let pj be the ﬁrst correct process
that does so. This process must call advance when: (i) a timer expires; or (ii) it delivers the
full batch of values (line 46).

Case 1. We have dur_deliveryj(v) > max{4δ, T + 3δ} and dur_recoveryj(v) > 4δ. Then

by Lemma 49, (i) is impossible, so that (ii) must hold.

Case 2. By contradiction, assume that pi = pj. Since no correct process calls advance
in v due to delivering a full batch of values, (ii) is impossible. But since dur_deliveryi(v) >
(cid:74)
max{4δ, T + 3δ} and dur_recoveryi(v) > 4δ, by Lemma 49, (i) is impossible either.

(cid:73) Theorem 52. PBFT-rotation satisﬁes the Liveness property of Byzantine atomic broadcast.

Proof. Consider a valid value x broadcast by a correct process. We ﬁrst prove that x is
eventually delivered by some correct process. By contradiction, assume that x is never
delivered by a correct process. A correct process broadcasts a value until it is delivered
(line 11). When a correct process receives a valid value that is not in its queue, it appends
the value (line 14). Thus, since x is never delivered, there exists a point in time t starting
from which x is always in the queues of all correct processes. By Lemma 48, every view is
entered by at least one correct process. Let view v1 be the ﬁrst view such that v1 ≥ V 0 and
Eﬁrst(v1) ≥ t.

(cid:66) Claim 1.
In any view v ≥ v1 with a correct leader, if a correct process calls advance
due to delivering a full batch of values (line 46), then leader(v) eventually removes B values
preceding x from its queue.

Proof. Consider a view v ≥ v1 with a correct leader where a correct process pi calls advance
at line 46. Then it delivers a full batch of values proposed by the leader of v, which are all
distinct from x. Since leader(v) is correct and x is forever in its queue, we have two options:
(i) all values proposed by the leader in v are distinct from nop and precede x in the leader’s
queue; or (ii) ∃k ≤ (v − 1) · B. log[k] = x at leader(v). But the latter is impossible. Indeed,
since pi delivers a full batch, it delivers all values whose position in its log is ≤ v · B. Since

M. Bravo, G. Chockler, and A. Gotsman

45

the log of the leader and pi is the same for those positions when pi calls advance, if (ii)
holds, then x is delivered. Hence, (i) must hold. Since pi reliably broadcasts committed
values (line 37), the protocol guarantees that if a correct process delivers a value, all correct
processes eventually do. Thus, leader(v) will eventually deliver these values and remove them
(cid:67)
from its queue.

(cid:66) Claim 2.
In any view ≥ v1 with a correct leader, at least one correct process calls advance
because one of its timers expires (line 5), and no correct process calls advance because it
delivers a full batch of values (line 46).

Proof. Assume that the claim does not hold. By Lemma 48 and since leaders rotate round-
robin across views, there are inﬁnitely many views ≥ v1 with a correct leader that are entered
by a correct process. Furthermore, by Validity, at least one correct process calls advance in
each of these. Since we assume that the claim is false, there is a correct process pi that leads
an inﬁnite number of views ≥ v1 in which some correct process calls advance at line 46. By
Claim 1, for each such view pi eventually removes B values preceding x from its queue. In
views ≥ v1 no new values are added to pi’s queue before x. Hence, there exists a view ≥ v1
in which x is proposed and a correct process calls advance at line 46, thus delivering x. This
(cid:67)
reaches a contradiction.

(cid:66) Claim 3. Every correct process calls the timer expiration handler (line 3) inﬁnitely often.

Proof. Assume this is not the case and let Cﬁn and Cinf be the sets of correct processes that
call the timer expiration handler ﬁnitely and inﬁnitely often, respectively. Then Cﬁn 6= ∅,
and by Claim 2, Cinf 6= ∅. The values of dur_delivery and dur_recovery increase unboundedly
at processes from Cinf , and do not change after some view v2 at processes from Cﬁn. By
Lemma 48 and since leaders rotate round-robin, there exists a view v3 ≥ max{v2, v1} with a
correct leader such that for any process pi ∈ Cinf that enters v3 we have dur_deliveryi(v3) >
max{4δ, T + 3δ} and dur_recoveryi(v3) > 4δ. By Claim 2, at least one correct process calls
advance because one of its timers expires in v3; let pl be the ﬁrst process to do so. Since
v3 ≥ v2, this cannot be a process from Cﬁn, since none of these processes can increase their
(cid:67)
timers in v3. Hence, pl ∈ Cinf , which contradicts Lemma 51(2).

We now prove that x is delivered by a correct process. By Claim 3 and Lemma 48, there
exists a view v4 ≥ v1 with a correct leader such that for any correct process pi that enters v4
we have dur_deliveryi(v4) > max{4δ, T + 3δ} and dur_recoveryi(v4) > 4δ. By Lemma 51(1),
some correct process calls advance in v4 due to delivering a full batch of values (line 46).
This contradicts Claim 2 and thus proves that x is delivered by a correct process. By reliably
broadcasting committed values (line 37), the protocol guarantees that if a correct process
delivers a value, then all correct eventually do. From here the Liveness property follows. (cid:74)

D.2 Latency Bounds for PBFT-rotation

Assume that PBFT-rotation is used with our SMR synchronizer in Figure 3. We now
quantify its latency using the bounds for the synchronizer in Theorem 3. We again assume
the existence of a known upper bound ∆ on the maximum value of the post-GST message
delay. We also modify the protocol in Figure 4 so that in lines 7-8 it does not increase
dur_recovery and dur_delivery above 4∆ and max{4∆, T +3∆}, respectively. This corresponds
to the bounds in Lemma 51(1) and preserves the protocol liveness.

We establish latency bounds for two scenarios key to the protocol’s performance. Our
ﬁrst bound considers the case when the protocol starts during the asynchronous period,

46

Liveness and Latency of Byzantine State-Machine Replication

before GST. We quantify how quickly after GST the protocol enters the ﬁrst functional view
V in which a correct leader can propose a full batch of B values that will be delivered by all
correct processes. This view V is the same as the one in Bounded Entry for our synchronizer,
deﬁned by Theorem 3. For simplicity, we assume that timeouts are high enough at GST.

(cid:73) Theorem 53. Assume that all correct processes start executing PBFT-rotation before GST
and that at GST each of them has dur_recovery > 4δ and dur_delivery > {4δ, T + 3δ}. Let V
be deﬁned as in Theorem 3. Then Elast(V) ≤ GST + ρ + 4∆ + B · max{4∆, T + 3∆} + 3δ, and
if leader(V) is correct, it proposes B values in V that are delivered by all correct processes.

Intuitively, the bound in the theorem captures worst-case scenarios in which some correct
processes may need to spend up to time 4∆ + B · max{4∆, T + 3∆} in a non-functional view
V − 1, e.g., to commit B nop values generated by a Byzantine leader. The theorem shows
that PBFT-rotation, like PBFT-light, recovers after a period of asynchrony in bounded time.
We now prove Theorem 53. The following lemma bounds the latency of entering V = 1.

(cid:73) Lemma 54. Assume that all correct processes starts executing PBFT-rotation before GST.
If V = 1, and some correct process enters V, then any correct process that enters V will do
that no later than at GST + ρ + δ.

Proof. When a correct process starts the protocol, it calls advance from view 0 unless it
has already entered a higher view. Therefore, Tlast(0) < GST. Applying the ﬁrst clause of
(cid:74)
Property B, we get Elast(1) ≤ max(Tlast(0), GST + ρ) + δ = GST + ρ + δ, as required.

We next consider the case of V > 1.

(cid:73) Lemma 55. Assume that all correct process starts executing PBFT-rotation before GST
and at GST each correct process has dur_recovery > 4δ and dur_delivery > max{4δ, T + 3δ}.
Then, if V > 1, and some correct process enters V, then Elast(V) ≤ GST + ρ + 4∆ + B ·
max{4∆, T + 3∆} + 3δ.

Proof. Since some correct process enters V > 1, by Proposition 1, some correct process
enters the view V − 1 as well. Let pi be a correct process that enters V − 1. We show that

Ti(V − 1) ≤ Ei(V − 1) + 4∆ + B · max{4∆, T + 3∆}.

(24)

If pi enters a view > V − 1 before Ei(V − 1) + 4∆ + B · max{4∆, T + 3∆}, then (24) holds.
Suppose now that pi does not enter a view > V −1 before Ei(V −1)+4∆+B·max{4∆, T +3∆}.
By the structure of the code, at Ei(V − 1), pi starts timer_recovery for the duration
dur_recoveryi(V − 1). If timer_recovery expires before pi receives NEW_STATE(V − 1, _, _) from
leader(V − 1), pi attempts to advance from V − 1. Since dur_recoveryi(V − 1) ≤ 4∆, (24)
holds. Otherwise, pi stops timer_recovery. Assume that pi has last_delivered ≥ curr_view · B
when it stops timer_recovery. Then, pi calls advance by Ei(V − 1) + dur_recoveryi(V − 1).
Since dur_recoveryi(V − 1) ≤ 4∆, (24) holds. Assume now that pi has last_delivered <
curr_view · B when it stops timer_recovery. Therefore, it starts timer_delivery for the duration
dur_deliveryi(V − 1). If timer_delivery expires, then pi calls advance by

Ei(V − 1) + dur_recoveryi(V − 1) + dur_deliveryi(V − 1).

Since dur_recoveryi(V − 1) ≤ 4∆ and dur_deliveryi(V − 1) ≤ max{4∆, T + 3∆}, (24) holds.
If pi stops timer_delivery, then it delivers a value at a position > (curr_view − 1) · B. Then
pi restarts and stops timer_delivery every time a new value is delivered, until it delivers the

M. Bravo, G. Chockler, and A. Gotsman

47

value at position curr_view · B or timer_delivery expires. In both cases, pi attempts to advance
from V − 1 by

Ei(V − 1) + dur_recoveryi(V − 1) + B · dur_deliveryi(V − 1).

Since dur_recoveryi(V − 1) ≤ 4∆ and dur_deliveryi(V − 1) ≤ max{4∆, T + 3∆}, (24) holds.
Since pi was picked arbitrarily, we can conclude that every correct process that enters
V − 1 either attempts to advance from it or enters a higher view no later than at Elast(V −
1) + 4∆ + B · max{4∆, T + 3∆}, and therefore, (24) holds. By Property A,

Elast(V − 1) ≤ max(Eﬁrst(V − 1), GST + ρ) + 2δ.

Since by the deﬁnition of V, Eﬁrst(V − 1) ≤ GST + ρ, we have

Elast(V − 1) ≤ GST + ρ + 2δ.

Thus,

Tlast(V − 1) ≤ Elast(V − 1) + 4∆ + B · max{4∆, T + 3∆} ≤

GST + ρ + 2δ + 4∆ + B · max{4∆, T + 3∆}.

We can now apply the ﬁrst clause of Property B to obtain

Elast(V) ≤ max(Tlast(V − 1), GST + ρ) + δ

≤ max(GST + ρ + 2δ + 4∆ + B · max{4∆, T + 3∆}, GST + ρ) + δ

≤ GST + ρ + 4∆ + B · max{4∆, T + 3∆} + 3δ,

as required.

(cid:74)

Proof of Theorem 53. By Lemma 48, some correct process eventually enters V. By the
theorem’s premise, all correct processes start the protocol before GST. Thus, by Lemma 54,

Elast(1) ≤ GST + ρ + δ < GST + ρ + 4∆ + B · max{4∆, T + 3∆} + 3δ.

And, if V > 1, then by Lemma 55,

Elast(V) ≤ GST + ρ + 4∆ + B · max{4∆, T + 3∆} + 3δ.

Since the timeout durations are monotone, the theorem’s assumption about timeout durations
implies that for any process pi that enters V

dur_recoveryi(V) > 4δ ∧ dur_deliveryi(V) > max{4δ, T + 3δ}.

By Lemma 51(1), some correct process calls advance in V due to delivering a full batch of
B values proposed by leader(V). By reliably broadcasting committed values, the protocol
guarantees that all these values will be eventually delivered by all correct processes, as
(cid:74)
required.

Our next bound assumes that the protocol executes during a synchronous period and
quantiﬁes how quickly it recovers after encountering a view v with a faulty leader. For
simplicity, we assume that this leader is initially crashed and the views < v operated normally.

48

Liveness and Latency of Byzantine State-Machine Replication

(cid:73) Theorem 56. Assume that all correct processes start executing PBFT-rotation after
GST, and consider a view v such that leader(v) is initially crashed. Suppose that initially
dur_recovery > 4δ and dur_delivery > max{4δ, T + 3δ} and, in each view v0 < v, each
correct process calls advance due to delivering a full batch of values proposed in v0. Then
Elast(v + 1) ≤ Elast(v) + R + δ, where R is the initial value of dur_recovery. Furthermore, if
leader(v + 1) is correct, then it proposes B values in v + 1 that are delivered by all correct
processes.

The bound established by the theorem illustrates the beneﬁts of how PBFT-rotation (as well
as PBFT) manages timeouts. Since processes do not increase timeouts in good views with
correct leaders, they pay a minimal latency penalty once they encounter a bad leader.

We now prove Theorem 56. The following lemma bounds the latest time by which a
correct process process can enter view v + 1 assuming the leader of view v > 0 is initially
crashed.

(cid:73) Lemma 57. Assume that all correct processes start executing PBFT-rotation after GST,
and consider a view v > 0 such that leader(v) is initially crashed. Suppose that any correct
processes pi that enters v has dur_recoveryi(v) = R. If a correct process enters v + 1, then
Elast(v + 1) ≤ Elast(v) + R + δ.

Proof. Since some correct process enters v + 1, by Proposition 1, Eﬁrst(v)↓. Consider a
correct process pi that enters v, and assume that pi does not enter any views > v before
Ei(v) + R. By the protocol, pi starts timer_recovery at Ei(v) to await NEW_STATE(v, _, _)
from leader(v). Since pi starts executing after GST, its local clock advances at the same rate
as real time. Thus, given that leader(v) is initially crashed, the pi’s timer_recovery will expire
at Ei(v) + dur_recoveryi(v) = Ei(v) + R. Hence, pi calls advance at Ei(v) + R. Therefore,
all correct processes that enter v either attempt to advance from v, or enter a view > v no
later than at Elast(v) + R. Hence,

Tlast(v) ≤ Elast(v) + R.

Since all correct processes start executing the protocol after GST, Aﬁrst(0) ≥ GST, and
therefore, by Property B,

Elast(v + 1) ≤ Tlast(v) + δ ≤ Elast(v) + R + δ,

as required.

(cid:74)

Proof of Theorem 56. Since in each view v0 < v all correct processes deliver B values
proposed in v0, by the structure of the code, no correct process increases the durations of any
of its timers. Thus, dur_recoveryi(v) = R for any correct processes pi that enters v, where R
is the initial value of dur_recovery. Therefore, by Lemma 57, Elast(v + 1) ≤ Elast(v) + R + δ.
Suppose that leader(v + 1) is correct. Then by the theorem’s assumption about the initial
timeout durations, and since all timeout durations are monotone, we have that for any correct
process pi that enters v

dur_recoveryi(v + 1) > 4δ ∧ dur_deliveryi(v + 1) > max{4δ, T + 3δ}.

Hence, by Lemma 51(1), some correct process calls advance in v + 1 due to delivering a full
batch of B values proposed by leader(v + 1). By reliably broadcasting committed values, the
protocol guarantees that all these values will be eventually delivered by all correct processes,
(cid:74)
as required.

M. Bravo, G. Chockler, and A. Gotsman

49

1 when the process starts

30 when received {hPREPARE(v, k, h)ij | pj ∈ Q} = C

2

advance();

for a quorum Q

3 when timer_delivery or timer_recovery

expires

4

5

6

7

8

stop_all_timers();
advance();
status ← advanced;
dur_delivery ← dur_delivery + τ ;
dur_recovery ← dur_recovery + τ ;

9 function broadcast(x)
pre: valid(x);
10
send hBROADCAST(x)ii to all

11

periodically until x is delivered

35

36

37

31

32

33

pre: curr_view = v ∧ phase[k] = preprepared ∧
status = normal ∧ hash(log[k]) = h;

(prep_log, prep_view, cert, phase)[k] ←
(log[k], curr_view, C, prepared);
send hPRECOMMIT(v, k, h)ii to all;

34 when received {hPRECOMMIT(v, k, h)ij | pj ∈ Q} = C

for a quorum Q

pre: curr_view = v ∧ phase[k] = prepared ∧

status = normal ∧ hash(prep_log[k]) = h;

(lock_view, phase)[k] ←
(curr_view, precommitted);
send hCOMMIT(v, k, h)ii to all;

12 when received BROADCAST(x)
pre: valid(x) ∧ x 6∈ queue ∧
13

(∀k. k ≤ last_delivered =⇒
commit_log[k] 6= x);
queue ← append(queue, x);

14

15 when status = normal ∧

pi = leader(curr_view) ∧
next ≤ curr_view · B ∧
∃x ∈ queue. ∀k. log[k] 6= x
x ← the ﬁrst value in queue that

is not in log;

stop_timer(timer_broadcast);
propagate(x);

16

17

18

19 when timer_broadcast expires
20

propagate(nop);

21 function propagate(x)
22

send hPREPREPARE(curr_view,

next, x)ii to all;
next ← next + 1;
if next ≤ curr_view · B then

start_timer(timer_broadcast, T )

23

24

25

26 when received hPREPREPARE(v, k, x)ij
27

pre: pj = leader(v) ∧ curr_view = v ∧

status = normal ∧
phase[k] = start ∧
k ≤ v · B ∧ valid(x) ∧
(∀k0. log[k0] 6= x);

28

29

(log, phase)[k] ← (x, preprepared);
send hPREPARE(v, k, hash(x))ii to all;

38 when received {hCOMMIT(v, k, h)ij | pj ∈ Q} = C

for a quorum Q

39

pre: curr_view = v ∧

phase[k] = precommitted ∧
status = normal ∧ hash(prep_log[k]) = h;
(commit_log, phase)[k] ← (log[k], committed);
broadcast hDECISION(commit_log[k], k, C);

40

41

42 when commit_log[last_delivered + 1] 6= ⊥ ∧

status = normal

43

44

45

46

47

48

49

50

51

52

53

54

last_delivered ← last_delivered + 1;
if commit_log[last_delivered] 6= nop then

deliver(commit_log[last_delivered])

remove(queue, commit_log[last_delivered]);
if status = normal then

if last_delivered = curr_view · B then

stop_all_timers();
advance();
status ← advanced;

else if last_delivered > (curr_view − 1) · B then

stop_timer(timer_delivery);
start_timer(timer_delivery, dur_delivery);

55 when received DECISION(x, k, C)
56

pre: commit_log[k] 6= ⊥ ∧

∃v. committed(C, v, k, hash(x));

57

commit_log[k] ← x;

Figure 13 Normal protocol operation of HotStuﬀ at a process pi.

E

A HotStuﬀ-like Protocol Using an SMR Synchronizer

In this section we demonstrate how an SMR synchronizer can be used to implement Byzantine
SMR protocols following the approach of HotStuﬀ [56], which reduces the communication
complexity of leader change. Figures 13-15 present a corresponding modiﬁcation of PBFT-
rotation, which we call HotStuﬀ-light. For brevity, we eschew the use of threshold signatures,

50

Liveness and Latency of Byzantine State-Machine Replication

58 upon new_view(v)
59

60

61

62

63

stop_all_timers();
curr_view ← v;
status ← initializing;
send hNEW_LEADER(curr_view, prep_view,
prep_log, cert)ii to leader(curr_view);

start_timer(timer_recovery,

dur_recovery);

64 when received

{hNEW_LEADER(v, prep_viewj,
prep_logj, certj)ij | pj ∈ Q} = M
for a quorum Q

65

pre: pi = leader(v) ∧ curr_view = v ∧

status = initializing ∧
∀m ∈ M. ValidNewLeader(m);

66

67

68

69

70

71

72

73

forall k do

if ∃pj0 ∈ Q. prep_viewj0 [k] 6= 0 ∧
∀pj ∈ Q. prep_viewj[k] ≤
prep_viewj0 [k] then

log0[k] ← prep_logj0 [k];
prep_view0[k] ← prep_viewj0 [k];
cert0[k] ← certj0 [k]
next ← (v − 1) · B + 1;
send hNEW_STATE(v, log0, prep_view0,
cert0)ii to all;
start_timer(timer_broadcast, T );

74 when received

hNEW_STATE(v, log0, prep_view0, cert0)ij = m

pre: status = initializing ∧

curr_view = v ∧ ValidNewState(m);

stop_timer(timer_recovery);
log ← log0;
forall k = 1..(v − 1) · B do

if log0[k] = ⊥ ∨
∃k0. k0 6= k ∧ log0[k0] = log0[k] ∧
prep_view0[k0] > prep_view[k] then

log0[k] ← nop

if last_delivered ≥ curr_view · B then

advance();
status ← advanced;

else

forall k = 1..(v − 1) · B do

phase[k] ← preprepared;
send hPREPARE(v, k, hash(log0[k]))ii
to all;

start_timer(timer_delivery,

dur_delivery);
status ← normal;

75

76

77

78

79

80

81

82

83

84

85

86

87

88

89

Figure 14 View-initialization protocol of HotStuﬀ at a process pi.

prepared(C, v, k, h) ⇐⇒ ∃Q. quorum(Q) ∧ C = {hPREPARE(v, k, h)ij | pj ∈ Q}
committed(C, v, k, h) ⇐⇒ ∃Q. quorum(Q) ∧ C = {hCOMMIT(v, k, h)ij | pj ∈ Q}

ValidNewLeader(hNEW_LEADER(v, prep_view, prep_log, cert)i_) ⇐⇒

∀k. (prep_view[k] > 0 =⇒ prep_view[k] < v ∧ prepared(cert[k], prep_view[k], k, prep_log[k]))

ValidNewState(hNEW_STATE(v, log, prep_view, cert)ii) ⇐⇒
pi = leader(v) ∧ (∀k. lock_view[k] > 0 =⇒ log[k] 6= ⊥) ∧
(∀k. log[k] 6= ⊥ =⇒ v > prep_view[k] > lock_view[k] ∧
prepared(cert[k], prep_view[k], hash(log[k])))

Figure 15 Auxiliary predicates for HotStuﬀ.

which can reduce the communication complexity even further. HotStuﬀ-light also excludes
optimizations from HotStuﬀ related to maintaining a hash-chain, but these can be added
easily.

HotStuﬀ-light adds an extra message exchange to the normal path of PBFT-rotation,
in between the ones for PREPARE and COMMIT messages. When a process gathers a set of
PREPARE(v, k, hash(x)) messages for a value x from a quorum (line 30), it disseminates a
PRECOMMIT(v, k, hash(x)) message (line 33). The process then waits until it gathers a quorum
of matching PRECOMMIT messages for the value x (line 34) and disseminates the corresponding
COMMIT message. At this point the process also becomes locked on x at position k in view
v, which is recorded by setting the position k of an array lock_view to curr_view (line 36).

M. Bravo, G. Chockler, and A. Gotsman

51

From this point on, the process will not accept a proposal of a diﬀerent value at position k
from a leader of a future view, unless the leader can convince the process that no decision
was reached in curr_view at position k. To this end, we also modify the view-change protocol
of PBFT-rotation. In HotStuﬀ-light the leader of a view v does not forward the set of
NEW_LEADER messages used to compute the view’s initial state in its NEW_STATE message; this
reduces the communication complexity. Instead, a follower checks that the leader’s proposal
is safe using a modiﬁed ValidNewState predicate. This checks that, if a process has previously
locked on a value at a position k, then either the leader proposes the same value for that
position, or its proposal is justiﬁed by a prepared certiﬁcate from a higher view than the lock.
In the latter case the process can be sure that no decision was reached at position k in the
view it is locked on. Finally, HotStuﬀ-light delegates the task of ﬁltering out duplicates to
the followers: a follower cannot check that the leader ﬁlters out duplicates correctly without
receiving the set of NEW_LEADER messages used by the leader to compute the view’s initial
state.

E.1 Proof of Safety for HotStuﬀ-light

Propositions 29, 30 and 33 established for PBFT-light still hold for HotStuﬀ-light. External
Validity can be proved similarly. We next prove Ordering and Integrity.

(cid:73) Proposition 58. The variables curr_view, prep_view[k] and lock_view[k] (for any k) at a
correct process never decrease and we always have lock_view[k] ≤ prep_view[k] ≤ curr_view.

(cid:73) Lemma 59. At a correct process we always have

∀k, k0. log0[k] = log0[k0] 6∈ {⊥, nop} =⇒ k = k0.

Proof. Analogous to that of Lemma 34.

(cid:73) Corollary 60.

∀x, v, k, k0, C, C 0. prepared(C, v, k, hash(x)) ∧ prepared(C 0, v, k0, hash(x)) ∧
wf(C) ∧ wf(C 0) ∧ x 6= nop =⇒ k = k0.

Proof. Analogous to that of Corollary 35.

(cid:73) Lemma 61. Fix k, v, v0, C and x, and assume

committed(C, v, k, hash(x)) ∧ wf(C) ∧ v0 > v.

Then

∀C 0, x0. prepared(C 0, v0, k, hash(x0)) ∧ wf(C 0) =⇒ x = x0.
∀C 0, k0. x 6= nop ∧ prepared(C 0, v0, k0, hash(x)) ∧ wf(C 0) =⇒ k = k0.

(cid:74)

(cid:74)

Proof. We prove the statement of the lemma by induction on v0. Assume this holds for all
v0 < v∗; we now prove it for v0 = v∗. Thus, we have

∀C 00, x00, v00. v < v00 < v0 ∧ prepared(C 00, v00, k, hash(x00)) ∧ wf(C 00) =⇒ x = x00;
(25)
∀C 00, k00, v00. v < v00 < v0 ∧ x 6= nop ∧ prepared(C 00, v00, k00, hash(x)) ∧ wf(C 00) =⇒ k = k00.
(26)

Assume that prepared(C 0, v0, k, hash(x0)) and wf(C 0). Since committed(C, v, k, hash(x)),
a quorum Q of processes sent COMMIT(v, k, hash(x)). Since prepared(C 0, v0, k, hash(x0)), a

52

Liveness and Latency of Byzantine State-Machine Replication

quorum Q0 of processes sent PREPARE(v0, k, hash(x0)). The quorums Q and Q0 have to
intersect in some correct process pi, which has thus sent both COMMIT(v, k, hash(x)) and
PREPARE(v0, k, hash(x0)). Since v < v0, this process pi must have sent the COMMIT message
before the PREPARE message. Before sending the former, the process set lock_view[k] to v
(line 36) and had prep_log[k] = log[k] = x. Assume towards a contradiction that x 6= x0. Let
v00 be the ﬁrst view after v when pi assigned log[k] to some x00 6= x, so that v < v00 ≤ v0.
Then pi must have assigned log[k] to x00 at either line 77 or line 80. When this happened, pi
had log[k] = prep_log[k] = x and, by Proposition 58, lock_view[k] ≥ v > 0.

By the ValidNewState check (line 75), the leader of v00 must have provided a well-formed

prepared certiﬁcate C 00 such that prepared(C 00, v000, k, hash(x00)) for v000 such that

v ≤ lock_view[k] < v000 ≤ v00 ≤ v0.

If pi assigned log[k] to x00 at line 77, then by (25) we get x00 = x, and above we assumed
x00 6= x: a contradiction. If pi assigned log[k] to x00 at line 80 due to a duplicate value at
a position k0 6= k, then x00 = nop and log[k0] = x 6= ⊥. Hence, the leader of v00 had to also
provide a well-formed prepared certiﬁcate C 00 such that prepared(C 00, v000
0 , k0, hash(x)) for v000
0
such that

v ≤ lock_view[k] ≤ v000 < v000

0 < v00 ≤ v0.

Since x 6= x00 = nop, by (26) we get k = k0: a contradiction. Since we reach a contradiction
in both cases, we must have x = x0, as required.

Assume now that x 6= nop, prepared(C 0, v0, k0, hash(x)) and wf(C 0).

Since
committed(C, v, k, hash(x)), a quorum Q of processes sent COMMIT(v, k, hash(x)). Since
prepared(C 0, v0, k0, hash(x)), a quorum Q0 of processes sent PREPARE(v0, k0, hash(x)). The
quorums Q and Q0 have to intersect in some correct process pi, which has thus sent both
COMMIT(v, k, hash(x)) and PREPARE(v0, k0, hash(x)). When pi sent the latter it must have
had log[k0] = x. As before, we can also show that at this moment pi had log[k] = x. By
Lemma 59, the process starts the view v0 with a log without duplications (except nops), and
does not add duplicate entries due to the check at line 21. Hence, we must have k0 = k, as
(cid:74)
required.

(cid:73) Corollary 62. HotStuﬀ-light satisﬁes Ordering and Integrity.

Proof. The same as the proofs of Corollaries 37 and 38, but using the corresponding lemmas
(cid:74)
for HotStuﬀ-light instead of PBFT-light.

E.2 Proof of Liveness for HotStuﬀ-light

The proof of liveness is virtually identical to the one for PBFT-rotation with two exceptions.
First, since HotStuﬀ-light has an extra phase in its normal path, the duration of timer_delivery
in Lemmas 49 and 51 has to be > max{5δ, T + 4δ}. Second, we need to show that in a view v
with a correct leader, if a correct process pi receives a NEW_STATE message m from the leader
of v, then ValidNewState(m) holds at pi. This fact is then used in the proof of Lemma 49 to
show that a process accepts the leader’s NEW_STATE message for the view v once it receives
the message and enters v. The following lemma states this fact.

(cid:73) Lemma 63. Let v ≥ V 0 be a view such that leader(v) is correct, and let pi be a correct process
that enters v. If pi receives the leader’s NEW_STATE message while in v, then ValidNewState(m)
holds at pi.

M. Bravo, G. Chockler, and A. Gotsman

53

Proof. The lemma trivially holds if pi is not locked on a value at any position of its prep_log
array when receiving the NEW_STATE message from the leader of v. We now consider the
case when pi is locked on a value in at least one position when receiving the NEW_STATE
message. Let k be one of the locked positions and let x = pi.prep_log[k] be the value locked
and v0 = pi.lock_view[k] < v be the corresponding view. Since pi locked x in v0, it must
have previously received messages PRECOMMIT(v0, k, hash(x)) from a quorum of processes, at
least f + 1 of which have to be correct. The latter processes must have prepared the value
x in view v0 at position k. When each of these f + 1 correct processes enters view v, it
has curr_view ≥ v0 and thus sends the corresponding value and its prepared certiﬁcate for
the position k in the NEW_LEADER(v, . . .) message to leader(v). The leader is guaranteed to
receive at least one of these messages before making a proposal, since it only does this after
receiving at least 2f + 1 NEW_LEADER messages. Hence, the leader proposes a value x0 for the
position k with a prepared certiﬁcate formed at some view v0 ≥ v0. Furthermore, if v0 = v0,
then by Proposition 33 we have that x0 = x and x is the only value that can be locked at
k and v0 by pi. Thus, pi will accept the leader’s proposal for the position k. Since k was
picked arbitrarily, then pi will accept the leader’s proposal for any locked position. Hence,
(cid:74)
the leader’s NEW_STATE message will satisfy ValidNewState at pi, as required.

F

A Liveness Bug in the Byzantine Consensus of Cachin et al. [19]

Cachin et al.’s book [19, §5.6.4] includes an implementation of Byzantine consensus using
an abstraction that, similarly to our SMR synchronizers, allows clients to ﬂag potential
protocol-speciﬁc failures. We now show that their implementation violates the Termination
property of Byzantine consensus, requiring that every correct process eventually decides
some value. Cachin et al.’s Byzantine Consensus algorithm (Alg. 5.19) relies on a Byzantine
Epoch-Change abstraction (Alg. 5.15) which guarantees that eventually all correct processes
enter the same epoch with a correct leader. The Epoch-Change itself is implemented using
a Byzantine Eventual Leader Detector (Alg. 2.10), which outputs the leader for correct
processes to follow. The Leader Detector considers the current leader faulty if more than
f correct processes have “complained” about its behavior via a special call. In Byzantine
Consensus a process complains about the current leader if it fails to observe a decision within
a given time duration. This, however, results in a problem if some correct processes stop
complaining while others are still unhappy.

To see this, consider an execution of Byzantine Consensus (Alg. 5.19) where all correct
processes enter an epoch e with a faulty leader. The leader may make a valid proposal to
f + 1 correct processes and withhold it from the remaining f correct processes. Since the
consensus algorithm operates based on quorums of 2f + 1 processes, the faulty processes
may then execute the algorithm so that only the f + 1 correct processes that received the
leader’s proposal decide in epoch e. These f + 1 correct processes will then stop complaining.
For the remaining f correct processes to decide, they need to switch to a new epoch with a
correct leader. But they will not be able to achieve this unless faulty processes cooperate,
because to nominate a diﬀerent leader, the Leader Detector requires more than f processes
to complain (Alg. 2.10). This breaks the Eventual Leadership property of Epoch-Change
(Module 5.12) and prevents the remaining f correct processes from ever reaching a decision,
violating the Termination property of Byzantine Consensus. This bug has been conﬁrmed by
one of the book’s authors [18]. It is similar to a bug recently discovered in PBFT’s read-only
request optimization [12].

The bug can be easily ﬁxed by reliably broadcasting decisions, as we do in PBFT-light

54

Liveness and Latency of Byzantine State-Machine Replication

(§4). But even with this ﬁx, the Eventual Leadership property of Epoch-Change will remain
broken, since correct processes will be allowed to remain forever in a view with a faulty
leader. This shows that the speciﬁcations of abstractions proposed in [19] are not well-suited
for implementing a live Byzantine Consensus. These abstractions are also underspeciﬁed:
the implementation of Byzantine Eventual Leader Detector (Alg. 2.10) will only satisfy its
speciﬁcation (Modules 2.10) if clients use it in a particular way that has not been formalized.
Informally, the authors require that correct processes eventually cease to complain against a
correct leader and in their proof sketches justify that this will happen because the processes
“wait long enough for the leader to achieve its goal”. But this argument is circular, since for
processes to stop complaining they need to get consensus decisions, and for this the Leader
Detector has to nominate a correct leader. Such circular reasoning is known to be unsound
for liveness properties2.

A part of Cachin et al.’s consensus protocol was also used in the BFT-SMaRt protocol
of Bessani et al. [13, 53]. This was based on an abstraction of validated and provable (VP)
consensus, which allows its clients to control when to change the leader via a special VP-
Timeout call. The overall BFT-Smart protocol appears to be correct, but its liveness proof
sketch suﬀers from issues with rigor similar to those of Cachin et al.’s. In particular, the
VP-Consensus abstraction is underspeciﬁed: the authors require VP-Consensus to satisfy the
Termination property, but to ensure this, its clients have to use VP-Timeout in particular
ways that have not been formalized. In particular, clients have to leave enough time in
between VP-Timeout calls for consensus to decide if the leader is correct; this in its turn
requires knowledge about the time necessary for such a decision. Thus, Lemma A2 in [53, §A]
cannot hold for an arbitrary VP-Consensus implementation.

2 M. Abadi and L. Lamport. Conjoining speciﬁcations. ACM Trans. Program. Lang. Syst., 17(3):507-534,

1995.

