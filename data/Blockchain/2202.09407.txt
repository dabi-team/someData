2
2
0
2

y
a
M
1
2

]

R
C
.
s
c
[

2
v
7
0
4
9
0
.
2
0
2
2
:
v
i
X
r
a

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

1

Blockchain Driven Privacy Preserving Contact
Tracing Framework in Pandemics

Xiao Li, Weili Wu, Senior Member and Tiantian Chen

Abstract—Contact tracing has been proven an effective approach to control the virus spread in pandemics like COVID-19 pandemic.
As an emerging powerful decentralized technique, blockchain has been explored to ensure data privacy and security in contact tracing
processes. However, existing works are mostly high-level designs with no sufﬁcient demonstration and treat blockchain as separate
storage system assisting third-party central servers, ignoring the importance and capability of consensus mechanism and incentive
mechanism. In this paper, we propose a light-weight and fully third-party free Blockchain-Driven Contact Tracing framework (BDCT) to
bridge the gap. In the BDCT framework, RSA encryption based transaction veriﬁcation method (RSA-TVM) is proposed to ensure
contact tracing correctness, which can achieve more than 96% contact cases recording accuracy even each person has 60%
probability of failing to verify the contact information. Reputation Corrected Delegated Proof of Stake (RC-DPoS) consensus
mechanism is proposed together with the incentive mechanism, which can ensure timeliness of reporting contact cases and keep
blockchain decentralized. A novel contact tracing simulation environment is created, which considers three different contact scenarios
based on population density. The simulation results demonstrate the effectiveness, robustness and attack resistance of RSA-TVM and
RC-DPoS in the proposed BDCT.

Index Terms—Blockchain, COVID-19 Pandemic, Contact Tracing, DPoS, RSA

(cid:70)

1 INTRODUCTION

S INCE the ﬁrst case of the novel corona-virus COVID-

19 discovered in December 2019, there have been over
510 million globally conﬁrmed cases, including 6 million
deaths by April 20221. The COVID-19 pandemic has brought
considerable degree of fear, emotional stress and anxiety
among individuals around the world [1]. The virus causes
severe acute respiratory infection, bringing symptoms such
as cough, fever, fatigue and breathlessness, which are very
similar to symptoms caused by regular inﬂuenza. In ad-
dition, the high contagiousness makes it even hard to be
controlled. In order to help people who have contact with
the patient get medical treatment timely, it is imperative to
record the contact histories of the patients.

The World Health Organization (WHO) has announced
the importance of contract tracing since EBOLA outbreak
in 2014 [2]. Formally, the contact tracing is the process of
identifying history contact cases of people who may have
come into contact with infected patients. Many countries
have developed contact tracing methods, such as Trace To-
gether in Singapore [3] and the QR code System in China [4].
Some technology companies also developed contact tracing
tools, such as Google and Apple developed a Bluetooth-
based API that can be used by third parties to develop
smart phone apps [5]. These apps mostly use Bluetooth to
recognize nearby devices or GPS signal to get the accurate
location coordinates to determine contact cases. Most of
these tracing systems rely on central servers controlled by

• Corresponding Author: Xiao Li, Email: xiao.li@utdallas.edu

• This work was supported in part by the US National Science Foundation

(NSF) under Grant NO.1822985.

Manuscript received April 19, 2005; revised August 26, 2015.

1. https://covid19.who.int/

governments or healthcare authorities, which may collect
the users’ identities and other privacy data through an
application installed on smart phones.

Systems based on centralized servers suffer single-point
failure and are weak to attacks. Decentralized contact trac-
ing methods are then promoted, which give more control
to users. In decentralized model, users are not required to
update all data to the server. They can hold data locally, and
share their data when necessary.

As an emerging decentralized data generating, sharing
and storing technique, blockchain systems are introduced to
solve contact tracing tasks to promote the security and pri-
vacy. Blockchain stores data into blocks that are connected
to each other as a chain. The data stored in blocks are not
able to be tempered. Smart contract deployed on blockchain
can perform various functionalities. Furthermore, encryp-
tion and anonymization technologies can be applied in
blockchain system to protect user’s identity. The consensus
mechanism in Blockchain allows blockchain systems keep
working stably without a central server.

There are some initial attempts of contact tracing systems
using blockchain technologies. Hasan et al. [6] propose
proof of location and develop smart contracts to ensure the
privacy of contact list. However, no simulation is provided.
In addition, there is no incentive mechanism to motivate
users to join the system. Authors assume there are plenty
of users in the system behaving honestly, while the situa-
tion is hard to achieve in practice. Xu et al. [7] proposes
BeepTrace blockchain-based contact tracing solution, where
a blockchain system plays the neutral role in bridging data
transmission between different parties, such as patients,
doctors and government authorities. The users’ geodata are
securely preserved in specially designed blockchain. How-
ever, the efﬁciency of this system is not demonstrated, and

 
 
 
 
 
 
JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

no speciﬁc consensus mechanism and incentive mechanism
are speciﬁed in the paper. Lv et al. [8] proposes Bychain, a
three-layer contact tracing framework without reliance on
trusted third parties. Proof of Location (PoL) is proposed to
verify the contact record and incentive mechanism is design
for maximizing contact tracing range. However, Bychain is
not able to produce person-to-person accurate contact cases.

We conclude 4 main challenges to develop a third-party
free blockchain-based contact tracing method. The 4 chal-
lenges are overlapped with each other: 1) Instead of simply
treating blockchain as a separated storage method, how
to leverage powerful consensus mechanism in blockchain
system to promote data security; 2) How to design an
effective consensus mechanism to organize data storage and
meanwhile achieve low latency of recording contact infor-
mation. The popular consensus mechanisms are usually too
computational expensive for mobile devices, and may bring
signiﬁcant delay of recording contact information. People
should be able to access latest contact records timely to
prevent further possible virus spread. 3) How to design the
incentive mechanism so that people are motivated to join
the contact tracing system and behaviour honestly. 4) Due
to lack of real-world contact data, as well as high cost of
testing whole system in practice, it is hard to evaluate the
effectiveness and efﬁciency of whole systems. The difﬁculty
of collecting real-world contact information, is not only from
privacy concerns, but also diversity of people contact sce-
narios. Contact cases happened in crowded cities and those
happened in rural areas are totally different scenarios with
different frequencies and amounts. This diversity brings
challenge to design incentive mechanism fair to every one.

There is seldom work that clearly addresses all above
mentioned 4 challenges. In addition, according to the survey
conducted at multiple countries in [9], though most people
accept app-based tracing methods, the concern about the
security and privacy is still an obstacle to the common
adoption of tracing apps in many countries. Therefore, in
this article, we aim to tackle the 4 challenges with the
users’ privacy ensured by proposing a fully third-party free
contact tracing framework with blockchain technology. A
RSA based transaction veriﬁcation algorithm is proposed
to ensure the correctness of recorded contact information
and improve system robustness. To efﬁciently store contact
information into blocks, we propose Reputation Corrected
Delegated Proof of Stake (RC-DPoS) consensus mechanism,
which can control the right of appending new blocks. An
incentive mechanism is then designed to work with RC-
DPoS motivating people to work honestly and maintaining
system decentrality. Finally, we design a contact tracing sim-
ulation method that simulates different real-world people
contact scenarios to evaluate the effectiveness of proposed
framework.

2

2 RELATED WORK
2.1 Traditional Contact Tracing Methods

Contact tracing refers to the process that records the people
contact history so that the people contacted with a patient
can be informed and get medical treatment timely to control
the spread of virus.

Various contact tracing tools have been developed using
location technologies such as GPS, Wiﬁ, cell tower signal
and Bluetooth [10], [11], [12], [13], [14], [15].

Reichert et al. [16] propose a centralized contact tracing
method, which assumes every user has their location history
stored in their devices, and the health authorities are able
to read the data. Nisar et al. [12] propose to use call data
record to trace the patient once she/he is diagnosed positive.
However, the trace build is not practical since most people
don not answer phones calls very frequently during a day,
therefore we can only get limited number of locations.

The contact tracing system based on GPS signal are not
reliable for in-door situations, while in-door contact is one
major way of virus spread due to short contact distance
and long contact time. Some work proposes to use WiFi
or wireless access points to discover contact cases [10],
[11], [13]. These frameworks require users to connect their
devices to speciﬁc wireless access points. However, in some
public areas such as shopping malls, airports and train
stations, people may not join public WiFi due to network
security concerns. Bluetooth technology can scan nearby
devices and get device identities within a small range, which
can help generate the contact cases [15]. In this article, we
also leverage this advantage to protect users privacy that
avoids disclosing users’ real identities and speciﬁc locations.
Chan et al. [17] propose PACT protocol, where every user
holds the contact tracing data on their own local devices,
and only when they are tested positive, they will broadcast
their contact information to a public platform. Every other
user will check the list on the platform to conﬁrm if they
have contacted with anyone in that list. Though this protocol
is a third-party-free mobile contracting protocol and easy
to be implemented in practice, However The users are not
guaranteed to behave honestly, and the public platform is
easy to be compromised since it is open to anyone.

Most of existing works are centralized where third-party
servers are used collecting user’s personal data and contact
history to match contact records [18]. Centralized models are
exposed to risks of single point failure, privacy data leaking
and security compromising. Though some contact tracing
methods are proposed to be decentralized [17], [19], these
methods still require a server to process data computing
functions and are vulnerable to dishonest behaviours from
malicious users.

2.2 Blockchain Based Contact Tracing Methods

The reminder of this article is organized as follows.
In Section 2, we discuss existing related work on contract
tracing. Section 3 is dedicated to presenting the overview
of proposed contact tracing framework. Next we elaborate
transaction veriﬁcation algorithm, RC-DPoS and incentive
mechanism in Section 4, Section 5 and Section 6, respec-
tively. Experimental simulation and discussion are con-
ducted in Section 7. Finally, Section 8 concludes the paper.

Blockchain technology is ﬁrst proposed by [20] as a dis-
tributed ledger for Bitcoin system, which ensures data secu-
rity without any trust given to third parties. A blockchain
system usually constructs a peer-to-peer network, where
each user plays exactly the same role and follows the same
protocol. Every user stores a whole copy of blockchain,
so that all the data on the blockchain are extremely hard
to be tempered and single-point failure can naturally be

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

avoided. There’s no need of a central server to perform
functions in the system, such as collecting, computing or
storing data. Users (peers) in a blockchain system have
equal rights to perform functionalities by executing smart
contracts deployed in the system. A consensus mechanism
is enforced in the system to control which user is qualiﬁed to
generate a new block at each step. An incentive mechanism
is also important in the system to motivate users to compete
for the right of generating a block.

Blockchain technology, ﬁrst known as distributed
ledger [20], can make a system work stably without any
trust built among parties. With anonymity techniques and
data encryption techniques, users in a blockchain system
can share data securely without compromising privacy.
Blockchain technology has demonstrated signiﬁcant feasi-
bility in IoT applications, which have similar requirements
as contact tracing systems [21], [22], [23], [24], [25].

Blockchain technology shows great potential for devel-
oping privacy preserving and efﬁcient contact tracing appli-
cations. Idrees et al. [26] point out several challenges and
risks associated with the available contact tracing apps and
analyze how the adoption of a blockchain-based decentral-
ized network could provide users with privacy-preserving
contact tracing.

Besides the BeepTrace [7] mentioned above, there ex-
ists many other blockchain-based contract tracing frame-
works or systems. Arifeen et al. [27] propose a high-
level blockchain based contract tracing framework where
blockchain is used for patients to publish contact list. Zhang
et al. [28] propose PTBM leveraging both permissionless
and permissioned blockchain to manage users’
location
data, and 5G technique provides support for low latency
communication. In PTBM, authorized third parties, such
as medical centers and medical organizations, are able to
compute the contact history and publish history route of
patients.

Peng et al. [29] propose P 2B, where users can upload
contact information to blockchain storage to be further
veriﬁed and cross-checked by clients and authorities. P 2B
is demonstrated with higher data transmission efﬁciency
than BeepTrace. Vangipuram et al. [30] propose a three-
tier architecture for storing numerous data collected by
Internet-of-MedicalThings (IoMT) for contact tracing. In the
architecture blockchain is employed to securely transfer the
data from the infected person to the hospital system using
the edge infrastructure.

Zuhair et al.

[31] consider a sixth-generation (6G)-
assisted unmanned aerial vehicles (UAVs) en-powered mass
surveillance system in dense areas, which can monitor
body temperature of persons with thermal imaging sensors.
Blockchain also works as storage system in their work,
and with the powerful bandwidth of 6G, the data can be
processed with low latency. Salimibeni et al. [32] consider in-
door contact tracing scenarios, and propose TB-ICT contact
tracing framework,where dynamic Proof of Work (dPoW)
credit-based consensus algorithm coupled with Random-
ized Hash Window (W-Hash) and dynamic Proof of Credit
(dPoC) mechanisms are proposed to differentiate between
honest and dishonest nodes. TB-ICT can motivate people
to behave honestly since better credit can decrease mining
difﬁculty. However, PoW-based consensus mechanism may

bring high computation overhead while BLE-carried devices
adopted in the system are not usually computational pow-
erful.

3

3 CONTRACT TRACING FRAMEWORK OVERVIEW

3.1 Problem Deﬁnition and Preliminary Settings

In this paper, we study the contact tracing problem as: given
Bluetooth signals on smart devices, with the constraints of
preserving privacy, we aim to output pairwise users’ contact
lists by discovering nearby Bluetooth devices. The goals to
achieve for the contact tracing problem are the completeness
and correctness of contact list, the contact tracing robustness
and attack resistance.

We assume our Blockchain-Driven Contact Tracing
framework (BDCT) is implemented and deployed through
clients on smart devices. People can join the contact tracing
system by installing the client on their smart devices. It
is assumed each user carries one device with the client
installed. The client will generate private-public key pair
and a unique device ID for each device. The client on a
device will use Bluetooth to share the device ID as well
as getting device IDs of other nearby devices. Bluetooth
is capable to evaluate the distance between two devices
within a certain range by the strength of Bluetooth signal.
Therefore, the contact distance can be easily computed [33].
The furthest contact distance considered in this paper is 5
meters where Bluetooth can produce strong enough signal
to support accurate computation. In this paper, since we
directly record the device IDs of contacts rather than record
accurate GPS coordinates and match contact information
afterwards, without any accurate location data recorded,
privacy will be preserved.

3.2 Contact Tracing Procedure

At a given frequency, the client on a smart device will
scan and record all the device IDs of nearby devices within
a range. This process is fast and secure since the client
only scans surrounding devices without having to establish
stable connection to them, which also avoids cyberattack
through Bluetooth channel. If there is a device detected
within 2 meters2, the client will identify this as a contact
case. The client will then store the device IDs of contacted
devices into contact list locally in a special format which will
be speciﬁed in next section.

Most of previous works ignore the fact that mobile
devices are not as robust as computers in terms of internet
connectivity, system robustness and security level. The de-
vice may fail to collect the contacted device information, or
be attacked to record false contact list. To improve the data
integrity, a special role witness is proposed in this paper.
All the devices that are 2 meters away but still within 5
meters from the current device are considered witnesses of
the contact case. Witnesses play important roles in BDCT,
which help verify the reported contact list, speed up the
veriﬁcation process, and recover the missed contacts. The
client will also store the device IDs of witnessed devices
into witness list locally in the similar format as contact list.

2. The distance can be adjusted according to particular scenarios.

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

4

Fig. 1. Overview of Contact Tracing Framework (User u1 generates a transaction))

With the pseudo IDs of contact devices and witness devices
stored locally, users can check whom they have contacted
with and who have witnessed their contact cases at any time
without knowing the real identity of the device owner.

Based on the above setting, we now illustrate the whole
Blockchain-Driven Contact Tracing Framework (BDCT) in
Figure 1 with an example.

In Figure 1, at a given Timestamp, assume user u1 would
like to report his current contact case. He will initiate a
contact tracing transaction Tcon. let’s assume users u2 and
u3 are within 2 meters from u1 and hence considered a
contact case with user u1. Users u4 and u5 are 2 meters
away but still within 5 meters from u1, and they witness that
u1 is with u2 and u3. u6 and u7 are considered irrelevant
to this contact case. As in the ﬁgure, there are 6 steps
from generating contact record as blockchain transaction to
the transaction being stored to blockchain storage in every
device.

Step 1: User u1 initiates a blockchain transaction Tcon =
{Tid, u1, ContactList, W itnessList, T imestamp}, which is
used for record the contact case of u1 at T imestamp. One
transaction represents one contact case of users at some
timestamp. Tid is an unique transaction ID for each trans-
action. T imestamp is the exact time that u1 contacts the
users in ContactList. The ContactList and W itnessList
contains secret messages from u1 encrypted by the public
keys of each contacted devices (u2 and u3) or witness
devices (u4 and u5). Formal deﬁnition of ContactList and
W itnessList will be presented in Section 4.

Step 2: User u1 then broadcasts the transaction Tcon
through internet to every user who have the client installed.
Since no one knows others’ identities, u1 is not able to
directly send message to u2, u3, u4 and u5.

Step 3: When other users receive the transaction Tcon,
it will check if it contacted with u1 at T imestamp or if
it witnessed the reported contact case. Then the contacted
users in this example, u2 and u3, and the witnessed users,
u4 and u5, will try decode the received message, sign the
decoded message and broadcast this signed transaction. The

transaction generator u1 will receive the signed transaction.
Step 4: After receiving the signed transaction Tcon, u1
will verify the signature by decoding the signature with
contact’s or witness’s public key to make sure the contact
list and witness list are signed by correct people. u1 will
wait for the signatures within a speciﬁc delay d, such as 60
minutes. Only the records in ContactList veriﬁed valid will
be ﬁnally preserved in Tcon. u1 will put transaction Tcon into
a shared transaction pool which is synchronized on every
device along with blockchain.

Step 5: At given frequency, one of the candidate min-
ers will be selected to package all the transactions in the
transaction pool into a block. In this paper, we propose
the Reputation-Corrected DPoS (RC-DPoS) mechanism to
choose the candidate miners, which will be presented in
detail in Section 5.

Step 6: The block is ﬁnally appended to the blockchain
by the miner, and broadcast to all users in the network for
synchronizing.

Step 1 to Step 4 will be elaborated in Section 4 by
proposing RSA-Based transaction veriﬁcation method. In
Section 5, RC-DPoS and corresponding incentive mecha-
nism are presented to complete Step 5 and Step 6.

4 TRANSACTION VERIFICATION METHOD
In this section, we will ﬁrst describe how to initialize creden-
tials for each user and then present RSA-based Transaction
Veriﬁcation Method (RSA-TVM). There are two major goals
on contact tracing system: 1) data integrity: the collected
contact cases should be as complete, untampered and cor-
rect as possible; and 2) privacy: the whole system should
never initiatively disclose any location or identity informa-
tion of users.

In this paper, We propose RSA-based Transaction Ver-
iﬁcation Method (RSA-TVM) to make sure the contact
records in the transaction are valid meanwhile ensuring
the anonymity. We employee RSA algorithm as encryption
module [34]. RSA algorithm is an asymmetric encryption
algorithm, and is able to generate a key pair, (public key,

𝑢3𝑢2𝑢1𝑢4𝑢5Contact:𝑢2,𝑢3WitnessedBy:𝑢4,𝑢5𝑢3𝑢2𝑢1①Generatetransac�on𝑇:{𝑢1, ContactList,WitnessList,Timestamp}②Broadcast𝑇𝑢4𝑢5𝑇:{𝑢1, Contact List(Signed),Witness List(Signed),Timestamp}Contact:𝑢1,𝑢3Contact:𝑢1,𝑢2Shared Transac�on Pool𝑇1𝑇2𝑇𝑛…Candidate Miners𝑢6𝑢7𝑢6𝑢7𝑢7Witness: (𝑢1,𝑢2,𝑢3)BlockHashPrevious HashBlockBodyTransac�ons (𝑇1,𝑇2, … ,𝑇𝑛)⑤PackageTransac�ons intoBlock with given frequency…⑥Appendedto BlockchainBlockchain③Decode andsign𝑢2,𝑢3𝑢4,𝑢5Witness:(𝑢1,𝑢2,𝑢3)④Verify Signature and put into pool𝑢6JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

private key) for a user. Public key is known by public, while
the private key is only known by the owner. The secret
message encrypted by public key can only be decoded by
private key owner. A message can be signed by private key
indicating owner’s consent to the message, and the signed
message can be veriﬁed by corresponding public key to
ensure the signature is correctly signed by the private key
owner.

Next we will ﬁrst describe how to initialize credentials

for each user and then present RSA-TVM.

4.1 Generate User Credential

When a person u installs the tracing client on a smart device
and become an user of the tracing system, the client will
ﬁrst name the device with an unique device ID, denoted
as uDID , and then generate a RSA key pair (public key,
private key), denoted as (uP ub key, uP ri key). The length
of each key is set to 1024 bits. The private key will be
stored locally in the smart device. The public key and the
device information will be included in a transaction through
the client, then be stored into blockchain. This transaction
is called “Registration Transaction”, which is deﬁned as
Treg = {Tid, {uDID , uP ub key, t}}. Tid is the unique id for
each transaction and is generated by SHA256 algorithm [35]
based on timestamp t as well as the transaction content
{uDID , uP ub key, t}, so that any change made on the content
will cause a different Tid.

After

the registration transaction is stored in the
blockchain, since every user in the system have a synchro-
nized copy of the whole blockchain, every user will hold the
public keys for every others. Users are able to modify their
device ID or credentials by submitting a new registration
transaction, so that every other users can get a new copy of
the updated device ID or public key.

Users will scan the nearby devices (through Bluetooth) at
a given frequency to get the nearby devices’ IDs and record
them locally. We avoid any device connection through Blue-
tooth channels to improve security. The client only collects
the devices’ IDs, and look up the registration transactions to
get the public keys for generating secret message later used
in ContactList or W itnessList. Next if the user wants to
report contact cases and store the contact information into
Blockchain, “Contact Transaction” will be initialized.

4.2 RSA-based Transaction Veriﬁcation Method (RSA-
TVM)

If there are nearby devices within 2 meters detected by user
u’s device, u can generate “Contact Transaction”, denoted
as Tcon = {Tid, {uDID , C, W, t}}, where Tid is the unique id
for each transaction and is generated based on timestamp
t and the transaction content {uDID , C, W, t}. The uDID is
the device ID of u, and t is the timestamp for this contact
case. C and W are Contact List and Witness List, which
contain the information of the contacted people(devices)
and the witness of this contact case, respectively. To generate
C and W , user u ﬁrst needs to decide a original secret
message D, and then encrypt it with the public key of the
contacted people (e.g., ui) and the witnesses (e.g., uj) of
this contact case. For each contacted person ui, uiP ub key

5

encrypted text, denoted as DuiP ub key is generated. Sim-
ilarly, for each witness uj, Duj P ub key is generated. For-
mally, the Contact List C is deﬁned as a set of tuples:
C = {(uiP ub key, DuiP ub key )|∀ui}. Similarly, the Witness
List is deﬁned as: W = {(uj P ub key, Duj P ub key

)|∀uj}.

Ideally, The secret message should be unique for every
ui and uj for every transaction to ensure security which
requires secret message as long as possible. However, the
encryption time increase rapidly with the length of text.
In practice, we set each secret message contains 10 Hex
characters (0 − 9, a − f ), which is able to represent about
1.1 × 1012 different messages.

Witness list W can be very helpful to avoid contact
case loss and improve robustness against dishonest user
behaviors or system failure. We will show this later in
Section 7.

The transaction Tcon will then be broadcast to all users
in order to protect privacy. Each user will check if C or W
in the received Tcon contains his/her public key. If so, the
related tuples require his/her veriﬁcation. Since the mes-
sages are all encrypted, therefore only the user who holds
the public key can decrypt the encrypted secret message by
his/her public key.

When ui identiﬁes the tuple (uiP ub key, DuiP ub key ) in C,
ui will decrypt the encrypted text DuiP ub key with the pri-
vate key uiP ri key to get the secret message D. Then ui will
check local contact history. If ui has the record that ui con-
tacted with u at timestamp t±3 min, then ui can conﬁrm the
tuple (uiP ub key, DuiP ub key ) valid in Tcon. Then ui needs to
send a message back to u to indicate that the contact record
about ui in Tcon is conﬁrmed. Speciﬁcally, ui signs the secret
message D with his private key. The signed text is denoted
as SDuiP ri key . Then ui replaces (uiP ub key, DuiP ub key ) with
(uiP ub key, SDuiP ri key ) in Tcon, and broadcast to all users.
uj will conduct similar veriﬁcation on the related tuple
in witness list W . If uj has the record that the transaction
generator u contacted with all users in C at t, then uj will
consider all tuples in C valid by signing secret message in
related tuple in W .

If ui can not ﬁnd any local record showing ui contacted
with u at timestamp t ± 3 min, then ui believes this is a
wrong record. ui will sign a predeﬁned warning message
Z=”Wrong Record” instead of signing the secret message
D. The tuple (uiP ub key, DuiP ub key ) in Tcon will then be
(uiP ub key, ZuiP ri key ). Once the transaction generator u re-
ceives the updated Tcon from user ui, u will verify the
signature with the public key of ui.

A tuple in contact list C in Tcon is considered valid if: 1)
there is no signed warning message in the tuple, and 2) the
secret message in tuple is correctly signed by the contacted
person or at least one tuple in witness list is correctly signed
by the witness. Due to network or system failure of users’
smart devices, users may have no response to the related
tuple in C or W within given delay d. In this case, the
tuple will still be considered valid as long as one witness
has veriﬁed the this contact case is correct.

If not all tuples in the contact list C are veriﬁed valid
within a speciﬁc delay d, then only the valid tuples in C
will be preserved in Tcon. The transaction Tcon will be put
into the shared transaction pool waiting to be mined, e.g.
permanently stored in blockchain. Any user ui or uj who

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

6

Fig. 2. An Example of RSA-TVM

signed D or Z will get reward for helping verify the contact
case. We will discuss reward policies in Section 6. Figure 2
shows the process of RSA-TVM that u2 veriﬁes u1’s contact
case.

REPUTATION-CORRECTED DPOS MECHANISM

5
(RC-DPOS)

Most existing work considers it is straightforward to let the
transaction generator directly package the veriﬁed transac-
tions into blocks and then broadcast to all users instead of
choosing a miner to do the job. However, the above strategy
will cause unfair incentive reward problem due to the nature
of diverse contact scenarios.

unfair incentive reward problem: Users are rewarded for
reporting contact cases by generating contact transactions.
However, people have different chance to have contact cases
due to the diversity of jobs or living styles. People who live
or work in human-dense areas, such as cashiers in markets
and staffs at transport stations, will obviously have much
more contact cases than those who stay or work at home,
thus gain much more reward. This will even encourage
people to go out and make contacts in order to earn re-

ward, which is against the social distancing policy during
pandemics.

In addition, since miners can be the one not in the
Contactlist or W itnessList, it helps avoid group cheat-
ing that small groups deliberately generate fake contact
cases, verify contact transactions for each other, package
transactions and append new blocks in order to gain great
amount of reward rapidly. Therefore, it is imperative to
carefully design consensus mechanism and incentive mech-
anism to balance the reward. The consensus mechanism is
required computational lightweight and have high transac-
tion throughput to satisfy the huge data storage demand
on smart devices which are usually have low computational
power.

The Delegated Proof of Stake (DPoS) consensus mech-
anism [36] is a popular light-weight consensus mechanism.
DPoS provides high-speed consensus making so that emerg-
ing transactions can be stored into blocks timely. In DPoS
consensus mechanism, each user holds some stakes, which
are usually crypto-currency. Whenever there is no candidate
miners, every user will vote someone they trust. The weight
of the vote is proportional to the stake of the voter. That
is, more stake gives the voter more vote power. After the

𝑢1’s Mobile Device𝑢2’s Mobile DeviceNetwork Transmission= “0023fadecd”= “Wrong Record!”𝐷:SHA384HashthenSignSHA384 HashWait 𝑑minutes, then append veriﬁed 𝑇𝐶𝑜𝑛into transac�on poolGenerate Contact Transac�onBroadcastReceiveRecognize Related Tuple Decode with 𝑢2𝑃𝑟𝑖_𝑘𝑒𝑦IfcontactrecordiscorrectIf contact record is wrongUpdate𝑇𝐶𝑜𝑛BroadcastReceive𝑢2𝑃𝑟𝑖_𝑘𝑒𝑦𝑢2𝑃𝑢𝑏_𝑘𝑒𝑦CheckifveriﬁedYield correct record if can get the same result(𝑢2𝑃𝑢𝑏𝑘𝑒𝑦,𝐷𝑢2𝑃𝑢𝑏_𝑘𝑒𝑦            )= “0023fadecd”(𝑢2𝑃𝑢𝑏_𝑘𝑒𝑦,𝑆𝐷𝑢2𝑃𝑟𝑖_𝑘𝑒𝑦)JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

voting, the users with top k total weighted votes will be
selected as k candidate miners. Whenever there is block
waiting to be appended into blockchain, one candidate
miner will be randomly chosen to do the job, and the chosen
miner will be removed from the candidate miner set once
the job is done. Once candidate miner set is empty, new
round of voting will start.

DPoS can produce high throughput without compromis-
ing decentrality of blockchain system if everyone is honest
and the voting is random. However, it can not be directly
applied in our proposed BDCT. In order to motivate people
to share their contact information, reward must be given to
those who generates contact transactions honestly. In DPoS
the reward is stake, people living or working in human-
dense areas will gather stakes quickly. Thus their votes will
gradually become highly weighted due to high stakes, hence
their votes will easily determine the selection of candidate
miners. In other words, the whole blockchain system will
be dominated by those people who generate contact cases
often.

In order to solve the issue described above, we propose
Reputation-Corrected DPoS (RC-DPoS) consensus mecha-
nism. In RC-DPoS, we assign reputation to each user, which
is represented by credit c. Users will gain reputation reward
instead of stake reward for honestly reporting their contact
cases, while only gain stake reward for working as a miner.
Speciﬁcally, the RC-DPoS mechanism works as follows:

Step 1: When new users ﬁrst join the contact tracing
framework, they will be initialized with a ﬁxed start-up
stake s0 and credit c0.

Step 2: Initially, the candidate miner set is empty, the
candidate selection process will start. Each user votes for
another one trusted user and users can not vote for them-
selves. Similar to DPoS, the vote is weighted according to
the voter’s stake. But the total votes received by a user will
be corrected by receiver’s credit. Formally, let N denotes the
total number of users in the system. For user ui, i ∈ Z N , the
total vote score accumulated by ui is calculated according to
Equation 1:

Gi =

RF (ui) + 1
2

(cid:88)

uk

sk
j∈ZN sj

(cid:80)

(1)

where the sum taken over user uk who votes ui is the total
weighted vote received by ui, sk is the current stake amount
of uk. ci is the current credit amount of ui. RF (ui) is the
reputation correction factor of user ui, which is deﬁned as:

RF (ui) =

ci − minj∈ZN (cj)
maxj∈ZN (cj) − minj∈ZN (cj)

.

(2)

RF (ui)+1
2

RF (ui) ∈ [0, 1], and
∈ [0.5, 1]. The intuition
behind this equation is that users with good reputation
should have higher chance to be a candidate miner in order
to improve the system security, meanwhile we also avoid
applying too much punishment on other users with lower
reputation (maximum 50% off on received votes).

Step 3: Rank all users in descending order according
to their vote scores. The top (cid:100)N/5(cid:101) users are selected into
candidate miners set. The size of candidate miners set can
be adjusted based on speciﬁc applications.

7

Step 4: At a given mining frequency (3 minutes, 5
minutes or so on), one arbitrary miner selected from the
candidate miner set will package all the transactions in the
shared transaction pool into a block and append it into the
miner’s local blockchain. Then shared transaction pool is
empty and waits for new veriﬁed transactions. The structure
of the blockchain storage is illustrated in Figure 3.

Step 5: The miner then broadcasts this blockchain update
to all users. Users in the system will update their local
blockchain and the local transaction pool. The miner will be
given stake reward and reputation reward. Reward detail
will be elaborated in Section 6. Then the miner will be
removed from the candidate miner set.

Step 6: When a miner fails to do this job within a excus-
able delay (e.g. 10 minutes) due to network disconnection
or system failure, a penalty will be applied on the miner
by taking away some credits and no stake reward will be
given. The miner will be removed from the candidate miner
list and another miner will be delegated to do the job.

Step 7: If the candidate miner set is empty, back to Step

2.

6 INCENTIVE MECHANISM
The proposed BDCT contact tracing framework is highly
automatic without a central server. BDCT fully relies on peo-
ple to generate transactions, store contact cases into blocks
and maintain decentrality, therefore it is crucial to design an
incentive mechanism to motivate people to generate contact
transactions and append blocks into blockchain honestly. It
is also important to ensure the incentive mechanism does
not specially beneﬁt a particular group of people to avoid
the system becoming centralized and dominated. If the
rewards are taking over by a small speciﬁc group of people,
others will be discouraged, and the whole system will be
barely helpful for contact tracing. In this paper, we design
the incentive mechanism as a composition of following 4
incentive policies.

1) Users will be rewarded with 1 unit3 credit for
generating transactions. The users can not get the
reward until the transaction is accepted by the
shared transaction pool. This will motivate users to
honestly report their contact list. With more credits,
according to Equation 1, users will be more likely
to be selected as candidate miner and thus can get
more credit reward as well as stake reward.

2) Users will be rewarded with 1 unit credit after
successfully verifying related tuple in contact trans-
actions. This will motivate users to participate in
generating transactions and improve the speed of
verifying contact cases.

3) Users will be rewarded with Ri unit stake reward
and 1 unit credit reward for mining a block, e.g.
append a new block into existing blockchain. Ri is
corresponding to the total amount of transactions
that ui generated, which is formally deﬁned as:

Ri = w ∗

T F (ui) + 1
2

,

(3)

3. numbers in the incentive mechanism only for indicating the rela-

tive amount, they can be of any unit.

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

8

Fig. 3. Blockchain Storage Structure in Proposed Framework

T F (ui) = 1 −

ti − minj∈ZN (tj)
maxj∈ZN (tj) − minj∈ZN (tj)

.

(4)

w is a predeﬁned reward amount (e.g. 5 units) and
ti is the total number of transaction generated by ui.
T F (ui) ∈ [0, 1] is called the transaction correction
factor. From the above deﬁnition, we could ﬁnd that
the more transaction ui has generated, the lower
stake reward will be given to ui. The intuition be-
hind Ri is that we do not want people who generate
much transactions gain much stake reward for com-
pleting mining job since they naturally have more
chance to become a miner according to incentive
policy 1). On the other hand, people who generate
less transactions will get more stake reward per
∈ [0.5, 1] will
mining job they complete.
make a maximum 50% off on the stake reward.
Therefore Ri can help balance the stake reward
among users in different contact scenarios, hence
help maintain the vote power distributed.

T F (ui)+1
2

4) A user will be punished if the user fails to complete
a mining job. 5 units credits will be deducted on the
miner for this punishment.

The stake reward is usually pecuniary crypto-currency,
which can be distributed by government or healthcare
authorities. Since this system does not require frequent
maintenance and huge computation center, the budget can
be saved for pecuniary stake reward. Then with accurate
and efﬁcient contact tracing, BDCT will save more money
for government by helping control the virus spread.

7 SIMULATION
7.1 Simulation Method

Though there are some well-known real-word trajectory
datasets indicating real people movements in speciﬁc areas
[37], [38], [39], [40], [41], [42], they are mostly based on
the record obtained from mobile vehicles or cell phone
calls, the trajectories are not continuous or the number of

trajectories are not sufﬁcient to support the simulation in
terms of frequency and amount. Since it is hard to collect
real-word trajectory in a wide range due to privacy concerns
and diversity of contact scenarios, we conduct experiments
on synthetic datasets that simulates different people contact
scenarios to demonstrate the effectiveness of the proposed
BDCT contact tracing framework.

We propose to consider three general contact scenarios
decided based on population density: Low density (Sparse),
Medium density (Medium), High density (Crowded). Each
scenario can intuitively represent for one kind of real-world
people contacting cases. “Sparse” can represent for the
people contacting cases in rural area or residential area.
“Medium” can represent for the cases in schools, parks
or other common public areas. “Crowded” represents for
contacting cases happening in some very crowded places,
such as shopping malls and sports events.

People in 3 scenarios have different frequencies of hav-
ing contact cases, different numbers of contacted people and
witnesses. Therefore the frequency of generating transac-
tions, and the length of contact list and witness list need to
be adjusted for simulating 3 scenarios. To achieve this goal,
we specify the settings for the three scenarios as follows:

Low density (Sparse) case: In each transaction, the length
of contact list and witness list follow normal distribution
N (µ = 0, σ = 2) and N (µ = 0, σ = 1), respectively. The
frequency of generating transaction is 1 cases/hr.

Medium density (Medium) case: In each transaction, the
length of contact list and witness list follow the normal
distribution N (µ = 2, σ = 4) and N (µ = 2, σ = 2),
respectively. The frequency of generating transaction is
3 cases/hr.

High density (Crowded) case: In each transaction, the
length of contact list and witness list follow the normal
distribution N (µ = 5, σ = 2) and N (µ = 7, σ = 2),
respectively. The frequency of generating transaction is
12 cases/hr.

We implement the framework with Python 3.7, and all
simulations are conducted on a machine with Intel Core
i7-8750h 8 cores and 32GB memories. Each user is imple-
mented as a thread of python, and all threads are run

BlockID(Hash)Previous Block Hash…BlockID(Hash)Previous Block HashBlock Generator (𝑢𝐷𝐼𝐷)BlockchainTime(Timestamp)BlockBodyBlockID(Hash)Previous Block HashBlockGenerator(𝑢𝐷𝐼𝐷)Blockchain Time (Timestamp)Block Body𝑇𝐶𝑜𝑛={𝑇𝑖𝑑,{𝑢2𝐷𝐼𝐷,𝐶𝑇𝐶𝑜𝑛={𝑇𝑖𝑑,{𝑢4𝐷𝐼𝐷,𝐶={(𝑢1𝑃𝑢𝑏𝑘𝑒𝑦,𝑢1𝑃𝑢𝑏𝑘𝑒𝑦_𝐸𝑛𝑐𝑟𝑦𝑝𝑡𝑒𝑑𝑇𝑒𝑥𝑡)},𝑊… JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

simultaneously to simulate real time contact. We randomly
generate the contact cases for each user without considering
reasonable trajectories for them, since the trajectories does
not affect the evaluation of the effectiveness and efﬁciency
of the whole framework. For the length of contact list
or witness list, we only adopt the non-negative number
sampled from corresponding normal distributions.

7.2 Decentrality Evaluation

It is crucial to maintain the decentrality of BDCT, so that the
voting power is distributed and every user can be equally
motivated to keep contributing contact cases honestly.

We simulate 200 users for each contact scenario, and
hence totally 600 users are in the whole simulation envi-
ronment. To measure the dencentrality of the system, we
draw Lorenz curve, and calculate the Gini coefﬁcient/index
of three factors of the 600 users: user balance (cumulative
stake reward), user credits (cumulative reputation reward)
and the total number of mined blocks.

Lorenz curve is originally proposed for drawing the
cumulative income from different units when they are in the
ascending order [43]. The closer the income distribution is
to uniform distribution, the closer the corresponding Lorenz
curve is to line y = x. We extend Lorenz curve in this article
to illustrate the decentrality of the proposed RC-DPoS.

The Gini coefﬁcient or Gini index Gini is a metric for
quantitatively measure inequality of a distribution, which
can derived from Lorenz curve [44]. It is deﬁned as a ratio
with values between 0 and 1. Speciﬁcally, the numerator
is the area between the Lorenz curve of the distribution
and the uniform distribution line; the denominator is the
area under the uniform distribution line. Hence, Gini = 0
indicates perfect equality of a distribution, and Gini = 1
indicates the distribution is total skew to one unit.

We adopt the DPoS mechanism as the baseline. In the
baseline, no credit reward is given to users, and users
will get 1 unit stake reward for generating or verifying
transactions and 5 units stake reward for mining a block.
Other settings are kept the same as proposed BDCT. The
initial stake and credit of users are set to 100 units. Random
voting strategy is adopted for voting the candidate miners.
We run the simulation for 10 times, and evaluate statis-
tical signiﬁcance of Gini coefﬁcient of user balance between
baseline and proposed BDCT. We conduct a two-sided T-test
for the null hypothesis that two frameworks’ stake reward
distribution have identical average (expected) values. The
p = 1.22 × 10−32 indicates BDCT achieves deﬁnitely better
stake reward dencentrality.

Figure 4 shows the results of Gini coefﬁcient and Lorenz
curve of the three factors. Figure 4(a) and (b) show how
the Gini coefﬁcient change with more and more data stored
in the blockchain. Figure 4(c) shows the Gini coefﬁcient of
balance of baseline DPoS remains as high as 0.56 when
blockchain height is 10k, indicating the stake rewards are
mostly given to people in Dense scenario. Since the baseline
DPoS mechanism does not consider any credit reward,
therefore the Gini coefﬁcient of credit is 0 in Figure 4(a)(c).
In addition The Gini coefﬁcient of mined blocks count of
baseline is close to 0, this is because under the random
vote strategy in DPoS, users has the same expectation to
be selected as a miner.

9

Figure 4(b) and (d) shows the results of our proposed
BDCT framework. In Figure 4(b), our BDCT framework
makes the gini coefﬁcient decrease with the height of
blockchain, which means BDCT is achieving balanced stake
reward when we continue recording more data. In Fig-
ure 4(d), as expected, the Gini coefﬁcient of credit is 0.57
when blockchain height is 10k, showing users in dense area
can indeed earn more credit than other users. The Gini
coefﬁcient of mined blocks count is 0.27 which is higher than
0.12 in baseline, indicating people in dense areas indeed
have higher chance to be a miner. Gini coefﬁcient of credit
is 0.19 which is signiﬁcantly lower than 0.56 in baseline and
demonstrates our RC-DPoS and proposed incentive mech-
anism can successfully balance the stake reward among
different groups of users.

We further investigate the stake reward distribution.
In DPoS baseline, the 200 users (1/3 of total users) in
the Crowded scenario together hold more than 85% stake
rewards giving them more than 85% vote power. On ther
other hand, the three groups of users in three different
contact scenarios in our proposed BDCT hold stake reward
23%, 42%, and 34% respectively.

7.3 Robustness Evaluation

Mobile devices are usually with low computational power
and low security level, and sometimes may suffer from
system failure or network delay and disconnection. All
those factors can cause failure of detecting contact case,
verifying contact list or receiving transactions. In this pa-
per, We proposed witness for every contact case in BDCT
framework, which can improve the robustness of recording
correct contact cases. As mentioned in Section 4.2, if a tuple
in contact case is not veriﬁed due to the failure mentioned
above, as long as there is one witness in W veriﬁed the
contact list C, the tuple will be considered valid.

To evaluate the robustness of recording contact infor-
mation of the proposed system, we set a failure rate p
of each user, representing that the user has a probability
p of failing to verify the corresponding transaction. Then
we compute how many contact cases, that ui contacts
with uj at timestamp t, e.g. (ui, uj, t), will lose compar-
ing with the given 300k contact cases. We use a baseline
BDCT − w/o − W itness that is BDCT without witness
role, therefore (ui, uj, t) will be lost when both ui and uj
fail to verify the corresponding tuples in C. This is also a
common design in exiting works [19], [45]. We simulate this
experiment for 10 times, and report the average results.

Table 1 shows the simulation results. It can be seen
that our framework lost signiﬁcantly less contact cases than
baseline at any failure rate p. BDCT can correctly record
nearly 96.31% (1-3.69%) total contact cases even every node
has 0.6 failure probability, which is 35% more than the
baseline that can only preserve about 61.26% (1-38.74%)
contact cases.

7.4 Attack Resistance

Malicious users may report false or fake contact cases to
generate more transactions, which may bring them more
credit reward or stake reward. The only way to achieve
this attack is through group cheating that several malicious

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

10

(a) Gini coefﬁcient, Baseline DPoS

(b) Gini coefﬁcient, Our BDCT

(c) Lorenz Curve, Baseline DPoS

(d) Lorenz Curve, Our BDCT

Fig. 4. Lorenz Curve and Gini Coefﬁcient of proposed BDCT framework and baseline DPoS

TABLE 1
Average Contact Case Loss Percentage at Different Failure Rate p

User failure rate
BDCT
BDCT-w/o-Witness

p=0.1

p=0.6
0.18±0.02% 0.45± 0.03%
3.69±0.03%
2.25±0.03% 6.12± 0.03% 11.12± 0.04% 18.70±0.09% 27.63±0.07% 38.74±0.14%

p=0.5
1.96±0.12%

p=0.3
0.68±0.01%

p=0.4
1.19±0.02%

p=0.2

users together create and verify transactions. More specif-
ically, malicious users have two attack approaches to get
a fake transaction veriﬁed. They can create a contact list
where all the contacts are malicious users, or put malicious
witness in the witness list so that the whole transaction will
be veriﬁed as long as this malicious witness veriﬁes related
tuple in witness list no matter whether the contact case is
real or fake in the contact list. Next we describe how each of
the attack approach impacts the whole system.

too much.

If a malicious user attacks through the second method,
that a malicious witness is put in the witness list for every
false transaction, it may include false contact cases in the
contact list. However, according to the proposed RSA-TVM
method, the tuple recording the false contact case can be
veriﬁed wrong and hence not be preserved before the trans-
action is put into the transaction pool. Therefore, the impact
of this attack can also be controlled.

If a malicious user chooses the ﬁrst method, that creates
contact list composed by other malicious users, this will
not bring any false information to other honest users. The
malicious users may earn more credits by generating or
verifying numerous fake transactions, but the number of
transactions is limited by the Bluetooth scanning frequency
speciﬁed by the system, e.g. 5 minutes. In other words, a
user can generate at most twelve transactions per hour. In
addition, the proposed RC-DPoS and incentive mechanism
can well balance the stake reward as shown in Figure 4.
Therefore malicious users will not dominate stake reward

7.5 Storage Cost Evaluation

In BDCT framework, every user is holding the whole copy
of blockchain where the contact transactions are stored. We
evaluate the expected blockchain storage cost of the pro-
posed BDCT framework by calculating the expected number
of transactions and blocks generated per hour with respect
to our experiment setting.

We denote the expected size of total blockchain segment
generated per hour as E(ST B/h), expected size of all block
heads per hour as E(SBH/h), and expected size of all block

200040006000800010000Height of Blockchain0.00.10.20.30.40.50.60.70.80.9Gini IndexBaseline, Total user 600, Gini Index with Height of blockCreditBalanceMining Count0200040006000800010000Height of Blockchain0.00.10.20.30.40.50.60.70.80.9Gini IndexTotal user 600, Gini Index with Height of blockCreditBalanceMining Count020406080100Cumulative % of users020406080100Cumulative % of  corresponding valueBaseline, Total user 600, Mined 10000 Blocksuser credit, gini = 0.0user balance, gini = 0.56mined blocks count, gini = 0.12equality, gini = 0020406080100Cumulative % of users020406080100Cumulative % of  corresponding valueTotal user 600, Mined 10000 Blocksuser credit, gini = 0.57user balance, gini = 0.19mined blocks count, gini = 0.27equality, gini = 0JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

bodies per hour as E(SBB/h). The size of single block head
is denoted as sBH , the expected amount of blocks generated
per hour is NB/h. Hence, E(SBH/h) = E(NB/h) ∗ sBH . The
block bodies contains transactions, therefore E(SBB/h) =
E(ST /h), where E(ST /h) is the expected size of total trans-
actions generated per hour. Consequently, E(ST B/h) is cal-
culated by Equation 5.

E(ST B/h) = E(SBH/h) + E(SBB/h)

= E(NB/h) ∗ sBH + E(ST /h)

(5)

The speed of generating a block is predeﬁned in the
system, e.g. every 5 minutes. Therefore E(NB/h) = 12.
Based on the block structure illustrated in Figure 3, sBH
can be calculated as Equation 6.

sBH = sBlockHash + sP reviousBlockHash
+ sT imestamp

+ suDID
= 2 ∗ sBlockHash + suDID
= 2 ∗ 256 bits + 10 bytes + 32 bits
= 64 bytes + 10 bytes + 4 bytes = 78 bytes

+ sT imestamp

(6)

sBlockHash is the size of a unique block ID, which is a
SHA256 hash value, therefore sBlockHash = 256 bits. suDID
is the size of block generator’s device ID. In our framework,
the set device ID a string contains 10 Hex characters, which
can represent 210∗4 ≈ 1.1 × 1012 unique devices. Since each
char type hex character take 1 byte, suDID
= 10 bytes.
sT imestamp is size of an Unix timestamp of 32 bit integer
type, hence sT imestamp = 32 bits.

In our experiment settings, three different contact sce-
narios are considered with different contact case generating
frequency, number of contacted people and number of wit-
nesses. Though there may also registration transactions in
block bodies, registration transactions cost minor storage.
In this discussion, we consider the general case that block
bodies contain only contact transactions. Then E(ST /h) is
the sum of expected all transactions generated by 3 contact
scenarios as in Equation 7.

E(ST /h) = E(ST S/h) + E(ST M/h) + E(ST C/h)

(7)

E(ST S/h), E(ST M/h) and E(ST C/h) are the expected
numbers of transactions generated per hour in Sparse sce-
nario, Medium scenario and Crowded scenario respectively.
We denote E(NT S/h) as the expected number of transac-
tions (contact cases) per hour in Sparse scenario and E(sT S)
as the expected size of a transaction generated in Sparse
scenario. Given the contact transaction structure described
in Section 4.2, E(sT S) is composed by size of transaction
ID sTid , size of transaction generator’s device ID suDID ,
size of transaction timestamp sT imestamp, expected size of
contact list E(sC) and expected size of witness list E(sW ).
In each contact list C or witness list W , there are signed
tuples (uiP ub key, SDuiP ri key ). The size of signed tuples is
denoted as sst. In our experiments, we generate 1024 bits
RSA Keys with the Python package Crypto4. With the secret
message as 10 Hex characters, sst = 56 bytes + 161 bytes =
217 bytes in our simulation.

Though the length of contact list and witness list are
sampled from normal distribution described in Section 7.1,

4. https://pycryptodome.readthedocs.io

we set the length to 0 if the sampled length is less than
0. The expected length of contact list E(NC) based such
sample strategy satisﬁes Equation 8.

11

E(NC) =

(cid:90) ∞

x

0

exp(−

x exp(−

(x − µ)2
2σ2
(x − µ)2
2σ2

) dx

) dx

1
√
σ
2π
(cid:90) ∞

0
(cid:90) ∞

=

=

=

=

=

1
√
2π
σ
√
2σ
√
2π
√
(

1
√
π

σ

√
(

1
√
π

1
√
π

(

σ
√
2

− µ
√
2σ
(cid:90) ∞

2σ

2σ

(cid:20)

−

− µ
√
2σ
1
2
exp− µ2

√
(

2σt + µ) exp−t2

dt(with t =

x − µ
√
2σ

)

t exp−t2

dt + µ

exp−t2(cid:21)∞

+ µ

− µ
√
2σ

(cid:90) ∞

− µ
√
2σ
(cid:90) ∞

− µ
√
2σ

2σ2 +µZ(t))

exp−t2

dt)

exp−t2

dt))

(8)

exp−t2

dt

exp−t2

dt +

(cid:90) ∞

exp−t2

dt

Z(t) =

=

=

=

≤

(cid:90) ∞

− µ
√
2σ
(cid:90) 0

− µ
√
2σ
(cid:90) µ

√

2σ

0
(cid:90) µ

√

2σ

0

0
(cid:90) ∞

1
2
√

π
2
√
π
2
π
2

0
(cid:90) µ

√

2σ

exp−t2

dt +

dt +
√

1
t2 + 1
µ
√
2σ

= arctan(

) +

exp−t2

dt +

exp−t2

dt

−∞

(9)

E(ST S/h) = E(NT S/h) ∗ E(sT S)

+ sT imestamp

= 1 ∗ (sTid + suDID
+ E(sC) + E(sW ))
= 256 bits + 10 bytes + 32 bits + E(sC) + E(sW )
= 46 bytes + E(NC) ∗ sst + E(NW ) ∗ sst

√
√

2
π

√
2
√
π
2

+

) ∗ 217 bytes

≤ 46 bytes + (

≈ 306 bytes.

(10)
Since Z(t) is limited by an upper bond, we can calculate
upper bond of the expected number of transactions per hour
in Sparse scenario as Equation 10. Similarly, E(ST M/h) ≤
3374 bytes and E(ST C/h) ≤ 36227 bytes.

Hence E(ST /h) ≤ 306 + 3374 + 36227 = 39907 bytes.
Then E(ST B/h) = E(NB/h) ∗ sBH + E(ST /h) = 12 ∗ 78 +
39907 bytes = 40843 bytes ≈ 39.89 KB. Therefore the
expected storage cost for the blockchain generated per day
is 24 ∗ E(ST /h) = 24 ∗ 39.89 KB = 957.36 KB < 1M B,
which is totally affordable for most smart devices.

8 CONCLUSION
In this article, we propose a Blockchain Driven Contact
Tracing framework (BDCT), which is a fully decentralized

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

framework without any third-party required. We propose
the role “witness” in the framework to promote contact
tracing data integrity, and the RSA based Transaction Ver-
iﬁcation Method (RSA-TVM) to verify the correctness of
the reported contact cases. Reputation Corrected Delegated
Proof of Stake (RC-DPoS) consensus mechanism is applied
to select miners based on both users’ reputation and users’
stake. An incentive mechanism is further developed to mo-
tivate people to keep reporting contact cases honestly and
work with RC-DPoS achieving balanced stake reward dis-
tribution to maintain the whole framework decentralized.
In the simulation, we propose a simulation environment,
which mixes three contact scenarios based on different
population density. The simulation results demonstrate our
proposed framework can achieve signiﬁcantly decentrality
than the baseline framework, and RSA-TVM incorporated
with “witness” role in the framework can hugely improve
the system robustness.

For future work, better consensus mechanism should be
designed to lower communication cost. In BDCT, though
the computation cost is eliminated and storage cost is con-
sidered acceptable, the communication cost is still high for
circulating contact transactions among devices to get contact
cases veriﬁed especially when contact cases are tremendous.
Synchronizing blockchain and shared transaction pool also
imposes communication stress on smart devices. Therefore
a better communication protocol is highly demanded for
making more scalable contact tracing applications.

REFERENCES

[1] E. Dong, H. Du, and L. Gardner, “An interactive web-based
dashboard to track covid-19 in real time,” The Lancet. Infectious
Diseases, vol. 20, pp. 533 – 534, 2020.

[2] W. H. Organization et al., “Contact tracing during an outbreak of

[3]

ebola virus disease,” 2014.
J. Bay, J. Kek, A. Tan, and C. S. Hau, “Bluetrace: A privacy-
preserving protocol for community-driven contact tracing across
borders,” 2020.

[4] F. Liang, “Covid-19 and health code: How digital platforms tackle
the pandemic in china,” Social Media + Society, vol. 6, no. 3,
p. 2056305120947657, 2020, pMID: 34192023. [Online]. Available:
https://doi.org/10.1177/2056305120947657

[5] Apple

and Google,

covid-19 contact
Available:
apple-and-google-partner-on-covid-19-contact-tracing-technology/

on
[Online].
https://www.apple.com/newsroom/2020/04/

tracing technology,” Dec 2021.

partner

“Apple

google

and

[6] H. R. Hasan, K. Salah, R. Jayaraman, I. Yaqoob, M. Omar, and
S. Ellahham, “Covid-19 contact tracing using blockchain,” IEEE
Access, 2021.

[7] H. Xu, L. Zhang, O. Onireti, Y. Fang, W. J. Buchanan, and
M. A. Imran, “Beeptrace: Blockchain-enabled privacy-preserving
tracing for COVID-19 pandemic and beyond,” IEEE
contact
Internet Things J., vol. 8, no. 5, pp. 3915–3929, 2021. [Online].
Available: https://doi.org/10.1109/JIOT.2020.3025953

[8] W. Lv, S. Wu, C. Jiang, Y. Cui, X. Qiu, and Y. Zhang, “Towards
large-scale and privacy-preserving contact tracing in COVID-19
pandemic: A blockchain perspective,” IEEE Trans. Netw. Sci.
Eng., vol. 9, no. 1, pp. 282–298, 2022.
[Online]. Available:
https://doi.org/10.1109/TNSE.2020.3030925
S. Altmann, L. Milsom, H. Zillessen, R. Blasone, F. Gerdon, R. L.
Bach, F. Kreuter, D. Nosenzo, S. Toussaert, and J. Abeler, “Accept-
ability of app-based contact tracing for covid-19: Cross-country
survey study,” JMIR mHealth and uHealth, vol. 8, 2020.

[9]

[10] T. Altuwaiyan, M. Hadian, and X. Liang, “Epic: Efﬁcient privacy-
preserving contact tracing for infection detection,” 2018 IEEE
International Conference on Communications (ICC), pp. 1–6, 2018.
[11] A. Prasad and D. F. Kotz, “Enact: Encounter-based architecture for
contact tracing,” Proceedings of the 4th International on Workshop on
Physical Analytics, 2017.

12

[12] S. Nisar, M. A. Zuhaib, A. Ulasyar, and M. Tariq, “A privacy
preserved and cost efﬁcient control scheme for coronavirus out-
break using call data record and contact tracing,” IEEE Consumer
Electronics Magazine, 2020.

[13] A. Trivedi, C. Zakaria, R. K. Balan, and P. J. Shenoy, “Wiﬁtrace:
Network-based contact tracing for infectious diseases using pas-
sive wiﬁ sensing,” Proc. ACM Interact. Mob. Wearable Ubiquitous
Technol., vol. 5, pp. 37:1–37:26, 2021.

[14] A. Hekmati, G. S. Ramachandran, and B. Krishnamachari, “Con-
tain: Privacy-oriented contact tracing protocols for epidemics,”
2021 IFIP/IEEE International Symposium on Integrated Network Man-
agement (IM), pp. 872–877, 2021.

[15] P. C. Ng, P. Spachos, and K. N. Plataniotis, “Covid-19 and your
smartphone: Ble-based smart contact tracing,” IEEE Systems Jour-
nal, vol. 15, pp. 5367–5378, 2021.

[16] L. Reichert, S. Brack, and B. Scheuermann, “Privacy-preserving
contact tracing of covid-19 patients.” IACR Cryptol. ePrint Arch.,
vol. 2020, p. 375, 2020.

[17] J. Chan, D. Foster, S. Gollakota, E. Horvitz, J. Jaeger, S. Kakade,
T. Kohno, J. Langford, J. Larson, P. Sharma et al., “Pact: Privacy
sensitive protocols and mechanisms for mobile contact tracing,”
arXiv preprint arXiv:2004.03544, 2020.

[18] M. A. Azad, J. Arshad, S. M. A. Akmal, F. Riaz, S. Abdullah,
M. Imran, and F. Ahmad, “A ﬁrst look at privacy analysis
of COVID-19 contact-tracing mobile applications,” IEEE Internet
Things J., vol. 8, no. 21, pp. 15 796–15 806, 2021. [Online]. Available:
https://doi.org/10.1109/JIOT.2020.3024180

[19] N. Ahmed, R. A. Michelin, W. Xue, S. Ruj, R. A. Malaney,
S. S. Kanhere, A. Seneviratne, W. Hu, H. Janicke, and S. K.
tracing apps,” IEEE
Jha, “A survey of COVID-19 contact
Access, vol. 8, pp. 134 577–134 601, 2020.
[Online]. Available:
https://doi.org/10.1109/ACCESS.2020.3010226

[20] S. Nakamoto, “Bitcoin : A peer-to-peer electronic cash system,”

2009.

[21] J. Guo, X. Ding, and W. Wu, “A blockchain-enabled ecosystem
for distributed electricity trading in smart city,” IEEE Internet
Things J., vol. 8, no. 3, pp. 2040–2050, 2021. [Online]. Available:
https://doi.org/10.1109/JIOT.2020.3015980

[22] Y. Fan, L. Wang, W. Wu, and D. Du, “Cloud/edge computing
resource allocation and pricing for mobile blockchain: An
iterative greedy and search approach,” IEEE Trans. Comput.
Soc. Syst., vol. 8, no. 2, pp. 451–463, 2021. [Online]. Available:
https://doi.org/10.1109/TCSS.2021.3049152

[23] X. Ding, J. Guo, D. Li, and W. Wu, “An incentive mechanism
for building a secure blockchain-based internet of things,” IEEE
Trans. Netw. Sci. Eng., vol. 8, no. 1, pp. 477–487, 2021. [Online].
Available: https://doi.org/10.1109/TNSE.2020.3040446

[24] L. Dong, W. Wu, Q. Guo, M. N. Satpute, T. Znati,
and D. Du, “Reliability-aware ofﬂoading and allocation in
IEEE Trans. Reliab.,
multilevel
vol. 70, no. 1, pp. 200–211, 2021. [Online]. Available: https:
//doi.org/10.1109/TR.2019.2909279

computing system,”

edge

[25] C. Luo, L. Xu, D. Li, and W. Wu, “Edge computing
integrated with blockchain technologies,” in Complexity and
Approximation -
In Memory of Ker-I Ko, ser. Lecture Notes
in Computer Science, D. Du and J. Wang, Eds., vol.
12000.
[Online]. Available:
https://doi.org/10.1007/978-3-030-41672-0 17

2020, pp.

Springer,

268–288.

[26] S. M. Idrees, M. Nowostawski, and R. Jameel, “Blockchain-based
digital contact tracing apps for covid-19 pandemic management:
Issues, challenges, solutions, and future directions,” JMIR medical
informatics, vol. 9, no. 2, p. e25245, 2021.

[27] M. M. Arifeen, A. Al Mamun, M. S. Kaiser, and M. Mahmud,
“Blockchain-enable contact tracing for preserving user privacy
during covid-19 outbreak,” 2020.

[28] C. Zhang, C. Xu, K. Sharif, and L. Zhu, “Privacy-preserving
contact tracing in 5g-integrated and blockchain-based medical
applications,” Comput. Stand. Interfaces, vol. 77, p. 103520, 2021.
[Online]. Available: https://doi.org/10.1016/j.csi.2021.103520

J. Huang,

[29] Z. Peng, C. Xu, H. Wang,

J. Xu, and X. Chu,
“P2b-trace: Privacy-preserving blockchain-based contact tracing
to combat pandemics,” in SIGMOD ’21: International Conference on
Management of Data, Virtual Event, China, June 20-25, 2021, G. Li,
Z. Li, S. Idreos, and D. Srivastava, Eds. ACM, 2021, pp. 2389–2393.
[Online]. Available: https://doi.org/10.1145/3448016.3459237
[30] S. L. T. Vangipuram, S. P. Mohanty, and E. Kougianos, “Covichain:
A blockchain based framework for nonrepudiable contact

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

13

tracing in healthcare cyber-physical systems during pandemic
outbreaks,” SN Comput. Sci., vol. 2, no. 5, p. 346, 2021. [Online].
Available: https://doi.org/10.1007/s42979-021-00746-x

[31] M. Zuhair, F. Patel, D. Navapara, P. Bhattacharya, and D. Saraswat,
“Blocov6: A blockchain-based 6g-assisted uav contact tracing
scheme for covid-19 pandemic,” in 2021 2nd International Confer-
ence on Intelligent Engineering and Management (ICIEM).
IEEE,
2021, pp. 271–276.

[32] M. Salimibeni, Z. Hajiakhondi-Meybodi, A. Mohammadi, and
Y. Wang, “TB-ICT: A trustworthy blockchain-enabled system for
indoor COVID-19 contact tracing,” CoRR, vol. abs/2108.08275,
2021. [Online]. Available: https://arxiv.org/abs/2108.08275
[33] A. Kotanen, M. Hannikainen, H. Leppakoski, and T. D.
Hamalainen, “Experiments on local positioning with bluetooth,”
in Proceedings ITCC 2003. International Conference on Information
Technology: Coding and Computing.

IEEE, 2003, pp. 297–303.

[34] R. L. Rivest, A. Shamir, and L. Adleman, “A method for obtaining
digital signatures and public-key cryptosystems,” Communications
of the ACM, vol. 21, no. 2, pp. 120–126, 1978.

[35] H. Gilbert and H. Handschuh, “Security analysis of SHA-256 and
sisters,” in Selected Areas in Cryptography, 10th Annual International
Workshop, SAC 2003, Ottawa, Canada, August 14-15, 2003, Revised
Papers, ser. Lecture Notes in Computer Science, M. Matsui and R. J.
Zuccherato, Eds., vol. 3006. Springer, 2003, pp. 175–193. [Online].
Available: https://doi.org/10.1007/978-3-540-24654-1 13

[36] D. Larimer, “Delegated proof-of-stake (dpos),” Bitshare whitepaper,

vol. 81, p. 85, 2014.

[37] K. K.

Jahromi, M. Zignani, S. Gaito, and G. P. Rossi,
“Simulating human mobility patterns in urban areas,” Simul.
Model. Pract. Theory, vol. 62, pp. 137–156, 2016. [Online]. Available:
https://doi.org/10.1016/j.simpat.2015.12.002

[38] X. Huang, Y. Yin, S. Lim, G. Wang, B. Hu, J. Varadarajan, S. Zheng,
A. Bulusu, and R. Zimmermann, “Grab-posisi: An extensive real-
life gps trajectory dataset in southeast asia,” in Proceedings of the 3rd
ACM SIGSPATIAL International Workshop on Prediction of Human
Mobility, 2019, pp. 1–10.

[39] C. DiDi, “Data source: Didi chuxing gaia open dataset initiative,”
[Online]. Available: https://outreach.didichuxing.com/

2019.
research/opendata/en/

[40] R. Mariescu-Istodor and P. Fr¨anti, “Cellnet:

Inferring road
networks from GPS trajectories,” ACM Trans. Spatial Algorithms
Syst., vol. 4, no. 3, pp. 8:1–8:22, 2018.
[Online]. Available:
https://doi.org/10.1145/3234692

[41] J. Yuan, Y. Zheng, C. Zhang, W. Xie, X. Xie, G. Sun, and
Y. Huang, “T-drive: driving directions based on taxi trajectories,”
in 18th ACM SIGSPATIAL International Symposium on Advances
in Geographic Information Systems, ACM-GIS 2010, November 3-5,
2010, San Jose, CA, USA, Proceedings, D. Agrawal, P. Zhang,
A. E. Abbadi, and M. F. Mokbel, Eds. ACM, 2010, pp. 99–108.
[Online]. Available: https://doi.org/10.1145/1869790.1869807
[42] J. Lian and L. Zhang, “One-month beijing taxi GPS trajectory
dataset with taxi ids and vehicle status,” in Proceedings of the
First Workshop on Data Acquisition To Analysis, DATA@SenSys 2018,
Shenzhen, China, November 4, 2018, J. Gao, P. Zhang, S. Pan,
[Online]. Available:
and C. Ni, Eds. ACM, 2018, pp. 3–4.
https://doi.org/10.1145/3277868.3277870

[43] N. C. Kakwani, “Applications of lorenz curves in economic
analysis,” Econometrica, vol. 45, no. 3, pp. 719–727, 1977. [Online].
Available: http://www.jstor.org/stable/1911684

[44] R. Dorfman, “A formula for the gini coefﬁcient,” The review of

economics and statistics, pp. 146–149, 1979.

[45] L. Reichert, S. Brack, and B. Scheuermann, “A survey of automatic
contact tracing approaches using bluetooth low energy,” ACM
Trans. Comput. Heal., vol. 2, no. 2, pp. 18:1–18:33, 2021. [Online].
Available: https://doi.org/10.1145/3444847

Xiao Li received his B.S. and M.S degree in
Software Engineering from Dalian University of
Technology, China in 2016 and 2019, respec-
tively. He is currently pursuing the Ph.D. degree
with the Department of Computer Science, Uni-
versity of Texas at Dallas, Richardson, TX, USA.
His current research interests include data min-
ing and Blockchain.

Weili Wu (Senior Member, IEEE) received the
M.S. and Ph.D. degrees from the Department
of Computer Science, University of Minnesota,
Minneapolis, MN, USA, in 1998 and 2002, re-
spectively. She is currently a Full Professor with
the Department of Computer Science, University
of Texas at Dallas, Richardson, TX, USA. Her
research mainly deals in the general research
area of data communication and data manage-
ment. Her research focuses on the design and
analysis of algorithms for optimization problems
that occur in wireless networking environments and various database
systems.

Tiantian Chen is a Ph.D. candidate in the De-
partment of Computer Science, The University
of Texas at Dallas. She received her B.S. de-
gree in Mathematics and Applied Mathematics,
and M.S. degree in Operational Research and
Cybernetics from Ocean University of China in
2016 and 2019, respectively. Her research fo-
cuses on social networks, design and analysis
of approximation algorithms, deep learning, and
reinforcement learning.

