2
2
0
2

y
a
M
1
2

]

R
C
.
s
c
[

2
v
7
0
4
9
0
.
2
0
2
2
:
v
i
X
r
a

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

1

Blockchain Driven Privacy Preserving Contact
Tracing Framework in Pandemics

Xiao Li, Weili Wu, Senior Member and Tiantian Chen

Abstractâ€”Contact tracing has been proven an effective approach to control the virus spread in pandemics like COVID-19 pandemic.
As an emerging powerful decentralized technique, blockchain has been explored to ensure data privacy and security in contact tracing
processes. However, existing works are mostly high-level designs with no sufï¬cient demonstration and treat blockchain as separate
storage system assisting third-party central servers, ignoring the importance and capability of consensus mechanism and incentive
mechanism. In this paper, we propose a light-weight and fully third-party free Blockchain-Driven Contact Tracing framework (BDCT) to
bridge the gap. In the BDCT framework, RSA encryption based transaction veriï¬cation method (RSA-TVM) is proposed to ensure
contact tracing correctness, which can achieve more than 96% contact cases recording accuracy even each person has 60%
probability of failing to verify the contact information. Reputation Corrected Delegated Proof of Stake (RC-DPoS) consensus
mechanism is proposed together with the incentive mechanism, which can ensure timeliness of reporting contact cases and keep
blockchain decentralized. A novel contact tracing simulation environment is created, which considers three different contact scenarios
based on population density. The simulation results demonstrate the effectiveness, robustness and attack resistance of RSA-TVM and
RC-DPoS in the proposed BDCT.

Index Termsâ€”Blockchain, COVID-19 Pandemic, Contact Tracing, DPoS, RSA

(cid:70)

1 INTRODUCTION

S INCE the ï¬rst case of the novel corona-virus COVID-

19 discovered in December 2019, there have been over
510 million globally conï¬rmed cases, including 6 million
deaths by April 20221. The COVID-19 pandemic has brought
considerable degree of fear, emotional stress and anxiety
among individuals around the world [1]. The virus causes
severe acute respiratory infection, bringing symptoms such
as cough, fever, fatigue and breathlessness, which are very
similar to symptoms caused by regular inï¬‚uenza. In ad-
dition, the high contagiousness makes it even hard to be
controlled. In order to help people who have contact with
the patient get medical treatment timely, it is imperative to
record the contact histories of the patients.

The World Health Organization (WHO) has announced
the importance of contract tracing since EBOLA outbreak
in 2014 [2]. Formally, the contact tracing is the process of
identifying history contact cases of people who may have
come into contact with infected patients. Many countries
have developed contact tracing methods, such as Trace To-
gether in Singapore [3] and the QR code System in China [4].
Some technology companies also developed contact tracing
tools, such as Google and Apple developed a Bluetooth-
based API that can be used by third parties to develop
smart phone apps [5]. These apps mostly use Bluetooth to
recognize nearby devices or GPS signal to get the accurate
location coordinates to determine contact cases. Most of
these tracing systems rely on central servers controlled by

â€¢ Corresponding Author: Xiao Li, Email: xiao.li@utdallas.edu

â€¢ This work was supported in part by the US National Science Foundation

(NSF) under Grant NO.1822985.

Manuscript received April 19, 2005; revised August 26, 2015.

1. https://covid19.who.int/

governments or healthcare authorities, which may collect
the usersâ€™ identities and other privacy data through an
application installed on smart phones.

Systems based on centralized servers suffer single-point
failure and are weak to attacks. Decentralized contact trac-
ing methods are then promoted, which give more control
to users. In decentralized model, users are not required to
update all data to the server. They can hold data locally, and
share their data when necessary.

As an emerging decentralized data generating, sharing
and storing technique, blockchain systems are introduced to
solve contact tracing tasks to promote the security and pri-
vacy. Blockchain stores data into blocks that are connected
to each other as a chain. The data stored in blocks are not
able to be tempered. Smart contract deployed on blockchain
can perform various functionalities. Furthermore, encryp-
tion and anonymization technologies can be applied in
blockchain system to protect userâ€™s identity. The consensus
mechanism in Blockchain allows blockchain systems keep
working stably without a central server.

There are some initial attempts of contact tracing systems
using blockchain technologies. Hasan et al. [6] propose
proof of location and develop smart contracts to ensure the
privacy of contact list. However, no simulation is provided.
In addition, there is no incentive mechanism to motivate
users to join the system. Authors assume there are plenty
of users in the system behaving honestly, while the situa-
tion is hard to achieve in practice. Xu et al. [7] proposes
BeepTrace blockchain-based contact tracing solution, where
a blockchain system plays the neutral role in bridging data
transmission between different parties, such as patients,
doctors and government authorities. The usersâ€™ geodata are
securely preserved in specially designed blockchain. How-
ever, the efï¬ciency of this system is not demonstrated, and

 
 
 
 
 
 
JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

no speciï¬c consensus mechanism and incentive mechanism
are speciï¬ed in the paper. Lv et al. [8] proposes Bychain, a
three-layer contact tracing framework without reliance on
trusted third parties. Proof of Location (PoL) is proposed to
verify the contact record and incentive mechanism is design
for maximizing contact tracing range. However, Bychain is
not able to produce person-to-person accurate contact cases.

We conclude 4 main challenges to develop a third-party
free blockchain-based contact tracing method. The 4 chal-
lenges are overlapped with each other: 1) Instead of simply
treating blockchain as a separated storage method, how
to leverage powerful consensus mechanism in blockchain
system to promote data security; 2) How to design an
effective consensus mechanism to organize data storage and
meanwhile achieve low latency of recording contact infor-
mation. The popular consensus mechanisms are usually too
computational expensive for mobile devices, and may bring
signiï¬cant delay of recording contact information. People
should be able to access latest contact records timely to
prevent further possible virus spread. 3) How to design the
incentive mechanism so that people are motivated to join
the contact tracing system and behaviour honestly. 4) Due
to lack of real-world contact data, as well as high cost of
testing whole system in practice, it is hard to evaluate the
effectiveness and efï¬ciency of whole systems. The difï¬culty
of collecting real-world contact information, is not only from
privacy concerns, but also diversity of people contact sce-
narios. Contact cases happened in crowded cities and those
happened in rural areas are totally different scenarios with
different frequencies and amounts. This diversity brings
challenge to design incentive mechanism fair to every one.

There is seldom work that clearly addresses all above
mentioned 4 challenges. In addition, according to the survey
conducted at multiple countries in [9], though most people
accept app-based tracing methods, the concern about the
security and privacy is still an obstacle to the common
adoption of tracing apps in many countries. Therefore, in
this article, we aim to tackle the 4 challenges with the
usersâ€™ privacy ensured by proposing a fully third-party free
contact tracing framework with blockchain technology. A
RSA based transaction veriï¬cation algorithm is proposed
to ensure the correctness of recorded contact information
and improve system robustness. To efï¬ciently store contact
information into blocks, we propose Reputation Corrected
Delegated Proof of Stake (RC-DPoS) consensus mechanism,
which can control the right of appending new blocks. An
incentive mechanism is then designed to work with RC-
DPoS motivating people to work honestly and maintaining
system decentrality. Finally, we design a contact tracing sim-
ulation method that simulates different real-world people
contact scenarios to evaluate the effectiveness of proposed
framework.

2

2 RELATED WORK
2.1 Traditional Contact Tracing Methods

Contact tracing refers to the process that records the people
contact history so that the people contacted with a patient
can be informed and get medical treatment timely to control
the spread of virus.

Various contact tracing tools have been developed using
location technologies such as GPS, Wiï¬, cell tower signal
and Bluetooth [10], [11], [12], [13], [14], [15].

Reichert et al. [16] propose a centralized contact tracing
method, which assumes every user has their location history
stored in their devices, and the health authorities are able
to read the data. Nisar et al. [12] propose to use call data
record to trace the patient once she/he is diagnosed positive.
However, the trace build is not practical since most people
don not answer phones calls very frequently during a day,
therefore we can only get limited number of locations.

The contact tracing system based on GPS signal are not
reliable for in-door situations, while in-door contact is one
major way of virus spread due to short contact distance
and long contact time. Some work proposes to use WiFi
or wireless access points to discover contact cases [10],
[11], [13]. These frameworks require users to connect their
devices to speciï¬c wireless access points. However, in some
public areas such as shopping malls, airports and train
stations, people may not join public WiFi due to network
security concerns. Bluetooth technology can scan nearby
devices and get device identities within a small range, which
can help generate the contact cases [15]. In this article, we
also leverage this advantage to protect users privacy that
avoids disclosing usersâ€™ real identities and speciï¬c locations.
Chan et al. [17] propose PACT protocol, where every user
holds the contact tracing data on their own local devices,
and only when they are tested positive, they will broadcast
their contact information to a public platform. Every other
user will check the list on the platform to conï¬rm if they
have contacted with anyone in that list. Though this protocol
is a third-party-free mobile contracting protocol and easy
to be implemented in practice, However The users are not
guaranteed to behave honestly, and the public platform is
easy to be compromised since it is open to anyone.

Most of existing works are centralized where third-party
servers are used collecting userâ€™s personal data and contact
history to match contact records [18]. Centralized models are
exposed to risks of single point failure, privacy data leaking
and security compromising. Though some contact tracing
methods are proposed to be decentralized [17], [19], these
methods still require a server to process data computing
functions and are vulnerable to dishonest behaviours from
malicious users.

2.2 Blockchain Based Contact Tracing Methods

The reminder of this article is organized as follows.
In Section 2, we discuss existing related work on contract
tracing. Section 3 is dedicated to presenting the overview
of proposed contact tracing framework. Next we elaborate
transaction veriï¬cation algorithm, RC-DPoS and incentive
mechanism in Section 4, Section 5 and Section 6, respec-
tively. Experimental simulation and discussion are con-
ducted in Section 7. Finally, Section 8 concludes the paper.

Blockchain technology is ï¬rst proposed by [20] as a dis-
tributed ledger for Bitcoin system, which ensures data secu-
rity without any trust given to third parties. A blockchain
system usually constructs a peer-to-peer network, where
each user plays exactly the same role and follows the same
protocol. Every user stores a whole copy of blockchain,
so that all the data on the blockchain are extremely hard
to be tempered and single-point failure can naturally be

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

avoided. Thereâ€™s no need of a central server to perform
functions in the system, such as collecting, computing or
storing data. Users (peers) in a blockchain system have
equal rights to perform functionalities by executing smart
contracts deployed in the system. A consensus mechanism
is enforced in the system to control which user is qualiï¬ed to
generate a new block at each step. An incentive mechanism
is also important in the system to motivate users to compete
for the right of generating a block.

Blockchain technology, ï¬rst known as distributed
ledger [20], can make a system work stably without any
trust built among parties. With anonymity techniques and
data encryption techniques, users in a blockchain system
can share data securely without compromising privacy.
Blockchain technology has demonstrated signiï¬cant feasi-
bility in IoT applications, which have similar requirements
as contact tracing systems [21], [22], [23], [24], [25].

Blockchain technology shows great potential for devel-
oping privacy preserving and efï¬cient contact tracing appli-
cations. Idrees et al. [26] point out several challenges and
risks associated with the available contact tracing apps and
analyze how the adoption of a blockchain-based decentral-
ized network could provide users with privacy-preserving
contact tracing.

Besides the BeepTrace [7] mentioned above, there ex-
ists many other blockchain-based contract tracing frame-
works or systems. Arifeen et al. [27] propose a high-
level blockchain based contract tracing framework where
blockchain is used for patients to publish contact list. Zhang
et al. [28] propose PTBM leveraging both permissionless
and permissioned blockchain to manage usersâ€™
location
data, and 5G technique provides support for low latency
communication. In PTBM, authorized third parties, such
as medical centers and medical organizations, are able to
compute the contact history and publish history route of
patients.

Peng et al. [29] propose P 2B, where users can upload
contact information to blockchain storage to be further
veriï¬ed and cross-checked by clients and authorities. P 2B
is demonstrated with higher data transmission efï¬ciency
than BeepTrace. Vangipuram et al. [30] propose a three-
tier architecture for storing numerous data collected by
Internet-of-MedicalThings (IoMT) for contact tracing. In the
architecture blockchain is employed to securely transfer the
data from the infected person to the hospital system using
the edge infrastructure.

Zuhair et al.

[31] consider a sixth-generation (6G)-
assisted unmanned aerial vehicles (UAVs) en-powered mass
surveillance system in dense areas, which can monitor
body temperature of persons with thermal imaging sensors.
Blockchain also works as storage system in their work,
and with the powerful bandwidth of 6G, the data can be
processed with low latency. Salimibeni et al. [32] consider in-
door contact tracing scenarios, and propose TB-ICT contact
tracing framework,where dynamic Proof of Work (dPoW)
credit-based consensus algorithm coupled with Random-
ized Hash Window (W-Hash) and dynamic Proof of Credit
(dPoC) mechanisms are proposed to differentiate between
honest and dishonest nodes. TB-ICT can motivate people
to behave honestly since better credit can decrease mining
difï¬culty. However, PoW-based consensus mechanism may

bring high computation overhead while BLE-carried devices
adopted in the system are not usually computational pow-
erful.

3

3 CONTRACT TRACING FRAMEWORK OVERVIEW

3.1 Problem Deï¬nition and Preliminary Settings

In this paper, we study the contact tracing problem as: given
Bluetooth signals on smart devices, with the constraints of
preserving privacy, we aim to output pairwise usersâ€™ contact
lists by discovering nearby Bluetooth devices. The goals to
achieve for the contact tracing problem are the completeness
and correctness of contact list, the contact tracing robustness
and attack resistance.

We assume our Blockchain-Driven Contact Tracing
framework (BDCT) is implemented and deployed through
clients on smart devices. People can join the contact tracing
system by installing the client on their smart devices. It
is assumed each user carries one device with the client
installed. The client will generate private-public key pair
and a unique device ID for each device. The client on a
device will use Bluetooth to share the device ID as well
as getting device IDs of other nearby devices. Bluetooth
is capable to evaluate the distance between two devices
within a certain range by the strength of Bluetooth signal.
Therefore, the contact distance can be easily computed [33].
The furthest contact distance considered in this paper is 5
meters where Bluetooth can produce strong enough signal
to support accurate computation. In this paper, since we
directly record the device IDs of contacts rather than record
accurate GPS coordinates and match contact information
afterwards, without any accurate location data recorded,
privacy will be preserved.

3.2 Contact Tracing Procedure

At a given frequency, the client on a smart device will
scan and record all the device IDs of nearby devices within
a range. This process is fast and secure since the client
only scans surrounding devices without having to establish
stable connection to them, which also avoids cyberattack
through Bluetooth channel. If there is a device detected
within 2 meters2, the client will identify this as a contact
case. The client will then store the device IDs of contacted
devices into contact list locally in a special format which will
be speciï¬ed in next section.

Most of previous works ignore the fact that mobile
devices are not as robust as computers in terms of internet
connectivity, system robustness and security level. The de-
vice may fail to collect the contacted device information, or
be attacked to record false contact list. To improve the data
integrity, a special role witness is proposed in this paper.
All the devices that are 2 meters away but still within 5
meters from the current device are considered witnesses of
the contact case. Witnesses play important roles in BDCT,
which help verify the reported contact list, speed up the
veriï¬cation process, and recover the missed contacts. The
client will also store the device IDs of witnessed devices
into witness list locally in the similar format as contact list.

2. The distance can be adjusted according to particular scenarios.

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

4

Fig. 1. Overview of Contact Tracing Framework (User u1 generates a transaction))

With the pseudo IDs of contact devices and witness devices
stored locally, users can check whom they have contacted
with and who have witnessed their contact cases at any time
without knowing the real identity of the device owner.

Based on the above setting, we now illustrate the whole
Blockchain-Driven Contact Tracing Framework (BDCT) in
Figure 1 with an example.

In Figure 1, at a given Timestamp, assume user u1 would
like to report his current contact case. He will initiate a
contact tracing transaction Tcon. letâ€™s assume users u2 and
u3 are within 2 meters from u1 and hence considered a
contact case with user u1. Users u4 and u5 are 2 meters
away but still within 5 meters from u1, and they witness that
u1 is with u2 and u3. u6 and u7 are considered irrelevant
to this contact case. As in the ï¬gure, there are 6 steps
from generating contact record as blockchain transaction to
the transaction being stored to blockchain storage in every
device.

Step 1: User u1 initiates a blockchain transaction Tcon =
{Tid, u1, ContactList, W itnessList, T imestamp}, which is
used for record the contact case of u1 at T imestamp. One
transaction represents one contact case of users at some
timestamp. Tid is an unique transaction ID for each trans-
action. T imestamp is the exact time that u1 contacts the
users in ContactList. The ContactList and W itnessList
contains secret messages from u1 encrypted by the public
keys of each contacted devices (u2 and u3) or witness
devices (u4 and u5). Formal deï¬nition of ContactList and
W itnessList will be presented in Section 4.

Step 2: User u1 then broadcasts the transaction Tcon
through internet to every user who have the client installed.
Since no one knows othersâ€™ identities, u1 is not able to
directly send message to u2, u3, u4 and u5.

Step 3: When other users receive the transaction Tcon,
it will check if it contacted with u1 at T imestamp or if
it witnessed the reported contact case. Then the contacted
users in this example, u2 and u3, and the witnessed users,
u4 and u5, will try decode the received message, sign the
decoded message and broadcast this signed transaction. The

transaction generator u1 will receive the signed transaction.
Step 4: After receiving the signed transaction Tcon, u1
will verify the signature by decoding the signature with
contactâ€™s or witnessâ€™s public key to make sure the contact
list and witness list are signed by correct people. u1 will
wait for the signatures within a speciï¬c delay d, such as 60
minutes. Only the records in ContactList veriï¬ed valid will
be ï¬nally preserved in Tcon. u1 will put transaction Tcon into
a shared transaction pool which is synchronized on every
device along with blockchain.

Step 5: At given frequency, one of the candidate min-
ers will be selected to package all the transactions in the
transaction pool into a block. In this paper, we propose
the Reputation-Corrected DPoS (RC-DPoS) mechanism to
choose the candidate miners, which will be presented in
detail in Section 5.

Step 6: The block is ï¬nally appended to the blockchain
by the miner, and broadcast to all users in the network for
synchronizing.

Step 1 to Step 4 will be elaborated in Section 4 by
proposing RSA-Based transaction veriï¬cation method. In
Section 5, RC-DPoS and corresponding incentive mecha-
nism are presented to complete Step 5 and Step 6.

4 TRANSACTION VERIFICATION METHOD
In this section, we will ï¬rst describe how to initialize creden-
tials for each user and then present RSA-based Transaction
Veriï¬cation Method (RSA-TVM). There are two major goals
on contact tracing system: 1) data integrity: the collected
contact cases should be as complete, untampered and cor-
rect as possible; and 2) privacy: the whole system should
never initiatively disclose any location or identity informa-
tion of users.

In this paper, We propose RSA-based Transaction Ver-
iï¬cation Method (RSA-TVM) to make sure the contact
records in the transaction are valid meanwhile ensuring
the anonymity. We employee RSA algorithm as encryption
module [34]. RSA algorithm is an asymmetric encryption
algorithm, and is able to generate a key pair, (public key,

ğ‘¢3ğ‘¢2ğ‘¢1ğ‘¢4ğ‘¢5Contact:ğ‘¢2,ğ‘¢3WitnessedBy:ğ‘¢4,ğ‘¢5ğ‘¢3ğ‘¢2ğ‘¢1â‘ Generatetransacï¿½onğ‘‡:{ğ‘¢1, ContactList,WitnessList,Timestamp}â‘¡Broadcastğ‘‡ğ‘¢4ğ‘¢5ğ‘‡:{ğ‘¢1, Contact List(Signed),Witness List(Signed),Timestamp}Contact:ğ‘¢1,ğ‘¢3Contact:ğ‘¢1,ğ‘¢2Shared Transacï¿½on Poolğ‘‡1ğ‘‡2ğ‘‡ğ‘›â€¦Candidate Minersğ‘¢6ğ‘¢7ğ‘¢6ğ‘¢7ğ‘¢7Witness: (ğ‘¢1,ğ‘¢2,ğ‘¢3)BlockHashPrevious HashBlockBodyTransacï¿½ons (ğ‘‡1,ğ‘‡2, â€¦ ,ğ‘‡ğ‘›)â‘¤PackageTransacï¿½ons intoBlock with given frequencyâ€¦â‘¥Appendedto BlockchainBlockchainâ‘¢Decode andsignğ‘¢2,ğ‘¢3ğ‘¢4,ğ‘¢5Witness:(ğ‘¢1,ğ‘¢2,ğ‘¢3)â‘£Verify Signature and put into poolğ‘¢6JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

private key) for a user. Public key is known by public, while
the private key is only known by the owner. The secret
message encrypted by public key can only be decoded by
private key owner. A message can be signed by private key
indicating ownerâ€™s consent to the message, and the signed
message can be veriï¬ed by corresponding public key to
ensure the signature is correctly signed by the private key
owner.

Next we will ï¬rst describe how to initialize credentials

for each user and then present RSA-TVM.

4.1 Generate User Credential

When a person u installs the tracing client on a smart device
and become an user of the tracing system, the client will
ï¬rst name the device with an unique device ID, denoted
as uDID , and then generate a RSA key pair (public key,
private key), denoted as (uP ub key, uP ri key). The length
of each key is set to 1024 bits. The private key will be
stored locally in the smart device. The public key and the
device information will be included in a transaction through
the client, then be stored into blockchain. This transaction
is called â€œRegistration Transactionâ€, which is deï¬ned as
Treg = {Tid, {uDID , uP ub key, t}}. Tid is the unique id for
each transaction and is generated by SHA256 algorithm [35]
based on timestamp t as well as the transaction content
{uDID , uP ub key, t}, so that any change made on the content
will cause a different Tid.

After

the registration transaction is stored in the
blockchain, since every user in the system have a synchro-
nized copy of the whole blockchain, every user will hold the
public keys for every others. Users are able to modify their
device ID or credentials by submitting a new registration
transaction, so that every other users can get a new copy of
the updated device ID or public key.

Users will scan the nearby devices (through Bluetooth) at
a given frequency to get the nearby devicesâ€™ IDs and record
them locally. We avoid any device connection through Blue-
tooth channels to improve security. The client only collects
the devicesâ€™ IDs, and look up the registration transactions to
get the public keys for generating secret message later used
in ContactList or W itnessList. Next if the user wants to
report contact cases and store the contact information into
Blockchain, â€œContact Transactionâ€ will be initialized.

4.2 RSA-based Transaction Veriï¬cation Method (RSA-
TVM)

If there are nearby devices within 2 meters detected by user
uâ€™s device, u can generate â€œContact Transactionâ€, denoted
as Tcon = {Tid, {uDID , C, W, t}}, where Tid is the unique id
for each transaction and is generated based on timestamp
t and the transaction content {uDID , C, W, t}. The uDID is
the device ID of u, and t is the timestamp for this contact
case. C and W are Contact List and Witness List, which
contain the information of the contacted people(devices)
and the witness of this contact case, respectively. To generate
C and W , user u ï¬rst needs to decide a original secret
message D, and then encrypt it with the public key of the
contacted people (e.g., ui) and the witnesses (e.g., uj) of
this contact case. For each contacted person ui, uiP ub key

5

encrypted text, denoted as DuiP ub key is generated. Sim-
ilarly, for each witness uj, Duj P ub key is generated. For-
mally, the Contact List C is deï¬ned as a set of tuples:
C = {(uiP ub key, DuiP ub key )|âˆ€ui}. Similarly, the Witness
List is deï¬ned as: W = {(uj P ub key, Duj P ub key

)|âˆ€uj}.

Ideally, The secret message should be unique for every
ui and uj for every transaction to ensure security which
requires secret message as long as possible. However, the
encryption time increase rapidly with the length of text.
In practice, we set each secret message contains 10 Hex
characters (0 âˆ’ 9, a âˆ’ f ), which is able to represent about
1.1 Ã— 1012 different messages.

Witness list W can be very helpful to avoid contact
case loss and improve robustness against dishonest user
behaviors or system failure. We will show this later in
Section 7.

The transaction Tcon will then be broadcast to all users
in order to protect privacy. Each user will check if C or W
in the received Tcon contains his/her public key. If so, the
related tuples require his/her veriï¬cation. Since the mes-
sages are all encrypted, therefore only the user who holds
the public key can decrypt the encrypted secret message by
his/her public key.

When ui identiï¬es the tuple (uiP ub key, DuiP ub key ) in C,
ui will decrypt the encrypted text DuiP ub key with the pri-
vate key uiP ri key to get the secret message D. Then ui will
check local contact history. If ui has the record that ui con-
tacted with u at timestamp tÂ±3 min, then ui can conï¬rm the
tuple (uiP ub key, DuiP ub key ) valid in Tcon. Then ui needs to
send a message back to u to indicate that the contact record
about ui in Tcon is conï¬rmed. Speciï¬cally, ui signs the secret
message D with his private key. The signed text is denoted
as SDuiP ri key . Then ui replaces (uiP ub key, DuiP ub key ) with
(uiP ub key, SDuiP ri key ) in Tcon, and broadcast to all users.
uj will conduct similar veriï¬cation on the related tuple
in witness list W . If uj has the record that the transaction
generator u contacted with all users in C at t, then uj will
consider all tuples in C valid by signing secret message in
related tuple in W .

If ui can not ï¬nd any local record showing ui contacted
with u at timestamp t Â± 3 min, then ui believes this is a
wrong record. ui will sign a predeï¬ned warning message
Z=â€Wrong Recordâ€ instead of signing the secret message
D. The tuple (uiP ub key, DuiP ub key ) in Tcon will then be
(uiP ub key, ZuiP ri key ). Once the transaction generator u re-
ceives the updated Tcon from user ui, u will verify the
signature with the public key of ui.

A tuple in contact list C in Tcon is considered valid if: 1)
there is no signed warning message in the tuple, and 2) the
secret message in tuple is correctly signed by the contacted
person or at least one tuple in witness list is correctly signed
by the witness. Due to network or system failure of usersâ€™
smart devices, users may have no response to the related
tuple in C or W within given delay d. In this case, the
tuple will still be considered valid as long as one witness
has veriï¬ed the this contact case is correct.

If not all tuples in the contact list C are veriï¬ed valid
within a speciï¬c delay d, then only the valid tuples in C
will be preserved in Tcon. The transaction Tcon will be put
into the shared transaction pool waiting to be mined, e.g.
permanently stored in blockchain. Any user ui or uj who

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

6

Fig. 2. An Example of RSA-TVM

signed D or Z will get reward for helping verify the contact
case. We will discuss reward policies in Section 6. Figure 2
shows the process of RSA-TVM that u2 veriï¬es u1â€™s contact
case.

REPUTATION-CORRECTED DPOS MECHANISM

5
(RC-DPOS)

Most existing work considers it is straightforward to let the
transaction generator directly package the veriï¬ed transac-
tions into blocks and then broadcast to all users instead of
choosing a miner to do the job. However, the above strategy
will cause unfair incentive reward problem due to the nature
of diverse contact scenarios.

unfair incentive reward problem: Users are rewarded for
reporting contact cases by generating contact transactions.
However, people have different chance to have contact cases
due to the diversity of jobs or living styles. People who live
or work in human-dense areas, such as cashiers in markets
and staffs at transport stations, will obviously have much
more contact cases than those who stay or work at home,
thus gain much more reward. This will even encourage
people to go out and make contacts in order to earn re-

ward, which is against the social distancing policy during
pandemics.

In addition, since miners can be the one not in the
Contactlist or W itnessList, it helps avoid group cheat-
ing that small groups deliberately generate fake contact
cases, verify contact transactions for each other, package
transactions and append new blocks in order to gain great
amount of reward rapidly. Therefore, it is imperative to
carefully design consensus mechanism and incentive mech-
anism to balance the reward. The consensus mechanism is
required computational lightweight and have high transac-
tion throughput to satisfy the huge data storage demand
on smart devices which are usually have low computational
power.

The Delegated Proof of Stake (DPoS) consensus mech-
anism [36] is a popular light-weight consensus mechanism.
DPoS provides high-speed consensus making so that emerg-
ing transactions can be stored into blocks timely. In DPoS
consensus mechanism, each user holds some stakes, which
are usually crypto-currency. Whenever there is no candidate
miners, every user will vote someone they trust. The weight
of the vote is proportional to the stake of the voter. That
is, more stake gives the voter more vote power. After the

ğ‘¢1â€™s Mobile Deviceğ‘¢2â€™s Mobile DeviceNetwork Transmission= â€œ0023fadecdâ€= â€œWrong Record!â€ğ·:SHA384HashthenSignSHA384 HashWait ğ‘‘minutes, then append veriï¬ed ğ‘‡ğ¶ğ‘œğ‘›into transacï¿½on poolGenerate Contact Transacï¿½onBroadcastReceiveRecognize Related Tuple Decode with ğ‘¢2ğ‘ƒğ‘Ÿğ‘–_ğ‘˜ğ‘’ğ‘¦IfcontactrecordiscorrectIf contact record is wrongUpdateğ‘‡ğ¶ğ‘œğ‘›BroadcastReceiveğ‘¢2ğ‘ƒğ‘Ÿğ‘–_ğ‘˜ğ‘’ğ‘¦ğ‘¢2ğ‘ƒğ‘¢ğ‘_ğ‘˜ğ‘’ğ‘¦Checkifveriï¬edYield correct record if can get the same result(ğ‘¢2ğ‘ƒğ‘¢ğ‘ğ‘˜ğ‘’ğ‘¦,ğ·ğ‘¢2ğ‘ƒğ‘¢ğ‘_ğ‘˜ğ‘’ğ‘¦            )= â€œ0023fadecdâ€(ğ‘¢2ğ‘ƒğ‘¢ğ‘_ğ‘˜ğ‘’ğ‘¦,ğ‘†ğ·ğ‘¢2ğ‘ƒğ‘Ÿğ‘–_ğ‘˜ğ‘’ğ‘¦)JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

voting, the users with top k total weighted votes will be
selected as k candidate miners. Whenever there is block
waiting to be appended into blockchain, one candidate
miner will be randomly chosen to do the job, and the chosen
miner will be removed from the candidate miner set once
the job is done. Once candidate miner set is empty, new
round of voting will start.

DPoS can produce high throughput without compromis-
ing decentrality of blockchain system if everyone is honest
and the voting is random. However, it can not be directly
applied in our proposed BDCT. In order to motivate people
to share their contact information, reward must be given to
those who generates contact transactions honestly. In DPoS
the reward is stake, people living or working in human-
dense areas will gather stakes quickly. Thus their votes will
gradually become highly weighted due to high stakes, hence
their votes will easily determine the selection of candidate
miners. In other words, the whole blockchain system will
be dominated by those people who generate contact cases
often.

In order to solve the issue described above, we propose
Reputation-Corrected DPoS (RC-DPoS) consensus mecha-
nism. In RC-DPoS, we assign reputation to each user, which
is represented by credit c. Users will gain reputation reward
instead of stake reward for honestly reporting their contact
cases, while only gain stake reward for working as a miner.
Speciï¬cally, the RC-DPoS mechanism works as follows:

Step 1: When new users ï¬rst join the contact tracing
framework, they will be initialized with a ï¬xed start-up
stake s0 and credit c0.

Step 2: Initially, the candidate miner set is empty, the
candidate selection process will start. Each user votes for
another one trusted user and users can not vote for them-
selves. Similar to DPoS, the vote is weighted according to
the voterâ€™s stake. But the total votes received by a user will
be corrected by receiverâ€™s credit. Formally, let N denotes the
total number of users in the system. For user ui, i âˆˆ Z N , the
total vote score accumulated by ui is calculated according to
Equation 1:

Gi =

RF (ui) + 1
2

(cid:88)

uk

sk
jâˆˆZN sj

(cid:80)

(1)

where the sum taken over user uk who votes ui is the total
weighted vote received by ui, sk is the current stake amount
of uk. ci is the current credit amount of ui. RF (ui) is the
reputation correction factor of user ui, which is deï¬ned as:

RF (ui) =

ci âˆ’ minjâˆˆZN (cj)
maxjâˆˆZN (cj) âˆ’ minjâˆˆZN (cj)

.

(2)

RF (ui)+1
2

RF (ui) âˆˆ [0, 1], and
âˆˆ [0.5, 1]. The intuition
behind this equation is that users with good reputation
should have higher chance to be a candidate miner in order
to improve the system security, meanwhile we also avoid
applying too much punishment on other users with lower
reputation (maximum 50% off on received votes).

Step 3: Rank all users in descending order according
to their vote scores. The top (cid:100)N/5(cid:101) users are selected into
candidate miners set. The size of candidate miners set can
be adjusted based on speciï¬c applications.

7

Step 4: At a given mining frequency (3 minutes, 5
minutes or so on), one arbitrary miner selected from the
candidate miner set will package all the transactions in the
shared transaction pool into a block and append it into the
minerâ€™s local blockchain. Then shared transaction pool is
empty and waits for new veriï¬ed transactions. The structure
of the blockchain storage is illustrated in Figure 3.

Step 5: The miner then broadcasts this blockchain update
to all users. Users in the system will update their local
blockchain and the local transaction pool. The miner will be
given stake reward and reputation reward. Reward detail
will be elaborated in Section 6. Then the miner will be
removed from the candidate miner set.

Step 6: When a miner fails to do this job within a excus-
able delay (e.g. 10 minutes) due to network disconnection
or system failure, a penalty will be applied on the miner
by taking away some credits and no stake reward will be
given. The miner will be removed from the candidate miner
list and another miner will be delegated to do the job.

Step 7: If the candidate miner set is empty, back to Step

2.

6 INCENTIVE MECHANISM
The proposed BDCT contact tracing framework is highly
automatic without a central server. BDCT fully relies on peo-
ple to generate transactions, store contact cases into blocks
and maintain decentrality, therefore it is crucial to design an
incentive mechanism to motivate people to generate contact
transactions and append blocks into blockchain honestly. It
is also important to ensure the incentive mechanism does
not specially beneï¬t a particular group of people to avoid
the system becoming centralized and dominated. If the
rewards are taking over by a small speciï¬c group of people,
others will be discouraged, and the whole system will be
barely helpful for contact tracing. In this paper, we design
the incentive mechanism as a composition of following 4
incentive policies.

1) Users will be rewarded with 1 unit3 credit for
generating transactions. The users can not get the
reward until the transaction is accepted by the
shared transaction pool. This will motivate users to
honestly report their contact list. With more credits,
according to Equation 1, users will be more likely
to be selected as candidate miner and thus can get
more credit reward as well as stake reward.

2) Users will be rewarded with 1 unit credit after
successfully verifying related tuple in contact trans-
actions. This will motivate users to participate in
generating transactions and improve the speed of
verifying contact cases.

3) Users will be rewarded with Ri unit stake reward
and 1 unit credit reward for mining a block, e.g.
append a new block into existing blockchain. Ri is
corresponding to the total amount of transactions
that ui generated, which is formally deï¬ned as:

Ri = w âˆ—

T F (ui) + 1
2

,

(3)

3. numbers in the incentive mechanism only for indicating the rela-

tive amount, they can be of any unit.

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

8

Fig. 3. Blockchain Storage Structure in Proposed Framework

T F (ui) = 1 âˆ’

ti âˆ’ minjâˆˆZN (tj)
maxjâˆˆZN (tj) âˆ’ minjâˆˆZN (tj)

.

(4)

w is a predeï¬ned reward amount (e.g. 5 units) and
ti is the total number of transaction generated by ui.
T F (ui) âˆˆ [0, 1] is called the transaction correction
factor. From the above deï¬nition, we could ï¬nd that
the more transaction ui has generated, the lower
stake reward will be given to ui. The intuition be-
hind Ri is that we do not want people who generate
much transactions gain much stake reward for com-
pleting mining job since they naturally have more
chance to become a miner according to incentive
policy 1). On the other hand, people who generate
less transactions will get more stake reward per
âˆˆ [0.5, 1] will
mining job they complete.
make a maximum 50% off on the stake reward.
Therefore Ri can help balance the stake reward
among users in different contact scenarios, hence
help maintain the vote power distributed.

T F (ui)+1
2

4) A user will be punished if the user fails to complete
a mining job. 5 units credits will be deducted on the
miner for this punishment.

The stake reward is usually pecuniary crypto-currency,
which can be distributed by government or healthcare
authorities. Since this system does not require frequent
maintenance and huge computation center, the budget can
be saved for pecuniary stake reward. Then with accurate
and efï¬cient contact tracing, BDCT will save more money
for government by helping control the virus spread.

7 SIMULATION
7.1 Simulation Method

Though there are some well-known real-word trajectory
datasets indicating real people movements in speciï¬c areas
[37], [38], [39], [40], [41], [42], they are mostly based on
the record obtained from mobile vehicles or cell phone
calls, the trajectories are not continuous or the number of

trajectories are not sufï¬cient to support the simulation in
terms of frequency and amount. Since it is hard to collect
real-word trajectory in a wide range due to privacy concerns
and diversity of contact scenarios, we conduct experiments
on synthetic datasets that simulates different people contact
scenarios to demonstrate the effectiveness of the proposed
BDCT contact tracing framework.

We propose to consider three general contact scenarios
decided based on population density: Low density (Sparse),
Medium density (Medium), High density (Crowded). Each
scenario can intuitively represent for one kind of real-world
people contacting cases. â€œSparseâ€ can represent for the
people contacting cases in rural area or residential area.
â€œMediumâ€ can represent for the cases in schools, parks
or other common public areas. â€œCrowdedâ€ represents for
contacting cases happening in some very crowded places,
such as shopping malls and sports events.

People in 3 scenarios have different frequencies of hav-
ing contact cases, different numbers of contacted people and
witnesses. Therefore the frequency of generating transac-
tions, and the length of contact list and witness list need to
be adjusted for simulating 3 scenarios. To achieve this goal,
we specify the settings for the three scenarios as follows:

Low density (Sparse) case: In each transaction, the length
of contact list and witness list follow normal distribution
N (Âµ = 0, Ïƒ = 2) and N (Âµ = 0, Ïƒ = 1), respectively. The
frequency of generating transaction is 1 cases/hr.

Medium density (Medium) case: In each transaction, the
length of contact list and witness list follow the normal
distribution N (Âµ = 2, Ïƒ = 4) and N (Âµ = 2, Ïƒ = 2),
respectively. The frequency of generating transaction is
3 cases/hr.

High density (Crowded) case: In each transaction, the
length of contact list and witness list follow the normal
distribution N (Âµ = 5, Ïƒ = 2) and N (Âµ = 7, Ïƒ = 2),
respectively. The frequency of generating transaction is
12 cases/hr.

We implement the framework with Python 3.7, and all
simulations are conducted on a machine with Intel Core
i7-8750h 8 cores and 32GB memories. Each user is imple-
mented as a thread of python, and all threads are run

BlockID(Hash)Previous Block Hashâ€¦BlockID(Hash)Previous Block HashBlock Generator (ğ‘¢ğ·ğ¼ğ·)BlockchainTime(Timestamp)BlockBodyBlockID(Hash)Previous Block HashBlockGenerator(ğ‘¢ğ·ğ¼ğ·)Blockchain Time (Timestamp)Block Bodyğ‘‡ğ¶ğ‘œğ‘›={ğ‘‡ğ‘–ğ‘‘,{ğ‘¢2ğ·ğ¼ğ·,ğ¶ğ‘‡ğ¶ğ‘œğ‘›={ğ‘‡ğ‘–ğ‘‘,{ğ‘¢4ğ·ğ¼ğ·,ğ¶={(ğ‘¢1ğ‘ƒğ‘¢ğ‘ğ‘˜ğ‘’ğ‘¦,ğ‘¢1ğ‘ƒğ‘¢ğ‘ğ‘˜ğ‘’ğ‘¦_ğ¸ğ‘›ğ‘ğ‘Ÿğ‘¦ğ‘ğ‘¡ğ‘’ğ‘‘ğ‘‡ğ‘’ğ‘¥ğ‘¡)},ğ‘Šâ€¦ JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

simultaneously to simulate real time contact. We randomly
generate the contact cases for each user without considering
reasonable trajectories for them, since the trajectories does
not affect the evaluation of the effectiveness and efï¬ciency
of the whole framework. For the length of contact list
or witness list, we only adopt the non-negative number
sampled from corresponding normal distributions.

7.2 Decentrality Evaluation

It is crucial to maintain the decentrality of BDCT, so that the
voting power is distributed and every user can be equally
motivated to keep contributing contact cases honestly.

We simulate 200 users for each contact scenario, and
hence totally 600 users are in the whole simulation envi-
ronment. To measure the dencentrality of the system, we
draw Lorenz curve, and calculate the Gini coefï¬cient/index
of three factors of the 600 users: user balance (cumulative
stake reward), user credits (cumulative reputation reward)
and the total number of mined blocks.

Lorenz curve is originally proposed for drawing the
cumulative income from different units when they are in the
ascending order [43]. The closer the income distribution is
to uniform distribution, the closer the corresponding Lorenz
curve is to line y = x. We extend Lorenz curve in this article
to illustrate the decentrality of the proposed RC-DPoS.

The Gini coefï¬cient or Gini index Gini is a metric for
quantitatively measure inequality of a distribution, which
can derived from Lorenz curve [44]. It is deï¬ned as a ratio
with values between 0 and 1. Speciï¬cally, the numerator
is the area between the Lorenz curve of the distribution
and the uniform distribution line; the denominator is the
area under the uniform distribution line. Hence, Gini = 0
indicates perfect equality of a distribution, and Gini = 1
indicates the distribution is total skew to one unit.

We adopt the DPoS mechanism as the baseline. In the
baseline, no credit reward is given to users, and users
will get 1 unit stake reward for generating or verifying
transactions and 5 units stake reward for mining a block.
Other settings are kept the same as proposed BDCT. The
initial stake and credit of users are set to 100 units. Random
voting strategy is adopted for voting the candidate miners.
We run the simulation for 10 times, and evaluate statis-
tical signiï¬cance of Gini coefï¬cient of user balance between
baseline and proposed BDCT. We conduct a two-sided T-test
for the null hypothesis that two frameworksâ€™ stake reward
distribution have identical average (expected) values. The
p = 1.22 Ã— 10âˆ’32 indicates BDCT achieves deï¬nitely better
stake reward dencentrality.

Figure 4 shows the results of Gini coefï¬cient and Lorenz
curve of the three factors. Figure 4(a) and (b) show how
the Gini coefï¬cient change with more and more data stored
in the blockchain. Figure 4(c) shows the Gini coefï¬cient of
balance of baseline DPoS remains as high as 0.56 when
blockchain height is 10k, indicating the stake rewards are
mostly given to people in Dense scenario. Since the baseline
DPoS mechanism does not consider any credit reward,
therefore the Gini coefï¬cient of credit is 0 in Figure 4(a)(c).
In addition The Gini coefï¬cient of mined blocks count of
baseline is close to 0, this is because under the random
vote strategy in DPoS, users has the same expectation to
be selected as a miner.

9

Figure 4(b) and (d) shows the results of our proposed
BDCT framework. In Figure 4(b), our BDCT framework
makes the gini coefï¬cient decrease with the height of
blockchain, which means BDCT is achieving balanced stake
reward when we continue recording more data. In Fig-
ure 4(d), as expected, the Gini coefï¬cient of credit is 0.57
when blockchain height is 10k, showing users in dense area
can indeed earn more credit than other users. The Gini
coefï¬cient of mined blocks count is 0.27 which is higher than
0.12 in baseline, indicating people in dense areas indeed
have higher chance to be a miner. Gini coefï¬cient of credit
is 0.19 which is signiï¬cantly lower than 0.56 in baseline and
demonstrates our RC-DPoS and proposed incentive mech-
anism can successfully balance the stake reward among
different groups of users.

We further investigate the stake reward distribution.
In DPoS baseline, the 200 users (1/3 of total users) in
the Crowded scenario together hold more than 85% stake
rewards giving them more than 85% vote power. On ther
other hand, the three groups of users in three different
contact scenarios in our proposed BDCT hold stake reward
23%, 42%, and 34% respectively.

7.3 Robustness Evaluation

Mobile devices are usually with low computational power
and low security level, and sometimes may suffer from
system failure or network delay and disconnection. All
those factors can cause failure of detecting contact case,
verifying contact list or receiving transactions. In this pa-
per, We proposed witness for every contact case in BDCT
framework, which can improve the robustness of recording
correct contact cases. As mentioned in Section 4.2, if a tuple
in contact case is not veriï¬ed due to the failure mentioned
above, as long as there is one witness in W veriï¬ed the
contact list C, the tuple will be considered valid.

To evaluate the robustness of recording contact infor-
mation of the proposed system, we set a failure rate p
of each user, representing that the user has a probability
p of failing to verify the corresponding transaction. Then
we compute how many contact cases, that ui contacts
with uj at timestamp t, e.g. (ui, uj, t), will lose compar-
ing with the given 300k contact cases. We use a baseline
BDCT âˆ’ w/o âˆ’ W itness that is BDCT without witness
role, therefore (ui, uj, t) will be lost when both ui and uj
fail to verify the corresponding tuples in C. This is also a
common design in exiting works [19], [45]. We simulate this
experiment for 10 times, and report the average results.

Table 1 shows the simulation results. It can be seen
that our framework lost signiï¬cantly less contact cases than
baseline at any failure rate p. BDCT can correctly record
nearly 96.31% (1-3.69%) total contact cases even every node
has 0.6 failure probability, which is 35% more than the
baseline that can only preserve about 61.26% (1-38.74%)
contact cases.

7.4 Attack Resistance

Malicious users may report false or fake contact cases to
generate more transactions, which may bring them more
credit reward or stake reward. The only way to achieve
this attack is through group cheating that several malicious

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

10

(a) Gini coefï¬cient, Baseline DPoS

(b) Gini coefï¬cient, Our BDCT

(c) Lorenz Curve, Baseline DPoS

(d) Lorenz Curve, Our BDCT

Fig. 4. Lorenz Curve and Gini Coefï¬cient of proposed BDCT framework and baseline DPoS

TABLE 1
Average Contact Case Loss Percentage at Different Failure Rate p

User failure rate
BDCT
BDCT-w/o-Witness

p=0.1

p=0.6
0.18Â±0.02% 0.45Â± 0.03%
3.69Â±0.03%
2.25Â±0.03% 6.12Â± 0.03% 11.12Â± 0.04% 18.70Â±0.09% 27.63Â±0.07% 38.74Â±0.14%

p=0.5
1.96Â±0.12%

p=0.3
0.68Â±0.01%

p=0.4
1.19Â±0.02%

p=0.2

users together create and verify transactions. More specif-
ically, malicious users have two attack approaches to get
a fake transaction veriï¬ed. They can create a contact list
where all the contacts are malicious users, or put malicious
witness in the witness list so that the whole transaction will
be veriï¬ed as long as this malicious witness veriï¬es related
tuple in witness list no matter whether the contact case is
real or fake in the contact list. Next we describe how each of
the attack approach impacts the whole system.

too much.

If a malicious user attacks through the second method,
that a malicious witness is put in the witness list for every
false transaction, it may include false contact cases in the
contact list. However, according to the proposed RSA-TVM
method, the tuple recording the false contact case can be
veriï¬ed wrong and hence not be preserved before the trans-
action is put into the transaction pool. Therefore, the impact
of this attack can also be controlled.

If a malicious user chooses the ï¬rst method, that creates
contact list composed by other malicious users, this will
not bring any false information to other honest users. The
malicious users may earn more credits by generating or
verifying numerous fake transactions, but the number of
transactions is limited by the Bluetooth scanning frequency
speciï¬ed by the system, e.g. 5 minutes. In other words, a
user can generate at most twelve transactions per hour. In
addition, the proposed RC-DPoS and incentive mechanism
can well balance the stake reward as shown in Figure 4.
Therefore malicious users will not dominate stake reward

7.5 Storage Cost Evaluation

In BDCT framework, every user is holding the whole copy
of blockchain where the contact transactions are stored. We
evaluate the expected blockchain storage cost of the pro-
posed BDCT framework by calculating the expected number
of transactions and blocks generated per hour with respect
to our experiment setting.

We denote the expected size of total blockchain segment
generated per hour as E(ST B/h), expected size of all block
heads per hour as E(SBH/h), and expected size of all block

200040006000800010000Height of Blockchain0.00.10.20.30.40.50.60.70.80.9Gini IndexBaseline, Total user 600, Gini Index with Height of blockCreditBalanceMining Count0200040006000800010000Height of Blockchain0.00.10.20.30.40.50.60.70.80.9Gini IndexTotal user 600, Gini Index with Height of blockCreditBalanceMining Count020406080100Cumulative % of users020406080100Cumulative % of  corresponding valueBaseline, Total user 600, Mined 10000 Blocksuser credit, gini = 0.0user balance, gini = 0.56mined blocks count, gini = 0.12equality, gini = 0020406080100Cumulative % of users020406080100Cumulative % of  corresponding valueTotal user 600, Mined 10000 Blocksuser credit, gini = 0.57user balance, gini = 0.19mined blocks count, gini = 0.27equality, gini = 0JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

bodies per hour as E(SBB/h). The size of single block head
is denoted as sBH , the expected amount of blocks generated
per hour is NB/h. Hence, E(SBH/h) = E(NB/h) âˆ— sBH . The
block bodies contains transactions, therefore E(SBB/h) =
E(ST /h), where E(ST /h) is the expected size of total trans-
actions generated per hour. Consequently, E(ST B/h) is cal-
culated by Equation 5.

E(ST B/h) = E(SBH/h) + E(SBB/h)

= E(NB/h) âˆ— sBH + E(ST /h)

(5)

The speed of generating a block is predeï¬ned in the
system, e.g. every 5 minutes. Therefore E(NB/h) = 12.
Based on the block structure illustrated in Figure 3, sBH
can be calculated as Equation 6.

sBH = sBlockHash + sP reviousBlockHash
+ sT imestamp

+ suDID
= 2 âˆ— sBlockHash + suDID
= 2 âˆ— 256 bits + 10 bytes + 32 bits
= 64 bytes + 10 bytes + 4 bytes = 78 bytes

+ sT imestamp

(6)

sBlockHash is the size of a unique block ID, which is a
SHA256 hash value, therefore sBlockHash = 256 bits. suDID
is the size of block generatorâ€™s device ID. In our framework,
the set device ID a string contains 10 Hex characters, which
can represent 210âˆ—4 â‰ˆ 1.1 Ã— 1012 unique devices. Since each
char type hex character take 1 byte, suDID
= 10 bytes.
sT imestamp is size of an Unix timestamp of 32 bit integer
type, hence sT imestamp = 32 bits.

In our experiment settings, three different contact sce-
narios are considered with different contact case generating
frequency, number of contacted people and number of wit-
nesses. Though there may also registration transactions in
block bodies, registration transactions cost minor storage.
In this discussion, we consider the general case that block
bodies contain only contact transactions. Then E(ST /h) is
the sum of expected all transactions generated by 3 contact
scenarios as in Equation 7.

E(ST /h) = E(ST S/h) + E(ST M/h) + E(ST C/h)

(7)

E(ST S/h), E(ST M/h) and E(ST C/h) are the expected
numbers of transactions generated per hour in Sparse sce-
nario, Medium scenario and Crowded scenario respectively.
We denote E(NT S/h) as the expected number of transac-
tions (contact cases) per hour in Sparse scenario and E(sT S)
as the expected size of a transaction generated in Sparse
scenario. Given the contact transaction structure described
in Section 4.2, E(sT S) is composed by size of transaction
ID sTid , size of transaction generatorâ€™s device ID suDID ,
size of transaction timestamp sT imestamp, expected size of
contact list E(sC) and expected size of witness list E(sW ).
In each contact list C or witness list W , there are signed
tuples (uiP ub key, SDuiP ri key ). The size of signed tuples is
denoted as sst. In our experiments, we generate 1024 bits
RSA Keys with the Python package Crypto4. With the secret
message as 10 Hex characters, sst = 56 bytes + 161 bytes =
217 bytes in our simulation.

Though the length of contact list and witness list are
sampled from normal distribution described in Section 7.1,

4. https://pycryptodome.readthedocs.io

we set the length to 0 if the sampled length is less than
0. The expected length of contact list E(NC) based such
sample strategy satisï¬es Equation 8.

11

E(NC) =

(cid:90) âˆ

x

0

exp(âˆ’

x exp(âˆ’

(x âˆ’ Âµ)2
2Ïƒ2
(x âˆ’ Âµ)2
2Ïƒ2

) dx

) dx

1
âˆš
Ïƒ
2Ï€
(cid:90) âˆ

0
(cid:90) âˆ

=

=

=

=

=

1
âˆš
2Ï€
Ïƒ
âˆš
2Ïƒ
âˆš
2Ï€
âˆš
(

1
âˆš
Ï€

Ïƒ

âˆš
(

1
âˆš
Ï€

1
âˆš
Ï€

(

Ïƒ
âˆš
2

âˆ’ Âµ
âˆš
2Ïƒ
(cid:90) âˆ

2Ïƒ

2Ïƒ

(cid:20)

âˆ’

âˆ’ Âµ
âˆš
2Ïƒ
1
2
expâˆ’ Âµ2

âˆš
(

2Ïƒt + Âµ) expâˆ’t2

dt(with t =

x âˆ’ Âµ
âˆš
2Ïƒ

)

t expâˆ’t2

dt + Âµ

expâˆ’t2(cid:21)âˆ

+ Âµ

âˆ’ Âµ
âˆš
2Ïƒ

(cid:90) âˆ

âˆ’ Âµ
âˆš
2Ïƒ
(cid:90) âˆ

âˆ’ Âµ
âˆš
2Ïƒ

2Ïƒ2 +ÂµZ(t))

expâˆ’t2

dt)

expâˆ’t2

dt))

(8)

expâˆ’t2

dt

expâˆ’t2

dt +

(cid:90) âˆ

expâˆ’t2

dt

Z(t) =

=

=

=

â‰¤

(cid:90) âˆ

âˆ’ Âµ
âˆš
2Ïƒ
(cid:90) 0

âˆ’ Âµ
âˆš
2Ïƒ
(cid:90) Âµ

âˆš

2Ïƒ

0
(cid:90) Âµ

âˆš

2Ïƒ

0

0
(cid:90) âˆ

1
2
âˆš

Ï€
2
âˆš
Ï€
2
Ï€
2

0
(cid:90) Âµ

âˆš

2Ïƒ

expâˆ’t2

dt +

dt +
âˆš

1
t2 + 1
Âµ
âˆš
2Ïƒ

= arctan(

) +

expâˆ’t2

dt +

expâˆ’t2

dt

âˆ’âˆ

(9)

E(ST S/h) = E(NT S/h) âˆ— E(sT S)

+ sT imestamp

= 1 âˆ— (sTid + suDID
+ E(sC) + E(sW ))
= 256 bits + 10 bytes + 32 bits + E(sC) + E(sW )
= 46 bytes + E(NC) âˆ— sst + E(NW ) âˆ— sst

âˆš
âˆš

2
Ï€

âˆš
2
âˆš
Ï€
2

+

) âˆ— 217 bytes

â‰¤ 46 bytes + (

â‰ˆ 306 bytes.

(10)
Since Z(t) is limited by an upper bond, we can calculate
upper bond of the expected number of transactions per hour
in Sparse scenario as Equation 10. Similarly, E(ST M/h) â‰¤
3374 bytes and E(ST C/h) â‰¤ 36227 bytes.

Hence E(ST /h) â‰¤ 306 + 3374 + 36227 = 39907 bytes.
Then E(ST B/h) = E(NB/h) âˆ— sBH + E(ST /h) = 12 âˆ— 78 +
39907 bytes = 40843 bytes â‰ˆ 39.89 KB. Therefore the
expected storage cost for the blockchain generated per day
is 24 âˆ— E(ST /h) = 24 âˆ— 39.89 KB = 957.36 KB < 1M B,
which is totally affordable for most smart devices.

8 CONCLUSION
In this article, we propose a Blockchain Driven Contact
Tracing framework (BDCT), which is a fully decentralized

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

framework without any third-party required. We propose
the role â€œwitnessâ€ in the framework to promote contact
tracing data integrity, and the RSA based Transaction Ver-
iï¬cation Method (RSA-TVM) to verify the correctness of
the reported contact cases. Reputation Corrected Delegated
Proof of Stake (RC-DPoS) consensus mechanism is applied
to select miners based on both usersâ€™ reputation and usersâ€™
stake. An incentive mechanism is further developed to mo-
tivate people to keep reporting contact cases honestly and
work with RC-DPoS achieving balanced stake reward dis-
tribution to maintain the whole framework decentralized.
In the simulation, we propose a simulation environment,
which mixes three contact scenarios based on different
population density. The simulation results demonstrate our
proposed framework can achieve signiï¬cantly decentrality
than the baseline framework, and RSA-TVM incorporated
with â€œwitnessâ€ role in the framework can hugely improve
the system robustness.

For future work, better consensus mechanism should be
designed to lower communication cost. In BDCT, though
the computation cost is eliminated and storage cost is con-
sidered acceptable, the communication cost is still high for
circulating contact transactions among devices to get contact
cases veriï¬ed especially when contact cases are tremendous.
Synchronizing blockchain and shared transaction pool also
imposes communication stress on smart devices. Therefore
a better communication protocol is highly demanded for
making more scalable contact tracing applications.

REFERENCES

[1] E. Dong, H. Du, and L. Gardner, â€œAn interactive web-based
dashboard to track covid-19 in real time,â€ The Lancet. Infectious
Diseases, vol. 20, pp. 533 â€“ 534, 2020.

[2] W. H. Organization et al., â€œContact tracing during an outbreak of

[3]

ebola virus disease,â€ 2014.
J. Bay, J. Kek, A. Tan, and C. S. Hau, â€œBluetrace: A privacy-
preserving protocol for community-driven contact tracing across
borders,â€ 2020.

[4] F. Liang, â€œCovid-19 and health code: How digital platforms tackle
the pandemic in china,â€ Social Media + Society, vol. 6, no. 3,
p. 2056305120947657, 2020, pMID: 34192023. [Online]. Available:
https://doi.org/10.1177/2056305120947657

[5] Apple

and Google,

covid-19 contact
Available:
apple-and-google-partner-on-covid-19-contact-tracing-technology/

on
[Online].
https://www.apple.com/newsroom/2020/04/

tracing technology,â€ Dec 2021.

partner

â€œApple

google

and

[6] H. R. Hasan, K. Salah, R. Jayaraman, I. Yaqoob, M. Omar, and
S. Ellahham, â€œCovid-19 contact tracing using blockchain,â€ IEEE
Access, 2021.

[7] H. Xu, L. Zhang, O. Onireti, Y. Fang, W. J. Buchanan, and
M. A. Imran, â€œBeeptrace: Blockchain-enabled privacy-preserving
tracing for COVID-19 pandemic and beyond,â€ IEEE
contact
Internet Things J., vol. 8, no. 5, pp. 3915â€“3929, 2021. [Online].
Available: https://doi.org/10.1109/JIOT.2020.3025953

[8] W. Lv, S. Wu, C. Jiang, Y. Cui, X. Qiu, and Y. Zhang, â€œTowards
large-scale and privacy-preserving contact tracing in COVID-19
pandemic: A blockchain perspective,â€ IEEE Trans. Netw. Sci.
Eng., vol. 9, no. 1, pp. 282â€“298, 2022.
[Online]. Available:
https://doi.org/10.1109/TNSE.2020.3030925
S. Altmann, L. Milsom, H. Zillessen, R. Blasone, F. Gerdon, R. L.
Bach, F. Kreuter, D. Nosenzo, S. Toussaert, and J. Abeler, â€œAccept-
ability of app-based contact tracing for covid-19: Cross-country
survey study,â€ JMIR mHealth and uHealth, vol. 8, 2020.

[9]

[10] T. Altuwaiyan, M. Hadian, and X. Liang, â€œEpic: Efï¬cient privacy-
preserving contact tracing for infection detection,â€ 2018 IEEE
International Conference on Communications (ICC), pp. 1â€“6, 2018.
[11] A. Prasad and D. F. Kotz, â€œEnact: Encounter-based architecture for
contact tracing,â€ Proceedings of the 4th International on Workshop on
Physical Analytics, 2017.

12

[12] S. Nisar, M. A. Zuhaib, A. Ulasyar, and M. Tariq, â€œA privacy
preserved and cost efï¬cient control scheme for coronavirus out-
break using call data record and contact tracing,â€ IEEE Consumer
Electronics Magazine, 2020.

[13] A. Trivedi, C. Zakaria, R. K. Balan, and P. J. Shenoy, â€œWiï¬trace:
Network-based contact tracing for infectious diseases using pas-
sive wiï¬ sensing,â€ Proc. ACM Interact. Mob. Wearable Ubiquitous
Technol., vol. 5, pp. 37:1â€“37:26, 2021.

[14] A. Hekmati, G. S. Ramachandran, and B. Krishnamachari, â€œCon-
tain: Privacy-oriented contact tracing protocols for epidemics,â€
2021 IFIP/IEEE International Symposium on Integrated Network Man-
agement (IM), pp. 872â€“877, 2021.

[15] P. C. Ng, P. Spachos, and K. N. Plataniotis, â€œCovid-19 and your
smartphone: Ble-based smart contact tracing,â€ IEEE Systems Jour-
nal, vol. 15, pp. 5367â€“5378, 2021.

[16] L. Reichert, S. Brack, and B. Scheuermann, â€œPrivacy-preserving
contact tracing of covid-19 patients.â€ IACR Cryptol. ePrint Arch.,
vol. 2020, p. 375, 2020.

[17] J. Chan, D. Foster, S. Gollakota, E. Horvitz, J. Jaeger, S. Kakade,
T. Kohno, J. Langford, J. Larson, P. Sharma et al., â€œPact: Privacy
sensitive protocols and mechanisms for mobile contact tracing,â€
arXiv preprint arXiv:2004.03544, 2020.

[18] M. A. Azad, J. Arshad, S. M. A. Akmal, F. Riaz, S. Abdullah,
M. Imran, and F. Ahmad, â€œA ï¬rst look at privacy analysis
of COVID-19 contact-tracing mobile applications,â€ IEEE Internet
Things J., vol. 8, no. 21, pp. 15 796â€“15 806, 2021. [Online]. Available:
https://doi.org/10.1109/JIOT.2020.3024180

[19] N. Ahmed, R. A. Michelin, W. Xue, S. Ruj, R. A. Malaney,
S. S. Kanhere, A. Seneviratne, W. Hu, H. Janicke, and S. K.
tracing apps,â€ IEEE
Jha, â€œA survey of COVID-19 contact
Access, vol. 8, pp. 134 577â€“134 601, 2020.
[Online]. Available:
https://doi.org/10.1109/ACCESS.2020.3010226

[20] S. Nakamoto, â€œBitcoin : A peer-to-peer electronic cash system,â€

2009.

[21] J. Guo, X. Ding, and W. Wu, â€œA blockchain-enabled ecosystem
for distributed electricity trading in smart city,â€ IEEE Internet
Things J., vol. 8, no. 3, pp. 2040â€“2050, 2021. [Online]. Available:
https://doi.org/10.1109/JIOT.2020.3015980

[22] Y. Fan, L. Wang, W. Wu, and D. Du, â€œCloud/edge computing
resource allocation and pricing for mobile blockchain: An
iterative greedy and search approach,â€ IEEE Trans. Comput.
Soc. Syst., vol. 8, no. 2, pp. 451â€“463, 2021. [Online]. Available:
https://doi.org/10.1109/TCSS.2021.3049152

[23] X. Ding, J. Guo, D. Li, and W. Wu, â€œAn incentive mechanism
for building a secure blockchain-based internet of things,â€ IEEE
Trans. Netw. Sci. Eng., vol. 8, no. 1, pp. 477â€“487, 2021. [Online].
Available: https://doi.org/10.1109/TNSE.2020.3040446

[24] L. Dong, W. Wu, Q. Guo, M. N. Satpute, T. Znati,
and D. Du, â€œReliability-aware ofï¬‚oading and allocation in
IEEE Trans. Reliab.,
multilevel
vol. 70, no. 1, pp. 200â€“211, 2021. [Online]. Available: https:
//doi.org/10.1109/TR.2019.2909279

computing system,â€

edge

[25] C. Luo, L. Xu, D. Li, and W. Wu, â€œEdge computing
integrated with blockchain technologies,â€ in Complexity and
Approximation -
In Memory of Ker-I Ko, ser. Lecture Notes
in Computer Science, D. Du and J. Wang, Eds., vol.
12000.
[Online]. Available:
https://doi.org/10.1007/978-3-030-41672-0 17

2020, pp.

Springer,

268â€“288.

[26] S. M. Idrees, M. Nowostawski, and R. Jameel, â€œBlockchain-based
digital contact tracing apps for covid-19 pandemic management:
Issues, challenges, solutions, and future directions,â€ JMIR medical
informatics, vol. 9, no. 2, p. e25245, 2021.

[27] M. M. Arifeen, A. Al Mamun, M. S. Kaiser, and M. Mahmud,
â€œBlockchain-enable contact tracing for preserving user privacy
during covid-19 outbreak,â€ 2020.

[28] C. Zhang, C. Xu, K. Sharif, and L. Zhu, â€œPrivacy-preserving
contact tracing in 5g-integrated and blockchain-based medical
applications,â€ Comput. Stand. Interfaces, vol. 77, p. 103520, 2021.
[Online]. Available: https://doi.org/10.1016/j.csi.2021.103520

J. Huang,

[29] Z. Peng, C. Xu, H. Wang,

J. Xu, and X. Chu,
â€œP2b-trace: Privacy-preserving blockchain-based contact tracing
to combat pandemics,â€ in SIGMOD â€™21: International Conference on
Management of Data, Virtual Event, China, June 20-25, 2021, G. Li,
Z. Li, S. Idreos, and D. Srivastava, Eds. ACM, 2021, pp. 2389â€“2393.
[Online]. Available: https://doi.org/10.1145/3448016.3459237
[30] S. L. T. Vangipuram, S. P. Mohanty, and E. Kougianos, â€œCovichain:
A blockchain based framework for nonrepudiable contact

JOURNAL OF LATEX CLASS FILES, VOL. 14, NO. 8, AUGUST 2015

13

tracing in healthcare cyber-physical systems during pandemic
outbreaks,â€ SN Comput. Sci., vol. 2, no. 5, p. 346, 2021. [Online].
Available: https://doi.org/10.1007/s42979-021-00746-x

[31] M. Zuhair, F. Patel, D. Navapara, P. Bhattacharya, and D. Saraswat,
â€œBlocov6: A blockchain-based 6g-assisted uav contact tracing
scheme for covid-19 pandemic,â€ in 2021 2nd International Confer-
ence on Intelligent Engineering and Management (ICIEM).
IEEE,
2021, pp. 271â€“276.

[32] M. Salimibeni, Z. Hajiakhondi-Meybodi, A. Mohammadi, and
Y. Wang, â€œTB-ICT: A trustworthy blockchain-enabled system for
indoor COVID-19 contact tracing,â€ CoRR, vol. abs/2108.08275,
2021. [Online]. Available: https://arxiv.org/abs/2108.08275
[33] A. Kotanen, M. Hannikainen, H. Leppakoski, and T. D.
Hamalainen, â€œExperiments on local positioning with bluetooth,â€
in Proceedings ITCC 2003. International Conference on Information
Technology: Coding and Computing.

IEEE, 2003, pp. 297â€“303.

[34] R. L. Rivest, A. Shamir, and L. Adleman, â€œA method for obtaining
digital signatures and public-key cryptosystems,â€ Communications
of the ACM, vol. 21, no. 2, pp. 120â€“126, 1978.

[35] H. Gilbert and H. Handschuh, â€œSecurity analysis of SHA-256 and
sisters,â€ in Selected Areas in Cryptography, 10th Annual International
Workshop, SAC 2003, Ottawa, Canada, August 14-15, 2003, Revised
Papers, ser. Lecture Notes in Computer Science, M. Matsui and R. J.
Zuccherato, Eds., vol. 3006. Springer, 2003, pp. 175â€“193. [Online].
Available: https://doi.org/10.1007/978-3-540-24654-1 13

[36] D. Larimer, â€œDelegated proof-of-stake (dpos),â€ Bitshare whitepaper,

vol. 81, p. 85, 2014.

[37] K. K.

Jahromi, M. Zignani, S. Gaito, and G. P. Rossi,
â€œSimulating human mobility patterns in urban areas,â€ Simul.
Model. Pract. Theory, vol. 62, pp. 137â€“156, 2016. [Online]. Available:
https://doi.org/10.1016/j.simpat.2015.12.002

[38] X. Huang, Y. Yin, S. Lim, G. Wang, B. Hu, J. Varadarajan, S. Zheng,
A. Bulusu, and R. Zimmermann, â€œGrab-posisi: An extensive real-
life gps trajectory dataset in southeast asia,â€ in Proceedings of the 3rd
ACM SIGSPATIAL International Workshop on Prediction of Human
Mobility, 2019, pp. 1â€“10.

[39] C. DiDi, â€œData source: Didi chuxing gaia open dataset initiative,â€
[Online]. Available: https://outreach.didichuxing.com/

2019.
research/opendata/en/

[40] R. Mariescu-Istodor and P. FrÂ¨anti, â€œCellnet:

Inferring road
networks from GPS trajectories,â€ ACM Trans. Spatial Algorithms
Syst., vol. 4, no. 3, pp. 8:1â€“8:22, 2018.
[Online]. Available:
https://doi.org/10.1145/3234692

[41] J. Yuan, Y. Zheng, C. Zhang, W. Xie, X. Xie, G. Sun, and
Y. Huang, â€œT-drive: driving directions based on taxi trajectories,â€
in 18th ACM SIGSPATIAL International Symposium on Advances
in Geographic Information Systems, ACM-GIS 2010, November 3-5,
2010, San Jose, CA, USA, Proceedings, D. Agrawal, P. Zhang,
A. E. Abbadi, and M. F. Mokbel, Eds. ACM, 2010, pp. 99â€“108.
[Online]. Available: https://doi.org/10.1145/1869790.1869807
[42] J. Lian and L. Zhang, â€œOne-month beijing taxi GPS trajectory
dataset with taxi ids and vehicle status,â€ in Proceedings of the
First Workshop on Data Acquisition To Analysis, DATA@SenSys 2018,
Shenzhen, China, November 4, 2018, J. Gao, P. Zhang, S. Pan,
[Online]. Available:
and C. Ni, Eds. ACM, 2018, pp. 3â€“4.
https://doi.org/10.1145/3277868.3277870

[43] N. C. Kakwani, â€œApplications of lorenz curves in economic
analysis,â€ Econometrica, vol. 45, no. 3, pp. 719â€“727, 1977. [Online].
Available: http://www.jstor.org/stable/1911684

[44] R. Dorfman, â€œA formula for the gini coefï¬cient,â€ The review of

economics and statistics, pp. 146â€“149, 1979.

[45] L. Reichert, S. Brack, and B. Scheuermann, â€œA survey of automatic
contact tracing approaches using bluetooth low energy,â€ ACM
Trans. Comput. Heal., vol. 2, no. 2, pp. 18:1â€“18:33, 2021. [Online].
Available: https://doi.org/10.1145/3444847

Xiao Li received his B.S. and M.S degree in
Software Engineering from Dalian University of
Technology, China in 2016 and 2019, respec-
tively. He is currently pursuing the Ph.D. degree
with the Department of Computer Science, Uni-
versity of Texas at Dallas, Richardson, TX, USA.
His current research interests include data min-
ing and Blockchain.

Weili Wu (Senior Member, IEEE) received the
M.S. and Ph.D. degrees from the Department
of Computer Science, University of Minnesota,
Minneapolis, MN, USA, in 1998 and 2002, re-
spectively. She is currently a Full Professor with
the Department of Computer Science, University
of Texas at Dallas, Richardson, TX, USA. Her
research mainly deals in the general research
area of data communication and data manage-
ment. Her research focuses on the design and
analysis of algorithms for optimization problems
that occur in wireless networking environments and various database
systems.

Tiantian Chen is a Ph.D. candidate in the De-
partment of Computer Science, The University
of Texas at Dallas. She received her B.S. de-
gree in Mathematics and Applied Mathematics,
and M.S. degree in Operational Research and
Cybernetics from Ocean University of China in
2016 and 2019, respectively. Her research fo-
cuses on social networks, design and analysis
of approximation algorithms, deep learning, and
reinforcement learning.

