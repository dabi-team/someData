2
2
0
2

n
u
J

7

]

R
C
.
s
c
[

1
v
1
8
4
3
0
.
6
0
2
2
:
v
i
X
r
a

Topos: A Secure, Trustless, and Decentralized
Interoperability Protocol

v1.0

Th´eo Gauthier1, S´ebastien Dan1, Monir Hadji1,
Antonella Del Pozzo2, and Yackolley Amoussou-Guenou2

1Toposware, Inc., Cambridge, Massachusetts, USA
2Universit´e Paris-Saclay, CEA, List, Palaiseau, France

June 8, 2022

Abstract

Topos is an open interoperability protocol designed to reduce as much as possible
trust assumptions by replacing them with cryptographic constructions and decentraliza-
tion while exhibiting massive scalability. The protocol does not make use of a central
blockchain, nor uses consensus to ensure consistent delivery of messages across a hetero-
geneous ecosystem of public and private blockchains, named subnets, but instead relies
on a weak causal reliable broadcast implemented by a distributed network which we call
Transmission Control Engine (TCE). The validity of cross-subnet messages is ensured
by the Universal Certiﬁcate Interface (UCI) and stems from zkSTARK proofs asserting
the validity of subnets’ state transitions executed by the Topos zkVM. Such proofs of
computational integrity are publicly veriﬁable by any other participants in and out the
protocol such as other subnets or audit companies. The interface between the TCE and
subnets leverages the ICE-FROST protocol, an innovative threshold signature scheme,
whose static public key allows for uniquely identifying subnets after they register in the
protocol. The Topos protocol is designed to provide uniform security to the ecosystem
and to handle any type of subnets (e.g., permissioned, permissionless) in order to ﬁt any
business use cases and pave the way for global adoption and a new standard for the
Internet base layer.

Contents

1 Introduction

1.1 Our Contributions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2 Properties

3 Design

3.1 System Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Subnets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.1
3.1.2
zkVM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.3 Universal Certiﬁcate Interface . . . . . . . . . . . . . . . . . . . . . . . .

1

3
4
4

6

6
7
7
7
7

 
 
 
 
 
 
System Model

ICE-FROST Signature
STARKs

3.1.3.1 Certiﬁcate
3.1.3.2
3.1.3.3

. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . .

8
9
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.1.4 Topos Subnet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
3.1.5 Transmission Control Engine . . . . . . . . . . . . . . . . . . . . . . . . 12
. . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.1.5.1
3.1.5.2 Probabilistic Reliable Broadcast . . . . . . . . . . . . . . . . . 14
3.1.5.3 Weak Causal Probabilistic Reliable Broadcast
. . . . . . . . . 16
3.1.5.4 Certiﬁcate Submission and State Update . . . . . . . . . . . . 18
Sybil Resistance . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.1.5.5
3.2 Protocol Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.2.1 Cross-Subnet Message . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
Scalability and Decentralization . . . . . . . . . . . . . . . . . . . . . . . 22
3.2.2
3.2.3 Composability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.2.3.1 Atomic Composability . . . . . . . . . . . . . . . . . . . . . . . 23
3.2.3.2 Asynchronous Composability . . . . . . . . . . . . . . . . . . . 23
Incentive System Design . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
. . . . . . . . . . . . . . . . . . . . . . . . . . 24
3.2.4.1 TCE Incentives
. . . . . . . . . . . . . . . . . . . . . . . . . 25
3.2.4.2 Cross-Subnet Fee
3.2.5 Uniform Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.2.6 Finality and Reorganization . . . . . . . . . . . . . . . . . . . . . . . . . 26

3.2.4

4 Use Cases

27
4.1 Subnets as Layer-2 to Interoperate Layer-1 . . . . . . . . . . . . . . . . . . . . 27
4.2 Decentralized Finance (DeFi) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
4.3 Enterprise Adoption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

5 Conclusion

30

6 Discussion and Future Work

30
6.1 Subnet Recovery . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
. . . . . . . . . . . . . . . . . . . 31
6.2 Conﬁdentiality of Cross-Subnet Transactions
6.3 Recursive STARKs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
6.4 Alternative to Topos Subnet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

7 Acknowledgements

32

A STARK Proof System

37
A.1 Assumptions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
A.2 Prover . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
A.3 Veriﬁer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
A.4 Randomized Air with Preprocessing (RAPs) . . . . . . . . . . . . . . . . . . . . 39

B ICE-FROST Signature

39
B.1 Assumptions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
B.2 Key Generation phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
B.3 Signing phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

C WCPRB Proof of Correctness

42

2

1 Introduction

Blockchain technology is evolving very fast. We are witnessing the development of more
and more real-world applications which demonstrates strong interest from both industry and
academia. Furthermore, blockchain technology is on its way to challenge the performance of
centralized systems with diﬀerent blockchain projects now reaching a throughput in the thou-
sands of transactions per second, e.g., Solana [Sol], Avalanche [SLBS20], Polkadot [Woo16],
or Algorand [GHM+17].

Since its inception, blockchain technology has mainly focused on creating very sparse and
standalone networks, all decoupled one another, trying to solve diﬀerent challenges. Such
heterogeneity has forged a future of blockchain leaning towards the coexistence of multiple
layer-1 chains over the domination of a single network. The proliferation of application-speciﬁc
blockchains and smart contract platforms hosting new instances of existing dApps and DeFi
protocols will continue to accelerate the general adoption of Web3 technologies. Thus, the
need for interoperability continues to grow considerably. It now appears crucial to solve the
interoperability challenge as it will improve overall blockchain scalability and pave the way for
new business opportunities by composing applications hosted on diﬀerent blockchain systems.
During the decade that followed the release of Bitcoin [Nak08], there has been a continuous
and global eﬀort to bring blockchain technology to an industrial level. This eﬀort has primarily
targeted some of the most important blockchain issues: scalability and interoperability.

its
Scalability. Blockchain scalability is closely pegged to two of its upmost metrics:
latency (speed) and its throughput (capacity). Latency represents the time a transaction
takes to be inserted in a block and for it to be accepted by the network, while throughput
relates to the number of transactions the network is capable of adding on-chain per unit of
time. For uncertain reasons, these concepts are often made misleading and thus prevent the
community from gauging the true performance of a blockchain system. Transaction ﬁnality,
probabilistic or deterministic, has to be considered when evaluating blockchain performance.
In this context, latency is deﬁned as the time it takes for a transaction to be ﬁnalized,
while throughput is deﬁned as the number of ﬁnalized transactions per unit of time. A later
phase in blockchain technology history has seen the generalization of deterministic ﬁnality,
commonly achieved by means of classical BFT consensus algorithms [ACDP+20, Kwo14,
MXC+16, YMR+18]. Such algorithms have shown their limitations in terms of scalability for
they come with a quadratic message complexity, and as such lead to much higher settlement
latency as the number of validators increases.

Interoperability. Interoperability lies in the capacity of multiple systems to interface with
each other. Exchanging assets and data between blockchains is key to the adoption of the
technology and yet has historically been a reality only within an environment of trust, either
internally between the exchanging parties or externally via third-party bridge administrators.
In addition, specialization, a scalability enabling principle centered around the segregation of
a multi-app blockchain into application-speciﬁc chains, is a straightforward call for interoper-
ability.

For an industrial age of blockchain to emerge, we add two additional components: com-

posability and privacy.

Composability. Composability is a design principle that allows diﬀerent components within
a system to be combined to meet any speciﬁc use case requirements. Within a single blockchain
network like Ethereum [But], composability is atomic: Smart contract functions can invoke
other contracts synchronously with the insurance that either all contract calls succeed or none
does. In a context of cross-chain interoperability, composability is obtained when business
logic deployed on diﬀerent blockchains can interact with each other to create new value.

Privacy. Historically, privacy has remained a rarity in the blockchain scene, transactional

3

data being accessible to all network participants by design even though private transaction
protocols such as [Mon, BSCG+] have allowed for keeping this data hidden while preserving
transaction validity. For enterprise use, being interoperable while keeping internal data private
is fundamental. Such a model is still lacking today, preventing organizations from switching
from Web1-2 technologies to Web3 ones.

1.1 Our Contributions

We propose Topos, a generalized interoperability protocol designed for transmitting messages
across sovereign blockchains. The Topos ecosystem is composed of a permissionless reliable
broadcast primitive [CGR11] and a scalable set of decoupled public and private blockchains,
named subnets. Topos ensures the validity of state transitions without relying on fraud proofs
[ABSB18] or on designated subsets of participants to perform validity checks [Woo16].

In the interoperability landscape, trustlessness is deﬁned as the absence of trust in the in-
teroperability protocol itself and relying instead on the security of the underlying blockchains.
While this is an improvement over trusted interoperability protocols, this does not permit
complete trustlessness and cannot provide a higher level of security than that of the inter-
operated blockchains. With Topos, we decouple the validity of cross-chain transactions from
the security of the underlying blockchains by replacing this coupling with a zkSTARK proof
system, providing irrefutable evidence of the validity of messages.

As part of their implementation of the Universal Certiﬁcate Interface (UCI), subnets
integrate the Topos zkVM (Zero-Knowledge Virtual Machine) to host an arbitrary number of
applications which can exchange assets and arbitrary data with other subnets by exchanging
objects called certiﬁcates. Certiﬁcates are a central component used by subnets to exchange
cross-subnet messages. Cross-subnet message transmission is handled by the Transmission
Control Engine (TCE), a decentralized network implementing a reliable broadcast primitive.
Additionally, the protocol enforces computational integrity of all state transitions among all
subnets by means of a zkSTARK proof system. Moreover, we introduce modiﬁcations to
the FROST signature scheme [KG21] to allow the TCE participants to authenticate incoming
certiﬁcates prior to their veriﬁcation and delivery. The combination of UCI and TCE provides
the ecosystem with uniform security and as such, subnets do not need to rely on any trust
assumptions but cryptographic assumptions for cross-subnet message passing. Finally, we
present the Topos Subnet, a subnet responsible for maintaining registration on the protocol
in order to minimize overall protocol complexity, while not being used for state synchronization
nor cross-subnet message passing.

The rest of the paper is organized as follows. Related works are discussed in Section 1.2.
In Section 2, we introduce the properties of our solution. We present in Section 3 the design
considerations of our protocol and its components. Section 4 shows several use cases in which
our solution is well-suited. In Section 5, we summarize the paper with concluding remarks
and Section 6 is dedicated to additional discussions and future works for our solution.

1.2 Related Work

Over the years, several projects have focused on interoperability and scalability. Here we
introduce some of the most contributing projects.

Cosmos.

[KB] Cosmos is a network of sovereign blockchains called zones. Zones are
endowed with Tendermint [Kwo14] and are connected with each other via the IBC proto-
col. Cosmos can only support interoperability between BFT-based blockchains and to do
so employs a simple model for their inter-blockchain communication protocol by centering

4

its design around the use of decentralized relayers and on-chain light-clients to allow con-
nected zones to verify each other’s block headers and validate transaction inclusion proofs.
The validity of cross-chain transfers is left to interpretation based on the trust zones have in
each other since, as opposed to Topos, Cosmos does not use validity proofs of state transitions.

Polkadot. [Woo16] Polkadot is a shard system composed of a central entity called the
Relay Chain along with shards called parachains. The purpose of Polkadot is to let parachains
free of any security concerns so that developers can focus on the application layer. This is en-
abled by two factors (a) an abstraction of the internals of the parachain providing a standard
veriﬁcation for all parachains (b) an active validation executed by randomly and frequently
sampled Relay Chain actors. These properties reﬂect the so-called Shared Security. The
validity of parachain block candidates is ensured by Relay Chain validators, hence prevents
parachains from being sovereign networks and from having a private state. On the contrary,
Topos allows subnets to have their own consensus, a private state, and trustless interoper-
ability.

Avalanche.

[SLBS20] Avalanche is a highly scalable blockchain platform that focuses
on the deployment of blockchains with three main targets: application-speciﬁc blockchains,
smart contract platforms, and digital asset platforms. In Avalanche, blockchains are deployed
within subnets (which are sets of validators). Validators are validating all chains in their
subnet, as well as the three chains composing the Primary Network. The Avalanche platform
has no bounds in the number of blockchains which can participate but oﬀers interoperability
only between the chains of the same subnet. Topos does not face this limitation: Upon imple-
menting the Topos protocol, subnets are interoperable with the whole ecosystem. Although
cross-subnet interoperability is envisioned on Avalanche, no design has been revealed yet.

Chainlink. [BCC+21] Chainlink 2.0 is a framework that aims at solving the oracle prob-
lem [Ora] by introducing the Decentralized Oracle Network (DON). Historically, oracle ser-
vices introduce trust. However, Chainlink tackles this problem by ﬁltering the oﬀ-chain data
source through a BFT layer. The committee of Oracles that composes the DON sign their
reports with a multi-signature scheme. By doing so, Chainlink is increasing decentralization
and minimizing trust in oracle services. Furthermore, Chainlink proposes an interoperabil-
ity feature with its Cross Chain Interoperability Protocol (CCIP). The global consistency of
cross-chain communication in CCIP is reduced to the security of their Anti-Fraud Network
which is a dedicated DON actively watching for misbehavior across other DONs. In Topos,
global consistency of cross-subnet messages is passively obtained via the TCE’s reliable broad-
cast protocol. In addition, validity of cross-subnet messages is ensured cryptographically in
Topos whereas Chainlink relies on agreements between oracles.

LayerZero. [RZ21] LayerZero is an interoperability protocol which decouples provision of
block headers and transaction proofs to allow for trustless cross-chain communication. Each
action is handled by two centralized or decentralized parties, namely an Oracle and a Re-
layer. The cross-chain message passing is trustless under the assumption of independence
between the Oracle and the Relayer. The Oracle transports the block headers while the
Relayer submits the transaction inclusion proofs. In LayerZero, cross-chain transactions are
not cryptographically guaranteed to be valid as opposed to Topos’s proofs of computational
integrity which enforce validity of all transactions.

5

2 Properties

An interoperability protocol should be trustless, secure, and have strong network eﬀect. The
following properties need to be maximized if the vision of an “Internet of blockchains” is to
be realized. By design, the Topos protocol fulﬁlls these properties comprehensively.

Trustless. Subnets receiving certiﬁcates and cross-subnet messages from another subnet
should have guarantees as to the validity of these cross-subnet messages. These guarantees
should not rely on trust assumptions in centralized entities, decentralized actors, or the in-
teroperated subnets, but on cryptographic assumptions. Leveraging succinct zero-knowledge
proofs allows for removing this trust completely from the equation and solely relying on math-
ematical truth.

Security. The protocol must be robust and prevent an adversary from creating conﬂict-
ing certiﬁcates in an attempt to double-spend via cross-subnet messages, as it would cause
consistency issues in the system.

Scalability. There should be no limit to the number of participants in the ecosystem.
The protocol should be able to handle an arbitrarily large number of subnets, as well as to
seamlessly scale to millions of TCE participants, by ideally ensuring logarithmic communica-
tion complexity per participant. Furthermore, the system must have very high capacity to be
able to process a massive amount of cross-subnet messages.

Privacy. It should be possible for subnets to keep their internal state hidden from the
rest of the ecosystem. Thus, the protocol cannot rely on having the receiving subnet nor any
third-parties actively verify cross-subnet messages by accessing the state of the sending sub-
net. Instead, cross-subnet messages should contain indisputable evidence that these messages
are correct. By design, the protocol should be able to handle any type of subnets, i.e., public
and private subnets.

Authentication. It is important that data exchanged between subnets is authenticated
to provide guarantees of integrity. Authentication using threshold signatures should have a
public key that remains static for the whole lifespan of subnets to facilitate key management.
As such, it should be possible for any actors, in and out of the protocol, to verify authenticity
of cross-subnet messages.

Decentralization. The protocol should allow for permissionless participation in the TCE
and open registration of subnets. Participation should not be handled by a central authority,
and processes should be able to join the system at any time. To enable high levels of decen-
tralization, it is also necessary that the entry cost for participation remains low, such that
common hardware is enough to fully participate in the system.

3 Design

The Topos protocol is a generalized interoperability protocol which enjoys strong network
eﬀect. Once a blockchain has implemented Topos, it becomes interoperable with all the
blockchains in the ecosystem, without any overhead. Topos complies with all the properties
detailed in the previous section. In this section, we will ﬁrst describe all the components that
compose Topos, then detail the protocol itself.

6

3.1 System Overview

Here, we deﬁne all the components that together make the Topos protocol.

3.1.1 Subnets

Subnets are sovereign blockchain networks which implement the Topos protocol, devise their
own consensus rules, and control their own native asset. New subnets join the ecosystem to
be natively interoperable with all existing subnets without making any compromise on their
sovereignty and without the need to trust any middleman. Though not a protocol requirement,
subnets are expected to implement classical BFT protocols to enforce deterministic ﬁnality.
This will help the subnet to guarantee that the state submitted to the rest of the ecosystem
is ﬁnalized, i.e., cannot be reverted, hence avoiding the subnet to be inconsistent between its
internal state and its submissions.

The ﬁrst subnet client will be our Substrate DevKit which is Topos’s extension of the
Substrate framework [Sub]. As any Substrate native blockchain, subnets can implement their
own consensus protocol and state transition function by customizing their own set of runtime
FRAME pallets. Topos’s Substrate DevKit additionally adds on top of Substrate the neces-
sary components for subnets to be compatible with the UCI. One signiﬁcant addition is the
integration of the Topos zkVM (see 3.1.2) as the core smart contract execution environment
for subnets in the Topos ecosystem.

In later iterations of the protocol, other DevKits will be created by the Topos community
as extensions of other blockchain frameworks and will allow developers familiar with any tech
stack to join the Topos ecosystem.

3.1.2

zkVM

Subnets implement the Topos zkVM, a zero-knowledge virtual machine that exposes a Turing
complete programming language which allows instructions to be provable with zero-knowledge
proofs. dApp developers can use the Topos zkVM programming language to write any type of
application that are deployed on any subnets in the form of smart contracts whose executions
are provable. Developers can as such leverage the composability oﬀered by the Topos protocol
by composing their applications with other zkVM-compatible applications deployed on any
subnets in the Topos ecosystem.

The Topos zkVM has been conceived to oﬀer a set of instructions eﬃciently veriﬁable with
our zkSTARK proof system. This instruction set, while small and simple, remains expressive
enough for developers to easily write any kind of application on subnets. We also include into
the default instruction set additional operation-speciﬁc instructions (e.g., range check, curve
point addition, hash evaluation, etc.), to allow programmers to execute common operations
directly without the burden of writing them with the original instruction set. The Topos
zkVM execution remains extremely fast to verify—maintaining the overall scalability of the
system—even when extending the original instruction set with custom complex ones.

3.1.3 Universal Certiﬁcate Interface

The Universal Certiﬁcation Interface (UCI) enfolds the concept of proving and verifying data
across diﬀerent subnets. This notion is key in trustless and secure interoperability: A sending
subnet generates data intended for another subnet and the receiving subnet is ensured that
the data is valid and authentic without the need for trust in the sending subnet or any third
party. The UCI oﬀers an abstraction of the internal structure of a subnet to guarantee these
properties of validity and authentication without compromising the sovereignty and privacy
of the sending subnet.

7

In the Topos ecosystem, the UCI exposes the interface that all subnets implement in order
to be interoperable with each other, i.e., exchange certiﬁed data. This interface describes how
certiﬁcates are to be constructed and authenticated by subnets.

3.1.3.1 Certiﬁcate

A certiﬁcate is an authenticated object that wraps exchanged data with a proof of validity.
The data subnets exchange are cross-subnet messages, i.e., cross-subnet asset transfers and
remote arbitrary smart contract calls. Authentication of certiﬁcates is done with Topos’s
ICE-FROST signature scheme and proofs of valid state transition are created using our zk-
STARK proof system.

The structure of a certiﬁcate is described below:

• subnet_id is the static ICE-FROST public key used as the unique subnet identiﬁer;

• prev_state_hash is the previous subnet state commitment (from the previous certiﬁ-

cate);

• state_hash is the current subnet state commitment;

• proof is the zkSTARK proof of validity;

• XS_list represents the list of included cross-subnet messages;

• proof_XS_list is the list of inclusion proofs of cross-subnet messages in the proven

state transition.

By including proofs of valid state transition in certiﬁcates, sending subnets prove the va-
lidity of all their internal transactions (including cross-subnet messages) executed since their
previous certiﬁcate. This allows a receiving subnet, i.e., a subnet to which at least one cross-
subnet message contained in the certiﬁcate is addressed, to verify the validity of a message
without having access to the state of the sending subnet nor relying on a third party to verify
the complete state transition. We envision that the actors creating these proofs will be subnet
validators although the Topos protocol does not impose any requirements.

A valid state transition is deﬁned as follows:

Deﬁnition (Valid State Transition). Let STF : Sk × Tk+1 → Sk+1 be a state transition
function, where Sk is the k-th subnet state committed to in the k-th certiﬁcate, and Tk+1 is a
set of transactions which applied to Sk results in Sk+1. We say that a state transition is valid
if and only if: ∀ tx ∈ Tk+1, tx is a transaction correctly executed by the Topos zkVM.

The zkSTARK proof included in the certiﬁcate veriﬁes that the set of transactions Tk+1
between Certk and Certk+1 is a valid state transition. While this does not ensure the validity
of the subnet state, it guarantees the validity of its state transitions. Thus, if the state initially
committed to by the subnet as per its registration and all of its subsequent state transitions
are valid, then by transitivity its latest state is valid.

The certiﬁcate validation is handled by the Valid cert predicate, deﬁned in Algorithm 1,
which calls the zkSTARK VerifC predicate (see Equation 1) on the certiﬁcate data to assert
the validity of the committed state transition, checks the inclusion proofs of the cross-subnets
messages in the proven state transition, and returns true if both checks succeed. In this case,

8

the predicate provides the certiﬁcate with intrinsic validity: The certiﬁcate contains all the
necessary information to prove its validity and its veriﬁcation does not depend on an external
state—the predicate is stateless and so trivially monotonic.

Algorithm 1 Certiﬁcate validation predicate

function Valid cert(Cert)

return VerifC(Cert.proof, Cert.prev_state_hash, Cert.state_hash) ∧

Verify incl(Cert.proof_XS_list)

end function

3.1.3.2 ICE-FROST Signature

A signature scheme TS = (KeyGen, Sign, Verify) with key generation, signing, and veriﬁcation
algorithms KeyGen, Sign, and Verify respectively, and security parameter λ is a (t, n) threshold
signature scheme if the following conditions hold:

• Correctness. Any subsets of participants with cardinality at least t can produce a valid
signature on message m. A valid signature is a signature that will be veriﬁed by the
Verify algorithm.

• Unforgeability. Any polynomial-time adversary who can corrupt up to t − 1 players and
views the protocol output (signature) on poly(λ) input messages of their choice cannot
produce the valid signature σ for a message m that has not been submitted to the Sign
algorithm before.

The Topos protocol employs threshold signatures to authenticate certiﬁcates, i.e., allow actors
of the ecosystem to verify that a propagated certiﬁcate has been created by the correct subnet
and has not been tampered with in transit. The Topos ICE-FROST signature [GRS+21] is
the ﬁrst to consider static private/public keys for a round-optimized Schnorr-based signature
scheme [Sch90]. With static public keys, the group’s established public and private keys
remain the same for the lifetime of the subnets, while the signing shares of each participant
are updated over time, as well as the set of group members. This ensures the long-term
security of the static keys and facilitates the veriﬁcation process of the generated threshold
signature because a group of signers communicate their public key to the veriﬁer only once
during the subnet’s lifetime.

Dealerless threshold signature schemes usually need to run a Distributed Key Generation
(DKG) [Ped91] protocol each and every time the set of participants changes, resulting in a new
public key. However, the TCE requires knowing the public key associated with the signature
in order for the TCE participants to verify the signatures applied to certiﬁcates. A natural
approach would be to include the threshold signature public key for the next certiﬁcate in the
current certiﬁcate but such short-lived public keys clearly lead to large overhead and are not
suited for the Topos protocol.

Our contribution to the ﬁeld of threshold signatures makes long-lived static public keys
possible. Topos uses ICE-FROST [GRS+21] to enforce usage of a single static key for the
whole lifespan of the subnet, no matter how many times the set of validators changes. This
allows for a lighter and simpler subnet key management.

In order to use a long-lived public key for each subnet, we add a share update property
to our scheme. To update the shares for each validator set, participants secretly share the
value “0” and send corresponding shares to other participants. These new shares are added to

9

previous shares to randomize them without changing the value of the shared secret. Random-
ization of shares guarantees unforgeability of the threshold signature scheme against a static
adversary, i.e., an adversary who can corrupt up to t−1 participants. A dynamic adversary on
the other hand can corrupt diﬀerent t−1 participants in each validator set. Because validators
secret shares need to be encrypted when redistributed, we need the additional property of
forward secrecy. That is, an attacker that would get access to some validator decryption key
would only be able to derive decryption keys between this compromised validator and future
ones, but would not be able to decrypt messages encrypted and shared by previous validator
sets during the shares redistribution phase, and hence would not gain knowledge of additional
secret shares. This key property ensures that even if the adversary corrupts diﬀerent subsets
of participants in consecutive validator sets, they still cannot forge a valid signature.

3.1.3.3 STARKs

When a subnet submits a certiﬁcate, it commits to a new state and certiﬁes the state transi-
tion. The new state is the state committed to in the previous certiﬁcate on which the state
transition is applied. To convince other subnets that the state transition is valid and con-
sistent with the previous state, the certiﬁcate contains a proof of computational integrity, a
zkSTARK proof [BSBHR18].

A STARK proof guarantees that a computation has been correctly executed and has
returned a certain output, and (if needed) without revealing the input. For example, a
STARK proof can guarantee that:

• The state Sk+1 is the state Sk plus some transactions, without revealing the transactions.

• The hash of the state Sk+1 is the hash of the state Sk plus some transactions, without

revealing the transactions nor the states.

• An Account a on subnet Si made a valid (holds enough funds and signed) transfer of x

tokens to an account b on subnet Sj, without revealing the balance of a.

More formally, a STARK proof is sent by a prover P to convince a veriﬁer V that it ran
a certain computation C with some input I (and possibly obtained some output O). The
STARK system is made of a proving algorithm and a verifying algorithm. While C is known
to both P and V, I and O could be partially or fully kept secret by the prover or shared
between the prover and the veriﬁer, depending on the statement to be proven. The entire
process takes four steps:

1. P runs C with input I and records an execution trace t. Broadly speaking, the trace is
a 2D-matrix recording the value of all the variables of C at each execution step. P also
saves the output O if any.

2. P executes the proving algorithm ProvC on input t (and O if any), which returns a
STARK proof π that C has been correctly executed with some input, and returned O
as an output (if any).

3. P sends π (and possibly parts of I, O, or functions of them, depending on the statement)

to V.

4. V executes VerifC on input the proof and potential inputs/outputs received. It returns
true if the proof has been computed from a valid execution of C that returns O (if any)
on input I, and F alse otherwise.

10

STARK systems are known to be doubly scalable, with a prover that is running in time
O(t log2 t), dominated by the Fast-Fourier-Transform interpolation, and a veriﬁer that scales
in only poly-logarithmic time with the trace length, i.e., O(log2 t). This allows subnets to
prove exponentially large computations and hence improve the overall scalability of the Topos
protocol. In addition, such systems are post-quantum secure, as only relying on symmetric
primitives like hash functions, unlike their SNARK [BSCTV14, Gro16, GWC19] counterparts
based on asymmetric primitives.

However, one issue with the above process is that ProvC and VerifC both depend on C.
In other words, a distinct pair of proving and verifying algorithms is needed for each speciﬁc
computation. Not only does it require both participants to potentially store and execute
multiple algorithms, but it also forces P to write a speciﬁc proving algorithm for every new
computation, for example for a new smart contract, it wants to prove. V would likewise
need to make sure to keep its verifying algorithm up to date. For these reasons, we adopted
a general-purpose approach: Our STARK system can prove arbitrary computations with a
single pair of proving and verifying algorithms that do not need to be updated if the program
to prove is modiﬁed.

More precisely, the computation C which is proven is the Topos zkVM execution itself. I
consists in a state hash and all the operations happening on-chain modifying this state. O
is the ﬁnal state being returned by the Topos zkVM after applying the provided input state
transition on the input state. After a proof has been computed, P sends it to V, along with
a hash of the ﬁnal state O. The hash of the previous state can be retrieved from the latest
veriﬁed certiﬁcate of the subnet P belongs to. Only providing the state hashes allows sending
subnets to keep their state private and improves on scalability by reducing the overhead in
data transmitted. The veriﬁcation function is deﬁned as follows:

VerifC(πk, Hash(Sk−1), Hash(Sk)) =

(cid:40)

true,
false,

if the proof is valid
otherwise

(1)

The veriﬁcation function attests to the validity of the state transition claimed by a send-
ing subnet, from a previous state that was committed to (in the form of a hash), to a new
committed state. This algorithm can only output true if the prover submitted a valid state
transition as part of its (private) input I, i.e., corresponding to valid executions of the Topos
zkVM.

Since the Topos protocol relies on cryptography for subnets to prove the validity of their
state transitions to the rest of the ecosystem, it is crucial to have eﬃcient cryptographic prim-
itives in order to preserve high scalability. STARK proof systems–in particular the ones based
on FRI (see A.2), as is the case for the one used in our protocol–have very light requirements
(namely to work on a prime ﬁeld Fp with a 2k-th root of unity for relatively large k) whereas
other common SNARK constructions are based, among other things, over algebraic groups,
which involve complex mathematical operations that can be hard to implement and optimize.
In particular, the prime ﬁeld involved in STARK proof systems can be much smaller than the
usual cryptographic size of 256 or 512 bits. However, blockchains always require some digi-
tal signature scheme to assert the authenticity of propagated messages and, to date, digital
signatures based on elliptic curves, such as Schnorr signatures, EdDSA or ECDSA are the
preferred ones, due to both their speed and resulting size. The underlying curves commonly
used in pair with those schemes are all of large cryptographic sizes, and hence prevent from
beneﬁting fully from the mathematical structure of our proving system. To address this, and
to oﬀer subnets the possibility to exploit the whole power of STARKs, we designed a new
elliptic curve, Cheetah [CST], constructed over a sextic extension of a small ﬁeld with char-
acteristic p = 264 − 232 + 1 and tailored for eﬃciency when proving operations over its group.

11

A detailed security analysis and description of the deterministic process that generated this
curve is available at [SSS22]. With Cheetah, the Topos zkVM execution C can be proven
while maintaining a small proof system base ﬁeld, a crucial consideration for the eﬃciency of
the protocol.

The STARK system at the core of Topos enables the protocol to be:

• Trustless: The soundness property of STARKs ensures that it is computationally infea-
sible for a malicious prover to create a valid proof for an invalid statement. This means
that validity of state transitions solely depends on the soundness of the STARK proof
included in certiﬁcates.

• Private: Instead of providing the whole computation that updated their internal state
to the veriﬁcation function, subnets pass only the known hash of their previous state
along with the hash of their new state, thus do not reveal anything about transactional
data. The computational integrity ensured by the STARK proof system combined with
zero-knowledge guarantees that no additional information about the state of subnets is
revealed to veriﬁers; this grants full privacy to subnets.

• Scalable: STARKs can prove the computational integrity of a very large number of

transactions while keeping the veriﬁcation cost extremely small.

3.1.4 Topos Subnet

The Topos Subnet is a blockchain network whose main purpose is to handle registration of
the ecosystem actors, namely the subnets and the TCE participants, to manage TOPOS,
the ecosystem’s native cryptocurrency, and to allow for governance of the protocol through
on-chain voting, such that TOPOS token holders will have the ability to participate in future
protocol improvements. Subnets register themselves by sending a special transaction which
pays a dedicated fee denominated in TOPOS. Furthermore, the Topos Subnet is leveraged for
the Sybil resistance of the TCE, requiring participants to lock a TOPOS amount in order to
join the system. Finally, it enables the setup of an incentive mechanism for the TCE partici-
pants to be rewarded when following the prescribed protocol.

As for the actual implementation, the Topos Subnet is built with the Substrate frame-
work [Sub] and implements the hybrid BABE/GRANDPA consensus. Block production is
conducted by the Ouroboros Praos-based [DGKR18] BABE protocol [Alp]. BABE ensures
liveness which guarantees that transactions submitted by honest users will eventually be
recorded as part of the Topos Subnet state. Moreover, GRANDPA [SKK20] is leveraged as
the ﬁnality gadget to ensure deterministic ﬁnality guaranteeing that blocks can never be re-
verted once ﬁnalized unlike protocols where ﬁnality is only probabilistic. Through the process
of nomination and validation, an unbounded number of TOPOS token holders are economi-
cally incentivized to participate in the consensus and contribute to the security of the system.

3.1.5 Transmission Control Engine

As seen in Section 3.1.3, the UCI ensures that subnets’ state transitions are valid (guaranteed
by the STARK proof) and that the certiﬁcates transporting them are authenticated (guar-
anteed by the ICE-FROST signature). To allow for trustless cross-subnet communication,
subnets additionally rely on the Transmission Control Engine (TCE), a network of nodes that
receives certiﬁcates submitted by subnets to consistently deliver them, i.e., prevent subnets
from having conﬂicting certiﬁcates successfully processed.

12

Figure 1: TCE partial ordering of cross-subnet messages. TCE processes p1 and p2 maintain
the same set of certiﬁcates but ordered diﬀerently.

The TCE implements a permissionless probabilistic protocol of causal reliable broadcast
based on [GKM+19a]. The protocol does not involve consensus since consensus enforces
total ordering on messages while it is suﬃcient to have causal ordering for our purposes, i.e.,
certiﬁcates from the same subnet do not commute, while two independent certiﬁcates from
two diﬀerent subnets commute. Causal ordering is needed to make sure that the protocol
processed all dependencies of a speciﬁc certiﬁcate as shown in Figure 1. This results in a
simpler, more eﬃcient and more robust protocol than consensus-based solutions.

A key role of the TCE is to deal with the situation where a subnet is under attack or is
controlled by an adversary, and tries to double-spend. A subnet Sm controlled by an adversary
may send the same assets twice to diﬀerent subnets Si and Sj, i.e., Sm sends two conﬂicting
n-th certiﬁcates (Certn to Si and Certn(cid:48) to Sj). In other words, and as shown in Figure 2,
for two certiﬁcates Certn and Certn(cid:48), they are said to be conﬂicting if both Certn and Certn(cid:48)
are valid with respect to Certn−1 but the operations associated with the two certiﬁcates do
not have a legal sequential history. Without a mechanism to prevent conﬂicting certiﬁcates,
Si and Sj would execute messages on-chain from Certn and Certn(cid:48) respectively, in which case
Sm would successfully be able to double-spend.

3.1.5.1 System Model

Here we brieﬂy describe the system model for the TCE reliable broadcast. We consider a set
Π of n processes. Processes are equipped with private and public keys and identiﬁed with the
latter. At most a fraction f of all processes is Byzantine, i.e., subject to arbitrary failures. We
say that a process is correct if it follows the prescribed protocol. Byzantine processes cannot
determine which correct processes another correct process is communicating with. Byzantine
processes are under the control of the same adversary, and can take coordinated actions.

Processes can communicate with each other using the Probabilistic Reliable Broadcast
(PRB) primitive [GKM+18, GKM+19b]. An instance of probabilistic reliable broadcast ex-
ports two events:

13

Figure 2: Certn and Certn(cid:48) are both valid with respect to the Valid cert function but
conﬂict with each other.

• prb.Broadcast(m): Used by a process inside the system to broadcast a message m;

• prb.Deliver(p, m): Used by a process inside the system to handle the delivery of a

message m from sender p.

For any (cid:15) ∈ [0, 1], we say that the protocol implementing the reliable broadcast is (cid:15)-secure if
the following properties hold:

• No duplication: No correct process prb.Delivers more than one message.

• Integrity: If a correct process prb.Delivers a message m, and the sender p is correct,

then m was previously prb.Broadcast by p.

• (cid:15)-Validity: If the sender p is correct, and p prb.Broadcasts a message m, then p eventually

prb.Delivers m with probability at least (1 - (cid:15)).

• (cid:15)-Consistency: Every correct process that prb.Delivers a message prb.Delivers the same

message with probability at least (1 − (cid:15)).

• (cid:15)-Totality: If a correct process prb.Delivers a message, then every correct process even-

tually prb.Delivers a message with probability at least (1 − (cid:15)).

3.1.5.2 Probabilistic Reliable Broadcast

For completeness, we recall the probabilistic reliable broadcast solution as presented in [GKM+18],
to underline its advantages and later detail the modiﬁcations we apply to it.

The probabilistic reliable broadcast protocol at the heart of the TCE is asynchronous,
permissionless and tolerant to Byzantine (arbitrary) failures. It replaces classical quorums by
stochastic samples which do not need to intersect and are of much smaller size compared to
quorums. The protocol has O(log n) message complexity per process—thus an overall message
complexity of O(n log n)—and the sample size per process is logarithmic in the size of the
system which hints at its massive scalability capabilities. The properties of Byzantine reliable
broadcast of the TCE can be violated with probability (cid:15), which can be made arbitrarily small.
The algorithm is composed of three sequential phases of communication exchanges, namely,
subscriptions, Echo exchanges, and Ready exchanges. Upon initialization, a correct process
randomly samples three sets via a uniform random oracle. The size of each set and the
associated threshold are security parameters of the protocol. At the end of the initialization,
each correct processes has the following:

14

• An Echo sample E and its associated threshold E < |E|

• A Ready sample R and its associated threshold R < |R|

• A Delivery sample D and its associated threshold D < |D|

During the subscription phase, a process starts exchanging sample-speciﬁc subscription
messages with processes in the Echo, Ready and Delivery sets. Upon receiving sample-
speciﬁc subscription messages from other processes, a process adds the corresponding message
senders in new samples in the following manner:

• Senders of Echo subscription messages are added to a new ˜E set.

• Senders of Ready subscription messages are added to a new ˜R set;

These sets determine how processes communicate between them. A process interacts with

its sets as follows:

• It only listens for messages coming from peers in E, R and D sets;

• It only sends messages to peers in ˜E and ˜R sets.

We note that each set is such that its size is Ω(log n).

Now we proceed with describing the algorithm implementing the probabilistic reliable
broadcast. Processes can communicate directly with each other or broadcast messages using
a probabilistic (not reliable) broadcast primitive, which might deliver conﬂicting copies of a
message. In the following we refer to it as pb.Broadcast and pb.Delivery.

Upon the invocation of prb.Broadcast for a message m, a process p pb.Broadcasts it to all

the processes in Π.

Upon pb.Delivering a correctly signed message m, a correct process sends an Echo message

to every process in its ˜E subscription set.

A correct process sends a Ready message for m (if correctly signed) to all processes in its

˜R subscription set if it receives either:

• at least E Echo messages for m from E; or

• at least R Ready messages for m from R.

When a correct process receives more than D Ready messages for m from its delivery sample
D for the ﬁrst time, and m is correctly signed, it prb.Delivers m.

In the context of the Topos protocol, the probabilistic reliable broadcast alone is not enough.
Indeed as mentioned above, the TCE is meant to consistently deliver messages while preserv-
ing causal order among them. In the next section we provide a deﬁnition of weak causal order
and discuss how to modify the PRB solution to extend it with a weak causal order prop-
erty. Finally we show how the TCE employs Weak Causal Probabilistic Reliable Broadcast to
broadcast certiﬁcates across the network, and how TCE nodes update their state accordingly.

15

3.1.5.3 Weak Causal Probabilistic Reliable Broadcast

We now introduce the Weak Causal Probabilistic Reliable Broadcast, which extends the previ-
ous broadcast primitive with an additional weak property of causal order among the delivered
messages. Intuitively, the weak causal order property imposes that if a correct process deliv-
ers a message m then m is weakly causally ordered with respect to the previously delivered
messages.

For completeness, we formally recall the deﬁnition of causal precedence [HT94]:

Deﬁnition (Causal Precedence). Let a step be the broadcast or the delivery of a message.
A given set of steps induces a partial order as follows. Step a casually precedes step b, denoted
a → b, if and only if:

• the same process executes both a and b, in that order; or

• a is the broadcast of some message m and b is the delivery of m; or

• there is a step c, such that a → c and c → b.

We now detail which kind of execution order we need to ensure for the TCE communica-
tion. In particular, we show why causal precedence is too strong for our purpose. Intuitively,
we are interested in keeping the execution order among the messages wcprb.Broadcast by the
same process on behalf of a subnet. We also impose the same execution order for any pair of
wcprb.Delivered and wcprb.Broadcast messages by the same process. However, it is not neces-
sary for the system to keep the execution order among messages wcprb.Delivered between two
wcprb.Broadcasts from the same subnet, i.e., certiﬁcates in deps. For instance, as shown in
Figure 1, correct processes p1 and p2 can wcprb.Deliver Certk,1 and Certi,2 in diﬀerent orders.

To formalize the above rules, we introduce the weak causal precedence relation, deﬁned as

follows:

Deﬁnition (Weak Causal Precedence). Let a step be the broadcast or the delivery of a
message. A given set of steps induces a partial order as follows. Step a weakly casually
precedes step b, denoted a →w b, if and only if:

• the same process executes both a and b, in that order, such that a and b are not a

delivery step; or

• a is the broadcast of some message m and b is the delivery of m; or

• there is a step c, such that a →w c and c →w b.

An instance of Weak Causal Probabilistic Reliable Broadcast (WCPRB) exposes two

events:

• wcprb.Broadcast(m): Used by a process inside the system to broadcast a message m;

• wcprb.Deliver(m): Used by a process inside the system to deliver a message m.

For any (cid:15) ∈ [0, 1] we say that the protocol implementing the WCPRB is (cid:15)-secure if the
following properties hold: No duplication, Integrity, (cid:15)-Validity, (cid:15)-Consistency, (cid:15)-Totality as
deﬁned for the probabilistic reliable broadcast, and additionally:

16

• Weak causal order: If the wcprb.Broadcast of a message m weakly causally precedes
the wcprb.Broadcast of a message m(cid:48), no correct process wcprb.Delivers m(cid:48) unless it has
previously delivered m.

The pseudo-code in Algorithm 4 speciﬁes a solution for WCPRB. This solution employs
the probabilistic reliable broadcast primitive as described in the previous section and a Valid
predicate speciﬁc to the Topos system.

Before introducing the algorithm, we deﬁne the Valid predicate. In the PRB solution,
a message must be properly signed to be delivered. Notice that, in the Topos system, TCE
processes broadcast certiﬁcates on behalf of subnets. Certiﬁcate production and submission
is left to the discretion of the sending subnet. For that reason, we are not interested in identi-
fying the process but the subnet that originated this certiﬁcate; this information is provided
inside the certiﬁcate itself by means of the subnet_id ﬁeld. Moreover, each certiﬁcate is
wcprb.Delivered if the casually dependent certiﬁcates have also been wcprb.Delivered.

The message to be delivered must satisfy validity conditions. Speciﬁcally, the Valid
predicate (see Algorithm 3) is the conjunction of the two deterministic predicates Valid cert
and Valid deps:

1. The certiﬁcate validation predicate Valid cert (see Algorithm 1) must return true;

2. Any preceding certiﬁcate that a subnet Sj issued must have been validated (implied by

the linkage of certiﬁcates and encompassed in Valid cert);

3. The reported dependencies of the certiﬁcate must have been validated and must exist
in the histories of all subnets of the dependencies, i.e., the Valid deps predicate must
output true.

The Valid deps predicate, as deﬁned in Algorithm 2, returns true if for each certiﬁcate
submitted by a subnet Sk in deps, the certiﬁcate is in historyp(Sk). Note that the pred-
icate is monotonic because, for a certiﬁcate message m, if Valid deps(m.deps) = true at
time t then ∀t(cid:48) ≥ t, Valid deps(m.deps) = true. The combination of the (cid:15)-Consistency, the
(cid:15)-Totality—both providing the agreement property—and weak causal order (enforced by the
Valid deps predicate) properties of the WCPRB deﬁnes extrinsic validity: All correct TCE
nodes are guaranteed to deliver the same weakly causally ordered sets of certiﬁcates, i.e., no
subnet can successfully submit conﬂicting certiﬁcates in order to double-spend.

Algorithm 2 Certiﬁcate dependencies validation predicate at process p

function Valid deps(deps)

return

(cid:86)
Certi∈deps

(Certi ∈ historyp(Sk = Certi.subnet id))

end function

When participating in the WCPRB, each TCE process p locally holds the following vari-

ables:

• historyp(Sj): The local set of accepted incoming and outgoing certiﬁcates involving

subnet Sj, for all Sj (initialized and modiﬁed by Algorithm 5);

• depsp: The local set of incoming certiﬁcates involving a subnet since its last outgoing

certiﬁcate (initialized and modiﬁed by Algorithm 5);

• pendingp: The local set of certiﬁcates pending for validation.

17

Note that depsp and historyp(Sj) are shared between Algorithm 3 and Algorithm 5, where

only the latter modiﬁes both variables.

Algorithm 3 Certiﬁcate message validation at process p

function Valid(m)

(Cert, deps) := m
return Valid cert(Cert) ∧ Valid deps(deps)

end function

The WCPRB protocol works as follows. When a TCE process wants to wcprb.Broadcast
a message m it veriﬁes that Valid(m) holds before calling prb.Broadcast(m). Upon the
prb.Delivery(m) event, a TCE process p does not trigger the wcprb.Delivery of that message
yet, but adds it to the pendingp set. Intuitively, Valid being a stateful predicate, it can happen
that m does not satisfy the predicate at the current time but it will after the wcprb.Delivery
of other messages. Hence, new incoming messages are kept in the pendingp variable. As soon
as there exists a message m in pendingp such that Valid(m) outputs true, m is removed from
pendingp and delivered. An interested reader can ﬁnd a sketch of the proof of correctness of
the proposed solution in Appendix C.

Algorithm 4 The TCE’s Weak Causal Probabilistic Reliable Broadcast at process p

pendingp := ∅

upon event wcprb.Broadcast(m) do

if Valid(m) then

prb.Broadcast(m)

end if

upon event (cid:104)prb.Deliver(m)(cid:105) do
pendingp := pendingp ∪ {m}

upon exists m such that (cid:104){m} ∈ pendingp ∧ Valid(m)(cid:105) do

pendingp := pendingp \ {m}
trigger wcprb.Deliver(m)

3.1.5.4 Certiﬁcate Submission and State Update

We detail how to transmit certiﬁcates in the Topos ecosystem using WCPRB. Algorithm 5
describes the submission of a certiﬁcate and its application to the local state of TCE processes.

Each TCE process p locally holds the following variables:

• historyp(Sj): as deﬁned for Algorithm 3;

• depsp: as deﬁned for Algorithm 3;

• subnetp: The subnet that p belongs to. If p does not belong to any subnet then subnetp =

⊥.

To submit a certiﬁcate Cert, a subnet Sj wcprb.Broadcasts an ICE-FROST signed mes-
sage m = (Cert, deps). When a correct TCE process wcprb.Delivers a certiﬁcate, the TCE
node applies the certiﬁcate to its local state. Applying a certiﬁcate means that the TCE node
adds the certiﬁcate Cert and its dependencies deps to the history of subnet Sj. More precisely,

18

upon the wcprb.Delivery event for a message m from Sj, a correct process p always updates
historyp(Sj) but updates depsp only if p belongs to a subnet addressed by the cross-subnet
message. Notice that, if p does not belong to any subnet (subnetp = ⊥) then p never updates
depsp.

The state of the TCE (see Equation 2) is deﬁned as the union of all the history sets of
the TCE participants. In other words, and as shown in the equation below, it is the set of all
certiﬁcates that have been validated, wcprb.Delivered, and applied. The state of each TCE
node is local and converges with probability 1 − (cid:15).

stateT CE =




(cid:91)



p∈Π

historyp






(2)

Algorithm 5 The TCE’s certiﬁcate submission and state update at process p

(cid:46) S: Set of all subnets

history(Sj) := ∅, ∀Sj ∈ S
depsp := ∅
subnetp ∈ S ∪ {⊥}

upon event submit(m) do
wcprb.Broadcast(m)
depsp := ∅

upon event (cid:104)wcprb.Deliver(m)(cid:105) do

(Cert, deps) := m
historyp(Sj) := historyp(Sj) ∪ deps ∪ Cert
if (subnetp ∈ SCert) then
depsp := depsp ∪ Cert

(cid:46) SCert: Subnets receiving messages for them in Cert

end if

Overall, the TCE adds multiple key properties to the Topos protocol:

• Security: The TCE enforces a weak causal ordering of certiﬁcates under asynchrony
[CR93] and is a more robust primitive than consensus and atomic broadcast since both
of them are impossible to solve in the asynchronous model even with one crash failure
[FLP85].

• Scalability and Decentralization: With a per-node communication and computation
complexity logarithmic in the size of the system, the WCPRB protocol can sustain a very
high number of TCE participants—which increases decentralization—while preserving
high throughput.

Discussion. For clarity of presentation, we used the PRB protocol as a black box.
However, the solution deﬁned in Section 3.1.5.2 would not prevent the prb.Delivery of ill-
formed messages (i.e., messages such that Valid cert(Cert) = false). Notice that this is not
a problem, as those messages are not delivered by the WCPRB solution deﬁned in Algorithm
4. Indeed, if Valid cert(Cert) = false then Valid(m) = false (see Algorithm 3).

However, to prevent TCE processes from prb.Delivering messages that will never be
wcprb.Delivered, we can move the Valid cert check to the reception of new messages during
the PRB protocol (see Section 3.1.5.2). That is, at the reception of a message m, each correct

19

process checks that the message is correctly signed and that the certiﬁcate carried by m is
well-formed (Valid cert(Cert) = true) before processing it, or discards it otherwise.

As a consequence, at the WCPRB level (see Algorithm 4) we can apply a lighter Valid(cid:48)

predicate deﬁnition, as deﬁned in Algorithm 6.

Algorithm 6 Certiﬁcate validation at process p, when Valid cert check is integrated into
the PRB solution.

function Valid(cid:48)(m)

return Valid deps(m.deps)

end function

3.1.5.5 Sybil Resistance

The TCE establishes an agreement on a set of operations among processes with equal weight.
Processes are equal due to the fact that they must construct samples of peers selected uni-
formly at random. The TCE tolerates up to a threshold f of Byzantine processes in the
system. The Sybil attack [Dou02], the capability of an adversary to freely create identities to
overcome the f threshold, is the main threat that the system has to tolerate. Sybil resistance
is relatively easy to achieve in a permissioned system contrary to permissionless systems where
membership is free. The TCE is a permissionless system and as such it is crucial to enforce
that the number of Byzantine processes remain below the threshold. Notable approaches are
the Proof of Work (the adversary cannot have more computational power for free) and Proof
of Stake (the adversary cannot hold more assets for free). The Topos approach follows the
latter, which implies the management of an asset. So in order to defend itself against Sybil
attacks, the TCE leverages the Topos Subnet to ensure that a majority of reliable broad-
cast participants follows the protocol such that it is not possible to inconsistently deliver
cross-subnet messages, i.e., double-spend.

Processes wishing to participate in the TCE must submit a special transaction on the
Topos Subnet which records their intention to join the TCE. This transaction includes a
ﬁxed amount, denominated in TOPOS, as well as an identiﬁer of the participant and it locks
the TOPOS amount on the Topos Subnet. Non-free registration of participants provides the
basis for a Sybil resistance mechanism in the TCE: Participants communicate only with peers
registered on the Topos Subnet.

3.2 Protocol Overview

To this day, interoperability protocols have fallen into disjointed categories depending on their
design goals. Trusted interoperability protocols (e.g., [Wor, Ava, Pol]) have relied on exter-
nal veriﬁers—administrators of centralized protocols or incentivized relayers in decentralized
protocols—to bridge the interoperated chains, allowing for cross-chain message passing at the
cost of trust in verifying entities that are external to the blockchains implementing the proto-
col (depending on an auxiliary, often much weaker, cryptoeconomic security). On the other
hand, trustless protocols have found solutions to remove the need for trust in third parties:
Some protocols (e.g., [RZ21]) have centered their design on the multiplication of non-colluding
verifying networks, while others (e.g., [KB]) have removed the need for external veriﬁcation
by solely depending on the chain’s own actors to natively verify data cross the chains. These
models, although on the right path towards trustless interoperability, still impose trust in the
consensus security of the interoperated chains and as such do not permit true trustlessness.
Topos innovates by introducing the very ﬁrst solution that cryptographically enforces
validity of cross-subnet messages without the need for trust in any external veriﬁers nor con-

20

sensus security. At its core, Topos allows subnets to exchange messages with each other
trustlessly and safely. Uniform security (see Section 3.2.5) is a key innovation in the cross-
chain interoperability landscape and will pave the way for a new era of secure communication
between decoupled blockchains.

Generally speaking, the Topos protocol is built on three major pillars enabled by the

components exposed in the previous section.

1. The TCE reliable broadcast protocol allows for consistent delivery of causally ordered

subnet certiﬁcates.

2. Certiﬁcates include a zkSTARK validity proof of the committed state transition; thus
every node in the TCE network can attest to the validity of cross-subnet messages
without the need to trust the sending subnet.

3. Certiﬁcates are authenticated by means of an ICE-FROST signature; receiving subnets

can thereby be ensured that delivered certiﬁcates were not tampered with.

3.2.1 Cross-Subnet Message

A cross-subnet message represents a request initiated by a user from a subnet to execute a
transaction in a remote subnet. It takes the form of a function call of a dedicated protocol-
level smart contract, namely the Topos Core contract, on the sending subnet and is to be
interpreted on the receiving subnet as another function to call. The Topos Core contract
function to call on the sending subnet depends on the type of message requested:

• Asset transfer: An asset is burnt/locked on the sending subnet and equivalently minted

on the receiving one.

transferAsset(

subnet_id: Identifier of the receiving subnet,
asset_id: Identifier of the transferred asset,
recipient_addr: Recipient’s address on the receiving subnet,
amount: Amount to be transferred

)

• Arbitrary contract call: A contract on the receiving subnet is called from the sending

subnet.

callArbitraryContract(

subnet_id: Identifier of the receiving subnet,
contract_addr: Address of the smart contract,
func_name: Name of the function to call,
func_args: Arguments to pass to the function call

)

Topos enables interoperability of subnets via the following transmission ﬂow of cross-
subnet messages (see Figure 3). Once a new cross-subnet message emitted by a user is part
of the canonical chain of the subnet, it becomes ready for certiﬁcation as per the rules of the
UCI: it is batched with an arbitrary amount of transactions to form a new state transition
whose validity is to be proven in a new authenticated certiﬁcate. Once created, the message
is delivered throughout the TCE network via the reliable broadcast primitive and eventually

21

Figure 3: Transmission ﬂow of a cross-subnet message

collected by the subnet it is addressed to. Thanks to the validity and authentication prop-
erties guaranteed by the UCI and the consistent delivery ensured by the TCE, the receiving
subnet can trustlessly and securely interpret the cross-subnet message and execute the request
transaction locally.

3.2.2 Scalability and Decentralization

In order to verify the zkSTARK proof included in a certiﬁcate, TCE nodes do not need access
to the subnet state. The zkSTARK veriﬁer only accesses the hash of the state committed to
in the previous certiﬁcate of the same subnet, and the hash of the new state committed to in
the new certiﬁcate. This means that even though the size of the subnets’ state transitions can
be extremely large, the veriﬁcation is nearly-optimal and the storage requirement for TCE
nodes is kept very low. Keeping the state of the TCE small is paramount to ensure that new
joining nodes can synchronize quickly and can keep the burden of storing the certiﬁcates low,
even with the system processing a large amount of cross-subnet messages. While the size of
the TCE state grows linearly with the number of certiﬁcates, the overhead of storing new
certiﬁcates remains acceptable.

Another essential advantage of having stateless veriﬁcation resides in the fact that since

22

Figure 4: Atomic Composability

the cost of storing the state of the TCE is kept low, it is possible for actors with low-cost
hardware to participate in the TCE, thus increasing the decentralization of the TCE.

3.2.3 Composability

As detailed earlier in the paper, composability is a design principle that is found when var-
ious applications can compose their value by invoking each others’ functions. In the Topos
ecosystem, composability is ensured in two diﬀerent manners.

3.2.3.1 Atomic Composability

Within a single subnet network, developers can deploy smart contracts that invoke other
contracts synchronously, i.e., comprise contract-to-contract calls that are executed one after
the other and only if the previous operation was successfully completed (see Figure 4). If
a single operation fails, the whole transaction is reverted.
In this context, composability
is described as atomic for either all operations or none are executed. Commonly found in
traditional databases, atomic composability allows subnets to safely transition their state and
prevents them from facing corrupted state introduced by composed contract calls that fail in
the middle their execution.

3.2.3.2 Asynchronous Composability

In addition to atomic intra-subnet composability, the Topos protocol permits inter-subnet
asynchronous composability, i.e., the capability of diﬀerent applications deployed on multiple
subnets to invoke each other. As we have seen previously, users of a sending subnet can emit
cross-subnet asset transfers or remotely invoke arbitrary smart contracts from diﬀerent subnets
by calling functions of the Topos Core contract. To obtain composability across subnets,
developers can atomically compose their smart contracts with the Topos Core contract, i.e.,
programmatically execute cross-subnet asset transfers or remote contract calls as part of their
own smart contract functions. Then, subnets can include calls to these composed smart
contracts in certiﬁcates for receiving subnets to learn about these new types of cross-subnet
messages (see Figure 5).

Asynchronous composability is enabled in the Topos ecosystem by the UCI and the TCE,

and is provided to any applications deployed on any subnets.

23

Figure 5: Asynchronous Composability

3.2.4 Incentive System Design

Topos will create economic incentives for the various actors of its ecosystem by means of its
native token, TOPOS.

In blockchain systems, some actors are selﬁsh and want to take advantage of the system.
These actors deviate from the protocol, when such deviation will lead to more individual
gain. As an example, they deviate to earn more rewards than when following the prescribed
protocol. These actors are called rationals. The Topos ecosystem aims at being tolerant to
Byzantine faults when the participants are rational.

In the following sections, we brieﬂy discuss incentive system designs that will be imple-
mented in Topos that will help align the rational actors behaviors to the prescribed behaviors.

3.2.4.1 TCE Incentives

Topos needs to prevent the veriﬁer’s dilemma [LTKS15] in which, instead of maintaining the
common good, correct processes choose not to verify certiﬁcates because their veriﬁcation is
more computationally expensive than verifying transactions, or doing anything at all. Even
if requiring the reliable broadcast participant to stake an amount of TOPOS is suﬃcient
to provide guarantees against Sybil attacks, it is not suﬃcient on its own to incentivize
TCE participants to follow the prescribed protocol. In fact, the system can still be subject
to many predicaments, such as the veriﬁer’s dilemma. Thus, to ensure proper veriﬁcation
and execution of certiﬁcates, TCE participants who correctly followed the protocol should
be rewarded accordingly. Such rewards come from applying a special fee to cross-subnet
messages. Fees associated to cross-subnet messages are denominated in TOPOS and are
collected by TCE participants with respect to their work. Without such economic incentives,
undesired situations can happen. For example, no one veriﬁes certiﬁcates and as such invalid
certiﬁcates can be spread in the system, or certiﬁcates could stay in pending for a long amount
of time, increasing the end-to-end cross-subnet communication latency. Topos’s incentive
model will give guarantees that all certiﬁcates are processed since they potentially contain a
large number of cross-subnet messages. To ensure the performance of the system, a desirable
objective of the incentive model is to process the certiﬁcates as quickly as possible. Verifying
and executing certiﬁcates should be an interesting and lucrative activity incentivizing rational
TCE participants to behave well, i.e., the incentive model should not reward participants
who do not contribute to the system. This is ensured by the proof-of-activity mechanism
introduced below.

24

Proof-of-Activity Since the communication in the TCE is not synchronous, assessing
whether a node does not participate is generally impossible for one cannot distinguish if a node
is slow or if it is not working. The alternative approach is to prove that a node was active.
Notice that this approach cannot, however, account for slow nodes. A proof-of-activity for a
node or a set of nodes proves that their work has been seen and was considered by suﬃciently
many TCE participants. Since messages are signed, the proof-of-activity can consist of the set
of messages delivered by a node. However, exchanging such sets of messages will induce a high
communication overhead and will require too much storage on the Topos subnet; therefore, to
be practical, the proof-of-activity will rely on aggregation techniques. The technical details
are deferred to a subsequent paper.

3.2.4.2 Cross-Subnet Fee

Cross-subnet fees must also be paid in order for the requested transaction to be executed on
the receiving subnet by its validators. To estimate these fees, the transaction originator (a
participant of the sending subnet) can ask a service to estimate the fee required to execute the
given transaction. The service estimates and returns the result based on the fee calculation
of the receiving subnet. One possibility is for this service to be exposed by a system of de-
centralized oracles like Chainlink [BCC+21]. Internally, the estimation provider will estimate
the resources consumed by processing the transaction requested in the cross-subnet message
based on the current receiving subnet state.

As a general observation, if the cross-subnet fee was not greater than the one of regular
transactions, the reward collected by the validator of the receiving subnet would be smaller
(because shared with the TCE participants), hence it would not be in the subnet validators’
best interest to process certiﬁcates in the ﬁrst place.

3.2.5 Uniform Security

As we have seen throughout the paper, the Topos protocol allows for trustless interoperability.
A sending subnet is responsible for proving that transactions are valid executions of the Topos
zkVM, signing certiﬁcates that include cross-subnet messages, and sending the certiﬁcates to
the TCE for broadcast in the ecosystem, while a receiving subnet is responsible for correctly
applying the cross-subnet messages, i.e., submitting the requested transactions in their net-
work.

Topos’s uniform security is realized by the combined properties of the UCI and the TCE:

• Intrinsic validity of certiﬁcates, ensured by the UCI’s Valid cert predicate;

• Extrinsic validity of certiﬁcate messages, ensured by the WCPRB’s agreement property

and Valid deps predicate implemented by the TCE.

Intrinsic Validity. The computational integrity of subnets’ state transitions is fully de-
coupled from the consensus security of the related subnets and is entirely ensured by zkSTARK
proofs. It is computationally infeasible for an adversary to forge a proof of validity, i.e., con-
vince a veriﬁer that an invalid transaction was correctly executed by the Topos zkVM. In this
setup, receiving subnets beneﬁt from an unparalleled level of security for they are assured
that certiﬁed state transitions are valid. Put another way, if the UCI certiﬁcate validation
predicate Valid cert outputs true, cross-subnet messages are guaranteed to be intrinsically
valid.

25

Extrinsic Validity. The certiﬁcate messages that are delivered by TCE nodes are guar-
anteed not to be conﬂicting with each other while they form weakly causally ordered sets
which capture the weak causal precedence between messages. This is achieved if the TCE’s
Valid deps predicate outputs true, which triggers the wcprb.Delivery when intrinsic validity
is also veriﬁed. It follows that it is infeasible for malicious subnets to successfully double-
spend and deceive honest receiving subnets into executing conﬂicting cross-subnet messages.

As soon as a certiﬁcate is delivered, intrinsic validity and extrinsic validity are enforced
by the Topos protocol. This provides the ecosystem with uniform security. The safety of
executing cross-subnet messages internally on receiving subnets is independent of the security
of sending subnets. The trust in cryptographic primitives in lieu of bridge veriﬁers and/or
blockchain consensus as to proving the validity of the message is a fundamental innovation
in the ﬁeld of blockchain interoperability. It is infeasible to create a certiﬁcate containing an
invalid state transition and to create conﬂicting certiﬁcates in order to double-spend across
the ecosystem, even in the presence of a malicious subnet, e.g., more than 2/3 of its validators
are controlled by an adversary. Note that transaction censorship remains an issue which needs
to be addressed by subnets directly.

Secure Cross-Subnet Asset Transfer.

In the practical case of a cross-subnet asset
transfer, a sending subnet submits a certiﬁcate containing a proof of the validity of the as-
set transfer transaction. This transaction, after checking that the balance of the sender was
suﬃcient to allow the transfer, proceeded with locking/burning the assets to be transferred.
Once delivered and veriﬁed, the certiﬁcate gives total insurance to the receiving subnet that
the balance check and the lock/burn operations were conducted with success on the send-
ing subnet. This demonstrates that no malicious entity can simulate that some assets were
locked/burnt in the context of a cross-subnet asset transfer, preventing them from arbitrarily
minting tokens on the receiving subnet.

An additional innovation brought by the Topos protocol is in that having uniform security
allows for the ﬁrst trustless burn-mint asset transfer model: Receiving subnets do not need
to trust sending subnets to have correctly burnt assets before minting. More secure than the
lock-mint model, burning assets on sending subnets ensures that no authority can steal user
assets sent across multiple chains. By enabling a trustless burn-mint asset transfer model,
Topos paves the way for a new kind of asset bridge paradigm where tokens can be natively
and frictionlessly deployed and managed on any blockchains.

3.2.6 Finality and Reorganization

With certiﬁcates being stored on the TCE, it is guaranteed that the submitted commitments
to the state of subnets are immutable and hence that subnets’ states cannot be reverted to
states prior to the ones committed to in their latest delivered certiﬁcates without creating
conﬂicts. In the event that a subnet reorgs to such state, the TCE would prevent the delivery
of new certiﬁcates committing to a new state as these certiﬁcates would conﬂict with the latest
delivered certiﬁcate. This is guaranteed by the monotonicity of the TCE message predicate:
If for any message m, Valid(m) is true at time t then it remains true at any time t(cid:48) ≥ t. Once
a certiﬁcate message is delivered via the WCPRB primitive, the certiﬁcate is considered to
be ﬁnal.

26

4 Use Cases

The Topos protocol can suit various diﬀerent use cases. Below are outlined three use cases
which hint at the vast capabilities that Topos is capable of.

4.1 Subnets as Layer-2 to Interoperate Layer-1

As we have seen previously, in the Topos ecosystem subnets are general-purpose blockchains:
They can host any type of application and prove their state transitions using the Topos zkVM,
a virtual machine that allows for the execution of arbitrary provable computation. One typical
use case that we envision is that of layer-2 (L2) protocols that scale layer-1 (L1) blockchain
networks by delegating the execution of transactions to an oﬀchain network and by relying on
validity proofs to update the L2 state view on the L1, i.e., zk-rollups [But18]. L2 protocols
separate the execution and settlement layers. Traditionally, the two layers are combined:
Transactions (execution layer) are executed locally by a participating node when importing a
block that has been validated by the network consensus rules (settlement layer). The Topos
ecosystem enables the concept of layered scalability (see Figure 6) where participating subnets
are execution layers which delegate state settlement to external L1 networks. One may notice
that L1 networks can greatly beneﬁt from the instantiation of new zk-rollup subnets for
they can delegate part of their execution layer and hence better scale by settling many more
transactions per second. Subnets are L2 zk-rollups scaling existing secure L1s (e.g., Ethereum
[But], Avalanche [SLBS20]). In this conﬁguration, settlement happens on the L1 networks
where subnets publish their proofs of valid state transition.

A key consequence is that Topos indirectly enables interoperability between decoupled L1
blockchains: Any L1 chain that hosts bridge smart contracts bridging assets with a Topos
subnet is de facto compatible with all other subnets in the Topos ecosystem, some of which are
to be zk-rollups of other L1 networks and as such are capable to route cross-subnet messages
back to their assigned L1 chain.

By design, L2 networks oﬀer much cheaper transaction fees than L1 blockchains for they
are parallel networks that do not face similar levels of congestion (if they were, the proto-
col operators could simply spawn a new instance of the protocol and delegate part of their
execution workload to it). For that reason, dApps have been making the move to L2 and
so have been their L1 users. By moving to Topos subnets, L1 users might enjoy lower fees
and additionally gain for free interoperability with all other subnets in the ecosystem and in
ﬁne with all the other bridged L1 networks. The Topos protocol oﬀers interoperability with
scalability for free for existing L1s.

Practically, the data ﬂow is the following (see Figure 7):

1. To send funds to an L2 subnet, users deposit assets into a bridge contract on the
underlying L1 blockchain. An equivalent number of wrapped assets is then minted on
the L2 subnet for the user once the lock transaction is processed (classic lock-mint model
found in most bridge protocols).

2. Users can initiate (wrapped) asset transfers to any other subnet in the ecosystem. They
can also use their wrapped assets to pay fees when submitting requests for general-
purpose computation execution, either locally on their subnet, or remotely on any other
subnet (remote arbitrary transaction).

3. A large number of subnet transactions are batched and proven by a zkSTARK proof
which is transmitted to the L1 blockchain for L2 state settlement and to the rest of the
Topos ecosystem via Topos certiﬁcates.

27

Figure 6: Interaction between L1s and L2s

4. The TCE reliably broadcasts certiﬁcates throughout the ecosystem. Once certiﬁcates
are delivered to all TCE nodes, the validators of receiving subnets can process the
included requests for remote transaction execution and submit requested transactions
locally in their subnet network.

4.2 Decentralized Finance (DeFi)

In the past few years, DeFi, one of the predominant use cases of web3 technologies today, has
attracted a previously unseen level of user activity and commitment, with global TVL (Total
Value Locked) reaching amounts in the hundreds of billions of USD. The problem is that
the locked value remains isolated in silos, inaccessible for user-friendly and secure exchange
options are still lacking. In most cases, liquidity, staking, loans, and other forms of DeFi value
remain locked oﬀ in individual protocols, i.e., smart contracts, on individual blockchains. Due
to this condition, crypto assets often lay idle in users’ wallets as there is limited scope for their
use within individual blockchains. And in turn, DeFi is unable to realize its full potential.

To unlock the true potential of decentralized ﬁnance and capture massive value it is
essential to allow for seamless composability of platforms and applications across diﬀerent
blockchain ecosystems, so that assets can move frictionlessly across diﬀerent blockchain net-
works and be used in any DeFi protocols on any blockchains. Using trustless bridges is the
best ﬁt for DeFi because they are non-custodial, and from a security viewpoint they only lever-
age the security of the interoperated blockchains. Because of Topos’ innovations, which give
superior security guarantees than other so-called trustless interoperability protocols, value
can move freely and securely from one DeFi protocol to another. The properties provided
by Topos greatly enhance DeFi’s potential to establish itself as a ubiquitous substitution for
traditional ﬁnancial systems.

4.3 Enterprise Adoption

The two major problems preventing enterprise adoption of blockchain technologies are the
lack of interoperability and the lack of privacy [Inc19].

Lack of interoperability. Companies and organizations build value by assembling pro-
prietary data and by controlling which part of it they expose in their products and services.
Enterprises often prosper by composing value with other companies and to that end have
traditionally, in the Web1-2 era, used ubiquitous infrastructure and technologies such as au-
thenticated RESTful APIs to interface their products and services with their partners’ without
friction nor extra cost. Unfortunately, Web3 technologies have yet to create such standards.
For enterprises to use Web3 and blockchain technologies, there is a need for a frictionless
interoperability model in which blockchains running proprietary business logic and storing

28

Figure 7: Transmission ﬂow of a cross-subnet transaction in a zk-rollup conﬁguration

29

proprietary data can exchange and capture value openly and without the requirement to
expose their private and hidden information.

Lack of privacy. Privacy is another challenge of blockchain technologies. One of the
greatest strengths of the technology is the transparency that comes from having a distributed
record of transaction history that is public and easy to verify. Yet, it poses a threat to the
privacy of organisations and users. Enterprises which want to protect their trade secrets and
other sensitive information are therefore reluctant to embrace even the most prominent per-
missionless blockchain protocols and hence have favored the private/permissioned blockchain
architecture.

Topos allows an unbounded heterogeneous set of public and private blockchains to in-
teroperate with each other while preserving the privacy of their internal state. As such,
Topos solves for both blockchain interoperability and privacy, and hence is the springboard
for adoption of the technology by enterprises.

5 Conclusion

In this paper, we introduced the design of Topos, the ﬁrst interoperability protocol that is
truly trustless and decentralized while preserving the privacy of the participating networks.
Topos allows cross-subnet messages to be safely exchanged without the need to rely on third
parties to guarantee the validity of the cross-subnet messages. Instead, we showed that this
trust can be replaced by proofs of computational integrity, providing cryptographic guaran-
tees. Another beneﬁt of using such proofs is that veriﬁcation is extremely fast and barely
grows with the size of the computation which grants great throughput increase capabilities.
Furthermore, a novel threshold signature scheme is introduced to facilitate authentication of
messages across the Topos ecosystem. Such primitive makes it practical to manage public keys
as, unlike with other threshold signature schemes, the public key remains static for the whole
lifespan of subnets. In addition, we introduced a probabilistic reliable broadcast primitive to
ensure consistent delivery of cross-subnet messages even in the presence of Byzantine actors.
The primitive replaces the classical quorums in favor of stochastic samples while keeping the
per-node communication and computation overhead very small even when the network size
increases. This leads to a massively scalable and high throughput protocol.

Topos is a secure, trustless, and decentralized interoperability protocol with the aim to

realize the vision of an “Internet of Blockchains”.

6 Discussion and Future Work

6.1 Subnet Recovery

Subnets are sovereign networks which can be exposed to network instability, or worse, to
attacks which can threaten their integrity. An example of attack is one leading a supermajority
of consensus participants to be controlled by an adversary. In this situation, an arbitrary state
can be ﬁnalized as part of the canonical chain. Once recovered from the attack, the subnet
can start back from a valid pre-attack state only if it has access to this state. Note that on the
Topos ecosystem level, the subnet can continue to participate only if there was no certiﬁcate
emitted during the attack, otherwise even in the case of a recovery, the subnet would never
be able to emit a certiﬁcate which is valid with respect to the subnet’s history stored on the
TCE.

30

One valuable extension of the Topos protocol can be found in leveraging data availability
on the TCE to oﬀer a recovery feature for any subnet in the ecosystem. Subnets that were
compromised can query the TCE for a proof of availability, retrieve their latest committed
state, and reboot from this state.

TCE nodes store certiﬁcates which from subnets’ transactional data expose only cross-
subnet messages. For a data availability layer on the TCE to allow for subnet recovery,
TCE nodes need to store subnets’ states in clear (preventing subnets to use Topos’s privacy
feature). This leads to having additional data be stored, hence impacts the decentralization of
the TCE network. A naive solution would be to leverage a distributed storage network, e.g.,
IPFS [Ben14], but it is not suﬃcient to simply store the state on it: There is need for a proof
guaranteeing high availability of the storage layer and that the state is actually available.
However, the successive states do not need to be available at all time for it is unnecessary to
keep past data stored on that layer. Only the commitment to the state needs to be stored
permanently on the data availability layer for new participants of the TCE to be able to verify
previous zkSTARKs. Thereby, past states can be completely discarded, only the current state
needs to be stored on the data availability layer.

Eventually, subnets can choose to include their states in certiﬁcates—giving up privacy—or
not [Sta20] and TCE nodes only store the latest state and remove previous ones as new ones
are submitted, keeping storage per subnet constant.

An alternative would be to run a data availability service on a given subnet, e.g., the Topos
Subnet, with an economic incentive to store data, such that the service is well decentralized,
hence minimizing trust in the data availability layer, in the sense that if the Topos Subnet
is available so is the state of other subnets. A drawback of this approach is that past states
cannot be discarded since they are stored on-chain.

6.2 Conﬁdentiality of Cross-Subnet Transactions

Since subnets in the Topos ecosystem are sovereign blockchain networks, they can choose
their level of conﬁdentiality for internal transactions. However, for interoperability trans-
actions between subnets must follow speciﬁc rules. In Topos’s current design, the protocol
speciﬁes proofs of validity of these transactions and authenticity of the certiﬁcates they are
included in but cross-subnet messages are visible in clear in the certiﬁcates. A path for future
improvement is to provide conﬁdentiality for cross-subnet messages without losing existing
properties. There are a few approaches that require substantial research to achieve this goal.
One such approach is to use zkSTARKs for hiding message data.

6.3 Recursive STARKs

As detailed in this paper, the Topos protocol introduces the UCI for subnets to speak a
common language in order to, in ﬁne, exchange data (via certiﬁcates) that is compliant with
the protocol. In the current form of the protocol, certiﬁcates are created when subnets ﬁll
their batch of transactions and create a zkSTARK proving the validity of all transactions of
the batch. Consequently, a subnet in which participants exchange a lot of internal transactions
but submit very few cross-subnet messages will lead to the creation and propagation in the
TCE of certiﬁcates that have little value in terms of interoperability in the ecosystem.

In order to relieve subnets and the TCE from this unnecessary workload, a future im-
provement of the Topos protocol is to leverage recursive zkSTARKs to compose proofs that
are pending for insertion in certiﬁcates and ultimately create certiﬁcates only when subnets
decide they have enough value in certifying some state transition (see Figure 8). Subnets will
batch and prove sets of transactions as currently designed, but will accumulate the proofs and

31

Figure 8: Recursion of STARK proofs

recursively compose them in a single proof for an upcoming certiﬁcate. Eventually, this will
introduce ﬂexibility and allow subnets to devise their own lineup of certiﬁcates.

6.4 Alternative to Topos Subnet

The current Topos solution relies on the Topos Subnet for the following key operations: (i)
subnets registration to the system; (ii) management of the participation in the TCE (for
Sybil Attack mitigation); (iii) TOPOS asset management. Even if the Topos system security
does not fully lean on the Topos Subnet, its failure would incur potential vulnerabilities in
the ecosystem. For that reason we aim in the future at implementing a solution that does
not depend on any dedicated subnet. This means that the three key operations described
above would have to be implemented at the TCE level. Intuitively, all the information totally
ordered in the Topos Subnet would have to be replicated at the TCE level, and in absence of
consensus this information would appear in diﬀerent order to diﬀerent TCE nodes.

However, preliminary research shows that partial ordering of sets of messages is suﬃcient
to implement all three operations. Indeed, all these operations are dependent on a token and
we know that causal reliable broadcast (that the TCE implements) is suﬃcient to implement a
cryptocurrency [GKM+18], even in the case where the reliable broadcast protocol implements
an inﬂation mechanism [KPPT21].

7 Acknowledgements

We would like to thank Sara Tucci-Piergiovanni and Thibault Rieutord at the CEA List and
Robin Salen, Travis Baumbaugh, Alonso Gonzalez, and Hamy Ratonanina, our colleagues at
Toposware for their helpful feedback and reviews which we have incorporated into the current
version of the paper.

References

[ABSB18] Mustafa Al-Bassam, Alberto Sonnino, and Vitalik Buterin. Fraud and data
availability proofs: Maximising light client security and scaling blockchains with
dishonest majorities. arXiv: Cryptography and Security, 2018.

[ACDP+20] L˘acr˘amioara A¸stefanoaei, Pierre Chambart, Antonella Del Pozzo, Thibault Rieu-
tord, Sara Tucci, and Eugen Z˘alinescu. Tenderbake – a solution to dynamic
repeated consensus for blockchains, 2020.

[Alp]

Handan Kilinc Alper.
https://research.web3.foundation/en/latest/polkadot/block-
production/Babe.html. Accessed: 2021-10-11.

Blind assignment

for blockchain extension.

[Ava]

Avalanche bridge. https://bridge.avax.network.

32

[BCC+21]

[Ben14]

[BFLS91]

Lorenz Breidenbach, Christian Cachin, Alex Coventry, Steve Ellis, Ari Juels,
Benedict Chan, Farinaz Koushanfar, Daniel Moroz, Florian Tram`er, Andrew
Miller, Sergey Nazarov, Brendan Magauran, Alexandru Topliceanu, and Fan
Zhang. Chainlink 2.0: Next steps in the evolution of decentralized oracle net-
works. https://research.chain.link/whitepaper-v2.pdf, April 2021.

Juan Benet.
abs/1407.3561, 2014.

Ipfs - content addressed, versioned, p2p ﬁle system. ArXiv,

L´aszl´o Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking
computations in polylogarithmic time. In Proceedings of the Twenty-Third An-
nual ACM Symposium on Theory of Computing, STOC ’91, page 21–32, New
York, NY, USA, 1991. Association for Computing Machinery.

[BSBHR17] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Fast reed-
solomon interactive oracle proofs of proximity. In Electron. Colloquium Comput.
Complex., 2017.

[BSBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable,
transparent, and post-quantum secure computational integrity. IACR Cryptol.
ePrint Arch., 2018:46, 2018.

[BSCG+]

Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian
Miers, Eran Tromer, and Madars Virza. Zerocash: Decentralized anonymous
payments from bitcoin.

[BSCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Suc-
cinct Non-Interactive zero knowledge for a von neumann architecture. In 23rd
USENIX Security Symposium (USENIX Security 14), pages 781–796, San Diego,
CA, August 2014. USENIX Association.

[But]

[But18]

[CGR11]

[CR93]

Vitalik Buterin.
whitepaper/. Accessed: 2021-12-21.

Ethereum whitepaper.

https://ethereum.org/en/

Vitalik Buterin. On-chain scaling to potentially
500 tx/sec through mass
tx validation. ethereum blog. https://ethresear.ch/t/on-chain-scaling-
to-potentially-500-tx-sec-through-mass-tx-validation/3477, Septem-
ber 2018.

Christian Cachin, Rachid Guerraoui, and Lus Rodrigues. Introduction to Reliable
and Secure Distributed Programming. Springer Publishing Company, Incorpo-
rated, 2nd edition, 2011.

Ran Canetti and Tal Rabin. Fast asynchronous byzantine agreement with op-
timal resilience. In Proceedings of the Twenty-Fifth Annual ACM Symposium
on Theory of Computing, STOC ’93, page 42–51, New York, NY, USA, 1993.
Association for Computing Machinery.

[CST]

Brad Cohn, Evan Shapiro, and Emre Teki¸salp. Mina: Economics and monetary
policy. https://github.com/Toposware/cheetah.

[DGKR18] Bernardo Machado David, Peter Gazi, Aggelos Kiayias, and Alexander Rus-
sell. Ouroboros praos: An adaptively-secure, semi-synchronous proof-of-stake
blockchain. In EUROCRYPT, 2018.

33

[Dou02]

John R. Douceur. The sybil attack. In Peter Druschel, Frans Kaashoek, and
Antony Rowstron, editors, Peer-to-Peer Systems, pages 251–260, Berlin, Heidel-
berg, 2002. Springer Berlin Heidelberg.

[FLP85]

Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. Impossibility of
distributed consensus with one faulty process. J. ACM, 32(2):374–382, apr 1985.

[GHM+17] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zel-
dovich. Algorand: Scaling byzantine agreements for cryptocurrencies. In Pro-
ceedings of the 26th Symposium on Operating Systems Principles, SOSP ’17,
page 51–68, New York, NY, USA, 2017. Association for Computing Machinery.

[GKM+18] Rachid Guerraoui, Petr Kuznetsov, Matteo Monti, Matej Pavlovic, and Dragos-
CoRR,

asynchronous trustworthy transfers.

AT2:

Adrian Seredinschi.
abs/1812.10844, 2018.

[GKM+19a] Rachid Guerraoui, Petr Kuznetsov, Matteo Monti, Matej Pavlovic, and Dragos-
Adrian Seredinschi. The consensus number of a cryptocurrency. Proceedings of
the 2019 ACM Symposium on Principles of Distributed Computing, 2019.

[GKM+19b] Rachid Guerraoui, Petr Kuznetsov, Matteo Monti, Matej Pavlovic, and Dragos-
Adrian Seredinschi. Scalable byzantine reliable broadcast (extended version), 08
2019.

[Gro16]

Jens Groth. On the size of pairing-based non-interactive arguments. In Marc
Fischlin and Jean-S´ebastien Coron, editors, Advances in Cryptology – EURO-
CRYPT 2016, pages 305–326, Berlin, Heidelberg, 2016. Springer Berlin Heidel-
berg.

[GRS+21] Alonso Gonz´alez, Hamy Ratoanina, Robin Salen, Setareh Shariﬁan, and
Vladimir Soukharev.
Identiﬁable cheating entity ﬂexible round-optimized
schnorr threshold (ice frost) signature protocol. Cryptology ePrint Archive, Re-
port 2021/1658, 2021.

[GWC19]

Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. Plonk: Permu-
tations over lagrange-bases for oecumenical noninteractive arguments of knowl-
edge. Cryptology ePrint Archive, Report 2019/953, 2019. https://ia.cr/2019/
953.

[HT94]

[Inc19]

[KB]

[KG21]

Vassos Hadzilacos and Sam Toueg. A modular approach to fault-tolerant broad-
casts and related problems. Technical report, Cornell University, 1994.

Forrester Research, Inc. Seize The Day: Public Blockchain Is On The Horizon.
https://assets.ey.com/content/dam/ey-sites/ey-com/en_gl/topics/
blockchain/ey-public-blockchain-opportunity-snapshot.pdf, 2019.

Jae Kwon and Ethan Buchman. A network of distributed ledgers. https:
//v1.cosmos.network/resources/whitepaper. Accessed: 2021-10-10.

Chelsea Komlo and Ian Goldberg. FROST: Flexible Round-Optimized Schnorr
Threshold Signatures, pages 34–65. 07 2021.

[KPPT21] Petr Kuznetsov, Yvonne-Anne Pignolet, Pavel Ponomarev, and Andrei Tonkikh.

Permissionless and asynchronous asset transfer [technical report], 2021.

34

[Kwo14]

Jae Kwon. Tendermint : Consensus without mining. 2014.

[LTKS15]

Loi Luu, Jason Teutsch, Raghav Kulkarni, and Prateek Saxena. Demystifying
incentives in the consensus computer. In Proceedings of the 22nd ACM SIGSAC
Conference on Computer and Communications Security, CCS ’15, page 706–719,
New York, NY, USA, 2015. Association for Computing Machinery.

[Mon]

Private, decentralized cryptocurrency that keeps your ﬁnances conﬁdential and
secure. https://www.getmonero.org.

[MXC+16] Andrew Miller, Yu Xia, Kyle Croman, Elaine Shi, and Dawn Song. The honey
badger of bft protocols. In Proceedings of the 2016 ACM SIGSAC Conference
on Computer and Communications Security, CCS ’16, page 31–42, New York,
NY, USA, 2016. Association for Computing Machinery.

[Nak08]

Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008.

[Ora]

[Ped91]

[Pol]

[RS60]

[RZ21]

[Sch90]

What is the blockchain oracle problem? https://blog.chain.link/what-is-
the-blockchain-oracle-problem/. Accessed: 2021-12-21.

T. P. Pedersen. Non-interactive and information-theoretic secure veriﬁable secret
sharing. In CRYPTO’91, page 129–140, 1991.

Polygon pos bridge. https://wallet.polygon.technology.

I. S. Reed and G. Solomon. Polynomial codes over certain ﬁnite ﬁelds. Journal
of the Society for Industrial and Applied Mathematics, 8(2):300–304, 1960.

Caleb Banister Ryan Zarick, Bryan Pellegrino. Layerzero: Trustless omnichain
interoperability protocol, May 2021.

C. P. Schnorr. Eﬃcient identiﬁcation and signatures for smart cards. In Gilles
Brassard, editor, Advances in Cryptology — CRYPTO’ 89 Proceedings, pages
239–252, New York, NY, 1990. Springer New York.

[SKK20]

Alistair Stewart and Eleftherios Kokoris-Kogia. Grandpa: a byzantine ﬁnality
gadget, 2020.

[SLBS20]

Kevin Sekniqi, Daniel Laine, Stephen Buttolph, and Emin G¨un Sirer. Avalanche
platform, 2020.

[Sol]

[SSS22]

[Sta20]

Solana: A new architecture for a high performance blockchain. https://solana.
com/solana-whitepaper.pdf. Accessed: 2021-12-21.

Robin Salen, Vijaykumar Singh, and Vladimir Soukharev. Security analysis of
elliptic curves over sextic extension of small prime ﬁelds. Cryptology ePrint
Archive, Report 2022/277, 2022.

Volition and the

StarkWare.
https://medium.com/starkware/volition-and-the-emerging-data-
availability-spectrum-87e8bfa09bb, June 2020. Accessed: 2021-12-20.

emerging data availability spectrum.

[Sub]

Substrate: The platform for blockchain innovators.
paritytech/substrate.

https://github.com/

[Woo16]

Gavin Wood. Polkadot: Vision for a heterogeneous multi-chain framework, 2016.

35

[Wor]

One integration to rule them all. https://wormholenetwork.com.

[YMR+18] Maofan Yin, Dahlia Malkhi, Michael K. Reiter, Guy Golan Gueta, and Ittai
Abraham. Hotstuﬀ: Bft consensus in the lens of blockchain, 2018.

36

A STARK Proof System

A.1 Assumptions

The only assumption required by STARK proof systems is that the hash functions to be used
for commitments are collision-resistant. This allows for simpler, leaner, post-quantum and
trustless proving systems than other SNARK systems.

A.2 Prover

The STARK proof construction can be decomposed into four stages.

Algebraic Intermediate Representation (AIR). First there is need for an algebraic
representation of the problem. Consider the set P of the multivariate polynomials Pi in
variables X and Y, P = {P1(X, Y), . . . , Ps(X, Y)} , where X = (x1, · · · xk) and Y = (y1, · · · yk)
represent the states of the current and next computation respectively. That is, for two correct
vectors X, Y, we have that X, Y is a correct solution for the system P, i.e. P1(X, Y) = . . . =
Ps(X, Y) = 0. For eﬃciency of both prover and veriﬁer, we need minimal AIR, which is
minimizing:

1. deg(P)= max (deg(P1), · · · , deg(Ps));

2. k, the state-width;

3. |P| = s;

4. c, the machine cycle count (that may depend in general on arbitrary input, but is here

linear in the size of the input set).

To be able to extend and commit to the trace eﬃciently, the number of steps is increased

so that the number of rows reaches the next power of 2, T , for eﬃcient FFTs.

We often talk of execution trace for a program, which can be seen as a T × k matrix in

which:

• each row is describing the state of the computation at a given step;

• each column tracks a the content of a register over time.

Extension of the trace and commitment. We can view any column of the execution
trace as a polynomial over a certain domain (generated by g ∈ F). We can then consider the
same polynomial over the domain S = (cid:104)ω(cid:105), where ω is a root of g. This is referred to as the
Low Degree Extension [BFLS91]. The evaluation of a column polynomial f on S makes a code
word of a Reed-Solomon code [RS60] of some rate ρ (ρ = 1/β with β the ratio between the
original trace domain and the augmented LDE domain). That is, f ∈ RS[F, S, ρ]. To prevent
forging of proofs, it is important that the prover cannot change these values later on. Rather
than sending all of these points (since we want succinctness and zero knowledge), the prover
creates a commitment to the values with a Merkle tree structure (the leaves being a grouping
of evaluations of all the polynomials at a given LDE point). The commitment, along with the
public inputs as part of the AIR program, is used to seed a public coin to allow drawing of
random values to make the protocol non-interactive with the Fiat-Shamir heuristic.

• If RAPs (see below) are being used, auxiliary trace segments can be computed after

the previous trace portion has been committed to.

37

Constraint composition polynomial and consistency proof. Similarly, the con-
straint polynomials Pi may be composed with the column polynomials (fi for i = 1, . . . , n)
and evaluated at the points of the LDE. However, instead of creating separate evaluations
for each constraint, random coins are drawn and used to create a random linear combination
of the constraint polynomials. In this combination, the degrees of all constraint polynomials
are augmented to all be D (the next power of 2 following the maximum degree). Due to
its higher degree, more coeﬃcients are needed to specify it. These are arranged in several
columns (H1, . . . , HD), which are committed to analogously to the trace polynomials. This
commitment is once again used to seed the randomness, and from this a random out-of-domain
point z is sampled. The prover then provides the values necessary to evaluate the constraint
composition polynomial in two ways: directly through the column values Hi committed to,
and indirectly by evaluating the constraint polynomials at the corresponding points of the
trace polynomials and performing the same linear combination as before. These values are
added to the proof and the randomization of the public coin.

Fast RS Interactive Oracle Proof of Proximity (FRI). The underlying idea of FRI
[BSBHR17], is to apply a similar degree-reduction to what’s happening during the Inverse
Fast Fourier Transform (splitting a polynomial in two instances over even and odd powers of
a variable), and bind prover’s responses in these reductions by evaluations of the function f
over points of the subset S. More formally, if we can represent S as (cid:104)ω(cid:105) (s.t. ω generates a
multiplicative group of order 2k) and the function f (0) : S → F to be the function known by
the prover of degree d ≤ ρ|S|. The veriﬁer will sample a random x(0), and ask the prover to

ρ|S|
2

ρ|(cid:104)ω2(cid:105)|
2

compute f (1) = f0 + x(0)f1, where f (1) will have degree ≤
for any x chosen by
the veriﬁer. Here, f0, f1 are two polynomial functions such that f (0)(x) = f0(x2) + xf1(x2).
That is, they are functions (cid:104)ω2(cid:105) → F with interpolants Pf0, Pf1 which are used to compute
the original interpolant of f (0). If f (0) is δ-far from RS[F, S, ρ], then the resulting f (1) will be
δ(cid:48)-far for some δ(cid:48) ≤ δ. This process is repeated for a number of layers until the polynomial f ((cid:96))
is reached which should be constant (or of low enough degree that it can be checked directly
in constant time).

=

If the original f (0) was far from any polynomial in RS[F, S, ρ], then (with high probability)
f ((cid:96)) is not constant. This property of FRI is used to succinctly prove that a certain polynomial
is of low degree. That polynomial is known as the DEEP composition polynomial (from
Domain Extension for Eliminating Pretenders). It is a polynomial constructed to be of low
degree only if the values previously supplied by the prover (for evaluation of the constraint
composition polynomial) are consistent with the polynomials previously committed to. Due
to its structure, low-degreeness of the DEEP composition polynomial also implies that the
trace polynomials and column polynomials for the constraint composition are of suitably low
degree.

A.3 Veriﬁer

To verify a proof given by a prover, the veriﬁer must perform the following steps.

1. Read the commitment to the execution trace over the LDE domain, updating the pub-
lic coin and drawing from it random coeﬃcients used by the prover to compute the
composition polynomial.

• If RAPs (see below) are being used, intermediate random coins (for use in per-
mutation arguments) are drawn after the previous columns have been committed
to.

38

2. Read the commitment to the constraint composition polynomial evaluations (over the
LDE domain), use that to update the public coin, and sample the out-of-domain point
z.

3. Evaluate the constraints at the provided out-of-domain point z based on prover-supplied
trace values. Compute the evaluations of the constraint composition polynomial at the
same point from the column values. Check for consistency between values. Reseeding
is done after each read.

4. Perform the FRI protocol: Draw coeﬃcients for computing the DEEP composition
polynomial and instantiate a FRI veriﬁer for the layer commitments provided in the
channel. Draw query positions for the LDE domain, read the evaluations of the trace
and constraint polynomials at those positions. Use those to compute evaluations of the
DEEP composition polynomial and verify that these are from a low-degree polynomial.

A.4 Randomized Air with Preprocessing (RAPs)

An additional feature desired for eﬃciency in STARKS is known as Randomized Air with
Preprocessing (RAP). With RAPs, additional columns of the trace are committed to with
access to random coins based on the original columns. This allows use of the Schwarz-Zippel
lemma to show that, for instance, two columns are permutations of each other. This can be
done by checking

n
(cid:89)

n
(cid:89)

(ai + γ) =

(bi + γ),

i=1

i=1

where ai and bi are the i-th entry in each column, and γ is randomly chosen after those values
have been comitted to. With high probability, this only holds if the two sets {ai} and {bi} are
permutations of each other [GWC19]. By supplying a known permutation σ to the veriﬁer,
they can run a check that

n
(cid:89)

(ai + αωi + γ) =

n
(cid:89)

(ai + αωσ(i) + γ)

i=1

i=1

(where α is randomly chosen along with γ), which indicates that ai = aσ(i) for all i = 1, . . . , n.
This is useful for enforcing equality over great distances in the execution trace, and is referred
to as copy constraints with RAPs.

B ICE-FROST Signature

The ICE-FROST protocol [GRS+21] is our own adaptation of the FROST protocol [KG21].
The goal is to allow a subnet to generate signatures with a t-out-of-n threshold in a decen-
tralized environment without any single trusted or semi-trusted party, and in the potential
presence of malicious actors. Compared to the original FROST, our construction makes the
key generation robust: enough honest actors can agree on the group’s public key even in
presence of malicious parties and without any rerun. In addition, honest actors can reliably
identify misbehaving participants and exclude them from the scheme. At any point of time,
honest actors maintain the same list of honest participants and can ignore any message from
other parties.

For completeness, below is the detailed summary of the protocol.

39

B.1 Assumptions

• G is a group of prime order q in which the DDH problem is hard. g is a generator of

that group.

• The threshold t and the n participants are chosen by the subnet.

• Each participant has or receives a unique id.

• Each participant has access to a broadcast function. Each message published using

broadcast is automatically signed and available to everyone.

• Each participant Pi is given an index i between 1 and q − 1. For simplicity we assume
that the n participants receive indices 1 to n but we only need them to be unique and
non-zero.

• Honest participants want to sign a message m agreed upon externally to the scheme.

B.2 Key Generation phase

Let H be a hash function whose output is in Z∗
q. Let Enc and Dec be symmetric encryption
and decryption functions. Let K be a key derivation function compatible with Enc and Dec.

Round 1

1. Every participant Pi samples t random values (ai0, ..., ai(t−1))

values as coeﬃcients to deﬁne a degree t − 1 polynomial fi(x) = (cid:80)t−1

j=0 aijxj.

$← Zq, and uses these

2. Every Pi computes a proof of knowledge to the corresponding secret ai0 by calculating
σi = (Ri, µi), such that k $← Zq, Ri = gk, ci = H(i, Φ, gai0, Ri), µi = k + ai0.ci, with Φ
being a context string to prevent replay attacks.

3. Every Pi samples ski randomly and computes pki = gski.

4. Every Pi computes a proof of knowledge to the secret key ski by calculating τi = (Si, νi),
such that k $← Zq, Si = gk, di = H(i, Φ, pki, Si), νi = k + ski.di, with Φ being a context
string to prevent replay attacks.

5. Every participant Pi computes a public commitment

gaij , 0 ≤ j ≤ t − 1.

6. Every Pi broadcasts

−→
Ci, σi, pki, τi.

−→
Ci = (cid:104)φi0, ..., φi(t−1)(cid:105), where φij =

7. Upon receiving

−→
Cl, σl, pkl, τl from participant 1 ≤ l ≤ n, l (cid:54)= i, participant Pi veriﬁes
?= gµl.φ−cl
l0 , where cl = H(l, Φ, φl0, Rl), and τl = (Sl, νl)
, where dl = H(l, Φ, pkl, Sl). On failure, Pi broadcasts

σl = (Rl, µl) by checking Rl
?= gνl.pk−dl
by checking Sl
(malicious, Pl) and excludes Pl from its list of participants.

l

8. If the number of remaining participants for Pi is below a certain value decided by
the subnet, the key generation is aborted. If not, the remaining participants advance to
Round 2. For simplicity, we will still refer to the remaining participants as Pi (i ∈
),
1, n
(cid:75)
(cid:74)
even though some may have been eliminated at the last step of Round 1.

Round 2

40

1. Each Pi does the following. For each Pl, l (cid:54)= i:

• Compute a Diﬃe-Hellman key dhkil = pkski
• Encrypt eil = Enckil(fi(l)).
• Broadcast ((i, l), eil).

l

and a symmetric key kil = K(dhkil).

2. Upon receiving ((l, i), eli) from participant 1 ≤ l ≤ n, l (cid:54)= i, participant Pi does the

following:

• Compute dhkli = pkski
• Decrypt δ = Deckli(eli).
• Verify the share by checking gδ ?= (cid:81)t−1

and kli = K(dhkli).

l

k=0 φik mod q

lk

the procedure complain.

. If the share is incorrect, initiate

3. Participants resolve all complaints with the procedure exclude. If the number of re-
maining participants is below a certain value decided by the subnet, the key generation
is aborted. For simplicity, we will still refer to the remaining participant as Pi (i in
), even though some may have been eliminated at the previous step.
1, n
(cid:75)
(cid:74)
4. Each Pi calculates their long-lived private signing share by computing si = (cid:80)n

l=1 fl(i),

stores si securely, and deletes each fl(i).

5. Each Pi calculates their public veriﬁcation share Yi = gsi, and the group’s public key Y =
j=1 φj0. Any participant can compute the veriﬁcation share of any other participant

(cid:81)n

by calculating Yi =

n
(cid:89)

t−1
(cid:89)

j=1

k=0

φik mod q
jk

. Each Pi then broadcast Y .

complain(i, l)

1. Pi computes a proof that dhkil is well-formed, which is a proof of knowledge of ski such
. To do so it proceeds as follow:

that (pki, pkl, kil) is of the form pki = gski, kil = pkski

l

• It computes A1 = gr, A2 = pkr
• It computes z = r + h.ski.
• The proof is π = (A1, A2, z).

l , where r $← Zq and h = H(pki, pkl, kil, A1, A2).

2. Pi broadcasts the message (complaint, Pi, Pl, kil, π)

exclude(complaint, Pi, Pl, kil, π)

1. Verify the proof by checking A1.pkh
i

?= gz, A2.kh
l where π = (A1, A2, z) and h =
il
H(pki, pkl, kil, A1, A2). If the proof is valid, go to step 2. Else, broadcast (malicious, Pi),
exclude Pi from the list of participants and terminate the procedure.

?= pkz

2. If there is an entry ((l, i), eli) published by Pj, go to step 3. Else, broadcast (malicious, Pi),

exclude Pi from the list of participants and terminate the procedure.

3. Compute δ = DecK(kil)(eli). Verify the decrypted share by checking gδ ?= (cid:81)t−1

k=0 φik mod q
.
If the share is correct, broadcast (malicious, Pl) and exclude Pi from the list of partici-
pants. Else, broadcast (malicious, Pl) and exclude Pl.

lk

41

B.3 Signing phase

We assume that a key generation phase has been successfully completed. The n remaining
participants now each hold a secret share, and the group’s public key is Y . Let H1, H2 be
hash functions whose outputs are in Z∗
q.

Round 1

1. The subnet selects randomly S ⊂

, |S| = s, s ≥ t the index of signing participants.
1, n
(cid:75)
(cid:74)
The signing participants are Pi, i ∈ S.

2. Each Pi, i ∈ S, samples single-use nonces (di, ei) $← Z∗

q × Z∗
q.

3. Each Pi broadcasts (Di, Ei) where Di = gdi and Ei = gei.

Round 2

1. Each Pi constructs B = (cid:104)(l, Dl, El)(cid:105)l∈S, computes the binding values ρl = H1(l, m, B),
l∈S Dl.(El)ρl and the challenge c =

l ∈ S, then derives the group commitment R = (cid:81)
H2(R, Y, m).

2. Each Pi computes their response using their long-lived secret share si by computing

zi = di + (ei.ρi) + λi.si.c using S to determine the ith Lagrange coeﬃcient λi.

3. Each Pi deletes (di, Di, ei, Ei) from their local storage, and then broadcasts zi.

4. Each Pi does the following:

• Upon receiving zl from participant Pl, l ∈ S, l (cid:54)= i, verify the validity of the
. On failure, broadcast (malicious, Pl), exclude

response by checking gzl
Pl from the list of participants and go to step 5.

?= Rl.Y c.λl

l

• If all responses are correct, compute the group’s response z = (cid:80) zi.
• Broadcast the signature σ = (R, z) along with m and terminate the procedure.

5. If no signature has been generated and some participants have been excluded, go back
to round 1 step 2 with the same S minus the excluded participants. If the resulting set
has less than t members, abort the signature generation.

C WCPRB Proof of Correctness

Theorem 1. Algorithm 4 solves Weak Causal Probabilistic Reliable Broadcast.

Proof sketch. To prove that Algorithm 4 solves Weak Causal Probabilistic Reliable Broadcast
we prove that all the properties are satisﬁed. For readability we recall for each property its
deﬁnition.

• No duplication: No correct process delivers more than one message. The proof follows
from the No duplication property of the PRB and from the fact that when a message is
wcprb.Delivered, it is removed from the pending set.

• Integrity: If a correct process delivers a message m, and the sender p is correct, then m
was previously broadcast by p. The proof follows from the No integrity property of the
PRB. In fact, in Algorithm 4, to be delivered, a message was necessary prb.Delivered
by PRB.

42

• (cid:15)-Validity: If the sender p is correct, and p broadcasts a message m, then p eventually
delivers m with probability at least (1 - (cid:15)). The proof follows from the (cid:15)-Validity property
of the PRB and considering the following:

– If p broadcasts m then Valid(m) = true at time t and p prb.Broadcast(m). Since
∀t(cid:48) ≥ t, Valid(m) = true, then by the (cid:15)-Validity of the PRB, p prb.Delivers message
m, therefore, m is placed in pendingp and being valid it will be removed from
pendingp and wcprb.Delivered by p.

• (cid:15)-Consistency: Every correct process that delivers a message delivers the same message
with probability at least (1 − (cid:15)). The proof follows from the (cid:15)-Consistency property of
the PRB.

• (cid:15)-Totality: If a correct process delivers a message, then every correct process eventually

delivers a message with probability at least (1 − (cid:15)).

– If pi delivers m then pi prb.Delivers m and Valid(m) = true. If pi prb.Delivers m
then by the (cid:15)-Totality of the PRB, every other correct process pj prb.Delivers m
and place it in pendingj with probability (1 − (cid:15)). We now have to prove that the
message m in pendingj will be eventually delivered, i.e., Valid(m) = true at pj.
If Valid(m) = false at pj at that time, it means that pj has not yet delivered the
messages delivered by pi with which Valid(m) = true. Thanks to the (cid:15)-Totality of
PRB, pj will eventually prb.Deliver the same set of messages that pi prb.Delivered,
at that time, Valid(m) = true, and then pj will wcprb.Deliver m.

• Weak causal order: If a correct process p wcprb.Delivers a message m then m weakly
casually precedes all the previously wcprb.Delivered messages. The proof simply follows
from the deﬁnition of the Valid predicate and the check on Valid(m) before triggering
wcprb.Deliver(m).

43

