1
2
0
2

v
o
N
7
1

]

R
C
.
s
c
[

2
v
4
4
5
6
0
.
1
1
1
2
:
v
i
X
r
a

A lightweight blockchain-based access control scheme for
integrated edge computing in the internet of things

Zhang Jiea, Yuan Lingyuna,b,∗, Xu Shanshana,c

aSchool of Information,Yunnan Normal University,Kunming,650500,China
bKey Laboratory of Educational Information for Nationalities,Ministry of Education,Yunnan Normal
University,Kunming,650500,China
cGIS Technology Research Center of Resource and Environment in Western China,Ministry of Education,Yunnan
Normal University,Kunming,650500,China

Abstract

In view of the security issues of the Internet of Things (IoT), considered better combining
edge computing and blockchain with the IoT, integrating attribute-based encryption (ABE) and
attribute-based access control (ABAC) models with attributes as the entry point, an attribute-
based encryption and access control scheme (ABE-ACS) has been proposed. Facing Edge-Iot,
which is a heterogeneous network composed of most resource-limited IoT devices and some
nodes with higher computing power. For the problems of high resource consumption and diﬃcult
deployment of existing blockchain platforms, we design a lightweight blockchain (LBC) with
improvement of the proof-of-work consensus. For the access control policies, the threshold
tree and LSSS are used for conversion and assignment, stored in the blockchain to protect the
privacy of the policy. For device and data, six smart contracts are designed to realize the ABAC
and penalty mechanism, with which ABE is outsourced to edge nodes for privacy and integrity.
Thus, our scheme realizing Edge-Iot privacy protection, data and device controlled access. The
security analysis shows that the proposed scheme is secure and the experimental results show
that our LBC has higher throughput and lower resources consumption, the cost of encryption
and decryption of our scheme is desirable.

Keywords:
Lightweight blockchain, Edge Computing, Internet of thinges, Access control, Attribute-based
encryption, Security

1. Introduction

With the rapid development of modern information technology, mankind is moving towards
the era of Internet of Everything, of which the Internet of Things (IoT) is the key technology. It
is estimated that there will be more than 41 billion IoT devices by 2027, which is far up from
about 8 billion in 2019 [1]. Another prediction [2] shows that by 2025, IoT devices will generate

∗Corresponding author.
Email addresses: zhangjie@user.ynnu.edu.cn (Zhang Jie), blues520@sina.com (Yuan Lingyun),

xushanshan@user.ynnu.edu.cn (Xu Shanshan)

Preprint submitted to Information Sciences

November 18, 2021

 
 
 
 
 
 
approximately 90 ZB of data worldwide. Too much data and devices will be exposed and security
is still the problem. Access control is the key technology to protect the data and device safety.[29]

Compared with other traditional access control models, Attribute-Based Access Control (ABAC)

model [18] may be the most suitable for IoT.[29] ABAC grants the access control to the resource
(called Object) according to the attributes, which are characteristics that deﬁne speciﬁc aspects
of the subject, object, environment conditions, and/or requested actions that are predeﬁned and
preassigned by an authority, presented by a target (called Subject).[18] Therefore it has the abil-
ity to provide more ﬂexible, scalable, secure and ﬁne-grained control for the access request by
each IoT device.[9]

However, the distributed architecture of the IoT makes ABAC, where access rights granted
by one centralized entity are not suitable. In recent years, some studies have applied blockchain
technology (BT) [25] to realize the distributed access control of the IoT. Blockchain is an dis-
tributed, trustless, and secure peer-to-peer (P2P) network, storing data (such as transaction infor-
mation) by the consensus algorithm in blocks and through hash digests to link them sequentially,
in which every single node is equal and has the whole data in the blockchain network.[26] With
the smart contracts (executable codes that reside in the blockchain), distributed and trustworthy
access control can be achieved.[44]

Blockchain based access control can achieve decentralized security but the computational
overhead involved is unacceptable for resource-constrained IoT devices.[34] At the same time, if
the access of a large number of heterogeneous devices, which generates a large amount of data to
be processed in a short time and is simultaneously transmitted to the data center (such as cloud)
through the network, and network delay will be inevitable.[30] So the edge computing model for
computing the massive amounts of data generated by IoT devices (Edge-Iot) came into being.
By putting the computing at the proximity of data sources (edge) and accomplishing tasks such
as computing oﬄoading, data storage, caching and processing to solve these problems.[35]

At the one hand, by running the blockchain at the IoT edge node, the computing overhead is
solved [40] and the access control is realized at the same time, at the other hand, data security
such as integrity and privacy protection are not completely solved. Cryptology may be a good
way to provide data protection. Attribute-Based Encryption (ABE) [32] was a particular formu-
lation in which data providers will provide a predicate f () in which a formula over the set of
string χ called ”attributes” to achieve the data encryption, only the user with the suitable χ can
decrypt a ciphertext encrypted with predicate f (). Ciphertext-Policy Attribute-Based Encryption
(CP-ABE) scheme [5] was a public-key encryption scheme based on bilinear pairing and access
construction. It is considered as the most suitable technology for providing IoT with data conﬁ-
dentiality and ﬁne-grained access control, for it enables the data owners to deﬁne ﬂexible access
policy [11].

Inspired by these studies, we attempt to introduce the blockchain technology and edge com-
puting to address the limitations of IoT access control. Firstly, aiming at the Edge-Iot, current
common blockchains such as Bitcoin[25], Ethereum[10], Fabric[20], the high resource occupa-
tion, diﬃcult in deployment and expansion involved are defective for safe and controllable IoT
data access and equipment management, we designed a lightweight blockchain called LBC. The
section.7.2 illustrates the comparison result of our LBC and other blockchains. By our LBC,
we refer [44] to the implementation of the ABAC model based on smart contracts (SC), called
SC-ABAC.

Secondly, based on the CP-ABE, we combine it with ABAC to propose ABE-ACS (Attribute-
based encryption and access control scheme, ABE-ACS). We abstract the attributes in ABE and
ABAC to achieve the combination of the two, expose the converted access and decrypt policy into
2

the chain and the computationally expensive operations involved during encryption & decryption
phases of CP-ABE are outsourced to edge nodes. Based on ABE-ACS, even if the access policy is
matched, the access is still encrypted data, and the attributes must be matched before decryption
can be used to obtain the data itself. In contrast, access to the device can only be achieved by
matching subject attributes and access policies.

Finally, we implement LBC based on node.js and deployed our LBC on a set of distributed
physical machines to simulate the real Edge-Iot environment. By the way that edge nodes act
as terminal devices, we conduct thorough experiments based on real data to demonstrate that
the proposed ABE-ACS can protect the security of data and provide the devices controllable in
practice.

The evaluation results show that for successful access to data and equipment, thought ABE-
ACS, LBC achieves a 300-fold increase in throughput compared to another blockchain under the
same conﬁguration,and successful matching the access policy and signature veriﬁcation with 3
times throughput improvement, penalty mechanism after matching failure (100 times through-
put improvement). At the same time, through edge computing, in terms of data encryption and
decryption, the time costs of diﬀerent sizes of data under diﬀerent numbers of attributes is ap-
proximately constant, at the millisecond level, which meets the low latency requirements.

Our contributions are summarized as follows:

. We propose a lightweight blockchain called LBC, based on smart contracts we called SC-

ABAC to provide secure and controlled access for Edge-Iot.

. We construct an attribute-based encryption and access control scheme called ABE-ACS, where
through edge computing and blockchain technology, ABE-ACS realizes controllable IoT de-
vices and secure data access.

. We extensively perform experiments using actual IoT heterogeneous devices and data on dif-

ferent platforms. We examine and provide insights on the access control.

2. Related work

In this section, we present an overview of the existing research on blockchain-based access
control for IoT, and introduce related research on IoT data access control and security with inte-
grated edge computing.

2.1. Blockchain in IoT for access control

With the rapid development in IoT technology, it is not only more important but also more
urgent to address secure data access and device management. By leveraging the tamper-proof, ac-
cessibility feature and decentralized consensus mechanism of blockchain technology, this prob-
lem can be solved. Blockchain technology is ﬁrst proposed by Satoshi Nakamoto [25] in 2008
as a decentralized P2P trading platform. Such as Bitcoin [25], Ethereum [10] , Fabric [20] are
three of the most famous blockchain platform. In recent years, several studies and works have
been made to use BT for access control in IoT.

Ouaddah et al.[28] for the ﬁrst time used BT to implement access control for the IoT, pro-
posed a framework called ”FairAccess”. In ”FairAccess”, access tokens are regarded as resource
access rights, and access control conditions are met by transferring access tokens, the access
token or resource policy is expressed in script language and publicly broadcast to the blockchain
network to realize veriﬁcation and transaction conﬁrmation. By using a Raspberry Pi 2 board

3

with camera as a resource to control access, it demonstrates the usefulness in IoT. However,
excessive transaction conﬁrmation and waiting time are still a problem.

Novo [26] for the ﬁrst time used smart contract to implement access control of the IoT, by
creating a single smart contract to deﬁne all the operations allowed policy rules. By using a set
of virtual devices to call a smart contract to return access control results under mutual requests.
Zhang et al.[44] used three smart contracts to implement access control of the IoT. Diﬀerent
from Nove[26], Zhang[44] use diﬀerent smart contracts to implement diﬀerent functions of ac-
cess control and implementing with real IoT devices. However, neither of them describes the
implementation details of access control.

Maesa et al.[12] for the ﬁrst time to implement ABAC through the blockchain, ABAC strate-
gies are created through scripting language and stored in the chain, and decentralization is
achieved by the blockchain transaction strategy. On this basis, Maesa et al.[13] converted the
logic represented by the ABAC strategy written by eXtensible Access Control Markup Language
(XACML, a language is currently available for writing ABAC policies) [27] into a smart contract
to implement the attribute access strategy and deploy it in the blockchain. However, Maesa only
gives an implementation plan, and does not implement it in a speciﬁc scene.

Zhang et al.[45] aimed at device access control and converted the access policy based on
device attributes into an access tree structure to achieve collaborative access. By giving the time-
consuming of signature authentication, encryption and decryption of terminal equipment and
authentication nodes, as well as the computing overhead of the equipment itself, it proves that
the collaborative access control scheme is suitable for IoT devices. However, each access to the
device causes the target device to store the keys of both parties, which causes a large storage
overhead when multiple devices access a certain device.

Liu et al.[23] proposed an open-source access control system called ”Fabric-iot”. In ”Fabric-
iot”, resources are uploaded to the cloud and a url is generated. The user requests the url from
”Fabric-iot”, among them, the smart contract realizes the function of judging, adding and deleting
user attributes and access policies. The processing time is obtained by simulating concurrent
access to three smart contracts with multithreaded clients. But for ”Fabric-iot”, its processing
time is greatly aﬀected by the network where the concurrent node is located ﬂuctuations.

Sun et al.[37] aimed at the problem of accessing cross-domain data in the IoT, introduced the
policy decision point (PDP) and policy information point (PIP) in ABAC to obtain and judge the
compliance of the access request and the attribute, and ﬁnally reached a consensus mechanism
for execution. The time-consuming judgment and communication are obtained by simulating the
access between diﬀerent domains. However, in the access request process, the judging mecha-
nism for the repeated joining of the same node in the domain is not considered, and there is a
problem of illegal data access.

Song et al.[36] proposed an access control framework called ACF, which uses smart contracts
to call traditional access control lists to solve the reliable management of IoT nodes in the supply
chain, designs a penalty mechanism under frequent calls to control resources eﬀectively use. By
using two blockchain technologies to complete the experimental evaluation. However, access
control list is weak to the access control ability, unable to realize ﬁne-grained access control.

Diﬀerent from the above research, Ding et al.[8] takes attributes more as the key to access
control, using elliptic curve cryptography (ECC) to create public and private key pairs for IoT
devices, and encrypting their respective attributes into the blockchain. Access is exchanged
through a symmetric key algorithm for access policies, and the access authority is conﬁrmed
by the attributes disclosed on the chain. But to establish a one-to-one connection inevitably
increases the communication cost.

4

In summary of the related research, the use of smart contracts can make the implementation of
access control more ﬂexible, and the use of the ABAC model can achieve ﬁner-grained access.
However, it is worth noting that some blockchain platforms still use centralized Certiﬁcation
Authority (CA) to achieve authentication, making the distribution incomplete. Second, most
access control mechanisms only return permission or denial, which does not solve illegal access.
In addition, most access control is only for the data itself, but it is more important to forget that
restricted devices that are safe and controllable are more important.

2.2. CP-ABE in IoT for data security

Sensitive data in the network needs to be secured, and ABE [32] allows the data owner to
deﬁne an access policy to encrypt the data, and it can be decrypted only if the policy is met.
CP-ABE [5] regards the access policy as the key to encryption, and the visitor generates the
corresponding private key based on his own attributes to decrypt. By setting a suitable attribute
policy, after encrypting once, the attribute set of multiple users can by decrypted successfully
if they matches the policy. However, a large number of resource-limited devices in the IoT
environment can not realize the expensive operation in CP-ABE, the main idea of related works
is to outsource the computing process to the cloud or edge node.

Cui et al.

[7] proposed a proxy-aided ciphertext-policy ABE (PA-CPABE) outsourcing
scheme, which divides the original attribute encryption keys in CP-ABE into public conver-
sion keys (ciphertext conversion by the edge) and the private key of the data owner ensures the
security of the key. However, the user’s decryption needs to request the cloud ﬁrst, and then send
it to the nearby edge node for initial decryption and then hand it over to the user for secondary
decryption, which has high latency and high computational consumption.

Zhang et al.[43] proposed an outsourcing and attribute update scheme based on fog nodes.
The fog node is used to implement data encryption and decryption by downloading the key
and part of the user’s key from the cloud. The user only needs to verify and execute it on the
resource-constrained device to prove that the computational cost is low. However, the attribute
update requires re-encryption of the data, which has high computational consumption.

Fan et al.[11] proposed an eﬃcient and privacy preserving outsourced multiauthority access
control scheme (PPO-MACS) to hide and revoke access policies. User attributes are generated
by a one-way hash function, the cloud deletes the stored proxy key after decryption, and the fog
node implements outsourcing decryption and veriﬁcation. However, the security of the fog node
itself is unknown, and there is a risk of malicious nodes returning incorrect data.

Li et al.[22] aimed at the problem of attribute duplication in the multi-user access of the
IoT, based on the Zhang et al.[43] and Fan et al. [11] proposed the users and attributes of the
the revocation. It is also cheaper to perform proof calculations on resource-constrained devices.
However, users can request all ciphertexts from the cloud through the fog node, and there may
be a risk of original data leakage.

Aiming at the existing CP-ABE scheme that cannot achieve attribute revocation, attribute
addition, outsourcing calculation, and authorization concentration, Sarma et al.[33] proposed the
PAC-FIT scheme. The user holds a key with the same size. Aﬀected by the number of attributes,
the size of the encrypted and decrypted message sent by the user is constant, and the time con-
sumed for encryption and decryption is constant. However, it has not been compared with related
researches in the same period, and its program performance does not have high credibility. For
example, Tu et al.[38] also realized attribute revocation and outsourcing calculations. But for
the problem of centralized authorization, Tu et al.[38] adopted multi-authority attribute encryp-

5

tion (MA-ABE), that is, diﬀerent authorization agencies control diﬀerent attribute sets. But the
comparison of computing performance is also not credible.

Most of the current solutions have too many fully trusted entities such as the Key Generation
Center (KGC), Central authority (CA), Attribute manager, etc., so there is a single point of failure
and exist the crisis of trust. However, the introduction of trustless blockchain in combination with
CP-ABE is mostly used for data privacy protection.

Hsu et al.[17] designed a log protection system based on a private signature chain to CP-ABE,
sign and verify data, and store user access records in response to log privacy issues generated by
IoT devices. However, the blockchain veriﬁes the signature for each ciphertext generated before
storing it in the block, which causes higher calculation and storage costs.

Guan et al.[16] proposed privacy-preserving blockchain energy trading scheme (PP-BCETS)
in response to the privacy problem of energy decentralized transactions. CP-ABE realizes the
privacy protection of transactions, and the blockchain realizes the controllability of decentral-
ized transactions. However, decentralized transactions bring higher computational costs and
communication delays.

Qin et al.[31] for the calculation and communication costs caused by veriﬁcations of the CP-
ABE outsourcing result, the user uses its attribute token as input to call the smart contract to
calculate and verify the result, return the corresponding address to access. After decrypting the
data, designing credibility and access records to ensure the data reliable access. However, its
high latency and computational time are not suitable for large-scale real-time IoT.

Yang et al.[41] aimed at the secure sharing of smart grid data, through smart contracts in the
blockchain to call edge nodes to implement CP-ABE outsourcing calculations, and use consen-
sus algorithms to ensure correct decryption and secure data sharing. It also gives the eﬀective
accountability mechanism for the reliability of edge node calculation results. Our work is partly
similar to Yang et al.[41]. The diﬀerence is that our method is more IoT-oriented access con-
trol, thinking that CP-ABE cannot achieve access control of devices, and the devices in the IoT
are equally important, so we design that through SC-ABAC implements data and device access
control, and CP-ABE implements data encryption protection.

The comparison between our study and the above related works is given in the Table.1, in-
cluding using BT for IoT access control and ABE for Edge-Iot data protection. It is evaluated
from two aspects of data security and device security. Using blockchain for Edge-Iot and intro-
ducing access control models and attribute encryption. Compared with the above research, we
have a punishment mechanism for illegal access, ﬁne-grained and real IoT device evaluation en-
vironment in access control, at the same time, in terms of encryption, we outsource computing,
low latency and low resource consumption, so it is the best in these two aspects.

Overall, we believe that the blockchain itself has insuﬃcient computing power and is not suit-
able for outsourcing calculations. For edge nodes, only outsourcing calculations are involved.
You can refer [11, 22, 33, 38] for updating and revoking attributes. We provide an implementation
of a security solution for Edge-Iot based on blockchain, namely the edge outsourced encryption
and decryption of data and the combination of the blockchain. We use the blockchain to honestly
record the access process, and design smart contracts to achieve secure access to encrypted data,
which is diﬀerent from Qin et al.[31]. We introduce an access control model based on smart con-
tracts to achieve controllable access to data and equipment. Outsourced computing is conﬁrmed
by the Proof of Work (PoW) consensus mechanism. On the basis of ensuring decrypted data, we
introduce edge computing to achieve low latency and low computing power consumption. Our
LBC test results guarantee high throughput at large scale.

6

Table 1: Comparison of Our Study and Other Previous Related Works

Implementation of Access Control for IoT Data and Devices based on Blockchain

Related Studies

Method

Punishment
Mechanism

Implementation Mechanism

Blockchain

Evaluation

Access Control

Data Security

Fine-
granularity

Data Secu-
rity Access

Data Privacy
Protection

Device Security
Device Access Control

Ouaddah et al.[28] Access Token
Access Policy
Novo [26]

Zhang et al.[44]

Access Policy

Maesa et al.[12]
Maesa et al.[13]
Zhang et al.[45]

ABAC Model
ABAC Model
Access Tree

Liu et al.[23]
Sun et al. [37]

ABAC Model
ABAC Model

Song et al.[36]

ACL

Ding et al.[8]

ABAC Model

Ours

ABAC Model

No
No

Yes

No
No
No

No
No

Yes

No

Yes

Judgment mechanism for passing access token
Single smart contract deﬁnes permission opera-
tions
Three smart contract implementation policies to
add judgment and punishment
Script language implements ABAC policies
Smart contracts implement ABAC policies
The smart contracts construct the access policies
as access trees
Smart contracts implement ABAC policies
Smart contracts calls PDP and PIP to implement
ABAC
Smart contracts implement ACL-based access
control
Smart contracts obtain the on-chain attributes that
comply with the ABAC policies
Smart contracts calls PEP,PDP,PAP and PIP to im-
plement ABAC

Bitcoin
Ethereum

Single IoT Device
Virtual IoT Devices

Ethereum

Two IoT Devices

Bitcoin
Ethereum
Fabric

Fabric
Fabric

-
-
Three IoT Devices

Virtual IoT Devices
Single IoT Device

Ethereum &
Fabric
Fabric

Proof of Concept

Proof of Concept

Our LBC

Three IoT Devices

No
No

No

Yes
Yes
Yes

Yes
Yes

No

Yes

Yes

Yes
Yes

Yes

Yes
Yes
-

Yes
Yes

Yes

Yes

Yes

No
No

No

No
No
No

No
No

No

No

Yes

Yes
Yes

Yes

-
-
Yes

Yes
No

No

No

Yes

Yes support; No not support; - not involved.

Data Security Access and Privacy Protection for Edge-Iot based on Attribute Encryption Outsourcing

Related Studies

Method

Outsource

Data Protection
Implementation Mechanism

Consumption

Data Security

Calculate

Latency

Resource

Data Secu-
rity Access

Data Privacy
Protection

Device Security
Device Access Control

H

L

M

L

L

L

H

H
H

L

L

H

H

M

L

-

-

H

H
H

L

L

Yes

Yes

Yes

No

No

Yes

Yes

Yes
Yes

Yes

Yes

Yes

No

Yes

Yes

Yes

Yes

Yes

Yes
Yes

No

Yes

No

No

No

No

No

No

-

No
Yes

Yes

Yes

Cui et al. [7]

PA-CPABE

Zhang et al.[43]

CP-ABE

Fan et al. [11]

PPO-MACS

Li et al.[22]

CP-ABE

Sarma et al.[33]

PAC-FIT

Tu et al.[38]

MA-ABE

Hsu et al.[17]

Guan et al.[16]
Qin et al.[31]

Signa-

Private
ture Chain
PP-BCETS
CP-ABE

Yang et al.[41]

CP-ABE

Ours

ABE-ACS

Yes

Yes

Yes

Yes

Yes

Yes

Yes

No
No

Yes

Yes

Fog node

Fog node

Fog node

Fog node

The decryption private key is generated from the
conversion key and the user private key
Decrypted by the combination of the cloud key
and the user’s partial private key
Fog node implements data encryption, decryption
and veriﬁcation
The ciphertext remains unchanged after revoking
the user and his attributes
The user key is unchanged, not aﬀected by at-
tributes
Diﬀerent authorization agencies control diﬀerent
attribute sets
Private signature chain ensures that encrypted data
will not be replaced
Transaction data encryption for privacy protection Ethereum
Encryption, decryption and veriﬁcation based on
smart contracts
Based on the consensus mechanism to ensure data
decryption securely
Edge node implements data encryption and de-
cryption, consensus mechanism to veriﬁcate re-
sults

Fog node

Fog node

Fabric

Fabric

Fabric

Edge node

Yes support; No not support; H high; M medium; L low; - not involved.

7

3. Preliminaries and deﬁnitions

In this section, we ﬁrst give a brief review of background information on bilinear maps. Then
we describe the deﬁnition of access structure and relevant background on Linear Secret Sharing
Schemes (LSSS) in our paper, and ﬁnally we describe CP-ABE and ABAC on which our scheme
is based.

Table 2: Description of main notations and acronyms used in this paper

Two multiplicative cyclic groups.
A generator and a prime order of G.
A bilinear map e : G × G → GT .
The integers modulo p, a random value ∈ Zp.
A set of attributes.

Description

Notations and Acronyms
G, GT
g, p
e
Zp, rv
AS = {a1, a2, · · · , an}
P = {PAs1, PAs2, · · · , PAsn} Attributes of a set of parties.
A
M(r, c),
ρ(i)
T , Tr, Lx, NLx
s = {s1, s2, · · · , sn}
PK, PK A
MK
pk, pk A
m, CT m

Access structure.
A matrix with r rows and c columns.
A function maps the i(cid:48)th row of M to an attribute set.
Access tree, root node, leaf node x, non-leaf node x.
A set of secret value.
Public key, public key of A.
Master key.
Private key, private key of A.
Message, the ciphertext of message.
A random polynomial of degree t − 1 to generate
secret value L(0) = s.
Subject, object, operation, environment.
The attributes of the subject, object, operation,
and environment respectively.
A set of active access subjects and passive access objects
at time t.
Our lightweight blockchain.
Internet of things architecture integrating edge computing.
Implementation of smart contract based on
attribute based access control model.
Attribute-based encryption and access control scheme.

L(x), L(0)

S ub, Ob, Op, En

S ubA, ObA, OpA, EnA

S (t), O(t)

LBC
Edge-Iot

SC-ABAC

ABE-ACS

We deﬁne some notations used in this section. The vectors are denoted by bold letters, and
vi denotes the i(cid:48)th element of the vector (cid:126)v. A vector is usually treated as a column vector. MT is
the transpose of the matrix M. The deﬁnitions of main notations and acronyms used in Table.2.

3.1. Bilinear maps
Deﬁnition 1. (Bilinear Maps [42]). Let G, GT be two multiplicative cyclic groups of prime order
p, and g be the generator of G. The bilinear map e is, e : G × G → GT , for all a, b ∈ Zp:

8

ua, vb(cid:17) = e(u, v)ab.
(1) Bilinearity: ∀u, v ∈ G, e
(2) Computability: ∀u, v ∈ G,there is an eﬃcient algorithm to compute e(u, v).
(3) Non-degeneracy: ∃u, v ∈ G, e(u, v) (cid:44) 1, where 1 is the unit of G

(cid:16)

3.2. Access structure
Deﬁnition 2. (Access structure [39]). Let P = {PAs1, PAs2, · · · , PAsn} be a set of parties. Set
a monotone collection A ⊆ 2P. If ∀B, C and if B ∈ A, B ⊆ C, then C ∈ A. An access structure
is a collection A of non-empty subsets of P, that is, A ⊆ 2P\{∅}. The sets in A are called the
authorized sets, and the sets not in A are called the unauthorized sets.

In this paper, an access structure A in ABE contains the authorized sets of attributes. Unless

otherwise stated, access structure for the rest of this paper means monotone.

3.3. Linear secret-sharing schemes
Deﬁnition 3. (Linear Secret-Sharing Schemes [4]). Let Π be a secret-sharing scheme over a set
of parties P with realizing an access structure A is called linear (over Zp), if:
1 The shares for each party form a vector over Zp.
2 There exists a matrix M(r, c) with r rows and c columns, called the share generating matrix
for Π. For ∀i ∈ {1, 2, · · · , l}, using the function ρ(i) to get a set of attribute from the i(cid:48)th row
of M. A vector (cid:126)v = (s, rv2, · · · , rvn)T is generated, where s ∈ Zp is the secret to be shared
and rv2, · · · , rvn ∈ Zp are randomly chosen, then M · (cid:126)v is the vector of l shares of the secret s
according to Π. The share (M · (cid:126)v)i belongs to party ρ(i).

In this paper, Π is described as (M, ρ). Using standard techniques [4] we can convert any
monotonic boolean formula into an LSSS representation, such as access binary trees. An access
tree of the l(cid:48)th non-leaf node will result in an LSSS matrix of the l(cid:48)th row.

3.4. (t,n) Threshold access tree

Let T be a tree representing an access structure with root Tr. Each leaf node Lx of T is
detailed by an attribute, each non-leaf node NLx of T is a threshold gate (t, n), which AND or
OR gate is the special case. Set n as the number of children of this node x and (1 ≤ t ≤ n) is its
threshold value. For a threshold gate (t, n), if t = 1, the threshold gate is an OR gate and if t = n,
it is an AND gate. Whether an attribute set P satisﬁes a monotone access tree is determined as
follows.

Deﬁnition 4. (Threshold access tree [24]). For the leaf node Lx, if Lx ∈ P, the leaf node is said to
be satisﬁed. For a threshold gate (t, n), if and only if at least t (out of n ) child nodes are satisﬁed,
the non-leaf node NLx is satisﬁed. If and only if the root Tr of T is satisﬁed, T is said to be
satisﬁed by P.

In this paper, access policy intuitively express in monotone boolean formulas with AND or
OR gates and based on random polynomials to construct a (t,n) threshold access tree and then
convert into a matrix by LSSS. Based on the Lagrange interpolation polynomial, the original
secret value s of Tr can only be calculated through at least t values (attributes).

9

3.5. CP-ABE and ABAC

3.5.1. Ciphertext-Policy Attribute-Based Encryption (CP-ABE)

The CP-ABE scheme consists of four algorithms:
Setup(g, p) → PK, MK.
The setup algorithm will choose a bilinear group G of prime order p with generator g. Next
it will choose two random exponents pk α, pk β ∈ Zp. The public key and the master key are
published as:

PK = e(g, g)pk α, MK = (cid:16)

(cid:17)
gpk α, pk β

Encrypt(PK, m, AS ) → CT m.
The encryption algorithm will take the public key PK, a message m and attribute set AS
under the access atructure T as the input and output the encrypted ciphertext CT m of m. Assign
a value to each node by randomly generating a polynomial L(x), and corresponding the attribute
to the leaf node Lx. Only the corresponding attribute can solve the value of the root (secret value)
to decrypt the ciphertext CT m. An example of this is given in the section.4.3.3.

Key Generation(PK, MK, AS ) → pk.
The key generation algorithm will take as input a set of attributes AS and output a private key
pk which described by AS . At the ﬁrst, it will choose a random rv ∈ Zp, then pk of diﬀerent
nodes have the same part:

D = gpk α/pk β ∗ grv/pk β
Next for ∀AS i ∈ AS , choose diﬀerent random rv i ∈ Zp corresponding to it one by one.
Decrypt(PK, pk, CT m) → m.
The decryption algorithm will take the public key PK, the private key pk and the ciphertext
CT m as the input, if the attribute set corresponding to the private key pk satisﬁes the access
tree corresponding to the ciphertext CT m, it will decrypt the ciphertext CT m and return the
message m.

3.5.2. Attribute-Based Access Control (ABAC) model
The deﬁnition of ABAC model is as follows:

1) S ub, Ob, Op, En represent four entities respectively: subject, object, operation, and environ-

ment.

2) S ubA, ObA, OpA, EnA represent the attributes of the subject, object, operation, and environ-

ment respectively, such as:

S ubA = {S A1, S A2, · · · , S An}

ObA = {Ob1, Ob2, · · · , Obn}
OpA = {Op1, Op2, · · · , Opn}
EnA = {En1, En2, · · · , Enn}

3) S (t) = {s1, s2, · · · , sn} represents a set of subjects that actively initiate access requests in the
IoT at time t, O(t) = {o1, o2, · · · , on} represents a set of objects that can be accessed in the IoT
at time t.

10

4) Generally, a policy is designed that describes what operations may be performed upon those
objects, by whom, and in what environment those subjects may perform those operations.
The policy can be expressed as an algorithm that returns a boolean value with the attribute of
S ub, Ob, Op, En as input parameters.
Policy Execution(S ubi ∈ S (t), Obi ∈ O(t), Opi, Eni) → (T rue|False)

If the return value from the policy is true, the subject can perform the operation to object in

environment. Otherwise the subject cannot.

4. System framework and model

In this section, ﬁrstly give the introduce about our lightweight blockchain, and brieﬂy intro-

duce the system framework and model of our scheme.

4.1. our lightweight blockchain

Our lightweight blockchain (LBC) is a private chain specially designed for Edge-Iot, similar
to current blockchains, our LBC is a traditional chain structure designed by node.js, and the
data block linked by the hash pointer is generated by the optimized PoW consensus algorithm.
The block stores transaction data, the previous block hash, creation role, creation time, data
digest, random number nonce and diﬃculty nBits of achieving consensus, and the block’s own
hash. Our LBC uses SHA256, Elliptic Curve Digital Signature Algorithm (ECDSA, using the
secp256k1 curve) [21] to implement hash calculations, data digital signatures, this is the same as
most blockchains.

4.2. System framework

We design a four-layer architecture for the realization of our scheme. As is illustrated in
Fig.1, the hierarchical structure of the proposed framework can be regarded as the upper two
layers of software deﬁnition layer and the lower two layers of hardware network layer. The
upper layer is implemented by smart contracts to implement access control and penalty mech-
anisms, and the lower layer is a decentralized blockchain network composed of Edge-Iot, and
corresponding resources and data.

4.2.1. Resource Data Layer

Resources and data are the objects of access control, which are the resources (such as storage,
computing) and data owned by IoT terminal devices and edge nodes that can be provided to other
devices or users.

4.2.2. Blockchain Node Layer

Blockchain node layer is composed of IoT terminal equipment and edge nodes. Terminal
equipments include sensors that can sense environmental data (such as temperature and hu-
midity) and embedded devices that can execute control commands. Edge nodes act as agents
for resource-limited devices and receive the data sent by terminal equipment, send the terminal
equipment control commands given by the SCPE and realize communication and synchroniza-
tion through POW consensus and distributed network.

11

Figure 1: The four-layer structural framework followed in our scheme.

12

4.2.3. Smart Contract Layer

Smart contracts layer is the mechanism guarantee for the implementation of access control,
ensuring the management of access policies, the judgment, punishment or execution of object
access control, and the management of attributes such as subject and object, etc.

1) Smart Contract for Policy Administration (SCPA) :

SCPA is used to manage the access control policies converted from the (t, n) threshold tree
and LSSS into the matrix, including adding, modifying, deleting and updating, and to provide
encryption policies for data owners. It can only be executed by the policy managers (e.g. the
data owners) and sent the policy to SCPD for judgment. An access control policy contains
four elements: S ubA, ObA, OpA, EnA. These attributes of elements get by the SCPI.

2) Smart Contract for Policy Decision (SCPD) :

SCPD is used to determine whether the subject’s access control complies with the object’s
corresponding policy. It obtains the subject, object, operation and environmental attributes
involved in the current policy from SCPI and returns the judgment result (True or False) to
SCPE or SCPM.

3) Smart Contract for Policy Information (SCPI):

SCPI is used to manage the attributes of the subject, object, operation, environment and pro-
vide attributes required for data decryption. S ubA represents the basic identiﬁcation informa-
tion of the subject, such as a unique subject number, identity, etc. ObA represents the basic
identiﬁcation information of the object, such as the unique object number, type, etc. OpA
represents the basic information of the operation, such as read, write, delete, create, etc. EnA
represents the basic information of the environment, such as time, location, etc.

4) Smart Contract for Encryption Decryption (SCED):

SCED is used for attribute-based encryption and decryption of data, implemented by edge
nodes. For example, encrypt and protect the corresponding attribute of the policy document
ontology corresponding to a certain object and decrypt in accordance with the attribute of the
subject.

5) Smart Contract for Penalty Mechanism (SCPM):

SCPM is oriented to the subject and used to implement punitive measures under illegal access,
such as deleting its corresponding access control policy to make it unable to access other
objects, etc.

6) Smart Contract for Policy Enforcement (SCPE):

SCPE is oriented to the object and used to implement legal access control mechanisms, then
return the corresponding encrypted data or available resources.

4.2.4. User Service Layer

It is used to provide services to users, such as cloud computing, data centers, etc. Access

control is achieved by calling SCPA.

4.3. System model

We describe the process through a subject with attributes to access the object under the cor-
responding policy. The object’s access control policy is transformed from the AND-OR relation-
ship to the (t, n) threshold tree structure and then from LSSS to the corresponding matrix, and
the subject decrypts the matrix by matching its own attributes and values, through the Lagrange
Interpolation Polynomial to obtain the secret value of the root node and compare it with the real
value. If they are equal, the access control policy is satisﬁed and the object is returned.

13

4.3.1. Original Access Control Policy P

Suppose that there is a subject S ub with an attribute PS ub such as:

PS ub = {S A1, S A2, S A3}

At the same time, there is a object Ob with an attribute POb such as:

POb = {ObA1, ObA2, ObA3}

For this object Ob, we design an access policy P based on AND-OR attribute relations:

P = (S A1 OR ObA1) AND (S A2 OR ObA2) AND (S A3 OR ObA3)

4.3.2. Construction based on (t, n) access tree T

Figure 2: Construction of (t, n) access tree T from access policy P(cid:48)

This access policy P can be described using a recursive-form string, namely,

P(cid:48) = ((S A1, ObA1, 1), (S A2, ObA2, 1), (S A3, ObA3, 1), 3)

Fig.2 shows the process from access policy to (t, n) access tree. Finally constructing a (3,3)-
threshold access tree with three children node (S A1, ObA1, 1), (S A2, ObA2, 1) and (S A3, ObA3, 1)
from P(cid:48). For the node (S A1, ObA1, 1), the two children are the leaf nodes Lx corresponding to
attributes S A1 and ObA1, which root node is a (1,2)-threshold gate.

4.3.3. Construction of LSSS-based access structure

For a (t, n) access tree T , t is its threshold value and n as the number of children of node. Root
node r is set with a secret value ϕr, which the child node is generated by a random polynomial
f (x), which the highest power is t − 1, the secret value ϕ is the constant term, f or x = 1, . . . , n.
14

When each node x except the root node r calculates its own corresponding secret value ϕx

through the random polynomial f (x), we can construct the corresponding LSSS over Zp, as





t
t1
t2
...
tn

n
n1
n2
...
nn

f (1)
f1(1)
f2(1)
...
fn(1)

f (2) . . .
f1(2) . . .
f2(2) . . .
...
fn(2) . . .


f (n)
f1(n1)
f2(n2)



fn(nn)

fi(x) = ϕx ( f or i = 1, . . . , n; x = 1, . . . , ni)

We now use the access tree shown in Fig.2 as an example to construct the LSSS-based struc-

9

(cid:17) (cid:16)

P =

13 19

ture.
1) T = (7) ( random ϕr = 7) ← P = ((S A1, ObA1, 1), (S A2, ObA2, 1), (S A3, ObA3, 1), 3)
2) (3, 3) − T = (cid:16)
(cid:17)
random polynomial f (x) = x2 + x + 7; x = 1, 2, 3
3 3


(S A1, ObA1, 1)

(S A2, ObA2, 1)
(S A3, ObA3, 1)
3) (1, 2)−A1 = (cid:16)
1

3
1
1
1

2 9 9
13 19
9
3
0
9
9
2
0
2 13 13
0
2 19 19

4) f inal T =









(cid:17)

( random polynomial f1(x) = f (1); x = 1, 2) ← P(cid:48) = (S A1, ObA1)

←

For calculating the secret value ϕr = 7 in the (3, 3) access tree T , suppose that the S ub with
(cid:17)
. Then from f (x) = ax2 + bx + c
9

an attribute PS ub = {S A1, S A2, S A3}, namely v = (cid:16)
we get a set of equations:

13

19


a + b + c = 9

4a + 2b + c = 13

9a + 3b + c = 19

So we set

M =


1
4
9



1
2
3


1
1
1



Then compute M · ωT = vT , it can be easily computed that ω = (cid:16)
. So the c = 7 = ϕr, we
1
can satisfy the access structure. Similarly, using the set of attributes PS ub(cid:48) = {S A1, S A2} cannot
get the vector ω.

(cid:17)
7

1

5. Attribute-based encryption and access control scheme (ABE-ACS)

In this section, we present the main procedures of the proposed scheme can be divided into

the following phases.

1) Initialization.
2) Access and control.
3) Outsource.

Our scheme implementation process is shown in Fig.3.

15

Figure 3: Attribute-Based Encrypt and Access Control Scheme (ABE-ACS)

16

5.1. Initialization

5.1.1. Devices and Users Registration

When a new device wants to apply to join our system, the new node registration is required.
Thinking about our scheme for large scale complex networks of heterogeneous devices, which
have diﬀerent ways to communicate, so we identify a device from the four dimensions: device
ID:DID, device COM Port:DCP, device MAC:DMAC and device IP Port:DIP. We use the SHA-
256 to calculate the device ID DID and storage it to the labels of nodes in regist set of DHashID.
By initializing rv ∈ Zp randomly, when DID (cid:60) DHashID, the DID and DHashID as follows:

DID = S HA256(DID, DCP, DMAC, DIP, rv)
DHashID = DHashID.push(DID)

(1)

(2)

After complete execution, a set of new nodes DID ∈ DHashID is available. Through the unique
identiﬁcation of DID, the device can be added to the blockchain. User registration also generates
user ID: UID and the labels of users in regist set of UHashID. The diﬀerence is that the user ID is
only determined by the UID.

5.1.2. Setup registration

We set P = {PAs1, PAs2, · · · , PAsn} as the universe set of attributes, the attributes related
to each device and user (such as S ubA, ObA, OpA, EnA) are in it, and they are associated with
the corresponding ID. Then set a group G = (G1, GT , g, p, e) as a bilinear pairing group, let
H : {0, 1}∗ → G be a hash function, which maps any attribute to a random element of G. So for
a device attribute set DAs = {DA1, DA2, · · · .DAn}, H(DAs) = {grv1 , grv2 , · · · , grvn }, for randomly
value {rv1, rv2, · · · , rvn} ∈ Zp.

We do H mapping to the attribute set in the registered blockchain node, randomly select
gpk α, gpk β ∈ G as the public keys and pk α ∈ Zp as the private key for secret preservation.The
global public key PK and master key MK we publish to the blocks are set as follows:

PK = {G1, GT , g, p, e, gpk α, gpk β, H}
MK = {gpk α, pk β}

(3)

(4)

17

5.2. Access and control

5.2.1. Smart Contract for Policy Administration

Algorithm 1 Policy Administration.
Input: User ID:UID; Labels of users in regist set of UHashID; Device ID:DID; Labels of nodes

in regist set of DHashID.

Output: Policy ID:PID; Labels of policies set of PHashID.

1: while UID ⊆ UHashID & DID ⊆ DHashID do
function addPolicy(UID, DID, · · · )
2:

3:
4:
5:
6:
7:

return Policy P

end function

function convertPolicy(P)
return Policy matrix M

end function

8:
9:
10:
11:
12:
13: end while

function storePolicy(M)
return PID, PHashID

end function

The user manages the policy by calling SCPA, such as adding, converting or storing. Algo-

rithm.1 shows the relevant operations on the policies.

addPolicy() takes at least two IDs of subject and object as input, calls the corresponding
attributes (mapped by H) through S CPI.getAtt() and combine them according to the AND-OR
relationship to output a policy ﬁle P.
1: function addPolicy(UID, DID, · · · )
UAs = S CPI.getAtt(UID)
2:
DAs = S CPI.getAtt(DID)
3:
if Subject is User and Object is Device then

4:
5:
6:
7:
8:
9:

Select As = {S ubA ∈ UAs, {ObA, OpA, EnA} ⊆ DAs}

else

Select As = {{S ubA, ObA, OpA, EnA} ⊆ DAs}
Or As = {{S ubA, ObA, OpA, EnA} ⊆ UAs}

end if
Generate Policy P based on the combination of AND-OR relationship under As
return Policy P

10:
11:
12: end function

convertPolicy() takes the P as input, for easy to understand, our default policy P itself con-
sists of S ubA, ObA, OpA and EnA, and they are connected by AND, so split based on AND-OR
and recursively return to non-leaf nodes of the threshold tree whose root node is (4, 4), and
attributes are converted to leaf nodes at corresponding positions. By constructing a random poly-
nomial for each non-leaf node to generate the secret value corresponding to the child node, the
leaf node corresponding to the ﬁnal attribute is assigned one by one, and a matrix M with a
hierarchical relationship and a tree T are output.

18

1: function convertPolicy(P)
2:
3:
4:
5:
6:

% Threshold Tree Conversion of Policy
Initialize a tree T with a root node (4, 4)
Split P with AND alone as x
for each x do

if (AND, OR) (cid:60) x then

The child node Lx of T is x

else

Compute the numbe n of attribute ∈ x
if ∃OR ∈ x then

Initialize a tree A with a root node (1, n)

else

Initialize a tree A with a root node (n, n)

end if
The child node of A is ∀ attributes ∈ x
The subtree of T is A

end if

end for
% Matrix Generation based on LSSS
Initialize a matrix M = [4, 4]
Randomly select a value ϕs ∈ Zp to replace the root node of T
Randomly select a set of parameters {a1, a2, a3}(over ∈ Zp)
Generate polynomial f (x) = ϕs + a1x + a2x2 + a3 x3
for each child node NLi of root node(4, 4) do

si for the i(cid:48)th NLi ← f (i)
the M(0, i + 1) ← si

end for
for each parent node i(cid:48)th NLi(t, n) do

The secret value si to replace the i(cid:48)th NLi(t, n)
the M(i, 0) ← t; M(i, 1) ← n
NL j(cid:48) ← the j(cid:48)th child node of i(cid:48)th NLi
while NL j(cid:48) (cid:44) Null do

7:
8:
9:
10:
11:

12:
13:
14:
15:
16:
17:

18:
19:
20:
21:
22:
23:

24:
25:
26:
27:
28:
29:

30:
31:
32:
33:
34:
35:

Randomly select a set of (t-1) parameters {a1, a2, · · · , at−1}
Generate polynomial fi(x) = si + a1x + a2x2 + · · · + at−1xn−1
s j for the j(cid:48)th NL j(cid:48) ← fi( j)
the M(i, j + 1) ← s j

end while

36:
37:
38:
39:
40: end function

end for
return Policy matrix M, policy tree T .

storePolicy() takes the M as input, outputs the policy ID PID corresponding to M by using

the SHA-256 to calculate the matrix M and the secret value ϕs .
1: function storePolicy(M)
PID ← S HA256(M, ϕs)
2:
if PID (cid:60) PHashID then
3:
PHashID.push(PID)
4:

19

end if
return PID, PHashID

5:
6:
7: end function

When a subject gets the PID and M from the storePolicy(), we believe that it is unacceptable
to use an exhaustive ϕs method to calculate the same string as PID in the time spent. On the con-
trary, it is more acceptable to use its own attributes to calculate a corresponding ϕs and determine
whether the calculated string is the same as the PID in terms of computational cost. Therefore,
the secret value corresponding to any policy can be guaranteed not to be calculated exhaustively,
but can only be calculated by the attributes involved in the policy.

5.2.2. Smart Contract for Policy Decision

Algorithm 2 Policy Decision.
Input: Subject ID:SID; Object ID:OID.
Output: The decision: True or False.

1: while ∃ SID, OID do
2:

function judgePolicy(SID, OID)

return Decision T ure or False

3:
4:
5: end while

end function

When a subject wants to access an object, for SCPD, it needs to obtain the corresponding
attribute set from the SCPI, at the same time to get the corresponding access control policy matrix
M and the PID from the SCPA. Therefore, SCPD takes the subject ID SID and the object ID OID
as input, the subject is the requester (such as user, equipment, etc.), and the object is the provider
(such as equipment), similarly obtains the attributes SAs corresponding to the subject through
S CPI.getAtt() and the policy matrix M, policy tree T and policy ID PID corresponding to the
object through S CPA.convertPolicy() and S CPA.storePolicy(). Then based on the matching of
SAs and leaf nodes of T , gets the distribution of attributes in the M and the corresponding values
si j, calculates the corresponding secret value s based on si j, combines M to calculate the string
and compare with the PID, if they are the same, return true, otherwise return false. Algorithm.2
shows the relevant operation.
1: function judgePolicy(SID, OID)
2:
3:
4:
5:
6:
7:

SAs = S CPI.getAtt(SID)
M, T ←SCPA.convertPolicy()
PID ←SCPA.storePolicy()
for all NLi ∈ T do

Select the same attribute set S Ai ⊆ SAs as the child attribute node of NLi
The value si j correspinding to S Ai ← M(i, j + 1)
t ← M(i, 0), n ← M(i, 1)
Randomly select a set of (t-1) parameters {a1, a2, · · · , at−1}
Randomly polynomial fi(x) = s(cid:48) + a1x + a2x2 + · · · + at−1xn−1
for each j do

8:
9:
10:
11:
12:
13:

14:

si j = s(cid:48) + a1 j + a2 j2 + · · · + at−1 jn−1

end for
if the number of S Ai ≥ t then

20

15:
16:
17:
18:
19:
20:

21:
22:
23:
24:
25:
26:

27:
28:
29:
30:
31:

s(cid:48) can be computed easily
The secret value si of NLi ← s(cid:48)

else

return Decision False

end if

end for
Randomly select a set of 3 parameters {a1, a2, a3}
Generate polynomial f (x) = s + a1 x + a2x2 + a3x3
for each i do

si = s + a1i + a2i2 + a3i3

end for
if the number of si ≥ 4 then
s can be computed easily
PID(cid:48) ← S HA256(M, s)
if PID(cid:48) ≡ PID then

return Decision T rue

else

return Decision False

else

end if

32:
33:
34:
35:
36:
37: end function

end if

return Decision False

5.2.3. Smart Contract for Policy Information

The user manages the attributes by calling SCPI, such as adding, deleting or getting. Algo-

rithm.3 shows the relevant operations on the attributes.

When a user is successfully registered, he can add or select the corresponding attributes from
the universe set of attributes P by inputting his own UID, and save the UID mapped by the hash
function H and the coresponding attribute set UAs to the AHashID in the form of key-value pairs,
and obtain the corresponding attribute set UAs by searching for the UID or deleting it from the
AHashID.

5.2.4. Smart Contract for Penalty Mechanism

When SCPD determines that the result of a subject’s access to the object is false, SCPM is
called to return illegal records Irec and a suitable punitive measure for this subject based the
number of illegal access, such as setting the access time limitation, the number of access, etc.
Algorithm.4 shows a punitive measure to limit access time based on illegal access history.

5.2.5. Smart Contract for Policy Enforcement

When SCPD determines that the result of a subject’s access to the object is true, or SCPM
return the punitive measure, SCPE is called to execute these results. Algorithm.5 shows the
relevant operations on the subject or object.

5.3. Outsource

For a visited device, when a visitor obtains the access permission from the PEP, it means
that the visitor can control the related resources corresponding to the accessed device’s access
21

Algorithm 3 Policy Informatiion.
Input: User ID: UID.
Output: The attribute set: UAS .
1: Initialize a universe set of attributes P
2: Initialize a label of users in attribute sets of AHashID
3: while ∃ UID do
4:
5:
6:

function addAtt(User ID: UID)
Add attributes As into P
Secert user attribute sets UAs ∈ P
UAs ← H(UAs)
Push (UID, UAs) in AHashID by key-value pair
return AHashID

end function

function delAtt(User ID: UID)
if UID in AHashID then

Delete (UID, UAs) from AHashID
return AHashID

end if
end function

7:
8:
9:
10:
11:
12:

13:
14:
15:
16:
17:
18:

function getAtt(User ID: UID)
if UID in AHashID then

return UAs

19:
20:
21:
22:
23:
24: end while

end if
end function

policy, such as calling the CPU calculation, etc. For the visitor, if obtains the data through the
accessed device, still needs to decrypt the data through calling SCED. The data owner (such
as terminal device) can call SCED to encrypt the data by outsourcing it to the edge node, and
the corresponding encryption policy may be inconsistent with the policy of the access control
process.

The CP-ABE traditional decryption is to input your own private key pk to decrypt the cipher-
text CT m. Because we use the outsourcing encryption and decryption method, the private key
cannot be directly handed over to the edge node for decryption, which has security problems.
Most of the current outsource methods such as [15, 38, 41] are designed to a transformation key
T K, and decrypting based on the T K, user needs only calculate one exponentiation to obtain the
massage m. However, there are still some resource-limited devices that do not have the ability
to perform exponential calculations, so we map the unique data owner (object) ID OID by hash
function H() to get gh, and then use gh in both encryption and private key generation process.
During the decryption process, the edge node obtains the key pk(cid:48) containing gh to realize the
normal decryption of the data. By generating a new private key pk(cid:48) after each decryption, it is
ensured that the private key will not be leaked each time, and the data can be decrypted normally,
thereby ensuring the security of the data and the private key.

22

Algorithm 4 Penalty Mechanism.
Input: Subject ID:SID,Decision:False.
Output: Punitive measure PM,illegal records Irec.
1: Initialize a universe set of punitive measures PM
2: Initialize a illegal records Irec
3: Initialize a number of illegal access t ← 0
4: if ∃ SID ∈ Irec then
5:

t ← 1

Get the corresponding vaule t(cid:48)
t ← t(cid:48) + 1
Delete (SID, t(cid:48)) from Irec

6:
7:
8: else
9:
10: end if
11: Push (SID, t) in Irec by key-value pair
12: Add punitive measures PM into PM
13: Secert a suitable punitive measure PM ∈ PM based the t-levels
14: % Limit the access time for example
15: Get the now time in the form of hours (dd:hh) T ime
16: if t ≤ 10 then
17:
18: else
19:
20: end if
21: Push (SID, N T ime) in PM by key-value pair
22: return Punitive measure PM,illegal records Irec

Next access time N T ime ← T ime + 2t (hours)

Next access time N T ime ← NULL

encrypt() takes public key PK, policy matrix (M, ρ), message m and object ID mapping
H(OID) as input and output the ciphertext CT m. The speciﬁc operation called by the object
here is similar to SCPD, but we will give speciﬁc instructions in the form of mathematical for-
mulas. From the section 5.1.2 we get the public key PK and hash function H(), and from the
S CPA.convertPolicy() we get a matrix M(r, c), thus, we descript the access policy with (M, ρ),
which function ρ(i) gets the attribute value of the i(cid:48)th row of M.

For each i = 1, · · · , r, (t, n) = Mi(0, 1), we get the matrix F as follows:






1
1
...
1

1
2
...
2t−1

. . .
. . .

. . .

1
n
...
nt−1



and choose a random vector (cid:126)vi = (si, a1, · · · , an−1) (over Zp), we have: (cid:126)vi = ρ(i) · F−1, the si
can be calculated, and ﬁnally secret value s can be calculated by si. In addition, with the gh, the
ciphertext CT m is published as :

CT m = {m · e(gpkα, gh)s}, C = {gpkβ·s}
(C1 = gs1 , Ma1 = H(ρ(1)), · · · , Ci = gsi, Mai = H(ρ(i)))

(5)

(6)

23

Get the punitive measure PM and illeagel records Irec = S CPM(SID, Decision)
Get the now time in the form of hours (dd:hh) T ime
t(cid:48) ← Irec(SID)
if T ime ≥ PM(SID).N T ime then

Algorithm 5 Policy Enforcement.
Input: Subject ID:SID; Object ID:OID.
Output: Punitive measure PM.
1: Decision = S CPD. judgePolicy(SID, OID)
2: if Decision ≡ False then
3:
4:
5:

t = t(cid:48) − 1

else

t = t(cid:48) + 1

6:
7:
8:
9:
10:
11:

12:
13:
14: else
15:
16:
17: end if

end if
Delete (SID, t(cid:48)) from Irec
Push (SID, t) in Irec by key-value pair
return Illegal records Irec

Get the permission to access the object OID
return The resource of OID

generateKey() takes the public key PK, the master key MK, the attribute set AS of subject
as input and output the private key pk. We choose random rv, rv1, rv2, · · · , rvr ∈ Zp, let J ⊆
{1, · · · , r} be deﬁned as J = { j : ρ( j) ∈ AS }. Then for each j, by the attribute set AS , the private
key pk as follows:

pk = {g(rv+h)/pkβ }, D = {gpkα/pkβ}
(D1 = grv1, Aa1 = gr · H(J1)rv1 , · · · , D j = grv j, Aa j = grv · H(J j)rv j)

(7)

(8)

decrypt() takes the public key PK, the private key pk and the ciphertext CT m as input and
output the result of decryption. From the i(cid:48)th row of M and the j part of AS , computes as follows:

e(Ci, Aa j)
e(D j, Mai)

=

e(gsi , grv · H(J j)rv j)
e(grv j, H(ρ(i)))

= e(g, g)rv·si, i f J j = ρ(i)

(9)

For e(g, g)rv·si, i = 1, 2, · · · , r, using polynomial interpolation can get e(g, g)rv·s(cid:48). If s(cid:48) = s,

the message m can be calculated as follows:

CT m · e(g, g)rv·s(cid:48)
e(pk, C) · e(D, C)

=

{m · e(g, g)(pkα+h)·s} · e(g, g)rv·s(cid:48)
{e(g, g)(rv+h)·s} · e(g, g)pkα·s

= m

(10)

By handing over all access control and related operations in the encryption and decryption
phases to the edge node, the visitor who matches the attribute policy can obtain the decrypted
data calculated by the edge node only by calling SCPE. In order to ensure the authenticity of the
data, similar to Yang et al.[41], we use PoW to verify the results. Algorithm.6 shows the relevant
operations on the edge nodes.

Calculate the current block hash CBHash including decrypted data m and random number
nNonce through multiple nodes, make it satisfy the nBits bits to be 0. Diﬀerent from traditional
24

PoW, even if a node ﬁrst calculates a random number that satisfys the nBits bits to be 0, other
nodes will not stop the calculation, but will verify after the decrypted data is calculated. If it
does not meet the requirements, continue to calculate random number nNonce and publish their
own calculation results, until most nodes believe that the result is consistent, the consensus is
completed. Therefore, the results can be veriﬁed by multiple nodes to ensure accuracy.

Algorithm 6 PoW Improvement.
Input: Blockchain diﬃculty:nBits; Previous block hash:PBHash; Current time:T ime;Current

PoW result:RPoW .

Output: Current

PoW result:

RPoW :((Current

block

hash:CBHash;

Random

value:nNonce),Number of support:n).

1: Message m = S CED.decrypt()
2: mHash ← S HA256(m); nNonce ← 0; random value set RS
3: CBHash ← S HA256(mHash, PBHash, T ime, nNonce)
4: while CBHash ﬁrst nBits bits (cid:44) 0 do
5:
6:
7:
8:
9:

if CBHash ﬁrst 1 bit (cid:44) 0 then
nNonce ← nNonce + 1

nNonce ← random()
while ∃nNonce ∈ RS do
nNonce ← random()

else

end while

end if
RS .push(nNoce)

10:
11:
12:
13:
14: end while
15: if ∃ others result R ∈ RPoW then
16:
17:
18:
19:
20:
21:

R.n ← R.n + 1
exist

else

Verify result VBHash ← S HA256(mHash, PBHash, T ime, R.nNonce)
if VBHash = R.CBHash then

Push((CBHash, nNonce), 1) in RPoW by key-value pair

end if

22:
23: else
24:
25: end if
26: return Current PoW result: RPoW

Push((CBHash, nNonce), 1) in RPoW by key-value pair

6. Security and performance analysis

In this section, we conduct a comprehensive analysis of the security of ABE-ACS from the

following aspects.

6.1. Formal Veriﬁcation Through AVISPA Tool

We use SPAN [14] + AVISPA (Automated Validation of Internet Security Protocols and Ap-
plications, AVISPA) simulation tool [3] to realize and verify the security of our scheme. AVISPA
25

uses the Dolev-Yao threat model to validate the security protocols described using the language
HLPSL (High-Level Protocol Speciﬁcation Language, HLPSL) [6]. Two validation conclusion,
namely: SAFE and UNSAFE, one of them will be returned.

In the communication process, the communication between edge nodes is recorded by the
tamper-free and traceable blockchain, and executed by smart contracts. Therefore, we believe
that the process is safe and controllable. We are aiming for a resource-limit device that may be
disguised by a malicious node to monitor and tamper with the communication data between the
edge node and the resource-limit devices. We assume that the malicious node has a full control
over the local network and can read, store, block every sent message, and can encrypt or decrypt
if it has the key.

Therefore we use the public-private key pair and random value generated in our scheme to
achieve secure communication between the two parties. We used two backends of the AVISPA
tool: OFMC and CL-AtSe to validate our scheme. The simulation results of the proposed pro-
tocol by using CL-AtSe and OFMC backend of AVISPA tool shows that the proposed scheme is
safe as shown in Figure 4 respectively.

(a) The OFMC summary report

(b) CL-AtSe summary report

Figure 4: Analysis of simulation results under OFMC (Fig.4a) and CL-AtSe (Fig.4b) backend.

6.2. Theoretical analysis

6.2.1. Data secure access

The heterogeneous environment of the IoT requires higher data security and can ensure the
correctness and reliability of the accessed data. Using a distributed blockchain to prevent single
points of failure, and to ensure the integrity and immutability of data access records through
timestamps and hash indexes. Smart contracts are used to achieve attribute-based ﬁne-grained
access control and illegal access punishment mechanisms under the decentralization. At the same
time, the optimized PoW consensus algorithm ensures the consistency of outsourcing decryption
results. Note that each edge node has the real encrypted data of all resource-limited devices that
it represents. Therefore, we do not consider the problem of malicious edge nodes tampering with
the data of their own resource-limited devices. We have no way to conﬁrm the correctness and

26

authenticity of the data obtained because of the nature problems of the resource-limited devices.
But we can guarantee the secure access to the data in the edge nodes and the authenticity and
correctness of the decrypted data.

Data conﬁdentiality: Considering that some resource-limited devices cannot achieve expo-
nential decryption capabilities, in order to ensure the security of device private keys in outsourced
computing, a mapping of H() to user UID is introduced gh, the edge node only completes the
decryption after getting the decryption key pk = g(rv+h)/pkβ , and cannot know the real private key
grv through pk. At the same time, to re-select the random number set {rv, rv1, rv2, · · · , rvr ∈ Zp}
to generate the new poliy and private key pk after each data decryption, and grv is generated and
the data is encrypted again to ensure data conﬁdentiality. For outsourcing nodes, after computing
the decrypted data, pk = g(rv+h)/pkβ will be invalidated and deleted, ensuring that pk is diﬀerent
for each decryption, ensure the conﬁdentiality of data.

Data authenticity: Considering that malicious nodes may deliberately not decrypt data af-
ter obtaining pk in order to reduce the time-consuming calculations, and thus complete the ﬁrst
generation of blocks and return false data, the optimized PoW algorithm returns the consistent
results calculated by most nodes as the true result, this guarantees the consistency of the de-
crypted data and at the same time forces the malicious node to complete the calculation to be
able to realize the approval of the generated block. On the assumption that most nodes are hon-
est, our optimized consensus mechanism can ensure that even if there are some malicious nodes
(all computing power is not more than 50%) during the block generation process, the real data
can still be obtained. Compared with the traditional PoW consensus algorithm, our optimization
algorithm avoids the window-breaking eﬀect caused by malicious nodes, and at the same time,
avoids the user’s veriﬁcation of the generated data. Our consensus mechanism can ensure the
fairness of generated block and the authenticity of the data.

Collusion resistance: Considering that unauthorized users may obtain access rights through
collusion, the data owner sets two mechanisms for each data access. One is to encrypt and
decrypt according to the attribute policy, and the other is to judge and execute according to the
access policy. To achieve collusion resistance, the core is to use a diﬀerent random number
set {rv, rv1, rv2, · · · , rvr ∈ Zp} for each policy, only when the user’s own attribute matches the
access and decryption policy, the real data can be returned. After decrypting the data, the original
data will be encrypted again by the new generated policy. At the same time, the user has four-
dimensional attributes {S ubi, Obi, Opi, Eni} are mapped by H(), so unauthorized users are not
clear about which attributes satisfy the policies, thereby ensuring collusion resistance.

6.2.2. Data privacy protection

The heterogeneous environment of the IoT requires higher privacy protection. Participants of
data access need to realize privacy protection for their own attributes and at the same time realize
access and obtain data without understanding the policy. The subject can only make an access
request on the basis of knowing the object.

Attribute anonymity: Although the attribute set UAS is public, for the subject and object,
the corresponding attribute set PAS is acquired by S CPI, it returns the point set H(PAS ) =
{grv1 , · · · , grvn } by H() mapped, other nodes cannot know the original attributes even if they query
the attribute set UAS , because using random index rv1, · · · , rvn to attribute mapping. So the
curious can’t get the real attribute information of other people except for itself, and guarantee the
attribute anonymity.

Policy anonymity: The key to access control, that is, the policy ﬁle is ﬁrst converted to (t, n)
threshold tree and then converted to matrix form M to store in S CPA. Only the hash value of
27

the policy matrix PID is returned, and other nodes through the public policy set PHashID cannot
know the speciﬁc policy information. Even if multiple nodes comply with the policy ﬁle, only
the judgment result is returned through S CPD, and nothing is known about the policy ﬁle itself.
Therefore the policy ﬁle can be well protected by privacy.

6.2.3. Device secure access

In the traditional IoT architecture, resource-limited devices are easily controlled by malicious
nodes due to problems such as weak passwords and no authentication mechanisms. By agenting
the resource-limit devices through edge nodes, the resource-limit devices only communicate with
the edge nodes and do not touch the external network; the communication between the edge
nodes is recorded by the blockchain, realized by smart contracts, and guaranteed by consensus
mechanism. During the subject’s access to the object, the subject can send an access request only
when the object is free at the time t and the object OID is known. After the object is visited at time
t, it cannot continue to be visited. At the same time, the smart contract is used to determine the
matching of policies and attributes, and achieve access to the object can only be performed on the
basis of the subject’s attributes SAs meeting the access policy P. At the same time, the consensus
mechanism ensures that the subject cannot have high-frequency access in a short period of time.
Guest authentication: When the system is initialized, for each device, by descirbed and
veriﬁed by four dimensions DID, DCP, DMAC, DIP, and at least one of the dimensions met can
be registered. The generated random number rv can ensure the uniqueness of the node DID. To
access a object, the subject must get the object OID at the time t by S CPA when the object is
free. The attacker cannot forge a certain legitimate node requesting access at a certain moment,
except for himself.

Controllable access: There are three measures to ensure controlled access. The attributes of
the subject SAs are described by four dimensions: {S ubi ∈ S (t), Obi ∈ O(t), Opi, Eni}, minimize
the correlation of attributes between diﬀerent nodes. Diﬀerent devices have diﬀerent access
policies and diﬀerent data decryption policies, which can minimize the impression of malicious
nodes on themselves. At the same time, the penalty mechanism designed by S CPM, such as
exponentially increasing the limit access time, can also minimize the frequency of malicious
nodes generating requests under random access and the probability of successful access.

7. Experimental evaluation

In this section, we present the experimental evaluation results on the performance of ABE-

ACS.

7.1. Experimental Settings

We implement a prototype of LBC using JavaScript to build the blockchain network, and
implement the crypto-graphic mechanism using CP-ABE. To deploy blockchain on real IoT en-
vironment, we use three computers and three CC2530s. The conﬁguration is shown in Table.3.
All tests use the real data collected by data owner with 8051 MCU and 8KB RAM below are
conducted on the edge node with 2.90GHz Intel Core i7 processor and 16GB RAM and data
manager with 3.40GHz Intel Core i7 processor and 4GB RAM.

For actual IoT heterogeneous devices and data, we set three terminals (CC2530) in diﬀerent
places where are outside, lab and aisle to collect the temperature and humidity all the time.
Fig.5a shows the variations of temperature and humidity at the diﬀerent places in 2021-09-22

28

Table 3: Conﬁguration of experiment

Role

Type

CPU

Data owners
Edge node
Data manager

CC2530
Desktop Computer
Server

8051 MCU
Intel core i7 (2.90GHz)
Intel core i7 (3.40GHz)

RAM

8KB
16GB
4GB

OA

-
Ubuntu 20.04
DiskStation DS3617xs

09:55, and Fig.5b shows a simple prediction result and error analysis of the outside temperature
and humidity on September 22 obtained by the edge node through the data of the 7 days before
the LSTM (Long short-term memory) training.

(a) Terminals collect data

(b) Edge node prediction data (Outside)

Figure 5: The terminals collect temperature and humidity data of three places (Outside, Lab504, Aisle) (Fig.5a), and
edge node processing and prediction (Fig.5b)

7.2. Performance Comparison

Table 4: The average time to generate a block

Blockchain Bitcoin[25] Ethereum[10]

Fabric[20] Our LBC

Time

10min

12.04s

10ms

0.13ms

We tested the average block time of three common blockchains at the edge node, shows in
table.4. Due to Bitcoin and Ethereum as public chains, their average block generation time is in
the second level, so we only use fabric to build a private chain to compare the performance with
our LBC.

We mainly test transaction performance under duration, such as throughput, memory usage,
transaction frequency and CPU usage. Fabric’s experimental data comes from Caliper [19].
Our LBC experimental data comes from the sorting of the results of the top command of the
edge node linux system. The experimental data is logarithmically standardized except for the
CPU usage. Since our LBC is oriented to access control, when comparing the fabric’s correct
transactions, we conducted three sets of experiments: correct transactions, wrong transactions,
29

Figure 6: Performance comparison of our LBC and fabric [20]

and data veriﬁcation. The test results are shown in the Fig.6.Note that the throughput, storage,
and frequency in the ﬁgure all use a logarithmic scale.

Fabric has an average throughput of about 300 TPS (transactions per second), and our success
is 300 times that of fabric, over 100,000 TPS, and 100 times that of failure, about 45,000 TPS,
but the veriﬁcation process is only 3 times, about 1000 TPS. This is because we return the result
directly when the conditions are met when a successful transaction is met, without veriﬁcation,
and when it fails, there is a penalty mechanism that causes time-consuming. The veriﬁcation
process is to query and verify the signature again, so the veriﬁcation process has the lowest
throughput. From a time point of view, as the duration increases, the resources occupied by fabric
and ours are increasing, but in terms of occupancy, the CPU occupancy of fabric has increased
signiﬁcantly and accounted for a relatively large amount (green line), and ours basically remained
stable. However, for the memory, our occupies more memory, which is caused by frequent data
exchange in a short period of time.

7.3. Experimental evaluation

The main system overheads of our scheme are in two aspects. One is computational costs
caused by encryption and decryption, and the another is the time costs caused by generate blocks
based on PoW consensus algorithm.

7.3.1. the CP-ABE

In Table.5, the storage and computational cost of the presented work has been compared with
Sarma et al.[33]. In storage overhead, the devices only need to store a grv, so just |G1| of data,
and for edge node, in which represents n devices, during the decryption needs to store the private
key pk = g(rv+h)/pkβ of each device, there are n · |G1| of data, which is may more than the method
of Sarma et al. This is because we try to reduce the storage pressure of the devices. For operation
costs, during the generateKey() phase, devices need to calculate the g(rv+h), which is G1. Edge
node needs to calculate the values Di, Aai of each attribute of the policy and the pk, D, which is
(2 + 2NS )G1. This is half consumption of Sarma et al. During the encrypt(), there is nothing
30

Table 5: Analysis and comparison of storage and operation costs in devices and edge node

PAC-FIT[33]

ABE-ACS

Role

Device(data owner)
Edge node
Device(data owner)
Edge node

Storage overhead
3|G1| + |GT |
-
|G1|
n · |G1|

encrypt()
3G1 + GT
2(1 + 2NP)G1
G1
(1 + 2NP)G1 + GT

generateKey()

decrypt()

-
(4 + 4NS )G1
G1
(2 + 2NS )G1

e
(2 + 3NP)e
-
(2 + 3NP)e

NS : Number of attributes associated with the subject
NP : Number of attributes associated with the policy
n : Number of devices represented by edge node
|G1| : Size of the element in G1
|GT | : Size of the element in GT
e : Time required for a bilinear pairing operation
G1 : Time required for an exponentiation operation in G1 elements
GT : Time required for an exponentiation operation in GT elements

to do for devices that have data, and for subject needs to calculate gh, which is G1. Edge node
needs to calculate the value Ci, Mai of each attribute of the subject and the CTm, C, which is
(1 + 2NP)G1 + GT , also nerly half. During the decrypt(), diﬃerent with Sarma et al, there are
nothing to do for devices, and edge node is same as the method of Sarma et al in consumption.

In performance testing, we test the encryption and decryption time with the CP-ABE at the
edge node. We set the data size from 1B to 10MB, show the encryption and decryption time with
diﬀerent number of attributes based and-or with the CP-ABE. As shown in Fig.7, we compare the
encryption and decryption time-consuming from three aspects: the number of attributes, the data
size, the way to encrypt or decrypt. For the number of attributes, with the number of attributes
increases, the encryption and decryption time-consuming is linear increasing. For the data size,
when the data size is less than 1MB, the time-consuming mostly can be regarded as a constant;
for the way to encrypt or decrypt, ”and” or ”or” in encryption is similar, but in decryption, if
we choose ”or”,the time does not change with the number of attributes, and ”and”, decryption
time-consuming is linear increasing with the number of attributes increases.

7.3.2. the PoW’s algorithms

For the three PoW’s algorithm, in the case of nNonce = 5, on the data manager node we set
up four sets of controlled experiments, namely single, three times of concurrency, four times of
concurrency and ﬁve times of concurrency. Each group is performed 100 times to ﬁnd the average
time-consuming, and 10 tests totally. And showing the order in the ﬁgure is once, four-time, ﬁve-
time and three-time, time-consuming shows mostly the ﬁve-time concurrency is the highest, and
the once is the lowest in the four groups. At the same time, the average block-produced time-
consuming does not much diﬀerent, PoW-Ours about 31s per block, and PoW-Based about 33s
per block. However, from the Fig.8, PoW-Ours from the once is 21s per block to the ﬁve-time
concurrency is 45s per block, so if we make the peers choose the low concurrency, PoW-Ours is
the best.

8. Conclusion

This paper proposes an attribute-based encryption and access control scheme (ABE-ACS).
Under the security issues of Edge-Iot, our scheme implements ditributed and trustworthy ac-

31

(a) Encryption

(b) Decryption

Figure 7: The ﬁnal encryption(a) and decryption(b) time-consuming with diﬀerent size data and the number of attributes

32

  %   %    %  . %   . %    . %  0 %   0 %  D      D W W U L E X W H V  I R U  H Q F U \ S W L R Q             W L P H  F R Q V X P L Q J  P V                                                     D W W U  Z L W K  W K H  F R P S D U L V R Q  R I    D Q G   	   R U enc with 20 attr (and)enc with 20 attr (or)  %   %    %  . %   . %    . %  0 %   0 %  E      D W W U L E X W H V  I R U  H Q F U \ S W L R Q                W L P H  F R Q V X P L Q J  P V                                                                 D W W U  Z L W K  W K H  F R P S D U L V R Q  R I    D Q G   	   R U enc with 40 attr (and)enc with 40 attr (or)  %   %    %  . %   . %    . %  0 %   0 %  F      D W W U L E X W H V  I R U  H Q F U \ S W L R Q                   W L P H  F R Q V X P L Q J  P V                                                                       D W W U  Z L W K  W K H  F R P S D U L V R Q  R I    D Q G   	   R U enc with 60 attr (and)enc with 60 attr (or)  %   %    %  . %   . %    . %  0 %   0 %  G      D W W U L E X W H V  I R U  H Q F U \ S W L R Q                      W L P H  F R Q V X P L Q J  P V                                                               D W W U  Z L W K  W K H  F R P S D U L V R Q  R I    D Q G   	   R U enc with 80 attr (and)enc with 80 attr (or)  %   %    %  . %   . %    . %  0 %   0 %  H       D W W U L E X W H V  I R U  H Q F U \ S W L R Q                   W L P H  F R Q V X P L Q J  P V                                                                  D W W U  Z L W K  W K H  F R P S D U L V R Q  R I    D Q G   	   R U enc with 100 attr (and)enc with 100 attr (or)  %   %    %  . %   . %    . %  0 %   0 %  D      D W W U L E X W H V  I R U  G H F U \ S W L R Q       W L P H  F R Q V X P L Q J  P V                                             D W W U  Z L W K  W K H  F R P S D U L V R Q  R I    D Q G   	   R U dec with 20 attr (and)dec with 20 attr (or)  %   %    %  . %   . %    . %  0 %   0 %  E      D W W U L E X W H V  I R U  G H F U \ S W L R Q         W L P H  F R Q V X P L Q J  P V                                        D W W U  Z L W K  W K H  F R P S D U L V R Q  R I    D Q G   	   R U dec with 40 attr (and)dec with 40 attr (or)  %   %    %  . %   . %    . %  0 %   0 %  F      D W W U L E X W H V  I R U  G H F U \ S W L R Q                W L P H  F R Q V X P L Q J  P V                                       D W W U  Z L W K  W K H  F R P S D U L V R Q  R I    D Q G   	   R U dec with 60 attr (and)dec with 60 attr (or)  %   %    %  . %   . %    . %  0 %   0 %  G      D W W U L E X W H V  I R U  G H F U \ S W L R Q                   W L P H  F R Q V X P L Q J  P V                                              D W W U  Z L W K  W K H  F R P S D U L V R Q  R I    D Q G   	   R U dec with 80 attr (and)dec with 80 attr (or)  %   %    %  . %   . %    . %  0 %   0 %  H       D W W U L E X W H V  I R U  G H F U \ S W L R Q                      W L P H  F R Q V X P L Q J  P V                                                   D W W U  Z L W K  W K H  F R P S D U L V R Q  R I    D Q G   	   R U dec with 100 attr (and)dec with 100 attr (or)Figure 8: The time-consuming about three PoW’s algorithm. The comparison among PoW-Based, PoW-randomly and
PoW-Ours with the nNonce = 5.

cess control based on blockchain and performs outsourcing decryption based on edge comput-
ing. Our scheme is executed by multiple smart contracts to realize access control and penalty.
Improved PoW consensus mechanism ensures the correctness of outsourcing decryption with-
out additional computing and communication costs on the user side. Moreover, we design a
lightweight blockchain (LBC) for the implementation of smart contracts. The combination of
the (t, n) threshold tree and LSSS enables privacy protection of the policy. A new CP-ABE
scheme ensures private key protection for resource-limited devices. We gave the security anal-
ysis to prove the security of our scheme. In the performance evaluation, we tested from three
aspects and compared our scheme with related schemes, the results show that our scheme is ef-
ﬁcient and practical. In the future, the focus of our work is to realize the automatic management
of attributes and the automatic generation of policies.

CRediT author statement

Zhang Jie: Conceptualization, Methodology, Formal analysis, Writing- Original, Visual-
ization. Yuan Lingyun: Conceptualization, Resources, Writing - Review & Editing, Project
administration, Funding acquisition. Xu Shanshan: Software, Validation, Investigation, Data
Curation.

Declaration of Competing Interest

The authors declare that they have no known competing ﬁnancial interests or personal rela-

tionships that could have appeared to inﬂuence the work reported in this paper.

Acknowledgment

This work is partially supported by the National Natural Science Foundation of China (No.61561055),

the Special Fundamental Research Project of Yunnan Province-General Project (No.202101AT070098),
The Yunnan Ten-thousand Talents Program, and the Graduate Innovation Fund of Yunnan Nor-
mal University (No.ysdyjs2020148).

33

 W K H    W K W K H    W K W K H    W K W K H    W K W K H    W K W K H    W K W K H    W K W K H    W K W K H    W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K W K H     W K                                    7 L P H  F R Q V X P L Q J   P V                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     $ Y J 7 L P H              P V $ Y J 7 L P H              P V $ Y J 7 L P H              P V 7 K H  Q 1 R Q F H  R I  3 R :  L Q  G L I I H U H Q W  Z D \ V  W R  R E W D L Q POW-BasedPOW-OursPOW at randomReferences

[1] ”IoT Report: How Internet of Things technology growth is reaching mainstream companies and consumers,” Jul.

2021. [Online]. Available: https://www.businessinsider.com/internet-of-things-report

[2] ”IDC: Expect

175

zettabytes

of

data worldwide

by

2025.” Aug.

2021.

[Online]. Available:

https://www.networkworld.com/article/3325397/idc-expect-175-zettabytes-of-data-worldwide-by-2025.html
[3] A. Armando, D. Basin, Y. Boichut, Y. Chevalier, L. Compagna, J. Cuellar, P.H. Drielsma, P.C. He´am, O.
Kouchnarenko, J. Mantovani, S. M¨odersheim, D. von Oheimb, M. Rusinowitch, J. Santiago, M. Turuani, L. Vigan`o,
L. Vigneron, The AVISPA Tool for the Automated Validation of Internet Security Protocols and Applications, in:
Comput. Aided Verif., 2005: pp. 281–285. https://doi.org/10.1007/11513988 27.

[4] Beimel, A.: Secure Schemes for Secret Sharing and Key Distribution. PhD thesis, Israel Institute of Technology,

Technion, Haifa, Israel (1996)

[5] J. Bethencourt, A. Sahai, B. Waters, Ciphertext-policy attribute-based encryption, in: Proc. - IEEE Symp. Secur.

Priv., IEEE, 2007: pp. 321–334. https://doi.org/10.1109/SP.2007.11.

[6] Y. Chevalier, L. Compagna, J. Cuellar, P. Hankes Drielsma, J. Mantovani, S. M¨odersheim, L. Vigneron, A High
Level Protocol Speciﬁcation Language for Industrial Security-Sensitive Protocols, Austrian Comput. Soc. (2004)
350–357.

[7] H. Cui, X. Yi, S. Nepal, Achieving Scalable Access Control over Encrypted Data for Edge Computing Networks,

IEEE Access. 6 (2018) 30049–30059. https://doi.org/10.1109/ACCESS.2018.2844373.

[8] S. Ding, J. Cao, C. Li, K. Fan, H. Li, A Novel Attribute-Based Access Control Scheme Using Blockchain for IoT,

IEEE Access. 7 (2019) 38431–38441. https://doi.org/10.1109/ACCESS.2019.2905846.

[9] B. Dundua, M. Rukhaia, Towards Integrating Attribute-Based Access Control into Ontologies, in: 2019 IEEE 2nd
Ukr. Conf. Electr. Comput. Eng., IEEE, 2019: pp. 1052–1056. https://doi.org/10.1109/UKRCON.2019.8879922.

[10] Ethereum Smart Contract Platform. Jul. 2021. [Online]. Available: https://www. ethereum.org/.
[11] K. Fan, H. Xu, L. Gao, H. Li, Y. Yang, Eﬃcient and privacy preserving access control scheme for fog-enabled IoT,

Futur. Gener. Comput. Syst. 99 (2019) 134–142. https://doi.org/10.1016/j.future.2019.04.003.

[12] D. Di Francesco Maesa, P. Mori, L. Ricci, Blockchain Based Access Control, in: Lect. Notes Comput. Sci. (Includ-
ing Subser. Lect. Notes Artif. Intell. Lect. Notes Bioinformatics), 2017: pp. 206–220. https://doi.org/10.1007/978-
3-319-59665-5 15.

[13] D. Di Francesco Maesa, P. Mori, L. Ricci, A blockchain based approach for the deﬁnition of auditable Access

Control systems, Comput. Secur. 84 (2019) 93–119. https://doi.org/10.1016/j.cose.2019.03.016.

[14] T. Genet, A Short SPAN + AVISPA Tutorial, IRISA. (2015) 1–7.
[15] M. Green, S. Hohenberger, B. Waters, Outsourcing the decryption of ABE ciphertexts, Proc. 20th USENIX Secur.

Symp. (2011) 523–538.

[16] Z. Guan, X. Lu, W. Yang, L. Wu, N. Wang, Z. Zhang, Achieving eﬃcient and Privacy-preserving en-
ergy trading based on blockchain and ABE in smart grid, J. Parallel Distrib. Comput. 147 (2021) 34–45.
https://doi.org/10.1016/j.jpdc.2020.08.012.

[17] C.L. Hsu, W.X. Chen, T.V. Le, An autonomous log storage management protocol with blockchain mechanism and
access control for the internet of things, Sensors (Switzerland). 20 (2020) 1–32. https://doi.org/10.3390/s20226471.
[18] V.C. Hu, D. Ferraiolo, R. Kuhn, A. Schnitzer, K. Sandlin, R. Miller, K. Scarfone, Guide to Attribute Based Access

Control (ABAC) Deﬁnition and Considerations(Draft), NIST Spec. Publ. 800 (2014) 162.
[19] Hyperledger Caliper.Aug. 2021. [Online]. Available: https://www.hyperledger.org/projects/caliper
[20] Hyperledger Fabric: A Blockchain Platform for the Enterprise. Jul. 2021. [Online]. Available: https://hyperledger-

fabric.readthedocs.io/en/latest/index.html.

[21] D. Johnson, A. Menezes, S. Vanstone, The Elliptic Curve Digital Signature Algorithm (ECDSA), Int. J. Inf. Secur.

1 (2001) 36–63. https://doi.org/10.1007/s102070100002.

[22] L. Li,
User
https://doi.org/10.1109/ACCESS.2020.3025140.

Z. Wang, N. Li,
and Attribute Revocation

Eﬃcient Attribute-Based Encryption Outsourcing
(2020)
for Fog-Enabled

IEEE Access.

IoT,

8

Scheme With
176738–176749.

[23] H. Liu, D. Han, D. Li, Fabric-iot: A Blockchain-Based Access Control System in IoT, IEEE Access. 8 (2020)

18207–18218. https://doi.org/10.1109/ACCESS.2020.2968492.

[24] Z. Liu, Z. Cao, D.S. Wong, Eﬃcient Generation of Linear Secret Sharing Scheme Matrices from Threshold Access

Trees, IACR Cryptol. EPrint Arch. (2010) .

[25] Satoshi Nakamoto, Bitcoin: A peer-to-peer electronic cash system.
[26] O. Novo, Blockchain Meets IoT: An Architecture for Scalable Access Management in IoT, IEEE Internet Things

J. 5 (2018) 1184–1195. https://doi.org/10.1109/JIOT.2018.2812239.

[27] OASIS Standard, eXtensible Access Control Markup Language (XACML) Version 3.0. 22 January 2013. Jul. 2021.

[Online]. Available:http://docs.oasis-open.org/xacml/3.0/xacml-3.0-core-spec-os-en.html.

34

[28] A. Ouaddah, A. Abou Elkalam, A. Ait Ouahman, FairAccess: a new Blockchain-based access control framework
for the Internet of Things, Secur. Commun. Networks. 9 (2016) 5943–5964. https://doi.org/10.1002/sec.1748.

[29] A. Ouaddah, H. Mousannif, A. Abou Elkalam, A. Ait Ouahman, Access control

in the Inter-
Big challenges and new opportunities, Comput. Networks. 112 (2017) 237–262.

net of Things:
https://doi.org/10.1016/j.comnet.2016.11.007.

[30] C. Puliaﬁto, E. Mingozzi, G. Anastasi, Fog Computing for the Internet of Mobile Things:

Challenges,
https://doi.org/10.1109/SMARTCOMP.2017.7947010.

in:

2017 IEEE Int. Conf. Smart Comput. SMARTCOMP 2017,

IEEE, 2017:

Issues and
pp. 1–6.

[31] X. Qin, Y. Huang, Z. Yang, X. Li, LBAC: A lightweight blockchain-based access control scheme for the internet

of things, Inf. Sci. (Ny). 554 (2021) 222–235. https://doi.org/10.1016/j.ins.2020.12.035.

[32] A. Sahai, B. Waters, Fuzzy Identity-Based Encryption,

in: Ann. Rheum. Dis., 2005:

pp. 457–473.

https://doi.org/10.1007/11426639 27.

[33] R. Sarma, C. Kumar, F.A. Barbhuiya, PAC-FIT: An eﬃcient privacy preserving access control scheme for fog-
enabled IoT, Sustain. Comput. Informatics Syst. 30 (2021) 100527. https://doi.org/10.1016/j.suscom.2021.100527.
[34] S. Shafeeq, M. Alam, A. Khan, Privacy aware decentralized access control system, Futur. Gener. Comput. Syst.

101 (2019) 420–433. https://doi.org/10.1016/j.future.2019.06.025.

[35] W. Shi, J. Cao, Q. Zhang, Y. Li, L. Xu, Edge Computing: Vision and Challenges, IEEE Internet Things J. 3 (2016)

637–646. https://doi.org/10.1109/JIOT.2016.2579198.

[36] Q. Song, Y. Chen, Y. Zhong, K. Lan, S. Fong, R. Tang, A Supply-chain System Framework Based
Internet Technol. 21 (2021) 1–24.

on Internet of Things Using Blockchain Technology, ACM Trans.
https://doi.org/10.1145/3409798.

[37] S. Sun, R. Du, S. Chen, W. Li, Blockchain-based IoT access control system: Towards security, lightweight, and

cross-domain, IEEE Access. 9 (2021) 36868–36878. https://doi.org/10.1109/ACCESS.2021.3059863.

[38] S. Tu, M. Waqas, F. Huang, G. Abbas, Z.H. Abbas, A revocable and outsourced multi-authority
108196.

computing, Comput. Networks.

(2021)

195

fog

in

attribute-based
encryption
https://doi.org/10.1016/j.comnet.2021.108196.

scheme

[39] B. Waters, Ciphertext-Policy Attribute-Based Encryption: An Expressive, Eﬃcient, and Provably Secure Realiza-
tion, in: Lect. Notes Comput. Sci. (Including Subser. Lect. Notes Artif. Intell. Lect. Notes Bioinformatics), 2011:
pp. 53–70. https://doi.org/10.1007/978-3-642-19379-8 4.

[40] R. Yang, F.R. Yu, P. Si, Z. Yang, Y. Zhang, Integrated Blockchain and Edge Computing Systems: A
IEEE Commun. Surv. Tutorials. 21 (2019) 1508–1532.

Survey, Some Research Issues and Challenges,
https://doi.org/10.1109/COMST.2019.2894727.

[41] W. Yang, Z. Guan, L. Wu, X. Du, M. Guizani, Secure Data Access Control with Fair Accountability in
Smart Grid Data Sharing: An Edge Blockchain Approach, IEEE Internet Things J. 8 (2021) 8632–8643.
https://doi.org/10.1109/JIOT.2020.3047640.

[42] F. Zhang, R. Safavi-Naini, W. Susilo, An Eﬃcient Signature Scheme from Bilinear Pairings and Its Applications,
in: Lect. Notes Comput. Sci. (Including Subser. Lect. Notes Artif. Intell. Lect. Notes Bioinformatics), 2004: pp.
277–290.https://doi.org/10.1007/978-3-540-24632-9 20.

[43] P. Zhang, Z. Chen, J.K. Liu, K. Liang, H. Liu, An eﬃcient access control scheme with outsourc-
ing capability and attribute update for fog computing, Futur. Gener. Comput. Syst. 78 (2018) 753–762.
https://doi.org/10.1016/j.future.2016.12.015.

[44] Y. Zhang, S. Kasahara, Y. Shen, X. Jiang, J. Wan, Smart contract-based access control for the internet of things,

IEEE Internet Things J. 6 (2019) 1594–1605. https://doi.org/10.1109/JIOT.2018.2847705.

[45] Y. Zhang, B. Li, B. Liu, J. Wu, Y. Wang, X. Yang, An attribute-based collaborative access control scheme using

blockchain for IoT devices, Electron. 9 (2020). https://doi.org/10.3390/electronics9020285.

35

