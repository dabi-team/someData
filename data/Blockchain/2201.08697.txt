Verilay: A Veriﬁable Proof of Stake Chain Relay

Martin Westerkamp
Service-centric Networking
Technische Universit¨at Berlin
Berlin, Germany
westerkamp@tu-berlin.de

Maximilian Diez
Hasso Plattner Institute
University of Potsdam
Potsdam, Germany
maximilian.diez@alumni.uni-potsdam.de

2
2
0
2

n
a
J

1
2

]

R
C
.
s
c
[

1
v
7
9
6
8
0
.
1
0
2
2
:
v
i
X
r
a

Abstract—Blockchain relay schemes enable cross-chain state
proofs without requiring trusted intermediaries. This is achieved
by applying the source blockchain’s consensus validation protocol
on the target blockchain. Existing chain relays allow for the
validation of blocks created using the Proof of Work (PoW)
protocol. Since PoW entails high energy consumption, limited
throughput, and no guaranteed ﬁnality, Proof of Stake (PoS)
blockchain protocols are increasingly popular for addressing
these shortcomings. We propose Verilay, the ﬁrst chain relay
scheme that enables validating PoS protocols that produce ﬁnal-
ized blocks, for example, Ethereum 2.0, Cosmos, and Polkadot.
The concept does not require changes to the source blockchain
protocols or validator operations. Signatures of block proposers
are validated by a dedicated relay smart contract on the target
blockchain. In contrast
to basic PoW chain relays, Verilay
requires only a subset of block headers to be submitted in order
to maintain full veriﬁability. This yields enhanced scalability.
We provide a prototypical implementation that facilitates the
validation of Ethereum 2.0 beacon chain headers within the
Ethereum Virtual Machine (EVM). Our evaluation proves the
applicability to Ethereum 1.0’s mainnet and conﬁrms that only
a fraction of transaction costs are required compared to PoW
chain relay updates.

Index Terms—Blockchain, Proof of Stake, Chain Relay, Inter-

operability

I. INTRODUCTION

The increasing utilization of blockchain networks has en-
tailed novel implementations fostering high throughput and ad-
vanced scalability. In addition, emerging consensus algorithms
such as Proof-of-Stake (PoS) mitigate the inherent immense
power consumption of Proof-of-Work (PoW)-based networks.
However, with a growing number of blockchain networks, the
resulting fragmentation constitutes a pressing challenge.

One of the most prominent use cases driving blockchain
utilization in recent years is Decentralized Finance (DeFi). The
deployment of a plethora of DeFi applications to Ethereum
has resulted in congestion that calls for ofﬂoading to other
blockchain networks that provide higher throughput or are
less utilized. Yet, as DeFi applications such as decentralized
exchanges require sufﬁcient liquidity, isolated deployments to
competing networks are not sufﬁcient. Enabling cross-chain
token transfers through wrapped tokens alleviates dependen-
cies on a single blockchain network and increases overall
throughput. Liquidity can be provided where necessary and
blockchain advances supporting novel use cases are supported.
Multiple approaches have been presented to enable cross-
the simplest approach is

chain data exchange [1]. First,

based on (semi) trusted intermediaries that mediate between
blockchains to exchange information. Various implementations
of such notary schemes exist and usually imply economic
rationality assumptions [2]. Therefore, the reliability of trans-
ferred data is not reﬂected in the source blockchain’s consen-
sus, but it depends on external entities and their respective
collateral.

The second approach targets use cases that do not require
any knowledge about the source blockchain state on the target
blockchain. For instance, atomic swaps enable the exchange of
assets stored on two distinct blockchains between two entities
by applying hash-locks in combination with a commit-reveal
scheme [3]. Both involved entities retrieve required informa-
tion by observing transactions occurring on both blockchains.
Reproducing transactions or states across blockchain networks
is not needed. However, such schemes cannot cater for more
elaborate use cases such as moving assets between blockchain
networks and suffer from attacks exploiting time delays to gain
economic beneﬁts [4].

In contrast, chain relays enable blockchain interoperability
without requiring trusted intermediaries or economic assump-
tions and facilitate complex cross-chain use cases that utilize
the state, transactions, or events of a remote blockchain [5].
The consensus rules of a primary blockchain are incorporated
typically in a smart contract.
on a secondary blockchain,
Resembling light client functionality, block headers are sub-
mitted and validated on the secondary blockchain, enabling the
utilization of Merkle proofs to determine facts from the source
blockchain. As the validation is conducted within a smart
contract, no trust in the submitting entity is required. Hereby,
chain relays enable a wide range of cross-chain applications
such as wrapped token transfer, cross-chain contract execution,
or smart contract synchronization.

While multiple chain relays have been proposed, they target
the validation of Nakamoto consensus protocols and their
derivatives. The majority of these implementations enables
the validation of PoW-based algorithms [5]–[7]. Furthermore,
Gaˇzi et. al proposed a sidechain protocol for PoS algorithms
that are derived from Nakamoto consensus [8]. Yet, these pro-
posals do not cater for emerging blockchain implementations
such as Ethereum 2.0 [9], Polkadot [10] or Cosmos [11] that
provide guaranteed ﬁnality.

We propose Verilay, a chain relay concept enabling in-
teroperability between PoS-based blockchains that support

 
 
 
 
 
 
guaranteed ﬁnality and any blockchain offering smart contract
functionality. In this paper, we ﬁrst analyze different PoS
algorithms and classify their properties in the context of chain
relays. We differentiate between Nakamoto-based consensus
algorithms that follow the longest-chain rule and those that
are based on Practical Byzantine Fault Tolerance (PBFT). To
the best of our knowledge, we propose the ﬁrst chain relay
compatible with PBFT-based PoS blockchains. Compared to
previous chain relay proposals, Verilay provides enhanced
scalability by skipping blocks of the source blockchain and
replacing formerly relayed blocks while remaining full veriﬁ-
ability of the entire blockchain history.

To demonstrate the viability of our proposed system design,
we provide and evaluate a prototypical implementation that
establishes a bridge between Ethereum 2.0’s beacon chain
and any blockchain supporting the Ethereum Virtual Machine
(EVM). As the EVM is supported by a multitude of blockchain
implementations such as Hyperledger Burrow1 or shards of
Avalanche2, Polkadot3, and Cosmos4, Verilay has the poten-
tial to provide trustless interoperability between PoS-based
blockchain networks.

II. PROOF OF STAKE PROTOCOLS

In the context of blockchain technologies, consensus algo-
rithms are utilized to agree on a shared state in a decentralized
setting [12]. Transactions are disseminated in the network and
subsumed in blocks to guarantee a common order of execution.
One of the main challenges in anonymous and permissionless
blockchain networks is leader election, that is the election of a
successive block proposer. The application of PoS constitutes
a solution for selecting such block proposers [9], [13].

Staking. Proof-of-Stake (PoS) protocols are a family of
consensus protocols that require a security deposit of cryp-
tocurrency for gaining the right to publish blocks. Hereby,
sybil attacks are mitigated, as staked deposits act as a limiting
factor [10]. Furthermore, honest behavior is incentivized, for
instance by distributing rewards for correct participation in the
protocol or by burning stake in case of disclosed misbehavior,
also referred to as slashing [14]. Protocols that apply slashing
when misbehavior is detected are called accountably safe
in the context of this paper [9]. Staking, also referred to
as bonding [15], describes the process of locking assets to
participate in the consensus protocol [14]. Stakeholders can
withdraw stake in a process called unbonding. The unbonding
period deﬁnes a duration participants have to wait before stake
can be withdrawn.

Typically, the probability of becoming a block proposer is
either proportional to bound stake [10], [16] or a ﬁxed amount
of stake is required to participate [9]. Delegated Proof-of-Stake
(dPoS) describes an extension that permits staking to vote for
a delegate who participates in the consensus protocol on behalf
of the nominator [10].

1https://github.com/hyperledger/burrow
2https://docs.avax.network/
3https://www.parity.io/blog/substrate-evm/
4https://github.com/tharsis/evmos

PoS consensus protocols suffer from the so-called nothing-
at-stake problem that allows for long-range-attacks [10]. PoW-
based protocols do not suffer from such attacks, as the creation
of forks requires signiﬁcant computational and thus economic
investments. The creation of an illegitimate fork becomes more
infeasible with each appended block in the competing fork. In
comparison, creating blocks in PoS calls for the computation
of signatures, a relatively cheap operation compared to PoW
mining that may permit colluding validators to create forks of
arbitrary length to force blockchain reorganizations. Various
approaches exist to tackle such an attack. For instance, double
signing can be detected as misbehavior and respective stake
slashed [9]. Protocols that accept only recent blocks to prevent
long-range-attacks are denoted weakly subjective [17].

Time. Many PoS protocols divide time into slots and
epochs [9], [16], [18]. A slot is deﬁned as a time period that
contains at most one valid block. An epoch refers to a number
of consecutive slots with the same set of validators responsible
for voting on blocks [9]. As such, each transition between two
epochs can be considered a scheduled validator set change.
The validator change rate deﬁnes how much of the validator
set may change at each scheduled validator set change.

Finality. Finality describes if a particular block is certain to
be part of the consecutive blockchain and cannot be reverted.
Most consensus protocols either implement (near-)instant ﬁ-
nality or probabilistic ﬁnality, also referred to as eventual
consensus [18]. (Near-)instant ﬁnality implies that a block
will be ﬁnal once the consensus process has ﬁnished for this
speciﬁc block. Probabilistic ﬁnality by contrast is initiated
with the publication of a block and then approaches ﬁnality
with the execution of the consensus process of the entire
blockchain. Since guaranteed ﬁnality allows the application
of a wide variety of optimizations towards the chain relay,
Verilay focuses on implementing these protocols.

Forks. Finality properties are closely related to the creation
and selection of forks. A fork is deﬁned as the existence of
multiple formally valid blocks in one or more consecutive slots
and may result from network partitions or attacks such as long-
range-attacks [17]. A protocol’s fork choice rule has an integral
effect on the conceptualization of a respective chain relay. In
this work, focus on PBFT-based algorithms that circumvent
the appearance of forks for slots that contain ﬁnalized blocks.

A. Nakamoto-inspired PoS

In Nakamoto-inspired consensus protocols,

the longest
chain5 of blocks is the preferred fork [12]. The likelihood of
a block being permanently included in the agreed blockchain
increases the more successive blocks are appended. While ﬁrst
proposed in 2008 as part of the Bitcoin protocol, the concept
has also been applied to PoS protocols [16]. With Ouroboros
Genesis, Badertscher et. al have proposed a protocol
that
utilizes the block density after two forks diverge to choose
the accepted chain rather than the longest chain [13]. Hereby,

5In PoW protocols, the term ”longest chain” is an abbreviation for the fork

that subsumes the most aggregated work.

long-range-attacks are mitigated and nodes that turn ofﬂine or
join the network at a later stage are able to synchronize from
the genesis block and do not require trusted checkpoints. Thus,
the trustless synchroniization of Nakamoto-based PoS provides
an advantage compared to PBFT-instpired algorithms, as out-
lined in Section II-B.

On-chain validation of a Nakamoto-inspired PoS protocol
requires signature validation, fork handling, and the valida-
tion of validator sets. As ﬁnality is only probabilistic for
Nakamoto-inspired protocols, the chain relay has to be able to
handle forks of arbitrary length. In order to synchronize, the
fork’s length or density is taken into account. The validation of
validator set changes typically requires awareness of the entire
blockchain, as leader election depends on preceding stake
distribution and subsequent validator sets are not explicitly
signed.

B. PBFT-inspired PoS

Practical Byzantine Fault Tolerance (PBFT) is a consensus
algorithm that enables state machine replication surviving
byzantine faults in a permissioned setting [19]. Participants
cast votes in multiple rounds to commit to a common state.
The protocol tolerates up to 1
3 of byzantine participants. PBFT-
inspired PoS algorithms such as Tendermint [15] or Gasper [9]
apply a comparable voting mechanism to facilitate consensus
in a permissionless setting. Validators vote on their view of
the current state by signing blocks. Hereby, (near)-instant
ﬁnality is provided since a block holding a sufﬁcient amount of
signatures from the responsible validator set cannot be reverted
and is therefore deemed ﬁnal [18]. This feature represents an
advantage over Nakamoto-based protocols, as no probabilistic
assumptions are required.

However,

this comes at

the cost of limited veriﬁablity
when participants temporarily leave the network or join at
a later stage, as fork choice depends on validators’ votes.
Accountably safe and weakly subjective protocols prevent
long-range attacks by slashing their stake in case double
signing of multiple forks is disclosed. Yet, stake can be
withdrawn after the unbonding period elapsed, permitting
adversaries to collude on double signing at practically no cost.
In a weakly subjective PoS protocol, signatures by validators
are only trusted as long as validators are accountable [17].
The time period during which validators are accountable is
called trusting period and must be shorter than the unbond-
ing period [20]. In a weakly subjective consensus protocol,
participants who have not received and validated any block
for longer than the trusting period need to obtain a trusted
state from a trusted source. Based on this state, they can
continue validating succeeding blocks. Consequently, clients
cannot synchronize starting from the genesis block after the
ﬁrst trusting period has elapsed if the respective blockchain
applies a weakly subjective consensus protocol.

Accountable safety depicts a challenge for chain relays, as
the property can only be maintained if valid block headers
are submitted regularly. For instance, a validator could double
sign a fork from the main chain and submit it to the chain

relay. In case the trusting period has elapsed, the adversary
could not be held accountable. If the trusting period has not
elapsed, accountablility can only be ensured in case observers
capture potential misbehavior and report it to the source chain.

III. PROOF OF STAKE CHAIN RELAY

A. Design Goals

In order to guide the chain relay design, we introduce six
design goals that are derived from related cross-chain literature
and adapted to suit a PoS chain relay [1], [5]–[8], [21]. These
design goals will be utilized to evaluate the proposed concept
in Section V.

• Forkless. The chain relay does not require any soft,
hard, or velvet fork on the source blockchain or explicit
collaboration of a subset of its validators [5], [8], [21].
• Trustless. There are no trusted intermediaries. Trust in
stored block headers should be derived solely from the
source blockchain’s consensus validation. Any trusted
state required for bootstrapping the chain relay can be
veriﬁed independently by its users [1], [5], [7].

• Autonomous. As

and target
blockchains are active, the chain relay can be operated
independently of any single entity [6].

long as

source

the

• Robust. The chain relay retains its state and can still be
updated, even after extended periods of inactivity due to
situations in which no updates are performed, for example
if the target blockchain is congested [17].

• Corresponding. Only those block headers that are valid
according to the source blockchain’s consensus rules are
processed by the chain relay [5], [7]. The replicated data
should allow for inclusion proofs of transactions, states
and events that occurred on the source blockchain.

• Lightweight. Executing the chain relay client should be
efﬁcient in terms of computation and memory usage.
Corresponding update transactions should remain at least
within the execution limits of the target ledger [5], [7].

B. Proof of Stake Relay

In this section, we introduce Verilay, a chain relay en-
abling the validation of PBFT-based PoS blockchains. We
ﬁrst introduce the generally applicable chain relay concept
and exemplify its realization given the speciﬁcs of Ethereum
2.0’s Gasper protocol [9] in the succeeding section. The
validation process is applicable to any blockchain supporting
(quasi) Turing-complete user-deﬁned computations such as
the EVM [22]. Therefore,
is independent of the target
it
blockchain’s consensus algorithm and suitable to a wide range
of blockchain networks. Subsequently, we depict the required
steps for relaying PoS block headers and outline the relay
states and preconditions.

Initialization. Any client attempting to synchronize with
a PoS-based blockchain that is weakly subjective has to be
bootstrapped with a trusted initial state. The initial state
consists of a trusted block and the epoch’s validator set. As this
condition also applies to PoS chain relays, users must verify
the initial state before utilizing the contract. This process is

similar to the initial veriﬁcation of an unknown contract’s logic
to prevent unexpected behavior during its execution. While
the veriﬁcation process is left to the skilled user, increasing
utilization and security audits conducted by trusted entities
may render the contract trustworthy to any user.

Relay update. After the relay contract’s deployment, any
entity connected to source and target blockchain is enabled to
update the relay state. As the validation of submitted block
headers is conducted in the relay contract, no trust in the
relayer is required. To apply an update, the Verilay client
retrieves the destination block header, current validation set,
and next validation set, prepares a transaction and submits it
to the relay contract on the target blockchain.

Finalized blocks. The proposed chain relay only accepts
blocks that are ﬁnalized according to the source blockchain’s
consensus rules. Since ﬁnalized blocks are guaranteed to be
part of the main chain, forks cannot occur and hence do not
have to be handled by the relay contract. Depending on the
source blockchain’s consensus algorithm, the ﬁnalization is
accompanied by a delay, as validator’s votes are collected in
successive blocks [9].

Validator set. The size of the validator set varies greatly
depending on the implementation. While Cosmos envisions
validator set sizes in the order of hundreds and Polkadot plans
to scale up to one thousand, Ethereum 2.0 does not deﬁne
an upper bound. The chain relay design must cater for these
conﬁgurations. As the validation of signatures requires both
computing resources and available public keys, the costs for
updating the relay increase with the number of validators.
Hence, it is infeasible for a relay contract that is executed in
a constrained execution environment to process all signatures
of the Ethereum 2.0 validator set.

To facilitate light client validation, Ethereum’s ﬁrst bea-
con chain upgrade called Altair implemented so-called sync
committees [23]. A sync committee is a periodically sampled
subset of the full validator set and consist of 512 validators
who generate a supplementary signature of each block that
is used for synchronization by resource constrained devices.
Furthermore, sync committees are stable during a sync com-
mittee period, which is two orders of magnitude longer than
a validator set epoch, and thus requires less frequent updates.
Successive sync committees are sampled one period in ad-
vance. Since every block references both the currently valid
and the the following sync committee, the transition between
sync committees can be validated by light clients as long
at least one block is submitted within each sync committee
period.

Polkadot and Cosmos do not implement the concept of sync
committees, because the election of a validator set natively
selects a subset of stakers for validation [10], [24]. Thus, the
set sizes are limited and signature validation is tolerable to
light clients. In the following, we presume the utilization of
the full validator set where its size is limited and a sub-sample
such as a sync committee otherwise.

Block validation. To validate a block, the minimum number
of signatures must be checked, according to the consensus

TABLE I
REQUIRED DATA FOR A CHAIN RELAY UPDATE IN GENERIC CASE AND
SPECIFIC TO ETHEREUM 2.0

Generic
e Finalized

header

Ethereum 2.0
Finalized block header root btarget

block

Finality proof or
signature

Next validator set
Next validator set
signa-
proof or
ture

Latest block header root blatest
Merkle proof that btarget is ﬁnal
Multi-signature by vtrusted/vtrustedN ext
Next sync committee vnext
Merkle proof that vnext is the next validator
set according to btarget

t
a
d
p
u

y
r
e
v
E

t
e
s

r
o
t
a
d
i
l
a
V

e
t
a
d
p
u

protocol. In case of Ethereum 2.0, it is veriﬁed whether the
sync committee’s aggregated signature was generated by a
threshold of its members. Other implementations that do not
apply signature aggregation require a sufﬁcient amount of
signatures to be available. Therefore, transactions updating the
relay contract must submit the ﬁnalized block header that is
intended to be stored and a signature issued by the respective
validator set, as depicted in Table I.

If the signature validation succeeds, the chain relay substi-
tutes the currently stored block with the newly validated block.
Hereby, storage costs are reduced, as allocating new storage is
usually the most expensive operation in blockchains’ execution
environments [22]. Unlike Bitcoin or Ethereum 1.0, blocks in
Ethereum 2.0 contain Merkle roots that reference the complete
history. Thereby, historical states are retrievable based on a
single subsequent block.

In addition, if the new block is part of a new epoch, the
transition between both validator sets is veriﬁed and the old set
is replaced by the new one. New validator sets are either signed
in the previous epoch (Ethereum 2.0) or share signiﬁcant inter-
sections that can be used to verify transitions. For instance, in
the case of Cosmos, its security model assumes a minimum of
1
3 of honest validators. Submitted block headers must be within
a certain bound. According to the light client synchronization
protocol of Cosmos [20], a block successive block can be
validated by the chain relay as long as the previously stored
block was signed by an at least 1
3 of equivalent validators. In
case of Ethereum 2.0, at least one block out of each epoch is
required to verify the transition between validator sets. Every
chain relay update transaction that includes a block header
which was signed by a new validator set must also include the
subsequent validator set and a proof or signature attesting the
transition. Table I presents the required parameters for chain
relay updates within a single epoch and across epochs.

Accountable safety. Provided that the source blockchain
supports accountable safety,
the chain relay should retain
this property. As accountable safety can only be ensured
within the trusting period of the signing validator set, updates
must be submitted to the chain relay before the trusting
period elapses. Otherwise, the chain relay expires and must
be redeployed including an initial trusted validator set. This
is due to potentially unbonded stake that permits colluding

Fig. 1. The chain relay always maintains one block header that is currently active. Two block headers must be submitted to update the relay contract, the
target block and the latest block that ﬁnalizes it. The three involved block headers may be part of different sync committee periods, determining which sync
committee signs the latest block and if the sync committee transitions.

validators to sign blocks of multiple forks without being
held accountable. To retain accountable safety, observers must
additionally detect misbehavior and submit respective proofs
to the source blockchain that applies slashing.

If the source blockchain protocol does not include slashing,
the chain relay does not need to adhere to such boundaries.
Some protocols such as Etherum 2.0 apply accountable safety
to full validation, but not for sub-samples such as sync
committees, as misbehavior in such a subset would provide
only limited guarantees of accountability. Thus, the use of
sync committees for chain relay updates does not supply
accountable safety.

C. Ethereum 2.0 Relay

that

The consensus algorithm Gasper

is utilized by
Ethereum 2.0 implements two distinct concepts for block
production and ﬁnalization respectively, namely LMD GHOST
and PBFT inspired Casper FFG [9]. Casper FFG ﬁnalizes
checkpoints by collecting votes in two rounds that ﬁrst justify
a checkpoint before ﬁnalizing it. This process is derived from
the commit phases of PBFT and adapted to a permissionless
setting. In Ethereum 2.0, a checkpoint is deﬁned as the ﬁrst
block of an epoch and implicitly ﬁnalizes all preceding blocks.
Since votes are collected in succeeding blocks, checkpoints
are ﬁnalized as soon as a sufﬁcient amount of votes has been
collected. As Verilay aims for providing ﬁnalized blocks, two
blocks must be submitted for updating its state, the ﬁnalized
block vtarget which is to be stored by the relay contract and the
latest block vlatest that declares vtarget to be ﬁnalized. Every
block contains a reference to the currently active sync commit-
tee vtrusted and the subsequent sync committee vtrustedN ext.
The relay contract veriﬁes blatest by validating the signatures
according to either vtrusted or vtrustedN ext that are comprised
in the currently stored block bcurrent. Depending on the sync
committee periods the blocks fall into, three different scenarios
need to be considered, as illustrated in Figure 1.

In the ﬁrst case, all three blocks bcurrent, btarget and blatest
are part of the same sync committee period. Therefore, the
public keys of sync committee vtrusted included in bcurrent
are used to validate the block signature for blatest. As bcurrent
has been successfully veriﬁed before,
the referenced sync
committee is trusted as well. Since no sync committee update
is needed, only the block headers btarget and blatest, a Merkle
proof that btarget is ﬁnal according to blatest and a multi-
signature by vtrusted are required to update the chain relay, as
depicted in Table I.

In the second case, bcurrent and btarget are contained
in sync committee period vtrusted, while blatest is part of
the successive sync committee period vtrustedN ext. Thus,
vtrustedN ext referenced in bcurrent must be used to verify
the multi signature attesting the validity of blatest. Because
bcurrent and btarget reference equivalent sync committees,
there is no transition to a newly active sync committee. Even
though blatest includes a new sync committee reference, it is
not applied, as the block has not necessarily been ﬁnalized at
the time of submission. As a result, compared to case one, the
same data must be passed to apply an update, but a different
validator set is used for signature validation.

Lastly, bcurrent may be part of vtrusted, while btarget
and blatest are included within vtrustedN ext. Here, signature
validation is performed analogously to the one in case two.
However, a transition to a new validator set occurs, transi-
tioning former vtrustedN ext to vtrusted and accepting a new
set for vtrustedN ext. Thus, in addition to the the data that
must be submitted for every relay update, the succeeding sync
committee vnext and a Merkle proof that it is part of btarget
must be passed, as detailed in Table I.

IV. IMPLEMENTATION

We provide a prototypical implementation of Verilay that
enables the validation of Ethereum 2.0 beacon chain headers
on any EVM-compatible blockchain. Verilay is seperated into

vtrustedNextvtrusted…vtrustedNextvtrusted……vtrustedNextvtrusted…1. signsLatest final block…referencesbcurrentbtargetblatestcurrent blockin chain relaysubmitted tochain relay2./3. signsvtrusted activevtrusted activevtrusted activevtrustedNext activevtrustedNext active1st2nd3rdoptions:the relay contract that is hosted on the target blockchain and
an off-chain client. While the relay contract is responsible for
validation, the client retrieves block headers from the beacon
chain and prepares update transactions including respective
proofs. No authorization is required to update the relay state,
as submitted block headers are validated by the relay contract.
Any user motivated for updating the relay contract requires
access to a synchronized node of the source and target
blockchain. Verilay is available on GitHub6 under an open-
source license.

Each operation of the EVM has a cost assigned to it that
is measured in gas and payed by the transaction sender using
the host blockchain’s native currency [22]. To reduce costs
and enable lightweight updates, the Verilay contract requires
only fractions of a block to be submitted while maintaining
full veriﬁablity. Referenced parts are validated using Merkle
proofs that must be passed with every update. In contrast
to Ethereum 1.0 that uses a modiﬁed Merkle Patricia Tree
to represent block data, Ethereum 2.0 implements a concept
called SimpleSerialize (SSZ) for serializing data containers
that are represented in a binary Merkle tree [23]. As SSZ
utilizes SHA256, which is available as cost-effective pre-
compiled contract on Ethereum 1.0, for computing the Merkle
tree, respective proofs can be veriﬁed efﬁciently on-chain.

The Verilay client prepares the parameters according to
the requirements depicted in Table I. Both the latest and the
ﬁnalized block are represented by their Merkle root subsuming
their referenced content. The ﬁnalized block is referenced by
the latest submitted block as part of the current state, as
illustrated in Figure 2. Since the sync committee used for
validation is selected based on the block’s slot, the slot is
passed along with a respective Merkle proof of inclusion for
both latest block and ﬁnalized block.

Verilay provides two options for accessing the sync com-
mittee’s public keys during validation. Option one requires
passing the sync committee’s public keys with any update
transaction that results in the transition to a new sync com-
mittee. Thereafter, the relay contract validates the respective
Merkle proof and replaces the stored keys of the current sync
committee with the new ones. In Ethereum 2.0, the sync
committee consists of 512 members. Each member holds a
public keys that 48 byte long, resulting in a total size of
512∗48 byte = 24, 576 byte. As the update of a 32 byte storage
slot calls for 5, 000 gas, the lower bound for updating the
sync committee is 24,576 byte
∗ 5, 000 gas = 3, 840, 000 gas,
excluding validation, data processing and memory operations.
The stored keys are retrieved from storage and used for each
update’s validation within in the same sync committee period.
As storage operations require comparatively large amounts
of gas, we provide a second option that does not store the sync
committee in the contract, but demands all public keys to be
resubmitted with each update. The sync committee period only
determines which public key to pass and validate, but does not
affect the transaction’s number of attributes. Resubmission of

32 byte

Fig. 2. Simpliﬁed representation of required parameters in SSZ structure.
Bold borders and arrows represent the Merkle paths of involved attributes.

data to reduce storage costs has been proposed in literature
before [7], [25], but involved the calculation of a hash or
Merkle root on-chain. As the sync committee is part of the SSZ
Merkle tree, this step can be omitted by the Verilay contract.
In Section V, we show that option two is beneﬁcial even when
updates are submitted regularly.

Multiple steps are required to verify the signature of
the submitted latest block. First, the relay contract checks
whether a sufﬁcient amount of sync committee members have
participated. Ethereum 2.0 enables signature aggregation by
applying Boneh–Lynn–Shacham (BLS) multi-signatures based
on the BLS12-381 elliptic curve [23], [26]. Operations on
the BLS12-381 curve are conducted on 384-bit words. Since
the EVM operates on 256-bit words, the operations required
to validate BLS signatures can not be executed efﬁciently
by the virtual machine. To provide an efﬁcient alternative, a
proposal7 has been published to add a pre-compiled contract
to Ethereum 1.0 that executes BLS12-381 curve operations
outside the EVM. The pre-compiled contract will allow the
efﬁcient implementation of BLS signature validation within a
smart contract.

As neither the proposed pre-compiled contract nor an on-
chain signature validation library is available at the time of
writing, we extended the Go Ethereum (geth) client with a
customized pre-compiled contract that conducts validations
using the Herumi BLS library8. To validate a submitted
block header, the Verilay contract ﬁrst serializes the sync
committee’s public keys and the aggregated signature, before
calling the pre-compiled contract. If the signature is valid, all
Merkle proofs are checked to ensure the correct ﬁnalized block

6https://github.com/MaximilianDiez/PoSChainRelay

7https://eips.ethereum.org/EIPS/eip-2537
8https://github.com/herumi/bls

slotlatestblockstate…latest blockheaderslotfinal.blockstate…current sync committeefinalizedblock headernext sync committeeMerkle rootMerkle treenodedatacontainer……signatureis referenced and correct slots have been declared. Finally, the
currently stored block header is replaced with the submitted
ﬁnalized block header.

V. EVALUATION

In this section, we evaluate Verilay according to its quanti-
tative properties such as on-chain execution costs and design
design goals as deﬁned in Section III-A.

A. Quantitative Analysis

The chain relay’s applicability depends in particular on the
complexity of the associated on-chain computations. Complex
computations and high storage volumes increase transaction
costs and may render transactions impossible to be executed in
case they exceed the limits of a block on the target blockchain.
Therefore, we analyze transaction costs for deploying the relay
contract and applying regular updates. Since our chain relay
prototype operates on the EVM, we measure transaction costs
in gas, as deﬁned by the Ethereum protocol [22].

While the Ethereum 2.0 speciﬁcations deﬁne a sync com-
mittee size of 512, we also measure the costs of smaller
sizes that result in reduced costs. Even though our evaluation
proves the applicability of Verilay for standard conﬁgurations
of Ethereum 1.0 and 2.0, smaller sets may be applicable
depending on the case’s security requirements. Figure 3 depicts
the gas costs of three different conﬁgurations, using a reduced
sync committee size of 32, applying the full set with 512 mem-
bers while storing the set within the contract and resubmitting
the set with every update, as described in Section IV.

We observe that the one-time deployment of the contract
remains within the gas limits of the Ethereum mainnet. The
most gas is accounted for allocating storage for the sync
committee. Since the option to resubmit the set with every
update does not require this step,
the respective contract
deployment is signiﬁcantly cheaper, as illustrated in Figure 3.
Furthermore, all operations on the smaller set are cheaper, as
less storage operations and signature aggregations are required.
The most expensive transaction is an update that includes
a sync committee transition, as the respective public keys
must be passed and stored. As expected, transitions of the
sync committee are signiﬁcantly cheaper when resubmitting
the sync committee’s public keys with every update, as no
storage write operations are required. Interestingly, update
transactions that do not include such transitions also call for
less gas compared to stored public keys. Here, our results
deviate from the evaluation of a similar approach taken by
ETH Relay [7]. We attribute this deviation to the Istanbul
Hard Fork that included relevant changes to gas metering.
First, Ethereum Improvement Proposal (EIP)-18849 increased
the costs for reading a storage value from 200 gas to 600
gas. Second, EIP-201810 reduced the price for passing call
data from 68 gas to 16 gas. We conclude that the described
pattern is favorable when utilizing externally submitted data,
even when regular resubmission is required.

s
a
G

.
o
i
M
n
i

t
s
o
C

n
o
i
t
c
a
s
n
a
r
T

30

20

10

0

28.7

Block Gas Limit
(Eth. Mainnet)

Deployment
Update (B)
Update (B + SC)

17.8

17.7

17.6

12.7

7.7

1.6

0.9

3.3

32

512
Chain Relay Version

512 No-Store

Fig. 3. Measurements of the gas costs of deploying and updating different
chain relay conﬁgurations. 32, 512 and 512 No-Store refer to chain relay
versions for different sync committee sizes and whether the No-Store op-
timization was implemented. The current block gas limit on the Ethereum
mainnet is indicated. B: Block. SC: Sync Committee.

B. Design Goals

In the following, we analyze Verilay’s compliance with
the design goals introduced in Section III-A based on the
presented prototype.

• Forkless. Verilay utilizes sync committees that are part
of the Ethereum 2.0 protocol and does not require col-
laboration of validators that is explicit to the chain relay.
• Trustless. After bootstrapping the relay contract, trust is
solely derived from the source blockchain’s sync commit-
tee’s signature. As the validation is conducted on-chain,
no trust in entities executing updates is needed.

• Autonomous. Anyone having access to the source and
target ledger is enabled to submit updates by executing
the Verilay client.

• Robust. While Ethereum 2.0 applies a weakly subjective
consensus algorithm, sync committees do not hold this
property. Hence, its state can be updated after arbitrarily
long periods of inactivity. The relay may only stall in
case no valid sync committee signature is present for an
entire sync committee period.

• Corresponding. Since block headers are validated by
sync committee members and a majority of at least 2
3
is assumed to be honest, relayed block headers are also
assumed to be valid. Merkle branches can be used to
prove the inclusion of transactions, states and events.
• Lightweight. Verilay is lightweight as only a single block
must be submitted for each sync committee period. Since
such period subsumes 256 epochs of 32 slots, only a
single update is required every 8,192 blocks, involving
17.7 million gas. In comparison, a single block update
using BTC Relay calls for 194,000 gas11, resulting in
1,589,248,000 gas for an equivalent number of blocks.

9https://eips.ethereum.org/EIPS/eip-1884
10https://eips.ethereum.org/EIPS/eip-2028

11Exemplary transaction ID of a Bitcoin header submission in BTC relay:
0xe21099d8fd1252281389fc888f23f98e60db22ecb5c149ad6fda6dccdf110b50

VI. RELATED WORK

Multiple chain relay schemes have been proposed perform-
ing on-chain validation. BTC Relay was the ﬁrst chain relay
to be deployed in a live setting and enables the submission
of Bitcoin headers to Ethereum to prove the inclusion of
transactions [6]. For the relay to remain live, every single
block header between the latest state and target state must be
submitted. BTC relay incorporates an incentive mechanism by
attaching fees to derived inclusion proofs and distributing them
to block header relayers. However, the mechanism requires
high utilization, as many unused intermediary headers would
have to be submitted in order to maintain live otherwise. As
a result, BTC relay has stalled for more than 38 months since
the last block has been submitted at the time of writing.

zkRelay is a chain relay that also aims for the submission of
Bitcoin block headers to blockchains supporting the EVM, but
signiﬁcantly decreases execution costs compared to BTC relay
by conducting off-chain header validation [5]. Block headers
are combined in batches and veriﬁed in an off-chain program.
Correct program execution is ensured by utilizing zkSNARKs,
so that the on-chain smart contract only veriﬁes the correct
program execution, rather than the header chain itself. As the
validation costs of the zkSNARK proof are independent of the
off-chain program’s complexity [27], its efﬁciency increases
with large batch sizes. While zkRelay provides signiﬁcant
improvements compared to BTC relay, it targets the validation
of PoW and does not support PoS validation.

ETH relay constitutes a chain relay that links Ethereum with
any blockchain supporting the EVM [7]. Ethereum applies a
memory-hard PoW algorithm to prevent centralization tenden-
cies that originate from the use of customized hardware [22].
As on-chain validation of memory-hard algorithms is complex,
ETH relay follows an optimistic approach and accepts block
headers without veriﬁcation. Submitted headers are blocked
for a contesting period in which it can be challenged by
observers. Only in case of a challenge, the submitted block
header is validated on-chain and the submitter is slashed in
case fraudulent behaviour is detected. The optimistic approach
taken by ETH relay potentially decreases operational costs
signiﬁcantly, as costly validation operations are only con-
ducted in case of misbehaviour. Therefore, while targeting
PoW consensus algorithms in its current proposal, its general
concept may be applicable to PoS chain relays as well. Yet, as
the concept depends on observing intermediaries and sufﬁcient
incentivization for correct behaviour, trust in transferred block
headers is limited compared to full validation.

Gaˇzi et al. have proposed a sidechain mechanism for PoS-
based blockchains that does validate block headers of the
source blockchain, but operates on explicitly signed cross-
chain transactions [8]. A subset of the source blockchain’s val-
idator is sampled to create certiﬁcates that notarize cross-chain
transactions. The solution is tailored to cater for Nakamoto-
inspired PoS blockchains such as Cardano. Thus, different
assumptions are applied concerning ﬁnality and veriﬁability,
compared to Verilay. Furthermore, while generalizable, the

concept enables a speciﬁc use-case of transferring tokens. In
contrast, Verilay applies the source blockchain’s consensus
to maintain the source blockchain’s security properties and
enables inclusion proofs of arbitrary data.

VII. DISCUSSION

The evaluation of Verilay demonstrates the concept’s ap-
plicability under the assumption that signatures applied by
the source blockchain’s consensus protocol can be efﬁciently
validated. In case of Ethereum 1.0’s EVM, this will be the
case as soon as the respective EIPs are applied. Furthermore,
the number of signatures that must be validated needs to
be limited. Therefore, Ethereum 2.0’s validator set cannot be
efﬁciently validated and we rely on its light client protocol that
provides a sub-sample of predeﬁned size. Since misbehavior of
the sub-sample cannot be slashed, it is assumed that a majority
of the sync committee acts altruistically honest. Thus, the
security guarantees are inferior compared to the validation of
the full validator set. Yet, some PoS protocols that do not offer
accountable safety operate under similar assumptions [13].

Validator set changes constitute a challenge to Verilay if
they are not efﬁciently veriﬁable. As succeeding sync commit-
tees are signed by a trusted set in Ethereum 2.0, the chain relay
need not re-execute the sampling. PoS protocols that require
all blocks of an epoch in order to calculate the next validator
set may require the submission of all respective blocks to
the chain relay. Yet, this requirement may be alleviated if
the source blockchain’s protocol deﬁnes limited validator set
changes.

VIII. CONCLUSION

In this paper, we proposed Verilay, a chain relay that pro-
vides interoperability between PBFT-inspired Proof-of-Stake
blockchains and any blockchain that is capable of executing
smart contracts. We enable the submission of PoS block
headers to a relay contract without requiring trust
in the
executing entity, as submitted block headers are veriﬁed based
on the source blockchain’s consensus protocol. Since PBFT-
based PoS protocols provide ﬁnality, no fork handling is
required, and submitted blocks commit to the entire blockchain
history. Thus, Verilay requires only a single update during each
validator set period, providing a lightweight solution compared
to previous chain relay proposals.

The prototypical implementation of Verilay constitutes a
chain relay for the Ethereum 2.0 beacon chain and provides
a relay contract operating on the EVM. Our evaluation shows
that the proposed solution is viable without requiring changes
to the consensus protocol of Ethereum 2.0 or the EVM. Recent
blocks can be submitted upon their ﬁnalization by the source
blockchain’s consensus. Since only a single block must be
submitted during each sync committee period, which lasts 17.3
hours, execution costs decrease signiﬁcantly. Hereby, Verilay
demonstrates that PoS chain relays constitute a promising
solution for blockchain interoperability.

REFERENCES

[14] V. Buterin and V. Grifﬁth, “Casper the Friendly Finality Gadget,” CoRR,

[1] V. Buterin, “Chain Interoperability,” 2016.

wp-content/uploads/2017/06/chain interoperability r3.pdf
2021-09-02.

https://www.r3.com/
Accessed:

[2] J. Heiss, J. Eberhardt, and S. Tai, “From Oracles to Trustworthy Data
On-Chaining Systems,” in 2019 IEEE International Conference on
Blockchain (Blockchain), pp. 496–503, 2019.

[3] R. v. d. Meyden, “On the speciﬁcation and veriﬁcation of atomic
swap smart contracts (extended abstract),” in 2019 IEEE International
Conference on Blockchain and Cryptocurrency (ICBC), pp. 176–179,
2019.

[4] J. Xu, D. Ackerer, and A. Dubovitskaya, “A Game-Theoretic Analysis
of Cross-Chain Atomic Swaps with HTLCs,” in 2021 IEEE 41st
International Conference on Distributed Computing Systems (ICDCS),
pp. 584–594, 2021.

[5] M. Westerkamp and J. Eberhardt, “zkRelay: Facilitating Sidechains
using zkSNARK-based Chain-Relays,” in 2020 IEEE European Sym-
posium on Security and Privacy Workshops (EuroS&PW), pp. 378–386,
2020.

[6] “BTC Relay.” https://github.com/ethereum/btcrelay. Accessed: 2021-07-

14.

[7] P. Frauenthaler, M. Sigwart, C. Spanring, M. Sober, and S. Schulte,
“ETH Relay: A Cost-efﬁcient Relay for Ethereum-based Blockchains,”
in 2020 IEEE International Conference on Blockchain (Blockchain),
pp. 204–213, 2020.

[8] P. Gaˇzi, A. Kiayias, and D. Zindros, “Proof-of-Stake Sidechains,”
in 2019 2019 IEEE Symposium on Security and Privacy (SP), (Los
Alamitos, CA, USA), pp. 677–694, IEEE Computer Society, may 2019.
[9] V. Buterin, D. Hernandez, T. Kamphefner, K. Pham, Z. Qiao, D. Ryan,
J. Sin, Y. Wang, and Y. X. Zhang, “Combining GHOST and Casper,”
CoRR, vol. abs/2003.03052, 2020.

[10] G. Wood, “Polkadot: Vision for a Heterogeneous Multi-chain Frame-
https://polkadot.network/PolkaDotPaper.pdf Accessed:

work,” 2016.
2021-03-18.

[11] E. Buchman, J. Kwon, and Z. Milosevic, “The latest gossip on BFT

consensus,” CoRR, vol. abs/1807.04938, 2018.

[12] S. Nakamoto, “Bitcoin: A Peer-to-Peer Electronic Cash System,” 2008.

http://www.bitcoin.org/bitcoin.pdf. Accessed: 2021-05-02.

[13] C. Badertscher, P. Gaˇzi, A. Kiayias, A. Russell, and V. Zikas, “Ouroboros
genesis: Composable proof-of-stake blockchains with dynamic avail-
ability,” in Proceedings of
the 2018 ACM SIGSAC Conference on
Computer and Communications Security, CCS ’18, (New York, NY,
USA), p. 913–930, Association for Computing Machinery, 2018.

[23] “Ethereum Proof-of-Stake Consensus Speciﬁcations,” 2021.
github.com/ethereum/consensus-specs. Accessed: 2021-11-17.

https://

vol. abs/1710.09437, 2017.

[15] J. Kwon, “Tendermint: Consensus without Mining,” 2014. https://cdn.
relayto.com/media/ﬁles/LPgoWO18TCeMIggJVakt tendermint.pdf Ac-
cessed: 27.11.2018.

[16] A. Kiayias, A. Russell, B. David, and R. Oliynykov, “Ouroboros: A
provably secure proof-of-stake blockchain protocol,” in Advances in
Cryptology – CRYPTO 2017 (J. Katz and H. Shacham, eds.), (Cham),
pp. 357–388, Springer International Publishing, 2017.

[17] E. Deirmentzoglou, G. Papakyriakopoulos, and C. Patsakis, “A Survey
on Long-Range Attacks for Proof of Stake Protocols,” IEEE Access,
vol. 7, pp. 28712–28725, 2019.

[18] A. Stewart and E. Kokoris-Kogia, “GRANDPA: a Byzantine Finality

Gadget,” CoRR, vol. abs/2007.01560, 2020.

[19] M. Castro and B. Liskov, “Practical byzantine fault

tolerance,” in
Proceedings of the Third Symposium on Operating Systems Design and
Implementation, OSDI ’99, (USA), p. 173–186, USENIX Association,
1999.

[20] S. Braithwaite, E. Buchman,

I. Khofﬁ,

R. Ruetschi, and J. Widder, “A tendermint
vol. abs/2010.07031, 2020.

I. Konnov, Z. Milosevic,
light client,” CoRR,

[21] A. Zamyatin, N. Stifter, A. Judmayer, P. Schindler, E. Weippl, and
W. J. Knottenbelt, “A Wild Velvet Fork Appears! Inclusive Blockchain
Protocol Changes in Practice,” in Financial Cryptography and Data
Security, pp. 31–42, Springer Berlin Heidelberg, 2019.

[22] G. Wood, “Ethereum: a secure decentralised generalised transaction
ledger,” Ethereum Project Yellow Paper, 2021. https://ethereum.github.
io/yellowpaper/paper.pdf. Accessed: 2021-07-05.

[24] J. Kwon and E. Buchman,

- A Network of Dis-
tributed Ledgers,” 2019. https://github.com/cosmos/cosmos/blob/master/
WHITEPAPER.md. Accessed: 2021-12-02.

“Cosmos

[25] S. Daveas, K. Karantias, A. Kiayias, and D. Zindros, “A gas-efﬁcient
superlight bitcoin client in solidity,” in Proceedings of the 2nd ACM
Conference on Advances in Financial Technologies, AFT ’20, (New
York, NY, USA), p. 132–144, Association for Computing Machinery,
2020.

[26] D. Boneh, B. Lynn, and H. Shacham, “Short signatures from the weil
pairing,” in Advances in Cryptology — ASIACRYPT 2001 (C. Boyd, ed.),
(Berlin, Heidelberg), pp. 514–532, Springer Berlin Heidelberg, 2001.

[27] J. Eberhardt and S. Tai, “ZoKrates - Scalable Privacy-Preserving
Off-Chain Computations,” in 2018 IEEE International Conference on
Blockchain, pp. 1084–1091, July 2018.

