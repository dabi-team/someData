Efficient FPGA-based ECDSA Verification Engine for
Permissioned Blockchains
Ji Yang
jamiey@xilinx.com
Xilinx Research Labs
Xilinx, USA

Rashmi Agrawalâˆ—
rashmi23@bu.edu
Integrated Circuit and Systems Group
Boston University, USA

Haris Javaid
harisj@xilinx.com
Xilinx Research Labs
Xilinx, Singapore

1
2
0
2

c
e
D
4

]

R
C
.
s
c
[

1
v
9
2
2
2
0
.
2
1
1
2
:
v
i
X
r
a

ABSTRACT
As enterprises embrace blockchain technology, many real-world
applications have been developed and deployed using permissioned
blockchain platforms (access to network is controlled by allow-
ing only nodes with known identities). Such blockchain platforms
heavily depend on cryptography to provide a layer of trust within
the network, thus verification of cryptographic signatures often
becomes the bottleneck. The Elliptic Curve Digital Signature Algo-
rithm (ECDSA) is the most commonly used cryptographic scheme
in permissioned blockchains. In this paper, we propose an efficient
implementation of ECDSA signature verification on an FPGA, in
order to improve the performance of permissioned blockchains that
aim to use FPGA-based hardware accelerators.

In particular, we propose several optimizations for modular arith-
metic (e.g., custom multipliers and fast modular reduction) and
point arithmetic (e.g., significantly reduced number of point double
and addition operations, and optimal width NAF representation).
Based on these optimized modular and point arithmetic modules,
we propose an ECDSA verification engine that can be used by any
application for fast verification of ECDSA signatures. We further
optimize our ECDSA verification engine for Hyperledger Fabric
(one of the most widely used permissioned blockchain platforms)
by moving carefully selected operations to a precomputation block,
thus simplifying the critical path of ECDSA signature verification.
From our implementation on Xilinx Alveo U250 accelerator board
with target frequency of 250MHz, our ECDSA verification engine
can perform a single verification in 760ğœ‡ğ‘  resulting in a throughput
of 1, 315 verifications per second, which is ~2.5Ã— faster than state-
of-the-art FPGA-based implementations [8, 18]. Our Hyperledger
Fabric-specific ECDSA engine can perform a single verification in
368ğœ‡ğ‘  with a throughput of 2, 717 verifications per second.

KEYWORDS
ECDSA signature verification, FPGA, Hyperledger Fabric

1 INTRODUCTION
Beyond the hype, blockchain technology is emerging as one of the
most disruptive technologies, with real-world use cases in many
domains from digital identity management to financial services,
supply chains, and product provenance. The blockchain technology
essentially provides a mechanism to execute and record transac-
tions (representative of business logic) in an immutable ledger, by
grouping transactions into blocks and creating a hash-linked chain
of those blocks. The nodes in a blockchain network agree upon a
total order of the blocks and transactions in each block (consensus),
and each node maintains its own copy of the ledger, resulting in a

âˆ—Work done during internship at Xilinx.

distributed ledger. The beauty of blockchain technology is that it
seamlessly combines consensus mechanisms with cryptography to
provide a layer of trust for executing and recording transactions
within a network of mutually untrusting nodes.

Blockchains are generally categorized into two types. In public
blockchains, such as Bitcoin and Ethereum, any node can participate
in the network without a specific identity and proof-of-work based
consensus is used. Proof-of-work consensus is computationally
very intensive because of the massive amounts of hashes that need
to be computed, and thus becomes the bottleneck. Consequently,
public blockchains use hardware acceleration for hashing. For ex-
ample, Bitcoin network is dominated by ASIC based nodes while
GPU based nodes dominate the Ethereum network [29]. In permis-
sioned blockchains, on the other hand, only nodes with known
identities are part of and allowed to interact with the network,
while the consensus is delegated to only a few nodes (based on BFT
or CFT protocols [1]). Consequently, nodes are authenticated and
transactions are validated cryptographically, thus cryptographic
operations become the bottleneck rather than the consensus mech-
anism [35]. Typically, permissioned blockchains are deployed on
multi-core servers to benefit from some parallelism available across
processing of multiple transactions.

Since permissioned blockchains provide trust through crypto-
graphic authentication, and data integrity and replication through
distributed ledger, they are becoming increasingly popular for
implementation of enterprise applications. Many permissioned
blockchain platforms such as Hyperledger Fabric [13], Quorum [5]
and Corda [27] are now available. Fabric is an open-source and
enterprise-grade implementation of a permissioned blockchain,
and is one of the most widely used platforms with many real-world
applications already developed and deployed from finance and sup-
ply chain domains [6, 7].

In a Hyperledger (HL) Fabric network, one of the nodes is a
validator peer, which is responsible for validating a block and all of
its transactions, before committing that block to the ledger. Many
recent works [3, 9, 15, 35] have shown that validator peer is the
major bottleneck and critically affects the peak throughput. Some
of these works [3, 15, 36] further demonstrated that verification of
cryptographic signatures is the major bottleneck inside a validator
peer. By default, Fabric uses 256-bit ECDSA scheme for signature
generation and verification. Validation of a block involves veri-
fication of its creatorâ€™s ECDSA signature, and validation of each
transaction in a block involves verification of multiple ECDSA sig-
natures (from creator and different peers in the network). Similar
validation nodes exist in other permissioned blockchains such as
Quorum [5] and Hyperledger Besu [14] (permissioned variants of
Ethereum).

 
 
 
 
 
 
Hardware acceleration was recently proposed for validation of
blocks in permissioned blockchains, specifically HL Fabric. The
work in [16] proposed a CPU-FPGA based system where a multi-
core server with a network-attached FPGA card (connected to the
CPU via PCIe) is used to accelerate validator peer of a Fabric net-
work. All the compute-intensive operations of validation were of-
floaded to the FPGA accelerator, including verification of ECDSA
signatures. Although the work in [16] demonstrated an order of
magnitude speedup in block validation compared to CPU-only
implementation, interestingly enough, the ECDSA signature verifi-
cation still turned out to be the critical path in the FPGA accelerator.
Therefore, in this paper, we focus on an efficient FPGA-based im-
plementation of ECDSA signature verification, in order to improve
performance of permissioned blockchains that aim to use FPGA-
based accelerators.

More specifically, we focus on accelerating ECDSA signature
verification over NIST ğ‘ƒ-256 elliptic curve. Working with NIST ğ‘ƒ-
256 curve requires performing 256-bit modular and point arithmetic
operations. This is challenging to implement on FPGAs because 256-
bit wide multipliers, adders/subtractors, and dividers are not readily
available. Therefore, a naive implementation will lead to a resource
intensive design, leaving less resources for other operations of an
accelerator. This, in turn, makes it challenging to fit the entire
accelerator on an FPGA and meet the required timing constraints.
In particular, we make the following contributions:

â€¢ FPGA-specific optimizations for modular arithmetic: We
present algorithmic optimizations for modular arithmetic mod-
ules to enable optimized FPGA-based implementations. We specif-
ically propose a custom 256-bit multiplier for integer multiplica-
tion (used in modular multiplication) and a 258-bit multiplier for
Barrett reduction module. These multipliers efficiently leverage
internal multipliers and registers of the DSP blocks in FPGA
for better performance. We also propose an efficient algorithm
to perform fast modular reduction over ğ‘ƒ-256 without using
expensive 256-bit comparators.

â€¢ Algorithmic optimizations for point arithmetic: We present
optimizations for simultaneous-point and fixed-point multipli-
cation algorithms (used in ECDSA verification) by reducing the
overall number of point double and addition operations respec-
tively. We use projective Chudnovsky coordinate system along

Rashmi Agrawal, Ji Yang, and Haris Javaid

with optimal width for non-adjacent form (NAF) representation
to further reduce the total number of point arithmetic operations.
â€¢ HL Fabric-specific ECDSA verification: We present a fast
ECDSA signature verification engine by leveraging the fact that
the generator point G is fixed and the public key K can be
extracted in advance. This allows us to move a major chunk
of point arithmetic from ECDSA verification to a precompute
block. Consequently, the point arithmetic during actual ECDSA
computation reduces to just point addition operations, resulting
in a much faster signature verification.

We implemented our optimized ECDSA verification engines on
Xilinx Alveo U250 board [40] with a target frequency of 250MHz.
For modular arithmetic modules, we observe on average 1.5Ã— speed
up compared to [10], while for point arithmetic modules, we ob-
serve on average 3.2Ã— speedup compared to the state-of-the-art
implementations [10, 19, 21, 22, 31, 37]. Our ECDSA verification
engine, using these modules, performs a signature verification in
760ğœ‡ğ‘  resulting in a throughput of 1, 315 verifications per second,
which is ~2.5Ã— faster than the existing FPGA-based implementa-
tions [8, 18]. With HL Fabric-specific optimizations, our ECDSA
verification engine can perform a signature verification in 368ğœ‡ğ‘ 
resulting in a throughput of 2, 717 verifications per second.

2 BACKGROUND AND PRELIMINARIES
2.1 Blockchain Machine
Figure 1(a) depicts a simplified overview of hardware accelerator
for HL Fabric that was proposed in [16]. The blocks are received in
the FPGA accelerator card through the integrated network inter-
face. The first module, ProtocolProcessor, processes the incoming
packets and extracts relevant data, such as block id, number of trans-
actions in the block, ECDSA signatures, public keys from identity
certificates, etc. The second module, BlockProcessor, uses this data
to validate the block and its transactions, before committing the
transactions. Once a block is validated, the Fabric software running
on CPU accesses validation results from hardware and continues
on with committing the block to the ledger.

Internally, the BlockProcessor uses a configurable number of
ECDSA verification engines distributed across multiple stages to
process the ECDSA verifications as fast as possible. Each ECDSA
engine accepts a verification request in the form of {signature, key,

Figure 1: Blockchain Machine: (a) FPGA-based hardware accelerator, (b) Domain parameters for Hyperledger Fabric.

(a)                                                                            ServerFPGA CardBlockProcessorTxVerifyProtocolProcessorBlockVerify...ECDSAenginePacketProcessorDataProcessorHashCalc.DataWriterRegisterMapNetwork InterfaceCPUPCIeECDSAengineECDSAengineTxVscc...ECDSAengineECDSAengineTxCommit Elliptic curve parameter, a = -3 Generator point on the curve,                     = 6b17d1f2e12c4247 f8bce6e563a440f2      77037d812deb33a0 f4a13945d898c296    = 4fe342e2fe1a7f9b 8ee7eb4a7c0f9e16      2bce33576b315ece cbb6406837bf51f5  Order of the curve, n  n = ffffffff00000000 ffffffffffffffff      bce6faada7179e84 f3b9cac2fc632551 Prime P-256, p = 2256 - 2224 + 2192 + 296 - 1  p = ffffffff00000001 0000000000000000       00000000ffffffff ffffffffffffffff(b) Domain ParametersEfficient FPGA-based ECDSA Verification Engine for Permissioned Blockchains

hash}, where signature includes both its r and s components, key is
the public key of the signer with both x and y components, and hash
corresponds to the hash of message (e.g., block or transaction). Typi-
cally, the hash is computed as part of the ECDSA verification, but in
Blockchain Machine, it is precomputed by the ProtocolProcessor for
better performance. The work in [16] reported that a single ECDSA
verification was the slowest operation in their hardware accelerator.
Therefore, in this paper, we design an efficient FPGA-based ECDSA
verification engine that can be used inside the Blockchain Machine,
or similar hardware accelerators for permissioned blockchains.

2.2 ECC
An elliptic curve E over a prime field Fğ‘ is defined by a pair of
tuple (ğ‘¥, ğ‘¦) satisfying the Weierstrass equation

ğ‘¦2 = ğ‘¥ 3 + ğ‘ğ‘¥ + ğ‘

(1)

where ğ‘ and ğ‘ belong to a Galois field ğºğ¹ (ğ‘) with ğ‘ > 3 and
Fğ‘ = ğºğ¹ (ğ‘). Point arithmetic allows us to compute any point
Pğ‘– = (ğ‘¥ğ‘–, ğ‘¦ğ‘– ) on the elliptic curve. Addition of two points P and Q,
where P â‰  Q, is defined by R = P + Q. However, when P = Q,
point addition is performed as a point double operation, resulting
in 2P. Although point addition and double operations can be per-
formed in affine or projective coordinates, affine coordinates are
not preferred as they require expensive modulo inverse computa-
tions [18]. In this work, we focus on performing point addition and
point double operations in projective Chudnovsky coordinates [4]
where each point P is represented as a quintuple (ğ‘‹, ğ‘Œ , ğ‘, ğ‘ 2, ğ‘ 3),
which corresponds to the affine point (ğ‘¥ = ğ‘‹ /ğ‘ 2, ğ‘¦ = ğ‘Œ /ğ‘ 3). These
coordinates give a speed benefit over affine coordinates when the
cost for modulo inversion is significantly higher than the modular
multiplication. Therefore, we use projective Chudnovsky coordi-
nates because FPGAs have DSP blocks with multipliers that can
perform fast multiplications. The point addition and double equa-
tions in projective Chudnovsky coordinates are given in Table 1.
For NIST Prime curves, which include ğ‘ƒ-256 that is used in HL
Fabric, domain parameters are given in FIPS 186 âˆ’ 4 [23] and are
listed along with Figure 1(b) for reference.

Table 1: Point addition and double equations in projective
Chudnovsky coordinates.

Point Addition

)

, ğ‘ 3
2

(ğ‘‹1, ğ‘Œ1, ğ‘1, ğ‘ 2
1

, ğ‘ 3
, ğ‘‹2, ğ‘Œ2, ğ‘2, ğ‘ 2
2
1
2 , ğ‘ˆ2 = ğ‘‹2 âˆ— ğ‘ 2
ğ‘ˆ1 = ğ‘‹1 âˆ— ğ‘ 2
1
ğ‘†1 = ğ‘Œ1 âˆ— ğ‘ 3
2 , ğ‘†2 = ğ‘Œ2 âˆ— ğ‘ 3
1
ğ» = ğ‘ˆ2 âˆ’ ğ‘ˆ1, ğ‘… = ğ‘†2 âˆ’ ğ‘†1
ğ‘‹3 = ğ‘…2 âˆ’ ğ» 3 âˆ’ 2 âˆ— ğ‘ˆ1 âˆ— ğ» 2
ğ‘Œ3 = ğ‘… âˆ— (ğ‘ˆ1 âˆ— ğ» 2 âˆ’ ğ‘‹3) âˆ’ ğ‘†1 âˆ— ğ» 3
ğ‘3 = ğ» âˆ— ğ‘1 âˆ— ğ‘2
3 = ğ‘ 2
3 , ğ‘ 3
3 = ğ‘ 2
ğ‘ 2
3 âˆ— ğ‘3
, ğ‘ 3
Return(ğ‘‹3, ğ‘Œ3, ğ‘3, ğ‘ 2
3
3

)

Point Double
(ğ‘‹, ğ‘Œ , ğ‘, ğ‘ 2, ğ‘ 3)
ğ‘† = 4 âˆ— ğ‘‹ âˆ— ğ‘Œ 2
ğ‘€ = 3 âˆ— ğ‘‹ 2 + ğ‘ âˆ— (ğ‘ 2)2
ğ‘‹1 = ğ‘€2 âˆ’ 2 âˆ— ğ‘†
ğ‘Œ1 = ğ‘€ âˆ— (ğ‘† âˆ’ ğ‘‹1) âˆ’ 8 âˆ— ğ‘Œ 4
ğ‘1 = 2 âˆ— ğ‘Œ âˆ— ğ‘
ğ‘ 2
1 = ğ‘ 2
1
1 âˆ— ğ‘1
1 = ğ‘ 2
ğ‘ 3
Return(ğ‘‹1, ğ‘Œ1, ğ‘1, ğ‘ 2
1

, ğ‘ 3
1

)

3 RELATED WORK
In this section, we discuss the most relevant exisiting works in the
literature. There are many publications focusing on acceleration
of modular multiplication, point arithmetic for ECC, or ECDSA

signature verification in hardware. Overall, these hardware acceler-
ators can be broadly classified into three categories based on their
implementation platforms. First category includes reconfigurable
architectures that are FPGA-based [8, 10, 19, 30, 32, 34, 37], the sec-
ond category includes 8-bit AVR-based implementations [11, 20, 25]
for embedded devices that are resource constrained, and the third
category includes ASIC-based hardwired architectures [17, 18, 41]
to achieve high-performance for a specific elliptic curve.

Some of the works [30, 41] focus on elliptic curves over binary
fields ğºğ¹ (2ğ‘š) only. This is because the hardware implementation
of binary field operations results in a carry-free logic, and thus these
fields are the most optimal for use in hardware in terms of both
speed and area. Other works focus on elliptic curves over prime
fields ğºğ¹ (ğ‘), but perform hardware acceleration for a different field
size like 163-bits [32], 192-bits [20], or 224-bits [11], which is not of
interest to blockchain platforms that typically use 256-bits prime
field. There is also a wide range of work [10, 19, 25, 37] that focuses
on accelerating only point arithmetic for ECC over NIST ğ‘ƒ-256
elliptic curve, and do not implement the entire ECDSA verification.
Tachibana et al. [34] accelerate ECDSA verification algorithm
over Secp256k1 elliptic curve for Bitcoin on an Intel Cyclone IV
FPGA. Their single ECDSA verification takes about 145.52 ms. Glas
et al. [8] present an FPGA-based ECDSA core for 256-bits field using
Xilinx Virtex 5 FPGA board. The authors integrate their hardware
core in a vehicle-to-vehicle communication system and compare the
performance against microcontroller-based implementation. Ji et
al. [17] and KneÅ¾eviÄ‡ et al. [18] implement the ECDSA verification
algorithm over NIST ğ‘ƒ-256 elliptic curve as ASICs. However, Ji et
al. [17] did not report any latency numbers. We will present the
results from both [8] and [18] for comparison in Section 7.

In this work, we optimize modular arithmetic operations (specif-
ically multiplications) to utilize DSP blocks on FPGA and accelerate
point arithmetic operations over NIST ğ‘ƒ-256 elliptic curve, and then
combine these modules to implement an efficient ECDSA verifi-
cation engine (both generic and HL Fabric-specific). To the best
of our knowledge, our proposed architecture performs the fastest
ECDSA verification over NIST ğ‘ƒ-256 prime field on an FPGA (see
Section 7).

4 ECDSA VERIFICATION ALGORITHM
A sender sends the message digest ğ‘§ = ğ» (ğ‘š), the signature (ğ‘Ÿ, ğ‘ ),
and the public key K = (ğ‘¥ K, ğ‘¦K ), which are verified by the receiver.
It is assumed that the receiver knows the ECC domain parameters
(ğ‘, G = (ğ‘¥ G, ğ‘¦ G), ğ‘›, and ğ‘ described in Section 2.2). Algorithm 1
defines the ECDSA signature verification process, where the out-
put indicates whether the signature is valid or not. Typically, an
ECDSA verification algorithm computes the message digest, how-
ever we assume that the hash is precomputed to be aligned with
the Blockchain Machine architecture (the hash is computed by the
ProtocolProcessor module). Hence, the algorithm receives the com-
puted hash instead of the message. It is also worth noting that the
signature verification algorithm performs modular reductions with
respect to two different primes. For point arithmetic (line 7), the
prime ğ‘ is used, whereas for the rest of the operations (lines 4-6
and 8) order of the curve ğ‘› is used.

When we translate Algorithm 1 into a pictorial representation as
shown in Figure 2, it is evident that we need to implement modular

Algorithm 1: ECDSA Verification
Input: Message digest ğ‘§, the signature (ğ‘Ÿ, ğ‘ ),

and the public key K = (ğ‘¥ K, ğ‘¦K )

Output: Valid or invalid

Return(Invalid)

1: if (ğ‘Ÿ, ğ‘ ) not in range [1, ğ‘› âˆ’ 1] then
2:
3: end if
4: Compute ğ‘¤ = ğ‘ âˆ’1 mod ğ‘›
5: Compute ğ‘˜1 = ğ‘§ âˆ— ğ‘¤ mod ğ‘›
6: Compute ğ‘˜2 = ğ‘Ÿ âˆ— ğ‘¤ mod ğ‘›
7: Compute (ğ‘¥2, ğ‘¦2) = ğ‘˜1ğº + ğ‘˜2K
8: if ğ‘Ÿ == ğ‘¥2 mod ğ‘› then
Return(Valid)
9:
10: else
11:
12: end if

Return(Invalid)

arithmetic operations such as modulo inverse, multiplication and
reduction followed by various point arithmetic operations such as
point addition, double and scalar-point multiplication.

5 FPGA-BASED ECDSA VERIFICATION

ENGINE

In this section, we present the architecture of our efficient ECDSA
verification engine. We would like to highlight here that the ECDSA
signature verification algorithm deals with the information that is
publicly known, therefore there is no secret information to leak
through side-channels while performing a signature verification.
This widens our choice of algorithms for implementing various
modules within the ECDSA verification engine. Therefore, in our
hardware implementation, we select algorithms that utilize minimal
hardware resources while resulting in low latency.

5.1 Modular Arithmetic
To efficiently implement 256-bit wide modular arithmetic on an
FPGA, we implement all modular arithmetic modules using multi-
word integer arithmetic [12]. In multi-word arithmetic, a 256-bit
field element ğ‘ can be represented as

ğ‘Š ğ´[1] + ğ´[0]

ğ‘ = 2(ğ‘¡ âˆ’1)ğ‘Š ğ´[ğ‘¡ âˆ’ 1] + Â· Â· Â· + 22ğ‘Š ğ´[2] + 2

(2)
where, ğ‘Š and ğ‘¡ = 256/ğ‘Š define the word length and the number of
words to operate on respectively. We set the value of ğ‘Š diligently
for every operation to efficiently utilize the underlying resources
of an FPGA. For example, on Xilinx Alveo U250 FPGA board, the
multipliers are 16-bit wide and hence,ğ‘Š can be set as 16. The advan-
tages of using multi-word integer approach and setting the value of
ğ‘Š carefully are two-fold. First, it helps in performing the modular
operations using hardwired DSP blocks on the FPGA. Second, it
helps in achieving a higher maximum operating frequency for the
entire design.

Modular Subtraction: Subtraction in Fğ‘ can be performed using
Algorithm 2 [12] with multi-word integer approach. The adder/-
subtractor in DSP blocks have 48-bit wide inputs. However, for
multi-word integer approach, the maximum bit width we can use

Rashmi Agrawal, Ji Yang, and Haris Javaid

Figure 2: Operations in ECDSA signature verification.

is 32 bits (32 being the largest integer dividing 256 symmetrically).
Therefore, to use DSP for subtraction, we set the parameter ğ‘Š as
32 and thus, we have ğ‘¡ = 8 words to operate on. Along with each
subtraction operation, we subtract the previous carry bit and store
the next carry bit (line 3). As we operate on a single word at a time,
we utilize only one DSP block to implement the modular subtrac-
tion operation. We want to highlight here that point arithmetic
(including point double and add) in projective Chudnovsky coor-
dinate requires only one modular addition operation (see Table 1).
Therefore, we decided to perform the modular addition using our
modular subtraction module with 2â€²s complement input for the
second operand. Implementing a separate adder leads to inefficient
resource utilization as the adder will remain idle for most of the
time.

Algorithm 2: Subtraction in Fğ‘
Input: Modulus ğ‘, integers ğ‘, ğ‘ âˆˆ [0, ğ‘ âˆ’ 1], ğ‘¡ = 8
Output: ğ‘ = (ğ‘ âˆ’ ğ‘) mod ğ‘

(ğ‘ğ‘ğ‘Ÿğ‘Ÿğ‘¦, ğ¶ [ğ‘–]) â† ğ´[ğ‘–] âˆ’ ğµ [ğ‘–] âˆ’ ğ‘ğ‘ğ‘Ÿğ‘Ÿğ‘¦

1: Set (A[t-1],. . . ,A[0]) â† ğ‘, (B[t-1],. . . ,B[0]) â† ğ‘
2: (ğ‘ğ‘ğ‘Ÿğ‘Ÿğ‘¦, ğ¶ [0]) â† ğ´[0] âˆ’ ğµ [0]
3: for ğ‘– from 1 to ğ‘¡ âˆ’ 1 do
4:
5: end for
6: if ğ‘ğ‘ğ‘Ÿğ‘Ÿğ‘¦ = 1 then
7:
8: end if
9: Return(ğ‘)

add ğ‘ to ğ‘ = (ğ¶ [ğ‘¡ âˆ’ 1], . . . , ğ¶ [2], ğ¶ [1], ğ¶ [0])

Integer Multiplication Module: We adopt a hybrid approach to
integer multiplication through a combined schoolbook [28] and
Karatsuba-Ofman [12] approach. The motivation behind adopt-
ing a hybrid approach is as follows. Our target FPGA board has
DSP blocks with 27x18 bit wide multipliers. However, both multi-
word arithmetic and schoolbook algorithm require operands to be
split symmetrically (i.e., both operands must have the same base).
Therefore, the maximum we can use is 16x16 bit wide multiplier
to multiply two 256-bit operands (16 being the largest number
that can split 256 symmetrically). If we set ğ‘Š as 16, we will have
ğ‘¡ = 16 words to operate on, thus implementing just the schoolbook
multiplication algorithm [12] will lead to a high latency (at least
256 clock cycles), which is not acceptable as many multiplications
are performed in point arithmetic. Therefore, the use of hybrid
approach lowers the latency of a multiplication performed using
multi-word approach with schoolbook multiplication. The steps of
our proposed approach are shown in Algorithm 3.

w = s-1(mod n)Modulo Inversex2(mod n) = r?Comparisonk2 = r * w(mod n)ModularMultiplicationsrzvalidk1 = z * w(mod n)ModularMultiplicationk1   + k2   = (x2,y2)Point Additionk2Scalar-pointMultiplicationk1Scalar-pointMultiplicationEfficient FPGA-based ECDSA Verification Engine for Permissioned Blockchains

Algorithm 3: Hybrid Integer Multiplication
Input: Integers ğ‘, ğ‘ âˆˆ [0, ğ‘ âˆ’ 1], ğ‘¡ = 8, ğ‘™ = 16
Output: ğ‘ = (ğ‘.ğ‘)

1: Set (A[t-1],. . . ,A[0]) â† ğ‘, (B[t-1],. . . ,B[0]) â† ğ‘
2: Set C[i] â† 0 for 0 â‰¤ ğ‘– â‰¤ 2ğ‘¡ âˆ’ 1
3: for i from 0 to ğ‘¡ âˆ’ 1 do
4:

U â† 0
for j from 0 to ğ‘¡ âˆ’ 1 do

(ğ‘1, ğ‘0) â† A[i], (ğ‘1, ğ‘0) â† B[i]
ğ‘ğ‘ = ğ‘1ğ‘122ğ‘™ + [(ğ‘0 + ğ‘1)(ğ‘0 + ğ‘1) âˆ’ ğ‘1ğ‘1 âˆ’ ğ‘0ğ‘0]2ğ‘™ + ğ‘0ğ‘0
(U,V) â† C[i+j] + ab + U
C[i+j] â† V

5:

6:

7:

8:

9:

10:

end for
C[i+t] â† U

11:
12: end for
13: Return(c)

ğ‘™ + ğ‘0ğ‘0)

We first take the schoolbook multiplication algorithm and set
the parameter ğ‘Š as 32 (twice the input width of a multiplier in
DSP block) to split 256-bit operands into ğ‘¡ = 8 32-bit words. Next,
we target the 32-bit operands and split them into 16-bit operands
(see Figure 3) and multiply these 16-bit operands using Karatsuba-
Ofman equation as follows:
ğ‘ğ‘ = (ğ‘1ğ‘122ğ‘™ + [(ğ‘0 + ğ‘1)(ğ‘0 + ğ‘1) âˆ’ ğ‘1ğ‘1 âˆ’ ğ‘0ğ‘0]2
where ğ‘™ is 16. Moreover, as multiplication operations (line 7
in Algorithm 3) are independent, we unroll the loops in the algo-
rithm to perform multiplications and accumulations in parallel. As
a result, we can perform 256-bit integer multiplications in just 39
clock cycles using the schoolbook multiplication algorithm with the
Karatsuba-Ofman split to utilize the available wide multipliers in
DSP blocks efficiently. Note that various existing works [39, 42, 43]
(implementing different cryptographic schemes) exploit Karatsuba-
ofman/Karatsuba algorithm to perform modular multiplication on
an FPGA. Therefore, novelty of this work lies in the way we com-
bine schoolbook multiplication and Karatsuba-ofman algorithm
together to implement a low-latency, parallel multiplier.

(3)

Figure 3: Schoolbook+Karatsuba-Ofman multiplication ap-
proach.

Fast ğ‘ƒ-256 Modular Reduction Module: The result of an inte-
ger multiplication yields a 512 bits result that needs to be reduced
to 256 bits by performing modular reduction. In point arithmetic,
modular reduction is performed using the prime ğ‘ = ğ‘ƒ-256 while
other modular reductions in ECDSA verification engine are per-
formed using the other prime, i.e., the order of the curve ğ‘›. Modular
reduction with ğ‘› follows this discussion. Either ways, 256-bit mod-
ular reduction is very expensive to implement in hardware due to

Algorithm 4: Fast Reduction Modulo ğ‘ƒ-256 Algorithm
Input: A 512-bit integer ğ‘ = (ğ‘15, . . . , ğ‘2, ğ‘1, ğ‘0) in base 232
Output: ğ‘Ÿ = ğ‘ mod ğ‘ƒ-256
1: ğ‘ 1 = (ğ‘7, ğ‘6, ğ‘5, ğ‘4, ğ‘3, ğ‘2, ğ‘1, ğ‘0),
ğ‘ 2 = (ğ‘15, ğ‘14, ğ‘13, ğ‘12, ğ‘11, 0, 0, 0)
2: ğ‘Ÿ = ğ‘ 1 + ğ‘ 2, ğ‘Ÿ = (ğ‘Ÿ â‰¥ ğ‘) ? ğ‘Ÿ âˆ’ ğ‘ : ğ‘Ÿ
3: ğ‘Ÿ = ğ‘Ÿ + ğ‘ 2, ğ‘Ÿ = (ğ‘Ÿ â‰¥ ğ‘) ? ğ‘Ÿ âˆ’ ğ‘ : ğ‘Ÿ
4: ğ‘ 3 = (0, ğ‘15, ğ‘14, ğ‘13, ğ‘12, 0, 0, 0)
5: ğ‘Ÿ = ğ‘Ÿ + (ğ‘ 3 << 1), ğ‘Ÿ = (ğ‘Ÿ â‰¥ ğ‘) ? ğ‘Ÿ âˆ’ ğ‘ : ğ‘Ÿ
6: ğ‘ 4 = (ğ‘15, ğ‘14, 0, 0, 0, ğ‘10, ğ‘9, ğ‘8)
7: ğ‘Ÿ = ğ‘Ÿ + ğ‘ 4, ğ‘Ÿ = (ğ‘Ÿ â‰¥ ğ‘) ? ğ‘Ÿ âˆ’ ğ‘ : ğ‘Ÿ
8: ğ‘ 5 = (ğ‘8, ğ‘13, ğ‘15, ğ‘14, ğ‘13, ğ‘11, ğ‘10, ğ‘9)
9: ğ‘Ÿ = ğ‘Ÿ + ğ‘ 5, ğ‘Ÿ = (ğ‘Ÿ â‰¥ ğ‘) ? ğ‘Ÿ âˆ’ ğ‘ : ğ‘Ÿ
10: ğ‘ 6 = (ğ‘10, ğ‘8, 0, 0, 0, ğ‘13, ğ‘12, ğ‘11)
11: ğ‘Ÿ = ğ‘Ÿ âˆ’ ğ‘ 6, ğ‘Ÿ = (ğ‘Ÿ < 0) ? ğ‘Ÿ + ğ‘ : ğ‘Ÿ
12: ğ‘ 7 = (ğ‘11, ğ‘9, 0, 0, ğ‘15, ğ‘14, ğ‘13, ğ‘12)
13: ğ‘Ÿ = ğ‘Ÿ âˆ’ ğ‘ 7, ğ‘Ÿ = (ğ‘Ÿ < 0) ? ğ‘Ÿ + ğ‘ : ğ‘Ÿ
14: ğ‘ 8 = (ğ‘12, 0, ğ‘10, ğ‘9, ğ‘8, ğ‘15, ğ‘14, ğ‘13)
15: ğ‘Ÿ = ğ‘Ÿ âˆ’ ğ‘ 8, ğ‘Ÿ = (ğ‘Ÿ < 0) ? ğ‘Ÿ + ğ‘ : ğ‘Ÿ
16: ğ‘ 9 = (ğ‘13, 0, ğ‘11, ğ‘10, ğ‘9, 0, ğ‘15, ğ‘14)
17: ğ‘Ÿ = ğ‘Ÿ âˆ’ ğ‘ 9, ğ‘Ÿ = (ğ‘Ÿ < 0) ? ğ‘Ÿ + ğ‘ : ğ‘Ÿ
18: Return(ğ‘Ÿ )

large division operation. We observe that a single modular reduc-
tion using the % operator in Verilog requires about 57, 000 LUTs
on the target FPGA, which is quite expensive. Therefore, efficient
implementation of modular reduction is crucial to the design of an
ECDSA verification engine.

NIST recommends a fast modulo reduction ğ‘ƒ-256 algorithm [12]
as ğ‘ = ğ‘ƒ-256 is a general Mersenne prime [33]. The algorithm re-
places large division operations with simple additions and subtrac-
tions by exploiting the structure of this Mersenne prime. Therefore,
by using this algorithm, we can perform the 256-bit modular re-
duction using two left shifts (multiplication by 2), four additions,
and four subtractions. However, the result generated from this al-
gorithm can be in the range âˆ’4ğ‘ to 5ğ‘ instead of 0 to ğ‘. So we need
to perform a correction by either adding to the result or subtract-
ing from the result, a suitable value of ğ‘ within this range. This
correction step, however, requires performing many 256-bit com-
parisons to figure out the exact range in which the result lies. On
FPGAs, a 256-bit comparator leads to long carry chains impacting
the timing constraints of the design adversely. Therefore, to avoid
performing many large parallel comparisons at once, we check
the results immediately after each step of the computation. The
steps of our proposed fast modulo reduction ğ‘ƒ-256 algorithm are
shown in Algorithm 4. We can see that on line 2 of the algorithm
as we perform addition, we perform an immediate correction by
comparing the result of addition with ğ‘. Similarly, after subtraction
operation (lines 10, 12, 14, and 16), we compare the result with 0 to
see if it is negative and correct it accordingly.

From Algorithm 4, it is evident that we avoid using many 256-bit
wide comparators in parallel, but we still need a 256-bit comparator
to check if the intermediate result is â‰¥ ğ‘ or not. To avoid doing
so, we further exploit the structure of the Mersenne prime and

A[0]A[1]A[7]...B[0]B[1]B[7]...a1[0]a0[0]256-bits256-bits32-bits16-bits16-bitsb1[0]b0[0]32-bits16-bits16-bitsAlgorithm 5: Efficient Comparison with ğ‘ƒ-256
Input: A 257-bit integer ğ‘Ÿ with 0 â‰¤ ğ‘Ÿ < 2ğ‘, conditions ğ¶0, ğ¶1,

ğ¶2, and ğ¶3
Output: ğ‘Ÿ â‰¥ ğ‘
1: ğ‘Ÿ0 = &ğ‘Ÿ [95 : 0], ğ‘Ÿ1 = ğ‘Ÿ [191 : 96], ğ‘Ÿ2 = ğ‘Ÿ [223 : 192],

ğ‘Ÿ3 = &ğ‘Ÿ [255 : 224], ğ‘Ÿ4 = ğ‘Ÿ [256]

2: if (ğ‘Ÿ4 == 1 or (ğ‘Ÿ3 == ğ¶3 and ğ‘Ÿ2 > ğ¶2 or (ğ‘Ÿ2 == ğ¶2 and

ğ‘Ÿ1 > ğ¶1))) then

Return(greater)

3:
4: else if (ğ‘Ÿ4 == 0 and ğ‘Ÿ3 == ğ¶3 and ğ‘Ÿ2 == ğ¶2 and ğ‘Ÿ1 == ğ¶1

and ğ‘Ÿ0 == ğ¶0) then
Return(equal)

5:
6: end if

propose an efficient algorithm to perform this comparison with-
out actual 256-bit comparators. Our Algorithm 5 is based on the
following observation. We can split ğ‘ƒ-256 into four parts as follows:

ğ‘ƒ0 = ğ‘ƒ [95 : 0] = ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“
ğ‘ƒ1 = ğ‘ƒ [191 : 96] = 0, ğ‘ƒ2 = ğ‘ƒ [223 : 192] = 1
ğ‘ƒ3 = ğ‘ƒ [255 : 224] = ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“ ğ‘“

Using these four parts, we can generate the following four con-
ditions: ğ¶0 : &ğ‘ƒ0 = 1, ğ¶1 : ğ‘ƒ1 = 0, ğ¶2 : ğ‘ƒ2 = 1, ğ¶3 : &ğ‘ƒ3 = 1
Here, an AND (&) reduction on ğ‘ƒ0 gives a 1, ğ‘ƒ1 is 0, ğ‘ƒ2 is 1, and again
an & reduction on ğ‘ƒ3 gives a 1. The algorithm starts by splitting the
input integer ğ‘Ÿ in a similar fashion as ğ‘ƒ-256 and an additional ğ‘Ÿ4
for the 257ğ‘¡â„ bit (as the input integer is of 257-bits). First, we check
if ğ‘Ÿ4 is 1, then ğ‘Ÿ is definitely greater. However, if ğ‘Ÿ4 is 0, we need to
check for other conditions. If ğ‘Ÿ2 > 1 or ğ‘Ÿ1 > 0 (line 3), then we know
that ğ‘Ÿ > ğ‘ else if all the four conditions on line 5 are satisfied, then
ğ‘Ÿ = ğ‘. This algorithm converts 256-bit wide comparisons to four
1-bit comparisons and can be efficiently implemented in hardware
using bit-slicing and unary & operator.

Modular Reduction over ğ‘› using Barrett Reduction: We pro-
pose to use the standard Barrett reduction algorithm [12] for mod-
ulo reduction over the prime ğ‘›. Barrett reduction does not exploit
the structure of ğ‘› but computes ğ‘Ÿ = ğ‘§ mod ğ‘›, by computing a
value Ë†ğ‘, which when multiplied with ğ‘› and subtracted from ğ‘§ will
give the desired modular reduction value ğ‘Ÿ . The algorithm requires
selecting a base ğ‘, which when chosen as a power of two gives
an efficient implementation in hardware. We select ğ‘ as 4 and we
precompute the parameters of Barrett reduction (ğ‘˜ and ğœ‡) as these
parameters are fixed and do not change at any point in computation.
Our modified hardware-friendly version of the Barrett reduction is
shown in Algorithm 6. In our hardware implementation, the divi-
sion operations are performed using right shift operation (line 1)
and modular reductions are performed using AND operation (line
2). This optimization is possible because ğ‘ is a power-of-2 and for
powers-of-2, modular reduction can be efficiently done by masking
the lower-order bits using AND operation. Thus, we avoid all large
division operations. However, we need to perform two large 258-bit
multiplications as the parameter ğœ‡ is a 258-bit integer.

Rashmi Agrawal, Ji Yang, and Haris Javaid

Algorithm 6: Hardware-friendly Barrett Reduction
Input: ğ‘›, ğ‘ = 4, ğ‘˜ = âŒŠlogğ‘ ğ‘›âŒ‹ + 1, 0 â‰¤ ğ‘§ < ğ‘2ğ‘˜ , and ğœ‡ = âŒŠ ğ‘2ğ‘˜
ğ‘› âŒ‹
Output: ğ‘§ mod ğ‘›

1: Ë†ğ‘ â† (ğ‘§ >> 2(ğ‘˜ âˆ’ 1)).(ğœ‡ >> 2(ğ‘˜ + 1))
2: ğ‘Ÿ â† ğ‘§ & (ğ‘ğ‘˜+1 âˆ’ 1) âˆ’ Ë†ğ‘.ğ‘› & (ğ‘ğ‘˜+1 âˆ’ 1)
3: if (ğ‘Ÿ < 0) then
ğ‘Ÿ â† ğ‘Ÿ + ğ‘ğ‘˜+1
4:
5: end if
6: while (ğ‘Ÿ â‰¥ ğ‘›) do
ğ‘Ÿ â† ğ‘Ÿ âˆ’ ğ‘›
7:
8: end while
9: Return(ğ‘Ÿ )

For 258-bit multiplication, we again use the hybrid approach pro-
posed in Algorithm 3. However, we set the parameter ğ‘Š = 6 and
split the input operands into 43-bit multi-word integers. In addition,
instead of a single Karatsuba-Ofman split as in Algorithm 3, we
perform a two-level Karatsuba-Ofman split to efficiently leverage
the DSP blocks for 43-bit multiplications. At level-1, we split 43-bit
operands into 32- and 11-bit integers. Then at level-2, we again split
32-bit integers into 16-bit integers (see Figure 4). Thus, effectively
we perform only 16-bit Ã— 16-bit, 16-bit Ã— 11-bit, and 11-bit Ã— 11-bit
multiplications instead of 43-bit multiplication. For example, a 43-
bit multiplication can be performed as follows:

Step-1: Split ğ´[42 : 0] into ğ‘0 â† ğ´[10 : 0] and ğ‘1 â† ğ´[42 : 11]
Step-2: Split ğµ [42 : 0] into ğ‘0 â† ğµ [10 : 0] and ğ‘1 â† ğµ [42 : 11]
Step-3: ğ‘ˆ0, ğ‘0 â† ğ‘0 âˆ— ğ‘0 // 11-bitÃ—11-bit multiplication
Step-4: ğ‘ˆ1, ğ‘1 â† (ğ‘0 âˆ— ğ‘1) + ğ‘ˆ0 // 11-bitÃ—32-bit multiplication
Step-5: ğ‘ˆ2, ğ‘2 â† ğ‘1 + (ğ‘1 âˆ— ğ‘0) // 11-bitÃ—32-bit multiplication
Step-6: ğ‘ˆ3, ğ‘3 â† (ğ‘1 âˆ—ğ‘1) +ğ‘ˆ1 +ğ‘ˆ2 // 32-bitÃ—32-bit multiplication
Step-7: ğ‘ â† (ğ‘ˆ3, ğ‘3, ğ‘2, ğ‘0) // 86-bit multiplication result

In steps-4 and 5 above, we need to perform an 11-bit Ã— 32-bit mul-
tiplication, which we further simplify as follows:

Step-1: Assign ğ‘1ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ â† ğ‘1 [15 : 0] and ğ‘1â„ğ‘–ğ‘”â„ğ‘’ğ‘Ÿ â† ğ‘1 [31 : 16]
Step-2: Pad a 0 (in MSB) to ğ‘0 to make it 12-bits
Step-3: ğ‘Ÿğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ â† ğ‘1ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ âˆ— ğ‘0 // ğ‘Ÿğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ is 28-bits
Step-4: ğ‘Ÿâ„ğ‘–ğ‘”â„ğ‘’ğ‘Ÿ â† ğ‘1â„ğ‘–ğ‘”â„ğ‘’ğ‘Ÿ âˆ— ğ‘0 // ğ‘Ÿâ„ğ‘–ğ‘”â„ğ‘’ğ‘Ÿ is 28-bits
Step-5: ğ‘Ÿğ‘šğ‘–ğ‘‘ â† ğ‘Ÿğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ [27 : 16] + ğ‘Ÿâ„ğ‘–ğ‘”â„ğ‘’ğ‘Ÿ [11 : 0] // ğ‘Ÿğ‘šğ‘–ğ‘‘ is 13-bits
Step-6: ğ‘Ÿâ„ğ‘–ğ‘”â„ğ‘’ğ‘Ÿ â† ğ‘Ÿâ„ğ‘–ğ‘”â„ğ‘’ğ‘Ÿ [26 : 12] + ğ‘Ÿğ‘šğ‘–ğ‘‘ [12]
Step-7: ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ â† (ğ‘Ÿâ„ğ‘–ğ‘”â„ğ‘’ğ‘Ÿ [26 : 12], ğ‘Ÿğ‘šğ‘–ğ‘‘ [11 : 0], ğ‘Ÿğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ [15 : 0])

Figure 4: Proposed 258-bit multiplication approach.

A[0]A[1]A[5]...B[0]B[1]B[5]...a1[0]a0[0]258-bits258-bits43-bits11-bits32-bitsb1[0]b0[0]43-bits11-bits32-bitsa1H[0]a1L[0]16-bits16-bitsb1H[0]b1L[0]16-bits16-bitsLevel-1 Karatsuba splitLevel-2 Karatsuba splitb0[0]11-bitsa0[0]11-bitsEfficient FPGA-based ECDSA Verification Engine for Permissioned Blockchains

Note that in step-5 above, ğ‘Ÿğ‘šğ‘–ğ‘‘ is 13 bits instead of 12 bits to ac-
count for an additional carry bit after addition. Note that although
the steps listed above are specific to a 43-bit multiplier, they can
be generalized to any bit-width that is not a multiple of the DSP
multiplierâ€™s input bit-width (assumed 16 in our case) and then can
be efficiently implemented leveraging the DSP blocks.

Modulo Inverse Module: NIST recommends using Extended Eu-
clidean algorithm [23] to compute modulo inverse in ECDSA veri-
fication algorithm. However, extended Euclidean algorithm is ex-
pensive to implement in hardware requiring 256-bit division and
multiplication to compute quotient and remainder respectively. Sec-
ond popular option, the Fermatâ€™s theorem [38] is comparatively
efficient to implement in hardware as it requires only multiplica-
tions. However, it involves 267 modular multiplications leading
to a higher latency. Fermatâ€™s theorem approach is more suitable
when a side-channel resistant implementation (computation time
is independent of the input) is a must.

We choose to implement an optimized, faster modulo inverse
algorithm proposed by Chen and Qin [2]. This algorithm is suitable
for hardware implementation as it has very low resource footprint
and also incurs a low latency. The algorithm computes a modulo
inverse using only right shift and addition operations and at any
given time only two 256-bit adders are operating in parallel. We
observe that the latency of this algorithm ranges from 35-600 clock
cycles depending on the input, however for real test cases, the la-
tency averages close to 550 clock cycles across multiple evaluations.
It is worth noting that we modified the actual algorithm to take
modulus as an input because we leverage the same algorithm to
perform modulo inverse with respect to ğ‘› (line 4 of Algorithm 1)
as well as to convert projective Chudnovsky coordinates back to
affine coordinates wherein we need to compute modulo inverse
with respect to ğ‘.

5.2 Point Arithmetic
During ECDSA signature verification, we need to perform two
scalar-point multiplications and one point addition operation (line
7 in Algorithm 1). We first present our generic approach to point
arithmetic that can be leveraged in any application requiring fast
ECDSA signature verification. We will discuss our optimized Hyper-
ledger Fabric-specific point arithmetic approach later in Section 6.
We leverage the simultaneous-point multiplication (SPM) Al-
gorithm 7, also known as â€œShamirâ€™s trickâ€, to operate on both the
generator point (P) and public key coordinates (Q) at the same time.
In addition, this algorithm eliminates the need to perform the point
addition separately. We conducted an analysis on how the number
of operations varies when different point representations such as
binary, NAF, joint-sparse form (JSF), and width-ğ‘¤ NAF are used in
Algorithm 7. Table 2 shows that point double operations largely
remain the same while point addition operations can be reduced
to as low as 112 when width-ğ‘¤ NAF is used. Note that width-ğ‘¤
NAF conversion can be done in hardware using the algorithm-3.35
from [12], and is trivial in comparison to point arithmetic. We use
ğ‘¤ = 4 to keep the storage requirements minimal.

In Algorithm 7, point double operation (line 6) and point addi-
tions (lines 8, 10, 13, 15) cannot be done in parallel as they depend

Algorithm 7: Width-ğ‘¤ NAF method for SPM
Input: Width ğ‘¤, integers ğ‘˜1 and ğ‘˜2, points P and Q
Output: ğ‘˜1P + ğ‘˜2Q
1: Compute: ğ‘–P and ğ‘–Q for ğ‘– âˆˆ {1, 3, . . . , 2ğ‘¤ âˆ’ 1}
2: Compute ğ‘ ğ´ğ¹ğ‘¤ (ğ‘˜1) and ğ‘ ğ´ğ¹ğ‘¤ (ğ‘˜2)
3: ğ‘™ = ğ‘šğ‘ğ‘¥ {â„“1, â„“2} where â„“1 and â„“2 are lengths of ğ‘ ğ´ğ¹ğ‘¤ (ğ‘˜1) and

ğ‘ ğ´ğ¹ğ‘¤ (ğ‘˜2)

4: A = âˆ
5: for ğ‘– from ğ‘™ âˆ’ 1 down to 0 do
6: A = 2A
7:

if ğ‘˜1 [ğ‘–] > 0 then

8:

9:

10:

11:

12:

13:

14:

15:

A = A + ğ‘˜1 [ğ‘–]P

else

A = A âˆ’ ğ‘˜1 [ğ‘–]P

end if
if ğ‘˜2 [ğ‘–] > 0 then

A = A + ğ‘˜2 [ğ‘–]Q

else

A = A âˆ’ ğ‘˜2 [ğ‘–]Q

end if
16:
17: end for
18: Return(A)

Table 2: Number of point arithmetic operations in SPM.

Representation

Point double

Point add

Binary
NAF
JSF
width-ğ‘¤ NAF (ğ‘¤ = 4)

256
256
256
257

193
148
130
~112

on each other. However, we reduce the number of these operations
by computing various values of G (3G, 5G, 7G, 9G, 11G, 13G, 15G)
offline and storing them in BRAM because G is known in advance.
This requires 1120 bytes of storage space but reduces the com-
putation of line 1 to only K (3K, 5K, 7K, 9K, 11K, 13K, 15K) in
hardware. For these values, 3K is computed by performing a point
double on K followed by a point addition. We store the 2K value
temporarily and reuse it; for example, 5K is computed by perform-
ing a point addition between 3K and 2K. Therefore, we only need
one point double and seven point addition operations in hardware
to compute all the required values. Overall, we significantly reduce
the number of point double and addition operations with the use of
width-ğ‘¤ NAF, and offline and optimized computation for G and K.

5.3 ECDSA Verification Engine
Figure 5(a) depicts the architecture of our generic ECDSA verifi-
cation engine, using the modular and point arithmetic modules
described earlier. We instantiate only one module corresponding
to a unique modular arithmetic operation to keep the resource
utilization low. Figure 5(b) depicts the data flow in the ECDSA
verification engine using SPM algorithm. Even with single instan-
tiation of the modular arithmetic modules, we leverage as much
parallelism as possible by scheduling different operations in par-
allel to efficiently utilize the hardware resources. For example, we

Rashmi Agrawal, Ji Yang, and Haris Javaid

Figure 5: Generic ECDSA verification engine: (a) Architecture (b) Data flow.

perform the ğ‘ ğ´ğ¹ğ‘¤ (ğ‘˜2) conversion in parallel with the second mod-
ular multiplication. Similarly, ğ‘ ğ´ğ¹ğ‘¤ (ğ‘˜1) conversion happens in
parallel to the computation on line 1 in Algorithm 7. Thus, no addi-
tional clock cycles are spent in NAF conversions. From amongst all
the modules, integer multiplication and modular reduction are the
heavily utilized modules.

It is worthwhile to reiterate that an additional point addition op-
eration is not required in this implementation because it is absorbed
in the SPM operation. However, after the multiple-point multiplica-
tion operation, we need an additional operation to convert ğ‘¥ from
projective Chudnovsky coordinate back to affine coordinate for
final comparison.

6 ECDSA VERIFICATION FOR HL FABRIC
In this section, we propose optimizations in the context of permis-
sioned blockchains specifically HL Fabric. We exploit the fact that
some parameters are fixed apriori while other parameters are avail-
able in advance, and hence both of these can be preprocessed to
speedup ECDSA verification operation. More specifically, we take
advantage of the fact that the generator point G is fixed and the pub-
lic key coordinates K = (ğ‘¥ K, ğ‘¦K ) are known well in advance before
the ECDSA verification starts. The ProtocolProcessor in Blockchain
Machine (see Figure 1) processes the incoming data and extracts
the public key and ECDSA signature information. Therefore, as
soon as the public key coordinates are available, we can start pro-
cessing them. With this goal in mind, we leverage the fixed-point
multiplication (FPM) algorithm (refer Algorithm 8) to perform point
arithmetic instead of simultaneous-point multiplication algorithm.

Algorithm 8: Fixed-base NAF windowing method for FPM
Input: Window width ğ‘¤, ğ‘‘ = 256/ğ‘¤, ğ‘˜, point P
Output: ğ‘˜ P
1: Precompute: Pğ‘– = 2ğ‘¤ğ‘– P, 0 â‰¤ ğ‘– â‰¤ ğ‘‘
2: Compute NAF(ğ‘˜)
3: ğ¼ = (2ğ‘¤+1 âˆ’ 2)/3
4: A = âˆ, B = âˆ
5: for ğ‘— from ğ¼ down to 1 do
6:

For each ğ‘– for which ğ‘˜ğ‘– = ğ‘— do B = B + Pğ‘–
For each ğ‘– for which ğ‘˜ğ‘– = âˆ’ğ‘— do B = B âˆ’ Pğ‘–

7:
8: A = A + B
9: end for
10: Return(A)

The algorithm starts by precomputing various powers-of-2 point
multiplications for a point P which is known apriori (for example,
when ğ‘¤ = 4, then precomputations will be P, 16P, 256P, and so
on). As the generator point is fixed, we precompute these values
offline and store the values in the BRAM on FPGA. For the public
key coordinates, we design a separate precompute block, outside
of the ECDSA verification engine, which runs binary scalar-point
multiplication algorithm (algorithm-3.27 in [12]) with point double
operations only to precompute the values mentioned earlier (i.e.,
P,16P, etc). Point addition operations are not required as we are
computing power-of-2 point multiplications only, which can be
computed using successive point double operations. We further
optimize the precompute block by reducing the number of point
double operations that it needs to perform. For example, if we want
to compute 256P, we need not start point double operations all
the way from P. Instead, we can use the value of 16P that was
computed in the previous step, thus reducing the number of point
double operations from ğ‘¤ğ‘– to ğ‘¤ in each step ğ‘– where 0 â‰¤ ğ‘– â‰¤ ğ‘‘. This
optimization helps reduce the number of point double operations
from over 8000 to only 252 when ğ‘¤ = 4 and ğ‘‘ = 64.

The precompute block computes the required point values for
public key and stores them in the BRAM. The computation within
the actual ECDSA verification reduces to lines 4-8 in Algorithm 8.
Consequently, ECDSA verification comprises of just point addition
operations with the point double operations moved to precompu-
tation. We use the fixed-base (with base ğ‘¤ = 4) NAF windowing
method to reduce the number of point addition operations. Note
that the fixed-point multiplication algorithm is executed twice;
once for the generator point G accessing offline computed point
values in line 1, and second time for the public key K accessing
precomputed point values in line 1.

Figures 6 and 7(a) show the architecture of our HL Fabric-specific
ECDSA verification engine. The precompute block is placed inside
the ProtocolProcessor to store all the required point values in BRAM.
With projective Chudnovsky coordinates, we need about 20ğ¾ğµ of
memory to store all the precomputed point values (including point

Figure 6: Integration of Precompute with ProtocolProcessor.

ModuloInverseCompareNAFw(k1)Modular Mult.IntegerMult.BarrettReductionModularMult.IntegerMult.BarrettReductionAffineConversionModuloInverseIntegerMult.ModularReductionSimultaneous-pointMultiplicationPointAddPointDoublesrzvalidNAFw(k2)Memory (BRAM)Control Unit (FSM)ModuloInverseModularReductionIntegerMultiplicationModularSubtractionBarrettReduction43-bitMultiplierMemory (BRAM)(a)(b)ProtocolProcessorPacketProcessorDataProcessorHashCalc.DataWriterPrecomputefor ECDSAPointsStorage(BRAM)Efficient FPGA-based ECDSA Verification Engine for Permissioned Blockchains

Figure 7: ECDSA verification engine with Precompute block: (a) Architecture (b) Data flow.

G and K). In a permissioned blockchain like HL Fabric, the number
of nodes are limited and hence the number of unique identities
(public keys) is limited and those identities are known apriori. In
a typical HL Fabric network, there may only be tens of unique
identities, thus storage of precomputed points will not incur a high
memory overhead. The precompute block has its own modular
arithmetic modules and the finite state machine (FSM) controlling
the movement of data between these modules. The ECDSA verifi-
cation engine has its own set of modular arithmetic modules. We
again instantiated only one module per modular arithmetic opera-
tion to keep the resource utilization low. This is beneficial especially
in Blockchain Machine where it is desirable to have many ECDSA
verification engines within the BlockProcessor module.

Figure 7(b) depicts the data flow in our ECDSA verification en-
gine with the precompute block. The precomputed points are read
from the BRAM by the ECDSA verification engine. The read from
BRAM is not a bottleneck as read will happen once in a while and
then hundreds of clock cycles are spent on processing the data.
Since the number of unique public keys is limited, the precom-
pute block is executed only when a new public key is encountered
and the precomputed values are stored in the BRAM. Hence, the
precompute block does not become the bottleneck. Both in precom-
pute and ECDSA verification engine, with single instantiation of
the modular arithmetic modules, most operations are performed
serially. However, we leverage as much parallelism as possible by
scheduling different modular operations in parallel. For example,
the NAF conversion of ğ‘˜2 happens in parallel with the second mod-
ular multiplication involving ğ‘˜1. Similarly, the NAF conversion of
ğ‘˜1 also happens in parallel with the first fixed-point multiplication.
After the fixed-point multiplication, a point addition operation
is required (line 7 of Algorithm 1) and conversion back to affine
coordinates for comparison.

7 EVALUATION
We designed our ECDSA verification engine and all of its modules
in Verilog 2001 and synthesized the design using Xilinx Vivado de-
sign suite 2019.2. For functional verification, we generated the test
cases using open-source code from OpenSSL library [26] and also
from the actual data, i.e., public key, signature, and hash used in Hy-
perledger Fabric. We also successfully verified the test vectors [24]

from NIST for ğ‘ƒ-256 (along with SHA-256) ECDSA signature verifi-
cation. We implement the design on Xilinx Alveo U250 FPGA. We
synthesize our design on this FPGA board because blockchains are
typically deployed on a cloud server with FPGA accelerator card.
Since our goal is to integrate the ECDSA engine into a blockchain
hardware accelerator [16], which is quite complex and operates at
250 MHz frequency, we limit the operating frequency of our ECDSA
verification engine to 250 MHz even when it is possible to obtain
higher frequencies with DSP blocks like in [10]. This restriction on
frequency will also enable better scalability within the blockchain
accelerator by instantiating multiple ECDSA engines for distributed
computation.

Throughout this section, we report frequency (freq.) in MHz, la-
tency in clock cycles, and throughput (TP) in operations per second.
When comparing our work with existing state-of-the-art implemen-
tations, we cautiously compare the clock cycles of different designs
instead of absolute runtimes to overcome the inherent improve-
ments from upgraded technologies and operating frequencies, and
hence provide a fair comparison. In an ideal situation, the existing
works should have been implemented on the Alveo U250 FPGA
board as well. However, those designs are not open-source and
implementation of each requires significant effort. Furthermore,
we do not present direct comparison results with CPU/GPU im-
plementations because our goal is not to compete with CPU/GPU
implementations but to provide the best FPGA implementation that
can be used in accelerators for permissioned blockchains (since
they are naturally suitable for FPGA based acceleration [16]).

7.1 Modular Arithmetic
We start by discussing the area footprint and latency of the individ-
ual modular arithmetic modules as listed in Table 3. With all the
proposed optimizations, our modular arithmetic modules incur low
resource utilization. The integer multiplication module consumes
the most LUTs, which can be reduced using BRAM-based optimiza-
tions. We, however, leave this optimization for future work. Most
modules perform fast computations except for Barrett reduction
which has the highest latency because of two serial 258-bit multipli-
cations. We made this design choice to keep the hardware resource
utilization low. Moreover, modular reduction using Barrett reduc-
tion is performed only in lines 5, 6, and 8 of Algorithm 1, which is
not the critical path (line 7 is the critical path in ECDSA verification).

Memory (BRAM)Memory (BRAM)Memory (BRAM)Memory (BRAM)Precompute for KeyBinary-point MultiplicationPoint DoublePointAddModuloInverseCompareNAF(k2)NAF(k1)ModularMult.IntegerMult.BarrettReductionModular Mult.IntegerMult.BarrettReductionFixed-point Mult.PointAddFixed-point Mult.PointAddAffineConversionModuloInverseIntegerMult.ModularReductionMemory (BRAM)srzvalidECDSA Verification EngineControl Unit (FSM)ModuloInverseModularReductionInteger Mult.ModularSubtractionBarrettReduction43-bitMultiplierMemory (BRAM)PrecomputeModularReductionInteger Mult.ModularSubtractionMemory (BRAM)ControlUnit (FSM)(a)(b)Table 3: Hardware results of various modular arithmetic
modules.

Operation

Modular subtraction
Integer multiplication
ğ‘ƒ-256 Modular Reduction
Barrett Reduction
Modulo Inverse

LUT

616
5471
2225
2130
3503

FFs

DSP

Latency

781
7980
789
3597
1313

1
128
0
9
0

10
39
19
1, 552
550

Table 4: Performance comparison of point arithmetic.

Platform

Freq.

Latency

TP

Operation

PA [Our work]
PA [10]

PD [Our work]
PD [10]

PM [Our work]
PM [10]
PM [37]
PM [19]
PM [22]
PM [21]
PM [31]

Alveo U250
Virtex-4

Alveo U250
Virtex-4

Alveo U250
Virtex-4
Virtex-2 Pro
Virtex-7
Virtex-2 Pro
Virtex-2
Virtex-E

250
375

250
375

250
375
108.2
124.2
67
39.5
39.7
250
375
250

622
980

435
700
190, 976
303, 450
451, 733
462, 520
567, 500
960, 000
987, 500
231, 406
366, 905
181, 024

402K
382K

574K
535K
1, 309
1, 236
240
268
118
41
40
1, 080
1, 022
1, 381

SPM [Our work]
SPM [10]
SPM-NAF [Our work] Alveo U250

Alveo U250
Virtex-4

Note that our modular subtraction module is 1.8Ã— faster and our
modular multiplication (integer multiplication+ğ‘ƒ-256 Modular Re-
duction) is 1.2Ã— faster than the implementations in state-of-the-art
work [10].
7.2 Point Arithmetic
We first evaluate the performance of our point addition (PA) and
point double (PD) operations. For a fair comparison, we also report
the latencies from state-of-the-art FPGA-based work [10], which
also uses projective Chudnovsky coordinates like our implementa-
tion. We observe that both of our point add and double operations
are ~1.6Ã— than their point add and double operations in terms of
clock cycles (refer Table 4). Note that their design involves a dual
clock which is much more complicated to implement than our de-
sign, which uses only a single clock throughout the entire design.
Moreover, the authors in [10] focus on optimizing only the point
arithmetic, and do not implement the entire ECDSA verification
algorithm. This makes it much easier for their stand-alone point
arithmetic modules to run at higher frequencies.

Now we compare the latencies of our scalar point multiplica-
tion (PM) with state-of-the-art works that implement scalar point
multiplication (refer Table 4). We observe that our PM is ~1.6Ã— to
~5Ã— faster than these existing works in terms of clock cycles. As
most of these prior implementation were done using binary double
and add algorithm, our PM is also implemented using the same ap-
proach. Note that implementation done by Kudithi et al. [19] works
with affine coordinates while rest of the works use projective coor-
dinates. Next, we compare the latencies of our simultaneous-point
multiplication (SPM) operation. As mentioned in Section 5.2, we

Rashmi Agrawal, Ji Yang, and Haris Javaid

perform SPM operation using width-4 NAF approach. However, for
fair comparison with [10], which uses a binary representation, we
estimated the latencies using the number of operations performed
in Algorithm 7 with binary representation. More importantly, our
SPM with width-4 NAF incurs about half the latency owing to our
faster modular arithmetic modules.

7.3 ECDSA Verification Engine
Table 5 presents the hardware resource utilization and latency of
the ECDSA verification engine. Our ECDSA verification engine
takes ~190, 000 clock cycles for a single signature verification lead-
ing to a throughput of 1, 315 signature verifications per second.
Although many prior works have accelerated point arithmetic on
FPGA, most works did not implement the entire ECDSA verification
algorithm. We found only two relevant comparable works in litera-
ture that accelerated ECDSA signature verification for NIST ğ‘ƒ-256
on FPGA, which are reported in Table 6. Glas et al. [8] reported the
implementation results of the complete signature generation and
verification unit on a Xilinx XC5VLX110T Virtex-5 FPGA. Their sig-
nature verification unit includes a hash generator ip which incurs
a latency of 68 clock cycles that we have adjusted accordingly for
a fair comparison. Their design achieves a throughput of 110 sig-
nature verifications per second that is about 12Ã— lower than the
throughput of our ECDSA verification engine.

KneÅ¾eviÄ‡ et al. [18] did an ASIC implementation for ECDSA
verification, but reported performance numbers by synthesizing
their design on a Xilinx Virtex-4 FPGA. Their design results in a
throughput of 475 signature verifications per second, which is ~2.8Ã—
lower than the throughput of our ECDSA verification engine. Note
that this design is primarily an ASIC implementation, which means
that it has a different optimization flow, resulting in a much lower
operating frequency and requiring less clock cycles. Therefore, we
do not compare frequency and latency for this design, but compare
the throughput for a fair comparison. We do not compare the hard-
ware resource utilization as prior designs use different FPGA boards
for implementation. Moreover, we cannot estimate the hardware
cost of these existing designs [8, 18] for Alveo U250 FPGA as these
designs are not open-sourced.

7.4 ECDSA Verification Engine for HL Fabric
Table 7 presents the hardware resource utilization and latency of
our ECDSA verification engine with precompute block. We ob-
serve that the precompute block incurs a latency of ~120, 000 clock
cycles. Then, the actual ECDSA verification engine requires only
~92, 000 clock cycles to perform a single signature verification. With

Table 5: Hardware results of ECDSA engine.

Design

LUT

FFs

ECDSA verf.

24394

10961

DSP BRAM Latency
190, 000

137

5

Table 6: Performance comparison of ECDSA engine.

Work

Platform

Freq.

Our work Alveo U250
[8]
[18]

Virtex-5
Virtex-4

250
50
33.3

Latency
190, 000
454, 140
69, 972

TP
1, 315
110
475

Efficient FPGA-based ECDSA Verification Engine for Permissioned Blockchains

Table 7: Hardware results of ECDSA engine (250 MHz).

Design

Precompute
ECDSA eng.

LUT

14088
21759

FFs

1417
5625

DSP BRAM Latency
120, 000
92, 000

129
137

15
15

TP

-
2, 717

Table 8: TP of Blockchain Machine with ECDSA engines.

No. of Engines Generic ECDSA HL Fabric ECDSA

4
7
10

1, 290 tps
2, 525 tps
3, 650 tps

2, 650 tps
5, 200 tps
7, 520 tps

this approach, we achieve a throughput of 2, 717 signature verifica-
tions per second.

We also evaluate the HL Fabric-specific ECDSA verification en-
gine in the context of Blockchain Machine. Table 8 presents the
throughput (transactions per second) of Blockchain Machine with
both the generic and Hyperledger Fabric-specific ECDSA verifica-
tion engines. We observe a 2Ã— improvement in throughput with our
precompute optimization. We also change the number of ECDSA
verification engines from 4 âˆ’ 10, and observe that both types of en-
gines scale the throughput in a similar trend (~1.57Ã— improvement).

8 CONCLUSION
In this work, we focused on an FPGA-based efficient implemen-
tation of ECDSA signature verification, in order to improve the
performance of permissioned blockchains that aim to use FPGA-
based accelerators. We presented several FPGA-specific algorithmic
optimizations for modular arithmetic modules. With efficient utiliza-
tion of DSP blocks on FPGA, we showed on average 1.5Ã— speedup
compared to [10]. We also presented optimizations for SPM and
FPM algorithms, and used projective Chudnovsky coordinate with
optimal width NAF representations. With these optimizations, we
observed on average 3.2Ã— speedup in our point arithmetic opera-
tions compared to [10, 19, 21, 22, 31, 37]. Our ECDSA verification
engine, using these modular and point arithmetic modules, per-
forms a signature verification in 760ğœ‡ğ‘  resulting in a throughput
of 1, 315 verifications per second, which is ~2.5Ã— faster than [8, 18].
With HL Fabric-specific optimizations, our ECDSA verification en-
gine can perform a signature verification in 368ğœ‡ğ‘  resulting in a
throughput of 2, 717 verifications per second.

REFERENCES
[1] Shehar Bano, Alberto Sonnino, Mustafa Al-Bassam, Sarah Azouvi, Patrick Mc-
Corry, Sarah Meiklejohn, and George Danezis. 2017. Consensus in the Age of
Blockchains. In CoRR, arXiv:1711.03936. arXiv:1711.03936 http://arxiv.org/abs/
1711.03936

[2] Chuanpeng Chen and Zhongping Qin. 2009. Fast algorithm and hardware archi-
tecture for modular inversion in GF (p). In 2009 Second International Conference
on Intelligent Networks and Intelligent Systems. IEEE, 43â€“45.

[3] Grant Chung, Luc Desrosiers, Manav Gupta, Andrew Sutton, Kaushik Venkatadri,
Ontak Wong, and Goran Zugic. 2019. Performance Tuning and Scaling Enterprise
Blockchain Applications. In CoRR, arXiv:1912.11456. arXiv:1912.11456 http:
//arxiv.org/abs/1912.11456

[4] Henri Cohen, Atsuko Miyaji, and Takatoshi Ono. 1998. Efficient elliptic curve
exponentiation using mixed coordinates. In International Conference on the Theory
and Application of Cryptology and Information Security. Springer, 51â€“65.

[5] Consensys. 2020. Quorum. Online: https://consensys.net/quorum/.
[6] Michael del Castillo. 2021. Forbes Blockchain 50 2021. https://www.forbes.com/

sites/michaeldelcastillo/2021/02/02/blockchain-50/?sh=58a32cb8231c.

[7] Steven Ehrlich. 2021.

Inside the Class of
2021. https://www.forbes.com/sites/stevenehrlich/2021/02/02/forbes-blockchain-
50inside-the-class-of-2021/?sh=625268fca508.

Forbes Blockchain 50 -

[8] Benjamin Glas, Oliver Sander, Vitali Stuckert, Klaus D MÃ¼ller-Glaser, and JÃ¼rgen
Becker. 2011. Prime field ECDSA signature processing for reconfigurable embed-
ded systems. International Journal of Reconfigurable Computing 2011 (2011).
[9] Christian Gorenflo, Stephen Lee, Lukasz Golab, and S. Keshav. 2019. FastFabric:
Scaling Hyperledger Fabric to 20,000 Transactions per Second. In 2019 IEEE
International Conference on Blockchain and Cryptocurrency (ICBC). https://doi.
org/10.1109/BLOC.2019.8751452

[10] Tim GÃ¼neysu and Christof Paar. 2008. Ultra high performance ECC over NIST
primes on commercial FPGAs. In International Workshop on Cryptographic Hard-
ware and Embedded Systems. Springer, 62â€“78.

[11] Nils Gura, Arun Patel, Arvinderpal Wander, Hans Eberle, and Sheueling Chang
Shantz. 2004. Comparing elliptic curve cryptography and RSA on 8-bit CPUs. In
International workshop on cryptographic hardware and embedded systems. Springer,
119â€“132.

[12] Darrel Hankerson, Alfred J Menezes, and Scott Vanstone. 2006. Guide to elliptic

curve cryptography. Springer Science & Business Media.

[13] Hyperledger. 2019. Hyperledger Fabric. Online: https://www.hyperledger.org/

projects/fabric.

[14] Hyperledger. 2020. Hyperledger Besu. Oline: https://www.hyperledger.org/

projects/besu.

[15] Haris Javaid, Chengchen Hu, and Gordon Brebner. 2019. Optimizing validation
phase of hyperledger fabric. In IEEE 27th International Symposium on Modeling,
Analysis, and Simulation of Computer and Telecommunication Systems (MASCOTS).
https://doi.org/10.1109/MASCOTS.2019.00038

[16] Haris Javaid, Ji Yang, Nathania Santoso, Mohit Upadhyay, Sundararajarao Mohan,
Chengchen Hu, and Gordon Brebner. 2021. Blockchain Machine: A Network-
Attached Hardware Accelerator for Hyperledger Fabric. In CoRR, arXiv:2104.06968.
arXiv:2104.06968

[17] Jang Hyun Ji and Ho Won Kima. 2018. ASIC implementation for an ECC processor.

IDEC Journal of Integrated Circuits and Systems (2018).

[18] Miroslav KneÅ¾eviÄ‡, Ventzislav Nikov, and Peter Rombouts. 2016. Low-latency
ECDSA signature verificationâ€”A road toward safer traffic. IEEE Transactions on
Very Large Scale Integration (VLSI) Systems 24, 11 (2016), 3257â€“3267.

[19] Thirumalesu Kudithi and R Sakthivel. 2019. High-performance ECC processor
architecture design for IoT security applications. The Journal of Supercomputing
75, 1 (2019), 447â€“474.

[20] Zhe Liu, Hwajeong Seo, Johann GroÃŸschÃ¤dl, and Howon Kim. 2015. Efficient
implementation of NIST-compliant elliptic curve cryptography for 8-bit AVR-
based sensor nodes. IEEE Transactions on Information Forensics and Security 11, 7
(2015), 1385â€“1397.

[21] C. McIvor, M. McLoone, and J.V. McCanny. 2004. An FPGA elliptic curve cryp-
IET Conference Proceedings (January 2004),

tographic accelerator over GF(p).
589â€“594(5).

[22] Nele Mentens. 2007. Secure and efficient coprocessor design for cryptographic

applications on FPGAs. https://lirias.kuleuven.be/retrieve/67565.

[23] NIST. 2013. FIPS DSS. Online: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.

186-4.pdf.

[24] NIST. 2021. FIPS DSA TEST VECTORS. Online: https://csrc.nist.gov/projects/

cryptographic-algorithm-validation-program/digital-signatures.

[25] Dong-won Park, Nam Su Chang, Sangyub Lee, and Seokhie Hong. 2020. Fast Im-
plementation of NIST P-256 Elliptic Curve Cryptography on 8-Bit AVR Processor.
Applied Sciences 10, 24 (2020), 8816.

[26] The OpenSSL project. 2021. OpenSSLâ€”cryptography and SSL/TLS toolkit. Online:

https://www.openssl.org/.

[27] R3. 2019. Corda. Online: https://www.corda.net.
[28] Ciara Rafferty, MÃ¡ire Oâ€™Neill, and Neil Hanley. 2017. Evaluation of large integer
multiplication methods on hardware. IEEE Trans. Comput. 66, 8 (2017), 1369â€“1382.
Ethereumm Set to Kill Graphics Card Mining. On-
line: https://www.pcgamer.com/ethereum-set-to-kill-graphics-card-mining-in-
the-upcoming-months/.

[29] Jacob Ridley. 2021.

[30] Suman Sau, Paresh Baidya, Rourab Paul, and Swagata Mandal. 2021. Binary Field
Point Multiplication Implementation in FPGA Hardware. In Intelligent and Cloud
Computing. Springer, 387â€“394.

[31] Dimitrios M Schinianakis, Apostolos P Fournaris, Harris E Michail, Athanasios P
Kakarountas, and Thanos Stouraitis. 2008. An RNS implementation of an ğ¹ _{ğ‘}
elliptic curve point multiplier. IEEE Transactions on Circuits and Systems I: Regular
Papers 56, 6 (2008), 1202â€“1213.

[32] Anissa Sghaier, Medien Zeghid, Chiraz Massoud, and Mohsen Mahchout. 2017.
Design and implementation of low area/power elliptic curve digital signature
hardware core. Electronics 6, 2 (2017), 46.

[33] Jerome A Solinas et al. 1999. Generalized mersenne numbers. Citeseer.
[34] Shoi Tachibana, Shunsuke Araki, Seiji Kajihara, Shigeyuki Azuchi, Yukishige
Nakajo, and Hideki Shoda. 2019. FPGA implementation of ECDSA for Blockchain.
In 2019 IEEE International Conference on Consumer Electronics-Taiwan (ICCE-TW).
IEEE, 1â€“2.

[35] Parth Thakkar and Senthil Nathan. 2021. Scaling hyperledger fabric using
pipelined execution and sparse peers. In CoRR, arXiv:2003.05113. arXiv:2003.05113
https://arxiv.org/abs/2003.05113

[36] Parth Thakkar, Senthil Nathan, and Balaji Vishwanathan. 2018. Performance
Benchmarking and Optimizing Hyperledger Fabric Blockchain Platform. In 26th
IEEE International Symposium on the Modeling, Analysis, and Simulation of Com-
puter and Telecommunication Systems (MASCOTS).
https://doi.org/10.1109/
MASCOTS.2018.00034

[37] Jo Vliegen, Nele Mentens, Jan Genoe, An Braeken, Serge Kubera, Abdellah
Touhafi, and Ingrid Verbauwhede. 2010. A compact FPGA-based architecture
for elliptic curve cryptography over prime fields. In ASAP 2010-21st IEEE Inter-
national Conference on Application-specific Systems, Architectures and Processors.
IEEE, 313â€“316.

[38] Guangli Xiang and Zhuxiao Cui. 2012. The algebra homomorphic encryption
scheme based on fermatâ€™s little theorem. In 2012 international conference on
communication systems and network technologies. IEEE, 978â€“981.

[39] Jiafeng Xie, Pramod Kumar Meher, Mingui Sun, Yuecheng Li, Bo Zeng, and Zhi-
Hong Mao. 2017. Efficient FPGA implementation of low-complexity systolic

Rashmi Agrawal, Ji Yang, and Haris Javaid

Karatsuba multiplier over ğºğ¹ (2ğ‘š) based on NIST polynomials. IEEE Transactions
on Circuits and Systems I: Regular Papers 64, 7 (2017), 1815â€“1825.

[40] Xilinx. 2020. Xilinx Alveo. Online: https://www.xilinx.com/products/boards-

and-kits/alveo.html.

[41] Noura Ben Hadjy Youssef, Wajih El Hadj Youssef, Mohsen Machhout, Rached
Tourki, and Kholdoun Torki. 2014. A low-resource 32-bit datapath ECDSA design
for embedded applications. In 2014 International Carnahan Conference on Security
Technology (ICCST). IEEE, 1â€“6.

[42] Gang Zhou, Harald Michalik, and LÃ¡szlÃ³ Hinsenkamp. 2009. Improving through-
put of AES-GCM with pipelined Karatsuba multipliers on FPGAs. In International
Workshop on Applied Reconfigurable Computing. Springer, 193â€“203.

[43] Jan Zutter, Max Thalmaier, Martin Klein, and Karsten-Olaf Laux. 2009. Accel-
eration of RSA cryptographic operations using FPGA technology. In 2009 20th
International Workshop on Database and Expert Systems Application. IEEE, 20â€“25.

