LightSync: Ultra Light Client for PoW Blockchains

Niusha Moshreﬁ§
School of Engineering
University of British Columbia
Okanagan Campus, Canada
niushamo@mail.ubc.ca

Mahyar Daneshpajooh§
School of Engineering
University of British Columbia
Okanagan Campus, Canada
mahyard@mail.ubc.ca

Chen Feng
School of Engineering
University of British Columbia
Okanagan Campus, Canada
chen.feng@ubc.ca

1
2
0
2

c
e
D
6

]

R
C
.
s
c
[

1
v
2
9
0
3
0
.
2
1
1
2
:
v
i
X
r
a

Abstract—Full nodes in a blockchain network store and verify
a copy of the whole blockchain. Unlike full nodes, light clients
are low-capacity devices that want to validate certain data on a
blockchain. They query the data they want from a full node. If
light clients do not verify the data they receive, full nodes might
deceive them. SPV, introduced in the Bitcoin paper, is a practical
solution to this problem currently used in many PoW blockchains.
In SPV, the resources needed to verify a full node’s response grow
linearly with the blockchain size, making it inefﬁcient over the
long run. Another issue with SPV is that the full nodes do not
get compensated for the services they provide.

In this work, we introduce LIGHTSYNC, a simple and cost-
effective solution for light clients to verify the inclusion of certain
data in a PoW blockchain. The resources needed for running
LIGHTSYNC remain constant no matter what the size of the
blockchain is. LIGHTSYNC uses an incentive mechanism that
encourages full nodes to participate in the protocol. We perform
a thorough analysis of the security of LIGHTSYNC and discuss
the details of deploying it in a real-world environment.

I. INTRODUCTION

In a blockchain network, full nodes are nodes that maintain
a copy of the whole blockchain and relay data in the network.
They need to have high storage, bandwidth, and computation
power since they need to store all
the blocks and verify
newly mined blocks to add them to their local chain. For
example, currently, Ethereum’s [1] blockchain size is roughly
870 gigabytes [2]. On the other hand, some clients have access
to limited resources, but need instant access to certain data on
a blockchain. Nowadays, there exist many such clients such
as smartphones, IoT devices, and wearable devices who want
to get data from a blockchain without storing and verifying
the whole blockchain. These low-capacity clients are called
light clients. In case that a light client wants to verify data
from multiple chains, the need for a cost-effective solution
becomes more crucial.

Another concern in today’s blockchain ecosystem is the
interoperability of the different blockchains [3]–[5]. Recently,
the topic of cross-chain applications has attracted wide atten-
tion [6]–[8]. In order to enable blockchains to embed a client
of another blockchain to facilitate cross-chain transactions
and cross-chain data transfer, there is a need for an efﬁcient
solution for light clients.

One solution for the light clients who need access to the
blockchain data is to send their queries to a trusted third
party (who maintains the blockchain) and get the required
data. However, this approach contradicts the very concept of

decentralization in blockchains. Thus, a light client needs an
efﬁcient solution to obtain information from any full node and
a proof to conﬁrm its validity, inclusion in the blockchain, and
ﬁnalization. Two important problems need to be tackled here.
First, the cost of the solution in terms of the required storage
and the computation power should be minimized. Second, an
incentive mechanism for the full nodes to provide the data and
the proof should be designed, especially with massive inquiries
from light clients.

A. Related Work

The original Bitcoin paper [9] has introduced SPV clients,
who are light clients performing a Simple Payment Veriﬁcation
by storing and verifying all the block headers of a blockchain.
This approach is cheaper than storing all the blocks of the
blockchain and acting as a full node. However, it is still costly
to store and verify all the block headers. The cost of this
solution grows linearly with the size of the blockchain.

Recently, two sublinear solutions have been proposed to
reduce the cost of light clients further. NIPoPoW [10] and
FlyClient [11] use several randomly chosen blocks from the
entire blockchain to verify the validity of a predicate based on
that blockchain. Compared to SPV, they have a lower cost for
veriﬁcation; the user is required to download a polylogarithmic
fraction of blocks to store and verify.

NIPoPoW chooses the high-difﬁculty blocks, as they happen
less frequently than other blocks, to be veriﬁed as a sub-chain
of the underlying chain. Verifying the validity of those blocks
proves that enough Proof-of-Work (PoW) for the underlying
chain has been provided with a high probability. FlyClient
has an optimized approach in which a binary search and a
random sampling are conducted to ﬁnd the invalid blocks of
an invalid chain. This way, the algorithm detects and discards
invalid proofs.

Both of the solutions use velvet forks [12] to include addi-
tional structures in the block headers of the source blockchain.
NIPoPoW requires an interlink pointers data structure to be
included in the block headers and FlyClient requires all block
headers to include the root of a Merkle Mountain Range
(MMR) [13] commitment of all previous block headers. How-
ever, both solutions suffer from several drawbacks. NIPoPoW
only works well when the difﬁculty of the blockchain stays
constant which is an unrealistic assumption. On the other
hand, FlyClient has not conducted a comprehensive analysis

 
 
 
 
 
 
TABLE I
PROOF SIZE (IN MB) OF SPV AND LIGHTSYNC FOR ETHEREUM
BLOCKCHAIN

Blockchain length
SPV
LightSync

1 M 10 M 100 M
50,800
5,080
508
0.076
0.076
0.076

on the security of its protocol under velvet fork deployment.
Their protocol is exposed to chain-sewing attacks under such
conditions. Nemoz and Zamyatin [14] have introduced this
attack and proposed some solutions to ﬁx it.

B. Our Contribution

We propose LIGHTSYNC, a new protocol for light clients in
PoW blockchains. The storage and computation power needed
for the users in LIGHTSYNC do not grow with the length
of the blockchain and remain constant. Thus, LIGHTSYNC
dramatically reduces the resources that light clients need for
conﬁrming a predicate from a PoW blockchain. Especially for
the light clients who want to conﬁrm data from a large or a
fast-growing blockchain, LIGHTSYNC is a promising solution
to reduce the cost. For example, the current length of the
Ethereum blockchain is roughly 13 Million blocks. Assume
the adversary mining power to the honest mining power to be
1
2 and the adversary miners to use the same target difﬁculty as
honest miners. In case that the blockchain includes MMR root
in the block header structure, to achieve the failure probability
less than 2−20, the expected number of block headers for
LIGHTSYNC’s proof will be 140. In Table I, we demonstrate
the resulted improvement in proof size in comparison to SPV.
Our solution is simple with realistic assumptions that make
it easily applicable to the current blockchains. Moreover,
LIGHTSYNC employs an incentive mechanism that encourages
full nodes to participate in the protocol. We have also analyzed
the security of the protocol thoroughly [15] and considered
all the deployment issues. Therefore, LIGHTSYNC is the ﬁrst
incentivized protocol for light clients that has the minimum
cost for its users which is provably secure.

II. MODELS AND PROBLEM FORMULATION

A. Backbone Model

Our model is based on the standard backbone model for
PoW blockchains [16]. This model consists of three main play-
ers: full nodes, miners and light clients. Full nodes maintain a
copy of the whole blockchain. They validate every data they
receive. Also, some full nodes relay data through the network.
Miners create new blocks extending the longest chain of the
blockchain and commit new transactions they receive from the
clients. Miners compete to become the next block proposer
by solving a puzzle which is known as Proof-of-Work. For
getting blocks and transactions, miners rely on full nodes.
Clients need up-to-date information from the blockchain. For
example, when they want to perform a transaction inclusion
veriﬁcation, they need the block header of the desired block, in
addition to a proof for the transaction inclusion in that block
header. Light clients are clients who utilize fewer resources

such as storage and computation. They send queries to some
full nodes to obtain their desired data instead of paying for
the cost of maintaining the whole blockchain.

Block creation is captured in the random oracle model as in
[16]. This model has a security parameter σ. In each mining
round, a miner sends q queries to the random oracle function
H(.). For each query, if the value has not been queried before,
the function returns a random value from {0, 1}σ and stores
the input and output values in a table. If the value has been
queried before, the function ﬁnds the recorded output from the
table and returns it.

For a block to be valid, it needs to have a proof to show
enough work has been done on that block. Each block B
has a target difﬁculty T . If H(B) < T , we say the block
meets its difﬁculty requirement, therefore, it has a sufﬁcient
amount of work. The target difﬁculty T is set in a way that
the block intervals remain constant in expectation. We call
the expectation of block intervals Block Interval Time. The
parameter λ is the arrival rate of new blocks, which is equal to
the inverse of the block interval time. In our model, the target
difﬁculty of the blocks can be constant or variable. Based on
the standard backbone model, the active mining power in the
network is proportional to λ/T .

We abstract B to contain the block header information. A
valid block that has a valid PoW and extends the longest chain
will be propagated by honest nodes and with a high probability
will get ﬁnalized in the blockchain. A block gets ﬁnalized
when it is buried under a chain of at least k other blocks, where
k is the ﬁnality parameter. The ﬁnality parameter k is tuned
in a way that the probability of a ﬁnalized block slipping out
of the longest chain is made negligible. The ﬁnality parameter
differs from one blockchain to another. For example, for the
Bitcoin ledger, we know that k = 6.

Each block has a block header. Every block header contains
a block number, the hash of the previous block as a pointer to
it, the target difﬁculty T , the Merkle root of all transactions,
and some other information related to the block. The size of
block headers is much smaller than the size of the blocks
themselves.

When a miner receives a new block, that block may extend
some block other than the last one and cause a fork in that
miner’s local blockchain. Honest nodes will follow the longest
chain rule. They choose the longest valid chain and start
mining their new block on it. In a valid chain, all the blocks
meet their difﬁculty requirement. We assume more than half
of the mining power in the network is honest. Any blockchain
that an honest node maintains is called an honest chain.

B. Chain Commitment

We leverage the notion of Merkle Mountain Range (MMR)
in our protocol to enable verifying data from any previous
block header of the blockchain. MMR is a more efﬁcient
variant of Merkle trees [17]. For the MMR root of each block,
the MMR leaves are the block headers of all previous blocks.
Just like Merkle trees, parent nodes in MMR are hash values
of their two children. Using MMR, the entire blockchain can

be committed into a single hash value. Also, the proof of the
inclusion of a block in the MMR tree is of logarithmic size.
MMR uses an efﬁcient updating process to append new leaves
and update its root. Each block’s MMR root can be constructed
from the previous block’s MMR root with a low computation
overhead. It is also capable of efﬁciently removing the last leaf
from the structure. Moreover, the consistency of the MMR
root of a past block with the MMR root of a more recent
block can be shown easily. The process of adding a leaf to an
MMR tree is shown in Figure 1. Since an MMR tree might
have more than one peak, the MMR root is constructed from
bagged peaks.

For blockchains that do not have MMR root in their block
header structure, an upgrade to the consensus layer is required
for the structure to include MMR root in it. One possible way
for upgrading is to do a hard fork or a soft fork [18]. If
doing such a fork is not possible, a velvet fork, introduced
by Kiayias et al. in [10], can be used to add MMR root
to the block structure. The changes they propose in the
velvet fork need no rule modiﬁcations to the consensus layer.
Honest miners will be divided into two groups of upgraded
and non-upgraded honest miners. The upgraded miners are
required to include the MMR root of the previous blocks in
their coinbase data, however, non-upgraded miners just ignore
that data as comments. Coinbase is the ﬁrst transaction of a
block, determined by the block’s miner. Both types of miners
accept previously valid blocks regardless of whether they have
upgraded structures or not.

In the velvet fork, the set of accepted blocks is not modiﬁed,
therefore, there may exist some upgraded blocks containing
an invalid MMR root. We assume that the majority of the
upgraded miners are honest. We add a voting mechanism so
that valid MMR roots can be detected. To enable the voting,
we require every upgraded miner to include a buffer of length
α in their coinbase data as well as the MMR root. Later, we
will deﬁne α in a way for the protocol to be secure and discuss
it. Every upgraded block has a ﬂag in its coinbase data so that
it can be recognized from the non-upgraded blocks.

C. The Prover and Veriﬁer Model

To verify some data being included in the blockchain
without having to maintain the whole blockchain, a client
needs to send some queries to full nodes. We call the light
client a veriﬁer and the full nodes provers. We assume that
the veriﬁer doesn’t trust any of the provers and is attempting to

ﬁnd a prover to get some ﬁnalized blocks of the honest chain.
This way, she can perform a state or transaction inclusion
veriﬁcation test and verify a piece of data is included in
the blockchain. We assume that the veriﬁer knows the block
interval time and the conﬁrmation number of the blocks k.

The veriﬁer sends the same request to several provers and
they will respond to her with a proof. The veriﬁer needs to
determine which of the proofs belongs to an honest prover.
The proof contains a chain of blocks. We assume that there
exists at least one honest full node among the selected provers,
i.e., the client has not been eclipsed from the network.

Without loss of generality, we can assume that the veriﬁer
sends requests to two full nodes where one of them is honest
and the other one is malicious. The veriﬁer’s goal
is to
determine which of them is the honest node. The honest
node maintains the honest chain which is a blockchain with
a speciﬁc genesis block that has maximum mining power
working on it. In other words, it has the highest cumulative
difﬁculty. The veriﬁer wants to conﬁrm some data from this
honest chain. In real-world scenarios, the veriﬁer can send
requests to multiple provers to increase the probability of
communicating with an honest node.

D. Notations

We denote a chain of length n of block headers by C[0 :
n − 1]. In this chain, C[i] (0 ≤ i ≤ n − 1) refers to the
block header with height i, and C[i : j] refers to the set of
block headers from height i inclusive to height j inclusive.
Speciﬁcally, C[i : end] is the set of block headers starting
from C[i] to the end of the chain.

III. LIGHTSYNC PROTOCOL

In this section, we present the protocol of LIGHTSYNC.
The main properties of the LIGHTSYNC protocol are threefold.
First, the proposed protocol is very simple, and it can easily
be implemented for any PoW blockchain without the need
to change its consensus rule. Second, the computation power
and the storage that a veriﬁer needs have been dramatically
reduced. The number of the blocks that a veriﬁer needs to
download from the full nodes does not depend on the length
of the chain and is a constant factor. Third, LIGHTSYNC uses
an incentive mechanism to encourage the full nodes to engage
in the protocol.

Fig. 1. Merkle Mountain Range

A. Protocol Overview

As we discussed in the prover and veriﬁer model in the
previous section, we assume that we have one veriﬁer and
two provers where only one of the provers is honest.

The veriﬁer starts the protocol by sending a query to the
provers. She creates a transaction and sends it to both of the
provers. We call this transaction the query transaction. We
explain the details of this transaction in the incentive section
(Section IV). After sending requests to the provers, the veriﬁer
waits to get responses. Every prover should respond with a
proof before a predetermined deadline. The veriﬁer compares
the received proofs using LIGHTSYNC algorithm. The winner
proof belongs to the honest node with an overwhelming
probability.

The proof consists of two parts. First, a proof to get the
last ﬁnalized block. Second, a proof to ﬁnd the last valid
MMR root of the blockchain. Using the ﬁrst part of the proof,
the veriﬁer gets the last ﬁnalized block of the honest chain.
Furthermore, the second part of the proof provides information
about the history of the blockchain in case that the veriﬁer
needs to verify some data based on the past blocks of the
blockchain.

In the following, we explain the details of each part of the

proof.

B. Getting the Last Finalized Block Header

The veriﬁer sends a query transaction to both provers.
try to include the query transaction in their
Provers will
local blockchains and provide the veriﬁer with a valid proof
within the challenge period to prove the honesty of their local
blockchains. The challenge period is determined by the veriﬁer
and is sent to the provers along with the query transaction. The
longer the challenge period is, the higher certainty it provides
for the veriﬁer about its ﬁnal decision. The challenge period
starts when the veriﬁer sends the query transaction to the
provers. The steps of the protocol for ﬁnding the last ﬁnalized
block header are described in Algorithm 1.

To include the query transaction in its local blockchain,
each prover broadcasts it into his local blockchain network.
The honest prover propagates the transaction in the whole
blockchain network so that the honest mining power working
on the last block of the blockchain includes this transaction
in their block. After the query transaction is included in
their local blockchains, the provers will wait for some block
conﬁrmations. The provers should send their proofs to the
veriﬁer before the challenge period is passed. The proof
consists of a sub-chain of block headers from the blockchain,
as well as a Merkle inclusion proof of the query transaction
in one of those block headers. The sub-chain contains block
headers from the block including the query transaction to
the last mined block on top of it that gets mined before the
challenge period is passed. Provers should include at least
k + 1 block headers in their proofs. If the number of blocks
mined after the block containing the query transaction is less
than k, the provers should include the previous block headers
to contain at least k + 1 block headers in their proof.

The honest prover can simply wait for the blockchain to
grow and have some block conﬁrmations, and send the proof
to the veriﬁer a few moments before the deadline. On the
other hand, for the malicious prover, the honest mining power
will not help him to grow his chain, as long as his local chain
data contradicts the honest chain data. The malicious prover,
therefore, has no more power than the adversary mining
power to mine conﬁrmation blocks on top of the block
containing the query transaction. We call the conﬁrmation
block headers along with the block header including the
query transaction, the challenge headers. Since the adversary
mining power is less than the honest mining power due to the
underlying blockchain’s security, in Section V-B, we show
that the overall difﬁculty of the challenge headers provided
by the malicious prover in the challenge period is less than
the honest prover’s with a very high probability.

Deﬁnition 1. The overall difﬁculty of a group of blocks is
the summation of the inverse of the target difﬁculty of each
block.

The veriﬁer receives all

the proofs provided within the
challenge period. Note that both the veriﬁer and the provers
should be online so that the veriﬁer can examine whether the
proof was provided within the challenge period or not. Each
proof consists of a chain of block headers. First, the veriﬁer
checks the inclusion of her query transaction in one of the
block headers of the proof using the Merkle proof of inclusion.
Then, she checks the validation of the rest of the block headers.
Each block header should refer to its previous block header
correctly and have valid PoW regarding its target difﬁculty. If
a proof passes all the above checks, we consider it as a valid
proof. In the next step, the veriﬁer decides which proof to
accept by calculating all valid proofs’ overall difﬁculties and
comparing them together. The valid proof with the highest
overall difﬁculty gets accepted. We call this proof the winner
proof.

Since the malicious prover wants the veriﬁer to accept his
local chain, he tries to maximize the overall difﬁculty of his
proof. It means that he tries to mine as many blocks with
high difﬁculties as possible, on top of the block containing
the query transaction. As long as the query transaction gets
determined by the veriﬁer, the provers cannot start constructing
the query transaction from the
the proof before they get
veriﬁer. Therefore, they only have a limited time (challenge
period) to construct the proof. During this limited time, there
is a negligible chance that the malicious prover could achieve
a higher overall difﬁculty than the honest prover, because, the
honest mining power is more than the adversary mining power
in the network.

The detailed analysis of the protocol is described in Sec-
tion V. After running the above protocol, the veriﬁer has the
last ﬁnalized block header of the blockchain. In the following,
we explain how the veriﬁer conﬁrms data from the history of
the blockchain.

Algorithm 1 LightSync Protocol for Finding the Last Final-
ized Block Header

1: The veriﬁer creates a query transaction and sends it to the

selected provers along with the challenge period.
2: The veriﬁer starts a timer for the challenge period.
3: Each prover who receives the query transaction runs
CREATEPROOF(queryT ransaction) (Procedure 2) and
sends the created proof to the veriﬁer.

4: For each received proof,

the veriﬁer

runs VALI-

DATEPROOF(proof ) (Procedure 3).

5: The

veriﬁer

runs

CULTY(proof, queryT ransaction)
for the valid proofs.

OVERALLDIFFI-
4)
(Procedure

6: The veriﬁer chooses the valid proof with the highest

overall difﬁculty as the winner proof.

Procedure 2 CREATEPROOF(queryTransaction)

1: Start a timer for the challenge period.
2: δ ← the communication delay between the veriﬁer and

the prover

3: Checks the validity of queryT ransaction
4: Broadcast queryT ransaction in the local blockchain
5: repeat
6:

On the local longest chain B[0 : end], ﬁnd the block
B[q] which includes queryT ransaction

7: M erkleP roof ← proof
queryT ransaction in the B[q]

of

inclusion

of

else

C[0 : m − 1] ← B[q : end]

8: m ← len(B[q : end])
if m ≥ k + 1 then
9:
10:
11:
12:
13:
14: until 2δ seconds remaining from the challenge period
15: proof ← C ∪ M erkleP roof
16: return proof

C[0 : k] ← B[q − k + m : end]

end if

Procedure 3 VALIDATEPROOF(proof )

1: Check the length of the chain in the proof to be at least

k + 1.

2: Verify the correctness of Merkle inclusion proof for the

query transaction.

3: Check that each block header of the chain refers correctly

to its previous block header.

4: Calculate the PoW for each block header of the chain and

validate it against the target difﬁculty.
5: return true if all the above checks pass

Procedure 4 OVERALLDIFFICULTY(proof, queryTransaction)
1: Find the block header C[q] containing queryT ransaction

2: T [i] := target difﬁculty of block header C[i] (q ≤ i ≤ end)

3: overallDif f iculty ← (cid:80)end
4: return overallDif f iculty

i=q T [i]−1

C. Finding the Last Valid MMR Root

After executing the ﬁrst part of the LIGHTSYNC protocol,
a veriﬁer has got a copy of at least k + 1 block headers of
the blockchain. If the construction of the block headers of
the blockchain includes the MMR root of all previous block
headers of the blockchain, then knowing the last k + 1 block
headers, the client has access to the MMR root in a ﬁnalized
block header of the blockchain. The client can perform a
transaction inclusion test for transactions related to the past
blocks of the blockchain using that MMR root. This is the
case for some blockchains like Beam [19] and Grin [20] that
include MMR root in their block header structure.

However, if a blockchain does not support MMR, there
exist three possible approaches for including MMR roots in
the structure and using them: Hard fork, Soft fork, or Velvet
fork. In the case of a hard fork, miners are required to
include an MMR root in the block headers of the blockchain.
Alternatively, in a soft fork, the MMR root is added to the
new blocks in a way to stay backward compatible with the
old blocks. For example,
the MMR root can be included
in a predetermined transaction like the coinbase transaction.
This way the non-upgraded miners will accept the new blocks
whether these blocks are created following the new rule or
not. Nonetheless, the upgraded miners will follow the new
rule and only accept blocks including a valid MMR root. A
soft fork needs the majority of the miners to upgrade to the
new rule. After including the MMR root in the structure of the
block headers of a blockchain using either of the above two
approaches, it can be used immediately to verify data from the
history of the blockchain by the veriﬁer. For example, Zcash
[21] has added MMR root to its block header structure using
a hard fork named Heartwood.

The last approach is to use a velvet fork to add MMR
roots to the block headers. In velvet forks, there is no need
for a speciﬁc number of miners to upgrade. The upgraded
miners will add the MMR root to the block headers in a
backward-compatible way (like soft forks it can be included
in the coinbase transaction data), but, they continue to accept
blocks created by non-upgraded miners. This way the set of
accepted blocks stays unchanged, meaning that every non-
upgraded or upgraded miner will accept a block, whether it
includes an MMR root or not. In this case, since no one is
checking the validity of the MMR ﬁeld, some of the blocks
may contain invalid MMR roots. If the veriﬁer accepts an
invalid MMR root, the malicious prover has deceived the
veriﬁer to accept a predicate that contradicts the honest chain.
To avoid invalid MMR roots getting accepted by the light
clients, we append a small buffer of data to the MMR root
that enables a voting mechanism for them. Applying this
change, the upgrade remains backward compatible. Using this
mechanism, we make sure that the veriﬁer can detect a valid
MMR root.

The buffer’s length is α. Each bit of the buffer points to
a preceding block and votes for its MMR root validity. In a
block header, the last bit of its voting buffer refers to the last

upgraded block, the bit before that refers to the second last
upgraded block, and so on. The miner sets a bit to 1 (accept
vote) if he believes that the corresponding block includes a
valid MMR root and sets it to 0 (reject vote) otherwise. We
assume that the majority of the upgraded miners are honest.
This way if the majority of miners in a long enough sub-chain
have voted 1 for an MMR root, the veriﬁer can make sure that
MMR root is valid and by adding new block headers to it, she
can easily construct the MMR root of the last ﬁnalized block
by herself.

The second part of the proof is sent by the prover to the
veriﬁer in the case of a velvet fork, to provide her with the
latest valid MMR root. The veriﬁer starts the second part of
the protocol by sending the last ﬁnalized block header and a
parameter called β to the prover. In response to the veriﬁer’s
request, the prover sends a sub-chain of block headers that
includes α+β upgraded block headers, as well as each block’s
coinbase data with proof of its inclusion in the block. We
call the ﬁrst β block headers of the sub-chain candidates. In
Section V-B, we discuss how β effects the protocol security.
Algorithm 5 shows the steps of the second part of the protocol.
First, the veriﬁer validates the received proof. She checks
the previous hashes of the block headers to be correct and
the coinbase data inclusions to be valid. She also checks
the extended proof to include the last ﬁnalized block header
from the previous part. After checking the validity of the
proof, the veriﬁer extracts candidates’ block headers. Each of
the candidates has α voters vote for them, as long as every
upgraded block header votes for previous α upgraded block
headers. An MMR root among the candidates that has been
accepted by more than half of its voters is a valid MMR root.
The veriﬁer will accept that MMR root and use it to obtain
the last valid MMR root of the blockchain by appending the
block headers that exist on top of it to its tree. By choosing the
right β, there exists a valid MMR root among the candidates
with an overwhelming probability. A detailed analysis of this
voting mechanism and how to determine the parameter β is
discussed in Section V.

Algorithm 5 LightSync Protocol for Finding the Last Valid
MMR Root

1: The veriﬁer sends an MMR request along with the last

ﬁnalized block header B[f ] to a prover.

2: The prover creates a proof containing two parts:

1) The last s + 1 block headers up to B[f ], which is
B[f − s : f ], that contains α + β upgraded block
headers from his local chain B[0 : f ].

2) The coinbase data for each block header along
with its proof of inclusion in that block header
PROOF(CoinbaseData).

3: The prover sends the proof to the veriﬁer.
4: The veriﬁer

runs FINDLASTMMR(B[f − s

f ],
CoinbaseData[0 : s], PROOF(CoinbaseData[0 : s])) to
ﬁnd the last valid MMR root.

:

Procedure 6 FINDLASTMMR(C[0 : s], CoinbaseData[0 :
s], PROOF(CoinbaseData[0 : s]))

1: Check that C[s] is equal to B[l].
2: Check that the number of upgraded block headers is equal

to α + β.

3: Check that each block header refers correctly to its previ-

ous block header.

4: Check the correctness of each coinbase data inclusion

proof.

5: candidates[0 : β − 1] ← ﬁrst β upgraded block headers

of C[0 : s]

6: V [0 : β − 1] := the number of accept votes for each block

header of candidates[0 : β − 1]

7: validSet ← the candidates’s block headers with more

than (cid:98)α/2(cid:99) accept votes

8: validRoot ← the MMR root of the last block header of

validSet

9: v ← the index of the block containing validRoot
10: lastV alidRoot ← update the validRoot by adding the

block headers C[v : s] to its tree

11: return lastV alidRoot

D. Staying Up-to-Date

In some applications, after running the LIGHTSYNC proto-
col and getting the last ﬁnalized block header and the last valid
MMR root of the blockchain, the veriﬁer may want to receive
the future block headers as soon as they are mined. In this
case, the veriﬁer can continue requesting block headers from
the honest full node and check their validity and compliance
with her current chain of block headers and add them to her
local chain if the received data is valid. When a new block
header gets ﬁnalized, the veriﬁer can add it to the MMR root
she maintains to achieve the last stable MMR root of the
blockchain. Then, she can drop all the ﬁnalized block headers
prior to it. In this way, she will always maintain a limited
number of block headers; a sub-chain with length k + 1 with
some possible forks. However, she can perform any transaction
inclusion or state veriﬁcation by using the MMR root she
maintains.

In other cases where the veriﬁer doesn’t need to learn about
new block headers immediately as they are mined, she can
repeat the LIGHTSYNC protocol in long time intervals. In this
way, instead of getting each block header in real-time, the
client can update herself periodically. So, she will use fewer
resources, but, will experience some delays.

IV. INCENTIVE DESIGN

Full nodes maintain a copy of the whole blockchain and
relay data in the network. In addition,
they provide the
veriﬁers with light client services which have some extra costs
for them. The growing number of light clients makes the
services’ cost considerable for full nodes. Without a proper
incentive mechanism, there is a lack of motivation for users
to participate in the network as full nodes. In this section, we

introduce LIGHTSYNC incentive mechanism, which proposes
a way to cover the costs of being a full node and prevents
the light clients from free-riding. The previous light client
solutions suffer from the lack of incentive in their protocols.
With the increase of demand for light clients, there is a need to
properly incentivize full nodes, so that they continue providing
the veriﬁers with light client services.

Incentive Mechanism. To start the protocol, the veriﬁer
sends a query transaction to provers. This transaction is a Pay-
To-Script-Hash (P2SH) [22]: a special type of transaction that
transfers money from the sender of the transaction to the hash
of a script which is determined by the sender. The script may
require some conditions to be satisﬁed. Anyone who provides
the script and satisﬁes the dictated conditions can spend the
P2SH transaction. The veriﬁer uses this kind of transaction to
pay the prover for the service she gets. We call this fee the
Service Fee that compensates for the costs of the full nodes.
The veriﬁer also has to pay the transaction fee of the P2SH
transaction.

After executing the LIGHTSYNC protocol, the veriﬁer sends
the script to the prover who has provided the ﬁnal chosen
the prover can spend the query
proof. Using the script,
transaction and receive his fee. The service fee makes an
incentive for honest provers to participate in LIGHTSYNC and
broadcast the query transaction in the fastest time. If more
honest nodes are incentivized to participate in LIGHTSYNC,
the chance of the user connecting to at least one honest prover
gets higher. Also, the faster the honest prover propagates the
query transaction in the network, the sooner an honest miner
includes it in a block.

A summary of all the needed communication between the
veriﬁer and the provers is shown in Figure 2. After receiving
the proofs, the veriﬁer detects the honest prover and continues
communicating with him to obtain the MMR and provide him
with the solution for conditions of P2SH transaction. We call
it the puzzle of P2SH transaction.

The described mechanism has a challenge: the veriﬁer might
refuse to provide the prover with the script. In this case,
although the prover has provided a service for the veriﬁer,
it hasn’t received the service fee and the veriﬁer has only paid
a transaction fee.

We assume that after executing the LIGHTSYNC protocol,
the communication between the veriﬁer and the prover needs
to be continued. Since the veriﬁer is a light client, she wants to
receive every new block header from the prover. If the veriﬁer
refuses to reveal the script, the prover will not provide her
with new block headers anymore. In this case, the veriﬁer
needs to restart the LIGHTSYNC protocol with another prover.
This means that she needs to send a new query transaction to
the other provers. This costs an extra transaction fee for her.
By setting the transaction fee greater than the service fee, it
will demotivate the veriﬁer to abandon the ﬁrst honest prover.

V. PROTOCOL ANALYSIS

In this section, we perform a thorough analysis of the
complexity and security of the LIGHTSYNC protocol. We

Fig. 2. Communication between the veriﬁer and the provers

compare LIGHTSYNC to the existing solutions in terms of
needed resources and we show that it is secure.

A. Complexity Analysis

The main goal of a light client protocol is to enable light
clients to verify the inclusion of some data in the blockchain
using the least possible storage and computation resources.

In the ﬁrst part of the protocol (III-B), each prover has a
limited time (challenge period) to provide the veriﬁer with
a proof. In LIGHTSYNC, the challenge period is determined
by the desired level of security and is independent of the
blockchain’s length. The number of blocks mined in the honest
chain during this period is on average the challenge period
divided by the block interval time of the blockchain, which
stays constant. If MMR root is included in the block structure
using a hard fork or a soft fork, after running the ﬁrst part
of the protocol, no more data is required from the prover. So,
the veriﬁer validates her predicate on the honest chain using
constant resources.

If MMR structure has been added to the blockchain using
velvet fork, after running the ﬁrst part of the protocol, more
data is required to validate the predicate. The winner prover
sends a sub-chain that includes α + β upgraded block headers
to the veriﬁer. Assuming that the ratio of the total mining
power to the upgraded mining power is l, in a long run, 1/l
of total mined blocks of the honest chain are upgraded. So,
on average, the winner prover needs to send (α + β) × l
block headers to the veriﬁer to provide α + β upgraded block
headers. Since α, β, and l do not depend on the length of the
blockchain, the needed resources to perform the second part
of the protocol (III-C) stays constant.

In conclusion, no matter what the size of the blockchain
is, the veriﬁer can perform data inclusion veriﬁcation using
constant storage and computation resources. In Table II, we
make a comparison between existing solutions and LIGHT-
SYNC. The veriﬁer’s complexity in the table refers to the
needed storage and computation resources for the veriﬁer.

TABLE II
COMPARISON OF DIFFERENT LIGHT CLIENT PROTOCOLS

Protocol
SPV
NIPoPoW
FlyClient
LightSync

Protocol Complexity for Veriﬁer
O(n)
O(polylog(n))
O(polylog(n))
O(1)

Added Structure
-
Interlink
MMR
MMR

B. Security Analysis

As we described in the prover and veriﬁer model, the veriﬁer
sends queries to two provers where one of them is honest
and the other one is malicious. Each prover sends a proof to
the veriﬁer. After executing the protocol, the veriﬁer decides
on one of the proofs as the winner proof. The LIGHTSYNC
protocol is secure if the veriﬁer decides on the honest prover’s
proof with an overwhelming probability. In what follows, we
explain the security conditions of the protocol and prove them.
We assume that the majority of the underlying blockchain
miners are honest which is a necessary condition for Proof-of-
Work blockchains. We assume the Poisson process model with
rate λ for the block mining process. In the case where MMR
structure has been added to the blockchain using velvet fork
(the approach described in III-C), we assume that the majority
of the upgraded miners are honest.

Regarding the difﬁculty of the blocks, we assume that in the
blocks that are sent as the ﬁrst part of the proof, the difﬁculty
of the blocks would change at most one time. This is a realistic
assumption as long as the difﬁculty adjustment in a blockchain
gets done in longer time intervals than the challenge period.
The malicious prover wants to deceive the veriﬁer and
make her conﬁrm some predicate that contradicts the honest
chain data. The veriﬁer validates her predicate using the last
valid MMR root. So, the malicious prover should be able to
convince the veriﬁer to accept an invalid MMR root to succeed
in deceiving the veriﬁer. In the following, we analyze both
cases where all the blocks include an MMR root (case I) and
where the MMR root is added to some of them using a velvet
fork (case II). The former is the case where the blockchain
includes the MMR root in its structure (and so there is no
need to do a fork), also, it is the case of using a hard fork or
soft fork to add MMR to the structure.

Case I. In this case where all blocks include an MMR root,
the malicious prover should send an invalid block as a ﬁnalized
block to be able to mislead the veriﬁer, because, the last valid
MMR root is included in the last ﬁnalized block header. If the
malicious prover wants his invalid block to be the winner proof
for the veriﬁer, he has to include some conﬁrmation blocks
containing higher overall difﬁculty than the other prover. Based
on Theorem 1, the probability of this scenario is negligible
under our model assumptions.

The probability of the query transaction being included
in the ﬁrst block mined after the challenge period starts is
determined by its transaction fee. The higher the transaction
fee is, the higher will be the chance for it to be included
in the blockchain sooner. We assume the transaction fee to
be high enough so that the query transaction gets included

in the ﬁrst mined block after the challenge period starts. If
the transaction fee is not high enough, the transaction will be
included in later block headers of the honest chain, however,
the adversary mining power will include it in the ﬁrst block of
its local chain anyways. Hence, there will be a higher chance
for the malicious proof to have more overall difﬁculty and
win.

The proof includes m ≥ k + 1 (m(cid:48) ≥ k + 1) block headers,
for the honest (malicious) prover. We denote this sub-chain
by C[0 : m − 1] (C (cid:48)[0 : m(cid:48) − 1]). The query transaction is
included in one of the block headers of the proof, suppose the
block header to be C[q] (C (cid:48)[q(cid:48)]). The veriﬁer calculates the
overall difﬁculty of C[q : end] and C (cid:48)[q(cid:48) : end]. The proof
with the higher overall difﬁculty will be chosen as the winner
proof.

The target difﬁculty for each of these two sub-chains can
change at most one time. We denote the number of block
headers using the same target difﬁculty T1 (T (cid:48)
1) which are
constructed in time t1 (t(cid:48)
1) starting from the beginning of
the challenge period by random variable N1 (N (cid:48)
1). In the
remaining time t2 (t(cid:48)
2), blocks are constructed with target
difﬁculty T2 (T (cid:48)
2). We denote the number of blocks constructed
during this time with random variable N2 (N (cid:48)
2). Real numbers
t1, t2, t(cid:48)
1 + t(cid:48)
2
are equal to the challenge period (t). Clearly, discrete random
variables N1, N2, N (cid:48)

2 are non-negative where t1 + t2 and t(cid:48)

2 have Poisson distributions.

1, and N (cid:48)

1, and t(cid:48)

We suppose the block arriving rate of the blockchain to be
λ1 blocks per second from the start of the challenge period
until t1 seconds. Since the challenge period is much less than
the difﬁculty adjustment time interval, we can assume that the
whole mining power of the network is constant during this
time. Furthermore, with changing the target difﬁculty of the
blockchain, the rate of arriving blocks will change to λ2 after
t1 seconds. Parameters λ(cid:48)
2 are deﬁned similarly for the
adversary mining power. All the blocks of the adversary chain
should meet their target difﬁculties, otherwise, the veriﬁer
would not accept their proof as a valid proof. However, the
adversary mining power will not necessarily use the target
difﬁculties of the honest chain. They may use other target
difﬁculties in order to maximize their chance of being selected
as the winner proof. Based on our model assumptions, the
arrival rate of new blocks in a chain is proportional to the
target difﬁculty for constant active mining power.

1 and λ(cid:48)

Theorem 1. The veriﬁer sends a query transaction (tx) to
two provers where exactly one of them is honest. The honest
prover running the LIGHTSYNC protocol provides proof, and
the malicious prover provides proof’. The probability

Pr{OVERALLDIFFICULTY(proof, tx)
> OVERALLDIFFICULTY(proof (cid:48), tx)}

(1)

is negligible.

Proof: Using the notations we deﬁned in this section, we

know that:

OVERALLDIFFICULTY(proof, tx) =

N1
T1

+

N2
T2

(2)

and

OVERALLDIFFICULTY(proof (cid:48), tx) =

N (cid:48)
1
T (cid:48)
1

+

N (cid:48)
2
T (cid:48)
2

.

(3)

}

}

n(cid:48)

=

(4)

2=0

n1=0

∞
(cid:88)

∞
(cid:88)

∞
(cid:88)

+ n2

+ N2

− n(cid:48)
2

− N (cid:48)
2

Pr{N (cid:48)

1 > n1

1 > N1

(cid:0) Pr{N (cid:48)

T (cid:48)
1
T2
T (cid:48)
1
T2

Due to symmetry and N1, N2, N (cid:48)

So, the probability (1) is equal to
T (cid:48)
1
T1
T (cid:48)
1
T1

n2=0
× Pr{N1 = n1} Pr{N2 = n2} Pr{N (cid:48)
1, and N (cid:48)

T (cid:48)
1
T (cid:48)
2
T (cid:48)
1
T (cid:48)
2
2}(cid:1).
2 = n(cid:48)
2 being indepen-
dent random variables, we can assume that T1 ≤ T2 and
T (cid:48)
1 ≤ T (cid:48)
the
scenarios in which a prover has used a higher target difﬁculty
at ﬁrst and then decreased it, can be matched with scenarios in
which the time intervals for each target difﬁculty remain the
same but the lower target difﬁculty comes ﬁrst. As long as the
number of mined blocks, time intervals, and target difﬁculties
remain the same and only their order of occurrence changes,
the probability of the malicious prover winning remains the
same.

loss of generality. In other words,

2 without

Now using Lemma 1 and the fact that N1, N2, and N (cid:48)

2 have
Poisson distributions, we can show that the Probability (4) is
less than or equal to

(cid:18)

∞
(cid:88)

(cid:0)

n1=0

m

λ1t1
T (cid:48)
1
T1
n1!

e

(cid:19)n1

(cid:18)

∞
(cid:88)

(cid:0)

(cid:1) ×

(cid:19)n2

(cid:1) × eλ(cid:48)
1t(cid:48)

1(em−1)

m

λ2t2
T (cid:48)
1
T2
n2!

e

n2=0
(cid:19)n(cid:48)

2

(cid:18)

∞
(cid:88)

(cid:0)

e

×

n(cid:48)

2=0

−m

2t(cid:48)
λ(cid:48)
2
T (cid:48)
1
T (cid:48)
2
n(cid:48)
2!

for any m > 0.

(cid:1) × e−λ1t1 × e−λ2t2 × e−λ(cid:48)
2t(cid:48)

2

(5)

1λ1
T1λ(cid:48)
1

)/(1 + T (cid:48)
1
T1

By using Taylor series of an exponential function and
substituting t2 and t(cid:48)
2 with t − t1 and t − t(cid:48)
1 respectively, and
letting m = m0 = (ln T (cid:48)
), it gets proved that
the expression (5) is equal to T (m0, t, t1, t(cid:48)
1) where function
T (m, t, t1, t(cid:48)
1) is deﬁned in Equation (15). Given the deﬁnition
of target difﬁculty and the honest mining power being more
= λ(cid:48)
> λ(cid:48)
than the adversary mining power, we get λ1
= λ2
.
2
1
T (cid:48)
T (cid:48)
T2
T1
2
1
Using Lemma 3, we conclude that T (m0, t, t1, t(cid:48)
1) exponen-
tially decreases by increasing t,
therefore, by choosing a
proper t (which is the challenge period) the result follows.

Case II. In this case, the probability of the veriﬁer getting
an invalid ﬁnalized block in the ﬁrst part of the protocol is
similar to the previous case which we proved is negligible.
In the second part of the protocol, where the veriﬁer aims to
ﬁnd the last valid MMR root, for the protocol to be secure,
we need to prove two important statements:

• The candidates contain a block header including a valid

MMR root with an overwhelming probability.

• After running the second part of the protocol, the veriﬁer
will decide on a block header among the candidates
including a valid MMR root with an overwhelming
probability.

Given that a block mined by an upgraded honest node
includes a valid MMR root, Theorem 2 results in the ﬁrst
statement. Based on Theorem 3, the probability of an MMR
root that is inconsistent with the honest chain to be chosen as
valid MMR root by the veriﬁer is negligible when α is chosen
properly. It can be easily deduced that the probability of a
valid MMR root getting rejected by the majority of the voters
is the same and is negligible. Therefore, the second statement
is concluded. To give an example for a proper α, let’s assume
a blockchain’s network where Ma = 1
3 and let α = 80. Now,
based on Equation (6), the probability of a wrong MMR root
being chosen by the veriﬁer is less than 0.01.

Suppose the proportion of the upgraded honest mining
power to be Mh and the adversary mining power to be Ma.
We have Mh + Ma = 1. We assume that Mh > Ma.

Theorem 2. Consider the candidates’ block headers. The
probability of none of them having been mined by an honest
node is negligible by choosing the right β.

Proof: The candidates are β block headers where each of
them could have been mined by the honest or the adversary
mining power. The probability of a block being mined by an
honest miner is Mh. We know that the probability of blocks
being mined by honest nodes is independent of each other.
Therefore, the probability of the candidates not including any
β which is negligible for a large
honest block headers is Ma
enough β.

To illustrate this probability, let us consider an example here
3 . Letting β = 7, the

for a blockchain network where Ma = 1
above probability will be less than 0.0005.

Theorem 3. For α → ∞, the probability of an inconsistent
MMR root (Ric) getting more than (cid:100) α
2 (cid:101) accept votes goes to
zero.

Proof: As Ric is not consistent with the honest chain,
the honest miners cast reject votes for it. At most, all the
malicious miners cast accept vote for Ric. The number of
malicious miners in the next α upgraded blocks is the binomial
random variable X with parameters p = Ma and n = α. The
probability of X being greater than or equal to (cid:100) α

2 (cid:101) is:

Pr(X ≥ (cid:100)

α
2

(cid:101)) =

= M (cid:100) α
2 (cid:101)

a

α
(cid:88)

i=(cid:100) α
2 (cid:101)
(cid:19)
(cid:18)α
i

i=(cid:100) α

2 (cid:101)

α
(cid:88)

(cid:18)α
i

(cid:19)

(M i

a)(M α−i
h

)

(M i−(cid:100) α
2 (cid:101)

a

)(M α−i
h

)

(6)

< M (cid:100) α
2 (cid:101)

a

α
(cid:88)

i=(cid:100) α

2 (cid:101)

(cid:19)

(cid:18)α
i

(M (cid:98) α
2 (cid:99)

h

) ≤ (MaMh)

α−1

2 × 2α−1

We know that Ma + Mh = 1 ∧ Ma < Mh ⇒ MaMh <
4 ⇒ MaMh = 2−(2+s), where s > 0. Therefore, Pr(X ≥

1

2 (cid:101)) < 2−s (α−1)
(cid:100) α
limα→∞ Pr(X ≥ (cid:100) α

2

2 (cid:101)) = 0.

, where s = − log2(MaMh) − 2 > 0. So,

VI. CONCLUSION
In this paper, we present LIGHTSYNC, a low-cost light
client protocol that is suitable for Proof of Work blockchains.
Leveraging LIGHTSYNC, a light client can verify the inclusion
of data in the blockchain using constant computation and
storage resources no matter what the length of the blockchain
is. LIGHTSYNC also introduces an incentive mechanism to
compensate full nodes that provide data for the light clients.
We describe the details of applying LIGHTSYNC and perform
a thorough security analysis of it. LIGHTSYNC can be used for
lightweight devices (e.g., mobile phones and IoT devices) that
intend to connect to blockchains and verify data against them.
Another important application of such a protocol is in cross-
chain communication, in which one blockchain wants to verify
the correctness of data against the other one. For future work,
we are going to extend the LIGHTSYNC protocol to support
blockchains using other consensus mechanisms (e.g. Proof of
Stake). Also, we will design a cross-chain bridge using the
LIGHTSYNC.

APPENDIX
In this appendix, we present several technical lemmas used
in Section V. The proofs of these lemmas are omitted due to
the space constraint.

Lemma 1. Suppose that N (cid:48)
rate λ(cid:48)

1. We show that

1t(cid:48)

1 has a Poisson distribution with

Pr{N (cid:48)

1 > n1

− n(cid:48)
2

T (cid:48)
1
T (cid:48)
2

}

(7)

+ n2

T (cid:48)
1
T2
1t(cid:48)

T (cid:48)
1
T1
e(em−1)λ(cid:48)
T (cid:48)
1
T2 )(e

1

≤

(emn1
where m, T1, T2, T (cid:48)

T (cid:48)
1
T1 )(emn2
2 > 0 and n1, n(cid:48)
Proof: For some m > 0, using the Chernoff bound we

T (cid:48)
1
T (cid:48)
2 )
1, n2, n(cid:48)

2 ≥ 0.

1, T (cid:48)

−mn(cid:48)
2

have:

P r{N (cid:48)

1 > n1

T (cid:48)
1
T1

+ n2

T (cid:48)
1
T2
E[emN (cid:48)
1 ]
T (cid:48)
1
T2

+mn2

− n(cid:48)
2

T (cid:48)
1
T (cid:48)
2

}

−mn(cid:48)
2

T (cid:48)
1
T (cid:48)
2

≤

T (cid:48)
1
T1

mn1

e

Now, notice

E[emN (cid:48)

1] =

∞
(cid:88)

n(cid:48)

1=0

emn(cid:48)

1P r{N (cid:48)

1 = n(cid:48)

1t(cid:48)
1} = e(em−1)λ(cid:48)

1

(9)

Proof: It is sufﬁcient to show

lim
t→∞

f (t) = −∞

which is equivalent to showing that

f (t)
t

< 0

We deﬁne

(11)

(12)

(13)

T (cid:48)
1
T1

g(m) = (em − 1)λ(cid:48)

1 − λ1 + λ1e−m
so, inequality (12) is equivalent to g(m0) < 0.

> λ(cid:48)
1
T (cid:48)
1

Considering λ1
T1

, we get g(cid:48)(m)|m=0 < 0. We know
g(0) = 0, also, as the given m0 is the only value for m
satisfying g(cid:48)(m) = 0, we conclude g(m0) < 0.
Lemma 3. Suppose that T2 ≥ T1, T (cid:48)
2 ≥ T (cid:48)
T (cid:48)
1λ1
= λ(cid:48)
T1λ(cid:48)
1
2
T (cid:48)
T (cid:48)
1
2
T1
T (m0, t, t1, t(cid:48)
1) = 0

1, t1 + t2 = t(cid:48)

. Then, we have

. Let m0 =

> λ(cid:48)
1
T (cid:48)
1

1 + t(cid:48)
2,

= λ2
T2

(14)

λ1
T1

1+

ln

lim
t→∞

where

T (m, t, t1, t(cid:48)

1) = et1(−λ1+λ2+λ1e

−m

T (cid:48)
1
T1 −λ2e

−m

T (cid:48)
1
T2 )

×et(cid:48)

1(λ(cid:48)

1em−λ(cid:48)

2e

m

T (cid:48)
1
T (cid:48)
2 −λ(cid:48)

1+λ(cid:48)
2)

(15)

×et(λ(cid:48)
2e
Proof: Let’s deﬁne the below functions

2+λ2e

m

T (cid:48)
1
T (cid:48)
2 −λ2−λ(cid:48)

−m

T (cid:48)
1
T2 ).

f1(m) = −λ1 + λ2 + λ1e−m

T (cid:48)
1
T1 − λ2e−m

T (cid:48)
1
T2

(16)

(17)

m

T (cid:48)
1
2 − λ(cid:48)
T (cid:48)

1 + λ(cid:48)
2

1em − λ(cid:48)

f2(m) = λ(cid:48)
2e
The derivative of f1 is equal to
T (cid:48)
1
T1 + λ2

f (cid:48)
1(m) = −λ1

T (cid:48)
1
T1
λ1
T1
As T2 ≥ T1, we get f (cid:48)
1(m) ≥ 0 for m > 0 and since

T (cid:48)
1
T2
T (cid:48)
1
T2 − e−m

1(e−m
T (cid:48)

T (cid:48)
1
T1 )

e−m

e−m

(18)

T (cid:48)
1
T2

=

(8)

f1(0) = 0, we conclude f1(m) ≥ 0 for m > 0.

The derivative of f2 is equal to
T (cid:48)
1
2 = λ(cid:48)
T (cid:48)

2(m) = λ(cid:48)
f (cid:48)

m
e

1em − λ(cid:48)
2

T (cid:48)
1
T (cid:48)
2
1, we get f (cid:48)
2(m) ≥ 0 for m > 0 and since

1(em − e

(19)

m

T (cid:48)
1
T (cid:48)
2 )

As T (cid:48)

2 ≥ T (cid:48)

f2(0) = 0, we conclude f2(m) ≥ 0 for m > 0.

Given that t ≥ t1, t ≥ t(cid:48)

1, f1(m) ≥ 0, and f2(m) ≥ 0 for

and the result follows.

Lemma 2. Suppose that T1, T (cid:48)
function

1, λ1, λ(cid:48)

1 > 0 and λ1
T1

m > 0, we get

> λ(cid:48)
1
T (cid:48)
1

. For

T (m, t, t1, t(cid:48)

1) ≤ et(f1(m))et(f2(m))et(λ(cid:48)
2e

m

T (cid:48)
1
T (cid:48)
2 −λ2−λ(cid:48)

2+λ2e

f (t) = (em0 − 1)λ(cid:48)

1t − λ1t + λ1e−m0

T (cid:48)
1
T1 t

(10)

where m0 =

ln

T (cid:48)
1λ1
T1λ(cid:48)
1
T (cid:48)
1
T1

1+

, we have limt→∞ ef (t) = 0.

= et((em−1)λ(cid:48)

1−λ1+λ1e

(20)
Based on Lemma 2, for m = m0 the above expression goes

to zero when t → ∞.

−m

−m

T (cid:48)
1
T2 )

T (cid:48)
1
T1 )

REFERENCES

[1] V. Buterin, “Ethereum white paper: A next generation smart contract
& decentralized application platform,” 2014. [Online]. Available: https:
//cryptorating.eu/whitepapers/Ethereum/Ethereum white paper.pdf
[2] “Ethereum chain full sync data size,” (Accessed on July 2021).
[Online]. Available: https://ycharts.com/indicators/ethereum chain full
sync data size

[3] V. Buterin, “Chain interoperability,” 2016. [Online]. Available: https://
www.r3.com/wp-content/uploads/2017/06/chain interoperability r3.pdf
[4] A. Zamyatin, M. Al-Bassam, D. Zindros, E. Kokoris-Kogias, P. Moreno-
Sanchez, A. Kiayias, and W. Knottenbelt, “Sok: Communication across
distributed ledgers,” IACR Cryptol. ePrint Arch., vol. 2019, p. 1128,
2019.

[5] R. Belchior, A. Vasconcelos, S. Guerreiro, and M. Correia, “A survey
on blockchain interoperability: Past, present, and future trends,” 2021.
[6] “Btc relay, a bridge between the bitcoin blockchain & ethereum
[Online]. Available:

smart contracts,” (Accessed on July 2021).
http://btcrelay.org/

[7] “Eth-near

rainbow bridge,” (Accessed on July 2021).

[Online].

Available: https://near.org/blog/eth-near-rainbow-bridge/

[8] P. Gaˇzi, A. Kiayias, and D. Zindros, “Proof-of-stake sidechains,” in 2019
IEEE, 2019, pp. 139–

IEEE Symposium on Security and Privacy (SP).
156.

[9] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” 2009.

[Online]. Available: http://www.bitcoin.org/bitcoin.pdf

[10] A. Kiayias, A. Miller, and D. Zindros, “Non-interactive proofs of proof-
of-work,” in Financial Cryptography and Data Security, J. Bonneau and
N. Heninger, Eds. Cham: Springer International Publishing, 2020, pp.
505–522.

[11] B. B¨unz, L. Kiffer, L. Luu, and M. Zamani, “Flyclient: Super-light
clients for cryptocurrencies,” in 2020 IEEE Symposium on Security and
Privacy (SP), 2020, pp. 928–946.

[12] A. Zamyatin, N. Stifter, A. Judmayer, P. Schindler, E. Weippl, and W. J.
Knottenbelt, “A wild velvet fork appears! inclusive blockchain protocol
changes in practice,” in Financial Cryptography and Data Security,
A. Zohar, I. Eyal, V. Teague, J. Clark, A. Bracciali, F. Pintore, and
M. Sala, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2019,
pp. 31–42.

[13] P. Todd and D. Zindros, “Merkle mountain ranges,” 2018 (Accessed
on July 2021). [Online]. Available: https://github.com/opentimestamps/
opentimestamps-server/blob/master/doc/merkle-mountain-range.md
[14] T. Nemoz and A. Zamyatin, “On the deployment of ﬂyclient as a velvet
fork: chain-sewing attacks and countermeasures,” Cryptology ePrint
Archive, Report 2021/782, 2021, https://eprint.iacr.org/2021/782.
[15] S. Paavolainen and C. Carr, “Security properties of light clients on the
ethereum blockchain,” IEEE Access, vol. 8, pp. 124 339–124 358, 2020.
[16] J. Garay, A. Kiayias, and N. Leonardos, “The bitcoin backbone protocol
with chains of variable difﬁculty,” in Advances in Cryptology – CRYPTO
2017, J. Katz and H. Shacham, Eds.
Cham: Springer International
Publishing, 2017, pp. 291–323.

[17] R. C. Merkle, “A digital signature based on a conventional encryption
function,” in A Conference on the Theory and Applications of Cryp-
tographic Techniques on Advances in Cryptology, ser. CRYPTO ’87.
Berlin, Heidelberg: Springer-Verlag, 1987, p. 369–378.

[18] V. Buterin, “Hard forks, soft forks, defaults and coercion,” (Accessed
on July 2021). [Online]. Available: https://vitalik.ca/general/2017/03/
14/forks and markets.html

[19] “Beam description. comparison with classical mw,” (Accessed on July
2021). [Online]. Available: https://docs.beam.mw/BEAM Comparison
with classical MW.pdf

[20] “Merkle

mountain

ranges
[Online]. Available:

2021).
merkle-mountain-range/

(mmr),”

July
(Accessed
https://docs.grin.mw/wiki/chain-state/

on

[21] Y. Tong Lai, J. Prestwich, and G. Konstantopoulos, “Flyclient

-
consensus-layer changes,” 2019. [Online]. Available: https://zips.z.cash/
zip-0221

[22] “Pay to script hash,” (Accessed on July 2021). [Online]. Available:

https://en.bitcoin.it/wiki/Pay to script hash

