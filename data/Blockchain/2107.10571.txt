2
2
0
2

y
a
M
2
1

]

R
C
.
s
c
[

3
v
1
7
5
0
1
.
7
0
1
2
:
v
i
X
r
a

1

Always on Voting: A Framework for Repetitive
Voting on the Blockchain

Sarad Venugopalan, Ivana Stanˇc´ıkov ´a, Ivan Homoliak

Abstract—Elections are commonly repeated over longer and ﬁxed time intervals, ranging from months to years. This results in
limitations on governance since elected candidates or policies are difﬁcult to remove before the next election even though they might
be deemed detrimental to the majority of participants. When new information is available, participants may decide (through a public
deliberation) to make amendments to their choice but have no opportunity to change their vote before the next elections. Another issue
is the peak-end effect, where voters’ judgment is based on how they felt a short time before the elections instead of judging the whole
period of the governance. Finally, there exist a few issues related to centralized e-voting, such as censorship and tampering with the
results and data. To address these issues, we propose Always on Voting (AoV) — a repetitive blockchain-based voting framework that
allows participants to continuously vote and change elected candidates or policies without having to wait for the next election.
Participants are permitted to privately change their vote at any point in time, while the effect of their change is manifested at the end of
each epoch, whose duration is shorter than the time between two main elections. To thwart the peak-end effect issue in epochs, the
ends of epochs are randomized and made unpredictable. While several blockchain-based e-voting proposals had been already
presented, to the best of our knowledge, none of them addressed the issue of re-voting and peak-end effect.

Index Terms—Blockchain Governance, Security, Voting, Peak-End Effect, Privacy, Veriﬁable Delay Function.

(cid:70)

1 INTRODUCTION

Voting is an integral part of democratic governance, where
eligible participants can cast a single vote for their repre-
sentative (candidate or policy) through a secret ballot. The
outcome is an announcement of winners through a tally
of votes, governed by the rules of the electoral system. In
practice, the time interval between two regularly scheduled
elections may be large − ranging from months to years.
Over time, a previously popular winning candidate (or
policy) may have fallen out of favor with the majority of
participants.

First, a common lacking attribute in governance is the
ability of participants to reverse or correct the previous deci-
sions that were collectively voted for when new information
is available after the election. Reasons for poor decision
making (i.e., error premise [1]) may arise from insufﬁcient
or false information, search engine manipulation effect [2],
social media manipulation [3], or from agenda setters [4],
[5]. To deal with this issue, we propose a repetitive voting
strategy. Repetitive voting gives its participants the ability
to change their vote anytime they decide. Nevertheless,
even with repetitive voting with ﬁxed intervals, participants
remain exposed to constant manipulation attacks. However,
in contrast to standard voting with long intervals, partici-

•

•

Sarad Venugopalan is currently with Singapore-ETH Centre, Singapore.

Ivana Stanˇc´ıkov´a and Ivan Homoliak are with Brno University of
Technology, Czech Republic.

• Any opinions, ﬁndings and conclusions or recommendations expressed in
this material are those of the author(s) and do not reﬂect the views of their
employer(s).

pants of repetitive voting might hold any elected candidate
accountable by changing their vote choice.

A second concern is a peak-end effect, whose discovery
in behavioral science is attributed to Nobel laureate Kahne-
man and his research collaborators [6], [7]. Their study on
the correlation of pain perception over time indicated that
duration plays a minor part in retrospective evaluations of
aversive experiences. The experiences are also dominated by
discomfort at the worst and the ﬁnal moments of episodes.
Carmon and Kahneman [8] found that how participants felt
at the ﬁnal moment of the experience was a good predictor
of their overall experience evaluation responses.

There are many studies in political science analyzing and
conﬁrming the existence and impact of the peak-end effect
that might be caused by economic growth in the election
and pre-election year [9], [10], [11], increased spending on
highly visible areas [12], [13], [14], private and government
credit easing [15], strategically planned welfare reforms [16],
and cash transfer in exchange for using school and health
services by poor households [17]. The details of related work
to the peak-end effect occurring in voting are presented in
Section 7.2.

Our Approach. We propose Always-on-Voting (AoV) that
supports 1-out-of-k candidate voting and runs on a
blockchain1. AoV has three key features: (1) it works in
repetitive epochs, (2) voters are allowed to change their
vote anytime before the end of each epoch (when the tally
is performed), and (3) ends of epochs are randomized and
unpredictable. Only the supermajority of votes can change
the previous winning vote choice at the end of each epoch.

1A blockchain is a Byzantine State Machine Replication.

 
 
 
 
 
 
In AoV, to thwart2 peak-end effects and decrease ma-
nipulation of participants, we randomize the time intervals
between election epochs using public randomness and se-
cure it with a veriﬁable delay function (VDF). The tally
time is random and unpredictable, denying everyone from
obtaining the knowledge of the time when the next tally
will be computed. One of the obstacles to implementing
repetitive voting is increased resource expenditure (e.g.,
time and money). To alleviate cost concerns, we use a public
permissioned blockchain (see Section 6.2).

Several e-voting and blockchain voting solutions under
various security requirements are compared in Venugopalan
et al. [18]. In this work, we focus on providing a solution to
security challenges arising from changes introduced by AoV,
i.e., randomized tally times and repetitive voting.
Contributions. We make the following contributions.

i) We identify two shortcomings in present governance
systems for voting, namely: a) the inability of partic-
ipants to change their vote between two consecutive
elections (that might be a few years apart), and b) a
manipulation of participants via peak-end effect (see
Section 7.2).

ii) We propose Always-on-Voting (AoV) framework for
repetitive voting, which incorporates voting epochs
and alleviates the shortcomings of present governance
systems (see Section 4).

iii) We propose the use of public randomness to determine
when the current iteration of voting should end using
commitments to a future event in order to thwart the
peak-end effect tactics (see Section 4.4).

iv) Due to the repetitive nature of the proposed framework,
voting that uses a blockchain wallet address might
enable an adversary to make statistical inferences re-
garding the user identiﬁers. We propose a mechanism
to cope with this issue by breaking the map between
the participant’s wallet address and her vote (see Sec-
tion 4.6).

v) We analyze the privacy implications of booth sharding
and booth size (see Section 5.2). Then we analyze the
randomness of the Bitcoin proof-of-work puzzle solu-
tion (hereafter referred to as a nonce) and AoV entropy
requirements in Section 5.3.

2 BACKGROUND

In this section, we describe the preliminaries required to
describe our approach.

2.1 Bitcoin Proof-of-Work Puzzle

Bitcoin uses proof-of-work (PoW) to achieve consensus
among consensus nodes (a.k.a, miners). A Bitcoin block
(on average) is generated once every 10 minutes. A block
consists of 2 parts — header and body. The Bitcoin header

2The voting start and end times need to be known in advance to
put in place the policies required to boost the election campaign and
entice a large number of voters over a short period of time. However,
with AoV, though it is possible to make election promises, they run
hollow after a while, and the spending budget is distributed over a
longer period of time because of the repeated nature of voting and its
uncertain tally timing, reducing the peak ‘awe’effect, making it a less
effective strategy to win votes.

2

has a ﬁeld called nBits that encodes Bitcoin mining difﬁculty.
The merkle root ﬁeld stores the root of the Merkle hash tree
corresponding to the transactions in the block. The Bitcoin
proof-of-work puzzle is a lottery solved by ﬁnding a nonce
s; such that the SHA-256 hash of the Bitcoin block header
that contains s is lower than target (see Walker [19]). The
32-bit nonce itself is a part of the header and adjusted using
a random trial-and-error approach until a solution is found.
The mining difﬁculty changes every 2016 blocks (i.e., ca.
every 2 weeks). The difﬁculty is decreased if it took more
time to mine 2016 blocks and increased if less time was
required.

In this work, we will use Bitcoin headers (from yet to
be generated blocks) to source the public randomness. We
analyze the randomness derived from Bitcoin headers in
Section 5.3 to show that it meets our entropy requirements.

2.2 Veriﬁable Delay Function
The functionality of VDF [20] is similar to a time lock3
function, but in addition, by providing a short proof, a
veriﬁer may easily check if the prover knows the output
of the VDF. The function is highly serialized, and parallel
processing does not help with speeding up VDF evaluation.
A moderate amount of sequential computation is required
to evaluate VDF. Given a time delay t, a VDF must satisfy
the following conditions: for any input x, anyone may
ﬁnd VDF(x) in t sequential steps, but an adversary with p
parallel processing units may not distinguish VDF(x) from a
random number in signiﬁcantly fewer steps. Further, given
a proof, a veriﬁer may check the output y =VDF(x) in
logarithmic time w.r.t t. The safety factor Amax is deﬁned
as the number of times an adversary is estimated to be able
to run VDF calculations faster on proprietary hardware as
opposed to a benign VDF evaluator using commercial hard-
ware (see Drake [21]). CPU overclocking world records [22]
also indicates that Amax = 10 is a reasonable estimate. I.e.,
the adversary with proprietary hardware is unlikely to solve
the VDF more than an order of magnitude times faster than
a benign user with commercial hardware.

2.3 E-Voting

A number of e-voting projects and protocols are discussed in
Curran [23] and Venugopalan et al. [18]. Typically, any elec-
tronic election has a parameters setup phase, participants
registration phase, followed by the standard voting phase
and tally phase. These elections include various actors such
as an election authority, contesting candidates, and voters.
Depending on the voting protocol used and the actors
involved, they inherit its underlying security properties.
For further details about particular e-voting approaches
utilizing blockchain, we refer the reader to Section 7.

3 SYSTEM & ADVERSARY MODEL
3.1 System Model

Our model has the following main actors and components:
i) A participant (voter) partakes in governance by casting a

3Time locks are computational problems that can only be solved by

running a continuous computation for a given amount of time.

3

Figure 1. The time between two regular elections is divided into a ﬁxed number of intervals (a.k.a., f t) or epochs. First, the ratios of votes for all vote
choices (i.e., candidates) are initialized from the last election. Further, repeated voting through k epochs results in a winning vote choice transition
(from C to A). The new winner A is declared when she obtains a supermajority of 70% (see Section 4) of total votes at interval k; k ≤ f t. Note that
r1, . . . , rk are randomized times that determine the length of the intervals 1, ..., k. The tally is computed at the end of each interval.

vote for her choice or candidate. ii) Election Authority (EA)
is responsible for validating the eligibility of participants to
vote in elections, registering them, and shifting between the
phases of the voting. iii) A smart contract (SC) collects the
votes, acts as a veriﬁer of zero-knowledge proofs, enforces
the rules of the election and veriﬁes the tallies of votes.
iv) Bitcoin Puzzle Oracle (BPO) provides an off-chain data
feed from the Bitcoin network and supplies the requested
Bitcoin block header (BH) when it is available on the Bitcoin
network. v) A VDF prover is any benign user in the voting
ecosystem who evaluates the output of VDF and supplies
proof of its correctness to SC.

3.2 Adversary Model

There are two types of adversaries: the network adversary
Advnet and a Bitcoin mining adversary Advmin. Both ad-
versaries are static and have bounded computing power
(i.e., they are unable to break used cryptographic primitives
under their standard cryptographic assumptions). Advnet is
a passive listener of communication entering the blockchain
network but cannot block it. Advnet may be any authorized
blockchain participant. Advmin can mine on the Bitcoin
blockchain. 4 She is not assumed to always work on extend-
ing the canonical chain, and may withhold valid blocks she
ﬁnds. Furthermore, election authority is assumed to verify
identity honestly and supply addresses of only veriﬁed
users to SC.

3.3 Design Goals

The AoV framework has three main design goals.

1) Repeated voting epochs: Participants are allowed to
continuously vote and change elected candidates or
policies without waiting for the next election. Partici-
pants are permitted to privately change their vote at
any point in time, while the effect of their change is
considered rightful at the end of each epoch. The dura-
tion of such epochs is shorter than the time between the
two main elections.

2) Randomized time epochs: The end of each epoch
(when the tally is computed) is randomized and made
unpredictable. In contrast to ﬁxed time epochs, the

4Therefore, according to the security reference architecture for
blockchain presented in Homoliak et al. [24] our attackers appear on
the network and consensus layer.

proposed randomized time epochs are used to thwart
the peak-end-effects by preventing agenda setters from
announcing policies and perks closer to the time of
the election to entice voters (as is the case with most
traditional elections with ﬁxed epochs).

3) Plug & play voting protocols: The AoV framework
is designed to “plug & play” new or existing voting
protocols. As a result, AoV inherits the properties of
the underlying protocol chosen. AoV itself does not
restrict5 what e-voting protocol may be used because
all it does is determine the voting phase end time6.
In practice, due to the repetitive nature of AoV, any e-
voting protocol that is complex to implement and time-
consuming to compute tallies may be avoided (e.g., self-
tallying protocols).

4 ALWAYS ON VOTING FRAMEWORK

Always-on-Voting (AoV) is a framework for a blockchain-
based e-voting, in which voting does not end when the
votes are tallied and the winners are announced. Instead,
participants can continue voting for their previous vote
choice or change their vote. A possible outcome of such
repetitive voting is transitioning from a previous winning
candidate to a new winner. To achieve this, the whole
time interval between two regularly scheduled elections
is unpredictably divided into several intervals, denoted as
voting epochs. Participants may change their vote anytime
before the end of a voting epoch (i.e., before a tally of the
epoch is computed); however, they do not know beforehand
when the end occurs. Any vote choice that transitioned into
the supermajority threshold of votes is declared as the new
winner of the election, and it remains a winning choice until
another vote choice reaches a supermajority threshold.

4.1 Underlying Voting Protocol

AoV provides the option to plug and play any suitable
e-voting protocol. To provide the baseline security and
veriﬁability, we assume the voting protocol plugged into
the AoV framework allows voters to blind or encrypt their
votes and the ability to prove their vote is valid. Beyond it,

5In the interest of security, AoV will assume a secret ballot where
votes can be privately veriﬁed to be correct, though it is not mandatory.
6Typically, the start of the tally phase also coincides with the end of

the voting phase.

r2rkCandidate A(25% of votes)Candidate C(55% of votes)Candidate D(5% of votes)T2=T1+r2Tk = Tk-1+rk(Interval 1)(Interval 2)(Interval k)Candidate A(win % from election)Candidate B(win % from election)Candidate C(win % from election)Candidate D(win % from election)IntervalSupermajority Winning Threshold: 70%. T:Tally Timetime=0r1T1=r1Initialize voting results on smart contractCandidate B(15% of votes)Candidate A(15% of votes)Candidate C(60% of votes)Candidate D(15% of votes)Candidate B(10% of votes)Candidate A(70% of votes)Candidate C(20% of votes)Candidate D(5% of votes)Candidate B(5% of votes)4

Figure 2. When the tally computation is triggered, each booth computes
the sum of all votes cast at the booth (referred to as booth tally). Each
booth tally is further summed up to determine the total tally. Pictorially,
the booths are numbered 1 to X along the rows and 1 to Y along the
columns. There are a total of X · Y booths.

the AoV framework makes no representation of the features
supported by the plugged-in voting protocol. Such details
are intentionally omitted.

Figure 3. Interaction among participants, election authority, smart con-
tracts, the Oracle, and VDF prover. (1) Registering wallet addresses of
participants (2) and their identity veriﬁcation are carried out by the EA.
(3) Participants send a blinded vote and its zero-knowledge proof (ZKP)
of correctness to their assigned booth contract. The booth contract
veriﬁes the validity of the vote (ZKP). (4) The Bitcoin Puzzle Oracle
(BPO) provides the latest Bitcoin block header and (5) VDF prover
sends a proof of sequential work for y to the validator contract. (6)
The validator contract ﬁnishes the epoch and shifts the election state
to the tally when f (y) meets the required condition. (7) The aggregator
contract is responsible for totaling individual booth tallies and (8) publicly
announcing the total tally.

4.2 Example of Operation

4.3 AoV Phases

Figure 1 illustrates a scenario with 4 candidates as follows.
The candidate C is the present winner of the election.
A supermajority threshold of 70% votes is set for future
winnings (see justiﬁcation later). However, this is a tunable
parameter that may be suitably tailored to the situation.
All candidates are initialized to their winning percentages
of obtained votes from the last election. Over time, the
individual tally is observed to shift as the supermajority of
participants decided to change its vote in favor of another
candidate by voting in the intervals. Through k intervals,
the winner-ship is seen to transition from candidate C to
A. At the kth interval, candidate A is seen to attain the
70% threshold of votes and is declared as the new winner.
Note that a supermajority is required only in the voting
epochs between two regularly scheduled main elections
(exclusively). E.g., If the regular election were to repeat
after every 4 years, then a majority (i.e., >50%) is sufﬁcient
to declare a winner immediately after the 4-year interval.
Regular elections are also executed within AoV. Hence, in
contrast to existing electoral systems, we only implement
changes between regularly scheduled elections and enable
new candidates to be added or removed.

Justiﬁcation for Supermajority. A supermajority of 70% was
chosen to help the incumbent carry out reforms without
the risk of losing when there is still sufﬁcient participant
support for the reforms. However, it may also be used
to block (or repeal) policies that are unpopular to a vast
majority of eligible voters. Additionally, we aim to avoid
the quorum paradox [25] (see Appendix B for details) by
setting a minimum participation requirement of 70% from
the just concluded main election.

Once the setup phase (that ensures the participants agree
upon all system parameters) is completed, electronic voting
frameworks typically consist of three phases: (1) a registra-
tion phase to verify voter credentials and add them to the
voting system, (2) a voting phase, in which participants cast
their vote via a secret ballot, and (3) a tally phase, where
the total votes for each candidate are counted and revealed
to the participants. The voting protocol plugged-in with the
AoV framework may contain additional phases, but we omit
them here for brevity.

The architecture of AoV is shown in Figure 3. In AoV, the
participants (in step 1) register their wallet address with the
EA, who then (in step 2) veriﬁes and updates it on the booth
smart contract7. This is followed by the voting phase (in step
3), where participants cast a secret ballot. The voting phase
ends when the tally phase is triggered. Tally trigger time
is determined with the assistance of Bitcoin Puzzle Oracle
(BPO), VDF prover, and validator contract. The role of BPO
(step 4) is to supply the validator contract and VDF prover
with the recent Bitcoin block header BH and its block
height. The VDF prover8 (in step 5) computes and submits a
proof of sequential work (i.e., V DF (BH)) to the validator
contract. Incorporating VDF into our protocol is proposed
to prevent a mining adversary from biasing the length of
time intervals between epochs – i.e., prematurely triggering
the end of any epoch. The validator contract (in step 6)

7The participants are randomly grouped and assigned to booths
∈ {1, 2, ..., X · Y } (see Figure 2), represented by a booth smart contract.
8A VDF prover is any benign user in the voting ecosystem with
commercial hardware to evaluate the input of VDF, i.e., y =VDF(BH)
and supply a proof (π).

Booth X,1Booth 1,1Booth 1,YBooth X,YBooth TallyTotal TallyAggregatorSmart Contract3. Blinded Votes and Proof of Valid VotingParticipants1. Register WalletAddress2. Verify Address List & Update 8. Publish Tally Results ContractBooth1ContractBoothXYBitcoinPuzzleOracleValidatorContractTrue6. Trigger tally computationP1,P2,...PnFalse 4. Supply target, block header BH, heightreturn (-1)EAEA: Election AuthorityVDF Prover 5. Supply y=VDF(BH); proof 7. Compute tallyveriﬁes the VDF proof and checks whether the supplied
nonce s (included in the block header) is a valid solution
to the recent Bitcoin PoW puzzle. If both veriﬁcations pass,
the validator contract computes a function derived from the
evaluated value of y = V DF (BH), where BH is the Bitcoin
block header. If its output is T rue, the contract ﬁnalizes
the epoch and triggers the tally computation for the epoch.
Otherwise, it waits for the next block header submission
from the BPO and proof of sequential work from the VDF
prover. The BPO, VDF prover, and validator contract are
described in Section 4.4. When the tally computation is
triggered, each booth contract {1, 2, ..., X · Y }, sums up
all its local vote counts and sends them to the aggregator
contract. Then, the aggregator contract totals the votes from
each booth contract (see step 7). It is followed by publishing
the tally results (step 8).

From the initialization of AoV until the next regular
election, the validator smart contract accepts all future Bit-
coin block headers. The new block headers (as part of the
block) arriving every 10 minutes on average are appended
to the Bitcoin blockchain. The BPO is responsible for timely
supplying9 each new block header to the VDF prover and
validator contract. The VDF prover computes the VDF on
each of those block headers after they are supplied.
Example of VDF Computation and Effect. We demonstrate
the situation in the following simpliﬁed example. Let us
assume 10 block headers BHi+1, ..., BHi+10 to be produced
in ∼100 minutes. We divide the 100 minutes into 5 intervals
(i.e., 20-minute chunks). In practice, the block headers ap-
pear sequentially over time, about once every 10 minutes.
On average, two block headers will be produced within each
20-minute interval. When the ﬁrst block header BHi+1 ar-
rives, the validator contract veriﬁes whether V DF (BHi+1)
mod 2 is equal to 0.

When the next block header is available,

it veriﬁes
whether V DF (BHi+2) mod 2 = 0. This is done for all 10
block headers in a chain. Whenever the condition evaluates
to zero, the validator contract triggers the computation of
the epoch tally.

The role of the VDF is to force a Bitcoin mining ad-
versary to wait for at least 10 minutes, so she cannot ﬁnd
more than 1 PoW solution per Bitcoin block and check if
V DF (BHi) mod 2 is in her favor (i.e., V DF (BHi) mod 2 =
0), which enables her to trigger the end of epoch arbitrary.
Without VDF, there is no time lock, and a mining adversary
may be able to check V DF (BHi) mod 2 = 0 in earlier
than 10 minutes. If unfavorable, she may be able to search
for another PoW puzzle solution (nonce) for the same block,
increasing the probability of ﬁnding a nonce that triggers the
epoch tally. The VDF is used to prevent this from occurring.
I.e., a mining adversary, on top of ﬁnding a valid Bitcoin
nonce, is forced to take on the role of a VDF solver (see
details in Section 5.1).

5

randomness relies on Bitcoin Proof-of-Work to generate
valid nonces.10 The validator contract awaits future block
headers yet to be mined on the Bitcoin network. When new
Bitcoin block headers arrive, they are sent to the validator
contract and the VDF prover via the BPO. The VDF ensures
that a mining adversary cannot ﬁnd more than one valid
nonce to a block and test if the nonce is favorable within
10 minutes. The VDF on the block header is evaluated by
the VDF prover, who then submits the VDF output and
proof of sequential work to the validator contract. The
choice of VDF depends on its security properties, speed
of veriﬁcation, and size of the proof [26]. Let BH be the
Bitcoin block header. Once we compute y = V DF (BH),
a small proof (π) is used to trivially verify its correctness
using V DF V erif y(y, π). Wesolowski’s construction [27]
is known for its fast veriﬁcation and a short proof: Let T L
be the number of sequential computations. Prover claims

and computes a proof

y = BH 2T L

π = BH (cid:98) 2T L

B (cid:99),

where B = Blake256(BH || y || T L) hash. Veriﬁer checks
whether

πB · BH 2T Lmod B ?= y.

By employing the VDF, an adversarial Bitcoin miner cannot
know the value of y before evaluating the VDF and is forced
to wait for a given amount of time to see if the output is
in her favor (before trying again). However, since Bitcoin
mining is a lottery, other miners can solve the puzzle and
append a block by propagating the solution to the Bitcoin
network, rendering any withheld or attempted solution by
the adversary that was not published useless.

4.4.1 Interactions of BPO, VDF Prover, and Validator
Let T otalT ime be the time in minutes between 2 regular
elections. The BPO (see Figure 3) feeds the block header
BH of every future Bitcoin block (when it is available) to
the validator contract and VDF prover. The target does not
change for 2016 blocks. The oracle is only required to send
the target value when it changes.

First, the VDF prover computes VDF output

y = V DF (BH)

(1)

and VDF proof π and sends it to the validator contract.
Next, the validator contract carries out the following two
veriﬁcations (the order may be swapped):

V DF V erif y(y, π) ?= T rue,

SHA256(BH) < target.

(2)

(3)

4.4 Publicly-Veriﬁable Random Tally Times

Due to concerns that Bitcoin nonces are a weak entropy
source, additional steps are taken to make it cryptograph-
ically secure (see details in Section 5.3). Our notion of

9To cater to chain forks and respect the ﬁnality of the Bitcoin

network, we assume only blocks with at least 6 conﬁrmations.

The ﬁrst veriﬁcation checks if the VDF output y and
supplied proof π (see Equation 2) corresponds to the BPO
supplied block header BH. If V DF V erif y returns T rue,
it passes the veriﬁcation.

10If the nonce overﬂows, a parameter called extraNonce (part of the
coinbase transaction) is used to provide miners with the extra entropy
needed to solve the PoW puzzle.

The second veriﬁcation (see Equation 3) is for the valida-
tor contract to check whether the nonce received from BPO11
is a valid solution to the Bitcoin PoW puzzle. Once the
results of both veriﬁcations are T rue, the validator contract
proceeds to compute

a = SHA(y),

(4)

where SHA(.) is SHA-X-25612 hash. The goal of Equation 4
is to consolidate the entropy by passing it through a com-
pression function that acts as a randomness extractor (see
Section 5.3). Using a, the validator contract computes

b = a (mod IntervalT ime),

(5)

where interval time is found as

IntervalT ime = T otalT ime/(f t · BlockT ime).

(6)

As seen in Figure 1, f t is the number of intervals that
the total time between 2 regular elections is divided into.
BlockT ime is the average time of block generation (i.e., 10
minutes in Bitcoin).

Tally computation for the interval is triggered when the

output of the validator contract is T rue:

V Coutput =

(cid:40)

if b = 0

True,
False, otherwise.

(7)

E.g., Let T otalT ime = 4 years = 4 · 525600 minutes and the
total number of intervals f t = 8; then IntervalT ime =
(525600 · 4)/(8 · 10) = 26280. On average, the oracle will
send 26280 block headers (BH values) to the validator
contract within 182.5 days (assuming 10 minutes Bitcoin
block interval), i.e., 1/8th of the total time. We expect the
tally will be triggered on average once in every interval of
182.5 days because of the Poisson probability distribution of
this event. Therefore, f t is the expected number of epochs.
Note that the number of epochs between two main elections
might differ across regular election iterations.

4.5 Changing a Participant’s Vote

A participant may vote at any time in a given interval
(see Figure 1). After voting, she may be presented with the
new information unavailable at the time of voting. In the
light of newly available information, a participant (through
public deliberation) may decide to change her vote choice.
The AoV framework permits participants to change their
vote anytime. The effect of the change is manifested at the
end of the epoch when the tally is computed. A participant
must use a new blinding key whenever she changes her
vote. Reusing blinding keys might result in revealing the
participant’s vote and thus cause privacy issues.13

A blinded vote provides conﬁdentiality, and a zero-
knowledge proof of the set membership ensures the vote is

11W.l.o.g, a single BPO may be replaced by a quorum to improve
decentralization. Validator contract accepts the BPO solution only when
> 2/3rd of them are in agreement. Note that the validator contract will
check the signatures of the quorum.

12X denotes a suitable hash function such as SHA-3, and 256 is the

output length in bits.

6

correct (without revealing any information about the vote
choice). However, a network adversary can observe the
vote events on the smart contract even though the vote
choice remains conﬁdential. A participant might vote in one
interval and then vote again in a future interval. A network
adversary cannot distinguish whether the participant voted
again for the same candidate or changed her vote to a differ-
ent candidate (due to the vote being blinded with a different
blinding key). However, both votes may be mapped to the
same participant blockchain wallet address, and Advnet is
able to determine the number of times a participant voted
and make other statistical inferences (see Section 4.6 below).

4.6 Anonymizing Identity

In this section, we use the idea presented in type 2 de-
terministic wallets (see Maxwell [28], [29]) to break the
map between a participant and her vote. This is achieved
by generating a new indistinguishable wallet address for
every time a participant wishes to vote. As a result, the
network adversary Advnet
is unable to map any new
participant wallet address to any of her previous wallet
addresses. The objective is to synchronize a practically
unlimited number of wallet public keys (one per voting)
between EA and a participant P such that this public key
list can be regenerated only by these two parties, and the
corresponding private keys can be computed only by P .
As mentioned in Section 3.2, the EA is assumed to verify
identities honestly, and it supplies veriﬁed identities to the
smart contract. Groth [30] proposed a shufﬂe solution to
break the map between a participant and her vote using
random permutations. Lai et al. [31] used stealth addresses
to embed the candidate choice in the participant wallet
public key. Their approach required the veriﬁer to access the
candidate’s private keys to recover the vote. We use wallet
addresses to keep track of authorized participants in our
scheme. The candidate’s choice is independent of the wallet
public key, and the candidate’s private keys are not required
to be revealed. Partitioning the candidate choice from the
wallet public key allows our scheme to be used in a more
generalized setting.

The wallet address is generated as a function f of the
elliptic curve public key. Once the public key is available, it
is straightforward for anyone to compute the corresponding
wallet address. Let BP be the base point on the elliptic
curve. Further, let P K be the blockchain wallet public key
corresponding to a private key SK. Here, SK is chosen as a
random positive integer whose size is bounded to the order
of BP on the chosen elliptic curve modulo a prime number.
Note that Equation 8 – Equation 12 are computed ofﬂine. As
an illustration, let the ﬁrst public key be computed as

P K0 = SK0 · BP

and the next public key be

P K1 = P K0 + SK1 · BP.

From Equation 8 and Equation 9, we observe that

(8)

(9)

(SK0 + SK1) · BP = P K1.

(10)

13Note that the exact details of the information leakage depend on

the blinding algorithm used.

The following steps ensue.

Algorithm 1: VDF Add
1 Def VdfAdd(V DF (BH), π, blockheight):
2

writeState(“vdf add” || blockheight, V DF (BH) || π)

i) During the identity veriﬁcation, a participant P sends
to EA: a) wallet public key P K0, b) a random shared
secret key hk, and c) parameters (g, p), where g is a
randomly chosen generator in F ∗
p and p is a large prime.
The wallet address is a public function of the wallet
public key. Hence, EA computes W0 = f (P K0) and
stores it.

ii) The private key of P at any future voting iteration e =

{1, 2, 3, ..., 2128 − 1} is generated by P as
SKe = SK0 + HM AChk(ge),

(11)

where ge ∈ F ∗
p is the pseudo-random number genera-
tor (PRNG) output at iteration e, HMAC(.) is HMAC-X-
256 using shared secret key hk between EA and voting
participant P . The shared key is unknown to Advnet
and is used to stop her from mapping participant wallet
addresses.

iii) The corresponding public key of P is

(12)

P Ke = P K0 + HM AChk(ge) · BP
EA and P can compute the public key, but all private
keys are held only by P . This effectively separates the PKs
from their SKs and, at the same time, maps it to P ’s ﬁrst
wallet public key, i.e., P K0. At any voting iteration e, the
public key P Ke, and the corresponding wallet address can
be computed by both EA and P . Since the shared secret
hk used with HMAC is known only to EA and P , no third
party, including Advnet, is able to compute any future public
keys. Since a sequence of wallet addresses of a participant is
given by We = f (P Ke), the map between the wallet address
and the participant is broken for all other parties other than
EA and P . Further, the EA sets a valid/invalid ﬂag to the
smart contract for the new wallet address posted by P .
Since Advnet is no longer able to correlate the identity of
wallet addresses added to the smart contract, any statistical
inference attacks are prevented. It is important to note that
if a participant changes her vote within the same interval,
the EA is required to set participant P ’s previous wallet
address to “invalid” to prevent double voting whenever P
submits her new wallet address to continue voting. This
allows Advnet to link the two wallets. A participant who
values wallet privacy must change her vote only during
the next (or a future) interval. This is because any future
interval employs a revote, and it resets the voting for all
participants. In case a participant votes more than once in an
interval, her wallet addresses may be linked by Advnet, but
only the EA knows the true identity of the wallet address
holder (i.e., participant). Using VPN/dVPNs may further
limit the network adversaries’ ability to map participant IP
addresses.

Algorithm 2: BPO Add
1 Def BpoAdd(T arget, BH, blockheight):
2

writeState(“bpoadd” || blockheight, BH || T arget)
writeState(“blockheightStored”, blockheight)
writeState(“blockheader” || blockheight, BH)

7

3

4

3

4

5

6

7

8

9

10

11

12

13

14

15

Algorithm 3: Trigger Mechanism
1 Def VerifyTrigger(V DF (BH), π, T, BH):
2

y = VDF(BH)
b = −1
tt= readState(params struct.totaltime)
f t= readState(params struct.f t)
seed= readState(params struct.key)
intervaltime = tt/(f t · 10)
if SHA256(BH) < T then

if V erif y V DF (y, π) == T rue then

a = SHA(y)
b = a(mod intervaltime)

if b==0 then

return T rue

else

return F alse

comprises of 5 main functions — setup, registration, voting,
tally and revote. The system parameters agreed upon are
added by EA using the setup function of the smart contract.
The EA is also responsible for adding the list of valid
participants’ wallet addresses to the contract through the
registration function. The voting function is supplied by a
participant’s wallet address, blinded vote, and its proof of
correctness. This information is signed with Pi’s private key
and sent to the contract. The voting function carries out the
necessary veriﬁcations and adds her vote. The participant
wallet address is set to “voted” to disallow its reuse. Before
invoking the tally function, the VDF prover and Bitcoin
oracle deposit their respective solution and its proof to the
contract (see Algorithm 1 and Algorithm 2). Next, the tally
function is called by EA or any authorized participant. The
tally function carries out two main tasks. First, it checks
whether the condition to trigger the interval tally is satisﬁed
(see Algorithm 3). The second task (when triggered) is to
tally the votes and return the results. When a participant
wishes to vote again, she sends her next wallet address
(synchronized with EA) to the revote function. The EA will
verify the new wallet address ofﬂine and call the registration
function to set the new address to valid. Next, a participant
may call the voting function and vote using her new wallet
address.

While different voting protocols may be used with this
framework, resolving the dependencies needed to complete
the tally is left to the voting implementation.

5 ANALYSIS

5.1 Mining Adversary

4.7 Functionality

The high-level functionality of the AoV framework and
its smart contracts is shown in Algorithm 4, and the trig-
ger mechanism is presented in Algorithm 3. Algorithm 4

The goal of Advmin is to ﬁnd a valid nonce s that solves the
Bitcoin puzzle such that b in Equation 5 is 0. When these two
conditions are met, and the new epoch is about to start, the
validator contract triggers the tally computation of votes.

Algorithm 4: Always on Voting Framework

Input: Set1: ∀ participants Pi, wallet addresses (W Aij ), blinded vote BVij (by Pi for her jth voting occurence, j = 0, 1, 2, 3, ...) & zero

knowledge proof of vote correctness (ZKPij ), boothno. Set2: system parameters init params, BTC blockheader BH,
V DF (BH), proof π, BTC target T , BTC blockheight.

Output: Total tally of votes in the interval.

1 Function Setup(init params):
2

writeState(params struct, init params) // add system parameters as key-value pairs.

8

5

6

7

8

9

10

13

14

15

16

17

18

19

22

23

24

25

26

27

28

29

32

33

3 Function Registration(msg1 = W Aij , msg2 = valid f lag, EA signed msg):
4

msg = msg1 || msg2 // concatenate message parts.
EA pubkey= readState(params struct.EA public key) // get EA public key.
if VerifySig(msg, EA signed msg, EA pubkey) = T rue then

if valid f lag == T rue then

writeState(W Aij , “valid”) // set wallet address to valid.

else

writeState(W Aij , “invalid”) // set wallet address to invalid.

11 Function Voting(msg1 = W Aij , msg2 = BVij , msg3 = ZKPij , Pi signed msg):
12

msg = msg1 || msg2 || msg3
wallet status= readState(W Aij )
Pi pubkey= readState(params struct.Pi public key)
sig f lag = VerifySig(msg,Pi signed msg,Pi pubkey)
zkp f lag = VerifyZKP(BVij , ZKPij )
if (sig f lag and zkp f lag) == T rue and wallet status == “valid” then

writeState(“vote” || W Aij , BVij ) // Latest participant wallet is mapped to her vote. The key in

(key,value) pair is prefixed with ‘vote’ tag to identify valid votes w.r.t wallet addresses.

writeState(W Aij , “voted”) // set W A to voted & prevent voting from that address again.

20 Function Tally(blockheight):
21

total tally = −1
stored blockheight = readState(“blockheightStored”)// blockheightStored is from Algorithm 2: BPO Add.
BH =readState(“blockheader” || blockheight)// blockheight is the argument passed to the function Tally.
V DF (BH), π = readState(“vdf add” || blockheight)// vdfadd is read from Algorithm 1.
BH, T arget = readState(“bpoadd” || blockheight)
trigger f lag=VerifyTrigger(V DF (BH), π, T arget, BH)// Call Algorithm 3.
if (stored blockheight == blockheight) and trigger f lag == True then

total tally =

X·Y
(cid:80)
no=1

return total tally

local tally(boothno)

30 Function Revote(msg = W Aij , Pi signed msg):
31

Pi pubkey= readState(params struct.Pi public key) // get Pi public key
if VerifySig(msg, Pi signed msg, Pi pubkey) = T rue then

writeState(W Aij , “pending”) // set wallet address to pending verification by EA.

// Next, EA makes a call to Func Registration(). Here, EA sets new wallet address of Pi to valid,

if verification passes.

// Further, Pi calls Func Voting() to revote using new wallet address.

We set the difﬁculty for the benign VDF prover (with com-
mercial hardware) to take 100 minutes14 to solve VDF(BH).
Based on Amax limit, we assume Advmin to take at least
10 minutes to solve the VDF. As a result, the adversary is
restricted to a maximum of 1 try (considering 10 minutes an
average Bitcoin block generation time), excluding the Proof-
of-Work required to solve the Bitcoin mining puzzle.

However, since a Bitcoin block header (that includes
nonce s) is generated on average once every 10 minutes
and the benign VDF prover is occupied for 100 minutes,
the question is — how many VDF provers are required to
prevent the block headers from queuing up, waiting for a
processor to be allocated? We can see in Table 1 that VDF
prover 1 runs a task for time 0-100 minutes, and she picks
up the next task to run for time 100-199 minutes. Similarly,
all other provers pick up the next task after completing the

14We consider Amax = 10, i.e., what is solved by a benign VDF

prover in 10 units of time, which may be solved by Advmin in 1 unit.

present one. Hence, 10 VDF provers are sufﬁcient to prevent
block headers from queuing up at the input of the VDF
because Amax = 10.

On the other hand, a benign VDF prover might, in
theory, reduce Amax of VDF computation by using special-
ized hardware instead of commercial hardware. Still, such
a decision depends on the cost-to-beneﬁt ratio. However,
we emphasize that the VDF can be computed only after
solving the PoW mining puzzle while solving it in itself
is prohibitively expensive. Moreover, the puzzle difﬁculty
increases proportionally to the mining power of the Bit-
coin network. Hence, the serial combination of solving
the Bitcoin mining puzzle followed by the computation
of VDF output improves the aggregate security against
Advmin from choosing a favorable nonce. The estimated
requirement of Amax = 10 might further increase as more
studies to efﬁciently solve VDFs on ASIC are carried out.
However, if the estimated Amax will increase in the future,

VDF
Prover
1
2
3
4
5
6
7
8
9
10

Time (min-
utes)
0-100
10-110
20-120
30-130
40-140
50-150
60-160
70-170
80-180
90-190

VDF
Prover
1
2
3
4
5
6
7
8
9
10

Time (min-
utes)
100-199
110-209
120-219
130-229
140-239
150-249
160-259
170-269
180-279
190-289

Table 1
Scheduling 10 VDF provers without queuing. Note the VDF
computations on a VDF prover machine are not parallelized. It is the
scheduling alone that is in parallel. The start time is based on the job
arrival time at the VDF prover, where it will run for 100 minutes. Once
completed, it is ready to take on the next job. In column 2, the start
times are 10 minutes apart and correspond to the average BTC
interblock (job) arrival time. The largest idle time in column 1 is for VDF
Prover 10 at 90 minutes, waiting for the job to start. Beyond this, all
VDF prover machines are continuously occupied since a new job is
available to start immediately after its current job ends.

our solution can cope with it by employing more VDF
provers. For example, if Amax is increased to 15, we will
require 15 VDF provers instead of 10.

5.2 Privacy Implications of Booth Sharding

In this section, we look at the implications of booth sharding.
Further, we recommend booth sizes to protect participant
votes from being revealed to the EA (in the case when all
participants in a booth voted for the same candidate).

The map between a participant’s wallet and her vote
is broken for all parties (including the network adversary)
except for the EA (see Section 4.6). The EA is aware of
the participants’ current wallet address used for voting at
all times, and hence it has an advantage over other entities
in statistical inference attacks. Even though the privacy
of each vote is achieved by blinding, statistical inference
attacks are possible under some circumstances. In detail, if
all participants in a booth voted for the same candidate, it is
trivial for the EA to determine the participants’ identities.

The aggregator smart contract computes the global tally
as the sum of individual booth contract tallies (see Figure 3).
A common way to eliminate demographic voting bias is to
assign participants to a booth randomly. However, there is
still a small probability that all participants of a few booths
voted for the same candidate (hence revealing their vote
to EA). This event is more signiﬁcant when the winning
probability of one candidate is much higher than the others.
Figure 4 gives the probability that X participants in a booth
voted for the same candidate, depending on the candidate
winning probability.

Figure 4(a) represents a booth with 30 participants and
candidate winning probability, p = 0.9. The probability
that all booth participants voted for the same candidate is
P (30, X = 30, p = 0.9) ∼= 0.0423. Figure 4(b) represents
a booth with 100 participants and candidate winning prob-
ability p = 0.9. The probability that all participants in a
booth voted for the same candidate is P (100, X = 100, p =
0.9) ∼= 0.00003. While the probabilities in the booth with
100 participants are very low, this may not be sufﬁcient.

9

For example, consider an election with 1 million
participants. Let boothsize = 30 and numbooths =
(cid:100)(1000000/30)(cid:101) = 33334. We know P (30, X = 30, p =
0.9) ∼= 0.0423. The number of booths where all participants
likely voted for the same candidate is 0.0423 · 33334 (cid:39) 1410
(in 33334 booths). This may be unacceptably high. The
booth size is increased from 30 to 100 participants. Then,
P (100, X = 100, p = 0.9) ∼= 0.00003. The number of booths
where all participants likely voted for the same candidate is
reduced to 0.00003 · 10000 = 0.3 (in 10000 booths). In this
manner, a suitable booth size may be determined at an ac-
ceptable probability limit. On the other hand, we emphasize
that a very big booth size makes the tally computation more
difﬁcult (especially with the high number of candidates),
and thus it needs to be viewed as a trade-off.

5.3 Randomness of Bitcoin Nonces & AoV Entropy

We decided to utilize a single public source of randomness
instead of a distributed randomness due to the low com-
putation cost and synchronization complexity. Bonneau et
al. [32] showed that if the underlying hash function used to
solve the Bitcoin PoW puzzle is secure, then each block in
the canonical chain has a computational min-entropy of at
least d bits (here d corresponds to the mining difﬁculty).
I.e., d consecutive 0 bits must appear in the hash of the
block header15. Hence, (cid:98) d
2 (cid:99) near-uniform bits can be securely
extracted.

Pierrot and Wesolowski [33] explain the malleability of
Bitcoin’s entropy. However, their games are modeled on
the longest chain rule, while in practice, Bitcoin follows
the strongest chain rule [34] (aggregating PoW of a chain).
Nevertheless, empirical evaluation has shown that Bitcoin
nonces have visible white spaces (non-uniformity) in its
scatter-plot [35]. A possible explanation is that some miners
are presetting some of the bits in the 32-bit nonce ﬁeld and
using the extraN once to solve the PoW puzzle. We use the
entire block header as the initial source of entropy instead
of the 32-bit nonce alone to avoid such biases. To reduce
the probability of an adversarial miner biasing the solution
in their favor, the block header (corresponding to winning
nonce) is passed through a veriﬁable delay function (see
Equation 1). The output of VDF is passed through a secure
hash function (see Equation 4) to consolidate the entropy.

6 DISCUSSION
6.1 Voting in a Referendum

The proposed framework for repetitive voting is also suit-
able for a referendum, where participants may vote on a
proposal. Unlike elections scheduled at regular intervals of
time, a referendum may not be necessarily tabled (i.e., put
up for voting) more than once. Nevertheless, AoV may be
used to make the referendum voting repetitive. Any change
to the outcome of a referendum using the AoV framework
requires a supermajority unless the proposal is re-tabled
through an agreement, in which case normal operations
follow.16 The danger of low participant turnout in-between

15At the time of writing, d ≈ 76.
16Some referendums require only a majority while others need a
supermajority to arrive at a decision. AoV does not change the voting
requirements when it is ﬁrst tabled or re-tabled.

regularly scheduled votings may be mitigated by setting a
minimum threshold on the number of participants (e.g., 70%
of the just concluded elections) to overturn a decision. In the
case of a referendum, a similar minimum threshold based on
previous participant turnouts is recommended. Further, the
proposed framework may also be used as an extra tool to
record changing public opinion.

6.2 Voting Costs on a Public Permissioned Blockchain
& Incentives for the VDF Prover

A permissioned blockchain such as Hyperledger [36] may
be used to decrease the costs of repeated voting. In a
permissioned blockchain, only authorized participants are
allowed to append transactions to the chain. Unlike a pub-
lic blockchain, the only costs involved in a permissioned
blockchain reside in maintaining the blockchain infrastruc-
ture. Here, the transaction fees are much lower in compar-
ison to a public blockchain. Given that all involved parties
are able to verify the correctness of results and execution of
consensus protocol, this may be acceptable in practice. To
put the costs of a permissioned blockchain into perspective,
let us assume that 4 independent candidates are contesting
the election, along with 6 public notaries and 1 EA. Each
one of them may run their permissioned consensus node or
rent it out from a cloud provider for a low fee of ∼20-50
USD/month [37]. The consensus nodes might be e.g., EA,
public notaries, and some of the participants. The EA pro-
vides all consensus nodes an equal stake. Equal distribution
ensures that even if some nodes might censor some voting
transactions, other nodes will add them to the blockchain.
Since the votes are blinded, it is non-trivial for an adver-
sarial miner to determine which vote transactions to censor.
Further, the wallet address of a participant changes for each
epoch she votes in (see Section 4.6).

The VDF provers may be incentivized through a cryp-
tocurrency treasury [38] to supply crypto-coins for their
services (supplying VDF proofs). A fraction of each trans-
action fee on the blockchain may be sent to a treasury smart
contract and claimed by the VDF prover on veriﬁcation of
a valid VDF proof by the validator contract in Figure 3.
This incentive would ensure a consistent supply of the
VDF proofs, which is required to maintain the probability
of entering a new epoch within each of the predeﬁned
intervals.

6.3 Limitations

AoV does not support voting where multiple candidates are
winners17 in a single election. It might also be less suitable
for voting where a winner is found through set reduction18.
AoV is suited for elections with 1-out-of k voting choices,
i.e., plurality voting such as ﬁrst-past-the-post (FPTP) [39].
Also, FPTP is the second most commonly used electoral
system in the world. It covers 59/232 countries in na-
tional legislature voting and 24/232 countries in presidential
elections [40], encompassing billions of voting participants
under this electoral system.

17While AoV does not support multi-candidate winners, its par-
ticipants may vote for a group with multiple candidates. Here, a
participant vote goes to a single group instead of its group members.

18In set reduction, candidates are eliminated based on a tally cut-off

criteria and revote is carried out on the reduced candidate set.

10

6.4 Optimizing Frequency of Supplied Block Headers

In terms of gas consumption, it can be costly to process
every single Bitcoin block header (supplied to the VDF
prover and the validator contract by the BPO). We suggest
optimizing this by choosing a coarser time granularity of
the block header supply, independent of the Bitcoin block
interval (e.g., every x-th block).

We modify the example from Section 4.4.1 by consid-
ering the processing of every 100th Bitcoin block header.
T otalT ime = 4 years = 525600 · 4 minutes and the to-
tal number of intervals f t = 8. Then, IntervalT ime =
(525600 · 4)/(8 · 1000) = 262.8. On average, the oracle will
send 262.8 block headers (BH values) to the validator con-
tract within 182.5 days instead of the 26280 block headers
required in the original example. In this case, we only need
1 VDF prover instead of 10, and it provides similar security
guarantees as before.

7 RELATED WORK
7.1 Blockchain E-Voting

A number of practical Blockchain voting service providers
have sprung up in recent years, such as, Agora [41], Follow
My Vote [42], Voatz secure and convenient voting anywhere,
and Polys secure online voting system, to name a few. They
target student organizations, various local, state, and federal
authorities involved in collective decision making, and work
on a variety of devices such as tablets, mobile phones and
laptops. Voting is also a standard feature in blockchain
governance, regularly used by Decentralized Autonomous
Organizations (DAOs) [43].

7.2 Peak End Effects

In political science, the consequences of peak-end effects on
voting have been extensively reviewed. We summarize the
results of such studies in the following.

Healy and Lenz [10] studied the bias in voter response
to the election-year economy. It showed respondents put a
75% weight on the election-year economy and 25% weight
on the year before, whereas the ﬁrst 2 years of the 4 years
considered were insigniﬁcant. They show that when the re-
spondents were presented with easy-to-follow information
on economic growth for all 4 years — the bias signiﬁcantly
decreased. Their work concludes by proposing a ﬁx that
enables voters with easily available overall data growth.
Wlezien [11] showed that voters weighed their decision not
only on the election-year economic indicators but also on
the pre-election year. The author attaches equal importance
to the pre-election year in inﬂuencing voter decisions. Dash
and Ferris [9] found the impacts of income growth during an
election year as more signiﬁcant in deciding the incumbents’
re-election chances.

Kern and Amri [15] demonstrated that both private and
government credit easing was common during an election
year to court votes and stimulate credit growth. Li et al. [12]
showed the existence of a pattern to political investment
cycles – signiﬁcantly more spending occurred during the
election year. Olejnik [13] conducted a study on Polish
local government investment expenditure during an elec-
tion year, indicating a signiﬁcant increase in highly visible

11

(a) Booth size X=30 participants, candidate winning p = 0.9

(b) Booth size X=100 participants, candidate winning p = 0.9

Figure 4. Binomial probability distribution function of X booth participants voting for their favorite candidate whose winning probability is p.

areas such as public infrastructure, tourism, and culture.
Guinjoan and Rodon [14] observed a similar pattern of
increased spending in highly visible areas such as local
festivities during the election year. Voters without expert
knowledge in evaluating the investments may base their
vote on the visibility of the actions taken. Wenzelburger et
al. [16] presented empirical evidence on how governments
strategically plan welfare reforms to expand their beneﬁts
as election approaches. Galiani et al. [17] indicated the peak-
end pattern of the experiment on cash transfer in exchange
for using school and health services by poor households
in Honduras. The study showed the increased incumbent
party vote share in the elections – indicating sensitivity to
recent economic activity.

Aguiar-Conraria et al. [44] examine the role of govern-
ment transparency, i.e., the disclosure of relevant informa-
tion. For the municipalities whose transparency indexes
were high, voters rewarded policies that brought long-
term beneﬁts. The results of Carlin et al. [45] showed that
restrictions on relevant information distorted the ability of
voters to choose in their best interests. On the other hand,
transparent governance and independent media allowed
voters to hold them accountable.

8 CONCLUSIONS

We reviewed the works in political science that motivated
an engineering solution to the peak-end effect problem in
voting and voter manipulation. We showed that existing
voting systems provide little to no recourse for changing the
elected candidates (for years until the next main election)
– even when they had fallen out of favor with a majority
of voters. Therefore, we proposed an Always-on-Voting
(AoV) framework that allows participants to change their
vote between 2 main elections and thwarts the peak-end
effects. This was achieved by dividing the time between two
main elections into several smaller epochs and tallying the
votes at the end of each epoch. Further, the times of epoch
ends were made unpredictable. The AoV framework uses
various cryptography and information security tools such
as veriﬁable delay functions to thwart a mining adversary
and Bitcoin block headers as the source of randomness. AoV

utilizes a public permissioned blockchain to ensure the secu-
rity properties and save costs. Wallet privacy of participants
was achieved by synchronizing participant wallet addresses
with the EA so that no third-party observer can map any
future participant’s wallet address to the current or previous
one. Finally, we proposed a supermajority requirement to
elicit a change reﬂecting the current election result, which
helps maintain the existing system’s stability.

ACKNOWLEDGMENT
The authors would like to thank Paweł Szałachowski,
Stefanos Leonardos, Daniel Reijsbergen, Mike Rosing and
Balamurali B. T. for their comments on an earlier version
of the paper. Any opinions, ﬁndings and conclusions or
recommendations expressed in this material are those of the
author(s) and do not reﬂect the views of their employer(s).

REFERENCES

[1] C. Blum and C.

I. Zuber, “Liquid democracy: Potentials,
problems, and perspectives,” Journal of Political Philosophy,
vol. 24, no. 2, pp. 162–182, 2016. [Online]. Available: https:
//onlinelibrary.wiley.com/doi/abs/10.1111/jopp.12065

[2] R. Epstein, R. E. Robertson, D. Lazer, and C. Wilson, “Suppressing
the search engine manipulation effect (SEME),” PACMHCI, vol. 1,
no. CSCW, pp. 42:1–42:22, 2017.

J. M ¨oller, S. Kruikemeier, R.

[3] R. S. Goldzweig, I. Kirova, B. Lupion, M. Meyer-Resende, and
S. Morgan, “Social media monitoring during elections: Cases
and best practice to inform electoral observation missions,” in
Democracy Reporting International, R. Taylor, Ed. Open Society
Foundations, 2019.
´O-Fathaigh,
J. Z. Borgesius,
[4] F.
K.
Irion, T. Dobber, B. Bodo, and C. de Vreese, “Online
political microtargeting: Promises and threats for democracy,” in
Proceedings of the 22Nd Annual International Cryptology Conference
on Advances in Cryptology, ser. Utrecht Law Review, 2018, pp.
82–96. [Online]. Available: https://ssrn.com/abstract=3128787
[5] Z. Tufekci, “Engineering the public: Big data, surveillance and
computational politics,” First Monday, vol. 19, no. 7, 2014.
[Online]. Available: https://ﬁrstmonday.org/ojs/index.php/fm/
article/view/4901

[6] D. Kahneman, B. L. Fredrickson, C. A. Schreiber, and D. A.
Redelmeier, “When more pain is preferred to less: Adding a better
end,” Psychological Science, vol. 4, no. 6, pp. 401–405, 1993. [Online].
Available: https://doi.org/10.1111/j.1467-9280.1993.tb00589.x
[7] D. Redelmeier and D. Kahneman, “Patients’ memories of painful
medical treatments: real-time and retrospective evaluations of two
minimally invasive procedures,” Pain, vol. 66, pp. 3–8, 1996.

12

[30] J. Groth, “Efﬁcient maximal privacy in boardroom voting and
anonymous broadcast,” in Financial Cryptography, A. Juels, Ed.
Berlin, Heidelberg: Springer Berlin Heidelberg, 2004, pp. 90–104.

[31] W. Lai and J. Wu, “An efﬁcient and effective decentralized
anonymous voting system,” CoRR, vol. abs/1804.06674, 2018.
[Online]. Available: http://arxiv.org/abs/1804.06674

[32] J. Bonneau, J. Clark, and S. Goldfeder, “On bitcoin as a public
randomness source,” IACR Cryptol. ePrint Arch., vol. 2015, p. 1015,
2015. [Online]. Available: http://eprint.iacr.org/2015/1015
[33] C. Pierrot and B. Wesolowski, “Malleability of the blockchain’s en-
tropy,” Cryptography Commun., vol. 10, no. 1, p. 211–233, Jan. 2018.
[Online]. Available: https://doi.org/10.1007/s12095-017-0264-3

[34] B. Alangot, D. Reijsbergen, S. Venugopalan, and P. Szalachowski,
“Decentralized lightweight detection of eclipse attacks on bitcoin
clients,” in IEEE International Conference on Blockchain, Blockchain
2020, Rhodes, Greece, November 2-6, 2020.
IEEE, 2020, pp. 337–342.
[35] Bitmex Reserach, “The mystery of the bitcoin nonce pattern,”
https://blog.bitmex.com/the-mystery-of-the-bitcoin-nonce-
pattern/, 2019.

[36] Hyperledger, “Hyperledger - opensource blockchain technolo-

gies,” 2020, https://www.hyperledger.org/.

[37] DigitalOcean,

machines,”
droplets/.

2021,

“Droplets: Digital

virtual
https://www.digitalocean.com/products/

scalable

ocean´s

[38] B. Zhang, R. Oliynykov, and H. Balogun, “A treasury system
for cryptocurrencies: Enabling better collaborative intelligence,”
in NDSS 2019, 2019.

[39] G. Harewood, “Electoral reform in canada,” 2002. [Online]. Avail-
able: https://www.securewebexchange.com/metamodequadrant.
com/Electoral Reform.html

[40] IDEA, “International institute for democracy and electoral assis-

tance,” 2021, https://www.idea.int/data-tools/world-view/44.

[41] Agora, “Agora: Bringing voting systems into the digital age,” 2022,

https://www.agora.vote/.

[42] FollowMyVote, “Secure decentralized application development -

follow my vote,” 2022, https://followmyvote.com/.

[43] DASH,

“Dash

docs:

Governance,”

https://docs.dash.org/en/stable/governance/, 2018.

[44] L. Aguiar-Conraria, P. C. Magalh˜aes, and F. J. Veiga, “Trans-
parency, Policy Outcomes, and Incumbent Support,” Kyklos,
vol. 72, no. 3, pp. 357–380, August 2019.

[45] R. E. Carlin, T. Hellwig, G. J. Love, C. Mart´ınez-Gallardo, and
M. M. Singer, “When does the public get it right? the information
environment and the accuracy of economic sentiment,” Compara-
tive Political Studies, vol. 0, no. 0, p. 0010414021989758, 2021.
[46] C. K. Rowley, “The relevance of the median voter theorem,”
Zeitschrift f ¨ur die gesamte Staatswissenschaft / Journal of Institutional
and Theoretical Economics, vol. 140, no. 1, pp. 104–126, 1984.
[Online]. Available: http://www.jstor.org/stable/40750679

[8] Z. Carmon and D. Kahneman, “The experienced utility of queuing:
Experience proﬁles and retrospective evaluations of simulated
queues,” Ph.D. dissertation, 01 1996.

[9] B. B. Dash and J. S. Ferris, “Economic Performance and
Electoral Volatility: Testing the Economic Voting Hypothesis on
Indian States, 1957–2013,” Carleton University, Department of
Economics, Carleton Economic Papers 18-07, Jun. 2018. [Online].
Available: https://ideas.repec.org/p/car/carecp/18-07.html
[10] A. Healy and G. S. Lenz, “Substituting the end for the whole:
Why voters respond primarily to the election-year economy,”
American Journal of Political Science, vol. 58, no. 1, pp. 31–47, 2014.
[Online]. Available: http://www.jstor.org/stable/24363467
[11] C. Wlezien, “The myopic voter? the economy and us presidential
elections,” Electoral Studies, vol. 39, pp. 195–204, 2015. [Online].
Available: https://doi.org/10.1016/j.electstud.2015.03.010

[12] Q. Li, C. Lin, and L. Xu, “Political investment cycles of state-
owned enterprises,” The Review of Financial Studies, vol. 33, no. 7,
pp. 3088–3129, 09 2019.

[13] Łukasz Wiktor Olejnik, “Cycles in a cycle: investment expendi-
tures and their composition during the political budgetary cycle,”
Local Government Studies, vol. 0, no. 0, pp. 1–32, 2021. [Online].
Available: https://doi.org/10.1080/03003930.2020.1851207
[14] M. Guinjoan and T. Rodon, “Let’s party! the impact of local
festivities on the incumbent’s electoral support,” Local Government
Studies, vol. 0, no. 0, pp. 1–23, 2020.
[Online]. Available:
https://doi.org/10.1080/03003930.2020.1771308

[15] A. Kern and P. Amri, “Political credit cycles,” Economics &
Politics, vol. 33, no. 1, pp. 76–108, 2021. [Online]. Available:
https://doi.org/10.1111/ecpo.12158

[16] G. Wenzelburger, C. Jensen, S. Lee, and C. Arndt, “How govern-
ments strategically time welfare state reform legislation: empirical
evidence from ﬁve european countries,” West European Politics,
vol. 43, no. 6, pp. 1285–1314, 2020.

“Voter

response

J. McEwan, P.

[17] S. Galiani, N. Hajj, P.

and
and end
N. Krishnaswamy,
cash
transfer
transfers:
Evidence
Journal: Economic Policy,
experiment,” American Economic
vol. 11, no. 3, pp. 232–60, August 2019. [Online]. Available:
https://www.aeaweb.org/articles?id=10.1257/pol.20170448
[18] S. Venugopalan, I. Homoliak, Z. Li, and P. Szalachowski, “Bbb-
voting: 1-out-of-k blockchain-based boardroom voting,” 2021.

conditional

Ibarrar´an,

to peak

from a

[19] G. Walker, “Bitcoin target,” 2021.

[Online]. Available: https:

//learnmeabitcoin.com/technical/target

[20] D. Boneh, J. Bonneau, B. B ¨unz, and B. Fisch, “Veriﬁable delay
functions,” Cryptology ePrint Archive, Report 2018/601, 2018,
https://eprint.iacr.org/2018/601.

[21] J.

Drake,

“Minimal

vdf

randomness

beacon,”

https://ethresear.ch/t/minimal-vdf-randomness-beacon/3566,
2018.

[22] D. SAMUEL and D. FRANCK, “Cpu-z oc world records. highest
overclocking of all times.” https://valid.x86.fr/records.php, 2020.
[23] K. Curran, “E-voting on the blockchain,” The Journal of the British

Blockchain Association, vol. 1, pp. 1–6, 12 2018.

[24] I. Homoliak, S. Venugopalan, D. Reijsbergen, Q. Hum, R. Schumi,
and P. Szalachowski, “The security reference architecture for
blockchains: Toward a standardized model for studying vulner-
abilities, threats, and defenses,” IEEE Communications Surveys Tu-
torials, vol. 23, no. 1, pp. 341–390, 2021.

[25] H. Herrera and A. Mattozi, “Quorum and turnout in referenda,”
Journal of the European Economic Association, vol. 8, no. 4, pp.
838–871, 2010. [Online]. Available: http://www.jstor.org/stable/
25700906

[26] K. Pietrzak, “Simple veriﬁable delay functions,” in 10th
ITCS
in Theoretical Computer Science Conference,
Innovations
January 10-12, 2019, San Diego, California, USA, ser.
2019,
LIPIcs, A. Blum, Ed., vol. 124.
Schloss Dagstuhl - Leibniz-
Zentrum f ¨ur Informatik, 2019, pp. 60:1–60:15. [Online]. Available:
https://doi.org/10.4230/LIPIcs.ITCS.2019.60

[27] B. Wesolowski, “Efﬁcient veriﬁable delay functions,” J. Cryptol.,
[Online]. Available:

vol. 33, no. 4, pp. 2113–2147, 2020.
https://doi.org/10.1007/s00145-020-09364-x

[28] G. Maxwell,

“Deterministic

wallet

bitcoin

forum,”

https://bitcointalk.org/index.php?topic=19137.msg239768#msg239768,
2019.

[29] BITCOINWIKI,

“Deterministic
https://en.bitcoin.it/wiki/Deterministic wallet, 2019.

wallet

bitcoin

wiki,”

13

Figure 5. Public choices in voting. When candidate c1’s ideal appearing
to the left of V and the candidate c2’s ideal to the right of V are
equidistant from the median voter policy position; Area L = Area R.

Figure 6. Public choices in voting. When the ideal of candidate c1 moves
towards the far left, it is farther away from the median voters’ ideal. Since
voters end up voting for the candidate closer to their ideal point, the
Area R >> Area L., and may result in c1 losing the election.

APPENDIX B
ROLE OF AOV
The role of AoV is to push elected candidates whose ideals
(over time) move away from the voters’ median ideal back
towards equilibrium if they want to remain the winner. This
is achieved by allowing voters to vote repeatedly in be-
tween 2 main elections. A supermajority threshold to change
an elected candidate is provided to ensure stability when
the incumbent candidate pursues major reforms. However,
when radical reforms from the incumbent are backed only
by a minority of the voters, the candidates’ ideal moves far-
ther away from the median. Further, there are costs incurred
to a voter when the candidate’s ideal moves away from her
ideal (see Appendix A for background). When a candidate’s
ideal is far from the median, the costs to a majority of
voters (and hence to society) are high. Using AoV, when
the supermajority winning threshold is met (e.g., 70%) —
it allows the incumbent to be replaced with a new winning
candidate. Further, AoV requires a high participant turnout
(e.g., 70% voters from the concluded main election) for the
votes to be tallied in the interval. In some cases, it might
result in the quorum paradox [25], where participants with
allegiance to a party are asked to abstain from voting, so
the minimum participant threshold is not met. The quorum
paradox is less likely to happen with AoV, especially with
a high winning threshold. For example, in AoV, we set
minimum participants = 70% and winning threshold = 70%.
If 30% of participants (from the eligible population) abstain,
in theory, the other party may get 100% of the votes and win
the election. However, if either more than 30% of the voter
abstain or more than 30% vote a “No”, they are of the same
consequence. It is no longer possible to breach the winning
supermajority threshold.

APPENDIX A
SPATIAL MODEL & MEDIAN VOTERS THEORY

First, we discuss the stakeholders, the model used, and the
equilibrium of the policies w.r.t voters. Further, we see the
effects when candidate policies shift away from the median
voters’ policy. Consider two sets of parties, one the incum-
bent and the opposition. Both incumbent and the opposition
parties may or may not consist of one or more alliance
parties with moderately similar ideologies/goals. Let c1 be
a candidate from the incumbent party and c2 be a candidate
from the opposition (see Figure 5). We use the spatial voting
model, where policy alternatives can be represented in a
geometric space (e.g., a 2-dimensional plane), where voters
have preferences deﬁned over the alternatives. The spatial
i.e., the voters’ most
model assumes single-peakedness,
preferred policy outcome can be represented by a single
point. This is called the ideal point of the voter. It implies
that overall policy preferences can be marked in increasing
order. The frequency of an ideal is the number of voters
who scored the same ideal. The median voter policy position
(point V) is where the median line (vertical line at V) divides
the area under the graph into 2 equal halves (where Area
L = Area R), each with the same number of voters (see
Figure 5). Further, the spatial model is also considered to
be symmetric. I.e., if a voter’s ideal point is in between the
ideal of candidates c1 and c2, that voter has no preference
for one over the other. Since both are equidistant from the
voter ideal (which in the illustration shown in Figure 5 is
also at the median voter’s ideal), half the votes will go to c1
and the other half to c2.

We use the median voters theory [46] as a means to deter-
mine the demand aggregation of voters’ preferences based
on their ideal. According to it, the candidate closest to the
viewpoint of the median voter will win. The median voter
ideal point is also in equilibrium and stable. In Figure 5,
since both c1 and c2 are equidistant from the median, there
is no clear winner. However in Figure 6, candidate c1 has
an ideal to the left of the median. Let T be the ideal point
equidistant from c1 and c2. Then, half the candidates in the
area enclosed between c1 and T will vote for c1, including
everyone with ideals to the left of c1’s ideal. The other half
of voters between T and c2, including everyone to the right
of c2’s ideal — will vote for c2. As a result, c2 will win
the majority of votes. Note the area under the curves in
Figure 5, and Figure 6 may be of any shape and are plotted
to illustrate the spatial model in two dimensions.

Frequency ofideal pointsPublic choicebetween L and RV: Median VotersPolicy PositionArea LArea RVc1c2Frequency ofideal pointsPublic choicebetween L and RV: Median VotersPolicy PositionArea LArea RVc1c2T