Recurring Contingent Service Payment†

Aydin Abadi‡1 Steven J. Murdoch§1 Thomas Zacharias¶2

1 University College London
2 University of Edinburgh

2
2
0
2

l
u
J

0
3

]

R
C
.
s
c
[

1
v
3
8
2
0
0
.
8
0
2
2
:
v
i
X
r
a

Abstract. Fair exchange protocols let two mutually distrustful parties exchange digital data in a
way that neither party can cheat. They have various applications such as the exchange of digital
items, or the exchange of digital coins and digital services between a buyer and seller. At CCS 2017,
two blockchain-based protocols were proposed to support the fair exchange of digital coins and a
certain service; namely, “proofs of retrievability” (PoR). In this work, we identify two notable issues
of these protocols, (1) waste of the seller’s resources, and (2) real-time information leakage. To rectify
these issues, we formally deﬁne and propose a blockchain-based generic construction called “recurring
contingent service payment” (RC-S-P). RC-S-P lets a fair exchange of digital coins and veriﬁable service
occur periodically while ensuring that the buyer cannot waste the seller’s resources, and the parties’
privacy is preserved. It supports arbitrary veriﬁable services, such as PoR, or veriﬁable computation and
imposes low on-chain overheads. Also, we present a concrete eﬃcient instantiation of RC-S-P when the
veriﬁable service is PoR. The instantiation is called “recurring contingent PoR payment” (RC-PoR-P).
We have implemented RC-PoR-P and analysed its cost. When it deals with a 4-GB outsourced ﬁle, a
veriﬁer can check a proof in 90 milliseconds, and a dispute between prover and veriﬁer is resolved in
0.1 milliseconds.

1

Introduction

Fair exchange is an interesting problem in which two mutually distrustful parties want to swap digital items
such that neither party can cheat the other, in the sense that either each party gets the other’s item, or
neither party does. The problem has been drawing considerable attention, as the Internet’s use for conducting
business is rapidly growing. It captures various real-world scenarios; for instance, when two parties want to
exchange digital items or when a seller wants to sell a digital veriﬁable service in exchange for digital coins.
Solutions to the problem are usually certain cryptographic schemes, called fair exchange protocols, and have
been studied for decades. It has been shown that fairness is unachievable without the aid of a trusted third
party [19].

With the advent of decentralised cryptocurrencies and blockchain, it seemed fair exchange protocols can
be designed without having to rely on a single trusted third party, in the sense that the third party’s role
can be turned into a computer program, i.e., smart contract, which is maintained and executed by the
decentralised blockchain. This ultimately results in a stronger security guarantee, as there would be no need
to trust a single entity, anymore. Ever since, various fair exchange protocols that rely on blockchain have been
proposed, see Appendix A for a survey. The two (publicly and privately veriﬁable) schemes of Campanelli et
al. at CCS 2017 [17] stand out from the rest, as they are the only ones designed so far to facilitate the fair
exchange of digital coins and veriﬁable service (VS), on a blockchain.

Nevertheless, as we will show in this work, the schemes in [17] suﬀer from two serious issues: (1) waste
of seller’s resources and (2) real-time information leakage. In these schemes, a cheating buyer can waste
the seller’s resources and in certain cases can even get a free ride from the seller, without having to face
any repercussions of its misbehaviour; moreover, the schemes leak in real-time non-trivial fresh information

† This work is the extension of our previous work in [5] with two important diﬀerences; namely, it oﬀers new (1)

generic deﬁnitions and (2) generic constructions.

‡ aydin.abadi@ucl.ac.uk
§ s.murdoch@ucl.ac.uk
¶ thomas.zacharias@ed.ac.uk

 
 
 
 
 
 
about the seller and buyer to the public, e.g., deposit’s actual amount, proofs’ status, buyer’s ﬁle size, or
even the ﬁle’s location in some situations. The schemes’ ﬂaws leading to these issues are generic. If they are
not dealt with appropriately, then future (blockchain-based) fair exchange protocols would inherit them.

Our Contributions. In this work, we:

1. identify two issues that the protocols of Campanelli et al. [17] suﬀer from; namely, (1) waste of seller’s
resources, and (2) real-time information leakage. We identify two drawbacks in these protocols that led to
Issue 1; namely, (a) incomplete fairness deﬁnition and (b) mismatch of security assumptions/requirements
between primitives. We identify the improper use of public blockchain as the primary factor that led to
Issue 2.

2. deﬁne and propose the ﬁrst generic construction, called “recurring contingent service payment ” (RC-S-P),
that addresses the above issues simultaneously. RC-S-P makes black-box use of any scheme that oﬀers a
veriﬁable service.

3. propose the ﬁrst recurring contingent PoR payment (RC-PoR-P) which is a concrete instantiation of
the RC-S-P scheme. By avoiding generic cryptographic tools with substantial overhead and utilising
symmetric-key primitives and smart contracts, RC-PoR-P achieves eﬃciency while preserving all desired
RC-S-P properties.

4. implement RC-PoR-P and analyse its cost. Our cost analysis illustrates RC-PoR-P is highly eﬃcient.
When it deals with a 4-GB outsourced ﬁle, in each veriﬁcation, a veriﬁer can check a proof in only 90
milliseconds, and a dispute between prover and veriﬁer can be resolved in 0.1 milliseconds. Also, the
contracts’ computation is constant in ﬁle size.

Deﬁning and designing generic RC-S-P is particularly challenging, for three reasons: (i) there exists no
generic deﬁnition for VS schemes in the literature, (ii) most of the application-speciﬁc VS schemes (e.g.,
proofs of retrievability [58], or veriﬁable computation [30], veriﬁable searchable encryption [51]) assume the
client is fully trusted, while in a fair exchange setting either party can be an active adversary, and (iii) the
majority of VS schemes do not (need to) take the privacy of exchanged messages into account, as they are in
the traditional setting where the client and server directly interact with each other, without the involvement
of a public blockchain; hence, their messages’ privacy can be protected from the public by using standard
tools, e.g., secure channels. Our protocols can be used to prevent a variant of “Authorised Push Payment”
(APP) fraud, called Purchase fraud, where the sender of an item may wish to receive a certain amount of
coin without sending the item3.

2 Related Work

In this section, we summarise related work. In Appendix A, we present a detailed survey. Maxwell [47]
proposes a fair exchange scheme, called “zero-knowledge contingent payment” that supports the fair exchange
of digital goods and coins. It is based on Bitcoin’s smart contracts, a hash function, and zero-knowledge (zk)
proofs. After the advancement of the “succinct non-interactive argument of knowledge” (zk-SNARK) [31]
that yields more eﬃcient zk proofs, the scheme was modiﬁed to use zk-SNARKs. Later, Campanelli et al. [17]
identiﬁed an issue in the above scheme. The issue lets a malicious buyer receive the item without paying. To
address it, the authors propose the “zero-knowledge Contingent Service Payments” (zkCSP) scheme that also
supports contingent payment for digital services. It is based on Bitcoin smart contracts, hash functions, and
witness indistinguishable proof of knowledge. To improve eﬃciency, they use zk-SNARKs where the buyer
generates a public parameter, i.e., CRS, and the seller performs minimal checks on the CRS. The authors,
as the zkCSP’s concrete instantiations, propose public and private veriﬁable schemes where the service is
“proofs of retrievability” (PoR) [58]. To date, they are the only ones designed for the fair exchange of digital
coins and a digital service. Shortly, we will explain their shortcomings undetected in the literature.

Fuchsbauer [28] identiﬁes a ﬂaw in the zkCSP and shows that the seller’s minimal check in the zkCSP
does not prevent the buyer from successfully cheating. Later, Nguyen et al. [54] show that by relying on a

3 We refer readers to [4,61] for further discussion about APP fraud.

2

stronger assumption, the zkCSP remains secure. Tramer et al. [60] propose a fair exchange scheme that uses
trusted hardware and Ethereum smart contracts. Dziembowski et al. [26] propose FairSwap, a fair exchange
scheme using the Ethereum smart contracts and the notion of proof of misbehaviour [18]. Later, Eckey
et al. [27] propose OPTISWAP that improves FairSwap’s performance. Similar to FairSwap, OPTISWAP
uses a smart contract and proof of misbehaviour, but it relies on an interactive dispute resolution protocol.
Recently, outsourced fair PoRs letting a client delegate the veriﬁcations to a smart contract were proposed
in [3,25]. The scheme in [3] uses message authentication codes (MACs) and time-lock puzzles. The one in [25]
uses polynomial commitment and involves a high number of exponentiations. As a result, it imposes higher
costs, of proving and verifying, than the former scheme. The schemes in [3,25] rely on a stronger security
assumption (i.e., the client is fully honest) than the rest of the above work.

3 Preliminaries

3.1 Notation

We write x $← X to denote that x is chosen uniformly at random from set X. We write negl(λ) to denote
that a function is negligible in λ, i.e., asymptotically smaller than the inverse of any polynomial. In the

formal deﬁnitions in this paper, we use the notation Pr

, where Exp is an experiment that involves an

adversary A, and Cond is the set of the corresponding winning conditions for A. We summarise our notations
in Table 1. Similar to the optimistic fair cryptographic protocols that aim eﬃciency, e.g., in [9,10,12,23], we
assume the existence of a trusted third party arbiter (e.g., secure hardware) which remains oﬄine most of
the time but can be invoked to resolve any dispute.

Exp
Cond

(cid:20)

(cid:21)

Table 1: Notation Table.

Setting Symbol

Description

Setting

Symbol

c
i
r
e
n
e
G

z
λ
PRF
ζ
P r
Com
Ver
µ
H
MT
sk, pk
PoR
u
u∗
σ
ωσ
e
pp
q, q
ωq
c
π, π
VS
VSID
RCSP
SAP
C
S
Ar
SC

Number of veriﬁcations
Security parameter
Pseudorandom function
PRF’s description
Probability
Commit algorithm in commitment
Verify algorithm in commitment
Negligible function
Hash function
Merkle tree
Secret and public keys
Proof of retrievability
Service input, e.g., ﬁle
Encoded input
Metadata
Proof for metadata’s correctness
e := (σ, ωσ)
Public parameter
Query and query vector
Proof for q’s correctness
c := (q, ωq)
Service proof and proof vector
Veriﬁable service
Veriﬁable service with identiﬁable abort
Recurring contingent service payment
Statement agreement protocol
Client
Server
Arbiter
Smart contract

c
i
r
e
n
e
G

-

P
R
o
P
C
R

-

r
o

P
-
S
-
C
R

F
M
Q
aux
m
||u∗||
δ
j
adr
φ
rqp, rcp
¨xqp, ¨xcp

coin∗

C, coin∗
S
enc
mC, mS
padπ, padq
yC, yS
C, y′
y′
S
cp
Tcp
qp
Tqp
T
gC, gS
pl
o
l
lmax
omax
pS

3

Description
Function run on u∗ by S
Metadata generator function
Query generator function
Auxiliary information
Number of a ﬁle blocks, m = |u∗|
Bit size of u∗
Proof of F ’s evaluation correctness
Veriﬁcation index, 1 ≤ j ≤ z
Address
Number of challenged blocks
Random values
¨xqp := (qp, rqp), ¨xcp := (cp, rcp)
Encoded coins deposited by C and S
Encoding/decoding functions enc := (E, D)
Complaints of C and S
Number of elements used to pad π and q
Number of times C and S misbehave towards each other
Number of times C and S unnecessarily invoke Ar
Coin secret parameters
Coin encoding token
Query/proof secret parameters
Query/proof encoding token
T := (Tcp, Tqp)
Commitments computed by C and S
Public price list: {(o, l), ..., (o′′, l′′)}
Coins S must get for a valid proof, where o ∈ pl
Coins Ar must get for resolving a dispute, where l ∈ pl
Max(l, ..., l′′)
Max(o, ..., o′′)
Total coins S should deposit

3.2 Smart Contract

Cryptocurrencies, such as Bitcoin [53] and Ethereum [63], beyond oﬀering a decentralised currency, support
computations on transactions. In this setting, often a certain computation logic is encoded in a computer
program, called a “smart contract”. To date, Ethereum is the most predominant cryptocurrency framework
that enables users to deﬁne arbitrary smart contracts. In this framework, contract code is stored on the
blockchain and executed by all parties maintaining the cryptocurrency, when the program inputs are pro-
vided by transactions. The program execution’s correctness is guaranteed by the security of the underlying
blockchain components. To prevent a denial of service attack, the framework requires a transaction creator
to pay a fee, called “gas”.

3.3 Building Blocks

We outline the main cryptographic primitives that we utilize in our protocols. For completeness, we provide
a detailed description of the said primitives in Appendix B.

– Pseudorandom Fuction (PRF): we apply a pseudorandom function PRF : {0, 1}ψ × {0, 1}η → {0, 1}ι that
takes as input a random ψ-bit key and η-bit message and outputs a ι-bit pseudorandom value (cf. Appendix
B.1).

– Commitment Scheme: we deploy a binding and hiding commitment scheme that comprises the commit
and open phases. In the commit phase, the sender commits to a message x as Com(x, r) = Comx, that
involves a secret value, r. In the open phase, the sender sends the opening ¨x := (x, r) to the receiver which
veriﬁes its correctness: Ver(Comx, ¨x) ?= 1 and accepts if the output is 1 (cf. Appendix B.2).

– Publicly Veriﬁable Non-interactive Zero-knowledge Proof (NIZK): is a non-interactive proof where a prover
P, given a witness w for some statement x in an NP language L, wants to convince in zero-knowledge a
veriﬁer V of the validity of x ∈ L. A NIZK is publicly veriﬁable when any party can verify the validity of
x ∈ L by obtaining the proof (cf. Appendix B.3).

– Symmetric-key Encryption Scheme: it consists of a key generation algorithm SKE.keyGen, an encryption
algorithm Enc, and a decryption algorithm Dec. We require that the scheme satisﬁes IND-CPA security
(cf. Appendix B.4).

– Digital Signature Scheme: it consists of a key generation algorithm Sig.keyGen, a signing algorithm
Sig.sign, and a veriﬁcation algorithm Sig.ver. We require that the digital signature scheme satisﬁes
EUF-CMA security (cf. Appendix B.5).

– Merkle Tree: A Merkle tree scheme [48,49] is a data structure often used for eﬃciently checking the integrity
of an outsourced ﬁle. The Merkle tree scheme includes three algorithms; namely, MT.genTree, MT.prove
and MT.verify. Brieﬂy, the ﬁrst algorithm constructs a Merkle tree on ﬁle blocks, the second generates a
proof of a block’s (or set of blocks’) membership, and the third veriﬁes the proof (cf. Appendix B.6).

3.4 Proofs of Retrievability (PoR)

A PoR scheme considers the case where an honest client wants to outsource the storage of its ﬁle to a
potentially malicious server, i.e., an active adversary. It is a challenge-response interactive protocol, where
the server proves to the client that its ﬁle is intact and retrievable. Below, we restate PoR’s formal deﬁnition
initially proposed in [39,58]. A PoR scheme comprises of ﬁve algorithms:

• PoR.keyGen(1λ) → k := (sk, pk). A probabilistic algorithm, run by a client, C. It takes as input the

security parameter 1λ. It outputs private-public veriﬁcation key, k := (sk, pk).

• PoR.setup(1λ, u, k) → (u∗, σ, pp). A probabilistic algorithm, run by C. It takes as input 1λ, a ﬁle u, and
key k. It encodes u yielding u∗ and generates metadata, σ. It outputs u∗, σ, and public parameters pp.
• PoR.genQuery(1λ, k, pp) → q. A probabilistic algorithm, run by C. It takes as input 1λ, key k, and public

parameters pp. It outputs a query vector q, possibly picked uniformly at random.

• PoR.prove(u∗, σ, q, pk, pp) → π. It is run by the server, S. It takes as input the encoded ﬁle u∗, metadata

σ, query q, public key pk, and public parameters pp. It outputs a proof, π.

4

• PoR.verify(π, q, k, pp) → d ∈ {0, 1}. It is run by C. It takes as input π, q, k, and pp. It outputs 0 if it

rejects the proof, or 1 if it accepts the proof.

A PoR scheme has two properties: correctness and soundness. Correctness requires that the veriﬁcation
algorithm accepts proofs generated by an honest veriﬁer; formally, PoR requires that for any key k, any
ﬁle u ∈ {0, 1}∗, and any pair (u∗, σ) output by PoR.setup(1λ, u, k), and any query q, the veriﬁer accepts
when it interacts with an honest prover. Soundness requires that if a prover convinces the veriﬁer (with high
probability) then the ﬁle is stored by the prover. This is formalized via the notion of an extractor algorithm,
that is able to extract the ﬁle in interaction with the adversary using a polynomial number of rounds. Before
we deﬁne soundness, we restate the experiment, deﬁned in [58], that takes place between an environment E
and adversary A. In this experiment, A plays the role of a corrupt party and E simulates an honest party’s
role.

1. E executes PoR.keyGen(1λ) algorithm and provides public key, pk, to A.
2. A can pick arbitrary ﬁle u, and uses it to make queries to E who runs PoR.setup(1λ, u, k) → (u∗, σ, pp)
and returns the output to A. Also, upon receiving the output of PoR.setup(1λ, u, k), A can ask E to run
PoR.genQuery(1λ , k, pp) → q and give the output to it. A can locally run PoR.prove(u∗, σ, q, pk, pp) → π
to get its outputs as well.

3. A can request from E the execution of PoR.verify(π, q, k, pp) for any u used to query PoR.setup(·).
Accordingly, E informs A about the veriﬁcation output. The adversary can send to E a polynomial
number of queries. Finally, A outputs metadata σ returned from a setup query and the description of a
prover, ˆA, for any ﬁle it has already chosen above.

It is said that a cheating prover, ˆAǫ, is ǫ-admissible if it convincingly answers ǫ fraction of veriﬁcation
challenges (for a certain ﬁle). Informally, a PoR scheme supports extractability, if there is an extractor
algorithm Ext(k, σ, ˆAǫ), that takes as input the key k, metadata σ, and the description of the machine
implementing the prover’s role ˆAǫ and outputs the ﬁle, u. The extractor has the ability to reset the adversary
to the beginning of the challenge phase and repeat this step polynomially many times for the purpose of
extraction, i.e., the extractor can rewind ˆAǫ.

Deﬁnition 1 (ǫ-soundness). A PoR scheme is ǫ-sound if there exists an extraction algorithm Ext(·) such
PoR and outputs an ǫ-admissible cheating prover ˆAǫ for
that, for every adversary A who plays experiment ExpA
a ﬁle u, the extraction algorithm recovers u from ˆAǫ, given honest party’s private key, public parameters,
metadata and the description of ˆAǫ, except with negl(λ) probability. Formally:

PoR.keyGen(1λ) → k := (sk, pk)
A(1λ, pk) → u
PoR.setup(1λ, u, k) → (u∗, σ, pp)
A(u∗, σ, pp) → state
PoR.genQuery(1λ, k, pp) → q

A(q, state) → π) ⇋ (PoR.verify(π, q, k, pp)

(cid:16)(cid:0)
Ext(k, pp, σ, ˆAǫ) 6= u

(cid:1)(cid:17) → ˆAǫ

Pr













= negl(λ).













In contrast to the PoR deﬁnition in [39,58] where PoR.genQuery(·) is implicit, in the above deﬁnition
we have explicitly deﬁned PoR.genQuery(·), as it plays an important role in this paper. Also, there are PoR
protocols, e.g., in [52], that do not involve PoR.keyGen(·). Instead, a set of public parameters/keys (e.g., ﬁle
size or a root of Merkle tree) are output by PoR.setup(·). To make the PoR deﬁnition generic to capture
both cases, we have explicitly included the public parameters pp in the algorithms’ deﬁnitions too.

4 Previous Work’s Limitations and Our Solution’s Overview

In this section, we ﬁrst elaborate on the limitations of previous work, and then outline how we address
them. We focus only on the zero-knowledge contingent service payment (zkCSP) protocols in [17], as they

5

have been speciﬁcally designed for a fair exchange of veriﬁable services and digital coins, whereas the other
protocols studied in Section 2 were designed for a fair exchange of digital items, e.g., ﬁle and coins. If they
are used for veriﬁable services, then they would suﬀer from the same issues as the ones in [17] do.

4.1 Limitations of zkCSP

We ﬁrst elaborate on the shortcomings of the schemes in [17] and explain the schemes’ ﬂaws that caused
such shortcomings. Then, we outline why trivial solutions would not work.

Issue 1: Waste of Server’s Resources. A malicious client, in each zkCSP scheme, can deviate from
the protocol to beneﬁt itself and waste the servers’ resources (depending on the service type it may include
computation or storage) without having to face any consequence of its misbehaviour. Its misbehaviours
include:

(i) not participating in the payment phase despite it has been using the server’s service, e.g., the server’s

storage in PoR.

(ii) participating in the payment phase but making the server generate invalid service proofs. For instance, in
PoR, at the setup the client may generate ill-formed tags that prevent the honest server from passing the
veriﬁcation. To give a concrete example, in the privately veriﬁable PoR [58], at the setup, the malicious
client instead of honestly generating a tag σi on a ﬁle block mi as σi = ri + α · mi, it generates a tag as:
σ′
i = ri + α · m′
i. In this case, given the ﬁle and its
maliciously generated tag, the server cannot pass the veriﬁcation when block mi is challenged. Hence, it
would not get paid.

i, where ri and α are two random values and mi 6= m′

At ﬁrst glance, it seems the malicious client can only waste the server’s resources without gaining any-
thing. But, as we will show shortly, in the recurring payment (i.e., when the server interacts with a client
multiple times and/or the server interacts with multiple clients) the client can collect convincing background
information about an honest server. This lets the client conclude that it has been served honestly, although
it does not pay the server and does not check the proof. Thus, it can get a free ride from the server.

Sources of Issue 1: Incomplete Fairness Deﬁnition and Mismatch of Security Assumptions between Primitives.
First, we focus on misbehaviour (i). Brieﬂy, the reason this misbehaviour is allowed in the zkCSP scheme is
that the scheme’s fairness deﬁnition is incomplete. Speciﬁcally, the fairness deﬁnition (presented in Section
4.1) in [17] only captures the moment when the client and server want to trade proof of service for coins
(i.e., fair payment phase). Nevertheless, this deﬁnition does not take into account the “resource fairness”,
i.e., the server is paid for the resources it allocated. The server needs to invest resources (in PoR for a long
time) to serve the client before it participates in the fair payment phase. Therefore, in the fair exchange
of services and coins, it would not be fair if the client does not participate in the payment phase. Now we
move on the misbehaviour (ii). The main reason that is allowed is that the zkCSP scheme uses a subprotocol
that oﬀers a weaker security guarantee than required. Speciﬁcally, the zkCSP scheme assumes either party
can be potentially corrupted by an active adversary, but it uses a certain veriﬁable service protocol that
is secure against only a malicious server and assumes the client is fully honest. This mismatch of security
assumption/requirement lets a malicious client misbehave. The incomplete deﬁnition and the lack of rigorous
security proof for the concrete instantiation of the zkCSP scheme also played vital roles in misbehaviour (ii)
remaining undetected.

Issue 2: Real-time Leakage. The zkCSP protocols leak in real-time non-trivial fresh information, about
the server and clients to the public. The leakage includes:

• Deposit amount. The amount of deposit placed in the smart contract, swiftly leaks non-trivial information
about the client to the public. In the case of PoR, an observer learns the approximate size of outsourced
data, service type, or in certain cases even the region of clients’ outsourced data, by comparing the amount

6

of deposit with the service provider’s price list which is usually publicly available, e.g., in [6,24,34]. For
instance, at the time of writing this paper, the “Amazon S3 One Zone - Infrequent Access” monthly
price is $0.0208 per GB if the data is stored in “South America (Sao Paulo)” Interestingly, that region
has a unique price. Hence, if the client deposits about $208 in cryptocurrency in the contract, then the
public knows that the client has outsourced about 10000 GB data, using Amazon S3 One Zone and its
data location is Sao Paulo.

• Proofs’ status. In the traditional setting, the client and server directly interact with each other to verify
and prove the integrity of agreed-upon services. In this case, the veriﬁcation’s result is only apparent to
them. Nevertheless, in the blockchain era, where a blockchain plays a role in the veriﬁcation and payment
phases, e.g., in the zkCSP schemes, it becomes visible in real-time to everyone whether the veriﬁcation
(proof) has been accepted, that reﬂects whether the server has successfully delivered the service. This
issue remains even if the service proofs are not stored in plaintext in the blockchain, as coins transfer itself
reveals the proofs’ status. In certain settings, this leakage might be undesirable and could have immediate
consequences for both the server and (business) clients, e.g., stock value drop [14,36], or opening doors
for attackers to exploit such incidents. As an example, observing the proof’s veriﬁcation outputs (when a
server deals with multiple clients) lets a malicious client construct comprehensive background knowledge
of the server’s current behaviour and status, e.g., the server has been acting honestly. Such auxiliary
information can assist the malicious client to more wisely exploit the above deposit issue. For instance,
when the server always acts honestly towards its clients, the malicious client refuses to send the deposit
and still has high conﬁdence that the server delivered the service. For more discussion on proofs’ status
issue we refer readers to Appendix C.

Source of Issue 2: Improper Use of Public Blockchain. This issue occurred due to the use of a public blockchain
for holding and transferring deposits without using any privacy-preserving mechanism to preserve the con-
ﬁdentiality of the deposits’ amount, in the real-time from the public view.

Strawman Solutions for the Two Issues To address Issue 1, one may adjust each zkCSP protocol such
that it would require the client to deposit coins before the server provides the ZK to it, with the hope that
the client cannot avoid depositing after the server provides ZK proofs. Nevertheless, this would not work, as
the client after accepting the ZK proof, needs to send a conﬁrmation message to the contract. A malicious
client can avoid doing so or make the server compute invalid (PoR) proofs, that ultimately lets the client get
its deposit back. Alternatively, one may let a smart contract perform the veriﬁcation on the client’s behalf,
such that the client deposits its coins in the contract when it starts using the service. Then, the server sends
its proof to the contract which performs the veriﬁcation and pays the server if the proof is accepted. Even
though this approach would solve (only) Issue 1, it imposes a high cost and defeats the purpose of zkCSP
design. Because the contract has to always be involved to run the veriﬁcation algorithm that has to be a
publicly veriﬁable one, which often imposes high costs. To address Issue 2, one may use privacy-preserving
cryptocurrency frameworks, e.g., Zerocash [15] or Hawk [43]. Although such frameworks partially solve this
problem (i.e., they can hide deposit amount but not proofs’ status), they impose additional high cost to their
users, as each transaction involves a generic proofs system that are computationally expensive. Also, one
might want to let the server pick a fresh address for each veriﬁer/veriﬁcation to preserve its pseudonymity
with the hope that an observer cannot link clients to a server (so Issues 1 and 2 can be addressed). However,
for this to work, we have to assume that multiple service providers use the same protocol on the blockchain
and all of them are pseudonymous. This is a strong assumption and may not be always feasible.

4.2 Overview of Our Solution

Addressing Issue 1 . To prevent a malicious client from wasting server’s resources, we use a combination of the
following techniques. First, we upgrade a veriﬁable service scheme to a “veriﬁable service with identiﬁable
abort” (VSID). This guarantees that not only the service takes into consideration that the client can be

7

malicious too, but also the public or an arbiter can identify the misbehaving party and resolve any potential
disputes between the two. Second, we require a client to deposit its coins to the contract right before it starts
using the service (e.g., in the case of PoR before it uploaded its data to the server) and it is forced to provide
correct inputs via NIZK; otherwise, its deposit is sent to the server. Third, we require parties to post (some
of) their messages to the contract, to avoid any potential repudiation issue. Forth, we allow the party which
resolves disputes to get paid by a corrupt party. Now we explain how the solution works. The client before
using the service, deposits a ﬁxed amount of coins in a smart contract, where the deposit amount covers the
service payment: o coins, and dispute resolutions’ cost: l coins. Also, the server deposits l coins. Then, the
client and server engage in the VSID protocol such that (the encryption of) messages exchanged between
the parties are put in the contract. The parties perform the veriﬁcations locally, oﬀ-chain. In the case where
a party detects misbehavior, it has a chance to raise a dispute that invokes the arbiter which checks the
party’s claim, oﬀ-chain. The arbiter sends the output of the veriﬁcation to the contract. If the party’s claim
is valid, then it can withdraw its coins and the arbiter is paid by the misbehaving party, i.e., l coins from the
misbehaving party’s deposit are transferred to the arbiter. If the party’s claim is invalid, then that party has
to pay the arbiter and the other party can withdraw its deposit. In the case where both the client and server
behave honestly, then the arbiter is never invoked; in this case, the server (after a ﬁxed time) gets its deposit
back and is paid for the service, while the client gets l coins back. Later, we will show in a certain case, i.e.,
PoR, the arbiter’s role can be eﬃciently played by a smart contract, so its involvement is not needed in that
case. Speciﬁcally, In a concrete instantiation of the generic solution in which the VS is PoR, we will use a
Merkle tree and proof of misbehaviour letting us avoid using NIZK and reduce arbiter-side computation.

Addressing Issue 2 . To prevent real-time information leakage, we use the following ideas in our protocols.
First, we let the client and server take control of the time of the information release. This enables them
to keep the information conﬁdential from the public within an agreed-upon period, and release it when it
becomes stale and loses its sensitivity.4 In particular, the client and server agree on the period in which
the information should remain hidden, “private time bubble”. During this period, all messages sent to the
contract are encrypted and the parties do not raise any dispute. They raise disputes only after the private
time bubble ends (or bubble bursts). Nevertheless, the client/server can still ﬁnd out whether a proof is
valid as soon as it is provided by its counter-party, because it can locally verify the proof. Note, due to the
above solutions to Issue 1, a malicious client that has seen all stale information on the blockchain, cannot
waste the server’s resources. Second, to further hide the amount of deposit, we let each party mask its coins,
by increasing the actual coins amount to the maximum amount of coins in the server’s price list. So, the
masked coins hide the actual coins amount from the public. However, this raises another challenge: how can
the mutually untrustful parties claim back their masking coins (i.e., the diﬀerence between the maximum and
actual coins amount) after the bubble bursts, while hiding the actual coins amount from the public in the
private time bubble? One may want to explicitly state in the contract the amount of masking coins, but
this would not suﬃce, as it would reveal the masking coins’ amount to the public at the beginning of the
protocol. Our third idea, which addresses this challenge, is to let the client and server, at the beginning of
the protocol, agree on a private statement specifying the deposit details, e.g., parties’ actual coins amount
for the service, dispute resolution, or masking. Later, when they want to claim their coins, they also provide
the statement to the contract which checks the statement validity and if it is accepted, it distributes coins
according to the statement (and the contract status). We will show how they can eﬃciently agree on such
a statement, by using a statement agreement protocol (SAP). In Section 7.3, we also show how they can
promise their locked share of coins to a third party.

Our generic framework that oﬀers the above features is called “recurring contingent service payment”

(RC-S-P).

4

The concept of delayed information release has already been used by researchers, e.g., in smart metering in [37], and in the real
world through the declassiﬁcation approach taken by most democratic countries which declassify sensitive information after the
information loses its sensitivity.

8

5 Veriﬁable Service (VS) Deﬁnition

At a high level, a veriﬁable service scheme is a two-party protocol in which a client chooses a function, F ,
and provides (an encoding of) F , its input u, and a query q to a server. The server is expected to evaluate
F on u and q (and some public parameters) and respond with the output. Then, the client veriﬁes that the
output is indeed the output of the function computed on the provided input. In veriﬁable services, either the
computation (on the input) or both the computation and storage of the input are delegated to the server. A
veriﬁable service is deﬁned as follows.

Deﬁnition 2 (VS Scheme). A veriﬁable service scheme VS := (VS.keyGen, VS.setup, VS.genQuery, VS.prove,
VS.verify) with function F , metadata generator function M , and query generator function Q consists of
ﬁve algorithms deﬁned as follows.

• VS.keyGen(1λ) → k := (sk, pk). A probabilistic algorithm run by the client. It takes as input the security

parameter 1λ and outputs a secret/public veriﬁcation key pair k. The server is given pk.

• VS.setup(1λ, u, k) → (u∗, σ, pp). It is run by the client. It takes as input the security parameter 1λ, the
service input u, and key pair k. If an encoding is needed, then it encodes u, that results in u∗; otherwise,
u∗ = u. It outputs encoded input u∗, metadata σ = M (u∗, k, pp), and (possibly input dependent) public
parameters pp. Right after that, the server is given u∗, σ, and pp.

• VS.genQuery(1λ, aux, k, pp) → q. A probabilistic algorithm run by the client. It takes as input the security
parameter 1λ, auxiliary information aux, the key pair k, and public parameters pp. It outputs a query
vector q = Q(aux, k, pp). Depending on service types, q may be empty or contain only random strings.
The output is given to the server.

• VS.prove(u∗, σ, q, pk, pp) → π. It is run by the server. It takes as input the service encoded input u∗,
metadata σ, queries q, public key pk, and public parameters pp. It outputs a proof, π = [F (u∗, q, pp), δ],
containing the function evaluation for service input u, public parameters pp, and query q, i.e., h =
F (u∗, q, pp), and a proof δ asserting the evaluation is performed correctly, where generating δ may involve
σ. The output is given to the client.

• VS.verify(π, q, k, pp) → d ∈ {0, 1}. It is run by the client. It takes as input the proof π, query vector q,
key k, and public parameters pp. In the case where VS.verify(·) is publicly veriﬁable then k := (⊥, pk),
and when it is privately veriﬁable k := (sk, pk). The algorithm outputs d = 1, if the proof is accepted;
otherwise, it outputs d = 0.

A veriﬁable service scheme has two main properties, correctness and soundness. Correctness requires that
the veriﬁcation algorithm always accepts a proof generated by an honest prover. It is formally stated below.

Deﬁnition 3 (VS Correctness). A veriﬁable service scheme VS with functions F, M, Q is correct for an
auxiliary information aux, if for any service input u it holds that:

VS.keyGen(1λ) → k := (sk, pk)
VS.setup(1λ, u, k) → (u∗, σ, pp)
VS.genQuery(1λ, aux, k, pp) → q
VS.prove(u∗, σ, q, pk, pp) → π
VS.verify(π, q, k, pp) → 1.

Pr 





= 1








Intuitively, a veriﬁable service is sound if a malicious server cannot convince the veriﬁcation algorithm to
accept an incorrect output of F except with negligible probability. Soundness is formally stated as follows.

Deﬁnition 4 (VS Soundness). A veriﬁable service VS with functions F, M, Q is sound for an auxiliary
information aux, if for any probabilistic polynomial time adversary A, it holds that:

9

VS.keyGen(1λ) → k := (sk, pk)
A(1λ, pk, F, M, Q) → u
VS.setup(1λ, u, k) → (u∗, σ, pp)
VS.genQuery(1λ, aux, k, pp) → q
A(q, u∗, σ, pp) → π = [h, δ]
VS.verify(π, q, k, pp) → d
F (u∗, q, pp) 6= h ∧ d = 1












Pr












= negl(λ).

The above generic deﬁnition captures the core requirements of a wide range of veriﬁable services such
as veriﬁable outsourced storage, i.e., Proofs of Retrievability [39,58] or Provable Data Possession [11,59],
veriﬁable computation [30,45], veriﬁable searchable encryption [51,46], and veriﬁable information retrieval
[64,62], to name a few. Other additional security properties (e.g., privacy) mandated by certain services can
be added to the above deﬁnition. Alternatively, the deﬁnition can be upgraded to capture the additional
requirements. The veriﬁable service with identiﬁable abort (VSID) and recurring contingent service payment
(RC-S-P) deﬁnitions presented in this paper are two examples.

Remark 1. It is not hard to see that the original PoR deﬁnition (presented in Section 3.4) is a VS’s special
case. In particular, PoR’s ǫ-soundness captures VS’s soundness; in ǫ-soundness, the extractor algorithm
interacts (many times) with the cheating prover which must not be able to persuade the extractor to accept
an invalid proof with a high probability and should provide accepting proofs for non-negligible ǫ fraction of
veriﬁcation challenges. The former property is exactly what VS soundness states.

6 Veriﬁable Service with Identiﬁable Abort (VSID)

A protocol that realises only VS’s deﬁnition (cf. Appendix 5) would be merely secure against a malicious
server and assumes the client is honest. Although this assumption would suﬃce in certain settings and has
been used before (e.g., in [59,51]), it is rather strong and not suitable in the real world, especially when
there are monetary incentives (e.g., service payment) that encourage a client to misbehave. Therefore, in
the following we enhance the VS notion to allow (a) either party to be malicious and (b) a trusted third
party, arbiter, to identify a corrupt party. We call an upgraded veriﬁable service scheme with these features
veriﬁable service with identiﬁable abort (VSID), inspired by the notion of secure multi-party computation
with identiﬁable abort [38].

6.1 VSID Deﬁnition

This section presents the deﬁnition of a VSID scheme.

Deﬁnition 5 (VSID Scheme). A veriﬁable service with identiﬁable abort VSID := (VSID.keyGen,
VSID.setup, VSID.serve, VSID.genQuery, VSID.checkQuery, VSID.prove, VSID.verify, VSID.identify) with
function F , metadata generator function M , and query generator function Q involves four entities; namely,
client, server, arbiter, and bulletin board. It consists of eight algorithms deﬁned below.

• VSID.keyGen(1λ) → k := (sk, pk). A probabilistic algorithm run by the client C. It takes as input the
security parameter 1λ and outputs a secret/public veriﬁcation key pair k. It sends pk to the bulletin board.
• VSID.setup(1λ, u, k) → (u∗, pp, e). It is run by the client. It takes as input the security parameter 1λ,
the service input u, and the key pair k. If an encoding is needed, then it encodes u, that results u∗;
otherwise, u∗ = u. It outputs u∗, (possibly ﬁle dependent) public parameters pp and e := (σ, wσ), where
σ = M (u∗, k, pp) is metadata and wσ is a proof asserting the metadata is well-structured. It sends the
output (i.e., u∗, pp, e) to the bulletin board.

• VSID.serve(u∗, e, pk, pp) → a ∈ {0, 1}. It is run by the server S. It takes as input the encoded service
input u∗, the pair e := (σ, wσ), public key pk, and public parameters pp. It outputs a = 1, if the proof wσ
is accepted, i.e., if the metadata is well-formed. Otherwise, it outputs a = 0. The output is sent to the
bulletin board.

10

• VSID.genQuery(1λ, aux, k, pp) → c := (q, wq). A probabilistic algorithm run by the client. It takes as
input the security parameter 1λ, auxiliary information aux, the key pair k, and public parameters pp. It
outputs a pair c containing a query vector, q = Q(aux, k, pp), and proofs, wq, proving the queries are
well-structured. Depending on service types, c might be empty or contain only random strings. It sends c
to the bulletin board.

• VSID.checkQuery(c, pk, pp) → b ∈ {0, 1}. It is run by the server. It takes as input a pair c := (q, wq)
including queries and their proofs, as well as public key pk, and public parameters pp. It outputs b = 1
if the proofs wσ are accepted, i.e., the queries are well-structured. Otherwise, it outputs b = 0.

• VSID.prove(u∗, σ, c, pk, pp) → π. It is run by the server. It takes as input the encoded service input
u∗, metadata σ, a pair c := (q, wq), public key pk, and public parameters pp. It outputs a proof,
π = [F (u∗, q, pp), δ)] containing the function evaluation, i.e., h = F (u∗, q, pp), and a proof δ asserting
the evaluation is performed correctly, where computing h may involve pk and computing δ may involve
σ. It sends π to the board.

• VSID.verify(π, q, k, pp) → d ∈ {0, 1}. It is run by the client. It takes as input the proof π, queries q,
key pair k, and public parameters pp. If the proof is accepted, it outputs d = 1; otherwise, it outputs
d = 0.

• VSID.identify(π, c, k, e, u∗, pp) → I ∈ {C, S, ⊥}. It is run by a third party arbiter. It takes as input the
proof π, query pair c := (q, wq), key pair k, metadata pair e := (σ, wσ), u∗, and public parameters pp.
If proof wσ or wq is rejected, then it outputs I = C; otherwise, if proof π is rejected it outputs I = S.
Otherwise, if wσ, wq, and π are accepted, it outputs I = ⊥.

A VSID scheme has four main properties; namely, it is (a) correct, (b) sound, (c) inputs of clients are
well-formed, and (d) a corrupt party can be identiﬁed by an arbiter, i.e., detectable abort. In the following,
we formally deﬁne each of them. Correctness requires that the veriﬁcation algorithm always accepts a proof
generated by an honest prover and both parties are identiﬁed as honest. It is formally stated as follows.

Deﬁnition 6 (VSID Correctness). A veriﬁable service with identiﬁable abort scheme with functions
F, M, Q is correct for an auxiliary information aux, if for any service input u it holds that:

VSID.keyGen(1λ) → k := (sk, pk)
VSID.setup(1λ, u, k) → (u∗, pp, e)
VSID.serve(u∗, e, pk, pp) → a
VSID.genQuery(1λ, aux, k, pp) → c
VSID.checkQuery(c, pk, pp) → b
VSID.prove(u∗, σ, c, pk, pp) → π
VSID.verify(π, q, k, pp) → d
VSID.identify(π, c, k, e, u∗, pp) → I = ⊥ ∧
a = 1 ∧ b = 1 ∧ d = 1

Pr















= 1.















Intuitively, a VSID is sound if a malicious server cannot convince the client to accept an incorrect output

of F except with negligible probability. It is formally stated as follows.

Deﬁnition 7 (VSID Soundness). A VSID with functions F, M, Q is sound for an auxiliary information
aux, if for any probabilistic polynomial time adversary A, it holds that:

VSID.keyGen(1λ) → k := (sk, pk)
A(1λ, pk, F, M, Q) → u
VSID.setup(1λ, u, k) → (u∗, pp, e)
VSID.genQuery(1λ, aux, k, pp) → c := (q, wq)
A(c, e, u∗, pp) → π = [h, δ]
VSID.verify(π, q, k, pp) → d
F (u∗, q, pp) 6= h ∧ d = 1












Pr












= negl(λ).

A VSID has well-formed inputs, if a malicious client cannot persuade a server to serve it on ill-structured

inputs (i.e., to accept incorrect outputs of M or Q). Below, we state the property formally.

11

Deﬁnition 8 (VSID Inputs Well-formedness). A VSID with functions F, M, Q has well-formed inputs
for an auxiliary information aux, if for any probabilistic polynomial time adversary A, it holds that:

A(1λ, F, M, Q) → (cid:16)u∗, k := (sk, pk),
e := (σ, wσ), pp(cid:17)
VSID.serve(u∗, e, pk, pp) → a
A(1λ, aux, k, pp) → c := (q, wq)
VSID.checkQuery(c, pk, pp) → b
(M (u∗, k, pp) 6= σ ∧ a = 1)∨
(Q(aux, k, pp) 6= q ∧ b = 1)













Pr













= negl(λ).

The above property ensures an honest server can detect a malicious client if the client provides ill-
structured inputs. It is further required that a malicious party be identiﬁed by an honest third party, arbiter.
This ensures that in the case of dispute (or false accusation) a malicious party can be pinpointed. A VSID
supports detectable abort if a corrupt party can escape from being identiﬁed, by the arbiter, with only
negligible probability. Formally:

Deﬁnition 9 (VSID Detectable Abort). A VSID with functions F, M, Q supports detectable abort for
an auxiliary information aux, if the following hold:

1. For any PPT adversary A1:



VSID.keyGen(1λ) → k := (sk, pk)
A1(1λ, pk, F, M, Q) → u
VSID.setup(1λ, u, k) → (u∗, pp, e)
VSID.genQuery(1λ, aux, k, pp) → c := (q, wq)
A1(c, e, u∗, pp) → π = [h, δ]
VSID.verify(π, q, k, pp) → d
VSID.identify(π, c, k, e, u∗, pp) → I
d = 0 ∧ I 6= S

Pr











2. For any PPT adversary A2:

= negl(λ).














A2(1λ, F, M, Q) → (cid:16)u∗, k := (sk, pk),
e := (σ, wσ), pp(cid:17)
VSID.serve(u∗, e, pk, pp) → a
A2(aux, k) → c := (q, wq)
VSID.checkQuery(c, pk, pp) → b
VSID.prove(u∗, σ, c, pk, pp) → π
VSID.identify(π, c, k, e, u∗, pp) → I
(a = 0 ∨ b = 0) ∧ I 6= C















Pr















= negl(λ).

Lighter VSID Scheme (VSIDlight) In the VSID deﬁnition, algorithm VSID.identify(·) allows an arbiter
to identify a misbehaving client even in the setup phase. Nevertheless, it is often suﬃcient to let the arbiter
pinpoint a corrupt party after the client and server agree to deal with each other, i.e., after the setup when
the server runs VSID.serve(·) and outputs 1. A VSID protocol that meets the latter (lighter) requirements,
denoted by VSIDlight, would impose lower costs especially when u and elements of e are of large size. Because
the arbiter is not required to identify a misbehaving client in setup; therefore, it does not need to have access
to the entire ﬁle u∗ and metadata e. This means (a) the server or client does not need to send u∗ and e
to the arbiter that leads to lower communication cost, and (b) the arbiter skips checking the correctness
of metadata in VSID.identify(·), which ultimately saves it computation cost too. In VSIDlight, algorithm
VSID.identify(·) needs to take only (π, c, k, e′, pp) as input, where e′ ⊂ e. So, this requires two changes to
the VSID deﬁnition, (a) the arbiter algorithm would be VSID.identify(π, c, k, e′, pp) → I, and (b) in case
2, in Deﬁnition 9 we would have b = 0 ∧ I 6= C, so event a = 0 is excluded. In this paper, any time we refer
to VSIDlight, we assume the above minor adjustments are applied to the VSID deﬁnition.

12

6.2 VSID Protocol

In this section, we present the VSID protocol. We show how it can be built upon a protocol that satisﬁes
the VS deﬁnition. As stated previously, a VS scheme inherently protects an honest client from a malicious
server. Therefore, at a high-level, VSID needs to have two added features; namely, it protects an honest
server from a malicious client and allows an arbiter to detect a corrupt party. VSID can be built upon
VS using the following standard techniques; Brieﬂy, (a) all parties sign their outgoing messages, (b) they
post the signed messages on a bulletin board, and (c) the client, using a publicly veriﬁable NIZK scheme,
proves to the server that its inputs have been correctly constructed. In particular, like VS, the client ﬁrst
generates its secret and public parameters. Then, in the setup, it processes its input, u, to generate encoded
input and metadata using the metadata generation function, M . Also, the client utilizes a publicly veriﬁable
NIZK scheme to prove to the server that the metadata has been constructed correctly. The client posts the
encoded input, metadata and the proofs along with their signatures to a bulletin board. Next, the server
veriﬁes the signatures and proofs. It agrees to serve the client, if they are accepted. Like VS, when the client
wants the server to run function F on its input, it uses function Q to generate a query. However, it uses the
zero-knowledge scheme to prove to the server that the query has been constructed correctly. The client posts
the query, proofs, and their signatures to the board. After that, the server veriﬁes the signatures and proofs.
The server-side proves and client-side veriﬁes algorithms remain unchanged with a diﬀerence that the server
posts its proofs (i.e., the output of the prove algorithm) and their signatures to the board and the client
ﬁrst veriﬁes the signatures before checking the proofs. In the case of any dispute/abort, either party invokes
the arbiter which, given the signed posted messages, checks the signatures and proofs in turn to identify
a corrupt party. Below, we present the VSID protocol in which we assume all parties sign their outgoing
messages and their counter-party ﬁrst veriﬁes the signature on the messages, before they feed them to their
local algorithms.

1. Key Generation. VSID.keyGen(1λ)

(a) Calls VS.keyGen(1λ) to generate a pair of secret and public keys, k : (sk, pk).
(b) Commits to the secret key and appends the commitment: Comsk to pk.
(c) Posts pk to a bulletin board.

2. Client-side Setup. VSID.setup(1λ, u, k)

(a) Calls VS.setup(1λ, u, k) → (σ, u∗), to generate a metadata: σ = M (u∗, k, pp), encoded ﬁle service input

and (input dependent) parameters pp.

(b) Generates non-interactive publicly veriﬁable zero-knowledge proofs asserting σ has been generated
correctly, i.e., σ is the output of M that is evaluated on u∗, pk, sk, and pp without revealing sk. Let
wσ contain the proofs.

(c) Posts e := (σ, wσ), pp, and u∗ to the bulletin board.

3. Server-side Setup. VSID.serve(u∗, e, pk, pp)

Ensures the metadata σ has been constructed correctly, by verifying the proofs in wσ (where σ, wσ ∈ e). If
the proofs are accepted, then it outputs a = 1 and proceeds to the next step; otherwise, it outputs a = 0
and halts.

4. Client-side Query Generation. VSID.genQuery(1λ, aux, k, pp).

(a) Calls VS.genQuery(1λ, aux, k, pp) → q, to generate a query vector, q = Q(aux, k, pp). If aux is a private

input, then it also commits to it, that yields Comaux

(b) Generates non-interactive publicly veriﬁable zero-knowledge proofs proving q has been generated
correctly, i.e., q is the output of Q which is evaluated on aux, pk, sk, and pp without revealing sk (and
aux, if it is a private input). Let wq contain the proofs and aux (or Comaux if aux is a private input).

(c) Posts c : (q, wq) to the board.

5. Server-side Query Veriﬁcation. VSID.checkQuery(c, pk, pp)

Checks if the query: q ∈ c has been constructed correctly by verifying the proofs wq ∈ c. If the check
passes, then it outputs b = 1; otherwise, it outputs b = 0.

6. Server-side Service Proof Generation. VSID.prove(u∗, σ, c, pk, pp) This phase starts only if the query

was accepted, i.e., b = 1 .
(a) Calls VS.prove(u∗, σ, q, pk, pp) → π, to generate π = [F (u∗, q, pp), δ]. Recall that q ∈ c.

13

(b) Posts π to the board.

7. Client-side Proof Veriﬁcation. VSID.verify(π, q, k, pp)

Calls VS.verify(π, q, k, pp) → d, to verify proof π. It accepts the proof if d = 1; otherwise, it rejects it.

8. Arbiter-side Identiﬁcation. VSID.identify(π, c, k, e, u∗, pp)

(a) Calls VSID.serve(u∗, e, pk, pp) → a. If a = 1, then it proceeds to the next step. Otherwise, it outputs

I = C and halts.

(b) Calls VSID.checkQuery(c, pk, pp) → b. If b = 1, then it proceeds to the next step. Otherwise, it outputs

I = C and halts.

(c) If π is privately veriﬁable, then the arbiter ﬁrst checks if sk ∈ k (provided by the client along with
other opening information) matches Comsk ∈ pk. If they do not match, then the arbiter outputs I = C.
Otherwise, it calls VS.verify(π, q, k, pp) → d. If d = 1, then it outputs I = ⊥; otherwise, it outputs
I = S.

Theorem 1. The VSID protocol with functions F, M, Q satisﬁes the correctness, soundness, inputs well-
formedness, and detectable abort properties for auxiliary information aux, (cf. Deﬁnitions 6-9), if the un-
derlying VS protocol with functions F, M, Q is correct and sound for aux and the underlying commitment,
publicly veriﬁable non-interactive zero-knowledge, and signature schemes are correct/complete and secure.

Proof (sketch). Correctness is implied by the correctness/completeness of the underlying primitives. The
soundness of VSID stems from the hiding property of the commitment, zero-knowledge property of the
publicly veriﬁable NIZK proofs, and soundness of the veriﬁable service (VS) schemes. In particular, in VSID,
the veriﬁer (i.e., in this case, the client) makes block-box calls to the algorithms of VS to ensure soundness.
However, the prover (i.e., the server) is given additional messages, i.e., Comsk, Comaux, wσ and wq. The hiding
property of the commitment scheme and zero-knowledge property of the zero-knowledge system ensure,
given the messages, the prover learns nothing about the veriﬁcation key and auxiliary information, except
with negligible probability. Moreover, the soundness of VS scheme ensures a corrupt prover cannot convince
an honest veriﬁer, except with a negligible probability. Inputs well-formedness property boils down to the
security of the commitment and publicly veriﬁable NIZK proofs schemes that are used in steps 1, 2 and 4
in VSID protocol. Speciﬁcally, the binding property of the commitment and the soundness of the publicly
veriﬁable NIZK proofs schemes ensure that a corrupt prover (i.e., in this case the client) cannot convince a
veriﬁer (i.e., the server) to accept metadata proofs, wσ and Comsk ∈ pk, while M (u∗, k, pp) 6= σ or to accept
query proofs, wq and Comaux, while Q(aux, k, pp) 6= q, except with negligible probability.

Moreover, the detectable abort property holds as long as both previous properties (i.e., soundness and
inputs well-formedness) hold, the commitment is secure, the zero-knowledge proofs are publicly veriﬁable
and the signature scheme is secure. The reason is that the algorithm VSID.identify(.), which ensures
detectable abort, is a wrapper function that is invoked by the arbiter, and sequentially makes subroutine calls
to algorithms VSID.serve(.), VSID.checkQuery(.) and VS.verify(.), where the ﬁrst two ensure input well-
formedness, and the last one ensures soundness. Also, due to the security of the commitment (i.e., binding),
the malicious client cannot provide the arbiter with another secret veriﬁcation key than what was initially
committed. Moreover, due to the public veriﬁability of the zero-knowledge proofs, the arbiter can verify all
proofs input to VSID.serve(.) and VSID.checkQuery(.). The signature’s security ensures if a proof is not
signed correctly, then it can also be rejected by the arbiter; on the other hand, if a proof is signed correctly,
then it cannot be repudiated by the signer later on (due to signature’s unforgeability); this guarantees that
✷
the signer is held accountable for a rejected proof it provides.

Remark 2. As we mentioned before, it is often suﬃcient to let the arbiter pinpoint a corrupt party after the
client and server agree to deal with each other. We denoted a VSID protocol that meets the latter (lighter)
requirement, by VSIDlight. This version would impose lower costs, when u and elements of e are of large size.
In VSIDlight protocol, the client and server run phases 1-3 of the VSID protocol as before, with a diﬀerence
that the client does not post e and u∗ to the board; instead, it sends them directly to the server. In VSIDlight
the arbiter algorithm, i.e., VSID.identify(·), needs to take only (π, c, k, e′, pp) as input, where e′ contains
the opening of Comsk if VSID.verify(·) is privately veriﬁable or e′ = ⊥ if it is publicly veriﬁable. In this light
version, the arbiter skips step 8a. Thus, VSIDlight saves (a) communication cost, as u∗ and e are never sent to
the board and arbiter, and (b) computation cost as the arbiter does not need to run VSID.serve(·) anymore.

14

7 Recurring Contingent Service Payment (RC-S-P)

In this section, ﬁrst, we provide a formal deﬁnition of RC-S-P. Then, we present the Statement Agreement
Protocol (SAP) that will be used as a subroutine in the construction of RC-S-P. After that, we present a
generic construction that realises the RC-S-P’s deﬁnition. After that, we prove the construction’s security.

7.1 RC-S-P Deﬁnition

In this section, we introduce a formal deﬁnition of recurring contingent service payment (RC-S-P).

Deﬁnition 10 (RC-S-P Scheme). A recurring contingent service payment scheme RC-S-P involves four
parties; namely, client, server, arbiter, and smart contract (which represents a bulletin board). The scheme
is parameterized by ﬁve functions:

– A function F that will be run on the client’s input by the server as a part of the service it provides.
– A metadata generator function M .
– A pair of encoding/decoding functions (E, D).
– A query generator function Q.

Also, the scheme consists of eight algorithms deﬁned as follows.
RCSP.keyGen(1λ) → k: A probabilistic algorithm run by client C. It takes as input security parameter 1λ. It
outputs k := (k, k′) that contains a secret and public veriﬁcation key pair k := (sk, pk) and a set of secret
and public parameters, k′ := (sk′, pk′). It sends pk and pk′ to the contract.
C): It is run by C. It takes as input 1λ, the service input u,
RCSP.cInit(1λ, u, k, z, pl) → (u∗, e, T, pS, y, coin∗
k := (k, k′), the total number of veriﬁcations z, and price list pl containing pairs of actual coin amount for
each accepting service proof and the amount for covering each potential dispute resolution’s cost. It represents
u as an input of M , let u∗ be this representation. It sets pp as (possibly) input dependent parameters, e.g., ﬁle
size. It computes metadata σ = M (u∗, k, pp) and a proof wσ asserting the metadata is well-structured. It sets
the value of pS to the total coins the server should deposit. It picks a private price pair (o, l) ∈ pl. It sets coin
secret parameters cp that include (o, l) and parameters of pl. It constructs coin encoding token Tcp containing
cp and cp’s witness, gcp. It constructs encoding token Tqp that contains secret parameters qp including pp,
(a representation of σ) and parameters (in sk′) that will be used to encode the service queries/proofs. Tqp
contains qp’s witness, gqp. Given a valid value and its witness, anyone can check if they match. It sets a
vector of parameters y that includes binary vectors [yC, yS, y′
S] each of which is set to 0 and its length
is z. Note y may contain other public parameters, e.g., the contract’s address. It outputs u∗, e := (σ, wσ),
T := (Tcp, Tqp), pS, y, and the encoded coins amount coin∗
C (that contains o and l coins in an encoded form).
C sends u∗, z, e, Tcp \ {gcp}, and Tqp \ {gqp} to the server S and sends gcp, gqp, pS, y, and coin∗
C coins to the
contract.
S, a): It is run by S. It takes as input u∗, metadata-proof pair e :=
RCSP.sInit(u∗, e, pk, z, T, pS, y) → (coin∗
(σ, wσ), pk (read from the contract), z, and T := (Tcp, Tqp), where {gcp, gqp} are read from the smart contract.
It reads pS, and y from the smart contract. It checks the validity of e and T elements. It checks elements
of y and ensures each element of yC, yS, y′
S ∈ y has been set to 0. If all checks pass, then it encodes the
amount of its coins that yields coin∗
S = ⊥ and a = 0. It outputs
coin∗
j : A probabilistic algorithm run by C. It takes as input 1λ, auxiliary in-
RCSP.genQuery(1λ, aux, k, Tqp) → c∗
formation aux, the key pair k, and encoding token Tqp. It computes a pair cj containing a query vector
qj = Q(aux, k, pp), and proof wqj proving the query is well-structured, where pp ∈ Tqp. It outputs the encod-
ing of the pair, c∗
RCSP.prove(u∗, σ, c∗
j , pk, Tqp) → (bj, mS,j, π∗
j , pk, and
Tqp. It checks the validity of decoded query pair cj = D(c∗
j , Tqp). If it is rejected, then it sets bj = 0 and
constructs a complaint mS,j. Otherwise, it sets bj = 1 and mS,j = ⊥. It outputs bj, mS,j, and encoded proof

j ): It is run by S. It takes as input u∗, metadata σ, c∗

j = E(cj, Tqp), and sends the output to the contract.

S, and sets a = 1. Otherwise, it sets coin∗

S and a. The smart contract is given coin∗

S coins and a.

C, y′

C, y′

15

j , c∗

j , k, and Tqp. It checks the decoded proof πj = D(π∗

j , k, Tqp) → (dj, mC,j): A deterministic algorithm run by C. It takes as input π∗

j , query
j , Tqp), if it is rejected, it outputs dj = 0 and

j = E(πj, Tqp), where πj contains hj = F (u∗, qj, pp) and a proof δj asserting the evaluation is performed

π∗
correctly (πj may contain dummy values if bj = 0). The smart contract is given π∗
j .
RCSP.verify(π∗
vector qj ∈ c∗
a complaint mC,j. Else, it outputs dj = 1 and mC,j = ⊥.
RCSP.resolve(mC, mS, z, π∗, c∗, pk, Tqp) → y: It is run by the arbiter R. It takes as input C’s complaints
mC, S’s complaints mS, z, all encoded proofs π∗, all encoded query pairs c∗, pk, and encoding token Tqp.
It veriﬁes the token, decoded queries, and proofs. It reads the binary vectors [yC, yS, y′
S] from the smart
contract. It updates yP by setting an element of it to one, i.e., yP,j = 1, if party P ∈ {C, S} has misbehaved in
the j-th veriﬁcation (i.e., provided invalid query or service proof ). It also updates y′
P (by setting an element
of it to one) if party P has provided a complain that does not allow it to identify a misbehaved party, in the
j-th veriﬁcation, i.e., when the arbiter is unnecessarily invoked.
RCSP.pay(y, Tcp, a, pS, coin∗
run by the smart contract. It takes as input the binary vectors [yC, yS, y′
S] ∈ y that indicate which party
misbehaved, or sent invalid complaint in each veriﬁcation, Tcp := {cp, gcp}, a, the total coins the server
should deposit pS, coin∗
S = pS, then it veriﬁes the validity of Tcp. If Tcp
is rejected, then it aborts. If it is accepted, then it constructs vector coinP, where P ∈ {C, S, R}; It sends
coinP,j ∈ coinP coins to party P for each j-th veriﬁcation. Otherwise (i.e., a = 0 or coin∗
S 6= pS) it sends
coin∗

S) → (coinC, coinS, coinR): It is

S. If a = 1 and coin∗

S coins to C and S respectively.

C, and coin∗

C and coin∗

C, coin∗

C, y′

C, y′

In the above deﬁnition, algorithms RCSP.genQuery, RCSP.prove, RCSP.verify, and RCSP.resolve implic-
S = pS; however, for simplicity we

S, pS) as other inputs and execute only if a = 1 and coin∗

itly take (a, coin∗
avoided explicitly stating it in the deﬁnition.

An RC-S-P scheme must meet correctness and security. Correctness requires that by the end of the
protocol’s execution (that involves honest client and server) the client receives all z valid service proofs while
the server gets paid for the proofs, without the involvement of the arbiter. More speciﬁcally, it requires that
the server accepts an honest client’s encoded data and query while the honest client accepts the server’s
valid service proof (and no one is identiﬁed as misbehaving party). Moreover, the honest client gets back all
its deposited coins minus the service payment, the honest server gets back all its deposited coins plus the
service payment and the arbiter receives nothing. Correctness is formally stated below.

Deﬁnition 11 (Correctness). An RC-S-P scheme with functions F, M, E, D, Q is correct for auxiliary
information aux if for any z polynomial in λ, any price list pl, and any service input u, it holds that the
following probability is equal to 1:


























Pr

where yC, yS, y′

C, y′

S ∈ y.

RCSP.keyGen(1λ) → k
RCSP.cInit(1λ, u, k, z, pl) → (u∗, e, T, pS, y, coin∗
C)
RCSP.sInit(u∗, e, pk, z, T, pS, y) → (coin∗
Forj = 1, . . . , z do :

S , a)

RCSP.genQuery(1λ, aux, k, Tqp) → c∗
RCSP.prove(u∗, σ, c∗
j , c∗
RCSP.verify(π∗

j , pk, Tqp) → (bj, mS,j, π∗
j )
j , k, Tqp) → (dj, mC,j)

j

RCSP.resolve(mC, mS, z, π∗, c∗, pk, Tqp) → y
RCSP.pay(y, Tcp, a, pS, coin∗

C, coin∗

dj = 1) ∧ (yC = yS = y′

S ) → (coinC, coinS, coinR)
C = y′

S = 0) ∧

C − o · z) ∧ (

z

Pj=1

coinS,j = coin∗

S + o · z) ∧

z

z

(a = 1) ∧ (

bj =

Vj=1
coinC,j = coin∗

Vj=1

coinR,j = 0)

z

(

(

Pj=1
z

Pj=1


























An RC-S-P scheme is said to be secure if it satisﬁes three main properties: (a) security against a malicious
server, (b) security against a malicious client, and (c) privacy. In the following, we formally deﬁne each of

16

them. Intuitively, security against a malicious server states that (at the end of the protocol execution) either
(i) for each veriﬁcation the client gets a valid proof and gets back its deposit minus the service payment,
or (ii) the client gets its deposit back (for the j-th veriﬁcation) and the arbiter receives l coins, or (iii) if a
malicious server unnecessarily invokes the arbiter, then it has to pay the arbiter. In particular, for each j-th
veriﬁcation, the security requires that only with a negligible probability the adversary wins, if it provides
either (a) correct evaluation of the function on the service input but it either makes the client withdraw an
incorrect amount of coins (i.e., something other than its deposit minus service payment) or makes the arbiter
withdraw an incorrect amount of coins if it unnecessarily invokes the arbiter, or (b) incorrect evaluation of
the function on the service input, but either persuades the client or the arbiter to accept it or makes them
withdraw an incorrect amount of coins (i.e., coinC,j 6= coin∗
or coinR,j 6= l coins). Below, we formalize this
intuition.

z

C

Deﬁnition 12 (Security Against Malicious Server). An RC-S-P scheme with functions F, M, E, D, Q
is secure against a malicious server for auxiliary information aux, if for any z polynomial in λ, any price list
pl, every j (where 1 ≤ j ≤ z), and any PPT adversary A, it holds that the following probability is negl(λ):

j

j , δ∗
j )
j , k, Tqp) → (dj, mC,j)

j , σ, u∗, a) → (bj, mS,j, h∗
j , c∗

RCSP.keyGen(1λ) → k
A(1λ, pk, F, M, E, D, Q) → u
RCSP.cInit(1λ, u, k, z, pl) → (u∗, e, T, pS, y, coin∗
C)
A(u∗, e, pk, z, T, pS, y) → (coin∗
S , a)
RCSP.genQuery(1λ, aux, k, Tqp) → c∗
A(c∗
RCSP.verify(π∗
RCSP.resolve(mC, mS, z, π∗, c∗, pk, Tqp) → y
RCSP.pay(y, Tcp, a, pS, coin∗
(cid:16)F (u∗, qj, pp) = hj ∧
(coinC,j 6= coin∗
(cid:16)F (u∗, qj, pp) 6= hj ∧
(dj = 1 ∨ yS,j = 0 ∨ coinC,j 6= coin∗

z − o ∨ (coinR,j 6= l ∧ y′

C, coin∗

C

C

S,j = 1))(cid:17) ∨

z

∨ coinR,j 6= l)(cid:17)

S ) → (coinC, coinS, coinR)


























Pr


























j , Tqp), π∗
where qj ∈ D(c∗
yS,j ∈ yS ∈ y, and pp ∈ Tqp.

j = [h∗

j , δ∗

j ], hj = D(h∗

j , Tqp), σ ∈ e, mC,j ∈ mC, mS,j ∈ mS, y′

S,j ∈ y′

S ∈ y,

Informally, security against a malicious client requires that, for each j-th veriﬁcation, a malicious client
with a negligible probability wins if it provides either (a) valid metadata and query but either makes the
server receive an incorrect amount of coins (something other than its deposit plus the service payment), or
makes the arbiter withdraw incorrect amounts of coin if it unnecessarily invokes the arbiter or (b) invalid
metadata or query but convinces the server to accept either of them (i.e., the invalid metadata or query),
or (c) invalid query but persuades the arbiter to accept it, or makes them withdraw an incorrect amount of
coins (i.e., coinS,j 6= coin∗
z + o or coinR,j 6= l coins). Below, we formally state the property. Note that in the
following deﬁnition, an honest server either does not deposit (e.g., when a = 0) or if it deposits (i.e., agrees
to serve) ultimately receives its deposit plus the service payment (with high probability).

S

Deﬁnition 13 (Security Against Malicious Client). An RC-S-P scheme with functions F, M, E, D, Q
is secure against a malicious client for an auxiliary information aux, if for any z polynomial in λ, every j
(where 1 ≤ j ≤ z), and any PPT adversary A, it holds that the following probability is negl(λ):

17

Pr

j

S , a)

j , c∗

C, aux, y, pk)

j , k, Tqp) → (dj, mC,j)

S , a, 1λ, aux, k, Tqp) → c∗

j , pk, Tqp) → (bj, mS,j, π∗
j )

A(1λ, F, M, E, D, Q) → (u∗, z, k, e, T, pl, pS, coin∗
RCSP.sInit(u∗, e, pk, z, T, pS, y) → (coin∗
A(coin∗
RCSP.prove(u∗, σ, c∗
A(π∗
RCSP.resolve(mC, mS, z, π∗, c∗, pk, Tqp) → y
RCSP.pay(y, Tcp, a, pS, coin∗
(cid:16)(M (u∗, k, pp) = σ ∧ Q(aux, k, pp) = qj) ∧
(coinS,j 6= coin∗
(cid:16)M (u∗, k, pp) 6= σ ∧ a = 1(cid:17) ∨ (cid:16)Q(aux, k, pp) 6= qj ∧ (bj = 1 ∨
yC,j = 0 ∨ coinS,j 6= coin∗

z + o ∨ coinR,j 6= l ∧ y′

S ) → (coinC, coinS, coinR)

C,j = 1)(cid:17) ∨

C, coin∗

S

S

z + o ∨ coinR,j 6= l)(cid:17)
C ∈ y, yC,j ∈ yC ∈ y, and pp ∈ Tqp.











































where qj ∈ D(c∗

j , tqp), σ ∈ e, y′

C,j ∈ y′

Informally, RC-S-P is privacy-preserving if it guarantees the privacy of (1) the service input (e.g., out-
sourced ﬁle) and (2) the service proof’s status during the private time bubble. In the following, we formally
deﬁne privacy.

Deﬁnition 14 (Privacy). An RC-S-P scheme with functions F, M, E, D, Q preserves privacy for auxiliary
information aux if for any z polynomial in λ and any price list pl, the following hold:

1. For any PPT adversary A1, it holds that the following probability is no more than 1

2 + negl(λ).

2. For any PPT adversaries A2 and A3, it holds that the following probability is no more than P rmax +

RCSP.keyGen(1λ) → k
A1(1λ, pk, F, M, E, D, Q) → (u0, u1)
β $← {0, 1}
RCSP.cInit(1λ, uβ , k, z, pl) → (u∗
RCSP.sInit(u∗
Forj = 1, . . . , z do :

β , e, pk, z, T, pS, y) → (coin∗

β , e, T, pS, y, coin∗
C)
S , a)

RCSP.genQuery(1λ, aux, k, Tqp) → c∗
j , pk, Tqp) → (bj, mS,j, π∗
β, σ, c∗
RCSP.prove(u∗
j )
j , c∗
RCSP.verify(π∗
j , k, Tqp) → (dj, mC,j)
C, gcp, gqp, π∗, pl, a) → β
S , coin∗

j


















Pr


















where c∗ = [c∗

1, ..., c∗

z] and π∗ = [π∗

A1(c∗, coin∗
1 , ..., π∗

z ].

negl(λ):



RCSP.keyGen(1λ) → k
A2(1λ, pk, F, M, E, D, Q) → u
RCSP.cInit(1λ, u, k, M, z, pl, enc) → (u∗, e, T, pS, y, coin∗
C)
RCSP.sInit(u∗, e, pk, z, T, pS, y) → (coin∗
Forj = 1, . . . , z do :

S , a)

A2(1λ, aux, k, Tqp) → c∗
RCSP.prove(u∗, σ, c∗
j , c∗
RCSP.verify(π∗

j

j , pk, Tqp) → (bj, mS,j, π∗
j )
j , k, Tqp) → (dj, mC,j)

A3(F, M, E, D, Q, c∗, coin∗

S , coin∗

C , gcp, gqp, π∗, pl, a) → (dj, j)















Pr













where P rmax is deﬁned as follows. Let ExpA2
We deﬁne the events Con(1)
Con(2)

1,j : bj = 1. For i ∈ {0, 1} and j ∈ [z], we deﬁne:

0,j : Q(aux, k, pp) 6= qj, Con(2)

priv (1λ) be the above experiment. Let qj ∈ D(c∗
0,j : bj = 0, Con(1)

j , Tqp), pp ∈ Tqp.
1,j : Q(aux, k, pp) = qj, and

Then, we have P rmax := max{P r0,1, P r1,1, ..., P r0,z, P r1,z}.

P ri,j := Pr

ExpA2

priv (1λ)
i,j ∧ Con(2)

Con(1)

.

i,j (cid:21)

(cid:20)

18

In the above deﬁnition, for each j-th veriﬁcation, the adversary A2 produces an invalid query with proba-
bility P r0,j and a valid query with probability P r1,j. It is required that privacy is preserved regardless of the
queries and proofs status, i.e., whether they are valid/invalid, as long as they are correctly encoded and pro-
vided. In the above deﬁnitions, the private time bubble is a time period from the point when RCSP.keyGen(·)
is executed up to the time when RCSP.resolve(·) is run. In other words, the privacy holds up to the point
where RCSP.resolve(.) is run. This is why the latter algorithm is excluded from the experiments in Deﬁnition
14.

Deﬁnition 15 (RC-S-P Security). An RC-S-P with functions F, M, E, D, Q is secure for auxiliary infor-
mation aux, if it satisﬁes security against malicious server, security against malicious client, and preserves
privacy for aux, w.r.t. Deﬁnitions 12, 13 , 14, respectively.

7.2 Statement Agreement Protocol (SAP)

As we stated in Section 4.2, RC-S-P relies on the idea that the server and client can eﬃciently agree on
private statements at the beginning of the protocol. Therefore, in this section, we present a protocol, called
statement agreement protocol (SAP), that satisﬁes the above requirement. Informally, an SAP is secure if it
meets four security properties:

1. Neither party can persuade a third party veriﬁer that it has agreed with its counter-party on an invalid

statement, i.e., a statement that both parties have not agreed on.

2. After they agree on the statement, an honest party can (almost) always prove to the veriﬁer that it has

the agreement.

3. The privacy of the statement should be preserved (from the public) before either of the two parties

attempts to prove the agreement on the statement.

4. After both parties reach an agreement neither can later deny the agreement.

To that end, we use a combination of a smart contract (including digital signatures involved) and a commit-
ment scheme. The idea is as follows. Let x be the statement. The client picks a random value and uses it to
commit to x. It sends the commitment to the contract and the commitment opening (i.e., statement and the
random value) to the server. The server checks if the opening matches the commitment and if so, it commits
to the statement using the same random value and sends its commitment to the contract. Later, for a party
to prove to the contract/veriﬁer that it has agreed on the statement with the other party, it only sends the
opening of the commitment. The contract/veriﬁer checks if the opening matches both commitments and
accepts if it matches. The SAP protocol is provided below. It assumes that each party P ∈ {C, S} already
has a blockchain public address adrP (via creating an account).

1. Initiate. SAP.init(1λ, adrC, adrS, x)
The following steps are taken by C.
(a) Deploys a smart contract, SAP, that states both adrC and adrS. Let adrSAP be the contract’s address.
(b) Picks a random value r, and commits to the statement as Com(x, r) = gC. It sends adrSAP and

¨x := (x, r) to S and sends gC to the contract.

2. Agreement. SAP.agree(x, r, gC, adrC, adrSAP)

The following steps are taken by S.
(a) Checks if gC was sent from adrC, and Ver(gC, ¨x) = 1.
(b) If the checks pass, it sets b = 1, computes Com(x, r) = gS, and sends gS to the contract. Else, it sets

b = 0 and gS = ⊥.

3. Prove. For C (resp. S) to prove that it has an agreement on x with S (resp. C), it sends ¨x := (x, r) to

the contract.

4. Verify. SAP.verify(¨x, gC, gS, adrC, adrS)

The following steps are taken by the contract.
(a) Ensures gC and gS were sent from adrC and adrS.
(b) Ensures Ver(gC, ¨x) = Ver(gS, ¨x) = 1.
(c) Outputs d = 1, if the checks in steps 4a and 4b pass. Otherwise, it outputs d = 0.

In Appendix D, we discuss the SAP’s security and explain why naive solutions are not suitable.

19

7.3 Recurring Contingent Service Payment (RC-S-P) Protocol

In this section, we present the “recurring contingent service payment” (RC-S-P) protocol for a generic
service. It utilises a novel combination of VSIDlight, SAP, the private time bubble notion, and symmetric-key
encryption schemes along with the coin masking and padding techniques. At a high level, the protocol works
as follows. The client and server use SAP to provably agree on two private statements; the ﬁrst statement
includes payment details, while another one speciﬁes a secret key, k, and the pads’ length. They also agree
on public parameters such as (a) the private time bubble’s length, that is the total number of billing cycles,
z, plus a waiting period, J, and (b) a smart contract which speciﬁes z and the total amount of masked
coins each party should deposit. The client deploys the contract. Each party deposits its masked coins in the
contract. If either party does not deposit enough coins on time, later each party has a chance to withdraw
its coins and terminate the contract. To start using/providing the service, they invoke VSIDlight protocol.
In particular, they engage in the VSID.keyGen(·), VSID.setup(·), and VSID.serve(·) algorithms. If the server
decides not to serve, e.g., it detects the client’s misbehaviour, it sends 0 within a ﬁxed time; in this case, the
parties can withdraw their deposit and terminate the contract. Otherwise, the server sends 1 to the contract.
At the end of each billing cycle, the client generates an encrypted query, by calling VSID.genQuery(·)
and encrypting its output using the key, k. It pads the encrypted query and sends the result to the contract.
The encryption and pads ensure nothing about the client’s input (e.g., outsourced ﬁle) is revealed to the
public within the private time bubble. In the same cycle, the server retrieves the query, removes the pads
and decrypts the result. Then, it locally checks its validity, by calling VSID.checkQuery(·). If the query is
rejected, the server locally stores the index of the billing cycle and then generates a dummy proof. Otherwise,
if the server accepts the query, it generates a proof of service by calling VSID.prove(·). In either case, the
server encrypts the proof, pads it and sends the result to the contract. Note that sending (padded encrypted)
dummy proofs ensures that the public, during the private time bubble, does not learn if the client generates
invalid queries. After the server sends the messages to the contract, the client removes the pads, decrypts the
proof and locally veriﬁes it, by calling VSID.verify(·). If the veriﬁcation is passed, then the client knows the
server has delivered the service honestly. But, if the proof is rejected, it waits until the private time bubble
passes and dispute resolution time arrives. During the dispute resolution period, in the case the client or
server rejects any proofs, it invokes the arbiter, refers it to the invalid encrypted proofs in the contract, and
sends to it the decryption key and the pads’ detail. The arbiter checks the validity of the key and pads,
by using SAP. If they are accepted, then the arbiter locally removes the pads from the encrypted proofs,
decrypts the related proofs, and runs VSID.identify(·) to check the validity of the party’s claim. The arbiter
sends to the contract a report of its ﬁndings that includes the total number of times the server and client
provided invalid proofs. In the next phase, to distribute the coins, either client or server sends: (a) “pay”
message, (b) the agreed statement that speciﬁes the payment details, and (c) the statement’s proof to the
contract which veriﬁes the statement and if approved it distributes the coins according to the statement’s
detail, and the arbiter’s report.

Now we outline why RC-S-P addresses the issues, raised in Section 4. In the setup, if the client provides
ill-formed inputs (so later it can accuse the server) then the server can detect and avoid serving it. After
the setup, if the client avoids sending any input, then the server still gets paid for the service it provided.
Also, in the case of a dispute between the parties, their claim is checked, and the corrupt party is identiﬁed.
The corrupt party has to pay the arbiter and if that is the client, then it has to pay the server as well.
These features not only do guarantee the server’s resource is not wasted, but also ensures fairness (i.e., if a
potentially malicious server is paid, then it must have provided the service and if a potentially malicious client
does not pay, then it will learn nothing). Furthermore, as during the private time bubble (a) no plaintext
proof is given to the contract, and (b) no dispute resolution and coin transfer take place on contract, the
public cannot ﬁgure out the outcome of each veriﬁcation. This preserves the server’s privacy. Also, because
the deposited coins are masked and the agreed statement is kept private, nothing about the detail of the
service is leaked to the public before the bubble bursts. This preserves the client’s privacy. Also, as either
party can prove to the contract the validity of the agreed statement, and ask the contract to distribute the
coins, the coins will be not be locked forever.

20

Protocol description The RC-S-P protocol is parameterized by the functions F, M, Q of the underlying
VSID and encoding/decoding functions (E, D) that refer to “encrypt then pad”/“remove pad then decrypt”
procedures, respectively. It is assumed that (a) each party P ∈ {C, S, R} already has a blockchain public
address, adrP , which is known to all parties, (b) it uses that (authorised) address to send transactions to the
smart contract, (c) the contract before recording a transaction, ensures the transaction is originated from
an authorised address, and (d) there is a public price list pl known to everyone. The protocol is presented
below.

1. Key Generation. RCSP.keyGen(1λ)

(a) C runs VSID.keyGen(1λ) → k := (sk, pk).
(b) C picks a random secret key ¯k for a symmetric-key encryption. Also, it sets two parameters: padπ and
padq, where padπ and padq refer to the number of dummy values that will be used to pad encrypted
proofs and encrypted queries respectively5, determined by the security parameter and description of
F . Let sk′ := (padπ, padq, ¯k). The keys’ size is part of the security parameter. Let k = [k, k′], where
k′ := (sk′, pk′) and pk′ := (adrC, adrS).

2. Client-side Initiation. RCSP.cInit(1λ, u, k, z, pl)

(a) Calls VSID.setup(1λ, u, k) → (u∗, pp, e), to encode service input, and generate metadata. It sets

qp = sk′ and appends pp to qp.

(b) Calls SAP.init(1λ, adrC, adrS, qp) → (rqp, gqp, adrSAP1), to initiate an agreement (with S) on qp. Let
Tqp := (¨xqp, gqp) be proof/query encoding token, where ¨xqp := (qp, rqp) is the opening and gqp is the
commitment stored on the contract as a result of running SAP.

(c) Sets coin parameters as follows, o: the amount of coins for each accepting proof, and l: the amount

of coins to cover the cost of each potential dispute resolution, given price list pl.

(d) Sets cp := (o, omax, l, lmax, z), where omax is the maximum amount of coins for an accepting service
proof, lmax is the maximum amount of coins to resolve a potential dispute, and z is the number of
service proofs/veriﬁcations. Then, C calls SAP.init(1λ, adrC, adrS, cp) → (rcp, gcp, adrSAP2 ), to initiate
an agreement (with S) on cp. Let Tcp := (¨xcp, gcp) be coin encoding token, where ¨xcp := (cp, rcp) is
the opening and gcp is the commitment stored on the contract as a result of executing SAP. Let
T := {Tqp, Tcp}.
(e) Set parameters coin∗

C and pS are the total number of
masked coins C and S should deposit respectively. It also designs a smart contract, SC, that explicitly
C, pS, adrSAP1, adrSAP2 , pk, and pk′. It sets a set of time points/windows,
speciﬁes parameters z, coin∗
Time : {T0, ..., T2, G1,1, ..., Gz,2, J, K1, ..., K3, L}, that are explicitly speciﬁed in the contract which will
accept a certain party’s message only in a speciﬁed time point/window. The time allocation will
become clear in the next phases.

C = z · (omax + lmax) and pS = z · lmax, where coin∗

(f) Sets also four counters [yC, y′

C, yS, y′

S] in SC, where their initial value is 0. It signs and deploys SC to

the blockchain. Let adrSC be the address of the deployed SC, and y : [yC, y′

C, yS, y′

S, adrSC].

(g) Deposits coin∗

C coins in the contract. It sends u∗, z, e, ¨xqp, and ¨xcp (along with adrSC) to S. Let T0 be

the time that the above process ﬁnishes.

3. Server-side Initiation. RCSP.sInit(u∗, e, pk, z, T, pS, y)

(a) Checks the parameters in T (e.g., qp and cp) and in SC (e.g., pS, y) and ensures a suﬃcient amount

of coins has been deposited by C.

(b) Calls SAP.agree(qp, rqp, gqp, adrC, adrSAP1 ) → (g′

qp, b1) and SAP.agree(cp, rcp, gcp, adrC, adrSAP2 ) →
cp, b2), to verify the correctness of tokens in T and to agree on the tokens’ parameters, where
qp and gcp = g′
cp.
(c) If any above check is rejected, then it sets a = 0. Otherwise, it calls VSID.serve(u∗, e, pk, pp) → a.

(g′
qp, rqp ∈ ¨xqp, and cp, rcp ∈ ¨xcp. Recall that if both C and S are honest, then gqp = g′

5

The values of padπ and padq is determined as follows, padπ = πmax − πact and padq = qmax − qact, where πmax and πact refer
to the maximum and actual the service’s proof size while qmax and qact refer to the maximum and actual the service’s query size,
respectively.

21

S = pS coins to SC at time T1, where coin∗

(d) Sends a and coin∗
Note that, S and C can withdraw their coins at time T2, if S sends a = 0, fewer coins than pS, or nothing
to the SC. To withdraw, S or C simply sends a “pay” message to RCSP.pay(·) algorithm (only) at time
T2.

S = ⊥ if a = 0

Billing-cycles Onset. C and S engage in the following three phases, i.e., phases 4-6, at the end of
every j-th billing cycle, where 1 ≤ j ≤ z. Each j-th cycle includes two time points, Gj,1 and Gj,2, where
Gj,2 > Gj,1, and G1,1 > T2.

4. Client-side Query Generation. RCSP.genQuery(1λ, aux, k, Tqp)

(a) Calls VSID.genQuery(1λ, aux, k, pp) → cj := (qj, wqj ), to generate a query-proof pair.
(b) Encodes cj, by ﬁrst encrypting it, Enc(¯k, cj) = c′

j, where ¯k ∈ Tqp; and then, padding (each element of)
the result with padq ∈ Tqp random values that are picked uniformly at random from the encryption’s
output range, U . Let c∗

j be the result.

(c) Sends the padded encrypted query-proof pair, c∗

j , to SC at time Gj,1.

5. Server-side Proof Generation. RCSP.prove(u∗, σ, c∗
(a) Constructs an empty vector, mS = ⊥, if j = 1.
(b) Removes the pads from c∗

j , pk, Tqp)

j be the result. Next, it decrypts the result,
j) = cj. Then, it runs VSID.checkQuery(cj, pk, pp) → bj, to check the correctness of the

j , using parameters of Tqp. Let c′

Dec(¯k, c′
queries.

• If S accepts the query, i.e., bj = 1, then calls

VSID.prove(u∗, σ, cj, pk, pp) → πj, to generate the service proof. In this case, S encrypts it,
Enc(¯k, πj) = π′
j. Next, it pads (every element of) the encrypted proof with padπ ∈ Tqp random
values picked uniformly at random from U . Let π∗
j be the result. It sends the padded encrypted
proof to SC at time Gj,2.

• Otherwise (if S rejects the query), it appends j to mS, constructs a dummy proof π′

j, picked
uniformly at random from U , pads the result as above, and sends the padded dummy proof, π∗
j ,
to SC at time Gj,2.

When j = z and mS 6= ⊥, S sets mS := (mS, adrSC).

6. Client-side Proof Veriﬁcation. RCSP.verify(π∗
(a) Constructs an empty vector, mC = ⊥, if j = 1.
(b) Removes the pads from π∗

j , utilising parameters of Tqp. Let π′

j , c∗

j , k, Tqp)

j) = π′′

j and then calls VSID.verify(π′′

proof: Dec(¯k, π′
qj ∈ cj (and cj is the result of removing pads from c∗
j = Enc(¯k, πj), then π′′
π′
j = πj.
• If π′′

j be the result. It decrypts the service
j , qj, k, pp) → dj, to verify the proof, where
j and then decrypting the result). Note that if

j passes the veriﬁcation (i.e., dj = 1), then C concludes that the service for this veriﬁcation

has been delivered successfully.

• Otherwise (when π′′

j is rejected), C appends j to mC.

When j = z and mC 6= ⊥, C sets mC := (mC, adrSC, e′), where e′ contains the opening of Comsk or ⊥, as
stated in Remark 2.

7. Dispute Resolution. RCSP.resolve(mC, mS, z, π∗, c∗, pk, Tqp)

The phase takes place only in case of dispute, e.g., when C and/or S reject any proofs in the previous
phases.
(a) The arbiter sets counters: yC, y′

S, that are initially set to 0, before time K1, where K1 >

C, yS and y′

Gz,2 + J.

(b) C sends mC and ¨xqp to the arbiter at time K1. Or, S sends mS and ¨xqp to the arbiter at time K1.

22

(c) At time K2, the arbiter checks the validity of statement ¨xqp sent by each party P ∈ {C, S}. To do
so, it sends each ¨xqp to SAP contract which returns either 1 or 0. The arbiter constructs an empty
vector, v. If party P’s statement is accepted, then it appends every element of mP to v. It ensures
v contains only distinct elements which are in the range [1, z]. Otherwise (if the party’s statement is
rejected) it discards the party’s request, mP. It proceeds to the next step if v is not empty, otherwise
it halts.

(d) The arbiter for every element i ∈ v:

i. removes the pads from the related encrypted query-proof pair and from encrypted service proof.

ii. decrypts the encrypted query-proof pair and encrypted service proof as follows, Dec(¯k, c′

i) = ci

Let c′

i and π′

i be the result.

and Dec(¯k, π′

i) = π′′
i .

iii. calls VSID.identify(π′′

i , ci, k, e′, pp) → Ii
• if Ii = C, then it increments yC by 1.
• if Ii = S, then it increments yS by 1.
C or y′
• if Ii = ⊥, then it increments y′

S by 1, if i is in the complaint of C or S respectively.

Let K3 be the time that the arbiter ﬁnishes the above checks.

(e) The arbiter at time K3 sends [yC, yS, y′

C, y′

S] to SC that accordingly overwrites the elements it holds

(i.e., elements of y) by the related vectors elements the arbiter sent.

8. Coin Transfer. RCSP.pay(y, Tcp, a, pS, coin∗

C, coin∗
S)

(a) If SC receives “pay” message at time T2, where a = 0 or coins∗

C coins to
C and coin∗
S coins to S. In other words, the parties can withdraw their coins if they do not reach
to an agreement in the end of phase 3, i.e., server-side initiation. Otherwise (i.e., they reach to an
agreement), they take the following steps.

S < pS, then it sends coin∗

(b) Either C or S sends “pay” message and the statement, ¨xcp ∈ Tcp, to SC at time L > K3.
(c) SC checks the validity of the statement by sending ¨xcp to the SAP contract which returns either 1

or 0. SC only proceeds to the next step if the output is 1.

(d) SC distributes the coins to the parties as follows:

• coinC = coin∗
• coinS = coin∗
• coinR = l · (yS + yC + y′

C − o · (z − yS) − l · (yC + y′
S + o · (z − yS) − l · (yS + y′
S + y′

C) coins to the arbiter.

C) coins to C.
S) coins to S.

Discussion on the RC-S-P protocol description We conclude Subsection 7.3 with the following remarks:

• The length of a private time bubble can be agreed between the server and client to be of any size that

suits them and can exceed the point where the z-th veriﬁcations is completed.

• For the sake of simplicity, in the RC-S-P protocol, we let each y ∈ {yC, y′

of a binary vector, y ∈ {yC, y′

C, yS, y′

that the sum of all elements y of equal y, i.e., y =

S} be a counter; instead
S}, deﬁned in the RC-S-P deﬁnition. However, it is not hard to see
yj. The same holds for the amounts of coin each

z

C, yS, y′

party receives, coin ∈ {coinC, coinS, coinR}, in the protocol and the coin vector used in the deﬁnition,
coin ∈ {coinC, coinS, coinR}.

j=1
P

• In the protocol, the pads are added after the actual values are encrypted. This is done to save computation
cost. Otherwise (if the pads are added prior to the encryption), then the pads would have to be encrypted
too, which imposes additional computation cost.

• As stated in Section 7.1, RCSP.genQuery(·), RCSP.prove(·),

RCSP.verify(·) and RCSP.resolve(·) implicitly take a, coin∗
a = 1 and coin∗
keeping track of (y′
accepting proofs in step 7(d)iii, pay for the veriﬁcations it performs.

S, pS as another inputs and execute only if
S = pS. For the sake of simplicity, we avoided explicitly stating it in the protocol. Also,
S) enables the arbiter to make malicious parties, that unnecessarily invoke it for

C, y′

23

• The total coin amounts the client receives is as follows; its initial deposit, i.e., coin∗

C, minus the total
coin amounts that the server should be paid for those veriﬁcations that it has acted honestly towards
the client, i.e., o · (z − yS), minus the total coin amounts the client has to pay to the arbiter when it
misbehaved towards the server and the arbiter, i.e., l ·(yC + y′
C). The total coin amounts the server receives
is as follows. Its initial deposit, i.e., coin∗
S, plus the total coin amounts that it should get paid for those
veriﬁcations that it acted honestly towards the client, i.e., o · (z − yS), minus the total coin amounts it has
to pay to the arbiter when it misbehaved towards the client and the arbiter, i.e., l ·(yS + y′
S). Moreover the
arbiter receives in total l · (yS + yC + y′
C) coins to cover its cost of resolving disputes, i.e., l · (yS + yC),
plus the cost imposed to it when it is unnecessarily invoked, i.e., l · (y′
C). If all parties behave honestly,
then the server receives all its deposit back plus the coin amounts they initially agreed to pay the server
if it delivers accepting proofs for all z cycles, i.e., in total it receives coin∗
S + o · z coins. Also, in this
case an honest client receives all coins minus the coin amounts paid to the server for delivering accepting
proofs for z cycles, i.e., in total it receives coin∗
C − o · z coins. However, the arbiter receives no coins, as
it is never invoked.

S + y′

S + y′

• The VSID scheme does not (need to) preserve the privacy of the proofs. However, in RC-S-P protocol
each proof’s privacy must be preserved, for a certain time; otherwise, the proof itself can leak its status,
e.g., when it can be publicly veriﬁed. This is the reason why in the RC-S-P protocol, encrypted proofs
are sent to the contract. Moreover, for the sake of simplicity, in the above protocol, we assumed that each
arbiter’s invocation has a ﬁxed cost regardless of the number of steps it takes. To deﬁne a ﬁne-grained
costing, one can simply allocate to each step the arbiter takes a certain rate and also separate counter
for the client and server.

• In the case where VSID.verify(·) is privately veriﬁable and the server invokes the arbiter, the client
needs to provide inputs to the arbiter too. Otherwise (when it is publicly veriﬁable and the server invokes
the arbiter), the client’s involvement is not required in the dispute resolution phase. In contrast, if the
client invokes the arbiter, the server’s involvement is not required in that phase, regardless of the type
of veriﬁability VSID.verify(·) supports. Furthermore, with a minor adjustment to the RC-S-P protocol,
we can let the client and server be compensated (by a misbehaving party) for the transaction they send
to the contract. To do so, brieﬂy, we can let the parties, in initiation phases, agree on and include in cp
parameters, l′ and l′′, that cover the client’s and server’s cost of sending a transaction, respectively. The
parameters are encoded the same way as l is encoded. In this setting, in the coin transfer phase, the client
S)−l′·yS+l′′·yC,
and server receive coin∗
coins respectively. The amount of coins the arbiter receives remains unchanged.

C)+l′·yS−l′′·yC and coin∗

S+o·(z−yS)−l·(yS +y′

C−o·(z−yS)−l·(yC +y′

ˆcoinS coins (where

• The server or client, even during the private time bubble, can spend (or more accurately promise to a
third party) the amount of coins kept in the contract and will ultimately be transferred to it. With slight
adjustments to the RC-S-P, they can do so in a privacy-preserving manner. We brieﬂy explain how it
can be done. For the sake of simplicity, we assume the server will receive coinS coins after the bubble
ˆcoinS ≤ coinS) to the third party D within the bubble.
bursts and wants to promise
First, the server proves to D that it will receive coinS coins after the bubble bursts. To do that, it sends
the RC-S-P transcripts (that includes all proofs) to D which can verify the server’s claim, as all proofs
are publicly veriﬁable. Next, if D is convinced, the server and D invoke a new instance of the SAP and
ˆcoinS into the SAP’s private statement. This results in a smart contract, SCSAP3 . Next,
insert the value
if both parties agree on the parameters of SCSAP3, then the server sends the address of SCSAP3 to the
main contract of RC-S-P, i.e., SC. When the bubble bursts, SC transfers the client’s share of coins to the
client as before. But, SC distributes the server’s coins if the server or D sends to it a valid proof for the
above private statement (in addition to the proofs required in the Phase 8 of the original RC-S-P). Upon
receiving that proof, SC invokes SCSAP3 to check the validity of the proof. If the proof is accepted, then
SC sends ˆcoinS to D and coinS − ˆcoinS to the server. It is evident that this approach leaks no information
about the coins amount (including ˆcoinS) during the bubble to the public, due to the security of the SAP.
The above idea can be further extended to support multiple parties. For instance, if the server wants to
promise coinS − ˆcoinS coins to D′ (after its promise to D), it needs to send to D′ all the proofs, including
the one related to the above private statement.

24

• As stated previously, the proofs are sent to the contract to avoid running into the deniability issue, i.e.,
a malicious client wrongly claims the server never sent a proof for a certain veriﬁcation or a malicious
server wrongly claims it sent its proof to the client. However, in the case where the proof size is large and
posting it to the smart contract would impose a high cost, the parties can use the following technique
to directly communicate with each other to send and receive the proof. The server sends a signed proof
directly to the client which needs to send back to the server a signed acknowledgment stating that it
received the proof, within a ﬁxed time period. If the server does not receive a valid acknowledgment on
time, it sends the signed proof to the arbiter. Moreover, if the client does not receive the proof on time,
it needs to let the arbiter know about it. In this case, if the arbiter has already received the proof, it
sends the proof to the client which allows the client to perform the rest of the computation. On the other
hand, if the arbiter does not have the proof, it asks the server to send to it the client’s acknowledgment. If
the server provides a valid acknowledgment, then the arbiter considers the client as a misbehaving party;
otherwise (if the server could not provide the acknowledgment), it considers the server as a misbehaving
one. However, if both the server and client behave honestly in sending and receiving the proof, then they
do not need to invoke the arbiter for this matter and the proof is never stored on the blockchain.

7.4 Security Analysis of RC-S-P Protocol

In this section, we analyse the security of RC-S-P protocol, presented in Section 7.3. First, we present the
protocol’s primary security theorem.

Theorem 2. The RC-S-P protocol with functions F, M, E, D, Q presented in Section 7.3 is secure for aux-
iliary information aux, (cf. Deﬁnition 15), if the underlying VSID protocol with functions F, M, Q satisﬁes
correctness, soundness, inputs well-formedness, and detectable abort for auxj, the SAP is secure, the signature
scheme is secure, and the symmetric-key encryption scheme is IND-CPA secure.

To prove Theorem 2, we show that RC-S-P meets all security properties deﬁned in Section 7.1. We start

by proving that RC-S-P satisﬁes security against a malicious server.

Lemma 1. If the SAP and signature scheme are secure and the VSID protocol satisﬁes correctness, sound-
ness, and detectable abort for auxiliary information aux, then the RC-S-P protocol presented in Section 7.3
is secure against malicious server for aux.(cf. Deﬁnition 12).

Proof. We ﬁrst consider event

(cid:16)

∧

(coinC,j 6=

F (u∗, qj, pp) = hj

coin∗
z
that captures the case where the server provides an accepting service proof but makes an honest client
withdraw an incorrect amount of coins, i.e., coinC,j 6= coin∗
z − o, or it makes the arbiter withdraw an incorrect
amount of coins, i.e., coinR,j 6= l, if it unnecessarily invokes the arbiter. As the service proof is valid, an
honest client accepts it and does not raise any dispute. However, the server would be able to make the client
withdraw incorrect amounts of coins, if it manages to either

− o) ∨ (coinR,j 6= l ∧ y′

S,j = 1)

(cid:17)

(cid:16)

(cid:17)

C

C

1. convince the arbiter that the client has misbehaved, by making the arbiter output yC,j = 1 through the

dispute resolution phase, or

2. submit to the contract, in the coin transfer phase, an accepting statement ¨x′

cp other than what was agreed
cp 6= ¨xcp, so it can change the payments’ parameters (e.g., l or o) or send a

in the initiation phase, i.e., ¨x′
message on the client’s behalf to invoke the arbiter unnecessarily.

Nevertheless, the server cannot falsely accuse the client of misbehaviour. This is because, due to the security
of SAP, it cannot convince the arbiter to accept diﬀerent decryption key or pads other than what was
agreed with the client in the initiation phase. Speciﬁcally, it cannot persuade the arbiter to accept ¨x′
qp, where
¨x′
qp 6= ¨xqp, except with a negligible probability. This ensures that the honest client’s message is accessed by

25

the arbiter with a high probability, as the arbiter can extract the client’s message using valid pad information
and decryption key. On the other hand, if the adversary provides a valid statement, i.e., ¨xqp, then due to the
correctness of VSID, algorithm VSID.identify(·) outputs Ij = ⊥. Therefore, due to the security of SAP and
correctness of VSID, yC and yS are not incremented by 1 in the j-th veriﬁcation, i.e., yC,j = yS,j = 0. Also,
due to the security of SAP, the server cannot change the payment parameters by persuading the contract
to accept any statement ¨x′
cp other than what was agreed initially between the client and server, except
with a negligible probability when it ﬁnds the hash function’s collision (in the SAP scheme). Moreover,
since the proof is valid the client never raises a dispute, also due to the digital signature’s unforgeability,
the server cannot send a message on behalf of the client (to unnecessarily invoke the arbiter), and make
the arbiter output y′
C,j = 1 for the j-th veriﬁcation, except with a negligible probability. So with a high
probability y′
C,j = 0. Recall, in the protocol, the total coins the client should receive after z veriﬁcations is
coin∗
C). Since we focus on the j-th veriﬁcation, the amount of coins that should be
credited to the client for that veriﬁcation is

C − o · (z − yS) − l · (yC + y′

coinC,j =

C

coin∗
z

− o · (1 − yS,j) − l · (yC,j + y′

C,j)

(1)

As shown above yC,j = y′

C,j = yS,j = 0. So, according to Equation 1, the client is credited coin∗

z − o coins
for j-th veriﬁcation, with a high probability. On the other hand, as stated above, if the adversary invokes the
arbiter, the arbiter with a high probability outputs Ij = ⊥ which results in y′
S,j = 1. Recall, in the RC-S-P
protocol, the total coins the arbiter should receive for z veriﬁcations is l · (yS + yC + y′
C), so for the j-th
the credited coins should be:

S + y′

C

coinR,j = l · (yS,j + yC,j + y′

S,j + y′

C,j)

(2)

As already shown, in the case where arbiter is unnecessarily invoked by the server, it holds that y′

S,j = 1;
So, according to Equation 2, l coins is credited to the arbiter for the j-th veriﬁcation. For the server to make
the arbiter withdraw other than that amount (for the j-th veriﬁcation), in the coin transfer phase, it has
to send to the contract an accepting statement ¨x′
cp other than what was agreed in the initiation phase, i.e.,
¨x′
cp 6= ¨xcp, so it can change the payments’ parameters, e.g., l or o. But, as argued above, it cannot succeed
with probability signiﬁcantly greater than negligible. We now move on to the following event

F (u∗, qj, pp) 6= hj

∧

dj = 1 ∨ yS,j = 0 ∨ coinC,j 6=

C

coin∗
z

∨ coinR,j 6= l

(cid:17)

(cid:16)

(cid:17)

(cid:16)

C

z

This event captures the case where the server provides an invalid service proof but either persuades the
client to accept the proof, or persuades the arbiter to accept the proof (e.g., when the client raises a dispute)
or makes the client or arbiter withdraw an incorrect amount of coins, i.e., coinC,j 6= coin∗
or coinR,j 6= l
respectively. Nevertheless, due to the soundness of VSID, the probability that a corrupt server can convince
an honest client to accept invalid proof (i.e., outputs dj = 1) is negligible. So, the client detects it with a high
probability and raises a dispute. On the other hand, the server may try to convince the arbiter, and make
it output yS,j = 0, e.g., by sending a complaint. For yS,j = 0 to happen, the server has to either provide a
diﬀerent accepting statement ¨x′
qp 6= ¨xqp) and passes
the veriﬁcation, which requires ﬁnding the hash function’s collision (in the SAP scheme), and its probability
of success is negligible. Or it makes the arbiter accept an invalid proof, but due to the detectable abort
property of VSID, its probability of success is also negligible. Also, as we discussed above, the probability
that the adversary makes the arbiter to recognise the client as misbehaving, and output yC,j = 1 is negligible
too. Therefore, the arbiter outputs yS,j = 1 and yC,j = 0 with a high probability, in both events when it
is invoked by the client or server. Also, in this case, y′
S,j = 0 as the arbiter has already identiﬁed a
misbehaving party. So, according to Equation 1, the client is credited coin∗
coins for that veriﬁcation, with
a high probability. Moreover, according to Equation 2, the arbiter is credited l coins for that veriﬁcation,
with a high probability. The adversary may try to make them withdraw an incorrect amount of coins, e.g.,
in the case where it does not succeed in convincing the client or arbiter. To this end, in the coin transfer

qp, than what was initially agreed with the client (i.e., ¨x′

C,j = y′

z

C

26

phase, it has to send a diﬀerent accepting statement than what was initially agreed with the client. But, it
would succeed only with a negligible probability, due to the security of SAP.

Lemma 2. If the SAP and signature scheme are secure and the VSID scheme satisﬁes correctness, inputs
well-formedness, and detectable abort for auxiliary information aux, then the RC-S-P protocol presented in
Section 7.3 is secure against malicious client for aux (cf. Deﬁnition 13).

Proof. First, we consider event

M (u∗, k, pp) = σ ∧ Q(aux, k, pp) = qj

∧

(coinS,j 6=

S

coin∗
z

+ o) ∨ (coinR,j 6= l ∧ y′

C,j = 1)

!

(cid:17)

(cid:16)

(cid:17)

(cid:16)

S

This event captures the case where the client provides accepting metadata and query but makes the
server withdraw an incorrect amount of coins, i.e., coinS,j 6= coin∗
z + o, or makes the arbiter withdraw an
incorrect amount of coins, i.e., coinR,j 6= l, if it unnecessarily invokes the arbiter. Since the metadata and
query’s proofs are valid, an honest server accepts them and does not raise any dispute, so we have yC,j = 0.
The client could make the server withdraw incorrect amount of coins, if it manages to either convince the
arbiter, in phase 7, that the server has misbehaved, i.e., makes the arbiter output yS,j = 1, or submit to
the contract an accepting statement ¨x′
cp other than what was agreed at the initiation phase, i.e., ¨xcp, in
phase 8, or send a message on the server’s behalf to invoke the arbiter unnecessarily. However, it cannot
falsely accuse the server of misbehaviour, as, due to the security of SAP, it cannot convince the arbiter
to accept diﬀerent decryption key and pads’ detail, by providing a diﬀerent accepting statement ¨x′
qp (where
¨x′
qp 6= ¨xqp), than what was initially agreed with the server, except with negligible probability. This ensures the
arbiter is given the honest server’s messages, with a high probability. So, with a high probability yS,j = 0.
On the other hand, if the adversary provides a valid statement, i.e., ¨xqp, then due to the correctness of
VSID, algorithm VSID.identify(·) outputs Ij = ⊥. So, due to the security of SAP and correctness of VSID,
we would have yC,j = yS,j = 0 with a high probability. Moreover, due to the security of SAP, the client
cannot convince the contract to accept any statement ¨x′
cp other than what was initially agreed between the
client and server (i.e., ¨x′
S,j = 0 because
an honest server never invokes the arbiter when the client’s messages are well-structured and due to the
signature’s unforgeability, the client cannot send a signed message on the server’s behalf to unnecessarily
invoke the arbiter. According to RC-S-P protocol, the total coins the server should receive after z veriﬁcations
is coin∗
S). Since we focus on the j-th veriﬁcation, the amount of coins that should
be credited to the server for the j-th veriﬁcation is

cp 6= ¨xcp), except with negligible probability. Also, it holds that y′

S + o · (z − yS) − l · (yS + y′

coinS,j =

S

coin∗
z

+ o · (1 − yS,j) − l · (yS,j + y′

S,j)

(3)

S

As shown above, the following holds yS,j = y′

S,j = 0, which means, according to Equation 3, the server
is credited coin∗
z + o coins for the j-th veriﬁcation, with a high probability. Furthermore, if the adversary
invokes the arbiter, the arbiter with a high probability outputs Ij = ⊥ which yields y′
C,j = 1. Also, as stated
above, y′
S,j = 0. Hence, according to Equation 2, the arbiter for the j-th veriﬁcation is credited l coins, if it
is unnecessarily invoked. As previously stated, due to the security of SAP, the client cannot make the arbiter
withdraw incorrect amounts of coin by changing the payment parameters and persuading the contract to
accept any statement ¨x′
cp other than what was agreed initially between the client and server, except with
negligible probability. We now turn our attention to

M (u∗, k, pp) 6= σ ∧ a = 1

that captures the case where the server accepts an ill-formed metadata. However, due to inputs well-
formedness of VSID, the probability that event happens is negligible. So, with a high probability a = 0.
Note, in the case where a = 0, the server does not raise any dispute, instead it avoids serving the client.
Next, we move on to

(cid:16)

(cid:17)

27

 
Q(aux, k, pp) 6= qj

∧

bj = 1 ∨ yC,j = 0 ∨ coinS,j 6=

(cid:16)

(cid:17)

(cid:16)

S

coin∗
z

+ o ∨ coinR,j 6= l

!

(cid:17)

This event considers the case where the client provides an invalid query, but either convinces the server
or arbiter to accept it, or makes the server or arbiter withdraw an incorrect amount of coins, i.e., coinS,j 6=
coin∗
z + o or coinR,j 6= l respectively. Nevertheless, due to inputs well-formedness of VSID, the probability
S
that the server outputs bj = 1 in this case is negligible. When the server rejects the query and raises a
dispute, the client may try to convince the arbiter and make it output yC,j = 0, e.g., by sending a complaint.
However, for the adversary to win, either

1. it has to provide a diﬀerent accepting statement ¨x′

qp, than what was initially agreed with the server (i.e.,
¨x′
qp 6= ¨xqp) and passes the veriﬁcation. Due to the security of SAP, its probability of success is negligible.
Or,

2. it has to make the arbiter accept an invalid query, i.e., makes the arbiter output yC,j = 0. Due to the

detectable abort property of VSID, its probability of success is negligible too.

Therefore, with a high probability, we have yC,j = 1. Also, as discussed above, the client cannot make the
arbiter recognise the honest server as a misbehaving party with a probability signiﬁcantly greater than
negligible. That means with a high probability yS,j = 0. Furthermore, as we already discussed, since the
arbiter has identiﬁed a misbehaving party, the following holds y′
C,j = y′
S,j = 0. Hence, according to Equation
3 the server is credited coin∗
z + o coins for this veriﬁcation. Also, the arbiter is credited l coins, according to
Equation 2. Note that the adversary may still try to make them withdraw an incorrect amount of coins (e.g.,
if the adversary does not succeed in convincing the server or arbiter). To this end, at the coin transfer phase,
it has to send a diﬀerent accepting statement than what was initially agreed with the server. However, due
to the security of SAP, its success probability is negligible.

S

Prior to proving RC-S-P’s privacy, we provide a lemma that will be used in the privacy’s proof. Informally,
the lemma states that encoded coins leaks no information about the actual amount of coins (o, l), agreed
between the client and server.

Lemma 3. Let β $← {0, 1}, price list be {(o0, l0), (o1, l1)}, and encoded coin amounts be coin∗
o1−β) +M ax(lβ, l1−β)) and coin∗
S = z · (M ax(lβ, l1−β)). Then, given the price list, z, coin∗
adversary A cannot tell the value of β with a probability signiﬁcantly greater than 1
is taken over the choice of β and the randomness of A).

C = z · (M ax(oβ,
C, and coin∗
S, an
2 (where the probability

C

C = coin∗

Proof. As it is evident, the list and z contains no information about β. Also, since z is a public value, it holds
that coin′∗
C is a function of maximum
value of (o0, o1), and maximum value of (l0, l1). It is also independent of β. Therefore (given the list, z and
C ) the adversary learns nothing about β, unless it guesses the value, with success probability 1
coin′∗
2 . The
same also holds for coin∗
S.

z = M ax(oβ, o1−β) + M ax(lβ, l1−β). It is not hard to see coin′∗

Lemma 4. If SAP is secure and the symmetric-key encryption scheme is IND-CPA secure, then the RC-S-P
protocol presented in Section 7.3 preserves privacy for auxiliary information aux, (cf. Deﬁnition 14).

Proof. We start with case 1, i.e., the privacy of service input. Due to the privacy property of SAP, that stems
from the hiding property of the commitment scheme, given the commitments gqp and gcp, (that are stored
in the blockchain as a result of running SAP) the adversary learns no information about the committed
values (e.g., o, l, padπ, padq, and ¯k), except with a negligible probability. Also, given price list pl, encoded
coins coin∗
S = z · lmax, the adversary learns nothing about the actual price that
was agreed between the server and client, (o, l), for each veriﬁcation, due to Lemma 3. Next we analyse the
privacy of padded encrypted query vector c∗. For the sake of simplicity, we focus on q∗
j ∈ c∗, that is a
padded encrypted query vector for j-th veriﬁcation. Let qj,0 and qj,1 be query vectors, for j-th veriﬁcation,
related to the service inputs u0 and u1 that are picked by the adversary according to Deﬁnition 14 which

C = z · (omax + lmax) and coin∗

j ∈ c∗

28

 
lets the environment pick β $← {0, 1}. Also, let {qj,0, ..., qj, ¯m} be a list of all queries of diﬀerent sizes. In the
experiment, if qj,β is only encrypted (but not padded), then given the ciphertext, due to semantical security
of the encryption, an adversary cannot tell if the ciphertext corresponds to qj,0 or qj,1 (accordingly to u0 or
u1) with probability signiﬁcantly greater than 1
2 + negl(λ), under the assumption that the size of qj,β is equal
to the size of largest query size 6, i.e., M ax(|qj,0|, ..., |qj, ¯m|) = |qj,β|. The above assumption is relaxed with the
use of a pad; as each encrypted query is padded to the queries’ maximum size, i.e., M ax(|qj,0|, ..., |qj, ¯m|), the
adversary cannot tell with a probability greater than 1
2 + negl(λ) if the padded encrypted proof corresponds
to qj,0 or qj,1, as the padded encrypted query always has the same size and the pad values are picked from
the same range as the encryption’s ciphertext are deﬁned. The same argument holds for w∗
j ∈ c∗. Next
qj
we analyse the privacy of padded encrypted proof vector π∗. The argument is similar to the one presented
above, however, we provide it for the sake of completeness. We focus on an element of the vector, π∗
j ∈ π∗,
that is a padded encrypted proof for j-th veriﬁcation. Let πj,0 and πj,1 be proofs, for j-th veriﬁcation, related
to the service inputs u0 and u1, where the inputs are picked by the adversary, w.r.t. Deﬁnition 14 in which
the environment picks β $← {0, 1}. Let {πj,0, ..., πj, ¯m} be proof list including all proofs of diﬀerent sizes. If
we assume πj,β is only encrypted, then given the ciphertext, due to semantical security of the encryption, an
adversary cannot tell if the ciphertext corresponds to πj,0 or πj,1 (accordingly to u0 or u1) with a probability
signiﬁcantly greater than 1
2 + negl(λ), if M ax(|πj,0|, ..., |πj, ¯m|) = |πj,β|. However, the assumption is relaxed
with the use of a pad. In particular, since each encrypted proof is padded to the proofs’ maximum size, the
adversary cannot tell with a probability greater than 1
2 + negl(λ) if the padded encrypted proof corresponds
to πj,0 or πj,1. Also, since the value of a is independent of u0 or u1, and only depends on whether the metadata
is well-formed, it leaks nothing about the service input uβ, β, the query-proof pair and service proof. Thus
C, gcp, gqp, π∗, pl, and a) the probability that the adversary can tell the value of β is at
(given c∗, coin∗
most 1

S, coin∗

∈ c∗

2 + negl(λ).

Now we move on to case 2, i.e., the privacy of proof’s status. Recall that in the experiment, an invalid
query-proof pair is generated with probability P r0,j and a valid query-proof pair is generated with probability
j ∈ c∗ has a ﬁxed size and contains random elements
P r1,j. As stated above, each encoded query-proof pair c∗
of U , i.e., they are uniformly random elements in the symmetric-key encryption scheme’s output range. Also,
it is assumed that for each j-th veriﬁcation, an encoded query-proof is always provided to the contract.
Therefore, each encoded pair leaks nothing, not even the query’s status to the adversary. So, given only
j (i.e., c∗) it can learn a query-proof’s status with probability at most P r′ + µ(λ), where
a vector of c∗
P r′ := M ax{P r0,1, P r1,1, ..., P r0,z, P r1,z}. On the other hand, for each j-th veriﬁcation, an encoded service
proof π∗
j ∈ π∗ is always provided to the contract, regardless of the query’s status. As stated above, each
π∗
j has a ﬁxed size and contains random element of U too. As we showed above, gcp, gqp, pl, and a leak no
information about the service input, except with a negligible probability, µ(λ). They are also independent
of the query-proof pair and service proof, so they leak no information about the pair and service proof
too. So, given c∗, coin∗
C, gcp, gqp, π∗, pl, and a, an adversary has to learn a proof’s status from the
aforementioned values or by correctly guessing a query’s status. In other words, its probability of learning a
proof’ status is at most P r′ + µ(λ).

S, coin∗

8 Recurring Contingent PoR Payment (RC-PoR-P) Protocol

In this section, we present recurring contingent PoR payment (RC-PoR-P) that is a concrete instantiation
of the RC-S-P, when the veriﬁable service is PoR. Now, instead of the function F , we have FPoR which is
an algorithm that takes as input C’s encoded ﬁle u∗ and C’s query q and outputs a proof asserting the
outsourced data u is retrievable. For instance, if a PoR utilises a Merkle tree, then FPoR is the algorithm
that generates the Merkle tree’s proofs. As a concrete instantiation, RC-PoR-P oﬀers two primary added
features. Speciﬁcally, unlike the generic RC-S-P construction (cf. Appendix 7), it (a) does not use any zk
proofs (even though either C or S can be malicious) which signiﬁcantly improves costs, and (b) has a much
lower arbiter-side computation cost; as we will show later, this also allows for a smart contract to eﬃciently
play the arbiter’s role. Below, we ﬁrst explain how the features are satisﬁed.
6

The assumption that all queries have the same size is subsumed under the above assumption.

29

Avoiding the use of zk proofs. The majority of PoRs assume that only S is potentially malicious while C
is honest. To ensure a ﬁle’s availability, they rely on metadata that is either a set of tags (e.g., MACs or
signatures) or a root of a Merkle tree, built on the ﬁle blocks. In the case where C can also be malicious,
if tags are used then using zk proofs seem an obvious choice, as it allows C to guarantee to S that the
tags have been constructed correctly (similar to the PoR in [8]). But, this imposes signiﬁcant computation
and communication costs. We observed that using a Merkle tree would beneﬁt our protocol from a couple
of perspectives; in short, it removes the need for zk proofs and it supports proof of misbehaviour. Our
ﬁrst observation is that if a Merkle tree is used, then S can eﬃciently check the metadata’s correctness by
reconstructing this tree on the ﬁle blocks, without involving zk proofs.
Low arbiter-side cost. In a Merkle tree-based PoR, in each veriﬁcation, the number of proofs (or paths)
are linear with the number of blocks that are probed, say φ. In this scheme, given the proofs, the veriﬁer
checks all proofs and rejects them if only one of them is invalid. We observed that if this scheme is used in
the RC-PoR-P, then once C ﬁnds an invalid proof, it can send only that single invalid proof as a proof of
misbehaviour to the arbiter.7 This technique signiﬁcantly reduces the arbiter computation cost, i.e., from
φ log2(n) to log2(n), where n is the number of ﬁle blocks.

The RC-PoR-P scheme (cf. Subsection 8.2) deploys the following two building blocks:

1. A PoR scheme, presented in Subsection 8.1, that can be seen as a variant of the standard Merkle tree-
based PoR [35,52,39]. The security of the construction relies on the security of the underlying Merkle tree
and pseudorandom function (cf. Subsection 3.3).

2. A statement agreement protocol (SAP), introduced in Subsection 7.2, that lets S and C eﬃciently agree on
private statements at the beginning of the RC-PoR-P scheme. The SAP is built upon a binding and hiding
commitment scheme, a smart contract, and a secure digital signature scheme used to sign transactions
on the blockchain (cf. Subsections 3.3 and 3.2).

8.1 Modiﬁed Merkle tree-based PoR

In this section, we ﬁrst present a modiﬁed version of the standard Merkle tree-based PoR and then explain
the applied modiﬁcations. At a high level, C encodes its input ﬁle using an error-correcting code, splits the
result into blocks, and builds a Merkle tree on the blocks. Then, it locally stores the tree’s root and sends
the blocks to S which rebuilds the tree. At the veriﬁcation time, C sends a PRF’s key to S which derives a
number of blocks’ indices showing which blocks are probed. S for each probed block generates a proof. It
sends all proofs to C which checks them. If it accepts all proofs, then it concludes that its ﬁle is retrievable.
Otherwise, if it rejects some proofs, it stores only one index of the blocks whose proofs were rejected. Below,
we present the PoR protocol.

1. Client-side Setup. PoR.setup(1λ, u)

(a) C uses an error-correcting code, to encode the input ﬁle, u. Let u′ be the encoded ﬁle. Then, it splits

u′ into m blocks as follows, u∗ = u′

1||1, ..., u′

m||m.

(b) C constructs a Merkle tree on u∗’s blocks, i.e., MT.genTree(u∗). Let σ be the root of the tree, and φ
be the number of blocks that will be probed. It sets public parameters as pp := (σ, φ, m, ζ), where ζ
is a PRF’s description, as deﬁned in Subsection 3.3 . It sends pp and u∗ to S.

2. Client-side Query Generation. PoR.genQuery(1λ, pp)

(a) C picks a key ˆk for PRF.
(b) C sends ˆk to S.

3. Server-side Proof Generation. PoR.prove(u∗, ˆk, pp)

(a) S derives φ pseudorandom indices from ˆk as follows.

∀i, 1 ≤ i ≤ φ : qi =
(b) S generates a proof πq

)]qi ∈q, where i-th element in π corresponds to qi, and the probed block is u∗

+ 1. Note that 1 ≤ qi ≤ m. Let q = [q1, ..., qφ].
= MT.prove(u∗, qi), for each random index qi. Let the ﬁnal result be π = [(u∗
. It sends π to C.

(cid:1)

(cid:0)

q

q

i

PRF(ˆk, i) mod m

,

i

πq

i

i

7 This idea is akin to the proof of misbehaviour proposed in [18].

30

4. Client-side Proof Veriﬁcation. PoR.verify(π, q, pp)

(a) If |π| = |q| = 1, then C sets φ = 1. This step is only for the case where a single proof and query is

provided (e.g., in the proof of misbehaviour).

(b) C checks if S sent all proofs, by parsing each element of π as: parse(u∗

||qi , and checking if
its index qi equals to q’s i-th element. If all checks pass, it takes the next step. Otherwise, it outputs
d = [0, i], where i is the index of π’s element that did not pass the check.

q

q

i

i

) = u′

(c) C checks if every path in π is valid, by calling MT.verify(u∗

, σ). If all checks pass, it outputs
d = [1, ⊥]; otherwise, it outputs d = [0, i], where i refers to the index of the ﬁrst element in π that
does not pass the check.

, πq

q

i

i

The above protocol diﬀers from the standard Merkle tree-based PoR from two perspectives; First, in step
4, C also outputs one of the rejected proofs’ indices. Given that index (and vectors of proofs and challenges),
this will let a third party eﬃciently verify that S did not pass the veriﬁcation. Second, in step 2, instead
of sending φ challenges, we let C send only a key/seed of the PRF to S which can derive a set of challenges
from it, such a technique has been used before, e.g., in [32,20,22]. This will lead to a decrease in the C’s
communication and smart contract’s storage costs.

8.2 Recurring Contingent PoR Payment (RC-PoR-P) Protocol

In this section, we present our RC-PoR-P construction. The RC-PoR-P and the generic RC-S-P design share
some ideas, yet as already mentioned, the two constructions have several diﬀerences. We provide the overview
of the RC-PoR-P scheme and its detailed description below.

In the beginning, C generates a symmetric encryption key ¯k and sets the number of dummy values to
pad encrypted proofs, padπ. In its setup step, C runs PoR.setup(1λ, u) to obtain the encoding u∗ and the
parameters pp := (σ, φ, m, ζ). The query/proof secret parameters qp include (¯k, padπ, pp). C sets the coin
secret parameters cp := (o, omax, l, lmax, z) (cf. Subsection 3.1) that determine coin∗
C and pS, i.e. the total
number of masked coins C and S must deposit. It initiates two SAP sessions for agreements on qp and cp
with S and deploys a smart contract, SC. It completes setup by providing S with u∗, the SAP parameters
(including qp and cp), and the number of veriﬁcations, z, and depositing coin∗
C coins in SC. In server setup, S
checks whether a suﬃcient amount of coins has been deposited by C and runs the agreement step of the two
SAP sessions initiated by C. If agreement is successful and the public parameters (σ, φ, m) verify, it sends
coin∗

S = pS coins to SC.
After their setup is complete, C and S engage in the billing cycles phase for a number of z veriﬁcations
as follows. During the j-th veriﬁcation, C runs PoR.genQuery and sends the output query, ˆkj, encrypted to
SC. In turn, S reads SC and decrypts the encrypted query. If ˆkj is invalid, it creates a complaint mS,j. Else,
it runs PoR.prove to generate a proof πj for ˆkj. Next, it sends πj encrypted and padded to SC. In order to
verify, C removes the pads and decrypts as πj and runs PoR.verify for πj and ˆkj. If πj does not pass the
veriﬁcation, it creates a complaint mC,j.

Dispute resolution takes place when C rejects service proofs or S rejects the queries. The arbiter R receives
the complaint vectors mC and mS from C and S along with each party’s “views” of the two SAP sessions.
Given mS and the view of S, if S’s view is valid, then R decides for every complaint in mS by decrypting
the corresponding query and executing S’s steps for that query in the billing cycles phase described above.
Given mC and the view of C, if C’s view is valid, then R decides for every complaint in mC by retrieving
the rejected proof’s details (included in the complaint), decrypting the related query and (i) executing S’s
steps for that query, (ii) executing C’s veriﬁcation for the rejected proof and the related query. The arbiter
updates SC’s state based upon its decisions. Finally, coin transfer is carried out according to the state of SC,
as updated by R.

Before we present the protocol, we discuss how metadata generator function MPoR, the pair of encoding/de-
coding functions (EPoR, DPoR) and the query generator function QPoR (involved in the RC-S-P Deﬁnition 10)
are deﬁned in the PoR context, as they are often implicit in the original deﬁnition of PoR. Brieﬂy, MPoR is
a function that processes a ﬁle and generates metadata. For instance, when PoR uses a Merkle tree, then

31

MPoR refers to MT.genTree(w) → (tr, σ), where tr is the tree constructed on in ﬁle w and σ is the root of the
tree. Encoding by EPoR refers to encrypting with a symmetric key and then adding an appropriate number
of pads, while decoding by DPoR refers to removing the pads and then decrypting with the symmetric key.
Furthermore, QPoR can be a PRF that generates a set of pseudorandom strings in a certain range, e.g., ﬁle
block’s indices.

1. Key Generation. RCPoRP.keyGen(1λ)
(a) C picks a fresh symmetric encryption key ¯k ← SKE.keyGen(1λ).
(b) C sets parameter padπ: the number of dummy values to pad encrypted proofs. Let sk′ := (padπ, ¯k). The

key’s size is part of the security parameter. Let k′ := (sk′, pk′), where pk′ := (adrC, adrS).

2. Client-side Initiation. RCPoRP.cInit(1λ, u, k′, z, pl)

(a) Calls PoR.setup(1λ, u) → (u∗, pp) to encode u. It appends pp := (σ, φ, m, ζ) and sk′ to secret param-

eters qp.

(b) Sets coin secret parameters cp := (o, omax, l, lmax, z), then coin∗

C = z · (omax + lmax) and pS = z · lmax,
C and pS are the total number of masked coins C and S should

given the price list pl, where coin∗
deposit. Section 3.1 deﬁnes the parameters.

(c) Calls SAP.init(1λ, adrC, adrS, qp) → (rqp, gqp, adrSAP1 ) and SAP.init(1λ, adrC, adrS, cp) → (rcp, gcp, adrSAP2 )
to initiate agreements on qp and cp with S. Let Tqp := (¨xqp, gqp) and Tcp := (¨xcp, gcp), s.t. ¨xqp := (qp, rqp)
and ¨xcp := (cp, rcp) are the openings of gqp and gcp. Let T := {Tqp, Tcp}.
(d) Sets a smart contract, SC, that explicitly speciﬁes parameters z, coin∗

cluding time values Time := {T0, ..., T2, G1,1, ..., Gz,2, J, K1, ..., K6, L} and a vector [yC, y′
as [0, 0, 0, 0]. It deploys SC. Let adrSC be the address of the deployed SC and y := [yC, y′

C, pS, adrSAP1 , adrSAP2, pk′, in-
C, yS, y′
S] initialized
S, adrSC].
C coins in the contract. It sends u∗, z, ¨xqp, and ¨xcp (along with adrSC) to S. Let T0 be

(e) Deposits coin∗

C, yS, y′

the time that the above process ﬁnishes.

3. Server-side Initiation. RCPoRP.sInit(u∗, z, T, pS, y)

(a) Checks the parameters in T (e.g., qp and cp) and in SC (e.g., pS, y) and ensures suﬃcient amount of

coins has been deposited by C.

(b) Calls SAP.agree(qp, rqp, gqp, adrC, adrSAP1 ) → (g′

qp, b1) and SAP.agree(cp, rcp, gcp, adrC, adrSAP2 ) → (g′

cp, b2),

to check and agree on qp and cp.

(c) If b1 = 0 or b2 = 0, it sets a = 0. Otherwise, it veriﬁes the public parameters correctness as follows (i)
rebuilds the Merkle tree on u∗ and checks the resulting root equals σ, and (ii) checks |u∗| = m and
φ ≤ m, where (m, φ) ∈ T , and σ ∈ pp ∈ T . If the checks pass, it sets a = 1; else, it sets a = 0. It sends
a and coin∗

S = pS coins to SC at time T1, where coin∗

S = ⊥ if a = 0.

S and C can withdraw their coins at time T2, if S sends a = 0, fewer coins than pS, or nothing to the SC.
To withdraw, S or C sends a “pay” message to RCPoRP.pay(.) at time T2.
Billing-cycles Onset. C and S engage in phases 4-6, at the end of every j-th billing cycle, where 1 ≤ j ≤ z.
Each j-th cycle includes two time points, Gj,1 and Gj,2, where Gj,2 > Gj,1, and G1,1 > T2.

4. Client-side Query Generation. RCPoRP.genQuery(1λ, Tqp)

(a) Calls PoR.genQuery(1λ, pp) → ˆkj, where pp ∈ Tqp.
(b) Sends encrypted query c∗

j = Enc(¯k, ˆkj) to SC at time Gj,1.
j , Tqp)

5. Server-side Proof Generation. RCPoRP.prove(u∗, c∗
j ), where ¯k ∈ Tqp.

(a) Decrypts the query, ˆkj = Dec(¯k, c∗
(b) Checks the query’s correctness by ensuring ˆkj is not empty, and is in the key’s universe, i.e., ˆkj ∈

{0, 1}ψ. If the checks pass, it sets bj = 1; otherwise, it sets bj = 0.

• if bj = 1, it sets mS,j = ⊥. Also, it generates proofs vector by calling PoR.prove(u∗, ˆkj, pp) → πj.
j contain the
j with padπ ∈ Tqp random values picked from

Then, it encrypts the proofs, i.e., for 1 ≤ g ≤ |πj| : Enc(¯k, πj[g]) = π′
encrypted proofs. It pads every encrypted proof in π′
the encryption’s output range, U . Let π∗

j be the result. It sends π∗

j to SC at time Gj,2.

j[g]. Let π′

• if bj = 0, it sets the complaint mS,j = j. It constructs a dummy proof π′
randomly picked from U , pads the result as above, and sends the result, π∗

j whose elements are
j , to SC at time Gj,2.

32

It outputs bj and mS,j.

6. Client-side Proof Veriﬁcation. RCPoRP.verify(π∗

j , c∗

j , Tqp)

(a) Removes the pads from π∗

j , yielding π′

j. It decrypts the service proofs Dec(¯k, π′

j) = πj and then veriﬁes

the proof by calling PoR.verify(πj, ˆkj, pp) → dj, where ˆkj = Dec(¯k, c∗

j ).

• if πj passes the veriﬁcation, i.e., dj[0] = 1, it sets mC,j = ⊥ and concludes that the service for

this veriﬁcation was delivered.

• otherwise (i.e., dj[0] = 0), it sets g = dj[1] and the complaint mC,j = [j, g]. Recall, dj[1] refers to

a rejected proof’s index in proof vector πj.

(b) It outputs dj and mC,j.

7. Dispute Resolution. RCPoRP.resolve(mC, mS, z, π∗, c∗, Tqp)

This phase takes place only in case of dispute, i.e., when C rejects service proofs or S rejects the queries.
(a) The arbiter R ensures counters: yC, y′
(b) S sends complaints mS and ¨xqp to the arbiter, at time K1.
(c) Upon receiving mS and ¨xqp , the arbiter takes the following steps at time K2.

S are set to 0, before time K1, where K1 > Gz,2 + J.

C, yS and y′

i. checks ¨xqp’s validity, by calling the SAP’s veriﬁcation which returns d. If the output is d = 0, it
discards mS and does not take steps 7(c)ii and 7(c)iii. Otherwise, it proceeds to the next step.
ii. removes from mS any element that is duplicated or is not in the range [1, z]. It constructs an

empty vector v.

iii. for any element i ∈ mS: fetches the related encrypted query c∗

i ∈ c∗ from SC and decrypts it as
i ); it checks the query by doing the same checks performed in step 5b. If the query
S by

ˆki = Dec(¯k, c∗
is rejected, it increments yC by 1 and appends i to v. If the query is accepted, it increments y′
1. Let K3 be the time the above checks are complete.

(d) C sends complaints mC and ¨xqp to the arbiter, at time K4.
(e) Upon receiving mC and ¨xqp, R takes the below steps at K5.

i. checks ¨xqp’s validity, by calling the SAP’s veriﬁcation which returns d′. If d′ = 0, it discards mC,

and does not take steps 7(e)ii-7(e)iii. Otherwise, it proceeds to the next step.

ii. ensures each vector m ∈ mC is well-formed. Speciﬁcally, it checks there exist no two vectors:
m, m′ ∈ mC such that m[0] = m′[0]. If such vectors exist, it deletes the redundant ones from
mC. This ensures no two claims refer to the same veriﬁcation. It removes any vector m from mC if
m[0] is not in the range [1, z] or if m[0] ∈ v. The latter check ensures C cannot hold S accountable
if C generated an invalid query for the same veriﬁcation.

iii. for every vector m ∈ mC:

A. retrieves a rejected proof’s details by setting j = m[0] and g = m[1]. Recall that g refers to the
index of a rejected proof in the proof vector which was generated for j-th veriﬁcation, i.e., πj.

B. fetches the related encrypted query c∗

the pads only from g-th padded encrypted proof. Let π′
encrypted proof, Dec(¯k, π′

j[g])) = πj[g].

j ∈ c∗ from SC and decrypts it: ˆkj = Dec(¯k, c∗

j ). It removes
j[g] be the result. Next, it decrypts the

C. identiﬁes the misbehaving party as follows.

– veriﬁes ˆkj by doing the same checks done in step 5b. If the checks do not pass, it sets Ij = C

and skips the next two steps; otherwise, it proceeds to the next step.
– derives the related challenged block’s index from ˆkj, by computing qg =
+1.
– veriﬁes only g-th proof, by calling PoR.verify(πj[g], qg, pp) → d′. If d′[0] = 0, then it sets

PRF(ˆkj, g) mod m

(cid:0)

(cid:1)

Ij = S. Otherwise, it outputs Ij = ⊥.

– if Ij = C, it increments yC by 1. If Ij = S, it increments yS by 1. If Ij = ⊥, it increments y′

C

by 1.

(f) The arbiter at time K6 sends [yC, yS, y′
8. Coin Transfer. RCPoRP.pay(y, Tcp, a, pS, coin∗

C, y′

C, coin∗
S)

S] to SC which accordingly adds them to y.

(a) If SC receives “pay” message at time T2, where a = 0 or coins∗

S < pS, then it sends coin∗

C coins to C

and coin∗

S coins to S. Otherwise (i.e., they reach an agreement), the following step is executed.

(b) If SC receives “pay” message and ¨xcp ∈ Tcp at time L > K6, it checks ¨xcp’s validity by calling the SAP’s

veriﬁcation which returns d′′.

33

(c) If d′′ = 1, SC distributes the coins to the parties as follows:

i. coinC = coin∗
ii. coinS = coin∗
iii. coinR = l · (yS + yC + y′

C − o · (z − yS) − l · (yC + y′
S + o · (z − yS) − l · (yS + y′
S + y′

C) coins to the arbiter.

C) coins to C.
S) coins to S.

Brieﬂy, the RC-PoR-P protocol’s correctness holds dues to the correctness of PoR, symmetric key en-
cryption, SAP, and smart contract. Appendix E presents a more detailed discussion. Below, we state our
main theorem on the security of the RC-PoR-P scheme. Appendix F presents the theorem’s proof.

Theorem 3. The RC-PoR-P scheme with functions FPoR, MPoR, EPoR, DPoR, QPoR described in Subsections 8.1
and 8.2 is secure (cf. Deﬁnition 15), if the underlying Merkle tree, pseudorandom function, commitment
scheme, and digital signature scheme are secure, and the underlying symmetric-key encryption scheme is
IND-CPA secure.

Due to the eﬃciency of the arbiter-side algorithm, in the above protocol, we can delegate the arbiter’s
role to the smart contract, SC. In Appendix G, we explain how the RC-PoR-P’s protocol (and deﬁnition)
can be adjusted to support such a delegation.

9 Evaluation of RC-PoR-P

In this section, we provide an analysis of the RC-PoR-P protocol. Table 2 summarises the protocol’s concrete
cost (we also provide a table for its asymptotic cost in Appendix H). Also, we compare RC-PoR-P with (a) the
zero-knowledge contingent (publicly veriﬁable) PoR payment in [17] and the fair PoR payment scheme in [3]
that are more eﬃcient than the state-of-the-art and closest to our work. Table 3 summarises the comparison.
The analysis of RC-PoR-P covers both asymptotic and concrete overheads. To conduct the concrete cost
study, we have implemented RC-PoR-P. The protocol’s oﬀ-chain and on-chain parts have been implemented
in C++ and Solidity programming languages respectively. To conduct the oﬀ-chain experiment, we used
a server with dual Intel Xeon Gold 5118, 2.30 GHz CPU and 256 GB RAM. To carry out the on-chain
experiment, we used a MacBook Pro laptop with quad-core Intel Core i5, 2 GHz CPU and 16 GB RAM
that interacts with the Ethereum private blockchain. We ran the experiment 10 times. In the experiment,
we used the SHA-2 hash function and set its output length and the security parameter to 128 bits. We set
the size of every block to 128 bits, as in [58]. We used a random ﬁle whose size is in the range [64 MB, 4 GB].
This results in the number of ﬁle blocks in the range [222, 228]. Since in the experiment we used relatively
large ﬁle sizes, to lower on-chain transaction costs, we allow the parties to use the technique explained in
Section 7.3, which lets the server and client exchange the (PoR) proofs oﬀ-chain in an irrefutable fashion8.
The prototype implementation utilises the Cryptopp [21] and GMP [56] libraries. The protocol’s oﬀ-chain
and on-chain source code are publicly available in [1] and [2] respectively.

9.1 Computation Cost

In our analysis, the cost of erasure-coding a ﬁle is not taken into consideration, as it is identical in all PoR
schemes. We ﬁrst analyse the computation cost of RC-PoR-P. C’s cost is as follows. In phase 2, its cost

log2 (m)

in step 2a involves m ·

1
2i invocations of a hash function. So its complexity in this step is O(m). Its
total cost in steps 2b and 2c involves two invocations of the hash function. Therefore, the client-side total
complexity in this phase is O(m). In this phase, its oﬀ-chain run-time increases about 2× (i.e., from 23.1 to
45.5, ..., from 732.1 to 1596.6 seconds) when m increases (i.e., from 222 to 223, ..., from 227 to 228 blocks). This
phase also costs it 123 · 10−5 ether. In phase 4, C invokes PRF and symmetric-key encryption φ times and

i=1
P

8

For each j-th veriﬁcation, S sends each related path to C, via an authenticated channel. If C rejects a path, then it inserts into
its complaint S’s message that includes one of the invalid paths for j-th veriﬁcation. Our analysis excludes signature generation
and veriﬁcation processes as they can be eﬃciently incorporated by using standard authenticated channels (e.g., PKI-based XML
signatures).

34

Table 2: RC-PoR-P oﬀ-chain run-time (in seconds) and on-chain cost, of z veriﬁcations; breakdown by phases. In
the table, z′ is the maximum number of complaints the client and server send to the arbiter, and m is the number of
blocks in a ﬁle.

Phase

Client-side Init.

Server-side Init.

Client-side Query Gen.

Server-side Proof Gen.

m : 222
23.1

8.9
-
22.4 · z

m : 223
45.5

16.5
-
30.4 · z

Oﬀ-chain cost
m : 225
185.8

134.6
-
166.8 · z

m : 224
89.7

33.2
-
57.4 · z

m : 226

413

149.4
-
376.1 · z

m : 227 m : 228
1596.6
732.1

248.8
-
793.1 · z

548.8
-
1820.7 · z

Client-side Proof Ver.

0.24 · z
Arbiter-side Dispute Res. 2 · 10−5 · z′ 4 · 10−5 · z′ 8 · 10−5 · z′ 8 · 10−5 · z′ 9 · 10−5 · z′ 9 · 10−5 · z′ 10−4 · z′

0.11 · z

0.21 · z

0.18 · z

0.12 · z

0.09 · z

0.16 · z

Coin Transfer

-

-

-

-

-

-

-

On-chain cost

Ether US Dollar

123 · 10−5
9 · 10−5

3.42

0.22

6 · 10−5 · z 0.17 · z

-
-
10−4
6 · 10−5

-
-
0.27

0.17

Table 3: Contingent PoRs comparison. In the table, m is the number of blocks in a ﬁle, T is a time parameter, and
φ is the number of challenged blocks.

Protocols

Operation

Initiate Solve Puzzle

Computation Complexity

[3]

[17]

RC-PoR-P

Exp.

O(z)

Add. or Mul. O(m + zφ)

Exp.
Add. or Mul.
Hash
ZK proof
Hash
Sym. key enc.

O(m)
−
O(m)
−
O(m)
−

O(T z)
O(z)
−
−
−
−
−
−

Prove
−
O(zφ)
O(zφ)
O(zφ)
O(1)
O(zφ)

Verify
−
O(zφ)
O(zφ)
O(zφ)
O(1)
O(zφ)

Proof
Size

O(1)

O(1)

Secure Against Malicious Oﬀers
Privacy

Server

Client

×

×

X

X

X

X

×

×

X

O(zφ log2(m)) O(zφ log2(m))
O(zφ log2(m)) O(zφ log2(m))

O(φ log2(m))

once respectively. So, for z veriﬁcations its total computation cost is O(z · φ). Its oﬀ-chain run-time in this
phase is negligibly small. This phase also costs it 6 · 10−5 · z ether. In phase 6, C for each veriﬁcation decrypts
and veriﬁes proofs which mainly involves φ · (log2(m) + 1) invocations of the symmetric key encryption and
φ · log2(m) invocations of the hash function. So, its total complexity in this phase is O(z · φ · log2(m)). Its
oﬀ-chain run-time in this phase is very low and grows almost 1.1× (i.e., from 0.09 · z to 0.11 · z, ..., from
0.21 · z to 0.24 · z seconds) when m increases.

Now, we analyse S’s computation cost. In phase 3, S’s complexity is O(m). Its oﬀ-chain run-time in this
phase grows 2× (i.e., from 8.9 to 16.5, ..., from 248.8 to 548.8 seconds) when m increases. This phase costs it
9 · 10−5 ether. In phase 5, S decrypts a value for each veriﬁcation, generates and encrypts proofs that require
φ · log2(m) invocations of the hash function and φ · (log2(m) + 1) invocations of symmetric key encryption, for
each veriﬁcation. So, its total complexity in phase 5 is O(z · φ · log2(m)). In this phase, its oﬀ-chain run-time
grows about 2.1× (i.e., from 22.4 · z to 30.4 · z, ..., from 793.1 · z to 1820.7 · z seconds) when m increases. 9
Next, we analyse R’s cost in phase 7. First, we evaluate R’s cost when it is invoked by an honest S.
In this case, it invokes the hash function twice and decrypts |vS| queries, where |vS| is the total number
of veriﬁcations that S complained about and |vS| ≤ z. Now, we evaluate its cost when it is invoked by an
honest C. It invokes the hash function twice to check the correctness of the statement, ¨xqp, sent by the client.
It invokes the hash function |vC| · (log2(m) + 2) times and the symmetric key encryption |vC| · (log2(m) + 2)
times, where |vC| is the total number of veriﬁcations that C complained about. Thus, its cost, in phase 7
is at most O(z′ · log2(m)), where z′ = M ax(|vC|, |vS|) and z′ ≤ z. Note that due to the use of the proof
φ = 1
of misbehaviour in the protocol, R’s cost is about 1
460 of its computation cost in the absence of such

9

To determine S’s cost for generating a proof, we considered the case where S does not store the Merkle tree nodes (to save storage
space), instead it generates the tree’s paths every time a challenge is given to it. If we let S store the tree, then it would have a lower
computation overhead.

35

technique where it has to check all φ proofs for each veriﬁcation.10 Its oﬀ-chain run-time is very low and
increases about 1.3× (i.e., from 2 · 10−5 · z′ to 4 · 10−5 · z′, ..., from 9 · 10−5 · z′ to 10−4 · z′ seconds) when m
increases. Phase 7 also imposes 10−4 ether to R. In phase 8, SC invokes the hash function only twice, so its
computation complexity is constant. This phase imposes 6 · 10−5 ether to the party that calls RCPoRP.pay.

9.2 Communication Cost

We ﬁrst analyse C’s communication cost. In phase 2, C sends ||u∗|| + 384 bits. So, in this phase, its complexity
is O(||u∗||). In phase 7, it sends (¨xqp, mC), where ¨xqp contains (a) padding information whose size is a few bits
and (b) the symmetric-key encryption’s key whose size is 128 bits. Also, mC contains at most z invalid paths
of the Merkle tree. Thus, in this phase, its communication cost is z · log2(||u∗||) + 128 bits or O(z · log2(||u∗||)).
S’s complexity for z veriﬁcations is O(z · ||π∗
j ||), as in phase 5, for each veriﬁcation, it sends out a proof
vector π∗
j . R’s communication cost is constant, as it only sends a transaction containing four values in phase
7.

9.3 Comparison

The fair PoR scheme in [3] assumes that C is trusted. The initiation phase involves O(z) modular exponentia-
tions and O(m + zφ) modular multiplications to generate puzzles and MACs respectively. Given the puzzles,
S has to continuously solve them sequentially until all z veriﬁcations end, which requires S to perform the
exponentiations even between two consecutive veriﬁcations. This requires S to perform O(T z) exponenti-
ations and z modular multiplications, where T is a time parameter. For z veriﬁcations, S performs O(zφ)
multiplications to generate z proofs. A veriﬁer performs O(zφ) multiplications to verify all proofs. Now we
focus on the scheme in [17]. As we showed in Section 4.1, this scheme is not secure against a malicious
C. In the initiation phase, C generates a signature for each ﬁle block which involves O(m) exponentiations
and O(m) hash function invocations. For S to generate z proofs, it (i) performs O(zφ) exponentiations to
combine the signatures, (ii) invokes the hash function at least O(1) times, and (iii) invokes zk proof system
O(zφ) times. The scheme imposes the same computation complexity on the veriﬁer as it does on the prover.
Campanelli et al. [17] provide an implementation of zkCSP for publicly and privately veriﬁable PoRs. We
were informed by Campanelli that the total size of the outsourced ﬁle used in their experiment is at most
256 bits, which is very small. In contrast, in our experiment, we used a much large ﬁle size, i.e., 4-GB.

Since both schemes in [3] and [17] use homomorphic tags, proofs for each veriﬁcation can be combined
resulting in constant proof size, i.e., O(1). These schemes do not address the privacy issue we highlighted
in Section 4.1. However, RC-PoR-P is secure against a malicious C and rectiﬁes the privacy issue. Similar
to the other two schemes, its initiation complexity is O(m); but, unlike them, it does not require any
modular exponentiations. Instead, it involves only invocations of the hash function which imposes a much
lower overhead. Moreover, unlike the other two schemes that have O(zφ) complexity in the prove and verify
phases, RC-PoR-P’s complexity, in theory, is slightly higher, i.e., it is O(zφ log2(m)). However, the extra
factor: log2(m) is not very high in practice. For instance, for a 4-GB ﬁle (or 228 blocks), it is only 28. RC-
PoR-P’s prove and verify algorithms, similar to the ones [3], involve only symmetric key operations; whereas,
the ones in [17] need asymmetric key operations. Also, RC-PoR-P’s the proof size complexity is larger than
the other two schemes; However, each message length in RC-PoR-P is much shorter than the one in [17],
i.e., 128-bit vs 2048-bit.

Thus, overall RC-PoR-P is computationally more eﬃcient than [17] and [3] while oﬀering stronger security

guarantees (i.e., security against a malicious client and privacy).

10 Conclusion

Fair exchange is an interesting problem. It captures the scenario in which two mutually distrusted parties want
to swap digital items such that either each party gets the other’s item, or neither party does. Solutions to the

10

As shown in [11], to ensure 99% of ﬁle blocks is retrievable, it would be suﬃcient to set the number of challenged blocks to 460.

36

problem are often certain cryptographic protocols. They have numerous real-world applications; especially,
nowadays where the use of the Internet for conducting business is swiftly increasing. Many years ago, it
was shown that fairness is unachievable without the aid of a trusted third party. However, the advent
of blockchain oﬀered a possibility to eliminate the trusted third party’s involvement. Therefore, various
blockchain-based fair exchange protocols were proposed. In this work, we showed that the blockchain-based
fair exchange protocols are not suitable for the exchange of digital coins and digital veriﬁable services. If
they are used directly, in this setting, then serious issues would arise, i.e., real-time information leakage
and waste of seller’s resources. We formally deﬁned and proposed a generic construction called “recurring
contingent service payment” (RC-S-P) that addresses the issues. RC-S-P lets a fair exchange of digital coins
and veriﬁable service’s proof, while ensuring that the buyer cannot waste the seller’s resources, and the
parties’ privacy is preserved. RC-S-P uses smart contracts; however, most of the computation is performed
oﬀ-chain which makes the smart contracts-side computation very low. RC-S-P is the ﬁrst fair service payment
scheme that oﬀers a combination of the above appealing features. We also presented concrete instantiation
of the RC-S-P, when the veriﬁable service is the “proofs of retrievability” (PoR). The instantiation is called
“recurring contingent PoR payment” (RC-PoR-P). We implemented the RC-PoR-P and analysed its costs.
Our cost evaluation indicated that the RC-PoR-P is eﬃcient. RC-PoR-P is the ﬁrst PoR scheme that oﬀers
all the above features at once.

Acknowledgments

Aydin Abadi and Steven J. Murdoch were supported by REPHRAIN: The National Research Centre on
Privacy, Harm Reduction and Adversarial Inﬂuence Online, under UKRI grant: EP/V011189/1. Steven J.
Murdoch was also supported by The Royal Society under grant UF160505.

References

1. Abadi, A.: Oﬀ-chain source code of ”recurring contingent proofs of retrievability payment” (RC-PoR-P) (2021),

https://github.com/AydinAbadi/RC-PoR-P-Source-code/blob/master/RC-PoR-P.cpp

2. Abadi, A.: On-chain source code of ”recurring contingent proofs of retrievability payment” (RC-PoR-P) (2021),

https://github.com/AydinAbadi/RC-PoR-P-Source-code/blob/master/RC-PoR-P-Smart-Contract.sol

3. Abadi, A., Kiayias, A.: Multi-instance publicly veriﬁable time-lock puzzle and its applications. In: Financial

Cryptography and Data Security Conference, FC (2021)

4. Abadi, A., Murdoch, S.J.: Payment with dispute resolution: A protocol for reimbursing frauds’ victims. IACR

Cryptol. ePrint Arch. p. 107 (2022), https://eprint.iacr.org/2022/107

5. Abadi, A., Murdoch, S.J., Zacharias, T.: Recurring contingent payment for proofs of retrievability. IACR Cryptol.

ePrint Arch. (2021), https://eprint.iacr.org/2021/1145

6. Amazon: Amazon s3 pricing (2021), https://aws.amazon.com/s3/pricing/
7. Androulaki, E., Karame, G., Roeschlin, M., Scherer, T., Capkun, S.: Evaluating user privacy in bitcoin. In:

Financial Cryptography and Data Security Conference FC (2013)

8. Armknecht, F., Bohli, J.M., Karame, G.O., Liu, Z., Reuter, C.A.: Outsourced proofs of retrievability. In: CCS’14
9. Asokan, N., Schunter, M., Waidner, M.: Optimistic protocols for fair exchange. In: Graveman, R., Janson, P.A.,

Neuman, C., Gong, L. (eds.) Conference on Computer and Communications Security CCS (1997)

10. Asokan, N., Shoup, V., Waidner, M.: Optimistic fair exchange of digital signatures (extended abstract). In:
Nyberg, K. (ed.) International Conference on the Theory and Application of Cryptographic Techniques EURO-
CRYPT (1998)

11. Ateniese, G., Burns, R.C., Curtmola, R., Herring, J., Kissner, L., Peterson, Z.N.J., Song, D.X.: Provable data

possession at untrusted stores. In: CCS’07

12. Bao, F., Deng, R.H., Mao, W.: Eﬃcient and practical fair exchange protocols with oﬀ-line TTP. In: IEEE

Symposium on Security and Privacy (1998)

13. Barber, S., Boyen, X., Shi, E., Uzun, E.: Bitter to better - how to make bitcoin a better currency. In: Financial

Cryptography and Data Security Conference, FC (2012)

14. Bary, E.: Zoom stock falls after service outage (2020), https://www.marketwatch.com/story/zoom-stock-falls-amid-service-outage-2020-08-24

37

15. Ben-Sasson, E., Chiesa, A., Garman, C., Green, M., Miers, I., Tromer, E., Virza, M.: Zerocash: Decentralized

anonymous payments from bitcoin. In: IEEE Symposium on Security and Privacy, SP (2014)

16. Boneh, D., Naor, M.: Timed commitments. In: Bellare, M. (ed.) CRYPTO 2000
17. Campanelli, M., Gennaro, R., Goldfeder, S., Nizzardo, L.: Zero-knowledge contingent payments revisited: Attacks

and payments for services. In: CCS’17

18. Canetti, R., Riva, B., Rothblum, G.N.: Practical delegation of computation using multiple servers. In: Chen, Y.,
Danezis, G., Shmatikov, V. (eds.) Proceedings of the 18th ACM Conference on Computer and Communications
Security, CCS 2011

19. Cleve, R.: Limits on the security of coin ﬂips when half the processors are faulty (extended abstract). In: Pro-

ceedings of the 18th Annual ACM Symposium on Theory of Computing. pp. 364–369. ACM (1986)

20. Cramer, R., Damg˚ard, I., Ishai, Y.: Share conversion, pseudorandom secret-sharing and applications to secure

computation. In: Kilian, J. (ed.) TCC. Springer (2005)
21. Dai, W.: Crypto++ library (2014), https://cryptopp.com
22. Damg˚ard, I., Ishai, Y.: Constant-round multiparty computation using a black-box pseudorandom generator. In:

Shoup, V. (ed.) CRYPTO, 2005, Proceedings (2005)

23. Dong, C., Chen, L., Camenisch, J., Russello, G.: Fair private set intersection with a semi-trusted arbiter. In: Data

and Applications Security and Privacy (2013)

24. Dropbox: Choose the right dropbox for you (2021), https://www.dropbox.com/plans?tab=personal
25. Du, Y., Duan, H., Zhou, A., Wang, C., Au, M.H., Wang, Q.: Enabling secure and eﬃcient decentralized storage

auditing with blockchain. IEEE Transactions on Dependable and Secure Computing (2021)

26. Dziembowski, S., Eckey, L., Faust, S.: Fairswap: How to fairly exchange digital goods. In: Lie, D., Mannan, M.,
Backes, M., Wang, X. (eds.) Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications
Security, CCS 2018

27. Eckey, L., Faust, S., Schlosser, B.: Optiswap: Fast optimistic fair exchange. In: Sun, H., Shieh, S., Gu, G., Ateniese,
G. (eds.) ASIA CCS ’20: The 15th ACM Asia Conference on Computer and Communications Security (2020)
28. Fuchsbauer, G.: WI is not enough: Zero-knowledge contingent (service) payments revisited. In: Cavallaro, L.,
Kinder, J., Wang, X., Katz, J. (eds.) Proceedings of the 2019 ACM SIGSAC Conference on Computer and
Communications Security, CCS 2019

29. Garay, J.A., Jakobsson, M.: Timed release of standard digital signatures. In: Blaze, M. (ed.) FC’02
30. Gennaro, R., Gentry, C., Parno, B.: Non-interactive veriﬁable computing: Outsourcing computation to untrusted
workers. In: Rabin, T. (ed.) Advances in Cryptology - CRYPTO 2010, 30th Annual Cryptology Conference (2010)
31. Gennaro, R., Gentry, C., Parno, B., Raykova, M.: Quadratic span programs and succinct nizks without pcps. In:

Advances in Cryptology - EUROCRYPT 2013 (2013)

32. Ghosh, S., Nilges, T.: An algebraic approach to maliciously secure private set intersection. In: Ishai, Y., Rijmen,

V. (eds.) EUROCRYPT. Lecture Notes in Computer Science, Springer (2019)

33. Goldreich, O.: The Foundations of Cryptography - Volume 1: Basic Techniques. Cambridge University Press

(2001), http://www.wisdom.weizmann.ac.il/%7Eoded/foc-vol1.html

34. GoogleOne: Upgrade to a plan that works for you (2021), https://one.google.com/about/plans?hl=en_GB
35. Halevi, S., Harnik, D., Pinkas, B., Shulman-Peleg, A.: Proofs of ownership in remote storage systems. In: Pro-

36. Haselton,

ceedings of the 18th ACM Conference on Computer and Communications Security, CCS 2011 (2011)
hours

goes
https://www.cnbc.com/2021/01/04/slack-outage-on-first-monday-of-2021.html

service

down

Slack

three

more

than

T.:

for

(2021),

37. Hu, C., Cheng, X., Tian, Z., Yu, J., Lv, W.: Achieving privacy preservation and billing via delayed information

release. IEEE/ACM Transactions on Networking (2021)

38. Ishai, Y., Ostrovsky, R., Zikas, V.: Secure multi-party computation with identiﬁable abort. In: Garay, J.A.,
Gennaro, R. (eds.) Advances in Cryptology - CRYPTO 2014 - 34th Annual Cryptology Conference (2014)
39. Juels, A., Jr., B.S.K.: Pors: Proofs of retrievability for large ﬁles. IACR Cryptology ePrint Archive 2007, 243

(2007)

40. Kalodner, H.A., Goldfeder, S., Chen, X., Weinberg, S.M., Felten, E.W.: Arbitrum: Scalable, private smart con-
tracts. In: Enck, W., Felt, A.P. (eds.) 27th USENIX Security Symposium, USENIX Security. USENIX Association
(2018)

41. Katz, J., Lindell, Y.: Introduction to Modern Cryptography. Chapman and Hall/CRC Press (2007)
42. Katz, J., Lindell, Y.:

Introduction to Modern Cryptography, Second Edition. CRC Press
https://www.crcpress.com/Introduction-to-Modern-Cryptography-Second-Edition/Katz-Lindell/p/book/9781466570269

(2014),

43. Kosba, A.E., Miller, A., Shi, E., Wen, Z., Papamanthou, C.: Hawk: The blockchain model of cryptography and

privacy-preserving smart contracts. In: S&P’16

38

44. Lab, K.: Understanding security of the cloud: from adoption beneﬁts to threats and concerns. Kaspersky daily

(2018), https://www.kaspersky.com/blog/understanding-security-of-the-cloud

45. Lai, J., Deng, R.H., Pang, H., Weng, J.: Veriﬁable computation on outsourced encrypted data. In: Kutylowski,

M., Vaidya, J. (eds.) ESORICS 2014 (2014)

46. Liu, Z., Li, T., Li, P., Jia, C., Li, J.: Veriﬁable searchable encryption with aggregate keys for data sharing system.

Future Gener. Comput. Syst. (2018)

47. Maxwell, G.: Zero knowledge contingent payment (2011)
48. Merkle, R.C.: Protocols for public key cryptosystems. In: Proceedings of the 1980 IEEE Symposium on Security

and Privacy, Oakland, California, USA, April 14-16, 1980. pp. 122–134. IEEE Computer Society (1980)

49. Merkle, R.C.: A certiﬁed digital signature. In: Brassard, G. (ed.) Advances in Cryptology - CRYPTO ’89, 9th

Annual International Cryptology Conference (1989)

50. Merryweather, L.: Three in ﬁve people have received a scam delivery text in the past year (2021),

https://www.which.co.uk/news/2021/06/three-in-five-people-have-received-a-scam-delivery-text-in-the-last-year/

51. Miao, Y., Tong, Q., Deng, R., Choo, K.R., Liu, X., Li, H.: Veriﬁable searchable encryption framework against

insider keyword-guessing attack in cloud storage. IEEE Transactions on Cloud Computing (2020)

52. Miller, A., Juels, A., Shi, E., Parno, B., Katz, J.: Permacoin: Repurposing bitcoin work for data preservation. In:

S&P’14

53. Nakamoto, S.: Bitcoin: A peer-to-peer electronic cash system. Tech. rep. (2019)
54. Nguyen, K., Ambrona, M., Abe, M.: WI is almost enough: Contingent payment all over again. In: CCS ’20: 2020

ACM SIGSAC Conference on Computer and Communications Security, 2020

55. Pedersen, T.P.: Non-interactive and information-theoretic secure veriﬁable secret sharing. In: CRYPTO ’91
56. Project, G.: The gnu multiple precision arithmetic library (1991), https://gmplib.org/
57. Reid, F., Harrigan, M.: An analysis of anonymity in the bitcoin system. In: Privacy, Security, Risk and Trust

(PASSAT) (2011)

58. Shacham, H., Waters, B.: Compact proofs of retrievability. In: ASIACRYPT. pp. 90–107 (2008)
59. Shen, S., Tzeng, W.: Delegable provable data possession for remote data in the clouds. In: ICICS 2011
60. Tram`er, F., Zhang, F., Lin, H., Hubaux, J., Juels, A., Shi, E.: Sealed-glass proofs: Using transparent enclaves to
prove and sell knowledge. In: 2017 IEEE European Symposium on Security and Privacy, EuroS&P 2017 (2017)

61. UK Finance: 2021 half year fraud update (2021), https://www.ukfinance.org.uk/system/files/Half-year-fraud-update-2021-FINAL.pdf
62. Wang, X., Zhao, L.: Veriﬁable single-server private information retrieval. In: Information and Communications

Security - 20th International Conference, ICICS 2018 (2018)

63. Wood, G., et al.: Ethereum: A secure decentralised generalised transaction ledger. Ethereum project yellow paper

(2014) (2014)

64. Zhang, L.F., Safavi-Naini, R.: Veriﬁable multi-server private information retrieval. In: Boureanu, I., Owesarski,
P., Vaudenay, S. (eds.) Applied Cryptography and Network Security - 12th International Conference (2014)

A Survey of Related Work

As stated in the introduction, blockchain technology and in particular smart contracts have the potentials
to replace the third party in fair exchange protocols. Ethereum is the most predominant generic smart
contract platform. Although the third-party’s role can be directly encoded/programmed in an Ethereum
smart contract, it would not be eﬃcient. Moreover, Bitcoin, as the most popular cryptocurrency, supports
smart contracts with very limited functionalities. Therefore, the third party’s full role cannot be directly
encoded in a contract on the Bitcoin blockchain.

A.1 Zero-knowledge Contingent Payment

For the ﬁrst time in [47] it was shown how to construct a fair exchange protocol, called “zero-knowledge
contingent payment”, that utilises Bitcoin’s smart contract capabilities. The protocol allows a fair exchange
of digital goods and payments over Bitcoin’s network. Its main security requirement is that a seller is paid
if and only if a buyer learns a correct secret. The protocol uses a feature of Bitcoin’s scripting language,
called “hash-lock transaction”. This type of transaction lets one create a payment transaction that speciﬁes
a hash value y and allows anyone that can provide its preimage k, i.e H(k) = y, to claim the amount of coin
speciﬁed in the transaction. The contingent payment protocol in [47] works as follows. The seller ﬁrst picks

39

a secret key, k, of a symmetric-key encryption and uses it to encrypt the secret information, s. This yields a
ciphertext, c. It also computes the key’s hash, y = H(k). The seller sends c, y, and a (zero-knowledge) proof
to the buyer, where the proof asserts that c is the encryption of s under key k and H(k) = y.

After the buyer veriﬁes and accepts the proof, it sends a transaction to the blockchain that pays the seller
a ﬁxed amount of coin if the seller provides, to the blockchain, a value k such that H(k) = y. Next, the seller
sends k to the blockchain and receives the coins. Now, the buyer can read the blockchain and learn k which
allows it to decrypt c, and extract the secret, s. Later, after the advancement of the “succinct non-interactive
argument of knowledge” (zk-SNARK) [31], that results in a more eﬃcient implementation of zero-knowledge
proofs, the contingent payment protocol was modiﬁed to use zk-SNARK. However, all zk-SNARKs require
a trusted third party for a trusted setup, i.e., to generate a “common reference string” (CRS), which means
there would be a need for the involvement of an additional third party in those protocols that use them,
including the contingent payment protocol. As such involvement is undesirable, the contingent payment
protocol, that uses zk-SNARK, lets the buyer play the role of the third party and generate the parameter.

A.2 Zero-knowledge Contingent Service Payment

Later, Campanelli et al. [17] identify a serious security issue of the above contingent payment (that uses
zk-SNARK and lets a buyer pick a CRS). In particular, the authors show that a malicious buyer (which
generates the CRS) can construct the CRS in a way that lets it learn the secret from the seller’s proof
without paying the seller. Campanelli et al. propose a set of ﬁxes; namely, (a) jointly computing the CRS
using a secure two-party computation, (b) allowing the seller to check the well-formedness of the buyer’s
CRS, or (c) using a new scheme called “zero-knowledge Contingent Service Payments” (zkCSP). The latter
solution is a more eﬃcient approach than the other two and oﬀers an additional interesting feature; namely,
supporting contingent payment for digital (veriﬁable) services. In short, zkCSP works as follows. Let v(.)
be the veriﬁcation algorithm for a certain service and s be the service’s proof, where if the proof is valid it
holds that v(s) = 1. The parties agree on two claw-free hash functions, e.g., H1(.) and H2(.). The seller picks a
random value, r. Then, it computes either y = H1(r) if it knows s such that v(s) = 1, or y = H2(r) otherwise.
The seller also generates a witness indistinguishable proof of knowledge (WIPoK), π, using a compound
sigma protocol to prove that it knows either the preimage of y = H1(r) if it knows a valid s, i.e., v(s) = 1,
or the preimage of y = H2(r). Note, due to the witness indistinguishability of π and the ﬂaw-freeness of the
hash functions, the veriﬁer cannot tell which statement the prover is proving.

The seller sends the proof along with y to the buyer which ﬁrst ensures π is valid. Then, if the check
passes, the buyer sends to the blockchain a hash-lock transaction that would send n coins to the party that
can provide r to the blockchain such that y = H1(r). After a seller provides a valid r to the blockchain
it gets paid, accordingly the buyer concludes that it has been served honestly by the seller, as the seller
demonstrated the knowledge of the service proof, s. Otherwise (if the seller does not provide a valid r) it
would not get paid and the buyer learns nothing about s. To improve the eﬃciency of the above zkCSP and
to make it practical, the authors suggest using SNARKs in the setting that the buyer generates the CRS
but the seller initially performs minimal eﬃcient checks. Also, as concrete instantiations of the zkCSP, the
authors propose two schemes in which the service is “proof of retrievability” (PoR) [58]. One of the schemes
relies on a publicly veriﬁable PoR and the other one relies on a privately veriﬁable one. In these schemes,
the buyer uploads its data to a server and pays if and only if the server provides valid proof that asserts the
buyer’s data is retrievable.

A.3 Known Zero-knowledge Contingent (Service) Payment’s Flaw in the Literature

Fuchsbauer [28] identiﬁes a ﬂaw in the above zkCSP. The author shows that the minimal eﬃcient check
that the seller performs in the zkCSP is not suﬃcient, because it does not prevent the buyer from cheating
and learning the secret. He highlights that the use of computationally expensive veriﬁcation on the CRS is
inevitable to address the issue. Very recently, Nguyen et al. [54] show that by relying on a slightly stronger
notion of WI (i.e., trapdoor subversion witness indistinguishability), the zkCSP can remain secure and would

40

not be susceptible to the issues Fuchsbauer pointed out. Moreover, they propose an eﬃcient scheme that
relies on an interactive ZK proof system which is based on garbled circuits and oblivious transfer. However,
the above two issues, we highlighted in Section 4, are not identiﬁed and addressed in [28,54].

A.4 Using Ethereum Smart Contracts in Contingent Payment

Tramer et al. [60] propose a fair exchange scheme that uses a combination of trusted hardware, i.e., Intel
SGX, and Ethereum smart contracts. Interestingly, unlike the common assumption that secure hardware
maintains private states, this scheme relies on weaker security assumptions, i.e., it only relies on the integrity
of SGX’s computation and the authenticity of a message it sends. At a high level, in this scheme, the buyer
and seller agree on a smart contract and then the buyer deposits a ﬁxed amount of coin in the smart contract.
Then, the seller sends its messages (that contains proofs) to SGX which veriﬁes the messages’ correctness
and then sends its verdict to the smart contract. Next, the contract distributes the deposit according to the
SGX’s verdicts. The scheme in addition to achieving fair exchange wants to ensure that after the parties’
initial interaction and after the seller makes an oﬀer, the buyer cannot abort without paying the seller. To
this end, in the scheme, the contract needs to validate SGX’s signature (or in general attestation). However,
as the authors state, in practice the signature scheme used in SGX (i.e., EPID signature) is not supported by
standard Ethereum contracts. Therefore, the suggested technique, to ensure the buyer cannot abort, remains
only of theoretical interest. Also, in the protocol SGX is always involved, regardless of the parties’ behaviour.
Later, Dziembowski et al. [26] propose FairSwap, an eﬃcient protocol for a fair exchange of digital
goods (i.e., ﬁles) and coins. It is mainly based on the Ethereum smart contracts and the notion of proof of
misbehaviour [18]. Brieﬂy, a proof of misbehaviour scheme is usually based on a Merkle tree; in this scheme,
proving that a party has misbehaved is much cheaper than proving it has behaved honestly. FairSwap oﬀers
two main features: (a) imposes a low computation cost to a smart contract, and (b) avoids using zero-
knowledge proofs. At a high level, FairSwap works as follows. First, the seller and buyer agree on a smart
contract. Then, the seller picks a key k (for symmetric-key encryption), encrypts the secret (i.e., ﬁle) under
k, and sends the ciphertext to the buyer. The seller also commits to k and sends the commitment to the
smart contract. Next, the buyer veriﬁes the correctness of the buyer’s messages and if approved, it sends a
ﬁxed amount of coin to the smart contract. After that, the seller reveals the opening of the commitment, that
contains k, to the smart contract. This allows the buyer to read from the contract and learn k with which
it can decrypt the ciphertext, extract the secret, and then verify the secret’s correctness. In the case where
the buyer rejects the secret, it can send a short proof (of misbehaviour) to the contract which performs an
eﬃcient veriﬁcation and distributes the deposit according to the veriﬁcation’s result.

Very recently, Eckey et al. [27] propose OPTISWAP that improves FairSwap’s performance. It also ensures
a malicious seller cannot force the buyer to submit a large transaction to the blockchain, which ultimately
imposes transaction costs to the buyer, i.e., the grieving attack. Similar to FairSwap, OPTISWAP uses
a smart contract and proof of misbehaviour. Nevertheless, to achieve a better eﬃciency (than FairSwap),
OPTISWAP uses an interactive dispute resolution protocol, previously proposed and used in [40]. The
interactive phase is a challenge-response procedure between the two parties and lets an honest buyer eﬃciently
generate proof of misbehaviour. After computing the proof, the buyer sends it to the contract which veriﬁes
the proof and distributes the deposit according to the veriﬁcation result. To prevent the grieving attack, the
protocol requires the seller to deposit coins to the contract as well, which allows the contract to compensate
an honest buyer which reports the seller’s misbehaviour.

We highlight that the protocols in [26,27,60] have been designed and are suitable for a fair exchange of
digital items, e.g., ﬁle, and digital coins. Nevertheless, they are not suitable for veriﬁable services, e.g., PoR.
If they are directly used for veriﬁable services, then they would suﬀer from the two issues we stated in Section
4 (i.e., a malicious client can waste an honest server’s resources and lack of privacy). For instance, if they
are naively used for PoR, then a malicious client (as a buyer) can simply avoid engaging in the payment
protocol with the server (as a seller), even though the server has honestly maintained the buyer’s data. This
means the client can waste the server’s resources. This issue would not be fully addressed by simply forcing
the client to deposit coins at the point where it outsources its data. Because, the client can encode its data
in a way that makes the server compute an invalid proof, that ultimately allows the client to withdraw its

41

deposit and avoid paying the server. Moreover, the amount of deposit leaks non-trivial information about
the secret (or the ﬁle in the PoR context) in real-time to the public.

Very recently, outsourced (fair) PoR schemes that allow a client to delegate the veriﬁcations to a smart
contract have been proposed in [3,25]. The scheme in [3] uses message authentication code (MAC) and
time-lock puzzle that results in low cost in the proof generation and veriﬁcation phases while the one in [25]
is based on polynomial commitment and involves a high number of modular exponentiations that lead to
higher proof generation and veriﬁcation cost than the former scheme. The schemes in [3,25] do not address
the above privacy issue either and rely on a stronger security assumption than the rest of the work studied
in this section, as these two protocols assume the client is fully honest while the rest assume either party
can be corrupt.

B Preliminaries

B.1 Pseudorandom Function

Informally, a pseudorandom function (PRF) is a deterministic function that takes as input a key and some
argument and outputs a value indistinguishable from that of a truly random function with the same domain
and range. Pseudorandom functions have many applications in cryptography as they provide an eﬃcient and
deterministic way to turn input into a value that looks random. Below, we restate the formal deﬁnition of
PRF, taken from [41].

Deﬁnition 16. Let W : {0, 1}ψ × {0, 1}η → {0, 1}ι be an eﬃcient keyed function. It is said W is a pseudo-
random function if for all probabilistic polynomial-time distinguishers B, there is a negligible function, µ(.),
such that:

Pr[BWˆk

(.)(1ψ) = 1] − Pr[Bω(.)(1ψ) = 1]

≤ µ(ψ)

where the key, ˆk $← {0, 1}ψ, is chosen uniformly at random and ω is chosen uniformly at random from the
set of functions mapping η-bit strings to ι-bit strings.

(cid:12)
(cid:12)
(cid:12)
(cid:12)

(cid:12)
(cid:12)
(cid:12)
(cid:12)

B.2 Commitment Scheme

A commitment scheme involves two parties, sender and receiver, and includes two phases: commit and open.
In the commit phase, the sender commits to a message: x as Com(x, r) = Comx, that involves a secret value:
r $← {0, 1}λ. In the end of the commit phase, the commitment Comx is sent to the receiver. In the open phase,
the sender sends the opening ¨x := (x, r) to the receiver who veriﬁes its correctness: Ver(Comx, ¨x) ?= 1 and
accepts if the output is 1. A commitment scheme must satisfy two properties: (a) hiding: it is infeasible for an
adversary (i.e., the receiver) to learn any information about the committed message x, until the commitment
Comx is opened, and (b) binding: it is infeasible for an adversary (i.e., the sender) to open a commitment
Comx to diﬀerent values ¨x′ := (x′, r′) than that was used in the commit phase, i.e., infeasible to ﬁnd ¨x′, s.t.
Ver(Comx, ¨x) = Ver(Comx, ¨x′) = 1, where ¨x 6= ¨x′. There exist eﬃcient non-interactive commitment schemes
both in (a) the standard model, e.g., Pedersen scheme [55], and (b) the random oracle model using the
well-known hash-based scheme such that committing is : H(x||r) = Comx and Ver(Comx, ¨x) requires checking:
H(x||r) ?= Comx, where H : {0, 1}∗ → {0, 1}λ is a collision resistant hash function; i.e., the probability to ﬁnd
x and x′ such that H(x) = H(x′) is negligible in the security parameter λ.

B.3 Publicly Veriﬁable Non-interactive Zero-knowledge Proof

In a non-interactive zero-knowledge proof (NIZK), a prover P, given a witness w for some statement x in
an NP language L, wants to convince a veriﬁer V of the validity of x ∈ L. The main security property of
the scheme is Zero-knowledge; meaning, a potentially malicious veriﬁer cannot learn anything beyond the
validity of the statement. The procedure is non-interactive, i.e., P generates a proof π and provides V with

42

π, who accepts (or rejects) veriﬁcation. A NIZK is publicly veriﬁable when any party by obtaining π can
verify the validity of x ∈ L. Publicly veriﬁable NIZKs have been constructed under trust assumptions such
as the presence of a common reference string, or setup assumptions such as the existence of a random oracle
which is used in this work. For a formal deﬁnition of NIZKs we refer the reader to [33].

B.4 Symmetric-key Encryption Scheme

A symmetric-key encryption scheme consists of three algorithms (SKE.keyGen, Enc, Dec), deﬁned as follows.
(1) SKE.keyGen(1λ) → k is a probabilistic algorithm that outputs a symmetric key k. (2) Enc(k, m) → c takes
as input k and a message m in some message space and outputs a ciphertext c. (3) Enc(k, c) → m takes as
input k and a ciphertext c and outputs a message m.

The correctness requirement is that for all messages m in the message space, it holds that

h

Pr

Dec(k, Enc(k, m)) = m : SKE.keyGen(1λ) → k
The symmetric-key encryption scheme satisﬁes indistinguishability against chosen-plaintext attacks (IND-
CPA), if any probabilistic polynomial time (PPT) adversary A has no more than 1
2 + negl(λ) probability in
winning the following game: the challenger generates a symmetric key SKE.keyGen(1λ) → k . The adversary
A is given access to an encryption oracle Enc(k, ·) and eventually sends to the challenger a pair of messages
m0, m1 of equal length. In turn, the challenger chooses a random bit b and provides A with a ciphertext
Enc(k, mb) → cb. Upon receiving cb, A continues to have access to Enc(k, ·) and wins if its guess b′ is equal
to b.

= 1.

i

B.5 Digital Signature Scheme

A digital signature is a scheme for verifying the authenticity of digital messages. It involves three algo-
rithms, (Sig.keyGen, Sig.sign, Sig.ver), deﬁned as follows. (1) Sig.keyGen(1λ) → (sk, pk) is probabilistic
algorithm run by a signer that outputs a key pair (sk, pk), consisting of secret key sk, and public key pk. (2)
Sig.sign(sk, pk, u) → sig is an algorithm run by the signer. It takes as input key pair (sk, pk) and a message
u. It outputs a signature sig. (3) Sig.ver(pk, u, sig) → h ∈ {0, 1} is an algorithm run by a veriﬁer. It takes
as input public key pk, message u, and signature sig. It checks the signature’s validity. If the veriﬁcation
passes, then it outputs 1; otherwise, it outputs 0.

A digital signature scheme should meet two properties. (1) Correctness: for every input u it holds that:
Sig.ver(pk, u, Sig.sign(sk, pk, u)) = 1 :

Pr

h

Sig.keyGen(1λ) → (sk, pk)

= 1

(2) Existential unforgeability under chosen message attacks (EUF-CMA): a probabilistic polynomial time
PPT adversary that obtains pk and has access to a signing oracle for messages of its choice, cannot create a
valid pair (u∗, sig∗) for a new message u∗, except with a negligible probability, σ. For a formal deﬁnition of
digital signatures, we refer readers to [42].

i

B.6 Merkle Tree

In the setting where a Merkle tree is used to remotely check a ﬁle, the ﬁle is split into blocks and the tree is
built on top of the ﬁle blocks. Usually, for the sake of simplicity, it is assumed the number of blocks, m, is
a power of 2. The height of the tree, constructed on m blocks, is log2(m). The Merkle tree scheme includes
three algorithms (MT.genTree, MT.prove, MT.verify) as follows:

• The algorithm that constructs a Merkle tree, MT.genTree, is run by V. It takes ﬁle blocks, u := u1, ..., um,
as input. Then, it groups the blocks in pairs. Next, a collision-resistant hash function, H(.), is used to
hash each pair. After that, the hash values are grouped in pairs and each pair is further hashed, and
this process is repeated until only a single hash value, called “root”, remains. This yields a tree with
the leaves corresponding to the blocks of the input ﬁle and the root corresponding to the last remaining
hash value. V locally stores the root, and sends the ﬁle and tree to P.

43

• The proving algorithm, MT.prove, is run by P. It takes a block index, i, and a tree as inputs. It outputs
a vector proof, of log2(m) elements. The proof asserts the membership of i-th block in the tree, and
consists of all the sibling nodes on a path from the i-th block to the root of the Merkle tree (including
i-th block). The proof is given to V.

• The veriﬁcation algorithm, MT.verify, is run by V. It takes as input i-th block, a proof and tree’s root.
It checks if the i-th block corresponds to the root. If the veriﬁcation passes, it outputs 1; otherwise, it
outputs 0.

The Merkle tree-based scheme has two properties: correctness and security. Informally, the correctness
requires that if both parties run the algorithms correctly, then a proof is always accepted by V. The security
requires that a computationally bounded malicious P cannot convince V into accepting an incorrect proof,
e.g., proof for non-member block. The security relies on the assumption that it is computationally infeasible
to ﬁnd the hash function’s collision.

C Further Discussion on Proof Status Leakage

As we already highlighted, the leakage of proof status (which reveals whether the server is suﬀering from
hardware/software failure) might be problematic in certain circumstances. In Section 4.1, we have described
a case where such leakage could beneﬁt adversaries.

However, this is not the only case. An adversary may directly target business and/or individual clients
by mounting social engineering attacks on them. It can exploit such leakage to increase the chance of success
in its attack. A survey conducted by Kaspersky lab suggests that 33% of attacks that aﬀect business clients
of cloud servers are of type social engineering [44] which is a high rate. Moreover, social engineering attacks
on individuals are still prevalent. In the UK, scammers have been impersonating the Post Oﬃce and sending
“extremely convincing” text messages to the citizens and asking them to use the link provided in the message
to schedule redelivery and pay for the redelivery using the given online form. The attackers would steal
victims’ payment details once they use the form and insert their card details. This message may seem
relevant and convincing to a certain percentage of recipients as they are indeed waiting for parcel delivery.
A survey conducted by a UK-based consumer protection organisation suggests that 61% of surveyed people
had received such a text message [50].

The same scam can be simply adjusted to target users of the cloud servers which are suﬀering a failure.
Given real-time evidence of servers’ failure (that is also known to the clients), an adversary can provide more
convincing evidence to their victims as a part of social engineering. This ultimately increases the adversary’s
chance of success. The adversary can target a large set of people a subset of which is likely to be the cloud’s
clients (akin to the above parcel delivery scam), or it can target speciﬁc cloud clients by using the techniques
used to link the blockchain’s addresses to certain parties [7,13,57].

D Further Discussion of the SAP

In this section, ﬁrst we outline why the SAP satisﬁes all four security properties set out in Section 8.2 and
then discuss why naive solutions are not suitable replacements of the SAP. After that, we highlight that the
SAP’s veriﬁcation phase can be locally performed with low costs.

D.1 SAP’s Security Analysis

Intuitively, the SAP meets Property 1 due to the binding property of the commitment scheme. Property 2
is satisﬁed due to the security of the blockchain and smart contract; namely, due to blockchain’s liveness
property an honestly generated transaction, containing the opening, eventually gets into chains of honest
miners, and due to the security and correctness of smart contracts a valid opening is always accepted by the
contract. Property 3 is met due to the hiding property of the commitment, while Property 4 is satisﬁed due
to the signature scheme’s security.

44

D.2 Unsuitability of Naive Solutions

As a replacement of the SAP, one may let each party sign the statement and send it to the other party, so
later each party can send both signatures to the contract which veriﬁes them. However, this would not work,
as the party who ﬁrst receives the other party’s signature may refuse to send its own signature, that prevents
the other party from proving that it has agreed on the statement with its counter-party, i.e., cannot satisfy
Property 2. Alternatively, one may want to use a protocol for a fair exchange of digital signature (or fair
contract signing) such as those in [16,29]. In this case, after both parties have the other party’s signature,
they can sign the statement themselves and send the two signatures to the contract which ﬁrst checks the
validity of both signatures. Although this satisﬁes the four security requirements, it yields two main eﬃciency
and practical issues; namely, it (a) imposes very high computation costs, as protocols for a fair exchange
of signatures involve generic zero-knowledge proofs and require a high number of modular exponentiations,
and (b) is impractical because protocols for the fair exchange of signatures support only certain signature
schemes (e.g., RSA, Rabin, or Schnorr) that are not directly supported by the most predominant smart
contract framework, Ethereum, that only supports Elliptic Curve Digital Signature Algorithm (EDCSA).

D.3 Oﬀ-chain Veriﬁcation in the SAP

The SAP’s veriﬁcation algorithm can be executed oﬀ-chain. In particular, given statement ¨x, anyone can read
(gC, gS, adrC, adrS) from the SAP smart contract and locally run SAP.verify(¨x, gC, gS, adrC, adrS) to check
the statement’s correctness. This relieves the veriﬁer from the transaction and smart contract’s execution
costs.

E RC-PoR-P’s Correctness

In this section, we brieﬂy discuss why the correctness of the RC-PoR-P protocol holds, w.r.t. Deﬁnition 11.
Recall, correctness requires that S accepts an honest C’s encoded data and query while honest C accepts S’s
valid service proof. Also, honest C gets back all its deposited coins minus the service payment, the honest
S gets back all its deposited coins plus the service payment and the arbiter receives nothing. In short, this
protocol’s correctness holds dues to the correctness of PoR, symmetric key encryption, SAP, and smart
contract. Below, we elaborate on that:

1. due to the correctness of smart contracts, any message sent by a party (i.e., C or S) to a contract is kept

intact by the contract.

2. due to the correctness of symmetric key encryption, the encrypted messages sent by a party to another

one can be correctly decrypted by its counterparty who knows the correct key.

3. due to points 1 and 2 above, an encrypted message sent to a contract by a party can be correctly

decrypted by its counterparty who knows the correct key.

4. due to the correctness of the underlying PoR scheme, proofs generated by honest S are always accepted
by honest C. Also, for the same reason, a query generated by honest C is always accepted by honest S.

5. due to points 1-4, the counters remain 0, i.e., yS = yC = y′
6. due to the correctness of SAP and point 1, a private statement’s proof (e.g., ¨xcp ∈ Tcp) sent by an honest

S = y′

C = 0.

C or S will always be accepted by the smart contract.

Therefore, C receives coinC = coin∗

C − o · z coins, S receives coinS = coin∗

S + o · z, and arbiter receives 0

coins.

F Proof of Theorem 3

This section contains the security analysis of the RC-PoR-P consrtuction presented in Section 8. First, we
prove the security of the PoR scheme in Subsection 8.1 in the following lemma.

45

Lemma 5. Let ǫ be non-negligible in the security paramenter λ. Then, the PoR scheme presented in Sub-
section 8.1 is ǫ-sound w.r.t. Deﬁnition 1, if the underlying Merkle tree and pseudorandom function PRF are
secure.

Proof. As stated above, the proposed PoR diﬀers from the standard Merkle tree-based PoR from a couple
of perspectives. However, the changes do not aﬀect the security and soundness of the proposed PoR. Its
security proof is similar to the existing Merkle tree-based PoR schemes, e.g., [35,39,52]. Alternatively, our
protocol can be proven based on the security analysis of the PoR schemes that use MACs or BLS signatures,
e.g., [58]. In this case, the extractor design (in the Merkle tree-based PoR) would be simpler because it does
not need to extract blocks from a linear combination of MACs or signatures, as the blocks are included in
proofs, i.e., they are part of the Merkle tree proofs. Intuitively, in either case, the extractor interacts with
any adversarial prover that passes a non-negligible ǫ fraction of audits. It initialises an empty array. Then
it challenges a subset of ﬁle blocks and asks the prover to generate a proof. If the received proof passes
the veriﬁcation, then it adds the related block (in the proof) to the array. It then rewinds the prover and
challenges a fresh set of blocks, and repeats the process many times. Since the prover has a good chance of
passing the audit, it is easy to show that the extractor can eventually extract a large fraction of the entire
ﬁle, as it is shown in [58]. Due to the security of the Merkle tree, the retrieved values are the valid and correct
ﬁle blocks and due to the security of the pseudorandom function, the challenges (or the function’s outputs)
are not predictable. After collecting a suﬃcient number of blocks, the extractor can use the error-correcting
code to decode and recover the entire ﬁle blocks, given the retrieved ones.

By applying Lemma 5, we prove the main theorem of Section 8.

Theorem 3. The RC-PoR-P scheme with functions FPoR, MPoR, EPoR, DPoR, QPoR described in Subsections 8.1
and 8.2 is secure (cf. Deﬁnition 15), if the underlying Merkle tree, pseudorandom function, commitment
scheme, digital signature scheme are secure, and the underlying symmetric-key encryption scheme is IND-
CPA secure.

Proof. We show that the RC-PoR-P scheme meets all security properties deﬁned in Section 7.1 by proving
a series of claims. First, we recall that coinP,j denotes the coins that are credited to the party P ∈ {C, S, R}
for the j-th veriﬁcation and hj is a value included in the decoded proof πj that should match FPoR(u∗, ˆkj, pp).
In addition, yC,j = 1 (resp. yS,j = 1) if C (resp. S) misbehaved in the j-th billing cycle, and y′
C,j = 1 (resp.
y′
S,j = 1) if C (resp. S) has provided a complaint that does not allow R to identify a misbehaved party in
the j-th veriﬁcation .

Claim. The RC-PoR-P scheme with functions FPoR, MPoR, EPoR, DPoR, QPoR is secure against a malicious server
(cf. Deﬁnition 12), if the SAP and signature scheme are secure, and the PoR scheme satisﬁes correctness and
soundness.

Proof of Claim F. First, we consider event

FPoR(u∗, ˆkj, pp) = hj ∧

(coinC,j 6= coin∗

C

z − o) ∨ (coinR,j 6=

(cid:17)(cid:17)

S,j = 1)

that captures the case where the server provides an accepting proof, but makes an honest

l ∧ y′
client withdraw an incorrect amount of coins, i.e., coinC,j 6= coin∗
z − o, or makes the arbiter withdraw an
incorrect amount of coins, i.e., coinR,j 6= l, if it unnecessarily invokes the arbiter. Because the proof is valid,
an honest client accepts it and does not raise a dispute. However, the server could make the client withdraw
incorrect amount of coins, if it manages to

C

(cid:16)

(cid:16)

1. either convince the arbiter that the client has misbehaved, by making the arbiter output yC,j = 1 through

the dispute resolution phase, or
2. submit an accepting statement ¨x′

cp to SC which is other than what was agreed in the initiation phase,

i.e., ¨x′

cp 6= ¨xcp, so it can change the payments’ parameters, or

3. send a message on the client’s behalf to unnecessarily invoke the arbiter.

46

In any of the above cases, the server cannot falsely accuse the client of misbehaviour; due to the binding
property of the SAP commitment scheme, it cannot convince the arbiter to accept a diﬀerent decryption
key (that will be used to decrypt queries) other than what was agreed with the client in the SAP initiation
phase. In particular, it cannot persuade the arbiter to accept ¨x′
qp 6= ¨xqp, except with negl(λ)
probability. This ensures that the honest client’s queries are accessed by the arbiter with a high probability.
Furthermore, if the adversary provides a valid statement, i.e., ¨xqp, then due to the correctness of the PoR
and query-checking process (speciﬁed in step 5b), no one is identiﬁed as a misbehaving party in the dispute
resolution phase, i.e., so we would have Ij = ⊥. Therefore, due to the binding property of SAP and correctness
of PoR and query-checking process, the following holds yC,j = yS,j = 0.

qp, where ¨x′

Moreover, due to the binding property of the SAP commitment scheme, the server cannot change the
payment parameters by convincing the contract to accept any statement ¨x′
cp other than what was agreed
initially between the client and server, except with negl(λ) probability. Also, due to the signature’s security,
the adversary cannot send a message on behalf of the client to unnecessarily invoke the arbiter and make
it output y′
C,j = 0. Recall,
in RC-PoR-P or RC-S-P protocol, according to Equation (1), the amount of coins that should be credited
to the client for the j-th veriﬁcation is coinC,j = coin∗
C,j). Since it holds that
yC,j = yS,j = y′

C,j = 1, except with negl(λ) probability; so with high probability, it holds that y′

z − o coins for the j-th veriﬁcation, with high probability.

C,j = 0, the client is credited coin∗

z − o · (1 − yS,j) − l · (yC,j + y′

C

C

As stated above, if the adversary invokes the arbiter, the arbiter with a high probability outputs Ij = ⊥
that yields y′
S,j = 1. In RC-PoR-P or RC-S-P protocol, according to Equation 2, the amount of coins the
arbiter should be credited for j-th veriﬁcation is coinR,j = l · (yS,j + yC,j + y′
C,j). As shown above
yC,j = yS,j = y′
S,j = 1, which means l coins is credited to the arbiter for the j-th veriﬁcation if
it is unnecessarily invoked by the adversary. In this case, for the server to make the arbiter withdraw other
than this amount, it has to send to SC (in the coin transfer phase) an accepting statement ¨x′
cp other than
what was agreed in the initiation phase, i.e., ¨x′
cp 6= ¨xcp, so it can change the payments’ parameters. However,
as stated above, it cannot succeed with a probability signiﬁcantly greater than negl(λ).

C,j = 0 and y′

S,j + y′

C

C

z

z

(cid:17)

(cid:16)(cid:16)

∨ coinR,j 6= l

We now study the event

FPoR(u∗, ˆkj, pp) 6= hj

dj = 1 ∨ yS,j = 0 ∨ coinC,j 6= coin∗
(cid:16)

∧
which captures the case where the server provides an invalid proof and it either convinces the client to accept
(cid:17)(cid:17)
the proof, or persuades the arbiter to accept it or makes the client or arbiter withdraw incorrect amount of
coins, i.e., coinC,j 6= coin∗
or coinR,j 6= l respectively. Due to the security of the Merkle tree and soundness of
PoR (Lemma 5), the probability that the adversary can convince an honest client to accept invalid proof is
negl(λ) and the ﬁle is extractable within a polynomial number of interactions with a ǫ-admissible adversary.
Therefore, the client outputs dj = 0 with a high probability and raises a dispute. Furthermore, the server
may try to make the arbiter keep yS,j = 0. For the adversary to succeed, it has to convince the arbiter that
the client has misbehaved, and output yC,j = 1. In this case, according to RC-PoR-P protocol, the client’s
complaint (for the j-th veriﬁcation) would not be processed by the arbiter. This allows yS,j to remain 0.
However, as we argued in the study of the previous event, the probability that the adversary makes the
arbiter recognise the client as misbehaving is negl(λ). So, with high probability yS,j = 1 and yC,j = 0,
after the arbiter is invoked by the client or server. It also holds that y′
S,j = 0, because the arbiter has
already identiﬁed a misbehaving party; speciﬁcally, recall if a malicious server invokes the arbiter, the arbiter
discards its complaint without carrying out any investigation/computation as a malicious party has already
been identiﬁed, thus y′
S,j remains 0. Moreover, due to SAP’s security, the probability that the adversary
succeeds in changing the payment parameters to make the client or arbiter withdraw an incorrect amount of
coins is negl(λ) too. So, according to Equations (1) and 2 the client and arbiter are credited coin∗
and l coins
for the j-th veriﬁcation respectively. Also, due to the security of SAP (i.e., after the parties agree on the
statement, an honest party can almost always prove to the veriﬁer that it has the agreement), the adversary
cannot block an honest client’s messages, “pay” and ¨xcp, to the contract in the coin transfer phase.
⊣

C,j = y′

z

C

Claim. The RC-PoR-P scheme with functions FPoR, MPoR, EPoR, DPoR, QPoR is secure against a malicious client
(cf. Deﬁnition 13), if SAP and signature scheme are secure and PoRID scheme supports correctness, inputs
well-formedness, and detectable abort.

47

Proof of Claim F. We ﬁrst consider event
coin∗
S

z + o) ∨ (coinR,j 6= l ∧ y′

C,j = 1)

(cid:16)(cid:16)

M (u∗, k, pp) = σ ∧ Q(aux, k, pp) = qj

∧

(coinS,j 6=

. It captures the case where the client provides accepting metadata

(cid:17)

(cid:16)

S

(cid:17)(cid:17)

(i.e., a Merkle tree and its root) and query but makes the server withdraw incorrect amounts of coin,
i.e., coinS,j 6= coin∗
z + o, or makes the arbiter withdraw incorrect amounts of coin, i.e. coinR,j 6= l, if it
unnecessarily invokes the arbiter. Since the metadata and queries are valid and correctly structured, an
honest server accepts them and does not raise a dispute, so yC,j = 0. However, the client could make the
server withdraw an incorrect amount of coins if it manages to either persuade the arbiter to recognise the
server as misbehaving, i.e., makes the arbiter output yS,j = 1, or submit to the contract an accepting
statement ¨x′
cp other than what was agreed at the initiation phase, i.e., ¨xcp or send a message on the client’s
behalf to unnecessarily invoke the arbiter. Nevertheless, it cannot falsely accuse the server of misbehaviour.
Because, due to SAP’s security, it cannot convince the arbiter to accept diﬀerent decryption key and pads’
detail, by providing a diﬀerent accepting statement ¨x′
qp 6= ¨xqp), than what was initially agreed
with the server, except with a negligible probability, µ(λ). This ensures the arbiter is given the honest server’s
messages, with a high probability. Therefore, with a high probability yS,j = 0.

qp (where ¨x′

Also, if the adversary provides a valid statement, i.e., ¨xqp, then due to the correctness of the PoR and
query-checking process (explained in step 5b), we would have Ij = ⊥. So, due to the security of SAP and
correctness of the PoR and query-checking process the following holds yC,j = yS,j = 0 with a high probability.
Moreover, it holds that y′
S = 0 because the honest server never invokes the arbiter when the client’s queries
are well-structured and due to the signature scheme’s security, the client cannot send a message on the
server’s behalf to unnecessarily invoke the arbiter. Note, due to SAP’s security, the client cannot change the
payment parameters by convincing the contract to accept any statement ¨x′
cp other than what was initially
agreed between the client and server (i.e., ¨x′
cp 6= ¨xcp) except with a negligible probability, µ(λ). Recall,
according to Equation 3, in RC-PoR-P or RC-S-P protocol, the total coins the server should be credited for
j-th veriﬁcation is coinS,j = coin∗
S,j = 0, the
server is credited coin∗
z + o coins for the j-th veriﬁcation, with a high probability. Furthermore, as stated
above, if the adversary invokes the arbiter, the arbiter with a high probability outputs Ij = ⊥ which yields
y′
C,j = 1. Hence, according to Equation 2, the arbiter for the j-th veriﬁcation is credited l coins, with a high
probability. As previously stated, due to the security of SAP, the client cannot make the arbiter withdraw
incorrect coin amounts by changing the payment parameters and persuading the contract to accept any
statement ¨x′
cp other than what was agreed initially between the client and server, except with a negligible
probability µ(λ). We now turn our attention to
which captures the case where
the server accepts ill-formed metadata. But, due to the security of the Merkle tree scheme, the probability
the event happens is negligible, µ(λ); therefore, with a high probability a = 0. In this case, the server does
not raise any dispute, instead it avoids serving the client.

z + o · (1 − yS,j) − l · (yS,j + y′

S,j). Therefore, given yS,j = y′

M (u∗, k, pp) 6= σ ∧ a = 1

(cid:17)

(cid:16)

S

S

S

Next, we move on to

(Q(aux, k, pp) 6= qj) ∧ (bj = 1 ∨ yC,j = 0 ∨ coinS,j 6= coin∗
z + o ∨ coinR,j 6= l)
which
considers the case where the client provides an invalid query, but either convinces the server or arbiter to
(cid:16)
(cid:17)
accept it, or makes the server or arbiter withdraw an incorrect amount of coins, i.e., coinS,j 6= coin∗
z + o or
S
coinR,j 6= l respectively. Due to the correctness of the query-checking process, the probability that the server
outputs bj = 1 is 0. Note, when the honest server rejects the query and raises a dispute, the arbiter checks the
query and sets yC,j = 1. After that, due to RC-PoR-P design, the client cannot make the arbiter set yC,j = 0
(unless it manages to modify the blockchain’s content later on, but its probability of success is negligible
due to the security of blockchain). As already stated, the client cannot make the arbiter recognise the honest
server as a misbehaving party with a probability signiﬁcantly greater than µ(λ). That means, with a high
probability yS,j = 0. Furthermore, since the arbiter has identiﬁed a misbehaving party, the following holds
y′
C,j = y′
S,j = 0. The adversary may still try to make them withdraw incorrect amounts of coin. To this end,
in the coin transfer phase, it has to send a diﬀerent accepting statement than what was initially agreed with
the server. But, due to SAP’s security, its success probability is µ(λ). Hence, according to Equations 3 and
2 the server and arbiter are credited coin∗
z + o and l coins respectively for the j-th veriﬁcation, with a high

S

48

probability. Furthermore, due to SAP’s security, the adversary cannot block an honest server’s messages,
“pay” and ¨xcp, to the contract in the coin transfer phase.
⊣

Claim. The RC-PoR-P scheme with functions FPoR, MPoR, EPoR, DPoR, QPoR preserves privacy (cf. Deﬁnition 14),
if SAP is secure and the symmetric-key encryption scheme is IND-CPA secure.

C and coin∗

Proof of Claim F. Brieﬂy, due to SAP’s privacy property, given commitments gqp and gcp (stored in the
blockchain as a result of running SAP) the adversary learns no information about the committed values
(e.g. o, l, padπ and ¯k), except with negligible probability µ(λ). Moreover, given price list pl, and the parties’
encoded coins coin∗
S, the adversary learns nothing about the actual price agreed between the server
and client, i.e., (o, l), for each veriﬁcation, due to Lemma 3. Also, since each proof π∗
j is encrypted and then
padded, given π∗
j is associated with u0 or with u1 (i.e., where u0 and
u1 are the adversary’s choice of ﬁles), with probability signiﬁcantly greater than 1
j is an
output of semantically secure symmetric-key encryption and its size is ﬁxed, it leaks noting to the adversary.
The value of a is also independent of u0 or u1, and only depends on whether the metadata is well-formed,
so it leaks nothing about the choice of input ﬁle uβ and β ∈ {0, 1}. Hence, the adversary cannot tell with a
probability signiﬁcantly greater than 1

2 + µ(λ) which ﬁle of its choice has been used as the server input.

j the adversary cannot tell whether π∗

2 + µ(λ). As each ˆk∗

Also, in the experiment, an invalid query-proof pair is computed with probability P r0 and a valid query-
proof pair is generated with probability P r1. We know each encoded query-proof pair c∗
j ∈ c∗ has a ﬁxed size
and contains random elements of U . It is also assumed that for each j-th veriﬁcation, an encoded query-proof
is always provided to the contract. So, each encoded pair leaks nothing, not even the query’s status to the
adversary; which means given only a vector of c∗
j , the adversary can learn a query-proof’s status with a
probability at most P r′ +µ(λ), where P r′ = M ax(P r0, P r1). Furthermore, each padded encrypted proof leak
no information and always contain a ﬁxed number of elements. Thus, for the adversary to the tell the status
of proof for each j-th veriﬁcation it has to learn information from ˆk∗
C, gcp, gqp, π∗, pl, and a but
its success probability is at most µ(λ) or correctly guess a query’s status but it has at most P r′ probability
of success; this means it cannot tell a proof’s status with a probability signiﬁcantly greater than P r′ +µ(λ). ⊣

j , coin∗

S, coin∗

The security of the construction follows from Claims F, F, and F.

G RC-PoR-P Without Arbiter’s Involvement

In the RC-PoR protocol, due to the eﬃciency of the arbiter-side algorithm, i.e., RCSPoR.resolve(·), we can
delegate the arbiter’s role to the smart contract, SC. In this case, the involvement of the third-party arbiter
is not needed anymore. However, to have the new variant of RC-PoR-P, some adjustments need to be applied
to the original RC-PoR-P’s protocol and deﬁnition, primarily from two perspectives. First, the way a party
pays to resolve a dispute would change, that ultimately aﬀects the amount of coins each party receives in the
coin distribution phase. Recall, in the RC-PoR-P and RC-S-P (presented in sections 8.2 and 7.3 respectively)
the party which raises a dispute does not pay the arbiter when it sends to it the dispute query. Instead,
loosely speaking, the arbiter in the coin distribution phase is paid by a misbehaving party. In contrast, when
the arbiter’s role is played by a smart contract, the party which raises a dispute and sends the dispute query
to the contract (due to the nature of the smart contracts’ platform) has to pay the contract before the
contract processes its query. This means an honest party which sends a complaint to the contract needs to
be compensated (by the corrupt party) for the amounts of coin it sent to the contract to resolve the dispute.
Therefore, the amount of coins each party receives in the coin distribution phase would change, compare to
the original RC-PoR-P protocol. Second, there would be no need to keep track of the number of times a party
unnecessarily raises a dispute, as it pays the contract when it sends a query, before the contract processes its
claim. In Appendix G.1, we provide a generic deﬁnition for RC-S-P for the case where the arbiter’s role can
be played by a smart contract. The generic deﬁnition also captures the new variant of RC-PoR-P. Moreover,
in Appendix G.2, we elaborate on how the new variant of RC-PoR-P can be constructed and we prove its
security.

49

G.1 Deﬁnition of RC-S-P Without Arbiter’s Involvement

There are cases, in RC-S-P schemes, where the third party arbiter’s role can be eﬃciently delegated to a
smart contract. In this variant of the RC-S-P scheme, denoted by RC-S-P, the arbiter’s involvement is not
needed anymore. The primary diﬀerence between RC-S-P and RC-S-P is the way a party pays to resolve a
dispute. In particular, in RC-S-P, the party which raises a dispute does not pay the arbiter when it sends to
it a dispute query. Instead, loosely speaking, the arbiter at coin distribution is paid by a misbehaving party.
Whereas, in RC-S-P, the party which raises a dispute and sends a dispute query to the contract, (due to
the nature of the smart contracts’ platform) has to pay the contract, before the contract processes its query.
In this section, we show how the RC-S-P deﬁnition (presented in Section 7.1) can be adjusted to capture
RC-S-P. In the following, we highlight the main changes that should be applied to the RC-S-P deﬁnition.

• In Deﬁnition 10:

• Three parties are involved; namely, client, server, and smart contract (so an arbiter is not involved

anymore).
• Vectors y′

C and y′

S are not needed anymore. Because a misbehaving party, which unnecessarily invokes
the contract, pays the contract ahead of time. Therefore, there is no need to keep track of unnecessary
contract’s invocation.

• RCSP.resolve(·) is run by a smart contract.
• RCSP.pay(·) outputs (coinC, coinS), so coinR is excluded from the output, as a third party arbiter

plays no role anymore.

• In Deﬁnition 11: only the above changes are applied to it.
• In Deﬁnition 12: the above changes are applied to the algorithms’ syntax in the experiment. Moreover,
the events are slightly modiﬁed, i.e. the amount of coins each party receives. For the sake of clarity and
completeness, we state the entire modiﬁed deﬁnition below.

Deﬁnition 17 (RC-S-P Security Against Malicious Server). An RC-S-P scheme with functions
F, M, E, D, Q is secure against a malicious server for an auxiliary information aux, if for any z polynomial
in λ, any price list pl, every j (where 1 ≤ j ≤ z), and any PPT adversary A, the following probability is
negl(λ):

j , σ, u∗, a) → (bj, mS,j, h∗
j , c∗

RCSP.keyGen(1λ, ) → k
A(1λ, pk, F, M, E, D, Q) → u
RCSP.cInit(1λ, u, k, z, pl) → (u∗, e, T, pS, y, coin∗
C)
A(u∗, e, pk, z, T, pS, y) → (coin∗
S , a)
RCSP.genQuery(1λ, aux, k, Tqp) → c∗
A(c∗
RCSP.verify(π∗
RCSP.resolve(mC, mS, z, π∗, c∗, pk, Tqp) → y
RCSP.pay(y, Tcp, a, pS, coin∗
(cid:16)F (u∗, qj, pp) = hj ∧ (coinC,j 6= coin∗
(cid:16)F (u∗, qj, pp) 6= hj ∧
(dj = 1 ∨ yS,j = 0 ∨ coinC,j 6= coin∗

j , k, Tqp) → (dj, mC,j)

z − o)(cid:17) ∨

C, coin∗

j , δ∗
j )

C

C

j

z + l)(cid:17)

S ) → (coinC, coinS)



Pr





















j := (h∗
























where qj ∈ D(c∗
pp ∈ Tqp.

j , tqp), π∗

j , δ∗

j ), hj = D(h∗

j , Tqp), σ ∈ e, mC,j ∈ mC, mS,j ∈ mS, yS,j ∈ yS ∈ y, and

• In Deﬁnition 13: similar to the previous point, only the algorithms’ syntax (in the experiment) and the

amount of coins each party receives changes. Below, we state the entire modiﬁed deﬁnition.

Deﬁnition 18 (RC-S-P Security Against Malicious Client). An RC-S-P scheme wih functions
F, M, E, D, Q is secure against a malicious client for an auxiliary information aux, if for any z polynomial
in λ, every j (where 1 ≤ j ≤ z), and any PPT adversary A, the following probability is negl(λ):

50

C, enc, aux,

j

S , a)

j , qj, k, Tqp) → (dj, mS,j)

S , a, 1λ, aux, k, Tqp) → c∗

j , pk, Tqp) → (bj, mS,j, π∗
j )

A(1λ, F, M, E, Q, D) → (u∗, z, k, e, T, pl, pS, coin∗
y, enc, pk)
RCSP.sInit(u∗, e, pk, z, T, pS, y) → (coin∗
A(coin∗
RCSP.prove(u∗, σ, c∗
A(π∗
RCSP.resolve(mC, mS, z, π∗, c∗, pk, Tqp) → y
RCSP.pay(y, Tcp, a, pS, coin∗
(cid:16)(M (u∗, k, pp) = σ ∧ Q(aux, k, pp) = qj) ∧
(coinS,j 6= coin∗
(cid:16)M (u∗, k, pp) 6= σ ∧ a = 1(cid:17) ∨
(cid:16)Q(aux, k, pp) 6= qj ∧
(bj = 1 ∨ yC,j = 0 ∨ coinS,j 6=

z + o)(cid:17) ∨

C , coin∗

coin∗
S

S

z + o + l)(cid:17)

S ) → (coinC, coinS)



























Pr



























where qj ∈ D(c∗

j , tqp), D ∈ enc, σ ∈ e, yC,j ∈ yC ∈ y, and pp ∈ Tqp.

Note that Deﬁnition 14 remains almost the same with a minor change, that is vectors (y′

C, y′

S) are excluded

from the related algorithms input/output.

Deﬁnition 19. An RC-S-P scheme is secure if it satisﬁes security against malicious server, security against
malicious client, and preserves privacy (cf. . Deﬁnitions 17,18, and 14).

G.2 Protocol For RC-PoR-P Without Arbiter’s Involvement

In this section, we elaborate on how the original recurring contingent PoR payment (RC-PoR-P) protocol,
presented in Section 8.2, can be adjusted such that the third party arbiter’s role, i.e., resolving disputes, is
totally delegated to the smart contract, SC. The new variant is denoted by RC-PoR-P. Brieﬂy, Phases 1-6
remain unchanged, with an exception. Namely, in step 2d, only two counters yC and yS are created, instead
of four counters; accordingly, in the same step, vector y is now y : [yC, yS, adrSC], so counters y′
S are
excluded from the vector. At a high level, the changes applied to phase 7 are as follows: the parties send
their complaints to SC now, SC does not maintain y′
S anymore, SC takes the related steps (on the
arbiter’s behalf), and it reads its internal state any time it needs to read data already stored on the contract.
Moreover, the main adjustment to phase 8 is that the amounts of coin each party receives changes. For the
sake of clarity, we present the modiﬁed version of phases 7 and 8, below.

C and y′

C and y′

7. Dispute Resolution. RCPoRP.resolve(mC, mS, z, π∗, q∗, Tqp)

The phase takes place only in case of dispute, i.e., when C rejects service proofs or S rejects the queries.
(a) S sends mS and ¨xqp to SC, at time K1, where K1 > Gz,2 + J
(b) SC upon receiving mS does the following a time K2.

i. Checks the validity of statement ¨xqp, by sending it to the SAP contract which returns 1 or 0. If
the output is 0, then SC discards the server’s complaint, mS, and does not take steps 7(c)ii and
7(c)iii. Otherwise, it proceeds to the next step.

ii. Removes from vS any element that is duplicated or not in the range [1, z]. It also constructs an

empty vector v.

iii. For any element i ∈ vS:

• Fetches the related encrypted query ˆk∗
• Checks if the query is well-formed, by doing the same checks performed in step 5b (of the

i ∈ q∗, and decrypts it, ˆki = Dec(¯k, ˆk∗

i ).

RC-PoR-P). If the query is rejected, then it increments yC by 1 and appends i to v.

Let K3 be the time SC ﬁnishes the above checks.

(c) C sends mC and ¨xqp to SC, at time K4.
(d) SC upon receiving mC, does the following at time K5.

51

i. Checks the validity of statement ¨xqp, by sending ¨xqp to the SAP contract which returns either
1 or 0. If the output is 0, then SC discards the client’s complaint, mC, and does not take steps
7(e)ii-7(e)iii. Otherwise, it proceeds to the next step.

ii. Ensures each vector m ∈ mC is well-formed. In particular, it veriﬁes there exist no two vectors:
m, m′ ∈ mC such that m[0] = m′[0]. If such vectors exist, it deletes the redundant ones from
mC. This ensures no two claims refer to the same veriﬁcation. Also, it removes any vector m from
mC if m[0] is not in the range [1, z] or if m[0] ∈ v. Note the latter check (i.e., m[0] ∈ v) ensures
C cannot hold S accountable if C has generated an ill-formed query for the same veriﬁcation.

iii. For every vector m ∈ mC:

A. retrieves a rejected proof’s details by setting j = m[0] and g = m[1]. Recall that g refers to
the index of a rejected proof in the proof vector which was generated for j-th veriﬁcation,
i.e., πj.

B. fetches the related encrypted query c∗

removes the pads only from g-th padded encrypted proof. Let π′
decrypts the encrypted proof, Dec(¯k, π′
C. identiﬁes the misbehaving party as follows.

j[g])) = πj[g].

j ∈ c∗ from SC and decrypts it as ˆkj = Dec(¯k, c∗

j ). It
j[g] be the result. Next, it

• veriﬁes ˆkj by doing the same checks done in step 5b (of the RC-PoR-P). If the checks do
not pass, it sets Ij = C and skips the next two steps; otherwise, it proceeds to the next
step.

• derives the related challenged block’s index from ˆkj, by computing qg =

PRF(ˆkj, g) mod

• veriﬁes only g-th proof, by calling PoR.verify(πj[g], qg, pp) → d′. If d′[0] = 0, then it sets

(cid:0)

m

+ 1.

(cid:1)

Ij = S. Otherwise, it outputs Ij = ⊥.

• if Ij = C, it increments yC by 1. If Ij = S, it increments yS by 1.

Let K6 be the time that SC ﬁnishes all the above checks.

8. Coin Transfer. RCPoRP.pay(y, Tcp, a, pS, coin∗

C, coin∗
S)

(a) If SC receives “pay” message at time T2, where a = 0 or coins∗

S < pS, then it sends coin∗

C coins to C

and coin∗

S coins to S. Otherwise (i.e., they reach an agreement), they take the following step.

(b) Either C or S sends “pay” message and statement ¨xcp ∈ Tcp to SC at time L > K6.
(c) SC checks the validity of the statement by sending it to the SAP contract that returns either 1 or 0.

SC only proceeds to the next step if the output is 1.

(d) SC distributes the coins to the parties as follows:
C − o · (z − yS) + l · (yS − yC) coins to C.
S + o · (z − yS) + l · (yC − yS) coins to S.

• coin∗
• coin∗

Theorem 4. The RC-PoR-P protocol is secure, w.r.t. Deﬁnition 19, if PoRID, SAP, and blockchain are
secure and the encryption scheme is semantically secure.

G.3 Proof of the RC-PoR-P Without Arbiter

To prove Theorem 4, we show that RC-PoR-P meets all security properties deﬁned in Appendix G.1. We
start by proving that RC-PoR-P meets security against a malicious server. The proof to some extent is
simpler to that of RC-PoR-P against a malicious server (i.e., proof of Claim F) as it does not involve any
third party arbiter.

Lemma 6. If SAP and blockchain are secure and PoRID scheme supports correctness, soundness, and
detectable abort, then RC-PoR-P is secure against malicious server, w.r.t. Deﬁnition 17.

Proof. First, we consider event

F (u∗, qj, pp) = hj ∧ (coinC,j 6=

(cid:16)

C

coin∗
z

− o)

(cid:17)

52

that captures the case where the server provides an accepting proof, i.e. PoR, but makes an honest client
withdraw incorrect amounts of coin, i.e., coinC,j 6= coin∗
z − o. Note, in RC-PoR-P protocol, the total coins
the client should receive after z veriﬁcations is coin∗
C − o · (z − yS) + l · (yS − yC). Since we focus on j-th
veriﬁcation, the amounts of coin that should be credited to the client for the j-th veriﬁcation is

C

coinC,j =

C

coin∗
z

− o · (1 − yS,j) + l · (yS,j − yC,j)

(4)

As the proof is valid, an honest client accepts it and does not raise any dispute. But, the server would
be able to make the client withdraw incorrect amounts of coin, if it manages to either convince the contract
that the client has misbehaved, by making the contract output yC,j = 1 through the dispute resolution
phase, or submit to the contract, in the coin transfer phase, an accepting statement ¨x′
cp other than what
was agreed in the initiation phase, i.e., ¨x′
cp 6= ¨xcp, so it can change the payments’ parameters, e.g., l or o.
Nevertheless, it cannot falsely accuse the client of misbehaviour. As, due to the security of SAP, it cannot
convince the contract to accept diﬀerent query’s parameters other than what was agreed with the client in
the initiation phase. In particular, it cannot persuade the contract to accept ¨x′
qp 6= ¨xqp, except
with a negligible probability, µ(λ). Furthermore, if the adversary provides a valid statement then, then due
to the correctness of the PoR and query-checking process, values yC and yS are not incremented by 1 in the
j-th veriﬁcation, i.e., yC,j = yS,j = 0. Also, due to the security of SAP, the server cannot change the payment
parameters by persuading the contract to accept any statement ¨x′
cp other than what was agreed initially
between the client and server, except with a negligible probability µ(λ). Therefore, according to Equation
4, the client is credited coin∗
z − o coins for the j-th veriﬁcation, with a high probability. We now move on to
event

qp such that ¨x′

C

F (u∗, qj, pp) 6= hj ∧ (dj = 1 ∨ yS,j = 0 ∨ coinC,j 6=

C

coin∗
z

+ l)

(cid:17)

(cid:16)

C

It captures the case where the server provides an invalid proof however either persuades the client to
accept the proof, or persuades the contract to set yS,j = 0 or makes the client withdraw incorrect amounts of
coin, i.e. coinC,j 6= coin∗
z + l. Nevertheless, due to the soundness of PoR, the probability that a corrupt server
can convince an honest client to accept invalid proof, i.e. outputs dj = 1, is negligible, µ(λ). So, the client
detects it with a high probability and raises a dispute. Also, the server may try to make the contract keep
yS,j = 0. For yS,j = 0 to happen, it has to make the contract recognise the client as the misbehaving party,
i.e., makes the contract output yC,j = 1. In this case, the client’s complaint would not be processed by the
contract; therefore, yS,j remains 0. Nevertheless, as we discussed above, the probability that the adversary
makes the contract recognise the client as misbehaving is negligible, µ(λ). Therefore, with a high probability
yS,j = 1 and yC,j = 0, after the contract is invoked by the client or server. The adversary may try to make the
client withdraw incorrect amounts of coin, e.g., in the case where it does not succeed in convincing the client
or contract. To do so, in the coin transfer phase, it has to send a diﬀerent accepting statement than what
was initially agreed with the client. But, it would succeed only with a negligible probability, µ(λ), due to the
security of SAP. So, according to Equation 4, the client is credited coin∗
z + l coins for the j-th veriﬁcation,
with a high probability.

C

Next, we prove that RC-PoR-P satisﬁes security against a malicious client. The proof is also slightly
simpler than that of RC-PoR-P against a malicious client (i.e., proof of Claim F) as it does not involve any
third party arbiter.

Lemma 7. If SAP and blockchain are secure and PoRID scheme supports correctness, inputs well-formedness,
and detectable abort, then RC-PoR-P is secure against malicious client, w.r.t. Deﬁnition 18.

Proof. First, we consider event

(M (u∗, k, pp) = σ ∧ Q(aux, k, pp) = qj) ∧ (coinS,j 6=

(cid:16)

53

S

coin∗
z

+ o)

(cid:17)

It captures the case where the client provides accepting metadata and query but makes the server with-
z + o. According to RC-PoR-P protocol, the total
S + o · (z − yS) + l · (yC − yS). As we focus on j-th

draw an incorrect amounts of coin, i.e. coinS,j 6= coin∗
coins the server should receive after z veriﬁcations is coin∗
veriﬁcation, the amount of coins that should be credited to the server for the j-th veriﬁcation is

S

coinS,j =

S

coin∗
z

+ o · (1 − yS,j) + l · (yC,j − yS,j)

(5)

Since the metadata and query are valid, an honest server accepts them and does not raise any dispute,
so we have yC,j = 0. The client however could make the server withdraw incorrect amounts of coin, if it
manages to either convince the contract, in the dispute resolution phase, that the server has misbehaved,
i.e., makes the contract output yS,j = 1, or submit to the contract an accepting statement ¨x′
cp other than
what was agreed at the initiation phase, i.e. ¨xcp, in the coin transfer phase. But, it cannot falsely accuse
the server of misbehaviour, because due to the security of SAP, it cannot convince the contract to accept
diﬀerent decryption key and pads’ detail, by providing a diﬀerent accepting statement ¨x′
qp 6= ¨xqp),
than what was initially agreed with the server, except with a negligible probability, µ(λ). So, with a high
probability yS,j = 0. On the other hand, if the adversary provides a valid statement, i.e. ¨xqp, then due to
the correctness of the PoR and query-checking process, we would have Ij = ⊥. Thus, due to the security of
SAP and the correctness of the PoR and query-checking process, we would have yC,j = yS,j = 0 with a high
probability. Also, due to the security of SAP, the client cannot change the payment parameters by convincing
the contract to accept any accepting statement ¨x′
cp other than what was initially agreed between the client
and server (i.e. ¨x′
cp 6= ¨xcp), except with a negligible probability, µ(λ). That means, according to Equation 5,
the server is credited coin∗
z + o coins for that veriﬁcation, with a high probability. We now move on to

qp (where ¨x′

S

M (u∗, k, pp) 6= σ ∧ a = 1

It captures the case where the server accepts ill-formed metadata. But, due to the security of the Merkle
tree scheme, the probability of the event happening is negligible, µ(λ). So, with a high probability a = 0;
in this case, the server does not raise any dispute, instead it avoids serving the client. Next, we turn our
attention to

(cid:16)

(cid:17)

Q(aux, k, pp) 6= qj) ∧ (bj = 1 ∨ yC,j = 0 ∨ coinS,j 6=

+ o + l)

S

coin∗
z

(cid:16)

(cid:17)
It considers the case where the client provides an invalid query, but either convinces the server or contract
to accept it, or makes the server withdraw incorrect amounts of coin, i.e. coinS,j 6= coin∗
z + o + l. Due to
the correctness of the query-checking process, the probability that the server outputs bj = 1 is 0. When the
honest server rejects the query and raises a dispute, the contract checks the server’s query and sets yC,j = 1.
After that, due to the security of blockchain the client cannot make the contract to set yC,j = 0 except
with probability µ(λ). Also, as discussed above, the client cannot make the contract recognise the honest
server as a misbehaving party with a probability signiﬁcantly greater than µ(λ). That means with a high
probability yS,j = 0. The adversary may still try to make the server withdraw incorrect amounts of coin
(e.g., if the adversary does not succeed in convincing the server). To this end, at the coin transfer phase, it
has to convince the contract to accept a diﬀerent statement than what was initially agreed with the server.
However, due to the security of SAP, its success probability is negligible, µ(λ). Hence, according to Equation
5, the server is credited coin∗

z + o + l coins for the j-th veriﬁcation.

S

S

In the following, we provide a lemma for RC-PoR-P’s privacy. For the lemma’s proof, we refer readers to

the proof of Claim F.

Lemma 8. If SAP is secure and the encryption scheme is semantically secure, then RC-PoR-P preserves
privacy, w.r.t. Deﬁnition 14.

54

H A Table Summarizing RC-PoR-P Assymptotic Costs

Table 4 summarizes the RC-PoR-P’s asymptotic costs of z veriﬁcations, breakdown by parties. In the table,
φ is the number of challenged blocks, z′ is the maximum number of complaints the client and server send to
the arbiter, m is the number of blocks in a ﬁle, ||u∗|| is the ﬁle bit-size, and ||π∗|| is the number of elements
in the padded encrypted proof vector.

Table 4: RC-PoR-P asymptotic complexity, of z veriﬁcations, breakdown by parties. In the table, φ is the number of
challenged blocks, z′ is the maximum number of complaints the client and server send to the arbiter, m is the number
of blocks in a ﬁle, ||u∗|| is the ﬁle bit-size, and ||π∗|| is the number of elements in the padded encrypted proof vector.

Phase

Client-side and Server-side Init.
(i.e., outsourcing: 2 and 3)

The rest of phases (i.e., 4- 8)

Party

Client

Server

Client

Server

Arbiter

Smart Contract

Computation Cost Communication Cost

O(m)

O(m)

O(zφ log2(m))
O(zφ log2(m))
O(z′ log2(m))
O(1)

O(||u∗||)

O(1)
O(z log2(||u∗||))
O(z||π∗

j ||)

O(1)
-

55

