2
2
0
2

p
e
S
5
2

]

R
C
.
s
c
[

2
v
9
0
0
9
0
.
1
0
2
2
:
v
i
X
r
a

Sliding Window Challenge Process for
Congestion Detection

Ayelet Lotem1, Sarah Azouvi2, Patrick McCorry3 and Aviv Zohar1

1The Hebrew University of Jerusalem, {ayelem02,avivz}@cs.huji.ac.il
2Protocol Labs, sarah.azouvi@protocol.ai
3Infura, stonecoldpat@gmail.com

Abstract. Many prominent smart contract applications such as pay-
ment channels, auctions, and voting systems often involve a mechanism
in which some party must respond to a challenge or appeal some action
within a ﬁxed time limit. This pattern of challenge-response mechanisms
poses great risks if, during periods of high transaction volume, the net-
work becomes congested. In this case, fee market competition can prevent
the inclusion of the response in blocks, causing great harm. As a result,
responders are allowed long periods to submit their response and overpay
in fees. To overcome these problems and improve challenge-response pro-
tocols, we suggest a secure mechanism that detects congestion in blocks
and adjusts the deadline of the response accordingly. The responder is
thus guaranteed a deadline extension should congestion arise. We lay
theoretical foundations for congestion signals in blockchains and then
proceed to analyze and discuss possible attacks on the mechanism and
evaluate its robustness. Our results show that in Ethereum, using short
response deadlines as low as 3 hours, the protocol has > 99% defense
rate from attacks even by miners with up to 33% of the computational
power. Using shorter deadlines such as one hour is also possible with a
similar defense rate for attackers with up to 27% of the power.

Keywords: Congestion, Challenge-Response

1

Introduction

DeFi platforms constructed over blockchains such as Ethereum have seen a recent
boom of activity and interest. Their growing ecosystem allows for increasingly
complex ﬁnancial interactions executed in a fully decentralized manner. The
main building blocks used to construct these platforms are the smart contracts
that deﬁne the rules of interaction in code.

Smart contracts enable a wide range of applications, such as auctions, voting
systems, and second layer protocols (e.g., payment channels) that operate above
the blockchain layer. They typically provide rules that allow them to act as an
automated adjudicator in case conﬂicts between participants arise.

For many applications, interactions with smart contracts are time dependent
and are even subject to deadlines, meaning that in some cases, transactions

 
 
 
 
 
 
2

A. Lotem et al.

added after a speciﬁc moment will eﬀectively be rejected. For example in the
case of auctions, a bid must be received before the end of the auction otherwise
it is not valid. Another example appears in the context of payment channels [12]
where participants have a limited interval of time to dispute the division of funds
if they disagree with their peers.

A major weakness of such deadlines is that in cases where the blockchain is
congested, users that submit transactions will not have them included in blocks
in time. In fact, several attacks and failures can be attributed directly to this
weakness (we provide some examples below). One mitigation often employed by
participants is to oﬀer higher fees for transactions with deadlines which means
users are usually overpaying. Another is to extend the deadlines which greatly de-
lays processing and settlement within the context of the relevant smart contract.
In many cases, transaction fees and deadlines are decided upon in advance, before
the exact conditions that will prevail when the transaction is actually transmit-
ted are known, which causes participants to take wider safety margins and in-
creases costs further. Due to the well-known scalability issues of blockchains [1],
we expect congested periods to become increasingly more common, which will
directly impact the design of time-sensitive smart contracts.
Our Contributions. In this work we present a mechanism aimed at solving
these issues. We propose to set short deadlines that are automatically extended
if congestion occurs. We lay the theoretical foundations of congestion monitor-
ing in blockchains and formalize the notion of challenge-response protocols in
this context. We then propose two diﬀerent protocols to detect congestion over
multiple blocks: the ‘L Consecutive Blocks’ protocol deﬁnes uncongestion by the
existence of L consecutive uncongested blocks; its generalization, the ‘Sliding
Window (K-out-of-N)’ protocol, deﬁnes uncongestion by the existence of N con-
secutive uncongested blocks with K uncongested blocks among them. We show
that the Sliding Window protocol is more resilient to attacks than the L Consec-
utive Blocks protocol when attacked by miners. Furthermore, we propose a new
opcode for Ethereum that will provide the required functionality; we also pro-
vide an implementation (not requiring new opcodes) in Solidity, using opcodes
introduced by Ethereum Improvement Proposal 1559 (EIP 1559) [5].

Examples of Congestion Attacks and Related Failures. A recent well-known ex-
ample of congestion-related failure took place on Crypto Black Thursday (March
12th, 2020) when the price of Ethereum dropped by more than 50% in less than
24 hours [11]. This led to a panic-sale of coins and increased congestion. At the
peak, during a 2-3 hour window, the Ethereum blockchain’s fees climbed to $1.65
on average, more than 10 times their cost on previous days.

The drop in ETH price triggered many MakerDAO auctions to liquidate
collateral (typically collateral on short positions must be sold if prices ﬂuctuate
too much). The tokens to be sold were purchased at almost no cost due to
the inability of many bidders to send transactions and participate. This has,
allegedly, been leveraged by one user to gain $8.3 million worth of ETH [3].

Several studies [10,13] deal with diﬀerent types of attacks designed to prevent
a party from responding on time to a challenge [10]. Harris and Zohar [13] present

Sliding Window Challenge Process for Congestion Detection

3

an attack where the attacker forces many victims at once to ﬂood the blockchain
with claims for their funds. The ensuing congestion allows the attacker to steal
the funds that cannot be claimed before the deadline. Our protocol will prevent
these issues by extending the deadlines until the congestion passes.

2 Related Work

Congestion is a real-world problem faced by the most prominent cryptocurren-
cies. In addition to the popular examples of Crypto Black Thursday or Cryptokit-
ties, widely discussed online [3,11,6], Sokolov [17] examined periods of congestion
caused by ransomware.

One way to deal with congestion is to improve the scalability of the underly-
ing consensus protocol [19,20,18,7,9] or to introduce higher-level layers that help
to scale. Solutions ranging from sharding [22], oﬀ-chain payment channels [12]
or layer-zero optimization [21] (i.e., network-level optimization) have been con-
sidered. All these solutions improve the number of transactions per second that
the network can process, but congestion may still occur even at higher rates.

Other methods that help to ensure that time-sensitive transactions are pro-
cessed are rather ad-hoc. For example, the replace by fee [4] and child pays for
parent [2] mechanisms allow users to add or change the fees of their transactions.
Bitcoin’s fee mechanism—equivalent to a ﬁrst-price auction—is sub-optimal and
often results in users paying more than what is necessary. EIP 1559 was made to
change this mechanism in Ethereum [16,5]. EIP 1559 implements a base fee that
is burned. This base fee can be seen as an indication of the level of congestion
in recent blocks, and we utilize this in our implementation.

Another line of research that could potentially prevent transaction fees from
spiking considers order-fairness consensus protocols [14,15]. The idea is to ensure
that transactions are ordered in the blockchain in the same order they arrived
in. This also helps to avoid problems such as front-running [8].

3 Preliminaries and Deﬁnitions

3.1 Challenge-Response Protocols

A challenge-response protocol is an implementation of a pattern in which some
party must respond to a challenge within a ﬁxed time limit. This pattern consists
of a challenge that takes eﬀect at time Tc and a response deadline Trd which is the
latest time by which response to the challenge will be accepted. We call the time
period between Tc and Trd the challenge window. Responding to the challenge
during the challenge window yields diﬀerent results compared to responding after
the deadline. The protocol we propose inspects the challenge window period and
extends it (by extending Trd) as long as the blockchain stays congested.

4

A. Lotem et al.

3.2 Blockchain Congestion

Our protocol has two components. First it relies on a mechanism to deﬁne what
it means for a block to be congested. We then use this deﬁnition to deﬁne an
uncongested period. Intuitively, a period will be (un)congested if some threshold
of blocks is (un)congested. We start by deﬁning block congestion before moving
on to presenting diﬀerent period congestion deﬁnitions and choosing one that
meets our requirements.

Blocks and Transactions. A block B = {tx1, · · · , txn} is as a set of transactions
(we ignore the order of transactions in the block as well as other data—such
as nonce—as they are irrelevant to our problem). Transactions pending to be
included in a block are kept locally by each node in their mempool until they
are included in the chain. Each transaction tx has a size w(tx), and a fee density
φ(tx). The fee paid by the transaction is therefore w(tx) · φ(tx). We deﬁne the
total weight of transactions in a block B with a fee density above θ as WB(θ) :=
(cid:80)

tx∈B: φ(tx)≥θ w(tx).
Blocks can contain transactions with total size bounded by B, i.e., WB(0) ≤
B. For simplicity, we treat every block as full, i.e., for any block WB(0) = B (if
necessary, we ﬁll them artiﬁcially with transactions with a fee of 0).

The total amount of fees collected from a block by the miner is UB :=
(cid:80)
tx∈B w(tx) · φ(tx). If the size of the mempool is bigger than the maximum
block size WB(0), we assume that honest miners choose the transactions in a
way to maximize the fees they get.

Period. A period P e = (b1, b2, ..., bn) in the blockchain is a non-empty sequence
of consecutive blocks. We denote the length (number of blocks) of the period
by |P e| = n, and write for i ∈ {1, ..., n}: P e[i] = bi ∈ P e. For a period P2, we
say that period P1 is included in P2 and note P1 ⊆ P2 if every block in P1 is
included in P2.

In this work, we want to capture the notion of congestion: a phenomenon
where there’s a spike in the number of transactions waiting in the mempool.
Since the mempool is not part of the blockchain, we instead rely on the data in
the blocks in order to deﬁne congestion. We propose the following deﬁnition for
block congestion.

Deﬁnition 1 ((θ, γ)-congestion). We say that a single block B is (θ, γ)-conges-
ted if WB(θ) ≥ γ · B and denote Cθ,γ(B) = 1, where Cθ,γ is the corresponding
indicator function.

Per this deﬁnition, all transactions above fee density θ are examined and
required to make up at least a γ-fraction of the block in terms of size. Intuitively,
for γ = 1 the deﬁnition captures that if a block is (θ, 1)-congested, a transaction
needs to have a fee density that is at least θ in order to have a better chance of
being included. In other words, we use the price of entering a transaction to the
blockchain as a reliable signal for congestion.

Sliding Window Challenge Process for Congestion Detection

5

For a block B and a fee density θ ≥ 0, we deﬁne the θ-weight threshold
γB(θ) as the maximum fraction of the block weight under which the block is
(θ, γ)-congested. From deﬁnition 1 it is clear that γB(θ) = WB(θ)
. Similarly, for
a block B and a fraction γ ≥ 0, we deﬁne the γ-fee density threshold θB(γ) as
the maximum fee density under which the block is (θ, γ)-congested (θB(γ) :=
max{θ | Cθ,γ(B) = 1}).

B

Block Manipulation. One of the key measures we are interested in is when is an
adversary able to manipulate blocks’ congestion signals. When a miner mines
a block, they can choose to include transactions from their mempool or to add
dummy transactions that move money between their accounts and pay a fee (to
themselves), making the fees appear diﬀerent than they ought to be. However,
miners cannot manipulate blocks at arbitrary heights, and doing so would in-
cur a cost. The miner’s chance of mining a new block depends on its relative
computational power. Therefore, as is standard, we denote the computational
power of an adversary by α. Each block has a probability α to be mined by the
adversary, and 1 − α to be mined by the other miners. Furthermore, giving up
mempool transactions means missing out their fees and hence induces a loss that
we compute in the next two propositions.

Proposition 1. An adversary manipulating a block B to make it (θ1, γ1)-conges-
ted when it is not, will lose a potential proﬁt of at-least B·(cid:82) 1
1−(γ1−γB(θ1)) θB(γ) dγ.

Proposition 2. An adversary manipulating a block B to reverse its signal from
(θ1, γ1)-congested to not congested will
lose a potential proﬁt of at-least B ·
(cid:82) γB(θ1)
γ1

(θB(γ) − θ1) dγ.

The proofs for both propositions can be found in Appendix A.1.
Before moving on to deﬁne period congestion, we note that there exist other
ways in which block congestion could be deﬁned. For example, in Section 5, we
take the EIP 1559 base fee as a measure of congestion and use it to implement
our suggested protocol. We include several other examples that are less eﬃcient
in Appendix B.

Congestion Vector of a Period. To determine whether a period P e is uncongested
we will refer to the congestion vector P ec := (C(P e[i]))n
i=1 ∈ {0, 1}n which
consists of the congestion signal of its blocks. Intuitively, if most of the blocks in
the period are congested then the period is congested and vice-versa. However,
we must also account for the fact that an adversary may be able to change the
congestion signal of some of the blocks, as already discussed. We will consider
diﬀerent protocols to deﬁne period uncongestion, a situation in which the period
is considered not congested. An uncongestion period protocol is a function that
we denote by UCP:{0, 1}∗ → {0, 1}. This function takes as input a binary series
representing the congestion signal of the blocks in the examined time period.
It will return 0 if the period is congested and 1 otherwise. This function can
furthermore be extended to also provide auxiliary information such as a proof π

6

A. Lotem et al.

in the case where the period is uncongested. For the eﬃciency of the protocol,
we will strive for a deﬁnition that can provide a compact and easy-to-verify
proof. Throughout the rest of the paper, we use B(n, p) to denote the binomial
distribution with parameters n and p.

Deﬁnition 2 (Period Manipulation). For a period P e and an adversary with
a fraction α of the total computational power, we associate a manipulated period
ˆP e deﬁned as follows. For i ∈ {1, . . . , |P e|} the adversary can replace P e[i] with
probability α, with a block that has a congestion signal of their choice. We denote
by m = m|P e|(α) ∼ B(|P e|, α) the vector that indicates which of the blocks
in the given period the adversary controls, meaning the adversary can replace
the P e[i] block’s congestion signal iﬀ m[i] = 1. We then deﬁne the adversary’s
manipulation set Sm,P e := { ˆP ec ∈ {0, 1}|P e| | ∀1 ≤ i ≤ |P e| : m[i] = 0 ⇒
ˆP ec[i] = P ec[i]}. Intuitively, Sm,P e corresponds to the set of possible congestion
vectors that the adversary could create by changing the signal of the blocks that
it controls.

In a real world setting, even if there is a long period of uncongestion, it could
be the case that one or more of the blocks are fuller than the others due to some
randomness in the transactions’ arrival time (e.g., there was a temporary high
transaction volume). To account for this randomness, we make a simplifying
assumption that blocks are congested independently with probability p and say
that the blockchain is p−congested. We note that, in reality, congestion is often
changing and is usually correlated when considering several consecutive blocks.
We leave more complex models of congestion for future work. In our case, the
congestion vector of a period P e chosen at random has a binomial distribution:
P ec ∼ B(n, p). When studying attacks where the adversary tries to convert a
congested period to an uncongested one, we will assume that p is close to one
(i.e., most of the blocks are congested), whereas when studying the opposite
case, we will consider p to be close to zero.

Our protocol consists in extending the deadline of challenge-response in the
event of a congestion period. However, to avoid an edge case where the deadline
is extended indeﬁnitely, we deﬁne ˆM , an upper bound on the total length of the
extended period.
Deﬁnition 3 ( ˆM -maximum Extension). Given a challenge-response proto-
col in a p−congested blockchain where the challenge starts at block height h, we
say that ˆM is the maximum extension of the challenge if the deadline cannot be
extended further than height h + ˆM .

3.3 Desirable Properties of Protocols

In this section, we deﬁne some properties that we aim for our protocol to achieve.
In the rest of the paper we use the notation D ←− s to denote that s was se-
lected randomly from the distribution D. We start by describing the two types of
attack that we will consider—a congestion attack and an uncongestion attack—
before deﬁning the robustness of the protocol, which captures the security of the
protocol against either attack.

Sliding Window Challenge Process for Congestion Detection

7

Deﬁnition 4 (Congestion/Uncongestion Attack on P e). Given a period
P e, chosen at random in a p-congested blockchain, we say that the adversary
wins a congestion, resp. uncongestion, attack on P e if it can manipulate P e into
an congested, resp. uncongested, period.

Deﬁnition 5 ((α, p, q, n)-congestion Robustness). We say an uncongestion
period protocol UCP:{0, 1}∗ → {0, 1} is (α, p, q, n)-congestion robust if, given
an adversary with a relative computational power α, his probability of winning a
congestion attack, i.e., of successfully manipulating a period P e of n blocks into
a congested period ˆP e, is less than q.

B(n, p) ←− P e : Pr(∃ ˆP e ∈ Sm,P e s.t. UCP( ˆP e) = 0) ≤ q.

Deﬁnition 6 ((α, p, q, n)-uncongestion Robustness). We say an unconges-
tion period protocol UCP:{0, 1}∗ → {0, 1} is (α, p, q, n)-uncongestion robust
if, given an adversary with a relative computational power α, his probability of
winning an uncongestion attack, i.e., of successfully manipulating a period P e
of n blocks into an uncongested period ˆP e, is less than q.

B(n, p) ←− P e : Pr(∃ ˆP e ∈ Sm,P e s.t. UCP( ˆP e) = 1) ≤ q.

Deﬁnition 7 (Monotonicity). A congestion protocol is monotone if for ev-
ery two periods P e1 and P e2, if P e1 ⊆ P e2 and P e1 is considered uncongested,
then so is P e2, i.e., ∀P e1 ⊆ P e2 : UCP(P ec

1) = 1 → UCP(P ec

2) = 1.

A monotone protocol is easier to verify as the prover only needs to select a
portion of blocks from the time period P e in order to prove uncongestion. Fur-
thermore, a monotone protocol requires only sporadic access to the blockchain.
A prover can go oﬄine and prove uncongestion when they come back online by
choosing any uncongested period from the time they were oﬄine. In the case of
a non-monotonic protocol, if the prover is oﬄine during an uncongested period,
they cannot prove the uncongestion of the longer period, after they came back
online, they missed the uncongested period.

Eﬃciency Properties. We deﬁne two properties that capture the eﬃciency of the
protocol.

– Concise proof size The evidence needed to prove uncongestion of a period

should be as concise as possible.

– Concise refresh information The extra information needed to be kept
when checking the congestion signal of a period that has already been ex-
tended due to congestion should be as concise as possible. Ideally, when we
extend a period from P e1 to P e2 in order to check P e2 for congestion, we
should not have to recheck every block in P e1 but, rather, aggregate this
information.

In the next section we will discuss diﬀerent period congestion protocols with
the goal of ﬁnding one that will be proof eﬃcient and robust against an attacker
with reasonable hash rate with high probability.

8

A. Lotem et al.

4 Uncongested Period Protocols

In this section, we examine diﬀerent protocols that ﬁt the deﬁnition of congestion
of a period P e. We start by presenting “naive” protocols and discuss why they
are not good enough, i.e., why they lack the desirable properties deﬁned in
Section 3.3.

4.1 Strawman Protocols

Deﬁnition 8 (Cumulative M). Period P e is uncongested if there exists M
blocks which are uncongested: UCPCM (P ec) = 1 ↔ (cid:0)(cid:80)

b∈P e(1 − C(b)) ≥ M (cid:1).

This protocol is monotonic but is not suﬃciently robust to adversarial at-
tacks: if we wait long enough, the probability of the adversary controlling M
blocks becomes overwhelming (even if α is small). We solve this in the next
strawman by considering the percentage of blocks instead of a ﬁxed number.

Deﬁnition 9 (Percentage). A period P e is uncongested if x% of its blocks are
not congested: UCPP C(P ec) = 1 ↔ (cid:0)(cid:80)

b∈P e(1 − C(b)) ≥ x

100 · |P e|(cid:1).

This protocol is much more robust but has the drawback of not being mono-
tonic. For example, if all blocks are uncongested during the ﬁrst part of the period
and congestion begins in the second part, then the beginning of the period is
uncongested while the whole period may not be.
We now suggest the following monotonic rule:

Deﬁnition 10 (L Consecutive Blocks). A period P e is uncongested if there
exists at least L consecutive uncongested blocks included in it:
UCPL(P ec) = 1 ↔ (∃ 1 ≤ i ≤ |P e| − L + 1 s.t. ∀ 0 ≤ j ≤ L − 1 : P ec[i + j] = 0).

We show that this protocol is monotonic and inspect its eﬃciency in Ap-

pendix A.2. We now evaluate its robustness.

Evaluation of the Robustness of the L Consecutive Blocks protocol.
We examine situations where the adversary attempts to manipulate the conges-
tion signal for a given period. We separate this into two attacks: uncongestion
and congestion attacks (as in Deﬁnition 4). We strive to achieve a high defense
rate against both attacks, meaning ﬁnding a value L that will give a low proba-
bility for an adversary to succeed in each of the attacks separately.

Evaluation of the Uncongestion Attack. In order to compute the probability of
an attacker to successfully manipulate P e into an uncongested period, we deﬁne
the following matrix T(L+1)×(L+1):

∀ 0 ≤ i, j ≤ L : Ti,j =





(1 − α) · p

if j = 0 ∧ i (cid:54)= L

α + (1 − α) · (1 − p)

if j = i + 1

1

0

if i = j = L

otherwise

(1)

Sliding Window Challenge Process for Congestion Detection

9

and denote by ei the ith unit vector of dimension L+1 (i.e., ei has a 1 in the

ith coordinate and 0’s elsewhere).

Theorem 1. The probability of an attacker with a relative computational power
α to successfully manipulate P e into an uncongested period in a p-congested
network equals e1 · T n · et

L+1.

Proof. We note that, at each block, the attacker has a probability α to mine the
next block, which allows them to decide its congestion level. In this context, this
means setting the block to be uncongested. In addition, the congestion signal of
a block not mined by the attacker depends on the prevailing congestion state
which is expressed by p. The probability of an honest block being congested, resp.
uncongested, is hence equal to (1 − α) · p, resp. α + (1 − α) · (1 − p). We deﬁne
the following Markov chain that describes a random walk on P e’s blocks and
whose states represent the number of consecutive blocks that are uncongested
at a point in time.

The initial state is 0 since it corresponds to the 0 consecutive uncongested
blocks at the beginning of the walk. With each step, we move from state i to
state i + 1, for i < L, if the block is uncongested, and return to state 0 if it is
not. If we reach state L, we stay there since it means the adversary has reached
the goal of L consecutive uncongested blocks in P e and can manipulate it to an
uncongested period.

T is the corresponding transition matrix; hence the probability of reaching

state L in |P e| = n steps is expressed by e1 · T n · et

L+1.

Evaluation of the Congestion Attack. For the attack in the opposite direction
we deﬁne ˆT(L+1)×(L+1) as follows:

∀ 0 ≤ i, j ≤ L :

ˆTi,j =





α + (1 − α) · p

if j = 0 ∧ i (cid:54)= L

(1 − α) · (1 − p)

if j = i + 1

1

0

if i = j = L

otherwise

(2)

Theorem 2. The probability of an attacker with a relative computational power
α to successfully manipulate P e into a congested period, in a p-congested network
equals 1 − e1 · ˆT n · et

L+1.

𝐿−1𝐿012𝑠𝑡𝑎𝑟𝑡...𝛼+(1−𝛼)∙(1−𝑝)𝛼+(1−𝛼)∙(1−𝑝)𝛼+(1−𝛼)∙(1−𝑝)𝛼+(1−𝛼)∙(1−𝑝)1(1−𝛼)∙𝑝(1−𝛼)∙𝑝(1−𝛼)∙𝑝(1−𝛼)∙𝑝𝛼+(1−𝛼)∙(1−𝑝)10

A. Lotem et al.

Proof. This time, if the attacker succeeds in mining a block, they will make it
congested. Therefore the probability for a block to be uncongested is (1 − α) ·
(1 − p). As before, we deﬁne the following Markov chain whose states represent
the number of consecutive blocks that are uncongested at a point in time in P e:

ˆT is the corresponding transition matrix. Therefore, the probability for the
adversary to succeed in the congestion attack is equivalent to the probability that
the rest of the miners will not reach the L state in n steps, which is expressed
by: 1 − e1 · ˆT n · et

L+1.

Now that we have the attacks’ success rates, we examine the robustness of

the protocol against both attacks for diﬀerent values of L.

Although attacks are potentially expensive for the adversary (who needs to
change the contents of its block and, hence, loses transaction fees), we still desire
a low success probability for the attack even for strong attackers. We assume in
the following evaluations that the attacker controls 33% of the computational
power.

Given that congestion may cause period extension, we need a value for L
that gives protection also against attacks over longer periods. We examine the
behavior of the protocol for periods as long as ˆM using diﬀerent values for L.

The value p should represent realistic network conditions. For our analysis
we pick p = 0.85 when studying the uncongestion attack, to simulate more
congested settings, or p = 0.15 when studying the congestion attack, to simulate
relatively uncongested settings. Other values can be plugged in, if needed, for
other conditions. We start by examining the robustness of the protocol for a
period of 1 day.

Figures 1a-1b present the probability of success in both attacks for two diﬀer-
ent period lengths: 6450 blocks in Figure 1a and 144 blocks in Figure 1b. These
periods correspond, roughly, to a single day in Ethereum and a single day in
Bitcoin. The red curves correspond to the congestion attack and the blue curves
to the uncongestion attack. We compute these probabilities for diﬀerent values
of L.

The results in both ﬁgures show there is no value L that gives a probability of
success less than 1% for both attacks. Formally, it shows that the L Consecutive
Blocks protocol cannot be simultaneously (0.33, 0.15, 0.01, 1 day)-congestion ro-
bust and (0.33, 0.85, 0.01, 1 day)-uncongestion robust. Therefore, we ﬁnd the L
Consecutive Blocks protocol not suﬃciently secure. Intuitively, this is because
more robust estimates of congestion are typically obtained over longer observa-

𝐿−1𝐿012𝑠𝑡𝑎𝑟𝑡...(1−𝛼)∙(1−𝑝)(1−𝛼)∙(1−𝑝)(1−𝛼)∙(1−𝑝)(1−𝛼)∙(1−𝑝)1𝛼+(1−𝛼)∙𝑝𝛼+(1−𝛼)∙𝑝𝛼+(1−𝛼)∙𝑝𝛼+(1−𝛼)∙𝑝(1−𝛼)∙(1−𝑝)Sliding Window Challenge Process for Congestion Detection

11

(a) |P e| = 6450 ∼ 1 day in Ethereum

(b) |P e| = 144 ∼ 1 day in Bitcoin

Fig. 1: Attack success rate as a function of L, for α = 0.33

tion windows. The L Consecutive Blocks protocol obtains longer observations
if L is increased, but then the requirement for consecutive blocks to be uncon-
gested is too strict and is not robust. As a result of this insight, we propose a
new protocol that generalizes the L Consecutive Blocks protocol and allows for
longer observation windows with a relaxed condition for uncongestion.

4.2 Sliding Window (K-out-of-N) Protocol

Deﬁnition 11 (K-out-of-N Sliding Window). A period P e is uncongested
if there exists a period ˆP e of length N included in it in which at least K blocks
are uncongested.

UCPSW (P ec) = 1 ↔


 ∃ ˆP e ⊆ P e : | ˆP e| = N ∧





(cid:88)

(1 − C(b)) ≥ K









b∈ ˆP e

We note that the L Consecutive Blocks protocol is a special case in which

L = N = K.

Proposition 4. The Sliding Window protocol is monotonic.

Proof. Given an uncongested period P e1, according to the Sliding Window pro-
tocol, which is included in period P e2:

UCPSW (P ec

1) = 1 ⇒


∃ ˆP e ⊆ P e1 : | ˆP e| = N ∧





(cid:88)





C(b) ≥ K





P e1 ⊆ P e2 ⇒

(cid:16) ˆP e ⊆ P e2

(cid:17)

⇒ UCPSW (P ec

2) = 1

b∈ ˆP e



∧



(cid:88)

b∈ ˆP e





C(b) ≥ K

12

A. Lotem et al.

We now evaluate its eﬃciency.

Proof Size. In order to provide evidence for the uncongestion of a period P e of
size n, it is enough to point to a window in which uncongestion occurs. Formally,
to present π = i ∈ {1, ..., n − K + 1} s.t. (cid:80)i+N

l=i (1 − C(P e[l])) ≥ K.

Refresh Information. Given a congested period P e, and ˆP e that extends it, in
order to determine the congestion level of the extended period UCPSW ( ˆP ec), it
is enough to check only windows that overlap blocks in ˆP e \ P e.

Evaluation of the Sliding Window Protocol’s Robustness. We consider
the two attacks in Deﬁnition 4. We ﬁrst note that the two attacks may diﬀer in
their consequences. While the congestion attack can cause a delay in the response
deadline (i.e., a deadline will be extended even if it is not really needed), the
uncongestion attack might lead participants to miss the chance to respond on
time, as the deadline will not be extended even if the network is congested. The
damage in each case depends on the particular use case. For example, in the
case of payment channels, not responding in time is more severe and may lead
to ﬁnancial losses. We strive to achieve a high level of security against both
types of attack, i.e., to ﬁnd values for parameters (N, K) that will yield a low
probability of success for both.

We begin by presenting upper bounds on the probabilities of success in each

of the attacks.

Theorem 3. The probability of an attacker with a relative computational power
α to successfully manipulate P e into an uncongested period, in a p-congested
(cid:1) · qj · (1 − q)N −j, for
network, is bounded above by (n − N + 1) · (cid:80)N
q = α + (1 − p) · (1 − α).

(cid:0)N
j

j=K

Proof. The probability for a block to be uncongested during this attack is q =
α + (1 − p) · (1 − α). In a period of size n, there are n − N + 1 diﬀerent sliding
windows. We denote by Ai the event in which there are K out of N uncongested
blocks in the ith sliding window. Therefore, the probability of a single sliding
(cid:1)·qj·(1−q)N −j. To succeed in the
window being uncongested is P (Ai) = (cid:80)N
uncongestion attack, at least one of the sliding windows has to be uncongested,
which is expressed by P (∪n−N +1
Ai). We use the union bound to bound this
probability and get:
P (∪n−N +1
i=1

P (Ai) = (n − N + 1) · (cid:80)N

(cid:1) · qj · (1 − q)N −j

Ai) ≤ (cid:80)n−N +1

(cid:0)N
j

j=K

i=1

j=K

i=1

(cid:0)N
j

Theorem 4. The probability of an attacker with a relative computational power
α to successfully manipulate P e into a congested period, in a p-congested network
(cid:1) · qj · (1 − q)N −j)(cid:98) n
is bounded above by ((cid:80)K−1
N (cid:99), for q = (1 − p) · (1 − α).
j=0

(cid:0)N
j

Sliding Window Challenge Process for Congestion Detection

13

j=0

(cid:0)N
j

Proof. The probability for a block to be uncongested is q = (1 − p) · (1 − α).
We denote by Bi the event in which there are less than K uncongested blocks
in the ith sliding window. The probability of a single sliding window being con-
(cid:1) · qj · (1 − q)N −j. To succeed in the congestion
gested is P (Bi) = (cid:80)K−1
attack, all sliding windows in the period must be congested, which is expressed
Bi). We bound this probability by P (∩(cid:98) n
N (cid:99)
by P (∩n−N +1
i=1 BN ·(i−1)+1), i.e., we
consider a subset of events Bi that are independent from each other (removing
overlapping windows). We compute the intersection of the pairwise independent
i=1 BN ·(i−1)+1) = (cid:81)(cid:98) n
Bi) ≤ P (∩(cid:98) n
N (cid:99)
N (cid:99)
events and get: P (∩n−N +1
i=1 P (BN ·(i−1)+1) =
((cid:80)K−1
j=0

(cid:1) · qj · (1 − q)N −j)(cid:98) n

N (cid:99).

i=1

i=1

(cid:0)N
j

We would like to compute the robustness of the protocol for 1 day to 1
hour sliding windows. We examine the situation where a period P e of size n is
chosen at random and the blockchain is p − congested for values of p = 0.85
(relatively congested) and p = 0.15 (relatively uncongested) against an attacker
with computational power α ≤ 0.33. In the evaluation, we allow periods to be
extended up to two weeks, a reasonable time for congestion to pass. We set the
ˆM -maximum extension (see Deﬁnition 3) accordingly (90300 blocks in Ethereum
and 2016 blocks in Bitcoin).

We ﬁrst evaluate the attack over Ethereum, computing the above bounds
for diﬀerent sliding window sizes. We begin with a sliding window of 1 day
(N = 6450), setting K = N
2 = 3225. Figure 2 presents the two upper bounds
for the diﬀerent possible period lengths N ≤ n ≤ ˆM . For the protocol to be
considered secure, we need low values in both curves for the diﬀerent period
lengths (since periods might be extended). As can be seen, the probabilities
in the graph are extremely low, showing the protocol to be very secure. We
emphasize that the blue curve is not horizontal, as shown in the graph; all of
its values are smaller than 10−323. Note that these are only upper bounds; the
actual probabilities are even lower.

Fig. 2: Upper bounds on the attacks’ success rates as a function of the period
length, for ˆM = 90300, N = 6450, K = 3225, α = 0.33

14

A. Lotem et al.

We evaluate the attack for smaller sliding windows. The following table sum-

marizes our results:

N
6450 (1 day)
3225 (12 hours)
1612 (6 hours)
806 (3 hours)

K
3225
1612
815
421

Uncongestion
< 10−323
1.26 × 10−10
7.14 × 10−5
8.87 × 10−3

Congestion
1.44 × 10−29
8.06 × 10−16
1.08 × 10−7
3.16 × 10−3

The wider the sliding window is, the greater the protection. For smaller
sliding windows, such as 1 hour (N = 269), we can achieve a 99% defense rate
against each attack if we lower the attackers’ computation power to α ≤ 0.27
(instead of 0.33). We provide examples of N, K values and the level of protection
they provide (an upper bound), but these are conﬁgurable and subject to the
user’s discretion. One can choose to increase the level of protection from one
attack at the expense of the other, or to set a larger initial period length (> N )
to increase the protection.

Next, we want to know what happens with smaller periods such as in Bitcoin,
which has longer block intervals. To do so, we set ˆM = 2016 and begin with a
sliding window of 1 day (N = 144).

We use a simulation to draw 100,000 samples P ec ∼ B( ˆM , p) of congestion
vectors and to compute the success rates of both attacks among the samples (Fig-
ures 3a,c,d). We use error plots to plot the standard error of the data; however,
the errors are very small and therefore are almost invisible in the graphs.

Figure 3a presents the probability of success in each of the attacks for dif-
ferent K values. As the graph shows, choosing K = 89 gives protection against
both attacks. We compute the upper bounds (from Theorems 3-4) for this value
of K in Figure 3b. The presented bounds as they appear in the graph are loose
compared to the simulation results and aﬀord a low level of defense, especially
against the congestion attack. These bounds give us useful, but non-tight, upper
bounds on the results for periods that are of longer length, for which the prob-
ability is extremely small. To get more precise results, we use more simulations
to compute the congestion attacks’ success rate for diﬀerent period lengths and
present the results in Figure 3c. Each curve corresponds to a diﬀerent value of α,
the computational power of the attacker. The defense rate against congestion at-
tacks is extremely low for short periods. For α = 0.33, we reach a > 99% defense
rate only for periods of ∼ 11 days or more. Lowering the computational power
of the adversary naturally improves these results. For example, considering an
attacker with computational power α = 0.2 results in an above 0.9995 defense
rate for period lengths starting from 2 days.

Finally, in Figure 3d we consider an attacker with a computational power
α = 0.2 and show the congestion attack success rate for diﬀerent choices of
N, K correspondig to sliding windows of lengths 24/12/6/3 hours. We do not
present the uncongestion attack results which had above 99% defense rate for
any N ≤ n ≤ ˆM = 2016.

We conclude that the longer the periods are, the higher and more eﬀective the
protection against attacks is. In Ethereum, we obtained very high defense rates

Sliding Window Challenge Process for Congestion Detection

15

(a) Attack success rate as a function of K,
for n = 2016, N = 144, α = 0.33

(b) Upper bounds on the attacks’ success
rates as a function of the period length, for
N = 144, K = 89, α = 0.33

(c) Congestion attack success rate as a func-
tion of the period length, for N = 144, K =
89

(d) Congestion attack success rate as a
function of the period length, for α = 0.2

Fig. 3: Evaluation of the attacks’ success rates for ˆM = 2016 (2 weeks in Bitcoin)

even when choosing short sliding window sizes and against strong attackers. In
Bitcoin, on the other hand, we need to compromise on the window size and on
the attackers’ power to achieve higher defense.

We deﬁned uncongested period protocols and suggested a concrete one, the
Sliding Window protocol, which meets our requirements (as deﬁned in Sec-
tion 3.3). In the next section, we will describe how to use an uncongested period
protocol to adjust the challenge-response protocol to deal with congested peri-
ods.

4.3 Application to Challenge-Response Protocols

A challenge-response protocol consists of a challenge that takes eﬀect at time
Tc and a response deadline Trd (see section 3.1). We link Tc and Trd to their
corresponding block height and denote by b(T ) the block at height T .

16

A. Lotem et al.

The parties involved in the challenge decide in advance on an uncongestion
period protocol UCP to use. We recall that UCP:{0, 1}∗ → {0, 1} accepts a
congestion vector (a binary series representing the congestion signal of blocks
in a period) and returns 1 if the period is congested and 0 otherwise. To apply
the uncongestion period protocol, the parties adjust Trd to a short deadline that
gives them a reasonable time to respond to the challenge assuming an optimal
case with no congestion.

The response deadline Trd is applied only in the event that the challenge
window P e = (b(Tc), b(Tc + 1), ..., b(Trd)) is uncongested. In the case where the
challenge window is congested, we repeatedly extend Trd, 1 block at a time,
as long as it remains congested. To avoid an edge case where the deadline is
extended indeﬁnitely, we deﬁne ˆTrd = Tc + ˆM , an upper bound on the deadline
(see Deﬁnition 3). The challenge-response protocol adjustment is summarized in
the algorithm below.

Tc ← init
Trd ← init
P e = (b(Tc), b(Tc + 1), ..., b(Trd))
P ec ← congestion vector(P e)
while UCP(P ec) = 0 and Trd < ˆTrd do

Trd ← Trd + 1
P e = (b(Tc), b(Tc + 1), ..., b(Trd))

We emphasize that the extension of the deadline is not necessarily carried
out at the exact moment of the deadline (since smart contract actions need
to be triggered by a transaction to the contract). Instead, a transaction that
is submitted afterwards is determined to be either before or after the deadline
given any possible extensions that are due. The uncongestion period protocol
is speciﬁed in advance in the smart contract, and the deadline calculation is
triggered either by a late response to the challenge or by the challenger that
claims that a response did not arrive in time.

5

Implementation

We provide an implementation of the Sliding Window protocol as an Ethereum
smart contract using the EIP 1559 base fee to determine block congestion. EIP
1559 implements a base fee that is adjusted up and down by the protocol ac-
cording to how congested the network is. The EVM supports fetching the base
fee of the highest (current) block. We suggest extending this to fetch the base
fee of any block, and to add an opcode that checks whether a block is congested
(without such opcodes, it is not possible to fully implement the mechanisms put
forward in this paper). This opcode will receive as inputs a block and a maxi-
mum base fee (chosen by a user) and will return whether the maximum base fee
exceeds the block’s base fee.

Sliding Window Challenge Process for Congestion Detection

17

In the implementation, we set the sliding window size equal to the initial

deadline of the examined period (before being granted any extension).

The full github1 repository includes the smart contracts, the new opcode,
and the tests. In addition, we include the Solidity code of the contracts in Ap-
pendix C.

6 Conclusion

In this paper, we tackled a problem that arises when challenge-response pro-
tocols face congested periods. When the network experiences congestion, users
will often miss the response deadline, which can lead to serious issues including
ﬁnancial loss. We formalized the problem and proposed a new protocol called
the Sliding Window as a solution. Our protocol deﬁnes a reliable way to detect
congested periods by looking only at the data available on-chain. We then used
this to extend the challenge-response deadline when congestion occurs. We stud-
ied the security of the protocol for diﬀerent parameters. Our results showed that
it is possible to decrease the time settlement (deadline) of challenge-response
protocols signiﬁcantly, while expanding the security of the protocol to deal with
cases of congestion.

For future work, it would be interesting to evaluate and optimize this protocol
and its security analysis for more realistic congestion settings—in particular,
settings in which congestion is correlated between consecutive blocks—and to
provide more experimental analysis of these settings. Is is also of interest to
explore whether Ethereum’s proposed base fee can be used as a suﬃciently robust
congestion signal.

7 Acknowledgments

Ayelet Lotem and Aviv Zohar are partially supported by grants from the Israel
Science Foundation (grants 1504/17 & 1443/21) and by a grant from the HUJI
Cyber Security Research Center in conjunction with the Israel National Cyber
Bureau.

References

1. Bano, S., Sonnino, A., Al-Bassam, M., Azouvi, S., McCorry, P., Meiklejohn, S.,
Danezis, G.: SoK: Consensus in the age of blockchains. In: AFT ’19: Proceedings
of the 1st ACM Conference on Advances in Financial Technologies. pp. 183–198
(2019)

2. Bitcoin Optech: Child pays for parent (CPFP), https://bitcoinops.org/en/

topics/cpfp

1 https://github.com/stonecoldpat/slidingwindow

18

A. Lotem et al.

3. Mempool manipulation enabled theft of $8m in MakerDAO collateral on Black
https://www.coindesk.com/tech/2020/07/22/mempool-

Thursday:
manipulation-enabled-theft-of-8m-in-makerdao-collateral-on-black-
thursday-report/

Report,

4. Bitcoin wiki: Replace by fee, https://en.bitcoin.it/wiki/Replace by fee
5. Buterin, V., Conner, E., Dudley, R., Slipper, M., Norden, I., Bakhta, A.: EIP-1559:
Fee market change for ETH 1.0 chain. https://eips. ethereum. org/EIPS/eip-1559
(2019)

6. ConsenSys: The inside story of

(Feb
https://consensys.net/blog/news/the-inside-story-of-the-

the CryptoKitties congestion crisis

2018),
cryptokitties-congestion-crisis/

7. Croman, K., Decker, C., Eyal, I., Gencer, A.E., Juels, A., Kosba, A., Miller, A.,
Saxena, P., Shi, E., Sirer, E.G., et al.: On scaling decentralized blockchains. In:
International conference on ﬁnancial cryptography and data security. pp. 106–125.
Springer (2016)

8. Daian, P., Goldfeder, S., Kell, T., Li, Y., Zhao, X., Bentov, I., Breidenbach, L.,
Juels, A.: Flash boys 2.0: Frontrunning, transaction reordering, and consensus
instability in decentralized exchanges. arXiv preprint arXiv:1904.05234 (2019)
9. Eyal, I., Gencer, A.E., Sirer, E.G., Van Renesse, R.: Bitcoin-NG: A scalable
blockchain protocol. In: 13th {USENIX} symposium on networked systems design
and implementation ({NSDI} 16). pp. 45–59 (2016)
on

10. Felten, E.: Fighting

censorship

contracts.

attacks

smart

https:

//medium.com/offchainlabs/fighting-censorship-attacks-on-smart-
contracts-c026a7c0ff02 (2020)

11. Frangella, E.: Crypto Black Thursday: The good, the bad, and the ugly,
https://medium.com/aave/crypto-black-thursday-the-good-the-bad-and-
the-ugly-7f2acebf2b83, accessed: 2021-08-31

12. Gudgeon, L., Moreno-Sanchez, P., Roos, S., McCorry, P., Gervais, A.: SoK: Layer-
two blockchain protocols. In: International Conference on Financial Cryptography
and Data Security. pp. 201–226. Springer (2020)

13. Harris, J., Zohar, A.: Flood & loot: A systemic attack on the lightning network.
In: AFT ’20: Proceedings of the 2nd ACM Conference on Advances in Financial
Technologies. pp. 202–213 (2020)

14. Kelkar, M., Zhang, F., Goldfeder, S., Juels, A.: Order-fairness for byzantine con-
sensus. In: Annual International Cryptology Conference. pp. 451–480. Springer
(2020)

15. Kursawe, K.: Wendy, the good little fairness widget: Achieving order fairness for
blockchains. In: AFT ’20: Proceedings of the 2nd ACM Conference on Advances
in Financial Technologies. pp. 25–36 (2020)

16. Roughgarden, T.: Transaction fee mechanism design for the Ethereum blockchain:
An economic analysis of EIP-1559. Tech. rep., Department of Computer Science,
Columbia University (2020)

17. Sokolov, K.: Ransomware activity and blockchain congestion. Journal of Financial

Economics (2021)

18. Sompolinsky, Y., Lewenberg, Y., Zohar, A.: SPECTRE: A fast and scalable cryp-
tocurrency protocol. IACR Cryptology ePrint Archive, Report 2016/1159 (2016)
19. Sompolinsky, Y., Wyborski, S., Zohar, A.: PHANTOM and GHOSTDAG: A scal-
able generalization of Nakamoto consensus. IACR Cryptology ePrint Archive, Re-
port 2018/104 (2018)

Sliding Window Challenge Process for Congestion Detection

19

20. Sompolinsky, Y., Zohar, A.: Secure high-rate transaction processing in bitcoin.
In: International Conference on Financial Cryptography and Data Security. pp.
507–527. Springer (2015)

21. Tanana, D.: Avalanche blockchain protocol for distributed computing security. In:
2019 IEEE International Black Sea Conference on Communications and Network-
ing (BlackSeaCom). pp. 1–3. IEEE, New York (2019)

22. Wang, G., Shi, Z.J., Nixon, M., Han, S.: SoK: Sharding on Blockchain. In: AFT ’19:
Proceedings of the 1st ACM Conference on Advances in Financial Technologies.
pp. 41–61 (2019)

20

A. Lotem et al.

A Proofs

A.1 Proofs of Section 3.2

Proof of Proposition 1.

Proposition 1. A miner manipulating a block B to make it (θ1, γ1)-congested
when it is not will lose a potential proﬁt of at least B · (cid:82) 1
1−(γ1−γB(θ1)) θB(γ) dγ.

Fig. 4: Cumulative function of the θ-weight threshold of a block B before and
after miner manipulation

Proof. Given a block B which is not (θ1, γ1)-congested (Cθ,γ (B) = 0), it is
possible to manipulate it into a block B which is (θ1, γ1)-congested (Cθ,γ (B) =
1) by replacing some of its transactions with dummy transactions that have fee
density ≥ θ1. In order to maximize its revenue, the adversary will remove the
transactions with the lowest fee density. The minimum portion of transactions
that the adversary needs to remove is γ1 − γB(θ1) (by the deﬁnition of γB),
and by doing so the miner misses the rewards associated with removing these
legitimate transactions.

Using the notations from above, we compute a lower bound on the miner’s
loss, which can be expressed by UB ≤ UB − B · (cid:82) 1
1−(γ1−γB(θ1)) θB(γ) dγ (see
Figure 4). Note this is only a lower bound since a miner can remove transactions
only in their entirety and not parts of them.

Proof of Proposition 2.

Proposition 2. A miner manipulating a block B to reverse its signal from
(θ1, γ1)-congested to not congested will
lose a potential proﬁt of at least B ·
(cid:82) γB(θ1)
γ1

(θB(γ) − θ1) dγ.

Sliding Window Challenge Process for Congestion Detection

21

Fig. 5: Cumulative function of the θ-weight threshold of a block B before and
after miner manipulation

Proof. The cost of reverting a block signal to uncongested depends on the state
of the mempool. It is likely that transactions with fee density slightly lower
than θ1 will be available in the miner’s mempool allowing him to substitute the
original transactions with fee density ≥ θ1 for these and lose the fee diﬀerence.
This allows us to give a bottom bound on the loss which can be expressed by
UB ≤ UB − B · (cid:82) γB(θ1)

(θB(γ) − θ1) dγ (see Figure 5).

γ1

A.2 Proof of Section 4

Proposition 3. The L Consecutive Blocks protocol is monotonic.

Proof. Given a period P e1, uncongested according to the L Consecutive Blocks
protocol, which is included in period P e2:

1) = 1 ⇒

UCPL(P ec
∃ 1 ≤ i1 ≤ |P e1| − L + 1 s.t. ∀ 0 ≤ j ≤ L − 1 : P ec
P e1 ⊆ P e2 ⇒
∃ 1 ≤ k ≤ |P e2| − |P e1| + 1 s.t. ∀ 1 ≤ d ≤ |P e1| : P ec
⇒ f or i2 = k + i1 − 1, ∀ 0 ≤ j ≤ L − 1 : P ec
⇒ UCPL(P ec

2) = 1

2[i2 + j] = 0

1[i1 + j] = 0

1[d] = P ec

2[k + d − 1]

We now evaluate its eﬃciency.

22

A. Lotem et al.

Proof size. In order to provide evidence for the uncongestion of period P e of size
n, it is enough to point to the location of the ﬁrst block in a series of L consecutive
uncongested blocks, given formally by π = min{i ∈ {1, ..., n − L + 1} | ∀ 0 ≤ j ≤
L − 1 : P ec[i + j] = 0}.

Refresh Information. Given a congested period P e, and ˆP e that extends it, in
order to determine the congestion level of the extended period UCPL( ˆP ec), it
is enough to check only ˆP e \ (P e[: −(L − 1)]), the period beginning L-1 blocks
before P e ends.

B Block Congestion Deﬁnition: Examples

In Deﬁnition 1, we oﬀered to deﬁne the congestion of a block based on the fee
densities. Other, less eﬀective, ways in which block congestion could be deﬁned
are listed below:

– By transaction with lowest fee density: A block is θ-congested if the lowest
fee density for a transaction in it is bigger than θ: mintx∈B φ(tx) ≥ θ. How-
ever, a miner could decide to always enter a single transaction with a very
low fee density (less than θ) and easily change a block from congested to not
congested; hence this scheme is easily manipulable.

– By transaction with highest fee density: A block is θ-congested if the highest
fee density of its transactions is bigger than θ: maxtx∈B φ(tx) ≥ θ. A miner
could decide to always enter a single (dummy) transaction with a high fee
density (higher than θ) and easily change a block from not congested to
congested; hence this scheme is also easily manipulable.

– By non-zero-fee transaction occupancy (”block size”): A block is γ-congested
if it is full at γ-fraction of its occupancy with non-zero-fee transactions:
(cid:80)
tx∈B: φ(tx)>0 w(tx) ≥ γ · B. A miner could artiﬁcially add transactions

with positive fee density to ﬁll the block at no cost.

– By transaction fees (instead of fee density): A block is (f ,γ)-congested if at
least a fraction γ of it is ﬁlled with transactions with fees above some value
f : (cid:80)
tx∈B:φ(tx)·w(tx)≥f w(tx) ≥ γ · B. A miner could prioritize transactions
by their size in order to decide the congestion signal, without lowering his
proﬁt from the fees (UB).

Sliding Window Challenge Process for Congestion Detection

23

C Code

contract BlockchainMock {

// Simulate block.basefee(). EVM only fetches the current basefee.
struct Block { uint baseFee; }
Block[] public blocks;

// Should the caller consider this block congested?
function isCongested(uint blockNumber, uint maximumBaseFee)
public view returns (bool) {

if(blocks[blockNumber].baseFee > maximumBaseFee) {

return true;

}

return false;

}

}

contract Auction is SlidingWindow {

bool start = false;
uint startBlock;
uint k;
uint n;
uint gasPriceCeiling;

function startAuction(uint startBlock, uint k, uint n,
uint gasPriceCeiling) public {
startBlock = startBlock;
k = k;
n = n;
gasPriceCeiling = gasPriceCeiling;
start = true; // Kick-start the auction!

}

function finaliseAuction() public returns(bool) {

if(isPeriodCongested(startBlock, k, n, gasPriceCeiling)) {

return false;

}

return true;

}

}

24

A. Lotem et al.

contract SlidingWindow is BlockchainMock {

function isPeriodCongested(uint startBlock, uint k, uint n,

uint maximumBaseFee) public view returns (bool) {

require(n>=k, ‘N should be greater than or equal to K.’);
require(blocks.length>=n, ‘Total should be greater than or equal to N.’);

uint totalCongested = 0;
bool[] memory recordCongestion = new bool[](blocks.length − startBlock);

for(uint i=startBlock; i < startBlock+n; i++) {
// Keep a record of this block’s congestion.
recordCongestion[i] = isCongested(i, maximumBaseFee);

// Sum of congestion (so far).
if(recordCongestion[i]) {

totalCongested = totalCongested + 1;

}

if(totalCongested>=k) {

return true;

}

}

// Activate the sliding window.
for(uint i=startBlock+n; i<blocks.length; i++)

// Remove start of the window.
if(recordCongestion[i-n] {

totalCongested = totalCongested - 1;

}

Keep a record of this block’s congestion.
recordCongestion[i] = isCongested(i, maximumBaseFee);

// Add to the end of the window.
if(recordCongestion[i]) {

totalCongested = totalCongested + 1;

}

if(totalCongested>=k) {

return true;

}

// Not congested.
return false;
}

}

