1
2
0
2

p
e
S
8

]

R
C
.
s
c
[

1
v
3
1
9
3
0
.
9
0
1
2
:
v
i
X
r
a

BMS: Secure Decentralized Reconﬁguration for Blockchain and
BFT Systems

Selma Steinhoff
ETH Zurich*

Chrysoula Stathakopoulou
IBM Research Europe - Zurich
ETH Zurich

Matej Pavlovic
IBM Research Europe - Zurich

Marko Vukoli´c
Protocol Labs*

Abstract

Reconﬁguration of long-lived blockchain and Byzan-
tine fault-tolerant (BFT) systems poses fundamental se-
curity challenges.
In case of state-of-the-art Proof-of-
Stake (PoS) blockchains, stake reconﬁguration enables
so-called long-range attacks, which can lead to forks.
Similarly, permissioned blockchain systems,
typically
based on BFT, reconﬁgure internally, which makes them
susceptible to a similar “I still work here” [6] attack.

In this work, we propose BMS (Blockchain/BFT Mem-
bership Service) offering a secure and dynamic reconﬁg-
uration service for BFT and blockchain systems, prevent-
ing long-range and similar attacks. In particular: (1) we
propose a root BMS for permissioned blockchains, imple-
mented as an Ethereum smart contract and evaluate it re-
conﬁguring the recently proposed Mir-BFT protocol [23],
(2) we discuss how our BMS extends to PoS blockchains
and how it can reduce PoS stake unbonding time from
weeks/months to the order of minutes, and (3) we discuss
possible extensions of BMS to hierarchical deployments
as well as to multiple root BMSs.

1 Introduction

Blockchain systems are conceived as long-lived systems,
implemented typically by a set of nodes (called e.g., min-
ers, validators) who participate in consensus on system

*Work done in IBM Research Europe - Zurich

state. More lightweight client nodes (e.g., wallets) oc-
casionally access blockchain nodes, e.g., when a client
wishes to submit an operation to the blockchain.
In a
long-lived system, this leads to a fundamental security
challenge: how can a client, who might have been dis-
connected for a while, trust the state of the system?

To visualize the issue, consider the illustration in Fig-
ure 1. In this example, the initial membership (conﬁgu-
ration C0) comprising nodes A, B, C and D has reconﬁg-
ured entirely to a new conﬁguration C2 which includes no
nodes from C0 (Fig. 1a). A client that reconnects only
occasionally to the blockchain system may have not been
updated about changes in the system membership, and re-
connect to the initial conﬁguration C0 (Fig. 1b). How-
ever, the initial conﬁguration might be entirely corrupted
by the adversary as realistic blockchain systems limit as-
sumptions on the power of the adversary only with respect
to their current conﬁguration.

This issue affects all blockchain systems, whether they
are based on Proof-of-Work (PoW), on Proof-of-Stake
(PoS), or are permissioned. In PoS blockchains, the ad-
versary can at this point mount a long-range attack [11, 7]
fabricating a blockchain history which the client cannot
distinguish from the “real” one. A similar attack is known
in permissioned blockchains and Byzantine fault-tolerant
(BFT) systems as the “I still work here” attack [6].

While the issue depicted in Figure 1 affects PoW
blockchains as well, these can rely — unlike PoS and
permissioned blockchains — on the longest chain selec-
tion rule [21]. This, together with ever growing miner

1

 
 
 
 
 
 
(a) Client communicates with initial conﬁguration C0 which then transitions, perhaps gradually, to con-
ﬁguration C2 (steps 1-4).

(b) When client reconnects, the initial conﬁguration C0 may be entirely corrupted by the adversary (step
5).

Figure 1: Illustration of the long-range (“I still work here”) family of attacks.

hashing power in established networks such as Bitcoin
and Ethereum, enables nodes of the current conﬁgura-
tion to (eventually) convince the client of their legiti-
macy. This powerful security feature of PoW blockchains
presents their critical advantage over PoS and permis-
sioned blockchain systems.

In PoS systems, long-range attacks are typically par-
tially addressed by making validators bond their stakes
for a very long time (stake unbonding or “thawing” time,
which is often several weeks [5] or more) with slashing
mechanisms to discourage adversarial behavior. Other ap-
proaches require clients to periodically synchronize with
changes in the membership set [7]. As for permissioned
blockchains, they typically reconﬁgure internally and are
as such entirely vulnerable to this type of attacks.

In this paper, we take a different approach and propose
a general decentralized solution for secure and dynamic
reconﬁguration for blockchain and BFT distributed sys-
tems. This paper presents the following key contributions:

1. We propose BMS, a Blockchain / BFT Membership
Service for permissioned blockchains and BFT systems
which prevents the “I still work here” attack by leverag-
ing a (root) BMS implemented as a smart-contract on a
public permissionless PoW blockchain. Members of the
BFT distributed system push membership updates to the
BMS; the new membership is accepted and published by
the BMS once a qualiﬁed number of nodes of the recon-
ﬁgured system approve (vote for) the change. Our BMS
allows the new permissioned blockchain nodes to pay fees
for joining and leaving the system. These fees are dis-

2

tributed among voting nodes to cover the cost of pushing
membership updates to the BMS and create incentives for
protocol participation.

2. We implement a BMS prototype as a smart-contract
on the Ropsten Ethereum testnet [4] and use it with the
Mir-BFT protocol [23]. We evaluate the latency and cost
of our reconﬁguration scheme for increasing system sizes
up to 100 nodes. We also evaluate the impact of different
reconﬁguration policies.

3. Finally, we discuss how to extend our BMS from per-
missioned to PoS blockchains to prevent the long-range
attack, where BMS can considerably reduce the stake un-
bonding (“thawing”) time. We also discuss possible ex-
tensions of BMS to hierarchical deployments (akin to In-
ternet DNS) as well as to multiple root BMSs.

In the rest of this paper, we present the system model
(Section 2), give an overview of BMS (Section 3), present
the details of our protocols (Section 4), evaluate our BMS
prototype implementation (Section 5), discuss PoS and
other extensions of BMS (Section 6), and compare BMS
to related work (Section 7).

2 System Model

We consider a message-passing system and an

eventually synchronous network [12] in which mes-
sages sent between any processes before an (unknown)
Global Stabilization Time (GST) can be delayed arbitrar-
ily or dropped. However, messages sent between correct
processes after GST are guaranteed to have bounded de-
lay.

We deﬁne a reconﬁgurable distributed Byzantine fault-
tolerant system (referred to, simply, as the BFT system)
as any distributed system composed of multiple member
nodes that execute a distributed application. We assume
that a certain fraction (see below) of the nodes can be
Byzantine faulty [17], but even faulty processes cannot
compromise standard cryptographic primitives such as se-
cure hash functions. We model the application as a repli-
cated state machine [22] across these nodes. The appli-
cation state can be updated through requests that clients
submit to the system (by sending request messages to the
member nodes). Each node maintains a copy of a totally
ordered log of such requests and applies them to its copy
of the application state in log order.

The BFT system being reconﬁgurable means that the
set of its member nodes, that we call the conﬁguration,
may dynamically change. The system starts in an initial
conﬁguration C0 that all nodes and all clients are aware
of. During operation, the system passes through a se-
quence of conﬁgurations C0, C1, C2, . . . and so on, as
nodes join and leave the system. We assume that the
BFT system reconﬁgures autonomously by maintaining
its conﬁguration alongside its application state. A transi-
tion from Ck to Ck+1 happens at agreed-upon positions
in the request log that we call checkpoints. All nodes use
conﬁgurations Ck and Ck+1 for ordering requests that oc-
cur in the log respectively before and after the checkpoint.
In a conﬁguration C, we assume that up to f (C) < |C|
3
nodes can be Byzantine faulty, if C is the last conﬁgura-
tion or if no newer conﬁguration has been published by
the BMS, or if a newer conﬁguration has been published
only recently. “Recently” means before time P (publish-
ing time) has elapsed since publishing the new conﬁgura-
tion by BMS.

Here we need to slightly depart from the standard def-
inition of a correct node as one that never misbehaves.
Instead, we regard node q as correct even if q misbehaves,
as long as this happens P units of time after the BMS pub-
lishes a conﬁguration q is not part of any more. We call a
node that is not correct faulty.

We further assume that a correct client’s view of the
BMS state is not older than P whenever the client inter-
acts with the BFT system. Note that, without BMS, the
client might be required to maintain a sufﬁciently up-to-
date view of the BFT system’s conﬁguration at all times
(not just while interacting with the BFT system), as is the
case in other systems [7, 16]. Weakening this requirement
is an important part of this paper’s contribution.

In order to interact with the BFT system, clients must
be aware of the BFT system’s current conﬁguration. We
only assume, however, that clients are aware of the initial
conﬁguration C0, and it is the protocol’s responsibility to
keep clients’ view of the conﬁguration up to date.

In addition to the BFT system (that implements a repli-
cated state machine), we assume the existence of another
external public state machine replication (SMR) service
that is reliably discoverable. This means that a client
can securely use the service without any prior informa-
tion about the system other than what is public knowl-

3

edge. Ethereum is an example of such an SMR system,
since, as a PoW system, it does not suffer from long-range
attacks. We use this external SMR system to implement
BMS.

3 Overview of BMS

On a high level, the system is composed of two parts: (1)
the BFT system itself, and (2) the reconﬁguration service
(BMS), tracking the membership of the former.

A client accessing the BFT system is required to know
its conﬁguration (network addresses, keys, etc.). A cru-
cial property of BMS is that it is accessible without any
prior knowledge about the identities of the nodes running
it. Public PoW-based blockchain systems like Ethereum
satisfy this property.
If the reconﬁguration service has
the form of an Ethereum smart contract (as in our im-
plementation), the identity of this smart contract can be
considered the identity of the whole system, as it is the
only information needed to bootstrap interaction with our
system.

In a nutshell, a client that needs to connect to the BFT
system ﬁrst reliably obtains an up to date conﬁguration of
the BFT system from the BMS. The client then submits
its requests to the BFT system.

In the following, we describe the state machines ex-
ecuted by the respective distributed systems and their in-
teraction. We ﬁrst describe a simpliﬁed version of the sys-
tem (Sec. 3.1 and 3.2). Then, we reﬁne it to account for
a potential performance bottleneck imposed by the recon-
ﬁguration service and real-world cost of using the recon-
ﬁguration service—in our case of Ethereum, the Gas cost
of transactions (Sec. 3.3).

3.1 Reconﬁguration Service

The reconﬁguration service is a state machine executed by
a system whose identity is public knowledge and is hard
to forge. A public PoW-based permissionless blockchain
platform like Ethereum is an example of such a system.

BMS does not necessarily need to be implemented on
Ethereum, it is only important that BMS is able to exe-
cute the logic of a state machine driven by client requests,
often called transactions. For clarity, we use the term “re-
quest” for requests submitted to the BFT system, while

we refer to operations invoked on BMS as “transactions”.
The state of BMS consists of the conﬁguration of the
BFT system, initialized to its initial conﬁguration. This
conﬁguration can only be updated if sufﬁciently many
members of it submit a speciﬁc transaction (that we call a
vote) containing the same new conﬁguration. For conﬁg-
uration Ci stored at the BMS, “sufﬁciently many” corre-
sponds to f (Ci) + 1, guaranteeing that at least one of the
voting nodes is correct. Only members of Ci can act as
voting clients to BMS. The service ignores all votes not
signed by members of Ci.

As soon as the service receives enough votes for a new
conﬁguration Cj, it replaces the old conﬁguration Ci with
Cj and waits for new votes (this time from nodes in Cj)
before it updates the conﬁguration again. Any process
can, however, query the reconﬁguration service for the
current conﬁguration. This is used by new nodes join-
ing the BFT system and clients (of the BFT system) that
want to submit requests to the BFT system.

3.2 Reconﬁgurable BFT System

The BFT system implements a replicated state machine.
The state of this state machine also includes (in addition
to the state of the executed application) the BFT system’s
conﬁguration, i.e., the identities (network addresses, pub-
lic keys) of the nodes executing it. The state of the state
machine is updated by processing an ordered log of re-
quests submitted by clients. In order to join the system, a
node ﬁrst acts as a client to the BFT system and submits
a special reconﬁguration request.

The nodes in the current membership treat this request
as they would any other client request, until two condi-
tions are satisﬁed: (1) the reconﬁguration request is in-
serted in the request log and all preceding requests have
been processed, and (2) the BMS is up to date, i.e., the
current conﬁguration is reﬂected in the state of the recon-
ﬁguration service.

Once both conditions hold, the BFT system reconﬁg-
ures. This comprises each node updating the current con-
ﬁguration in its local state to a new one and sending a
response to the joining node. The response contains all
information the joining node needs to start executing the
BFT protocol: the application state, the new conﬁgura-
tion, and all protocol-speciﬁc data. We use an analogous
procedure for nodes leaving the system.

4

After the BFT system reconﬁgures, each node in the old
conﬁguration (the one still saved by the reconﬁguration
service) acts as a client to the reconﬁguration service and
submits its vote (as a transaction to BMS) with the new
conﬁguration (see also Sec. 3.1).

3.3 Batching and Incentives

Our BMS is intended to be hosted on a public PoW
blockchain platform like Ethereum. However, such plat-
forms usually imply high transaction latencies (minutes
to hours) and a real-world cost in form of transaction fees
(expressed as “Gas” in Ethereum). This has major impli-
cations on the reconﬁguration protocol as described so far:
(1) churn (i.e. the rate at which nodes can join and leave
the BFT system) is limited to the inverse of the transac-
tion latency, and (2) a join or leave event of a node incurs
additional ﬁnancial cost for the other members of the con-
ﬁguration that send their vote transactions to the recon-
ﬁguration service and have to assume the corresponding
transaction fees.

In the following, we present two modiﬁcations to the al-
gorithm described above that (1) enable higher churn rates
in exchange for stronger failure assumptions (batching)
and (2) make each node bare the transaction fees result-
ing from its joining and leaving the system (incentives).

3.3.1 Batching Updates to BMS

In order to allow higher churn, the BFT system need not
notify the reconﬁguration service about every single con-
ﬁguration change. Instead, the BFT system may recon-
ﬁgure locally, without pushing all conﬁgurations to BMS,
and only when the conﬁguration of the BFT system be-
comes “too different” from the one stored by BMS, or
only when a certain amount of (logical) time passes1, the
BFT system updates the BMS state.

As we do not expect nodes which left the system to
participate in voting, there always needs to be a sufﬁ-
cient overlap between the last published conﬁguration and
the local conﬁguration of the BFT system. Otherwise the
BFT system looses the ability to publish new conﬁgura-
tions to the BMS. Since f (Ci) + 1 correct nodes of the

1Logical time in a BFT system can be expressed in the number of
requests processed, while enforcing a minimal request rate by injecting
special “noop” requests as necessary.

last published conﬁguration Ci are necessary for updat-
ing the BMS state, we require for any subsequent un-
published local conﬁguration Cj of the BFT system that
|Ci ∩ Cj| ≥ f (Ci) + f (Cj) + 1. This way, even if all
f (Cj) nodes in Cj misbehave, Cj will still contain suf-
ﬁciently many (f (Ci) + 1) correct nodes to update the
BMS state.

In practice, this can easily be implemented if the state
machine executed by the BFT system keeps track of the
number of join / leave events that occurred since it pushed
the last conﬁguration to BMS. As long as this number is
below a conﬁgured threshold t (i.e., not “too different”),
the BFT system does not enforce condition (2) of Section
3.2 and it does not notify the reconﬁguration service. The
simpliﬁed case described so far corresponds to t = 1,
where even a single join/leave event is always announced
to BMS.

The threshold t is limited by the required overlap be-
tween the last published conﬁguration Ci and the local
conﬁguration Cj of the BFT system, as discussed above.
As conﬁguration Ci is, by assumption, only guaranteed to
contain |Ci| − f (Ci) correct nodes, no more than |Ci| −
f (Ci) − (f (Ci) + 1) = |Ci| − (2f (Ci) + 1) correct nodes
can leave the system before updating the published con-
ﬁguration becomes impossible. This, together with the
consequences of always maintaining more than two thirds
of honest nodes in every individual conﬁguration, leads to
a bound t ≤ (cid:98)3/2 · f (Ci)(cid:99) + 1 + ((|Ci| − 1) mod 3)2.
In particular, for conﬁgurations with an optimal size with
respect to fault tolerance, where |Ci| = 3 · f (Ci) + 1, this
translates to t ≤ (cid:100)|Ci|/2(cid:101).

Increasing t also results in an according increase of the
period during which a departing node is assumed to not
misbehave. This is implied by the assumption that less
than one third of nodes misbehave in every conﬁguration
until a newer conﬁguration is published by the BMS (plus
the publishing time P ). In other words, we assume se-
quences of t consecutive conﬁgurations such that in each
of those conﬁgurations no more than one third of nodes
misbehave until the last of those conﬁgurations is pub-
lished by the BMS.

2The term ((|Ci| − 1) mod 3) accounts for conﬁgurations Ci with
|Ci| > 3 · f (Ci) + 1. Those conﬁgurations contain one or two “ad-
ditional” nodes that contribute to a greater system size |Ci|, but are not
sufﬁcient to enable tolerating an additional node failure.

5

3.3.2 Transaction Costs and Incentives.

To make each node pay for the cost pertaining to its recon-
ﬁguration operations, we add a registration mechanism to
BMS, where we require each node joining the system to
pay a registration fee. The BMS then uses this fee to reim-
burse members of the BFT system for their voting trans-
actions.

The form of the registration fee is platform-dependent
and is expressed in the same way as the cost of executing
transactions on that platform. In the case of Ethereum, for
example, the cost of executing a transaction is measured
in Gas (or Ether, that can be converted to Gas), and so is
the registration fee. To register, the joining node trans-
fers the registration fee to the smart contract implement-
ing BMS.

Only after the joining node is registered with the BMS,
it submits its reconﬁguration request to the BFT system.
The BFT system only handles the reconﬁguration request
after verifying that the joining node has registered with
BMS and paid the registration fee. When it comes to
voting on the new conﬁguration that includes the join-
ing node, BMS reimburses the voting members using the
joining node’s registration fee. Concretely on Ethereum,
the voting transaction performed by a member of the BFT
system also induces a transfer of an appropriate part of the
joining node’s registration fee from the smart contract to
the voting member’s Ethereum account.

The registration fee is not fully redistributed to voting
members during the process of joining. The reconﬁgura-
tion service retains part of the registration fee to analo-
gously cover the costs associated with a node leaving the
BFT system.

4 Algorithm Details

This section presents the protocols of our system in detail.
Algorithm 1 describes the logic of the state machine im-
plementing the reconﬁguration service (BMS) itself. Al-
gorithm 2 deﬁnes the extension to the BFT system for in-
teraction with joining/leaving nodes and the reconﬁgura-
tion service. It is executed by each member of the BFT
system in addition to the protocols implementing the BFT
system itself.

The interaction between MBS and the BFT system is

depicted in Figure 2 using an example execution of a new
node joining the BFT system.

We assume that all nodes have access to the state of the
reconﬁguration service.
In particular, for an Ethereum-
based implementation of BMS, each node is assumed to
run its own Ethereum client (or use a proxy). We also as-
sume that all messages and requests are authenticated us-
ing an appropriate authentication mechanism, e.g., public-
key cryptography.

4.1 BMS Algorithm (Algorithm 1)

BMS stores the conﬁguration Ci of the BFT system
and the parameter cost which speciﬁes the registra-
tion fee. BMS is public, so anyone can read its state
and learn the conﬁguration Ci of the BFT system. A
read operation from a process to the reconﬁguration ser-
vice has the form (cid:104)CONFIG-REQUEST(cid:105) and returns
a (cid:104)CONFIG-RESPONSE, Ci(cid:105), where Ci is the stored
conﬁguration. We omit this part in the pseudocode for
brevity.

BMS records registration transactions sent by joining
nodes (lines 14-16). A registration transaction from node
p has the form (cid:104)REGISTER, p, a(cid:105), where a indicates the
amount of cryptocurrency that is transferred to BMS with
the transaction. A REGISTER transaction is only con-
sidered by BMS if a ≥ cost.

The conﬁguration Ci stored in BMS can be updated to
a new conﬁguration Cj, j > i, in a process that we call
“voting”. To update the conﬁguration, a threshold of vi =
f (Ci)+1 nodes from Ci need to send a vote proposing the
same new conﬁguration Cj to BMS. A vote from a node p
has the form (cid:104)VOTE, Cj, p(cid:105), where Cj contains the node
identiﬁers (including public keys) of all members of the
new conﬁguration. BMS only accepts a VOTE from a
node p if p ∈ Ci, i.e., if p is member of the currently
stored conﬁguration (line 19). Only a single vote per node
per conﬁguration is possible (line 20).

Once BMS has recorded vi VOTE transactions for a
new conﬁguration Cj (line 22), it rewards the participat-
ing voters (line 29) and updates the stored conﬁguration
Ci to Cj (line 31). The joining fees collected through reg-
istrations of nodes which are now included in (or excluded
from) the new conﬁguration are distributed evenly among
the nodes that voted for the accepted conﬁguration.

6

Figure 2: Execution of our protocol for adding a new node to the conﬁguration. The BFT system’s conﬁguration Ck
transitions to conﬁguration Ck+1, augmented by the joining node. The transfers of funds within the reconﬁguration
service happen on processing the “Register” transaction (from the joining node’s account to the BMS smart contract)
and on updating the stored conﬁguration (from the smart contract to the accounts of nodes which voted for Ck+1).

4.2 Extensions to the BFT System

4.2.1 Submitting Reconﬁguration Requests

When a node p wants to join the BFT system, it ﬁrst
reads the last published conﬁguration Ci from BMS and
registers as described in Section 4.1. Node p then ob-
tains a proof of registration. To this end, p sends a
(cid:104)REGISTER-ANNOUNCE, p(cid:105) message to all nodes
q ∈ Ci of the BFT system. Each member q of the BFT
system receiving such a message waits until it observes
p’s registration in the BMS state and responds to p with
a (cid:104)REGISTER-CONFIRM, p, σq(cid:105) message, with σq be-
ing q’s signature. A set of f (Ci)+1 such signed conﬁrma-
tions that p obtains constitute a valid proof of registration.
The joining node p then (acting as a client of the
BFT system) submits a special reconﬁguration request
(cid:104)JOIN-REQUEST, pr(cid:105) to the BFT system. The recon-
ﬁguration request contains the previously obtained proof
of registration pr.
Its purpose is to convince members
of the BFT system that p indeed registered (and paid the

registration fee), even if some nodes have not yet ob-
served p’s registration directly in the reconﬁguration ser-
vice. Join requests with invalid pr are ignored by correct
nodes.

Similarly, a node p that is currently member of the BFT
system and wants to leave, submits a leave request of the
form (cid:104)LEAVE-REQUEST, p, σp(cid:105) (acting as a client to
the BFT system). The signature of the leaving node is
necessary to prevent malicious nodes from evicting cor-
rect ones. Members of the BFT system ignore leave re-
quests with invalid signatures. Alternatively, if the BFT
system possesses a mechanism for detecting misbehav-
ing nodes, a node different from p can submit a request
(cid:104)LEAVE-REQUEST, p, P oM (p), (cid:105), where P oM (p) is
a Proof of Misbehavior of node p. This way, misbehaving
nodes may actively be evicted from the system.

7

v

cost

number

Ccur ← C0
Registrations ← ∅
V otes ← {}

Algorithm 1 BMS
1: Parameters:
2:
3:
4: Struct Conf iguration contains
5:
6: members
7:
8:
9: Init:
10:
11:
12:
13:
14: upon receiving (cid:104)REGISTER, id, f ee(cid:105)
15:
such that f ee ≥ cost do
16:
17:
18: upon receiving (cid:104)VOTE, C, p(cid:105) from p
19:
20:
21:
22: upon ∃C : C.number > Ccur.number ∧ |V otes[C]| ≥ Ccur.v
23:
24:
25:
26:
27:
28:
29:
30:
31:

reward ← 0
for all r ∈ Registrations : r.id ∈ (C(cid:52)Ccur) do

such that p ∈ Ccur.members do
V otes[C] ← V otes[C] ∪ {p}

Registrations ← Registrations ∪ {r}

transfer (reward/|V otes[C]|) to p

reward ← reward + (r.f ee/2)

for all p ∈ V otes[C] do

Ccur ← C

(cid:46) Joining fee

(cid:46) Conﬁguration number
(cid:46) List of member identiﬁers
(cid:46) Threshold of votes for accepting the next conﬁguration

(cid:46) Current conﬁguration
(cid:46) Set of valid registrations
(cid:46) Map from conﬁgurations to sets nodes voting for them

(cid:46) Store registrations

(cid:46) Store votes

(cid:46) Compute reward ((cid:52) denotes symmetric set difference):
(cid:46) For each joining or leaving node
(cid:46) Add half of registration fee to reward

(cid:46) Reward voters

(cid:46) Update conﬁguration

4.2.2 Handling Reconﬁguration Requests

(Algo-

rithm 2)

The BFT system’s replicated state contains, along with
the application state, its current conﬁguration Ccur. Note
that Ccur might be “ahead” of the conﬁguration stored
by the reconﬁguration service (in case the conﬁguration
service has not yet been updated). The BFT system also
keeps track of all the nodes’ local views of the conﬁgura-
tion stored by BMS3 (line 15). For this data to be consis-
tent across all nodes, they must agree on it before updat-
ing their copies of the BFT system’s state (lines 35-39).
We model the agreement by using a total order broad-
cast (TOB) abstraction, some form of which every BFT
system possesses. To account for f (Ccur) faulty nodes,
we deﬁne the latest conﬁguration stored in the BMS that
the BFT system observed as the one observed by at least

3If the reconﬁguration service is implemented as an Ethereum smart
contract, each node observes progressively newer states of the reconﬁg-
uration service by downloading more and more blocks of the Ethereum
blockchain. This happens independently at each member of the BFT
system.

Finally,

f (Ccur) + 1 nodes of the current conﬁguration (line 54).
the BFT system also stores a queue of
pending reconﬁguration requests (JOIN-REQUEST or
LEAVE-REQUEST) submitted by joining and leaving
nodes (line 14). The nodes also keep this queue consis-
tent by agreeing on its content using TOB (lines 21-33).
They also discard invalid requests before inserting them
in the queue (lines 28 and 32). For brevity of the pseu-
docode, we assume that each request is delivered at most
once by TOB, even if broadcast by multiple nodes.

Once the BFT system reaches a state where the queue
of reconﬁguration requests is not empty and the conﬁgu-
ration stored in BMS is not too different from the current
conﬁguration, the BFT system processes the ﬁrst pending
reconﬁguration request and transitions to a new conﬁg-
uration that reﬂects the processed request (lines 41-48).
We measure the difference between two conﬁgurations
Cj and Ci as their symmetric difference (Ci(cid:52)Cj), which
corresponds to the number of reconﬁguration requests that
need to be applied to Ci in order to obtain Cj. We con-
sider two conﬁgurations too different if their difference
reaches a threshold t, which is a system parameter. In our

8

(cid:46) The node id
(cid:46) Tolerated difference between local conﬁguration and current conﬁguration in BMS
(cid:46) Fault tolerance of the current conﬁguration

(cid:46) Set of signed registration conﬁrmations

(cid:46) Current conﬁguration
(cid:46) The last BMS conﬁguration the node voted for
(cid:46) Queue of pending valid join and leave requests
(cid:46) Map from conﬁgurations to sets of nodes that observed them

(cid:46) Check joining node registrations

(cid:46) Order join requests

(cid:46) Order leave requests

(cid:46) Check and enqueue
(cid:46) ordered join requests

(cid:46) Check and enqueue
(cid:46) ordered leave requests

(cid:46) Order own observations
(cid:46) of the BMS state

(cid:46) Register other node’s
(cid:46) observations of the BMS state

(cid:46) Reconﬁgure

(cid:46) Vote for updating the conﬁguration stored in BMS

conf irmations

T otalOrderBroadcast.Broadcast((cid:104)JOIN-REQUEST, p, pr(cid:105))

T otalOrderBroadcast.Broadcast((cid:104)LEAVE-REQUEST, p, σid(cid:105))

and ∃r ∈ BM S.Registrations : r.id = p do
send (cid:104)REGISTER-CONFIRM, p, σid(cid:105) to p

Ccur ← C0
ClastV oted ← C0
P endingRequests ← empty queue
ObservedConf ig ← {}

Algorithm 2 Reconﬁguration Protocol
1: import T otalOrderBroadcast
2: import BMS
3: Parameters:
4:
id
5:
t
6:
f
7:
8: Struct P roof Of Registration contains
9:
10:
11: Init:
12:
13:
14:
15:
16:
17: upon received (cid:104)REGISTER-ANNOUNCE, p(cid:105)
18:
19:
20:
21: upon receiving (cid:104)JOIN-REQUEST, p, pr(cid:105) do
22:
23:
24: upon receiving (cid:104)LEAVE-REQUEST, p, σp(cid:105) do
25:
26:
27: upon T otalOrderBroadcast.Deliver((cid:104)JOIN-REQUEST, p, pr(cid:105))
28:
such that V alidP roof Of Registration(pr) do
29:
30:
31: upon T otalOrderBroadcast.Deliver((cid:104)LEAVE-REQUEST, p, σp(cid:105))
32:
33:
34:
35: upon change of BMS.Ccur do
36:
37:
38: upon T otalOrderBroadcast.Deliver((cid:104)BMS-CONFIG, C, p(cid:105)) do
39:
ObservedConf ig[C] ← ObservedConf ig[C] ∪ {p}
40:
41: upon length(P endingRequests) > 0 ∧ LastBM SConf ig()(cid:52)Ccur < t do
42:
43:
44:
45:
46:
47:
48:
49:
50: upon ClastV oted(cid:52)Ccur ≥ t do
51:
52:
53:
54: function LatestBMSConﬁg() :
55:
56:
57: function ValidProofOfRegistration(pr) :
58:
59:

Ccur.number ← Ccur.number + 1
req ← P endingRequests.dequeue()
if req = (cid:104)JOIN-REQUEST, p(cid:105) then

Ccur.members ← Ccur.members ∪ {p}
Respond to p

T otalOrderBroadcast.Broadcast((cid:104)BMS-CONFIG, BMS.Ccur, id(cid:105))

send (cid:104)VOTE, C, id(cid:105) to BMS
ClastV oted = Ccur

P endingRequests.enqueue((cid:104)LEAVE-REQUEST, p(cid:105))

P endingRequests.enqueue((cid:104)JOIN-REQUEST, p(cid:105))

Ccur.members ← Ccur.members \ {p}

if req = (cid:104)LEAVE-REQUEST, p(cid:105) then

such that V alidSig(σp) do

return C with highest C.number such that |ObservedConf ig[C] ∪ Ccur| ≥ f + 1

return |pr.conf irmations| ≥ f + 1 ∧ ∀c ∈ pr.conf irmations : V alidSig(c.σid)

9

evaluation we experiment with two different values for t:
1 and f (Ccur)/2, where f (Ccur) is the tolerated num-
ber of faulty nodes in the current conﬁguration4. To en-
sure that reconﬁguration requests can be handled, the BFT
system updates the conﬁguration stored in BMS when the
difference between its actual conﬁguration and the con-
ﬁguration stored in BMS reaches t (lines 50-52).

5 Evaluation

5.0.1 Experimental Setup.

For each node, we use a virtual machine provided by a
leading cloud provider, with 4 CPUs and 8 GB memory,
equipped with 1Gbps networking, running the Ubuntu
18.04 Linux distribution. For the BFT system we use Mir-
BFT [23] conﬁgured as shown in Table 1. We use the
hosted Ethereum node cluster Infura [3] to run the recon-
ﬁguration service on Ropsten [4], an Ethereum test net-
work. We evaluate primarily two aspects of our system:
joining latency (Sec. 5.1) and its cost (Sec.5.2).

Checkpoint Interval
Join Response Threshold
Number of Peers

20 s
ucur = f (Ccur) + 1
4 ≤ |Ccur| ≤ 100

Table 1: Mir-BFT conﬁguration parameters used in the
evaluation.
In Mir-BFT, reconﬁguration happens only
when the system internally creates a checkpoint of its
state.

5.1

Joining Latency

To evaluate the join latency for different system sizes, we
start with an initial conﬁguration C0 of Mir-BFT with
|C0| = 4 nodes. We then make the system gradually grow
by having new nodes join, one after the other, until the
system size reaches |C96| = 100 nodes in its 96-th con-
ﬁguration. We conﬁgure the system to update the BMS
state after each reconﬁguration. Only once the BMS state
is updated, we add the next node. The adding of a node

4For simplicity of implementation, we use the current conﬁgura-
tion and not the last published one for the computation of t. Using
t = Ccur/2 is clearly below the bound on t deﬁned in Section 3.3.1,
regardless of the difference between Ccur and the last published conﬁg-
uration.

consists of 4 phases that contribute to the total join la-
tency:

1. Transaction latency: The time between submission
of the registration transaction by the joining node to
BMS and the time this transaction becomes part of
the BMS state. We consider the transaction to be
part of the BMS state when it is included in a block
of the Ropsten Ethereum testnet.

2. Conﬁrmation latency: The time between the join-
ing node requesting registration conﬁrmation from
the current members of the BFT system and the time
when the joining node is able to send its join request
to the BFT system. This phase involves the current
members of the BFT system waiting for a sufﬁcient
number of blocks to consider the registration con-
ﬁrmed and sending a conﬁrmation message to the
joining node.

3. Ordering latency: Time it takes for Mir-BFT to or-

der the reconﬁguration request.

4. Checkpoint latency: Time between ordering the re-
conﬁguration request and the next internal check-
point at which Mir-BFT reconﬁgures and sends the
ﬁnal response to the joining node. We stop count-
ing when the joining node receives the ﬁnal response
from ucur = f (Ccur) + 1 nodes.

We measure the duration of these phases separately.
Figure 3 shows the results of one run from 4 to 100 nodes.
To speed up the experiment, we skip phase 2, as it can
be easily computed by multiplying the expected block
creation time by the number of conﬁrmation blocks and
adding one message round trip for the registration conﬁr-
mation by the BFT system nodes.

Transaction latency. The Ropsten Ethereum testnet has
an average block generation time of 15s with high vari-
ances. Additionally, the transaction acceptance rate ﬂuc-
tuates signiﬁcantly, e.g. due to network congestion [26],
as conﬁrmed by our measurements. We observe an aver-
age transaction latency of 27.7s with standard deviation
of 24.9s.

Conﬁrmation latency. To match Bitcoin security, we as-
sume that 37 Ethereum blocks are required to consider a
transaction conﬁrmed. An expected block creation time

10

Figure 3: Breakdown of join latency for increasing system size (with t = 1 policy). The dominating conﬁrmation
latency (of more than 9 minutes) omitted for better readability.

of 15s on the Ethereum network [2] thus results in a con-
ﬁrmation latency of 9.25min. The round-trip time for
the registration conﬁrmation messages between the join-
ing node and the members of the BFT system is on the
order of milliseconds and thus negligible. The conﬁrma-
tion latency by far dominates the total joining latency and
we omit it from Figure 3 for better readability.

Ordering and checkpoint latency. The latency of order-
ing a request in Mir-BFT is stable with increasing system
size and, with an average ordering latency of 0.95s, is not
an inﬂuencing factor of the total join latency. In our de-
ployment, Mir-BFT reaches a checkpoint every 20s. This
is, as expected, the upper bound on the checkpoint latency
that we observe. The checkpoint latency stays between 0s
and 20s as the request of a joining peer is, in the best case,
ordered right before the next checkpoint or, in the worst
case, right after a checkpoint.

5.2

Joining Cost

We now evaluate the cost associated with reconﬁguration
operations. Given that we implement our reconﬁguration
service as an Ethereum smart contract, the cost of execut-
ing associated transactions is measured in Gas. We ﬁrst
evaluate the Gas cost of a single voting transaction and
the total amount of Gas consumed by a conﬁguration up-
date. We then estimate as the cost for a single node to

join the BFT system both in terms of Gas and (using the
current conversion rate) in US dollars. This per-node join
cost corresponds to the registration fee the joining node
should pay.

We evaluate two policies for updating the conﬁgura-
tion stored by the reconﬁguration service. The policy is
expressed by the parameter t – the number of reconﬁgura-
tions of the BFT system after which it updates the recon-
ﬁguration service though the voting procedure. The ﬁrst
policy updates BMS on every reconﬁguration (t = 1).
The second policy updates BMS after f (Ccur)/2 recon-
ﬁgurations (t = f (Ccur)/2). Note that f (Ccur), the num-
ber of tolerated failures, depends on the current conﬁgu-
ration’s size, and so does t in this case.

Cost of a Single Vote Transaction. Figure 4a compares
the average amount of gas used by a single vote transac-
tion for t = 1 and t = f (Ccur)/2.

For t = 1, the average gas used for a single vote trans-
action decreases as the system size grows. This is be-
cause the ﬁrst vote transaction for a new conﬁguration re-
quires more Gas for initializing certain data structures in
the smart contract. The last vote necessary to update the
stored conﬁguration is also more expensive due to the ex-
tra computation induced by performing the conﬁguration
update. In a bigger system, this increased cost is amor-
tized over more simple vote transactions.

For t = f (Ccur)/2, the transaction cost remains the

11

(a) Average gas used by a single vote transaction.

(b) Total amount of gas used for a conﬁguration update, divided
by the joining peers included in the update for an increasing
system size.

Figure 4: Gas used by BMS with reconﬁguration policies t = 1 and t = f (Ccur)/2

same until the system is large enough for t to increase
from 1 to 2. This occurs at |Ccur| = 13, i.e., when t =
f (Ccur)/2 = (cid:98)((|Ccur| − 1)/3)(cid:99)/2 = 2. The update
itself being larger, it also requires more Gas to process
than in the case of t = 1. Note the sparser data points for
t = f (Ccur)/2 caused by the voting occurring once every
t reconﬁgurations rather than on every reconﬁguration.

Normalized Cost of a Conﬁguration Update. Figure 4b
shows the the amount of gas consumed by a conﬁgura-
tion update divided by the number of joining peers in
that update. We examine this value for an increasing
system size and the reconﬁguration policies t = 1 and
t = f (Ccur)/2.

We observe that the total amount of gas increases lin-
early with the system size for the reconﬁguration policy
t = 1. This is due to the increasing number of votes
v = f (Ci)+1 required to update the conﬁguration, where
Ci the last published conﬁguration. For t = f (Ccur)/2,
the amount of gas used for a conﬁguration update initially
corresponds to the results for reconﬁguration policy t = 1
since, as discussed above, t = f (Ccur)/2 = 1 in small
systems. For larger systems, however, the total cost of up-
dating the conﬁguration is divided by an increasing num-
ber of joining nodes and the per-node joining cost remains
low.

Price of Joining in US Dollars. We now approximate
the cost of adding a single node in US dollars based on
the Gas measurements presented in Figure 4b.

The Gas cost of a transaction is computed by multiply-

ing its Gas price with the amount of used Gas. As the Gas
price is speciﬁed by the transaction sender, we use the
current average gas price of 93.1 Gwei, determined using
Etherscan (26.08.2020) [13]. To convert our results from
Ether to US dollars, we use the current exchange rate of
1 Ether to 386.10 US dollars (26.08.2020) [1]. It should
be noted, however, that the exchange rate and average gas
rate ﬂuctuate heavily. Table 2 shows the gas cost for a
conﬁguration update per joining node for different sys-
tem sizes. The registration fee for joining nodes should
be calculated based on these values. For a system size of
|C| ≥ 19, the current joining cost is approximately 4$.

System Size Amount of Gas US Dollar
5.71
4.52
4.45
3.88
3.94
3.92
3.81
3.88
4.01
4.37

166640
131970
129952
113314
114913
114460
111179
113146
117102
127590

5
10
15
25
45
52
60
69
80
93

Table 2: Amount of gas and cost in USD for a conﬁgura-
tion update per joining node

In addition to the cost of joining, each node’s registra-
tion fee should also cover the cost of removal of that node

12

from the conﬁguration. Removing nodes from a conﬁg-
uration being analogous to adding new ones, the cost of
leaving is at most as high as the cost of joining. We
even expect leaving to be “cheaper” than joining, since
Ethereum reduces the gas consumption of a transaction
that frees storage space [25].

to lock as stake while joining is higher than the amount
returned to the node when leaving. The difference corre-
sponds to the registration fee. A node that proves to have
participated in the voting process can claim a part of this
fee. This approach does raise cryptocurrency exchange
considerations, that are out of the scope of this paper.

6 BMS for Proof-of-Stake Systems

and Extensions

Reconﬁguration of Proof of Stake Systems.
PoS
blockchain systems inherently reconﬁgure their valida-
tor sets through the process of “staking” and “destaking”
funds in native cryptocurrency. To generalize BMS to
PoS, we simply need to store in BMS, in addition to the
current conﬁguration, the amount of stake associated to
each validator (i.e. member). Each validator’s vote for a
new conﬁguration then has a weight proportional to the
size of the corresponding stake.

As discussed before, destaking blocks the funds for
weeks or months (“thawing time”),
in order to de-
incentivize former validators from acting maliciously to-
wards clients that still believe them to be part of the val-
idator set. This is necessary because a client has no re-
liable means of distinguishing between the new true val-
idator set and a set of former validators that started acting
maliciously. With BMS, however, the client can make this
distinction using the reconﬁguration service. Therefore,
no incentive is needed to keep old validators well-behaved
and they can reclaim their staked funds. The advantage of
using BMS instead of a long thawing time is thus twofold.
First, the destaking time reduces from weeks or months
(arbitrarily set threshold, during which all clients are as-
sumed to update their view of the validator set) to the
order of minutes, as in our evaluation (Sec. 5). Second,
long-range attacks, where a client reconnects “too late”,
are completely ruled out (unlike with—even very long—
thawing times).

Another advantage of using BMS with a PoS
blockchain is the possibility of rewarding nodes for in-
teraction with BMS in the native currency of the BFT
system. The interaction with BMS can be substantially
simpliﬁed, completely leaving out the registration of new
nodes. Instead, the amount of native currency a node has

Extensions: Hierarchical BMS and Multi-BMS. Con-
ceptually, BMS bears a similarity to Internet DNS (Do-
main Name System). Apart from serving a similar pur-
pose, BMS can even exhibit similar structural patterns.

Note that a ﬁxed-membership BFT system can be used
instead of Ethereum in our system, as a root BMS. Even
PoS and dynamic-membership BFT systems can be used,
as long as their conﬁguration is registered in another
BMS. Such hierarchy can have arbitrary many levels and
be rooted in a reliably discoverable system, that we call
root BMS (i.e., a PoW blockchain or static-membership
BFT system).

Moreover, analogously to the existence of multiple in-
dependent DNS services, the conﬁguration of a single
BFT system can rely on multiple independent BMS in-
stances. Upon reconﬁguring, the BFT system would cor-
respondingly update each of these BMSs. A client would,
depending on its trust in those reconﬁguration services,
use any / all / a quorum of them to learn about the conﬁg-
uration of the BFT system.

7 Related Work

Reconﬁguration of BFT Systems. Reiter [19] [18] in-
troduces a fundamental approach for reconﬁguration by
having the BFT system members agree on the next con-
ﬁguration with a 3-phase commit scheme. Later efforts
aim to improve the performance and scalability, e.g. by
optimizing fault-free execution [14], by having only a
subset of nodes run the reconﬁguration protocol [20],
or by sharding membership updates across different re-
gions [10]. Similarly, CommChain [24] blockchain ad-
dresses dynamic reconﬁguration by having the set of
nodes who run consensus, called deciders, periodically
add a conﬁguration block with the next set of deciders.
Such protocols, however, are vulnerable to “I still work
here” attack [6], that our BMS addresses, as joining and
reconnecting nodes are not aware of the current set of
nodes that implement the membership service.

13

Some BFT systems rely on centralization, e.g. require
a system administrator to initiate the reconﬁguration pro-
cesses [8]. Our solution replaces such centralized admin-
istrator with a decentralized BMS.

Prevention of Long-range Attacks. A number of de-
centralized solutions have been proposed to prevent long-
range and similar attacks in blockchain systems by intro-
ducing mechanisms to provide a ﬁnality layer. Casper
the Friendly Finality Gadget [9], is a PoS based over-
lay system that enables the ﬁnalization of blocks in PoW
Blockchains, e.g. Ethereum. Casper employs timestamps
to enable protocol participants to ignore conﬂicting chains
that revert ﬁnalized blocks. This approach, however, ad-
dresses a slightly different (though related) problem of ﬁ-
nality rather than preventing long-range attacks.
It still
suffers from the issue that clients must know the current
set of validators and thus go online frequently to track any
changes. Additionally, clients must verify the validator
set at least once against a trusted source when they ﬁrst
connect to the system.

rupted. Moreover, validators may join or leave the system
within minutes, only constrained by the latency of updat-
ing the BMS state.

Tendermint/Cosmos [16], a practical PoS system, cur-
rently employs a combination of measures to prevent
long-range attacks. Firstly, they make use of unbonding
periods during which a deposits is made non-transferable
to accounts. Secondly, the ﬁrst time a client connects to
the network, it must verify the state of the chain against
a trusted source, and thirdly, clients are required to re-
connect and track all changes in the validator set as at least
as frequently as the unbonding period. They have, how-
ever, also discussed other prevention mechanisms, e.g.,
that non-validator token holders become trusted validity
attestation sources for clients by posting their tokens as
collateral with a much longer unbonding period. Both
options suffer from long periods during which coins are
locked and require clients to frequently go online. Our so-
lution optimizes the thawing time and makes no assump-
tions on the up-time of clients.

A recent

theoretical

result by Kuznetsov and
Tonkikh [15] prevents the “I still work here” / long
range attack by using forward secure signatures, without
relying on a service external to the BFT system. The
nodes’ responses to all requests, however, must be
signed, which may create a computational performance
bottleneck in practical
implementations. Moreover,
while the proposed solution only makes sure that an old
conﬁguration is unable to compromise a (re-)connecting
client, our approach can leverage the reconﬁguration
service to bootstrap clients’ and joining nodes’ initial
views of the conﬁguration.

Another recent proposal for PoS is Winkle [7], which
leverages singed client transactions as weighted votes on
recent blocks. Blocks with a threshold of signatures con-
stitute checkpoints which cannot be equivocated even if
their validators become corrupted. However, checkpoints
require clients being active, which, given current Bitcoin
and Ethereum usage, translates to delays in the order of
months, even years. Even using delegation, checkpoint
delay remains in the order of hours or few days. More-
over, Winkle relies on the assumption that an adversary
cannot easily control a big number of clients. Our solu-
tion, on the other hand, does not rely on validation from
the clients and therefore clients can be arbitrarily cor-

14

References

[1] Coinbase:

Ethereum price. https://www.

coinbase.com/price, accessed: 26.08.2020

[2] The ethereum block chain explorer. https://
etherchain.org/charts/blockTime

[3] Infura. https://infura.io

[4] Ropsten. https://ropsten.etherscan.io

[5] Interchain

Cosmos
foundation:
https://blog.cosmos.network/
launch-communications-june-
community-update-e1b29d66338 (2018)

update.

[6] Aguilera, M.K., Keidar, I., Malkhi, D., Martin, J.P.,
Shraer, A.: Reconﬁguring replicated atomic storage:
A tutorial. Bulletin of the EATCS: The Distributed
Computing Column (October 2010)

[7] Azouvi, S., Danezis, G., Nikolaenko, V.: Winkle:
Foiling long-range attacks in proof-of-stake sys-
tems. IACR Cryptol. ePrint Arch. p. 1440 (2019),
https://eprint.iacr.org/2019/1440

[19] Reiter, M.K.: A secure group membership protocol.
IEEE Trans. Software Eng. 22(1), 31–42 (1996).

[20] Rodrigues, R., Liskov, B., Chen, K., Liskov, M.,
Schultz, D.A.: Automatic reconﬁguration for large-
scale reliable storage systems. IEEE Trans. Depend-
able Sec. Comput. 9(2), 145–158 (2012).

[21] S. Nakamoto: Bitcoin: A peer-to-peer electronic

cash system

[22] Schneider, F.B.:

Implementing fault-tolerant ser-
vices using the state machine approach: A tutorial.
ACM Comput. Surv. 22(4), 299–319 (1990)

[23] Stathakopoulou, C., David, T., Vukoli´c, M.: Mir-bft:
High-throughput bft for blockchains. arXiv preprint
arXiv:1906.05552 (2019)

[24] Vizier, G., Gramoli, V.: Comchain: A blockchain
with byzantine fault-tolerant reconﬁguration. Con-
currency and Computation: Practice and Experience
32(12), e5494 (2020)

[25] Wood, G.: Ethereum: A secure decentralised
generalised transaction ledger. Byzantium Ver-
https://ethereum.github.io/
sion,
yellowpaper/paper.pdf

[26] Zhang, L., Lee, B., Ye, Y., Qiao, Y.: Ethereum
transaction performance evaluation using test-nets.
In: European Conference on Parallel Processing. pp.
179–190. Springer (2019)

[8] Bessani, A.N., Sousa, J., Alchieri, E.A.P.: State ma-
chine replication for the masses with BFT-SMART.
In:
International Conference on Dependable Sys-
tems and Networks (DSN). pp. 355–362 (2014)

[9] Buterin, V., Grifﬁth, V.: Casper the friendly ﬁnality
gadget. arXiv preprint arXiv:1710.09437 (2017)

[10] Cowling, J.A., Ports, D.R.K., Liskov, B., Popa,
R.A., Gaikwad, A.: Census: Location-aware mem-
bership management for large-scale distributed sys-
tems. In: Voelker, G.M., Wolman, A. (eds.) 2009
USENIX Annual Technical Conference, San Diego,
CA, USA, June 14-19, 2009.

[11] Deirmentzoglou, E., Papakyriakopoulos, G., Pat-
sakis, C.: A survey on long-range attacks for proof
of stake protocols. IEEE Access 7, 28712–28725
(2019).,

[12] Dwork, C., Lynch, N., Stockmeyer, L.: Consensus
in the presence of partial synchrony. J. ACM 35(2).

[13] Etherscan:
chart.
gasprice, accessed: 26.08.2020

price
https://etherscan.io/chart/

Ethereum average

gas

[14] Kihlstrom, K.P., Moser, L.E., Melliar-Smith, P.M.:
The securering group communication system. ACM
Trans. Inf. Syst. Secur. 4(4), 371–406 (2001).

[15] Kuznetsov, P., Tonkikh, A.: Asynchronous Recon-
ﬁguration with Byzantine Failures. In: Attiya, H.
(ed.) 34th International Symposium on Distributed
Computing (DISC 2020). Leibniz International Pro-
ceedings in Informatics (LIPIcs), vol. 179, pp. 27:1–
27:17. Schloss Dagstuhl–Leibniz-Zentrum f¨ur Infor-
matik, Dagstuhl, Germany (2020).

[16] Kwon, J., Buchman, E.: Cosmos: A network of dis-
tributed ledgers. https://cosmos.network/
whitepaper, accessed: 12.08.2020

[17] Lamport, L., Shostak, R.E., Pease, M.C.: The
Byzantine generals problem. ACM Trans. Program.
Lang. Syst. 4(3), 382–401 (1982)

[18] Reiter, M.K.: Distributed trust with the rampart
toolkit. Commun. ACM 39(4), 71–74 (1996).

15

