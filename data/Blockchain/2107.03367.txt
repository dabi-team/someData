Building Stable Oﬀ-chain Payment Networks

MohammadAmin Fazli, Seyed Moeen Nehzati, MohammadAmin Salarkia

Sharif University of Technology, Tehran, Iran.

1
2
0
2

l
u
J

7

]
T
G
.
s
c
[

1
v
7
6
3
3
0
.
7
0
1
2
:
v
i
X
r
a

Abstract

Payment channel is a protocol which allows cryptocurrency users to route multiple transactions through network without committing
them to the main blockchain network (mainnet). This ability makes them the most prominent solution to blockchains’ scalability
problem. Each modiﬁcation of payment channels requires a transaction on the mainnet and therefore, big transaction fees. In
this paper, we assume that a set of payment transactions are given (batch or online) and we study the problem of scheduling
modiﬁciations on payment channels to route all of the transactions with minimum modiﬁcation cost.

We investigate two cost models for aforementioned problem: the step cost function in which every channel modiﬁcation has a
constant cost and the linear cost function in which modiﬁcation costs are proportional to the amount of change. For the step cost
function model, we prove impossibility results for both batch and online case. Moreover, some heuristic methods for the batch case
are presented and compared. For the linear cost we propose a polynomial time algorithm using linear programming for the batch
case.
Keywords: Payment Channels, Oﬀ-chain Payment Networks, Network Modiﬁcation, Scheduling

1. Introduction

A payment channel is a cryptocurrency transaction on blockchain

Recently, blockchain-based decentralized cryptocurrencies
like Bitcoin, Ethereum, and Zcash have got much popularity
In these decentralized cryptocurrencies, trans-
and attention.
actions don’t need to be managed by third parties [1], but the
problem with these currencies is their performance and scalabil-
ity. Since their transaction throughput is bounded by maximum
block size in the chain, they are not scalable for the high num-
ber of transactions [2]. For example, for bitcoin, the best known
bound for average transaction throughput is seven transactions
per second [3]. This value is an order of magnitude lesser than
the transaction rate in everyday payments, such as Visa cards.
Therefore, it will not be possible to use bitcoin in people’s daily
life. Moreover, this low transaction rate has resulted in compe-
tition between users to ﬁnalize their transactions faster, which
resulted in higher transaction fees.

Many solutions have been provided to solve the scalability
problem in blockchain networks. Kim et al. [4] and Zhou et al.
[1] provide surveys on these solutions. Some of these solutions
are on-chain methods, which try to solve the problem within the
main blockchain, for example, by modifying some elements in
the chain to increase the maximum block size. Other solutions
are non-on-chain methods such as oﬀ-chain, side-chain, cross-
chain, etc. These solutions use another network or chain to
improve scalability outside the blockchain. One of these non-
on-chain solutions, which was very promising in recent years,
is payment channels. With this solution, some transactions will
transfer to a temporary oﬀ-chain network to reduce the number
of transactions on the main chain. Lightning network for Bit-
coin and Raiden network for Ethereum are examples of such
payment channel networks.

that deposits some money on the blockchain for exchange be-
tween two speciﬁc users [5]. For instance, Alice can deposit 1
BTC into a multi-signature transaction (meaning that the sig-
natures of both parties is needed for withdrawing) for sending
to Bob. Setting up this transaction follows the common mecha-
nism of transactions on blockchain and needs to be committed
on main net. From now on, Alice can send money up to 1 BTC
to Bob as many times as she wants by sending signed transc-
tions from the deposit account. Bob can close payment channel
by signing the last transaction and broadcasting it into the main
net. This whole process just needs two commits on blockchain.
The ﬁrst one for setting up the payment channel and the second
one for closing it.

However, payment channels can only handle transactions
between two users. So, it won’t solve the scalability problem if
everyone has to set up a payment channel to another user to pro-
vide fast payments to him. For this purpose, oﬀchain networks
of payment channels are proposed [6]. With these networks,
This is where the Lightning Network comes up. With this net-
work, every two users can make transactions if there is a path
of payment channels between them.

In this paper, we target the problem of building stable pay-
ment networks. In this problem, every channel has a speciﬁc
deposit. That means it can route transactions with values less
than its deposit. We call this deposit channel capacity, and it
decreases with routing every transaction. Also, we assume that
every node in this network has a ﬁnite capital which means the
sum of channels’ capacities sourcing from that node must be
less than its capital. As a result, channels can’t have inﬁnite ca-
pacity. Every change in channel capacities needs a transaction
commit on the mainnet, and it is costly. In the target problem

Preprint submitted to Future Generation Computer Systems

July 8, 2021

 
 
 
 
 
 
of this paper, a network of payment channels and a set of trans-
actions on the network are given. Then, we want to schedule
capacity changes on payment channels to minimize the cost of
commitments on the mainnet.

To evaluate diﬀerent scheduling algorithms, we investigate
two cost models. The ﬁrst one is the linear cost model. In this
case, the change cost of a channel’s capacity is linearly depen-
dent on the value of the change. The second one is the step cost
model, which means the cost of capacity change is constant.
Moreover, we check out two cases for transactions: the batch
case and the online case. In the batch case, we assume that all
the input transactions are given at time zero. In the online case,
we suppose that at each time, we only know the next transac-
tion. This paper proposes a polynomial-time algorithm to ﬁnd
the optimum solution for the linear cost model and the batch
input case. For the step cost model and the batch input case, we
prove the NP-completeness of the solution. For the step cost
model and the online input case, we show no c-competitive al-
gorithm such that c ≤ δ, where δ is the maximum degree of
nodes in our network. Finally, we propose some heuristic al-
gorithms for the step cost model and the batch input case and
compare their performance in a simulation.

This section will explain payment channels and the payment
network concepts in more detail and then survey the literature.
In the next section, we will propose the formal statement of our
problem. After that, we will state the aforementioned theoreti-
cal results in ﬁnding optimum solutions. Next, we will present
our report on heuristic algorithms and their performance. We
will conclude this paper by reviewing the achievements made
in this paper and the possible future works.

1.1. Payment channels

The Payment channel can be mono-directional or bi-directional.

Imagine the case
First, let’s see the mono-directional form.
that Alice wants to open a payment channel with Bob with the
capacity of 1 BTC. She has to deposit this money in a multi-
signature address. All the transactions on this address need the
signature of both Alice and Bob to be performed. If Alice wants
to pay 0.1 BTC to Bob, she creates a transaction that gives 0.9
BTC from that speciﬁc address to Alice and gives 0.1 BTC to
Bob. She signs this transaction and gives it to Bob. Sometime
later, when Alice wants to pay another 0.2 BTC to Bob, she
writes a transaction that gives 0.7 BTC to herself and gives 0.3
BTC to Bob. Again, she signs this transaction and gives it to
Bob. Whenever Bob wants to withdraw his money, he can sign
the transaction (complete the needed signatures), and then, this
transaction will broadcast on the main blockchain and close the
channel. Note that he can’t commit any other transaction after
Bob has committed the last transaction. In Figure 1.1, you can
see this scenario.

The problem here is that if Alice wants her 0.7 BTC, she
depends on Bob’s action. Thus, there must be a deadline for
Bob to withdraw the money; otherwise, all the money will turn
back to Alice. A transaction that gives all the money to Alice
after some time will do this aim. Before Alice funds the ad-
dress, Bob will write and sign this transaction and gives it to
Alice. Then, Alice will fund the channel.

2

However, mono-directional payment channels do not look
promising because they only allow one-way payments. So there
is a need for bi-directional channels. In a bi-directional chan-
nel, both Alice and Bob create guarantee transactions and give
them to each other. After that, they both fund the channel, for
example, by Va and Vb values. Now, if Alice wants to pay Bob
v1, she can create a transaction that gives herself Va − v1 and
gives Bob Vb + v1, sign it and give it to Bob. Then, if Bob wants
to give Alice v2, he can write a transaction which gives Alice
Va − v1 + v2 and gives himself Vb + v1 − v2 and so on.

Since these channels (both mono-directional and bi-directional)

only need two transactions on the main blockchain (one for
opening and one for closing), they look very promising for solv-
ing the scalability problem of blockchain-based payments.

1.2. Payment Networks

Although payment channels need just two transactions on
the blockchain, if everyone has to create a payment channel
with another one, it doesn’t solve the scalability problem. Cre-
ating these many channels and closing them needs a lot of time
and locks many coins only for future payments. Here the so-
lution of payment networks comes up. Payment networks are
graphs in which users are the nodes, and payment channels be-
tween them are edges. If some user Alice wants to pay some
money to user Carol and there is a path between them in the
graph, they can do their transaction only if the value of the
transaction is less than the channels’ capacities in this path (See
Figure 1.2).

One of the main problems with payment networks is how
to incentivize intermediate nodes to route other nodes’ transac-
tions. This problem can be solved by giving a routing fee to all
users in the path. With routing fees, the users in the network
tend to create more channels with higher capacities to achieve
more fees.

Another problem with this network is that intermediate users
can steal the routing coins. Hash-locked contracts can prevent
this. Hash locked contracts are transactions that can only be
ﬁnalized by providing a speciﬁc proof. For instance, assume
Alice wants to pay Carol, and there is a path of length 2 (Alice-
Bob-Carol) between them. First, Carol has to generate a private
key and a public key and give the public key to Alice. Then, Al-
ice makes a transaction with Bob, which needs the private key
to be done. Also, Bob makes a similar transaction with Carol.
Now Carol provides the private key and does the transaction
between herself and Bob. After that, Bob will know the private
key, and he can also give the private key and do the transaction
between herself and Alice.

The Lightning Network is the payment channel network for
bitcoin. The Raiden Network is the Ethereum version. It is very
similar to the Lightning Network except that it supports diﬀer-
ent types of transactions while the lightning network supports
only bitcoin transactions.

1.3. Related Work
Kim et al.

[4], and Zhou et al.

[1] provide surveys on
solutions to the scalability problem on blockchain-based pay-
ments. As one of the most promising solutions, researchers

have proposed various payment channel protocols (networks)
which present how to create a payment channel [7, 8, 6, 9].
However, the current work is independent of channel proto-
cols and applies to all such solutions. The Lightning Network,
which is the most famous payment channel, was ﬁrst introduced
in [6].

Most of the optimization and algorithmic research works
done by a team resided in the ETH university. Avarikioti et al.
[10] study the optimal structure of the channels’ network and
the allocation of charges to them to maximize the proﬁt of the
payment service provider (PSP). In their other work [11], pro-
poses three optimization problems in the context of payment
network design. All of those problems are variants of the Gen-
eral Network Design problem. In this problem, a set of trans-
actions, a capital, and a proﬁt are given. The problem asks to
design a network and a strategy to route the transaction through
the network. The ﬁrst target problem gets a set of transactions
and asks whether it is possible to route all of them from a single
bidirectional channel between two users. The second problem
gets a set of transactions and asks to return a graph with the
minimum possible capital. The third problem receives a set of
transactions, a graph, and a capital and asks whether there is
a capital assignment to the graph’s edges that can route all the
transactions. They present hardness results and approximation
algorithms for the batch case of these three problems. For the
online case, they give an impossibility result for the ﬁrst prob-
lem and a competitive algorithm for the second problem.

The ETH team has also focused on some other aspects of
payment channels. For example, in [12], they explore the game
theory of payment networks. They assume that the users in
the network are selﬁsh players, and they compete to earn more.
Then study the Nash equilibrium of the network creation game,
which are the topologies that emerge from their interactions.
For investigating the topology, they consider betweenness and
closeness centrality as the central concept. At last, they deter-
mine the social optima for the network topology.

There are some other works targetting payment channels
and the Lightning Network. Most of these works are unre-
lated to this paper, but some of them are surveyed as exam-
ples. Sivaraman et al. [5] Claim that shortest-path routing is
not a good idea for routing transactions on payment networks
(because of the limited capacity of channels, some important
channels may get exhausted, and the system will stop work-
ing). Then, it provides a new routing solution of transactions
to achieve high throughput. Prihodko et al. [13] provide an-
other routing algorithm of transactions in the Lightning net-
work called Flare. Seres et al. [14] analyze the eﬀects of the
Lightning network’s topology on its security and its robustness
against failures and attacks. Herrera et al. [15] mention that the
precise balance of the pair of nodes in payment networks has to
be kept secret due to privacy problems. Then, they investigate
the problem of hiding this balance and having working routing
algorithms simultaneously and proposes an attack to reveal the
balance of a channel.

2. The Problem Statement

Here we will go with the formal deﬁnition of our problem.
We are given a payment network G = (V, E), Where V stands
for a set of nodes that are cryptocurrency users (more precisely,
addresses) and can have payment transactions between them-
selves. E is the set of G’s payment channels. Each e ∈ E, is a
directed pair e = (u, v), u, v ∈ V. These channels can be used
for money transfers. The capacity of each channel is deﬁned by
a function ce : T → R+, where T is the set of times. Without
loss of generality, we can assume that times are positive integers
from 1 to n, which means: T = {1, 2, ..., n}.

Deﬁnition 1. For every channel e ∈ E in graph G = (V, E)
the capacity of channel at time t is represented by ce(t), where
ce : T → R+ is the capacity function and T = {i|1 ≤ i ≤ n} and
n is the number of time steps.

Now, suppose that a set of transactions Γ is given. Without
loss of generality we can assume that in each time i ∈ T we
have exactly one input transaction ti ∈ Γ. Thus, the number of
input transactions is equal to n. Each transaction is deﬁned like
this: ti =< si, di, pi, vi >, where si, di ∈ V are the source and
the destination of the transactions, pi is a path (an ordered set
of channels) in G between si and di and ﬁnally, vi is the value of
transaction ti. In practical settings most of the times this path is
the shortest path between si and di in G (but sometimes it is not
a good idea to use the shortest path, See [5]). The transaction ti
can be executed in G if:

ce(i) ≥ vi ; ∀e ∈ pi

.

In this paper, we want to schedule the modiﬁcations of G’s
channels’ capacity in a way that can route all the input trans-
actions with minimum cost. Each channel’s capacity is con-
strained by its connected nodes’ capital. We deﬁne the capital
of each node u ∈ V as a function Cu : T → R+, where Cu(t)
represents u’s capital at time t.

Deﬁnition 2. For every node u ∈ V in graph G = (V, E), the
capital of node in time step t is represented by Cu(t), where
Cu : T → R+ is the capital function and T = {i|1 ≤ i ≤ n} and
n is the number of time steps.

We assume that no node can change its capital while pro-
cessing payment transactions. Therefore, Cu can only be in-
creased or decreased by transactions. Cu decreases when u is
the source of a transaction, i.e., u wants to pay some amount of
money to someone. In the same way, Cu increases when u is the
destination of a transaction, i.e., someone wants to pay u some
money.

Lemma 1. With set of transactions Γ = {< si, di, pi, vi > |1 ≤
i ≤ n}, the capital of node u at time t can be represented in this
way:

Cu(t) = Cu(0) −

3

(cid:88)

v j +

(cid:88)

v j

j≤t,s j=u

j≤t,d j=u

i , λe

i )}ke

Our desired scheduling plan consists of a scheme for each
channel. The scheme for each channel e is deﬁned as a se-
quence of channel modiﬁcations fe = {(τe
i=0 , where ke is
the number of modiﬁcations by our plan on channel e, τe
i ∈ T is
the scheduled time for ith modiﬁcation (with τe
i is
0
the new amount which e gets after this modiﬁcation. Note that
its initial value λe
0 equals to the initial capcity of channel ce(0).
i )}ke
i=0
i is the value of capacity of
i+1. We can represent this def-

Deﬁnition 3. A channels modiﬁcation scheme fe = {(τe
for edge e is deﬁned in a way that λe
channel e between times τe
inition by this formula:

= 0) and λe

i and τe

i , λe

i ≤ t < τe
τe

i+1 → ce(t) = λe

i −

(cid:88)

v j +

(cid:88)

v j,

j≤ j<τe
τe

j+1,e∈p j

j≤ j<τe
τe

j+1,e∈ ¯p j

where ¯p j is the path p j in reverse direction.

This paper deﬁnes the problem of designing a plan for schedul-

ing the input payment transactions on a given payment network
as an optimization problem with a set of constraints and an ob-
jective function. The constraints are deﬁned based on the fact
that each node u must provide the capacity of its outgoing chan-
nels, and the sum of its outgoing channels capacities should be
less than its capital. more formally: (cid:80)
e∈O(u) ce(t) ≤ Cu(t), where
O(u) is the set of edges sourced by u, i.e. O(u) = {(u, v)|(u, v) ∈
E}.

For the optimization objective, we consider two diﬀerent
functions, the linear cost function, and the step cost function.
The linear cost function measures the cost of each channel mod-
iﬁcation by its amount of change in its capital.

Deﬁnition 4. For a given graph G and a set of transactions
Γ and a channels modiﬁcations scheme fe = {(τe
i=0, we
can deﬁne the linear cost function of channels modiﬁcations
as follows:

i )}ke

i , λe

LC(G, Γ) =

(cid:88)

ke(cid:88)

e∈E(G)

i=1

|λe

i − ce(τe

i )|.

The step cost function computes the cost as the number of

changes to the capacities.

Deﬁnition 5. For given graph G and set of transactions Γ and
channels modiﬁcations scheme fe = {(τe
i=0, we can deﬁne
the step cost function of the channels modiﬁcations as follows:

i )}ke

i , λe

S C(G, Γ) =

(cid:88)

ke

e∈E(G)

Finally, with these deﬁnitions, we can propose the formal

statement of our problem.

Problem 1. Scheduling capacity changes on payment net-
works with linear cost
Given a graph G(V, E) and a set of transactions Γ = {< si, di, pi, vi >
|1 ≤ i ≤ n}, we want to propose fe = {(τe
i=0 for every e ∈ E
in a way that minimizes LC(G, Γ) and meets these constraints:

i )}ke

i , λe

ce(i) ≥ vi; ∀1 ≤ i ≤ n, ∀e ∈ pi,

4

(cid:88)

e∈O(u)

ce(t) ≤ Cu(t),

where ce is capacity function of edge e, Cu is capital function of
node u and O(u) is set of outgoing channels from u.

Problem 2. Scheduling capacity changes on payment net-
work with step cost
Given a graph G(V, E) and a set of transactions Γ = {< si, di, pi, vi >
|1 ≤ i ≤ n}, we want to propose fe = {(τe
i=0 for every e ∈ E
in a way that minimizes S C(G, Γ) and meets these constraints:

i )}ke

i , λe

ce(i) ≥ vi; ∀1 ≤ i ≤ n, ∀e ∈ pi,

(cid:88)

e∈O(u)

ce(t) ≤ Cu(t),

where ce is capacity function of edge e, Cu is capital function of
node u and O(u) is set of outgoing channels from u.

We face these two problems with two types for Γ, batch and
online. In the batch form, all ti ∈ Γ are given at ﬁrst, But, in the
online form in every time step i we just have t j ∈ Γ; 1 ≤ j ≤ i
and we don’t know the future transactions.

3. Theoretical Results

In this section, we are going to investigate the optimal so-
lution to the problems stated in Section 2. For the problem 1,
which used the linear cost function, we propose a linear pro-
gramming algorithm for scheduling modiﬁcations in polyno-
mial time. For the problem 2, we investigate both batch and
online cases. For the batch input case, we reduce a well-known
fault caching problem to our problem. Moreover, as it is proved
that fault caching is an NP-Complete algorithm, we can con-
clude that the problem 2 is NP-Complete either. For the on-
line input case, we deﬁne the competitiveness, and then we
prove that there are no c-competitive algorithms for our prob-
lem where c ≤ ∆ and ∆ equals the maximum degree of nodes
in the graph. For that purpose, for each algorithm, we devise a
graph in which the cost of the algorithm will be greater than the
optimal cost multiplied by ∆.

3.1. Batch Input - Linear Cost

The following theorem shows that this case of the problem

is solvable in polynomial time by a linear programming.

Theorem 1. The problem 1 with batch input can be solved in
polynomial time.

Proof. The following LP can model the problem. The ﬁrst con-
dition ensures that the scheduling plan is executable at each
time. The second condition guarantees changes will not set the
capacity of edges to a negative value. The third constraint en-
sures that the payment network can route all the incoming trans-
actions. Th ﬁnal condition guarantees the validity of nodes’
capitals. As all the constraints are met and the algorithm mini-
mizes the cost function, it ﬁnds the optimal solution. This linear
programming problem can be solved in polynomial time and
gives the optimal solution.

minimize (cid:80)
e∈E

ke(cid:80)
i=1

|λe

i − ce(τe
i )|

subject to

ce(i) = λe

i − (cid:80)
τe
i ≤ j<τe
i+1
e∈p j

v j + (cid:80)
τe
i ≤ j<τe
i+1
e∈ ¯p j

v j

∀i ∈ T, e ∈ E

λe
i ≥ 0,

ce(t) ≥ vi

(cid:80)
e∈O(u)

ce(t) ≤ Cu(t)

∀i ∈ T, e ∈ E

∀i ∈ T, e ∈ pi

∀i ∈ T, v ∈ V

3.2. Batch Input - Step Cost

In this subsection, we show that the problem of scheduling
capacity changes on payment networks with the step cost func-
tion is NP-complete. To this aim, we use a reduction from an-
other NP-complete problem called the Fault Caching problem
([16]).

Problem 3. Fault Caching problem
Assume that we are given set of pages {pg0, pg1, ..., pgk−1} with
sizes {size(pgi)}k
0. Assume that we have a cache of size W. In
each time we can store a set of pages in the cache if the sum of
their sizes is less than W. A series of page requests will come
in an order σ0, σ1, ..., σn−1 where σi ∈ {pg0, pg1, ..., pgk−1} and
σi is requested at time i. If at time i, σi is not available in cache
we say that a fault happens. The Fault Caching problem asks
for a replacement policy that makes responding to σis with at
most F faults.

Theorem 2. The problem of scheduling capacity changes on
payment networks with the step cost function is NP-complete.

Proof. We want to make a reduction from the Fault Caching
problem to our target problem. To this aim, consider the graph
G = (V, E) with V = {v1, v2} and E = {e1, e2, ..., ek} where
all eis are from v1 to v2 and Cv1 (0) = W. Now we construct
transactions Γ like this:

ti =< v1, v2, eI(σi), size(σi) >,

where I gives index of the requested page.

We show that the answer to the Fault Caching problem is
yes if and only if we can ﬁnd a modiﬁcation schedule for G and
Γ with cost less than or equal to F.

First, we prove the if part. Consider a solution of the Fault
Caching problem like this: di pages that are dropped in time i
and bi set of pages that are brought to the cache in time i. Also
set b0 set of pages that are brought to the cache at time 0. we
construct the solution fe = {τe
i , λe

i }ke
i=0 in this way:
= {(τ, 0)|∀τ, pgi ∈ dτ} ∪ {(τ, size(pgi))|∀τ, pgi ∈ bτ}

fei

n−1(cid:88)

i=0

(|di| + |bi|) ≤ F →

k−1(cid:88)

i=0

| fei| ≤ F

5

So the cost of this modiﬁcation schedule is at most F.
Secondly, we prove the only if part. Suppose we have solu-
tion fe for the scheduling problem. For each time step τe
i that e
+ 1 (cid:60) fe and
+ 1 if τe
is not same as eI(σi) we change τe
i
+ 1 ∈ fe. (we do this sequentially
remove (τe
ordered by τ, starting from 1). The resulting schedule is valid
and the sum of sizes of fes is less than its value for original
schedule.

i ) from fe if τe
i

i to τe
i

i , λe

Then, at each time step τe

i , starting from 1, we decrease λe
i
to size(σi). The resulting schedule still satisﬁes the question
and has a cost of at most F.

Now we construct the solution of Fault Caching problem in

this way:

bt = {pgi|∀i; ∃(t, λ) ∈ fei, λ − cei(t − 1) > 0}
dt = {pgi|∀i; ∃(t, λ) ∈ fei, λ − cei(t − 1) < 0},

and the reduction is complete. We know that the Fault Caching
is NP-complete and it’s reduced to scheduling problem above
in polynomial time, thus, we can infer that scheduling problem
with Batch input and step cost is NP-complete.

3.3. Online Input - Step Cost

In this subsection, we study the problem of scheduling ca-
pacity changes on payment network with the step cost function
and online input. With this type of input, in every time step i
we just have t j ∈ Γ; 1 ≤ j ≤ i and we don’t have any informa-
tion about the future transactions. In this context, we deal with
online algorithms and competetive analysis.

In competitive analysis, an online algorithm A is compared
to an optimal oﬄine algorithm. An optimal oﬄine algorithm
knows the entire request sequence in advance and can serve it
with minimum cost. Given a request sequence σ, let CA(σ)
denote the cost incurred by A and let COPT (σ) denote the cost
incurred by an optimal oﬄine algorithm OPT . The algorithm
A is called c-competitive if there exists a constant a such that:

CA(σ) ≤ c.COPT (σ) + a,

for all request sequences σ. Here we assume that A is a deter-
ministic online algorithm. The factor c is also called the com-
petitive ratio of A ([17]).

Theorem 3. Given a graph G = (V, E) and a set of online
transactions Γ. There is no deterministic c-competitive online
scheduling algorithm f = { fe}e∈E such that c ≤ ∆ (maximum
degree of nodes in G) for ﬁnding the minimum cost modiﬁcation
schedule with the step cost function S C(G, Γ):

S C(G, Γ) =

(cid:88)

e

| fe|

Proof. Let g be the optimal batch solution. For each determin-
istic algorithm f we devise a network and a series of transac-
tions such that:

∆ × S Cg(G, Γ) ≤ S C f (G, Γ)

Consider a graph G(V, E), V = {v1, v2} and E = {e1, e2, ..., e∆}
where all eis are edges from v1 to v2. For algorithm f we have:

(cid:88)

e∈E

ci
e ≤ Cv1 (i); ∀i ∈ T →

∃ j : ci
e j

≤

Cv1 (i)
∆

+ (cid:15); ∀i ∈ T, ∀(cid:15) > 0

We devise ti such that:

ti =< v1, v2, e j,

Cv1 (i)
∆

+ (cid:15))

With this input for every i we have (i,
every time step we have at least one changes so:

Cv1 (i)

∆ ) in fe j. Thus, for

S C f (G, Γ) ≥ n,

but for optimal solution, g, when we need an increase to e j at
time step i we decrease ek such that ek ∈ pi+∆. Thus, g needs a
change for every ∆ step. So:

∆ × S Cg(G, Γ) ≤ S C f (G, Γ)

4. Heuristic Algorithms

In previous sections, we approached the problem of ﬁnding
the minimum cost modiﬁcation schedule for a given payment
network and set of transactions in four diﬀerent cases: Batch
input-linear cost, Batch input-step cost, Online input-step cost,
Online input-linear cost.

For the batch input-step cost case, we proved that ﬁnding
the optimum solution is NP-complete. This section will try
some heuristic algorithms for this case, and we will compare
their performances to ﬁnd out the best heuristic. First of all, we
will give a model of the problem of implementing heuristics for
that. Then, we will introduce the heuristic algorithms we want
to try. Finally, We will show empirical results and compare
them.

4.1. Model

Suppose that we have a graph G with n channels and a set
of transactions T , over G, with m transactions. Again, accord-
ing to the deﬁnition of the problem, each channel and node has
a capacity. Node capacities cannot change, but channels’ ca-
pacity can change with cost 1 for each modiﬁcation. The sum
of capacities of all channels of a speciﬁc node can’t be greater
than the capacity of that node. Now, assume that we have found
a solution S for the problem.

The procedure of the algorithm will be in this way: At
each step i, S will do some modiﬁcations on channels’ capaci-
ties, and the cost will increase by the number of modiﬁcations.
Then, transaction ti of T will be executed, and the capacity of
channels in the path of ti, the capacity of the source node, and
capacity of target node will decrease by the value of ti. If limits
of capacities cannot route the transaction, the solution will get

6

some penalty, and the cost will increase by that, and ti will be
skipped. This procedure will repeat from i = 0 to i = m.

We want to use an array to represent solution S and then try
to change that array with heuristic algorithms to ﬁnd better so-
lutions. The ﬁrst and the most straightforward way to represent
S is to use a 2D matrix. The number in row i and column j of
the matrix will be the value of modiﬁcation on channel i in step
j. The cost of the solution will be the number of non-zero ele-
ments plus the penalty for the number of skipped transactions.
However, there are some problems with this way of solution
modeling. One problem is that the number of parameters in
the solution matrix array is m × n, i.e., the number of channels
times the number of transactions. This number of parameters
will increase our heuristic algorithms’ time and complexity and
increase randomness in our algorithms.

Another problem is the way we represent the numbers in
the matrix. If the numbers are absolute values of increase or de-
crease to capacities, those values may depend on every capacity
and transaction’s values. Also, these values have no bound and
can change from minus inﬁnity to plus inﬁnity. These problems
can make the progress of the algorithm hard and slow. However,
if, in some way, we can use normalized coeﬃcients from 0 to
1 instead of these absolute values, that can make our problem
easier.

For ﬁnding a better way to represent a solution of an al-
gorithm in an array, we will use some lemmas. Here we will
discuss these lemmas.

Lemma 2. Assume that in step i we have transaction ti that uses
path pi. Deﬁne Ni the set of all nodes in path pi. If two nodes
v1 and v2 are not in Ni, there is no need to change capacity of
edge e between v1 and v2, in step i.

This lemma is quite intuitive because we can push changes
to irrelevant edges to the next steps, and the resulting cost will
be less than or equal to the ﬁrst solution.

Lemma 3. If a transaction ti in step i has value vi and there is
channel e in path pi of ti and capacity of e is greater than vi,
there is no need to change the capacity of e in step i.

The intuition behind this lemma is just like before. We can
push changes to edges that have enough capacity for now to the
next steps.

Now we can provide another model for our solution S . We
will have an array of numbers between 0 and 1 to represent
this solution. Every step a transaction needs to pass through a
channel, we check that if the channel’s capacity is enough for
that value, we let it go and do not change the channel capacity.
But, if the channel’s capacity is not enough, there can be two
states.

First, the source node’s capacity is enough, but the chan-
nel’s capacity is not enough. We increase the channel’s capacity
as much as it can pass the transaction; then, we increase it by
the amount that it can increase multiplied by a coeﬃcient from
the solution array.

Another state is when both the channel’s capacity and the
source node’s capacity are not enough. In this state, we need to

decrease the capacity of other channels connected to the source
node so that its capacity will increase, and then we can act like
before. Therefore, we go through all other channels connected
to the source node and multiply them by a coeﬃcient from the
solution array. Whenever the node capacity is enough for the
transaction to pass, we change the channel’s capacity like the
former state.

There is a problem with this model, and that is the length
of the array. If the array’s length is too long, then there would
be some parameters that are not useful. If the length of the ar-
ray is too short, then we lack some coeﬃcients for our solution.
To tackle this problem, we assumed that if we ran out of co-
eﬃcients in the solution, we use 0 as the coeﬃcient. Also, we
consider the length of the solution array as a hyper-parameter to
our heuristic model that can be tuned, and diﬀerent values can
be checked to ﬁnd the best one.

4.2. Algorithms

After providing a model for our algorithm and its solution,
we will test some heuristic algorithms to ﬁnd the best solution
and compare their performance. Here we’ll explain these algo-
rithms.

• Alg1. This algorithm is based on Genetic Algorithms
[18]. First, we create random solution arrays to the num-
ber of population. Then, in each generation, we calculate
the ﬁtness function for each solution and ﬁnd the best
ones as parents. Then we do a crossover between those
selected solutions and do some random mutations on re-
sulting arrays. The resulting arrays after crossover and
mutation plus the parent arrays will form the next popu-
lation. This process will repeat until the algorithm con-
verges or the maximum number of generations exceeds.

• Alg2. This algorithm is based on Random Hill Climb-
ing. At each step, we move our solution to a new ran-
dom state. That means we increase or decrease some
random elements of our array by a constant step. After
each move, we calculate the ﬁtness function of our array,
and if it has improved, we stay; otherwise, we step back
to the previous solution. This process repeats until the
maximum number of steps exceeds.

• Alg3. This algorithm is based on Late Acceptance Hill-
Climbing [19]. Researches have shown the superiority of
this algorithm over other optimization methods in many
application ﬁelds. It is similar to the previous algorithm,
but it has a history array. After each step, it checks the so-
lution’s ﬁtness with the previous step and with ﬁtness in
speciﬁc steps before from our history array. For example,
if we are in step 52 and the history array’s length is 30,
our algorithm compares the ﬁtness of the next step with
the previous one and the number in the index of 22 in our
history array. If it is better than any of them, it will move
to the next step. Moreover, if new ﬁtness is better than
the ﬁtness in our history, it will replace it in the history
array. This process repeats until the maximum number of
steps exceeds.

7

• Alg4. This algorithm is based on the PSO algorithm
[18]. It initiates a population of swarms with a position
in search space and a velocity. At each step, this algo-
rithm updates the velocity of each particle using the PSO
well-known formula depending on its current position,
its best-known position, and the best-known position of
the entire swarm. Then, it updates the particle’s position
depending on this new velocity.
If this new position’s
ﬁtness is better than this particle’s best-known position
or the entire swarm’s best-known position, updates them.
This process repeats until the algorithm converges or the
maximum number of generations exceeds.

• Alg5. This algorithm is based on Simulated Annealing
[20]. It initiates the algorithm with a state and a temper-
ature. Each step moves the state (like movements we had
in Alg3 or Alg2) and calculates its ﬁtness. Then calcu-
lates the probability of acceptance of the new state with
this formula: e(old f itness−new f itness)/T . Then, it compares
acceptance probability with a random number, and if it is
greater than that, it moves to the new state. After each
step, the temperature decreases by being multiplied by a
constant. This process repeats until the temperature goes
below some speciﬁc number.

4.3. Empirical Results

In this subsection, we present the results of experimenting
with the heuristics mentioned above on real-world data. For
data of nodes and channels, we used [21] API and crawled data
from that. This data was massive, So for making it smaller, we
sampled a connected graph from it.

There is no open dataset for transactions over the Light-
ning network. So we generated a random transaction dataset
by choosing some random paths in our graph and some random
values from the uniform distribution. We used the number of
changes in channel capacities as our objective function. For
each algorithm, some hyper-parameters must be tuned—for ex-
ample, the length of the solution array or the coeﬃcient of tem-
perature in simulated annealing. We ran many simulations and
tests on algorithms to ﬁnd the best hyper-parameters for each
one of them.

The result of growth and convergence of algorithms can be
seen in Figure 3. From this simulation, these results can be
concluded:

• The best overall eﬃciency was obtained from Alg3, which
is based on the Late Acceptance Hill Climbing, with the
second-best being Alg4, which is based on the classic
PSO algorithm. Late Acceptance Hill Climbing has shown
to be very eﬀective in many other applications.

• Alg4 and Alg5 converge after few steps, but Alg1, Alg5,

and Alg2 took much more time to converge.

• Alg3 is not having improvements at the ﬁrst steps, but it
starts at the ending steps. Maybe it depends on the length
of the history array in our Late Acceptance Hill climbing
algorithm

[10] G. Avarikioti, G. Janssen, Y. Wang, R. Wattenhofer, Payment network
in: Data Privacy Management, Cryptocurrencies and

design with fees,
Blockchain Technology, Springer, 2018, pp. 76–84.

[11] G. Avarikioti, Y. Wang, R. Wattenhofer, Algorithmic blockchain channel

design, arXiv preprint arXiv:1810.07603 (2018).

[12] Z. Avarikioti, L. Heimbach, Y. Wang, R. Wattenhofer, Ride the lightning:
The game theory of payment channels, in: Financial Cryptography.
[13] P. Prihodko, S. Zhigulin, M. Sahno, A. Ostrovskiy, O. Osuntokun, Flare:
An approach to routing in lightning network, White Paper (2016).
[14] I. A. Seres, L. Guly´as, D. A. Nagy, P. Burcsi, Topological analysis of
in: Mathematical Research for Blockchain

bitcoin’s lightning network,
Economy, Springer, 2020, pp. 1–12.

[15] J. Herrera-Joancomart´ı, G. Navarro-Arribas, A. Ranchal-Pedrosa,
C. P´erez-Sol`a, J. Garcia-Alfaro, On the diﬃculty of hiding the balance
of lightning network channels,
in: Proceedings of the 2019 ACM Asia
Conference on Computer and Communications Security, Asia CCS ’19,
Association for Computing Machinery, New York, NY, USA, 2019, p.
602–612.

[16] M. Chrobak, G. J. Woeginger, K. Makino, H. Xu, Caching is hard—even

in the fault model, Algorithmica 63 (2012) 781–794.

[17] S. Albers, Competitive online algorithms, Computer Science Department,

University of Aarhus, 1996.

[18] X.-S. Yang, Nature-inspired optimization algorithms: Challenges and
open problems, Journal of Computational Science 46 (2020) 101104.
[19] E. K. Burke, Y. Bykov, The late acceptance hill-climbing heuristic, Eu-

ropean Journal of Operational Research 258 (2017) 70–78.

[20] D. Delahaye, S. Chaimatanan, M. Mongeau, Simulated annealing: From
in: Handbook of metaheuristics, Springer, 2019,

basics to applications,
pp. 1–35.

[21] https://github.com/ﬁatjaf,

Bigsun

lightning

network

api,

https://ln.bigsun.xyz/, 2020. [Online; accessed April-2020].

• All the algorithms were stable and converged.

5. Conclusion

We formalized the problem of capacity changes scheduling
on payment networks while minimizing the cost of maintaining
the network.

We have considered diﬀerent types of this problem, depend-
ing on the input type of transactions and the cost function type.
We proposed a polynomial-time algorithm for the batch input
and the linear cost case for ﬁnding the optimal solution using
linear programming. We proved the NP-completeness of ﬁnd-
ing the optimal modiﬁcation scheme for the batch input and the
step cost function. For the online input and step cost case, we
proved no deterministic c-competitive online scheduling algo-
rithm such that c ≤ ∆, where ∆ is the maximum degree of the
nodes in our payment network.

After that, we proposed some heuristic algorithms for the
batch input and step cost case. We ran some simulations on
those algorithms and compared them in an empirical experi-
ment. This paper’s results and algorithms can be used in all
oﬀ-chain payment networks like the Lightning Network or the
Raiden Network.

We have not addressed other cost functions. Moreover, we
have not considered the general form of the problem, the prob-
lem in which a general function f is assumed as a cost function.
For the heuristic part, we have not implemented heuristic
algorithms for other cases, such as online input and step cost.
Additionally, There are more heuristic algorithms we could in-
vestigate.

These are the problems that need to be addressed in the fu-

ture.

References

[1] Q. Zhou, H. Huang, Z. Zheng, J. Bian,

Solutions to scalability of

blockchain: A survey, IEEE Access 8 (2020) 16440–16455.

[2] K. Croman, C. Decker, I. Eyal, A. E. Gencer, A. Juels, A. Kosba,
A. Miller, P. Saxena, E. Shi, E. G. Sirer, et al., On scaling decentral-
ized blockchains, in: International conference on ﬁnancial cryptography
and data security, Springer, pp. 106–125.

[3] E. Georgiadis, How many transactions per second can bitcoin really han-
dle ? theoretically., Cryptology ePrint Archive, Report 2019/416, 2019.
Https://eprint.iacr.org/2019/416.

[4] S. Kim, Y. Kwon, S. Cho, A survey of scalability solutions on blockchain,
in: 2018 International Conference on Information and Communication
Technology Convergence (ICTC), pp. 1204–1207.

[5] V. Sivaraman, S. B. Venkatakrishnan, K. Ruan, P. Negi, L. Yang, R. Mit-
tal, G. Fanti, M. Alizadeh, High throughput cryptocurrency routing in
in: 17th {USENIX} Symposium on Net-
payment channel networks,
worked Systems Design and Implementation ({NSDI} 20), pp. 777–796.
[6] J. Poon, T. Dryja, The bitcoin lightning network: Scalable oﬀ-chain in-

stant payments, 2016.

[7] Z. Avarikioti, O. S. T. Litos, R. Wattenhofer, Cerberus channels: incen-
tivizing watchtowers for bitcoin, in: International Conference on Finan-
cial Cryptography and Data Security, Springer, pp. 346–366.

[8] C. Decker, R. Wattenhofer, A fast and scalable payment network with bit-
coin duplex micropayment channels, in: Symposium on Self-Stabilizing
Systems, Springer, pp. 3–18.

[9] M. Green, I. Miers, Bolt: Anonymous payment channels for decentralized
in: Proceedings of the 2017 ACM SIGSAC Conference on

currencies,
Computer and Communications Security, pp. 473–489.

8

Figure 1: The Payment Channel Mechanism

9

Figure 2: A Payment Network; Alice wants to pay 0.2 bitcoin to Carol. This payment is impossible through the Alice-Will-Scarlet-Carol path because the channel
between Scarlet and Carol has not enough capacity. However the Alice-Bob-Carlo path makes it possible. First, Alice pays 0.2 BTC to Bob through her channel to
him. Then Bob pays this money to Carol through his channel to him.

10

Figure 3: Simulation results for the Stable network problem with 5 diﬀerent
algorithms.

11

