Securing Smart Grids Through an Incentive Mechanism for
Blockchain-Based Data Sharing

Daniël Reijsbergen, Aung Maw, Tien Tuan Anh Dinh, Wen-Tai Li, and Chau Yuen
Singapore University of Technology and Design

2
2
0
2

b
e
F
9

]

R
C
.
s
c
[

1
v
5
4
3
4
0
.
2
0
2
2
:
v
i
X
r
a

ABSTRACT
Smart grids leverage the data collected from smart meters to make
important operational decisions. However, they are vulnerable to
False Data Injection (FDI) attacks in which an attacker manipulates
meter data to disrupt the grid operations. Existing works on FDI are
based on a simple threat model in which a single grid operator has
access to all the data, and only some meters can be compromised.
Our goal is to secure smart grids against FDI under a realistic
threat model. To this end, we present a threat model in which there
are multiple operators, each with a partial view of the grid, and
each can be fully compromised. An effective defense against FDI
in this setting is to share data between the operators. However,
the main challenge here is to incentivize data sharing. We address
this by proposing an incentive mechanism that rewards operators
for uploading data, but penalizes them if the data is missing or
anomalous. We derive formal conditions under which our incentive
mechanism is provably secure against operators who withhold or
distort measurement data for profit. We then implement the data
sharing solution on a private blockchain, introducing several opti-
mizations that overcome the inherent performance limitations of
the blockchain. Finally, we conduct an experimental evaluation that
demonstrates that our implementation has practical performance.

1 INTRODUCTION
Meters in modern power systems are increasingly augmented with
automated data collection and communication capabilities, leading
to the emergence of smart grids. The high-frequency measurements
gathered by these smart meters allow for unprecedented levels of
feedback and control. However, as utility companies become more
reliant on smart meter data for grid management, the meters and
their data become more attractive targets for attackers. As a critical
infrastructure, power systems are at risk from, e.g., hackers seeking
to extort utility companies [41], or state-sponsored adversaries
seeking to disrupt a power grid for political reasons [24].

One important attack against smart power grids is False Data
Injection (FDI) [7, 22, 23, 28, 29, 40]. In an FDI attack, the measure-
ments collected by the meter during normal operation are replaced
by arbitrary measurements, which violates data integrity. Existing
approaches against FDI include redundancy through the strategic
placement of additional meters [10, 12, 35, 44], improving the secu-
rity of the existing meters [20, 30], and robust detection algorithms
[40]. However, these works consider a simple threat model in which
there is a single operator who has access to all the measurement
data. Furthermore, they assume that the attackers are limited in the
number of meters that they can compromise, or in the magnitude
with which they can distort measurements.

We seek a solution for protecting smart grids against FDI under
a realistic threat model. We note that the model used in existing
works precludes attacks that overwrite the data from all of a single

operator’s meters. However, such an attack cannot be ruled out,
e.g., if the storage servers at the operator are compromised by a ma-
licious insider or after a successful hack. In this paper, we consider
a more realistic model, in which there are multiple operators, and
each of them only has a partial view of the grid. Each operator can
be fully compromised, i.e., all of its meters and its data management
servers can be under the attacker’s control.

Under this new threat model, we propose a solution for defend-
ing against FDI in which operators form a consortium to share
their data. In particular, the operators first agree on a high-level
system topology and indicate the location of their meters within
this topology. They then upload meter measurements to a shared,
tamper-evident data structure – e.g., a blockchain. The operators
have access to the full measurement dataset, and can therefore run
their own FDI detection algorithms. We focus on meters on the
higher levels of the grid – i.e., the distribution and transmission
stages – as they have the following advantages over household
meters: 1) user privacy is less of a concern because each high-level
measurement aggregates many households, 2) high-level meters
perform and share measurements at a higher frequency than house-
hold meters, and 3) the number of high-level meters in a regional
or national network is typically in the order of thousands (e.g., see
the IEEE test cases for Poland and the Western USA [2]).

The main motivation for joining our data sharing solution is
to defend against FDI attacks. However, we note that convincing
the operators to join the consortium is not sufficient. The grid
operators are competitors in the same market as they bid for the
same contracts to operate sections of the grid, and one operator
may therefore profit if the others do poorly. This implies that the
operators may be motivated to share bad or insufficient data. As
an example, consider an operator who shares only a small fraction
of its meters’ data. If its goal is to determine system-wide mea-
surement averages, it can first obtain data from other operators,
then combine these with its hidden measurements. This way, the
operator achieves its goal while reducing the degree to which its
competitors benefit from the system. A malicious operator can even
share distorted measurements in order to mislead other operators.
We address this incentivization challenge by proposing an incen-
tive mechanism in which operators make an initial financial deposit,
and earn credits when they share meaningful data. Moreover, they
lose credits if they fail to share data or share anomalous data. An
operator who loses all of its credits after incurring penalties over
a long period (e.g., weeks) can be expelled from the consortium,
causing it to lose its deposit. To identify anomalies, we exploit the
interdependence between measurements: in particular, a measure-
ment is flagged as anomalous if it is found, through state estimation
[3, 33], to be inconsistent with the measurements from other up-
stream or downstream meters. Our incentive mechanism helps

 
 
 
 
 
 
operators to identify and fix benign problems that cause their me-
ters to report anomalous data. It also helps to identify bad operators
who persistently share bad data. Furthermore, we derive formal
conditions under which our mechanism is provably incentive com-
patible: i.e., it is the optimal strategy for (coalitions of) operators to
share as many accurate measurements as possible unless certain
technical conditions are violated. These conditions depend on the
structure of the grid and the strength of the adversarial coalition.
We implement our data sharing solution on top of a private
blockchain. Blockchains allow us to implement credit transfers be-
tween parties in a secure, transparent, and fully automated manner
on a network of mutually untrusting peers [39]. Blockchains re-
move the need for a trusted third party, which itself may suffer from
attacks or temporary losses of service that impact the incentive
mechanism, leading to costly disputes. We implement the mech-
anism in a smart contract that performs state estimation, which
requires expensive matrix computations. Since smart contract ex-
ecution times affect the blockchain’s throughput, the challenge
here is to speed up such execution in order to avoid throughput
degradation. As a final contribution, we therefore introduce several
performance improvements: data storage optimization, moving ex-
pensive computations offline, utilizing a randomized algorithm to
verify offline computations [16, 37], and multithreading. Our exper-
iments show that our approach achieves practical performance.

In summary, we make the following four contributions:
(1) We present a threat model for FDI attacks that is broader and
more realistic than the threat models in existing works be-
cause it includes the possibility that all of a single operator’s
measurements are affected.

(2) We present a data sharing solution that defends against FDI
attacks in this threat model if other operators’ meters per-
form redundant measurements.

(3) Our data sharing solution features an incentive mechanism
that is provably incentive-compatible, i.e., it motivates op-
erators to share meaningful data, under explicit technical
conditions that depend on the grid topology and the strength
of the adversarial coalition.

(4) We implement our solution on a private blockchain and in-
troduce four optimizations that speed up storage operations
and matrix computation in the contract. We conduct an ex-
perimental evaluation of our implementation and show that
it achieves practical performance.

The rest of the paper is organized as follows. In Section 2, we
review the relevant background on smart grids and blockchains.
In Section 3, we describe the system model, threat model, and the
requirements for our solution. We discuss our incentive mechanism
in Section 4 and the implementation of our data sharing solution
in Section 5. We analyze our solution in Section 6 and find that it
satisfies the stated requirements. We present the empirical evalua-
tion in Section 7, discuss related work in Section 8, and conclude
the paper in Section 9.

2 BACKGROUND
2.1 Power Grid
Power grids are systems that deliver electrical power from power
plants to consumers such as households and businesses. Figure 1

Daniël Reijsbergen, Aung Maw, Tien Tuan Anh Dinh, Wen-Tai Li, and Chau Yuen

Figure 1: High-level overview of the power grid.

Figure 2: Meters and data collection in the grid. Solid lines
represent power lines, whereas dotted lines indicate data
transfers. There are four operators (one generator, one TSO,
and two DSOs), and each has its own MDMS to collect and
process data from their meters. By sharing their data, the op-
erators are able to fully exploit the redundancy in the grid,
e.g., between the two meters marked ‘1’ and ‘2’.

shows the design of a grid which consists of four stages: generation,
transmission, distribution, and consumption. After generation, power
is transmitted over a network of high-voltage power lines, after
which it is distributed to consumers over medium- and low-voltage
networks. The power lines and nodes (junctions and substations)
in the transmission network are operated by Transmission System
Operators (TSOs). Similarly, the power lines and nodes in the dis-
tribution network are operated by Distribution System Operators
(DSOs). Billing and customer service is provided to consumers by
retailers. The roles of different organizations in the grid vary from
country to country. For example, in Japan, there are 10 regions
in which a single operator acts as a TSO and DSO [36]. However,
in Germany, the national grid is operated by four TSOs, but the
distribution networks are operated by hundreds of municipal utility
companies (Stadtwerke) and some regional DSOs [4].

In each stage of the grid, the electricity going over the power lines
is measured using meters. In this paper, we focus particularly on
the meters at the higher levels of the grid, that is, at the generation,
transmission, and distribution stages. These meters are an essential
component of the operator’s Supervisory Control And Data Acqui-
sition (SCADA) system. The main goal of the SCADA system is to
facilitate operations management such as load balancing because

GenerationTransmissionDistributionPrimarySecondaryConsumptionHVLineMVLineLVLine–powermeter–MDMSserverGeneratorTSODSO2DSO112Securing Smart Grids Through an Incentive Mechanism for Blockchain-Based Data Sharing

excessively high loads can cause line failures and blackouts. SCADA
meters can measure a number of different quantities, for example,
voltage, current, and frequency. However, the main quantities of
interest in our setting are the power flow and injection on lines
and nodes, respectively. In addition to meters on the power lines,
grid operators can also deploy high-precision meters called Phasor
Measurement Units (PMUs) at the nodes. A PMU outputs high-
frequency estimates of voltage and current phasors [20, 25, 35, 40].
The high-level meters all have advanced communication capabili-
ties. Meter data is collected, stored, and processed by the operator’s
Meter Data Management System (MDMS).

The data collected from the meters allows for the estimation of
system states (i.e., voltage and current phasors) at the nodes. In the
following, we use the bus-branch model, in which the branches rep-
resent lines and the buses represent nodes, in combination with the
DC flow model [3, 18, 33, 42]. In this model, the relationship between
the measurements and the system states is linear. Furthermore, mea-
surement inaccuracies – e.g., due to different meters not performing
measurements at exactly the same time – are expressed as random
variables with a known distribution (e.g., normal/Gaussian with
known variance). To detect faults or attacks, we can then use linear
regression: we use the least-squares method to estimate the system
states, and then use the result to re-estimate the measurements.
If the sum of the differences between the observed and the esti-
mated measurements, called the residuals, is significantly higher
than what we would expect from the probability distribution of the
measurement errors, then this is evidence of a fault or an attack.

Depending on the placement of the meters, the system can be
observable or unobservable [3, 7]. The system is unobservable if the
matrix used for state estimation does not have full rank. Individual
meters can be either critical or redundant. A meter is critical if the
following holds: if the meter is included then the system is observ-
able, but if the meter is removed then the system is unobservable. A
meter that is not critical is redundant. A residual that corresponds
to a critical meter will always be zero, but those that correspond
to a redundant meter will typically be non-zero. When a single
redundant meter produces a bad measurement (i.e., different from
the true quantity) then this meter will have the largest residual [3].
Figure 2 illustrates an example of different operators managing
different sets of meters. Meters 1 and 2 are redundant, as they are
on the same line and are likely to produce similar measurements.
This redundancy in the grid can only be exploited if the operators
share measurement data. Some countries, such as the USA, make it
compulsory for grid operators to share data with a regulator. There
are even standard data formats for exchanging information between
grid operators.1 However, we do not assume that the regulator has
an active role in monitoring grid measurements. The potential role
of the regulator will be discussed in more detail in Section 6.

2.2 Blockchains
A blockchain is a distributed system consisting of mutually dis-
trusting peers. The peers maintain some global states which can be
updated via transactions. The blockchain groups transactions into
blocks – each block links to another block via a cryptographic hash

1https://www.entsoe.eu/digital/common-information-model/#common-
information-model-cim-for-grid-models-exchange

pointer, forming a chain. A Merkle tree [31] is built on the global
states, and the root of the tree is included in each block. The nodes
run a consensus protocol to ensure that each node has the same
copy of the states.

There are two main types of blockchains: public (or permission-
less) and private (or permissioned) [13]. The former type allows
any node to join the network, and typically uses a variant of Proof-
of-Work [34] for consensus. The latter is restricted to approved
members, and uses a classic Byzantine fault-tolerant consensus pro-
tocol such as PBFT [9]. One popular private blockchain is Hyper-
ledger Fabric [1]. It supports a centralized membership service that
maintains a list of users who can read and write to the blockchain.
Many blockchain systems today support smart contracts which
are pieces of code that run on the blockchain. The smart contract
can access the global states, and its execution is replicated at all
nodes. Some blockchains allow Turing-complete smart contracts.
For example, Ethereum [43] has its own language and executes
the code on the Ethereum Virtual Machine (EVM). Hyperledger
Fabric [1] runs its smart contracts inside a Docker container.

3 MODEL & REQUIREMENTS
3.1 System Model
The main entities in our system model are the grid operators, i.e., the
TSOs and DSOs. We denote the set of operators by O = {1, . . . , 𝑂 }.
The grid is represented by a graph that consists of nodes and power
lines. Let N = {1, . . . , 𝑁 } be the set of nodes and L = {1, . . . , 𝐿}
the set of lines. As discussed in Section 2, we consider three types
of meters: power flow meters, node injection meters, and PMUs. We
denote the set of meters by M = {1, . . . , 𝑀 }. Some nodes N ′ ⊂ N
are assumed to always have zero power injection. The set M is
partitioned in the following way: for each operator 𝑜 ∈ O, let
M𝑜 ⊂ M be the set of meters owned by 𝑜. Let 𝑁 ′ and 𝑀𝑜 the size
of N ′ and M𝑜 , respectively. Time is represented as a discrete set
of slots 𝑡 ∈ {1, 2, . . .}. Each meter 𝑚 ∈ M is expected to produce a
measurement 𝑥𝑚 𝑡 in each time slot 𝑡, and send it to its operator’s
MDMS server for processing. We assume that time slots have fixed
start and end points and that the operators’ servers have loosely
synchronized clocks. In the following, when we consider a single
time slot, we omit the subscript 𝑡 and simply write 𝑥𝑚.

In practice, measurements can be delayed or missing altogether.
The processing of measurements may be delayed for various rea-
sons, including: 1) hardware or software problems on the meter
affecting the transmission of the measurement to the operator’s
MDMS server, 2) network conditions between the meter and MDMS
server, or 3) hardware or software problems on the MDMS server.
Similarly, reasons for measurements that permanently go missing
include: 1) hardware or software problems on the meter that pre-
vent measurements from being recorded, 2) hardware or software
problems on the meter that delete measurements stored on the flash
memory before they are transmitted, 3) messages being lost during
transmission, or 4) hardware or software problems on the MDMS
server that delete the measurements.

It is not feasible to wait indefinitely for measurements since
they may have gone missing. In addition, measurements from too
far in the past are no longer relevant for operations management.
We model this through a cut-off time 𝜏, which is the number of

time slots after which measurements are no longer relevant. We
assume that each meter 𝑚 ∈ M is offline in each time slot with a
fixed probability 𝑝𝑚. In our setting, offline means that the meter
is not able to communicate with the MDMS server from the start
of the time slot until the end of the cut-off period. A meter can
also produce bad data, which we define as data that is, with high
probability (given the probability distribution of the measurement
errors), different from the true quantity that is being measured.

Given a grid specified in terms of N , N ′, L, M, we can per-
form state estimation as follows. First, we construct a topology
matrix 𝐺 such that (cid:174)𝑥 = 𝐺 (cid:174)𝜃 + (cid:174)𝜖 where (cid:174)𝑥 is a column vector with
measurements, (cid:174)𝜃 is the voltage phasor angle in each of the nodes,
and (cid:174)𝜖 are the errors. Next, we determine the projection matrix
𝑃 = 𝐺 (𝐺𝑇 𝐺)−1𝐺𝑇 for the least squares method. The residuals are
then computed as ^𝜖 = (cid:174)𝑥 − 𝑃 (cid:174)𝑥. If the sum of squared residuals, given
by (cid:174)𝜖𝑇 𝜖 = (cid:205)𝑚 ∈M 𝜖2
𝑚, exceeds a given threshold 𝜃 ′, then an anomaly
– possibly caused by an FDI attack – is detected. A more detailed de-
scription of how to construct the matrix 𝐺 using the grid topology
can be found in Algorithm A.

3.2 Threat Model
In our model, we consider two distinct types of attackers.

FDI Attacker: this attacker’s goal is to cause short-term disruption
to grid operations, potentially causing a blackout. FDI attackers can
be very powerful, i.e., state-sponsored. We assume that this attacker
is able to compromise some, but not all operators for a short period
of time. By “compromise” we mean that the attacker has obtained
access to the operator’s computer systems or the private keys or
passwords stored on these systems, e.g., through a hack, (spear)
phishing, or an insider threat.

Persistently Adversarial Operator: this attacker’s aim is to maxi-
mize its long-term profits, possibly by deviating from the protocol.
We consider the following types of persistent adversarial behav-
ior by an operator: 1) refraining from registering valid meters, 2)
uploading fake measurements from offline or non-existing meters,
3) taking its own meters offline by disconnecting them from the
network, 4) preventing another operator’s meters from sharing
measurements, and 5) uploading distorted measurements by manip-
ulating input signals or placing the meters at a different location in
the grid than what is claimed.

An overview of threat models in the related literature can be

found in Appendix B.

3.3 Requirements
In the remainder of this work, we present a solution that satisfies
the following requirements.

(1) FDI Attack Security. FDI attacks against compromised op-
erators should still be detectable if redundant measurements
are performed by uncompromised operators.

(2) Incentive Compatibility. Operators should be incentivized
to join the system, and to refrain from the persistent adver-
sarial behavior discussed in the previous section.

(3) Scalability. The solution should be able to support thou-

sands of meters.

Daniël Reijsbergen, Aung Maw, Tien Tuan Anh Dinh, Wen-Tai Li, and Chau Yuen

In Sections 4 and 5, we present our data sharing mechanism and
the implementation of our data sharing solution, respectively. We
discuss under what conditions our solution satisfies the above re-
quirements in Section 6.

4 INCENTIVE MECHANISM
As discussed in Section 3, an FDI attacker who successfully compro-
mises an operator can tamper with all of that operator’s readings.
Such attacks can be mitigated by sharing data between operators,
but a naïve data sharing solution is vulnerable to adversarial behav-
ior by operators. Grid operators compete with each other for the
same customers, and as such may be willing to take actions that
harm other operators if it comes at no cost to themselves. As an
example, see the recent EU lawsuit in which TenneT [14], which is
both a TSO and a generator, was accused of restricting grid capacity
to competing generators. Under our threat model, an adversarial
strategy could arise in which an operator withholds its own data
while still reading the data from others. Alternatively, it can mis-
lead the anomaly detection efforts by other companies by including
poorly calibrated or distorted readings.

To defend against adversarial operators, we propose an incen-
tive mechanism that rewards operators for each measurement, but
penalizes them for missing and anomalous measurements. In partic-
ular, companies earn or lose credit tokens based on the quantity and
quality of their measurements. When a company runs out of credits,
it is expelled from the system. To avoid expulsion, a company must
purchase credits from other companies. This provides a financial
incentive for companies to accumulate credits. We describe our
incentive mechanism in the following.

4.1 Description of the Mechanism
In our mechanism, the grid operators first agree on a topology – i.e.,
on N , N ′, and L. Each operator 𝑜 ∈ O then registers a set of meters
M0 and states the position of each meter within the topology. The
grid operators are each given 𝛾 initial credits, where 𝛾 is a large
integer. In each time slot, the MDMS server of each operator 𝑜
shares a single measurement from each meter 𝑚 ∈ M𝑜 with the
rest of the consortium. After the cut-off period has passed, the slot
is finalized – at this point, the measurements are evaluated and
the credits are redistributed in the following way. Each operator
𝑜 ∈ O receives a reward 𝜌 for each meter in M𝑜 that has shared
a measurement, and a penalty 𝜙 for each meter in M𝑜 that has
not shared a measurement. If at least one operator has not shared
a measurement then the incentive mechanism is terminated after
administering the missing measurement penalties. However, if all
measurements have been received then the algorithm performs
anomaly detection using state estimation. In particular, it constructs
the (𝑀 + 𝑁 ′) × 1 vector (cid:174)𝑥 as follows: for each 𝑖 = 1 . . . , 𝑀, the 𝑖th
element of (cid:174)𝑥 is set equal to the measurement of the 𝑖th meter. The
next 𝑁 ′ elements are set equal to zero. Finally, the residuals are
computed as ^𝜖 = (cid:174)𝑥 − 𝑃 (cid:174)𝑥, where 𝑃 is the projection matrix of the
weighted least squares estimator (as discussed in Section 2). We then
compute the sum of the meters’ squared residuals as 𝑟 = (cid:205)𝑀
𝑚.
𝑚=1 ^𝜖2
(We multiply the rows in the grid matrix 𝐺 that correspond to the
zero-injection nodes by a large constant 𝜅, so the 𝑁 ′ residuals that
correspond to those nodes are typically negligible.) If 𝑟 is above an

Securing Smart Grids Through an Incentive Mechanism for Blockchain-Based Data Sharing

agreed threshold 𝜃 , then the operators are penalized proportionally
to the squared residuals of their meters. Let 𝜙 ′ be an agreed constant
that determines the overall severity of the anomaly penalties. The
penalties are then as follows: we iterate over all meters 𝑚 ∈ M and
remove the following number of credits from of 𝑚’s operator:

Φ′

𝑚 =

𝜙 ′
𝑟

(cid:16)
𝜖2
𝑚 −

(cid:17)

.

𝑟
𝑀

(1)

𝜌
𝑂−1

or 𝜙
𝑂−1

That is, to compute Φ′
𝑚, we subtract from 𝑚’s squared residual 𝜖2
𝑚
the fraction 𝑟
𝑀 , i.e., the system-wide average squared residual. The
result is then multiplied by 𝜙′
𝑟 , which ensures that the maximum
penalty per meter remains below 𝜙 ′. This prevents an extremely
high residual, possibly due to an FDI attack or a fault, from causing
an operator to lose all of its credits in a short time period. Note that
Φ′
𝑚 can be either positive or negative, i.e., some operators profit
if others are penalized. In fact, it is easy to check that summing
(1) over all 𝑚 ∈ M yields 0, so no credits are ever created or lost.
Similarly, when a node is rewarded by 𝜌 or penalized by 𝜙, then
each of the other 𝑂 − 1 operators loses or gains
credits,
respectively. As such, the total number of credits is fixed by design.
We note that if two operators 𝑜 and 𝑢 are symmetric in the
sense that they have the same number of meters and a one-to-one
mapping between any 𝑚 ∈ M𝑜 and a 𝑚′ ∈ M𝑢 such that 𝑝𝑚 = 𝑝𝑚′,
then their expected net gains/losses are also the same. Hence, if
all operators have exactly the same meters and error probabilities,
then each of them will have a net loss of zero. In any other case,
the credits of at least one operator will tend to zero over time.
This means that smaller operators must periodically buy credits
from larger operators to avoid expulsion – hence, larger operators
are rewarded for contributing more meaningful data. This is an
essential feature of our mechanism, as operators would otherwise
not be incentivized to share as much data as they can. We assume
that payments for credit transfers are done out-of-band, and leave
alternative means of achieving this, for example, using a two-way
peg with a smart contract on another blockchain such as Ethereum
[5], as future work. The speed at which companies run out of credits
depends on the parameter choice. In Appendix C, we present a
realistic choice of parameters and illustrate our mechanism through
a numerical experiment.

4.2 Properties of the Incentive Mechanism
In this section, we investigate the properties that determine our
mechanism’s incentive compatibility. In particular, we present four
corollaries that formalize the conditions under which our mecha-
nism is incentive compatible. Each corollary considers a different
adversarial strategy: not registering valid meters, withholding mea-
surements from registered meters, blocking measurements from
other operators’ meters, and distorting measurements. These corol-
laries follow straightforwardly from three theorems that are stated
and proven in Appendix D.

Each theorem focuses on the expected gains of an operator 𝑜 ∈ O
in a single time slot, as changes to 𝑜’s credits are accrued over a
succession of slots. After each time slot is finalized, 𝑜’s credits are
affected by each meter 𝑚 ∈ M𝑜 in the following three ways:
(1) 𝑜 earns a reward 𝜌 if 𝑚 produced a measurement,
(2) 𝑜 incurs a penalty 𝜙 if 𝑚 did not produce one, and

(3) if there are no missing measurements and 𝑟 > 𝜃 , then 𝑜 earns

or loses Φ′

𝑚 credits in accordance with (1).
Furthermore, 𝑜’s credits are affected by the meters of other opera-
tors. Due to the redistribution of the credits, 𝑜 loses or gains credits
if other meters produce or miss measurements, respectively. Finally,
Φ′
𝑗 and 𝑟 , and
𝑚 depends on other meters’ measurements through 𝜖2
whether it is applied at all depends on whether any other meter
failed to produce a measurement. In Appendix D, we formalize
this by decomposing 𝑜’s expected gains during a time slot into a
summation with five terms:

𝑅net
𝑜

= 𝑅tot

𝑜 − Φtot

𝑜 − 𝑅oth
Each of the three theorems considers the impact on these terms of
the different adversarial strategies.

+ Φoth
𝑜

+ Φ′
𝑜 .

𝑜

Our first corollary formalizes the conditions under which it is
profitable to register a meter 𝑚, or to hide its existence from the
other operators.

Corollary 1. It is profitable for 𝑜 to add any meter 𝑚 ∈ M𝑜 if

the impact of adding the meter 𝑚 on Φ′

𝑜 is negligible and

𝑝𝑚 <

(cid:18)

1 +

𝜙
𝜌

(cid:19)−1

.

Proof. This follows from setting Δ𝑚 (I) = 0 in Theorem 1 in
□

Appendix D.

As it is profitable for 𝑜 to add suitable meters regardless of the
actions of other operators, it is a Nash equilibrium for all operators to
add all meters 𝑚 for which 𝑝𝑚 satisfies the bound in Corollary 1. In
practice, changes to Φ′
𝑜 can be small because the maximum penalty
𝜙 ′ is low, because 𝜃 is high, or because the new meter has a small
impact on the residuals. The bound in Corollary 1 depends only on
the ratio 𝜙
, which means
that the meter must be online at least half the time for the rewards
to outweigh the penalties. In practice, 𝜙 should be high compared
to 𝜌 (e.g., 𝜙
𝜌 > 1000) to ensure that meters with a relatively high
probability of being offline are not added.

𝜌 – e.g., if 𝜌 and 𝜙 are equal, then 𝜁 = 1
2

The next corollary formalizes whether it is profitable for 𝑜 to

share or withhold the readings produced by its meters.

Corollary 2. It is always profitable for 𝑜 to add the readings of

all of its meters unless

𝜌 + 𝜙 < ∑︁
𝑚 ∈M𝑜

Φ′
𝑚

and 𝑜 is unable to block a reading by another operator’s meter.

Proof. From Theorem 2 in Appendix D, we know that 𝑜’s profit
from withholding measurements equals 𝛿 +𝑞1𝑀′ (cid:205)𝑚 ∈M𝑜
Φ′
𝑚, with
𝛿 and 1𝑀′ as defined in the statement of the theorem. The operator
𝑜 maximizes 𝛿 by not withholding any of its own measurements,
i.e., choosing 𝑀 ′
𝑜 = 0. However, if 𝑜 also does not block any other
operator’s measurement (i.e., 𝑀 ′
¬𝑜 = 0), then 1𝑀′ = 0. In this case,
Φ′
choosing 𝑀 ′
𝑚. This
□
is positive if the bound in the corollary holds.

𝑜 = 1 results in a profit of −(𝜌 + 𝜙) + (cid:205)𝑚 ∈M𝑜

Informally, the corollary states that it is profitable for 𝑜 to add all
possible readings for its meters unless its expected loss of credits
through the anomaly penalties outweighs the loss of 𝜌 and the
penalty 𝜙. In this case it would be profitable to withhold a single
meter’s measurement. In practice, this situation can be avoided by
choosing a much smaller value for 𝜙 ′ than for 𝜙 and 𝜌.

Although it is generally profitable for 𝑜 to add measurements, the
zero-sum nature of credit redistributions implies that it is also prof-
itable to block other operators’ measurements. This is formalized
through the next corollary.

Corollary 3. If it possible for 𝑜 to block 𝑛 distinct measurements
of meters owned by other operators, then it is profitable to do so unless

𝑛
𝑂 − 1

(𝜌 + 𝜙) < ∑︁
𝑚 ∈M𝑜

Φ′
𝑚 .

Proof. Again, we obtain from Theorem 2 that 𝑜’s profit from
Φ′
𝑚. The oper-
¬𝑜 as
Φ′
𝑚 ≥ 0 then it is always
𝑜 = 0. However,
Φ′
𝑚 < 0, i.e., if 𝑜 is making a profit from the anomaly
¬𝑜 = 0 and
□

withholding measurements equals 𝛿 + 𝑞1𝑀′ (cid:205)𝑚 ∈M𝑜
ator 𝑜 maximizes 𝛿 by choosing 𝑀 ′
high as possible. If 𝑞1𝑀′ = 0 or (cid:205)𝑚 ∈M𝑜
optimal to maximize 𝛿 by choosing 𝑀 ′
if (cid:205)𝑚 ∈M𝑜
penalties, then it can be profitable for 𝑜 to choose 𝑀 ′
𝑀 ′
𝑜 = 0, but only if the bound in the corollary holds.

𝑜 as low as possible and 𝑀 ′

¬𝑜 = 𝑛 and 𝑀 ′

The result of Corollary 3 is a necessary consequence of the
incentive mechanism: if 𝑜 has no incentive to block measurements,
then 𝑜 also has no incentive to share measurements. It should
therefore be made as hard as possible for 𝑜 to block measurements.
We discuss this in more detail in Section 6.

The final corollary formalizes the conditions under which it is
profitable for 𝑜 to distort measurements. This is a technical con-
dition that depends strongly on the structure of the grid and the
location of 𝑜’s meters within it. In the following, let D ⊂ M be
the set of smart meters whose measurements can be arbitrarily
distorted by 𝑜. Typically D = M𝑜 but this is not a requirement. Let
𝑑𝑚, 𝑚 ∈ M, be the distortion applied to 𝑚’s measurement, and 𝑥𝑚
the “true” – i.e., corresponding to the physical reality at 𝑚’s claimed
location in the grid – measurement of meter 𝑚. We then construct
the (2𝑀 + 𝑁 ′) × 1 vector (cid:174)𝑦 as follows: the first 𝑀 entries correspond
to 𝑑1, . . . , 𝑑𝑀 , the next 𝑀 values correspond to 𝑥1, . . . , 𝑥𝑀 , and the
final 𝑁 ′ entries correspond to the zero-injection nodes. We can
then prove the following corollary.

Corollary 4. With (cid:174)𝑦 as defined above and matrix 𝐴 as defined in
Appendix D, it is profitable for 𝑜 to introduce distortions 𝑑𝑚, 𝑚 ∈ D,
given 𝑥𝑚, 𝑚 ∈ M, if and only if (cid:174)𝑦 𝑇 𝐴(cid:174)𝑦 < 0.

Proof. This is a reformulation of Theorem 3 in Appendix D. □

In practice, an honest operator can determine whether a coalition
of other operators is able to profit from distorted measurements by
checking whether some combinations of distortions 𝑑 and measure-
ments 𝑥 exist such that (cid:174)𝑦 𝑇 𝐴(cid:174)𝑦 < 0. However, the operator should
be careful to eliminate trivial attacks: e.g., where a single meter
has an error, and the “attack” is to correct this error. This can be

Daniël Reijsbergen, Aung Maw, Tien Tuan Anh Dinh, Wen-Tai Li, and Chau Yuen

achieved by introducing a suitable constraint: e.g., that the resid-
uals 𝜖 = 𝑃 (cid:174)𝑥 − (cid:174)𝑥 are equal to zero without the attack. This can be
formulated as a Quadratic Programming (QP) problem:

minimize
subject to 𝑃 (cid:174)𝑥 − (cid:174)𝑥 = 0

(cid:174)𝑦 𝑇 𝐴(cid:174)𝑦

𝑥𝑚 ≥ 0, 𝑚 ∈ M
𝑑𝑚 = 0 , 𝑚 ∉ D.

(2)

If the result found by solving (2) equals 0, then no profitable at-
tack exists, whereas a profitable attack does exist if the result is
negative. Solving a QP is computationally efficient if 𝐴 is positive
semidefinite, but this is not always true in our setting. In this case,
solving the QP is NP-Hard. Even in this case, state-of-the-art solvers
such as BARON or IBM’s CPLEX are typically able to solve QPs
for several dozen variables. An alternative formulation of incentive
compatibility is to add the constraint (cid:174)𝑦 𝑇 𝐴(cid:174)𝑦 < 0 to (2), and change
the objective function to an arbitrary constant. Our mechanism is
then incentive compatible if no feasible solution can be found. How-
ever, we have found that some of the software tools – in particular
CPLEX – support matrices that are not positive semidefinite in the
objective function, but not in the constraints. We leave a further
investigation into the use of QP tools as future work.

5 IMPLEMENTATION
In this section, we present an implementation of our data sharing
solution, including the incentive mechanism described in the previ-
ous section. In particular, we implement our solution on a private
blockchain maintained by the consortium. The smart contract pro-
cesses data uploads and operates the incentive mechanism. Each
operator runs a blockchain node on one of its MDMS servers. We
use Hyperledger Fabric for our implementation, due to its three
advantages over the alternatives, e.g., private Ethereum. First, it
has higher throughput [13]. Second, it supports a centralized Mem-
bership Service Provider (MSP) that allows us to easily add and
remove operators from the system. Third, while Ethereum executes
its contracts on its own virtual machine, Hyperledger supports
native code execution. In particular, a Hyperledger contract can be
written in the Go language and import third-party libraries, e.g.,
libraries that support fast matrix computations.

5.1 Data Model
The smart contract stores a variety of data fields, including informa-
tion about the grid topology, the measurements, the system-wide
constants and parameters, and information that is cached (e.g., the
projection matrix 𝑃). We note that Hyperledger only allows data to
be stored in the form of key-value pairs, so during processing we
occasionally need to parse strings into arrays or binaries. We did
not find that this had a major impact on performance. An overview
of the key-value pairs stored in the contract can be found in Table 1.

5.2 Smart Contract Functions

Initialization. As mentioned before, the consortium members
agree before the initialization of the smart contract on the sys-
tem parameters. These parameters are set to the agreed values
when the contract is created. Furthermore, an initial grid topology

Securing Smart Grids Through an Incentive Mechanism for Blockchain-Based Data Sharing

Table 1: Key-value pairs stored in the smart contract.

name

value

key

data type

𝑛1
𝑛2
𝑜
𝑋
𝑙
𝑛

𝑠

𝑑
X′

1st connected bus ID
2nd connected bus ID
operator ID
reactance
line ID
node ID

type:

0 ⇒ SCADA bus
1 ⇒ SCADA line
2 ⇒ PMU
deposit (credits)
recorded measurements

line ID
line ID
meter ID
line ID
meter ID
meter ID

integer-integer
integer-integer
integer-integer
integer-float
integer-integer
integer-integer

meter ID

integer-integer

operator ID integer-integer
integer-float list

epoch

Algorithm 1: Measurement processing.
1 function changeDeposit(𝑜, 𝐷)
2

⊲ cannot subtract more from 𝑜 than 𝑑 [𝑜 ]

⊲ operators with non-zero credit

𝑑 [𝑜 ] ← 𝑑 [𝑜 ] + Δ∗

⊲

due to rounding,
it may be that Δ∗ ≠ 𝑑

⊲ meters that reported a measurement

𝐷′ ← max(−𝑑 [𝑜 ], 𝐷)
Δ∗ ← 0
O′ ← ∅
𝑂 ← 0
for 𝑜′ ∈ O do

if 𝑑 [𝑜 ] > 0 then

O′ ← O′ ∪ {𝑜 }
𝑂 ← 𝑂 + 1

for 𝑜′ ∈ O′ do

(cid:107)

if 𝑜′ ≠ 𝑜 then
(cid:106) 𝐷′
Δ ←
𝑂−1
𝑑 [𝑜′ ] = 𝑑 [𝑜′ ] − Δ)
Δ∗ ← Δ∗ + Δ

16 function finalizeTimeSlot(𝑡 )
17

M′ ← ∅
for (𝑣, 𝑚) ∈ X′ [𝑡 ] do

𝑥𝑚 ← 𝑣
changeDeposit(𝑜 [𝑚], 𝜌)
M′ ← M′ ∪ {𝑚 }

if M′ = M then

for 𝑖 ∈ {1, . . . , 𝑁 ′ } do

𝑥𝑖+𝑀 = 0

(cid:174)𝑥 ← (𝑥1, . . . , 𝑥𝑀+𝑁 ′ )𝑇
(cid:174)𝜖 ← (cid:174)𝑥 − 𝑃 (cid:174)𝑥
𝑟 ← (cid:205)𝑀
𝜖 2
𝑗 =1
𝑗
Δ∗ ← 0
if 𝑟 > 𝜃 then
𝑘 = 𝑟 /𝑀
for 𝑗 ∈ {1 . . . , 𝑛 } do
Δ ← ⌊𝜙′ (𝜖 2
𝑑 [𝑜 [𝑚 𝑗 ] ] ← 𝑑 [𝑜 [𝑚 𝑗 ] ] − Δ
Δ∗ ← Δ∗ + Δ

𝑗 − 𝑘)/𝑟 ⌋

𝑚∗ ← RandomValue(1, . . . , 𝑀)
𝑑 [𝑚 [𝑜 ∗ ] ] ← 𝑑 [𝑚 [𝑜 ∗ ] ] − Δ∗

else

for 𝑚′ ∈ M\M′ do

changeDeposit(𝑜 [𝑚′ ], −𝜙)
39
40 function processMeasurement(𝑣′, 𝑡 ′, 𝑚′)
41

𝑐 ← currentBlock()
X′ [𝑡 ′ ] ← X′ [𝑡 ′ ] ∪ { (𝑣′, 𝑚′) }
while 𝑐 > (𝑓 + 1) · 𝜂 + 𝜏 ∗ do
finalizeTimeSlot( f+1)
𝑓 ← 𝑓 + 1

3

4

5

6

7

8

9

10

11

12

13

14

15

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

42

43

44

45

(N , N ′, L, M) is chosen and the initial consortium members O
are given an initial deposit 𝛾.

Algorithm 2: Updating the grid.
1 function findTopologyMatrix(N, N′, L, M)
2

for 𝑖 ∈ 1, . . . , |N | − 1 do

for 𝑗 ∈ 1, . . . , |M | + |N′ | do

𝑔𝑖 𝑗 ← 0

𝑖 ← 0
for 𝑚 ∈ M do
𝑖 ← 𝑖 + 1
if 𝑠 [𝑚] = 0 then
for 𝑙 ′ ∈ L do

if 𝑛1 [𝑙 ′ ] = 𝑛 [𝑚] then

𝑔𝑖 𝑛1 [𝑙′ ] ← 𝑔𝑖 𝑛1 [𝑙′ ] − 1/𝑋 [𝑙 ′ ]
𝑔𝑖 𝑛 [𝑚] ← 1/𝑋 [𝑙 ′ ]

else if 𝑠 [𝑚] = 1 then

𝑔𝑛1 [𝑙 [𝑚] ] ← −1/𝑋 [𝑙 [𝑚] ]
𝑔𝑛2 [𝑙 [𝑚] ] ← 1/𝑋 [𝑙 [𝑚] ]

else

𝑔 [𝑏 [𝑚] ] ← 1

for 𝑛 ∈ N′ do

for 𝑙 ′ ∈ L do

if 𝑛1 [𝑙 ′ ] = 𝑛 [𝑚] then

𝑔𝑖 𝑛1 [𝑙′ ] ← 𝑔𝑖 𝑛1 [𝑙′ ] − 𝜅
𝑔𝑖 𝑛 [𝑚] ← 𝜅

22
23 function multiplyCheck(𝐴, 𝐵, 𝐶, 𝐷)
24

𝑋 = 𝐴𝐵
𝑌 = 𝑋𝐶
return 𝑌 = 𝐷

26
27 function updateGrid(N, N′, L, M, 𝑃 ′, 𝑈 )
28

𝐺 ′ ← findTopologyMatrix(N, N′, L, M) if
multiplyCheck(𝐺 ′𝑇 , 𝐺 ′, 𝑈 , 𝐼|M|+|N′ | ) then
if multiplyCheck(𝐺 ′, 𝑈 , 𝐺 ′𝑇 , 𝑃 ′) then

𝐺 ← 𝐺 ′
𝑃 ← 𝑃 ′

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

25

29

30

31

Measurement Processing. During each time slot, each node up-
loads one measurement per meter by calling the processMeasure-
ment function of Algorithm 1. This function adds the measurement
to X′[𝑡 ′], which is the set of measurements for the current time slot
𝑡 ′, and checks for which previous time slots the cut-off period has
passed. For each such previous time slot 𝑡, the effect on the deposits
can be processed through a call to finalizeTimeSlot. This function
first evaluates which meters have reported a measurement during
𝑡 – these measurements are added to the set M ′ and the operator
of the meter is rewarded through a call to changeDeposit. If some
meters have not reported a measurement, then they are punished
and the routine terminates. However, if all nodes have reported
a measurement then the anomaly detection routine is started. In
particular, the residual vector ^𝜖 is determined, and if the sum of
squared residuals 𝑟 exceeds the threshold 𝜃 , then the deposits are
changed in accordance with (1).

We note that the function changeDeposit has built-in checks to
ensure that nodes with zero credits do not gain credits from the
redistribution of penalties to other nodes. Furthermore, it checks
that no credits are lost due to rounding errors. Rounding errors
may also occur when administering the anomaly penalties: in this
case, any remaining credits are given to the operator of a meter
sampled uniformly at random from M.

Grid Change. To change the grid – e.g., to add/remove meters,
nodes, or lines – one node proposes the change by using a transac-
tion to call the updateGrid described in Algorithm 2. This transac-
tion lists the new values for N , N ′, L, and M. The grid topology is

calculated using these lists in the findTopologyMatrix function of Al-
gorithm 2. This function constructs the grid topology as discussed
in [25, 42] and particularly [6]. Additionally, the new matrices
𝑈 = (𝐺𝑇 𝐺)−1 and 𝑃 are sent as parameters of Algorithm 2. As
we discuss in Section 5.3, this speeds up the function by moving a
computationally expensive matrix inversion from the blockchain
(which is performed by all nodes) to a single node. The matrices
are checked for correctness in the smart contract through the func-
tion multiplyCheck(𝐴, 𝐵, 𝐶, 𝐷) which returns true if 𝐴𝐵𝐶 = 𝐷
and false otherwise. In particular, the algorithms checks whether
𝐺𝑇 𝐺𝑈 = 𝐼𝑛, where 𝐼𝑛 is the identity matrix with dimension 𝑛, and
whether 𝐺𝑈 𝐺𝑇 = 𝑃. The interaction between the processes exe-
cuted by a node’s client and the blockchain is depicted in Figure 3.

Figure 3: Flowchart that depicts the processes that occur
when the grid topology is changed.

Although we omit this from the pseudocode for brevity, all op-
erators whose meters and added/removed must vote to approve
changes to the grid. Other nodes do not need to approve the changes,
but have the ability to cast a veto within a cooldown period if the
change is suspected to be the work of an attacker – e.g., removing
all or nearly all of an operator’s meters, or adding too many meters.

Other Functions. We briefly discuss the remaining smart contract
functions, but we do not present pseudocode for them because they
are straightforward to implement. First, operators will occasionally
transfer funds between each other, particularly if one has almost
depleted its credits. This can be done via a call to a transferCredits
function that removes credits from the sender’s deposit and adds
the same amount to the recipient’s deposit.

To expel an operator who has run out of credits, a function
expelOperator can be called to remove the operator from O, and
remove all meters that it operates. To add a new operator, a function
addOperator can be called by an existing operator 𝑜 – as part of this
function, 𝑜 must also send credits to the new operator. Otherwise,
the addition/removal of the node (and the suspension of read access)
is processed via the MSP in Hyperledger Fabric.

Finally, the operators may occasionally want to change the sys-
tem parameters. This could be for a variety of reasons, e.g., when
the anomaly detection threshold 𝜃 is found to be too high or low
relative to the natural variance in the measurements. In this case,
one node proposes a system parameter change through a call to the
proposeParameter function. In this case, a supermajority of operator
must vote to approve the change – note that the supermajority
threshold itself can be a modifiable system parameter.

Daniël Reijsbergen, Aung Maw, Tien Tuan Anh Dinh, Wen-Tai Li, and Chau Yuen

5.3 Asymptotic Complexity
In this section we analyze the asymptotic complexity of the func-
tions in Algorithms 1 and 2, and identify the bottlenecks that we
seek to ameliorate. Before we begin, we note that the time complex-
ity of multiplying an 𝑁 ×𝑀 matrix by an 𝑀 ×𝐾 matrix is Θ(𝑁 𝑀𝐾).2
Furthermore, the time complexity of checking the equality of two
𝑁 × 𝑀 matrices is Θ(𝑁 𝑀). An overview of the time complexities
of the most computationally intensive lines in the smart contract
functions is given in Table 2. To obtain these results, we made two
assumptions about the grid, in particular that (𝑀 + 𝑁 ′) ≥ 𝑁 − 1
(as otherwise the matrix 𝐺𝑇 𝐺 would not be invertible), and that
Θ(𝑀𝐿) = Θ(𝑀𝑁 ) = Θ((𝑀 + 𝑁 ′)𝑁 ) (as there will typically be only
several lines per node, and one or two meters per line).

We discuss the updateGrid function in Algorithm 2 in detail, as
it includes an important optimization step. The function starts by
calling the findTopologyMatrix function to obtain 𝐺, which has com-
plexity Θ((𝑀 + 𝑁 ′)𝑁 ). It then calls multiplyCheck in line 28, which
computes 𝐺𝑇 𝐺. This consists of multiplying an (𝑁 − 1) × (𝑀 + 𝑁 ′)
by an (𝑀 + 𝑁 ′) × (𝑁 − 1) matrix. The time complexity of this is
Θ((𝑀 + 𝑁 ′)𝑁 2). Next, 𝐺𝑇 𝐺 is multiplied by 𝑈 , which has com-
plexity Θ(𝑁 3). It then checks equality with a (𝑁 − 1) × (𝑁 − 1)
identity matrix, which requires Θ(𝑁 2) operations. In line 29, mul-
tiplyCheck is invoked again. First, 𝐺𝑈 𝐺𝑇 is computed, which re-
quires the multiplication of a (𝑀 + 𝑁 ′) × (𝑁 − 1) matrix with a
(𝑁 − 1) × (𝑁 − 1) matrix. This is followed by the multiplication
of a (𝑀 + 𝑁 ′) × (𝑁 − 1) matrix with a (𝑁 − 1) × (𝑀 + 𝑁 ′) matrix.
The first step has complexity Θ((𝑀 + 𝑁 ′)𝑁 2) and the second step
a complexity of Θ((𝑀 + 𝑁 ′)2𝑁 ).

If, instead of requiring 𝑈 and 𝑃 as transaction input, the smart
contract would determine 𝑃 directly from 𝐺, then it would have to
compute 𝐺 (𝐺𝑇 𝐺)−1𝐺𝑇 by itself. This would require three matrix-
matrix multiplications, in contrast to the four used in the current
implementation. However, it would also require the inversion of an
(𝑁 − 1) × (𝑁 − 1) matrix. Inversion of an (𝑁 − 1) × (𝑁 − 1) matrix
has the same theoretical time complexity as multiplication of two
(𝑁 − 1) × (𝑁 − 1) matrices, but in practice it is much slower. Our
approach is therefore faster than the naïve approach.

Table 2: Time complexity of the smart contract functions

function

finalizeTimeSlot
findTopologyMatrix
updateGrid

complexity
Θ((𝑀 + 𝑁 ′)2)
Θ((𝑀 + 𝑁 ′)𝑁 )
Θ((𝑀 + 𝑁 ′)2𝑁 )

5.4 Performance Optimizations
To detect an attack as soon as possible, it is preferable for the time
slot duration to be as short as possible. Short time slot durations
have the additional advantage of minimizing the variance between
measurements taken at different time points in the slot. However,
since the finalizeTimeSlot must be executed at least once per time
slot, it is essential that the computational overhead of this function
is minimal. Furthermore, even though updateGrid is only called

2While some practical approaches exist that achieve slightly higher speeds, e.g.,
Strassen’s algorithm, this does not have an impact on our analysis.

ClientSmartContract1.updateN,N0L,M2.constructGbasedonN,N0L,M3.computeU=(GTG)−14.computeP=G(GTG)−1GT5.sendN,N0L,M,U,andPa.constructGbasedonN,N0L,Mb.verifythatGTGU=Ic.verifythatGUGT=Pd.ifsuccessful,updatePSecuring Smart Grids Through an Incentive Mechanism for Blockchain-Based Data Sharing

sporadically, its computational overhead should not be such that it
significantly impedes the processing of measurements. It is there-
fore essential that the performance of these functions is optimized.
To achieve this, we have implemented four practical optimiza-
tions. The first optimization is the offline computation and caching
of 𝑃 as discussed in Section 5.2. By moving the most expensive
part of the computation offline, we avoid interference with the
processing of measurements.

For the second optimization, we replace the function multiply-
Check, which uses two expensive matrix-matrix multiplications,
with the freivaldsCheck function of Algorithm 3. The latter uses
Freivalds’ algorithm [16, 37], which is a randomized algorithm that
requires four inexpensive matrix-vector multiplications instead of
two matrix-matrix multiplications. Our implementation makes use
of a cryptographic hash function 𝐻𝑝 that takes a byte array as input
and returns an integer that is sampled uniformly at random from
{0, . . . , 𝑝 − 1}. We then construct a random vector (cid:174)𝑟 by repeatedly
applying 𝐻𝑝 to a concatenation 𝐴|𝐵|𝐶 |𝐷 of the four input variables.
The function then evaluates whether 𝐴𝐵𝐶(cid:174)𝑟 = 𝐷 (cid:174)𝑟 . It can be shown
that if 𝐴𝐵𝐶 ≠ 𝐷, then the probability that freivaldsCheck returns
true is at most 1
𝑝 , which is negligible for large 𝑝.

Algorithm 3: Fast verification of matrix equalities.
1 function freivaldsCheck(𝐴, 𝐵, 𝐶, 𝐷)
2

(cid:174)𝑟 = (𝑟1 . . . , 𝑟𝑚𝐷 )
𝑟1 ← 𝐻𝑝 (𝐴 |𝐵 |𝐶 |𝐷)
for 𝑖 ∈ {2, . . . , 𝑚𝐷 } do
𝑟𝑖 ← 𝐻𝑝 (𝑟𝑖−1)

(cid:174)𝑐 ← 𝐶 (cid:174)𝑟
(cid:174)𝑏 ← 𝐵(cid:174)𝑐
(cid:174)𝑎 ← 𝐴 (cid:174)𝑏
(cid:174)𝑑 ← 𝐷 (cid:174)𝑟
return (cid:174)𝑎 = (cid:174)𝑑

3

4

5

6

7

8

9

10

The third is the efficient storage of measurement data by parti-
tioning the set X′ into different sets X′[𝑡] for each time slot 𝑡. We
also store the elements of these sets using a different key-value pair
for each measurement, instead of using a single key-value pair to
store the entire set. The former approach reduces the complexity of
write operations, since it avoids reading the existing entry, updating
it, and writing the new combined value to the storage – also known
as write amplification. By contrast, the latter approach would reduce
the number of read operations in finalizeTimeSlot. However, we
found that the write operations were a greater bottleneck than the
read operations, as we discuss further in Section 7.

Finally, we found in Section 5.3 that the bottlenecks in both final-
izeTimeSlot and updateGrid were matrix-vector or matrix-matrix
multiplications. Both are trivially paralellized, since the computa-
tion of the elements in different rows can be done independently.

6 ANALYSIS
In this section, we analyze the data sharing solution presented in
Sections 4 and 5 in terms of the requirements of Section 3.3, i.e.,
FDI attack security, incentive compatibility, and scalability. For each
requirement, we discuss the technical conditions under which it is
satisfied, and we conclude the section by discussing the practical
relevance of these conditions and our modeling assumptions.

6.1 Requirements
FDI Attack Security: for this requirement to be satisfied, FDI attacks
against a compromised operator must still be detectable if redun-
dant measurements are performed by uncompromised operators. To
make this formal, we consider an attack in which a set of operators
𝐴 ⊂ O is compromised. In such an attack, all meters 𝑚 ∈ M ′(𝐴)
where M ′(𝐴) = ∪𝑜 ∈𝐴M𝑜 are insecure and their measurements
can be arbitrarily distorted by the FDI attacker, whereas the other
meters are secure and their measurements cannot be distorted. This
scenario is well-known from the FDI literature [7, 10] – e.g., [10]
discusses placement strategies for secure meters that ensure that
the system remains observable even if the insecure meters are sub-
ject to an FDI attack. In our setting, each operator 𝑜 ∈ 𝐴 should
consider the system that consists only of the meters in M\M ′(𝐴)
and the nodes in N that are sensitive to an FDI attack – i.e., those
nodes for which it holds that if their state is not estimated correctly,
then grid operation may fail, e.g., leading to blackouts. If this system
is observable (i.e., the matrix 𝐺 has full rank), then the data sharing
solution satisfies the property of FDI attack security.

𝑜

Incentive Compatibility – Joining the Network: the first part of
our incentive compatibility requirement is satisfied if operators are
incentivized to join the data sharing consortium. This holds for any
operator 𝑜 if 𝑜’s benefits of joining outweigh the costs. To determine
whether this is true for 𝑜, we first determine the expected credit
change per time slot 𝑅net
as defined in Section 4. A first observation
is that if 𝑅net
is positive, then it is always profitable for 𝑜 to join
the network. However, if 𝑅net
needs to be
outweighed by the reduced expected costs of an FDI attack per time
slot, which we denote by 𝐾. To compute 𝐾, the operator must
determine for each attack scenario 𝐴 ⊂ O the quantities 𝑝ATT
𝐴 ,
DET
𝐴 , 𝐾𝐴, and 𝐾 ′
𝐴, which are defined as follows:
1
𝑝ATT
𝐴

is negative, then 𝑅net

𝑜

𝑜

𝑜

the likelihood that attack scenario 𝐴 occurs in a single
time slot (e..g, if 𝐴 is expected to occur once a year,
and a year consists of 𝑆 slots, then 𝑝ATT
1 if the attack 𝐴 can be detected by the meters in
M\M ′(𝐴) and 0 otherwise,
the expected cost of attack 𝐴 if it is detected, and
the expected cost of attack 𝐴 if it not detected.

= 𝑆−1),

𝐴

DET
1
𝐴

𝐾𝐴
𝐾 ′
𝐴

Given these quantities, 𝑜 is incentivized to join the network if

−𝑅net
𝑜

< ∑︁
𝐴 ⊂ O

𝑝ATT
𝐴 1

DET
𝐴 (𝐾𝐴 − 𝐾 ′

𝐴),

that is, if the expected costs per time unit of participating in the
mechanism are smaller than the expected cost reduction per time
unit from attacks that the mechanism can detect.

Incentive Compatibility – Adversarial Behavior: the conditions
under which each of the five types of adversarial behavior presented
in Section 3.2 are disincentivized are as follows.

• Refraining from registering valid meters: from Corollary 1,
we know that it is always profitable for 𝑜 to add each me-
ter 𝑚 whose probability of missing a measurement 𝑝𝑚 is
low enough, i.e., below the bound stated in the corollary. As
such, it is only profitable to add those meters for which the
probability of missing a measurements is low enough.

• Uploading fake measurements from offline or non-existing
meters: we know from Corollary 2 that is always profitable
to upload as many measurements as possible, even from fake
or offline meters. However, from Corollary 4 we know that
sharing measurements that do not reflect the true system
state can be costly, depending on the grid topology.

• Taking its own meters offline: we know from Corollary 2 that

this is never profitable.

• Blocking other operators’ measurements: we know from Corol-

lary 3 that this is always profitable if it is possible.

• Uploading distorted measurements: we know from Corollary 4
that this can be costly, depending on the grid topology.

Scalability: as discussed in Section 5.4, we have presented four
optimizations that improve our data sharing solution’s practical
performance: offline computation of the matrix 𝑃, Freivalds’ algo-
rithm, partitioning the measurement dataset, and multithreading.
To demonstrate that this is sufficient to support thousands of meters,
we present an experimental evaluation in Section 7.

6.2 Discussion: Practical Relevance
We now discuss the practical impact of the technical conditions
mentioned in the previous section. We first discuss the impact
of an operator’s size on its expected gains and losses, and then
discuss how to defend against types of misbehavior that are not
disincentivized (e.g., blocking or distorting measurements).

Large vs. Small Operators: in the previous section, we saw that
operators join the consortium only if the expected costs of lost
credits are outweighed by the expected cost of an FDI attack and
whether such an attack can be prevented by the data sharing solu-
tion. The latter only holds if the operator’s meters are redundant
in a network that also includes the meters of other operators. In
general, this is more likely to be the case for smaller operators
than for larger operators. For example, in a system with regional
operators (e.g., Japan), only the meters on the edge of the operator’s
region are likely to have redundant measurements performed by
other operators. If an operator’s region is smaller, then the fraction
of its meters that are on the region’s edge will typically be larger,
as the region’s interior will be smaller. Similarly, in a system with
a handful or large TSOs and a multitude of smaller DSOs (e.g., Ger-
many), the measurements that are most important to the DSOs (i.e.,
on lines with the largest power flows) will be performed on lines
that are also of interest to the TSOs.

Conversely, larger operators are in general more likely to profit
from the credit redistribution mechanism than smaller operators,
because they share a larger number of measurements. As such, our
mechanism maximizes operator participation by incentivizing both
smaller and larger operators to join: the larger operators because
they gain credits, and the smaller ones because they gain a larger
degree of protection from FDI attacks.

Alternative Defenses Against Persistently Adversarial Operators:
We saw in Section 6.1 that the following three types of adversarial
behavior are not always disincentivized: uploading fake measure-
ments, blocking measurements, and (depending on the grid topol-
ogy) distorting measurements. In each case, defense measures exist
that make this type of adversarial behavior hard to execute. In the

Daniël Reijsbergen, Aung Maw, Tien Tuan Anh Dinh, Wen-Tai Li, and Chau Yuen

first case, uploading fake measurements can be made harder by re-
quiring that measurements are signed by the meter using a private
key that is known only to the equipment manufacturer. Such func-
tionality is supported by default in meters that are equipped with a
Trusted Platform Module [38]. In the second case, mechanisms that
defend against transaction blocking attacks – e.g., DoS or eclipse
attacks – are known from the blockchain security literature [19].
In Appendix E, we discuss how to defend against such attacks in
our setting using round-robin consensus. Finally, operators can use
audits by external parties to detect measurement distortion attacks.
In practice, an operator would not only consider direct financial
incentives before adopting an adversarial strategy, but also repu-
tation damage and lawsuits. Some types of misbehavior (e.g., not
adding a measurement) are legal but undesirable, whereas others
are illegal (e.g., blocking another operator’s measurements or dis-
torting measurements). Depending on the political situation in the
operator’s country, a regulator could simply make all data sharing
mandatory. However, as witnessed by the Tennet lawsuit [14], but
also the recent Volkswagen emissions and LIBOR fraud cases, laws
alone cannot provide a strict guarantee against misbehavior that is
hard to detect. As such, our mechanism disincentivizes mild and
hard-to-detect cases of misbehavior (e.g., neglecting to add meters),
while leaving only the more serious cases that are susceptible to
detection by other operators to the regulator.

7 EXPERIMENTS
In this section we present our evaluation of the effect of our opti-
mizations on performance. We use Hyperledger Fabric v0.6 with
version 1.13 of Go for the smart contract (‘chaincode’ in Hyperledger
terminology). All the transactions are signed using the SHA256 hash
algorithm. For matrix multiplication and serialization, we use the
Go library gonum-v1. We run the Hyperledger nodes on top of 4
powerful VMs – each VM runs ubuntu-18.04, and has 8 cores and
32GB RAM. For each Hyperledger node, we increase the Docker
memory limit to 25GB. In the following, we use the shorthand no-
tation 𝐾 = 𝑀 + 𝑁 ′ for the dimension (“size”) of the matrices that
we use for benchmarking.

First, we evaluate the cost of grid updates and time slot final-
izations for both single- and multi-threaded processing, to show
the benefits of parallelizing matrix computations. Figure 7a shows
the transaction execution time for finalization. Although loading
the matrices from storage takes a large amount of time for large
matrices, e.g., 2 seconds even for 𝐾 = 5000, we observe the benefits
of parallel computation as the matrix size grows. In Figure 7b, we
display the execution times of updates to the projection matrix 𝑃,
which is a 𝐾 ×𝐾 square matrix. The transaction size for 𝐾 = 1000 is
32MB and for 𝐾 = 2000 it is 128MB. Single-threaded computation
takes a long time and even crashes at 𝐾 = 2500.

Next, we show the impact of our data storage and parallel execu-
tion optimizations on the throughput over time in Figures 5a and 5b.
Measurements are simulated and sent as transactions, and the time
slots are finalized after 40-second intervals. We obtain the maxi-
mum throughput by increasing the requests per second for as long
as the blockchain can manage. The matrix size 𝐾 equals 2000 and
the transaction size is 686 Bytes, including the signature. We clearly

Securing Smart Grids Through an Incentive Mechanism for Blockchain-Based Data Sharing

(a) Finalize and detect anomaly

(a) Single vs multiple key-value pairs

(b) Update projection matrix

Figure 4: Speed up due to parallel matrix multiplication.

(a) Single vs multiple key-value pairs

(b) Single vs multiple thread anomaly detection

Figure 5: Throughput with different optimizations.

see that the throughput drops after each time slot finalization (at
each 40 second mark) in both figures.

Figure 5a shows the effect of different data layouts. When we
store multiple values on the same key, we suffer from write amplifi-
cation (as discussed in Section 5.4), so throughput is low. Figure 5b
shows the impact of parallel execution on throughput. We see that
the impact is limited, because the execution time is too small to
affect throughput. The average throughputs for 𝐾 = 2000 are as fol-
lows: 51.6 for multi-threaded execution and 50.3 for single-threaded
execution, which is not a major difference. We therefore find that al-
though multithreading greatly accelerates grid updates, it does not
have a major effect on time slot finalizations. However, data storage
optimization does have a significant effect on the measurement
transaction throughput. We note that even though the throughput
is low at 50 tx/sec, this means that we can set the time slot duration
to 40 seconds for 2000 meters and hence collect measurements from
each meter every 40 seconds.

(b) Single vs multiple thread anomaly detection

Figure 6: Effect of different performance optimizations on
the execution time of the grid change algorithm.

Finally, Figure 6a shows the reduction in execution time that we
achieve by replacing the multiplyCheck function of Algorithm 2
with the more efficient freivaldsCheck from Algorithm 3. We ob-
serve that the execution time drops further, from over 25 seconds
for 𝐾 = 5000 to slightly over 12 seconds. However, we also observe
little difference between executing the three matrix-vector multi-
plications sequentially in a single thread, (brown line) or in parallel
(green line). To explain this, we display in Figure 6b a breakdown of
the cost into the network transfer cost – i.e., transmitting the data
of the fairly large 𝑃 and 𝑈 matrices – and the computational cost
of the two algorithms. In contrast to the multiplyCheck, the cost
of executing the freivaldsCheck function is negligible compared
to the network cost. As such, the potential to further reduce the
execution time of this function through computational speed-ups
is negligible.

8 RELATED WORK
Since we have already compared the paper to related work from the
state estimation literature in Section 3, we instead focus in this sec-
tion on comparing our work to related blockchain approaches for
smart grids. Fan and Zhang [15] propose a consortium blockchain
that allows operators and consumers to exchange data, but they
focus solely on privacy concerns that they address through en-
cryption. In another paper by the same authors [46], a blockchain
mechanism is proposed that allows devices such as smart meters to
exchange fault diagnosis reports through a blockchain. Li et al. [26]
present a blockchain framework that allows prosumers (consumers
that produce electricity, e.g., via solar panels) to trade energy credits
with other consumers. In general, blockchain solutions that allow
users to exchange credits in a privacy-preserving manner are an
active research field – see also, e.g., [17, 32]. These works are orthog-
onal to ours as they do not consider data sharing incentives, as the
incentive to participate in their frameworks is to sell energy credits.
A detailed overview of blockchain solutions applied to different
smart energy systems and applications can be found in [39].

matrix sizeexec time (s)05101550007500100001250015000Multi-threadSingle-threadmatrix sizeexec time (s)0102030401000150020002500Multi-threadSingle-thread020406080100120140160050100matrixsizeExectime(s)Single-valueMulti-value020406080100120140160050100matrixsizeExectime(s)SinglethreadMultithread1,0002,0003,0004,0005,000020406080matrixsizeExectime(s)Multiply,1threadMultiply,multithreadFreivalds,1threadFreivalds,multithread1,0002,0003,0004,0005,0006,0007,00002040matrixsizeExectime(s)NetworktransferFreivaldsMultiply9 CONCLUSIONS & DISCUSSION
In this paper, we have presented a blockchain solution that incen-
tivizes operators to share data to detect FDI attacks. Our solution
provides security in settings where an individual operator is not
able to detect attacks due to a lack of redundancy. We have pre-
sented a formal analysis of our incentive mechanism, and shown
that operators are motivated to share data of as many meters as
possible as long as the meter’s error probability is sufficiently low.
Finally, we have presented four optimizations that allow our solu-
tion to be applied to realistic grids with thousands of meters.

Although the blockchain nodes may introduce a new attack
vector, we note that an FDI attacker would not be able to violate
network safety or liveness unless they compromise more than a
third of all operators in the consortium. However, we do require that
the blockchain client run by the operator is trusted, e.g., if the client
does not validate the signatures of new blocks then our data sharing
solution would be ineffective because the FDI attacker would be
able to arbitrarily distort the measurements of other operators.
However, the security of blockchain clients is a generic challenge
that is not specific to smart grids. Bugs in the smart contract may
also introduce a new type of vulnerability, but the smart contract’s
code can be audited by all consortium members.

In future work, we aim to investigate whether we can replace
the MSP in Hyperledger, which we use to expel nodes, with a ded-
icated encryption mechanism that expels nodes by resetting the
encryption/decryption key among the remaining operators. An-
other interesting question is whether the asynchronous protocol in
Hyperledger can be replaced with a more efficient bespoke algo-
rithm for our context, e.g., using Byzantine broadcast [8] instead of
distributed consensus. Finally, although we have focused on power
grids, our results generalize to any other system in which multiple
operators perform measurements that can be described using a
system of linear equations, e.g., water or gas distribution networks.

ACKNOWLEDGMENTS
This research / project is supported by the National Research Foun-
dation, Singapore, under its National Satellite of Excellence Pro-
gramme “Design Science and Technology for Secure Critical Infras-
tructure” (Award Number: NSoE_DeST-SCI2019-0009). Any opin-
ions, findings and conclusions or recommendations expressed in
this material are those of the author(s) and do not reflect the views
of National Research Foundation, Singapore. We also thank the
anonymous reviewers of previous versions of this work for their
insightful comments.

REFERENCES
[1] Hyperledger fabric. https://www.hyperledger.org/use/fabric.
[2] IEEE test cases. http://amfarid.scripts.mit.edu/Datasets/SPG-Data/index.php.
[3] A. Abur and A. G. Exposito. Power system state estimation: theory and implemen-

tation. CRC press, 2004.

[4] K. Appunn and R. Russell. Set-up and challenges of Germany’s power grid, 2018.

[Online; accessed 23-7-2020].

[5] A. Back, M. Corallo, L. Dashjr, M. Friedenbach, G. Maxwell, A. Miller, A. Poelstra,
J. Timón, and P. Wuille. Enabling blockchain innovations with pegged sidechains,
2014. [Online; accessed 14-10-2020].

[6] S. Bi and Y. J. Zhang. Graphical methods for defense against false-data injection
IEEE Transactions on Smart Grid,

attacks on power system state estimation.
5(3):1216–1227, 2014.

[7] R. B. Bobba, K. M. Rogers, Q. Wang, H. Khurana, K. Nahrstedt, and T. J. Overbye.
Detecting false data injection attacks on DC state estimation. In Preprints of the

Daniël Reijsbergen, Aung Maw, Tien Tuan Anh Dinh, Wen-Tai Li, and Chau Yuen

First Workshop on Secure Control Systems, 2010.

[8] C. Cachin, R. Guerraoui, and L. Rodrigues. Introduction to reliable and secure

distributed programming. Springer Science & Business Media, 2011.

[9] M. Castro, B. Liskov, et al. Practical Byzantine fault tolerance. In OSDI, volume 99,

pages 173–186, 1999.

[10] J. Chen and A. Abur. Placement of PMUs to enable bad data detection in state

estimation. IEEE Transactions on Power Systems, 21(4):1608–1615, 2006.

[11] Deloitte. European energy market reform – country profile: Germany, 2015.

[Online; accessed 14-10-2020].

[12] G. Denegri, M. Invernizzi, and F. Milano. A security oriented approach to PMU
positioning for advanced monitoring of a transmission grid. In International
Conference on Power System Technology, volume 2, pages 798–803. IEEE, 2002.

[13] T. T. A. Dinh, J. Wang, G. Chen, R. Liu, B. C. Ooi, and K.-L. Tan. Blockbench: A
framework for analyzing private blockchains. In ACM SIGMOD, pages 1085–1100,
2017.

[14] European Commission. Antitrust: Commission imposes binding obligations on
TenneT to increase electricity trading capacity between Denmark and Germany,
2018. [Online; accessed 13-8-2020].

[15] M. Fan and X. Zhang. Consortium blockchain based data aggregation and
regulation mechanism for smart grid. IEEE Access, 7:35929–35940, 2019.
[16] R. Freivalds. Fast probabilistic algorithms. In International Symposium on Mathe-

matical Foundations of Computer Science, pages 57–69. Springer, 1979.

[17] K. Gai, Y. Wu, L. Zhu, M. Qiu, and M. Shen. Privacy-preserving energy trading
IEEE Transactions on Industrial

using consortium blockchain in smart grid.
Informatics, 15(6):3548–3558, 2019.

[18] A. Gomez-Exposito, A. J. Conejo, and C. Cañizares. Electric energy systems:

analysis and operation. CRC press, 2018.

[19] I. Homoliak, S. Venugopalan, D. Reijsbergen, Q. Hum, R. Schumi, and P. Szala-
chowski. The security reference architecture for blockchains: Toward a standard-
ized model for studying vulnerabilities, threats, and defenses. IEEE Communica-
tions Surveys & Tutorials, 23(1):341–390, 2020.

[20] M. Jamei, E. Stewart, S. Peisert, A. Scaglione, C. McParland, C. Roberts, and
A. McEachern. Micro synchrophasor-based intrusion detection in automated
distribution systems: Toward critical infrastructure security. IEEE Internet Com-
puting, 20(5):18–27, 2016.

[21] J. Kwon. Tendermint: Consensus without mining. Draft v. 0.6, fall, 1(11), 2014.
[22] S. Lakshminarayana, A. Kammoun, M. Debbah, and H. V. Poor. Data-driven false
data injection attacks against power grid: A random matrix approach. arXiv
preprint arXiv:2002.02519, 2020.

[23] S. Lakshminarayana, T. Z. Teng, D. K. Yau, and R. Tan. Optimal attack against
cyber-physical control systems with reactive attack mitigation. In International
Conference on Future Energy Systems, 2017.

[24] R. M. Lee, M. J. Assante, and T. Conway. Analysis of the cyber attack on the
Ukrainian power grid. Electricity Information Sharing and Analysis Center (E-
ISAC), 2016.

[25] W. Li, C. Wen, J. Chen, K. Wong, J. Teng, and C. Yuen. Location identification of
power line outages using PMU measurements with bad data. IEEE Transactions
on Power Systems, 31(5):3624–3635, 2015.

[26] Z. Li, J. Kang, R. Yu, D. Ye, Q. Deng, and Y. Zhang. Consortium blockchain for
IEEE Transactions on

secure energy trading in industrial Internet of Things.
Industrial Informatics, 14(8):3690–3700, 2017.

[27] L. Liu, M. Esmalifalak, Q. Ding, V. A. Emesih, and Z. Han. Detecting false data
injection attacks on power grid by sparse optimization. IEEE Transactions on
Smart Grid, 5(2):612–621, 2014.

[28] X. Liu, P. Zhu, Y. Zhang, and K. Chen. A collaborative intrusion detection
mechanism against false data injection attack in advanced metering infrastructure.
IEEE Transactions on Smart Grid, 6(5):2435–2443, 2015.

[29] Y. Liu, P. Ning, and M. K. Reiter. False data injection attacks against state
estimation in electric power grids. ACM Transactions on Information and System
Security (TISSEC), 14(1):1–33, 2011.

[30] A. Mazloomzadeh, O. A. Mohammed, and S. Zonouzsaman. Empirical develop-
ment of a trusted sensing base for power system infrastructures. IEEE Transactions
on Smart Grid, 6(5):2454–2463, 2015.

[31] R. C. Merkle. A digital signature based on a conventional encryption function.
In Conference on the theory and application of cryptographic techniques, pages
369–378. Springer, 1987.

[32] M. B. Mollah, J. Zhao, D. Niyato, K.-Y. Lam, X. Zhang, A. M. Ghias, L. H. Koh,
and L. Yang. Blockchain for future smart grid: A comprehensive survey. IEEE
Internet of Things Journal, 2020.

[33] A. Monticelli. State estimation in electric power systems: a generalized approach.

Springer Science & Business Media, 1999.

[34] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. https://bitcoin.org/

bitcoin.pdf, 2009.

[35] C. Rakpenthai, S. Premrudeepreechacharn, S. Uatrongjit, and N. R. Watson. An
optimal PMU placement method against measurement loss and branch outage.
IEEE Transactions on Power Delivery, 22(1):101–107, 2006.

[36] TEPCO. The electric power business in Japan, 2012. [Online; accessed 23-7-2020].

Securing Smart Grids Through an Incentive Mechanism for Blockchain-Based Data Sharing

[37] F. Tramer and D. Boneh. Slalom: Fast, verifiable and private execution of neural

networks in trusted hardware. arXiv preprint arXiv:1806.03287, 2018.

[38] Trusted Computing Group. Trusted platform module library part 1: Architecture,

2019. [Online; accessed 24-9-2020].

[39] N. Ul Hassan, C. Yuen, and D. Niyato. Blockchain technologies for smart energy
systems: Fundamentals, challenges, and solutions. IEEE Industrial Electronics
Magazine, 13(4):106–118, 2019.

[40] X. Wang, D. Shi, J. Wang, Z. Yu, and Z. Wang. Online identification and data
recovery for PMU data manipulation attack. IEEE Transactions on Smart Grid,
10(6):5889–5898, 2019.

[41] D. Winder. Cyber attack on U.K. electricity market confirmed: National Grid

investigates. Forbes, 2020. [Online; accessed 30-9-2020].

[42] A. J. Wood, B. F. Wollenberg, and G. B. Sheblé. Power generation, operation, and

control. John Wiley & Sons, 2013.

[43] G. Wood. Ethereum: a secure decentralized generalized transaction ledger. https:

//gavwood.com/paper.pdf, 2014.

[44] Q. Yang, D. An, R. Min, W. Yu, X. Yang, and W. Zhao. On optimal PMU placement-
based defense against data integrity attacks in smart grid. IEEE Transactions on
Information Forensics and Security, 12(7):1735–1750, 2017.

[45] M. Yin, D. Malkhi, M. K. Reiter, G. G. Gueta, and I. Abraham. Hotstuff: BFT
consensus with linearity and responsiveness. In Proceedings of the 2019 ACM
Symposium on Principles of Distributed Computing, pages 347–356, 2019.
[46] X. Zhang and M. Fan. Blockchain-based secure equipment diagnosis mechanism

of smart grid. IEEE Access, 6:66165–66177, 2018.

A CONSTRUCTION OF THE GRID TOPOLOGY

MATRIX

In this section, we present more details about the construction of
the grid topology matrix 𝐺. The topology is represented using the
bus-branch model [3, 33] that is commonly used in state estimation,
which is the method that we use for anomaly detection. We only
present a high-level overview of the model, and refer the interested
reader to other works [3, 18, 33, 42] for a more in-depth discussion
of power systems.

In our setting, buses represent nodes (e.g., power plants or trans-
former substations) whereas branches represent power lines. The
sets O, N , L, and M are as defined in Section 3. Recall that there
are 𝑁 + 1 nodes/buses. Buses are represented by integers (via their
IDs), so N ⊂ N. There are 𝐿 lines/branches that connect the buses –
each line 𝑙 ∈ L can also be represented as a pair (𝑛, 𝑛′) of buses (so
by a pair of integers). Hence, L ⊂ N2. In this definition, the lines are
bidirectional: i.e., if (𝑛, 𝑛′) ∈ L, then (𝑛′, 𝑛) ∈ L as well. Let 𝑁nb (𝑛)
be the set of neighbors of 𝑛, i.e., 𝑁nb (𝑛) = {𝑚 ∈ N : (𝑛, 𝑚) ∈ L}
The reactance on line 𝑙 = (𝑛, 𝑛′) is denoted by 𝑋𝑙 = 𝑋𝑛𝑛′, such
that 𝑋𝑛𝑛′ = 𝑋𝑛′𝑛. The power flow on line (𝑛, 𝑛′) is denoted by 𝑝𝑛𝑛′,
such that 𝑝𝑛𝑛′ = −𝑝𝑛′𝑛. The power injection at bus 𝑛 is denoted
by 𝑝𝑛, and the voltage phase angle at bus 𝑛 is denoted by 𝜃𝑛. The
last bus is selected as the reference bus, so that 𝜃𝑁 +1 = 0 and 𝜃𝑖 ,
𝑖 ∈ {1, . . . , 𝑁 } are expressed relative to the reference bus.

Although the relationship between the measurements and the
phase angles at the buses is non-linear in an Alternating Current
(AC) power system, it can be approximated using the linearized
Direct Current (DC) power flow model. In particular, we obtain
the following first-order approximation [27, 42] for the power flow
on a single line: 𝑝𝑛𝑛′ =
𝑋𝑛𝑛′ (𝜃𝑛 − 𝜃𝑛′). Using Kirchhoff’s laws,
1
we furthermore obtain that the power injected into bus 𝑛 equals
the power outflow minus the inflow: 𝑝𝑛 = (cid:205)𝑛′ ∈𝑁nb (𝑛) 𝑝𝑛𝑛′. Let
𝑥𝑚 denote the measurement recorded by meter 𝑚. We assume
that meter 𝑚’s measurement error is given by 𝜖𝑚, leading to the

following equations:

𝑥𝑚 =






𝑝𝑛𝑛′ + 𝜖𝑚

𝑝𝑛 + 𝜖𝑚

𝜃𝑛 + 𝜖𝑚

if 𝑚 is a SCADA power
flow meter on line (𝑛, 𝑛′),
if 𝑚 is a SCADA power
injection meter on bus (𝑛), and
if 𝑚 is a PMU for the voltage
phase angle on bus (𝑛).

The above equations can be combined into a single system of linear
equations:

(cid:174)𝑥 = 𝐺 (cid:174)𝜃 + (cid:174)𝜖,
which can be used for state estimation. The topology matrix 𝐺 can
then be constructed using the following algorithm:

(3)

(1) Initialize 𝐺 as an (𝑀 + 𝑁 ′) × 𝑁 matrix filled with zeroes. Let

𝑔𝑚𝑛 be its entry in the 𝑚th row and 𝑛th column.

(2) For each bus injection meter 𝑚, let 𝑛 be the ID of its bus. For

each 𝑛′ ∈ 𝑁nb (𝑛), update 𝑔𝑚𝑛 ← 𝑔𝑚𝑛 + 1
𝑋𝑛𝑛′
.
𝑔𝑚𝑛′ ← 𝑔𝑚𝑛′ − 1
𝑋𝑛𝑛′

and

(3) For each power flow meter 𝑚, let 𝑛 be the ID of the first bus
and 𝑛′ the ID of the second bus. Update 𝑔𝑚𝑛 ← 𝑔𝑚𝑛 + 1
𝑋𝑛𝑛′
and 𝑔𝑚𝑛′ ← 𝑔𝑚𝑛′ − 1
𝑋𝑛𝑛′
(4) For each PMU 𝑚, let 𝑛 be the ID of its bus. Update

.

𝑔𝑚𝑛 ← 𝑔𝑚𝑛 + 1.

(5) Zero-injection buses in N ′ are treated as bus injection me-
ters that measure zero power, but which are given greater
weight by multiplying the entries with a large constant 𝜅.
Let 𝑛 be the ID of its bus. For each 𝑛′ ∈ 𝑁nb (𝑛), update
𝑔𝑚𝑛 ← 𝑔𝑚𝑛 + 𝜅
𝑋𝑛𝑛′

and 𝑔𝑚𝑛′ ← 𝑔𝑚𝑛′ − 𝜅
𝑋𝑛𝑛′

.

B THREAT MODEL COMPARISON
In the earliest papers on FDI attack detection using state estimation
[7, 29], the focus was on attackers who could either only com-
promise a fixed set of meters, or who had a maximum number 𝑘
of meters that they could compromise (but were free to choose
which ones). This restriction was kept in some works [44] and [22],
whereas in others, e.g., [23], the attacker was instead restricted in
terms of the total distortion that they could add to the measure-
ments. Note that if an attacker has complete knowledge of the
network topology and the ability to change the measurements of
all meters to arbitrary values, then they are free to choose the mea-
surements such that the residuals are zero. Hence, any approach
that uses state estimation to detect anomalies must assume that the
attacker’s capabilities are somehow limited. By contrast, we con-
sider a system where the attacker is limited in terms of the number
of OEMs that they can compromise, but an attack against a single
OEM may affect all of a single operator’s meters. An overview of
these related threat models can be found in Table 3.

C NUMERICAL EXAMPLE OF THE

EVOLUTION OF OPERATORS’ CREDITS
To illustrate the evolution of the credits as discussed in Section 4,
we consider a parameter setting based on Germany, where as of
2015 4 TSOs respectively controlled roughly 31.6%, 30.8%, 28.1%,
and 9.5% of the grid [11]. We choose the following parameters
for our benchmark setting: 𝑀 = 1000, 𝛾 = 1014, 𝜌 = 106, and

Table 3: Overview of threat model restrictions in the litera-
ture.

Bobba et al. (2010)
Liu et al. (2011)
Yang et al. (2017)
Lakshminarayana et al. (2017)
Lakshminarayana et al. (2020)

[7]
[29]
[44]
[23]
[22]

threat model

limited
# meters
✓
✓
✓

✓

limited
total deviation

✓

𝜙 = 𝜙 ′ = 1010. Here, 𝛾 is chosen to be a large integer to avoid
rounding errors, because the deposits are implemented as integers
in Section 5. Furthermore, 𝜌 and 𝜙 are chosen to ensure that it is
profitable to add any meter whose probability of being offline in
any slot is below 10−4. We also assume that all meters have the
same error probabilities, namely 𝑝𝑚 = 10−5 and 𝑝 ′
𝑚 = 0 for all 𝑚.

(a)

(b)

Figure 7: Net losses as a function of the probability of miss-
ing a measurement 𝑝. In Figure a), we choose 𝜙𝑚 = 𝑝 the
same for all meters 𝑚 of the four TSOs. In Figure b), we only
choose 𝜙𝑚 = 𝑝 if 𝑚 belongs to TSO 1, and 𝜙𝑚 = 10−5 other-
wise.

In Figure 7a, we display the net losses per time slot for the four
TSOs. At 𝑝𝑚 = 10−5, we see that the smallest TSO loses roughly
2 · 108 credits per time slot. This is divided almost equally among
the other TSOs. With 𝛾 = 1014, this means that the smallest TSO
would run out of credits after 106 time slots - if one time slot lasts
10 seconds, then this would be once every 115 days. The probability
threshold 𝜁 is close to 10−4. Once this threshold is crossed, meters
become a liability and the smallest TSO is the only one that makes
a profit.

In Figure 7b, we keep 𝑝𝑚 constant at 10−5 for the meters of the
last three TSOs, but vary the 𝑝 for the meters of TSO 1. We see that
the profits of TSO 1 approach a maximum of around 1.108 · 108
credits per time slot as 𝑝𝑚 decreases. However, if 𝑝𝑚 increases then
the costs of TSO 1 eventually start to outweigh the gains. Eventually,
the losses of TSO 1 become so high that even TSO 4 starts to make
an expected profit each time slot – however, at this point 𝑝𝑚 is
higher than 𝜁 , which means that TSO 1 is better off joining the
framework with a single meter.

Daniël Reijsbergen, Aung Maw, Tien Tuan Anh Dinh, Wen-Tai Li, and Chau Yuen

D INCENTIVE COMPATIBILITY THEOREMS
In this section, we prove the three theorems mentioned in Sec-
tion 4.2. We study the rewards of an operator 𝑜 ∈ O in a single
time slot as a function of 𝑜’s actions. We first introduce five terms
that determine the expected total change in 𝑜’s credits per time slot.
These terms depend on 𝑅𝑚 = (1 − 𝑝𝑚)𝜌 and Φ𝑚 = 𝑝𝑚𝜙, which are
the expected reward and penalty in each time slot for measurements
produced and missed by meter 𝑚, respectively.

𝑜

𝑜

= (cid:205)𝑚 ∈M𝑜

= (cid:205)𝑚 ∈M𝑜

The first term is the total expected reward for measurements
produced by 𝑜’s meters, given by 𝑅tot
𝑅𝑚. The sec-
ond term is the expected penalty for the missed measurements,
given by Φtot
Φ𝑚. The third term represents the to-
tal losses from the rewards for other operators’ meters, given by
𝑅oth
𝑅𝑚. The fourth term represents the total
𝑜
gains from the missing measurement penalties for other operators,
given by Φoth
Φ𝑚. The fifth term represents
= 1
𝑂−1
the anomaly penalties and equals Φ′
Φ′
𝑚, where 𝑞
equals the probability that 𝑟 > 𝜃 and that every meter produced a
measurement, i.e., (cid:206)𝑚 ∈M (1 − 𝑝𝑚). The total expected change to
𝑜’s credits after each time slot is then given by:

𝑜 = 𝑞 (cid:205)𝑚 ∈M𝑜

(cid:205)𝑚 ∈M\M𝑜

(cid:205)𝑚 ∈M\M𝑜

= 1
𝑂−1

𝑜

𝑅net
𝑜

= 𝑅tot

𝑜 − Φtot

𝑜 − 𝑅oth

𝑜

+ Φoth
𝑜

− Φ′
𝑜 .

(4)

Incentive compatibility then means that given a set of possible
actions, 𝑜 maximizes 𝑅net
by choosing the action recommended by
the protocol. If this choice does not depend on the actions of the
other operators, then it is a Nash equilibrium for all operators to
follow the protocol.

𝑜

For the first theorem, we consider the impact of registering
add
𝑚 be equal to 1 if meter 𝑚 has
meters or not on 𝑜’s profits. Let 1
add
been added by its operator and 0 otherwise. Let I = (1
𝑚 )𝑚 ∈M be
the complete strategy profile that describes for each meter whether
it is added or not. The probability 𝑞 depends on which meters have
been added or not, so it is a function of I. Similarly, the net gains
𝑅net
𝑜

and its five constituent terms are functions of I.

(I𝑚,1) > 𝑅net

For any I ∈ {0, 1}𝑀 , let I𝑚,0 and I𝑚,1 be equal to I except that 1𝑚
has been set equal to 0 or 1, respectively. Incentive compatibility
is then equivalent to the assertion that, for each I and suitable
𝑚, it holds that 𝑅net
(𝐼𝑚,0) – i.e., it is profitable for
𝑜
each operator to add all suitable meters regardless of which meters
are added by the other operators. As a consequence, all operators
adding all suitable meters would be a Nash equilibrium because
each operator would gain less by deviating. In Theorem 1, we prove
𝑜 (I𝑚,1) − Φ′
that as long as Δ𝑚 (I) = Φ′
𝑜 (I𝑚,0) is small, then it is
profitable for all operators to add each meter 𝑚 for which 𝜙 < 𝜁
for a given bound 𝜁 .

𝑜

Theorem 1. For any meter 𝑚 such that 𝑝𝑚 < 𝜁𝑚 (I), with

𝜁𝑚 (I) ≜

𝜌
𝜌 + 𝜙

− Δ𝑚 (I),

and for any I ∈ {0, 1}𝑀 it holds that 𝑅net
𝑜 (I𝑚,1) − Φ′
where Δ𝑚 (I) = Φ′

𝑜 (I𝑚,0).

𝑜

(I𝑚,1) > 𝑅net

𝑜

(I𝑚,0),

10−810−710−610−510−410−3−4−2024·108p(allTSOs)NetLossesperTimeSlotTSO1TSO2TSO3TSO410−810−710−610−510−410−3−4−2024·108p(TSO1only)NetLossesperTimeSlotTSO1TSO2TSO3TSO4Securing Smart Grids Through an Incentive Mechanism for Blockchain-Based Data Sharing

Proof. From (4), we observe that 𝑅net
be decomposed into five terms as follows:

𝑜

(I𝑚,1) − 𝑅net

𝑜

(I𝑚,0) can

𝑜

𝑜

(5)

𝑅net
𝑜

(I𝑚,1) − 𝑅net

(I𝑚,0)
(I𝑚,0))
(I𝑚,0))
(I𝑚,0)

(I𝑚,1) − 𝑅tot
(I𝑚,1) − Φtot
𝑜
(I𝑚,1) − 𝑅oth
𝑜
(I𝑚,1) − Φoth

(I𝑚,0) = 𝑅tot
𝑜
− (Φtot
𝑜
− (𝑅oth
𝑜
+ Φoth
𝑜
− (Φ′
From the definition of these terms, we find that the first term equals
𝑅𝑚, the second term equals Φ𝑚, and the third and fourth terms
equal 0. The fifth term represents the net effect of: 1) a higher
likelihood that at least one measurement is missing, and 2) the
impact on the residuals and therefore 𝑟 and 𝜙 ′
𝑚. The latter effect
depends on the place of the new meter in the grid and the degree
to which the meter agrees with related meters. Whether this term,
which equals Δ𝑚 (I), is positive or negative therefore depends on
the setting.

𝑜
𝑜 (I𝑚,0))

𝑜 (I𝑚,1) − Φ′

If we combine the above, we find that 𝑅net

is positive if and only

𝑜

if 𝑅𝑚 − Φ𝑚 − Δ𝑚 (I) > 0, i.e.,

𝜌 − 𝑝𝑚𝜌 − 𝑝𝑚𝜙 − Δ𝑚 (I) > 0.

which can be rewritten as

𝑝𝑚 <

𝜌
𝜌 + 𝜙

− Δ𝑚 (I).

This proves the theorem.

□

𝑜 ∪ M ′

𝑜 and M ′

¬𝑜 are withheld, such that M ′

¬𝑜 be the number of elements in M ′

For the next theorem, we assume that it is known which meters
have been registered or not, which are offline or not, and what the
residuals would be based on the readings of all meters. We investi-
gate the impact on the profits of an operator 𝑜 when the meters in
the sets M ′ = M ′
𝑜 ⊂ M𝑜 and
¬𝑜 ⊂ M\M𝑜 . We assume that the measurements in M ′ would
M ′
otherwise have made it onto the blockchain in time. Let 𝑀 ′
𝑜 and
𝑀 ′
¬𝑜 , respectively. We
assume that 𝑜 is aware which other meters have shared their mea-
surements and what the values of these measurements are. This
represents the situation where a single operator 𝑜 has the choice
to withhold or block the measurements of the meters in M ′ right
before the end of the timeout period. We make these assumptions
because we want to make the situation as advantageous as possible
for the adversary for the corollaries that we derive from Theorem 2.
miss
𝑚 be equal to 1 if the measurement of me-
ter 𝑚 is missed and 0 if it is not. In this setting, the strategy profile
I is given by (1
be equal to I expect
miss
that for all 𝑚 ∈ M ′, 1
𝑚 has been set equal to 0 or 1, respectively.
Since we assume that 𝑜 knows whether any meter has missed its
measurement, it holds that 𝑞 = 0 if at least one measurement is miss-
ing, and 𝑞 = 1 otherwise. Let Δ′
(IM′,1)
be 𝑜’s profit from withholding the measurements of the meters in
M ′. We can then prove the following statement.
(cid:16) 𝑀′
¬𝑜
𝑂−1

· (𝜌 + 𝜙). Let 1𝑀′ be equal to 1

miss
𝑚 )𝑚 ∈M . Let IM′,0

In the following, let 1

(IM′,0) − 𝑅net

M′ (I) = 𝑅net

and IM′,1

− 𝑀 ′
𝑜

(cid:17)

𝑜

𝑜

Theorem 2. Let 𝛿 =
𝑜 + 𝑀 ′

if 𝑀 ′

¬𝑜 and to 0 otherwise. Then
Δ′(IM′) = 𝛿 + 𝑞1𝑀′

𝑜

𝑜

𝑜 meters in M ′

𝑜 𝜌 as 𝑜 misses out on the rewards for the 𝑀 ′

Proof. We can decompose 𝑅net
into five terms as in (5), except
instead of I𝑚,0 and
and IM′,1
that each quantity depends on IM′,0
I𝑚,1. From the definition of 𝑅tot
, we find that the first term equals
−𝑀 ′
𝑜 . The
second term equals −𝑀 ′
𝑜𝜙, as the missed measurement penalty 𝜙 is
𝑜 times. The third equals 𝑀′
incurred an additional 𝑀 ′
𝜌 as 𝑜 loses
¬𝑜
𝑂−1
fewer credits given as a reward to the other operators. Similarly,
the fourth term equals 𝑀′
of the
¬𝑜
𝑂−1
redistributed credits from the penalties incurred by the operators
of the meters in M ′
Φ′
𝑚 if
𝑀 ′
¬𝑜 > 0, as the anomaly penalty is no longer applied, and 0
otherwise. By substituting these results into (5), we find that

¬𝑜 . The fifth term either equals (cid:205)𝑚 ∈M𝑜

𝜙 as 𝑜 receives a fraction 1

𝑜 + 𝑀 ′

𝑂−1

Δ′

M′ (I) =

(cid:18) 𝑀 ′
¬𝑜
𝑂 − 1

(cid:19)

− 𝑀 ′
𝑜

· (𝜌 + 𝜙) + 𝑞1𝑀′

∑︁

Φ′
𝑚

𝑚 ∈M𝑜

where 1𝑀′ is as defined in the statement of the theorem. This
completes the proof.

□

In the final theorem, we derive an expression for the effect of
distorting measurements on 𝑜’s profits. This does not have an im-
pact on first four terms of (4), so we focus on Φ′
𝑜 . If at least one
measurement is missing, then the anomaly penalty is not applied
at all, so we focus on the case where all meters have reported their
measurements. As discussed in Section 6, (cid:174)𝑥 denotes the vector of
“true” measurements, D the set of meters whose measurements can
be arbitrarily distorted by 𝑜, and (cid:174)𝑑 is a 𝑀 × 1 vector such that 𝑑𝑚 is
the distortion applied to meter 𝑚. In this setting, the residuals are
a function of (cid:174)𝑑, i.e., ^𝜖 ( (cid:174)𝑑) = M( (cid:174)𝑥 + (cid:174)𝑑), where M = 𝐼𝑀+𝑁 ′ − 𝑃 where
𝐼𝑀+𝑁 ′ is the identity matrix of size 𝐼𝑀+𝑁 ′. In regression analysis,
the matrix M is often called the “residual maker” matrix, and we
denote its 𝑖, 𝑗th entry by m𝑖 𝑗 . The sum 𝑟 and the total anomaly
penalty Φ′

𝑜 are also functions of (cid:174)𝑑, i.e.,

𝑜 ( (cid:174)𝑑) =
Φ′

∑︁

𝑚 ∈M𝑜

𝜙 ′
𝑟 ( (cid:174)𝑑)

(cid:32)
𝑚 ( (cid:174)𝑑) −
𝜖2

(cid:33)

.

𝑟 ( (cid:174)𝑑)
𝑀

𝑜 ( (cid:174)𝑑) − Φ′

The total impact of adding distortions (cid:174)𝑑 on the anomaly penalty is
𝑜 ((cid:174)0), where (cid:174)0 is an 𝑀 × 1 vector of zeroes.
then given by Φ′
The impact of adding distortions (cid:174)𝑑 on 𝑜’s net profits per time slot
𝑜 ( (cid:174)𝑑) − Φ′
𝑜 ((cid:174)0) < 0, i.e., if the anomaly
are positive if and only if Φ′
penalties would be reduced. In Theorem 3 we state a necessary and
sufficient condition for this to hold. The theorem depends on the
matrix 𝐴, given by

𝐴 =

(cid:18)𝐴𝑑𝑑 𝐴𝑑𝑥
𝐴𝑥𝑑
0

(cid:19)

,

where 𝐴𝑑𝑑 , 𝐴𝑑𝑥 , 𝐴𝑥𝑑 , and 0 are 𝑀 × 𝑀 matrices. Each entry of
0 equals zero, and the 𝑘, 𝑙th entry of 𝐴𝑑𝑑 , 𝐴𝑑𝑥 , and 𝐴𝑥𝑑 , denoted
respectively by 𝑎𝑑𝑑,𝑘𝑙 , 𝑎𝑑𝑥,𝑘𝑙 , and 𝑎𝑥𝑑,𝑘𝑙 , are given by

∑︁

Φ′
𝑚 .

𝑚 ∈M𝑜

Finally, let (cid:174)𝑦 =

(cid:19)
(cid:18) (cid:174)𝑑
(cid:174)𝑥

𝑎𝑑𝑑,𝑘𝑙 = 𝑎𝑑𝑥,𝑘𝑙 = 𝑎𝑥𝑑,𝑘𝑙 =

m𝑖𝑘 m𝑖𝑙 −

∑︁

𝑖 ∈M𝑜

(cid:169)
(cid:173)
(cid:171)

m𝑗𝑘 m𝑗𝑙
𝑀

∑︁

𝑗 ∈M

.

(cid:170)
(cid:174)
(cid:172)

be a 2𝑀 × 1 vector with the entries of (cid:174)𝑑 and (cid:174)𝑥.

Theorem 3. With (cid:174)𝑦 and 𝐴 as above, Φ′

𝑜 ( (cid:174)𝑑) − Φ′

𝑜 ((cid:174)0) < 0 if and

only if

(cid:174)𝑦 𝑇 𝐴(cid:174)𝑦 < 0.

Daniël Reijsbergen, Aung Maw, Tien Tuan Anh Dinh, Wen-Tai Li, and Chau Yuen

Proof. First note that Φ′

𝑜 ( (cid:174)𝑑) − Φ′

𝑜 ((cid:174)0) < 0 is equivalent to saying

that

(cid:16)
𝑟 ( (cid:174)𝑑) − 𝑟 ((cid:174)0)

(cid:17) (cid:19)

< 0.

1
𝑀

(6)

Figure 8: Flowchart that represents the necessary stages for
adding new measurements to the blockchain.

∑︁

(cid:18)
𝑚 ( (cid:174)𝑑) − 𝜖2
𝜖2

𝑚 ((cid:174)0) −

𝑚 ∈M𝑜

Note that

delays the inclusion of a competing operator’s readings beyond 𝑦
blocks.

The first attack involves an adversarial coalition that refuses to
endorse unwanted blocks. Since each block requires the endorse-
ment of at least 2𝑓 + 1 peers to be committed, adversarial nodes
have the possibility to veto blocks if abstaining would mean that
more than 𝑓 peers do not endorse the block. For example, if there
are 4 companies involved, of which 1 is adversarial and 1 is offline
for more than 𝑦 blocks, then the adversarial node can veto all blocks
by the two honest nodes, and only the blocks by the adversarial
node will be committed. The adversarial node has full control over
which transactions it includes in its block, so it can leave out the
measurements of its competitors. However, although operators can
periodically go offline, if 𝑂 is large then it is unlikely that many
operators would go offline simultaneously.

The second attack involves an operator who is the round leader
during all 𝑦 blocks. Whether this possible depends on the choice of
consensus protocol. In PBFT [9], round leaders remain in place the
same unless a node requests a view change. In this case, it is the
responsibility of the maligned operators to request a view change
if they observe that their measurements are not being included.
However, in Tendermint [21] and HotStuff [45] rotate the leader
every round. As such, each operator has to wait at most 𝑂 −1 blocks
until it can propose a block, so this is safe as long as 𝑂 − 1 < 𝑦.
As such, 𝜏 ∗ and 𝜂 should be chosen such that 𝑦 > 𝑂 − 1 with high
probability.

2

∑︁

𝑚 ( (cid:174)𝑑) = (cid:169)
𝜖2
(cid:173)
𝑘 ∈M𝑜
(cid:171)
∑︁

=

m𝑚𝑘 (𝑥𝑘 + 𝑑𝑘 )(cid:170)
(cid:174)
(cid:172)

∑︁

m𝑚𝑘 m𝑚𝑙 (𝑥𝑘 + 𝑑𝑘 )(𝑥𝑙 + 𝑑𝑙 )

𝑘 ∈M𝑜

𝑙 ∈M𝑜

so that

𝑚 ( (cid:174)𝑑) − 𝜖2
𝜖2

𝑚 ((cid:174)0) =

∑︁

∑︁

m𝑚𝑘 m𝑚𝑙 (𝑑𝑘𝑑𝑙 + 𝑑𝑘𝑥𝑙 + 𝑥𝑘𝑑𝑙 ).

𝑙 ∈M𝑜

𝑘 ∈M𝑜
Since 𝑟 ( (cid:174)𝑑) = (cid:205)𝑘 ∈M 𝜖2
𝑘 ( (cid:174)𝑑), we can rewrite the left hand side of (6)
as a summation of terms 𝑑𝑘𝑑𝑙 , 𝑑𝑘𝑥𝑙 , and 𝑥𝑘𝑑𝑙 for all 𝑘, 𝑙 ∈ M. In
particular, we can reorganize to produce the following matrix 𝐴

𝑑1
𝑎𝑑𝑑,11
...

𝑑1
...
𝑑𝑀 𝑎𝑑𝑑,𝑀1
𝑎𝑑𝑑,11
𝑥1
...
...
𝑥𝑀 𝑎𝑑𝑑,𝑀1

...

𝑥1

𝑑𝑀

. . .
. . . 𝑎𝑑𝑑,1𝑀 𝑎𝑑𝑥,11
...
. . .
. . . 𝑎𝑑𝑑,𝑀𝑀 𝑎𝑑𝑥,𝑀1
. . . 𝑎𝑑𝑑,1𝑀
...
. . .
. . . 𝑎𝑑𝑑,𝑀𝑀

0
...
0

𝑥𝑀

. . .
. . . 𝑎𝑑𝑥,1𝑀
...
. . .
. . . 𝑎𝑑𝑥,𝑀𝑀
. . .
. . .
. . .

0
...
0

for which it holds that (cid:174)𝑦 𝑇 𝐴(cid:174)𝑦 corresponds to the left hand side of
□
(6). This proves the theorem.

E BLOCKCHAIN SECURITY
As we discussed in Section 4, it is typically profitable for an operator
to prevent another operator to upload its measurements to the
blockchain. The process of uploading a measurement from a meter
to the blockchain is depicted in Figure 8. Each measurement is
created and sent by the meter over the network to its operator’s
MDMS server, which broadcasts it to the peer-to-peer network. The
measurement must then be added to a block before FinalizeTimeSlot
– this occurs after 𝑦 blocks, where 𝑦 ∈ {0, . . . , 𝜂 +𝜏 ∗ − 1} represents
the number of rounds left in which the round leader is aware of the
measurement until the end of the current period and the timeout
duration. After the measurement has been included in a block,
this block must receive the support of at least two thirds of the
nodes to be added to the blockchain. In Section 3 we assume that it
is beyond the capabilities of operators to attack other operator’s
meters, MDMS servers, or the network (e.g., through a DoS attack). 3
However, operators are able to influence decisions at the consensus
layer. In the following, we discuss two attacks in which an operator

3For the same reason, we do not consider attacks in which an operator changes the
reading of another operator’s meter to an anomalous reading.

······MeterNetworkMDMSServerConsensusLayerDataLayerBlockchain