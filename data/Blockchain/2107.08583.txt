1
2
0
2

p
e
S
1

]
E
S
.
s
c
[

2
v
3
8
5
8
0
.
7
0
1
2
:
v
i
X
r
a

Compositional Veriﬁcation of Smart Contracts
Through Communication Abstraction
(Extended)

Scott Wesley1

, Maria Christakis2, Jorge A. Navas3
Valentin W¨ustholz4, and Arie Gurﬁnkel1

, Richard Treﬂer1,

1 University of Waterloo, Canada
2 MPI-SWS, Germany
3 SRI International, USA
4 ConsenSys, Germany

Abstract. Solidity smart contracts are programs that manage up to
2160 users on a blockchain. Verifying a smart contract relative to all users
is intractable due to state explosion. Existing solutions either restrict
the number of users to under-approximate behaviour, or rely on manual
proofs. In this paper, we present local bundles that reduce contracts with
arbitrarily many users to sequential programs with a few representative
users. Each representative user abstracts concrete users that are locally
symmetric to each other relative to the contract and the property. Our
abstraction is semi-automated. The representatives depend on commu-
nication patterns, and are computed via static analysis. A summary for
the behaviour of each representative is provided manually, but a default
summary is often suﬃcient. Once obtained, a local bundle is amenable
to sequential static analysis. We show that local bundles are relatively
complete for parameterized safety veriﬁcation, under moderate assump-
tions. We implement local bundle abstraction in SmartACE, and show
order-of-magnitude speedups compared to a state-of-the-art veriﬁer.

1

Introduction

Solidity smart contracts are distributed programs that facilitate information
ﬂow between users. Users alternate and execute predeﬁned transactions, that
each terminate within a predetermined number of steps. Each user (and con-
tract) is assigned a unique, 160-bit address, that is used by the smart contract
to map the user to that user’s data. In theory, smart contracts are ﬁnite-state
systems with 2160 users. However, in practice, the state space of a smart contract
is huge—with at least 22160
states to accommodate all users and their data (con-
servatively counting one bit per user). In this paper, we consider the challenge
of automatically verifying Solidity smart contracts that rely on user data.

A naive solution for smart contract veriﬁcation is to verify the ﬁnite-state sys-
tem directly. However, verifying systems with at least 22160
states is intractable.
The naive solution fails because the state space is exponential in the number of

 
 
 
 
 
 
2

S. Wesley et al.

mapping ( address => uint ) bids ;
address manager ; uint leadingBid ; bool stopped ;
uint _sum ;

constructor ( address mgr ) public { manager = mgr ; }

1 contract Auction {
2
3
4
5
6
7
8
9
10
11
12
13
14
15

}

function bid ( uint amount ) public {
require ( msg . sender != manager ) ;
require ( amount > leadingBid );
require (! stopped );
_sum = _sum + amount - bids [ msg . sender ];
bids [ msg . sender ] = amount ;
leadingBid = amount ;

16
17
18
19
20
21
22
23
24
25
26
27
28
29 }

function withdraw () public {

require ( msg . sender != manager );
require ( bids [ msg . sender ] != leadingBid );
require (! stopped );
_sum = _sum + 0 - bids [ msg . sender ];
bids [ msg . sender ] = 0;

}

function stop () public {

require ( msg . sender == manager );
stopped = true ;

}

Fig. 1: A smart contract that implements a simple auction.

1 Auction _a = new Auction ( address (2) ) ;
2 _a . address = address (1) ;
3
4 while ( true ) {
5
6
7
8
9
10

// Applies an interference invariant .
uint bid = *;
uint maxBid = _a . leadingBid ;
require ( bid <= maxBid );
require ( bid == maxBid || bid + maxBid <= _a . sum );
_a . bids [ address (3) ] = bid ;

// Selects a sender .
msg . sender = *;
require ( msg . sender > address (1) );
require ( msg . sender < address (5) );
require ( msg . sender < address (4) );
// Selects a call .
if
else if (*) _a . withdraw () ;
else if (*) _a . stop () ;

(*) _a . bid (*) ;

11
12
13
14
15
16
17
18
19
20 }

Fig. 2: A harness to verify Prop. 1 (ignore the highlighted lines) and Prop. 2.

users. Instead, we infer correctness from a small number of representative users
to ameliorate state explosion. To restrict a contract to fewer users, we ﬁrst gen-
eralize to a family of ﬁnite-state systems parameterized by the number of users.
In this way, smart contract veriﬁcation is reduced to parameterized veriﬁcation.
For example, consider Auction in Fig. 1 (for now, ignore the highlighted lines).
In Auction, each user starts with a bid of 0. Users alternate, and submit increas-
ingly larger bids, until a designated manager stops the auction. While the auc-
tion is not stopped, a non-leading user may withdraw their bid5. Auction satisﬁes
Prop. 1: “Once stop() is called, all bids are immutable.” Prop. 1 is satisﬁed
since stop() sets stopped to true, no function sets stopped to false, and while
stopped is true neither bid() nor withdraw() is enabled. Formally, Prop. 1 is
initially true, and remains true due to Prop. 1b: “Once stop() is called, stopped
remains true.” Prop. 1 is said to be inductive relative to its inductive strength-
ening Prop. 1b. A Software Model Checker (SMC) can establish Prop. 1 by an
exhaustive search for its inductive strengthening. However, this requires a bound
on the number of addresses, since a search with all 2160 addresses is intractable.
A bound of at least four addresses is necessary to represent the zero-account
(i.e., a null user that cannot send transactions), the smart contract account, the
manager, and an arbitrary sender. However, once the arbitrary sender submits
a bid, the sender is now the leading bidder, and cannot withdraw its bid. To
enable withdraw(), a ﬁfth user is required. It follows by applying the results
of [20], that a bound of ﬁve addresses is also suﬃcient, since users do not read
each other’s bids, and adding a sixth user does not enable additional changes to
leadingBid [20]. The bounded system, known as a harness, in Fig. 2 assigns the

5 For simplicity of presentation, we do not use Ether, Ethereum’s native currency.

Compositional Veriﬁcation of Smart Contracts

3

zero-account to address 0, the smart contract account to address 1, the manager
to address 2, the arbitrary senders to addresses 3 and 4, and then executes an
unbounded sequence of arbitrary function calls. Establishing Prop. 1 on the
harness requires ﬁnding its inductive strengthening. A strengthening such as
Prop. 1b (or, in general, a counterexample violating Prop. 1) can be found by
an SMC, directly on the harness code.

The above bound for Prop. 1 also works for checking all control-reachability
properties of Auction. This, for example, follows by applying the results of [20].
That is, Auction has a Small Model Property (SMP) (e.g., [20,1]) for such prop-
erties. However, not all contracts enjoy an SMP. Consider Prop. 2: “The sum of
all active bids is at least leadingBid.” Auction satisﬁes Prop. 2 since the leading
bid is never withdrawn. To prove Auction satisﬁes Prop. 2, we instrument the
code to track the current sum, through the highlighted lines in Fig. 1. With
the addition of _sum, Auction no longer enjoys an SMP. Intuitively, each user
enables new combinations of _sum and leadingBid. As a proof, assume that there
are N users (other than the zero-account, the smart contract account, and the
manager) and let SN = 1 + 2 + · · · + N . In every execution with N users, if
leadingBid is N + 1, then _sum is less than SN +1, since active bids are unique and
SN +1 is the sum of N + 1 bids from 1 to N + 1. However, in an execution with
N + 1 users, if the i-th user has a bid of i, then leadingBid is N + 1 and _sum is
SN +1. Therefore, increasing N extends the reachable combinations of _sum and
leadingBid. For example, if N = 2, then S3 = 1+2+3 = 6. If the leading bid is 3,
then the second highest bid is at most 2, and, therefore, _sum ≤ 5 < S3. However,
when N = 3, if the three active bids are {1, 2, 3}, then _sum is S3. Therefore,
instrumenting Auction with _sum violates the SMP of the original Auction.

Despite the absence of such an SMP, each function of Auction interacts with at
most one user per transaction. Each user is classiﬁed as either the zero-account,
the smart contract, the manager, or an arbitrary sender. In fact, all arbitrary
senders are indistinguishable with respect to Prop. 2. For example, if there are
exactly three active bids, {2, 4, 8}, it does not matter which user placed which
bid. The leading bid is 8 and the sum of all bids is 14. On the other hand, if the
leading bid is 8, then each participant of Auction must have a bid in the range of
0 to 8. To take advantage of these classes, rather than analyze Auction relative
to all 2160 users, it is suﬃcient to analyze Auction relative to a representative
user from each class. In our running example, there must be representatives for
the zero-account, the smart contract account, the manager, and an (arbitrary)
sender. The key idea is that each representative user can correspond to one or
many concrete users.

Intuitively, each representative user summarizes the concrete users in its class.
If a representative’s class contains a single concrete user, then there is no dif-
ference between the concrete user and the representative user. For example, the
zero-account, the smart contract account, and the manager each correspond to
single concrete users. The addresses of these users, and in turn, their bids, are
known with absolute certainty. On the other hand, there are many arbitrary
senders. Since senders are indistinguishable from each other, the precise address

4

S. Wesley et al.

of the representative sender is unimportant. What matters is that the represen-
tative sender does not share an address with the zero-account, the smart contract
account, nor the manager. However, this means that at the start of each transac-
tion the location of the representative sender is not absolute, and, therefore, the
sender has a range of possible bids. To account for this, we introduce a predicate
that is true of all initial bids, and holds inductively across all transactions. We
provide this predicate manually, and use it to over-approximate all possible bids.
An obvious predicate for Auction is that all bids are at most leadingBid, but this
predicate is not strong enough to prove Prop. 2. For example, the representa-
tive sender could ﬁrst place a bid of 10, and then (spuriously) withdraw a bid of
5, resulting in a sum of 5 but a leading bid of 10. A stronger predicate, that is
adequate to prove Prop. 2, is given by θU : “Each bid is at most leadingBid. If
a bid is not leadingBid, then its sum with leadingBid is at most _sum.”

Given θU , Prop. 2 can be veriﬁed by an SMC. This requires a new harness,
with representative, rather than concrete, users. The new harness, Fig. 2 (now
including the highlighted lines), is similar to the SMP harness in that the zero-
account, the smart contract account, and the manager account are assigned
to addresses 0, 1, and 2, respectively, followed by an unbounded sequence of
arbitrary calls. However, there is now a single sender that is assigned to address 3
(line 15). That is, the harness uses a ﬁxed conﬁguration of representatives in
which the fourth representative is the sender. Before each function call, the
sender’s bid is set to a non-deterministic value that satisﬁes θU (lines 6–10). If
the new harness and Prop. 2 are provided to an SMC, the SMC will ﬁnd an
inductive strengthening such as, “The leading bid is at most the sum of all bids.”

The harness in Fig. 2 diﬀers from existing smart contract veriﬁcation tech-
niques in two ways. First, each address in Fig. 2 is an abstraction of one or
more concrete users. Second, msg.sender is restricted to a ﬁnite address space
by lines 13 to 15. If these lines are removed, then an inductive invariant must
constrain all cells of bids, to accommodate bids[msg.sender]. This requires quan-
tiﬁed invariants over arrays that is challenging to automate. By introducing
lines 13 to 15, a quantiﬁer-free predicate, such as our θU , can directly constrain
cell bids[msg.sender] instead. Adding lines 13–15 makes the contract ﬁnite state.
Thus, its veriﬁcation problem is decidable and can be handled by existing SMCs.
However, as illustrated by Prop. 2, the restriction on each user must not exclude
feasible counterexamples. Finding such a restriction is the focus of this paper.

In this paper, we present a new approach to smart contract veriﬁcation. We
construct ﬁnite-state abstractions of parameterized smart contracts, known as
local bundles. A local bundle generalizes the harness in Fig. 2, and is constructed
from a set of representatives and their predicates. When a local bundle and a
property are provided to an SMC, there are three possible outcomes. First, if a
predicate does not over-approximate its representative, a counterexample to the
predicate is returned. Second, if the predicates do not entail the property, then a
counterexample to veriﬁcation is returned (this counterexample refutes the proof,
rather than the property itself). Finally, if the predicates do entail the property,
then an inductive invariant is returned. As opposed to deductive smart contract

Compositional Veriﬁcation of Smart Contracts

5

solutions, our approach ﬁnds inductive strengthenings automatically [17,43]. As
opposed to other model checking solutions for smart contracts, our approach is
not limited to pre- and post-conditions [21], and can scale to 2160 users [24].

Key theoretical contributions of this paper are to show that veriﬁcation with
local bundle abstraction is an instance of Parameterized Compositional Model
Checking (PCMC) [31] and the automation of the side-conditions for its appli-
cability. Speciﬁcally, Theorem 3 shows that the local bundle abstraction is a
sound proof rule, and a static analysis algorithm (PTGBuilder in Sec. 4) com-
putes representatives so that the rule is applicable. Key practical contributions
are the implementation and the evaluation of the method in a new smart con-
tract veriﬁcation tool SmartACE, using SeaHorn [15] for SMC. SmartACE
takes as input a contract and a predicate. Representatives are inferred automat-
ically from the contract, by analyzing the communication in each transaction.
The predicate is then validated by SeaHorn, relative to the representatives. If
the predicate is correct, then a local bundle, as in Fig. 2, is returned.

The rest of the paper is structured as follows. Sec. 2 reviews parameter-
ized veriﬁcation. Sec. 3 presents MicroSol, a subset of Solidity with network
semantics. Sec. 4 relates user interactions to representatives. We formalize user
interactions as Participation Topologies (PTs), and deﬁne PT Graphs (PTGs)
to over-approximate PTs for arbitrarily many users. Intuitively, each PTG over-
approximates the set of representatives. We show that a PTG is computable for
every MicroSol program. Sec. 5 deﬁnes local bundles and proves that our ap-
proach is sound. Sec. 6 evaluates SmartACE and shows that it can outperform
VerX, a state-of-the-art veriﬁcation tool, on all but one VerX benchmark.

2 Background

In this section, we brieﬂy recall Parameterized Compositional Model Checking
(PCMC) [31]. We write u = (u0, . . . , un−1) for a vector of n elements, and ui for
the i-th element of u. For a natural number n ∈ N, we write [n] for {0, . . . , n−1}.

Labeled Transition Systems. A labeled transition system (LTS), M , is a tuple
(S, P, T, s0), where S is a set of states, P is a set of actions, T : S × P → 2S
is a transition relation, and s0 ∈ S is an initial state. M is deterministic if T is
a function, T : S × P → S. A (ﬁnite) trace of M is an alternating sequence of
states and actions, (s0, p1, s1, . . . , pk, sk), such that ∀i ∈ [k] · si+1 ∈ T (si, pi+1).
A state s is reachable in M if s is in some trace (s0, p1, . . . , sk) of M ; that is,
∃i ∈ [k + 1] · si = s. A safety property for M is a subset of states (or a predicate6)
ϕ ⊆ S. M satisﬁes ϕ, written M |= ϕ, if every reachable state of M is in ϕ.

Many transition systems are parameterized. For instance, a client-server ap-
plication is parameterized by the number of clients, and an array-manipulating
program is parameterized by the number of cells. In both cases, there is a single
control process that interacts with many user processes. Such systems are called

6 Abusing notation, we refer to a subset of states ϕ as a predicate and do not distinguish

between the syntactic form of ϕ and the set of states that satisfy it.

6

S. Wesley et al.

synchronized control-user networks (SCUNs) [31]. We let N be the number of
processes, and [N ] be the process identiﬁers. We consider SCUNs in which users
only synchronize with the control process and do not execute code on their own.
An SCUN N is a tuple (SC, SU , PI , PS, TI , TS, c0, u0), where SC is a set of
control states, SU a set of user states, PI a set of internal actions, PS a set
of synchronized actions, TI : SC × PI → SC an internal transition function,
TS : SC × SU × PS → SC × SU a synchronized transition function, c0 ∈ SC is the
initial control state, and u0 ∈ SU is the initial user state. The semantics of N are
given by a parameterized LTS, M (N ) := (S, P, T, s0), where S := SC × (SU )N ,
P := PI ∪ (PS × [N ]), s0 := (c0, u0, . . . , u0), and T : S × P → S such that:
(1) if p ∈ PI , then T ((c, u), p) = (TI (c, p), u), and (2) if (p, i) ∈ PS × [N ], then
T ((c, u), (p, i)) = (c(cid:48), u(cid:48)) where (c(cid:48), u(cid:48)
j = uj.

i) = TS(c, ui, p), and ∀j ∈ [N ]\{i}·u(cid:48)

Parameterized Compositional Model Checking (PCMC). Parameterized systems
have parameterized properties [16,31]. A k-universal safety property [16] is a
predicate ϕ ⊆ SC × (SU )k. A state (c, u) satisﬁes predicate ϕ if ∀{i1, . . . , ik} ⊆
[N ] · ϕ(c, ui1 , . . . , uik ). A parameterized system M (N ) satisﬁes predicate ϕ if
∀N ∈ N · M (N ) |= ϕ. For example, Prop. 1 (Sec. 1) of SimpleAuction (Fig. 1) is
1-universal: “For every user u, if stop() has been called, then u is immutable.”
Proofs of k-universal safety employ compositional reasoning, e.g., [2,16,31,33].
Here, we use PCMC [31]. The keys to PCMC are uniformity—the property that
ﬁnitely many neighbourhoods are distinguishable—and a compositional invari-
ant—a summary of the reachable states for each equivalence class, that is closed
under the actions of every other equivalence class. For an SCUN, the composi-
tional invariant is given by two predicates θC ⊆ SC and θU ⊆ SC ×SU satisfying:

Initialization c0 ∈ θC and (c0, u0) ∈ θU ;
Consecution 1 If c ∈ θC, (c, u) ∈ θU , p ∈ PS, and (c(cid:48), u(cid:48)) ∈ TS(c, u, p), then

Consecution 2 If c ∈ θC, (c, u) ∈ θU , p ∈ PC, and c(cid:48) = TI (c, p), then c(cid:48) ∈ θC

c(cid:48) ∈ θC and (c(cid:48), u(cid:48)) ∈ θU ;

and (c(cid:48), u) ∈ θU ;

Non-Interference If c ∈ θC, (c, u) ∈ θU , (c, v) ∈ θU , u (cid:54)= v, p ∈ PS, and

(c(cid:48), u(cid:48)) = TS(c, u, p), then (c(cid:48), v) ∈ θC.

By PCMC [31], if ∀c ∈ θC · ∀{(c, u1), . . . , (c, uk)} ⊆ θU · ϕ(c, u1, . . . , uk), then
M |= ϕ. This is as an extension of Owicki-Gries [33], where θC summarizes the
acting process and θU summarizes the interfering process. For this reason, we
call θC the inductive invariant and θU the interference invariant.

3 MicroSol: Syntax and Semantics

This section provides network semantics for MicroSol, a subset of Solidity7. Like
Solidity, MicroSol is an imperative object-oriented language with built-in com-
munication operations. The syntax of MicroSol is in Fig. 3. MicroSol restricts So-
lidity to a core subset of communication features. For example, MicroSol does not

7 https://docs.soliditylang.org/

Compositional Veriﬁcation of Smart Contracts

7

(cid:104)FName(cid:105) ::= a valid function name

(cid:104)VName(cid:105) ::= a valid variable name

(cid:104)CName(cid:105) ::= a valid contract name

(cid:104)Literal(cid:105) ::= an integer, Boolean, or address literal

(cid:104)Types(cid:105) ::= uint | bool | address | mapping( address => uint ) | (cid:104)CName(cid:105)

(cid:104)Operator(cid:105) ::= == | != | < | > | + | - | * | / | && | || | !

(cid:104)Expr(cid:105) ::= (cid:104)Literal(cid:105) | (cid:104)VName(cid:105) | this | msg.sender | (cid:104)Expr(cid:105) (cid:104)Operator(cid:105) (cid:104)Expr(cid:105)

| address( (cid:104)VName(cid:105) ) | (cid:104)Expr(cid:105).(cid:104)FName(cid:105) ( (cid:104)Expr(cid:105), . . . )

| (cid:104)FName(cid:105) ( (cid:104)Expr(cid:105), . . . ) | (cid:104)Expr(cid:105) [ (cid:104)Expr(cid:105) ] . . . [ (cid:104)Expr(cid:105) ]

(cid:104)Assign(cid:105) ::= (cid:104)VName(cid:105) = (cid:104)Expr(cid:105) | (cid:104)Expr(cid:105) = new (cid:104)CName(cid:105)( (cid:104)Expr(cid:105), . . . )

| (cid:104)Expr(cid:105) [ (cid:104)Expr(cid:105) ] . . . [ (cid:104)Expr(cid:105) ] = (cid:104)Expr(cid:105)

(cid:104)Decl(cid:105) ::= (cid:104)Types(cid:105) (cid:104)VName(cid:105)

(cid:104)Stmt(cid:105) ::= (cid:104)Decl(cid:105) | (cid:104)Assign(cid:105) | require( (cid:104)Expr(cid:105) ) | assert( (cid:104)Expr(cid:105) ) | return

| if( (cid:104)Expr(cid:105) ) { (cid:104)Stmt(cid:105) } | while( (cid:104)Expr(cid:105) ) { (cid:104)Stmt(cid:105) } | (cid:104)Stmt(cid:105); (cid:104)Stmt(cid:105)

(cid:104)Ctor(cid:105) ::= constructor ( (cid:104)Decl(cid:105), . . . ) public { (cid:104)Stmt(cid:105) }

(cid:104)Func(cid:105) ::= function (cid:104)FName(cid:105) ( (cid:104)Decl(cid:105), . . . ) public { (cid:104)Stmt(cid:105) }

(cid:104)Contract(cid:105) ::= contract (cid:104)CName(cid:105) { (cid:104)Decl(cid:105); . . . ; (cid:104)Ctor(cid:105) (cid:104)Func(cid:105) . . . }

(cid:104)Bundle(cid:105) ::= (cid:104)Contract(cid:105) (cid:104)Contract(cid:105) . . .

Fig. 3: The formal grammar of the MicroSol language.

include inheritance, cryptographic operations, or mappings between addresses.
In our evaluation (Sec. 6), we use a superset of MicroSol, called MiniSol (see
Appendix B), that extends our semantics to a wider set of smart contracts.
Throughout this section, we illustrate MicroSol using Auction in Fig. 1.

A MicroSol smart contract is similar to a class in object-oriented program-
ming, and consists of variables, and transactions (i.e., functions) for users to
call. A transaction is a deterministic sequence of operations. Each smart con-
tract user has a globally unique identiﬁer, known as an address. We view a smart
contract as operating in an SCUN: the control process executes each transac-
tion sequentially, and the user processes are contract users that communicate
with the control process. Users in the SCUN enter into a transaction through
a synchronized action, then the control process executes the transaction as an
internal action, and ﬁnally, the users are updated through synchronized actions.
For simplicity of presentation, each transaction is given as a global transition.

A constructor is a special transaction that is executed once after contract
creation. Calls to new (i.e., creating new smart contracts) are restricted to con-
structors. Auction in Fig. 1 is a smart contract that deﬁnes a constructor (line 6),
three other functions (lines 8, 17, and 25), and four state variables (lines 2–3).
MicroSol has four types: address, numeric (including bool), mapping, and
contract reference. Address variables prevent arithmetic operations, and numeric
variables cannot cast to address variables. Mapping and contract-reference vari-
ables correspond to dictionaries and object pointers in other object-oriented
languages. Each typed variable is further classiﬁed as either state, input, or lo-
cal. We use role and data to refer to state variables of address and numeric types,
respectively. Similarly, we use client and argument to refer to inputs of address

8

S. Wesley et al.

and numeric types, respectively. In Auction of Fig. 1, there is 1 role (manager), 2
contract data (leadingBid and stopped), 1 mapping (bids), 1 client common to all
transactions (msg.sender), and at most 1 argument in any transaction (amount).
Note that in MicroSol, user denotes any user process within a SCUN. A
client is deﬁned relative to a transaction, and denotes a user passed as an input.

Semantics of MicroSol. Let C be a MicroSol program with a single transaction
tr (see Appendix A for multiple transactions). An N -user bundle is an N -user
network of several (possibly identical) MicroSol programs. The semantics of a
bundle is an LTS, lts(C, N ) := (S, P, f, s0), where SC := control(C, [N ]) is the set
of control states, SU := user(C, [N ]), is the set of user states, s⊥ is the error state,
S ⊆ (SC ∪ {s⊥}) × (SU )N is the set of LTS states, P := action(C, [N ]) is the set
of actions, f : S × P → S is the transition function, and s0 is the initial state.
We assume, without loss of generality, that there is a single control process8.

Let D be the set of 256-bit unsigned integers. The state space of a smart
contract is determined by the address space, A, and the state variables of C. In
the case of lts(C, N ), the address space is ﬁxed to A = [N ]. Assume that n, m, and
k are the number of roles, data, and mappings in C, respectively. State variables
are stored by their numeric indices (i.e., variable 0, 1, etc.). Then, control(C, A) ⊆
An × Dm and user(C, A) ⊆ A × Dk. For c = (x, y) ∈ control(C, A), role(c, i) = xi
is the i-th role and data(c, i) = yi is the i-th datum. For u = (z, y) ∈ user(C, A),
z is the address of u, and map(u) = y are the mapping values of u.

Similarly, actions are determined by the address space, A, and the input
variables of tr . Assume that q and r are the number of clients and arguments
of tr , respectively. Then action(C, A) ⊆ Aq × Dr. For p = (x, y) ∈ action(C, A),
client(p, i) = xi is the i-th client in p and arg(p, i) = yi is the i-th argument in
p. For a ﬁxed p, we write fp(s, u) to denote f ((s, u), p).

The initial state of lts(C, N ) is s0 := (c, u) ∈ control(C, [n]) × user(C, [n])N ,
where c = (0, 0), ∀i ∈ [N ] · map(ui) = 0, and ∀i ∈ [N ] · id(ui) = i. That is, all
variables are zero-initialized and each user has a unique address.

C

An N -user transition function is determined by the (usual) semantics of tr ,
and a bijection from addresses to user indices, M : A → [N ]. If M(a) = i, then
address a belongs to user ui. In the case of lts(C, N ), the i-th user has address
i, so M(i) = i. We write f :=
M, and given an action p, fp updates the state
variables according to the source code of tr with respect to M. If an assert fails
or an address is outside of A, then the error state s⊥ is returned. If a require
fails, then the state is unchanged. Note that f preserves the address of each user.
For example, lts(Auction, 4) = (S, P, f, s0) is the 4-user bundle of Auction.
Assume that (c, u) is the state reached after evaluating the constructor. Then
role(c, 0) = 2, data(c, 0) = 0, data(c, 1) = 0, and ∀i ∈ [4] · map(ui)0 = 0. That is,
the manager is at address 2, the leading bid is 0, the auction is not stopped, and
there are no active bids. This is because variables are zero-indexed, and stopped

(cid:75)

(cid:74)

8 Restrictions place on new ensure that the number of MicroSol smart contracts in a
bundle is a static fact. Therefore, all control states are synchronized, and can be
combined into a product machine.

Compositional Veriﬁcation of Smart Contracts

9

(a) A PT for 4 users and a ﬁxed action.

(b) The PTG from PTGBuilder.

Fig. 4: A PT of Auction contrasted with a PTG for Auction.

is the second numeric variable (i.e., at index 1). If the user at address 3 placed a
bid of 10, this corresponds to p ∈ P such that client(p, 0) = 3 and arg(p, 0) = 10.
A complete LTS for this example is in Appendix A.

Limitations of MicroSol. MicroSol places two restrictions on Solidity. First, ad-
dresses are not numeric. We argue that this restriction is reasonable, as address
manipulation is a form of pointer manipulation. Second, new must only appear
in constructors. In our evaluation (Sec. 6), all calls to new could be moved into a
constructor with minimal eﬀort. We emphasize that the second restriction does
not preclude the use of abstract interfaces for arbitrary contracts.

4 Participation Topology

The core functionality of any smart contract is communication between users.
Usually, users communicate by reading from and writing to designated mapping
entries. That is, the communication paradigm is shared memory. However, it is
convenient in interaction analysis to re-imagine smart contracts as having ren-
dezvous synchronization in which users explicitly participate in message passing.
In this section, we formally re-frame smart contracts with explicit communica-
tion by deﬁning a (semantic) participation topology and its abstractions.

A user u participates in communication during a transaction f whenever the
state of u aﬀects execution of f or f aﬀects a state of u. We call this inﬂuence. For
example, in Fig. 1, the sender inﬂuences withdraw on line 19. Similarly, withdraw
inﬂuences the sender on line 22. In all cases, the inﬂuence is witnessed by the
state of the contract and the conﬁguration of users that exhibit the inﬂuence.

Let C be a contract, N ∈ N be the network size, (S, P, f, s0) = lts(C, N ), and
p ∈ P . A user with address a ∈ N inﬂuences transaction fp if there exists an
s, r, r(cid:48) ∈ control(C, [N ]), u, u(cid:48), v, v(cid:48) ∈ user(C, [N ])N , and i ∈ [N ] such that:

1. id(ui) = a;
2. ∀j ∈ [N ] · (uj = vj) ⇐⇒ (i (cid:54)= j);
3. (r, u(cid:48)) = fp(s, u) and (r(cid:48), v(cid:48)) = fp(s, v);
4. (r = r(cid:48)) ⇒ (cid:0)∃j ∈ [N ] \ {i} · u(cid:48)

(cid:1).

j (cid:54)= v(cid:48)
j

That is, there exists two network conﬁgurations that diﬀer only in the state of
the user ui, and result in diﬀerent network conﬁgurations after applying fp. In

0123Implicit@0Transient@0Transient@0Implicit@1Transient@0Explicit@1Transient@0bid / withdraw / stopmsg.sender	=	3;	amount	=	5Transient@0Explicit@0scImplicit@0Transient@0Explicit@001*Implicit@1Transient@0Explicit@010

S. Wesley et al.

practice, fp must compare the address of ui to some other address, or must
use the state of ui to determine the outcome of the transaction. The tuple
(s, u, v) is a witness to the inﬂuence of a over transaction fp. A user with address
a ∈ N is inﬂuenced by transaction fp if there exists an s, s(cid:48) ∈ control(C, [N ]),
u, u(cid:48) ∈ user(C, [N ])N , and i ∈ [N ] such that:

1. id(ui) = a;
2. (s(cid:48), u(cid:48)) = fp(s, u);
3. u(cid:48)

i (cid:54)= ui.

That is, fp must write into the state of ui, and the changes must persist after
the transaction terminates. The tuple (s, u) is a witness to the inﬂuence of
transaction fp over user a.

Deﬁnition 1 (Participation). A user with address a ∈ N participates in
a transaction fp if either a inﬂuences fp, witnessed by some (s, u, v), or fp
inﬂuences a, witnessed by some (s, u). In either case, s is a witness state.

Smart contracts facilitate communication between many users across many
transactions. We need to know every possible participant, and the cause of their
participation—we call this the participation topology (PT). A PT associates each
communication (sending or receiving) with one or more participation classes,
called explicit, transient, and implicit. The participation is explicit if the partic-
ipant is a client of the transaction; transient if the participant has a role during
the transaction; implicit if there is a state such that the participant is neither a
client nor holds any roles. In the case of MiniSol, all implicit participation is due
to literal address values, as users designated by literal addresses must participate
regardless of clients and roles. An example of implicit participation is when a
client is compared to the address of the zero-account (i.e., address(0)) in Fig. 1.

Deﬁnition 2 (Participation Topology). A Participation Topology of a trans-
action fp is a tuple pt(C, N, p) := (Explicit, Transient, Implicit), where:

1. Explicit ⊆ N × [N ] where (i, a) ∈ Explicit iﬀ a participates during fp, with

client(p, i) = a;

2. Transient ⊆ N × [N ] where (i, a) ∈ Transient iﬀ a participates during fp, as

witnessed by a state s ∈ control(C, [N ]), where role(s, i) = a;

3. Implicit ⊆ [N ] where a ∈ Implicit iﬀ a participates during fp, as witnessed
by a state s ∈ control(C, [N ]), where ∀i ∈ N, role(s, i) (cid:54)= a and client(p, i) (cid:54)= a.

For example, Fig. 4a shows a PT for any function of Fig. 1 with 4 users.
From Sec. 1, it is clear that each function can have an aﬀect. The zero-account
and smart contract account are both implicit participants, since changing either
account’s address to 3 would block the aﬀect of the transaction. The manager
is a transient participant and the sender is an explicit participant, since the
(dis)equality of their addresses is asserted at lines 9, 18, and 26.

Def. 2 is semantic and dependent on actions. A syntactic summary of all
PTs for all actions is required to reason about communication. This summary

Compositional Veriﬁcation of Smart Contracts

11

is analogous to over-approximating control-ﬂow with a “control-ﬂow graph” [3].
This motivates the Participation Topology Graph (PTG) that is a syntactic over-
approximation of all possible PTs, independent of network size. A PTG has a
vertex for each user and each action, such that edges between vertices represent
participation classes. In general, a single vertex can map to many users or actions.
PTG edges are labeled by participation classes. For any contract C, there
are at most m explicit classes and n transient classes, where n is the number of
roles, and m is the maximum number of clients taken by any function of C. On
the other hand, the number of implicit classes is determined by the PTG itself.
In general, there is no bound on the number of implicit participants, and it is up
to a PTG to provide an appropriate abstraction (i.e., L in Def. 3). The label set
common to all PTGs is AP(C) := {explicit@i | i ∈ [n]} ∪ {transient@i | i ∈ [m]}.

Deﬁnition 3 (Participation Topology Graph). Let L be a ﬁnite set of
implicit classes, V (cid:40) N be ﬁnite, E ⊆ V × V , and δ ⊆ E × (AP(C) ∪ L). A PT
Graph for a contract C is a tuple ((V, E, δ), ρ, τ ), where (V, E, δ) is a graph labeled
by δ, ρ ⊆ action(C, N) × V , and τ ⊆ action(C, N) × N × V , such that for all N ∈ N
and for all p ∈ action(C, [N ]), with pt(C, N, p) = (Explicit, Transient, Implicit):

1. If (i, a) ∈ Explicit, then there exists a (p, u) ∈ ρ and (p, a, v) ∈ τ such that

(u, v) ∈ E and δ ((u, v), explicit@i);

2. If (i, a) ∈ Transient, then there exists a (p, u) ∈ ρ and (p, a, v) ∈ τ such that

(u, v) ∈ E and δ ((u, v), transient@i);

3. If a ∈ Implicit, then there exists a (p, u) ∈ ρ, (p, a, v) ∈ τ , and l ∈ L such

that (u, v) ∈ E and δ ((u, v), l).

In Def. 3, τ and ρ map actions and users to vertices, respectively. An edge
between an action and a user indicates the potential for participation. The labels
describe the potential participation classes. As an example, Fig. 4b is a PTG
for Fig. 1, where all actions map to sc, the zero-account maps to vertex 0, the
smart contract account maps to vertex 1, and all other users map to (cid:63). The two
implicit classes have the label implicit@0 and implicit@1, respectively.

Theorem 1. Let C be a contract with a PTG (G, ρ, τ ), G = (V, E, δ), and δ ⊆
E × (AP(C) ∪ L). Then, for all N ∈ N and all p ∈ action(C, [N ]), pt(C, N, p) =
(Explicit, Transient, Implicit) is over-approximated by (G, ρ, τ ) as follows:

1. If Explicit(i, a), then ∃(u, v) ∈ E · ρ(p, u) ∧ τ (p, a, v) ∧ δ ((u, v), explicit@i);
2. If Transient(i, a), then ∃(u, v) ∈ E ·ρ(p, u)∧τ (p, a, v)∧δ ((u, v), transient@i);
3. If Implicit(a), then ∃(u, v) ∈ E · ∃l ∈ L · ρ(p, u) ∧ τ (p, a, v) ∧ δ ((u, v), l).

For any PT, there are many over-approximating PTGs. The weakest PTG
joins every user to every action using all possible labels and a single implicit
class. Fig. 4b, shows a simple, yet stronger, PTG for Fig. 1. First, note that
there are two implicit participants, identiﬁed by addresses 0 and 1, with labels
implicit@0 and implicit@1, respectively. Next, observe that any arbitrary user
can become the manager. Finally, the distinctions between actions are ignored.
Thus, there are three user vertices, two which are mapped to the zero-account

12

S. Wesley et al.

and smart contract account, and another mapped to all other users. Such a PTG
is constructed automatically using an algorithm named PTGBuilder.

PTGBuilder takes a contract C and returns a PTG. The implicit classes are
L := {implicit@a | a ∈ N}, where implicit@a signiﬁes implicit communication
with address a. PTG construction is reduced to taint analysis [23]. Input address
variables, state address variables, and literal addresses are tainted sources. Sinks
are memory writes, comparison expressions, and mapping accesses. PTGBuilder
computes (Args, Roles, Lits), where (1) Args is the set of indices of input vari-
ables that propagate to a sink; (2) Roles is the set of indices of state variables
that propagate to a sink; (3) Lits is the set of literal addresses that propa-
gate to a sink. Finally, a PTG is constructed as (G, ρ, τ ), where G = (V, E, δ),
ρ ⊆ action(C, N) × V , τ ⊆ action(C, N) × N × V , sc, and (cid:63) are unique vertices:
1. V := Lits ∪ {sc, (cid:63)} and E := {(sc, v) | v ∈ V \{sc}};
2. δ := {(e, explicit@i) | e ∈ E, i ∈ Args} ∪ {(e, transient@i) | e ∈ E, i ∈ Roles} ∪

{((sc, a), transient@a) | a ∈ Lits};

3. ρ := {(p, sc) | p ∈ action(C, N)};
4. τ := {(p, a, (cid:63)) | p ∈ action(C, N), a ∈ N\Lits} ∪ {(p, a, a) | p ∈ action(C, N), a ∈ Lits}.

PTGBuilder formalizes the intuition of Fig. 4b. Rule 1 ensures that every lit-
eral address has a vertex, and that all user vertices connect to sc. Rule 2 over-
approximates explicit, transient, and implicit labels. The ﬁrst set states that if
an input address is never used, then the client is not an explicit participant. This
statement is self-evident, and over-approximates explicit participation. The sec-
ond and third set make similar claims for roles and literal addresses Rules 3 and 4
deﬁne ρ and τ as expected. Note that in MicroSol, implicit participation stems
from literal addresses, since addresses do not support arithmetic operations, and
since numeric expressions cannot be cast to addresses.

By re-framing smart contracts with rendezvous synchronization, each trans-
action is re-imagined as a communication between several users. Their communi-
cation patterns are captured by the corresponding PT. A PTG over-approximates
PTs of all transactions, and is automatically constructed using PTGBuilder. This
is crucial for PCMC as it provides an upper bound on the number of equivalence
classes, and the users in each equivalence class (see Appendix C).

5 Local Reasoning in Smart Contracts

In this section, we present a proof rule for the parameterized safety of MicroSol
programs. Our proof rule extends the existing theory of PCMC. The section is
structured as follows. Sec. 5.1 introduces syntactic restrictions, for properties and
interference invariants, that expose address dependencies. Sec. 5.2, deﬁnes local
bundle reductions, that reduce parameterized smart contract models to ﬁnite-
state models. We show that for the correct choice of local bundle reduction, the
safety of the ﬁnite-state model implies the safety of the parameterized model.

5.1 Guarded Properties and Split Invariants

Universal properties and interference invariants might depend on user addresses.
However, PCMC requires explicit address dependencies. This is because address

Compositional Veriﬁcation of Smart Contracts

13

dependencies allow predicates to distinguish subsets of users. To resolve this, we
introduce two syntactic forms that make address dependencies explicit: guarded
universal safety properties and split interference invariants. We build both forms
from so called address-oblivious predicates that do not depend on user addresses.
For any smart contract C and any address space A, a pair of user conﬁgura-
tions, u, v ∈ user(C, A)k, are k-address similar if ∀i ∈ [k] · map(ui) = map(vi). A
predicate ξ ⊆ control(C, A) × user(C, A)k is address-oblivious if, for every choice
of s ∈ control(C, A), and every pair of k-address similar conﬁgurations, u and v,
ξ(s, u) ⇐⇒ ξ(s, v). Prop. 1 and Prop. 2 in Sec. 1 are address-oblivious.

A guarded k-universal safety property is built from a single k-user address-
oblivious predicate. The predicate is guarded by constraints over its k user
addresses. Each constraint compares a single user’s address to either a literal
address or a role. This notion is formalized by Def. 4, and illustrated in Ex. 1.

Deﬁnition 4 (Guarded Universal Safety). For k ∈ N, a guarded k-universal
safety property is a k-universal safety property ϕ, given by a tuple (L, R, ξ),
where L (cid:40) N × [k] is ﬁnite, R (cid:40) N × [k] is ﬁnite, and ξ is an address-oblivious
k-user predicate, such that:

ϕ (s, u) :=









(cid:94)

(a,i)∈L





a = id(ui)

 ∧



(cid:94)

(i,j)∈R





role(s, i) = id(uj)



 ⇒ ξ(s, u)

Note that AL := {a | (a, i) ∈ L} and AR := {i | (i, j) ∈ R} and deﬁne the literal
and role guards for ϕ.

Example 1. Consider the claim that in Auction of Fig. 1, the zero-account cannot
have an active bid. This claim is stated as Prop. 3: For each user process u,
if id(u0) = 0, then map(u0)0 = 0. That is, Prop. 3 is a guarded 1-universal
safety property ϕ1(s, u) := (0 = id(u0)) ⇒ (map(u0)0 = 0). Following Def. 4, ϕ1
is determined by (L1, ∅, ξ1), where L1 = {(0, 0)} and ξ1(s, u) := map(u0)0 = 0.
The second set is ∅ as there are no role constraints in Prop. 3. If a state (s, u)
satisﬁes ϕ1, then ∀{i} ⊆ [N ] · ϕ1(s, (ui)). Note that u is a singleton vector, and
(cid:117)(cid:116)
that ϕ1 has 1 literal guard, given by {0}.

The syntax of a split interference invariant is similar to a guarded safety
property. The invariant is constructed from a list of address-oblivious predi-
cates, each guarded by a single constraint. The ﬁnal predicate is guarded by
the negation of all other constraints. Intuitively, each address-oblivious predi-
cate summarizes the class of users that satisfy its guard. The split interference
invariant is the conjunction of all (guarded predicate) clauses. We proceed with
the formal deﬁnition in Def. 5 and a practical illustration in Ex. 2.

Deﬁnition 5 (Split Interference Invariant). A split interference invariant
is an interference invariant θ, given by a tuple (AL, AR, ζ, µ, ξ), where AL =
{l0, . . . , lm−1} (cid:40) N is ﬁnite, AR = {r0, . . . , rn−1} (cid:40) N is ﬁnite, ζ is a list of

14

S. Wesley et al.

m address-oblivious 1-user predicates, µ is a list of n address-oblivious 1-user
predicates, and ξ is an address-oblivious 1-user predicate, such that:

ψLits(s, u) :=

(cid:32)m−1
(cid:94)

(cid:33)

id(u0) = li

⇒ ζi(s, u)

i=0
(cid:32)n−1
(cid:94)

ψRoles(s, u) :=

(cid:33)

id(u0) = role(s, ri)

⇒ µi(s, u)

ψElse(s, u) :=

i=0
(cid:32)(cid:32)m−1
(cid:94)

i=0

(cid:33)

id(u0) (cid:54)= li

∧

(cid:32)n−1
(cid:94)

i=0

(cid:33)(cid:33)

id(u0) (cid:54)= role(s, ri)

⇒ ξ(s, u)

θ(s, u) := ψRoles(s, u) ∧ ψLits(s, u) ∧ ψElse(s, u)

Note that AL and AR deﬁne literal and role guards of θ, and that |u| = 1.

Example 2. To establish ϕ1 from Ex. 1, we require an adequate interference
invariant such as Prop. 4: The zero-account never has an active bid, while all
other users can have active bids. That is, Prop. 4 is a split interference invariant:

θ1(s, u) := (id(u0) = 0 ⇒ (map(u0))0 = 0) ∧ (id(u0) (cid:54)= 0 ⇒ (map(u0))0 ≥ 0)

Following Def. 5, θ1 is determined by Inv = (AL, ∅, (ξ1), ∅, ξ2), where AL =
{0}, ξ1 is deﬁned in Ex. 1, and ξ2(s, u) := map(u0)0 ≥ 0. The two instances of ∅
in Inv correspond to the lack of role constraints in θ1. If Inv is related back to
Def. 5, then ψRoles(s, u) := (cid:62), ψLits(s, u) := (id(u0) = 0) ⇒ (map(u0)0 = 0), and
(cid:117)(cid:116)
ψElse(s, u) := (id(u0) (cid:54)= 0) ⇒ (map(u0)0 ≥ 0).

5.2 Localizing a Smart Contract Bundle

A local bundle is a ﬁnite-state abstraction of a smart contract bundle. This ab-
straction reduces smart contract PCMC to software model checking. At a high
level, each local bundle is a non-deterministic LTS and is constructed from three
components: a smart contract, a candidate interference invariant, and a neigh-
bourhood. The term candidate interference invariant describes any predicate
with the syntax of an interference invariant, regardless of its semantic interpre-
tation. Sets of addresses are used to identify representatives in a neighbourhood.
Let A be an N -user neighbourhood and θU be a candidate interference in-
variant. The local bundle corresponding to A and θU is deﬁned using a special
relation called an N -user interference relation. The N -user interference relation
(for θU ) sends an N -user smart contract state to the set of all N -user smart
contract states that are reachable under the interference of θU . A state is reach-
able under the interference of θU if the control state is unchanged, each address
is unchanged, and all user data satisﬁes θU . For example, lines 6–10 in Fig. 2
apply a 4-user interference relation to the states of Auction. Note that if the
interference relation for θU fails to relate (s, u) to itself, then (s, u) violates θU .

Compositional Veriﬁcation of Smart Contracts

15

Deﬁnition 6 (Interference Relation). Let N ∈ N, C be a contract, S =
control(C, N) × user(C, N)N , and θU be a split candidate interference invariant.
The N -user interference relation for θU is the relation g : S → 2S such that
g(c, u) := {(c, v) ∈ S | ∀i ∈ [N ] · id(ui) = id(vi) ∧ θU (s, vi)}.

Each state of the local bundle for A and θU is a tuple (s, u), where s is a
control state and u is an N -user conﬁguration. The N users in the local bundle
correspond to the N representatives in A, and therefore, the address space of
the local bundle can be non-consecutive. The transition relation of the local
bundle is deﬁned in terms of the (global) transaction function f . First, the
transition relation applies f . If the application of f is closed under θU , then the
interference relation is applied. Intuitively, θU deﬁnes a safe envelop under which
the interference relation is compositional.

Deﬁnition 7 (Local Bundle). Let C be a contract, A = {a0, . . . , aN −1} ⊆
N be an N -user neighbourhood, θU be a candidate split interference invariant,
and g be the N -user interference relation for θU . A local bundle is an LTS
local(C, A, θU ) := (S, P, ˆf , s0), such that S := control(C, A) × user(C, A)N , P :=
action(C, A), s0 := (c0, u), c0 := (0, 0), ∀i ∈ [N ] · id(ui) = ai ∧ map(ui) = 0, and
ˆf is deﬁned with respect to M : A → [N ], M(ai) = i, such that:

ˆf ((s, u), p) :=

(cid:40)

g(s(cid:48), u(cid:48))
C

(cid:74)

(cid:75)

if (s(cid:48), u(cid:48)) =

M((s, u), p) ∧ (s(cid:48), u(cid:48)) ∈ g(s(cid:48), u(cid:48))

C

(cid:74)

(cid:75)

M((s, u), p) otherwise

Example 3. We brieﬂy illustrate the transition relation of Def. 7 using Auction of
Fig. 1. Let A1 = {0, 1, 2, 3} be a neighbourhood, θ1 be as in Ex. 2, g be the 4-user
interference relation for θ1, and (S, P, ˆf , s0) = local(C, A1, θ1). Consider applying
ˆf to (s, u) ∈ S with action p ∈ P , such that s = {manager (cid:55)→ 2; leadingBid (cid:55)→ 0},
∀i ∈ [4] · map(ui) = 0, and p is a bid of 10 from a sender at address 3.

By deﬁnition, if (s(cid:48), v) = f (s, u, p), then the leading bid is now 10, and
the bid of the sender is also 10, since the sender of p was not the manager
and the leading bid was less than 10. Clearly (s(cid:48), v) ∈ g(s(cid:48), v), and therefore,
g(s(cid:48), v) = ˆf ((s, u), p). A successor state is then selected, as depicted in Fig. 5a.
This is done by ﬁrst assigning an arbitrary bid to each representative, and then
requiring that each bid satisﬁes θ1 relative to s(cid:48). In Fig. 5a, a network is selected
in which ∀i ∈ [4] · id(vi) = i. As depicted in Fig. 5a, θ1 stipulates that the
zero-account must satisfy ξ1 and that all other users must satisfy ξ2.

In Fig. 5b, a satisfying bid is assigned to each user. The choice for d0 was ﬁxed
since ξ1(s, v0) entails d0 = 0. For d1 to d3, any non-negative value could have
been selected. After the transaction is executed, map(u(cid:48)
1)0 = 1,
3)0 = 3, and s(cid:48) = {manager (cid:55)→ 2; leadingBid (cid:55)→ 10}. Then
map(u(cid:48)
(s(cid:48), u(cid:48)) ∈ ˆf (s, u), as desired. Note that (s(cid:48), u(cid:48)) is not reachable in lts(C, 4).
(cid:117)(cid:116)

2)0 = 2, map(u(cid:48)

0)0 = 0, map(u(cid:48)

Ex. 3 motivates an important result for local bundles. Observe that (s(cid:48), u(cid:48)) |=
θ1. This is not by chance. First, by the compositionality of θ1, all user conﬁgura-
tions reached by local(C, A1, θ1) must satisfy θU . Second, and far less obviously,

16

S. Wesley et al.

(a) A local 4-user conﬁguration.

(b) The saturating property of A1.

Fig. 5: The local bundle for Auction in Fig. 1, as deﬁned by A1 and θ1 in Ex. 3.

by choice of A1, if all reachable user conﬁgurations satisfy θ1, then θ1 must be
compositional. The proof of this result relies on a saturating property of A1.

A neighbourhood A is saturating if it contains representatives from each par-
ticipation class of a PTG, and for all role guards (AR (cid:40) N) and literal guards
(AL ⊆ N) of interest. Intuitively, each participation class over-approximates an
equivalence class of C. The number of representatives is determined by the equiv-
alence class. In the case of PTGBuilder, a saturating neighbourhood contains one
address for each participation class. For an implicit class, such as implicit@x,
x is literal and must appear in the neighbourhood. All other addresses are se-
lected arbitrarily. The saturating property of A1 is depicted in Fig. 5b by the
correspondence between users and participation classes (AR = ∅, AL = {0}).

Deﬁnition 8 (Saturating Neighbourhood). Let AR, AL ⊆ N, C be a con-
tract, (G, ρ, τ ) be the PTGBuilder PTG of C, and G = (V, E, δ) such that AR
and AL are ﬁnite. A saturating neighbourhood for (AR, AL, (G, ρ, τ )) is a set
AExp ∪ ATrans ∪ AImpl s.t. AExp, ATrans, AImpl ⊆ N are pairwise disjoint and:

1. |AExp| = |{i ∈ N | ∃e ∈ E · δ (e, explicit@i)}|,
2. |ATrans| = |{i ∈ N | ∃e ∈ E · δ (e, transient@i)} ∪ AR|,
3. AImpl = {x ∈ N | ∃e ∈ E · δ (e, implicit@x)} ∪ AL.

A saturating neighbourhood can be used to reduce compositionality and k-
safety proofs to the safety of local bundles. We start with compositionality. Con-
sider a local bundle with a neighbourhood A+, where A+ contains a saturating
neighbourhood, the guards of θU , and some other address a. The neighbourhood
A+ contains a representative for: each participation class; each role and literal
user distinguished by θU ; an arbitrary user under interference (i.e., a). We ﬁrst
claim that if θU is compositional, then a local bundle constructed from θU must
be safe with respect to θU (as in Ex. 3). The ﬁrst claim follows by induction.
By Initialization (Sec. 2), the initial users satisfy θU . For the inductive step,
assume that all users satisfy θU and apply ˆfp. The users that participate in ˆfp
maintain θU by Consecution (Sec. 2). The users that do not participate also
maintain θU by Non-Interference (Sec. 2). By induction, the ﬁrst claim is
true. We also claim that for a suﬃciently large neighbourhood—say A+—the
converse is also true. Intuitively, A+ is large enough to represent each equiva-
lence class imposed by both the smart contract and θU , along with an arbitrary

bid / withdraw / stopState : { manager ↦ 2 ; leadingBid ↦ 0 }Explicit 1Explicit 2Transient 1Implicit 1 id : 0 rec : d0 id : 1 rec : d1 id : 2 rec : d2 id : 3 rec : d3ξ1:d0 = 0ξ2:d1 ≥ 0ξ2:d2 ≥ 0ξ2:d3 ≥ 0Implicit 1id : 1rec : d1Explicit 0Transient 0bidInput : { msg.sender ↦ 1 ; amount ↦ 10 }State : { manager ↦ 2 ; leadingBid ↦ 0 } Explicit 1Explicit 2Transient 1Implicit 0 id : 0rec : 0 id : 1rec : 1 id : 2rec : 2 id : 3rec : 3ξ1:0 = 0ξ2:1 ≥ 0ξ2:2 ≥ 0ξ2:3 ≥ 0Transient 0Explicit 0Implicit 1Compositional Veriﬁcation of Smart Contracts

17

user under interference. Our key insight is that the reachable control states of
the local bundle form an inductive invariant θC. If the local bundle is safe, then
the interference relation is applied after each transition, and, therefore, the local
bundle considers every pair of control and user states (c, u) such that c ∈ θC
and (c, u) ∈ θU . Therefore, the safety of the local bundle implies Initialization,
Consecution, and Non-Interference. This discussion justiﬁes Theorem 2.

Theorem 2. Let C be a contract, G be a PTG for C, θU be a candidate split
interference invariant with role guards AR and literal guards AL, A be a sat-
urating neighbourhood for (AR, AL, G), a ∈ N\A, and A+ = {a} ∪ A. Then,
local(C, A+, θU ) |= θU if and only if θU is an interference invariant for C.

Next, we present our main result: a sound proof rule for k-universal safety. As
in Theorem 2, Theorem 3 uses a saturating neighbourhood A+. This proof rule
proves inductiveness, rather than compositionality, so A+ does not require an ar-
bitrary user under interference. However, a k-universal property can distinguish
between k users at once. Thus, A+ must have at least k arbitrary representatives.

Theorem 3. Let ϕ be a k-universal safety property with role guards AR and
literal guards AL, C be a contract, θU be an interference invariant for C, G be
a PTG for C, A = AExp ∪ ATrans ∪ AImpl be a saturating neighbourhood for
(AR, AL, G). Deﬁne A+ ⊆ N such that A ⊆ A+ and |A+| = |A| + max(0, k −
|AExp|). If local(C, A+, θU ) |= ϕ, then ∀N ∈ N · lts(C, N ) |= ϕ.

Theorem 3 completes Ex. 2. Recall (ϕ1, θ1, A1) from Ex. 3. Since ϕ1 is 1-
universal and A1 has one explicit representative, it follows that A+ = A1 ∪ ∅.
Using an SMC, local(C, A+
1 , θ1) |= ϕ1 is certiﬁed by an inductive strengthening
1. Then by Theorem 3, C is also safe for 2160 users. Both the local and global
θ∗
bundle have states exponential in the number of users. However, the local bundle
has 4 users (a constant ﬁxed by C), whereas the global bundle is deﬁned for any
number of users. This achieves an exponential state reduction with respect to
the network size. Even more remarkably, θ∗
1 must be the inductive invariant from
Sec. 2, as it summarizes the safe control states that are closed under the inter-
ference of θ1. Therefore, we have achieved an exponential speedup in veriﬁcation
and have automated the discovery of an inductive invariant.

6

Implementation and Evaluation

We implement smart contract PCMC as an open-source tool called SmartACE,
that is built upon the Solidity compiler. It works in the following automated
steps: (1) consume a Solidity smart contract and its interference invariants; (2)
validate the contract’s conformance to MiniSol; (3) perform source-code analysis
and transformation (i.e., inheritance inlining, devirtualization, PTGBuilder); (4)
generate a local bundle in LLVM IR; (5) verify the bundle using SeaHorn [15].
In this section, we report on the eﬀectiveness of SmartACE in verifying real-
world smart contracts. A full description of the SmartACE architecture and of

18

S. Wesley et al.

Contracts

SmartACE

VerX

Name

Prop. LOC

Time Inv. Size Users

Alchemist
ERC20
Melon
MRV
Overview
PolicyPal
Zebi
Zilliqa

Brickblock
Crowdsale
ICO
VUToken
Mana

Fund
Auction
QSPStaking

401
3
599
9
462
16
868
5
66
4
4
815
5 1,209
377
5

6
549
9 1,198
8
650
5 1,120
885
4

38
2
1
42
4 1,550

7
12
30
2
4
26
8
8

13
223
371
19
—

1
1
3

0
1
0
0
0
0
0
0

7
5
7
7
8
8
7
7

0
0
0
0

10
8
16
10
— —

0
1
7

6
5
8

Time

29
158
408
887
211
20,773
77
94

191
261
6,817
715
41,409

—
—
—

Table 1: Experimental results for SmartACE. All reported times are in seconds.

each case study is beyond the scope of this paper. Both SmartACE and the case
studies are available9. Our evaluation answers the following research questions:

RQ1: Compliance. Can MiniSol represent real-world smart contracts?
RQ2: Eﬀectiveness. Is SmartACE eﬀective for MiniSol smart contracts?
RQ3: Performance. Is SmartACE competitive with other techniques?

Benchmarks and Setup. To answer the above research questions, we used a
benchmark of 89 properties across 15 smart contracts (see Tab. 1). Contracts
Alchemist to Mana are from VerX [34]. Contracts Fund and Auction were added to
oﬀset the lack of parameterized properties in existing benchmarks. The QSPStaking
contract comprises the Quantstamp Assurance Protocol10 for which we checked
real-world properties provided by Quantstamp. Some properties require addi-
tional instrumentation techniques (i.e., temporal [34] and aggregate [17] prop-
erties). Aggregate properties allow SmartACE to reason about the sum of all
records within a mapping. In Tab. 1, Inv. Size is the clause size of an interference
invariant manually provided to SmartACE and Users is the maximum number
of users requested by PTGBuilder. All experiments were run on an Intel® Core
i7® CPU @ 2.8GHz 4-core machine with 16GB of RAM on Ubuntu 18.04.

RQ1: Compliance. To assess if the restrictions of MiniSol are reasonable, we ﬁnd
the number of compliant VerX benchmarks. We found that 8 out of 13 bench-

9 https://github.com/contract-ace
10 https://github.com/quantstamp/qsp-staking-protocol

Compositional Veriﬁcation of Smart Contracts

19

marks are compliant after removing dead code. With manual abstraction, 4 more
benchmarks complied. Brickblock uses inline assembly to revert transactions with
smart contract senders. We remove the assembly as an over-approximation. To
support Crowdsale, we manually resolve dynamic calls not supported by Smar-
tACE. In ICO, calls are made to arbitrary contracts (by address). However, these
calls adhere to eﬀectively external callback freedom [12,34] and can be omitted.
Also, ICO uses dynamic allocation, but the allocation is performed once. We in-
line the ﬁrst allocation, and assert that all other allocations are unreachable.
To support VUToken, we replace a dynamic array of bounded size with variables
corresponding to each element of the array. The function _calcTokenAmount iter-
ates over the array, so we specialize each call (i.e., _calcTokenAmount_{1,2,3,4}) to
eliminate recursion. Two other functions displayed unbounded behaviour (i.e.,
massTransfer and addManyToWhitelist), but are used to sequence calls to other
functions, and do not impact reachability. We conclude that the restrictions of
MiniSol are reasonable.

RQ2: Eﬀectiveness. To assess the eﬀectiveness of SmartACE, we determined
the number of properties veriﬁed from compliant VerX contracts. We found that
all properties could be veriﬁed, but also discovered that most properties were not
parameterized. To validate SmartACE with parameterized properties, we con-
ducted a second study using Auction, as described on our development blog11. To
validate SmartACE in the context of large-scale contract development, we per-
formed a third study using QSPStaking. In this study, 4 properties were selected
at random, from a speciﬁcation provided by Quantstamp, and validated. It re-
quired 2 person days to model the environment, and 1 person day to discover an
interference invariant. The major overhead in modeling the environment came
from manual abstraction of unbounded arrays. The discovery of an interference
invariant and array abstractions were semi-automatic, and aided by counterex-
amples from SeaHorn. For example, one invariant used in our abstraction says
that all elements in the array powersOf100 must be non-zero. This invariant was
derived from a counterexample in which 0 was read spuriously from powersOf100,
resulting in a division-by-zero error. We conclude that SmartACE is suitable
for high-assurance contracts, and with proper automation, can be integrated into
contract development.

RQ3: Performance. To evaluate the performance of SmartACE, we compared
its veriﬁcation time to the reported time of VerX, a state-of-the-art, semi-
automated veriﬁcation tool. Note that in VerX, predicate abstractions must be
provided manually, whereas SmartACE automates this step. VerX was eval-
uated on a faster processor (3.4GHz) with more RAM (64GB)12. In each case,
SmartACE signiﬁcantly outperformed VerX, achieving a speedup of at least
10x for all but 2 contracts13. One advantage of SmartACE is that it beneﬁts

11 http://seahorn.github.io/blog/
12 We have requested access to VerX and are awaiting a response.
13 We compare the average time for VerX to the total evaluation time for SmartACE.

20

S. Wesley et al.

from state-of-the art software model checkers, whereas the design of VerX re-
quires implementing a new veriﬁcation tool. In addition, we suspect that local
bundle abstractions obtained through smart contract PCMC are easier to reason
about than the global arrays that VerX must quantify over. However, a com-
plete explanation for the performance improvements of SmartACE is challeng-
ing without access to the source code of VerX. We observe that one bottleneck
for SmartACE is the number of users (which extends the state space). A more
precise PTGBuilder would reduce the number of users. Upon manual inspection
of Melon and Alchemist (in a single bundle), we found that user state could be
reduced by 28%. We conclude that SmartACE can scale.

7 Related Work

In recent years, the program analysis community has developed many tools for
smart contract analysis. These tool range from dynamic analysis [19,42] to static
analysis [27,30,26,39,13,32,25,40,5] and veriﬁcation [21,17,41,29,34,38]. The lat-
ter are most related to SmartACE since their focus is on functional correctness,
as opposed to generic rules (e.g., the absence of reentrancy [14] and integer over-
ﬂows). Existing techniques for functional correctness are either deductive, and re-
quire that most invariants be provided manually (i.e., [17,41]), or are automated
but neglect the parameterized nature of smart contracts (i.e., [28,29,34,38]). The
tools that do acknowledge parameterization employ static analysis [25,5]. In con-
trast, SmartACE uses a novel local reasoning technique that veriﬁes parame-
terized safety properties with less human guidance than deductive techniques.

More generally, parameterized systems form a rich ﬁeld of research, as out-
lined in [4]. The use of SCUNs was ﬁrst proposed in [11], and many other mod-
els exist for both synchronous and asynchronous systems (e.g., [9,36,37]). The
approach of PCMC is not the only compositional solution for parameterized
veriﬁcation. For instance, environmental abstraction [6] considers a process and
its environment, similar to the inductive and interference invariants of Smar-
tACE. Other approaches [35,10] generalize from small instances through the use
of ranking functions. The combination of abstract domains and SMPs has also
proven useful in ﬁnding parameterized invariants [2]. The addresses used in our
analysis are similar to the scalarsets of [18]. Most compositional techniques re-
quire cutoﬀ analysis—considering network instances up to a given size [7,20,22].
Local bundles avoid explicit cutoﬀ analysis by simulating all smaller instances,
and is similar to existing work on bounded parameterized model checking [8].
SmartACE is the ﬁrst application of PCMC in the context of smart contracts.

8 Conclusions

In this paper, we present a new veriﬁcation approach for Solidity smart contracts.
Unlike many of the existing approaches, we automatically reason about smart
contracts relative to all of their clients and accross multiple transaction. Our

Compositional Veriﬁcation of Smart Contracts

21

approach is based on treating smart contracts as a parameterized system and
using Parameterized Compositional Model Checking (PCMC).

Our main theoretical contribution is to show that PCMC oﬀers an expo-
nential reduction for k-universal safety veriﬁcation of smart contracts. That is,
veriﬁcation of safety properties with k arbitrary clients.

The theoretical results of this paper are implemented in an automated So-
lidity veriﬁcation tool SmartACE. SmartACE is built upon a novel model
for smart contracts, in which users are processes and communication is explicit.
In this model, communication is over-approximated by static analysis, and the
results are suﬃcient to ﬁnd all local neighbourhoods, as required by PCMC.
The underlying parameterized veriﬁcation task is reduced to sequential Soft-
ware Model Checking. In SmartACE, we use the SeaHorn veriﬁcation frame-
work for the underlying analysis. However, other Software Model Checkers can
potentially be used as well.

Our approach is almost completely automated – SmartACE automatically
infers the necessary predicates, inductive invariants, and transaction summaries.
The only requirement from the user is to provide an occasional interference
invariant (that is validated by SmartACE). However, we believe that this step
can be automated as well through reduction to satisﬁability of Constrained Horn
Clauses. We leave exploring this to future work.

References

1. Abdulla, P.A., Haziza, F., Hol´ık, L.: All for the price of few. In: Giacobazzi, R.,
Berdine, J., Mastroeni, I. (eds.) Veriﬁcation, Model Checking, and Abstract In-
terpretation, 14th International Conference, VMCAI 2013, Rome, Italy, January
20-22, 2013. Proceedings. Lecture Notes in Computer Science, vol. 7737, pp. 476–
495. Springer (2013). https://doi.org/10.1007/978-3-642-35873-9 28

2. Abdulla, P.A., Haziza, F., Hol´ık, L.: Parameterized veriﬁcation through view
Int. J. Softw. Tools Technol. Transf. 18(5), 495–516 (2016).

abstraction.
https://doi.org/10.1007/s10009-015-0406-x

3. Allen, F.E.: Control ﬂow analysis. In: Proceedings of a Symposium on Compiler
Optimization. pp. 1–19. Association for Computing Machinery, New York, NY,
USA (1970). https://doi.org/10.1145/800028.808479, https://doi.org/10.1145/
800028.808479

4. Bloem, R., Jacobs, S., Khalimov, A., Konnov, I., Rubin, S., Veith, H., Widder,
J.: Decidability in parameterized veriﬁcation. SIGACT News 47(2), 53–64 (2016).
https://doi.org/10.1145/2951860.2951873

5. Brent, L., Grech, N., Lagouvardos, S., Scholz, B., Smaragdakis, Y.: Ethain-
ter: a smart contract security analyzer for composite vulnerabilities. In: Don-
aldson, A.F., Torlak, E. (eds.) Proceedings of the 41st ACM SIGPLAN In-
ternational Conference on Programming Language Design and Implementa-
tion, PLDI 2020, London, UK, June 15-20, 2020. pp. 454–469. ACM (2020).
https://doi.org/10.1145/3385412.3385990

6. Clarke, E.M., Talupur, M., Veith, H.: Environment abstraction for param-
eterized veriﬁcation. In: Emerson, E.A., Namjoshi, K.S. (eds.) Veriﬁcation,
Model Checking, and Abstract Interpretation, 7th International Conference,

22

S. Wesley et al.

VMCAI 2006, Charleston, SC, USA, January 8-10, 2006, Proceedings. Lec-
ture Notes in Computer Science, vol. 3855, pp. 126–141. Springer (2006).
https://doi.org/10.1007/11609773 9

7. Emerson, E.A., Namjoshi, K.S.: On reasoning about rings. Int. J. Found. Comput.

Sci. 14(4), 527–550 (2003). https://doi.org/10.1142/S0129054103001881

8. Emerson, E.A., Treﬂer, R.J., Wahl, T.: Reducing model checking of the few to the
one. In: Liu, Z., He, J. (eds.) Formal Methods and Software Engineering, 8th Inter-
national Conference on Formal Engineering Methods, ICFEM 2006, Macao, China,
November 1-3, 2006, Proceedings. Lecture Notes in Computer Science, vol. 4260,
pp. 94–113. Springer (2006). https://doi.org/10.1007/11901433 6

9. Esparza, J., Ganty, P., Majumdar, R.: Parameterized veriﬁcation of asynchronous
shared-memory systems. In: Sharygina, N., Veith, H. (eds.) Computer Aided Veri-
ﬁcation - 25th International Conference, CAV 2013, Saint Petersburg, Russia, July
13-19, 2013. Proceedings. Lecture Notes in Computer Science, vol. 8044, pp. 124–
140. Springer (2013). https://doi.org/10.1007/978-3-642-39799-8 8

10. Fang, Y., Piterman, N., Pnueli, A., Zuck, L.D.: Liveness with invisible ranking. In:
Steﬀen, B., Levi, G. (eds.) Veriﬁcation, Model Checking, and Abstract Interpre-
tation, 5th International Conference, VMCAI 2004, Venice, Italy, January 11-13,
2004, Proceedings. Lecture Notes in Computer Science, vol. 2937, pp. 223–238.
Springer (2004). https://doi.org/10.1007/978-3-540-24622-0 19

11. German, S.M., Sistla, A.P.: Reasoning about systems with many processes. J. ACM

39(3), 675–735 (1992). https://doi.org/10.1145/146637.146681

12. Gershuni, E., Amit, N., Gurﬁnkel, A., Narodytska, N., Navas, J.A., Rinetzky, N.,
Ryzhyk, L., Sagiv, M.: Simple and precise static analysis of untrusted linux kernel
extensions. In: McKinley, K.S., Fisher, K. (eds.) Proceedings of the 40th ACM
SIGPLAN Conference on Programming Language Design and Implementation,
PLDI 2019, Phoenix, AZ, USA, June 22-26, 2019. pp. 1069–1084. ACM (2019).
https://doi.org/10.1145/3314221.3314590

13. Grech, N., Kong, M., Jurisevic, A., Brent, L., Scholz, B., Smaragdakis, Y.: Mad-
max: surviving out-of-gas conditions in ethereum smart contracts. Proc. ACM Pro-
gram. Lang. 2(OOPSLA), 116:1–116:27 (2018). https://doi.org/10.1145/3276486
14. Grossman, S., Abraham, I., Golan-Gueta, G., Michalevsky, Y., Rinetzky, N., Sagiv,
M., Zohar, Y.: Online detection of eﬀectively callback free objects with applica-
tions to smart contracts. Proc. ACM Program. Lang. 2(POPL), 48:1–48:28 (2018).
https://doi.org/10.1145/3158136

15. Gurﬁnkel, A., Kahsai, T., Komuravelli, A., Navas, J.A.: The seahorn veriﬁcation
framework. In: Kroening, D., Pasareanu, C.S. (eds.) Computer Aided Veriﬁcation
- 27th International Conference, CAV 2015, San Francisco, CA, USA, July 18-
24, 2015, Proceedings, Part I. Lecture Notes in Computer Science, vol. 9206, pp.
343–361. Springer (2015). https://doi.org/10.1007/978-3-319-21690-4 20

16. Gurﬁnkel, A., Shoham, S., Meshman, Y.: Smt-based veriﬁcation of parameterized
systems. In: Zimmermann, T., Cleland-Huang, J., Su, Z. (eds.) Proceedings of
the 24th ACM SIGSOFT International Symposium on Foundations of Software
Engineering, FSE 2016, Seattle, WA, USA, November 13-18, 2016. pp. 338–348.
ACM (2016). https://doi.org/10.1145/2950290.2950330

17. Hajdu, ´A., Jovanovic, D.: solc-verify: A modular veriﬁer for solidity smart con-
tracts. In: Chakraborty, S., Navas, J.A. (eds.) Veriﬁed Software. Theories, Tools,
and Experiments - 11th International Conference, VSTTE 2019, New York City,
NY, USA, July 13-14, 2019, Revised Selected Papers. Lecture Notes in Computer
Science, vol. 12031, pp. 161–179. Springer (2019). https://doi.org/10.1007/978-3-
030-41600-3 11

Compositional Veriﬁcation of Smart Contracts

23

18. Ip, C.N., Dill, D.L.: Better veriﬁcation through symmetry. In: Agnew, D., Claesen,
L.J.M., Camposano, R. (eds.) Computer Hardware Description Languages and
their Applications, Proceedings of the 11th IFIP WG10.2 International Conference
on Computer Hardware Description Languages and their Applications - CHDL ’93,
sponsored by IFIP WG10.2 and in cooperation with IEEE COMPSOC, Ottawa,
Ontario, Canada, 26-28 April, 1993. IFIP Transactions, vol. A-32, pp. 97–111.
North-Holland (1993)

19. Jiang, B., Liu, Y., Chan, W.K.: Contractfuzzer: fuzzing smart contracts for vulner-
ability detection. In: Huchard, M., K¨astner, C., Fraser, G. (eds.) Proceedings of the
33rd ACM/IEEE International Conference on Automated Software Engineering,
ASE 2018, Montpellier, France, September 3-7, 2018. pp. 259–269. ACM (2018).
https://doi.org/10.1145/3238147.3238177

20. Kaiser, A., Kroening, D., Wahl, T.: Dynamic cutoﬀ detection in parameterized
concurrent programs. In: Touili, T., Cook, B., Jackson, P.B. (eds.) Computer Aided
Veriﬁcation, 22nd International Conference, CAV 2010, Edinburgh, UK, July 15-
19, 2010. Proceedings. Lecture Notes in Computer Science, vol. 6174, pp. 645–659.
Springer (2010). https://doi.org/10.1007/978-3-642-14295-6 55

21. Kalra, S., Goel, S., Dhawan, M., Sharma, S.: ZEUS: analyzing safety of smart
contracts. In: 25th Annual Network and Distributed System Security Symposium,
NDSS 2018, San Diego, California, USA, February 18-21, 2018. The Internet So-
ciety (2018)

22. Khalimov, A., Jacobs, S., Bloem, R.: Towards eﬃcient parameterized synthesis. In:
Giacobazzi, R., Berdine, J., Mastroeni, I. (eds.) Veriﬁcation, Model Checking, and
Abstract Interpretation, 14th International Conference, VMCAI 2013, Rome, Italy,
January 20-22, 2013. Proceedings. Lecture Notes in Computer Science, vol. 7737,
pp. 108–127. Springer (2013). https://doi.org/10.1007/978-3-642-35873-9 9

23. Kildall, G.A.: A uniﬁed approach to global program optimization. In: Fischer, P.C.,
Ullman, J.D. (eds.) Conference Record of the ACM Symposium on Principles of
Programming Languages, Boston, Massachusetts, USA, October 1973. pp. 194–
206. ACM Press (1973). https://doi.org/10.1145/512927.512945

24. Kolb, J.: A Languge-Based Approach to Smart Contract Engineering. Ph.D. thesis,

University of California at Berkeley, USA (2020)

25. Kolluri, A., Nikolic, I., Sergey, I., Hobor, A., Saxena, P.: Exploiting the laws of
order in smart contracts. In: Zhang, D., Møller, A. (eds.) Proceedings of the
28th ACM SIGSOFT International Symposium on Software Testing and Anal-
ysis, ISSTA 2019, Beijing, China, July 15-19, 2019. pp. 363–373. ACM (2019).
https://doi.org/10.1145/3293882.3330560

26. Krupp, J., Rossow, C.: teether: Gnawing at ethereum to automatically exploit
smart contracts. In: Enck, W., Felt, A.P. (eds.) 27th USENIX Security Symposium,
USENIX Security 2018, Baltimore, MD, USA, August 15-17, 2018. pp. 1317–1333.
USENIX Association (2018)

27. Luu, L., Chu, D., Olickel, H., Saxena, P., Hobor, A.: Making smart contracts
smarter. In: Weippl, E.R., Katzenbeisser, S., Kruegel, C., Myers, A.C., Halevi, S.
(eds.) Proceedings of the 2016 ACM SIGSAC Conference on Computer and Com-
munications Security, Vienna, Austria, October 24-28, 2016. pp. 254–269. ACM
(2016). https://doi.org/10.1145/2976749.2978309

28. Marescotti, M., Otoni, R., Alt, L., Eugster, P., Hyv¨arinen, A.E.J., Sharygina, N.:
Accurate smart contract veriﬁcation through direct modelling. In: Margaria, T.,
Steﬀen, B. (eds.) Leveraging Applications of Formal Methods, Veriﬁcation and Val-
idation: Applications - 9th International Symposium on Leveraging Applications of

24

S. Wesley et al.

Formal Methods, ISoLA 2020, Rhodes, Greece, October 20-30, 2020, Proceedings,
Part III. Lecture Notes in Computer Science, vol. 12478, pp. 178–194. Springer
(2020). https://doi.org/10.1007/978-3-030-61467-6 12

29. Mavridou, A., Laszka, A., Stachtiari, E., Dubey, A.: Verisolid: Correct-by-design
smart contracts for ethereum. In: Goldberg, I., Moore, T. (eds.) Financial Cryp-
tography and Data Security - 23rd International Conference, FC 2019, Frigate
Bay, St. Kitts and Nevis, February 18-22, 2019, Revised Selected Papers. Lec-
ture Notes in Computer Science, vol. 11598, pp. 446–465. Springer (2019).
https://doi.org/10.1007/978-3-030-32101-7 27

30. Mossberg, M., Manzano, F., Hennenfent, E., Groce, A., Grieco, G., Feist, J., Brun-
son, T., Dinaburg, A.: Manticore: A user-friendly symbolic execution framework
for binaries and smart contracts. In: 34th IEEE/ACM International Conference on
Automated Software Engineering, ASE 2019, San Diego, CA, USA, November 11-
15, 2019. pp. 1186–1189. IEEE (2019). https://doi.org/10.1109/ASE.2019.00133

31. Namjoshi, K.S., Treﬂer, R.J.: Parameterized compositional model checking. In:
Chechik, M., Raskin, J. (eds.) Tools and Algorithms for the Construction
and Analysis of Systems - 22nd International Conference, TACAS 2016, Held
as Part of the European Joint Conferences on Theory and Practice of Soft-
ware, ETAPS 2016, Eindhoven, The Netherlands, April 2-8, 2016, Proceedings.
Lecture Notes in Computer Science, vol. 9636, pp. 589–606. Springer (2016).
https://doi.org/10.1007/978-3-662-49674-9 39

32. Nikolic, I., Kolluri, A., Sergey, I., Saxena, P., Hobor, A.: Finding the greedy, prodi-
gal, and suicidal contracts at scale. In: Proceedings of the 34th Annual Computer
Security Applications Conference, ACSAC 2018, San Juan, PR, USA, December
03-07, 2018. pp. 653–663. ACM (2018). https://doi.org/10.1145/3274694.3274743
33. Owicki, S.S., Gries, D.: An axiomatic proof technique for parallel programs I. Acta

Informatica 6, 319–340 (1976). https://doi.org/10.1007/BF00268134

34. Permenev, A., Dimitrov, D., Tsankov, P., Drachsler-Cohen, D., Vechev, M.T.: Verx:
Safety veriﬁcation of smart contracts. In: 2020 IEEE Symposium on Security and
Privacy, SP 2020, San Francisco, CA, USA, May 18-21, 2020. pp. 1661–1677. IEEE
(2020). https://doi.org/10.1109/SP40000.2020.00024

35. Pnueli, A., Ruah, S., Zuck, L.D.: Automatic deductive veriﬁcation with invisible
invariants. In: Margaria, T., Yi, W. (eds.) Tools and Algorithms for the Construc-
tion and Analysis of Systems, 7th International Conference, TACAS 2001 Held
as Part of the Joint European Conferences on Theory and Practice of Software,
ETAPS 2001 Genova, Italy, April 2-6, 2001, Proceedings. Lecture Notes in Com-
puter Science, vol. 2031, pp. 82–97. Springer (2001). https://doi.org/10.1007/3-
540-45319-9 7

36. Siegel, S.F., Avrunin, G.S.: Veriﬁcation of mpi-based software for scientiﬁc com-
putation. In: Graf, S., Mounier, L. (eds.) Model Checking Software, 11th In-
ternational SPIN Workshop, Barcelona, Spain, April 1-3, 2004, Proceedings.
Lecture Notes in Computer Science, vol. 2989, pp. 286–303. Springer (2004).
https://doi.org/10.1007/978-3-540-24732-6 20

37. Siegel, S.F., Gopalakrishnan, G.: Formal analysis of message passing - (invited
talk). In: Jhala, R., Schmidt, D.A. (eds.) Veriﬁcation, Model Checking, and Ab-
stract Interpretation - 12th International Conference, VMCAI 2011, Austin, TX,
USA, January 23-25, 2011. Proceedings. Lecture Notes in Computer Science,
vol. 6538, pp. 2–18. Springer (2011). https://doi.org/10.1007/978-3-642-18275-4 2
38. So, S., Lee, M., Park, J., Lee, H., Oh, H.: VERISMART: A highly precise safety
veriﬁer for ethereum smart contracts. In: 2020 IEEE Symposium on Security and

Compositional Veriﬁcation of Smart Contracts

25

Privacy, SP 2020, San Francisco, CA, USA, May 18-21, 2020. pp. 1678–1694. IEEE
(2020). https://doi.org/10.1109/SP40000.2020.00032

39. Tsankov, P., Dan, A.M., Drachsler-Cohen, D., Gervais, A., B¨unzli, F.,
Vechev, M.T.: Securify: Practical security analysis of smart contracts.
In:
Lie, D., Mannan, M., Backes, M., Wang, X. (eds.) Proceedings of the 2018
ACM SIGSAC Conference on Computer and Communications Security, CCS
2018, Toronto, ON, Canada, October 15-19, 2018. pp. 67–82. ACM (2018).
https://doi.org/10.1145/3243734.3243780

40. Wang, S., Zhang, C., Su, Z.: Detecting nondeterministic payment bugs in ethereum
smart contracts. Proc. ACM Program. Lang. 3(OOPSLA), 189:1–189:29 (2019).
https://doi.org/10.1145/3360615

41. Wang, Y., Lahiri, S.K., Chen, S., Pan, R., Dillig, I., Born, C., Naseer, I., Ferles, K.:
Formal veriﬁcation of workﬂow policies for smart contracts in Azure blockchain.
In: VSTTE. LNCS, vol. 12031, pp. 87–106. Springer (2019)

42. W¨ustholz, V., Christakis, M.: Harvey: a greybox fuzzer for smart contracts. In: De-
vanbu, P., Cohen, M.B., Zimmermann, T. (eds.) ESEC/FSE ’20: 28th ACM Joint
European Software Engineering Conference and Symposium on the Foundations of
Software Engineering, Virtual Event, USA, November 8-13, 2020. pp. 1398–1409.
ACM (2020). https://doi.org/10.1145/3368089.3417064

43. Zhong, J.E., Cheang, K., Qadeer, S., Grieskamp, W., Blackshear, S., Park,
J., Zohar, Y., Barrett, C.W., Dill, D.L.: The move prover. In: Lahiri, S.K.,
Wang, C. (eds.) Computer Aided Veriﬁcation - 32nd International Conference,
CAV 2020, Los Angeles, CA, USA, July 21-24, 2020, Proceedings, Part I. Lec-
ture Notes in Computer Science, vol. 12224, pp. 137–150. Springer (2020).
https://doi.org/10.1007/978-3-030-53288-8 7

26

S. Wesley et al.

A The Auction LTS

In this section we formally deﬁne the bundle of C := Auction, from Fig. 1. We
no longer assume that C consists of a single transaction. This means that each
input must also specify the name of the function to execute. In the case of C,
the function name are deﬁned by Tx := {constructor, bid, withdraw, stop}.

The control states are control(C, A) ⊆ (A) × (D × D) × (D), where A is the
address space. For each state (a1, d1, d2, aux1) ∈ control(C, A), a1, d1, and d2
correspond to the manager, leadingBid, and stopped, respectively. An auxiliary
variable, aux1, is added to indicate whether the constructor has been called.
When aux1 is 0, then the constructor has not been called and must be called in
the next transaction. When aux1 is 1, then the constructor has been called, and
may not be called again. For simplicity, data(s, 2) = aux1.

The user states are user(C, A) ⊆ A×(D). For each user (x, y1) ∈ control(C, A),

x is the user’s address and y1 is the user’s bid.

The inputs are action(C, A) ⊆ Tx×(A×A)×(D). For any p = (t, x1, x2, y1) ∈
action(C, A), the interpretation of p depends on t. In all cases, x1 is msg.sender.
If t = constructor, then x2 represents mgr. If t = bid, then y1 represents amount.
In all other cases, x2 and y1 are unused.

For the rest of this section, we restrict our discussion to lts(C, N ). This means
that A = [N ], and that M is the identify function for [N ]. We now present
transactional semantics for f =
M. We assume that N ≥ 2, so that the
zero-account and smart contract account are deﬁned.

C

(cid:75)

(cid:74)

f ((s, u), (t, x1, x2, y1)) =






(s, u)
(s, u)
g1((s, u), (x1, x2))
g2((s, u), (x1, y1))
g3((s, u), (x1))
g4((s, u), (x1))

if x1 = id(u0)
if x1 = id(u1)
if t = constructor
if t = bid
if t = withdraw
if t = stop

g1((s, u), (x1, x2)) =

g2((s, u), (x1, y1)) =

(s, u)
(s(cid:48), u)

(s, u)
(s, u)
(s, u)
(s, u)
(s, u(cid:48))










if data(s, 2) (cid:54)= 0
else, s.t. role(s(cid:48), 0) = x2, data(s(cid:48), 0) = data(s, 0),
data(s(cid:48), 1) = data(s, 1), and data(s(cid:48), 2) = 1

if data(s, 2) (cid:54)= 1
if role(s, 0) = x1
if data(s, 0) ≥ y1
if data(s, 1) = 1
else, s.t. ∀i ∈ [N ] · id(u(cid:48)
map(u(cid:48)

i) = id(ui) ∧ i (cid:54)= x1 ⇒

i) = data(ui) ∧ i = x1 ⇒ map(u(cid:48)

i) = (y1)

Compositional Veriﬁcation of Smart Contracts

27

g3((s, u), (x1)) =

g4((s, u), (x1)) =










(s, u)
(s, u)
(s, u)
(s, u(cid:48))

if data(s, 2) (cid:54)= 1
if role(s, 0) = x1
if data(s, 0) (cid:54)= map(ux1)0
else, s.t. ∀i ∈ [N ] · id(u(cid:48)
map(u(cid:48)

i) = data(ui) ∧ i = x1 ⇒ map(u(cid:48)

i) = id(ui) ∧ i (cid:54)= x1 ⇒
i) = 0

(s, u)
(s, u)
(s(cid:48), u)

if data(s, 2) (cid:54)= 1
if role(s, 0) (cid:54)= x1
else, s.t. role(s(cid:48), 0) = role(s, 0),
data(s(cid:48), 0) = data(s, 0), data(s(cid:48), 1) = 1, and
data(s(cid:48), 2) = data(s, 2)

Recall from Sec. 3 that a reverted transaction (such as a failed require state-
ment) is treated as a no-op. In f , these no-ops correspond to the cases that send
(s, u) to (s, u). Most of these cases, such as the second case of g2, are derived
directly from the source code (line 10 for this case). However, the ﬁrst two cases
for f , along with the ﬁrst case for each gi, are special.

The ﬁrst case for f guards against transactions sent from the zero-account.
An important observation is that the sender, x1, is compared to id(u0), rather
than 0. This is because M is used to map all literal addresses to users. For the
ﬁrst case of f , M ﬁrst maps 0 to u0, and then id(u0) maps u0 back to 014. Note
that the second case of f is similar to the ﬁrst case, in that the second case
guards against transactions from the smart contract account.

The ﬁrst case of g1 guards against calls to constructor after the constructor
has already the called. Similarly, the ﬁrst case of g2, g3, and g4, each guard
against calls to non-constructor functions before the constructor has been called.
These cases ensure that the contract is constructed once and only once.

B MiniSol: Syntax and Semantics

MiniSol is an extension of MicroSol that provides more communication prim-
itives. Speciﬁcally, MiniSol introduces: transactions with multiple calls; a cur-
rency called Ether ; a built-in time primitive. The grammar for MiniSol is pre-
sented in Fig. 6. As in MicroSol, the address type in MiniSol is non-arithmetic,
and mappings must relate addresses to integers. Note, however, that MiniSol
does allow for multi-dimensional mappings. Throughout the section, we illus-
trate MiniSol using the MiniSol program in Fig. 7.

In MiniSol, a transaction consists of one or more user calls. As in MicroSol,
the ﬁrst call is performed by a user that is neither the zero-account nor a smart
contract account. Each subsequent call is made by the account of the smart
contract currently executing a functions (e.g., line 48 in Fig. 7). As in most
object-oriented languages, each function has a visibility modiﬁer (see (cid:104)Vis(cid:105) in

14 This indirection allows for users to be readdressed in Def. 1

28

S. Wesley et al.

(cid:104)FName(cid:105) ::= a valid function name

(cid:104)VName(cid:105) ::= a valid variable name

(cid:104)CName(cid:105) ::= a valid contract name

(cid:104)Literal(cid:105) ::= an integer, Boolean, or address literal

(cid:104)SimpleType(cid:105) ::= mapping( address => (cid:104)SimpleType(cid:105) ) | int | uint | bool

(cid:104)ComplexType(cid:105) ::= (cid:104)SimpleType(cid:105) | address | (cid:104)CName(cid:105)

(cid:104)Global(cid:105) ::= block.number | block.timestamp | tx.origin | msg.sender | msg.value

(cid:104)Operator(cid:105) ::= == | != | < | > | + | - | * | / | && | || | !

(cid:104)Expr(cid:105) ::= (cid:104)Literal(cid:105) | (cid:104)VName(cid:105) | (cid:104)Global(cid:105) | (cid:104)Expr(cid:105) (cid:104)Operator(cid:105) (cid:104)Expr(cid:105)

| this | (cid:104)Expr(cid:105).(cid:104)FName(cid:105).value( (cid:104)Expr(cid:105) ) ( (cid:104)Expr(cid:105), . . . )

| (cid:104)FName(cid:105) ( (cid:104)Expr(cid:105), . . . ) | address( (cid:104)VName(cid:105) )

| (cid:104)Expr(cid:105).balance | (cid:104)Expr(cid:105) [ (cid:104)Expr(cid:105) ] . . . [ (cid:104)Expr(cid:105) ]

(cid:104)Decl(cid:105) ::= (cid:104)ComplexType(cid:105) (cid:104)VName(cid:105)

(cid:104)Assign(cid:105) ::= (cid:104)VName(cid:105) = (cid:104)Expr(cid:105) | (cid:104)Expr(cid:105) = new (cid:104)CName(cid:105)( (cid:104)Expr(cid:105), . . . )

| (cid:104)Expr(cid:105) [ (cid:104)Expr(cid:105) ] . . . [ (cid:104)Expr(cid:105) ] = (cid:104)Expr(cid:105)

(cid:104)Stmt(cid:105) ::= (cid:104)Decl(cid:105) | (cid:104)Assign(cid:105) | require( (cid:104)Expr(cid:105) ) | assert( (cid:104)Expr(cid:105) ) | return

| return (cid:104)Expr(cid:105) | if( (cid:104)Expr(cid:105) ) { (cid:104)Stmt(cid:105) } | while( (cid:104)Expr(cid:105) ) { (cid:104)Stmt(cid:105) }

| (cid:104)Stmt(cid:105); (cid:104)Stmt(cid:105) | (cid:104)Expr(cid:105).transfer( (cid:104)Expr(cid:105) )

(cid:104)Payable(cid:105) ::= payable | (cid:15)

(cid:104)Vis(cid:105) ::= public | internal

(cid:104)RetVal(cid:105) ::= returns ( (cid:104)SimpleType(cid:105) ) | (cid:15)

(cid:104)Ctor(cid:105) ::= constructor ( (cid:104)Decl(cid:105), . . . ) public (cid:104)Payable(cid:105) { (cid:104)Stmt(cid:105) }

(cid:104)Func(cid:105) ::= function (cid:104)FName(cid:105) ( (cid:104)Decl(cid:105), . . . ) (cid:104)Vis(cid:105) (cid:104)Payable(cid:105) (cid:104)RetVal(cid:105) { (cid:104)Stmt(cid:105) }

(cid:104)Contract(cid:105) ::= contract (cid:104)CName(cid:105) { (cid:104)Decl(cid:105); . . . ; (cid:104)Ctor(cid:105) (cid:104)Func(cid:105) . . . }

(cid:104)Bundle(cid:105) ::= (cid:104)Contract(cid:105) (cid:104)Contract(cid:105) . . .

Fig. 6: The formal grammar of the MiniSol language.

mapping ( address => uint ) _funds ;

function () public payable {

function _buy () internal {

_funds [ msg . sender ] += msg . value ;

function withdraw ( address dst ) public {

uint amt = _balances [ msg . sender ];
assert ( amt <= balance ( this )) ;

_balances [ msg . sender ] = 0;
( dst ) . transfer ( amt ) ;

}

}

_buy () ;

1 contract Fund {
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19 }
20
21 contract FundManager {
22
23
24
25

Fund _fund ;

}

mapping ( address => bool ) _owners ;
uint _end ;

address _dst ;

constructor ( uint dur , address dst ) public {

_end = block . timestamp + dur ;
_dst = dst ;
_fund = new Fund () ;
_owners [ msg . sender ] = true ;

}

function add ( address user ) public {

require ( _owners [ msg . sender ]) ;
_owners [ user ] = true ;

}

function buy () public payable {
require ( _owners [ msg . sender ]) ;
require ( block . timestamp < _end );
fund . transfer ( msg . value );

}

function withdraw () public {

require ( block . timestamp >= _end );
_fund . withdraw . value (0) ( _dst );

}

26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50 }

Fig. 7: A MiniSol program that allows a FundManager to raise funds inside a Fund.
The funds are forwarded to a predetermined destination after a duration.

Fig. 6). Functions with a public visibility can be called by users (e.g., line 12 in
Fig. 7), whereas functions with an internal visibility can only be executed as part

Compositional Veriﬁcation of Smart Contracts

29

Expression

Interpretation

role(s, i)
data(s, 0)
data(s, 1)
data(s, 2 + i)

id(ui)
map(ui)0
map(ui)1+j

client(p, 0)
client(p, 1)
client(p, 2 + i)
arg(p, 0)
arg(p, 1 + i)

The value of the i-th address-typed state variable.
The current value of block.number.
The current value of block.timestamp.
The value of the i-th numeric-typed state variable.

The address of the i-th user.
The balance of the i-th user.
The j-th mapping value of the i-th user.

The value of tx.origin.
The value of msg.sender.
The value of the i-th address-typed input variable.
The value of msg.value.
The value of the i-th numeric-typed input variable.

Table 2: The interpretation of a control state s, a user conﬁguration u, and an
action p in MiniSol.

of an ongoing call (e.g., the function at line 8 called at line 5 in Fig. 7). In either
case, the inputs tx.origin and msg.sender expose the addresses of the ﬁrst and
most recent user to call a function during the current transaction, respectively.

A currency called Ether is integrated into the MiniSol language. Each user
has a balance of Ether, that is exposed through the built-in balance function
(e.g., line 14 in Fig. 7). A user that is neither the zero-account nor a smart
contract account can spontaneously acquire Ether through minting. A smart
contract account can receive Ether through a function marked payable (e.g.,
line 4 in Fig. 7). The amount of Ether sent to a payable function is accessible
through the msg.value input (e.g., line 9 in Fig. 7). There are two ways that one
smart contract can send Ether to another smart contract. If a function is called
by name, then the .value modiﬁer is used (e.g., line 48 in Fig. 7). Otherwise, a
built-in transfer function (e.g., line 43 in Fig. 7) can be used to call a special
unnamed function, called a fallback function (e.g., line 4 in Fig. 7).

MiniSol also exposes a built-in time primitive to each function. In MiniSol,
time is measured with respect to the number of transactions that have been ex-
ecuted. Transactions are executed in batches, known as blocks. The block.number
input exposes the number of blocks executed so far. The block.timestamp input
exposes the real-world time at which the last block was executed (e.g., line 42
in Fig. 7). MiniSol enforces that block.timestamp is non-decreasing.

The semantics of a MiniSol program are similar to those of a MicroSol pro-

gram. For a MiniSol program C with transaction tr , the transition function
M
is still determined by the (usual) semantics of the single transaction tr . However,
the state space and actions of each MiniSol program also include information
about the ﬁrst caller of each transaction, Ether, and time. The changes are
outlined in Tab. 2.

C

(cid:74)

(cid:75)

30

S. Wesley et al.

C Uniformity and Participation

In this section we show that MicroSol (and MiniSol) satisfy the uniformity as-
sumptions of PCMC given in Sec. 2 (i.e., there are ﬁnitely many ﬁnite neigh-
bourhoods). First, we show that if the set of implicit users is ﬁnite, then each
transaction of the network is performed against a neighbourhood of bounded
size. Second, we show that the users within the given neighbourhood are in-
terchangeable (up to address). Finally, we show that if all transactions can be
reduced to a ﬁnite set of addresses. From these results, it follows that all MicroSol
transactions are uniform.

C.1 Reduction to a Bounded Neighbourhood

Let C be a contract. This section proves that if a PT over-approximation for C
is ﬁnite, then every transaction of C can be computed by projecting the network
onto a neighbourhood of bounded size. To do this, a precise deﬁnition must
ﬁrst be given of an over-approximation and a projection. The notion of over-
approximation generalizes a PTG from Sec. 4.

Deﬁnition 9 (PT Over-Approximation). For N ∈ N and p ∈ action(C, [N ]),
the tuple (E, T, I) ⊆ N×N×N over-approximates the PT, pt(C, N, p) = (Explicit,
Transient, Implicit), when {i | Explicit(i, x)} ⊆ E, {i | Transient(i, x)} ⊆ T ,
and Implicit ⊆ I. Furthermore, (E, T, I) is a PT over-approximation of C when
(E, T, I) over-approximates all PT’s of C.

Note that when a PT Over-Approximation is ﬁnite, the over-approximation
corresponds to a PTGBuilder PTG. This is because each label in a PTGBuilder
PTG corresponds to precisely one user, with a speciﬁc address. Therefore, the
users that appear in a PT over-approximate also over-approximate the local
neighbourhood of a transaction.

Deﬁnition 10 (View). Let (E, T, I) be a PT over-approximation of C, s ∈
control(C, [N ]), and p ∈ action(C, [N ]). The (E, T, I)-view for s and p is:

view(E, T, I, s, p) := {client(p, i) | i ∈ E} ∪ {role(s, i) | i ∈ T } ∪ I

In Sec. 5.2 we use sets of addresses to represent local neighbourhoods. In-
tuitively, each address corresponds to the user (or a representative of the user)
with the given address. In other words, the users in a bundle are projected onto
the neighbourhood, as deﬁned below in Def. 11.

Deﬁnition 11 (Projection). Let A2 ⊆ A1 ⊆ N, N = |A1|, M = |A2|,
and u ∈ user(C, A1)N . Then v ∈ user(C, A2)M is a projection of u onto A2,
written v = πA2(u), if there exists a total, injective, order-preserving mapping,
σ[M ] → [N ] such that A2 = {id(vi) | i ∈ [M ]} and ∀i ∈ [M ] · vi = uσ(i).

Compositional Veriﬁcation of Smart Contracts

31

Notice that as σ in Def. 11 is order-preserving, each projection is unique (with
respect to A). This means that projections can be compared directly. The fol-
lowing theorem shows that each transaction can be reduced to a neighbourhood
projection of ﬁnitely many clients.

Theorem 4. Let (E, T, I) be a PT over-approximation of C with N0 = |E| +
|T | + |I| ﬁnite. Then for all N ≥ N0 with (S, P, f, s0) = lts(C, N ), and for
all (s, u) ∈ S, p ∈ P , if (s(cid:48), u(cid:48)) = f (s, u, p) and A = view(E, T, I, s, p), then
i and (s(cid:48), πA(u(cid:48))) =
∀i ∈ [N ] · id(ui) (cid:54)∈ A ⇒ ui = u(cid:48)

tr

N0 (s(cid:48), πA(u), p).
(cid:75)

(cid:74)

Proof. Theorem 4 draws two conclusions. (1) The ﬁrst conclusion claims that
∀i ∈ [N ] · id(ui) (cid:54)∈ A ⇒ ui = u(cid:48)
i. When id(ui) ∈ A, this holds trivially. Assume
that id(ui) (cid:54)∈ A. Then ui is not a participant. Then fp has no inﬂuence on
ui. By deﬁnition, ui = u(cid:48)
i, as desired. (2) The second conclusion claims that
(s(cid:48), πA(u(cid:48))) =
N0 (s(cid:48), πA(u), p). By construction, all participants of fp are in
(cid:75)
A. Then πA(u) contains all clients which inﬂuence fp, while πA(u(cid:48)) contains all
clients which are inﬂuenced by fp. In addition,
is the semantic interpretation
of tr . The source text of tr is deﬁned independent from the size of the network,
therefore
N0 must perform the same sequence of synchronized and
(cid:75)
(cid:117)(cid:116)
internal actions against the same set of clients.

N and

tr
(cid:74)

tr

tr

tr

(cid:75)

(cid:74)

(cid:75)

(cid:74)

(cid:74)

C.2 The Interchangeability of Users

Let C be a contract. This section shows that arbitrary users in C are interchange-
able. We rely on the MicroSol restriction that address values are not numeric.

To discuss the interchangeability of users, we require a notion of swapping
users. Let A be an address space, u, u(cid:48) ∈ user(C, A)N , and ﬁx x, y ∈ A. Then
u(cid:48) is an (x, y) address swap of u, written swap(u, x, y), if ∀i ∈ [N ]: (1) id(ui) =
i) = x; (2) id(ui) = x ⇒ id(u(cid:48)
y ⇒ id(u(cid:48)
i = ui;
(4) map(u(cid:48)
i) = map(ui). A similar notion is deﬁned for the roles of a control
process. Speciﬁcally, let s, s(cid:48) ∈ control(C, A). Then, s(cid:48) is an (x, y) address swap
of s, if ∀i ∈ [N ]: (1) role(s, i) = y ⇒ role(s(cid:48), i) = x; (2) role(s, i) = x ⇒
role(s(cid:48), i) = y; (3) role(s, i) (cid:54)∈ {x, y} ⇒ role(s(cid:48), i) = role(s, i). The extensions to
action(C, A) and control(C, A) × user(C, A)N are trivial.

i) = y; (3) id(ui) (cid:54)∈ {x, y} ⇒ u(cid:48)

Lemma 1. Let C be a contract, N ∈ N, (S, P, f, s0) = lts(C, N ), p ∈ P , and
pt(C, N, p) = (Explicit, Transient, Implicit). For every s, t ∈ S and every x, y ∈
N \ Implicit, f (swap(t, x, y), swap(p, x, y)) = swap(f (s, p), x, y).

Lemma 1 says that address swaps commute with MicroSol transactions. The
lemma follows directly from the semantics of MicroSol, since MicroSol restricts
address comparisons to (dis)equality.

Lemma 1 extends to address bijections. If A1, A2 (cid:40) N \ Implicit are ﬁnite,
transactions are also preserved under any address bijection σ : A1 → A2. Intu-
itively, σ is constructed using a sequence of swaps from A1 to A2. The deﬁnition
of σ is inductive, with respect to the size of A1.

32

S. Wesley et al.

Theorem 5. Let C be a contract, N ∈ N, (S, P, f, s0) = lts(C, N ), p ∈ P ,
pt(C, N, p) = (Explicit, Transient, Implicit), and A1, A2 ⊆ N \ Implicit be ﬁnite.
If σ : A1 → A2 is bijective, then fσ(p)(σ(s)) = σ−1(fp(s)).

Proof. This follows by induction over the size of A1. As σ is a correspondence,
then |A1| = |A2|. In the base case, |A1| = 1, A1 = {a1} and A2 = {a2} with a1 (cid:54)∈
Implicit and a2 (cid:54)∈ Implicit. Then σ(s) = σ−1(s) = swap(s, a1, a2) and σ(p) =
σ−1(p) = swap(p, a1, a2). Now assume that the inductive argument holds up to
k ≥ 1, and that |A1| = k + 1. Then ﬁx some a1 ∈ A1, and let A(cid:48)
1 = A1 \ {a} and
A(cid:48)
2, as deﬁned by τ (x) = σ(x) is also a cor-
respondence. Then σ(s) = swap(τ (s), a, σ(a)), σ−1(s) = swap(τ −1(s), a, σ(a)),
σ(p) = swap(τ (p), a, σ(a)), and σ−1(p) = swap(τ −1(p), a, σ(a)). By the induc-
tive hypothesis, τ and τ −1 are also reducible to sequences of swaps.
(cid:117)(cid:116)

2 = A1 \ {σ(a)}. Clearly τ : A(cid:48)

1 → A(cid:48)

C.3 Reduction to a Finite Address Set

Let C be an contract. This section proves that if the assumptions of Theorem 4
holds for C, then by the results of Theorem 5, the state space of each neighbour-
hood can be reduced to a ﬁnite state space. Recall that all non-address state is
already over a ﬁnite domain.

Theorem 6. Let (E, T, I) over-approximate PT’s of C with N0 = |E| + |T | + |I|
ﬁnite an let I ⊆ A0 ⊆ A∗ ⊆ N with |A0| = N0. Then for all s ∈ control(C, A∗),
and for all p ∈ action(C, A∗), with A = view(E, T, I, s, p), there exists a corre-
spondence σ : (A \ I) → (A0 \ I) such that fp(s, u) = σ−1(fσ(p)(σ(s), σ(u))).

Proof. This proof follows in two parts. First, it is shown that σ exists. This
follows quite trivial. By construction, |A| = N0, |A0| = N0, I ⊆ A, and I ⊆ A0,
therefore |A\I| = |A0\I|. Then a correspondence σ : A → A0 can be constructed
arbitrarily. As σ does not map to or from I, Theorem 5 applies to σ. As I is
ﬁnite, Theorem 4 also applies. The conclusion of Theorem 6 follows as a direct
(cid:117)(cid:116)
consequence.

From Theorem 6, every MicroSol transaction can be simulated using a ﬁ-
nite address space. By Theorem 5, this simulation also preserves k-universal
safety properties. This means that there are ﬁnitely many distinguishable neigh-
bourhoods, and that these neighbourhoods are subsumed by A. Therefore, all
MicroSol transactions are uniform, as desired.

