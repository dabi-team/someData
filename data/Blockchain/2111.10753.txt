1
2
0
2

v
o
N
1
2

]

R
C
.
s
c
[

1
v
3
5
7
0
1
.
1
1
1
2
:
v
i
X
r
a

Secure Linear Aggregation Using Decentralized
Threshold Additive Homomorphic Encryption
For Federated Learning

Haibo Tian1, Fangguo Zhang1, Yunfeng Shao2, and Bingshuai Li2 (cid:63)

1 Sun Yat-Sen University
2 Huawei Noah’s Ark Lab

Abstract. Secure linear aggregation is to linearly aggregate private in-
puts of diﬀerent users with privacy protection. The server in a federated
learning (FL) environment can fulﬁll any linear computation on private
inputs of users through the secure linear aggregation. At present, based
on pseudo-random number generator and one-time padding technique,
one can eﬃciently compute the sum of user inputs in FL, but linear
calculations of user inputs are not well supported. Based on decentral-
ized threshold additive homomorphic encryption (DTAHE) schemes, this
paper provides a secure linear aggregation protocol, which allows the
server to multiply the user inputs by any coeﬃcients and to sum them
together, so that the server can build a full connected layer or a convo-
lution layer on top of user inputs. The protocol adopts the framework
of Bonawitz et al. to provide fault tolerance for user dropping out, and
exploits a blockchain smart contract to encourage the server honest. The
paper gives a security model, security proofs and a concrete lattice based
DTAHE scheme for the protocol. It evaluates the communication and
computation costs of known DTAHE construction methods. The evalu-
ation shows that an elliptic curve based DTAHE is friendly to users and
the lattice based version leads to a light computation on the server.

Keywords: Privacy Protection, Secure Linear Aggregation, Additive Homo-
morphic Encryption, Smart Contract.

1

Introduction

Federated learning (FL) is intended to train better machine learning models
on decentralized real-world data. The models then could be used to build more
intelligent equipments for people, such as cars, wearable devices or browsers.
McMahan et al. [1] proposed a well known FL protocol. The players in their

(cid:63) Dr. Tian and Prof. Zhang were with the GuangDong Province Key Laboratory
of Information Security Technology, School of Data and Computer Science, Sun
Yat-Sen University, Guangzhou, Guangdong, 510275, P. R. China e-mail: {tianhb,
isszhfg}@mail.sysu.edu.cn. Dr. Shao and Dr. Li were with Huawei Noah’s Ark Lab.
e-mail: {shaoyunfeng, libingshuai}@huawei.com.

 
 
 
 
 
 
2

Haibo Tian, Fangguo Zhang, Yunfeng Shao, and Bingshuai Li

protocol include users who owned data and a parameter server that aggregates
model information of users. The protocol runs periodically. In each period, the
parameter server randomly selects some users to upload their local model pa-
rameters, and averages the parameters to update a global learning model. A
user in a period downloads the global learning model, feeds their local data,
runs a deep learning network locally and gets updated local model parameters,
the information of which is sent to the parameter server. In diﬀerent periods the
server may select diﬀerent users, and within a period some of the selected users
may drop out.

As real-world data are usually sensitive, an important problem in FL is data
privacy. Although user data are not directly sent to the parameter server in FL,
information of local model parameters may leak the raw data of users. Fredrikson
et al. [2] show how to recover train samples from prediction results of a model.
Rubaie and Chang [3] exploit feature vectors to reconstruct raw input data of a
model. Chai et al. [4] show how to recover preferences of users by model gradient
data. Bonawitz et al. [5] believe that recent updated local model parameters of
a user may leak raw data of the user.

There are mainly two approaches to solve the data privacy problem in FL.
One uses diﬀerential privacy and the other uses cryptographic tools. The work
of Martin et al. [6] is an earlier report of the diﬀerential privacy approach. Wei
et al. [7] point out a tradeoﬀ between the convergence performance and privacy
protection levels of the diﬀerential privacy method. For a ﬁxed privacy protec-
tion level, the number of users increases, the convergence performance behaves
better. However, if the number of users in each period is limited, one may use
the cryptographic tools based approach. Bonawitz et al. [5] propose an elegant
solution based on one-time padding and a secure pseudorandom generator.

To the best of our knowledge, the solution of Bonawitz et al. [5] is the only
work suitable for the FL using cryptographic tools. They take the data privacy
problem in FL as an secure aggregation problem. And they show some new
requirements of a secure aggregation protocol for the FL. Except a security
requirement, other requirements are as follow:

1. The protocol should operates on a high-dimensional vectors;
2. The protocol should tolerate users dropping out;
3. The protocol should be communication eﬃcient even with a new set of uses

on each period.

With these requirements, Bonawitz et al. [5] show that previous works are unsat-
isfactory which include some works based on homomorphic encryption schemes.
In detail, they believe that solutions based on Paillier scheme [8–11] are either
computationally expensive or require additional trusted dealer, and solutions
based on ElGamal scheme [12–15] need a high expansion factor considering the
size of the group elements and that of the model parameters.

Considering the development of the communication technology, we believe
that a moderate expansion factor is acceptable and the functionality of a protocol
is more important. Liu et al. [16] proposed a federated forest where a parameter
server should ﬁnd the maximal value of user inputs. Zhuo et al. [17] proposed a

Title Suppressed Due to Excessive Length

3

federated deep reinforcement learning model where a parameter server needs to
build a multi-layer perception on user inputs. The users in these scenarios are
usually not mobile users so that the communication cost is not the dominate
factor. However, to protect the privacy of users, a sum only secure aggregation
is not enough.

We provide a secure linear aggregation protocol to enrich the parameter
server. It could naturally be used in the federated averaging algorithm [1] in the
same way as the secure sum aggregation [5]. It also could be used in [17] to build
a linear multi-layer perception to get a reinforcement learning model. It may be
adapted in [16] with the homomorphic encryption [18] to ﬁnd the maximal value
of user inputs. For simplicity, the solution here is only based on decentralized
threshold additive homomorphic encryption (DTAHE) schemes.

Currently, there are three known methods to construct a DTAHE scheme.
The ﬁrst method is to distribute many secret shares to a user. Bendlin and
Damg˚ard [19] proposed a threshold homomorphic encryption scheme in this
way. It relies on secret sharing schemes with general access structure. Boneh et
al. [20] proposed such a scheme based on secret sharing schemes constructed
by a monotone formulae. The second method is to use a large modulus for
coeﬃcients of an element in a polynomial ring. Boneh et al. [20] propose to use
Shamir secret sharing scheme in this way. The last method is to use the ElGamal
encryption as a basic building tool [21]. We exclude the Paillier encryption based
construction method since it is hard to produce a shared key pair in a distributed
manner without a trusted dealer. According to our evaluation, in the secure
linear aggregation protocol, the communication overhead of the ﬁrst method
is too high and the computation overhead of the third method is a bit high.
The second method also has a drawback since a large modulus means a higher
polynomial degree when the noise bound is ﬁxed [22]. So we provide a new
method to construct a DTAHE scheme with security proofs. It does not increase
the modulus size and polynomial degree.

The secure linear aggregation protocol is against an active adversary [5]. An
active adversary could corrupt a parameter server and ask t users to decrypt a
cipher of a target user. It is not easy to defend against the attack. Note that
Bonawitz et al. [5] add a consistency check round to solve a similar problem
in their protocol. However, even we add such a round, the problem still exists
since the target user may have dropped out before the consistency check round.
To solve the problem, we introduce a blockchain system. We design a smart
contract to record ciphers of users and to check the evaluation process of the
parameter server. If the parameter server deviates its expected behaviours in
a period, the parameter server could be punished and the users in that period
could get compensation.

There exists a lot of works to introduce a blockchain into the FL. A top com-
plained problem in FL is the incentive of users to participate a learning process.
Researchers propose blockchain enabled models [23–27] to give rewards to data
owners. Basically, model initializer proposes model parameters and rewards in
the blockchain, data owners choose their interested model to download the cur-

4

Haibo Tian, Fangguo Zhang, Yunfeng Shao, and Bingshuai Li

rent model parameters, to train an updated model by their local private inputs
and to update information of model parameters to the blockchain, and miners
of the blockchain aggregate inputs of users to get a new global model parameter
and rewards relevant users. Pokhrel and Choi [28] and Kim et al. [29] show some
theoretical results about the performance of blockchain enabled FL considering
the delays in a blockchain. A simulation result in [30] shows that the FL without
a blockchain is most eﬃcient. Another motivation to introduce a blockchain sys-
tem to the FL is about the trustiness of a learning model. Sarpatwar et al. [31]
propose to model and capture provenance of an overall learning process for veri-
ﬁcation. Awan et al. [32] propose to record data produced in a learning task in a
blockchain for veriﬁcation. We use a blockchain as a trusted third party to verify
the behaviours of the parameter server. Since a veriﬁcation process usually could
be separated from a learning process, the FL and the blockchain could work at
their own paces.

In summary, our contributions are as follows.

– We give a deﬁnition of DTAHE for FL and provide a basic linear aggregation
protocol based on the deﬁnition. The basic protocol supports a parameter
server to linearly operate ciphers of model parameters from diﬀerent users.
– We provide a secure linear aggregation protocol against an active adversary
with security model and proofs. It shows how to use a blockchain smart
contract to help a secure linear aggregation protocol.

– We provides a new method to construct a lattice based instance of the
DTAHE scheme with security proofs. Evaluations show that the DTAHE
scheme leads to a lightweight computation on the server side.

2 Preliminaries

2.1 Basic Notations

For any set X, we denote by |X| the number of elements of the set X. If x is a
string, |x| denotes its bit length. And if x is a vector, |x| denotes the dimension
of the vector. x||y denotes the bit catenation of two strings x and y.

Let R = Z[x]/(f (x)) be a polynomial ring where f (x) is a monic irreducible
polynomial of degree d. Elements of the ring R is denoted by vectors. For (cid:126)a ∈ R,
the coeﬃcients of (cid:126)a is denoted by ai such that (cid:126)a = (cid:80)d−1
i=0 ai · xi. The inﬁnity
norm of ||(cid:126)a|| is deﬁned as maxi|ai| and the expansion factor of R is deﬁned as
δR = max{||(cid:126)a · (cid:126)b||/(||(cid:126)a|| · ||(cid:126)b||) : (cid:126)a,(cid:126)b ∈ R}.

Let h > 1 be an integer. Then Zh denotes a set of integers (− h

2 ]. The
symbol Z/qZ denotes a ring on integers {0, . . . , q − 1}. For x ∈ Z, [x]h denotes
the unique integer in Zh with [x]h = x mod h. For (cid:126)x ∈ R, [(cid:126)x]h denotes the
element in R obtained by applying [·]h to all its coeﬃcients. For x ∈ R, (cid:98)x(cid:101)
denotes rounding to the nearest integer and (cid:98)x(cid:99), (cid:100)x(cid:101) denote rounding up or
down.

2 , h

Let λ be an integer as the security parameter. A function negl(λ) is negligi-
ble in λ if negl(λ) = o(1/λc) for every c ∈ N. An event occurs with negligible

Title Suppressed Due to Excessive Length

5

probability if the probability of the event is negl(λ). An event occurs with over-
whelming probability if its complement occurs with negligible probability.

Given a probability distribution D, we use x ← D to denote that x is sampled
from D. For a set X, x ← X denotes that x is sampled uniformly from X. A
distribution χ over integers is called B-bounded if it is supported on [−B, B].

2.2 Federated Learning

McMahan et al. [1] described the FL framework. We give a brieﬂy review to see
their federated averaging algorithm. As shown in Fig. 1, there is a parameter
server S1 and many users. S1 exchanges model parameters with users to collab-
oratively build a better learning model. The federated averaging algorithm runs
periodically. In each period, S1 selects n users randomly. In Fig. 1, we intended
to show two periods with totally diﬀerent users. Next we focus on a period e
where users in a set Ue.

Fig. 1: The framework of FL

The FL in a period is as follows.

1. A user u ∈ Ue is activated to download the global parameters from the

parameter server.

2. The user u feeds their local data samples to get updated model parameters.
And the parameters or their gradients ωu with the number of local data
samples nu should be sent to S1.

3. The parameter server S1 compute the updated global model parameters

ω =

(cid:80)

1

u∈Ue

nu

(cid:80)

nuωu.

u∈Ue

The parameter server S1 continues to randomly activate a set of users in the next
period until the parameters ω converge to that of the global optimal learning
model.

Users could upload the nu together with ωu so that the server could get
the value (cid:80)
nu and compute the updated ω. So a sum only aggregation is
enough for the federated averaging algorithm. However, a parameter server may
execute more computations in other federated learning models [16, 17], where a
sum only aggregation is not enough.

u∈Ue

S1u1...unv1vn......Period eUsersModel ParametersPeriod fParameter Server6

Haibo Tian, Fangguo Zhang, Yunfeng Shao, and Bingshuai Li

2.3 The Model Of Secure Aggregation For FL

We adapt the notion of message-driven entities in [33] to the FL security model
[5] to describe the participants in a FL scenario. A message-driven entity is
initially invoked by an environment process. Each entity has their initial states.
Once invoked, an entity waits for an activation that can happen for a message
from the network or an environment process. On activation, the entity processes
the incoming message or the arguments from a process with its current internal
state, and generates a new internal state, outgoing messages and a cumulative
output. Once an activation is completed, the entity waits for the next activation
if it does not stop.

A protocol π consists of a server side progress πS and a client side progress
πu. An FL process in S1 invokes πS, which runs periodically until πS is stopped
by the FL process. In each period, πS randomly selects a set of users U and
activates their client side progresses. A user u should have voluntarily invoked
their πu before S1 activates them. On activation, πu exchanges messages with
πS until πS ﬁnishes a period or πu is stopped by the user. There may be some
auxiliary entities for the security of the protocol π. A common setup includes a
certiﬁcate authority (CA) [5]. A CA is invoked and runs permanently to receive
certiﬁcate requests from users and issue certiﬁcates to users. In our protocol,
we also introduce blockchain miners BM . Miners are invoked to receive trans-
actions from users and the server, and to execute smart contracts on commonly
consented transactions.

The server and each user have a bi-directional secure channel between them.
Practically, it reuses a transport layer secure channel established by FL processes.
Users do not have direct links in the protocol π. The communications of users
are transferred by the server. Users and the CA may exchange messages at an
initial stage. When the protocol π runs, the CA could be oﬄine. Blockchain
miners usually have a point-to-point (P2P) network to deliver transactions and
blocks. When a blockchain is used in π, FL entities should have the ability to
send and receive transactions to and from the P2P network.

An active adversary A could corrupt the server and users in π. For each
period, the number of corrupted parties is at most nc [5]. When A corrupts
an entity, it knows the internal states and long-term secrets of the entity, and
controls all the behaviours of the entity from that point. Obviously, the server
S1 could be corrupted to act as a malicious server. When A corrupts a user, it
could send transactions on behalf of the user.

We does not allow an adversary to corrupt CA or BM since we do not try
to model the security of a CA system or a blockchain system. We simply make
assumptions about them:

– A transaction from a user or the server will be executed and recorded cor-

rectly by blockchain miners within a bounded delay.

– A certiﬁcate from a CA proves the binding relation of a veriﬁcation key and

the real identity of a user.

We deﬁne GOπ,e,{S1}∪Ue,A((cid:126)x, (cid:126)r) as a global output for π in a period e where
(cid:126)x = {xS} ∪ {xu}u∈Ue denotes the inputs of the server S1 and the inputs of users

Title Suppressed Due to Excessive Length

7

in the set Ue of the period e, and (cid:126)r = {r0, rS} ∪ {ru}u∈Ue denotes the random
inputs of the adversary A, server S1 and users in Ue. Let

GOπ,e,{S1}∪Ue,A((cid:126)x)

be the random variable about GOπ,e,{S1}∪Ue,A((cid:126)x, (cid:126)r). The randomness comes
from the adversary A, server S1 and users in Ue.

We deﬁne the input privacy of a user [5] as follows.

Deﬁnition 1. (Input Privacy of a User). For any uncorrupted user u ∈ Ue in
a period e, the privacy of its input is assured if

GOπ,e,{S1}∪Ue,A((cid:126)x) ≈ GOπ,e,{S1}∪Ue,A((cid:126)x(cid:48))

where (cid:126)x(cid:48) = {xS} ∪ {xv}v∈Ue\{u} ∪ {0} and “≈” means computationally indistin-
guishable.

The security goal in [5] is input privacy of all uncorrupted users. Apparently,
if the privacy of all users are protected, the privacy of a user is protected. If the
privacy of each uncorrupted user in protected, the privacy of all uncorrupted
users are protected. So the two deﬁnitions are equivalent.

2.4 DTAHE

Boneh et al. [20] give a deﬁnition of decentralized threshold fully homomorphic
encryption (DTFHE). We reﬁne it as a DTAHE deﬁnition for the FL scenario.
A DTAHE scheme is a tuple of probabilistic polynomial time (PPT) algorithms
DT AHE = (Setup, KeyGen, Share, CombKey, Enc, Eval, P arDec, F inDec).

1. Setup(1λ) → parm: It takes as input a security parameter λ, outputs system

parameters parm.

2. KeyGen(parm) → (sku, pku): It takes as input the system parameter parm

to produce public and private keys for a user u.

3. Share(parm, {pkv}v∈U \{u}, t, sku) → {ev,u}v∈U \{u}: It takes as input the
system parameter parm, public keys of users in a set U excluding the user
u, a threshold value t and private keys sku of the user u, to produce encrypted
shares ev,u for each user v ∈ U \{u}.

4. CombKey(parm, {pku}u∈U ) → pk: It takes as input the system parameter
parm, public keys of a set of users in U , and produces an encryption key pk.
5. Enc(parm, pk, mu) → cu: It takes as input the system parameter parm, a
public key pk and a message mu from a user u, and produces a ciphertext
cu.

6. Eval(parm, {cu}u∈U , {αu}u∈U ) → ˆc: It takes as the system parameter parm,
ciphers {cu}u∈U and coeﬃcients {αu}u∈U , and produces an evaluated cipher
ˆc = (cid:80)

u∈U αu · cu.

7. P arDec(parm, ˆc, {eu,v}v∈U ) → ˆmu: It takes as input the system parameter
parm, the cipher ˆc, and a set of encrypted shares {eu,v}v∈U \{u} to the user
u, and produces a partially decrypted value ˆmu.

8

Haibo Tian, Fangguo Zhang, Yunfeng Shao, and Bingshuai Li

8. F inDec(parm, t, ˆc, { ˆmu}u∈V ) → m: It takes as input the system parameter
parm, the threshold value t, the cipher ˆc and partially decrypted ciphers
{ ˆmu}u∈V from users in a set V with |V | ≥ t, and produces a plaintext m.

One could simply give an ElGamal based DTAHE instance following the

constructions in [21], which justiﬁes the correctness of the DTAHE deﬁnition.

2.5 DTAHE Model

We adapt the model of DTFHE in [20] for the DTAHE. The ﬁrst deﬁnition is
evaluation correctness.

Deﬁnition 2. (Evaluation Correctness). A DTAHE scheme for a set of users
U satisﬁes evaluation correctness if for all λ and t, the following holds:

For an evaluated cipher

ˆc ← Eval(parm, {cu}u∈U , {αu}u∈U )

the probability



F inDec

(cid:32)

parm, t, ˆc,
{P arDec(parm, ˆc, {eu,v}v∈U )}u∈V

(cid:33)








P r






=

(cid:88)

u∈U

αu · mu

is overwhelming where

cu ← Enc(parm, pk, mu),

({ev,u}v∈U ) ← Share(parm, {pkv}v∈U \{u}, t, sku),

(sku, pku) ← KeyGen(parm),

pk ← CombKey(parm, {pku}u∈U ),

parm ← Setup(1λ).

and

The second deﬁnition is sematic security. It captures the privacy of messages.

Deﬁnition 3. (Sematic Security). We say that a DTAHE scheme for a user set
U satisﬁes sematic security if for all λ, the following holds:

For any PPT adversary A, the following experiments ExptA,Sem(1λ) outputs

1 with probability 1

2 + negl(λ):

– ExptA,Sem(1λ):

1. The adversary outputs U and V where |U | = n and |V | = t specify an

access structure.

Title Suppressed Due to Excessive Length

9

2. The challenger runs

parm ← Setup(1λ),

(sku, pku) ← KeyGen(parm),
(cid:32)

parm, {pkv}v∈U \{u},
t, sku

(cid:33)

,

{ev,u}v∈U \{u} ← Share

pk ← CombKey(parm, {pku}u∈U ),

and provides (parm, pk, {{ev,u}v∈U \{u}}u∈U ) to A.

3. A outputs a set S ⊆ U such that |S| < t. It submits message vectors

{mu,0, mu,1}u∈U and S to the challenger.

4. The challenger provides A the shares {{su,v}v∈U }u∈S and a cipher set

{cu ← Enc(parm, pk, mu,b)}u∈U , for b ∈ {0, 1}.

5. A outputs a guess bit b(cid:48). The experiment outputs 1 if b = b(cid:48).

The last deﬁnition is simulation security. It captures the privacy of shared

secrets and private keys of users.

Deﬁnition 4. (Simulation Security). A DTAHE scheme satisﬁes simulation se-
curity if for all λ, the following holds:

There is a stateful PPT algorithm C = (C1, C2) such that for any PPT ad-
versary A, the following experiments ExptA,Real(1λ) and ExptA,Ideal(1λ) are
indistinguishable:

– ExptA,Real(1λ):

1. The adversary outputs U and V where |U | = n and |V | = t specify an

access structure.
2. The challenger runs

parm ← Setup(1λ),

(sku, pku) ← KeyGen(parm),
(cid:32)

parm, {pkv}v∈U \{u},
t, sku

(cid:33)

,

({ev,u}v∈U ) ← Share

pk ← CombKey(parm, {pku}u∈U ),

and provides (parm, pk, {{ev,u}v∈U }u∈U ) to A.

3. A outputs a set S∗ ⊆ U with |S∗| = t − 1 and messages {mu}u∈U .
4. The challenger provides A the shares {{su,v}v∈U }u∈S∗ in {{eu,v}v∈U }u∈S∗

and a cipher set

{cu ← Enc(parm, pk, mu)}u∈U .

5. A issues a polynomial number of adaptive queries of the form (S ⊆
U, {cu}u∈U ∗ , {αu}u∈U ∗ ) where U ∗ ⊆ U . For each query, the challenger
computes ˆc ← Eval(parm, {cu}u∈U ∗ , {αu}u∈U ∗ ) and provides A

{ ˆmu ← P arDec(parm, ˆc, {eu,v}v∈U )}u∈S.

10

Haibo Tian, Fangguo Zhang, Yunfeng Shao, and Bingshuai Li

6. At the end of the experiment, A outputs a distinguishing bit b.

– ExptA,Ideal(1λ):

1. The adversary outputs U and V where |U | = n and |V | = t specify an

access structure.
2. The challenger runs

(parm, pk, {{ev,u}v∈U }u∈U , st) ← C1(1λ, U, t)

and provides (parm, pk, {{ev,u}v∈U }u∈U ) to A.

3. A outputs a set S∗ ⊆ U with |S∗| = t − 1 and messages {mu}u∈U .
4. The challenger provides A shares {{su,v}v∈U }u∈S∗ and ciphers

{cu ← Enc(parm, pk, mu)}u∈U .

5. A issues a polynomial number of adaptive queries of the form (S ⊆
U, {cu}u∈U ∗ , {αu}u∈U ∗ ) where U ∗ ⊆ U . For each query, the challenger
runs

{ ˆmu}u∈S ← C2

(cid:32)

S, {cu}u∈U ∗ , {αu}u∈U ∗ ,
{mu}u∈U , {cu}u∈U , st

(cid:33)

and provides { ˆmu}u∈S to A.

6. At the end of the experiment, A outputs a distinguishing bit b.

3 Secure Linear Aggregation Protocol

We provides two protocols in this section. The ﬁrst is a basic protocol showing
how to embed a DTAHE scheme to the secure aggregation framework in [5]. The
second is the secure linear aggregation protocol against an active adversary.

3.1 A Basic Protocol

As shown in Fig. 2, initially a server S1 runs parm ← Setup(1λ) to pro-
vide a system-wide parameters for all users, and each user runs (sku, pku) ←
KeyGen(parm) to produce their key pairs. The server and users then runs a
four-round protocol π with an agreed threshold value t. We next focus on a
period e to show the protocol.

1. Round 1 (AdvertiseKeys). When a user u is active, it packs a message as
mu,1 = (u, pku) and sends the message to the server S1. The user then waits
for the ﬁrst response from S1 or stops.
The server S1 makes a set U 1
(u, pku), it sets U 1
mS,1 = {mu,1}u∈U 1
e
as their responses.

e = ∅. After it receives a message mu,1 =
e = U 1
e | > t, S1 packs a message as
. The message mS,1 is broadcasted to all the users in U 1
e

e ∪ {u}. When |U 1

2. Round 2 (ShareKeys). When a user u receives mS,1, it makes a U 1

e set from
e | ≥ t. If the veriﬁcation passes, the user executes as

mS,1 and checks |U 1
follows:

Title Suppressed Due to Excessive Length

11

Fig. 2: Basic Aggregation Protocol from DTAHE

(a) It makes a public key set {pkv}v∈U 1

e \{u} from mS,1 and produce en-

crypted shares by

{ev,u}v∈U 1

e

← Share

(cid:32)parm, {pkv}v∈U 1
t, sku

e \{u},

(cid:33)

.

(b) It packs mu,2 = (u, {(v, ev,u)}v∈U 1

e \{u}) and sends the message to S1.

Then u waits for the second response or stops.

The server S1 builds a set U 2
When |U 2
user v ∈ U 2

e | > t, S1 packs a message mS,2,v = ({(u, ev,u)}u∈U 2
e , and sends them to the users in U 2
e .

e in the same way as U 1

e satisfying U 2

e ⊆ U 1
e .
e \{v}) for each

3. Round 3 (CipherCollection). When a user u receives a message mS,2,u, it

makes a set U 2

e from mS,2,u. If |U 2
– It runs pk ← CombKey(parm, {pku}u∈U 2
– It runs cu ← Enc(parm, pk, mu) to compute the cipher of its private

e | ≥ t, u executes as follows:

).

e

input mu.

– It packs a message mu,3 = (u, cu) and sends the message to S1. Then u

waits for the third response or stops.

The server S1 builds a set U 3
runs

e in the same way as U 1

e satisfying U 3

e ⊆ U 2

e . It

ˆc ← Eval(parm, {cu}u∈U 3

e

, {αu}u∈U 3

e

)

and sends mS,3 = ˆc to users in U 3
e .

4. Round 4 (Decryption). When a user u receives mS,3, it runs

ˆmu ← P arDec(parm, ˆc, {eu,v}v∈U 2

e

).

u then packs a message mu,4 = (u, ˆmu) and sends the message to the server
S1. The user u ﬁnishes the client protocol πu for the period e and stops.
The server S1 builds a set U 4
e ⊆ U 3
|U 4

e in the same way as U 1

e satisfying U 4

e . If

e | ≥ t, it runs

m ← F inDec(parm, ˆc, { ˆmu}u∈U 4

e

)

to get m as an aggregated value. The server ﬁnishes the server side protocol
πS for the period e and waits for the next period.

S1u1...unv1vn......Period eUsersPeriod fParameter Server1.AdvertiseKeys2.ShareKeys(Share)3.CipherCollection(CombKey, Enc, Eval)4.Decryption (ParDec, FinDec)(Setup)(KeyGen)12

Haibo Tian, Fangguo Zhang, Yunfeng Shao, and Bingshuai Li

Remark 1. The basic protocol uses the framework in [5] to tolerate user dropping
out. It needs the sever to be honest. A malicious server may simply return a
cipher cu as mS,3 to decrypt the cipher.

3.2 The Secure Linear Aggregation Protocol

Bonawitz et al. [5] use a certiﬁcate authority (CA) and an extra consistency
round to defend against an active adversary. We also use a CA but keep our
protocol four rounds. We introduce a smart contract in a blockchain to encourage
the server S1 and users to be honest.

The blockchain is described as (cid:126)σλt+1 = Υ ((cid:126)σλt, T x) [34] where Υ is a state
transition function, (cid:126)σλt is the system state in a block height λt, and T x is a
transaction in the system. A transaction could be described as

T x = (f rom, to, value, data, aux, sig)

where f rom and to ﬁelds are the sender and receiver accounts of the transaction,
value ﬁeld is the values to be transferred from the sender to the receiver, data
ﬁeld is arbitrary data of the sender, aux ﬁeld is the auxiliary information used
in the blockchain and sig ﬁeld is the sender’s signature. The instance of the
blockchain certainly could be the Ethereum [34]. Any other blockchain system
supporting state transition is ﬁne.

Initially, the server S1 has an account accS and a user u has an account accu
in the blockchain. The server should deploy a smart contract EncCheck on the
blockchain which will have an account accE after deployment.

Deﬁnition 5. (EncCheck). The smart contract includes three functions. A func-
tion Init is for the server S1 to deposit values and set parameters. A function
Record is for a user to record their encrypted inputs. A function Check is for
the server S1 and users to check the correctness of a protocol transcript.

– Init: If the transaction T x is signed by the server S1, the data ﬁeld of the
transaction includes “Init” as the function name, and a threshold value t and
the number of periods prds supported by the contract as the arguments, the
function checks a deposit variable Dep of the server S1. If Dep < M inV alue∗
prds, it checks that Dep + value ≥ M inV alue ∗ prds where M inV alue is the
smallest deposit value for a period. If the check fails, it stops. Otherwise, it
transfers values from the server account to the contract account, and stores
(accS, t, Dep, prds) in the contract.

– Record: If the data ﬁeld of the transaction includes “Record” as the function
name, and an epoch session id esidu and a cipher caccu as the arguments,
the function stores (esidu, accu, caccu ) in the contract.

– Check: If the transaction T x is singed by the server S1, the data ﬁeld of
the transaction includes “Check” as the function name, and a termination
ﬂag draw, an epoch session id esidS, a cipher cS, a list of user accounts
LA, and coeﬃcients {αaccu}accu∈LA as the arguments, the function checks
whether esidS is new. If the esidS is used before in another transaction T x(cid:48),

Title Suppressed Due to Excessive Length

13

it checks whether the two transactions are the same. If they are diﬀerent, the
check fails. If they are the same, the function stops. The function forms a
set

AA = {accu : accu ∈ LA ∧ esidu = esidS}.

If esidS is new, it checks that the size |AA| ≥ t, and

cS = Eval(parm, {caccu}accu∈AA , {αaccu }accu∈AA ).

If any check fails, the value M inV alue is shared by users in the AA set.
Otherwise, it updates prds = prds − 1, and if draw is true, it transfers
the deposit back to the account of the server after six new blocks. When the
deposit is cleared, the contract suicides.

Now the server S1 has two tasks to initialize the protocol. At ﬁrst, the server
S1 runs parm ← Setup(1λ) to provide system-wide parameters for all users.
Secondly, the server S1 produces a transaction as

T xS,1 = (accS, accE, value, Init||t||prds, aux, sig)

to initialize the deployed smart contract.

A user u has three tasks to participate in the protocol II. At ﬁrst, it runs
(sku, pku) ← KeyGen(parm) to produce protocol keys. Secondly, it produces a
transaction

T xu,1 = (accu, accu, 0, pku, aux, sig)

and sends the transaction to the blockchain to store its public keys. Thirdly,
the user u should produce a signature key pair (skSigu, vkSigu) ← SIG.Gen(1λ)
using a signature scheme (SIG.Gen, SIG.Sign, SIG.V er) that is existential un-
forgeable against adaptive chosen messages (EUF-CMA). And then u applies for
a certiﬁcate certu of the verifying key vkSigu from a CA.

The CA and miners are auxiliary entities in the protocol. A CA is used to
defend against a “Sybil” attack where an adversary may create many blockchain
accounts to act as users. The miners of a blockchain receive transactions, pack
them into blocks, reach a consensus on a block and update the global state.
The public keys of users, parameters of the server S1, and deposited values of
the server S1 are states of the blockchain maintained by the miners. The whole
picture of the protocol is in Fig. 3. We next focus on a period e to show the
protocol.

1. Round 1 (AdvertiseAccounts). When a user u is active, it looks up the de-
posit Dep, supported periods prds and the threshold t in the smart contract
account accE indexed by the server account accS. If Dep, t, or prds are too
small for the user’s local policy, the user simply stops. Otherwise, it produces
a signature

σu ← SIG.Sign(skSigu, accu||Tu)

where Tu is a time stamp of the user. It packs a message as mu,1 = (u, accu, Tu, σu, certu)
and sends the message to the server S1. The user u then waits for the ﬁrst
response from S1 or stops.

14

Haibo Tian, Fangguo Zhang, Yunfeng Shao, and Bingshuai Li

Fig. 3: The Secure Linear Aggregation Protocol

e

The server S1 builds a set U 1
as mS,1 = ({mu,1}u∈U 1
The message mS,1 is broadcasted to all the users in U 1

e as in the basic protocol. It then packs a message
, esid) where esid is a session number for the period.
e set as their response.
2. Round 2 (ShareKeys). When a user u receives mS,1, it parses mS,1 to extract
the identities of users which form a set U 1
e | ≥ t, and the
time stamps, signatures and certiﬁcates are correct. If the veriﬁcations pass,
u looks up the blockchain to ﬁnd public keys of users in U 1
e by their accounts
which form a set {pkv}v∈U 1
The server S1 executes in the same way as in the basic protocol to produce
mS,2,v for a user v.

e \{u}, and executes as in the basic protocol.

e . If checks that |U 1

3. Round 3 (CipherCollection). When a user u receives a message mS,2,u, it
e | ≥ t, it executes in the same way as in

makes a set U 2
the basic protocol to compute pk and cu. Then u creates a transaction

e from mS,2,u. If |U 2

T xu,2 = (accu, accE, 0, Record||esid||cu, aux, sig)

and sends the transaction to the blockchain. The user u then waits for a
response transaction of the server S1 from the blockchain network or stops.
The server S1 makes a set U 3
e = ∅. After it receives a transaction T xu,2,
if the transaction includes the same esid as the current session number, S1
sets U 3
e ∪ {u} where the identity u is indexed by the accu. It then runs

e = U 3

ˆc ← Eval(parm, {cu}u∈U 3

e

, {αu}u∈U 3

e

),

and packs a transaction

T xS,2 =

(cid:32)

accS, accE, 0, Check||f alse||
, aux, sig
esid||ˆc||{accu}u∈U 3

e

(cid:33)

and sends the transaction to the blockchain.

4. Round 4 (Decryption). When a user u receives T xS,2, it builds a U 3
e ⊆ U 2

e set
indexed by {accu}u∈U 3
e | ≥ t, and the esid ﬁeld is the
current session number, u then executes in the same way as in the basic
protocol to interact with the server S1.
The server S1 executes in the same way as in the basic protocol to get an
aggregated result.

e , |U 3

. If U 3

e

u1...unv1vn......S1BlockchainMinerMinerMinerCA1.AdvertiseAccounts2.ShareKeys4.Decryption3.CipherCollection3.CipherCollectionUsersPeriod ePeriod fTitle Suppressed Due to Excessive Length

15

When the FL process is to stop, S1 may send a T xS,2 with the true ter-
mination ﬂag. The EncCheck contract will delay the withdraw action until six
blocks are generated. This is intentionally for users to check the correctness of
the server. Before the deposit is given back to the server, a user could send T xS,2
received in an period to the contract. If there are diﬀerent T xS,2 transactions
with the same esid ﬁeld, the deposit will be shared by users in that period.

Remark 2. In a period, two transactions are transferred by the blockchain net-
work. Miners, the parameter server and users will receive transactions, parse
them, and process them independently.

3.3 Security Analysis

We prove the security of the secure linear aggregation protocol against an active
adversary. In a high level, we divide the global outputs into four views, and
analyze the advantages of the adversary as a new view appears.

Theorem 1. Suppose that a DTAHE scheme is sematic and simulation secure,
a signature scheme SIG is EUF-CMA secure, and the secret sharing scheme in
the DTAHE has a privacy property [20]. Let t be the threshold value, nc be the
maximal number of corrupted users in a period, and λm be the minimal number
of private inputs to make the ﬁnal aggregated value hide one input. For any
uncorrupted user u, against an adversary A, if λm ≥ t − nc and the deposit of
the server S1 in the smart contract EncCheck has not lost, the protocol satisﬁes
GOπ,e,{S1}∪Ue,A((cid:126)x) ≈ GOπ,e,{S1}∪Ue,A((cid:126)x(cid:48)).

Proof: A global output GOπ,e,{S1}∪Ue,A((cid:126)x) consists of four views {viewi}i∈{1,...4}.
The view1 includes the outputs of the initialization procedures and the ﬁrst
round of the server S1 and users. The views {view2, view3, view4} include the
outputs of their corresponding rounds. We consider two global outputs GO and
GO(cid:48) with inputs (cid:126)x and (cid:126)x(cid:48). Note that the only diﬀerence of the two inputs are
the inputs of the user u. We denote the four views of GO(cid:48) as {view(cid:48)

i}i∈{1,...4}.

– Initially, view1 and view(cid:48)

1 include the same certiﬁcates, public keys and

accounts in the initialization procedure of the protocol π.

– When π executes, view1 and view(cid:48)

1 include message-signature pairs of users
and the ﬁrst response of the server. view2 and view(cid:48)
2 include encrypted shares
and the second response of the server. Since private inputs of the user u are
not involved, the two global outputs are indistinguishable until now.

– The view3 and view(cid:48)
3 consist of two kinds of transactions, separately. Trans-
actions of users in U 3
. The transaction
e could form a ciphertext set {cu}u∈U 3
of the server S1 includes ˆc. In the view3, the ciphertext of the target user
u is cu ← Enc(parm, pk, mu), and the evaluated ciphertext of the server S1
3, the ciphertext of the
is ˆc ← Eval(parm, {cu}u∈U 3
target user u is cu ← Enc(parm, pk, 0), and the evaluated ciphertext of the
server is produced in the same way. Now the chances of A increases.

). In the view(cid:48)

, {αu}u∈U 3

e

e

e

16

Haibo Tian, Fangguo Zhang, Yunfeng Shao, and Bingshuai Li

• A could exploit the diﬀerences of the two views view3 and view(cid:48)

3. Since
the only diﬀerence is the message mu and the message 0, if the DTAHE
is sematic secure, A has only negligible advantages to distinguish the
two views.

• A could exploit the combined views of view3 ∪ view2 and view(cid:48)

3 ∪ view(cid:48)
2.
Suppose that A could get the shared secrets in view2 and view(cid:48)
2. Then
A could decrypt cu by the P arDec and F inDec algorithms. However,
since the DTAHE is simulation secure, the secret shares are protected
well. A has only negligible advantages to distinguish the two combined
views.

• A could exploit the combined views of view3 ∪view2 ∪view1 and view(cid:48)

3 ∪

2 ∪ view(cid:48)

1 in the two global outputs.

view(cid:48)
At ﬁrst, Suppose that A corrupts users in C ∗ and |C ∗| = nc. It then
knows secret keys {sku}u∈C∗ which could be used to decrypt ciphers
in view2. The decrypted shares may help A to decrypt cu. However,
since we assume nc < t and the secret sharing scheme has a privacy
property [20], this event happens negligibly.
Secondly, A may make special view1 and view(cid:48)
1. A could establish t
blockchain accounts and store public keys in each account. Then A acts
as users to cheat the target user u. However, since messages in view1 and
view(cid:48)
1 are signed by users who have certiﬁcates from a CA, the accounts
of A could not be identiﬁed by the user u. And since we explicitly include
a time stamp in the ﬁrst message of a user, A could not replay messages
of users in other periods. To satisfy the claims, the signature scheme
SIG should be EUF-CMA secure.

– view4 and view(cid:48)

4 consists of partially decrypted ciphers and the ﬁnal aggre-

gated value. A has more chances:

• A could exploit the partially decrypted ciphers to discover secret shares.
Since the DTAHE is simulation secure, A has only negligible advantages.
• A could exploit the ﬁnal aggregated value. An obvious strategy is that
in the transaction of the server T xS,2, only cu is included. To make the
strategy more practical, A may aggregate some ciphers of corrupted users
and the target user. Then the ﬁnal output is the sum of nc + 1 inputs.
The strategy is a possible way to get inputs of a user at the cost of the
deposit in the smart contract. Since T xS,2 comes from the blockchain
network, miners will execute the Check function in the EncCheck smart
contract. The function takes {accu}u∈U 3
as LA, and checks the correct-
ness of the evaluation of the server S1. The smart contract builds a
AA ⊆ LA and checks that |AA| ≥ t. So if nc + 1 < t, the check fails
and the server S1 will be punished. To avoid the punishment, A should
prepare a LA set with |LA| ≥ nc + λm ≥ t.
A may try to withdraw their deposit before the penalty is paid. However,
the smart contract needs extra six blocks to conﬁrm the request of the
server. The six-block waiting time is the last chance of users to check
the behaviours of the server. Users are encouraged to send the received

e

Title Suppressed Due to Excessive Length

17

transaction of the server to the blockchain since they are the possible
beneﬁciaries.

In summary, if the cryptographic primitives are secure, λm ≥ t − nc, and the
server pays no penalties, the adversary has only negligible advantage to distin-
guish the two outputs GO and GO(cid:48).

Remark 3. We explicitly introduce a parameter λm to describe the number of
private inputs of uncorrupted users in a period. The parameter is in fact used
in [5] implicitly. The consistency check round [5] makes sure that at least t
private inputs are summed. If nc inputs are known by an adversary A, then in
their protocol λm ≥ t − nc.

4 A DTAHE Instance

Since all known construction methods of DTAHE schemes have some weaknesses.
We provide a new construction method to produce a lattice based DTAHE
scheme for an interactive protocol.

4.1 The Instance

We use the BFV scheme [22,35] as a basic building block which is implemented in
the SEAL library [36]. We need a sematic secure hybrid encryption scheme [37]
HP KE = (HP KE.Gen, HP KE.Enc, HP KE.V er) to encrypt shares. A lattice
based HP KE instance will give us a fully lattice DHAHE instance that may be
post quantum secure. We also need the Shamir secret sharing scheme denoted
by SS = (SS.Split, SS.Recover).

1. Setup(1λ) → parm: It takes as input a security parameter λ, produces a
parameter set parm = (d, f (x), h, R, Rh, χ, µ, (cid:126)a, l, λ), where d is the degree
depending on λ of a cyclotomic polynomial f (x), h ≥ 2 is an integer depend-
ing on λ, R is a ring R = Z[x]/(f (x)), Rh is the set of polynomials in R with
coeﬃcients in Zh, χ here is in fact deﬁned as discrete Gaussian distribution,
µ is a uniform distribution, (cid:126)a is uniformly selected from Rh as (cid:126)a ← Rh, and
l is an integer depending on λ.

2. KeyGen(parm) → (sku, pku): It selects (cid:126)su ← R3 and samples (cid:126)eu ← χ.
It sets sku,0 = (cid:126)su and pku,0 = [−((cid:126)a · (cid:126)su + (cid:126)eu)]h. It runs (pku,1, sku,1) ←
HP KE.Gen(1λ). The output is sku = (sku,0, sku,1) and pku = (pku,0, pku,1).
3. Share(parm, {pkv}v∈U \{u}, t, sku) → {ev,u}v∈U \{u}: It samples (cid:126)eu,2 ← χ,
computes n = |{pkv}v∈U \{u}|+1, sets ssu = {sku,0, (cid:126)eu,2}, and for each coeﬃ-
cient ssu,i of the elements in ssu, computes {(cid:126)sv,u,i}v∈U ← SS.Split(ssu,i, n, t, h).
For all the shares to v ∈ U \{u}, it computes a cipher ev,u = HP KE.Enc(pkv,1, {(cid:126)sv,u,i}i∈|ssu|∗d).

4. CombKey(parm, {pku}u∈U ) → pk: It computes pk = [(cid:80)
5. Enc(parm, pk, mu) → cu: It selects (cid:126)uu ← R3, (cid:126)eu,0, (cid:126)eu,1 ← χ, computes
cu,0 = [(cid:126)a · (cid:126)uu + (cid:126)eu,0]h and cu,1 = [pk · (cid:126)uu + (cid:126)eu,1 + (cid:98)h/l(cid:99) · mu]h. It sets
cu = (cu,0, cu,1).

u∈U pku,0]h.

18

Haibo Tian, Fangguo Zhang, Yunfeng Shao, and Bingshuai Li

6. Eval(parm, {cu}u∈U , {αu}u∈U ) → ˆc: It computes ˆc0 = [(cid:80)

u∈U αucu,0]h, ˆc1 =

[(cid:80)

u∈U αucu,1]h and sets ˆc = (ˆc0, ˆc1).

7. P arDec(parm, ˆc, {eu,v}v∈U ) → ˆmu: It decrypts the shares for the user u ∈ U
from the user v ∈ U as (cid:126)su,v ← HP KC.Dec(sku,1, eu,v). It parses the shares
of coeﬃcients as shares of elements in R, sets ( (cid:126)seu,v, (cid:126)ssku,v) = (cid:126)su,v, then
computes ˆmu = [ˆc0 · (cid:80)

(cid:126)ssku,v + (cid:80)

v∈U (cid:126)seu,v]h.

8. F inDec(parm, t, ˆc, { ˆmu}u∈V ) → m: It recovers cs = [(cid:80)

u∈V liu ˆmu]h where
liu is the Lagrange coeﬃcient of the user u with respect to the user set V ,
and computes the ﬁnal output m = [(cid:98) l·[ˆc1+cs]h

v∈U

(cid:101)]l.

h

Remark 4. If the data dimension of the message mu is greater than d, the number
of noise samples (cid:126)eu,2 ∈ R increases.

4.2 Security Analysis

The security of our scheme could be reduced to a variant of the classical ring
version decisional learning with errors (RLWE) problem [22, 38]. The variant is
named n-Decision-RLWE problem.

Deﬁnition 6. (n-Decision-RLWE). For a random set {(cid:126)si ∈ Rh}i∈{1,...,n} and a
distribution χ over R, denote with A{(cid:126)si∈Rh}i∈{1,...,n},χ,µ the distribution by choos-
ing a uniformly random element (cid:126)a ← Rh and n noise term {(cid:126)ei ← χ}i∈{1,...,n}
and outputting ((cid:126)a, {[(cid:126)a · (cid:126)si + (cid:126)ei]h}i∈{1,...,n}). The problem is then to distinguish
between the distribution A{(cid:126)si∈Rh}i∈{1,...,n},χ,µ and a uniform distribution µ over
Rn+1
h

.

By a hybrid argument, one could conclude that if an adversary has an advan-
tage at least (cid:15)n-RLW E to solve the n-Decision-RLWE problem, the adversary has
an advantage at least 1
n (cid:15)n-RLW E to solve the classical RLWE problem in [22,38].

The ﬁrst proof is about the evaluation correctness in the deﬁnition 2.

Theorem 2. Assume that U is the user set, χ is B-bounded and the maximal
inﬁnity norm of elements in the set {αu}u∈U is A, the evaluation of the DTAHE
is correct with probability 1 if |U |B(1 + δRA(1 + 2δR|U |)) < h
2l .

Proof. Since

ˆmu = [ˆc0 ·

(cid:88)

v∈U

(cid:126)ssku,v +

(cid:88)

v∈U

(cid:126)seu,v]h,

Title Suppressed Due to Excessive Length

19

we have the equation (1) due to the Lagrange interpolation.

(cid:88)

cs = [

liu · (ˆc0 ·

u∈V
(cid:88)

= [

liu · (ˆc0 ·

(cid:126)seu,v)]h

(cid:126)ssku,v +

(cid:88)

v∈U

(cid:126)ssku,v)

(cid:88)

v∈U
(cid:88)

v∈U

u∈V
(cid:88)

liu · (

+

u∈V

v∈U

= [ˆc0 · (

(cid:88)

liu · (

u∈V
(cid:88)

= [ˆc0 ·

sku,0 +

(cid:88)

v∈U

(cid:126)ssku,v)) +

(cid:88)

u∈U

(cid:126)eu,2]h

(cid:88)

u∈U

(cid:126)eu,2]h

(cid:88)

(cid:126)seu,v)]h

(1)

u∈U

Let X = [ˆc1 + cs]h. Since

(cid:88)

ˆc0 = [

αucu,0]h,

u∈U

(cid:88)

ˆc1 = [

αucu,1]h,

u∈U

cu,0 = [(cid:126)a · (cid:126)uu + (cid:126)eu,0]h,

cu1 = [pk · (cid:126)uu + (cid:126)eu,1 + (cid:98)h/l(cid:99) · mu]h,

(cid:88)

pk = [

pku,0]h,

u∈U

and

we have the equation 2.

pku = [−((cid:126)a · sku,0 + (cid:126)eu)]h,

X = [ˆc1 + ˆc0 ·

(cid:88)

u∈U

sku,0 +

(cid:88)

u∈U

(cid:126)eu,2]h

(cid:88)

= [

αu(pk · (cid:126)uu + (cid:126)eu,1 + (cid:98)h/l(cid:99) · mu)

+

+

u∈U
(cid:88)

αu((cid:126)a · (cid:126)uu + (cid:126)eu,0) · (

(cid:88)

sku,0)

(2)

u∈U
(cid:88)

u∈U

(cid:126)eu,2]h

u∈U

Let

N S0 =

(cid:88)

u∈U

αu(cid:126)eu,1 + (

(cid:88)

u∈U

αu(cid:126)eu,0) · (

(cid:88)

sku,0) +

u∈U

(cid:88)

u∈U

(cid:126)eu,2,

20

Haibo Tian, Fangguo Zhang, Yunfeng Shao, and Bingshuai Li

and

Let

M P =

(cid:88)

u∈U

αu(cid:98)h/l(cid:99) · mu.

Y = [X − N S0 − M P ]h.

We then have the equation 3.

(cid:88)

Y = [

αu(pk · (cid:126)uu) +

(cid:88)

u∈U

αu((cid:126)a · (cid:126)uu) · (

(cid:88)

sku,0)]h

u∈U

u∈U
(cid:88)

= [

αu((cid:126)uu · (

(cid:88)

−((cid:126)a · sku0 + (cid:126)eu)))

u∈U

(cid:88)

+ (cid:126)a · (

u∈U

αu(cid:126)uu) · (

(cid:88)

sku,0)]h

u∈U
(cid:88)

αu(cid:126)uu ·

= [−

u∈U

u∈U

(cid:88)

u∈U

(cid:126)eu]h

(3)

Let N S = N S0 − (cid:80)
the equation 4.

u∈U αu(cid:126)uu · (cid:80)

u∈U (cid:126)eu, then X = [N S + M P ]h. We then have

m = [(cid:98)

l · [ˆc1 + cs]h
h

(cid:101)]l

l · X
h

(cid:101)]l
l · (N S + (cid:80)

u∈U αu(cid:98)h/l(cid:99) · mu)

αumu]l + [(cid:98)

h
l · N S
h

(cid:101)]l

= [(cid:98)

= [(cid:98)

(cid:88)

= [

u∈U

(cid:101)]l

(4)

If N S < h

2l , the above decryption is correct. Since (cid:126)uu, sku0 ← R3, (cid:126)eu0, (cid:126)eu1,
(cid:126)eu, (cid:126)eu2 ← χ, the maximal inﬁnity norm of elements in the set {αu}u∈U is A, the
inﬁnity norm of N S is

||N S|| ≤ δRA|U |B + δ2

RA|U |2B + |U |B + δ2

RA|U |2B

= |U |B(1 + δRA(1 + 2δR|U |))

(5)

The second proof is for the privacy of messages in the deﬁnition 3.

Theorem 3. If there is an adversary A with advantage (cid:15)sem to make the ex-
periment ExptA,Sem(1λ) output 1, one could construct a challenger to break the
n-decision-RLWE problem with an advantage 1
2 (cid:15)sem under the condition that the
secret sharing scheme SS has the privacy property [20] and the hybrid encryption
scheme HP KE is sematic secure.

Proof. With |U | and t, the challenger samples a |U |-decision-RLWE instance
(x0, {xu}u∈U ). It embeds the problem instance into the DTAHE instance as
follows:

parm ← Setup(1λ),

Title Suppressed Due to Excessive Length

21

parm = parm\{(cid:126)a} ∪ {x0},
(sku, pku) ← KeyGen(parm),
sku,0 = 0; pku,0 = xu,
{ev,u}v∈U \{u} ← Share(parm, {pkv}v∈U \{u}, t, sku),
pk ← CombKey(parm, {pku}u∈U ).

It then provides (parm, pk, {{ev,u}v∈U \{u}}u∈U ) to A.

The challenger plays with A by {sku,1}u∈U until A outputs b(cid:48).
If the HP KE scheme is sematic secure, the ciphers {ev,u}v∈U \{u} leak noth-
ing about shares. Then from the privacy property of the SS scheme, if |S| < t,
A can not distinguish a secret sku,0 from zero. So A should produce an educated
guess b(cid:48).

The strategy of the challenger is to use the guess of A. If the ExptA,Sem(1λ)
outputs 0, the challenger believes that the |U |-decision-RLWE instance is a uni-
form random sample from Rn+1

.

When the input is indeed a uniform random sample from Rn+1

, the advan-
tage of A is simple negligible since the messages are masked by random values.
Otherwise, the adversary has an advantage (cid:15)sem by assumption. So the advan-
tage of the challenger is 1

h

h

2 (cid:15)sem.

The third proof is for the privacy of secret keys and shares in the deﬁnition

4.

Theorem 4. If the secret sharing scheme SS has the privacy property [20]
and the hybrid encryption scheme HP KE is sematic secure, the adversary A
has negligible advantage to distinguish the two experiments ExpA,Real(1λ) and
ExptA,Ideal(1λ).
Proof. The proof needs a serial of hybrid experiments between an adversary A
and a challenger.

– H0: This is the experiment ExpA,Real(1λ) in the deﬁnition 4.
– H1:Same as H0, except that the challenger simulates the P arDec algorithm
to produce ˆmu for queries of A. Note that A has given the challenger a set
S∗ with the size |S∗| = t − 1. From S∗, the challenger could construct a set
SC = S\S∗. For each party u ∈ SC, |S∗ ∪ {u}| = t. The challenger sets ˆmu
as

˜mu = [li−1

u ((cid:98)h/l(cid:99)

(cid:88)

αvmv + N S − ˆc1 −

liv ˆmv)]h

(cid:88)

v∈U

v∈S∗

where N S is deﬁned in the theorem 2. If u ∈ S∗, the challenger computes
ˆmu as in the game H0.
The correctness of the simulation is obviously since

˜mu = [li−1

u (M P + N S − (ˆc1 +

(cid:88)

v∈S∗

liv ˆmv))]h

u (M P + N S − (ˆc1 + cs − liu ˆmu))]h
u (M P + N S − X + liu ˆmu)]h

= [li−1
= [li−1
= ˆmu

(6)

22

Haibo Tian, Fangguo Zhang, Yunfeng Shao, and Bingshuai Li

– H2: Same as H1, except that the challenger shares zero as

{ev,u}v∈U \{u} ← Share(parm, {pkv}v∈U \{u}, t, 0).

By the privacy property [20] of the SS scheme and the sematic security of
the HP KE scheme, H2 and H1 are indistinguishable.
– H3: Same as H2, except that N S is replaced by ˜N S as

˜N S = N S − (

(cid:88)

sku,0)(

u∈U

+ (

(cid:88)

u∈U

(cid:126)uu,0)(

(cid:88)

u∈U

αu(cid:126)eu,0)

(cid:88)

u∈U

αu(cid:126)eu,0)

(7)

where (cid:126)uu,0 ← R3.
˜N S
Since sku,0 ← R3, H3 and H2 have the same distribution. In fact,
may appear in an experiment when the {(cid:126)uu,0}u∈U happens to be part of
the secret keys of users. Now the challenger does not use the private keys
of users {sku}u∈U or secret shares of users in U . So the ideal experiment
ExptA,Ideal(1λ) could be simulated indistinguishably.

5 Performance

We evaluate the communication and computation costs of the secure linear ag-
gregation protocol.

5.1 Communication

We have stated that there are mainly three methods [19–21] to construct a
DTAHE. We concrete the method in [21] based on an elliptic curve version
ElGamal (EC-ElGamal) scheme, and other methods based on the BFV [13, 35]
scheme. The user side communication overhead of the secure linear aggregation
protocol is calculated as follows:

(cid:88)

i∈{1,...,4}

mu,i = (n + 2)|u| + (n − 1)|ev,u| + |cu|

+ | ˆmu| + 3|accu| + |Tu| + |σu| + |Sig|
+ |certu| + |aux| + |Record| + |esid|

(8)

where n is the number of users. Table I shows the main components in the
equation (8). The security parameter λ is 128. An element in EC-ElGamal takes
33 bytes where one byte is for y-coordinate. LR denotes the size of a ring element
in Rh, SN the number of shares to each user and LN the number of ciphers
to encrypt the user input mu. LR(cid:48) and LN (cid:48) have the same meaning as LR and
LN with LR (cid:54)= LR(cid:48) and LN (cid:54)= LN (cid:48). The method to use Shamir secret sharing
in [20] is denoted as BGGJK-2, and the other is denoted as BGGJK-1.

Title Suppressed Due to Excessive Length

23

Table 1: Communication Overheads of Main Components in the Protocol

|ev,u|

|cu|

| ˆmu|

Pedersen [21]

33 + 32

66 ∗ |mu|

33 ∗ |mu|

BD [19]

BGGJK-1 [20]

BGGJK-2 [20]

33 + LR ∗ SN 2 ∗ LR ∗ LN LR ∗ LN ∗ SN
2 ∗ LR ∗ LN LR ∗ LN ∗ n4
33 + LR ∗ n4
2 ∗ LR(cid:48) ∗ LN (cid:48) LR(cid:48) ∗ LN (cid:48)
33 + LR(cid:48)

Ours

33 + LR(1 + LN) 2 ∗ LR ∗ LN

LR ∗ LN

Fig. 4: Main Communication Overheads of Diﬀerent DTAHE Schemes in the
Protocol

Fig. 4 shows the main communication overhead of the protocol on user side
with diﬀerent DTAHE constructions when the number of user increases. We
mainly consider the components in Table I. We set |mu| = 105 for all instances,
and set d = 2048 and |h| = 54 so that LR = d ∗ |h|/8 = 13824 bytes and

(cid:19)

(cid:18) n − 1
t − 1

. The

LN = (cid:100)|mu|/d(cid:101) = 49. We set t = (cid:100)n ∗ 2/3(cid:101) and compute SN =

values of LR(cid:48) and LN (cid:48) are relative to the number of users since the noise element
in the P arDec algorithm should be multiplied by (n!)2, which are limited by the
Theorem 2 and the equation (6) in [22].

From Fig. 4, we exclude the BD [19] and BGGJK-1 [20] methods to distribute
many shares to a user. Our method is better than the BGGJK-2 [20] when
the user number is greater than 26. The EC-ElGamal method has the best
communication performance when the number of users is greater than 20.

5.2 Computation

Since the computation costs of the protocol are dominated by a DTAHE scheme.
We give Table II to show the time cost of some DTAHE algorithms. We set
the user number as n = 35 and implement three DTAHE schemes for com-
parison. The schemes are implemented in Python. The “pyOpenSSL” is used
to implement the EC-ElGamal based DTAHE. The small discrete logarithm of

24

Haibo Tian, Fangguo Zhang, Yunfeng Shao, and Bingshuai Li

Table 2: Computation Costs of Some DTAHE Algorithms with Fixed Number
of Users

Share CombKey and Enc Eval ParDec FinDec

[21]

0.03

[20]-2 4.03

Ours 17.46

6.95

15.48

7.50

14.62

6.32

441.25

2.40

1.52

17.29

51.17

2.98

1.64

a group element is found by the well-known “Baby-Step-Giant-Step” method.
An open source library “bfv-python” is adapted to implement our scheme and
the BGGJK-2 method in [20]. For simplicity, we use a public python mod-
ule “eciespy” as an instance of the HP KE scheme. The CPUs are Intel(R)
Core(TM) i7-8550U (1.80GHz, 1.99GHz) and the RAM is 16GB.

We use the “secp256r1” curve as the parameter set to implement the EC-
ElGamal based DTAHE. For the security parameter λ = 128, we set d = 2048,
|h| = 54 and |l| = 17 for our DTAHE scheme. When n = 35, the scheme
constructed by the BGGJK-2 method in [20] requires |h| ≥ 426. So we set
d = 16384 according to the parameter table in [39]. Each data element in mu
in our test occupies 8 bits. The time costs of the three implementations are
listed in the table II, which are measured in seconds. Apparently, a secure linear
aggregation protocol with the EC-ElGamal based DTAHE takes the least time
on user side. The protocol with our DTAHE scheme takes the least time on
server side.

6 Conclusion

This paper shows a secure linear protocol mainly for complex federated learning
models. When the communication cost is not the dominate factor, the protocol
could be deployed in a federated learning model to protect the private inputs
of users. The DTAHE schemes in the protocol may be further optimized to
reduce the computation time. For example, parallel computing technologies may
reduce the time cost of the EC-ElGamal based DTAHE, and multi-secret sharing
schemes may reduce the communication and computation costs of our DTAHE
scheme.

Acknowledgment

This work is supported by the National Key R&D Program of China (2017YFB0802500),
Guangdong Major Project of Basic and Applied Basic Research(2019B030302008)
and Natural Science Foundation of Guangdong Province of China (2018A0303130133).

Title Suppressed Due to Excessive Length

25

References

1. H. B. McMahan, E. Moore, D. Ramage, and B. A. y Arcas, “Federated learning
of deep networks using model averaging,” CoRR, vol. abs/1602.05629, 2016.
[Online]. Available: http://arxiv.org/abs/1602.05629

2. M. Fredrikson, S. Jha, and T. Ristenpart, “Model inversion attacks that exploit
conﬁdence information and basic countermeasures,” in Proceedings of the 22Nd
ACM SIGSAC Conference on Computer and Communications Security, ser. CCS
’15. New York, NY, USA: ACM, 2015, pp. 1322–1333.
[Online]. Available:
http://doi.acm.org/10.1145/2810103.2813677

3. M. Al-Rubaie and J. M. Chang, “Reconstruction attacks against mobile-based con-
tinuous authentication systems in the cloud,” IEEE Transactions on Information
Forensics and Security, vol. 11, no. 12, pp. 2648–2663, Dec 2016.

4. C. Di, W. Leye, C. Kai, and Y. Qiang, “Secure federated matrix factorization,” in
FML 2019 : The 1st International Workshop on Federated Machine Learning for
User Privacy and Data Conﬁdentiality, 2019.

5. K. Bonawitz, V.

Ivanov, B. Kreuter, A. Marcedone, H. B. McMahan,
S. Patel, D. Ramage, A. Segal, and K. Seth, “Practical secure aggregation for
privacy-preserving machine learning,” in Proceedings of the 2017 ACM SIGSAC
Conference on Computer and Communications Security, ser. CCS’17. New York,
NY, USA: Association for Computing Machinery, 2017, pp. 1175–1191. [Online].
Available: https://doi.org/10.1145/3133956.3133982

6. M. Abadi, A. Chu, I. Goodfellow, H. B. McMahan, I. Mironov, K. Talwar, and
L. Zhang, “Deep learning with diﬀerential privacy,” in Proceedings of the 2016
ACM SIGSAC Conference on Computer and Communications Security, ser. CCS
’16. New York, NY, USA: Association for Computing Machinery, 2016, pp.
308–318. [Online]. Available: https://doi.org/10.1145/2976749.2978318

7. K. Wei, J. Li, M. Ding, C. Ma, H. H. Yang, F. Farokhi, S. Jin, T. Q. S. Quek,
and H. Vincent Poor, “Federated learning with diﬀerential privacy: Algorithms and
performance analysis,” IEEE Transactions on Information Forensics and Security,
vol. 15, pp. 3454–3469, 2020.

8. V. Rastogi and S. Nath, “Diﬀerentially private aggregation of distributed
time-series with transformation and encryption,” in Proceedings of the 2010 ACM
SIGMOD International Conference on Management of Data, ser. SIGMOD ’10.
New York, NY, USA: Association for Computing Machinery, 2010, p. 735–746.
[Online]. Available: https://doi.org/10.1145/1807167.1807247

9. M. Jawurek and F. Kerschbaum, “Fault-tolerant privacy-preserving statistics,” in
Privacy Enhancing Technologies, S. Fischer-H¨ubner and M. Wright, Eds. Berlin,
Heidelberg: Springer Berlin Heidelberg, 2012, pp. 221–238.

10. M. Joye and B. Libert, “A scalable scheme for privacy-preserving aggregation of
time-series data,” in Financial Cryptography and Data Security, A.-R. Sadeghi,
Ed. Berlin, Heidelberg: Springer Berlin Heidelberg, 2013, pp. 111–125.

11. I. Leontiadis, K. Elkhiyaoui, and R. Molva, “Private and dynamic time-
series data aggregation with trust relaxation,” in Proceedings of
the 13th
International Conference on Cryptology and Network Security - Volume 8813.
[Online]. Available:
Berlin, Heidelberg: Springer-Verlag, 2014, p. 305–320.
https://doi.org/10.1007/978-3-319-12280-9 20

12. E. Shi, T.-H. Chan, E. Rieﬀel, R. Chow, and D. Song, “Privacy-preserving aggre-

gation of time-series data,” vol. 2, 01 2011.

26

Haibo Tian, Fangguo Zhang, Yunfeng Shao, and Bingshuai Li

13. T. H. H. Chan, E. Shi, and D. Song, “Privacy-preserving stream aggregation with
fault tolerance,” in Financial Cryptography and Data Security, A. D. Keromytis,
Ed. Berlin, Heidelberg: Springer Berlin Heidelberg, 2012, pp. 200–214.

14. I. Leontiadis, K. Elkhiyaoui, M. ¨Onen, and R. Molva, “Puda – privacy and un-
forgeability for data aggregation,” Cryptology ePrint Archive, Report 2015/562,
2015, https://eprint.iacr.org/2015/562.

15. Q. Li and G. Cao, “Eﬃcient privacy-preserving stream aggregation in mobile sens-
ing with low aggregation error,” in Privacy Enhancing Technologies, E. De Cristo-
faro and M. Wright, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2013,
pp. 60–81.

16. Y. Liu, Y. Liu, Z. Liu, Y. Liang, C. Meng, J. Zhang, and Y. Zheng, “Federated

forest,” IEEE Transactions on Big Data, pp. 1–1, 2020.

17. H. H. Zhuo, W. Feng, Y. Lin, Q. Xu, and Q. Yang, “Federated deep reinforcement

learning,” 2020.

18. J. L. H. Crawford, C. Gentry, S. Halevi, D. Platt, and V. Shoup, “Doing real work
with FHE: the case of logistic regression,” in Proceedings of the 6th Workshop on
Encrypted Computing & Applied Homomorphic Cryptography, WAHC@CCS 2018,
Toronto, ON, Canada, October 19, 2018, 2018, pp. 1–12. [Online]. Available:
https://doi.org/10.1145/3267973.3267974

19. R. Bendlin and I. Damg˚ard, “Threshold decryption and zero-knowledge proofs
for lattice-based cryptosystems,” in Theory of Cryptography, D. Micciancio, Ed.
Berlin, Heidelberg: Springer Berlin Heidelberg, 2010, pp. 201–218.

20. D. Boneh, R. Gennaro, S. Goldfeder, A. Jain, S. Kim, P. M. R. Rasmussen, and
A. Sahai, “Threshold cryptosystems from threshold fully homomorphic encryp-
tion,” in Advances in Cryptology – CRYPTO 2018, H. Shacham and A. Boldyreva,
Eds. Cham: Springer International Publishing, 2018, pp. 565–596.

21. T. P. Pedersen, “A threshold cryptosystem without a trusted party,” in Advances in
Cryptology — EUROCRYPT ’91, D. W. Davies, Ed. Berlin, Heidelberg: Springer
Berlin Heidelberg, 1991, pp. 522–526.

22. J. Fan and F. Vercauteren, “Somewhat practical fully homomorphic encryption,”
Cryptology ePrint Archive, Report 2012/144, 2012, https://eprint.iacr.org/2012/
144.

23. X. Zhu, H. Li, and Y. Yu, “Blockchain-based privacy preserving deep learning,”
in Information Security and Cryptology, F. Guo, X. Huang, and M. Yung, Eds.
Cham: Springer International Publishing, 2019, pp. 370–383.

24. X. Bao, C. Su, Y. Xiong, W. Huang, and Y. Hu, “Flchain: A blockchain for au-
ditable federated learning with trust and incentive,” in 2019 5th International
Conference on Big Data Computing and Communications (BIGCOM), 2019, pp.
151–159.

25. Y. Lu, X. Huang, K. Zhang, S. Maharjan, and Y. Zhang, “Blockchain empowered
asynchronous federated learning for secure data sharing in internet of vehicles,”
IEEE Transactions on Vehicular Technology, vol. 69, no. 4, pp. 4298–4311, 2020.
26. Y. Qu, L. Gao, T. H. Luan, Y. Xiang, S. Yu, B. Li, and G. Zheng, “Decentral-
ized privacy using blockchain-enabled federated learning in fog computing,” IEEE
Internet of Things Journal, vol. 7, no. 6, pp. 5171–5183, 2020.

27. J. Weng, J. Weng, J. Zhang, M. Li, Y. Zhang, and W. Luo, “Deepchain: Au-
ditable and privacy-preserving deep learning with blockchain-based incentive,”
IEEE Transactions on Dependable and Secure Computing, pp. 1–1, 2019.

28. S. R. Pokhrel and J. Choi, “Federated learning with blockchain for autonomous
vehicles: Analysis and design challenges,” IEEE Transactions on Communications,
pp. 1–1, 2020.

Title Suppressed Due to Excessive Length

27

29. H. Kim, J. Park, M. Bennis, and S. Kim, “Blockchained on-device federated learn-

ing,” IEEE Communications Letters, vol. 24, no. 6, pp. 1279–1283, 2020.

30. Q. Wang, Y. Guo, X. Wang, T. Ji, L. Yu, and P. Li, “Ai at the edge: Blockchain-
empowered secure multiparty learning with heterogeneous models,” IEEE Internet
of Things Journal, pp. 1–1, 2020.

31. K. Sarpatwar, R. Vaculin, H. Min, G. Su, T. Heath, G. Ganapavarapu, and
D. Dillenberger, Towards Enabling Trusted Artiﬁcial Intelligence via Blockchain.
Cham: Springer International Publishing, 2019, pp. 137–153. [Online]. Available:
https://doi.org/10.1007/978-3-030-17277-0 8

32. S. Awan, F. Li, B. Luo, and M. Liu, “Poster: A reliable and accountable privacy-
preserving federated learning framework using the blockchain,” in Proceedings of
the 2019 ACM SIGSAC Conference on Computer and Communications Security,
ser. CCS ’19. New York, NY, USA: Association for Computing Machinery, 2019,
p. 2561–2563. [Online]. Available: https://doi.org/10.1145/3319535.3363256
33. M. Di Raimondo and R. Gennaro, “New approaches for deniable authentication,”
in Proceedings of the 12th ACM Conference on Computer and Communications
Security, ser. CCS’ 05. New York, NY, USA: Association for Computing
Machinery, 2005, pp. 112–121.
[Online]. Available: https://doi.org/10.1145/
1102120.1102137

34. D. G. Wood, “Ethereum: a secure decentralised g generalised transaction ledger
[Online, Accessed 26-June-

homestead,” http://gavwood.com/paper.pdf, 2014,
2020].

35. Z. Brakerski, “Fully homomorphic encryption without modulus switching from
classical gapsvp,” in Advances in Cryptology – CRYPTO 2012, R. Safavi-Naini
and R. Canetti, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2012, pp.
868–886.

36. “Microsoft SEAL (release 3.5),” https://github.com/Microsoft/SEAL, Apr. 2020,

microsoft Research, Redmond, WA.

37. J. Herranz, D. Hofheinz, and E. Kiltz, “Some (in)suﬃcient conditions for secure
hybrid encryption,” Inf. Comput., vol. 208, no. 11, p. 1243–1257, Nov. 2010.
[Online]. Available: https://doi.org/10.1016/j.ic.2010.07.002

38. V. Lyubashevsky, C. Peikert, and O. Regev, “On ideal lattices and learning with
errors over rings,” in Advances in Cryptology – EUROCRYPT 2010, H. Gilbert,
Ed. Berlin, Heidelberg: Springer Berlin Heidelberg, 2010, pp. 1–23.

39. M. Albrecht, M. Chase, H. Chen, J. Ding, S. Goldwasser, S. Gorbunov, S. Halevi,
J. Hoﬀstein, K. Laine, K. Lauter, S. Lokam, D. Micciancio, D. Moody, T. Morrison,
A. Sahai, and V. Vaikuntanathan, “Homomorphic encryption security standard,”
HomomorphicEncryption.org, Toronto, Canada, Tech. Rep., November 2018.

