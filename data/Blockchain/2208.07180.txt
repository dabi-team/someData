2
2
0
2

g
u
A
5
1

]

O
L
.
s
c
[

1
v
0
8
1
7
0
.
8
0
2
2
:
v
i
X
r
a

Smart Contract Synthesis Modulo Hyperproperties

Norine Coenen
CISPA Helmholtz Center for Information Security
Saarbr¨ucken, Germany
norine.coenen@cispa.de

Bernd Finkbeiner
CISPA Helmholtz Center for Information Security
Saarbr¨ucken, Germany
ﬁnkbeiner@cispa.de

Jana Hofmann
CISPA Helmholtz Center for Information Security
Saarbr¨ucken, Germany
jana.hofmann@cispa.de

Julia Tillman
CISPA Helmholtz Center for Information Security
Saarbr¨ucken, Germany
julia.tillman@cispa.de

Abstract—Smart contracts are small but highly security-
critical programs that implement wallets, token systems, auc-
tions, crowd funding systems, elections and other multi-party
transactions on the blockchain. A broad range of methods has
been developed to ensure that a smart contract is functionally
correct. However, smart contracts often additionally need to
satisfy certain hyperproperties, such as symmetry, determinism,
or an information ﬂow policy. In this paper, we show how a
synthesis method for smart contracts can ensure that the contract
satisﬁes its desired hyperproperties. We build on top of a recently
developed synthesis approach from speciﬁcations in the temporal
logic TSL. We present HyperTSL, an extension of TSL for the
speciﬁcation of hyperproperties of inﬁnite-state software. As a
preprocessing step, we show how to detect if a hyperproperty has
an equivalent formulation as a (simpler) trace property. Finally,
we describe how to reﬁne a synthesized contract to adhere to its
HyperTSL speciﬁcation.

Index Terms—hyperproperties, smart contracts, reactive syn-

thesis, temporal logics

I. INTRODUCTION

Smart contracts are small programs which describe trans-
actions between multiple parties. Common smart contracts
implement wallets, token systems, auctions, crowd funding
systems, and elections. Smart contracts run on the blockchain
and thus remove the need for a trusted third party. Bugs in
smart contracts have led to huge monetary losses in the last
decade, making the need for rigorous formal foundations for
smart contracts obvious. In the absence of a trusted third party,
it is especially important to ensure that a contract implements
the agreed order of transactions. The large body of existing
work on the correctness of a contract’s control ﬂow mainly
consists of veriﬁcation methods to ensure that a contract
exhibits a correct behavior with respect to trace properties.

Smart contracts often additionally need to satisfy hyperprop-
erties, however. Hyperproperties describe the relation between
several execution traces of the system. Prominent hyperproper-
ties are information ﬂow policies like noninterference and ob-
servational determinism. Existing work on hyperproperties in

This work was partially supported by the German Research Foundation
(DFG) as part of the Collaborative Research Center “Foundations of Per-
spicuous Software Systems” (TRR 248, 389792660), and by the European
Research Council (ERC) Grant OSARES (No. 683300).

smart contracts focuses on verifying concrete information ﬂow
policies such as integrity, which are enforced using language-
based methods [1], [2]. Hyperproperties are not limited to
information ﬂow policies, though. To establish the users’ trust
in a contract, one has to additionally show that a contract
satisﬁes hyperproperties such as robustness and symmetry. In
a voting contract, for example, all candidates should be treated
symmetrically, and a vote from the owner of the contract
should not count more than any other vote.

In this work, we develop a general-purpose temporal logic,
HyperTSL,
to express the wide range of hyperproperties
relevant in the context of smart contracts. We then show how
to automatically construct the underlying state machine of
a smart contract directly from the logical speciﬁcation of
the hyperproperties. We approach the task from two angles.
First, we investigate the synthesis problem of the logic and
show how to approximate the in general undecidable problem
to obtain correct-by-design implementations. Second, we
propose a two-step approach to include HyperTSL properties
in a recently proposed smart contract synthesis approach [3].

HyperTSL. We develop two variants of the logic, HyperTSL
and HyperTSLrel, which are both based on temporal stream
logic (TSL) [4]. TSL extends linear temporal logic (LTL) with
the concept of cells and uninterpreted functions and predicates.
These mechanisms separate the temporal control ﬂow from the
concrete data in the system, which enables reasoning about
inﬁnite-state systems. TSL has been applied successfully to
synthesize hardware [5], functional programs [6], and also to
describe the underlying state machines of smart contracts [3].
As an example, we can state that the winner of an election
remains the same after the method close has been called.

(close → Jwinner ֋ winnerK)

The contract’s method close is modeled as a boolean and the
ﬁeld winner is modeled as a cell. We deﬁne HyperTSL as
a conservative extension of TSL. It adds quantiﬁcation over
multiple executions; predicates, functions, and updates then
refer to one of the quantiﬁed executions. In an election with

 
 
 
 
 
 
two candidates A and B, we can state that two traces have the
same winner A if they agree on the votes for A.
∀π∀π′.

(voteAπ ↔ voteAπ′ )
→ (Jwinner ֋ A()Kπ ↔ Jwinner ֋ A()Kπ′ )
The second hyperlogic HyperTSLrel allows to relate executions
within a predicate. Here, we can state that the winners on two
executions are always the same as long as the votes are always
the same.
∀π∀π′.

(voteπ = voteπ′) → (winnerπ = winnerπ′)

Note that the = predicate ranges over two different execution
variables π and π′. In TSL, all functions and predicates
are uninterpreted, but = would probably be implemented as
actual equality.

Smart contract synthesis from HyperTSL. Synthesis con-
structs correct-by-design systems from a formal speciﬁcation.
It therefore shifts the development from software writing to
speciﬁcation writing. This idea ﬁts especially well to smart
contracts. Most contracts belong to one of the major classes
like token systems or election protocols, and their behavior can
be characterized with similar speciﬁcations. This also extends
to hyperproperties: the set of actually relevant hyperproperties
is often the same across different systems.

We therefore investigate the synthesis problem of Hyper-
TSL. Inherited from TSL, the problem is undecidable already
for a single quantiﬁer. We show, however, that the ∀∗ fragment
of HyperTSL can be approximated in ∀∗ HyperLTL, for which
there exists a bounded synthesis approach implemented in
HyperBoSy [7]. For the ∃∗ fragment of HyperTSL, we present
an approximation based on LTL satisﬁability checking.

As a step towards actual smart contract synthesis, we build
on a recent workﬂow that implements the synthesis of a smart
contract control ﬂow from TSL speciﬁcations [3]. We present
a two-step approach to synthesize a contract that adheres to
HyperTSL speciﬁcations. First, we check if the combination
of a given TSL speciﬁcation with a ∀∗ HyperTSL speciﬁcation
lets the hyperproperty “collapse” to a simple trace property.
We show that the check is undecidable in general, but can
to some extend be approximated in a decidable fragment of
with HyperLTL satisﬁability checking. If this is not the case,
we synthesize the most general solution (the winning region)
for the TSL speciﬁcation using the tool presented in [3]. We
then prune the system to ﬁnd a strategy that implements a
∀∗ HyperTSL property. Our implementation of the approach
shows that we can automatically construct a voting contract
which satisﬁes several hyperproperties.

Contributions. We present the ﬁrst solution to automatically
construct smart contracts with respect to hyperproperties.

• We deﬁne HyperTSL and HyperTSLrel, two hyperlogics
based on TSL, and show how they can specify hyper-
properties occurring in the context of smart contracts.
• We show that the synthesis problem of ∀∗ HyperTSL can
be over-approximated by ∀∗ HyperLTL synthesis and that

the synthesis problem of ∃∗ HyperTSL can be under-
approximated by LTL satisﬁability checking.

• We describe a preprocessing step to detect if a HyperTSL

formula has an equivalent TSL formulation.

• We describe and implement a repair-like pruning
algorithm that reﬁnes a smart contract synthesized from
a TSL speciﬁcation to satisfy a ∀∗ HyperTSL formula.

Structure of the paper. We ﬁrst give the necessary prelimi-
naries, including the deﬁnitions of HyperLTL and TSL. In Sec-
tion III, we present HyperTSL and HyperTSLrel, and show how
to specify hyperproperties in a voting contract. We proceed by
investigating the realizability problem of HyperTSL and argue
why HyperTSL is more suited for synthesis than HyperTSLrel.
In Section V, we recap the synthesis workﬂow based on
TSL [3] and discuss the combination of the TSL speciﬁcation
of the voting contract with the HyperTSL speciﬁcations.
Section VI discusses the detection of pseudo hyperproperties.
Section VII presents the pruning of a contract with respect to
HyperTSL, including a prototype implementation.

II. PRELIMINARIES

We recap the deﬁnitions of HyperLTL and TSL.

A. HyperLTL

Let AP be an inﬁnite set of atomic propositions. A trace t is
an element of (2AP )ω. We write t[i] for the ith element of t. A
trace property P is a set of traces, a hyperproperty H is a set
of sets of traces. HyperLTL [8] describes hyperproperties by
extending LTL with explicit trace quantiﬁcation. It is deﬁned
with respect to an inﬁnite set of trace variables V.

ϕ ::= ∀π. ϕ | ∃π. ϕ | ψ
ψ ::= aπ | ¬ψ | ψ ∧ ψ | ψ | ψ U ψ,
where a ∈ AP and π ∈ V. In HyperLTL, atomic propositions
are indexed with the trace variable they refer to. The semantics
of HyperLTL is deﬁned with respect to a set of traces T . Let
Π : V → T be a trace assignment that maps trace variables
to traces in T . To update Π, we write Π[π 7→ t], where
π maps to t and all other trace variables are as in Π. The
satisfaction relation of HyperLTL is deﬁned with respect to a
trace assignment Π, a set of traces T , and a point in time i.

iff a ∈ Π(π)[i]
Π, T, i |= aπ
iff Π, T, i 6|= ψ
Π, T, i |= ¬ψ
Π, T, i |= ψ1 ∧ ψ2 iff Π, T, i |= ψ1 and Π, T, i |= ψ2
Π, T, i |= ψ
Π, T, i |= ψ1 U ψ2 iff ∃j ≥ i. Π, T, j |= ψ2

iff Π, T, i + 1 |= ψ

and ∀i ≤ k < j. Π, T, k |= ψ1

Π, T, i |= ∃π. ϕ
Π, T, i |= ∀π. ϕ

iff ∃t ∈ T. Π[π 7→ t], T, i |= ϕ
iff ∀t ∈ T. Π[π 7→ t], T, i |= ϕ

As for LTL, we can derive the usual boolean logical con-
ψ = ⊤ U ψ,
nectives and temporal operators “eventually”
ψ = ¬ ¬ψ, and “weak until” ψ1 W ψ2 =
“globally”

(ψ1 U ψ2)∨ ψ1. When specifying smart contracts, we assume
speciﬁcations to belong to the syntactic safety fragment, i.e.,
, and W as temporal operators. For-
that they only contain ,
mulas from the syntactic safety fragment can be equivalently
expressed using past-time temporal operators, which reason
about the past instead of the future of a trace. “Yesterday”
, and “since” S corresponds to
is the past-time equivalent of
U. We say that a trace set T satisﬁes a HyperLTL formula ϕ,
written as T |= ϕ, if ∅, T, 0 |= ϕ, where ∅ denotes the empty
trace assignment.

We deﬁne the HyperLTL realizability problem as in [9]. We
assume AP to be a disjoint union of a set of input propositions
and a set of output propositions, i.e., AP = AP in ˙∪ AP out . A
strategy σ : (2AP in )+ → 2AP out maps ﬁnite sequences of input
valuations to an output valuation. For an inﬁnite word w =
w0w1w2 · · · ∈ (2AP in )ω, the trace generated by a strategy σ is
deﬁned as σw = (w0 ∪ σ(w0))(w1 ∪ σ(w0w1)) . . . ∈ (2AP )ω.
We write traces(σ) for the set {σw | w ∈ (2AP in )ω}. We
say that a strategy σ satisﬁes a HyperLTL formula ϕ over
AP = AP in ˙∪ AP out if traces(σ) |= ϕ.

Deﬁnition II.1 (HyperLTL realizability). A HyperLTL for-
mula ϕ over AP = AP in ˙∪ AP out is realizable if there is a
strategy σ : (2AP in )+ → 2AP out that satisﬁes ϕ.

B. TSL

We introduce the syntax and semantics of TSL follow-
ing [3], [4]. TSL extends LTL with the concept of cells,
which hold data from an arbitrary domain. To abstract from
concrete data points, TSL employs uninterpreted functions and
predicates. A TSL formula describes a system that receives
a stream of inputs, abstracts from the concrete values using
predicates, and produces a stream of cell updates using func-
tion applications. We formally deﬁne values, functions, and
predicates. The set of all values is denoted by V, the Boolean
values by B ⊆ V. An n-ary function f : V n → V computes
a value from n values. An n-ary predicate p : V n → B
assigns a boolean value to n values. The sets of all functions
and predicates are denoted by F and P ⊆ F , respectively.
Constants are both 0-ary functions and values.

Let I and C be the set of inputs and cells, and let ΣF
and ΣP ⊆ ΣF be the set of function and predicate symbols.
Function terms τ f are recursively deﬁned by

τ f ::= s | f τ f . . . τ f
where s ∈ I ∪ C and f is an n-ary function symbol. Predicate
terms τ p are obtained by applying a predicate to function
terms. The sets of all function and predicate terms are denoted
by TF and TP ⊆ TF , respectively. TSL formulas are built
according to the following grammar:

ψ ::= ¬ψ | ψ ∧ ψ |

ψ | ψ U ψ | τ p | Jc ֋ τ f K

where c ∈ C, τ p ∈ TP , and τ f ∈ TF . An update term Jc ֋
τf K denotes that the value of function term τf is assigned to
cell c. We denote the set of update terms with TU .

Function and predicate terms are syntactic objects, i.e. the
term p(f c) only becomes meaningful when we assign, for

example, c to the value 3, f to the function f (x) = x + 1
and p to p(x) = x > 0. To assign a semantic interpretation
to function and predicate symbols, we use an interpretation
h·i : ΣF → F . A cell assignment C → TF is a total function
assigning exactly one function term to each cell. The set of all
assignments C → TF is denoted by C. A computation ς ∈ Cω
describes the control ﬂow of the cells, i.e., which function term
is associated with a cell at which point in time. For every cell
c ∈ C, let init c be a designated value assigned initially to
c. Input streams I ω are inﬁnite sequences of assignments of
inputs to values. Given a computation, an input stream, and a
point in time i, we can evaluate a function term. The evaluation
function ηh·i : Cω × I ω × N × TF → V is deﬁned as

ηh·i(ς, ι, i, s) := 


s ∈ I
ι[i] s
s ∈ C ∧ i = 0
init s
ηh·i(ς, ι, i−1, ς[i−1] s) s ∈ C ∧ i > 0

ηh·i(ς, ι, i, f τ0 . . . τn) :=


hfi ηh·i(ς, ι, i, τ0) . . . ηh·i(ς, ι, i, τn)

Note that ι[i] s denotes the value that input stream ι assigns
to input s at position i. Likewise, ς[i] s is the function term
that ς assigns to cell s at point in time i. As an example,
to compute the value of cell x in step i, we might obtain
from the computation that x is updated to f x in step i, so
we recursively evaluate x in step i − 1 and apply the function
assigned to f to the result. We evaluate a TSL formula ψ with
respect to an assignment function h·i, an input stream ι ∈ I ω,
a computation ς ∈ Cω, and a time step i ∈ N.

ς, ι, i |=h·i ¬ψ
ς, ι, i |=h·i ψ1 ∧ ψ2
ς, ι, i |=h·i ψ
ς, ι, i |=h·i ψ1 U ψ2

ς, ι, i |=h·i Jc ֋ τ K
ς, ι, i |=h·i p τ1 . . . τn

iff
iff

iff

iff

iff
iff

ς, ι, i 6|=h·i ψ
ς, ι, i |=h·i ψ1 and ς, ι, i |=h·i ψ2
ς, ι, i + 1 |=h·i ψ
∃j ≥ i. ς, ι, j |=h·i ψ2
and ∀i ≤ k < j. ς, ι, k |=h·i ψ1
ς[i] c ≡ τ
ηh·i(ς, ι, i, p τ1 . . . τn)

We use ≡ to syntactically compare two terms. An execution
(ς, ι) satisﬁes a TSL formula ψ if ς, ι, 0 |=h·i ψ holds. In this
case, we write ς, ι |=h·i ψ. A TSL formula ψ is satisﬁable iff
there exists an interpretation h·i and an execution (ς, ι) such
that ς, ι |=h·i ψ [10].
TSL realizability. The realizability problem of a TSL formula
ψ asks whether there exists a strategy which reacts to predicate
evaluations with cell updates according to ψ. Formally, a
strategy is a function σ : (2TP )+ → C. Given a strategy σ
and an input stream ι, we can deﬁne the resulting computation
σ(ι). To compute the cell updates at point in time i, we require
the current inputs as well as the history of cell updates:

σ(ι)[i] := σ( {τ p ∈ TP | ηh·i(σ(ι), ι, 0, τ p)} · . . .
. . . · {τ p ∈ TP | ηh·i(σ(ι), ι, i, τ p)} )

Note that in order to deﬁne σ(ι)[i], the deﬁnition uses σ(ι).
This is well-deﬁned since the evaluation function ηh·i(ς, ι, i, τ )
only uses ς[0] . . . ς[i − 1].

Deﬁnition II.2 (TSL realizability [4]). A TSL formula ψ is
realizable iff there exists a strategy σ : (2TP )+ → C such that
for every input stream ι ∈ I ω and every assignment function
h·i : ΣP → F , it holds that σ(ι), ι |=h·i ψ.

point in time i. We omit the cases for ¬, ∧,
follow closely the respective cases in TSL.
Π, E, i |=h·i Jc ֋ τ f Kπ
Π, E, i |=h·i (p τ1 . . . τn)π iff ηh·i(ς, ι, i, p τ1 . . . τn)

iff #ς (Π(π)) i c ≡ τ f

, and U, which

for ς = #ς (Π(π)) and
ι = #ι(Π(π))
iff ∃e ∈ E. Π[π 7→ e], E, i |=h·i ϕ
iff ∀e ∈ E. Π[π 7→ e], E, i |=h·i ϕ

III. HYPERTSL

Π, E, i |=h·i ∃π. ϕ
Π, E, i |=h·i ∀π. ϕ

We extend TSL with execution quantiﬁers to allow reason-
ing about hyperproperties for inﬁnite-state systems. There is
not a single obvious way to lift TSL to a hyperlogic, so we
motivate in the following our choices for HyperTSL.
Function and predicate interpretations. There are two op-
tions to deal with function and predicate interpretations. The
ﬁrst is to interpret functions and predicates differently across
multiple executions. This would make sense, for example,
to model multiple components of a system. Most of the
hyperproperties, however, concern the behavior of the same
system when executed several times. Functions and predicates
like equality and addition mostly stay the same across several
executions. We therefore decide to quantify the function and
predicate interpretation before quantifying executions.
Domain of updates and predicates. Another question is
whether predicates, functions, and update terms may contain
terms evaluated on different executions. In the case of update
terms the answer should probably be no: an update of the form
Jcπ ֋ f(cπ′)K would mean that the system could access the
value of a cell at the same point in time but on a different
execution. This does not seem realistic for a real system,
which would have to store all possible values a cell c could
hold at some point in time. Additionally, the execution chosen
for π′ differs with every quantiﬁer evaluation. Predicates
ranging over multiple executions, on the other hand, would
be useful. One could state a stronger version of observational
determinism, namely “if two traces agree on the value of input
x, then also cell c is always updated to the same term”, written
(xπ = xπ′) → (Jc ֋ f(x)Kπ ↔ Jc ֋ f(x)Kπ′).
as
in which we
We therefore deﬁne two logics: HyperTSL,
allow predicates to range only over the same execution, and
HyperTSLrel, which relates multiple executions using predi-
cates.

A. HyperTSL

We deﬁne HyperTSL as an extension of TSL. The deﬁnition
of function terms τ f and predicate terms τ p are the same as
in TSL. The syntax of HyperTSL is given as follows.

ϕ ::= ∀π. ϕ | ∃π. ϕ | ψ

ψ ::= ¬ψ | ψ ∧ ψ |

ψ | ψ U ψ | τ p

π | Jc ֋ τ f Kπ

where π ∈ V, c ∈ C, τ p ∈ TP , and τ f ∈ TF . We evaluate
a HyperTSL formula ϕ with respect to a set of executions
E ⊆ Cω × I ω, an execution assignment function Π, and a

Here, #ι(·) and #ς (·) are used to project an execution on
its input stream and its computation. Given an assignment
function h·i : ΣF → F , a set of executions E satisﬁes a
HyperTSL formula ϕ, written E |=h·i ϕ, if ∅, E, 0 |=h·i ϕ.

B. HyperTSLrel

In HyperTSLrel, predicate terms are deﬁned with respect to
the set of executions variables V. If τ 1, . . . , τ n are function
terms, π1, . . . πn ∈ V, and p is an n-ary predicate symbol,
. . . τ n
then p τ 1
πn is a predicate term. The syntax of
π1
is that of HyperTSL with the exception that
HyperTSLrel
we denote predicate terms as τ p
π . The
semantics of HyperTSLrel is that of HyperTSL except for the
semantics of the predicate, which we deﬁne as follows.

π1,...,πn instead of τ p

Π, E, i |=h·i p τ 1
iff
where vj = ηh·i(#ς (Π(πj )), #ι(Π(πj )), i, τ j ) for 1 ≤ j ≤ n

hpi v1 . . . vn

π1 . . . τ n
πn

Satisfaction of a HyperTSLrel formula is deﬁned as for Hy-
perTSL.

C. HyperTSL for Smart Contracts

As for TSL, the strength of HyperTSL and HyperTSLrel is
in their use of uninterpreted predicates and functions together
with a cell mechanism. That way, the logics can describe
control ﬂow properties like “if predicate p(c) evaluates to
true, cell c should be updated by applying function f to it”.
Since the concrete implementation of p and f is not relevant
for the property, the synthesized system can be later completed
to a concrete system by implementing p and f as needed.

In this section, we showcase how the logics can express
temporal hyperproperties of smart contracts. As a running
example, we use a simple voting contract. We informally
describe the contract and specify hyperproperties that should
hold in such a contract. This showcases the expressiveness
of the logics and makes the differences in expressiveness
become clear. We postpone the formal speciﬁcation of the trace
properties of the contract to Section V.

For simplicity, we describe the core features of an ex-
emplary voting contract, which are enough to demonstrate
typical hyperproperties occurring in a voting scenario. The
contract describes an election where users can vote for either
candidate A or candidate B by calling methods voteA and
voteB. The contract can be closed by the owner, who can call
method close. voteA, voteB, and close are modeled
as booleans. We assume that in each step, exactly one of

sameWinner (π, π′) :=

W

voteA, voteB, and close holds. The contract has two
ﬁelds, votesA and votesB, to store the number of votes
recorded for the candidates. Both ﬁelds are modeled as cells
in TSL. In the smart contract setting, we use the term ﬁeld
interchangeably. Furthermore, winner holds the
and cell
current winner chosen by the contract. The winner is updated
in every step where the contract receives a vote, so either
Jwinner ֋ A()K or Jwinner ֋ B()K holds globally.
A() and B() are constants.

The hyperproperties relevant in such a setting are typical
hyperproperties such as determinism and symmetry. Consider,
for example, the question which candidate is chosen as winner
if there is a tie. One would expect a form of symmetry, e.g.,
that the winner is not simply always candidate A. Similarly,
one typically requires some sort of determinism, i.e., that
in similar situations the same winner is chosen. We use the
following syntactic sugar.

(Jwinner ֋ A()Kπ ↔ Jwinner ֋ A()Kπ′)
∧ (Jwinner ֋ B()Kπ ↔ Jwinner ֋ B()Kπ′)
The formula states that two executions π and π′ choose the
same winner.
Determinism. We state that the winner of the election is
determined by the sequence of votes received.

∀π. ∀π′. sameWinner (π, π′) W

(voteAπ = voteAπ′) ∨ (voteBπ = voteBπ′ )

(cid:2)

(cid:3)

The formula states that for any two executions, as long as they
receive the exact same votes, they should agree on who is the
winner. Alternatively, we could have stated a local version of
determinism using a greater predicate. Instead of writing
greater votesA votesB, we use the better readable inﬁx
notation with >. Note that the predicate is uninterpreted at this
stage altough we intend it to be implemented as expected. We
express that the choice of the winner is strictly determined by
the current evaluation of the > predicate on the votes and the
last vote.
∀π. ∀π′.

(cid:2)

((votesA > votesB)π ↔ (votesA > votesB)π′)
∧ ((votesB > votesA)π ↔ (votesB > votesA)π′ )
∧ (voteAπ ↔ voteAπ′ ) ∧ (voteBπ ↔ voteBπ′)
→ sameWinner (π, π′)

(cid:3)

(1)

This formula states that if A and B received the same number
of votes, the winner must be the same on both executions.
Note that the formula implicitly entails that any other predi-
cate/input does not inﬂuence the winner. For example, if there
is a predicate term sender = owner() testing whether the
caller of the method is the contract’s owner, this should not
inﬂuence the winner ﬁeld. This formulation of determinism
additionally entails that the past of an execution cannot inﬂu-
ence the choice of the winner.

In HyperTSLrel, we can express determinism by relating
executions with predicates. Instead of abstracting from the
concrete number of votes using the > predicate, we could
state local determinism as follows. As before, the = predicate
used in the formula is uninterpreted.

∀π. ∀π′.

votesAπ = votesAπ′ ∧ votesBπ = votesBπ′
→ sameWinner (π, π′)
(cid:2)

Symmetry. A prominent fairness condition in systems with
(cid:3)
multiple agents is symmetry, which requires that agents are
treated symmetrically. In the voting case, this means, e.g., that
if two traces swap the votes for A and B, then the winner must
also be swapped.

∀π. ∀π′.

(Jwinner ֋ A()Kπ ↔ Jwinner ֋ B()Kπ′ )

∧ (Jwinner ֋ B()Kπ ↔ Jwinner ֋ A()Kπ′)
(cid:2)
(voteAπ = voteBπ′) ∨ (voteBπ = voteAπ′ )
(cid:3)

(cid:2)

The fairness property implies that in case of a tie, the winner
cannot be brute-forced to always be candidate A or candidate
B.
No harm. A typical monotonicity criterion in elections states
that a vote for the currently leading candidate should not harm
the candidate. Translated to our context this means that a vote
for candidate A does not lead to B being the winner instead
of A. We formulate this condition as follows in HyperTSL.

(2)
(cid:3)

∀π. ∀π′.

xπ ↔ xπ′

U

xπ ↔ xπ′

x∈TP
(cid:0) ^

(cid:1)
∧ voteAπ ∧ voteBπ′ ∧

(cid:20)

x∈TP
(cid:0) ^

(cid:1)
xπ ↔ xπ′

(cid:0)
→ (Jwinner ֋ A()Kπ′ → Jwinner ֋ A()Kπ)

x∈(TP )\{voteA,voteB}
^

(cid:21)
(cid:1)

(3)

The formula describes two executions on which all predicate
terms evaluate to the same value except for one point in time
at which the ﬁrst execution receives a vote for A while the
second receives a vote for B. Then, A is the winner in the ﬁrst
trace whenever A is in the second one.
Elections with multiple candidates. HyperTSLrel can specify
hyperproperties in contracts with an unknown number of
candidates. Assume that instead of voteA and voteB, the
contract has a single method vote with a parameter cand
indicating which candidate the caller is voting for. We model
vote and cand as inputs. Now, the winner ﬁeld might
range over a domain of unknown size. We express determinism
as follows.

∀π. ∀π′.

(winnerπ = winnerπ′ )
W (¬(candπ = candπ′ ))

(cid:2)

IV. HYPERTSL SYNTHESIS VIA REDUCTIONS

(cid:3)

In this section, we deﬁne the synthesis problem of Hyper-
TSL and argue why HyperTSL is better suited for synthesis

∅

ǫ

{p(x)}

σ(∅)

σ({p(x)})

∅

{p(x)}

∅

{p(x)}

σ(∅∅)
...

σ(∅{p(x)})
...

σ({p(x)}∅)
...
Fig. 1: The strategy tree for a HyperTSL strategy σ branching
on a single predicate term TP = {p(x)}.

σ({p(x)}{p(x)})

...

than HyperTSLrel. HyperTSL inherits the undecidable realiz-
ability problem from TSL. We therefore show that ∀∗ Hyper-
TSL synthesis can be soundly approximated by HyperLTL, i.e,
a strategy for the HyperLTL approximation can be translated
to a strategy in HyperTSL. The ∃∗ fragment of HyperTSL
synthesis can be approximated by LTL satisﬁability to prove
unrealizability.

Deﬁnition IV.1. A HyperTSL formula ϕ is realizable iff
there exists a strategy σ : (2TP )+ → C such that for every
interpretation h·i : ΣP → F the set constructed from all input
streams satisﬁes ϕ, i.e., {(σ(ι), ι) | ι ∈ I ω} |=h·i ϕ.

The above deﬁnition deﬁnes the realizability problem of
HyperTSL by generalizing the TSL deﬁnition, similarly to how
HyperLTL generalizes LTL. The strategy has the same type
as a TSL strategy, i.e., it generates an execution by reacting
to the predicate evaluations for the current input stream. The
resulting set of executions must satisfy the HyperTSL formula.
A visualization of the deﬁnition can be found in Figure 1.

In HyperTSLrel, formulas contain predicates that relate
multiple executions. However, a system can still only react
to the inputs it receives, i.e., it cannot include the evaluation
of such predicates in its decision making. A deﬁnition of
the realizability problem could therefore only contain pred-
icates not ranging over multiple executions. This makes many
formulas unrealizable or only realizable by trivial strategies
most likely not intended by the developer. Consider the two
HyperTSLrel formulas from Section III-C again. In the ﬁrst
formula, the evaluation of the terms votesAπ = votesAπ′
and votesBπ = votesBπ′ depends on the chosen exe-
cutions π and π′ and can therefore not be known by the
system. The predicate symbol = is uninterpreted and could
be implemented with any binary predicate. A strategy must
be winning for all interpretations. The only winning strategy
is therefore the trivial strategy to set winner to either always
A() or always B(). We observe a similar phenomenon for
the second formula. Since = is an uninterpreted predicate, the
only winning strategy in this case is to always copy the value
of cand to winner.

The above observations make HyperTSL the better candi-
date to extend TSL synthesis to hyperproperties. This is only
the case for synthesis, though, and as long as predicates and
functions remain uninterpreted. If we considered HyperTSLrel
synthesis with the theory of equality, much more meaningful

strategies would be possible. HyperTSLrel might also be useful
when performing model checking, where formulas can contain
predicates that are not part of the system. TSL synthesis with
theories has only been studied in one work so far [11] and is
therefore out of the scope of this paper. TSL model checking
has not been studied at all so far. Both directions will be
exciting future work.

A. Realizability of ∀∗ HyperTSL

We show that the fact that TSL synthesis can by approx-
imated by LTL synthesis [4] carries over to ∀∗ HyperTSL.
To do so we recap the approximation of TSL in LTL [4].
The main idea of the approximation is to forget the fact
that predicates must evaluate to the same value if evaluated
on cells that hold the same value. Then, every predicate
τ p and update term Jx ֋ τ f K can be replaced with an
atomic proposition aτ p and ax to τ f , respectively, which is
denoted by syntacticConversion (ψ) for a given TSL formula
ψ. For example, syntacticConversion ( (p x → Jx ֋ f xK)
(ap x → ax to f x). We call the set of atomic
translates to
propositions obtained in that translation AP ψ. Additionally,
we ensure that in each step, exactly one update proposition
holds for each cell:

cellProps(ϕ) :=

aτ ∧

¬aτ ′

U (cid:0)
U is the set of all update terms of c and aτ is the

where T c
atomic proposition associated with term τ . Now we deﬁne

^τ ′∈T c

U \{τ }

(cid:21)
(cid:1)

c∈C
(cid:20) ^

τ ∈T c
_

[ψ]atomic := syntacticConversion (ψ) ∧ cellProps(ψ)

Given an execution e = (ς, ι) ∈ Cω × I ω and an interpretation
h·i, we deﬁne the corresponding LTL trace [e]h·i
atomic over AP ψ.

[e]h·i

atomic[i] :={aτ p | ηh·i(ς, ι, i, τ p)} ∪
{ax to τ f | ς i x ≡ τ f }

Theorem 1 in [4] shows that for a TSL formula ψ, if [ψ]atomic
is realizable, then ψ is realizable. Actually, their proof shows
the following stronger result.

Proposition IV.1 (Proof of Theorem 1 in [4]). Let ψ be a TSL
formula. For any execution e, any interpretation h·i, and any
point in time i, e, i |=h·i ψ iff [e]h·i

atomic, i |= [ψ]atomic.

This results entails that realizability of [ψ]atomic implies
realizability of ψ; the opposite direction does not hold. This is
because the semantics of TSL forbids spurious behavior, which
is not captured by the approximation in LTL. For example,
if we have Jx ֋ yK at some point in time, p(x) will be
equivalent to p(y) but ap x and ap y are different atomic
propositions with possibly different truth values assigned to
them. Therefore, every execution e can be mapped to a trace
[e]h·i
atomic, but there are traces t over AP ψ such that there is no
execution e with [e]h·i
atomic = t. The approximation is still very
valuable, because strategies found for the LTL approximations
carry over to strategies for the TSL speciﬁcation. We show that
this result can be lifted to ∀∗ HyperTSL and ∀∗ HyperLTL.

Given a set of executions E, we set [E]h·i
atomic |
e ∈ E} and also lift [·]atomic to HyperTSL formulas by setting
[τπ]atomic = ([τ ]atomic)π with τ being either a predicate term or
an update term.

atomic = {[e]h·i

Lemma IV.2. Let ϕ be a HyperTSL formula. For any set
of executions E and any interpretation h·i, E |=h·i ϕ iff
[E]h·i

atomic |= [ϕ]atomic.

atomic

Proof. Let ϕ = (∃∗∀∗)k. ψ be a HyperTSL formula consisting
of k blocks of ∃∗∀∗ quantiﬁers. For the ﬁrst direction, let
E |=h·i ϕ. We show [E]h·i
|= [ϕ]atomic. Let ϕ[i] be the
subformula of ϕ starting from the ith quantiﬁer block with 1 ≤
i ≤ k. We keep the invariant to only construct trace assign-
ments Π such that there exists an execution assignment ˆΠ with
Π(π) = [ ˆΠ(π)]h·i
atomic and ˆΠ, E, 0 |=h·i ϕ[i]. When choosing the
witness traces for the existential variables πi+1
of the
]h·i
(i + 1)th quantiﬁer block, we choose Π(πi+1
atomic
where ei+1
by the proof of satisfaction of
ϕ[i] with respect to the current execution assignment ˆΠ. Now,
by Proposition IV.1 and a simple induction over the structure
of ψ, we get Π, [E]h·i
atomic, 0 |= ψ. The argument is similar for
the other direction since for every t ∈ [E]h·i
atomic, there exists
an e ∈ E such that [e]h·i

, . . . πi+1
n
) = [ei+1

is assigned to πi+1

1

j

j

j

j

atomic = t.

Note that the above lemma does not extend to HyperTSLrel
as predicates over multiple executions cannot be mapped to
HyperLTL. From the lemma we get the following theorem.
We will also reuse the lemma in Section V.

Theorem IV.3. Let ϕ be a ∀∗ HyperTSL formula. If [ϕ]atomic
is realizable, then ϕ is realizable.

Proof. Let AP ϕ = AP in ˙∪ AP out be the atomic propositions
obtained in the translation [ϕ]atomic, where AP in are the
propositions generated for predicate terms and AP out
the
propositions for update terms, respectively. Let σHyperLTL :
(2AP in )+ → 2AP out be the realizing strategy for [ϕ]atomic. We
claim that the following strategy σ realizes ϕ.

σ (P1 · . . . · Pi) c := τ f
s.t. [Jc ֋ τ f K]atomic ∈ σHyperLTL([P1]atomic · . . . · [Pi]atomic)

Here, we lift [·]atomic to sets by [Pj ]atomic = {[τ p]atomic | τ p ∈
Pj}. By deﬁnition of cellProps, the function term τ f is unique
for every i and every cell c. We show that σ realizes ϕ. Let h·i
be any interpretation. Let E = {(σ(ι), ι) | ι ∈ I ω} be the set
of executions obtained from σ and T = traces(σ) be the set of
traces obtained from σHyperLTL. Notice that [E]h·i
atomic ⊆ T , but T
may not be a subset of [E]h·i
atomic. Since T |= [ϕ]atomic and since
universal properties are downwards-closed, also [E]h·i
atomic |=
[ϕ]atomic. Therefore, by Lemma IV.2 we have E |=h·i ϕ.

This theorem approximates ∀∗ HyperTSL synthesis by ∀∗
HyperLTL synthesis. Even for HyperLTL, this problem is
undecidable [7]. However,
there exists an implementation
of bounded synthesis for ∀∗ HyperLTL in the tool Hy-
perBoSy [7]. This approach searches for smallest systems

implementing the formula. The efﬁcient reduction from ∀∗
HyperTSL to HyperLTL opens the door to apply HyperBoSy
to HyperTSL.

B. Realizability of ∃∗ HyperTSL

Theorem IV.3 uses the downwards closedness of ∀∗ Hy-
perLTL properties. This is necessary since a strategy for Hy-
perTSL produces “fewer” traces than a strategy for the trans-
lation of the formula to HyperLTL does. Consequently, the
proof does not extend to HyperTSL formulas with existential
quantiﬁers. We show how to translate the synthesis problem of
∃∗ HyperTSL formulas to a TSL satisﬁability problem, which
we can approximate by LTL satisﬁability checking using the
translation from TSL to LTL from [4]. In contrast to the case
of ∀∗ HyperTSL formulas, the approximation of existential
properties in LTL can be used to show unrealizability instead
of realizability.

Theorem IV.4. Given an ∃∗ HyperTSL formula ϕ, there exists
a TSL formula ψTSL such that ϕ is realizable iff ψ is satisﬁable.

Proof. Let ϕ = ∃π1 . . . ∃πn. ψ. We encode the fact that all
traces in a model of ϕ are producible by a strategy:

ϕstrat := ∀π. ∀π′.

π ↔ τ u
τ u
π′

W

#

τ p
π

= τ p
π′

#

"

τ p∈TP
_

"

τ u∈TU
^

The formula states that while two executions have the same
predicate evaluations, they have to perform the same updates.
Formula ϕ′ = ∃π1 . . . ∃πn. ψ ∧ ϕstrat ensures that the exe-
cutions chosen as witnesses for π1, . . . , πn can be arranged
in a strategy tree. Thus, ϕ and ϕ′ are equi-realizable. The
additional conjunct also ensures that ϕ′ is satisﬁable iff it is
realizable. Formula ϕ′ is satisﬁable iff it is satisﬁable by n
executions. The ∀ quantiﬁers in ϕ′ quantify from these n exe-
cutions. We can therefore create an equi-satisﬁable ∃n formula
by “unrolling” the ∀ quantiﬁers. Let ϕstrat = ∀π. ∀π′. ψstrat. We
deﬁne:

ϕnew := ∃π1 . . . ∃πn. ψ ∧

ψstrat[π 7→ πi, π′ 7→ πj]

^1≤i,j≤n
Now we have that ϕ is realizable iff ϕnew is satisﬁable.
The above formula is satisﬁable iff a TSL formula ψTSL is
satisﬁable, where we construct ψTSL by creating n copies of
each input and each cell.

It is an open question whether the two approximations for ∀∗
HyperTSL and ∃∗ HyperTSL can be combined to approximate
formulas with quantiﬁer alternations. The challenge here is
that universal properties are best over-approximated to obtain
realizability results, whereas existential properties would need
an under-approximation.

V. HYPERPROPERTIES FOR SMART CONTRACT SYNTHESIS

We have shown that universal and existential HyperTSL
formulas can be approximated by HyperLTL synthesis and
LTL satisﬁability. For the case of universal properties, this

result is, as of now, mostly of theoretic interest. The realiz-
ability problem of ∀∗ HyperLTL is undecidable [7]. Bounded
hyperproperty synthesis is also still in its infancy.

In the following three sections, we therefore present a more
feasible approach to synthesize smart contract control ﬂows.
We exploit the fact that we do not synthesize a system from
hyperproperties only, but in combination with trace properties
describing the temporal behavior of the contract. We build
on a workﬂow recently developed for smart contract control
ﬂows from TSL speciﬁcations [3] and augment it with methods
for HyperTSL. In this section, we recap the TSL approach
by showing how to specify some of the trace properties
expected of a voting protocol as described in Section III-C.
We also show how to include the hyperproperties discussed
in Section III-C. In the next section, we analyze whether the
combination of hyperproperties with trace properties leads to
“pseudo” hyperproperties. In Section VII, we synthesize the
most general system from the trace properties and resolve free
choices with a repair-like algorithm.

speciﬁcation
(pastTSL)

BDD-based
synthesis

✓

free
choices?

✓ / ✘

translation
to solidity

✘

✓

reﬁne

implementation of
predicates/functions

Fig. 2: Workﬂow for the synthesis of a smart contract control
ﬂow as developed in [3].

predicates (such that the implementation respects the assump-
tions stated in the speciﬁcation), and SCSYNT generates a
Solidity smart contract.

SCSYNT specializes on a correct temporal control ﬂow
and does not check if the provided function and predicate
implementations satisfy the stated assumptions. This can be
checked by specialized tools based on SMT solving. For recent
approaches on how to combine TSL synthesis with reasoning
over theories and syntax-guided synthesis, see [11], [12].

A. Recap: Smart Contract Synthesis from TSL Speciﬁcations

B. Voting Protocol

It was recently demonstrated that the temporal behavior of
a smart contract can be extensively speciﬁed in the syntactic
safety fragment of TSL [3]. The idea of the approach is to
synthesize the underlying state machine of a smart contract
from a TSL speciﬁcation. The state machine is then trans-
lated to Solidity code, which can then be augmented with
additional functionality to obtain the desired contract. TSL
is a convenient logic to not only describe the correct order
of method calls (method “vote should not be called after
close has been successfully called”) but also how ﬁelds need
to be updated to ensure a correct control ﬂow. This can be
achieved through TSL’s cells and uninterpreted functions and
predicates. The TSL speciﬁcation abstracts from the concrete
implementation of functions and predicates and instead states
how ﬁelds have to be updated if certain predicates hold (“if
method vote is called, update the winner ﬁeld, depending
on whether votesA > votesB”).

While TSL synthesis is in general undecidable [4], correct
solutions can be found through approximation in LTL, which
works very well in practice [4]–[6]. By restricting the TSL
speciﬁcation to the past-time fragment, synthesis can be solved
comparatively fast using a BDD-based implementation in a
tool called SCSYNT [3].

The synthesis is integrated in a feedback loop as shown
in Figure 2. The user provides a past-time TSL speciﬁcation,
which is translated to LTL. If the LTL formula is unrealizable,
this might be either a speciﬁcation error or is due to the
LTL approximation (in most cases it’s the former). If the
speciﬁcation is realizable, SCSYNT returns the full winning
region – a Mealy machine that implements the speciﬁcation
and includes all realizing strategies. If there is more than one
admissible strategy, the speciﬁcation might be incomplete and
should be reﬁned. If not, or if either strategy is ﬁne, a strategy
is extracted from the winning region. In the last step, the
developer provides an implementation of the functions and

The part of the TSL voting speciﬁcation that is relevant for
this paper is depicted in Speciﬁcation 1.
Speciﬁcations
are divided into three parts. Assumptions describe properties
we can assume, e.g., that in each step only one method is
called. We also formulate assumptions on the predicates which
must be met by the user providing the implementation of
the functions and predicates. Requirements state in which
order and under which conditions methods can be called.
Obligations describe how the contract’s ﬁelds must be updated.
The speciﬁcation has four inputs. There is one input for
each method indicating the called method. The sender input
contains the caller of the method (msg.sender in Solidity).
Cells describe the ﬁelds of the contract. We use a function
addOne, which will be implemented as an increment. There
are two predicates > and =, which will be implemented as
the actual “greater” and “equals” predicate. Lastly, we use
three constants, one for each candidate A and B, and one
for the owner of the contract. Constants will be translated to
immutable Solidity ﬁelds which are set in the constructor.

Method calls are assumed to be atomic, i.e., exactly one
method is called at a time. This follows other work on
modeling the control ﬂow of smart contracts, e.g., [13], [14].
Initially, neither candidate has more votes than the other,
what can be achieved by setting votesA and votesB to
0. Lastly, keeping in mind that
the > predicate will be
implemented as the actual “greater” predicate, we assume that
votesA > votesB and votesB > votesA cannot hold
true at the same time. The requirements ensure that close can
only be invoked by the owner of the contract and that no vote
can be cast after the voting is closed. The obligations describe
the updates of the ﬁelds. When voteA or voteB is invoked,
the respective ﬁeld counting the votes must be increased.
Otherwise, the ﬁeld must self-update, i.e., stay unchanged. If a
vote is cast, then the contract must update the winner to either
A() or B(). If votesA holds more votes than votesB,

9

10

11

12

25

26

27

28

29

30

31

32

33

34

35

36

37

1 Inputs: voteA, voteB, close, reveal, sender
2 Cells: votesA, votesB
3 Functions: addOne
4 Predicates: >, =
5 Constants: owner(), A(), B()
6
7 --- Assumptions ---
8 // Mutex on methods

(voteA → ¬ voteB ∧ ¬ close);
(voteB → ¬ voteA ∧ ¬ close);
(close → ¬ voteA ∧ ¬ voteB);
(voteA ∨ voteB ∨ close);

13
14 // Arithmetic assumptions on > predicate
¬(votesA > votesB ∧ votesB > votesA);
15
16 // Initial assumption on number of votes
17 ¬(votesA > votesB) ∧ ¬(votesB > votesA);

18
19 --- Requirements ---
20

(close → sender = owner());
(close →

¬voteA ∧ ¬voteB);

21

22
23 --- Obligations ---
24

(voteA → JvotesA ֋ addOne votesAK);
(voteB → JvotesB ֋ addOne votesBK);

(¬ voteA → JvotesA ֋ votesAK);
(¬ voteB → JvotesB ֋ votesBK);

((voteA ∨ voteB)

→ Jwinner ֋ A()K∨Jwinner ֋ B()K);

((voteA ∨ voteB) ∧ votesA > votesB

→ Jwinner ֋ A()K);

((voteA ∨ voteB) ∧ votesB > votesA

→ Jwinner ֋ B()K);

(close → Jwinner ֋ winnerK);

Speciﬁcation 1: Functional speciﬁcation of the voting contract
in TSL.

the winner ﬁeld is set to A() and correspondingly to B()
if there are more votes in votesB. Once close has been
called, the winner cannot change anymore.

In this paper, we include in Speciﬁcation 1 only the trace
properties which interact with the hyperproperties we are
interested in. To obtain a satisfactory voting protocol, one
would, for example, also record the voters who already cast
their vote and require that every person only votes once
by using a predicate. This could be achieved by using a
ﬁeld voters and guard calls to voteA and voteB with
an uninterpreted predicate inVoters voters sender,
which is later implemented as expected.

The winning region synthesized from the above speciﬁca-
tion is depicted in Figure 3. We write w instead of winner,
and vA and vB instead of votesA and votesB, respectively.
We also use +1 instead of addOne. We simplify the system
by summarizing multiple transitions between the same states
with boolean formulas. For example, (¬(vA > vB) ∧ Jw ֋
B()K) ∨ (¬(vB > vA) ∧ Jw ֋ A()K) expresses that A can
be chosen as winner as long as B does not have strictly more

votes.

From the winning region we can see that the TSL speciﬁca-
tion leaves the free choice which candidate is the winner when
neither one has the majority of votes. Strategies permitted by
the winning region are, for example, to always choose A as
winner, or go for the candidate who got the last vote. Which
strategies are considered to be suitable is described by the
HyperTSL formulations of local determinism (Formula 1 in
Section III-C), symmetry (Formula 2 in Section III-C), and the
no harm property (Formula 3 in Section III-C). Our goal is to
combine the TSL speciﬁcation with the HyperTSL speciﬁca-
tions to obtain a satisfactory strategy. Since the speciﬁcation
of the voting contract abstracts from the concrete number of
votes cast with the > predicate, we need to add the following
assumption to make the combination of the speciﬁcations
realizable.

∀π. ∀π′.

((votesA > votesB)π ↔ (votesA > votesB)π′)
∧ ((votesB > votesA)π ↔ (votesB > votesA)π′ )

(cid:2)
W (voteAπ = voteAπ′ ∨ voteBπ = voteBπ′ )

(cid:3)

The property states that the evaluation of the > predicate is
the same for every two executions as long as they receive
the same sequence of votes. The property is satisﬁed when
implementing addOne as increment and > as “greater than”.
When combining the TSL speciﬁcation of the voting con-
tract with local determinism, symmetry, and the no harm
property, we observe that there is only one valid strategy left
to resolve a tie. Local determinism states that the winner may
only depend on the greater predicate on the votes and the vote
cast in the current step. This forbids to take into account the
past of the trace, e.g., by choosing the winner differently in
the ﬁrst and in the second step. Symmetry excludes to brute
force and always let the same candidate win in case of a tie.
Together with local determinism, the winner must therefore
truly depend on the current vote. In combination with local
determinism and symmetry, the no harm property forbids to
let A win if the current vote is for B (and vice versa). This
leaves as only option to resolve a tie to let the candidate win
who got the current vote. In this case, we could therefore
replace the hyperproperties with a trace property describing
exactly this strategy, which leads to a much easier synthesis
problem.

VI. PSEUDO HYPERPROPERTIES

The previous section has shown that it can be hard to see the
implications of combining several hyperproperties with trace
properties. It might be the case that the conjunction leaves
only one strategy to resolve free choices. To recognize such
situations is not easy for a human. We therefore propose to
preprocess the speciﬁcation by checking whether the hyper-
properties in conjunction with the trace properties effectively
deﬁne a trace property. To do so, we introduce the notion
of pseudo hyperproperties. We ﬁrst investigate the problem

q1

close ∧ sender = owner() ∧
¬ (vA > vB ) ∧ ¬ (vB > vA )
∧ JvA ֋ vA K ∧ JvB ֋ vBK ∧ Jw ֋ wK
¬(vA > vB) ∧ ¬(vB > vA) ∧ (Jw ֋ A()K ∨ Jw ֋ B()K)
∧ (cid:2)(voteA ∧JvA ֋ +1 vAK ∧ JvB ֋ vBK)
∨ (voteB ∧JvB ֋ +1 vBK ∧ JvA ֋ vAK)(cid:3)

q3

close ∧ sender = owner() ∧ Jw ֋ wK

close ∧ sender = owner() ∧ Jw ֋ wK

q2

(cid:2)(¬(vA > vB) ∧ Jw ֋ B()K) ∨ (¬(vB > vA) ∧ Jw ֋ A()K)(cid:3)
∧ (cid:2) (voteA ∧JvA ֋ +1 vAK ∧ JvB ֋ vBK)

∨ (voteB ∧JvB ֋ +1 vBK ∧ JvA ֋ vAK) (cid:3)

Fig. 3: Winning region for Speciﬁcation 1 as synthesized by SCSYNT [3].

for the general deﬁnition based on equivalence checking, and
subsequently consider the special case of synthesis.

Deﬁnition VI.1. A hyperproperty H is a pseudo hyperprop-
erty iff there is a trace property P such that

∀T ⊆ (2

AP

)ω. T ∈ H iff ∀t ∈ T. t ∈ P

If H is a pseudo hyperproperty, H describes the trace
T ∈H T . For proofs we will often use the

property P =
following fact.

S

Proposition VI.1. If H is a pseudo hyperproperty, then H is
closed under union and subsets.

The downwards closure property in the above proposition
implies that only hyperproperties expressible with ∀∗ formulas
can be pseudo hyperproperties. The following proposition
establishes the convenient fact that if a ∀∗ HyperTSL formula
ϕ is a pseudo hyperproperty, then the formula obtained by
using only a single execution variable in the body of the
formula is equivalent to ϕ. The proposition is close to the
corresponding result for HyperLTL, which has been observed
in context of using HyperLTL synthesis for the synthesis
of linear distributed architectures [7]. Given a HyperTSL
formula ϕ = ∀π1 . . . ∀πn. ψ, we deﬁne its ∀1 counterpart as
ϕ[π] := ∀π. ψ[π1 7→ π, . . . , πn 7→ π].

Proposition VI.2. A ∀∗ HyperTSL formula ϕ describes a
pseudo hyperproperty iff ϕ ↔ ϕ[π].

Proof. We observe that a hyperproperty H a pseudo hyper-
property iff

∀T ⊆ (2

AP

)ω. T ∈ H iff ∀t ∈ T. {t} ∈ H

Thus, for any set of executions E and any interpretation h·i,
we have E |=h·i ϕ iff ∀e ∈ E. {e} |=h·i ϕ iff E |=h·i ϕ[π].

The proposition describes how to check if a HyperTSL
property is a pseudo hyperproperty, namely by checking if
ϕ is equivalent to ϕ[π]. If it is, the TSL formula ϕ[π] can be
used for synthesis. The check is undecidable for HyperTSL,
however.

Theorem VI.3. It is undecidable whether a HyperTSL formula
ϕ describes a pseudo hyperproperty.

Proof. The proof follows from undecidability of the satisﬁabil-
ity problem of TSL [10]. The formula ϕ = ∀π. ∀π′.(p a)π ↔

(p a)π′
is not a pseudo hyperproperty as there exists an
interpretation of p such that E consists of executions for which
p a always evaluates to true, and E′ consists of executions
for which p a always evaluates to false. E and E′ are not
closed under union for ϕ. Now, let a TSL formula ψ be given
for which we assume w.l.o.g. that p is a fresh predicate and a
a fresh input. Since ∀π. ∀π′. false is a pseudo hyperproperty,
the formula ∀π. ∀π′. ((p a)π ↔ (p a)π′ ) ∧ ψπ is a pseudo
hyperproperty iff ψ is unsatisﬁable. Here, ψπ denotes the
formula obtained by lifting ψ to a HyperTSL formula by
annotating predicate and update terms with the trace variables
π.

Fortunately, the above negative result comes with the rem-
edy that we can approximate the problem in HyperLTL, which
is a result of Lemma IV.2.

Theorem VI.4. Let ϕ be a HyperTSL formula. If [ϕ]atomic is
a pseudo hyperproperty, then so is ϕ.

atomic =

e∈E[e]h·i

atomic, and E ⊆ E′ iff [E]h·i
S

atomic, i.e., [E ∪ E′]h·i
atomic ⊆ [E′]h·i
atomic.

Proof. Closedness under union and subsets follows from
Lemma IV.2 and since for every set of executions E and in-
terpretation h·i, [E]h·i
atomic =
atomic ∪ [E′]h·i
[E]h·i
Using the above result, we can translate a ∀∗ HyperTSL
formula to HyperLTL and check its equivalence with the
corresponding ∀1 formula. For HyperLTL, this check is de-
cidable, because of the decidability of the ∃∗∀∗ fragment of
HyperLTL [7]: a HyperLTL formula ϕ = ∀π1 . . . ∀πn. ψ is
equivalent to its ∀1 counterpart ϕ[π] iff ϕ[π] → ϕ (because
of the semantics of the ∀). By merging the quantiﬁers, this
implication is valid iff the formula

∃π1 . . . ∃πn. ∀π. ¬ψ ∧ ψ[π1 7→ π, . . . πn 7→ π]

is unsatisﬁable. Thus, if the check returns UNSAT, the Hyper-
TSL formula is guaranteed to describe a pseudo hyperproperty,
so we can replace the hyperproperty with its TSL version.

So far, we described the check for pseudo hyperproperties
in terms of satisﬁability checking. This can be useful
to
detect superﬂuous speciﬁcations or mistakes. For example, the
developer could have already speciﬁed in TSL that in case of
a tie, the current vote determines the winner.

(¬(votesA > votesB) ∧ ¬(votesB > votesA)
→ Jwinner ֋ A()K ↔ voteA)

With this speciﬁcation,
the hyperproperties stated in Sec-
tion III-C are entailed by the speciﬁcation. In the case of the
“no harm” property, for example, the check with EAHyper
reveals correctly within 0.003 seconds that the conjunction of
the trace properties with the “no harm” property is a pseudo
hyperproperty.

Without the above TSL speciﬁcation however, the check
for the conjunction of local determinism, symmetry, and the
no harm property is labeled as a hyperproperty by EAHyper,
even though there is only one possible strategy. The reason for
that is the difference between realizability and satisﬁability.
Consider the following two traces.

(1) {voteA, Jwinner ֋ A()K}ω
(2) {voteB, Jwinner ֋ A()K}ω

In the ﬁrst trace, neither votesA > votesB nor votesB >
votesA, and there is always a vote for A, who is always
the winner. The second trace is similar but there is always
a vote for B. As single sets, both traces satisfy all three hy-
perproperties. Together, they do not (because of the symmetry
requirement). Therefore, EAHyper returns that the conjunction
of the properties is not a pseudo hyperproperty (even in
combination with the full contract speciﬁcation). When solving
the realizability problem, however, we do not need to ﬁnd an
equivalent trace property, it is enough to ﬁnd a trace property
which evaluates the same on all sets generated by strategies.
We therefore adapt the notion of pseudo hyperproperties to
realizability. We give the deﬁnition for hyperproperties of
traces over AP in ˙∪ AP out , but the deﬁnition applies to traces
of any type, particularly also to hyperproperties over TSL-like
executions.

Deﬁnition VI.2. Let H be a hyperproperty over atomic propo-
sitions AP = AP in ˙∪ AP out . H is a pseudo hyperproperty in
the context of realizability if there is a trace property P such
that

∀σ : (2

AP in )+ → 2

AP out .

traces(σ) ∈ H iff ∀t ∈ traces(σ). t ∈ P

The deﬁnition implies that a HyperTSL formula ϕ is a
pseudo hyperproperty in the context of realizability iff there
is a TSL formula ψ such that a strategy σ realizes ϕ iff σ
realizes ψ. In the context of realizability, however, ψ may
not be equivalent to ϕ[π]. To show why, we give an example
in HyperLTL but the reasoning carries over to HyperTSL.
Consider the example of the following HyperLTL formulas
over input i and output o, which are abstract, simpliﬁed
versions of local determinism, symmetry, and the no harm
property.

∀π. ∀π′. (iπ ↔ iπ′ ) → (oπ ↔ oπ′ )
∀π. ∀π′. (iπ = iπ′ ) → (oπ = oπ′ )
∀π. ∀π′. iπ ∧ ¬iπ′ ∧ oπ′ → oπ

The properties are not temporal, so they are realizable iff there
are values o1, o2 such that {{i, o1}ω, {¬i, o2}ω} satisﬁes the

three formulas. Let ϕ be their conjunction. There are only
four possible assignments of o1, o2 to boolean values, each
of which corresponds to a possible strategy. Indeed, for every
possible strategy, ϕ is satisﬁed iff the trace property i ↔ o
is satisﬁed. However, the same does not hold for the trace
property true, which is equivalent to ϕ[π]. Unfortunately, the
general problem is undecidable already for HyperLTL, due
to the undecidability of the realizability problem of the ∀∗
fragment of HyperLTL.

Theorem VI.5. Given a HyperLTL formula ϕ, it is in general
undecidable if there exists an LTL formula ψ such that for all
strategies σ, traces(σ) |= ϕ iff ∀t ∈ traces(σ). t |= ψ.

Proof. We show undecidability by a reduction from the ∀∗
HyperLTL realizability problem, which is undecidable [7]. Let
ρ be a ∀∗ HyperLTL formula over AP = AP in ˙∪ AP out .
We assume w.l.o.g. that AP in is non-empty. We deﬁne ϕ as
follows, where o is an output proposition that does not occur
in ρ.

ϕ := ρ ∧ ∀π. ∀π′. oπ ↔ oπ′

We claim that ρ is unrealizable iff there exists an LTL
formula ψ such that for all strategies σ, traces(σ) |= ϕ iff
∀t ∈ traces(σ). t |= ψ. If ρ is unrealizable, then we choose
ψ := false. Since ρ is unrealizable, it holds for all σ that
traces(σ) 6|= ϕ iff ∀t ∈ traces(σ). t |= ψ. For the other
direction, assume that ρ is realizable and that there exists a
suitable LTL formula ψ. Let σ be the realizing strategy of ρ.
Since o is fresh for ρ, we can extend σ to σ1 and σ2, where σ1
adds o to the ﬁrst output (for any input), and σ2 does not add
o (also for any input). Both strategies realize ϕ, therefore, by
our assumption, both strategies realize ψ. Now, let i ∈ AP in
be any input. We deﬁne σ3 as the strategy that adds o to the
ﬁrst output exactly if i holds in the ﬁrst position of the input
sequence. Since every trace generated by σ3 is either a trace
of σ1 or σ2, σ3 realizes ψ. However, it does not realize ϕ,
which contradicts our assumption.

Lastly, we observe that we can decide if a HyperTSL
formula is a pseudo hyperproperty if the formula contains
as conjunct a local determinism formula like the one in our
running example. We deﬁne local determinism in the general
case as follows.

localDeterminism :=

∀π. ∀π′.

((

π ↔ τ p
τ p

π′) → (

π ↔ τ c
τ c

π′ ))

τ p∈TP
^

τ c∈TU
^

Proposition VI.6. For every ∀∗ HyperTSL formula ϕ
over predicate terms TP and update terms TU ,
if ϕ =
localDeterminism ∧ ϕ′, then deciding whether ϕ is a pseudo
hyperproperty in the context of realizability is equivalent to a
SAT problem.

The above proposition follows from the observation that
localDeterminism ∧ ϕ is realizable iff there is a positional
strategy that always assigns the same cell updates for the same
predicate evaluations, independently of the trace’s past. In this

case, there are only ﬁnitely many combinations of predicate
evaluations and the problem becomes ﬁnite.

VII. RESOLVING CHOICES WITH REPAIR

If a hyperproperty is not a pseudo hyperproperty, we synthe-
size the winning region of the trace property and then check
if free choices can be resolved such that the hyperproperty is
satisﬁed. This is a repair algorithm additionally respecting the
distinction between inputs and outputs. We ﬁrst give a formal
deﬁnition of the problem we are interested in for HyperTSL
formulas. As observed several times, the formal problem is
undecidable for HyperTSL, but a sound approximation can
be achieved through HyperLTL. We then discuss how to
simplify the problem for ∀∗ formulas and present a prototype
implementation, which successfully repairs the synthesized
voting contract with respect to determinism, symmetry, and
the no harm property.

The result of synthesizing the extended control ﬂow of a
smart contract from TSL speciﬁcations is a Mealy machine as
depicted in Figure 3. A Mealy machine is a tuple (Q, Σ, δ, q0),
where Q is a set of states, Σ = 2AP with AP = AP in ˙∪AP out
is a labeling alphabet, δ : Q × Σ → Q is a transition function,
and q0 is the initial state.

Deﬁnition VII.1. A free choice in a Mealy machine
(Q, Σ, δ, q0) consists of a state q ∈ Q and an input i ∈ 2AP in
such that there are at least two outputs o1, o2 ∈ 2AP out with
(q, i ∪ o1, q1) ∈ δ and (q, i ∪ o2, q2) ∈ δ for some q1, q2.
Deﬁnition VII.2. A Mealy machine ˆS is a reﬁnement of a
Mealy machine S if ˆQ = Q, ˆΣ = Σ, ˆq0 = q0 and ˆδ ⊆ δ such
that for every q ∈ Q, i ∈ 2AP in , if there are o ∈ 2AP out and
q′ ∈ Q such that δ(q, i ∪ o, q′), then there are ˆo ∈ 2AP out and
ˆq′ ∈ ˆQ such that ˆδ(q, i ∪ ˆo, ˆq′) and δ(q, i ∪ ˆo, ˆq′).

The above deﬁnition ensures that if S deﬁnes a set of
strategies for a TSL property ψ, then a reﬁnement ˆS still
describes at least one strategy for ψ. Our goal is to reﬁne
S such that ˆS models a HyperTSL property ϕ.

The system S is produced from the LTL approximation,
it might
therefore contain spurious traces which, for any
interpretation, cannot be produced by a combination of an
input stream and a computation. We deﬁne when such a system
satisﬁes a HyperTSL formula.

Deﬁnition VII.3. Let ϕ be a HyperTSL formula over TP , TU
and let S be a Mealy machine over AP = [TP ]atomic ∪
[TU ]atomic. S models ϕ if for every interpretation h·i:

{(ς, ι) | ∃t ∈ traces(S). t = [(ς, ι)]h·i

atomic} |=h·i ϕ

The deﬁnition creates for each interpretation the set of
executions which have a trace through S and then checks if ϕ
is satisﬁed on these sets. We show that we cannot check the
satisfaction of a HyperTSL formula on such a system directly.

Lemma VII.1. Given a HyperTSL formula ϕ, it is undecidable
whether a Mealy machine S over AP = [TP ]atomic ∪ [TU ]atomic
models ϕ.

Proof. We show that the problem is already undecidable for
TSL formulas expressed in HyperTSL as ∀π. ψπ, where ψπ is
the π-indexed version of a TSL formula ψ . We proceed by
reduction from the unsatisﬁability problem of TSL. Let ψ be
a TSL property. ψ is unsatisﬁable if for every h·i and every ς,
ι, it holds that ς, ι |=h·i ¬ψ. Let S be the system that produces
every trace over AP = [TP ]atomic ∪ [TU ]atomic. Then, S models
∀π. ¬ψπ iff ψ is unsatisﬁable.

However, owing to Lemma IV.2, for every ∀∗ HyperTSL
formula ϕ, if a Mealy machine S models [ϕ]atomic, then it also
models ϕ.

Theorem VII.2. Let a ∀∗ HyperTSL formula and a Mealy
machine S over AP = [TP ]atomic ∪ [TU ]atomic be given. If S
models [ϕ]atomic, then S models ϕ.

atomic}. By construction, [Sh·i]h·i

Proof. For every h·i, let Sh·i = {(ς, ι) | ∃t ∈ traces(S). t =
[(ς, ι)]h·i
atomic ⊆ traces(S). Since
S |= [ϕ]atomic and since universal properties are downwards
closed, [Sh·i]h·i
atomic |= [ϕ]atomic and by Lemma IV.2 we have
Sh·i |=h·i ϕ.

Based on this theorem, we repair the synthesized transition
system with respect to the corresponding HyperLTL formula.
To do so, we enumerate all reﬁnements which leave exactly
one transition for each choice. Thereby, the reﬁnement still
implements a strategy. Since the HyperLTL is a universal
formula, this approach detects a correct reﬁnement iff there
is one. Note that also with respect to HyperLTL, this cannot
be a complete method, as ∀∗ HyperLTL synthesis is undecid-
able [7]. The general problem of repairing HyperLTL formulas
has been discussed in [15], the problem is NP-complete for
∀∗ HyperLTL. An approach similar to our has been described
for controller synthesis in [16], which distinguishes between
controllable and uncontrollable inputs. Implementations have
not been developed yet.

VIII. IMPLEMENTATION AND EXPERIMENTS

We implemented a prototype of the repair algorithm as a
Python script. Given a synthesized smart contract in form
of a Mealy machine and a universal HyperLTL formula, the
script checks if the complete system satisﬁes the property. If
not, it searches for free choices, performs a self-composition,
and checks if one of the possibilities to resolve the choices
satisﬁes the LTL body of the HyperLTL formula. For LTL
model checking we use the state-of-the-art model checker
nuXmv [17]. Using our implementation, we conducted exper-
iments on different version of the voting contract and on a
blinded auction contract.

A. Voting Contract

We repaired four variants of the voting protocol with respect
to the hyperproperties described in this paper. The results
are depicted in Table I. None of the three systems initially
satisﬁes either of the properties, the number of calls given in
the table therefore refers to the number of reﬁnements tested
with nuXmv.

TABLE I: Results of the prototype implementation of the
repair algorithm. Times (t) are given in seconds. # refers to
the number of nuXmv calls that were needed to ﬁnd a repair.

Property

only vote
#

t

+ close
#

t

+ owner
#
t

Local determinism 0.170

Local symmetry

Global no harm

Determinism

Symmetry

No harm

Determinism
+ Symmetry
+ No harm

0.229

0.163

0.147

0.254

0.170

0.274

1

2

1

1

2

1

3

0.475

1.251

0.473

0.612

1.630

0.704

2.105

1

6

1

1

6

1

6

full

t

7.049

#

1

308.1

120

219.9

86

6.825

6.571

1

1

90.81

35

2.577

64.90

2.786

27.63

29.03

2.993

1

86

1

35

35

1

217.7

256

760.4

256

The ﬁrst variant (“only vote”) reduces the contract to
the core speciﬁcation needed for the hyperproperties to make
sense. It has only a vote method and can be implemented as
a single-state system. It has two state-input combinations with
a free choice, in each case there are two possible transitions.
The second variant (“+ close”) adds the close method and
initial assumptions, resulting in a three-state system with four
choices, again each with two options. The third variant (“+
owner”) is the contract as described in Speciﬁcation 1. It has
eight choices. This results in 28 different combinations that
might need to be checked.

Lastly, we extended the voting contract with additional
features following the voting example of the Solidity Docu-
mentation [18]. The extended version additionally records the
registered voters in a ﬁeld voters and which addresses have
voted in a ﬁeld voted. The contract also has two additional
methods: giveRightToVote may be called by the owner
of the contract and adds addresses to voters; getWinner
may be called after the voting has been closed to learn which
candidate won. The synthesized state machine has again eight
choices but is naturally larger than the state machine depicted
in Figure 3.

Determinism, local determinism, symmetry, and the no harm
property indicate the formulas given in Section III-C. For
symmetry, we included the necessary assumption described in
Section V-B. The “global no harm” property formulates the no
harm property with a single
instead of W . Local symmetry
states symmetry with respect to the greater predicate as well as
the voteA and voteB inputs, similar to local determinism.

B. Blind Auction

As a second contract, we speciﬁed a blind auction in TSL,
following [19]. Similar to the voting protocol, we had to
restrict ourselves to a ﬁnite number of bidders, otherwise the
hyperproperties would not have been expressible in HyperTSL.
The idea of a blind auction is that bidders send a hash of
their actual bid and deposit a value which might be higher or
lower than the actual bid. After the bidding is closed, bidders
reveal their bids. If the hash ﬁts the revealed bid and the

deposited value is higher than the actual bid, the bid is valid.
The winner of the auction is the bidder with the highest valid
bid. Bidders can also withdraw their deposits once a higher
bid was revealed.

We speciﬁed the contract with two bidders. We use meth-
ods bidA, bidB, closeBidding, revealA, revealB,
closeRevealing, and withdraw. One of the temporal
requirements is that bids can only be placed as long as the
bidding has not been closed.

(closeBidding →

¬(bidA ∨ bidB))

The speciﬁcation also reasons about ﬁelds bidsA, bidsB,
highestBidder, highestBid. One of the obligations on
the ﬁelds is to update highestBid if bidder A reveals a
correct bid which is higher than all bids revealed so far.

(revealA ∧ valid bid secret

∧ bid > highestBid
→ JhighestBid ֋ bidK)

Similar

In the above speciﬁcation, bid and secret are parameters
of the method revealA. As for the voting speciﬁcation, the
TSL speciﬁcation describes the control ﬂow of the contract,
i.e., in which order methods have to be called and how ﬁelds
need to be updated. Other functionality like checking if a bid
is valid needs to be implemented in the predicate validBid
to obtain a working contract.
to

TABLE II: Repairing the blind auction
state machine. Times (t) are given in
seconds. # refers to the number of
nuXmv calls.

the
case, we
voting
left the free choice
which bid is stored
as highest bid if the
revealed
currently
bid is the same is
the current highest
bid. The synthesized
state machine leaves
free choices at two
nodes. Using our implementation, we obtained strategies
to resolve a tie in a way that local determinism or local
the running times and
symmetry are satisﬁed. We report
number of calls to nuXmv in Table II.

Local determinism 11.13s

Local symmetry

Property

17.42s

2

1

#

t

C. Evaluation

Our experiments show that the hyperproperties discussed in
this paper are realizable on top of variants of a voting contract
and a blinded auction. The evaluation shows that the runtime
mainly depends on the number of choice options that had to
be tested with NUXMV. The runtime also increases with larger
formulas and larger state machines.

This implementation is only a prototype to see if the idea to
resolve free choices via repair works for relevant hyperprop-
erties. There are many options to improve performance. For
example, one could switch to a model checker that is based on
B¨uchi or Parity automata (e.g., spot [20]). Like this, the LTL
formula (which stays the same for every call) would only have
to be translated to an automaton only once.

IX. RELATED WORK

Our work brings together research on formal methods for
smart contract control ﬂows, reactive synthesis using TSL, and
logics for hyperproperties.
Formal methods for smart contract control ﬂows. Most
closely related work is the recent approach to synthesize
the control and data ﬂow of a smart contract from TSL
speciﬁcations [3]. We build on the fact that they synthesize
the full winning region of the speciﬁcation, which we reﬁne to
ﬁnd a strategy that satisﬁes a HyperTSL speciﬁcation. Another
approach to synthesize smart contract control ﬂows is [21],
which synthesizes the order of method calls from an LTL
speciﬁcation. Formal guarantees have been also obtained by
modeling the control ﬂow of a contract directly with a ﬁnite
state machine and transform the state machine to Solidity
code. In the FSOLIDM framework [13] the state machine can
be modeled in a graphical editor. A lot of work has been
invested to verify a contract against correctness properties
instead of generating it automatically. The VERISOL [14], [22]
framework checks a smart contract against properties deﬁned
with ﬁnite state machines. VERX [23] and SMARTPULSE [24]
verify that a contract satisﬁes speciﬁcations given in LTL-like
logics, where SMARTPULSE can handle not only safety but
also liveness properties.
Temporal Stream Logic. TSL is a temporal
logic that
has been developed to simplify reasoning about
inﬁnite-
state systems by separating control and data [4]. Due to its
expressiveness, TSL synthesis is undecidable in general but
sound CEGAR loops based on LTL synthesis work well in
practice [4]. TSL has been successfully applied to specify and
synthesize an arcade shooter game running on an FPGA [5]
and functional reactive programs [6]. The TSL synthesis
approach has been extended with decidable theories like linear
integer arithmetic [11]. Here, counterexamples provided by
the CEGAR loop are checked for consistency with the theory
using an SMT solver. TSL modulo ﬁrst-order theories has also
been studied with respect to its satisﬁability problem [10].
Hyperproperties. The interest in hyperproperties, or relational
properties, stems from information ﬂow policies like non-
interference and observational determinism. Since the term
has been coined for the general class of properties [25], a
range of logics have been developed for the speciﬁcation of
hyperproperties. Examples are temporal logics like HyperLTL,
HyperCTL∗ [8], and HyperPDL [26], ﬁrst-order and second-
order logics [27], [28], or asynchronous extensions mostly
based on HyperLTL [29]–[31]. All of the above logics are
targeted to specify properties in the context of hardware and
therefore assume a ﬁnite state space. Recently, the temporal
logic of actions (TLA) has also been used to verify hy-
perproperties via self-composition [32]. The synthesis from
hyperproperties is known to be challenging. HyperLTL can ex-
press distributed architectures, which makes the synthesis from
∀∗ properties already undecidable [7]. A simpler variant of
synthesis is controller synthesis, where the state space is given.
Related to our approach, the resulting problem is similar to the

repair problem and is therefore decidable for HyperLTL [16].
The classic program repair problem does not distinguish
between inputs and outputs and has been studied for HyperLTL
as well [15]. The analysis of smart contract with respect
to hyperproperties has not received enough attention yet. A
recent approach uses type-checking to ensure information ﬂow
policies such as integrity in smart contracts in the context of
reentrancy attacks [1]. Other hyperproperties identiﬁed in the
context of smart contracts are integrity properties to prevent
reentrancy attacks [33], [34]

X. CONCLUSION AND FUTURE WORK

We have presented two logics, HyperTSL and HyperTSLrel,
which extend the temporal logic TSL to express hyperproper-
ties. Inherited from TSL, both logics express the control ﬂow
of inﬁnite-state systems by abstracting from concrete data with
cells and uninterpreted functions and predicates. HyperTSLrel
predicates relate several executions, which makes the logic
more expressive than HyperTSL. HyperTSL, on the other
hand, is more suitable for synthesis tasks. We have demon-
strated that both logics can express typical hyperproperties
that occur in the context of smart contracts. The realizabil-
ity problem of the universal fragment of HyperTSL can be
approximated with HyperLTL realizability, the unrealizability
problem of the existential fragment can be approximated with
LTL satisﬁability. As a step towards making synthesis from
hyperproperties reality, we have described two approaches to
integrate universal HyperTSL speciﬁcations in the synthesis
workﬂow of smart contracts speciﬁed with TSL. The ﬁrst
approach checks for overly complicated speciﬁcations which
have equivalent formulations in TSL. The second approach
reﬁnes the winning region obtained from the TSL synthesis to
resolve choices in a way that satisfy the hyperproperty.
Future work. This work has opened many interesting
paths for future work. To proﬁt from the expressiveness
of HyperTSLrel, one would have to include theories (e.g.,
the theory of equality) into the synthesis from HyperTSLrel
speciﬁcations. Prior work has made steps in that direction for
TSL [10], [11], one could extend these ideas to HyperTSLrel.
Using theories, HyperTSLrel would also be interesting in the
context of model checking smart contracts or other inﬁnite-
state systems. Another open question is how to approximate
the HyperTSL realizability problem for formulas with quanti-
ﬁer alternations.

REFERENCES

[1] E. Cecchetti, S. Yao, H. Ni, and A. C. Myers, “Compositional
reentrant applications,” in 42nd IEEE Symposium on
security for
Security and Privacy, SP 2021, San Francisco, CA, USA, 24-
27 May 2021.
[Online]. Available:
https://doi.org/10.1109/SP40001.2021.00084

IEEE, 2021, pp. 1249–1267.

[2] ——, “Securing smart contracts with information ﬂow,” in International
Symposium on Foundations and Applications of Blockchain, 2020.
[3] B. Finkbeiner, J. Hofmann, F. Kohn, and N. Passing, “Reactive
synthesis of smart contract control ﬂows,” 2022. [Online]. Available:
https://arxiv.org/abs/2205.06039

[4] B. Finkbeiner, F. Klein, R. Piskac, and M. Santolucito, “Temporal
Stream Logic: Synthesis Beyond the Bools,” in Computer Aided Ver-
iﬁcation - 31st International Conference, CAV 2019, New York City,
NY, USA, July 15-18, 2019, Proceedings, Part I, ser. Lecture Notes in
Computer Science, I. Dillig and S. Tasiran, Eds., vol. 11561. Springer,
2019, pp. 609–629.

[5] G. Geier, P. Heim, F. Klein,

“Syntroids:
Synthesizing
logic
speciﬁcations,” CoRR, vol. abs/2101.07232, 2021. [Online]. Available:
https://arxiv.org/abs/2101.07232

and B. Finkbeiner,
using
fpgas

temporal

game

for

a

[6] B.

Piskac,

Finkbeiner,

F. Klein, R.

Santolucito,
in Proceedings of
“Synthesizing functional
the 12th ACM SIGPLAN International Symposium on Haskell,
Haskell@ICFP 2019, Berlin, Germany, August 18-23, 2019, R. A.
[Online]. Available:
Eisenberg, Ed. ACM, 2019, pp. 162–175.
https://doi.org/10.1145/3331545.3342601

reactive programs,”

and M.

[7] B.

Finkbeiner,

C. Hahn,

L. Tentrup, “Synthesis
vol.
no.
https://doi.org/10.1007/s00236-019-00358-2

137–163,

1-2,

57,

pp.

P.

Lukert, M.

and
from hyperproperties,” Acta Informatica,
[Online]. Available:

Stenger,

2020.

[8] M. R. Clarkson, B. Finkbeiner, M. Koleini, K. K. Micinski, M. N.
Rabe, and C. S´anchez, “Temporal
logics for hyperproperties,” in
Principles of Security and Trust - Third International Conference,
POST 2014, Held as Part of the European Joint Conferences on Theory
and Practice of Software, ETAPS 2014, Grenoble, France, April 5-13,
2014, Proceedings, ser. Lecture Notes in Computer Science, M. Abadi
and S. Kremer, Eds., vol. 8414. Springer, 2014, pp. 265–284. [Online].
Available: https://doi.org/10.1007/978-3-642-54792-8 15

[9] B. Finkbeiner, C. Hahn, P. Lukert, M. Stenger, and L. Tentrup, “Synthe-
sizing reactive systems from hyperproperties,” in Proceedings of CAV,
ser. LNCS, vol. 10981. Springer, 2018, pp. 289–306.

[10] B. Finkbeiner, P. Heim, and N. Passing, “Temporal stream logic
modulo theories,” in Foundations of Software Science and Computation
Structures - 25th International Conference, FOSSACS 2022, Held as
Part of the European Joint Conferences on Theory and Practice of
Software, ETAPS 2022, Munich, Germany, April 2-7, 2022, Proceedings,
ser. Lecture Notes in Computer Science, P. Bouyer and L. Schr¨oder,
Eds., vol. 13242. Springer, 2022, pp. 325–346. [Online]. Available:
https://doi.org/10.1007/978-3-030-99253-8 17

[11] B. Maderbacher and R. Bloem, “Reactive synthesis modulo theories
using abstraction reﬁnement,” CoRR, vol. abs/2108.00090, 2021.
[Online]. Available: https://arxiv.org/abs/2108.00090

[12] W. Choi, B. Finkbeiner, R. Piskac, and M. Santolucito, “Can reactive
synthesis and syntax-guided synthesis be friends?” in PLDI ’22: 43rd
ACM SIGPLAN International Conference on Programming Language
Design and Implementation, San Diego, CA, USA, June 13 - 17, 2022,
R. Jhala and I. Dillig, Eds. ACM, 2022, pp. 229–243. [Online].
Available: https://doi.org/10.1145/3519939.3523429

[13] A. Mavridou and A. Laszka, “Designing secure ethereum smart
contracts: A ﬁnite state machine based approach,” in Financial
Cryptography and Data Security - 22nd International Conference, FC
2018, Nieuwpoort, Curac¸ao, February 26 - March 2, 2018, Revised
Selected Papers, ser. Lecture Notes in Computer Science, S. Meiklejohn
and K. Sako, Eds., vol. 10957. Springer, 2018, pp. 523–540. [Online].
Available: https://doi.org/10.1007/978-3-662-58387-6 28

[14] Y. Wang, S. K. Lahiri, S. Chen, R. Pan, I. Dillig, C. Born, I. Naseer,
and K. Ferles, “Formal veriﬁcation of workﬂow policies for smart
contracts in azure blockchain,” in Veriﬁed Software. Theories, Tools,
and Experiments - 11th International Conference, VSTTE 2019, New
York City, NY, USA, July 13-14, 2019, Revised Selected Papers, ser.
Lecture Notes in Computer Science, S. Chakraborty and J. A. Navas,
Eds., vol. 12031.
Springer, 2019, pp. 87–106. [Online]. Available:
https://doi.org/10.1007/978-3-030-41600-3 7
Finkbeiner,

for
for Veriﬁcation and
hyperproperties,”
Analysis
- 17th International Symposium, ATVA 2019, Taipei,
Taiwan, October 28-31, 2019, Proceedings, ser. Lecture Notes in
Computer Science, Y. Chen, C. Cheng, and J. Esparza, Eds.,
vol. 11781.
[Online]. Available:
https://doi.org/10.1007/978-3-030-31784-3 25

Springer, 2019, pp. 423–441.

in Automated Technology

[15] B. Bonakdarpour

“Program repair

and B.

[16] ——, “Controller

synthesis

in 33rd IEEE
Computer Security Foundations Symposium, CSF 2020, Boston, MA,
USA, June 22-26, 2020.
IEEE, 2020, pp. 366–379. [Online]. Available:
https://doi.org/10.1109/CSF49147.2020.00033

for hyperproperties,”

[17] R. Cavada, A. Cimatti, M. Dorigatti, A. Griggio, A. Mariotti, A. Micheli,
S. Mover, M. Roveri, and S. Tonetta, “The nuxmv symbolic model
checker,” in CAV, 2014, pp. 334–342.
documentation,”
the
https://docs.soliditylang.org/en/v0.8.13/solidity-by-example.html#voting,
2022, accessed: 2022-05-12.
example
auction

documentation,”

[18] “Voting

[19] “Blind

from the

example

solidity

solidity

from

https://docs.soliditylang.org/en/v0.8.13/solidity-by-example.html#blind-auction,
2022, accessed: 2022-05-12.

[20] A. Duret-Lutz, A. Lewkowicz, A. Fauchille, T. Michaud, E. Renault, and
L. Xu, “Spot 2.0 — a framework for LTL and ω-automata manipulation,”
in Proceedings of
the 14th International Symposium on Automated
Technology for Veriﬁcation and Analysis (ATVA’16), ser. Lecture Notes
in Computer Science, vol. 9938. Springer, Oct. 2016, pp. 122–129.

[21] D. Suvorov and V. Ulyantsev, “Smart contract design meets state
machine synthesis: Case studies,” CoRR, vol. abs/1906.02906, 2019.
[Online]. Available: http://arxiv.org/abs/1906.02906

[22] S. K. Lahiri, S. Chen, Y. Wang,

“Formal
speciﬁcation
azure
of
blockchain,” CoRR, vol. abs/1812.08829, 2018. [Online]. Available:
http://arxiv.org/abs/1812.08829

veriﬁcation

I. Dillig,

contracts

smart

and

and

for

[23] A. Permenev, D. K. Dimitrov, P. Tsankov, D. Drachsler-Cohen, and
M. T. Vechev, “Verx: Safety veriﬁcation of smart contracts,” in 2020
IEEE Symposium on Security and Privacy, S&P 2020, San Francisco,
CA, USA, May 18-21, 2020.
IEEE, 2020, pp. 1661–1677. [Online].
Available: https://doi.org/10.1109/SP40000.2020.00024

[24] J. Stephens, K. Ferles, B. Mariano, S. K. Lahiri, and I. Dillig,
“Smartpulse: Automated checking of temporal properties in smart
contracts,” in 42nd IEEE Symposium on Security and Privacy, SP 2021,
San Francisco, CA, USA, 24-27 May 2021.
IEEE, 2021, pp. 555–571.
[Online]. Available: https://doi.org/10.1109/SP40001.2021.00085
[25] M. R. Clarkson and F. B. Schneider, “Hyperproperties,” in Proceedings
of
IEEE Computer Security Foundations Symposium,
CSF 2008, Pittsburgh, Pennsylvania, USA, 23-25 June 2008.
IEEE Computer Society, 2008, pp. 51–65.
[Online]. Available:
https://doi.org/10.1109/CSF.2008.7

the 21st

[26] J. O. Gutsfeld, M. M¨uller-Olm, and C. Ohrem, “Propositional
dynamic logic for hyperproperties,” in 31st International Conference
on Concurrency Theory, CONCUR 2020, September 1-4, 2020,
Vienna, Austria
I. Konnov
and L. Kov´acs, Eds., vol. 171.
- Leibniz-
Zentrum f¨ur Informatik, 2020, pp. 50:1–50:22. [Online]. Available:
https://doi.org/10.4230/LIPIcs.CONCUR.2020.50

ser. LIPIcs,
Schloss Dagstuhl

(Virtual Conference),

[27] B. Finkbeiner and M. Zimmermann, “The ﬁrst-order

logic of
hyperproperties,” CoRR, vol. abs/1610.04388, 2016. [Online]. Available:
http://arxiv.org/abs/1610.04388

[28] N. Coenen, B. Finkbeiner, C. Hahn,

“The
hierarchy of hyperlogics,” in 34th Annual ACM/IEEE Symposium on
Logic in Computer Science, LICS 2019, Vancouver, BC, Canada,
June 24-27, 2019.
[Online]. Available:
IEEE, 2019, pp. 1–13.
https://doi.org/10.1109/LICS.2019.8785713

and J. Hofmann,

[29] J. Baumeister, N. Coenen, B. Bonakdarpour, B. Finkbeiner, and
C. S´anchez, “A temporal logic for asynchronous hyperproperties,” in
Computer Aided Veriﬁcation - 33rd International Conference, CAV
2021, Virtual Event, July 20-23, 2021, Proceedings, Part
I, ser.
Lecture Notes in Computer Science, A. Silva and K. R. M. Leino,
Eds., vol. 12759. Springer, 2021, pp. 694–717. [Online]. Available:
https://doi.org/10.1007/978-3-030-81685-8 33

[30] L. Bozzelli, A. Peron, and C. S´anchez, “Asynchronous extensions
in 36th Annual ACM/IEEE Symposium on Logic
Italy,
-
June
[Online]. Available:

of hyperltl,”
in Computer
July
2,
https://doi.org/10.1109/LICS52264.2021.9470583

2021, Rome,
1–13.

Science, LICS

IEEE, 2021,

2021.

pp.

29

[31] J. O. Gutsfeld, M. M¨uller-Olm, and C. Ohrem, “Automata and
ﬁxpoints for asynchronous hyperproperties,” Proc. ACM Program.
Lang., vol. 5, no. POPL, pp. 1–29, 2021.
[Online]. Available:
https://doi.org/10.1145/3434319

[32] L. Lamport and F. B. Schneider, “Verifying hyperproperties with
TLA,” in 34th IEEE Computer Security Foundations Symposium, CSF
2021, Dubrovnik, Croatia, June 21-25, 2021.
IEEE, 2021, pp. 1–16.
[Online]. Available: https://doi.org/10.1109/CSF51468.2021.00012
[33] I. Grishchenko, M. Maffei, and C. Schneidewind, “A semantic
framework for the security analysis of ethereum smart contracts,” in
Principles of Security and Trust - 7th International Conference, POST

2018, Held as Part of the European Joint Conferences on Theory and
Practice of Software, ETAPS 2018, Thessaloniki, Greece, April 14-20,
2018, Proceedings, ser. Lecture Notes in Computer Science, L. Bauer
Springer, 2018, pp. 243–269.
and R. K¨usters, Eds., vol. 10804.
[Online]. Available: https://doi.org/10.1007/978-3-319-89722-6 10
[34] E. Albert, S. Grossman, N. Rinetzky, C. Rodr´ıguez-N´u˜nez, A. Rubio,
and M. Sagiv, “Taming callbacks for smart contract modularity,” Proc.
ACM Program. Lang., vol. 4, no. OOPSLA, pp. 209:1–209:30, 2020.
[Online]. Available: https://doi.org/10.1145/3428277

