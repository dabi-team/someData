1
2
0
2

g
u
A
5

]
L
P
.
s
c
[

1
v
2
7
6
2
0
.
8
0
1
2
:
v
i
X
r
a

Protocol-based Smart Contract Generation

Afonso Falc˜ao1, Andreia Mordido1

, and Vasco T. Vasconcelos1

LASIGE, Faculty of Sciences, University of Lisbon, Portugal
anfalcao@lasige.di.fc.ul.pt afmordido@ciencias.ulisboa.pt
vmvasconcelos@ciencias.ulisboa.pt

Abstract. The popularity of smart contracts is on the rise, yet breaches
in reliability and security linger. Among the many facets of smart con-
tract reliability, we concentrate on faults rooted in out-of-order interac-
tions with contract endpoints. We propose SmartScribble, a protocol
language to describe valid patterns of interaction between users and end-
points. SmartScribble not only ensures correct interactive behaviour
but also simpliﬁes smart contract coding. From a protocol description,
our compiler generates a smart contract that can then be completed by
the programmer with the relevant business logic. The generated contracts
rely on ﬁnite state machines to control endpoint invocations. As a proof
of concept, we target Plutus, the contract programming language for the
Cardano blockchain. Preliminary evaluation points to a 75% decrease in
the size of the code that developers must write, coupled with an increase
of reliability by enforcing the speciﬁed patterns of interaction.

Keywords: Programming language · Smart contract · Protocol speciﬁ-
cation · State machine

1

Introduction

Smart contracts are a focal point of modern blockchain environments. Such con-
tracts were ﬁrstly popularized by Ethereum [14], but soon thereafter other net-
works developed their own smart contract languages, enabling the implementa-
tion of blockchain-based decentralized applications between untrusted parties.

Smart contracts usually operate over user owned assets, thus, vulnerabil-
ities in programs and in the underlying programming languages can lead to
considerable losses. The famous attack on the DAO resulted in a theft of ap-
proximately 60 million USD worth of Ether [1,5,7]. Due to recent exploitations
of vulnerabilities in smart contracts, blockchain providers turned their attention
to the development of robust programming languages, often relying on formal
veriﬁcation, including Liquidity1 by Tezos, Plutus by IOHK [4], Move by Face-
book [3], and Rholang2 by RChain. Such languages aim at oﬀering ﬂexible and
complex smart contracts while assuring that developers may fully trust contract
behaviour. Unfortunately, for Plutus, the last objective has not been completely

1 http://www.liquidity-lang.org/doc/index.html
2 https://github.com/rchain/rchain/tree/master/rholang-tutorial

 
 
 
 
 
 
achieved yet. As we show in the next section, in Plutus, assets can be easily lost
forever to the ledger with a simple unintended interaction.

To counter unplanned interactions with smart contracts endpoints while au-
tomating the development of boilerplate code, we propose SmartScribble, a
protocol speciﬁcation language for smart contracts. Its syntax is adapted from
the Scribble protocol language [15] to the smart contract trait and features prim-
itives for sequential composition, choice, recursion, and interrupts. Protocols in
SmartScribble specify interactions between participants and the ledger, as
well as triggers to interrupt protocol execution. The business logic underlying
the contract can be added by the programmer after the automatic generation of
the smart contract boilerplate code. The generated code relies on a ﬁnite state
machine to validate all interactions, precluding unexpected behaviours.

SmartScribble currently targets Plutus, a native smart contract program-
ming language for the Cardano blockchain [11], based on the Extended Unspent
Transaction Output model [6], a solution that expands the limited expressiveness
of the Unspent Transaction Output model. In UTxO, transactions consist of a
list of inputs and outputs. Outputs correspond to the quantity available to be
spent by inputs of subsequent transactions. Extended UTxO expands UTxO’s
expressiveness without switching to an account-based model, that introduces a
notion of shared mutable state, ravelling contract semantics [6]. Nevertheless, the
framework we propose can be integrated with other smart contract languages
and blockchain infrastructures expressive enough to support state machines.

Several works have been adopting state machines to control the interac-
tion of participants with smart contracts. FSolidM [12]—the closest proposal to
SmartScribble—introduces a model for smart contracts based on ﬁnite state
machines. FSolidM relies on the explicit construction of ﬁnite state machines for
contract speciﬁcation; instead, we automatically generate all state machine code.
On a diﬀerent fashion, the model checker Cubicle [9] encodes smart contracts
and the transactional model of the blockchain as a state machine.

SmartScribble distinguishes itself from other domain-speciﬁc languages—
BitML, integrated with the Bitcoin blockchain [2], Obsidian [8], a typestate-
oriented language, and Nomos [10], a functional (session-typed) language—by
abstracting the interactive behaviour and details of the target programming
language through a protocol speciﬁcation, only relying on the smart contract
language to implement the business logic and thus ﬂattening the learning curve.
The next section motivates SmartScribble via an example where assets
are lost to the ledger; section 3 presents the protocol language and section 4
contract generation from protocols. Section 5 describes some preliminary results
of our evaluation of SmartScribble, and section 6 concludes the paper and
points to future work. Appendix A contains the source code for the vulnerable
contract we explore in our motivation, appendix B presents input and logs for
playground simulations, appendix C contains the deﬁnition of SmartScribble
protocols used in section 5, and appendix D the source code for the business
logic of our running example.

Fig. 1: Diagram of a particular well-behaved ﬂow of operations

2 Smart contracts can go wrong

This section identiﬁes a weakness of the Plutus smart contract programming
language. Although Plutus is developed with a clear focus on reliability, it lacks
mechanisms to enforce correct patterns of interactions. As a running example we
consider the popular guessing game (contract in appendix A), the paradigm for
secret-based contracts where participants try to guess a secret and get rewarded
if successful. Another example that falls in this category is a lottery. Figure 1
represents a correct sequence of events in the guessing game:

1. The owner of the contract locks a secret and deposits a prize in ADA3 to be

retrieved by the ﬁrst player who correctly guesses the secret.

2. The player tries to guess the secret.
3. If the guess matches the secret, the player retrieves the prize and the game
ends; otherwise, the player is warned that the guess did not succeed and the
game continues.

In Plutus, the parties involved in the protocol are not required to follow
valid patterns of interaction. We explore a scenario where one of the parties
deviates from the (implicitly) expected ﬂow and show that this leads to a faulty
behaviour that is silenced by the blockchain. Figure 2 represents a scenario where

3 ADA is the digital currency of the Cardano blockchain. 1 ADA = 1,000,000 Lovelace.

Fig. 2: The owner (incorrectly) locks twice and a correct guess results in a failure

the owner incorrectly executes two consecutive lock operations and the player
provides a correct guess. A simulation of this scenario in the Plutus Playground4
is illustrated in Figure 3. Starting with 10 Lovelace in both the owner’s and
player’s wallets, we reach a situation where the log identiﬁes a validation failure
for a guess that coincides with that of the ﬁrst lock (see Figure 8 in Appendix B).
The ﬁnal balances in Figure 4 show that the player did not collect the reward
despite having guessed the ﬁrst secret and the owner lost their money to the
contract.

This behaviour is certainly unexpected: rather than overriding the ﬁrst lock
or having the second lock fail, both secrets are stored in the ledger as outputs.
When a guess is performed, both stored outputs are compared to the guess
and, as a consequence, no guess will ever validate against two diﬀerent secrets.
Furthermore, the prize is irrevocably lost to the contract without any possibility
of retrieval. This is an unexpected band of silent behaviour that we want to
prevent. Even in this simple scenario users lose assets to the ledger. Similar
situations are very likely to occur in complex contracts, with devastating results.
We propose specifying the interaction behaviour of smart contracts through
protocols that describe the valid patterns of interactions between diﬀerent classes
of users and the contract. Our approach prevents unexpected contract behaviours
by having contracts automatically validating interactions. The protocol for the
guessing game described at the end of next section, detects and avoids further
attempts to lock secrets, among other unintended interactions. Note that this
type of vulnerability is diﬀerent from Transaction Ordering Dependence [13] that

4 https://prod.playground.plutus.iohkdev.io/

Fig. 3: Playground setup for Fig. 2: the owner makes two consecutive locks, the
player guesses the ﬁrst secret (complete version in Fig. 7, appendix B)

Fig. 4: Final balances for input in Fig. 3 (Plutus Playground)

is related to corrupt miners maliciously changing the order of transactions, and
not the order in which the endpoints are called.

3 Specifying smart contract protocols in SmartScribble

Scribble [15] is a language to describe application-level protocols for communi-
cating systems. It comes with tools to generate Java or Python APIs on which
developers can base correct-by-construction implementations of protocols.

SmartScribble is based as much as possible on Scribble, even if it covers
only a fragment of the language and includes support for smart contract spe-
ciﬁc features. The base types of SmartScribble include String, HashedString
(strings stored in the ledger), PubKeyHash (wallet public key identiﬁers) and
Value (an amount in ADA). To watch SmartScribble in action we start with
a very simple version of the guessing game protocol and gradually make it more
robust. Our ﬁrst version is the straight line guessing game, featuring a sequential
composition of three endpoints: lock, guess, closeGame.

p r o t o c o l S t r a i g h t L i n e G u e s s i n g G a m e ( r o l e Owner ,

r o l e P l a y e r ) {

f i e l d HashedString ; // s a v e t h e s e c r e t
l o c k s
// t h e owner
l o c k ( S t r i n g , Value ) from Owner ;
g u e s s
( S t r i n g ) from P l a y e r ;
// t h e owner c l o s e s

// t h e p l a y e r makes a g u e s s

t h e game ( no f u r t h e r g u e s s e s a l l o w e d )

t h e s e c r e t and d e p o s i t s a p r i z e

i n t h e c o n t r a c t

c l o s e G a m e ( )

from Owner ;

}

The StraightLineGuessingGame protocol introduces, in the ﬁrst line, the roles
users are expected to take when interacting with the smart contract: the Owner
owns the game; the Player makes guesses. Stateful protocols require state to be
kept in the contract. The ﬁeld declaration introduces the types of the ﬁelds that
are stored within the state machine. In this case, we need an HashedString for the
secret. Along with the declared ﬁelds, SmartScribble creates an extra Value
ﬁeld by default, this ﬁeld is used to manage the funds in the contract, in this
instance, we use it to store the prize. The ﬁelds are stored in the state machine
in the form of tuples, with each element of the tuple corresponding to one of
the declared ﬁelds. Users may declare repeated types. The tuple with stored
contents can be used by the programmer when implementing the business logic.
Protocol StraightLineGuessingGame makes use of interaction constructs to describe
interactions between an user and the endpoints lock, guess and closeGame. In this
protocol, the three endpoints must be exercised once, in the order by which they
appear in the protocol, and by users of the appropriate role. Endpoint signatures
comprise the endpoint name followed by the types of the parameters.

It should be stressed that the guessing nature of the contract is nowhere
present in the protocol. Nothing in the protocol associates the HashedString in
endpoint lock to a secret, or Value to the prize. Nowhere it is said that guessing
the secret entails the transfer of the prize to the Player’s account. Instead, the
protocol governs interaction only: which endpoints are available to which roles,
at which time. The business logic associated with the contract is programmed
later, in the contract language of the blockchain.

Our next version allows the owner to cancel the game after locking the secret
(perhaps the secret was too easy or the prize was set too low). The choice operator
denotes a choice made by an user, featuring diﬀerent alternative branches.

p r o t o c o l C h o i c e G u e s s i n g G a m e ( r o l e Owner ,

r o l e P l a y e r ) {

f i e l d HashedString ;
l o c k ( S t r i n g , Value ) from Owner ;
c h o i c e a t Owner {

proceedWithGame : { // owner wants p l a y e r s

t o g u e s s

g u e s s

( S t r i n g ) from P l a y e r ;

}
cancelGame : { // t h e owner c h o o s e s
}

}
c l o s e G a m e ( )

from Owner ;

}

t o c a n c e l

t h e game

After locking the secret, the Owner is given two choices: to cancel the game
(cancelGame) or to allow a player to make a guess (proceedWithGame). The two
branches represent two diﬀerent endpoints in the contract. The choice is in the
hands of a single role, Owner in this case. This role should exercise one endpoint
or the other (but not both). Protocols for the two branches are distinct. In the

case of proceedWithGame, endpoint guess is to be called by Player. The cancelGame
branch is empty. In either case, the Owner is supposed to close the game after
making the choice.

The third version allows one or more players to continue guessing while the

game is kept open by the owner. We make use of rec-loops for the eﬀect.

p r o t o c o l RecGuessingGame ( r o l e Owner ,

r o l e P l a y e r ) {

f i e l d HashedString ;
l o c k ( S t r i n g , Value ) from Owner ;
r e c Loop {

c h o i c e a t Owner {
proceedWithGame : { // owner wants p l a y e r s

t o g u e s s

g u e s s
Loop ;

( S t r i n g ) from P l a y e r ;

}
cancelGame : { // t h e owner wants
}

}
c l o s e G a m e ( )

from Owner ;

}

t o c a n c e l

t h e game

The rec constructor introduces a labelled recursion point. In this case the
protocol may continue at the recursion point by means of the Loop label. In any
iteration of the loop the owner is called to decide whether the game continues
or not (perhaps the secret was found or the owner got tired of playing). If she
decides proceedWithGame, a player is given the chance of guessing (by calling
endpoint guess) and the owner is called again to decide the faith of the game.

Version three requires a lot of Owner intervention: the continuation of the
game depends on her choice—proceedWithGame or cancelGame—after each guess.
We want protocols able to terminate automatically, based on guess validation or
on the passage of time. Our fourth version takes advantage of the do−interrupt
constructor and the trigger declaration:

p r o t o c o l GuessingGame ( r o l e Owner ,

r o l e P l a y e r ) {

f i e l d HashedString ;
l o c k ( S t r i n g , Value ) from Owner {

// t r i g g e r s
f u n d s
s l o t

t r i g g e r c l o s e G a m e ;

t r i g g e r c l o s e G a m e ;

f o r

f u n d s and s l o t

} ;
do {

r e c Loop {
g u e s s
Loop ;

( S t r i n g ) from P l a y e r ;

}

}
i n t e r r u p t {

// c l o s e t h e game when one o f
c l o s e G a m e ( )

from C o n t r a c t ;

t h e

t r i g g e r s

i s a c t i v a t e d

}

}

In the last version of the protocol, the Owner does not have any further in-
volvement after locking the secret. The game ends when one of the triggers is ac-
tivated. Declarations slot trigger closeGame and funds trigger closeGame contain
the keywords slot and funds, that instruct the compiler to generate functions in
the business logic module where the programmer may deﬁne the conditions for
these triggers. The primitive role Contract signs the closeGame operation. This is
not an endpoint, but an interaction that is executed automatically.

Constructors rec, choice, do−interrupt and protocol deﬁnitions share Scrib-
ble’s syntax entirely. Interactions are simpliﬁed: we remove to <recipient> present
in Scribble syntax because in our setting the recipient is always the contract. The
declarations ﬁeld , funds trigger, slot trigger are exclusive to SmartScribble.

4 Smart contract generation from SmartScribble

This section details the smart contracts generated from SmartScribble pro-
tocols and explain how developers can add custom business logic to complete
contract code. To ensure the validation of participants’ interactions with the con-
tract we construct a ﬁnite state machine from each SmartScribble protocol,
whose implementation is automatically generated by our compiler.

Protocols are governed by ﬁnite state machines. Figure 5 depicts the au-
tomata for the recursive and the do−interrupt guessing game in section 3. The
correspondence is such that endpoints in the automaton correspond to edges,
and pre- and post-interaction points in a protocol correspond to nodes. Sequen-
tial composition, choice and rec generate appropriate wiring. Interrupts call the
associated function generating new edges, as in the case of closeGame where an
edge links state #2 to the terminal state #3 (Figure 5b).

The SmartScribble compiler generates code divided in three diﬀerent mod-
ules: Domain and Library Module, Smart Contract Module and Business Logic
Module. In this section we give a brief overview of the three modules.

The Domain and Library Module includes declaration of errors, the interface
for the contract, the deﬁnition of state machine inputs, states and the functions
to interact with the state machine.

The Smart Contract Module contains code activated when interacting with
endpoints. For example, lock registers the two triggers and calls the correspond-
ing function in the Business Logic Module. The latter function returns either
an error or the ﬁelds to be stored at the new state. If an error is received, no
state transition is performed. Otherwise, the machine advances to the next state
and sets its new contents. Changes to the value ﬁeld stored in the state results
in the transfer of funds between the node interacting with the endpoint and
the contract. This module also contains code for state transition that is used to
deﬁne the state machine and boilerplate code speciﬁc to Plutus’ contracts. To
implement the state machine we use the Plutus State Machine library5, part of
the standard Plutus package.

5 Language.Plutus.Contract.StateMachine

(a) RecGuessingGame

(b) GuessingGame

Fig. 5: Finite state automata for two SmartScribble protocols

Finally, the Business Logic Module contains signatures for each of the end-
points in the contract. The actual code is meant to be written by the contract
developer. The interaction

l o c k ( S t r i n g , Value ) from Owner ;

in the protocol requires a function

l o c k : : S t r i n g −> V a l u e −> C o n t r a c t

( E i t h e r S t a t e C o n t e n t s

E r r o r )

(signature simpliﬁed) in the Smart Contract Module that returns either a new
StateContents (a tuple composed of the ﬁelds stored in the state) or an error.
If the value is non-positive, lock returns an error including an error message;
otherwise returns a StateContents, that is a pair, composed of the hashed string
corresponding to the input and the value. These are the two ﬁelds to store in
the new state of the state machine (state#2 in Figure 5b, reached via the guess-
labelled edge). The triggers: funds trigger and slot trigger associated with lock,
generate functions with signatures:

l o c k F u n d T r i g g e r
l o c k S l o t T r i g g e r

: : S t r i n g −> V a l u e −> C o n t r a c t
: : S t r i n g −> V a l u e −> C o n t r a c t S l o t

( V a l u e −> Bool )

for the respective triggers. In lockFundTrigger, the developer should add an expres-
sion with the condition to activate the trigger, e.g., (\funds −> funds ‘V.leq‘ 0).
In lockSlotTrigger we specify the Slot that activates the trigger.

Corresponding to the

g u e s s

( S t r i n g ) from P l a y e r ;

in the protocol, a function with the following signature must be written.

g u e s s

: : S t r i n g −> C o n t r a c t

( E i t h e r S t a t e C o n t e n t s E r r o r )

Function guess reads the secret from the machine state (an HashedString)
compares with the hashed version of the input string. If they match, it returns a

Fig. 6: Final balances for setup in Fig. 3, using SmartScribble (Plutus Play-
ground)

pair whose second component is zero ADA, otherwise it returns an appropriate
error message. The caller to guess (in module Smart Contract Module) detects
the diﬀerence in the value ﬁeld of the state and credits the diﬀerence in the
client’s account. Finally, the closeGame () from Contract interaction point needs a
function with the same name that, in this case, returns a state with HashedString
”Game over” and zero ADA as its ﬁelds.

The complete code of the module is in appendix D; the code for the three

functions and two triggers amounts to 13 lines.

We now revisit the scenario in Figure 2 using the input from Figure 3, that
previously resulted in an error. Thanks to the integration with a state machine,
the contract now impedes the second lock from taking eﬀect, as can be seen in
Figure 9 (available in appendix B). In Figure 6, we see that now the player is
able to retrieve the prize for guessing correctly: the player terminates with 13
Lovelace, and the owner ends with 7 Lovelace, resulting from the deposit of 3
Lovelace with the ﬁrst lock.

5 Evaluation

This section compares the amount of lines of code (LOC), those written by the
developer and those generated by our compiler. To carry out the comparison,
we use the guessing game together with three protocols representative of simple
smart contracts. The new protocols are in appendix C.

Ping Pong A simple protocol that alternates between ping and pong operations,

ad eternum. No business logic is required for this protocol.

Crowdfunding A crowdfunding where an owner starts a campaign with a goal
(in ADA), and contributors donate to the campaign. When the owner decides
to close the campaign, all the donations stored in the contract are collected.
Auction A protocol where a seller starts an auction over some token, setting
the time limit and the maximum number of bids. Buyers bid for the token.
When the auction is over, the seller collects the funds of the highest bid and
the corresponding bidder gets the token.

Table 1: Lines of code for each use case. From left to right: LOC of the
SmartScribble protocol, LOC of the generated code, LOC of the business
logic, LOC for suggested implementation, ratio between LOC of the protocol
and the generated code, ratio between LOC written by the programmer (pro-
tocol + business logic) and smart contract, ratio between LOC written by the
developer and suggested implementation
Logic
Protocol
(LOC)
(LOC)
0
8
6
12
13
16
22
15

4.52% 4.52% 5.63%
6.42% 9.63% 11.04%
9.88% 17.90% 17.57%
10.00% 25.67% 20.00%

Ping Pong
Crowdfunding
Guessing Game
Auction

Generated
(LOC)

Suggested
(LOC)

142
163
165
185

177
187
162
150

Protocol
Generated

Written
Suggested

Written
Contract

Protocol

Table 1 summarizes the analysis. Depending on the protocol, the amount of
generated code varies from 150 to 187 lines. In all our examples, the generated
code is at least 10× larger than the source written in SmartScribble. The
business logic varies a lot from contract to contract; nevertheless, it is important
to note that it is extremely likely to be a small portion of the complete contract
due to the amount of necessary boilerplate that Plutus requires. We see that
the ratio between all the code written by the programmer (that is, the proto-
col and the business logic code) and the Plutus code that would otherwise be
manually written is less than 1/4 in all analysed contracts. When we compare
LOC for suggested implementations6 and SmartScribble, we conclude that
with SmartScribble, the code manually written is once again 1/5 or less for
every scenario. Even in implementations developed by experts, the boilerplate
portion of the contract is signiﬁcant.

6 Conclusion and future work

We present SmartScribble—a protocol language for smart contracts—and a
compiler that automatically generates all contract code, except the business
logic. The generated code relies on state machines to prevent unexpected inter-
actions with the contract. We claim that SmartScribble improves the relia-
bility of contracts by reducing the likelihood of programmers introducing faults
in smart contract code. Our language also ﬂattens the learning curve, allowing
developers to focus on the business logic rather than on the boilerplate required
to setup a contract, namely in Plutus. Preliminary results point to a 1/4 ra-
tio between the number of lines of code written by the programmer and those
in the ﬁnal contract. This paper constitutes an initial report on using protocol
descriptions to generate contract code. Much remains to be done. SmartScrib-
ble protocols classify participants under diﬀerent roles, but we currently do not
enforce any form of association of participants to roles. We plan to look into

6 Implementations available on Plutus’ GitHub

diﬀerent forms of enforcing the association. Business logic is currently manually
written in the contract language (Plutus) and added to the code generated from
the protocol. We plan to look into ways of adding more business logic to proto-
cols, thus minimising the Plutus code that must be hand written. Some features
of SmartScribble are strongly linked with Plutus. The trigger generation is
one of those features: it depends on Plutus libraries for the eﬀect. Nevertheless,
we believe that SmartScribble can be adapted to target other languages with
minimal changes to the syntax and semantics. Generating Solidity code might
be an interesting option for the future, as it also supports state machines. Lastly,
evaluation needs to be elaborated. In ongoing work, we are comparing the usage
of computational resources between contracts implemented with SmartScrib-
ble and the corresponding suggested implementations.

References

1. Atzei, N., Bartoletti, M., Cimoli, T.: A survey of attacks on ethereum smart
contracts (sok). In: International conference on principles of security and trust.
Springer (2017)

2. Bartoletti, M., Zunino, R.: Bitml: a calculus for bitcoin smart contracts. In: Pro-
ceedings of the 2018 ACM SIGSAC Conference on Computer and Communications
Security (2018)

3. Blackshear, S., Cheng, E., Dill, D.L., Gao, V., Maurer, B., Nowacki, T., Pott, A.,
Qadeer, S., Rain, D.R., Sezer, S., et al.: Move: A language with programmable
resources. Libra Assoc (2019)

4. Br¨unjes, L., Vinogradova, P.: Plutus: Writing Reliable Smart Contracts. IOHK

(2020)

5. del Castillo, M.: The dao attacked code issue leads to $60 million ether theft (2016),
https://www.coindesk.com/dao-attacked-code-issue-leads-60-million-ether-theft
6. Chakravarty, M.M., Chapman, J., MacKenzie, K., Melkonian, O., Jones, M.P.,
Wadler, P.: The extended UTXO model. In: International Conference on Financial
Cryptography and Data Security. Springer (2020)

7. Chen, H., Pendleton, M., Njilla, L., Xu, S.: A survey on ethereum systems security:
Vulnerabilities, attacks, and defenses. ACM Computing Surveys 53(3) (2020)
8. Coblenz, M., Oei, R., Etzel, T., Koronkevich, P., Baker, M., Bloem, Y., Myers,
B.A., Sunshine, J., Aldrich, J.: Obsidian: Typestate and assets for safer blockchain
programming. TOPLAS 2020 42(3) (2020)

9. Conchon, S., Korneva, A., Za¨ıdi, F.: Verifying smart contracts with cubicle. In:
Formal Methods. FM 2019 International Workshops, Revised Selected Papers, Part
I. Lecture Notes in Computer Science, vol. 12232. Springer (2019)

10. Das, A., Balzer, S., Hoﬀmann, J., Pfenning, F., Santurkar, I.: Resource-aware ses-
sion types for digital contracts. In: IEEE 34th Computer Security Foundations
Symposium (CSF). IEEE Computer Society (2021)

11. Kiayias, A., Russell, A., David, B., Oliynykov, R.: Ouroboros: A provably secure
proof-of-stake blockchain protocol. In: Annual International Cryptology Confer-
ence. Springer (2017)

12. Mavridou, A., Laszka, A.: Designing secure ethereum smart contracts: A ﬁnite state
machine based approach. In: International Conference on Financial Cryptography
and Data Security. Springer (2018)

13. Sayeed, S., Marco-Gisbert, H., Caira, T.: Smart contract: Attacks and protections.

IEEE Access 8 (2020)

14. Wood, G.: Ethereum: A secure decentralised generalised transaction ledger.

Ethereum project yellow paper 151(2014) (2014)

15. Yoshida, N., Hu, R., Neykova, R., Ng, N.: The scribble protocol language. In:
International Symposium on Trustworthy Global Computing. Springer (2013)

A Plutus code for vulnerable guessing game

module GuessingGame

( g u e s s
,
l o c k
, e n d p o i n t s )
where

C o n t r o l . Monad

import
import q u a l i f i e d Data . B y t e S t r i n g . Char8
import
import q u a l i f i e d Language . P l u t u s T x
import

Language . P l u t u s . C o n t r a c t

( v o i d )
a s C

a s P l u t u s T x

Language . P l u t u s T x . P r e l u d e h i d i n g ( pu re , (<$>)

)

import

L e d g e r

( A d d r e s s , V a l i d a t o r

, V a l i d a t o r C t x , Value ,

s c r i p t A d d r e s s )

import q u a l i f i e d L e d g e r . C o n s t r a i n t s
import q u a l i f i e d L e d g e r . Typed . S c r i p t s
import
import q u a l i f i e d P r e l u d e

P l a y g r o u n d . C o n t r a c t

a s C o n s t r a i n t s
a s S c r i p t s

newtype H a s h e d S t r i n g = H a s h e d S t r i n g B y t e S t r i n g d e r i v i n g

newtype P l u t u s T x . I s D a t a

P l u t u s T x . m a k e L i f t

’ ’ H a s h e d S t r i n g

newtype C l e a r S t r i n g = C l e a r S t r i n g B y t e S t r i n g d e r i v i n g newtype

P l u t u s T x . I s D a t a

P l u t u s T x . m a k e L i f t

’ ’ C l e a r S t r i n g

type GameSchema =

B l o c k c h a i n A c t i o n s

. \ / E n d p o i n t ” l o c k ” LockParams
. \ / E n d p o i n t ” g u e s s ” GuessParams

data Game
i n s t a n c e S c r i p t s . S c r i p t T y p e Game where

type i n s t a n c e RedeemerType Game = C l e a r S t r i n g
type i n s t a n c e DatumType Game = H a s h e d S t r i n g

g a m e I n s t a n c e
g a m e I n s t a n c e = S c r i p t s . v a l i d a t o r @Game

: : S c r i p t s . S c r i p t I n s t a n c e Game

$$ ( P l u t u s T x . c o m p i l e
$$ ( P l u t u s T x . c o m p i l e

v a l i d a t e G u e s s

[ | |
[ | | wrap | | ] ) where

| | ] )

wrap = S c r i p t s . w r a p V a l i d a t o r @ H a s h e d S t r i n g

@ C l e a r S t r i n g

−− c r e a t e a d a t a s c r i p t

f o r

t h e g u e s s i n g game by h a s h i n g t h e

s t r i n g

−− and l i f t i n g t h e h a s h t o i t s on−c h a i n r e p r e s e n t a t i o n
h a s h S t r i n g : : S t r i n g −> H a s h e d S t r i n g
h a s h S t r i n g = H a s h e d S t r i n g .

s h a 2 2 5 6 . C . pack

−− c r e a t e a r e d e e m e r

s c r i p t

f o r

t h e g u e s s i n g game by l i f t i n g

t h e

−− s t r i n g t o i t s on−c h a i n r e p r e s e n t a t i o n
c l e a r S t r i n g : : S t r i n g −> C l e a r S t r i n g
c l e a r S t r i n g = C l e a r S t r i n g . C . pack

−− t h e v a l i d a t i o n f u n c t i o n ( Datum −> Redeemer −> V a l i d a t o r C t x

−> B o o l )
v a l i d a t e G u e s s
−> Bool
v a l i d a t e G u e s s

: : H a s h e d S t r i n g −> C l e a r S t r i n g −> V a l i d a t o r C t x

( H a s h e d S t r i n g a c t u a l )

( C l e a r S t r i n g g u e s s ’ )

=

a c t u a l == s h a 2 2 5 6 g u e s s ’

−− t h e v a l i d a t o r
g a m e V a l i d a t o r
g a m e V a l i d a t o r = S c r i p t s . v a l i d a t o r S c r i p t g a m e I n s t a n c e

s c r i p t o f
: : V a l i d a t o r

t h e game .

−− t h e a d d r e s s o f
gameAddress
gameAddress = L e d g e r . s c r i p t A d d r e s s g a m e V a l i d a t o r

t h e game ( t h e h a s h o f

: : A d d r e s s

i t s

v a l i d a t o r

s c r i p t )

−− p a r a m e t e r s
data LockParams = LockParams

f o r

t h e ” l o c k ” e n d p o i n t

: : V a l u e

{ s e c r e t W o r d : : S t r i n g
, amount
}
d e r i v i n g s t o c k ( P r e l u d e . Eq , P r e l u d e . Show , G e n e r i c )
d e r i v i n g a n y c l a s s
ToArgument )

( FromJSON , ToJSON ,

I o t s T y p e , ToSchema ,

−− p a r a m e t e r s
f o r
newtype GuessParams = GuessParams

t h e ” g u e s s ” e n d p o i n t

{ guessWord : : S t r i n g
}
d e r i v i n g s t o c k ( P r e l u d e . Eq , P r e l u d e . Show , G e n e r i c )
d e r i v i n g a n y c l a s s
ToArgument )

( FromJSON , ToJSON ,

I o t s T y p e , ToSchema ,

−− t h e ” l o c k ” e n d p o i n t .
l o c k : : A s C o n t r a c t E r r o r e => C o n t r a c t GameSchema e ( )
l o c k = do

LockParams
t x
l e t
h a s h S t r i n g s e c r e t ) amt

s e c r e t amt <− e n d p o i n t @” l o c k ” @LockParams

= C o n s t r a i n t s . m u s t P a y T o T h e S c r i p t

(

v o i d ( s u b m i t T x C o n s t r a i n t s g a m e I n s t a n c e t x )

−− t h e ” g u e s s ” e n d p o i n t .
g u e s s
g u e s s = do

: : A s C o n t r a c t E r r o r e => C o n t r a c t GameSchema e ( )

t h e G u e s s <− e n d p o i n t @” g u e s s ” @GuessParams

GuessParams
u n s p e n t O u t p u t s <− u t x o A t gameAddress
l e t

r e d e e m e r = c l e a r S t r i n g t h e G u e s s
t x

= c o l l e c t F r o m S c r i p t u n s p e n t O u t p u t s

r e d e e m e r

v o i d ( s u b m i t T x C o n s t r a i n t s S p e n d i n g g a m e I n s t a n c e

u n s p e n t O u t p u t s

t x )

game : : A s C o n t r a c t E r r o r e => C o n t r a c t GameSchema e ( )
game = l o c k ‘ s e l e c t ‘ g u e s s

e n d p o i n t s
e n d p o i n t s = game

: : A s C o n t r a c t E r r o r e => C o n t r a c t GameSchema e ( )

m k S c h e m a D e f i n i t i o n s

’ ’ GameSchema

$ ( mkKnownCurrencies

[ ] )

B Plutus playground simulation for the guessing game

scenario

Fig. 7: Complete version of Fig. 3. This is the setup to run the scenario illustrated
in Fig. 2 in Plutus Playground: the owner (Wallet 1) makes two consecutive locks
(“Pink Floyd” and “Led Zeppelin”), the player (Wallet 2) guesses the ﬁrst secret.
Wait in between actions, to let the simulator process the inputs.

=== Slot 1 ===

Wallet 1:
ReceiveEndpointCall ("tag":"lock","value":3,"secretWord":"Pink Floyd")
Validating transaction: [..]
=== Slot 2 ===
=== Slot 3 ===
Wallet 1:
ReceiveEndpointCall ("tag":"lock","value":4,"secretWord":"Led Zeppelin")
Validating transaction: [..]
=== Slot 4 ===
=== Slot 5 ===
Wallet 2:
ReceiveEndpointCall ("tag":"guess","guessWord":"Pink Floyd")
Validation failed: [..] (ScriptFailure (EvaluationError []))

Fig. 8: Log resulting from the setup in Fig.3 with a vanilla Plutus smart contract;
observe that both locks are validated (Slot 1 and Slot 3) and that a correct
guess later results in a validation failure (Slot 5)

Validating transaction: [...]
=== Slot 1 ===
Wallet 1:
EndpointCall ("tag":"lock","value":3,"secretWord":"Pink Floyd")
Validating transaction: [...]
=== Slot 2 ===
Wallet 1: "No previous state found, initialising SM with state:
LockState (HashedString ...) and with value: 3"
=== Slot 3 ===
Wallet 1:
EndpointCall ("tag":"lock","value":4,"secretWord":"Led Zeppelin")
Wallet 1: "Previous lock detected.
This lock produces no effect"
=== Slot 4 ===
=== Slot 5 ===
Wallet 2:
EndpointCall ("tag":"guess","guessWord":"Pink Floyd")
Wallet 2: "Congratulations, you won!"
Validating transaction: [...]
=== Slot 6 ===
Wallet 1: "Closing the game"
Wallet 2:
"Successful transaction to state: LockState (HashedString ...)"
Validating transaction: [...]
=== Slot 7 ===
Wallet 1:
"Successful transaction to state: CancelGameState (HashedString ...)"

Fig. 9: Log resulting from the setup in Fig.3. This time using the contract gen-
erated from the protocol using SmartScribble; observe that the second lock
fails (Slot 3) and therefore the guess from Wallet 2 is successfully validated

C SmartScribble protocols for the evaluation section

The ping-pong protocol

p r o t o c o l PingPongRec ( r o l e C l i e n t ) {

i n i t ( )
r e c Loop {
p i n g ( )
pong ( )
Loop ;

from C l i e n t ;

from C l i e n t ;
from C l i e n t ;

}

}

The crowdfunding protocol

p r o t o c o l C r o w d f u n d i n g ( r o l e C o n t r i b u t o r ,

r o l e Owner ) {

( Value ) from Owner ;

i n i t
r e c Loop {

c h o i c e a t Owner{

c o n t i n u e

: {

c o n t r i b u t e ( Value ) from C o n t r i b u t o r ;
Loop ;

}
c l o s e C r o w d f u n d : {}

}

}

}

The auction protocol

p r o t o c o l A u c t i o n ( r o l e S e l l e r ,

r o l e Buyer ) {

f i e l d PubKeyHash , Value ;
b e g i n A u c t i o n ( Token , Value ) from S e l l e r {

s l o t

t r i g g e r

( s l o t == 1 0 , e n d A u c t i o n ) ;

} ;
do {

r e c Loop {

b i d ( Value ) from Buyer ;
Loop ;

}

}
i n t e r r u p t {

e n d A u c t i o n ( )

from C o n t r a c t ;

}

}

D Plutus code for business logic

Guessing game logic module (SmartScribble)

module G u e s s i n g G a m e L o g i c

l o c k
(
, g u e s s
, c l o s e G a m e
) where

C o n t r o l . L e n s
C o n t r o l . Monad
GHC . G e n e r i c s
Language . P l u t u s T x . P r e l u d e

import
import
import
import
import q u a l i f i e d L e d g e r . Ada
import q u a l i f i e d L e d g e r . V a l u e
import q u a l i f i e d Data . Text
import q u a l i f i e d Data . B y t e S t r i n g . Char8
import q u a l i f i e d G u e s s G a m e L i b r a r y
import P l u t u s T x . P r e l u d e
import q u a l i f i e d P r e l u d e

( v o i d )
( G e n e r i c )

a s Ada
a s V
a s T
a s C
a s G

h a s h S t r i n g : : S t r i n g −> H a s h e d S t r i n g
h a s h S t r i n g = H a s h e d S t r i n g .

s h a 2 2 5 6 . C . pack

z e r o L o v e l a c e
z e r o L o v e l a c e = Ada . l o v e l a c e V a l u e O f 0

: : V a l u e

l o c k F u n d T r i g g e r

: : G . A s E r r o r e => S t r i n g −> V a l u e −> C o n t r a c t

G . Schema e ( V a l u e −> Bool )

l o c k F u n d T r i g g e r

s t r

v a l =

p u r e $ ( \ p r e s e n t V a l −> p r e s e n t V a l

‘V . l e q ‘

z e r o L o v e l a c e )

l o c k S l o t T r i g g e r

: : G . A s E r r o r e e => S t r i n g −> V a l u e −>

C o n t r a c t G . Schema e S l o t

l o c k S l o t T r i g g e r param1 param2 = p u r e $ 10

l o c k : : G . A s E r r o r e => S t r i n g −> V a l u e −> C o n t r a c t G . Schema e

( E i t h e r G . S t a t e G . E r r o r )
v a l = p u r e $

l o c k s t r

i f

v a l

‘V . l e q ‘

z e r o L o v e l a c e

then R i g h t $ E r r o r $ T . pack $ ”The p r i z e must be g r e a t e r

t h a n 0 ; g o t ” <> show v a l

e l s e L e f t

( h a s h S t r i n g s t r , v a l )

g u e s s

: : G . A s E r r o r e => S t r i n g −> C o n t r a c t G . Schema e ( E i t h e r

G . S t a t e G . E r r o r )

g u e s s

s t r = do

s e c r e t <− m a p E r r o r

( r e v i e w Gu ess ing G ame S ME rro r ) $ G .

g e t C u r r e n t S t a t e S M G . c l i e n t
s e c r e t == h a s h S t r i n g s t r

i f

then do

l o g I n f o @ S t r i n g ” C o n g r a t u l a t i o n s , you won ! ”
p u r e $ L e f t

( h a s h S t r i n g s t r ,
e l s e p u r e $ R i g h t $ E r r o r ” I n c o r r e c t g u e s s ,

z e r o L o v e l a c e )

t r y a g a i n ”

c l o s e G a m e

: : G . A s E r r o r e => C o n t r a c t G . Schema e ( E i t h e r G .

S t a t e G . E r r o r )

c l o s e G a m e = do

l o g I n f o @ S t r i n g ” C l o s i n g t h e game”
p u r e $ L e f t

( h a s h S t r i n g ”Game o v e r ” , z e r o L o v e l a c e )

