2
2
0
2

y
a
M
5

]

R
C
.
s
c
[

3
v
3
2
3
2
1
.
1
1
1
2
:
v
i
X
r
a

Information Dispersal with Provable Retrievability for Rollups

Kamilla Nazirkhanova
nazirk@stanford.edu

Joachim Neu
jneu@stanford.edu

David Tse
dntse@stanford.edu

ABSTRACT
The ability to verifiably retrieve transaction or state data stored off-
chain is crucial to blockchain scaling techniques such as rollups or
sharding. We formalize the problem and design a storage- and com-
munication-efficient protocol using linear erasure-correcting codes
and homomorphic vector commitments. Motivated by application
requirements for rollups, our solution Semi-AVID-PR departs from
earlier Verifiable Information Dispersal schemes in that we do not
require comprehensive termination properties. Compared to Data
Availability Oracles, under no circumstance do we fall back to
returning empty blocks. Distributing a file of 22 MB among 256
storage nodes, up to 85 of which may be adversarial, requires in
total ≈ 70 MB of communication and storage, and ≈ 41 s of single-
thread runtime (< 3 s on 16 threads) on an AMD Opteron 6378
processor when using the BLS12-381 curve. Our solution requires
no modification to on-chain contracts of Validium rollups such
as StarkWare’s StarkEx. Additionally, it provides privacy of the
dispersed data against honest-but-curious storage nodes. Finally,
we discuss an application of our Semi-AVID-PR scheme to data
availability verification schemes based on random sampling.

1 INTRODUCTION
1.1 Rollups
Ethereum, like many blockchains, suffers from poor transaction
throughput and latency. To address this issue, various consensus-
layer and off-chain scaling methods were introduced. While consensus-
layer solutions such as sharding [20, 21] or multi-chain protocols
[3, 33] aim at improving the base blockchain protocol, off-chain
‘layer 2’ solutions such as payment channels [11, 25] and rollups
[17, 23] aim at moving transaction processing and storage off-chain.
The base blockchain then serves only as a trust anchor, rollback
prevention mechanism, and arbitrator in case of misbehavior and
disputes among participants. Rollups in particular introduce an
on-chain smart contract representing certain application logic, to
and from which rollup users can transfer funds to enter and exit
the rollup, and who watches over proper execution of the state
machine that describes the rollup’s application logic. Rollup users
appoint an operator whose role is to execute the contract’s state
machine and keep track of updated state such as users’ balances.
For this purpose, the operator collects transactions issued by users
and executes them off the main chain, but periodically posts a state
snapshot to the main chain in order to irrevocably confirm transac-
tion execution and, thus, inherit the main chain’s safety guarantee.
To ensure liveness, rollup users need to be able to enforce applica-
tion logic and to exit the rollup with their funds, even if the rollup
operator turns uncooperative. To this end, if a user presents proof
of their balance according to the latest state snapshot, then the
on-chain contract will pay out their funds to the user and thus
enforce the user’s exit. Rollup designs differ in two crucial aspects.

KN and JN contributed equally and are listed alphabetically.

1

Ensuring State Transition Integrity

Validity Proofs

Fraud Proofs

Validium: StarkWare,
Matter Labs zkPorter,
Loopring

Plasma: OMG Network,
Polygon, Gluon,
Gazelle, LeapDAO

Zk-Rollups: Loopring,
Starkware, Matter Labs
zkSync, Aztec 2.0, Hermez
network, zkTube

Optimistic Rollups:
Optimism, Offchain Labs
Arbitrum, Fuel Network,
Cartesi, OMGX

e
g
a
r
o
t
S

a
t
a
D

n
i
a
h
C
-
ff
O

n
i
a
h
C
-
n
O

Figure 1: Layer 2 and rollup projects grouped into four
categories according to how validity of state transitions
and data availability are ensured (fraud/validity proofs vs.
data storage on/off chain). Source: https://ethereum.org/en/
developers/docs/scaling/, https://twitter.com/vitalikbuterin/
status/1267455602764251138

First, how to ensure that the state is only updated in accordance
with the application logic. Second, how to guarantee that users are
able to exit even if the operator turns malicious and withholds the
information necessary for users to prove their balances on-chain.

1.2 State Integrity and Data Availability
Rollup designs can be grouped into four categories, as illustrated in
Figure 1, according to how they ensure validity of state transitions
and availability of transaction information. For the problem of
ensuring that application logic is followed, one approach is to use
fraud proofs: anyone can re-execute the application logic on the
inputs at hand and check that the state transitions are correct. If
they are not, they present proof of a fraudulent state transition to
the on-chain contract which will step in as an arbitrator and enforce
application logic. Rollups using fraud proofs are called optimistic
rollups. A second approach is based on validity proofs, where instead
of detecting fraud after the fact, fraud is prevented from the get-go
by requiring the operator to provide cryptographic proof [5, 14] of
proper state update. This approach is used in zk-rollups.

To ensure that rollup users are able to track proper execution
of application rules and to prove their balances, there are again
two approaches. The relevant information could be made available
either on the main chain, perhaps in a condensed form, or stored off
the main chain but with some credible assurance that the data is in
fact available for users to retrieve. For the latter purpose, Validium
rollups, i.e., zk-rollups with off-chain storage such as StarkWare’s
‘StarkEx’, introduce a committee of trusted storage nodes. This way,
Validium rollups avoid both the settlement delays introduced by
fraud proofs’ dispute period, and the cost and scalability bottle-
neck of on-chain data storage; making them a promising rollup
construction and attractive subject of study. For the normal oper-
ating mode of a Validium rollup see Figure 2. The rollup operator
deposits a copy of the relevant data with each storage node, who

 
 
 
 
 
 
Rollup Users

Storage Nodes

...

...

Rollup Operator

1

...

3

...

...

4

txs𝑡 −1

state𝑡 −1

txs𝑡

2

state𝑡

Main Chain

5

6

Figure 2: Normal operating mode of a Validium rollup, i.e., a
zk-rollup with off-chain storage: 1 Rollup operator collects
transactions from rollup users. 2 Transactions are executed
by operator off-chain and new state of rollup is calculated.
3 Transaction and state data is dispersed to storage nodes
by operator. 4 Storage nodes confirm receipt. Operator col-
lects sufficient number of confirmations into certificate of
data retrievability. 5 Operator sends commitment to state
and certificate of retrievability to main chain. 6 State snap-
shot and certificate of retrievability are verified and if valid
accepted by main chain.

in turn confirm receipt. A valid state snapshot is accepted by the
main chain only if enough storage nodes have confirmed receipt
of the corresponding full data. As long as enough storage nodes
remain honest and available, rollup users can always turn to them
to obtain the data necessary to prove fraud or balances, should the
rollup operator withhold it.

This solution, however, is not communication- or storage-efficient.
The operator has to send a copy of the entire data to every storage
node which in turn stores an entire copy. Therefore, this solution is
not scalable and works only for a relatively small number of storage
nodes (e.g., a current application of the StarkWare Validium rollup
uses 8 storage nodes [15]), which leads to heavy centralization.
Furthermore, the privacy of user data is violated, as storage nodes
can view the entire state.

1.3 Information Dispersal with Provable

Retrievability

A more communication- and storage-efficient solution is provided
by Verifiable Information Dispersal (VID) as embodied by Asynchro-
nous Verifiable Information Dispersal (AVID [9]) and its successors
AVID-FP [16] and AVID-M [32]. Generally speaking, AVID schemes
encode the input data block into chunks and every storage node has
to store only one chunk rather than the full block. The correctness
of the dispersal is verifiable, meaning that the consistency of chunks

2

Kamilla Nazirkhanova, Joachim Neu, and David Tse

is ensured. A VID scheme consists of two protocols, Disperse and
Retrieve, satisfying [16], informally:
(a) Termination. If Disperse(𝐵) is initiated by an honest client,
then Disperse(𝐵) is eventually completed by all honest storage
nodes.

(b) Agreement. If some honest storage node completes Disperse(𝐵),
all honest storage nodes eventually complete Disperse(𝐵).

(c) Availability. If ‘enough’ honest storage nodes complete Disperse(𝐵),
an honest client that initiates Retrieve() eventually recon-
structs some block 𝐵′.

(d) Correctness. After ‘enough’ honest storage nodes complete
Disperse(𝐵), all honest clients that initiate Retrieve() even-
tually retrieve the same block 𝐵′. If the client that initiated
Disperse(𝐵) was honest, then 𝐵′ = 𝐵.

Although some existing VID schemes can be used to ensure data
availability for rollups, they miss properties that are required for
this application, while having others that are not needed, resulting
in unnecessary complexity (cf. Figure 3). For Validium rollups, it
is crucial that the on-chain rollup contract can verify ( 4 , 5 ) the
retrievability of the underlying data before accepting a new state
update, to ensure that users have access to the data required to
enforce the contract (or be able to exit) on-chain in case of an
uncooperative operator. For this purpose, consistent retrieval of
‘some’ block 𝐵′ ≠ 𝐵 is not enough, the retrievability ( 3 ) of the
original block 𝐵 needs to be ensured. Oppositely, comprehensive
termination properties ( 2 ) such as Termination and Agreement are
not needed, and some VID schemes (here AVID) provide properties
exceeding VID that are not required for the rollup application ( 1 ).
We introduce the concept of Semi-AVID with Provable Retrievabil-
ity (Semi-AVID-PR) to capture the requirements in the rollup ap-
plication. Besides Disperse and Retrieve, a Semi-AVID-PR scheme
provides Commit to succinctly and unequivocally identify data
blocks and Verify to verify certificates of retrievability.

Definition (Semi-AVID-PR Security (Informal), cf. Definition 3.2).
If 𝑓 ≤ 𝑡 nodes are Byzantine, then the Semi-AVID-PR scheme provides:
(a) Commitment-Binding. Commit is a binding deterministic com-

mitment to a block of data.

(b) Correctness. If an honest client initiates Disperse(𝐵), then even-
tually it obtains a valid certificate of retrievability for Commit(𝐵).
(c) Availability. If an honest client invokes Retrieve(𝑃, 𝐶) with
a valid certificate of retrievability 𝑃 for commitment 𝐶, then
eventually it obtains a block 𝐵 such that Commit(𝐵) = 𝐶.

Note that availability is ensured even for certificates of retriev-
ability generated under adversarial dispersal (i.e., malicious rollup
operator). We provide formal game-based definitions of commitment-
binding (cf. Definition 1) and availability (cf. Definition 2).

We propose a construction for a communication- and storage-
efficient Semi-AVID-PR scheme with practical computational cost,
which is compatible with the established on-chain smart contracts
of and thus can be readily adopted for existing Validium rollups, e.g.,
such as StarkWare’s StarkEx. Our construction relies on a collision-
resistant hash function, unforgeable signatures, and a deterministic
homomorphic vector commitment. We provide a reduction-based
security proof. A high-level illustration of Disperse of our scheme is
provided in Figure 4. In our protocol, the rollup operator computes

Information Dispersal with Provable Retrievability for Rollups

1 2 3 ( 4 )

AVID [9]

2 3 ( 4 )

AVID-FP [16]

ACeD [29]

2 5

APDB [22]

4

AVID-M [32]

2 ( 4 )

Semi-AVID-PR
(this work)

3 4

Figure 3: Related protocols and supported properties: 1
Retrieval from any sufficiently large set of storage nodes
2 Comprehensive termination guarantees 3 Retrievability
guaranteed 4 Issues certificates of retrievability 5 Disper-
sal verifiable on-chain

Rollup Operator

Storage Node 𝑖

Data

2

𝑖
k
n
u
h
C

1

Commitments

5

4

3

Verify consistency
of chunk 𝑖 with
commitments

Figure 4: Dispersal in our Semi-AVID-PR scheme. 1 Client
arranges data in matrix and computes vector commitments
of columns. 2 Client encodes data row-wise (same code for
each row). 3 Commitments and chunk 𝑖 are sent to storage
node 𝑖. 4 If chunk 𝑖 is consistent with commitments, storage
node confirms receipt. 5 Enough acknowledgements form
certificate of retrievability.

commitments to chunks of the initial data and encodes it using an
erasure-correcting code. Encoded chunks are dispersed among the
storage nodes along with the commitments. Similarly to AVID-FP,
the commitments allow storage nodes to verify the consistency of
their local chunk with the file for which they are about to acknowl-
edge the receipt of a chunk. If their chunk is consistent, a storage
node confirms receipt to the operator. Upon collecting enough con-
firmations, the operator can produce a certificate of retrievability
for the respective file, which is later verified by the main chain
before accepting the new state snapshot. Additional blinding can be
used in our scheme to provide privacy against honest-but-curious
storage nodes. Finally, the core construction of our scheme can
be used to derive a data availability verification scheme based on
random sampling with practical computational requirements.

1.4 Related Work
The AVID protocol [9] satisfies not only the VID properties, but fur-
thermore guarantees that eventually a dispersed file can be retrieved
from any subset containing 𝑘 honest storage nodes (cf. Figure 3, 1 ),
rather than from only some subset that can be identified from the

3

certificate of retrievability, as for Semi-AVID-PR (following earlier
successors of AVID which also dispense with this excess guarantee).
This is achieved by an additional round of echoing chunks which
leads to a high communication cost for AVID (cf. Table 1), whose
communication complexity is 𝑂 (𝑛|𝐵| + 𝑛3𝜆), with block size |𝐵|,
number of storage nodes 𝑛, and 𝜆-bit security parameter of the
underlying cryptographic primitives. Our Semi-AVID-PR scheme’s
communication and storage complexity is 𝑂 (|𝐵| + 𝑛2𝜆).

AVID-FP [16], a successor of AVID, brings the communication
complexity to 𝑂 (|𝐵| + 𝑛3𝜆) using homomorphic fingerprinting (as
in our Semi-AVID-PR scheme) so that storage nodes can verify their
chunks without echoing them. Since chunks can be verified, retriev-
ability is guaranteed ( 3 ). A round of AVID (with the fingerprints)
is still used to achieve comprehensive termination properties ( 2 ).
A recent advancement of VID, AVID-M [32], improves the com-
munication complexity to 𝑂 (|𝐵| + 𝑛2𝜆) by reducing the size of
fingerprints using Merkle trees [24]. However, chunks cannot be
verified anymore, and AVID-M retrieves as empty block any data
that was maliciously encoded during dispersal, so that retrievabil-
ity is no longer guaranteed. This makes AVID-M less suitable for
application to rollups. The situation is similar for Data Availability
Oracles (DAOs) such as ACeD [29], and for Asynchronous Provable
Dispersal Broadcast (APDB), the primitive implemented by the dis-
persal sub-protocol of Dumbo-MVBA [22]. If a block was invalidly
encoded during dispersal by a malicious client, then AVID-M, DAOs
and APDB ensure consistency across retrieving clients, but no guar-
antee is provided about how the retrieved content relates to the
‘dispersed content’. In contrast, for Semi-AVID-PR, Commit links
available dispersed content and retrieved content, and thus en-
sures that data availability and state transition integrity operate on
the same content. We think of exhibiting Commit as the ‘interface’
where data availability and state transition integrity ‘come together’
in the rollup application as a key contribution of this work.

DAOs and protocols from the VID family differ in terms of how
the rollup’s on-chain contract can verify completion of the dispersal.
Semi-AVID-PR issues certificates of retrievability ( 4 ) that can be
independently verified (e.g., by a smart contract), similar to Dumbo-
MVBA’s dispersal where the dispersing client produces a ‘lock
proof’ consisting of a quorum of signatures from storage nodes
attesting to having received their respective chunks of the dispersed
data. AVID, AVID-FP and AVID-M can readily be extended with
such functionality. DAOs report data availability directly on-chain
via a smart contract ( 5 ). Since AVID, AVID-FP and AVID-M all
perform a round of VID to achieve comprehensive termination
properties, the AVID family is limited to an adversarial resilience
𝑡 < 𝑛/3, in contrast to 𝑡 < 𝑛/2 for Semi-AVID-PR, APDB and ACeD.
Unlike proofs of retrievability [8] and proof of replication [13],
the goal in this work is not to test whether a storage system has
custody of certain intact data and/or whether a storage system
actually delivers the data upon request, as would arguably be the
starting point to study how to incentivize data storage and retrieval
in the honest-but-rational model resulting from open-participation
systems, a surely interesting problem in its own right. Rather, we
leave incentives for future work, and focus in this work on com-
munication, storage, and compute efficient dispersal in the setting
of honest vs. Byzantine participants, where honest nodes follow
the protocol as specified. In practice, for Validium rollups, earlier

dispersed data becomes deprecated as state/transaction information
is ‘overwritten’ by later dispersed data, so that honest storage nodes
are only required to make available the data of recent dispersals
(on the order of days or weeks).

Sampling Based Data Availability Checks. The data availability
problem is not unique to rollups, but arises in other scaling ap-
proaches such as sharding or light clients as well. Solutions like
[1, 34] provide interactive protocols based on random sampling of
chunks of erasure-coded data. A block is deemed available if all
randomly sampled chunks are available, with the assumption being
that if enough nodes’ random queries are answered, then enough
chunks are available to restore the block. However, this interactive
technique is not feasible for rollups since the on-chain contract
cannot engage in random sampling to convince itself of data avail-
ability. Instead, the assurance of data availability could either be
made on-chain (as by Data Availability Oracles) or in the form of
a verifiable certificate of retrievability. However, techniques from
our Semi-AVID-PR scheme can be used to obtain a data availability
check where the consistency of a randomly sampled chunk can be
efficiently verified, obviating fraud proofs for invalid encoding [1].

1.5 Outline
Cryptographic essentials and erasure-correcting codes are reviewed
in Section 2. Model and formal properties of Semi-AVID-PR for the
application in rollups are introduced in Section 3. We describe our
Semi-AVID-PR protocol in Section 4 and prove its security in Sec-
tion 5. Use of blinding to protect privacy of dispersed data against
honest-but-curious storage nodes is discussed in Section 6. An
evaluation of computational cost and storage- and communication-
efficiency in comparison to other schemes is discussed in Section 7.
We close with comments on an application of techniques of our
Semi-AVID-PR scheme to data availability sampling in Section 8.

2 PRELIMINARIES
In this section, we briefly recapitulate tools from cryptography and
erasure-correcting codes used throughout the paper.

2.1 Basics & Notation
Let G be a cyclic group (denoted multiplicatively, i.e., with group
operation ‘·’) of prime order 𝑝 ≥ 22𝜆 with generator 𝑔 ∈ G, where 𝜆
denotes the security parameter used subsequently for all primitives.
The function 𝐻 (𝑥) ≜ 𝑔𝑥 is a bijection between the finite field Z𝑝
(i.e., integers modulo 𝑝) and G. It has the linear homomorphism
property which this paper makes ample use of:

∀𝑛 ≥ 1 : ∀𝑐1, ..., 𝑐𝑛 ∈ Z𝑝 : ∀𝑥1, ..., 𝑥𝑛 ∈ Z𝑝 :

(cid:33)

𝑐𝑖𝑥𝑖

=

𝐻

(cid:32) 𝑛
∑︁

𝑖=1

𝑛
(cid:214)

𝑖=1

𝐻 (𝑥𝑖 )𝑐𝑖

(1)

A hash function HF = (Gen, H), see Definition B.1, is collision
resistant if for any probabilistic poly-time (PPT) adversary A there
exists a negligible function negl(.) such that

Pr(cid:0) CFGHF,A (𝜆) = true (cid:1) ≤ negl(𝜆),
(2)
where CFGHF,A (𝜆) is the collision finding game recapitulated in
Alg. 13. We use CRHF𝑠 (𝑥) ≜ HF.H𝑠 (𝑥) as a notational shorthand.

4

Kamilla Nazirkhanova, Joachim Neu, and David Tse

A signature scheme Sig = (KeyGen, Sign, Verify), see Defini-
tion B.2, is secure under existential forgery if for any PPT adversary
A there exists a negligible function negl(.) such that

Pr(cid:0) EFGSig,A (𝜆) = true (cid:1) ≤ negl(𝜆),
where EFGSig,A (𝜆) is the existential forgery game of Alg. 12.

We denote by [𝒙]𝑖 the 𝑖-th entry of a vector 𝒙, by [𝑿 ]𝑖 the 𝑖-
th column of a matrix 𝑿 , and by [𝑛] ≜ {1, ..., 𝑛}. In algorithms,
Π[𝑓 (.)/𝑔(.)] denotes substitution of 𝑓 (.) for 𝑔(.) in the code of Π.

(3)

2.2 Reed-Solomon Codes
A linear (𝑛, 𝑘)-code is a linear mapping Z𝑘
𝑝 with 𝑛 ≥ 𝑘. It can
be represented by a 𝑘 × 𝑛 generator matrix 𝑮, with the encoding
operation then 𝒄⊤ = 𝑮.Encode(𝒖⊤) ≜ 𝒖⊤𝑮 to obtain a length-𝑛
row vector of codeword symbols 𝒄⊤ from a length-𝑘 row vector of
information symbols 𝒖⊤.

𝑝 → Z𝑛

A linear code is maximum distance separable (MDS) if any 𝑘
columns of its generator matrix 𝑮 are linearly independent, i.e.,
any 𝑘 × 𝑘 submatrix of 𝑮 is invertible. Thus, any set of codeword
symbols 𝑐𝑖 𝑗 from 𝑘 distinct indices 𝑖 𝑗 can be used to uniquely decode
using the relation induced by the encoding 𝒄⊤ = 𝒖⊤𝑮,

𝒖⊤ (cid:2)𝒈𝑖1
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:124)

(cid:3)

... 𝒈𝑖𝑘
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:123)(cid:122)
(cid:125)
≜ ˜𝑮

!

= (cid:2)𝑐𝑖1
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:124)

(cid:3)

... 𝑐𝑖𝑘
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:123)(cid:122)
(cid:125)
≜˜𝒄 ⊤
𝑗=1) ≜ ˜𝒄⊤ ˜𝑮

⇐⇒ 𝒖⊤ = 𝑮.Decode(((𝑖 𝑗 , 𝑐𝑖 𝑗 ))𝑘

−1,

(4)

where 𝒈𝑖 corresponds to the 𝑖-th column of the generator matrix 𝑮.
Reed-Solomon codes [28] are an important class of MDS codes.
Here, an information vector 𝒖⊤ is associated with a polynomial
𝑈 (𝑋 ) = (cid:205)𝑘
𝑗=1 [𝒖⊤]𝑖𝑋 𝑖−1 and the codeword vector is obtained by
evaluating 𝑈 (𝑋 ) at 𝑛 distinct locations 𝛼1, ..., 𝛼𝑛, such that 𝒄⊤ =
(𝑈 (𝛼1), ..., 𝑈 (𝛼𝑛))⊤. This corresponds to a generator matrix 𝑮RS
𝑖 , ..., 𝛼𝑘−1
with columns 𝒈RS,𝑖 = (𝛼 0
𝑖

).

2.3 Linear Vector Commitment Schemes
A deterministic vector commitment (VC) scheme VC = (Setup, Commit,
OpenEntry, VerifyEntry) [10, 24] for vectors of length 𝐿 allows to
commit to an element of Z𝐿
𝑝 . Later, the commitment can be com-
pared to the commitment of another vector to check a vector open-
ing, and it can be opened to individual entries of the vector. Ideally,
the proof for the opening of an entry of the vector is short and
computationally easy to generate and verify. For our purposes it
is important that the VC is binding, i.e., a commitment cannot be
opened to values that are inconsistent with the committed vector.
Specifically, we call a VC, see Definition B.3, binding if for any PPT
adversary A there exists a negligible function negl(.) such that
Pr(cid:0) VCBGLVC,A (𝜆) = true (cid:1) ≤ negl(𝜆).
(5)
where VCBGLVC,A (𝜆) is the binding game defined in Alg. 14. We
use VC(𝒗) ≜ LVC.Commit(𝒗) as a notational shorthand.

For this manuscript of particular interest are linearly homomor-

phic (also simply called linear) VCs (LVC) with

∀𝛼, 𝛽 ∈ Z𝑝 : ∀𝒗, 𝒘 ∈ Z𝐿
𝑝 :
Commit(𝛼𝒗 + 𝛽𝒘) = 𝛼Commit(𝒗) + 𝛽Commit(𝒘).

(6)

Information Dispersal with Provable Retrievability for Rollups

Kate-Zaverucha-Goldberg (KZG) polynomial commitments [18]
(here the ‘basic’ variant PolyCommitDL of [18] as KZG) can be
readily turned into an example linear VC, which we use subse-
quently and introduce here briefly. From a vector 𝒖 of length 𝐿 in-
terpolate a polynomial 𝑈 (𝑋 ) of degree (𝐿 −1) such that 𝑈 (𝑖) = [𝒖]𝑖
for 𝑖 = 1, ..., 𝐿. Commit to 𝒖 by KZG.Commit(𝑈 ).1 The vector open-
ing can be verified by recomputing the commitment. The entry [𝒖]𝑖
can be opened and the opening verified using KZG.CreateWitness
and KZG.VerifyEval for the corresponding 𝑈 (𝑋 ) at 𝑋 = 𝑖, respec-
tively.

To see that the resulting VC’s Commit is linear, consider this.
During trusted setup, KZG.Setup samples 𝑟 R
←− Z𝑝 and computes
public parameters (𝑔𝑟 0, ..., 𝑔𝑟 𝐿−1 ). KZG.Commit computes the com-
mitment to a polynomial 𝑈 (𝑋 ) of degree (𝐿 − 1) with coefficients
𝛾0, ..., 𝛾𝐿−1 as 𝑔𝑈 (𝑟 ) which, due to the linear homomorphism of
𝐻 (𝑥) = 𝑔𝑥 , can be obtained from the public parameters as

KZG.Commit(𝛾0, ..., 𝛾𝐿−1) = KZG.Commit(𝑈 ) =

𝐿−1
(cid:214)

𝑗=0

(𝑔𝑟 𝑗

)𝛾 𝑗 . (7)

Since interpolation of coefficients 𝜸 = (𝛾0, ..., 𝛾𝐿−1) of 𝑈 (𝑋 ) from a
vector 𝒖 such that 𝑈 (𝑖) = [𝒖]𝑖 for 𝑖 = 1, ..., 𝐿 is linear and invertible,
Commit is linear. When using KZG-based LVCs, our protocol in-
herits its trusted setup. Parameters generated in recent ceremonies
can be reused (cf. Zcash’s or Filecoin’s ‘Powers of Tau’ [7]).

3 MODEL
The system under discussion consists of 𝑛 storage nodes 𝑃1, ..., 𝑃𝑛
and some clients. A PPT adversary can corrupt protocol participants
adaptively, i.e., as the protocol execution progresses. Corrupt partic-
ipants surrender their internal state to the adversary immediately
and from thereon behave as coordinated by the adversary. We de-
note by 𝑓 the number of storage nodes corrupted over the course of
the execution, and by 𝑡 the design resilience, i.e., our construction
is parametric in 𝑡 and satisfies the desired security properties in all
executions with 𝑓 ≤ 𝑡. Protocol participants can send each other
messages (a priori without sender identification) which undergo
delay controlled by the adversary, subject to the constraint that
every message has to arrive eventually. We design a scheme with
the following interface and security properties.

Definition 3.1 (Semi-AVID-PR Syntax). A Semi-AVID (Asynchro-
nous Verifiable Information Dispersal) Scheme with Provable Retriev-
ability (ΠSAVIDPR) consists of two algorithms, Commit and Verify,
and three protocols, Setup, Disperse and Retrieve.
• Setup : 1𝜆 ↦→ (pp, sp1, ..., sp𝑛): The protocol Setup is run by a
temporary trusted party and all storage nodes, at the beginning
of time (i.e., before adversarial corruption). It takes as input the
security parameter 1𝜆 and outputs global public parameters pp,
and local secret parameters sp1, ..., sp𝑛, one per storage node.
The public parameters pp are common knowledge and input
to all other algorithms and protocols. The secret parameters
sp1, ..., sp𝑛 are part of the state of a storage node and as such
available to that node during Disperse and Retrieve invocations.
1The polynomial interpolation can be avoided by preprocessing the public parameters
of KZG to obtain them in the Lagrange polynomial basis.

1

scheme

Commitment-binding

Semi-AVID-PR

Algorithm
against
(Setup, Commit, Disperse, Verify, Retrieve)
1: (pp, sp1, ..., sp𝑛) ← Setup(1𝜆)
⊲ Run setup for all parties
2: (𝐵, 𝐵′) ← ACBG (pp, sp1, ..., sp𝑛) ⊲ A can simulate any party
3: return 𝐵 ≠ 𝐵′ ∧ Commit(𝐵) = Commit(𝐵′)

game
ΠSAVIDPR

(CBG)
=

Algorithm 2 Availability game
Semi-AVID-PR
𝑡
(Setup, Commit, Disperse, Verify, Retrieve)

scheme

against

(AvG) with resilience
=

ΠSAVIDPR

1: C ← ∅
2: ∀𝑖 ∈ [𝑛] : 𝑃𝑖 ← new ΠSAVIDPR (∅)

⊲ Bookkeeping of corrupted parties
⊲ Instantiate 𝑃𝑖 as

⊲ Run setup among all parties
⊲ Oracle for A to corrupt parties

ΠSAVIDPR with blank state

3: pp ← Setup𝑃1,...,𝑃𝑛 (1𝜆)
4: function Ocorrupt(𝑖)
assert 𝑖 ∉ C
5:
C ← C ∪ {𝑖}
return 𝑃𝑖

6:

10:

11:

⊲ Mark party as corrupted
⊲ Hand 𝑃𝑖 ’s state to A
7:
8: function Ointeract(𝑖, 𝑚) ⊲ Oracle for A to interact with parties
9:

assert 𝑖 ∉ C
return 𝑃𝑖 (𝑚) ⊲ Execute 𝑃𝑖 on input 𝑚, return output to A
⊲ A
𝑃, 𝐶,
AvG
returns certificate of retrievability 𝑃, commitment 𝐶, and oracle
access to corrupted nodes for retrieval

← A Ocorrupt (.),Ointeract (.)

Onode
𝑖

(pp)

𝑖 ∈ C

(.)

(cid:16)

(cid:16)

(cid:17)

(cid:17)

12: ^𝐵 ← Retrieve𝑃1,...,𝑃𝑛 (cid:2)Onode

⊲
During retrieval, interact with corrupted nodes through oracles
⊲ A wins iff: while

13: return |C| ≤ 𝑡

(.)/Query(𝑖, .)(cid:3)

𝑖 ∈ C (𝑃, 𝐶)

𝑖

∧ Verify(𝑃, 𝐶) = true
∧ Commit( ^𝐵) ≠ 𝐶

corrupting no more than 𝑡 parties, A produces a valid certificate
of retrievability 𝑃 for 𝐶 such that retrieval does not return a file
matching 𝐶

Explicit mention of these inputs is subsequently omitted for
simplicity of notation.

• Commit : 𝐵 ↦→ 𝐶: The algorithm Commit takes as input a block

𝐵 of data, and returns a commitment 𝐶 to the data.

• Disperse : 𝐵 ↦→ 𝑃: The protocol Disperse is run by a client and
all storage nodes. It takes as input a block 𝐵 of data at the client,
and outputs ⊥ or a certificate of retrievability 𝑃 for commitment
𝐶 = Commit(𝐵) to the client.

• Verify : (𝑃, 𝐶) ↦→ 𝑏 ∈ {true, false}: The algorithm Verify
takes as input a certificate of retrievability 𝑃 and a commit-
ment 𝐶, and returns true or false, depending on whether the
certificate is considered valid.

• Retrieve : (𝑃, 𝐶) ↦→ 𝐵: The protocol Retrieve is run by a client
and all storage nodes. It takes as input a certificate of retriev-
ability 𝑃 and a commitment 𝐶 at the client, and outputs ⊥ or a
block 𝐵 of data to the client.

Definition 3.2 (Semi-AVID-PR Security). A Semi-AVID-PR scheme
ΠSAVIDPR is secure with resilience 𝑡 if for all executions with 𝑓 ≤ 𝑡:
(1) Commitment-Binding. Commit of ΠSAVIDPR implements
a binding deterministic commitment to a block 𝐵 of data. More

5

formally, ΠSAVIDPR is commitment-binding if for any PPT
adversary A there exists a negligible function negl(.) such
that

Pr(cid:0) CBGΠSAVIDPR,A (𝜆) = true (cid:1) ≤ negl(𝜆),

(8)
where CBGΠSAVIDPR,A (𝜆) is the commitment-binding game
defined in Alg. 1.

(2) Correctness. If an honest client invokes Disperse with a block
𝐵 of data, then eventually it outputs a certificate of retrievability
𝑃 with the property that Verify(𝑃, Commit(𝐵)) = true.
(3) Availability. For a certificate of retrievability 𝑃 and a commit-
ment 𝐶, if Verify(𝑃, 𝐶) = true, then if an honest client invokes
Retrieve with 𝑃 and 𝐶, then eventually it outputs a block 𝐵
of data such that Commit(𝐵) = 𝐶. More formally, ΠSAVIDPR
provides availability if for any PPT adversary A there exists a
negligible function negl(.) such that

Pr(cid:0) AvGΠSAVIDPR,A (𝜆, 𝑡) = true (cid:1) ≤ negl(𝜆),

(9)
where AvGΠSAVIDPR,A (𝜆, 𝑡) is the availability game defined
in Alg. 2. (Π[𝑓 (.)/𝑔(.)] denotes replacing 𝑔(.) with 𝑓 (.) in Π.)

A few remarks are due on this formulation. First, note the inter-
play of Commitment-Binding and Availability. Because of Commitment-
Binding, Availability ensures that any block, for which there is a
valid certificate of retrievability, can be retrieved by honest clients.
This holds even if the certificate was produced adversarially, e.g.,
by a malicious rollup operator tampering with the dispersal.

Unlike earlier formulations of AVID [9, 16, 32], our formula-
tion does not have independent session identifiers. Instead, the
scheme provides a binding commitment scheme which is used to
establish a link between the data in question, invocations of the
dispersal/retrieval protocols, and certificates of retrievability. The
completion of dispersal of a block and the possibility to retrieve
content matching a commitment are tied together through the
Commitment-Binding property of the commitment scheme and can
be proven to a third party using the certificate of retrievability. This
matches the Validium rollup application, where on the one hand
retrievability of content matching a certain commitment needs to
be verifiable on-chain, and on the other hand validity of the block
content is proved and verified with respect to the commitment.

This can also be seen as following the paradigm shift from
location-addressed to content-addressed storage and is particu-
larly suitable for applications such as rollups or sharding where
one wants to succinctly but unequivocally identify what content
is being referenced rather than where to find it. In terms of the
original four properties of AVID schemes [9], our Correctness prop-
erty takes the place of the Termination and Agreement properties,
and our Availability property takes the place of the Availability
and Correctness properties. Above weakenings (hence the name
‘Semi’-AVID) allow us to achieve greater resilience up to 𝑡 < 𝑛/2
rather than 𝑡 < 𝑛/3 as for AVID, AVID-FP or AVID-M.

4 PROTOCOL
We provide a construction Π⋆ of Semi-AVID-PR from a binding
deterministic linear vector commitment scheme LVC, a maximum
distance separable (𝑛, 𝑘)-code Code, a collision resistant hash func-
tion CRHF𝑠 , and a secure digital signature scheme Sig. Our con-
struction satisfies the properties laid out in Section 3 as shown in

6

Kamilla Nazirkhanova, Joachim Neu, and David Tse

Algorithm 3 Π⋆.Setup(1𝜆)
1: At the trusted party:
2: ppLVC ← LVC.Setup(1𝜆)
3: ppHF ← HF.Gen(1𝜆)
4: At each storage node 𝑖:
5: return pp = (ppLVC, ppHF, pk1, ..., pk𝑛), sp1 = sk1, ..., sp𝑛 =

(pk𝑖, sk𝑖 ) ← Sig.KeyGen(1𝜆)

sk𝑛

Algorithm 4 Π⋆.Commit(𝐵)
1: 𝑼 ← AsMatrix𝐿×𝑘 (𝐵)
2: (ℎ1, ..., ℎ𝑘 ) ← VC⊗𝑘 (𝑼 )
3: return CRHF𝑠 (ℎ1 ∥...∥ℎ𝑘 )

Algorithm 5 Π⋆.Verify(𝑃, 𝐶)
1: ^𝑞 ← |{𝑖 | ∃(𝑖 ↦→ 𝜎) ∈ 𝑃 : Sig.Verify(pk𝑖, (ack, 𝐶), 𝜎) = true}|
2: if ^𝑞 ≥ 𝑞 return true
3: return false

Algorithm 6 Π⋆.Disperse(𝐵)
1: At the client:
2: 𝑼 ← AsMatrix𝐿×𝑘 (𝐵)
3: (ℎ1, ..., ℎ𝑘 ) ← VC⊗𝑘 (𝑼 )
4: 𝑪 ← Code.Encode⊗𝐿 (𝑼 )
5: Send (store, (ℎ1, ..., ℎ𝑘 ), 𝒄𝑖 ) to all storage nodes 𝑖
6: At storage node 𝑖 upon receiving (store, (ℎ1, ..., ℎ𝑘 ), 𝒄𝑖 ):
7: ^ℎ ← [Code.Encode(ℎ1, ..., ℎ𝑘 )]𝑖
8: if ^ℎ ≠ VC(𝒄𝑖 ) abort
9: 𝐶 ← CRHF𝑠 (ℎ1 ∥...∥ℎ𝑘 )
10: Store 𝐶 ↦→ ((ℎ1, ..., ℎ𝑘 ), 𝒄𝑖 )
11: Send 𝜎𝑖 ≜ Sig.Sign(sk𝑖, (ack, 𝐶)) to client
12: At the client:
13: Wait

unique

for

𝑞
{𝑖 𝑗 }
𝑗=1

with

from 𝑞
𝜎𝑖 𝑗
, (ack, 𝐶), 𝜎𝑖 𝑗 ) = true

Sig.Verify(pk𝑖 𝑗

14: return (cid:208)𝑞

𝑗=1{𝑖 𝑗 ↦→ 𝜎𝑖 𝑗 }

Section 5. Moreover, it is storage- and communication-efficient and
incurs practically moderate cost for cryptographic computations
and erasure-correction coding as demonstrated in Section 7. It is
easy to extend our scheme with blinding such that an honest-but-
curious storage node cannot learn anything about the dispersed
data from its chunk (see Section 6).

Our construction Π⋆ is provided in Algs. 3 to 7. See also Fig-
ure 5 for an illustration of the Disperse protocol (cf. Figure 4). Our
approach is related to AVID-FP [16] in that we also use the linear
homomorphism between the LVC and the erasure-correcting code.
More specifically, during Disperse, the input file 𝐵 is arranged as an
𝐿 × 𝑘 matrix 𝑼 (using AsMatrix𝐿×𝑘 ) and a commitment ℎ𝑖 is taken
per column 𝒖𝑖 . Vectorization of the 𝑘 column commitments of 𝑼 is
denoted as VC⊗𝑘 (𝑼 ). The matrix is encoded row-wise into a coded
matrix 𝑪, of which each column 𝒄𝑖 constitutes the chunk for storage
server 𝑖. Vectorization of the 𝐿 row encodings of 𝑼 is denoted as

Information Dispersal with Provable Retrievability for Rollups

Algorithm 7 Π⋆.Retrieve(𝑃, 𝐶)
1: At the client:
2: Extract

from

𝑃
{𝑖 | ∃(𝑖 ↦→ 𝜎) ∈ 𝑃 : Sig.Verify(pk𝑖, (ack, 𝐶), 𝜎) = true}

any

𝑞

unique

3: Send (load, 𝐶) to all storage nodes 𝑖
4: At storage node 𝑖 upon receiving (load, 𝐶):
5: Load 𝐶 ↦→ ((ℎ1, ..., ℎ𝑘 ), 𝒄𝑖 )
6: Send (𝑖, (ℎ1, ..., ℎ𝑘 ), 𝒄𝑖 ) to client
7: At the client:
8: Wait for (ℎ1, ..., ℎ𝑘 ) such that 𝐶 = CRHF𝑠 (ℎ1 ∥...∥ℎ𝑘 )
9: ^𝒉 ← Code.Encode(ℎ1, ..., ℎ𝑘 )
10: Discarding any 𝑖 with [^𝒉]𝑖 ≠ VC(𝒄𝑖 ), wait for 𝑘 remaining

unique {𝑖 𝑗 }𝑘

𝑗=1
11: return Code.Decode(((𝑖 𝑗 , 𝒄𝑖 𝑗 ))𝑘

𝑗=1)

Client

𝑘

𝐿

1
𝒖

2
𝒖

3
𝒖

...

𝑘
𝒖

VC⊗𝑘

ℎ1ℎ2ℎ3

... ℎ𝑘

𝐿
⊗

e
d
o
c
n
E
.
e
d
o
C

𝑛

1
𝒄

2
𝒄

3
𝒄

...

𝑖
𝒄

...

𝑛
𝒄

𝐿

(store, (ℎ1, ..., ℎ𝑘 ), 𝒄𝑖 )

𝑃 = (cid:208)𝑞

𝑗 =1 {𝑖 𝑗 ↦→ 𝜎𝑖 𝑗 }

𝜎𝑖 ≜ Sig.Sign(sk𝑖, (ack, 𝐶))

Storage Node 𝑖

[Code.Encode(ℎ1, ..., ℎ𝑘 ) ]𝑖
?= VC(𝒄𝑖 )
If not, abort. Else,
𝐶 ← CRHF𝑠 (ℎ1 ∥... ∥ℎ𝑘 ),
𝑆𝑖 [𝐶 ] ← ( (ℎ1, ..., ℎ𝑘 ), 𝒄𝑖 ).

Figure 5: Disperse protocol of our Semi-AVID-PR construc-
tion Π⋆ (cf. Figure 4). Client arranges data in 𝐿 × 𝑘 matrix
𝑼 , computes commitments ℎ1, ..., ℎ𝑘 column-wise and 𝐿 × 𝑛
coded matrix 𝑪 row-wise. Commitments and 𝑖-th column
𝒄𝑖 of 𝑪 are sent to storage node 𝑖. Upon verification, stor-
age node computes commitment 𝐶 to the data, stores com-
mitments and chunk, and acknowledges receipt of chunk
to client. Client forms certificate of retrievability 𝑃 from 𝑞
unique server identifiers 𝑖 𝑗 and their receipts 𝜎𝑖 𝑗 .

Code.Encode⊗𝐿 (𝑼 ). Now, due to the linear homomorphism, the
commitment of the encodings 𝒄𝑖 is equal to the encoding of the
commitments ℎ𝑖 . This allows storage nodes to easily verify the con-
sistency of their chunk with the uncoded data (i.e., the verifiability
property in AVID). For this check, a storage node only needs to
know the commitments ℎ𝑖 of the uncoded data, which keeps the
communication-overhead of the scheme low. Our approach differs
from AVID-FP in that AVID-FP still performs a round of AVID (for
the commitments) in order to satisfy the full AVID requirements (in
particular Termination and Agreement), while our Semi-AVID-PR
scheme satisfies only the weaker Correctness property (cf. Figure 3).
Our construction is parametric in the design resilience 𝑡, the
quorum size 𝑞 for certificates of retrievability, the code dimension
𝑘 and the length of chunks 𝐿. The analysis of Section 5 reveals that

7

𝑞 ≤ (𝑛 − 𝑡), 0 < (𝑞 − 𝑡) and 𝑘 ≤ (𝑞 − 𝑡) are necessary. So given any
𝑡 < 𝑛/2 and target file size |𝐵| (in field elements), choose 𝑞 ≜ (𝑛 −𝑡),
minimize storage overhead with 𝑘 ≜ 𝑛 − 2𝑡, and set 𝐿 ≜ |𝐵|/𝑘.

During Setup (Algorithm 3), a trusted party performs the setup
of the LVC and the HF, and each storage node generates a crypto-
graphic identity for Sig. The public parameters of the LVC and the
public keys of the storage nodes become common knowledge, each
storage node stores its secret key.

The Commitment of a block 𝐵 (Algorithm 4) is computed by
arranging 𝐵 as an 𝐿 × 𝑘 matrix 𝑼 , then computing the commit-
ments ℎ𝑖 as VC(𝒖𝑖 ) for each of the 𝑘 columns 𝒖𝑖 of 𝑼 , and finally
CRHF𝑠 (ℎ1 ∥...∥ℎ𝑘 ) is the commitment.

To Disperse a block 𝐵 (Algorithm 6, Figures 4, 5), the client first
computes 𝑼 and the commitments ℎ𝑖 as for Commit. Then, 𝑼 is
encoded row-wise using Code.Encode to obtain an 𝐿 × 𝑛 coded
matrix 𝑪. Each column 𝒄𝑖 of 𝑪 is sent to storage node 𝑖 together
with (ℎ1, ..., ℎ𝑘 ). Each storage node 𝑖 verifies its chunk using the
linearly homomorphic property (aborting if violated)

?
= VC(𝒄𝑖 ),

[Code.Encode(ℎ1, ..., ℎ𝑘 )]𝑖

(10)
before computing the file’s commitment 𝐶 ≜ CRHF𝑠 (ℎ1 ∥...∥ℎ𝑘 )
and storing commitments and chunk indexed by 𝐶. The storage
node then acknowledges receipt of the chunk by sending a signature
on (ack, 𝐶) to the client. Upon collecting valid signatures 𝜎𝑖 𝑗 from
𝑞 unique storage nodes 𝑖 𝑗 , the client collects them into a certificate
of retrievability 𝑃.

To Verify a certificate of retrievability 𝑃 for a commitment 𝐶
(Algorithm 5), one counts whether 𝑃 contains valid signatures on
(ack, 𝐶) from at least 𝑞 unique storage nodes.

Finally, to Retrieve a file based on a certificate of retrievability 𝑃
for a commitment 𝐶, the client first extracts any 𝑞 unique storage
nodes for which 𝑃 contains a valid signature on (ack, 𝐶). The client
then queries the chunks of 𝐶 from these storage nodes. The storage
nodes reply with the commitments and chunks they have stored for
𝐶. The client first waits until some commitments (ℎ1, ..., ℎ𝑘 ) satisfy
𝐶 = CRHF𝑠 (ℎ1 ∥...∥ℎ𝑘 ). Then, the client discards any chunks that
do not satisfy the homomorphic property (10). Upon receiving valid
chunks from 𝑘 unique storage nodes, the client uses Code.Decode
to decode the file.

To protect the data against honest-but-curious storage nodes
(i.e., assuming storage nodes do not collude—clearly, a sufficiently
large set of storage nodes can retrieve the data, which is a design
goal of Semi-AVID-PR), 𝑼 can be augmented by the client with a
column and a row drawn uniformly a random, to blind the encoded
chunks. Details in Section 6.

5 SECURITY PROOF
We first provide a proof sketch to convey the relevant high level intu-
ition, before providing a formal reduction-based proof of Commitment-
Binding and Availability in Lemmas 5.2 and 5.3.

Theorem 5.1. The Semi-AVID-PR construction Π⋆

of Section 4
is secure with resilience 𝑡 for any 𝑡 < 𝑛/2 as defined in Section 3,
assuming HF is collision resistant, Sig is existentially unforgeable,
and LVC is binding.

Proof sketch. Commitment-Binding. Π⋆ is deterministic
because VC and CRHF𝑠 are. For binding, assume for contradiction
that Π⋆ was not commitment-binding, i.e., there was an adver-
sary A that can produce blocks 𝐵 ≠ 𝐵′ such that Commit(𝐵) =
Commit(𝐵′) with non-negligible probability. Since 𝐵 ≠ 𝐵′, for their
respective representations as 𝐿 × 𝑘 matrices, 𝑼 ≠ 𝑼 ′. Either 𝒉 ≜
VC⊗𝑘 (𝑼 ) ≠ VC⊗𝑘 (𝑼 ′) ≜ 𝒉′ but CRHF𝑠 (𝒉) = CRHF𝑠 (𝒉′), a colli-
sion in CRHF𝑠 , which can happen with negligible probability only
by assumption, or 𝒉 = 𝒉′, so that for some 𝑖, VC([𝑼 ]𝑖 ) = VC([𝑼 ′]𝑖 )
but [𝑼 ]𝑖 ≠ [𝑼 ′]𝑖 , so ([𝑼 ]𝑖, [𝑼 ′]𝑖 ) is a pair that breaks the binding
property of VC, which can happen with negligible probability only
by assumption. Thus, Π⋆ is commitment-binding.

Lemma 5.2 below establishes Commitment-Binding formally.
Correctness. Since the client is honest and LVC is linearly ho-
momorphic, the consistency check in Algorithm 6 l. 8 passes at all
honest storage nodes. So the client receives signatures 𝜎𝑖 𝑗 (which
are valid, by correctness of Sig) of (ack, Commit(𝐵)) from at least
(𝑛 − 𝑡) unique storage nodes 𝑖 𝑗 , which it can bundle into a certifi-
cate of retrievability 𝑃 that satisfies the check of Algorithm 5 by
construction, if 𝑞 ≤ (𝑛 − 𝑡).

Availability. Since Verify(𝑃, 𝐶) = true by assumption, the
client can extract some 𝑞 unique storage nodes 𝑖 𝑗 from 𝑃 in Al-
gorithm 7 l. 2. Of these 𝑞 storage nodes, at least (𝑞 − 𝑡) remain
honest. Security of Sig implies that they must have previously
executed Algorithm 6 l. 11 and hence stored (ℎ1, ..., ℎ𝑘 ) for 𝐶 =
CRHF𝑠 (ℎ1, ..., ℎ𝑘 ) in Algorithm 6 l. 10 and their chunks satisfied
the consistency check in Algorithm 6 l. 8. Note that by collision
resistance of CRHF𝑠 , there can be only one set of (ℎ1, ..., ℎ𝑘 ) for
𝐶. As long as (𝑞 − 𝑡) > 0, the client eventually completes the wait
in Algorithm 7 l. 8, and if 𝑘 ≤ (𝑞 − 𝑡), then the client eventu-
ally also completes the wait in Algorithm 7 l. 10. Finally, since
Code is an MDS (𝑛, 𝑘)-code, Algorithm 7 l. 11 succeeds to de-
code a block 𝐵, corresponding to an 𝐿 × 𝑘 matrix 𝑼 . It remains
to show that Commit(𝐵) = 𝐶, for which (by CRHF𝑠 ) it suffices
that (ℎ1, ..., ℎ𝑘 ) = VC⊗𝑘 (𝑼 ). Note the decoder uses that Code is
an MDS (𝑛, 𝑘)-code and thus any 𝑘 × 𝑘 submatrix of its generator
matrix 𝑮 is invertible, and the relation
... 𝒄𝑖𝑘
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:123)(cid:122)
(cid:125)
≜ ˜𝑪

(cid:2)𝒖1 ... 𝒖𝑘
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:123)(cid:122)
(cid:125)
(cid:124)
=𝑼

... 𝒈𝑖𝑘
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:123)(cid:122)
(cid:125)
≜ ˜𝑮

= (cid:2)𝒄𝑖1
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:124)

⇐⇒ 𝑼 = ˜𝑪 ˜𝑮

(cid:2)𝒈𝑖1
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:124)

−1.

(11)

(cid:3)

(cid:3)

(cid:3)

!

At the same time, by the checks in Algorithm 7 l. 10,
(cid:3) ˜𝑮 = (cid:2)VC(𝒄𝑖1 ) ... VC(𝒄𝑖𝑘 )(cid:3) .

(cid:2)ℎ1 ... ℎ𝑘

By the linear homomorphism of LVC,
−1

VC⊗𝑘 (𝑼 ) = VC⊗𝑘 ( ˜𝑪) ˜𝑮

= (cid:2)ℎ1 ... ℎ𝑘

(cid:3) .

(12)

(13)

Thus, as long as the retrieving client receives enough chunks from
honest storage nodes such that Retrieve outputs any block ^𝐵 rather
than ⊥, Commit( ^𝐵) = 𝐶 for the commitment 𝐶 associated with
the certificate of retrievability 𝑃. This insight is crucial for the
subsequent formal proof of Availability.

Lemma 5.3 below establishes Availability formally.
Resilience. From above analysis, we obtain the constraints 𝑞 ≤
(𝑛 − 𝑡) (for Correctness), 0 < (𝑞 − 𝑡) (for Availability, to obtain
ℎ1, ..., ℎ𝑘 ), and 𝑘 ≤ (𝑞 − 𝑡) (for Availability, to decode), which the

Kamilla Nazirkhanova, Joachim Neu, and David Tse

(cf. Alg. 3) ...

⊲ ... except use 𝑠 for ppHF

Algorithm 8 ACFG←CBG (𝑠) constructed from ACBG
⊲ Setup Π⋆
1: ppLVC ← LVC.Setup(1𝜆)
2: ∀𝑖 ∈ [𝑛] : (pk𝑖, sk𝑖 ) ← Sig.KeyGen(1𝜆)
3: ppHF ← 𝑠
4: pp ← (ppLVC, ppHF, pk1, ..., pk𝑛)
5: (𝐵, 𝐵′) ← ACBG (pp, sp1, ..., sp𝑛)
6: 𝑼 ← AsMatrix𝐿×𝑘 (𝐵)
7: 𝑼 ′ ← AsMatrix𝐿×𝑘 (𝐵′)
8: (ℎ1, ..., ℎ𝑘 ) ← VC⊗𝑘 (𝑼 )
𝑘 ) ← VC⊗𝑘 (𝑼 ′)
, ..., ℎ′
9: (ℎ′
1
10: if ℎ1 ∥...∥ℎ𝑘 ≠ ℎ′
1 ∥...∥ℎ′
𝑘
𝑠 (ℎ1 ∥...∥ℎ𝑘 ) = CRHF
∧ CRHF
1 ∥...∥ℎ′
return (ℎ1 ∥...∥ℎ𝑘, ℎ′
𝑘 )

𝑠 (ℎ′

11:
12: else
13:

abort

1 ∥...∥ℎ′
𝑘 )
⊲ Collision in HF.H

⊲ No collision identified

(cf. Alg. 3) ...

⊲ ... except use pp for ppLVC

⊲ Setup Π⋆

Algorithm 9 AVCBG←CBG (pp) constructed from ACBG
1: ppHF ← HF.Gen(1𝜆)
2: ∀𝑖 ∈ [𝑛] : (pk𝑖, sk𝑖 ) ← Sig.KeyGen(1𝜆)
3: ppLVC ← pp
4: pp ← (ppLVC, ppHF, pk1, ..., pk𝑛)
5: (𝐵, 𝐵′) ← ACBG (pp, sp1, ..., sp𝑛)
6: 𝑼 ← AsMatrix𝐿×𝑘 (𝐵)
7: 𝑼 ′ ← AsMatrix𝐿×𝑘 (𝐵′)
8: if ∃𝑖 ∈ [𝑘] : [𝑼 ]𝑖 ≠ [𝑼 ′]𝑖 ∧ VC([𝑼 ]𝑖 ) = VC([𝑼 ′]𝑖 )
9:
10: else
11:

return ([𝑼 ]𝑖, [𝑼 ′]𝑖 )

abort

choice of parameters in Section 4 satisfies, and which lead to the
□
resilience bound 𝑡 < 𝑛/2.

We proceed to give formal reduction-based proofs of the Com-

mitment-Binding and Availability properties of Π⋆.

Lemma 5.2. If HF is collision resistant and LVC is binding, then
is commitment-binding, i.e., for all PPT adversaries ACBG there

Π⋆
exists a negligible function negl(.) such that
(cid:17)

(cid:16)

(𝜆) = true

≤ negl(𝜆).

(14)

Pr

CBGΠ⋆,ACBG

Proof. Let ACBG be an arbitrary PPT CBG adversary. We con-
struct from it the adversaries ACFG←CBG against CFG and AVCBG←CBG
against VCBG. The adversary ACFG←CBG is detailed in Alg. 8. It re-
ceives a challenge 𝑠 and runs LVC.Setup(1𝜆) and Sig.KeyGen(1𝜆)
to produce the remaining public parameters pp and the secret
parameters (sp1, ..., sp𝑛) for ACBG. After ACBG outputs a pair
(𝐵, 𝐵′), ACFG←CBG computes 𝑼 ← AsMatrix𝐿×𝑘 (𝐵) and 𝑼 ′ ←
AsMatrix𝐿×𝑘 (𝐵). Next, it computes (ℎ1, ..., ℎ𝑘 ) ← VC⊗𝑘 (𝑼 ) and
𝑘 ) ← VC⊗𝑘 (𝑼 ′) to check whether ℎ1 ∥...∥ℎ𝑘 and ℎ′
(ℎ′
1 ∥...∥ℎ′
𝑘
1
are a collision of CRHF𝑠 . If so, it outputs (ℎ1 ∥...∥ℎ𝑘, ℎ′
1 ∥...∥ℎ′
𝑘 ); else
it aborts.

, ..., ℎ′

The adversary AVCBG←CBG is detailed in Alg. 9. It receives
the challenge ppLVC and runs HF.Gen(1𝜆) and Sig.KeyGen(1𝜆)
to produce the remaining public parameters pp and the secret

8

Information Dispersal with Provable Retrievability for Rollups

parameters (sp1, ..., sp𝑛) for ACBG. After ACBG outputs a pair
(𝐵, 𝐵′), AVCBG←CBG computes 𝑼 ← AsMatrix𝐿×𝑘 (𝐵) and 𝑼 ′ ←
AsMatrix𝐿×𝑘 (𝐵′). Next, it checks if there exists 𝑖 ∈ [𝑘] such that
the column [𝑼 ]𝑖 ≠ [𝑼 ′]𝑖 but VC([𝑼 ]𝑖 ) = VC([𝑼 ′]𝑖 ). If so, it out-
puts the collision ([𝑼 ]𝑖, [𝑼 ′]𝑖 ); else it aborts.

The adversaries ACFG←CBG and AVCBG←CBG run in polyno-
mial time. The input of the adversary ACBG when run as a subrou-
tine of ACFG←CBG or AVCBG←CBG is distributed identically to
the input of the adversary ACBG when run in CBG.

For the subsequent arguments we define the following events:

(𝜆) = true}

𝐸CB ≜ {CBGΠ⋆,ACBG
𝐸CF ≜ {CFGHF,ACFG←CBG (𝜆) = true}
𝐸VCB ≜ {VCBGLVC,AVCBG←CBG (𝜆) = true}
𝐸 ≜ {VC⊗𝑘 (𝑼 ) ≠ VC⊗𝑘 (𝑼 ′) ∧ 𝑼 ≠ 𝑼 ′}
𝑈 ≜ 𝐸CF ∨ 𝐸VCB

(15)

(16)

(17)

(18)

(19)

, ..., ℎ′

Suppose 𝐸CB holds and ACBG outputs (𝐵, 𝐵′) such that Commit(𝐵) =
Commit(𝐵′) but 𝐵 ≠ 𝐵′. Hence, CRHF𝑠 (ℎ1 ∥...∥ℎ𝑘 ) = CRHF𝑠 (ℎ′
1 ∥...∥ℎ′
𝑘 ),
where 𝑼 ← AsMatrix𝐿×𝑘 (𝐵), 𝑼 ′ ← AsMatrix𝐿×𝑘 (𝐵′), (ℎ1, ..., ℎ𝑘 ) ←
VC⊗𝑘 (𝑼 ) and (ℎ′
𝑘 ) ← VC⊗𝑘 (𝑼 ′). We consider two cases. If
1
𝐸 holds, then (ℎ1, ..., ℎ𝑘 ) ≠ (ℎ1, ..., ℎ𝑘 ). Thus, in the event of 𝐸,
𝑘 ) is a collision of CRHF𝑠 , so the event 𝐸CF
(ℎ1 ∥...∥ℎ𝑘, ℎ′
holds. In the case of ¬𝐸, (ℎ1, ..., ℎ𝑘 ) = (ℎ′
𝑘 ). Thus, there ex-
1
ists 𝑖 ∈ [𝑘] such that [𝑼 ]𝑖 ≠ [𝑼 ′]𝑖 but VC([𝑼 ]𝑖 ) = VC([𝑼 ′]𝑖 ). So
under ¬𝐸, the event 𝐸VCB holds.

1 ∥...∥ℎ′

, ..., ℎ′

Observe that if 𝐸 holds, then 𝐸CF holds. Hence, 𝐸 ⊆ 𝐸CF
and Pr( ¬𝐸CF ∧ 𝐸 ) = 0. Similarly, if ¬𝐸 holds, then 𝐸VCB holds.
Hence, ¬𝐸 ⊆ 𝐸VCB and Pr( ¬𝐸VCB ∧ ¬𝐸 ) = 0.
We can now bound the probability of 𝐸CB:

Pr( 𝐸CB )

(a)
= Pr( 𝐸CB | 𝑈 ) Pr( 𝑈 ) + Pr( 𝐸CB | ¬𝑈 ) Pr( ¬𝑈 )
(b)
≤ Pr( 𝑈 ) + Pr( 𝐸CB ∧ ¬𝑈 )
(c)
≤ Pr( 𝑈 ) + Pr( 𝐸CB ∧ ¬𝑈 ∧ 𝐸 ) + Pr( 𝐸CB ∧ ¬𝑈 ∧ ¬𝐸 )
(d)
≤ Pr( 𝑈 ) + Pr( ¬𝐸CF ∧ 𝐸 ) + Pr( ¬𝐸VCB ∧ ¬𝐸 )
(e)
≤ Pr( 𝑈 )
(f)
≤ Pr( 𝐸CF ) + Pr( 𝐸VCB )

(20)

(21)

(22)

(23)

(24)

(25)

where (a) uses the law of total probability (TP) to introduce 𝑈 ; (b)
uses Pr( 𝐸CB | 𝑈 ) ≤ 1; (c) uses TP to introduce 𝐸; (d) uses
Pr( 𝐸CB ∧ ¬𝐸CF ∧ ¬𝐸VCB ∧ 𝐸 ) ≤ Pr( ¬𝐸CF ∧ 𝐸 )

(26)

and

Pr( 𝐸CB ∧ ¬𝐸CF ∧ ¬𝐸VCB ∧ ¬𝐸 ) ≤ Pr( ¬𝐸VCB ∧ ¬𝐸 ) ;(27)
(e) uses Pr( ¬𝐸CF ∧ 𝐸 ) = 0 and Pr( ¬𝐸VCB ∧ ¬𝐸 ) = 0; (f) uses a
union bound.

Since by assumption HF is collision resistant and LVC is binding,
there exist negl1 (.), negl2 (.) such that Pr( 𝐸CF ) ≤ negl1 (𝜆) and
Pr( 𝐸VCB ) ≤ negl2 (𝜆). Thus,

Algorithm 10 AEFG←AvG′ (pk) constructed from AAvG′

←− [𝑛]

⊲ Choose random party 𝐼 to emulate using Osign (.)
⊲ Bookkeeping of corrupted parties C
⊲ Blank state for each party 𝑃𝑖
(cf. Alg. 3) ...

1: 𝐼 R
2: C ← ∅
3: ∀𝑖 ∈ [𝑛] : 𝑆𝑖 ← ∅
4: ppLVC ← LVC.Setup(1𝜆)
5: ppHF ← HF.Gen(1𝜆)
6: ∀𝑖 ∈ [𝑛] \ {𝐼 } : (pk𝑖, sk𝑖 ) ← Sig.KeyGen(1𝜆)
7: pk𝐼 ← pk
8: pp ← (ppLVC, ppHF, pk1, ..., pk𝑛)
9: function Ocorrupt(𝑖)
assert 𝑖 ∉ C
10:
if 𝑖 ≠ 𝐼

⊲ ... except use pk for party 𝐼 ’s pk𝐼

⊲ Setup Π⋆

11:

12:

13:

14:

C ← C ∪ {𝑖}
return (sk𝑖, 𝑆𝑖 )

else

⊲ Cannot hand over 𝑃𝐼 since sk𝐼 is unknown

15:
abort
16: function Ointeract(𝑖, 𝑚)
assert 𝑖 ∉ C
17:
if 𝑖 ≠ 𝐼

18:

19:

20:

21:

sk𝑖, 𝑆𝑖 , and return output to A

else

return Π⋆,sk𝑖,𝑆𝑖 (𝑚) ⊲ Execute 𝑃𝑖 on input 𝑚 and state

return Π⋆,𝑆𝑖 [Osign (.)/Sig.Sign(sk𝑖, .)] (𝑚) ⊲ Execute
𝑃𝐼 on input 𝑚 and state 𝑆𝑖 , substituting Osign (.) for invocations
of Sig.Sign(sk𝑖, .), and return output to A
(cid:17)
(cid:16)
𝑃, 𝐶,

Onode
𝑖

22:
23: ^𝐵 ← Retrieve𝑃1,...,𝑃𝑛 (cid:2)Onode

𝑖 ∈ C

← A Ocorrupt (.),Ointeract (.)
AvG′
(.)/Query(𝑖, .)(cid:3)

⊲
During retrieval, interact with corrupted nodes through oracles

(pp)
𝑖 ∈ C (𝑃, 𝐶)

(.)

(cid:16)

(cid:17)

𝑖

24: if ∃𝜎 : (𝐼 ↦→ 𝜎) ∈ 𝑃 ∧ 𝑆𝐼 [𝐶] = ∅
return ((ack, 𝐶), 𝜎)
25:
26: else
27:

abort

⊲ Forgery for pk𝐼 = pk

⊲ No forgery for pk𝐼 = pk identified

Lemma 5.3. If HF is collision resistant, Sig is secure against exis-
tential forgery, and 𝑡 < 𝑛/2, then Π⋆
provides availability, i.e., for
all PPT adversaries AAvG there exists a negligible function negl(.)
such that

(cid:16)

Pr

AvGΠ⋆,AAvG

(𝜆, 𝑡) = true

≤ negl(𝜆).

(29)

Proof. First, we modify the availability game AvG (Alg. 2) to
obtain AvG′ (Alg. 15) in which initially the index 𝐼 of a storage
node is sampled uniformly at random, and subsequently the game
is aborted if the adversary AAvG′ attempts to corrupt 𝐼 . This modi-
fication will subsequently streamline the reduction of availability
of Π⋆ to security of Sig against existential forgery.

We reduce availability of Π⋆ to availability′ of Π⋆, i.e., if for all

PPT AAvG′ there exists negl(.) such that
(𝜆, 𝑡) = true

AvG′

Pr

(cid:16)

Π⋆,AAvG′

then for all PPT AAvG there exists negl(.) such that

(cid:17)

≤ negl(𝜆),

(30)

(cid:16)

AvGΠ⋆,AAvG

(𝜆, 𝑡) = true

≤ negl(𝜆).

(31)

(cid:17)

(cid:17)

Pr( 𝐸CB ) ≤ negl1 (𝜆) + negl2 (𝜆) ≤ negl(𝜆).

Hence, Π⋆ is commitment-binding.

Pr

(28)

□

9

Algorithm 11 ACFG←AvG′ (𝑠) constructed from AAvG′

⊲ Bookkeeping of corrupted parties C and

⊲ Blank state for each party 𝑃𝑖
(cf. Alg. 3) ...

⊲ Setup Π⋆

⊲ ... except use 𝑠 for ppHF

1: 𝐼 R
←− [𝑛]
2: C, H ← ∅, ∅

image/preimage pairs H for HF.H

3: ∀𝑖 ∈ [𝑛] : 𝑆𝑖 ← ∅
4: ppLVC ← LVC.Setup(1𝜆)
5: ∀𝑖 ∈ [𝑛] : (pk𝑖, sk𝑖 ) ← Sig.KeyGen(1𝜆)
6: ppHF ← 𝑠
7: pp ← (ppLVC, ppHF, pk1, ..., pk𝑛)
8: function Ocorrupt(𝑖)
assert 𝑖 ∉ C
9:
if 𝑖 ≠ 𝐼

10:

11:

12:

13:

C ← C ∪ {𝑖}
return (sk𝑖, 𝑆𝑖 )

else

14:
abort
15: function Ointeract(𝑖, 𝑚)
assert 𝑖 ∉ C
16:
if 𝑚 parses as (store, (ℎ1, ..., ℎ𝑘 ), 𝒄)

17:

Record image/preimage pair for HF.H

(cid:16)

(cid:17)

19:

20:

return Π⋆,sk𝑖,𝑆𝑖 (𝑚)
sk𝑖, 𝑆𝑖 , and return output to A
(cid:16)
(.)
𝑃, 𝐶,
21: function ˜Onode
𝑟 ← Onode
22:
𝑖
if 𝑟 parses as (𝑖, (ℎ1, ..., ℎ𝑘 ), 𝒄𝑖 )

𝑖 ∈ C
(𝑚)
(𝑚)

Onode
𝑖

AvG′

23:

(cid:17)

𝑖

18:

H ← H ∪ {(CRHF𝑠 (ℎ1 ∥...∥ℎ𝑘 ) ↦→ ℎ1 ∥...∥ℎ𝑘 )}

⊲

⊲ Execute 𝑃𝑖 on input 𝑚 and state

← A Ocorrupt (.),Ointeract (.)

(pp)

H ← H ∪ {(CRHF𝑠 (ℎ1 ∥...∥ℎ𝑘 ) ↦→ ℎ1 ∥...∥ℎ𝑘 )}

⊲

Record image/preimage pair for HF.H

24:

25:

return 𝑟

26: Retrieve𝑃1,...,𝑃𝑛 (cid:104) ˜Onode

⊲ During
retrieval, interact with corrupted nodes through wrapped oracles

(.)/Query(𝑖, .)

(𝑃, 𝐶)

𝑖 ∈ C

(cid:105)

𝑖

return (𝑥, 𝑥 ′)

27: if ∃𝑥, 𝑥 ′ : (𝐶 ↦→ 𝑥) ∈ H ∧ (𝐶 ↦→ 𝑥 ′) ∈ H ∧ 𝑥 ≠ 𝑥 ′
28:
29: else
30:

abort

⊲ No collision identified

⊲ Collision in HF.H

To this end, pick any AvG adversary AAvG. Note that AAvG′ ≜
AAvG is an AvG′ adversary. Define the events:

𝐸A ≜ {AvGΠ⋆,AAvG
𝐸A′ ≜ {AvG′
Π⋆,AAvG′
Obviously, 𝐸A ∧ {𝐼 ∉ C} ⊆ 𝐸A′. Furthermore, 𝐸A implies |C| ≤
𝑡 < 𝑛/2, so that Pr( 𝐼 ∉ C | 𝐸A ) ≥ 1/2. Thus, by availability′ of
Π⋆,

(𝜆, 𝑡) = true}
(𝜆, 𝑡) = true}

(33)

(32)

Pr( 𝐸A′ ) ≥ Pr( 𝐸A ∧ {𝐼 ∉ C} )

≥ Pr( {𝐼 ∉ C} | 𝐸A ) Pr( 𝐸A ) ≥

(34)

(35)

Pr( 𝐸A )

1
2

Pr( 𝐸A ) ≤ 2 Pr( 𝐸A′ ) ≤ negl(𝜆).

(36)
We proceed with the reduction of availability′ of Π⋆ to collision
resistance of HF and security of Sig against existential forgery. Let
AAvG′ be an arbitrary PPT AvG′ adversary. We construct from
it the adversaries AEFG←AvG′ for the EFG and ACFG←AvG′ for

10

Kamilla Nazirkhanova, Joachim Neu, and David Tse

the CFG as detailed in Algs. 10 and 11, respectively. AEFG←AvG′
emulates the AvG′ challenger (Alg. 15), except it does not generate a
signature public/secret key pair for node 𝐼 , but instead uses the input
challenge pk, and it attempts to forge a signature for 𝐼 . It uses the
signature oracle Osign (.) provided in the EFG to produce signatures
for node 𝐼 whenever Π⋆ requires to do so. ACFG←AvG′ emulates
the AvG′ challenger (Alg. 15), except it uses the input challenge
𝑠 for HF’s key in the public parameters of Π⋆. Throughout the
protocol execution, for both dispersal and retrieval operations, the
reduction adversary keeps track of any (ℎ1, ..., ℎ𝑘 ) that may present
colliding inputs for CRHF𝑠 . Clearly, the adversaries AEFG←AvG′
and ACFG←AvG′ run in time polynomial in the security parameter
𝜆. Furthermore, the input pp of AAvG′ and its interactions through
the oracles Ocorrupt (.) and Ointeract (.) are distributed identically
when run by the challenger of AvG′ and when run as a subroutine
of AEFG←AvG′ or ACFG←AvG′ invoked by the challenger of EFG
or CFG, respectively.

(37)

(38)

For the subsequent arguments we define the following events:
𝐸E ≜ {EFGSig,AEFG←AvG′ (𝜆) = true}
𝐸C ≜ {CFGHF,ACFG←AvG′ (𝜆) = true}
𝐸 ≜ {(∃𝜎 : (𝐼 ↦→ 𝜎) ∈ 𝑃) ∧ 𝑆𝐼 [𝐶] = ∅}
(39)
The following facts will be useful. Observe that if 𝐸 ∧ 𝐸A′ holds,
then AEFG←AvG′ wins the EFG, i.e., 𝐸E holds. So 𝐸 ∧ 𝐸A′ ⊆
𝐸E. Thus, Pr( 𝐸A′ ∧ ¬𝐸C ∧ ¬𝐸E ∧ 𝐸 ) = 0. Inverting the impli-
cation, ¬𝐸E ⊆ ¬𝐸 ∨ ¬𝐸A′. Thus, Pr( 𝐸A′ ∧ ¬𝐸C ∧ ¬𝐸E ∧ ¬𝐸 ) ≤
Pr( 𝐸A′ ∧ ¬𝐸C ∧ ¬𝐸 ), where we have used a union bound and
𝐸A′ ∧ ¬𝐸A′ = ∅.

Finally, suppose AAvG′ as a subroutine of AEFG←AvG′ behaves
such that it would win the corresponding AvG′. Furthermore, sup-
pose no collision is identified by ACFG←AvG′, so ¬𝐸C. Then, given
that |C| ≤ 𝑡 < 𝑞, Verify(𝑃, 𝐶) = true, the only way in which
Commit( ^𝐵) ≠ C could be true is if there is at least one node that
is part of 𝑃, has not been corrupted, and has not previously stored
a chunk associated with 𝐶. This is because, as was argued earlier
in the proof sketch, if the retrieving client receives chunks from
at least 𝑘 honest storage nodes, it decodes a block that matches
the expected commitment 𝐶. Hence, it must be the case that the
client does not receive sufficiently many valid chunks. But since 𝑃
contains 𝑞 > 𝑡 valid signatures, but at most 𝑡 ≥ |C| storage nodes
are corrupted, and 𝑘 ≤ (𝑞 − 𝑡) by design, there must be an honest
storage node whose signature on (ack, 𝐶) is in 𝑃, yet the node does
not respond to the retrieving client’s query because it has never
stored a chunk associated with 𝐶 (and hence not signed (ack, 𝐶)).
Thus, Pr( 𝐸 | 𝐸A′ ∧ ¬𝐸C ) ≥ 1
𝑛 .

Now we can bound, with 𝑥 ≜ Pr( 𝐸C ) + Pr( 𝐸E ),
Pr( 𝐸A′ )

(40)

(a)
= Pr( 𝐸A′ ∧ 𝐸C ) + Pr( 𝐸A′ ∧ ¬𝐸C )
(b)
≤ Pr( 𝐸C ) + Pr( 𝐸E ) + Pr( 𝐸A′ ∧ ¬𝐸C ∧ ¬𝐸E ) (41)
(c)
≤ 𝑥 + Pr( 𝐸A′ ∧ ¬𝐸C ∧ ¬𝐸E ∧ ¬𝐸 )
(d)
≤ 𝑥 + Pr( 𝐸A′ ∧ ¬𝐸C ∧ ¬𝐸 )
= 𝑥 + Pr( ¬𝐸 | 𝐸A′ ∧ ¬𝐸C ) Pr( 𝐸A′ ∧ ¬𝐸C )
(e)
≤ 𝑥 +

(43)

(42)

(44)

(45)

Pr( 𝐸A′ )

𝑛 − 1
𝑛

Information Dispersal with Provable Retrievability for Rollups

Pr( 𝐸A′ ) ≤ 𝑛𝑥 = 𝑛 Pr( 𝐸C ) + 𝑛 Pr( 𝐸E )

(46)
where (a) uses the law of total probability (TP) to introduce 𝐸C;
(b) uses TP to introduce 𝐸E, 𝐸A′ ∧ 𝐸C ⊆ 𝐸C, 𝐸A′ ∧ ¬𝐸C ∧ 𝐸E ⊆
𝐸E; (c) uses TP to introduce 𝐸, Pr( 𝐸A′ ∧ ¬𝐸C ∧ ¬𝐸E ∧ 𝐸 ) = 0;
(d) uses Pr( 𝐸A′ ∧ ¬𝐸C ∧ ¬𝐸E ∧ ¬𝐸 ) ≤ Pr( 𝐸A′ ∧ ¬𝐸C ∧ ¬𝐸 ); (e)
uses 𝐸A′ ∧ ¬𝐸C ⊆ 𝐸A′, Pr( 𝐸 | 𝐸A′ ∧ ¬𝐸C ) ≥ 1
𝑛 .

Since by assumption HF is collision resistant and Sig is secure
against existential forgery, there exist negl1 (.), negl2 (.) such that
Pr( 𝐸C ) ≤ negl1 (𝜆) and Pr( 𝐸E ) ≤ negl2 (𝜆). Furthermore, 𝑛 is a
constant independent of the security parameter 𝜆. Thus,
(47)
Pr( 𝐸A′ ) ≤ 𝑛 negl1 (𝜆) + 𝑛 negl2 (𝜆) ≤ negl(𝜆).
Hence, Π⋆ provides availability′, to which availability of Π⋆ was
□
reduced in the first part of the proof.

6 PRIVACY
Our Semi-AVID-PR scheme Π⋆ can be extended to hide the dis-
persed data from non-colluding honest-but-curious storage nodes,
i.e., formally, for each storage node, the distribution of the dispersed
information is independent of the data received by the storage node.
For this purpose, with a slight abuse of notation, let ˜𝑼 denote the
(𝐿 −1) × (𝑘 −1) matrix of information to be dispersed (with columns
˜𝒖𝑖 ). The dispersing client augments it first with a blinding column
R
←− Z𝑘
𝒃
𝑝
to the bottom of both ˜𝑼 and 𝒃, to obtain the 𝐿 × 𝑘 matrix 𝑼 ,

to the right of ˜𝑼 and then with a blinding row 𝒔

R
←− Z𝐿−1
𝑝

𝑼 ≜

(cid:21)

(cid:20) ˜𝑼
𝒃
− 𝒔⊤−

.

(48)

The coded matrix 𝑪 (with columns 𝒄𝑖 ) and the column commitments
(ℎ1, ..., ℎ𝑘 ) continue to be computed as detailed in Figure 5 and
Section 4. Thus, storage node 𝑚 receives (𝒄𝑚, ℎ1, ..., ℎ𝑘 ) as part of
the protocol (see Alg. 6).

Theorem 6.1. The distribution of (𝒄𝑚, ℎ1, ..., ℎ𝑘 ) induced by the
randomness in the blinding 𝒃 and 𝒔 is independent of ˜𝑼 , so that storage
node 𝑚 learns nothing about the dispersed information.

Proof. Assume that storage node 𝑚 could even compute log𝑔 (.)
in G, and hence knows the secret 𝑟 sampled during trusted setup of
the KZG polynomial commitment scheme (see Section 2.3), as well
as log𝑔 (ℎ𝑖 ) for the column commitments ℎ𝑖 . Furthermore, assume
a Reed-Solomon code (see Section 2.2) is used as part of Π⋆ so that
the column 𝒈RS,𝑚 = (𝛼 0
𝑚 ) corresponds to storage node
𝑚 in the code’s generator matrix 𝑮RS. Then, the data obtained by
node 𝑚 is related to the unknowns by the following equations:

𝑚, ..., 𝛼𝑘−1

[𝒄𝑚 ]1...




[𝒄𝑚 ]𝐿−1



[𝒄𝑚 ]𝐿



log𝑔 (ℎ1 )

...



log𝑔 (ℎ𝑘−1 )



log𝑔 (ℎ𝑘 )























=

𝛼 0𝑚 ... 𝛼𝑘−2𝑚





















(cid:124)

𝑟 0 0
...
... 0 𝑟 0

...

Denote by [𝑴]⊤
𝑖
𝐿
∑︁

[𝑴]⊤

𝐿+𝑘 =

𝑖=1

...

...

...

𝛼𝑘−1𝑚 0
...
0 𝛼𝑘−1𝑚

...

𝛼 0𝑚 ... 𝛼𝑘−2𝑚

...

𝑟 𝐿−2 0
...
0 𝑟 𝐿−2

...

𝛼 0𝑚 ... 𝛼𝑘−2𝑚 𝛼𝑘−1𝑚
𝑟 𝐿−1 0
...
...
0 𝑟 𝐿−1

...

(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)

𝑟 0 ... 𝑟 𝐿−2

𝑟 𝐿−1
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)

(cid:123)(cid:122)
≜𝑴 ∈Z(𝐿+𝑘 )×(𝐿𝑘+(𝐿−1)+(𝑘−1)+1)
the 𝑖-th row of 𝑴. Observe that

𝑝

[˜𝒖1 ]1
...
[˜𝒖𝑘−1 ]1
...
[˜𝒖1 ]𝐿−1
...

[˜𝒖𝑘−1 ]𝐿−1

𝒃

𝒔


































































(cid:125)

𝑟𝑖−1𝛼 −(𝑘−1)
𝑚

[𝑴]⊤

𝑖 −

𝑘−1
∑︁

𝑖=1

𝛼 −(𝑘−𝑖)
𝑚

[𝑴]⊤

𝐿+𝑖 .

(50)

11

Thus, the last equation of the system is redundant. Striking it,

[𝒄𝑚 ]1...
[𝒄𝑚 ]𝐿−1
[𝒄𝑚 ]𝐿
log𝑔 (ℎ1 )
...

log𝑔 (ℎ𝑘−1 )























=

+

. . .

𝛼 0𝑚 . . . 𝛼𝑘−2𝑚







𝑟 0 0

...


. . . 0 𝑟 0

𝛼𝑘−1𝑚 0


...



0 𝛼𝑘−1𝑚













(cid:124)

. . .

. . .

...

...

𝛼 0𝑚 . . . 𝛼𝑘−2𝑚

. . .

𝑟 𝐿−2 0
...
0 𝑟 𝐿−2

. . .























[˜𝒖1 ]1...
[˜𝒖𝑘−1 ]1
...
[˜𝒖1 ]𝐿−1
...

[˜𝒖𝑘−1 ]𝐿−1











𝛼 0𝑚 . . . 𝛼𝑘−2𝑚 𝛼𝑘−1𝑚
𝑟 𝐿−1 0
. . .
...
0 𝑟 𝐿−1

. . .

[𝒃 ]1...
[𝒃 ]𝐿−1
[𝒔 ]1...
[𝒔 ]𝑘−1
[𝒔 ]𝑘



































.

(51)



















(cid:125)

(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)

(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)

𝑝

(cid:123)(cid:122)
≜𝑴′∈Z(𝐿+𝑘−1)×(𝐿−1+𝑘 )
Observe that 𝑴 ′ is full-rank. Thus, the randomness of 𝒃 and 𝒔
renders the distribution of (𝒄𝑚, ℎ1, ..., ℎ𝑘−1) uniform, while ℎ𝑘 is
a function of (𝒄𝑚, ℎ1, ..., ℎ𝑘−1), all independent of the dispersed
information ˜𝑼 . Thus, as desired,

Pr(cid:0) ˜𝑼 = 𝒚 (cid:12)

(cid:12) (𝒄𝑚, ℎ1, ..., ℎ𝑘 ) = 𝒙 (cid:1) = Pr(cid:0) ˜𝑼 = 𝒚 (cid:1) .

(52)

□

7 EVALUATION
In this section, we show that the computational cost required for
our Semi-AVID-PR scheme Π⋆ is low, and the communication and
storage requirements in comparison with AVID [9], AVID-FP [16],
AVID-M [32] and ACeD [29] are among the best-of-class (tied with
AVID-M) and practically low, while providing superior resilience
(up to 𝑡 < 𝑛/2 vs. 𝑡 < 𝑛/3) and provable retrievability.

7.1 Computation
To evaluate the computational requirements imposed by compu-
tation and verification of vector commitments and encoding and
decoding of the erasure-correcting code during Disperse (i.e., com-
putational burden to the Validium rollup operator) and Retrieve (i.e.,
computational burden to the Validium rollup user, in case of mali-
cious operator) of our Semi-AVID-PR scheme Π⋆, we implemented
a prototype in the Rust programming language using libraries from
arkworks [2]. We make the source code available on Github.2 We
used KZG commitments [18] on the BLS12-381 curve [4, 6] as vector
commitments, and Reed-Solomon codes [28] over the underlying
scalar prime field. Reed-Solomon (RS) encoding was implemented
using the fast Fourier transform (FFT). The consistency check of
chunks performed by storage nodes in Alg. 6 line 8 was imple-
mented naively, by computing a vector commitment of the received
chunk and comparing it with the corresponding ‘encoded’ combi-
nation (computed using 𝑘 exponentiations and multiplications in
(49)
the group) of the column commitments ℎ1, ..., ℎ𝑘 . Note that during
dispersal, these consistency checks are naturally parallelized across
storage nodes, but have to be computed independently.

For retrieval, on the other hand, the computation of the coded
chunks’ commitments (Alg. 6 line 9) was sped up using the FFT. RS
decoding was naive (generic for any MDS code): After downloading
𝑘 valid chunks from distinct storage nodes, the retrieving client first

2Source code: https://github.com/tse-group/semiavidpr-experiments

(a) (𝑛, 𝑘) = (128, 32)

(b) (𝑛, 𝑘) = (256, 64)

(c) (𝑛, 𝑘) = (1024, 256)

100

10

1

0.1

100

10

1

0.1

100

10

1

4

8

16

32

4

8

16

32

4

8

16

32

(d) (𝑛, 𝑘) = (128, 43)

(e) (𝑛, 𝑘) = (256, 85)

(f) (𝑛, 𝑘) = (1024, 341)

100

10

1

0.1

100

10

1

100

10

1

8

16

32

8

16

32

8

16

32

(g) (𝑛, 𝑘) = (128, 58)

(h) (𝑛, 𝑘) = (256, 115)

(i) (𝑛, 𝑘) = (1024, 461)

100

10

1

0.1

100

10

1

100

10

1

8

16

32

64

8

16

32

64

8

16

32

64

Figure 6: Single-thread runtime (ordinate, in seconds) of dif-
ferent steps of Π⋆ on AMD Opteron 6378 processor for vary-
ing file sizes (abscissa, in 106 bytes; for varying 𝐿) in BLS12-
381 curve. Rows: code rates 𝑘/𝑛 ≈ 0.25, 0.33, 0.45 (
,
). Columns: system sizes 𝑛 = 128, 256, 1024 ( ,
). Steps
of Π⋆: Disperse: Reed-Solomon (RS) encoding ( ), comput-
ing vector commitments ( ). Retrieve: Verifying downloaded
chunks ( ), RS decoding 𝑘 × 𝑘 matrix inversion ( ), RS decod-
ing matrix-matrix product ( ). (Aggregated: Figure 9. Note
in some plots.)
that

lies on top of

,

,

]
s
[

e
m

i
t
n
u
R

100

10

1

0.1

32

64

128
256
System size 𝑛

512

1024

Figure 7: Single-thread runtime of steps of Π⋆ on AMD
Opteron 6378 processor for varying system size 𝑛 in BLS12-
381 curve. Fixed code rate 𝑘/𝑛 ≈ 0.33, and file size ≈ 22 MB.
Disperse: RS encoding ( ), computing vector commitments
( ). Retrieve: Verifying downloaded chunks ( ), RS decoding
𝑘 × 𝑘 matrix inversion ( ), RS decoding matrix-matrix prod-
uct ( ). (cf. Figure 6)

inverts the corresponding 𝑘 × 𝑘 sub-matrix of the code’s generator

12

Kamilla Nazirkhanova, Joachim Neu, and David Tse

Table 1: Communication and storage required to disperse
22 MB among 𝑛 = 1024 nodes using different solutions; re-
silience and whether provable retrievability is supported.
(Calculations: Appendix A.)

Scheme

Resilience

Communication

Storage

Retrievability

Repetition
AVID [9]
AVID-FP [16]
AVID-M [32]
ACeD [29]
ACeD [29]
This work (Π⋆)
This work (Π⋆)

502 = 0.49𝑛
338 = 0.33𝑛
338 = 0.33𝑛
338 = 0.33𝑛
338 = 0.33𝑛
502 = 0.49𝑛
338 = 0.33𝑛
502 = 0.49𝑛

22.5 GB 22.5 GB
101 GB 98.3 MB
46.1 GB
110 MB
98.7 MB 65.1 MB
585 MB
585 MB
10.2 GB 10.2 GB
81.8 MB 81.8 MB
1.13 GB 1.13 GB

✔
✔
✔
✘
✘
✘
✔
✔

matrix 𝑮, and then obtains the matrix 𝑼 of uncoded chunks from the
downloaded sub-matrix of the coded chunks 𝑪 by way of a matrix-
matrix product with the inverse. This way, the cubic complexity (in
𝑘) of naive matrix inversion via Gaussian elimination is amortized
over the decoding of 𝐿 rows (each with quadratic complexity in 𝑘;
in the regime of interest 𝑘 ≤ 𝐿). Note that this naive approach to RS
decoding is permissible as our experiments indicate that Retrieve’s
runtime is bottlenecked by another step (verifying downloaded
chunks), and during normal operation (when the rollup operator is
honest) only Disperse is invoked. Note that a systematic erasure-
correcting code can be used to further speed up decoding in the
realistic scenario where few storage nodes are corrupted (as long
as the privacy techniques of Section 6 are not used).

Figure 6 shows the single-thread runtime (ordinate) on an AMD
Opteron 6378 processor of the different steps of Π⋆ for varying file
sizes (abscissa), system sizes (columns), and code rates (rows). Fig-
ure 9 shows the measurements aggregated on the level of Disperse
and Retrieve, respectively. The plots reveal a minor slowdown of
Disperse with increasing system size and code rate. The runtime of
Disperse is dominated by computing the vector commitments. The
runtime of Retrieve is dominated by verifying downloaded chunks.
Recall that both bottlenecking steps have been optimized using the
FFT. Naive RS decoding does not introduce a performance bottle-
neck, but becomes relevant for large systems (𝑛 = 1024). Fixing file
size to ≈ 22 MB and code rate to 𝑘/𝑛 ≈ 0.33 while varying system
size 𝑛 (cf. Figure 7), corroborates the earlier observations.

Concretely, the client computation for dispersing a file of 22 MB
among 256 storage nodes, up to 85 of which may be adversar-
ial, requires ≈ 41 s of single-thread runtime on an AMD Opteron
6378 processor when using the BLS12-381 curve. The correspond-
ing retrieval takes ≈ 44 s of single-thread runtime. The dispersal
throughput of ≈ 0.54 MB/s corresponds to ≈ 2,700 tx/s (assuming
200 B transaction size). It should be noted that we report single-
thread runtime on a seven year old processor here. The workload is
embarrassingly parallel and hence wall-clock time reduces trivially
with an increasing number of parallel workers. With 16 threads,
the Validium operator can complete dispersal and Validium users
can complete retrieval in less than 3 s, respectively.

7.2 Communication & Storage
Communication and storage required for different data availability
solutions are tabulated for a numerical example in Table 1. The

Information Dispersal with Provable Retrievability for Rollups

calculations are provided in Appendix A, and in the source code
available on Github.3 Note the 𝑡 < 𝑛/2 resilience upper bound for
any scheme that simultaneously provides availability and correct-
ness (cf. Definition 3.2). To see this, suppose the cooperation of 𝑞
storage nodes is necessary and sufficient to complete a dispersal.
Correctness requires 𝑞 ≤ 𝑛 − 𝑡 (else adversarial storage nodes can
‘block’ dispersal), and availability requires 𝑞 > 𝑡 (else adversarial
storage nodes can ‘forge’ a dispersal). Combining the two condi-
tions yields 𝑡 < 𝑛/2, which is achieved by the naive repetition
(full replication) scheme, at high communication and storage cost.
Our Π⋆ recovers the same trade-off when parameterized for re-
silience close to 𝑛/2; but our scheme can also be parameterized
for lower resilience, in which case it achieves considerably lower
communication and storage, whereas the repetition scheme does
not allow for such parameterization. AVID improves over repetition
in that each node only needs to store a chunk rather than the full
file. However, nodes still echo chunks to each other, leading to a
lot of communication. AVID-FP improves in communication be-
cause storage nodes only echo fingerprints rather than full chunks.
AVID-M improves over AVID-FP in that it drastically reduces the
fingerprint size and hence the communication. ACeD allows for a
trade-off of communication and storage with adversarial resilience.
In terms of communication and storage, our Semi-AVID-PR
scheme Π⋆ (Sec. 4) is among the best-of-class (tied with AVID-
M), while providing superior resilience (𝑡 < 𝑛/2 vs. 𝑡 < 𝑛/3) and
provable retrievability (the lack thereof limits application of AVID-
M to Validium rollups). Our Semi-AVID-PR scheme outperforms
ACeD in communication and storage by at least 7×. The net data
throughput of ≈ 0.54 MB/s for (𝑛, 𝑘) = (256, 85) corresponding
to ≈ 2,700 tx/s (cf. Section 7.1) entails ≈ 1.7 MB/s communication
bandwidth usage (≈ 70 MB in ≈ 41 s), which is feasible even via
consumer-grade Internet connectivity. Finally, it should be noted
that the VID-based schemes in Table 1 have resilience 𝑡 at most
𝑡 < 𝑛/3. In that regime, Π⋆ matches or exceeds the communication-
and storage-efficiency of VID-based schemes. However, like ACeD,
Π⋆ also supports higher resilience up to 𝑡 < 𝑛/2. In this regime,
the overhead from erasure coding increases, as for ACeD, but still
outperforms ACeD.

8 APPLICATION TO DATA AVAILABILITY

SAMPLING

In common blockchain designs every block consists of a meta data
header and transaction content. Full nodes download the full chain
and validate all transactions. However, a resource-limited node can
instead participate as a light node.4 Then, it only processes block
headers. If a block contained an invalid transaction, it would be
rejected by full nodes but its header would be accepted by a light
node unable to inspect the block content and verify transaction va-
lidity. To prevent this, full nodes can produce an invalid transaction
fraud proof [1]. To take full nodes’ ability to issue such fraud proofs,
a malicious block producer can withhold parts of the block content.
Full nodes would then reject the block until its content is fully
available, but light nodes would not notice the missing content. The

3Source code: https://github.com/tse-group/semiavidpr-experiments
4Light nodes also occur in the context of sharding, where each node is assigned to a
shard and behaves in-shard as a full node and out-of-shard as a light node.

13

absence of an invalid transaction fraud proof can thus mean two
things: either the block is valid, or full nodes are unable to verify
the block due to missing data. To rule out the second possibility,
data availability sampling schemes for light nodes were introduced.
Data availability schemes using Reed-Solomon codes were pro-
posed in [1], where the block producer encodes the 𝑘 chunks block
content with a (2𝑘, 𝑘) Reed-Solomon (RS) code. Light nodes ran-
domly query a few chunks of the encoded block content. The block
is accepted only if the queried chunks are available. For a block to
be widely accepted by light nodes, most of the light nodes’ queried
chunks have to be available. Quickly, light nodes’ queries cover
more than 50% of coded chunks of the block and any remaining
missing chunks can be recovered using the RS code. It is there-
fore no longer possible to trick light nodes into accepting a block
while withholding data to prevent invalid transaction fraud proofs.
However, a malicious block producer could invalidly encode the
block. Decoding would then not consistently recover the original
chunks’ data. Full nodes can detect invalid encoding and issue a
fraud proof for light nodes. But, the size of such proofs in this
scheme is commensurate to the block content size—defying the
idea of light nodes downloading less than the full block. Subse-
quent works [1, 26, 27, 34] focussed on reducing the fraud proof
size, but drawbacks remain (e.g., complexity, timing assumptions).
A different approach is to make it impossible for block produc-
ers to invalidly encode data. Such schemes can be achieved using
polynomial commitments [18], where the block is interpreted as a
low-degree polynomial, the commitment to which is included in
the block header and gets opened at locations randomly sampled by
light clients. This effectively enforces valid RS encoding. Schemes
of this flavor however require to compute an evaluation witness
for each query, which despite recent algorithmic improvements is
still computationally heavy [30? , 31].

Algorithm Π⋆.Commit of our Semi-AVID-PR scheme is suit-
able for the application at hand. It can commit to a block 𝐵 such
that: (a) The commitment can be opened to chunks, but only of a
valid RS encoding of 𝐵. Computing and verifying these openings is
practically efficient. This enables data availability sampling. (b) The
commitment can be opened to entries of the original block 𝐵. The
openings are short and can be produced and verified practically
efficiently. This enables the invalid transaction fraud proofs of [1].
Let 𝑼 ≡ AsMatrix𝐿×𝑘 (𝐵) with columns 𝒖1, ..., 𝒖𝑘 . An opening
(𝒄𝑖, 𝑖, (ℎ1, ..., ℎ𝑘 )) to chunk 𝑖 of an RS encoding of 𝐵 is computed as:
(ℎ1, ..., ℎ𝑘 ) ← VC⊗𝑘 (𝑼 ) (53)
An opening (𝒄, 𝑖, (ℎ1, ..., ℎ𝑘 )) to chunk 𝑖 of an RS encoding of a
block with commitment 𝐶 is verified as:
𝑠 (ℎ1 ∥...∥ℎ𝑘 ) ∧ [Code.Encode(ℎ1, ..., ℎ𝑘 )]𝑖
𝐶 ?
?
= VC(𝒄) (54)
An opening ([𝒖 𝑗 ]𝑖, 𝑖, 𝑗, (ℎ1, ..., ℎ𝑘 ), 𝑤) to the entry at (𝑖, 𝑗) of the
matrix 𝑼 corresponding to 𝐵 is computed as:

𝒄𝑖 ← [Code.Encode⊗𝐿 (𝑼 )]𝑖

= CRHF

(ℎ1, ..., ℎ𝑘 ) ← VC⊗𝑘 (𝑼 ) 𝑤 ← VC.OpenEntry(pp, 𝒖 𝑗 , 𝑖)

(55)

An opening (𝑦, 𝑖, 𝑗, (ℎ1, ..., ℎ𝑘 ), 𝑤) to entry [𝒖 𝑗 ]𝑖 of a block with
commitment 𝐶 is verified as:
𝐶 ?

𝑠 (ℎ1 ∥...∥ℎ𝑘 ) ∧ VC.VerifyEntry(pp, ℎ 𝑗 , 𝑖, 𝑦, 𝑤) ?

= CRHF

= true (56)

For more details on the application of Π⋆ to data availability

sampling see Appendix E.

ACKNOWLEDGMENT
The authors thank Mohammad Ali Maddah-Ali and Dionysis Zin-
dros for fruitful discussions. KN is supported by a gift from IOG
(Input-Output Global) and a grant from the National Science Foun-
dation Center for Science of Information. JN is supported by the
Protocol Labs PhD Fellowship, a gift from Ethereum Foundation,
and the Reed-Hodgson Stanford Graduate Fellowship.

REFERENCES
[1] Mustafa Al-Bassam, Alberto Sonnino, Vitalik Buterin, and Ismail Khoffi. 2021.
Fraud and Data Availability Proofs: Detecting Invalid Blocks in Light Clients.
In Financial Cryptography (2) (Lecture Notes in Computer Science, Vol. 12675).
Springer, 279–298.

[2] arkworks contributors. 2022. arkworks zkSNARK ecosystem. https://arkworks.rs
[3] Vivek Kumar Bagaria, Sreeram Kannan, David Tse, Giulia C. Fanti, and Pramod
Viswanath. 2019. Prism: Deconstructing the Blockchain to Approach Physical
Limits. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and
Communications Security, CCS 2019, London, UK, November 11-15, 2019. ACM,
585–602. https://doi.org/10.1145/3319535.3363213

[4] Paulo S. L. M. Barreto, Ben Lynn, and Michael Scott. 2002. Constructing Elliptic
Curves with Prescribed Embedding Degrees. In SCN (Lecture Notes in Computer
Science, Vol. 2576). Springer, 257–267.

[5] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. 2018. Scalable,
transparent, and post-quantum secure computational integrity. IACR Cryptol.
ePrint Arch. (2018), 46. http://eprint.iacr.org/2018/046

[6] Sean Bowe. 2017. BLS12-381: New zk-SNARK Elliptic Curve Construction. (2017).

https://electriccoin.co/blog/new-snark-curve/

[7] Sean Bowe, Ariel Gabizon, and Ian Miers. 2017. Scalable Multi-party Computation
for zk-SNARK Parameters in the Random Beacon Model. IACR Cryptol. ePrint
Arch. (2017), 1050.

[8] Kevin D. Bowers, Ari Juels, and Alina Oprea. 2009. Proofs of retrievability: theory

and implementation. In CCSW. ACM, 43–54.

[9] Christian Cachin and Stefano Tessaro. 2005. Asynchronous Verifiable Information
Dispersal. In Distributed Computing, 19th International Conference, DISC 2005,
Cracow, Poland, September 26-29, 2005, Proceedings (Lecture Notes in Computer
Science, Vol. 3724). Springer, 503–504. https://doi.org/10.1007/11561927_42
[10] Dario Catalano and Dario Fiore. 2013. Vector Commitments and Their Appli-
cations. In Public-Key Cryptography - PKC 2013 - 16th International Conference
on Practice and Theory in Public-Key Cryptography, Nara, Japan, February 26 -
March 1, 2013. Proceedings (Lecture Notes in Computer Science, Vol. 7778). Springer,
55–72. https://doi.org/10.1007/978-3-642-36362-7_5

[11] Christian Decker and Roger Wattenhofer. 2015. A Fast and Scalable Payment
Network with Bitcoin Duplex Micropayment Channels. In Stabilization, Safety,
and Security of Distributed Systems - 17th International Symposium, SSS 2015,
Edmonton, AB, Canada, August 18-21, 2015, Proceedings (Lecture Notes in Computer
Science, Vol. 9212). Springer, 3–18.

[12] ]fk Dankrad Feist and Dmitry Khovratovich. [n. d.]. Fast Amortized Kate Proofs.
([n. d.]). https://github.com/khovratovich/Kate/blob/master/Kate_amortized.pdf
[13] Ben Fisch. 2019. Tight Proofs of Space and Replication. In EUROCRYPT (2) (Lecture

Notes in Computer Science, Vol. 11477). Springer, 324–348.

[14] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. 2013. Qua-
dratic Span Programs and Succinct NIZKs without PCPs. In Advances in Cryp-
tology - EUROCRYPT 2013, 32nd Annual International Conference on the Theory
and Applications of Cryptographic Techniques, Athens, Greece, May 26-30, 2013.
Proceedings (Lecture Notes in Computer Science, Vol. 7881). Springer, 626–645.
https://doi.org/10.1007/978-3-642-38348-9_37

[15] Alex Gluchowski. 2020. zkRollup vs. Validium. (2020). https://medium.com/

matter-labs/zkrollup-vs-validium-starkex-5614e38bc263

[16] James Hendricks, Gregory R. Ganger, and Michael K. Reiter. 2007. Verifying
distributed erasure-coded data. In Proceedings of the Twenty-Sixth Annual ACM
Symposium on Principles of Distributed Computing, PODC 2007, Portland, Oregon,
USA, August 12-15, 2007. ACM, 139–146. https://doi.org/10.1145/1281100.1281122
[17] Harry A. Kalodner, Steven Goldfeder, Xiaoqi Chen, S. Matthew Weinberg, and Ed-
ward W. Felten. 2018. Arbitrum: Scalable, private smart contracts. In 27th USENIX
Security Symposium, USENIX Security 2018, Baltimore, MD, USA, August 15-17,
2018. USENIX Association, 1353–1370. https://www.usenix.org/conference/
usenixsecurity18/presentation/kalodner

[18] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. 2010. Constant-Size
Commitments to Polynomials and Their Applications. In Advances in Cryptology
- ASIACRYPT 2010 - 16th International Conference on the Theory and Application of

14

Kamilla Nazirkhanova, Joachim Neu, and David Tse

Cryptology and Information Security, Singapore, December 5-9, 2010. Proceedings
(Lecture Notes in Computer Science, Vol. 6477). Springer, 177–194. https://doi.org/
10.1007/978-3-642-17373-8_11

[19] Jonathan Katz and Yehuda Lindell. 2014. Introduction to Modern Cryptography,

Second Edition. CRC Press.

[20] Eleftherios Kokoris-Kogias, Philipp Jovanovic, Linus Gasser, Nicolas Gailly, Ewa
Syta, and Bryan Ford. 2018. OmniLedger: A Secure, Scale-Out, Decentralized
Ledger via Sharding. In 2018 IEEE Symposium on Security and Privacy, SP 2018,
Proceedings, 21-23 May 2018, San Francisco, California, USA. IEEE Computer
Society, 583–598. https://doi.org/10.1109/SP.2018.000-5

[21] Songze Li, Mingchao Yu, Chien-Sheng Yang, Amir Salman Avestimehr, Sreeram
Kannan, and Pramod Viswanath. 2020. PolyShard: Coded Sharding Achieves
Linearly Scaling Efficiency and Security Simultaneously. In IEEE International
Symposium on Information Theory, ISIT 2020, Los Angeles, CA, USA, June 21-26,
2020. IEEE, 203–208. https://doi.org/10.1109/ISIT44484.2020.9174305

[22] Yuan Lu, Zhenliang Lu, Qiang Tang, and Guiling Wang. 2020. Dumbo-MVBA:
Optimal Multi-Valued Validated Asynchronous Byzantine Agreement, Revisited.
In PODC. ACM, 129–138.

[23] Patrick McCorry, Chris Buckland, Bennet Yee, and Dawn Song. 2021. SoK:
Validating Bridges as a Scaling Solution for Blockchains. IACR Cryptol. ePrint
Arch. (2021), 1589.

[24] Ralph C. Merkle. 1987. A Digital Signature Based on a Conventional Encryption
Function. In Advances in Cryptology - CRYPTO ’87, A Conference on the Theory and
Applications of Cryptographic Techniques, Santa Barbara, California, USA, August
16-20, 1987, Proceedings (Lecture Notes in Computer Science, Vol. 293). Springer,
369–378. https://doi.org/10.1007/3-540-48184-2_32

[25] Andrew Miller, Iddo Bentov, Surya Bakshi, Ranjit Kumaresan, and Patrick Mc-
Corry. 2019. Sprites and State Channels: Payment Networks that Go Faster
Than Lightning. In Financial Cryptography and Data Security - 23rd International
Conference, FC 2019, Frigate Bay, St. Kitts and Nevis, February 18-22, 2019, Revised
Selected Papers (Lecture Notes in Computer Science, Vol. 11598). Springer, 508–526.
https://doi.org/10.1007/978-3-030-32101-7_30

[26] Debarnab Mitra, Lev Tauz, and Lara Dolecek. 2020. Concentrated Stopping
Set Design for Coded Merkle Tree: Improving Security Against Data Availabil-
ity Attacks in Blockchain Systems. In IEEE Information Theory Workshop, ITW
2020, Riva del Garda, Italy, April 11-15, 2021. IEEE, 1–5. https://doi.org/10.1109/
ITW46852.2021.9457630

[27] Debarnab Mitra, Lev Tauz, and Lara Dolecek. 2021. Overcoming Data Availability
Attacks in Blockchain Systems: LDPC Code Design for Coded Merkle Tree. CoRR
abs/2108.13332 (2021). arXiv:2108.13332 https://arxiv.org/abs/2108.13332
[28] I. Reed and G. Solomon. 1960. Polynomial Codes Over Certain Finite Fields.
Journal of The Society for Industrial and Applied Mathematics 8 (1960), 300–304.
[29] Peiyao Sheng, Bowen Xue, Sreeram Kannan, and Pramod Viswanath. 2021. ACeD:
Scalable Data Availability Oracle. In Financial Cryptography (2) (Lecture Notes in
Computer Science, Vol. 12675). Springer, 299–318.

[30] Alin Tomescu. 2020. How to compute all Pointproofs. IACR Cryptol. ePrint Arch.

(2020), 1516. https://eprint.iacr.org/2020/1516

[31] Alin Tomescu, Ittai Abraham, Vitalik Buterin, Justin Drake, Dankrad Feist, and
Dmitry Khovratovich. 2020. Aggregatable Subvector Commitments for Stateless
Cryptocurrencies. In SCN (Lecture Notes in Computer Science, Vol. 12238). Springer,
45–64.

[32] Lei Yang, Seo Jin Park, Mohammad Alizadeh, Sreeram Kannan, and David Tse.
2022. DispersedLedger: High-Throughput Byzantine Consensus on Variable
Bandwidth Networks. (2022).

[33] Haifeng Yu, Ivica Nikolic, Ruomu Hou, and Prateek Saxena. 2020. OHIE:
Blockchain Scaling Made Simple. In 2020 IEEE Symposium on Security and Pri-
vacy, SP 2020, San Francisco, CA, USA, May 18-21, 2020. IEEE, 90–105. https:
//doi.org/10.1109/SP40000.2020.00008

[34] Mingchao Yu, Saeid Sahraei, Songze Li, Salman Avestimehr, Sreeram Kannan, and
Pramod Viswanath. 2020. Coded Merkle Tree: Solving Data Availability Attacks
in Blockchains. In Financial Cryptography and Data Security - 24th International
Conference, FC 2020, Kota Kinabalu, Malaysia, February 10-14, 2020 Revised Selected
Papers (Lecture Notes in Computer Science, Vol. 12059). Springer, 114–134. https:
//doi.org/10.1007/978-3-030-51280-4_8

A CALCULATIONS FOR TABLE 1
Table 1 shows communication and storage required to disperse a
block of size |𝐵| = 22 MB among 𝑛 = 1024 storage nodes using
different schemes. We provide the corresponding calculations here.
We denote communication and storage costs as 𝐶 and 𝑆, respectively.
We assume the size of a hash is 𝜆h = 32 B, and the size of an LVC
is 𝜆c = 48 B (as in BLS12-381). Given adversarial resilience 𝑡, we

Information Dispersal with Provable Retrievability for Rollups

]
B
M

[

t
s
o
c

e
g
a
r
o
t
s
d
n
a

]
B
k
[

e
z
i
s

f
o
o
r
p
d
u
a
r
f

n
o
i
t
a
c
i
n
u
m
m
o
C

g
n

i
d
o
c
n
e
d
i
l
a
v
n
I

800

600

400

200

0

600

400

200

20

40

60

80

100

Base layer symbol size [kB]

Figure 8: Communication and storage cost (top) and invalid
encoding fraud proof size (bottom) as a function of the base
layer symbol size 𝑐, when dispersing a file of size 22 MB
among 1024 nodes using ACeD [29] with resilience 𝑡 = 0.33𝑛.

choose 𝑘 ≜ 𝑛−2𝑡. In the following, we do not account for signatures
on messages or for blockchain interaction (e.g., ACeD).
• Repetition (uncoded) scheme:

𝐶 = 𝑆 = 𝑛|𝐵|

• AVID:

𝐶 =

+ 𝑛𝜆h

(cid:19) (cid:16)

𝑛 + 𝑛2(cid:17)
(cid:19)

(cid:18) |𝐵|
𝑘
(cid:18) |𝐵|
𝑘

𝑆 = 𝑛

+ 𝑛𝜆h

• AVID-FP:

• AVID-M:

𝐶 = 𝑛

𝑆 = 𝑛

(cid:18) |𝐵|
𝑘
(cid:18) |𝐵|
𝑘

(cid:19)

(cid:19)

+ (𝑛 + 𝑘)𝜆h

+ (𝑛 + 𝑘)𝜆h

+ 𝑛2 (𝑛 + 𝑘)𝜆h

𝐶 = 𝑛

𝑆 = 𝑛

(cid:18) |𝐵|
𝑘
(cid:18) |𝐵|
𝑘

+ (1 + log2 𝑛)𝜆h

+ (1 + log2 𝑛)𝜆h

+ 𝑛2𝜆h

(cid:19)

(cid:19)

• ACeD:

𝐶 = 𝑆 = 𝑛

Parameters:
𝑡 ′ = 16

(cid:18)
𝑡 ′𝜆h +

|𝐵|
𝑛𝑟𝜆

+

(2𝑞 − 1)|𝐵|𝜆h
𝑛𝑟𝑐𝜆

log𝑞𝑟

(cid:19)

|𝐵|
𝑐𝑡 ′𝑟

𝑟 = 0.25

𝑞 = 8

𝑑 = 8

𝑐 = 40 kB 𝜂 = 0.875 𝜆 =

1 − 2𝑡/𝑛
(cid:17)
(cid:16) 1
1−𝜂

ln

(57)

(58)

(59)

(60)

(61)

(62)

(63)

(64)

(65)

(66)

As illustrated in Figure 8, the communication and storage cost of
ACeD can be decreased by increasing the base layer symbol size
𝑐, at the expense of an increased invalid encoding fraud proof
size. We picked what seemed to us to be a reasonable tradeoff,
where increasing the fraud proof size further does not lead to
any more substantial gains in communication and storage.

15

Algorithm 12 Existential forgery game (EFG) against Sig =
(Sig.KeyGen, Sig.Sign, Sig.Verify)

1: M ← ∅
2: (pk, sk) ← Sig.KeyGen(1𝜆)
3: function Osign(m)
4: M ← M ∪ {𝑚}
5:
6: (𝑚, 𝜎) ← A Osign (.)
(pk)
7: return 𝑚 ∉ M ∧ Sig.Verify(pk, 𝑚, 𝜎) = true

return Sig.Sign(sk, 𝑚)

EFG

Algorithm 13 Collision finding game (CFG) against HF =
(HF.Gen, HF.H)
1: 𝑠 ← HF.Gen(1𝜆)
2: (𝑥, 𝑥 ′) ← ACFG (𝑠)
3: return 𝑥 ≠ 𝑥 ′ ∧ CRHF𝑠 (𝑥) = CRHF𝑠 (𝑥 ′)

Algorithm 14 Binding game (VCBG) against LVC
(LVC.Setup, LVC.Commit)
1: pp ← LVC.Setup(1𝜆)
2: (𝒗, 𝒗 ′) ← AVCBG (pp)
3: return 𝒗 ≠ 𝒗 ′ ∧ LVC.Commit(𝒗) = LVC.Commit(𝒗 ′)

=

• Semi-AVID-PR:

𝐶 = 𝑛

𝑆 = 𝑛

(cid:18) |𝐵|
𝑘
(cid:18) |𝐵|
𝑘

(cid:19)

(cid:19)

+ 𝑘𝜆c

+ 𝑘𝜆c

(67)

(68)

B PRELIMINARIES

Definition B.1 (Hash Function). A hash function is a pair of PPT

algorithms (Gen, H) [19], such that:
• Gen : 1𝜆 ↦→ 𝑠: takes as input a security parameter 𝜆 and outputs

a randomly sampled key 𝑠,

• H : (𝑠, 𝑥) ↦→ ℎ: takes as input a key 𝑠 and a string 𝑥 ∈ {0, 1}∗

and outputs a string ℎ ∈ {0, 1}𝜆.
Definition B.2 (Digital Signature Scheme). A digital signature
scheme Sig = (KeyGen, Sign, Verify) [19] consists of three PPT
algorithms, such that:
• KeyGen : 1𝜆 ↦→ (pk, sk): takes as input a security parameter 𝜆

and outputs a public key pk and a secret key sk,

• Sign : (sk, 𝑚) ↦→ 𝜎: takes as input a secret key sk and a message

𝑚 and outputs a signature 𝜎,

• Verify : (pk, 𝑚, 𝜎) ↦→ 𝑏 ∈ {true, false}: takes as input a public
key pk, a message 𝑚 and a signature 𝜎 and outputs a boolean 𝑏
indicating whether the signature is valid.

Definition B.3 (Deterministic Vector Commitment Scheme). A de-
terministic vector commitment scheme VC = (Setup, Commit,
OpenEntry, VerifyEntry) [10, 18] consists of four PPT algorithms,
such that:
• Setup : 1𝜆 ↦→ pp: takes as input a security parameter 𝜆 and

outputs some public parameters pp,

Kamilla Nazirkhanova, Joachim Neu, and David Tse

(a) (𝑛, 𝑘) = (128, 32)

(b) (𝑛, 𝑘) = (256, 64)

(c) (𝑛, 𝑘) = (1024, 256)

(a) (𝑛, 𝑘) = (128, 32)

(b) (𝑛, 𝑘) = (256, 64)

(c) (𝑛, 𝑘) = (1024, 256)

100

10

10

4

8

16

32

4

8

16

32

4

8

16

32

(d) (𝑛, 𝑘) = (128, 43)

(e) (𝑛, 𝑘) = (256, 85)

(f) (𝑛, 𝑘) = (1024, 341)

10

1

0.1

10

1

0.1

10

1

4

8

16

32

4

8

16

32

4

8

16

32

100

(d) (𝑛, 𝑘) = (128, 43)

(e) (𝑛, 𝑘) = (256, 85)

(f) (𝑛, 𝑘) = (1024, 341)

8

16

32

8

16

32

8

16

32

(g) (𝑛, 𝑘) = (128, 58)

(h) (𝑛, 𝑘) = (256, 115)

(i) (𝑛, 𝑘) = (1024, 461)

100

100

10

1

0.1

10

1

10

1

100

8

16

32

8

16

32

8

16

32

(g) (𝑛, 𝑘) = (128, 58)

(h) (𝑛, 𝑘) = (256, 115)

(i) (𝑛, 𝑘) = (1024, 461)

8

16

32

64

8

16

32

64

8

16

32

64

Figure 9: Single-thread runtime (ordinate, in seconds) of
Disperse ( ) and Retrieve ( ) on AMD Opteron 6378 processor
for varying file sizes (abscissa, in 106 bytes; for varying 𝐿) in
BLS12-381 curve. Rows: code rates 𝑘/𝑛 ≈ 0.25, 0.33, 0.45 (
,
). Columns: system sizes 𝑛 = 128, 256, 1024 ( ,
).

,

,

(Disaggregated: Figure 6)

• Commit : (pp, 𝒗) ↦→ 𝐶: takes as input the public parameters pp

and a vector 𝒗 and outputs a commitment 𝐶,

• OpenEntry : (pp, 𝒗, 𝑖) ↦→ 𝜋𝑖 : takes as input the public parame-
ters pp, a vector 𝒗, a position 𝑖 and returns a proof 𝜋𝑖 attesting
to the fact that [𝒗]𝑖 is the 𝑖-th entry of 𝒗,

• VerifyEntry : (pp, 𝐶, 𝑖, 𝑦, 𝜋) ↦→ 𝑏 ∈ {true, false}: takes as in-
put the public parameters pp, a commitment 𝐶, a position 𝑖, a
value 𝑦, and an opening proof 𝜋, and returns a boolean 𝑏 in-
dicating whether 𝜋 is a proof attesting to the fact that 𝐶 is a
commitment to a vector 𝒗 such that [𝒗]𝑖 = 𝑦.

C ADDITIONAL EVALUATION PLOTS
The runtime measurements for different steps of Π⋆ shown in
Figure 6 are aggregated for Disperse and Retrieve in Figure 9.

Figures 6 and 9 use curve BLS12-381. Corresponding plots for
curve BN254 are provided in Figures 10 and 11. The plots show a
slight speedup, due to faster operations in BN254.

D PROOF DETAILS
We modify the availability game AvG (Alg. 2) to obtain AvG′ (Alg. 15)
in which initially the index 𝐼 of a storage node is sampled uniformly
at random, and subsequently the game is aborted if the adversary
AAvG′ attempts to corrupt 𝐼 .

10

1

0.1

10

1

100

10

1

8

16

32

64

8

16

32

64

8

16

32

64

,

Figure 10: Single-thread runtime (ordinate, in seconds) of
different steps of Π⋆ on AMD Opteron 6378 processor for
varying file sizes (abscissa, in 106 bytes; for varying 𝐿) in
BN254 curve. Rows: code rates 𝑘/𝑛 ≈ 0.25, 0.33, 0.45 (
,
). Columns: system sizes 𝑛 = 128, 256, 1024 ( ,
).
Steps of Π⋆: Disperse: Reed-Solomon (RS) encoding ( ), com-
puting vector commitments ( ). Retrieve: Verifying down-
loaded chunks ( ), RS decoding 𝑘 ×𝑘 matrix inversion ( ), RS
decoding matrix-matrix product ( ). (Aggregated: Figure 11.
Note that

in some plots.)

lies on top of

,

E DETAILS ON APPLICATION TO DATA

AVAILABILITY SAMPLING

In common blockchain designs all nodes have to download the
full blockchain and validate all included transactions (e.g., check
that accounts have sufficient balances, no funds are created out
of thin air, etc.). However, if a node does not have enough band-
width, storage, or computational resources to do so, it can instead
participate as a so called light node.5 We assume that every block
consists of a header comprised of meta data and a body comprised
of a list of transactions. The header includes a commitment to the
block content, binding the two together. Full nodes process block
headers and content, while light nodes only process block headers.
If an invalid transaction was added to a block, this block would be
rejected by full nodes but a header of this block can be accepted

5Light nodes also occur in the context of sharding, where each node is assigned to
a shard and behaves in-shard (i.e., towards their assigned shard) as a full node and
out-of-shard (i.e., towards other shards) as a light node.

16

Information Dispersal with Provable Retrievability for Rollups

(a) (𝑛, 𝑘) = (128, 32)

(b) (𝑛, 𝑘) = (256, 64)

(c) (𝑛, 𝑘) = (1024, 256)

10

10

10

4

8

16

32

4

8

16

32

4

8

16

32

(d) (𝑛, 𝑘) = (128, 43)

(e) (𝑛, 𝑘) = (256, 85)

(f) (𝑛, 𝑘) = (1024, 341)

10

10

100

10

8

16

32

8

16

32

8

16

32

(g) (𝑛, 𝑘) = (128, 58)

(h) (𝑛, 𝑘) = (256, 115)

(i) (𝑛, 𝑘) = (1024, 461)

100

10

10

8

16

32

64

8

16

32

64

8

16

32

64

14:

15:

Figure 11: Single-thread runtime (ordinate, in seconds) of
Disperse ( ) and Retrieve ( ) on AMD Opteron 6378 processor
for varying file sizes (abscissa, in 106 bytes; for varying 𝐿)
in BN254 curve. Rows: code rates 𝑘/𝑛 ≈ 0.25, 0.33, 0.45 (
,
). Columns: system sizes 𝑛 = 128, 256, 1024 ( ,
).

,

,

(Disaggregated: Figure 10)

by a light node, since the light node cannot inspect the block con-
tent and verify transaction validity. To prevent light nodes from
accepting (the header of) an invalid block, full nodes can produce
an invalid transaction fraud proof (i.e., a succinct string of the evi-
dence necessary to verify relative to the block header that the block
indeed contains an invalid transaction). To take full nodes’ ability
to issue invalid transaction fraud proofs, a malicious block producer
can perform a data availability attack and withhold parts of the
block content, including the invalid transaction. Full nodes would
now temporarily reject the block (until its content becomes fully
available), but light nodes would not notice the missing content
since they do not attempt to download the block content anyway.
In this setting, the absence of an invalid transaction fraud proof
can thus mean two things: either that the block is alright, or that
full nodes were not able to verify the block due to missing data. To
rule out the possibility of data unavailability (so that finally lack
of fraud proof implies the block is valid), various data availability
sampling schemes for light nodes were introduced.

Data availability schemes using Reed-Solomon codes were pro-
posed in [1]. In a naive scheme, a block producer encodes a list of
transactions, consisting of 𝑘 chunks, with a (2𝑘, 𝑘) Reed-Solomon
code. Once a light node receives a header of the block, it randomly
queries a few chunks of the encoded block content. The block is
accepted only if the queried chunks are available. For a block to be
widely accepted by light nodes, most of the light nodes’ queried
chunks have to be available. Quickly, light nodes’ queries cover
more than 50% of coded chunks of the block, so that any remaining
missing chunks can be recovered using the Reed-Solomon code. It

17

Algorithm 15 Modified availability game (AvG′) with re-
silience 𝑡
=
(Setup, Commit, Disperse, Verify, Retrieve)

against Semi-AVID-PR scheme ΠSAVIDPR

←− [𝑛]

1: 𝐼 R
2: C ← ∅
3: ∀𝑖 ∈ [𝑛] : 𝑃𝑖 ← new ΠSAVIDPR (∅)

ΠSAVIDPR with blank state

4: pp ← Setup𝑃1,...,𝑃𝑛 (1𝜆)
5: function Ocorrupt(𝑖)
assert 𝑖 ∉ C
6:
if 𝑖 ≠ 𝐼

7:

⊲ Bookkeeping of corrupted parties
⊲ Instantiate 𝑃𝑖 as

⊲ Run setup among all parties
⊲ Oracle for A to corrupt parties

8:

9:

10:

C ← C ∪ {𝑖}
return 𝑃𝑖

else

⊲ Mark party as corrupted
⊲ Hand 𝑃𝑖 ’s state to A

(cid:16)

(cid:16)

(cid:17)

abort

11:
12: function Ointeract(𝑖, 𝑚) ⊲ Oracle for A to interact with parties
13:

assert 𝑖 ∉ C
return 𝑃𝑖 (𝑚) ⊲ Execute 𝑃𝑖 on input 𝑚, return output to A
⊲ A
𝑃, 𝐶,
AvG′
returns certificate of retrievability 𝑃, commitment 𝐶, and oracle
access to corrupted nodes for retrieval

← A Ocorrupt (.),Ointeract (.)

16: ^𝐵 ← Retrieve𝑃1,...,𝑃𝑛 (cid:2)Onode

⊲
During retrieval, interact with corrupted nodes through oracles
⊲ A wins iff: while

17: return |C| ≤ 𝑡

(.)/Query(𝑖, .)(cid:3)

𝑖 ∈ C (𝑃, 𝐶)

Onode
𝑖

(pp)

𝑖 ∈ C

(.)

(cid:17)

𝑖

∧ Verify(𝑃, 𝐶) = true
∧ Commit( ^𝐵) ≠ 𝐶

corrupting no more than 𝑡 parties, A produces a valid certificate
of retrievability 𝑃 for 𝐶 such that retrieval does not return a file
matching 𝐶

is therefore no longer possible to trick light nodes into accepting
a block while withholding a chunk in an attempt to prevent full
nodes from generating an invalid transaction fraud proof. The main
drawback of this solution is that a malicious block producer could
invalidly encode the block. Decoding would then not consistently
recover the original chunks’ data, even if nominally enough chunks
are available. Again, full nodes would be able to detect invalid en-
coding, but light nodes would not. And again, full nodes could issue
a fraud proof to prevent light nodes from accepting an invalidly
encoded block. However, the amount of evidence needed to prove
invalid encoding in this scheme is as big as the block content itself –
defying the idea of light nodes downloading less than the full block
content. For example, an invalid encoding fraud proof consists of
the full original block data, which the light node can verify with
respect to the block header, re-encode, and then check that some
of the ‘encoded’ chunks received in response to data availability
queries do not match the properly encoded chunks. Subsequent
works [1, 26, 27, 34] on data availability schemes of this flavor
have thus focussed on reducing the size of invalid encoding fraud
proofs, but drawbacks remain (e.g., additional complexity, timing
assumptions).

A different approach is to eliminate invalid encoding fraud proofs
by making it impossible for block producers to invalidly encode
data. Such schemes can be achieved using polynomial commitment

Kamilla Nazirkhanova, Joachim Neu, and David Tse

Since in Semi-AVID-PR valid encoding can be verified by light
nodes using the homomorphic property of linear vector commit-
ments, invalid encoding fraud proofs are not needed needed. At
the same time, verifying a chunk requires only to compute a vector
commitment (to 𝒄𝑖 ) and a linear combination of the vector commit-
ments ℎ1, ..., ℎ𝑘 , which is lightweight to compute. Performance is
discussed in more detail in Section 7.

schemes such as KZG [18]. Treated as evaluations of a polynomial at
agreed-upon locations, the 𝑘 chunks of the block content uniquely
determine a polynomial of degree 𝑘 − 1. A commitment to this poly-
nomial is included in the block header. To ensure data availability,
light nodes query for evaluations of this polynomial at random lo-
cations. Consistency of every query response with the polynomial
committed to in the block header can be verified using the polyno-
mial commitment scheme by providing an evaluation witness. Even
with few queries each, light nodes together will soon have queried
evaluations at at least 𝑘 distinct locations. If the block producer
withholds any of these evaluations, light nodes will not accept the
block. But once evaluations at 𝑘 distinct locations are available, the
polynomial, and thus the block content, can be reconstructed. Any
invalid transaction becomes visible and full nodes can generate
corresponding fraud proofs. Schemes of this flavor however require
to compute an evaluation witness for each query, which despite
recent algorithmic improvements is still computationally heavy
[30? , 31].

The Semi-AVID-PR scheme, described in Section 4 and illustrated
in Figure 5, can be seen as combining ‘the best of both worlds’ in
that it does not require invalid encoding fraud proofs, but sampled
chunks can be verified efficiently. We assume that a block contains
an alternating sequence of transactions and commitments to result-
ing intermediary chain states (this is used for invalid transaction
fraud proofs as in [1]). As illustrated in Figure 5, the block producer
arranges the block content 𝑼 as a matrix of size 𝐿 × 𝑘, where 𝑘
and 𝐿 are system parameters. It commits to each of the columns
𝒖1, ..., 𝒖𝑘 of that matrix using the linear vector commitment scheme
defined in Section 2.3 (to obtain commitments ℎ1, ..., ℎ𝑘 ), and en-
codes the matrix 𝑼 row-wise using a (𝑛, 𝑘) Reed-Solomon code to
obtain chunks 𝒄1, ..., 𝒄𝑛 of a coded matrix 𝑪. A final commitment
to the full block content is computed as 𝐶 ≜ CRHF𝑠 (ℎ1 ∥...∥ℎ𝑘 )
and used on-chain in the block’s header to uniquely reference the
block content. Full nodes receive the full block content, recompute
the column commitments and their hash, and compare it with 𝐶 to
verify the block content. Light nodes receive only 𝐶 from the block
header. Prior to accepting a new block header, a light node samples
random coded chunks 𝒄𝑖 . The response to each query is accom-
panied by purported column commitments ℎ1, ..., ℎ𝑘 . Every light
node can verify the column commitments by locally recomputing
their hash and comparing it with the commitment 𝐶 in the block
header. Subsequently, the light node verifies the downloaded chunk
𝒄𝑖 using the linear homomorphic property of the vector commit-
ment scheme and the column commitments ℎ1, ..., ℎ𝑘 . To employ
the invalid transaction fraud proofs of [1], it remains to show how
a full node can open any entry of 𝑼 to a light node in a verifiable
manner. For this purpose, an opening witness for value 𝑦 = [𝒖 𝑗 ]𝑖
at position (𝑖, 𝑗) consists of:
• Value 𝑦 = [𝒖 𝑗 ]𝑖 and coordinates (𝑖, 𝑗).
• Commitments ℎ1, ..., ℎ𝑘 to columns 𝒖1, ..., 𝒖𝑘 .
• A witness 𝑤 for the opening of 𝑦 at the 𝑖-th position in 𝒖 𝑗 with

respect to the vector commitment ℎ 𝑗 .

The light client first verifies the commitments ℎ1, ..., ℎ𝑘 by com-
paring their hash to the commitment 𝐶 in the block header. The
client then verifies the opening of the value 𝑦 at position 𝑖 in 𝒖 𝑗
with respect to the vector commitment ℎ 𝑗 .

18

