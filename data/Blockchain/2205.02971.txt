2
2
0
2

y
a
M
6

]

R
C
.
s
c
[

1
v
1
7
9
2
0
.
5
0
2
2
:
v
i
X
r
a

Transferable Cross-Chain Options

Daniel Engel
Computer Science Dept., Brown University
Providence, RI, USA

Yingjie Xue
Computer Science Dept., Brown University
Providence, RI, USA

ABSTRACT
An option is a financial agreement between two parties to trade
two assets. One party is given the right, but not the obligation, to
complete the swap before a specified termination time. In today‚Äôs
financial markets, an option is considered an asset which can itself
be transferred: while an option is active, one party can sell its rights
(or obligations) to another.

Today‚Äôs blockchains support simple options in the form of cross-
chain atomic swap protocols where one party has the choice whether
to complete the swap. The options implemented by these cross-
chain protocols, are not, however, transferable.

This paper proposes novel distributed protocols for transferable
cross-chain options, where both option owners and providers can sell
their positions to third parties. The protocol ensures that none of
the parties can be cheated, that no unauthorized party can interfere,
and that the transfer succeeds if the buyer and seller faithfully
follow the protocol.

1 INTRODUCTION
An option is a financial agreement between two parties, say, Alice
and Bob. Alice owns some units of ‚Äúflorin‚Äù cryptocurrency, while
Bob owns some units of ‚Äúguilder‚Äù cryptocurrency. Alice and Bob
agree that Alice will purchase from Bob the right, but not the obli-
gation, to buy 100 guilders from him in return for 100 florins from
her, at any time before, say, next Tuesday. If the value of guilders
relative to florins goes up before Tuesday, Alice will exercise her
option by executing the trade, and otherwise she will keep her
florins and walk away. Alice pays Bob a fee, called a premium, to
compensate him for his inconvenience and risk.

In the world of decentralized finance (Defi), florins and guilders
are managed on distinct blockchains, Alice and Bob are autonomous
agents, and they do not trust each other. Moreover, they have no re-
course to third-party arbiters or to courts of law. Several non-trivial
distributed protocols have been proposed to execute cross-chain
swaps and options [7, 11‚Äì14, 16, 21‚Äì23]. Simplifying somewhat,
these protocols guarantee that if Alice and Bob are both honest,
then the deal unfolds as planned, but if either party cheats, the
honest party ends up in what it considers a satisfactory position.

The contribution of this paper is to take the notion of a cross-
chain option to the next level: while Alice‚Äôs unexercised option
has value, she should be able to sell it to a third party, Carol. In
conventional finance, such a transfer is simple: Bob grants Alice
an options contract, Alice signs over that contract to Carol, and
all agreements are enforced by civil law. In the lawless world of
decentralized finance, by contrast, transferable options require a
carefully-crafted distributed protocol.

We propose novel cross-chain protocols, to support transferable
cross-chain options. Additionally, we prove the security properties

1

of our proposed protocols, and detailed pseudocode for the proto-
cols is provided. Informally, our proposed protocols can address
option transfer in the following scenarios:

(1) Alice (the option owner, i.e the one who has a right to buy
an asset) transfers her position to another party (Carol).
(2) Bob (the option provider, i.e. the one who provides the owner
the right) transfers his position to another party (David).
(3) Alice and Bob concurrently transfer their positions to Carol

and David, respectively.

Take the option position transfer between Alice and Carol for
example. The proposed transfer protocol ensures that if Alice and
Carol are honest, then Alice relinquishes her rights, Carol assumes
Alice‚Äôs rights, and Bob cannot veto the transfer. If Carol cheats,
then Alice‚Äôs rights remain with Alice.

We view the proposed distributed protocols as a first step toward
a more ambitious goal. One can imagine more complex cross-chain
deals where parties acquire various rights and obligations (options,
futures, derivatives, and so on). It should be possible for a party
who holds unrealized rights or obligations to sell those rights or
obligations to another party, atomically transferring its position
without being hindered by any third party. Here, we show how to
make certain transferable cross-chain option deals, but someday
we hope to do the same for arbitrary cross-chain deals.

This paper is organized as follows. Our model is given in Sec-
tion 2. We provide an overview of our proposed transferable two-
party swap protocols in Section 3 and detailed protocols are de-
scribed in Section 4. We prove security properties of our proposed
protocols in Section 5. In Section 6, we describe related work. Finally,
we conclude in Section 7.

2 MODEL
For our purposes, a blockchain is a tamper-proof distributed ledger
(or database) that tracks ownership of assets by parties. An asset can
be a cryptocurrency, a token, an electronic deed to property, and so
on. A party can be a person, an organization, or even a contract (see
below). There are multiple blockchains managing different kinds of
assets. We focus here on applications where mutually-untrusting
parties trade assets across multiple blockchains. Because we treat
blockchains simply as ledgers, our results do not depend on specific
blockchain technology (such as proof-of-stake vs proof-of-work).
We assume only that ledgers are highly available, tamper-proof,
and capable of running smart contracts.

A smart contract (or ‚Äúcontract‚Äù) is a blockchain-resident program
initialized and called by the parties. A party can create a contract
on a blockchain, or call a function exported by an existing contract.
Contract code and state are public, so a party calling a contract
function knows what code will be executed. Contract code is deter-
ministic because contract execution is replicated, and all executions
must agree.

 
 
 
 
 
 
A contract can read or write ledger entries on the blockchain
where it resides, but it cannot actively access data from the outside
world, including calling contracts on other blockchains. Although
there are protocols that allow blockchains to communicate (cross-
chain proofs), they have weaknesses that make them difficult to use
in practice: for example, incompatibility problems, lack of decentral-
ization, and non-deterministic guarantees of message delivery [20].
Therefore, we assume different blockchains do not communicate.
A contract on blockchain ùê¥ can learn of a change to a blockchain
ùêµ only if some party explicitly informs ùê¥ of ùêµ‚Äôs change, along with
some kind of ‚Äúproof‚Äù that the information about ùêµ‚Äôs state is correct.
Contract code is passive, public, deterministic, and trusted, while
parties are active, autonomous, and potentially dishonest.

At any given time each party has a given financial position. This
is characterized by their current and future financial obligations/al-
lowances. Financial positions are managed by rules on contracts
that can reside across multiple distinct blockchains.

Our execution model is synchronous: there is a known upper
bound Œî on the propagation time for one party‚Äôs change to the
blockchain state, plus the time to be noticed by the other parties.
Specifically, blockchains generate new blocks at a steady rate, and
valid transactions sent to the blockchain will be included in a block
and visible to participants within a known, bounded time Œî.

As noted, we assume blockchains are always available, tamper-
proof, and that they correctly execute their contracts. Although
parties may display Byzantine behavior, contracts can limit their
behavior by rejecting unexpected contract calls.

We make standard cryptographic assumptions. Each party has a
public key and a private key, and any party‚Äôs public key is known to
all. Messages are signed so they cannot be forged, and they include
single-use labels (‚Äúnonces‚Äù) so they cannot be replayed.

3 PROBLEM OVERVIEW
One way to convey the challenge presented by making options
transferable is to trace the evolutionary path that leads from 20th
Century distributed systems to modern decentralized finance (DeFi).
Suppose, in 1999, Alice and Bob agree that she will transfer 100
dollars to him at a New York bank, and he will transfer 100 eu-
ros to her at a Paris bank. Each bank maintains its own database,
which communicate over a network. The swap protocol must tol-
erate hardware failures: databases can crash and messages can be
lost. Each bank makes a tentative transfer. In the classical two-
phase commit protocol [2], each bank records its tentative transfers
‚Äúsomewhere safe‚Äù (on a magnetic disk that survives crashes) and
sends to a trusted coordinator a vote whether to commit or abort. If
both banks vote to commit, the transfers are installed, and if either
votes to abort, or does not vote in a reasonable time, the transfers
are discarded, leaving both databases unchanged.

The two-phase commit protocol established a pattern for later
blockchain protocols. Today, Alice and Bob want to trade units
of cryptocurrency. They agree to exchange 100 of her (electronic)
florins for 100 of his (electronic) guilders. Each cryptocurrency
is managed on a distinct blockchain. Alice and Bob must agree
on a swap protocol that tolerates not only hardware failures, but
Byzantine failures by participants: each party must protect itself if
its counterparty cheats by departing from the agreed-upon protocol.

Daniel Engel and Yingjie Xue

Atomic swap protocols based on hashed timelock contracts (HTLCs) [13,

17] mimic two-phase commit. In the HTLC protocol‚Äôs first phase,
each party places the assets to be transferred ‚Äúsomewhere safe‚Äù.
In place of writing to magnetic disk, Alice transfers her florins to
an escrow account controlled by a smart contract, a program that
decides, based on later input, whether to commit by transferring
Alice‚Äôs florins to Bob, or to abort by refunding Alice her florins.
Then Bob does the same. Each escrow transfer is effectively a vote
to commit. When both votes are confirmed, Alice releases a secret
that causes the contracts to complete the swap. Otherwise, if the
escrow transfers are not confirmed in reasonable time, the contracts
refund the assets to their original owners. This description elides
many technical details, but the HTLC protocol‚Äôs overall structure
is remarkably similar to two-phase commit, despite substantial
differences in their failure models.

While technically correct, HTLC swap protocols are flawed: once
both assets are escrowed, Alice can take her time deciding whether
to trigger the swap. Cryptocurrencies are notoriously volatile, so if
the value of Bob‚Äôs guilders goes up relative to Alice‚Äôs florins before
the timeout expires, she can choose to complete the swap at the last
minute. If the value goes down, she is free to walk away without
penalty. Bob may be reluctant to accept such a deal.

This protocol is unfair to Bob because only Alice has optionality:
at the end, he cannot back out of the deal, but she can. If she does
back out, he gets his guilders back, but only after a possibly long
delay while the market is moving against him. Bob thus incurs the
opportunity cost of not being able to use his coins while they are
escrowed. By contrast, in conventional finance, this deal would be
structured as an option contract, where Alice pays Bob a fee, called a
premium, to compensate him if she walks away without completing
the deal.

Cross-chain atomic swap options require carefully-defined dis-
tributed protocols [16, 23]. The protocol proposed by Xue and Her-
lihy [23] is structured like an iterated two-phase commit protocol:
in the first phase the parties escrow premiums. If all goes well, in
the next phase they escrow coins. If all goes well in the final phase
they complete the swap. Any party who drops out of the protocol
ends up paying a premium to the other, and in the end, Alice has
the optionality, but Bob has been compensated for his risk.

We are now ready to address the main topic of this paper. As long
as Alice has optionality, that optionality has value. Alice should be
able to sell her position to a third party Carol. (Bob may also want
to sell his position to a third party David). For starters, we focus
on Alice‚Äôs position transfer since Bob‚Äôs transfer will be similar.
There are many reasons Alice and Carol might agree to such a
deal. Alice may want to liquidate her position because she needs
cash. Perhaps Alice and Carol have different opinions on the future
values of florins versus guilders, or they have different levels of risk
tolerance.

A transferable atomic swap option (or ‚Äútransferable swap‚Äù) proto-
col roughly must satisfy the following properties. (We define these
properties more precisely in Section 5.)

‚Ä¢ Liveness: If Alice and Carol both follow the protocol, then
(1) Carol acquires the right to buy Bob‚Äôs coins at the same
price and deadline, (2) Alice loses that right, and she is paid
by Carol, (3) Bob cannot veto the transfer.

2

Transferable Cross-Chain Options

‚Ä¢ Safety: As long as one of Alice or Carol follows the protocol,
(1) the protocol completes before the option expires, and (2)
when the protocol completes, exactly one of Alice or Carol
has the right to trigger the atomic swap with Bob, (3) Bob‚Äôs
position in the option does not change if he conforms.

Here is a high-level summary of our protocol. The contract linking
Alice and Bob is a delayed swap: Alice escrows her asset, then Bob
escrows his. These escrow contracts are controlled by a hashlock ‚Ñé.
Until each contract‚Äôs timeout expires, that contract will complete
its side of the swap when Alice produces a secret ùê¥1 such that
‚Ñé = ùêª (ùê¥1), where ùêª (¬∑) is a predefined cryptographic hash function.
Alice has optionality because she alone knows the secret.

Here is how Carol can buy Alice‚Äôs position. First, there must be
enough time to complete this transfer before Alice‚Äôs option expires.
Roughly speaking, Carol generates a secret, then Alice and Carol
swap the roles of Carol‚Äôs and Alice‚Äôs secrets: following the transfer,
Alice‚Äôs secret will no longer trigger the swap with Bob, but Carol‚Äôs
secret will.

There are two contracts (discussed in detail below). Contract ùê¥ùêµ
controls Alice‚Äôs possible payment to Bob, while ùêµùê¥ controls Bob‚Äôs
payment to Alice. The optionality transfer itself is structured like
a cross-chain swap, exchanging roles instead of assets. In the first
phase, Alice marks contracts ùê¥ùêµ and ùêµùê¥ as mutating, temporarily
preventing any transfer to or from Bob. This step prevents Alice
or Carol from creating a chaotic situation by triggering a partial
asset swap with Bob while the optionality transfer is in progress.
In the second phase, Carol replaces the (hash of) Alice‚Äôs secret and
address in both ùê¥ùêµ and ùêµùê¥ with the (hash of) Carol‚Äôs secret and
address. Just as for regular swaps, the optionality transfer protocol
will time out and revert if Alice or Carol fails to take a step in time.
There is still a danger that Alice and Carol might cheat Bob
by making inconsistent changes to contracts ùê¥ùêµ and ùêµùê¥. Because
ùê¥ùêµ and ùêµùê¥ cannot coordinate directly, the protocol has a built-in
delay to give Bob an opportunity to contest a malformed transfer
and to revert its changes. If the transfer is well-formed, Bob can
expedite the protocol by actively approving of the transfer, perhaps
in return for an extra premium. If Bob remains silent, the protocol
will proceed after the delay expires. Bob contests the transfer by
providing proof that Alice signed inconsistent changes to ùê¥ùêµ and
ùêµùê¥.

To keep the presentation uncluttered, we omit some functionality
that would be expected in a full protocol, but that is not essential for
optionality transfer. For example, there would be additional steps
where parties deposit premiums to compensate one another if one
party leaves the other‚Äôs assets temporarily trapped in escrow, where
Alice pays Bob a premium to encourage prompt transfer approval,
and where Alice posts a bond to be slashed if she is caught sending
inconsistent information to ùê¥ùêµ and ùêµùê¥.

4 TWO-PARTY TRANSFERABLE SWAP
4.1 Overview
We will now describe several protocols for transferring option
positions. First we will describe a protocol that allows Alice to
transfer her position as the option owner in a swap with Bob, to a
third-party Carol. Next, we will give a protocol that allows Bob to
transfer his position as the option provider in a swap with Alice, to

3

a third-party David. Finally, we show that both of these protocols
can be run concurrently and can also support multiple concurrent
buyers. Solidity code for these contracts appears in Appendix .1.
A party that follows the protocol is conforming, and a party that
does not is adversarial. A party‚Äôs principal is the assets escrowed at a
contract during the protocol execution. We use transfer and replace
interchangeably. First we describe the initial setup where Alice and
Bob first lock their principals using a hashlock. Throughout this
paper, the party who owns the preimage to the hashlock (Alice,the
initial owner of the option) is called a leader and the counterparty
(Bob) is called a follower. This terminology is similar to prior two-
party, HTLC-based cross-chain swap protocols [10, 17, 24].

Setup.
(1) Agreement. Alice and Bob agree on a time startLeader to
start the protocol, usually shortly after this agreement. Alice
and Bob agree on the amounts Assetùê¥, Assetùêµ forming their
principals, as well as the number of rounds ùëëùëá 1, where after
ùëá = startLeader + ùëëùëá ¬∑ Œî when Alice‚Äôs optionality on the
ùêµùê¥ contract expires. Alice generates a secret ùê¥1 and ùêª (ùê¥1)
which is used as swap_hashlock to redeem both principals
as in a typical two-party swap.

(2) Escrow. After the agreement achieved,

(a) Within Œî, Alice publishes the ùê¥ùêµ contract, escrowing
Assetùê¥, setting ùêª (ùê¥1) as the swap_hashlock and set ùëá + Œî
as the timeout for ùê¥ùêµ contract to expire.

(b) Once Bob sees Assetùê¥ is escrowed with the correct timeout,
before Œî elapses, Bob creates the ùêµùê¥ contract, escrowing
Assetùêµ, setting ùêª (ùê¥1) as the swap_hashlock and set ùëá as
the timeout for ùêµùê¥ contract to expire.

A swap option between Alice and Bob, where Alice has op-
tionality, is determined by Alice and Bob‚Äôs addresses, i.e. sender
and receiver in contracts, the swap_hashlock used for redemption,
and the timeout ùëá for refunds. To make the swap option trans-
ferable to Carol, we will need to replace Alice‚Äôs address with
Carol‚Äôs as sender in the ùê¥ùêµ contract and as receiver in the ùêµùê¥
contract, and replace the swap_hashlock with a new one gener-
ated by Carol. In short, we must atomically replace the fields
(ùê¥ùêµ.sender, ùêµùê¥.receiver, ùê¥ùêµ.swap_hashlock, ùêµùê¥.swap_hashlock).
The contracts export the following functions of interest.

‚Ä¢ Asset transfer related: the receiver calls claim() to withdraw
the asset in the contract. This function requires that the
preimage of the swap_hashlock is sent to claim() before the
contract expires. The sender calls ùëüùëí ùëì ùë¢ùëõùëë () to withdraw the
asset after the contract expires.

‚Ä¢ Option transfer related: mutateLockLeader () temporarily
freezes the assets and stores a replace_hashlock used to re-
place Alice‚Äôs role (the replacement between Carol and Alice
is also enforced by a hashlock mechanism) and the new
swap_hashlock if Carol successfully replaces Alice. The call
to replace() completes the replacement for Carol.

For example, consider the ùê¥ùêµ contract. The mutateLockLeader()
function freezes the assets, tentatively records the new sender
as candidate_sender, the new swap_hashlock for redemption, and
records a short-term replace_hashlock to be used by replace() to

1We inherit the requirement ùëëùëá ‚â• 4 from the standard two-party swap protocol.

finalize the replacement. Later, when replace() is called with the
secret matching the replace_hashlock, these tentative changes be-
come permanent. The replaceLeader () function has a timeout. If
that timeout expires, the internal revertLeader () function unfreezes
the assets, discards the tentative changes, and restores the contract‚Äôs
previous state.

The challenge is how to ensure the transfer is atomic on both
contracts. If the transfer is not atomic, Bob will be cheated if his
principal can be claimed but he cannot claim Alice‚Äôs principal. To
protect Bob, the contract allows Bob to inspect the changes and
ensure atomicity by relaying changes on one contract to another.

4.2 Transfer Leader Position
Our protocol will consist of 3 phases, each of which we describe in
turn:

(1) Mutate Lock Phase. Alice locks the assets on both contracts

and tentatively transfers her position to Carol.

(2) Consistency Phase. Bob makes sure the tentative changes on

both contracts are consistent.

(3) Replace/Revert Phase. Carol replaces Alice‚Äôs role or she gives

up and Alice gets her option back.

I: Mutate Lock Phase. Assume Alice and Carol agree on Assetùê∂ for
transferring her role to Carol at time startLeader, which is the start
time the following executions are based on2. Carol has secrets ùê∂1, ùê∂2
and generates hashlocks ùêª (ùê∂1), ùêª (ùê∂2). Let ùê∂ùëöùë†ùëî = [ùêª (ùê∂1), ùêª (ùê∂2)]
be the message Carol sends to specify that she would like to use
[replace_hashlock, swap_hashlock], respectively.

In this phase, Carol prepares tentative payment Assetùê∂ to Alice
to replace Alice‚Äôs role. Alice locks the ùê¥ùêµ and ùêµùê¥ contracts so that
the currently escrowed assets cannot be claimed from the original
swap.

(1) By startLeader + Œî, Carol creates the ùê∂ùê¥ contract, escrow-
ing Assetùê∂ , setting the swap_hashlock as ùêª (ùê∂1) for Alice to
redeem Assetùê∂ , and the timeout to be startLeader + 9Œî. She
also sends ùê∂ùëöùë†ùëî = [ùêª (ùê∂1), ùêª (ùê∂2)] to Alice.

(2) If the previous step succeeds, before Œî elapses, Alice
concurrently calls mutateLockLeader () on both ùê¥ùêµ and
ùêµùê¥ contracts, tentatively setting [replace_hashlock =
ùêª (ùê∂1), swap_hashlock = ùêª (ùê∂2)] to both contracts, and
setting candidate_sender = Carol.address on ùê¥ùêµ and
candidate_receiver = Carol.address on ùêµùê¥ contract. If Al-
ice is conforming, mutateLockLeader () should be called by
startLeader + 2Œî on both ùê¥ùêµ and ùêµùê¥.

II: Consistency Phase. It is possible that in the worst case, in
the Mutate Lock Phase, Alice could report inconsistent tentative
changes to ùê¥ùêµ, ùêµùê¥ by either mutating one contract but not the other,
or by reporting different hashlocks to each contract. Because the
two contracts cannot communicate, they have no way of knowing
what is happening on the other contract. One such example of an
attack is shown in Fig. 2.

Because of these attacks, in the Consistency Phase, Bob is given
a period to ensure both ùê¥ùêµ and ùêµùê¥ have the same changes. If one
of the contracts is not changed, then Bob forwards the change (by

2The protocol requires that startLeader ‚â§ ùëá ‚àí 9Œî. Otherwise, there may not be
sufficient time to complete the replacement.

Daniel Engel and Yingjie Xue

forwarding Alice‚Äôs signature on the contract she signed) to the
other contract. If both contracts are tentatively changed but the
changed are different, then Bob can call contestLeader () to prove
that Alice has lied and reported inconsistent changes signed by
Alice.

(1) If Bob sees that Alice only calls mutateLockLeader ()
then within Œî, Bob
call
on ùê¥ùêµ(ùêµùê¥),
set
on ùêµùê¥(ùê¥ùêµ)
mutateLockLeader ()
[replace_hashlock = ùêª (ùê∂1), swap_hashlock = ùêª (ùê∂2)]
by forwarding Alice‚Äôs signature.

should
and

contract

(2) If Bob sees Alice has called mutateLockLeader () on both ùê¥ùêµ
and ùêµùê¥ , but the changes are different, i.e. either one or more
hashlocks are not the same, or the new candidate sender does
not correspond to the new candidate receiver, then before a
Œî elapses, Bob should call contestLeader () on both contracts,
forwarding Alice‚Äôs signature on one contract to the other. In
this case, the tentative change will be reverted.

(3) If Bob sees Alice has called claim() with her secret
ùê¥1 on ùêµùê¥ to redeem Assetùêµ, and she also successfully
called mutateLockLeader () on ùê¥ùêµ, then Bob should call
contestLeader () on ùê¥ùêµ before a Œî elapses to revert the tenta-
tive change. Bob then calls claim() using ùê¥1 on ùê¥ùêµ to redeem
Assetùê¥.

Importantly, Bob is able to contest when either Alice reports in-
consistent mutation signatures between contracts or if she preemp-
tively reveals her swap secret. Bob‚Äôs ability to call contestLeader ()
ensures that he‚Äôs able to maintain his position in the original trade if
Alice deviates from the protocol by reporting inconsistent changes.

III: Replace/Revert Phase. After the Consistency Phase has ended,
in the Replace/Revert Phase, the swap either finalizes to one be-
tween Carol and Bob or reverts back to the original swap between
Alice and Bob. Once Carol sees consistent changes with no success-
ful contestLeader () calls by Bob, she calls replaceLeader () to make
herself the new leader of the swap. Figure 1 shows an execution of
the protocol where all parties are conforming. If Bob sees Carol only
call replaceLeader () on one contract, he uses her revealed secret ùê∂1
to finalize the replacement on the other contract.

(1) When Carol sees the tentative changes are the same on
both ùê¥ùêµ and ùêµùê¥ contract, and Bob is not able to contest
anymore on both contracts 3, then before Œî elapses, she calls
replaceLeader () on both contracts with her secret ùê∂1.
(2) If Bob sees Carol only called replaceLeader () on one contract
ùêµùê¥(ùê¥ùêµ) , then within Œî he calls replaceLeader () on ùê¥ùêµ(ùêµùê¥).
(3) If Carol gives up the replacement and does not
call
(ùëõùëúùë§ ‚àí
ùê¥ùêµ(ùêµùê¥).mutation.start_time > 6 ‚àó Œî), then the tenta-
tive changes can be reverted by revertLeader () causing the
assets to be unfrozen.

replaceLeader () when she

can,

i.e.

(4) If Alice sees ùê∂1 which is passed by replaceLeader (), then
within Œî she calls claim() to claim Assetùê∂ on the ùê∂ùê¥ contract.
The Replace/Revert Phase marks the point of the protocol where
Alice‚Äôs position is actually transferred to Carol. Before this phase,

3If Bob mutates a contract first, there is no contest window on that contract (He is
implicitly approving of the tentative changes). If Alice mutates a contract first, Bob is
given 2Œî to dispute that mutation.

4

Transferable Cross-Chain Options

Figure 1: In the figure, ùë• .ùêπùë¢ùëõùëêùë°ùëñùëúùëõ means party ùë• calls
ùêπùë¢ùëõùëêùë°ùëñùëúùëõ in the contract. E.g. ùê¥ùëôùëñùëêùëí.ùëÄùë¢ùë°ùëÜùë§ùëéùëùùê¥ùêµ means Alice
creates the swap contract ùê¥ùêµ and escrows her assets. The
blue arrow depicts contract ùê¥ùêµ and the green arrow depicts
contract ùêµùê¥ and the orange one depicts contract ùê∂ùê¥. The text
above each arrow depicts the state of the contract. For ex-
ample, ùë†ùë§ùëéùëù = ‚Ñéùê¥1, ùëüùëíùëêùëíùëñùë£ùëíùëü = ùê¥ùëôùëñùëêùëí, ùëöùë¢ùë°ùëéùë°ùëñùëõùëî = ùëì ùëéùëôùë†ùëí means
ùë†ùë§ùëéùëù_‚Ñéùëéùë†‚Ñéùëôùëúùëêùëò = ‚Ñéùê¥1 , and Alice can claim the asset in the
contract if she provides preimage of ‚Ñéùê¥1 . ùëüùëíùëùùëôùëéùëêùëí is short for
ùëüùëíùëùùëôùëéùëêùëí_‚Ñéùëéùë†‚Ñéùëôùëúùëêùëò.

Alice has only set up a tentative transfer to Carol. If Carol changes
her mind and gives up the replacement, the tentative swap be-
tween Carol and Bob can revert back to the original one be-
tween Alice and Bob by calling revertLeader (). Instead of call-
ing revertLeader () directly, Alice and Bob can alternatively call
mutateLockLeader (),refund (),or claim() at this point in the proto-
col since these will all automatically call revertLeader (). Alice would
do this if after an unsuccessful attempt to transfer her swap, she
wants to attempt another transfer, reclaim her escrowed funds, or
exercise the swap.

Timeouts. Timeouts are critical to guarantee the correctness of
our protocol. They were omitted in the earlier protocol descriptions
for simplicity. Here, we provide the timeouts we set in each step.
The ùêµùê¥ contract expires at time ùëá , the last time for the leader to
send her secret to redeem the principal. The ùê¥ùêµ contract expires at
time ùëá + Œî.

Denote the time when mutateLockLeader () is called on ùê¥ùêµ(ùêµùê¥)
contract as ùê¥ùêµ(ùêµùê¥).mutation.start_time. After the mutation starts
on any contract, Bob is given time 2Œî to contest Alice‚Äôs mutation:
ùê¥ùêµ(ùêµùê¥).contest.timeout = ùê¥ùêµ(ùêµùê¥).mutation.start_time + 2Œî.
When Bob is able to contest, and Bob has not called
mutateLockLeader () himself, Carol cannot call replaceLeader ().
the contest period elapses, Carol has 2Œî to call
After
replaceLeader (). Here we have ùê¥ùêµ(ùêµùê¥).replace.timeout_Carol =
ùê¥ùêµ(ùêµùê¥).mutation.start_time + 4Œî.

If Carol deviates and only calls replaceLeader () on one con-
tract, we allow Bob to call replaceLeader () on the another contract.
We give Bob 2Œî more than Carol to call replaceLeader (). That is,
ùê¥ùêµ(ùêµùê¥).replace.timeout_Bob = ùê¥ùêµ(ùêµùê¥).mutation.start_time + 6Œî.
We see that it takes 6Œî from the start of a mutateLockLeader ()
in the worst case. Thus,
call
ùê¥ùêµ(ùêµùê¥).mutation.start_time + 6Œî ‚â§ ùëá ‚àí Œî, which means
ùê¥ùêµ(ùêµùê¥).mutation.start_time ‚â§ ùëá ‚àí 7Œî.

to finalize a replacement

The last person that is able to call mutateLockLeader () is Bob. He
is given one more Œî than Alice on each contract to call this function
in case Alice decides to just call it on one contract. The deadline for
Alice to call mutateLockLeader () should be ùëá ‚àí 7Œî. The deadline
for Bob to call mutateLockLeader () should be ùëá ‚àí 6Œî. Consider the
case when Alice is adversarial by not calling mutateLockLeader ()
on ùêµùê¥ but does call it on ùê¥ùêµ by ùëá ‚àí 7Œî. If Bob is compliant, then he
calls mutateLockLeader () by ùëá ‚àí 6Œî on the ùêµùê¥ contract. Because we
require ùê¥ùêµ.mutation.start_time ‚â§ ùëá ‚àí 7Œî, Bob is guaranteed 6Œî to
a do a full replacement in the worst case. Conforming Carol‚Äôs safety
is also guaranteed since she can give up the replacement if she finds
there is not sufficient time to call replaceLeader () then claim(). In
that case, due to the timeout of the original swap, adversarial Alice
loses her opportunity to sell her position.

For CA edge, after Carol escrows Assetùê∂ , in the worst case it
takes 7Œî to complete the replacement, (Œî to start the mutation
and 6Œî to complete the replacement). After the replacement, it
takes one Œî for Alice to redeem. Thus, the timeout for ùê∂ùê¥ edge is
startLeader + 9Œî.

The reason why we have 2Œî for Bob to contest, and 2Œî more
than Carol to call replaceLeader () is that the start time of mutation
can be staggered by Œî on two contracts, which will be described in
detail in proof.

the contestLeader ()

time
4.2.1 An Optimization. Because of
in the worst case, Carol has to wait 2Œî after a
window,
mutateLockLeader () call to decide whether to release her secret
or not. We can speed up the process by adding an approveLeader ()
method. Instead of waiting for 2Œî even though Bob does not con-
test at all, once Bob sees Alice has made consistent mutations on
both edges, Bob can call approveLeader () to approve the pending
transfer. In other words, by calling approveLeader (), Bob gives up
the right to contest meaning Carol will not have to wait out the
contest window in order to call replaceLeader (). In that case, if Bob
cooperates, the transfer would be finalized sooner. If Bob doesn‚Äôt
cooperate, the transfer would be finalized later but not stoppable if
Alice and Carol are conforming.

This can be accomplished by adding to the ùê¥ùêµ(ùêµùê¥) contracts an
ùëéùëùùëùùëüùëúùë£ùëíùëë flag indicating whether Bob has given up his ability to
call contestLeader ().

Phases II-III are the only ones affected.
We add the following instruction to the Consistency Phase:

(1) Once Bob sees Alice has called mutateLockLeader () on both
ùê¥ùêµ and ùêµùê¥ with the same change, then before a Œî elapses,
Bob should call approveLeader () on both ùê¥ùêµ and ùêµùê¥.

and to the Replace/Revert Phase:

(1) If Carol sees Bob approved the tentative consistent changes
on both ùê¥ùêµ and ùêµùê¥, then before a Œî elapses, she calls
replaceLeader () on both ùê¥ùêµ and ùêµùê¥.

If in addition to conforming to the base protocol in Section 5.1,
Bob also executes the approve step shown previously, then we call
Bob altruistic. This just indicates that Bob is willing to speed up the
termination of the protocol even if it doesn‚Äôt necessarily change
his financial position.

5

AliceBobCarolNo ContestNo ContestDaniel Engel and Yingjie Xue

From this point on, we will use Protocol 4.2 to refer the protocol
in Section 4.2, Protocol 4.2.1 to the refer to the protocol 4.2.1 with
extra steps from Section 4.2.1, Protocol 4.3 to refer to the protocol
in Section 4.3, and Protocol 4.4 to refer to the protocol in Section
4.4.

4.4 Handling Multiple Candidates
When Alice decides to tentatively transfer her swap option to Carol,
it could be the case that Carol is intending to just grief Alice. In the
worst case, Alice will have her option locked for 6Œî by Carol that
simply doesn‚Äôt participate in the Replace/Revert Phase of Protocol
4.2.

To combat this, Alice might want to initiate several concurrent

transfers with multiple buyers at once.

A straightforward solution to this is, after Alice gets her po-
sition back from a failed transfer with ùê∂ùëéùëüùëúùëôùëñ , Alice can call
ùëöùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùêøùëíùëéùëëùëíùëü () again to indicate she wants to transfer her
option to a new option buyer ùê∂ùëéùëüùëúùëôùëñ+1. In the worst case, in this
protocol, Alice would spend 6Œî with her option locked for each
potential buyer who doesn‚Äôt comply.

One question then is, can we have Alice potentially transfer her
position to multiple buyers at the same time, or with less waiting
time than 6Œî in between each new buyer? Although we cannot
let Alice transfer her option to multiple buyers simultaneously,
we can create enough overlap between each of the potential to
reduce Alice‚Äôs waiting time for each potential buyer. The protocol
description below outlines how Alice is able to reduce her waiting
time for each potential buyer to 4Œî rather than 6Œî.

The main idea of the protocol is to use to run a concurrent version
of Protocol 4.2 for each potential buyer. Alice assigns each potential
buyer a ticket (sequence number). A shared counter is synchronized
between the ùê¥ùêµ and ùêµùê¥ contracts. The shared counter assigns an
ordering to each of the potential buyers to execute their respective
versions of Protocol 4.2. In this way, it serves as a first-come first-
serve mechanism for Alice to sell her swap option.

We will use ùê∂ùëéùëüùëúùëôùëñ to denote the buyer who is assigned the ùëñ-th
sequence number by Alice. On each contract ùê¥ùêµ and ùêµùê¥, each po-
tential buyer ùê∂ùëéùëüùëúùëôùëñ , will have their own associated state structure
ùë†ùë°ùëéùë°ùëíùëñ , similar to Protocol 4.2. This keeps track of the state relevant
to the 3 different phases from Protocol 4.2.

The protocol is defined as follows:

‚Ä¢ Initially counter on AB and BA contracts is initialized to 0.
‚Ä¢ For each potential buyer, Alice assigns a unique sequence
number seq (starting from 0 and growing by 1 for each as-
signment) to them, which represents that party‚Äôs position
in the queue for a tentative replacement. If Alice assigns the
same sequence number to different parties and sends both
of them to the AB/BA contracts, the conflict is resolved via
the Consistency Phase from the original Protocol 4.2. It is
the same as when Alice deviates by sending inconsistent
mutation transactions to both contracts, in which case Bob
contests and the tentative transfer is reverted.

‚Ä¢ Alice sends mutation transactions as in Protocol 4.2. The
main difference is that the mutation transactions now in-
clude a sequence number seq for the candidate replace-
ment. The ùëöùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùêøùëíùëéùëëùëíùëü (), ùëêùëúùëõùë°ùëíùë†ùë°ùêøùëíùëéùëëùëíùëü () functions

Figure 2: A protocol execution demonstrating why Bob
needs two more replaceLeader() rounds than Carol. If not,
then he lacks full Œî to call replaceLeader() on ùêµùê¥ after Carol
calls it on ùê¥ùêµ. Here we assume Alice has reported consistent
signatures in the Mutate Lock Phase but has reported them
a Œî apart. Colored blocks represent time periods when func-
tions can be called. The Leader suffix is excluded from the
function calls for simplicity.

4.3 Transfer Follower Position
We will now describe a protocol that allows Bob to transfer his
position in a swap with Alice, to a third-party David. The main
difference with this protocol and the previous one, is that Bob
cannot limit Alice‚Äôs optionality. Namely, he cannot unilaterally lock
the asset in the ùêµùê¥ contract since this would limit the optionality
Alice purchased. Effectively Alice must always be able to claim the
funds on ùêµùê¥ with her secret until the swap itself times out. This
weakening of the constraint that we had in the previous protocol,
allows for a much simpler protocol. It consists of 2 phases:

(1) Mutate Phase
(2) Replace/Revert Phase

the

(2) If

succeeds,

previous
revealed ùê¥1

I: Mutate Phase.
(1) Bob and David agree on Assetùê∑ at time startFollower, similar
to the replacing leader protocol. David creates ùê∑ùêµ contract,
escrowing Assetùê∑ , setting the swap_hashlock as ùêª (ùê∑1) for
Bob to redeem Assetùê∑ and the timeout be startFollower + 5Œî.
step
has
before Œî elapses, Bob concur-
not
and
rently
on
calls mutateLockFollower ()
ùê¥ùêµ
mutateLockFreeFollower () on ùêµùê¥ contracts,
tentatively
setting [replace_hashlock = ùêª (ùê∑1)] to both contracts,
and setting candidate_sender = David.address on ùêµùê¥
and candidate_receiver = David.address on ùê¥ùêµ. We use
mutateLockFreeFollower () because on the ùê¥ùêµ contract, this
mutation does not lock the asset on ùê¥ùêµ. This is necessary to
ensure Alice does not temporarily lose her optionality.

and Alice

II: Replace/Revert Lock Phase.
(1) If David sees Bob successfully call mutateLockFollower (),
mutateLockFreeFollower () on both ùê¥ùêµ and ùêµùê¥ respectively,
then within Œî he concurrently executes replaceFollower ()
with ùê∑1 on ùê¥ùêµ and ùêµùê¥ to replace Bob.

(2) If Bob sees David call replaceFollower () on either ùê¥ùêµ or ùêµùê¥,
within Œî he should call claim() on ùê∑ùêµ to claim Assetùê∑ .

6

Transferable Cross-Chain Options

all take this sequence number as parameters as part of the
mutation. If ùëêùëúùë¢ùëõùë°ùëíùëü == ùë†ùëíùëû, the transaction is accepted.
Otherwise, the transaction is rejected.
If Alice is conforming, counter should be synchronized on
AB/BA within Œî. If a tentative transfer is in progress, a new
mutation transaction with ùë†ùëíùëû == ùëêùëúùë¢ùëõùë°ùëíùëü + 1 will be ac-
cepted only if 4Œî has elapsed after the first mutation. A
mutate transaction with ùë†ùëíùëû == ùëêùëúùë¢ùëõùë°ùëíùëü can serve as muta-
tion transaction for a contest of the current tentative trans-
fer. After the tentative change is reverted, i.e. revertLeader()
is called, the counter is incremented by 1. This design can
be optimized by accepting the mutation transactions with
larger sequence numbers and store them in a queue for fu-
ture use. These can then take effect immediately after 4Œî
has elapsed after the current tentative mutation happens
and revertLeader() has been called. The reason why 4Œî is
sufficient interval between the execution of base protocols
for two potential buyers is that, after 4Œî, there is only 2Œî
left for the mutation to be reverted if the previous potential
buyer gives up. The later arriving buyer can use this window
to finish its consistency phase and after it ends, its replace
phase can start without waiting.

‚Ä¢ A mutation transaction can take effect (The corresponding
candidate can call replaceLeader() ) only after the previous
mutation transaction has expired, meaning it is reverted and
Alice regains the position. Then after that the new candidate
can execute Protocol 4.2 to replace Alice.

The protocol for transferring the follower position to multiple

candidates is similar.

5 SECURITY PROPERTIES AND PROOF
5.1 General Transfer Properties
Our leader and follower transfer protocols overlap in some proper-
ties they satisfy. We outline those properties here.

Recall that assets escrowed in the contracts are called principal.
The principals involved in the swap option are always Alice‚Äôs prin-
cipal and Bob‚Äôs principal. Here, the original option provider is Bob
(follower) and the option owner is Alice (leader). In the leader trans-
fer protocol and the follower transfer protocol, what is transferred
is a position in the swap option. If Alice transfers her position it is
to Carol, and Bob to David. We say one party owns a position in
an option if they are option owner (Alice/Carol): one can release a
secret, receiving Bob‚Äôs principal by relinquishing Alice‚Äôs, or let the
option expire and Alice‚Äôs principal is refunded to them, or option
provider (Bob/David): one provides the option owner the right, but
not obligation, for the exchange of Alice‚Äôs principal with Bob‚Äôs.

From now on, we call a leader/follower who wants to transfer
their position as position seller, and the one who wants to replace
them as position buyer.

‚Ä¢ Liveness: In a transfer of positions, if all parties are conform-
ing, then leader/follower transfers their position to a buyer
and the position seller gets proper payment from the buyer.
‚Ä¢ Transfer independence: A compliant position seller (leader/-
follower) transferring their position to another compliant
position buyer, can successfully transfer their position with-
out the cooperation of a third counterparty (follower/leader).

7

‚Ä¢ Non-blocking transfer with adversarial counterparty: If a com-
pliant position seller (leader/follower) is transferring their
position to another compliant position buyer, a third coun-
terparty (follower/leader) cannot interfere with the transfer.
‚Ä¢ Transfer atomicity: If a compliant position seller (leader/fol-
lower) loses their position to the buyer, then they receive
the expected principal from the position buyer.

‚Ä¢ No UNDERWATER for a conforming party (Safety): UNDER-
WATER means a party loses their outgoing principal without
getting their incoming principal. No UNDERWATER guaran-
tees a conforming party‚Äôs safety since it will never end up
with losing their principal without getting principals from
others.

Theorem 1. Protocol 4.2 and 4.3 satisfy No UNDERWATER for

Alice, Bob, Carol and David:

‚Ä¢ If Alice is conforming, then if she loses her principal, she either

gets Bob‚Äôs or Carol‚Äôs principal, or both.

‚Ä¢ If Bob is conforming, then if he loses his principal, he gets

Alice‚Äôs principal or David‚Äôs, or both.

‚Ä¢ If Carol is conforming, then if she loses her principal, she gets

Alice‚Äôs principal or Bob‚Äôs principal, or both.

‚Ä¢ If David is conforming, then if he loses his principal, he gets

Alice‚Äôs principal or Bob‚Äôs principal, or both.

Proof. See Appendix .2.2.

‚ñ°

5.2 Leader Transfer Properties
We first demonstrate how our leader transfer protocol satisfies the
general transfer properties from 5.1.

Because the detailed proofs of the following results are long and
similar to those that we will see for the follower transfer protocol
5.3, we omit them here. See the Appendix Section .2 for details.

Theorem 2. Protocol 4.2 satisfies liveness: If Alice, Bob, and Carol
are all conforming, then Alice gets Carol‚Äôs principal, Carol gets Alice‚Äôs
position, and Bob maintains his position.

Theorem 3. Protocol 4.2 satisfies transfer independence: Alice can

transfer her position to Carol without Bob‚Äôs participation.

Theorem 4. Protocol 4.2 satisfies non-blocking transfer: Alice can

transfer her position to Carol even if Bob is adversarial.

Theorem 5. Protocol 4.2 satisfies transfer atomicity: If Alice loses

her position in the swap, then she can claim Carol‚Äôs principal.

In addition to the properties from Section 5.1, it is desirable for

a leader transfer protocol to have one additional property.

Given two protocols ùëÉ, ùëÉ ‚Ä≤ that satisfy non-blocking transfer with
adversarial counterparty (Bob), Bob is called altruistic in ùëÉ ‚Ä≤ with
respect to ùëÉ if Bob conforming in ùëÉ ‚Ä≤ terminates faster than Bob
conforming in ùëÉ in executions where all parties are conforming.
Importantly, it is not necessary that Bob should be incentivized to
choose to follow ùëÉ ‚Ä≤ over ùëÉ.

When Alice and Carol are conforming, even though adversarial
Bob cannot block the transfer, Bob can delay the transfer for a
few rounds. The following next property we introduce is a slightly
stronger version of non-blocking property that is ideal for a leader
transfer protocol.

(1) Timely transfer with altruistic Bob: A protocol ùëÉ ‚Ä≤ satisfies this
property if there exists a protocol ùëÉ satisfying non-blocking
transfer with adversarial counterparty (Bob) where Bob is
altruistic in ùëÉ ‚Ä≤ with respect to ùëÉ.

Theorem 6. Protocol 4.2.1 satisfies timely transfer with altruistic

Bob.

Proof. Since Protocol 4.2 is non-blocking by Theorem 4, it is
enough to show that Bob is altruistic in Protocol 4.2.1 with respect
to Protocol 4.2. By assumption all parties are conforming. In both
protocols, Carol will have created ùëÄùë¢ùë°ùëÜùë§ùëéùëùùê∂ùê¥ by ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + Œî
and Alice will have called ùëöùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùêøùëíùëéùëëùëíùëü () on ùê¥ùêµ and ùêµùê¥ by
ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 2Œî. In Protocol 4.2.1 Bob now calls ùëéùëùùëùùëüùëúùë£ùëíùêøùëíùëéùëëùëíùëü ()
on ùëÄùë¢ùë°ùëÜùë§ùëéùëùùê¥ùêµ and ùëÄùë¢ùë°ùëÜùë§ùëéùëùùêµùê¥ by ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 3Œî. Thus the
Replace/Revert Phase for Protocol 4.2.1 begins because Bob skips
the contest phase. In Protocol 4.2, since Alice is compliant, her
signatures on ùëÄùë¢ùë°ùëÜùë§ùëéùëùùê¥ùêµ and ùëÄùë¢ùë°ùëÜùë§ùëéùëùùêµùê¥ are consistent. Thus
Bob won‚Äôt call ùëêùëúùëõùë°ùëíùë†ùë° () on ùëÄùë¢ùë°ùëÜùë§ùëéùëùùê¥ùêµ or ùëÄùë¢ùë°ùëÜùë§ùëéùëùùêµùê¥ during
this 2Œî Consistency Phase. Carol waits 2Œî after ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 2Œî.
In this case, the Replace/Revert Phase begins at ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 4Œî.
Thus Bob is altruistic in Protocol 4.2.1 with respect to Protocol
‚ñ°
4.2.

5.3 Follower Transfer Properties
We now demonstrate how our follower transfer protocol also satis-
fies the general transfer properties from Section 5.1.

Again, the proofs are included in the Appendix Section .2.

Theorem 7. Protocol 4.3 satisfies liveness: If Alice, Bob, and David
are all conforming, and Alice doesn‚Äôt reveal ùê¥1, then Bob gets David‚Äôs
principal, David gets Bob‚Äôs position, and Alice maintains her position.

Theorem 8. Protocol 4.3 satisfies transfer independence: Bob can

transfer his position to David without Alice‚Äôs participation.

Theorem 9. Protocol 4.3 satisfies non-blocking transfer: Bob can

transfer his position to David even if Alice is adversarial.

Note that Alice is not adversarial by choosing to reveal her
secret ùê¥1 since this just means she is exercising her option. This
is consistent with how she should behave in the original swap
protocol.

Theorem 10. Protocol 4.3 satisfies transfer atomicity: If Bob loses

his swap position, then he can claim David‚Äôs principal.

On top of the base properties described in Section 5.1, any pro-

tocol transferring Bob‚Äôs position should also be:

(1) Optionality preserving: If Alice is compliant, she never loses

her ability to exercise the original swap option.

Namely, it is unfair for Alice to temporarily lose her right to use

her option without her consent.

Theorem 11. Protocol 4.3 is optionality preserving.

Proof. It‚Äôs

enough to show that Alice

claim the principal on ùêµùê¥,
by timeout ùëá . The added functions
namely ùëöùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùêπùëüùëíùëíùêπùëúùëôùëôùëúùë§ùëíùëü (),ùëüùëíùëùùëôùëéùëêùëíùêπùëúùëôùëôùëúùë§ùëíùëü (),

can always
if she reveals her secret ùê¥1
from Protocol 4.3,
and

Daniel Engel and Yingjie Xue

ùëüùëíùë£ùëíùëüùë°ùêπùëúùëôùëôùëúùë§ùëíùëü () only modify the state of ùëì ùëúùëôùëôùëúùë§ùëíùëü _ùëöùë¢ùë°ùëéùë°ùëñùëúùëõ.
However, any call to ùëêùëôùëéùëñùëö() on ùêµùê¥ doesn‚Äôt depend on the state of
ùëì ùëúùëôùëôùëúùë§ùëíùëü _ùëöùë¢ùë°ùëéùë°ùëñùëúùëõ. Namely, any call to ùëêùëôùëéùëñùëö() is independent of
the state of the follower transfer protocol. So its enough that Alice
‚ñ°
reveal ùê¥1 before ùëá .

There is nothing preventing both Protocol 4.2 and Protocol 4.3 to
be run concurrently. That is, if Alice wants to transfer her position
to Carol, and Bob wants to transfer his position to David, they can
both do so simultaneously. This follows immediately from the fact
that the parts of the contracts managing the state for each individual
protocol are entirely disjoint and cannot affect each other.

5.4 Leader Transfer (Multiple Buyers)

Properties

Besides the general properties mentioned above, the protocol that
handles multiple candidate buyers (Protocol 4.4) satisfies the fol-
lowing unique properties.

‚Ä¢ First-come first-serve (FCFS): If Alice is conforming (the
buyer who tentatively pays to Alice earlier gets a smaller se-
quence number), then the earlier arriving buyer has priority
to replace Alice‚Äôs position.

‚Ä¢ Starvation freedom: If Alice is conforming and a conforming
buyer, say ùê∂ùëéùëüùëúùëô ùëó , gets a sequence number ùëó, then ùê∂ùëéùëüùëúùëô ùëó can
replace Alice‚Äôs position if she is conforming and all ùê∂ùëéùëüùëúùëôùëñ
where ùëñ < ùëó gives up the replacement.

Theorem 12. If Alice is conforming, the counter on both contracts

are synchronized with inconsistency for at most Œî.

Proof. The counter is initialized as 0 and it incremented only
after revertLeader() is enabled. The revertLeader() is enabled only
when 6Œî elapses after the start time of mutateLockLeader() being
called. Since the start time of mutateLock() on both contracts are
staggered by at most Œî, when the counter is incremented on one
contract, it can be incremented on another contract within Œî. ‚ñ°

Theorem 13. If Alice is conforming, Protocol 4.4 satisfies FCFS.

Proof. If Alice is conforming, she issues mutateLockLeader()
transactions with ascending sequence numbers to different poten-
tial buyers, in an arrive-earlier-smaller-sequence manner. For every
potential buyer, a base transfer protocol (Protocol 4.2) is run as
normal. Without loss of generality, at time ùë°, suppose on AB con-
tract the counter is ùëñ and on BA the counter is ùëó = ùëñ ‚àí 1. On AB,
ùê∂ùëéùëüùëúùëôùëñ has priority. By Theorem 12, we know the counter on ùêµùê¥
will become ùëñ within Œî and then ùê∂ùëéùëüùëúùëôùëñ has priority. The reason
why the counter is incremented from ùëó to ùëñ is that ùê∂ùëéùëüùëúùëô ùëó gives up
the replacement. Then we see on both contracts ùê∂ùëéùëüùëúùëôùëñ has priority.
It is obvious ùê∂ùëéùëüùëúùëôùëò where ùëò ‚â• ùëñ + 1 cannot start their replacement
unless ùê∂ùëéùëüùëúùëôùëñ gives up, i.e. the replacement phase ends and the mu-
tation is reverted, since the counter is ùëñ now. Therefore the protocol
‚ñ°
satisfies FCFS.

Theorem 14. If Alice is conforming, Protocol 4.4 is starvation free.

Proof. Similar to Proof 5.4, if Alice is conforming and a buyer
ùê∂ùëéùëüùëúùëô ùëó , gets a sequence number ùëó, then the base protocol for ùê∂ùëéùëüùëúùëô ùëó
can start underlying others‚Äô base protocols. If all ùê∂ùëéùëüùëúùëôùëñ where ùëñ < ùëó

8

Transferable Cross-Chain Options

gives up the replacement, then the counter is incremented to ùëó and
‚ñ°
then ùê∂ùëéùëüùëúùëô ùëó can call replaceLeader() to replace Alice.

6 RELATED WORK
Cross-chain options have their origin in cross-chain atomic swap
protocols. A cross-chain atomic swap enables two parties to ex-
change assets across different blockchains. An atomic swap is im-
plemented via hashed timelock contracts(HTLC)[17]. There are a
variety of protocols proposed [1, 8, 10, 24] and implemented [4, 6].
Herlihy et al. proposed protocols for atomic multi-party swaps [13]
and more general atomic cross-chain deals [14].

Several researchers [11, 12, 16, 25] have noted that most two-
party swap protocols effectively act as poorly-designed options [15],
because one party has the power to decide whether to go through
with the agreed-upon swap without compensation for its counter-
party.

A number of proposals [7, 11, 12, 16, 18, 23, 25] address the
problem of optionality in cross-chain atomic swaps by introducing
some form of premium payment, where a party that chooses not
to complete the swap pays a premium to the counterparty. Robin-
son [19] proposes to reduce the influence of optionality by splitting
each swap into a sequence of very small swaps. Han et al. [11]
quantified optionality unfairness in atomic swap using the Cox-
Ross-Rubinstein option pricing model [5], treating the atomic swap
as an American-style option. The Black-Scholes (BS) Model [3] can
be used to estimate the value of European-style options.

Liu [16] proposed an alternative approach where option
providers are are paid up-front for providing optionality, as in
the conventional options market. In this protocol, Alice explicitly
purchases an option from Bob by paying him an nonrefundable
premium. Tefagh et al. [21] proposed a similar protocol which en-
ables Alice to deposit her principal later than Bob. None of these
works have considered how to close an option owner‚Äôs position by
transferring that option to a third party.

There are protocols that allow blockchains to communicate
(cross-chain proofs), however they either rely on external third
parties [9] or their applicability requires the introduction of cen-
tralized services, modifications to existing software, and doesn‚Äôt
guarantee reliable message delivery [20].

7 REMARKS AND CONCLUSIONS
The transferable swap protocols presented here have certain limita-
tions. As described earlier, the protocols require multiple time-out
periods. If all parties are responsive, these timeouts should not affect
the performance of normal executions, but they could lead to long
worst-case executions. The protocols also include a ‚Äúhard timeout‚Äù
where Alice and Carol pause to give Bob a chance to object to a mal-
formed transfer. Bob can be paid an incentive to respond quickly,
but he could slow down (but not stop) the protocols execution.

The ability for Bob to be able to report inconsistent state changes
between multiple blockchains is integral to the design of our pro-
tocols. Adding such functionality was not necessary in simpler
cross-chain protocols like the two-party swap. In future work, we
hope to better understand how the complexity of a cross-chain deal
relates to the necessity of this consistency phase.

9

REFERENCES
[1] AtomicDEX. November, 2019.

First AtomicDEX Stress Test Success-
fully Completed. https://atomicdex.io/first-atomicdex-stress-test-successfully-
completed/.

[2] Philip A Bernstein, Vassos Hadzilacos, and Nathan Goodman. 1986. Concurrency
control and recovery in database systems. Addison-Wesley Longman Publishing
Co., Inc., Boston, MA, USA.

[3] Fischer Black and Myron Scholes. 2019. The pricing of options and corporate
liabilities. In World Scientific Reference on Contingent Claims Analysis in Corporate
Finance: Volume 1: Foundations of CCA and Equity Valuation. World Scientific,
3‚Äì21.

[4] Sean Bowe and Daira Hopwood. 2017. Hashed Time-Locked Contract transac-
tions. https://github.com/bitcoin/bips/blob/master/bip-0199.mediawiki. As of 9
January 2018.

[5] John C Cox, Stephen A Ross, and Mark Rubinstein. 1979. Option pricing: A

simplified approach. Journal of financial Economics 7, 3 (1979), 229‚Äì263.
[6] Decred. 2018. https://github.com/decred/atomicswap. As of 18 February 2021.
[7] Thomas Eizinger, Lloyd Fournier, and Phillip Hoenisch. 2018. The state
of atomic swaps. http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/
atomic-swaps/.

[8] Altcoin.io Exchange. October 2017.

The First Ethereum <>Bitcoin
Atomic Swap. https://blog.altcoin.io/the-first-ethereum-bitcoin-atomic-swap-
79befb8373a8. Altcoin.io Exchange.

[9] Christopher Goes. 2020. The interblockchain communication protocol: An

overview. arXiv preprint arXiv:2006.15918 (2020).

[10] Trey Griffith. July, 2018. Sparkswap: Trade across blockchains without cus-
tody risk. https://medium.com/sparkswap/sparkswap-trade-across-blockchans-
without-custody-risk-a6bfe08013e8.

[11] Runchao Han, Haoyu Lin, and Jiangshan Yu. 2019. On the optionality and
fairness of Atomic Swaps. In Proceedings of the 1st ACM Conference on Advances
in Financial Technologies. ACM, Zurich Switzerland, 62‚Äì75. https://doi.org/10.
1145/3318041.3355460

[12] Ethan Heilman, Sebastien Lipmann, and Sharon Goldberg. 2019. The arwen

trading protocols. https://www.arwen.io/whitepaper.pdf

[13] Maurice Herlihy. 2018. Atomic cross-chain swaps. In Proceedings of the 2018 ACM
symposium on principles of distributed computing (PODC ‚Äô18). ACM, New York,
NY, USA, 245‚Äì254. https://doi.org/10.1145/3212734.3212736 Number of pages:
10 Place: Egham, United Kingdom tex.acmid: 3212736.

[14] Maurice Herlihy, Barbara Liskov, and Liuba Shrira. 2019. Cross-Chain Deals and
Adversarial Commerce. Proc. VLDB Endow. 13, 2 (Oct. 2019), 100‚Äì113. https:
//doi.org/10.14778/3364324.3364326

[15] Desmond J. Higham. 2009. An introduction to financial option valuation: math-
ematics, stochastics and computation (4. printing ed.). Cambridge Univ. Press,
Cambridge.

[16] James A. Liu. 2020.

Atomic Swaptions: Cryptocurrency Derivatives.
arXiv:1807.08644 [cs, q-fin] (March 2020). http://arxiv.org/abs/1807.08644 arXiv:
1807.08644.

[17] Tier Nolan. May, 2013. Alt chains and atomic transfers. https://bitcointalk.org/

index.php?topic=193281.0. Bitcoin Forum.

[18] Komodo Platform. July,2019. Advanced blockchain technology, focused on free-
dom. https://docs.komodoplatform.com/basic-docs/start-here/core-technology-
discussions/introduction.html#note-on-changes-since-whitepaper-creation-
cr-2019.

[19] Dan Robinson. 2019. HTLCs Considered Harmful. http://diyhpl.us/wiki/

transcripts/stanford-blockchain-conference/2019/htlcs-considered-harmful/.

[20] Peter Robinson. 2021. Survey of crosschain communications protocols. Computer

Networks 200 (2021), 108488.

[21] Mojtaba Tefagh, Fateme Bagheri, Amirhossein Khajehpour, and Melika Abdi.
October, 2020. Capital-free Futures Arbitrage. https://doi.org/10.13140/RG.2.2.
31609.90729/1

[22] Jiahua Xu, Damien Ackerer, and Alevtina Dubovitskaya. 2021. A Game-Theoretic
Analysis of Cross-Chain Atomic Swaps with HTLCs. arXiv:2011.11325 [cs] (April
2021). http://arxiv.org/abs/2011.11325 arXiv: 2011.11325.

[23] Yingjie Xue and Maurice Herlihy. 2021. Hedging Against Sore Loser Attacks
in Cross-Chain Transactions. In ACM Symposium on Principles of Distributed
Computing.

[24] Jake Yocom-Piatt. September, 2017. On-Chain Atomic Swaps. https://blog.decred.

org/2017/09/20/On-Chain-Atomic-Swaps/. Decred Blog.

[25] ZmnSCPxj. 2018. An Argument For Single-Asset Lightning Network. https://lists.
linuxfoundation.org/pipermail/lightning-dev/2018-December/001752.html. As
of 10 January 2021.

APPENDIX
.1 Contracts

1
2
3
4
5

6
7
8
9

10

11
12
13
14
15

16
17
18
19
20
21
22
23

24
25
26
27
28
29
30

31
32
33
34
35
36
37
38
39
40
41
42
43
44

45
46
47
48
49
50
51
52
53
54
55
56
57
58

//Assume the following:

// now is the time the transaction is included in a block
// A clear() function on the Mutation struct that resets all

fields to default values

// A hash function H
// || denotes concatenation of inputs to a hash function
// A sig (digital signature) object with the following functions
// valid(address) -> bool, returns true if valid signature by

address

// msg() -> [hash], returns an array of hashlocks if the
signature signed such a message, null otherwise

contract MutSwapAB{

struct FollowerMutation{

//Signature by follower to allow candidate to take its

position

Sig voucher;
//Candidate party to replace follower
address candidate_receiver;
//Hashlock used to replace follower
uint replace_hash_lock;
//Time mutation begins
uint start_time;
//Flag for freezing asset when a tentative replacement is

happening

bool mutating;
//Controls whether asset is locked or not during mutation
bool can_lock_asset;

}

struct LeaderMutation{

//Signature by follower to allow candidate to take its

position

Sig voucher;
//Candidate party to replace follower
address candidate_sender;
//Party who called mutateLockLeader
address mutator;
//Hashlock used to replace follower
uint replace_hash_lock;
//Hashlock for exercising option
uint swap_hash_lock;
//Time mutation begins
uint start_time;
//Used for optimistic execution of protocol
bool approved;
//Flag for freezing asset when a tentative replacement is

happening

bool mutating;
//Controls whether asset is locked or not during mutation
bool can_lock_asset;

}

//State information for base swap protocol
Asset asset; //Reference to preferred token contract
address sender; //Current sender of escrowed funds
address receiver; //Current receiver of escrowed funds
address leader; //Leader of the original swap protocol
address follower; //Follower of the original swap protocol
uint swap_hash_lock; //Hashlock of the swap protocol
uint T_AB; //Timeout for locked asset

10

59

60
61
62
63
64
65
66
67
68
69
70

71

72

73
74
75
76
77
78
79
80
81
82
83
84
85

86
87
88
89
90
91
92
93

94
95
96
97
98
99
100
101

102
103
104
105
106
107
108
109
110
111

112
113

114
115
116
117

Daniel Engel and Yingjie Xue

uint delta = 10 minutes; //Assumed worst case transaction

inclusion time (Is arbitrary)

//State info associated with mutable leader position
LeaderMutation leader_mutation;

//State info associated with mutable follower position
FollowerMutation follower_mutation;

//Controls whether follower/leader positions can be changed
bool mutable;

function MutSwapAB(Asset _asset,uint start,uint dT,address

_sender,address _receiver,uint _swap_hash_lock,address
_leader,address _follower,bool _mutable){

require(msg.sender == _sender); //Sender can only escrow

their own funds

require(leader != follower); //Leader and follower should

be distinct

require(leader == _sender);
require(follower == _receiver);

this.mutable = _mutable;

//Inital mutation states
leader_mutation.mutating = false;
leader_mutation.approved = false;
follower_mutation.mutating = false;

sender = _sender;
receiver = _receiver;
swap_hash_lock = _swap_hash_lock; //Hashlock for the

initial swap
leader = _leader;
follower = _follower;
asset = _asset;
asset.send(address(this));
T_AB = start + (dT+1)*delta; //Sender is Alice

if(mutable){

//For AB contract, asset is actively locked during

leader and follower transfer
leader_mutation.can_lock_asset = true;
follower_mutation.can_lock_asset = true;

}

}

function claim(string secret){

//If a previous mutation lock was never completed, revert

to original swap

if(mutable){

if(leader_mutation.mutating){

revertLeader();

}
if(follower_mutation.mutating){

revertFollower();

}

}

require(msg.sender == receiver.id); //Only receiver can

call claim

require(now <= T_AB); //Must be before timeout
require(H(secret) == swap_hash_lock); //Claim conditional

on revealing secret

asset.send(receiver);

}

function refund(){

Transferable Cross-Chain Options

118
119

120
121
122
123
124
125
126
127
128
129

130
131
132
133
134

135
136
137

138
139
140
141
142

143

144

145
146
147

148
149
150
151

152

153
154

155
156
157
158
159

160
161
162

163
164
165

166
167
168
169
170
171

//If a previous mutation lock was never completed, revert

to original swap

if(mutable){

if(leader_mutation.mutating){

revertLeader();

}
if(follower_mutation.mutating){

revertFollower();

}

}

require(msg.sender == sender); //Only sender can call

refund

require(now > T_AB); //After lock has timed out
asset.send(sender);

}

function mutateLockLeader(Sig sig,address _candidate_sender,

uint _replace_hash_lock,uint _swap_hash_lock){

require(mutable);

//If a previous mutation lock is stale, then call revert
to allow for a new mutation lock to be made

if(leader_mutation.mutating){

revertLeader();

}

require(!leader_mutation.mutating); //Only one

mutate_lock at a time

require(msg.sender == sender || msg.sender == receiver);

//Only sender or receiver can mutate

if(msg.sender == leader){ //Alice has less time to call

mutateLock

require(T_AB >= now + 8*delta);

}else if(msg.sender == follower){

//Bob is given more time to call mutateLock in

response to Alice

require(T_AB >= now + 7*delta);

}

require(sig.valid(leader)); //Requres Alice's sig of

Carol's hashlocks

require(sig.msg() == [_replace_hash_lock,_swap_hash_lock
]); //The msg has to just be the candidate's
hashlocks

leader_mutating.mutating = true;
leader_mutating.voucher = sig; //Proof that candidate was

approved

leader_mutating.candidate_sender = _candidate;
leader_mutating.mutator = msg.sender;
leader_mutating.replace_hash_lock = _replace_hash_lock;
leader_mutating.swap_hash_lock = _swap_hash_lock;
leader_mutating.start_time = now; //Used for flexible

timeouts in the transfer

}

function mutateLockFollower(Sig sig,address

_candidate_receiver, uint _replace_hash_lock){

require(mutable);

//If a previous mutation lock is stale, then call revert
to allow for a new mutation lock to be made

if(follower_mutation.mutating){

revertFollower();

}

require(msg.sender == follower); //Only Bob can call
require(!follower_mutation.mutating);

172

173
174
175

176
177
178

179

180
181

182
183
184
185
186
187
188
189
190

191

192
193

194
195

196
197
198
199

200

201

202

203
204
205
206
207
208
209

210
211
212
213
214
215
216
217
218
219
220

11

require(follower_mutation.lock_asset); //Only can call

mutateLockFollower on AB contract

require(sig.valid(follower)); //Bob's valid signature
require(sig.msg() == [_replace_hash_lock]);
require(T_AB >= now + 3*delta); //Need enough time for

David to call claim

follower_mutation.mutating = true;
follower_mutation.voucher = sig; //Proof that candidate

was approved by previous owner of the position

follower_mutation.candidate_receiver =

_candidate_receiver;

follower_mutation.replace_hash_lock = _replace_hash_lock;
follower_mutation.start_time = now; //Used for flexible

timeouts in the transfer

}

function replaceLeader(string secret){

require(mutable);
require(leader_mutation.mutating);
bool candidate_round = false;
bool follower_round = false;

//If Bob mutated, can skip contesting phases since he is

implicitly approving of the signature he called
mutateLock with

if(leader_mutation.mutator == follower || (

leader_mutation.mutator == leader &&
leader_mutation.approved)){ //Can immediately call
replace once Bob has mutated

//Carol can replace once Bob has called mutate
candidate_round = (msg.sender == leader_mutation.
candidate_sender) && (4*delta >= now -
leader_mutation.start_time > 0);

//Bob can call replace
follower_round = (msg.sender == follower) && (6*delta
>= now - leader_mutation.start_time > 0);

}
else{ //Contesting (pessimistic case)

//Carol can replace in round right after last chance

at contesting

candidate_round = (msg.sender == leader_mutation.
candidate_sender) && (4*delta >= now -
leader_mutation.start_time > 2*delta);
//Bob can replace in the 3 rounds right after last

chance at mutating round

follower_round = (msg.sender == follower) && (6*delta
>= now - leader_mutation.start_time>0);

}

require(candidate_round || follower_round);
require(H(secret) == leader_mutation.replace_hash_lock);

sender = leader_mutation.candidate_sender; //Carol takes

refund optionality from Alice
swap_hash_lock = mutation.swap_hash_lock;

leader_mutation.approved = false;
leader_mutation.mutating = false;
leader_mutation.mutation.clear();

}

//If no contesting has occurred, transfer can be complete
function replaceFollower(string secret){

require(mutable);
require(follower_mutation.mutating);

221

222
223

224
225

226
227
228
229
230
231

232

233
234
235
236

237

238

239

240

241

242

243

244
245
246
247
248
249
250
251

252
253
254
255

256

257

258
259
260
261
262

263

264
265
266
267

require(2*delta >= now - follower_mutation.start_time >

0); //2 rounds given for replacement

require(H(secret) == follower_mutation.replace_hash_lock)

;

receiever = follower_mutatation.candidate_receiver; //

David takes refund optionality from Bob

follower_mutatation.clear();
follower_mutation.mutating = false;

}

//Contest if transferring party tries to transfer to two

different parties simultaneously

//Note this method only does something if it can be proved

that Alice lied

//This method can't do anything if Alice is honest
function contestLeader(Sig sig,string secret){

require(mutable);
require(msg.sender == follower); //Only allow Bob to call

this

require(leader_mutation.mutating); //Can only contest a

mutation if one has occured

require(!leader_mutation.approved); //Cannot contest

after approval

require(leader_mutation.mutator == leader); //Can only
contest a mutation when Alice called it, not Bob

require(2*delta >= now - leader_mutation.start_time > 0);

//Can contest only in the 2 rounds after mutation

//Can contest if Alice creates two inconsistent

signatures or tries to reveal preimage of hashlock
too early

require(sig.valid(leader) || H(secret) == swap_hash_lock)

; //Make sure Alice actually signed the sig
if(sig != leader_mutation.voucher || H(secret) ==
swap_hash_lock){ //Checks if Alice reported
inconsistent sigs

leader_mutation.clear();
leader_mutation.mutating = false;

}

}

//Issue is really in the sequential consistent case
//Bob can call approve in any next two rounds after a

mutation

function approveLeader(){

require(mutable);
require(msg.sender == follower); //Only Bob can approve
require(leader_mutation.mutating); //Can only approve

after a mutation has begun

require(leader_mutation.mutator == leader); //Can only

call approve when Alice was the one who called
mutate

require(2*delta >= now - leader_mutation.start_time > 0);

//Can approve only in the 2 rounds after mutation

leader_mutation.approved = true;

}

//If replacement doesn't happen quickly enough, can revert

back to the old swap

//Isn't called directly in order to save an extra round of

the protocol
function revertLeader(){
require(mutable);
require(leader_mutation.mutating);
require(now - leader_mutation.start_time > 6*delta);

Daniel Engel and Yingjie Xue

leader_mutation.approved = false;
leader_mutation.mutating = false;
leader_mutation.clear();

}

//If replacement doesn't happen quickly enough, can revert

back to the old swap

//Isn't called directly in order to save an extra round of

the protocol

function revertFollower(){
require(mutable);
require(follower_mutation.mutating);
require(now - follower_mutation.start_time > 2*delta);

follower_mutation.mutating = false;
follower_mutation.clear();

}

}

//Assume the following:

// now is the time the transaction is included in a block
// A clear() function on the Mutation struct that resets all

fields to default values

// A hash function H
// || denotes concatenation of inputs to a hash function
// A sig (digital signature) object with the following functions
// valid(address) -> bool, returns true if valid signature by

address

// msg() -> [hash], returns an array of hashlocks if the
signature signed such a message, null otherwise

contract MutSwapBA{

struct FollowerMutation{

//Signature by follower to allow candidate to take its

position

Sig voucher;
//Candidate party to replace follower
address candidate_sender;
//Hashlock used to replace follower
uint replace_hash_lock;
//Time mutation begins
uint start_time;
//Flag for freezing asset when a tentative replacement is

happening

bool mutating;
//Controls whether asset is locked or not during mutation
bool can_lock_asset;

}

struct LeaderMutation{

//Signature by follower to allow candidate to take its

position

Sig voucher;
//Candidate party to replace follower
address candidate_receiver;
//Party who called mutateLockLeader
address mutator;
//Hashlock used to replace follower
uint replace_hash_lock;
//Hashlock for exercising option
uint swap_hash_lock;
//Time mutation begins
uint start_time;
//Used for optimistic execution of protocol

268
269
270
271
272
273
274

275

276
277
278
279
280
281
282
283
284
285

1
2
3
4
5

6
7
8
9

10

11
12
13
14
15

16
17
18
19
20
21
22
23

24
25
26
27
28
29
30

31
32
33
34
35
36
37
38
39
40
41
42

12

Transferable Cross-Chain Options

43
44

45
46
47
48
49
50
51
52
53
54
55
56
57
58
59

60
61
62
63
64
65
66
67
68
69
70

71

72

73
74
75
76
77
78
79
80
81
82
83
84
85

86
87
88
89
90
91
92
93
94

95
96
97
98
99
100

101

bool approved;
//Flag for freezing asset when a tentative replacement is

happening

bool mutating;
//Controls whether asset is locked or not during mutation
bool can_lock_asset;

}

//State information for base swap protocol
Asset asset; //Reference to preferred token contract
address sender; //Current sender of escrowed funds
address receiver; //Current receiver of escrowed funds
address leader; //Leader of the original swap protocol
address follower; //Follower of the original swap protocol
uint swap_hash_lock; //Hashlock of the swap protocol
uint T_BA; //Timeout for locked asset
uint delta = 10 minutes; //Assumed worst case transaction

inclusion time

//State info associated with mutable leader position
LeaderMutation leader_mutation;

//State info associated with mutable follower position
FollowerMutation follower_mutation;

//Controls whether follower/leader positions can be changed
bool mutable;

function MutSwapBA(Asset _asset,uint start,uint dT,address

_sender,address _receiver,uint _swap_hash_lock,address
_leader,address _follower,bool _mutable){

require(msg.sender == _sender); //Sender can only escrow

their own funds

require(leader != follower); //Leader and follower should

be distinct

require(follower == _sender);
require(leader == _receiver);

this.mutable = _mutable;

//Inital mutation states
leader_mutation.mutating = false;
leader_mutation.approved = false;
follower_mutation.mutating = false;

sender = _sender;
receiver = _receiver;
swap_hash_lock = _swap_hash_lock; //Hashlock for the

initial swap
leader = _leader;
follower = _follower;
asset = _asset;
asset.send(address(this));
T_BA = start + dT*delta;

if(mutable){

leader_mutation.lock_asset = true;
follower_mutatation.lock_asset = false; //Prevents

Bob from denying Alice her optionality by
locking her asset

}

}

function claim(string secret){

//If a previous mutation lock was never completed, revert

to original swap

if(mutable){

13

102
103
104
105
106
107

108
109

110
111
112
113
114
115

116
117
118
119
120
121
122
123
124
125

126
127
128
129
130

131
132
133

134
135
136
137
138

139

140

141
142
143

144
145
146
147

148

149
150

151
152
153
154
155

if(leader_mutation.mutating){

revertLeader();

}

}

require(msg.sender == receiver.id); //Only receiver can

call claim

require(now <= T_BA); //Must be before timeout
require(H(secret) == swap_hash_lock); //Claim conditional

on revealing secret

asset.send(receiver);

}

function refund(){

//If a previous mutation lock was never completed, revert

to original swap

if(mutable){

if(leader_mutation.mutating){

revertLeader();

}
if(follower_mutation.mutating){

revertFollower();

}

}

require(msg.sender == sender); //Only sender can call

refund

require(now > T_BA); //After lock has timed out
asset.send(sender);

}

function mutateLockLeader(Sig sig,address _candidate_receiver
, uint _replace_hash_lock,uint _swap_hash_lock){

require(mutable);

//If a previous mutation lock is stale, then call revert
to allow for a new mutation lock to be made

if(leader_mutation.mutating){

revertLeader();

}

require(!leader_mutation.mutating); //Only one

mutate_lock at a time

require(msg.sender == sender || msg.sender == receiver);

//Only sender or receiver can mutate

if(msg.sender == leader){ //Alice has less time to call

mutateLock

require(T_BA >= now + 7*delta);

}else if(msg.sender == follower){

//Bob is given more time to call mutateLock in

response to Alice

require(T_BA >= now + 6*delta);

}

require(sig.valid(leader)); //Requres Alice's sig of

Carol's hashlocks

require(sig.msg() == [_replace_hash_lock,_swap_hash_lock
]); //The msg has to just be the candidate's
hashlocks

leader_mutating.mutating = true;
leader_mutating.voucher = sig; //Proof that candidate was

approved

leader_mutating.candidate = _candidate_receiver;
leader_mutating.mutator = msg.sender;
leader_mutating.replace_hash_lock = _replace_hash_lock;
leader_mutating.swap_hash_lock = _swap_hash_lock;
leader_mutating.start_time = now; //Used for flexible

timeouts in the transfer

156
157
158
159

160

161
162
163

164
165
166
167
168

169
170
171

172
173
174

175
176
177
178
179
180
181
182
183

184

185
186

187
188

189
190
191
192

193

194

195

196
197
198
199
200
201
202

203
204

}

//Provides similar functionality to mutateLockLeader but

doesn't lock the escrowed resource from being locked

function mutateLockFreeFollower(Sig sig,address

_candidate_sender,uint _replace_hash_lock){

require(mutable);

require(msg.sender == follower); //Only Bob can call

attest

require(!follower_mutation.mutating);
require(!follower_mutation.lock_asset);
require(sig.valid(follower)); //Bob's valid signature
require(sig.msg() == [_replace_hash_lock]);
require(T_BA >= now + 2*delta); //Need enough time for

David to call claim

follower_mutation.mutating = true;
follower_mutation.voucher = sig; //Proof that candidate

was approved

follower_mutation.candidate_receiver = _candidate_sender;
follower_mutation.replace_hash_lock = _replace_hash_lock;
follower_mutation.start_time = now; //Used for flexible

timeouts in the transfer

}

function replaceLeader(string secret){

require(mutable);
require(leader_mutation.mutating);
bool candidate_round = false;
bool follower_round = false;

//If Bob mutated, can skip contesting phases since he is

implicitly approving of the signature he called
mutateLock with

if(leader_mutation.mutator == follower || (

leader_mutation.mutator == leader &&
leader_mutation.approved)){ //Can immediately call
replace once Bob has mutated

//Carol can replace once Bob has called mutate
candidate_round = (msg.sender == leader_mutation.

candidate_receiver) && (4*delta >= now -
leader_mutation.start_time > 0);

//Bob can call replace
follower_round = (msg.sender == follower) && (6*delta
>= now - leader_mutation.start_time > 0);

}
else{ //Contesting (pessimistic case)

//Carol can replace in round right after last chance

at contesting

candidate_round = (msg.sender == leader_mutation.

candidate_receiver) && (4*delta >= now -
leader_mutation.start_time > 2*delta);
//Bob can replace in the 3 rounds right after last

chance at mutating round

follower_round = (msg.sender == follower) && (6*delta
>= now - leader_mutation.start_time > 0);

}

require(candidate_round || follower_round);
require(H(secret) == leader_mutation.replace_hash_lock);

receiever = leader_mutation.candidate_receiver; //Carol

takes receiving optionality from Alice

swap_hash_lock = mutation.swap_hash_lock;

205
206
207
208
209
210
211
212
213
214

215
216

217
218

219
220
221
222
223
224

225

226
227
228
229

230

231

232

233

234

235

236

237
238
239
240
241
242
243
244

245
246
247
248

249

250

251
252
253

14

Daniel Engel and Yingjie Xue

leader_mutation.approved = false;
leader_mutation.mutating = false;
leader_mutation.mutation.clear();

}

//If no contesting has occurred, transfer can be complete
function replaceFollower(string secret){

require(mutable);
require(follower_mutation.mutating);
require(2*delta >= now - follower_mutation.start_time >

0); //2 rounds given for replacement

require(H(secret) == follower_mutation.replace_hash_lock)

;

sender = follower_mutatation.candidate_sender; //David

takes refund optionality from Bob

follower_mutatation.clear();
follower_mutation.mutating = false;

}

//Contest if transferring party tries to transfer to two

different parties simultaneously

//Note this method only does something if it can be proved

that Alice lied

//This method can't do anything if Alice is honest
function contestLeader(Sig sig,string secret){

require(mutable);
require(msg.sender == follower); //Only allow Bob to call

this

require(leader_mutation.mutating); //Can only contest a

mutation if one has occured

require(!leader_mutation.approved); //Cannot contest

after approval

require(leader_mutation.mutator == leader); //Can only
contest a mutation when Alice called it, not Bob

require(2*delta >= now - leader_mutation.start_time > 0);

//Can contest only in the 2 rounds after mutation

//Can contest if Alice creates two inconsistent

signatures or tries to reveal preimage of hashlock
too early

require(sig.valid(leader) || H(secret) == swap_hash_lock)

;

if(sig != leader_mutation.voucher || H(secret) ==
swap_hash_lock){ //Checks if Alice reported
inconsistent sigs

leader_mutation.clear();
leader_mutation.mutating = false;

}

}

//Issue is really in the sequential consistent case
//Bob can call approve in any next two rounds after a

mutation

function approveLeader(){
require(mutable);
require(msg.sender == follower); //Only Bob can approve
require(leader_mutation.mutating); //Can only approve

after a mutation has begun

require(leader_mutation.mutator == leader); //Can only

call approve when Alice was the one who called
mutate

require(2*delta >= now - leader_mutation.start_time > 0);

//Can approve only in the 2 rounds after mutation

leader_mutation.approved = true;

}

Transferable Cross-Chain Options

254
255

256

257
258
259
260
261
262
263
264
265
266
267

268

269
270
271
272
273
274
275
276
277
278

//If replacement doesn't happen quickly enough, can revert

back to the old swap

//Isn't called directly in order to save an extra round of

the protocol
function revertLeader(){
require(mutable);
require(leader_mutation.mutating);
require(now - leader_mutation.start_time > 6*delta);

leader_mutation.approved = false;
leader_mutation.mutating = false;
leader_mutation.clear();

}

//If replacement doesn't happen quickly enough, can revert

back to the old swap

//Isn't called directly in order to save an extra round of

the protocol

function revertFollower(){
require(mutable);
require(follower_mutation.mutating);
require(now - follower_mutation.start_time > 2*delta);

follower_mutation.mutating = false;
follower_mutation.clear();

}

}

.2 Proofs
.2.1 Misc Proofs. First, we provide proofs for the properties of the
leader transfer protocol.

Lemma 15. If Alice and Carol are both conforming in the Mu-
tate Lock Phase, then both ùê¥ùêµ and ùêµùê¥ are mutate locked with
(ùêª (ùê∂1), ùêª (ùê∂2)) by ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 2Œî.

Proof. If Carol is conforming, she escrows her principal to Al-
ice by time ùëÖ + Œî. Alice, after observing the creation of ùê∂ùê¥, will
then call mutateLockLeader() within a Œî on both ùê¥ùêµ and ùêµùê¥, pass-
ing (ùêª (ùê∂1), ùêª (ùê∂2)) as the transfer hashlock and the new swap
hashlock. For any contract, if it is not mutate locked, then the mu-
tateLockLeader() sent by Alice can be included in the blockchain
by ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 2Œî. If the mutateLockLeader() transaction sent
by Alice can not be included in the blockchain due to some-
one else calling it first, it must be that Bob called mutateLock-
Leader() on the contract with (ùêª (ùê∂1), ùêª (ùê∂2)) before her. In any
case, within ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 2Œî, both contracts are mutate locked by
‚ñ°
(ùêª (ùê∂1), ùêª (ùê∂2)).

If there is a successfully call to mutateLockLeader() on ùê¥ùêµ with
(ùêª (ùê∂1), ùêª (ùê∂2)), let the first time that this transaction is called be
ùë°ùê¥ùêµ. Similarly, let ùë°ùêµùê¥ be the first time mutateLockLeader() is called
on ùêµùê¥ with (ùêª (ùê∂1), ùêª (ùê∂2)).

Theorem 2. Protocol 4.2 satisfies liveness: If Alice, Bob, and Carol
are all conforming, then Alice gets Carol‚Äôs principal, Carol gets Alice‚Äôs
position, and Bob maintains his position.

Proof. If Alice starts the transfer procedure, and all parties are
conforming, then Carol owns the option and paid her principal to
Alice. The argument is as follows.

15

By Lemma 15, we know mutateLockLeader() has been called by
ùëÖ + 2Œî on ùê¥ùêµ and ùêµùê¥ with (ùêª (ùê∂1), ùêª (ùê∂2)). After max{ùë°ùê¥ùêµ, ùë°ùêµùê¥} +
2Œî ‚â§ ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 4Œî, Carol will know that Bob cannot success-
fully call contest() on either ùê¥ùêµ or ùêµùê¥. Carol then releases her secret
ùê∂1 to ùê¥ùêµ and ùêµùê¥ by max{ùë°ùê¥ùêµ, ùë°ùêµùê¥} + 3Œî ‚â§ ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 5Œî. Then
ùê¥ùêµ and ùêµùê¥ are transferred to a new state where the swap hashlock
is ùêª (ùê∂2), the sender of ùê¥ùêµ contract becomes Carol, and the receiver
of ùêµùê¥ contract becomes Carol. At this point, these contracts can be
more appropriately renamed as as ùê∂ùêµ and ùêµùê∂ respectively. That is
to say, Carol has set up a swap with Bob using her swap hashlock
ùêª (ùê∂2). Carol now owns the option. Because the timeout on ùê∂ùê¥ is
ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 10Œî, Alice can use ùê∂1 to redeem Carol‚Äôs principal on
‚ñ°
ùê∂ùê¥ by revealing ùê∂1 by ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 6Œî. .

Theorem 3. Protocol 4.2 satisfies transfer independence: Alice can

transfer her position to Carol without Bob‚Äôs participation.

Proof. If Alice and Carol are both conforming, then by Lemma
15, we know mutateLock() will be called with (ùêª (ùê∂1), ùêª (ùê∂2)) on
both ùê¥ùêµ and ùêµùê¥ by ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 2Œî. In the worst case, after
max{ùë°ùê¥ùêµ, ùë°ùêµùê¥} + 2Œî, Carol should release ùê∂1 to replace Alice on
both ùê¥ùêµ and ùêµùê¥. This results in the replacement of the old swap
hashlock ùêª (ùê¥1) with ùêª (ùê∂2). Bob does not have to call any func-
tions to help Carol replace Alice‚Äôs role. Thus, conforming Alice and
‚ñ°
Carol can trade without Bob‚Äôs cooperation.

We have proven that conforming Alice and Carol can trade the
option without Bob cooperating. Now we look at this property
from another perspective. Can Bob actively prevent Alice selling
her option to Carol? The following result guarantees Bob cannot
block Alice and Carol.

Theorem 4. Protocol 4.2 satisfies non-blocking transfer: Alice can

transfer her position to Carol even if Bob is adversarial.

Proof. The only way for Bob to block the transfer of an option
is to contest. To contest, Bob needs to show a different mutation
signed by Alice or by showing Alice‚Äôs secret to the old hashlock.
As long as Alice is conforming to the protocol and does not collude
with Bob, which is the case in this context, an adversarial Bob
‚ñ°
cannot forge her signature and successfully call contest().

Theorem 5. Protocol 4.2 satisfies transfer atomicity: If Alice loses

her position in the swap, then she can claim Carol‚Äôs principal.

Proof. Conforming Carol only loses her principal if she releases
her secret ùê∂1. She only releases her secret ùê∂1 after she sees both
ùê¥ùêµ and ùêµùê¥ are both mutate locked by (ùêª (ùê∂1), ùêª (ùê∂2)) and at least
one of the conditions are met: (1)Bob has approved both ùê¥ùêµ and
ùêµùê¥; (2) both of his contest windows on ùê¥ùêµ and ùêµùê¥ have ended.
Bob can no longer contest this result either due to timeout of his
contesting window or Bob has approved this result. Then when
Carol sends her secret ùê∂1 to both ùê¥ùêµ and ùêµùê¥, she replaces Alice‚Äôs
role and changes the swap hashlock to ùêª (ùê∂2) thus she owns the
option.

Conforming Alice loses her option only if Carol releases her
secret ùê∂1 on some contract. We know by Lemma 15 that in the
worst case mutateLockLeader() will be called on ùê¥ùêµ and ùêµùê¥ by
ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 2Œî. Thus, the latest time any party can call replace()
is. ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 8Œî. So if Alice loses her option there must have

been a replace() call by ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 8Œî. Since ùê∂ùê¥ has timeout
ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü +10Œî, Alice is guaranteed enough time to claim Carol‚Äôs
‚ñ°
principal.

The remaining proofs are for the properties of the follower trans-

fer protocol.

Lemma 16. In Protocol 4.3, if Bob, David are both compliant, and
Alice does nothing, then Bob gets David‚Äôs principal, and David gets
Bob position.

Proof. By assumption, we know the Mutate

Phase
ends ùë†ùë°ùëéùëüùë°ùêπùëúùëôùëôùëúùë§ùëíùëü + 2Œî. At this point, ùëêùëéùëõùëëùëñùëéùë°ùëí_ùë†ùëíùëõùëëùëíùëü =
ùê∑ùëéùë£ùëñùëë.ùëéùëëùëëùëüùëíùë†ùë† on ùêµùê¥ and ùëêùëéùëõùëëùëñùëëùëéùë°ùëí_ùëüùëíùëêùëíùëñùë£ùëíùëü = ùê∑ùëéùë£ùëñùëë.ùëéùëëùëëùëüùëíùë†ùë†
on ùê¥ùêµ. By ùë†ùë°ùëéùëüùë°ùêπùëúùëôùëôùëúùë§ùëíùëü + 3Œî we know ùê∑ùëéùë£ùëñùëë will reveal
ùê∑1 to ùê¥ùêµ and ùêµùê¥. At this point ùë†ùëíùëõùëëùëíùëü = ùê∑ùëéùë£ùëñùëë on ùêµùê¥ and
ùëüùëíùëêùëíùëñùë£ùëíùëü = ùê∑ùëéùë£ùëñùëë on ùê¥ùêµ. Thus David has successfully taken Bob‚Äôs
position. When Bob forwards ùê∑1 to the ùê∑ùêµ, it will arrive no
later than ùë†ùë°ùëéùëüùë°ùêπùëúùëôùëôùëúùë§ùëíùëü + 4Œî < ùë†ùë°ùëéùëüùë°ùêπùëúùëôùëôùëúùë§ùëíùëü + 5Œî. So Bob gets
‚ñ°
David‚Äôs principal.

Theorem 7. Protocol 4.3 satisfies liveness: If Alice, Bob, and David
are all conforming, and Alice doesn‚Äôt reveal ùê¥1, then Bob gets David‚Äôs
principal, David gets Bob‚Äôs position, and Alice maintains her position.

Proof. Because Alice is compliant and doesn‚Äôt reveal ùê¥1, she
does nothing according to Protocol 4.3. Since Bob and David are
‚ñ°
both compliant, the result follows from Lemma 16.

Theorem 8. Protocol 4.3 satisfies transfer independence: Bob can

transfer his position to David without Alice‚Äôs participation.

Proof. Assume Alice does nothing and Bob, David are compli-
‚ñ°

ant. By Lemma 16, the result follows immediately.

Theorem 9. Protocol 4.3 satisfies non-blocking transfer: Bob can

transfer his position to David even if Alice is adversarial.

Proof. Alice‚Äôs only ability during Protocol 4.3, is to choose
to reveal her secret ùê¥1. Since Bob and David are compliant,
David creates ùê∑ùêµ by ùë†ùë°ùëéùëüùë°ùêπùëúùëôùëôùëúùë§ùëíùëü + Œî. In the worst case, Bob
calls ùëöùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùêπùëüùëíùëíùêπùëúùëôùëôùëúùë§ùëíùëü () on ùêµùê¥ at the last available op-
portunity, at ùëá ‚àí 2Œî. Since Bob is compliant, he also calls
ùëöùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùêπùëúùëôùëôùëúùë§ùëíùëü () on ùê¥ùêµ by ùëá ‚àí 2Œî. Since David is compliant,
he calls ùëüùëíùëùùëôùëéùëêùëí () on ùê¥ùêµ, ùêµùê¥ by ùëá ‚àí Œî, thereby revealing ùê∑1 to
Bob. Both replace calls are then completed by ùë†ùë°ùëéùëüùë°ùêπùëúùëôùëôùëúùë§ùëíùëü + 3Œî.
Bob then has enough time to reveal ùê∑1 on ùê∑ùêµ since its timeout is
ùë†ùë°ùëéùëüùë°ùêπùëúùëôùëôùëúùë§ùëíùëü + 5Œî. If Alice reveals ùê¥1 by ùëá on ùêµùê¥, then David will
have Bob‚Äôs position so he on ùê¥ùêµ and ùêµùê¥. Thus he can reveal ùê¥1 on
‚ñ°
ùê¥ùêµ since it has timeout ùëá + Œî.

Theorem 10. Protocol 4.3 satisfies transfer atomicity: If Bob loses

his swap position, then he can claim David‚Äôs principal.

Proof. Suppose a conforming Bob loses his swap posi-
tion. By Protocol 4.3, we know ùëöùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùêπùëúùëôùëôùëúùë§ùëíùëü () and
ùëöùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùêπùëüùëíùëíùêπùëúùëôùëôùëúùë§ùëíùëü () are called on ùê¥ùêµ and ùêµùê¥ respectively
by ùë†ùë°ùëéùëüùë°ùêπùëúùëôùëôùëúùë§ùëíùëü + 2Œî by Bob. By assumption Bob loses his swap
position. Thus David must have revealed ùê∑1 on ùê¥ùêµ or ùêµùê¥ before the
ùëüùëíùëùùëôùëéùëêùëíùêπùëúùëôùëôùëúùë§ùëíùëü () timeout. Since each ùëüùëíùëùùëôùëéùëêùëíùêπùëúùëôùëôùëúùë§ùëíùëü () timeout
is 2Œî, the latest David could have revealed ùê∑1 is ùë†ùë°ùëéùëüùë°ùêπùëúùëôùëôùëúùë§ùëíùëü + 4Œî.
Conforming Bob sends ùê∑1 to ùê∑ùêµ which arrives by ùë†ùë°ùëéùëüùë°ùêπùëúùëôùëôùëúùë§ùëíùëü +

Daniel Engel and Yingjie Xue

5Œî. Since the timeout on ùê∑ùêµ is ùë†ùë°ùëéùëüùë°ùêπùëúùëôùëôùëúùë§ùëíùëü + 5Œî, this ensures
‚ñ°
Bob gets David‚Äôs principal.

.2.2 No UNDERWATER. The goal of this section is to prove Theo-
rem 1.

If the reselling is started by Alice calling mutateLockLeader()
on ùê¥ùêµ and/or ùêµùê¥ contract, the state of the corresponding contract
will be changed. We first define states of contracts. These are refer-
enced from .1. A smart contract‚Äôs state is defined by the following
elements:

‚Ä¢ sender: sender can call refund() if the receiver does not re-

deem it before swap hashlock times out.

‚Ä¢ receiver: receiver can call claim() and pass the preimage of
swap hashlock to get the asset escrowed in the contract.
‚Ä¢ mutating: mutating is a bool where mutating=true means
the asset is temporarily not redeemable due to some active
mutation in progress. In other words, the right to claim the
asset is locked. On the other hand, mutating=false means the
asset can be claimed if the preimage to the hashlock is sent
to the contract.

‚Ä¢ swap_hash_lock: The swap hashlock is the hashlock used
to claim assets. If the preimage of the hashlock is sent to
claim(), then the receiver can claim the asset.

‚Ä¢ replace_hash_lock: If replace_hash_lock != nil, that means
Alice would like to transfer her option. replace_hash_lock
stores the hashlock for the transfer.

‚Ä¢ candidate_sender/candidate_receiver: denotes the new sender
or receiver when transfer is finalized, i.e. Carol replaces
Alice‚Äôs role.

We take ùê¥ùêµ as an example to illustrate the states. The states on

ùêµùê¥ are symmetric which can be inferred from the context.

state

‚Ä¢ ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê¥1), ùê¥ùêµ) denotes

=
ùê¥ùëôùëñùëêùëí, ùëüùëíùëêùëíùëñùë£ùëíùëü = ùêµùëúùëè, ùëöùë¢ùë°ùëéùë°ùëñùëõùëî = ùëì ùëéùëôùë†ùëí, ùë†ùë§ùëéùëù_‚Ñéùëéùë†‚Ñé_ùëôùëúùëêùëò =
ùêª (ùê¥1)), meaning if ùê¥1 is sent before the contract ex-
pires, Bob can claim Alice‚Äôs principal. We will use
ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê¥1)) for simplicity when which contract
we are referring to is obvious from the context.

(ùë†ùëíùëõùëëùëíùëü

= ùêª (ùê∂1), ùë†ùë§ùëéùëù_‚Ñéùëéùë†‚Ñé_ùëôùëúùëêùëò

‚Ä¢ ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùê∂ùëéùëüùëúùëô, ùêª (ùê∂1), ùêª (ùê∂2), ùê¥ùêµ) denotes
the state (ùë†ùëíùëõùëëùëíùëü = ùê¥ùëôùëñùëêùëí, ùëüùëíùëêùëíùëñùë£ùëíùëü = ùêµùëúùëè, ùëöùë¢ùë°ùëéùë°ùëñùëõùëî =
ùë°ùëüùë¢ùëí, ùëüùëíùëùùëôùëéùëêùëí_‚Ñéùëéùë†‚Ñé_ùëôùëúùëêùëò
=
ùêª (ùê∂2), ùëêùëéùëõùëëùëñùëëùëéùë°ùëíùëü ùëíùëêùëíùëñùë£ùëíùëü = ùê∂ùëéùëüùëúùëô), which means Al-
ice tentatively locks the asset and transfers her role to
Carol. In this state Bob is able to call contest(). We will
use ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)) for simplicity
when other parts we are referring to are obvious from the
context. ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí is just a preparation for
Carol to replace Alice‚Äôs role. The replaceLeader() cannot be
called until the state defined below.

‚Ä¢ ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùê∂ùëéùëüùëúùëô, ùêª (ùê∂1), ùêª (ùê∂2), ùê¥ùêµ).

In
this state Bob cannot call contest() because his contest
window has passed or he approved the mutation. At
this state, Carol can release her secret ùê∂1 to replace Al-
ice. The state when Carol can replace Alice is denoted
as ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùê∂ùëéùëüùëúùëô, ùêª (ùê∂1), ùêª (ùê∂2), ùê¥ùêµ).
is the short
ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2))
name.

16

Transferable Cross-Chain Options

Figure 3: State transition until Carol replaces Alice on ùê¥ùêµ
contract

‚Ä¢ ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê∂2), ùê∂ùêµ).

After

replace()

role by sending ùê∂1. After

ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùê∂ùëéùëüùëúùëô, ùêª (ùê∂1), ùêª (ùê∂2), ùê¥ùêµ)
to replace Al-
is reached, Carol can call
the replacement,
ice‚Äôs
the state becomes
=
ùêµùëúùëè, ùëöùë¢ùë°ùëéùë°ùëñùëúùëõ_ùëôùëúùëêùëò = ùëì ùëéùëôùë†ùëí, ùë†ùë§ùëéùëù_‚Ñéùëéùë†‚Ñé_ùëôùëúùëêùëò = ùêª (ùê∂2)), de-
noted as ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê∂2), ùê∂ùêµ). ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê∂2))
is the short name.

ùê∂ùëéùëüùëúùëô, ùëüùëíùëêùëíùëñùë£ùëíùëü

(ùë†ùëíùëõùëëùëíùëü

=

‚Ä¢ ùê∂ùëôùëéùëñùëöùëíùëë (ùêª (ùëÜ), ùê¥ùêµ) means the asset on ùê¥ùêµ contract is
claimed by a secret ùëÜ which is the preimage to ùêª (ùëÜ) and
Bob gets the asset. In this context, ùëÜ can be ùê¥1 or ùê∂2.
ùê∂ùëôùëéùëñùëöùëíùëë (ùêª (ùëÜ)) is the short name.
The state transition is depicted in Fig 3.
There are two stages of changes of state on the ùê¥ùêµ and ùêµùê¥

contracts.

(2) Second

(1) First stage. Alice and Bob aim to change the state of
both contracts from ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê¥1)) to a mutation
state ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)), during
which state ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)) may be
reached temporally, corresponding to Mutate Lock Phase
and Consistency Phase.
from
stage.
ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)),
Bob
and Carol are involved in an atomic change from
to
ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2), ùê∂ùëéùëüùëúùëô)
ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê∂2)) by Carol releasing a secret ùê∂1. It is
similar to a standard atomic swap where Carol is the leader
and Bob is the follower, corresponding to the Replace/Revert
Phase.

Starting

Theorem 17. Conforming Alice will never end up in UNDERWA-

TER.

Proof. If Carol never creates ùê∂ùê¥ or creates ùê∂ùê¥ with different
conditions than what Carol and Alice agreed upon, then Alice does
nothing and so she doesn‚Äôt lose her option.

Otherwise, consider the case when Carol creates ùê∂ùê¥ with the

conditions Alice and Carol had agreed upon.

If Alice is conforming, by Lemma 15 then both ùê¥ùêµ and
ùêµùê¥ are mutate locked with (ùêª (ùê∂1), ùêª (ùê∂2)) by ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü +
2Œî. This means ùê¥ùêµ and ùêµùê¥ both have reached the state

17

ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)) by ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü +2Œî. Since
Alice is conforming, by ùë†ùë°ùëéùëüùë°ùêøùëíùëéùëëùëíùëü + 4Œî, the state will transition
to ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)) since Bob cannot
forge Alice‚Äôs signature and contest.

After ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)), if Carol re-
leases ùê∂1, Alice observes it in the Replace/Revert phase, and can get
Carol‚Äôs principal as shown in Theorem 5. If Carol does not release
ùê∂1, then eventually, after ùë°ùê¥ùêµ + 6Œî and ùë°ùêµùê¥ + 6Œî respectively, the
states on both contracts can be reverted to ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê¥1))
which means Alice still owns the option and it is unlocked. If Alice
finally owns the option, then she does not end up in UNDERWATER
by the guarantee of atomic swap. If Alice loses her option(maybe
only lose a role on one contract), she gets Carol‚Äôs principal, with-
/without losing her principal escrowed in her old option, which is
‚ñ°
acceptable for her.

Theorem 18. Conforming Carol will never end up in UNDERWA-

TER.

Proof. After Carol escrows her principal

to Alice on
ùê∂ùê¥ and sends her hashlocks ùêª (ùê∂1), ùêª (ùê∂2)
to Alice, Carol
does not do anything in the first stage but observe. She
only joins in the protocol after she observes that both con-
tracts are in ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)) state.
Otherwise, she is silent and she will not end up in UNDER-
WATER since her principal will be refunded eventually. After
she
ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2))
releases ùê∂1, moving
contracts,
state
to
state
ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2))
ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê∂2)). Then she owns the option provided
by Bob and takes over Alice‚Äôs option. In that case, she may lose her
principal to Alice due to the release of ùê∂1. Say, in the worst, she
loses her principal to Alice.

observes
on

both

she

Then, if Carol decides to exercise the option, she gets Bob‚Äôs
principal. That means, her principal is exchanged with Bob‚Äôs. If she
does not exercise the option and let it expire, she can get Alice‚Äôs
principal. That means, her principal is exchanged with Alice‚Äôs. In
‚ñ°
any case, Carol never ends up in UNDERWATER.

To prove that conforming Bob does not end up in UNDERWATER,
we need to to prove the consistency of states on two contracts.
Specifically,

‚Ä¢ In the first stage, if Alice calls mutateLockLeader() in
any contract, either both contracts eventually gets
reverted
ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)
back to ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê¥1)).

or

‚Ä¢ In the second stage, if Carol releases ùê∂1, both contracts
are eventually at state ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê∂2)). If Carol does
not releases ùê∂1, both contracts are eventually are in state
ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê¥1)).

Suppose, without loss of generality, that ùê¥ùêµ contract is the first
to update its state from ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê¥1)) to a new state by
Alice calling mutateLockLeader() at some time ùë°, assuming Bob is
conforming.

Theorem 19. If ùêµùê¥ is not claimed by ùë° + Œî, then ùêµùê¥ will be mutate

locked by ùë° + Œî.

2/12/22, 9:42 PMtransfer_option_states1/1Bob mutates at timeRevert afterAlice revealsbefore timeoutAlice mutates at timeBob contests withinBob doesn't contest byor Bob approvesrevealed beforeProof. Since Bob is conforming, when Alice calls mutateLock-
Leader() on the ùê¥ùêµ contract, Bob can send mutateLockLeader() trans-
action on the ùêµùê¥ within Œî. Recall that the start time that mutate-
LockLeader() is called is denoted as ùë°ùê¥ùêµ and ùë°ùêµùê¥ respectively. Then
in ùêµùê¥ mutateLockLeader() is called on ùêµùê¥ by ùë°ùê¥ùêµ + Œî.

If Bob‚Äôs mutateLockLeader() is included on ùêµùê¥, then ùë°ùêµùê¥ ‚â§ ùë°ùê¥ùêµ+Œî.
If Bob‚Äôs mutateLockLeader() on ùêµùê¥ is not included, then it must
be Alice was able to call it before he was. In either case, ùë°ùêµùê¥ ‚â§
‚ñ°
ùë°ùê¥ùêµ + Œî.

The case that by ùë° + Œî, the other contract‚Äôs state changes to

ùê∂ùëôùëéùëñùëöùëíùëë (ùêª (ùê¥1)) will be analyzed in Theorem 22.

Theorem 20. Suppose

two
eventually
reach ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)). Then,
ei-
ther both contracts are eventually ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê¥1)) or
ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê∂2)).

contracts

both

Proof. Since we know the start time of mutation between two
contracts does not stagger beyond Œî. Denote the start time on two
contracts as ùë°ùëì ùëñùëüùë†ùë° and ùë°ùë†ùëíùëêùëúùëõùëë respectively where ùë°ùëì ùëñùëüùë†ùë° ‚â§ ùë°ùë†ùëíùëêùëúùëõùëë .
Since Bob is conforming, ùë°ùë†ùëíùëêùëúùëõùëë ‚àíùë°ùëì ùëñùëüùë†ùë° ‚â§ Œî. We denote the timeout
for Carol to release ùê∂1 on ùê¥ùêµ and ùêµùê¥ contracts as ùë°1,ùë°2 respectively,
and the timeout for Bob to release ùê∂1 as ùë°3,ùë°4. Without loss of gener-
ality, assume ùë°1 = ùë°ùëì ùëñùëüùë†ùë° + 4Œî and ùë°2 = ùë°ùë†ùëíùëêùëúùëõùëë + 4Œî. ùë°3 = ùë°ùëì ùëñùëüùë†ùë° + 6Œî
and ùë°4 = ùë°ùë†ùëíùëêùëúùëõùëë + 6Œî. We see that the latest timeout for Carol to
release ùê∂1 is ùë°2. The earliest timeout for Bob to send ùê∂1 satisfies
ùë°3 ‚â• ùë°2 + Œî since we have ùë°3 = ùë°ùëì ùëñùëüùë†ùë° + 6Œî ‚â• ùë°ùë†ùëíùëêùëúùëõùëë + 5Œî = ùë°2 + Œî.
That means, if Carol releases ùê∂1, then it is eventually sent to both
contracts and the state is ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê∂2)). If Carol does not re-
lease ùê∂1, then both contracts are reverted to ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê¥1))
‚ñ°
after timeout ùë°3 and ùë°4, respectively.

The atomic changes between AB and BA are a bit more
complicated, since starting from ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê¥1)), there
are multiple possible state changes available on both con-
tracts: ùê∂ùëôùëéùëñùëöùëíùëë (ùêª (ùê¥1)), ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)),
states
and ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)). The
ùê∂ùëôùëéùëñùëöùëíùëë (ùêª (ùê¥1)) and ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2))
are not contestable. Assuming Bob is conforming and relay what-
ever he sees from one contract to another contract.

Lemma

21. If

a

to
contract
ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)) at ùë°, then within ùë° + 2Œî, it
learns the other contract‚Äôs update and then agree on either reverting
back if there is a conflict or agree on the same mutation if no conflict.

transferred

is

a

contract,

Proof. If

say AB,

to
transferred
is
ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)) at
time ùë°, since the
compliant Bob relays it, whatever happens before ùë° ‚àí Œî to
AB contract, that means, at time ùë° ‚àí Œî, the other chain is in
ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê¥1)). If there is any change happening on BA
contract, it would happen between ùë° ‚àí Œî to ùë° + Œî. Then, by
ùë° + 2Œî, AB contract will learn what happens on BA contract
between ùë° ‚àí Œî to ùë° + Œî by Bob. If AB contract does not receive
any transaction from Bob, then no conflicting changes hap-
pened on BA from ùë° ‚àí Œî to ùë° + Œî. Bob can update BA contract
to ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)) by relaying Alice‚Äôs
mutation to BA contract, and AB contract can be updated to

Daniel Engel and Yingjie Xue

ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)) after ùë° + 2Œî. If there
is any state change between ùë° ‚àí Œî to ùë° + Œî on BA contract, then by
ùë° + 2Œî, AB contract would be informed, and its own state update is
also sent to BA contract. Then the conflicting state update would
revert back their state change to ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê¥1)) when it
‚ñ°
receives the conflicting change.

Theorem 22. Conforming Bob never ends up in UNDERWATER.

Proof. Starting from ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê¥1)),
(1) If

is

a

transferred

to
contract
ùë°, and the
ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2))
other contract is not updated to ùê∂ùëôùëéùëñùëöùëíùëë (ùêª (ùê¥1)), then by
Lemma 21, we know that either both contracts eventually
reach
ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)) or are reverted
back to ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê¥1)).

at

(2) If a contract BA is transferred to ùê∂ùëôùëéùëñùëöùëíùëë (ùêª (ùê¥1))
state at ùë°, then, if the other contract makes temporary
ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2),
it will be revert
back to ùëÖùëíùëéùëëùë¶2ùê∂ùëôùëéùëñùëö(ùêª (ùê¥1)) by ùë° + Œî, and then transfer
to ùê∂ùëôùëéùëñùëöùëíùëë (ùêª (ùê¥1)). Bob does not end up with UNDERWA-
TER.

(3) If

a

contract

is

transferred

directly

to

ùë°,

then

contract must

ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2))
at
be
other
the
ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)) at ùë° ‚Ä≤ ‚àà [ùë° ‚àí Œî, ùë°],
and then after ùë° + 2Œî or sooner, the other contract will
become ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)).
When ùëÄùë¢ùë°ùëéùë°ùëíùêøùëúùëêùëòùëÅùëúùëõùê∂ùëúùëõùë°ùëíùë†ùë°ùëéùëèùëôùëí (ùêª (ùê∂1), ùêª (ùê∂2)) is reached on
both contracts, by Theorem 20, Bob will either be involved in the
swap with Alice by Alice‚Äôs secret ùê¥1 or involved in the swap with
Carol by Carol‚Äôs secret ùê∂2. By the guarantee of atomic swap, Bob
will not end up with UNDERWATER.

‚ñ°

The details for showing Protocol 4.3 satisfies No UNDERWATER
are omitted since they mirror the previous arguments shown for
4.2.

18

