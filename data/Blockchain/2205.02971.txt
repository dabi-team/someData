2
2
0
2

y
a
M
6

]

R
C
.
s
c
[

1
v
1
7
9
2
0
.
5
0
2
2
:
v
i
X
r
a

Transferable Cross-Chain Options

Daniel Engel
Computer Science Dept., Brown University
Providence, RI, USA

Yingjie Xue
Computer Science Dept., Brown University
Providence, RI, USA

ABSTRACT
An option is a financial agreement between two parties to trade
two assets. One party is given the right, but not the obligation, to
complete the swap before a specified termination time. In todayâ€™s
financial markets, an option is considered an asset which can itself
be transferred: while an option is active, one party can sell its rights
(or obligations) to another.

Todayâ€™s blockchains support simple options in the form of cross-
chain atomic swap protocols where one party has the choice whether
to complete the swap. The options implemented by these cross-
chain protocols, are not, however, transferable.

This paper proposes novel distributed protocols for transferable
cross-chain options, where both option owners and providers can sell
their positions to third parties. The protocol ensures that none of
the parties can be cheated, that no unauthorized party can interfere,
and that the transfer succeeds if the buyer and seller faithfully
follow the protocol.

1 INTRODUCTION
An option is a financial agreement between two parties, say, Alice
and Bob. Alice owns some units of â€œflorinâ€ cryptocurrency, while
Bob owns some units of â€œguilderâ€ cryptocurrency. Alice and Bob
agree that Alice will purchase from Bob the right, but not the obli-
gation, to buy 100 guilders from him in return for 100 florins from
her, at any time before, say, next Tuesday. If the value of guilders
relative to florins goes up before Tuesday, Alice will exercise her
option by executing the trade, and otherwise she will keep her
florins and walk away. Alice pays Bob a fee, called a premium, to
compensate him for his inconvenience and risk.

In the world of decentralized finance (Defi), florins and guilders
are managed on distinct blockchains, Alice and Bob are autonomous
agents, and they do not trust each other. Moreover, they have no re-
course to third-party arbiters or to courts of law. Several non-trivial
distributed protocols have been proposed to execute cross-chain
swaps and options [7, 11â€“14, 16, 21â€“23]. Simplifying somewhat,
these protocols guarantee that if Alice and Bob are both honest,
then the deal unfolds as planned, but if either party cheats, the
honest party ends up in what it considers a satisfactory position.

The contribution of this paper is to take the notion of a cross-
chain option to the next level: while Aliceâ€™s unexercised option
has value, she should be able to sell it to a third party, Carol. In
conventional finance, such a transfer is simple: Bob grants Alice
an options contract, Alice signs over that contract to Carol, and
all agreements are enforced by civil law. In the lawless world of
decentralized finance, by contrast, transferable options require a
carefully-crafted distributed protocol.

We propose novel cross-chain protocols, to support transferable
cross-chain options. Additionally, we prove the security properties

1

of our proposed protocols, and detailed pseudocode for the proto-
cols is provided. Informally, our proposed protocols can address
option transfer in the following scenarios:

(1) Alice (the option owner, i.e the one who has a right to buy
an asset) transfers her position to another party (Carol).
(2) Bob (the option provider, i.e. the one who provides the owner
the right) transfers his position to another party (David).
(3) Alice and Bob concurrently transfer their positions to Carol

and David, respectively.

Take the option position transfer between Alice and Carol for
example. The proposed transfer protocol ensures that if Alice and
Carol are honest, then Alice relinquishes her rights, Carol assumes
Aliceâ€™s rights, and Bob cannot veto the transfer. If Carol cheats,
then Aliceâ€™s rights remain with Alice.

We view the proposed distributed protocols as a first step toward
a more ambitious goal. One can imagine more complex cross-chain
deals where parties acquire various rights and obligations (options,
futures, derivatives, and so on). It should be possible for a party
who holds unrealized rights or obligations to sell those rights or
obligations to another party, atomically transferring its position
without being hindered by any third party. Here, we show how to
make certain transferable cross-chain option deals, but someday
we hope to do the same for arbitrary cross-chain deals.

This paper is organized as follows. Our model is given in Sec-
tion 2. We provide an overview of our proposed transferable two-
party swap protocols in Section 3 and detailed protocols are de-
scribed in Section 4. We prove security properties of our proposed
protocols in Section 5. In Section 6, we describe related work. Finally,
we conclude in Section 7.

2 MODEL
For our purposes, a blockchain is a tamper-proof distributed ledger
(or database) that tracks ownership of assets by parties. An asset can
be a cryptocurrency, a token, an electronic deed to property, and so
on. A party can be a person, an organization, or even a contract (see
below). There are multiple blockchains managing different kinds of
assets. We focus here on applications where mutually-untrusting
parties trade assets across multiple blockchains. Because we treat
blockchains simply as ledgers, our results do not depend on specific
blockchain technology (such as proof-of-stake vs proof-of-work).
We assume only that ledgers are highly available, tamper-proof,
and capable of running smart contracts.

A smart contract (or â€œcontractâ€) is a blockchain-resident program
initialized and called by the parties. A party can create a contract
on a blockchain, or call a function exported by an existing contract.
Contract code and state are public, so a party calling a contract
function knows what code will be executed. Contract code is deter-
ministic because contract execution is replicated, and all executions
must agree.

 
 
 
 
 
 
A contract can read or write ledger entries on the blockchain
where it resides, but it cannot actively access data from the outside
world, including calling contracts on other blockchains. Although
there are protocols that allow blockchains to communicate (cross-
chain proofs), they have weaknesses that make them difficult to use
in practice: for example, incompatibility problems, lack of decentral-
ization, and non-deterministic guarantees of message delivery [20].
Therefore, we assume different blockchains do not communicate.
A contract on blockchain ğ´ can learn of a change to a blockchain
ğµ only if some party explicitly informs ğ´ of ğµâ€™s change, along with
some kind of â€œproofâ€ that the information about ğµâ€™s state is correct.
Contract code is passive, public, deterministic, and trusted, while
parties are active, autonomous, and potentially dishonest.

At any given time each party has a given financial position. This
is characterized by their current and future financial obligations/al-
lowances. Financial positions are managed by rules on contracts
that can reside across multiple distinct blockchains.

Our execution model is synchronous: there is a known upper
bound Î” on the propagation time for one partyâ€™s change to the
blockchain state, plus the time to be noticed by the other parties.
Specifically, blockchains generate new blocks at a steady rate, and
valid transactions sent to the blockchain will be included in a block
and visible to participants within a known, bounded time Î”.

As noted, we assume blockchains are always available, tamper-
proof, and that they correctly execute their contracts. Although
parties may display Byzantine behavior, contracts can limit their
behavior by rejecting unexpected contract calls.

We make standard cryptographic assumptions. Each party has a
public key and a private key, and any partyâ€™s public key is known to
all. Messages are signed so they cannot be forged, and they include
single-use labels (â€œnoncesâ€) so they cannot be replayed.

3 PROBLEM OVERVIEW
One way to convey the challenge presented by making options
transferable is to trace the evolutionary path that leads from 20th
Century distributed systems to modern decentralized finance (DeFi).
Suppose, in 1999, Alice and Bob agree that she will transfer 100
dollars to him at a New York bank, and he will transfer 100 eu-
ros to her at a Paris bank. Each bank maintains its own database,
which communicate over a network. The swap protocol must tol-
erate hardware failures: databases can crash and messages can be
lost. Each bank makes a tentative transfer. In the classical two-
phase commit protocol [2], each bank records its tentative transfers
â€œsomewhere safeâ€ (on a magnetic disk that survives crashes) and
sends to a trusted coordinator a vote whether to commit or abort. If
both banks vote to commit, the transfers are installed, and if either
votes to abort, or does not vote in a reasonable time, the transfers
are discarded, leaving both databases unchanged.

The two-phase commit protocol established a pattern for later
blockchain protocols. Today, Alice and Bob want to trade units
of cryptocurrency. They agree to exchange 100 of her (electronic)
florins for 100 of his (electronic) guilders. Each cryptocurrency
is managed on a distinct blockchain. Alice and Bob must agree
on a swap protocol that tolerates not only hardware failures, but
Byzantine failures by participants: each party must protect itself if
its counterparty cheats by departing from the agreed-upon protocol.

Daniel Engel and Yingjie Xue

Atomic swap protocols based on hashed timelock contracts (HTLCs) [13,

17] mimic two-phase commit. In the HTLC protocolâ€™s first phase,
each party places the assets to be transferred â€œsomewhere safeâ€.
In place of writing to magnetic disk, Alice transfers her florins to
an escrow account controlled by a smart contract, a program that
decides, based on later input, whether to commit by transferring
Aliceâ€™s florins to Bob, or to abort by refunding Alice her florins.
Then Bob does the same. Each escrow transfer is effectively a vote
to commit. When both votes are confirmed, Alice releases a secret
that causes the contracts to complete the swap. Otherwise, if the
escrow transfers are not confirmed in reasonable time, the contracts
refund the assets to their original owners. This description elides
many technical details, but the HTLC protocolâ€™s overall structure
is remarkably similar to two-phase commit, despite substantial
differences in their failure models.

While technically correct, HTLC swap protocols are flawed: once
both assets are escrowed, Alice can take her time deciding whether
to trigger the swap. Cryptocurrencies are notoriously volatile, so if
the value of Bobâ€™s guilders goes up relative to Aliceâ€™s florins before
the timeout expires, she can choose to complete the swap at the last
minute. If the value goes down, she is free to walk away without
penalty. Bob may be reluctant to accept such a deal.

This protocol is unfair to Bob because only Alice has optionality:
at the end, he cannot back out of the deal, but she can. If she does
back out, he gets his guilders back, but only after a possibly long
delay while the market is moving against him. Bob thus incurs the
opportunity cost of not being able to use his coins while they are
escrowed. By contrast, in conventional finance, this deal would be
structured as an option contract, where Alice pays Bob a fee, called a
premium, to compensate him if she walks away without completing
the deal.

Cross-chain atomic swap options require carefully-defined dis-
tributed protocols [16, 23]. The protocol proposed by Xue and Her-
lihy [23] is structured like an iterated two-phase commit protocol:
in the first phase the parties escrow premiums. If all goes well, in
the next phase they escrow coins. If all goes well in the final phase
they complete the swap. Any party who drops out of the protocol
ends up paying a premium to the other, and in the end, Alice has
the optionality, but Bob has been compensated for his risk.

We are now ready to address the main topic of this paper. As long
as Alice has optionality, that optionality has value. Alice should be
able to sell her position to a third party Carol. (Bob may also want
to sell his position to a third party David). For starters, we focus
on Aliceâ€™s position transfer since Bobâ€™s transfer will be similar.
There are many reasons Alice and Carol might agree to such a
deal. Alice may want to liquidate her position because she needs
cash. Perhaps Alice and Carol have different opinions on the future
values of florins versus guilders, or they have different levels of risk
tolerance.

A transferable atomic swap option (or â€œtransferable swapâ€) proto-
col roughly must satisfy the following properties. (We define these
properties more precisely in Section 5.)

â€¢ Liveness: If Alice and Carol both follow the protocol, then
(1) Carol acquires the right to buy Bobâ€™s coins at the same
price and deadline, (2) Alice loses that right, and she is paid
by Carol, (3) Bob cannot veto the transfer.

2

Transferable Cross-Chain Options

â€¢ Safety: As long as one of Alice or Carol follows the protocol,
(1) the protocol completes before the option expires, and (2)
when the protocol completes, exactly one of Alice or Carol
has the right to trigger the atomic swap with Bob, (3) Bobâ€™s
position in the option does not change if he conforms.

Here is a high-level summary of our protocol. The contract linking
Alice and Bob is a delayed swap: Alice escrows her asset, then Bob
escrows his. These escrow contracts are controlled by a hashlock â„.
Until each contractâ€™s timeout expires, that contract will complete
its side of the swap when Alice produces a secret ğ´1 such that
â„ = ğ» (ğ´1), where ğ» (Â·) is a predefined cryptographic hash function.
Alice has optionality because she alone knows the secret.

Here is how Carol can buy Aliceâ€™s position. First, there must be
enough time to complete this transfer before Aliceâ€™s option expires.
Roughly speaking, Carol generates a secret, then Alice and Carol
swap the roles of Carolâ€™s and Aliceâ€™s secrets: following the transfer,
Aliceâ€™s secret will no longer trigger the swap with Bob, but Carolâ€™s
secret will.

There are two contracts (discussed in detail below). Contract ğ´ğµ
controls Aliceâ€™s possible payment to Bob, while ğµğ´ controls Bobâ€™s
payment to Alice. The optionality transfer itself is structured like
a cross-chain swap, exchanging roles instead of assets. In the first
phase, Alice marks contracts ğ´ğµ and ğµğ´ as mutating, temporarily
preventing any transfer to or from Bob. This step prevents Alice
or Carol from creating a chaotic situation by triggering a partial
asset swap with Bob while the optionality transfer is in progress.
In the second phase, Carol replaces the (hash of) Aliceâ€™s secret and
address in both ğ´ğµ and ğµğ´ with the (hash of) Carolâ€™s secret and
address. Just as for regular swaps, the optionality transfer protocol
will time out and revert if Alice or Carol fails to take a step in time.
There is still a danger that Alice and Carol might cheat Bob
by making inconsistent changes to contracts ğ´ğµ and ğµğ´. Because
ğ´ğµ and ğµğ´ cannot coordinate directly, the protocol has a built-in
delay to give Bob an opportunity to contest a malformed transfer
and to revert its changes. If the transfer is well-formed, Bob can
expedite the protocol by actively approving of the transfer, perhaps
in return for an extra premium. If Bob remains silent, the protocol
will proceed after the delay expires. Bob contests the transfer by
providing proof that Alice signed inconsistent changes to ğ´ğµ and
ğµğ´.

To keep the presentation uncluttered, we omit some functionality
that would be expected in a full protocol, but that is not essential for
optionality transfer. For example, there would be additional steps
where parties deposit premiums to compensate one another if one
party leaves the otherâ€™s assets temporarily trapped in escrow, where
Alice pays Bob a premium to encourage prompt transfer approval,
and where Alice posts a bond to be slashed if she is caught sending
inconsistent information to ğ´ğµ and ğµğ´.

4 TWO-PARTY TRANSFERABLE SWAP
4.1 Overview
We will now describe several protocols for transferring option
positions. First we will describe a protocol that allows Alice to
transfer her position as the option owner in a swap with Bob, to a
third-party Carol. Next, we will give a protocol that allows Bob to
transfer his position as the option provider in a swap with Alice, to

3

a third-party David. Finally, we show that both of these protocols
can be run concurrently and can also support multiple concurrent
buyers. Solidity code for these contracts appears in Appendix .1.
A party that follows the protocol is conforming, and a party that
does not is adversarial. A partyâ€™s principal is the assets escrowed at a
contract during the protocol execution. We use transfer and replace
interchangeably. First we describe the initial setup where Alice and
Bob first lock their principals using a hashlock. Throughout this
paper, the party who owns the preimage to the hashlock (Alice,the
initial owner of the option) is called a leader and the counterparty
(Bob) is called a follower. This terminology is similar to prior two-
party, HTLC-based cross-chain swap protocols [10, 17, 24].

Setup.
(1) Agreement. Alice and Bob agree on a time startLeader to
start the protocol, usually shortly after this agreement. Alice
and Bob agree on the amounts Assetğ´, Assetğµ forming their
principals, as well as the number of rounds ğ‘‘ğ‘‡ 1, where after
ğ‘‡ = startLeader + ğ‘‘ğ‘‡ Â· Î” when Aliceâ€™s optionality on the
ğµğ´ contract expires. Alice generates a secret ğ´1 and ğ» (ğ´1)
which is used as swap_hashlock to redeem both principals
as in a typical two-party swap.

(2) Escrow. After the agreement achieved,

(a) Within Î”, Alice publishes the ğ´ğµ contract, escrowing
Assetğ´, setting ğ» (ğ´1) as the swap_hashlock and set ğ‘‡ + Î”
as the timeout for ğ´ğµ contract to expire.

(b) Once Bob sees Assetğ´ is escrowed with the correct timeout,
before Î” elapses, Bob creates the ğµğ´ contract, escrowing
Assetğµ, setting ğ» (ğ´1) as the swap_hashlock and set ğ‘‡ as
the timeout for ğµğ´ contract to expire.

A swap option between Alice and Bob, where Alice has op-
tionality, is determined by Alice and Bobâ€™s addresses, i.e. sender
and receiver in contracts, the swap_hashlock used for redemption,
and the timeout ğ‘‡ for refunds. To make the swap option trans-
ferable to Carol, we will need to replace Aliceâ€™s address with
Carolâ€™s as sender in the ğ´ğµ contract and as receiver in the ğµğ´
contract, and replace the swap_hashlock with a new one gener-
ated by Carol. In short, we must atomically replace the fields
(ğ´ğµ.sender, ğµğ´.receiver, ğ´ğµ.swap_hashlock, ğµğ´.swap_hashlock).
The contracts export the following functions of interest.

â€¢ Asset transfer related: the receiver calls claim() to withdraw
the asset in the contract. This function requires that the
preimage of the swap_hashlock is sent to claim() before the
contract expires. The sender calls ğ‘Ÿğ‘’ ğ‘“ ğ‘¢ğ‘›ğ‘‘ () to withdraw the
asset after the contract expires.

â€¢ Option transfer related: mutateLockLeader () temporarily
freezes the assets and stores a replace_hashlock used to re-
place Aliceâ€™s role (the replacement between Carol and Alice
is also enforced by a hashlock mechanism) and the new
swap_hashlock if Carol successfully replaces Alice. The call
to replace() completes the replacement for Carol.

For example, consider the ğ´ğµ contract. The mutateLockLeader()
function freezes the assets, tentatively records the new sender
as candidate_sender, the new swap_hashlock for redemption, and
records a short-term replace_hashlock to be used by replace() to

1We inherit the requirement ğ‘‘ğ‘‡ â‰¥ 4 from the standard two-party swap protocol.

finalize the replacement. Later, when replace() is called with the
secret matching the replace_hashlock, these tentative changes be-
come permanent. The replaceLeader () function has a timeout. If
that timeout expires, the internal revertLeader () function unfreezes
the assets, discards the tentative changes, and restores the contractâ€™s
previous state.

The challenge is how to ensure the transfer is atomic on both
contracts. If the transfer is not atomic, Bob will be cheated if his
principal can be claimed but he cannot claim Aliceâ€™s principal. To
protect Bob, the contract allows Bob to inspect the changes and
ensure atomicity by relaying changes on one contract to another.

4.2 Transfer Leader Position
Our protocol will consist of 3 phases, each of which we describe in
turn:

(1) Mutate Lock Phase. Alice locks the assets on both contracts

and tentatively transfers her position to Carol.

(2) Consistency Phase. Bob makes sure the tentative changes on

both contracts are consistent.

(3) Replace/Revert Phase. Carol replaces Aliceâ€™s role or she gives

up and Alice gets her option back.

I: Mutate Lock Phase. Assume Alice and Carol agree on Assetğ¶ for
transferring her role to Carol at time startLeader, which is the start
time the following executions are based on2. Carol has secrets ğ¶1, ğ¶2
and generates hashlocks ğ» (ğ¶1), ğ» (ğ¶2). Let ğ¶ğ‘šğ‘ ğ‘” = [ğ» (ğ¶1), ğ» (ğ¶2)]
be the message Carol sends to specify that she would like to use
[replace_hashlock, swap_hashlock], respectively.

In this phase, Carol prepares tentative payment Assetğ¶ to Alice
to replace Aliceâ€™s role. Alice locks the ğ´ğµ and ğµğ´ contracts so that
the currently escrowed assets cannot be claimed from the original
swap.

(1) By startLeader + Î”, Carol creates the ğ¶ğ´ contract, escrow-
ing Assetğ¶ , setting the swap_hashlock as ğ» (ğ¶1) for Alice to
redeem Assetğ¶ , and the timeout to be startLeader + 9Î”. She
also sends ğ¶ğ‘šğ‘ ğ‘” = [ğ» (ğ¶1), ğ» (ğ¶2)] to Alice.

(2) If the previous step succeeds, before Î” elapses, Alice
concurrently calls mutateLockLeader () on both ğ´ğµ and
ğµğ´ contracts, tentatively setting [replace_hashlock =
ğ» (ğ¶1), swap_hashlock = ğ» (ğ¶2)] to both contracts, and
setting candidate_sender = Carol.address on ğ´ğµ and
candidate_receiver = Carol.address on ğµğ´ contract. If Al-
ice is conforming, mutateLockLeader () should be called by
startLeader + 2Î” on both ğ´ğµ and ğµğ´.

II: Consistency Phase. It is possible that in the worst case, in
the Mutate Lock Phase, Alice could report inconsistent tentative
changes to ğ´ğµ, ğµğ´ by either mutating one contract but not the other,
or by reporting different hashlocks to each contract. Because the
two contracts cannot communicate, they have no way of knowing
what is happening on the other contract. One such example of an
attack is shown in Fig. 2.

Because of these attacks, in the Consistency Phase, Bob is given
a period to ensure both ğ´ğµ and ğµğ´ have the same changes. If one
of the contracts is not changed, then Bob forwards the change (by

2The protocol requires that startLeader â‰¤ ğ‘‡ âˆ’ 9Î”. Otherwise, there may not be
sufficient time to complete the replacement.

Daniel Engel and Yingjie Xue

forwarding Aliceâ€™s signature on the contract she signed) to the
other contract. If both contracts are tentatively changed but the
changed are different, then Bob can call contestLeader () to prove
that Alice has lied and reported inconsistent changes signed by
Alice.

(1) If Bob sees that Alice only calls mutateLockLeader ()
then within Î”, Bob
call
on ğ´ğµ(ğµğ´),
set
on ğµğ´(ğ´ğµ)
mutateLockLeader ()
[replace_hashlock = ğ» (ğ¶1), swap_hashlock = ğ» (ğ¶2)]
by forwarding Aliceâ€™s signature.

should
and

contract

(2) If Bob sees Alice has called mutateLockLeader () on both ğ´ğµ
and ğµğ´ , but the changes are different, i.e. either one or more
hashlocks are not the same, or the new candidate sender does
not correspond to the new candidate receiver, then before a
Î” elapses, Bob should call contestLeader () on both contracts,
forwarding Aliceâ€™s signature on one contract to the other. In
this case, the tentative change will be reverted.

(3) If Bob sees Alice has called claim() with her secret
ğ´1 on ğµğ´ to redeem Assetğµ, and she also successfully
called mutateLockLeader () on ğ´ğµ, then Bob should call
contestLeader () on ğ´ğµ before a Î” elapses to revert the tenta-
tive change. Bob then calls claim() using ğ´1 on ğ´ğµ to redeem
Assetğ´.

Importantly, Bob is able to contest when either Alice reports in-
consistent mutation signatures between contracts or if she preemp-
tively reveals her swap secret. Bobâ€™s ability to call contestLeader ()
ensures that heâ€™s able to maintain his position in the original trade if
Alice deviates from the protocol by reporting inconsistent changes.

III: Replace/Revert Phase. After the Consistency Phase has ended,
in the Replace/Revert Phase, the swap either finalizes to one be-
tween Carol and Bob or reverts back to the original swap between
Alice and Bob. Once Carol sees consistent changes with no success-
ful contestLeader () calls by Bob, she calls replaceLeader () to make
herself the new leader of the swap. Figure 1 shows an execution of
the protocol where all parties are conforming. If Bob sees Carol only
call replaceLeader () on one contract, he uses her revealed secret ğ¶1
to finalize the replacement on the other contract.

(1) When Carol sees the tentative changes are the same on
both ğ´ğµ and ğµğ´ contract, and Bob is not able to contest
anymore on both contracts 3, then before Î” elapses, she calls
replaceLeader () on both contracts with her secret ğ¶1.
(2) If Bob sees Carol only called replaceLeader () on one contract
ğµğ´(ğ´ğµ) , then within Î” he calls replaceLeader () on ğ´ğµ(ğµğ´).
(3) If Carol gives up the replacement and does not
call
(ğ‘›ğ‘œğ‘¤ âˆ’
ğ´ğµ(ğµğ´).mutation.start_time > 6 âˆ— Î”), then the tenta-
tive changes can be reverted by revertLeader () causing the
assets to be unfrozen.

replaceLeader () when she

can,

i.e.

(4) If Alice sees ğ¶1 which is passed by replaceLeader (), then
within Î” she calls claim() to claim Assetğ¶ on the ğ¶ğ´ contract.
The Replace/Revert Phase marks the point of the protocol where
Aliceâ€™s position is actually transferred to Carol. Before this phase,

3If Bob mutates a contract first, there is no contest window on that contract (He is
implicitly approving of the tentative changes). If Alice mutates a contract first, Bob is
given 2Î” to dispute that mutation.

4

Transferable Cross-Chain Options

Figure 1: In the figure, ğ‘¥ .ğ¹ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘› means party ğ‘¥ calls
ğ¹ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘› in the contract. E.g. ğ´ğ‘™ğ‘–ğ‘ğ‘’.ğ‘€ğ‘¢ğ‘¡ğ‘†ğ‘¤ğ‘ğ‘ğ´ğµ means Alice
creates the swap contract ğ´ğµ and escrows her assets. The
blue arrow depicts contract ğ´ğµ and the green arrow depicts
contract ğµğ´ and the orange one depicts contract ğ¶ğ´. The text
above each arrow depicts the state of the contract. For ex-
ample, ğ‘ ğ‘¤ğ‘ğ‘ = â„ğ´1, ğ‘Ÿğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ = ğ´ğ‘™ğ‘–ğ‘ğ‘’, ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘›ğ‘” = ğ‘“ ğ‘ğ‘™ğ‘ ğ‘’ means
ğ‘ ğ‘¤ğ‘ğ‘_â„ğ‘ğ‘ â„ğ‘™ğ‘œğ‘ğ‘˜ = â„ğ´1 , and Alice can claim the asset in the
contract if she provides preimage of â„ğ´1 . ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’ is short for
ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’_â„ğ‘ğ‘ â„ğ‘™ğ‘œğ‘ğ‘˜.

Alice has only set up a tentative transfer to Carol. If Carol changes
her mind and gives up the replacement, the tentative swap be-
tween Carol and Bob can revert back to the original one be-
tween Alice and Bob by calling revertLeader (). Instead of call-
ing revertLeader () directly, Alice and Bob can alternatively call
mutateLockLeader (),refund (),or claim() at this point in the proto-
col since these will all automatically call revertLeader (). Alice would
do this if after an unsuccessful attempt to transfer her swap, she
wants to attempt another transfer, reclaim her escrowed funds, or
exercise the swap.

Timeouts. Timeouts are critical to guarantee the correctness of
our protocol. They were omitted in the earlier protocol descriptions
for simplicity. Here, we provide the timeouts we set in each step.
The ğµğ´ contract expires at time ğ‘‡ , the last time for the leader to
send her secret to redeem the principal. The ğ´ğµ contract expires at
time ğ‘‡ + Î”.

Denote the time when mutateLockLeader () is called on ğ´ğµ(ğµğ´)
contract as ğ´ğµ(ğµğ´).mutation.start_time. After the mutation starts
on any contract, Bob is given time 2Î” to contest Aliceâ€™s mutation:
ğ´ğµ(ğµğ´).contest.timeout = ğ´ğµ(ğµğ´).mutation.start_time + 2Î”.
When Bob is able to contest, and Bob has not called
mutateLockLeader () himself, Carol cannot call replaceLeader ().
the contest period elapses, Carol has 2Î” to call
After
replaceLeader (). Here we have ğ´ğµ(ğµğ´).replace.timeout_Carol =
ğ´ğµ(ğµğ´).mutation.start_time + 4Î”.

If Carol deviates and only calls replaceLeader () on one con-
tract, we allow Bob to call replaceLeader () on the another contract.
We give Bob 2Î” more than Carol to call replaceLeader (). That is,
ğ´ğµ(ğµğ´).replace.timeout_Bob = ğ´ğµ(ğµğ´).mutation.start_time + 6Î”.
We see that it takes 6Î” from the start of a mutateLockLeader ()
in the worst case. Thus,
call
ğ´ğµ(ğµğ´).mutation.start_time + 6Î” â‰¤ ğ‘‡ âˆ’ Î”, which means
ğ´ğµ(ğµğ´).mutation.start_time â‰¤ ğ‘‡ âˆ’ 7Î”.

to finalize a replacement

The last person that is able to call mutateLockLeader () is Bob. He
is given one more Î” than Alice on each contract to call this function
in case Alice decides to just call it on one contract. The deadline for
Alice to call mutateLockLeader () should be ğ‘‡ âˆ’ 7Î”. The deadline
for Bob to call mutateLockLeader () should be ğ‘‡ âˆ’ 6Î”. Consider the
case when Alice is adversarial by not calling mutateLockLeader ()
on ğµğ´ but does call it on ğ´ğµ by ğ‘‡ âˆ’ 7Î”. If Bob is compliant, then he
calls mutateLockLeader () by ğ‘‡ âˆ’ 6Î” on the ğµğ´ contract. Because we
require ğ´ğµ.mutation.start_time â‰¤ ğ‘‡ âˆ’ 7Î”, Bob is guaranteed 6Î” to
a do a full replacement in the worst case. Conforming Carolâ€™s safety
is also guaranteed since she can give up the replacement if she finds
there is not sufficient time to call replaceLeader () then claim(). In
that case, due to the timeout of the original swap, adversarial Alice
loses her opportunity to sell her position.

For CA edge, after Carol escrows Assetğ¶ , in the worst case it
takes 7Î” to complete the replacement, (Î” to start the mutation
and 6Î” to complete the replacement). After the replacement, it
takes one Î” for Alice to redeem. Thus, the timeout for ğ¶ğ´ edge is
startLeader + 9Î”.

The reason why we have 2Î” for Bob to contest, and 2Î” more
than Carol to call replaceLeader () is that the start time of mutation
can be staggered by Î” on two contracts, which will be described in
detail in proof.

the contestLeader ()

time
4.2.1 An Optimization. Because of
in the worst case, Carol has to wait 2Î” after a
window,
mutateLockLeader () call to decide whether to release her secret
or not. We can speed up the process by adding an approveLeader ()
method. Instead of waiting for 2Î” even though Bob does not con-
test at all, once Bob sees Alice has made consistent mutations on
both edges, Bob can call approveLeader () to approve the pending
transfer. In other words, by calling approveLeader (), Bob gives up
the right to contest meaning Carol will not have to wait out the
contest window in order to call replaceLeader (). In that case, if Bob
cooperates, the transfer would be finalized sooner. If Bob doesnâ€™t
cooperate, the transfer would be finalized later but not stoppable if
Alice and Carol are conforming.

This can be accomplished by adding to the ğ´ğµ(ğµğ´) contracts an
ğ‘ğ‘ğ‘ğ‘Ÿğ‘œğ‘£ğ‘’ğ‘‘ flag indicating whether Bob has given up his ability to
call contestLeader ().

Phases II-III are the only ones affected.
We add the following instruction to the Consistency Phase:

(1) Once Bob sees Alice has called mutateLockLeader () on both
ğ´ğµ and ğµğ´ with the same change, then before a Î” elapses,
Bob should call approveLeader () on both ğ´ğµ and ğµğ´.

and to the Replace/Revert Phase:

(1) If Carol sees Bob approved the tentative consistent changes
on both ğ´ğµ and ğµğ´, then before a Î” elapses, she calls
replaceLeader () on both ğ´ğµ and ğµğ´.

If in addition to conforming to the base protocol in Section 5.1,
Bob also executes the approve step shown previously, then we call
Bob altruistic. This just indicates that Bob is willing to speed up the
termination of the protocol even if it doesnâ€™t necessarily change
his financial position.

5

AliceBobCarolNo ContestNo ContestDaniel Engel and Yingjie Xue

From this point on, we will use Protocol 4.2 to refer the protocol
in Section 4.2, Protocol 4.2.1 to the refer to the protocol 4.2.1 with
extra steps from Section 4.2.1, Protocol 4.3 to refer to the protocol
in Section 4.3, and Protocol 4.4 to refer to the protocol in Section
4.4.

4.4 Handling Multiple Candidates
When Alice decides to tentatively transfer her swap option to Carol,
it could be the case that Carol is intending to just grief Alice. In the
worst case, Alice will have her option locked for 6Î” by Carol that
simply doesnâ€™t participate in the Replace/Revert Phase of Protocol
4.2.

To combat this, Alice might want to initiate several concurrent

transfers with multiple buyers at once.

A straightforward solution to this is, after Alice gets her po-
sition back from a failed transfer with ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ğ‘– , Alice can call
ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ () again to indicate she wants to transfer her
option to a new option buyer ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ğ‘–+1. In the worst case, in this
protocol, Alice would spend 6Î” with her option locked for each
potential buyer who doesnâ€™t comply.

One question then is, can we have Alice potentially transfer her
position to multiple buyers at the same time, or with less waiting
time than 6Î” in between each new buyer? Although we cannot
let Alice transfer her option to multiple buyers simultaneously,
we can create enough overlap between each of the potential to
reduce Aliceâ€™s waiting time for each potential buyer. The protocol
description below outlines how Alice is able to reduce her waiting
time for each potential buyer to 4Î” rather than 6Î”.

The main idea of the protocol is to use to run a concurrent version
of Protocol 4.2 for each potential buyer. Alice assigns each potential
buyer a ticket (sequence number). A shared counter is synchronized
between the ğ´ğµ and ğµğ´ contracts. The shared counter assigns an
ordering to each of the potential buyers to execute their respective
versions of Protocol 4.2. In this way, it serves as a first-come first-
serve mechanism for Alice to sell her swap option.

We will use ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ğ‘– to denote the buyer who is assigned the ğ‘–-th
sequence number by Alice. On each contract ğ´ğµ and ğµğ´, each po-
tential buyer ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ğ‘– , will have their own associated state structure
ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘– , similar to Protocol 4.2. This keeps track of the state relevant
to the 3 different phases from Protocol 4.2.

The protocol is defined as follows:

â€¢ Initially counter on AB and BA contracts is initialized to 0.
â€¢ For each potential buyer, Alice assigns a unique sequence
number seq (starting from 0 and growing by 1 for each as-
signment) to them, which represents that partyâ€™s position
in the queue for a tentative replacement. If Alice assigns the
same sequence number to different parties and sends both
of them to the AB/BA contracts, the conflict is resolved via
the Consistency Phase from the original Protocol 4.2. It is
the same as when Alice deviates by sending inconsistent
mutation transactions to both contracts, in which case Bob
contests and the tentative transfer is reverted.

â€¢ Alice sends mutation transactions as in Protocol 4.2. The
main difference is that the mutation transactions now in-
clude a sequence number seq for the candidate replace-
ment. The ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ (), ğ‘ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ () functions

Figure 2: A protocol execution demonstrating why Bob
needs two more replaceLeader() rounds than Carol. If not,
then he lacks full Î” to call replaceLeader() on ğµğ´ after Carol
calls it on ğ´ğµ. Here we assume Alice has reported consistent
signatures in the Mutate Lock Phase but has reported them
a Î” apart. Colored blocks represent time periods when func-
tions can be called. The Leader suffix is excluded from the
function calls for simplicity.

4.3 Transfer Follower Position
We will now describe a protocol that allows Bob to transfer his
position in a swap with Alice, to a third-party David. The main
difference with this protocol and the previous one, is that Bob
cannot limit Aliceâ€™s optionality. Namely, he cannot unilaterally lock
the asset in the ğµğ´ contract since this would limit the optionality
Alice purchased. Effectively Alice must always be able to claim the
funds on ğµğ´ with her secret until the swap itself times out. This
weakening of the constraint that we had in the previous protocol,
allows for a much simpler protocol. It consists of 2 phases:

(1) Mutate Phase
(2) Replace/Revert Phase

the

(2) If

succeeds,

previous
revealed ğ´1

I: Mutate Phase.
(1) Bob and David agree on Assetğ· at time startFollower, similar
to the replacing leader protocol. David creates ğ·ğµ contract,
escrowing Assetğ· , setting the swap_hashlock as ğ» (ğ·1) for
Bob to redeem Assetğ· and the timeout be startFollower + 5Î”.
step
has
before Î” elapses, Bob concur-
not
and
rently
on
calls mutateLockFollower ()
ğ´ğµ
mutateLockFreeFollower () on ğµğ´ contracts,
tentatively
setting [replace_hashlock = ğ» (ğ·1)] to both contracts,
and setting candidate_sender = David.address on ğµğ´
and candidate_receiver = David.address on ğ´ğµ. We use
mutateLockFreeFollower () because on the ğ´ğµ contract, this
mutation does not lock the asset on ğ´ğµ. This is necessary to
ensure Alice does not temporarily lose her optionality.

and Alice

II: Replace/Revert Lock Phase.
(1) If David sees Bob successfully call mutateLockFollower (),
mutateLockFreeFollower () on both ğ´ğµ and ğµğ´ respectively,
then within Î” he concurrently executes replaceFollower ()
with ğ·1 on ğ´ğµ and ğµğ´ to replace Bob.

(2) If Bob sees David call replaceFollower () on either ğ´ğµ or ğµğ´,
within Î” he should call claim() on ğ·ğµ to claim Assetğ· .

6

Transferable Cross-Chain Options

all take this sequence number as parameters as part of the
mutation. If ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡ğ‘’ğ‘Ÿ == ğ‘ ğ‘’ğ‘, the transaction is accepted.
Otherwise, the transaction is rejected.
If Alice is conforming, counter should be synchronized on
AB/BA within Î”. If a tentative transfer is in progress, a new
mutation transaction with ğ‘ ğ‘’ğ‘ == ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡ğ‘’ğ‘Ÿ + 1 will be ac-
cepted only if 4Î” has elapsed after the first mutation. A
mutate transaction with ğ‘ ğ‘’ğ‘ == ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡ğ‘’ğ‘Ÿ can serve as muta-
tion transaction for a contest of the current tentative trans-
fer. After the tentative change is reverted, i.e. revertLeader()
is called, the counter is incremented by 1. This design can
be optimized by accepting the mutation transactions with
larger sequence numbers and store them in a queue for fu-
ture use. These can then take effect immediately after 4Î”
has elapsed after the current tentative mutation happens
and revertLeader() has been called. The reason why 4Î” is
sufficient interval between the execution of base protocols
for two potential buyers is that, after 4Î”, there is only 2Î”
left for the mutation to be reverted if the previous potential
buyer gives up. The later arriving buyer can use this window
to finish its consistency phase and after it ends, its replace
phase can start without waiting.

â€¢ A mutation transaction can take effect (The corresponding
candidate can call replaceLeader() ) only after the previous
mutation transaction has expired, meaning it is reverted and
Alice regains the position. Then after that the new candidate
can execute Protocol 4.2 to replace Alice.

The protocol for transferring the follower position to multiple

candidates is similar.

5 SECURITY PROPERTIES AND PROOF
5.1 General Transfer Properties
Our leader and follower transfer protocols overlap in some proper-
ties they satisfy. We outline those properties here.

Recall that assets escrowed in the contracts are called principal.
The principals involved in the swap option are always Aliceâ€™s prin-
cipal and Bobâ€™s principal. Here, the original option provider is Bob
(follower) and the option owner is Alice (leader). In the leader trans-
fer protocol and the follower transfer protocol, what is transferred
is a position in the swap option. If Alice transfers her position it is
to Carol, and Bob to David. We say one party owns a position in
an option if they are option owner (Alice/Carol): one can release a
secret, receiving Bobâ€™s principal by relinquishing Aliceâ€™s, or let the
option expire and Aliceâ€™s principal is refunded to them, or option
provider (Bob/David): one provides the option owner the right, but
not obligation, for the exchange of Aliceâ€™s principal with Bobâ€™s.

From now on, we call a leader/follower who wants to transfer
their position as position seller, and the one who wants to replace
them as position buyer.

â€¢ Liveness: In a transfer of positions, if all parties are conform-
ing, then leader/follower transfers their position to a buyer
and the position seller gets proper payment from the buyer.
â€¢ Transfer independence: A compliant position seller (leader/-
follower) transferring their position to another compliant
position buyer, can successfully transfer their position with-
out the cooperation of a third counterparty (follower/leader).

7

â€¢ Non-blocking transfer with adversarial counterparty: If a com-
pliant position seller (leader/follower) is transferring their
position to another compliant position buyer, a third coun-
terparty (follower/leader) cannot interfere with the transfer.
â€¢ Transfer atomicity: If a compliant position seller (leader/fol-
lower) loses their position to the buyer, then they receive
the expected principal from the position buyer.

â€¢ No UNDERWATER for a conforming party (Safety): UNDER-
WATER means a party loses their outgoing principal without
getting their incoming principal. No UNDERWATER guaran-
tees a conforming partyâ€™s safety since it will never end up
with losing their principal without getting principals from
others.

Theorem 1. Protocol 4.2 and 4.3 satisfy No UNDERWATER for

Alice, Bob, Carol and David:

â€¢ If Alice is conforming, then if she loses her principal, she either

gets Bobâ€™s or Carolâ€™s principal, or both.

â€¢ If Bob is conforming, then if he loses his principal, he gets

Aliceâ€™s principal or Davidâ€™s, or both.

â€¢ If Carol is conforming, then if she loses her principal, she gets

Aliceâ€™s principal or Bobâ€™s principal, or both.

â€¢ If David is conforming, then if he loses his principal, he gets

Aliceâ€™s principal or Bobâ€™s principal, or both.

Proof. See Appendix .2.2.

â–¡

5.2 Leader Transfer Properties
We first demonstrate how our leader transfer protocol satisfies the
general transfer properties from 5.1.

Because the detailed proofs of the following results are long and
similar to those that we will see for the follower transfer protocol
5.3, we omit them here. See the Appendix Section .2 for details.

Theorem 2. Protocol 4.2 satisfies liveness: If Alice, Bob, and Carol
are all conforming, then Alice gets Carolâ€™s principal, Carol gets Aliceâ€™s
position, and Bob maintains his position.

Theorem 3. Protocol 4.2 satisfies transfer independence: Alice can

transfer her position to Carol without Bobâ€™s participation.

Theorem 4. Protocol 4.2 satisfies non-blocking transfer: Alice can

transfer her position to Carol even if Bob is adversarial.

Theorem 5. Protocol 4.2 satisfies transfer atomicity: If Alice loses

her position in the swap, then she can claim Carolâ€™s principal.

In addition to the properties from Section 5.1, it is desirable for

a leader transfer protocol to have one additional property.

Given two protocols ğ‘ƒ, ğ‘ƒ â€² that satisfy non-blocking transfer with
adversarial counterparty (Bob), Bob is called altruistic in ğ‘ƒ â€² with
respect to ğ‘ƒ if Bob conforming in ğ‘ƒ â€² terminates faster than Bob
conforming in ğ‘ƒ in executions where all parties are conforming.
Importantly, it is not necessary that Bob should be incentivized to
choose to follow ğ‘ƒ â€² over ğ‘ƒ.

When Alice and Carol are conforming, even though adversarial
Bob cannot block the transfer, Bob can delay the transfer for a
few rounds. The following next property we introduce is a slightly
stronger version of non-blocking property that is ideal for a leader
transfer protocol.

(1) Timely transfer with altruistic Bob: A protocol ğ‘ƒ â€² satisfies this
property if there exists a protocol ğ‘ƒ satisfying non-blocking
transfer with adversarial counterparty (Bob) where Bob is
altruistic in ğ‘ƒ â€² with respect to ğ‘ƒ.

Theorem 6. Protocol 4.2.1 satisfies timely transfer with altruistic

Bob.

Proof. Since Protocol 4.2 is non-blocking by Theorem 4, it is
enough to show that Bob is altruistic in Protocol 4.2.1 with respect
to Protocol 4.2. By assumption all parties are conforming. In both
protocols, Carol will have created ğ‘€ğ‘¢ğ‘¡ğ‘†ğ‘¤ğ‘ğ‘ğ¶ğ´ by ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + Î”
and Alice will have called ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ () on ğ´ğµ and ğµğ´ by
ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 2Î”. In Protocol 4.2.1 Bob now calls ğ‘ğ‘ğ‘ğ‘Ÿğ‘œğ‘£ğ‘’ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ ()
on ğ‘€ğ‘¢ğ‘¡ğ‘†ğ‘¤ğ‘ğ‘ğ´ğµ and ğ‘€ğ‘¢ğ‘¡ğ‘†ğ‘¤ğ‘ğ‘ğµğ´ by ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 3Î”. Thus the
Replace/Revert Phase for Protocol 4.2.1 begins because Bob skips
the contest phase. In Protocol 4.2, since Alice is compliant, her
signatures on ğ‘€ğ‘¢ğ‘¡ğ‘†ğ‘¤ğ‘ğ‘ğ´ğµ and ğ‘€ğ‘¢ğ‘¡ğ‘†ğ‘¤ğ‘ğ‘ğµğ´ are consistent. Thus
Bob wonâ€™t call ğ‘ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ () on ğ‘€ğ‘¢ğ‘¡ğ‘†ğ‘¤ğ‘ğ‘ğ´ğµ or ğ‘€ğ‘¢ğ‘¡ğ‘†ğ‘¤ğ‘ğ‘ğµğ´ during
this 2Î” Consistency Phase. Carol waits 2Î” after ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 2Î”.
In this case, the Replace/Revert Phase begins at ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 4Î”.
Thus Bob is altruistic in Protocol 4.2.1 with respect to Protocol
â–¡
4.2.

5.3 Follower Transfer Properties
We now demonstrate how our follower transfer protocol also satis-
fies the general transfer properties from Section 5.1.

Again, the proofs are included in the Appendix Section .2.

Theorem 7. Protocol 4.3 satisfies liveness: If Alice, Bob, and David
are all conforming, and Alice doesnâ€™t reveal ğ´1, then Bob gets Davidâ€™s
principal, David gets Bobâ€™s position, and Alice maintains her position.

Theorem 8. Protocol 4.3 satisfies transfer independence: Bob can

transfer his position to David without Aliceâ€™s participation.

Theorem 9. Protocol 4.3 satisfies non-blocking transfer: Bob can

transfer his position to David even if Alice is adversarial.

Note that Alice is not adversarial by choosing to reveal her
secret ğ´1 since this just means she is exercising her option. This
is consistent with how she should behave in the original swap
protocol.

Theorem 10. Protocol 4.3 satisfies transfer atomicity: If Bob loses

his swap position, then he can claim Davidâ€™s principal.

On top of the base properties described in Section 5.1, any pro-

tocol transferring Bobâ€™s position should also be:

(1) Optionality preserving: If Alice is compliant, she never loses

her ability to exercise the original swap option.

Namely, it is unfair for Alice to temporarily lose her right to use

her option without her consent.

Theorem 11. Protocol 4.3 is optionality preserving.

Proof. Itâ€™s

enough to show that Alice

claim the principal on ğµğ´,
by timeout ğ‘‡ . The added functions
namely ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¹ğ‘Ÿğ‘’ğ‘’ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ (),ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ (),

can always
if she reveals her secret ğ´1
from Protocol 4.3,
and

Daniel Engel and Yingjie Xue

ğ‘Ÿğ‘’ğ‘£ğ‘’ğ‘Ÿğ‘¡ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ () only modify the state of ğ‘“ ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ _ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘›.
However, any call to ğ‘ğ‘™ğ‘ğ‘–ğ‘š() on ğµğ´ doesnâ€™t depend on the state of
ğ‘“ ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ _ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘›. Namely, any call to ğ‘ğ‘™ğ‘ğ‘–ğ‘š() is independent of
the state of the follower transfer protocol. So its enough that Alice
â–¡
reveal ğ´1 before ğ‘‡ .

There is nothing preventing both Protocol 4.2 and Protocol 4.3 to
be run concurrently. That is, if Alice wants to transfer her position
to Carol, and Bob wants to transfer his position to David, they can
both do so simultaneously. This follows immediately from the fact
that the parts of the contracts managing the state for each individual
protocol are entirely disjoint and cannot affect each other.

5.4 Leader Transfer (Multiple Buyers)

Properties

Besides the general properties mentioned above, the protocol that
handles multiple candidate buyers (Protocol 4.4) satisfies the fol-
lowing unique properties.

â€¢ First-come first-serve (FCFS): If Alice is conforming (the
buyer who tentatively pays to Alice earlier gets a smaller se-
quence number), then the earlier arriving buyer has priority
to replace Aliceâ€™s position.

â€¢ Starvation freedom: If Alice is conforming and a conforming
buyer, say ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ ğ‘— , gets a sequence number ğ‘—, then ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ ğ‘— can
replace Aliceâ€™s position if she is conforming and all ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ğ‘–
where ğ‘– < ğ‘— gives up the replacement.

Theorem 12. If Alice is conforming, the counter on both contracts

are synchronized with inconsistency for at most Î”.

Proof. The counter is initialized as 0 and it incremented only
after revertLeader() is enabled. The revertLeader() is enabled only
when 6Î” elapses after the start time of mutateLockLeader() being
called. Since the start time of mutateLock() on both contracts are
staggered by at most Î”, when the counter is incremented on one
contract, it can be incremented on another contract within Î”. â–¡

Theorem 13. If Alice is conforming, Protocol 4.4 satisfies FCFS.

Proof. If Alice is conforming, she issues mutateLockLeader()
transactions with ascending sequence numbers to different poten-
tial buyers, in an arrive-earlier-smaller-sequence manner. For every
potential buyer, a base transfer protocol (Protocol 4.2) is run as
normal. Without loss of generality, at time ğ‘¡, suppose on AB con-
tract the counter is ğ‘– and on BA the counter is ğ‘— = ğ‘– âˆ’ 1. On AB,
ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ğ‘– has priority. By Theorem 12, we know the counter on ğµğ´
will become ğ‘– within Î” and then ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ğ‘– has priority. The reason
why the counter is incremented from ğ‘— to ğ‘– is that ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ ğ‘— gives up
the replacement. Then we see on both contracts ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ğ‘– has priority.
It is obvious ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ğ‘˜ where ğ‘˜ â‰¥ ğ‘– + 1 cannot start their replacement
unless ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ğ‘– gives up, i.e. the replacement phase ends and the mu-
tation is reverted, since the counter is ğ‘– now. Therefore the protocol
â–¡
satisfies FCFS.

Theorem 14. If Alice is conforming, Protocol 4.4 is starvation free.

Proof. Similar to Proof 5.4, if Alice is conforming and a buyer
ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ ğ‘— , gets a sequence number ğ‘—, then the base protocol for ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ ğ‘—
can start underlying othersâ€™ base protocols. If all ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ğ‘– where ğ‘– < ğ‘—

8

Transferable Cross-Chain Options

gives up the replacement, then the counter is incremented to ğ‘— and
â–¡
then ğ¶ğ‘ğ‘Ÿğ‘œğ‘™ ğ‘— can call replaceLeader() to replace Alice.

6 RELATED WORK
Cross-chain options have their origin in cross-chain atomic swap
protocols. A cross-chain atomic swap enables two parties to ex-
change assets across different blockchains. An atomic swap is im-
plemented via hashed timelock contracts(HTLC)[17]. There are a
variety of protocols proposed [1, 8, 10, 24] and implemented [4, 6].
Herlihy et al. proposed protocols for atomic multi-party swaps [13]
and more general atomic cross-chain deals [14].

Several researchers [11, 12, 16, 25] have noted that most two-
party swap protocols effectively act as poorly-designed options [15],
because one party has the power to decide whether to go through
with the agreed-upon swap without compensation for its counter-
party.

A number of proposals [7, 11, 12, 16, 18, 23, 25] address the
problem of optionality in cross-chain atomic swaps by introducing
some form of premium payment, where a party that chooses not
to complete the swap pays a premium to the counterparty. Robin-
son [19] proposes to reduce the influence of optionality by splitting
each swap into a sequence of very small swaps. Han et al. [11]
quantified optionality unfairness in atomic swap using the Cox-
Ross-Rubinstein option pricing model [5], treating the atomic swap
as an American-style option. The Black-Scholes (BS) Model [3] can
be used to estimate the value of European-style options.

Liu [16] proposed an alternative approach where option
providers are are paid up-front for providing optionality, as in
the conventional options market. In this protocol, Alice explicitly
purchases an option from Bob by paying him an nonrefundable
premium. Tefagh et al. [21] proposed a similar protocol which en-
ables Alice to deposit her principal later than Bob. None of these
works have considered how to close an option ownerâ€™s position by
transferring that option to a third party.

There are protocols that allow blockchains to communicate
(cross-chain proofs), however they either rely on external third
parties [9] or their applicability requires the introduction of cen-
tralized services, modifications to existing software, and doesnâ€™t
guarantee reliable message delivery [20].

7 REMARKS AND CONCLUSIONS
The transferable swap protocols presented here have certain limita-
tions. As described earlier, the protocols require multiple time-out
periods. If all parties are responsive, these timeouts should not affect
the performance of normal executions, but they could lead to long
worst-case executions. The protocols also include a â€œhard timeoutâ€
where Alice and Carol pause to give Bob a chance to object to a mal-
formed transfer. Bob can be paid an incentive to respond quickly,
but he could slow down (but not stop) the protocols execution.

The ability for Bob to be able to report inconsistent state changes
between multiple blockchains is integral to the design of our pro-
tocols. Adding such functionality was not necessary in simpler
cross-chain protocols like the two-party swap. In future work, we
hope to better understand how the complexity of a cross-chain deal
relates to the necessity of this consistency phase.

9

REFERENCES
[1] AtomicDEX. November, 2019.

First AtomicDEX Stress Test Success-
fully Completed. https://atomicdex.io/first-atomicdex-stress-test-successfully-
completed/.

[2] Philip A Bernstein, Vassos Hadzilacos, and Nathan Goodman. 1986. Concurrency
control and recovery in database systems. Addison-Wesley Longman Publishing
Co., Inc., Boston, MA, USA.

[3] Fischer Black and Myron Scholes. 2019. The pricing of options and corporate
liabilities. In World Scientific Reference on Contingent Claims Analysis in Corporate
Finance: Volume 1: Foundations of CCA and Equity Valuation. World Scientific,
3â€“21.

[4] Sean Bowe and Daira Hopwood. 2017. Hashed Time-Locked Contract transac-
tions. https://github.com/bitcoin/bips/blob/master/bip-0199.mediawiki. As of 9
January 2018.

[5] John C Cox, Stephen A Ross, and Mark Rubinstein. 1979. Option pricing: A

simplified approach. Journal of financial Economics 7, 3 (1979), 229â€“263.
[6] Decred. 2018. https://github.com/decred/atomicswap. As of 18 February 2021.
[7] Thomas Eizinger, Lloyd Fournier, and Phillip Hoenisch. 2018. The state
of atomic swaps. http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/
atomic-swaps/.

[8] Altcoin.io Exchange. October 2017.

The First Ethereum <>Bitcoin
Atomic Swap. https://blog.altcoin.io/the-first-ethereum-bitcoin-atomic-swap-
79befb8373a8. Altcoin.io Exchange.

[9] Christopher Goes. 2020. The interblockchain communication protocol: An

overview. arXiv preprint arXiv:2006.15918 (2020).

[10] Trey Griffith. July, 2018. Sparkswap: Trade across blockchains without cus-
tody risk. https://medium.com/sparkswap/sparkswap-trade-across-blockchans-
without-custody-risk-a6bfe08013e8.

[11] Runchao Han, Haoyu Lin, and Jiangshan Yu. 2019. On the optionality and
fairness of Atomic Swaps. In Proceedings of the 1st ACM Conference on Advances
in Financial Technologies. ACM, Zurich Switzerland, 62â€“75. https://doi.org/10.
1145/3318041.3355460

[12] Ethan Heilman, Sebastien Lipmann, and Sharon Goldberg. 2019. The arwen

trading protocols. https://www.arwen.io/whitepaper.pdf

[13] Maurice Herlihy. 2018. Atomic cross-chain swaps. In Proceedings of the 2018 ACM
symposium on principles of distributed computing (PODC â€™18). ACM, New York,
NY, USA, 245â€“254. https://doi.org/10.1145/3212734.3212736 Number of pages:
10 Place: Egham, United Kingdom tex.acmid: 3212736.

[14] Maurice Herlihy, Barbara Liskov, and Liuba Shrira. 2019. Cross-Chain Deals and
Adversarial Commerce. Proc. VLDB Endow. 13, 2 (Oct. 2019), 100â€“113. https:
//doi.org/10.14778/3364324.3364326

[15] Desmond J. Higham. 2009. An introduction to financial option valuation: math-
ematics, stochastics and computation (4. printing ed.). Cambridge Univ. Press,
Cambridge.

[16] James A. Liu. 2020.

Atomic Swaptions: Cryptocurrency Derivatives.
arXiv:1807.08644 [cs, q-fin] (March 2020). http://arxiv.org/abs/1807.08644 arXiv:
1807.08644.

[17] Tier Nolan. May, 2013. Alt chains and atomic transfers. https://bitcointalk.org/

index.php?topic=193281.0. Bitcoin Forum.

[18] Komodo Platform. July,2019. Advanced blockchain technology, focused on free-
dom. https://docs.komodoplatform.com/basic-docs/start-here/core-technology-
discussions/introduction.html#note-on-changes-since-whitepaper-creation-
cr-2019.

[19] Dan Robinson. 2019. HTLCs Considered Harmful. http://diyhpl.us/wiki/

transcripts/stanford-blockchain-conference/2019/htlcs-considered-harmful/.

[20] Peter Robinson. 2021. Survey of crosschain communications protocols. Computer

Networks 200 (2021), 108488.

[21] Mojtaba Tefagh, Fateme Bagheri, Amirhossein Khajehpour, and Melika Abdi.
October, 2020. Capital-free Futures Arbitrage. https://doi.org/10.13140/RG.2.2.
31609.90729/1

[22] Jiahua Xu, Damien Ackerer, and Alevtina Dubovitskaya. 2021. A Game-Theoretic
Analysis of Cross-Chain Atomic Swaps with HTLCs. arXiv:2011.11325 [cs] (April
2021). http://arxiv.org/abs/2011.11325 arXiv: 2011.11325.

[23] Yingjie Xue and Maurice Herlihy. 2021. Hedging Against Sore Loser Attacks
in Cross-Chain Transactions. In ACM Symposium on Principles of Distributed
Computing.

[24] Jake Yocom-Piatt. September, 2017. On-Chain Atomic Swaps. https://blog.decred.

org/2017/09/20/On-Chain-Atomic-Swaps/. Decred Blog.

[25] ZmnSCPxj. 2018. An Argument For Single-Asset Lightning Network. https://lists.
linuxfoundation.org/pipermail/lightning-dev/2018-December/001752.html. As
of 10 January 2021.

APPENDIX
.1 Contracts

1
2
3
4
5

6
7
8
9

10

11
12
13
14
15

16
17
18
19
20
21
22
23

24
25
26
27
28
29
30

31
32
33
34
35
36
37
38
39
40
41
42
43
44

45
46
47
48
49
50
51
52
53
54
55
56
57
58

//Assume the following:

// now is the time the transaction is included in a block
// A clear() function on the Mutation struct that resets all

fields to default values

// A hash function H
// || denotes concatenation of inputs to a hash function
// A sig (digital signature) object with the following functions
// valid(address) -> bool, returns true if valid signature by

address

// msg() -> [hash], returns an array of hashlocks if the
signature signed such a message, null otherwise

contract MutSwapAB{

struct FollowerMutation{

//Signature by follower to allow candidate to take its

position

Sig voucher;
//Candidate party to replace follower
address candidate_receiver;
//Hashlock used to replace follower
uint replace_hash_lock;
//Time mutation begins
uint start_time;
//Flag for freezing asset when a tentative replacement is

happening

bool mutating;
//Controls whether asset is locked or not during mutation
bool can_lock_asset;

}

struct LeaderMutation{

//Signature by follower to allow candidate to take its

position

Sig voucher;
//Candidate party to replace follower
address candidate_sender;
//Party who called mutateLockLeader
address mutator;
//Hashlock used to replace follower
uint replace_hash_lock;
//Hashlock for exercising option
uint swap_hash_lock;
//Time mutation begins
uint start_time;
//Used for optimistic execution of protocol
bool approved;
//Flag for freezing asset when a tentative replacement is

happening

bool mutating;
//Controls whether asset is locked or not during mutation
bool can_lock_asset;

}

//State information for base swap protocol
Asset asset; //Reference to preferred token contract
address sender; //Current sender of escrowed funds
address receiver; //Current receiver of escrowed funds
address leader; //Leader of the original swap protocol
address follower; //Follower of the original swap protocol
uint swap_hash_lock; //Hashlock of the swap protocol
uint T_AB; //Timeout for locked asset

10

59

60
61
62
63
64
65
66
67
68
69
70

71

72

73
74
75
76
77
78
79
80
81
82
83
84
85

86
87
88
89
90
91
92
93

94
95
96
97
98
99
100
101

102
103
104
105
106
107
108
109
110
111

112
113

114
115
116
117

Daniel Engel and Yingjie Xue

uint delta = 10 minutes; //Assumed worst case transaction

inclusion time (Is arbitrary)

//State info associated with mutable leader position
LeaderMutation leader_mutation;

//State info associated with mutable follower position
FollowerMutation follower_mutation;

//Controls whether follower/leader positions can be changed
bool mutable;

function MutSwapAB(Asset _asset,uint start,uint dT,address

_sender,address _receiver,uint _swap_hash_lock,address
_leader,address _follower,bool _mutable){

require(msg.sender == _sender); //Sender can only escrow

their own funds

require(leader != follower); //Leader and follower should

be distinct

require(leader == _sender);
require(follower == _receiver);

this.mutable = _mutable;

//Inital mutation states
leader_mutation.mutating = false;
leader_mutation.approved = false;
follower_mutation.mutating = false;

sender = _sender;
receiver = _receiver;
swap_hash_lock = _swap_hash_lock; //Hashlock for the

initial swap
leader = _leader;
follower = _follower;
asset = _asset;
asset.send(address(this));
T_AB = start + (dT+1)*delta; //Sender is Alice

if(mutable){

//For AB contract, asset is actively locked during

leader and follower transfer
leader_mutation.can_lock_asset = true;
follower_mutation.can_lock_asset = true;

}

}

function claim(string secret){

//If a previous mutation lock was never completed, revert

to original swap

if(mutable){

if(leader_mutation.mutating){

revertLeader();

}
if(follower_mutation.mutating){

revertFollower();

}

}

require(msg.sender == receiver.id); //Only receiver can

call claim

require(now <= T_AB); //Must be before timeout
require(H(secret) == swap_hash_lock); //Claim conditional

on revealing secret

asset.send(receiver);

}

function refund(){

Transferable Cross-Chain Options

118
119

120
121
122
123
124
125
126
127
128
129

130
131
132
133
134

135
136
137

138
139
140
141
142

143

144

145
146
147

148
149
150
151

152

153
154

155
156
157
158
159

160
161
162

163
164
165

166
167
168
169
170
171

//If a previous mutation lock was never completed, revert

to original swap

if(mutable){

if(leader_mutation.mutating){

revertLeader();

}
if(follower_mutation.mutating){

revertFollower();

}

}

require(msg.sender == sender); //Only sender can call

refund

require(now > T_AB); //After lock has timed out
asset.send(sender);

}

function mutateLockLeader(Sig sig,address _candidate_sender,

uint _replace_hash_lock,uint _swap_hash_lock){

require(mutable);

//If a previous mutation lock is stale, then call revert
to allow for a new mutation lock to be made

if(leader_mutation.mutating){

revertLeader();

}

require(!leader_mutation.mutating); //Only one

mutate_lock at a time

require(msg.sender == sender || msg.sender == receiver);

//Only sender or receiver can mutate

if(msg.sender == leader){ //Alice has less time to call

mutateLock

require(T_AB >= now + 8*delta);

}else if(msg.sender == follower){

//Bob is given more time to call mutateLock in

response to Alice

require(T_AB >= now + 7*delta);

}

require(sig.valid(leader)); //Requres Alice's sig of

Carol's hashlocks

require(sig.msg() == [_replace_hash_lock,_swap_hash_lock
]); //The msg has to just be the candidate's
hashlocks

leader_mutating.mutating = true;
leader_mutating.voucher = sig; //Proof that candidate was

approved

leader_mutating.candidate_sender = _candidate;
leader_mutating.mutator = msg.sender;
leader_mutating.replace_hash_lock = _replace_hash_lock;
leader_mutating.swap_hash_lock = _swap_hash_lock;
leader_mutating.start_time = now; //Used for flexible

timeouts in the transfer

}

function mutateLockFollower(Sig sig,address

_candidate_receiver, uint _replace_hash_lock){

require(mutable);

//If a previous mutation lock is stale, then call revert
to allow for a new mutation lock to be made

if(follower_mutation.mutating){

revertFollower();

}

require(msg.sender == follower); //Only Bob can call
require(!follower_mutation.mutating);

172

173
174
175

176
177
178

179

180
181

182
183
184
185
186
187
188
189
190

191

192
193

194
195

196
197
198
199

200

201

202

203
204
205
206
207
208
209

210
211
212
213
214
215
216
217
218
219
220

11

require(follower_mutation.lock_asset); //Only can call

mutateLockFollower on AB contract

require(sig.valid(follower)); //Bob's valid signature
require(sig.msg() == [_replace_hash_lock]);
require(T_AB >= now + 3*delta); //Need enough time for

David to call claim

follower_mutation.mutating = true;
follower_mutation.voucher = sig; //Proof that candidate

was approved by previous owner of the position

follower_mutation.candidate_receiver =

_candidate_receiver;

follower_mutation.replace_hash_lock = _replace_hash_lock;
follower_mutation.start_time = now; //Used for flexible

timeouts in the transfer

}

function replaceLeader(string secret){

require(mutable);
require(leader_mutation.mutating);
bool candidate_round = false;
bool follower_round = false;

//If Bob mutated, can skip contesting phases since he is

implicitly approving of the signature he called
mutateLock with

if(leader_mutation.mutator == follower || (

leader_mutation.mutator == leader &&
leader_mutation.approved)){ //Can immediately call
replace once Bob has mutated

//Carol can replace once Bob has called mutate
candidate_round = (msg.sender == leader_mutation.
candidate_sender) && (4*delta >= now -
leader_mutation.start_time > 0);

//Bob can call replace
follower_round = (msg.sender == follower) && (6*delta
>= now - leader_mutation.start_time > 0);

}
else{ //Contesting (pessimistic case)

//Carol can replace in round right after last chance

at contesting

candidate_round = (msg.sender == leader_mutation.
candidate_sender) && (4*delta >= now -
leader_mutation.start_time > 2*delta);
//Bob can replace in the 3 rounds right after last

chance at mutating round

follower_round = (msg.sender == follower) && (6*delta
>= now - leader_mutation.start_time>0);

}

require(candidate_round || follower_round);
require(H(secret) == leader_mutation.replace_hash_lock);

sender = leader_mutation.candidate_sender; //Carol takes

refund optionality from Alice
swap_hash_lock = mutation.swap_hash_lock;

leader_mutation.approved = false;
leader_mutation.mutating = false;
leader_mutation.mutation.clear();

}

//If no contesting has occurred, transfer can be complete
function replaceFollower(string secret){

require(mutable);
require(follower_mutation.mutating);

221

222
223

224
225

226
227
228
229
230
231

232

233
234
235
236

237

238

239

240

241

242

243

244
245
246
247
248
249
250
251

252
253
254
255

256

257

258
259
260
261
262

263

264
265
266
267

require(2*delta >= now - follower_mutation.start_time >

0); //2 rounds given for replacement

require(H(secret) == follower_mutation.replace_hash_lock)

;

receiever = follower_mutatation.candidate_receiver; //

David takes refund optionality from Bob

follower_mutatation.clear();
follower_mutation.mutating = false;

}

//Contest if transferring party tries to transfer to two

different parties simultaneously

//Note this method only does something if it can be proved

that Alice lied

//This method can't do anything if Alice is honest
function contestLeader(Sig sig,string secret){

require(mutable);
require(msg.sender == follower); //Only allow Bob to call

this

require(leader_mutation.mutating); //Can only contest a

mutation if one has occured

require(!leader_mutation.approved); //Cannot contest

after approval

require(leader_mutation.mutator == leader); //Can only
contest a mutation when Alice called it, not Bob

require(2*delta >= now - leader_mutation.start_time > 0);

//Can contest only in the 2 rounds after mutation

//Can contest if Alice creates two inconsistent

signatures or tries to reveal preimage of hashlock
too early

require(sig.valid(leader) || H(secret) == swap_hash_lock)

; //Make sure Alice actually signed the sig
if(sig != leader_mutation.voucher || H(secret) ==
swap_hash_lock){ //Checks if Alice reported
inconsistent sigs

leader_mutation.clear();
leader_mutation.mutating = false;

}

}

//Issue is really in the sequential consistent case
//Bob can call approve in any next two rounds after a

mutation

function approveLeader(){

require(mutable);
require(msg.sender == follower); //Only Bob can approve
require(leader_mutation.mutating); //Can only approve

after a mutation has begun

require(leader_mutation.mutator == leader); //Can only

call approve when Alice was the one who called
mutate

require(2*delta >= now - leader_mutation.start_time > 0);

//Can approve only in the 2 rounds after mutation

leader_mutation.approved = true;

}

//If replacement doesn't happen quickly enough, can revert

back to the old swap

//Isn't called directly in order to save an extra round of

the protocol
function revertLeader(){
require(mutable);
require(leader_mutation.mutating);
require(now - leader_mutation.start_time > 6*delta);

Daniel Engel and Yingjie Xue

leader_mutation.approved = false;
leader_mutation.mutating = false;
leader_mutation.clear();

}

//If replacement doesn't happen quickly enough, can revert

back to the old swap

//Isn't called directly in order to save an extra round of

the protocol

function revertFollower(){
require(mutable);
require(follower_mutation.mutating);
require(now - follower_mutation.start_time > 2*delta);

follower_mutation.mutating = false;
follower_mutation.clear();

}

}

//Assume the following:

// now is the time the transaction is included in a block
// A clear() function on the Mutation struct that resets all

fields to default values

// A hash function H
// || denotes concatenation of inputs to a hash function
// A sig (digital signature) object with the following functions
// valid(address) -> bool, returns true if valid signature by

address

// msg() -> [hash], returns an array of hashlocks if the
signature signed such a message, null otherwise

contract MutSwapBA{

struct FollowerMutation{

//Signature by follower to allow candidate to take its

position

Sig voucher;
//Candidate party to replace follower
address candidate_sender;
//Hashlock used to replace follower
uint replace_hash_lock;
//Time mutation begins
uint start_time;
//Flag for freezing asset when a tentative replacement is

happening

bool mutating;
//Controls whether asset is locked or not during mutation
bool can_lock_asset;

}

struct LeaderMutation{

//Signature by follower to allow candidate to take its

position

Sig voucher;
//Candidate party to replace follower
address candidate_receiver;
//Party who called mutateLockLeader
address mutator;
//Hashlock used to replace follower
uint replace_hash_lock;
//Hashlock for exercising option
uint swap_hash_lock;
//Time mutation begins
uint start_time;
//Used for optimistic execution of protocol

268
269
270
271
272
273
274

275

276
277
278
279
280
281
282
283
284
285

1
2
3
4
5

6
7
8
9

10

11
12
13
14
15

16
17
18
19
20
21
22
23

24
25
26
27
28
29
30

31
32
33
34
35
36
37
38
39
40
41
42

12

Transferable Cross-Chain Options

43
44

45
46
47
48
49
50
51
52
53
54
55
56
57
58
59

60
61
62
63
64
65
66
67
68
69
70

71

72

73
74
75
76
77
78
79
80
81
82
83
84
85

86
87
88
89
90
91
92
93
94

95
96
97
98
99
100

101

bool approved;
//Flag for freezing asset when a tentative replacement is

happening

bool mutating;
//Controls whether asset is locked or not during mutation
bool can_lock_asset;

}

//State information for base swap protocol
Asset asset; //Reference to preferred token contract
address sender; //Current sender of escrowed funds
address receiver; //Current receiver of escrowed funds
address leader; //Leader of the original swap protocol
address follower; //Follower of the original swap protocol
uint swap_hash_lock; //Hashlock of the swap protocol
uint T_BA; //Timeout for locked asset
uint delta = 10 minutes; //Assumed worst case transaction

inclusion time

//State info associated with mutable leader position
LeaderMutation leader_mutation;

//State info associated with mutable follower position
FollowerMutation follower_mutation;

//Controls whether follower/leader positions can be changed
bool mutable;

function MutSwapBA(Asset _asset,uint start,uint dT,address

_sender,address _receiver,uint _swap_hash_lock,address
_leader,address _follower,bool _mutable){

require(msg.sender == _sender); //Sender can only escrow

their own funds

require(leader != follower); //Leader and follower should

be distinct

require(follower == _sender);
require(leader == _receiver);

this.mutable = _mutable;

//Inital mutation states
leader_mutation.mutating = false;
leader_mutation.approved = false;
follower_mutation.mutating = false;

sender = _sender;
receiver = _receiver;
swap_hash_lock = _swap_hash_lock; //Hashlock for the

initial swap
leader = _leader;
follower = _follower;
asset = _asset;
asset.send(address(this));
T_BA = start + dT*delta;

if(mutable){

leader_mutation.lock_asset = true;
follower_mutatation.lock_asset = false; //Prevents

Bob from denying Alice her optionality by
locking her asset

}

}

function claim(string secret){

//If a previous mutation lock was never completed, revert

to original swap

if(mutable){

13

102
103
104
105
106
107

108
109

110
111
112
113
114
115

116
117
118
119
120
121
122
123
124
125

126
127
128
129
130

131
132
133

134
135
136
137
138

139

140

141
142
143

144
145
146
147

148

149
150

151
152
153
154
155

if(leader_mutation.mutating){

revertLeader();

}

}

require(msg.sender == receiver.id); //Only receiver can

call claim

require(now <= T_BA); //Must be before timeout
require(H(secret) == swap_hash_lock); //Claim conditional

on revealing secret

asset.send(receiver);

}

function refund(){

//If a previous mutation lock was never completed, revert

to original swap

if(mutable){

if(leader_mutation.mutating){

revertLeader();

}
if(follower_mutation.mutating){

revertFollower();

}

}

require(msg.sender == sender); //Only sender can call

refund

require(now > T_BA); //After lock has timed out
asset.send(sender);

}

function mutateLockLeader(Sig sig,address _candidate_receiver
, uint _replace_hash_lock,uint _swap_hash_lock){

require(mutable);

//If a previous mutation lock is stale, then call revert
to allow for a new mutation lock to be made

if(leader_mutation.mutating){

revertLeader();

}

require(!leader_mutation.mutating); //Only one

mutate_lock at a time

require(msg.sender == sender || msg.sender == receiver);

//Only sender or receiver can mutate

if(msg.sender == leader){ //Alice has less time to call

mutateLock

require(T_BA >= now + 7*delta);

}else if(msg.sender == follower){

//Bob is given more time to call mutateLock in

response to Alice

require(T_BA >= now + 6*delta);

}

require(sig.valid(leader)); //Requres Alice's sig of

Carol's hashlocks

require(sig.msg() == [_replace_hash_lock,_swap_hash_lock
]); //The msg has to just be the candidate's
hashlocks

leader_mutating.mutating = true;
leader_mutating.voucher = sig; //Proof that candidate was

approved

leader_mutating.candidate = _candidate_receiver;
leader_mutating.mutator = msg.sender;
leader_mutating.replace_hash_lock = _replace_hash_lock;
leader_mutating.swap_hash_lock = _swap_hash_lock;
leader_mutating.start_time = now; //Used for flexible

timeouts in the transfer

156
157
158
159

160

161
162
163

164
165
166
167
168

169
170
171

172
173
174

175
176
177
178
179
180
181
182
183

184

185
186

187
188

189
190
191
192

193

194

195

196
197
198
199
200
201
202

203
204

}

//Provides similar functionality to mutateLockLeader but

doesn't lock the escrowed resource from being locked

function mutateLockFreeFollower(Sig sig,address

_candidate_sender,uint _replace_hash_lock){

require(mutable);

require(msg.sender == follower); //Only Bob can call

attest

require(!follower_mutation.mutating);
require(!follower_mutation.lock_asset);
require(sig.valid(follower)); //Bob's valid signature
require(sig.msg() == [_replace_hash_lock]);
require(T_BA >= now + 2*delta); //Need enough time for

David to call claim

follower_mutation.mutating = true;
follower_mutation.voucher = sig; //Proof that candidate

was approved

follower_mutation.candidate_receiver = _candidate_sender;
follower_mutation.replace_hash_lock = _replace_hash_lock;
follower_mutation.start_time = now; //Used for flexible

timeouts in the transfer

}

function replaceLeader(string secret){

require(mutable);
require(leader_mutation.mutating);
bool candidate_round = false;
bool follower_round = false;

//If Bob mutated, can skip contesting phases since he is

implicitly approving of the signature he called
mutateLock with

if(leader_mutation.mutator == follower || (

leader_mutation.mutator == leader &&
leader_mutation.approved)){ //Can immediately call
replace once Bob has mutated

//Carol can replace once Bob has called mutate
candidate_round = (msg.sender == leader_mutation.

candidate_receiver) && (4*delta >= now -
leader_mutation.start_time > 0);

//Bob can call replace
follower_round = (msg.sender == follower) && (6*delta
>= now - leader_mutation.start_time > 0);

}
else{ //Contesting (pessimistic case)

//Carol can replace in round right after last chance

at contesting

candidate_round = (msg.sender == leader_mutation.

candidate_receiver) && (4*delta >= now -
leader_mutation.start_time > 2*delta);
//Bob can replace in the 3 rounds right after last

chance at mutating round

follower_round = (msg.sender == follower) && (6*delta
>= now - leader_mutation.start_time > 0);

}

require(candidate_round || follower_round);
require(H(secret) == leader_mutation.replace_hash_lock);

receiever = leader_mutation.candidate_receiver; //Carol

takes receiving optionality from Alice

swap_hash_lock = mutation.swap_hash_lock;

205
206
207
208
209
210
211
212
213
214

215
216

217
218

219
220
221
222
223
224

225

226
227
228
229

230

231

232

233

234

235

236

237
238
239
240
241
242
243
244

245
246
247
248

249

250

251
252
253

14

Daniel Engel and Yingjie Xue

leader_mutation.approved = false;
leader_mutation.mutating = false;
leader_mutation.mutation.clear();

}

//If no contesting has occurred, transfer can be complete
function replaceFollower(string secret){

require(mutable);
require(follower_mutation.mutating);
require(2*delta >= now - follower_mutation.start_time >

0); //2 rounds given for replacement

require(H(secret) == follower_mutation.replace_hash_lock)

;

sender = follower_mutatation.candidate_sender; //David

takes refund optionality from Bob

follower_mutatation.clear();
follower_mutation.mutating = false;

}

//Contest if transferring party tries to transfer to two

different parties simultaneously

//Note this method only does something if it can be proved

that Alice lied

//This method can't do anything if Alice is honest
function contestLeader(Sig sig,string secret){

require(mutable);
require(msg.sender == follower); //Only allow Bob to call

this

require(leader_mutation.mutating); //Can only contest a

mutation if one has occured

require(!leader_mutation.approved); //Cannot contest

after approval

require(leader_mutation.mutator == leader); //Can only
contest a mutation when Alice called it, not Bob

require(2*delta >= now - leader_mutation.start_time > 0);

//Can contest only in the 2 rounds after mutation

//Can contest if Alice creates two inconsistent

signatures or tries to reveal preimage of hashlock
too early

require(sig.valid(leader) || H(secret) == swap_hash_lock)

;

if(sig != leader_mutation.voucher || H(secret) ==
swap_hash_lock){ //Checks if Alice reported
inconsistent sigs

leader_mutation.clear();
leader_mutation.mutating = false;

}

}

//Issue is really in the sequential consistent case
//Bob can call approve in any next two rounds after a

mutation

function approveLeader(){
require(mutable);
require(msg.sender == follower); //Only Bob can approve
require(leader_mutation.mutating); //Can only approve

after a mutation has begun

require(leader_mutation.mutator == leader); //Can only

call approve when Alice was the one who called
mutate

require(2*delta >= now - leader_mutation.start_time > 0);

//Can approve only in the 2 rounds after mutation

leader_mutation.approved = true;

}

Transferable Cross-Chain Options

254
255

256

257
258
259
260
261
262
263
264
265
266
267

268

269
270
271
272
273
274
275
276
277
278

//If replacement doesn't happen quickly enough, can revert

back to the old swap

//Isn't called directly in order to save an extra round of

the protocol
function revertLeader(){
require(mutable);
require(leader_mutation.mutating);
require(now - leader_mutation.start_time > 6*delta);

leader_mutation.approved = false;
leader_mutation.mutating = false;
leader_mutation.clear();

}

//If replacement doesn't happen quickly enough, can revert

back to the old swap

//Isn't called directly in order to save an extra round of

the protocol

function revertFollower(){
require(mutable);
require(follower_mutation.mutating);
require(now - follower_mutation.start_time > 2*delta);

follower_mutation.mutating = false;
follower_mutation.clear();

}

}

.2 Proofs
.2.1 Misc Proofs. First, we provide proofs for the properties of the
leader transfer protocol.

Lemma 15. If Alice and Carol are both conforming in the Mu-
tate Lock Phase, then both ğ´ğµ and ğµğ´ are mutate locked with
(ğ» (ğ¶1), ğ» (ğ¶2)) by ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 2Î”.

Proof. If Carol is conforming, she escrows her principal to Al-
ice by time ğ‘… + Î”. Alice, after observing the creation of ğ¶ğ´, will
then call mutateLockLeader() within a Î” on both ğ´ğµ and ğµğ´, pass-
ing (ğ» (ğ¶1), ğ» (ğ¶2)) as the transfer hashlock and the new swap
hashlock. For any contract, if it is not mutate locked, then the mu-
tateLockLeader() sent by Alice can be included in the blockchain
by ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 2Î”. If the mutateLockLeader() transaction sent
by Alice can not be included in the blockchain due to some-
one else calling it first, it must be that Bob called mutateLock-
Leader() on the contract with (ğ» (ğ¶1), ğ» (ğ¶2)) before her. In any
case, within ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 2Î”, both contracts are mutate locked by
â–¡
(ğ» (ğ¶1), ğ» (ğ¶2)).

If there is a successfully call to mutateLockLeader() on ğ´ğµ with
(ğ» (ğ¶1), ğ» (ğ¶2)), let the first time that this transaction is called be
ğ‘¡ğ´ğµ. Similarly, let ğ‘¡ğµğ´ be the first time mutateLockLeader() is called
on ğµğ´ with (ğ» (ğ¶1), ğ» (ğ¶2)).

Theorem 2. Protocol 4.2 satisfies liveness: If Alice, Bob, and Carol
are all conforming, then Alice gets Carolâ€™s principal, Carol gets Aliceâ€™s
position, and Bob maintains his position.

Proof. If Alice starts the transfer procedure, and all parties are
conforming, then Carol owns the option and paid her principal to
Alice. The argument is as follows.

15

By Lemma 15, we know mutateLockLeader() has been called by
ğ‘… + 2Î” on ğ´ğµ and ğµğ´ with (ğ» (ğ¶1), ğ» (ğ¶2)). After max{ğ‘¡ğ´ğµ, ğ‘¡ğµğ´} +
2Î” â‰¤ ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 4Î”, Carol will know that Bob cannot success-
fully call contest() on either ğ´ğµ or ğµğ´. Carol then releases her secret
ğ¶1 to ğ´ğµ and ğµğ´ by max{ğ‘¡ğ´ğµ, ğ‘¡ğµğ´} + 3Î” â‰¤ ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 5Î”. Then
ğ´ğµ and ğµğ´ are transferred to a new state where the swap hashlock
is ğ» (ğ¶2), the sender of ğ´ğµ contract becomes Carol, and the receiver
of ğµğ´ contract becomes Carol. At this point, these contracts can be
more appropriately renamed as as ğ¶ğµ and ğµğ¶ respectively. That is
to say, Carol has set up a swap with Bob using her swap hashlock
ğ» (ğ¶2). Carol now owns the option. Because the timeout on ğ¶ğ´ is
ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 10Î”, Alice can use ğ¶1 to redeem Carolâ€™s principal on
â–¡
ğ¶ğ´ by revealing ğ¶1 by ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 6Î”. .

Theorem 3. Protocol 4.2 satisfies transfer independence: Alice can

transfer her position to Carol without Bobâ€™s participation.

Proof. If Alice and Carol are both conforming, then by Lemma
15, we know mutateLock() will be called with (ğ» (ğ¶1), ğ» (ğ¶2)) on
both ğ´ğµ and ğµğ´ by ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 2Î”. In the worst case, after
max{ğ‘¡ğ´ğµ, ğ‘¡ğµğ´} + 2Î”, Carol should release ğ¶1 to replace Alice on
both ğ´ğµ and ğµğ´. This results in the replacement of the old swap
hashlock ğ» (ğ´1) with ğ» (ğ¶2). Bob does not have to call any func-
tions to help Carol replace Aliceâ€™s role. Thus, conforming Alice and
â–¡
Carol can trade without Bobâ€™s cooperation.

We have proven that conforming Alice and Carol can trade the
option without Bob cooperating. Now we look at this property
from another perspective. Can Bob actively prevent Alice selling
her option to Carol? The following result guarantees Bob cannot
block Alice and Carol.

Theorem 4. Protocol 4.2 satisfies non-blocking transfer: Alice can

transfer her position to Carol even if Bob is adversarial.

Proof. The only way for Bob to block the transfer of an option
is to contest. To contest, Bob needs to show a different mutation
signed by Alice or by showing Aliceâ€™s secret to the old hashlock.
As long as Alice is conforming to the protocol and does not collude
with Bob, which is the case in this context, an adversarial Bob
â–¡
cannot forge her signature and successfully call contest().

Theorem 5. Protocol 4.2 satisfies transfer atomicity: If Alice loses

her position in the swap, then she can claim Carolâ€™s principal.

Proof. Conforming Carol only loses her principal if she releases
her secret ğ¶1. She only releases her secret ğ¶1 after she sees both
ğ´ğµ and ğµğ´ are both mutate locked by (ğ» (ğ¶1), ğ» (ğ¶2)) and at least
one of the conditions are met: (1)Bob has approved both ğ´ğµ and
ğµğ´; (2) both of his contest windows on ğ´ğµ and ğµğ´ have ended.
Bob can no longer contest this result either due to timeout of his
contesting window or Bob has approved this result. Then when
Carol sends her secret ğ¶1 to both ğ´ğµ and ğµğ´, she replaces Aliceâ€™s
role and changes the swap hashlock to ğ» (ğ¶2) thus she owns the
option.

Conforming Alice loses her option only if Carol releases her
secret ğ¶1 on some contract. We know by Lemma 15 that in the
worst case mutateLockLeader() will be called on ğ´ğµ and ğµğ´ by
ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 2Î”. Thus, the latest time any party can call replace()
is. ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 8Î”. So if Alice loses her option there must have

been a replace() call by ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 8Î”. Since ğ¶ğ´ has timeout
ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ +10Î”, Alice is guaranteed enough time to claim Carolâ€™s
â–¡
principal.

The remaining proofs are for the properties of the follower trans-

fer protocol.

Lemma 16. In Protocol 4.3, if Bob, David are both compliant, and
Alice does nothing, then Bob gets Davidâ€™s principal, and David gets
Bob position.

Proof. By assumption, we know the Mutate

Phase
ends ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ + 2Î”. At this point, ğ‘ğ‘ğ‘›ğ‘‘ğ‘–ğ‘ğ‘¡ğ‘’_ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ =
ğ·ğ‘ğ‘£ğ‘–ğ‘‘.ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘’ğ‘ ğ‘  on ğµğ´ and ğ‘ğ‘ğ‘›ğ‘‘ğ‘–ğ‘‘ğ‘ğ‘¡ğ‘’_ğ‘Ÿğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ = ğ·ğ‘ğ‘£ğ‘–ğ‘‘.ğ‘ğ‘‘ğ‘‘ğ‘Ÿğ‘’ğ‘ ğ‘ 
on ğ´ğµ. By ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ + 3Î” we know ğ·ğ‘ğ‘£ğ‘–ğ‘‘ will reveal
ğ·1 to ğ´ğµ and ğµğ´. At this point ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ = ğ·ğ‘ğ‘£ğ‘–ğ‘‘ on ğµğ´ and
ğ‘Ÿğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ = ğ·ğ‘ğ‘£ğ‘–ğ‘‘ on ğ´ğµ. Thus David has successfully taken Bobâ€™s
position. When Bob forwards ğ·1 to the ğ·ğµ, it will arrive no
later than ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ + 4Î” < ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ + 5Î”. So Bob gets
â–¡
Davidâ€™s principal.

Theorem 7. Protocol 4.3 satisfies liveness: If Alice, Bob, and David
are all conforming, and Alice doesnâ€™t reveal ğ´1, then Bob gets Davidâ€™s
principal, David gets Bobâ€™s position, and Alice maintains her position.

Proof. Because Alice is compliant and doesnâ€™t reveal ğ´1, she
does nothing according to Protocol 4.3. Since Bob and David are
â–¡
both compliant, the result follows from Lemma 16.

Theorem 8. Protocol 4.3 satisfies transfer independence: Bob can

transfer his position to David without Aliceâ€™s participation.

Proof. Assume Alice does nothing and Bob, David are compli-
â–¡

ant. By Lemma 16, the result follows immediately.

Theorem 9. Protocol 4.3 satisfies non-blocking transfer: Bob can

transfer his position to David even if Alice is adversarial.

Proof. Aliceâ€™s only ability during Protocol 4.3, is to choose
to reveal her secret ğ´1. Since Bob and David are compliant,
David creates ğ·ğµ by ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ + Î”. In the worst case, Bob
calls ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¹ğ‘Ÿğ‘’ğ‘’ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ () on ğµğ´ at the last available op-
portunity, at ğ‘‡ âˆ’ 2Î”. Since Bob is compliant, he also calls
ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ () on ğ´ğµ by ğ‘‡ âˆ’ 2Î”. Since David is compliant,
he calls ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’ () on ğ´ğµ, ğµğ´ by ğ‘‡ âˆ’ Î”, thereby revealing ğ·1 to
Bob. Both replace calls are then completed by ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ + 3Î”.
Bob then has enough time to reveal ğ·1 on ğ·ğµ since its timeout is
ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ + 5Î”. If Alice reveals ğ´1 by ğ‘‡ on ğµğ´, then David will
have Bobâ€™s position so he on ğ´ğµ and ğµğ´. Thus he can reveal ğ´1 on
â–¡
ğ´ğµ since it has timeout ğ‘‡ + Î”.

Theorem 10. Protocol 4.3 satisfies transfer atomicity: If Bob loses

his swap position, then he can claim Davidâ€™s principal.

Proof. Suppose a conforming Bob loses his swap posi-
tion. By Protocol 4.3, we know ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ () and
ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¹ğ‘Ÿğ‘’ğ‘’ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ () are called on ğ´ğµ and ğµğ´ respectively
by ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ + 2Î” by Bob. By assumption Bob loses his swap
position. Thus David must have revealed ğ·1 on ğ´ğµ or ğµğ´ before the
ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ () timeout. Since each ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ () timeout
is 2Î”, the latest David could have revealed ğ·1 is ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ + 4Î”.
Conforming Bob sends ğ·1 to ğ·ğµ which arrives by ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ +

Daniel Engel and Yingjie Xue

5Î”. Since the timeout on ğ·ğµ is ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¹ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ + 5Î”, this ensures
â–¡
Bob gets Davidâ€™s principal.

.2.2 No UNDERWATER. The goal of this section is to prove Theo-
rem 1.

If the reselling is started by Alice calling mutateLockLeader()
on ğ´ğµ and/or ğµğ´ contract, the state of the corresponding contract
will be changed. We first define states of contracts. These are refer-
enced from .1. A smart contractâ€™s state is defined by the following
elements:

â€¢ sender: sender can call refund() if the receiver does not re-

deem it before swap hashlock times out.

â€¢ receiver: receiver can call claim() and pass the preimage of
swap hashlock to get the asset escrowed in the contract.
â€¢ mutating: mutating is a bool where mutating=true means
the asset is temporarily not redeemable due to some active
mutation in progress. In other words, the right to claim the
asset is locked. On the other hand, mutating=false means the
asset can be claimed if the preimage to the hashlock is sent
to the contract.

â€¢ swap_hash_lock: The swap hashlock is the hashlock used
to claim assets. If the preimage of the hashlock is sent to
claim(), then the receiver can claim the asset.

â€¢ replace_hash_lock: If replace_hash_lock != nil, that means
Alice would like to transfer her option. replace_hash_lock
stores the hashlock for the transfer.

â€¢ candidate_sender/candidate_receiver: denotes the new sender
or receiver when transfer is finalized, i.e. Carol replaces
Aliceâ€™s role.

We take ğ´ğµ as an example to illustrate the states. The states on

ğµğ´ are symmetric which can be inferred from the context.

state

â€¢ ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ´1), ğ´ğµ) denotes

=
ğ´ğ‘™ğ‘–ğ‘ğ‘’, ğ‘Ÿğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ = ğµğ‘œğ‘, ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘›ğ‘” = ğ‘“ ğ‘ğ‘™ğ‘ ğ‘’, ğ‘ ğ‘¤ğ‘ğ‘_â„ğ‘ğ‘ â„_ğ‘™ğ‘œğ‘ğ‘˜ =
ğ» (ğ´1)), meaning if ğ´1 is sent before the contract ex-
pires, Bob can claim Aliceâ€™s principal. We will use
ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ´1)) for simplicity when which contract
we are referring to is obvious from the context.

(ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ

= ğ» (ğ¶1), ğ‘ ğ‘¤ğ‘ğ‘_â„ğ‘ğ‘ â„_ğ‘™ğ‘œğ‘ğ‘˜

â€¢ ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ¶ğ‘ğ‘Ÿğ‘œğ‘™, ğ» (ğ¶1), ğ» (ğ¶2), ğ´ğµ) denotes
the state (ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ = ğ´ğ‘™ğ‘–ğ‘ğ‘’, ğ‘Ÿğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ = ğµğ‘œğ‘, ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘›ğ‘” =
ğ‘¡ğ‘Ÿğ‘¢ğ‘’, ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’_â„ğ‘ğ‘ â„_ğ‘™ğ‘œğ‘ğ‘˜
=
ğ» (ğ¶2), ğ‘ğ‘ğ‘›ğ‘‘ğ‘–ğ‘‘ğ‘ğ‘¡ğ‘’ğ‘Ÿ ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ = ğ¶ğ‘ğ‘Ÿğ‘œğ‘™), which means Al-
ice tentatively locks the asset and transfers her role to
Carol. In this state Bob is able to call contest(). We will
use ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)) for simplicity
when other parts we are referring to are obvious from the
context. ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ is just a preparation for
Carol to replace Aliceâ€™s role. The replaceLeader() cannot be
called until the state defined below.

â€¢ ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ¶ğ‘ğ‘Ÿğ‘œğ‘™, ğ» (ğ¶1), ğ» (ğ¶2), ğ´ğµ).

In
this state Bob cannot call contest() because his contest
window has passed or he approved the mutation. At
this state, Carol can release her secret ğ¶1 to replace Al-
ice. The state when Carol can replace Alice is denoted
as ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ¶ğ‘ğ‘Ÿğ‘œğ‘™, ğ» (ğ¶1), ğ» (ğ¶2), ğ´ğµ).
is the short
ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2))
name.

16

Transferable Cross-Chain Options

Figure 3: State transition until Carol replaces Alice on ğ´ğµ
contract

â€¢ ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ¶2), ğ¶ğµ).

After

replace()

role by sending ğ¶1. After

ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ¶ğ‘ğ‘Ÿğ‘œğ‘™, ğ» (ğ¶1), ğ» (ğ¶2), ğ´ğµ)
to replace Al-
is reached, Carol can call
the replacement,
iceâ€™s
the state becomes
=
ğµğ‘œğ‘, ğ‘šğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘–ğ‘œğ‘›_ğ‘™ğ‘œğ‘ğ‘˜ = ğ‘“ ğ‘ğ‘™ğ‘ ğ‘’, ğ‘ ğ‘¤ğ‘ğ‘_â„ğ‘ğ‘ â„_ğ‘™ğ‘œğ‘ğ‘˜ = ğ» (ğ¶2)), de-
noted as ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ¶2), ğ¶ğµ). ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ¶2))
is the short name.

ğ¶ğ‘ğ‘Ÿğ‘œğ‘™, ğ‘Ÿğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ

(ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ

=

â€¢ ğ¶ğ‘™ğ‘ğ‘–ğ‘šğ‘’ğ‘‘ (ğ» (ğ‘†), ğ´ğµ) means the asset on ğ´ğµ contract is
claimed by a secret ğ‘† which is the preimage to ğ» (ğ‘†) and
Bob gets the asset. In this context, ğ‘† can be ğ´1 or ğ¶2.
ğ¶ğ‘™ğ‘ğ‘–ğ‘šğ‘’ğ‘‘ (ğ» (ğ‘†)) is the short name.
The state transition is depicted in Fig 3.
There are two stages of changes of state on the ğ´ğµ and ğµğ´

contracts.

(2) Second

(1) First stage. Alice and Bob aim to change the state of
both contracts from ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ´1)) to a mutation
state ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)), during
which state ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)) may be
reached temporally, corresponding to Mutate Lock Phase
and Consistency Phase.
from
stage.
ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)),
Bob
and Carol are involved in an atomic change from
to
ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2), ğ¶ğ‘ğ‘Ÿğ‘œğ‘™)
ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ¶2)) by Carol releasing a secret ğ¶1. It is
similar to a standard atomic swap where Carol is the leader
and Bob is the follower, corresponding to the Replace/Revert
Phase.

Starting

Theorem 17. Conforming Alice will never end up in UNDERWA-

TER.

Proof. If Carol never creates ğ¶ğ´ or creates ğ¶ğ´ with different
conditions than what Carol and Alice agreed upon, then Alice does
nothing and so she doesnâ€™t lose her option.

Otherwise, consider the case when Carol creates ğ¶ğ´ with the

conditions Alice and Carol had agreed upon.

If Alice is conforming, by Lemma 15 then both ğ´ğµ and
ğµğ´ are mutate locked with (ğ» (ğ¶1), ğ» (ğ¶2)) by ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ +
2Î”. This means ğ´ğµ and ğµğ´ both have reached the state

17

ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)) by ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ +2Î”. Since
Alice is conforming, by ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ¿ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ + 4Î”, the state will transition
to ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)) since Bob cannot
forge Aliceâ€™s signature and contest.

After ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)), if Carol re-
leases ğ¶1, Alice observes it in the Replace/Revert phase, and can get
Carolâ€™s principal as shown in Theorem 5. If Carol does not release
ğ¶1, then eventually, after ğ‘¡ğ´ğµ + 6Î” and ğ‘¡ğµğ´ + 6Î” respectively, the
states on both contracts can be reverted to ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ´1))
which means Alice still owns the option and it is unlocked. If Alice
finally owns the option, then she does not end up in UNDERWATER
by the guarantee of atomic swap. If Alice loses her option(maybe
only lose a role on one contract), she gets Carolâ€™s principal, with-
/without losing her principal escrowed in her old option, which is
â–¡
acceptable for her.

Theorem 18. Conforming Carol will never end up in UNDERWA-

TER.

Proof. After Carol escrows her principal

to Alice on
ğ¶ğ´ and sends her hashlocks ğ» (ğ¶1), ğ» (ğ¶2)
to Alice, Carol
does not do anything in the first stage but observe. She
only joins in the protocol after she observes that both con-
tracts are in ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)) state.
Otherwise, she is silent and she will not end up in UNDER-
WATER since her principal will be refunded eventually. After
she
ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2))
releases ğ¶1, moving
contracts,
state
to
state
ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2))
ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ¶2)). Then she owns the option provided
by Bob and takes over Aliceâ€™s option. In that case, she may lose her
principal to Alice due to the release of ğ¶1. Say, in the worst, she
loses her principal to Alice.

observes
on

both

she

Then, if Carol decides to exercise the option, she gets Bobâ€™s
principal. That means, her principal is exchanged with Bobâ€™s. If she
does not exercise the option and let it expire, she can get Aliceâ€™s
principal. That means, her principal is exchanged with Aliceâ€™s. In
â–¡
any case, Carol never ends up in UNDERWATER.

To prove that conforming Bob does not end up in UNDERWATER,
we need to to prove the consistency of states on two contracts.
Specifically,

â€¢ In the first stage, if Alice calls mutateLockLeader() in
any contract, either both contracts eventually gets
reverted
ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)
back to ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ´1)).

or

â€¢ In the second stage, if Carol releases ğ¶1, both contracts
are eventually at state ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ¶2)). If Carol does
not releases ğ¶1, both contracts are eventually are in state
ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ´1)).

Suppose, without loss of generality, that ğ´ğµ contract is the first
to update its state from ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ´1)) to a new state by
Alice calling mutateLockLeader() at some time ğ‘¡, assuming Bob is
conforming.

Theorem 19. If ğµğ´ is not claimed by ğ‘¡ + Î”, then ğµğ´ will be mutate

locked by ğ‘¡ + Î”.

2/12/22, 9:42 PMtransfer_option_states1/1Bob mutates at timeRevert afterAlice revealsbefore timeoutAlice mutates at timeBob contests withinBob doesn't contest byor Bob approvesrevealed beforeProof. Since Bob is conforming, when Alice calls mutateLock-
Leader() on the ğ´ğµ contract, Bob can send mutateLockLeader() trans-
action on the ğµğ´ within Î”. Recall that the start time that mutate-
LockLeader() is called is denoted as ğ‘¡ğ´ğµ and ğ‘¡ğµğ´ respectively. Then
in ğµğ´ mutateLockLeader() is called on ğµğ´ by ğ‘¡ğ´ğµ + Î”.

If Bobâ€™s mutateLockLeader() is included on ğµğ´, then ğ‘¡ğµğ´ â‰¤ ğ‘¡ğ´ğµ+Î”.
If Bobâ€™s mutateLockLeader() on ğµğ´ is not included, then it must
be Alice was able to call it before he was. In either case, ğ‘¡ğµğ´ â‰¤
â–¡
ğ‘¡ğ´ğµ + Î”.

The case that by ğ‘¡ + Î”, the other contractâ€™s state changes to

ğ¶ğ‘™ğ‘ğ‘–ğ‘šğ‘’ğ‘‘ (ğ» (ğ´1)) will be analyzed in Theorem 22.

Theorem 20. Suppose

two
eventually
reach ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)). Then,
ei-
ther both contracts are eventually ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ´1)) or
ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ¶2)).

contracts

both

Proof. Since we know the start time of mutation between two
contracts does not stagger beyond Î”. Denote the start time on two
contracts as ğ‘¡ğ‘“ ğ‘–ğ‘Ÿğ‘ ğ‘¡ and ğ‘¡ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ respectively where ğ‘¡ğ‘“ ğ‘–ğ‘Ÿğ‘ ğ‘¡ â‰¤ ğ‘¡ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ .
Since Bob is conforming, ğ‘¡ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ âˆ’ğ‘¡ğ‘“ ğ‘–ğ‘Ÿğ‘ ğ‘¡ â‰¤ Î”. We denote the timeout
for Carol to release ğ¶1 on ğ´ğµ and ğµğ´ contracts as ğ‘¡1,ğ‘¡2 respectively,
and the timeout for Bob to release ğ¶1 as ğ‘¡3,ğ‘¡4. Without loss of gener-
ality, assume ğ‘¡1 = ğ‘¡ğ‘“ ğ‘–ğ‘Ÿğ‘ ğ‘¡ + 4Î” and ğ‘¡2 = ğ‘¡ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ + 4Î”. ğ‘¡3 = ğ‘¡ğ‘“ ğ‘–ğ‘Ÿğ‘ ğ‘¡ + 6Î”
and ğ‘¡4 = ğ‘¡ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ + 6Î”. We see that the latest timeout for Carol to
release ğ¶1 is ğ‘¡2. The earliest timeout for Bob to send ğ¶1 satisfies
ğ‘¡3 â‰¥ ğ‘¡2 + Î” since we have ğ‘¡3 = ğ‘¡ğ‘“ ğ‘–ğ‘Ÿğ‘ ğ‘¡ + 6Î” â‰¥ ğ‘¡ğ‘ ğ‘’ğ‘ğ‘œğ‘›ğ‘‘ + 5Î” = ğ‘¡2 + Î”.
That means, if Carol releases ğ¶1, then it is eventually sent to both
contracts and the state is ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ¶2)). If Carol does not re-
lease ğ¶1, then both contracts are reverted to ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ´1))
â–¡
after timeout ğ‘¡3 and ğ‘¡4, respectively.

The atomic changes between AB and BA are a bit more
complicated, since starting from ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ´1)), there
are multiple possible state changes available on both con-
tracts: ğ¶ğ‘™ğ‘ğ‘–ğ‘šğ‘’ğ‘‘ (ğ» (ğ´1)), ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)),
states
and ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)). The
ğ¶ğ‘™ğ‘ğ‘–ğ‘šğ‘’ğ‘‘ (ğ» (ğ´1)) and ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2))
are not contestable. Assuming Bob is conforming and relay what-
ever he sees from one contract to another contract.

Lemma

21. If

a

to
contract
ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)) at ğ‘¡, then within ğ‘¡ + 2Î”, it
learns the other contractâ€™s update and then agree on either reverting
back if there is a conflict or agree on the same mutation if no conflict.

transferred

is

a

contract,

Proof. If

say AB,

to
transferred
is
ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)) at
time ğ‘¡, since the
compliant Bob relays it, whatever happens before ğ‘¡ âˆ’ Î” to
AB contract, that means, at time ğ‘¡ âˆ’ Î”, the other chain is in
ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ´1)). If there is any change happening on BA
contract, it would happen between ğ‘¡ âˆ’ Î” to ğ‘¡ + Î”. Then, by
ğ‘¡ + 2Î”, AB contract will learn what happens on BA contract
between ğ‘¡ âˆ’ Î” to ğ‘¡ + Î” by Bob. If AB contract does not receive
any transaction from Bob, then no conflicting changes hap-
pened on BA from ğ‘¡ âˆ’ Î” to ğ‘¡ + Î”. Bob can update BA contract
to ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)) by relaying Aliceâ€™s
mutation to BA contract, and AB contract can be updated to

Daniel Engel and Yingjie Xue

ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)) after ğ‘¡ + 2Î”. If there
is any state change between ğ‘¡ âˆ’ Î” to ğ‘¡ + Î” on BA contract, then by
ğ‘¡ + 2Î”, AB contract would be informed, and its own state update is
also sent to BA contract. Then the conflicting state update would
revert back their state change to ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ´1)) when it
â–¡
receives the conflicting change.

Theorem 22. Conforming Bob never ends up in UNDERWATER.

Proof. Starting from ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ´1)),
(1) If

is

a

transferred

to
contract
ğ‘¡, and the
ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2))
other contract is not updated to ğ¶ğ‘™ğ‘ğ‘–ğ‘šğ‘’ğ‘‘ (ğ» (ğ´1)), then by
Lemma 21, we know that either both contracts eventually
reach
ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)) or are reverted
back to ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ´1)).

at

(2) If a contract BA is transferred to ğ¶ğ‘™ğ‘ğ‘–ğ‘šğ‘’ğ‘‘ (ğ» (ğ´1))
state at ğ‘¡, then, if the other contract makes temporary
ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2),
it will be revert
back to ğ‘…ğ‘’ğ‘ğ‘‘ğ‘¦2ğ¶ğ‘™ğ‘ğ‘–ğ‘š(ğ» (ğ´1)) by ğ‘¡ + Î”, and then transfer
to ğ¶ğ‘™ğ‘ğ‘–ğ‘šğ‘’ğ‘‘ (ğ» (ğ´1)). Bob does not end up with UNDERWA-
TER.

(3) If

a

contract

is

transferred

directly

to

ğ‘¡,

then

contract must

ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2))
at
be
other
the
ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)) at ğ‘¡ â€² âˆˆ [ğ‘¡ âˆ’ Î”, ğ‘¡],
and then after ğ‘¡ + 2Î” or sooner, the other contract will
become ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)).
When ğ‘€ğ‘¢ğ‘¡ğ‘ğ‘¡ğ‘’ğ¿ğ‘œğ‘ğ‘˜ğ‘ğ‘œğ‘›ğ¶ğ‘œğ‘›ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ (ğ» (ğ¶1), ğ» (ğ¶2)) is reached on
both contracts, by Theorem 20, Bob will either be involved in the
swap with Alice by Aliceâ€™s secret ğ´1 or involved in the swap with
Carol by Carolâ€™s secret ğ¶2. By the guarantee of atomic swap, Bob
will not end up with UNDERWATER.

â–¡

The details for showing Protocol 4.3 satisfies No UNDERWATER
are omitted since they mirror the previous arguments shown for
4.2.

18

