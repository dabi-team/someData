1
2
0
2

v
o
N
4
1

]
T
C
.
h
t
a
m

[

1
v
1
6
4
7
0
.
1
1
1
2
:
v
i
X
r
a

A Topos View of Blockchain Consensus Protocols

Michael Lambert

November 2021

Abstract

This paper presents a reformulation in topos logic of a safety result arising in an abstract presenta-
tion of blockchain consensus protocols. That is, in a high-level template for “correct-by-construction”
consensus protocols, it is shown that a proposition and its negation cannot both be safe in protocol states
that have executions to some common state. This is in fact true for any inconsistent propositions and
the proof requires only intuitionistic reasoning. This opens the door for work on consensus protocols in
the internal language of a topos. As a ﬁrst pass on such a program, the main contribution of this paper
is the formulation of estimate safety in abstract correct-by-construction protocols as a forcing statement
in the internal logic of a given topos. This is illustrated ﬁrst in the setting of copresheaf toposes. It is
also seen there that safety can be viewed as a modal statement. For these interpretations, some exten-
sions and adaptations of results in the literature on modal operators in toposes are presented. The ﬁnal
reformulation of estimate safety is a completely elementary version in the language of an arbitrary topos
where it is seen that estimate safety is equivalent to a certain forcing statement.

Contents

1 Introduction

2 Heyting Algebras

3 Estimate Safety for Heyting-Valued Consensus Protocols

4 Toposes and Their Internal Logic

5 Geometric Models

6 Presheaf Forcing Semantics of Estimate Safety

7 Consensus Protocols in a Topos

8 Estimate Safety in a Topos

9 Decided Propositions in a Topos

10 Prospectus

1

Introduction

1

3

5

6

7

9

11

13

15

16

A distributed system is a network of interconnected nodes tasked with solving certain computational
problems. A long-standing issue is that of desiging algorithms or protocols by which distributed systems
arrive at a consensus about a state of aﬀairs, given network latency or that some nodes may be faulty or
inoperative. These faults could be due to mechanical errors or the presence of malicious actors.

A blockchain is a distributed system in which nodes validate blocks forming a public ledger of transac-
tions. Any blockchain is ultimately a linear order of individual blocks, each of which identiﬁes its unique im-
mediate predecessor, contains an identiﬁcation hash, and records network transaction data. The blockchain

1

 
 
 
 
 
 
protocol governs how nodes communicate. As part of the protocol, a consensus algorithm for such a
blockchain is a process by which nodes come to agree on which blocks to include in the chain in the case that
blocks are minted simultaneously or contain conﬂicting data. For example, [Nakamoto, 2008] outlines the
consensus algorithm used in the Bitcoin blockchain; [Buterin, 2013] is the Ethereum blockchain whitepaper
from 2013. Safety is the issue of whether nodes will or will not validate conﬂicting blocks. A proposition
about a conﬁguration of the system or the consensus is safe in a protocol state if it is validated by all
subsequent states accessible from the given state. A consensus algorithm should guarantee safety given that
a certain percentage of nodes are not faulty. See [Gramoli, 2020] for a recent overview of issues in consensus
protocols and fault tolerance in blockchain development.

Here the concern is the mathematics of an abstract version of the consensus protocol used in the Ethereum
blockchain. Ethereum follows a “correct-by-construction” (CBC) Byzantine fault tolerant (BFT) protocol
outlined for example in [Buterin & Griﬃth, 2017], [Buterin, 2017], [Zamﬁr, 2018] and [Zamﬁr et. al. 2019].
An abstract template (referred to here as “Abstract CBC”) for such protocols was given [Zamﬁr, 2017]. The
present purpose is not to extend this ongoing work, but rather to explicitly formulate Abstract CBC in topos
logic and show that the central concept of “estimate safety” is equivalently a forcing statement and indeed
a modal statement arising from certain geometric models as in [Awodey, Kishida, & Kotzsch, 2014]. To this
end, review the main deﬁnition of the Abstract CBC template as presented in [Zamﬁr, 2017].

Deﬁnition 1.1. An estimate consensus protocol consists of

1. a set C of possible consensus values;

2. a propositional logic LC such that each proposition is either true or not true of each consensus value;

3. a category Σ whose objects w are protocol states and whose morphisms are protocol executions;

4. ﬁnally an estimator function E : Σ0 → LC assigning a proposition to each object of Σ in such a way

that if Ew ⇒ p, then ¬(Ew ⇒ ¬p) for any proposition p and any state w.

Display an estimate consensus protocol as a tuple (C, LC , Σ, E).

Deﬁnition 1.2. A proposition p safe in the protocol state w if for any execution w → w′, it follows that
Ew′ ⇒ p holds. Write ‘S(p, w)’ to indicate that p is safe in w. States w1 and w2 are compatible if there is
a third state w3 and executions w1 → w3 ← w2. Say that w3 is a common future state.

The main result of [Zamﬁr, 2017] is then the following.

Theorem 1.3. A proposition p and its negation ¬p are not both safe in compatible states. In notation, for
any compatible w1 and w2 and any proposition p, it is not the case that both S(p, w1) and S(¬p, w2).

This suggests a modest generalization, proved below as Theorem 3.7.

Theorem 1.4. Inconsistent propositions are not both safe in compatible states. In notation, if p ∧ q = ⊥
holds, then for any compatible states w1 and w2 it is not the case that both S(p, w1) and S(q, w2).

This generalization is proved using an intuitionistic logic L and by reasoning without double negation
or DeMorgan’s laws in the metatheory. From these intuitionistic proofs, the possibility arises of giving a
topos-theoretic reformulation of consensus protocols. And indeed the main observations of this paper are
that estimate safety is (1) equivalent to a forcing statement and (2) equivalent to a modal statement with
a forcing semantics. As background, recall (e.g. [Kripke, 1965], [Kripke, 1963]) that the traditional forcing
semantics of a modal operator (cid:3) for “necessity” are w (cid:13) (cid:3)p if, and only if, v (cid:13) p for all w ≤ v. That is,
“necessarily p” is “forced” at stage w if it is also at all accessible future states. Now, “safety in a state”
is inherently modal. Think of subsequent protocol states as accessible future states. Thinking of C as
possible conﬁgurations of the blockchain itself, the estimator E returns a “fork choice” at a given protocol
state, that is, a choice of which blocks to include and which to drop from the ledger. In this way, p is safe
at the protocol state if, and only if, p is in the fork choice of every subsequent protocol state.

The question is how to make sense of these heuristics. A ﬁrst approach is to use an adaptation of
the relativised forcing relation ‘(cid:13)∗’ of [Awodey, Kishida, & Kotzsch, 2014] induced from the canonical ge-
ometric morphism between presheaf toposes associated to the estimator E : Σ → P C. This requires some

2

technical results related to ‘(cid:13)∗’, such as Lemma 6.5, which are made as needed in §6. This leads to
the ﬁrst main result, Theorem 6.6, showing that estimate safety is equivalent to a (cid:13)∗-forcing statement.
In [Awodey, Kishida, & Kotzsch, 2014] the presheaf semantics of modalized statements are given in terms of
this relative forcing relation. Thus, along the way in §5, some observations are made concerning (cid:3)-semantics
arising from “geometric models” as preparation for the second main result. Namely, Theorem 6.9 shows that
estimate safety is also equivalent to a certain modal statement with semantics given by relative forcing.

Both of these preliminary results suﬀer from a defect. That is, for the semantics to work properly, it
needs to be assumed that E : Σ → P C induces a surjective geometric morphism of copresheaf toposes, hence
a geometric model. Since P C is a poset category, this would require that E is surjective on objects. This
is probably an unreasonable assumption. For in [Zamﬁr, 2018] and [Zamﬁr et. al. 2019], the protocol Σ
is inductively derived from transactions on the blockchain. This is a latency issue that is fundamental to
blockchain development. So, not only would a completely elementary presentation of Abstract CBC protocols
be preferred, but the use of geometric models, while it is intuitive and rather starkly illustrates the forcing
and modal semantics, should ultimately be avoided in the settled account. The presheaf are left in because
they explicitly illustrate the role of the “total cosieve” in Lemma 6.5. This is the basis of the elementary
axiomatization and main forcing result. That is, §8 gives a formulation of Abstract CBC protocols in the
internal category theory of a topos. Safety is shown to be a forcing statement in Theorem 8.1 and the main
safety result is proved in Theorem 8.7.

Results of [Awodey, Kishida, & Kotzsch, 2014] are extended and adapted where needed. In particular,

there are the following technical contributions to the theory of forcing semantic of modalized topos logic:

1. Theorem 6.8 extends the forcing semantics of ‘(cid:3)’ in [Awodey, Kishida, & Kotzsch, 2014] from inclusions

|C | → C to functors C → D that induce a surjection between copresheaf toposes.

2. Lemma 7.6 shows that one of the main properties of forcing semantics can be internalized to general

diagram categories in an arbitrary base topos.

3. This allows a rewriting of Theorem 6.8 to give forcing semantics of a modal operator induced by a

geometric morphism of internal diagram categories in any topos. This appears as Theorem 7.8.

The following section §2 gives an overview of Heyting algebras and some intuitionistic principles. Following
that §3 gives an account of safety in a state is given using an intuitionistic system L in the place of the
classical propositional system. Topos logic occupies the following section §4. The ﬁnal three sections give
the ﬁnal topos-theoretic account of Abstract CBC and the safety result, namely, Theorem 8.7. This paper
is essentially an application of topos theory, but many details have been included in an eﬀort to make it
accessible for non-specialist readers interested in the mathematics of blockchain consensus protocols.

Acknowledgements. This paper was prepared under the supervision of Dr. Geoﬀ Cruttwell at Mount
Allison University where the author is a postdoctoral research associate. The author would like to thank Dr.
Cruttwell for his support and feedback on an earlier version of the paper.

2 Heyting Algebras

Denote the top element of any lattice by ‘⊤’ and the bottom by ‘⊥’. Conjunction and disjunction are denoted
by ‘∧’ and ‘∨’, respectively. Most of the following is standard from §I.8 of [MacLane & Moerdijk, 1992] or
Chapter 1 of [Borceux, 1994]. These details are included since the subobject classiﬁer Ω in a topos is
an internal Heyting algebra and thus obeys arrow-theoretic versions of the logical laws presented here.
Throughout use ‘≡’ as a metasymbol for “if, and only if.”

Deﬁnition 2.1. A Heyting algebra is a ﬁnitely complete lattice H where for each p ∈ H, the functor
p ∧ − : H → H has a right adjoint p ⇒ (−) : H → H.

By the deﬁnition of adjoint functors, the Heyting implication satisﬁes

One of the main examples of a Heyting algebra is the set O(X) of open subsets of a topological space X. In
this example, the implication U ⇒ V is the union of open sets whose intersection with U is contained in V .

p ∧ q ≤ r ≡ p ≤ q ⇒ r ≡ q ≤ p ⇒ r.

(2.1)

3

Lemma 2.2. In any Heyting algebra the following hold:

1. [p ⇒ (q ∧ r)] = [(p ⇒ q) ∧ (p ⇒ r)]

2. [(p ∧ q) ⇒ r] = [p ⇒ (q ⇒ r)]

3. p ≤ q if, and only if, p ⇒ q = ⊤

Proof. For the ﬁrst statement, the functor p ⇒ (−) is a right adjoint, hence preserves limits. For the second,
note that products are associative. Finally, from the adjoint property 2.1 above

as required.

p = ⊤ ∧ p ≤ q ≡ ⊤ ≤ p ⇒ q

Denote by ‘¬p’ the element p ⇒ ⊥. This is the negation or pseudocomplement of p. It is the largest

element of H whose meet with p is ⊥.

Lemma 2.3. For any elements p and q in a Heyting algebra,

1. p ≤ ¬¬p

2. p ⇒ ¬¬p = ⊤

3. p ∧ ¬p = ⊥

4. if p ∧ q = ⊥ then q ≤ ¬p.

Proof. For the ﬁrst statement, use the fact that ⊥ = p ∧ (p ⇒ ⊥) and the adjoint property 2.1. The rest
follow from this statement and the equivalences in 2.1.

In a given Heyting algebra, generally p ∨ ¬p = ⊤ does not hold. Take as an example O(X), the frame
of open sets of a topological space with X = R. The pseudocomplement of R \ {0} is empty, so the double
pseudocomplement is R. Likewise the inequality ¬(p ∧ q) ≤ ¬p ∨ ¬q is generally strict, meaning that Heyting
algebras do not in general satisfy both of the DeMorgan laws.

Theorem 2.4. In a Heyting algebra, the following are equivalent:

1. ¬¬p ≤ p

2. ¬¬p = p

3. p ∨ ¬p = ⊤

Any Heyting algebra satisfying any of these is a Boolean algebra.

Proof. There are standard arguments for these equivalences; see for example the proof of Proposition I.8.4
of [MacLane & Moerdijk, 1992].

Heyting algebras are algebraic models of systems of propositional logic that do not obey double negation.
In this sense, Heyting algebras are models of “non-classical” logic that is also said to be “intuitionistic.”
Throughout given proofs will avoid using classical reasoning wherever possible. To make these argument
easier to read, use some meta-language symbols: ‘⊃’ stands for material implication, ‘≡’ is biequivalence or
biconditional, & is conjunction, and ‘∼’ stands for negation. Given statements P and Q, use freely various
principles of intuitionistic reasoning: namely, from P ⊃ Q infer that ∼ Q ⊃∼ P (contraposition); from P
infer ∼∼ P ; ﬁnally that P ⊃ (Q ⊃ ⊥) will hold if, and only if, to P &Q ⊃ ⊥.

4

3 Estimate Safety for Heyting-Valued Consensus Protocols

The main deﬁnition of the Abstract CBC template in [Zamﬁr, 2017] can now be phrased in terms of an
arbitrary Heyting algebra.

Deﬁnition 3.1. A Heyting-valued estimate consensus protocol consists of

1. a set C of the possible consensus values;

2. a Heyting algebra HC ;

3. a category Σ whose objects w are protocol states and whose morphisms are protocol executions;

4. ﬁnally an estimator functor E : Σ → HC assigning a proposition to each object of Σ in such a way

that if Ew ⇒ p = ⊤, then ¬(Ew ⇒ ¬p) = ⊤ for any proposition p and any state w.

Display a Heyting-valued estimate safety consensus protocol as (C, HC , Σ, E). For the most part, work will
be done for HC = P C, the powerset of C. For emphasis, call this a Boolean-valued estimate consensus
protocol. However, in the abstract setting P C, will be an internally complete Heyting algebra.

Deﬁnition 3.2. A proposition p has estimate safety in the protocol state w if for any execution
w → w′, it follows that Ew′ ⇒ p = ⊤ holds. Write ‘S(p, w)’ to indicate that p is safe in w. States w1 and
w2 are compatible if there is a third state w3 and executions w1 → w3 ← w2.

With the deﬁnitions stated, the results of [Zamﬁr, 2017] can be reproved in the present framework. Note

throughout that neither double negation nor DeMorgan are required.

Lemma 3.3 (Persistence Lemma). If p ⇒ q = ⊤, then S(p, w) implies S(q, w) for any state w.

Proof. Take an execution w → w′ and assume that Ew′ ⇒ p = ⊤. Then by Lemma 2.2, equivalently
Ew′ ≤ p ≤ q and therefore by transitivity of ‘≤’ and the same lemma Ew′ ⇒ q = ⊤, as required.

Lemma 3.4 (Forward Consistency). For any execution w → w′, if p is safe in w, then p is safe in w′. That
is, if S(p, w) then S(p, w′).

Proof. Take any execution w′ → w′′. Compose to get one w → w′′. Then by the hypothesis that p is safe in
w, the implication Ew′′ ⇒ p holds.

Lemma 3.5 (Current Consistency). If p is safe in w, then ¬p is not safe in w. That is, if S(p, w) then
∼ S(¬p, w).

Proof. If S(¬p, w) holds, then in particular Ew ⇒ ¬p does too. Consequently, if ¬(Ew ⇒ ¬p) holds, then
not S(¬p, w). In general if Ew ⇒ p = ⊤, then ¬(Ew ⇒ ¬p)⊤ by assumption on E. Therefore, since S(p, w)
implies in particular that Ew ⇒ p, the conclusion follows.

Lemma 3.6 (Backward Consistency). For all executions w → w′, if p is safe in w′, then ¬p is not safe in
w. That is, if S(p, w′) holds, then ∼ S(¬p, w).

Proof. By Lemmas 3.4 and 3.5, there are valid implications

Therefore, by contraposition,

But note that

S(¬p, w) ⊃ S(¬p, w′) ⊃∼ S(¬¬p, w′).

∼∼ S(¬¬p, w′) ⊃∼ S(¬p, w).

S(p, w′) ⊃ S(¬¬p, w′) ⊃∼∼ S(¬¬p, w′)

always holds intuitionistically. Putting together the last and penultimate lines, the desired result follows.

Theorem 3.7. Contradictory propositions are not safe at compatible states. That is, if p ∧ q = ⊥ and
w1 ≃ w2 both hold, then ¬(S(p, w1) ∧ (S(q, w2)) holds.

5

Proof. By Lemma 2.3, p ∧ q = ⊥ is equivalent to q ≤ ¬p which is equivalent to q ⇒ ¬p = ⊤. Now, by
forward consistency and backward consistency, the implications

(3.1)

(3.2)

S(p, w1) ⊃ S(p, w3) ⊃∼ S(¬p, w2)

hold. By Lemma 3.3 applied to q ⇒ ¬p,

and intuitionistic contraposition,

S(q, w2) ⊃ S(¬p, w2)

∼ S(¬p, w2) ⊃∼ S(q, w2).

Therefore, putting together the implications 3.1 and 3.2,

holds. But, by deﬁnition of negation, the last display is equivalently

S(p, w1) ⊃∼ S(q, w2)

which is intuitionistically equivalent to

S(p, w1) ⊃ (S(q, w2) ⊃ ⊥)

(S(p, w1) & S(q, w2)) ⊃ ⊥

by Lemma 2.2 that is, to ∼ (S(p, w1) & S(q, w2)), as required.

4 Toposes and Their Internal Logic

The forcing interpretation of safety in a topos requires some background and notation on topos theory.
References are the standard ones, such as [MacLane & Moerdijk, 1992] and [Johnstone, 2002].

Recall that a subobject classiﬁer in a ﬁnitely-complete category E is a morphism ⊤ : 1 → Ω such that

for any subobject m : S → X there is a unique characteristic map χm : X → Ω making a pullback

S

m

/ 1

⊤

X χm

/ Ω.

In non-elementary terms, this is to say that Sub(−) : E op → Set is representable, that is, pulling back along
X → Ω induces isomorphisms Sub(X) ∼= E (X, Ω) holding naturally in X. A morphism X → Ω in a topos is
a propositon ranging over the elements of X. A special proposition is the composite of the unique arrow
X → 1 and ⊤ : 1 → Ω denoted throughout by ‘⊤X’. Think of this as “true with respect to X.”

Deﬁnition 4.1. A topos is a ﬁnitely complete category E with power objects and a subobject classiﬁer.

Example 4.2. The category of sets Set, the category of ﬁnite sets Fin, any presheaf category [C op, Set],
any sheaf category Sh(C , J), and any arrow category E 2 on a topos E are all toposes.The two-element set
2 = {0, 1} is a subobject classiﬁer in Set. The presheaf C op → Set making the assignment

C 7→ {sieves on C}

is a subobject classiﬁer in the presheaf category [C op, Set]. The top element of Ω(C) is the so-called “total
sieve” on C , namely, the collection tC = {f : D → C} consisting of all the arrows of C with codomain C.
The classifying arrow χ associated to a subobject S → X in [C op, Set] has as its components χC : XC → ΩC
the functions

x 7→ {f : D → C | f ∗x ∈ SD}

(4.1)

where f ∗ : F D → F C denotes the associated transition function F (f ) = f ∗.

6

(cid:15)
(cid:15)
/
(cid:15)
(cid:15)
/
The power object P X of a topos object X comes with a membership morphism ∈X : X × P X → Ω
having the universal property that for any morphism g : X ×Y → Ω, there is a unique transpose ˆg : Y → P X
such that g =∈X (1 × ˆg) holds. Consequently, propositions p : X → Ω are in bijection with global elements
ˆp : 1 → P X. Each such power object is an internal frame. For each subobject lattice Sub(C) is one and by
the naturality of the isomorphisms

Sub(C × X) ∼= E (X, P C)

the Heyting operations on Sub(C × X) induce operations on P C by Yoneda. The internal ordering relation
(≤) can be described as the equalizer

(≤)

/ P X × P X

π1

∧

/ P X.

Write ‘f ≤ g’ if the pair hf, gi factors through (≤). For the special case of Ω = P 1, the isomorphism above
reduces to

Sub(X) ∼= E (X, Ω)

which is the unique frame isomorphism making Ω an internal frame. The classifying map of the internal
order object (≤) → Ω × Ω → Ω is the implication operator ⇒ : Ω × Ω → Ω.

5 Geometric Models

Morphisms of toposes give rise to one version of the forcing semantics presented here. First recall the
standard deﬁnition and some conventions.

Deﬁnition 5.1. A geometric morphism F : F → E between toposes is a pair of adjoint functors F ∗ ⊣ F∗
where F ∗ is ﬁnite limit preserving. Call F ∗ : E → F the inverse image and F∗ : F → E the direct image.

Conventionally geometric morphisms point in the direction of their direct image. For any geometric
morphism F : F → E , denote by A∗ the action of F ∗ on A ∈ E , namely, F ∗A = A∗. Similarly, X∗ for
X ∈ F denotes F∗X in E . Denote by f the transpose in F of a morphism f : A → X∗, that is, f = ǫf ∗.
Likewise, ˆg denotes the transpose in E of a morphism g : A∗ → X in F , namely, g∗η.

Example 5.2. Order-preserving morphisms f : P ⇄ Q : g between posets internal to a topos are internally
adjoint with f ⊣ g if f g ≤ 1 and 1 ≤ gf both hold. Since P : E op → E is a functor, each arrow f : A → B
induces one P f : P B → P A. Each such arrow has an internal left adjoint ∃f and an internal right adjoint ∀f ,
similiarly induced from external adjoints on subobject lattices by the Yoneda isomorphism. In the special
case of the morphism C → 1 this situation is summarized by

P C

∀C

∆C

∃C

/ Ω

∃C ⊣ ∆C ⊣ ∀C .

These adjoints compose (cid:3) := ∆∀ and ♦ := ∆∃ yielding an “adjoint modality” ♦ ⊣ (cid:3). Consequently, any
power object in a topos is an “internal S4-modal algebra.”

Example 5.3. Let F : F → E denote a geometric morphism between toposes. The direct image of the
subobject classiﬁer F∗ΩF is again a complete Heyting algebra in E . Since ΩE is the initial frame in E , there
is a unique frame morphism i : ΩE → F∗ΩF . On the other hand, a morphism τ : F∗ΩF → ΩE classiﬁes the
top element of F∗ΩF . These morphisms are internally adjoint with i ⊣ τ and by the proposition, iτ = (cid:3)
makes f∗ΩF into an S4-modal algebra in E (cf. Lemmas 1.2 and 1.3 of [Awodey, Kishida, & Kotzsch, 2014]).

As observed in the proof of Proposition 4.2 of [Awodey, Kishida, & Kotzsch, 2014], the adjunction i ⊣ τ
from the example arises via the Yoneda Principle from an external adjunction ∆ ⊣ Γ natural in A and various
natural isomorphisms

E (A, ΩE ) ∼= SubE (A)

Γ

∆

/ SubF (f ∗A) ∼= F (f ∗A, ΩF ) ∼= E (A, Ω∗).

7

/
/
/
/
/
/
/
o
o
/
o
o
See the reference for the construction of Γ. However, ∆ is the restiction of F ∗ to subobjects and that it is
injective implies that the unique frame homomorphism i is monic. The converse is also true.

Proposition 5.4. The following are equivalent:

1. ∆ above is injective;

2. f ∗ is faithful;

3. i : ΩE → Ω∗ is monic.

In the event that any of these conditions are satsiﬁed, F is said to be a surjection.

Proof. See Lemma VII.4.3 of [MacLane & Moerdijk, 1992] for the equivalence of the ﬁrst two statements.
That the third condition implies the ﬁrst is a consequence of Yoneda.

Deﬁnition 5.5. A surjective geometric morphism F : F → E is a geometric model. The associated
operator (cid:3) is a geometric modality.
Remark 5.6. The typical situation is the following. Let F : C → D denote any functor. In the development
below, this will be an estimator E : Σ → P C coming with an Abstract CBC protocol as in Deﬁnition 3.1. In
the general case, there is an induced essential geometric morphism

[C , Set]

F∗

∗

F

F!

/ [D, Set]

F! ⊣ F ∗ ⊣ F∗

In this case, F∗ΩC is an
where the adjoints to substitution are given by left and right Kan extensions.
S4-modal algebra in [D, Set]. This is a surjection if, and only if, every object of D is a retract of on in
the image of F (cf. A4.2.7(b) of [Johnstone, 2002]). Thus, an estimator E : Σ → P C in an Abstract CBC
protocol may give rise to a geometric model even if it is not an epimorphism by taking the bo-ﬀ factorization
of e and forgetting the ﬀ-part. So, it might as well be assumed that e is surjective on objects. However, this
is an unnatural assumption as discussed in the Introduction.

The semantics of the operator (cid:3) originate with [Kripke, 1963]. The basis of the present development is
proposition 4.9 of [Awodey, Kishida, & Kotzsch, 2014] that gives a forcing semantics of geometric modalities
induced by surjective geometric morphisms. The following preliminary result will be needed later on.
Lemma 5.7. If F : F → E is a geometric model, then for any φ : A → Ω∗ in E , the transposes satisfy
(cid:3)φ = ⊤A if, and only if, φ = ⊤A.

Proof. Consider the diagram

1

⊤∗

1

⊤

1

⊤∗

A

φ

/ Ω∗

/ ΩE

τ

/ Ω∗

i

Since i is a frame homomorphism, the rightmost square commutes; since i is monic, it is a pullback. Thus,
φ : A → Ω∗ factors through ⊤∗ if, and only if, (cid:3)φ factors through ⊤∗. Since ǫ is natural, the square

1

∗

(⊤∗)

1

⊤

(Ω∗)∗

/ ΩF

ǫ

commutes. Thus, for any ψ : X → Ω∗, the equation ψ = ⊤X holds if, and only if, ψ factors through ⊤∗ in
E . Therefore, the equivalences

establish the result.

φ = ⊤A ≡ φ factors through ⊤∗

≡ (cid:3)φ factors through ⊤∗
≡ (cid:3)φ = ⊤A

8

/
/
/
o
o
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
/
/
/
(cid:15)
(cid:15)
(cid:15)
(cid:15)
/
6 Presheaf Forcing Semantics of Estimate Safety

Forcing originates with Kripke’s semantics for intuitionistic logic [Kripke, 1965]. For further background
on Kripke-Joyal forcing as a semantics of topos logic see Chapter VI of [MacLane & Moerdijk, 1992]. This
section illustrates the role of the total cosieve in the forcing semantics of safety. While this does require the
use of geometric models, it forms the basis of the elementary axiomatization and forcing results later on.

Deﬁnition 6.1. A morphism a : W → X forces a proposition φ : X → Ω if the image of a : W → X factors
through Sφ as in the diagram

Sφ

<②

②

②

/ 1

⊤

/ X

/ Ω

φ

②
Im(a)

Equivalently, a forces φ(x) if φ(a) = ⊤W . Denote this situation by W (cid:13) φ(a).
Example 6.2. In the special case where E is a presheaf topos, the forcing relation has an especially nice
form. It suﬃces to restrict to a generating set, namely, that consisting of the canonical representable functors
and to genuine elements a ∈ X(C). One writes ‘C (cid:13) φ(a)’ in the place of ‘yC (cid:13) φ(a).’ The forcing relation
takes the form

C (cid:13) φ(a) if, and only if, a ∈ Sφ if, and only if, φC (a) = tC
That is, a forces φ in stage C if, and only if, a is in the comprhension of φ at stage C if, and only if, φC
evaluates at a to the total sieve on C.

Lemma 6.3 (Stability). If W (cid:13) φ(a), then V (cid:13) φ(ab) holds for any b : V → W .

Proof. This follows by the uniqueness of image factorizations in a topos.

Presheaf forcing as in the example can be relativised to an over-topos using a geometric morphism.

Consider the adjoint situation

[C , Set]

F∗
∗

F

F!

/ [D, Set]

F! ⊣ F ∗ ⊣ F∗

Recall that the transpose of a proposition is φ = ǫφ∗, obtained by applying F ∗ and composing with the counit
ǫ. The following gives the deﬁnition of the relativised notion of forcing. It is a modiﬁcation of Deﬁnition 4.8
in [Awodey, Kishida, & Kotzsch, 2014] by allowing F to be an arbitrary functor C → D.

Deﬁnition 6.4 (Relativised Forcing). An element a ∈ X(F C) forces φ(x) : X → Ω∗ in state C if C (cid:13) φ(a)
holds in [C , Set]. Denote this situation by C (cid:13)∗ φ(a).

The required semamtics for this relativisted notion of forcing is the following. Notice that the proof does

not require that F induces a geometric model.

Lemma 6.5 (Presheaf Forcing Semantics). C (cid:13)∗ φ(a) holds if, and only if, D (cid:13)∗ φ(f!a) for all f : C → D.

Proof. The equivalences

C (cid:13)∗ φ(a) ≡ C (cid:13) ǫφ∗(a)

≡ ǫφ∗(a) = ⊤C
≡ {f : C → D | f!(a) ∈ Sǫφ∗} = tC
≡ f!(a) ∈ Sǫφ∗ for all f : C → D
≡ ǫφ∗(f!(a)) = ⊤D for all f : C → D
≡ D (cid:13) ǫφ∗(f!(a)) for all f : C → D
≡ D (cid:13)∗ φ(f!(a)) for all f : C → D

9

establish the result.

(def. ‘(cid:13)∗’)
(def. ‘(cid:13)’)
(constr. ‘χ’)
(def. tC )
(def. Sǫφ∗ )
(def. ‘(cid:13)’)
(def. ‘(cid:13)∗’)

(cid:15)
(cid:15)
/
(cid:15)
(cid:15)
<
/
/
/
/
/
o
o
Now, give a presheaf forcing semantics of estimate safety. Fix the estimator E : Σ0 → P C in an estimate
consensus protocol as in Deﬁnition 3.1 and consider the associated geomtric morphism e : F → E with
F = [Σ, Set] and E = [P C, Set]. Interpret a proposition p ∈ P C as a subobject of 1 in [P C, Set] by

p(S) =

1
0

(

if p ⊂ S
otherwise

(6.1)

This is the same as noting that p induces a canonical representable functor yp : P C → Set and then by
taking support yp → U → 1 via image factorization there is a corresponding subobject of 1. Likewise, each
w ∈ Σ determines two such subojects – one in [Σ, Set] in the same manner, and another in [P C, Set] since
ew is an element of P C. In the theorem below, interpret such states and propositions used in formulas as
subobjects of 1. For a proposition p : U → 1, let χp : 1 → Ω denote the classifying arrow and let i : Ω → Ω∗
denote the unique frame homomorphism. This is monic if, and only if, E induces a geometric model. In this
case p is the subobject classiﬁed by iχp since the square involving i is also a pullback.

Theorem 6.6. Suppose that E : Σ0 → P C induces a geometric model. A proposition p : U → 1 is safe in
state w if, and only if, w (cid:13)∗ iχp.

Proof. Consider the following equivalences:

w (cid:13)∗ iχp ≡ v (cid:13)∗ iχp for all w → v
≡ v (cid:13) iχp for all w → v
≡ v ≤ S iχp in SubF (1) for all w → v
≡ ev ≤ p in Sub(1)E for all w → v

≡ ev ⇒ p = ⊤ in Sub(1)E for all w → v.

(Lemma 6.5)
(def ‘(cid:13)∗’)
(def. ‘(cid:13)’)

(transpose & i monic)

(Lemma 2.2)

Note that the second to last step uses the fact that the transpose of S iχp is isomorphic to p as subobjects
of 1 in E because p is the subobject classiﬁed by iχp since i is monic.

Corollary 6.7 (Persistence). If E induces a geometric model, then if p is safe in w and w → v is an
execution, then p is safe in v too.

Proof. The theorem shows that safety is a forcing relation. Lemma 6.5 then establishes the statement since
any state accessible from v is one accessible from w.

Now, give a modal interpretation of estimate safety. Adopt the same set-up as for Theorem 6.6 above.
The required semantics for (cid:3) extends Proposition 4.9 in [Awodey, Kishida, & Kotzsch, 2014] from inclusions
|C | → C to functors C → D inducing a geometric model.

Theorem 6.8 ((cid:3)-Semantics). Suppose that F : F → E is a geometric model. Then C (cid:13)∗ (cid:3)φ(a) holds if,
and only if, D (cid:13)∗ φ(f!a) holds for all f : C → D.

Proof. Consider the following equivalences:

C (cid:13)∗ (cid:3)φ(a) ≡ C (cid:13) (cid:3)φ(a)
≡ (cid:3)φ(a) = tC
≡ φ(a) = tC
≡ C (cid:13) φ(a)
≡ C (cid:13)∗ φ(a)
≡ D (cid:13)∗ φ(f!a) for all f : C → D

(def. ‘(cid:13)∗’)
(def. ‘(cid:13)’)

(Lemma 5.7)
(def. ‘(cid:13)’)
(def. ‘(cid:13)∗’)
(Lemma 6.5)

These establish the result.

Corollary 6.9 (Modal Interpretation of Safety). Assume that E results in a geometric model. A proposition
p is safe in w if, and only if, w (cid:13)∗ (cid:3)iχp.

10

Proof. This follows from Theorem 6.6 above, Lemma 6.5 and ﬁnally Theorem 6.8.

Remark 6.10. There are at least two reasons that it might be expected the safety results above would
involve passing to sheaf toposes. First any P C, even in a elementary topos, is the direct image of the
§5 of
subobject classiﬁer of a sheaf topos, namely, sheaves on P C viewed as an internal frame (cf.
[Awodey, Kishida, & Kotzsch, 2014]). Additionally the space of consensus values should be nonempty, that
is, should admit an epimorphism C → 1, meaning that the induced geometric morphism from sheaves on
P C to the base topos should be a surjection. Clearly, Ω in the base topos then embeds faithfully into Ω∗
and the conditions of the previous results are satisﬁed. Additionally, subobjects of 1 in sheaves on P C are
precisely the global elements of P C, so there is a 1-1 correspondence between propositions about consensus
values and subobjects of 1. However, this does not work for at least a couple of reasons. First is that forcing
should happen relative to protocol states, not generalized elements of P C. Secondly, the semantics of the
total coseive in Lemma 6.5 were crucial in the sense that it ensures that the directed upperset on a state w is
contained below the safe proposition p. This be a cosieve, as otherwise, for ordinary sheaves (contravariant
functors!), the subobject classiﬁer is sets of sieves, namely, downward closed sets.

7 Consensus Protocols in a Topos

Abstract CBC can be formulated in an arbitrary topos. An estimator will pick out a proposition for every
protocol state in a functorial way. Therefore, an estimator is an internal functor e : Σ → P C satisfying the
internalized version of the compatibility condition. Here is the formal deﬁnition.

Deﬁnition 7.1. An estimate consensus protocol in a topos E consists of

1. an object C of consensus values;

2. an internal category Σ of protocol states Σ0 and executions Σ1;

3. an internal functor e : Σ → P C called the estimator satisfying the condition that

if e(w) ⇒ p = ⊤ for some state w : X → Σ0, then ¬(e(w) ⇒ ¬p) = ⊤

(7.1)

for any proposition p : 1 → P C.

This phrasing has the advantage of incorporating all the data in a single morphism e : Σ → P C of
Cat(E ). It therefore is not too much to identify an estimate safety consensus protocol with the internal
functor e : Σ → P C. Now, the main deﬁnition of the paper:

Deﬁnition 7.2. A proposition p : 1 → P C is safe in the protocol state w : W → Σ0 if for any execution
f : w → v, it follows that ew ⇒ p = ⊤ holds.

Proposition 7.3 (Persistence). If p ⇒ q = ⊤, then that p is safe in w, implies that q is safe in w too.

Proof. Start with any execution w → v and assume that ev ⇒ p = ⊤. Then by Lemma 2.2, equivalently
ev ≤ p ≤ q holds and therefore by transitivity of ‘≤’ and the same lemma ev ⇒ q = ⊤, as required.

Deﬁnition 7.4. States w1, w2 : Σ0 are compatible if there is a state w3 : Σ0 and executions w1 → w3 ← w2.
Denote compatibility by ‘w1 ≃ w2’. Compatible states are said to have a common future.

In this set-up it is possible to give a completely elementary account of the presheaf forcing semantics of
the previous sections. This is a prelude to the account given in §8 that uses internal category theory without
direct reference to the internal diagram categories used here. This is a somewhat tangential discussion that
can be skipped without losing the main thread.

First recall some standard deﬁnitions (cf. §V.7 of [MacLane & Moerdijk, 1992] or §B2.3 of [Johnstone, 2002]).

Throughout let S denote a topos thought of as playing the role of Set. An internal category C in S
consists of the data of objects and arrows

C1 ×C0 C1

⊗ /

/ C1

d0
y

d1

/ C0

11

/
/
/
o
o
satisfying the usual axioms for a category in diagrammatic form. An internal functor f : C → D consists
of arrows f0 : C0 → D0 and f1 : C1 → D1 commuting with the identity, domain, codomain and composition
morphisms coming with C and D.
Deﬁnition 7.5. Let C denote a category in S . An internal diagram on C consists of an arrow γ : X → C0
and an action morphism m : X ×C0 C1 → C1 such that

X ×C0 C1 ×C0 C1

1×m /

/ X ×C0 C1

X

m×1

X ×C0 C1

m

m

/ X

/ X ×C0 C1

hγ,yi /

■■■■■■■■■■
■■■■■■■■■■

m

X

both commute. A morphism of internal diagrams is an arrow f : X → Y that is equivariant with respect to
the actions; that is, the diagram

X ×C0 C1

f ×1 /

/ Y ×C0 C1

m

X

n

/ Y

f

commutes. Internal diagrams and their morphisms form a category [C, S ].

Categories of internal diagrams are an elementary version of base-valued functors, that is, ordinary
presheaves on the given category. Needed results on such categories are developed in §B2.3 of [Johnstone, 2002].
There it is shown that the underlying functor [C, S ] → S /C0 is comonadic, making [C, S ] a topos. Addi-
tionally, any internal functor F : C → D induces a geometric morphism

F : [C, S ] → [D, S ].

This is an internal analogue of the geometric morphism induced by a functor between ordinary presheaf
toposes. Forcing has the following form. A proposition and generalized element will take the form of
commutative triangles such as

Z

c

a

/ X

γ

φ

/ Ω

ω

C0
Mimicing the presheaf phrasing of forcing, c (cid:13) φ(a) holds if a factors through Sφ in [C, S ]. Denote the map
accomplishing this by ˆa : W → Sφ where u : Sφ → X computes the required pullback in [C, S ]. The ﬁrst
result concerning forcing follows essentially by equivariance. It is an internal version of Lemma 6.5.

C0

C0

Lemma 7.6. For any φ : X → Ω in [C, S ], if c (cid:13) φ(a) holds, then d (cid:13) φ(f!a) for all f : c → d with f : C1.

Proof. Here f!(a) = mha, f i is the result of the action of the element f of C1 on a. It needs to be seen that
φf!(a) factors through Sφ as well. This is proved by the diagram (ignoring the morphisms to the base C0)

Sφ ×C0 C1

n /

/ Sφ

/ 1

u

u

⊤

hˆa,f i

:✉✉✉✉✉✉✉✉✉✉

Z

/ X ×C0 C1 m

a

/ X

/ Ω

φ

which commutes by construction of ˆa, construction of Sφ and ﬁnally the fact that Sφ and X are both internal
diagrams and that u preserves the action of C1.

With the technical result proven, the forcing semantics of the adjoint modality can be given. First

internalize Deﬁnition 6.4 to an induced geometric morphism of diagram toposes.

12

(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
/
(cid:15)
(cid:15)
(cid:15)
(cid:15)
/
(cid:15)
(cid:15)
/
(cid:15)
(cid:15)
/
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
(cid:15)
/
(cid:15)
(cid:15)
:
/
/
/
Deﬁnition 7.7. Let F : C → D denote an internal functor in S . An element a : W → X as above forces
φ : X → Ω∗ in state w if w (cid:13) φ(a) holds in [C, S ]. Denote this situation by w (cid:13)∗ φ(a).

Theorem 7.8 (Internalized Forcing Semantics). In the notation above, c (cid:13)∗ φ(a) holds if, and only if,
d (cid:13)∗ φ(f!a) holds for all f : c → d.

Proof. The computation of Theorem 6.5 can be recreated internally using Lemma 7.6.

8 Estimate Safety in a Topos

Provided one can countenance a little internal category theory, the forcing semantics of safety take on an
especially nice form without requiring passage to internal diagram categories and without appealing to the
mechanisms of geometric models. The point of the geometric models development was the revelation of the
central of the total cosieve, whose elementary analogue can be developed with some internal category theory.
Throughout work internally with a estimate consensus protocol e : Σ → P C in a given ﬁxed topos E as

in Deﬁnition 7.1. For any state w : W → Σ0, form the object of executions from w as the pullback

Σ(w, −)

/ Σ1

d0

W

/ Σ0.

w

This will play the role of the total cosieve on w. Notice that since d0 is an epimorphism (it is split by i), so
is the projection to W , as epimorphisms are pullback-stable. In other words, Σ(w, −) is a sort of generalized
protocol execution deﬁned on w. Now take any execution f : w → v on w, that is, a generalized element
f : X → Σ1 with an epimorphism making a commutative square

X

f

/ Σ1

d0

W w

/ Σ0.

There is then a unique morphism ˆf : X → Σ(w, −) by the universal property of the pullback, interpretable
as the statement that f is an element of the “ﬁber” of the reprentable functor at v ∈ Σ0. For any proposition
p : 1 → P C, form the implication x ⇒ p for a variable x : P C as the composite

P C ∼= P C × 1

x×p /

/ P C × P C ⇒ /

/ Ω

where ‘⇒’ is the classifying arrow of the order object (≤) → P C × P C. There is then the following result,
essentially stating that estimate safety is equivalent to forcing this proposition by the representable Σ(w, −).
As is customary with presheaf forcing, identify w with the representable Σ(w, −) in the forcing notation.
That is, write ‘w (cid:13) x ⇒ p’ as a shorthand for ‘Σ(w, −) (cid:13) x ⇒ p’.

Theorem 8.1. A proposition p : 1 → P C is safe in state w if, and only if, w (cid:13) (x ⇒ p)(ed1).

Proof. First show necessity. Since Σ(w, −) is an execution deﬁned on w, the morphism ed1π2 : Σ(w, −) → P C
satisﬁes d1eπ2 ⇒ p = ⊤ by the hypothesis of safety. Thus, there is a factorization

Sx⇒p
:✉

✉

✉

✉

/ 1

⊤

/ P C x⇒p

/ Ω

ed1π2

✉
Σ(w, −)

since the square is a pullback, proving the forcing statement. On the other hand, for suﬃciency, assume the
forcing statement. In particular, ed1π2 ⇒ p = ⊤ holds. Let f : w → v be any execution on w. Then by

13

(cid:15)
(cid:15)
(cid:15)
(cid:15)
/
(cid:15)
(cid:15)
/
(cid:15)
(cid:15)
(cid:15)
(cid:15)
/
(cid:15)
(cid:15)
/
(cid:15)
(cid:15)
/
(cid:15)
(cid:15)
:
/
/
deﬁnition, f factors through Σ(w, −) via a unique map ˆf : X → Σ(w, −) satisfying in particular π2 ˆf = f .
Thus, compute that

⊤ = ed1π2 ˆf ⇒ p
= ed1f ⇒ p
= ev ⇒ p

proving that p is safe in w.

However, in light of Theorem 8.1, write ‘w (cid:13) x ⇒ p’ to indicate that p is safe in w. The practical upshot is
that the well-known forcing semantics (cf. Theorem VI.6.1 of [MacLane & Moerdijk, 1992]) of usual logical
connectives can be used to prove safety results. In particular, for any implication statement φ ⇒ ψ with
φ, ψ : X ⇒ Ω and a : U → X, there is the equivalence

U (cid:13) φ(a) ⇒ ψ(a) if, and only if, V (cid:13) φ(af ) implies V (cid:13) ψ(af ) for all f : V → U.

(8.1)

As an immediate consequence, there is the next result.

Corollary 8.2. A proposition p is safe in state w if, and only if, v (cid:13) x(ev) implies that v (cid:13) p for all
executions f : w → v on w.

Proof. Interpret p : 1 → P C as deﬁned on P C by composing with the unique map P C → 1. Then use
Theorem 8.1 and the equivalence 8.1.

Corollary 8.3 (Persistence). If w (cid:13) x ⇒ p holds and p ⇒ q = ⊤, then w (cid:13) x ⇒ q holds too.

Proof. Use the previous corollary and transitivity of implication.

Now, the preliminaries of §3 can be reproved in the present context.

Lemma 8.4 (Forward Consistency). For any execution f : w → v, if p is safe in w, then p is safe in v.
That is, in notation, if w (cid:13) (x ⇒ p) then v (cid:13) (x ⇒ p).

Proof. Any execution f : w → v induces a morphism f ∗ : Σ(v, −) → Σ(w, −) and conversely. This is basically
the internalized ﬁbered Yoneda lemma (cf. §B2.7 [Johnstone, 2002] for example) although it can be worked
out by hand using universal properties of pullbacks. By forcing stability 6.3, v (cid:13) (x ⇒ p) then holds.

Lemma 8.5 (Current Consistency). If p is safe in w, then ¬p is not safe in w. That is, if w (cid:13) (x ⇒ p)
holds then ∼ (w (cid:13) (x ⇒ ¬p)).

Proof. If w (cid:13) (x ⇒ ¬p) holds, then in particular ew ≤ ¬p does too. Consequently, by contraposition, if
ew (cid:2) ¬p holds, then ∼ (w (cid:13) (x ⇒ ¬p)). In general if ew ≤ p, then ew (cid:2) ¬p by assumption on e. Therefore,
since w (cid:13) (x ⇒ p) implies in particular that ew ≤ p, the conclusion follows.

Lemma 8.6 (Backward Consistency). For all executions f : w → v, if p is safe in v, then ¬p is not safe in
w. That is, if v (cid:13) (x ⇒ p) holds, then ∼ w (cid:13) (x ⇒ ¬p).

Proof. By the previous two lemmas, w (cid:13) (x ⇒ ¬p) implies that ∼ v (cid:13) (x ⇒ ¬¬p). Therefore, by contra-
position, ∼∼ (v (cid:13) (x ⇒ ¬¬p)) implies that ∼ (w (cid:13) (x ⇒ ¬p)). But note that v (cid:13) (x ⇒ p) implies that
v (cid:13) (x ⇒ ¬¬p) by Corollary 8.3 since p ≤ ¬¬p always holds. But this implies that ∼∼ (v (cid:13) (x ⇒ ¬¬p))
holds too. Putting together these implications, the result then follows.

The main result of the paper is now the following.

Theorem 8.7 (Estimate Safety). Inconsistent propositions are not safe at related states. That is, if p∧q = ⊥
and w1 ≃ w2 both hold, then it is not the case that both w1 (cid:13) (x ⇒ p) and w2 (cid:13) (x ⇒ q) hold.

14

Proof. By Lemma 2.3, p ∧ q = ⊥ is equivalent to q ≤ ¬p which is equivalent to q ⇒ ¬p = ⊤. Now, by
Forward Consistency and Backward Consistency, the implications

w1 (cid:13) (x ⇒ p) ⊃ w3 (cid:13) (x ⇒ p) ⊃∼ (w2 (cid:13) (x ⇒ ¬p))

hold. By the Persistence Lemma 7.3 applied to q ⇒ ¬p and contraposition,

(∼ w2 (cid:13) (x ⇒ ¬p)) ⊃ (∼ w2 (cid:13) (x ⇒ q)).

Therefore, putting together the implications in 8.2 and 8.3,

(w1 (cid:13) (x ⇒ p)) ⊃ (∼ w2 (cid:13) (x ⇒ q))

(8.2)

(8.3)

holds metatheoretically. Thus, if p is safe in w1 then q cannot be safe in w2. The argument is perfectly
symmetric, hence the roles of p and q and of w1 and w2 can be interchanged. Therefore, not both w1 (cid:13) (x ⇒
p) and w2 (cid:13) (x ⇒ q) as required.

9 Decided Propositions in a Topos

Decided properties of protocol states are considered for example in [Zamﬁr et. al. 2019]. Once safety is
established, protocol states can be decided. Here the notion is formalized in a topos S .

Deﬁnition 9.1. A property p : Σ → Ω is decided for a state w : W → Σ if it is valid in all future states
accessible from w. That is, p is decided for w if for all w → v, it follows that pv = ⊤.

In this set up, a forcing interpretation of decided propositions is a special case of that for estimate safety

in Theorem 8.1. Recall that ‘w’ on the left of ‘(cid:13)’ is a shorhand for Σ(w, −).

Corollary 9.2. A proposition p is decided in w if, and only if, w (cid:13) p holds.

Proof. The proposition p plays the role of e in Theorem 8.1 since P 1 = Ω and p = p ⇒ ⊤. In other words,
the equivalences

w (cid:13) p ≡ w (cid:13) p ⇒ ⊤

≡ v (cid:13) p ⇒ ⊤ for all w → v
≡ v (cid:13) p for all w → v
≡ pv = ⊤ for all w → v

(p = p ⇒ ⊤)
(Theorem 8.1)

(p = p ⇒ ⊤)
(def ‘(cid:13)’)

prove the result.

As a result, write ‘w (cid:13) p’ to indicate that p is decided in w. Theorem 8.7 implies that inconsistent

propositions cannot be decided in states with a common future.

Corollary 9.3. Inconsistent state-propositions cannot both be decided in related protocol states. That is, if
two states w1 and w2 have a common future state and if p ∧ q = ⊥ holds, then p and q cannot both be decided
in states w1 and w2, respectively, that is, w1 (cid:13) p and w2 (cid:13) q cannot both hold.

Proof. Since w (cid:13) p is equivalent to w (cid:13) p ⇒ ⊤, Theorem 8.7 proves the result.

Close with a modal interpretation of decided states. This is more natural since Σ → 1 should always
be an epimorphism. First work over Set. Let F = [Σ, Set] and Γ : F → Set denote the canonical
global sections geometric morphism with inverse image given by the diagonal presheaf functor (cf. §I.6
[MacLane & Moerdijk, 1992]). There is then an adjoint modality

Γ(1, ΩF )

τ

/ 2

i

/ Γ(1, ΩF )

15

/
/
yielding the modal operator (cid:3) = iτ . Note that i is monic. View the terminal object in F as given by
w 7→ {w}. Suppose that the proposition p : Σ0 → 2 extends to a functor Σ → 2. In this case p determines
one p : 1 → ΩF in F by the assignments

w 7→

tw
∅

(

if pw = 1
otherwise.

Interpret (cid:3)p : 1 → ΩF as its image under (cid:3). There is then the following result.

Proposition 9.4. A proposition p : 1 → Ω is decided in state w if and only if w (cid:13)∗ (cid:3)p holds.

Proof. The computation

w (cid:13)∗ (cid:3)p ≡ v (cid:13)∗ p for all w → v
≡ v (cid:13) ¯p for all w → v
≡ ǫvp = tv for all w → v
≡ p(v) = tv for all w → v

(Theorem 6.8)
(def. ‘(cid:13)∗’)
(def. ‘(cid:13)’)
(constr. ǫ)

proves the result by the construction of the transpose.

10 Prospectus

This study is not meant explicitly to advance the practical implementation of consensus protocols in the
various languages in which they are written. The hope has at least been to illustrate applicability of topos
theory to the description of those protocols and introduce these ideas especially to the applied category
theory community. At most there is the possibility that such descriptions clarify the issues in such a way as
to facilitate future developments in consensus protocol design and implementation.

Mathematically there is work to be done mostly on the questions raised implicitly in Remark 6.10. This
is that of whether sheaves play a role in the forcing semantics developed in that subsection. This seems
likely, although somewhat awkward to work out. This is because the cosieves arising in the subobject
classiﬁer for copresheaves has played a central role. Passing to presheaves and then onto sheaves introduces
contravariance, hence ordinary sieves, which eliminates the item playing the most important role in the
present semantics. However, thinking of copresheaves and presheaves as forming the algebraic and geometric
sides of some abstract “Isbell Duality,” it seems plausible that there is a way of reworking the results of
this paper either to make sense for sheaves, or perhaps “to cosheaﬁfy” the present covariant version without
passing to the explicitly geometric side of the duality.

References

[Awodey, Kishida, & Kotzsch, 2014] S. Awodey, K. Kishida, & H.-C. Kotzsch. “Topos Semantics for Higher-

Order Modal Logic.” Logique et Analyse, 57(228): pp. 591-636.

[Borceux, 1994] F. Borceux. Handbook of Categorical Algebra 3: Categories of Sheaves. Encyclopedia of

Mathematics and its Applications 52. Cambridge University Press, 1994.

[Buterin, 2013] V. Buterin. “A Next-Generation Smart Contract and Decentralized Application Platform.”

https://ethereum.org/en/whitepaper/, 2013.

[Buterin, 2017] V.

Buterin.

“Incentives

in

Casper

the

Friendly

Finality

Gadget.”

https://github.com/ethereum/research/blob/master/papers/casper-economics/casper_economics_basic.pdf,
2017.

[Buterin & Griﬃth, 2017] V. Buterin & V. Griﬃth.

“Casper

the Friendly Finality Gadget.”

https://github.com/ethereum/research/tree/master/papers/casper-basics, 2017.

16

[Gramoli, 2020] V. Gramoli. From Blockchain Consensus back to Byzantine Consensus. Future Generation

Computer Systems, 107: pp. 760-769.

[Johnstone, 2002] P. Johnstone. Sketches of an Elephant: A Topos Theorey Compendium, Vol 1/2. Oxford

Logic Guides 43/44. Clarendon Press, 2002.

[Kripke, 1963] S. Kripke. “Semantical Considerations on Modal Logic.” Acta Philosophica Fennica 16: pp.

83-94.

[Kripke, 1965] S. Kripke. “Semantical Analysis of Intionistic Logic.” Formal Systems and Recursive Func-

tions ed. Crossley & Dummett. North-Holland, Amsterdam, pp. 92-130.

[MacLane & Moerdijk, 1992] S. MacLane & I. Moerdijk. Sheaves in Logic and Geometry: A First Introduc-

tion to Topos Theory. New York, Springer, 1992.

[Nakamoto, 2008] S.

Nakamoto.

“Bitcoin:

A

Peer-to-Peer

Electronic

Cash

System.

https://bitcoin.org/en/bitcoin-paper, 2008.

[Zamﬁr, 2017] V.

Zamﬁr.

A

Template

for

Correct-by-Construction

Consensus

Protocols.

https://github.com/ethereum/research/tree/master/papers/cbc-consensus, 2017.

[Zamﬁr, 2018] V. Zamﬁr. “Casper the Friendly Ghost: A ‘Correct-by-Construction’ Blockchain Consensus

Protocol.” https://github.com/ethereum/research/tree/master/papers/CasperTFG, 2018.

[Zamﬁr et. al. 2019] V. Zamﬁr, N. Rush, A. Asgaonkar, & G. Piliouras. “Introducing the ‘Minimal CBC
Casper’ Family of Consensus Protocols.” https://github.com/cbc-casper/cbc-casper-paper, 2019.

17

