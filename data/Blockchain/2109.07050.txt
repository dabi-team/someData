1
2
0
2

p
e
S
5
1

]

R
C
.
s
c
[

1
v
0
5
0
7
0
.
9
0
1
2
:
v
i
X
r
a

The Elliptic Net Algorithm Revisited

Shiping Cai1, Zhi Hu2, Zheng-An Yao1, and Chang-An Zhao1,3

1 School of Mathematics, Sun Yat-sen University, Guangzhou 510275, P.R. China
2 School of Mathematics and Statistics, Central South University, P.R. China
3 Guangdong Key Laboratory of Information Security, Guangzhou 510006, P.R.
China

Abstract. Pairings have been widely used since their introduction to
cryptography. They can be applied to identity-based encryption, tripar-
tite Diﬃe-Hellman key agreement, blockchain and other cryptographic
schemes. The Acceleration of pairing computations is crucial for these
cryptographic schemes or protocols. In this paper, we will focus on the El-
liptic Net algorithm which can compute pairings in polynomial time, but
it requires more storage than Miller’s algorithm. We use several methods
to speed up the Elliptic Net algorithm. Firstly, we eliminate the inverse
operation in the improved Elliptic Net algorithm. In some circumstance,
this ﬁnding can achieve further improvements. Secondly, we apply lazy
reduction technique to the Elliptic Net algorithm, which helps us achieve
a faster implementation. Finally, we propose a new derivation of the for-
mulas for the computation of the Optimal Ate pairing on the twisted
curve. Results show that the Elliptic Net algorithm can be signiﬁcantly
accelerated especially on the twisted curve. The algorithm can be 80%
faster than the previous ones on the twisted 381-bit BLS12 curve and
71.5% faster on the twisted 676-bit KSS18 curve respectively.

Keywords: Elliptic Net Algorithm · Twists of Elliptic Curves · Pairings · De-
nominator Elimination · High Security Level.

1

Introduction

Pairings as mathematical primitives can oﬀer eﬃcient solutions to some special
diﬃcult problems in cryptography [25]. Nowadays, pairings still play a vital role
in some areas. In the blockchain, pairings can be applied for the zero-knowledge
succinct non-interactive argument of knowledge (zk-SNARK) [8,14]. Moreover,
pairings can be used for the compression of public keys in the isogeny-based
cryptosystem [26].

The implementation of pairings is a key operation in these applications. The
Weil pairing, the Tate pairing and their variants such as the Ate pairing [17,21],
the R-ate pairing [19], and the Optimal Ate pairing [34] are used in some cryp-
tographic schemes. It is well known that pairings can be computed by Miller’s
algorithm [22,23] which was proposed in 1986. Miller’s algorithm has been opti-
mized a lot since 2000, and it has been developed to be in a relatively mature

 
 
 
 
 
 
2

Shiping Cai, Zhi Hu, Zheng-An Yao, and Chang-An Zhao

stage. There also exists another polynomial time algorithm to compute pair-
ings, i.e., the Elliptic Net algorithm. This algorithm was proposed in 2007 by
Stange [31] who ﬁrst deﬁned elliptic nets and gave a relationship between el-
liptic nets and the Tate pairing. We abbreviate this original Elliptic Net algo-
rithm to ENA. Compared with Miller’s algorithm, the Elliptic Net algorithm
requires more computational costs while it can be implemented eﬃciently on a
personal computer. Furthermore, there is no inverse operation involved in aﬃne
coordinates in the Elliptic Net algorithm. Therefore, the implementation of this
algorithm is simple and intuitive.

Elliptic nets are generated by elliptic divisibility sequences which were ﬁrst
studied by Morgan Ward [35] in 1948. These sequences arise from any choice of
an elliptic curve and rational points on that curve. For more information about
elliptic divisibility sequences see [10]. The method called Double-and-Add for
updating each value of an elliptic divisibility sequence in polynomial time which
was proposed by Rachel Shipsey [30].

Pairings can be computed using elliptic nets of rank 2. The ENA was used to
compute the Tate pairing originally [31]. Then the explicit formulas for comput-
ing some variants of the Tate pairing using the ENA were given [33,27]. In 2015,
an improved version of the ENA was proposed [7]. We abbreviate this algorithm
to IENA in this work. The IENA can perform well if the parameter of the Miller
loop has low Hamming weight. Fortunately, the most popular paring-friendly
curves all meet this condition. Due to the particularity of the structure of el-
liptic nets, an parallel strategy for the ENA to compute pairings was proposed
[28].

Elliptic nets of rank 1 can be applied to scalar multiplication, and it is an
algorithm that can resist side-channel attacks. Kanayama et al. [18] adopted the
ENA to compute scalar multiplication using elliptic nets of rank 1, i.e., division
polynomials. Besides, there are some other works about scalar multiplication
based on elliptic nets. An optimized version of scalar multiplication algorithm
using division polynomials was proposed in [6], which saved f our multiplications
at each iteration by using the equivalence of elliptic nets. Based on these previous
works, Rao et al. [32] proposed a modiﬁed algorithm based on elliptic nets to
compute scalar multiplication.

However, the eﬃciency of the Elliptic Net algorithm still needs to be avoided.
In order to shorten the gap between the Elliptic Net algorithm and Miller’s algo-
rithm in eﬃciency, we develop several methods. Firstly, we analyze the properties
of elliptic nets and conclude that the inverse operation in the IENA can be elim-
inated. Secondly, we construct the Optimal Ate pairing on the twisted curve
and discuss the relationship between the Optimal Ate pairing on the original
elliptic curve and that on the twisted curve with divisor and pull-back. This is
a new derivation of the formulas for pairing computation which is entirely on
the twisted curve. Thirdly, lazy reduction technique is employed in our imple-
mentation to get a further improvement. The speciﬁc contributions of this work
are:

The Elliptic Net Algorithm Revisited

3

– We explore how to eliminate the inverse operation in the IENA. For the
IENA, an inverse operation is involved at addition step in the Double-and-
Add algorithm. In this paper, we get a result in the updating process of the
IENA. If all the values of an elliptic net in the current state are multiplied
by a non-zero ﬁxed value, then the value of the reduced Tate pairing or its
variants can not be changed. This ﬁnding means that the inverse operation
can be replaced by several multiplications. The implementation indicates
that the IENA works well if it is further modiﬁed by this trick. Besides, this
trick contributes to the scalar multiplication algorithm in [32].

– The idea of twists is employed to speed up the Elliptic Net algorithm. Twists
of elliptic curves are deeply applied to Miller’s algorithm, which can signiﬁ-
cantly decrease the amount of multiplications. More detailed descriptions see
[15,17]. Throughout the process of Miller’s algorithm, Costello et al. [9] ex-
plored the pairing computation which is entirely on the twisted curve. Based
on these works, we use the Elliptic Net algorithm to compute the Optimal
Ate pairing entirely on the twisted curve. We will provide a new proof based
on the theory of divisors and pull-back, which has a strength that it not
depends on the process of Miller’s algorithm. Hence, this is totally diﬀerent
from the previous work. Furthermore, we give the explicit formulas of the
line function of the Optimal Ate pairing on the twisted curve. We boost
the performance of the Elliptic Net algorithm on a 381-bit BLS12 curve at
128-bit security level and a 676-bit KSS18 curve at 192-bit security level by
using twists [4]. Twists of elliptic curves allow us to transfer the operations
from Fqk to the proper subﬁeld of Fqk , which signiﬁcantly reduces the total
amount of multiplications.

– We adopt lazy reduction technique [20] which only performs one reduction
for the sum of several multiplications to the Elliptic Net algorithm. Lazy
reduction was ﬁrst introduced in quadratic extension ﬁeld arithmetic for
Miller’s algorithm by Michael Scott [29] and further developed in [2]. In the
Elliptic Net algorithm, we observe that there are many terms have the form
A · B − C · D, which inspires us to apply lazy reduction for this algorithm.
In our implementation, lazy reduction reduces by around 27% the number
of modular reductions.

We conclude that pairings can be eﬃciently computed with the Elliptic Net
algorithm. Even though it is still slower than Miller’s algorithm, the ratio of the
cost of the Elliptic Net algorithm to Miller’s algorithm is reduced from more
than 9 to less than 2 after the modiﬁcation in this work.

The rest of this paper is organized as follows. Section 2 gives an overview of
pairings, twists of elliptic curves and the Elliptic Net algorithm. In Section 3, we
replace an inverse operation by several multiplications in the IENA. Section 4
analyzes the Ate pairing and Optimal Ate pairing on the twisted curve that
are computed by the Elliptic Net algorithm. In Section 5, we apply lazy reduc-
tion technique to the Elliptic Net algorithm. The implementation and eﬃciency
analysis are discussed in Section 6. Section 7 concludes the paper.

4

Shiping Cai, Zhi Hu, Zheng-An Yao, and Chang-An Zhao

2 Preliminaries

In this section, we will give the deﬁnition of the Tate pairing and the (Optimal)
Ate pairing. A brief description of twists of elliptic curves and the Elliptic Net
algorithm will also be provided.

2.1 Pairings

Let Fq be a ﬁnite ﬁeld where q = pm (m ∈ Z+) and p is a prime. Let E be an
elliptic curve deﬁned over Fq. We denote the q-power Frobenius endomorphism
on E by πq. The number of points on E/Fq is given by #E(Fq) = q + 1 − t,
where t is the Frobenius trace of πq.

Choose a large prime r with r|#E(Fq), and let k ∈ Z+ be the embedding
degree with respect to r such that r|qk − 1 but r2 ∤ qk − 1. Choose P ∈ E(Fq)[r]
and Q ∈ E(Fqk )[r]. The r-th roots of unity in Fqk , which we denote by µr.

For an integer i and a point S on E, let fi,S be a rational function such that

Div(fi,S) = i(S) − (iS) − (i − 1)(∞).

In particular, Div(fr,P ) = rDP = r(P )−r(∞). Then the reduced Tate pairing
[12] is deﬁned as

T ate : E(Fq)[r] × E(Fqk )[r] → µr

(P, Q) 7→ T ate(P, Q) = fr,P (Q)qk−1/r.

Furthermore, if we choose P and Q in speciﬁc subgroups of E[r], the pairing

computation can be sped up. Deﬁne

G1 , E[r]

Ker(πq − [1]), G2 , E[r]

Ker(πq − [q]).

\

\

Choose P ∈ G1 and Q ∈ G2. Let T = t − 1. We can deﬁne a pairing when
r ∤ (T k − 1)/r:

AteE : G2 × G1 → µr

(Q, P ) 7→ AteE(Q, P ) = fT,Q(P )qk−1/r,

which is called the Ate pairing [17].

The Ate pairing is a variant of the Tate pairing, and the length of the Miller
loop is short[21,19]. The Optimal Ate pairing allows us to obtain the shortest
loop length [34]. We have the following theorem [34,37,38].

Theorem 1. Let λ = αr with r ∤ α. We have λ =
Euler function of k, then we can deﬁne a bilinear map

P

ϕ(k)
i=0 ciqi, where ϕ(k) is the

OptE : G2 × G1 → µr

(Q, P ) 7→ OptE(Q, P ) = (

f qi
ci,Q(P )·

Yi=0

Yi=0

ϕ(k)−1

ϕ(k)−1

l[si+1]Q,[ciqi]Q(P )
v[si]Q(P )

)qk−1/r,

The Elliptic Net Algorithm Revisited

5

where si =
OptE is non-degenerate. We call OptE as the Optimal Ate pairing.

j=i cjqj. If αkqk−1 6=

qk − 1

iciqi−1(mod r), then

/r

(cid:0)(cid:0)

(cid:1)

(cid:1) P

P

ϕ(k)−1
i=0

ϕ(k)

The explicit expression of the Optimal Ate pairing depends on the family type
of pairing-friendly curves. In this work, we mainly consider the implementation
of the Optimal Ate pairing on the BLS12 and KSS18 curves. More speciﬁc in-
formation will be discussed in Section 6.

2.2 Twists of Elliptic Curves
Deﬁnition 1. A twist of degree d of E is an elliptic curve E′ deﬁned over Fqk/d.
We can deﬁne an isomorphism Ψd over Fqk from E′ to E with d is minimal:

Ψd : E′

Fqk/d
(cid:0)

−→ E

.

Fqk
(cid:0)

(cid:1)
The potential degree d is 2, 3, 4 or 6 [25,15]. For the BLS12 and KSS18 curves,
E′ is a twist of degree 6 of E. Let ξ ∈ Fqk/6. For the M-type and D-type twists
[3] with degree d = 6, the corresponding isomorphism Ψ6 is given as follows:

(cid:1)

M − type : E′ : y2 = x3 + bξ

D − type : E′ : y2 = x3 + b/ξ

Ψ6 : E′ → E : (x, y) 7→

ξ−1/3x, ξ−1/2y
(cid:16)
Ψ6 : E′ → E : (x, y) 7→

ξ1/3x, ξ1/2y
(cid:16)

(1)

,

.

(cid:17)

(cid:17)

Furthermore, we have the following theorem for the Tate pairing:

Theorem 2. [5] Let E1/Fq be an elliptic curve. Choose r0|#E1(Fq). Suppose
that the embedding degree with respect to q and r0 is k. There exists an isogeny
φ : E1 → E2 and ˆφ is the dual of φ, where E2 is an elliptic curve over Fqk .
Choose P ∈ E1(Fq)[n] and Q ∈ E2(Fqk ). We have e(P, φ(Q)) = e( ˆφ(P ), Q).

Notice that Ψd is an isogeny of degree 1. If we denote the dual of Ψd by ˆΨd,
then ˆΨd ◦ Ψd = [1], i.e., Ψ −1
d = ˆΨd. By Deﬁnition 1, choose P ∈ E(Fq)[r] and
Q′ ∈ E′(Fqk/d ). We can compute pairings (Opt)AteE′ ( ˆΨd(P ), Q′) on the twisted
curve E′. And the loop length is the same as (Opt)AteE(P, Ψd(Q′)) which is
computed on the original curve E.

Furthermore, deﬁne

Φd = Ψ −1

d ◦ πq ◦ Ψd.

One can verify that Φd is a group isomorphism from E′ to E′ over Fqk [11],
which can be used in Section 4.

2.3 The Elliptic Net algorithm

An elliptic net satisﬁes some certain recurrence relation which is a map W from
a ﬁnitely generated free Abelian group A to an integral domain R. An elliptic
net of rank 1 satisﬁes the following recurrence relation:

W (α + β + δ, 0)W (α − β, 0)W (γ + δ, 0)W (γ, 0)
+ W (β + γ + δ, 0)W (β − γ, 0)W (α + δ, 0)W (α, 0)

+ W (γ + α + δ, 0)W (γ − α, 0)W (β + δ, 0)W (β, 0) = 0,

(2)

6

Shiping Cai, Zhi Hu, Zheng-An Yao, and Chang-An Zhao

where α, β, γ, δ ∈ A. Let E0 : y2 = x3 + Ax + B be a short Weierstrass curve
over Fq, where 4A3 + 27B2 6= 0. And the characteristic of Fq is not equal to 2
or 3.

Scalar Multiplication For each n ∈ Z+, we can deﬁne division polynomials
ψn ∈ Z[A, B, x, y] as follows [15].

ψ0 = 0, ψ1 = 1, ψ2 = 2y,
ψ3 = 3x4 + 6Ax2 + 12Bx − A2,
ψ4 = 4y(x6 + 5Ax4 + 20Bx3 − 5A2x2 − 4ABx − 8B2 − A3),
n+1 (n ≥ 2),

n − ψn−1ψ3

ψ2n+1ψ1 = ψn+2ψ3

ψ2nψ2 = ψn(ψn+2ψ2

n−1 − ψn−2ψ2

n+1) (n ≥ 3).

Division polynomials are elliptic nets of rank 1, i.e., W (i, 0) = ψi, ∀i ∈ Z.

They can be used to compute scalar multiplication.

Choose P = (xP , yP ) ∈ E0(Fq), and deﬁne two polynomials ζn, ωn. These

formulas can be used to compute [n]P = (xnP , ynP ) as follows.

where

[n]P =

ζn(P )
ψn(P )2 ,

ωn(P )
ψn(P )3 (cid:19)

,

(cid:18)

ζn = xP ψ2
4yP ωn = ψn+2ψ2

n − ψn+1ψn−1,
n−1 − ψn−2ψ2

n+1.

Equation (3) can be represented by elliptic nets of rank 1 [18]:

xnP = xP −

W (n − 1, 0)W (n + 1, 0)
W (n, 0)2

,

ynP =

W (n − 1, 0)2W (n + 2, 0) − W (n + 1, 0)2W (n − 2, 0)
4yP W (n, 0)3

.

(3)

(4)

Pairing Computation Elliptic nets of rank 2 is applied to pairing compu-
tation. The relationship between the Tate pairing and an elliptic net is given
below.

Theorem 3. [31] Choose P ∈ E(Fq)[r] and Q ∈ E(Fqk )[r] such that [r]P = ∞.
If WP,Q is the elliptic net associated to E, P , Q, then we have

fr,P (DQ) =

WP,Q(r + 1, 1)WP,Q(1, 0)
WP,Q(r + 1, 0)WP,Q(1, 1)

.

According to Equation (2), we obtain the explicit formulas to update the
values of an elliptic net. We can compute the Tate pairing in polynomial time
if the initial values of an elliptic net are given. For simplicity, we abbreviate

The Elliptic Net Algorithm Revisited

7

WP,Q(n, s) to W (n, s). In [31], they deﬁned a block that consists of a ﬁrst vector
of eight consecutive terms centered on term W (i, 0) and a second vector of three
consecutive terms centered on W (i, 1), where i ∈ Z.

Assume that W (1, 0) = W (0, 1) = 1. For the ﬁrst vector, all of W (n, 0) terms

can be updated by two formulas as follows.

W (2i − 1, 0) = W (i + 1, 0)W (i − 1, 0)3 − W (i − 2, 0)W (i, 0)3,

W (2i, 0) = (W (i, 0)W (i + 2, 0)W (i − 1, 0)2
−W (i, 0)W (i − 2, 0)W (i + 1, 0)2)/W (2, 0).

(5)

(6)

For the second vector, we need the following formulas to update the W (n, 1)
terms.

W (2i − 1, 1) = (W (i + 1, 1)W (i − 1, 1)W (i − 1, 0)2
−W (i, 0)W (i − 2, 0)W (i, 1)2)/W (1, 1),

W (2i, 1) = (W (i − 1, 1)W (i + 1, 1)W (i, 0)2
−W (i − 1, 0)W (i + 1, 0)W (i, 1)2),

W (2i + 1, 1) = (W (i − 1, 1)W (i + 1, 1)W (i + 1, 0)2
−W (i, 0)W (i + 2, 0)W (i, 1)2)/W (−1, 1),
W (2i + 2, 1) = (W (i + 1, 0)W (i + 3, 0)W (i, 1)2
−W (i − 1, 1)W (i + 1, 1)W (i + 2, 0)2)/W (2, −1).

(7)

(8)

(9)

(10)

For some certain conditions, W (2, 0) can be changed to 1 by the equivalence

of elliptic nets [6].

Algorithm 1 The improved Elliptic Net algorithm [7]
INPUT: Initial terms a = W (2, 0), b = W (3, 0), c = W (4, 0), d = W (2, 1), e =
W (−1, 1), f = W (2, −1), g = W (1, 1), h = W (2, 1) of the Elliptic Net algorithm
satisﬁes W (1, 0) = W (0, 1) = 1 and n = (dldl−1...d0)2 ∈ Z with dl = 1 and
di ∈ {0, 1} for 0 ≤ i ≤ l − 2
OUTPUT: W (n, 0), W (n, 1)
1: V ← [[−a, −1, 0, 1, a, b, c], [1, g, d]]
2: for i = l − 1 → 0 do
if di = 0 then
3:
4:
5:
6:
end if
7:
8: end for
9: return V [0, 3], V [1, 1]

V ← DoubleAdd(V )

V ← Double(V )

else

The IENA is shown in Algorithm 1. Generally, updating a block centered
on i to a block centered on 2i is called the Double step, and updating a block

8

Shiping Cai, Zhi Hu, Zheng-An Yao, and Chang-An Zhao

centered on i to a block centred on 2i + 1 is called the DoubleAdd step, which
is represented by Double(V ) and DoubleAdd(V ) respectively. The algorithm
to compute the process of line 2-8 in Algorithm 1 is called the Double-and-Add
algorithm. If we just need to compute scalar multiplication, then we only need to
update the ﬁrst vector by Equation (5)-(6). We do not use the IENA to compute
scalar multiplication here. There exists an inversion if we need to compute the
DoubleAdd step in the IENA. But for the scalar multiplication, the scalar n is
random and we can not ensure that n is an integer with low Hamming weight.
Notice that 4 multiplications can be saved at each iteration in the Double-and-
Add algorithm if gcd(p − 1, 3) = 1 [6]. In this work, we will improve the Double-
and-Add algorithm for scalar multiplication in two situations in [32].

Note that twists of elliptic curves have been applied for accelerating Miller’s
algorithm successfully. The situation of operations entirely on the twisted curve
E′
0 was proposed [9]. Their derivation of the Ate pairing entirely on the twisted
curve heavily relies on the process of Miller’s algorithm. Pairings entirely on the
twisted curve can also be computed by the Elliptic Net algorithm, but it still
needs to be veriﬁed.

3 Elimination of the Inverse Operation

In the IENA, an inverse operation is always involved at addition step. We will
show how to eliminate this inverse operation in this section, i.e., replace the
inversion by few multiplications.

When a block centered on i is updated to a block centered on 2i + 1, the

value W (2i + 4, 0) satisﬁes the following recursive formula:

W (2i+4, 0) =

W (2i + 3, 0)W (2i + 1, 0)W (2, 0)2 − W (3, 0)W (1, 0)W (2i + 2, 0)2
W (2i, 0)

.

(11)
From Equation (11), we need to compute the inverse element of W (2i, 0). To
eliminate this inverse operation, we multiply W (λ, 0)2i−3≤λ≤2i+4 by W (2i, 0)
simultaneously when the bit is equal to 1. We have the following theorem to
support this approach.

Theorem 4. Let W (λ, 0)i−3≤λ≤i+3, W (λ, 1)i−1≤λ≤i+1 ∈ Fqk be the current
state of an elliptic net.
1. For α ∈ F∗

qk , if W (λ, 0)i−3≤λ≤i+3 are multiplied by α, i.e.,

ˆW (λ, 0)i−3≤λ≤i+3 = α · W (λ, 0)i−3≤λ≤i+3,

then in the next state

ˆW (λ, 0)2i−3≤λ≤2i+3 = α4 · W (λ, 0)2i−3≤λ≤2i+3,
ˆW (λ, 1)2i−1≤λ≤2i+1 = α2 · W (λ, 1)2i−1≤λ≤2i+1.

Furthermore, if α 6= 0 is chosen to be in a proper subﬁeld of Fqk , then the
value of the reduced Tate pairing or its variants can not be changed.

The Elliptic Net Algorithm Revisited

9

2. For α ∈ F∗

qk , if W (λ, 0)i−3≤λ≤i+3 and W (λ, 1)i−1≤λ≤i+1 are multiplied by
α , then in the next state all the terms of this elliptic net will be multiplied
by α4, and the value of the reduced Tate pairing or its variants can not be
changed.

Proof. Let us consider ˆW (2i − 1, 0) ﬁrst.

Note that the recursive formula for W (2i − 1, 0) is

W(2i−1, 0) = W(i+1, 0)W(i−1, 0)3−W(i−2, 0)W(i, 0)3.

(12)

We multiply W (λ, 0)i−3≤λ≤i+3 by α, then the new updated ˆW (2i − 1, 0) should
be

ˆW(2i−1, 0) = α4(W(i+1, 0)W(i−1, 0)3−W(i−2, 0)W(i, 0)3)

(13)

= α4 · W (2i − 1, 0).

Similarly, we can show that the new updated ˆW (2i, 0) = α4 · W (2i, 0). This

ﬁnishes the proof for the ﬁrst assertion.

Then we consider the second vector. Note that there are only two values
of the ﬁrst vector involved for computing each W (λ, 1)2i−1≤λ≤2i+2. The new
updated ˆW (λ, 1)2i−1≤λ≤2i+2 will be multiplied by α2.

Therefore, the value of the new pairing is equal to the product of the original
pairing value and a ﬁxed power of α. However, if the constant α is chosen to be
in a proper subﬁeld of Fqk , then the ﬁnal exponentiation will eliminate the value
of the ﬁxed power of the constant α. So the value of the reduced Tate pairing
or its variants can not be changed even if all the values of W (λ, 0)i−3≤λ≤i+3 in
the state are multiplied by a non-zero ﬁxed value α.

Now we prove the second part of this theorem. In Theorem 3, we know that

fr,P (DQ) =

WP,Q(r + 1, 1)WP,Q(1, 0)
WP,Q(r + 1, 0)WP,Q(1, 1)

.

If we multiply W (λ, 0)i−3≤λ≤i+3 and W (λ, 1)i−1≤λ≤i+1 by α, where α is any

non-zero value, then we have:

fr,P (DQ) =

=

αℓWP,Q(r + 1, 1)WP,Q(1, 0)
αℓWP,Q(r + 1, 0)WP,Q(1, 1)
WP,Q(r + 1, 1)WP,Q(1, 0)
WP,Q(r + 1, 0)WP,Q(1, 1)

for some integer ℓ. This means that if we multiply all values in the updating
block by a ﬁxed non-zero value, the ratio of WP,Q(r+1,1)
WP,Q(r+1,0) can not be changed. ⊓⊔

Remark 1. We just consider the situation at the Double step. At the the Dou-
bleAdd step, the conclusion can be veriﬁed similarly.

Remark 2. Theorem 4 can also be applied for any pairing-friendly curves while
we may have to multiply both dimension of vectors. In this situation, we cost 8
multiplications and the result can not be changed.

10

Shiping Cai, Zhi Hu, Zheng-An Yao, and Chang-An Zhao

Until now, we have shown how to replace the inverse operation by several
multiplications. For some popular pairing-friendly curves, we have a friendly
situation. Take the BLS12 curve we used in this work as an example, then there
is a proposition which is helpful to our algorithm. The related parameters of the
BLS12 curve can be seen in Section 6.1 and the towering scheme is shown as
follows.

– Fq2 = Fq[u]/hu2 − βi, where β = −1;
– Fq6 = Fq2[v]/hv3 − ξi, where ξ = u + 1;
– Fq12 = Fq6 [ω]/hω2 − vi.

Proposition 1. Choose P ∈ E0(Fq) and Q′ = (xQ, yQ) ∈ E′

0(Fq2 ).

For WΨ6(Q′),P (s, 0)(s ∈ Z) , if s is odd, then WΨ6(Q′),P (s, 0) is in the proper
subﬁeld of Fq12 ; If s is even, then WΨ6(Q′),P (s, 0) belongs to Fq12 . Furthermore,
let WΨ6(Q′),P (s, 0) = a0 + a1ω, a0, a1 ∈ Fq6 , a0 = 0 if s is even.

Proof. We abbreviate WΨ6(Q′),P (s, 0) to WΨ6(Q′)(s, 0).

Note that WΨ6(Q′)(s, 0) = ψs ∈ Z[x, y, A, B], where ψs is a division poly-
nomial. Therefore, we just verify the proposition in two situations according to
Section 3.2 in [36]:

1. Assume that s is odd, then ψs is a polynomial in Z[x, y2, A, B]. For the short
Weierstrass curve y2 = x3 + Ax + B, y2 can be replaced by polynomials in
x. Furthermore, Q′ ∈ E′ and the x-coordinate of Ψ6(Q′) is xQv ∈ Fq6 .
Therefore, WΨ6(Q′)(s, 0) is always in a proper subﬁeld of Fq12 .

2. If s is even, then ψs is a polynomial in 2yZ[x, y2, A, B]. And the y-coordinate
of Ψ6(Q′) is yQvω ∈ Fq12 , so ψs ∈ 2yZ[x, y2, A, B] can be written as a1ω,
where a1 ∈ Fq6 .

⊓⊔

From Proposition 1, if W (λ, 0)i−3≤λ≤i+3 are multiplied by α = a1ω, where
a1 ∈ Fq6 , then both α2 and α4 will always be in Fq6 . From Theorem 4, in the
next state the value of WΨ6(Q′),P (2s, 0) or WΨ6(Q′),P (2s + 1, 0) will be multiplied
by α4. And WΨ6(Q′),P (2s, 1) or WΨ6(Q′),P (2s + 1, 1) will be multiplied by α2.
Therefore, if the last iteration is the doubling step, then the value of the reduced
Tate pairing or its variants can not be changed.

Moreover, the last iteration of the Miller loop on the BLS12 curve will always
invoke the doubling step. Hence, we can avoid the inversion in the IENA. This
means that we can use 5 multiplications to eliminate 1 inversion. Therefore, the
eﬀect of our method always works well when the cost of 1 inverse operation is
more than that of 5 multiplications.

For the situation of scalar multiplication algorithm based on elliptic nets, we

have the following corollary.

Corollary 5 Choose P = (xP , yP ) ∈ E0(Fq). Let W (λ, 0)i−3≤λ≤i+4 ∈ Fq be
the current state of an elliptic net which is associate to E0, P . For α ∈ F∗
q, if
W (λ, 0)i−3≤λ≤i+4 are multiplied by α, i.e., ˆW (λ, 0)i−3≤λ≤i+4 = α·W (λ, 0)i−3≤λ≤i+4.
Then the value of the scalar multiplication [n]P = (xnP , ynP )(n ∈ Z+) can not
be changed.

The Elliptic Net Algorithm Revisited

11

Proof. From Theorem 4, we know that in the next state each W (λ, 0) will be
multiplied by α4. According to Equation (4), we have the following formulae for
some integer l:

xnP = xP −

α2lW (n − 1)W (n + 1)
α2lW (n)2

,

= xP −

W (n − 1)W (n + 1)
W (n)2

,

ynP =

α3l(W (n − 1)2W (n + 2) − W (n + 1)2W (n − 2))
α3l4yP W (n)3

,

=

W (n − 1)2W (n + 2) − W (n + 1)2W (n − 2)
4yP W (n)3

.

⊓⊔

Besides, we can have a further improvement based on the algorithm in [32].
Their Double-and-Add algorithm is improved by using some tricks to save 2
multiplications at each iteration, but it involves 6 right-shift operations. We can
replace these operations by 2 left-shift operations.

4 The Elliptic Net Algorithm on the Twisted Curve

The application of the twisted curve brings some signiﬁcant improvements in
Miller’s algorithm. However, if we use the twist trick on the original curve with
the Elliptic Net algorithm, then it will not be as portable and intuitive as Miller’s
algorithm. In 2010, Costello et al. [9] proposed the Ate pairing entirely on the
twisted curve for Miller’s algorithm. Actually, when we use the Elliptic Net
algorithm to compute pairings, it will also have a good improvement if the related
parameters all on the twisted curve. In this section, we will analyze the Ate
pairing and the Optimal Ate pairing on the twisted curve with our method and
apply our work to the Elliptic Net algorithm.

4.1 The Ate Pairing on the Twisted Curve

Let E be an elliptic curve over Fq, and the related parameters are deﬁned in
Section 2.1. Let E′/Fqe be the twist of E of degree d with e = k/d. Let π′
qe be
the qe-power Frobenius map on E′. There exists an isomorphism Ψd : E′ → E
over Fqk , then we can deﬁne two groups

G′
1

, E′[r]

\

Ker(π′

qe − [1]), G′

2

, E′[r]

\

Ker(π′

qe − [qe]).

Actually, the iterations of the Miller loop T can be set as (t − 1) mod r [21].
When we compute the Ate pairing, the operations are all on the original curve.
In the following part, we will give a new derivation of the theorem about pairings
entirely on the twisted curve.

12

Shiping Cai, Zhi Hu, Zheng-An Yao, and Chang-An Zhao

d (P ) ∈ G′

2, Q′ ∈ G′

1, we can deﬁne a pairing on G′

1 × G′
2

Theorem 6. For Ψ −1
if r ∤ (T k − 1)/r:
AteE′ : G′

2 → µr

1 × G′
d (P )) = (fT,Q′ (Ψ −1
d (P )) 7→ AteE′ (Q′, Ψ −1
Proof. We only need to prove that fT,Ψd(Q′) = fT,Q′ ◦ Ψ −1

(Q′, Ψ −1

d (P )))qk −1/r.
d , for all Q′ ∈ G′
1.

The divisor of fT,Ψd(Q′) is

Div(fT,Ψd(Q′)) = T (Ψd(Q′)) − ([T ]Ψd(Q′)) − (T − 1)(∞),

and since Ψd is an isomorphism,
(Ψd)∗Div(fT,Ψd(Q′)) = T (Ψd)∗(Ψd(Q′)) − (Ψd)∗([T ]Ψd(Q′)) − (T − 1)(Ψd)∗(∞),

= T (Q′) − ([T ]Q′) − (T − 1)(∞),
= (fT,Q′ ).

Furthermore, we have (Ψd)∗Div(fT,Ψd(Q′)) = Div(fT,Ψd(Q′) ◦ Ψd), then we have
fT,Ψd(Q′) ◦ Ψd = fT,Q′ . We compose the formula with Ψ −1
on both sides, and
obtain:

d

fT,Ψd(Q′)(P ) = fT,Q′ ◦ Ψ −1

d (P ).

⊓⊔

Remark 3. When we compute pairings on the twisted curves, the operations are
always in the ﬁeld where Q′ is located. The ﬁnal value we need can be obtained
by twists. The transformation involved here is very small for Miller’s algorithm.
This is because each transformation only needs to be multiplied by a ﬁxed value
α on Fqk . Generally, α is sparse. But for the Elliptic Net algorithm, if we adopt
the same idea to use this isomorphism, then the value of α will be changed as the
iterations, which means that the transformation of the value we need will not
be a friendly process. Therefore, we choose to compute pairings on the twisted
curve for the Elliptic Net algorithm.

4.2 The Optimal Ate Pairing on the Twisted Curve

For the Optimal Ate pairing on the twisted curve, the situation is more compli-
cated than that of the Ate pairing while we can still derive the following theorem
easily.

Theorem 7. Let λ = mr with r ∤ m and λ =

ϕ(k)
i=0 ciqi. Deﬁne

Φd,i = Ψ −1

d ◦ [ciqi] ◦ Ψd,

P

and note that Φd,si = Ψ −1
pairing on G′
OptE′ : G′

1 × G′

1 × G′

2 → µr

2:

d

◦ [si] ◦ Ψd, where si =

ϕ(k)
j=i cjqj. There exists a

P

ϕ(k)

ϕ(k)−1

(Q′, Ψ −1

d (P )) 7−→ (

Yi=0

f qi
ci,Q′ (Ψ −1

d (P ))·

Yi=0

lΦd,si+1 ,Φd,i(Q′)
vΦd,si (Q′)

(Ψ −1

d (P )))(qk−1)/r.

The Elliptic Net Algorithm Revisited

13

Proof. From Theorem 6, we have

ϕ(k)

Div(

Yi=0

ϕ(k)

f qi
ci,Q′ ◦ Ψ −1

d ) = Div(

fci,Ψd(Q′)).

Yi=0

Let Qi , [si+1] ◦ Ψd(Q′). Consider the relation between lΦd,si+1 ,Φd,i(Q′) and
lQi,[ciqi]Ψd(Q′). From the deﬁnition of divisors,

Div(lQi,[ciqi]Ψd(Q′)) = (Qi) + ([ciqi]Ψd(Q′)) + (−Qi+1) − 3(∞).

Since Ψd is an isomorphism,

d Div(lQi,[ciqi]Ψd(Q′)) = (Ψ −1
Ψ ∗

d ◦ [ciqi] ◦ Ψd(Q′)) + (−Qi+1) − 3(∞),

d (Qi)) + (Ψ −1
= (lΦd,si+1 ,Φd,i(Q′)).

Therefore,

Similarly,

lQi,[ciqi]Ψd(Q′)(P ) = lΦd,si+1 ,Φd,i(Q′) ◦ Ψ −1

d (P ).

vQi (P ) = vΦd,i(Q′) ◦ Ψ −1

d (P ).

⊓⊔

Remark 4. For Q′ ∈ G′

1, we have πq ◦ Ψd(Q′) = [q]Ψd(Q′).
Since πq is an endomorphism and Ψd is an isomorphism over Fqk , we have

πq ◦ Ψd(Q′) = Ψd ◦ [q](Q′).

Therefore, we have

Ψ −1
d ◦ πq ◦ Ψd(Q′) = [q](Q′), i.e., Φd,1(Q′) = [q](Q′).

Thus, we know that the point in G′

1 can be mapped to a point in E[r]. This

also means that the line function on the twisted curve via this result.

Note that the ratio of the cost of inversions to the multiplications over Fqk
decreases if the size of Fqk is larger. When we compute the Ate pairing on the
twisted curve, our operations in the ﬁrst dimension vector centered on i are in
Fqe . Compared with the operations in Fqk , it is more necessary to eliminate the
inverse operation when the bit is not equal to 0. Furthermore, we can use the
NAF form to ensure that the density ρ is within the eﬀective range to accelerate
the IENA.

5 The Elliptic Net Algorithm with Lazy Reduction

Lazy reduction technique can also be applied to speed up the Elliptic Net al-
gorithm. Lazy reduction was presented formally in [20]. It can save the number
of modular reductions during the calculation. The main idea of lazy reduction

14

Shiping Cai, Zhi Hu, Zheng-An Yao, and Chang-An Zhao

is to put the required modular reductions of some multiplication operations like
aibi over Fq to the end. So these multiplication operations only need 1 modu-
lar reduction over Fq. Thus it can save the number of modular reductions during
P
the calculation. In this paper, we use Montgomery reduction [24], so the cost
of a modular reduction is equal to the cost of one multiplication. Note that
each item of aibi without modular reduction should satisfy the upper bound of
Montgomery reduction.

When we use the Elliptic Net algorithm to compute pairings, it contains lots
of multiplications like A · B ± C · D, which needs 2 modular reductions normally.
But if we use lazy reduction, we can only need one modular reduction. Obviously,
we are not concern about violating the upper bound for this situation since we
only use the lazy reduction once each time, and we set A, B, C, D ∈ Fq. The
proposed algorithms using lazy reduction are given for the initialization step
and Double-and-Add step respectively. We mainly improve the term W (3, 0)
and W (4, 0) at the initialization step. The improvement is not obvious here, so
we only give the number of modular reductions of three situations in Table 1.

Table 1. The Number of Modular Reductions at the Initialization Step

Algorithm A, B 6= 0 B = 0 A = 0
ENA [31] 10
This work 7

6
5

8
6

The explicit updating formulas at the Double-and-Add step are mentioned
in Section 2.3. The Double(V ) and DoubleAdd(V ) functions are combined with
the lazy reduction technique, and we adopt the new Double-and-Add step in [7]
which needs 10 terms in total. We present the Double-and-Add algorithm based
on the IENA in Appendix A. Assume that our terms belong to the ﬁnite ﬁeld
Fq. At step [7]-[23] we compute the Double(V ) function. We update 7 terms in
the ﬁrst vector and 3 terms in the second vector that are both centered on 2i.
In the ENA, we need 42 modular reductions in each iteration. In contrast, the
number of modular reductions decreases to 37 in the IENA. With the help of lazy
reduction, the updating process of each term can save one modular reduction, so
10 terms will save 10 modular reductions in total. The DoubleAdd(V ) function is
computed at step [25]-[43]. These steps contain 40 modular reductions originally
and the number of modular reductions decreases to 30 with lazy reduction in
each iteration. Table 2 shows the number of modular reductions of three Elliptic
Net Algorithms at the Double-and-Add step.

6

Implementation and Analysis

In this section, we implement the optimization of the Elliptic Net algorithm for
scalar multiplication and pairing computation respectively. Our algorithms are

Table 2. The Number of Modular Reductions at the Double-and-Add Step

The Elliptic Net Algorithm Revisited

15

Algorithm Double(V ) DoubleAdd(V )
ENA [31] 42
IENA [7] 37
This work 27

42
40
30

implemented by using the C programming language compiled with the GCC
compiler of which the version is 7.4.0. Our code is based on version 0.5.0 of the
RELIC toolkit [1] and we use the Intel Core i7-8550U CPU processor operating
at 1.80 GHz that runs on a 64-bit Linux. Our implementation will be divided into
two parts. One is scalar multiplication, and the other one is pairing computation.
We apply lazy reduction technique to both parts. Note that lazy reduction has
a good acceleration eﬀect in the Elliptic Net algorithm.

In the ﬁrsy part, we will use diﬀerent methods to compare the eﬃciency of
computing the Optimal Ate pairing on the twisted curve at 128-bit security level
and 192-bit security level respectively. Notice that the DoubleAdd(V ) function
is not friendly in the IENA. In general, we will choose the loop length which has
a low Hamming weight so that we can use Double(V ) function more frequently
in the whole iterations to accelerate the algorithm.

In the second part, we will show the comparison of the eﬃciency between
computing scalar multiplication in [32] and our work. Scalar multiplication al-
gorithm with division polynomials is similar to the ladder algorithm, and this
algorithm is easily coded compared to the traditional double-and-add algorithm.
It can naturally resist power attacks, but it is slower than the basic double-and-
add algorithm. Therefore, we do not compare our algorithms with the state-of-
the-art algorithm for standard elliptic curve scalar multiplication algorithm [13].
We choose the NIST P-384 curve and the NIST P-521 curve to compute scalar
multiplication respectively [16]. Notice that for the NIST P-384 curve, the prime
p satisﬁes gcd(p − 1, 3) = 1. Therefore, we can combine works in [6] with our
work to get a further improvement on this curve.

The elliptic curves we choose are the 381-bit BLS12 and 676-bit KSS18
curves. We specify some symbols here to show the amount of operations in this
section:

– Mk: the multiplication over Fqk , Sk: the square operation over Fqk ,
– M : the multiplication over Fq, S: the square operation over Fq,
– Ik: the inversion over Fqk , A: the addition operation over Fq.

6.1 Pairing Computation

In the following part, we will focus on the improvement of pairing computation
using the Elliptic Net algorithm.

16

Shiping Cai, Zhi Hu, Zheng-An Yao, and Chang-An Zhao

381-bit BLS12 Curve The concrete parameters for the 381-bit BLS12 curve
with embedding degree k = 12 are given as follows.

– t = −263 − 262 − 260 − 257 − 248 − 216;
– r = t4 − t2 + 1;
– q = (t − 1)2(t4 − t2 + 1)/3 + t;
– E0 : y2 = x3 + 4 over Fq;
– Fq2 = Fq[u]/hu2 − βi, where β = −1;
– Fq6 = Fq2[v]/hv3 − ξi, where ξ = u + 1;
– Fq12 = Fq6 [ω]/hω2 − vi;
– the twisted curve E′

0 : y2 = x3 + 4ξ over Fq2 .

Recall that P ∈ E0(Fq) and Q′ ∈ E′

0(Fqe ). We apply three techniques dis-
cussed in this work to the ENA and the IENA for computing the Optimal Ate
pairing. According to Theorem 7 in Section 3, the explicit formulas of line func-
tions on the twisted BLS12 curve can be obtained. Therefore, for the BLS12
curve, we only need to calculate

(ft,Ψ6(Q′)(P ))

q12 −1
r

or (ft,Q′ (Ψ −1

6 (P )))

q12 −1
r

.

The amount of operations for ft,Ψ6(Q′) and ft,Q′ in one iteration is 7S12 + 67
2 M12
and 6S2 + 62M2 + S12 + 3
2 M12 at the Double step in the ENA, respectively.
Note that in our implementation, 1I12 ≈ 3M12, 1I2 ≈ 13M2, 1M2 ≈ 3M and
1M12 ≈ 54M . In the IENA, we need 6S12 + 31M12 + I12 without twist when the
bit is not equal to 0. If we compute pairings on its corresponding twisted curve,
the operations can be reduced to 1S12 + 1M12 + 5S2 + 39M2 + 1I2. Without
considering the inﬂuence of delay error, it is not necessary to eliminate the
inverse operation if we do not use twists of elliptic curves here. But when the
cost of one inversion is greater than the cost of 5 multiplications, eliminating
the inverse operation can have a more obvious improvement. Moreover, since
t is a negative number, we choose to compute f−t,Q′ and use the relationship
(ft,Q′ )(q12−1)/r = (
)(q12−1)/r to revise the value. Note that in order to

1
f−t,Q′

make the IENA work well, we choose to expand −t in the NAF form to reduce
the proportion of non-zero digits. Then the non-zero digits density ρ will be
smaller than that of the previous one. Although the Elliptic Net algorithm is
much slower than Miller’s algorithm, it still counts in milliseconds. Therefore,
we cycle the program 10, 000 times and take the average value to ensure the
stability and accuracy of our program. The comparison about the eﬃciency of
diﬀerent methods is provided in Table 3.

From Table 3, we can see that this work speeds up the Elliptic Net algo-
rithm indeed and the eﬃciency of computing the Optimal Ate pairing on the
twisted curve is much quicker than that on the original elliptic curve. The twist
technology has a good performance for both algorithms. The eﬃciency has been
increased by about 80.9% without using lazy reduction in the IENA. Notice that
lazy reduction also plays a vital role in the algorithm, which further accelerates

The Elliptic Net Algorithm Revisited

17

Table 3. Eﬃciency Comparison on a 381-bit BLS12 Curve

Clock Cycle (×103) Time (ms)
Method
25,524
ENA [31]
24,599
ENA with lazy reduction
23,508
IENA [7]
22,586
IENA with lazy reduction
23,554
IENA (Eliminate Inverse)
22,722
IENA (Eliminate Inverse) with lazy reduction
4,890
ENA (Twist)
4,463
ENA (Twist) with lazy reduction
4,749
IENA(Twist)
4,325
IENA(Twist) with lazy reduction
IENA(Twist & Eliminate Inv)
4,575
IENA(Twist & Eliminate Inv) with lazy reduction 4,315
3,123
Miller’s algorithm

12.81
12.35
11.80
11.34
11.82
11.41
2.45
2.24
2.38
2.17
2.30
2.16
1.57

the algorithm. Besides, the elimination of the inversion has also been proved to
be eﬀective which is up to 3.36% faster than the IENA. Compared to the ENA,
the eﬃciency of our work on the original and twisted curves increases by around
11% and 11.8%, respectively.

676-bit KSS18 Curve Now we give the parameters of the 676-bit KSS18 curve
with embedding degree k = 18 below:

– t = −285 − 231 − 226 + 26;
– r = (t6 + 37t3 + 343)/343;
– q = (t8 + 5t7 + 7t6 + 37t5 + 188t4 + 259t3 + 343t2 + 1763t + 2401)/21;
– E0 : y2 = x3 + 2 over Fq;
– Fq3 = Fq[u]/hu3 − βi, where β = −2;
– Fq6 = Fq2[v]/hv2 − ξi, where ξ = u;
– Fq18 = Fq6 [ω]/hω3 − vi;
– the twisted curve E′

0 : y2 = x3 + 2/ξ over Fq2 .

We need to calculate

(ft,Ψ6(Q′) · f q

3,Ψ6(Q′) · l[t]Ψ6(Q′),[3q]Ψ6(Q′)(P ))

q18 −1
r

or

(ft,Q′ · f q

3,Q′ · lΨ

−1
6 ◦[t]◦Ψ6(Q′),Ψ

−1

6 ◦[3q]◦Ψ6(Q′)(Ψ −1

6 (P )))

q18 −1
r

for computing the Optimal Ate pairing on this curve. In order to make our
comparisons more obviously and steadily, we calculate the Optimal Ate pairing
1, 000 times, and take the average value as the ﬁnal result. Table 4 shows the
timings of diﬀerent methods for computing the Optimal Ate pairing.

18

Shiping Cai, Zhi Hu, Zheng-An Yao, and Chang-An Zhao

Table 4. Eﬃciency Comparison on a 676-bit KSS Curve

Clock Cycle (×103) Time (ms)
Method
136,542
ENA [31]
132,700
ENA with lazy reduction
122,629
IENA [7]
119,991
IENA with lazy reduction
122,681
IENA (Eliminate Inverse)
120,686
IENA (Eliminate Inverse) with lazy reduction
40,949
ENA (Twist)
39,440
ENA (Twist) with lazy reduction
40,676
IENA(Twist)
39,276
IENA(Twist) with lazy reduction
IENA(Twist & Eliminate Inv)
40,291
IENA(Twist & Eliminate Inv) with lazy reduction 38,904
17,149
Miller’s algorithm

68.54
66.61
61.56
60.23
61.59
60.58
20.56
19.80
20.42
19.72
20.23
19.53
8.61

On the KSS18 curve, the eﬀect of our modiﬁcation is similar to the perfor-
mance on the BLS12 curve. Just comparing the performance of the ENA on the
twisted curve and the original curve, the algorithm is 70% faster on the twisted
curve. But after eliminating the inverse operation and using lazy reduction tech-
nique, the algorithm can be about 5% faster than the IENA on the twisted
curve.

From these results, we ﬁnd that the improvement of lazy reduction on the
KSS18 curve is increased. This is mainly because the embedding degree on the
KSS18 curve is bigger than that of the BLS12 curve. Besides, we have more iter-
ations of the Miller loop on the KSS18 curve. But the amount of optimization in
a single iteration is same. In contrast to our theory, the eﬃciency of computing
the Optimal Ate pairing on the twisted curve is much higher than that on the
original curve for the Elliptic Net algorithm. In addition, we can further improve
the eﬃciency of the algorithm by eliminating the inverse operation. Notice that
Miller’s algorithm performs well in our implementation with the cost time of
1.57 ms on the 381-bit BLS12 curve. Its version in our work is the fastest one
implemented by Diego et al. in the Relic toolkit [1], and we test its eﬃciency
in our personal computer. However, compared with the previous work, the gap
between the Elliptic Net algorithm and Miller’s algorithm has been greatly short-
ened, which from the original cost of more than 9 times to the current cost of
less than 2 times.

6.2 Scalar Multiplication

Our work based on the scalar multiplication algorithm proposed in [32] is to
replace 6 right-shift operations by 2 left-shift operations in each iteration. It
seems that this improvement will not work obviously. However, after we use
the lazy reduction technique, the eﬃciency will have a good improvement. We

The Elliptic Net Algorithm Revisited

19

choose two curves which achieve 192-bit security level and 256-bit security level
respectively. The equations of these curves over Fq have the form: y2 = x3−3x+b.

NIST P-521 Curve In [32], the amount of operations is 24M + 6S + 36A and
6 right-shift operations at each iteration. Let one subtraction operation or one
double operation be equal to one addition operation. The trick in Section 3 is
applied to this algorithm, and then we replace 6 right-shift operations by 2 left-
shift operations. Table 5 provides the timings of scalar multiplication algorithm
in [32] and this work.

Table 5. Eﬃciency of Scalar Multiplication on the NIST P-521 Curve

Clock Cycle (×103) Time (ms)
Method
Algorithm [32]
5,097
Algorithm [32] with lazy reduction 4,844
4,920
This work
4,530
This work with lazy reduction

2.56
2.43
2.47
2.27

Our work facilitates an acceleration of around 11.2% over the algorithm in
[32] of scalar multiplication. However, the eﬃciency of these algorithms is slower
than that of the ENA for scalar multiplication except the prime p is large enough.

NIST P-384 Curve We focus on the situation of gcd(p−1, 3) = 1 and combine
the work in [6] and [32] to compute scalar multiplication. Let α ∈ Fq such that
α3 = W (2)−1. Then the initial values of an elliptic net are given below:

˜W (1) = 1, ˜W (2) = 1, ˜W (3) = α8 · W (3),
˜W (4) = α15 · W (4), ˜W (5) = ˜W (4) − ˜W (3)3.

We use these new initial values above to compute scalar multiplication. The
amount of operations will be reduced from 20M + 6S + 36A and 6 right-shift
operations to 18M + 6S + 36A and 2 left-shift operations in each iteration.
Table 6 reﬂects the eﬃciency of algorithm in [32] and our work for computing
scalar multiplication on the NIST P-384 curve. Results shown that we have an
improvement based on [32] with 14.96%.

7 Conclusions

In this work, we improved the Elliptic Net algorithm. Among diﬀerent versions
of the Elliptic Net algorithm, we analyzed their eﬃciency and presented higher
speed records on the computation of the Optimal Ate pairing on a 381-bit BLS12

20

Shiping Cai, Zhi Hu, Zheng-An Yao, and Chang-An Zhao

Table 6. Eﬃciency of Scalar Multiplication on the NIST P-384 Curve

Clock Cycle (×103) Time (ms)
Method
Algorithm [32]
2,329
Algorithm [32] with lazy reduction 2,208
2,234
This work
1,980
This work with lazy reduction

1.17
1.11
1.12
0.99

curve and a 676-bit KSS18 curve by using the Elliptic Net algorithm with sev-
eral tricks, respectively. We also improved the scalar multiplication algorithm
in [32] and implemented our work on a NIST P-384 curve and a NIST P-521
curve, respectively. The scalar multiplication algorithm was increased by up to
14.96% than the work in [32]. The lazy reduction technique was able to reduce
by around 27% of the required modular reductions. Moreover, the application
of twist technology helped us reduce the number of multiplications and the im-
provement was signiﬁcant. Besides, the improved Elliptic Net algorithm was also
further improved, i.e., the inverse operation can be replaced by few multiplica-
tions when the bit is equal to 1 or −1. On the 381-bit BLS12 curve, this work
improved the performance of the Optimal Ate pairing by 80% compared with
the original version on a 64-bit Linux platform. The implementation on the 676-
bit KSS18 curve had shown that this work was 71.5% faster than the previous
ones. Our results shown that the Elliptic Net algorithm can compute pairings
eﬃciently on personal computers while it was still slower than Miller’s algorithm.
In the future, we will consider the parallelization of the Elliptic Net algorithm
to get a further improvement.

References

1. Aranha, D.F., Gouvˆea, C.P.L.: RELIC is an Eﬃcient LIbrary for Cryptography.

https://github.com/relic-toolkit/relic

2. Aranha, D., Karabina, K., Longa, P., Gebotys, C., L´opez, J.: Faster explicit formu-
las for computing pairings over ordinary curves. In: Paterson, K. (ed.) Advances in
Cryptology – EUROCRYPT 2011, Lecture Notes in Computer Science, vol. 6632,
pp. 48–68. Springer Berlin Heidelberg (2011)

3. Azarderakhsh, R., Fishbein, D., Grewal, G., Hu, S., Jao, D., Longa, P., Verma, R.:
Fast software implementations of bilinear pairings. IEEE Transactions on Depend-
able and Secure Computing 14(6), 605–619 (2017)

4. Barbulescu, R., Duquesne, S.: Updating key size estimations for pairings. Journal

of Cryptology 32(1), 1–39 (2018)

5. Blake, I.F., Seroussi, G., Smart, N.P.: Advances in elliptic curve cryptography.

Cambridge University Press (2005)

6. Chen, B.L., Hu, C.Q., Zhao, C.A.: A note on scalar multiplication using division

polynomials. IET Information Security 11(4), 195–198 (2017)

7. Chen, B.L., Zhao, C.A.: An improvement of the elliptic net algorithm. IEEE Trans-

actions on Computers 65, 2903–2909 (2015)

The Elliptic Net Algorithm Revisited

21

8. Chiesa, A., Hu, Y., Maller, M., Mishra, P., Vesely, N., Ward, N.: Marlin: Prepro-
cessing zksnarks with universal and updatable srs. In: Canteaut, A., Ishai, Y. (eds.)
Advances in Cryptology – EUROCRYPT 2020. pp. 738–768. Springer International
Publishing, Cham (2020)

9. Costello, C., Lange, T., Naehrig, M.: Faster pairing computations on curves with
high-degree twists. In: International Conference on Practice & Theory in Public
Key Cryptography (2010)

10. Einsiedler, M., Everest, G., Ward, T.: Primes in elliptic divisibility sequences. LMS

Journal of Computation and Mathematics 4, 1–13 (2001)

11. Galbraith, S.D., Lin, X., Scott, M.: Endomorphisms for faster elliptic curve cryp-

tography on a large class of curves. J. Cryptology 24, 446–469 (2011)

12. Granger, R., Hess, F., Oyono, R., Theriault, N., Vercauteren, F.: Ate pairing on
hyperelliptic curves. In: Naor, M. (ed.) Advances in Cryptology - EUROCRYPT
2007, Lecture Notes in Computer Science, vol. 4515, pp. 430–447. Springer Berlin
/ Heidelberg (2007)

13. Granger, R., Scott, M.: Faster ecc over F2521−1. In: Katz, J. (ed.) Public-Key Cryp-
tography – PKC 2015. pp. 539–553. Springer Berlin Heidelberg, Berlin, Heidelberg
(2015)

14. Groth, J.: On the size of pairing-based non-interactive arguments. In: Fischlin, M.,
Coron, J.S. (eds.) Advances in Cryptology – EUROCRYPT 2016. pp. 305–326.
Springer Berlin Heidelberg, Berlin, Heidelberg (2016)

15. H. Silverman, J.: The Arithmetic of Elliptic Curves, vol. 106 (2009)
16. Hankerson, D., Menezes, A.: NIST Elliptic Curves, pp. 843–844. Springer US,

Boston, MA (2011)

17. Hess, F., Smart, N., Vercauteren, F.: The eta pairing revisited. IEEE Transactions

on Information Theory 52, 4595–4602 (2006)

18. Kanayama, N., Liu, Y., Okamoto, E., Saito, K., Teruya, T., Uchiyama, S.: Imple-
mentation of an elliptic curve scalar multiplication method using division polyno-
mials. IEICE Transactions on Fundamentals of Electronics, Communications and
Computer Sciences E97.A(1), 300–302 (2014)

19. Lee, E., Lee, H.S., Park, C.M.: Eﬃcient and generalized pairing computation on
abelian varieties. IEEE Transactions on Information Theory 55(4), 1793–1803
(2009)

20. Lim, C.H., Hwang, H.S.: Fast implementation of elliptic curve arithmetic in

GF (pn

). public key cryptography pp. 405–421 (2000)

21. Matsuda, S., Kanayama, N., Hess, F., Okamoto, E.: Optimised versions of the ate
and twisted ate pairings. In: Ima International Conference on Cryptography &
Coding (2007)

22. Miller, V., et al.: Short programs for functions on curves. Unpublished manuscript

97(101-102), 44 (1986)

23. Miller, V.S.: The weil pairing, and its eﬃcient calculation. J. Cryptology 17(4),

235–261 (2004)

24. Montgomery, P.L.: Modular multiplication without trial division. Mathematics of

Computation 44(170), 519–521 (1985)

25. Mrabet, N.E., Joye., M.: Guide to Pairing-Based Cryptography. Chapman &

HallCRC Cryptography and Network Security Series. CRC Press (01 2017)

26. Naehrig, M., Renes, J.: Dual isogenies and their application to public-key compres-
sion for isogeny-based cryptography. In: Galbraith, S.D., Moriai, S. (eds.) Advances
in Cryptology – ASIACRYPT 2019. pp. 243–272. Springer International Publish-
ing, Cham (2019)

22

Shiping Cai, Zhi Hu, Zheng-An Yao, and Chang-An Zhao

27. Ogura, N., Kanayama, N., Uchiyama, S., Okamoto, E.: Cryptographic pairings
based on elliptic nets. In: Iwata, T., Nishigaki, M. (eds.) Advances in Information
and Computer Security. pp. 65–78. Springer Berlin Heidelberg, Berlin, Heidelberg
(2011)

28. Onuki, H., Teruya, T., Kanayama, N., Uchiyama, S.: Faster Explicit Formulae for
Computing Pairings via Elliptic Nets and Their Parallel Computation (2016)
29. Scott, M., Costigan, N., Abdulwahab, W.: Implementing cryptographic pairings

on smartcards pp. 134–147 (2006)

30. Shipsey, R.: Elliptic divisibility sequences. Goldsmiths College (2000)
31. Stange, K.E.: The tate pairing via elliptic nets. In: Takagi, T., Okamoto, T.,
Okamoto, E., Okamoto, T. (eds.) Pairing-Based Cryptography - Pairing 2007, Lec-
ture Notes in Computer Science, vol. 4575, pp. 329–348. Springer Berlin Heidelberg
(2007)

32. SubramanyaRao, S., Hu, Z., Zhao, C.A.: Division polynomial-based elliptic curve
scalar multiplication revisited. IET Information Security 13(6), 614–617 (2019)
33. Tang, C., Ni, D., Xu, M., Guo, B., Qi, Y.: Implementing optimized pairings with

elliptic nets. Science China Information Sciences 57(5), 1–10 (2014)

34. Vercauteren, F.: Optimal pairings. IEEE Transactions on Information Theory

56(1), 455–461 (2009)

35. Ward, M.: Memoir on elliptic divisibility sequences. American Journal of Mathe-

matics 70(1), 31 (1948)

36. Washington, L.C.: Elliptic Curves Number Theory and Cryptography. Elsevier

Science Publishers B. V. (2008)

37. Zhao, C.A., Zhang, F.G., Huang, J.W.: All pairings are in a group. IEICE Trans-

actions 91-A(10), 3084–3087 (2008)

38. Zhao, C.A., Zhang, F.G., Huang, J.W.: A note on the ate pairing. Int. J. Inf. Sec

7(6), 379–382 (2008)

The Elliptic Net Algorithm Revisited

23

A Algorithm in This Work

Algorithm 2 Double-and-Add Algorithm with Lazy Reduction (Eliminate
Inversion)

INPUT: Block V centered on i in which the ﬁrst vector has 7 terms and
the second vector has 3 terms. W (1, 0) = W (0, 1) = 1, α = W (2, 0)−1,
β = W (−1, 1)−1, γ1 = W (2, −1)−1, δ = W (1, 1)−1, ω2 = W (2, 0)2, ω13 =
W (1, 0)W (3, 0), f lag ∈ {0, 1} .

for j = 1 → 3 do

S[i] ← V [1, i + 1]2 mod p, P [i] ← (V [1, i] ∗ V [1, i + 2]) mod p;

t0 ← S[j] ∗ P [j + 1], t1 ← S[j + 1] ∗ P [j], V [1, 2j − 1] ← (t0 − t1) mod p;
t0 ← S[j] ∗ P [j + 2], t1 ← S[j + 2] ∗ P [j], V [1, 2j] ← (t0 − t1) mod p;
V [1, 2j] ← (V [1, 2j] ∗ α) mod p;

end for
t0 ← S[4] ∗ P [5], t1 ← S[5] ∗ P [4], V [1, 7] ← (t0 − t1) mod p;
k0 ← S[2] ∗ P0, k1 ← P [2] ∗ S0, V [2, 1] ← (k0 − k1) mod p;
V [2, 1] ← (V [2, 1] ∗ δ) mod p;
k0 ← S[3] ∗ P0, k1 ← P [3] ∗ S0, V [2, 2] ← (k0 − k1) mod p;
k0 ← S[4] ∗ P0, k1 ← P [4] ∗ S0, V [2, 3] ← (k0 − k1) mod p;
V [2, 3] ← (V [2, 3] ∗ β) mod p;

OUTPUT: Block centered on 2i if f lag = 0, centered on 2i + 1 if f lag = 1.
1: S0 ← V [2, 2]2 mod p, P0 ← (V [2, 1] ∗ V [2, 3]) mod p; //1Sk + 1Mk
2: for i = 1 → 5 do
3:
4: end for
5: if f lag = 0 then
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17: else
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32:
33: end if
34: return V

end for
k0 ← S[3] ∗ P0, k1 ← P [3] ∗ S0, V [2, 1] ← (k0 − k1) mod p;
k0 ← S[4] ∗ P0, k1 ← P [4] ∗ S0, V [2, 2] ← (k0 − k1) mod p;
V [2, 2] ← (V [2, 2] ∗ β) mod p;
k0 ← S[5] ∗ P0, k1 ← P [5] ∗ S0, V [2, 3] ← (k0 − k1) mod p;
V [2, 3] ← (V [2, 3] ∗ γ1) mod p.

end for
vt1 ← (V [1, 4] ∗ V [1, 6]) mod p, vt2 ← (V [1, 5]2) mod p; //1Me + 1Se
t0 ← vt1 ∗ ω2, t1 ← vt2 ∗ ω13, V [1, 7] ← (t0 − t1) mod p; //2Me
for j = 1 → 6 do

t0 ← S[j] ∗ P [j + 2], t1 ← S[j + 2] ∗ P [j], V [1, 2j − 1] ← (t0 − t1) mod p;
V [1, 2j − 1] ← (V [1, 2j − 1] ∗ α) mod p;
t0 ← S[j +1]∗P [j +2], t1 ← S[j +2]∗P [j +1], V [1, 2j] ← (t0 −t1) mod p;

V [1, j] = (V [1, j] ∗ V [1, 3]) mod p;

for j = 1 → 3 do

