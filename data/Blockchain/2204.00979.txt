Breaking Blockchain’s Communication
Barrier with Coded Computation

Canran Wang and Netanel Raviv
Department of Computer Science and Engineering, Washington University in St. Louis, St. Louis, MO 63103.

2
2
0
2

r
p
A
3

]

C
D
.
s
c
[

1
v
9
7
9
0
0
.
4
0
2
2
:
v
i
X
r
a

Abstract

Although blockchain, the supporting technology of various cryptocurrencies, has offered a potentially effective framework
for numerous decentralized trust management systems, its performance is still sub-optimal in real-world networks. With limited
bandwidth, the communication complexity for nodes to process a block scales with the growing network size and hence becomes
the limiting factor of blockchain’s performance.

In this paper, we suggest a re-design of existing blockchain systems, which addresses the issue of the communication burden.
First, by employing techniques from Coded Computation, our scheme guarantees correct veriﬁcation of transactions while reducing
the bit complexity dramatically such that it grows logarithmically with the number of nodes. Second, with the adoption of
techniques from Information Dispersal and State Machine Replication, the system is resilient to Byzantine faults and achieves
linear message complexity. Third, we propose a novel 2-dimensional sharding strategy, which inherently supports cross-shard
transactions, alleviating the need for complicated communication protocols between shards, while keeping the computation and
storage beneﬁts of sharding.

I. INTRODUCTION

Blockchain is an append-only decentralized system, in which data resides in a chain of blocks that are periodically proposed
and agreed upon by a consensus mechanism. Although it is a promising platform for various applications, its performance is
sub-optimal due to the limited bandwidth and the scaling communication complexity, in terms of message complexity and bit
complexity. Message complexity is measured by the number of transferred messages, and bit complexity is characterized by
the number of communicated bits.

The performance of Bitcoin [2], the ﬁrst double-spending-resistent cryptocurrency in a public peer-to-peer network, is
inherently limited by its design. For a valid new block to be generated, the competing nodes invest the majority of time
in solving Proof-of-Work (PoW) puzzles. Consensus is reached on the sole block proposed by the winner, which is then
propagated to the remaining nodes and appended to each local chain. Such a concatenated consensus-then-propagation scheme
fails to fully utilize the bandwidth of nodes, since the network remains idle during the PoW puzzle solving period.

Meanwhile, the security of Bitcoin is guaranteed by the fact that the time interval between blocks is sufﬁciently greater than
the block transmission time [3]. Otherwise, frequent forks, which occur when multiple blocks are proposed simultaneously
cause temporary inconsistency between nodes, and jeopardize the safety of the system. In other words, the PoW puzzle should
take a sufﬁciently long period of time to solve, compared with the required time for the majority of node to receive a block.
Together, na¨ıve reparameterization such as reducing the difﬁculty of the PoW puzzle or enlarging the block size degrades
security, and a comprehensive redesign is required to improve Bitcoin’s performance.

A widely adopted paradigm to achieve high-performance blockchain systems is to parallelize consensus and propagation,
and hence to maximize the efﬁciency of bandwidth usage [4, 5, 6, 46]. Works following this path inherit the PoW mechanism
to periodically select an entity from the public network as a leader, which could be a node or a committee of nodes. The
selected entity is allowed to continuously generate blocks in parallel with the leader election mechanism, until the next entity
is selected. Compared with Bitcoin, this paradigm persistently utilizes the bandwidth of nodes, and hence improves system
performance.

In another direction, researchers attempt to improve Bitcoin by replacing its PoW mechanism, which is seen as the root
cause of the scalability issue and huge energy consumption. Proof-of-Stake (PoS) is a noteworthy alternative used by [7, 8, 9],
which does not involve the computation-intensive PoW puzzle solving. Instead, the chance for each individual node being
selected as the leader, or one of the leaders, is proportional to its stake, referring to the value resides in the blockchain system.
Although the aforementioned attempts improve the performance of blockchain to some extent, a fundamental obstacle
remains. That is, every node must receive every transaction. This requirement is paramount to the safety and decentralization
of blockchain systems, but unfortunately leads to an inevitable Ω(N P ) bit complexity for a block B containing P transactions
to be conﬁrmed, given a network of N nodes.

Sharding [23] is a novel paradigm proposed to address this problem. The network is sliced into multiple communities
of a similar sizes, each individually processes a disjoint set of data [24, 25, 26]. The constant community size reduces the
communication complexity as one transaction is only propagated within one community. As a result, the system throughput
scales with the number of nodes, as additional nodes form extra communities and process additional transactions.

Parts of this paper have previously appeared in [1].

1

 
 
 
 
 
 
In sharding-based blockchain designs, random node rotation, or even reassignment, is necessary to avoid concentration
of adversaries in one community. Further, sharding creates a distinction between two types of transactions; a transaction is
called intra-shard if the sender and the receiver belong to the same community, and called cross-shard otherwise. Hence, extra
mechanisms are required in this path, which is an added complexity that degrades the system’s performance and diminishes
the beneﬁts of sharding.

Coding has been introduced to bypass the requirement for every node to receive every transaction, which leads to the invention
of coded blockchain. Duan et al. propose BEAT3 [27], a BFT storage system that enables each node to periodically store a
relatively small coded fragment generated from the whole data block. The error-correcting code guarantees reconstruction of
the original data block from sufﬁciently many of fragments. The AVID-FP [32] protocol is used to assure that fragments stored
by correct nodes correspond to a unique original data block. However, as a BFT storage system, BEAT3 does not concern
external validity, which assures that the stored data is acceptable to a speciﬁc application [28]. In Blockchain’s scenario, nodes
in BEAT3 cannot verify the correctness of each stored transaction.

The introduction of coded computation partially alleviates the security problems in sharding, and provides support for external
validity. Li et al.
[29] proposed Polyshard, which offers a novel separation between nodes and shards. Polyshard formulates
the veriﬁcation of transactions as computation tasks, one for each shard, to be solved across all nodes in a distributed manner.
Using Lagrange Coded Computing (LCC) [30], nodes individually compute a polynomial veriﬁcation function over a coded
chain and a coded block. Since veriﬁcation is performed in a coded fashion, and a node does not verify or store transactions
for any speciﬁc shard, the need for node rotation/reassignment is removed.

Polyshard implicitly assumes that the performance bottleneck stems from insufﬁcient computation resources in nodes, rather
than limited communication bandwidth, and considers the system as a computation cluster with a highly synchronous network.
The bit complexity, however, is again O(N P ), as Polyshard requires every node to ﬁrstly reach a consensus of the whole
block B and then perform encoding individually. Otherwise, as pointed out in [11], the system can be broken by a discrepancy
attack. Besides, the messages complexity is O(N 2), due to the fact that Polyshard involves an all-to-all communication
operation.

Finally, coding has been employed in blockchain system that allows light nodes. Unlike full nodes that validate and store
all transactions, light nodes only download the header of each block, and hence addressing the O(N P ) bit complexity. The
header contains the root of a Merkle tree whose transactions are the leaves; it allows light nodes to verify the inclusion of any
transaction in the corresponding block by downloading a Merkle proof from full nodes. However, the data availability problem
arises, i.e., upon receiving a header and Merkle proof, a light node cannot assure the corresponding block is fully available to
the network, while the undisclosed part of the block may be invalid. A coding-based solution to data availability problem has
bee proposed by [47] and further improved by [48]. In this paper, we only consider full nodes, and leave the incorporation of
light nodes for future work.

Our Contributions

In this paper, we propose a fundamental re-design for coded blockchain, which resolves many of the issues in contemporary
coded blockchain systems. In particular, this re-design addresses the issue that every node should receive every transaction,
and hereby resolves the presumably inevitable Ω(N P ) bit complexity, that is also prevalent in ordinary (that is, uncoded)
blockchain systems. Further, it achieves linear message complexity by resolving the issue of all-to-all communication, which
is message-heavy but necessary for decoding the results of the computation. On top of this gain, we adopt Lagrange coded
computing—similar to existing designs—to achieve comparable levels of decentralization and security guarantees with respect
to uncoded (i.e., ordinary) blockchain. In detail,

1) By employing techniques from Lagrange Coded Computing [30], our scheme allows nodes to perform veriﬁcation
on coded transactions, whose size is a fraction of the entire block. Our method incurs O(P log2 M log N ) bit complexity
to process a block with P transactions, where M is the total number of transactions in one shard. As an alternative
interpretation, the average bit complexity to process a block is O(log2 M log N ).

2) By devising techniques inspired by Information Dispersal and BFT SMR protocols, our design allows a leader node
to securely distribute coded transactions, under the presence of a certain fraction of Byzantine nodes, with O(N )
message complexity in the partial synchrony model. In the suggested parameter regime and under standard cryptographic
assumptions, our design is provably secure to any attack that aims at breaking the consistency of the system, and in
particular the attack pointed out by [11].

3) We propose 2-Dimensional Sharding, a new technique which partitions the transactions based on their senders and
receivers, respectively. This design provides inherent support for cross-shard transactions, alleviating the need for com-
plicated communication mechanisms. More precisely, in our design there is no difference between the veriﬁcation process
of cross- and intra-shard transactions.

4) Our design inherits the unspent transaction output (UTXO) model and formulates the veriﬁcation process as computing
a polynomial function with a degree that scales logarithmically with the number of transactions on a shard. In detail,
our scheme addresses the degree problem by replacing current cryptographic primitives (i.e, ECDSA, SHA256 and
RIPEMD-160) by multivariate cryptography in the generation and veriﬁcation of a transaction.

2

These contributions bring coded blockchain closer to feasibility. That is, our scheme achieves linear message complexity and
logarithmic bit complexity and removes the boundary between shards with inherent support for cross-shard transactions. The
rest of this paper is organized as follows. Section II introduces necessary background. Section III details the coded veriﬁcation
scheme. Section IV discusses the communication aspect of our design, including the propagation of transactions and the
exchange of computation results. Section V analyzes the security, communication complexity, and the tradeoff between them.
Section VI discusses the future research directions.

A. Lagrange Coded Computing

II. BACKGROUND

Coded computing broadly refers to a family of coding-inspired solutions for straggler- and adversary-resilient distributed com-
putation. Tasks of interest include matrix-vector multiplication [51], matrix-matrix multiplication [52], gradient-computations [53,
54], and more. Further works on the topic include exploitation of partial stragglers [55], heterogeneous networks [57], and
timely coded computing [56].

Lagrange Coded Computing [30] (LCC) is a recent development in the ﬁeld of coded computation. The task of interest is
computing a multivariate polynomial f (X) on each of the K datasets {X1, . . . , XK}. LCC employs the Lagrange polynomial
to linearly combine the K datasets with T redundant datasets {Z1, . . . , ZT } chosen uniformly at random, generating N distinct
coded dataset {

XN } with injected computational redundancy.

X1, . . . ,

The encoding of LCC is performed by ﬁrst choosing mutually disjoint sets {α1, . . . , αN } and {ω1, . . . , ωK, . . . , ωK+T }

with elements in Fq. The generator matrix GL is then deﬁned as

e

e

GL = 

where Φk(z) is the Lagrange polynomial




Φ1(α1)
...

Φ1(α2)
...

ΦK+T (α1) ΦK+T (α2)

Φ1(αN )
...

. . .
. . .
. . . ΦK+T (αN )






Φk(z) =

Yj,k∈[K+T ],j6=k

z − ωj
ωk − ωj

.

,

(1)

(2)

X1, . . . ,

and returns a coded result f (

The coded datasets is generated as (

XN ) = (X1, . . . , XK, Z1, . . . , ZT ) · GL. Every worker node i ∈ [N ] computes
Xi). The leader obtains f (X1), . . . , f (XK) by performing decoding on collected coded results.
LCC achieves the optimal tradeoff between resiliency, security and privacy. It tolerates up to S stragglers and A adversarial
nodes, deﬁned as working nodes that are unresponsive or return erroneous results, respectively. In addition, with proper
incorporation of random keys, it also prevents the exposure of the original datasets to sets of at most T colluding workers, as
long as

e

e

e

(K + T − 1) deg f + S + 2A + 1 ≤ N.

B. State Machine Replication

The state machine replication (SMR) approach [12, 13] formulates a service, e.g., a network ﬁle system, as a state machine
to be replicated in participating nodes. The state can be altered by client-issued service requests. To ensure the consistency of
the states, nodes must agree on a total order of execution for requests.

An SMR implementation must guarantee safety and liveness. Safety suggests that no two nodes conﬁrm different order of
requests, and liveness imposes that the system continuously accepts and executes new requests. Further, an SMR protocol is
said to be Byzantine Fault-Tolerant (BFT) if it is resilient to Byzantine faults, as coined by Lamport et al. [10], which are
deﬁned as arbitrary (and possibly malicious) behaviour of nodes.

Network models plays an important role in the design of SMR protocols. In an asynchronous systems, message can be
delayed by any ﬁnite amount of time, but eventual delivery is guaranteed. BFT SMR protocols which operate in this model
employ randomization to bypass the famous FLP impossibility [50]. This impossibility result states that in the presence of
even one faulty node (not necessarily Byzantine), it is impossible to guarantee consensus with a deterministic protocol. Works
following this path include [21, 22, 27].

As proposed by Dwork et al. [49], partial synchrony is another noteworthy network model. In this setting, message delivery
is asynchronous until an unknown Global Stabilization Time (GST). After GST, the system becomes synchronous, where
message delay is bounded by a known constant ∆. PBFT [15] is the ﬁrst practical implementation of BFT SMR in the the
partial synchrony model. It guarantees safety always, and provides liveness when the system becomes synchronous.

PBFT employs a leader to propose client-issued requests, and it takes two phases of all-to-all communication for the decision
on one request. To prohibit Byzantine leaders from proposing different requests to different nodes, a proposal is considered
valid only after being signed by a quorum of N −f nodes in the ﬁrst phase, known as a quorum certiﬁcate (QC), where f is the

3

number of Byzantine nodes. Next, nodes commit the request after receiving another N −f votes in the second phase. A quorum
contains enough nodes such that any two quorums must intersect on at least one correct node [14]. Such a property guarantees
that correct nodes entering the second phase are consistent on the same request. In addition, it assures that the proposals from
subsequent leaders (should the previous one crash) are consistent in request and hence maintains safety during leader switches.
This celebrated two-phase paradigm serves as the foundation of future leader-based BFT SMR protocols [16, 17, 18, 19].

Bitcoin coined the word blockchain, providing an alternative implementation of SMR, particularly for value transfer systems
in large networks. It maintains an ordered sequence (chain) of blocks (requests), each contains transactions that incur value
(bitcoins) transfers between clients. Nodes invest computation power into PoW puzzle solving for the right to propose the next
block; they are incentived by a reward in values. In particular, nodes look for a new block by trial and error. The new block
must extends the current chain (i.e., contains a hash pointer to the last block on the chain), and the hash value of which must
satisfy a certain rule (e.g., begin with a sequence zeros). The winner of the competition disseminates its block to the network
by gossip protocol, which is then appended to each local chain. Unlike the protocol discussed earlier, the safety of Bitcoin
relies on synchrony. Further, the ﬁnality property (i.e., a consensus once reached cannot be reverted) of Bitcoin is probabilistic.
In practice, a block is considered irrevertible after being followed by six new blocks. Numerous blockchain designs have been
introduced to improve Bitcoin (see Section I).

HotStuff [20] bridges PBFT-like protocols and Bitcoin-like protocols. It extends the two-phase paradigm of PBFT to three
phases, each contains a nearly identical communication operation between the leader and the nodes. Due to this remarkable
simplicity, HotStuff can be easily pipelined; i.e., the second phase on a block functions as the ﬁrst phase on the following
block, as well as the last phase on the preceding block. Therefore, a block is irrevitible after three new blocks being appended
to it, which is similar to the case of Bitcoin. Besides, the extra phase allows HotStuff to be the ﬁrst protocol that simultaneously
achieves linear message complexity and responsiveness during leader switches. A leader switch is said to be responsive if the
new leader only has to collect a quorum of leader-switch messages, and there is no requirement for it to wait for a predeﬁned
time period.

Due to these merits, we adopt HotStuff as the core consensus protocol, and employ techniques from coded computation
and information dispersal (deﬁne next) to reduce bit complexity. Our work can be regarded as a communication-efﬁcient
implementation of coded state machine [58], which simultaneously maintains K state machines (shards) and employ coded
computation to combat Byzantine faults.

Remark 1. BFT SMR protocols focus on the communication complexity induced by reaching a consensus on the order of
the requests. It is generally assumed that each request is broadcast to every node by the issuing client, and this process is out
of the scope of communication complexity analysis. However, blockchain systems usually require the leader to collect and
distribute transactions, which must be considered in analyzing the communication complexity.

C. Information Dispersal

k ∈ Fδ×1

In a coded distributed information system, a ﬁle X ∈ FδK

1 , . . . , X ⊺
K)
where X ⊺
. A Maximum Distance Separable (MDS) error-correcting code C, induced by a generator matrix GC ∈ FK×N
,
N ) = X · GC. Each of the N nodes stores one coded fragment. The
is used to generate N coded fragments
MDS property of C codes guarantees that any K × K submatrix of GL is of full rank and hence any K coded fragments are
sufﬁcient to reconstruct X, tolerating up to N − K crashes.

to be stored is ﬁrst partitioned to K parts X = (X ⊺

1 , . . . ,

X = (

X ⊺

X ⊺

q

q

q

e

e

e

Research in this ﬁeld normally concerns a scenario where an external client wants to disperse a ﬁle X to the system. That is,
for every node i to store the corresponding coded fragment
Xi. Byzantine faults can cause inconsistency of coded fragments,
i.e., nodes might store coded fragments that do not correspond to the same ﬁle X. Efforts has been made on developing
protocols to combat Byzantine faults in this scenario.

e

AVID-FP (where FP stands for ﬁngerprinting) [32] enables a client to distribute coded fragments of some ﬁle X to nodes in
a distributed system, along with a checksum, i.e., a list of ﬁngerprints of every coded fragment. AVID-FP inherits the properties
of Cachin’s Asynchronous Veriﬁable Information Dispersal (AVID) protocol [31], with additional ﬁngerprints. The ﬁngerprints,
generated by a homomorphic ﬁngerprinting function (deﬁned formally in the sequel) preserves the structure of error-correcting
codes, and allows node i to verify that the received fragment corresponds to a unique ﬁle X. In this paper, we propose an
efﬁcient transaction propagation scheme that integrates the steps of AVID-FP and coding techniques (see Section IV).

D. The Unspent Transaction Output (UTXO) Model

In the UTXO model, value resides in transactions, instead of client accounts. A transaction has inputs and outputs. An
unspent output of an old transaction serves as an input to a new transaction, incurring a value transfer between the two. The
old UTXO is then invalidated, since it has been spent, and new UTXO is created in the new transaction.

The UTXO model makes extensive use of cryptographic hash functions and digital signatures. The uninformed reader is
referred to [2, Sec. 2] for a thorough introduction to the topic. In a nutshell, a transaction output contains the amount of stored
value and the intended receiver’s address, which is the hash value of her public key. Besides, the sender attaches his public

4

key and signs the transaction with his secret key. For a transaction to be valid, the hash value computed from the sender’s
public key must match the address in the referenced UTXO. Also, the signature must be valid when checked by the public
key. This two-step veriﬁcation process guarantees the sender’s possession of the public and secret keys, proves his identity as
the receiver of the redeemed UTXO, and protects the integrity of the new transaction.

Although a transaction may have multiple inputs and outputs, we adopt a simpliﬁed UTXO model in our scheme for clarity,

where a transaction has exactly one input and one output, and transfers one indivisible coin.

E. Cryptographic Primitives

We assume that a public key infrastructure (PKI) exists among nodes. That is, every node i can create a signature hmiσi on
a message m using its private key σi. Meanwhile, such a signature can be veriﬁed by the corresponding public key, which is
shared by all nodes. Further, we employ a threshold signature [34] scheme. A (t, n)-threshold signature scheme π contains a
single public key shared by all nodes. Every node i possess a private key πi which allows it to create a partial signature hmiπ,i
on message m. A valid threshold signature hmiπ = tcombine(m, {hmiπ,i}i∈I) can be produced using function tcombine from
a set of partial signatures {hmiπ,i}i∈I of size |I| = t, but not smaller. Hence, it is guaranteed that the message m has been
signed by t nodes if the signature veriﬁcation function tverify(m, hmiπ) returns true.

In addition, in order to formulate the veriﬁcation of transactions as the computation of polynomials, clients use a multivariate
public key cryptosystem (MPKC) [36, 37, 38] as a signature scheme. MPKC is based on the multivariate quadratic (MQ)
problem, which is believed to be hard even for quantum computers. An MQ problem involves a system of m quadratic
polynomials {p(1), . . . , p(m)} in n variables {y1, . . . , yn} over some ﬁnite ﬁeld Fq, i.e.,

p(y) =

a(i,j)yiyj +

biyi + c,

X0<i≤j<n

0<i<n
X

where a, b, and c are vectors in Fm

q . The solution is a vector u = (u1, . . . , un) ∈ Fn such that p(u) = (0, . . . , 0) ∈ Fm
q .

In general, the public key of a MPKC is the set of coefﬁcients of the quadratic polynomial system. A valid signature s ∈ Fn
q
on a message w ∈ Fm
is the solution to the quadratic system p(y) = w. In addition to MQ-based signature schemes, hash
q
functions based on multivariate polynomials of low degree have been studied [40, 41, 42]. In the remainder of this paper, we
assume a polynomial hash function over Fq of a constant degree.

III. CODED VERIFICATION

In this section, we ﬁrst introduce our general settings and assumptions. Based on these settings, we discuss the veriﬁcation
of transactions. As in the UTXO model, the veriﬁcation process starts from fetching an existing transaction stored in the
chain, and proceeds with the address check and signature veriﬁcation process. Together, the entire veriﬁcation is formulated as
computing a polynomial function. Consequently, we demonstrate the incorporation of Lagrange Coded Computing, showing
how veriﬁcation can be performed in a coded manner.

A. Setting

The system includes N nodes and K client communities of equal size. The nodes are responsible for collecting, verifying
and storing transactions; clients issue transactions and transfer coins between each other. Note that clients are afﬁliated with
communities, whereas nodes are not. Transactions are proposed by clients and veriﬁed by nodes periodically during time
intervals, called epochs, denoted by a discrete time unit t.

We formulate the block containing all transactions in epoch t as a matrix,

b1,1
...
bK,1

b1,2
...
bK,2

. . .
. . .
. . .

b1,K
...
bK,K




B(t) = 



,



(3)

where every bk,r ∈ FQ×R
receivers in community r; each transaction x ∈ FR

is a tiny block, formed as a concatenation of Q transactions with senders in community k and
q is a vector of length R over some ﬁnite ﬁeld Fq.

q

We partition the block B(t) into outgoing strips and incoming strips, as shown in Fig. 1. An outgoing strip

is a vector containing transactions with senders in community k. Similarly, an incoming strip

h(t)
k = (bk,1, . . . , bk,K) ∈ (FQ×R

q

)K

v(t)
k = (b1,k, . . . , bK,k) ∈ (FQ×R
stands for a collection of all transactions in epoch t with receivers in community k. Equivalently, one can view an outgoing
strip h(t)
k

as the k-th row of matrix B(t), and incoming strip v(t)
k

as the transpose of the k-th column of matrix B(t), i.e.,

)K

q

B(t) =

1 )⊺, (v(t)

2 )⊺, . . . , (v(t)

(v(t)
h

K )⊺)
i

1 )⊺,

(h(t)
h

=

5

(h(t)

2 )⊺,

. . . ,

(h(t)

K )⊺

⊺

.

i

Shards

Link

Link

Link

Link

v(t−1)
4

(cid:1) v(t−2)
4

(cid:1) . . . (cid:1) v(1)
4

v(t−1)
3

(cid:1) v(t−2)
3

(cid:1) . . . (cid:1) v(1)
3

v(t−1)
2

(cid:1) v(t−2)
2

(cid:1) . . . (cid:1) v(1)
2

v(t−1)
1

(cid:1) v(t−2)
1

(cid:1) . . . (cid:1) v(1)
1

V(t)
4

V(t)
3

V(t)
2

V(t)
1

Filter

h(t)
1

h(t)
2

h(t)
3

h(t)
4

b11

b12

b13

b14

b21

b22

b23

b24

b31

b32

b33

b34

b41

b42

b43

b44

v(t)
1

v(t)
2

v(t)
3

v(t)
4

Block B(t)

F(t)

F(t)

F(t)

F(t)

Veriﬁcation
Results

1 , . . . , h(t)
Fig. 1. Illustration of 2-Dimensional Sharding in a blockchain system with 4 shards. The block B(t) is horizontally sliced into outgoing strips h(t)
and vertically sliced into incoming strips v(t)
using the veriﬁcation
function F(t), for k = 1, 2, 3, 4. Together, the veriﬁcation results reveal the validity of every transaction, and help to ﬁlter out the invalid transactions in the
incoming strips, which are ﬁnally linked to the corresponding shards.

is veriﬁed against the corresponding shard V(t)
k

4 . The outgoing strip h(t)

1 , . . . , v(t)

k

4

k =

k , . . . , v(t)
v(1)

Formally, we deﬁne a shard V(t)

as a concatenation of incoming strips associated with community k
from epoch 1 to epoch t, which contains M (t) transactions. Note that our deﬁnition of a shard is slightly different from the
existing literature1. This deﬁnition provides a inherent support for cross-shard transactions, which will be elaborated in sequel.
Remark 2. A coded outgoing strip h(t)
a polynomial function that veriﬁes h(t)
k
strip v(t)
alleviating the need for sophisticated cross-shard communication mechanisms.

k . In later sections, we present
k . The results are used to ﬁlter out invalid transactions in the incoming
k before they are appended to the shard. As a result, our setting does not differentiate intra- and cross-shard transactions,

k contains transactions redeeming UTXOs from shard V(t)

against V(t)

(cid:17)

(cid:16)

k

B. Polynomial Veriﬁcation Function

is a lookup matrix used to index the previous transaction, where T (t) = log2 M (t).

In our setting, a new transaction is of the form xnew = (unew, pnew, anew, snew), where:
1) unew ∈ FT (t−1)×2
q
2) pnew ∈ FB
q is the sender’s public key, containing all coefﬁcients of an MQ system.
3) anew ∈ FC
q is the receiver’s address, i.e., the hash value of the receiver’s public key.
snew ∈ FD
q is the senders signature on x′
4)
Verifying xnew includes three crucial parts:
• Transaction Fetching: To fetch the corresponding old transaction xold = (uold, pold, aold, sold) from which xnew redeems

new = (unew, pnew, anew)

the UTXO.

• Address Checking: To check whether the hash value of pnew matches aold.
• Signature Veriﬁcation: To verify that snew is a valid signature on the hash value of x′
In detail, the above parts are executed as follows.

new by using the public key pnew.

1Sharding in blockchain broadly refers to the practice of partitioning nodes among different committees (in a possibly random fashion), each individually
handles a portion of veriﬁcation and storage [23]. On the contrary, we do not assign individual node to any speciﬁc committee, but partition clients among
communities. Meanwhile, we partition transactions based on the community of the receivers, and each partition is called a shard.

6

1) Transaction Fetching: The lookup matrix unew has exactly one 1-entry and one 0-entry in each row. Hence, every
transaction in V(t) can be uniquely indexed by a lookup matrix. The veriﬁer views shard V(t) as T (t−1)-dimensional tensor
in (F

qR)2×2×...×2, and therefore every transaction can be conveniently expressed as a tensor entry V(t)

∈ F

qR .

i1,...,iT (t−1)

To fetch a transaction, one computes a multilinear polynomial,

T (t−1)

fetch(t)(u, V(t)) =

(i1,...,iT (t−1) )∈{1,2}T (t−1)
X

V(t)

i1,...,iT (t−1)





j=1
Y

uj,ij 


which takes a shard V(t) and a lookup table u as inputs and yields the transaction xu ∈ F
of fetch(t) is T (t−1) + 1. Note that the subscript k is omitted in fetch(t) since it can be applied to any shard.

qR indexed by u. The degree

Example 1. In a shard V that contains 8 transactions, to fetch one of them, one would compute

fetch(u, V) = u1,1u2,1u3,1 V1,1,1 + u1,1u2,1u3,2 V1,1,2 + u1,1u2,2u3,1 V1,2,1 + u1,1u2,2u3,2 V1,2,2

+ u1,2u2,1u3,1 V2,1,1 + u1,2u2,1u3,2 V2,1,2 + u1,2u2,2u3,1 V2,2,1 + u1,2u2,2u3,2 V2,2,2.

Since the lookup matrix contains only one 1-entry and one 0-entry, only the entry indexed by u has coefﬁcient 1, while the
rest have coefﬁcients 0.

2) Address Checking: Based on Section II-E, we assume a multivariate polynomial hash1 : FB
q of a constant degree
q
to serve as our ﬁrst collision resistant hash function. Having obtained xold = fetch(t)(unew, V(t)
k ), the veriﬁer then checks
whether hash1(pnew) = aold holds, which is expressed as a polynomial,

(cid:1) FC

checkAddr(p, a) = hash1(p) − a.

Note that pnew is accepted when checkAddr(pnew, aold) ∈ FC
3) Signature Veriﬁcation: The veriﬁer needs to check the validity of the signature snew. She ﬁrst computes a hash digest w =
q is our second collision resistant hash function

hash2(unew, pnew, anew) = (w1, . . . , wE) ∈ FE
of a constant degree. Later, the veriﬁer checks whether M Q(pnew, snew) = w holds, where,

q , where hash2 : FA+B+C

q is the all-zero vector.

(cid:1) FE

q

M Q(p, s) =

a(i,j)sisj +

bisi + c,

and a, b, c ∈ FE
signature s in a transaction x = (u, p, a, s) can be expressed as a polynomial,

q are vectors stored in pnew, serving as coefﬁcients of the MQ problem. Equivalently, the veriﬁcation of a

X0<i≤j<D

X0<i<D

Note that snew is accepted only when checkSig(xnew) = 0.

The above three parts focus on the veriﬁcation of an individual transaction. We further employ them to verify the entire

checkSig(x) = M Q(p, s) − hash2(u, p, a).

strip as follows.

4) Veriﬁcation of a strip: Let η ∈ FC+E

be the concatenation of checkAddr(pnew, aold) and checkSig(xnew); a transaction x
is accepted if and only if η = f (t)(x, V(t)) = 0. This information is further used to ﬂiter out invalid trancations in the incoming
strip. Since the UTXOs redeemed by transactions in h(t)
k , we deﬁne a multivariate
polynomial,

k = (x1, . . . , xQK) all reside in V(t)

q

of degree d, which yields an outgoing result strip

F (t)(h(t), V(t−1)) = (f (t)(x1, V(t−1))⊺, . . . , f (t)(xQK , V(t−1))⊺),

deﬁned as the k-th row of the result matrix

e(t)
k = (rk,1, . . . , rk,K ) ∈ (FQ×(C+E)

q

)K,

(4)

r1,1
...
rK,1

r1,2
...
rK,2

. . .
. . .
. . .

r1,K
...
rK,K

R(t) = 


Each tiny result block rk,k′ contains Q entries of length C + E; one per every transaction in the tiny block bk,k′ . The j-th
and the j-th transaction in bk,k′ . Hence, the outgoing result strip e(t)
entry in rk,k′ is the result of computing f (t) on V(t)
k
k
reveals the validity of every transaction in the outgoing strip h(t)
k , and the result matrix R(t) reveals the validity of every
transaction in the block B(t). As shown in Fig. 1, the outgoing result strips are used to ﬁlter out the invalid transactions in
the incoming strips before they are being appended to the corresponding shards.

(5)






.

7

Similarly, the incoming result strip

s(t)
k = (r1,k, . . . , rK,k) ∈ (FQ×(C+E)
is a transpose of the k-th column of the result block. It reveals the validity of every transaction in the incoming strip v(t)
will employ this notation in Section III-D.

)K

q

(6)

k . We

Remark 3 (The degree of F (t)). The veriﬁcation result of a transaction is the concatenation of functions checkAddr and checkSig.
By deﬁnition, checkAddr(p, a) = hash1(p)− a, where a is the output of function fetch(t). Besides, checkSig(x) = M Q(p, s)−
hash2(u, p, a), where the degree of the multivariate function M Q(p, s) is 3. Together, the degree of polynomial that veriﬁes
a transaction is d = max(T (t−1) + 1, deg hash1, deg hash2, 3), where T (t−1) + 1 is the degree of fetch(t).

As existing works [40, 41, 42] show the existence of secure polynomial hash functions with degree as low as 3, we assume
that the degree of both hash1 and hash2 is less than T (t−1) in realistic blockchain systems (e.g., a blockchain system with 106
transactions in each shard has a veriﬁcation function of degree d = 20). Hence, the polynomial F (t) has a degree d = T (t−1)+1,
which scales logarithmically with the number of transactions in a shard.

C. Coded Computation

Now that the veriﬁcation of outgoing strips has been formulated as a low degree polynomial, we turn to describe how it is
conducted in a coded fashion. In detail, every shard k ∈ [K] is assigned a unique scalar ωk ∈ Fq, and every node i ∈ [N ] is
assigned a unique scalar αi ∈ Fq.

Setting T = 0, the generator matrix in (1) becomes

Φ1(α1) Φ1(α2)

GL = 

...

...

ΦK(α1) ΦK(α2)

. . . Φ1(αN )
. . .
. . . ΦK(αN )

...







,



(7)

where Φk(z) is the Lagrange polynomial (2). For node i, the coded outgoing strip and coded incoming strip are linear
combinations of outgoing strips and incoming strips, respectively, i.e.,

i )⊺ = ((h(t)
h(t)
(
i )⊺ = ((v(t)
v(t)
(
e

1 )⊺, . . . , (h(t)
1 )⊺, . . . , (v(t)
h(t)
i

and

v(t)
i

K )⊺) · (GL)i = (B(t))⊺ · (GL)i,
K )⊺) · (GL)i = B(t) · (GL)i,

are evaluations of Lagrange polynomials ψ(t)(z) and φ(t)(z)

where (GL)i is the i-th column of GL. Equivalently,
at αi, respectively, where

e

ψ(t)(z) =

K

h(t)
k

e
z − ωj
ωk − ωj

Yj6=k

e
and φ(t)(z) =

K

v(t)
k

Xk=1

Yj6=k

z − ωj
ωk − ωj

.

Every node i stores a coded shard

, i.e., a node-speciﬁc linear combination of all shards,

Xk=1
V(t)
i

e

K

Xk=1

e
V(t)

i =

Gk,iV(t)

k = (φ(1)(αi), . . . , φ(t)(αi)).

In epoch t, every node i receives the coded strips

h(t)
i

and

v(t)
i

are given in Section IV. Node i computes the polynomial veriﬁcation function F (t) on
obtains a coded outgoing result strip

e

e

; protocols for secure encoding and delivery of coded strips
, and

and the locally stored

Vt−1
i

h(t)
i

Formally, the coded outgoing result strip
e

an evaluation of a polynomial F, i.e.,

e

e(t)
i = F (t)(

h(t)
i

,

) = F (t)(ψ(t)(αi), (φ(1)(αi), . . . , φ(t)(αi)).

V(t−1)
i
, as well as the (uncoded) outgoing result strip e(t)
e(t)
e
i

e

e

k deﬁned in Equation (4), is

e(t)
k = F(t)(ωk) and
e

e(t)
i = F(t)(αi),

Since the degree of both ψ(t) and φ(t) is K − 1, it follows that the degree of F(t) is (K − 1)d.

where F(t)(z) = F (t)(ψ(t)(z), (φ(1)(z), . . . , φ(t)(z)).

e

Similar to the outgoing result strip deﬁned in (4), the coded outgoing result strip

e(t)
i = (

e(t)
i,1, . . . ,

e(t)
i,K) ∈ (FQ×(C+E)

q

)K

(8)

(9)

(10)

is a length-K vector, in which the k-th element
tiny block in the coded outgoing strip

e(t)
i,k contains Q entries and equals to the veriﬁcation result of the k-th coded
e
e
. Note that unlike the coded incoming strip or the coded outgoing strip, the coded

e

h(t)
i

e

e

8

outgoing result strip
the coded
and (13) for details).

e

i = F(αi) and uncoded e(t)
e(t)

is not a linear combination of outgoing result strips e(t)

K speciﬁed by GL. Instead, both of
i = F(ωi) are evaluation of polynomial F(z) at different points (see Equation (12)

1 , . . . , e(t)

e(t)
i

e

Nodes further obtain the indicator vector g ∈ {0, 1}QK by exchanging

; the details are given in Section IV-D. This
data is crucial for the next section, namely coded appending, as each of its entries is associated with a coded transaction
in every coded incoming strip. Speciﬁcally, note that every coded transaction is a linear combination of K transactions; the
corresponding entry of the indicator vector g equals to 0 if they are all valid. Otherwise, if invalid transactions are included,
the entry equals to 1.

e

e(t)
i

D. Coded Appending

The appending operation of node i is instructed by the indicator vector g. Following the coded veriﬁcation, each node i
to their coded shard, after setting to zero the parts of it which failed the veriﬁcation

appends the coded incoming strip
process. That is, node i zeros out the transactions whose corresponding entry of g equals to 1.

v(t)
i

e

Remark 4. This process of setting to zero the parts which fail veriﬁcation has an unexpected implication—it invalidates valid
transactions that were linearly combined with invalid ones. We deﬁne the Collateral Invalidation (CI) rate as the number of
transactions that are abandoned due to one invalid transaction, normalized by the total number of transactions processed in one
1
epoch. Polyshard [29] has an CI rate of 1
KQ , which is Q times smaller (i.e., better)
K , while our scheme has an CI rate of
than Polyshard.

IV. CODED CONSENSUS

In this section, we discuss the consensus aspect of our design. Due to its coded nature, we propose three conditions that
deﬁne coded consensus. Later, we show mechanisms that maintain these conditions. We use f to denote the number of Byzantine
nodes, and deﬁne a quorum as a set of N − f nodes. Our scheme tolerates these f Byzantine nodes in the partial synchrony
model, given that N ≥ (K − 1)d + 3f + 1; a discussion on the nature of this assumption is given in the following section.
Note that the communication between nodes is point-to-point, and the communication analysis takes into consideration every
bit that is transmitted through the system.

First, our design must guarantee consistency, i.e, at every epoch t, correct nodes must perform coded veriﬁcation on coded

outgoing strips generated from the same block B(t). Formally, we propose the following condition.

Condition 1 (Consistency). Every correct node i obtains
column of the generator matrix GL.

hi, deﬁned as

h(t)
i = (GL)⊺

i · B(t), where (GL)i denotes the i-th

This condition imposes that correct nodes obtain coded outgoing strips that are consistent with each other, i.e., correspond
to the same block B(t) deﬁned in Equation (3). Otherwise, correct veriﬁcation is impossible, as suggested in [11]. Moreover,
our design must maintain homology.

e

e

Condition 2 (Homology). Every correct node i obtains
in Condition 1.

vi, deﬁned as

vi = (GL)⊺

i (B(t))⊺, where both B(t) and GL are as

The second condition suggests that every node obtains the coded incoming strip that is homologous to the coded outgoing strip,
i.e., generated from the same block B(t). Otherwise, we say they are nonhomologous; such nonhomology problem can cause
a discrepancy between the veriﬁed and the appended, i.e., nodes verify valid transactions, but append invalid ones, nullifying
the veriﬁcation efforts. Satisfying this condition assures the correct appending of incoming strips. Finally, the blockchain must
not store invalid transactions, which gives rise to the last condition.

e

e

Condition 3 (Validity). Every correct node i appends the coded incoming strip
invalid coded transactions to zero, i.e, coded transactions which were not formed exclusively from valid transactions.

to its local coded chain after setting the

v(t)
i

This condition requires every node i to obtain the indicator vector g deﬁned in Section III-D. Together, we say that a protocol
provides coded consensus if it simultaneously achieves Condition 1, Condition 2 and Condition 3, i.e., maintains consistency,
homology, and validity at the same time. We propose such a protocol, employing a leader to distribute coded strips and
provide coded consensus. Our approach adopts HotStuff [20], a BFT SMR with linear message complexity, and techniques
from Information Dispersal for consistency and homology. In addition, we employ coded computation that maintains validity
of the system. Further, the superscript (t) is omitted for clarity in the rest of this paper.

e

A. Overview

In order to maintain the aforementioned three properties, we employ HotStuff to maintain a chain of headers, each
corresponds to a block. HotStuff provides the safety and liveness property of the header chain. Together with information
dispersal techniques, our scheme maintains the consistency property. We provide detailed discussion in Section IV-B. Further,

9

Header Chain

header

header

header

header

Coded Shard

vt−2
i

vt−1
i

vt
i

vt+1
i

e
Illustration of the internal storage of node i. We use HotStuff for nodes to reach a consensus on a chain of headers. Meanwhile, each node stores a
Fig. 2.
distinct chain of coded incoming strips. i.e., the coded shard. The consensus on the chain of headers assures that at any height t (i.e., epoch) of the chain,
nodes store coded outgoing strips that are consistent with each other, i.e., generated from the same block B
.

e

e

e

we incorporate extra mechanisms in HotStuff to maintain homology (Section IV-C) and validity (Section IV-D). In Section V,
we show that our scheme indeed provides coded consensus, and inherits the liveness property from HotStuff.

B. Maintaining Consistency (Condition 1)

We ﬁrst address the consistency problem of coded outgoing strips generated from B (the case for coded incoming strips are
similar). Our method depends on a data structure called checksum, introduced by AVID-FP [32]. A checksum allows nodes to
verify that the received coded strip is consistent with ones received by others, i.e., computed from the same block. It contains a
list of K ﬁngerprints. Each ﬁngerprint is generated from an (uncoded) outgoing strip (a row of B), using some ε-ﬁngerprinting
function fp deﬁned as follows.
Deﬁnition 1. [32, Deﬁnition 2.1] A function fp : T × Fδ
q

(cid:1) Fγ

max

d,d′∈Fδ

q,d6=d′

Pr
r∼Unif (T )

q is an ε-ﬁngerprinting function if
[fp(r, d) = fp(r, d′)] ≤ ε.

That is, the probability for two distinct d, d′ ∈ Fδ
at random from some input space T .

q to have the same ﬁngerprint is at most ε, where the key r is chosen uniformly

(cid:1) Fγ

Examples of ε-ﬁngerprinting functions include division ﬁngerprinting, which generalizes Rabin’s ﬁngerprinting [44] from F2
to any ﬁeld Fq. With coefﬁcients in Fq, the input d ∈ Fδ
q is regarded as a polynomial d(x) of degree δ, and T is a collection of
monic irreducible polynomials of degree γ. The division ﬁngerprinting function returns the remainder of d(x) divided by p(x),
i.e., d(x) mod p(x), where p(x) is chosen from T uniformly at random.

We let fp : T × Fδ
q

q be an ε-ﬁngerprinting function where δ = |B|

K is the size of a strip. As done in AVID-FP [32],
the random selection of r from T is simulated by deterministic cryptographic hash functions [45]; referring to the use of a
hash function as a random oracle is a common practice in blockchain systems, e.g., in [24]. In addition to the K ﬁngerprints,
hN )] is included in the checksum, generated using a cryptographic hash
a list of hash values cc = [hash(
function hash : F∗
q (not to be confused with hash1 and hash2 mentioned earlier). The selection of r is achieved by
q
q )N (cid:1) T , which takes the list cc as input and outputs an element in T 2.
another cryptographic hash function select : (Fλ
e
Formally, the function CHECKSUM in Algorithm 1 encapsulates the construction of the checksum.

h1), . . . , hash(

(cid:1) Fλ

1 · B, . . . , (GL)⊺

The leader ﬁrst generates coded outgoing strips (GL)⊺

creates coded incoming strips (GL)⊺
piggybacked with the coded fragments
the received checksum, i.e., cksH and
we require the ﬁngerprinting function to be homomorphic.
Deﬁnition 2. [32, Deﬁnition 2.5] A ﬁngerprinting function fp : T ×Fδ
(cid:1) Fγ
q is homomorphic if fp(r, d)+fp(r, d′) = fp(r, d+d′)
q
and b · fp(r, d) = fp(r, b · d) for any r ∈ T , any b ∈ Fq, and any d, d′ ∈ Fδ
q.

1 · B⊺, . . . , (GL)⊺
hi = (GL)⊺
hi are computed from the same B, and cksV and
e
e

N · B and constructs the checksum cksH. Similarly, it
N · B⊺ and cksV. The leader then sends the checksums to every node i
i · B⊺. In order to verify that a coded strip agrees with
vi are computed from the same B⊺,

vi = (GL)⊺

i · B and

e

e

e

This property enables the node to verify that the coded fragment satisﬁes the required linear combination (deﬁned by the
generator matrix) with uncoded strips, by having access only to the ﬁngerprints of uncoded strips, and not to the uncoded
strips. As any coded strip is a linear combination of K uncoded strips, the homomorphism guarantees that its ﬁngerprint must
be equal to the same linear combination of K ﬁngerprints of uncoded strips, i.e.,

fp(r, h1)
...
fp(r, hK )






(GL)⊺






= 

fp(r,
...
fp(r,

h1)

e
hN )






, and (GL)⊺






fp(r, v1)
...
fp(r, vK )






fp(r,
...
fp(r,

= 




v1)

.

e
vN )









2We point out that Veriﬁable Random Function (VRF) [33] is an alternative implementation of the random oracle, which is communication-efﬁcient as it

does not require the checksum to contain N hash values. It has been employed in blockchain designs including [9] and [25], but for different purposes.

e

e

10

vi is the i-th row of the matrix

hi is the i-th row of the matrix
B⊺ = (GL)⊺

i B. Similarly, vk is the k-th
Note that hk is the k-th row of the matrix B, and
row of the matrix B⊺, and
i B⊺. Thus, each node can conﬁrm the agreement
e
between the received (coded) strip and the checksum, as long as the ﬁngerprints of the coded strip match the encoding of
the K ﬁngerprints in the checksum; this is guaranteed with high probability, as shown [32, Theorem 3.4].
f
In this respect, each node can assure that the received coded strip is consistent with ones received by others by reaching a
consensus on the checksum which is in agreement with all coded strips. Treating checksums as requests, we can employ BFT
SMR protocols that allow correct nodes to reach a consensus on the total order of them, and hence maintain the consistency of
strips at any epoch t. Speciﬁcally, we adopt HotStuff [20], a leader-based BFT SMR protocol that works in partial synchrony
(see Section II-B). We deﬁne a header of a block B as a concatenation of checksums computed from the matrix B and its
transpose B⊺, i.e.,

e

e

B = (GL)⊺

header = (cksH, cksV).

HotStuff allows nodes to reach a consensus on a chain of header. HotStuff always ensure safety given bounded number of
faulty nodes (N ≥ 3f + 1). That is, no two correct node should accept conﬂicting headers; by conﬂicting we mean the chain
led by neither one extends the chain led by the other. Hence, correct nodes will never accept different headers at any epoch t.
When the system becomes synchronous, HotStuff provides the liveness property, such that the consensus on headers will be
reached when the leader is correct. As discussed earlier, such a consensus on a header guarantees the consistency of coded
fragment generated from the corresponding block.

For clarity, the lines in Algorithm 2 and Algorithm 3 are color coded. The pseudocode of HotStuff is provided in black.
The blue lines concern the distribution and veriﬁcation of coded strips, maintaining validity. The orange lines and green lines
maintain consistency and homology, respectively. We will elaborate the colored lines in sequel. In particular, we argue that
our add-ons do not affect the safety and liveness property of HotStuff algorithm.

Algorithm 1 Utilities

1: function MSG(type, header, qc, payload)
2: m.type = type
3: m.viewNumber = curView
4: m.header = header
5: m.qc = qc
6: m.payload = payload
7:
8: function HEADER(prev, checksums)
9:
10:

header.prev = prev
header.checksums = checksums

return m

// instantiate QC from a set of messages

11: function QC(M)
12:
13:
14:
15:

qc.type (cid:0) m.type : m ∈ M
qc.viewNumber (cid:0) m.viewNumber : m ∈ M
qc.header (cid:0) m.header : m ∈ M
qc.sig ← tcombine(hqc.type, qc.viewNumber,

{qc.headeri, m.partialSig | m ∈ M})

return (m.type = t) ∧ (m.viewNumber = v)

16: function MATCHINGMSG(m, t, v)
17:
18: function MATCHINGQC(qc, t, v)
19:

return (qc.type = t) ∧ (qc.viewNumber = v)∧
tverify(hqc.type, qc.viewNumber, qc.headeri, qc.sig)

return m · G

return G⊺ · M

20: function ENCODE(G, m)
21:
22: function ENCODEROW(G, M)
23:
24: function CHECKSUM(G, M)
M (cid:0) ENCODEROW(G, M)
25:
f
for k = 1 to N do
26:
cks.CC[i] (cid:0) hash(
27:
r (cid:0) select(cks.CC)
28:
for k = 1 to K do
29:
30:
31:

cks.FP[k] (cid:0) fp(r, mk.∗)
M
f

mi.∗)
e

return cks,

// check if checksum agrees with coded fragment

// m:length-K vector

//

//

M: N × K matrix
f

the i-th row of

M
f

//

the k-th row of M

h (cid:0) hash(fragment) f (cid:0) fp(select(cks.CC), fragment)
return (h = cks.CC[i]) ∧ (f = ENCODE(GL, cks.FP)[i])

32: function AGREE(checksum, fragment, i)
33:
34:
35: function SAFEHEADER(header, qc)
36:
37:
38: function SIGNEACH(m, i)
39:
40:

for j = 1 to N do result[j] (cid:0) hm[j]iσi
return result

return (header extends from lockedQC.header)∨

(qc.viewNumber > lockedQC.viewNumber)
// m: length-N vector

HotStuff runs in consecutive views associated with increasing integer view numbers. In each view there is a designated
node LEADER(viewNumber) that proposes new headers and distribute coded strips. In order to append a header to the chain,
the leader must collect partial signatures on its proposal from a quorum of nodes in each of three phases, namely PREPARE,
PRE-COMMIT and COMMIT. The partial signatures are generated with a (N − f, N )-threshold signature scheme π.

A new leader must collect NEW-VIEW messages from a quorum of nodes; a correct node sends the NEW-VIEW message,
alongside a valid prepareQC (deﬁne next) with highest view that it has received, to the leader of the next view if it believes
the current one fails (line 22, Algorithm 3). The new leader chooses the one, called highQC, with the highest view number
within all received prepareQCs. It creates and extends the new header (i.e., containing the hash value of another header) from
the header contained in highQC. If the leader is an incumbent one, it extends the header from its last proposed header.

hi and

Incumbent or not, the leader sends the newly created header to every node i piggybacked with the corresponding coded
vi (line 8, Algorithm 2) generated from the block B (line 2, Algorithm 2). Upon receiving the PREPARE message
strips
from the leader, the node i runs the function SAFEHEADER in Algorithm 1 which compares the newly received header with the
header it has locked on (i.e. the header contained in the precommitQC with highest view number it has received, called lockedQC,
which will be deﬁned next). The new header is considered valid if it extends from the locked header, or extends from a header

e

e

11

Algorithm 2 Coded Consensus Part 1

⊲ PREPARE PHASE

(cksH,

vi]
e

{m.qc.viewNumber}).qc

B⊺) (cid:0) CHECKSUM(GL, B⊺)
f

B) (cid:0) CHECKSUM(GL, B), (cksV,
e

1: as a leader
2: B (cid:0) collect a block of transactions
3:
4: wait for N − f NEW-VIEW messages: M (cid:0) {m | MATCHINGMSG(m, NEW-VIEW, curView − 1)}
5:

highQC (cid:0) (arg max
m∈M
header (cid:0) HEADER(highQC.header, [cksH, cksV])
for i = 1 to N do
payload (cid:0) [
hi,
e
send MSG(PREPARE, header, highQC, payload) to node i

6:
7:
8:
9:
10: as node i
11: wait for message m from LEADER(curView): m (cid:0) MATCHINGMSG(m, PREPARE, curView)
if (m.header extends from m.qc.header) ∧ (SAFEHEADER(m.header, header.qc)) then
12:
13:
14:
15:
16:
17:
18:
19:
20:

codedResults (cid:0) F (
Vi,
e
wi,∗ (cid:0) ENCODE(GL, m.payload[1]), pxi
ui,∗ (cid:0) ENCODE(GL, m.payload[2])
results (cid:0) ENCODE(GL, codedResults), sigResults (cid:0) SIGNEACH(ENCODE(GL, codedResults))
ack (cid:0) MSG(PREPARE, m.header, ⊥, payload (cid:0) (pxi, results, sigResults)
ack.partialSig (cid:0) hPREPARE, curView, m.headeriπ,i
send ack to LEADER(curView)

if ¬(AGREE(header.checksum[1], m.payload[1], i) ∧ AGREE(header.checksum[2], m.payload[2], i) then

(cid:0) SIGNEACH(wi,∗)

hi)
e

// i = LEADER(curV iew)

// QC with highest view number

// the i-th rows of

B and
e

B⊺
f

// acknowledge the PREPARE message

⊲ PRE-COMMIT PHASE

prepareQC (cid:0) QC(A)
for i = 1 to N do

payload[1] (cid:0) COLUMN({ack.payload[1] | ack ∈ A}, i)
payload[3] (cid:0) COLUMN({ack.payload[3] | ack ∈ A}, i)
payload[4] (cid:0) COLUMN({ack.payload[4] | ack ∈ A}, i)
m (cid:0) MSG(PRE-COMMIT, ⊥, prepareQC, payload), m.quorumIdentiﬁer (cid:0) QI(I)
send m to node i

21: as a leader
22: wait for ack’s on PREPARE from a quorum I: A (cid:0) {ack | MATCHINGMSG(ack, PREPARE, curView)}
23:
24:
25:
26:
27:
28:
29:
30: as node i
31: wait for message m from LEADER(curView): m (cid:0) MATCHINGQC(m.qc, PRE-COMMIT, curView)
32:
33:
34:
35:
36:
37:
38:
39:

decoded (cid:0) DECODE(m.payload[3])
binaryResults (cid:0) BINARY(decoded)
payload (cid:0) PARTIALINDICATOR(binaryResults)
ack (cid:0) MSG(PRE-COMMIT, m.qc.header, ⊥, payload)
ack.partialSig (cid:0) hPRE-COMMIT, curView, m.qc.headeriπ,i, ack.partialSigQI (cid:0) hQIiπ,i
send ack to LEADER(curView)

prepareQC (cid:0) m.qc
if VERIFYSIG(m.payload[1]), ui,∗) ∧ VERIFYSIG(m.payload[2], m.payload[3]) then

// acknowledge the PRE-COMMIT message

in a prepareQC with a higher view number than the lockedQC (line 37, Algorithm 1). Such a check guarantees both safety [20,
Theorem 2] and liveness [20, Theorem 4].

Further, a valid checksum in the header must agree with the coded strip, and we implement the checking process in the
function AGREE in Algorithm 1. In particular, we add another predicate in line 13 of Algorithm 2 to verify such agreements.
If the aforementioned two predicates both return true, node i responds with a partial signature hPREPARE, curView, headeriπ,i
acknowledging the header from the leader of the current view (line 19, Algorithm 2). The leader then enters the PRE-COMMIT
phase, and instantiates a prepareQC (where QC stands for quorum certiﬁcate) from the replies using the constructor function QC
in Algorithm 1. The prepareQC contains a valid signature hPREPARE, curView, headeriπ, showing a quorum of N − f nodes
has acknowledged the PREPARE message from the current leader.

The leader broadcasts prepareQC. Every node veriﬁes the signature hPREPARE, curView, headeriπ using the function MATCH-
INGQC in Algortithm 1. After that, node i replies with a partial signature hPRE-COMMIT, curView, headeriπ,i. From the replies the
leader creates a precommitQC, and broadcast it in the COMMIT phase. Similarly, from the replies the leader creates commitQC;
nodes only link the coded outgoing strip

vi to the local chain after receiving the commitQC.

C. Maintaining Homology (Condition 2)

e

Although [20] allows nodes to reach a consensus on the chain of headers, which guarantees the consistency property of strips,
the homology problem remains. With a Byzantine leader, even though a correct node i may obtain a consistent coded outgoing
vi = (GL)⊺
i (B′)⊺, they might correspond to different blocks B 6= B′.
strip
To solve this problem, we integrate the following design (in green) with Hotstuff’s three-phase protocol to maintain homology.

i B and consistent coded incoming strip

hi = (GL)⊺

e

e

12

Algorithm 3 Coded Consensus Part 2

⊲ COMMIT PHASE

broadcast m

payload (cid:0) MERGEINDICATORS(A)
precommitQC (cid:0) QC(A)

1: as a leader
2: wait for (N − f ) ack’s on PRE-COMMIT: A (cid:0) {ack | MATCHINGMSG(ack, PRE-COMMIT, curView)}
3:
4:
5: m (cid:0) MSG(COMMIT, ⊥, precommitQC, payload)
6: m.signatureQI (cid:0) tcombine(hQIi, {ack.partialSigQI | ack ∈ A})
7:
8: as node i
9: wait for message m from LEADER(curView): m (cid:0) MATCHINGQC(m, COMMIT, curView)
10:
11:
12:
13:
14:

lockedQC (cid:0) m.qc
vi (cid:0) UPDATE(
vi, m.payload)
ack (cid:0) MSG(COMMIT, m.qc.header, ⊥, ⊥), ack.partialSig (cid:0) hCOMMIT, curView, m.qc.headeriπ,i
e
e
send ack to LEADER(curView)

if tverify(hQI(I)i, m.signatureQI) then

// update coded incoming strip using g

// acknowledge the PRE-COMMIT message

⊲ DECIDE PHASE

commitQC (cid:0) QC(A)
broadcast MSG(DECIDE, ⊥, commitQC, ⊥)

15: as a leader
16: wait for (N − f ) ack’s on COMMIT: A (cid:0) {ack | MATCHINGMSG(ack, COMMIT, curView)}
17:
18:
19: as node i
20: wait for message m from LEADER(curView): m (cid:0) MATCHINGQC(m, COMMIT, curView)
21:

append

vi to local chain
e

⊲ NEXTVIEW INTERRUPT

22: send MSG(NEW-VIEW, ⊥, prepareQC, ⊥) to LEADER(curView + 1)

Upon receiving the coded outgoing strip

the right with GL, creating a length-N vector wi,∗, which equals to the i-th row of the matrix W = G⊺
Algorithm 2). Similarly, it creates a vector ui,∗ = (GL)⊺
i

vi as the i-th row of U = (GL)⊺(B′)⊺GL (line 16, Algorithm 2).

i B from the leader in the PREPARE phase, node i multiplies it from
LBGL (line 15,

Node i then deﬁnes a length-N signature vector pxi, whose j-th entry stores its digital signature (not to be confused with

e

hi = (GL)⊺

partial signature) on hwi,j , ji. Formally, we have

e

pxi[j] = hwi,j , jiσi , for j ∈ [N ].

(11)

Node i sends back pxi in the acknowledgement of the PREPARE message received from the leader. For every received pxi,
the leader ﬁrst veriﬁes if pxi[j] is indeed a valid signature on wi,j, for each j ∈ [N ]. This step is omitted in the pseudocode
for clarity, and the leader ignores messages that fail the veriﬁcation. After collecting such vectors from nodes in a quorum I
of size |I| = N − f , the leader stacks the pxi’s in an (N − f ) × N matrix ordered by the indices of nodes. It sends the j-th
column of the resulting matrix to every node j ∈ [N ] in the PRE-COMMIT message together with a quorum identiﬁer QI(I)
that speciﬁes the members of I.3 (line 28, Algorithm 2).

Upon receiving the PRE-COMMIT message from the leader, node j learns the members of I from the quorum identiﬁer QI(I).
Meanwhile, node j receives hwi,j iσi , for every i ∈ I, and veriﬁes if the received hwi,j , jiσi is a valid signature on huj,i, ji
(line 33, Algorithm 2). The process is encapsulated in function VERIFYSIG, whose simple implementation (see above) is omitted
for brevity. If the veriﬁcation passes, node j creates partial signature hQI(I)iπ,i on the quorum identiﬁer and sends it back to
the leader as an acknowledgement of the PRE-COMMIT message (line 38, Algorithm 2).

The leader veriﬁes the received partial signature; this veriﬁcation is omitted in the pseudocode. Upon receiving acknowl-
edgements from a quorum J of nodes, the leader combines partial signatures and broadcasts a COMMIT message with a valid
signature hQI(I)iπ (line 6–7, Algorithm 3). Nodes can be convinced that B = B′ after verifying hQI(I)iπ in the COMMIT
message, due to the following lemma.

Lemma 1. A valid signature hQI(I)iπ implies B = B′.

Proof. The signature hQI(I)iπ reveals the existence of a quorum J such that for every correct node j ∈ J and every correct
node i ∈ I, we have

wi,j = (GL)⊺

i B(GL)j = (GL)⊺

j (B′)⊺(GL)i = uj,i.

Since we assume that N = (K − 1)d + 3f + 1, the quorums I and J intersect on at least

2(N − f ) − N = (K − 1)d + f + 1 − (K − 1) + (K − 1) = (K − 1)(d − 1) + f + K ≥ f + K

nodes, which contains at least K correct ones.

3Since there are (cid:0)

N
N
f (cid:1) possible quorums, log (cid:0)
f =1 (cid:0)
size compared to the N − 2f digital signatures sent along with it.

N
f (cid:1) < log[P

N

f (cid:1)] = log 2N = N bits sufﬁce to uniquely present either of them; this is negligible in

13

Let K be a set containing these K correct nodes, and let GK be a K × K matrix containing the corresponding K columns
KB′GK. By the

k′ (B′)⊺gk for every k, k′ ∈ [K], it follows that G⊺

of the Lagrange matrix GL. Since g⊺
MDS property of GL, the matrix GK is invertible, and hence B = B′.

KBGK = G⊺

k Bgk′ = g⊺

D. Maintaining Validity (Condition 3)

So far, we have developed mechanisms that maintain homology and consistency. Together, every correct node i is performing
i B⊺. We now present
veriﬁcation on the coded outgoing strip
a communication-efﬁcient scheme that employs coded computation to guarantee validity, such that no invalid transactions in
the block can be appended to the blockchain.

i B and appending the coded incoming strip

hi = (GL)⊺

vi = (GL)⊺

e

Speciﬁcally, we weave a mechanism into the existing protocol. It allows nodes to securely obtain the indicator vector g ∈
{0, 1}QK. Note that each of the entries of g is associated with a coded transaction in every coded incoming strip. A coded
transaction should be zeroed-out if the corresponding entry is 1 (see Section III-C).

e

Recall that the degree of the polynomial veriﬁcation function F(z) is (K −1)d, and hence it is uniquely deﬁned by evaluations
at any L = (K − 1)d + 1 distinct points. That is, for any distinct β1, . . . , βL, one may represent F(z) as a linear combination
of L Lagrange basis polynomials Ψ1(z), . . . , ΨL(z), i.e.,

F(z) =

F(βi)Ψℓ(z), where Ψℓ(z) =

Xℓ∈[L]

z − βl
βℓ − βl

.

Yl,ℓ∈[L],l6=ℓ

As a result, the coded outgoing result strips F(α1), . . . , F(αN ) can be represented as

and the (uncoded) outgoing result strips can be represented as

e1
...
e
eN











(8)
= 




F(α1)
...
F(αN )






e

e1
...
eK






F(ω1)
...
F(ωK)




(8)

= 









= G⊺

F ,α · 

= G⊺

F ,ω · 



F(β1)
...
F(βL)






= 





F(β1)
...
F(βL)






= 











...

...

Ψ1(α1) Ψ1(α2)
Ψ2(α1) Ψ2(α2)

ΨL(α1) ΨL(α2)

. . . Ψ1(αN )
. . . Ψ2(αN )
. . .
. . . ΨL(αN )

...

F(β1)
...
F(βL)






· 




Ψ1(ω1) Ψ1(ω2)
Ψ2(ω1) Ψ2(ω2)

ΨL(ω1) ΨL(ω2)

. . . Ψ1(ωK)
. . . Ψ2(ωK)
. . .
. . . ΨL(ωK)

...

⊺

· 




F(β1)
...
F(βL)






⊺















...

...

,

.

(12)

(13)

Upon receiving the message from the leader in the PREPARE phase, node i computes the veriﬁcation function F and obtains its
ei (line 14, Algorithm 2). Node i multiplies it from the right with the Lagrange matrix GL ∈ FK×N
,

q

ei,K) · GL, which equals to the i-th row of the matrix

C = G⊺

F ,α ·

F(β1)⊺, . . . , F(βL)⊺

⊺

· GL.

(14)

coded outgoing result strip
and obtains ci,∗ = (

ei,1, . . . ,
e

e

e

(cid:2)

(cid:3)

In the acknowledgment of the PREPARE message, node i replies the leader with ci,∗ with its signatures on each entry
(line 17, Algorithm 2). The leader veriﬁes if the signatures matches ci,∗; this step is omitted in the pseudocode for clarity.
Upon receiving a quorum of N − f such vectors, the leader stacks them on top of each other to form a (N − f ) × N
matrix (which is a submatrix of C), and sends the j-th column to every node j ∈ [N ] in the PRE-COMMIT phase (line 26,
Algorithm 2). Note that the j-th column of C is the encoding of the j-th column of matrix [F(β1)⊺, . . . , F(βL)⊺]⊺ · GL using
the generator matrix GF ,α, which generates a Lagrange code of length N and dimension L. As a result, every node can
perform Reed-Solomon decoding after verifying the signature of each entry (line 33, Algorithm 2), and obtain the j-th column
of matrix [F(β1)⊺, . . . , F(βL)⊺]⊺ · GL (line 34, Algorithm 2). The decoding is given in the function DECODE which calls a
Reed-Solomon decoder. Since we have N ≥ (K − 1)d + 3f + 1, decoding from N − f elements will be successful since there
are at most f Byzantine nodes.

By left multiplying the decoded column with G⊺
1 , . . . , e⊺
e⊺
F(β1)⊺, . . . , F(βL)⊺
K
sj = R · (GL)j.
equals to the j-th coded incoming result strip by Equation (5) and Equation (6), i.e.,
(cid:2)
(cid:3)

· GL. This vector equals to the j-th column of

F ,ω, every correct node i obtains the j-th column of the matrix G⊺

F ,ω ·
· GL by Equation (13), which further

Recall that the result block R is a K ×K matrix whose each element rk,k′ stores the veriﬁcation results of the Q transactions
si contains K coded tiny result blocks; the k-th one is a
in the tiny block bk,k′ . Therefore, a coded incoming results strip
linear combination of rk,1, . . . , rk,K deﬁned by (GL)k. Hence, for l ∈ [Q], the l-th entry in the k-th coded tiny result block
is a linear combination of veriﬁcation results of transactions in Sk,l; a set containing every l-th transaction in bk,1, . . . , bk,K.
If the entry is not a zero vector, it suggests that at least one of these veriﬁcation results is not a zero vector, which further
suggests at least one transaction in Sk,l is invalid. On the other hand, if the entry is a zero vector, node i cannot conclude the
validity of transactions in Sk,l, as a linear combination of non-zero vectors might be the zero vector.

e

e

(cid:3)

(cid:2)

⊺

⊺

14

Recall that in an MDS code of dimension K, every codeword is either the zero codeword, or has at most K − 1 zeros. In
sN form a codedword of an [N, K] MDS code,
this regard, the l-th entries in the k-th coded tiny result block from all
and hence contains either all zero vectors, or at most K − 1 zero vectors (note that a vector is an element in the codeword).
The former case implies that each of the l-th transactions in bk,1, . . . , bk,K passes veriﬁcation. The latter case implies that at
least one of theses transactions is invalid, and the l-th coded transaction in the k-th coded tiny block of every coded incoming
strip must be set to zero before being appended. To simplify the problem, every node i creates a binary results vector g∗,i,
which is the i-th column of matrix G ∈ {0, 1}QK×N . Each entry of g∗,i is associated with an entry of
si; it equals to 0 if the
si is a zero vector, and equals to 1 otherwise (line 35, Algorithm 2). This operation is encapsulated
corresponding entry in
in the function BINARY, whose pseudocode implementation is omitted for its simplicity. Note that each row of G is either
all zeros, or contains at most K − 1 zeros. Clearly, the indicator vector g equals to the reduction of all columns of G with
operator bitwise OR.

s1, . . . ,

e

e

e

e

Let λ be a (K + f, N ) threshold signature scheme, and let τ be a (f + 1, N ) threshold signature scheme. Using the binary
results vector g∗,i, node i obtains a partial indicator as the output of the function PARTIALINDICATOR (line 36, Algorithm 2).
This function deﬁnes a length-QK vector, denoted by gwi, such that for every ℓ ∈ [QK],

gwi[ℓ] =

hℓ, 0, headeriλ,i
hℓ, 1, headeriτ,i

(

gℓ,i = 0
gℓ,i = 1

.

Node i sends gwi back to the leader in the acknowledgment of the PRE-COMMIT message. The leader collects gwi’s from a
quorum of N − f nodes and merges them into a length-QK vector gw using function MERGEINDICATORS (line 3, Algorithm 3);
the details are given as follows.

Among the ℓ-th entries of the collected vectors {gwj}j∈J , if there exist K + f partial signatures endorsing 0 (generated
by the λ scheme), the leader generates and stores a valid signature hℓ, 0, headeriλ in the ℓ-th entry of gw. Otherwise, if there
exists f + 1 partial signatures endorsing 1 (generated by the τ scheme), the leader stores a valid signature hℓ, 1, headeriτ .
Notice that exactly one of these cases must hold due to the following lemma. Note that we implicitly assume that the leader is
guaranteed to obtain responses from a quorum J in the PRE-COMMIT phase; such an assumption will be justiﬁed in Theorem 2
on the liveness property of our scheme.

Lemma 2. Among the ℓ-th entries of the collected vectors {gwj}j∈J from a quorum of size |J | = N − f , the leader is
guaranteed to obtain K + f partial signatures endorsing 0, or f + 1 partial signatures endorsing 1, but not both.

Proof. For any ℓ ∈ [QK], if the ℓ-th row of G is all-zero, then at least

N − 2f = (K − 1)d + f + 1 ≥ (K − 1)d + f + 1 − (K − 1) + (K − 1) = (K − 1)(d − 1) + f + K ≥ f + K

vector gwi’s are from correct nodes; they all have zero ℓ-th entry and sign using the λ scheme. Meanwhile, there exist at
most f 1’s, all from the Byzantine nodes.

If the ℓ-th row of G is not all-zero, then the number of nodes (at least N − (K − 1)) having 1’s must intersect with the

quorum on at least (N − f ) + N − (K − 1) − N nodes, which equals to

N − f − (K − 1) = (K − 1)d + 2f + 1 − (K − 1) = (K − 1)(d − 1) + 2f + 1 ≥ 2f + 1

nodes, out of which at least f + 1 are correct; they all endorse 1 and sign the entry using the τ scheme. Also, there exist at
most (K − 1 + f ) 0’s, out of which K − 1 are from correct nodes, and at most f are from Byzantine nodes.

The leader then broadcasts the vector gw to every node in the COMMIT phase. Every node i can learn the indicator vector g

from gw, i.e., for every ℓ ∈ [QK],

g[ℓ] =

0
1

(

gw[ℓ] = hℓ, 0, headeriλ
gw[ℓ] = hℓ, 1, headeriτ

.

It then uses the indicator variable to “ﬁlter out” invalid transactions in the coded incoming strip

vi (line 12, Algorithm 3).

In this section, we discuss the security, liveness, and the communication complexity aspects of our design. In particular, we

investigate the tradeoff between bit complexity and security level.

V. DISCUSSION

e

A. Security

The security level of our scheme is reﬂected by the upper bound of f compared with N , i.e., the maximum fraction of
Byzantine nodes that can be tolerated in the system. The following theorem shows that, for correct veriﬁcation of transactions, f
depends on the total number of nodes N , the number of shards K, and the degree d of the veriﬁcation function.

15

Theorem 1. If N ≥ (K − 1) · d + 3f + 1, our design provides coded consensus.

Proof. First, HotStuff guarantees safety [20, Theorem 2] (see Section IV for deﬁnitions) of the header chain when N ≥ 3f + 1,
which is a weaker assumption than N ≥ (K − 1)d + 3f + 1. Note that the added mechanisms are irrelevant to the safety
property, as no extra conditions on which nodes can accept a header are introduced. The property of homomorphic ﬁngerprinting
function assures the consistency between the coded fragments received by each node [32, Theorem 3.4]. Together, consistency
is maintained.

Second, as seen in Lemma 1, our method maintains homology between the coded incoming strips and the coded outgoing

strips when N ≥ (K − 1) · d + 3f + 1.

Finally, in order to obtain the indicator vector g, every node needs to decode an [N, L] Reed-Solomon code from N − f
elements in the codeword, where L = (K − 1)d + 1 (see Section IV-D). Since N − f ≥ (K − 1)d + 2f + 1, the property of
Reed-Solomon code guarantees correct decoding in this case. Thus, validity is maintained.

B. Liveness

Although the proposed algorithm provides coded consensus, adversaries may conduct a liveness attack, i.e., prevent the

system from processing new transactions. In this section, we show that the proposed algorithm also provides liveness.

Theorem 2. In the partial synchrony model, the proposed algorithm provides liveness after Global Stabilization Time (GST,
see Section II-B).

Proof. As shown in [20, Theorem 4], HotStuff provides liveness after GST. That is, a decision is reached given that there is
a bounded duration Tf , in which all correct nodes remain in the same view, and the view-leader is correct. We show that this
property is preserved with the added mechanisms. Speciﬁcally, in our modiﬁed algorithm, there are precisely three occasions,
one in each phase, in which liveness can be affected: line 13, Algorithm 2, line 33, Algorithm 2, and line 10, Algorithm 3. In
these occasions, a correct leader might fail to collect sufﬁciently many responses, and thus liveness might not be guaranteed.
We show that each of these occasions depends on a Boolean predicate which is guaranteed to be satisﬁed when the leader is
correct, and thus liveness is preserved.

The ﬁrst predicate (line 13, Algorithm 2) checks if the received header agrees with the received strips. It is true in every
correct node since a correct leader follows the protocol. Therefore, a correct leader is guaranteed to receive valid responses in
the PREPARE phase from N − f nodes.

For the second predicate (line 33, Algorithm 2), given the N − f valid responses from the PREPARE phase, a correct leader
is able to construct two (N − f ) × N matrices. The j-th row of these matrices will make the green-colored function calls in
line 33, Algorithm 2 to return true for node j. For the same reason, a correct leader is able to construct an (N − f ) × N matrix,
whose j-th row will make the blue-colored function call in the same line true. Therefore, every correct node will respond in
the PRE-COMMIT phase, and hence the correct leader will receive responses, each containing a valid partial signature on QI,
from N − f nodes.

Finally, the leader is able to generate a valid signature hQI(I)iπ on the quorum identiﬁer from the partial signatures.

Therefore, the third predicate (line 10, Algorithm 3) is true as well.

C. Communication Complexity

We analyze the communication complexity for the system to process a block B that contains P = QK 2 transactions, and
then compare it to ordinary blockchain designs. The bit complexity of the different stages of our protocol is analyzed next,
and sumarized in Table I. Note also that the message complexity is linear thanks to the HotStuff protocol in use.

PREPARE

COMMIT
Leader O(N log N + dQK log N ) O(N Q log N ) O(QK)
Node

O(N Q log N )

O(QK)

O(1)

PRE-COMMIT

DECIDE
O(1)
N/A

TABLE I
BIT COMPLEXITIES OF A SINGLE MESSAGE FROM THE LEADER TO A NODE, AND FROM A NODE TO THE LEADER, IN EACH OF THE STAGES.

In the PREPARE phase, the leader sends a checksum and two coded fragments to each of the N nodes. A checksum contains N
signatures over Fq, and a coded fragment contains |B|
K bits. Recall that a block B contains QK 2 transactions, and each contains
a lookup table whose size scales logarithmically with the number of transactions in a shard, same as the degree of the polynomial
veriﬁcation function d (see Section III-B). Further, since the underlying ﬁeld Fq must contain at least N distinct elements,
it follows that the size of a ﬁeld element is O(log N ) bits. Together, the size of a block is O(dQK 2 log N ), and the size
of a coded strip is O(dQK log N ). Note that the leader also broadcast the header, which contains 2N hash values and 2K
ﬁngerprints, each has a constant number of ﬁeld elements. Therefore, the message from the leader to a single node in this step
is O(N log N + dQK log N ).

16

Also in the PREPARE phase, every node i sends N signatures (line 15, Algorithm 2), as well as N coded tiny result
blocks (line 17), to the leader. Recall that every coded tiny result block contains Q veriﬁcation results, each is a length-
(C + E) vector, where C + E is the outputs of hash functions and hence constant. Therefore, each message from a node to
the leader in the PREPARE phase has a size of O(N + N Q(C + E) log N ) = O(N Q log N ).

In the PRE-COMMIT phase, node i receives (N − 2f ) signatures (line 25, Algorithm 2) and N − 2f coded tiny result
blocks (line 26) back from the leader. Therefore, the size of a message from the leader to a node is also O(N + N Q log N ) =
O(N Q log N ). Next, still in the PRE-COMMIT phase, every node i sends a partial indicator vector (line 36) to the leader, whose
size is O(QK) as it contains QK partial signatures. In the COMMIT phase, every node receives a length-QK vector of threshold
signatures (line 3). In addition, every message sent to the leader contains a partial signature and hence has a size of O(1).
Similarly, every message sent from the leader in the DECIDE phase contains a threshold signature (in commitQC), and hence
has size O(1). Together, the bit complexity of our design is as follows.

Corollary 1. For µ < 1/3, to tolerate µN Byzantine nodes in a system with N nodes, the overall bit complexity for verifying
a block of P = K 2Q transactions is O( P d2 log N

(1−3µ)2 ).
Proof. From Table I, the overall bit complexity is

O(N 2 log N + dN QK log N + N 2Q log N + N QK + N ) = O(N 2Q log N + dN QK log N ).

Taking the maximum possible f given the parameter restriction in Theorem 1, we have that N = (K − 1) · d + 3f + 1, and
hence for n = (K−1)d

we have

f

N
K

≈

N − 1
K − 1

=

(3 + n)f
nf /d

3
n

= d

1 +

,

(15)

dN QK log N = N

Further, since N 2Q log N
Kd ≈ 1 + 3
(K − 1)d + 3f + 1 by Theorem 1, the system tolerates a fraction µ = f
express the overall bit complexity as a function of µ:

(cid:19)
n ≥ 1, it follows that the overall bit complexity is O(N 2Q log N ). As we have N =
3+n+1/f ≈ 1
3+n of Byzantine nodes. We can now

N =

(cid:18)

1

O(N 2Q log N ) = O((N/K)2K 2Q log N ) = O(P d2(1 + 3/n)2 log N ) = O

P

d2 log N
(1 − 3µ)2

.

(cid:19)

(cid:18)

That is, for a system of N nodes and the veriﬁcation function of degree d, the system designer can choose a value for µ,
and the bit complexity for verifying a block scales quadratically with d and logarithmically with N . Note that the degree d
scales logarithmically with the number of transactions on one shard. We hereby rewrite the bit complexity for verifying one
block as

where M (t) equals to the number of transactions on one shard at epoch t.

O(P log2 M (t) log N ),

To show the novelty of our design, we deﬁne the communication gain G as the ratio between the bit complexity common
in ordinary blockchain systems, which require every node to receive every transaction, and the bit complexity of our design;
the former leads to an inevitable O(N P ) bit complexity assuming that each transaction requires a constant amount of bits,
and a block contains P transactions. Speciﬁcally, if the system in our design tolerates µN Byzantine nodes, where µ < 1
3 , the
communication gain is

G =

N P
P d2 log N
(1−3µ)2

=

N (1 − 3µ)2
d2 log N

.

(16)

It is evident from (16) that the communication gain is signiﬁcant for any ﬁxed value of µ and d. Moreover, increasing the
number of nodes in the system while keeping the remaining parameters ﬁxed improves the overall communication gain with
respect to traditional designs; this is a highly desirable property of blockchain systems.

D. Communication-Security Tradeoff

By Corollary 1, the overall bit complexity is O(P d2 log N

(1−3µ)2 ), from which a tradeoff between security and communication is
evident. A lower µ value yields low bit complexity, but degrades the security level (since µ = f /N ). In contrast, a higher µ
value allows the system to tolerate more Byzantine nodes, but inevitably leads to a higher bit complexity. In Figure 3 we
illustrate the function µ 7→ 1
(1−3µ)2 , which describes the tradeoff between µ and the bit communication complexity, measured
relative to the baseline P d2 log N in Corollary 1.

This paper focuses on verifying the validity of new transactions, but does not discuss how nodes can learn if an old transaction
has already been redeemed. Directions for future work include incorporating light nodes, and developing algorithms for them

VI. FUTURE WORK AND CONCLUDING REMARKS

17

)

N
g
o
l

2
d
P
(

y
t
i
x
e
l
p
m
o
C

t
i

B

100

50

0

0

5

10
15
20
Security Level µ (%)

25

30

Fig. 3. An illustration of the tradeoff between the security level µ = f

N and communication bit complexity.

to access raw data by querying a coded distributed system with Byzantine nodes. Finally, as this paper adopts a simpliﬁed
UTXO model, the generalized multi-input multi-output setting is an interesting direction for future research. In spite of these
disadvantages, our work shows that coded computation can alleviate the communication burden in blockchain systems, while
maintaining the computations and storage beneﬁts of sharding.

REFERENCES

[1] C. Wang and N. Raviv, “Low Latency Cross-Shard Transactions in Coded Blockchain,” in IEEE International Symposium

on Information Theory, pp. 2678–2683, 2021.

[2] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” 2008.
[3] K. Croman, et al., “On scaling decentralized blockchains,” in International Conference on Financial Cryptography and

Data Security, pp. 106–125, 2016.

[4] I. Eyal, A. E. Gencer, E. G. Sirer, and R. Van Renesse, “Bitcoin-NG: A scalable blockchain protocol,” USENIX Symp.

Networked Systems Design and Implementation, pp. 45–59, 2016.

[5] R. Pass and E. Shi, “Hybrid Consensus: Efﬁcient consensus in the permissionless model,” International Symposium on

Distributed Computing, 2017

[6] E. Kokoris-Kogias, P. Jovanovic, N. Gailly, I. Khofﬁ, L. Gasser, and B. Ford, “Enhancing Bitcoin security and performance

with strong consistency via collective signing”, USENIX Security Symposium, pp. 279–296, 2016.

[7] A. Kiayias, A. Russell, B. David, and R. Oliynykov, “Ouroboros: A provably secure proof-of-stake blockchain protocol,”

Annu. Int. Cryptology Conference. pp. 357–388, 2017.

[8] P. Daian, R. Pass, and E. Shi, “Snow white: Robustly reconﬁgurable consensus and applications to provably secure proof

of stake,” in International Conference on Financial Cryptography and Data Security, 2019, pp. 23–41.

[9] Y. Gilad, R. Hemo, S. Micali, G. Vlachos, and N. Zeldovich, “Algorand: Scaling Byzantine Agreements for Cryptocur-

rencies”, Proceedings of the 26th Symposium on Operating Systems Principles, pp. 51–68, 2017.

[10] L. Lamport, R. Shostak, and M. Pease, “The Byzantine Generals Problem,” ACM Transactions on Programming Languages

and Systems, vol, 4, no. 3 pp. 382–401, 1982.

[11] N. A. Khooshemehr and M. A. Maddah-Ali, “The Discrepancy Attack on Polyshard-ed Blockchains,” in IEEE Int. Symp.

Information Theory, pp. 2672–2677, 2021.

[12] L. Lamport, “Time, Clocks, and the Ordering of Events in a Distributed System,” Communications, vol. 21, no. 7,

pp. 558–565, 1978.

[13] F. B. Schneider, “Implementing fault-tolerant services using the state machine approach: A tutorial,” ACM Computing

Surveys, vol. 22, no. 4, pp. 299–319, 1990.

[14] D. Malkhi and M. Reiter, “Byzantine quorum systems,” Distributed Computing, vol. 11, no. 4, pp. 203–213, 1998.
[15] C. Miguel and L. Barbara, “Practical byzantine fault

tolerance,” Symposium on Operating Systems Design and

Implementation, vol. 99, pp. 173–186, 1999.

[16] R. Kotla, L. Alvisi, M. Dahlin, A. Clement, and E. Wong, “Zyzzyva: Speculative byzantine fault tolerance,” in ACM

SIGOPS Symp. Operating Systems Principles, pp. 45–58, 2007.

[17] R. Guerraoui, N. Kneˇzevi´c, V. Qu´ema, and M. Vukoli´c, “The next 700 BFT protocols,” in Proceedings of the 5th European

conference on Computer systems, pp. 363–376, 2010.

[18] E. Buchman, J. Kwon, and Z. Milosevic, “The latest gossip on BFT consensus,” 2017.

[Online]. Available:

arXiv:1807.04938.

18

[19] G. G. Gueta, , I. Abraham, S. Grossman, D. Malkhi, B. Pinkas, M. K. Reiter, D.-A. Seredinschi, O. Tamir, and A.
Tomescu, “Sbft: a scalable and decentralized trust infrastructure,” in 49th Annual IEEE/IFIP international conference on
dependable systems and networks (DSN), pp. 568–580, 2019.

[20] M. Yin, D. Malkhi, M. K. Reiter, G. G. Gueta, and I. Abraham, “HotStuff: BFT consensus with linearity and
responsiveness,” Proceedings of ACM Symposium on Principles of Distributed Computing (PODC), pp. 347–356. 2019.
[21] A. Miller, Y. Xia, K. Croman, E. Shi, and D. Song, “The honey badger of BFT protocols,” in ACM SIGSAC Conference

on Computer and Communications Security, pp. 31–42. 2016.

[22] B. Guo, Z. Lu, Q. Tang, J. Xu, and Z. Zhang, “Dumbo: Faster asynchronous bft protocols,” in ACM SIGSAC Conf.

Computer and Communications Security, pp. 803–818. 2020.

[23] G. Wang, Z. J. Shi, M. Nixon, and S. Han, “Sok: Sharding on blockchain,” Proceedings of the 1st ACM Conference on

Advances in Financial Technologies, pp. 41–61, 2019.

[24] L. Luu, V. Narayanan, C. Zheng, K. Baweja, S. Gilbert, and P. Saxena, “A secure sharding protocol for open blockchains,”

ACM SIGSAC Conference on Computer and Communications Security, pp. 17–30, 2016.

[25] E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly, E. Syta, and B. Ford, “Omniledger: A secure, scale-out, decentralized

ledger via sharding,” IEEE Symposium on Security and Privacy (SP), pp. 583–598, 2018.

[26] M. Zamani, M. Movahedi, and M. Raykova, “Rapidchain: Scaling blockchain via full sharding,” ACM SIGSAC Conference

on Computer and Communications Security, pp. 931–948, 2018.

[27] S. Duan, M. K. Reiter, and H. Zhang, “BEAT: Asynchronous BFT made practical,” in ACM SIGSAC Conference on

Computer and Communications Security, pp. 2028–2041, 2018.

[28] C. Cachin, K. Kursawe, F. Petzold and V. Shoup, “Secure and efﬁcient asynchronous broadcast protocols,” in Annu. Int.

Cryptology Conference, pp. 524–541, 2001.

[29] S. Li, M. Yu, C.-S. Yang, A. S. Avestimehr, S. Kannan, and P. Viswanath, “Polyshard: Coded sharding achieves linearly
scaling efﬁciency and security simultaneously,” IEEE Transactions on Information Forensics and Security, vol. 16, pp. 249–
261, 2020.

[30] Q. Yu, S. Li, N. Raviv, S. M. M. Kalan, M. Soltanolkotabi, and S. A. Avestimehr, “Lagrange coded computing: Optimal
design for resiliency, security, and privacy,” in International Conference on Artiﬁcial Intelligence and Statistics, pp. 1215–
1225, 2019.

[31] C. Cachin and S. Tessaro, “Asynchronous veriﬁable information dispersal,” in 24th IEEE Symposium on Reliable

Distributed Systems (SRDS), pp. 191–201, 2005.

[32] J. Hendricks, G.R. Ganger, and M. K. Reiter, “Verifying distributed erasure-coded data,” Proceedings of ACM symposium

on Principles of distributed computing, pp. 139–146, 2007.

[33] S. Micali, M. Rabin, and S. Vadhan, “Veriﬁable random functions,” in 40th Annual Symposium on Foundations of Computer

Science, pp. 120–130, 1999.

[34] A. Boldyreva, “Threshold signatures, multisignatures and blind signatures based on the gap-Difﬁe-Hellman-group signature

scheme,”, in International Workshop on Public Key Cryptography, pp. 31–46, 2003.

[35] J. Ding and A. Petzoldt, “Current state of multivariate cryptography,” IEEE Security & Privacy, vol. 15, no. 4, pp. 28–36,

2017.

[36] A. Kipnis, J. Patarin, and L. Goubin, “Unbalanced oil and vinegar signature schemes,” in Int. Conf. Theory and Applications

of Cryptographic Techniques, pp. 206–222, 1999.

[37] A. Petzoldt, M.-S. Chen, B.-Y. Yang, C. Tao, and J. Ding, “Design Principles for HFEv- Based Multivariate Signature
Schemes,” International Conference on the Theory and Application of Cryptology and Information Security, pp. 311–334,
2015.

[38] J. Ding and D. Schmidt, “Rainbow, a new multivariable polynomial signature scheme,” Int. Conf. Applied Cryptography

and Network Security, pp. 164–175, 2005.

[39] A. Gervais, G.O. Karame, K. W¨ust, V. Glykantzis, H. Ritzdorf, and S. ˇCapkun, “On the security and performance of
proof of work blockchains,” ACM SIGSAC Conference on Computer and Communications Security, pp. 3–16, 2016.
[40] B. Applebaum, N. Haramaty-Krasne, Y.I shai, E. Kushilevitz, and V. Vaikuntanathan, “Low-complexity cryptographic

hash functions,” Innovations in Theoretical Computer Science Conference (ITCS), 2017.

[41] J-P. Aumasson and W. Meier, “Analysis of multivariate hash functions” in International Conference on Information

Security and Cryptology, pp. 309–323, 2007.

[42] J. Ding and B.-Y. Yang, “Multivariates polynomials for hashing,” in International Conference on Information Security

and Cryptology, pp. 358–371, 2007.

[43] M. O. Rabin, “Efﬁcient dispersal of information for security, load balancing, and fault tolerance,” Journal of the ACM

(JACM) 36, no. 2, pp. 335–348, 1989.

[44] M. O. Rabin, “Fingerprinting by random polynomials,“ Technical report, 1981.
[45] M. Bellare and P. Rogaway, “Random oracles are practical: A paradigm for designing efﬁcient protocols,” in Proceedings

of the 1st ACM Conference on Computer and Communications Security, pp. 62–73,1993.

[46] V. Bagaria, S. Kannan, D. Tse, G. Fanti, and P. Viswanath, “Prism: Deconstructing the blockchain to approach physical

19

limits”, in ACM SIGSAC Conference on Computer and Communications Security, pp. 585–602, 2019.

[47] M. Al-Bassam, A. Sonnino, V. Buterin, and I. Khofﬁ, “Fraud and data availability proofs: Detecting invalid blocks in

light clients,” in International Conference on Financial Cryptography and Data Security, pp. 279–298, 2021.

[48] M. Yu, S. Sahraei, S. Li, S. Avestimehr, S. Kannan, and S. Viswanath, “Coded merkle tree: Solving data availability
attacks in blockchains,” in International Conference on Financial Cryptography and Data Security, pp. 114–134, 2020.
[49] C. Dwork, N. A. Lynch, and L. J. Stockmeyer, ”Consensus in the presence of partial synchrony,“ Journal of the ACM,

vol. 35, no. 2, pp. 288–323, 1988.

[50] M. J. Fischer, N. A. Lynch, and M. S. Paterson, “Impossibility of distributed consensus with one faulty process,” Journal

of the ACM, vol. 32, no. 2, pp. 374–382, 1985.

[51] S. Dutta, V. Cadambe, and P. Grover, “Short-dot: Computing large linear transforms distributedly using coded short dot

products,” Advances In Neural Information Processing Systems, 2016.

[52] Q. Yu, M. Maddah-Ali, and S. Avestimehr, “Polynomial codes: an optimal design for high-dimensional coded matrix

multiplication,” Advances in Neural Information Processing Systems, 2017.

[53] R. Tandon, Q. Lei, A. G. Dimakis, and N. Karampatziakis, “Gradient coding: Avoiding stragglers in distributed learning,”

in Proc. 34th Int. Conf. Mach. Learn. (ICML), Aug. 2017, pp. 3368-–3376.

[54] N. Raviv, I. Tamo, R. Tandon, A. G. Dimakis, “Gradient coding from cyclic MDS codes and expander graphs,” IEEE

Transactions on Information Theory, vol. 66, no. 12, pp. 7475–7489, 2020.

[55] A. B. Das and A. Ramamoorthy, “Coded sparse matrix computation schemes that leverage partial stragglers,” IEEE

Transactions on Information Theory, 2022.

[56] C.-S. Yang, R. Pedarsani, and A. S. Avestimehr, “Timely coded computing,” in IEEE International Symposium on

Information Theory (ISIT), pp. 2798–2802, 2019.

[57] N. Woolsey, R.-R. Chen, and M. Ji, “Cascaded coded distributed computing on heterogeneous networks,” in IEEE

International Symposium on Information Theory (ISIT), pp. 2644–2648, 2019.

[58] S. Li, S. Sahraei, M. Yu, S. Avestimehr, S. Kannan, and P. Viswanath, “Coded State Machine–Scaling State Machine
Execution under Byzantine Faults,” in Proceedings of the 2019 ACM Symposium on Principles of Distributed Computing,
pp. 150–152, 2019.

20

