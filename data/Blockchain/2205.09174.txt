2
2
0
2

g
u
A
1
1

]

C
D
.
s
c
[

3
v
4
7
1
9
0
.
5
0
2
2
:
v
i
X
r
a

Cordial Miners: Blocklace-Based Ordering Consensus Protocols
for Every Eventuality

Idit Keidar
Technion

Oded Naor
Technion

Ehud Shapiro
Weizmann Institute of Science and
Columbia University

ABSTRACT
Cordial Miners are a family of efficient Byzantine Atomic Broad-
cast protocols, with instances for asynchrony and eventual syn-
chrony. Their efficiency‚Äîalmost half the latency of state-of-the-art
DAG-based protocols‚Äîstems from not using reliable broadcast as a
building block. Rather, Cordial Miners use the blocklace‚Äîa partially-
ordered generalization of the totally-ordered blockchain‚Äîfor all
algorithmic tasks required for ordering consensus: Dissemination,
equivocation-exclusion, and ordering.

1 INTRODUCTION
1.1 Overview and Related Work
The problem of reaching consensus on the ordering of acts by par-
ticipants in a distributed system has been investigated for four
decades [38], with efforts in the last decade falling into two cate-
gories: Permissioned, where the set of participants is determined
by some authority, and permissionless, where anyone may join and
participate provided that they pass some ‚Äòsybil-proof‚Äô test, notably
proof-of-work [34] or proof-of-stake [29]. Two leaders-of-the-pack
in the permissioned category are the State-Machine-Replication
protocol (SMR, consensus on an ordering of proposals) for the
eventual-synchrony model ‚Äì Hotstuff [42] and its extensions and
variations [13], and the Byzantine Atomic Broadcast protocol (BAB,
consensus on an ordering of all proposals made by correct par-
ticipants) for the asynchronous model ‚Äì DAG-Rider [28] and its
extensions and variations [25]. Since the emergence of Bitcoin [34],
followed by Ethereum with its support for smart contracts [8],
permissionless consensus protocols have received the spotlight.

Recent conceptual and computational advances, notably stake-
based sampling, have allowed permissioned consensus protocols to
join the cryptocurrency fray (e.g. Cardano [29] and Algorand [24]),
offering much greater efficiency and throughput compared to proof-
of-work protocols. According to this approach, in every epoch
(which could be measured in minutes or weeks) a new set of miners
is chosen in a random auction, where the probability of being
an auction winner is correlated with the stake bid by the miner.
Mechanism design ensures that miners benefit from performing
the protocol well, benefit less if they perform the protocol less well,
and lose their stake if they subvert the protocol.

With this in mind, the expectation is that miners will do their
best, not their worst, to execute the protocol, and hence the focus
of analyses of permissioned consensus protocols has shifted from
worst-case complexity to good-case complexity [1, 25], where miners
are generally expected to behave as well as they can, given compute
and network limitations, as opposed to as bad as they can. Still,
standard protections against a malicious adversary are needed,
for example to prevent a double-spending, a hostile takeover, or

1

a meltdown of the cryptocurrency supported by the consensus
protocol.

The use of a DAG-like structure to solve consensus has been
introduced in previous works, especially in asynchronous net-
works [33]. Hashgraph [3] builds an unstructured DAG, with each
block containing two references to previous blocks, and on top of
the DAG the miners run an inefficient binary agreement protocol.
This leads to expected exponential time complexity. Aleph [23]
builds a structured round-based DAG, where miners proceed to
the next round once they receive 2ùëì + 1 DAG nodes from other
miners in the same round. On top of the DAG construction protocol
a binary agreement protocol decides on the order of vertices to
commit. Nodes in the DAG are reliably broadcast. Blockmania [15]
uses a variant of PBFT [11] in the eventual synchrony model.

DAG-Rider [28] is a BAB protocol for the asynchronous model. It
assumes an adaptive adversary that controls the finite delay of mes-
sages between any two correct miners. In DAG-Rider, the miners
jointly build a DAG of blocks, with blocks as vertices and pointers
to previously-created blocks as edges, divided into strong and weak
edges. Strong edges are used for the commit rule, and weak edges
are used to ensure fairness. The protocol employs an underlying
reliable broadcast protocol of choice, which ensures that eventually
the local DAGs of all correct miners converge and equivocation is
excluded. Each miner independently converts its local DAG to an
ordered sequence of blocks, with the use of threshold signatures
to implement a global coin that retrospectively chooses one of the
miners as the leader for each round. The decision rule for delivering
a block is if the vertex created by the leader is observed by at least
2ùëì + 1 miners three rounds after it is created. The DAG is divided
into waves, each consisting of the nodes of four rounds. When a
wave ends, miners locally check whether a decision rule is met, sim-
ilar to our protocol. DAG-Rider has an expected amortized linear
message complexity, and expected constant latency. Tusk [16] is an
implementation based on DAG-Rider. Bullshark [25] is the current
state-of-the-art dual consensus protocol based on DAG-Rider that
offers a fast-track to commit nodes every two rounds in case the
network is synchronous. Other DAG-based consensus protocols
include [12, 20, 36, 40].

HotStuff [42] is an SMR protocol designed for the eventual syn-
chrony model. The protocol employs all-to-leader, leader-to-all
communication: In each round, a deterministically-chosen desig-
nated leader proposes a block to all and collects from all signatures
on the block. Once the leader has 2ùëì + 1 signatures, it can combine
them into a threshold signature [4] which it sends back to all. The
decision rule for delivering a block is three consecutive correct
leaders. This leads to a linear message complexity and constant
latency in the good case. The protocol delivers a block if there are
three correct leaders in a row, which is guaranteed to happen after

 
 
 
 
 
 
Latency

Protocol

Cordial Miners
Bullshark [25];
DAG-Rider [28] for Asynchrony

Eventual Synchrony
Good
2
4
8

Expected
4.5
9
18

Asynchrony

Good
5
8
16

Expected
7.5
12
24

Message
complexity

amortized ùëÇ (ùëõ2)
amortized ùëÇ (ùëõ2)
amortized ùëÇ (ùëõ)

Table 1: Performance summary. Latency is measured in the number of communication rounds to finalize a correct leader block,
which in turn orders the blocks till the previous final leader. The Cordial Miners protocols have better latency than Bullshark
and DAG-Rider in both protocols and in both the good case and the expected case. Note that each formal round of Bullshark
and DAG-Rider employs reliable broadcast [5], which requires at least two rounds of communication of simple messages [1]
(ùëÇ (ùëõ2) amortized message complexity), or four round with erasure coding [18] (ùëÇ (ùëõ) amortized message complexity).

GST. HotStuff is based on Tendermint [7] and is also the core of sev-
eral other consensus protocols [14, 22, 27, 41]. In this model, there
are number of leader-based protocols such as DLS [21], PBFT [11],
Zyzzyva [30], and SBFT [26].

It is within this context that we introduce Cordial Miners ‚Äì a
family of simple, efficient, self-contained Byzantine Atomic Broad-
cast [9] protocols, and present two of its instances: Retrospective
random leader selection for the asynchronous model and determin-
istic leader selection for the eventual synchrony model (See Table
1 for their performance).

In a Cordial Miners protocol, correct miners cooperatively create
and share a blocklace, each contributing its own cryptographically-
signed blocks, with each new block observing all the blocks pre-
viously received or created by the miner. In addition, each miner
incrementally coverts its local blocklace into an ordered sequence
of blocks, which is the output of the protocol. We believe that the
simplicity-cum-efficiency of the Cordial Miners protocols stems
from the use of the blocklace data structure and its analysis for all
key algorithmic tasks (the following refers to correct miners):

(1) The Blocklace [37] is a partially-ordered generalization of the

totally-ordered blockchain (Def. 3.1), that consists of cryptographically-
signed blocks, each containing a payload and a finite number of
cryptographic hash pointers to previous blocks. The blocklace
induces a DAG, as cryptographic hash pointers cannot form
cycles by a compute-bound adversary. The DAG induces a par-
tial order ‚âª (Def. 3.3) on the blocks that includes Lamport‚Äôs
‚Äòhappened-before‚Äô causality relation [31] among correct min-
ers. The globally-shared blocklace is constructed incrementally
and cooperatively by all miners, who cordially disseminate it
to each other. In a run of a Cordial Miners protocol, the local
blocklaces of correct miners all converge to the same shared
global blocklace (Proposition 5.4), referred to as the blocklace
of the run.

(2) Ordering: The ordering algorithm (Algorithm 2) is used locally
by each miner to topologically-sort its local blocklace into a
totally-ordered output sequence of blocks, excluding equivoca-
tion along the way. This conversion is monotonic (Prop. 4.3)
‚Äì the output sequence is extended as the miner learns of or
produces ever-larger portions of the global blocklace, and in
this sense every output block of each miner is final. We say
that two sequences are consistent if one is a prefix of the other
(Def. 2.2), a notion stronger than the common prefix property
of Ouroboros [29]. We assume that less than one-third of the

2

miners are faulty, and prove that the following holds for the
correct miners of the Cordial Miners protocols (Theorem 5.1):
‚Ä¢ Safety: Outputs of correct miners are consistent.
‚Ä¢ Liveness: A block sent by a correct miner is eventually out-

put by every correct miner.

(3) Dissemination: Any new block created by a miner ùëù observes
blocks known to ùëù by including pointers to the tips (DAG
sources) of ùëù‚Äôs local blocklace. Correspondingly, a miner ùëù will
buffer, rather than include in its blocklace, any received block
with dangling pointers ‚Äì pointers to blocks not known to ùëù.
Hence, a block ùëè by a correct miner ùëù informs its recipients
of blocks not known to ùëù at the time of ùëè‚Äôs creation. Thus ùëù,
being cordial, when sending to ùëû a new ùëù-block, will include
with it blocks ùëù knows but, to the best of ùëù‚Äôs knowledge, are
not yet known to ùëû and have not already been sent to ùëû by ùëù,
thus ensuring block dissemination (Prop. 5.4).

(4) Equivocation exclusion: An equivocation (Def. 3.4) is a pair
of blocks by the same miner that are not causally-related ‚Äì have
no path of pointers from one to the other; a miner that creates
an equivocation is an equivocator and is considered faulty. A
key observation is that a miner cannot approve (Def. 3.5) both
blocks of an equivocation without being itself an equivocator
(Ob. 2). Hence, if less than one-third of the miners are equivo-
cators, then no equivocation will ever receive an approval from
blocks created by a supermajority (at least two-thirds) of the
miners. That‚Äôs how blocklace-based is the basis of equivocation-
exclusion by the blocklace: A miner finalizes a block ùëè once its
local blocklace includes blocks that approve ùëè by a supermajor-
ity (Algorithm 2).

(5) Cordial Miners: The depth, or round, of a block ùëè is the max-
imal length of any path emanating from ùëè (Def. 3.1). A round
is a set of blocks of the same depth. Miners are cordial in two
respects. First, as explained above, in informing other miners
of blocks they believe the other miner lacks. Second, awaiting
a supermajority of round ùëë before producing a block of round
ùëë + 1 (Def. 3.14).

(6) Leader Selection: The Cordial Miners protocol for the eventual
synchrony model employs prospective leader selection (e.g.
via a shared pseudorandom function). In the asynchronous
model, the adversary has complete control over the order of
message delivery, indefinitely. The panacea to such an adversary,
employed for example by DAG-Rider [28], is to use a shared
random coin [10] and elect the leader retrospectively.

(7) Ratified and Super-Ratified Leaders: A block ùëè is ratified
by block ùëè ‚Ä≤ if [ùëè ‚Ä≤] includes a cordial and non-equivocating
supermajority that approves ùëè. A block ùëè ‚àà ùêµ is super-ratified in
blocklace ùêµ if there is a supermajority of blocks in ùêµ that ratify
ùëè (Def.3.10). Given a wavelength (ùë§ = 2 for eventual synchrony
and ùë§ = 5 for asynchrony), a leader block ùëè is final in blocklace
ùêµ if the depth(ùëè) + ùë§ prefix of ùêµ super-ratifies ùëè (Def. 3.10 and
Fig. 1).

(8) Blocklace Ordering with ùúè and Finality: We assume a topo-
logical sort procedure that takes a blocklace as an input and
produces a sequence of its blocks while respecting their causal
partial order ‚âª and excluding equivocations along the way.
With it, an ordering function ùúè that converts a partially-ordered
blocklace ùêµ to a totally-ordered output sequence is defined (Def.
4.1). The function ùúè, applied to a blocklace ùêµ, seeks the highest-
depth final leader block ùëè ‚àà ùêµ and produced an ordering of [ùëè].
It has the property that if [ùëè] includes another final leader block
ùëè ‚Ä≤, then ùúè (ùëè ‚Ä≤) is a prefix of ùúè (ùëè). Hence, it is safe to compute ùúè
starting from any blocklace, and as the blocklace extends and
includes a new final leader block, then the output sequence
produced by ùúè would only extend the one computed already.
Hence any output of ùúè is final.

(9) Exclusion of faulty miners: Any faulty ùëù-block known to
some correct miner will eventually be known to all, resulting in
correct miners suspending any further communication with ùëù.
For example, any miner can easily verify whether another miner
ùëù is cordial in the second sense by examining the blocklace. In
addition, an equivocation by ùëù, with each block of the pair
known to a different correct miner, will eventually be known
to all and result in the exclusion of ùëù.

Miners accomplish all the above by simple and efficient analyses of
their local blocklace.

The reset of the paper is organized by the following Sections:

2. Provides an overview of the two models explored‚Äîasynchrony
and eventual synchrony‚Äîthe Byzantine Atomic Broadcast prob-
lem we aim to solve with the Cordial Miners protocols in the two
models, the safety and liveness requirements any solution must
satisfy, and the outline of the proof of safety and liveness of the
Cordial Miners protocols.

3. Introduces the notions of blocklace safety and liveness. The Block-
lace was introduced in reference [37], and its preliminaries are
reproduced in Section 3.1.

4. Introduces the blocklace ordering function ùúè, which is param-
eterized by the notion of final leader, and the requirements on
a blocklace for the safety and liveness of ùúè. It then provides
sufficient conditions for a blocklace-based ordering consensus
protocol to produce a blocklace that satisfies these requirements.
5. Introduces the Cordial Miners protocols and argue their safety

and liveness.

6. Discusses performance analysis, future optimizations and future

Cordial Miners protocols.

7. Concludes the paper.

2 MODELS, PROBLEM, SAFETY AND

LIVENESS

We assume ùëõ ‚â• 3 miners (aka agents, processors) Œ†, of which at
most ùëì < ùëõ/3 may be faulty (act under the control of the adversary,
be ‚ÄòByzantine‚Äô), each equipped with a single and unique crypto-
graphic key-pair, with a public key known to others. Miners can
create, sign, and send messages to each other, where any message
sent from one correct miner to another is eventually received. In ad-
dition, each miner can sequentially output (aka ‚Äòdeliver‚Äô) messages
(e.g., to a local output device or storage device).

Definition 2.1. We consider two models of distributed computing

with an adversary:

(1) Asynchrony [6], in which an adversary controls up to ùëì

faulty miners and the finite delay of every message.

(2) Eventual Synchrony [21]: In addition, there is a point in
time, known as the global stabilization time (GST), beyond
which message delay among correct miners does not exceed
a known bound Œî.

Next we define the problem we aim to solve in this paper:

Definition 2.2 (Prefix, ‚™Ø, Consistent Sequences). A sequence ùë• is
a prefix of a sequence ùë• ‚Ä≤, ùë• ‚™Ø ùë• ‚Ä≤, if ùë• ‚Ä≤ can be obtained from ùë• by
appending to it zero or more elements. Two sequences ùë•, ùë• ‚Ä≤ are
consistent if ùë• ‚™Ø ùë• ‚Ä≤ or ùë• ‚Ä≤ ‚™Ø ùë•.

Definition 2.3 (Safety and Liveness of an Ordering Consensus Pro-

tocol). An ordering consensus protocol is:

Safe if outputs of correct miners are consistent.
Live if a message sent by a correct miner is eventually output
by every correct miner with probability 1.

Problem: Devise safe and live ordering consensus pro-
tocols for the models of distributed computing with an
adversary.

We note that safety and liveness, combined with message unique-
ness (e.g., a block in a blocklace, see next), imply the standard
Byzantine Atomic Broadcast guarantees: Agreement, Integrity, Va-
lidity, and Total Order [5, 28]. Hence, the blocklace-based Cordial
Miners protocols that address the problem are in fact protocols for
Byzantine Atomic Broadcast [9].

3 THE BLOCKLACE
A blocklace [37] is a partially-ordered generalization of the totally-
ordered blockchain: In a blocklace, each block may contain a finite
set of cryptographic hash pointers to previous blocks, in contrast
to one pointer (or zero for the initial/genesis block) in a blockchain.
Next we present the basic definitions and results from [37]. Please
consult the original reference for explanations and proofs. Blocklace
utilities that realize these notions are presented in Algorithm 1.
These are followed by definitions and results needed for establishing
the safety and liveness of blocklace-based consensus protocols.

3.1 Blocklace Basics
In addition to the set of miners Œ†, we assume a given set of payloads
A and a cryptographic hash function hash.

3

Definition 3.1 (Block, Acknowledge). A block over Œ†, A and hash
is a triple ùëè = (ùëù, ùëé, ùêª ), referred to as a ùëù-block, ùëù ‚àà Œ†, with ùëé ‚àà A
being the payload of ùëè, and ùêª is a finite set of hash pointers to
blocks, namely for each ‚Ñé ‚àà ùêª , ‚Ñé = hash(ùëè ‚Ä≤) for some block ùëè ‚Ä≤ in
which case we also say that ùëè acknowledges ùëè ‚Ä≤. If ùêª = ‚àÖ then ùëè is
initial.

In a concrete implementation, a ùëù-block is encoded by a string
signed by ùëù. Note that hash being cryptographic implies that a set
of blocks that form a cycle cannot be effectively computed. A set of
blocks ùêµ induces a finite-degree directed graph (ùêµ, ùê∏), ùê∏ ‚äÇ ùêµ √ó ùêµ,
with blocks ùêµ as vertices and directed edges (ùëè, ùëè ‚Ä≤) ‚àà ùê∏ if ùëè ‚àà ùêµ
includes a hash pointer to ùëè ‚Ä≤ ‚àà ùêµ. We overload ùêµ to also mean its
induced directed graph (ùêµ, ùê∏).

Definition 3.2 (Blocklace). Let B be the maximal set of blocks
over Œ†, A and hash for which the induced directed graph (B, E) is
acyclic. A blocklace over A is a set of blocks ùêµ ‚äÜ B.

Note that the directed graph induced by a blocklace ùêµ ‚äÇ B is
acyclic. The two key blocklace notions used in our protocols are
observation and approval.

Definition 3.3 (‚âª, Observe). The strict partial order ‚âª is defined
by ùëè ‚Ä≤ ‚âª ùëè if there is a nonempty path from ùëè ‚Ä≤ to ùëè. A block ùëè ‚Ä≤
observes ùëè if ùëè ‚Ä≤ ‚™∞ ùëè. Miner ùëù observes ùëè in ùêµ if there is a ùëù-block
ùëè ‚Ä≤ ‚àà ùêµ that observes ùëè, and a group of miners ùëÑ ‚äÜ Œ† observes ùëè
in ùêµ if every miner ùëù ‚àà ùëÑ observes ùëè.

We note that ‚Äòobserve‚Äô is the transitive closure of ‚Äòacknowledge‚Äô.
With this, we can define the basic notion of equivocation (which
may result in double-spending when payloads are conflicting finan-
cial transactions). See Figure 1.A.

Definition 3.4 (Equivocation, Equivocator). A pair of ùëù-blocks
ùëè ‚â† ùëè ‚Ä≤ ‚àà B, ùëù ‚àà Œ†, form an equivocation by ùëù if they are not
consistent wrt ‚âª, namely ùëè ‚Ä≤ ‚äÅ ùëè and ùëè ‚äÅ ùëè ‚Ä≤. A miner ùëù is an
equivocator in ùêµ, equivocator(ùëù, ùêµ), if ùêµ has an equivocation by
ùëù.

Namely, a pair of ùëù-blocks form an equivocation of ùëù if neither
observes the other. As any ùëù-block is cryptographically signed by
ùëù, an equivocation by ùëù is a volitional fault of ùëù.

Definition 3.5 (Approval). Given blocks ùëè, ùëè ‚Ä≤ ‚àà B, the block ùëè
approves ùëè ‚Ä≤ if ùëè observes ùëè ‚Ä≤ and does not observe any block ùëè ‚Ä≤‚Ä≤ that
together with ùëè ‚Ä≤ forms an equivocation. A miner ùëù ‚àà Œ† approves
ùëè ‚Ä≤ in ùêµ if there is a ùëù-block ùëè ‚àà ùêµ that approves ùëè ‚Ä≤, in which case we
also say that ùëù approves ùëè ‚Ä≤ in ùêµ. A set of miners ùëÑ ‚äÜ Œ† approve
ùëè ‚Ä≤ in ùêµ if every miner ùëù ‚àà ùëÑ approves ùëè ‚Ä≤ in ùêµ.

Observation 1. Approval is monotonic wrt ‚äÉ.

Namely, if miner ùëù approves ùëè in ùêµ it also approves ùëè in ùêµ‚Ä≤ ‚äÉ ùêµ.
A key observation is that a miner cannot approve an equivocation
of another miner in a blocklace ùêµ without being an equivocator in
ùêµ itself (Fig. 1.A):

Observation 2. [Approving an Equivocation] If miner ùëù ‚àà Œ† ap-
proves an equivocation ùëè1, ùëè2 in a blocklace ùêµ ‚äÜ B, then ùëù is an
equivocator in ùêµ.

4

Definition 3.6 (Closure, Closed, Tip). The closure of ùëè ‚àà B wrt
‚âª is the set [ùëè] := {ùëè ‚Ä≤ ‚àà B : ùëè ‚™∞ ùëè ‚Ä≤}. The closure of ùêµ ‚äÇ B wrt ‚âª
is the set [ùêµ] := (cid:208)ùëè ‚ààùêµ [ùëè]. A blocklace ùêµ ‚äÜ B is closed if ùêµ = [ùêµ].
A block ùëè ‚àà B is a tip of ùêµ if [ùëè] = [ùêµ] ‚à™ {ùëè}.

Note that a blocklace ùêµ is closed iff its blocks to not contain

‚Äòdangling pointers‚Äô to blocks not in ùêµ.

Definition 3.7 (Block Depth/Round, Blocklace Prefix & Suffix). The
depth (or round) of a block ùëè ‚àà B, depth(ùëè), is the maximal length
of any path of pointers emanating from ùëè. For a blocklace ùêµ ‚äÜ B and
ùëë ‚â• 0, the depth-ùëë prefix of ùêµ is ùêµ(ùëë) := {ùëè ‚àà ùêµ : depth(ùëè) ‚â§ ùëë },
and the depth-ùëë suffix of ùêµ is ¬Øùêµ(ùëë) := ùêµ \ ùêµ(ùëë)

3.2 Blocklace Safety
As equivocation is a fault, at most ùëì miners may equivocate.

Definition 3.8 (Supermajority). A set of miners ùëÉ ‚äÇ Œ† is a super-
majority if |ùëÉ | > ùëõ+ùëì
. A set of blocks ùêµ is a supermajority if the
set of miners ùëÉ = {ùëù ‚àà Œ† : ùëè ‚àà ùêµ is a ùëù-block} is a supermajority.

2

Note that a supermajority is defined to be large enough to nec-
essarily include a majority of the correct miners. Also note that if a
faulty miner is exposed and repelled by the correct miners, such
a step effectively deducts 1 from both ùëõ and ùëì , causing the super-
majority to decrease, reaching simple majority when all ùëì faulty
miners are exposed and repelled, namely ùëì = 0. As the Cordial
Miners protocol does expose and repel faulty miners, the notion
of supermajority is preferred over the standard formulas of ùëõ ‚àí ùëì
or 2ùëì + 1, as they converge to all or none, respectively, rather than
to majority when exposed faulty miners are deducted from both ùëì
and ùëõ.

Lemma 3.9 (No Supermajority Approval for Eqivocation).
If there are at most ùëì equivocators in a blocklace ùêµ ‚äÇ B with an equiv-
ocation ùëè, ùëè ‚Ä≤ ‚àà ùêµ, then not both ùëè, ùëè ‚Ä≤ have supermajority approval in
ùêµ.

Next, we introduce the notions of ratification (Figure 1.B) and
super-ratification (Figure 1.C), which is the blocklace algebraic
counterpart of the conditions for ‚Äòcommit & terminate‚Äô of Byzantine
reliable broadcast protocols [1].

Definition 3.10 (Ratified and Super-Ratified Block). A block ùëè ‚àà B
is ratified by block ùëè ‚Ä≤ if [ùëè ‚Ä≤] includes a supermajority of blocks
that approve ùëè. It is super-ratified in blocklace ùêµ ‚äÇ B if ùêµ includes
a supermajority of blocks, each of which ratifies ùëè.

Definition 3.11 (Wavelength, Leader Selection Function, Leader
Block). Given a wavelength ùë§ ‚â• 1, a leader selection function
is a partial function ùëô : N ‚Ü¶‚Üí Œ† satisfying ùëô (ùëü ) ‚àà ùëÉ if ùëü mod ùë§ = 0
else ùëô (ùëü ) = ‚ä•. A ùëù-block ùëè is a leader block if ùëô (depth(ùëè)) = ùëù.

Note that an equivocating leader can have several leader blocks
in the same round. In the following we assume given wavelength
ùë§ ‚â• 1 and a leader selection function ùëô. The following definition
has two cases: The first applies to retrospective leader selection,
employed by the Cordial Miners protocol for asynchrony using a
shared coin; the second to prospective leader selection, employed
by the Cordial Miners protocol for eventual synchrony. See Figure
1.B.

Figure 1: Observation, Equivocation, Approval, Ratification, Super-Ratification: (A) Observing an Equivocation: The ‚Äòdrop
shape‚Äô depicts a blocklace with a block at the tip of the drop that observes all the blocks inside the drop. Initial blocks are
at the bottom, and inclusion among two drops implies ‚âª among their tips. Assume ùëè1, ùëè2 are an equivocation (Def. 3.4) by the
red miner. According to the figure, the green block approves ùëè2 (Def. 3.5) since it observes ùëè2 (Def. 3.3) and does not observe
any conflicting red block, in particular it does not observe ùëè1. However, since the purple block observes the red green block,
it observes both ùëè1 and ùëè2 and hence does not approve the equivocating ùëè1 (nor ùëè2). (B) Ratified: The blue block (blue dot) is
ratified by the red block (red dot), since the red block observes a supermajority (thick green horizontal line) that approves
the blue block. (C) Super-Ratified: The blue block is super-ratified by the red supermajority (thick red horizontal line), each
member of which ratifies the blue block by observing a green supermajority (possibly a different one for each member of the
red supermajority) that approves the blue block. A leader is final if super-ratified within a protocol-specific wave (number of
rounds).

Algorithm 1 Cordial Miners: Blocklace Utilities
pseudocode for miner ùëù ‚àà Œ†

Local variables:
struct block ùëè:

ùëè.creator ‚Äì the miner that created ùëè
ùëè.payload ‚Äì a set of transactions
ùëè.pointers ‚Äì a possibly-empty set of hash pointers to other blocks

new ùëè
ùëè.payload ‚Üê payload()
ùëè.creator ‚Üê ùëù
ùëè.pointers ‚Üê ‚Ñéùëéùë†‚Ñé (ùë°ùëñùëùùë†), where tips are the tips of blocklace_prefix (ùëë)
blocklace ‚Üê blocklace ‚à™ {ùëè }
output_blocks()
return ùëè

blocklace ‚Üê { }
1: procedure create_block(ùëë)
2:
3:
4:
5:
6:
7:
8:
9: procedure hash(ùëè) return collision-free cryptographic hash pointer to block ùëè
10: procedure ùëè ‚™∞ ùëè‚Ä≤
11:

return ‚àÉùëè1, ùëè2, . . . , ùëèùëò ‚àà blocklace, ùëò ‚â• 1, s.t. ùëè1 = ùëè, ùëèùëò = ùëè‚Ä≤ and ‚àÄùëñ ‚àà [ùëò ‚àí 1] : hash(ùëèùëñ+1) ‚àà ùëèùëñ .pointers

‚ä≤ Also referred to as [ùëè ]. ùëè could also be any subset of blocklace.

12: procedure closure(ùëè) return {ùëè‚Ä≤ ‚àà blocklace : ùëè ‚™∞ ùëè‚Ä≤ }
13: procedure equivocation(ùëè1, ùëè2) return ùëè1.creator = ùëè2.creator ‚àß ùëè1 ‚™∞Ã∏ ùëè2 ‚àß ùëè2 ‚™∞Ã∏ ùëè1
14: procedure equivocator(ùëû, ùëè) return ‚àÉùëè1, ùëè2 ‚àà [ùëè ] ‚àß ùëè1.creator = ùëè2.creator = ùëû ‚àß equivocation(ùëè1, ùëè2)
15: procedure approves(ùëè, ùëè1) return ùëè ‚™∞ ùëè1 ‚àß (ùëè ‚™∞ ùëè2 =‚áí ¬¨equivocation(ùëè1, ùëè2))
16: procedure ratifies(ùëè1, ùëè2) return {ùëè.creator : ùëè1 ‚™∞ ùëè ‚àß approves(ùëè, ùëè2) } is a supermajority
17: procedure depth(ùëè) return max {ùëò : ‚àÉùëè‚Ä≤ ‚àà blocklace with a path from ùëè to ùëè‚Ä≤ of length ùëò}.
18: procedure blocklace_prefix(ùëë) return {ùëè ‚àà blocklace : depth(ùëè) ‚â§ ùëë }

5

‚ä≤ The structure of a block ùëè in a blocklace, Def. 3.1

‚ä≤ The local blocklace of miner ùëù
‚ä≤ Add to blocklace a new block ùëè of depth ùëë + 1
‚ä≤ Allocate a new block structure
‚ä≤ e.g., dequeue a payload from a queue of proposals (aka mempool)

‚ä≤ Def. 3.6

‚ä≤ Def. 3.3

‚ä≤ Def. 3.6

‚ä≤ Def. 3.4, Fig. 1.A

‚ä≤ Def. 3.4, Fig. 1.A

‚ä≤ Def. 3.5, Fig. 1.A

‚ä≤ Def. 3.10, Fig. 1.B

‚ä≤ Def. 3.7

‚ä≤ Def. 3.7

Figure 2: Finality of a Super-Ratified Leader (Definition 3.12): Assume that a leader block (blue dot) is super-ratified. A ratifying
supermajority is represented by a thick red line, each member of which observes a possibly-different approving supermajority
represented by a green thick line. We show that the blue leader is ratified by any subsequent cordial leader. (A) The successive
cordial leader (red dot) is part of the ratifying supermajority. (B) The successive cordial leader (purple dot) is one round follow-
ing the ratifying supermajority. Being cordial, it observes a supermajority (thick purple line) that must have an intersection
(black dot) with the ratifying supermajority, hence it observes an approving supermajority and thus ratifies the blue leader.
(C) A successive leader is more than one round following the ratifying supermajority. Being cordial, it observes a superma-
jority (thick purple line). There must be a correct miner common to the purple and red supermajority, with blocks in both
(black dots); being a correct miner, its later block observes the earlier block (black line). Hence the purple leader observes the
approving supermajority (via black lines) and hence ratifies the blue leader.

Definition 3.12 (Final Leader Block). Let ùêµ ‚äÜ B be a blocklace. A

leader block ùëè ‚àà B of round ùëü is final in ùêµ if:

(1) Retrospective: It is super-ratified in ùêµ(ùëü + ùë§ ‚àí 1), or
(2) Prospective: It is super-ratified in ùêµ(ùëü + ùë§) and the leader

block of round ùëü + ùë§ also ratifies ùëè.

The following notion of blocklace safety is the basis for the
monotonicity of the blocklace ordering function ùúè, and hence for
the safety of a protocol that uses ùúè for blocklace ordering.

Definition 3.13 (Blocklace Leader Safety). A blocklace ùêµ is leader-
safe if every final leader block in ùêµ is ratified by every subsequent
leader block in ùêµ.

Next, we identify a sufficient condition for blocklace leader

safety.

Definition 3.14 (Cordial Block, Blocklace). A block ùëè ‚àà B of round
ùëü is cordial if it acknowledges blocks by a supermajority of miners.
A blocklace ùêµ ‚äÇ B is cordial if all its blocks are cordial.

The following proposition ensures that in a cordial blocklace, a
final leader block is ratified by any subsequent leader block. See
Figure 2.

Proposition 3.15 (Cordial Blocklace Leader Safety). A cor-

dial blocklace is leader-safe.

Proof of Proposition 3.15. Let ùêµ be a cordial blocklace and
ùëè ‚àà ùêµ (blue dot) a final leader block of round ùëü in ùêµ. We have to
show ùëè is ratified by any subsequent leader block in ùêµ. We consider

in turn the two cases in Definition 3.12, and in reference to the
three cases in Figure 2. Consider the case of a prospective leader, in
which the leader of round ùëü + ùë§ is included in the ratifying super
majority:

A. The subsequent leader block ùëè ‚Ä≤ of round ùëü + ùë§ (red dot)
ratifies ùëè by definition. For a further subsequent leader block
ùëè ‚Ä≤ (purple dot) of a round ùëü ‚Ä≤ > ùëü + ùë§, there are two cases:
B. There is an overlap between the supermajority observed by
ùëè ‚Ä≤ at round ùëü ‚Ä≤ ‚àí 1 (thick purple line) and the supermajority
that ratifies ùëè (thick red line). Then there is a block ùëè ‚Ä≤‚Ä≤ (black
dot) shared by both, hence ùëè ‚Ä≤ observes ùëè ‚Ä≤‚Ä≤, which observes a
supermajority (thick green line) that approves ùëè, hence ùëè ‚Ä≤
ratifies ùëè.

C. The supermajority observed by ùëè ‚Ä≤ at round ùëü ‚Ä≤ ‚àí 1 (thick
purple line) is of a later round than the members of the su-
permajority that ratifies ùëè (thick red line). By counting, there
is a non-equivocating miner ùëù ‚àà ùëÉùëñ with a block ùëè1 in the
purple supermajority and a block ùëè2 in the red supermajor-
ity (black dots). Since ùëù is non-equivocating, ùëè1 observes ùëè2.
Hence, ùëè ‚Ä≤ observes ùëè1, which observes ùëè2, which observes
the green supermajority that approves ùëè, hence ùëè ‚Ä≤ ratifies ùëè.

For the retrospective notion of a final leader, the arguments in cases
‚ñ°
B and C above apply as is. This completes the proof.

3.3 Blocklace Liveness
The notion of blocklace leader liveness is defined thus:

6

Definition 3.16 (Blocklace Leader Liveness). A blocklace ùêµ is leader-

live if for every block ùëè ‚àà ùêµ by a miner not equivocating in ùêµ there
is a final leader block in ùêµ that observes ùëè.

Next, we discuss conditions that ensure blocklace leader liveness.
Given a blocklace, a set of miners ùëÉ is (mutually) disseminating if
every block by a miner in ùëÉ is eventually observed by every miner
in ùëÉ.

Definition 3.17 (Disseminating). Given a blocklace ùêµ ‚äÜ B, a set of
miners ùëÉ ‚äÜ Œ† is mutually disseminating in ùêµ, or disseminating
for short, if for any ùëù, ùëû ‚àà ùëÉ and any ùëù-block ùëè ‚àà ùêµ there is a ùëû-block
ùëè ‚Ä≤ ‚àà ùêµ such that ùëè ‚Ä≤ ‚âª ùëè. The blocklace ùêµ is disseminating if it has
a disseminating supermajority.

Observation 3 (Dissemination is Unbounded). If a set of miners
ùëÉ ‚äÜ Œ†, |ùëÉ | > 1, are disseminating in a blocklace ùêµ that includes a
ùëù-block, ùëù ‚àà ùëÉ, then ùêµ is infinite and any suffix of ùêµ has blocks by
every member of ùëÉ.

The following liveness condition will be proven for each Cordial

Miners protocol, thus establishing their liveness (Figure 3).

Proposition 3.18 (Blocklace Leader Liveness Condition). If
ùêµ ‚äÇ B is a cordial blocklace with a non-equivocating and dissemi-
nating supermajority of miners, such that for every ùëü > 0 there is a
final leader block of round ùëü ‚Ä≤ > ùëü , then ùêµ is leader-live.

Figure 3: Liveness Condition, Proposition 3.18

Proof of Proposition 3.18. Let ùêµ ‚äÇ B be a cordial blocklace
and ùëÉ ‚äÜ Œ† a supermajority of miners non-equivocating and dissem-
inating in ùêµ. Let ùëè be a ùëù-block by a miner ùëù ‚àà ùëÉ (blue dot in Figure
3). As ùëÉ are disseminating in ùêµ, then for every ùëû ‚àà ùëÉ there is a first
ùëû-block ùëèùëû ‚àà ùëÉ that observes ùëè; let ùëü be the maximal round of any
of these blocks (thick horizontal red line). By assumption, ùêµ has a
final leader block ÀÜùëè of round ÀÜùëü > ùëü (purple dot). As ÀÜùëè is cordial, it

7

must observe a block ùëè ‚Ä≤
ùëû of depth ÀÜùëü ‚àí 1 of a miner ùëû ‚àà ùëÉ (black dot).
As ùëû is non-equivocating, there is a (possible empty) path from ùëè ‚Ä≤
ùëû
to ùëèùëû (black path among black dots), and from there to ùëè (blue line).
Hence ÀÜùëè observes ùëè.
‚ñ°

4 BLOCKLACE ORDERING WITH ùúè: SAFETY

AND LIVENESS

Here we present a deterministic function ùúè that, given a block ùëè,
employs final leaders to topologically sort the blocklace [ùëè] into
a sequence of its blocks, respecting ‚âª. The intention is that in a
blocklace-based ordering consensus protocol, each miners would
use ùúè to locally convert their partially-ordered blocklace into the
totally-ordered output sequence of blocks.

The section concludes with Theorem 4.6, which provides suffi-
cient conditions for the safety and liveness of any blocklace-based
ordering consensus protocol that employs ùúè. In the following section
we prove that the Cordial Miners protocols, which employ Algo-
rithm 2 that realizes ùúè, satisfy these conditions, and thus establish
their safety and liveness.

We show that if ùúè is called with a sequence of super-ratified
blocks increasing wrt ‚âª then its output is monotonic wrt to the
subset relation. This monotonicity ensures finality, as it implies
that the output sequence will only extend while the local blocklace
that is the input of ùúè increases over time. With ùúè, final leaders are
the anchors of finality in the growing chain, each ‚Äòwrites history‚Äô
backwards till the preceding final leader. We use the term ‚ÄòOkazaki
fragments‚Äô for the sequences computed backwards from each leader
to its predecessor, acknowledging the analogy with the way one of
the DNA strands of a replicated DNA molecule is elongated via the
stitching of backwards-synthesized Okazaki-fragments [35].

Proposition 4.3 ensures that given a blocklace ùêµ, a super-ratified
leader ùëè in ùêµ will be ratified by any subsequent cordial leader, and
hence will always initiate an Okazaki-fragment in any execution of
ùúè with any subsequent final leader. Hence, the final sequence up to a
super-ratified leader ùëè is fully-determined by ùëè itself independently
of the (continuously changing) identity of the last super-ratified
leader. Hence the final sequence up to a super-ratified leader ùëè can
be ‚Äòcached‚Äô and will not change as the blocklace increases. Propo-
sition ensures that if ùúè is incrementally applied to a leader-live
blocklace, then any block in its input blocklace will eventually be in-
cluded in its output sequence. Together they provide the conditions
for Theorem 4.6.

The following recursive ordering function ùúè maps a blocklace
into a sequence of blocks, excluding equivocations along the way.
Formally, the entire sequence is computed backwards from the last
super-ratified leader, afresh by each application of ùúè. Practically, a
sequence up to a super-ratified leader is final (Prop. 4.3) and hence
can be cached, allowing ùúè to be computed from the new super-
ratified leader backwards through previous ratified leaders, and
to output all the blocks approved by the new leader (the approval
ensures that the new fragment does not introduce equivocations)
that are not observed by the previous final leader.

Definition 4.1 (ùúè). We assume a fixed topological sort function
xsort(ùëè, ùêµ) (exclude and sort) that takes a block ùëè and a blocklace
ùêµ, and returns a sequence consistent with ‚âª of all the blocks in ùêµ
that are approved by ùëè. The function ùúè : 2B ‚àí‚Üí B‚àó is defined for a

blocklace ùêµ ‚äÇ B backwards, from the last output element to the
first, as follows: If ùêµ has no final leaders then ùúè (ùêµ) := Œõ. Else let ùëè
be the last final leader in ùêµ. Then ùúè (ùêµ) := ùúè ‚Ä≤(ùëè), where ùúè ‚Ä≤ is defined
recursively:

ùúè ‚Ä≤(ùëè) :=

xsort(ùëè, [ùëè]) if [ùëè] has no leader ratified by ùëè, else
Ô£±Ô£¥Ô£¥Ô£¥Ô£≤
ùúè ‚Ä≤(ùëè ‚Ä≤) ¬∑ xsort(ùëè, [ùëè] \ [ùëè ‚Ä≤]) if ùëè ‚Ä≤ is the last leader
Ô£¥Ô£¥Ô£¥
Ô£≥

ratified by ùëè in [ùëè]

Note that ùúè ‚Ä≤ uses the notion of a leader ratified by another leader,

not a final leader.

A pseudo-code implementation of ùúè is presented as Algorithm
2. The Algorithm is a literal implementation of the mathematics
described above: It maintained outputBlocks that includes the prefix
of the output ùúè has already computed. Upon adding a new block to
its blocklace (line 19), it computes the most-recent final leader ùëè1
according to Definition 3.12, and applies ùúè to it, realizing the math-
ematical definition of ùúè (Def. 4.1), with the optimization, discussed
above, that a recursive call with a block that was already output is
returned. Hence the following proposition:

Proposition 4.2 (Correct implementation of ùúè). The proce-
dure ùúè in Algorithm 2 correctly implements the function ùúè in Definition
4.1.

4.1 ùúè Safety
A safe blocklace ensures a final leader is ratified by any subsequent
leader, final or not. Hence the following:

Proposition 4.3 (Monotonicity of ùúè). Let ùêµ be a cordial block-
lace with a supermajority of correct miners. Then ùúè is monotonic wrt
the superset relation among closed subsets of ùêµ, namely for any two
closed blocklaces ùêµ2 ‚äÜ ùêµ1 ‚äÜ ùêµ, ùúè (ùêµ2) ‚™Ø ùúè (ùêµ1).

Proof of Proposition 4.3. Let ùêµ, ùêµ1, ùêµ2 be blocklaces as assumed

by the Proposition. If ùêµ2 has no final leader then ùúè (ùêµ2) is the empty
sequence and the proposition holds vacuously. Let ÀÜùëè2 be the last
final leader of ùêµ2 and ÀÜùëè1 be the last final leader of ùêµ1. Note that
according to Definition4.1, ùúè (ùêµ1) calls ùúè ‚Ä≤(ÀÜùëè1) and ùúè (ùêµ2) calls ùúè ‚Ä≤(ÀÜùëè2).
Let ùëè1, ùëè2 . . . , ùëèùëò , ùëò ‚â• 2, be the sequence of ratified leaders in the
recursive calls of the execution of ùúè ‚Ä≤(ÀÜùëè1), starting with ùëè1 = ÀÜùëè1. We
argue that ÀÜùëè2 is called in this execution, namely ÀÜùëè2 = ùëè ùëó for some
ùëó ‚àà [ùëò]. Note that according to Proposition 3.15, ÀÜùëè1 = ùëè1, being
cordial, ratifies ÀÜùëè2. Let ùëó ‚àà [ùëò] be the last index for which ùëè ùëó ratifies
ÀÜùëè2. We argue by way of contradiction that ùëè ùëó+1 = ÀÜùëè2. Consider
three cases regarding the relative depths of ùëè ùëó+1 and ÀÜùëè2:

= Note that two different blocks of the same depth cannot
observe each other: If only one observes the other, it is one
deeper than the other; if both observe each other they form a
cycle, which is impossible. Since both ùëè ùëó+1 and ÀÜùëè2 are leader
blocks of the same depth, then they must be by the same
leader, and hence, being different blocks by the same miner
that do not observe each other, they form an equivocation.
By assumption, both are ratified, implying that both have
supermajority approval, contradicting the assumption that
there is a supermajority of correct miners in ùêµ.

Figure 4: The Operation of ùúè, Safety and Liveness: (A) The In-
put of ùúè: A blocklace with final leaders (large dots) and lead-
ers ratified by their successors (small dots). Each leader ob-
serves the portion of the blocklace below it (including the
lines emanating from it). (B) The Output of ùúè: A sequence
of blocks consisting of ‚ÄòOkazaki‚Äô fragments. The sequence
of fragments are computed recursively backwards, starting
from the last final leader, and back from each leader to the
previous leader it ratifies. The input to computing the frag-
ment consists of the portion of the blocklace observed by
the current leader but not observed by the previous rati-
fied leader. The output form each fragment is a sequence
of blocks computed forward by topological sort of the in-
put blocklace fragment, respecting ‚âª and using the leader
of the fragment to resolve and exclude equivocations. Final
leaders are final, hence the backwards computation start-
ing from the last purple final leader need not proceed be-
yond the recursive call to the previous red final leader, as
the output sequence up to the previous final leader has al-
ready been computed by the previous invocation of ùúè. Safety
Requirement: A final leader (large dot) is ratified by any sub-
sequent leader (large or small dot). Liveness Requirement:
Any leader will eventually have a subsequent final leader
(large dot) with probability 1. (C) Leader-Based Equivocation
Exclusion: The green Okazaki fragment created by the green
leader includes the ùëâ -marked red block, since the green
leader does not observe the red equivocation. However, the
red ùëã -marked red block is excluded from the purple frag-
ment created by the purple leader, since the purple leader
observes the equivocation among the two red blocks. (See
also Figure 1.A)

8

Algorithm 2 Cordial Miners: Ordering of a Blocklace with ùúè
pseudocode for miner ùëù ‚àà Œ†, including Algorithms 1 & 4

Local Variable:

outputBlocks ‚Üê { }
currentLeader ‚Üê { }

19: procedure output_blocks()
20:
21:

currentLeader ‚Üê last_final_leader ()
ùúè (currentLeader)

22: procedure ùúè(ùëè1)
23:

if ùëè1 ‚àà outputBlocks ‚à® ùëè1 = ‚àÖ then return
ùëè2 ‚Üê previous_ratified_leader(ùëè1)
ùúè (ùëè2)
output xsort(ùëè1, [ùëè1 ] \ [ùëè2 ])
outputBlocks ‚Üê outputBlocks ‚à™ xsort(ùëè1, [ùëè1 ] \ [ùëè2 ])

24:
25:
26:
27:

28: procedure xsort(ùëè, ùêµ)
29:

return topological sort wrt ‚âª of the set {ùëè‚Ä≤ ‚àà ùêµ : approved(ùëè‚Ä≤, ùëè) }

30: procedure previous_ratified_leader(ùëè1)
return argùëè‚ààùëÖ max depth(ùëè)
31:
where ùëÖ = {ùëè ‚àà [ùëè1 ] \ {ùëè1 } : ùëè.creator = leader(depth(ùëè)) ‚àß ratified(ùëè, ùëè1) }
32:

33: procedure last_final_leader()
34:
35:

return argùë¢‚ààùëà max depth(ùë¢) where
ùëà = {ùëè ‚àà blocklace : ùëè.creator = leader(depth(ùëè)) ‚àß final_leader(ùëè) }

procedure leader () is defined in Algorithm 4
procedure final_leader () is defined Algorithm 4

‚ä≤ Recursive call to ùúè
‚ä≤ Output a new equivocation-free ‚ÄòOkazaki-fragment‚Äô

‚ä≤ Exclude equivocations and sort

‚ä≤ Figure 1.B

‚ä≤ Figure 2

> If ùëè ùëó+1 is deeper than ÀÜùëè2, then by Definition 4.1, ùúè ‚Ä≤ elects the
first leader ratified by the current leader ùëè ùëó , and hence cannot
prefer calling ùëè ùëó+1 over ÀÜùëè2, which precedes it by assumption.
< If ÀÜùëè2 is deeper, then Proposition 3.15 implies that ùëè ùëó+1 ratifies
ÀÜùëè2, in contradiction to the assumption that ùëè ùëó is the last
leader in the list that ratifies ÀÜùëè2.

Hence ÀÜùëè2 is included in the recursive calls of ùúè ‚Ä≤(ÀÜùëè1), which, accord-
‚ñ°
ing to Definition 4.1 of ùúè, implies that ùúè (ùêµ2) ‚™Ø ùúè (ùêµ1).

Observation 4 (Consistent triplet). Given three sequences ùë•, ùë• ‚Ä≤, ùë• ‚Ä≤‚Ä≤,
if both ùë• ‚Ä≤ ‚™Ø ùë• and ùë• ‚Ä≤‚Ä≤ ‚™Ø ùë• then ùë• ‚Ä≤ and ùë• ‚Ä≤‚Ä≤ are consistent.

The following Proposition ensures that if there is a supermajority
of correct miners, which jointly create a cordial blocklace, then the
output sequences computed by any two miners based on their local
blocklaces would be consistent. This establishes the safety of ùúè
under these conditions.

Proposition 4.4 (ùúè Safety). Let ùêµ be a blocklace with a superma-
jority of correct miners. Then for every ùêµ1, ùêµ2 ‚äÜ ùêµ, ùúè (ùêµ1) and ùúè (ùêµ2)
are consistent.

Proof of Proposition 4.4. By monotonicity of ùúè (Prop. 4.3),
both ùúè (ùêµ1) ‚™Ø ùúè (ùêµ1 ‚à™ ùêµ2) and ùúè (ùêµ2) ‚™Ø ùúè (ùêµ1 ‚à™ ùêµ2). By Obser-
‚ñ°
vation 4, ùúè (ùêµ1) and ùúè (ùêµ2) are consistent.

4.2 ùúè Liveness
While ùúè does not output all the blocks in its input, as blocks not
observed by the last final leader in its input are not in its output,

9

the following observation and proposition sets the conditions for ùúè
liveness:

Observation 5 (ùúè output).
If a ùëù-block ùëè ‚àà ùêµ by a miner ùëù not
equivocating in ùêµ is observed by a final leader in ùêµ, then ùëè ‚àà ùúè (ùêµ).

Proof of Observation 5. Since ùëè is observed by a final leader
in ùêµ, it is also observed by the last final leader of ùêµ. Consider the
recursive construction of ùúè (ùêµ). If in its last recursive call ùúè ‚Ä≤(ùëè ‚Ä≤), ùëè ‚Ä≤
observes ùëè, then by definition of ùúè, ùëè ‚àà ùúè (ùëè ‚Ä≤) and hence ùëè ‚àà ùúè (ùêµ).
Otherwise, consider the first recursive call ùúè ‚Ä≤(ùëè ‚Ä≤) by ùúè ‚Ä≤(ùëè ‚Ä≤‚Ä≤) in which
ùëè ‚Ä≤‚Ä≤ observes ùëè but ùëè ‚Ä≤ does not observe ùëè. Then by definition of ùúè ‚Ä≤,
ùëè ‚àà ùúè ‚Ä≤(ùëè ‚Ä≤‚Ä≤) and hence ùëè ‚àà ùúè (ùêµ).
‚ñ°

Proposition 4.5 (ùúè Liveness). Let ùêµ1 ‚äÇ ùêµ2 ‚äÇ . . . be a sequence
of finite blocklaces for which ùêµ = (cid:208)ùëñ ‚â•1 ùêµùëñ is a cordial leader-live
blocklace. Then for every block ùëè ‚àà ùêµ by a correct miner in ùêµ there is
an ùëñ ‚â• 1 such that ùëè ‚àà ùúè (ùêµùëñ ).

Proof of Proposition 4.5. Let ùêµ be as assumed and ùëè ‚àà ùêµ. As
ùêµ is leader-live, there is a final leader block ùëè ‚Ä≤ that observes ùëè. Let
ùëñ ‚â• 1 be an index for which ùêµùëñ includes ùëè ‚Ä≤. Consider the call ùúè (ùêµùëñ ).
Since ùëè is a final leader in ùêµùëñ than according to Observation 5, the
‚ñ°
output of ùúè (ùêµùëñ ) includes ùëè.

And based on it, we conclude that the safety and liveness prop-

erties of ùúè carry over to Algorithm 2.

The following Theorem provides a sufficient condition for the
safety and liveness (Def. 2.3) of any blocklace-based ordering con-
sensus protocol that employs ùúè:

Theorem 4.6 (Sufficient Condition for the Safety and
Liveness of a Blocklace-Based Ordering Consensus Protocol).
A blocklace-based consensus protocol that employs ùúè for ordering is
safe and live if in every run all correct miners have in the limit the
same blocklace ùêµ, and ùêµ is leader-safe and leader-live.

Proof of Theorem 4.6. Let ùëÉ ‚äÜ Œ† be the correct miners in a
run of the protocol that produce in the limit the blocklace ùêµ. The
protocol is safe since the local blocklaces of any two miners in
ùëù, ùëû ‚àà ùëÉ at any time are subsets of ùêµ, hence by Proposition 4.4
the outputs of ùëù and ùëû are consistent. The protocol is live since by
Proposition 4.5, every block ùëè ‚àà ùêµ will be output by every correct
‚ñ°
miner ùëù ‚àà ùëÉ.

Next, we prove that the two Cordial Miners consensus protocols‚Äî
eventual synchrony and asynchrony‚Äîsatisfy the conditions of The-
orem 4.6, and hence are safe and live.

5 THE CORDIAL MINERS PROTOCOLS
The shared components of the Cordial Miners protocols are spec-
ified via pseudocode in Algorithms 1 (blocklace utilities), 2 (the
ordering function ùúè) and 3 (dissemination). There are several dif-
ferences between the Cordial Miners protocols for eventual syn-
chrony and for asynchrony: Wavelength (2 or 5); leader selection
(prospective or retrospective); the notion of a final leader (whether
it includes ratification by the next leader or not); and when is a
round complete (based only on cordiality or also on including or
observing the leader or a timeout). These differences are summa-
rized in Table 2 and are specified via pseudocode in Algorithm 4.

The main Theorem we prove here is the following:

Theorem 5.1 (Cordial Miners Protocols Safety and Live-
ness). The Cordial Miners protocols for eventual synchrony and for
asynchrony specified in Algorithms 1, 2, 3 & 4 are safe and are live.

Proof Outline. We prove two propositions that together es-
tablish the Theorem: Proposition 5.5 shows that the two Cordial
Miners protocols are safe and Proposition 5.6 shows that they are
‚ñ°
live.

In the Cordial Miners protocols there is a tradeoff between la-
tency and messages complexity, analogously to this same tradeoff
in reliable-broadcast protocols [18], and there is a range of possible
optimizations and heuristics. These are discussed in Section 6. Here,
we present latency-optimal Cordial Miners protocols in which ev-
ery block is communicated among every pair of correct miners. In
a Cordial Miners protocol, each miner maintains a history array
that records its communication history with the other miners, and
updates it upon accepting (line 42) and sending (line 48) blocks.
When a miner ùëù creates a block ùëè, it includes in it pointers to the
tip of its blocklace (line 45), so that [ùëè] is identical to the updated
blocklace that includes ùëè. It then sends ùëè to all other miners (line 48),
sends to each miner ùëû also all the blocks that ùëù knows but ùëû does
not know, based on their communication history. Namely, it sends
to ùëû the blocklace [ùëè] \ [history(ùëû)] (line 48). A recipient of a block
defers accepting it it until the block has no dangling pointers in
its local blocklace (line 39), so that adding the block to the local
blocklace would retain it being closed.

10

5.1 Cordial Miners Safety
We argue next that in the limit the blocklaces of correct miners
that participate in a run of a Cordial Miners protocol are identical,
are leader-safe and leader-live. Variations and optimizations are
discussed in Section 6.

A formal description of blocklace-based protocols in terms of
asynchronous multiagent transition systems with faults has been
carried out in reference [37]. Here, we employ pseudocode, pre-
sented in Algorithms 1, 2, 3 & 4 to describe the correct behaviors of
a miner in a protocol, and discuss only informally the implied mul-
tiagent transition system and its computations. We assume that the
run of the protocol by the miners Œ† results in a sequence of configu-
rations ùëü = ùëê0, ùëê1, . . ., each encoding the local state of each miner. A
miner is correct in a run ùëü it if behaves according to the pseudocode
during ùëü , faulty otherwise. As stated above, we assume that there
are at most ùëì < ùëõ/3 faulty miners in any run. We use ùêµùëù (ùëê) to de-
note the local blocklace of miner ùëù ‚àà Œ† in configuration ùëê, ùêµùëù (ùëü ) to
denote the blocklace of miner ùëù in the limit, ùêµùëù (ùëü ) := (cid:208)ùëê ‚ààùëü ùêµùëù (ùëê),
and ùêµ(ùëü ) to denote the unions of the blocklaces of all correct miners
in the limit, ùêµ(ùëü ) := (cid:208)ùëù ‚ààùëÉ ùêµùëù (ùëü ), where ùëÉ ‚äÜ Œ† is the set of miners
correct in run ùëü .

Proposition 5.2 (Miner Asynchrony). If a miner can create a
block (line 45) then it can create it also after receiving blocks from
other miners.

Proof of Proposition 5.2. Examination of the completed_round
procedures of Algorithm 4, which gate block creation in Algorithm
3, line 45, shows that if it holds for a blocklace it holds after blocks
by other miners are received and buffered or added to the local
‚ñ°
blocklace.

Miner asynchrony combined with the standard notion of fairness,
that a transition that is enabled infinitely often in a run is eventually
taken in the run, implies that once a Cordial Miners block creation
transition is enabled then it will eventually be taken.

Proposition 5.3 (Miners Liveness). In a fair run of a Cordial
Miners protocol with correct miners ùëÉ ‚äÜ Œ†, if there is a configuration
for which completed_round() ‚â• ùëë (line 44) for ùëë ‚â• 0 and for the
blocklace of every miner ùëù ‚àà ùëÉ, then there is a subsequent configura-
tion for which completed_round() ‚â• ùëë + 1 for the blocklace of every
miner ùëù ‚àà ùëÉ.

Proof of Proposition 5.3. We show by induction on the round
number. Consider a configuration ùëê in which the depth of the last
completed round in the blocklace of all miners be ùëë ‚â• 0. If ùëë = 0
then the completed_round () call (line 44 in both Cordial Miners
protocols (Algorithm 4, line 57 and line 66) returns 0 and ùëù can
create a initial block (line 45) with no predecessors (line 5). Assume
ùëë > 0. Consider a miner ùëù ‚àà ùëÉ that has not yet created a block of
depth ùëë + 1 in ùëê. Then the condition completed_round() ‚â• ùëü (line 44)
holds for ùëü = ùëë, and the transition to create the next block is enabled.
By miner asynchrony (Proposition 5.2) such a transition is enabled
indefinitely, and by the fairness assumption it is eventually taken,
in which ùëù sends a new ùëù-block ùëè of depth ùëë + 1 to all other miners
(line 48), and includes, for each miner ùëû, all the blocks in the closure
of ùëè that ùëû might not know of, based on the communication history
of ùëù with ùëû. By assumption, all said messages among correct miners

Algorithm 3 Cordial Miners: Blocklace-Based Dissemination
pseudocode for miner ùëù ‚àà Œ†, including Algorithms 1, 2 & 4

Local variables:

array history(ùëõ), initially ‚àÄùëò ‚àà [ùëõ] : history(ùëò) ‚Üê { }
ùëü ‚Üê 0

‚ä≤ Communication history of ùëù
‚ä≤ The current round of ùëù
‚ä≤ send and receipt are simple messaging on a reliable link

for ùëè ‚àà buffer : (b.pointers ‚äÜ hash(blocklace) ‚àß ‚àÄùëè‚Ä≤ ‚àà blocklace : ¬¨equivocator(ùëè.creator, ùëè‚Ä≤)) do

if cordial_block(ùëè) then buffer ‚Üê buffer ‚à™ {ùëè }

36: upon receipt of ùëè do
37:
38: while true do
39:
40:
41:
42:
43:

buffer ‚Üê buffer \ {ùëè }
blocklace ‚Üê blocklace ‚à™ {ùëè }
history(ùëû) ‚Üê history(ùëû) ‚à™ {ùëè }
output_blocks()

44:
45:
46:
47:
48:
49:

if completed_round() ‚â• ùëü then

ùëè ‚Üê create_block(completed_round())
ùëü ‚Üê depth(ùëè)
for ùëû ‚àà Œ† ‚àß ùëû ‚â† ùëù ‚àß ¬¨equivocator(ùëû, ùëè) do

send [ùëè ] \ [history(ùëû) ] to ùëû
history(ùëû) ‚Üê history(ùëû) ‚à™ {ùëè }

50: procedure cordial_block(ùëè)
51:

return {ùëè‚Ä≤.creator : ùëè ‚âª ùëè‚Ä≤ ‚àß depth(ùëè‚Ä≤) = depth(ùëè) ‚àí 1} is a supermajority.

procedure output_blocks () is defined in Algorithm 2
procedure completed_round () is defined in Algorithm 4

Property
Wavelength ùë§

Eventual Synchrony
2

Leader Selection

Prospective

Asynchrony
5

Retrospective

Leader Final if:

Round Completed if:

Super-ratified & Ratified by next
leader within ùë§

Super-ratified within ùë§

Cordial and (includes or ratifies
leader, or timeout)

Cordial

Probability of Wave Success:

4
9

2
3

Table 2: Differences Between the Cordial Miners Protocols for Eventual Synchrony and for Asynchrony

eventually arrive at their destination. Hence there is some subse-
quent configuration ùëê ‚Ä≤ in which every correct miner has receives a
ùëë + 1-depth ùëû-block ùëè from every other correct miner ùëû, as well as
all preceding blocks to ùëè. Hence in ùëê ‚Ä≤, completed_round() ‚â• ùëü holds
‚ñ°
for ùëü = ùëë + 1 for every correct miner.

Proposition 5.4 (Cordial Miners Dissemination). In a run ùëü
of a Cordial Miners protocol with correct miners ùëÉ ‚àà Œ†, ùêµ(ùëü ) = ùêµùëù (ùëü )
for every miner ùëù ‚àà ùëÉ.

Proof of Proposition 5.4. Given a run ùëü of a Cordial Miners
protocol with correct miners ùëÉ ‚äÇ Œ†, we have to show that for
any ùëù, ùëû ‚àà ùëÉ, a configuration ùëê of the run, and a block ùëè in the
blocklace of ùëù is configuration ùëê, there is a subsequent configuration
ùëê ‚Ä≤ of the run in which ùëè is in the local blocklace of ùëû. By miners
liveness (Proposition 5.3), for any miner ùëû, there is a subsequent
configuration by which miner ùëù sends a block to miner ùëû. According

to the dissemination protocol (line 48), [ùëè] is also sent to ùëû, minus
any blocks in [ùëè] that have been previously communicated between
ùëù and ùëû. Hence there is a subsequent configuration to ùëê ‚Ä≤ in which ùëè
‚ñ°
is included in the blocklace of ùëû.

We refer to ùêµ(ùëü ) as the blocklace of run ùëü , and conclude that every
miner ùëù correct in a run produces the blocklace of the run, namely
ùêµùëù (ùëü ) = ùêµ(ùëü ).

We can now argue the safety of the Cordial Miners protocols:

Proposition 5.5 (Cordial Miners Protocol Safety). The Cor-

dial Miners protocols for asynchrony and synchrony are safe.

Proof of Proposition 5.5. According to Proposition 5.4, in any
computation of a Cordial Miners protocol, the local blocklace of
any two correct miners ùëù, ùëû ‚àà Œ† is the same blocklace ùêµ. Hence, in
any configuration of the computation, the local blocklaces of ùëù and
ùëû are subsets of ùêµ, and hence according to Proposition 4.4, their

11

Algorithm 4 Cordial Miners: Protocol-Specific Utilities
pseudocode for miner ùëù ‚àà Œ†

52: ùë§ ‚Üê 2
53: procedure leader(ùëë) return ùëù ‚àà Œ† using a shared pseudorandom function if ùëë mod ùë§ = 0 else ‚ä•.

4.1 Procedures for Eventual Synchrony

54: procedure final_leader(ùëè)
55:
56:

return ùêµ = {ùëè‚Ä≤ ‚àà blocklace_prefix(depth(ùëè) + ùë§) : ratifies(ùëè‚Ä≤, ùëè) } is a supermajority ‚àß
‚àÉùëè‚Ä≤ ‚àà ùêµ : ùëè‚Ä≤.creator = leader(depth(ùëè‚Ä≤)) ‚àß depth(ùëè‚Ä≤) = depth(ùëè) + ùë§

57: procedure completed_round()
58:
59:
60:
61:

return max ùëü : {ùëè.creator : ùëè ‚àà blocklace ‚àß depth(ùëè) = ùëü } is a supermajority ‚àß
(ùëü mod ùë§ = 0 =‚áí ‚àÉùëè ‚àà blocklace : leader(ùëü ) = ùëè.creator ‚à® timeout) ‚àß
(ùëü mod ùë§ = 1 =‚áí ‚àÉùëè ‚àà blocklace : (leader(ùëü ‚àí 1) = ùëè.creator ‚àß
{ùëè‚Ä≤.creator : ùëè‚Ä≤ ‚àà blocklace ‚àß depth(ùëè‚Ä≤) = ùëü ‚àß approves(ùëè‚Ä≤, ùëè) } is a supermajority) ‚à® timeout)

‚ä≤ Prospective leader

‚ä≤ Cordial & (leader included/ratified or timeout)
‚ä≤ Cordial
‚ä≤ Leader included
‚ä≤ Leader ratified

62: ùë§ ‚Üê 5
63: procedure leader(ùëë) return ùëù ‚àà Œ† via a random shared coin tossed at round ùëë + ùë§ ‚àí 1 if ùëë mod ùë§ = 0 else ‚ä•.

4.2 Procedures for Asynchrony

64: procedure final_leader(ùëè)
65:

return {ùëè‚Ä≤ ‚àà blocklace_prefix(depth(ùëè) + ùë§ ‚àí 1) : ratifies(ùëè‚Ä≤, ùëè) } is a supermajority

66: procedure completed_round()
67:

return max ùëü : {ùëè.creator : ùëè ‚àà blocklace ‚àß depth(ùëè) = ùëü } is a supermajority

‚ä≤ Retrospective leader

‚ä≤ Cordial

outputs at that configuration are consistent, which is the safety
requirement of ordering consensus protocols (Def. 2.3). Hence the
‚ñ°
Cordial Miners protocols are safe.

5.2 Cordial Miners Liveness
We now proceed to argue the liveness of the Cordial Miners proto-
cols.

Proposition 5.6 (Cordial Miners Protocol Liveness). The
Cordial Miners protocols for asynchrony and eventual synchrony are
live.

Proof of Proposition 5.6. According to Propositions 5.7 and
5.14 below, the blocklace produced in any computation of the Cor-
dial Miners protocols for eventual synchrony and for asynchrony
is leader-live with probability 1. According to Proposition 4.5, if the
function ùúè applied to a sequence of blocklaces that converge to a
leader-live blocklace ùêµ then any ùëè ‚àà ùêµ appears eventually in the
output of ùúè. If the blocklace ùêµ is leader-live with probability 1 then
any ùëè ‚àà ùêµ appears eventually in the output of ùúè with probability 1,
which is the liveness requirement of ordering consensus protocols
‚ñ°
(Def. 2.3). Hence the Cordial Miners protocols are live.

Next we prove the required leader-liveness propositions.

Proposition 5.7 (Leader-Liveness Cordial of Miners Even-
tual Synchrony Protocol). The blocklace produced by a run of a
Cordial Miners eventual synchrony protocol is leader-live with proba-
bility 1.

Proof of Proposition 5.7. Let ùêµ be the cordial blocklace pro-
duced by a run of a Cordial Miners eventual synchrony protocol,
ùëÉ ‚äÜ Œ† the supermajority of miners correct in the run, and let
ùëü > 0 be any round for which the ùëü ‚àí 1 suffix of of ùêµ, ¬Øùêµ(ùëü ‚àí 1), is
equivocation-free, ùëü mod ùë§ = 0, where ùë§ = 2 (line 52). Let ùëü ‚Ä≤ > ùëü

be any even round following network synchronization (GST). Since
leader selection is pseudo random (line 53), and ùëÉ is a supermajority,
there is probability of |ùëÉ |
ùëõ that the ùëü ‚Ä≤-leader ùëû is correct, namely
ùëû ‚àà ùëÉ. As timeout does not affect correct miners after GST, then
for every ùëù ‚àà ùëÉ, the ùëü ‚Ä≤-depth ùëû-block ùëè is approved by the ùëü ‚Ä≤ + 1
ùëù-block (line 59 and ratified by the ùëü ‚Ä≤ + 2-round block of ùëù. Hence,
the blocks of the correct miners ùëÉ satisfy the conditions of ùëè being
a final leader (line 54) for the Cordial Miners eventual synchrony
protocol. As this holds also for the leader of any round following
ùëü , the probability that for any depth ùëü ‚Ä≤ ‚â• ùëü , a leader in ¬Øùêµ(ùëü ‚Ä≤) has
a final leader is 1, hence ùêµ is leader-live with probability 1. Hence
the condition of Proposition 3.18, that for every ùëü > 0, ùêµ has a final
leader block of some round ùëü ‚Ä≤ > ùëü with probability 1, is satisfied
‚ñ°
and we conclude that ùêµ is leader-live with probability 1.

We note that, following GST, the probability of a leader block
then

being final is at least ( |ùëÉ |
the expected latency is at most 2/( 2

ùëõ )2, and given that ùë§ = 2, if |ùëÉ |
3 )2 = 4.5.

The Cordial Miners asynchrony protocol, for which ùë§ = 5
(line 62), elects leaders retroactively using a shared random coin.
To elect the leader of round ùëü , when ùëü mod 5 = 0, all correct miners
toss the coin in round ùëü + 3 and know in round ùëü + 4 the elected
leader of round ùëü , as follows. to elect a leader

ùëõ > 2
3

Definition 5.8 (Blocklace-Based Shared Random Coin). We assume
two shared random coin functions, toss_coin and combine_tosses.
The function toss_coin(ùëùùë†, ùëë) takes the secret key ùëùùë† of miner ùëù ‚àà Œ†
and a round number ùëë > 0 as input, and produces ùëù‚Äôs share of the
coin of round ùëë, ùë†ùëù,ùëë , as output. If the protocol needs to compute
the shared random coin for round ùëë, then ùë†ùëù,ùëë is incorporated in
the payload of the ùëë-depth ùëù-block of every correct miner ùëù. The
function combine_tosses(ùëÜ, ùëë) takes a set ùëÜ of shares ùë†ùëù,ùëë , ùëë > 0, for
which |{ùëù : ùë†ùëù,ùëë ‚àà ùëÜ }| > ùëì + 1, and returns a miner ùëû ‚àà Œ†.

12

Assume some ùëë > 0 and let ùëÜ = {toss_coin(ùëùùë†, ùëë) : ùëù ‚àà ùëÉ } for
a set of miners ùëÉ ‚äÜ Œ†, |ùëÉ | > ùëì + 1. Then the functions have the
following properties:

Agreement If both ùëÜ ‚Ä≤, ùëÜ ‚Ä≤‚Ä≤ ‚äÜ ùëÜ and both |ùëÜ ‚Ä≤|, |ùëÜ ‚Ä≤‚Ä≤| > ùëì + 1, then
combine_tosses(ùëÜ ‚Ä≤, ùëë) = combine_tosses(ùëÜ ‚Ä≤‚Ä≤, ùëë)
Termination combine_tosses(ùëÜ, ùëë) ‚àà Œ†.
Fairness The coin is fair, i.e., for every set ùëÜ computed as above
and any ùëù ‚àà Œ†, the probability that ùëù = combine_tosses(ùëÜ, ùëë) is
1
ùëõ .
Unpredictability If ùëÜ ‚Ä≤ ‚äÇ ùëÜ, |ùëÜ ‚Ä≤| < ùëì + 1, then the probability
that the adversary can use ùëÜ ‚Ä≤ to guess the value of combine_tosses(ùëÜ, ùëë)
is less than 1

ùëõ + ùúñ.

Examples of such a coin implementation using a PKI and thresh-
old signatures [4, 32, 39] are in [10, 28]. See DAG-Rider [28] on
details on how to implement such a coin as part of a distributed
blocklace-like structure.

The following proposition ensures that in a disseminating cordial
blocklace, all correct miners eventually repel all equivocators and
stop observing blocks by them.

Definition 5.9 (Equivocator-Repelling). Let ùëè ‚àà B be a ùëù-block,
ùëù ‚àà Œ†, that acknowledges a set of blocks ùêµ ‚äÇ B. Then ùëè is
equivocator-repelling if ùëù does not equivocate in [ùëè] and all
blocks in ùêµ are equivocator-repelling. A blocklace ùêµ is equivocator-
repelling if every block ùëè ‚àà ùêµ is equivocator-repelling.

Note that the recursive definition terminates with an initial
block, where ùêµ = ‚àÖ. Also note that a block (or blocklace) that
is equivocator-repelling may include equivocations, for example
two equivocating blocks each observed by a different block in ùêµ.
However, once an equivocation by miner ùëû is observed by a block ùëè,
ùëû would be repelled: Any block that observes ùëè would not acknowl-
edge any ùëû-block, preventing any further ùëû-blocks from joining the
blocklace. Also note that the local blocklace created by a correct
miner is equivocation-repelling, due to the last condition in line 39.

Proposition 5.10 (Eqivocators-Free Suffix). Let ùêµ be an
equivocator-repelling and cordial blocklace and ùëÉ ‚äÇ Œ† the set of
miners that do not equivocate in ùêµ and are disseminating in ùêµ. If ùëÉ
is a supermajority then there is a depth ùëë > 0 for which the depth-ùëë
suffix of ùêµ, ¬Øùêµ(ùëë), includes only ùëÉ-blocks.

The following Lemma is the blocklace-variant of the notion of
a common core [2, 19]. Its proof is an adaptation to the cordial
blocklace setting of the common core proof in [19], which in turn
is derived from the proof of get-core in [2]. Figure 5 illustrates its
proof as well as the proof of the following ratified common core
Corollary 5.12.

Lemma 5.11 (Blocklace Common Core). Let ùêµ be a cordial block-
lace, ùëÉ ‚äÇ Œ† the set of miners that do not equivocate in ùêµ and are
disseminating in ùêµ, and ùëü > 0 a depth for which the depth-(ùëü ‚àí 1)
suffix of ùêµ, ¬Øùêµ(ùëü ‚àí 1), includes only ùëÉ-blocks (ùëü exists by Proposition
5.10), and hence equivocation free. If ùëÉ is a supermajority then there
is a supermajority of ùëü -round blocks ÀÜùêµ ‚äÇ ùêµ, referred to as common
core, such that every (ùëü + 3)-round block approves every block in ÀÜùêµ.

Proof of Lemma 5.11. Let ùêµ and ùëü be as assumed by the Lemma,
and let ùëÉ be the set of miners that have (ùëü + 2)-round blocks in ùêµ.

Figure 5: Common Core, Ratified Common Core, Safety
and Liveness of Decision Rule for Asynchrony: (A) Proof of
Lemma 5.11 and Corollary 5.12: Rounds ùëü to ùëü + 3 relate to
the proof of Lemma 5.11, where the existence of a common
core at round ùëü is established. Round ùëü + 4 relates to Corol-
lary 5.12, which establishes that all cordial blocks at round
ùëü + 4 ratify all members of the common core of round ùëü via
a supermajority at round ùëü + 3. (B) The common-core table
ùëá used in the proof to relate rounds ùëü + 1 and ùëü + 2. (C) The
decision rule for asynchrony: Protocol wavelength is 4. Live-
ness: Common-core ensures that the blue leader at round ùëü is
super-ratified by a red supermajority at round ùëü +4 with prob-
ability 2ùëì +1
3ùëì +1 , thus ensuring liveness and expected latency of
6 rounds. Safety: A blue leader is approved by every cordial
block at round ùëü + 3 (green) and hence is ratified by every
cordial block at round ùëü + 4 (red) and beyond.

Since ùêµ is cordial and disseminating it is infinite of depth > ùëü + 3
(Observation 3), it follows that |ùëÉ | ‚â• 2ùëì + 1. Define a table ùëá with
rows and columns indexed by ùëÉ. Each (ùëü + 2)-round ùëù-block of a
miner ùëù ‚àà ùëÉ observes (ùëü + 1)-round blocks by at least 2ùëì + 1 miners,
which includes at least blocks by ùëì + 1 miners of ùëÉ, represented in
ùëá . For ùëù, ùëû ‚àà ùëÉ, entry ùëá [ùëù, ùëû] in the table is 1 if the (ùëü + 2)-round ùëù-
block observes the (ùëü + 1)-round ùëû-block, and 0 otherwise. Observe
that if 1 appears in entry ùëá [ùëù, ùëû], the (ùëü +2)-round ùëù-block observes
all the 2ùëì + 1 ùëü -round blocks observed by the (ùëü + 1)-round block
of ùëû.

Since all miners in ùëÉ have (ùëü + 2)-round blocks, ùëá contains at
least (2ùëì + 1)(ùëì + 1) entries with 1. This implies that there is a
miner in ùëÉ, say ¬Øùëù, that appears in at least ùëì + 1 rows; let ¬ØùëÉ be the
set of miners indexing ¬Øùëù rows and ¬Øùëè (blue dot) the (ùëü + 1)-round
¬Øùëù-block. Thus, the (ùëü + 2)-round blocks of miners in ¬ØùëÉ (thick green
line at round ùëü + 2) observe ¬Øùëè. We argue that [¬Øùëè] is a common core.

13

First, note that as ¬Øùëè is cordial, [¬Øùëè] includes 2ùëì + 1 ùëü -round blocks.
Second, consider any (ùëü + 3)-round block ùëè (green dot). It observes
2ùëì + 1 (ùëü + 2)-round blocks (thick red line), so it also observes at
least one of the (ùëü + 1)-round blocks (black dot) of the ùëì + 1 miners
of ¬ØùëÉ, which in turn observes ¬Øùëè. Thus [¬Øùëè] ‚äÜ [ùëè], with [¬Øùëè] satisfying
‚ñ°
the requirements of a common core.

Corollary 5.12 (Super-Ratified Common Core). Under the
same conditions as Lemma 5.11 and assuming ÀÜùêµ is a common core,
then every (ùëü + 4)-round block in ùêµ ratifies every block in ÀÜùêµ, Hence
every member of the common core ÀÜùêµ, is super-ratified in ùêµ(ùëü + 4).

Proof of Corollary 5.12. Under the assumptions of the Corol-
lary, let ÀÜùêµ be a common core and consider any (ùëü + 4)-block ùëè ‚àà ùêµ
(purple dot). Being cordial, ùëè observes 2ùëì + 1 (ùëü + 2)-round blocks
(thick purple line). By Lemma 5.11, each of these blocks observes
each block in ÀÜùêµ. Hence ùëè ratifies every block in ÀÜùêµ.
‚ñ°

Note that the Lemma and Corollary require an equivocators-free
section of the blocklace, which may be the entire equivocation-free
suffix of the blocklace as in the proof. But the proof also holds if
there is a long enough stretch of rounds without equivocation, in
which case a common core also exists.

We conclude that if a Cordial Miners protocol relies on the com-
mon core for liveness, dissemination and cordiality are sufficient to
ensure it.

Corollary 5.13 (Liveness of Common Core). Let ùêµ be a dis-
seminating and cordial blocklace. Then there is a ùëë > 0 for which the
common core Lemma 5.11 holds for ùêµ and for any round ùëü ‚â• ùëë.

Proposition 5.14 (Leader-Liveness of Cordial Miners Asyn-
chrony Protocol). The blocklace produced by a run of a Cordial
Miners asynchrony protocol is leader-live with probability 1.

Proof of Proposition 5.14. Let ùêµ be the cordial blocklace pro-
duced by a run of a Cordial Miners asynchrony protocol, ùëÉ ‚äÜ Œ†
the supermajority of miners correct in the run, and let ùëü > 0 be any
round for which the ùëü ‚àí1 suffix of of ùêµ, ¬Øùêµ(ùëü ‚àí1), is equivocation-free,
ùëü mod ùë§ = 0, where ùë§ = 5 (line 62). According to Corollary 5.12,
a supermajority ÀÜùêµ of the round-ùëü blocks are super-ratified by all
round-ùëü + 4 blocks. As the leader of round ùëü is selected at random,
and retroactively after the common core ÀÜùêµ has been established,
the probability that the elected leader is super-ratified, and hence
final, is at least |ùëÉ |
ùëõ . As this holds also for the leader of any round
following ùëü , the probability that for any depth ùëë ‚â• ùëü , a leader in
¬Øùêµ(ùëë) has a final leader is 1, hence ùêµ is leader-live with probability
‚ñ°
1.

This completes the proof of Proposition 5.6 and hence also the

proof of Theorem 5.1.

6 PERFORMANCE ANALYSIS AND
POTENTIAL OPTIMIZATIONS

Latency (See Table 1). Latency is defined as the number of blocklace
rounds between every two consecutive ratified leaders.

In the asynchronous instance of the protocol, each wave (rounds
till leader finality) consists of 5 rounds. According to Lemma 5.11,

Figure 6: Eventual Synchrony: Cordiality, Safety and Live-
ness. Cordiality: Wavelength is 2 (line 52). Even round con-
tains a supermajority (red thick line) that includes the
leader (red dot), which ratifies the leader of the previous
even round (blue dot). At odd rounds (ùëü + 1), wait for a su-
permajority (thick blue line) of the previous round (ùëü ) that
includes the leader (blue dot), or a timeout (line 59). At even
rounds (ùëü + 2), wait for a supermajority (thick green line)
of the previous round (ùëü + 1) that approves the leader, or a
timeout (line 60). Safety: Any subsequent leader to the blue
leader ratifies the blue leader; the immediate red successor
by construction‚Äîcase (A) of Figure 2‚Äîand any subsequent
leaders according to cases (B) and (C) of Figure 2. Liveness:
If a round leader (blue) is correct than it will be finalized
within ùë§ = 2 rounds.

the probability that the decision rule is met, namely that a superma-
jority of the blocks in ùëü + 4 each ratify a leader at ùëü is 2
. Therefore,
3
in the expected-case, the decision rule is met on average every 1.5
waves, and therefore the expected latency is 1.5ùë§ = 7.5 rounds of
communication.

Note that the adversary can equivocate or not be cordial up to ùëì
times, but after each Byzantine process ùëù equivocates, all correct
processes eventually detect the equivocation and do not consider ùëù‚Äôs
blocks as part of their cordial rounds when building the blocklace.
Thus, in an infinite run, equivocations do not affect the overall
expected latency.

In the eventual synchrony case, each wave consists of 2 rounds.
The probability that the decision rule is met in each wave is the
probability that there are two correct leaders in a row, therefore, it
is at least 4
. Thus, in the expected-case, the latency is 4.5 rounds
9
of communication.
Bit complexity. Each block in the blocklace is linear in size, since
it has a linear number of hash pointers to previous blocks. In the
worst-case, each block is sent to all miners by all the other miners,
i.e., the bit complexity is ùëÇ (ùëõ3) per block. But, if we batch per block
a linear number of transactions, when the decision rule is met,
we can amortize the bit complexity by a linear factor. Thus, the
amortized bit complexity per decision is ùëÇ (ùëõ2).

14

We note that DAG-Rider and Bullshark achieve amortized ùëÇ (ùëõ)
message complexity per decision by using a reliable broadcast pro-
tocol that relies on erasure coding [17]. We plan as part of future
work to incorperate similar techniques as used in [17] to the block-
lace dissemination protocol to achieve the same amortized message
complexity.
Future directions. Several optimizations are possible to the pro-
tocol instances presented. First, as faulty miners are exposed, they
are repelled and therefore need not be counted as parties to the
agreement, which means that the number of remaining faulty min-
ers, initially bounded by ùëì , decreases. As a result, the superma-
jority needed for finality is not ùëõ+ùëì
2ùëõ (namely 2ùëì + 1 votes in case
ùëõ = 3ùëì + 1), but ùëõ+ùëì ‚àí2ùëì ‚Ä≤
, where ùëì ‚Ä≤ is the number of exposed faulty
2(ùëõ‚àíùëì ‚Ä≤)
miners, which converges to simple majority ( 1
2
miners as more faulty miners are exposed and ùëì ‚Ä≤ tends to ùëì .

) among the correct

Secondly, once faulty miners are exposed and repelled, their slots
as leaders could be taken by correct miners, improving good-case
and expected complexity.

Thirdly, a hybrid protocol in the spirit of Bullshark [25] can be
explored. Such a protocol would employ two leaders per round ‚Äì
deterministic and random, try to achieve quick finality with the
deterministic leader, and fall back to the randomly-selected leader
if this attempt fails.
Exclusion of nonresponsive miners: A miner ùëù need not be
cordial to miner ùëû as long as ùëû has not observed a previous block ùëè
sent to ùëû by ùëù. If ùëû fail-stopped, then ùëù should definitely not waste
resources on ùëû; if ùëû is only suspended or delayed, then eventually
it will send to ùëù a block observing ùëè, following which ùëù‚Äîbeing
cordial‚Äîwill send to ùëû the backlog ùëù has previously refrained from
sending it, and is not observed by the new block received from ùëû.

7 CONCLUSIONS
An important next step towards making Cordial Miners a useful
foundation for cryptocurrencies is to design a mechanism that will
encourage miners to cooperate‚Äîas needed by these protocols‚Äîas
opposed to compete, which is the current standard in mainstream
cryptocurrencies.

ACKNOWLEDGMENTS
Oded Naor is grateful to the Azrieli Foundation for the award of
an Azrieli Fellowship. Ehud Shapiro is the Incumbent of The Harry
Weinrebe Professorial Chair of Computer Science and Biology at the
Weizmann Institute and a visiting scholar at Columbia University.
We thank Andrew Lewis-Pye for his comments on an earlier draft.

REFERENCES
[1] Ittai Abraham, Kartik Nayak, Ling Ren, and Zhuolun Xiang. 2021. Good-case
latency of byzantine broadcast: A complete categorization. In Proceedings of the
2021 ACM Symposium on Principles of Distributed Computing. 331‚Äì341.

[2] Hagit Attiya and Jennifer Welch. 2004. Distributed computing: fundamentals,

simulations, and advanced topics. Vol. 19. John Wiley & Sons.

[3] Leemon Baird. 2016. The Swirlds Hashgraph Consensus Algorithm: Fair, Fast,

Byzantine Fault Tolerance. Report. Swirlds.

[4] Dan Boneh, Ben Lynn, and Hovav Shacham. 2001. Short signatures from the Weil
pairing. In International conference on the theory and application of cryptology
and information security. Springer, 514‚Äì532.

[5] Gabriel Bracha. 1987. Asynchronous Byzantine agreement protocols. Information

and Computation 75, 2 (1987), 130‚Äì143.

[6] Gabriel Bracha and Sam Toueg. 1985. Asynchronous consensus and broadcast

protocols. Journal of the ACM (JACM) 32, 4 (1985), 824‚Äì840.

[7] Ethan Buchman. 2016. Tendermint: Byzantine fault tolerance in the age of

blockchains. Ph.D. Dissertation. University of Guelph.

[8] Vitalik Buterin et al. 2014. A next-generation smart contract and decentralized

application platform. white paper 3, 37 (2014).

[9] Christian Cachin, Klaus Kursawe, Frank Petzold, and Victor Shoup. 2001. Se-
cure and efficient asynchronous broadcast protocols. In Annual International
Cryptology Conference. Springer, 524‚Äì541.

[10] Christian Cachin, Klaus Kursawe, and Victor Shoup. 2005. Random oracles in Con-
stantinople: Practical asynchronous Byzantine agreement using cryptography.
Journal of Cryptology 18, 3 (2005), 219‚Äì246.

[11] Miguel Castro and Barbara Liskov. 1999. Practical Byzantine fault tolerance.
Proceedings of the third symposium on Operating systems design and implemen-
tation, USENIX Association, New Orleans, Louisiana, USA, 173‚Äì186.

[12] Gregory V Chockler, Nabil Huleihel, and Danny Dolev. 1998. An adaptive totally
ordered multicast protocol that tolerates partitions. In Proceedings of the seven-
teenth annual ACM symposium on Principles of distributed computing. 237‚Äì246.
[13] Shir Cohen, Rati Gelashvili, Lefteris Kokoris Kogias, Zekun Li, Dahlia Malkhi,
Alberto Sonnino, and Alexander Spiegelman. 2021. Be Aware of Your Leaders.
arXiv:2110.00960 [cs.DC]

[14] Cypherium. 2022. Cypherium. https://www.cypherium.io.
[15] George Danezis and David Hrycyszyn. 2018. Blockmania: from block dags to

consensus. arXiv preprint arXiv:1809.01620 (2018).

[16] George Danezis, Eleftherios Kokoris Kogias, Alberto Sonnino, and Alexander
Spiegelman. 2021. Narwhal and Tusk: A DAG-based Mempool and Efficient BFT
Consensus. arXiv preprint arXiv:2105.11827 (2021).

[17] Sourav Das, Zhuolun Xiang, and Ling Ren. 2021. Asynchronous Data Dissemi-
nation and Its Applications. In Proceedings of the 2021 ACM SIGSAC Conference
on Computer and Communications Security (Virtual Event, Republic of Korea)
(CCS ‚Äô21). Association for Computing Machinery, New York, NY, USA, 2705‚Äì2721.
https://doi.org/10.1145/3460120.3484808

[18] Sourav Das, Zhuolun Xiang, and Ling Ren. 2022. Near-optimal Balanced Reliable
Broadcast and Asynchronous Verifiable Information Dispersal. Cryptology ePrint
Archive (2022).

[19] Danny Dolev and Eli Gafni. 2016. Some garbage in-some garbage out: Asynchro-
nous t-Byzantine as asynchronous benign t-resilient system with fixed t-trojan-
horse inputs. arXiv preprint arXiv:1607.01210 (2016).

[20] Danny Dolev, Shlomo Kramer, and Dalia Malki. 1993. Early delivery totally
ordered multicast in asynchronous environments. In FTCS-23 The Twenty-Third
International Symposium on Fault-Tolerant Computing. IEEE, 544‚Äì553.

[21] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. 1988. Consensus in the
presence of partial synchrony. Journal of the ACM (JACM) 35, 2 (1988), 288‚Äì323.

[22] Flow. 2022. Flow. https://www.onflow.org.
[23] Adam GƒÖgol and Micha≈Ç ≈öwiƒôtek. 2018. Aleph: A leaderless, asynchronous,
byzantine fault tolerant consensus protocol. arXiv preprint arXiv:1810.05256
(2018).

[24] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zel-
dovich. 2017. Algorand: Scaling byzantine agreements for cryptocurrencies. In
Proceedings of the 26th Symposium on Operating Systems Principles. 51‚Äì68.
[25] Neil Giridharan, Lefteris Kokoris-Kogias, Alberto Sonnino, and Alexander Spiegel-
man. 2022. Bullshark: DAG BFT Protocols Made Practical. arXiv preprint
arXiv:2201.05677 (2022).

[26] Guy Golan Gueta, Ittai Abraham, Shelly Grossman, Dahlia Malkhi, Benny Pinkas,
Michael Reiter, Dragos-Adrian Seredinschi, Orr Tamir, and Alin Tomescu. 2019.
Sbft: a scalable and decentralized trust infrastructure. In 2019 49th Annual IEEE/I-
FIP international conference on dependable systems and networks (DSN). IEEE,
568‚Äì580.

[27] Sep Kamvar, Marek Olszewski, and Rene Reinsberg. 2019. Celo: A multi-asset
cryptographic protocol for decentralized social payments. DRAFT version 0.24
https://storage. googleapis. com/celo whitepapers/Celo A Multi Asset Cryptographic
Protocol for Decentralized Social Payments. pdf (2019).

[28] Idit Keidar, Eleftherios Kokoris-Kogias, Oded Naor, and Alexander Spiegelman.

2021. All You Need is DAG. arXiv:2102.08325 [cs.DC]

[29] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. 2017.
Ouroboros: A provably secure proof-of-stake blockchain protocol. In Annual
International Cryptology Conference. Springer, 357‚Äì388.

[30] Ramakrishna Kotla, Lorenzo Alvisi, Mike Dahlin, Allen Clement, and Edmund
Wong. 2007. Zyzzyva: speculative byzantine fault tolerance. In Proceedings of
twenty-first ACM SIGOPS symposium on Operating systems principles. 45‚Äì58.
[31] Leslie Lamport. 1978. Time, Clocks, and the Ordering of Events in a Distributed

System. Communications (1978).

[32] Beno√Æt Libert, Marc Joye, and Moti Yung. 2016. Born and raised distributively:
Fully distributed non-interactive adaptively-secure threshold signatures with
short shares. Theoretical Computer Science 645 (2016), 1‚Äì24.

[33] Louise E Moser and Peter M Melliar-Smith. 1999. Byzantine-resistant total
ordering algorithms. Information and Computation 150, 1 (1999), 75‚Äì111.

15

[34] Satoshi Nakamoto. 2019. Bitcoin: A peer-to-peer electronic cash system.
[35] Tsuneko Okazaki. 2017. Days weaving the lagging strand synthesis of DNA‚ÄîA
personal recollection of the discovery of Okazaki fragments and studies on
discontinuous replication mechanism‚Äî. Proceedings of the Japan Academy, Series
B 93, 5 (2017), 322‚Äì338.

[36] Serguei Popov. 2018. The Tangle. https://assets.ctfassets.net/r1dr6vzfxhev/

2t4uxvsIqk0EUau6g2sw0g/45eae33637ca92f85dd9f4a3a218e1ec/iota1_4_3.pdf.

[37] Ehud Shapiro. 2021. Multiagent Transition Systems: Protocol-Stack Mathematics

for Distributed Computing. arXiv preprint arXiv:2112.13650 (2021).

[38] Robert Shostak, Marshall Pease, and Leslie Lamport. 1982. The byzantine generals
problem. ACM Transactions on Programming Languages and Systems 4, 3 (1982),
382‚Äì401.

[39] Victor Shoup. 2000. Practical threshold signatures. In International Conference on
the Theory and Applications of Cryptographic Techniques. Springer, 207‚Äì220.
[40] Yonatan Sompolinsky and Aviv Zohar. 2015. Secure high-rate transaction pro-
cessing in bitcoin. In International Conference on Financial Cryptography and
Data Security. Springer, 507‚Äì527.

[41] Thunder. 2022. Thunder. https://www.thundercore.com/.
[42] Maofan Yin, Dahlia Malkhi, Michael K Reiter, Guy Golan Gueta, and Ittai Abra-
ham. 2019. HotStuff: BFT consensus with linearity and responsiveness. In Pro-
ceedings of the 2019 ACM Symposium on Principles of Distributed Computing.
347‚Äì356.

16

