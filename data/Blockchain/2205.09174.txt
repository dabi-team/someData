2
2
0
2

g
u
A
1
1

]

C
D
.
s
c
[

3
v
4
7
1
9
0
.
5
0
2
2
:
v
i
X
r
a

Cordial Miners: Blocklace-Based Ordering Consensus Protocols
for Every Eventuality

Idit Keidar
Technion

Oded Naor
Technion

Ehud Shapiro
Weizmann Institute of Science and
Columbia University

ABSTRACT
Cordial Miners are a family of efficient Byzantine Atomic Broad-
cast protocols, with instances for asynchrony and eventual syn-
chrony. Their efficiencyâ€”almost half the latency of state-of-the-art
DAG-based protocolsâ€”stems from not using reliable broadcast as a
building block. Rather, Cordial Miners use the blocklaceâ€”a partially-
ordered generalization of the totally-ordered blockchainâ€”for all
algorithmic tasks required for ordering consensus: Dissemination,
equivocation-exclusion, and ordering.

1 INTRODUCTION
1.1 Overview and Related Work
The problem of reaching consensus on the ordering of acts by par-
ticipants in a distributed system has been investigated for four
decades [38], with efforts in the last decade falling into two cate-
gories: Permissioned, where the set of participants is determined
by some authority, and permissionless, where anyone may join and
participate provided that they pass some â€˜sybil-proofâ€™ test, notably
proof-of-work [34] or proof-of-stake [29]. Two leaders-of-the-pack
in the permissioned category are the State-Machine-Replication
protocol (SMR, consensus on an ordering of proposals) for the
eventual-synchrony model â€“ Hotstuff [42] and its extensions and
variations [13], and the Byzantine Atomic Broadcast protocol (BAB,
consensus on an ordering of all proposals made by correct par-
ticipants) for the asynchronous model â€“ DAG-Rider [28] and its
extensions and variations [25]. Since the emergence of Bitcoin [34],
followed by Ethereum with its support for smart contracts [8],
permissionless consensus protocols have received the spotlight.

Recent conceptual and computational advances, notably stake-
based sampling, have allowed permissioned consensus protocols to
join the cryptocurrency fray (e.g. Cardano [29] and Algorand [24]),
offering much greater efficiency and throughput compared to proof-
of-work protocols. According to this approach, in every epoch
(which could be measured in minutes or weeks) a new set of miners
is chosen in a random auction, where the probability of being
an auction winner is correlated with the stake bid by the miner.
Mechanism design ensures that miners benefit from performing
the protocol well, benefit less if they perform the protocol less well,
and lose their stake if they subvert the protocol.

With this in mind, the expectation is that miners will do their
best, not their worst, to execute the protocol, and hence the focus
of analyses of permissioned consensus protocols has shifted from
worst-case complexity to good-case complexity [1, 25], where miners
are generally expected to behave as well as they can, given compute
and network limitations, as opposed to as bad as they can. Still,
standard protections against a malicious adversary are needed,
for example to prevent a double-spending, a hostile takeover, or

1

a meltdown of the cryptocurrency supported by the consensus
protocol.

The use of a DAG-like structure to solve consensus has been
introduced in previous works, especially in asynchronous net-
works [33]. Hashgraph [3] builds an unstructured DAG, with each
block containing two references to previous blocks, and on top of
the DAG the miners run an inefficient binary agreement protocol.
This leads to expected exponential time complexity. Aleph [23]
builds a structured round-based DAG, where miners proceed to
the next round once they receive 2ğ‘“ + 1 DAG nodes from other
miners in the same round. On top of the DAG construction protocol
a binary agreement protocol decides on the order of vertices to
commit. Nodes in the DAG are reliably broadcast. Blockmania [15]
uses a variant of PBFT [11] in the eventual synchrony model.

DAG-Rider [28] is a BAB protocol for the asynchronous model. It
assumes an adaptive adversary that controls the finite delay of mes-
sages between any two correct miners. In DAG-Rider, the miners
jointly build a DAG of blocks, with blocks as vertices and pointers
to previously-created blocks as edges, divided into strong and weak
edges. Strong edges are used for the commit rule, and weak edges
are used to ensure fairness. The protocol employs an underlying
reliable broadcast protocol of choice, which ensures that eventually
the local DAGs of all correct miners converge and equivocation is
excluded. Each miner independently converts its local DAG to an
ordered sequence of blocks, with the use of threshold signatures
to implement a global coin that retrospectively chooses one of the
miners as the leader for each round. The decision rule for delivering
a block is if the vertex created by the leader is observed by at least
2ğ‘“ + 1 miners three rounds after it is created. The DAG is divided
into waves, each consisting of the nodes of four rounds. When a
wave ends, miners locally check whether a decision rule is met, sim-
ilar to our protocol. DAG-Rider has an expected amortized linear
message complexity, and expected constant latency. Tusk [16] is an
implementation based on DAG-Rider. Bullshark [25] is the current
state-of-the-art dual consensus protocol based on DAG-Rider that
offers a fast-track to commit nodes every two rounds in case the
network is synchronous. Other DAG-based consensus protocols
include [12, 20, 36, 40].

HotStuff [42] is an SMR protocol designed for the eventual syn-
chrony model. The protocol employs all-to-leader, leader-to-all
communication: In each round, a deterministically-chosen desig-
nated leader proposes a block to all and collects from all signatures
on the block. Once the leader has 2ğ‘“ + 1 signatures, it can combine
them into a threshold signature [4] which it sends back to all. The
decision rule for delivering a block is three consecutive correct
leaders. This leads to a linear message complexity and constant
latency in the good case. The protocol delivers a block if there are
three correct leaders in a row, which is guaranteed to happen after

 
 
 
 
 
 
Latency

Protocol

Cordial Miners
Bullshark [25];
DAG-Rider [28] for Asynchrony

Eventual Synchrony
Good
2
4
8

Expected
4.5
9
18

Asynchrony

Good
5
8
16

Expected
7.5
12
24

Message
complexity

amortized ğ‘‚ (ğ‘›2)
amortized ğ‘‚ (ğ‘›2)
amortized ğ‘‚ (ğ‘›)

Table 1: Performance summary. Latency is measured in the number of communication rounds to finalize a correct leader block,
which in turn orders the blocks till the previous final leader. The Cordial Miners protocols have better latency than Bullshark
and DAG-Rider in both protocols and in both the good case and the expected case. Note that each formal round of Bullshark
and DAG-Rider employs reliable broadcast [5], which requires at least two rounds of communication of simple messages [1]
(ğ‘‚ (ğ‘›2) amortized message complexity), or four round with erasure coding [18] (ğ‘‚ (ğ‘›) amortized message complexity).

GST. HotStuff is based on Tendermint [7] and is also the core of sev-
eral other consensus protocols [14, 22, 27, 41]. In this model, there
are number of leader-based protocols such as DLS [21], PBFT [11],
Zyzzyva [30], and SBFT [26].

It is within this context that we introduce Cordial Miners â€“ a
family of simple, efficient, self-contained Byzantine Atomic Broad-
cast [9] protocols, and present two of its instances: Retrospective
random leader selection for the asynchronous model and determin-
istic leader selection for the eventual synchrony model (See Table
1 for their performance).

In a Cordial Miners protocol, correct miners cooperatively create
and share a blocklace, each contributing its own cryptographically-
signed blocks, with each new block observing all the blocks pre-
viously received or created by the miner. In addition, each miner
incrementally coverts its local blocklace into an ordered sequence
of blocks, which is the output of the protocol. We believe that the
simplicity-cum-efficiency of the Cordial Miners protocols stems
from the use of the blocklace data structure and its analysis for all
key algorithmic tasks (the following refers to correct miners):

(1) The Blocklace [37] is a partially-ordered generalization of the

totally-ordered blockchain (Def. 3.1), that consists of cryptographically-
signed blocks, each containing a payload and a finite number of
cryptographic hash pointers to previous blocks. The blocklace
induces a DAG, as cryptographic hash pointers cannot form
cycles by a compute-bound adversary. The DAG induces a par-
tial order â‰» (Def. 3.3) on the blocks that includes Lamportâ€™s
â€˜happened-beforeâ€™ causality relation [31] among correct min-
ers. The globally-shared blocklace is constructed incrementally
and cooperatively by all miners, who cordially disseminate it
to each other. In a run of a Cordial Miners protocol, the local
blocklaces of correct miners all converge to the same shared
global blocklace (Proposition 5.4), referred to as the blocklace
of the run.

(2) Ordering: The ordering algorithm (Algorithm 2) is used locally
by each miner to topologically-sort its local blocklace into a
totally-ordered output sequence of blocks, excluding equivoca-
tion along the way. This conversion is monotonic (Prop. 4.3)
â€“ the output sequence is extended as the miner learns of or
produces ever-larger portions of the global blocklace, and in
this sense every output block of each miner is final. We say
that two sequences are consistent if one is a prefix of the other
(Def. 2.2), a notion stronger than the common prefix property
of Ouroboros [29]. We assume that less than one-third of the

2

miners are faulty, and prove that the following holds for the
correct miners of the Cordial Miners protocols (Theorem 5.1):
â€¢ Safety: Outputs of correct miners are consistent.
â€¢ Liveness: A block sent by a correct miner is eventually out-

put by every correct miner.

(3) Dissemination: Any new block created by a miner ğ‘ observes
blocks known to ğ‘ by including pointers to the tips (DAG
sources) of ğ‘â€™s local blocklace. Correspondingly, a miner ğ‘ will
buffer, rather than include in its blocklace, any received block
with dangling pointers â€“ pointers to blocks not known to ğ‘.
Hence, a block ğ‘ by a correct miner ğ‘ informs its recipients
of blocks not known to ğ‘ at the time of ğ‘â€™s creation. Thus ğ‘,
being cordial, when sending to ğ‘ a new ğ‘-block, will include
with it blocks ğ‘ knows but, to the best of ğ‘â€™s knowledge, are
not yet known to ğ‘ and have not already been sent to ğ‘ by ğ‘,
thus ensuring block dissemination (Prop. 5.4).

(4) Equivocation exclusion: An equivocation (Def. 3.4) is a pair
of blocks by the same miner that are not causally-related â€“ have
no path of pointers from one to the other; a miner that creates
an equivocation is an equivocator and is considered faulty. A
key observation is that a miner cannot approve (Def. 3.5) both
blocks of an equivocation without being itself an equivocator
(Ob. 2). Hence, if less than one-third of the miners are equivo-
cators, then no equivocation will ever receive an approval from
blocks created by a supermajority (at least two-thirds) of the
miners. Thatâ€™s how blocklace-based is the basis of equivocation-
exclusion by the blocklace: A miner finalizes a block ğ‘ once its
local blocklace includes blocks that approve ğ‘ by a supermajor-
ity (Algorithm 2).

(5) Cordial Miners: The depth, or round, of a block ğ‘ is the max-
imal length of any path emanating from ğ‘ (Def. 3.1). A round
is a set of blocks of the same depth. Miners are cordial in two
respects. First, as explained above, in informing other miners
of blocks they believe the other miner lacks. Second, awaiting
a supermajority of round ğ‘‘ before producing a block of round
ğ‘‘ + 1 (Def. 3.14).

(6) Leader Selection: The Cordial Miners protocol for the eventual
synchrony model employs prospective leader selection (e.g.
via a shared pseudorandom function). In the asynchronous
model, the adversary has complete control over the order of
message delivery, indefinitely. The panacea to such an adversary,
employed for example by DAG-Rider [28], is to use a shared
random coin [10] and elect the leader retrospectively.

(7) Ratified and Super-Ratified Leaders: A block ğ‘ is ratified
by block ğ‘ â€² if [ğ‘ â€²] includes a cordial and non-equivocating
supermajority that approves ğ‘. A block ğ‘ âˆˆ ğµ is super-ratified in
blocklace ğµ if there is a supermajority of blocks in ğµ that ratify
ğ‘ (Def.3.10). Given a wavelength (ğ‘¤ = 2 for eventual synchrony
and ğ‘¤ = 5 for asynchrony), a leader block ğ‘ is final in blocklace
ğµ if the depth(ğ‘) + ğ‘¤ prefix of ğµ super-ratifies ğ‘ (Def. 3.10 and
Fig. 1).

(8) Blocklace Ordering with ğœ and Finality: We assume a topo-
logical sort procedure that takes a blocklace as an input and
produces a sequence of its blocks while respecting their causal
partial order â‰» and excluding equivocations along the way.
With it, an ordering function ğœ that converts a partially-ordered
blocklace ğµ to a totally-ordered output sequence is defined (Def.
4.1). The function ğœ, applied to a blocklace ğµ, seeks the highest-
depth final leader block ğ‘ âˆˆ ğµ and produced an ordering of [ğ‘].
It has the property that if [ğ‘] includes another final leader block
ğ‘ â€², then ğœ (ğ‘ â€²) is a prefix of ğœ (ğ‘). Hence, it is safe to compute ğœ
starting from any blocklace, and as the blocklace extends and
includes a new final leader block, then the output sequence
produced by ğœ would only extend the one computed already.
Hence any output of ğœ is final.

(9) Exclusion of faulty miners: Any faulty ğ‘-block known to
some correct miner will eventually be known to all, resulting in
correct miners suspending any further communication with ğ‘.
For example, any miner can easily verify whether another miner
ğ‘ is cordial in the second sense by examining the blocklace. In
addition, an equivocation by ğ‘, with each block of the pair
known to a different correct miner, will eventually be known
to all and result in the exclusion of ğ‘.

Miners accomplish all the above by simple and efficient analyses of
their local blocklace.

The reset of the paper is organized by the following Sections:

2. Provides an overview of the two models exploredâ€”asynchrony
and eventual synchronyâ€”the Byzantine Atomic Broadcast prob-
lem we aim to solve with the Cordial Miners protocols in the two
models, the safety and liveness requirements any solution must
satisfy, and the outline of the proof of safety and liveness of the
Cordial Miners protocols.

3. Introduces the notions of blocklace safety and liveness. The Block-
lace was introduced in reference [37], and its preliminaries are
reproduced in Section 3.1.

4. Introduces the blocklace ordering function ğœ, which is param-
eterized by the notion of final leader, and the requirements on
a blocklace for the safety and liveness of ğœ. It then provides
sufficient conditions for a blocklace-based ordering consensus
protocol to produce a blocklace that satisfies these requirements.
5. Introduces the Cordial Miners protocols and argue their safety

and liveness.

6. Discusses performance analysis, future optimizations and future

Cordial Miners protocols.

7. Concludes the paper.

2 MODELS, PROBLEM, SAFETY AND

LIVENESS

We assume ğ‘› â‰¥ 3 miners (aka agents, processors) Î , of which at
most ğ‘“ < ğ‘›/3 may be faulty (act under the control of the adversary,
be â€˜Byzantineâ€™), each equipped with a single and unique crypto-
graphic key-pair, with a public key known to others. Miners can
create, sign, and send messages to each other, where any message
sent from one correct miner to another is eventually received. In ad-
dition, each miner can sequentially output (aka â€˜deliverâ€™) messages
(e.g., to a local output device or storage device).

Definition 2.1. We consider two models of distributed computing

with an adversary:

(1) Asynchrony [6], in which an adversary controls up to ğ‘“

faulty miners and the finite delay of every message.

(2) Eventual Synchrony [21]: In addition, there is a point in
time, known as the global stabilization time (GST), beyond
which message delay among correct miners does not exceed
a known bound Î”.

Next we define the problem we aim to solve in this paper:

Definition 2.2 (Prefix, âª¯, Consistent Sequences). A sequence ğ‘¥ is
a prefix of a sequence ğ‘¥ â€², ğ‘¥ âª¯ ğ‘¥ â€², if ğ‘¥ â€² can be obtained from ğ‘¥ by
appending to it zero or more elements. Two sequences ğ‘¥, ğ‘¥ â€² are
consistent if ğ‘¥ âª¯ ğ‘¥ â€² or ğ‘¥ â€² âª¯ ğ‘¥.

Definition 2.3 (Safety and Liveness of an Ordering Consensus Pro-

tocol). An ordering consensus protocol is:

Safe if outputs of correct miners are consistent.
Live if a message sent by a correct miner is eventually output
by every correct miner with probability 1.

Problem: Devise safe and live ordering consensus pro-
tocols for the models of distributed computing with an
adversary.

We note that safety and liveness, combined with message unique-
ness (e.g., a block in a blocklace, see next), imply the standard
Byzantine Atomic Broadcast guarantees: Agreement, Integrity, Va-
lidity, and Total Order [5, 28]. Hence, the blocklace-based Cordial
Miners protocols that address the problem are in fact protocols for
Byzantine Atomic Broadcast [9].

3 THE BLOCKLACE
A blocklace [37] is a partially-ordered generalization of the totally-
ordered blockchain: In a blocklace, each block may contain a finite
set of cryptographic hash pointers to previous blocks, in contrast
to one pointer (or zero for the initial/genesis block) in a blockchain.
Next we present the basic definitions and results from [37]. Please
consult the original reference for explanations and proofs. Blocklace
utilities that realize these notions are presented in Algorithm 1.
These are followed by definitions and results needed for establishing
the safety and liveness of blocklace-based consensus protocols.

3.1 Blocklace Basics
In addition to the set of miners Î , we assume a given set of payloads
A and a cryptographic hash function hash.

3

Definition 3.1 (Block, Acknowledge). A block over Î , A and hash
is a triple ğ‘ = (ğ‘, ğ‘, ğ» ), referred to as a ğ‘-block, ğ‘ âˆˆ Î , with ğ‘ âˆˆ A
being the payload of ğ‘, and ğ» is a finite set of hash pointers to
blocks, namely for each â„ âˆˆ ğ» , â„ = hash(ğ‘ â€²) for some block ğ‘ â€² in
which case we also say that ğ‘ acknowledges ğ‘ â€². If ğ» = âˆ… then ğ‘ is
initial.

In a concrete implementation, a ğ‘-block is encoded by a string
signed by ğ‘. Note that hash being cryptographic implies that a set
of blocks that form a cycle cannot be effectively computed. A set of
blocks ğµ induces a finite-degree directed graph (ğµ, ğ¸), ğ¸ âŠ‚ ğµ Ã— ğµ,
with blocks ğµ as vertices and directed edges (ğ‘, ğ‘ â€²) âˆˆ ğ¸ if ğ‘ âˆˆ ğµ
includes a hash pointer to ğ‘ â€² âˆˆ ğµ. We overload ğµ to also mean its
induced directed graph (ğµ, ğ¸).

Definition 3.2 (Blocklace). Let B be the maximal set of blocks
over Î , A and hash for which the induced directed graph (B, E) is
acyclic. A blocklace over A is a set of blocks ğµ âŠ† B.

Note that the directed graph induced by a blocklace ğµ âŠ‚ B is
acyclic. The two key blocklace notions used in our protocols are
observation and approval.

Definition 3.3 (â‰», Observe). The strict partial order â‰» is defined
by ğ‘ â€² â‰» ğ‘ if there is a nonempty path from ğ‘ â€² to ğ‘. A block ğ‘ â€²
observes ğ‘ if ğ‘ â€² âª° ğ‘. Miner ğ‘ observes ğ‘ in ğµ if there is a ğ‘-block
ğ‘ â€² âˆˆ ğµ that observes ğ‘, and a group of miners ğ‘„ âŠ† Î  observes ğ‘
in ğµ if every miner ğ‘ âˆˆ ğ‘„ observes ğ‘.

We note that â€˜observeâ€™ is the transitive closure of â€˜acknowledgeâ€™.
With this, we can define the basic notion of equivocation (which
may result in double-spending when payloads are conflicting finan-
cial transactions). See Figure 1.A.

Definition 3.4 (Equivocation, Equivocator). A pair of ğ‘-blocks
ğ‘ â‰  ğ‘ â€² âˆˆ B, ğ‘ âˆˆ Î , form an equivocation by ğ‘ if they are not
consistent wrt â‰», namely ğ‘ â€² âŠ ğ‘ and ğ‘ âŠ ğ‘ â€². A miner ğ‘ is an
equivocator in ğµ, equivocator(ğ‘, ğµ), if ğµ has an equivocation by
ğ‘.

Namely, a pair of ğ‘-blocks form an equivocation of ğ‘ if neither
observes the other. As any ğ‘-block is cryptographically signed by
ğ‘, an equivocation by ğ‘ is a volitional fault of ğ‘.

Definition 3.5 (Approval). Given blocks ğ‘, ğ‘ â€² âˆˆ B, the block ğ‘
approves ğ‘ â€² if ğ‘ observes ğ‘ â€² and does not observe any block ğ‘ â€²â€² that
together with ğ‘ â€² forms an equivocation. A miner ğ‘ âˆˆ Î  approves
ğ‘ â€² in ğµ if there is a ğ‘-block ğ‘ âˆˆ ğµ that approves ğ‘ â€², in which case we
also say that ğ‘ approves ğ‘ â€² in ğµ. A set of miners ğ‘„ âŠ† Î  approve
ğ‘ â€² in ğµ if every miner ğ‘ âˆˆ ğ‘„ approves ğ‘ â€² in ğµ.

Observation 1. Approval is monotonic wrt âŠƒ.

Namely, if miner ğ‘ approves ğ‘ in ğµ it also approves ğ‘ in ğµâ€² âŠƒ ğµ.
A key observation is that a miner cannot approve an equivocation
of another miner in a blocklace ğµ without being an equivocator in
ğµ itself (Fig. 1.A):

Observation 2. [Approving an Equivocation] If miner ğ‘ âˆˆ Î  ap-
proves an equivocation ğ‘1, ğ‘2 in a blocklace ğµ âŠ† B, then ğ‘ is an
equivocator in ğµ.

4

Definition 3.6 (Closure, Closed, Tip). The closure of ğ‘ âˆˆ B wrt
â‰» is the set [ğ‘] := {ğ‘ â€² âˆˆ B : ğ‘ âª° ğ‘ â€²}. The closure of ğµ âŠ‚ B wrt â‰»
is the set [ğµ] := (cid:208)ğ‘ âˆˆğµ [ğ‘]. A blocklace ğµ âŠ† B is closed if ğµ = [ğµ].
A block ğ‘ âˆˆ B is a tip of ğµ if [ğ‘] = [ğµ] âˆª {ğ‘}.

Note that a blocklace ğµ is closed iff its blocks to not contain

â€˜dangling pointersâ€™ to blocks not in ğµ.

Definition 3.7 (Block Depth/Round, Blocklace Prefix & Suffix). The
depth (or round) of a block ğ‘ âˆˆ B, depth(ğ‘), is the maximal length
of any path of pointers emanating from ğ‘. For a blocklace ğµ âŠ† B and
ğ‘‘ â‰¥ 0, the depth-ğ‘‘ prefix of ğµ is ğµ(ğ‘‘) := {ğ‘ âˆˆ ğµ : depth(ğ‘) â‰¤ ğ‘‘ },
and the depth-ğ‘‘ suffix of ğµ is Â¯ğµ(ğ‘‘) := ğµ \ ğµ(ğ‘‘)

3.2 Blocklace Safety
As equivocation is a fault, at most ğ‘“ miners may equivocate.

Definition 3.8 (Supermajority). A set of miners ğ‘ƒ âŠ‚ Î  is a super-
majority if |ğ‘ƒ | > ğ‘›+ğ‘“
. A set of blocks ğµ is a supermajority if the
set of miners ğ‘ƒ = {ğ‘ âˆˆ Î  : ğ‘ âˆˆ ğµ is a ğ‘-block} is a supermajority.

2

Note that a supermajority is defined to be large enough to nec-
essarily include a majority of the correct miners. Also note that if a
faulty miner is exposed and repelled by the correct miners, such
a step effectively deducts 1 from both ğ‘› and ğ‘“ , causing the super-
majority to decrease, reaching simple majority when all ğ‘“ faulty
miners are exposed and repelled, namely ğ‘“ = 0. As the Cordial
Miners protocol does expose and repel faulty miners, the notion
of supermajority is preferred over the standard formulas of ğ‘› âˆ’ ğ‘“
or 2ğ‘“ + 1, as they converge to all or none, respectively, rather than
to majority when exposed faulty miners are deducted from both ğ‘“
and ğ‘›.

Lemma 3.9 (No Supermajority Approval for Eqivocation).
If there are at most ğ‘“ equivocators in a blocklace ğµ âŠ‚ B with an equiv-
ocation ğ‘, ğ‘ â€² âˆˆ ğµ, then not both ğ‘, ğ‘ â€² have supermajority approval in
ğµ.

Next, we introduce the notions of ratification (Figure 1.B) and
super-ratification (Figure 1.C), which is the blocklace algebraic
counterpart of the conditions for â€˜commit & terminateâ€™ of Byzantine
reliable broadcast protocols [1].

Definition 3.10 (Ratified and Super-Ratified Block). A block ğ‘ âˆˆ B
is ratified by block ğ‘ â€² if [ğ‘ â€²] includes a supermajority of blocks
that approve ğ‘. It is super-ratified in blocklace ğµ âŠ‚ B if ğµ includes
a supermajority of blocks, each of which ratifies ğ‘.

Definition 3.11 (Wavelength, Leader Selection Function, Leader
Block). Given a wavelength ğ‘¤ â‰¥ 1, a leader selection function
is a partial function ğ‘™ : N â†¦â†’ Î  satisfying ğ‘™ (ğ‘Ÿ ) âˆˆ ğ‘ƒ if ğ‘Ÿ mod ğ‘¤ = 0
else ğ‘™ (ğ‘Ÿ ) = âŠ¥. A ğ‘-block ğ‘ is a leader block if ğ‘™ (depth(ğ‘)) = ğ‘.

Note that an equivocating leader can have several leader blocks
in the same round. In the following we assume given wavelength
ğ‘¤ â‰¥ 1 and a leader selection function ğ‘™. The following definition
has two cases: The first applies to retrospective leader selection,
employed by the Cordial Miners protocol for asynchrony using a
shared coin; the second to prospective leader selection, employed
by the Cordial Miners protocol for eventual synchrony. See Figure
1.B.

Figure 1: Observation, Equivocation, Approval, Ratification, Super-Ratification: (A) Observing an Equivocation: The â€˜drop
shapeâ€™ depicts a blocklace with a block at the tip of the drop that observes all the blocks inside the drop. Initial blocks are
at the bottom, and inclusion among two drops implies â‰» among their tips. Assume ğ‘1, ğ‘2 are an equivocation (Def. 3.4) by the
red miner. According to the figure, the green block approves ğ‘2 (Def. 3.5) since it observes ğ‘2 (Def. 3.3) and does not observe
any conflicting red block, in particular it does not observe ğ‘1. However, since the purple block observes the red green block,
it observes both ğ‘1 and ğ‘2 and hence does not approve the equivocating ğ‘1 (nor ğ‘2). (B) Ratified: The blue block (blue dot) is
ratified by the red block (red dot), since the red block observes a supermajority (thick green horizontal line) that approves
the blue block. (C) Super-Ratified: The blue block is super-ratified by the red supermajority (thick red horizontal line), each
member of which ratifies the blue block by observing a green supermajority (possibly a different one for each member of the
red supermajority) that approves the blue block. A leader is final if super-ratified within a protocol-specific wave (number of
rounds).

Algorithm 1 Cordial Miners: Blocklace Utilities
pseudocode for miner ğ‘ âˆˆ Î 

Local variables:
struct block ğ‘:

ğ‘.creator â€“ the miner that created ğ‘
ğ‘.payload â€“ a set of transactions
ğ‘.pointers â€“ a possibly-empty set of hash pointers to other blocks

new ğ‘
ğ‘.payload â† payload()
ğ‘.creator â† ğ‘
ğ‘.pointers â† â„ğ‘ğ‘ â„ (ğ‘¡ğ‘–ğ‘ğ‘ ), where tips are the tips of blocklace_prefix (ğ‘‘)
blocklace â† blocklace âˆª {ğ‘ }
output_blocks()
return ğ‘

blocklace â† { }
1: procedure create_block(ğ‘‘)
2:
3:
4:
5:
6:
7:
8:
9: procedure hash(ğ‘) return collision-free cryptographic hash pointer to block ğ‘
10: procedure ğ‘ âª° ğ‘â€²
11:

return âˆƒğ‘1, ğ‘2, . . . , ğ‘ğ‘˜ âˆˆ blocklace, ğ‘˜ â‰¥ 1, s.t. ğ‘1 = ğ‘, ğ‘ğ‘˜ = ğ‘â€² and âˆ€ğ‘– âˆˆ [ğ‘˜ âˆ’ 1] : hash(ğ‘ğ‘–+1) âˆˆ ğ‘ğ‘– .pointers

âŠ² Also referred to as [ğ‘ ]. ğ‘ could also be any subset of blocklace.

12: procedure closure(ğ‘) return {ğ‘â€² âˆˆ blocklace : ğ‘ âª° ğ‘â€² }
13: procedure equivocation(ğ‘1, ğ‘2) return ğ‘1.creator = ğ‘2.creator âˆ§ ğ‘1 âª°Ì¸ ğ‘2 âˆ§ ğ‘2 âª°Ì¸ ğ‘1
14: procedure equivocator(ğ‘, ğ‘) return âˆƒğ‘1, ğ‘2 âˆˆ [ğ‘ ] âˆ§ ğ‘1.creator = ğ‘2.creator = ğ‘ âˆ§ equivocation(ğ‘1, ğ‘2)
15: procedure approves(ğ‘, ğ‘1) return ğ‘ âª° ğ‘1 âˆ§ (ğ‘ âª° ğ‘2 =â‡’ Â¬equivocation(ğ‘1, ğ‘2))
16: procedure ratifies(ğ‘1, ğ‘2) return {ğ‘.creator : ğ‘1 âª° ğ‘ âˆ§ approves(ğ‘, ğ‘2) } is a supermajority
17: procedure depth(ğ‘) return max {ğ‘˜ : âˆƒğ‘â€² âˆˆ blocklace with a path from ğ‘ to ğ‘â€² of length ğ‘˜}.
18: procedure blocklace_prefix(ğ‘‘) return {ğ‘ âˆˆ blocklace : depth(ğ‘) â‰¤ ğ‘‘ }

5

âŠ² The structure of a block ğ‘ in a blocklace, Def. 3.1

âŠ² The local blocklace of miner ğ‘
âŠ² Add to blocklace a new block ğ‘ of depth ğ‘‘ + 1
âŠ² Allocate a new block structure
âŠ² e.g., dequeue a payload from a queue of proposals (aka mempool)

âŠ² Def. 3.6

âŠ² Def. 3.3

âŠ² Def. 3.6

âŠ² Def. 3.4, Fig. 1.A

âŠ² Def. 3.4, Fig. 1.A

âŠ² Def. 3.5, Fig. 1.A

âŠ² Def. 3.10, Fig. 1.B

âŠ² Def. 3.7

âŠ² Def. 3.7

Figure 2: Finality of a Super-Ratified Leader (Definition 3.12): Assume that a leader block (blue dot) is super-ratified. A ratifying
supermajority is represented by a thick red line, each member of which observes a possibly-different approving supermajority
represented by a green thick line. We show that the blue leader is ratified by any subsequent cordial leader. (A) The successive
cordial leader (red dot) is part of the ratifying supermajority. (B) The successive cordial leader (purple dot) is one round follow-
ing the ratifying supermajority. Being cordial, it observes a supermajority (thick purple line) that must have an intersection
(black dot) with the ratifying supermajority, hence it observes an approving supermajority and thus ratifies the blue leader.
(C) A successive leader is more than one round following the ratifying supermajority. Being cordial, it observes a superma-
jority (thick purple line). There must be a correct miner common to the purple and red supermajority, with blocks in both
(black dots); being a correct miner, its later block observes the earlier block (black line). Hence the purple leader observes the
approving supermajority (via black lines) and hence ratifies the blue leader.

Definition 3.12 (Final Leader Block). Let ğµ âŠ† B be a blocklace. A

leader block ğ‘ âˆˆ B of round ğ‘Ÿ is final in ğµ if:

(1) Retrospective: It is super-ratified in ğµ(ğ‘Ÿ + ğ‘¤ âˆ’ 1), or
(2) Prospective: It is super-ratified in ğµ(ğ‘Ÿ + ğ‘¤) and the leader

block of round ğ‘Ÿ + ğ‘¤ also ratifies ğ‘.

The following notion of blocklace safety is the basis for the
monotonicity of the blocklace ordering function ğœ, and hence for
the safety of a protocol that uses ğœ for blocklace ordering.

Definition 3.13 (Blocklace Leader Safety). A blocklace ğµ is leader-
safe if every final leader block in ğµ is ratified by every subsequent
leader block in ğµ.

Next, we identify a sufficient condition for blocklace leader

safety.

Definition 3.14 (Cordial Block, Blocklace). A block ğ‘ âˆˆ B of round
ğ‘Ÿ is cordial if it acknowledges blocks by a supermajority of miners.
A blocklace ğµ âŠ‚ B is cordial if all its blocks are cordial.

The following proposition ensures that in a cordial blocklace, a
final leader block is ratified by any subsequent leader block. See
Figure 2.

Proposition 3.15 (Cordial Blocklace Leader Safety). A cor-

dial blocklace is leader-safe.

Proof of Proposition 3.15. Let ğµ be a cordial blocklace and
ğ‘ âˆˆ ğµ (blue dot) a final leader block of round ğ‘Ÿ in ğµ. We have to
show ğ‘ is ratified by any subsequent leader block in ğµ. We consider

in turn the two cases in Definition 3.12, and in reference to the
three cases in Figure 2. Consider the case of a prospective leader, in
which the leader of round ğ‘Ÿ + ğ‘¤ is included in the ratifying super
majority:

A. The subsequent leader block ğ‘ â€² of round ğ‘Ÿ + ğ‘¤ (red dot)
ratifies ğ‘ by definition. For a further subsequent leader block
ğ‘ â€² (purple dot) of a round ğ‘Ÿ â€² > ğ‘Ÿ + ğ‘¤, there are two cases:
B. There is an overlap between the supermajority observed by
ğ‘ â€² at round ğ‘Ÿ â€² âˆ’ 1 (thick purple line) and the supermajority
that ratifies ğ‘ (thick red line). Then there is a block ğ‘ â€²â€² (black
dot) shared by both, hence ğ‘ â€² observes ğ‘ â€²â€², which observes a
supermajority (thick green line) that approves ğ‘, hence ğ‘ â€²
ratifies ğ‘.

C. The supermajority observed by ğ‘ â€² at round ğ‘Ÿ â€² âˆ’ 1 (thick
purple line) is of a later round than the members of the su-
permajority that ratifies ğ‘ (thick red line). By counting, there
is a non-equivocating miner ğ‘ âˆˆ ğ‘ƒğ‘– with a block ğ‘1 in the
purple supermajority and a block ğ‘2 in the red supermajor-
ity (black dots). Since ğ‘ is non-equivocating, ğ‘1 observes ğ‘2.
Hence, ğ‘ â€² observes ğ‘1, which observes ğ‘2, which observes
the green supermajority that approves ğ‘, hence ğ‘ â€² ratifies ğ‘.

For the retrospective notion of a final leader, the arguments in cases
â–¡
B and C above apply as is. This completes the proof.

3.3 Blocklace Liveness
The notion of blocklace leader liveness is defined thus:

6

Definition 3.16 (Blocklace Leader Liveness). A blocklace ğµ is leader-

live if for every block ğ‘ âˆˆ ğµ by a miner not equivocating in ğµ there
is a final leader block in ğµ that observes ğ‘.

Next, we discuss conditions that ensure blocklace leader liveness.
Given a blocklace, a set of miners ğ‘ƒ is (mutually) disseminating if
every block by a miner in ğ‘ƒ is eventually observed by every miner
in ğ‘ƒ.

Definition 3.17 (Disseminating). Given a blocklace ğµ âŠ† B, a set of
miners ğ‘ƒ âŠ† Î  is mutually disseminating in ğµ, or disseminating
for short, if for any ğ‘, ğ‘ âˆˆ ğ‘ƒ and any ğ‘-block ğ‘ âˆˆ ğµ there is a ğ‘-block
ğ‘ â€² âˆˆ ğµ such that ğ‘ â€² â‰» ğ‘. The blocklace ğµ is disseminating if it has
a disseminating supermajority.

Observation 3 (Dissemination is Unbounded). If a set of miners
ğ‘ƒ âŠ† Î , |ğ‘ƒ | > 1, are disseminating in a blocklace ğµ that includes a
ğ‘-block, ğ‘ âˆˆ ğ‘ƒ, then ğµ is infinite and any suffix of ğµ has blocks by
every member of ğ‘ƒ.

The following liveness condition will be proven for each Cordial

Miners protocol, thus establishing their liveness (Figure 3).

Proposition 3.18 (Blocklace Leader Liveness Condition). If
ğµ âŠ‚ B is a cordial blocklace with a non-equivocating and dissemi-
nating supermajority of miners, such that for every ğ‘Ÿ > 0 there is a
final leader block of round ğ‘Ÿ â€² > ğ‘Ÿ , then ğµ is leader-live.

Figure 3: Liveness Condition, Proposition 3.18

Proof of Proposition 3.18. Let ğµ âŠ‚ B be a cordial blocklace
and ğ‘ƒ âŠ† Î  a supermajority of miners non-equivocating and dissem-
inating in ğµ. Let ğ‘ be a ğ‘-block by a miner ğ‘ âˆˆ ğ‘ƒ (blue dot in Figure
3). As ğ‘ƒ are disseminating in ğµ, then for every ğ‘ âˆˆ ğ‘ƒ there is a first
ğ‘-block ğ‘ğ‘ âˆˆ ğ‘ƒ that observes ğ‘; let ğ‘Ÿ be the maximal round of any
of these blocks (thick horizontal red line). By assumption, ğµ has a
final leader block Ë†ğ‘ of round Ë†ğ‘Ÿ > ğ‘Ÿ (purple dot). As Ë†ğ‘ is cordial, it

7

must observe a block ğ‘ â€²
ğ‘ of depth Ë†ğ‘Ÿ âˆ’ 1 of a miner ğ‘ âˆˆ ğ‘ƒ (black dot).
As ğ‘ is non-equivocating, there is a (possible empty) path from ğ‘ â€²
ğ‘
to ğ‘ğ‘ (black path among black dots), and from there to ğ‘ (blue line).
Hence Ë†ğ‘ observes ğ‘.
â–¡

4 BLOCKLACE ORDERING WITH ğœ: SAFETY

AND LIVENESS

Here we present a deterministic function ğœ that, given a block ğ‘,
employs final leaders to topologically sort the blocklace [ğ‘] into
a sequence of its blocks, respecting â‰». The intention is that in a
blocklace-based ordering consensus protocol, each miners would
use ğœ to locally convert their partially-ordered blocklace into the
totally-ordered output sequence of blocks.

The section concludes with Theorem 4.6, which provides suffi-
cient conditions for the safety and liveness of any blocklace-based
ordering consensus protocol that employs ğœ. In the following section
we prove that the Cordial Miners protocols, which employ Algo-
rithm 2 that realizes ğœ, satisfy these conditions, and thus establish
their safety and liveness.

We show that if ğœ is called with a sequence of super-ratified
blocks increasing wrt â‰» then its output is monotonic wrt to the
subset relation. This monotonicity ensures finality, as it implies
that the output sequence will only extend while the local blocklace
that is the input of ğœ increases over time. With ğœ, final leaders are
the anchors of finality in the growing chain, each â€˜writes historyâ€™
backwards till the preceding final leader. We use the term â€˜Okazaki
fragmentsâ€™ for the sequences computed backwards from each leader
to its predecessor, acknowledging the analogy with the way one of
the DNA strands of a replicated DNA molecule is elongated via the
stitching of backwards-synthesized Okazaki-fragments [35].

Proposition 4.3 ensures that given a blocklace ğµ, a super-ratified
leader ğ‘ in ğµ will be ratified by any subsequent cordial leader, and
hence will always initiate an Okazaki-fragment in any execution of
ğœ with any subsequent final leader. Hence, the final sequence up to a
super-ratified leader ğ‘ is fully-determined by ğ‘ itself independently
of the (continuously changing) identity of the last super-ratified
leader. Hence the final sequence up to a super-ratified leader ğ‘ can
be â€˜cachedâ€™ and will not change as the blocklace increases. Propo-
sition ensures that if ğœ is incrementally applied to a leader-live
blocklace, then any block in its input blocklace will eventually be in-
cluded in its output sequence. Together they provide the conditions
for Theorem 4.6.

The following recursive ordering function ğœ maps a blocklace
into a sequence of blocks, excluding equivocations along the way.
Formally, the entire sequence is computed backwards from the last
super-ratified leader, afresh by each application of ğœ. Practically, a
sequence up to a super-ratified leader is final (Prop. 4.3) and hence
can be cached, allowing ğœ to be computed from the new super-
ratified leader backwards through previous ratified leaders, and
to output all the blocks approved by the new leader (the approval
ensures that the new fragment does not introduce equivocations)
that are not observed by the previous final leader.

Definition 4.1 (ğœ). We assume a fixed topological sort function
xsort(ğ‘, ğµ) (exclude and sort) that takes a block ğ‘ and a blocklace
ğµ, and returns a sequence consistent with â‰» of all the blocks in ğµ
that are approved by ğ‘. The function ğœ : 2B âˆ’â†’ Bâˆ— is defined for a

blocklace ğµ âŠ‚ B backwards, from the last output element to the
first, as follows: If ğµ has no final leaders then ğœ (ğµ) := Î›. Else let ğ‘
be the last final leader in ğµ. Then ğœ (ğµ) := ğœ â€²(ğ‘), where ğœ â€² is defined
recursively:

ğœ â€²(ğ‘) :=

xsort(ğ‘, [ğ‘]) if [ğ‘] has no leader ratified by ğ‘, else
ï£±ï£´ï£´ï£´ï£²
ğœ â€²(ğ‘ â€²) Â· xsort(ğ‘, [ğ‘] \ [ğ‘ â€²]) if ğ‘ â€² is the last leader
ï£´ï£´ï£´
ï£³

ratified by ğ‘ in [ğ‘]

Note that ğœ â€² uses the notion of a leader ratified by another leader,

not a final leader.

A pseudo-code implementation of ğœ is presented as Algorithm
2. The Algorithm is a literal implementation of the mathematics
described above: It maintained outputBlocks that includes the prefix
of the output ğœ has already computed. Upon adding a new block to
its blocklace (line 19), it computes the most-recent final leader ğ‘1
according to Definition 3.12, and applies ğœ to it, realizing the math-
ematical definition of ğœ (Def. 4.1), with the optimization, discussed
above, that a recursive call with a block that was already output is
returned. Hence the following proposition:

Proposition 4.2 (Correct implementation of ğœ). The proce-
dure ğœ in Algorithm 2 correctly implements the function ğœ in Definition
4.1.

4.1 ğœ Safety
A safe blocklace ensures a final leader is ratified by any subsequent
leader, final or not. Hence the following:

Proposition 4.3 (Monotonicity of ğœ). Let ğµ be a cordial block-
lace with a supermajority of correct miners. Then ğœ is monotonic wrt
the superset relation among closed subsets of ğµ, namely for any two
closed blocklaces ğµ2 âŠ† ğµ1 âŠ† ğµ, ğœ (ğµ2) âª¯ ğœ (ğµ1).

Proof of Proposition 4.3. Let ğµ, ğµ1, ğµ2 be blocklaces as assumed

by the Proposition. If ğµ2 has no final leader then ğœ (ğµ2) is the empty
sequence and the proposition holds vacuously. Let Ë†ğ‘2 be the last
final leader of ğµ2 and Ë†ğ‘1 be the last final leader of ğµ1. Note that
according to Definition4.1, ğœ (ğµ1) calls ğœ â€²(Ë†ğ‘1) and ğœ (ğµ2) calls ğœ â€²(Ë†ğ‘2).
Let ğ‘1, ğ‘2 . . . , ğ‘ğ‘˜ , ğ‘˜ â‰¥ 2, be the sequence of ratified leaders in the
recursive calls of the execution of ğœ â€²(Ë†ğ‘1), starting with ğ‘1 = Ë†ğ‘1. We
argue that Ë†ğ‘2 is called in this execution, namely Ë†ğ‘2 = ğ‘ ğ‘— for some
ğ‘— âˆˆ [ğ‘˜]. Note that according to Proposition 3.15, Ë†ğ‘1 = ğ‘1, being
cordial, ratifies Ë†ğ‘2. Let ğ‘— âˆˆ [ğ‘˜] be the last index for which ğ‘ ğ‘— ratifies
Ë†ğ‘2. We argue by way of contradiction that ğ‘ ğ‘—+1 = Ë†ğ‘2. Consider
three cases regarding the relative depths of ğ‘ ğ‘—+1 and Ë†ğ‘2:

= Note that two different blocks of the same depth cannot
observe each other: If only one observes the other, it is one
deeper than the other; if both observe each other they form a
cycle, which is impossible. Since both ğ‘ ğ‘—+1 and Ë†ğ‘2 are leader
blocks of the same depth, then they must be by the same
leader, and hence, being different blocks by the same miner
that do not observe each other, they form an equivocation.
By assumption, both are ratified, implying that both have
supermajority approval, contradicting the assumption that
there is a supermajority of correct miners in ğµ.

Figure 4: The Operation of ğœ, Safety and Liveness: (A) The In-
put of ğœ: A blocklace with final leaders (large dots) and lead-
ers ratified by their successors (small dots). Each leader ob-
serves the portion of the blocklace below it (including the
lines emanating from it). (B) The Output of ğœ: A sequence
of blocks consisting of â€˜Okazakiâ€™ fragments. The sequence
of fragments are computed recursively backwards, starting
from the last final leader, and back from each leader to the
previous leader it ratifies. The input to computing the frag-
ment consists of the portion of the blocklace observed by
the current leader but not observed by the previous rati-
fied leader. The output form each fragment is a sequence
of blocks computed forward by topological sort of the in-
put blocklace fragment, respecting â‰» and using the leader
of the fragment to resolve and exclude equivocations. Final
leaders are final, hence the backwards computation start-
ing from the last purple final leader need not proceed be-
yond the recursive call to the previous red final leader, as
the output sequence up to the previous final leader has al-
ready been computed by the previous invocation of ğœ. Safety
Requirement: A final leader (large dot) is ratified by any sub-
sequent leader (large or small dot). Liveness Requirement:
Any leader will eventually have a subsequent final leader
(large dot) with probability 1. (C) Leader-Based Equivocation
Exclusion: The green Okazaki fragment created by the green
leader includes the ğ‘‰ -marked red block, since the green
leader does not observe the red equivocation. However, the
red ğ‘‹ -marked red block is excluded from the purple frag-
ment created by the purple leader, since the purple leader
observes the equivocation among the two red blocks. (See
also Figure 1.A)

8

Algorithm 2 Cordial Miners: Ordering of a Blocklace with ğœ
pseudocode for miner ğ‘ âˆˆ Î , including Algorithms 1 & 4

Local Variable:

outputBlocks â† { }
currentLeader â† { }

19: procedure output_blocks()
20:
21:

currentLeader â† last_final_leader ()
ğœ (currentLeader)

22: procedure ğœ(ğ‘1)
23:

if ğ‘1 âˆˆ outputBlocks âˆ¨ ğ‘1 = âˆ… then return
ğ‘2 â† previous_ratified_leader(ğ‘1)
ğœ (ğ‘2)
output xsort(ğ‘1, [ğ‘1 ] \ [ğ‘2 ])
outputBlocks â† outputBlocks âˆª xsort(ğ‘1, [ğ‘1 ] \ [ğ‘2 ])

24:
25:
26:
27:

28: procedure xsort(ğ‘, ğµ)
29:

return topological sort wrt â‰» of the set {ğ‘â€² âˆˆ ğµ : approved(ğ‘â€², ğ‘) }

30: procedure previous_ratified_leader(ğ‘1)
return argğ‘âˆˆğ‘… max depth(ğ‘)
31:
where ğ‘… = {ğ‘ âˆˆ [ğ‘1 ] \ {ğ‘1 } : ğ‘.creator = leader(depth(ğ‘)) âˆ§ ratified(ğ‘, ğ‘1) }
32:

33: procedure last_final_leader()
34:
35:

return argğ‘¢âˆˆğ‘ˆ max depth(ğ‘¢) where
ğ‘ˆ = {ğ‘ âˆˆ blocklace : ğ‘.creator = leader(depth(ğ‘)) âˆ§ final_leader(ğ‘) }

procedure leader () is defined in Algorithm 4
procedure final_leader () is defined Algorithm 4

âŠ² Recursive call to ğœ
âŠ² Output a new equivocation-free â€˜Okazaki-fragmentâ€™

âŠ² Exclude equivocations and sort

âŠ² Figure 1.B

âŠ² Figure 2

> If ğ‘ ğ‘—+1 is deeper than Ë†ğ‘2, then by Definition 4.1, ğœ â€² elects the
first leader ratified by the current leader ğ‘ ğ‘— , and hence cannot
prefer calling ğ‘ ğ‘—+1 over Ë†ğ‘2, which precedes it by assumption.
< If Ë†ğ‘2 is deeper, then Proposition 3.15 implies that ğ‘ ğ‘—+1 ratifies
Ë†ğ‘2, in contradiction to the assumption that ğ‘ ğ‘— is the last
leader in the list that ratifies Ë†ğ‘2.

Hence Ë†ğ‘2 is included in the recursive calls of ğœ â€²(Ë†ğ‘1), which, accord-
â–¡
ing to Definition 4.1 of ğœ, implies that ğœ (ğµ2) âª¯ ğœ (ğµ1).

Observation 4 (Consistent triplet). Given three sequences ğ‘¥, ğ‘¥ â€², ğ‘¥ â€²â€²,
if both ğ‘¥ â€² âª¯ ğ‘¥ and ğ‘¥ â€²â€² âª¯ ğ‘¥ then ğ‘¥ â€² and ğ‘¥ â€²â€² are consistent.

The following Proposition ensures that if there is a supermajority
of correct miners, which jointly create a cordial blocklace, then the
output sequences computed by any two miners based on their local
blocklaces would be consistent. This establishes the safety of ğœ
under these conditions.

Proposition 4.4 (ğœ Safety). Let ğµ be a blocklace with a superma-
jority of correct miners. Then for every ğµ1, ğµ2 âŠ† ğµ, ğœ (ğµ1) and ğœ (ğµ2)
are consistent.

Proof of Proposition 4.4. By monotonicity of ğœ (Prop. 4.3),
both ğœ (ğµ1) âª¯ ğœ (ğµ1 âˆª ğµ2) and ğœ (ğµ2) âª¯ ğœ (ğµ1 âˆª ğµ2). By Obser-
â–¡
vation 4, ğœ (ğµ1) and ğœ (ğµ2) are consistent.

4.2 ğœ Liveness
While ğœ does not output all the blocks in its input, as blocks not
observed by the last final leader in its input are not in its output,

9

the following observation and proposition sets the conditions for ğœ
liveness:

Observation 5 (ğœ output).
If a ğ‘-block ğ‘ âˆˆ ğµ by a miner ğ‘ not
equivocating in ğµ is observed by a final leader in ğµ, then ğ‘ âˆˆ ğœ (ğµ).

Proof of Observation 5. Since ğ‘ is observed by a final leader
in ğµ, it is also observed by the last final leader of ğµ. Consider the
recursive construction of ğœ (ğµ). If in its last recursive call ğœ â€²(ğ‘ â€²), ğ‘ â€²
observes ğ‘, then by definition of ğœ, ğ‘ âˆˆ ğœ (ğ‘ â€²) and hence ğ‘ âˆˆ ğœ (ğµ).
Otherwise, consider the first recursive call ğœ â€²(ğ‘ â€²) by ğœ â€²(ğ‘ â€²â€²) in which
ğ‘ â€²â€² observes ğ‘ but ğ‘ â€² does not observe ğ‘. Then by definition of ğœ â€²,
ğ‘ âˆˆ ğœ â€²(ğ‘ â€²â€²) and hence ğ‘ âˆˆ ğœ (ğµ).
â–¡

Proposition 4.5 (ğœ Liveness). Let ğµ1 âŠ‚ ğµ2 âŠ‚ . . . be a sequence
of finite blocklaces for which ğµ = (cid:208)ğ‘– â‰¥1 ğµğ‘– is a cordial leader-live
blocklace. Then for every block ğ‘ âˆˆ ğµ by a correct miner in ğµ there is
an ğ‘– â‰¥ 1 such that ğ‘ âˆˆ ğœ (ğµğ‘– ).

Proof of Proposition 4.5. Let ğµ be as assumed and ğ‘ âˆˆ ğµ. As
ğµ is leader-live, there is a final leader block ğ‘ â€² that observes ğ‘. Let
ğ‘– â‰¥ 1 be an index for which ğµğ‘– includes ğ‘ â€². Consider the call ğœ (ğµğ‘– ).
Since ğ‘ is a final leader in ğµğ‘– than according to Observation 5, the
â–¡
output of ğœ (ğµğ‘– ) includes ğ‘.

And based on it, we conclude that the safety and liveness prop-

erties of ğœ carry over to Algorithm 2.

The following Theorem provides a sufficient condition for the
safety and liveness (Def. 2.3) of any blocklace-based ordering con-
sensus protocol that employs ğœ:

Theorem 4.6 (Sufficient Condition for the Safety and
Liveness of a Blocklace-Based Ordering Consensus Protocol).
A blocklace-based consensus protocol that employs ğœ for ordering is
safe and live if in every run all correct miners have in the limit the
same blocklace ğµ, and ğµ is leader-safe and leader-live.

Proof of Theorem 4.6. Let ğ‘ƒ âŠ† Î  be the correct miners in a
run of the protocol that produce in the limit the blocklace ğµ. The
protocol is safe since the local blocklaces of any two miners in
ğ‘, ğ‘ âˆˆ ğ‘ƒ at any time are subsets of ğµ, hence by Proposition 4.4
the outputs of ğ‘ and ğ‘ are consistent. The protocol is live since by
Proposition 4.5, every block ğ‘ âˆˆ ğµ will be output by every correct
â–¡
miner ğ‘ âˆˆ ğ‘ƒ.

Next, we prove that the two Cordial Miners consensus protocolsâ€”
eventual synchrony and asynchronyâ€”satisfy the conditions of The-
orem 4.6, and hence are safe and live.

5 THE CORDIAL MINERS PROTOCOLS
The shared components of the Cordial Miners protocols are spec-
ified via pseudocode in Algorithms 1 (blocklace utilities), 2 (the
ordering function ğœ) and 3 (dissemination). There are several dif-
ferences between the Cordial Miners protocols for eventual syn-
chrony and for asynchrony: Wavelength (2 or 5); leader selection
(prospective or retrospective); the notion of a final leader (whether
it includes ratification by the next leader or not); and when is a
round complete (based only on cordiality or also on including or
observing the leader or a timeout). These differences are summa-
rized in Table 2 and are specified via pseudocode in Algorithm 4.

The main Theorem we prove here is the following:

Theorem 5.1 (Cordial Miners Protocols Safety and Live-
ness). The Cordial Miners protocols for eventual synchrony and for
asynchrony specified in Algorithms 1, 2, 3 & 4 are safe and are live.

Proof Outline. We prove two propositions that together es-
tablish the Theorem: Proposition 5.5 shows that the two Cordial
Miners protocols are safe and Proposition 5.6 shows that they are
â–¡
live.

In the Cordial Miners protocols there is a tradeoff between la-
tency and messages complexity, analogously to this same tradeoff
in reliable-broadcast protocols [18], and there is a range of possible
optimizations and heuristics. These are discussed in Section 6. Here,
we present latency-optimal Cordial Miners protocols in which ev-
ery block is communicated among every pair of correct miners. In
a Cordial Miners protocol, each miner maintains a history array
that records its communication history with the other miners, and
updates it upon accepting (line 42) and sending (line 48) blocks.
When a miner ğ‘ creates a block ğ‘, it includes in it pointers to the
tip of its blocklace (line 45), so that [ğ‘] is identical to the updated
blocklace that includes ğ‘. It then sends ğ‘ to all other miners (line 48),
sends to each miner ğ‘ also all the blocks that ğ‘ knows but ğ‘ does
not know, based on their communication history. Namely, it sends
to ğ‘ the blocklace [ğ‘] \ [history(ğ‘)] (line 48). A recipient of a block
defers accepting it it until the block has no dangling pointers in
its local blocklace (line 39), so that adding the block to the local
blocklace would retain it being closed.

10

5.1 Cordial Miners Safety
We argue next that in the limit the blocklaces of correct miners
that participate in a run of a Cordial Miners protocol are identical,
are leader-safe and leader-live. Variations and optimizations are
discussed in Section 6.

A formal description of blocklace-based protocols in terms of
asynchronous multiagent transition systems with faults has been
carried out in reference [37]. Here, we employ pseudocode, pre-
sented in Algorithms 1, 2, 3 & 4 to describe the correct behaviors of
a miner in a protocol, and discuss only informally the implied mul-
tiagent transition system and its computations. We assume that the
run of the protocol by the miners Î  results in a sequence of configu-
rations ğ‘Ÿ = ğ‘0, ğ‘1, . . ., each encoding the local state of each miner. A
miner is correct in a run ğ‘Ÿ it if behaves according to the pseudocode
during ğ‘Ÿ , faulty otherwise. As stated above, we assume that there
are at most ğ‘“ < ğ‘›/3 faulty miners in any run. We use ğµğ‘ (ğ‘) to de-
note the local blocklace of miner ğ‘ âˆˆ Î  in configuration ğ‘, ğµğ‘ (ğ‘Ÿ ) to
denote the blocklace of miner ğ‘ in the limit, ğµğ‘ (ğ‘Ÿ ) := (cid:208)ğ‘ âˆˆğ‘Ÿ ğµğ‘ (ğ‘),
and ğµ(ğ‘Ÿ ) to denote the unions of the blocklaces of all correct miners
in the limit, ğµ(ğ‘Ÿ ) := (cid:208)ğ‘ âˆˆğ‘ƒ ğµğ‘ (ğ‘Ÿ ), where ğ‘ƒ âŠ† Î  is the set of miners
correct in run ğ‘Ÿ .

Proposition 5.2 (Miner Asynchrony). If a miner can create a
block (line 45) then it can create it also after receiving blocks from
other miners.

Proof of Proposition 5.2. Examination of the completed_round
procedures of Algorithm 4, which gate block creation in Algorithm
3, line 45, shows that if it holds for a blocklace it holds after blocks
by other miners are received and buffered or added to the local
â–¡
blocklace.

Miner asynchrony combined with the standard notion of fairness,
that a transition that is enabled infinitely often in a run is eventually
taken in the run, implies that once a Cordial Miners block creation
transition is enabled then it will eventually be taken.

Proposition 5.3 (Miners Liveness). In a fair run of a Cordial
Miners protocol with correct miners ğ‘ƒ âŠ† Î , if there is a configuration
for which completed_round() â‰¥ ğ‘‘ (line 44) for ğ‘‘ â‰¥ 0 and for the
blocklace of every miner ğ‘ âˆˆ ğ‘ƒ, then there is a subsequent configura-
tion for which completed_round() â‰¥ ğ‘‘ + 1 for the blocklace of every
miner ğ‘ âˆˆ ğ‘ƒ.

Proof of Proposition 5.3. We show by induction on the round
number. Consider a configuration ğ‘ in which the depth of the last
completed round in the blocklace of all miners be ğ‘‘ â‰¥ 0. If ğ‘‘ = 0
then the completed_round () call (line 44 in both Cordial Miners
protocols (Algorithm 4, line 57 and line 66) returns 0 and ğ‘ can
create a initial block (line 45) with no predecessors (line 5). Assume
ğ‘‘ > 0. Consider a miner ğ‘ âˆˆ ğ‘ƒ that has not yet created a block of
depth ğ‘‘ + 1 in ğ‘. Then the condition completed_round() â‰¥ ğ‘Ÿ (line 44)
holds for ğ‘Ÿ = ğ‘‘, and the transition to create the next block is enabled.
By miner asynchrony (Proposition 5.2) such a transition is enabled
indefinitely, and by the fairness assumption it is eventually taken,
in which ğ‘ sends a new ğ‘-block ğ‘ of depth ğ‘‘ + 1 to all other miners
(line 48), and includes, for each miner ğ‘, all the blocks in the closure
of ğ‘ that ğ‘ might not know of, based on the communication history
of ğ‘ with ğ‘. By assumption, all said messages among correct miners

Algorithm 3 Cordial Miners: Blocklace-Based Dissemination
pseudocode for miner ğ‘ âˆˆ Î , including Algorithms 1, 2 & 4

Local variables:

array history(ğ‘›), initially âˆ€ğ‘˜ âˆˆ [ğ‘›] : history(ğ‘˜) â† { }
ğ‘Ÿ â† 0

âŠ² Communication history of ğ‘
âŠ² The current round of ğ‘
âŠ² send and receipt are simple messaging on a reliable link

for ğ‘ âˆˆ buffer : (b.pointers âŠ† hash(blocklace) âˆ§ âˆ€ğ‘â€² âˆˆ blocklace : Â¬equivocator(ğ‘.creator, ğ‘â€²)) do

if cordial_block(ğ‘) then buffer â† buffer âˆª {ğ‘ }

36: upon receipt of ğ‘ do
37:
38: while true do
39:
40:
41:
42:
43:

buffer â† buffer \ {ğ‘ }
blocklace â† blocklace âˆª {ğ‘ }
history(ğ‘) â† history(ğ‘) âˆª {ğ‘ }
output_blocks()

44:
45:
46:
47:
48:
49:

if completed_round() â‰¥ ğ‘Ÿ then

ğ‘ â† create_block(completed_round())
ğ‘Ÿ â† depth(ğ‘)
for ğ‘ âˆˆ Î  âˆ§ ğ‘ â‰  ğ‘ âˆ§ Â¬equivocator(ğ‘, ğ‘) do

send [ğ‘ ] \ [history(ğ‘) ] to ğ‘
history(ğ‘) â† history(ğ‘) âˆª {ğ‘ }

50: procedure cordial_block(ğ‘)
51:

return {ğ‘â€².creator : ğ‘ â‰» ğ‘â€² âˆ§ depth(ğ‘â€²) = depth(ğ‘) âˆ’ 1} is a supermajority.

procedure output_blocks () is defined in Algorithm 2
procedure completed_round () is defined in Algorithm 4

Property
Wavelength ğ‘¤

Eventual Synchrony
2

Leader Selection

Prospective

Asynchrony
5

Retrospective

Leader Final if:

Round Completed if:

Super-ratified & Ratified by next
leader within ğ‘¤

Super-ratified within ğ‘¤

Cordial and (includes or ratifies
leader, or timeout)

Cordial

Probability of Wave Success:

4
9

2
3

Table 2: Differences Between the Cordial Miners Protocols for Eventual Synchrony and for Asynchrony

eventually arrive at their destination. Hence there is some subse-
quent configuration ğ‘ â€² in which every correct miner has receives a
ğ‘‘ + 1-depth ğ‘-block ğ‘ from every other correct miner ğ‘, as well as
all preceding blocks to ğ‘. Hence in ğ‘ â€², completed_round() â‰¥ ğ‘Ÿ holds
â–¡
for ğ‘Ÿ = ğ‘‘ + 1 for every correct miner.

Proposition 5.4 (Cordial Miners Dissemination). In a run ğ‘Ÿ
of a Cordial Miners protocol with correct miners ğ‘ƒ âˆˆ Î , ğµ(ğ‘Ÿ ) = ğµğ‘ (ğ‘Ÿ )
for every miner ğ‘ âˆˆ ğ‘ƒ.

Proof of Proposition 5.4. Given a run ğ‘Ÿ of a Cordial Miners
protocol with correct miners ğ‘ƒ âŠ‚ Î , we have to show that for
any ğ‘, ğ‘ âˆˆ ğ‘ƒ, a configuration ğ‘ of the run, and a block ğ‘ in the
blocklace of ğ‘ is configuration ğ‘, there is a subsequent configuration
ğ‘ â€² of the run in which ğ‘ is in the local blocklace of ğ‘. By miners
liveness (Proposition 5.3), for any miner ğ‘, there is a subsequent
configuration by which miner ğ‘ sends a block to miner ğ‘. According

to the dissemination protocol (line 48), [ğ‘] is also sent to ğ‘, minus
any blocks in [ğ‘] that have been previously communicated between
ğ‘ and ğ‘. Hence there is a subsequent configuration to ğ‘ â€² in which ğ‘
â–¡
is included in the blocklace of ğ‘.

We refer to ğµ(ğ‘Ÿ ) as the blocklace of run ğ‘Ÿ , and conclude that every
miner ğ‘ correct in a run produces the blocklace of the run, namely
ğµğ‘ (ğ‘Ÿ ) = ğµ(ğ‘Ÿ ).

We can now argue the safety of the Cordial Miners protocols:

Proposition 5.5 (Cordial Miners Protocol Safety). The Cor-

dial Miners protocols for asynchrony and synchrony are safe.

Proof of Proposition 5.5. According to Proposition 5.4, in any
computation of a Cordial Miners protocol, the local blocklace of
any two correct miners ğ‘, ğ‘ âˆˆ Î  is the same blocklace ğµ. Hence, in
any configuration of the computation, the local blocklaces of ğ‘ and
ğ‘ are subsets of ğµ, and hence according to Proposition 4.4, their

11

Algorithm 4 Cordial Miners: Protocol-Specific Utilities
pseudocode for miner ğ‘ âˆˆ Î 

52: ğ‘¤ â† 2
53: procedure leader(ğ‘‘) return ğ‘ âˆˆ Î  using a shared pseudorandom function if ğ‘‘ mod ğ‘¤ = 0 else âŠ¥.

4.1 Procedures for Eventual Synchrony

54: procedure final_leader(ğ‘)
55:
56:

return ğµ = {ğ‘â€² âˆˆ blocklace_prefix(depth(ğ‘) + ğ‘¤) : ratifies(ğ‘â€², ğ‘) } is a supermajority âˆ§
âˆƒğ‘â€² âˆˆ ğµ : ğ‘â€².creator = leader(depth(ğ‘â€²)) âˆ§ depth(ğ‘â€²) = depth(ğ‘) + ğ‘¤

57: procedure completed_round()
58:
59:
60:
61:

return max ğ‘Ÿ : {ğ‘.creator : ğ‘ âˆˆ blocklace âˆ§ depth(ğ‘) = ğ‘Ÿ } is a supermajority âˆ§
(ğ‘Ÿ mod ğ‘¤ = 0 =â‡’ âˆƒğ‘ âˆˆ blocklace : leader(ğ‘Ÿ ) = ğ‘.creator âˆ¨ timeout) âˆ§
(ğ‘Ÿ mod ğ‘¤ = 1 =â‡’ âˆƒğ‘ âˆˆ blocklace : (leader(ğ‘Ÿ âˆ’ 1) = ğ‘.creator âˆ§
{ğ‘â€².creator : ğ‘â€² âˆˆ blocklace âˆ§ depth(ğ‘â€²) = ğ‘Ÿ âˆ§ approves(ğ‘â€², ğ‘) } is a supermajority) âˆ¨ timeout)

âŠ² Prospective leader

âŠ² Cordial & (leader included/ratified or timeout)
âŠ² Cordial
âŠ² Leader included
âŠ² Leader ratified

62: ğ‘¤ â† 5
63: procedure leader(ğ‘‘) return ğ‘ âˆˆ Î  via a random shared coin tossed at round ğ‘‘ + ğ‘¤ âˆ’ 1 if ğ‘‘ mod ğ‘¤ = 0 else âŠ¥.

4.2 Procedures for Asynchrony

64: procedure final_leader(ğ‘)
65:

return {ğ‘â€² âˆˆ blocklace_prefix(depth(ğ‘) + ğ‘¤ âˆ’ 1) : ratifies(ğ‘â€², ğ‘) } is a supermajority

66: procedure completed_round()
67:

return max ğ‘Ÿ : {ğ‘.creator : ğ‘ âˆˆ blocklace âˆ§ depth(ğ‘) = ğ‘Ÿ } is a supermajority

âŠ² Retrospective leader

âŠ² Cordial

outputs at that configuration are consistent, which is the safety
requirement of ordering consensus protocols (Def. 2.3). Hence the
â–¡
Cordial Miners protocols are safe.

5.2 Cordial Miners Liveness
We now proceed to argue the liveness of the Cordial Miners proto-
cols.

Proposition 5.6 (Cordial Miners Protocol Liveness). The
Cordial Miners protocols for asynchrony and eventual synchrony are
live.

Proof of Proposition 5.6. According to Propositions 5.7 and
5.14 below, the blocklace produced in any computation of the Cor-
dial Miners protocols for eventual synchrony and for asynchrony
is leader-live with probability 1. According to Proposition 4.5, if the
function ğœ applied to a sequence of blocklaces that converge to a
leader-live blocklace ğµ then any ğ‘ âˆˆ ğµ appears eventually in the
output of ğœ. If the blocklace ğµ is leader-live with probability 1 then
any ğ‘ âˆˆ ğµ appears eventually in the output of ğœ with probability 1,
which is the liveness requirement of ordering consensus protocols
â–¡
(Def. 2.3). Hence the Cordial Miners protocols are live.

Next we prove the required leader-liveness propositions.

Proposition 5.7 (Leader-Liveness Cordial of Miners Even-
tual Synchrony Protocol). The blocklace produced by a run of a
Cordial Miners eventual synchrony protocol is leader-live with proba-
bility 1.

Proof of Proposition 5.7. Let ğµ be the cordial blocklace pro-
duced by a run of a Cordial Miners eventual synchrony protocol,
ğ‘ƒ âŠ† Î  the supermajority of miners correct in the run, and let
ğ‘Ÿ > 0 be any round for which the ğ‘Ÿ âˆ’ 1 suffix of of ğµ, Â¯ğµ(ğ‘Ÿ âˆ’ 1), is
equivocation-free, ğ‘Ÿ mod ğ‘¤ = 0, where ğ‘¤ = 2 (line 52). Let ğ‘Ÿ â€² > ğ‘Ÿ

be any even round following network synchronization (GST). Since
leader selection is pseudo random (line 53), and ğ‘ƒ is a supermajority,
there is probability of |ğ‘ƒ |
ğ‘› that the ğ‘Ÿ â€²-leader ğ‘ is correct, namely
ğ‘ âˆˆ ğ‘ƒ. As timeout does not affect correct miners after GST, then
for every ğ‘ âˆˆ ğ‘ƒ, the ğ‘Ÿ â€²-depth ğ‘-block ğ‘ is approved by the ğ‘Ÿ â€² + 1
ğ‘-block (line 59 and ratified by the ğ‘Ÿ â€² + 2-round block of ğ‘. Hence,
the blocks of the correct miners ğ‘ƒ satisfy the conditions of ğ‘ being
a final leader (line 54) for the Cordial Miners eventual synchrony
protocol. As this holds also for the leader of any round following
ğ‘Ÿ , the probability that for any depth ğ‘Ÿ â€² â‰¥ ğ‘Ÿ , a leader in Â¯ğµ(ğ‘Ÿ â€²) has
a final leader is 1, hence ğµ is leader-live with probability 1. Hence
the condition of Proposition 3.18, that for every ğ‘Ÿ > 0, ğµ has a final
leader block of some round ğ‘Ÿ â€² > ğ‘Ÿ with probability 1, is satisfied
â–¡
and we conclude that ğµ is leader-live with probability 1.

We note that, following GST, the probability of a leader block
then

being final is at least ( |ğ‘ƒ |
the expected latency is at most 2/( 2

ğ‘› )2, and given that ğ‘¤ = 2, if |ğ‘ƒ |
3 )2 = 4.5.

The Cordial Miners asynchrony protocol, for which ğ‘¤ = 5
(line 62), elects leaders retroactively using a shared random coin.
To elect the leader of round ğ‘Ÿ , when ğ‘Ÿ mod 5 = 0, all correct miners
toss the coin in round ğ‘Ÿ + 3 and know in round ğ‘Ÿ + 4 the elected
leader of round ğ‘Ÿ , as follows. to elect a leader

ğ‘› > 2
3

Definition 5.8 (Blocklace-Based Shared Random Coin). We assume
two shared random coin functions, toss_coin and combine_tosses.
The function toss_coin(ğ‘ğ‘ , ğ‘‘) takes the secret key ğ‘ğ‘  of miner ğ‘ âˆˆ Î 
and a round number ğ‘‘ > 0 as input, and produces ğ‘â€™s share of the
coin of round ğ‘‘, ğ‘ ğ‘,ğ‘‘ , as output. If the protocol needs to compute
the shared random coin for round ğ‘‘, then ğ‘ ğ‘,ğ‘‘ is incorporated in
the payload of the ğ‘‘-depth ğ‘-block of every correct miner ğ‘. The
function combine_tosses(ğ‘†, ğ‘‘) takes a set ğ‘† of shares ğ‘ ğ‘,ğ‘‘ , ğ‘‘ > 0, for
which |{ğ‘ : ğ‘ ğ‘,ğ‘‘ âˆˆ ğ‘† }| > ğ‘“ + 1, and returns a miner ğ‘ âˆˆ Î .

12

Assume some ğ‘‘ > 0 and let ğ‘† = {toss_coin(ğ‘ğ‘ , ğ‘‘) : ğ‘ âˆˆ ğ‘ƒ } for
a set of miners ğ‘ƒ âŠ† Î , |ğ‘ƒ | > ğ‘“ + 1. Then the functions have the
following properties:

Agreement If both ğ‘† â€², ğ‘† â€²â€² âŠ† ğ‘† and both |ğ‘† â€²|, |ğ‘† â€²â€²| > ğ‘“ + 1, then
combine_tosses(ğ‘† â€², ğ‘‘) = combine_tosses(ğ‘† â€²â€², ğ‘‘)
Termination combine_tosses(ğ‘†, ğ‘‘) âˆˆ Î .
Fairness The coin is fair, i.e., for every set ğ‘† computed as above
and any ğ‘ âˆˆ Î , the probability that ğ‘ = combine_tosses(ğ‘†, ğ‘‘) is
1
ğ‘› .
Unpredictability If ğ‘† â€² âŠ‚ ğ‘†, |ğ‘† â€²| < ğ‘“ + 1, then the probability
that the adversary can use ğ‘† â€² to guess the value of combine_tosses(ğ‘†, ğ‘‘)
is less than 1

ğ‘› + ğœ–.

Examples of such a coin implementation using a PKI and thresh-
old signatures [4, 32, 39] are in [10, 28]. See DAG-Rider [28] on
details on how to implement such a coin as part of a distributed
blocklace-like structure.

The following proposition ensures that in a disseminating cordial
blocklace, all correct miners eventually repel all equivocators and
stop observing blocks by them.

Definition 5.9 (Equivocator-Repelling). Let ğ‘ âˆˆ B be a ğ‘-block,
ğ‘ âˆˆ Î , that acknowledges a set of blocks ğµ âŠ‚ B. Then ğ‘ is
equivocator-repelling if ğ‘ does not equivocate in [ğ‘] and all
blocks in ğµ are equivocator-repelling. A blocklace ğµ is equivocator-
repelling if every block ğ‘ âˆˆ ğµ is equivocator-repelling.

Note that the recursive definition terminates with an initial
block, where ğµ = âˆ…. Also note that a block (or blocklace) that
is equivocator-repelling may include equivocations, for example
two equivocating blocks each observed by a different block in ğµ.
However, once an equivocation by miner ğ‘ is observed by a block ğ‘,
ğ‘ would be repelled: Any block that observes ğ‘ would not acknowl-
edge any ğ‘-block, preventing any further ğ‘-blocks from joining the
blocklace. Also note that the local blocklace created by a correct
miner is equivocation-repelling, due to the last condition in line 39.

Proposition 5.10 (Eqivocators-Free Suffix). Let ğµ be an
equivocator-repelling and cordial blocklace and ğ‘ƒ âŠ‚ Î  the set of
miners that do not equivocate in ğµ and are disseminating in ğµ. If ğ‘ƒ
is a supermajority then there is a depth ğ‘‘ > 0 for which the depth-ğ‘‘
suffix of ğµ, Â¯ğµ(ğ‘‘), includes only ğ‘ƒ-blocks.

The following Lemma is the blocklace-variant of the notion of
a common core [2, 19]. Its proof is an adaptation to the cordial
blocklace setting of the common core proof in [19], which in turn
is derived from the proof of get-core in [2]. Figure 5 illustrates its
proof as well as the proof of the following ratified common core
Corollary 5.12.

Lemma 5.11 (Blocklace Common Core). Let ğµ be a cordial block-
lace, ğ‘ƒ âŠ‚ Î  the set of miners that do not equivocate in ğµ and are
disseminating in ğµ, and ğ‘Ÿ > 0 a depth for which the depth-(ğ‘Ÿ âˆ’ 1)
suffix of ğµ, Â¯ğµ(ğ‘Ÿ âˆ’ 1), includes only ğ‘ƒ-blocks (ğ‘Ÿ exists by Proposition
5.10), and hence equivocation free. If ğ‘ƒ is a supermajority then there
is a supermajority of ğ‘Ÿ -round blocks Ë†ğµ âŠ‚ ğµ, referred to as common
core, such that every (ğ‘Ÿ + 3)-round block approves every block in Ë†ğµ.

Proof of Lemma 5.11. Let ğµ and ğ‘Ÿ be as assumed by the Lemma,
and let ğ‘ƒ be the set of miners that have (ğ‘Ÿ + 2)-round blocks in ğµ.

Figure 5: Common Core, Ratified Common Core, Safety
and Liveness of Decision Rule for Asynchrony: (A) Proof of
Lemma 5.11 and Corollary 5.12: Rounds ğ‘Ÿ to ğ‘Ÿ + 3 relate to
the proof of Lemma 5.11, where the existence of a common
core at round ğ‘Ÿ is established. Round ğ‘Ÿ + 4 relates to Corol-
lary 5.12, which establishes that all cordial blocks at round
ğ‘Ÿ + 4 ratify all members of the common core of round ğ‘Ÿ via
a supermajority at round ğ‘Ÿ + 3. (B) The common-core table
ğ‘‡ used in the proof to relate rounds ğ‘Ÿ + 1 and ğ‘Ÿ + 2. (C) The
decision rule for asynchrony: Protocol wavelength is 4. Live-
ness: Common-core ensures that the blue leader at round ğ‘Ÿ is
super-ratified by a red supermajority at round ğ‘Ÿ +4 with prob-
ability 2ğ‘“ +1
3ğ‘“ +1 , thus ensuring liveness and expected latency of
6 rounds. Safety: A blue leader is approved by every cordial
block at round ğ‘Ÿ + 3 (green) and hence is ratified by every
cordial block at round ğ‘Ÿ + 4 (red) and beyond.

Since ğµ is cordial and disseminating it is infinite of depth > ğ‘Ÿ + 3
(Observation 3), it follows that |ğ‘ƒ | â‰¥ 2ğ‘“ + 1. Define a table ğ‘‡ with
rows and columns indexed by ğ‘ƒ. Each (ğ‘Ÿ + 2)-round ğ‘-block of a
miner ğ‘ âˆˆ ğ‘ƒ observes (ğ‘Ÿ + 1)-round blocks by at least 2ğ‘“ + 1 miners,
which includes at least blocks by ğ‘“ + 1 miners of ğ‘ƒ, represented in
ğ‘‡ . For ğ‘, ğ‘ âˆˆ ğ‘ƒ, entry ğ‘‡ [ğ‘, ğ‘] in the table is 1 if the (ğ‘Ÿ + 2)-round ğ‘-
block observes the (ğ‘Ÿ + 1)-round ğ‘-block, and 0 otherwise. Observe
that if 1 appears in entry ğ‘‡ [ğ‘, ğ‘], the (ğ‘Ÿ +2)-round ğ‘-block observes
all the 2ğ‘“ + 1 ğ‘Ÿ -round blocks observed by the (ğ‘Ÿ + 1)-round block
of ğ‘.

Since all miners in ğ‘ƒ have (ğ‘Ÿ + 2)-round blocks, ğ‘‡ contains at
least (2ğ‘“ + 1)(ğ‘“ + 1) entries with 1. This implies that there is a
miner in ğ‘ƒ, say Â¯ğ‘, that appears in at least ğ‘“ + 1 rows; let Â¯ğ‘ƒ be the
set of miners indexing Â¯ğ‘ rows and Â¯ğ‘ (blue dot) the (ğ‘Ÿ + 1)-round
Â¯ğ‘-block. Thus, the (ğ‘Ÿ + 2)-round blocks of miners in Â¯ğ‘ƒ (thick green
line at round ğ‘Ÿ + 2) observe Â¯ğ‘. We argue that [Â¯ğ‘] is a common core.

13

First, note that as Â¯ğ‘ is cordial, [Â¯ğ‘] includes 2ğ‘“ + 1 ğ‘Ÿ -round blocks.
Second, consider any (ğ‘Ÿ + 3)-round block ğ‘ (green dot). It observes
2ğ‘“ + 1 (ğ‘Ÿ + 2)-round blocks (thick red line), so it also observes at
least one of the (ğ‘Ÿ + 1)-round blocks (black dot) of the ğ‘“ + 1 miners
of Â¯ğ‘ƒ, which in turn observes Â¯ğ‘. Thus [Â¯ğ‘] âŠ† [ğ‘], with [Â¯ğ‘] satisfying
â–¡
the requirements of a common core.

Corollary 5.12 (Super-Ratified Common Core). Under the
same conditions as Lemma 5.11 and assuming Ë†ğµ is a common core,
then every (ğ‘Ÿ + 4)-round block in ğµ ratifies every block in Ë†ğµ, Hence
every member of the common core Ë†ğµ, is super-ratified in ğµ(ğ‘Ÿ + 4).

Proof of Corollary 5.12. Under the assumptions of the Corol-
lary, let Ë†ğµ be a common core and consider any (ğ‘Ÿ + 4)-block ğ‘ âˆˆ ğµ
(purple dot). Being cordial, ğ‘ observes 2ğ‘“ + 1 (ğ‘Ÿ + 2)-round blocks
(thick purple line). By Lemma 5.11, each of these blocks observes
each block in Ë†ğµ. Hence ğ‘ ratifies every block in Ë†ğµ.
â–¡

Note that the Lemma and Corollary require an equivocators-free
section of the blocklace, which may be the entire equivocation-free
suffix of the blocklace as in the proof. But the proof also holds if
there is a long enough stretch of rounds without equivocation, in
which case a common core also exists.

We conclude that if a Cordial Miners protocol relies on the com-
mon core for liveness, dissemination and cordiality are sufficient to
ensure it.

Corollary 5.13 (Liveness of Common Core). Let ğµ be a dis-
seminating and cordial blocklace. Then there is a ğ‘‘ > 0 for which the
common core Lemma 5.11 holds for ğµ and for any round ğ‘Ÿ â‰¥ ğ‘‘.

Proposition 5.14 (Leader-Liveness of Cordial Miners Asyn-
chrony Protocol). The blocklace produced by a run of a Cordial
Miners asynchrony protocol is leader-live with probability 1.

Proof of Proposition 5.14. Let ğµ be the cordial blocklace pro-
duced by a run of a Cordial Miners asynchrony protocol, ğ‘ƒ âŠ† Î 
the supermajority of miners correct in the run, and let ğ‘Ÿ > 0 be any
round for which the ğ‘Ÿ âˆ’1 suffix of of ğµ, Â¯ğµ(ğ‘Ÿ âˆ’1), is equivocation-free,
ğ‘Ÿ mod ğ‘¤ = 0, where ğ‘¤ = 5 (line 62). According to Corollary 5.12,
a supermajority Ë†ğµ of the round-ğ‘Ÿ blocks are super-ratified by all
round-ğ‘Ÿ + 4 blocks. As the leader of round ğ‘Ÿ is selected at random,
and retroactively after the common core Ë†ğµ has been established,
the probability that the elected leader is super-ratified, and hence
final, is at least |ğ‘ƒ |
ğ‘› . As this holds also for the leader of any round
following ğ‘Ÿ , the probability that for any depth ğ‘‘ â‰¥ ğ‘Ÿ , a leader in
Â¯ğµ(ğ‘‘) has a final leader is 1, hence ğµ is leader-live with probability
â–¡
1.

This completes the proof of Proposition 5.6 and hence also the

proof of Theorem 5.1.

6 PERFORMANCE ANALYSIS AND
POTENTIAL OPTIMIZATIONS

Latency (See Table 1). Latency is defined as the number of blocklace
rounds between every two consecutive ratified leaders.

In the asynchronous instance of the protocol, each wave (rounds
till leader finality) consists of 5 rounds. According to Lemma 5.11,

Figure 6: Eventual Synchrony: Cordiality, Safety and Live-
ness. Cordiality: Wavelength is 2 (line 52). Even round con-
tains a supermajority (red thick line) that includes the
leader (red dot), which ratifies the leader of the previous
even round (blue dot). At odd rounds (ğ‘Ÿ + 1), wait for a su-
permajority (thick blue line) of the previous round (ğ‘Ÿ ) that
includes the leader (blue dot), or a timeout (line 59). At even
rounds (ğ‘Ÿ + 2), wait for a supermajority (thick green line)
of the previous round (ğ‘Ÿ + 1) that approves the leader, or a
timeout (line 60). Safety: Any subsequent leader to the blue
leader ratifies the blue leader; the immediate red successor
by constructionâ€”case (A) of Figure 2â€”and any subsequent
leaders according to cases (B) and (C) of Figure 2. Liveness:
If a round leader (blue) is correct than it will be finalized
within ğ‘¤ = 2 rounds.

the probability that the decision rule is met, namely that a superma-
jority of the blocks in ğ‘Ÿ + 4 each ratify a leader at ğ‘Ÿ is 2
. Therefore,
3
in the expected-case, the decision rule is met on average every 1.5
waves, and therefore the expected latency is 1.5ğ‘¤ = 7.5 rounds of
communication.

Note that the adversary can equivocate or not be cordial up to ğ‘“
times, but after each Byzantine process ğ‘ equivocates, all correct
processes eventually detect the equivocation and do not consider ğ‘â€™s
blocks as part of their cordial rounds when building the blocklace.
Thus, in an infinite run, equivocations do not affect the overall
expected latency.

In the eventual synchrony case, each wave consists of 2 rounds.
The probability that the decision rule is met in each wave is the
probability that there are two correct leaders in a row, therefore, it
is at least 4
. Thus, in the expected-case, the latency is 4.5 rounds
9
of communication.
Bit complexity. Each block in the blocklace is linear in size, since
it has a linear number of hash pointers to previous blocks. In the
worst-case, each block is sent to all miners by all the other miners,
i.e., the bit complexity is ğ‘‚ (ğ‘›3) per block. But, if we batch per block
a linear number of transactions, when the decision rule is met,
we can amortize the bit complexity by a linear factor. Thus, the
amortized bit complexity per decision is ğ‘‚ (ğ‘›2).

14

We note that DAG-Rider and Bullshark achieve amortized ğ‘‚ (ğ‘›)
message complexity per decision by using a reliable broadcast pro-
tocol that relies on erasure coding [17]. We plan as part of future
work to incorperate similar techniques as used in [17] to the block-
lace dissemination protocol to achieve the same amortized message
complexity.
Future directions. Several optimizations are possible to the pro-
tocol instances presented. First, as faulty miners are exposed, they
are repelled and therefore need not be counted as parties to the
agreement, which means that the number of remaining faulty min-
ers, initially bounded by ğ‘“ , decreases. As a result, the superma-
jority needed for finality is not ğ‘›+ğ‘“
2ğ‘› (namely 2ğ‘“ + 1 votes in case
ğ‘› = 3ğ‘“ + 1), but ğ‘›+ğ‘“ âˆ’2ğ‘“ â€²
, where ğ‘“ â€² is the number of exposed faulty
2(ğ‘›âˆ’ğ‘“ â€²)
miners, which converges to simple majority ( 1
2
miners as more faulty miners are exposed and ğ‘“ â€² tends to ğ‘“ .

) among the correct

Secondly, once faulty miners are exposed and repelled, their slots
as leaders could be taken by correct miners, improving good-case
and expected complexity.

Thirdly, a hybrid protocol in the spirit of Bullshark [25] can be
explored. Such a protocol would employ two leaders per round â€“
deterministic and random, try to achieve quick finality with the
deterministic leader, and fall back to the randomly-selected leader
if this attempt fails.
Exclusion of nonresponsive miners: A miner ğ‘ need not be
cordial to miner ğ‘ as long as ğ‘ has not observed a previous block ğ‘
sent to ğ‘ by ğ‘. If ğ‘ fail-stopped, then ğ‘ should definitely not waste
resources on ğ‘; if ğ‘ is only suspended or delayed, then eventually
it will send to ğ‘ a block observing ğ‘, following which ğ‘â€”being
cordialâ€”will send to ğ‘ the backlog ğ‘ has previously refrained from
sending it, and is not observed by the new block received from ğ‘.

7 CONCLUSIONS
An important next step towards making Cordial Miners a useful
foundation for cryptocurrencies is to design a mechanism that will
encourage miners to cooperateâ€”as needed by these protocolsâ€”as
opposed to compete, which is the current standard in mainstream
cryptocurrencies.

ACKNOWLEDGMENTS
Oded Naor is grateful to the Azrieli Foundation for the award of
an Azrieli Fellowship. Ehud Shapiro is the Incumbent of The Harry
Weinrebe Professorial Chair of Computer Science and Biology at the
Weizmann Institute and a visiting scholar at Columbia University.
We thank Andrew Lewis-Pye for his comments on an earlier draft.

REFERENCES
[1] Ittai Abraham, Kartik Nayak, Ling Ren, and Zhuolun Xiang. 2021. Good-case
latency of byzantine broadcast: A complete categorization. In Proceedings of the
2021 ACM Symposium on Principles of Distributed Computing. 331â€“341.

[2] Hagit Attiya and Jennifer Welch. 2004. Distributed computing: fundamentals,

simulations, and advanced topics. Vol. 19. John Wiley & Sons.

[3] Leemon Baird. 2016. The Swirlds Hashgraph Consensus Algorithm: Fair, Fast,

Byzantine Fault Tolerance. Report. Swirlds.

[4] Dan Boneh, Ben Lynn, and Hovav Shacham. 2001. Short signatures from the Weil
pairing. In International conference on the theory and application of cryptology
and information security. Springer, 514â€“532.

[5] Gabriel Bracha. 1987. Asynchronous Byzantine agreement protocols. Information

and Computation 75, 2 (1987), 130â€“143.

[6] Gabriel Bracha and Sam Toueg. 1985. Asynchronous consensus and broadcast

protocols. Journal of the ACM (JACM) 32, 4 (1985), 824â€“840.

[7] Ethan Buchman. 2016. Tendermint: Byzantine fault tolerance in the age of

blockchains. Ph.D. Dissertation. University of Guelph.

[8] Vitalik Buterin et al. 2014. A next-generation smart contract and decentralized

application platform. white paper 3, 37 (2014).

[9] Christian Cachin, Klaus Kursawe, Frank Petzold, and Victor Shoup. 2001. Se-
cure and efficient asynchronous broadcast protocols. In Annual International
Cryptology Conference. Springer, 524â€“541.

[10] Christian Cachin, Klaus Kursawe, and Victor Shoup. 2005. Random oracles in Con-
stantinople: Practical asynchronous Byzantine agreement using cryptography.
Journal of Cryptology 18, 3 (2005), 219â€“246.

[11] Miguel Castro and Barbara Liskov. 1999. Practical Byzantine fault tolerance.
Proceedings of the third symposium on Operating systems design and implemen-
tation, USENIX Association, New Orleans, Louisiana, USA, 173â€“186.

[12] Gregory V Chockler, Nabil Huleihel, and Danny Dolev. 1998. An adaptive totally
ordered multicast protocol that tolerates partitions. In Proceedings of the seven-
teenth annual ACM symposium on Principles of distributed computing. 237â€“246.
[13] Shir Cohen, Rati Gelashvili, Lefteris Kokoris Kogias, Zekun Li, Dahlia Malkhi,
Alberto Sonnino, and Alexander Spiegelman. 2021. Be Aware of Your Leaders.
arXiv:2110.00960 [cs.DC]

[14] Cypherium. 2022. Cypherium. https://www.cypherium.io.
[15] George Danezis and David Hrycyszyn. 2018. Blockmania: from block dags to

consensus. arXiv preprint arXiv:1809.01620 (2018).

[16] George Danezis, Eleftherios Kokoris Kogias, Alberto Sonnino, and Alexander
Spiegelman. 2021. Narwhal and Tusk: A DAG-based Mempool and Efficient BFT
Consensus. arXiv preprint arXiv:2105.11827 (2021).

[17] Sourav Das, Zhuolun Xiang, and Ling Ren. 2021. Asynchronous Data Dissemi-
nation and Its Applications. In Proceedings of the 2021 ACM SIGSAC Conference
on Computer and Communications Security (Virtual Event, Republic of Korea)
(CCS â€™21). Association for Computing Machinery, New York, NY, USA, 2705â€“2721.
https://doi.org/10.1145/3460120.3484808

[18] Sourav Das, Zhuolun Xiang, and Ling Ren. 2022. Near-optimal Balanced Reliable
Broadcast and Asynchronous Verifiable Information Dispersal. Cryptology ePrint
Archive (2022).

[19] Danny Dolev and Eli Gafni. 2016. Some garbage in-some garbage out: Asynchro-
nous t-Byzantine as asynchronous benign t-resilient system with fixed t-trojan-
horse inputs. arXiv preprint arXiv:1607.01210 (2016).

[20] Danny Dolev, Shlomo Kramer, and Dalia Malki. 1993. Early delivery totally
ordered multicast in asynchronous environments. In FTCS-23 The Twenty-Third
International Symposium on Fault-Tolerant Computing. IEEE, 544â€“553.

[21] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. 1988. Consensus in the
presence of partial synchrony. Journal of the ACM (JACM) 35, 2 (1988), 288â€“323.

[22] Flow. 2022. Flow. https://www.onflow.org.
[23] Adam GÄ…gol and MichaÅ‚ ÅšwiÄ™tek. 2018. Aleph: A leaderless, asynchronous,
byzantine fault tolerant consensus protocol. arXiv preprint arXiv:1810.05256
(2018).

[24] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zel-
dovich. 2017. Algorand: Scaling byzantine agreements for cryptocurrencies. In
Proceedings of the 26th Symposium on Operating Systems Principles. 51â€“68.
[25] Neil Giridharan, Lefteris Kokoris-Kogias, Alberto Sonnino, and Alexander Spiegel-
man. 2022. Bullshark: DAG BFT Protocols Made Practical. arXiv preprint
arXiv:2201.05677 (2022).

[26] Guy Golan Gueta, Ittai Abraham, Shelly Grossman, Dahlia Malkhi, Benny Pinkas,
Michael Reiter, Dragos-Adrian Seredinschi, Orr Tamir, and Alin Tomescu. 2019.
Sbft: a scalable and decentralized trust infrastructure. In 2019 49th Annual IEEE/I-
FIP international conference on dependable systems and networks (DSN). IEEE,
568â€“580.

[27] Sep Kamvar, Marek Olszewski, and Rene Reinsberg. 2019. Celo: A multi-asset
cryptographic protocol for decentralized social payments. DRAFT version 0.24
https://storage. googleapis. com/celo whitepapers/Celo A Multi Asset Cryptographic
Protocol for Decentralized Social Payments. pdf (2019).

[28] Idit Keidar, Eleftherios Kokoris-Kogias, Oded Naor, and Alexander Spiegelman.

2021. All You Need is DAG. arXiv:2102.08325 [cs.DC]

[29] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. 2017.
Ouroboros: A provably secure proof-of-stake blockchain protocol. In Annual
International Cryptology Conference. Springer, 357â€“388.

[30] Ramakrishna Kotla, Lorenzo Alvisi, Mike Dahlin, Allen Clement, and Edmund
Wong. 2007. Zyzzyva: speculative byzantine fault tolerance. In Proceedings of
twenty-first ACM SIGOPS symposium on Operating systems principles. 45â€“58.
[31] Leslie Lamport. 1978. Time, Clocks, and the Ordering of Events in a Distributed

System. Communications (1978).

[32] BenoÃ®t Libert, Marc Joye, and Moti Yung. 2016. Born and raised distributively:
Fully distributed non-interactive adaptively-secure threshold signatures with
short shares. Theoretical Computer Science 645 (2016), 1â€“24.

[33] Louise E Moser and Peter M Melliar-Smith. 1999. Byzantine-resistant total
ordering algorithms. Information and Computation 150, 1 (1999), 75â€“111.

15

[34] Satoshi Nakamoto. 2019. Bitcoin: A peer-to-peer electronic cash system.
[35] Tsuneko Okazaki. 2017. Days weaving the lagging strand synthesis of DNAâ€”A
personal recollection of the discovery of Okazaki fragments and studies on
discontinuous replication mechanismâ€”. Proceedings of the Japan Academy, Series
B 93, 5 (2017), 322â€“338.

[36] Serguei Popov. 2018. The Tangle. https://assets.ctfassets.net/r1dr6vzfxhev/

2t4uxvsIqk0EUau6g2sw0g/45eae33637ca92f85dd9f4a3a218e1ec/iota1_4_3.pdf.

[37] Ehud Shapiro. 2021. Multiagent Transition Systems: Protocol-Stack Mathematics

for Distributed Computing. arXiv preprint arXiv:2112.13650 (2021).

[38] Robert Shostak, Marshall Pease, and Leslie Lamport. 1982. The byzantine generals
problem. ACM Transactions on Programming Languages and Systems 4, 3 (1982),
382â€“401.

[39] Victor Shoup. 2000. Practical threshold signatures. In International Conference on
the Theory and Applications of Cryptographic Techniques. Springer, 207â€“220.
[40] Yonatan Sompolinsky and Aviv Zohar. 2015. Secure high-rate transaction pro-
cessing in bitcoin. In International Conference on Financial Cryptography and
Data Security. Springer, 507â€“527.

[41] Thunder. 2022. Thunder. https://www.thundercore.com/.
[42] Maofan Yin, Dahlia Malkhi, Michael K Reiter, Guy Golan Gueta, and Ittai Abra-
ham. 2019. HotStuff: BFT consensus with linearity and responsiveness. In Pro-
ceedings of the 2019 ACM Symposium on Principles of Distributed Computing.
347â€“356.

16

