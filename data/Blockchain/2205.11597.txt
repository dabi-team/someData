2
2
0
2

y
a
M
3
2

]

R
C
.
s
c
[

1
v
7
9
5
1
1
.
5
0
2
2
:
v
i
X
r
a

Wiser: Increasing Throughput in Payment Channel Networks
with Transaction Aggregation

Samarth Tiwari1(cid:63), Michelle Yeo2, Zeta Avarikioti3, Iosif Salem4, Krzysztof Pietrzak2(cid:63)(cid:63), and Stefan Schmid5(cid:63) (cid:63) (cid:63)

1 Centrum Wiskunde & Informatica, Amsterdam, The Netherlands
samarth.tiwari@cwi.nl
2 Institute of Science and Technology Austria {michelle.yeo, krzysztof.pietrzak}@ist.ac.at
3 TU Wien, Austria
georgia.avarikioti@tuwien.ac.at
4 TU Berlin, Germany
iosif.salem@inet.tu-berlin.de
5 TU Berlin, Germany & University of Vienna, Austria
stefan.schmid@tu-berlin.de

Abstract. Payment channel networks (PCNs) are one of the most prominent solutions to the limited transaction
throughput of blockchains. Nevertheless, PCNs suffer themselves from a throughput limitation due to the capital
constraints of their channels. A similar dependence on high capital is also found in inter-bank payment settlements,
where the so-called netting technique is used to mitigate liquidity demands.
In this work, we alleviate this limitation by introducing the notion of transaction aggregation: instead of executing
transactions sequentially through a PCN, we enable senders to aggregate multiple transactions and execute them
simultaneously to beneﬁt from several amounts that may “cancel out”. Two direct advantages of our proposal
is the decrease in intermediary fees paid by senders as well as the obfuscation of the transaction data from the
intermediaries.
We formulate the transaction aggregation as a computational problem, a generalization of the Bank Clearing Problem.
We present a generic framework for the transaction aggregation execution, and thereafter we propose WISER as an
implementation of this framework in a speciﬁc hub-based setting. To overcome the NP-hardness of the transaction
aggregation problem, in WISER we propose a ﬁxed-parameter linear algorithm for a special case of transaction
aggregation as well as the Bank Clearing Problem. WISER can also be seen as a modern variant of the Hawala
money transfer system, as well as a decentralized implementation of the overseas remittance service of Wise.

Keywords: Payment Channel Networks, Transaction Aggregation, Netting, Fixed Parameter Tractability, Privacy,
Throughput

1

Introduction

1.1 Motivation

Payment channel networks (PCNs) [34,13,12,30] are a promising technology to signiﬁcantly increase the transaction
throughput of blockchain-based cryptocurrencies such as Bitcoin [31]. Two parties can open a payment channel by
locking coins in a joint account on-chain. Thereafter, the parties can transact off-chain via updating the distribution of
the coins in the channel to depict the new transaction. Only if the parties want to close the channel or allocate extra
budget, do they need to go on-chain. Therefore, payment channels can facilitate arbitrary many transactions off-chain
with a constant number of on-chain transactions, signiﬁcantly increasing the transaction throughput. These payment

(cid:63) Supported by ERC Starting Grant QIP–805241.
(cid:63)(cid:63) Supported by the Vienna Cybersecurity and Privacy Research Center (ViSP), funded by the Vienna business agency (Wirtschaft-

sagentur), 2020-2023.

(cid:63) (cid:63) (cid:63) Supported partially by the Austrian Science Fund (FWF) project I 4800-N (ADVISE), 2020-2023 and the Vienna Cybersecurity

and Privacy Research Center (ViSP), funded by the Vienna business agency (Wirtschaftsagentur), 2020-2023.

 
 
 
 
 
 
channels collectively constitute a payment channel network (PCN) which allows two parties to transact off-chain even if
they do not share a payment channel by using other parties as intermediaries in routing their transactions [34,13].

In order to provide high and reliable transaction throughput, PCNs require many well connected high-capacity
payment channels. The reason is that channels may quickly deplete if several transactions are forwarded along a
channel or path in the same direction, thus preventing any further use of the channel in that direction. However, locking
large amount of capital for a long period of time comes with a cost. To mitigate this cost, the users of PCNs ask
for a service fee for relaying transactions of others through their channels. As a result, a business opportunity arises:
wealthy individuals can act as (transaction) hubs by establishing well-connected high-capacity nodes, offering routing
of transactions as a service. In this way, capital reserves can be used to generate passive income.

While this business model beneﬁts the PCN’s users, it also introduces several challenges: (a) the liquidity of the hubs
still poses a constraint to the PCN’s overall liquidity and hence limits the transaction throughput, (b) the transaction
fees that are typically proportional to the transaction value may be high, and (c) the hubs may learn a signiﬁcant amount
of transactions, thus compromising the privacy of users.

To address these challenges, we introduce the notion of transaction aggregation (Figure 1). In high level, we
enable users to aggregate multiple transactions and execute them simultaneously in the PCN instead of sequentially,
i.e., one-by-one. This way multiple transactions may “cancel out” effectively reducing the transferred amounts and
the corresponding transaction fees, thus increasing the PCN’s liquidity and consequently the transaction throughput.
Moreover, the transaction aggregation obfuscates the individual transactions routed through a channel, as only the
aggregated amount is executed.

A closely related notion to transaction aggregation in ﬁnance is netting that deals with the aggregation of various
ﬁnancial obligations, say, to mitigate risk. In particular, the application of netting in inter-bank payment systems
essentially tackles the ﬁrst aforementioned challenge. The computation problem of optimal netting, i.e., optimal
aggregation of payments across traditional banks, is known as the Bank Clearing Problem or BCP. The transaction
aggregation problem we introduce in this work is a more generic formulation of the BCP problem, hence demonstrating
the potential impact of our work in the ﬁnancial landscape even beyond blockchains.

Transaction aggregation can also be seen as a decentralized and privacy-enhancing variant of the payment system
Wise (formerly TransferWise) [46] built on payment channel networks. Wise is a ﬁnancial technology allowing
convenient online transactions, often used to cheaply transfer money abroad. Another similar ﬁnancial system is
Hawala [36], a centuries-old system of fund transfer across long distances and overseas. A system that implements
transaction aggregation can be interpreted as a modern and improved digital version of the Hawala money transfer
system, which is still in use in parts of the Middle East and South Asia.

1.2 Contribution

The goal of this work is to address the three challenges of PCNs in the hub-based business model, i.e., (a) improve the
throughput of payment channel networks while (b) minimizing fees in the process and also (c) accounting for privacy
concerns. To do so, we propose a system which allows hubs to act cooperatively, combining their capital to serve all
their clients. Any two users connected to any of the hubs can thereafter transact thought the hubs. The transactions
collected over a ﬁxed time interval are then aggregated into a single monetary ﬂow through the network. This ﬂow is
consequently executed atomically through the PCN, meaning that either all the selected transactions are executed or
none. We term the computational problem of ﬁnding a subset of transactions that can be aggregated into a feasible
resultant ﬂow as the transaction aggregation problem (Figure 1).

Speciﬁcally, we present a generic framework which combines three building blocks: (a) a protocol to enable optimal
liquidity usage among hubs, (b) an efﬁcient algorithm for the transaction aggregation problem, and (c) a protocol
for atomic multi-channel state updates, i.e., the atomic execution of the selected transaction in the PCN. We present
a skeleton protocol, that is an abstraction of the composed protocols, to illustrate its beneﬁts as well as technical
challenges. We further determine the necessary properties for such a system and show that our abstraction satisﬁes
them.

We then present WISER, a concrete implementation of the generic framework. WISER uses channel factories [9]
and Thora [1] as substantiations of the aforementioned building blocks ((a) and (c) respectively). As the ﬁnal building

2

block (b), we present a ﬁxed-parameter linear6 algorithm to solve the transaction aggregation problem, which we ﬁrst
show to be NP-hard. For the execution of our algorithm, we leverage secure multi-party computation (MPC) to conceal
channel balances and transaction data.

We further derive a connection between transaction aggregation and netting, and exploit this connection to enrich
both notions. On one hand, our ﬁxed-parameter linear algorithm developed for WISER is directly applicable to BCP. Our
algorithm exhibits the best known parameterized complexity, improving dependence on number of transactions from
pseudo-polynomial to linear. On the other hand, algorithms for the Bank Clearing Problem with inferior asymptotic
complexity may still be faster in certain parameter regimes. WISER can be implemented with any of these optimization
algorithms as a building block, so that work on BCP also bolsters the versatility of our protocol.

1.3 Organisation

The remainder of this paper is organized as follows. In
Section 2, we present the model and additional assump-
tions, as well as the proposed skeleton protocol for solv-
ing the transaction aggregation problem and the desired
properties it should fulﬁl. In Section 3, we present our
implementation of the skeleton protocol, namely WISER,
and in Section 4 we prove that our implementation pro-
vides the desired guarantees. In Section 5 we demonstrate
the connection to the netting problem and discuss fur-
ther extensions of our protocol. Finally, in Section 6 we
compare to related work and we conclude with Section 7.

2 Model and Protocol Overview

In this section, we ﬁrst describe payment channel net-
works, and then introduce the assumptions of our work.
Later, we formulate transaction aggregation as an opti-
mization problem, then provide a high-level overview of
our solution (skeleton protocol), and conclude the section
by deﬁning the desired properties for our system.

2.1 Payment channel networks

Fig. 1: Transaction aggregation example. User A wants to
make a payment of 10 coins to user B and user C wants to
make a payment of 10 coins to user D. The A-to-B and C-
to-D payment paths might render the transaction infeasible
and incur routing fees linear to the path length. Instead, if
A pays D and C pays B, each 10 coins, the transactions
success depends on the capacity of fewer channels and the
fees are reduced.

In this subsection, we provide a brief introduction to payment channel networks with standard fees as they currently
operate.

We assume that a payment channel is characterized by the public keys of the two users opening it, and the funds and
forwarding fees that each user adds to each direction of the channel upon its creation [34]. Let u, v be two users that
have opened a payment channel {(u, v), (v, u)} and c(e), bf (e), pf (e), e ∈ {(u, v), (v, u)} be the current capacity, the
base forwarding fee, and the proportional forwarding fee of each channel direction, respectively. Users u and v can do
an arbitrary number of payments to each other by subtracting any non-negative amount x ≤ c(e), e ∈ {(u, v), (v, u)},
and increasing c(e(cid:48)) by x, where e(cid:48) ∈ {(u, v), (v, u)} \ {e}. Note that the forwarding fees and c(u, v) + c(v, u) is
public information, while each summand (current balance) is not.

A payment channel network (PCN) is the network built over all payment channels. Users that do not share
payment channels can perform payments via paths in the network, by covering a forwarding cost to the intermediate
nodes of the path. For example, if payment channels exist between u, v and v, w, but not between u, w, then u can
transfer an amount x to w in two steps: (i) u transfers x + (bf (v, w) + pf (v, w) · x) coins to v and (ii) v transfers
x coins to w, i.e. bf (v, w) + pf (v, w) · x are the forwarding fees charged by v. The transaction is feasible only if
x + (bf (v, w) + pf (v, w) · x) ≤ c(u, v) and x ≤ c(v, w).

6 FPL is a subclass of the ﬁxed-parameter tractable (FPT) complexity class [15].

3

ABDC10101010In general, suppose that user s wants to pay x coins to user r, via a payment path {(s, u1), ..., (uk, r)}. Then uk
receives rcvk = x+(bf (uk, r)+pf (uk, r)·x) and forwards x coins to r, uk−1 receives rcvk−1 = x+(bf (uk−1, uk)+
pf (uk−1, uk) · rcvk) and forwards rcvk coins to uk, and so on. Moreover, the transaction is feasible only if every node
in the path has sufﬁcient capacity to route the forwarded amount. This is not always the case, since current balances are
private and senders might have to try different payment paths towards a successful transaction.

A transaction along a payment path is successful when all intermediate transactions go through, and otherwise none
of them is performed. That is, PCNs must ensure atomicity in transaction routing. In the Bitcoin Lightning Network,
this is ensured by Hash Timelock Contracts (HTLCs) [34].

Fig. 2: Example of the restricted PCN topology. Each client (nodes {c1, . . . , c9}) is connected to one of hub nodes
(nodes {h1, . . . , h4}) and the hub nodes are well interconnected (potential edges are dashed). We propose a solution for
hub connectivity in our protocol description.

2.2 Assumptions

In this subsection, we introduce the cryptographic and network assumptions as well as the considered PCN topology.

Cryptographic assumptions. We assume the existence of secure communication channels between users.

Blockchain and network model. We assume the underlying block-chain satisﬁes persistence and liveness as deﬁned in
[20]. We also assume a synchronous network model. That is, there is a known network delay which bounds the time
needed for any user to receive any incoming message.

Studied PCN topology We restrict the PCN topology to allow for a computationally tractable implementation of
transaction aggregation. Let V = H ∪ C be the set of all users, which we split to a relatively small set of hub nodes H
and the remainder set of client nodes C. The hubs are well interconnected, and the client nodes are those connected to
only one hub (Figure 2).

Users and transactions. We assume the users of the protocol follow the protocol speciﬁcation unless they can monetarily
gain from deviating from it.

Over time, users accumulate transactions before initiating the protocol. The list Tu of transactions that user u
submits must not exceed the capacity of the channel u has with their hub hu. In other words, users must not authorize a
total payment of funds exceeding their balance with the hub. Moreover, the same must also hold for the set of incoming
transactions where u is the recipient.

Fee function. We assume that the forwarding fees charged by hubs for each channel are publicly known before the
protocol execution. We also assume that the forwarding fee is a non-negative function F (a, b) of the initial and ﬁnal
states a, b of the channel and that the triangle inequality holds: for all states a, b, c: F (a, c) ≤ F (a, b) + F (b, c). As
described in Section 2.1 above, the standard fee functions are simply a base fee plus a proportional fee, which do
satisfy our more general assumptions. Intuitively, it should not be cheaper to forward a given amount along a channel in
multiple parts compared to one.

4

h1h2h3h4c2c3c4c1c9c8c7c6c5Note that our proposed solution does not aim to minimize the fees, but rather to maximize the volume of transactions
that are cleared. We nevertheless show that transaction aggregation implicitly reduces incurred fees for the above class
of fee functions. We discuss a more sophisticated consideration of fees in Section 5.

2.3

(Computational) Problem Deﬁnition

Let G = (V, E) be a directed graph that models a PCN with integral edge capacities c(e). Let V = {v1, . . . vn}, |E| =
m. A payment channel between vi and vj is modelled as two unidirectional edges (vi, vj) and (vj, vi).

A ﬂow through this network is an m-dimensional vector f = (f (e))e∈E that satisﬁes the capacity constraints:

0 ≤ f (e) ≤ c(e) ∀e ∈ E.

A demand vector d = (d1, . . . dn) ∈ Zn is a vector representing the monetary ﬂow through each vertex. For
instance, a transaction of 1 unit from v1 to v2 can be represented as the demand vector (1, −1, 0, . . . 0). A ﬂow f is said
to route a demand vector d if for every vertex v:

(cid:88)

f (v, u) −

(cid:88)

f (u, v) = d(v)

(v,u)∈E

(u,v)∈E

A demand vector is feasible if there is a ﬂow that routes it. For example, the demand vector (1, −1, 0, . . . 0)
representing a transaction of amount 1 from v1 to v2 is feasible if, say, there is an edge (payment channel) from v1 to v2
of capacity at least 1.

Consider a list of transactions T = [t1, . . . tk] each represented as a demand vector, i.e., ti is a demand vector with
wi in the position of the sender, −wi in the position of the receiver, and zero otherwise, where wi is the transaction
amount of ti. We denote by |ti| := wi the amount of transaction ti. We deﬁne transaction aggregation as the process
of:
(i) algebraically adding up all the demand vectors in T , to obtain a demand vector d = (cid:80)
t∈T

t,

(ii) computing a ﬂow f that routes d, and then
(iii) executing this ﬂow on the payment channel network as a means of executing all the transactions in T .

The computational challenge of transaction aggrega-
tion lies in ﬁnding a subset T (cid:48) whose aggregate demand
vector can feasibly be routed, which we deﬁne below.

Deﬁnition 1. The Transaction Aggregation Problem on
a directed graph G concerns computing a sublist T ∗ ⊆
T = [t1, . . . tk] that can feasibly be aggregated, and
which is optimal in terms of total throughput (cid:80)
ti∈T ∗ |ti|.

Next, we reformulate the Bank Clearing Prob-
lem [22,39] in our notation, noting it to be a special case
of transaction aggregation.

Deﬁnition 2. The Bank Clearing Problem with n par-
ticipants {v1, . . . , vn}, each with current balance (also
known as cover money) b = (b1, . . . bn) concerns com-
puting a sublist T ∗ ⊆ T = [t1, . . . tk] that can be aggre-
gated into a demand vector d∗ such that d∗ ≤ b, and
which is optimal in terms of total throughput (also known
as clearing volume) (cid:80)
ti∈T ∗ |ti|.

Let us brieﬂy elaborate on the throughput beneﬁts of
transaction aggregation. First, it may be that the complete
list T cannot be aggregated into a feasible demand vector,

are

aggregation

annotated with their

example. Non-
Fig. 3: A transaction
capacity
depleted edges
(e.g. c(v2, v1) = 0, while c(v1, v2) = 4). Let T =
[(10, 0, −10, 0, 0, 0), (10, 0, −10, 0, 0, 0), (0, 0, 0, 10, 0, −10)],
i.e., two transactions of 10 coins from v1 to v3 and one
transaction of 10 coins from v4 to v6. These transac-
tions are infeasible if executed sequentially. However,
T ∗ = [(10, 0, −10, 0, 0, 0), (0, 0, 0, 10, 0, −10)] can be ag-
gregated to the demand vector d = (10, 0, −10, 10, 0, −10),
and executed by the ﬂow f with f (v1, v6) = f (v4, v3) = 10
and f (e) = 0 otherwise.

5

v1v2v3v6v5v444441010Fig. 5: Skeleton protocol for transaction aggregation.

but sublists of transactions can (Figure 3). Figure 3 also illustrates that routing an aggregate may require less ﬂow along
channels, or use shorter paths, and thus incur lower fees. Secondly, there is a varying degree of cancelling out of the
demand vector d, depending on transactions in T . That is, transactions might be completely independent (payment
paths are disjoint), or all of them can cancel out (e.g. s and r want to pay each other the same amount), leading to a
smaller demand vector, or anything between these two extremes. This form of canceling out is beneﬁcial regardless of
channel capacities. We give an example in Figure 4. Note that the cancelling out feature of transaction aggregation
might render a list of transactions feasible, even though channel capacities do not sufﬁce for sequential execution.

In what follows, we will refer to oracles O as algorithms that can solve the transaction aggregation prob-
lem, possibly under certain assumptions on G and T , to return a feasible sublist T ∗ that maximizes a linear
function of T . The transaction aggregation problem is generally computationally hard as we show in Section 4.

2.4 Protocol overview

In this section, we introduce a protocol abstraction or
the “skeleton” protocol for solving and executing the
transaction aggregation problem in a payment channel
network formulated as described in Section 2.3 under our
assumptions.

Our skeleton protocol consists of two phases: a ﬂow
computation phase and an execution phase. The goal of
the ﬂow computation phase is to privately compute and
output an optimal transaction ﬂow from the list of trans-
action requests submitted to the protocol. The goal of the
execution phase is to execute the ﬂow in an atomic fash-
ion. An illustration of the ﬂow of the skeleton protocol
can be found in Figure 5.

Flow computation phase The ﬂow computation phase
initiates when a pre-speciﬁed amount of time elapses or
when sufﬁciently many transactions have been collected
by the users7. In this phase, the list of transactions T as
well as the respective channel balances are taken as input.
The output of the ﬂow computation phase is a sublist
of transactions T ∗ that will be eventually executed in
the PCN, along with a resultant ﬂow f that routes the
aggregate of these transactions.

to the examples. We consider

transactions.
Fig. 4: Examples of cancelling out of
rele-
Capacities are annotated only on the edges
two examples:
vant
T1 = [(0, 5, 0, −5, 0), (0, 0, 5, 0, −5)] and T2 =
[(0, 0, 5, 0, −5), (0, 0, −2, 0, 2)]. Transaction aggregation
beneﬁts T2 by reducing total ﬂow but not T1. That is, aggre-
gating T2 produces a smaller demand vector (0, 0, 3, 0, −3),
while aggregating T1 yields (0, 5, 5, −5, −5), which is
equivalent to sequential execution.

Execution phase Out of the computed solution T ∗ and f , individual users v are provided with the sublist of T ∗
containing only those transactions where v is a sender or recipient, and the ﬂow f (e) for edges e adjacent to v. With

7 The decision of when the protocol triggers is left to the users. The core idea is to be able to accumulate many transactions per user

may that be after some time interval or when a speciﬁc number of transactions per user is reached.

6

TNodes accumulate transactions within a time intervalT*Computation of optimal sublist of T and per channel ﬂows fValidationNodes validate fExecutionNodes execute fFlow computation phaseExecution phasev5v2v4v1v3101010101010this data, each user veriﬁes the validity of the solution, and that balance security holds, i.e., the user does not lose any
money given the resulting ﬂow and the transactions to be executed. After this veriﬁcation, the users must execute f
atomically. The ﬂow output from the previous ﬂow computation phase might involve disconnected components of the
network; therefore, simple HTLCs may not sufﬁce to atomically execute the transactions T ∗. Instead, a clever solution
is needed where atomicity of all transactions in T ∗ is maintained regardless of the graph topology.

We will introduce the speciﬁc protocols that will be leveraged to implement the skeleton protocol described above

in Section 3.

2.5 Desired Properties

In this section, we discuss the desiderata of our protocol WISER and then formally deﬁne the protocol goals.

First, we demand that our protocol is practical, i.e., that the solution of the transaction aggregation problem is
computationally feasible. Second, WISER should maintain security of the channel balances, meaning that the users
should not lose money due to the protocol execution. In particular, the intermediaries (hubs) should not lose any money,
while the users should only have a deﬁcit equal to the sum of the amounts of the selected transactions in T ∗. This
security property is encapsulated by Balance Security.

Furthermore, we demand two optimization properties: one that ensures that our solution transfers the maximum
amount of value possible, termed Optimality, and one that ensures our solution is cheaper (or equivalent at worse)
than executing the same transactions sequentially in the PCN, termed Cost Efﬁciency. The former property guarantees
that WISER does not output a trivial solution and the solution maximizes the transaction throughput, while the latter
guarantees that WISER is beneﬁcial in terms of fees compared to the no-aggregation solution where each user executes
its transactions sequentially and without the need for coordination on the PCN.

Lastly, due to the potential aggregation of transactions per user, the resulting ﬂow may enhance the privacy of the
protocol compared to the simple sequential execution per user. For instance, if the transaction aggregation selects two
transactions for a user that partially cancel out (e.g., the user receives 5 coins and sends 3 coins), the user’s channel to
the hub will only be updated by the difference (e.g., 5-3=2 coins); thus, the hub only learns the aggregated ﬂow and not
the individual transactions. To capture this improvement on privacy guarantees, we deﬁne the Privacy property.

In particular, we deﬁne the notion of privacy we wish to achieve during the entire course of our protocol, i.e. both
the ﬂow computation and execution phases. We want to enforce, ﬁrstly, that each uninvolved user should only learn that
they are not involved in the protocol. Secondly, each involved user (whether client or hub) should only learn the ﬂow
output on each of the incident channels to the hubs. We stress that the above two conditions imply value privacy: users
will not know the ﬂow (and thus the transaction amounts) along channels they are not a part of. Finally, we allow each
involved user to learn the number of other involved users in the protocol 8.

Formally, WISER should achieve the following properties:

Deﬁnition 3 (Computational Feasibility). The transaction aggregation problem as per Deﬁnition 1 is ﬁxed-parameter
linear (FPL complexity class) [15], i.e., its running time is polynomial in the number of clients and exponential in the
number of hubs.

Deﬁnition 4 (Balance Security). The change in user balances, after the execution of our protocol, must be the
aggregated demand vector of some sublist T (cid:48) ⊂ T of transactions.

Deﬁnition 5 (Optimality). For a given list of transactions, the aggregation should select a maximal sublist in the
sense of total demand fulﬁlled.

Deﬁnition 6 (Cost Efﬁciency).

The total fees levied to users should be less than or equal to the amount that would have been levied had the

transactions been processed sequentially.

Deﬁnition 7 (Privacy). Our notion of privacy is based on the following indistinguishability game between an passive
adversary A and a transaction aggregation and execution protocol Π when run on the subgraph of users interested in
participating in the protocol G = (V, E):

8 Ideally, involved users should not learn any information about the set of other involved users in the protocol. However, our
proposed ﬂow execution protocol requires the number of involved users to be known in advance. We are working on future work
to bound the number of involved users each involved user needs to know.

7

Fig. 6: Proposed implementation of the skeleton protocol for transaction aggregation. Secret sharing is used before the
computation module to select the delegates and share the inputs, MPC is used throughout the computation module and
until the module’s output is delivered to the nodes. The tools used for the computation and (atomic) execution modules
are noted below those boxes.

– A chooses a subset of users V A ⊂ V to corrupt, i.e., A gains access to the transcripts of every corrupted user
v ∈ V A. V A can consist solely of hubs, clients, or a mix of both. Let GA be the subgraph created by taking the
union of all corrupted nodes and their incident edges. Additionally, if a hub node is in V A, we add all the other
hubs in the network and all their incident edges to GA.

– A chooses the following for i ∈ {0, 1}: A creates a list of transactions tuples T i = [(xj, sj, rj)]ni

j=1 where the jth
transaction tuple consists of a transaction amount xj, the vertex sj that requested the transaction, and the vertex
rj that should receive the transaction. ni is the number of transaction tuples in the ith list.

– For every node and channel in GA, the following condition needs to hold: the resulting ﬂow returned by Π
restricted to the subgraph GA when run on G and when given transaction tuple lists T 0 and T 1 has to be the same.
Additionally, the set of involved users as computed by Π should be the same when given T 0 or T 1 as input.

– (Challenge phase.) We choose a random bit b ∈ {0, 1} and run Π with transaction tuple list T b.
– A gets the ﬂow output sent to each corrupted user from Π.
– A outputs a bit b(cid:48). If b(cid:48) = b, A wins the game.

We say a transaction aggregation and execution protocol Π is (cid:15)-private if A wins the above game with probability

at most 1

2 + (cid:15), and private if it is (cid:15)-private for some negligible (cid:15).

3 WISER Architecture

In this section, we present WISER, a protocol that solves the transaction aggregation problem under our system model.
In Section 3.1, we present the topology over which WISER is designed to operate. This restriction is necessary to design
a computationally tractable solution to the otherwise NP-hard transaction aggregation problem (NP-hardness is proved
in Section 4.1). Then we present WISER, which is illustrated in an abstract level in Figure 6.

WISER consists of a ﬂow computation phase (Section 3.2) and an execution phase (Section 3.3). Nodes accumulate
transactions within a ﬁxed time interval and then secret share these transactions and their balances to all hub nodes,
which in turn run a ﬂow computation module. This module privately computes an optimal (in terms of maximum
throughput) sublist of transactions to be executed and a ﬂow that realizes these transactions. WISER then proceeds to
the execution phase. Each node locally validates the ﬂow and selected transactions received by the computation module
and then proceeds to atomically executing the ﬂow. That is, either all ﬂows are executed or none. We summarize WISER
in Algorithm 1 (Section 3.4).

3.1 PCN topology & Channel Factories

We consider the restricted topology presented in Section 2.2. That is, the set of nodes is composed by a small set of hub
nodes H and a set client nodes, such that each client is connected to exactly one hub. This assumption ensures that
transactions, and general demand vectors, can only be routed by unique ﬂows in our PCN. In such a PCN, transaction
aggregation problem is ﬁxed parameter tractable (see Section 4.1 for more details). Moreover, we assume that the hub
nodes are interconnected with a channel factory.

8

TNodes accumulate transactions within a time intervalT*Computation of optimal sublist of T and per channel ﬂows fValidationNodes validate fExecutionNodes execute fSecret sharing & MPCTransaction aggregation oracle:●Dynamic programming   ●Discrepancy techniquesThoraChannel factories were ﬁrst introduced as an intermediate construction between layer 1 on-chain transactions and
layer 2 payment channel transactions[9]. These factories are set up between 3 or more individuals, and henceforth can
be used to instantly open and close off-chain standard payment channels between any 2 of the involved parties.

Two parties set up a conventional payment channel by committing some amount of their individual funds into
a 2-signature wallet considered as a shared account. In much the same way, k parties may set up a channel factory
among themselves by locking funds in a k-signature wallet. The internal working of a channel factory relies in fact on
conventional payment channels, however these are not broadcast publicly nor included in the blockchain. Since the
funds in the internal channels of the factory can be reallocated to new channels instantly, channel factories provide
greater ﬂexibility and scalability.

A conventional payment channel can execute arbitrarily many transactions between two parties provided the
resultant balance lies within the channel’s capacity, and a channel factory can achieve the same functionality for 3
or more parties. Formally, a channel factory between r parties v1, . . . vr of current capacity (c1, c2, . . . cr) (the total
capacity is C = c1 + c2 + . . . cr and is ﬁxed) can route any demand vector (d1, . . . dr) provided di ≤ ci, ∀1 ≤ i ≤ r.
Another equivalent description of channel factories is that the transaction aggregation problem on r parties connected
by a channel factory reduces to the bank clearing problem on r banks.

There is a natural generalization of fees from payment channels to channel factories, where a node vi would charge
a fee for a certain state transition from c = (c1, c2, . . . cr) to c(cid:48) = (c(cid:48)
i < ci ie. if their balance decreases.
Our assumption on the fee function as stated in Section 2.2 generalized to the following: the total forwarding fee must
be a non-negative function F (c0, c1) of the initial and ﬁnal states c0, c1 of the channel factory. F must also satisfy the
triangle inequality: for any states c0, c1, c2, we have

2, . . . c(cid:48)

r) if c(cid:48)

1, c(cid:48)

F (c0, c2) ≤ F (c0, c1) + F (c1, c2).

The improvements of channel factories come at the cost of minor liveness assumptions, namely, that the internal
channels in a factory can only be reorganized when all involved parties are online. Although this assumption is generally
impractical, it is a reasonable one to make in the setting of WISER. Only the hubs, and not the clients, are required to set
up a channel factory. Based on their role as payment service providers, it is fair to expect them to be online regularly.
Channel factories are not crucial to our protocol, but they provide an increase in throughput compared to solely
using payment channels. We recommend a channel factory between the hubs, as opposed to the hubs building various
channels between each other for the following reason: suppose the hubs commit the same amount of capital to a set of
payment channels between them to create a PCN GH between them. Any demand vector d that can feasibly be routed
in GH can also be routed by the channel factory. On the other hand, there are always demands d that a given GH cannot
route but the factory can. In this way, the throughput of the network is maximized for a given amount of capital per hub.

3.2 Flow computation phase

The ﬂow computation phase begins when sufﬁciently many transactions have been collected by the users, or when
a pre-speciﬁed time has elapsed. In this phase, the transaction aggregation problem is solved. In WISER we aim to
preserve the privacy of transactions. For this reason, we employ secret sharing and secure multi-party computation to
solve the optimization problem. The output of the ﬂow computation phase is a list of transactions T ∗ and a ﬂow f to be
executed in the next phase. The two separate components of this phase are discussed below.

Secret Sharing the Transaction Aggregation Input With secret sharing we refer to protocols that allow a user to
distribute a secret among a group of participants, each of whom is allocated a share of the secret. The secret can be
then reconstructed but only when a sufﬁcient number of shares are combined (threshold), meaning that a sufﬁcient
number of participants cooperate. Furthermore, the individual shares (or a subset of the shares with cardinality less
than the threshold) leak no information on the secret. When n is the number of participants that get shares and t is the
reconstruction threshold, the protocol is called (t, n)−threshold secret sharing. WISER is agnostic to the selection of a
speciﬁc secret sharing protocol, so any such scheme can be used such as Shamir’s secret sharing [40].

In WISER, the list of transactions T as well as the channel capacities in either direction are secret shared by the
users, in order to perform a multi-party computation of the transaction aggregation problem. In particular, we assume
the protocol speciﬁes a speciﬁc block header from the underlying blockchain that provides common randomness

9

Algorithm 1: WISER – pseudocode for node u

Local input: out(T , u) a set of outgoing transactions from node u, where T := ∪uout(T , u) and the balances of adjacent

channels {c(u, w), c(w, u) | u and w share a channel}.

Local output: Result of atomic execution of a ﬂow that realizes a sublist out(T ∗, u) ⊆ out(T , u), such that

T ∗ = ∪uout(T ∗, u) is optimal in terms of total throughput (cid:80)

t∈T |t|.

Macros:
f (u): denotes the entries of a ﬂow f referring to edges adjacent to u;
in(T , u), out(T , u): the list of incoming, and respectively, outgoing transactions with respect to node u in the transaction

list T ;

/* Flow computation phase

1 secretSharingProtocol(out(T , u), {c(u, w), c(w, u) | u and w share a channel});
2 if u is a hub (i.e., MPC delegate) then
/* Input validation
for v ∈ V \ H do

3

t∈out(T ,v) |t| ≥ c(v, hv) then T ← T \ out(T , v);

t∈in(T ,v) |t| ≥ c(hv, v) then T ← T \ in(T , v);

4

5

6

if (cid:80)
capacity */
if (cid:80)
capacity */
optimizationOracle();
return out(T ∗, v), f ∗(v) to each node v;

7
8 out(T ∗, u), f ∗(u) ← M P C();

/* Execution phase

*/
/* share input to hubs */

*/

/* exclude txns violating outgoing

/* exclude txns violating incoming

/* u receives MPC output from hubs */
*/
/* validation of out(T ∗, u) */

9 if ∃t ∈ out(T ∗, u) s.t. t /∈ out(T , u) then abort;
10 if ∃t ∈ in(T ∗, u) ∪ out(T ∗, u) s.t. t /∈ in(T ∗, v) ∪ out(T ∗, v) ∧ t is a transaction between u and v then abort;
11 if f ∗(u) does not match the entries for u in f ∗(v) s.t. transactions between u and v appear in T ∗ then abort;
12 if (cid:80)

f (e) (cid:54)= d(v) then abort

f (e) − (cid:80)

/* validation of d vs f */

e=(v,u)∈E
13 T hora(f ∗(u));

e=(u,v)∈E

/* u executes f (u) by participating in Thora [1] */

to the users. Using this randomness, the users select k delegates among the hubs, which will be the ones that will
later execute the optimization oracle to provide a solution of the transaction aggregation problem to all users in a
privacy-preserving manner. The users then (k, k)-threshold secret share to the k delegates their inputs, speciﬁcally their
outgoing transactions and their channel balances. For privacy reasons, we demand that all users send transactions – even
if they are of zero value, when a user has only incoming transactions.

We stress that the k delegates should be sampled from the set of hubs (as opposed to sampling from clients or a
mixture of both) for the following reasons: ﬁrstly, as hubs are large business holders in the PCN, it becomes expensive,
hence difﬁcult, for an adversary to launch Sybil attacks to counterfeit them in order to control a disproportionate fraction
of the delegates. Secondly, computing the solution to the transaction aggregation problem imposes resource and liveness
constraints on the delegates: all delegates need to have sufﬁcient computational power to perform the computation, and
they need to be online throughout the computation process. It would therefore be more reasonable to assume that hubs,
as large ﬁnancial service providers in the PCN, indeed have the capacity to fulﬁl these requirements.

Input Validation Once the transactions and constraints have been secret shared, the delegates should validate the
well-posedness of the input. In particular, the delegates verify that no user submits outgoing transactions that would
exceed the capacity of their channel with their hub, as assumed in Section 2.2.

Solving the Transaction Aggregation Problem Let O denote an optimization oracle that, when given a PCN graph G
and a list of transactions T , returns a sublist T ∗ along with a resultant ﬂow f that routes the aggregate of T ∗. T ∗ is
optimal in the sense that the throughput (cid:80)
|ti| is maximized. We elaborate on our proposed optimization oracle
ti∈T ∗

below.

As stated in Section 3.1, our PCN consists of hubs, connected by a channel factory, and clients connected to one
hub only. The assumption on T is that for each client v, their channel with the hub contains enough liquidity to route all

10

transactions in T where v is the sender. The same channel must also have sufﬁcient liquidity in the opposite direction to
route all transactions where v is the recipient.

Under these assumptions, the transaction aggregation problem reduces to an integer program with |T | variables
and |H| constraints. Although solving such integer programs generally takes time exponential in |T |, we employ a
recent result by Eisenbrand and Weismantel [18] that solves integer programs in time linear in |T |, albeit exponential in
|H|, i.e., the algorithm is ﬁxed-parameter linear [15]. Their algorithm uses discrepancy techniques (which address the
question of rearranging a sequence of vectors to limit the norm of their partial sums) to facilitate dynamic programming.
In Theorem 3 of Section 4.1 we prove that the proposed optimization oracle solves the transaction aggregation problem
and compute its computational complexity.

3.3 Execution phase

The ﬂow computation phase concludes with a solution to the transaction aggregation problem, albeit encoded as secret
shares. The solution consists of the list of accepted transactions T ∗ ⊆ T , along with a resultant ﬂow f on the network.
An execution of this ﬂow would be equivalent to a simultaneous execution of every transaction in T ∗. However, the
solution must ﬁrst be checked for validity, and then be executed atomically though the entire network. In the following,
we discuss how the validation of the solution will be performed as well as the execution of the accepted transactions
through the network in an atomic manner. We further propose a speciﬁc structure for the interconnection of the hubs,
known as payment channel factories [9].

Flow Validation To check that a solution (T ∗, f ) is valid is to check that T ∗ ⊆ T , that aggregation of T ∗ yields a
feasible demand vector d = (cid:80)
t∈T ∗

t, and that the ﬂow f routes d.

A trusted third party could easily verify the above, but we require users to verify these conditions locally. We present
a method for local veriﬁcation, such that a solution is valid if and only if every user locally veriﬁes the above conditions.
v whenever v is the sender or the recipient.
v = {t ∈ T ∗ : tv (cid:54)= 0}. Moreover, v is supplied with f (e) for every

v ⊂ T ∗ such that a transaction t ∈ T ∗

A user v is supplied with a list T ∗

Representing transactions as demand vectors, T ∗
edge e adjacent to v ie. e = (u, v) or e = (v, u).

The users can verify that the provided local data is consistent with that of other users: for every t ∈ T , the
v . Similarly, every pair of adjacent vertices u, v

sender-recipient pair u, v can verify that t ∈ T ∗
with (u, v) ∈ E can verify they have both been provided the same value of f (u, v).

u if and only if t ∈ T ∗

v veriﬁes that every transaction in T ∗

v also belongs in Tv and therefore in T . v computes their aggregate demand

d(v) under T ∗

v . To verify that f routes T ∗ locally, v simply checks if the net ﬂow of f through v is equal to d(v):

(cid:88)

f (e) −

(cid:88)

f (e) = d(v).

e=(v,u)∈E

e=(u,v)∈E

Atomic Execution After this veriﬁcation, the users must execute f atomically, i.e., ensuring that our protocol executes
the set of payments atomically and efﬁciently after performing transaction aggregation, is critical for security. An
incomplete update of channels does not typically correspond to any meaningful ﬁnancial activity like the execution
of a sublist of aggregated transactions. The ﬂow output from the previous ﬂow computation phase might involve
disconnected components of the network. To ensure atomicity of channel updates across all disjoint paths, we employ
the solution proposed in Thora [1] that ensures any number of disjoint channels can be atomically updated within a
constant time interval.

We ﬁrst note that existing HTLC-based solutions like [34,26,28] can guarantee atomicity of the channel updates
only when the subgraph induced by the set of channels form a path. Moreover, these solutions require users along the
path to lock their payment amount for a time linear in the length of the path. For these reasons, in WISER we leverage
Thora, which is solution that performs the multi-channel updates atomically in constant time [1]. Furthermore, Thora
operates in any graph structure as it does not depend on the PCN topology or the connectivity among channels.

In more detail, let f denote the ﬂow in which all channels need to be updated atomically. Let us denote the support
of the ﬂow by E∗ = {ei = (si, ri)}m
i=1, where si denotes the sender and ri denotes the receiver in the ith channel.
In Thora, each receiver ﬁrst creates and signs a special transaction, txep, which contains “dummy” outputs for every

11

receiver ri, i ∈ [n] of value (cid:15) and requires a signature from each sender si. Each sender si then creates a transaction
to update the state of channel ei and another payment transaction for their corresponding receiver ri. A payment
transaction between si and ri takes as input the output to ri in any txep, and must be spent by a timeout period T . Thus,
as long as any txep is posted by any receiver to the ledger before a given timeout period of T , receivers can use their
corresponding output in the txep to ensure they get their payment and spend it. If any receiver does not spend their
payment transaction by the timeout period T , all senders will get a refund with the refund amount being the amount of
the payment. In this way, atomicity of channel updates is ensured.

In Thora, the timeout period T is independent of m, the number of channels involved. In particular, if all users
are honest, all channel updates and payments can be instantaneous, while security is guaranteed even in the presence
of malicious adversaries. We note that Thora guarantees value privacy with respect to channel balances, but requires
all users involved to know the public keys of the other involved users. These public keys can nevertheless be made
pseudonymous (see Section 5.3 for more details).

3.4 Algorithm description

We consolidate the description of WISER in Algorithm 1. We present WISER from the point of view of a node u; be
it client or hub. The input to the protocol is the list of transactions out(T , u) originating from u and the balances of
channels adjacent to u. The output of WISER is the result of the atomic execution of a ﬂow f ∗ that realizes a sublist T ∗
of T , which is optimal in terms of total throughput (cid:80)
t∈T |t|.

Lines 1–8 consist of the ﬂow computation phase. In line 1 node u secret shares its local input to the hubs (MPC
delegates). That is, the outgoing transactions (or a single zero transaction if there is no outgoing transaction) and the
capacities of all adjacent channels. Then, the hub nodes run lines 2–8. They ﬁrst check if the incoming and outgoing
transactions submitted are feasible with the given channel capacities (lines 3–5) and exclude user inputs otherwise.
Subsequently, they run the optimization oracle (line 6), and return the output to all nodes (line 7). With the given output
(line 8), node u proceeds to the execution phase. It ﬁrst validates the output in lines 9–12 and then participates in Thora
with its local input f ∗(u) (line 13).

4 Formal analysis

In this section, we prove that WISER satisﬁes the protocol goals. We ﬁrst discuss the complexity of the transaction
aggregation problem, and show that the presented algorithm is ﬁxed-parameter linear in the number of hubs. Later, we
demonstrate that WISER satisﬁes balance security, optimality and cost efﬁciency. Lastly, we prove security with our
indistinguishability game as per Deﬁnition 7.

4.1 Complexity of the Transaction Aggregation Problem

In section 3.2, we referred to an optimization oracle O to abstract out the algorithmic challenge of computing an
optimal sublist T ∗ ⊂ T . Here, we will ﬁrst show that the problem is NP-hard in general via reduction from the
well-known subset sum problem. Then we will restrict attention to our speciﬁc graph and show that the problem is
ﬁxed-parameter linear. That is, we show that the computational complexity of the optimization oracle is linear in the
number of transactions |T | but exponential in m, the number of hubs.

Theorem 1. The Transaction Aggregation Problem is NP-hard.

Proof. In fact, the problem is NP-hard even for a graph on two vertices and no edges. Consider an instance of the
Subset Sum problem, well-known to be NP-hard: given a positive integer A and a set {a1, . . . , ak} of positive integers,
ﬁnd a subset of them that sum to A.

Let G = (V, E) with V = {v1, v2}, E = ∅. Let T = {(a1, −a1), (a2, −a2), . . . (ak, −ak), (−A, A)}. Finding
any nonempty subset of T , let alone one optimal in terms of throughput, which can feasibly be aggregated, yields a
solution of the Subset Sum problem.

12

Remark: Transaction aggregation coincides with BCP when the graph has only two vertices. Thus, the NP hardness
(and in fact inapproximability) follows from the NP-hardness and inapproximability of BCP with two participants[22].
We now proceed to calculating the computational complexity of the optimization oracle (Section 3.2). Let us ﬁrst

state the relevant theorem from [18] before proceeding to apply it to our setting.

Theorem 2 (Theorem 8 in [18]). An integer program of the form9

max wTx

such that

for c ∈ Zk, A ∈ Zh×k, b ∈ Zh, u ∈ Zk
absolute value by ∆.

Ax ≤ b, 0 ≤ x ≤ u, x ∈ Zk.
+, can be solved in time O(k(h∆)h2

), provided all entries of A are bounded in

Theorem 3. The Transaction Aggregation problem of WISER can be solved in time O(k(h∆)h2
bound on the demand of every transaction, k is the number of transactions in T and h is the number of hubs.

), where ∆ is an upper

Proof. It is sufﬁcient to reformulate the transaction aggregation problem as one satisfying the hypothesis of Theorem 2
above.

Consider an arbitrary ordering of the transactions in T = {t1, . . ., tk}. For a vector x ∈ {0, 1}k, let T (x) =
{ti : xi = 1}. We need to construct a matrix A and vectors w, b such that ﬁnding the optimal sublist T ∗ ⊂ T is
equivalent to ﬁnding a vector x maximizing wTx subject to Ax = b and 0 ≤ x ≤ u, where u is the all ones vector.

The main idea behind the construction of A is that, by our assumption on client-hub channels having sufﬁcient
capacity to route all transactions from T , we need only consider feasibility of the demand vector of a sublist T (cid:48) with
respect to the channel factory between the hubs.

So let us order the hubs as h1, h2, . . . , hm and deﬁne b = (b1, b2, . . ., bm) as: bi is the current balance of hi in the
channel factory. Now, for every transaction ti ∈ T of demand |ti|, we deﬁne Ai, the ith row of A coordinate-wise as:
Ai,j = |ti| if the sender of ti is connected to the hub hj. Ai,j = −|ti| if the recipient of ti is connected to hub hj, and
0 otherwise. We deﬁne w as wi = |ti|.

The vector Ax represents the requisite ﬂow in the channel factory for routing the aggregate of T (x). Due to our
assumption on the capacity of client-hub channels, this is sufﬁcient for checking for the feasibility of the aggregate.
Since b represents the current state of the channel factory, the aggregate of T (x) is feasible if and only if Ax ≤ b. We
conclude the proof by observing that maximizing the objective max cTx is equivalent to maximizing the throughput
(cid:80)|ti| of the aggregate.

Theorem 3 immediately implies the following.

Corollary 1. WISER satisﬁes computational feasibility as in Deﬁnition 3.

4.2 Balance Security

Here, we show that the users of WISER do not lose any money through their participation in the protocol.

Theorem 4. WISER satisﬁes balance security as in Deﬁnition 4.

Proof. The ﬂow execution phase of WISER is the only phase that involves monetary ﬂow, hence requiring atomicity.
In WISER, ﬂow execution is done using Thora, which guarantees atomicity of channel updates assuming rational
adversaries (see [1] for more details). Thus, WISER also inherits atomicity against rational adversaries. As a result,
either the atomic execution of a ﬂow that routes our optimal list T ∗ succeeds, implies that the change in user balances
corresponds to the same sublist T ∗ ⊂ T . Or, the atomic execution failed, in which case the user balances are unchanged,
corresponding to the empty sublist ∅ ⊂ T .

9 The integer program in [18] is presented in the so-called standard form of Ax = b, whereas we use the inequality form Ax ≤ b
here for simplicity of exposition. Any integer program can be reformulated from inequality form to standard form by the
introduction of slack variables, which doubles the number of variables. This is inconsequential in our case as our dependence on
the number of variables is linear.

13

4.3 Optimality & Cost Efﬁciency

Here, we ﬁrst show that the selected set transaction is maximal in terms of throughput. Next, we show that the users of
WISER may beneﬁt from their participation in the system in terms of fees.

Theorem 5. WISER satisﬁes optimality as in Deﬁnition 5.

Proof. This follows immediately from the objective function of the transaction aggregation problem (Deﬁnition 1) and
the correctness of the optimization oracle (Theorem 3).

Theorem 6. WISER satisﬁes cost efﬁciency as in Deﬁnition 6.

Proof. We wish to prove that total fee levied to users should be no greater than the fees that would have been levied had
the transactions been processed sequentially. Although WISER routes an optimal sublist T ∗, we prove the above for any
list T of transactions that can feasibly be aggregated. The main idea of this proof is that forwarding fees satisfy the
triangle inequality, and that transactions can only be routed along unique paths (Section 2.2).

Suppose T = [t1, . . . tk] and the ﬂow f routes T . Note that a sequential execution of transactions may not be
possible although the atomic execution of the aggregate (this is in fact one of the beneﬁts of transaction aggregation), in
which cost efﬁciency holds trivially. Suppose that a sequential execution of transactions is indeed possible, and without
loss of generality assume this order is t1, t2 . . . tk.

Consider any channel or channel factory C in our PCN, and let a0 be its initial state. Suppose the atomic execution
of f leaves C in the ﬁnal state af , and this incurs fee F = F (a0, af ). Next, suppose the sequential execution of
transactions takes C along states a0, a1, . . . ak = af , so that the routing of ti involves a state transition from ai−1 to ai
and costs F (ai−1, ai). Since the fee function satisﬁes the triangle inequality,

F (a0, af ) = F (a0, ak) ≤

k
(cid:88)

i=1

F (ai−1, ai).

Observing that the total fees incurred is simply the sum of forwarding fees per channel, this establishes cost efﬁciency.

4.4 Privacy

Our transaction aggregation solution as well as the execution protocol satisﬁes our privacy notion, i.e.,

Theorem 7. WISER satisﬁes the privacy notion from Deﬁnition 7 (assuming the users running the MPC protocol
satisfy the trust assumptions required by the underlying MPC protocol).

Proof. Consider the indistinguishability game as deﬁned in Deﬁnition 7. Let us assume during the challenge phase
of the game there exists a trusted third party (TTP) that computes a ﬂow fb from the challenge transaction tuple list
T b. Suppose additionally that the computed ﬂow satisﬁes all the constraints as detailed in Deﬁnition 7. The TTP
subsequently lets each user in V know how much they need to send or receive on each of their incident edges.

Each corrupted user learns, from the TTP, only the amount they need to send or receive on each of their incident
channels. Since the ﬂow restricted on GA has to be the same when the protocol is run on either T 0 or T 1, the joint
view of the adversarial nodes when the protocol is run on T 0 or T 1 is identical (and thus trivially indistinguishable).
Now we can replace the above assumption of a TTP with an MPC protocol that computes the same functionality
with the same privacy guarantees. If the parties running the MPC protocol satisfy the trust assumption of the underlying
protocol, privacy is preserved. A natural choice would be to use a computationally (rather than information theoretically)
secure MPC protocol (so we have privacy unless all the users are corrupted), and (for efﬁciency reasons) pick a small
random subset of the users to run the MPC protocol after receiving the secret-shared inputs from all the participating
users. This way privacy is preserved unless the entire randomly picked subset of users has been corrupted by the
adversary.

The execution phase of our protocol uses the Thora protocol as a black box, and Thora guarantees that payment
values along any channel that needs to be updated are not known to anyone except the channel owners. This again
ensures that involved users only know the payments and hence ﬂow on their incident channels. Thora leaks the set of

14

involved users, but they can be made pseudonymous using ephemeral keys (see Section 5.3). Thus, the only information
involved users gain is the number of all other involved users, which is allowed in our privacy deﬁnition.

Since we restrict the set of involved users to be exactly the same when the protocol computes the ﬂow given
transaction tuples T 0 and T 1, the view of an adversarial node when the execution phase of the protocol is run on T 0 or
T 1 is again indistinguishable, hence the execution phase is private.

5 Discussion & Extensions

In this section, we ﬁrst discuss the WISER architecture and its various components. Then, we elaborate on our privacy
deﬁnition and potential extensions. Finally, we revisit the assumptions of this work and in particular the fees requested
for routing by the hubs.

5.1 WISER modularity

WISER implements the skeleton protocol described in Section 2.4. However, the speciﬁc components of the skeleton
protocol are modular, in the sense that they can be replaced with other protocols that maintain the same guarantees.

As mentioned previously, there are various suitable MPC frameworks we can use. As an active area of research, we
expect improvements on the side of secret sharing and MPC protocols, which would directly apply to WISER. The
delegates conducting the MPC can also be chosen from any set of parties that have sufﬁcient computing power and
strong identities. The MPC may even be entirely replaced by a semi-trusted third party if the application does not
require privacy of transactions and channel balances.

The rest of the components are also replaceable. Executing the ﬂow derived from aggregating transactions can be

implemented by any protocol, like Thora, that provides atomicity of channel updates.

In WISER we assume the hubs have created an on-chain channel factory. Although this construction beneﬁts the
protocol in terms of throughput, lower liquidity requirements as well as runtime, this structure is by no means restrictive
or necessary for our protocol execution. Hubs that are already connected via traditional payment channels in an arbitrary
graph structure can implement transaction aggregation without paying for constructing channel factories.

Most importantly, the optimization oracle is also replaceable. In Section 5.2 below, we demonstrate the equivalence
of BCP, the Bank Clearing Problem and transaction aggregation on channel factories. Due to the modularity of WISER,
we can use any of the algorithms developed for BCP as our optimization oracles. We also discuss applicable algorithms
below.

5.2 Connection to Netting

As observed in Section 3.1, the use of channel factories between h hubs with capacities c = (c1, c2, . . . cr) allows for
routing of any demand vector d = (d1, d2, . . . dr) so long as d ≤ c. Observe that this feasibility constraint is identical
to that of the Bank Clearing Problem when h participants have capital (or cover money) c. Since both transaction
aggregation and BCP aim to maximize throughput or clearing volume, the problem of transaction aggregation on a
channel factory is equivalent to BCP.

On one hand, this means our ﬁxed-parameter linear algorithm from Section 4 also shows that BCP is ﬁxed-parameter
linear in the parameter (h∆). This linear dependence on the number of transactions is not only best possible (since
simply reading a list of k transactions requires O(k) time), but also improves upon the previous known polynomial
dependence on k.

Although the algorithm we present in Section 4.1 enjoys the best known asymptotic complexity, other, simpler
algorithms such as the pseudopolynomial time dynamic programming solution of [22] may be faster in certain parameter
regimes. Moreover, although BCP has been shown to be inapproximable unless P = NP, [39] propose a fast heuristic
for approximately solving it, which may also be employed here to achieve even faster implementations at the cost of
optimality.

5.3 Privacy

Here we discuss two privacy issues regarding our protocol.

15

Revealing the full set of involved users. As brieﬂy mentioned in Deﬁnition 7, we use Thora to execute the computed
ﬂow atomically, and this leaks the full set of involved users. This is because every receiver in Thora has to create a
special transaction txep that contains outputs for every other receiver and signed with a signature from each sender. Not
only is it possible, but it is also good practice, to use fresh ephemeral public keys (also known in the literature as receive
addresses) when receiving tokens in UTXO-based cryptocurrencies. If all users employ fresh receive addresses each
time they participate in our protocol, the only information leaked would be the number of involved users. We consider
this a non-issue, as the set of involved users is not revealed, but only the size of this set.

Hiding transaction requests from hubs. In WISER, users secret share their transaction requests and the transaction
aggregation problem is solved using MPC. Thus, the ﬂow computation stage conceals transactional data.

In the execution phase, the hubs see the aggregated ﬂow output on all their incident channels, but they cannot
conﬁdently determine sender-recipient pairs or demands since the number of transactions is not known to them. This
gives users an additional potential privacy beneﬁt when using our protocol as compared to when the hubs sequentially
execute transaction requests.

5.4 Optimizing for Fees

The algorithm presented in Section 4.1 seeks a feasible sublist of transactions that maximizes throughput without
considering the fees incurred in the execution of ﬂow. As a result, we can only guarantee the weak notion of cost
efﬁciency as given in Deﬁnition 6: that the fee is no greater than the case without transaction aggregation at all ie. had
the transactions been processed sequentially.

WISER can in fact achieve greater cost efﬁciency by modifying the optimization oracle. In fact, only the objective
function, and not the algorithm itself, must be modiﬁed to a sum of throughput and total fees incurred, with a certain
trade-off factor relating the importance of these two objectives. By leaving the constraints of the integer program
unchanged, this extension enjoys the same runtime as given by Theorem 3.

6 Related work

Payment channel networks have received much attention recently as a promising way to increase the limited transaction
throughput of blockchains. Payment channels were originally introduced by Spilman [42], but the ﬁrst bidirectional
constructions followed later with the Bitcoin Lightning Network [34] and the Duplex Micropayment Channels [13].
There is currently a ﬂurry of payment channel proposals each optimizing a different aspect [6,29,12,7,2,30,17,3,16];
see [14] for a recent survey.

Routing on PCNs. The original proposals for payment channels faced many practical challenges. A major challenge
was how to design an efﬁcient routing algorithm for a PCN: as the current balances on the network are not known,
identifying a viable short path from sender to receiver proved to be difﬁcult. Several routing protocols for PCNs have
been developed to provide efﬁcient solutions to this problem. Flare [35] and SilentWhispers [25] both employ highly
connected nodes to route the payments in order to improve the scalability of the routing algorithm. SpeedyMurmurs [38]
and VOUTE [37] improve the process by leveraging a routing approach called preﬁx embeddings. Flash [47] uses a
modiﬁed max-ﬂow algorithm to ﬁnd the optimal path, while Perun [16] introduces virtual channels to avoid routing
through intermediaries. On a different front, other routing discovery algorithms focus on maintaining the anonymity
and privacy during the route discovery [33,5] or the transaction execution [45].

However, all of these works focus on a different problem, that of efﬁcient (and often privacy-preserving) routing in
PCNs with arbitrary graph structure. We, on the other hand, simplify the network structure and examine how the users
of such a graph topology can beneﬁt from other functionalities of transaction aggregation such as canceling out and
“transferwise”, in order to increase throughput and decrease the intermediaries’ fees.

Rebalancing PCNs. The previously mentioned routing approaches generally ignore the issue of balance depletion;
channels that transfer coins mainly in one direction will soon get depleted and must top-up the balance on-chain.
The rebalancing problem was identiﬁed and addressed in Revive [23], which was the ﬁrst work to propose the use

16

of rebalancing strategies. Many interesting follow-up works spawned afterwards: Pickhardt et al. [32] improved the
balances of a PCN as a sequence of rebalancing operations of the channel funds, while Avarikioti et al. presented Hide &
Seek, [8] a privacy-preserving decentralized rebalancing protocol that improved upon Revive. Also the Bitcoin Lightning
Network comes with rebalancing plugins, e.g., c-lightning10 and lnd11. The Spider Network [41] splits payments into
smaller units and routes them over multiple paths using waterﬁlling, aiming to efﬁciently route transactions while
maintaining balanced channels. The Merchant [19] utilises adaptive fee strategies to incentivize the balanced use of
payment channels, and [24] uses estimated payment demands along channels to plan the amount of funds to inject
into a channel during channel creation. There also exist several interesting approaches to save fees in payment channel
networks, e.g., virtual channels [16], and studies on the security implications of such fee mechanisms [44].

Transaction aggregation is intrinsically related to the question of rebalancing in the sense that multiple ﬂows can
execute a given aggregate of transactions, and an appropriate choice of ﬂow inevitably results in minimal channel
depletion. In other words, rebalancing can be interpreted as transaction aggregation of an empty list of transactions.
However, none of these works leverage transaction aggregation to increase throughput in PCNs and hence do not enable
routing transactions even in a disconnected graph topology with the newly introduced “transferwise” functionality.

Atomic multi-hop transaction execution. Traditional payment channel networks like the Bitcoin Lightning network
achieve the atomic execution of multi-hop payments using Hash Timelock Contracts or HTLCs [34,13]. however,
HTLC suffer from sepciﬁc attacks such as the wormhole attack [27]. In a recent line of work, several proposals exist
that improve upon the use of simple HTLCs to guarantee the atomic execution of transactions, typically targeting
efﬁciency and security in an extended model [4,43,1]. These works are complementary to ours because our proposed
solution requires the use of a protocol that can execute transactions in an atomic manner in general topologies where
the graph can even be disconnected. Therefore, any efﬁciency improvements on the atomic transaction execution in
generic topologies implies immediately an efﬁciency improvement on WISER.

Netting. Our work is closely related to netting systems in ﬁnancial markets, speciﬁcally netting for inter-bank settlements,
which involve using a central entity (typically a central bank) to settle all liabilities of involved ﬁnancial institutions [21].
The netting problem for banks, also known as the Bank Clearing Problem, is NP-complete and inapproximable. However,
heuristic-based algorithms that yield approximate solutions in practice have been developed in [22] and [39]. On the
side of exact algorithms, a pseudopolynomial time exact algorithm for BCP was presented in [22]. This exact algorithm
is based on dynamic programming, but processes transactions in the same order as input. Our algorithm, also based
on dynamic programming, improves upon theirs by exploiting discrepancy techniques to reorder the transactions and
hence reduce time and memory requirements to linear.

Besides the algorithmic connection, netting is also related to our work in terms of privacy and decentralization.
Although inter-bank netting traditionally relies on central banks as mediators, there are multiple reasons to seek
decentralized alternatives. Central banks are trusted to preserve the conﬁdentiality of transactional data, as well as
perform the netting correctly, which incurs greater liability for all involved parties. As observed in [10], ﬁnding trusted
mediators for cross-border multi-currency transfer is also challenging. To this end, there are some works which aim
to implement decentralised netting systems [11,10]. In particular, the work of Cao et al. provides a decentralized and
optimal netting solution that also guarantees the privacy of payment amounts using smart contracts and zero knowledge
proofs on the blockchain [10]. Our work, in contrast, aims to address this problem for payments on payment channel
networks, and thus all our proposed solutions in WISER seek to reduce the usage of the underlying blockchain for
arbitration.

7 Conclusion

In this work, we formulated the transaction aggregation problem and presented a protocol solving it. Transaction aggre-
gation can potentially increase throughput and even realize payments that were infeasible when executed sequentially.
We presented a skeleton protocol for a hub-based business model that abstracts the components required to (i) privately
compute the ﬂows through each channel maximizing the transaction throughput, and (ii) execute those ﬂows atomically.

10 https://github.com/lightningd/plugins/tree/master/rebalance
11 https://github.com/bitromortac/lndmanage

17

We then presented WISER, an implementation of our skeleton protocol: In WISER we employed channel factories as the
intra-hub channel structure. We further proposed a ﬁxed-parameter linear algorithm to solve the transaction aggregation
problem, which we execute via an MPC to maintain privacy of transactions and channel balances. Finally, WISER
utilized Thora to execute the ﬂow atomically across the PCN. With WISER we (a) enhanced the liquidity of the PCN, (b)
effectively reducing the transaction fees to the hubs, while (c) maintaining the privacy of the transaction’s and channels’
data.

We regard our work as a ﬁrst step toward more general protocols. Speciﬁcally, an interesting future work is to design
a computationally tractable protocol for more general topologies than the hubs/clients topology we use. Algorithmic
breakthroughs in the speciﬁc topology we consider would also beneﬁt centralized or decentralized netting protocols.
Also, we can improve the privacy guarantees by anonymizing the involved users or hiding transaction requests from
hubs. Moreover, it is orthogonal to our work to compute a fee mechanism charged by the hubs. Note that including fees
in the optimization component is straightforward and does not affect the protocol’s complexity, although its effect on
throughput is not understood.

References

1. Aumayr, L., Abbaszadeh, K., Maffei, M.: Thora: Atomic and privacy-preserving multi-channel updates. IACR Cryptol. ePrint

Arch. p. 317 (2022), https://eprint.iacr.org/2022/317

2. Aumayr, L., Ersoy, O., Erwig, A., Faust, S., Host´akov´a, K., Maffei, M., Moreno-Sanchez, P., Riahi, S.: Bitcoin-compatible

virtual channels. IACR Cryptology ePrint Archive, Report 2020/554 (2020)

3. Aumayr, L., Ersoy, O., Erwig, A., Faust, S., Hostakova, K., Maffei, M., Moreno-Sanchez, P., Riahi, S.: Generalized bitcoin-

compatible channels. IACR Cryptology ePrint Archive, Report 2020/476 (2020)

4. Aumayr, L., Moreno-Sanchez, P., Kate, A., Maffei, M.: Blitz: Secure multi-hop payments without two-phase commits. In: Bailey,
M., Greenstadt, R. (eds.) 30th USENIX Security Symposium, USENIX Security 2021, August 11-13, 2021. pp. 4043–4060.
USENIX Association (2021), https://www.usenix.org/conference/usenixsecurity21/presentation/
aumayr

5. Avarikioti, Z., Bastankhah, M., Maddah-Ali, M.A., Pietrzak, K., Svoboda, J., Yeo, M.: Route discovery in private payment

channel networks. IACR Cryptol. ePrint Arch. p. 1539 (2021), https://eprint.iacr.org/2021/1539

6. Avarikioti, Z., Kogias, E.K., Wattenhofer, R., Zindros, D.: Brick: Asynchronous incentive-compatible payment channels. In: FC

(2021), https://fc21.ifca.ai/papers/168.pdf

7. Avarikioti, Z., Litos, O.S.T., Wattenhofer, R.: Cerberus channels: Incentivizing watchtowers for bitcoin. In: International

Conference on Financial Cryptography and Data Security. pp. 346–366. Springer (2020)

8. Avarikioti, Z., Pietrzak, K., Salem, I., Schmid, S., Tiwari, S., Yeo, M.: HIDE & SEEK: privacy-preserving rebalancing
on payment channel networks. In: International Conference on Financial Cryptography and Data Security (FC) (2022),
https://arxiv.org/abs/2110.08848

9. Burchert, C., Decker, C., Wattenhofer, R.: Scalable funding of bitcoin micropayment channel networks - regular submission. In:

SSS (2017)

10. Cao, S., Yuan, Y., Caro, A.D., Nandakumar, K., Elkhiyaoui, K., Hu, Y.: Decentralized privacy-preserving netting protocol
on blockchain for payment systems. In: Bonneau, J., Heninger, N. (eds.) Financial Cryptography and Data Security - 24th
International Conference, FC 2020, Kota Kinabalu, Malaysia, February 10-14, 2020 Revised Selected Papers. Lecture Notes in
Computer Science, vol. 12059, pp. 137–155. Springer (2020). https://doi.org/10.1007/978-3-030-51280-4 9, https://doi.
org/10.1007/978-3-030-51280-4_9

11. Chapman, J., Garratt, R., Hendry, S., McCormack, A., McMahon, W.: Project jasper: Are distributed wholesale payment systems

feasible yet? (2017)

12. Decker, C., Russell, R., Osuntokun, O.: eltoo: A simple layer2 protocol for bitcoin. https://blockstream.com/eltoo.

pdf (2018)

13. Decker, C., Wattenhofer, R.: A fast and scalable payment network with bitcoin duplex micropayment channels. In: Symposium

on Self-Stabilizing Systems. pp. 3–18. Springer (2015)

14. Dotan, M., Pignolet, Y.A., Schmid, S., Tochner, S., Zohar., A.: Survey on blockchain networking: Context, state-of-the-art,

challenges. In: Proc. ACM Computing Surveys (CSUR) (2021)

15. Downey, R.G., Fellows, M.R.: Parameterized complexity. Springer Science & Business Media (2012)
16. Dziembowski, S., Eckey, L., Faust, S., Malinowski, D.: Perun: Virtual payment hubs over cryptocurrencies. In: IEEE Symposium

on Security and Privacy. pp. 327–344 (2017)

18

17. Egger, C., Moreno-Sanchez, P., Maffei, M.: Atomic multi-channel updates with constant collateral in bitcoin-compatible
payment-channel networks. In: Proceedings of the 26th ACM SIGSAC Conference on Computer and Communications Security.
pp. 801–815. ACM (2019)

18. Eisenbrand, F., Weismantel, R.: Proximity results and faster algorithms for integer programming using the steinitz lemma. CoRR

abs/1707.00481 (2017), http://arxiv.org/abs/1707.00481

19. van Engelshoven, Y., Roos, S.: The merchant: Avoiding payment channel depletion through incentives. In: IEEE International
Conference on Decentralized Applications and Infrastructures, DAPPS 2021, Online Event, August 23-26, 2021. pp. 59–68. IEEE
(2021). https://doi.org/10.1109/DAPPS52256.2021.00012, https://doi.org/10.1109/DAPPS52256.2021.00012
20. Garay, J., Kiayias, A., Leonardos, N.: The bitcoin backbone protocol with chains of variable difﬁculty. In: CRYPTO (2017),

10.1007/978-3-319-63688-7_10

21. Garratt, R., Zimmerman, P.: Centralized netting in ﬁnancial networks. Journal of Banking & Finance 112, 105270
(2020). https://doi.org/https://doi.org/10.1016/j.jbankﬁn.2017.12.008, https://www.sciencedirect.com/science/
article/pii/S0378426617302959, challenges to global ﬁnancial stability: interconnections,credit risk, business cycle
and the role of market participants

22. G¨untzer, M.M., Jungnickel, D., Leclerc, M.: Efﬁcient algorithms for the clearing of interbank payments. Eur. J. Oper. Res. 106(1),
212–219 (1998). https://doi.org/10.1016/S0377-2217(97)00265-8, https://doi.org/10.1016/S0377-2217(97)
00265-8

23. Khalil, R., Gervais, A.: Revive: Rebalancing off-blockchain payment networks. In: CCS (2017), 10.1145/3133956.

3134033

24. Li, P., Miyazaki, T., Zhou, W.: Secure balance planning of off-blockchain payment channel networks. In: 39th IEEE Con-
ference on Computer Communications, INFOCOM 2020, Toronto, ON, Canada, July 6-9, 2020. pp. 1728–1737. IEEE
(2020). https://doi.org/10.1109/INFOCOM41043.2020.9155375, https://doi.org/10.1109/INFOCOM41043.2020.
9155375

25. Malavolta, G., Moreno-Sanchez, P., Kate, A., Maffei, M.: Silentwhispers: Enforcing security and privacy in decentralized credit

networks. In: NDSS (2017), 10.14722/ndss.2017.23448

26. Malavolta, G., Moreno-Sanchez, P., Kate, A., Maffei, M., Ravi, S.: Concurrency and privacy with payment-channel networks.

CoRR abs/1911.09148 (2019), http://arxiv.org/abs/1911.09148

27. Malavolta, G., Moreno-Sanchez, P., Schneidewind, C., Kate, A., Maffei, M.: Anonymous multi-hop locks for blockchain

scalability and interoperability. In: NDSS (2019), 10.14722/ndss.2019.23330

28. Mazumdar, S., Ruj, S.: Cryptomaze: Privacy-preserving splitting of off-chain payments. IACR Cryptol. ePrint Arch. p. 123

(2022), https://eprint.iacr.org/2022/123

29. McCorry, P., Bakshi, S., Bentov, I., Meiklejohn, S., Miller, A.: Pisa: Arbitration outsourcing for state channels. In: AFT (2019),

10.1145/3318041.3355461

30. Miller, A., Bentov, I., Bakshi, S., Kumaresan, R., McCorry, P.: Sprites and state channels: Payment networks that go faster than

lightning. In: International Conference on Financial Cryptography and Data Security. pp. 508–526 (2019)

31. Nakamoto, S.: Bitcoin: A peer-to-peer electronic cash system. https://bitcoin.org/bitcoin.pdf (2008)
32. Pickhardt, R., Nowostawski, M.: Imbalance measure and proactive channel rebalancing algorithm for the lightning network.
In: IEEE International Conference on Blockchain and Cryptocurrency, ICBC 2020, Toronto, ON, Canada, May 2-6, 2020.
pp. 1–5. IEEE (2020). https://doi.org/10.1109/ICBC48266.2020.9169456, https://doi.org/10.1109/ICBC48266.
2020.9169456

33. Pietrzak, K., Salem, I., Schmid, S., Yeo, M.: Lightpir: Privacy-preserving route discovery for payment channel networks. In:

IFIP Networking (2021), 10.23919/IFIPNetworking52078.2021.9472205

34. Poon, J., Dryja, T.: The bitcoin lightning network: Scalable off-chain instant payments. https://lightning.network/

lightning-network-paper.pdf (2015)

35. Prihodko, P., Zhigulin, S., Sahno, M., Ostrovskiy, A., Osuntokun, O.: Flare: An approach to routing in lightning network.

shorturl.at/adrHP (2016)

36. Qorchi, M.E., Maimbo, S.M., Wilson, J.F.: Informal Funds Transfer Systems: An Analysis of the Informal Hawala System.
International Monetary Fund, USA (2003). https://doi.org/10.5089/9781589062269.084, https://www.elibrary.imf.
org/view/books/084/03590-9781589062269-en/03590-9781589062269-en-book.xml

37. Roos, S., Beck, M., Strufe, T.: Voute-virtual overlays using tree embeddings. arXiv: 1601.06119 (2016), http://arxiv.

org/abs/1601.06119

38. Roos, S., Moreno-Sanchez, P., Kate, A., Goldberg, I.: Settling payments fast and private: Efﬁcient decentralized routing for

path-based transactions. In: NDSS (2018), 10.14722/ndss.2018.23254

39. Shafransky, Y.M., Doudkin, A.A.: An optimization algorithm for the clearing of interbank payments. Eur. J. Oper. Res. 171(3),
743–749 (2006). https://doi.org/10.1016/j.ejor.2004.09.003, https://doi.org/10.1016/j.ejor.2004.09.003
40. Shamir, A.: How to share a secret. Commun. ACM 22(11), 612–613 (nov 1979). https://doi.org/10.1145/359168.359176,

https://doi.org/10.1145/359168.359176

19

41. Sivaraman, V., Venkatakrishnan, S.B., Ruan, K., Negi, P., Yang, L., Mittal, R., Fanti, G., Alizadeh, M.: High throughput
cryptocurrency routing in payment channel networks. In: 17th USENIX Symposium on Networked Systems Design and
Implementation (NSDI). pp. 777–796 (2020)

42. Spilman, J.: Anti dos for tx replacement. https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-April/002433.html (2013),

accessed: 2020-11-22

43. Tairi, E., Moreno-Sanchez, P., Maffei, M.: A2l: Anonymous atomic locks for scalability in payment channel hubs. In: 42nd
IEEE Symposium on Security and Privacy, SP 2021, San Francisco, CA, USA, 24-27 May 2021. pp. 1834–1851. IEEE (2021).
https://doi.org/10.1109/SP40001.2021.00111, https://doi.org/10.1109/SP40001.2021.00111

44. Tochner, S., Zohar, A., Schmid, S.: Route hijacking and dos in off-chain networks. In: Proc. ACM Conference on Advances in

Financial Technologies (AFT) (2020)

45. Tripathy, S., Mohanty, S.K.: Mappcn: Multi-hop anonymous and privacy-preserving payment channel network. In: International

Conference on Financial Cryptography and Data Security. pp. 481–495. Springer (2020)

46. Wall, B.M.: Money may make the world go round, but at what cost? https://www.bbc.com/news/

business-31639262 (2015), [Published on 23 March 2015]

47. Wang, P., Xu, H., Jin, X., Wang, T.: Flash: Efﬁcient dynamic routing for offchain networks. In: International Conference on

Emerging Networking Experiments And Technologies. p. 370–381 (2019). https://doi.org/10.1145/3359989.3365411

20

