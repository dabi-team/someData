Noname manuscript No.
(will be inserted by the editor)

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based
on Reﬁnement Types

Yuki Nishida · Hiromasa Saito · Ran Chen ·
Akira Kawata · Jun Furuse · Kohei Suenaga ·
Atsushi Igarashi

the date of receipt and acceptance should be inserted later

Abstract A smart contract is a program executed on a blockchain, based on which
many cryptocurrencies are implemented, and is being used for automating transactions.
Due to the large amount of money that smart contracts deal with, there is a surging
demand for a method that can statically and formally verify them.

This article describes our type-based static veriﬁcation tool HELMHOLTZ for
Michelson, which is a statically typed stack-based language for writing smart contracts
that are executed on the blockchain platform Tezos. HELMHOLTZ is designed on top of
our extension of Michelson’s type system with reﬁnement types. HELMHOLTZ takes a
Michelson program annotated with a user-deﬁned speciﬁcation written in the form of
a reﬁnement type as input; it then typechecks the program against the speciﬁcation
based on the reﬁnement type system, discharging the generated veriﬁcation conditions
with the SMT solver Z3. We brieﬂy introduce our reﬁnement type system for the
core calculus Mini-Michelson of Michelson, which incorporates the characteristic
features such as compound datatypes (e.g., lists and pairs), higher-order functions, and
invocation of another contract. HELMHOLTZ successfully veriﬁes several practical
Michelson programs, including one that transfers money to an account and that checks
a digital signature.

Keywords Smart contract · Blockchain · Formal veriﬁcation · Tools

1 Introduction

A blockchain is a data structure to implement a distributed ledger in a trustless yet
secure way. The idea of blockchains is initially devised for the Bitcoin cryptocur-

Yuki Nishida((cid:66)) · Hiromasa Saito · Ran Chen · Akira Kawata · Kohei Suenaga · Atsushi Igarashi
Kyoto University, Kyoto, Japan
E-mail: {nishida,hsaito,aran,akira,ksuenaga,igarashi}@fos.kuis.kyoto-u.ac.jp

Jun Furuse
DaiLambda, Inc., Kyoto, Japan
E-mail: jun.furuse@dailambda.jp

1
2
0
2

p
e
S
0
1

]
L
P
.
s
c
[

2
v
1
7
9
2
1
.
8
0
1
2
:
v
i
X
r
a

 
 
 
 
 
 
2

Yuki Nishida et al.

rency [12] platform. Many cryptocurrencies are implemented using blockchains, in
which value equivalent to a signiﬁcant amount of money is exchanged.

Recently, many cryptocurrency platforms allow programs to be executed on a
blockchain. Such programs are called smart contracts [19] (or, simply contracts in
this article) since they work as a device to enable automated execution of a contract. In
general, a smart contract is a program Pa associated with an account a on a blockchain.
When the account a receives money from another account b with a parameter v, the
computation deﬁned in Pa is conducted, during which the state of the account a (e.g.,
the balance of the account and values that are stored by the previous invocations of Pa)
which is recorded on the blockchain may be updated. The contract Pa may execute
money transactions to another account (say c), which results in invocations of other
contracts (say Pc) during or after the computation; therefore, contract invocations may
be chained.

Although smart contracts’ original motivation was handling simple transactions
(e.g., money transfer) among the accounts on a blockchain, recent contracts are being
used for more complicated purposes (e.g., establishing a fund involving multiple
accounts). Following this trend, the languages for writing smart contracts also evolve
from those that allow a contract to execute relatively simple transactions (e.g., Script
for Bitcoin) to those that allow a program that is as complex as one written in standard
programming languages (e.g., EVM for Ethereum and Michelson [13] for Tezos [4]).
Due to a large amount of money they deal with, veriﬁcation of smart contracts is
imperative. Static veriﬁcation is especially needed since a smart contract cannot be
ﬁxed once deployed on a blockchain. Attack on a vulnerable contract indeed happened.
For example, the DAO attack, in which the vulnerability of a fundraising contract was
exploited, resulted in the loss of cryptocurrency equivalent to approximately 150M
USD [18].

In this article, we describe our type-based static veriﬁer HELMHOLTZ1 for smart
contracts written in Michelson. The Michelson language is a statically and simply
typed stack-based language equipped with rich data types (e.g., lists, maps, and
higher-order functions) and primitives to manipulate them. Although several high-
level languages that compile to Michelson are being developed, Michelson is most
widely used to write a smart contract for Tezos as of writing.

A Michelson program expresses the above computation in a purely functional style,
in which the Michelson program corresponding to Pa is deﬁned as a function. The
function takes a pair of the parameter v and a value s that represents the current state of
the account (called storage) and returns a pair of a list of operations and the updated
storage s(cid:48). Here, an operation is a Michelson value that expresses the computation
(e.g., transferring money to an account and invoking the contract associated with the
account) that is to be conducted after the current computation (i.e., Pa) terminates.
After the computation speciﬁed by Pa ﬁnishes with a pair of a storage value and an
operation list, a blockchain system invokes the computation speciﬁed in the operation
list. This purely functional style admits static veriﬁcation methods for Michelson
programs similar to those for standard functional languages.

1 Hermann von Helmholtz (1821–1894), a German physicist and physician, was a doctoral advisor of

Albert A. Michelson (1852–1931), whom the Michelson language is apparently named after.

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

3

As the theoretical foundation of HELMHOLTZ, we design a reﬁnement type system
for Michelson as an extension of the original simple type system. In contrast to
standard reﬁnement types that reﬁne the types of values, our type system reﬁnes the
type of stacks.

We show that our tool can verify several practical smart contracts. In addition to
the contracts we wrote ourselves, we apply our tool to the sample Michelson programs
used in Mi-cho-coq [2], a formalization of Michelson in Coq proof assistant [21].
These contracts consist of practical contracts such as one that checks a digital signature
and one that transfers money.

We note that HELMHOLTZ currently supports approximately 80% of the whole
instructions of the Michelson language. Another limitation of the current HELMHOLTZ
is that it can verify only a single contract, although one often uses multiple contracts
for an application, in which a contract may call another by a money transfer operation,
and their behavior as a whole is of interest. We are currently extending HELMHOLTZ
so that it can deal with more programs.

Our contribution is summarized as follows: (1) Deﬁnition of the core calculus
Mini-Michelson and its reﬁnement type system; (2) Automated veriﬁcation tool
HELMHOLTZ for Michelson contracts implemented based on the type system of Mini-
Michelson; the interface to the implementation can be found at https://www.fos.
kuis.kyoto-u.ac.jp/trylang/Helmholtz; and (3) Evaluation of HELMHOLTZ
with various Michelson contracts, including practical ones. A preliminary version of
this article was presented at International Conference on Tools and Algorithms for
the Construction and Analysis of Systems (TACAS) in 2021. We have given detailed
proofs of properties of Mini-Michelson and a more detailed description about the
veriﬁer implementation, in addition to revision of the text.

The rest of this article is organized as follows. Before introducing the technical
details, we present an overview of the veriﬁer HELMHOLTZ in Section 2 using a
simple example of a Michelson contract. Section 3 introduces the core calculus Mini-
Michelson with its reﬁnement type system and states soundness of the reﬁnement
type system. (Detailed proofs are deferred to Appendix A.) We also discuss a few
extensions implemented in the veriﬁer. Section 4 describes the veriﬁer HELMHOLTZ,
a case study, and experimental results. After discussing related work in Section 5, we
conclude in Section 6.

2 Overview of HELMHOLTZ and Michelson

We give an overview of our tool HELMHOLTZ in this section before presenting its
technical details. We also explain Michelson by example (Section 2.2) and user-written
annotation added to a Michelson program for veriﬁcation purposes (Section 2.3).

2.1 HELMHOLTZ

As input, HELMHOLTZ takes a Michelson program annotated with (1) its speciﬁcation
expressed in a reﬁnement type and (2) additional user annotations such as loop

4

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29

Yuki Nishida et al.

parameter unit ;
storage unit ;
<< ContractAnnot { ( param , st ) | True } ->

{ ( ops , st ’) | amount = 0 && ops = [] ||

amount <> 0 && ( match contract_opt source with

| Some c -> ops = [ Transfer Unit amount c ]
| None -> False ) }

& { _ | False } >>

code

{ CDR ;

NIL operation ;
AMOUNT ;
PUSH mutez 0;
IFCMPEQ

{}
{

/* ( param , st ) */
/* st */
/* [] (cid:46) st */
/* amount (cid:46) [] (cid:46) st */
/* 0 (cid:46) amount (cid:46) [] (cid:46) st */

( amount ≤ 0) */
( amount > 0) */

/* [] (cid:46) st
/* [] (cid:46) st
/* src (cid:46) [] (cid:46) st */
/* Some ( Contract src ) (cid:46) [] (cid:46) st */
/* ( Contract src ) (cid:46) [] (cid:46) st */

SOURCE ;
CONTRACT unit ;
ASSERT_SOME ;
AMOUNT ; UNIT ;
/* Unit (cid:46) amount (cid:46) ( Contract src ) (cid:46) [] (cid:46) st */
TRANSFER_TOKENS ;
/* ( Transfer Unit amount ( Contract src )) (cid:46) [] (cid:46) st */
CONS
/* [ Transfer Unit amount ( Contract src )] (cid:46) st */

};
/* ops (cid:46) st, where ops is the top element at the end of each branch, namely,

[Transfer Unit amount (Contract src)] if amount > 0; or [] otherwise */

PAIR }

/* ( ops , st ) */

Fig. 1 boomerang.tz. The comment inside /* */ describes the stack at the program point.

invariants. It typechecks the annotated program against the speciﬁcation using our
reﬁnement type system; the veriﬁcation conditions generated during the typechecking
is discharged by the SMT solver Z3 [11]. If the code successfully typechecks, then the
program is guaranteed to satisfy the speciﬁcation.

HELMHOLTZ is implemented as a subcommand of tezos-client, the client
program of the Tezos blockchain. For example, to verify boomerang.tz in Figure 1,
we run tezos-client refinement boomerang.tz. If the veriﬁcation succeeds,
the command outputs VERIFIED to the terminal screen (with a few log messages);
otherwise, it outputs UNVERIFIED.

2.2 An Example Contract in Michelson

Figure 1 shows an example of a Michelson program called boomerang. A Michelson
program is associated with an account on the Tezos blockchain; the program is invoked
by transferring money to this account. This artiﬁcial program in Figure 1, when it is
invoked, is supposed to transfer the received money back to the account that initiated
the transaction.

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

5

A Michelson program starts with type declarations of its parameter, whose value
is given by contract invocation, and storage, which is the state that the contract
account stores. Lines 1–2 declare that the types of both are unit, the type inhabited by
the only value Unit. Lines 3–8 surrounded by << and >> are a user-written annotation
used by HELMHOLTZ for veriﬁcation; we will explain this annotation later. The code
section in Lines 10–29 is the body of this program.

Let us take a look at the code section of the program. In the following explana-
tion of each instruction, we describe the state of the stack after each instruction as
comments; stack elements are delimited by (cid:46).

– Execution of a Michelson program starts with a stack with one value, which is a

pair (param, st) of a parameter param and a storage value storage.

– CDR pops the pair at the top of the stack and pushes the second value of the popped
pair; thus, after executing the instruction, the stack contains the single value st.
– NIL pushes the empty list [] to the stack; the instruction is accompanied by the

type operation of the list elements for typechecking purposes.

– AMOUNT pushes the nonnegative amount of the money sent to the account to which

this program is associated.

– PUSH mutez 0 pushes the value 0. The type mutez represents a unit of money

used in Tezos.

– IFCMPEQ b1 b2, if the state of the stack before executing the instruction is v1
(cid:46) v2 (cid:46) tl, (1) pops v1 and v2 and (2) executes the then-branch b1 (resp., the
else-branch b2) if v2 = v1 (resp., v2 (cid:54)= v1). In boomerang, this instruction does
nothing if amount = 0; otherwise, the instructions in the else-branch are executed.
– SOURCE at the beginning of the else-branch pushes the address src of the source
account, which initiated the chain of contract invocations that the current contract
belongs to, resulting in the stack src (cid:46) [] (cid:46) st.

– CONTRACT T pops an address addr from the stack and typechecks whether the
contract associated with addr takes an argument of type T . If the typechecking
succeeds, then Some (Contract addr) is pushed; otherwise, None is pushed.
The constructor Contract creates an object that represents a typechecked contract
at the given address. In Tezos, the source account is always a contract that takes the
value Unit as a parameter; thus, Some (Contract src) will always be pushed
onto the stack.

– ASSERT_SOME pops a value v from the stack and pushes v’ if v is Some v’;

otherwise, it raises an exception.

– UNIT pushes the unit value Unit to the stack.
– TRANSFER_TOKENS, if the stack is of the shape varg (cid:46) vamt (cid:46) vcontr (cid:46) tl, pops
varg, vamt, and vcontr from the stack and pushes (Transfer varg vamt
vcontr) onto tl. The value Transfer varg vamt vcontr is an operation
object expressing that money (of amount vamt) shall be sent to the account vcontr
with the argument varg after this program ﬁnishes without raising an exception.
Therefore, the program associated with vcontr is invoked after this program
ﬁnishes. Otherwise, an operation object is an opaque tuple and no instruction can
extract its elements.

6

Yuki Nishida et al.

– CONS with the stack v1 (cid:46) v2 (cid:46) tl pops v1 and v2, and pushes a cons list v1::v2

onto the stack. (We use the list notation in OCaml here.)

– After executing one of the branches associated with IFCMPEQ in this program,
the shape of the stack should be ops (cid:46) storage, where ops is [] if amount = 0
or [Transfer varg vamt vcontr] if amount > 0. The instruction PAIR pops
ops and storage, and pushes (ops,storage).

A Michelson program is supposed to ﬁnish its execution with a singleton stack whose
unique element is a pair of (1) a list of operations to be executed after the current
execution of the contract ﬁnishes and (2) the new value for the storage.

Michelson is a statically typed language. Each instruction is associated with a
typing rule that speciﬁes the shapes of stacks before and after it by a sequence of
simple types such as int and int list. For example, CONS requires the type of top
element to be T and that of the second to be T list (for any T ); it ensures the top
element after it has type T list.

Other notable features of Michelson include ﬁrst-class functions, hashing, instruc-
tions related to cryptography such as signature veriﬁcation, and manipulation of a
blockchain using operations.

2.3 Speciﬁcation

A user can specify the behavior of a program by a ContractAnnot annotation,
which is a part of the augmented syntax of our veriﬁcation tool. A ContractAnnot
annotation gives a speciﬁcation of a Michelson program by the following notation
inspired by the reﬁnement types: {(param,st) | pre} -> {(ops,st’) | post}
& {exc | abpost} where pre, post, and abpost are predicates. This speciﬁcation
reads as follows: if this program is invoked with a parameter param and storage st
that satisﬁes the property pre, then (1) if the execution of this program succeeds,
then it returns a list of operations ops and new storage storage’ that satisfy the
property post; (2) if this program raises an exception with value exc, then exc
satisﬁes abpost. The speciﬁcation language, which is ML-like, is expressive enough
to cover the speciﬁcations for practical contracts, including the ones we used in the
experiments in Section 4.5. In the predicates, one can use several keywords such as
amount for the amount of the money sent to this program when it is invoked and
source for the source account’s address.

The ContractAnnot annotation in Figure 1 (Lines 3–8) formalizes this program’s
speciﬁcation as follows. This program can take any parameter and storage (Line 3).
Successful execution of this program results in a pair (ops,st’) that satisﬁes the
condition in Lines 4–7 that expresses (1) if amount = 0, then ops is empty, that is,
no operation will be issued; (2) if amount > 0, then ops is a list of a single element
Transfer Unit amount c, where c is bound for Contract source2, which ex-
presses transfer of money of the amount amount to the account at source with the unit

2 It

is one axiom of our domain speciﬁc theory that contract_opt source always return

Some (Contract source).

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

7

V ::= i | a | Transfer(V, i, a) | (V1,V2) | [] | V1 :: V2 | (cid:104)IS(cid:105)
T ::= int | address | operation | T1 × T2 | T list | T1 → T2
IS ::= {} | {I; IS}
I ::= IS | DIP IS | DROP | DUP | SWAP | PUSH T V | NOT | ADD | IF IS1 IS2 | LOOP IS |
| ITER IS | LAMBDA T1 T2 IS |

PAIR | CAR | CDR | NIL T | CONS | IF_CONS IS1 IS2
EXEC | TRANSFER_TOKENS T

S ::= ‡ | V (cid:46) S
¯T ::= ‡ | T (cid:46) ¯T
ϒ ::= ‡ | x:T (cid:46)ϒ

Fig. 2 Syntax of Mini-Michelson.

argument.3 In the speciﬁcation language, source and amount are keywords that stand
for the source account and the amount of money sent to this program, respectively.
The part & { _ | False } expresses that this program does not raise an exception.
This speciﬁcation correctly formalizes the intended behavior of this program.

3 Reﬁnement Type System for Mini-Michelson

In this section, we formalize Mini-Michelson, a core subset of Michelson with its
syntax, operational semantics, and reﬁnement type system. We omit many features
from the full language in favor of conciseness but includes language constructs—such
as higher-order functions and iterations—that make veriﬁcation difﬁcult.

3.1 Syntax

Figure 2 shows the syntax of Mini-Michelson. Values, ranged over by V , consist of
integers i; addresses a; operation objects Transfer(V, i, a) to invoke a contract at a by
sending money of amount i and an argument V ; pairs (V1,V2) of values; the empty list
[]; cons V1 :: V2; and code (cid:104)IS(cid:105) of ﬁrst-class functions.4 Unlike Michelson, which has
primitive Boolean literals True and False, we use integers as a substitute for Boolean
values so that 0 means False and the others mean True. As we have mentioned, there
is no instruction to extract elements from an operation object but the elements can be
referenced in reﬁnement types to state what kind of operation object is constructed by
a smart contract. Simple types, ranged over by T , consist of base types (int, address,
and operation, which are self-explanatory), pair types T1 × T2, list types T list, and
function types T1 → T2. Instruction sequences, ranged over by IS, are a sequence of
instructions, ranged over by I, enclosed by curly braces. A Mini-Michelson program
is an instruction sequence.

Instructions include those for operand stack manipulation (to DROP, DUPlicate,
SWAP, and PUSH values); NOT and ADD for manipulating integers; PAIR, CAR, and CDR

3 As we mentioned in Section 1, HELMHOLTZ can currently verify the behavior of a single contract,
although there will be an invocation of the contract associated with source after the termination of
boomerang. An operation is treated as an opaque data structure, from which one cannot extract values.

4 Closures are not needed because functions in Michelson can access only arguments.

8

Yuki Nishida et al.

for pairs; NIL and CONS for constructing lists; LAMBDA for a ﬁrst-class function; EXEC
for calling a function; and TRANSFER_TOKENS to create an operation. Instructions for
control structures are IF and IF_CONS, which are for branching on integers (whether
the stack top is True or not) and lists (whether the stack top is a cons or not), respec-
tively, and LOOP and ITER, which are for iteration on integers and lists, respectively.
LAMBDA pushes a function (described by its operand IS) onto the stack and EXEC calls a
function. Perhaps unfamiliar is DIP IS, which pops and saves the stack top somewhere
else, execute IS, and then push back the saved value.

We also use a few kinds of stacks in the following deﬁnitions: operand stacks,
ranged over by S, type stacks, ranged over by ¯T , and type binding stacks, ranged over
by ϒ . The empty stack is denoted by ‡ and push is by (cid:46). We often omit the empty stack
and write, for example, V1 (cid:46)V2 for V1 (cid:46)V2 (cid:46) ‡. Intuitively, T1 (cid:46) .. (cid:46) Tn and x1:T1 (cid:46) .. (cid:46) xn:
Tn describe stacks V1 (cid:46) .. (cid:46)Vn where each value Vi is of type Ti. We will use variables
to name stack elements in the reﬁnement type system.

We summarize main differences from Michelson proper:

– Michelson has the notion of type attributes, which classify types, according to
which generic operations such as PUSH can be applied. For example, values of
pushable types can be put on the stack by PUSH. Since type operation is not
pushable, an instruction such as PUSH operation Transfer(V, i, a) is not valid
in Michelson—all operations have to be created by designated instructions. We
ignore type attributes for simplicity here, but the implementation of HELMHOLTZ,
which calls the typechecker of Michelson, does not.

– As we saw in Section 2, an operation is created from an address in two steps via a
contract value. Since we model only one kind of operations, i.e., Transfer(V, i, a),
we simplify the process to let instruction TRANSFER_TOKENS directly creates an
operation from an address in one step. We also omit the typecheck of the contract
associated with an address.

– In Michelson, each execution of a smart contract is assigned a gas to control how

long the contract can run to prevent contracts from running too long.

– We do not formally model exceptions for simplicity and, thus, the reﬁnement type
system do not (have to) capture exceptional behavior. Our veriﬁer, however, does
handle exceptions; we will informally discuss how we extend the type system with
exceptions in Section 3.6.

3.2 Operational Semantics

Figure 3 deﬁnes the operational semantics of Mini-Michelson. A judgment of the
form S (cid:96) I ⇓ S(cid:48) (or S (cid:96) IS ⇓ S(cid:48), resp.) means that evaluating the instruction I (or the
instruction sequence IS, resp.) under the stack S results in the stack S(cid:48). Although the
deﬁning rules are straightforward, we will make a few remarks about them.

The rule (E-DIP) means that DIP IS pops and saves the stack top somewhere else,
execute IS, and then push back the saved value, as explained above. This instruction
implicitly gives Mini-Michelson (and Michelson) a secondary stack. (E-PUSH) means
that PUSH T V does not check if the pushed value is well formed at run time: the check
is the job of the simple type system, discussed soon.

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

9

Evaluation for Instruction Sequence S (cid:96) IS ⇓ S

S (cid:96) {} ⇓ S

(E-NOP)

S (cid:96) I ⇓ S(cid:48)

S(cid:48) (cid:96) IS ⇓ S(cid:48)(cid:48)

S (cid:96) {I; IS} ⇓ S(cid:48)(cid:48)

(E-SEQ)

Evaluation for Instruction S (cid:96) I ⇓ S

S (cid:96) IS ⇓ S(cid:48)
V (cid:46) S (cid:96) DIP IS ⇓ V (cid:46) S(cid:48)

(E-DIP)

V (cid:46) S (cid:96) DROP ⇓ S

(E-DROP)

V (cid:46) S (cid:96) DUP ⇓ V (cid:46)V (cid:46) S

(E-DUP)

V1 (cid:46)V2 (cid:46) S (cid:96) SWAP ⇓ V2 (cid:46)V1 (cid:46) S

(E-SWAP)

S (cid:96) PUSH T V ⇓ V (cid:46) S

(E-PUSH)

(i (cid:54)= 0)
i (cid:46) S (cid:96) NOT ⇓ 0 (cid:46) S

(E-NOTT)

0 (cid:46) S (cid:96) NOT ⇓ 1 (cid:46) S

(E-NOTF)

(i1 + i2 = i3)
i1 (cid:46) i2 (cid:46) S (cid:96) ADD ⇓ i3 (cid:46) S

(E-ADD)

V1 (cid:46)V2 (cid:46) S (cid:96) PAIR ⇓ (V1,V2) (cid:46) S

(V1,V2) (cid:46) S (cid:96) CDR ⇓ V2 (cid:46) S

(E-PAIR)

(E-CDR)

V1 (cid:46)V2 (cid:46) S (cid:96) CONS ⇓ V1 :: V2 (cid:46) S

(E-CONS)

(V1,V2) (cid:46) S (cid:96) CAR ⇓ V1 (cid:46) S

(E-CAR)

S (cid:96) NIL T ⇓ [] (cid:46) S

(E-NIL)

S (cid:96) IS1 ⇓ S(cid:48)
(i (cid:54)= 0)
i (cid:46) S (cid:96) IF IS1 IS2 ⇓ S(cid:48)

(E-IFT)

S (cid:96) IS2 ⇓ S(cid:48)
0 (cid:46) S (cid:96) IF IS1 IS2 ⇓ S(cid:48)

(E-IFF)

(i (cid:54)= 0)

S (cid:96) IS ⇓ S(cid:48)
i (cid:46) S (cid:96) LOOP IS ⇓ S(cid:48)(cid:48)

S(cid:48) (cid:96) LOOP IS ⇓ S(cid:48)(cid:48)

(E-LOOPT)

0 (cid:46) S (cid:96) LOOP IS ⇓ S

(E-LOOPF)

V1 (cid:46)V2 (cid:46) S (cid:96) IS1 ⇓ S(cid:48)
V1 :: V2 (cid:46) S (cid:96) IF_CONS IS1 IS2 ⇓ S(cid:48)

(E-IFCONST)

S (cid:96) IS2 ⇓ S(cid:48)
[] (cid:46) S (cid:96) IF_CONS IS1 IS2 ⇓ S(cid:48)

(E-IFCONSF)

[] (cid:46) S (cid:96) ITER IS ⇓ S

(E-ITERNIL)

V1 (cid:46) S (cid:96) IS ⇓ S(cid:48)

V2 (cid:46) S(cid:48) (cid:96) ITER IS ⇓ S(cid:48)(cid:48)

V1 :: V2 (cid:46) S (cid:96) ITER IS ⇓ S(cid:48)(cid:48)

(E-ITERCONS)

S (cid:96) LAMBDA T1 T2 IS ⇓ (cid:104)IS(cid:105) (cid:46) S

(E-LAMBDA)

V (cid:46) ‡ (cid:96) IS ⇓ V (cid:48) (cid:46) ‡
V (cid:46) (cid:104)IS(cid:105) (cid:46) S (cid:96) EXEC ⇓ V (cid:48) (cid:46) S

(E-EXEC)

V (cid:46) i (cid:46) a (cid:46) S (cid:96) TRANSFER_TOKENS T ⇓ Transfer(V, i, a) (cid:46) S

(E-TRANSFERTOKENS)

Fig. 3 Operational Semantics of Mini-Michelson

The rules (E-IFT) and (E-IFF) deﬁne the behavior of the branching instruction
IF IS1 IS2, which executes IS1 or IS2, depending on the top of the operand stack. As
we have mentioned, nonzero integers mean True. Thus, (E-IFT) is used for the case
in which IS1 is executed, and otherwise, (E-IFF) is used. There is another branching
instruction IF_CONS IS1 IS2, which executes either instruction sequence depending

10

Yuki Nishida et al.

on whether the list at the top of the stack is empty or not (cf. (E-IFCONST) and
(E-IFCONSF)).

The rules (E-LOOPT) and (E-LOOPF) deﬁne the behavior of the looping in-
struction LOOP IS. This instruction executes IS repeatedly until the top of the stack
becomes false. (E-LOOPT) means that, if the condition is True, IS is executed, and
then LOOP IS is executed again. (E-LOOPF) means that, if the condition is false, the
loop is ﬁnished after dropping the stack top. A similar looping instruction is ITER IS,
which iterates over a list (see (E-ITERNIL) and (E-ITERCONS)).

The rule (E-LAMBDA) means that LAMBDA T1 T2 IS pushes the instruction sequence
to the stack and (E-EXEC) means that EXEC pops the instruction sequence (cid:104)IS(cid:105) and
the stack top V , saves the rest of the stack S elsewhere, runs IS with V as the sole value
in the stack, pushes the result V (cid:48) back to the restored stack S.

The rule (E-TRANSFERTOKENS) means that TRANSFER_TOKENS T creates an
operation object and pushes onto the stack. (As we have discussed, we omit a run-time
check to see if T is really the argument type of the contract that the address a stores.)

3.3 Simple Type System

Mini-Michelson (as well as Michelson) is equipped with a simple type system. The
type judgment for instructions is written ¯T (cid:96) I ⇒ ¯T (cid:48), which means that instruction
I transforms a stack of type ¯T into another stack of type ¯T (cid:48). The type judgment for
values is written V : T , which means that V is given simple type T . The typing rules,
which are shown in Figure 4, are fairly straightforward. Note that these two judgment
forms depend on each other—see (RTV-FUN) and (T-PUSH).

3.4 Reﬁnement Type System

Now we extend the simple type system to a reﬁnement type system. In the reﬁnement
type system, a simple stack type T1 (cid:46) .. (cid:46) Tn is augmented with a formula ϕ in an
assertion language to describe the relationship among stack elements. More concretely,
we introduce reﬁnement stack types, ranged over by Φ, of the form {x1:T1 (cid:46) ... (cid:46) xn:
Tn | ϕ(x1, ... , xn)}, which denotes a stack V1 (cid:46) .. (cid:46) Vn such that Vn : T1, . . . , Vn : Tn
and ϕ(V1, ... ,Vn) hold, and reﬁne the type judgment form, accordingly. We start
with an assertion language, which is many-sorted ﬁrst-order logic and proceed to the
reﬁnement type system.

3.4.1 Assertion Language

The assertion language is many-sorted ﬁrst-order logic, where sorts are simple types.
We show the syntax of terms, ranged over by t, and formulae, ranged over by ϕ,
in Figure 5. As usual, x is bound in ∃ x:T.ϕ. Most of them are straightforward but
the formulae of the form call(t1,t2) = t3 deserves an explanation. It means that, if
instruction sequence denoted by t1 is called with (a singleton stack that stores) a value
denoted by t2 (and terminates), it yields the value denoted by t3. The term constructor

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

11

Value Typing V : T

(RTV-INT)

i : int

a : address

(RTV-ADDRESS)

V : T
Transfer(V, i, a) : operation

(RTV-OPERATION)

V1 : T1
(V1,V2) : T1 × T2

V2 : T2 (RTV-PAIR)

[] : T list

(RTV-NIL)

V1 : T

V2 : T list

V1 :: V2 : T list

(RTV-CONS)

T1 (cid:46) ‡ (cid:96) IS ⇒ T2 (cid:46) ‡
(cid:104)IS(cid:105) : T1 → T2

(RTV-FUN)

Instruction Sequence Typing ¯T (cid:96) IS ⇒ ¯T (cid:48)

¯T (cid:96) {} ⇒ ¯T

(T-NOP)

Instruction Typing ¯T (cid:96) I ⇒ ¯T (cid:48)

¯T1 (cid:96) IS ⇒ ¯T2
T (cid:46) ¯T1 (cid:96) DIP IS ⇒ T (cid:46) ¯T2

(T-DIP)

¯T1 (cid:96) I ⇒ ¯T2

¯T2 (cid:96) IS ⇒ ¯T3 (T-SEQ)

¯T1 (cid:96) {I; IS} ⇒ ¯T3

T (cid:46) ¯T (cid:96) DROP ⇒ ¯T

(T-DROP)

T (cid:46) ¯T (cid:96) DUP ⇒ T (cid:46) T (cid:46) ¯T

(T-DUP)

T1 (cid:46) T2 (cid:46) ¯T (cid:96) SWAP ⇒ T2 (cid:46) T1 (cid:46) ¯T

(T-SWAP)

V : T
¯T (cid:96) PUSH T V ⇒ T (cid:46) ¯T

(T-PUSH)

int (cid:46) ¯T (cid:96) NOT ⇒ int (cid:46) ¯T

(T-NOT)

int (cid:46) int (cid:46) ¯T (cid:96) ADD ⇒ int (cid:46) ¯T

(T-ADD)

T1 (cid:46) T2 (cid:46) ¯T (cid:96) PAIR ⇒ T1 × T2 (cid:46) ¯T

(T-PAIR)

T1 × T2 (cid:46) ¯T (cid:96) CAR ⇒ T1 (cid:46) ¯T

(T-CAR)

T1 × T2 (cid:46) ¯T (cid:96) CDR ⇒ T2 (cid:46) ¯T

(T-CDR)

¯T (cid:96) NIL T ⇒ T list (cid:46) ¯T

(T-NIL)

T (cid:46) T list (cid:46) ¯T (cid:96) CONS ⇒ T list (cid:46) ¯T

(T-CONS)

¯T (cid:96) IS1 ⇒ ¯T (cid:48)

¯T (cid:96) IS2 ⇒ ¯T (cid:48)

int (cid:46) ¯T (cid:96) IF IS1 IS2 ⇒ ¯T (cid:48)

(T-IF)

¯T (cid:96) IS ⇒ int (cid:46) ¯T
int (cid:46) ¯T (cid:96) LOOP IS ⇒ ¯T

(T-LOOP)

T (cid:46) T list (cid:46) ¯T (cid:96) IS1 ⇒ ¯T (cid:48)

¯T (cid:96) IS2 ⇒ ¯T (cid:48)

T list (cid:46) ¯T (cid:96) IF_CONS IS1 IS2 ⇒ ¯T (cid:48)

(T-IFCONS)

T (cid:46) ¯T (cid:96) IS ⇒ ¯T
T list (cid:46) ¯T (cid:96) ITER IS ⇒ ¯T

(T-ITER)

T1 (cid:46) ‡ (cid:96) IS ⇒ T2 (cid:46) ‡
¯T (cid:96) LAMBDA T1 T2 IS ⇒ T1 → T2 (cid:46) ¯T

(T-LAMBDA)

T1 (cid:46) T1 → T2 (cid:46) ¯T (cid:96) EXEC ⇒ T2 (cid:46) ¯T

(T-EXEC)

T (cid:46) int (cid:46) address (cid:46) ¯T (cid:96) TRANSFER_TOKENS T ⇒ operation (cid:46) ¯T

(T-TRANSFERTOKENS)

Fig. 4 Simple typing

12

Yuki Nishida et al.

t
::= x | V | Transfer(t1,t2,t3) | (t1,t2) | (t1 :: t2) | t1 + t2
ϕ ::= (cid:62) | t1 = t2 | call(t1,t2) = t3 | ¬ ϕ | ϕ1 ∨ ϕ2 | ∃ x:T.ϕ
Γ ::= empty | Γ , x:T

Fig. 5 Syntax of Assertion Language

Well-Sorted Terms Γ (cid:96) t : T

x:T ∈ Γ
Γ (cid:96) x : T

(WT-VAR)

V : T
Γ (cid:96) V : T

(WT-VAL)

Γ (cid:96) t1 : int

Γ (cid:96) t2 : int

Γ (cid:96) t1 + t2 : int

(WT-PLUS)

Γ (cid:96) t1 : T

Γ (cid:96) t2 : int

Γ (cid:96) t3 : address

Γ (cid:96) Transfer(t1,t2,t3) : operation

(WT-TRANSACTION)

Γ (cid:96) t1 : T1

Γ (cid:96) t2 : T2 (WT-PAIR)

Γ (cid:96) (t1,t2) : T1 × T2

Γ (cid:96) t1 : T

Γ (cid:96) t2 : T list

Γ (cid:96) t1 :: t2 : T list

(WT-CONS)

Well-Sorted Formulae Γ (cid:96) ϕ : ∗

Γ (cid:96) (cid:62) : ∗

(WF-TRUE)

Γ (cid:96) t1 : T

Γ (cid:96) t2 : T

Γ (cid:96) t1 = t2 : ∗

(WF-EQUAL)

Γ (cid:96) t1 : T1 → T2

Γ (cid:96) t2 : T1

Γ (cid:96) call(t1,t2) = t3 : ∗

Γ (cid:96) t3 : T2 (WF-CALL)

Γ (cid:96) ϕ : ∗
Γ (cid:96) ¬ ϕ : ∗

(WF-NOT)

Γ (cid:96) ϕ1 : ∗

Γ (cid:96) ϕ2 : ∗

Γ (cid:96) ϕ1 ∨ ϕ2 : ∗

(WF-OR)

Γ , x:T (cid:96) ϕ : ∗
Γ (cid:96) ∃ x:T.ϕ : ∗

(WF-EXISTS)

Fig. 6 Well-Sorted Terms and Formulae.

Transfer(t1,t2,t3) allows us to refer to the elements in an operation object, which
is opaque. Conjunction ϕ1 ∧ ϕ, implication ϕ1 =⇒ ϕ2, and universal quantiﬁcation
∀ x:T.ϕ are deﬁned as abbreviations as usual. We use several common abbreviations
such as t1 (cid:54)= t2 for ¬ (t1 = t2), ∃ x1:T1, .. , xn:Tn.ϕ for ∃x1:T1. . . . ∃xn:Tn.ϕ, etc. A typing
environment, ranged over by Γ , is a sequence of type binding. We assume all variables
in Γ are distinct. We abuse a comma to concatenate typing environments, e.g., Γ1,Γ2.
We also use a type binding stack ϒ as a typing environment, explicitly denoted by (cid:98)ϒ ,
which is deﬁned as (cid:98)‡ = empty and (cid:92)x:T (cid:46)ϒ = x:T, (cid:98)ϒ .

Well-sorted terms and formulae are deﬁned by the judgments Γ (cid:96) t : T and Γ (cid:96)
ϕ : ∗, respectively. The former means that the term t is a well-sorted term of the sort T
under the typing environment Γ and the latter that the formula ϕ is well-sorted under
the typing environment Γ , respectively. The derivation rules for each judgment, shown
in Figure 6, are straightforward. Note that well-sortedness depends on the simple type
system via (WT-VAL).

Let a value assignment σ be a mapping from variables to values. We write σ [x (cid:55)→
V ] to denote the value assignment which maps x to V and otherwise is identical to
σ . As we are interested in well-sorted formulae, we consider a value assignment that
respects a typing environment, as follows.

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

13

Deﬁnition 1. A value assignment σ is typed under a typing environment Γ , denoted
by σ : Γ , iff σ (x) : T for every x:T ∈ Γ .

Now we deﬁne the semantics of the well-sorted terms and formulae in a standard

manner as follows.

Deﬁnition 2 (Semantics of terms). For a typed value assignment σ : Γ . The semantics
[[t]]σ :Γ of term t under typed value assignment σ : Γ is deﬁned as follows:

[[x]]σ :Γ = σ (x)

[[V ]]σ :Γ = V

[[Transfer(t1,t2,t3)]]σ :Γ = Transfer([[t1]]σ :Γ , [[t2]]σ :Γ , [[t3]]σ :Γ )

[[(t1,t2)]]σ :Γ = ([[t1]]σ :Γ , [[t2]]σ :Γ )
[[t1 :: t2]]σ :Γ = [[t1]]σ :Γ :: [[t2]]σ :Γ
[[t1 + t2]]σ :Γ = [[t1]]σ :Γ + [[t2]]σ :Γ .

Deﬁnition 3 (Semantics of formulae). For a typed value assignment σ : Γ , a valid
well-sorted formula ϕ under Γ is denoted by σ : Γ |= ϕ and deﬁned as follows.

– σ : Γ |= (cid:62).
– σ : Γ |= t1 = t2 iff [[t1]]σ :Γ = [[t2]]σ :Γ .
– σ : Γ |= call(t1,t2) = t3 iff [[t1]]σ :Γ = (cid:104)IS(cid:105) and [[t2]]σ :Γ (cid:46) ‡ (cid:96) IS ⇓ [[t3]]σ :Γ (cid:46) ‡.
– σ : Γ |= ¬ ϕ iff σ : Γ (cid:54)|= ϕ.
– σ : Γ |= ϕ1 ∨ ϕ2 iff σ : Γ |= ϕ1 or σ : Γ |= ϕ2.
– σ : Γ |= ∃ x:T.ϕ iff σ [x (cid:55)→ V ] : Γ , x:T |= ϕ for some V .

We write Γ |= ϕ iff σ : Γ |= ϕ for any σ .

3.4.2 Typing Rules

The type system is deﬁned by subtyping and typing: a subtyping judgment is of the
form Γ (cid:96) Φ1 <: Φ2, which means stack type Φ1 is a subtype of Φ2 under Γ , and a type
judgment for instructions (resp. instruction sequences) is of the form Γ (cid:96) Φ1 I Φ2 (resp.
Γ (cid:96) Φ1 IS Φ2), which means that if I (resp. IS) is executed under a stack satisfying
Φ1, the resulting stack (if terminates) satisﬁes Φ2. We often call Φ1 pre-condition and
Φ2 post-condition, following the terminology of Hoare logic. Note that the scopes
of variables declared in Γ include Φ1 and Φ2 but those bound in Φ1 do not include
Φ2. To express the relationship between the initial and ﬁnal stacks, we use the type
environment Γ . In writing down concrete speciﬁcations, it is sometimes convenient
to allow the scopes of variables bound in Φ1 to include Φ2, but we ﬁnd that it would
clutter the presentation of typing rules.

In our type system, subtyping is deﬁned semantically as follows.

Deﬁnition 4 (Subtyping relation). A reﬁnement stack type {ϒ | ϕ1} is called subtype
of a reﬁnement stack type {ϒ | ϕ2} under a typing environment Γ , denoted by Γ (cid:96)
{ϒ | ϕ1} <: {ϒ | ϕ2}, iff Γ , (cid:98)ϒ |= ϕ1 =⇒ ϕ2.

We show the typing rules in Figure 7 and Figure 8. It is easy to observe that the
type binding stack parts in the pre- and post-conditions follows the simple type system.
We will focus on predicate parts below.

14

Yuki Nishida et al.

Reﬁnement Instruction Sequence Typing Γ (cid:96) Φ1 IS Φ2

Γ (cid:96) Φ {} Φ

(RT-NOP)

Γ (cid:96) Φ I Φ (cid:48)

Γ (cid:96) Φ (cid:48) IS Φ (cid:48)(cid:48)

Γ (cid:96) Φ {I; IS} Φ (cid:48)(cid:48)

(RT-SEQ)

Reﬁnement Instruction Sequence Typing Γ (cid:96) Φ1 IS Φ2

Γ , x:T (cid:96) {ϒ | ϕ} IS {ϒ (cid:48) | ϕ (cid:48)}
Γ (cid:96) {x:T (cid:46)ϒ | ϕ} DIP IS {x:T (cid:46)ϒ (cid:48) | ϕ (cid:48)}

(RT-DIP)

Γ (cid:96) {x:T (cid:46)ϒ | ϕ} DROP {ϒ | ∃ x:T.ϕ}

(RT-DROP)

(x(cid:48) /∈ dom(Γ , (cid:92)x:T (cid:46)ϒ ))
Γ (cid:96) {x:T (cid:46)ϒ | ϕ} DUP {x(cid:48):T (cid:46) x:T (cid:46)ϒ | ϕ ∧ x(cid:48) = x}

(RT-DUP)

Γ (cid:96) {x1:T1 (cid:46) x2:T2 (cid:46)ϒ | ϕ} SWAP {x2:T2 (cid:46) x1:T1 (cid:46)ϒ | ϕ}

(RT-SWAP)

(x /∈ dom(Γ , (cid:98)ϒ ))

V : T

Γ (cid:96) {ϒ | ϕ} PUSH T V {x:T (cid:46)ϒ | ϕ ∧ x = V }

(RT-PUSH)

(x(cid:48) /∈ dom(Γ , (cid:92)x:int (cid:46)ϒ ))
Γ (cid:96) {x:int (cid:46)ϒ | ϕ} NOT {x(cid:48):int (cid:46)ϒ | ∃ x:int.ϕ ∧ (x (cid:54)= 0 ∧ x(cid:48) = 0 ∨ x = 0 ∧ x(cid:48) = 1)}

(RT-NOT)

(x3 /∈ dom(Γ , (cid:92)x1:int (cid:46) x2:int (cid:46)ϒ ))
Γ (cid:96) {x1:int (cid:46) x2:int (cid:46)ϒ | ϕ} ADD {x3:int (cid:46)ϒ | ∃ x1:int, x2:int.ϕ ∧ x1 + x2 = x3}

(RT-ADD)

(x3 /∈ dom(Γ , (cid:92)x1:T1 (cid:46) x2:T2 (cid:46)ϒ ))
Γ (cid:96) {x1:T1 (cid:46) x2:T2 (cid:46)ϒ | ϕ} PAIR {x3:T1 × T2 (cid:46)ϒ | ∃ x1:T1, x2:T2.ϕ ∧ (x1, x2) = x3}

(RT-PAIR)

(x2 /∈ dom(Γ , (cid:92)x:T1 × T2 (cid:46)ϒ ))
(x1 (cid:54)= x2)
Γ (cid:96) {x:T1 × T2 (cid:46)ϒ | ϕ} CAR {x1:T1 (cid:46)ϒ | ∃ x:T1 × T2, x2:T2.ϕ ∧ x = (x1, x2)}

(x1 /∈ dom(Γ , (cid:92)x:T1 × T2 (cid:46)ϒ ))

(RT-CAR)

(x2 /∈ dom(Γ , (cid:92)x:T1 × T2 (cid:46)ϒ ))
(x1 (cid:54)= x2)
Γ (cid:96) {x:T1 × T2 (cid:46)ϒ | ϕ} CDR {x2:T2 (cid:46)ϒ | ∃ x:T1 × T2, x1:T1.ϕ ∧ x = (x1, x2)}

(x1 /∈ dom(Γ , (cid:92)x:T1 × T2 (cid:46)ϒ ))

(RT-CDR)

(x /∈ dom(Γ , (cid:98)ϒ ))
Γ (cid:96) {ϒ | ϕ} NIL T {x:T list (cid:46)ϒ | ϕ ∧ x = []}

(RT-NIL)

(x3 /∈ dom(Γ , (cid:92)x1:T (cid:46) x2:T list (cid:46)ϒ ))
Γ (cid:96) {x1:T (cid:46) x2:T list (cid:46)ϒ | ϕ} CONS {x3:T list (cid:46)ϒ | ∃ x1:T, x2:T list.ϕ ∧ x1 :: x2 = x3}

(RT-CONS)

Fig. 7 Typing rules (I)

– (RT-DIP) means that DIP IS is well typed if the body IS is typed under the stack
type obtained by removing the top element. However, since a property ϕ for
the initial stack relies on the popped value x, we keep the binding in the typing
environment.

– (RT-IF) means that the instruction is well typed if both branches have the same
post-condition; the pre-conditions of the branches are strengthened by the assump-

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

15

Γ (cid:96) {ϒ | ∃ x:int.ϕ ∧ x (cid:54)= 0} IS1 Φ

Γ (cid:96) {ϒ | ∃ x:int.ϕ ∧ x = 0} IS2 Φ

Γ (cid:96) {x:int (cid:46)ϒ | ϕ} IF IS1 IS2 Φ

(RT-IF)

Γ (cid:96) {ϒ | ∃ x:int.ϕ ∧ x (cid:54)= 0} IS {x:int (cid:46)ϒ | ϕ}
Γ (cid:96) {x:int (cid:46)ϒ | ϕ} LOOP IS {ϒ | ∃ x:int.ϕ ∧ x = 0}

(RT-LOOP)

(x1 /∈ dom(Γ , (cid:92)x:T list (cid:46)ϒ ))

(x1 (cid:54)= x2)
Γ (cid:96) {x1:T (cid:46) x2:T list (cid:46)ϒ | ∃ x:T list.ϕ ∧ x1 :: x2 = x} IS1 Φ
Γ (cid:96) {ϒ | ∃ x:T list.ϕ ∧ x = []} IS2 Φ

(x2 /∈ dom(Γ , (cid:92)x:T list (cid:46)ϒ ))

Γ (cid:96) {x:T list (cid:46)ϒ | ϕ} IF_CONS IS1 IS2 Φ

(RT-IFCONS)

(x1 /∈ dom(Γ , (cid:92)x:T list (cid:46)ϒ ))

(x1 (cid:54)= x2)
Γ , x2:T list (cid:96) {x1:T (cid:46)ϒ | ∃ x:T list.ϕ ∧ x1 :: x2 = x} IS {ϒ | ∃ x:T list.ϕ ∧ x2 = x}
Γ (cid:96) {x:T list (cid:46)ϒ | ϕ} ITER IS {ϒ | ∃ x:T list.ϕ ∧ x = []}

(x2 /∈ dom(Γ , (cid:92)x:T list (cid:46)ϒ ))

(x /∈ dom(Γ , (cid:98)ϒ ) ∪ {y1, y(cid:48)
1:T1 (cid:96) {y1:T1 (cid:46) ‡ | y(cid:48)
y(cid:48)

1, y2})

(y1 (cid:54)= y2)

y(cid:48)
1:T1, y1:T1 (cid:96) ϕ1 : ∗

1 = y1 ∧ ϕ1} IS {y2:T2 (cid:46) ‡ | ϕ2}

Γ (cid:96) {ϒ | ϕ} LAMBDA T1 T2 IS {x:T1 → T2 (cid:46) ϒ | ϕ ∧ ∀ y(cid:48)
call(x, y(cid:48)

1) = y2 =⇒ ϕ2}

1:T1, y1:T1, y2:T2.y(cid:48)

1 = y1 ∧ ϕ1 ∧

(RT-ITER)

(RT-LAMBDA)

(x3 /∈ dom(Γ , (cid:92)x1:T1 (cid:46) x2:T1 → T2 (cid:46)ϒ ))
Γ (cid:96) {x1:T1 (cid:46) x2:T1 → T2 (cid:46)ϒ | ϕ} EXEC {x3:T2 (cid:46)ϒ | ∃ x1:T1, x2:T1 → T2.ϕ ∧ call(x2, x1) = x3}

(RT-EXEC)

(x4 /∈ dom(Γ ,

(cid:92)x1:T (cid:46) x2:int (cid:46) x3:address (cid:46)ϒ ))

Γ (cid:96) {x1:T (cid:46) x2:int (cid:46) x3:address (cid:46) ϒ | ϕ} TRANSFER_TOKENS T {x4:
operation (cid:46)ϒ | ∃ x1:T, x2:int, x3:address.ϕ ∧ x4 = Transfer(x1, x2, x3)}

(RT-TRANSFERTOKENS)

Γ (cid:96) Φ1 <: Φ (cid:48)
1

Γ (cid:96) Φ (cid:48)
1 I Φ (cid:48)
2
Γ (cid:96) Φ1 I Φ2

Γ (cid:96) Φ (cid:48)

2 <: Φ2

(RT-SUB)

Fig. 8 Typing rules (II)

tions that the top of the input stack is True (x (cid:54)= 0) and False (x = 0). The variable
x is existentially quantiﬁed because the top element will be removed before the
execution of either branch.

– (RT-LOOP) is similar to the proof rule for while-loops in Hoare logic. The formula
ϕ is a loop invariant. Since the body of LOOP is executed while the stack top is
nonzero, the pre-condition for the body IS is strengthened by x (cid:54)= 0, whereas the
post-condition of LOOP IS is strengthened by x = 0.

– (RT-LAMBDA) is for the instruction to push a ﬁrst-class function onto the operand
stack. The premise of the rule means that the body IS takes a value (named y1) of
type T1 that satisﬁes ϕ1 and outputs a value (named y2) of type T2 that satisﬁes
ϕ2 (if it terminates). The post-condition in the conclusion expresses, by using
call, that the function x has the property above. The extra variable y(cid:48)
1 in the type
environment of the premise is an alias of y1; being a variable declared in the type

16

Stack Typing S : ¯T

Yuki Nishida et al.

(ST-BOTTOM)

‡ : ‡

V : T

S : ¯T

V (cid:46) S : T (cid:46) ¯T

(ST-PUSH)

Reﬁnement Stack Typing σ : Γ |= S : Φ

σ : Γ |= ϕ
σ : Γ |= ‡ : {‡ | ϕ}

(SEM-BOTTOM)

σ [x (cid:55)→ V ] : Γ , x:T |= S : {ϒ | ϕ}
σ : Γ |= V (cid:46) S : {x:T (cid:46)ϒ | ϕ}

(SEM-PUSH)

Fig. 9 Simple and reﬁnement stack typing

environment y(cid:48)
1 can appear in both ϕ1 and ϕ2
between the input and output of the function.

5 and can describe the relationship

– (RT-EXEC) just adds to the post-condition call(x2, x1) = x3, meaning the result
of a call to the function x2 with x1 as an argument yields x3. It may look simpler
than expected; the crux here is that ϕ is expected to imply ∀ x1:T1, x3:T2.ϕ1 ∧
call(x2, x1) = x3 =⇒ ϕ2, where ϕ1 and ϕ2 represent the pre- and post-conditions,
respectively, of function x2. If x1 satisﬁes ϕ1, then we can derive that ϕ2 holds.
– (RT-SUB) is the rule for subsumption to strengthening the pre-condition and

weakening the post-condition.

3.5 Properties

In this section, we show soundness of our type system. Informally, what we show
is that, for a well-typed program, if we execute it under a stack which satisﬁes the
pre-condition of the typing, then (if the evaluation halts) the resulting stack satisﬁes
the post-condition of the typing. We only sketch proofs with important lemmas. The
detailed proofs are found in Appendix A.

To state the soundness formally, we give additional deﬁnitions.

Deﬁnition 5 (Free variables). The set of free variables in ϕ is denoted by fvars(ϕ).

Deﬁnition 6 (Erasure). We deﬁne (cid:98)Φ(cid:99), which is the simple stack type obtained by
erasing predicates from Φ, as follows.

(cid:98){‡ | ϕ}(cid:99) = ‡

(cid:98){x:T (cid:46)ϒ | ϕ}(cid:99) = T (cid:46) (cid:98){ϒ | ϕ}(cid:99)

Deﬁnition 7 (Stack typing). Stack typing S : ¯T and reﬁnement stack typing σ : Γ |=
S : Φ are deﬁned by the rules in Figure 9.

Note that the deﬁnition of reﬁnement stack typing follows the informal explanation

of the reﬁnement stack types in Section 3.4.

We start from soundness of simple type system as follows, that is, for a simply
well-typed instruction sequence ¯T1 (cid:96) IS ⇒ ¯T2, if evaluation starts from correct stack S1,
that is S1 : ¯T1, and results in a stack S2; then S2 respects ¯T2, that is S2 : ¯T2. This lemma

5 The scope of a variable in a reﬁnement stack type is its predicate part and so y1 cannot appear in the

post-condition.

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

17

is not only just a desirable property but also one we use for proving the soundness of
the reﬁnement type system in the case EXEC.
Lemma 8 (Soundness of the Simple Type System). If ¯T1 (cid:96) IS ⇒ ¯T2, S1 (cid:96) IS ⇓ S2, and
S1 : ¯T1, then S2 : ¯T2.

Proof. Proved with a similar statement

If ¯T1 (cid:96) IS ⇒ ¯T2, S1 (cid:96) IS ⇓ S2, and S1 : ¯T1, then S2 : ¯T2

for a single instruction by simultaneous induction on ¯T1 (cid:96) IS ⇒ ¯T2 and ¯T1 (cid:96) I ⇒ ¯T2.

We state the main theorem as follows.

Theorem 9 (Soundness of the Reﬁnement Type System). If Γ (cid:96) Φ1 IS Φ2, S1 (cid:96) IS ⇓ S2,
and σ : Γ |= S1 : Φ1, then σ : Γ |= S2 : Φ2.

The proof is close to a proof of soundness of Hoare logic, with a few extra
complications due to the presence of ﬁrst-class functions. One of the key lemmas is
the following one, which states that a value assignment can be represented by a logical
formula or a stack element:

Lemma 10. The following statements are equivalent:

(1) σ : Γ |= S : {ϒ | ∃ x:T.ϕ ∧ x = V };
(2) σ [x (cid:55)→ V ] : Γ , x:T |= S : {ϒ | ϕ}; and
(3) σ : Γ |= V (cid:46) S : {x:T (cid:46)ϒ | ϕ}.

Then, we prove a few lemmas related to LOOP (Lemma 11), ITER (Lemma 12),

predicate call (Lemmas 13 and 14), and subtyping (Lemma 15).

Lemma 11. Suppose IS satisﬁes that S1 (cid:96) IS ⇓ S2 and σ : Γ |= S1 : {ϒ | ∃ x:int.ϕ ∧x (cid:54)=
0} imply σ : Γ |= S2 : {x:int (cid:46)ϒ | ϕ} for any S1 and S2. If S1 (cid:96) LOOP IS ⇓ S2 and
σ : Γ |= S1 : {x:int (cid:46)ϒ | ϕ}, then σ : Γ |= S2 : {ϒ | ∃ x:int.ϕ ∧ x = 0}.

Proof. By induction on the derivation of S1 (cid:96) LOOP IS ⇓ S2.

Lemma 12. Suppose x1 /∈ fvars(ϕ), x2 /∈ fvars(ϕ), and that S(cid:48)
T list |= S(cid:48)
S(cid:48)
2 : {ϒ | ∃ x:T list.ϕ ∧ x2 = x} for any S(cid:48)
σ : Γ |= S1 : {x:T list (cid:46)ϒ | ϕ}, then σ : Γ |= S2 : {ϒ | ∃ x:T list.ϕ ∧ x = []}.

2 and σ (cid:48) : Γ , x2:
1 : {x1:T (cid:46) ϒ | ∃ x:T list.ϕ ∧ x1 :: x2 = x} imply σ (cid:48) : Γ , x2:T list |=
2, and σ (cid:48). If S1 (cid:96) ITER IS ⇓ S2 and

1 (cid:96) IS ⇓ S(cid:48)

1, S(cid:48)

Proof. By induction on the derivation of S1 (cid:96) ITER IS ⇓ S2.

Lemma 13. If y1 (cid:54)= y2, y(cid:48)

1:T1, y1:T1 (cid:96) ϕ1 : ∗, y(cid:48)

1:T1, y2:T2 (cid:96) ϕ2 : ∗, (cid:104)IS(cid:105) : T1 → T2, and

for any V1,V2, σ , if V1 (cid:46) ‡ (cid:96) IS ⇓ V2 (cid:46) ‡ and
σ : y(cid:48)
then σ : y(cid:48)

1:T1 |= V1 (cid:46) ‡ : {y1:T1 (cid:46) ‡ | y(cid:48)
1:T1 |= V2 (cid:46) ‡ : {y2:T2 (cid:46) ‡ | ϕ2},

1 = y1 ∧ ϕ1}

then Γ |= ∀ y(cid:48)

1:T1, y1:T1, y2:T2.y(cid:48)

1 = y1 ∧ ϕ1 ∧ call((cid:104)IS(cid:105), y(cid:48)

1) = y2 =⇒ ϕ2 for any Γ .

Proof. By the deﬁnition of the semantics of call.

18

Yuki Nishida et al.

Lemma 14. If V1 (cid:46) ‡ (cid:96) IS ⇓ V2 (cid:46) ‡, V1 : T1, V2 : T2, and (cid:104)IS(cid:105) : T1 → T2, then Γ |=
call((cid:104)IS(cid:105),V1) = V2 for any Γ .

Proof. By the deﬁnition of the semantics of call.

Lemma 15. If Γ (cid:96) Φ1 <: Φ2 and σ : Γ |= S : Φ1, then σ : Γ |= S : Φ2.

Proof. Straightforward from Deﬁnition 4.

Proof of Theorem 9. It is proved together with a similar statement

If Γ (cid:96) Φ1 I Φ2, S1 (cid:96) I ⇓ S2, and σ : Γ |= S1 : Φ1, then σ : Γ |= S2 : Φ2.

for a single instruction by simultaneous induction on Γ (cid:96) Φ1 IS Φ2 and Γ (cid:96) Φ1 I Φ2
with case analysis on the last typing rule used. We show a few representative cases.

Case (RT-DIP): We have I = DIP IS and Φ1 = {x:T (cid:46)ϒ | ϕ} and Φ2 = {x:T (cid:46)ϒ (cid:48) | ϕ (cid:48)}
and Γ , x:T (cid:96) {ϒ | ϕ} IS {ϒ (cid:48) | ϕ (cid:48)} for some IS, x, T , ϒ , ϒ (cid:48), ϕ, and ϕ (cid:48). By (E-DIP),
1 (cid:96) IS ⇓ S(cid:48)
we have S1 = V (cid:46) S(cid:48)
2 and S(cid:48)
2. By
Lemma 10, we have σ [x (cid:55)→ V ] : Γ , x:T |= S(cid:48)
1 : {ϒ | ϕ}. By applying IH, we have
σ [x (cid:55)→ V ] : Γ , x:T |= S(cid:48)
2 : {x:T (cid:46)ϒ (cid:48) | ϕ (cid:48)}
follows.

2 : {ϒ (cid:48) | ϕ (cid:48)} from which σ : Γ |= V (cid:46) S(cid:48)

1 and S2 = V (cid:46) S(cid:48)

2 for some V , S(cid:48)

1, and S(cid:48)

Case (RT-LOOP): We have I = LOOP IS and Φ1 = {x:int (cid:46)ϒ | ϕ} and Φ2 = {ϒ | ∃ x:
int.ϕ ∧ x = 0} and Γ (cid:96) {ϒ | ∃ x:int.ϕ ∧ x (cid:54)= 0} IS {x:int (cid:46)ϒ | ϕ} and S1 = i (cid:46) S
for some IS, x, ϒ , S, and ϕ. By IH, we have that, for any S(cid:48)
2, if S(cid:48)
1, S(cid:48)
1 (cid:96) IS ⇓
1 : {ϒ | ∃ x:int.ϕ ∧ x (cid:54)= 0}, then σ : Γ |= S(cid:48)
2 and σ : Γ |= S(cid:48)
S(cid:48)
2 : {x:int (cid:46)ϒ | ϕ}.
The goal easily follows from Lemma 11.

1 and y(cid:48)

1:T1, y1:T1, y2:T2.y(cid:48)

1 = y1 ∧ ϕ1 ∧ call(x, y(cid:48)

1:T1 (cid:96) {y1:T1 (cid:46) ‡ | y(cid:48)
1, y2} and y1 (cid:54)= y(cid:48)

Case (RT-LAMBDA): We have I = LAMBDA T1 T2 IS and Φ1 = {ϒ | ϕ} and Φ2 = {x:
T1 → T2 (cid:46)ϒ | ϕ ∧ ∀ y(cid:48)
1) = y2 =⇒ ϕ2}
and y(cid:48)
1 = y1 ∧ ϕ1} IS {y2:T2 (cid:46) ‡ | ϕ2} and x /∈ dom(Γ , (cid:98)ϒ ) ∪
{y1, y(cid:48)
1, y2, T1,
T2, ϒ , ϕ, ϕ1, and ϕ2. By (E-LAMBDA), we also have S2 = (cid:104)IS(cid:105) (cid:46) S1. By IH, we
have that, for any V1,V2, σ , if V1 (cid:46)‡ (cid:96) IS ⇓ V2 (cid:46)‡ and σ : y(cid:48)
1:T1 |= V1 (cid:46)‡ : {y1:T1 (cid:46)‡ |
1:T1 |= V2 (cid:46)‡ : {y2:T2 (cid:46)‡ | ϕ2}. By Lemma 13, Γ , (cid:98)ϒ |= ∀ y(cid:48)
1 = y1 ∧ϕ1}, then σ : y(cid:48)
y(cid:48)
1:
T1, y1:T1, y2:T2.y(cid:48)
1) = y2 =⇒ ϕ2. Then, it is easy to show
σ : Γ |= S1 : {ϒ | ϕ ∧ ∀ y(cid:48)
1 = y1 ∧ ϕ1 ∧ call((cid:104)IS(cid:105), y(cid:48)
1) = y2 =⇒
ϕ2}. Then, we have

1 = y1 ∧ ϕ1 ∧ call((cid:104)IS(cid:105), y(cid:48)
1:T1, y1:T1, y2:T2.y(cid:48)

1:T1, y1:T1 (cid:96) ϕ1 : ∗ and for some IS, x, y1, y(cid:48)

σ : Γ |= S1 : {ϒ | ∃ x:T1 → T2.(ϕ ∧

∀ y(cid:48)

1:T1, y1:T1, y2:T2.y(cid:48)

1 = y1 ∧ ϕ1 ∧ call(x, y(cid:48)

1) = y2 =⇒ ϕ2) ∧ x = (cid:104)IS(cid:105)}.

Therefore, by Lemma 10, we have

σ : Γ |= (cid:104)IS(cid:105) (cid:46) S1 : {x:T1 → T2 (cid:46)ϒ | ϕ ∧

∀ y(cid:48)

1:T1, y1:T1, y2:T2.y(cid:48)

1 = y1 ∧ ϕ1 ∧ call(x, y(cid:48)

1) = y2 =⇒ ϕ2}

as required.

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

19

Case (RT-EXEC): We have I = EXEC and, for some x1, x2, x3, T1, T2, ϒ , and ϕ,
Φ1 = {x1:T1 (cid:46) x2:T1 → T2 (cid:46)ϒ | ϕ} and Φ2 = {x3:T2 (cid:46)ϒ | ∃ x1:T1, x2:T1 → T2.ϕ ∧
call(x2, x1) = x3} and x3 /∈ dom(Γ , (cid:92)x1:T1 (cid:46) x2:T1 → T2 (cid:46)ϒ ). By (E-EXEC), we
have S1 = V1 (cid:46)(cid:104)IS(cid:105)(cid:46)S and S2 = V2 (cid:46)S and V1 (cid:46)‡ (cid:96) IS ⇓ V2 (cid:46)‡ for some V1, V2, IS, and
S. By the assumption σ : Γ |= S1 : Φ1, we have σ : Γ |= S : {ϒ | ∃ x2:T1 → T2.(∃ x1:
T1.ϕ ∧ x1 = V1) ∧ x2 = (cid:104)IS(cid:105)}. By Lemma 14, we have Γ , (cid:98)ϒ |= call((cid:104)IS(cid:105),V1) = V2.
Therefore, we have σ : Γ |= S : {ϒ | (∃ x2:T1 → T2.(∃ x1:T1.ϕ ∧ x1 = V1) ∧ x2 =
(cid:104)IS(cid:105)) ∧ call((cid:104)IS(cid:105),V1) = V2}. Finally, we have σ : Γ |= S : {ϒ | ∃ x3:T2.(∃ x1:T1, x2:
T1 → T2.ϕ ∧ call(x2, x1) = x3) ∧ x3 = V2} and, thus, σ : Γ |= V2 (cid:46) S : {x3:T2 (cid:46)ϒ |
(∃ x1:T1, x2:T1 → T2.ϕ ∧ call(x2, x1) = x3)} as required.

Case (RT-SUB): We have Γ (cid:96) Φ1 <: Φ (cid:48)

1 and Γ (cid:96) Φ (cid:48)

some Φ (cid:48)
σ : Γ |= S2 : Φ (cid:48)

1 and Φ (cid:48)

2. By Lemma 15, we have σ : Γ |= S1 : Φ (cid:48)

2. Then, the goal follows from Lemma 15.

2 <: Φ2 and Γ (cid:96) Φ (cid:48)

1 I Φ (cid:48)

2 for
1. By IH, we have

3.6 Extension with Exceptions

The type system implemented in HELMHOLTZ is extended to handle instruction
FAILWITH, which immediately aborts the execution, discarding all the stack elements
but the top element. The type judgment form is extended to

Γ (cid:96) Φ1 IS Φ2 & Φ3,

which means that, if IS is executed under a stack satisfying Φ1, then the resulting stack
satisﬁes Φ2 (if normally terminates), or Φ3 (if aborted by FAILWITH). The typing rule
for instruction FAILWITH, which raises an exception with the value at the stack top, is
given as follows:

Γ (cid:96) {x:T (cid:46)ϒ | ϕ} FAILWITH {ϒ | ⊥} & { err | ∃ x:T, (cid:98)ϒ .ϕ ∧ x = err}.

The rule expresses that, if FAILWITH is executed under a non-empty stack that satisﬁes
ϕ, then the program point just after the instruction is not reachable (hence, {ϒ | ⊥}).
The reﬁnement ∃ x:T, (cid:98)ϒ .ϕ ∧ x = err for the exception case states that ϕ in the pre-
condition with the top element x is equal to the raised value err; since x is not in the
scope in the exception reﬁnement, x is bound by an existential quantiﬁer. Most of the
other typing rules can be extended with the “&” part easily.

For (RT-LAMBDA) and (RT-EXEC), we ﬁrst extend the the assertion language
with a new predicate call_err(t1,t2) = t3 meaning the call of t1 with t2 aborts with
the value t3. (The semantics of call is unchanged.) Using the new predicate, (RT-
LAMBDA) and (RT-EXEC) are modiﬁed as in Figure 10.

4 Tool Implementation

In this section, we present HELMHOLTZ, the veriﬁcation tool based on the reﬁnement
type system. We ﬁrst discuss how Michelson code can be annotated. Then, we give an
overview of the veriﬁcation algorithm, which reduces the veriﬁcation problem to SMT
solving, and discuss how Michelson-speciﬁc features are encoded. Finally, we show a
case study of contract veriﬁcation and present veriﬁcation experiments.

20

Yuki Nishida et al.

(x /∈ dom(Γ , (cid:98)ϒ ) ∪ {y1, y(cid:48)
1:T1 (cid:96) {y1:T1 (cid:46) ‡ | y(cid:48)
y(cid:48)

1, y2})

(y1 (cid:54)= y2)

y(cid:48)
1:T1, y1:T1 (cid:96) ϕ1 : ∗
1 = y1 ∧ ϕ1} IS {y2:T2 (cid:46) ‡ | ϕ2} & { err | ϕ3}
1:T1, y1:T1, y2:T2.y(cid:48)

Γ (cid:96) {ϒ | ϕ} LAMBDA T1 T2 IS {x:T1 → T2 (cid:46)ϒ | ϕ ∧ ∀ y(cid:48)
y2 =⇒ ϕ2) ∧ (call_err(x, y(cid:48)

1) = err =⇒ ϕ3)} & { err | ⊥}

1 = y1 ∧ ϕ1 =⇒ (call(x, y(cid:48)

1) =

(x3 /∈ dom(Γ , (cid:92)x1:T1 (cid:46) x2:T1 → T2 (cid:46)ϒ ))
Γ (cid:96) {x1:T1 (cid:46) x2:T1 → T2 (cid:46)ϒ | ϕ} EXEC {x3:T2 (cid:46)ϒ | ∃ x1:T1, x2:T1 → T2.ϕ ∧ call(x2, x1) = x3} & { err |
∃ x1:T1, x2:T1 → T2, (cid:98)ϒ .ϕ ∧ call_err(x2, x1) = err}

Fig. 10 Modiﬁed Typing Rules for LAMBDA and EXEC.

4.1 Annotations

HELMHOLTZ supports several forms of annotations (surrounded by << and >> in the
source code), other than ContractAnnot explained in Section 2. As we have already
mentioned, ML-like notations can be used to describe formulae, which have to be
quantiﬁer free (mainly because state-of-the-art SMT solvers do not handle quentiﬁers
very well). We explain several constructs for an annotation in the following.

Assert Φ and Assume Φ can appear before or after an instruction. The former
asserts that the stack at the annotated program location satisﬁes the type Φ; the
assertion is veriﬁed by HELMHOLTZ. If there is an annotation Assume Φ, HELM-
HOLTZ assumes that the stack satisﬁes the type Φ at the annotated program location.
A user can give a hint to HELMHOLTZ by using Assume Φ. The user has to make sure
that it is correct; if an Assume annotation is incorrect, the veriﬁcation result may also
be incorrect.

An annotation LoopInv Φ may appear before a loop instruction (e.g., LOOP and
ITER). It asserts that Φ is a loop invariant of the loop instruction. In the current
implementation, annotating a loop invariant using LoopInv Φ is mandatory for a loop
instruction. HELMHOLTZ checks that Φ is indeed a loop invariant and uses it to verify
the rest of the program.

In the current implementation, a LAMBDA instruction, which pushes a func-
tion on the top of the stack, must be accompanied by a LambdaAnnot annotation.
LambdaAnnot comes with a speciﬁcation of the pushed function written in the same
way as ContractAnnot. Concretely, the speciﬁcation of the form Φpre → Φpost &
Φabpost(x1 : T1, . . . , xn : Tn) speciﬁes the precondition Φpre, the (normal) postcondition
Φpost, and the (abnormal) postcondition Φabpost as reﬁnement stack types. The binding
(x1 : T1, . . . , xn : Tn) introduces the ghost variables that can be used in the annotations
in the body of the annotated LAMBDA instruction;6; one can omit if it is empty.

The ﬁrst contract in Figure 11, which pushes a function that takes a pair of integers
and returns the sum of them, exempliﬁes LambdaAnnot. The annotated type of the
function (Line 6) expresses that it returns 4 if it is fed with a pair (3, 1). The ghost
variables a and b are used in the annotations Assume (Line 10) and Assert (Line 12)
in the body to denote the ﬁrst and the second arguments of the pair passed to this
function.

6 ContractAnnot also allows declarations of ghost variable used in the code section.

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

21

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

1
2
3
4
5
6
7
8
9
10
11
12
13

parameter unit ;
storage int ;
<< ContractAnnot { _ | True } -> { _ | True }

& { _ | False } >>

code { DROP ;

<< LambdaAnnot { p | p = (3 , 1) } -> { x | x = 4 }

& { _ | False }

( a : int , b : int ) >>

LAMBDA ( pair int int ) int

{ << Assume { p | p = (a , b ) } >>

UNPAIR ; ADD
<< Assert { p | p = a + b } >>

};

PUSH int 1; PUSH int 3; PAIR ; EXEC ;
<< Assert { x | x = 4 } >>
NIL operation ; PAIR

}

parameter ( list int );
storage int ;
<< Measure len : list int -> int

where [] = 0 | h :: t = (1 + len t ) >>

<< ContractAnnot

{ (p , _ ) | True } -> { (_ , ret ) | len p = ret }
& { _ | False } >>

code { CAR ; PUSH int 0; SWAP ;

<< LoopInv { l : n | len l + n = len p } >>
ITER { DROP ; PUSH int 1; ADD };
NIL operation ;
PAIR

}

Fig. 11 lambda.tz, which uses higher-order functions, and length.tz, which uses a measure function
in the contract annotation.

To describe a property for recursive data structures, HELMHOLTZ supports measure
functions introduced by Kawaguchi et al. [9] and also supported in Liquid Haskell [23].
A measure function is a (recursive) function over a recursive data structure that can
be used in assertions. The annotation Measure x : T1 → T2 where p1 = e1 | · · · | pn =
en deﬁnes a measure function x over the type T1. The measure function x takes a
value of type T1, destructs it by the pattern matching, and returns a value of type T2.
Metavariables p and e represent ML-like patterns and expressions. The second contract
in Figure 11, which computes the length of the list passed as a parameter, exempliﬁes
the usage of the Measure annotation. This contract deﬁnes a measure function len
that takes a list of integers and returns its type; it is used in ContractAnnot and
LoopInv.

22

Yuki Nishida et al.

4.2 Overview of the Veriﬁcation Algorithm

HELMHOLTZ takes an annotated Michelson program and conducts typechecking
based on the reﬁnement type system in Section 3.4. The typechecking procedure (1)
computes the veriﬁcation conditions (VCs) for the program to be well-typed and (2)
discharges it using an SMT solver. The latter is standard: We decide the validity of the
generated VCs using an SMT solver (Z3 in the current implementation.) We explain
the VC-generation step in detail.

For an annotated contract, HELMHOLTZ conducts forward reasoning starting
from the precondition and generates VCs if necessary. During the forward reasoning,
HELMHOLTZ keeps track of the Γ -and-ϒ part of the type judgment.

The typing rules are designed so that they enable the forward reasoning if a
program is simply typed. For example, consider the rule (RT-ADD) in Figure 7. This
rule can be read as a rule to compute a postcondition ∃ x1:int, x2:int.ϕ ∧ x1 + x2 = x3
from a precondition ϕ if the ﬁrst two elements in ϒ are x1 and x2. The other rules can
also be read as postcondition-generation rules in the same way.

There are three places where HELMHOLTZ generates a veriﬁcation condition.

– At the end of the program: HELMHOLTZ generates a condition that ensures that the
computed postcondition of the entire program implies the postcondition annotated
to the program.

– Before and after instruction LAMBDA: HELMHOLTZ generates conditions that en-
sure that the pre- and post- conditions of the instruction LAMBDA is as annotated in
LambdaAnnot.

– At a loop instruction: HELMHOLTZ generates veriﬁcation conditions that ensure
the condition annotated by LoopInv is indeed a loop invariant of this instruction.

A VC generated by HELMHOLTZ at these places is of the form ∀(cid:126)x :(cid:126)T .ϕ1 ⇒ ϕ2, where
(cid:126)x :(cid:126)T is a sequence of bindings.

To discharge each VC, as many veriﬁcation condition discharging procedures
do, HELMHOLTZ checks whether its negation, ∃(cid:126)x :(cid:126)T .ϕ1 ∧ ¬ϕ2, is satisﬁable; if it is
unsatisﬁable, then the original VC is successfully discharged. We remark that our
type system is designed so that ϕ1 and ϕ2 are quantiﬁer free for a program that does
not use LAMBDA and EXEC. Indeed, ϕ2 comes only from the annotations, which are
quantiﬁer-free. ϕ1 comes from the postcondition-computation procedure, which is of
the form ∃(cid:126)x(cid:48) : (cid:126)T (cid:48).ϕ (cid:48)
1 for the instructions other than LAMBDA and
EXEC; the formula ∃(cid:126)x :(cid:126)T .ϕ1 ∧ ¬ϕ2 is equivalent to ∃(cid:126)x :(cid:126)T ,(cid:126)x(cid:48) : (cid:126)T (cid:48).ϕ (cid:48)

1 for quantiﬁer-free ϕ (cid:48)

1 ∧ ¬ϕ2.

4.3 Encoding Micheslon-Speciﬁc Features

Since our assertion language includes several speciﬁc features that originates from
Michelson and our assertion language, HELMHOLTZ needs to encode them in dis-
charging VCs so that Z3 can handle them. We explain how this encoding is conducted.

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

23

4.3.1 Michelson-Speciﬁc Functions and Predicates

We use encode several Michelson-speciﬁc values using uninterpreted functions. For
example, HELMHOLTZ assumes the following typing rule for instruction SHA256,
which converts the top element to its SHA256 hash.

Γ (cid:96) {x : bytes (cid:66)ϒ | φ } SHA256 {y : bytes (cid:66)ϒ | ∃x.φ ∧ y = sha256(x)}

In the post condition, we use an uninterpreted function sha256 to express the SHA256
hash of x. In Z3, this uninterpreted function is declared as follows.

1
2

( declare - fun sha256 ( String ) String )
( assert ( forall (( x String )) (= ( str . len ( sha256 x )) 32)))

The ﬁrst line declares the signature of sha256. The second line is the axiom for sha256
that the length of a hash is always 32.

Notice that, we cannot assert that a hash is equal to a speciﬁc constant since sha256

is an uninterpreted function. Therefore, HELMHOLTZ cannot prove:

Γ (cid:96) {x : bytes | x = 0} SHA256 {y : bytes (cid:66)ϒ | ∃x.φ ∧ y =
“6e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d”}.

4.3.2 Implementation of Measure Functions

A measure function is encoded as an uninterpreted function accompanied with axioms
that specify the behavior of the function, which is deﬁned by the Measure annotation.
For example, for the following form of a measure function deﬁnition for lists:

1

<< Measure f : list T -> T ’ where [] = e1 | h :: t = e2 >>

Theoretically, one could insert the following declarations and assertions when it
generates an input to Z3 to encode this deﬁnition:

1
2
3
4

( declare-fun f (( List T )) T ’)
( assert (= ( f []) e1 ))
( assert ( forall (( h T ) ( t ( List T )))

(= ( f ( cons h t )) e2 )))

However, Z3 tends to timeout if we naively insert the above axioms to Z3 input which
contains a universal quantiﬁer in the encoded deﬁnition.

To address this problem, HELMHOLTZ rewrites VCs so that heuristically in-
stantiated conditions on a measure function are available where necessary. Con-
sider the above deﬁnition of f as an example. Suppose HELMHOLTZ obtains a
VC of the form ∃(cid:126)x :(cid:126)T .ϕ1 ∧ ¬ϕ2 mentioned in Section 4.2 and ϕ1 and ϕ2 contains
(cons eh,i et,i) for i ∈ {1, . . . , N}. Then, HELMHOLTZ constructs a formula ϕmeas :=
(cid:86)
i∈{1,...,N} (= (f (cons eh,i et,i)) e2) and rewrites the VC to ∃(cid:126)x :(cid:126)T .ϕmeas ∧ ϕ1 ∧
¬ϕ2.

We remark that, in LiquidHaskell, measure functions are treated as a part of the
type system [9]: the asserted axioms are systematically (instantiated and) embedded
into the typing rules. In HELMHOLTZ, measure functions are treated as an ingredient
that is orthogonal to the type system; the type system is oblivious of measure functions
until its deﬁnition is inserted to Z3 input.

24

Yuki Nishida et al.

4.3.3 Overloaded Functions

Due to the polymorphically-typed instructions in Michelson, our assertion language
incorporates polymorphic uninterpreted functions. For example, Michelson has an
instruction PACK, which pops a value (of any type) from the stack, serializes it to a
binary representation, and pushes the serialized value. HELMHOLTZ typechecks this
instruction based on the following rule.

Γ (cid:96) {x : T (cid:66)ϒ | ϕ} PACK {y : bytes (cid:66)ϒ | ∃x : T.ϕ ∧ y = pack(x)}

The term pack(x) in the postcondition represents a serialized value created from x.
Since x may be of any simple type T , pack must be polymorphic.

Having a polymorphic uninterpreted function in assertions is tricky because Z3
does not support a polymorphic value. HELMHOLTZ encodes polymorphic uninter-
preted functions to a monomorphic function whose name is generated by mangling the
name of its instantiated parameter type. For example, the above pack(x) is encoded as
a Z3 function pack!int(x) whose type is int → bytes. Although there are inﬁnitely
many types, the number of the encoded functions is ﬁnite since only ﬁnitely many
types appear in a single contract.

4.3.4 Michelson-Speciﬁc Types

In encoding a VC as Z3 constraints, HELMHOLTZ maps types in Michelson into
sorts in Z3, e.g., the Michelson type nat for nonnegative integers to the Z3 sort
Int. A naive mapping from Michelson types to Z3 sorts is problematic; for example,
∀x : nat.x ≥ 0 in HELMHOLTZ is valid, but a naively encoded formula (forall ((x
Int)) (>= x 0)) is invalid in Z3. This naive encoding ignores that a value of sort
nat is nonnegative.

To address the problem, we adapt the method encoding a many-sorted logic
formula into a single-sorted logic formula [3]. Concretely, we deﬁne a sort predicate
PT (x) for each sort T , which characterizes the property of the sort T . For example,
Pnat(x) := x ≥ 0. We also deﬁne sort predicates for compound data types.

Using the sort predicates, we can encode a VC into a Z3 constraint as follows: ∀x :
T.φ is encoded into ∀x : [[T ]].PT (x) ⇒ φ and ∃x : T.φ is encoded into ∃x : [[T ]].PT (x) ∧
φ , where [[T ]] denotes the target sort of T (e.g., [[nat]] = Int). Furthermore, we also
add axioms about co-domain of uninterpreted functions as ∀(cid:126)xi : (cid:126)Ti.PT ( f ((cid:126)xi)) for the
function f of (cid:126)Ti → T .

4.4 Case Study: Contract with Signature Veriﬁcation

Figure 12 presents the code of the contract checksig.tz, which veriﬁes that a
sender indeed signed certain data using her private key. This contract uses instruction
CHECK_SIGNATURE, which is supposed to be executed under a stack of the form key
(cid:46) sig (cid:46) bytes (cid:46) tl, where key is a public key, sig is a signature, and bytes is some
data. CHECK_SIGNATURE pops these three values from the stack and pushes True
if sig is the valid signature for bytes with the private key corresponding to key.

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

25

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25

parameter ( pair signature string );
storage ( pair address key );
<< ContractAnnot

{ (( sign , data ) , ( addr , pubkey )) |

match contract_opt addr with
| Some ( Contract < string > _ ) -> True | _ -> False } ->

{ ( ops , new_store ) | ( addr , pubkey ) = new_store &&
sig pubkey sign ( pack data ) &&
match contract_opt addr with
| Some c -> ops = [ TransferTokens data 1 c ]
| None -> False }

& { _ | not ( sig pubkey sign ( pack data )) } >>

code

{ DUP ; DUP ; DUP ;

DIP { CAR ; UNPAIR ; DIP { PACK } }; CDDR ;
CHECK_SIGNATURE ; ASSERT ;

UNPAIR ; CDR ; SWAP ; CAR ;
CONTRACT string ; ASSERT_SOME ; SWAP ;
PUSH mutez 1; SWAP ;
TRANSFER_TOKENS ;

NIL operation ; SWAP ;
CONS ; DIP { CDR };
PAIR

}

Fig. 12 checksig.tz, which involves signature veriﬁcation.

The instruction ASSERT after CHECK_SIGNATURE checks if the signature checking has
succeeded; it aborts the execution of the contract if the stack top is False; otherwise,
it pops the stack top (True) and proceeds the next instruction.

The intended behavior of checksig.tz is as follows. It stores a pair of an address
addr, which is the address of a contract that takes a string parameter, and a public
key pubkey in its storage. It takes a pair (sign,data) of type (pair signature
string) as a parameter; here, signature is the primitive Michelson type for signa-
tures. This contract terminates without exception if sign is created from the serialized
(packed) representation of data and signed by the private key corresponding to
pubkey. In a normal termination, this contract transfers 1 mutez to the contract with
address addr. If this signature veriﬁcation fails, then an exception is raised.

This behavior is expressed as a speciﬁcation in the ContractAnnot annotation in

checksig.tz as follows.

– The reﬁnement of its pre-condition part expresses that the address stored in
the ﬁrst element addr of the storage is an address of a contract that takes a
value of type string as a parameter. This is expressed by the pattern-matching
on contract_opt addr, which checks if there is an intended parameter type
of contract stored at the address addr and returns the contract (wrapped by
Some) if there is. The intended parameter type is given by the pattern expres-
sion Contract<string> _, which matches a contract that takes a string.

26

Yuki Nishida et al.

– The reﬁnement of the post-condition forces the following three conditions: (1)
the store is not updated by this contract ((addr, pubkey) = new_store); (2)
sign is the signature created from the packed bytes pack data of the string in
the second element of the parameter and signed by the private key corresponding
to the second element pubkey of the store (sig pubkey sign (pack data));
and (3) the operations ops returned by this contract is [ Transfer data 1 c
], which represents an operation of transferring 1 mutez to the contract c, which
is bound to Contract addr, with the parameter data. The predicate sig and the
function pack are primitives of the assertion language of HELMHOLTZ.

– The reﬁnement in the exception part expresses that if an exception is raised, then
the signature veriﬁcation should have failed (not (sig pubkey sign (pack
data))).

HELMHOLTZ successfully veriﬁes checksig.tz without any additional annota-
tion in the code section. If we change the instruction ASSERT in Line 15 to DROP to
let the contract drop the result of the signature veriﬁcation (hence, an exception is not
raised even if the signature veriﬁcation fails), the veriﬁcation fails as intended.

4.5 Experiments

We applied HELMHOLTZ to various contracts; Table 1 is an excerpt of the result, in
which we show (1) the number of the instructions in each contract (column #instr.) and
(2) time (ms) spent to verify each contract. The experiments are conducted on MacOS
Big Sur 11.4 with Quad-Core Intel Core i7 (2.3 GHz), 32 GB RAM. We used Z3
version 4.8.10. The contracts boomerang.tz, deposit.tz, manager.tz, vote.tz,
and reservoir.tz are taken from the benchmark of Mi-cho-coq [2]. checksig.tz,
discussed above, is derived from weather_insurance.tz of the ofﬁcial Tezos test
suite.7 vote_for_delegate.tz and xcat.tz are taken from the ofﬁcial test suite;
xcat.tz is simpliﬁed from the original. tzip.tz is taken from Tezos Improvement
proposals.8 triangular_num.tz is a simple test case that we made as an example
of using LOOP. The source code of these contracts can be found at the Web interface
of HELMHOLTZ. Each contract is supposed to work as follows.

– boomerang.tz: Transfers the received amount of money to the source account.
– deposit.tz: Transfers money to the sender if the address of the sender is identical

to that is stored in the storage.

– manager.tz: Calls the passed function if the address of the caller matches the

address stored in the storage.

– vote.tz: Accepts a vote to a candidate if the voter transfers enough voting fee,

and stores the tally.

– tzip.tz: One of the components implementing Tezos smart contracts API. We

verify one entrypoint of the contract.

7 https://gitlab.com/tezos/tezos/-/tree/ee2f75bb941522acbcf6d5065a9f3b2/tests_

python/contracts/mini_scenarios

8 https://gitlab.com/tezos/tzip/-/blob/b73c7cd5df8e045bbf7ad9ac20a45fb3cb862c87/

proposals/tzip-7/tzip-7.md

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

27

Table 1 Benchmark result

Filename
boomerang.tz
deposit.tz
manager.tz
vote.tz
tzip.tz
checksig.tz

#instr.
17
24
24
24
537
32

time (ms)
435
451
449
450
15578
468

Filename
checksig_unverified.tz
vote_for_delegate.tz
xcat.tz
reservoir.tz
triangular_num.tz

#instr.
30
78
52
45
16

time (ms)
462
608
513
482
517

– checksig.tz: The one explained in Section 4.4.
– vote_for_delegate.tz: Delegates one’s ballot in voting by stakeholders, which
is one of the fundamental features of Tezos, to another using a primitive operation
of Tezos.

– xcat.tz: Transfers all stored money to one of the two accounts speciﬁed before-
hand if called with the correct password. The account that gets money is decided
based on whether the contract is called before or after a deadline.

– reservoir.tz: Sends a certain amount of money to either a contract or another

depending on whether the contract is executed before or after the deadline.

– triangular_num.tz: Calculates the sum from 1 to n, which is the passed param-

eter.

In the experiments, we veriﬁed that each contract indeed works according to the
intention explained above. triangular_num.tz was the only contract that required
a manual annotation for veriﬁcation in the code section; we needed to specify a loop
invariant in this contract.

Although the numbers of instructions in these contracts are not large, they capture
essential features of smart contracts; every contract except triangular_num.tz
executes transactions; deposit.tz and manager.tz check the identity of the caller;
and checksig.tz conducts signature veriﬁcation. The time spent on veriﬁcation is
small.

5 Related Work

There are several publications on the formalization of programming languages for
writing smart contracts. Hirai [7] formalizes EVM, a low-level smart contract language
of Ethereum and its implementation, using Lem [14], a language to specify semantic
deﬁnitions; deﬁnitions written in Lem can be compiled into deﬁnitions in Coq, HOL4,
and Isabelle/HOL. Based on the generated deﬁnition, he veriﬁes several properties
of Ethereum smart contracts using Isabelle/HOL. Bernardo et al. [2] implemented
Mi-Cho-Coq, a formalization of the semantics of Michelson using the Coq proof
assistant. They also veriﬁed several Michelson contracts. Compared to their approach,
we aim to develop an automated veriﬁcation tool for smart contracts. Park et al. [15]
developed a formal veriﬁcation tool for EVM by using the K-framework [17], which
can be used to derive a symbolic model checker from a formally speciﬁed language
semantics (in this case, formalized EVM semantics [6]), and successfully applied the
derived model checker to a few EVM contracts. It would be interesting to formalize

28

Yuki Nishida et al.

the semantics of Michelson in the K-framework to compare HELMHOLTZ with the
derived model checker.

The DAO attack [18], mentioned in Section 1, is one of the notorious attacks on a
smart contract. It exploits a vulnerability of a smart contract that is related to a callback.
Grossman et al. [5] proposed a type-based technique to verify that execution of a smart
contract that may contain callbacks is equivalent to another execution without any
callback. This property, called effectively callback freedom, can be seen as one of the
criteria for execution of a smart contract not to be vulnerable to the DAO-like attack.
Their type system focuses on verifying the ECF property of the execution of a smart
contract, whereas ours concerns the veriﬁcation of generic functional properties of a
smart contract.

Benton proposes a program logic for a minimal stack-based programming lan-
guage [1]. His program logic can give an assertion to a stack as our stack reﬁnement
types do. However, his language does not support ﬁrst-class functions nor instructions
for dealing with smart contracts (e.g., signature veriﬁcation).

Our type system is an extension of the Michelson type system with reﬁnement
types, which have been successfully applied to various programming languages [16,22,
9,10,20,26,23,24, 25]. DTAL [25] is a notable example of an application of reﬁnement
types to an assembly language, a low-level language like Michelson. A DTAL program
deﬁnes a computation using registers; we are not aware of reﬁnement types for stack-
based languages like Michelson.

We notice the resemblance between our type system and a program logic for PCF
proposed by Honda and Yoshida [8], although the targets of veriﬁcation are different.
Their logic supports a judgment of the form A (cid:96) e :u B, where e is a PCF program,
A is a pre-condition assertion, B is a post-condition assertion, and u represents the
value that e evaluates to and can be used in B, which resembles our type judgment
in the formalization in Section 3. Their assertion language also incorporates a term
expression f • x, which expresses the value resulting from the application of f to x;
this expression resembles the formula call(t1,t2) = t3 used in a reﬁnement predicate.
We have not noticed an automated veriﬁer implemented based on their logic. Further
comparison is interesting future work.

6 Conclusion

We described our automated veriﬁcation tool HELMHOLTZ for the smart contract
language Michelson based on the reﬁnement type system for Mini-Michelson. HELM-
HOLTZ veriﬁes whether a Michelson program follows a speciﬁcation given in the form
of a reﬁnement type. We also demonstrated that HELMHOLTZ successfully veriﬁes
various practical Michelson contracts.

Currently, HELMHOLTZ supports approximately 80% of the whole instructions of
the Michelson language. The deﬁnition of a measure function is limited in the sense
that, for example, it can deﬁne only a function with one argument. We are currently
extending HELMHOLTZ so that it can deal with more programs.

HELMHOLTZ currently veriﬁes the behavior of a single contract, although a
blockchain application often consists of multiple contracts in which contract calls are

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

29

chained. To verify such an application as a whole, we plan to extend HELMHOLTZ
so that it can verify an inter-contract behavior compositionally by combining the
veriﬁcation results of each contract.

Acknowledgements This work has been partially supported by a research grant from Tezos Foundations.
Igarashi’s ﬁrst encounter with formal proofs was when he visited Prof. Hagiya’s group as an intern and
played Boomborg PC.

References

1. Benton, N.: A Typed, Compositional Logic for a Stack-Based Abstract Machine. In: Proceedings of
Asian Symposium on Programming Languages and Systems (APLAS), pp. 364–380. Springer Berlin
Heidelberg (2005). DOI 10.1007/11575467_24

2. Bernardo, B., Cauderlier, R., Hu, Z., Pesin, B., Tesson, J.: Mi-Cho-Coq, a framework for certifying
Tezos smart contracts. In: Formal Methods. FM 2019 International Workshops - Porto, Portugal,
October 7-11, 2019, Revised Selected Papers, Part I, Lecture Notes in Computer Science, vol. 12232,
pp. 368–379. Springer (2019). DOI 10.1007/978-3-030-54994-7_28

3. Enderton, H.B.: A Mathematical Introduction to Logic. Academic Press (2001)
4. Goodman, L.: Tezos — a self-amending crypto-ledger. white paper. https://tezos.com/static/
white_paper-2dc8c02267a8fb86bd67a108199441bf.pdf (2014). Retrieved Oct. 14, 2020.
5. Grossman, S., Abraham, I., Golan-Gueta, G., Michalevsky, Y., Rinetzky, N., Sagiv, M., Zohar, Y.:
Online detection of effectively callback free objects with applications to smart contracts. Proc. ACM
Program. Lang. 2(POPL) (2017). DOI 10.1145/3158136

6. Hildenbrandt, E., Saxena, M., Rodrigues, N., Zhu, X., Daian, P., Guth, D., Moore, B., Park, D.,
Zhang, Y., Stefanescu, A., Rosu, G.: KEVM: A Complete Formal Semantics of the Ethereum Virtual
Machine. In: 2018 IEEE 31st Computer Security Foundations Symposium (CSF), pp. 204–217 (2018).
DOI 10.1109/CSF.2018.00022

7. Hirai, Y.: Deﬁning the Ethereum virtual machine for interactive theorem provers.

In: Financial

Cryptography and Data Security, pp. 520–535. Springer International Publishing (2017)

8. Honda, K., Yoshida, N.: A compositional logic for polymorphic higher-order functions. In: Proceedings
of the 6th International ACM SIGPLAN Conference on Principles and Practice of Declarative Program-
ming, 24-26 August 2004, Verona, Italy, pp. 191–202. ACM (2004). DOI 10.1145/1013963.1013985
9. Kawaguchi, M., Rondon, P.M., Jhala, R.: Type-based data structure veriﬁcation. In: Proceedings of
the 2009 ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI
2009, Dublin, Ireland, June 15-21, 2009, pp. 304–315. ACM (2009). DOI 10.1145/1542476.1542510
10. Kobayashi, N., Sato, R., Unno, H.: Predicate abstraction and CEGAR for higher-order model check-
ing.
In: Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language De-
sign and Implementation, PLDI 2011, San Jose, CA, USA, June 4-8, 2011, pp. 222–233 (2011).
DOI 10.1145/1993498.1993525

11. de Moura, L.M., Bjørner, N.: Z3: an efﬁcient SMT solver. In: Tools and Algorithms for the Construction
and Analysis of Systems, 14th International Conference, TACAS 2008, Held as Part of the Joint
European Conferences on Theory and Practice of Software, ETAPS 2008, Budapest, Hungary, March
29-April 6, 2008. Proceedings, pp. 337–340 (2008). DOI 10.1007/978-3-540-78800-3_24

12. Nakamoto, S.: Bitcoin: A peer-to-peer electronic cash system. https://bitcoin.org/bitcoin.

pdf (2008). Retrieved Oct. 12, 2020.

13. Nomadic Labs: Michelson: the language of smart contracts in Tezos. https://tezos.gitlab.io/

whitedoc/michelson.html. Retrieved Oct. 14, 2020.

14. Owens, S., Böhm, P., Zappa Nardelli, F., Sewell, P.: Lem: A lightweight tool for heavyweight semantics.

In: Interactive Theorem Proving, pp. 363–369. Springer Berlin Heidelberg (2011)

15. Park, D., Zhang, Y., Saxena, M., Daian, P., Ro¸su, G.: A formal veriﬁcation tool for Ethereum VM
bytecode. In: Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering
Conference and Symposium on the Foundations of Software Engineering, pp. 912–915. ACM (2018).
DOI 10.1145/3236024.3264591

16. Rondon, P.M., Kawaguchi, M., Jhala, R.: Liquid types. In: Proceedings of the ACM SIGPLAN 2008
Conference on Programming Language Design and Implementation, Tucson, AZ, USA, June 7-13,
2008, pp. 159–169 (2008). DOI 10.1145/1375581.1375602

30

Yuki Nishida et al.

17. Ro¸su, G., ¸Serb˘anut˘a, T.F.: An overview of the K semantic framework. The Journal of Logic and

Algebraic Programming 79(6), 397–434 (2010). DOI 10.1016/j.jlap.2010.03.012

18. Siegel, D.: Understanding the DAO attack. CoinDesk (2016). URL https://www.coindesk.com/

understanding-dao-hack-journalists. Retrieved Oct. 13, 2020.

19. Szabo, N.: Formalizing and securing relationships on public networks. First Monday 2(9) (1997).

DOI 10.5210/fm.v2i9.548

20. Terauchi, T.: Dependent types from counterexamples. In: Proceedings of the 37th ACM SIGPLAN-
SIGACT Symposium on Principles of Programming Languages, POPL 2010, Madrid, Spain, January
17-23, 2010, pp. 119–130 (2010). DOI 10.1145/1706299.1706315

21. The Coq development team: The coq proof assistant reference manual (2020). URL http://coq.

inria.fr. Version 8.12.0

22. Unno, H., Kobayashi, N.: Dependent type inference with interpolants. In: Proceedings of the 11th
International ACM SIGPLAN Conference on Principles and Practice of Declarative Programming,
September 7-9, 2009, Coimbra, Portugal, pp. 277–288 (2009). DOI 10.1145/1599410.1599445
23. Vazou, N., Seidel, E.L., Jhala, R., Vytiniotis, D., Jones, S.L.P.: Reﬁnement types for Haskell. In:
Proceedings of the 19th ACM SIGPLAN international conference on Functional programming, Gothen-
burg, Sweden, September 1-3, 2014, pp. 269–282. ACM (2014). DOI 10.1145/2628136.2628161
24. Xi, H.: Dependent ML an approach to practical programming with dependent types. J. Funct. Program.

17(2), 215–286 (2007). DOI 10.1017/S0956796806006216

25. Xi, H., Harper, R.: A dependently typed assembly language. In: Proceedings of the Sixth ACM
SIGPLAN International Conference on Functional Programming (ICFP ’01), Firenze (Florence), Italy,
September 3-5, 2001, pp. 169–180. ACM (2001). DOI 10.1145/507635.507657

26. Zhu, H., Jagannathan, S.: Compositional and lightweight dependent type inference for ML.

In:
Veriﬁcation, Model Checking, and Abstract Interpretation, 14th International Conference, VMCAI
2013, Rome, Italy, January 20-22, 2013. Proceedings, pp. 295–314 (2013). DOI 10.1007/978-3-642-
35873-9_19

A Proof of Soundness

This Appendix is only for reviewing. If this is accepted, we will remove it, upload a preprint version with the
proof to arXiv. The article will refer to the preprint version.

We prove our main theorem (Theorem 16), whose ﬁrst item is Theorem 9. The proof is close to a proof
of soundness of Hoare logic, with a few extra complications due to the presence of ﬁrst-class functions. We
ﬁrst prove a few lemmas related to LOOP (Lemma 11), ITER (Lemma 12), predicate call (Lemmas 13 and
14), and subtyping (Lemma 15). We often use Theorem 8 implicitly.

Lemma 11. Suppose IS satisﬁes

S1 (cid:96) IS ⇓ S2 and σ : Γ |= S1 : {ϒ | ∃ x:int.ϕ ∧ x (cid:54)= 0} imply σ : Γ |= S2 : {x:int (cid:46)ϒ | ϕ}

(H.1)

for any S1 and S2. If

S1 (cid:96) LOOP IS ⇓ S2
σ : Γ |= S1 : {x:int (cid:46)ϒ | ϕ}

(H.2)

(H.3)

then σ : Γ |= S2 : {ϒ | ∃ x:int.ϕ ∧ x = 0}.

Proof. By induction on the derivation of (H.2). We conduct the last rule that derives (H.2), which is either
(E-LOOPT) or (E-LOOPF).

Case (E-LOOPT). We have

S1 = i (cid:46) S
i (cid:54)= 0
S (cid:96) IS ⇓ S(cid:48)
S(cid:48) (cid:96) LOOP IS ⇓ S2.

(H.4)

(H.5)

(H.6)

(H.7)

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

31

From (H.4), (H.5), and (H.3), we have

From (H.1), we have σ : Γ |= S(cid:48) : {x:int (cid:46)ϒ | ϕ}. Then, the goal from (H.7), (H.8), and IH.

σ : Γ |= S : {ϒ | ∃ x:int.ϕ ∧ x (cid:54)= 0}

(H.8)

Case (E-LOOPF). We have S1 = 0 (cid:46) S2. The goal σ : Γ |= S2 : {ϒ | ∃ x:int.ϕ ∧ x = 0} follows from

Lemma 10 and (H.3).

Lemma 12. Suppose

Suppose also that

x1 /∈ fvars(ϕ)
x2 /∈ fvars(ϕ)

1 (cid:96) IS ⇓ S(cid:48)
S(cid:48)

2 and σ (cid:48) : Γ , x2:T list |= S(cid:48)
σ (cid:48) : Γ , x2:T list |= S(cid:48)

1 : {x1:T (cid:46)ϒ | ∃ x:T list.ϕ ∧ x1 :: x2 = x} imply
2 : {ϒ | ∃ x:T list.ϕ ∧ x2 = x}

for any S(cid:48)

1, S(cid:48)

2, and σ (cid:48). If

S1 (cid:96) ITER IS ⇓ S2
σ : Γ |= S1 : {x:T list (cid:46)ϒ | ϕ}

(H.1)

(H.2)

(H.3)

(H.4)

(H.5)

then σ : Γ |= S2 : {ϒ | ∃ x:T list.ϕ ∧ x = []}.

Proof. By induction on the derivation of (H.4). We conduct case analysis on the last rule that derives (H.4),
which is either (E-ITERNIL) or (E-ITERCONS).
Case (E-ITERNIL). We have

The goal follows from Lemma 10 and (H.5).

Case (E-ITERCONS). We have

S1 = [] (cid:46) S2.

S1 = V1 :: V2 (cid:46) S
V1 (cid:46) S (cid:96) IS ⇓ S(cid:48)
V2 (cid:46) S(cid:48) (cid:96) ITER IS ⇓ S2.

Therefore, from (H.7), (H.5), and Lemma 10, we have

σ : Γ |= S : {ϒ | ∃ x:T list.ϕ ∧ x = V1 :: V2}.

(H.6)

(H.7)

(H.8)

(H.9)

(H.10)

Therefore, we have σ : Γ |= S : {ϒ | ∃ x:T list, x1:T, x2:T list.ϕ ∧ x = x1 :: x2 ∧ x1 = V1 ∧ x2 = V2}
and hence

σ [x2 (cid:55)→ V2] : Γ , x2:T list |= V1 (cid:46) S : {x1:T (cid:46)ϒ | ∃ x:T list.ϕ ∧ x = x1 :: x2}

(H.11)

From (H.3) and (H.8), we have

σ [x2 (cid:55)→ V2] : Γ , x2:T list |= S(cid:48) : {ϒ | ∃ x:T list.ϕ ∧ x = x2}.

From Lemma 10, we have

σ : Γ |= V2 (cid:46) S(cid:48) : {x2:T list (cid:46)ϒ | ∃ x:T list.ϕ ∧ x = x2}.

Knowing (H.2), we have

from (H.13). Now the goal follows from IH, (H.8), and (H.14).

σ : Γ |= V2 (cid:46) S(cid:48) : {x:T list (cid:46)ϒ | ϕ}

(H.12)

(H.13)

(H.14)

32

Lemma 13. If








y1 (cid:54)= y2
y(cid:48)
1:T1, y1:T1 (cid:96) ϕ1 : ∗
y(cid:48)
1:T1, y2:T2 (cid:96) ϕ2 : ∗
(cid:104)IS(cid:105) : T1 → T2

For any V1,V2, σ ,

if V1 (cid:46) ‡ (cid:96) IS ⇓ V2 (cid:46) ‡ and

σ : y(cid:48)
then σ : y(cid:48)

1:T1 |= V1 (cid:46) ‡ : {y1:T1 (cid:46) ‡ | y(cid:48)
1:T1 |= V2 (cid:46) ‡ : {y2:T2 (cid:46) ‡ | ϕ2}

1 = y1 ∧ ϕ1}








then Γ |= ∀ y(cid:48)

1:T1, y1:T1, y2:T2.y(cid:48)

1 = y1 ∧ ϕ1 ∧ call((cid:104)IS(cid:105), y(cid:48)

1) = y2 =⇒ ϕ2 for any Γ .

Proof. By the deﬁnition of the semantics of call.

Lemma 14. If

V1 (cid:46) ‡ (cid:96) IS ⇓ V2 (cid:46) ‡
V1 : T1
V2 : T2
(cid:104)IS(cid:105) : T1 → T2

then Γ |= call((cid:104)IS(cid:105),V1) = V2 for any Γ .

Proof. By the deﬁnition of the semantics of call.

Lemma 15. If

Γ (cid:96) Φ1 <: Φ2
σ : Γ |= S : Φ1

then σ : Γ |= S : Φ2.

Proof. Straightforward from Deﬁnition 4.

Theorem 16 (Soundness). The following two statements hold.

(1) If

then σ : Γ |= S2 : Φ2.

(2) If

Γ (cid:96) Φ1 IS Φ2
S1 (cid:96) IS ⇓ S2
σ : Γ |= S1 : Φ1

Γ (cid:96) Φ1 I Φ2
S1 (cid:96) I ⇓ S2
σ : Γ |= S1 : Φ1

Yuki Nishida et al.

(H.1)

(H.2)

(H.3)

(H.4)

(H.5)

(H.1)

(H.2)

(H.3)

(H.4)

(H.1)

(H.2)

(H.1)

(H.2)

(H.3)

(H.4)

(H.5)

(H.6)

then σ : Γ |= S2 : Φ2.

Proof. The proof is done by mutual induction on the given derivation of (H.1) and (H.4).

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

33

Case (RT-NOP). We have IS = {} and Φ1 = Φ2. The last rule that is used to derive (H.2) is (E-NOP).

Therefore, we have S1 = S2, which is followed by (H.3).

Case (RT-SEQ). We have

IS = {I(cid:48); IS(cid:48)}
Γ (cid:96) Φ1 I(cid:48) Φ (cid:48)
Γ (cid:96) Φ (cid:48) IS(cid:48) Φ2

for some I(cid:48), IS(cid:48), and Φ (cid:48). The last rule that derives (H.2) is (E-SEQ). Therefore, we have

for some S(cid:48). Now we have

S1 (cid:96) I(cid:48) ⇓ S(cid:48)
S(cid:48) (cid:96) IS(cid:48) ⇓ S2

σ : Γ |= S(cid:48) : Φ (cid:48)

(H.7)

(H.8)

(H.9)

(H.10)

(H.11)

(H.12)

by applying IH to (H.8), (H.10) and (H.3). Then, the goal follows by applying IH to (H.9), (H.11) and
(H.12).

Case (RT-DIP). We have

I = DIP IS
Φ1 = {x:T (cid:46)ϒ | ϕ}
Φ2 = {x:T (cid:46)ϒ (cid:48) | ϕ (cid:48)}
Γ , x:T (cid:96) {ϒ | ϕ} IS {ϒ (cid:48) | ϕ (cid:48)}

(H.13)

(H.14)

(H.15)

(H.16)

for some IS, x, T , ϒ , ϒ (cid:48), ϕ, and ϕ (cid:48). The last rule that derives (H.5) is (E-DIP). Therefore, we have

S1 = V (cid:46) S(cid:48)
1
S2 = V (cid:46) S(cid:48)
2
1 (cid:96) IS ⇓ S(cid:48)
S(cid:48)
2

for some V , S(cid:48)

1, and S(cid:48)

2. By Lemma 10, we have

σ [x (cid:55)→ V ] : Γ , x:T |= S(cid:48)

1 : {ϒ | ϕ}

from (H.6), (H.14), and (H.17). By applying IH to (H.16), (H.19), and (H.20), we have

Therefore, σ : Γ |= V (cid:46) S(cid:48)

2 : {x:T (cid:46)ϒ (cid:48) | ϕ (cid:48)} follows from (SEM-PUSH) and (H.21).

σ [x (cid:55)→ V ] : Γ , x:T |= S(cid:48)

2 : {ϒ (cid:48) | ϕ (cid:48)}.

Case (RT-DROP). We have

I = DROP
Φ1 = {x:T (cid:46)ϒ | ϕ}
Φ2 = {ϒ | ∃ x:T.ϕ}

for some x, T , ϒ , and ϕ. The last rule that derives (H.5) is (E-DROP). Therefore, we have

S1 = V (cid:46) S2

(H.17)

(H.18)

(H.19)

(H.20)

(H.21)

(H.22)

(H.23)

(H.24)

(H.25)

for some V . From (H.6), (H.25), and Lemma 10, we have σ : Γ |= S2 : {ϒ | ∃ x:T.ϕ ∧ x = V } and hence
σ : Γ |= S2 : {ϒ | ∃ x:T.ϕ} as required.

34

Yuki Nishida et al.

Case (RT-DUP). We have

I = DUP
Φ1 = {x:T (cid:46)ϒ | ϕ}
Φ2 = {x(cid:48):T (cid:46) x:T (cid:46)ϒ | ϕ ∧ x(cid:48) = x}
x(cid:48) /∈ dom(Γ , (cid:92)x:T (cid:46)ϒ )

for some x, x(cid:48), T , ϒ , and ϕ. The last rule that derives (H.5) is (E-DUP). Therefore, we have

S1 = V (cid:46) S
S2 = V (cid:46)V (cid:46) S

(H.26)

(H.27)

(H.28)

(H.29)

(H.30)

(H.31)

for some V and S. By (H.6), we have σ [x (cid:55)→ V ] : Γ , x:T |= S : {ϒ | ϕ} and hence σ [x (cid:55)→ V ][x(cid:48) (cid:55)→ V ] : Γ , x:
T, x(cid:48):T |= S : {ϒ | ϕ}. Since σ [x (cid:55)→ V ][x(cid:48) (cid:55)→ V ] : Γ , x:T, x(cid:48):T |= ϕ =⇒ (ϕ ∧ x = x(cid:48)), we have σ [x (cid:55)→
V ][x(cid:48) (cid:55)→ V ] : Γ , x:T, x(cid:48):T |= S : {ϒ | ϕ ∧ x = x(cid:48)}. Therefore, we have σ : Γ |= S2 : {ϒ | ϕ ∧ x = x(cid:48)} as
required.

Case (RT-SWAP). We have

I = SWAP
Φ1 = {x:T (cid:46) x(cid:48):T (cid:46)ϒ | ϕ}
Φ2 = {x(cid:48):T (cid:46) x:T (cid:46)ϒ | ϕ}

for some x, x(cid:48), T , ϒ , and ϕ. The last rule that derives (H.5) is (E-SWAP). Therefore, we have

S1 = V (cid:46)V (cid:48) (cid:46) S
S2 = V (cid:48) (cid:46)V (cid:46) S

(H.32)

(H.33)

(H.34)

(H.35)

(H.36)

for some V , V (cid:48), and S. By (H.6), we have σ [x (cid:55)→ V ][x(cid:48) (cid:55)→ V (cid:48)] : Γ , x:T, x(cid:48):T |= S : {ϒ | ϕ}. Since x (cid:54)= x(cid:48),
we have σ [x(cid:48) (cid:55)→ V (cid:48)][x (cid:55)→ V ] : Γ , x(cid:48):T, x:T |= S : {ϒ | ϕ}. Therefore, we have σ : Γ |= S2 : {ϒ | ϕ}.

Case (RT-PUSH). We have

I = PUSH T V
Φ1 = {ϒ | ϕ}
Φ2 = {x:T (cid:46)ϒ | ϕ ∧ x = V }
V : T

x /∈ dom(Γ , (cid:98)ϒ )

for some x, T , ϒ , ϕ, and V . The last rule that derives (H.6) is (E-PUSH). Therefore, we have

S2 = V (cid:46) S1.

(H.37)

(H.38)

(H.39)

(H.40)

(H.41)

(H.42)

To show σ : Γ |= S2 : {x:T (cid:46)ϒ | ϕ ∧ x = V }, it sufﬁces to show σ [x (cid:55)→ V ] : Γ , x:T |= S1 : {ϒ | ϕ ∧ x = V }
from (SEM-PUSH), which follows from σ : Γ |= S1 : {ϒ | ϕ}, (H.41), and σ [x (cid:55)→ V ] : Γ , x:T |= ϕ =⇒
(ϕ ∧ x = V ).

Case (RT-NOT). We have

I = NOT
Φ1 = {x:int (cid:46)ϒ | ϕ}
Φ2 = {x(cid:48):int (cid:46)ϒ | ∃ x:int.ϕ ∧ (x (cid:54)= 0 ∧ x(cid:48) = 0 ∨ x = 0 ∧ x(cid:48) = 1)}
x(cid:48) /∈ dom(Γ , (cid:92)x:int (cid:46)ϒ )

(H.43)

(H.44)

(H.45)

(H.46)

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

35

for some x, ϒ , and ϕ. The last rule that derives (H.5) is either (E-NOTT) or (E-NOTF). We only show
the case of (E-NOTT); (E-NOTF) is similar. In this case, we have

S1 = i (cid:46) S
i (cid:54)= 0
S2 = 0 (cid:46) S.

for some i and S. By (H.6), we have

From Lemma 10, we have

σ [x (cid:55)→ i] : Γ , x:T |= S : {ϒ | ϕ}.

σ : Γ |= S : {ϒ | ∃ x:T.ϕ ∧ x = i}.

(H.47)

(H.48)

(H.49)

(H.50)

(H.51)

From i (cid:54)= 0, we have σ : Γ |= S : {ϒ | ∃ x:T.ϕ ∧ x (cid:54)= 0}. From (H.46), we have σ [x(cid:48) (cid:55)→ 0] : Γ , x(cid:48):T |=
S : {ϒ | ∃ x:T.ϕ ∧ x (cid:54)= 0}. From σ [x(cid:48) (cid:55)→ 0] : Γ , x(cid:48):T |= (∃ x:T.ϕ ∧ x (cid:54)= 0) =⇒ (∃ x:T.ϕ ∧ x (cid:54)= 0 ∧ x(cid:48) = 0),
we have σ [x(cid:48) (cid:55)→ 0] : Γ , x(cid:48):T |= S : {ϒ | ∃ x:T.ϕ ∧ x (cid:54)= 0 ∧ x(cid:48) = 0}. Therefore, we have σ : Γ |= 0 (cid:46) S : {x(cid:48):
T (cid:46)ϒ | ∃ x:T.ϕ ∧ x (cid:54)= 0 ∧ x(cid:48) = 0}, which is followed by σ : Γ |= 0 (cid:46) S : {x(cid:48):T (cid:46)ϒ | ∃ x:T.ϕ ∧ ((x (cid:54)= 0 ∧ x(cid:48) =
0) ∨ (x = 0 ∧ x(cid:48) (cid:54)= 1))} as required.

Case (RT-ADD). We have We have

I = ADD
Φ1 = {x1:int (cid:46) x2:int (cid:46)ϒ | ϕ}
Φ2 = {x3:int (cid:46)ϒ | ∃ x1:int, x2:int.ϕ ∧ x1 + x2 = x3}
x3 /∈ dom(Γ , (cid:92)x1:int (cid:46) x2:int (cid:46)ϒ )

for some x1, x2, x3, ϒ , and ϕ. The last rule that derives (H.5) is (E-ADD). Therefore,

S1 = i1 (cid:46) i2 (cid:46) S
S2 = i3 (cid:46) S
i1 + i2 = i3

for some i1, i2, i3, and S. By (H.6), we have

σ [x1 (cid:55)→ i1][x2 (cid:55)→ i2] : Γ , x1:int, x2:int |= S : {ϒ | ϕ}.

From (H.55), we have

(H.52)

(H.53)

(H.54)

(H.55)

(H.56)

(H.57)

(H.58)

(H.59)

σ [x1 (cid:55)→ i1][x2 (cid:55)→ i2][x3 (cid:55)→ i3] : Γ , x1:int, x2:int, x3:int |= S : {ϒ | ϕ}.

(H.60)

From σ [x1 (cid:55)→ i1][x2 (cid:55)→ i2][x3 (cid:55)→ i3] : Γ , x1:int, x2:int, x3:int |= ϕ =⇒ ϕ ∧ x1 + x2 = x3, we have

σ [x1 (cid:55)→ i1][x2 (cid:55)→ i2][x3 (cid:55)→ i3] : Γ , x1:int, x2:int, x3:int |= S : {ϒ | ϕ ∧ x1 + x2 = x3}.

(H.61)

and therefore σ [x1 (cid:55)→ i1][x2 (cid:55)→ i2] : Γ , x1:int, x2:int |= i3 (cid:46) S : {x3:int (cid:46) ϒ | ϕ ∧ x1 + x2 = x3}. By
Lemma 10, we have σ : Γ |= i3 (cid:46) S : {x3:int (cid:46)ϒ | ∃ x1:int, x2:int.ϕ ∧ x1 + x2 = x3} as required.

Case (RT-PAIR). Similar to the case for (RT-ADD).

Case (RT-CAR). We have

I = CAR
Φ1 = {x:T1 × T2 (cid:46)ϒ | ϕ}
Φ2 = {x1:T1 (cid:46)ϒ | ∃ x:T1 × T2, x2:T2.ϕ ∧ x = (x1, x2)}
x1 (cid:54)= x2
x1 /∈ dom(Γ , (cid:92)x:T1 × T2 (cid:46)ϒ )
x2 /∈ dom(Γ , (cid:92)x:T1 × T2 (cid:46)ϒ )

(H.62)

(H.63)

(H.64)

(H.65)

(H.66)

(H.67)

36

Yuki Nishida et al.

for some x, x1, x2, T1, T2, ϒ , and ϕ. The last rule that derives (H.5) is (E-CAR). Therefore,

S1 = (V1,V2) (cid:46) S
S2 = V1 (cid:46) S

for some V1, V2, and S. By (H.6), we have

σ [x (cid:55)→ (V1,V2)] : Γ , x:T1 × T2 |= S : {ϒ | ϕ}

and hence

σ : Γ |= S : {ϒ | ∃ x:T1 × T2.ϕ ∧ x = (V1,V2)}.

(H.68)

(H.69)

(H.70)

(H.71)

σ : Γ |= S : {ϒ | ∃ x:T1 × T2.ϕ ∧ x = (V1,V2)} implies σ : Γ |= S : {ϒ | ∃ x:T1 × T2, x1:T1, x2:T2.ϕ ∧ x =
(x1, x2) ∧ x1 = V1 ∧ x2 = V2}. Therefore, σ : Γ |= S : {ϒ | ∃ x1:T1.(∃ x:T1 × T2, x2:T2.ϕ) ∧ x1 = V1}, which
implies σ : Γ |= V1 (cid:46) S : {ϒ | ∃ x:T1 × T2, x2:T2.ϕ} as required.

Case (RT-CDR). Similar to the case for (RT-CAR).

Case (RT-NIL). Similar to the case for (RT-PUSH).

Case (RT-CONS). Similar to the case for (RT-PAIR).

Case (RT-IF). We have

I = IF IS1 IS2
Φ1 = {x:int (cid:46)ϒ | ϕ}
Γ (cid:96) {ϒ | ∃ x:int.ϕ ∧ x (cid:54)= 0} IS1 Φ2
Γ (cid:96) {ϒ | ∃ x:int.ϕ ∧ x = 0} IS2 Φ2

(H.72)

(H.73)

(H.74)

(H.75)

for some IS1, IS2, x, ϒ , and ϕ. The last rule that derives (H.5) is (E-IFT) or (E-IFF). We conduct case
analysis.
SCase (E-IFT). For some i and S,

i (cid:54)= 0
S1 = i (cid:46) S
S (cid:96) IS1 ⇓ S2.

From (H.6), (H.73), (H.77), and Lemma 10, we have

From (H.76), we have

σ : Γ |= S : {ϒ | ∃ x:int.ϕ ∧ x = i}.

σ : Γ |= S : {ϒ | ∃ x:int.ϕ ∧ x (cid:54)= 0}.

Then, the goal follows From IH and (H.74).

SCase (E-IFF). Similar to the case for (E-IFT).

Case (RT-LOOP). We have

I = LOOP IS
Φ1 = {x:int (cid:46)ϒ | ϕ}
Φ2 = {ϒ | ∃ x:int.ϕ ∧ x = 0}
Γ (cid:96) {ϒ | ∃ x:int.ϕ ∧ x (cid:54)= 0} IS {x:int (cid:46)ϒ | ϕ}
S1 = i (cid:46) S

(H.76)

(H.77)

(H.78)

(H.79)

(H.80)

(H.81)

(H.82)

(H.83)

(H.84)

(H.85)

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

37

for some IS, x, ϒ , S, and ϕ. By IH and (H.84), we have

For any S(cid:48)

1, S(cid:48)

2, if S(cid:48)

1 (cid:96) IS ⇓ S(cid:48)

2 and σ : Γ |= S(cid:48)

1 : {ϒ | ∃ x:int.ϕ ∧ x (cid:54)= 0},
then σ : Γ |= S(cid:48)

2 : {x:int (cid:46)ϒ | ϕ}.

Then, the goal follows from Lemma 11, (H.5), (H.6), (H.81), (H.82) and (H.86).

Case (RT-IFCONS). Similar to the case for (RT-IF).

Case (RT-ITER). We have

I = ITER IS
Φ1 = {x:T list (cid:46)ϒ | ϕ}
Φ2 = {ϒ | ∃ x:T list.ϕ ∧ x = []}

Γ , x2:T list (cid:96) {x1:T (cid:46)ϒ | ∃ x:T list.ϕ ∧ x1 :: x2 = x} IS {ϒ | ∃ x:T list.ϕ ∧ x2 = x}

x1 (cid:54)= x2
x1 /∈ dom(Γ , (cid:92)x:T list (cid:46)ϒ )
x2 /∈ dom(Γ , (cid:92)x:T list (cid:46)ϒ )

for some IS, x, x1, x2, T , ϒ , and ϕ. From IH and (H.90), we have

(H.86)

(H.87)

(H.88)

(H.89)

(H.90)

(H.91)

(H.92)

(H.93)

For any S(cid:48)

1, S(cid:48)

2, σ (cid:48), if S(cid:48)

1 (cid:96) IS ⇓ S(cid:48)

2 and σ (cid:48) : Γ , x2:T list |= S(cid:48)
then σ (cid:48) : Γ , x2:T list |= S(cid:48)

1 : {x1:T (cid:46)ϒ | ∃ x:T list.ϕ ∧x1 :: x2 = x},
2 : {ϒ | ∃ x:T list.ϕ ∧ x2 = x}.
(H.94)

Then, the goal follows from Lemma 12. (H.93), and (H.94).

Case (RT-LAMBDA). Since the last rule that derive (H.5) is (E-LAMBDA), we have

I = LAMBDA T1 T2 IS
Φ1 = {ϒ | ϕ}

Φ2 = {x:T1 → T2 (cid:46)ϒ | ϕ ∧ ∀ y(cid:48)

1:T1, y1:T1, y2:T2.y(cid:48)

1:T1 (cid:96) {y1:T1 (cid:46) ‡ | y(cid:48)
y(cid:48)

1 = y1 ∧ ϕ1 ∧ call(x, y(cid:48)
1 = y1 ∧ ϕ1} IS {y2:T2 (cid:46) ‡ | ϕ2}

1) = y2 =⇒ ϕ2}

x /∈ dom(Γ , (cid:98)ϒ ) ∪ {y1, y(cid:48)

1, y2}

y1 (cid:54)= y(cid:48)
1
y(cid:48)
1:T1, y1:T1 (cid:96) ϕ1 : ∗
S2 = (cid:104)IS(cid:105) (cid:46) S1

for some IS, x, y1, y(cid:48)

1, y2, T1, T2, ϒ , ϕ, ϕ1, and ϕ2. From IH and (H.98), we have

For any V1,V2, σ , if V1 (cid:46) ‡ (cid:96) IS ⇓ V2 (cid:46) ‡ and σ : y(cid:48)

1:T1 |= V1 (cid:46) ‡ : {y1:T1 (cid:46) ‡ | y(cid:48)
then σ : y(cid:48)

1 = y1 ∧ ϕ1},
1:T1 |= V2 (cid:46) ‡ : {y2:T2 (cid:46) ‡ | ϕ2}.

By Lemma 13, (H.100), (H.101), (H.103), (H.91), and (H.92), we have

Γ , (cid:98)ϒ |= ∀ y(cid:48)

1:T1, y1:T1, y2:T2.y(cid:48)

1 = y1 ∧ ϕ1 ∧ call((cid:104)IS(cid:105), y(cid:48)

1) = y2 =⇒ ϕ2

and hence, from (H.6), (H.96), and (H.104), we have

σ : Γ |= S1 : {ϒ | ϕ ∧ ∀ y(cid:48)

1:T1, y1:T1, y2:T2.y(cid:48)

1 = y1 ∧ ϕ1 ∧ call((cid:104)IS(cid:105), y(cid:48)

1) = y2 =⇒ ϕ2}.

By (H.99), and (H.105), we have

σ : Γ |= S1 : {ϒ | ∃ x:T1 → T2.(ϕ ∧
∀ y(cid:48)

1:T1, y1:T1, y2:T2.y(cid:48)

1 = y1 ∧ ϕ1 ∧ call(x, y(cid:48)

1) = y2 =⇒ ϕ2) ∧ x = (cid:104)IS(cid:105)}.

(H.95)

(H.96)

(H.97)

(H.98)

(H.99)

(H.100)

(H.101)

(H.102)

(H.103)

(H.104)

(H.105)

(H.106)

38

Yuki Nishida et al.

Therefore, from Lemma 10 and (H.106), we have

σ : Γ |= (cid:104)IS(cid:105) (cid:46) S1 : {x:T1 → T2 (cid:46)ϒ | ϕ ∧
∀ y(cid:48)

1:T1, y1:T1, y2:T2.y(cid:48)

1 = y1 ∧ ϕ1 ∧ call(x, y(cid:48)

1) = y2 =⇒ ϕ2}

as required.

Case (RT-EXEC). We have

I = EXEC
Φ1 = {x1:T1 (cid:46) x2:T1 → T2 (cid:46)ϒ | ϕ}
Φ2 = {x3:T2 (cid:46)ϒ | ∃ x1:T1, x2:T1 → T2.ϕ ∧ call(x2, x1) = x3}
x3 /∈ dom(Γ , (cid:92)x1:T1 (cid:46) x2:T1 → T2 (cid:46)ϒ )

(H.107)

(H.108)

(H.109)

(H.110)

for some x1, x2, x3, T1, T2, ϒ , and ϕ. Since the last rule that derives (H.5) is (E-EXEC), we have

S1 = V1 (cid:46) (cid:104)IS(cid:105) (cid:46) S
S2 = V2 (cid:46) S
V1 (cid:46) ‡ (cid:96) IS ⇓ V2 (cid:46) ‡

(H.111)

(H.112)

(H.113)

for some V1, V2, IS, and S. By (H.6), (H.108), and (H.111), we have

σ : Γ |= S : {ϒ | ∃ x2:T1 → T2.(∃ x1:T1.ϕ ∧ x1 = V1) ∧ x2 = (cid:104)IS(cid:105)}.

(H.114)

By Lemma 14, (H.113), (H.105), and (H.51), we have

Γ , (cid:98)ϒ |= call((cid:104)IS(cid:105),V1) = V2.

(H.115)

Therefore, from (H.114), and (H.115), we have

σ : Γ |= S : {ϒ | (∃ x2:T1 → T2.(∃ x1:T1.ϕ ∧ x1 = V1) ∧ x2 = (cid:104)IS(cid:105)) ∧ call((cid:104)IS(cid:105),V1) = V2}.

(H.116)

From (H.110) and (H.116), we have σ : Γ |= S : {ϒ | ∃ x3:T2.(∃ x1:T1, x2:T1 → T2.ϕ ∧ call(x2, x1) =
x3) ∧ x3 = V2} and hence σ : Γ |= V2 (cid:46) S : {x3:T2 (cid:46)ϒ | (∃ x1:T1, x2:T1 → T2.ϕ ∧ call(x2, x1) = x3)} as
required.

Case (RT-TRANSFERTOKENS). We have

I = TRANSFER_TOKENS T
Φ1 = {x1:T (cid:46) x2:int (cid:46) x3:address (cid:46)ϒ | ϕ}

Φ2 = {x4:operation (cid:46)ϒ | ∃ x1:T, x2:int, x3:address.ϕ ∧ x4 = Transfer(x1, x2, x3)}

x4 /∈ dom(Γ ,

(cid:92)x1:T (cid:46) x2:int (cid:46) x3:address (cid:46)ϒ )

(H.117)

(H.118)

(H.119)

(H.120)

for some x1, x2, x3, x4, T , ϒ , and ϕ. The last rule that derives (H.5) is (E-TRANSFERTOKENS); therefore

S1 = V (cid:46) i (cid:46) a (cid:46) S
S2 = Transfer(V, i, a) (cid:46) S

(H.121)

(H.122)

for some V , i, a, and S. By (H.6), (H.118), and (H.121), we have

σ : Γ |= S : {ϒ | ∃ x3:address.(∃ x2:int.(∃ x1:T.ϕ ∧ x1 = V ) ∧ x2 = i) ∧ x3 = a}.

(H.123)

By (H.120) and (H.123), we have

σ : Γ |= S : {ϒ | ∃ x4:operation.(∃ x1:T, x2:int, x3:address.ϕ ∧

x4 = Transfer(x1, x2, x3)) ∧ x4 = Transfer(V, i, a)}.

(H.124)

HELMHOLTZ: A Veriﬁer for Tezos Smart Contracts Based on Reﬁnement Types

39

Therefore, we have

σ : Γ |= Transfer(V, i, a) (cid:46) S : {x4:operation (cid:46)ϒ | (∃ x1:T, x2:int, x3:address.ϕ ∧

x4 = Transfer(x1, x2, x3))}

as required.

Case (RT-SUB). We have

Γ (cid:96) Φ1 <: Φ (cid:48)
1
Γ (cid:96) Φ (cid:48)
2 <: Φ2
1 I Φ (cid:48)
Γ (cid:96) Φ (cid:48)
2

for some Φ (cid:48)

1 and Φ (cid:48)

2. By Lemma 15, (H.6), and (H.125), we have

σ : Γ |= S1 : Φ (cid:48)
1.

By IH, (H.127), (H.5), and (H.128), we have

σ : Γ |= S2 : Φ (cid:48)
2.

Then, the goal follows from Lemma 15.

(H.125)

(H.126)

(H.127)

(H.128)

(H.129)

