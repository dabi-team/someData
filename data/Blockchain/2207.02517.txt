2
2
0
2

l
u
J

6

]

R
C
.
s
c
[

1
v
7
1
5
2
0
.
7
0
2
2
:
v
i
X
r
a

Transaction Monitoring of Smart Contracts

Margarita Capretto1,2

, Martin Ceresa1

, and C´esar S´anchez1

1 IMDEA Software Institute, Spain
2 Universidad Polit´ecnica de Madrid (UPM), Madrid, Spain

Abstract. Blockchains are modern distributed systems that provide de-
centralized ﬁnancial capabilities with trustable guarantees. Smart con-
tracts are programs written in specialized programming languages run-
ning on a blockchain and govern how tokens and cryptocurrency are
sent and received. Smart contracts can invoke other contracts during the
execution of transactions initiated by external users.
Once deployed, smart contracts cannot be modiﬁed and their pitfalls can
cause malfunctions and losses, for example by attacks from malicious
users. Runtime veriﬁcation is a very appealing technique to improve the
reliability of smart contracts. One approach consists of specifying unde-
sired executions (never claims) and detecting violations of the speciﬁ-
cation on the ﬂy. This can be done by extending smart contracts with
additional instructions corresponding to monitor speciﬁed properties, re-
sulting in an onchain monitoring approach.
In this paper, we study transaction monitoring that consists of detect-
ing violations of complete transaction executions and not of individual
operations within transactions. Our main contributions are to show that
transaction monitoring is not possible in most blockchains and propose
diﬀerent execution mechanisms that would enable transaction monitor-
ing.

1

Introduction

Distributed ledgers (also known as blockchains) were ﬁrst proposed by Nakamoto
in 2009 [14] in the implementation of Bitcoin, as a method to eliminate trustable
third parties in electronic payment systems. Modern blockchains incorporate
smart contracts [22,23], which are state-full programs stored in the blockchain
that describe the functionality of blockchain transactions, including the exchange
of cryptocurrency. Smart contracts allow us to describe sophisticated function-
ality enabling many applications in decentralized ﬁnances (DeFi), decentralized
governance, Web3, etc.

Smart contracts are written in high-level programming languages for smart
contracts, like Solidity [2] and Ligo [4] which are then typically compiled into
low-level bytecode languages like EVM [23] or Michelson [1]. Even though smart
contracts are typically small compared to conventional software, writing smart
contracts has been proven to be notoriously diﬃcult. Apart from conventional
software runtime errors (like underﬂow and overﬂow), smart contracts also suﬀer

 
 
 
 
 
 
2

Capretto, Ceresa and S´anchez

from new attack patterns [17] or from attacks towards the blockchain infrastruc-
ture itself [18]. Smart contracts store and transfer money, and are openly exposed
to external users directly and through caller smart contracts. Once installed the
code of the contract is immutable and the eﬀect of running a contract cannot be
reverted (the contract is the law).

There are two classic approaches to achieve software reliability, and there are

attempts to apply them to smart contracts:

– static techniques using automatic techniques like static analysis [21] or
model checking [16], or deductive software veriﬁcation techniques [3,15,8,10],
theorem proving [7,5,19] or assisted formal construction of programs [20].
– dynamic veriﬁcation[11,6,13] attempting to dynamically inspect the exe-

cution of a contract against a correctness speciﬁcation.

In this paper, we follow a dynamic monitoring technique. Monitors are a de-
fensive mechanism where developers write properties that must hold during the
execution of the smart contracts. If a monitored property fails the whole trans-
action is aborted. Otherwise, the execution ﬁnishes normally as stipulated by
the code of the contract.

Most of the monitoring techniques inject the monitor into the smart contract
as additional instructions [11,6,13], which is called inline monitoring [12]. The
property to be monitored for a method of a given contract A is typically de-
scribed as two parts: Abegin , that runs at the beginning of each call, and Aend ,
which is checked at the end. This monitoring code can inspect the storage of con-
tract A and read and modify speciﬁc monitor variables. For example, monitors
can compare the balance at the beginning and end of the invocation. However,
monitors can only see the contents of A and cannot inspect or invoke other con-
tracts. We call these monitors operation monitors as they allow us to inspect a
single operation invocation. In this paper, we study a richer notion of monitoring
that can inspect information across the running transaction, illustrated by our
running example.

Running example: Flash Loans The aim of a ﬂash loan contract is to allow other
contracts to borrow balance without any collateral, provided that the borrowed
money is repaid in the same transaction (perhaps with some interest) [9]. A
simple way to specify the correctness of a ﬂash loan contract A is by the following
two informal properties:
FL-safety
FL-progress A request must be granted unless FL-safety is violated

No transaction can decrease the balance of A

Fig. 1(a) shows a simple smart contract attempting to implement a ﬂash
loan lender. Function lend checks that the lender contract has enough tokens
to provide the requested loan, saves the initial balance to check that the loan
has been repaid completely, and transfers the amount requested to the borrower.
Upon return, lend checks that the loan has been paid back.

Unfortunately, the lender smart contract in Fig. 1(a) does not fulﬁll property
FL-progress. Consider a client, for example Fig. 1(b), that borrows money from
diﬀerent lenders, then invests the borrowed money to obtain a proﬁt and ﬁnally

Transaction Monitoring of Smart Contracts

3

contract Lender {

function lend ( address payable dest , uint amount ) public {

require ( amount <= this . balance ) ;
uint initial_balance = this . balance ;
dest . transfer ( amount ) ;
assert ( this . balance >= initial_balance ) ;

}

}

(a) A ﬂash loan implementation attempt

contract Client {
Lender l1 , l2 ;
function borrowAndInvest () public {

l1 . lend (100) ; l2 . lend (200) ;
invest (300) ;
l1 . transfer (100) ; l2 . transfer (200) ;

}

}

(b) A ﬂash loan client

contract MaliciousClient {

Lender l ;
function borrowAndInvest () public {

l . lend (100) ;
invest (100) ;

}

}

(c) A malicious ﬂash loan client

Fig. 1. Pseudocode for contracts Lender, Client and MaliciousClient.

pays back to the lenders. In other words, the contract Client in Fig. 1(b) collects
all the money upfront before investing it and then pays back the lenders. The
contract Client will not successfully borrow from the lender in Fig. 1(a), be-
cause contract Lender expects to be paid back within the scope of method lend.
However, the contract Client exercises correctly FL-safety and FL-progress,
and returns the borrowed tokens before the transaction ﬁnishes. The problem
is that contract Lender is too defensive and only allows repayments within the
control ﬂow of function lend and not in arbitrary points within the enclosing
transaction. Alternatively, a lender contract could lend funds with the hope that
the client returns the loan before the end of the transaction, but then a malicious
contract, like in Fig. 1(c), would violate FL-safety easily. We cannot solve this
problem with operation monitors because it is not possible within the scope of
lend to successfully predict or guarantee whether the loan will be repaid within
the transaction.

In this article, we propose to extend monitors with two additional functions:
Ainit , which executes before the ﬁrst call to A in a given transaction; and Aterm ,

4

Capretto, Ceresa and S´anchez

contract Lender {

function lend ( address payable dest , uint amount ) public {

require ( amount <= this . balance ) ;
dest . transfer ( amount ) ;

}

} with monitor {

uint initial_balance ;
init { initial_balance = this . balance ; }
term { assert ( this . balance >= initial_balance ) ; }

}

Fig. 2. A correct ﬂash loan implementation using transaction monitors

which executes after the last call to A (equivalently, at the end of the trans-
action). As for Abegin and Aend , Ainit and Aterm have access to the storage
and can fail but cannot be called from other contracts or emit operations. We
call these monitors transaction monitors since they can check properties of the
whole transaction. With transaction monitors, we implement a lender contract
that satisﬁes FL-safety and FL-progress by saving the balance at the begin-
ning of a transaction in init and comparing it with the ﬁnal balance in term as
shown in Fig. 2.

As for future work, we envision even more sophisticated monitors that guar-
antee properties that involve two or more contracts—like checking that the com-
bined balance of A and B does not decrease—or even that predicating about all
contracts participating in a transac-
tion of the whole blockchain. We refer
to them as multicontract monitors and
global monitors, respectively, but they
are out of the scope of this paper, where
we focus on transaction monitors. Fig. 3
shows the monitoring hierarchy.

future work
Global monitors
Multicontract monitors future work
Transaction monitors
Operation Monitors

this paper
[6,11,13]

Fig. 3. Monitors hierarchy

In summary, the contributions of the paper are the following:
– The notion of transaction monitors and its formal deﬁnition.
– A proof that current blockchains cannot implement transaction monitors,

and a list of simple mechanisms that allow their implementation.

– An exhaustive study of how the proposed mechanisms interact with each
other and the basic building blocks to implement full-ﬂedged transaction
monitors.
The rest of the paper is organized as follows. Section 2 describes the model of
computation. Section 3 studies transaction monitors. Section 4 introduces new
execution mechanisms, and in Section 5, we study how these new mechanisms
implement transaction monitors. Finally, Section 6 concludes.

Transaction Monitoring of Smart Contracts

5

2 Model of Computation

We introduce now a general model of computation that captures the evolution
of smart contract blockchains.

An Informal Introduction. Blockchains are a public incremental record of the
executed transactions. Even though several transactions are packed in “blocks”—
which are totally ordered—, transactions within a block are also totally ordered.
Therefore, we can interpret blockchains as totally ordered sequences of transac-
tions.

Transactions are in turn composed of a sequence of operations where the
initial operation is an invocation from an external user. Each operation invokes
a destination contract (where contracts are identiﬁed by their unique address).
Operations also contain the name of the invoked method, arguments and balance
(in the cryptocurrency of the underlying blockchain), and an amount of gas3.
The execution of an operation follows the instructions of the program (the smart
contract) stored in the destination address.

Given the arguments and state of the blockchain, the code of every smart
contract is deterministic which makes the blockchain predictable and amenable
to validation. We model smart contracts as pure computable functions taking
their input arguments and the current local storage of the contract, and return-
ing (1) the changes to be performed in the local storage; (2) a list of further
operations to be executed. No eﬀect takes place in their local storage until the
end of the operation. This abstraction does not impose any restriction since ev-
ery imperative program can be split into a collection of basic pure code blocks
separated by the instructions with eﬀects.

The execution of a transaction consists of iteratively executing pending op-
erations, computing their eﬀects (including updating the pending operations)
until either (1) the queue of pending operations is empty, or (2) some operation
fails or the gas is exhausted. In the former case, the transaction commits and all
changes are made permanent. In the latter case, the transaction aborts and no
eﬀect takes place (except that some gas is consumed).

Model of Computation. We now formally model the state of a blockchain
during the execution of the operations forming a transaction. We represent a
blockchain conﬁguration as a pair (Σ, ∆) where:

Blockchain state Σ is a partial map between addresses and the storage and

balance of smart contracts,

Blockchain context ∆ contains additional information about the blockchain,
such as block number, current time, amount of money sent in the transaction,
etc.

3 The notion of gas is introduced to make all operations terminate because each indi-
vidual instruction consumes gas and once the initial operation is invoked no more
gas can be added to the transaction.

6

Capretto, Ceresa and S´anchez

Blockchain contexts may vary since diﬀerent blockchains carry diﬀerent informa-
tion, but either implicitly or explicitly, every blockchain maintains a blockchain
state. The computation of a successful transaction begins with an external op-
eration o from a conﬁguration (Σ, ∆) and either aborts or ﬁnishes into a ﬁnal
conﬁguration (Σ(cid:48), ∆(cid:48)).

We model a smart contract as a partial map A : ∆ × IP × S × IN (cid:42) (S × [O])
where IP is the set of all possible parameters of A, S the set of all possible
storage states, O the set of operations and [·] is a set operator representing lists
of elements of a given set. Smart contracts written in imperative languages with
eﬀects can be modeled as sequences of pure blocks where eﬀects happen at the
end in the standard way.

Operations. An operation is a record containing the following ﬁelds:

– dest the address to invoke;
– src the address initiating the operation;
– param parameters expected by the smart contract at address dest;
– money the amount of crypto-currency sent in the operation.

We use standard object notation to access each ﬁeld, so o.dest is the destination
address, o.src is the source address, o.param the parameters and o.money the
amount transferred.

Transactions. A transaction results from the execution of a sequence of op-
erations starting from an external operation placed by an external user. If an
operation fails the transaction fails and the blockchain state remains unchanged.
A successful operation o results in a new storage and a list of new operations ls.
The blockchain updates the storage of smart contract o.dest and balance of both
smart contracts o.dest and o.src generating a new blockchain conﬁguration and
the list ls is added to the current pending queue of operations. Operations are
executed one at a time modifying the blockchain conﬁguration until some opera-
tion fails or there is no more operations on the pending queue. In the second case,
the transaction is successful and the last blockchain conﬁguration consolidates.
We assume there is an implicit partial map from addresses to smart contracts
G : Addr (cid:42) SmartContract. Moreover, we assume map G does not change since
we assume that smart contracts cannot install new contracts.

Operation Execution. Let o be an operation and (Σ, ∆) a blockchain conﬁgura-
tion. The evaluation of o from (Σ, ∆) results in a new conﬁguration and a list
of operations ls, which we denote (Σ, ∆) o−→ (Σ(cid:48), ∆(cid:48), ls) whenever:
1. The source smart contract has enough balance, Σ(o.src) ≥ o.money
2. The invocation to the smart contract is successful:

G(o.dest)(∆, o.param, Σ(o.dst).st, Σ(o.dst).balance) = (st(cid:48), ls)

The new blockchain conﬁguration state Σ(cid:48) is the result of: 1) adding o.money
into the balance of o.dest and subtracting it from o.src, and 2) updating the stor-
age as Σ(cid:48)(o.dest).st = st(cid:48). Note that we leave the evolution of ∆ unspeciﬁed as it

Transaction Monitoring of Smart Contracts

7

is system dependant. In Section 5, we implement diﬀerent additional blockchain
features by inspecting (and possibly modifying) the blockchain context. For fail-

ing evaluation of operations, we use (Σ, ∆)

o
−×.

Execution Order. The execution can proceed in diﬀerent ways. We consider two
execution orders: new operations are added to the beginning of the pending
queue (a DFS strategy) and new operations added to the end of the pending
queue (a BFS strategy). This results in the following transition rules:

o
−×

(Σ, ∆)
(Σ, ∆, o :: os) (cid:54)(cid:32)a

(Σ, ∆) o−→ (Σ(cid:48), ∆(cid:48), ls)
(Σ, ∆, o :: os) (cid:32)dfs (Σ(cid:48), ∆(cid:48), ls ++ os)

(Σ, ∆) o−→ (Σ(cid:48), ∆(cid:48), ls)
(Σ, ∆, o :: os) (cid:32)bfs (Σ(cid:48), ∆(cid:48), os ++ ls)

The execution starting from an external operation o is a sequence of steps ((cid:32)a)—
with a ﬁxed to be either dfs or bfs—until the pending operation list is empty or
the execution of the next operation fails. Beginning from a blockchain conﬁgu-
ration (Σ, ∆) and an initial operation o, a transaction execution is a sequence
of operation executions: (Σ, ∆, [o]) (cid:32)a (Σ1, ∆1, os1) (cid:32)a . . . (cid:32)a (Σn, ∆n, []) or
that (Σ, ∆, [o]) (cid:32)a (Σ1, ∆1, os1) (cid:32)a . . . (cid:32)a (Σn, ∆n, osn) (cid:54)(cid:32)a

A transaction can fail either because of gas exhaustion or an internal oper-
ation has failed, and in that case, we have a sequence of (cid:32)a leading to a ﬁnal
step marked as (cid:54)(cid:32)a following the failing operation.

Finally, after every successful execution, the blockchain takes the last conﬁg-

uration and upgrades its global system.

The model of computation described in this section does not follow exactly a
call-and-return model like the Ethereum blockchain does [23]. However, it is easy
to see that it can be simulated in our model by having each contract explicitly
keeping its stack of returned values.

3 Transaction Monitors and Execution Mechanisms

We now introduce transaction monitors and show that it is not possible to
implement them in current blockchains. We present diﬀerent extensions that
allow us to implement transaction monitors.

3.1 Transaction Monitors

Transaction monitors allow us to reason about properties of transactions. Each
smart contract A is equipped with a monitor storage and four especial methods
Ainit , Abegin , Aend and Aterm . These new methods cannot emit operations or
modify smart contract storage, however, they have their own monitor storage.
We assume that these new methods are interpreted by the blockchain and if one
of these methods fail the whole transaction fails. Otherwise, the eﬀect in the
blockchain is the same as if it was executed without monitors. The functions

8

Capretto, Ceresa and S´anchez

Ainit and Aterm can read the storage and balance of the smart contract and
read and write the monitor storage. Function Ainit is executed before the ﬁrst
time A is invoked in the transaction and function Aterm is invoked after the last
interaction to A ﬁnished in the transaction, and does not modify the monitor
storage. Functions Abegin and Aend are executed at the beginning and at the end
of each operation that is executed in A, as in operation monitors [11] (note that
Abegin and Aend can be easily implemented by inlining their code around the
methods of A). The method Abegin takes the same arguments as any A operation
plus the monitor storage, while function Aend has access to the result of the
operation (list of the operation emitted and the new storage) plus the monitor
storage. We call the resulting smart contracts monitored smart contracts.

Operation Monitors. We ﬁrst extend the model of computation to include opera-
tion monitors. A monitored operation execution is a normal operation execution
where the corresponding operation monitor is executed before and after the op-
eration is executed.
o−−−→
We deﬁne (
mon

) modifying ( o−→) as follows. Before executing o, (1) proce-
dure G(o.dest).begin is invoked, then (2) operation o is executed, and (3) ﬁnally
G(o.dest).end runs. That is, operation monitors are simply restricted functions
executed before and after each operation. We can then specialize (cid:32)a with op-
) instead of relation ( o−→) to obtain
eration monitors, that is, use relation (
transaction executions that use operation monitors.

o−−−→
mon

Procedures begin and end can only modify the private monitor storage and
fail, and thus, they cannot interfere in the normal execution of smart contracts
(except by failing more often).

Transaction Monitors. We redeﬁne transaction monitors execution as a restric-
tion of the transaction execution relation so transactions invoke init and term
when required. In this case, init can change the monitor storage, and thus, can
modify the blockchain state. We deﬁne a new relation (cid:16)a the smallest relation
deﬁned by the following inference rules:

Ainit (Σ(A)) = Σ(cid:48)
(Σ, ∆, os)(cid:16)a(Σ(cid:48), ∆, os)

Aterm (Σ(A))
(Σ, ∆, [])(cid:16)a(Σ, ∆, [])

(Σ, ∆, o :: os)(cid:32)a(Σ(cid:48), ∆(cid:48), os(cid:48))
(Σ, ∆, o :: os)(cid:16)a(Σ(cid:48), ∆(cid:48), os(cid:48))

Note that we sacriﬁce a deterministic operational semantics in favor of a

clearer set of rules. As before, we use (−×) to represent failing transactions.

(Σ, ∆)

o
−×

(Σ, ∆, os)−×

Ainit (Σ(A))−×
(Σ, ∆, os)−×

Aterm(Σ(A))−×
(Σ, ∆, [])−×

Finally, we deﬁne a monitored trace of a transaction same as before, given a
blockchain conﬁguration (Σ, ∆) and an external operation o:

(Σ, ∆, [o])(cid:16)a(Σ1, ∆1, os1)(cid:16)a(Σ2, ∆2, os2)(cid:16)a . . . (cid:16)a(Σn, ∆n, [])

Transaction Monitoring of Smart Contracts

9

To remove the non-determinism we add a new relation that restricts the
legal runs. This relation knows the set of visited addresses (smart contracts),
and invokes an initialization method, and at the very end of the evaluation of a
transaction uses the same set to invoke their corresponding term method.

(Σ, ∆, os)(cid:16)o

a(Σ(cid:48), ∆(cid:48), os(cid:48))

o.dest ∈ E

E (cid:96) (Σ, ∆, o :: os) ⇒a E (cid:96) (Σ(cid:48), ∆(cid:48), os(cid:48))

(Σ(cid:48)(cid:48), ∆, os) (cid:32)o

a (Σ(cid:48), ∆(cid:48), os(cid:48))
o.dest /∈ E
a
E (cid:96) (Σ, ∆, o :: os) ⇒a E ∪ {o.dest} (cid:96) (Σ(cid:48), ∆(cid:48), os(cid:48))

(Σ, ∆, os)(cid:16)Ainit

(Σ(cid:48)(cid:48), ∆, os)

(Σ, ∆, [])(cid:16)Aterm
e ∈ E
E (cid:96) (Σ, ∆, []) ⇒a E \ {e} (cid:96) (Σ, ∆, [])

(Σ, ∆, os)

a

As result, we only accept traces generated by relation (⇒a), beginning with a
blockchain conﬁguration (Σ, ∆) and an external operation o resulting in failure
or a new blockchain conﬁguration (Σ(cid:48), ∆(cid:48)): ∅ (cid:96) (Σ, ∆, [o]) ⇒a . . . ⇒a ∅ (cid:96)
(Σ(cid:48), ∆(cid:48), []).

3.2 Transaction Monitors in BFS/DFS

Unfortunately, transaction monitors cannot be implemented in blockchains that
follow DFS or BFS evaluation strategies. We show now a counter-example. Con-
sider a transaction monitor for A that fails when smart contract A is called
exactly once in a transaction. The monitor storage contains a natural number
which function init sets to 0, begin adds one to the counter, end does nothing,
and term fails if the monitor storage is exactly one.

Now let (Σ, ∆) be a blockchain conﬁguration, and let A and B be two smart
contracts, where A is being monitored for the “only once” property. Consider
the following two executions of external operations from (Σ, ∆):

– o1 invokes B.f which then invokes oA1 in A,
– o2 invokes B.g which then invokes oA1 and oA2 in A.

The monitor for “only once” must reject the transaction beginning with o1, but
accept the transaction beginning with o2.

Consider a DFS strategy. Starting from o1, the execution trace is

(Σ, ∆, [o1]) (cid:32)dfs (Σ1, ∆2, [oA1]) (cid:32)dfs (Σ2, ∆2, as1)

with corresponding sequence of pending operations [o1], [oA1], as1. Starting from
o2 the sequence of pending operations is [o2], [oA1; oA2], as1 ++ [oA2],. . . ,[oA2],
as2. It is not possible to distinguish between the traces generated by o1 and o2,
as anything that operation oA1 and its descendants as1 do will happen before
the execution of oA2 in the second transaction. In other words, o1 and all the
operations that can be generated by it or its descendants cannot know that some
other invocation to A is pending so A cannot fail preventively. At the same time

10

Capretto, Ceresa and S´anchez

oA1 is the only chance in A to make the ﬁrst transaction fails because there is
no other operation in A. Therefore, the two runs are identical up to the end of
oA1 and one must fail and the other must not fail.

A BFS scheduler can distinguish between the execution of operations o1
and o2 by using a recurring operation. Since new operations are added to the
end of the pending queue, A can inject an operation that checks A’s state and
conditionally (if the test that would make term fail is true) injects itself at the
end of the pending queue. If the condition that makes term accept is never met,
the transaction fails because the recurring operation injects itself ad-inﬁnitum,
exhausting gas. In Section 5.1 we use recurring operations thoroughly. However, a
simple variation of this example that includes comparing with a third transaction
where A is invoked three times shows that BFS cannot implement “only once”
either (as BFS cannot distinguish between the third invocation to A and a ﬁrst
invocation to A in a transaction following the one originated by o2). For a detailed
proof see Appendix B.

4 Execution Mechanisms

We propose new mechanisms and study if they help to implement transaction
monitors. However, adding features to blockchains is potentially dangerous since
it can introduce unwanted behaviour[17]. We focus on simple mechanisms that
are easy to implement and are backwards compatible.

Since Abegin and Aend can already be implemented using inlining, we focus
on mechanisms that allow executions at the beginning and end of transactions,
which can aid to implement Ainit and Aterm . We present two kinds of mecha-
nisms, ones that introduce a new instruction, and others that add a new special
method to smart contracts. In the next section, we compare their relative power
and if they can implement transaction monitors.

Mechanisms that Add New Instructions. The ﬁrst four mechanisms add
new instructions and can be easily implemented by bakers/miners collecting the
information required in the context ∆.

– First. We consider a new instruction, first, which returns true if the cur-
rent operation is the ﬁrst invocation to the smart contract in the current
transaction. The context ∆ can be extended to contain the set of contracts
F that have already run an operation in the current transaction, which al-
lows us to implement first as A (cid:54)∈ F , where A is the smart contract that
executes first.

– Count. We introduce now a new instruction, count that returns how many
invocations have been performed to methods of the contract in the current
transaction. Again, the context ∆ can easily count how many times each
contract has been invoked.

– Fail/NoFail. This mechanism equips each contract with a new ﬂag fail
that can be assigned during the execution of the contract (and that is false
by default). The semantics is that at the end of the transaction, the whole

Transaction Monitoring of Smart Contracts

11

transaction would fail if some contract has the fail bit to true. For example,
the failing bit allows us to implement ﬂash loans as follows. A lender smart
contract can set fail to true when is lending money and change it to false
only when the money is returned.

– Queue info. We add a new operation, queue, indicating if there is no more
interaction between smart contracts. Or equivalently, if the only operations
permitted in the pending queue are recurrent operations (which can only
inject operations to the same contract). These operations must also be spe-
cially qualiﬁed in the contract, and the runtime system must make sure that
they only generate operations to the same contract.

Mechanisms that Add New Methods or Storage. The following mecha-
nisms modify the deﬁnition of smart contracts either by adding new methods
that are executed at particular moments in a transaction or by adding special
storage/memory.

– Transaction Memory. Smart contracts are equipped with a special volatile
memory segment that exists only during the execution of a transaction and
which is created and initialized at the beginning of the transaction. We add a
new segment in the smart contract indicating the initial values to be assigned.
In concrete, each contract A indicates a new storage type for the transaction
memory and a procedure that initializes it (which can read but not change
the conventional storage). We use trmem to refer to this mechanism.

– Storage Hookup, Bounded and Unbounded. The idea is to equip smart con-
tracts with a new method that updates the storage after the last local op-
erations in the transaction. These methods can only modify the storage but
not invoke other methods. A bounded version of this mechanism is restricted
to terminating non-failing functions (for example, by restricting the class of
programs). In addition, the unbounded version is arbitrary code that can
fail. We use bstore and ustore to refer to these mechanisms.

5

Implementing Transaction Monitors

We say a mechanism M implements another mechanism N if and only if as-
suming a blockchain equipped with M can write every smart contract that a
blockchain equipped with mechanism N can write. We say that two mechanisms
are equivalent if and only if they can implement each other. We disregard gas
consumption here, only considering inﬁnite computations (i.e. we assume that
one can always assume suﬃcient gas).

Theorem 1. The following are equivalent: trmem, first, count, and bstore.

If contracts can know when their ﬁrst invocation in the transaction occurs,
they can set the storage in diﬀerent ways simulating count and trmem. Also,
count and trmem can simulate first, by checking if the count is 0 and initializ-
ing a volatile bit to true. More interesting is that first can simulate bounded

12

Capretto, Ceresa and S´anchez

Fig. 4. Relation between mechanisms for any scheduler. An arrow from mechanism M
to mechanism N means that M implements N.

storage hookup by applying the eﬀect on the storage of bounded storage hookup
at the beginning of the next transaction. Detailed proofs are included in Ap-
pendix A.

Lemma 1. Mechanism ustore implements bstore and fail.

Proof. Mechanism ustore implements bstore trivially as it is just less restric-
tive. For fail we add in the storage of A a new ﬁeld, ﬂ to represent the failing
bit which is initialized to false when the contract is installed and updated to
simulate the fail instruction. At the end of the transaction, the ustore hookup
(cid:117)(cid:116)
checks if ﬂ is true and fail. Otherwise, it does nothing.

It can be proven that the other direction is not always possible. Fig 4 shows
graphically the previous results where an arrow indicates that one mechanism
implements another. In this diagram, an absence of an arrow does not neces-
sarily imply impossibility but perhaps that the result depends on the execution
order. For example, in BFS blockchains first can implement ustore, but this
is impossible with DFS.

Since first, count, bstore and trmem are all equivalent, from now on we
only refer to mechanism first. It is easy to see that this mechanism is enough
to implement init.

To implement term, we can either implement fail or ustore, where fail is
simpler, and ustore is more powerful but requires a bigger change to blockchains.

Theorem 2. Mechanisms first + fail implement transaction monitors.

Proof. Let B be a blockchain that implements first and fail. Given a moni-
tored smart contract A, we want to implement A in blockchain B. We deﬁne a
new smart contract A(cid:48) extending its storage to also contains A’s monitor storage.
Then, we equip A(cid:48) with a new method f (cid:48) for every method f in A, such that, f (cid:48)
ﬁrst checks first and executes Ainit if needed. Then, before exiting, f (cid:48) executes
Aterm with the current state but instead of failing explicitly f (cid:48) set the failing
bit. Function Ainit is executed exactly once and Aterm may be executed multi-
ple times, but it does not modify the contract storage and it does not generate
operations. The last execution of Aterm in A(cid:48) will simulate Aterm in A. If the

bstoreustoreTransactionMemorycountfirstfailTransaction Monitoring of Smart Contracts

13

Fig. 5. Relation between mechanisms and transaction monitor for any scheduler.

semantics of the blockchain were such that the balance of pending outgoing op-
eration would subtract balance from A when it executes, then these calculations
(cid:117)(cid:116)
can be made in the monitor storage when the operations are generated.

Since ustore implements first and fail, it follows that ustore implements

transaction monitors.

Corollary 1. ustore implements transaction monitors but transaction moni-
tors cannot implement ustore.

Transaction monitors can only make contracts fail but not change the storage.

Our results are summarized in Fig. 5.

5.1 BFS Blockchains

We now study more in detail the mechanism for BFS based blockchains. The
ﬁrst result is that unless equipped with further mechanisms, BFS blockchains
cannot implement transaction monitors. The essence of the proof is to create
two transactions on a monitored contract A (like in “only once”) in which corre-
sponding invocations to the same contract A receive identical information, and
one must fail and the other commit.

Theorem 3. A BFS blockchain does not implement transaction monitors.

A BFS blockchain guarantees that new operations are executed after all
pending operations, which enables the implementation of implement fail using
recurring operations. A recurring operation is a private function that can read
and write the storage and that either terminates or reinjects itself again to
the pending queue. Since every time the operation is executed the blockchain
consumes gas, and eventually, failure follows from an attempt to inject itself
ad-inﬁnitum.

Lemma 2. Recurring operations in BFS blockchain allow to implement fail.

Since transaction monitors cannot be implemented within a BFS blockchain (see

Appendix B), we conclude that fail does not implement transaction moni-
tors in BFS blockchains. The missing element is first which allows to imple-
ment ustore. And, since ustore implements transaction monitors (Corollary 1),
first can also implement transaction monitors.

Lemma 3. Mechanism first implements ustore in BFS blockchains.

ustoreTransactionMonitorsfirst+fail14

Capretto, Ceresa and S´anchez

Proof. Assume a BFS blockchain implementing first. Let A be a smart con-
tract. We modify A to contain a second copy S(cid:48) of its storage. Upon the ﬁrst
call of A, we update the current storage using the values in S(cid:48). We add a new
private method hookup in A that mimics the code of ustore but (1) it applies
the changes in S(cid:48), and (2) instead of failing (if ustore fails) it calls itself as a
recurring operation. Finally, we modify A so that function hookup is invoked at
the end of each method in A. In eﬀect, hookup is preventively evaluating ustore
on the side memory S(cid:48), and simulating the failure as a recurring operation (when
ustore fails). Therefore, if the operation is the last one on the contract and it
does not fail, then S(cid:48) contains the correct storage, which will then be copied at
(cid:117)(cid:116)
the beginning of the next transaction.

In the previous proof, we split mechanism ustore into two parts: one in charge
of updating the storage, the other in charge of failing. If we also add queue,
we can implement ustore without failing by gas exhaustion because now the
hookup executed recurrently can know if there are only recurrent operations and
then execute the ustore code (including the failure).

Lemma 4. Mechanism queue implements ustore in BFS blockchains.

In a BFS blockchain, ustore implements transaction monitors (Corollary 1),
and thus, by the previous lemma, queue also implements transaction monitors.
Next, we will show that queue cannot be implemented with ustore when a BFS
strategy is used. Intuitively, mechanism queue adds a way for smart contracts to
know the state of the blockchain, i.e. if there is still interaction between smart
contracts, and thus, smart contracts can take diﬀerent actions based on the state
of the blockchain, while mechanism ustore adds a way to execute a procedure
at the end of transactions, but smart contracts are oblivious about interactions
between smart contracts. Since ustore implements all other mechanisms, we
have that no other mechanism can implement queue.

Lemma 5. In BFS blockchains ustore cannot implement queue.

The main idea is to create two executions that are identical unless one can
inspect the pending operation queue, and in which one operation must fail if
queue returns that the queue of pending operations is empty. The complete
proof is in Appendix B. Fig 6 summarizes the relations between mechanisms
and transaction monitor in BFS blockchains.

5.2 DFS Blockchains

We now study DFS blockchains, that is, when the resulting list of operations
from smart contracts execution are appended at the beginning of the list. This
is the most conventional execution order in most blockchains, like Ethereum. We
now prove several impossibility results.

Mechanisms ustore and first plus fail implement transaction monitors
(Corollary 1 and Thoerem 2). In a DFS blockchain, those are the only two

Transaction Monitoring of Smart Contracts

15

Fig. 6. Relation between mechanisms and transaction monitor in BFS blockchains. A
black arrow from mechanism M to mechanism N means that M can implement N . The
∞ symbol represents the use of an inﬁnite recursion to provoke a failure. A red arrow
with a cross from mechanism M to mechanism N means that M cannot implement N .

ways using our mechanisms to implement transaction monitors. We show that
transaction monitors cannot be implemented by combining queue with either
first or fail, and as a consequence none of these mechanisms on their own
can implement transaction monitors.

Lemma 6. A DFS blockchain implementing queue and first does no imple-
ment transaction monitors.

Proof. Let B be a DFS blockchain and A a smart contract installed in B. Con-
sider the “only once” monitor that fails if and only if the smart contract A is
called exactly once. We show that this monitor cannot be implemented in DFS
even with first and queue.

Let B, C be two other smart contracts. We analyze the pending queue of

execution of two possible external operations originated by B:
1. o1 where B calls A once and then C
2. o2 where B calls A twice and then C
We assume that there are no additional invocations to A aside from the described
above. When we execute both operations in a (Σ, ∆) blockchain system, we have
the following two traces:

• t1 : (Σ, ∆, [o1]) (cid:32)dfs (Σ(cid:48), ∆(cid:48), [a1, c1]) . . .
• t2 : (Σ, ∆, [o2]) (cid:32)dfs (Σ(cid:48), ∆(cid:48), [a1, a2, c1]) . . .

Note that the presence of operation c1 in the pending execution queue is forcing
mechanism queue to return false. Since the occurrence of operation a1 in both
cases execute in the same conﬁguration, the behavior must be the same. The
transaction executing o1 must fail because A is called only once, but this will
(cid:117)(cid:116)
make the second transaction fail as well.

We can conclude that neither queue nor first alone would implement transac-
tion monitors.

∞TransactionMonitorsBFS+failBFS+ustoreBFS+queueBFSBFS+first∞16

Capretto, Ceresa and S´anchez

Lemma 7. Under DFS queue and fail cannot implement transaction moni-
tors.

The main diﬀerence between these mechanisms and transaction monitors
is that the latter can execute functions without a contract being invoked at
particular moments in the execution of transactions. Take for example procedure
init, neither queue nor fail can simulate init, as there is no way for these
mechanisms to distinguish the ﬁrst execution of a smart contract in a given
transaction.

Combining fail with first one can implement transaction monitors in any
execution order, including DFS (Theorem 2), but fail is not enough to imple-
ment transaction monitors in DFS. Therefore, we conclude that DFS blockchains
do not implement first. Moreover, putting all previous lemmas together, we
conclude that a DFS blockchains cannot implement any of the mechanisms listed
in Section 4 directly.

Corollary 2. DFS blockchains cannot implement first, fail, ustore or queue.

All proofs are in Appendix C.

6 Conclusion and Future Work

We have studied transaction monitors for smart contracts. Transaction monitors
are a defense mechanism enabling smart contracts to explicitly state wanted
or unwanted behaviour at the transactional level. This kind of properties are
motivated by contracts like ﬂash loans, which are not implementable in their full
generality in current blockchains. We propose a solution based on adding new
mechanisms to the blockchain. Transaction monitors can be incorporated directly
into contracts or simulated if some of these mechanisms are implemented. This
could be preferable since some of these mechanisms are very simple and backward
compatible, while others extend the functionality of smart contracts. We have
studied how some mechanisms simulate each other, both for any execution order,
and speciﬁcally for BFS and DFS blockchains. The conclusion is that the simplest
mechanism that allows us to implement transaction monitors is the combination
of first and fail.

For simplicity, we have neglected a speciﬁc analysis of gas consumption, ex-
cept for recurrent operations that purposefully fail by exhausting gas. Even
though transaction monitors will consume additional gas which can inﬂuence
the failure of the transaction (as with operation monitors), we claim that for all
our development there is an amount of gas that can be calculated which will not
make accepting transactions fail. However, we leave a detailed study for future
work.

Other avenues of future work include the study of new features, particularly
views that allows contracts to inspect the state of other contracts. We are also
performing a thorough study of how exposing new mechanisms to contracts—
that can use them for implementing functionality—can break (or not) imple-
mentations of monitors that are correct without adding the mechanisms.

Transaction Monitoring of Smart Contracts

17

References

1. Michelson: the language of smart contracts in Tezos. https://tezos.gitlab.io/

whitedoc/michelson.html.

2. Ethereum. Solidity documentation — release 0.2.0.

http://solidity.

readthedocs.io/, 2016.

3. W. Ahrendt and R. Bubel. Functional veriﬁcation of smart contracts via strong

data integrity. In Proc. of ISoLA (3), LNCS, pages 9–24. Springer, 2020.

4. G. Alfour. LIGO: a friendly smart-contract language for Tezos. https://ligolang.

org, 2020. last accessed: 2022-05-03.

5. D. Annenkov, J. B. Nielsen, and B. Spitters. ConCert: a smart contract certiﬁcation
framework in Coq. In Proc. of the 9th ACM SIGPLAN Int’l Conf. on Certiﬁed
Programs and Proofs (CPP’20), pages 215–218. ACM, 2020.

6. S. Azzopardi, J. Ellul, and G. J. Pace. Monitoring smart contracts: ContractLarva
In Proc. of the 18th International Conference on
and open challenges beyond.
Runtime Veriﬁcation (RV’18), volume 11237 of LNCS, pages 113–137. Springer,
2018.

7. B. Bernardo, R. Cauderlier, Z. Hu, B. Pesin, and J. Tesson. Mi-Cho-Coq, a frame-

work for certifying Tezos smart contracts. CoRR, abs/1909.08671, 2019.

8. K. Bhargavan, A. Delignat-Lavaud, C. Fourneta, A. Gollamudi, G. Gonthier,
N. Kobeissi, N. Kulatova, A. Rastogi, T. Sibut-Pinote, N. Swamy, and S. Z.
B´eguelin. Formal veriﬁcation of smart contracts: Short paper. In Proc. of Workshop
on Programming Languages and Analysis for Security (PLAS@CCS’16), pages 91–
96. ACM, 2016.

9. A. C. Ca˜nada, F. Kobayashi, fubuloubu, and A. Williams. Eip-3156: Flash loans.
10. S. Conchon, A. Korneva, and F. Za¨ıdi. Verifying smart contracts with Cubicle. In
Proc. of the 1st Workshop on Formal Methods for Blockchains (FMBC’19), volume
12232 of LNCS, pages 312–324. Springer, 2019.

11. J. Ellul and G. J. Pace. Runtime veriﬁcation of Ethereum smart contracts. In
Proc. of the 14th European Dependable Computing Conference (EDCC’18), pages
158–163. IEEE Computer Society, 2018.
12. M. Leucker. Teaching runtime veriﬁcation.

In Proc. of RV’11, number 7186 in

LNCS, pages 34–48. Springer, 2011.

13. A. Li, J. A. Choi, and an. Long. Securing smart contract with runtime validation.

In Proc. of ACM PLDI’20, pages 438–453. ACM, 2020.

14. S. Nakamoto. Bitcoin: a peer-to-peer electronic cash system, 2009.
15. Z. Neha¨ı and F. Bobot. Deductive proof of industrial smart contracts using Why3.
In Proc. of the 1st Workshop on Formal Methods for Blockchains (FMBC’19),
volume 12232 of LNCS, pages 299–311. Springer, 2019.

16. A. Permenev, D. Dimitrov, P. Tsankov, D. Drachsler-Cohen, and M. Vechev. Verx:
Safety veriﬁcation of smart contracts. In 2020 IEEE Symposium on Security and
Privacy (SP), pages 1661–1677, 2020.
17. D. Phil. Analysis of the dao exploit, 2016.
18. D. Robinson and G. Konstantopoulos. Ethereum is a dark forest, 2020.
19. J. Schiﬄ, W. Ahrendt, B. Beckert, and R. Bubel. Formal analysis of smart con-
tracts: Applying the KeY system. In Deductive Software Veriﬁcation: Future Per-
spectives - Reﬂections on the Occasion of 20 Years of KeY, volume 12345 of LNCS,
pages 204–218. 2020.

20. I. Sergey, A. Kumar, and A. Hobor. Scilla: a smart contract intermediate-level

LAnguage. CoRR, abs/1801.00687, 2018.

18

Capretto, Ceresa and S´anchez

21. J. Stephens, K. Ferles, B. Mariano, S. Lahiri, and I. Dillig. SmartPulse: Automated
In Proc. of the 42nd IEEE

checking of temporal properties in smart contracts.
Symposium on Security and Privacy (S&P’21). IEEE, May 2021.

22. N. Szabo. Smart contracts: Building blocks for digital markets. Extropy, 16, 1996.
23. G. Wood. Ethereum: A secure decentralised generalised transaction ledger.

Ethereum project yellow paper, 151:1–32, 2014.

Transaction Monitoring of Smart Contracts

19

A Mechanisms Equivalence

Lemma 8. Mechanisms first and count are equivalent.

Proof. Assume count, we implement first by checking that its value is 0.

Assume first. For each smart contract A installed in the blockchain, we
extend the storage of A with a natural variable Acount, and we replace each
method in A with a new one where we ﬁrst check first: if it is true set Acount =
1, if it not, add one to Acount.

Lemma 9. Mechanisms first and trmem are equivalent.

Proof. Assume trmem. For each smart contract A installed in the blockchain, we
deﬁne a new volatile boolean value binit . The variable binit is initialized to true
and set to false at the end of every method in A. Therefore, the value binit is
true only at the ﬁrst interaction with A and false afterward.

Assume first, let B be a smart contract and TM be the volatile memory
segment of B. Extend B storage with TM’, a copy of TM. At every method in B,
we check first, if it is true we initialize TM’ in the same way as the procedure
from trmem.

Lemma 10. Mechanisms first and bstore are equivalent.

Proof. Assume first. Let A be a smart contract deﬁning a hookup function
updating the storage of A. We expand the storage of A with a copy of the
storage, shookup. Moreover, at the end of every method in A, we apply hookup
with the current storage and store its result at shookup. Since function hookup
cannot fail, it does not matter if it is executed at the end of a transaction or at
the very beginning of the next one. Finally, we can check with first and update
the storage with the value stored in shookup.

Note that if the contract A is never invoked again the last change will not

happen. However, from the point of view of A, it is equivalent.

Assume bstore, and let B be a smart contract. Extend B storage with
a boolean ﬁeld bfst to represent ﬁrst, such that it is initialized to true, each
invocation set it to false and bstore set it back to true.

20

Capretto, Ceresa and S´anchez

B Impossibility of Monitorability in BFS

Theorem 3. A BFS blockchain does not implement transaction monitors.

Proof. Consider a transaction monitor for A that fails smart contract A is called
exactly once in a transaction. The monitor storage contains natural number,
function init sets the monitor storage to 0, begin adds one to the counter, end
does nothing, and term fails if the monitor storage is exactly one.

Now, let (Σ, ∆) be a blockchain conﬁguration, and let A and B be two smart
contracts, where A is being monitored for the “only once” property. Consider
the following family of executions of external operations originated by B:

– operation o where B calls A once,
– operation ok where B calls to method f at smart contract B with parameter
k and also calls A. The method f calls itself recursively k times and then it
will call A.

When we execute previous operations in (Σ, ∆), we have the following traces:

• t : (Σ, ∆, [o]) (cid:32)bfs (Σ1, ∆1, [a1]) . . .
• t0 : (Σ, ∆, [o0]) (cid:32)bfs (Σ1, ∆1, [b0, a1]) (cid:32)bfs (Σ2, ∆2, [a1, a2]) (cid:32)bfs

(Σ3, ∆3, [a2] ++ as1) (cid:32)bfs (Σ4, ∆4, as1 ++ as2) . . .
• t1 : (Σ, ∆, [o1]) (cid:32)bfs (Σ1, ∆1, [b1, a1]) (cid:32)bfs (Σ2, ∆2, [a1, b(cid:48)

(Σ3, ∆3, [b(cid:48)

1] ++ as1) (cid:32)bfs (Σ4, ∆4, as1 ++ [a2]) . . .

1]) (cid:32)bfs

Monitor “only once” rejects transaction t, but accepts transactions tk, for
all k ≥ 0. Notice that a1 is executed in the same blockchain conﬁguration in all
transactions, therefore it must behave the same in all cases. The execution of a1
in t has three options:

1. do nothing/modify the storage,
2. fail,
3. generate a new invocation to A.

In the ﬁrst case t will not satisfy the property “only once” as the transaction
will not fail since A never regains the control. On the other hand, in the second
case all transactions tk will violate the monitor as all of them will fail while
executing a1. Therefore, a1 must generate a new invocation to A, opa. When opa
executes it will have the same options as a1, and by making a similar analysis
as before, we can conclude that it must also generate a new invocation. The
only diﬀerence with a1 is in the transaction t0 where a2 has already executed
and therefore opa can do nothing. By repeating this argument, we have that the
operation generated by a1 must be a recurring operation (see Section 5.1) that
keeps invoking itself until another method of A is invoked. If no other method
of A is invoked in the same transaction, the recurring operation will fail by
gas exhaustion. This will work correctly for transactions t and tk with k ≥ 0.
However, this will not work for all transactions. Let’s consider a transaction

Transaction Monitoring of Smart Contracts

21

similar to t0 where A is invoked three times. It is originated by an operation
o(cid:48)
0 where B calls to method f at smart contract B with parameter 0, then calls
A and ﬁnally calls method f with parameter 0 again. When we execute o(cid:48)
0 in
(Σ, ∆), we have the following trace:

• t(cid:48)

0 : (Σ, ∆, [o0]) (cid:32)bfs (Σ1, ∆1, [b0, a1, b0]) (cid:32)bfs (Σ2, ∆2, [a1, b0, a2]) (cid:32)bfs

(Σ3, ∆3, [b0, a2] ++ as1) (cid:32)bfs (Σ4, ∆4, [a2] ++ as1 ++ [a3]) . . .

Notice that the third invocation of A originated by B will execute after the
recurring operation generated by a1 stops. 4 So, if we compare it with the case
where t is executed after t0 we have that a3 and a1 will execute in the same state.
Therefore, they must have the same behaviour. As explained before, when a1
executes it must call the recurring operation. However, a3 is the last invocation
of A in t(cid:48)
0, then its recurring operation will keep calling itself until it fails by gas
(cid:117)(cid:116)
exhaustion, violating the property of monitor only once.

Lemma 5. In BFS ustore cannot implement queue.

Proof. Assume a BFS blockchain that implements queue. Let A be a smart
contract that fails if and only if queue is false. Let (Σ, ∆) be a blockchain system,
and consider the following two executions of external operations in (Σ, ∆):

– operation o1 calls B.f which then generates two operations: oA1 to A and

oC1 a call to C which does not generate any new operation.

– operation o2, which calls B.g which in turn generates oA1, a call to A.

Clearly, A will fail in the execution of o1 but not on o2. In both cases the execu-
tion oA1 will run in the same blockchain conﬁguration and with same parameter
and without queue it is not possible for A to know that there are pending oper-
ations as they will execute in another smart contract. Therefore, oA1 will behave
exactly the same in both transactions. As this is the only operation in A in
both transactions, the hookup method from the ustore will also have the same
behaviour in both cases. As consequence, either both transactions fail (making
the transaction generated by o2 fail incorrectly) or none (making the transaction
generated by o1 succeed incorrectly). Therefore, the smart contract A cannot be
implemented in a BFS blockchain equipped with ustore but without queue. (cid:117)(cid:116)

4 if the recurring operation does not stop immediately after it see that other method
in A was invoked it must still stop after a ﬁnite number of steps and therefore we
can still create a transaction where the third invocation to A executes after it stops.

22

Capretto, Ceresa and S´anchez

C DFS Proofs

Lemma 7. Under DFS queue and fail cannot implement transaction moni-
tors.

Proof. Consider a transaction monitor for A that fails smart contract A is called
exactly once in a transaction. The monitor storage contains natural number,
function init sets the monitor storage to 0, begin adds one to the counter, end
does nothing, and term fails if the monitor storage is exactly one.

Now, let (Σ, ∆) be a blockchain conﬁguration, and let A, B and C be three
smart contracts, where A is being monitored for the “only once” property. We
analyze the pending queue of execution of two possible external operations orig-
inated by B:

1. o1 where B calls A once and then C
2. o2 where B calls A twice and then C

We assume that there are no additional invocations to A aside from the described
above. When we execute both operations in a (Σ, ∆) blockchain conﬁguration,
we have the following two traces:

• t1 : (Σ, ∆, [o1]) (cid:32)dfs (Σ(cid:48), ∆(cid:48), [a1, c1]) . . .
• t2 : (Σ, ∆, [o2]) (cid:32)dfs (Σ(cid:48), ∆(cid:48), [a2, a3, c1]) . . .

Note that the presence of operation c1 in the pending execution queue is
forcing the mechanism queue info to return false. Operations a1 and a2 are
exactly the same operation invoking smart contract A. Since operations o1 and o2
execute on the same blockchain conﬁguration, i.e. (Σ, ∆), the result of executing
a1 and a2 should be same on A.

The transaction executing o1 must fail because A is called only once. Then,
this execution of A must fail, and thus, a1 should fail directly, set the failing bit
to true, or call another operation that will fail later.

The transaction executing o2 should not fail. Therefore, a1 cannot fail di-
rectly, and thus, it must either set the failing bit to true or call another operation,
a4. In the latter case, since the scheduler strategy is DFS, operation a4 replaces
a1 as the head of the pending execution queue in both cases. Moreover, every
operation resulting from the execution of operation a4 is going to be appended
to the head of the pending execution queue.

• t1 : (Σ, ∆, [o1]) (cid:32)dfs (Σ(cid:48), ∆(cid:48), [a1, c1]) (cid:32)dfs (Σ(cid:48)(cid:48), ∆(cid:48)(cid:48), [a4, c1]) . . .
• t2 : (Σ, ∆, [o2]) (cid:32)dfs (Σ(cid:48), ∆(cid:48), [a2, a3, c1]) (cid:32)dfs (Σ(cid:48)(cid:48), ∆(cid:48)(cid:48), [a4, a3, c1]) . . .

If operations a1, a4 or any of its decedents explicitly fail, then the execution

of operation o2 is doomed to fail too.

However, if none of these operations, a1, a4, . . ., fail then the ﬁrst run will

ﬁnish without failing, violating the property of monitor only once.

Transaction Monitoring of Smart Contracts

23

Therefore, a1 or any of its decedents must set the failing bit to true. This
will work correctly for the execution of operation o1. In order for this to also
work for the execution of operation o2 it is enough if a3 sets the failing to false.
However, if we consider the transaction that begins with two external operations
[o2; o1] and the execution of the transaction t2 followed by t1. We have that o1
will run in both cases in the same blockchain conﬁguration, and therefore it will
have the same behaviour in both cases. As explained before, when a1 executes
it or one of it descendants must set the failing bit to true. This implies that the
execution originated by [o2; o1] will ﬁnish with A’s failing bit set to true and thus
the whole transaction will fail, violating the property of monitor only once. (cid:117)(cid:116)

Lemma 11. A DFS blockchain does not implement queue.

Proof. Let B be a DFS blockchain and A a smart contract installed in B that
fails if and only if queue is false. Let (Σ, ∆) be a blockchain system, and consider
the following two executions of external operations in (Σ, ∆):

– operation o1 calls B.f which then generates two operations: oA1 to A and

oC1 a call to C which does not generate any new operation.

– operation o2, which calls B.g which in turn generates oA1, a call to A.

Clearly, A will fail in the execution of o1 but not on o2. In both cases the execu-
tion oA1 will run in the same blockchain conﬁguration and with same parameter
and without queue it is not possible for A to know that there are pending oper-
ations as they will execute in another smart contract. Therefore, oA1 will behave
exactly the same in both transactions. As consequence, either both transactions
fail (making the transaction generated by o2 fail incorrectly) or none (making
the transaction generated by o1 succeed incorrectly). Therefore, the smart con-
(cid:117)(cid:116)
tract A cannot be implemented in a DFS blockchain without queue.

24

Capretto, Ceresa and S´anchez

contract Lender {

uint initial_balance ;
function lend ( address payable dest , uint amount )

public {

require ( amount <= this . balance ) ;
dest . transfer ( amount ) ;

}
ustore {

assert ( this . balance >= initial_balance ) ;
initial_balance = this . balance ;

}

}

Listing 1.1. A correct Flash Loan implementation using U. Storage Hookup

contract Lender {

uint initial_balance ;
function lend ( address payable dest , uint amount )

public {

if ( this . first ) {

initial_balance = this . balance ;

}
require ( amount <= this . balance ) ;
dest . transfer ( amount ) ;
check_balance () ;

}
receive () external payable {

check_balance () ;

}
function check_balance () private {

if ( this . balance < initial_balance ) {

this . fail = true ;

} else {

this . fail = false ;

}

}

}

Listing 1.2. A correct Flash Loan implementation using First + Fail/NoFail Hookup

D Implementations of Flash Loan

Transaction Monitoring of Smart Contracts

25

contract Lender {

uint initial_balance ;
function lend ( address payable dest , uint amount )

public {

if ( this . first ) {

initial_balance = this . balance ;

}
return [ system . gen_op ( dest , () , amount ) , system .

gen_op ( this . check_balance , () , 0) ];

}
receive () external payable {

return [ system . gen_op ( this . check_balance , () , 0) ];

}
function check_balance () private {

if ( this . balance < initial_balance ) {

return [ system . gen_op ( this . check_balance , () ,

0) ];

}
return [];

}

}

Listing 1.3. A correct Flash Loan implementation using BFS Scheduler and First.
Each function returns the list of generated operations.

contract Lender {

uint initial_balance ;
function lend ( address payable dest , uint amount )

public {

require ( amount <= this . balance ) ;
dest . transfer ( amount ) ;
check_balance () ;

}
receive () external payable {

check_balance () ;

}
function check_balance () private {

if ( system . queue ) {

assert ( this . balance >= initial_balance ) ;
initial_balance = this . balance ;

} else {

check_balance () ;

}

}

}

Listing 1.4. A correct Flash Loan implementation using BFS + Qeueu Info

