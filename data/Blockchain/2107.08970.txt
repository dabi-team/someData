Indexing structures for the PLS blockchain

Alex Shafarenko∗

University of Hertfordshire, AL10 9AB, UK; Ada Finex Ltd

∗Correspondence address: University of Hertfordshire, U.K.; email: a.shafarenko@herts.ac.uk

1
2
0
2

g
u
A
3

]

R
C
.
s
c
[

2
v
0
7
9
8
0
.
7
0
1
2
:
v
i
X
r
a

1

 
 
 
 
 
 
Abstract

This paper studies known indexing structures from a new point of view: minimisation of
data exchange between an IoT device acting as a blockchain client and the blockchain server
running a protocol suite that includes two Guy Fawkes protocols, PLS and SLVP. The PLS
blockchain is not a cryptocurrency instrument; it is an immutable ledger oﬀering guaranteed
non-repudiation to low-power clients without use of public key crypto. The novelty of the
situation is in the fact that every PLS client has to obtain a proof of absence in all blocks of
the chain to which its counterparty does not contribute, and we show that it is possible without
traversing the block’s Merkle tree.

We obtain weight statistics of a leaf path on a sparse Merkle tree theoretically, as our
ground case. Using the theory we quantify the communication cost of a client interacting with
the blockchain. We show that large savings can be achieved by providing a bitmap index of the
tree compressed using Tunstall’s method. We further show that even in the case of correlated
access, as in two IoT devices posting messages for each other in consecutive blocks, it is possible
to prevent compression degradation by re-randomising the IDs using a pseudorandom bijective
function. We propose a low-cost function of this kind and evaluate its quality by simulation,
using the avalanche criterion.

keywords: PLS blockchain, Guy Fawkes protocol, content-addressable storage, data–structure

statistics, Tunstall coding, pseudorandom bijections

1 Introduction

This paper gives statistical analysis of some known data structures required for the implementation
of the PLS (permissioned) blockhain [12] or PLSB for short, whose purpose is to support a swarm
of IoT devices, or things operating on the premises of a single administrative authority, for example
a smart hospital. The use of a blockchain is for the purposes of audit trail, authentication and non-
repudiation of all actors, both human and unmanned, including small, bare-metal microcontrollers
that supply critical sensor data and those which drive actuators.

The utility of permissioned distributed ledger systems (permissioned blockchains, or PBCs for short)
is based on two fundamentals: (i) distributed validity check of messages and (ii) an immutable,
linearly-ordered ledger. In IoT applications, especially in sensor-networks, (ii) tends to be more
important than (i). Indeed, typically messages are not transactions in the ﬁnancial sense, so checks
such as double spending are not relevant; value checks are domain-speciﬁc and are best performed
by smart contracts, which leaves the authenticity and provenance of each message posted on the
ledger as the only general validity concerns. The PLS blockchain [12] assures (ii) by employing
Guy-Fawkes Protocols (GFPs) [2].

A GFP is a post-quantum signature protocol based on an unlimited series of interlocking crypto-
graphic hashes. GFP computations are fast, messages short and secrets neither moved nor kept for
a long time; the GFPs are resistant to quantum computing as they do not use operations such as
prime-number factorisation or discrete logarithm. Finally, by their recursive nature, GFPs deﬁne
a single sequence of signatures that is very hard to split; this makes them quite suitable as a basis
of a blockchain.

In the next section we will brieﬂy outline the architecture and protocols of the PLS blockchain
published in an earlier paper[12]. Operational diﬀerences between the PLS and other blockchains,
such as Etherium, call for re-evaluation of major data structures required for its implementation.

2

In Section 4 we argue that the limited number of users (IoT devices on the premises and human
actors1) and the limit on their communication duty cycle and disposable energy need eﬃcient secure
data structures to avoid communicating irrelevant data. We propose a Merkle-Tunstall Tree for
that purpose (Section 5) and provide a statistical evaluation of its eﬃciency. The eﬃciency of the
Tunstall compressor depends on the lack of correlations between diﬀerent user’s contributing to
the same block. To decorrelate block access we propose to use a random permutation function to
map users’ true IDs onto local IDs for a given block, see Section 6. To illustrate how proposed
technologies work together we give one illustrated example in section 7. Finally, there is a section
on related work and some conclusions.

The main contributions of the paper are as follows:

1. Statistical analysis of a sparse Merkle tree with uniform, uncorrelated probabilistic leaf occu-
pancy. We have obtained the path-weight probability distribution function (as a recurrence
relation in the tree height) analytically, without Monte-Carlo simulation. It is easy to quantify
the function numerically for any given height.

2. The proposal and evaluation of a compressed bitmap and local enumeration of block users.
This makes it possible for a user to obtain the proof of absence in the block directly from
the broadcast root of trust without accessing the Merkle tree. We have also shown that the
local enumeration results in a path weight similar to that on the original sparse Merkle Tree
on average, but the variation is tightly bounded from above, which makes it possible to limit
the packet length when communicating a secure leaf path using our structure. By contrast,
the path across the original tree varies more widely depending on the leaf statistics and may
result in paths exceeding the maximum packet size.

3. The proposal and evaluation of shift-shuﬄe as a low-cost pseudorandom permutation tech-
nique suﬃcient to break a possible correlation between occurrences of diﬀerent users’ records
in block contents. We quantiﬁed the number of rounds in the permutation algorithm to be
used taking the avalanche criterion as a basis.

2 PLS blockchain: architecture and protocols.

The details of the protocols and their security analysis are available from [12]. We present them
here for completeness. However, for the contributions of the present paper we only need to discuss
the logistics of the PLSB, whose architecture is shown in ﬁgure 1.

Blocks
are formed from transactions communicated by things via proxies that make it possible for
all things to rely on low-power radio communication. To authorise a transaction, things run another
GFP protocol, called SLVP. That protocol’s messages are forwarded by one or more proxies to the
Fog Server (FS) to be included in the next block. The FS forms blocks regularly, on a ﬁxed wall-
clock schedule, by validating incoming SLVP messages from things, and adding them to the current
block.

1In the sequel, when it is not important what kind of actor is meant we will call all actors users for short and

apply the pronoun ’it’.

3

Figure 1: Architecture of a PLS-blockchain system

Chain. By regular deadlines the current blocks are stored in CAS and their hash is signed by
producing messages of the main protocol, PLS. All PLS messages are generated and transmitted by
radio via a sealed unit, Sequencer, which receives the current block’s hash from the FS on a private
radio channel. The Sequencer does not contain a changeable program and is not connected to the
Internet, so it is not hackable. The PLS sequence, i.e. the sequence of PLS messages, requires a
short-term secret, which is produced inside the Sequencer using a physical source of randomness in
one time interval and is revealed in the next interval at the same time as selecting a new random
secret. All things must receive each PLS message, validate it, and unlock the corresponding block’s
hash, which is a ﬁle name of the block in CAS, see ﬁg 2. P- and L- messages cross-validate as shown
in the ﬁgure, and S-messages contain some redundancy, which, after deciphering, indicates whether
the message is valid or not. For example, J can include a run of zeros at the end; this would be
suﬃcient to thwart a “random message” attack, which is a possible DoS action of the attacker
jamming the radio channel2. Also notice that blocks of the blockchain are, as usual, key-value
collections, where the key is the originator’s ID.

Any invalid messages, possibly sent by an attacker will fail the validity check with a very high
probability. Progress is assured by limiting the number of invalid messages using various tech-
niques discussed in [12], but those are exclusively DoS countermeasures which do not inﬂuence the
semantics of the blockchain. The initial message P0 is authenticated by all blockchain users via
external credentials. Users joining the system later would require external authentication of the
latest P-message instead of P0. The unlocked hashes of all the subsequent blocks are as secure as
the weaker of the credential and the computational hardness of the full hash preimage problem
(i.e. ﬁnding all bit-strings of a given length whose hash is a given value). The latter is not feasible
for a SHA-2 hash even Post Quantum. Also notice that the veriﬁcation and unlocking computa-

2Since the attacker does not know the preimage of P at the time when an attack is possible, it can only send
an arbitrary message; after unlocking, it would produce a near-random bitstring as a would-be block hash. The
requirement for it to have r trailing zeros will only be satisﬁed with the probability 2−r

4

Sequencer	Fog	Server	Proxy	…	CAS	Local	TCP/IP	Subnet	Proxy	Thing	Thing	Thing	hard	shell	…	tions are fast (single microseconds) even for a small bare-metal microcontroller equipped with a
crypto-accelerator, e.g. ESP32[7].

Transactions. As mentioned earlier, a thing publishes a transaction on the blockchain by running
the SLVP protocol with the FS. A transaction requires one round of the SLVP protocol, which takes
three blockchain blocks. For the security of the protocol it is required that the originating thing
check that the latest sent SLVP message has appeared on a block. As soon as it has, the next
protocol message can be sent. The ﬁrst message to send is an S-message, which contains the data
object to be signed. Then an LV-message is posted on the blockchain, which provides interlocking
hashes and veriﬁcation data (the latter is needed to thwart jam-spoof attacks, see [12]). Finally,
the thing posts a (proof) P-message. The FS validates the P-message using the data contained in
the previous round’s P-message and the content of the LV-message sent in between. The FS will
only include a P-message in a block if the P-message is valid, while LV- and S- are posted right
away, the reason being that invalid LV- or S-messages will be recognised as such by the protocol
itself only after the next P-message is posted. In practice The FS and a user may share a secret to
help the FS to authenticate incoming messages early to make it diﬃcult for an attacker to post a
large number of invalid S- and LV-messages. However, this does not help a counterparty that must
be mistrustful of the FS. So additional authentication, if present, is purely a DoS countermeasure;
we needn’t focus on it as we concern ourselves only with the machinery of the blockchain.

The protocol is summarised in ﬁgure 3. The diagram shows two users, blue and brown, posting
their SLVP messages on the blockchain using the transmissions shown in the table below, which
is presented on behalf of a single blockchain user. Users are independent in transmitting protocol
messages for themselves and in verifying messages sent by others. The veriﬁcation formulae in
the penultimate column enable users (as well as the FS that does it ﬁrst) to prove to themselves
that the other party has genuinely signed its data object M . If the next P-message, Pk+1 checks
out, they use its value to unlock the data object Mk as deﬁned in the bottom of the ﬁgure3. Just
like blockchain blocks, the data objects have some redundancy. For example, a certain number of
leading zeroes, not necessarily very few as this does not require computation, will adequately defend
against random S messages, sent by an attacker. Notice that the SLVP protocol deﬁnes variable
length encryption for S-messages using a block cipher in PCBC mode. Encryption is bijective, i.e.
information-preserving, and the redundancy required for validation in the presence of a random-
message attack is just a few bytes (e.g. 4 bytes gives the attacker 1 chance in a few billion to post
valid random data, but even then it only subverts a single S-message).

Also note that the FS has authority to introduce a new user by posting their very ﬁrst P-message.
The ﬁrst P-message is always marked as such on the blockchain for other users exchanging trans-
actions to recognise it as the originator’s identity.

Operations. Transactions can be posted by both things and human users. Each thing has one or
more masters, which are typically users (but could be other things). Not only does each thing check
the posting of each of its SLVP messages on the blockchain, it also monitors the postings of all its
masters and any relevant counterparties, and validates their data objects by applying the SLVP
protocol. Alternatively, the thing can participate in a smart contract which would only require it
to follow and validate messages from the contract engine. In this paper we limit ourselves to the

3The original paper [12] has a slightly diﬀerent arrangement for S-messages since in the original design CAS was

trusted for progress, but in the present paper we eliminate this requirement.

5

Interval

Transmit/Receive

Verify

Unlock

[T0, T1]

[T1, T2]

...

L0 = H(N1) ⊕ N0
S0 = EN0 (J0 ⊕ H(N1))
P0 = H(N0)
L1 = H(N2) ⊕ N1
S1 = EN1 (J1 ⊕ H(N2))
P1 = H(N1)
...

[Tk, Tk+1] Lk = H(Nk+1) ⊕ Nk

P0 out of band

H(L0 ⊕ P1) = P0

H(B0) = P1 ⊕ DL0⊕P1(S0)

...

...

Sk = ENk (Jk ⊕ H(Nk+1)) H(Lk−1 ⊕ Pk) = Pk−1 H(Bk−1) = Pk ⊕ DLk−1⊕Pk (Sk−1)
Pk = H(Nk)

Notation:

H(·): a cryptographic hash function
Ji: a digest of blockchain block Bi, e.g. H(Bi)
Eα: encipherment under symmetric key α; use PCBC mode if J exceeds cipher block size
Dα: decipherment under symmetric key α, matching Eα

Figure 2: Structure of the PLS protocol

6

Block Transmit

Verify

BC Action

b0
b1
b2

...

bn
bn+1
bn+2

bn+3

P1 = H(N1)
S1 = E∗
N1
LV1 = H(N2) ⊕ N1 || H(H(N2)||N1)

(H(N2), M1)

...

Out of Band (Enrolment)

—

—

...

Pk = H(Nk)
Sk = E∗
Nk
LVk = H(Nk+1) ⊕ Nk || H(H(Nk+1)||Nk) —

(H(Nk+1), Mk)

as for bn+3, assume success
—

Pk+1 = H(Nk+1)

for bn < b < bn+3:

ﬁnd ﬁrst LV such that

H(Pk+1||L ⊕ Pk+1) = V

if found in block ˆb:

unless ∃b ∈ (bn, ˆb), L(cid:48) ∈ Bb :

H(L(cid:48) ⊕ Pk+1) = Pk

else

Post

Post

Post

...

Post

Post

Post

Post

Reject

To unlock the data object Mk compute M = D∗
[bn, ˆb) and accept the ﬁrst valid M . Here E∗
with a as IV; D∗

k(a, b) is the matching decryption.

L⊕Pk+1

(Pk+1, S) for every S-message in the interval
k(a, b) is the encryption of b under key k in PCBC mode

Figure 3: Structure of the SLVP protocol. Table on behalf of a single user

7

id1id2id3…	Block	…	 id1	S	S	 id1	LV	CAS	tid1id2id3…	Block	…	…	LV	id1id2id3…	Block	id1id2id3…	Block	P	 id3	S	 id3	LV	S	LV	 id1	P	 id3	P	mechanics of transaction processing, while leaving higher-level protocol to further work. We will
assume in the sequel that each thing is interacting with a very small number of other actors and
needs to follow a few SLVP threads (perhaps 2 or 3). Our focus will be on how to make these
interactions as computationally and communicationally eﬃcient as possible.

Addresses. Each PLS user has an address, which is a small number. Since we concern ourselves
with a localised enterprise solution (e.g. a smart hospital) covered by a direct link radio network
(e.g. smart sensors equipped with a LoRa[1] transceiver), we do not expect the number of things
greater than circa 1000. The total number of actors should be a small factor of that to account for
human users and smart contracts, so 2–4K addresses is our target. Transactions have an originating
address and a destination.

Frequency.
In IoT networks of interest, communication is limited by the duty cycle to save the
limited bandwidth that all things have to share. This is in addition to the constraints imposed
by the energy budget of an individual IoT device. Consequently a small fraction (typically a few
percent) of the registered users will be posting a transaction in any given block.

3 Block structure and optimisation challenge

Immutable dictionary.
In the previous section blockchain blocks were shown in the diagrams
that consisted of records attributed to various users as key-value pairs, where the key is the user
ID. In a given block only some of the registered users would be represented by records. Since the
frequency of posting on the blockchain in our case is severely limited by the things’ communication
duty cycle (if using LoRa) or energy budget (if using public networks or LoRa), the proportion of
users posting to any given block is expected to be very small. Still, the user can only authenticate
the block by the S-message of the PLS protocol, which, when unlocked, contains the block hash.
On the other hand, as we mentioned in the previous section the user is typically interested in two
or three other users’ contributions, which, given a typical enterprise IoT network of a thousand
things, is still much less than the expected volume of activity in a block. Indeed, given a block
production rate of 4 blocks per hour and a thing data production rate of 2–4 samples per day, and
bearing in mind that each data post requires 3 blocks according to the SLVP protocol, we arrive
at 6 to 12 blocks per device per day and circa 100 blocks per day in total. This means that in
the absence of correlated activities we should expect about 5 to 10 percent of the swarm to post
in every given block. For a 1000-strong swarm, the block may contain an estimated 50 to 100 user
records authenticated by a single hash. If a thing wishes to access just a few of these, it would have
to ﬁrst read the whole block and check the hash to validate it, and then dispose of most of these
records as they would be irrelevant.

Merkle tree. The standard solution to the above problem is called the Merkle Tree(MT)[11], see
ﬁgure 4. It is a labelled binary4 tree each node ν of which has two children, with some labels νL
and νR, and its own label is ν = H(νL||νR). A child can either be a leaf or a full node in its own
right; in both cases it has a label but in the latter case it also has two children of its own. It is
quite clear that a change in any leaf will change the root label (also known as the root hash), so the

4The tree does not have to be binary, but higher-based trees, and higher-based MPTs, discussed later, are

ineﬃcient for a small number of leaves.

8

Figure 4: Merkle Tree.

authenticated root makes the whole tree authentic. For each node except the root there exists one
other node with the same parent, which we call adjunct. What makes the MT useful is that it can
also authenticate a single leaf by providing a root-path list of adjunct nodes’ labels, or root-adjunct
path for short. For example, to authenticate the leaf ν101 shown in red in the ﬁgure, given the root
label r, we only need to know the labels of the blue (adjunct) nodes: ν100, ν11 and ν0, since

r = H(ν0||H(H(ν100||ν101)||ν11)) .

Generally speaking, for a tree with K leaves one needs to communicate h = (cid:100)log2 K(cid:101) hashes, which
is much less than K for the number of leaves in the hundreds that we are considering. The tree
thus represents an array of leaves indexed by the path: a left edge represents 0 and a right edge
1; the edges traversed en route to the leaf form a bit-string that represents the key. The leaf itself
represents the value of the key-value pair.

Blocks represented as Merkle trees. Common practice in Blockchain construction is to rep-
resent a block as an MT, each leaf of which carries the hash of a user’s record included in the block,
with the user ID being the key gleaned from the leaf’s root path. A user requesting another user’s
record (or the one of its own) from an intelligent CAS could just receive the root-adjunct path
corresponding to the requested ID and hash it through to match with the root hash value. If the
PBC signs the root hash of every block it creates, no further security is required to authenticate
any user records. Our investigation is of a special case when the maximum number of users is small
and is known in advance, and where good communication eﬃciency is important. We could use an
MT with the tree height h close to 10 (to accommodate our expected 210 ∼ 1000 users). Since, as
we have mentioned earlier, we expect only around 50 (maybe up to 100) users to contribute to any
given block, a great majority of the leaves will not be used.

Mask-controllable sparse MT. The number of leaves in an MT does not have to be a power
of 2. Also leaves can have no value associated the root-path key. We can think of such leaves as
unoccupied. An MT with no-value leaves is called a sparse MT, or SMT. There are several ways of

9

r	!00	!000	!001	!01	!010	!011	!0	!1	!10	!100	!101	!11	!110	!111	organising an SMT, but proposals usually focus on mutable trees that are used for secure updatable
key-value storage. Our interest is in immutable SMTs, where eﬃciency is understood in narrow
terms as eﬃciency of retrieval only. Below we deﬁne our own version of the SMT, geared towards
our objectives.

We can assume that a leaf without value has a special label NULL and the parent of two NULL
nodes has the label NULL as well. This assumption does not diminish security due to the fact that
a NULL child of any node is implicitly associated with the node height. Consequently, the shape
of the NULL subtree associated with the child is completely deﬁned by its root position. All such
NULL trees are identical anyway, so a single label value fully represents them.

For the veriﬁer to be able to verify a path with NULL nodes, it requires a bit mask of length h,
where bit-value 1 indicates that the corresponding adjunct node is non-NULL; and the bit-value
0, that it is NULL. The NULL labels can then be omitted from the path. Finally we extend the
domain of H(x) to include NULL-concatenated strings by deﬁning that for any bit-string x

H(x (cid:107) NULL) = H(x (cid:107) x(cid:48)) ,
H(NULL (cid:107) x) = H(x(cid:48) (cid:107) x) ,

(1)

where x(cid:48) is the bit string obtained form x by ﬂipping all bits.
sion

Interestingly, a simpler exten-

H(x (cid:107) NULL) = H(NULL (cid:107) x) = H(x)

would not be secure, as it allows one to construct a second preimage by rotating the subtree or
swapping nodes along a NULL path. It is easy to see that the hashing process introduced by Eq
1 is not invariant to any such transformation. It is impossible to create a new valid SMT with the
same root hash and a diﬀerent leaf sequence without solving the second preimage problem.

If the path is mask-controlled, CAS only needs to communicate up to h hashes in addition to the
bit mask for the veriﬁer to successfully compute the root hash. Extending the above example, if
ν11 were unoccupied, CAS could supply the bit mask 101 (the second adjunct is missing in path
order), and the values of ν0 and ν100. Notice that the bit mask does not need to be secured: if it is
incorrect, the veriﬁer will compute an incorrect path expression and the result will not match the
root hash. Also notice that the mask is very small compared to the hash length: for a tree of 1024
leaves (counting both NULL and non-NULL) the root-adjunct path contains from 1 to 10 hashes
256 bits each, i.e. 256 to 2560 bis, but the mask length is only 10 bits regardless.

Merkle-Patricia Trie. The idea of mask-control path is similar to that of the so called Merkle-
Patricia Trie(MPT)[15] where not only the nodes but also the edges can be labelled. If a node has
a single active edge (i.e the other edge leads to a NULL subtree), the node is eliminated and its
parent uses the preﬁx of the other edge as its label, see ﬁgure 5. The example in the ﬁgure is of
a block where, out of the maximum 8, only users 2, 4, 5, and 7 (010, 100, 101, 111 in binary) are
present. Notice that we still have a binary tree, but the root-adjunct path augmented with edge
labels requires from one (for 010) to three (for 100 and 101) adjunct hashes for validation, depending
on the leaf. The edge labels are typically much shorter bit-strings than a single cryptographic hash
(log2 K (cid:28) 256) and so can be neglected in determining the communication eﬃciency of the access
scheme. The same is true of masks with our version of the SMT.

10

Figure 5: Merkle-Patricia Trie. All unlabelled edges are assumed to have the label ‘0’ if they lean
to the left and ‘1’ if they lean to the right.

How is the edge label secured? It is simply hashed together with its child content in determining
the node label:

ν = H(λ0||λ1||ν0||ν1) ,

where λ0,1 are the edge labels of the left and right child, respectively.

It is easy to see that there is a direct correspondence between the MPT and the SMT with mask-
controlled paths. Our construction requires more work when validating a path: each node, irre-
spective of its path quality involves h hash calculations for veriﬁcation, where h is the height of
the tree, but in the MPT case the number of times a hash is calculated is the same as the number
of adjunct hashes supplied with the MPT path, although each hash calculation also involves edge
labels, which may increase the cost. The total length of edge labels along the root path in the MPT
case is equal to the length of the mask in the SMT case. However, an MPT path requires markers
to partition the path string into individual edge labels. Our construction is slightly more frugal in
this respect, and it is simpler, which is why we prefer it.

4 Motivation and optimisation idea

It is obvious from the SLVP protocol that an actor engaging in transactions with another on
the PLSB must check each block to determine the presence of a transaction message from the
counterparty. Due to the low duty-cycle of thing-to-FS communication, the counterparty will not
be present in a great majority of blocks. However, to securely establish the absence the actor must
traverse the block and verify that the counterparty’s record is not there. In the MT case we can
use the mask-controlled path to the unoccupied leaf which can contain up to h adjunct hashes. In
the MPT case CAS will supply the longest path in the direction of, rather than to, the unoccupied
leaf. By examining the last node on that path the user will be able to verify that the necessary
edge is missing. For example, looking at the MPT in ﬁgure 5, if an actor requested the unoccupied

11

r	!00	!000	!001	!01	!010	!011	!0	!1	!10	!100	!101	!11	!110	!111	010	11	leaf 110, the one-step path r → ν1 with adjunct material will be sent back for validation:

010, 1, ν010
0, 11, ν10, ν111

The number of hashes to be communicated is the same as that for the mask-controlled MT: in the
current example the latter would require hashes ν111, ν10, and ν0. An advantage of the MPT is
that it saves the veriﬁer extra hash computations by providing segments of the path as (hashed-
controlled) edge labels. While saving some compute time, the eﬀect of it is negligible, since the
maximum root-adjunct path length is logarithmic in the number of leaves ((cid:46) 12), and a modern
microcontroller can compute tens of thousands of hashes per second. A disadvantage of the MPT
is that it requires communication of edge labels in addition to the hash for each node on the path,
but again, compared to the hash length this is negligible, too.

What is considerably more important here is that neither mask-controlled MT, nor MPT reduce
the maximum root-adjunct path length. In our example the number of leaves present is 4, but the
hight of the MPT as a binary tree is 3, not log2 4 = 2; it is as if all leaves were present. As a
result, the system would require to accommodate longer communication packets, which may aﬀect
the guaranteed duty cycle limit of an IoT device.

This brings us to the central idea of the paper: to index a block, one might prefer to locally
renumber the users to achieve a contiguous range of IDs rather than a scattering over a regular
structure with subsequent remedies such as the MPT.

However, before proceeding to our solution, we would like to evaluate the base case, the mask-
controlled MT. We would like to establish some quantitative characteristics of MT paths under a
random distribution of leaf occupancy.

4.1 Sparse MT Statistics

Let us number the levels of the MT from the leaves up, starting with 0. We will call the number
of adjunct hashes associated with a path its weight. Let function PDFk(i) of integer i be the
probability for a path from a given leaf to a hight-k node on the tree to be of weight i. Recall that
we only count nodes on the path with both children being non-NULL as those require an adjunct
hash for a Merkle proof. Let us take a closer look at an example path, see ﬁgure 6. From level
0 we move to level 1 as a left child, then to level 2 as the left child, and ﬁnally to the level 3 as
the right child. Clearly diﬀerent leaves’ paths diﬀer by the choice of left- and right- ascension at
each level, but the signiﬁcance of the node does not depend on it: the node is only counted when
both its children are non-NULL. The shaded triangles signify the subtrees that represent the other,
non-path child of the corresponding path node, which, if non–NULL, produces what we termed
above the adjunct hash. If the non-path node is NULL, this fact is noted in the path bit mask, but
no adjunct hash is produced.

At level 0, the subtree is of height 0 (it is a leaf), at level 1 it is of height 1 (connects two leaves),
etc.

Statistical model. We adopt a model relevant to the IoT case that the PLS blockchain was
developed for. A thing submits a message for inclusion in a block very infrequently. It does so at

12

Figure 6: A path across a sparse MT

random with some small probability p, whose value depends on the duty cycle restriction, urgency
of the sensor data and the available energy budget. Without loss of generality let us assume that
p ∼ 0.1 in our examples, which will give us some intuition of what kind of ﬁgures may arise in
practical work. This level of activity means that a thing participates in roughly one block out of
10 or that about 1/10 of all blockchain users are active in any given PLS round. We also assume
that the activities of diﬀerent things are uncorrelated, so any given leaf is either present or absent
(NULL) irrespective of the presence/absence of other leaves.

Path weight. The subtrees in ﬁgure 6 will consequently be NULL-valued with the probabil-
ity

αk = (1 − p)2k
where k is the level at which the subtree is rooted. Let us introduce the Probability Distribution
Function PDFk(L) as the probability for the weight of a path from level k to a leaf to be equal to
L. Clearly PDFk(L > k) = 0, and we also assume for convenience that for all k, PDFk(L < 0) = 0.
It is easy to calculate PDF1 directly:

(2)

,

PDF1(0) = 1 − p, PDF1(1) = p .

(3)

Indeed, the other child of a given leaf of a height-1 tree is NULL with the probability 1−p, producing
no adjunct hash, so L = 0 with that probability; otherwise (with the probability p) the other leaf
is non-NULL, supplying a single adjunct hash.

For a hight-k path we have a combinatorial problem of calculating the probabilities of 2k combina-
tions of absence/presence of each adjunct hash (remember that these probabilities are completely
independent as per our chosen statistical model). Instead of doing this, we observe the following
recurrence relation between the paths to neighbouring levels:

PDFk+1(i) = αkPDFk(i) + (1 − αk)PDFk(i − 1)

(4)

Indeed, if the non-path child of the height-(k + 1) path node is NULL (this happens with the
probability αk) the number of adjunct hashes that the path to height k + 1 produces is the same as
that to height k. Alternatively, if the non-path child is non-NULL, it produces one adjunct hash,
and so the probability to produce L hashes for the whole path is the same as the probability to

13

3		2		1		0		k

mean

4
= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

10

2

1

0

7

3

5

9

8

6

2
3
4
5
6
7
8
9
10

0.200
0.390
0.734
1.303
2.118
3.084
4.083
5.083
6.083

81.0
65.6
43.0
18.5
3.4
0.1
0.0
0.0
0.0

18.0
30.0
42.2
42.7
23.0
4.1
0.1
0.0
0.0

1.0
4.2
13.1
29.7
40.3
23.6
4.1
0.1
0.0

0.2
1.6
8.1
25.7
39.8
23.6
4.1
0.1

0.1
0.9
6.8
25.0
39.8
23.6
4.1

0.0
0.8
6.6
25.0
39.8
23.6

0.0
0.7
6.6
25.0
39.8

0.0
0.7
6.6
25.0

0.0
0.7
6.6

0.0
0.7

0.0

Table 1: Numerical evaluation of Eq 2–4. Probability Distribution Function (%) of path weight vs
height in a sparse MT (p = 0.1)

produce L − 1 for the path to height k. The above equation is the weighted sum of those two
outcomes, a mixture distribution.

The signiﬁcance of Eqs. 2–4 is in the fact that they permit direct calculation of the PDF at any
level above 1 very cheaply given the value of p. The PDF obtained can deliver various practical
parameters: the average path weight:

(cid:88)

¯Lk =

i × PDFk(i) ,

i

the standard deviation, the probability that a certain limit Lmax is exceeded, etc., which are useful
in designing bandwidth-limited communication protocols.

Table 1 presents the outcome of a direct calculation of Eqs. 2–4 for p = 0.1 and also includes the
value of ¯Lk in the second column (heading “mean”). The table shows the value (%) of PDFk(i),
where i runs horizontally. For obvious reasons nontrivial evolution only happens until αk drops to
small values, whereupon Eq. 4 degenerates to

PDFk+1(i) ≈ PDFk(i − 1)

making the PDF(i) shift to the right by 1 without change of shape as k increases. For p = 0.1
sparsity is present in the ﬁrst 7 levels of the tree; from level 8 up the tree becomes dense.

Another noteworthy feature of the distribution is its breadth: 95% of the paths require from 4 to
8 hashes, with the mean being around 6, which would necessitate variable length communication,
since a factor of 2 diﬀerence cannot be ignored. This variability comes despite the compression we
have already applied by introducing the bitmap-controlled MT.

The sparse MT is indexed by the user ID, and a set of active users for an individual block is random
as deﬁned by our statistical model. To get a feel of how eﬃcient the sparse MT is in terms of path
weights, we compare its mean path weight with that of a truncated dense tree carrying the same
number of non-NULL leaves. We use the least suﬃcient hight of the dense tree to accommodate
all non-NULL leaves, and place all NULLs on the right hand side of level 0, so that the non-NULL
leaves may be contiguous, and use Eqs: 1 to deal with none values (that is what we mean by
truncation). Figure 7 compares the path weights of the two trees. The dependence of the path-
weight averaged across the truncated tree on the number of non-NULL leaves is not smooth, as the

14

Figure 7: Mean path weights. The curve: sparse MT, n = 1024 leaves each occupied with probability
p. Scattered dots: the average path weight of a truncated dense MT with 2(cid:100)log2(np)(cid:101) leaves

tree hight leaps up when the number of non-NULLs crosses power-of-two boundaries. Nevertheless,
one can clearly see that the dense tree has a lighter path weight at the majority of probability
values, becoming slightly worse just before the probability reaches a value that the equivalent dense
tree must grow at.

Challenge. Now we are prepared to argue our case. A user engaging in the SLVP protocol as
veriﬁer must examine every consecutive block to see if the prover has placed a message in it (i.e. an
S-, LV- or P-message). According to our statistical model, in a great majority of the blocs, in fact,
in a factor of 1 − p of them, the prover’s message is likely to be absent. Nevertheless, the veriﬁer
needs to satisfy itself that indeed, no message from the prover is present. With the classic MT as
well as MPT and our own version of sparse MT, the absence of a leaf is almost as expensive to
prove as its presence with a particular value. The diﬀerence is that for an absent leaf the label is
NULL and it is not communicated, but that is a diﬀerence of 1 against, as our calculation shows,
circa 6 adjunct hashes to be communicated when 1024 users participate at probability p = 0.1.
This means that on average 60 (!) hashes would be required to certify the start of an SLVP round.
Worse still, each active user, even when all it does is wait for a possible signed message from a
counterparty, will be actively requesting the counterparty’s root-adjunct path from CAS every time
a block is released, which pretty much destroys the advantages of a low-bandwidth Guy Fawkes
protocol.

However, a simple remedy exists, which we consider next.

15

0	1	2	3	4	5	6	7	8	0.05	0.06	0.07	0.08	0.09	0.10	0.11	0.12	0.13	0.14	0.15	Wp5 Tunstall-Merkel Tree

Basic idea. We kill two birds with one stone by providing a one-time renumbering of users in
each block while broadcasting the renumbering information together with the root of the tree. The
purpose of the renumbering is to achieve a contiguous range of ID numbers. This way absent users
will be recognised as such immediately by any counterparty involved. As a result the cost of absence
proof will be zero (plus the cost of the one-for-all broadcast message, which need not be requested).
The indexing structure in terms of new IDs will be the kind of tree we have already studied and
shown the superior access cost of: a dense, truncated one.

How do we enumerate users that are present? Imagine a bitmap sized 2h, where h is the height
of the original (sparse) MT. In the bitmap 1s mark the presence of the corresponding user/leaf
and 0s its absence. Under our statistical model (see page 12) on average 2kp bits (as per binomial
distribution) of the bitmap will be 1s. Users are renumbered according to the bitmap: the user’s
new ID is the number of 1s in the bitmap preceding the bit that corresponds to the user’s actual
ID.

Our statistical model assumes that all users are engaged the whole time. A user that decides not
to use the blockchain for a while will not be able to maintain a factor of p messages per block on
average until the user becomes active again; the user’s bit position in the bitmap will be 0 during
that period. If there are many such users, the bitmap may have signiﬁcantly fewer 1s than the
aforementioned expectation 2kp. In this sense the expectation is pessimistic.

The maximum number of users is within a near-unity factor from the number of things in the
swarm, since non-IoT users have typically a one-to-many relation with things: a human or a server
would be in control of several IoT devices. The majority of the users tend to be always-on, active
things, which work according to a near-periodic schedule. Another useful circumstance here is that
the bitmap can be eﬀectively and eﬃciently compressed to a fraction of its length, provided that
the distribution of 1s is close to random and that the number of 1s is known to both the sender
and the recipient. The former can be made true by pseudorandomisation, and the later is easy to
achieve by including a small integer (typically 10-12 bits in length) in the message that broadcasts
the bitmap. In this section we describe the compression technique, and in the next one we will
propose a simple and eﬃcient pseudorandomisation.

Tunstall code. Given a bit string of length n which is expected to contain m = pn, p < 1 ones in
random positions (which makes p a true probability), or alternatively a bit string which is known
to contain m ones, m = pn in random positions (which makes p an empirical probability), with the
positions of ones pairwise uncorrelated (this is called a zero-order environment), we set ourselves
the task of ﬁnding a bijective function C : Bn → Brw, rw < n that maps the string to a sequence of
r codewords of length w. We wish to minimise rw, or, for a given w, to minimise r. The theoretical
limit of compression is well known from information theory: rw ≥ H0n, where the zero-order per-bit
entropy H0 is deﬁned thus:

H0 = −p log2 p − (1 − p) log2(1 − p) .

The mapping C is realised by partitioning the source bit string into (generally unequal length)
chunks and assigning a codeword to each. A chunk b0, b1, . . . , bk is found at any given position in

16

Figure 8: Tunstall Tree for p = 0.4. First two steps of the algorithm.

our random string with the likelihood

pc =

k
(cid:89)

i=0

pbi(1 − p)1−bi .

(5)

The best code with the word length w should assign its 2w codewords to the 2w chunks with the
highest likelihood. It must also make sure that the code is complete, i.e. any bit sequence can be
represented as a sequence of codewords. It is intuitive that such a code would be optimal, and it
can be proven that it is also asymptotically eﬀective, i.e. that its compression ratio tends to the
entropy limit as w tends to inﬁnity.

It is not easy, however, to turn Eq. 5 into a practical encoder/decoder. The main reason for it is
that the value of k is not bounded, and neither is the search for suitable chunks to ﬁnd the top 2w
ones in terms of their likelihood. The problem is not so much the amount of work required for the
search, since we could take the logarithm of Eq 5 and maximise the linear form

log pc = l log p + (k − l) log(1 − p) ,

(6)

where

l =

k
(cid:88)

i=0

bi ,

in the (0 ≤ l ≤ k, k > 0) area of the (l, k)-plane starting at the maximum (0, 1). The problem is
(cid:1) chunks of length k with l 1s in each. Their enumeration
that each (l, k) point corresponds to (cid:0)k
and mapping at diﬀerent k would be rather awkward.

l

Tunstall in his PhD thesis[13] proposed a greedy search which at the same time builds a compact
dictionary structure (the Tunstall tree) that can be used for encoding/decoding eﬃciently, without
sharing the dictionary (as long as p is known to both the encoder and the decoder). The greedy
search turns out to be of excellent quality, too, delivering the entropy limit asymptotically[13], and,

17

1−p0	1	p1−p0	1	p0.4								0.6	(1−p)20	1	p(1−p)0.24									0.36	0.4	1−p0	1	p(1−p)20	1	p(1−p)0.24									0.36	p(1−p)0	1	p20.16									0.24	startstep 1step 2as a recent study shows [9], with a rapidly decreasing redundancy as w increases. The redundancy
formula from [9] being useful for our analysis, we present it below (without derivation and rewritten
in our notation):

rw ≤ nH0 + O(nH0

log(1/p)
w

) .

(7)

We will return to Eq 7 later and present our own measurements for the relevant range of parameters,
but let us ﬁrst introduce the dictionary idea, see ﬁgure 8. The dictionary is a (generally imbalanced)
labelled binary tree. Both the nodes and the edges are labelled. The edge labels are 0 and 1 as usual,
and a node’s label is the likelihood value of the chunk composed by reading the edge labels along
the path from the root to the node. The algorithm builds the tree node-by-node, as follows:

1. Create a root node with two edges labelled 1 and 0 to two child nodes labelled with the value

of p and 1 − p, respectively.

2. Find and mark the maximum likelihood leaf node. Denote its label as R.

3. Create two leaf children of the marked node and connect them with edges labelled 1 and 0.

Make the node labels the value of Rp and R(1 − p), respectively.

4. Repeat steps 2 and 3 until the tree has 2w nodes besides the root.

5. Now relabel each leaf by its consecutive leaf number while visiting the leaves in some order

agreed between the encoder and decoder5.

Tunstall encoding is achieved by running the source bit-string down the Tunstall tree bit by bit until
a leaf is reached, at which point the codeword is read oﬀ from the leaf label and the process returns
to the root. Tunstall decoding requires a 2w-entry table where variable-length path sequences are
set against codewords, with the former read oﬀ from the path to the leaf labelled by the latter. We
notice with satisfaction that Tunstall decoding has the cost O(1).

Implementation. Tunstall encoding (and especially decoding) is very undemanding, well within
reach of a small, system-on-chip smart sensor. To avoid accuracy/underﬂow problems with repeated
multiplication in generating the dictionary at the receiver (Step 3 of the algorithm above), one could
use log-likelihoods as node labels. Then instead of multiplication, log p and log(1 − p) are added to
the parent label to produce labels for the 1- and 0-child, respectively6. This way for any reasonable
table size, computational accuracy will not be a problem. We implemented the algorithm to see
what kind of residual redundancy we could be getting from a speciﬁc Tunstall code. The results
of our running a Tunstall compressor through 1 million random bits are presented in table 2.
Comparing this with Eq 7, we conclude that at p = 0.05 the compressor already reaches asymptotic
mode when doubling the codeword length roughly halves the redundancy ρ. At the same time,
the dependency ρ(p) in the interesting range of p, i.e.
in the area around p = 0.1 is not quite
asymptotic: the contrast in redundancy between p = 0.05 and p = 0.15 is nowhere near a factor of
2 that the formula suggests.

From the practical point of view, if we target a blockchain with ∼ 1K users, with 10% of them
posting messages in any given block, p = 0.1 suggests a compressed bitmap of at least 1024 × 0.47 =

5For example, left to right, or in preﬁx order. The properties of the code remain the same under any permutation

of the codeword assignments but the practicalities of encoding/decoding require a shared order

6We use the fact that the greatest number has the greatest logarithm

18

w
4
4
4
8
8
8

p
0.05
0.10
0.15
0.05
0.10
0.15

κ
0.37
0.50
0.65
0.32
0.49
0.63

H0
0.29
0.47
0.61
0.29
0.47
0.61

ρ(%)
30.4
7.5
6.9
13.4
4.6
3.8

Table 2: Observed redundancy ρ of Tunstall code. Sample length before compression: 106. Column
headers: w, codeword length; p, probability of 1; κ, compression ratio; H0, per-bit entropy; ρ =
(κ − H)/H, residual redundancy(%)

codeword − log2 pc

0000
0001
0010
0011
0100
0101
0110
0111
1000
1001
1010
1011
1100
1101
1110
1111

3.06
5.55
5.32
5.08
4.85
4.61
4.38
4.14
3.91
3.67
3.44
3.20
3.20
5.70
2.97
5.47

chunk
0000000000000
0000000000001
000000000001
00000000001
0000000001
000000001
00000001
0000001
000001
00001
0001
001
010
011
10
11

Table 3: 4-bit Tunstall code for p = 0.15

482 bits or 61 bytes. An 8% residual redundancy would increase this by only 5 bytes. However,
the bitmap is broadcast together with the root hash, 32 bytes long, and a few extra bytes of forced
redundancy for the purposes of S-message veriﬁcation (as per PLS protocol). This increases the
length of the S-message up to nearly 100 bytes, and at this level a redundancy of the compressor
to the tune of 5 to 10 bytes makes little diﬀerence.

If the number of users drops to 0.05, even the poor compression quality for w = 4 results in only 379
bits (though 82 bits, or 11 bytes, more than the entropy limit), which is still less than the already
acceptable 482 bits we observed for p = 0.1. An alternative is to use a list of raw ID numbers, circa
52 in total, each requiring 10 bits. This is 520 bits, far worse than the compressor’s output, but
not signiﬁcantly worse than 482, and the list length would decrease in proportion to p. If p were
to drop further below 0.05, and if the Tunstall compressor further deteriorated, the uncompressed
‘list’ option could at some point be preferred, with the switch controlled by a single additional bit
in the message.

19

oﬀset
(bits)
0

256
280

ﬁeld

Ti

n,m
ﬂags φ

size
(bits)
256

24
8

288
L + 288

bitmap M L ≤ 1024
redundancy

32

description

root hash of the Merkle Tree for the new block Bi
built using new user-IDs
n: total number of users, m: how many present
bits 0,1: bitmap type (plain, compressed, list, empty)
bit 2: (0: w = 4, 1: w = 8)
bits 3–7: pre-randomisation parameter (see next section)
processed bitmap content
all zeros, for PLS validation

Table 4: Structure of the proposed block root-of-trust Ji

We conclude that a four-bit Tunstall code is all that is required to implement the PLS S-message
within half of the maximum LoRa message length (250 bytes). To aid the reader’s intuition,
we present an example of a 4-bit Tunstall code for p = 0.15 in table 3. For each codeword we
additionally show its log-likelihood. Notice that unless the log-likelihoods are exactly identical, as
is the case for codewords 1010 and 1100 which correspond to chunks with the same number of 1s
and 0s, the diﬀerences between log-likelihoods manifest themselves in the ﬁrst (decimal) fractional
digit already, so computational accuracy should not be a concern7.

New structure of the root of trust.
In the original PLS protocol [12] the S-record was a
message that contains the block’s root of trust Ji, which was the root hash of the Merkle tree
representing the new block Bi. In the light of our analysis of indexing costs presented in Section
4.1 and the properties of Tunstall encoding described in the current section, we propose to modify
the root of trust Ji as shown in Table 4.

The total message length is L+320 bits or L+40 bytes. We expect L to be close to 60 bytes in most
cases (which is the entropy limit for 1024 users at 10% occupancy per block on average), which makes
the S-message circa 100 bytes long, but if necessary L can be increased to 128 bytes resulting in the
packet length 168 bytes, still well within the length limit (255 bytes) for LoRa communications. A
128-byte bitmap would support the number of users up to 1024 without Tunstall compression, or
about twice as many if Tunstall compression is used at 10% occupancy.

The hash T requires the server to renumber the users, building a new Merkle tree and computing
its root hash. The client will recompute T from any leaf hash, adjunct hashes and the path mask
– all sent to it by CAS (unauthenticated, unsigned) at request, and then check it against the T in
the S-record.

Notice that the redundancy ﬁeld is only 32 bits, since it is impossible to crack the S-message
directly: both the plaintext and the key are unknown, the former due to the XORing of the next
P-message, yet to be received, to the plain text, see Figure 2. As mentioned earlier, the purpose of
the redundancy ﬁeld is to thwart a random message attack for the DoS purposes, and so a 32-bit
redundancy translates into a less than 1-in-a-billion chance to cause the recipient to accept a false
message, which is more than suﬃcient in the IoT world.

7the main danger would be that the sender and the receiver use diﬀerent ﬂoating-point arithmetic, incur diﬀerent
rounding errors and end up using diﬀerent dictionaries; this example shows that for a small dictionary there is no
such danger

20

Finally, let us dwell a little on the block’s MT whose root Ti is included in the block’s root-of-trust
Ji. The leaves of that tree are hashes of the user records with the user ID corresponding to the
path label sequence as usual, except the IDs are now new IDs calculated from the block bitmap
and occupying a range from 0 to m − 1 without gaps. Since m is not necessarily a power of 2,
the MT generally consists of a complete half with leaf labels in the interval [0, 2(cid:98)log2 m(cid:99)) without
gaps and a truncated half with labels in the interval [2(cid:98)log2 m(cid:99), m), also without gaps, with the
rest of the leaves labelled with NULL. The shape of the MT depends solely on one parameter, m,
which is part of the root-of-trust. Consequently, no further information, such as path masks, etc,
is required for access and validation of the root hash, Ti, except, of course, we must use Eqs. 1 to
calculate the root-adjunct paths in the truncated half. For our running example of 10% occupancy
and the total number of users 1024, the value of m will have an expectancy of around 102, which
means this path will be between 1 and 7, and never longer. Table 1 indicates that the standard
(MPT or mask-controlled MP) would require from 3 to 9 adjunct hashes. The diﬀerence between
7 and 9 is not big, but notice that 8 hashes would already require more than one LoRa packet to
transmit.

We would like to emphasise here that the main eﬀect of using the Tunstall-Merkle Tree (TMT,
which is how we wish to call our construction) rather than, say, MPT is not that fewer hashes have
to be communicated with the former than the latter, but the fact that the latter requires a full path
irrespective of the presence or absence of the leaf for secure retrieval. By contrast, a TMT provides
an absence proof directly from the root-of-trust bypassing the Merkle Tree entirely. Since the SLVP
protocol requires every thing to check the presence of its own S- and LV- messages before advancing
the protocol, and since a thing would typically monitor another user’s infrequent activity, the cost
of absence proof dominates over the cost of secure retrieval. Nevertheless, it is reassuring to see
that the latter is also improved, in terms of limits if not necessarily average, by our approach. The
price we are paying is some additional calculations well within the capabilities of resource-limited
systems such as most things tend to be.

Returning to the compression issue, there is one factor yet to be accounted for. We remarked
earlier that our statistical calculations are based on the zero-order assumption, i.e. that diﬀerent
users’ behaviours are uncorrelated. Obviously it is not the case when users engage in a higher-level
protocol with one another, e.g. producer/consumer. This may skew the chunk statistics resulting
in a longer codeword sequence for the block bitmap. In the next section we will propose a simple
remedy.

6 Pre-randomisation

The idea is to apply a bijective function to the source user ID which depends on an extra parameter,
block number i. A diﬀerent block number should result in a very diﬀerent permutation. This way a
position in the block bitmap will have the value 1 in a proportion of bitmaps that does not depend
on the value of other positions. A user ID will be associated with a pseudorandom sequence of
positions as new blocks are produced.
Invertibility (bijection) is very important, as it prevents
diﬀerent users from being mapped on the same bit-position in the bitmap, thus ensuring that the
mapping a pseudorandom permutation.

A simple and eﬀective pseudorandom permutation based solely on the block number i can be
achieved by analogy with randomising the order in a deck of playing cards. One player performs

21

the deck shuﬄe:
i = idid−1 . . . i0, the new position of the card i(cid:48), represented in binary as i(cid:48)
from the current position by applying the following operator

for the card in position i in the deck i ∈ [0, n = 2d) represented in binary as
0 is obtained

d−1 . . . i(cid:48)

di(cid:48)

di(cid:48)
i(cid:48)

d−1 . . . i(cid:48)

0 = id−1id−2 . . . i0id = σ(i) ,

which is a cyclic shift left. This corresponds to dividing the deck into two halves and interleaving
them, exactly as an experienced dealer would.

When the shuﬄe is ﬁnished, the other player shifts the deck, i.e. divides it into two unequal parts
and transposes them. In terms of card numbers, this corresponds to adding a pseudorandom value
v modulo 2d:

i(cid:48) = i + v mod n = τv(i)
Applying the shuﬄe-shift operator Qv = σ ◦ τv to a range ρ = [0, n) t times with a pseudorandom
choice of v:

Qvt . . . Qv1 Qv0 ρ
has the same eﬀect as repeatedly shuﬄing/shifting a deck of cards, which, the intuition suggests,
delivers a rather arbitrary permutation. We call t the number of rounds.

Note that the operators σ and τv have a negligible cost even when executed by the least powerful
platform, as they take literally a few machine instructions. The cost of pseudorandom generator that
produces a series of v-values is similarly small if we use a standard Linear Congruential Generator
(LCG):

vk+1 = F × vk + 1 mod n, 0 ≤ k < t ,
where n is a power of 2, v0 is set to the block number, and the factor F is any positive integer that
satisﬁes the well-known Hull-Dobell constraint: F = 5 mod 8. We chose for F the hex value 5EED
which satisﬁes the constraint and which has more than enough signiﬁcant digits for any reasonable
n.

Our solution appears quite attractive from the point of view of its cost; however, while bijectiveness
is guaranteed by construction, we need to be reassured that the solution can deliver suﬃcient
randomness of mapping at a reasonably small number of rounds t.

Avalanche test. How do we judge the quality of a pseudorandom mapping? A common test is
based on the so-called avalanche criterion[14], used in evaluation of symmetric ciphers and hash
functions. We consider it next in relation to our mapping Q.

Select the block-number v0 for the test. Next, select a number x from the range ρ and some integer
0 ≤ k < d and prepare two numbers x1 = x and x2 same as x1, except bit k of it is ﬂipped. Apply
the mapping Q to both and take the bitwise XOR of the results: Ai(x, k) = Q(x1) ⊕ Q(x1). Let
Ai(x, k, l) be the lth bit of Ai(x, k). Deﬁne the correlation matrix Kkl thus:

Kkl = (cid:104)Ai(x, k, l)(cid:105)x,i ,

(8)

Here the averaging is done over values of x ∈ ρ and block numbers v0. Good randomness of the
mapping manifests itself in the closeness of all matrix elements of Kkl to 1/2:

max
kl

(Kkl − 1/2) (cid:28) 1/2 .

(9)

22

d
10
10
10

t
100
150
200

δ
0.061
0.014
0.008

d
11
11
11

t
100
150
200

δ
0.113
0.026
0.009

d
12
12
12

t
100
150
200

δ
0.164
0.042
0.013

Table 5: Avalanche test of the pre-randomiser. d:
mapping quality, δ = maxkl(Kkl − 1/2), see Eq 9

input length (bits), t: number of rounds, δ:

This means that if we ﬂip a random bit in a random value x the probability that any bit in the
image of x under Q ﬂips in response is close to 1/2. In other words, if we ﬂip one bit in x, on
average close to one half of the bits in the result will ﬂip. The name “avalanche eﬀect” is to do
with the fact that small changes cascade through the rounds of the computation causing further
changes until all bits of the result are aﬀected in a complex and unpredictable, though of course
deterministic, way.

We have applied the avalanche criterion to our proposed randomiser to estimate the acceptable
minimum value of t, the number of rounds. As it is impossible to average over all potential values
of the block number v0, we limited ourselves to 50 random samples taken from the interval [0, 10000]
The results have proven quite insensitive to the averaging over v0, which in not surprising given
that we established that the required t-numbers are in the hundreds. The averaging over x was
done by sweeping the whole range ρ.

The results of the avalanche test are presented in Table 5. For practical purposes we limited ourselves
to n = 1024, 2048 and 4096, since more users are unlikely to be supported by the communication
infrastructure of a single site. The results show that a surprisingly large number, around 200, of
rounds is required to achieve good randomisation. It is large compared to the number of rounds
one expects to be necessary to randomise a deck of cards (of the order of 10), but it is not large
technically: a microprocessor would have to execute only a few thousand instructions to compute
the image i(cid:48) given i. This has to be done as many times per block as the number of counterparties
that the user has to monitor on the blockchain. For a thing this would be a number of the order
unity, hence the cost would be negligible even on a tight energy budget. On the other hand, setting
t to 200 would ensure that possible correlations between bits in the image do not exceed 3% (0.013
normalised by 1/2), which should be good enough for practical purposes.

Finally, let us recall that the IoT platform is low-power, but the server running the PLS protocol
via the Sequencer is not. It has ample capacity to analyse the quality of the permutation in terms
of its inﬂuence on Tunstall compression. We have reserved 5 bits in φ to pass to the shuﬄe-shifter
an integer value in the interval [0, 32). It is convenient to use the value 0 to indicate that a random
permutation is not required8, whereas a nonzero value is added to the round counter t. The server
can try up to 31 additional rounds and choose the one that gives the best compression. The users
receiving the root of trust will be aware of how many additional rounds should be performed and
will maintain consistency.

23

Figure 9: Retrieving a user record from block 269 for ID= 45; for this block m = 5.

Figure 10: Obtaining proof of absence.

24

     Tblock						i = 26920	user	45shuffle-shifter	45	  0000 0100 0010 0101 0000 1000 0010          0     1   2 3      4      5 0	1	2	3	4	5	CAS	!	Tunstall	decoder!	n,!	n,m	PLS	protocol	S-message	for	block	269	n,m,!	block	bitmap	0	4	8	12	16	20	24		Tblock						i = 30523	user	17shuffle-shifter	17	  0000 0011 0000 1000 0001 0000 0100           01      2       3       4  !	Tunstall	decoder!	n,!	n,m	PLS	protocol	S-message	for	block	305	n,m,!	block	bitmap	0	4	8	12	16	20	24	7 Putting it all together

Next we consider a complete example of a user attempting to retrieve a contribution to a block
that has been made either by itself or a counterparty.

Figure 9 presents the ﬂow of data when a block-269 S-message is received and successfully unlocked
by a user. The user is about to request the contribution to block 269 from user ID 45. To accomplish
this, it needs to decode the received block bitmap by feeding it to the Tunstall decoder together
with the parameters n and m (total number of users and the number of users contributing to block
269, respectively). The decoder produces the uncompressed bitmap. At the same time the user ID
(45) and the block number (269) along with the total number of users and conﬁguration parameters
are fed to the shuﬄe-shifter, which will extract the number of additional rounds from φ and produce
its output value, 20. The bit in position 20 of the uncompressed bitmap happens to be 1, which
means that the contribution from ID 45 is present in block 269. The number of 1s in the bitmap
to the left of position 20 is 4, so the index in the truncated Merkle tree for the contribution in
question will be 4. The path to leaf 4 is highlighted in red in the ﬁgure.

The user’s CAS request will include the block number, 269, and the ID index, 4. CAS will respond
with the leaf hash h4 and the adjunct sequence

V0 = h5, V2 = H(H(h0 (cid:107) h1) (cid:107) H(h2 (cid:107) h3)) ,

which consists of the labels of the two nodes of the tree marked in blue. Because the user acquired
m from the unlocked S-message, i.e. the root of trust, it knows the shape of the tree. Consequently,
no mask is communicated, but the user is able to reconstruct the mask anyway.

To validate the requested h4, the user checks that the following equation holds:

H(V2 (cid:107) H(h4 (cid:107) V0) (cid:107) H(h4 (cid:107) V0)(cid:48))) = T .

where T is the root hash received with the unlocked S-message.

An alternative scenario is shown in ﬁgure 10. When attempting to retrieve the contribution of
user ID=17 to block 305, it turns out that the output of the shuﬄe-shifter points to a 0 in the
uncompressed block bitmap. Since the unlocked S-message is the root of trust, this constitutes a
proof that block 305 has no contribution from user 17. Notice that CAS is not involved in the
process at all.

8 Related work

The PLS blockchain and the protocols in basic form were proposed in [12]. The idea of sparse Merkle
Tree has an unclear origin. To the best of our knowledge it was ﬁrst put forward by Bauer[5] and
was recently improved on in [6]. Both studies are concerned with mutable trees, with objectives
very diﬀerent from ours, although, like ourselves, the authors remark on the importance of proofs of
absence (non-membership). Tree statistics is tackled theoretically in [4] in the context of optimising
mutable MTs for the Bitcoin blockchain in the context of Bitcoin transactions. The objectives of
this study are similar to ours as the authors attempt to group the leaves together to minimise the

8This could be advantageous when, for example, no compression is used.

25

proof length, but they do it using tree transformations (taking the data structure red-black tree as
a starting point), while we achieve a similar objective by renumbering the keys (user IDs in our
case).

The compression technique we use is due to Tunstall [13] and this seems to be uniquely suitable
for our case since it is based on empyrical probability of leaf occupancy, which is available to the
Fog Server running PLS and which takes next to no resources to communicate to the client. The
eﬃciency of our technique depends on this method.

We used our own pseudorandom permutation as a combination of a perfect shuﬄe and a random
shift, using a classical LCG source [10]. There exist various methods of pseudorandom permutation,
an oft-cited one being Fisher-Yates shuﬄe[8], ﬁrst published in the 1930s (citation unavailable). The
idea there is to choose a (pseudo)random element of a sequence of source items and exchange it
with the ﬁrst element on the sequence. Clearly, if this is repeated enough times then any possible
permutation could be achieved9. A recent paper [3] presents a fast, parallel algorithm that mimics
the technique of merge-sort except the merge makes a pseudorandom choice when ordering two
elements for the output.

However, our situation is quite diﬀerent. Not because we are dealing with a contiguous range of
numbers rather than an abstract sequence of objects: one could enumerate the objects and the
problem would boil down to the one we are faced with. Our situation is diﬀerent because the
sender and the recipient must choose the same permutation. To encode an arbitrary permutation
of n numbers would take close to (m − 1) log2 m bits, which is the same order of magnitude as the
block bitmap we are trying to make more compact. Of course the ability to perform an arbitrary
permutation is not required: all we want is break correlations between user IDs in a series of block
bitmaps, and for this any suﬃciently rich subgroup would do.

Conclusions

Statistical analysis of a sparse Merkel Tree under the assumption of uniform, uncorrelated leaf
occupancy has been presented. The model obtained allows direct computation of the Probability
Distribution Function for path lengths given the leaf-value probabilities. The path weight was
quantiﬁed in terms of the number of adjunct hashes required for its leaf proof. We determined that
the mean path weight of a sparse MT tree is close to that of a dense, truncated MT tree, with the
latter being slightly better at most leaf-probability values p in the practically interesting interval.
We proposed an alternative structure, a Tunstall-Merkle tree, which combines a dense, truncated
MT and a Tunstall-compressed bitmap indicating leaf ocupancy. We tested the compressor at
several practical values of code size and quantiﬁed its residual redundancy. We found that a very
small code table (16 or 256 codewords) proves suﬃcient for achieving near-limit compression, which
means that Tunstall decoding presents no storage problem whatsoever to an IoT platform. To
improve the eﬀect of compression we further proposed a decorellation facility in the form of a shuﬄe-
shifting algorithm and tested its properties using the standard avalanche criterion to determine the
number of rounds. Both the Tunstall decoder and the shuﬄe-shifter with the codes size and the
number of rounds, respectively, suﬃcient for our purposes are quite processor-eﬃcient as well, since
they involve inexpensive operations (table indexing, cyclic shift and binary addition) and short
instruction sequences in implementation.

9unless the pseudorandom generator producing the selections is caught in a cycle ﬁrst

26

The main eﬀect of the proposed technology is a drastic improvement in the cost of the SLVP proto-
col. Indeed an SLVP veriﬁer has to check every block for the presence of counterparty (prover) con-
tributions, and no such contribution would be present in a great majority of blocks. Our proposed
Tunstall-Merkle tree has zero proof-of-absence cost, and when a leaf is present the communication
cost of retrieval is in most cases better than that for the standard MT and MPT. Obviously our
technique oﬀers no advantage to a system with an unlimited and dynamic number of users, but it is
beneﬁcial for at least the PLS blockchain situation. The statistical analysis of a sparse MT/MPT
has signiﬁcance beyond the area of our study; it could be useful for planning and designing any
secure storage structure that involves Merkle trees.

Future work will concentrate on higher-level protocols which control the interaction of things with
a smart contract within the same limited-resource set of assumptions.

References

[1] LoRa and LoRaWAN: A Technical Overview. Technical report, Sentech Corporation, December

2019.

[2] Ross Anderson, Francesco Bergadano, Bruno Crispo, Jong-Hyeon Lee, Charalampos Mani-
favas, and Roger Needham. A new family of authentication protocols. SIGOPS Oper. Syst.
Rev., 32(4):9–20, October 1998.

[3] Axel Bacher, Olivier Bodini, Alexandros Hollender, and J´er´emie Lumbroso. Mergeshuﬄe: A
very fast, parallel random permutation algorithm. CEUR Workshop Proceedings, 2113:43–52,
2018.

[4] Bolton Bailey and Suryanarayana Sankagiri. Merkle trees optimized for stateless clients in

bitcoin. IACR Cryptol. ePrint Arch., 2021:340, 2021.

[5] Matthias Bauer. Proofs of zero knowledge. CoRR, cs.CR/0406058, 2004.

[6] Rasmus Dahlberg, Tobias Pulls, and Roel Peeters. Eﬃcient sparse merkle trees - caching
strategies and secure (non-)membership proofs.
In Billy Bob Brumley and Juha R¨oning,
editors, Secure IT Systems - 21st Nordic Conference, NordSec 2016, Oulu, Finland, November
2-4, 2016, Proceedings, volume 10014 of Lecture Notes in Computer Science, pages 199–215,
2016.

[7] Espressif Systems. ESP32 Technical Reference Manual. Available as https://www.espressif.
com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf.

[8] R. A. Fisher and F Yates. Statistical Tables for Biological, Agricultural and Medical Research.

Oliver & Boyd, Edinburgh and London, 6th edition, 1963.

[9] Seungbum Jo, Stelios Joannou, Daisuke Okanohara, Rajeev Raman, and Srinivasa Rao Satti.
Compressed Bit vectors Based on Variable-to-Fixed Encodings. The Computer Journal,
60(5):761–775, 12 2017.

[10] Derrick H. Lehmer. Mathematical methods in large-scale computing units. In Proceedings of the
Second Symposium on Large Scale Digital Computing Machinery, pages 141–146, Cambridge,
United Kingdom, 1951. Harvard University Press.

27

[11] Ralph C. Merkle. A digital signature based on a conventional encryption function. In Carl
Pomerance, editor, Advances in Cryptology — CRYPTO ’87, pages 369–378, Berlin, Heidel-
berg, 1988. Springer Berlin Heidelberg.

[12] Alex Shafarenko. A PLS blockchain for IoT applications: protocols and architecture. Cyber-

security, 4(1):4, 2021.

[13] B.P. Tunstall. Synthesis of noiseless compression codes. PhD thesis, Georgia Tech, 1967.

[14] A F Webster and S E Tavares. On the design of s-boxes.

In Lecture Notes in Computer
Sciences; 218 on Advances in Cryptology—CRYPTO 85, pages 523–534, Berlin, Heidelberg,
1986. Springer-Verlag.

[15] Cong Yue, Zhongle Xie, Meihui Zhang, Gang Chen, Beng Chin Ooi, Sheng Wang, and Xiaokui
Xiao. Analysis of indexing structures for immutable data. In Proceedings of the 2020 ACM
SIGMOD International Conference on Management of Data, SIGMOD ’20, page 925–935, New
York, NY, USA, 2020. Association for Computing Machinery.

28

