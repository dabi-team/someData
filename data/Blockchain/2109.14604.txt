1
2
0
2

t
c
O
1
1

]

C
D
.
s
c
[

2
v
4
0
6
4
1
.
9
0
1
2
:
v
i
X
r
a

Fast B4B: Fast BFT for Blockchains (”patent pending”)

Mohammad M. Jalalzai
The University of British Columbia

Chen Feng
The University of British Columbia

Victoria Lemieux
The University of British Columbia

Abstract

Low latency is one of the desired properties for partially
synchronous Byzantine consensus protocols. Previous
protocols have achieved consensus with just two com-
munication steps either by reducing the upper bound on
the number of faults the protocol can tolerate ( f = n+1
5 )
or use of trusted hardware like Trusted Execution En-
vironment or TEEs. In this paper, we propose a proto-
col called VBFT, in which the protocol achieves consen-
sus in just two communication steps. VBFT can tolerate
maximum number of faults a partial BFT consensus can
tolerate ( f = n−1
3 ). Furthermore, VBFT does not require
the use of any trusted hardware. The trade-off for this
achievement is that at most f nodes nodes may revert
their blocks for small number times. We show that this
reversion of a block will not compromise the safety of
the protocol at all, yet it may incur a small amount of
additional latency during view change.

1

Introduction

Consensus has been a long-studied problem in dis-
tributed systems [1, 2]. Consensus protocols may either
tolerate crash faults [2, 3, 4, 5] or Byzantine faults (ar-
bitrary faults) [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]. There
has been proposals on fast crash failure tolerant proto-
cols that can achieve consensus in just one round trip
(RTT) or two communication steps [3,4,5,16] during fast
path when certain conditions meet (e.g., no dependency
among transactions).

On the other hand, Byzantine faults are arbitrary faults
that include not only crash failure but also more se-
vere faults including software bugs, malicious attacks,
and collusion among malicious processors (nodes), etc.
Byzantine fault-tolerant protocols achieve fault tolerance
by replicating a state, which is often referred to as State
Machine Replication (SMR) in the literature. BFT-based
protocols have been used in intrusion-tolerant services
[17, 18, 19, 20] including databases [21]. Recently, BFT-
based consensus protocols have been actively used in

blockchain technology [7, 8, 9, 10, 22, 23, 24, 25]. In all
of these use cases, the underlying BFT protocol must re-
main efﬁcient. More speciﬁcally, the protocol response
time should be fast. This helps the client requests to
get executed and responses returned to the client faster,
thereby greatly improving the client experience.

In BFT-based consensus protocols, one of the most
important aspects that affect the protocol latency is the
number of communication steps. This is even more im-
portant when the protocol operates in a WAN (Wide-
Area-Network) environment, as the latency for each
communication step might be several hundred times
higher than the LAN (Local-Area-Network) environ-
ment.

Generally, BFT-based consensus protocols in the par-
tially synchronous mode1 either operate in three com-
munication steps [6, 12, 26] or more [7, 10, 23, 27] during
normal execution or in the absence of failure. Here, the
normal execution latency is an important metric because
the worst-case latency of partially synchronous BFT con-
sensus protocols can be unbounded. Moreover, failure
(which leads to view changes) is often a rare event in
practice. Hence, BFT-based consensus protocols that op-
erate with just two communication steps are regarded as
fast BFT consensus protocols [28, 29, 30].

The proposals in [28] can reach consensus with two
communication rounds if all the nodes 3 f + 1 ( f is the
upper bound of the number of Byzantine nodes) in the
network are honest. Hence, these protocols lack re-
silience against Byzantine faults. Fast-BFT [29] is an-
other protocol that can achieve consensus in two com-
munication steps, but the maximum number of Byzantine
faults it can tolerate during worst case is small f = n−1
5 .
Another recent proposal [31] has further improved the re-
sults of [29] and shown that Byzantine consensus can be
achieved in two communication steps where maximum
faults tolerated is f = n+1
5 . A concurrent but similar

1There is an unknown maximum bound on the message delay

1

 
 
 
 
 
 
work to [31] is presented in [30]. The authors of this
work revisit optimal resilience for fast Byzantine con-
sensus and present a tight lower bound for the resiliency
n = 5 f − 1 (where f = n+1
5 ) for fast Byzantine protocols.
MinBFT [32] uses trusted hardware TEEs (Trusted Ex-
ecution Environment) to prevent equivocation attack 2.
Although TEEs are considered to be secure, some recent
work (e.g., [33]) raises legitimate concerns about the se-
curity of TEEs by identifying several vulnerabilities.

In this paper, we propose a fast BFT-based consensus
protocol called VBFT that can achieve consensus dur-
ing normal execution with n = 3 f + 1 nodes. Hence,
it tolerates the maximum number of Byzantine faults
( f = n−1
3 ), thereby providing the best possible resilience
achieved by a partially synchronous Byzantine proto-
col [34]. Therefore, the resiliency achieved in this pro-
tocol is optimal. Moreover, it does not require the use
of any trusted hardware e.g., TEEs. Like any optimiza-
tion, there is a trade-off for this improvement. In short,
the trade-off is that there may be a small latency incur-
ring during the view change process (two communication
step)3.

Moreover, there is a possibility that at most f num-
ber of honest nodes may revoke their committed block
for limited number of times at worst case (during the
protocol lifetime) until at most f Byzantine nodes are
blacklisted. It should be noted that these revoked trans-
actions will not be considered committed by the clients.
Hence, there won’t be any double-spending 4. In other
words, revocation can only delay the commitment of the
transaction for some time. The revocation is only possi-
ble if the primary node performs equivocation (propose
multiple requests for the same sequence). Since equiv-
ocation attacks can easily be detected, hence, the culprit
primary can be blacklisted. Therefore, after blacklisting
f Byzantine primaries, there will be no Byzantine node
left. Hence, in the future, no equivocation will take place.
We present the VBFT protocol in this paper in the con-
text of blockchains. But VBFT consensus protocol can
simply be adapted for other use cases too. VBFT proto-
col exhibits the following properties:

• Optimal latency during normal protocol execution.

• Practical throughput, comparable to the state-of-

the-art consensus protocol.

• Simple by design.

2An attack during which a malicious primary/leader proposes mul-

tiple blocks for the same height.

3Though this trade-off can be addressed by piggybacking a constant

size message during view change.

4A request is considered committed by a client, which is then later

revoked.

2 Background

In PBFT [6] consensus protocol, initially, the primary
node broadcasts the proposal. Then there are addi-
tional two rounds of the broadcast before an agreement
is reached (overall three communication steps). The ﬁrst
round of broadcast is to agree on a request order. Once
nodes agree on the sequence for the request, then the
request will be assigned the same sequence even if the
primary is replaced (view change). Whereas the second
round uses broadcast to agree on committing or execut-
ing a request. The two-round broadcast is used to pro-
vide a guarantee that if at least a single node commits
a request then after recovering from a view change all
other nodes will commit the same request. This is due
to the reason that if a single node completes the second
round of broadcast (hence commits the request), then at
least the other two-third of nodes have completed the ﬁrst
round of broadcast. Hence after the view change, these
two third nodes make sure the request that has been com-
mitted by at least by a single node will be proposed again
in the same sequence by the next primary. This means the
ﬁrst round of broadcast is only necessary for the presence
of a failure that will result in the view change. Therefore,
this additional round during normal protocol operation
can be removed. But if the ﬁrst round is removed, this
means agreement on the requested order and commit oc-
curs in a single round. This is ﬁne during normal protocol
execution. But during view change, if at most f honest
nodes have committed a request b, there is no guarantee
that the request will be committed in the same sequence
when the new primary is in charge. To avoid this, we in-
troduce a recovery phase at the end of the view change to
recover a request b that has been committed by at most
f nodes.
In this way the new primary will be able to
propose the next request, extending b.

But there is also the problem of equivocation by a
Byzantine primary.
If the Byzantine primary proposes
two equivocating proposals b and b(cid:48) and one of them is
committed by at most f honest nodes, then during the
view change, honest nodes cannot agree on the latest
committed request to be extended by the new primary.
Hence, the protocol will lose liveness 5. If the protocol
chooses to extend one the of equivocating requests (b or
b(cid:48)) then protocol safety cannot be guaranteed. For exam-
ple, if request b has been committed by at most f nodes,
and request b(cid:48) is chosen (randomly) to be extended, then
at most f honest nodes have to revoke request b.

But the good news is that if a request b is committed
by at least f + 1 honest nodes, then it cannot be revoked
through equivocation. Therefore, though VBFT allows
the equivocation and revocation of a request (if the re-
quest is committed by at most f nodes) temporarily be-

5The protocol will stall indeﬁnitely.

2

fore all Byzantine nodes get blacklisted, it avoids double-
spending. The client only considers a request to be suc-
cessfully committed by the network if it receives 2 f + 1
responses from distinct nodes, verifying that the request
has been committed. In this case, out of 2 f + 1 nodes
(that respond to the client) at least f + 1 honest nodes
have committed the request. We show that a request re-
vocation is not possible once the client considers a re-
quest committed ( since at least f + 1 honest nodes com-
mit a request). Moreover, to avoid equivocation in the
future, VBFT simply black lists equivocating primaries.
Therefore, after blacklisting at most f Byzantine nodes,
no equivocations will take place. Hence, after that, no
request will be revoked anymore if it is committed by at
least a single node.

The remainder of this paper is organized as follows:
Section 3 presents system model, deﬁnitions and prelim-
inaries. Section 4 presents detailed VBFT protocol. Sec-
tion 5 presents how a Byzantine node can be blacklisted.
Section 6 provides formal proofs of correction for VBFT.
Section 7 present related work and Section 8 concludes
the paper.

3 Deﬁnitions and Model

VBFT operates under the Byzantine fault model. VBFT
can tolerate up to f Byzantine nodes where the total num-
ber of nodes in the network is n such that n = 3 f + 1.
The nodes that follow the protocol are referred to as cor-
rect/honest nodes.

Nodes are not able to break encryption, signatures, and
collision-resistant hashes. We assume that all messages
exchanged among nodes are signed.

To avoid the FLP impossibility result [34], VBFT as-
sumes partial synchrony [35] model with a ﬁxed but un-
known upper bound on message delay. The period during
which a block is generated is called an epoch. Each node
maintains a timer. If an epoch is not completed within
a speciﬁc period (called timeout period), then the node
will timeout and will trigger the view change (changing
the primary) process. The node then doubles the time-
out value, to give enough chance for the next primary to
drive the consensus. As a state machine replication ser-
vice, VBFT needs to satisfy the following properties.

3.1 Deﬁnitions

Deﬁnition 1 (Relaxed Safety). A protocol is R-safe
against all Byzantine faults if the following statement
holds: in the presence of f Byzantine nodes, if 2 f + 1
nodes or f + 1 correct (honest) nodes commit a block at
the sequence (blockchain height) s, then no other block
will ever be committed at the sequence s.

Deﬁnition 2 (Strong Safety). A protocol is considered
to be S-safe in the presence of
f Byzantine nodes, if
a single correct node commits a block at the sequence

(blockchain height) s, then no other block will ever be
committed at the sequence s.

Deﬁnition 3 (Liveness). A protocol is alive if it guar-
antees progress in the presence of at most f Byzantine
nodes.

3.2 Preliminaries

View and View Number. A view determines which
node is in charge (primary). A view is associated with
a monotonically increasing number called view number.
A node uses a deterministic function to map the view
number into a node ID. In other words, the view number
determines the primary for a speciﬁc view.
Signature Aggregation. VBFT uses signature aggrega-
tion [36, 37, 38] in which signatures from nodes can be
aggregated into a a single collective signature of con-
stant size. Upon receipt of the messages (M1, M2, . . . , My
where 2 f + 1 ≤ y ≤ n) with their respective signatures
(σ1, σ2, . . . , σy) the primary then generates an aggregated
signature σ ← AggSign({Mi, σi}i∈N). The aggregated
signature can be veriﬁed by replicas given the messages
M1, M2, . . . , My where 2 f +1 ≤ y ≤ n, the aggregated sig-
nature σ , and public keys PK1, PK2, . . . , PKy. Signature
aggregation has previously been used in BFT-based pro-
tocols [6,8,39]. Any other signature scheme may also be
used with VBFT as long as the identity of the message
sender is known.
Block and Blockchain Requests are also called a trans-
action. Transactions are batched into a block data struc-
ture. This optimization improves throughput as the net-
work decides on a block instead of a single transaction.
Each block keeps the hash of the previous block as a
pointer to the previous block. Hence, building a chain
of blocks called the blockchain.
Quorum Certiﬁcate (QC) and Aggregated QC. A quo-
rum certiﬁcate (QC) is the collection of 2 f + 1 messages
of a speciﬁc type from distinct nodes. For example, the
collection of at least 2 f + 1 votes from distinct nodes
for a block is called QC for the block denoted as QCb.
A block is certiﬁed when enough votes (at least 2 f + 1)
are received to build its QC or its QC is received. Sim-
ilarly, collection of 2 f + 1 view messages forms QC for
the view change or QCv. An aggregated QC or AggQC
is collection of 2 f + 1 QCvs. If b is the latest commit-
ted block or if QCb is the QC with highest view in the
AggQC, then the QCb is called the highQC.

4 VBFT Protocol

The VBFT protocol operates in two modes namely nor-
mal and the view change mode. The protocol operates
in normal mode where blocks are added into the chain
until a failure is encountered. To recover from failure,
the VBFT switches to the view change mode. Upon suc-

3

Algorithm 1: Utilities for nodei
1 Func CreatePrepareMsg(type, v,s,h,d,qcnr,

cmd):

2

3

4

5

6

7

8

13

14

15

16

17

22

33

34

35

36

37

38

39

40

41

b.type ← type
b.v ← v
b.s ← s
b.h ← h
b.parent ← d
b.QCnr ← qcnr
b.cmd ← cmd
return b

9
10 End Function
11 Func GenerateQC(V ):
12

qc.type ← m.type : m ∈ V
qc.viewNumber ← m.viewNumber : m ∈ V
qc.block ← m.block : m ∈ V
qc.sig ← AggSign( qc.type, qc.viewNumber,
qc.s ← V.s,
qc.block,i, {m.Sig |m ∈ V })
return qc

18
19 End Function
20 Func CreateAggQC(ηSet ):
21

aggQC.QCset ← extract QCs from ηSet
aggQC.sig ← AggSign( curView,
{qc.block|qc.block ∈ aggQC.QCset},
{i|i ∈ N}, {m.Sig|m ∈ ηSet })
return aggQC

23
24 End Function
25 Func CreateNVMsg(AggQC,NextView):
26

NewViewMsg.type ← NEW-VIEW
NewViewMsg.AggQC ← AggQC
NewViewMsg.v ← NextView
return NewViewMsg

27

28

29
30 End Function
31 Func SafetyCheck(b,qc):
32

if b.viewNumber == qc.viewNumber
∧b.s = qc.s + 1 then
return b.s > curS

end
if b.viewNumber > qc.viewNumber then
if β ∧ B contains β ’s payload then

return b extends from highQC.block
if ¬β then

return b extends from
highQC.block

end

end

end
42
43 End Function

cessful completion of the view change mode, the VBFT
again begins the normal mode.

4.1 Normal Mode

The normal mode is straightforward. The message
pattern during normal mode is given in the Figure
1.
The primary node receives requests/transactions
from clients. A client c sends its signed transaction
(cid:104)REQUEST, o,t, c(cid:105) to the primary. In a transaction the
ﬁeld o is the operation requested by the client, t is the
timestamp (primary uses t to order requests from client
c).

The primary node builds a block (also called
The proposal mes-
proposal/pre-prepare message).
sage (cid:104)PRE-PREPARE, v, s, h, parent, QCnr, cmd(cid:105) include
the view number v, block sequence (blockchain height)
s, block hash h, parent block hash parent and commands
(cmd) to be executed. QCnr is the QC for the negative
response. After view change before proposing the ﬁrst
block new primary may want to conﬁrm if there is a
block that has been committed by at most f nodes. If
there is no such block then the primary collects 2 f + 1
negative responses nr and builds QCnr. Therefore, after
view changes QCnr ﬁeld may be used only once. More
about this will be discussed in the View Change subsec-
tion.

The primary signs the proposal over

the tuple
(cid:104)v, s, h, parent(cid:105). The primary node then proposes the
proposal to all nodes through broadcast during the pre-
prepare phase (Algorithm 2, lines 18-22). Upon re-
ceipt of a proposal, a node i veriﬁes the primary sig-
nature and the message format. Each node then makes
a safety check through Sa f etyCheck() predicate. The
Sa f etyCheck() predicate accepts two parameters includ-
ing the received block b and the highQC (latest QC built
from 2 f + 1 votes received for the previous block). In the
absence of failure, the Sa f etyCheck() predicate makes
sure the proposal extends the latest committed block.
Which means if the sequence of the latest committed
block b(cid:48) is s (the block has highQC), then the sequence of
the received block b has to be s + 1. If b.s > b(cid:48).s + 1, then
it either means the node i is missing one or more commit-
ted blocks or the block proposal has invalid sequence. In
the case of missing blocks the node will download the
missing blocks and their respective QCs. In case, of in-
valid block sequence, node i can send the block b(cid:48) meta-
data (with invalid sequence) as a proof to the network to
trigger a view change.

If

is

there

failure or view change,

then
a
Sa f etyCheck() predicate makes
sure any uncom-
f + 1 honest nodes (a
mitted block seen by at least
block committed by at most f honest nodes) has been
re-proposed with its previous sequence number 6.
If

6More details about this in later section

4

Algorithm 2: Normal execution for node i
1 foreachin curView ← 1,2,3,...
if i is primary then
2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

if If there is β .s == highQC.s + 1 then

if If commands for β are present then

B ← CreatePrepareMsg(Prepare,v,s,h,parent,⊥,client’s command (from β ))

end
else

Broadcast Request for β payload
upon Receipt of 2 f + 1 Negative Response msgs do

B← CreatePrepareMsg(Prepare,v,s,h,parent,qcnr,client’s command)

end
upon Receipt of payload for β do

B ← CreatePrepareMsg(Prepare,v,s,h,parent,⊥,client’s command (from β ))

end

end

end
else

upon Receipt of 2 f + 1 votes do

B← CreatePrepareMsg(Prepare,v,s,h,parent,⊥,client’s command)

end

end
broadcast B

end
if i is normal replica then

upon Receipt of the Request for β payload do

Send payload to the primary or Negative Response if don’t have payload

end
wait for B from primary(curView)
if SafetyCheck(B, highqc) then

Send vote (cid:104)v, s, h, parent, i(cid:105) for prepare message to primary(curView)

end
upon Receipt of 2 f + 1 votes for block B do

execute new commands in B
respond to clients

end

end
check always for For timeout or proof of maliciousness then

Broadcast VIEW-CHANGE message V

end

5

the safety check is successful, then the node i broad-
casts its vote (cid:104)Vote, v, s, h, parent, i(cid:105) signed over tuples
(cid:104)v, s, h, parent, i(cid:105) (Algorithm 2 lines 29-32).

Upon receipt of 2 f + 1 votes for a block b each node
commits the block (commit phase). Each node also
builds a QC from votes it received for the block b. This
QC will be used as a proof of commit during view change
or for providing proof of commit required by applica-
tion that is running over the top of the VBFT protocol.
Each node that has committed the block will also send a
Reply message to clients whose transaction is included
in the block (Algorithm 2 lines 32-35). A client consid-
ers its request/transaction being committed if it receives
2 f + 1 distinct Reply messages. Similarly, upon receipt
of 2 f + 1 votes, the primary commit the block and pro-
poses the next block in its queue.

If a client c does not receive Reply message within
some speciﬁc interval, then the client broadcasts its re-
quest to all nodes. Upon receipt of the request, if the
request has been committed, then each node sends Reply
message.
If it has not been proposed by the primary,
nodes forward the request to the primary. If the primary
still does not propose the block within the timeout period,
then each node broadcasts a VIEW-CHANGE message to
replace the primary. Similarly, if a block is not commit-
ted within a timeout period, the primary sends an invalid
message or performs equivocation, nodes will trigger the
view change process. The view change process will re-
sult in replacing the faulty primary.

4.2 View Change

In BFT-based protocols, a view change is used to re-
place the failed primary with a new primary. Nodes use
a deterministic function to map the view number to the
primary ID. Primary can be chosen in round-robin man-
ner [6, 8, 10] or randomly [9, 27, 40, 41, 42, 43, 44, 45].

In addition to selecting a new primary, view change
also involves the synchronization of information among
nodes. More speciﬁcally, the new primary needs to de-
termine the sequence number that it will use for its ﬁrst
request to be proposed. The block proposed in the new
sequence number just after the view change has to ex-
tend the latest block committed by at least one honest
node [6, 7, 10] (S-safety). In VBFT, the view change is
different than the view change in the general BFT-based
consensus protocol. In VBFT, there are two ways to ex-
tend the latest committed block. If the latest proposed
block has been committed by more than f honest nodes,
then the VBFT view change is similar to the view change
in classic BFT consensus. But if the latest proposed
block is committed by at most f honest nodes or has not
been committed by any node then the VBFT, requires
an additional data retrieval phase (two communication
steps) to address this case. Moreover, if at most f honest

nodes have committed a block, then the equivocation by
a Byzantine primary may result in revocation of the lat-
est committed block during view change. We, therefore,
show that after each revocation the Byzantine primary
will be blacklisted. Hence, after blacklisting f nodes the
protocol will become S-safe. Which means VBFT will
guarantee that if a block is committed by one node, then
eventually it will be committed by all nodes. Further-
more, as stated, this revocation does not affect clients
and will not result in double-spending.

Algorithm 3: View Change for node i

1 if i is primary then
2

if n − f V (view change) msgs are received
then

3

4

5

6

7

8

aggQC ← CreateAggQC(VSet )
NvMsg ← CreateNVMsg(aggQC,v+1)
Broadcast NvMsg

end
if n − f R (view change) msgs are received
then

qcr ← CreateReadyMsg(Rset )
Broadcast qcr

end

9
10 end
11 if i is normal node then
12

upon Receipt of NEW-VIEW Msg do

13

14

15

16

17

Extract the latest QC and β (if present)
Send Ready Msg R to the primary

end
upon Receipt of qcr do

Execute Algorithm 2

end

18
19 end

If a node does not receive a message from primary
or a command is not executed within some interval,
then the node broadcasts a VIEW-CHANGE message V =
(cid:104)VIEW-CHANGE, v + 1, qc, β , ⊥, i(cid:105). The qc is the QC
for the latest committed block. Whereas, the β is the
header of the latest uncommitted block for which the
node i has voted. In case the node receives a proof of
maliciousness from primary e.g, multiple proposals for
the same sequence, invalid message etc, then it can in-
clude the proof too in the VIEW-CHANGE message (V =
(cid:104)VIEW-CHANGE, v + 1, qc, β , proo f , i(cid:105)) (Algorithm 2
lines 37-39). Once the new primary receives 2 f + 1
VIEW-CHANGE messages (may include its own), it pre-
pares NEW-VIEW message (cid:104)NEW-VIEW, AggQC, v + 1(cid:105).
Here AggQC is the QC built from 2 f + 1 VIEW-CHANGE
messages. The new primary then broadcasts NEW-VIEW
message to all nodes (Algorithm 3 lines 2-5). Each node
that receives the NEW-VIEW can extract important infor-

6

Figure 1: VBFT Message Pattern.

mation out of it as described below:

1. The QC type ﬁeld in the VIEW-CHANGE message
in 2 f + 1 QCs in AggQC, is used to extract the lat-
est committed block by at least f + 1 honest nodes.
Since if f + 1 honest nodes commit the latest block,
then any combination of 2 f + 1, VIEW-CHANGE
messages will have at least one QC for the commit-
ted block by at least f + 1 nodes (for more details
please refer to Lemmas 2 and 3). Though the QC of
a block committed by at most f nodes may also end
up in AggQC, it is not guaranteed. If it did, then the
new primary will extend the block committed by at
most f nodes.

2. The β ﬁeld in the 2 f + 1 VIEW-CHANGE messages
in AggQC determine the latest committed block by
at most f honest nodes (In the absence of equiv-
ocation).
If a block is committed by less than
f + 1 honest nodes, then its QC may not end up
among 2 f + 1 VIEW-CHANGE messages in AggQC,
but since 2 f + 1 nodes (of which f + 1 are honest)
have voted for that block therefore, at least one β
in AggQC will be from the latest committed block.
There is also the possibility that the block/request
of β may have not been committed by a single hon-
est node. In that case, the next primary will have to
collect the proof that the block from β has not been
committed.

Therefore, upon receipt of NEW-VIEW message from
the new primary, each node extracts the latest qc as well
as β (if there is any) as shown in Algorithm 3, lines 12-
15. Each node then sends Ready message to the new
primary. The new primary aggregates Read messages
into the QC for the ready message (QCr) and broadcasts
back. Upon receipt of QCr each node is now ready to
take part in the next view.

Recovering the block committed by at most f hon-
est nodes using β . As stated β in the view change QC
(QCv) is used to recover any block that has been commit-
ted by at most f nodes (in the absence of equivocation).
But if there is not such a block, then the primary has to
provide proof that there is no block such that it has been
committed by at most f honest nodes.

If β ﬁeld in all VIEW-CHANGE messages in AggQC
is nil, then it means no block has been committed by
at most f honest nodes. In other words, the latest pro-
posed block has been committed by at least f + 1 hon-
est nodes. Therefore, the new primary will extend the
block of the latest QC in the AggQC. In case there is a
block b that has been committed by x number of nodes
such that f ≥ x ≥ 1, then the QC for block b may or
may not end up in AggQC. In this case the protocol re-
lies on β (for block b) to make sure the latest block gets
extended after the view change. The β is only relevant
if its sequence is greater than the sequence of latest QC
(highQC) in AggQC such that β .s == highQC.s+1. If at
least one VIEW-CHANGE message in AggQC has the QC
for the latest committed block b (highQC), then the new
primary will propose a block that will extend the block
b. In this case β is not relevant since β .s ≤ highQC.s. It
is also possible that no QC for block b in the AggQC of
the NEW-VIEW message is collected during view change.
But it is guaranteed that at least one β in AggQC will be
from the block b. In this case, if the new primary does
not have the payload for the β from block b, then the
new primary will be able to retrieve the contents of block
b from other nodes in the network. The new primary
then re-proposes the same block b at the same sequence
again as the ﬁrst proposal. Hence, in case if there is a
non-nil β , then the new primary has to make sure if there
is a block that has been committed (by at most f honest
nodes), then it should be recovered and re-proposed. It

7

is also possible that a block may not be committed by
any honest node but its β has been received by the new
primary, hence, included in the AggQC. In this case, the
new primary will try to retrieve the block for β (when
β .s == highQC.s + 1). If the block is retrieved, the pri-
mary will propose it for the same sequence. If the block
is not retrieved then the primary has to provide proof to
all honest nodes that such a block has not been commit-
ted by any honest node. The proof will allow the new
primary to extend the block with the latest QC (instead
of the block of β ) in the VIEW-CHANGE message.

Therefore as it can be seen in the Algorithm 2, if there
is a β such that β .s == highQC.s + 1 and the primary
has the payload for β , then it can propose the β ’s pay-
load (lines 4-6). If the β payload is not present, then the
algorithm requires to recover the payload (block) (lines
7-11). The primary broadcasts a request to retrieve the
payload for β . Now if β has been committed by at least
one node, then this means 2 f + 1 nodes have voted for
it. Which means 2 f + 1 nodes have the payload for β .
Therefore when nodes (at least 2 f + 1) respond to the re-
quest for β payload, at least one response will have the
payload. Upon, receipt of the payload the new primary
proposes the payload for β again (lines 12-15).

There is also a possibility that the respective block for
the β may not be committed by any honest node. In that
case, the primary may not receive the β payload. But it is
guaranteed that the new primary will receive 2 f + 1 neg-
ative responses from distinct nodes. These 2 f + 1 neg-
ative response indicates that the block for the β has not
been committed by any honest node. To prove that the
respective block for β has not been committed, the new
primary attaches the QC for negative response (qcnr) to
its ﬁrst proposal for the view. If there is a β and the new
primary neither proposes its payload nor includes its qcnr
during the ﬁrst proposal, honest nodes will trigger view
change. Therefore, in the absence of equivocation, the
VBFT guarantees S-safety. Therefore, the presence of
the latest block QC or β is guaranteed in AggQC (further
details in Section 6). Hence, the new primary will extend
the latest committed block (in the absence of equivoca-
tion).

Addressing the problem of Equivocation (Byzan-
tine Primary). Since VBFT achieves consensus in just
two steps of communications, therefore it allows Byzan-
tine primary to perform equivocation (proposing multi-
ple blocks for the same sequence). In the case of equiv-
ocation if one of the proposed blocks is committed by
f + 1 honest nodes then the equivocation will not result
in revocation of the block committed by f + 1 honest
nodes. Hence, equivocation will not be able to cause
any safety or liveness issues. But the problem arises if
at most f honest nodes commit one of the equivocated
blocks. In this case, there is a possibility that the block

committed by at most f nodes will be revoked. To bet-
ter explain how revocation takes place, let us assume that
there are two equivocated blocks b1 and b2, such that b1
has been committed by f honest node. During the view
change, the new primary receives VIEW-CHANGE mes-
sages from 2 f + 1 nodes (assuming that the QC for b1
is not among the 2 f + 1 VIEW-CHANGE messages). The
new primary may receive VIEW-CHANGE messages con-
taining β for both blocks b1 (β1) and b2 (β2). Now if the
new primary chooses to recover the payload for β1 and
repropose the payload for β1, then the S-safety does not
break. But if the new primary choose to extend β2, then
up to f nodes that have committed b1, have to revoke b1.
Hence, the S-safety does not hold if equivocation is per-
formed. Since at most f honest nodes have committed
block b1, therefore, the clients have not received 2 f + 1
Reply messages. As a result, clients still do not consider
transactions in the block b1 as committed. Therefore, the
revocation does not result in double-spending. A Client
c can only get 2 f + 1 Reply messages for a transaction if
its subsequent block is committed by at least f +1 honest
nodes. As stated, if a block is committed by f + 1 honest
nodes then it will not be revoked (See safety proof for
more details). Therefore, to discourage Byzantine nodes
equivocated primaries will be blacklisted. As a result,
once all Byzantine nodes are blacklisted, there won’t be
any equivocation.

View Change Optimization View change in classic
BFT protocols [6, 7] can have quadratic cost of signature
veriﬁcation in AggQC. Recently there have been propos-
als on improving the message and computational costs
from signatures during the view change [23,46]. We pre-
ferred to use the solution in citejalalzai2021fasthotstuff
as it is straightforward and easy to implement. In Fast-
HotStuff [23], authors show that this quadratic cost of
signature veriﬁcation can be reduced linear. The tech-
nique they suggested is to verify the aggregated signature
of the AggQC along with the aggregated signature of the
VIEW-CHANGE message with the highest QC. This is
sufﬁcient to guarantee the validity of the AggQC. The
veriﬁcation of the aggregated signature of the AggQC
veriﬁes that it contains VIEW-CHANGE message from
2 f + 1 distinct nodes. Whereas, the veriﬁcation of the
signature of the latest QC makes sure the latest QC and
potential latest β messages are valid. Thus, each node
does not require to verify aggregated signatures from the
remaining 2 f QCs. Although this solution does not help
with the message complexity during the view change, in
practice the collective size of view change messages is
negligible compare to the block size. Hence, their effect
on performance is also negligible 7.

7If the network size is too large or the block size is too small, then

view change message complexity may affect the performance.

8

5 Black Listing Byzantine Primary

An equivocation attack is mainly performed to break the
protocol safety. Although it is a strong type of attack,
the good news is that it can easily be detected.
It is
also important that the blacklisting decision is consistent
throughout the network. Therefore, the blacklisting of a
Byzantine node is done through a transaction (request).
This allows the network to take a decision on blacklisting
and remain consistent.

When an honest node i receives multiple blocks for
the same sequence, it knows that the primary is Byzan-
tine and is trying to perform equivocation. Therefore,
broadcasts the proof (which includes the header of both
equivocated blocks) included in the view change mes-
sage. This will trigger a view change as explained in the
algorithm 3. After the view change, honest nodes expect
the new primary to include the blacklisting transaction
in the block proposal. If the new primary does not pro-
pose a blacklisting transaction within the timeout period,
then honest nodes forward the proof to the new primary
and wait again for the blacklisting transaction to be pro-
posed. If by the timeout the blacklisting transaction is not
proposed by the primary, then honest nodes trigger view
change by broadcasting VIEW-CHANGE messages. This
process will continue until the new primary proposes the
transaction containing a blacklisting transaction.

It is also possible that a node is no longer the pri-
mary but another node i discovers proof of equivocation
In this case, the node i still broadcasts the
against it.
proof to all nodes. Upon receipt of the proof a j checks if
the node that has performed equivocation has been black-
listed or not. If the equivocator is blacklisted then the
proof is ignored by the node j. If not then it forwards
the proof to the current primary and waits for the pro-
posal of the blacklisting transaction. If the primary does
not propose the blacklisting transaction within a timeout
interval, then node j broadcast VIEW-CHANGE message.
Therefore, eventually, there will be an honest primary
that will propose the blacklisting transaction.

6 Proof of Correctness

In this section, we provide proof of safety and liveness
for the VBFT protocol. We consider Sh as the set of hon-
est nodes in the network and 2 f + 1 ≤ |Sh| ≤ n.

6.1 Safety

As stated VBFT satisﬁes S-safety during the normal pro-
tocol. VBFT also satisﬁes S-safety during a view change
in the absence of equivocation. VBFT protocol may fall
back to R-safety. But once all byzantine nodes (at most
f ) get blacklisted then, the protocol will always guaran-
tee S-safety. Below we provide lemmas related to the
VBFT safety.

Lemma 1. VBFT is S-Safe during normal execution of
the protocol.

Proof. This lemma can be proved by contradiction. Let
us assume that a block b1 has been committed by a single
node i such that i ∈ Sh in the sequence s. This means 2 f +
1 nodes in a set S1 have voted for block b1. Similarly
an honest node j ( j ∈ Sh ) commits a block b2 in the
sequence s. A set of 2 f + 1 nodes (S2) have voted for the
block b2. Since n = 3 f +1, we have S1 ∩S2 ≥ f +1. This
means there is at least one honest node that has voted
both, for the block b1 and b2. But this is impossible since
an honest node only vote once for a single block at the
same sequence. Hence, VBFT is S-safe during normal
execution of the protocol.

Lemma 2. VBFT is R-Safe during normal execution of
the protocol.

Proof. From Lemma 1, we know that VBFT is S-safe
during normal mode. Therefore, we can conclude that if
VBFT is S-safe during the normal mode, then it is also
R-safe during the normal mode.

Lemma 3. VBFT is R-Safe during view change.

Proof. Let us assume that a block b1, is committed just
before view change by a set of nodes S1 ∈ Sh of size
f + 1. During view change 2 f + 1 nodes (out of which
f + 1 are honest nodes) in set S2 send their
at least
VIEW-CHANGE messages to the new primary. The new
primary aggregates 2 f +1 VIEW-CHANGE messages into
NEW-VIEW message as shown in (Algorithm 3). Since
S1 ∩ S2 = S and |S| ≥ 1, therefore there is at least one
honest node that have committed block b1 and has its
VIEW-CHANGE message V ∈ NEW-VIEW. This means
when the new primary broadcasts the NEW-VIEW mes-
sage, every receiving node will know that block b1 is the
latest committed block. Therefore, the new primary will
have to extend the block b1.

Lemma 4. VBFT is S-Safe during view change when
there is no equivocation.

Proof. A block b is committed by a single honest node
i at the sequence s just before the view change. This
means a set of nodes S1 ≥ 2 f + 1 have voted for the
block b. During the view change the new primary col-
lects VIEW-CHANGE messages from another set of 2 f +1
nodes (S2) into NEW-VIEW message. There is no guaran-
tee that node i’s VIEW-CHANGE message is included in
the NEW-VIEW message built from VIEW-CHANGE mes-
sage of nodes in S2. If node i’s QC for block b from its
VIEW-CHANGE message is included in the NEW-VIEW
message, then the new primary will simply propose a
block that extends the block b. But in case the QC

9

for block b is not included in NEW-VIEW, then block
b can be recovered using information in the β ﬁeld of
the NEW-VIEW messages in NEW-VIEW message. Each
node in S2 has included the latest β (block header it
has voted for) in its VIEW-CHANGE message it has sent
to the primary. The primary has aggregated these mes-
sages into NEW-VIEW message. Since n = 3 f + 1 there-
fore, S1 ∩ S2 ≥ f + 1. This means there is at least one
honest node j in the intersection of S1 (that has voted
for the block b) and S2 (has its VIEW-CHANGE mes-
sage Vj ∈ NEW-VIEW message such that and Vj.β .s =
highQC8.s + 1). Therefore, the new primary can retrieve
the payload for β (block b’s header) and propose it for
the same sequence s as shown in Algorithm 2.

Lemma 5. After blacklisting f Byzantine nodes, the
VBFT will guarantee S-safety.

Proof. A Byzantine primary may perform equivocation
by proposing multiple blocks for the same sequence. As
stated in Sections 4 and 5 an equivocation attack can
easily be detected and the culprit node can be black-
listed. Therefore, upon blacklisting f number of Byzan-
tine nodes, there won’t be any Byzantine node left to
perform equivocation when selected as a primary. Since
there will be no equivocation anymore therefore based
on the Lemmas 1, 2, 3, and 4, VBFT protocol is S-safe
after blacklisting f equivocating nodes.

The above lemmas prove that the VBFT protocol is al-
ways R-safe. Fast-B4B is S-safe during the normal mode
and view change (when there is no equivocation). After,
blacklisting f Byzantine primaries, due to equivocation
the VBFT protocol will always guarantee S-safety.

6.2 Liveness

A consensus protocol has guaranteed that
it makes
progress eventually and will not stall indeﬁnitely. VBFT
replaces a primary through a view change if the primary
fails to make progress. VBFT borrows techniques from
PBFT [6] to provide liveness. The ﬁrst technique in-
cludes an exponential back-off timer where the timeout
period is doubled after each view change to give the next
primary enough time to achieve the decision on a re-
quest/block

Secondly, a node broadcasts VIEW-CHANGE message
if it receives f + 1 VIEW-CHANGE messages higher than
its current view from distinct nodes. This guarantees that
at least one message is from an honest node. Moreover,
if a node receives f +1 VIEW-CHANGE messages for dif-
ferent views greater than its current view, it will broad-
cast a VIEW-CHANGE message for the smallest view of
the f + 1 VIEW-CHANGE messages.

8highQC is the QC with highest sequence (latest QC) in the AggQC.

AggQC is the set of QCs in the NEW-VIEW message.

10

Third, to prevent the protocol to be indeﬁnitely in
the state of view change, a node will not broadcast
VIEW-CHANGE message and trigger view change if it re-
ceives at most f < n/3 number of VIEW-CHANGE mes-
sages. Therefore, Byzantine nodes cannot trigger a view
change until at least one honest not also broadcast a
VIEW-CHANGE message.

If the primary is selected in round robin-manner, then
after at most f Byzantine primaries, an honest primary
will be selected. Therefore, progress will be made even-
tually. Similarly, if the primary is being selected ran-
domly then the probability of a bad event (selection of a
Byzantine primary) is Pb = 1/3. By considering such a
bad event as the Bernoulli trial, we have the probability
of a bad event for k consecutive views as Pk
b . This shows
that Pk
b quickly approaches 0 as k increases. Therefore,
eventually, an honest node will be selected as primary so
that the protocol can make progress.

7 Related Work

Fast B4B uses block recovery mechanism that Hermes
BFT [27] employed to retrieve a block committed by at
most f nodes. During block recovery Hermes primary
may collect proofs that the most recent block is not com-
mitted. Hermes is designed for optimal bandwidth usage
rather than latency. It has ﬁve communication steps com-
pare to the two in Fast B4B. The concept of collecting
proofs for uncommitted block during a view change is
also used in a recent concurrent manuscript [46] (called
No-Commit Proofs). But [46] achieves consensus in at
least four communication steps.

Kursawe [28] in his paper proposes an optimistic fast
BFT consensus protocol that can achieve consensus in
two-step communication only if all the nodes n = 3 f + 1
are honest. Otherwise, the protocol will switch to ran-
domized asynchronous consensus.

2

Martin and Alvisi [29] presented FaB Paxos (Fast
Byzantine Tolerant Paxos) that can tolerate f < n
5 Byzan-
tine nodes. They also present a paramaterized version of
FaB Paxos in which n = 3 f + 2t + 1, (where t ≤ f ) that
achieve consensus in two communication steps while tol-
erating only t Byzantine nodes. They also claim that
t = n−3 f −1
, is the optimal resilience of the Fab Paxos.
For t = f , the optimal resiliency is f = n−1
5 .

Zyzzyva [47] is another protocol that can execute a
proposal optimistically if all nodes follow the protocol. If
not, then the protocol may fall back to three communica-
tion steps or may revoke the executed proposal. The main
problem with Zyzzyva is that it depends (trusts) on the
client for message propagation. Depending on a client to
achieve consensus is not a safe option for blockchain.

hBFT is another protocol

it can
achieve consensus in two communication steps while
f = n−1
3 . But authors in [48] show that hBFT cannot

that claims that

guarantee safety during view change.

Abraham et al. [31] considers the problem of reliable
broadcast. Then they show that it is possible to achieve
consensus in two communication steps with upper bound
on Byzantine faults is f = n+1
and the primary is hon-
5
est. Their result applies to both partially synchronous
and synchronous models.

Kuznetsov et. al [30] generalizes the result of optimal
resiliency to achieve consensus in two rounds with upper
bound on faults is f = n+1
5 . There result shows that this
optimal resiliency bound can be achieved for protocols
that employ primary to reach consensus along with those
that do not.

Whereas, our protocol Fast B4B achieves consensus in
two communication steps (when the primary is honest)
while improving the upper bound on tolerating Byzan-
tine faults to f = n−1
3 .

8 Conclusion

In this paper, we present Fast B4B consensus protocol,
that achieves consensus during normal protocol opera-
tion in just two communication steps. We show that
the previous optimal bound for Byzantine resilience fast
BFT can be improved from f ≤ n+1
3 . Further-
5
more, Fast B4B does not employ any trusted hardware to
achieve this improvement.

to f ≤ n−1

References

[1] M. Pease, R. Shostak, and L. Lamport, “Reaching
in the presence of faults,” J. ACM,
agreement
vol. 27, no. 2, p. 228–234, Apr. 1980. [Online].
Available: https://doi.org/10.1145/322186.322188

[2] L. Lamport, “The part-time parliament,” ACM
Transactions on Computer Systems 16, 2 (May
1998), 133-169. Also appeared as SRC Research
Report 49. This paper was ﬁrst submitted in 1990,
setting a personal record for publication delay
that has since been broken by [60]., May 1998,
aCM SIGOPS Hall of Fame Award in 2012.
[Online]. Available: https://www.microsoft.com/
en-us/research/publication/part-time-parliament/

[3] ——,

Tech.

consensus

“Generalized

and
MSR-TR-2005-
Avail-
https://www.microsoft.com/en-us/research/

paxos,”
33,
able:
publication/generalized-consensus-and-paxos/

[Online].

March

2005.

Rep.

[4] I. Moraru, D. G. Andersen, and M. Kamin-
sky, “There is more consensus in egalitarian
the Twenty-
in Proceedings of
parliaments,”
Fourth ACM Symposium on Operating Sys-
tems Principles,
ser. SOSP ’13. New York,

11

NY, USA: Association for Computing Machin-
ery, 2013, p. 358–372.
[Online]. Available:
https://doi.org/10.1145/2517349.2517350

[5] S. Tollman, S.

J. Park,

and J. Ousterhout,
“Epaxos revisited,” in 18th USENIX Symposium
on Networked Systems Design and Implementation
(NSDI 21). USENIX Association, Apr. 2021, pp.
613–632. [Online]. Available: https://www.usenix.
org/conference/nsdi21/presentation/tollman

[6] M. Castro and B. Liskov, “Practical Byzantine fault
tolerance,” in Proceedings of the Third Symposium
on Operating Systems Design and Implementation,
ser. OSDI ’99. Berkeley, CA, USA: USENIX As-
sociation, 1999, pp. 173–186.

[7] G. Golan-Gueta,

I. Abraham, S. Grossman,
D. Malkhi, B. Pinkas, M. K. Reiter, D. Seredin-
schi, O. Tamir, and A. Tomescu, “SBFT: a scalable
decentralized trust infrastructure for blockchains,”
CoRR, vol. abs/1804.01626, 2018.

[8] M. M. Jalalzai and C. Busch, “Window based BFT
blockchain consensus,” in iThings, IEEE Green-
Com,
IEEE (CPSCom) and IEEE SSmartData
2018, July 2018, pp. 971–979.

[9] M. M. Jalalzai, C. Busch, and G. G. Richard,
“Proteus: A scalable bft consensus protocol for
blockchains,” in 2019 IEEE International Confer-
ence on Blockchain (Blockchain), 2019, pp. 308–
313.

[10] M. Yin, D. Malkhi, M. K. Reiter, G. G. Gueta, and
I. Abraham, “Hotstuff: Bft consensus with linear-
ity and responsiveness,” in Proceedings of the 2019
ACM PODC, ser. PODC ’19.
New York, NY,
USA: Association for Computing Machinery, 2019,
p. 347–356.

[11] M. Pires, S. Ravi, and R. Rodrigues, “Generalized
paxos made byzantine (and less complex),” Algo-
rithms, vol. 11, no. 9, 2018. [Online]. Available:
https://www.mdpi.com/1999-4893/11/9/141

[12] A. Clement, E. Wong, L. Alvisi, M. Dahlin, and
M. Marchetti, “Making byzantine fault tolerant sys-
tems tolerate byzantine faults,” in Proceedings of
the 6th USENIX Symposium on Networked Systems
Design and Implementation, ser. NSDI’09. USA:
USENIX Association, 2009, p. 153–168.

[13] Y. Amir, B. Coan,

J. Kirsch, and J. Lane,
“Byzantine replication under attack,” in 2008
IEEE International Conference on Dependable
Systems and Networks With FTCS and DCC

(DSN), vol. 00, June 2008, pp. 197–206. [Online].
Available:
doi.ieeecomputersociety.org/10.1109/
DSN.2008.4630088

[14] Z. Avarikioti, L. Heimbach, R. Schmid, L. Van-
bever, R. Wattenhofer, and P. Wintermeyer, “Fnf-
bft: Exploring performance limits of bft protocols,”
2021.

[15] A. Singh, P. Fonseca, P. Kuznetsov, R. Rodrigues,
and P. Maniatis, “Zeno: Eventually consistent
byzantine-fault tolerance,” in Proceedings of the
6th USENIX Symposium on Networked Systems De-
sign and Implementation, ser. NSDI’09.
USA:
USENIX Association, 2009, p. 169–184.

[16] V. Enes, C. Baquero, T. F. Rezende, A. Gotsman,
M. Perrin, and P. Sutra, “State-machine replication
in Proceedings of
for planet-scale systems,”
the Fifteenth European Conference on Computer
Systems,
ser. EuroSys ’20. New York, NY,
USA: Association for Computing Machinery,
2020. [Online]. Available: https://doi.org/10.1145/
3342195.3387543

[17] T. Distler, “Byzantine fault-tolerant state-machine
replication from a systems perspective,” ACM
Comput. Surv., vol. 54, no. 1, Feb. 2021. [Online].
Available: https://doi.org/10.1145/3436728

[18] A. Clement, M. Kapritsos, S. Lee, Y. Wang,
L. Alvisi, M. Dahlin, and T. Riche, “Upright
the ACM
cluster services,” in Proceedings of
SIGOPS 22nd Symposium on Operating Systems
Principles,
ser. SOSP ’09. New York, NY,
USA: Association for Computing Machinery,
https:
2009, p. 277–290. [Online]. Available:
//doi.org/10.1145/1629575.1629602

[19] A. N. Bessani, P. Sousa, M. Correia, N. F. Neves,
and P. Ver´ıssimo, “The crutial way of critical infras-
tructure protection,” IEEE Security Privacy, vol. 6,
no. 6, pp. 44–51, 2008.

[20] A. Nogueira, M. Garcia, A. Bessani, and N. Neves,
“On the challenges of building a bft scada,” in
2018 48th Annual IEEE/IFIP International Confer-
ence on Dependable Systems and Networks (DSN),
2018, pp. 163–170.

[21] R. Garcia, R. Rodrigues,

database

replication,”

and N. Preguic¸a,
tol-
in Proceedings
the Sixth Conference on Computer Sys-
New York, NY,
for Computing Machin-
[Online]. Available:

“Efﬁcient middleware for byzantine fault
erant
of
tems,
USA: Association
ery, 2011, p. 107–122.
https://doi.org/10.1145/1966445.1966456

ser. EuroSys

’11.

[22] J. Wang and H. Wang, “Monoxide: Scale out
blockchains with asynchronous consensus zones,”
in 16th USENIX Symposium on Networked Systems
Design and Implementation (NSDI 19). Boston,
MA: USENIX Association, Feb. 2019, pp. 95–
112. [Online]. Available: https://www.usenix.org/
conference/nsdi19/presentation/wang-jiaping

[23] M. M. Jalalzai, J. Niu, C. Feng, and F. Gai, “Fast-
hotstuff:a fast and resilient hotstuff protocol,” 2021.

[24] Y. Gilad, R. Hemo, S. Micali, G. Vlachos, and
N. Zeldovich, “Algorand: Scaling Byzantine agree-
ments for cryptocurrencies,” in Proceedings of the
26th Symposium on Operating Systems Principles,
ser. SOSP ’17. New York, NY, USA: ACM, 2017,
pp. 51–68.

[25] V. Buterin and V. Grifﬁth, “Casper the friendly ﬁ-
nality gadget,” arXiv preprint arXiv:1710.09437,
2017.

[26] A. Bessani, J. Sousa, and E. E. P. Alchieri, “State
machine replication for the masses with bft-smart,”
in 2014 44th Annual IEEE/IFIP International Con-
ference on Dependable Systems and Networks,
2014, pp. 355–362.

[27] M. Jalalzai, C. Feng, C. Busch, G. R. III, and
J. Niu, “The hermes bft for blockchains,” IEEE
Transactions on Dependable and Secure Comput-
ing, no. 01, pp. 1–1, sep 5555.

[28] K. Kursawe, “Optimistic byzantine agreement,” in
21st IEEE Symposium on Reliable Distributed Sys-
tems, 2002. Proceedings., 2002, pp. 262–267.

[29] J.-P. Martin and L. Alvisi, “Fast byzantine con-
sensus,” IEEE Trans. Dependable Secur. Comput.,
vol. 3, no. 3, p. 202–215, Jul. 2006. [Online].
Available: https://doi.org/10.1109/TDSC.2006.35

resilience of

[30] P. Kuznetsov, A. Tonkikh, and Y. X. Zhang,
fast byzan-
“Revisiting optimal
the 2021
tine consensus,” in Proceedings of
ACM Symposium on Principles of Distributed
Computing,
ser. PODC’21. New York, NY,
for Computing Machin-
USA: Association
ery, 2021, p. 343–353.
[Online]. Available:
https://doi.org/10.1145/3465084.3467924

[31] I. Abraham, K. Nayak, L. Ren, and Z. Xiang,
“Good-case latency of byzantine broadcast:
a
complete categorization,” in PODC ’21: ACM
Symposium on Principles of Distributed Com-
puting, Virtual Event,
Italy, July 26-30, 2021,
A. Miller, K. Censor-Hillel, and J. H. Korhonen,

12

[42] S. Popov, “On a decentralized trustless pseudo-
random number generation algorithm,” Journal
of Mathematical Cryptology, vol. 11, no. 1,
pp. 37–43, 2017.
https:
//doi.org/10.1515/jmc-2016-0019

[Online]. Available:

[43] C. Cachin, K. Kursawe, and V. Shoup, “Random
oracles in constantinople: Practical asynchronous
byzantine agreement using cryptography,” J. Cryp-
tol., vol. 18, no. 3, p. 219–246, Jul. 2005.

[44] T. Moran, M. Naor, and G. Segev, “An optimally
fair coin toss,” in Theory of Cryptography, O. Rein-
gold, Ed. Berlin, Heidelberg: Springer Berlin Hei-
delberg, 2009, pp. 1–18.

[45] T. Hanke, M. Movahedi, and D. Williams, “Dﬁn-
ity technology overview series, consensus system,”
2018.

[46] N. Giridharan, H. Howard, I. Abraham, N. Crooks,
and A. Tomescu, “No-commit proofs: Defeating
livelock in bft,” Cryptology ePrint Archive, Report
2021/1308, 2021, https://ia.cr/2021/1308.

[47] R. Kotla, A. Clement, E. Wong, L. Alvisi, and
M. Dahlin, “Zyzzyva: Speculative Byzantine fault
tolerance,” Commun. ACM, vol. 51, no. 11, pp. 86–
95, Nov. 2008.

[48] N. Shrestha, M. Kumar, and S. Duan, “Revisit-
ing hbft: Speculative byzantine fault tolerance with
minimum cost,” 2019.

Eds. ACM, 2021, pp. 331–341. [Online]. Avail-
able: https://doi.org/10.1145/3465084.3467899

[32] G. S. Veronese, M. Correia, A. N. Bessani,
L. C. Lung, and P. Verissimo, “Efﬁcient byzantine
fault-tolerance,” IEEE Transactions on Computers,
vol. 62, no. 1, pp. 16–30, 2013.

[33] D. Cerdeira, N. Santos, P. Fonseca, and S. Pinto,
“Sok: Understanding the prevailing security vul-
nerabilities in trustzone-assisted tee systems,” in
2020 IEEE Symposium on Security and Privacy
(SP), 2020, pp. 1416–1432.

[34] M. J. Fischer, N. A. Lynch, and M. S. Paterson,
“Impossibility of distributed consensus with one
faulty process,” J. ACM, vol. 32, no. 2, pp. 374–
382, Apr. 1985.

[35] C. Dwork, N. Lynch, and L. Stockmeyer, “Consen-
sus in the presence of partial synchrony,” J. ACM,
vol. 35, no. 2, pp. 288–323, Apr. 1988.

[36] D. Boneh, B. Lynn, and H. Shacham, “Short sig-
natures from the weil pairing,” in Proceedings of
the 7th International Conference on the Theory and
Application of Cryptology and Information Secu-
rity: Advances in Cryptology, ser. ASIACRYPT
’01. Berlin, Heidelberg: Springer-Verlag, 2001,
p. 514–532.

[37] D. Boneh, C. Gentry, B. Lynn, and H. Shacham,
“Aggregate and veriﬁably encrypted signatures
from bilinear maps,” in Proceedings of the 22nd In-
ternational Conference on Theory and Applications
of Cryptographic Techniques. Berlin, Heidelberg:
Springer-Verlag, 2003, pp. 416–432.

[38] D. Boneh, M. Drijvers, and G. Neven, “Com-
pact multi-signatures for smaller blockchains,”
in Advances in Cryptology – ASIACRYPT 2018,
T. Peyrin and S. Galbraith, Eds. Cham: Springer
International Publishing, 2018, pp. 435–464.

[39] L. Lamport, R. Shostak, and M. Pease, “The
Byzantine generals problem,” ACM Trans. Pro-
gram. Lang. Syst., vol. 4, no. 3, pp. 382–401, Jul.
1982.

[40] M. Blum, “Coin ﬂipping by telephone a protocol
for solving impossible problems,” SIGACT News,
vol. 15, no. 1, p. 23–27, Jan. 1983. [Online]. Avail-
able: https://doi.org/10.1145/1008908.1008911

[41] M. Ben-Or and N. Linial, “Collective coin ﬂipping,
robust voting schemes and minima of banzhaf val-
ues,” in 26th Annual Symposium on Foundations of
Computer Science (sfcs 1985), 1985, pp. 408–416.

13

