2
2
0
2

r
a

M
0
3

]

R
C
.
s
c
[

1
v
8
6
9
5
1
.
3
0
2
2
:
v
i
X
r
a

Light Clients for Lazy Blockchains

Ertem Nusret Tas1, Dionysis Zindros1, Lei Yang2, and David Tse1

1 Stanford University
{nusret,dionyziz,dntse}@stanford.edu
2 MIT CSAIL
leiy@csail.mit.edu

Abstract. Decoupling consensus from transaction veriﬁcation and ex-
ecution is an important technique to increase the throughput of block-
chains, a technique known as a lazy blockchain. Lazy blockchains can end
up containing invalid transactions such as double spends, but these can
easily be ﬁltered out by full nodes that can check if there have been pre-
vious conﬂicting transactions. However, creating light (SPV) clients that
do not see the whole transaction history on top of these chains becomes
a challenge: A record of a transaction on the chain does not necessar-
ily entail transaction conﬁrmation. In this paper, we devise a protocol
that enables the creation of eﬃcient light clients for lazy blockchains.
The number of interaction rounds and the communication complexity of
our protocol are only logarithmic in the blockchain execution time. Our
construction is based on a bisection game that traverses the Merkle tree
containing the ledger of all – valid or invalid – transactions. We prove
that our proof system is succinct, complete and sound, and we illustrate
how it can be applied to both the UTXO as well as the account based
models. Lastly, we empirically demonstrate the feasibility of our scheme
by providing experimental results.

1

Introduction

A traveler in Naples saw twelve beggars lying in the sun. He oﬀered a
lira to the laziest of them. Eleven of them jumped up to claim it, so he
gave it to the twelfth [41]. Towards scalable blockchains, the holy grail
of cryptocurrency adoption, it has become clear that lazy systems will
similarly be the winner of the race.

Eager blockchain protocols, such as Bitcoin and Ethereum, combine
transaction veriﬁcation and execution with consensus to ensure that only
valid transactions are included in their ledger. In contrast, lazy blockchain
protocols separate the consensus layer (responsible for ordering transac-
tions) from the execution layer (responsible for interpreting them). In
these systems, a population of consensus nodes collects transactions and
places them in a total order, without care for their validity. This produces

 
 
 
 
 
 
2

a dirty ledger, a sequence of totally ordered, but potentially invalid, trans-
actions – such as double spends. It is the responsibility of full nodes to
sanitize the dirty ledger and ascertain which transactions are valid. This
is done by executing the transactions one by one, as long as they are valid,
and ignoring transactions that are not applicable. For instance, if a trans-
action is a double spend of another and they both appear on the dirty
ledger, only the ﬁrst one to appear on the ledger will be executed. Exam-
ples of lazy distributed ledger protocols include Celestia (LazyLedger) [1],
Prism [3], Parallel Chains [22] and Snap-and-Chat [39].

The advantage of a lazy protocol is that consensus nodes do not need
to perform any execution. This removes the execution bottleneck to scal-
ing the blockchain [1]. However, because consensus nodes do not execute,
they have no knowledge of the state of the system (such as account bal-
ances) and can therefore not prevent invalid transactions from appearing
in the ledger. They also cannot ﬁnd and include the state commitment in
the blockchain.

For this reason, lazy protocols cannot easily provide support for light
clients, and techniques from the realm of eager systems, such as SPV
(Simple Payment Veriﬁcation [38,11]), are not applicable. For instance,
in Bitcoin, to help the light clients verify a transaction, a full node presents
a block header containing the Merkle root of the transactions in the block,
together with an inclusion proof of the transaction. However, in a lazy
protocol, this is not suﬃcient since some transactions included in a block
can be invalid. Similarly, in Ethereum, to prove to the light clients their
current account balance, a full node presents a block header, together
with a Merkle inclusion proof of the account to be veriﬁed within the
state commitment. However, in a lazy protocol, there cannot be any such
state commitment in a block.

In this paper, we resolve this outstanding problem by introducing the
ﬁrst light client for lazy blockchains. Consider a light client, such as the
mobile wallet of a vendor, wishing to conﬁrm an incoming payment. Our
construction allows them to synchronize with the network and quickly
learn their latest account balance. Towards this purpose, the light client
ﬁrst connects to several full nodes, at least one of which is honest. It
then asks them its account balance. If the answers received contradict
each other, then it deduces that at least one of them is adversarial. It
interactively interrogates the full nodes in order to determine which of
them is truthful.

Contributions. Our contributions in this paper are:

3

1. We put forth the ﬁrst light client for lazy blockchains, achieving expo-
nential improvement over full nodes in terms of communication and
computational complexity.

2. We prove our system is complete, sound, and succinct, from 9 straight-
forward axioms that the underlying system must be governed under.
3. We illustrate that our full node prover is eﬃcient in compute and

storage.

4. We implement our scheme and compare the performance of our im-

plementation against existing systems.

Fig. 1: Bisection Game. Charlie the challenger helps the light client itera-
tively traverse the tree of Eve the evil responder. A green node indicates
a match, while a red node indicates a mismatch, between the two dirty
trees.

Construction overview. Consider a light client connected to two full
nodes, Charlie and Eve. Charlie is honest and Eve is adversarial. The light
client begins by downloading the canonical header chain, each header
containing the Merkle root of the transactions (valid and invalid) in its
block. It wonders what its current account balance is. It asks this question
to both full nodes. If both of them return the same answer, it rests assured
that the balance reported is accurate. If they disagree, it must ﬁgure out
who is truthful. Since Charlie and Eve are full nodes, they each have a
copy of the current dirty ledger, and can already determine the correct
balance.

                      CharlieEvelightclientopen rightopen right     ,txstate4

To help convince the light client, Charlie takes the dirty ledger of
transactions and augments it with some extra information: Together with
every transaction, he includes a commitment to the state of the world
after the particular transaction has been applied to the previous state. If
a transaction is invalid, he does not update the state. He organizes this
augmented dirty ledger into a binary Merkle tree, the dirty tree. Each leaf
of this tree contains a transaction and its respective state commitment.
All honest full nodes following this process will construct the same dirty
tree and will hold the same dirty tree root. If the light client somehow
learns the correct dirty tree root, then it can deduce its balance. To do so,
it downloads a Merkle inclusion proof of the last leaf within this dirty tree.
Within the last leaf lies the latest commitment to the state of the world,
which, in turn, is another Merkle tree root. The light client downloads
another Merkle tree proof that attests to its balance within this latest
state commitment.

Charlie gives the correct dirty tree root to the light client, but Eve
gives it an incorrect dirty tree root. It suﬃces for the light client to dis-
cover which of the two roots is truthful. Since the two roots are diﬀerent,
the underlying augmented dirty ledgers must diﬀer somewhere. Charlie
helps the light client identify the ﬁrst leaf in Eve’s dirty tree that diﬀers
from his own. With reference to his own dirty tree, he guides the light
client through a path on Eve’s dirty tree that starts at the root and ends
at the ﬁrst leaf of disagreement. He does this by iteratively asking Eve
to reveal an increasingly deeper node at a time. Given a node revealed
at a certain height, Charlie selects to query the left or the right child
as illustrated in Figure 1. The left child is queried if it does not match
the corresponding internal node of his own tree, indicating a mismatch;
otherwise he selects to query the right child, since the left subtrees are
identical. When the process ﬁnishes, the light client has arrived at the
ﬁrst point of disagreement between Charlie’s and Eve’s augmented dirty
ledgers.

Once the entry of disagreement is identiﬁed, the light client only needs
to verify that it is fraudulent, as claimed by Charlie: It either contains an
invalid state commitment or an invalid transaction. The light client can
locally evaluate the correct state commitment for this item on its own
by applying the transaction to the previous state commitment (which is
valid as Charlie agrees with it). Therefore, any discrepancy in the state
commitment will be caught by the light client. Lastly, in case of a dis-
crepancy in the transaction, the light client can detect this by asking for
the transaction’s Merkle inclusion proof with respect to the header chain

5

it already holds. Thus, the light client can identify the correct dirty tree
root, and therefore deduce its correct balance. Here, headers are used to
rule out transactions which are not in the dirty ledger at adversarially
claimed positions.

Structure of the paper. We begin our paper by describing a construc-
tion that works in the setting of blockchain protocols, as this is easier
to illustrate and the reader can refer to a concrete protocol. In our ﬁrst
presentation, we assume that the ledgers presented by one honest and
one adversarial party have exactly the same lengths, and we discuss how
any discrepancies can be resolved using a Bisection Game (Section 3.1).
We then generalize our construction to allow for disagreements in length,
which requires more complex machinery and uses a Challenge Game (Sec-
tion 3.2) that makes use of the earlier bisection game. Next, we include
more parties into the picture (Section 3.3) by introducing a Tournament
that administers multiple instanes of our previous games. We provide
some experimental results such as execution times from our prototype
implementation that show our protocol is practical in Section 4. In par-
ticular, we observe that the light clients can determine the correct state
on the order of seconds that matches the state-of-the-art for eager block-
chains. We then generalize our construction to non-blockchain protocols
by introducing the concept of a consensus and execution oracle in Sec-
tion 5. This allows our construction to leverage an axiomatic approach
in which the underlying system only needs to satisfy 9 axioms. While
we provide intuition about the security of our construction early on, we
leave the theoretical analysis for the end: Our security and succinctness
theorems treating the axiomatic construction are stated in Section 6 and
formally proven in Appendix A.

Related work. Lazy distributed ledger systems stand at the heart of
any Layer-1 scalability solution. Popular such systems include Celestia
(LazyLedger) [1], Prism [3], Parallel Chains [22] and Snap-and-Chat [39,40].
In the Appendix, we discuss how Celestia, Prism and Snap-and-Chat can
be instantiated. Eager light clients were ﬁrst introduced by Nakamoto [38].
Superlight clients for eager proof-of-work blockchains were put forth as
NIPoPoWs [32,10,29,34] and CODA [8]. Improved light clients for eager
proof-of-stake chains were described by Gaˇzi et al. [25]. Our techniques are
orthogonal to theirs and can be composed as discussed in Section 7. Our
interactive bisection game is based on the work of Canetti et al. [13] which
was ﬁrst applied in the blockchain setting by Arbitrum [28]. Computa-
tion over large public logs was also explored by VerSum [27]. Contrary to
Canetti and Arbitrum, where bisection games are used to dispute com-

6

putation over known data with a predetermined duration and result, our
bisection games are administered over ledgers. Their data, due to nodes
being out of synchrony for a bound duration, can be somewhat incon-
sistent. This challenge requires us to introduce novel techniques in these
refereed games. The fraud proofs we use for our challenges are modelled
after the work of Al-Bassam et al. [2].

As an alternative to our construction, recursive compositions [7] of
SNARKs [6] and STARKs [5] can be used to support non-interactive lazy
light clients. For example, Coda [8] relies on recursive SNARKs to enable
veriﬁcation of all past state transition in constant time, independent of
the number of past transitions. Thus, on Coda, a light client can be con-
vinced that a given state commitment is correct in constant time through
a succinct proof.

2 Preliminaries & Model

Notation. For a natural number n, we use the bracket notation [n] to
mean the set {1, · · · , n}. We use (cid:15) to denote the empty string. Given two
strings a and b, we write a (cid:107) b for some unambiguous encoding of their
concatenation. Given a sequence X, we address it using X[i] to mean the
ith element (starting from 0). We use negative indices to address elements
from the end, so X[−i] is the ith element from the end, and X[−1] in
particular is the last element. We use X[i:j] to denote the subsequence of
X consisting of the elements indexed from i (inclusive) to j (exclusive).
The notation X[i:] means the subsequence of X from i onwards, while
X[:j] means the subsequence of X up to (but not including) j. We use
|X| to denote the size of a sequence. For a non-empty sequence X, we use
(x:xs) ← X to mean that the ﬁrst element of X is assigned to x, while
the rest of the elements are assigned to the (potentially empty) sequence
xs. Reversely, given an element x and a sequence xs, we use (x:xs) to
denote the sequence where the ﬁrst element is x and the rest are xs. In
our multi-party algorithms, we use m (cid:57)(cid:57)(cid:75) A to indicate that message m
is sent to party A and m (cid:76)(cid:57)(cid:57) A to indicate that message m is received
from party A. We use X ≺ Y to mean that the sequence X is a strict
preﬁx of Y . Similarily, we use X (cid:22) Y to mean that X is a preﬁx of Y . We
use X | Y to mean that X is a subarray of Y , meaning all the elements
of X appear in Y consecutively.
Parties. Our protocol augments an existing permissionless lazy block-
chain protocol of multiple participants. There are three types of nodes:
Consensus nodes, full nodes, and light clients.

7

Consensus nodes. The consensus nodes receive and broadcast chains
consisting of blocks. Each node locally maintains a chain C which always
begins at the genesis block G. They validate the consensus rules of these
chains [38], such as proof-of-work or proof-of-stake validity. These chains
contain constant size transactions in some order. Each node reads its chain
and produces a sequence of transactions called a ledger. This provides
a total order of transactions. A consensus node also receives new, yet
unconﬁrmed, transactions from the network to be introduced into the
blockchain. To do this, it extends the blockchain by proposing new blocks
that contain these transactions.

The consensus node is lazy: It treats transactions as meaningless
strings, without validating them. It includes in its proposed block any
transaction it receives with some spam-resilience mechanism.

At any point in time, the views of diﬀerent consensus nodes can be
diﬀerent. Honest consensus nodes follow the speciﬁed consensus protocol.
On the contrary, adversarial consensus nodes can arbitrarily deviate from
it. The consensus protocol imposes some trust assumptions: For example,
in proof-of-work [21], it is assumed that the majority of consensus nodes
by compute are honest, and in proof-of-stake [33,14], it is assumed that the
majority of the system’s money is in honest hands. These assumptions are
necessary so that the local views of the ledgers of diﬀerent parties satisfy
two properties: (1) Safety mandates that any transaction that appears in
the ledger of one honest party will also eventually appear in the ledger of
every honest party at the same position; (2) Liveness mandates that, if
an honest party broadcasts a new transaction, it will eventually appear
in the ledger of an honest party.
Full nodes. The full nodes maintain chains and ledgers just like the
consensus nodes, but they do not produce new blocks. Instead, they rely
on the fact that consensus nodes maintain the blockchain. Like consensus
nodes, each full node also produces a ledger of transactions. Contrary to
consensus nodes, full nodes execute transactions to maintain a state.

The current state of the system is uniquely determined by the ledger.
An empty ledger corresponds to a constant genesis state, st0. To deter-
mine the state of a non-empty ledger, transactions from the ledger are
iteratively applied on top of the state, starting at the genesis state. This
application of transactions on existing state is captured by a transition
function δ. Consider a dirty ledger L = tx1 · · · txn. Then the state of
the system is δ(· · · δ(st0, tx1), · · · , txn). We use the shorthand notation δ∗
to apply a sequence of transactions tx = tx1 · · · txn to a state. Namely,
δ∗(st0, tx) = δ(· · · δ(st0, tx1), · · · , txn).

8

Some transactions can be applied on top of a particular state, but
others may not, because they are invalid with respect to the state (for
example, they could be double spends). Because we are dealing with lazy
systems, these invalid transactions are still contained in the ledger, hence
the ledger is called dirty. We denote Lv
r the dirty ledger in the view of a
full node v at time r. If safety is guaranteed, then we use L∪
r to denote
the longest among all the dirty ledgers kept by honest parties at round r.
Similarly, we use L∩
r to denote the shortest among them. We skip r in this
notation if it is clear from the context. By convention, if transaction tx
cannot be applied to state st because tx is invalid with respect to st, we let
δ(st, tx) = st. Because the state can grow large, it is often useful to provide
a succinct representation of state, which we call a state commitment and
denote by (cid:104)st(cid:105). We assume that state commitments have constant size. We
denote by (cid:104)·(cid:105) the commitment function that takes the state and produces
the state commitment, e.g., the commitment of the state st is denoted as
(cid:104)st(cid:105).

For example, in Ethereum, the state is the list of all account balances
(among other data). The state is organized into a Merkle tree and its
root is the state commitment. A value-transfer transaction tx modiﬁes an
element of the state st at two positions: the balances of an outgoing and
the balances of an incoming account. The new state st(cid:48) is determined as
st(cid:48) = δ(st, tx). The transaction is deemed invalid if the outgoing account
has insuﬃcient balance. In that case, applying the transaction leaves the
balances unchanged.
Light clients. A light client wishes to ﬁnd out a particular state ele-
ment, e.g., its own account balance. However, it wishes to do so without
downloading the whole ledger or executing all the transactions. As in the
SPV model, the light client will download and verify the header chain,
e.g., the longest chain headers containing transaction roots, but not ev-
ery transaction (Transaction root might be the root of the Merkle tree of
transactions organized within a block.) While a full node needs to down-
load data proportional to O(|C| + L), we want a light node to learn its
desired state element by downloading asymptotically less data. We call
a lazy light client succinct if instead of L, it only needs to download
poly log L transactions.
The Prover–Veriﬁer model. We are interested in a light client V who
is booting up the network for the ﬁrst time. The light client holds only
the genesis block and is always honest. It connects to full nodes who
have fully synchronized with the rest of the network. The light client
acts as a veriﬁer, while the full nodes act as provers [32]. We assume at

9

least one of the provers Ph that the veriﬁer connects to is honest (the
standard non-eclipsing assumption [23,24,26,47]), but the rest could be
adversarially controlled. The honest parties follow the protocol speciﬁed
here. The adversary can run any probabilistic polynomial-time algorithm.
Network. Time proceeds in discrete rounds numbered with the natural
numbers {0, 1, · · · }. Our network treatment is in the synchronous model,
where a message sent by one honest party at the end of round r is received
by all honest parties at the beginning of round r + 1. Our adversary can
inject arbitrary messages to the network. Communication is over anony-
mous channels that the adversary can Sybil attack [20] by introducing
as many honest-appearing messages as she wishes. She can also reorder
the messages sent by honest nodes and deliver them in a diﬀerent order
to diﬀerent honest nodes. However, the adversary cannot censor honest
messages – honestly broadcast messages are guaranteed to be delivered
to all honest parties.

end if
mid ← (cid:98) |data|
(cid:99)
tree ← Tree(

return Tree(root: H(data[0]), data: data[0])

Algorithm 1 Creates a Merkle tree using the given data.
1: function MakeMT(data)
2:
if |data| = 1 then
3:
4:
5:
6:
7:
8:
)
9:
tree.root ← H(tree.left.root (cid:107) tree.right.root)
10:
11:
return tree
12: end function

left: MakeMT(data[:mid]),
right: MakeMT(data[mid:])

2

Primitives. We use H to denote a generic cryptographically secure
hash function. For our purposes, we require the function to be collision-
resistant [36]. We make use of Merkle Trees [37] and their variants. Our
Merkle trees always contain data whose length is a power of 2(cf. Algo-
rithm 1). For data that has diﬀerent lengths, we organize it into a Merkle
Mountain Range [35,46,19]. In a Merkle Mountain Range, the data is
split into chunks with length decreasing powers of 2. Each such chunk of
data is organized into a Merkle Tree. The resulting roots, the peaks, are
all collected and hashed together to produce the Merkle Mountain Range
root.

10

3 Construction

Initially, the veriﬁer downloads the header chain. This can later be used
as a reference to check transaction inclusion and ordering. Because we are
working with a lazy blockchain, there are no state commitments within
the headers. The rest of the protocol will allow us to determine the state.
Augmented Dirty Ledgers and Dirty Trees. The prover needs to
create a tree representing all transactions and states in the system ac-
cording to its local dirty ledger. Towards this purpose, the prover aug-
ments each element of its dirty ledger L and produces an augmented dirty
ledger L+. Every transaction in the original dirty ledger is replaced, in
the augmented dirty ledger, with a pair. The pair contains the original
transaction as well as a commitment to the state of the world after this
transaction is applied. Thus, the augmented dirty ledger contains pairs
in the form of (tx, (cid:104)st(cid:105)) of a transaction tx and a state commitment (cid:104)st(cid:105),
one for each transaction in the dirty ledger L. In addition, it contains as
a ﬁrst element, the pair ((cid:15), (cid:104)st0(cid:105)), where the ﬁrst pair entry is the empty
string (because there is no genesis transaction) and the second entry is the
commitment to the genesis state (cid:104)st0(cid:105). The state commitment of L+[i+1]
is computed by applying the transaction at L[i] to the state committed
to by L+[i]. Concretely, if L = (tx1, tx2, . . .), then

L+ = (((cid:15), (cid:104)st0(cid:105)), (tx1, (cid:104)δ(st0, tx1)(cid:105)), (tx2, (cid:104)δ(δ(st0, tx1), tx2))(cid:105)), . . .) .

The dirty tree T corresponding to an augmented dirty ledger L+ is

deﬁned as the Merkle tree that contains L+[i] as the i-th leaf.
Views in Disagreement. Consider a light client V that connects to an
honest prover P and an adversarial prover P ∗, but does not know who is
who. Let st be the current state in the view of P at round r. Let L denote
the dirty ledger, L+ denote the augmented dirty ledger, and T denote the
corresponding dirty tree of P at round r. The last entry L+[−1] of the
honest augmented dirty ledger contains the commitment (cid:104)st(cid:105) to the state
st. The client wishes to learn the value of a particular state element in st.
Towards this purpose, V only needs to learn a truthful state commitment
(cid:104)st(cid:105); from there, an inclusion proof, e.g., a Merkle proof, into (cid:104)st(cid:105) suﬃces
to show inclusion of any state element value. So the goal of P will be to
convince V of the correct state commitment (cid:104)st(cid:105). If both provers respond
to V’s request with the same commitment (cid:104)st(cid:105), then the client can rest
assured that the received state commitment is correct (because at least
one prover is honest). If they diﬀer, the client must discover the truth.
If at any point in time, one of the provers fails to respond in a timely

11

fashion (within one round of receiving its query), the prover is considered
adversarial and ignored thereafter. In practice, this equates to a short
timeout in the network connection.

The two provers claim that the state commitment is (cid:104)st(cid:105) and (cid:104)st(cid:105)∗
respectively, where (cid:104)st(cid:105) (cid:54)= (cid:104)st(cid:105)∗. To prove the correctness of its state com-
mitment, P sends to V the root (cid:104)T (cid:105) of T , the length (cid:96) = |L+| of its
augmented dirty ledger, i.e., the number of leaves on T , and the Merkle
proof π from the last leaf L+[−1], which contains (cid:104)st(cid:105), to the root (cid:104)T (cid:105).
The adversary P ∗ sends to V an alleged root (cid:104)T (cid:105)∗, an alleged length (cid:96)∗,
and an alleged Merkle proof π∗. Since (cid:104)st(cid:105) (cid:54)= (cid:104)st(cid:105)∗, if π and π∗ both verify,
then we have that (cid:104)T (cid:105) (cid:54)= (cid:104)T (cid:105)∗. In this case, V mediates a bisection game
between P and P ∗ to determine whether (cid:104)T (cid:105) or (cid:104)T (cid:105)∗ commit to (cid:104)st(cid:105).

We deﬁne a well-formed ledger and tree to be those constructed ac-

cording to our honest algorithm.

Deﬁnition 1 (Well-formed Ledgers and Trees). An augmented dirty
ledger L+ is said to be well-formed with respect to dirty ledger L, transi-
tion δ, genesis state st0, and commitment function (cid:104)·(cid:105) if:

– L+[0] = ((cid:15), (cid:104)st0(cid:105)) and,
– ∀ i ∈ [|L+| − 1], L+[i] = (txi, (cid:104)sti(cid:105)) such that (txi−1, txi) | L, and

sti = δ∗(st0, L[:i]).

A dirty tree T is said to be well-formed if its leaves correspond to the

entries of a well-formed augmented dirty ledger.

The augmented dirty ledger and dirty tree held by an honest prover
are always well-formed. Hence, to determine whether (cid:104)T (cid:105) or (cid:104)T (cid:105)∗ commit
to (cid:104)st(cid:105), it suﬃces for the veriﬁer to check if (cid:104)T (cid:105) or (cid:104)T (cid:105)∗ correspond to the
root of a well-formed dirty tree.

3.1 Bisection Game

The bisection game is played between two provers, one designated as a
challenger and the other designated as a responder. The challenger sends
queries to the responder through the veriﬁer, upon which the responder
replies through the same channel (cf. Figure 1). In particular, the chal-
lenger ﬁrst sends his query to the veriﬁer. The veriﬁer then forwards this
query to the responder. Upon receiving the query from the veriﬁer, the re-
sponder produces a response and sends it back to the veriﬁer. Lastly, the
veriﬁer forwards this response to the challenger. Subsequently, the chal-
lenger can follow up with more queries. As the veriﬁer forwards queries

12

and responses, it performs sanity checks on both of them to ensure that
they are well-formed and that the responses correctly correspond to the
queries asked. All of the communication of the bisection game between
the two provers passes through the veriﬁer. The purpose of the challenger
is to convince the veriﬁer that the responder’s dirty tree root does not
correspond to the root of a well-formed tree. The purpose of the responder
is to defend his claim that his dirty tree root is the root of a well-formed
tree. We will design the game in such a fashion that an honest challenger
will always win against an adversarial responder, and an honest responder
will always win against an adversarial challenger.

if (cid:96) = 1 then
return

Algorithm 2 The algorithm ran by an honest challenger to identify the
ﬁrst point of disagreement against the responder’s dirty tree, given that
the trees of the challenger and the responder have the same size (cid:96), but
diﬀerent roots. The variable T represents the challenger’s dirty tree.
1: function TreeVsTree(T , (cid:96))
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14: end function

end if
(h∗
l , h∗
(hl, hr) ← T .left.root, T .right.root
if hl = h∗

l then
1 (cid:57)(cid:57)(cid:75) Responder
TreeVsTree(T .right, (cid:98) (cid:96)

0 (cid:57)(cid:57)(cid:75) Responder
TreeVsTree(T .left, (cid:98) (cid:96)

(cid:46) We are done; let the veriﬁer check the leaf

(cid:46) Ask to open inner node

r) (cid:76)(cid:57)(cid:57) Responder

end if

else

2 (cid:99))

2 (cid:99))

The game proceeds in a binary search fashion similar to refereed del-
egation of computation [13,12,28]. For simplicity, let us for now assume
that (cid:96) = (cid:96)∗ and they are a power of two. If (cid:104)T (cid:105) (cid:54)= (cid:104)T (cid:105)∗, then there must
be a ﬁrst point of disagreement between the two underlying augmented
dirty ledgers L+ and L∗
+ alleged by the two provers. During the game, an
honest challenger tries to identify the ﬁrst point of disagreement between
his augmented dirty ledger L+ and the one the adversarial responder
claims to hold. Let j be the index of that ﬁrst point of disagreement pin-
pointed by the honest challenger. Then, the challenger asks the responder
to reveal the (j − 1)st and jth entries of his augmented dirty ledger. Upon
observing that the revealed entries violate the well-formedness conditions

13

of Deﬁnition 1, the veriﬁer concludes that the responder’s dirty tree is
not well-formed. On the other hand, the honest responder replies to the
adversarial challenger’s queries truthfully. Therefore, the adversarial chal-
lenger cannot pinpoint any violation of the well-formedness in the honest
augmented dirty ledger.

We will now describe how the protocol allows the challenger to dis-
cover the ﬁrst point of disagreement. The honest challenger runs Algo-
rithm 2, whereas the honest responder runs Algorithm 3. The challenger
ﬁrst asks the responder to reveal the left and the right children of the re-
sponder’s dirty tree root (cid:104)T (cid:105)∗. Let h∗
r denote the children returned
by the responder (cf. Figure 1 and Algorithm 2 Line 5 and Algorithm 3
Line 6). Let hl and hr be the children of the challenger’s root (cid:104)T (cid:105). The
r) = (cid:104)T (cid:105)∗. If the check fails, the
l (cid:107) h∗
veriﬁer then checks whether H(h∗
responder is a liar, and the veriﬁer designates him as a loser in the game
(Algorithm 2). Otherwise, as (cid:104)T (cid:105) (cid:54)= (cid:104)T (cid:105)∗, either hl (cid:54)= h∗
r. If
hl = h∗
r, and the challenger repeats the same
step with the two children of h∗
l and the challenger
continues with the children of h∗

r. Otherwise, hl (cid:54)= h∗
l (Lines 9 and 12 of Algorithm 2).

l , then necessarily hr (cid:54)= h∗

l or hr (cid:54)= h∗

l and h∗

T ∗ ← MakeMerkleTree(L+)
T ∗.root (cid:57)(cid:57)(cid:75) Challenger
while T ∗.size > 1 do

Algorithm 3 The algorithm ran during the bisection game by the re-
sponder to reply to the challenger’s queries while the challenger tries to
identify the ﬁrst point of disagreement against the responder’s Merkle
Tree. The variable L+ denotes the responder’s augmented dirty ledger.
1: function Respond(L+)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15: end function

(h∗
(h∗
dir (cid:76)(cid:57)(cid:57) Challenger
if dir = 0 then
T ∗ ← T ∗.left

end if
end while
T ∗.data (cid:57)(cid:57)(cid:75) Challenger

r) ← (T ∗.left.root, T ∗.right.root)
r) (cid:57)(cid:57)(cid:75) Challenger

T ∗ ← T ∗.right

l , h∗
l , h∗

else

These queries continue until the challenger reaches a leaf with index
j. The veriﬁer forwards and veriﬁes exactly up to log (cid:96) inner node queries

14

and one leaf query. Then, the challenger pinpoints the location j as the
ﬁrst point of disagreement, and the honest responder reveals the leaf data
(txj, (cid:104)stj(cid:105)) (Algorithm 3 Line 14). Finally, if j ≥ 1, the honest responder
also sends the leaf (txj−1, (cid:104)stj−1(cid:105)) at index j − 1, along with its Merkle
proof π within its dirty tree in a single round of interaction (if j = 0, then
the veriﬁer already knows the contents of the ﬁrst leaf of a well-formed
augmented dirty ledger). This last response is only checked by the veriﬁer
and does not need to be forwarded to the challenger. For brevity, we omit
this portion from the responder’s algorithm.

If the responder is adversarial, she could send malformed responses.
We use the notation (cid:104)st(cid:105)j to denote the claimed jth state commitment
by the responder, but this may be malformed and does not necessarily
correspond to an actual commitment (cid:104)stj(cid:105), where stj is the jth state of
an honest party’s augmented dirty ledger. In fact, it may not be a com-
mitment at all. Similarly, the claimed tree root (cid:104)T (cid:105)∗, provided by the
adversary may not necessarily be generated by the MakeMerkleTree
algorithm as (cid:104)T (cid:105)∗ (cid:54)= (cid:104)T (cid:105).

The veriﬁer algorithm is described by Algorithm 2.

3.2 Ledgers of Diﬀerent Sizes

In the previous section, we assumed that the sizes of the augmented dirty
ledgers were powers of two, and so they could easily be organized into a
Merkle tree. In reality, these could attain other values. To organize such
ledgers, provers use Merkle Mountain Ranges (MMRs). An MMR is a
sequence of Merkle trees of decreasing size, each of which is a power of
two. Provers construct their MMRs using Algorithm 4, where the input
data is their augmented dirty ledger. To build an MMR, a prover divides
his augmented dirty ledger L+ into segments s1, s2, . . . , sk with lengths
(cid:96) = ((cid:96)1, (cid:96)2, . . . , (cid:96)k), where (cid:96)1 = 2q1 > (cid:96)2 = 2q2 > . . . > (cid:96)k = 2qk are
unique decreasing powers of 2. This is always possible by writing the
length |L+| of the augmented dirty ledger in binary form and looking at
the ‘1’s: |L+| = (cid:80)k
i=1 2qi. Each of these k segments is then organized into
a Merkle tree, and those trees T = (T1, T2, . . . , Tk) are all collected into an
array, which is the MMR T . The roots (cid:104)T (cid:105) = ((cid:104)T (cid:105)1 , (cid:104)T (cid:105)2 , . . . , (cid:104)T (cid:105)k) of
these Merkle trees T = (T1, T2, . . . , Tk), where (cid:104)T (cid:105)i = (cid:104)Ti(cid:105), are called the
peaks. Besides organizing data of diﬀerent sizes, MMRs have the added
beneﬁt of being easily amendable.

15

The game is terminated by the veriﬁer as soon as the victory of one of the provers
becomes certain.
Challenger wins. The challenger wins the bisection game in the veriﬁer’s view when-
ever one of the following conditions fails:

1. The responder must not timeout, i.e., must reply to a query within one round of

receiving it from the veriﬁer.

2. The response of the responder must be syntactically valid according to the expec-
tations of the veriﬁer, e.g., if the challenger has asked for the two children of a
Merkle tree inner node, these must be two hashes.

3. For the two nodes hl and hr returned by the responder as the children of a node

h on its dirty tree, h = H(hl (cid:107) hr).

4. If j ≥ 1, the Merkle proof for the (j − 1)st leaf of the responder’s dirty tree is valid.
5. If j ≥ 1, (txj−1, txj) | L∪.
6. If j ≥ 1, for the claimed state commitments (cid:104)st(cid:105)j−1 , (cid:104)st(cid:105)j, there is an underlying

state stj−1 such that (cid:104)stj−1(cid:105) = (cid:104)st(cid:105)j−1 and (cid:104)st(cid:105)j = (cid:104)δ(stj−1, txj)(cid:105).

7. If j = 0, the claimed state commitment (cid:104)st(cid:105)0 matches the genesis state commitment

(cid:104)st0(cid:105) known to the veriﬁer and tx0 = (cid:15).

To check condition 5, the veriﬁer consults the already downloaded header chain (cf.
Section 5.2). To check condition 6, the veriﬁer requests a proof
from the responder
that illustrates the correct state transition from (cid:104)st(cid:105)j−1 to (cid:104)st(cid:105)j, e.g., the balances that
were updated by txj (cf. Section 5.3).
Responder wins. The responder wins and the challenger loses in the veriﬁer’s view
if one of the following conditions fails:

1. The challenger must send valid queries. A valid query is a root number on the ﬁrst
round (if the responder holds multiple Merkle trees), or a single bit in any next
round.

2. The challenger must not timeout, i.e., must send a query within a round of being

asked by the veriﬁer.

If both parties respond according to these rules, then the responder wins.

Fig. 2: The algorithm ran by the veriﬁer to determine the winner of the
bisection game.

Algorithm 4 Creates a Merkle Mountain Range using the given data
for the leaves.
1: function MakeMMR(data)
if |data| = 0 then
2:
3:
return [ ]
4:
5:
6:
7:
8:
9: end function

end if
bound ← 2(cid:98)log |data|(cid:99)
head ← MakeMT(data[:bound])
tail ← MakeMMR(data[bound:])
return (head:tail)

16

Fig. 3: The challenger’s MMR (top) is compared to the responder’s alleged
MMR. The ﬁrst two peaks (A in blue) are the same, so they are skipped
by Algorithm 6. The second peak of the challenger is reached (B in purple)
and compared against the responder’s second peak (C). When found to be
diﬀerent, the challenger knows all of the remaining responder peaks (the
black at the bottom) will lie within his own current tree (B in purple), so
Algorithm 6 Line 4 calls Algorithm 7 to compare the black peaks against
the purple tree.

The following fact will be useful and follows from the organization of

the tree into powers of two:

Fact 1 (Tree Subsumption). In any Merkle Mountain Range T con-
taining trees of lengths {(cid:96)i}i∈[k], for any i ∈ [k] it holds that (cid:96)i > (cid:80)k
j=i+1 (cid:96)j.

Additionally, it is possible that even two honest provers have aug-
mented dirty ledgers of diﬀerent sizes (cid:96) (cid:54)= (cid:96)∗. This is an artifact of net-
work delays. We will now explore our full protocol that allows the veriﬁer
to compare competing claims of diﬀerent sizes by two provers.

Suppose an honest prover P holding an augmented dirty ledger LP
+
claims to a veriﬁer V that the latest state commitment is (cid:104)st(cid:105). Then, to
prove its claim, P ﬁrst organizes its augmented dirty ledger into an MMR
and sends its peaks (cid:104)T (cid:105) = ((cid:104)T (cid:105)1 , (cid:104)T (cid:105)2 , . . . , (cid:104)T (cid:105)k) to V, together with the
length (cid:96) = |LP
+|. It also sends a Merkle proof π from the last augmented
dirty ledger entry LP
+[−1], which contains (cid:104)st(cid:105), to the last Merkle tree
root (cid:104)T (cid:105)k.

Suppose another prover P ∗ also claims to V that the latest state com-
mitment is (cid:104)st(cid:105)∗ (cid:54)= (cid:104)st(cid:105). To back his claim, P ∗ also sends to V an alleged
sequence of peaks (cid:104)T (cid:105)∗ = ((cid:104)T (cid:105)∗
1 , (cid:104)T (cid:105)∗
k∗), an alleged length (cid:96)∗,
and an alleged Merkle proof π∗. In this case, V ﬁrst checks whether π and
π∗ verify with respect to (cid:104)T (cid:105)k and (cid:104)T (cid:105)∗
k∗. If the proof given by a prover
cannot be veriﬁed, V rejects his claim. Otherwise, if ((cid:104)T (cid:105) , (cid:96)) (cid:54)= ((cid:104)T (cid:105)∗ , (cid:96)∗),

2 , . . . , (cid:104)T (cid:105)∗

ChallengerResponderAABCC17

then V initiates a challenge game to ﬁnd which of the two provers holds
a well-formed augmented dirty ledger.

During the challenge game, the prover that claimed to have a larger
augmented dirty ledger L+ acts as the challenger while the other one, with
the smaller augmented dirty ledger L∗
+, acts as the responder. The goal
of the challenger is to identify the ﬁrst point on the responder’s alleged
augmented dirty ledger that disagrees with his own ledger. He starts the
challenge by calling Algorithm 5.

Algorithm 5 The algorithm ran by the challenger to start the chal-
lenge game. The challenger’s goal is to identify the ﬁrst point of dis-
agreement against the responder’s alleged augmented dirty ledger. The
variable L+ denotes the challenger’s augmented dirty ledger. The vari-
able (cid:104)T (cid:105)∗ denotes the peaks received from the responder, and (cid:96)∗ denotes
the augmented dirty ledger size claimed by the responder. The function
GetSizes takes the length of an augmented dirty ledger and returns the
sequence of number of leaves under the Merkle trees in the corresponding
MMR.
1: function Challenge(L+)
2:
3:
4:
5:
6:
7: end function

trees ← MakeMMR(L+)
sizes ← GetSizes(|L+|)
(cid:96)∗, (cid:104)T (cid:105)∗ (cid:76)(cid:57)(cid:57) Responder
reSizes ← GetSizes((cid:96)∗)
FindPeak(trees, sizes, (cid:104)T (cid:105)∗, reSizes)

The challenge game consists of two phases: During the ﬁrst phase,
the zooming phase, the challenger reduces his search of the ﬁrst point of
disagreement to a single tree within the responder’s MMR. After this ﬁrst
phase is completed, the second phase consists of either the two parties
playing a bisection game, similar to the previous section, or the challenger
going into a suﬃx monologue.
Zooming phase. To narrow his search down to a single tree, the chal-
lenger ﬁrst calls Algorithm 6 to identify the earliest peak in the respon-
der’s peaks that disagrees with his own peaks. Algorithm 6 iterates over
the responder’s peaks (Algorithm 6 Line 2) until the challenger ﬁnds a
peak (cid:104)T (cid:105)∗
i among those returned by the responder, that is diﬀerent from
the corresponding root (cid:104)Ti(cid:105) in his own peaks. If the number of leaves
under both peaks are the same, the challenger calls Algorithm 2 to play

18

the bisection game of the previous section on the Merkle trees whose
roots are (cid:104)Ti(cid:105) and (cid:104)T (cid:105)∗
i (Algorithm 6 Line 7). Otherwise, if the number of
leaves under (cid:104)T (cid:105)∗
i is smaller than the number of leaves under (cid:104)Ti(cid:105), then,
by Fact 1, all the data within the responder’s remaining peaks allegedly
lies under the ith peak of the challenger (see Figure 3). The challenger
has now narrowed the ﬁrst point of disagreement to his own ith tree and
can compare it against the responder’s remaining peaks. This is done by
calling Algorithm 7 on the remaining peaks returned by the responder
(Algorithm 6 Line 4).

Algorithm 6 The algorithm ran by the challenger to identify the ﬁrst
peak in the MMR of the responder that is diﬀerent from that of the
challenger. The variables T and (cid:96) denote the challenger’s sequence of
∗
Merkle trees and a sequence of their respective sizes, whereas (cid:104)T (cid:105)∗ and (cid:96)
denote the responder’s sequence of peaks and the corresponding number
of leaves respectively.

∗
return TreeVsPeaks(T [i], (cid:104)T (cid:105)∗[i:], (cid:96)

)

[i] then

for i = 0 to |(cid:104)T (cid:105)∗| − 1 do
∗
if (cid:96)[i] (cid:54)= (cid:96)

∗
1: function PeaksVsPeaks(T , (cid:96), (cid:104)T (cid:105)∗, (cid:96)
2:
3:
4:
5:
6:
7:
8:
9:
10: end function

end if
if T [i].root (cid:54)= (cid:104)T (cid:105)∗[i] then

return TreeVsTree(T [i], (cid:96)[i])

end for

end if

[i:])

Algorithm 6 already narrowed the challenger’s search to within one of
its trees (purple tree denoted B in Figure 3). Now the goal of Algorithm 7
is to narrow down the search of the ﬁrst point of disagreement to one of the
peaks of the responder, so that the veriﬁer can compare the two trees using
the earlier bisection game. Consider the remaining peaks of the responder
overlayed onto the challenger’s tree Ti (dashed lines in Figure 3). These
correspond to certain inner nodes within Ti (black, red, and red subtrees
at the top of Figure 3). Algorithm 7 locates the ﬁrst such inner node that
disagrees with the corresponding responder’s peak (left-most red tree at
the top of Figure 3).

To ﬁnd the ﬁrst disagreeing inner node, the challenger traverses a path
on Ti that starts at (cid:104)Ti(cid:105) and ends at the root of the desired subtree within

19

Algorithm 7 The algorithm ran by the challenger to identify the ﬁrst
subtree root under one of the challenger’s larger Merkle trees that is
diﬀerent from a responder’s peak. The variable T denotes the challenger’s
larger Merkle tree whereas (cid:104)T (cid:105)∗ and (cid:96)
denote the responder’s sequence of
peaks (with some of the ﬁrst elements chopped oﬀ during the recursion)
and the corresponding number of leaves respectively.

∗

∗

)

(cid:46) Done

return

(cid:96)∗∈(cid:96)∗ (cid:96)∗

assert T .size > (cid:80)
if |(cid:104)T (cid:105)∗| = 0 then

end if
(peak:peaks) ← (cid:104)T (cid:105)∗
∗
(reSize:reSizes) ← (cid:96)
if (cid:98) T .size

1: function TreeVsPeaks(T , (cid:104)T (cid:105)∗, (cid:96)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15: end function

ChallengeTree(T , reSize)

else if tree.left.root = peak then

(cid:99) > reSize then

end if

else

2

TreeVsPeaks(T .left, (cid:104)T (cid:105)∗, reSizes)

TreeVsPeaks(T .right, peaks, reSizes)

Ti. Let ˜T denote an inner node of Ti that lies on the path. Let ˜T .left and
˜T .right denote the children of T . While exploring ˜T , the challenger checks
if the number of leaves under ˜T .left exceeds the total number of leaves
under the responder’s remaining roots (Algorithm 7 Line 8). If this is the
case, all of the responder’s remaining roots must lie within ˜T .left. Thus,
the challenger moves to ˜T .left (Algorithm 7 Line 9). Otherwise, the chal-
lenger checks if the root of ˜T .left, i.e., the left child of ˜T , equals the ﬁrst
peak among the remaining ones returned by the responder (Algorithm 7
Line 10). If so, the ﬁrst point of disagreement is later, and so the chal-
lenger moves to ˜T .right (Algorithm 7 Line 11). The search ends when
˜T .left diﬀers.
Bisection game. Once the search ends, the challenger calls Algorithm 2
to play the bisection game on the sub-trees under ˜T and the responder’s
currently inspected root (Algorithm 7 Line 13). At the end of the algo-
rithm, just like before, a ﬁrst point of disagreement is pinpointed. We
remark here that, if the point j of disagreement is the ﬁrst leaf of this
tree, then the last step of the algorithm, which requires the veriﬁer to
execute the state transition, will require the responder to also open up
leaf j − 1. Note that this opening will have to be with respect to the

20

trees ← MakeMMR(L+)
peaks ← {tree.root : tree ∈ trees}
peaks (cid:57)(cid:57)(cid:75) Challenger
pNum (cid:76)(cid:57)(cid:57) Challenger
tree ← trees[pNum]
while tree.size > 1 do

Algorithm 8 The algorithm ran by the responder to reply to the chal-
lenger’s queries while the challenger tries to identify the ﬁrst point of
disagreement against the responder’s MMR. The variable L+ denotes the
responder’s augmented dirty ledger.
1: function Respond(L+)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17: end function

(tree.left, tree.right) (cid:57)(cid:57)(cid:75) Challenger
dir (cid:76)(cid:57)(cid:57) Challenger
if dir = 0 then

end if
end while
dirtyLedger[loc] (cid:57)(cid:57)(cid:75) Challenger

(cid:46) Enter a particular Merkle Tree

tree ← tree.right

tree ← tree.left

else

previous peak. After the bisection game is played, one of the challenger
or the responder is declared the winner and the other one is declared the
loser.

Suﬃx monologue. It is possible that the challenger and the responder
will never enter into a bisection game, if none of the return statements
in Algorithm 6 are reached, or if Algorithm 7 Line 4 is reached. In that
case, there is no ﬁrst point of disagreement between the two. Therefore,
the two alleged augmented dirty ledgers form a preﬁx of one another: the
responder’s alleged L∗
+ of length (cid:96)∗ is a preﬁx of the challenger’s alleged
L+ of length (cid:96) > (cid:96)∗ (if (cid:96) = (cid:96)∗, and given that the two parties have
a disagreement, then they must have played a bisection game; thus at
this point, (cid:96) > (cid:96)∗). This situation can arise even when both provers are
honest due to network synchronization issues. In particular, the challenger
could have seen more recent transactions on the network. (Due to the
Common Preﬁx property [23], the discrepancy between two honest provers
is bounded to ledger extensions that correspond to k blocks.) Hence, it is
the challenger’s turn to present the augmented dirty ledger entries that
extend the responder’s augmented dirty ledger. Speciﬁcally, the challenger
must present the suﬃx L+[(cid:96)∗:].

21

The veriﬁer checks all the transitions within this suﬃx. Concretely,
for every consecutive (txj, (cid:104)stj(cid:105)) and (txj+1, (cid:104)stj+1(cid:105)), for (cid:96)∗ ≤ j < |L+|−1,
the veriﬁer checks the inclusion of txj and txj+1 in the header chain as
before, and veriﬁes that the state (cid:104)stj+1(cid:105) has been computed correctly
using δ. The veriﬁer also checks the transition from L∗
+[−1],
i.e., the responder’s last augmented dirty ledger entry, to L+[(cid:96)∗], i.e., the
ﬁrst entry in the challenger’s suﬃx, since the challenger, by starting the
suﬃx monologue, claims that his augmented dirty ledger is a suﬃx of the
responder’s. The entry L∗
+[−1] has already been revealed, together with
a proof of inclusion, by the responder at the beginning of the protocol.

+[(cid:96)∗ − 1] = L∗

If the challenger fails to present a well-formed suﬃx, then the re-
sponder is declared the winner, while the challenger is declared the loser.
Otherwise, if the suﬃx presented is well-formed, then both provers are
declared winners of the challenge game. Unlike the bisection game, at the
end of the suﬃx monologue, both the challenger and the responder can
win.

Towards succinctness, the veriﬁer checks only the ﬁrst α(u + ν) extra
entries from the challenger’s augmented dirty ledger extension. Here, α,
u and ν are constants selected in accordance with the chain growth and
liveness parameters of the blockchain (cf. Table 1). Therefore, in reality,
the challenger only needs to send the portion L+[(cid:96)∗: min((cid:96), (cid:96)∗ + α(u + ν))]
of his suﬃx. If the challenger is able to present more than α(u + ν) extra
entries with consecutive transactions and correct state transitions, then
the responder is declared a loser, as he presented a ledger that is too short
to possibly be honest, due to the Common Preﬁx property.

3.3 Multiparty Tournaments

Upon joining the network, the veriﬁer contacts the set of all available
provers3 for queries. If all of the responses are the same, the veriﬁer ac-
cepts the response as the correct answer. If it receives diﬀerent responses,
the veriﬁer arbitrates a tournament, described by Algorithm 9, among
the provers that responded. The purpose of the tournament is to select a
prover whose latest claimed stable state is both safe and live (cf. Deﬁni-
tion 9). That is, the veriﬁer wants to obtain a state at least as up-to-date
as the state obtained by applying the state transition function iteratively
on the transactions in L∩.

3 In practice, the veriﬁer contacts a small subset of them. As a concrete ex-
ample, according to https://github.com/bitcoin/bitcoin/blob/master/doc/
reduce-traffic.md, Bitcoin makes 8 outbound full-relay connections.

22

Suppose the veriﬁer hears back from n provers. Before the tournament,
the veriﬁer orders the n provers into a sequence P1, P2, . . . , Pn in an
increasing order of the augmented dirty ledger sizes claimed by the provers
(i.e., the size of P1’s alleged MMR is equal to or smaller than that of P2
and so on). This sequence dictates the order in which the provers play
the bisection game with each other. Then, it calls Algorithm 9 to start
the tournament.

The tournament consists of n steps. Before the ﬁrst step, Algorithm 9
initializes S = ∅. At the end of each step t, the set S contains each prover
that has engaged in at least one challenge game, and has not lost any of
those by step t.

do

else

sizes[p] ← p.getsize()

sizes ← { }
for p ∈ P do

if largest.getsize() > sizes[i] then

result ← Challenge(largest, P[i])

end for
S ← {P[0]}
largest ← P[0]
for i = 1 to |P| − 1 do

Algorithm 9 The tournament among the provers administered by the
veriﬁer. It takes a sequence of provers P, ordered in a decreasing fashion
according to the alleged augmented dirty ledger sizes.
1: function Tournament(P)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29: end function

while result is “largest loses” ∧ S (cid:54)= ∅
if S = ∅ then
S ← {P[i]}

S ← S \ {largest}
largest ← arg maxp∈S sizes
else if result is “P[i] loses” then

end if
if result is “nested MMRs” then

result ← Challenge(P[i], largest)

(cid:46) The set S does not need to be updated

else if result is “largest loses” then

end for
return largest

S ← S ∪ {P[i]}

end if

end if

23

The tournament starts with a challenge game between P1 and P2,
during which the prover with the larger alleged augmented dirty ledger
challenges the other. The winners are added to S and the tournament
moves to the second step. At each step of the tournament, the set S is
updated to contain the winners so far. Players may be removed from the
set S if they lose, and new winners can be added to S as they win. Each
player P is considered in order. Let P denote the prover in S that claims
to have the largest augmented dirty ledger at a given round. The prover
among {P, P} with the larger alleged augmented dirty ledger challenges
the other prover (Lines 11 and 13 of Algorithm 9). Depending on the
outcome of the challenge game, there are three cases:

1. If both provers win, P is added to S and the tournament moves to

step 3 (Line 16 of Algorithm 9).

2. If P loses, the tournament directly moves to step 3 and S stays the

same. (Line 21 of Algorithm 9).

3. If P wins and P loses, P is removed from S (Line 18 of Algorithm 9).
Then, P challenges the new P, the prover with the largest alleged
size among those remaining in the set S (or vice versa). This case
is repeated until either one of cases (1) or (2) happens, or there are
no provers left in S (Line 23 of Algorithm 9). If the latter happens,
P is added to S and the tournament moves to step 3 (Line 25 of
Algorithm 9).

The procedure above is repeated until the end of step n − 1, after which,
P wins the tournament. Hence, the veriﬁer accepts the state commitment
of P among those remaining in S as the correct state.

The above procedure consists of O(n) bisection games. The reason is
that, after each game, one party is eliminated from the winners, either by
not being added to S, or by being removed from S, and every party can
be eliminated at most once.

3.4 Prover Complexity
Given an augmented dirty ledger of length (cid:96) = (cid:80)k
i=1 2qi, qi ∈ N, each
prover can construct the corresponding MMR with O((cid:96)) number of com-
putations upon entering the challenge game. This is because each prover
can obtain the binary representation of (cid:96) with O((cid:96)) operations, and cre-
ate each of the k Merkle trees Ti, i ∈ [k], with O(2qi) hash computations,
making the total compute complexity O((cid:96)).

Moreover, provers need not create a new MMR from scratch at each
challenge game. Full nodes can maintain an MMR of the augmented dirty

24

ledger in their memory and augmented the MMR when a new entry is
added to the ledger in their view. A node that holds an MMR with (cid:96)
leaves in total can construct the MMR containing a single new leaf with
O(log (cid:96)) hash computations since the prover only needs to combine the ex-
isting log (cid:96) hashes to update the MMR. Hence, per each new transaction,
each prover only incurs logarithmic compute complexity. In particular,
updating the MMR on a rolling basis, each prover can obtain the MMR
with (cid:96) leaves with O((cid:96) log (cid:96)) number of operations. Thus, our algorithms
require in total quasi-linear number of operations in the ledger size from
each full node over the lifetime of the protocol.

4

Implementation

4.1 Latency-Bandwidth Trade-oﬀ

So far, we have only discussed binary Merkle trees for use in our bisection
game. However, we can consider m-ary Merkle trees more generally. In a
dirty tree representing an L-sized ledger, the dirty tree height decreases
logarithmically as the degree of the tree increases, making the number of
rounds of interactivity in the game logm L. At the same time, the length
of each message of the challenger is now no longer a single bit, but needs
to indicate the index of the child to open, making it log m bits in size.
When the responder opens up an inner node and reveals its children, m
children need to be sent over the network. If the hash used is H bits long,
then the messages sent by the responder are mH bits. There is therefore
a latency/bandwidth tradeoﬀ in the parameter m. A large m incurs less
interactivity, but larger network messages, while a small m incurs more
interactivity but shorter network messages. In this section, we calculate
the optimal m, given the respective network parameters on bandwidth
and latency.

Let ∆ be the network latency between the prover and veriﬁer, mea-
sured in seconds, and C be the communication bandwidth of the chan-
nels connecting each prover to the veriﬁer. We assume that, upon down-
loading any given message, the prover and the veriﬁer can compute the
corresponding reply instantly (network latency dominates computational
latency).

At the beginning of the bisection game, the responder sends the m
hash values corresponding to the children of the root node on its dirty
tree. The challenger then selects one of them and sends back log m bits,
through the veriﬁer, to specify the selected child. This is repeated for

logm L rounds until the challenger speciﬁes one of the leaves on the re-
sponder’s dirty tree to be opened.

25

At each round, log m and mH bits are downloaded by the responder
and the challenger respectively. Moreover, each message sent between
the responder and challenger takes 2∆ seconds to reach its destination,
because it has to be forwarded through the veriﬁer. Hence, each round is
completed in 4∆+(mH+log m)/C seconds, making the total running time
(cid:1)+ log L
of the bisection game
C .
This expression is minimized for m that satisﬁes the expression m(log m−
1) = 4∆C
eH ) + 1), where W1 is the Lambert W
function. The diﬀerent optimal m for a range of common bandwidths and
latencies are plotted in Figure 4.

H , i.e., m = exp (W1(4∆ C

logm L = log L
log m

4∆ + mH+log m

(cid:0)4∆ + mH
C

(cid:16)

(cid:17)

C

Fig. 4: Optimal Merkle tree degree m (isolines) for a given network con-
nection bandwidth (x-axis, in Mbps) and latency (y-axis, in ms). The ×
marker marks the particular example described in the text.

Given4 C = 290 Mbps, ∆ = 13 ms, H = 256 bits, the optimal m is
7,442, yielding dirty trees that have quite a large degree. Note that the
optimal m only depends on the network parameters and not the ledger

4 Typical conditions for the network connection in Stanford university graduate stu-

dent residences.

50100150200250300Bandwidth(Mbps)255075100125150175200Latency(ms)5,00010,00015,00020,00025,00030,00035,00040,00045,00050,00055,00060,00065,00070,00075,00080,00020,00040,00060,00080,00026

size. Given the Ethereum ledger of L = 1.5 · 109 transactions at the time
of writing5, using the optimal m for the given network parameters gives
an estimate of 0.96 seconds, where 0.86 seconds of the time is due to the
network delay ∆. This captures the duration of the whole bisection game
with its logm L rounds of interactivity.

4.2 Experiments

Implementation and experimental setup. We implement a proto-
type of the prover and the veriﬁer in 1000 lines of Golang6, and set up
17 provers on AWS r5.xlarge instances distributed across 17 data cen-
ters around the globe. All provers have ledgers of the same size, but only
one of the provers has the correct augmented dirty ledger. Each of the
remaining 16 provers has an augmented dirty ledger that diﬀers from the
correct one at a randomly selected position. To simplify the prototype,
we do not implement a state transition function δ (e.g., the Ethereum
Virtual Machine). Instead, all transactions and state commitments (cf..
Algorithm 2) are random byte strings. We hard code the prover and the
veriﬁer such that a state commitment is valid to the veriﬁer only if the
prover has the correct commitment in its augmented dirty ledger. We run
the veriﬁer under a residential internet connection with 300 Mbps down-
link and 10 Mbps uplink bandwidth. The veriﬁer connects to all of the
17 provers, and arbitrates the tournament (Algorithm 9) among them.

Veriﬁcation latency. We ﬁrst explore the duration of the tournament,
and how the degree m of the Merkle tree aﬀects the performance. For this
experiment, we ﬁx the ledger size to 10 million transactions vary m. For
each conﬁguration, we run 10 tournaments and measure the average and
the standard deviation of the duration. Figure 5a shows the results. When
m = 300, the duration reaches the lowest, at 18.37s. Most blockchains
conﬁrm transactions with a latency of tens of seconds. In comparison,
the tournament adds little extra time on top of the end-to-end latency
that a light client perceives for new transactions. Under this conﬁguration,
a tournament consists of 16 games, and each game involves 4 rounds of
interaction between the veriﬁer and the provers. On average, each round
of interaction lasts for 0.287s. In comparison, the average network round-
trip time (RTT) from the veriﬁer to the provers is 0.132s.

5 Google Cloud Platform BigQuery table bigquery-public-data:crypto ethereum.

transactions as of March 6th, 2022

6 The code is opensource under MIT license, and is available at https://github.com/

yangl1996/super-light-client.

27

As we vary m, tournaments take longer to ﬁnish. Speciﬁcally, a smaller
m makes each Merkle tree opening shorter, but increases the number of
openings per game. The propagation latency becomes the main bottleneck
of the game. On the contrary, a larger m makes bandwidth the main
bottleneck. As we increase m to 10000, each opening of the Merkle tree
becomes large enough such that message transmission is aﬀected by the
ﬂuctuation of the internet bandwidth, causing a higher variation in the
tournament duration.
Scalability. We now evaluate how our scheme scales as the ledger size
grows. We ﬁx the tree degree m to 300 and vary the size of the ledger
from 1000 to 100 million transactions. Similar to the previous experiment,
we report the mean and the standard deviation over 10 tournaments for
each datapoint. Figure 5b shows the results. As we increase the ledger size
by 105×, the tournament duration grows from 13s to 26s, an increase of
only 2×. This is because the number of interactions in a game is equal to
the depth of the Merkle tree, which grows logarithmically with the ledger
size.
Prover throughput. Finally, we evaluate the throughput that a prover
can achieve. To minimize the network inﬂuence, we run two provers in
the same datacenter. Each prover has a ledger of 10M transactions, but
their ledgers diﬀer at a random location. We start a veriﬁer in the same
datacenter, which initiates a variable number of bisection games between
the two provers in parallel. We gradually ramp up the parallelism to gen-
erate enough load and saturate the provers. Figure 5c shows the results.
As we ramp up the parallelism, the achieved throughput ﬁrst increases
due to the increased load, and then stays ﬂat because the provers have
saturated their compute. Speciﬁcally, a prover running our prototype can
support a throughput of 680 games/second using its 4 virtual CPU cores.
We expect the throughput to scale with the available CPU cores and disk
IO.

4.3 Denial of service attacks

While our theoretical model assumes synchrony, in practice the veriﬁers
and provers may be susceptible to denial of service attacks in which in-
valid data is sent on the network. To deal with this, provers that submit
invalid data should be blacklisted by the veriﬁer, while provers that time-
out can be ignored after a few strikes. Since bisection games typically
take a few seconds, avoiding denial of service attacks for our construc-
tion is not diﬀerent from avoiding them in standard SPV clients or full

28

Fig. 5:
In (a) and (b), we measure the time to complete a tournament
of 17 geo-distributed provers. Error bars show the standard deviation.
Solid lines show the trend. (a) Time when varying the tree degree m. (b)
Time when varying the ledger size L. (c) Throughput of games with two
provers and one veriﬁer co-located in a data center. The veriﬁer initiates
games with variable parallelism to saturate the provers.

 0 20 40 60 80 100 120 10 100 1000 10000Duration (s)Tree degree 0 5 10 15 20 25 30 1000 10000 100000 1x106 1x107 1x108Duration (s)Ledger size 0 200 400 600 800 1000 50 100 150 200 250 300Throughput (games/s)# games in parallel29

nodes. All well known heuristic techniques for avoiding such attacks can
be employed here.

5 Generalizing the Model

So far, we have assumed that the underlying consensus protocol is block-
chain based and that the computation of state mimicks the Ethereum
EVM. However, there exist diﬀerent architectures for consensus (e.g.,
DAG-based constructions [22,43,42]) and execution (e.g., UTXO [18]).
Our protocol is quite generic and agnostic to the details of how the con-
sensus and execution layers are implemented. To enable the formal analy-
sis of our construction in a generic manner, in this section we axiomatize
the protocol requirements regarding consensus and execution.

Primitive

Axiom

Param Requirement

Ledger

Safety

Liveness

Lipschitz

Completeness

Consensus

Soundness

Succinctness

Completeness

Execution

Soundness

Succinctness

-

u

α

-

ν

f

-

-

g

r1 (cid:22) LP2
LP1
r2
tx in LP

r+u

|LP

r2 | − |LP

r1 | ≤ α(r2 − r1)

(tx, tx(cid:48)) in L∪

r → COr(tx, tx(cid:48))

(tx, tx(cid:48)) not in L∪

r+ν → ¬COr(tx, tx(cid:48))

f (r) ∈ O(poly log r)

δ(st, tx) = st(cid:48) → (cid:104)δ(cid:105) ((cid:104)st(cid:105) , tx, π) = (cid:104)st(cid:48)(cid:105)

(cid:104)δ(st, tx)(cid:105) (cid:54)= (cid:104)δ(cid:105) ((cid:104)st(cid:105) , tx, π) is hard

g(r) ∈ O(poly log r)

Table 1: The 9 axioms required to construct a succinct light client.

5.1 Consensus Protocol

We consider a consensus protocol C executed by honest full nodes. Each
honest full node P exposes a read ledger functionality which, at round
r, returns a ﬁnite sequence LP
r of stable transactions as the dirty ledger.
They also expose a write transaction functionality which, given a trans-
action tx at round r, attempts to include the transaction into the ledger.

Our consensus protocol must satisfy the following properties.

30

Deﬁnition 2 (Ledger Safety). A consensus protocol C is safe if for all
honest parties P1, P2 at rounds r1 < r2, LP1

r1 is a preﬁx of LP2
r2 .

Deﬁnition 3 (Ledger Liveness). A consensus protocol C is live with
liveness parameter u if, when an honest party P attempts to write a trans-
action tx to the ledger at round r, the transaction appears in LP

r+u.

Proof-of-work (in static and variable diﬃculty) and proof-of-stake pro-

tocols satisfy the above properties [23,24,33,17,16].

Deﬁnition 4 (Ledger Lipschitz). A consensus protocol C is Lipschitz
with parameter α if for every honest party P and rounds r1 ≤ r2, we have
that |LP

r1| < α(r2 − r1).

r2| − |LP

The above requirement states that ledgers grow at a bounded rate. For
blockchain based protocols, this follows from the fact that chains have an
upper bound in their growth rate [48, Theorem 4], and that the number
of transactions in each block is limited by a constant.

5.2 Consensus Oracle

To enable queries about the order of transactions on the dirty ledger, we
assume that the lazy blockchain protocol provides access to a consensus
oracle CO. The consensus oracle is a single-round black box interactive
protocol executed among the veriﬁer and the provers. The veriﬁer invokes
the oracle with input two transactions (tx, tx(cid:48)) and receives a boolean
response. The goal of the veriﬁer is to determine whether a transaction
tx(cid:48) immediately follows another transaction tx on L∪ (i.e., (tx, tx(cid:48)) | L∪).
We require that the consensus oracle satisﬁes the following properties.

Deﬁnition 5 (Consensus Oracle Security). An consensus oracle is
secure if it satisﬁes:
– Completeness. When invoked at round r, it holds that COr(tx, tx(cid:48)) =

true when (tx, tx(cid:48)) | L∪
r .

– Soundness. The consensus oracle is sound with delay parameter ν

if for any PPT adversary A,

Pr[(tx, tx(cid:48), r) ← A(1λ);

COr(tx, tx(cid:48)) ∧ (tx, tx(cid:48)) (cid:45) L∪

r+ν] ≤ negl(λ) .

Deﬁnition 6 (Consensus Oracle Communication Complexity). A
consensus oracle has communication complexity f (r) if the total size of
the query and respond messages exchanged during an oracle query invoked
at round r is f (r) ∈ O(r).

31

We assume that every transaction in the dirty ledger is unique and
there are no duplicate transactions. Under this assumption, a consensus
oracle on top of the Nakamoto longest chain consensus protocol can be
instantiated as follows. Since the construction below also applies to pro-
tocols that output a chain of blocks, we will refer to the longest chain as
the canonical chain.

The blockchain consists of a header chain, each header containing the
Merkle tree root, i.e. the transaction root, of the transactions organized
within the associated block. The ordering of the blocks by the header
chain together with the ordering imposed on the transactions by each
Merkle tree determine the total order across all transactions. Thus, to
query the consensus oracle with the two transactions tx and tx(cid:48) (cid:54)= tx, the
veriﬁer ﬁrst downloads all the block headers from the honest provers and
determines the canonical stable header chain. Then, it asks a prover if tx
immediately precedes tx(cid:48) on its dirty ledger.

To aﬃrm, the prover replies with:

– the positions i and i(cid:48) of the transactions tx and tx(cid:48) within their re-

spective Merkle trees,

– the Merkle proofs π and π(cid:48) from the transactions tx and tx(cid:48) to the

transaction roots,

– the positions j ≤ j(cid:48) of the block headers containing these transaction

roots, on the canonical stable header chain.

Then, the veriﬁer checks that the Merkle proofs are valid, and accepts

the prover’s claim if and only if either of the following cases hold:

1. the two blocks are the same, i.e., j(cid:48) = j, and i(cid:48) = i + 1,
2. otherwise, the two blocks are consecutive, i.e., j(cid:48) = j + 1, and i is the
index of the last leaf in the tree of block j while i(cid:48) is the index of the
ﬁrst leaf in the tree of block j(cid:48) = j + 1.

If no prover is able to provide such a proof, the oracle returns false to

the veriﬁer. The oracle’s soundness follows the ledger safety.

The above is one example instantiation of a consensus oracle. Ap-
pendix B gives proofs of completeness and soundness for the consensus
oracle as well as notes on how it can be implemented on diﬀerent block-
chain protocols.

To relax the uniqueness assumption for the transactions in the dirty
ledger, each augmented dirty ledger entry containing a transaction tx can
be extended by adding the index jtx of the header of the block containing
tx, and the index of tx within the Merkle tree of that block. In this case,

32

the veriﬁer queries the consensus oracle not only with transactions tx
and tx(cid:48)
(cid:54)= tx, but also with the corresponding block header and Merkle
tree indices jtx, itx and jtx(cid:48), itx(cid:48). Hence, during the query, the veriﬁer also
checks if the block and transaction indices for tx and tx(cid:48), e.g., j, i and j(cid:48), i(cid:48),
received from the prover matches the claimed indices: j = jtx, j(cid:48) = jtx(cid:48),
i = itx, i(cid:48) = itx(cid:48).

5.3 Execution Oracle

To enable queries about the validity of state execution, we assume that
the lazy blockchain protocol provides access to an execution oracle. The
execution oracle is a single-round black box interactive protocol executed
among the veriﬁer and the provers. The veriﬁer invokes the oracle with
a transaction tx and two state commitments, (cid:104)st(cid:105) and (cid:104)st(cid:105)(cid:48) as input,
and receives a boolean response. The goal of the veriﬁer is to determine
whether there exists a state st such that (cid:104)st(cid:105) is the commitment of st and
(cid:104)st(cid:105)(cid:48) = (cid:104)δ(tx, st)(cid:105).

The execution oracle is parametrized by a triplet (δ, (cid:104)·(cid:105) , (cid:104)δ(cid:105)) consist-
ing of an eﬃciently computable transition function δ(·, ·), a commitment
scheme (cid:104)·(cid:105), and a succinct transition function (cid:104)δ(cid:105) (·, ·, ·). The succinct
transition function (cid:104)δ(cid:105) accepts a state commitment (cid:104)st(cid:105), a transaction tx,
and a proof π, and produces a new state commitment (cid:104)st(cid:105)(cid:48) which corre-
sponds to the commitment of the updated state.

To query the execution oracle on tx, (cid:104)st(cid:105) and (cid:104)st(cid:105)(cid:48), the veriﬁer ﬁrst asks
a prover for a proof π. If the prover claims that there exists a state st such
that (cid:104)st(cid:105) is the commitment of st and (cid:104)st(cid:105)(cid:48) = (cid:104)δ(tx, st)(cid:105), it gives a proof
π. Then, the veriﬁer accepts the prover’s claim if (cid:104)st(cid:105)(cid:48) = (cid:104)δ(cid:105) ((cid:104)st(cid:105) , tx, π).
Otherwise, if (cid:104)δ(cid:105) throws an error or outputs a diﬀerent commitment, the
veriﬁer rejects the claim.

Deﬁnition 7 (Execution Oracle Security). An execution oracle is
secure if it satisﬁes:

– Completeness. The execution oracle is complete with respect to a
proof-computing PPT machine M if for any state st and transaction
tx, it holds that M (st, tx) outputs a π that satisﬁes (cid:104)δ(cid:105) ((cid:104)st(cid:105) , tx, π) =
(cid:104)δ(st, tx)(cid:105).

– Soundness. For any PPT adversary A:

Pr[(st, tx, π) ← A(1λ);

(cid:104)δ(st, tx)(cid:105) (cid:54)= (cid:104)δ(cid:105) ((cid:104)st(cid:105) , tx, π)] ≤ negl(λ) .

33

Deﬁnition 8 (Execution Oracle Communication Complexity). An
execution oracle has communication complexity g(r) if the total size of the
query and respond messages exchanged during an oracle query invoked at
round r is g(r) ∈ O(r).

In the account based model [2], the state is a Sparse Merkle Tree
(SMT) [15] representing a key-value store. The values constitute the leaves
of the SMT and the keys denote their indices. The state commitment
corresponds to the root.

The veriﬁer queries the execution oracle with tx, (cid:104)st(cid:105) and (cid:104)st(cid:105)(cid:48). Suppose
there is a state st with commitment (cid:104)st(cid:105) and (cid:104)st(cid:105)(cid:48) = (cid:104)δ(st, tx)(cid:105). Let D
denote the leaves of the SMT st. Let Stx be the keys of the SMT that
the transaction tx reads from or writes to. We assume that the number
of leaves touched by a particular transaction is constant. Then, the proof
required by (cid:104)δ(cid:105) consists of:

– The key-value pairs (i, D[i]) for i ∈ Stx within st.
– The Merkle proofs πi, i ∈ Stx, from the leaves D[i] to the root (cid:104)st(cid:105).

Given the components above, (cid:104)δ(cid:105) veriﬁes the proofs πi and the validity
of tx with respect to the pairs (i, D[i]), e.g., tx should not be spending
from an account with zero balance. If there are pairs read or modiﬁed by
tx that have not been provided by the prover, then (cid:104)δ(cid:105) outputs ⊥. If all
such key-value pairs are present and tx is invalid with respect to them,
(cid:104)δ(cid:105) outputs (cid:104)st(cid:105), and does not modify the state commitment. Otherwise,
(cid:104)δ(cid:105) modiﬁes the relevant key-value pairs covered by Stx, which can be
done eﬃciently [12]. Finally, it calculates the new SMT root, i.e. the
new state commitment, using the modiﬁed leaves and the corresponding
Merkle proofs among πi, i ∈ Stx.

SMTs can also be used to represent states based on the UTXO [38]
model. In this case, the value at each leaf of the SMT is a UTXO. Thus,
the execution oracle construction above generalizes to the UTXO model.

6 Analysis

The security of the protocol relies on the completeness and succinctness
of the consensus oracle and the execution oracle.

Deﬁnition 9 (State Security). An interactive Prover–Veriﬁer protocol
(P, V ) is state secure with safety parameter ν, if the state commitment
(cid:104)st(cid:105) obtained by the veriﬁer at the end of the protocol execution at round
r satisﬁes safety and liveness as deﬁned below.

34

There exists a ledger L such that (cid:104)δ∗(st0, L)(cid:105) = (cid:104)st(cid:105), and for all rounds

r(cid:48) ≥ r + ν:

– Safety. L is a preﬁx of L∪
r(cid:48).
– Liveness. L is a suﬃx of L∩
r .

The theorems for succinctness and security of the protocol are given
below. Security consists of two components: completeness and soundess.

Lemma 1 (Succinctness). Consider a consensus and execution oracle
with f and g communication complexity respectively. Then, the challenge
game invoked at round r with sizes (cid:96)1 and (cid:96)2 > (cid:96)1 ends in log((cid:96)1+α(u+ν))
rounds of communication and has a total communication complexity of
O(log((cid:96)1)) + α(u + ν)(f (r) + g(r))).

Theorem 1 (Completeness). Suppose the consensus and execution
oracles are complete and the ledger is safe. Then, the honest responder
wins the challenge game against any PPT adversarial challenger.

Theorem 2 (Soundness). Let H s be a collision resistant hash func-
tion. Suppose the consensus and execution oracles are complete and sound.
Then, for all PPT adversarial responders A, an honest challenger wins
the challenge game against A with overwhelming probability in λ.

Theorem 3 (Tournament Runtime). Suppose the consensus and ex-
ecution oracles are complete and sound, and have f and g communication
complexity respectively. Consider a tournament started at round r with n
provers. Given at least one honest prover, for any PPT adversary A,
the tournament ends in 2n log(|L∪
r | + α(u + ν)) rounds of communication
and has a total communication complexity of O(2n log(|L∪
r | + α(u + ν)) +
2nα(u + ν)(f (r) + g(r))), with overwhelming probability in λ.

Theorem 4 (Security). Suppose the consensus and execution oracles
are complete and sound, and have f and g communication complexity
respectively. Consider a tournament started at round r with n provers.
Given at least one honest prover, for any PPT adversary A, the state
commitment obtained by the prover at the end of the tournament satisﬁes
State Security with overwhelming probability in λ.

Proofs of the lemmas and theorems above are given in Appendix A.

35

7 Superlight Clients

In our construction, we abstracted the checking of transaction order
that the veriﬁer performs into a consensus oracle, and discussed how
this can be realized in the blockchain setting using the standard SPV
technique, achieving communication complexity of O(C) = O(r), where
C is the chain size and r is the round during which the light client is
booting up. This gives a total of O(C + log L) communication complex-
ity for our lazy light client protocol. However, the consensus oracle can
be replaced with a superlight client that does not download the whole
header chain, and instead samples a small portion of it. Such examples
include interactive [30] or non-interactive PoPoWs, a primitive which can
be constructed using either superblocks [32,31] or FlyClient [10], and
brings down the consensus oracle communication complexity to a suc-
cinct O(poly log C) = O(poly log r). When composed with our protocol
for identifying lazy ledger disagreements, the total communication com-
plexity then becomes O(poly log C + log L) = O(poly log r), which is the
desirable succinctness. We highlight the diﬀerent roles of each protocol
here: On the one hand, the superlight client, such as FlyClient or su-
perblocks, plays the role of the consensus oracle and is used to answer
queries about which transaction succeeds another on the chain; on the
other hand, the interactive veriﬁcation game is administered to deter-
mine the current state of the world, given access to such a consensus
oracle. The two protocols are orthogonal and can be composed to achieve
an overall performant system.

Full
Node

Light
Client

Superlight
Client

Custodian
Wallet

Interactivity

O(1)

O(log L)

O(log L)

Communication O(C + L)

O(C + log L)

O(log CL)

Decentralized

(cid:88)

(cid:88)

(cid:88)

O(1)

O(1)

×

Table 2: Comparison of diﬀerent client types on a lazy blockchain.

The interactivity and communication complexity for synchronization
times for lazy light clients composed with diﬀerent consensus oracles is
illustrated in Table 2. A Full Node (left-most column) downloads the

36

whole header chain of size C and every transaction of size L, thus does not
need to play any interactive games, achieving constant interactivity but
large communication complexity. A Custodian Node (right-most column)
is a wallet that trusts a server to deliver correct data and does not verify
it (e.g., MetaMask); this has the best performance in both complexity
and interactivity. These were the only two previously known means of
constructing clients for lazy blockchains. The two protocols titled Light
Client and Superlight Client in the middle columns are clients composed
with the lazy light clients explored in this work. In the light client case,
an SPV client is used for the consensus oracle, while in the super light
client case, a NIPoPoW superblock client is used for the consensus oracle.
The C or log C term stems from the underlying consensus oracle, while
the log L term stems from our lazy protocol.

Acknowledgements

We thank Shresth Agrawal, Kostis Karantias, Angel Leon and Joachim
Neu for several insightful discussions on this project.

References

1. Al-Bassam, M.: Lazyledger: A distributed data availability ledger with client-side

smart contracts (2019)

2. Al-Bassam, M., Sonnino, A., Buterin, V.: Fraud and data availability proofs: Max-
imising light client security and scaling blockchains with dishonest majorities.
arXiv:1809.09044 [cs.CR] (2018)

3. Bagaria, V., Kannan, S., Tse, D., Fanti, G., Viswanath, P.: Prism: Deconstruct-
ing the blockchain to approach physical limits. In: Proceedings of the 2019 ACM
SIGSAC Conference on Computer and Communications Security. p. 585–602. CCS
’19, ACM (2019)

4. Bagaria, V., Kannan, S., Tse, D., Fanti, G., Viswanath, P.: Prism: Deconstructing

the blockchain to approach physical limits. working paper (2019)

5. Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable, transparent, and
post-quantum secure computational integrity. IACR Cryptol. ePrint Arch. 2018,
46 (2018)

6. Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: From extractable collision re-
sistance to succinct non-interactive arguments of knowledge, and back again. In:
Proceedings of the 3rd Innovations in Theoretical Computer Science Conference.
p. 326–349. ITCS ’12, ACM, New York, NY, USA (2012)

7. Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: Recursive composition and boot-
strapping for snarks and proof-carrying data. In: Proceedings of the forty-ﬁfth
annual ACM symposium on Theory of computing. pp. 111–120 (2013)

8. Bonneau, J., Meckler, I., Rao, V., Shapiro, E.: Coda: Decentralized cryptocurrency

at scale. Cryptology ePrint Archive (2020)

37

9. Buchman, E., Kwon, J., Milosevic, Z.: The latest gossip on BFT consensus.

arXiv:1807.04938 (2018), https://arxiv.org/abs/1807.04938

10. B¨unz, B., Kiﬀer, L., Luu, L., Zamani, M.: Flyclient: Super-light clients for cryp-
tocurrencies. In: 2020 IEEE Symposium on Security and Privacy (SP). IEEE (2020)
11. Buterin, V.e.a.: Light client protocol (2014), https://eth.wiki/en/concepts/

light-client-protocol

12. Canetti, R., Riva, B., Rothblum, G.N.: Practical delegation of computation using
multiple servers. In: Proceedings of the 18th ACM conference on Computer and
communications security. pp. 445–454 (2011)

13. Canetti, R., Riva, B., Rothblum, G.N.: Refereed delegation of computation. Infor-

mation and Computation 226, 16–36 (2013)

14. Chen, J., Micali, S.: Algorand: A secure and eﬃcient distributed ledger. Theoretical

Computer Science 777, 155–183 (2019)

15. Dahlberg, R., Pulls, T., Peeters, R.: Eﬃcient sparse merkle trees. In: Nordic Con-

ference on Secure IT Systems. pp. 199–215. Springer (2016)

16. Daian, P., Pass, R., Shi, E.: Snow white: Robustly reconﬁgurable consensus and
applications to provably secure proof of stake. In: Financial Cryptography and
Data Security. pp. 23–41. FC ’19, Springer (2019)

17. David, B., Gaˇzi, P., Kiayias, A., Russell, A.: Ouroboros Praos: An adaptively-
secure, semi-synchronous proof-of-stake blockchain. In: Annual International Con-
ference on the Theory and Applications of Cryptographic Techniques. pp. 66–98.
Springer (2018)

18. Developers, B.: Developer guide - bitcoin. Available at: https://bitcoin.org/en/

developer-guide, https://bitcoin.org/en/developer-guide

19. Developers, G.: Merkle Mountain Ranges (MMR), https://docs.grin.mw/wiki/

chain-state/merkle-mountain-range/

20. Douceur, J.R.: The sybil attack. In: International Workshop on Peer-to-Peer Sys-

tems. pp. 251–260. Springer (2002)

21. Dwork, C., Naor, M.: Pricing via processing or combatting junk mail. In: Annual

International Cryptology Conference. pp. 139–147. Springer (1992)

22. Fitzi, M., Gaˇzi, P., Kiayias, A., Russell, A.: Parallel chains: Improving throughput
and latency of blockchain protocols via parallel composition. Cryptology ePrint
Archive, Report 1119 (2018)

23. Garay, J., Kiayias, A., Leonardos, N.: The Bitcoin backbone protocol: Analysis

and applications. In: EUROCRYPT 2015. pp. 281–310. Springer (2015)

24. Garay, J.A., Kiayias, A., Leonardos, N.: The bitcoin backbone protocol with chains
of variable diﬃculty. In: Katz, J., Shacham, H. (eds.) Annual International Cryp-
tology Conference. LNCS, vol. 10401, pp. 291–323. Springer (Aug 2017)

25. Gaˇzi, P., Kiayias, A., Zindros, D.: Proof-of-Stake Sidechains. In: 2019 IEEE Sym-

posium on Security and Privacy (SP). pp. 139–156. IEEE (2019)

26. Heilman, E., Kendler, A., Zohar, A., Goldberg, S.: Eclipse attacks on bitcoin’s
peer-to-peer network. In: USENIX Security Symposium. pp. 129–144 (2015)
27. van den Hooﬀ, J., Kaashoek, M.F., Zeldovich, N.: Versum: Veriﬁable computations
over large public logs. In: Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security. pp. 1304–1316 (2014)

28. Kalodner, H., Goldfeder, S., Chen, X., Weinberg, S.M., Felten, E.W.: Arbitrum:
Scalable, private smart contracts. In: 27th USENIX Security Symposium (USENIX
Security 18). pp. 1353–1370 (2018)

29. Karantias, K., Kiayias, A., Zindros, D.: Compact storage of superblocks for
nipopow applications. In: The 1st International Conference on Mathematical Re-
search for Blockchain Economy. Springer Nature (2019)

38

30. Kiayias, A., Lamprou, N., Stouka, A.P.: Proofs of proofs of work with sublinear
complexity. In: International Conference on Financial Cryptography and Data Se-
curity. pp. 61–78. Springer, Springer (2016)

31. Kiayias, A., Leonardos, N., Zindros, D.: Mining in Logarithmic Space. In: Pro-
ceedings of the 2021 ACM SIGSAC Conference on Computer and Communications
Security. pp. 3487–3501 (2021)

32. Kiayias, A., Miller, A., Zindros, D.: Non-Interactive Proofs of Proof-of-Work. In:
International Conference on Financial Cryptography and Data Security. Springer
(2020)

33. Kiayias, A., Russell, A., David, B., Oliynykov, R.: Ouroboros: A Provably Se-
cure Proof-of-Stake Blockchain Protocol. In: Katz, J., Shacham, H. (eds.) Annual
International Cryptology Conference. LNCS, vol. 10401, pp. 357–388. Springer,
Springer (Aug 2017)

34. Kiayias, A., Zindros, D.: Proof-of-work sidechains. In: International Conference on

Financial Cryptography and Data Security. Springer, Springer (2019)

35. Laurie, B., Langley, A., Kasper, E.: Rfc6962: Certiﬁcate transparency. Request for

Comments. IETF (2013)

36. Lindell, Y., Katz, J.: Introduction to Modern Cryptography. Chapman and Hal-

l/CRC (2014)

37. Merkle, R.C.: A digital signature based on a conventional encryption function. In:
Advances in Cryptology - CRYPTO ’87. LNCS, vol. 293, pp. 369–378. Springer
(1987). https://doi.org/10.1007/3-540-48184-2 32

38. Nakamoto, S.: Bitcoin: A peer-to-peer electronic cash system. https://bitcoin.

org/bitcoin.pdf (2008)

39. Neu, J., Tas, E.N., Tse, D.: Snap-and-chat protocols: System aspects. arXiv

preprint arXiv:2010.10447 (2020)

40. Neu, J., Tas, E.N., Tse, D.: Ebb-and-ﬂow protocols: A resolution of the availability-
ﬁnality dilemma. In: 2021 IEEE Symposium on Security and Privacy (SP). pp.
446–465. IEEE (2021)

41. Russell, B.: In Praise of Idleness. Unwin (1935)
42. Sompolinsky, Y., Lewenberg, Y., Zohar, A.: Spectre: A fast and scalable cryptocur-

rency protocol. IACR Cryptology ePrint Archive (2016:1159)

43. Sompolinsky, Y., Zohar, A.: Phantom: A scalable blockdag protocol (2018)
44. Sompolinsky, Y., Wyborski, S., Zohar, A.: PHANTOM and GHOSTDAG: A Scal-
able Generalization of Nakamoto Consensus. IACR Cryptology ePrint Archive
(2018), http://eprint.iacr.org/2018/104

45. Tas, E.N.: Woods Attack on Celestia, https://forum.celestia.org/t/woods-

attack-on-celestia/59

46. Todd, P.: Merkle Mountain Ranges (October 2012), https://github.com/
opentimestamps/opentimestamps-server/blob/master/doc/merkle-mountain-
range.md

47. W¨ust, K., Gervais, A.: Ethereum eclipse attacks. Tech. rep., ETH Zurich (2016)
48. Zindros, D.: Hours of Horus: Keyless Cryptocurrency Wallets. Cryptology ePrint

Archive (2021)

A Proofs

Our proof structure is as follows. First, we prove some facts about the
bisection game, in particular its succinctness, soundness, and complete-

39

ness. We later leverage these results to show that our full game enjoys
the same virtues. Axioms used by the proofs are given by Table 1.

Lemma 2 (Bisection Succinctness). Consider a consensus oracle
and an execution oracle with f and g communication complexity respec-
tively. Then, the bisection game invoked at round r with trees of size (cid:96)
ends in log((cid:96)) rounds of communication and has a total communication
complexity of O(log (cid:96) + f (r) + g(r)).

Proof. When the dirty trees have (cid:96) leaves, there can be at most log (cid:96)
valid queries, as the veriﬁer aborts the game after log (cid:96) queries. Hence,
the bisection game ends in log (cid:96) rounds of interactivity.

At each round of communication, the challenger indicates whether he
wants the left or the right child to be opened (which can be designated by
a constant number of bits), and the responder replies with two constant
size hash values. At the ﬁnal round, the responder returns (txj−1, (cid:104)st(cid:105)j−1)
and (txj, (cid:104)st(cid:105)j), the augmented dirty ledger entries at indices j − 1 and j,
along with the Merkle proof for the j − 1st entry (Alternatively, it only
returns (tx0, (cid:104)st(cid:105)0)). The entries have constant size since transactions and
state commitments are assumed to have constant sizes. The Merkle proof
consists of log (cid:96) constant size hash values. Consequently, the total com-
munication complexity of the bisection game prior to the oracle queries
becomes O(log (cid:96)).

Finally, the veriﬁer queries the consensus oracle on (txj−1, txj) and the
execution oracle on ((cid:104)st(cid:105)j−1 , txj, (cid:104)st(cid:105)j) with O(f (r)) and O(g(r)) commu-
nication complexity. Hence, the total communication complexity of the
bisection game becomes O(log((cid:96)) + f (r) + g(r)).

Lemma 3 (Bisection Completeness). Suppose the consensus and ex-
ecution oracles are complete and the ledger is safe. Then, the honest re-
sponder wins the bisection game against any PPT adversarial challenger.

Proof. We will enumerate the conditions checked by the veriﬁer in Algo-
rithm 2 to show that the honest responder always wins.

The honest responder replies to each valid query from the veriﬁer,
and the replies are syntactically valid. Hence, conditions (1) and (2) of
Algorithm 2 cannot fail.

By the construction of the honest responder’s Merkle tree, each inner
node h queried by the challenger satisﬁes h = H(hl (cid:107) hr) for its children
hl, hr returned in response to the query. For the same reason, the Merkle

40

proof given by the responder is valid. Hence, conditions (3) and (4) cannot
fail either.

If j = 0, by the well-formedness of the responder’s dirty ledger,

(txj, (cid:104)st(cid:105)j) = ((cid:15), (cid:104)st0(cid:105)), so condition (7) cannot fail.

Let r denote the round at which the bisection game was started. If j ≥
1, by the well-formedness of the responder’s dirty tree, for any consecutive
pair of leaves at indices j − 1 and j, it holds that (txj−1, txj) | LP
r (cid:22) L∪
r
due to ledger safety. As the consensus oracle is complete, by Deﬁnition 5,
it returns true on (txj−1, txj), implying that the condition (5) cannot fail.
Finally, by the well-formedness of the responder’s dirty tree, for any
consecutive pair of leaves at indices j − 1 and j, there exist a state stj−1
such that (cid:104)st(cid:105)j−1 = (cid:104)stj−1(cid:105), and (cid:104)st(cid:105)j = (cid:104)δ(stj−1, txj)(cid:105). As the execution
oracle is complete, by Deﬁnition 7, M (stj−1, txj) outputs a proof π such
that (cid:104)δ(cid:105) ((cid:104)stj−1(cid:105) , txj, π) = (cid:104)δ(stj−1, txj)(cid:105). Using the observations above,
(cid:104)δ(cid:105) ((cid:104)st(cid:105)j−1 , txj, π) = (cid:104)st(cid:105)j. Consequently, condition (6) cannot fail. Thus,
the honest responder wins the bisection game against any adversary.

Let Verify(π, (cid:104)T (cid:105) , i, v) be the veriﬁcation function for Merkle proofs.
It takes a proof π, a Merkle root (cid:104)T (cid:105), an index for the leaf i and the leaf v
itself. It outputs 1 if π is valid and 0 otherwise. The following proposition
is a well-known folklore result about the security of Merkle trees, stating
that it is impossible to prove proofs of inclusion for elements that were
not present during the tree construction. It extends the result that Merkle
trees are collision resistant [36].

Proposition 1 (Merkle Security). Let H s be a collision resistant hash
function used in the binary Merkle trees. For all PPT A: Pr[(v, D, π, i) ←
A(1λ) : (cid:104)T (cid:105) = MakeMT(D).root∧D[i] (cid:54)= v ∧Verify(π, (cid:104)T (cid:105) , i, v) = 1] ≤
negl(λ).

Proof. Suppose A is the adversary of the statement. We will construct a
hash collision adversary A(cid:48) that calls A as a subroutine. The adversary A(cid:48)
works as follows. It invokes A(1λ) and obtains v, D, π, i. Let h∗
a−1
denote the hash values within π, where a = log |D| + 1 is the height
of the Merkle tree. Let h1, . . . , ha−1 denote the inner nodes within the
Merkle tree at the positions that correspond to those of h∗
a−1. Let
˜h1, . . . , ˜ha−1 denote the siblings of h1, . . . , ha−1. Deﬁne ˜ha := (cid:104)T (cid:105). Then,
˜h1 = H(D[i]), and for i = 1, . . . , a − 1;

1, . . . , h∗

1, . . . h∗

– If hi is the left child of its parent, ˜hi+1 = H(hi (cid:107) ˜hi).
– If hi is the right child of its parent, ˜hi+1 = H(˜hi (cid:107) hi).

41

Consider the event Merkle-Collision that A succeeds. In that case,
1 = H(v),

a such that ˜h∗

1, . . . , ˜h∗

there exists a sequence of hash values ˜h∗
˜h∗
a = (cid:104)T (cid:105), and for i = 1, . . . , a − 1,
– If hi is the left child of its parent, ˜h∗
– If hi is the right child of its parent, ˜h∗

i+1 = H(h∗
i+1 = H(˜h∗

i (cid:107) ˜h∗
i ).
i (cid:107) h∗

i ).

Finally, for i = 1, . . . , a, deﬁne hi,m and hi,c as follows:

– ha,m = (cid:104)T (cid:105), ha,c = (cid:104)T (cid:105).
– h0,m = v, h0,c = D[i].
– If hi is the left child of its parent, hi,m = h∗
– If hi is the right child of its parent, hi,m = ˜h∗

i and hi,c = hi (cid:107) ˜hi.
i and hi,m = ˜hi (cid:107) hi.
Finally, the adversary A(cid:48) ﬁnds the ﬁrst index p for which there is a

i (cid:107) ˜h∗
i (cid:107) h∗

collision

H(hi,m) = H(hi,c) and hi,m (cid:54)= hi,c

and returns a := hp,m and b := hp,c, if such an index p exists. Otherwise,
it returns Failure.

In the case of Merkle-Collision, for i = 0, . . . , a − 1, hi+1,m =
H(hi,m), hi+1,c = H(hi,c). As v (cid:54)= D[i], a collision must have been
found for at least one index p ∈ [h − 1]. Therefore, Pr[A(cid:48) succeeds] =
Pr[Merkle-Collision].

However, since ∀ PPT A(cid:48):

Pr[(a, b) ← A(cid:48)(1λ) : a (cid:54)= b, H(a) = H(b)] ≤ negl(λ) ,

therefore, Pr[Merkle-Collision] = negl(λ).

The next lemma establishes an important result for our bisection
game: That the honest challenger can pinpoint the ﬁrst point of disagree-
ment or last point of agreement indices j − 1 and j within the responder’s
claimed tree. The result stems from the fact that the data are organized
into a Merkle tree which can be explored, moving left or right, one level at
a time, ensuring the invariant that the ﬁrst point of disagreement remains
within the subtree explored at every step.

Lemma 4 (Bisection Pinpointing). Let H s be a collision resistant
hash function. Consider the following game among an honest challenger
P, a veriﬁer V and an adversarial responder P ∗: The challenger P re-
ceives an array D of size (cid:96) from P ∗, and calculates the corresponding dirty

42

Fig. 6: The world in the view of the proof of Lemma 4. Starred quantities
(right-hand side) denote adversarially provided values. Unstarred quanti-
ties (left-hand side) denote the respective honestly provided values. The
inner node at height q from the leaves is the level containing the lowest
common ancestor between leaves with indices j and j − 1.

tree T with root (cid:104)T (cid:105). Then, P plays the bisection game against P ∗ claim-
ing root (cid:104)T (cid:105)∗ (cid:54)= (cid:104)T (cid:105) and size (cid:96). Finally, V outputs (1, D∗[j − 1], D∗[j]) if
P wins the bisection game; otherwise, it outputs (0, ⊥, ⊥). Here, D∗[j −1]
and D∗[j] are the two entries revealed by P ∗ for the consecutive indices
j − 1 and j during the bisection game. (D∗[−1] is deﬁned as ⊥ if j = 0.)
Then, for all PPT adversarial responder A, Pr[D ← A(1λ); (1, D∗[j −
1], D∗[j]) ← V ∧ (D∗[j − 1] (cid:54)= D[j − 1] ∨ D∗[j] = D[j])] ≤ negl(λ).

Proof. Consider a PPT adversarial responder P ∗ playing the bisection
game against the honest challenger P at some round r. Since the chal-
lenger is honest, his queries are valid and he does not time out. For the
responder to win the bisection game, she must satisfy all the conditions
checked by Algorithm 2.

Consider the event Bad that the responder wins. Conditioned on
Bad, the responder does not timeout and her replies are syntactically
valid. Let a = log (cid:96) + 1 denote the height of the challenger’s dirty tree. At
each round i ∈ [a−1] of interactivity in the bisection game, the responder
reveals two hash values h∗
a−i,r. The subscript a − i signiﬁes the
a−i,l and h∗
alleged height of the nodes h∗
a−i,r. Let hi,l and hi,r denote the
inner nodes in the honest challenger’s dirty tree with the same positions
as h∗
i,l and h∗
i,r. These will always exist, as the veriﬁer limits the rounds
of interaction to a.

a−i,l and h∗

Honest tree T⟨T⟩              _hq,D[j]Adversarial responseshq,rD[j - 1]h2,rh1,r_h3_h2_h1h3h2h1h2,h1,h3,⟨T⟩*                          _h*q,≟D*[j]h*q,rD*[j - 1]h*2,rh*1,r_h*3_h*2_h*1h*3h*2h*1h*2,h*1,h*3,h3,rh*3,r43

At the ﬁrst round, the responder reveals h∗

a−1,r as the
alleged left and right children of its dirty tree root (cid:104)T (cid:105)∗. By condition (3)
a−1,r) = (cid:104)T (cid:105)∗. However, since (cid:104)T (cid:105)∗ (cid:54)= (cid:104)T (cid:105) =
of Algorithm 2, H(h∗
H(ha−1,l (cid:107) ha−1,r), either ha−1,l (cid:54)= h∗
a−1,r or both. Then,
if ha−1,l (cid:54)= h∗
a−1,l to query next; else, he picks
h∗
a−1,r.

a−1,l, the challenger picks h∗

a−1,l or ha−1,r (cid:54)= h∗

a−1,l and h∗

a−1,l (cid:107) h∗

We observe that if a node h∗ = h∗

i,l or h∗ = h∗

i,r, i ∈ {2, . . . , a − 1},

returned by the responder, is queried by the honest challenger,
i−1,l and h∗
– For the two children h∗

i−1,r of h∗, h∗ = H(h∗

i−1,l (cid:107) h∗

i−1,r) by

condition (3).

– For the nodes h, hi−1,l and hi−1,r in the challenger’s dirty tree that
i−1,r; h = H(hi−1,l (cid:107) hi−1,r),

i−1,l and h∗

have the same positions as h∗, h∗
and h (cid:54)= h∗.

– By implication, either hi−1,l

hi−1,l
picks h∗

i−1,l, the challenger picks h∗

(cid:54)= h∗
i−1,r as its next query.

(cid:54)= h∗

i−1,l or hi−1,r (cid:54)= h∗

i−1,r or both. If
i−1,l as its next query; else, it

The queries continue until the challenger queries a node h∗ = h1,l or
h∗ = h1,r returned by the responder, and the responder reveals the leaf
D∗[j] such that H(D∗[j]) = h∗. By induction, h∗ is diﬀerent from the
node h = H(D[j]) with the same position in the challenger’s dirty tree.
Thus, D∗[j] (cid:54)= D[j].

If j = 0, it must hold that D∗[0] = ((cid:15), (cid:104)st0(cid:105)) by condition (7) of
Algorithm 2. However, since the challenger’s dirty tree is well-formed,
D[0] = ((cid:15), (cid:104)st0(cid:105)) as well. Hence, D∗[0] = D[0], therefore necessarily j > 0.
(When the provers hold MMRs instead of Merkle treees, responder’s
augmented dirty ledger entries D∗[j − 1] and D∗[j] can lie in diﬀerent
Merkle trees held by the responder. In this case, since the honest chal-
lenger did not initiate a bisection game between the responder’s peak
T ∗
containing D∗[j − 1] and his corresponding inner node Ti = T ∗
i ,
i
D∗[j −1] = D[j −1] with overwhelming probability. To show this, we con-
struct the PPT Merkle tree adversary that outputs D∗[j − 1], the honest
challenger’s leaves under Ti, the responder’s Merkle proof π∗ for D∗[j − 1]
with respect to Ti = T ∗
i and the index of D[j − 1] within the subtree of
Ti, if D∗[j − 1] (cid:54)= D[j − 1]; and Failure otherwise. Since this adversary
succeeds except with negligible probability in λ, D∗[j − 1] = D[j − 1] with
overwhelming probability, and this concludes the proof. In the rest of this
section, we assume that j − 1 and j lie in the same Merkle tree of the
responder.)

As j > 0, there must exist a last node queried by the challenger such
q,r revealed by the responder at height q, it

that for its children h∗

q,l and h∗

44

q,l = hq,l and h∗
last = h∗

holds that h∗
went right). Deﬁne h∗

q,r (cid:54)= hq,r (This is the last time the challenger
q,l (see Figure 6).
By condition (4) of Algorithm 2, the Merkle proof π∗ for D∗[j − 1]
1, h∗
a−1 denote the sequence of
1 := H(D∗[j − 1]) and deﬁne ˜h∗
i+1, i = 1, . . . , a − 1,
i (cid:107) ˜h∗
is the left child of its
i is the right child of its parent. Since
i , i ∈ [a − 1], are the alleged nodes on
i are their alleged

is valid with respect to (cid:104)T (cid:105)∗. Let h∗
nodes on π∗ Let ˜h∗
recursively as follows: ˜h∗
i+1 := H(h∗
parent, and, ˜h∗
i+1 := H(˜h∗
i (cid:107) h∗
i ) if h∗
a = (cid:104)T (cid:105)∗ (The nodes ˜h∗
π∗ is valid, ˜h∗
the path connecting D∗[j − 1] to the root (cid:104)T (cid:105)∗, and h∗
siblings).

2, . . . , h∗

i ) if h∗
i

Let hi, i ∈ [a − 1], denote the inner nodes in the challenger’s dirty
i . Let ˜hi, i ∈ [a − 1], denote the inner
tree with the same positions as h∗
nodes in the challenger’s dirty tree on the path from D[j − 1] to (cid:104)T (cid:105).
These inner nodes satisfy the following relations for i ∈ [a − 1]: ˜ha = (cid:104)T (cid:105),
˜h1 := H(D[j − 1]), ˜hi+1 = H(hi (cid:107) ˜hi) if hi is the left child of its parent,
and, ˜hi+1 = H(˜hi (cid:107) hi) if hi is the right child of its parent.

Consider the event Discrepancy that ˜h∗
q
q = h∗

(cid:54)= h∗
last and the event
Invalid-Proof that ˜h∗
last ∧ D[j−1] (cid:54)= D∗[j−1]. Since Pr[D[j−1] (cid:54)=
D∗[j − 1] | Bad] ≤ Pr[Discrepancy] + Pr[Invalid-Proof] we next
bound the probabilities of these events.

We ﬁrst construct a hash collision adversary A1 that calls the re-
sponder as a subroutine, and show that the event Discrepancy im-
a,c := (cid:104)T (cid:105)∗
plies that A1 succeeds. For i ∈ {q, . . . , a}, deﬁne h∗
a,m := (cid:104)T (cid:105)∗,
and h∗
i (cid:107) ˜h∗
i,m := ˜h∗
h∗
i if
hi is the left child of its parent.

i,r if i < h. Similarly, deﬁne h∗
i,l (cid:107) h∗
i if hi is the right child of its parent, and h∗

i,c as: h∗
i,m as: h∗

i,c := h∗
i (cid:107) h∗

i,m := h∗

i,c and h∗

The adversary A1 calls the responder as a sub-routine, and obtains
i,m, i ∈ {q, . . . , h}. It ﬁnds the ﬁrst index p for
p,c) and h∗
p,c and returns
p,c, if such an index p exists. Otherwise, it returns

the values h∗
which there is a collision H(h∗
a := h∗
p,m and b := h∗
Failure.

p,m) = H(h∗

p,m (cid:54)= h∗

In the case of Discrepancy, ˜h∗

q,l. Hence, it must be the
case that h∗
a,c, a collision must
have been found for at least one index i ∈ {q, . . . , a − 1}. Consequently,
Discrepancy implies that A1 succeeds.

q,c. However, since h∗

a,m = (cid:104)T (cid:105)∗ = h∗

last = h∗

q,m (cid:54)= h∗

q (cid:54)= h∗

We next construct a Merkle tree adversary A2 that calls the responder
as a subroutine, and show that the event Invalid-Proof implies that
A2 succeeds.

45

1, . . . , h∗

Let P denote the sequence of leaves in the challenger’s dirty tree,
i.e., within D, that lie under the subtree with root hq,l. Let π denote
the sub-sequence h∗
q−1 within π∗. The adversary A2 receives P
from the responder, and constructs a well-formed dirty tree using P in
time O(poly((cid:96))). It then obtains the leaf v := D∗[j − 1] and the Merkle
proof π = (h∗
q−1) from the responder. Finally, it returns v, P , π
and the index idx of the leaf D[j − 1] within the sequence P such that
P [idx] = D[j − 1].

1, . . . , h∗

If Invalid-Proof, it must be the case that ˜h∗

last = hq,l and
D[j−1] (cid:54)= D∗[j−1] = v. Hence, π is a valid Merkle proof for v with respect
to the root hq,l of the Merkle tree with leaves P . Moreover, v (cid:54)= P [idx].
Consequently, Invalid-Proof implies than A2 succeeds.

q = h∗

Finally, by the fact that H is a collision-resistant hash function and

Lemma 1,

Pr[D[j − 1] (cid:54)= D∗[j − 1] | Bad] ≤
Pr[Discrepancy] + Pr[Invalid-Proof] ≤
Pr[A1 succeeds] + Pr[A2 succeeds] ≤ negl(λ) .

Hence, for any PPT adversarial responder, the probability that the re-
sponder wins and (D∗[j − 1] (cid:54)= D[j − 1]) ∨ (D∗[j] = D[j]) is negligible in
λ.

The next lemma ensures that an honest challenger can win in the
bisection game by leveraging sound consensus and execution oracles to
resolve any disagreements at the leaf level.

Lemma 5 (Bisection Soundness). Let H s be a collision resistant
hash function. Consider an execution that satisﬁes ledger safety and in
which the consensus and execution oracles are sound. Then, for all PPT
adversarial responders A claiming root (cid:104)T (cid:105)∗ and size (cid:96), the honest chal-
lenger claiming (cid:104)T (cid:105) (cid:54)= (cid:104)T (cid:105)∗ and (cid:96) wins the bisection game against A with
overwhelming probability in λ.

Proof. Consider an adversarial PPT responder P ∗ playing against the
honest challenger P at some round r. Since the challenger is honest, his
queries are valid and he does not time out. For the responder to win the
bisection game, it must satisfy all the conditions checked by Algorithm 2.
Let (tx∗
j ) denote the two entries revealed by P ∗
for the consecutive indices j − 1 and j in the event that it wins.

j−1) and (tx∗

j−1, (cid:104)st(cid:105)∗

j , (cid:104)st(cid:105)∗

46

j−1, tx∗

j−1, (cid:104)st(cid:105)∗

Deﬁne Consensus-Oracle as the event that the responder wins
j−1) ∧ tx∗
and (txj−1, (cid:104)st(cid:105)j−1) = (tx∗
j (cid:54)= txj. We construct a con-
sensus oracle adversary A1 that calls P ∗ as a subroutine and outputs
(tx∗
j , r). By the well-formedness of the challenger’s dirty ledger and
r (cid:22) L∪
r (cid:22) L∪
ledger safety, it holds that (txj−1, txj) | LP
r+ν. Therefore, if
Consensus-Oracle, it must be the case that tx∗
j (cid:54)= txj does not immedi-
ately follow tx∗
r+ν is unique.
However, as the responder wins, the consensus oracle must have outputted
j , r) by condition (5). Hence, Consensus-Oracle im-
true on (tx∗
plies that A1 succeeds.

r+ν as every transaction on L∪

j−1 = txj−1 on L∪

j−1, tx∗

j−1, (cid:104)st(cid:105)∗

j−1) ∧ tx∗

j = txj ∧ (cid:104)st(cid:105)∗

Deﬁne Execution-Oracle as the event that the responder wins and
(txj−1, (cid:104)st(cid:105)j−1) = (tx∗
j (cid:54)= (cid:104)st(cid:105)j. By the well-
formedness of the challenger’s dirty tree, there exist a state stj−1 such that
(cid:104)st(cid:105)j−1 = (cid:104)stj−1(cid:105), stj−1 = δ∗(st0, L[:j − 1]), and, (cid:104)st(cid:105)j = (cid:104)δ(stj−1, txj)(cid:105).
Therefore, if Execution-Oracle, it holds that (cid:104)st(cid:105)j−1 = (cid:104)st(cid:105)∗
j−1, and
(cid:104)δ(stj−1, txj)(cid:105) = (cid:104)st(cid:105)j (cid:54)= (cid:104)st(cid:105)∗
j . However, as the responder wins, the exe-
j , (cid:104)st(cid:105)∗
cution oracle must have outputted true on tx∗
j by con-
dition (6). Thus, the responder must have given a proof π such that
(cid:104)δ(cid:105) ((cid:104)st(cid:105)∗
j−1 , tx∗
(cid:54)=
(cid:104)δ(stj−1, txj)(cid:105).

j . This implies (cid:104)δ(cid:105) ((cid:104)st(cid:105)j−1 , txj, π) = (cid:104)st(cid:105)∗

j−1 and (cid:104)st(cid:105)∗

j , π) = (cid:104)st(cid:105)∗

j

Finally, we construct an execution oracle adversary A2 that calls
P ∗ as a subroutine and receives π. Then, using L, A2 ﬁnds stj−1 =
δ∗(st0, L[:j − 1]) in O(poly((cid:96))) time. It outputs (stj−1, txj, π). Observe
that if Execution-Oracle, then A2 succeeds.
Note that the event (txj−1, (cid:104)st(cid:105)j−1) = (tx∗
j , (cid:104)st(cid:105)∗

j ) ∧ Responder wins is the union of the events Consensus-Oracle

j−1) ∧ (txj, (cid:104)st(cid:105)j) (cid:54)=

j−1, (cid:104)st(cid:105)∗

(tx∗
and Execution-Oracle:

Pr[(txj−1, (cid:104)st(cid:105)j−1) = (tx∗
j , (cid:104)st(cid:105)∗
(txj, (cid:104)st(cid:105)j) (cid:54)= (tx∗

j−1)∧

j−1, (cid:104)st(cid:105)∗
j ) ∧ Responder wins] =

Pr[Consensus-Oracle ∨ Execution-Oracle] ≤
Pr[A1 succeeds] + Pr[A2 succeeds] ≤ negl(λ) .

Moreover, by Lemma 4;

Pr[((txj−1, (cid:104)st(cid:105)j−1) (cid:54)= (tx∗
j , (cid:104)st(cid:105)∗
(txj, (cid:104)st(cid:105)j) = (tx∗

j−1) ∨

j−1, (cid:104)st(cid:105)∗
j )) ∧ Responder wins] ≤ negl(λ) .

Consequenty, Pr[Responder wins] = negl(λ).

47

Lemma 1 (Succinctness). Consider a consensus and execution oracle
with f and g communication complexity respectively. Then, the challenge
game invoked at round r with sizes (cid:96)1 and (cid:96)2 > (cid:96)1 ends in log((cid:96)1+α(u+ν))
rounds of communication and has a total communication complexity of
O(log((cid:96)1)) + α(u + ν)(f (r) + g(r))).

Proof. Suppose the challenge game was invoked on augmented dirty ledgers
with (alleged) sizes (cid:96)1 and (cid:96)2 > (cid:96)1 respectively. The zooming phase of the
challenge game does not require any communication among the provers
and the veriﬁer.

Suppose that at the end of the zooming phase, the provers play a
bisection game on two Merkle trees with (cid:96) ≤ (cid:96)1 leaves. By Lemma 2,
the bisection game ends in Θ(log (cid:96)) = Θ(log (cid:96)1) rounds and has a total
communication complexity of O(log (cid:96) + f (r) + g(r)) = O(log (cid:96)1 + f (r) +
g(r)).

Suppose that the challenge game reaches the suﬃx monologue. Since
the veriﬁer checks for at most α(u + ν) extra entries, (txj, (cid:104)st(cid:105)j), j ∈
{(cid:96)1, . . . , min((cid:96)2, (cid:96)1 + α(u + ν))}, at most α(u + ν) entries are sent to
the veriﬁer by the challenger. These entries have constant sizes since the
transactions and the state commitments are assumed to have constant
sizes. Finally, the veriﬁer can query the consensus oracle on the α(u + ν)
transaction pairs (txj−1, txj), j ∈ {(cid:96)1 + 1, min((cid:96)2, (cid:96)1 + α(u + ν))}, and the
execution oracle on the α(u + ν) triplets ((cid:104)st(cid:105)j−1 , txj, (cid:104)st(cid:105)j), j ∈ {(cid:96)1 +
1, min((cid:96)2, (cid:96)1 + α(u + ν))}, with O(α(u + ν)f (r)) and O(α(u + ν)g(r))
communication complexity respectively. Hence, the total communication
complexity of the challenge game becomes O(log (cid:96)1 + α(u + ν)(f (r) +
g(r))).

By the Lipschitz property of the ledger, |L∪

r | < αr, and α, ν, u are
constants. Superlight client constructions [32,10] place f in O(poly log r),
and g is in O(poly log r) if standard Merkle constructions [2] are used and
the transition function δ ensures the state grows at most linearly, as is the
case in all practical constructions. In light of these quantities, the result
of the above theorem establishes that our protocol is also O(poly log r)
and, hence, succinct.

Theorem 1 (Completeness). Suppose the consensus and execution or-
acles are complete and the ledger is safe. Then, the honest responder wins
the challenge game against any PPT adversarial challenger.

Proof. Suppose that at the end of the zooming phase, the challenger
invoked the bisection game between one of the honest responder’s peaks,

48

(cid:104)T (cid:105)i, and a node (cid:104)T (cid:105)∗ alleged to have the same position as (cid:104)T (cid:105)i within the
challenger’s MMR. By Lemma 3, the honest responder wins the bisection
game. If the challenger starts a suﬃx monologue instead of the bisection
game at the end of the zooming phase, the responder automatically wins
the challenge game. Hence, the responder wins the challenge game.

Proposition 2. For any honest prover P and round r, |L∪

r | < |LP

r |+αu.

r | ≥ |LP

r | ≥ |LP
Proof. Towards contradiction, suppose |L∪
r |+αu. By ledger safety,
there exists an honest prover P (cid:48) such that LP (cid:48)
r = L∪
r , which implies
r (cid:22) LP (cid:48)
|LP (cid:48)
r | + αu. Again by ledger safety, LP
r . By ledger live-
ness, every transaction that is in LP (cid:48)
and not in LP
r becomes part of
r
r+u, for which LP
LP
r (cid:22)
LP
r+u and, |LP
r | + αu. However, this is a violation of
the ledger Lipschitz property. Consequently, it should be the case that
|L∪

r+u holds by ledger safety. Hence, LP
r | ≥ |LP

r (cid:22) LP
r+u| ≥ |LP (cid:48)

r (cid:22) LP (cid:48)

r | < |LP

r | + αu.

Lemma 6 (Monologue Succinctness). Consider an execution of a
consensus protocol which is Lipschitz with parameter α and has live-
ness with parameter u. Consider the challenge game instantiated with
a collision-resistant hash function H s and a consensus oracle which is
sound with parameter ν. For all PPT adversarial challengers A, if the
game administered by the honest veriﬁer among A and the honest re-
sponder P at round r reaches the suﬃx monologue, the adversary cannot
reveal α(u + ν) or more entries and win the game except with negligible
probability.

Proof. Suppose the game between the challenger A and the honest re-
sponder P reaches the suﬃx monologue. Consider the event Bad that
the challenger reveals β ≥ α(u + ν) entries and wins the game. Let
D = ((tx1, (cid:104)st(cid:105)1), (tx2, (cid:104)st(cid:105)2), . . . , (txβ, (cid:104)st(cid:105)β)) denote these entries, and
(tx0, (cid:104)st(cid:105)0) the responder’s last entry prior to the monologue phase. Be-
cause P is in agreement with tx0, therefore tx0 = LP
r [−1]. Let J =
(tx0, tx1, . . . , txβ). Since the challenger wins, the veriﬁer has invoked the
consensus oracle α(u + ν) times for all consecutive pairs of transactions
within K = J[:α(u + ν)]. At each invocation, the consensus oracle has
returned true.

We next construct a consensus oracle adversary A(cid:48) that calls A as a
subroutine. If β ≥ α(u + ν), A(cid:48) identiﬁes the ﬁrst index p ∈ [α(u + ν)]
such that txp does not immediately follow txp−1 on L∪
r+ν, and outputs
(txp−1, txp, r). If β < α(u + ν), A(cid:48) outputs Failure.

49

By the ledger Lipschitz property, |LP
r+ν| < |LP
r+ν| + αu. Thus, |L∪
r |. By ledger safety, tx0 = LP
r+ν, tx1 = L∪

Lemma 2, |L∪
Let (cid:96) = |LP
r+ν[(cid:96) − 1]. Hence,
if (tx0, tx1) | L∪
r+ν is unique.
By induction, either there exists an index i ∈ [β] such that txi does not
immediately follow txi−1 on L∪
r+ν[(cid:96)+i−1]
for all i ∈ [β].

r+ν| < |LP
r+ν| < |LP
r [(cid:96) − 1] = L∪

r | + αν. Moreover, by
r | + α(u + ν).

r+ν[(cid:96)] as every transaction on L∪

r+ν| ≥ (cid:96)+β and txi = L∪

r+ν, or |L∪

Finally, if β ≥ α(u + ν), there exists an index i ∈ [α(u + ν)] such
that txi does not immediately follow txi−1 on L∪
r+ν. Thus, Pr[Bad] =
Pr[A(cid:48)succeeds]. However, by the soundness of the consensus oracle, ∀
PPT A(cid:48), Pr[A(cid:48)succeeds] = negl(λ). Therefore, Pr[Bad] = negl(λ).

Theorem 2 (Soundness). Let H s be a collision resistant hash function.
Suppose the consensus and execution oracles are complete and sound.
Then, for all PPT adversarial responders A, an honest challenger wins
the challenge game against A with overwhelming probability in λ.

Proof. Suppose that at the end of the zooming phase, the honest chal-
lenger P identiﬁed one of the responder P ∗’s peaks, (cid:104)T (cid:105)∗
i , as being dif-
ferent from a node (cid:104)T (cid:105) within the challenger’s MMR that has the same
position as (cid:104)T (cid:105)∗
i . In this case, the challenger initiates a bisection game
between (cid:104)T (cid:105)∗
i and (cid:104)T (cid:105). By Lemma 5, the honest challenger wins the bi-
section game with overwhelming probability.

Suppose the challenger observes that the peaks shared by the respon-
der correspond to the peaks of a well-formed MMR. Then, at the end
of the zooming phase, the honest challenger starts the suﬃx monologue.
Let (cid:96) and (cid:96)∗ denote the challenger’s and the responder’s (alleged) aug-
mented dirty ledger sizes respectively. Let r denote the round at which
the challenge game was started. During the suﬃx monologue, the chal-
lenger reveals its augmented dirty ledger entries (txj, (cid:104)st(cid:105)j) at the indices
(cid:96)∗, . . . , min ((cid:96), (cid:96)∗ + α(u + ν)) − 1. Then, for all j ∈ {(cid:96)∗ + 1, (cid:96)∗ + 2, . . . ,
min ((cid:96), (cid:96)∗ + α(u + ν)) − 1}, the veriﬁer checks the transactions and the
state transitions between (txj−1, (cid:104)st(cid:105)j−1) and (txj, (cid:104)st(cid:105)j). The veriﬁer does
the same check between the responder’s last (alleged) augmented dirty
ledger entry (tx∗
(cid:96)∗−1) and (tx(cid:96)∗, (cid:104)st(cid:105)(cid:96)∗).

(cid:96)∗−1, (cid:104)st(cid:105)∗
Consider the event Equal that (tx∗

(cid:96)∗−1) = (tx(cid:96)∗−1, (cid:104)st(cid:105)(cid:96)∗−1).
By the well-formedness of the challenger’s augmented dirty ledger, for any
pair of leaves at indices j − 1 and j, j ∈ {(cid:96)∗, . . . , min ((cid:96), (cid:96)∗ + α(u + ν)) −
1}, it holds that (txj−1, txj) | LP
r by ledger safety. As
the consensus oracle is complete, by Deﬁnition 5, it returns true on
all (txj−1, txj), j ∈ {(cid:96)∗, . . . , min ((cid:96), (cid:96)∗α(u + ν)) − 1}. Similarly, by the

r , thus, on L∪

(cid:96)∗−1, (cid:104)st(cid:105)∗

50

well-formedness of the challenger’s augmented dirty ledger, for any pair
of leaves at indices j − 1 and j, j ∈ {(cid:96)∗, . . . , min ((cid:96), (cid:96)∗ + α(u + ν)) −
1}, there exists a state stj−1 such that (cid:104)st(cid:105)j−1 = (cid:104)stj−1(cid:105), and, (cid:104)st(cid:105)j =
(cid:104)δ(stj−1, txj)(cid:105). As the execution oracle is complete, by Deﬁnition 7, for all
j ∈ {(cid:96)∗, . . . , min ((cid:96), (cid:96)∗ + α(u + ν)) − 1}, M (stj−1, txj) outputs a proof πj
such that (cid:104)δ(cid:105) ((cid:104)stj−1(cid:105) , txj, πj) = (cid:104)δ(stj−1, txj)(cid:105). Thus, for all j ∈ {(cid:96)∗, . . . ,
min ((cid:96), (cid:96)∗ + α(u + ν)) − 1}, the veriﬁer obtains a proof πj such that
(cid:104)δ(cid:105) ((cid:104)st(cid:105)j−1 , txj, πj) = (cid:104)st(cid:105)j. In other words, if the challenge protocol
reaches the suﬃx monologue and Equal, the honest challenger wins the
suﬃx monologue.

(cid:96)∗−1, (cid:104)st(cid:105)∗

Finally, consider the Merkle tree adversary A(cid:48) that calls the responder
P ∗ as a subroutine. Let π∗ denote the Merkle proof revealed by the re-
(cid:96)∗−1) with respect to its last (alleged) peak (cid:104)T (cid:105)∗.
sponder for (tx∗
Let (cid:104)T (cid:105) denote the corresponding node in the challenger’s MMR. Let D
denote the sequence of augmented dirty ledger entries held by the honest
challenger in the subtree rooted at (cid:104)T (cid:105). Let idx := |D| denote the size
of this subtree. If the game reaches the suﬃx monologue and ¬Equal,
A(cid:48) returns v := (tx∗
(cid:96)∗−1), D, π and idx. Otherwise, it returns
Failure.

(cid:96)∗−1, (cid:104)st(cid:105)∗

If the game reaches the suﬃx monologue, (cid:104)T (cid:105)∗ = (cid:104)T (cid:105), and π is valid
(cid:96)∗−1, (cid:104)st(cid:105)∗
with respect to (cid:104)T (cid:105). Then, if (tx∗
(cid:96)∗−1) (cid:54)= (tx(cid:96)∗−1, (cid:104)st(cid:105)(cid:96)∗−1), there-
fore (cid:104)T (cid:105) = MakeMT(D).root, D[idx] (cid:54)= v, and Verify(π, (cid:104)T (cid:105) , idx, v) =
1. Conditioned on the fact that the challenge game reaches the suﬃx
monologue, by Proposition 1, Pr[¬Equal] = Pr[A(cid:48) succeeds] = negl(λ).
Thus, the honest challenger wins the challenge protocol with overwhelm-
ing probability.

Theorem 5 (Tournament Runtime). Suppose the consensus and ex-
ecution oracles are complete and sound, and have f and g communication
complexity respectively. Consider a tournament started at round r with n
provers. Given at least one honest prover, for any PPT adversary A,
the tournament ends in 2n log(|L∪
r | + α(u + ν)) rounds of communication
and has a total communication complexity of O(2n log(|L∪
r | + α(u + ν)) +
2nα(u + ν)(f (r) + g(r))), with overwhelming probability in λ.

Proof. By the end of the ﬁrst step, size of the set S can be at most 2.
Afterwards, each step of the tournament adds at most one prover to S
and the number of steps is n − 1. Moreover, at each step, either there
is exactly one challenge game played, or if k > 1 games are played, at
least k − 1 provers are removed from S. Hence, the maximum number

51

of challenge games that can be played over the tournament is at most
2n − 1.

Recall that the size alleged by Pi is at most the size alleged by Pi+1,
i ∈ [n − 1]. Let i∗ be the ﬁrst round where an honest prover plays the
challenge game. If i∗ > 1, until round i∗, the sizes alleged by the provers
are upper bounded by |L∪
r |. From round i∗ onward, at each round, the
prover P claiming the largest size is either honest or must have at least
once won the challenge game as a challenger against an honest responder.
During the game against the honest responder, by Lemma 6, P could not
have revealed α(u + ν) or more entries except with negligible probability.
Hence, from round i∗ onward, with overwhelming probability, the size
claimed by P at any round can at most be |L∪
r | + α(u + ν) − 1. Thus,
with overwhelming probability, by Theorem 1, each challenge game ends
after at most log(|L∪
r | + α(u + ν)) rounds of interactivity and has total
communication complexity O(log(|L∪
r |+α(u+ν))+α(u+ν)(f (r)+g(r))).
Consequently, with overwhelming probability, the tournament started at
round r with n provers ends in at most 2n log(|L∪
r | + α(u + ν)) rounds
of interactivity and has total communication complexity O(2n log(|L∪
r | +
α(u + ν)) + 2nα(u + ν)(f (r) + g(r))).

Lemma 7. Consider a challenge game invoked by the veriﬁer at some
round r. If at least one of the provers P is honest, for all PPT adversarial
A, the state commitment obtained by the veriﬁer at the end of the game
between P and A satisﬁes state security with overwhelming probability.

Proof. If the challenger is honest, by Theorem 2, he wins the challenge
game with overwhelming probability and the veriﬁer accepts his state
commitment.

Suppose the responder P of the challenge game is honest, and it is
challenged by a challenger P ∗. If P ∗ starts a bisection game, by Lemma 3,
P ∗ loses the challenge game and P wins the game. In this case, the veri-
ﬁer accepts the state commitment given by the honest responder. On the
other hand, if the challenge game reaches the suﬃx monologue and the
challenger loses the monologue, the veriﬁer again accepts the state com-
mitment given by the honest responder. As the state commitment of an
honest prover satisﬁes security as given by Deﬁnition 9, in all of the cases
above, the commitment accepted by the veriﬁer satisﬁes state security
with overwhelming probability.

Finally, consider the event Win that the game reaches the suﬃx
monologue and the challenger wins. Let (cid:96) and (cid:96)∗ denote the respon-
der’s and the challenger’s (alleged) augmented dirty ledger lengths re-

52

i , (cid:104)st(cid:105)∗

spectively. During the suﬃx monologue, the challenger reveals its al-
i ) at indices i = (cid:96) + 1, . . . , min ((cid:96)∗, (cid:96) + α(u + ν)) −
leged entries (tx∗
1. Let (tx(cid:96)−1, (cid:104)st(cid:105)(cid:96)−1) denote the responder’s last entry. As the chal-
lenger wins, consensus oracle must have returned true on (tx(cid:96)−1, tx∗
(cid:96) )
and (tx∗
i ) for all i ∈ {(cid:96) + 1, . . . , min ((cid:96)∗, (cid:96) + α(u + ν)) − 1}. Sim-
ilarly, for all i ∈ {(cid:96), . . . , min ((cid:96)∗, (cid:96) + α(u + ν))}, execution oracle must
have outputted a proof πi−(cid:96)+1 such that (cid:104)δ(cid:105) ((cid:104)st(cid:105)(cid:96)−1 , tx∗
(cid:96) and
(cid:104)δ(cid:105) ((cid:104)st(cid:105)∗
i for i ∈ {(cid:96) + 1, . . . , min ((cid:96)∗, (cid:96) + α(u + ν)) −
1}

i , πi−(cid:96)+1) = (cid:104)st(cid:105)∗

(cid:96) , π1) = (cid:104)st(cid:105)∗

i−1 , tx∗

i−1, tx∗

(cid:96) , . . . , tx∗

Let D denote the sequence tx(cid:96)−1, tx∗

min ((cid:96)∗,(cid:96)+α(u+ν))−1 of trans-
actions. Consider the event Consensus-Oracle that Win holds, (cid:96)∗ <
(cid:96) + α(u + ν), and there exists an index i ∈ {1, . . . , (cid:96)∗ − (cid:96)} such that D[i]
does not immediately follow D[i−1] on L∪
r+ν. We next construct a consen-
sus oracle adversary A1 that calls P ∗ as a subroutine. The adversary A1
identiﬁes the ﬁrst index p > 0 such that D[p] does not immediately follow
D[p − 1] on L∪
r+ν if such an index exists, and outputs (D[p − 1], D[p], r).
Otherwise, A1 outputs Failure. Hence, Consensus-Oracle implies
that A1 succeeds.

r ||(tx∗

(cid:96) , . . . , tx∗

Let S denote the sequence of state commitments (cid:104)st(cid:105)(cid:96)−1 , (cid:104)st(cid:105)∗
min ((cid:96)∗,(cid:96)+α(u+ν))−1. Deﬁne sti = δ∗(st0, LP

(cid:96) , . . . ,
(cid:104)st(cid:105)∗
(cid:96)+i−1)) for i ∈
{1, . . . , (cid:96)∗−(cid:96)} (st0 = δ∗(st0, LP
r )). Consider the event Execution-Oracle
that Win holds, (cid:96)∗ < (cid:96) + α(u + ν), ¬Consensus-Oracle holds, and
S[i] (cid:54)= (cid:104)sti(cid:105) for at least one index i ∈ {1, . . . , (cid:96)∗ − (cid:96)}. We next con-
struct an execution oracle adversary A2 that calls P ∗ as a subroutine.
Using LP
r |)
time. Then, A2 identiﬁes the ﬁrst index p > 0 such that S[p] (cid:54)= (cid:104)stp(cid:105)
if such an index exists, and outputs st = stp−1, tx = D[p] = tx∗
(cid:96)+p−1, and
π = πp. Otherwise, A2 outputs Failure. Since (cid:104)δ(cid:105) (S[i−1], D[i], πi) = S[i]
for i ∈ {0, 1, . . . , min ((cid:96)∗ − (cid:96), α(u + ν)) − 1}, Execution-Oracle im-
plies that (cid:104)δ(stp−1, D[p])(cid:105) = (cid:104)stp(cid:105) (cid:54)= S[p] = (cid:104)δ(cid:105) (S[p − 1], D[p], πp) =
(cid:104)δ(cid:105) ((cid:104)stp−1(cid:105) , D[p], πp). Hence, Execution-Oracle implies that A2 suc-
ceeds.

r , A2 ﬁnds sti for all i ∈ {0, 1, . . . , (cid:96)∗ − (cid:96)} in O(poly(|LP

Finally, if Win ∧ ¬Consensus-Oracle ∧ ¬Execution-Oracle ∧
(cid:96)∗−1, which
(cid:96)∗−1) (cid:22)

(cid:96)∗ < (cid:96) + α(u + ν), the veriﬁer accepts the commitment (cid:104)st(cid:105)∗
satisﬁes state security by Deﬁnition 9 (Here, L = LP
r+ν and (cid:104)st(cid:105)∗
L∪

(cid:96)∗−1 = (cid:104)δ∗(st0, L)(cid:105) = (cid:104)st(cid:105)). However,

(cid:96) , . . . , tx∗

r (cid:107) (tx∗

Pr[Consensus-Oracle ∨ Execution-Oracle] ≤
Pr[A1 succeeds] + Pr[A2 succeeds] ≤ negl(λ) .

53

Moreover, by Lemma 6, P ∗ cannot reveal α(u + ν) or more entries and
win the game except with negligible probability. Hence,

Pr[Win] =negl(λ) + Pr[Win ∧ ¬Consensus-Oracle

∧ ¬Execution-Oracle ∧ (cid:96)∗ < (cid:96) + α(u + ν)] .

which implies that either Pr[Win] = negl(λ) or conditioned on Win, the
commitment accepted by the veriﬁer satisﬁes state security except with
negligible probability. Consequently, in a challenge game invoked by the
veriﬁer at some round r, if at least one of the provers is honest, the state
commitment obtained by the veriﬁer satisﬁes state security except with
negligible probability.

Theorem 6 (Security). Suppose the consensus and execution oracles
are complete and sound, and have f and g communication complexity
respectively. Consider a tournament started at round r with n provers.
Given at least one honest prover, for any PPT adversary A, the state
commitment obtained by the prover at the end of the tournament satisﬁes
State Security with overwhelming probability in λ.

Proof. Let Pi∗ denote an honest prover within P. Let n = |P| − 1 de-
note the total number of rounds. By Theorems 1 and 2, Pi∗ wins every
challenge game and stays in S after step i∗ with overwhelming probability.
The prover P with the largest alleged MMR at the end of each step
i ≥ i∗ is either Pi∗ or has a larger (alleged) MMR than the one held by
Pi∗. In the ﬁrst case, as Pi∗ is honest, its state commitment satisﬁes safety
and liveness per Deﬁnition 9. In the latter case, P must have played the
challenge game with Pi∗. Then, by Lemma 7, the state commitment of P
satisﬁes safety and liveness per Deﬁnition 9 with overwhelming probabil-
ity. Consequently, the state commitment obtained by the veriﬁer at the
end of the tournament, i.e., the commitment of P at the end of round
n ≥ i∗, satisﬁes safety and liveness with overwhelming probability.

B Consensus Oracle Constructions

Consensus oracle constructions for Celestia (LazyLedger) [1], Prism [3,4],
and Snap-and-Chat [40,39] follow the same paradigm described in Sec-
tion 5.2.

54

B.1 Celestia

Celestia uses Tendermint [9] as its consensus protocol, which outputs a
chain of blocks containing transactions. Blocks organize the transactions
as namespaced Merkle trees, and the root of the tree is included within
the block header. Hence, the construction of Section 5.2 can be used to
provide a consensus oracle for Celestia.

B.2 Prism

In Prism, a transaction tx is ﬁrst included within a transaction block. This
block is, in turn, referred by a proposer block. Once the proposer block
is conﬁrmed in the view of a prover P at round r, tx enters the ledger
LP
r . Hence, the proof of inclusion for tx consists of two proofs: one for the
inclusion of tx in a transaction block BT , the other for the inclusion of
the header of BT in a proposer block BP . If transactions and transaction
blocks are organized as Merkle trees, then, the proof of inclusion for tx
would be two Merkle proofs: one from tx to the Merkle root in the header
of BT , the other from the header of BT to the Merkle root in the header
of BP .

The construction of Section 5.2 can be generalized to provide a con-
sensus oracle for Prism. In this case, to query the consensus oracle with
two transactions tx and tx(cid:48) (cid:54)= tx, the veriﬁer ﬁrst downloads all the pro-
posal block headers from the honest provers and determines the longest
stable header chain. Then, it asks a prover if tx immediately precedes tx(cid:48)
on its dirty ledger.

To aﬃrm, the prover replies with:

– the positions it and i(cid:48)

t of the transactions tx and tx(cid:48) within their re-
spective Merkle trees contained in the respective transaction blocks
BT and B(cid:48)
T .

– the Merkle proofs πt and π(cid:48)

t from the transactions tx and tx(cid:48) to the

corresponding Merkle roots within the headers of BT and B(cid:48)
T ,

– the positions ip and i(cid:48)

p of the headers of the transaction blocks BT and
T within their respective Merkle trees contained in the respective

B(cid:48)
proposal blocks BP and B(cid:48)
P .
p from the headers of BT and B(cid:48)
– the Merkle proofs πp and π(cid:48)
T to the
corresponding Merkle roots within the headers of BP and B(cid:48)
P ,

– the positions j ≤ j(cid:48) of the headers of BP and B(cid:48)

P on the longest stable

header chain.

Then, the veriﬁer checks that the Merkle proofs are valid, and accepts
the prover’s claim if and only if either of the following cases hold:

55

1. if j = j(cid:48) and i(cid:48)
2. if j = j(cid:48) and i(cid:48)
of BT while i(cid:48)

t = it + 1.

p = ip, then i(cid:48)
p = ip + 1, then it is the index of the last leaf in the tree
t is the index of the ﬁrst leaf in the tree of B(cid:48)
T .

3. if j(cid:48) > j, then ip is the index of the last leaf in the tree of BP while
P . Similarly, it is the
t is the index of the ﬁrst

p is the index of the ﬁrst leaf in the tree of B(cid:48)
i(cid:48)
index of the last leaf in the tree of BT while i(cid:48)
leaf in the tree of B(cid:48)

T .

If no prover is able to provide such a proof, the oracle returns false to the
veriﬁer.

B.3 Snap-and-Chat

In Snap-and-Chat protocols, a transaction tx is ﬁrst included within a
block BT proposed in the context of a longest chain protocol. Upon be-
coming k-deep within the longest chain, where k is a predetermined pa-
rameter, BT is, in turn, included within a block BP proposed as part of a
partially-synchronous BFT protocol. Once BP is ﬁnalized in the view of
a prover P at round r, tx enters the ﬁnalized ledger LP
r . There are again
two Merkle proofs for veriﬁable inclusion, one from tx to the Merkle root
included in BT , the other from the header of BT to the Merkle root in the
header of BP . Consequently, the consensus oracle construction for Prism
also applies to Snap-and-Chat protocols.

Remark 1. We remark here that protocols that do not follow the longest
chain rule, or are not even proper chains, can be utilized by our pro-
tocol. Such examples include Parallel Chains [22], PHANTOM [43] /
GHOSTDAG [44], and SPECTRE [42]. The only requirement is that
these systems provide a succinct means of determining whether two trans-
actions follow one another on the ledger.

B.4 Longest Chain

As an illustration of how the consensus oracle can be realized in a longest
header chain protocol, we provide sketches for the proofs of consensus
oracle completeness and soundness in the Nakamoto setting.

Even in the original Nakamoto paper [38], a description of an SPV
client is provided, and it realizes our consensus oracle axioms, although
these virtues were not stated or proven formally. The consensus oracle
works as follows. The veriﬁer connects to multiple provers, at least one
of which is assumed to be honest. It inquires of the provers their longest

56

chains, downloads them, veriﬁes that they are chains and that they have
valid proof-of-work, and keeps the heaviest chain. It then chops oﬀ k
blocks from the end to arrive at the stable part. Upon being queried on
two transactions (tx, tx(cid:48)), the oracle inquires of its provers whether these
transactions follow one another on the chain. To prove that they do, the
honest prover reveals two Merkle proofs of inclusion for tx and tx(cid:48). These
must appear in either consecutive positions within the same block header,
or at the last and ﬁrst position in consecutive blocks.

The terminology of typical executions, the Common Preﬁx parame-
ter k, and the Chain Growth parameter τ are borrowed from the Bit-
coin Backbone [23] line of works, where these properties are proven. We
leverage these properties to show that our Consensus Oracle satisﬁes our
desired axioms. Our proofs are in the static synchronous setting, but gen-
eralize to the ∆-bounded delay and variable diﬃculty settings.

Lemma 8 (Nakamoto Completeness). In typical executions where
honest majority is observed, the Nakamoto Consensus Oracle is complete.

Sketch. We prove that, if (tx, tx(cid:48)) are reported in L∪, then an honest
prover will be able to prove so. Suppose the veriﬁer chose a longest header
chain CV . If (tx, tx(cid:48)) appear consecutively in L∪, by ledger safety, this
means that they belong to the ledger of at least one honest party P who
is acting as a prover. Since (tx, tx(cid:48)) appear consecutively in LP , therefore
they appear in the stable portion CP [: − k] of the chain CP held by P .
By the Common Preﬁx property, CP [: − k] is a preﬁx of CV and therefore
(tx, tx(cid:48)) appear consecutively in the stable header chain adopted by the
veriﬁer. Therefore, the veriﬁer accepts.

Lemma 9 (Nakamoto Soundness). In typical executions where honest
majority is observed, the Nakamoto Consensus Oracle instantiated with
a Merkle Tree that uses a collision resistant hash function is sound, with
soundness parameter ν = k
τ where k is the Common Preﬁx parameter and
τ is the Chain Growth parameter.

Sketch. Suppose for contradiction that (tx, tx(cid:48)) are not reported in L∪
r+ν,
yet the adversary convinces the veriﬁer of this at round r. This means
that the adversary has presented some header chain CV to the veriﬁer
which was deemed to be the longest at the time, and (tx, tx(cid:48)) appear in
its stable portion CV [: − k]. Consider an honest prover P . At time r, the
honest prover holds a chain CP
r+ν.
By the Common Preﬁx property, CV [: − k] is a preﬁx of CP
r+ν.
Furthermore, (tx, tx(cid:48)) will appear in the same block (or consecutive blocks)

r and at round r + ν, it holds a chain CP
r and of CP

57

r . Therefore, (tx, tx(cid:48)) appears in CP

in all three. By the Chain Growth property, CP
r+ν contains at least k more
blocks than CP
r+ν[: − k] and are part of
the stable chain at round r + ν for party P . They are hence reported in
LP
r+ν ⊆ L∪
r+ν, which is a contradiction. Finally, by Proposition 1, proofs
of inclusion for tx and tx(cid:48) cannot be forged with respect to Merkle roots
in block headers other than those in CV , that were initially shown to
contain tx and tx(cid:48) (except with negligible probability).

Proofs of correctness and soundness for the consensus oracle construc-
tions of Celestia, Prism and Snap-and-Chat follow a similar pattern to
the proofs for the Nakamoto setting.

Lastly, for succinctness, one must leverage a construction such as su-
perblock NIPoPoWs [32]. Here, proofs of the longest chain are poly log C
where C denotes the chain size. Transaction inclusion proofs make use
of inﬁx proofs [32] in addition to Merkle Tree proofs of inclusion into
block headers. As C ∈ O(poly log r), these protocols are O(poly log r) as
desired. Completeness and soundness follow from the relevant security
proofs of the construction.

C Attack on SPV Clients on Lazy Blockchains

We examine a hypothetical attack on the succinctness of the communi-
cation complexity of the Bitcoin’s SPV [38] on a lazy blockchain protocol
with UTXO-based execution model. Suppose at round r, the conﬁrmed
sequence of blocks contain the transactions txi, i ∈ [n] in the reverse
order: for i ∈ {2, . . . , n − 1}, txi appears in the preﬁx of txi−1. Each trans-
action txi, i ∈ [n], spends two UTXO’s, UTXOp
i, such that for
i = UTXOp
i = 2, .., n, UTXOl
i i ∈ {2, . . . , n − 1},
and UTXOp
n are all distinct UTXOs. Thus, if txi−1 appears in the preﬁx
of txi, it invalidates txi as txi will be double-spending UTXOl
i−1
already spent by txi−1. However, txi, i ∈ {3, . . . , n}, does not invalidate
txj for any j < i − 1. We assume that no transaction outside the set txi,
i ∈ [n], invalidates txi for any i ∈ [n − 1].

i−1, and UTXOl

i and UTXOl

i = UTXOp

1 UTXOp

If n is even, tx1 would be invalid, since each transaction txi with an
odd index i ∈ {1, 3, . . . , 2n − 1}, will be invalidated by the transaction
txi−1. However, if n is odd, each transaction txi, with an even index i ∈
{2, 4, . . . , 2n−1}, will be invalidated by the transaction txi−1, which has an
odd index. Hence, tx2 would be invalid, implying that tx1 would be valid
as no transaction other than tx2 can invalidate tx1 by our assumption.

Consider a light client whose goal is to learn whether tx1 is valid with
respect to the transactions in its preﬁx. Suppose n is even, i.e., tx1 is

58

invalid. Towards its goal, the client asks full nodes it is connected to,
whether tx1 is valid with respect to the transactions in its preﬁx. Then,
to convince the light client that tx1 is invalid, an honest full node shows
tx2, which invalidates tx1, along with its inclusion proof. However, in this
case, an adversarial full node can show tx3 to the client, which in turn
invalidates tx2, and gives the impression that tx1 is valid. Through an
inductive reasoning, we observe that the adversarial nodes can force the
honest full node to show all of the transactions txi with even indices
i ∈ {2, . . . , n}, to the light client, such that no adversarial full node can
veriﬁably claim tx1’s validity anymore. However, since n can be arbitrarily
large, e.g., a constant fraction of the size of the conﬁrmed ledger, light
client in this case would have to download and process linear number of
transactions in the length of the ledger.

A related attack on rollups that use a lazy blockchain as its parent

chain is described by [45].

