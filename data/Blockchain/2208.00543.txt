2
2
0
2

t
c
O
0
1

]

R
C
.
s
c
[

3
v
3
4
5
0
0
.
8
0
2
2
:
v
i
X
r
a

ERC-20R and ERC-721R: Reversible Transactions on Ethereum

Kaili Wang
kkwang@cs.stanford.edu

Qinchen Wang
qinchenw@cs.stanford.edu

Dan Boneh
dabo@cs.stanford.edu

October 11, 2022

Abstract

Blockchains are meant to be persistent: posted trans-
actions are immutable and cannot be changed. As
a result, when a theft takes place, there are limited
options for reversing the disputed transaction, and
this has led to signiﬁcant losses in the blockchain
ecosystem.

In this paper we propose reversible versions of
ERC-20 and ERC-721, the most widely used token
standards. With these new standards, a transaction is
eligible for reversal for a short period of time after it
has been posted on chain. After the dispute period
has elapsed, the transaction can no longer be reversed.
Within the short dispute period, a sender can request
to reverse a transaction by convincing a decentralized
set of judges to ﬁrst freeze the disputed assets, and
then later convincing them to reverse the transaction.

Supporting reversibility in the context of ERC-20
and ERC-721 raises many interesting technical chal-
lenges. This paper explores these challenges and pro-
poses a design for our ERC-20R and ERC-721R stan-
dards, the reversible versions of ERC-20 and ERC-
721. We also provide a prototype implementation.
Our goal is to initiate a deeper conversation about re-
versibility in the hope of reducing some of the losses
in the blockchain ecosystem.

1

Introduction

1
Since their inception, cryptocurrencies have been
plagued by thefts and accidental losses [26]. Vic-
tims include end users [7], DAOs [20], bridges [18,
15, 25, 9], and exchanges [10, 1, 8, 22, 23]. Usually,
the stolen assets are ﬁrst transferred from the victim’s
address to an address controlled by the attacker. From
there the assets are laundered by transferring them to
other addresses and eventually to an offramp. In a
few cases, the assets are seized at the offramp [4].

The annual losses can be quite high. In 2020, $7.8
billion was stolen, and in 2021 that amount doubled
to $14 billion [5, 21]. A recent well publicized attack
on the Ronin bridge resulted in a theft of over $600
million [18]. The attacker transferred ETH and USDC
from the Ronin contract on Ethereum to an address
controlled by the attacker. From there, some of the
funds were moved to the Tornado mixer [19]. Other
bridges have experienced similar thefts [15, 25, 9]. In
many of these attacks, the assets stolen were held in
ERC-20 contracts.

Similarly, NFTs held in ERC-721 and ERC-1155
contracts have seen an uptick in thefts. In a twelve
months period following July 2021, an estimated
$100 million were stolen in NFTs using phishing
and other attacks [12, 5].

These attacks were often discovered soon after the
theft took place. Had there been a way to reverse the
offending transaction(s) – as in traditional ﬁnance –

 
 
 
 
 
 
the damage could have been greatly reduced.

Beyond theft, transaction ﬁnality has also worked
against us when funds are accidentally sent to a wrong
address. In May 2022, a Cosmos-based blockchain
called JUNO passed a proposal to move $36 million
USD to a speciﬁc address. The address contained a
typo [14] and consequently the funds were lost. The
funds could have been recovered had there been a
way to reverse that transaction.

Reversible transactions. In a 2018 tweet, Vitalik
Buterin wrote that

Someone should come along and issue an
ERC20 called “Reversible Ether” that is
1:1 backed by ether but has a DAO that can
revert transfers within N days.

Nowadays, this can be applied to any ERC-20 token
(not just wrapped ETH), as well as to NFTs.

Enabling reversible transactions is not easy and in-
troduces many fascinating technical challenges. The
main contribution of this paper is to explore how to
support reversibility within the ERC-20 and ERC-721
framework. We propose two new standards that allow
transaction reversal within a limited time window,
say four days. We call these standards ERC-20R and
ERC-721R, the reversible versions of ERC-20 and
ERC-721, respectively.

We envision the following high-level workﬂow for

reversing a posted transaction (see Figure 1):
• Request freeze. The victim posts a freeze request
to a governance contract, along with the relevant
evidence, and some stake. A request to freeze a
transaction can only be initiated by an address that
is directly affected by the transaction.

• Freeze assets. A decentralized set of judges de-
cides to accept or reject the request. If accepted,
the judges instruct an on-chain governance con-
tract to call the freeze function on the impacted

ERC-20R or ERC-721R contract. Subsequently,
the assets in question are frozen and can no longer
be transferred. For NFTs, this is a simple matter of
freezing the disputed NFT. For ERC-20 tokens this
is more complicated, as we explain below. We dis-
cuss the operation of the governance contract, and
the selection of judges, in Section 3. We envision
the freeze process being relatively quick, taking the
judges at most one or two days to make a decision.

• Trial. Both sides can then present evidence to the
decentralized set of judges. Eventually the judges
reach a decision, at which point they instruct the
governance contract to call either the reverse or
rejectReverse functions on the impacted ERC-20R
or ERC-721R contract. The reverse function trans-
fers the disputed (frozen) assets to their original
owner. The rejectReverse releases the freeze on
the disputed assets and leaves them where they are.
The trial may be lengthy, possibly taking several
weeks or months.

A more complete workﬂow is presented in Figure 2.

Locating the stolen assets. By the time the victim
submits a freeze request, the attacker may have al-
ready moved the stolen assets through multiple ac-
counts. In fact, the attacker can monitor the mempool,
and move the assets as soon as it sees a request to
freeze the stolen assets. In the case of an NFT, the
attacker may have sold the stolen NFT to an unsus-
pecting honest user. In the case of an ERC-20 token,
the attacker may have divided the stolen tokens across
multiple accounts; it may have exchanged a portion of
the tokens for another ERC-20 token using an honest
on-chain exchange; it may have burned a portion of
the tokens; or it may have sent the tokens to a mixer.
The new reversible standards must properly handle
all these cases.

In case of a dispute over an ERC-721 NFT, the
freeze is applied to the current holder of the NFT:
either the original attacker, or an honest user who pur-

2

Figure 1: The process for reversing a transaction.

chased the stolen NFT from the attacker. If the judges
decide that a theft took place, then the ERC-721R
contract sends the NFT back to the pre-theft owner.
The current owner of the NFT loses the NFT. This
policy is consistent with tort law in many countries,
but of course, other policies can be implemented.

In case of a dispute over stolen ERC-20 tokens
things are more complicated. By the time the freeze
is executed, the funds may have been dispersed across
many downstream accounts, some honest and some
dishonest. In Section 2 we present an example algo-
rithm that assigns fractional responsibility to each of
the downstream accounts that received a portion of
the stolen funds. The partial freeze is then applied
to these accounts. Implementing this freeze strategy
requires the ERC-20 contract to maintain a transac-
tion log during the dispute window so that the freeze
function can trace the funds when it is called by the
governance contract. If the judges decide that a theft
took place, the ERC-20R contract moves the frozen

Figure 2: Overview of reversal process

tokens from the obligated accounts to the pre-theft
account. We discuss this in more detail in Section 2.

Will reversibility introduce delays? Suppose Alice
holds tokens in an ERC-20R (an R-token) and she
wishes to exchange them for ETH or for some other
ERC-20 (a non-R-token). Bob is willing to do the
ETH-for-token exchange with Alice and they agree
on the exchange rate. Clearly Bob will not release his
ETH to Alice until he is assured that the R-tokens that
Alice sent him cannot be taken back due an upstream

3

reversal request. This means that Bob will only ac-
cept R-tokens that were transferred to Alice at least
four days ago, if the dispute window is four days. We
refer to such R-tokens as “old” tokens, since they are
no longer subject a freeze and reversal. If Alice has
sufﬁciently many old R-tokens then the transaction
can settle right away. Otherwise, Bob will delay ﬁnal
settlement for four days, after which he is assured
that Alice’s R-tokens cannot be taken away due to an
upstream reversal. In particular, if Alice steals some
R-tokens from Victor (the victim) and immediately
tries to exchange them for Bob’s non-R-token, that ex-
change will only settle four days later, by which time
Victor may have asked for the theft to be reversed.
To reiterate, an exchange of a recently transferred
R-token for a non-R-token will be subject to delay.

Interestingly, if Alice wants to exchange one re-
versible token for another reversible token, then Bob
can immediately settle that exchange. No delay is
needed. If the transaction that sends Alice’s tokens to
Bob is later reversed, then Bob can request to reverse
the matching transaction that sends his tokens to Al-
ice. Hence an R-token to R-token exchange can settle
instantly, but an R-token to a non-R-token exchange
may need to be delayed until the reversible tokens are
sufﬁciently old.

The consequence of this is that once a few key to-
kens become reversible, there is a strong incentive for
other tokens to become reversible to avoid settlement
delays. In other words, reversibility is viral.

1.1

Implementation

We provide a reference implementation of these new
standards. Our Solidity implementation is split into
two parts: (i) the main ERC-20R and ERC-721R
contracts that keep track of all the balances and trans-
actions, and (ii) a governance contract that selects
judges and gathers votes. Our ERC-20R and ERC-
721R implementations are extensions of the Open-

Zeppelin non-reversible contracts.

Recall that an ERC-20 contract manages the bal-
ances of many accounts. In our ERC-20R contract, an
account balance is a pair of numbers we call Rbalance
and NRbalance.

• The NRbalance is the current account balance
due to incoming transactions whose dispute win-
dow has elapsed. Funds in the NRbalance are
non-reversible: they are no longer subject to a
potential freeze and reversal.

• The Rbalance is the account balance due to re-
cent incoming transactions. Funds in the Rbal-
ance are subject to reversal.

As the dispute window elapses, funds move from the
Rbalance to the NRbalance. This is done using the
clean function discussed below.

When an account owner sends funds from its own
account to another account (say, to fulﬁll an exchange
of assets), the account owner speciﬁes how much
to take out of the Rbalance and how much to take
out of the NRbalance. That is, the standard ERC-20
transfer function now comes in two ﬂavors: transfer()
and Rtransfer(). The former transfers from the non-
reversible balance, while the latter transfers from the
reversible balance. Either way, the transferred funds
are added to the Rbalance of the recipient. Note that
our transfer function is backwards compatible with
the ERC-20 speciﬁcation. When the contract needs
to burn tokens in an account (e.g., due to a ﬁat or
base token withdrawal), it will typically only burn
tokens from the NRbalance of the account. However,
there may be situations where the contract is willing
to burn from the Rbalance.

Beyond the new transfer interface, an ERC-20R and
ERC-721R contract exposes the new interface func-
tions freeze, reverse, rejectReverse, and clean. Let us
describe this API in more detail:
• freeze(): calculates the amounts to freeze on the

4

attacker’s address as well as potential downstream
addresses, and freezes those amounts. For ERC-
20R it returns a claimID that points to an on-chain
list of (account,amount) pairs. The list identiﬁes
all the accounts that contain frozen assets associ-
ated with the complaint, and the amount frozen in
each. For ERC-721R it returns a boolean success
ﬂag. The inner workings of the freeze function is
explained in Section 2.

• reverse(): sends all frozen assets associated with
the claimed theft back to the original owner. For
ERC-20R, takes as argument a valid claimID. For
ERC-721R, takes in arguments (tokenId, index)
where index identiﬁes the transaction being re-
versed.

• rejectReverse(): unfreezes all amounts associated
with the claim. For ERC-20R, takes as argument
a claimID; for ERC-721R, takes as argument a
tokenId.

• clean(): Reversible contracts store some transac-
tion data on chain. The clean function removes
on-chain information for transactions whose dis-
pute window has elapsed. The data structure that is
being updated is explained in Section 2.1. In addi-
tion, for ERC-20R this function moves the relevant
balance from the Rbalance to the NRbalance.
The freeze, reverse and rejectReverse functions can
only be called by the governance contract, while any-
one can call the clean function.

1.2 Related Work

In the fall of 2018, one of the co-creators of the
ERC-20 standard proposed the concept of a reversible
ICO, where investors would be able to get a refund
amount inversely proportional to how recently they
invested [24]. Although this safeguards against a sin-
gle token being a scam at launch, it does not protect
against malicious transactions.

Eigenmann [11] drafted a contract for a reversible
token that extends the ERC-20 standard. It used an
escrow method, where the escrow period was 30 days,
during which the sender could recall the money at any
time. This is problematic because Bob could pay Al-
ice for a service, and then reverse the payment 28 days
later, after Alice completed the service. A similar ap-
proach is used in a proposal for refunds in ERC-721
mints [13], where Bob can get his money back within
a certain time window after buying an NFT. In our
proposal, Bob would need to present sufﬁcient evi-
dence to a committee of judges for a transaction to be
reversed. This protects counter-parties to the disputed
transaction.

The Reversecoin project from 2015 launched as a
layer 1 blockchain [6]. It introduced a timeout pe-
riod between transaction initiation and conﬁrmation.
Each account has an ofﬂine key pair that enables the
owner to either reverse a transaction or immediately
conﬁrm it. This may not prevent some modern hacks:
the attacker would either steal the conﬁrmation key,
or trick the user into using the conﬁrmation key to
conﬁrm a malicious transaction. The elegant Bitcoin
Convenants proposal [17] similarly uses two keys (or
more) to enable a vault owner to ﬁnalize or revert
transactions from the vault 24 hours after they were
posted.

A closely related project is Lossless.io [16]. The
company provides a wrapped version of certain ERC-
20 tokens. Anyone with staked LSS tokens can moni-
tor on-chain events for hacks, and can freeze an ad-
dress if the address is involved in a hack. Only a
single address can be frozen for a given hack, so one
must act quickly after a hack to freeze the attacker’s
address before the funds are further dispersed. The
quickest spotter is rewarded in a winner-takes-all fash-
ion. Transactions can also be frozen automatically by
open-source mechanisms built by the Lossless team.
The company then decides unilaterally whether the
reversal is warranted, and if so reverses the transfer.

5

If a recipient burns the wrapped token it receives, by
converting them back to the base unwrapped token,
then reversal is no longer possible. This cannot hap-
pen in our proposal since token burns come from an
account’s NRbalance (unless the contract willingly
accepts the risk of burning Rbalance tokens).

Finally, centralized exchanges maintain the ability
to freeze and remove assets. For example, Binance
USD (BUSD), issued by Paxos, states that (link):

Paxos also has the ability to create and burn
BUSD tokens at will, as well as freeze and
remove funds from people who exhibit ne-
farious or illicit activity.

The same holds for other centralized tokens. In these
centralized systems, the operator acts as a centralized
judge that can reverse transactions.

2 The transaction reversal process

In this section we describe the details of the ERC-20R
and ERC-721R process of reverting a transaction. We
describe the data structures and algorithms needed to
track the funds that will be frozen and later sent back
to the victim, if the victim prevails.

In this section we explain what happens when the
governance contract calls the freeze function on the
relevant ERC-20R or ERC-721R contract.

2.1.1 An ERC-721R freeze

The freeze function on an ERC-721R contract is quite
simple. First, we add two structures to the contract:

mapping(uint256 => bool )
mapping(uint256 => Queue)

_frozen;
_owners;

The frozen structure indicates if a particular
tokenID is frozen.
If frozen[tokenID] is
true then the asset is frozen, and cannot be transferred.
The owners structure keeps track of the recent
list of owners for the asset identiﬁed by tokenID.
On every transfer, a pair (newOwner, blockNumber)
is appended to the queue at owners[tokenID]
to record that at this block number, the new owner
of tokenID became newOwner. This owners
structure looks as:



tokenID0 → (cid:2)(owner0, bn0), (owner1, bn1), . . .(cid:3)

tokenID1 → (cid:2)(owner0, bn0), (owner1, bn1), . . .(cid:3)
tokenID2 → (cid:2)(owner0, bn0), (owner1, bn1), . . .(cid:3)


. . .

2.1 Freezing assets

After a theft from an ERC-20R or an ERC-721R con-
tract, the victim posts an on-chain freeze request to
the governance contract. The request includes the
offending transaction ID, a link to evidence that an
unauthorized transfer took place, and some stake. If
the judges are convinced by the evidence (see Sec-
tion 3) then they instruct the governance contract to
call the freeze function on the relevant ERC-20R or
ERC-721R contract. Once the assets are frozen, any
attempt to transfer them will fail. If the judges are
unconvinced, they instruct the governance contract to
reject the request, and the victim loses the stake.

where for each tokenID we have bn0 ≤ bn1 ≤ · · ·

The governance contract freezes an asset by calling

freeze(tokenID, index)

where index points to an entry in the queue
owners[tokenID]. The function ﬁrst veriﬁes
that the disputed transfer took place within the dis-
pute window by using the block number at position
index+1 in the queue owners[tokenID]. The
function also ensures that the asset is not already
frozen.
If the checks succeed, the function sets
frozen[tokenID] to true, indicating that the as-
set is frozen. That’s it. Doing these checks on-chain
ensures that even malicious judges cannot reverse a
transaction outside of the dispute window.

6

If at a later time the ERC-721R contract is asked
to revert the disputed transfer (that is, the governance
contract calls the reverse function), the contract sim-
ply transfers tokenID to the address written at po-
sition index in the queue owners[tokenID].
This was the owner before the disputed transaction.

Calling the clean function on this contract with
a list of token IDs removes data from the owners
structure that is no longer needed. This removes trans-
fers that can no longer be reverted because the dispute
window has elapsed. It is done to save on chain stor-
age. Note that a frozen tokenID cannot be cleaned
until it becomes unfrozen; this preserves the data
needed to reverse a disputed transaction, if needed.

2.1.2 An ERC-20R freeze

The freeze function on an ERC-20 contract is much
more complicated. The problem is that the tokens
might have been transferred to multiple accounts be-
tween the time of the theft and the freeze request.

Figure 3 shows a transaction from a victim address
v to an attacker address a0. Subsequent transfers
from a0 that took place after the disputed transaction,
but prior to a freeze request, are indicated as directed
edges in the graph. All these downstream addresses
may hold stolen funds that may need to be frozen.

Another complication is that tokens can be burned
and simply vanish from the system. For example,
in a stablecoin contract that is collateralized by a
ﬁat currency, the account a8 may choose to redeem
its coins for ﬁat currency, at which point the coins
at a8 are burned. If the contract supports burning
token from the Rbalance of a8 then there might not
be sufﬁcient assets to freeze at address a8, and the
stolen funds are permanently lost. This is why burns
generally apply to the NRbalance of an account.

Yet another complication is that a single address,
say address a1, might own funds obtained from mul-
tiple thefts. When the funds are frozen, the system

Figure 3: An example graph G of transfers following
the disputed transaction from v to a0.

needs to remember the amount frozen for each rever-
sion request, and if a reversion request is approved,
only the funds associated with that request should be
taken out of account a1.

If there are multiple freeze events on a single ac-
count, the frozen amount is cumulative. In particular,
if account a has a total of s frozen coins, then the
ERC-20R contract will reject any transfer that causes
the Rbalance of account a to drop below s.

Calculating suspect addresses. Let us begin by de-
scribing a speciﬁc strategy for calculating the amount
to freeze on each account in the graph G from Fig-
ure 3. Accounts that are subject to a freeze are called
suspect addresses. Our freeze algorithm will chase the
stolen funds across the transaction graph and freeze
funds across suspected addresses. The algorithm will
freeze assets that are as close as possible to a0 in G.

Before we describe the detailed algorithm, let us
ﬁrst see a few examples. Suppose that s coins are
stolen from the victim v and transferred to account a0
at time T0. At time Tf > T0 the ERC-20R contract
receives a request to freeze that transaction.
Example 1. If at time Tf the Rbalance at a0 is s or

7

more, then s coins will be frozen at a0 and the process
concludes.
Example 2. Suppose that at some time between T0
and Tf a transaction transfers s/4 coins from a0 to
a1 and an additional s/4 coins from a0 to a2. The
remaining Rbalance at a0 is s/2 and no subsequent
transactions apply to a0. Then at the freeze time, the
entire s/2 Rbalance at a0 will be frozen. Moreover, if
the Rbalance at a1 and a2 is exactly (s/4), then (s/4)
coins will be frozen at each of those accounts. Now
that a total of s coins has been frozen, the process ter-
minates. Note that a1 or a2 might be the addresses of
an honest exchange or a mixing service, in which case
a portion of the coin’s liquidity pool at the exchange
or mix will become frozen.
Example 3. Suppose that following the disputed trans-
action from v to a0, there is a second transaction
a0 → a1. Clearly if there are insufﬁcient funds at
a0 at the time of the freeze, then some of the freeze
obligations should pass on to a1, as explained in the
previous paragraph. However, suppose that at some
time before the a0 → a1 transaction, there is a trans-
action a1 → a2 that transfers funds from a1 to a2.
We propose that none of the freeze obligations will
pass on to a2, because the a1 → a2 transaction was
posted before the disputed funds arrived at a1. The
funds sent to a2 are not directly involved in the dis-
pute. One can give examples where this policy can
lead us astray, but by in large, we claim that a2 should
not be involved in the freeze.

These examples suggest that the freeze process
is an iterative procedure that freezes the maximum
amount possible at every step. If the Rbalance at
the current node is insufﬁcient, then the obligation is
passed to the descendants of that node. The process
terminates once s coins are frozen, or once there are
no more descendants to process.

balances cannot change while the freeze process is
executing.

Terminology. Suppose that the freeze function is
called to freeze a transaction t0 that transferred
s coins from address v to address a0. Let tf be the
posted freeze transaction on chain. To describe the
freeze algorithm, we use the following notation:

• toFreeze(a) is the number of coins that the
freeze transaction tf will freeze at address a. At
the start of the algorithm toFreeze(a) = 0 for
all a, with the exception of a0, where

toFreeze(a0) := min(cid:0)s, Bal(a0)(cid:1).

(1)

The quantity Bal(a), for an address a, is the
available Rbalance at a at the time of tf. This
Bal(a) is calculated as the Rbalance at a at the
beginning of the freeze transaction minus the
amount of coins already frozen at a due to a
prior dispute. Thus (1) will freeze the maximum
amount possible at a0.

• For a transaction t = (a → b), from a to b, let

val(t) be the value transferred from a to b.

• burnedAt(a) is set to the number of coins burned
at address a from its Rbalance between the ﬁrst
transaction that sent a portion of the disputed
funds to a and the freeze transaction tf.

Now, consider the graph G that is deﬁned by the
set of transactions that took place after the disputed
transaction and before the freeze transaction. The
nodes in the graph are addresses, and every directed
edge represents a transfer from one address to another.
The graph only includes an edge b → c if there is
directed path of transactions from a0 to address b that
all took place after t0.

We stress that the freezing algorithm in its entirety
runs in a single transaction. This ensures that account

The algorithm. We ﬁrst describe a freeze algorithm
that applies when the graph G rooted at a0 is a di-

8

rected acyclic graph (DAG). In Appendix A we ex-
tend the algorithm to handle cycles by introducing a
pre-processing phase that eliminates cycles.

The freeze algorithm is implemented in the func-
tion CalcFreeze shown in Figure 4. This function is
called as

CalcFreeze(t0)

where t0 is the disputed transaction.

The algorithm begins by constructing a topological
sort of the vertices of G staring at a0. A topological
sort is a list L of the vertices in G, where every vertex
in G appears exactly once in L, such that for every
edge (a → b), the vertex a appears in L before b.
Every DAG has a topological sort L, and L can be
constructed in linear time in the number of edges.

For each address a in G the algorithm builds a
value oblig(a) that indicates the obligation amount
that is passed to address a and its descendants as
a result of the disputed transaction. The value of
oblig(a) can increase whenever the algorithm process
an address that sent funds to a. For all a, the array
oblig(a) is initially set to zero.

The algorithm attempts to freeze the maximal
amount possible at every node a, starting with the
root a0. Line (3) calculates τ (cid:48), the amount left to
freeze after the available Rbalance at a is frozen.
the algorithm subtracts the Rbalance
Moreover,
amount burned at a because that obligation should
not transfer to the descendants of a. The remain-
ing amount, τ (cid:48), should pass as an obligation to the
descendants of a. In Line (6) the algorithm loops
over all the transactions that take funds out of a. The
loop proceeds in reverse chronological order, namely
from the most recent transaction to the oldest trans-
action. Then Line (8) obligates the recipient of the
most recent transaction from a to the maximal pos-
sible amount. This continues until all of τ (cid:48) is passed
as an obligation to the children of a. We analyze this
algorithm and its properties in Appendix A.

CalcFreeze(t0):
L := (topological sort of the graph rooted at a0)

// freeze trans. t0=(v→a0)

// assuming the graph G is a DAG

oblig(a0) := val(t0)

// the obligation of a0 due to t0

for each a in L in order do:

// start at a0

1:

τ := oblig(a)

2:

3:

// total obligation at a from parents

toFreeze(a) := min(cid:0)τ, Bal(a)(cid:1)
// amount to freeze at a

τ (cid:48) := τ − toFreeze(a) − burnedAt(a)

// the amount left to freeze, but do not
// pass burned amount downstream

4:

if τ (cid:48) ≤ 0: continue

// all done with a

5: E(a) := sort( {t=(a→b)} )

// the set of trans. from a sorted
// in reverse chronological order

6:

for each t=(a→b) in E(a) in order do:

7:

8:

9:

// for each outgoing edge from a,
// starting with the most recent one

ob := min(cid:0)τ (cid:48), val(t)(cid:1)

oblig(b) += ob ;

τ (cid:48) – = ob

// obligate recipient b to ob tokens

if τ (cid:48) ≤ 0: break

// all done with a,
// terminate the inner loop on line (6)

Figure 4: The freeze algorithm for a DAG

Note that every address a is only visited once, and
only after all its parents have been processed. Con-
sequently, the running time is linear in the number
of edges in the graph. More precisely, if there are V

9

nodes and E edges in the graph then the running time
is O(V + E) thanks to the data structure we use that
keeps edges in a chronologically sorted order.

Once this algorithm completes, the contract will
add the quantity toFreeze(a) to the number of coins
frozen at address a (recall that a might already have
frozen coins due to a prior dispute). This means that
a subsequent transfer out of address a will fail if it
causes the Rbalance of a to drop below the commula-
tive frozen amount.

Implementing the algorithm. The ERC-20R con-
tract needs to maintain enough state to support the
freeze process. We introduce a new Solidity data
structure called spenditures that serves two func-
tions: (i) when asked to freeze a transaction, the con-
tract needs to verify that the transaction took place
within the dispute window, and (ii) for an address a,
the contract needs to identify all downstream ad-
dresses that received funds from a after the disputed
transaction took place.

The new Solidity data structure called spenditures

is illustrated in Figure 5.

Figure 5: Spenditures nested map.

We refer to each sequence of ∆ blocks as an epoch
(e.g., ∆ = 1000). For each epoch, the spenditures
data structure lists all the transactions that took place
during that epoch for each source address (Alice and
Bob in the ﬁgure). Each Spenditure entry in Figure 5
contains the triple (to, amount, blockNumber). Every
time the contract processes a transfer request, it ap-
pends a Spenditure entry to the appropriate array in
the spenditures structure. A burn transaction adds a
Spenditure triple where the to ﬁeld is null.

The freeze function takes in arguments

(epoch, from, index),

where epoch identiﬁes the epoch in which the dis-
puted transaction took place, from identiﬁes the payer,
and index identiﬁes the speciﬁc Spenditure in the data
structure. The index argument is provided by the
governance contract by running an off-chain search
over the spenditures structure to locate the disputed
transaction.

The freeze function checks that the requested trans-
action is within the dispute window, and if so, runs
the freeze algorithm using the spenditures data struc-
ture to determine the edges of the graph G from Fig-
ure 3. The ﬁnal calculated freeze amounts per address
are frozen. In addition, all these freeze amounts are
recorded in a secondary array called claims that is
indexed by a newly generated 256-bit ClaimID. If the
victim prevails in trial, this array is used to transfer
the correct amount from every suspect address to the
victim. The freeze function returns the ClaimID that
indicates how to reverse the transaction.

The clean function. To minimize on-chain storage,
our ERC-20R includes a clean function that takes
in an epoch and an array of addresses. The function
deletes all array entries in spenditures with the speci-
ﬁed epoch and sender addresses for epochs for which
the dispute window has elapsed. For every deleted
entry, the speciﬁed spenditures amount is transferred
from the account’s Rbalance to its NRbalance, while

10

making sure that the total Rbalance does not drop
below the frozen amount at the account. Anyone can
call the clean function and free up on-chain storage
that is no longer needed.

2.2 Reversing a transaction

Once the trial over a disputed transaction concludes,
the governance contract will call the rejectReverse
function or the Reverse function on the ERC-20R or
ERC-721R contract.

• An ERC-20R reversal takes as input a ClaimID
which is an index into the claims array. The
entry indicates the obligation of each suspect
account in the disputed transfer. The function
transfers the speciﬁed amount from the Rbalance
of suspect accounts to the original owner, and
clears the freezes.

• An ERC-721R reversal takes as input TokenID
and an index into owners array. This indicates
the owner prior to the disputed transaction. The
asset is then transferred to the original owner,
and the asset is unfrozen.

3 The Arbitration Process

We now turn to the governance process where judges
examine the evidence on a disputed transaction and
decide if the transaction should be revered. Some of
the key issues in designing this process are: (i) how
judges are selected, (ii) how judges are compensated,
and (iii) how to discourage misbehaving judges, such
as judges who take bribes or make bad decisions on
disputed transactions.

This process is orchestrated by a governance con-
tract. A single governance contract can govern many
20R and 721R contracts. Judges vote on cases by
either using an on chain or off chain voting system.

Once enough votes on a case are collected, the gover-
nance contract calls the appropriate function on the
20R or 721R contract to either execute the reversal or
dismiss the case. To ensure that judges make indepen-
dent decisions, it is important that votes remain secret
until sufﬁciently many votes are cast. This could be
done, for example, using some ﬂavor of a commit-
and-reveal voting scheme, or any other semi-private
voting scheme.

3.1 Selecting judges

We envision a large pool of available judges who will
be compensated for their work. When a freeze request
is submitted, the governance contract selects a ran-
dom and unpredictable quorum of n judges from the
pool. The value of n can be ﬁxed, say n = 12, or it
can increase with the size of the disputed transaction,
so that deciding on a large transaction requires more
judges. This random selection is best implemented us-
ing a randomness beacon [2]. This quorum of judges
decides on the initial freeze request, and later decides
whether to approve or reject the reversal request.

Who can join the pool of judges and preside over
cases? One can envision a process that requires a real
world identity, a requirement for qualiﬁcations, and
a statement of conﬂicts, much like real-world judge
selection. We will leave the details of how to admit
applicants into the pool of judges to future policy
discussions of the exact mechanism.

3.2 Compensating judges

Every freeze request to the governance contract is
accompanied by some stake from the party request-
ing the freeze. This stake can be used to compensate
judges for their work. We state the following prin-
ciple in deciding how to compensate judges: When
judges submit their vote on a freeze request or on a re-
versal decision, they are compensated for their work.

11

However, the compensation amount is independent of
their voting decision.

If judges approve a freeze request,

then the
claimant’s staked amount, minus fees, remains locked
in the governance contract. If later the claimant loses
the trial, the staked amount can compensate the de-
fendant for their effort. If the claimant wins the trial,
they could get back their excess stake. Importantly,
if the judges reject the initial freeze request, then
the claimant’s staked amount minus the judges’ ﬁxed
fees, should be burned.

Priority fees. While victims must provide a minimal
stake along with a freeze request, they can optionally
provide additional stake if they so choose. This extra
“tip” from the victim could potentially indicate the
priority of the case. Judges could rule on cases by
priority rather than by chronological order. The tip
could either be burned, or given to the prevailing party,
or some combination of the two.

3.3 Discouraging judicial misbehavior

A judge might fail to vote in a timely manner, or
they might frequently vote with the extreme minor-
ity, potentially indicating an issue with their decision
making. In either case, the governance contract could
remove such a judge from the pool.

A more interesting question is how to prevent
bribery, where a party bribes judges to vote in its
favor. There are several technical solutions that could
help partially mitigate this issue. One approach is
to use a secrecy-preserving process for selecting the
quorum of judges to preside over a case: a selected
judge will learn that they were selected; however, on
their own, they will not know who the other judges
are, nor will they be able to prove to anyone that they
were selected (if they honestly follow the selection
protocol). Once all the selected judges vote, the set of
judges is revealed along with a proof that the correct

set voted. Importantly, the proof is revealed by the
posted data from the selected judges, not by a set
of trustees. This way, a party who wishes to bribe
a judge will not know who to bribe because the set
of judges is only revealed after they all voted. This
makes it more difﬁcult (but not impossible) to bribe
judges.

4 Discussion and Extensions

Backwards compatibility. Our ERC-20R standard
is backwards compatible with the existing DeFi in-
frastructure, such as exchanges and lending protocols.
First the transfer() function in ERC-20R has the same
API as the transfer() function in the ERC-20 standard.
Hence, no software changes are needed to process
a customer request. Second, because the transfer()
function transfers funds from Alice’s NRbalance (her
balance of “old” tokens that are no longer reversible),
the exchange is assured that the funds that Alice sends
to it will not be reversed due to a subsequent upstream
reversal. Of course, Alice herself might try to re-
verse the transaction that sent Alice’s tokens to the
exchange, but as long as the exchange can show that
it honestly processed the swap, that reversal request
will be rejected, and Alice will lose the fee needed to
ﬁle a freeze request. Hence, the only change to the
DeFi provider is that it may need to respond to false
reversal requests by Alice.

When the exchange sends ERC-20R tokens to Al-
ice, it will call the transfer() function, as it does today.
This transfers funds from the exchange’s NRbalance.
Hence, the exchange will need to ensure that its NR-
balance is sufﬁciently high to support customer de-
mand. This is done by calling the clean() function
frequently, to transfer maturing funds from the ex-
change’s Rbalance to it NRbalance.

Finally, some exchanges and lending protocols may
be willing to take the risk and accept funds from

12

Alice’s Rbalance, most likely charging Alice a higher
fee in the process. These transactions will require
greater scrutiny by the DeFi provider, and will require
additional software to properly assess the risk.

Reversibility is viral. An exchange that processes a
swap of one 20R token for another 20R token is safe
to do so without delay: if one side of the transaction
is later claimed to have come from stolen funds, the
exchange can initiate a reversal on the other side of
the transaction. However, exchanging a 20R token
for a non-reversible ERC-20 token is more dangerous.
The exchange might only approve such a swap after
the dispute window has elapsed on the 20R side of the
transaction. This introduces a delay when swapping a
reversible token for a non-reversible one. Thus, once
some key tokens become reversible, other tokens are
incentivized to do the same to eliminate this delay. In
other words, reversibility is viral.

Automation. In addition to judges, one could also ex-
periment with an algorithmic transaction monitor that
factors into the ﬁnal decision. A decision to freeze or
reverse could then be a function of both the risk score
given by the monitoring algorithm and the judges’
votes. For example, if the algorithm determines a
high likelihood that a transaction is a result of theft,
then a reversal rejection would require a higher thresh-
old of judges voting against the case. One could also
use such an algorithm to broadcast alerts of suspi-
cious transactions, lowering the risk that a victim will
miss the reversion window.

Appeals. Future work may consider an appeals pro-
cess, in which the party who loses the trial can request
another group of judges to rule on the disputed trans-
action. We do not explore this here.

Partial reversals. In some cases judges may opt for
a partial reversal, where part of the funds go back to
the owner, and part stay with the recipient. While we
focused on complete reversals, the API can support

partial reversals.

Grouping disputes. A transaction that sends coins
from address A1 to A2 is often accompanied by a
transaction from A2 to A1. For example, A1 might
send DAI to A2, and in exchange A2 sends an NFT
to A1. Suppose that both DAI and the NFT support
our reversible standards. Then, if A1 asks to reverse
the DAI transaction, A2 will likely ask to reverse the
NFT transaction. As an optimization, both claims can
be decided jointly by the same quorum of judges.

5 Conclusion

In this paper, we proposed extensions to ERC-20 and
ERC-721 that introduce a short time window when a
transaction can be reversed. If adopted widely, these
standards can protect the blockchain community from
large ﬁnancial losses. We hope that this paper will
generate more discussion of reversibility as well as
new designs to address the challenges that it raises.

Acknowledgments. This work was supported by
NSF, the Simons Foundation, NTT Research, Coin-
base, and UBRI.

A Details of the freeze algorithm

In this section we extend and further analyze the
freeze algorithm in Figure 4.

A.1 Properties of the algorithm

First, let us examine some properties of the freeze
algorithm in Figure 4. Consider the two transaction
graphs in Figure 6. Both show the ﬂow of funds,
starting with a disputed transaction from v to a0. Let
us assume that when freeze is called, the balance at
a0 and a1 is zero in both graphs. As a result, in both
graphs, calling freeze on the transaction from v to a0

13

will transfer the obligation to addresses a2 and a3,
which is where the funds reside at the time of the
freeze.

In the graph G1 the transaction from a1 to a3 is the
most recent, and therefore the algorithm will freeze
10 tokens at a3 and zero tokens at a2. This may seem
unfair because both a2 and a3 may have received a
portion of the disputed funds. We stress, however,
that in this case there is no “correct” answer because
it is not possible to determine how exactly a1 split the
20 tokens at its disposal (10 from the disputed trans-
action and 10 from a prior balance). Our algorithm’s
decision is as “correct” as any other answer.

Interestingly, an algorithm that tries to split the obli-
gation evenly between a2 and a3 in the graph G1 can
lead to paradoxical results. Consider the graph G2.
The algorithm needs to obligate a2 and a3 to a total
of 20 tokens. By the discussion in Section 2 (Exam-
ple 3), address a3 bears the full responsibility for the
second transaction from a0 to a1, and will therefore
be obligated to 10 tokens as a result of this transaction.
Now, if a3 were to bear a portion of the responsibil-
ity for the ﬁrst transaction from a0 to a1, then the
total obligation passed to a3 would exceed 10 tokens.
Since the balance at a3 may only be equal to 10, this
strategy will cause the algorithm to fail to freeze 20
tokens in total. Consequently, splitting the obligation
between a2 and a3 in such cases may lead to freezing
a reduced number of tokens, thereby preventing the
victim from recovering the disputed funds.

Our algorithm does not suffer from this issue: The-
orem 1 below shows that our freeze algorithm in Fig-
ure 4 always freezes the correct amount: 10 tokens in
the graph G1 and 20 tokens in the graph G2.

A.2 Graphs with cycles

The freeze algorithm in Figure 4 relies on a topologi-
cal sort of the nodes in the graph G. The topological
sort only exists when the graph is acyclic. Here we

Figure 6: Two graphs where transactions are ordered
chronologically from top to bottom. In both graphs,
the balance at a0 and a1 is zero at the time of the
freeze. In G1 the starting balance at a1 is 10.

extend the algorithm to any directed graph, even one
that includes cycles. We use a pre-processing phase
that eliminates cycles.

Let us ﬁrst see an example. Suppose the graph
contains a transaction t = (a0 → a1) for ﬁve coins,
and a subsequent transaction t(cid:48) = (a1 → a0) for
three coins. This simple cycle means that a0 sent ﬁve
coins to a1, and a1 subsequently sent three coins back
to a0. For the purpose of our freeze algorithm, we
can replace both transactions by a single transaction
from a0 to a1 for two coins, and eliminate the cycle.
More generally, let t0 = (v → a0) be the disputed
transaction. The pre-processing step scans the graph
rooted at a0 to look for a directed cycle of transac-
tions c0, . . . , ck−1 where ci = (bi → bi+1 mod k) that
were all posted after the disputed transaction. Let c
be the transaction of smallest value along the cycle,
breaking ties arbitrarily. Let d := val(c). We can
eliminate the cycle by removing transaction c from
the graph, and subtracting d from the value of every
other transaction in the cycle. The algorithm can re-
peat this process until the graph is free of cycles. At
this point, the algorithm from Figure 4 can be applied

14

to the resulting graph.

A.3 Two correctness theorems

Finally, we argue that the algorithm will freeze the
correct amount. The ﬁrst theorem shows that the
algorithm will freeze the correct total amount. The
second theorem shows that the algorithm will not
over-freeze funds at any single address.

Theorem 1. Suppose that no burn transactions are
processed between the disputed transaction t0 and
the freeze transaction tf . Moreover, there are no
prior freezes in the system. Then, if the disputed
transaction t0 sends s tokens to address a0, then the
freeze algorithm in Figure 4 will freeze a total of
exactly s tokens. In particular, when the algorithm
terminates we have

(cid:88)

s =

toFreeze(a).

(2)

a

Proof sketch. First, let us assume that the directed
graph rooted at a0 is a DAG. We argue that the algo-
rithm satisﬁes two properties:
• Property 1. When an address a is processed in
the main loop, let us call the quantity τ (cid:48) computed
on Line (3) the excess obligation at a, namely the
obligation not covered by a’s current balance. We
claim that when the algorithm completes process-
ing address a, the quantity τ (cid:48) is added to the total
obligation of the children of a.

• Property 2. For a transaction t : a → b, let ob(b, t)
be the obligation that the algorithm passes to b as
a result of t. We claim that for every transaction
t : a → b we have

ob(b, t) ≤ val(t).

Figure 7: A sequence of m + 1 incoming transac-
tions to a from its parent a0, along with m outgoing
transactions from a, interleaved in time. Incoming
transaction number i obligates a0 to xi tokens, and
outgoing transaction number j sends yj tokens to bj.

Together these two properties prove the lemma: at
every address, the exact excess obligation is passed
to its children, and there are sufﬁcient funds at the
descendants to cover these obligations.

Let us prove these two properties. Property 2 is
immediate from Line (8) in the algorithm. This line
ensures that for every transaction t, at most val(t) is
added to the obligation at b.

Property 1 follows from the fact that no coins are
burned. In particular, consider the node a in Figure 7.
The total obligation passed to a is τ := x0 + . . . + xm.
Let Bal(a) be the balance at a just prior to the freeze
transaction. Then, by Property 2 and because no
tokens were burned we know that

This means that the funds that transaction t sends
to b (and its descendants) is sufﬁcient to cover the
full obligation that the algorithm passes to b.

τ ≤ Bal(a) + (y1 + . . . + ym)
(cid:125)
(cid:124)

(cid:123)(cid:122)
amount that left a

.

Moreover, by Line (3) we know that τ − τ (cid:48) = Bal(a)

15

and therefore

τ (cid:48) ≤ y1 + . . . + ym.

(3)

But when (3) holds, the loop in Lines (6) to (9) is
guaranteed to add τ (cid:48) to the total obligations of the
children of a. This proves Property 1.

To complete the proof we observe that the cycle
elimination process from Section A.2 does not affect
the number of frozen tokens. Hence, the lemma ap-
plies equally well to non-DAG graphs, assuming the
cycle elimination process is applied ﬁrst.

Next, we show that the algorithm will not over-
obligate an address. This is where we rely on the
reverse chronological order loop in Line (6). Consider
again the transactions out of a in Figure 7. We show
that for every j ∈ {1, . . . , m}, the address bj will
bear no obligation for funds that arrived at a after
transaction number j. To deﬁne this, for a transaction
t : a → b we use the following terminology:

• ob(b, t) is the obligation passed on to b as a result of
transaction t. In other words, ob(b, t) is the value
added to oblig(b) when the algorithm processes the
transaction t.

• obsum(a, t) is the sum of all the obligations that
were added to oblig(a) as a result of the transac-
tions that sent funds to a prior to t. For example,
for a transaction tj : a → bj in Figure 7 we have

Theorem 2. Suppose that no burn transactions are
processed between the disputed transaction t0 and
the freeze transaction tf . Then when the algorithm
terminates, for every transaction t : a → b we have

ob(b, t) ≤ obsum(a, t)

(4)

Proof. Let us prove the theorem for the graph in Fig-
ure 7. The exact same argument applies to other
graphs. Let Bal(a) be the balance at address a at the
time of the freeze. As usual, let

τ = x0 + . . . + xm.

(5)

Now, ﬁx some j ∈ {1, . . . , m} and let tj be the trans-
action a → bj in Figure 7. Observe that if

τ ≤ Bal(a) +

m
(cid:88)

yi

i=j+1

then ob(bj, tj) = 0 and the theorem follows trivially.
Hence, we can assume that

τ > Bal(a) +

m
(cid:88)

yi.

i=j+1

In this case, by deﬁnition of the loop in Lines (6)
to (9) in the algorithm we know that

ob(bj, tj) =



min

yj,

τ − Bal(a) −



yi

 .

(6)

m
(cid:88)

i=j+1

obsum(a, tj) = x0 + . . . + xj−1

Since no coins were burned at a we know that

The following theorem shows that for a transaction
t : a → b we have ob(b, t) ≤ obsum(a, t). This
means that the obligation passed to b will not exceed
the obligations passed to a due to transactions that
preceded t. In other words, b will not bear responsibil-
ity for an amount transferred to a after transaction t.

m
(cid:88)

i=j

xi ≤ Bal(a) +

m
(cid:88)

yi

i=j+1

and therefore by (6) we obtain

ob(bj, tj) ≤ min(cid:0)yj, τ −

m
(cid:88)

i=j

(cid:1).

xj

16

It now follow by (5) that

References

ob(bj, tj) ≤ x0 + . . . + xj−1 = obsum(a, tj)

as required. This completes the proof.

[1] Sarah Ahmed. Bitgrail hack - one of the largest

crypto hacks in history. link, 2022.

A.4 Preventing double freezes

Consider two transactions v → a0 and a0 → a1
issued in that order, each transferring τ tokens. Sup-
pose, that the ﬁnal balance at a0 is zero and at a1 is 2τ .
Next, suppose v requests to freeze the v → a0 transac-
tion, which will freeze τ tokens at a1. The problem is
that now a0 can request to freeze the a0 → a1 trans-
action. This second request is attempting to again
freeze the τ tokens from v, and should do nothing.
However, our freeze algorithm, as currently described,
will freeze an additional τ tokens at a1.

We brieﬂy describe two ways to prevent double
freezes. First, the judges can recognize the second
freeze as a double freeze and reject this freeze request.
Alternatively, there is a simple modiﬁcation to
the freeze algorithm in Figure 4 that eliminates dou-
ble freezes. Recall that the freeze algorithm in Fig-
ure 4 processes one transaction at a time in the
transaction graph. Every transaction is recorded
in the spenditures data structure shown in Fig-
ure 5. Consider a transaction a → b, and let
S = (to, amount, blockNumber) be the correspond-
ing triple in the spenditures data structure. If the
freeze algorithm obligates b to τ0 ≤ τ tokens due to
this transaction, then the algorithm does two more
steps: ﬁrst, it subtracts τ0 from the amount ﬁeld in the
triple S, and second, it adds the triple (a, index, τ0) to
the claims array for this freeze request. The ﬁrst
step ensures that funds cannot be double frozen. The
second step is needed for the rejectReverse() function.
If the reversal is eventually rejected, then the rejec-
tReverse() function will add τ0 back to the triple S
in the spenditures data structure from which it was
subtracted.

[2] The beacon chain. link, 2018.

[3] Dan Boneh, Saba Eskandarian, Lucjan Hanzlik,
and Nicola Greco. Single secret leader elec-
tion. In Proceedings of the 2nd ACM Confer-
ence on Advances in Financial Technologies,
page 12–24, 2020.

[4] Ed Caesar. How a young couple failed to launder
billions of dollars in stolen bitcoin. link, 2022.

[5] Chainalysis. The 2022 crypto crime report. link,

2022.

[6] Obulapathi N Challa. Reversecoin: Worlds
ﬁrst cryptocurrency with reversible transactions.
link, 2014.

[7] Vishal Chawla. Uniswap liquidity provider
hacked for $8 million in phishing attack. link,
2022.

[8] Evelyn Cheng.

Japanese cryptocurrency ex-
change loses more than $500 million to hackers.
link, 2018.

[9] CryptoSec. Documented timeline of DeFi ex-

ploits. link, 2022.

[10] CryptoSec. Documented timeline of exchange

hacks. link, 2022.

[11] Dean Eigenmann. Reversible token. link, 2018.

[12] Elliptic. Elliptic NFT report 2022 edition: NFTs

and ﬁnancial crime. link, 2022.

[13] Guy Eshet. Refunds for NFTs – the new

ERC721R standard. link, 2022.

17

[14] Sam Kessler. Typo moves $36M in seized
JUNO tokens to wrong wallet. link, 2022.

[15] Olga Kharif, Sidhartha Shukla, and Bloomberg.
Hackers just stole $100 million in crypto from
harmony’s horizon bridge. link, June 2022.

[16] Lossless. Lossless whitepaper. link, 2020.

[17] Malte M¨oser, Ittay Eyal, and Emin G¨un Sirer.
Bitcoin covenants. In Financial Cryptography,
volume 9604 of Lecture Notes in Computer Sci-
ence, pages 126–141. Springer, 2016.

[18] Ronin’s Newsletter. Community alert: Ronin

validators compromised. link, 2022.

[19] Muyao Shen. Hacker moves crypto stolen from
ronin breach to help cover its tracks. link, 2022.

[20] Cryptopedia Staff. What was The DAO? link,

2022.

[21] Smiljanic Stasha. Cryptocurrency hacking statis-

tics: Facts on hacking crypto. link, Feb. 2022.

[22] Chainalysis Team. The kucoin hack: What we
know so far and how the hackers are using DeFi
protocols to launder stolen funds. link, 2020.

[23] Jordan Tuwiner. What was the Mt. Gox hack?

link, 2022.

[24] Fabian Vogelsteller. rICO — the reversible ICO.

Medium, 2020.

[25] Wikipedia contributors. Poly network exploit
— Wikipedia, the free encyclopedia. link, 2022.
[Online; accessed July-2022].

[26] Florian Zandt. Infographic: The biggest crypto

heists. link, 2022.

18

