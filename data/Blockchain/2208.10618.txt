Optimal Bootstrapping of PoW Blockchains
Dimitris Karakostas
University of Edinburgh
UK
d.karakostas@ed.ac.uk

Sreeram Kannan
University of Washington Seattle
USA
ksreeram@uw.edu

Ranvir Rana
University of Illinois Urbana
Champaign
USA
rbrana2@illinois.edu

2
2
0
2

g
u
A
2
2

]

R
C
.
s
c
[

1
v
8
1
6
0
1
.
8
0
2
2
:
v
i
X
r
a

Aggelos Kiayias
University of Edinburgh and IOHK
UK
akiayias@inf.ed.ac.uk

Pramod Viswanath
University of Illinois Urbana
Champaign
USA
pramodv@illinois.edu

ABSTRACT
Proof of Work (PoW) blockchains are susceptible to adversarial
majority mining attacks in the early stages due to incipient par-
ticipation and corresponding low net hash power. Bootstrapping
ensures safety and liveness during the transient stage by protecting
against a majority mining attack, allowing a PoW chain to grow
the participation base and corresponding mining hash power. Live-
ness is especially important since a loss of liveness will lead to
loss of honest mining rewards, decreasing honest participation,
hence creating an undesired spiral; indeed existing bootstrapping
mechanisms offer especially weak liveness guarantees.

In this paper, we propose Advocate, a new bootstrapping method-
ology, which achieves two main results: (a) optimal liveness and low
latency under a super-majority adversary for the Nakamoto longest
chain protocol and (b) immediate black-box generalization to a va-
riety of parallel-chain based scaling architectures, including OHIE
[34] and Prism [4]. We demonstrate via a full-stack implementation
the robustness of Advocate under a 90% adversarial majority.

CCS CONCEPTS
‚Ä¢ Security and privacy ‚Üí Distributed systems security; ‚Ä¢ Com-
puter systems organization ‚Üí Dependable and fault-tolerant
systems and networks; ‚Ä¢ Theory of computation ‚Üí Distributed
algorithms.

ACM Reference Format:
Ranvir Rana, Dimitris Karakostas, Sreeram Kannan, Aggelos Kiayias, and Pramod
Viswanath. 2022. Optimal Bootstrapping of PoW Blockchains. In The
Twenty-third International Symposium on Theory, Algorithmic Foundations,
and Protocol Design for Mobile Networks and Mobile Computing (MobiHoc
‚Äô22), October 17‚Äì20, 2022, Seoul, Republic of Korea. ACM, New York, NY, USA,
10 pages. https://doi.org/10.1145/3492866.3549731

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
MobiHoc ‚Äô22, October 17‚Äì20, 2022, Seoul, Republic of Korea
¬© 2022 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-9165-8/22/10. . . $15.00
https://doi.org/10.1145/3492866.3549731

1 INTRODUCTION
Bootstrapping PoW Blockchains. Proof of Work (PoW) blockchains,
epitomized by Bitcoin, have proven themselves to be secure designs.
Their security has been shown in theory [12] as well as in practice
(Bitcoin has not seen any severe safety or liveness incidents in more
than 13 years of being online). However, an important, and less
studied, aspect of PoW blockchains is that they are particularly
hard to bootstrap. At the early stages of a PoW blockchain, there is
not much participation (in terms of mining hash power), making it
relatively easy for an adversary to overpower the honest miners.
If a PoW blockchain can avoid the dangers of such attacks in its
infancy, eventually a significant amount of honest hashing power
participates in the mining process and security is correspondingly
strengthened. Thus, the focus of this paper is on principled ap-
proaches to secure bootstrapping, a crucial aspect to the successful
development of any PoW blockchain.

1.1 Related Works
Checkpointing. Checkpointing is a standard technique used in state
machine replication protocols [7], where a centralized server is-
sues checkpoints attesting to the recent state of the protocol. In
blockchains, checkpoints attest to the hash of well-embedded blocks
every so often so that new users can securely bootstrap using a
recent execution state of the protocol. A key benefit of such check-
pointing is that an adversary even with super-majority mining
power cannot create a long-range reversion attack (i.e., forking
from a block created long ago). Since such a long-range fork will
deviate from the stated checkpoint, clients will reject them. Prac-
tical blockchains utilizing checkpointing include Bitcoin [23, 24],
Peercoin [18], Feathercoin [14], and RSK [20]. A centralized check-
pointing mechanism was maintained by Satoshi Nakamoto them-
self (presumably honest) until late 2014. Additionally, checkpoints
of some form have been central in the context of Proof-of-Stake
(PoS) protocols, including Ouroboros [17], Snow White [9], and
Ouroboros Praos [10], as well as e.g. in hybrid consensus [27],
Thunderella [28], ByzCoin [19], and Algorand [13]. In a related
context, Fantomette [3] employs distributed checkpoints to secure
a blockDAG-based ledger.

Finality Gadgets: A crucial problem in the context of checkpoint-
ing is ensuring the safe delivery of checkpoints to the blockchain
client. A new generation of blockchain algorithms have sought to

 
 
 
 
 
 
MobiHoc ‚Äô22, October 17‚Äì20, 2022, Seoul, Republic of Korea

Ranvir Rana, Dimitris Karakostas, Sreeram Kannan, Aggelos Kiayias, and Pramod Viswanath

decentralize this process by designing a separate distributed con-
sensus protocol to issue checkpoints. We will refer to this class of
solutions as finality gadgets, which are comprised of a Byzantine
Fault Tolerant (BFT) protocol for finalizing blocks created by a
Proof-of-work (PoW) or Proof-of-stake (PoS) chain protocol. They
have become very popular methods for combining the best features
of the BFT and PoW protocols and are proposed for deployment in
many major blockchains including Ethereum 2.0 [29, 32]. Depend-
ing on the context, the checkpoint committee can be comprised of
a fixed committee (for example, run by independent community
leaders) or the committee itself can be elected using stake deposits.
Rationale for Finality Gadgets. There are multiple reasons for
utilizing finality gadgets, and different protocols emphasize dif-
ferent properties. We enumerate the properties that motivate the
development of finality gadgets as follows.

(1) Safety against long-range attacks;
(2) Economic finality;
(3) Availability vs Finality tradeoff capability;
(4) Responsiveness: low-latency block confirmation;

The raison d‚Äôetre of finality-gadgets (including centralized check-
points) is to provide property (1): safety against long-range attacks
by an adversarial majority. In a PoW system, this is an important
safeguard since an adversary can control a super-majority mining
power temporarily, for example, by renting cloud mining equip-
ment. Finality gadgets and checkpoints can prevent such attacks.
Beyond this basic reason, different protocols optimize for differ-
ent criterion. Casper [5, 6] focuses on (2) that ensures that if safety
is violated, the malicious action is detected and at least one-third of
the staking nodes will lose their stake, a similar approach is taken
by GRANDPA [32] and Afgjort [11]. Recent works [8, 31] have iden-
tified general BFT protocols which have such detectability. Some
protocols like [25, 30] focus on (3) by designing gadgets that let
users prioritize adaptivity or availability by implementing different
confirmation rules. Some protocols like Winkle [2] guarantee (1) by
utilizing transaction traffic for voting. Finally, other finality gadgets
(e.g. Afgjort [11]) are optimized for property (4): responsiveness,
the ability of the BFT to confirm blocks produced by the PoW chain
near-instantaneously.

Bootstrapping gadget: A bootstrapping gadget is a finality gadget
that has one additional property: Liveness despite adversarial
majority. During the initial stages of a novel PoW protocol, live-
ness is required to ensure that honest miners are rewarded for their
effort even under an adversarial majority. Lack of a live checkpoint-
ing protocol creates an undesired spiral: low honest participation
‚Üí low honest miner rewards ‚Üí honest miners leaving (lower
participation).

1.2 Motivation and contributions
Key shortcoming of existing solutions. While all the aforementioned
protocols satisfy several properties of finality gadgets, none of
them can work as bootstrapping gadgets. This was observed in a
recent paper [15] for even the simple centralized checkpointing
protocol. An adversary controlling a majority mining power can
issue a long private adversarial chain, which does not contain any
honest transactions. When such a chain is checkpointed repeatedly,
honest clients lose liveness in the system. The paper proposed the

ùõΩ = 0.5

y
t
i
l
a
u
q
n
i
a
h
C

Adversary mining power: ùõΩ

Figure 1: Chain quality (CQ) of fruitchains deteriorates to 0
when ùõΩ > 0.5; an upper bound on CQ of previous work [15]
deteriorates rapidly with epoch length and ùõΩ; CQ of Advocate
is optimal.

inclusion of a random nonce as well as a checkpoint certificate
(issued by the central checkpointer or BFT) to reduce the impact of
this attack. The key idea is that since this random nonce needs to be
included in the next block, this creates a renewal event where the
adversarial blocks stored prior to the event have to be disregarded,
creating a new race between the honest and adversarial chains at
each checkpoint. While this approach can ensure a non-zero chance
that the honest chain can win, thus giving asymptotic liveness, the
latency of transaction inclusion as well as the chain quality (fraction
of honest blocks in the final ledger) and the corresponding mining
rewards for honest miners decrease exponentially as mining power
increases beyond 50% or as the inter-checkpoint interval increases.
Main Contributions. In this paper, we focus on building a boot-
strapping gadget that achieves safety and liveness under an adver-
sarial majority. We propose Advocate, a new scheme that achieves
optimal chain quality. The core idea is the inclusion of appropriate
reference links to checkpoint blocks. Variations of this idea have
been proposed in different contexts in the literature: in [12] for
achieving a 1/2 threshold Byzantine Agreement, in Fruitchains [26]
for designing incentives, in inclusive protocols [21] for minimizing
block wastage due to forking and in general DAG (directed acyclic
graph) protocols, such as Conflux [22], for improving throughput.
We prove that Advocate achieves optimal chain quality while en-
suring transaction inclusion for all honest transactions within two
epochs even under an arbitrarily high adversarial mining power
(the so-called ‚Äú99% mining adversary‚Äù). The plots for chain quality
of related works are in Figure 1; an upper bound on the chain qual-
ity of [15] diminishes rapidly with adversarial power (ùõΩ) and epoch
size (ùëí), whereas Advocate achieves the optimal chain quality equal
to the honest mining power (1 ‚àí ùõΩ).

General applicability. We create appropriate blackbox interfaces
through which our protocol can employ any BFT protocol for
checkpointing, to make our construction widely applicable. We

0.00.20.40.60.81.00.00.20.40.60.81.0AdvocateFruitchain[16] (e=10)[16] (e=100)Optimal Bootstrapping of PoW Blockchains

MobiHoc ‚Äô22, October 17‚Äì20, 2022, Seoul, Republic of Korea

also demonstrate that our bootstrapping gadget Advocate work
with a variety of PoW protocols beyond Nakamoto consensus.

System Implementation. We perform extensive experiments on a
distributed testbed to demonstrate the robustness of our protocol
under and up to 90% adversarial mining majority and compare
performance gains with prior state-of-the-art. To demonstrate com-
patibility of Advocate with high throughput parallel-chain archi-
tectures, we implemented Advocate on Prism and demonstrated an
honest throughput of 8,200 tx/s under a 70% adversarial majority.
The code for the systems implementation is available at [1].

Organization. The rest of the paper is organized as follows. Sec-
tion 2 provides an overview of the preliminaries used in our work
including the threat model and the distributed ledger‚Äôs properties
and block production mechanisms. Section 3 describes Advocate
under a single checkpointing node and provides its security analy-
sis to show safety and liveness with optimal chain quality. Section
4 extends Advocate to ensure similar performance and security
guarantees under a committee-based BFT-SMR protocol by provid-
ing a unified network functionality. Section 5 integrates Advocate
into parallel-chain architectures by providing a meta-protocol that
can be readily integrated into Prism, OHIE and ledger-combiner to
achieve high throughput under an adversarial majority. Section 6
presents detailed experimental results on a distributed testbed of a
full-stack implementation, stress testing performance with majority
adversarial mining power.

2 PRELIMINARIES
2.1 The Distributed Ledger Model
The distributed ledgers analyzed in this work are constructed as
blockchains. A ledger is formed as a hash chain (or tree) of blocks,
each block containing transactions which alter the ledger‚Äôs state.
New blocks, which extend the chain, are created by mining parties
at regular intervals. Conflicts, i.e., forks in the chain, are resolved
following Sybil resilience mechanisms, such as PoW. Given a tree
of blocks, each party chooses a single branch as the main chain;
blocks that are not part of the main chain are called uncles.

We assume a synchronous setting with a delay upper bound of Œî.
Specifically, the execution proceeds in rounds. On each round, every
party is activated to participate in the protocol. Communication
is performed via a ‚Äúdiffuse‚Äù functionality, i.e., a gossip protocol,
such that no point-to-point communication channels exist, but
rather a peer-to-peer network is formed. Therefore, every message
produced at round ùëü is received by all other parties by round ùëü + 1.
We also assume that the number of participating parties is fixed for
the duration of the execution.

The ledger‚Äôs core properties, described in detail by the Bitcoin

Backbone model [12], are provided in Definitions 2.1-2.3.

Definition 2.1 (Stable Block and Transaction). A block is stable if
it is ùëò-deep in the main chain. A transaction published in a stable
block is also stable.

Definition 2.2 (Safety). A transaction reported as stable by an
honest party on round ùëü is reported as stable by all honest parties
on round ùëü + 1, at the same position in the ledger.

Definition 2.3 (Liveness). A transaction which is provided con-

tinuously as input to the parties becomes stable after ùë¢ rounds.

An additional important property of interest is chain quality
(Definition 2.4) [12, 16]. Briefly, this property ensures that the num-
ber of blocks that each party contributes to the chain is bounded
by a function of the party‚Äôs mining power ùúá.

Definition 2.4 (Chain Quality (ùëû, ùëô)). Let ùëû be the proportional
mining power of A. Chain quality with parameter ùëô states that for
any honest party P with chain C, it holds that, for any ùëô consecutive
blocks of C, the ratio of adversarial blocks is at most 1 ‚àí ùëû.

2.2 Threat Model
Our work considers polynomial-time executions, such that all par-
ties, including the adversary A, are locally polynomial-bounded.
On each execution round, the adversary may ‚Äúcorrupt‚Äù a party, at
which point it accesses the party‚Äôs internal state; following, when
the corrupted party is supposed to be activated, the adversary is
activated instead. Additionally, A is ‚Äúadaptive‚Äù, i.e., corrupts parties
on the fly, and ‚Äúrushing‚Äù, i.e., retrieves all honest parties‚Äô messages
before deciding its strategy at each round.

A controls ùúá A of the network‚Äôs mining power and tries to break
safety and liveness. To break safety, A forces two non-corrupted
nodes to accept different chains as stable, i.e., to report different
transactions as stable in the same position in their respective ledger.
To break liveness, A attempts to prevent a transaction from becom-
ing stable within ùë¢ rounds. We explore settings where the honest
majority assumption is violated, i.e., when the adversary may con-
trol more than 1/2 of the net mining power. In those settings, the
ledger cannot be secure in a standalone fashion, hence the need for
the checkpointing protocols presented in this work.

3 ADVOCATE: OPTIMAL CHECKPOINTING OF

LONGEST CHAIN PROTOCOLS

Our main contribution is a novel protocol, Advocate, that ensures
both safety and liveness against a (arbitrarily high) super-majority
mining adversary on the PoW chain. This section considers a single
(honest) checkpointing node, in order to clearly present the main
innovations, while the following sections relax this assumption by
proposing a distributed checkpointing federation.

Checkpointing in Advocate is performed via certificates. Specifi-
cally, at regular intervals of ùëí blocks on the main chain, the check-
pointing service issues a signed certificate, which is published on
the chain within ùëê blocks on the main chain (PoW chain). The certifi-
cate defines the canonical chain that parties should adopt. Advocate
is parameterized by two values ùëê and ùëí as described above.

3.1 Checkpointing Party Behavior
The checkpointing party is connected to the blockchain network,
so at each round ùë° it holds a view of the PoW chain. Therefore, on
any round, the checkpointing party maintains a list of leaves L (ùë°)
of its local block-tree.

At regular intervals (i.e., every ùëí blocks), the party issues a check-
point certificate. The ùëñ-th checkpoint certificate issued by the party
is denoted ùê∂ùëñ . A checkpoint certificate is constructed as follows:
ùê∂ùëñ = {ùêµùëñ, Rùëñ, ùëÜùëñ }; ùêµùëñ is the checkpointed block, i.e., the block of the
main PoW chain that the party checkpoints; Rùëñ is a list of refer-
ences of blocks that are not part of the main chain, i.e., leaves of
the block tree which are not checkpointed; ùëÜùëñ is the signature of the

MobiHoc ‚Äô22, October 17‚Äì20, 2022, Seoul, Republic of Korea

Ranvir Rana, Dimitris Karakostas, Sreeram Kannan, Aggelos Kiayias, and Pramod Viswanath

certificate. The initial, bootstrapping certificate is ùê∂0 = {0, {0}, ùëÜ0}.
For the rest of the paper, a checkpointed block is a block which is
referenced in a checkpointing certificate.

3.2 Main Chain behavior
With the introduction of checkpoints, the PoW node behavior needs
to change appropriately. The key change is that, once a new cer-
tificate checkpoints block ùêµùëñ , it should be published in at least one
of the ùëê blocks that immediately extend ùêµùëñ ; the first block that in-
cludes the certificate is called the referring block. The nodes follow
the longest checkpointed chain. In summary, Advocate modifies the
main-chain rule as follows:

‚Ä¢ Go to ùêµùëñ in the blocktree.
‚Ä¢ If there exists a descendant block ùêµùëü

ùëñ within ùëê blocks of ùêµùëñ
that contains ùê∂ùëñ , pick the longest chain which contains ùêµùëü
ùëñ
as the main chain. (Note: A block ùêµùëü
ùëñ which contains ùê∂ùëñ but is
more than ùëê blocks after ùêµùëñ is not acceptable.)

‚Ä¢ If no such ùêµùëü
(1) ùêµùëñ is not ùëê-deep in the longest chain: pick the longest chain

ùëñ exists, then either of the following holds:

containing ùêµùëñ as the main-chain.

(2) ùêµùëñ is ùëê-deep in the longest chain: pick one of the chains
which is (ùëê ‚àí 1)-deep and contains ùêµùëñ as the main chain
(breaking ties arbitrarily).

Mining behavior Miners follow the above main chain rules. Ad-
ditionally, w.r.t. a checkpoint certificate ùê∂ùëñ , two cases exist:

(1) the main chain contains ùê∂ùëñ in some block ùêµùëü

ùëñ : proceed mining

as usual.

(2) the main chain does not contain ùê∂ùëñ : include ùê∂ùëñ alongside the

list of transaction to be mined.

We suppose that when a miner creates a new block, the block
contains all transactions in the miner‚Äôs mempool (in practice, this
requires sufficiently incentivized transactions fees). With hindsight,
this assumption will prove useful to argue that a transaction is
published in the first honestly-generated block that is produced
after the transaction‚Äôs creation.

Let main chain oracle ùêπùëöùëêùëú represent the view in the execution
of the underlying consensus algorithm (Nakamoto) and the public
global tree ùê∫ùë° at time ùë° is received by time ùë° +Œî (by the synchronous
network assumption). The main chain oracle gets the additional
checkpointing information from Advocate . The interaction of a
main chain oracle (ùêπùëöùëêùëú ) with the Advocate functionality can be
formalized using a functionality ùêπAdvocate described next.

Advocate ùêπùê¥ùëëùë£ùëúùëêùëéùë°ùëí

ùêπAdvocate and ùêπùëöùëêùëú interact using various push-pull mes-
sages as described bellow; message delay is considered zero
since both the modules use the same machine

(1) potentialCandidate: ùêπùëöùëêùëú sends this message as soon as
it receives a new block ùêµùëõ that satisfies the checkpoint
criteria

(2) candidateFinalized: ùêπAdvocate sends this message as soon
as it receives a new checkpointing certificate Cùëõ
(3) sendReferences: On receiving a a potential candidate,
ùêπAdvocate immediately checks with the ùêπùëöùëêùëú to see if

there are any unreferred uncle blocks; ùêπùëöùëêùëú replies
immediately with unreferredBlocks

(4) isCertValid: On receiving a checkpoint certificate Cùëõ on
the main chain, ùêπùëöùëêùëú immediately requests ùêπAdvocate
to check if it‚Äôs valid (correct signatures, etc.); ùêπAdvocate
immediately replies in boolean using certValidity.
(5) isValidBlock: Triggered when ùêπAdvocate receives a new
checkpoint certificate; it sends the above message with
block hashes to the main chain oracle, to see if those
blocks are valid. The main chain oracle replies with
validBlock

(6) validBlock: Response to the above; if ùêπùëöùëêùëú has not re-
ceived the block yet, it waits for Œî before the reply. If
the block is not yet received or is invalid due to main
chain consensus protocol, it replies False, else it replies
True.

(7) certRequest A query to the certificate database stored
by ùêπAdvocate, the response requestedCert is immediate.

Note that all the interactions between ùêπùëéùëëùë£ùëúùëêùëéùë°ùëí and ùêπùëöùëêùëú are
immediate except for isValidBlock which has a maximum delay of
Œî; the synchronous network delay bound.

The checkpointing party maintains the same functionalities ùêπùëöùëêùëú
and ùêπùê¥ùëëùë£ùëúùëêùëéùë°ùëí with an additional checkpointing service functional-
ity ùêπùëêùëùùë† .

Checkpointing module ùêπùëêùëùùë†
ùêπùëêùëùùë† receives the checkpointCandidate and unreferredBlocks
in the form of inputValue message from ùêπùê¥ùëëùë£ùëúùëêùëéùë°ùëí . This mes-
sage takes zero delay once ùêπùê¥ùëëùë£ùëúùëêùëéùë°ùëí receives potentialCandi-
date from ùêπùëöùëêùëú . ùêπùëêùëùùë† queries ùêπùê¥ùëëùë£ùëúùëêùëéùë°ùëí regarding the validity
of this input using the isInputValid and inputValidity mes-
sages and gets a reply after a delay ùë°ùëêùëùùë† . If the input is valid,
ùêπùëêùëùùë† immediately certifies the input and sends the message to
ùêπùê¥ùëëùë£ùëúùëêùëéùë°ùëí .

Note that the above process will happen within a time ùë°ùëêùëùùë† with
ùë°ùëêùëùùë† /Œî ‚â™ 1, since the process is in the same machine. The message
isInputValid and inputValidity seems redundant for now, however,
we will see in section 4, that this message classification is critical.

3.3 Decoupled Validity: Ledger Creation
Without loss of generality, we assume that the execution completes
with the issuing of a final checkpoint. To construct the aggregate
ledger at any point of the execution, the blocks of the main chain
are concatenated with the blocks of the non-main branches. In the
aggregate ordering, the main chain blocks, up to and including the
referring block (i.e., the block which includes the checkpointing
certificate), are prioritized over the blocks which are not part of the
main chain (i.e., the ‚Äúuncle‚Äù blocks).

Formally, let ùëá (Lùëñ ) be the tree corresponding to the leaves Lùëñ .
Let the forest ùêπùëñ be the difference between ùëá (Lùëñ ) and the previously
checkpointed tree: ùêπùëñ := ùëá (Lùëñ ) \ {ùëá (Lùëñ‚àí1) ‚à™Chainùëñ }, where Chainùëñ
is the main chain up to (and including) the referring block for
checkpoint ùê∂ùëñ . ùúã (¬∑) denotes a topological sort of the blocks in a
forest, with ties broken in a universal manner (e.g. via block hashes).

Optimal Bootstrapping of PoW Blockchains

MobiHoc ‚Äô22, October 17‚Äì20, 2022, Seoul, Republic of Korea

Theorem 3.1 (Safety). Let ùêµ be a block which is checkpointed
by Advocate via certificate ùê∂. If ùêµ is part of the main chain, then ùêµ
is stable (cf. Definition 2.1). If ùêµ is an uncle, then ùêµ is stable if ùê∂ is
published in a block which is ùëò-deep, with ùëò = ùëí ‚àí ùëê.

Proof: Let ùê∂ùëñ = {ùêµùëñ, Rùëñ, ùëÜùëñ } be the ùëñ-th certificate and ùêµ a block
checkpointed by ùê∂ùëñ . By definition of the protocol, all honest parties
eventually accept a chain which contains a referring block ùêµùê∂
which contains ùê∂ùëñ . Observe that, once ùê∂ùëñ is created, the ledger
position of ùêµùëñ is finalized, given the ledger construction description
in Section 3.3. Therefore, if ùêµ is part of the main chain, its ledger
position is also fixed as soon as ùê∂ùëñ is created. If ùêµ is an uncle, then
its ledger position depends on the referring block ùêµùê∂ . Specifically,
the ledger construction rules enforce that the uncle blocks which
are checkpointed by ùê∂ùëñ are appended in the final ledger after the
referring block for ùê∂ùëñ . However, a referring block can be reverted, if
a chain appears which is both valid (i.e., contains a correct referring
block) and long enough. Therefore, the position of uncle blocks,
which are checkpointed by ùê∂ùëñ , is finalized only when the certificate
ùê∂ùëñ+1 is issued, which occurs after at most ùëí ‚àíùëê main chain blocks. ‚ñ°

Theorem 3.2 (Liveness). Let ‚Ñé be the probability that at least
one honest block is created per round; Advocate satisfies liveness (cf.
Definition 2.3) with parameter ùë¢ = ‚åà 2

‚Ñé ‚åâ ¬∑ ùëí.

Proof: The proof follows directly from the ledger construction (cf.
Section 2.1) and Theorem 3.1. Specifically, let ùë° be the round on when
block ùêµ is created. If ùêµ is a main chain block, then it becomes stable
with the issuing of the first checkpoint after ùë° which, by definition of
the checkpointing behavior (Section 3.1), occurs at most ùëí
rounds
‚Ñé
after ùë°. If ùêµ is an uncle block then, as shown in Theorem 3.1, it
becomes stable with the issuing of the first checkpoint after ùêµ
becomes checkpointed; in other words, ùêµ becomes stable when
2 checkpoints are issued after it is created. However, the chain
growth depends at worst on the honest miners‚Äô mining power
(e.g. if the adversary abstains), therefore two checkpoints are issued
on expectation at most ‚åà 2
‚Ñé ‚åâ ¬∑ùëí rounds after ùë°. Finally, as mentioned in
Section 3.2, a transaction is published in the first honestly-generated
block which is produced after the transaction‚Äôs creation. In turn,
this block is checkpointed, either as part of the main chain or as an
uncle block, by the upcoming checkpoint. ‚ñ°

The next property that we explore is chain quality (cf. Defini-
tion 2.4). First, we observe that Advocate cannot guarantee chain
quality over any fixed window of ùëô consecutive blocks of the final
ledger. Briefly, the adversary can produce blocks in private and re-
lease them, such that the checkpoint certificate refers to all of them
at once, hence temporarily flooding the ledger with adversarial
blocks. However, as Theorem 3.3 shows, Advocate does guarantee
chain quality over the entire ledger. This is a direct improvement
of the checkpoint protocol in [15], which guarantees safety and
liveness but not chain quality.

Theorem 3.3 (Chain Quality). Let ùõΩ be the adversarial power.
For every execution, during which ùëô blocks are created in aggregate by
all parties, Advocate satisfies chain quality (cf. Definition 2.4) with
parameters ùëô, (1 ‚àí ùõΩ).

Figure 2: Advocate protocol: 30% honest mining power en-
sures 30% of the blocks in the ledger are mined by honest
miners.

Figure 3: Ledger sanitization ignores/removes invalid trans-
actions post ordering.

The aggregate ledger is constructed by concatenating the referring
block (i.e., Chainùëñ ) with ùúã (ùêπùëñ ). Therefore, when the referring block
for certificate ùê∂ùëñ is read, the blocks referred by ùê∂ùëñ (i.e., the blocks
in ùúã (ùêπùëñ )) are also read in the order defined in ùê∂ùëñ .1 This procedure
is exemplified in figure 2 where Blocks 3,5 are included after block
8. Note that we can follow other universal ordering approaches for
blocks in ùêπùëñ (e.g. sort by hash) without affecting the security of our
protocol.

Figure 2 depicts the ledger construction, s.t. the sanitized ledger
(figure 3) is obtained by parsing the main chain and referenced
blocks and removing invalid (e.g. double spending) entries. Such
post ordering ledger sanitization is required even under a hon-
est setting since referred uncle blocks may have transactions that
conflict with transactions on the main chain.

3.4 Security Properties of Advocate
In this section we show that Advocate, under the centralized setting
of a single honest checkpointing party, satisfies a host of desirable
properties. First and foremost, Theorems 3.1 and 3.2 prove that
Advocate satisfies safety and liveness (cf. Section 2.1).

1We assume that the (honest) checkpointing node follows the universal topological
sorting ùúã when constructing the reference list of certificate ùê∂ùëñ .

Proof: During the entire execution, the honest parties collectively
create (on expectation) at least (1 ‚àí ùõΩ) ¬∑ ùëô blocks. At the end of the

012467835Ledger01246783599Adversarial blockHonest blockCheckpointed blockParent linkReference linkCheckpointing link100124678359ùë°ùë•:	ùê¥‚Üíùêµ:10ùë°ùë•:ùê∂‚Üíùê∑:20ùë°ùë•:ùê¥‚Üíùê∂:15State:ùê¥:10,ùê∂:20State:B:10,ùê∑:20LedgerValid transactionDouble spendSanitizationMobiHoc ‚Äô22, October 17‚Äì20, 2022, Seoul, Republic of Korea

Ranvir Rana, Dimitris Karakostas, Sreeram Kannan, Aggelos Kiayias, and Pramod Viswanath

execution, a checkpoint is issued, which references all main chain
and uncle blocks that are not checkpointed. After the issuing of the
last checkpoint, the aggregate ledger at the end of the execution
contains all blocks created by all parties, hence the ratio of honest
blocks in the final, aggregate ledger is at least 1 ‚àí ùõΩ. ‚ñ°

Advocate with hooks. To achieve chain quality for smaller win-
dows of blocks, we propose a slightly modified version of Advocate.
Now, each block contains a reference to the latest checkpoint certifi-
cate ùê∂ ùëó at the time it was mined. Next, such block can be referenced
by a certificate ùê∂ùëñ only if ùëñ ‚àí ùëó ‚â§ ùë°, i.e., it can be referenced only by
one of the ùë° certificates that immediately follow ùê∂ ùëó . This constraint,
called a hook, prevents A from releasing old blocks.

Theorem 3.4 shows that Advocate with hooks ensures chain qual-
ity for any window of blocks containing ùë° consecutive checkpoints.

Theorem 3.4 (Short Term Chain Quality). Under Advocate
with hooks, the ratio of honest blocks in any window of ùëô consecutive
(1‚àíùõΩ) ¬∑(ùë° ‚àí1)
ùë° +ùõΩ+ùë° ¬∑ùõΩ‚àí1 , where ùõΩ
blocks, which includes ùë° checkpoints, is at least
is the adversarial power.
Proof: Let Œ• be the maximum number of blocks that are produced
on expectation by all parties (honest and adversarial) between
two consecutive checkpoints. Without loss of generality, assume
a window of blocks which begins with the checkpointed block of
certificate ùê∂ùëñ and ends with the checkpointed block of certificate
ùê∂ùëñ+ùë° . ùê∂ùëñ can reference at most ùë° ¬∑ ùõΩ ¬∑ Œ• adversarial blocks (i.e., which
have been created after certificate ùê∂ùëñ‚àíùë° ) and at minimum 0 honest
blocks (i.e., if all honest blocks created between certificates ùê∂ùëñ‚àí1 and
ùê∂ùëñ are part of the main chain). Also, certificate ùê∂ùëñ+ùë° can reference
at most (1 ‚àí ùõΩ) ¬∑ Œ• honest blocks and at minimum 0 adversarial
blocks (i.e., if all honest blocks created between certificates ùê∂ùëñ+ùë° ‚àí1
and ùê∂ùëñ+ùë° are uncle blocks and all such adversarial blocks are part of
the main chain). In this case, the above window of blocks contains
2 ¬∑ ùë° ¬∑ ùõΩ ¬∑ Œ• adversarial blocks and (ùë° ‚àí 1) ¬∑ (1 ‚àí ùõΩ) ¬∑ Œ• honest blocks,
hence the ratio of honest blocks is (1‚àíùõΩ) ¬∑(ùë° ‚àí1)

ùë° +ùõΩ+ùë° ¬∑ùõΩ‚àí1 . ‚ñ°

Finally, we introduce two performance metrics that accentuate
the functionality of Advocate. First, the chain inclusion gap (Defini-
tion 3.5) expresses the expected number of blocks until a new block
is stable. Corollary 3.8 shows that plain Advocate cannot ensure
a chain inclusion gap, whereas Advocate with hooks guarantees
a chain inclusion gap of (ùõΩ ¬∑ ùë° ‚àí ùõΩ + 1) ¬∑ Œ• blocks, where Œ• is the
maximum number of blocks that all parties produce on expectation
between two consecutive checkpoints; the proof follows directly
from Theorems 3.3 and 3.4. We know that the chain grows at the
rate 1 ‚àí ùõΩ; thus, the maximum number of blocks mined between
ùëí
1‚àíùõΩ = Œ•. Observe that the chain inclusion gap
two checkpoints is
increases linearly with Œ• and, consequently, with the epoch length,
this is a direct improvement on the result of [15], where it increases
exponentially under adversarial mining majority.

Definition 3.5 (Chain Inclusion Gap). Let party ùëÉ with a main
chain ùê∂ of length ùëô, which creates a new block ùêµ. The chain inclusion
gap with parameter ùëî states that, when ùêµ becomes stable, its position
in the aggregate ledger is at most ùëô + ùëî.

Corollary 3.6 (Advocate Chain Inclusion Gap). Advocate
guarantees chain inclusion gap (cf. Definition 3.5) with parameter
ùëî = ‚àû. Advocate with hooks guarantees chain inclusion gap with

parameter ùëî = (ùõΩ ¬∑ ùë° ‚àí ùõΩ + 1) ¬∑
ùë° is the hook parameter, and ùëí is the checkpoint epoch length.

ùëí
1‚àíùõΩ , where ùõΩ is the adversarial power,

Second, optimistic serializability (Definition 3.7) ensures that the
checkpointing service does not trivialize the ledger maintenance.
Specifically, under fully honest conditions, i.e., ùõΩ = 0, transactions
are ordered in the ledger in the order of their arrival, if such arrival
order exists.

Definition 3.7 (Optimistic Serializability). For two transactions
ùë°ùë•, ùë°ùë• ‚Ä≤, where ùë°ùë• was given as an input to all honest nodes at round
ùëü and is valid w.r.t. ledger ùêøùëÉ (ùëü ) at round ùëü and ùë°ùë• ‚Ä≤ was given as an
input to all honest parties after round ùëü , it holds that for any ùëü ‚Ä≤ > ùëü ,
the ledger ùêøùëÉ (ùëü ‚Ä≤) of any honest party ùëÉ cannot include ùë°ùë• ‚Ä≤,ùë°ùë• in
this order, given that the network consists of all honest nodes.

Permissionless protocols like Nakamoto longest chain ensures
optimistic serializability and the checkpointing service does not
affect the block ordering; playing a supplementary role. Evidently,
Advocate satisfies optimistic serializability by design.

Corollary 3.8 (Advocate optimistic serializability). Advo-

cate guarantees optimistic serializability (cf. Definition 3.7).

Consider a Nakamoto longest chain protocol; it is easy to show
that it guarantees optimistic serializability. Since the honest nodes
received ùë°ùë• before ùë°ùë• ‚Ä≤, all miners will mine ledger with ùë°ùë• before
ùë°ùë• ‚Ä≤. Even when the ledger is forked, within each fork, the parent is
known and hence the order is maintained for all parties. In Advocate,
it may happen that the certificate refers to a transaction ùë°ùë• again;
hence the ledger ùêøùëÉ (ùëü ) might have transactions ùë°ùë•, ùë°ùë• ‚Ä≤ in that order.
However, since the base consensus is Nakamoto; it will ensure
that ùë°ùë•, ùë°ùë• ‚Ä≤ exists in that order before checkpointing. Thus the ùë°ùë• ‚Ä≤
referred by the checkpoint ùê∂ùëü will be a second occurrence and will
be removed by ledger sanitization.

3.5 Contrast with Fruitchains and Conflux
In terms of safety, the transaction inclusion from ùêπùëñ has similarity
to fruits in Fruitchains [26] and DAG references in the pivot chain
of Conflux [22]. However, we note that if the adversarial mining
power is greater than 50%, the adversary can always beat honest
nodes by creating a mainchain in Fruitchain and a conflicting pivot
chain in Conflux, thus violating safety.

In terms of liveness, Fruitchains has a chain quality of 1 ‚àí ùõΩ,
which is ensured because all blocks created by honest miners are
eventually included as fruits. This chain quality however is reduced
to 0 for ùõΩ > 0.5. To understand this abrupt loss of chain quality, let
us consider an attack by a 51% adversary. The adversary creates a
longer blockchain, consisting of only adversarial blocks, and the
adversarial blocks do not include references to fruits mined by
honest miners. Since the longest blockchain is chosen to create the
fruit ledger, it will not consist of any honest fruits, rendering the
chain quality 0. Similar arguments can be made for a heavier pivot
chain generated by adversaries in Conflux. This abrupt loss of chain
quality for ùõΩ > 0.5 is depicted in Figure 1.

Note that implementing existing checkpointing designs like
Casper to Fruitchains will not will not improve chain quality since
the adversarial majority can ensure that the main chain only con-
tains blocks referring to no honest fruits; hence even the check-
pointed ledger will not contain any honest fruits. Instead, Advocate

Optimal Bootstrapping of PoW Blockchains

MobiHoc ‚Äô22, October 17‚Äì20, 2022, Seoul, Republic of Korea

checkpoints all leaves of the block tree; this achieves optimal chain
quality (Theorem 3) because the final ledger consists of all produced
blocks, where the percentage of adversarial blocks is equal to the
adversarial mining power (the lower bound).

4 ADVOCATE WITH BFT CHECKPOINTING
Although Advocate, as described above, satisfies the desired security
properties, it assumes a single checkpointing node. This central-
ized design is problematic, especially in systems like distributed
ledgers, whose main purpose is decentralization. In this section, we
present Advocate with Byzantine Fault Tolerant (BFT) checkpoint-
ing, which extends the single checkpointing node with a committee
of ùëõ nodes. Although this extension might seem trivial, there are
certain fine points (for example running a BFT-SMR with external
state validation) that need to be analyzed to establish equivalency.
In contrast to other checkpointing protocols, Advocate -BFT allows
multiple checkpointing candidates, since a candidate includes both
the checkpointed block and the reference links, thus increasing the
input space for the BFT committee nodes. The committee achieves
consensus on the contents of the checkpoint certificate, which is
then published on the main chain.

We present a design that optimizes transaction inclusion and
confirmation latency. The adversary A controls up to ùëì committee
nodes, s.t. ùëõ ‚â• 3ùëì + 1, and a fraction ùõΩ ‚àà [0, 1) of the PoW mining
power. Note that the BFT committee is independent from the com-
mittee of miners. Hence, it is possible for the committee of miners
(i.e., a small community for novel PoW chains) to be in adversarial
majority, whereas the BFT committee (consisting of well established
and legally bound validators) is in honest supermajority.

4.1 Advocate-BFT
The committee nodes act as full nodes for the PoW main chain
and run a separate SMR (BFT-based State Machine Replication)
protocol; any generic BFT-SMR protocol should suffice. On receiv-
ing a valid PoW block, the committee node posts a transaction
‚ü®ùêµùëôùëúùëêùëò‚Ñéùëéùë†‚Ñé, ùê∑ùëíùëùùë°‚Ñé‚ü© on the SMR chain, which is finalized after some
rounds as per the BFT-SMR‚Äôs rules.

The SMR chain announces a new checkpoint when a trans-
action containing a block with depth ùëí more than the previous
checkpoint is posted on the SMR chain. A checkpoint transaction
ùë°ùê∂ùëñ = {ùêª (ùêµùëñ ), ùëÄ (ùëÖùëñ )} is posted on the SMR chain, where ùëÖùëñ consists
of all the main chain blocks referenced on the SMR chain between
the references for ùêµùëñ‚àí1 and ùêµùëñ , ùëÄ (ùëÖùëñ ) denotes it‚Äôs Merkle root and
ùêª (ùêµùëñ ) denotes hash of block ùêµùëñ .

The checkpoint certificate ùê∂ùëñ = {{ùë°ùê∂ùëñ }, ùëÖùëñ, ùë§ùëñ } consists of the
checkpoint transaction ùë°ùê∂ùëñ = ùêµùëñ, ùëÄ (ùëÖùëñ ), a witness ùë§ùëñ stating that
it is finalized on the SMR chain, and the list of references ùëÖùëñ . ùê∂ùëñ
should be posted on the PoW chain before the depth of ùëë (ùêµùëñ ) + ùëê,
where ùëë (ùêµùëñ ) is the depth of checkpoint ùêµùëñ .

The SMR chain‚Äôs block inclusion validity rules are as follows:

‚Ä¢ Data availability: The block should be available.
‚Ä¢ Block validity: The block should have valid PoW; note that
full transaction validity is not required due to main chain‚Äôs
ledger sanitization.

‚Ä¢ No checkpoint conflict: The block should not be at a height
of ùëë (ùêµùëñ ) + ùëí and extend a chain that does not contain ùêµùëñ .

Evidently, the BFT checkpointing service realizes in a distributed
manner the checkpointing node of Section 3. Specifically, the BFT
service collects all leaves which are not checkpointed, including
the main chain and uncle blocks, and issues a certificate which
references them. Assuming the BFT protocol is secure (safe and
live), the committee will i) issue a certificate which ii) references all
non-checkpointed blocks, so the analysis of Section 3 also applies
here.

Main chain behavior The main chain miners act as light nodes
for the SMR chain. They include ùê∂ùëñ in the main chain as soon as
ùë°ùê∂ùëñ is finalized on the SMR chain. We assume that the main chain
nodes are connected to at least one honest SMR chain node, to get
the references from ùëÄ (ùëÖùëñ ). The mining behavior and validity rules
including the ùëê constraint on checkpoint inclusion remain the same
as described in Section 3.

Latency To compute the latency for a transaction, let ùúèùëö be the
time until a block ùêµ containing the transaction is mined. Also let ùúèùë°
be the time until a transaction containing the hash of ùêµ is posted on
the SMR chain and ùúèùëì be the time until that transaction is finalized
on the SMR chain. The total time until an honest transaction is
considered for checkpointing is ùúèùëñ = ùúèùëö + ùúèùë° + ùúèùëì . Observe that the
value ùúèùë° is not affected by the adversarial mining fraction. Finally,
the transaction is confirmed when the next checkpoint is posted on
the SMR chain, i.e., after time ùúèùëê until the checkpoint is finalized.
Therefore, the overall latency of a transaction is ùúè = ùúèùëñ + ùúèùëê . We
note that, the parameter ùëê depends on the BFT latency, i.e., Œîùêµùêπùëá .

4.2 BFT integration
We abstract the BFT functionality ùêπùêµùêπùëá and show equivalence with
the checkpointing service ùêπùëêùëùùë† described in Section 3.

BFT-SMR service ùêπùêµùêπùëá

ùêπùêµùêπùëá is a part of a network of ùëÉ replicas participating in
BFT-SMR. ùêπùêµùêπùëá takes an input ùêºùêµùêπùëá and outputs ùëÇùêµùêπùëá after
a delay bounded by Œîùêµùêπùëá . ùêπùêµùêπùëá may take no input and still
output ùëÇùêµùêπùëá depending on the state ùëÜùêµùêπùëá and ùêºùëôùêµùêπùëá : an in-
put received by some replica. ùêπùêµùêπùëá checks validity of ùêºùêµùêπùëá
and/or ùêºùëôùêµùêπùëá with respect to ùëÜùêµùêπùëá stored locally using ùëâùêµùêπùëá .
A message from one replica implementing ùêπùêµùêπùëá to another
takes a maximum delay of Œî.

We now establish an equivalence between ùêπùêµùêπùëá and ùêπùëêùëùùë† . input-
Value in ùêπùëêùëùùë† is equivalent to ùêºùêµùêπùëá in ùêπùêµùêπùëá , while commitDecision is
equivalent to ùëÇùêµùêπùëá . However, a major difference is that the delay be-
tween the two is Œîùêµùêπùëá in ùêπùêµùêπùëá and Œîùëêùëùùë† in ùêπùëêùëùùë† , s.t. Œîùêµùêπùëá /Œîùëêùëùùë† > 1.
Note that Œîùêµùêπùëá is dependent on the liveness parameter ùë¢ of the BFT
protocol. A further major deviation regards to the implementation
of ùëâùêµùêπùëá , which corresponds to the isInputValid and inputValidity
messages in ùêπùëêùëùùë† . Since the state is not in the same module and the
input may be indirectly received from a different replica, the data
needed for validating ùêºùëôùêµùêπùëá may not be available to ùêπùëéùëëùë£ùëúùëêùëéùë°ùëí , thus
returning inputValidity may take unknown time. This is resolved
via a unified network functionality Nùë¢ùëõùëñ (Figure 4) to which each
BFT replica connects.

MobiHoc ‚Äô22, October 17‚Äì20, 2022, Seoul, Republic of Korea

Ranvir Rana, Dimitris Karakostas, Sreeram Kannan, Aggelos Kiayias, and Pramod Viswanath

5 ADVOCATE: CHECKPOINTING FOR

PARALLEL-POW CHAINS

Many emerging PoW blockchains rely on a ‚Äúparallel-chain‚Äù archi-
tecture for scaling, where multiple chains run in parallel and are
aggregated. Two successful parallel-chain architectures are Prism
[4] and OHIE [34]. Although these two protocols are significantly
different from each other, we demonstrate the generalizability of
Advocate; we extend Advocate to both these settings by proposing
a meta-protocol Advocate-PC for integrating Advocate to parallel-
chain architectures. For simplicity, we design Advocate-PC using a
single (honest) checkpointing node, which can be readily extended
to a BFT federation as described in Section 4.

5.1 Advocate-PC: Meta-protocol
Consider ùëÄ parallel chains, with mining power sortition across
if it belongs to branch ùëìùëè of
them. A block is labelled as ùêµùëö,ùëó,ùëìùëè
chain ùëö and has rank ùëó. ùëìùëè is a function of parent of ùêµùëö,ùëó,ùëìùëè
. The
rank R (ùêµùëö,ùëó,ùëìùëè ) = ùëó of a block is determined by the parallel-chain
protocol‚Äôs specifics and is deterministic when a block is mined. We
highlight the first important meta-principle:

Rank criterion: Blocks mined by honest miners have
monotonically increasing rank within a chain.

Block ranks are used to determine epoch intervals with a check-
pointing epoch spanning blocks with a rank-difference of ùëí. We
denote a chain as payload-carrying, denoted by ùëå (ùëñ) = 1 if its blocks
are designed to carry a transaction payload. We set one chain (chain
0) as a base-chain, which may or may not be payload-carrying.

Checkpointing party behavior.

‚Ä¢ Upon receiving Block ùêµ0,ùëó,ùëìùëè

at rank R ( Àúùê∂ùëñ‚àí1) + ùëí, where
Àúùê∂ùëñ‚àí1 is the latest checkpointed base-chain block, it creates a
new checkpoint certificate ùê∂ùëñ , the block ùêµ0,ùëó,ùëìùëè
is the check-
pointed block Àúùê∂ùëñ ;

‚Ä¢ The certificate ùê∂ùëñ = {ùëÖ( Àúùê∂ùëñ ), ùëÖùëñ, Bi} defines: (a) a vector of ùëÄ‚àí
1 parallel-chain blocks Bi, i.e., one tip block from each parallel
chain except the base-chain, (b) the reference list ùëÖùëñ of all
payload-carrying blocks not referenced by any checkpoint
until Rank R ( Àúùê∂ùëñ ), (c) a reference ùëÖ( Àúùê∂ùëñ ) to the checkpointed
base-chain block Àúùê∂ùëñ .

Validity rules.

‚Ä¢ All chains extend the latest checkpoint;
‚Ä¢ A base-chain block is invalid if it extends the chain past rank

R ( Àúùê∂ùëñ ) + ùëê and does not contain ùê∂ùëñ ;

‚Ä¢ A non base-chain is invalid if none of it‚Äôs blocks refer to
the base-chain block containing the certificate ùê∂ùëñ by rank
R ( Àúùê∂ùëñ ) + ùëê;

‚Ä¢ A non base-chain tip block ùêµùëö,ùëó,ùëìùëè

Bi only if chain ùëö has referred to ùê∂ùëñ‚àí1.

is valid for inclusion in

The ledger creation rules are similar to Advocate; the checkpoint
certificate brings in all the referred blocks ùëÖùëñ in the respective
payload-carrying chain‚Äôs ledger.

Advocate-OHIE: We observe that rank in OHIE satisfies the rank
criterion and thus can be treated as R. The meta-protocol can be
integrated into OHIE by setting the chain 0 as base chain and

Figure 4: The network layer of BFT is modified to accommo-
date the external state validation (isInputValid) functional-
ity; the end impact on BFT replica process is equivalent to be-
ing connected to a synchronous network without ùêπùê¥ùëëùë£ùëúùëêùëéùë°ùëí

Unified network functionality Nùë¢ùëõùëñ

Nùë¢ùëõùëñ gets messages from the nodes connected to it. The
message handling is split in 3 levels. The first level is the
Network Handler, which manages network functions like mes-
sage downloading and forwarding. Once the message is down-
loaded, it is passed to the Validity Handler, which verifies the
message w.r.t. a well-defined validity predicate ùëâùêµùêπùëá , which
utilizes isInputValid and inputValidity. Once the checks pass,
the validity handler forwards the message to ùêπùêµùêπùëá , marking
the message as received.

Note that Nùë¢ùëõùëñ ensures that, once a message is received by ùêπùêµùêπùëá ,
checking ùëâùêµùêπùëá is instantaneous, thus replicating a local state. More-
over, Nùë¢ùëõùëñ does not change the synchronous setting delay. Specifi-
cally, let ùëñ be the first honest node to receive a message ùëö at time
ùë°. By definition, ùêπAdvocate sends inputValidity to node ùëñ at some
time ùë° ‚Ä≤ ‚â§ ùë°. Now, the message ùëö propagates across all nodes in a
synchronous manner, hence it is downloaded by each honest node
ùëó at the latest at time ùë° + Œî. Therefore, ùêπùëéùëëùë£ùëúùëêùëéùë°ùëí is queried by node
ùëó regarding isInputValid of ùëö at time ùë° + Œî. Since ùêπAdvocate replied
inputValidity to node ùëñ at time ùë°, it will also reply inputValidity to
ùëó at ùë° + Œî. Thus, ùëö is marked as received by node ùëó by time ùë° + Œî,
ensuring that the network is Œî-synchronous under Nùë¢ùëõùëñ .

Properties of the BFT service

As discussed above, as long as the BFT-SMR protocol is secure,
i.e., satisfies safety and liveness, it securely realizes the single check-
pointing node in a distributed manner. However, our integration
of the federation BFT into checkpoints affects the values of the
parameters ùëê, ùëí. Specifically, ùëê should be at least ùúèùëì /ùúèùëü larger than
in Section 3, ùúèùëì being the time required for a transaction to be final-
ized by the BFT and ùúèùëü being the size of each round of the ledger
protocol. Therefore, faster BFT protocols are preferable, in order to
minimize the time until the checkpoint certificate is finalized.

In the next section, we present a variant of Advocate for multi-

chain systems.

BFT replicaprocessMessagesValidity HandlerGossipNetworkinputValidatorNetworkHandlerOptimal Bootstrapping of PoW Blockchains

MobiHoc ‚Äô22, October 17‚Äì20, 2022, Seoul, Republic of Korea

assigning its protocol defined rank with the Advocate rank R. A
similar extension of the rank criterion works for ledger combiner
as well.

Advocate-Prism: We observe that Prism‚Äôs proposer levels follow
the Rank criterion since honest miners always mine blocks with
increasing proposer levels. We can integrate Advocate-PC by setting
the Proposer chain as the base-chain and assigning proposer level
as Advocate rank R.

6 IMPLEMENTATION AND EVALUATION
We implement Advocate on a codebase in Rust and compare its per-
formance with various existing checkpointing techniques. To test
the performance of Advocate to the limit, we integrate Advocate-
Prism along with the high performance implementation of Prism
written in Rust [33]. We evaluate the performance of Advocate
comparing with various other checkpointing protocols. The code
is available at [1].

6.1 Comparison baselines
We implement two other checkpointing protocols as baselines to
compare performance metrics of Advocate . We briefly describe
these baselines and their integration with Prism below.
Stochastic-checkpointing. Derived from [15], the checkpoint cer-
tificates referring to a single Block-hash(checkpoint) are introduced
in the ledger. The certificates add randomness at every epoch, en-
suring the adversary cannot implement a front-running attack de-
scribed in [15]. Stochastic-checkpointing is implemented by modi-
fying the Advocate ùêπùëêùëùùë† to generate checkpoint without references.
Nakamoto-checkpointing. Derived from the off-chain check-
points published by Nakamoto in the early days of bitcoin (check-
pointing via GitHub). The checkpoints certificates are posted off-
chain and consist of a block‚Äôs hash. The full node codebase recog-
nizes these checkpoints and only considers chains extending these
checkpoints as valid. Nakamoto-checkpointing is implemented by
modifying code for Stochastic-checkpointing not to include the
certificate on chain.
Experimental setup: We run Advocate and Advocate-Prism ex-
periments on c5d.large and c5d.4xlarge AWS instances respectively.
We run our experiments with ùõΩ ‚â• 0.5 with private mining attack
where the adversary mines a private chain and broadcast private
blocks in bursts of epoch length. Our evaluation answers the fol-
lowing questions:

(1) How do performance and security metrics of Advocate com-
pare to state-of-the-art checkpointing and finality gadgets?
(2) How does the performance of Advocate react to a slow check-

pointing service?

(3) How does Advocate perform with large epoch sizes?
(4) How does Advocate integrate with very high throughput
PoW blockchains, e.g., Prism? How is the performance over-
head?

Performance metrics: We use three metrics defined below to
measure performance:

‚Ä¢ Fractional Goodput (ùêπùê∫): Let Goodput (G) be the number
of honest transactions confirmed per unit time and optimal
throughput (T ) be the maximum throughput in the absence
of an adversary. We define fractional goodput as G/T .

‚Ä¢ Ledger Inclusion latency (ùêºùêø): for an honest party ùëÉ is the time
taken (measure in means of block arrival time Œîùê¥) between
transaction generation and inclusion in the ledger of ùëÉ.
‚Ä¢ Honest block wastage (ùêªùëä ): Fraction of honest blocks that

are not part of the ledger.

The performance metrics are tabulated in Tables 1, 2, 3 for a variety
of experimental settings: varying adversary mining power, BFT net-
work latency (Œîùêµùêπùëá ), epoch size. Each experiment was conducted
over a range of 50-100 epochs. We make the following more broad
observations from the data.

(1) We observe that Advocate is far superior to it‚Äôs competitors

in all settings and metrics

(2) Advocate takes a lesser hit on performance as compared to

its competitors if the checkpointing service is slow

(3) ùêºùêø of Advocate increases linearly with epoch length with

minimal drop in its ùêπùê∫

Prism The Prism full-stack implementation can achieve a through-
put of 70K tx/s; coupled with Advocate an optimized implementa-
tion should achieve a throughput of (1 ‚àí ùõΩ) ¬∑ 70ùêæ tx/s. However,
checkpointing adds to the validity rules, leading to loss of through-
put. Our implementation of Advocate-Prism aims to develop a
proof-of-concept, s.t. checkpointing can be integrated into high
throughput parallel chains without much expense of throughput.
To this end, we design an adversary A for Prism who censors hon-
est transaction blocks. For such A with ùõΩ = 0.7, our full-stack
implementation of Advocate-Prism (with UTXO at the application
layer and p2p networking at the networking layer) can achieve a
goodput of 8200 tx/s with a confirmation latency of 120s. While 8200
tx/s with a 70% adversary is much higher than any existing protocol
can achieve, we believe it can be further improved by optimizing
interaction between ledger manager and integrated checkpointing
module, a direction which will be explored in future research.

7 ACKNOWLEDGEMENTS
This research was partly supported by US Army Research Of-
fice Grant W911NF-18-1-0332, National Science Foundation CCF-
1705007, NeTS 1718270, XDC network and IOHK.

REFERENCES
[1] anon. 2021. Advocate System implementation. https://github.com/advocate-

checkpoint/advocate-systems.

[2] Sarah Azouvi, George Danezis, and Valeria Nikolaenko. 2019. Winkle: Foiling
Long-Range Attacks in Proof-of-Stake Systems. Cryptology ePrint Archive,
Report 2019/1440. https://eprint.iacr.org/2019/1440.

[3] Sarah Azouvi, Patrick McCorry, and Sarah Meiklejohn. 2018.

Betting
on Blockchain Consensus with Fantomette. CoRR abs/1805.06786 (2018).
arXiv:1805.06786 http://arxiv.org/abs/1805.06786

[4] Vivek Kumar Bagaria, Sreeram Kannan, David Tse, Giulia C. Fanti, and Pramod
Viswanath. 2019. Prism: Deconstructing the Blockchain to Approach Physical
Limits. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and
Communications Security, CCS 2019, London, UK, November 11-15, 2019, Lorenzo
Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz (Eds.). ACM,
585‚Äì602. https://doi.org/10.1145/3319535.3363213

[5] Vitalik Buterin and Virgil Griffith. 2017. Casper the friendly finality gadget.
[6] Vitalik Buterin, Dani√´l Reijsbergen, Stefanos Leonardos, and Georgios Piliouras.
2019. Incentives in Ethereum‚Äôs Hybrid Casper Protocol. In IEEE International
Conference on Blockchain and Cryptocurrency, ICBC 2019, Seoul, Korea (South),
May 14-17, 2019. IEEE, 236‚Äì244. https://doi.org/10.1109/BLOC.2019.8751241
[7] Miguel Castro and Barbara Liskov. 1999. Practical Byzantine Fault Tolerance.
In Proceedings of the Third USENIX Symposium on Operating Systems Design
and Implementation (OSDI), New Orleans, Louisiana, USA, February 22-25, 1999,

MobiHoc ‚Äô22, October 17‚Äì20, 2022, Seoul, Republic of Korea

ùëí = 5, Œîùêµùêπùëá =0
ùêºùêø
ùêπùê∫
- 2
67.14
6.688
0.204
3.611
0.514
Table 1: Advocate evaluation for ùõΩ = 0.5

Ranvir Rana, Dimitris Karakostas, Sreeram Kannan, Aggelos Kiayias, and Pramod Viswanath
ùëí = 10, Œîùêµùêπùëá =0
ùêºùêø
-
21.53
6.712

ùëí = 5, Œîùêµùêπùëá =2
ùêºùêø
-
13.76
2.546

ùêªùëä
0.7032
0.3539
0

ùêπùê∫
-
0.227
0.475

ùêªùëä
-
0.546
0.048

ùêªùëä
-
0.594
0

ùêπùê∫
0.148
0.323
0.588

Parameters
Metrics
Nakamoto-cp
Stochastic-cp

Advocate

Parameters
Metrics
Nakamoto-cp
Stochastic=cp

Advocate

Parameters
Metrics
Nakamoto-cp
Stochastic-cp

Advocate

ùêπùê∫
0
0.101
0.389

ùëí = 5, Œîùêµùêπùëá =0
ùêºùêø
‚àû
43.11
3.491

ùêπùê∫
- 2
0.033
0.330
Table 2: Advocate evaluation for ùõΩ = 0.67

ùëí = 5, Œîùêµùêπùëá =2
ùêºùêø
-
24.43
3.217

ùêªùëä
1
0.696
0

ùêªùëä
-
0.9
0

ùëí = 10, Œîùêµùêπùëá =0
ùêºùêø
-
‚àû
6.512

ùêπùê∫
-
0
0.311

ùêªùëä
-
1
0.056

ùêπùê∫
0
0
0.102

ùëí = 5, Œîùêµùêπùëá =0
ùêºùêø
‚àû
‚àû
2.849

ùêπùê∫
- 2
0
0.072
Table 3: Advocate evaluation for ùõΩ = 0.9

ùëí = 5, Œîùêµùêπùëá =2
ùêºùêø
-
‚àû
4.319

ùêªùëä
-
1
0.278

ùêªùëä
1
1
0

ùëí = 10, Œîùêµùêπùëá =0
ùêºùêø
-
‚àû
6.467

ùêπùê∫
-
0
0.087

ùêªùëä
-
1
0.13

Margo I. Seltzer and Paul J. Leach (Eds.). USENIX Association, 173‚Äì186. https:
//dl.acm.org/citation.cfm?id=296824

[8] Pierre Civit, Seth Gilbert, and Vincent Gramoli. 2019. Polygraph: Accountable
Byzantine Agreement. Cryptology ePrint Archive, Report 2019/587. https:
//eprint.iacr.org/2019/587.

[9] Phil Daian, Rafael Pass, and Elaine Shi. 2019. Snow White: Robustly Reconfig-
urable Consensus and Applications to Provably Secure Proof of Stake. In Financial
Cryptography and Data Security - 23rd International Conference, FC 2019, Frigate
Bay, St. Kitts and Nevis, February 18-22, 2019, Revised Selected Papers (Lecture Notes
in Computer Science, Vol. 11598), Ian Goldberg and Tyler Moore (Eds.). Springer,
23‚Äì41. https://doi.org/10.1007/978-3-030-32101-7_2

[10] Bernardo David, Peter Gazi, Aggelos Kiayias, and Alexander Russell. 2018.
Ouroboros Praos: An Adaptively-Secure, Semi-synchronous Proof-of-Stake
Blockchain. In Advances in Cryptology - EUROCRYPT 2018 - 37th Annual Interna-
tional Conference on the Theory and Applications of Cryptographic Techniques, Tel
Aviv, Israel, April 29 - May 3, 2018 Proceedings, Part II (Lecture Notes in Computer
Science, Vol. 10821), Jesper Buus Nielsen and Vincent Rijmen (Eds.). Springer,
66‚Äì98. https://doi.org/10.1007/978-3-319-78375-8_3

[11] Thomas Dinsdale-Young, Bernardo Magri, Christian Matt, Jesper Buus Nielsen,
and Daniel Tschudi. 2020. Afgjort: A Partially Synchronous Finality Layer for
Blockchains. In Security and Cryptography for Networks - 12th International Con-
ference, SCN 2020, Amalfi, Italy, September 14-16, 2020, Proceedings (Lecture Notes
in Computer Science, Vol. 12238), Clemente Galdi and Vladimir Kolesnikov (Eds.).
Springer, 24‚Äì44. https://doi.org/10.1007/978-3-030-57990-6_2

[12] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. 2015. The Bitcoin Backbone
Protocol: Analysis and Applications. In Advances in Cryptology - EUROCRYPT
2015 - 34th Annual International Conference on the Theory and Applications of
Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part II
(Lecture Notes in Computer Science, Vol. 9057), Elisabeth Oswald and Marc Fischlin
(Eds.). Springer, 281‚Äì310. https://doi.org/10.1007/978-3-662-46803-6_10
[13] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zel-
dovich. 2017. Algorand: Scaling Byzantine Agreements for Cryptocurrencies.
In Proceedings of the 26th Symposium on Operating Systems Principles, Shanghai,
China, October 28-31, 2017. ACM, 51‚Äì68. https://doi.org/10.1145/3132747.3132757
[14] David Gilson. 2013. Feathercoin secures its block chain with advanced checkpoint-
ing. https://www.coindesk.com/feathercoin-secures-block-chain-advanced-
check-pointing.

[15] Dimitris Karakostas and Aggelos Kiayias. 2020. Securing Proof-of-Work Ledgers
via Checkpointing. Cryptology ePrint Archive, Report 2020/173. https://eprint.
iacr.org/2020/173.

[16] Aggelos Kiayias and Giorgos Panagiotakos. 2017. On Trees, Chains and Fast
Transactions in the Blockchain. In Progress in Cryptology - LATINCRYPT 2017
- 5th International Conference on Cryptology and Information Security in Latin
America, Havana, Cuba, September 20-22, 2017, Revised Selected Papers (Lecture
Notes in Computer Science, Vol. 11368), Tanja Lange and Orr Dunkelman (Eds.).
Springer, 327‚Äì351. https://doi.org/10.1007/978-3-030-25283-0_18

[17] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. 2017.
Ouroboros: A Provably Secure Proof-of-Stake Blockchain Protocol. In Advances
in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference,
Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part I (Lecture Notes in
Computer Science, Vol. 10401), Jonathan Katz and Hovav Shacham (Eds.). Springer,

357‚Äì388. https://doi.org/10.1007/978-3-319-63688-7_12

[18] Sunny King and Scott Nadal. 2012. Ppcoin: Peer-to-peer crypto-currency with

proof-of-stake.

[19] Eleftherios Kokoris-Kogias, Philipp Jovanovic, Nicolas Gailly, Ismail Khoffi, Linus
Gasser, and Bryan Ford. 2016. Enhancing Bitcoin Security and Performance with
Strong Consistency via Collective Signing. In 25th USENIX Security Symposium,
USENIX Security 16, Austin, TX, USA, August 10-12, 2016, Thorsten Holz and
Stefan Savage (Eds.). USENIX Association, 279‚Äì296. https://www.usenix.org/
conference/usenixsecurity16/technical-sessions/presentation/kogias

[20] Sergio Demian Lerner. 2015. RSK White paper Overview. https://docs.rsk.co/

RSK_White_Paper-Overview.pdf.

[21] Yoad Lewenberg, Yonatan Sompolinsky, and Aviv Zohar. 2015. Inclusive block
chain protocols. In International Conference on Financial Cryptography and Data
Security. Springer, 528‚Äì547.

[22] Chenxing Li, Peilun Li, Wei Xu, Fan Long, and Andrew Chi-chih Yao. 2018. Scaling
Nakamoto Consensus to Thousands of Transactions per Second. arXiv preprint
arXiv:1805.03870 (2018).

[23] Satoshi Nakamoto. 2008. Bitcoin: A peer-to-peer electronic cash system.
[24] Satoshi Nakamoto. 2010. Bitcoin 0.3.2 released. https://bitcointalk.org/index.

php?topic=437.msg3807.

[25] Joachim Neu, Ertem Nusret Tas, and David Tse. 2020. Ebb-and-Flow Protocols:
A Resolution of the Availability-Finality Dilemma. Cryptology ePrint Archive,
Report 2020/1091. https://eprint.iacr.org/2020/1091.

[26] R. Pass and E. Shi. 2017. Fruitchains: A fair blockchain. In Proceedings of the ACM

Symposium on Principles of Distributed Computing. ACM.

[27] Rafael Pass and Elaine Shi. 2017. Hybrid Consensus: Efficient Consensus in the
Permissionless Model. In 31st International Symposium on Distributed Computing,
DISC 2017, October 16-20, 2017, Vienna, Austria (LIPIcs, Vol. 91), Andr√©a W. Richa
(Ed.). Schloss Dagstuhl - Leibniz-Zentrum f√ºr Informatik, 39:1‚Äì39:16. https:
//doi.org/10.4230/LIPIcs.DISC.2017.39

[28] Rafael Pass and Elaine Shi. 2018. Thunderella: Blockchains with Optimistic In-
stant Confirmation. In Advances in Cryptology - EUROCRYPT 2018 - 37th Annual
International Conference on the Theory and Applications of Cryptographic Tech-
niques, Tel Aviv, Israel, April 29 - May 3, 2018 Proceedings, Part II (Lecture Notes
in Computer Science, Vol. 10821), Jesper Buus Nielsen and Vincent Rijmen (Eds.).
Springer, 3‚Äì33. https://doi.org/10.1007/978-3-319-78375-8_1

[29] Ethereum Research. 2020. Ethereum 2.0. https://github.com/ethereum/eth2.0-

specs.

[30] Suryanarayana Sankagiri, Xuechao Wang, Sreeram Kannan, and Pramod
Viswanath. 2020. The Checkpointed Longest Chain: User-dependent Adaptivity
and Finality. arXiv:2010.13711 [cs.CR]

[31] Peiyao Sheng, Gerui Wang, Kartik Nayak, Sreeram Kannan, and Pramod

Viswanath. 2020. BFT Protocol Forensics. arXiv:2010.06785 [cs.CR]

[32] Alistair Stewart and Eleftherios Kokoris-Kogia. 2020. GRANDPA: a Byzantine
Finality Gadget. CoRR abs/2007.01560 (2020). arXiv:2007.01560 https://arxiv.org/
abs/2007.01560

[33] L. Yang, V. Bagaria, Gerui Wang, Mohammad Alizadeh, David M. Tse, G. Fanti,
and P. Viswanath. 2019. Prism: Scaling Bitcoin by 10,000x. ArXiv abs/1909.11261
(2019).

[34] Haifeng Yu, Ivica Nikolic, Ruomu Hou, and Prateek Saxena. 2019. OHIE:

Blockchain Scaling Made Simple. arXiv:1811.12628 [cs.DC]

