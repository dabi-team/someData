Optimal Bootstrapping of PoW Blockchains
Dimitris Karakostas
University of Edinburgh
UK
d.karakostas@ed.ac.uk

Sreeram Kannan
University of Washington Seattle
USA
ksreeram@uw.edu

Ranvir Rana
University of Illinois Urbana
Champaign
USA
rbrana2@illinois.edu

2
2
0
2

g
u
A
2
2

]

R
C
.
s
c
[

1
v
8
1
6
0
1
.
8
0
2
2
:
v
i
X
r
a

Aggelos Kiayias
University of Edinburgh and IOHK
UK
akiayias@inf.ed.ac.uk

Pramod Viswanath
University of Illinois Urbana
Champaign
USA
pramodv@illinois.edu

ABSTRACT
Proof of Work (PoW) blockchains are susceptible to adversarial
majority mining attacks in the early stages due to incipient par-
ticipation and corresponding low net hash power. Bootstrapping
ensures safety and liveness during the transient stage by protecting
against a majority mining attack, allowing a PoW chain to grow
the participation base and corresponding mining hash power. Live-
ness is especially important since a loss of liveness will lead to
loss of honest mining rewards, decreasing honest participation,
hence creating an undesired spiral; indeed existing bootstrapping
mechanisms offer especially weak liveness guarantees.

In this paper, we propose Advocate, a new bootstrapping method-
ology, which achieves two main results: (a) optimal liveness and low
latency under a super-majority adversary for the Nakamoto longest
chain protocol and (b) immediate black-box generalization to a va-
riety of parallel-chain based scaling architectures, including OHIE
[34] and Prism [4]. We demonstrate via a full-stack implementation
the robustness of Advocate under a 90% adversarial majority.

CCS CONCEPTS
â€¢ Security and privacy â†’ Distributed systems security; â€¢ Com-
puter systems organization â†’ Dependable and fault-tolerant
systems and networks; â€¢ Theory of computation â†’ Distributed
algorithms.

ACM Reference Format:
Ranvir Rana, Dimitris Karakostas, Sreeram Kannan, Aggelos Kiayias, and Pramod
Viswanath. 2022. Optimal Bootstrapping of PoW Blockchains. In The
Twenty-third International Symposium on Theory, Algorithmic Foundations,
and Protocol Design for Mobile Networks and Mobile Computing (MobiHoc
â€™22), October 17â€“20, 2022, Seoul, Republic of Korea. ACM, New York, NY, USA,
10 pages. https://doi.org/10.1145/3492866.3549731

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
MobiHoc â€™22, October 17â€“20, 2022, Seoul, Republic of Korea
Â© 2022 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-9165-8/22/10. . . $15.00
https://doi.org/10.1145/3492866.3549731

1 INTRODUCTION
Bootstrapping PoW Blockchains. Proof of Work (PoW) blockchains,
epitomized by Bitcoin, have proven themselves to be secure designs.
Their security has been shown in theory [12] as well as in practice
(Bitcoin has not seen any severe safety or liveness incidents in more
than 13 years of being online). However, an important, and less
studied, aspect of PoW blockchains is that they are particularly
hard to bootstrap. At the early stages of a PoW blockchain, there is
not much participation (in terms of mining hash power), making it
relatively easy for an adversary to overpower the honest miners.
If a PoW blockchain can avoid the dangers of such attacks in its
infancy, eventually a significant amount of honest hashing power
participates in the mining process and security is correspondingly
strengthened. Thus, the focus of this paper is on principled ap-
proaches to secure bootstrapping, a crucial aspect to the successful
development of any PoW blockchain.

1.1 Related Works
Checkpointing. Checkpointing is a standard technique used in state
machine replication protocols [7], where a centralized server is-
sues checkpoints attesting to the recent state of the protocol. In
blockchains, checkpoints attest to the hash of well-embedded blocks
every so often so that new users can securely bootstrap using a
recent execution state of the protocol. A key benefit of such check-
pointing is that an adversary even with super-majority mining
power cannot create a long-range reversion attack (i.e., forking
from a block created long ago). Since such a long-range fork will
deviate from the stated checkpoint, clients will reject them. Prac-
tical blockchains utilizing checkpointing include Bitcoin [23, 24],
Peercoin [18], Feathercoin [14], and RSK [20]. A centralized check-
pointing mechanism was maintained by Satoshi Nakamoto them-
self (presumably honest) until late 2014. Additionally, checkpoints
of some form have been central in the context of Proof-of-Stake
(PoS) protocols, including Ouroboros [17], Snow White [9], and
Ouroboros Praos [10], as well as e.g. in hybrid consensus [27],
Thunderella [28], ByzCoin [19], and Algorand [13]. In a related
context, Fantomette [3] employs distributed checkpoints to secure
a blockDAG-based ledger.

Finality Gadgets: A crucial problem in the context of checkpoint-
ing is ensuring the safe delivery of checkpoints to the blockchain
client. A new generation of blockchain algorithms have sought to

 
 
 
 
 
 
MobiHoc â€™22, October 17â€“20, 2022, Seoul, Republic of Korea

Ranvir Rana, Dimitris Karakostas, Sreeram Kannan, Aggelos Kiayias, and Pramod Viswanath

decentralize this process by designing a separate distributed con-
sensus protocol to issue checkpoints. We will refer to this class of
solutions as finality gadgets, which are comprised of a Byzantine
Fault Tolerant (BFT) protocol for finalizing blocks created by a
Proof-of-work (PoW) or Proof-of-stake (PoS) chain protocol. They
have become very popular methods for combining the best features
of the BFT and PoW protocols and are proposed for deployment in
many major blockchains including Ethereum 2.0 [29, 32]. Depend-
ing on the context, the checkpoint committee can be comprised of
a fixed committee (for example, run by independent community
leaders) or the committee itself can be elected using stake deposits.
Rationale for Finality Gadgets. There are multiple reasons for
utilizing finality gadgets, and different protocols emphasize dif-
ferent properties. We enumerate the properties that motivate the
development of finality gadgets as follows.

(1) Safety against long-range attacks;
(2) Economic finality;
(3) Availability vs Finality tradeoff capability;
(4) Responsiveness: low-latency block confirmation;

The raison dâ€™etre of finality-gadgets (including centralized check-
points) is to provide property (1): safety against long-range attacks
by an adversarial majority. In a PoW system, this is an important
safeguard since an adversary can control a super-majority mining
power temporarily, for example, by renting cloud mining equip-
ment. Finality gadgets and checkpoints can prevent such attacks.
Beyond this basic reason, different protocols optimize for differ-
ent criterion. Casper [5, 6] focuses on (2) that ensures that if safety
is violated, the malicious action is detected and at least one-third of
the staking nodes will lose their stake, a similar approach is taken
by GRANDPA [32] and Afgjort [11]. Recent works [8, 31] have iden-
tified general BFT protocols which have such detectability. Some
protocols like [25, 30] focus on (3) by designing gadgets that let
users prioritize adaptivity or availability by implementing different
confirmation rules. Some protocols like Winkle [2] guarantee (1) by
utilizing transaction traffic for voting. Finally, other finality gadgets
(e.g. Afgjort [11]) are optimized for property (4): responsiveness,
the ability of the BFT to confirm blocks produced by the PoW chain
near-instantaneously.

Bootstrapping gadget: A bootstrapping gadget is a finality gadget
that has one additional property: Liveness despite adversarial
majority. During the initial stages of a novel PoW protocol, live-
ness is required to ensure that honest miners are rewarded for their
effort even under an adversarial majority. Lack of a live checkpoint-
ing protocol creates an undesired spiral: low honest participation
â†’ low honest miner rewards â†’ honest miners leaving (lower
participation).

1.2 Motivation and contributions
Key shortcoming of existing solutions. While all the aforementioned
protocols satisfy several properties of finality gadgets, none of
them can work as bootstrapping gadgets. This was observed in a
recent paper [15] for even the simple centralized checkpointing
protocol. An adversary controlling a majority mining power can
issue a long private adversarial chain, which does not contain any
honest transactions. When such a chain is checkpointed repeatedly,
honest clients lose liveness in the system. The paper proposed the

ğ›½ = 0.5

y
t
i
l
a
u
q
n
i
a
h
C

Adversary mining power: ğ›½

Figure 1: Chain quality (CQ) of fruitchains deteriorates to 0
when ğ›½ > 0.5; an upper bound on CQ of previous work [15]
deteriorates rapidly with epoch length and ğ›½; CQ of Advocate
is optimal.

inclusion of a random nonce as well as a checkpoint certificate
(issued by the central checkpointer or BFT) to reduce the impact of
this attack. The key idea is that since this random nonce needs to be
included in the next block, this creates a renewal event where the
adversarial blocks stored prior to the event have to be disregarded,
creating a new race between the honest and adversarial chains at
each checkpoint. While this approach can ensure a non-zero chance
that the honest chain can win, thus giving asymptotic liveness, the
latency of transaction inclusion as well as the chain quality (fraction
of honest blocks in the final ledger) and the corresponding mining
rewards for honest miners decrease exponentially as mining power
increases beyond 50% or as the inter-checkpoint interval increases.
Main Contributions. In this paper, we focus on building a boot-
strapping gadget that achieves safety and liveness under an adver-
sarial majority. We propose Advocate, a new scheme that achieves
optimal chain quality. The core idea is the inclusion of appropriate
reference links to checkpoint blocks. Variations of this idea have
been proposed in different contexts in the literature: in [12] for
achieving a 1/2 threshold Byzantine Agreement, in Fruitchains [26]
for designing incentives, in inclusive protocols [21] for minimizing
block wastage due to forking and in general DAG (directed acyclic
graph) protocols, such as Conflux [22], for improving throughput.
We prove that Advocate achieves optimal chain quality while en-
suring transaction inclusion for all honest transactions within two
epochs even under an arbitrarily high adversarial mining power
(the so-called â€œ99% mining adversaryâ€). The plots for chain quality
of related works are in Figure 1; an upper bound on the chain qual-
ity of [15] diminishes rapidly with adversarial power (ğ›½) and epoch
size (ğ‘’), whereas Advocate achieves the optimal chain quality equal
to the honest mining power (1 âˆ’ ğ›½).

General applicability. We create appropriate blackbox interfaces
through which our protocol can employ any BFT protocol for
checkpointing, to make our construction widely applicable. We

0.00.20.40.60.81.00.00.20.40.60.81.0AdvocateFruitchain[16] (e=10)[16] (e=100)Optimal Bootstrapping of PoW Blockchains

MobiHoc â€™22, October 17â€“20, 2022, Seoul, Republic of Korea

also demonstrate that our bootstrapping gadget Advocate work
with a variety of PoW protocols beyond Nakamoto consensus.

System Implementation. We perform extensive experiments on a
distributed testbed to demonstrate the robustness of our protocol
under and up to 90% adversarial mining majority and compare
performance gains with prior state-of-the-art. To demonstrate com-
patibility of Advocate with high throughput parallel-chain archi-
tectures, we implemented Advocate on Prism and demonstrated an
honest throughput of 8,200 tx/s under a 70% adversarial majority.
The code for the systems implementation is available at [1].

Organization. The rest of the paper is organized as follows. Sec-
tion 2 provides an overview of the preliminaries used in our work
including the threat model and the distributed ledgerâ€™s properties
and block production mechanisms. Section 3 describes Advocate
under a single checkpointing node and provides its security analy-
sis to show safety and liveness with optimal chain quality. Section
4 extends Advocate to ensure similar performance and security
guarantees under a committee-based BFT-SMR protocol by provid-
ing a unified network functionality. Section 5 integrates Advocate
into parallel-chain architectures by providing a meta-protocol that
can be readily integrated into Prism, OHIE and ledger-combiner to
achieve high throughput under an adversarial majority. Section 6
presents detailed experimental results on a distributed testbed of a
full-stack implementation, stress testing performance with majority
adversarial mining power.

2 PRELIMINARIES
2.1 The Distributed Ledger Model
The distributed ledgers analyzed in this work are constructed as
blockchains. A ledger is formed as a hash chain (or tree) of blocks,
each block containing transactions which alter the ledgerâ€™s state.
New blocks, which extend the chain, are created by mining parties
at regular intervals. Conflicts, i.e., forks in the chain, are resolved
following Sybil resilience mechanisms, such as PoW. Given a tree
of blocks, each party chooses a single branch as the main chain;
blocks that are not part of the main chain are called uncles.

We assume a synchronous setting with a delay upper bound of Î”.
Specifically, the execution proceeds in rounds. On each round, every
party is activated to participate in the protocol. Communication
is performed via a â€œdiffuseâ€ functionality, i.e., a gossip protocol,
such that no point-to-point communication channels exist, but
rather a peer-to-peer network is formed. Therefore, every message
produced at round ğ‘Ÿ is received by all other parties by round ğ‘Ÿ + 1.
We also assume that the number of participating parties is fixed for
the duration of the execution.

The ledgerâ€™s core properties, described in detail by the Bitcoin

Backbone model [12], are provided in Definitions 2.1-2.3.

Definition 2.1 (Stable Block and Transaction). A block is stable if
it is ğ‘˜-deep in the main chain. A transaction published in a stable
block is also stable.

Definition 2.2 (Safety). A transaction reported as stable by an
honest party on round ğ‘Ÿ is reported as stable by all honest parties
on round ğ‘Ÿ + 1, at the same position in the ledger.

Definition 2.3 (Liveness). A transaction which is provided con-

tinuously as input to the parties becomes stable after ğ‘¢ rounds.

An additional important property of interest is chain quality
(Definition 2.4) [12, 16]. Briefly, this property ensures that the num-
ber of blocks that each party contributes to the chain is bounded
by a function of the partyâ€™s mining power ğœ‡.

Definition 2.4 (Chain Quality (ğ‘, ğ‘™)). Let ğ‘ be the proportional
mining power of A. Chain quality with parameter ğ‘™ states that for
any honest party P with chain C, it holds that, for any ğ‘™ consecutive
blocks of C, the ratio of adversarial blocks is at most 1 âˆ’ ğ‘.

2.2 Threat Model
Our work considers polynomial-time executions, such that all par-
ties, including the adversary A, are locally polynomial-bounded.
On each execution round, the adversary may â€œcorruptâ€ a party, at
which point it accesses the partyâ€™s internal state; following, when
the corrupted party is supposed to be activated, the adversary is
activated instead. Additionally, A is â€œadaptiveâ€, i.e., corrupts parties
on the fly, and â€œrushingâ€, i.e., retrieves all honest partiesâ€™ messages
before deciding its strategy at each round.

A controls ğœ‡ A of the networkâ€™s mining power and tries to break
safety and liveness. To break safety, A forces two non-corrupted
nodes to accept different chains as stable, i.e., to report different
transactions as stable in the same position in their respective ledger.
To break liveness, A attempts to prevent a transaction from becom-
ing stable within ğ‘¢ rounds. We explore settings where the honest
majority assumption is violated, i.e., when the adversary may con-
trol more than 1/2 of the net mining power. In those settings, the
ledger cannot be secure in a standalone fashion, hence the need for
the checkpointing protocols presented in this work.

3 ADVOCATE: OPTIMAL CHECKPOINTING OF

LONGEST CHAIN PROTOCOLS

Our main contribution is a novel protocol, Advocate, that ensures
both safety and liveness against a (arbitrarily high) super-majority
mining adversary on the PoW chain. This section considers a single
(honest) checkpointing node, in order to clearly present the main
innovations, while the following sections relax this assumption by
proposing a distributed checkpointing federation.

Checkpointing in Advocate is performed via certificates. Specifi-
cally, at regular intervals of ğ‘’ blocks on the main chain, the check-
pointing service issues a signed certificate, which is published on
the chain within ğ‘ blocks on the main chain (PoW chain). The certifi-
cate defines the canonical chain that parties should adopt. Advocate
is parameterized by two values ğ‘ and ğ‘’ as described above.

3.1 Checkpointing Party Behavior
The checkpointing party is connected to the blockchain network,
so at each round ğ‘¡ it holds a view of the PoW chain. Therefore, on
any round, the checkpointing party maintains a list of leaves L (ğ‘¡)
of its local block-tree.

At regular intervals (i.e., every ğ‘’ blocks), the party issues a check-
point certificate. The ğ‘–-th checkpoint certificate issued by the party
is denoted ğ¶ğ‘– . A checkpoint certificate is constructed as follows:
ğ¶ğ‘– = {ğµğ‘–, Rğ‘–, ğ‘†ğ‘– }; ğµğ‘– is the checkpointed block, i.e., the block of the
main PoW chain that the party checkpoints; Rğ‘– is a list of refer-
ences of blocks that are not part of the main chain, i.e., leaves of
the block tree which are not checkpointed; ğ‘†ğ‘– is the signature of the

MobiHoc â€™22, October 17â€“20, 2022, Seoul, Republic of Korea

Ranvir Rana, Dimitris Karakostas, Sreeram Kannan, Aggelos Kiayias, and Pramod Viswanath

certificate. The initial, bootstrapping certificate is ğ¶0 = {0, {0}, ğ‘†0}.
For the rest of the paper, a checkpointed block is a block which is
referenced in a checkpointing certificate.

3.2 Main Chain behavior
With the introduction of checkpoints, the PoW node behavior needs
to change appropriately. The key change is that, once a new cer-
tificate checkpoints block ğµğ‘– , it should be published in at least one
of the ğ‘ blocks that immediately extend ğµğ‘– ; the first block that in-
cludes the certificate is called the referring block. The nodes follow
the longest checkpointed chain. In summary, Advocate modifies the
main-chain rule as follows:

â€¢ Go to ğµğ‘– in the blocktree.
â€¢ If there exists a descendant block ğµğ‘Ÿ

ğ‘– within ğ‘ blocks of ğµğ‘–
that contains ğ¶ğ‘– , pick the longest chain which contains ğµğ‘Ÿ
ğ‘–
as the main chain. (Note: A block ğµğ‘Ÿ
ğ‘– which contains ğ¶ğ‘– but is
more than ğ‘ blocks after ğµğ‘– is not acceptable.)

â€¢ If no such ğµğ‘Ÿ
(1) ğµğ‘– is not ğ‘-deep in the longest chain: pick the longest chain

ğ‘– exists, then either of the following holds:

containing ğµğ‘– as the main-chain.

(2) ğµğ‘– is ğ‘-deep in the longest chain: pick one of the chains
which is (ğ‘ âˆ’ 1)-deep and contains ğµğ‘– as the main chain
(breaking ties arbitrarily).

Mining behavior Miners follow the above main chain rules. Ad-
ditionally, w.r.t. a checkpoint certificate ğ¶ğ‘– , two cases exist:

(1) the main chain contains ğ¶ğ‘– in some block ğµğ‘Ÿ

ğ‘– : proceed mining

as usual.

(2) the main chain does not contain ğ¶ğ‘– : include ğ¶ğ‘– alongside the

list of transaction to be mined.

We suppose that when a miner creates a new block, the block
contains all transactions in the minerâ€™s mempool (in practice, this
requires sufficiently incentivized transactions fees). With hindsight,
this assumption will prove useful to argue that a transaction is
published in the first honestly-generated block that is produced
after the transactionâ€™s creation.

Let main chain oracle ğ¹ğ‘šğ‘ğ‘œ represent the view in the execution
of the underlying consensus algorithm (Nakamoto) and the public
global tree ğºğ‘¡ at time ğ‘¡ is received by time ğ‘¡ +Î” (by the synchronous
network assumption). The main chain oracle gets the additional
checkpointing information from Advocate . The interaction of a
main chain oracle (ğ¹ğ‘šğ‘ğ‘œ ) with the Advocate functionality can be
formalized using a functionality ğ¹Advocate described next.

Advocate ğ¹ğ´ğ‘‘ğ‘£ğ‘œğ‘ğ‘ğ‘¡ğ‘’

ğ¹Advocate and ğ¹ğ‘šğ‘ğ‘œ interact using various push-pull mes-
sages as described bellow; message delay is considered zero
since both the modules use the same machine

(1) potentialCandidate: ğ¹ğ‘šğ‘ğ‘œ sends this message as soon as
it receives a new block ğµğ‘› that satisfies the checkpoint
criteria

(2) candidateFinalized: ğ¹Advocate sends this message as soon
as it receives a new checkpointing certificate Cğ‘›
(3) sendReferences: On receiving a a potential candidate,
ğ¹Advocate immediately checks with the ğ¹ğ‘šğ‘ğ‘œ to see if

there are any unreferred uncle blocks; ğ¹ğ‘šğ‘ğ‘œ replies
immediately with unreferredBlocks

(4) isCertValid: On receiving a checkpoint certificate Cğ‘› on
the main chain, ğ¹ğ‘šğ‘ğ‘œ immediately requests ğ¹Advocate
to check if itâ€™s valid (correct signatures, etc.); ğ¹Advocate
immediately replies in boolean using certValidity.
(5) isValidBlock: Triggered when ğ¹Advocate receives a new
checkpoint certificate; it sends the above message with
block hashes to the main chain oracle, to see if those
blocks are valid. The main chain oracle replies with
validBlock

(6) validBlock: Response to the above; if ğ¹ğ‘šğ‘ğ‘œ has not re-
ceived the block yet, it waits for Î” before the reply. If
the block is not yet received or is invalid due to main
chain consensus protocol, it replies False, else it replies
True.

(7) certRequest A query to the certificate database stored
by ğ¹Advocate, the response requestedCert is immediate.

Note that all the interactions between ğ¹ğ‘ğ‘‘ğ‘£ğ‘œğ‘ğ‘ğ‘¡ğ‘’ and ğ¹ğ‘šğ‘ğ‘œ are
immediate except for isValidBlock which has a maximum delay of
Î”; the synchronous network delay bound.

The checkpointing party maintains the same functionalities ğ¹ğ‘šğ‘ğ‘œ
and ğ¹ğ´ğ‘‘ğ‘£ğ‘œğ‘ğ‘ğ‘¡ğ‘’ with an additional checkpointing service functional-
ity ğ¹ğ‘ğ‘ğ‘  .

Checkpointing module ğ¹ğ‘ğ‘ğ‘ 
ğ¹ğ‘ğ‘ğ‘  receives the checkpointCandidate and unreferredBlocks
in the form of inputValue message from ğ¹ğ´ğ‘‘ğ‘£ğ‘œğ‘ğ‘ğ‘¡ğ‘’ . This mes-
sage takes zero delay once ğ¹ğ´ğ‘‘ğ‘£ğ‘œğ‘ğ‘ğ‘¡ğ‘’ receives potentialCandi-
date from ğ¹ğ‘šğ‘ğ‘œ . ğ¹ğ‘ğ‘ğ‘  queries ğ¹ğ´ğ‘‘ğ‘£ğ‘œğ‘ğ‘ğ‘¡ğ‘’ regarding the validity
of this input using the isInputValid and inputValidity mes-
sages and gets a reply after a delay ğ‘¡ğ‘ğ‘ğ‘  . If the input is valid,
ğ¹ğ‘ğ‘ğ‘  immediately certifies the input and sends the message to
ğ¹ğ´ğ‘‘ğ‘£ğ‘œğ‘ğ‘ğ‘¡ğ‘’ .

Note that the above process will happen within a time ğ‘¡ğ‘ğ‘ğ‘  with
ğ‘¡ğ‘ğ‘ğ‘  /Î” â‰ª 1, since the process is in the same machine. The message
isInputValid and inputValidity seems redundant for now, however,
we will see in section 4, that this message classification is critical.

3.3 Decoupled Validity: Ledger Creation
Without loss of generality, we assume that the execution completes
with the issuing of a final checkpoint. To construct the aggregate
ledger at any point of the execution, the blocks of the main chain
are concatenated with the blocks of the non-main branches. In the
aggregate ordering, the main chain blocks, up to and including the
referring block (i.e., the block which includes the checkpointing
certificate), are prioritized over the blocks which are not part of the
main chain (i.e., the â€œuncleâ€ blocks).

Formally, let ğ‘‡ (Lğ‘– ) be the tree corresponding to the leaves Lğ‘– .
Let the forest ğ¹ğ‘– be the difference between ğ‘‡ (Lğ‘– ) and the previously
checkpointed tree: ğ¹ğ‘– := ğ‘‡ (Lğ‘– ) \ {ğ‘‡ (Lğ‘–âˆ’1) âˆªChainğ‘– }, where Chainğ‘–
is the main chain up to (and including) the referring block for
checkpoint ğ¶ğ‘– . ğœ‹ (Â·) denotes a topological sort of the blocks in a
forest, with ties broken in a universal manner (e.g. via block hashes).

Optimal Bootstrapping of PoW Blockchains

MobiHoc â€™22, October 17â€“20, 2022, Seoul, Republic of Korea

Theorem 3.1 (Safety). Let ğµ be a block which is checkpointed
by Advocate via certificate ğ¶. If ğµ is part of the main chain, then ğµ
is stable (cf. Definition 2.1). If ğµ is an uncle, then ğµ is stable if ğ¶ is
published in a block which is ğ‘˜-deep, with ğ‘˜ = ğ‘’ âˆ’ ğ‘.

Proof: Let ğ¶ğ‘– = {ğµğ‘–, Rğ‘–, ğ‘†ğ‘– } be the ğ‘–-th certificate and ğµ a block
checkpointed by ğ¶ğ‘– . By definition of the protocol, all honest parties
eventually accept a chain which contains a referring block ğµğ¶
which contains ğ¶ğ‘– . Observe that, once ğ¶ğ‘– is created, the ledger
position of ğµğ‘– is finalized, given the ledger construction description
in Section 3.3. Therefore, if ğµ is part of the main chain, its ledger
position is also fixed as soon as ğ¶ğ‘– is created. If ğµ is an uncle, then
its ledger position depends on the referring block ğµğ¶ . Specifically,
the ledger construction rules enforce that the uncle blocks which
are checkpointed by ğ¶ğ‘– are appended in the final ledger after the
referring block for ğ¶ğ‘– . However, a referring block can be reverted, if
a chain appears which is both valid (i.e., contains a correct referring
block) and long enough. Therefore, the position of uncle blocks,
which are checkpointed by ğ¶ğ‘– , is finalized only when the certificate
ğ¶ğ‘–+1 is issued, which occurs after at most ğ‘’ âˆ’ğ‘ main chain blocks. â–¡

Theorem 3.2 (Liveness). Let â„ be the probability that at least
one honest block is created per round; Advocate satisfies liveness (cf.
Definition 2.3) with parameter ğ‘¢ = âŒˆ 2

â„ âŒ‰ Â· ğ‘’.

Proof: The proof follows directly from the ledger construction (cf.
Section 2.1) and Theorem 3.1. Specifically, let ğ‘¡ be the round on when
block ğµ is created. If ğµ is a main chain block, then it becomes stable
with the issuing of the first checkpoint after ğ‘¡ which, by definition of
the checkpointing behavior (Section 3.1), occurs at most ğ‘’
rounds
â„
after ğ‘¡. If ğµ is an uncle block then, as shown in Theorem 3.1, it
becomes stable with the issuing of the first checkpoint after ğµ
becomes checkpointed; in other words, ğµ becomes stable when
2 checkpoints are issued after it is created. However, the chain
growth depends at worst on the honest minersâ€™ mining power
(e.g. if the adversary abstains), therefore two checkpoints are issued
on expectation at most âŒˆ 2
â„ âŒ‰ Â·ğ‘’ rounds after ğ‘¡. Finally, as mentioned in
Section 3.2, a transaction is published in the first honestly-generated
block which is produced after the transactionâ€™s creation. In turn,
this block is checkpointed, either as part of the main chain or as an
uncle block, by the upcoming checkpoint. â–¡

The next property that we explore is chain quality (cf. Defini-
tion 2.4). First, we observe that Advocate cannot guarantee chain
quality over any fixed window of ğ‘™ consecutive blocks of the final
ledger. Briefly, the adversary can produce blocks in private and re-
lease them, such that the checkpoint certificate refers to all of them
at once, hence temporarily flooding the ledger with adversarial
blocks. However, as Theorem 3.3 shows, Advocate does guarantee
chain quality over the entire ledger. This is a direct improvement
of the checkpoint protocol in [15], which guarantees safety and
liveness but not chain quality.

Theorem 3.3 (Chain Quality). Let ğ›½ be the adversarial power.
For every execution, during which ğ‘™ blocks are created in aggregate by
all parties, Advocate satisfies chain quality (cf. Definition 2.4) with
parameters ğ‘™, (1 âˆ’ ğ›½).

Figure 2: Advocate protocol: 30% honest mining power en-
sures 30% of the blocks in the ledger are mined by honest
miners.

Figure 3: Ledger sanitization ignores/removes invalid trans-
actions post ordering.

The aggregate ledger is constructed by concatenating the referring
block (i.e., Chainğ‘– ) with ğœ‹ (ğ¹ğ‘– ). Therefore, when the referring block
for certificate ğ¶ğ‘– is read, the blocks referred by ğ¶ğ‘– (i.e., the blocks
in ğœ‹ (ğ¹ğ‘– )) are also read in the order defined in ğ¶ğ‘– .1 This procedure
is exemplified in figure 2 where Blocks 3,5 are included after block
8. Note that we can follow other universal ordering approaches for
blocks in ğ¹ğ‘– (e.g. sort by hash) without affecting the security of our
protocol.

Figure 2 depicts the ledger construction, s.t. the sanitized ledger
(figure 3) is obtained by parsing the main chain and referenced
blocks and removing invalid (e.g. double spending) entries. Such
post ordering ledger sanitization is required even under a hon-
est setting since referred uncle blocks may have transactions that
conflict with transactions on the main chain.

3.4 Security Properties of Advocate
In this section we show that Advocate, under the centralized setting
of a single honest checkpointing party, satisfies a host of desirable
properties. First and foremost, Theorems 3.1 and 3.2 prove that
Advocate satisfies safety and liveness (cf. Section 2.1).

1We assume that the (honest) checkpointing node follows the universal topological
sorting ğœ‹ when constructing the reference list of certificate ğ¶ğ‘– .

Proof: During the entire execution, the honest parties collectively
create (on expectation) at least (1 âˆ’ ğ›½) Â· ğ‘™ blocks. At the end of the

012467835Ledger01246783599Adversarial blockHonest blockCheckpointed blockParent linkReference linkCheckpointing link100124678359ğ‘¡ğ‘¥:	ğ´â†’ğµ:10ğ‘¡ğ‘¥:ğ¶â†’ğ·:20ğ‘¡ğ‘¥:ğ´â†’ğ¶:15State:ğ´:10,ğ¶:20State:B:10,ğ·:20LedgerValid transactionDouble spendSanitizationMobiHoc â€™22, October 17â€“20, 2022, Seoul, Republic of Korea

Ranvir Rana, Dimitris Karakostas, Sreeram Kannan, Aggelos Kiayias, and Pramod Viswanath

execution, a checkpoint is issued, which references all main chain
and uncle blocks that are not checkpointed. After the issuing of the
last checkpoint, the aggregate ledger at the end of the execution
contains all blocks created by all parties, hence the ratio of honest
blocks in the final, aggregate ledger is at least 1 âˆ’ ğ›½. â–¡

Advocate with hooks. To achieve chain quality for smaller win-
dows of blocks, we propose a slightly modified version of Advocate.
Now, each block contains a reference to the latest checkpoint certifi-
cate ğ¶ ğ‘— at the time it was mined. Next, such block can be referenced
by a certificate ğ¶ğ‘– only if ğ‘– âˆ’ ğ‘— â‰¤ ğ‘¡, i.e., it can be referenced only by
one of the ğ‘¡ certificates that immediately follow ğ¶ ğ‘— . This constraint,
called a hook, prevents A from releasing old blocks.

Theorem 3.4 shows that Advocate with hooks ensures chain qual-
ity for any window of blocks containing ğ‘¡ consecutive checkpoints.

Theorem 3.4 (Short Term Chain Quality). Under Advocate
with hooks, the ratio of honest blocks in any window of ğ‘™ consecutive
(1âˆ’ğ›½) Â·(ğ‘¡ âˆ’1)
ğ‘¡ +ğ›½+ğ‘¡ Â·ğ›½âˆ’1 , where ğ›½
blocks, which includes ğ‘¡ checkpoints, is at least
is the adversarial power.
Proof: Let Î¥ be the maximum number of blocks that are produced
on expectation by all parties (honest and adversarial) between
two consecutive checkpoints. Without loss of generality, assume
a window of blocks which begins with the checkpointed block of
certificate ğ¶ğ‘– and ends with the checkpointed block of certificate
ğ¶ğ‘–+ğ‘¡ . ğ¶ğ‘– can reference at most ğ‘¡ Â· ğ›½ Â· Î¥ adversarial blocks (i.e., which
have been created after certificate ğ¶ğ‘–âˆ’ğ‘¡ ) and at minimum 0 honest
blocks (i.e., if all honest blocks created between certificates ğ¶ğ‘–âˆ’1 and
ğ¶ğ‘– are part of the main chain). Also, certificate ğ¶ğ‘–+ğ‘¡ can reference
at most (1 âˆ’ ğ›½) Â· Î¥ honest blocks and at minimum 0 adversarial
blocks (i.e., if all honest blocks created between certificates ğ¶ğ‘–+ğ‘¡ âˆ’1
and ğ¶ğ‘–+ğ‘¡ are uncle blocks and all such adversarial blocks are part of
the main chain). In this case, the above window of blocks contains
2 Â· ğ‘¡ Â· ğ›½ Â· Î¥ adversarial blocks and (ğ‘¡ âˆ’ 1) Â· (1 âˆ’ ğ›½) Â· Î¥ honest blocks,
hence the ratio of honest blocks is (1âˆ’ğ›½) Â·(ğ‘¡ âˆ’1)

ğ‘¡ +ğ›½+ğ‘¡ Â·ğ›½âˆ’1 . â–¡

Finally, we introduce two performance metrics that accentuate
the functionality of Advocate. First, the chain inclusion gap (Defini-
tion 3.5) expresses the expected number of blocks until a new block
is stable. Corollary 3.8 shows that plain Advocate cannot ensure
a chain inclusion gap, whereas Advocate with hooks guarantees
a chain inclusion gap of (ğ›½ Â· ğ‘¡ âˆ’ ğ›½ + 1) Â· Î¥ blocks, where Î¥ is the
maximum number of blocks that all parties produce on expectation
between two consecutive checkpoints; the proof follows directly
from Theorems 3.3 and 3.4. We know that the chain grows at the
rate 1 âˆ’ ğ›½; thus, the maximum number of blocks mined between
ğ‘’
1âˆ’ğ›½ = Î¥. Observe that the chain inclusion gap
two checkpoints is
increases linearly with Î¥ and, consequently, with the epoch length,
this is a direct improvement on the result of [15], where it increases
exponentially under adversarial mining majority.

Definition 3.5 (Chain Inclusion Gap). Let party ğ‘ƒ with a main
chain ğ¶ of length ğ‘™, which creates a new block ğµ. The chain inclusion
gap with parameter ğ‘” states that, when ğµ becomes stable, its position
in the aggregate ledger is at most ğ‘™ + ğ‘”.

Corollary 3.6 (Advocate Chain Inclusion Gap). Advocate
guarantees chain inclusion gap (cf. Definition 3.5) with parameter
ğ‘” = âˆ. Advocate with hooks guarantees chain inclusion gap with

parameter ğ‘” = (ğ›½ Â· ğ‘¡ âˆ’ ğ›½ + 1) Â·
ğ‘¡ is the hook parameter, and ğ‘’ is the checkpoint epoch length.

ğ‘’
1âˆ’ğ›½ , where ğ›½ is the adversarial power,

Second, optimistic serializability (Definition 3.7) ensures that the
checkpointing service does not trivialize the ledger maintenance.
Specifically, under fully honest conditions, i.e., ğ›½ = 0, transactions
are ordered in the ledger in the order of their arrival, if such arrival
order exists.

Definition 3.7 (Optimistic Serializability). For two transactions
ğ‘¡ğ‘¥, ğ‘¡ğ‘¥ â€², where ğ‘¡ğ‘¥ was given as an input to all honest nodes at round
ğ‘Ÿ and is valid w.r.t. ledger ğ¿ğ‘ƒ (ğ‘Ÿ ) at round ğ‘Ÿ and ğ‘¡ğ‘¥ â€² was given as an
input to all honest parties after round ğ‘Ÿ , it holds that for any ğ‘Ÿ â€² > ğ‘Ÿ ,
the ledger ğ¿ğ‘ƒ (ğ‘Ÿ â€²) of any honest party ğ‘ƒ cannot include ğ‘¡ğ‘¥ â€²,ğ‘¡ğ‘¥ in
this order, given that the network consists of all honest nodes.

Permissionless protocols like Nakamoto longest chain ensures
optimistic serializability and the checkpointing service does not
affect the block ordering; playing a supplementary role. Evidently,
Advocate satisfies optimistic serializability by design.

Corollary 3.8 (Advocate optimistic serializability). Advo-

cate guarantees optimistic serializability (cf. Definition 3.7).

Consider a Nakamoto longest chain protocol; it is easy to show
that it guarantees optimistic serializability. Since the honest nodes
received ğ‘¡ğ‘¥ before ğ‘¡ğ‘¥ â€², all miners will mine ledger with ğ‘¡ğ‘¥ before
ğ‘¡ğ‘¥ â€². Even when the ledger is forked, within each fork, the parent is
known and hence the order is maintained for all parties. In Advocate,
it may happen that the certificate refers to a transaction ğ‘¡ğ‘¥ again;
hence the ledger ğ¿ğ‘ƒ (ğ‘Ÿ ) might have transactions ğ‘¡ğ‘¥, ğ‘¡ğ‘¥ â€² in that order.
However, since the base consensus is Nakamoto; it will ensure
that ğ‘¡ğ‘¥, ğ‘¡ğ‘¥ â€² exists in that order before checkpointing. Thus the ğ‘¡ğ‘¥ â€²
referred by the checkpoint ğ¶ğ‘Ÿ will be a second occurrence and will
be removed by ledger sanitization.

3.5 Contrast with Fruitchains and Conflux
In terms of safety, the transaction inclusion from ğ¹ğ‘– has similarity
to fruits in Fruitchains [26] and DAG references in the pivot chain
of Conflux [22]. However, we note that if the adversarial mining
power is greater than 50%, the adversary can always beat honest
nodes by creating a mainchain in Fruitchain and a conflicting pivot
chain in Conflux, thus violating safety.

In terms of liveness, Fruitchains has a chain quality of 1 âˆ’ ğ›½,
which is ensured because all blocks created by honest miners are
eventually included as fruits. This chain quality however is reduced
to 0 for ğ›½ > 0.5. To understand this abrupt loss of chain quality, let
us consider an attack by a 51% adversary. The adversary creates a
longer blockchain, consisting of only adversarial blocks, and the
adversarial blocks do not include references to fruits mined by
honest miners. Since the longest blockchain is chosen to create the
fruit ledger, it will not consist of any honest fruits, rendering the
chain quality 0. Similar arguments can be made for a heavier pivot
chain generated by adversaries in Conflux. This abrupt loss of chain
quality for ğ›½ > 0.5 is depicted in Figure 1.

Note that implementing existing checkpointing designs like
Casper to Fruitchains will not will not improve chain quality since
the adversarial majority can ensure that the main chain only con-
tains blocks referring to no honest fruits; hence even the check-
pointed ledger will not contain any honest fruits. Instead, Advocate

Optimal Bootstrapping of PoW Blockchains

MobiHoc â€™22, October 17â€“20, 2022, Seoul, Republic of Korea

checkpoints all leaves of the block tree; this achieves optimal chain
quality (Theorem 3) because the final ledger consists of all produced
blocks, where the percentage of adversarial blocks is equal to the
adversarial mining power (the lower bound).

4 ADVOCATE WITH BFT CHECKPOINTING
Although Advocate, as described above, satisfies the desired security
properties, it assumes a single checkpointing node. This central-
ized design is problematic, especially in systems like distributed
ledgers, whose main purpose is decentralization. In this section, we
present Advocate with Byzantine Fault Tolerant (BFT) checkpoint-
ing, which extends the single checkpointing node with a committee
of ğ‘› nodes. Although this extension might seem trivial, there are
certain fine points (for example running a BFT-SMR with external
state validation) that need to be analyzed to establish equivalency.
In contrast to other checkpointing protocols, Advocate -BFT allows
multiple checkpointing candidates, since a candidate includes both
the checkpointed block and the reference links, thus increasing the
input space for the BFT committee nodes. The committee achieves
consensus on the contents of the checkpoint certificate, which is
then published on the main chain.

We present a design that optimizes transaction inclusion and
confirmation latency. The adversary A controls up to ğ‘“ committee
nodes, s.t. ğ‘› â‰¥ 3ğ‘“ + 1, and a fraction ğ›½ âˆˆ [0, 1) of the PoW mining
power. Note that the BFT committee is independent from the com-
mittee of miners. Hence, it is possible for the committee of miners
(i.e., a small community for novel PoW chains) to be in adversarial
majority, whereas the BFT committee (consisting of well established
and legally bound validators) is in honest supermajority.

4.1 Advocate-BFT
The committee nodes act as full nodes for the PoW main chain
and run a separate SMR (BFT-based State Machine Replication)
protocol; any generic BFT-SMR protocol should suffice. On receiv-
ing a valid PoW block, the committee node posts a transaction
âŸ¨ğµğ‘™ğ‘œğ‘ğ‘˜â„ğ‘ğ‘ â„, ğ·ğ‘’ğ‘ğ‘¡â„âŸ© on the SMR chain, which is finalized after some
rounds as per the BFT-SMRâ€™s rules.

The SMR chain announces a new checkpoint when a trans-
action containing a block with depth ğ‘’ more than the previous
checkpoint is posted on the SMR chain. A checkpoint transaction
ğ‘¡ğ¶ğ‘– = {ğ» (ğµğ‘– ), ğ‘€ (ğ‘…ğ‘– )} is posted on the SMR chain, where ğ‘…ğ‘– consists
of all the main chain blocks referenced on the SMR chain between
the references for ğµğ‘–âˆ’1 and ğµğ‘– , ğ‘€ (ğ‘…ğ‘– ) denotes itâ€™s Merkle root and
ğ» (ğµğ‘– ) denotes hash of block ğµğ‘– .

The checkpoint certificate ğ¶ğ‘– = {{ğ‘¡ğ¶ğ‘– }, ğ‘…ğ‘–, ğ‘¤ğ‘– } consists of the
checkpoint transaction ğ‘¡ğ¶ğ‘– = ğµğ‘–, ğ‘€ (ğ‘…ğ‘– ), a witness ğ‘¤ğ‘– stating that
it is finalized on the SMR chain, and the list of references ğ‘…ğ‘– . ğ¶ğ‘–
should be posted on the PoW chain before the depth of ğ‘‘ (ğµğ‘– ) + ğ‘,
where ğ‘‘ (ğµğ‘– ) is the depth of checkpoint ğµğ‘– .

The SMR chainâ€™s block inclusion validity rules are as follows:

â€¢ Data availability: The block should be available.
â€¢ Block validity: The block should have valid PoW; note that
full transaction validity is not required due to main chainâ€™s
ledger sanitization.

â€¢ No checkpoint conflict: The block should not be at a height
of ğ‘‘ (ğµğ‘– ) + ğ‘’ and extend a chain that does not contain ğµğ‘– .

Evidently, the BFT checkpointing service realizes in a distributed
manner the checkpointing node of Section 3. Specifically, the BFT
service collects all leaves which are not checkpointed, including
the main chain and uncle blocks, and issues a certificate which
references them. Assuming the BFT protocol is secure (safe and
live), the committee will i) issue a certificate which ii) references all
non-checkpointed blocks, so the analysis of Section 3 also applies
here.

Main chain behavior The main chain miners act as light nodes
for the SMR chain. They include ğ¶ğ‘– in the main chain as soon as
ğ‘¡ğ¶ğ‘– is finalized on the SMR chain. We assume that the main chain
nodes are connected to at least one honest SMR chain node, to get
the references from ğ‘€ (ğ‘…ğ‘– ). The mining behavior and validity rules
including the ğ‘ constraint on checkpoint inclusion remain the same
as described in Section 3.

Latency To compute the latency for a transaction, let ğœğ‘š be the
time until a block ğµ containing the transaction is mined. Also let ğœğ‘¡
be the time until a transaction containing the hash of ğµ is posted on
the SMR chain and ğœğ‘“ be the time until that transaction is finalized
on the SMR chain. The total time until an honest transaction is
considered for checkpointing is ğœğ‘– = ğœğ‘š + ğœğ‘¡ + ğœğ‘“ . Observe that the
value ğœğ‘¡ is not affected by the adversarial mining fraction. Finally,
the transaction is confirmed when the next checkpoint is posted on
the SMR chain, i.e., after time ğœğ‘ until the checkpoint is finalized.
Therefore, the overall latency of a transaction is ğœ = ğœğ‘– + ğœğ‘ . We
note that, the parameter ğ‘ depends on the BFT latency, i.e., Î”ğµğ¹ğ‘‡ .

4.2 BFT integration
We abstract the BFT functionality ğ¹ğµğ¹ğ‘‡ and show equivalence with
the checkpointing service ğ¹ğ‘ğ‘ğ‘  described in Section 3.

BFT-SMR service ğ¹ğµğ¹ğ‘‡

ğ¹ğµğ¹ğ‘‡ is a part of a network of ğ‘ƒ replicas participating in
BFT-SMR. ğ¹ğµğ¹ğ‘‡ takes an input ğ¼ğµğ¹ğ‘‡ and outputs ğ‘‚ğµğ¹ğ‘‡ after
a delay bounded by Î”ğµğ¹ğ‘‡ . ğ¹ğµğ¹ğ‘‡ may take no input and still
output ğ‘‚ğµğ¹ğ‘‡ depending on the state ğ‘†ğµğ¹ğ‘‡ and ğ¼ğ‘™ğµğ¹ğ‘‡ : an in-
put received by some replica. ğ¹ğµğ¹ğ‘‡ checks validity of ğ¼ğµğ¹ğ‘‡
and/or ğ¼ğ‘™ğµğ¹ğ‘‡ with respect to ğ‘†ğµğ¹ğ‘‡ stored locally using ğ‘‰ğµğ¹ğ‘‡ .
A message from one replica implementing ğ¹ğµğ¹ğ‘‡ to another
takes a maximum delay of Î”.

We now establish an equivalence between ğ¹ğµğ¹ğ‘‡ and ğ¹ğ‘ğ‘ğ‘  . input-
Value in ğ¹ğ‘ğ‘ğ‘  is equivalent to ğ¼ğµğ¹ğ‘‡ in ğ¹ğµğ¹ğ‘‡ , while commitDecision is
equivalent to ğ‘‚ğµğ¹ğ‘‡ . However, a major difference is that the delay be-
tween the two is Î”ğµğ¹ğ‘‡ in ğ¹ğµğ¹ğ‘‡ and Î”ğ‘ğ‘ğ‘  in ğ¹ğ‘ğ‘ğ‘  , s.t. Î”ğµğ¹ğ‘‡ /Î”ğ‘ğ‘ğ‘  > 1.
Note that Î”ğµğ¹ğ‘‡ is dependent on the liveness parameter ğ‘¢ of the BFT
protocol. A further major deviation regards to the implementation
of ğ‘‰ğµğ¹ğ‘‡ , which corresponds to the isInputValid and inputValidity
messages in ğ¹ğ‘ğ‘ğ‘  . Since the state is not in the same module and the
input may be indirectly received from a different replica, the data
needed for validating ğ¼ğ‘™ğµğ¹ğ‘‡ may not be available to ğ¹ğ‘ğ‘‘ğ‘£ğ‘œğ‘ğ‘ğ‘¡ğ‘’ , thus
returning inputValidity may take unknown time. This is resolved
via a unified network functionality Nğ‘¢ğ‘›ğ‘– (Figure 4) to which each
BFT replica connects.

MobiHoc â€™22, October 17â€“20, 2022, Seoul, Republic of Korea

Ranvir Rana, Dimitris Karakostas, Sreeram Kannan, Aggelos Kiayias, and Pramod Viswanath

5 ADVOCATE: CHECKPOINTING FOR

PARALLEL-POW CHAINS

Many emerging PoW blockchains rely on a â€œparallel-chainâ€ archi-
tecture for scaling, where multiple chains run in parallel and are
aggregated. Two successful parallel-chain architectures are Prism
[4] and OHIE [34]. Although these two protocols are significantly
different from each other, we demonstrate the generalizability of
Advocate; we extend Advocate to both these settings by proposing
a meta-protocol Advocate-PC for integrating Advocate to parallel-
chain architectures. For simplicity, we design Advocate-PC using a
single (honest) checkpointing node, which can be readily extended
to a BFT federation as described in Section 4.

5.1 Advocate-PC: Meta-protocol
Consider ğ‘€ parallel chains, with mining power sortition across
if it belongs to branch ğ‘“ğ‘ of
them. A block is labelled as ğµğ‘š,ğ‘—,ğ‘“ğ‘
chain ğ‘š and has rank ğ‘—. ğ‘“ğ‘ is a function of parent of ğµğ‘š,ğ‘—,ğ‘“ğ‘
. The
rank R (ğµğ‘š,ğ‘—,ğ‘“ğ‘ ) = ğ‘— of a block is determined by the parallel-chain
protocolâ€™s specifics and is deterministic when a block is mined. We
highlight the first important meta-principle:

Rank criterion: Blocks mined by honest miners have
monotonically increasing rank within a chain.

Block ranks are used to determine epoch intervals with a check-
pointing epoch spanning blocks with a rank-difference of ğ‘’. We
denote a chain as payload-carrying, denoted by ğ‘Œ (ğ‘–) = 1 if its blocks
are designed to carry a transaction payload. We set one chain (chain
0) as a base-chain, which may or may not be payload-carrying.

Checkpointing party behavior.

â€¢ Upon receiving Block ğµ0,ğ‘—,ğ‘“ğ‘

at rank R ( Ëœğ¶ğ‘–âˆ’1) + ğ‘’, where
Ëœğ¶ğ‘–âˆ’1 is the latest checkpointed base-chain block, it creates a
new checkpoint certificate ğ¶ğ‘– , the block ğµ0,ğ‘—,ğ‘“ğ‘
is the check-
pointed block Ëœğ¶ğ‘– ;

â€¢ The certificate ğ¶ğ‘– = {ğ‘…( Ëœğ¶ğ‘– ), ğ‘…ğ‘–, Bi} defines: (a) a vector of ğ‘€âˆ’
1 parallel-chain blocks Bi, i.e., one tip block from each parallel
chain except the base-chain, (b) the reference list ğ‘…ğ‘– of all
payload-carrying blocks not referenced by any checkpoint
until Rank R ( Ëœğ¶ğ‘– ), (c) a reference ğ‘…( Ëœğ¶ğ‘– ) to the checkpointed
base-chain block Ëœğ¶ğ‘– .

Validity rules.

â€¢ All chains extend the latest checkpoint;
â€¢ A base-chain block is invalid if it extends the chain past rank

R ( Ëœğ¶ğ‘– ) + ğ‘ and does not contain ğ¶ğ‘– ;

â€¢ A non base-chain is invalid if none of itâ€™s blocks refer to
the base-chain block containing the certificate ğ¶ğ‘– by rank
R ( Ëœğ¶ğ‘– ) + ğ‘;

â€¢ A non base-chain tip block ğµğ‘š,ğ‘—,ğ‘“ğ‘

Bi only if chain ğ‘š has referred to ğ¶ğ‘–âˆ’1.

is valid for inclusion in

The ledger creation rules are similar to Advocate; the checkpoint
certificate brings in all the referred blocks ğ‘…ğ‘– in the respective
payload-carrying chainâ€™s ledger.

Advocate-OHIE: We observe that rank in OHIE satisfies the rank
criterion and thus can be treated as R. The meta-protocol can be
integrated into OHIE by setting the chain 0 as base chain and

Figure 4: The network layer of BFT is modified to accommo-
date the external state validation (isInputValid) functional-
ity; the end impact on BFT replica process is equivalent to be-
ing connected to a synchronous network without ğ¹ğ´ğ‘‘ğ‘£ğ‘œğ‘ğ‘ğ‘¡ğ‘’

Unified network functionality Nğ‘¢ğ‘›ğ‘–

Nğ‘¢ğ‘›ğ‘– gets messages from the nodes connected to it. The
message handling is split in 3 levels. The first level is the
Network Handler, which manages network functions like mes-
sage downloading and forwarding. Once the message is down-
loaded, it is passed to the Validity Handler, which verifies the
message w.r.t. a well-defined validity predicate ğ‘‰ğµğ¹ğ‘‡ , which
utilizes isInputValid and inputValidity. Once the checks pass,
the validity handler forwards the message to ğ¹ğµğ¹ğ‘‡ , marking
the message as received.

Note that Nğ‘¢ğ‘›ğ‘– ensures that, once a message is received by ğ¹ğµğ¹ğ‘‡ ,
checking ğ‘‰ğµğ¹ğ‘‡ is instantaneous, thus replicating a local state. More-
over, Nğ‘¢ğ‘›ğ‘– does not change the synchronous setting delay. Specifi-
cally, let ğ‘– be the first honest node to receive a message ğ‘š at time
ğ‘¡. By definition, ğ¹Advocate sends inputValidity to node ğ‘– at some
time ğ‘¡ â€² â‰¤ ğ‘¡. Now, the message ğ‘š propagates across all nodes in a
synchronous manner, hence it is downloaded by each honest node
ğ‘— at the latest at time ğ‘¡ + Î”. Therefore, ğ¹ğ‘ğ‘‘ğ‘£ğ‘œğ‘ğ‘ğ‘¡ğ‘’ is queried by node
ğ‘— regarding isInputValid of ğ‘š at time ğ‘¡ + Î”. Since ğ¹Advocate replied
inputValidity to node ğ‘– at time ğ‘¡, it will also reply inputValidity to
ğ‘— at ğ‘¡ + Î”. Thus, ğ‘š is marked as received by node ğ‘— by time ğ‘¡ + Î”,
ensuring that the network is Î”-synchronous under Nğ‘¢ğ‘›ğ‘– .

Properties of the BFT service

As discussed above, as long as the BFT-SMR protocol is secure,
i.e., satisfies safety and liveness, it securely realizes the single check-
pointing node in a distributed manner. However, our integration
of the federation BFT into checkpoints affects the values of the
parameters ğ‘, ğ‘’. Specifically, ğ‘ should be at least ğœğ‘“ /ğœğ‘Ÿ larger than
in Section 3, ğœğ‘“ being the time required for a transaction to be final-
ized by the BFT and ğœğ‘Ÿ being the size of each round of the ledger
protocol. Therefore, faster BFT protocols are preferable, in order to
minimize the time until the checkpoint certificate is finalized.

In the next section, we present a variant of Advocate for multi-

chain systems.

BFT replicaprocessMessagesValidity HandlerGossipNetworkinputValidatorNetworkHandlerOptimal Bootstrapping of PoW Blockchains

MobiHoc â€™22, October 17â€“20, 2022, Seoul, Republic of Korea

assigning its protocol defined rank with the Advocate rank R. A
similar extension of the rank criterion works for ledger combiner
as well.

Advocate-Prism: We observe that Prismâ€™s proposer levels follow
the Rank criterion since honest miners always mine blocks with
increasing proposer levels. We can integrate Advocate-PC by setting
the Proposer chain as the base-chain and assigning proposer level
as Advocate rank R.

6 IMPLEMENTATION AND EVALUATION
We implement Advocate on a codebase in Rust and compare its per-
formance with various existing checkpointing techniques. To test
the performance of Advocate to the limit, we integrate Advocate-
Prism along with the high performance implementation of Prism
written in Rust [33]. We evaluate the performance of Advocate
comparing with various other checkpointing protocols. The code
is available at [1].

6.1 Comparison baselines
We implement two other checkpointing protocols as baselines to
compare performance metrics of Advocate . We briefly describe
these baselines and their integration with Prism below.
Stochastic-checkpointing. Derived from [15], the checkpoint cer-
tificates referring to a single Block-hash(checkpoint) are introduced
in the ledger. The certificates add randomness at every epoch, en-
suring the adversary cannot implement a front-running attack de-
scribed in [15]. Stochastic-checkpointing is implemented by modi-
fying the Advocate ğ¹ğ‘ğ‘ğ‘  to generate checkpoint without references.
Nakamoto-checkpointing. Derived from the off-chain check-
points published by Nakamoto in the early days of bitcoin (check-
pointing via GitHub). The checkpoints certificates are posted off-
chain and consist of a blockâ€™s hash. The full node codebase recog-
nizes these checkpoints and only considers chains extending these
checkpoints as valid. Nakamoto-checkpointing is implemented by
modifying code for Stochastic-checkpointing not to include the
certificate on chain.
Experimental setup: We run Advocate and Advocate-Prism ex-
periments on c5d.large and c5d.4xlarge AWS instances respectively.
We run our experiments with ğ›½ â‰¥ 0.5 with private mining attack
where the adversary mines a private chain and broadcast private
blocks in bursts of epoch length. Our evaluation answers the fol-
lowing questions:

(1) How do performance and security metrics of Advocate com-
pare to state-of-the-art checkpointing and finality gadgets?
(2) How does the performance of Advocate react to a slow check-

pointing service?

(3) How does Advocate perform with large epoch sizes?
(4) How does Advocate integrate with very high throughput
PoW blockchains, e.g., Prism? How is the performance over-
head?

Performance metrics: We use three metrics defined below to
measure performance:

â€¢ Fractional Goodput (ğ¹ğº): Let Goodput (G) be the number
of honest transactions confirmed per unit time and optimal
throughput (T ) be the maximum throughput in the absence
of an adversary. We define fractional goodput as G/T .

â€¢ Ledger Inclusion latency (ğ¼ğ¿): for an honest party ğ‘ƒ is the time
taken (measure in means of block arrival time Î”ğ´) between
transaction generation and inclusion in the ledger of ğ‘ƒ.
â€¢ Honest block wastage (ğ»ğ‘Š ): Fraction of honest blocks that

are not part of the ledger.

The performance metrics are tabulated in Tables 1, 2, 3 for a variety
of experimental settings: varying adversary mining power, BFT net-
work latency (Î”ğµğ¹ğ‘‡ ), epoch size. Each experiment was conducted
over a range of 50-100 epochs. We make the following more broad
observations from the data.

(1) We observe that Advocate is far superior to itâ€™s competitors

in all settings and metrics

(2) Advocate takes a lesser hit on performance as compared to

its competitors if the checkpointing service is slow

(3) ğ¼ğ¿ of Advocate increases linearly with epoch length with

minimal drop in its ğ¹ğº

Prism The Prism full-stack implementation can achieve a through-
put of 70K tx/s; coupled with Advocate an optimized implementa-
tion should achieve a throughput of (1 âˆ’ ğ›½) Â· 70ğ¾ tx/s. However,
checkpointing adds to the validity rules, leading to loss of through-
put. Our implementation of Advocate-Prism aims to develop a
proof-of-concept, s.t. checkpointing can be integrated into high
throughput parallel chains without much expense of throughput.
To this end, we design an adversary A for Prism who censors hon-
est transaction blocks. For such A with ğ›½ = 0.7, our full-stack
implementation of Advocate-Prism (with UTXO at the application
layer and p2p networking at the networking layer) can achieve a
goodput of 8200 tx/s with a confirmation latency of 120s. While 8200
tx/s with a 70% adversary is much higher than any existing protocol
can achieve, we believe it can be further improved by optimizing
interaction between ledger manager and integrated checkpointing
module, a direction which will be explored in future research.

7 ACKNOWLEDGEMENTS
This research was partly supported by US Army Research Of-
fice Grant W911NF-18-1-0332, National Science Foundation CCF-
1705007, NeTS 1718270, XDC network and IOHK.

REFERENCES
[1] anon. 2021. Advocate System implementation. https://github.com/advocate-

checkpoint/advocate-systems.

[2] Sarah Azouvi, George Danezis, and Valeria Nikolaenko. 2019. Winkle: Foiling
Long-Range Attacks in Proof-of-Stake Systems. Cryptology ePrint Archive,
Report 2019/1440. https://eprint.iacr.org/2019/1440.

[3] Sarah Azouvi, Patrick McCorry, and Sarah Meiklejohn. 2018.

Betting
on Blockchain Consensus with Fantomette. CoRR abs/1805.06786 (2018).
arXiv:1805.06786 http://arxiv.org/abs/1805.06786

[4] Vivek Kumar Bagaria, Sreeram Kannan, David Tse, Giulia C. Fanti, and Pramod
Viswanath. 2019. Prism: Deconstructing the Blockchain to Approach Physical
Limits. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and
Communications Security, CCS 2019, London, UK, November 11-15, 2019, Lorenzo
Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz (Eds.). ACM,
585â€“602. https://doi.org/10.1145/3319535.3363213

[5] Vitalik Buterin and Virgil Griffith. 2017. Casper the friendly finality gadget.
[6] Vitalik Buterin, DaniÃ«l Reijsbergen, Stefanos Leonardos, and Georgios Piliouras.
2019. Incentives in Ethereumâ€™s Hybrid Casper Protocol. In IEEE International
Conference on Blockchain and Cryptocurrency, ICBC 2019, Seoul, Korea (South),
May 14-17, 2019. IEEE, 236â€“244. https://doi.org/10.1109/BLOC.2019.8751241
[7] Miguel Castro and Barbara Liskov. 1999. Practical Byzantine Fault Tolerance.
In Proceedings of the Third USENIX Symposium on Operating Systems Design
and Implementation (OSDI), New Orleans, Louisiana, USA, February 22-25, 1999,

MobiHoc â€™22, October 17â€“20, 2022, Seoul, Republic of Korea

ğ‘’ = 5, Î”ğµğ¹ğ‘‡ =0
ğ¼ğ¿
ğ¹ğº
- 2
67.14
6.688
0.204
3.611
0.514
Table 1: Advocate evaluation for ğ›½ = 0.5

Ranvir Rana, Dimitris Karakostas, Sreeram Kannan, Aggelos Kiayias, and Pramod Viswanath
ğ‘’ = 10, Î”ğµğ¹ğ‘‡ =0
ğ¼ğ¿
-
21.53
6.712

ğ‘’ = 5, Î”ğµğ¹ğ‘‡ =2
ğ¼ğ¿
-
13.76
2.546

ğ»ğ‘Š
0.7032
0.3539
0

ğ¹ğº
-
0.227
0.475

ğ»ğ‘Š
-
0.546
0.048

ğ»ğ‘Š
-
0.594
0

ğ¹ğº
0.148
0.323
0.588

Parameters
Metrics
Nakamoto-cp
Stochastic-cp

Advocate

Parameters
Metrics
Nakamoto-cp
Stochastic=cp

Advocate

Parameters
Metrics
Nakamoto-cp
Stochastic-cp

Advocate

ğ¹ğº
0
0.101
0.389

ğ‘’ = 5, Î”ğµğ¹ğ‘‡ =0
ğ¼ğ¿
âˆ
43.11
3.491

ğ¹ğº
- 2
0.033
0.330
Table 2: Advocate evaluation for ğ›½ = 0.67

ğ‘’ = 5, Î”ğµğ¹ğ‘‡ =2
ğ¼ğ¿
-
24.43
3.217

ğ»ğ‘Š
1
0.696
0

ğ»ğ‘Š
-
0.9
0

ğ‘’ = 10, Î”ğµğ¹ğ‘‡ =0
ğ¼ğ¿
-
âˆ
6.512

ğ¹ğº
-
0
0.311

ğ»ğ‘Š
-
1
0.056

ğ¹ğº
0
0
0.102

ğ‘’ = 5, Î”ğµğ¹ğ‘‡ =0
ğ¼ğ¿
âˆ
âˆ
2.849

ğ¹ğº
- 2
0
0.072
Table 3: Advocate evaluation for ğ›½ = 0.9

ğ‘’ = 5, Î”ğµğ¹ğ‘‡ =2
ğ¼ğ¿
-
âˆ
4.319

ğ»ğ‘Š
-
1
0.278

ğ»ğ‘Š
1
1
0

ğ‘’ = 10, Î”ğµğ¹ğ‘‡ =0
ğ¼ğ¿
-
âˆ
6.467

ğ¹ğº
-
0
0.087

ğ»ğ‘Š
-
1
0.13

Margo I. Seltzer and Paul J. Leach (Eds.). USENIX Association, 173â€“186. https:
//dl.acm.org/citation.cfm?id=296824

[8] Pierre Civit, Seth Gilbert, and Vincent Gramoli. 2019. Polygraph: Accountable
Byzantine Agreement. Cryptology ePrint Archive, Report 2019/587. https:
//eprint.iacr.org/2019/587.

[9] Phil Daian, Rafael Pass, and Elaine Shi. 2019. Snow White: Robustly Reconfig-
urable Consensus and Applications to Provably Secure Proof of Stake. In Financial
Cryptography and Data Security - 23rd International Conference, FC 2019, Frigate
Bay, St. Kitts and Nevis, February 18-22, 2019, Revised Selected Papers (Lecture Notes
in Computer Science, Vol. 11598), Ian Goldberg and Tyler Moore (Eds.). Springer,
23â€“41. https://doi.org/10.1007/978-3-030-32101-7_2

[10] Bernardo David, Peter Gazi, Aggelos Kiayias, and Alexander Russell. 2018.
Ouroboros Praos: An Adaptively-Secure, Semi-synchronous Proof-of-Stake
Blockchain. In Advances in Cryptology - EUROCRYPT 2018 - 37th Annual Interna-
tional Conference on the Theory and Applications of Cryptographic Techniques, Tel
Aviv, Israel, April 29 - May 3, 2018 Proceedings, Part II (Lecture Notes in Computer
Science, Vol. 10821), Jesper Buus Nielsen and Vincent Rijmen (Eds.). Springer,
66â€“98. https://doi.org/10.1007/978-3-319-78375-8_3

[11] Thomas Dinsdale-Young, Bernardo Magri, Christian Matt, Jesper Buus Nielsen,
and Daniel Tschudi. 2020. Afgjort: A Partially Synchronous Finality Layer for
Blockchains. In Security and Cryptography for Networks - 12th International Con-
ference, SCN 2020, Amalfi, Italy, September 14-16, 2020, Proceedings (Lecture Notes
in Computer Science, Vol. 12238), Clemente Galdi and Vladimir Kolesnikov (Eds.).
Springer, 24â€“44. https://doi.org/10.1007/978-3-030-57990-6_2

[12] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. 2015. The Bitcoin Backbone
Protocol: Analysis and Applications. In Advances in Cryptology - EUROCRYPT
2015 - 34th Annual International Conference on the Theory and Applications of
Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part II
(Lecture Notes in Computer Science, Vol. 9057), Elisabeth Oswald and Marc Fischlin
(Eds.). Springer, 281â€“310. https://doi.org/10.1007/978-3-662-46803-6_10
[13] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zel-
dovich. 2017. Algorand: Scaling Byzantine Agreements for Cryptocurrencies.
In Proceedings of the 26th Symposium on Operating Systems Principles, Shanghai,
China, October 28-31, 2017. ACM, 51â€“68. https://doi.org/10.1145/3132747.3132757
[14] David Gilson. 2013. Feathercoin secures its block chain with advanced checkpoint-
ing. https://www.coindesk.com/feathercoin-secures-block-chain-advanced-
check-pointing.

[15] Dimitris Karakostas and Aggelos Kiayias. 2020. Securing Proof-of-Work Ledgers
via Checkpointing. Cryptology ePrint Archive, Report 2020/173. https://eprint.
iacr.org/2020/173.

[16] Aggelos Kiayias and Giorgos Panagiotakos. 2017. On Trees, Chains and Fast
Transactions in the Blockchain. In Progress in Cryptology - LATINCRYPT 2017
- 5th International Conference on Cryptology and Information Security in Latin
America, Havana, Cuba, September 20-22, 2017, Revised Selected Papers (Lecture
Notes in Computer Science, Vol. 11368), Tanja Lange and Orr Dunkelman (Eds.).
Springer, 327â€“351. https://doi.org/10.1007/978-3-030-25283-0_18

[17] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. 2017.
Ouroboros: A Provably Secure Proof-of-Stake Blockchain Protocol. In Advances
in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference,
Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part I (Lecture Notes in
Computer Science, Vol. 10401), Jonathan Katz and Hovav Shacham (Eds.). Springer,

357â€“388. https://doi.org/10.1007/978-3-319-63688-7_12

[18] Sunny King and Scott Nadal. 2012. Ppcoin: Peer-to-peer crypto-currency with

proof-of-stake.

[19] Eleftherios Kokoris-Kogias, Philipp Jovanovic, Nicolas Gailly, Ismail Khoffi, Linus
Gasser, and Bryan Ford. 2016. Enhancing Bitcoin Security and Performance with
Strong Consistency via Collective Signing. In 25th USENIX Security Symposium,
USENIX Security 16, Austin, TX, USA, August 10-12, 2016, Thorsten Holz and
Stefan Savage (Eds.). USENIX Association, 279â€“296. https://www.usenix.org/
conference/usenixsecurity16/technical-sessions/presentation/kogias

[20] Sergio Demian Lerner. 2015. RSK White paper Overview. https://docs.rsk.co/

RSK_White_Paper-Overview.pdf.

[21] Yoad Lewenberg, Yonatan Sompolinsky, and Aviv Zohar. 2015. Inclusive block
chain protocols. In International Conference on Financial Cryptography and Data
Security. Springer, 528â€“547.

[22] Chenxing Li, Peilun Li, Wei Xu, Fan Long, and Andrew Chi-chih Yao. 2018. Scaling
Nakamoto Consensus to Thousands of Transactions per Second. arXiv preprint
arXiv:1805.03870 (2018).

[23] Satoshi Nakamoto. 2008. Bitcoin: A peer-to-peer electronic cash system.
[24] Satoshi Nakamoto. 2010. Bitcoin 0.3.2 released. https://bitcointalk.org/index.

php?topic=437.msg3807.

[25] Joachim Neu, Ertem Nusret Tas, and David Tse. 2020. Ebb-and-Flow Protocols:
A Resolution of the Availability-Finality Dilemma. Cryptology ePrint Archive,
Report 2020/1091. https://eprint.iacr.org/2020/1091.

[26] R. Pass and E. Shi. 2017. Fruitchains: A fair blockchain. In Proceedings of the ACM

Symposium on Principles of Distributed Computing. ACM.

[27] Rafael Pass and Elaine Shi. 2017. Hybrid Consensus: Efficient Consensus in the
Permissionless Model. In 31st International Symposium on Distributed Computing,
DISC 2017, October 16-20, 2017, Vienna, Austria (LIPIcs, Vol. 91), AndrÃ©a W. Richa
(Ed.). Schloss Dagstuhl - Leibniz-Zentrum fÃ¼r Informatik, 39:1â€“39:16. https:
//doi.org/10.4230/LIPIcs.DISC.2017.39

[28] Rafael Pass and Elaine Shi. 2018. Thunderella: Blockchains with Optimistic In-
stant Confirmation. In Advances in Cryptology - EUROCRYPT 2018 - 37th Annual
International Conference on the Theory and Applications of Cryptographic Tech-
niques, Tel Aviv, Israel, April 29 - May 3, 2018 Proceedings, Part II (Lecture Notes
in Computer Science, Vol. 10821), Jesper Buus Nielsen and Vincent Rijmen (Eds.).
Springer, 3â€“33. https://doi.org/10.1007/978-3-319-78375-8_1

[29] Ethereum Research. 2020. Ethereum 2.0. https://github.com/ethereum/eth2.0-

specs.

[30] Suryanarayana Sankagiri, Xuechao Wang, Sreeram Kannan, and Pramod
Viswanath. 2020. The Checkpointed Longest Chain: User-dependent Adaptivity
and Finality. arXiv:2010.13711 [cs.CR]

[31] Peiyao Sheng, Gerui Wang, Kartik Nayak, Sreeram Kannan, and Pramod

Viswanath. 2020. BFT Protocol Forensics. arXiv:2010.06785 [cs.CR]

[32] Alistair Stewart and Eleftherios Kokoris-Kogia. 2020. GRANDPA: a Byzantine
Finality Gadget. CoRR abs/2007.01560 (2020). arXiv:2007.01560 https://arxiv.org/
abs/2007.01560

[33] L. Yang, V. Bagaria, Gerui Wang, Mohammad Alizadeh, David M. Tse, G. Fanti,
and P. Viswanath. 2019. Prism: Scaling Bitcoin by 10,000x. ArXiv abs/1909.11261
(2019).

[34] Haifeng Yu, Ivica Nikolic, Ruomu Hou, and Prateek Saxena. 2019. OHIE:

Blockchain Scaling Made Simple. arXiv:1811.12628 [cs.DC]

