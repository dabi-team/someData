2
2
0
2

n
u
J

8
1

]
h
p
-
t
n
a
u
q
[

1
v
9
5
1
9
0
.
6
0
2
2
:
v
i
X
r
a

Beating the fault-tolerance bound and security loopholes for Byzantine agreement
with a quantum solution

Chen-Xun Weng,1, ‚àó Rui-Qi Gao,1, ‚àó Yu Bao,1 Wen-Bo Liu,1
Yuan-Mei Xie,1 Yu-Shuo Lu,1 Hua-Lei Yin,1, ‚Ä† and Zeng-Bing Chen1, ‚Ä°
1National Laboratory of Solid State Microstructures and School of Physics,
Collaborative Innovation Center of Advanced Microstructures, Nanjing University, Nanjing 210093, China
(Dated: June 22, 2022)

Byzantine agreement, the underlying core of blockchain, aims to make every node in a decen-
tralized network reach consensus. However, the classical Byzantine agreement faces two major
problems. One is the 1/3 fault-tolerance bound, which means the system to tolerate f malicious
nodes requires at least 3f + 1 nodes. The other problem is the security loopholes of its classical
cryptography methods. Here, we propose a quantum Byzantine agreement that exploits the recur-
sion method and quantum digital signatures to break this bound with nearly 1/2 fault-tolerance
and provides unconditional security. The consistency check between each pair of rounds ensures the
unforgeability and nonrepudiation throughout the whole process. Our protocol is highly practical
for its ability to transmit arbitrarily long messages and mature techniques. For the Ô¨Årst time, we
experimentally demonstrate three-party and Ô¨Åve-party quantum consensus for a digital ledger. Our
work suggests an important avenue for quantum blockchain and quantum consensus networks.

I.

INTRODUCTION

As Bitcoin has attracted increasing attention, one of its fundamental core mechanisms, decentralized blockchain
technology, has rapidly gained popularity [1]. Consensus is the most fundamental and indispensable building block
of the blockchain architecture. To ensure the smooth functioning of a blockchain, there must be a system to ensure
that all users of the network can achieve consensus. This system requires solving a problem initially posed in 1982
known as the Byzantine Generals Problem [2]. For a strict Byzantine agreement, there are two necessary interactive
consistency (IC) Byzantine conditions. The Ô¨Årst is that all loyal lieutenants obey the same order (IC1), and the
second is that every loyal lieutenant obeys the order of the commanding general if the commanding general is loyal
(IC2). Only when both conditions are satisÔ¨Åed can the system reach consensus. Since 1982, numerous classical
Byzantine agreement (CBA) protocols have been proposed to reduce communication complexity and address real-life
application problems [3‚Äì9]. For an n-party system, however, any one of the CBA protocols that tolerates f malicious
players requires n ‚â• 3f + 1 players; namely, the fault-tolerance bound is 1/3 [10‚Äì13]. Thus, the three-party consensus
problem is naturally unsolvable for CBA. The other issue is the security loopholes of CBA‚Äôs widely used public-key
encryption and one-way hash function [14], which are seriously threatened by quantum computing [15‚Äì22]. Recently,
using the authentication classical channel with information-theoretical security, a four-party Byzantine agreement has
been implemented to tolerate one malicious node [23].

A promising approach for Byzantine agreement is to use quantum technology to address these problems. The quan-
tum version of Byzantine agreement is called quantum Byzantine agreement (QBA). For the three-party consensus
problem, the Ô¨Årst quantum solution using a three-qutrit singlet state was proposed in 2001 [24] and was demonstrated
experimentally using a four-photon polarization-entangled state in 2008 [25]. This protocol and its subsequent proto-
cols [26‚Äì30], called detectable QBA, weaken the two original Byzantine conditions with extra assumptions, which leads
to a certain probability of aborting the protocol. More seriously, they are restricted to the three-party scenario and
can only reach one-bit message consensus [24, 25, 27‚Äì30]. Additionally, some achievements have been made towards
scalable multiparty QBA [31‚Äì34] but the fault tolerance of these protocols is still 1/3. All QBA protocols require
sophisticated techniques, such as multiparticle entanglement generation and distribution and entanglement swapping,
which are diÔ¨Écult for practical implementations. Furthermore, the security of detectable QBA has not been proven
rigorously [35, 36].

In this work, we propose a strict QBA protocol that exploits the recursion method [37] and quantum digital
signatures (QDS) [38‚Äì51] to address the limitation of the fault-tolerance bound and security loopholes, which exploits
the nonrepudiation and unforgeability of the delivered messages and thus ensures consistency. We also compare our

‚àó These authors contributed equally to this work
‚Ä† hlyin@nju.edu.cn
‚Ä° zbchen@nju.edu.cn

 
 
 
 
 
 
2

FIG. 1. Comparison of diÔ¨Äerent quantum solutions. We compare our work with previous detectable QBA protocols in
three respects: security, scalability and decentralization. Our QBA protocol is fully decentralized and information-theoretically
secure. It is the Ô¨Årst QBA protocol that can totally break the fault-tolerance bound while strictly obeying the two original
Byzantine conditions. Unlike previous detectable QBA protocols using multiparticle entangled state to establish a binary game
for a single bit, our protocol is highly scalable and practical due to its low technical requirements and its ability to transmit
multiple messages of arbitrary lengths.

protocol with the other detectable QBA protocols in Fig. 1. Our multiparty QBA protocol totally breaks the fault-
tolerance bound while strictly obeying the two original Byzantine conditions, and it can reach a fault-tolerance of
n ‚â• 2f + 1. Moreover, the technical requirements of our protocol depend on the highly practical one-time universal2
hashing QDS [51], avoiding complex multiparticle entangled state manipulation. This enables the parties to transmit
multiple messages of arbitrary lengths, and this protocol can be proven information-theoretically secure. By using a
decoy-state quantum key distribution [52] network to generate the networked secret keys for the one-time universal2
hashing QDS process, we experimentally demonstrate three-party and Ô¨Åve-party consensus for a decentralized digital
ledger, which is one of the most signiÔ¨Åcant applications of blockchain technology.

The main contributions of this work are twofold. First, we solve the two major problems mentioned above. By
combining two important topics of quantum information science, namely, the quantum Byzantine agreement and
quantum digital signatures, for the Ô¨Årst time, we demonstrate that the well-known fault-tolerance bound can be
surpassed under the two original Byzantine conditions by using quantum resources. Our protocol does not rely on
computational complexity and can be proven information-theoretically secure. Second, our work is highly practical
and scalable due to its high performance in transmitting messages and its mature techniques. We highlight that our
protocol can be applied to future quantum blockchain as well as quantum consensus networks.

II. RESULTS

A. Multicast round

Before stating the protocol, let us introduce the basic unit of our protocol called the multicast round.

In the
multicast round for certain players, there is a primary player, and the other players are called backups. The primary
multicasts his or her message to the backups by the following operation, as shown in Fig 2. One of the backups
is selected as the forwarder, and the other unselected backups automatically become veriÔ¨Åers. The primary, the
forwarder and one of the veriÔ¨Åers perform a three-party QDS to transmit the message. Usually, the three-party QDS
process is divided into three steps: (1) signing, (2) forwarding, and (3) veriÔ¨Åcation. (See Appendix D for more details.)
For a chosen forwarder, the veriÔ¨Åers take turns participating in such three-party QDS. Note that the forwarder will
repeatedly participate in three-party QDS, i.e., the forwarder will receive messages from the primary many times
and then forward the message to diÔ¨Äerent veriÔ¨Åers. Therefore, an honest forwarder requires the primary to deliver

Performance indexThis workRef. [24]Ref. [25]Ref. [28]Ref. [29]SecuritySecurityproofInformation-theoreticalsecurityNot providedNot providedNot providedNot providedFault toleranceùëõ‚â•2ùëì+1( for any ùëì)Only for three-partyOnly for three-partyOnly forthree-partyOnly for three-partyBreak fault-tolerance lower bound or not?Yes( for anyùëì)Yes( only for ùëì=1)Yes( only for ùëì=1)Yes( only for ùëì=1)Yes( only for ùëì=1)ScalabilityCommunication complexityExponentialN/AN/AN/AN/ATechnical requirementsCoherent stateThree-qutrit singlet stateFour-qubit entangled stateMultipartite entangled Gaussian states,homodyne detectionHardy correlations, entanglement swappingTransmitted messageMessages of arbitrary lengthBinary ( 0 and 1 )Binary ( 0 and 1 )Binary ( 0 and 1 )Binary ( 0 and 1 )Full decentralizationYesN/AN/AN/AN/AStrictly obey Byzantineagreement conditions ornot?YesNo( detectable QBA )No( detectable QBA )No( detectable QBA )No( detectable QBA )3

FIG. 2. Schematic diagram of a multicast round. Here, we provide an example of a multicast round including n players
with primary S. The forwarder is chosen from among the backups, and the other unchosen backups act as veriÔ¨Åers. The
primary, the forwarder and one of veriÔ¨Åers perform a three-party QDS. The backups take turns acting as the forwarder. The
yellow circle represents the primary. The blue circle represents the forwarder. The grey circles represent the veriÔ¨Åers.

consistent messages. Otherwise the forwarder will reject this primary‚Äôs message and ask the primary to resend a
consistent message. The above process will be repeated until all backups have acted as the forwarder one time.

For a multicast round with t backups, each backup will record t messages received from others into his or her own
list. One of them is the message that he or she directly accepted from the primary when he or she acted as the
forwarder. The other t‚àí1 messages are the messages received from other backups when he or she acted as a veriÔ¨Åer.

B. Protocol deÔ¨Ånition

Our protocol for reaching consensus is similar to an information interchange between players. All players inquire each
other about the message a certain sender broadcast previously. Since some dishonest players may deliberately send
conÔ¨Çicting messages to confuse honest players, one needs additional rounds of information interchange for players to
conÔ¨Årm the delivered messages. The players communicate all the information they received in the previous round from
the other players. According to the information they gather, all honest players independently output a consistent
message. Generally our protocol consists of two phases, namely, the broadcasting phase and the gathering phase.
Suppose there is a system of n players, including f malicious players. The commanding general (initial primary) is
denoted as S, and the lieutenants are denoted as Ri, for i = 1, 2, ¬∑ ¬∑ ¬∑ , n ‚àí 1. Our protocol can reach consensus with a
fault tolerance of n ‚â• 2f + 1. Below we illustrate the two phases in detail.

Broadcasting phase. The broadcasting phase involves successive multicast rounds. The initial primary, i.e., com-
manding general, in the Ô¨Årst round is chosen randomly from among the n players. Then each backup in the current
multicast round will become the primary of the following round, and will multicast his or her message to all other
players. This process will be repeated f times as in a message relaying chain. Note that the primary in the current
round does not participate in the subsequent multicast rounds.

For clarity, we denote the multicast round as MRd

Œ∂ , where Œ∂ represents the route of delivering the message and d
is the depth of the multicast round. For example, the Ô¨Årst multicast round with the initial primary S is denoted as
MR1
S, where Œ∂ = S and d = 1. In the initial multicast round, there are n ‚àí 1 backups. We denote the ith backup
among these n ‚àí 1 backups as Ri. In the next round MR2
where Œ∂ = S ‚Üí Ri and d = 2, Ri acts as a primary
S‚ÜíRi
and multicasts the message, m2
(see Fig. 3a). There are n‚àíd backups in each multicast round at depth d, i.e.,

S‚ÜíRi

ùëÖùëñùëÖ1ùëÜùëπùíè‚àíùüèùëπùíä‚àíùüèùëπùíä+ùüèùëÖ2ùëÖùëñùëÖ1ùëÜùëπùíä‚àíùüèùëπùíä+ùüèùëÖ2ùëπùíè‚àíùüèprimaryforwarderverifierÔºéÔºéÔºéùëπùíè‚àíùüèùëÖùëñùëÖ1ùëÜùëπùíä‚àíùüèùëπùíä+ùüèùëÖ2ÔºéÔºéÔºéùëÖùëñùëÖ1ùëÜùëπùíè‚àíùüèùëπùíä‚àíùüèùëπùíä+ùüèùëÖ24

FIG. 3. Schematic diagram of the protocol. a. The broadcasting phase and gathering phase. The initial primary is S and
the other players are denoted as Ri, for i = 1, 2, ¬∑ ¬∑ ¬∑ , n ‚àí 1. In the broadcasting phase, the message is broadcast layer by layer
via multicast rounds at diÔ¨Äerent depths until d = f . The number of players participating in each multicast round at depth d is
n ‚àí d + 1. In the gathering phase, each player Ri independently deduces the messages layer-by-layer from the lowest to highest
depth until d = 1 and then outputs the Ô¨Ånal outcome mS. b. Flow chart of the broadcasting phase and gathering phase. Note
that the initial value of d in the Ô¨Çow chart is set as d = 0.

Here, we emphasize the rule of consistency. A backup Ri acts as both a forwarder in MRd
. The messages he or she delivers in the two adjacent rounds, MRd

route Œ∂ records d players in order of delivering the message. The maximum depth of our protocol is f , which is also
the number of dishonest players. We use Bd,Ri
to denote a list for Ri to record his own received messages in MRd
Œ∂ .
Œ∂ and as a primary in
Œ∂ and MRd+1
the next round MRd+1
, must
Œ∂‚ÜíRi
be consistent unless he or she is a dishonest player. Thus, when acting as both a veriÔ¨Åer of MRd
Œ∂ and as a forwarder
of MRd+1
corresponding to Ri, one can check the consistency between the messages in the two adjacent rounds
delivered by the same player Ri. If these two messages are not consistent, the receiver will reject them and ask Ri to
repeat the process until the two messages are consistent.

Œ∂‚ÜíRi

Œ∂‚ÜíRi

Œ∂

Gathering phase. We introduce the deterministic function, called the majority function, used in the gathering
phase. If we input a set of elements into the majority function, the output equals the value of the majority of the
inputs (see Appendix B for more details).

Œ∂

Œ∂

In MRd

). Then, mf,Ri

Œ∂ =majority(Gf,Ri

Œ∂ , the gathering list of Ri, denoted as Gd,Ri

When the broadcasting phase Ô¨Ånishes, the gathering phase begins.

In the gathering phase, each backup infers
the message that has been delivered by the primary in a multicast round. We introduce another list: the gath-
ering list.
, is used to deduce the message delivered by the
primary. In the multicast rounds at d = f , Ri directly sets his or her own gathering list to Gf,Ri
mf,Ri
becomes an element of the gathering list in the corresponding previous multi-
cast round, where d = f ‚àí 1. When considering multicast rounds where d (cid:54)= f , all elements of Ri‚Äôs own gathering
list Gd,Ri
(Rj visits all players do not appear in route Œ∂). Note that
the primary Rj of MRd+1
, upon obtaining a complete
gathering list Gd+1,Ri
Œ∂‚ÜíRj
delivered by the primary Rj. This output md+1,Ri
Œ∂‚ÜíRj
Gd,Ri
Œ∂
recursive process, the gathering phase ends up when d = 1, and then Ri outputs m1,Ri

Œ∂‚ÜíRj
, Ri inputs the list into the majority function, and treats the output md+1,Ri
Œ∂‚ÜíRj
= majority(Gd+1,Ri
Œ∂‚ÜíRj

) will become an element of the gathering list
Œ∂ ). With the
) as the Ô¨Ånal

Œ∂ (when j=i, this element is the message that Ri forwards in MRd
S =majority(G1,Ri

are deduced from the lists Gd+1,Ri
Œ∂‚ÜíRj

is also one of the backups of MRd

held by Ri as a backup of MRd

Œ∂ . In detail, in MRd+1
Œ∂‚ÜíRj

Œ∂ =Bf,Ri

as the message

of MRd+1

and outputs

Œ∂‚ÜíRj

S

Œ∂

Œ∂

Œ∂

Generate Broadcast listFor each backup:d = f ?d+1NOYESGathering listInputd = 1?d -1&Update gathering listMajority functionOutput = majority(Gathering list)NOYESOutputd=f-2d=2d=1Depthd=fd=f-1ÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéùíéùüèùíéùüêùíéùë∫ùíéùíè‚àíùüèÔºéÔºéÔºéThe output in the multicast round with primary ùëπùíäùíéùíän-f+1n-f+1n-f+1n-f+1n-f+1n-f+1n-f+1n-f+1n-f+1n-f+2n-f+2n-f+2Depthd=1d=2d=3d=fd=f-1ÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºén-f+2ÔºéÔºéÔºén-f+1ÔºéÔºéÔºén-f+1ÔºéÔºéÔºén-f+1ÔºéÔºéÔºén-f+2ÔºéÔºéÔºén-f+1ÔºéÔºéÔºén-f+1ÔºéÔºéÔºén-f+1ÔºéÔºéÔºén-f+2ÔºéÔºéÔºén-f+1ÔºéÔºéÔºén-f+1ÔºéÔºéÔºén-f+1ùëπùüèùëπùüêùë∫ùëπùíè‚àíùüèùëπùüêùëπùüëùëπùíè‚àíùüèùëπùüèùëπùüèùëπùüêùëπùíè‚àíùüêùëπùüëùëπùíè‚àíùüèThe multicast round with primary ùëπùíäùëπùíäÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéInput playersÔºéÔºéÔºéÔºéÔºéÔºéabÔºéÔºéÔºéthe player listDelete the current primary fromBroadcasting phaseGathering phaseBroadcasting phaseGathering phaseMulticast roundprimarybackupsmessagemulticastÔºéÔºéÔºéthe player listDelete the current primary fromdecision (see Fig. 3b).

Box 1 | Protocol deÔ¨Ånition

Broadcasting phase

5

(Œ∂f is the route that visits all permutations of f

The broadcasting phase begins with MR1
members among the n players). In a multicast round MRd

S and ends with MRf
Œ∂f

Œ∂ (d=1, 2, 3, ¬∑ ¬∑ ¬∑ , f ):

1.Multicast: The primary multicasts the message md

Œ∂ to the n‚àíd backups via QDS as shown in Fig. 2.

2.Consistency check: Upon receiving the message from the primary, forwarder Rj (Rj visits all players except
the players appearing in Œ∂) veriÔ¨Åes the consistency of messages he or she received in the two adjacent multicast
rounds. If consistency check is passed, perform the next step. Otherwise, he or she requests that the primary
perform Multicast again until he receives a consistent message. If d=1, no consistency check and skip to the next
step.

3.Forward: Rj forwards the message to veriÔ¨Åers Rk (Rk visits all players except Rj and the players appearing in
Œ∂).

4.Verify and record: Forwarder Rj and veriÔ¨Åer Rk check the message and corresponding signature. When both
of them accept, the signature is successful and they add this valid message to their own broadcasting lists Bd,Rj
and Bd,Rk

, respectively. Otherwise, repeat the QDS process until it succeeds.

Œ∂

Œ∂

5.Recursion: The forwarder Rj of MRd
recursion process ends when d = f .

Œ∂ acts as the primary of MRd+1
Œ∂‚ÜíRj

and repeat the above four steps. The

Gathering phase

For player Ri (i = 1, 2, ¬∑ ¬∑ ¬∑ , n ‚àí 1):

1.Input: In the bottom layer d = f , Ri obtains the initial gathering list Gf,Ri

Œ∂

= Bf,Ri
Œ∂

.

2.Recursion: When 1‚â§d<f , the gathering lists at the corresponding depth and route are Gd,Ri
where md+1,Ri
Œ∂‚ÜíRj

) and Rj visits all players except those appearing in route Œ∂.

=majority(Gd+1,Ri
Œ∂‚ÜíRj

Œ∂ =(cid:83)

{md+1,Ri
Œ∂‚ÜíRj

},

Rj

3.Output: m1,Ri

S =majority(G1,Ri

S

)

C. Security analysis

In our protocol, the players can be divided into two components according to whether they are honest or dishonest.
Therefore, we can simplify the protocol with a perfect binary tree model in which one tree node represents a set of
multicast rounds with honest or dishonest primaries. When d=1, we represent the initial multicast round by the root
node; when 1 < d ‚â§ f , each tree node is connected by two children, and the left (right) child tree node represents the
multicast rounds started by honest (dishonest) primaries. We Ô¨Årst introduce the two important lemmas. Note that
when we say that the tree node is honest (dishonest), it means that the primary of each multicast round in this tree
node is honest (dishonest).

Lemma 1 Suppose that B is a right child tree node of a parent node A who is honest, and C is the left child tree node
of B. The messages multicast in C are consistent with A, which protects the delivery of consistency.

Lemma 2 Suppose that B is a right child tree node of a parent node A who is honest, and D is the right child tree
node of B. The message multicast in D can be totally inconsistent with A, which disrupts the delivery of consistency.

By Lemma 1 and Lemma 2 (see Appendix E for the proofs), we Ô¨Ånd that in a route that avoids consecutively
choosing the right child node, the consistency of the delivered messages can be protected in the broadcasting phase.

6

FIG. 4. Part of the perfect binary tree model of our protocol. We use blue (red) nodes to represent the tree nodes with
honest (dishonest) primaries. The route A ‚Üí B ‚Üí C exempliÔ¨Åes Lemma 1 and the route A ‚Üí B ‚Üí D exempliÔ¨Åes Lemma 2.
Suppose that m1 is the message multicast by the honest primary of A; then, by Lemma 1, the route A ‚Üí B ‚Üí C ensures the
consistency of the delivered messages. By Lemma 2, for A ‚Üí B ‚Üí D, the consistency of the delivered messages is disrupted,
and the dishonest primaries of D can successfully deliver the conÔ¨Çicting messages m2 and m3 .

With this idea, we denote a special route as a safe path beginning with a safe node in the binary tree. The safe node
is the Ô¨Årst honest tree node appearing in the message delivery route from minimum to maximum depth. Note that
in the multicast rounds represented by the safe tree node, at least half of the backups are honest. From the safe
tree node we continuously choose the left child node layer-by-layer until we Ô¨Ånd an intermediate tree node, which
has the same number of honest and dishonest backups. Then, the right and left child tree nodes are chosen in turn,
layer-by-layer, until we reach the ending tree node at d = f ‚àí 1. Note that we Ô¨Årst choose the right child tree node
of the intermediate tree node. Following the above process, we can obtain a path that begins with the safe tree node,
passes through the intermediate tree node and ends at the ending tree node at d = f ‚àí 1, which we deÔ¨Åne as the safe
path (see Appendix E for a detailed illustration).

To analyse the consistency of the Ô¨Ånal outputs, we consider the message deducing process in the gathering phase.
In each tree node of a safe path, at least half of the elements of each gathering list are from a child tree node that is
also on the safe path. With these elements, we can prove that more than half of the elements of each gathering list on
the safe path are always consistent. Therefore, the outputs of each tree node on the safe path are consistent during
the recursion of the gathering process, and the other branches of the binary tree can be ignored since they have no
inÔ¨Çuence on the Ô¨Ånal results. Thus, we can obtain Lemma 3.

Lemma 3 The safe path ensures that the honest players on the safe tree node can reach consensus on their outputs.

For an n-player system with f malicious players, when n ‚â• 2f + 1, the safe path can always be found in the binary
tree model. We analyse the case in which n=2f + 1 according to whether the initial primary is honest or dishonest.
(1) The initial primary is honest: The root tree node is not only the safe tree node but also the immediate tree
node. Thus, all honest players in the initial round can reach consensus, which satisÔ¨Åes Byzantine conditions IC1 and
IC2.

(2) The initial primary is dishonest: We can Ô¨Ånd more than one safe path beginning from diÔ¨Äerent depths. The
Ô¨Årst safe path starts from the safe node at d = 2, and the others starts at d = 3, d = 4, and so on. The consistent
outputs from each safe node indirectly or directly lead to the eventual consistency of the elements that constitute
each gathering list at d = 1. Although the elements of a list may be diÔ¨Äerent from each other, all the gathering lists
will be the same. Thus all honest players can reach consensus with the same Ô¨Ånal gathering list.

If n ‚â§ 2f , the safe paths appear too late in the binary tree model. Thus the consistency of the delivered messages
and the outputs cannot be guaranteed in the tree nodes before the safe path, especially when d = 2. Finally, we
cannot guarantee a consistent output. Therefore, we can get the Theorem 1 below.

Theorem 1 For an n-player system with f malicious players, our QBA protocol can reach consensus with a fault
tolerance of n ‚â• 2f + 1.

To summarize, we prove that by strictly obeying two original Byzantine conditions IC1 and IC2, the fault tolerance
of our information-theoretically secure protocol is n ‚â• 2f + 1. This fault-tolerance performance exceeds that of
its classical counterpart, and this protocol can reach consensus for multiple messages. Note that the process of
transmitting information in the broadcasting phase uses QDS that is information-theoretically secure. This implies
that our QBA protocol does not rely on computational complexity and thus is information-theoretically secure. The
detailed security analysis can be found in Appendix E.

ùëö1ùê¥ùêµùê∑ùê∂ùëö1ùëö1ùëö2ùëö3ùëö2ùëö3ÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéùëö1ùê¥ùêµùê∑ùê∂ùëö1ùëö1ùëö2ùëö3ùëö2ùëö3ÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºéÔºé7

FIG. 5. Overview of experimental implementation. a. The Ô¨Åve users are located in diÔ¨Äerent buildings of Nanjing
University. Each of them independently owns the secret keys pre-generated in the laboratory via four-intensity decoy-state
quantum key distribution; the keys are used for the subsequent QDS processes in our QBA protocol. The users perform our
QBA protocol to reach consensus for a decentralized digital ledger. b. Main parameters of the quantum key distribution links
used in the laboratory to pre-generate the secret keys. QBER: quantum bit error rate. c. Experimental setup of the four-
intensity decoy-state quantum key distribution system with a time-phase encoding. We take one of the pairs of the Ô¨Åve users,
Alice (user A) and Bob (user B), as an example. Alice uses a master laser, two slave lasers and an asymmetric interferometer
to prepare optical pulses in the Z and X bases. An intensity modulator is used for the decoy-state modulating. Before passing
through a set of Ô¨Ålters, a monitor and an attenuator are utilized to regulate the photon number per pulse. Bob uses a biased
beam splitter for the passive basis detection. The pulses either go directly to the time detector or pass through an asymmetric
interferometer. A synchronization signal is distributed from Alice to Bob through a wavelength division multiplexed quantum
channel. BS: beam splitter; Circ: circulator; IM: intensity modulator; FBG: Ô¨Åbre Bragg grating; Att: attenuator; DWDM:
dense wavelength division multiplexer; FM: Faraday mirror; PS: phase shifter; SPD: single-photon detector.

D. Experimental implementation

To demonstrate the viability of the presented protocol, we show an experimental implementation of our QBA
protocol for reaching consensus on a decentralized digital ledger, which is the most important application of blockchain
technology. The digital ledger is a 1.10 MByte document, which is a virtual transaction (see Appendix F). The digital
ledger is converted into a binary string of bits. We denote this correct message as m1, and the incorrect messages
as m2, m3, and so on. In the experiment, we utilize four-intensity decoy-state quantum key distribution to generate
the secret keys for the QDS processes in our QBA protocol [52]. We note that networks using any quantum key
distribution protocols [53‚Äì58] can serve as the basis for our QBA scheme. There are Ô¨Åve independent users, A, B, C,
D and E. The secret keys of diÔ¨Äerent pairwise users are pre-generated in the laboratory via a Ô¨Åbre spool. The Ô¨Åve
users bring their own secret keys to Ô¨Åve diÔ¨Äerent buildings (see Fig. 5a). The main parameters of these ten links are
shown in Fig. 5b. Note that, in principle, each pair of users should be linked with a quantum channel to generate the
secret keys, but to simplify the experiment we adopt the above method of pre-generating the key in the laboratory
and then bringing the key to diÔ¨Äerent locations. This will not inÔ¨Çuence the security of our protocol. The Ô¨Åve users
will execute the QBA protocol in which the QDS applied is introduced in Appendix D 2 using the pre-generated secret
keys. Detailed information about the four-intensity decoy-state quantum key distribution can be found in Appendix F.
We experimentally implement three-party and Ô¨Åve-party consensus as shown in Fig. 6. We choose nodes A, B and
C to perform three-party consensus and choose all Ô¨Åve nodes to perform Ô¨Åve-party consensus. According to the two
Byzantine conditions, we consider the two situations in which the initial primary is honest and dishonest. All honest

BSCircSPDFMcabA-BA-CA-DA-EB-C25354050256.358.909.3510.356.351.591.030.851.701.6211.427.804.153.7312.09LinkLength (km)Loss (dB)QBER (%)Key rate (kbps)B-DB-EC-DC-ED-E35402525358.909.356.356.358.900.800.881.591.640.868.235.5212.5312.418.90LinkLength (km)Loss (dB)QBER (%)Key rate (kbps)ABCDE8

FIG. 6. Experimental results fpr three-party and Ô¨Åve-party consensus. We use ‚ÄòF‚Äô to represent ‚Äòforwarder‚Äô and ‚ÄòV‚Äô
to represent ‚ÄòveriÔ¨Åer‚Äô in the tables of lists. Each column of a table is a broadcasting list for the corresponding player. In the
bottom layer d = f , Ri sets his or her gathering list as Gf,Ri
and performs the gathering phase to deduce the Ô¨Ånal
output. a. The multicast rounds of d = 1 in three-party consensus with an honest primary. b. The multicast rounds at d = 1
in three-party consensus with a dishonest primary. ‚àÜ=majority(m1, m2) c(d). The multicast rounds at d = 1 (d = 2) in
Ô¨Åve-party consensus with an honest initial primary. e(f ). The multicast rounds at d = 1 (d = 2) in Ô¨Åve-party consensus with
a dishonest initial primary. ‚àÜ1=majority(m41, m42, m43) and ‚àÜ2=majority(m1, m2, m3, ‚àÜ1).

Œ∂ =Bf,Ri

Œ∂

users can obtain consistent outputs regardless of whether the initial primary is honest. When the initial primary is
honest, all honest users can obtain the correct outputs.

ùê∫ùëÖ11,ùëÖ2ùëöùëÖ1‚ÜíùëÖ22,ùëÖ3=ùëö1ùëöùëÖ1‚ÜíùëÖ22,ùëÖ4=ùëö1ùëöùëÖ11,ùëÖ2=majorityùê∫ùëÖ11,ùëÖ2=Œî2ùëöùëÖ11,ùëÖ3=majorityùê∫ùëÖ11,ùëÖ3=Œî2ùëöùëÖ11,ùëÖ4=majorityùê∫ùëÖ11,ùëÖ4=Œî2ùëÖ4ùëÖ2ùëÖ4ùëö41ùëÖ3ùëÖ2ùëÖ3ùëÖ5ùëÖ5ùëö2ùëö3ùëö2ùëö2ùëö3ùëö42ùëö3ùëö3ùëö44ùëö43ùëö1ùëö2ùëö1ùëö1ùëö1ùêπùëâùëÖ3ùëÖ4ùëÖ3ùëÖ4ùëÖ5ùëÖ5ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùêπùëâùëâùëÖ4ùëÖ2ùëÖ4ùëö1ùëÖ3ùëÖ2ùëÖ3ùëÖ5ùëÖ5ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùêπùëâùëÄùëÖùëÖ11cùëöùëÖ1‚ÜíùëÖ22,ùëÖ3=ùëö1ùëÖ3ùëÖ4ùëÖ3ùëÖ4ùëÖ5ùëÖ5ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùêπùëâùëö1ùëö2ùëÖ2ùëÖ3ùëÖ2ùëÖ3ùëÖ5ùëÖ5ùëö1ùëö2ùëö2ùëö1ùëö1ùëö1ùëö1ùëöùëÖ1‚ÜíùëÖ42,ùëÖ2=ùëö1ùëöùëÖ1‚ÜíùëÖ42,ùëÖ3=ùëö1ùêπùëâùëö1ùëö3ùëÖ2ùëÖ3ùëÖ2ùëÖ3ùëÖ4ùëÖ4ùëö1ùëö3ùëö3ùëö1ùëö1ùëö1ùëö1ùëöùëÖ1‚ÜíùëÖ52,ùëÖ2=ùëö1ùëöùëÖ1‚ÜíùëÖ52,ùëÖ3=ùëö1ùêπùëâùëöùëÖ1‚ÜíùëÖ32,ùëÖ2=ùëö1ùëÖ2ùëÖ4ùëÖ2ùëÖ4ùëÖ5ùëÖ5ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùêπùëâùëÖ5ùëÖ4ùëÖ3ùëö1ùëö1ùëö1ùëÖ2ùê∫ùëÖ11,ùëÖ2=ùê∫ùëÖ11,ùëÖ3=ùëö1,ùëö1,ùëö1,ùëö1ùëÖ5ùëÖ4ùëö1ùëö1ùëö1ùëÖ3ùëÖ2ùëÖ3ùëö1ùëö3ùëö1ùëÖ5ùëÖ4ùëÖ2ùëÄùëÖùëÖ1‚ÜíùëÖ22ùëÄùëÖùëÖ1‚ÜíùëÖ32ùëÄùëÖùëÖ1‚ÜíùëÖ42ùëÄùëÖùëÖ1‚ÜíùëÖ52ùëö2ùëö1ùëö1ùëÖ2ùëÖ5ùëÖ4ùëÖ3eùëÖ5ùëÖ3ùëö1ùëö1ùëö1ùëÖ2ùëÖ4ùê∫ùëÖ11,ùëÖ2=ùê∫ùëÖ11,ùëÖ3=ùê∫ùëÖ11,ùëÖ4=ùëö1,ùëö2,ùëö3,Œî1ùëÖ5ùëö2ùëö2ùëö2ùëÖ3ùëÖ2ùëÖ4ùëÖ3ùëö41ùëö43ùëö42ùëÖ5ùëÖ2ùëÖ4ùëÄùëÖùëÖ1‚ÜíùëÖ22ùëÄùëÖùëÖ1‚ÜíùëÖ32ùëÄùëÖùëÖ1‚ÜíùëÖ42ùëÄùëÖùëÖ1‚ÜíùëÖ52ùëö3ùëö3ùëö3ùëÖ2ùëÖ3ùëÖ5ùëÖ4ùëö1ùëö1ùëö1ùëö1ùëÖ1ùëÖ5ùëÖ4ùëÖ3ùëÖ2ùëÄùëÖùëÖ11ùëö1ùëö2ùëö3ùëö4ùëÖ5ùëÖ3ùëÖ1ùëöùëÖ1‚ÜíùëÖ32,ùëÖ4=ùëö2ùëö2ùëöùëÖ1‚ÜíùëÖ32,ùëÖ2=ùëö2ùëÖ2ùëÖ4ùëÖ2ùëÖ4ùëÖ5ùëÖ5ùëö2ùëö2ùëö2ùëö2ùëö2ùëö2ùëö2ùëö2ùêπùëâùëöùëÖ1‚ÜíùëÖ42,ùëÖ3=ùëö3ùëö3ùëö3ùëÖ2ùëÖ3ùëÖ2ùëÖ3ùëÖ5ùëÖ5ùëö3ùëö3ùëö3ùëö3ùëö3ùëö3ùëö3ùëöùëÖ1‚ÜíùëÖ42,ùëÖ2=ùëö3ùêπùëöùëÖ1‚ÜíùëÖ52,ùëÖ3=Œî1ùëöùëÖ1‚ÜíùëÖ52,ùëÖ4=Œî1ùëö43ùëö43ùëö43ùëÖ2ùëÖ3ùëÖ2ùëÖ3ùëÖ4ùëÖ4ùëö42ùëö41ùëö42ùëö41ùëö42ùëö41ùëöùëÖ1‚ÜíùëÖ52,ùëÖ2=Œî1ùêπùëâùëöùëÖ11,ùëÖ3=majorityùê∫ùëÖ11,ùëÖ3=ùëö1ùëöùëÖ11,ùëÖ2=majorityùê∫ùëÖ11,ùëÖ2=ùëö1dfDepth=1Depth=2Depth=1Depth=2abùëö1ùëö1ùëÖ1ùëÖ3ùëÖ2ùëö1ùëö2ùëÖ2ùëÖ1ùëÖ3ùëÖ2ùëÖ2ùëÖ3ùëö1ùëö1ùëö1ùëö1ùëÖ3ùëöùëÖ11,ùëÖ2=majorityùê∫ùëÖ11,ùëÖ2=ùëö1ùêπùëâùëÖ3ùëÖ2ùëÖ3ùëö1ùëö2ùëö1ùëö2ùëÖ2ùêπùëâùëÄùëÖùëÖ11ùëÄùëÖùëÖ11Depth=1Depth=1ùëÖ4ùëÖ2Message multicast honestlyMessage multicast dishonestlyMessage forwarded honestlyMessage forwarded dishonestlyHonest playerDishonest playerùê∫ùëÖ11,ùëÖ2ùëöùëÖ11,ùëÖ2=majorityùê∫ùëÖ11,ùëÖ2=Œîùê∫ùëÖ11,ùëÖ2ùê∫ùëÖ11,ùëÖ3ùëöùëÖ11,ùëÖ3=majorityùê∫ùëÖ11,ùëÖ3=ŒîIII. CONCLUSION AND DISCUSSION

9

In this section, we analyse the performance of our QBA protocol. First, our protocol is fully decentralized without
the assumption of a trusted certiÔ¨Åcate authority. Second, it can be proven information-theoretically secure. In our
security analysis, we Ô¨Ånd that the nonrepudiation and unforgeability of the QDS can eÔ¨Äectively prevent dishonest
players from deliberately delivering conÔ¨Çicting messages to honest players because they cannot deny the authorship
of their signatures and forge the message. Even under colluding attacks, because there are f recursions, conÔ¨Çicting
messages in the system will not aÔ¨Äect the Ô¨Ånal consistent output. Thus the fault tolerance of our QBA protocol can
reach

n ‚â• 2f + 1,

(1)

where f is the number of malicious players and f can be any positive integer. And the communication complexity of
our protocol can be expressed as

C =

f ‚àí1
(cid:88)

m=0

A2+m
n‚àí1 ,

(2)

a = a!

where Ab
(a‚àíb)! is b-permutations of a, f is the number of dishonest players and n is the number of all players
(see Appendix C for details). Note that for an n-player system with f malicious players, our protocol requires f
(cid:3)
recursions. In reality, considering that the fault-tolerance of our protocol is n ‚â• 2f + 1, we need to perform (cid:2) n‚àí1
2
recusions for a real-life consensus system with unknown f , where [x] is the greatest integer less than or equal to x.

Note that the fault-tolerance bound cannot be beaten for any arbitrary pairwise communication [10‚Äì13], i.e., not
even quantum channels can help solve this problem. However, the QDS is a useful tool for solving this problem.
In nature, three-party QDS establishes a correlation among the three participants to ensure the unforgeability and
nonrepudiation [38, 51]. The secret sharing correlation plays a fundamental role in QDS [51], which is equivalent to that
of using multiparticle correlation. In addition, the consistency check between each pair of adjacent multicast rounds
enables the unforgeability and non-repudiation to work throughout the whole protocol. This connects the correlations
of every pair of rounds and can eÔ¨Äectively prevent malicious players in the system from sending conÔ¨Çicting messages
at will, as we can see in the security analysis. Thanks to the three-party correlation established by the QDS and
consistency check, our QBA protocol is equivalent to using quantum entanglement to construct correlations among all
players, i.e., to correlate the communications between all pairs of players. Due to the unique nature of the multiparty
correlation provided by quantum physics, our protocol is able to break the fault-tolerance bound even under pairwise
communication, which demonstrates quantum superiority in terms of the Byzantine consensus problem.

To the best of our knowledge, our work is the Ô¨Årst QBA protocol that totally breaks the fault-tolerance lower bound
while strictly obeying the two original Byzantine conditions, which is impossible for classical resources. Moreover, due
to using information-theoretically secure QDS to transmit information, the security of our protocol does not rely on
computational complexity and thus is information-theoretically secure. In addition, by avoiding multiqubit entangled
states to reach binary consensus for a single bit, our work can reach consensus for multiple messages of arbitrary
length, and its technical requirements are much easier to fulÔ¨Ål than those of the previous detectable protocols, i.e.,
our protocol requires only QDS which can be achieved in practice under current technology. Thus, by bridging
two prominent research themes, the Byzantine agreement and quantum digital signatures, our work indicates a new
paradigm of quantum information science and paves the way for practical quantum blockchain and quantum consensus
networks.

Appendix A: Two Byzantine conditions

A strict Byzantine agreement must satisfy the following two interactive consistency Byzantine conditions as follows.
IC1: All loyal lieutenants obey the same order. IC2: Every loyal lieutenant obeys the order he or she sends if the
commanding general is loyal. These two conditions emphasize two major concerns. When the commanding general
is dishonest, all loyal players output consistent values. When the commanding general is honest, all loyal players
output consistent and correct values. A strict Byzantine agreement must obey these two original conditions without
adding any other assumptions. However, for detectable QBA protocols to achieve three-party consensus, an extra
assumption is required: there must be a certain probability that the protocol will fail. The players must discard the
outcome when the protocol fails and perform the process again until the protocol succeeds. Therefore, all detectable
QBA protocols are weaker versions of the Byzantine agreement.

Appendix B: The majority function

10

The majority function we apply in our protocol aims to output the element that appears most often for an input
set. For example, when the input set is M = {m1, m1, m1, m2, m2}, the output will be majority(M ) = m1. In a few
cases, more than one element appears most frequently in the input set, and the systems that calculate the majority
function on the input set are often deliberately biased towards one of them that we set initailly. For example, when
the input set is M = {m1, m1, m1, m2, m2, m2}, the output will be majority(M )=m1 (m2), which is determined by
the biased output m1 (m2)that we set before calculation. Note that for the same input sets with diÔ¨Äerent players,
the majority function outputs the same value, which we denote as ‚àÜ.

Appendix C: Communication complexity

To measure the consumed resources, we deÔ¨Åne the number of times the QDS process is implemented to reach
consensus as the communication complexity, denoted as C. The total communication complexity can be expressed by

C =A2

n‚àí1 + (n ‚àí 1)A2
n‚àí2 + (n ‚àí 1)(n ‚àí 2)A2
+ ¬∑ ¬∑ ¬∑ + (n ‚àí 1)(n ‚àí 2) ¬∑ ¬∑ ¬∑ (n ‚àí f + 1)A2

n‚àí3

n‚àíf

=

f ‚àí1
(cid:88)

m=0

A2+m
n‚àí1 ,

(C1)

where Ab
Here A2+m

a = a!
n‚àí1 represents the communication complexity at depth m + 1.

(a‚àíb)! is b-permutations of a, f is the number of dishonest players and n is the number of all players.

Appendix D: Quantum digital signatures

In this section, we Ô¨Årst brieÔ¨Çy introduce the common process of QDS, and then describe the one-time universal2

hashing QDS which we used in the protocol in detail, and Ô¨Ånally

1. Brief description for nonrepudiation and unforgeability

Quantum digital signatures with information-theoretical security have two major properties, nonrepudiation and
unforgeability. The brief process of quantum digital signatures can be described as follows. Alice is a ‚Äòsigner‚Äô. Bob is
a ‚Äòforwarder‚Äô. Charlie is a ‚ÄòveriÔ¨Åer‚Äô. Alice signs a message with certain methods, and then transmits the message and
corresponding signature to Bob. Bob forwards the message and corresponding signature to the veriÔ¨Åer Charlie. Then,
Bob and Charlie will check the message and corresponding signature, respectively. The process of QDS is successful
when and only when both Bob and Charlie accept the message and the corresponding signature.

Nonrepudiation. Nonrepudiation refers to a situation in which the signer cannot successfully dispute the authorship
of his signature. This means that Alice cannot deny the fact that she signed the message if the signature is accepted
by both Bob and Charlie.

Unforgeability. Unforgeability refers to a situation in which no one can forge a message and its corresponding
signature. This means that if Bob forwards a forged message and signature, it will be impossible for him to successfully
make Charlie accept the forged message and signature.

Note that our QBA protocol can apply any kind of QDS to ensure unconditional security and better fault-tolerance
performance. Here, we prefer to use the most eÔ¨Écient and practical QDS protocol, called one-time universal2 hashing
QDS [51], which we also use in the experiment of three-party and Ô¨Åve-party consensus. A detailed description of
one-time universal2 hashing QDS can be found in the next.

2. One-time universal2 hashing QDS

We introduce the one-time universal2 hashing (OTUH)-QDS we applied in our experiment of quantum consensus,
which utilizes secret sharing, one-time hashing and one-time pad to generate and verify signatures [51]. Before
executing the signature, Alice, Bob and Charlie all have two sets of keys, Xa,b,c and Ya,b,c, which satisfy the bit

11

correlations Xa = Xb ‚äï Xc (p bits) and Ya = Yb ‚äï Yc (2p bits). The perfect bit correlation of three parties can be
realized by using quantum communication, such as quantum secret sharing and quantum key distribution. In our
experiment, we use four-intensity decoy-state BB84 QKD to implement this bit correlation. Alice shares the secret
keys Xb and Yb with Bob, and Xc and Yc with Charlie via QKD. Then, Alice gets her own secret keys by XOR
operation. Suppose that Alice signs a q-bit document (message), denoted as m, and sends it to ‚Äòforwarder‚Äô Bob.

(i) Signing‚ÄìAlice generates an irreducible polynomial [14] I(x) of degree p at random using a local quantum random
number, which can be characterized by an p-bit string Ia. Then she uses her key bit string Xa and the irreducible
polynomial I(x) to generate a random linear feedback shift register-based (LFSR-based) Toeplitz matrix [59] Hpq of
p rows and q columns. She acquires a 2p-bit digest Dig = (Dig1||Ia). Here, Dig1 is the digest of the q-bit document
through a hash operation with Dig1= Hpq ¬∑ m, and Ia is an p-bit string for generating the irreducible polynomial
in the LFSR-based Toeplitz matrix. Then, Alice encrypts the digest with her key bit string Ya to obtain the 2p-bit
signature Sig = Dig ‚äï Ya. She sends the document and signature {Sig, m} to Bob.

(ii) Forwarding‚Äì Bob transmits {Sig, m} as well as his key bit strings {Xb, Yb} to Charlie to inform Charlie that
he has received the signature. Then, Charlie forwards his key bit strings {Xc, Yc} to Bob. Bob obtains two new key
bit strings {KXb = Xb ‚äï Xc, KYb = Yb ‚äï Yc} by the XOR operation.

(iii) VeriÔ¨Åcation‚Äì Bob exploits KYb to obtain an expected digest and a string Ib via XOR decryption. He utilizes
KXb and Ib to establish an LFSR-based Toeplitz matrix and acquires an actual digest via a hash operation. Bob will
accept the signature if the actual digest is equal to the expected digest. Then, he informs Charlie of the result. If Bob
announces that he accepts the signature, Charlie creates two new key bit strings {KXc = Xb ‚äï Xc, KYc = Yb ‚äï Yc}
using his original key and the key sent by Bob. He employs KYc to acquire an expected digest and a variable Ic via
XOR decryption. Charlie obtains an actual digest via a hash operation, where the hash function is an LFSR-based
Toeplitz matrix generated by KXc and Ic. Charlie accepts the signature if the two digests are identical.

This QDS protocol is naturally immune to repudiation and the probability of a successful forgery can be determined
by Œµf or = q/2p‚àí1 [51]. In this work, we choose p = 128 and thus even for the 264-bit document it is still safe enough.

3. Colluding attacks

Colluding attacks are the most serious problem in decentralized quantum digital signatures involving multiple
participants [50]. A colluding attack means that there are more than two malicious nodes colluding together to disturb
the normal functioning of a system. In our quantum Byzantine agreement, due to complete decentralization, colluding
attacks appear as the number of malicious nodes increases. In a three-party QDS, if the sender and forwarder are
dishonest, they can collude together to make another node believe the forged message and the corresponding signature.
In the broadcasting phase of our QBA protocol, this will lead to inconsistency of the delivered messages of the two
adjacent multicast rounds without prejudice to the rule of coherence, as we can see in Lemma 1 and Lemma 2. It
allows dishonest players to deliver inconsistent messages in the system only under colluding attacks.

Appendix E: Detailed security anslysis

In our QBA protocol, the performance of honest (dishonest) players follows the same rule. Therefore, the players
can be divided into two groups according to whether they are honest or dishonest, and the elements of a gathering
list can be divided in the same way. Therefore, we can simplify the protocol with a perfect binary tree model where
one tree node represents a set of multicast rounds with honest or dishonest primaries. The left (right) child tree
node represents the multicast rounds with honest (dishonest) primaries of the next depth. In what follows, when we
say a tree node is honest(dishonest), it means that the primary of each multicast round in this tree node is honest
(dishonest). When we say the primaries of a tree node multicast a message (or a message is multicast in a tree node),
it means that each primary of this tree node multicasts this message in his or her round. This perfect binary tree
model simpliÔ¨Åes the QBA protocol, and we can obtain the following important conclusions, Lemma 1 and Lemma 2.

Lemma 1 Suppose that B is a right child tree node of a parent node A who is honest, and C is the left child tree
node of B. The messages delivered in C are consistent with that of A, which protects the consistency of the delivered
messages.

Proof 1 As shown in Fig. 7a, each primary of the honest node A multicasts m1 to the backups. In this case, the
dishonest forwarders cannot forward any messages except m1 due to the unforgeability of the QDS, and each veriÔ¨Åer
receives m1. Then, coherence check guarantees that each primary of dishonest B must deliver m1 to the honest
forwarders in MRd+1
Œ∂A‚ÜíB‚ÜíC are m1,
where Œ∂A marks the route before and containing A.

Œ∂A‚ÜíB. Therefore, the messages multicast by the honest primaries of C in MRd+2

12

FIG. 7. Illustration of Lemma 1 and Lemma 2. We use ‚ÄòF‚Äô to represent ‚Äòforwarder‚Äô, ‚ÄòV‚Äô to represent ‚ÄòveriÔ¨Åer‚Äô, ‚ÄòH‚Äô
to represent ‚Äòhonest backups‚Äô and ‚ÄòD‚Äô to represent ‚Äòdishonest backups‚Äô in the tables. The honest (dishonest) tree nodes are
denoted by green (orange). The detailed process of the broadcasting phase is shown in tables where all recorded messages are
summarized according to the honest and the dishonest case. (a)Illustration of Lemma 1. (b) Illustration of Lemma 2.

Lemma 2 Suppose that B is a right child tree node of a parent node A who is honest, and E is the right child tree
node of B. The message multicast in E can be inconsistent with that of A, which disrupts the consistency of the
delivered messages.

Proof 2 As shown in Fig. 7b, each primary of the honest node A multicasts m1 to backups. Then, each primary
of the dishonest node B can only deliver m1 to the honest backups. However, the primaries of the dishonest B can
execute the colluding attack together with the dishonest forwarders, and they can deliver any conÔ¨Çicting messages to
the veriÔ¨Åers. After forwarding the diÔ¨Äerent messages, these dishonest forwarders in MRd+1
Œ∂A‚ÜíB (Œ∂A marks the route
before and containing A), who are also the dishonest primaries of E, can multicast these conÔ¨Çicting messages without
compromising consistency. The consistency of the delivered messages is completely disrupted.

By Lemma 1 and Lemma 2, we Ô¨Ånd that on the route that avoids consecutively choosing the right child, the
consistency of the delivered messages can be protected in the broadcasting phase. With this idea, we denote a special
route as a safe path in the binary tree as follows.

DeÔ¨Ånition 1 The safe tree node, denoted by P, is deÔ¨Åned as the Ô¨Årst honest tree node in the message delivery route
from the top to the bottom layer, as shown in Fig. 8a. Note that in the safe tree node, at least half of the backups
are honest. Then, we continuously choose the left child node layer-by-layer until we reach an intermediate tree node.
The intermediate node is deÔ¨Åned as the tree node that has an equivalent number of honest and dishonest backups of
depth d(cid:48), denoted by Q. As shown in Fig. 8c, from the intermediate tree node Q (depth d(cid:48)), we choose the right child
K of Q (d(cid:48) + 1), the left child J of K (d(cid:48) + 2), the right child T of J (d(cid:48) + 3), the right child of T (d(cid:48) + 4), and so
on. That is, the right and left child tree nodes are chosen in turn layer-by-layer until the ending tree node O of the
penultimate depth is reached. This path from the safe tree node P, passing through the intermediate tree node Q, to
reach the ending tree node O is deÔ¨Åned as the safe path.

ùê¥ùêµùê∂ùê¥ùêµùê∏ùë¥ùëπùúªùë®‚Üíùë©‚Üíùë™ùíÖ+ùüêùê∑ùê∑ùê∂ùêªùêªùê∑ùêªùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùêπùëâùê∑ùê∑ùê¥ùêªùêªùê∑ùêªùëö1ùëö1ùëö1ùëö1ùë¥ùëπùúªùë®ùíÖùëö1ùëö1ùêπùëâùê∑ùê∑ùê¥ùêªùêªùê∑ùêªùëö1ùëö1ùëö1ùëö1ùë¥ùëπùúªùë®ùíÖùëö1ùëö1ùêπùëâùê∑ùê∑ùêªùêªùê∑ùêªùëö1ùëö1ùëö1ùëö2ùë¥ùëπùúªùë®‚Üíùë©ùíÖ+ùüèùëö1ùëö2ùêπùëâùêµùê∑2ùê∑1ùê∑2ùê∑1ùêª1ùêª2ùëö1ùëö1ùë¥ùëπùúªùë®‚Üíùë©ùíÖ+ùüèùëö1ùëö1ùêª1ùëö21ùëö25ùëö22ùëö26ùëö1ùëö1ùëö1ùëö1ùëö23ùëö27ùëö24ùëö28ùêª2ùê∑ùêªùëö1ùëö1ùêµùêπùëâùê∑ùê∑2ùê∑1ùê∑2ùê∑1ùêª1ùêª2ùëö21ùëö22ùë¥ùëπùúªùë®‚Üíùë©‚Üíùë¨ùíÖ+ùüêùëö21ùëö22ùêª1ùëö31ùëö35ùëö32ùëö36ùëö21ùëö22ùëö21ùëö22ùëö33ùëö37ùëö34ùëö38ùêª2ùêªùëö2ùëö3ùê∏ùêπùëâab13

FIG. 8. The perfect binary tree model of our protocol and the safe path. The green (orange) nodes in the tree
represent the multicast rounds with honest (dishonest) primaries. Beside each node, the left number indicates the number
of honest backups of this tree node, and the right number indicates the number of dishonest backups. The safe paths are
represented by the red arrows. (a) and (b) illustrate the safe path before reaching the intermediate tree node. (a) The case
in which the initial primary is honest. By the deÔ¨Ånition of a safe path, the honest initial primary is a safe node, denoted by
P, and there is only one safe path in the whole process. (b) The case where the initial primary is dishonest and there is more
than one safe path. The safe tree nodes are denoted by P, P(cid:48), P(cid:48)(cid:48) and so on. (c) Illustration of the part of the safe path from
the intermediate tree node Q to the ending tree node. The other tree nodes in the safe path are denoted by K, J, T and so on.

Lemma 3 The safe path ensures that the honest players in the safe tree node can reach consensus on their outputs.

Proof 3 In the broadcasting phase, by Lemma 1, the consistency of the message from the safe node‚Äôs primaries can
be protected. Considering one of the rounds of the safe tree node, the honest primary multicasts the message m1.
For simplicity, the following discussion only analyses the route starting with this round. The analysis for the other
rounds of the safe node is similar. On the safe path, the honest players in the subsequent rounds will receive and then
multicast the message m1.

Depth(n‚Äô-3,n‚Äô)(n‚Äô-1,n‚Äô)(n‚Äô,n‚Äô)¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑(n‚Äô-2,n‚Äô)(n‚Äô-2,n‚Äô-1)(n‚Äô-2,n‚Äô-1)(n‚Äô-1,n‚Äô-1)(n‚Äô-1,n‚Äô-1)(n‚Äô-2,n‚Äô-1)(n‚Äô,n‚Äô-1)(n‚Äô,n‚Äô-2)(n‚Äô,n‚Äô-3)(n‚Äô-1,n‚Äô-2)(n‚Äô-1,n‚Äô-2)(n‚Äô-1,n‚Äô-2)d‚Äôd‚Äô+1d‚Äô+3¬∑¬∑¬∑d‚Äô+2321Depth¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑(n-f-1,f)(n-f-2,f)(n-f-1,f-1)(n-f-1,f-2)(n-f-3,f)(n-f-2,f-1)(n-f-2,f-1)¬∑¬∑¬∑ùë∑(n-f,f-1)¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑(n-f-1,f-1)(n-f,f-2)(n-f,f-3)(n-f,f-4)(n-f-2,f-1)(n-f-3,f-1)(n-f-1,f-2)(n-f-1,f-2)(n-f-2,f-2)(n-f-2,f-2)(n-f-2,f-2)(n-f-1,f-3)(n-f-1,f-3)(n-f-1,f-3)3241Depth¬∑¬∑¬∑ùë∑‚Ä≤ùë∑ùë∑‚Ä≤‚Ä≤ùë∏ùë±ùë≤ùëªùë¥ùëΩabc14

In the gathering phase, the message deducing process analysed below demonstrates the consistency of the Ô¨Ånal
outputs. From the safe tree node P to the intermediate tree node Q, more than half of the elements from the left
(honest) child node appear in the gathering lists of each tree node. From the intermediate tree node Q to the ending
tree node, if a tree node is honest, then in each gathering list of this node, the number of elements from the left child
node is the same as that of the right child; if a tree node is dishonest, then in each gathering list of this node, the
honest child node contributes one more element than the dishonest child node. Note that the output of each tree
node in the safe path is determined by the tree nodes that are also on the safe path. Thus, all other branches in the
binary tree can be ignored.

Our aim is to prove that in each tree node from the ending tree node to the safe tree node, more than half of the
elements of each gathering list are always consistent, and thus the outputs of each node are always consistent during
the recursion gathering process. We consider the two situations in Fig. 9: (a) the ending tree node O is honest, and
(b) the ending tree node O is dishonest. We denote the left (right) child tree node of O as OL (OR).

(a). The ending tree node O is honest. We Ô¨Årst analyse the outputs from the initial gathering lists of OL
and OR. The message of OL is m1, which is also the message that is multicast in the safe node. In the bottom layer,
each backup has the same gathering list where all the elements are m1, which is obtained directly from the bottom
broadcasting list. Thus, the honest backups of OL have the same output. The primaries of OR multicast m1 to the
honest backups. Since the honest backups contribute one element more than the dishonest backups in each gathering
list, message m1 is the majority. Thus, each honest backup of OR has the same output m1. That is, the outputs
from OL and OR are all m1. Then, the honest backups of the ending tree node O have the same output deduced
from their consistent gathering lists.

Considering the consistent outputs of the ending tree node, consistency can always be held on the safe path. Suppose
that node U is the dishonest parent tree node of O at d = f ‚àí 2. The output of each gathering list of U is determined
by elements from O. Thus, the outputs are also m1. On the safe path, the parent tree node of U has at least half of
the elements, which are m1, in each gathering list. Moreover, for a certain backup‚Äôs gathering list, there is also one
element from the backup himself or herself, which is the message he or she received directly from the corresponding
primary. This element is also m1 by Lemma 1. Therefore, more than half of the elements in each gathering list are
m1, and the output is m1. Following the above process until the intermediate tree node Q is reached, we can see
that all the outputs of the tree nodes on the safe path are m1. Finally, the honest backups of node Q have the same
output m1.

In the tree nodes from P to Q, for each gathering list, more than half of the elements are m1. Finally, in the safe

tree node P, all honest players in each round will reach consensus.

(b). The ending tree node O is dishonest. The output of O is determined by the elements from OL. We Ô¨Ånd
that these elements are all m1 since OL is honest. Thus, the backups in the ending tree node O have the same output
m1. Similar to the analysis in (a), each backup of the intermediate node Q outputs m1. Therefore, all the honest
players in the safe tree node P have consistent outputs m1.

Theorem 1 For an n-player system with f malicious players, our QBA protocol can reach consensus with a fault
tolerance of n ‚â• 2f + 1.

Proof 4 We start with n = 2f + 1. We analyse it according to whether the initial primary is honest or dishonest.

(a). The initial primary is honest. By DeÔ¨Ånition 1, the root tree node is not only the safe tree node but also
the immediate tree node. From Lemma 3, all honest players in the initial round can reach consensus, which satisÔ¨Åes
the Byzantine conditions IC1 and IC2.

(b). The initial primary is dishonest. As shown in Fig. 8b, the dishonest initial primary S can arbitrarily
deliver diÔ¨Äerent messages to diÔ¨Äerent forwarders at depth 1. At depth 2, the left (honest) child tree node is a safe tree
node that starts a safe path. The primaries of the right (dishonest) child tree node M can execute colluding attacks
and deliver conÔ¨Çicting messages as described in Lemma 2. The left child tree node P(cid:48) of M is another safe tree node
that starts another safe path. Similarly, the tree node P(cid:48)(cid:48) is also a safe tree node that starts another safe path, and
so on.

One of the honest player‚Äôs outputs in the initial round is m1

S = majority(G1

S), where G1

S = (cid:8)mS‚ÜíR1 , mS‚ÜíR2 ¬∑ ¬∑ ¬∑ , mS‚ÜíRn‚àí1

(cid:9).

By Proof 3, although the outputs of the tree node P may be diÔ¨Äerent, the honest players reach consensus on each
of these outputs since P is a safe tree node. Thus, in the gathering list G1
S, the f + 1 elements from the safe tree
node P are consistent among the honest backups. Next, we discuss the f ‚àí 1 elements of the list G1
S from node M,
as shown in Fig. 8b. Similar to the above process, we can Ô¨Ånd that all honest backups reach consensus on the f
elements from the safe tree node P(cid:48), so we must consider the f ‚àí 2 elements of the list G2
S‚ÜíB from node V, and
so on. After we continuously choose the right child tree node at the next depth, the dishonest backups of the tree
nodes will continuously be reduced by one while the number of honest backups will not change. When we reach
depth f , in the dishonest leaf node, only the primary is dishonest and all the backups are honest. Thus, there are

15

FIG. 9. The ending tree node of a safe path at the penultimate depth and its child tree nodes. The yellow Ô¨Ågure
of the binary tree presents the ending tree node of a safe path, denoted by O, and its left (right) child tree node is denoted by
OL (OR). The messages contributed by the honest (dishonest) backups are marked by green (orange). The messages recorded
in the broadcasting list are represented in the table. The gathering list and the corresponding outputs are also presented beside
the tables. (a) The ending tree node is honest. (b) The ending tree node is dishonest.

no colluding attacks. Although the outputs of diÔ¨Äerent rounds may be diÔ¨Äerent, the backups of the same round can
obtain the consistent outputs. In the dishonest parent of this leaf node, each gathering list has one element from the
this dishonest leaf node (right child node) and f ‚àí 1 elements from the honest leaf node (left child node). The left
child node is also a safe node and these f ‚àí 1 elements are also consistent. Thus each honest backup of this dishonest
parent tree node also obtain a consistent output. Following the above recursion process, we can Ô¨Ånd that the honest
backups in each round of the above path always have the same gathering lists. The consistent outputs from each safe
node indirectly or directly lead to the eventual consistency of the elements that make up each gathering list of d = 1.
In the initial round, the elements in a list may be diÔ¨Äerent from each other, but the gathering lists of the honest
players are the same, regardless of the messages delivered by the dishonest primary. Finally, all the honest players
reach consensus and output consistent messages, which satisÔ¨Åes the condition IC2.

In summary, we prove that our protocol can satisfy the two Byzantine conditions, IC1 and IC2, to reach Byzantine

agreement when n ‚â• 2f + 1.

If n ‚â§ 2f , then the safe paths appear too late in the binary tree model. The consistency of the delivered messages
cannot be guaranteed in the tree nodes before the safe path. For example, when n = 2f and the initial primary is
honest. The root tree node is honest, but the number of honest backups is f ‚àí 1 and the number of dishonest backups
is f . Therefore, the root tree node is no longer a safe tree node. In fact, the minimum depth at which we can Ô¨Ånd
a safe tree node is d = 4 in the binary tree. There are two safe nodes, denoted as P1 and P2, that begin their safe
paths at depth 4. P1 and P2 can be found by the following steps. P1: After choosing the right child tree node twice,
the left tree node at depth 4 is P1. P2: First choosing the left child of the root tree node Ô¨Årst, and then choosing the
right tree node, Ô¨Ånally the left tree node at depth 4 is P2. By Lemma 2, the message multicast in P1 can conÔ¨Çict with
the message delivered by the initial primary. Suppose the messages multicast by the initial primary are m1 and the
conÔ¨Çicting messages delivered by dishonest players are m2. Then the backups of tree node P1 will consistently output
m2. The backups of the tree node P2 will still consistently output m1. After several rounds of counting, the numbers
of messages m1 and m2 in his or her own gathering list for the initial round are f ‚àí 1 and f , respectively. Then, all

ùê∑ùê∑ùêªùêªùêªùê∑ùêªùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùêπùëâùëÇùêøùëö1ùëö2ùê∑ùê∑ùêªùêªùê∑ùêªùëö1ùëö2ùëö1ùëö2ùêπùëâùê∑ùëÇùëÖùê∫Œ∂ùëÇùëì‚àí1,ùêª={ùëö1,ùëö1,‚Ä¶,ùëö1Ôºåùëö1,ùëö1,‚Ä¶,ùëö1}ùëöŒ∂ùëÇùëì‚àí1,ùêª=majority{ùê∫Œ∂ùëÇùëì‚àí1,ùêª}=ùëö1ùëÇùëÇùêøùëÇùëÖùëöŒ∂ùëÇùëôùëì,ùêªùëöŒ∂ùëÇùëÖùëì,ùêªùëÇùëÇùêøùê∫Œ∂ùëÇùëì‚àí1,ùêª={ùëö1,ùëö1,‚Ä¶,ùëö1,ùëö2,‚Ä¶,ùëö2}ùëöŒ∂ùëÇùëì‚àí1,ùêª=majority{ùê∫Œ∂ùëÇùëì‚àí1,ùêª}=ùëö1ùëöŒ∂ùëÇùêøùëì,ùêªabùëöŒ∂ùëÇùêøùëì,ùêª=majority{ùê∫Œ∂ùëÇùêøùëì,ùêª}=ùëö1={ùëö1,ùëö1,‚Ä¶,ùëö1,ùëö1,ùëö1,‚Ä¶,ùëö1}ùê∫Œ∂ùëÇùêøùëì,ùêª=ùêµŒ∂ùëÇùêøùëì,ùêªùëöŒ∂ùëÇùëÖùëì,ùêª=majority {ùê∫Œ∂ùëÇùëÖùëì,ùêª}=ùëö1={ùëö1,ùëö1,‚Ä¶,ùëö1,ùëö2,‚Ä¶,ùëö2}ùê∫Œ∂ùëÇùëÖùëì,ùêª=ùêµŒ∂ùëÇùëÖùëì,ùêªùê∑ùê∑ùêªùêªùêªùê∑ùêªùëö1ùëö1ùëö1ùëö1ùëö1ùëö1ùêπùëâùëÇùêøùëöŒ∂ùëÇùêøùëì,ùêª=majority{ùê∫Œ∂ùëÇùêøùëì,ùêª}=ùëö1={ùëö1,ùëö1,‚Ä¶,ùëö1,ùëö1,ùëö1,‚Ä¶,ùëö1}ùê∫Œ∂ùëÇùêøùëì,ùêª=ùêµŒ∂ùëÇùêøùëì,ùêªthe honest backups in the initial round will output m2, while the honest initial primary outputs m1. Therefore, they
cannot reach consensus. When n < 2f , the situation will undoubtedly worsen.

16

Appendix F: Experimental details

The main program of our protocol including classical communication and computation is realized based on GoLand.
Each participant independently executes the program on their own personal computer and reaches the consistent
output independently. The environment of each player is in OS Win 10, CPU i7-1165G7 @ 2.80 GHz, RAM 16.0
GB. Additionally, we provide the pseudocode for our protocol according to the broadcasting and gathering phases,
as shown in Algorithm 1 and Algorithm 2. In addition, the decentralized digital ledger is shown in Fig. 10, which is
reached consensus on by the users in the experiment.

Algorithm 1: Multicast process

Œ∂ ‚Üê broadcasting list
Œ∂ ‚Üê gathering list

1 Bd
2 Gd
3 N odelist ‚Üê the set of participating players
4 Œ∂ ‚Üê the subscript tracking the route of the message broadcasting
5 Function Multicast{mes,d}:
6

N odelist ‚Üê all nodes except the primary
for Ri ‚Üê N odelist [0] to N odelist [n ‚àí d ‚àí 1] do

7
8

9

10

11
12

13

14

15
16

17

18
19

20

21

22

23

24

25

26

As a primary:
Together with a forwarder Ri multicast the message mesŒ∂ via QDS to all other backups (veriÔ¨Åers)
As a forwarder:
Perform the coherence checking and forward the valid message from the primary via QDS to all the veriÔ¨Åers
mes ‚Üê the valid message mesŒ∂
As a veriÔ¨Åer:
Upon receiving a valid message mesŒ∂‚ÜíRi , the backup adds mesŒ∂ into its own broadcasting list Bd
Œ∂
if d < f then

The forwarder executes M ulticast{mes, d + 1}

else

As a veriÔ¨Åer: gathering list Gd

Œ∂ ‚Üê broadcasting list Bd
Œ∂

end

end
mŒ∂ ‚Üê majority(Gd
Œ∂ )
add all mŒ∂ to Gd‚àí1
Œ∂
if d (cid:54)= 1 then
return Gd‚àí1

Œ∂

(Œ∂ is updated by deleting the record of the last player)

else

F inalM essage ‚Üê majority(G1

S)

end
return F inalM essage

27
28
29 End Function

Algorithm 2: Protocol 1
input : An initial primary chosen randomly from n players distributes a massage mesS to all other n ‚àí 1 backups
output: All honest players output the consistent messages, F inalM essage (= mesS if the initial primary is honest)

1 mesS ‚Üê the initial primary inputs some messages
2 d ‚Üê 1
3 A primary chosen randomly from n players executes M ulticast{mesS, d}
4 All nodes output their own value of F inalM essage

Then we introduce the detailed information of the experimental setup to generate the secret keys. The master laser
generates phase-randomized 1.6 ns-wide laser pulses with a repetition rate of 96 MHz at 1550.12 nm. Two pairs of
pulses with relative phases 0 and œÄ at a 2 ns time delay generated by an asymmetric interferometer are injected into
two slave lasers through the optical circulator, respectively. By controlling the trigger electrical signal of two slave

17

FIG. 10. The digital ledger for transmission in the experiment. We convert the digital ledger into a binary string of
bits. The binary string of bits are the actual message we transmit in the experiment. We denote the correct string as m1, and
denote the conÔ¨Çicting messages delivered by dishonest players as m2, m3 and so on.

lasers, Alice randomly prepares quantum states in the Z (time) and X (phase) bases by using 400 ps-wide slave laser
pulses. The programmable delay chip with a 10 ps timing resolution is used to calibrate the time consistency. The
spectral consistency is naturally satisÔ¨Åed because of the laser seeding technique [60]. A 50 GHz nominal bandwidth
Ô¨Åber Bragg grating is used to remove extra spurious emission and precompensate for the pulse broadening in the
Ô¨Åber transmission. The 2 ns-wide synchronization pulses with repetition rates of 100 kHz are transmitted via the
quantum channel using multiplexed wavelength division. The intensities are set as ¬µ = 0.40, ŒΩ = 0.20, œâ = 0.4 and
0 with the corresponding probabilities p¬µ = 0.60, pŒΩ = 0.20, pœâ = 0.15 and p0 = 0.05, respectively. If trigger signal
is not provided to the slave laser, the vacuum state is generated . The amplitude modulator generates two diÔ¨Äerent
intensities, and the intensity of œâ is double that of ŒΩ (œâ = 2ŒΩ) since it has two pulses in the X basis.

At the receiving end, a 30:70 biased beam splitter is used to perform passive basis detection after a wavelength
division demultiplexer. A probability of 30% is measured in the phase basis and the probability of 70% is used to
receive in the time basis. A Faraday-Michelson interferometer is used for the phase measurement, in which phase drift
is compensated in real time by using the phase shifter. The total insertion losses of the time and phase bases are 4.25
and 8 dB, respectively. The eÔ¨Éciency of single-photon detectors is 20% at a 160 dark count per second. To decrease
the after-pulse probability, we set the dead times to 10 ¬µs for the links.

The length of the Ô¨Ånal key, which is Œµcor-correct and Œµsec-secret, can be expressed by [52]

(cid:96) = szz

0 + szz
1

(cid:104)
1 ‚àí h

(cid:16)

œÜ

zz
1

(cid:17)(cid:105)

‚àí ŒªEC ‚àí log2

2
Œµcor

‚àí 6 log2

22
Œµsec

,

(F1)

where h(x) := ‚àíx log2 x ‚àí (1 ‚àí x) log2(1 ‚àí x), and x (x) denotes the upper (lower) bound of the observed value x.
Using the decoy-state method for Ô¨Ånite sample sizes, the expected number of vacuum events szz‚àó
and single-photon

0

Transaction Number: Date:RECEIPT123123XX/XX/2022 Page 1 of 1X111111AliceStudent Number:PAYMENT ACTIVITY:Current Payment / (Refund)$ 10,000.00Visa ****************Total Current Payment / (Refund):$ 10,000.00On Account$ (3,000.00)Invoice 1$ (3,000.00)Invoice 2$ (3,000.00)Invoice 3$ (750.00)Invoice 4$ (250.00)Invoice 5Total On Account:$ (10,000.00)TOTAL PAYMENTS / (REFUNDS):$ 0.00Nanjing Universityevents szz‚àó

1

can be expressed as

and

szz‚àó
1 ‚â•

szz‚àó
0 ‚â• (e‚àí¬µp¬µ + e‚àíŒΩpŒΩ)

nz‚àó
0
p0

,

¬µ2e‚àí¬µp¬µ + ¬µŒΩe‚àíŒΩpŒΩ
¬µŒΩ ‚àí ŒΩ2
ŒΩ2

¬µ2 e¬µ nz‚àó

¬µ
p¬µ

(cid:32)
eŒΩ nz‚àó
ŒΩ
pŒΩ

‚àí

√ó

‚àí

¬µ2 ‚àí ŒΩ2
¬µ2

nz‚àó
0
p0

(cid:33)

,

18

(F2)

(F3)

k

respectively. Here nz(x)
is the count of k (k ‚àà {¬µ, ŒΩ, œâ}) intensity pulse measured in the Z(X) basus, and x‚àó is the
expected value of observed value x. We use the variant of the ChernoÔ¨Ä bound [61] to obtain the lower and upper
bounds, x‚àó = x + Œ≤ + (cid:112)2Œ≤x + Œ≤2 and x‚àó = x ‚àí Œ≤
2Œ≤x + Œ≤2
The expected value of the number of single-photon events sxx‚àó

4 , where Œ≤ = ln 22
Œµsec

in œáœâ can be given by

2 ‚àí

(cid:113)

.

1

sxx‚àó
1 ‚â•

¬µœâe‚àíœâpœâ
¬µŒΩ ‚àí ŒΩ2

(cid:32)
eŒΩ nx‚àó
ŒΩ
pŒΩ

‚àí

ŒΩ2

¬µ2 e¬µ nx‚àó

¬µ
p¬µ

‚àí

¬µ2 ‚àí ŒΩ2
¬µ2

nx‚àó
0
p0

(cid:33)

.

(F4)

Additionally, the expected number of bit errors txx‚àó

œâ ‚àítxx
0 ,
nx‚àó
0 . For a given expected value x‚àó, the upper and lower bounds of the observed value are given
2Œ≤x‚àó + Œ≤2
2Œ≤x‚àó, respectively. Using random sampling without replacement, the

associated with the single-photon event in œáœâ is txx

1 ‚â§ mx

‚àö

1

4 and x = x‚àó ‚àí

where txx

0 = e‚àíœâpœâ
2p0
(cid:113)
by x = x‚àó + Œ≤
2 +
phase error rate in the Z basis is

zz
1 =

œÜ

txx
1
sxx
1

+ Œ≥U

(cid:18)

1 , sxx
szz
1 ,

txx
1
sxx
1

,

Œµsec
22

(cid:19)

,

(F5)

where Œ≥U (n, k, Œª, (cid:15)) =

(cid:114)

(1‚àí2Œª)AG

n+k +

A2G2
(n+k)2 +4Œª(1‚àíŒª)G

2+2 A2G
(n+k)2

, A = max {n, k} and G = n+k

nk ln

n+k
2œÄnkŒª(1‚àíŒª)(cid:15)2 .

ACKNOWLEDGMENTS

We thank Y. Fu and M.-G. Zhou for their valuable discussions. We gratefully acknowledge the supports from the
Natural Science Foundation of Jiangsu Province (No. BK20211145), the Fundamental Research Funds for the Central
Universities (No. 020414380182), the Key Research and Development Program of Nanjing Jiangbei New Aera (No.
ZDYD20210101), the Program for Innovative Talents, and Entrepreneurs in Jiangsu (No. JSSCRC2021484).

AUTHOR CONTRIBUTIONS

H.-L.Y. and Z.-B.C. conceived the research. C.-X. W., R.-Q. G. and H.-L.Y. developed the quantum Byzantine
agreement. R.-Q. G., C.-X. W. and H.-L.Y. provided the security proof. Y. B., Y.-S.L. and H.-L.Y. performed
the quantum communication network. R.-Q. G., C.-X. W. and H.-L.Y. performed the quantum consensus of digital
ledger. C.-X. W., R.-Q. G. and H.-L.Y. co-wrote the manuscript, with input from the other authors. All authors
have discussed the results and proofread the manuscript.

[1] Extance, A. The future of cryptocurrencies: Bitcoin and beyond. Nature 526, 21‚Äì23 (2015).
[2] Lamport, L., Shostak, R. & Pease, M. The Byzantine generals problem. ACM Transactions on Programming Languages

and Systems 4, 382‚Äì401 (1982).

[3] Castro, M., Liskov, B. et al. Practical Byzantine fault tolerance. In OSDI, vol. 99, 173‚Äì186 (1999).

19

[4] Castro, M. & Liskov, B. Practical Byzantine fault tolerance and proactive recovery. ACM Trans. Comput. Syst. 20,

398‚Äì461 (2002).

[5] Aublin, P.-L., Mokhtar, S. B. & Qu¬¥ema, V. RBFT: Redundant Byzantine fault tolerance. In 2013 IEEE 33rd International

Conference on Distributed Computing Systems, 297‚Äì306 (2013).

[6] Miller, A., Xia, Y., Croman, K., Shi, E. & Song, D. The honey badger of BFT protocols. In Proceedings of the 2016 ACM
SIGSAC Conference on Computer and Communications Security, CCS ‚Äô16, 31‚Äì42 (Association for Computing Machinery,
2016).

[7] Yin, M., Malkhi, D., Reiter, M. K., Gueta, G. G. & Abraham, I. HotstuÔ¨Ä: BFT consensus with linearity and responsiveness.
In Proceedings of the 2019 ACM Symposium on Principles of Distributed Computing, PODC ‚Äô19, 347‚Äì356 (Association for
Computing Machinery, 2019).

[8] Guo, B., Lu, Z., Tang, Q., Xu, J. & Zhang, Z. Dumbo: Faster asynchronous BFT protocols. In Proceedings of the 2020
ACM SIGSAC Conference on Computer and Communications Security, CCS ‚Äô20, 803‚Äì818 (Association for Computing
Machinery, 2020).

[9] Lu, Y., Lu, Z., Tang, Q. & Wang, G. Dumbo-MVBA: Optimal multi-valued validated asynchronous Byzantine agreement,
revisited. In Proceedings of the 39th Symposium on Principles of Distributed Computing, PODC ‚Äô20, 129‚Äì138 (Association
for Computing Machinery, 2020).

[10] Pease, M., Shostak, R. & Lamport, L. Reaching agreement in the presence of faults. Journal of the ACM 27, 228‚Äì234

(1980).

[11] Dolev, D., Halpern, J. Y. & Strong, H. R. On the possibility and impossibility of achieving clock synchronization. Journal

of Computer and System Sciences 32, 230‚Äì250 (1986).

[12] Fischer, M. J., Lynch, N. A. & Merritt, M. Easy impossibility proofs for distributed consensus problems. Distributed

Computing 1, 26‚Äì39 (1986).

[13] Fitzi, M., Garay, J., Maurer, U. & Ostrovsky, R. Advances in cryptology-crypto 2001: Proceedings of the 21-st annual
international cryptology conference, Santa Barbara, CA, 2001. Lecture Notes in Computer Science (Springer, Berlin, New
York, 2001) (2001).

[14] Menezes, A. J., Van Oorschot, P. C. & Vanstone, S. A. Handbook of applied cryptography (CRC press, 2018).
[15] Shor, P. Algorithms for quantum computation: discrete logarithms and factoring. In Proceedings 35th Annual Symposium

on Foundations of Computer Science, 124‚Äì134 (1994).

[16] Grover, L. K. Quantum mechanics helps in searching for a needle in a haystack. Phys. Rev. Lett. 79, 325 (1997).
[17] Arute, F. et al. Quantum supremacy using a programmable superconducting processor. Nature 574, 505‚Äì510 (2019).
[18] Fedorov, A. K., Kiktenko, E. O. & Lvovsky, A. I. Quantum computers put blockchain security at risk. Nature 563,

465‚Äì467 (2018).

[19] Wei, S., Li, H. & Long, G. A full quantum eigensolver for quantum chemistry simulations. Research 2020, 1486935 (2020).
[20] Fern¬¥andez-Caram`es, T. M. & Fraga-Lamas, P. Towards post-quantum blockchain: A review on blockchain cryptography

resistant to quantum computing attacks. IEEE Access 8, 21091‚Äì21116 (2020).

[21] Zhou, M.-G. et al. Experimental quantum advantage with quantum coupon collector. Research 2022, 9798679 (2022).
[22] Huang, S., Yin, H.-L., Chen, Z.-B. & Wu, S. Quantum-accelerated algorithms for generating random primitive polynomials

over Ô¨Ånite Ô¨Åelds. arXiv preprint arXiv:2203.12884 (2022).

[23] Kiktenko, E. O. et al. Quantum-secured blockchain. Quantum Sci. Technol. 3, 035004 (2018).
[24] Fitzi, M., Gisin, N. & Maurer, U. Quantum solution to the Byzantine agreement problem. Phys. Rev. Lett. 87, 217901

(2001).

[25] Gaertner, S., Bourennane, M., Kurtsiefer, C., Cabello, A. & Weinfurter, H. Experimental demonstration of a quantum

protocol for Byzantine agreement and liar detection. Phys. Rev. Lett. 100, 070504 (2008).

[26] Fitzi, M., Gottesman, D., Hirt, M., Holenstein, T. & Smith, A. Detectable byzantine agreement secure against faulty

majorities. In Proceedings of the twenty-Ô¨Årst annual symposium on Principles of distributed computing, 118‚Äì126 (2002).

[27] Iblisdir, S. & Gisin, N. Byzantine agreement with two quantum-key-distribution setups. Phys. Rev. A 70, 034306 (2004).
[28] Neigovzen, R., Rod¬¥o, C., Adesso, G. & Sanpera, A. Multipartite continuous-variable solution for the Byzantine agreement

problem. Phys. Rev. A 77, 062307 (2008).

[29] Rahaman, R., Wie¬¥sniak, M. & ÀôZukowski, M. Quantum Byzantine agreement via Hardy correlations and entanglement

swapping. Phys. Rev. A 92, 042302 (2015).

[30] Smania, M., Elhassan, A. M., Tavakoli, A. & Bourennane, M. Experimental quantum multiparty communication protocols.

npj Quantum Inf. 2, 16010 (2016).

[31] Ben-Or, M. & Hassidim, A. Fast quantum Byzantine agreement.

In Proceedings of the Thirty-Seventh Annual ACM

Symposium on Theory of Computing, 481‚Äì485 (Association for Computing Machinery, New York, NY, USA, 2005).
[32] Taherkhani, M. A., Navi, K. & Van Meter, R. Resource-aware system architecture model for implementation of quantum

aided Byzantine agreement on quantum repeater networks. Quantum Sci. Technol. 3, 014011 (2018).

[33] Sun, X., Kulicki, P. & Sopek, M. Multi-party quantum Byzantine agreement without entanglement. Entropy 22, 1152

(2020).

[34] Wang, W., Yu, Y. & Du, L. Quantum blockchain based on asymmetric quantum encryption and a stake vote consensus

algorithm. Sci. Rep. 12, 8606 (2022).

[35] Gao, F., Guo, F.-Z., Wen, Q.-Y. & Zhu, F.-C. Comment on ‚Äúexperimental demonstration of a quantum protocol for

byzantine agreement and liar detection‚Äù. Phys. Rev. Lett. 101, 208901 (2008).

20

[36] Gaertner, S., Bourennane, M., Kurtsiefer, C., Cabello, A. & Weinfurter, H. Gaertner et al. reply:. Phys. Rev. Lett. 101,

208902 (2008).

[37] Kleinberg, J. & Tardos, E. Algorithm design (Pearson Education India, 2006).
[38] Yin, H.-L., Fu, Y. & Chen, Z.-B. Practical quantum digital signature. Phys. Rev. A 93, 032316 (2016).
[39] Amiri, R., Wallden, P., Kent, A. & Andersson, E. Secure quantum signatures using insecure quantum channels. Phys.

Rev. A 93, 032325 (2016).

[40] Puthoor, I. V., Amiri, R., Wallden, P., Curty, M. & Andersson, E. Measurement-device-independent quantum digital

signatures. Phys. Rev. A 94, 022328 (2016).

[41] Yin, H.-L. et al. Experimental quantum digital signature over 102 km. Phys. Rev. A 95, 032334 (2017).
[42] Roberts, G. et al. Experimental measurement-device-independent quantum digital signatures. Nat. Commun. 8, 1098

(2017).

[43] Yin, H.-L. et al. Experimental measurement-device-independent quantum digital signatures over a metropolitan network.

Phys. Rev. A 95, 042338 (2017).

[44] Collins, R. J. et al. Experimental demonstration of quantum digital signatures over 43 dB channel loss using diÔ¨Äerential

phase shift quantum key distribution. Sci. Rep. 7, 1‚Äì8 (2017).

[45] Roehsner, M.-C., Kettlewell, J. A., BatalhÀúao, T. B., Fitzsimons, J. F. & Walther, P. Quantum advantage for probabilistic

one-time programs. Nature Commun. 9, 5225 (2018).

[46] An, X.-B. et al. Practical quantum digital signature with a gigahertz BB84 quantum key distribution system. Opt. Lett.

44, 139‚Äì142 (2019).

[47] Thornton, M., Scott, H., Croal, C. & Korolkova, N. Continuous-variable quantum digital signatures over insecure channels.

Phys. Rev. A 99, 032341 (2019).

[48] Lu, Y.-S. et al. EÔ¨Écient quantum digital signatures without symmetrization step. Opt. Express 29, 10162‚Äì10171 (2021).
[49] Richter, S. et al. Agile and versatile quantum communication: Signatures and secrets. Phys. Rev. X 11, 011038 (2021).
[50] Weng, C.-X. et al. Secure and practical multiparty quantum digital signatures. Opt. Express 29, 27661‚Äì27673 (2021).
[51] Yin, H.-L. et al. Experimental quantum secure network with digital signatures and encryption.

arXiv preprint

arXiv:2107.14089 (2021).

[52] Yin, H.-L. et al. Experimental composable security decoy-state quantum key distribution using time-phase encoding. Opt.

Express 28, 29479‚Äì29485 (2020).

[53] Xu, F., Ma, X., Zhang, Q., Lo, H.-K. & Pan, J.-W. Secure quantum key distribution with realistic devices. Rev. Mod.

Phys. 92, 025002 (2020).

[54] Pirandola, S. et al. Advances in quantum cryptography. Adv. Opt. Photon. 12, 1012‚Äì1236 (2020).
[55] Liu, W.-B. et al. Homodyne detection quadrature phase shift keying continuous-variable quantum key distribution with

high excess noise tolerance. PRX Quantum 2, 040334 (2021).

[56] Lo, H.-K., Curty, M. & Qi, B. Measurement-device-independent quantum key distribution. Phys. Rev. Lett. 108, 130503

(2012).

[57] Lucamarini, M., Yuan, Z. L., Dynes, J. F. & Shields, A. J. Overcoming the rate‚Äìdistance limit of quantum key distribution

without quantum repeaters. Nature 557, 400‚Äì403 (2018).

[58] Xie, Y.-M. et al. Breaking the rate-loss bound of quantum key distribution with asynchronous two-photon interference.

PRX Quantum 3, 020315 (2022).

[59] Krawczyk, H. LFSR-based hashing and authentication. In Annual International Cryptology Conference, 129‚Äì139 (Springer,

1994).

[60] Comandar, L. et al. Quantum key distribution without detector vulnerabilities using optically seeded lasers. Nat. Photonics

10, 312‚Äì315 (2016).

[61] Yin, H.-L. et al. Tight security bounds for decoy-state quantum key distribution. Sci. Rep. 10, 14312 (2020).

