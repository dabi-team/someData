INSTITUTO FEDERAL DE EDUCAÇÃO, CIÊNCIA E TECNOLOGIA
SUL-RIO-GRANDENSE - CAMPUS PASSO FUNDO

CHRISTOFER L. SEGA, ANUBIS G. DE M. ROSSETTO, VALDERI R. Q.
LEITHARDT

PROJETO E IMPLEMENTAÇÃO DE UMA
DAPP PARA ARMAZENAR DADOS DE SAÚDE

DESIGN AND IMPLEMENTATION OF A DAPP
TO STORE HEALTH DATA

2
2
0
2

l
u
J

8

]

R
C
.
s
c
[

1
v
9
1
9
9
0
.
7
0
2
2
:
v
i
X
r
a

Passo Fundo - RS
2022, v1

 
 
 
 
 
 
CHRISTOFER L. SEGA, ANUBIS G. DE M. ROSSETTO, VALDERI R. Q. LEITHARDT

PROJETO E IMPLEMENTAÇÃO DE UMA
DAPP PARA ARMAZENAR DADOS DE SAÚDE

DESIGN AND IMPLEMENTATION OF A DAPP
TO STORE HEALTH DATA

Relatório Técnico referente ao trabalho de conclusão
de curso apresentado ao Curso de Ciências da Com-
putação do Instituto Federal de Educação, Ciência e
Tecnologia Sul-rio-grandense, Campus Passo Fundo,
como requisito parcial para a obtenção do título de
Bacharel em Ciências da Computação.

Passo Fundo - RS
2022, v1

Agradecimentos

A conquista de ﬁnalizar esse trabalho, só foi possível pelo conjunto dos esforços de

várias pessoas, assim agradeço:

A minha mãe Carla e meu pai Claudio por estarem sempre dispostos a fazerem tudo
dentro do alcance para me ajudar e fornecer todo o apoio necessário para continuar a seguir
em frente, mesmo nos momentos mais difíceis.

A minha avó Sulmi, tia Rachel e prima Amanda por estarem presentes me apoiando

e por me ajudarem com toda a questão de mudança de cidade para realizar o curso.

Ao meu irmão Junior, que mesmo longe, me apoiou da forma que conseguia.

A minha orientadora Anubis que durante todo o processo me guiou, instigou e me
motivou para a elaboração deste trabalho, possibilitando que conseguíssemos resultados
incríveis.

Ao meu coorientador Valderi que mesmo distante forneceu o auxílio necessário para

a construção do trabalho.

Aos meus professores do curso de Ciência da Computação que através de seus
ensinamentos e companheirismo, permitiram que eu conseguisse ﬁnalizar este ciclo, em
especial ao professor André pela parceria.

Aos meus amigos que ﬁz durante o trajeto, principalmente ao Bruno, Eliel e William,

sempre apoiando um ao outro para continuar ﬁrme sem desistir da jornada.

Enﬁm, quero agradecer a todas as pessoas que ajudaram de forma direta e indireta

na conquista de ﬁnalizar esse trabalho.

Resumo

Este trabalho apresenta o projeto e implementação de uma aplicação descentralizada
(DApp) que visa garantir a privacidade dos dados relacionados à área da saúde, que são
armazenados e compartilhados dentro de uma rede blockchain. Para tanto é empregado o
uso de criptograﬁa com os algoritmos RSA, ECC e AES. São apresentadas as plataformas, as
tecnologias, as ferramentas e as bibliotecas necessárias para o desenvolvimento, bem como
detalhes da implementação.

Palavras-chave: Blockchain. Criptograﬁa. Dados da saúde; DApp. Privacidade.

Abstract

This work presents the design and implementation of a decentralized application (DApp)
that aims to guarantee the privacy of data related to the health area, which are stored and
shared within a blockchain network. For this, encryption with RSA, ECC and AES algo-
rithms is used. The platforms, technologies, tools and libraries required for development
are presented, as well as implementation details.

Keywords: Blockchain; Cryptography; DApp; Health data; Privacy.

Lista de Ilustrações

transações

Figura 1 – Esquema da arquitetura . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 2 – Diagrama de sequência para o login e busca de arquivos . . . . . . . . . .
Figura 3 – Diagrama de sequência para o envio de arquivos e gerenciamento das
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 4 – Diagrama de sequência para o envio de uma permissão . . . . . . . . . .
Figura 5 – Diagrama de sequência para visualizar arquivos com permissão . . . . .
Figura 6 – Comunicação com o MetaMask . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 7 – Carregando a conta, buscando o ID da rede e dados do contrato . . . . .
Figura 8 – Carregando dados do contrato . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 9 – Enviando dados ao contrato . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 10 – Inicialização do IPFS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 11 – Envio de arquivo para o IPFS . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 12 – Busca arquivo no IPFS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 13 – Gerar Chaves RSA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 14 – Criptografar RSA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 15 – Descriptografar RSA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 16 – Gerar Chaves ECC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 17 – Criptografar ECC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 18 – Descriptografar ECC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 19 – Criptografar AES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 20 – Descriptografar AES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 21 – Tela do MetaMask . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 22 – Tela das chaves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 23 – Tela dos arquivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 24 – Tela das permissões . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Figura 25 – Tela dos arquivos com permissões . . . . . . . . . . . . . . . . . . . . . . .

15
20

21
21
22
23
24
24
25
25
26
26
27
27
27
28
28
29
30
30
31
32
32
33
34

Lista de Abreviaturas e Siglas

ABI

API

CID

DAG

DApp

DDoS

DHT

DNS

DOM

ECC

Application Binary Interface

Application Programming Interface

Content Identiﬁer

Directed Acyclic Graph

Decentralized Application

Distributed Denial of Service

Distributed Hash Table

Domain Name System

Document Object Model

Elliptic Curve Cryptography

ECIES

Elliptic Curve Integrated Encryption Scheme

ETH

EVM

Ether

Ethereum Virtual Machine

HTTPS

Hypertext Transfer Protocol Secure

IPFS

IPNS

JSON

JSX

POW

RPC

RSA

WSS

InterPlanetary File System

InterPlanetary Name System

JavaScript Object Notation

JavaScript XML

Proof-of-Work

Remote Procedure Calling

Rivest-Shamir-Adleman

Windows Sharepoint Services

Sumário

1 INTRODUÇÃO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2 FUNDAMENTOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1 Blockchain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Contratos Inteligentes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Algoritmos de Criptograﬁa . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3.1 RSA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3.2 ECC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3.3 AES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3 TECNOLOGIAS E FERRAMENTAS . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1 Rede Blockchain do Ethereum . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 IPFS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3 Truﬄe Suite . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3.1 Truﬄe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3.2 Ganache . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4 MetaMask . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.5 React . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.6 Node.js . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.7 WEB3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.8 API do Infura . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1

2
2
3
4
4
5
7

8
8
9
10
10
11

11
12
12
13
13

4 DAPP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

15

5 IMPLEMENTAÇÕES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.1 Comunicação com a Blockchain . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2 Comunicação com o IPFS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3 Criptograﬁa . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3.1 RSA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3.2 ECC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3.3 AES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

23
23
25
26
26
27
27

6 INTERFACE DA DAPP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

31

7 CONSIDERAÇÕES FINAIS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

35

Referências . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

36

1 Introdução

1

A Blockchain proposta inicialmente por Nakamoto (2008), permite que os dados
ﬁquem publicamente visíveis para todos na rede blockchain, consequentemente é impor-
tante que essas informações sejam criptografadas antes de serem armazenadas. Desta forma,
é possível garantir a conﬁdencialidade dos dados, pois manter o conteúdo da transação
privado ajudará a reduzir o risco de vinculação do pseudônimo a identidade real do usuá-
rio da Blockchain, o que é fundamental para promover o compartilhamento baseado na
necessidade de saber (ZHANG; XUE; LIU, 2019).

Este trabalho traz o detalhamento do projeto e da implementação de uma arquitetura
que foi proposta para garantir a privacidade dos dados relacionados à área da saúde que são
armazenados dentro de uma rede blockchain e no IPFS, de maneira descentralizada, através
do uso de criptograﬁa com os algoritmos Rivest-Shamir-Adleman (RSA), ECC e Advanced
Encryption Standard (AES).

A arquitetura prevê seis componentes que são: usuário, Dapp, MetaMask, Blockchain,
IPFS e criptograﬁa. O objetivo deste trabalho é trazer os fundamentos para a proposta da
arquitetura, as ferramentas que foram utilizadas na implementação, bem como detalhar
como foram realizadas as comunicações entre estes componentes. Cabe ressaltar que os
algoritmos RSA e ECC tem a mesma função, assim, foram desenvolvidas bibliotecas de
solução com ambos os algoritmos para poder conduzir uma avaliação sobre o impacto
destes na arquitetura. Já o algoritmo AES é utilizado para fazer a criptograﬁa do arquivo a
ser enviado para o IPFS. Portanto este documentos traz um maior detalhamento quanto a
implmentação e demonstra protótipos da interface desenvolvida para interação do usuário.

Este documento está organizado da seguinte forma: a primeira parte aborda os
fundamentos das tecnologias empregadas, bem como as ferramentas utilizadas. A segunda
parte apresenta a arquitetura proposta. Na terceira parte traz um detalhamento quanto ao
desenvolvimento da aplicação. Por ﬁm, são apresentadas as conclusões obtidas a partir da
proposta e implementação da arquitetura, além da realização de um apontamento para os
próximos passos a serem realizados.

2

2 Fundamentos

2.1 Blockchain

A blockchain foi originalmente introduzida, ou teve maior reconhecimento, quando
Nakamoto em seu trabalho propôs um sistema ﬁnanceiro utilizando a blockchain para
registrar todas as transferências da moeda digital Bitcoin de forma segura e conﬁável (FENG
et al., 2019).

Essa tecnologia é como um livro-razão descentralizado, distribuído e imutável, for-
mado por uma coleção de registros que são criptograﬁcamente vinculados, esta coleção é
mais conhecida como corrente de blocos que armazenam transações ou eventos (HEWA;
YLIANTTILA; LIYANAGE, 2021). Este livro-razão é compartilhado com todos os membros
participantes (nós) da rede blockchain.

As transações que são realizadas entre os membros de uma blockchain devem ser
aprovadas pelos nós mineradores antes de serem conﬁrmadas e adicionadas a rede block-
chain. Dessa forma, para iniciar o processo de mineração, a transação é transmitida a todos
os nós da rede e os nós que são mineradores vão organizar as transações em um bloco,
veriﬁcar as transações no bloco e transmitir o bloco e a sua veriﬁcação usando um protocolo
de consenso, por exemplo o Proof of Work (POW), para obter a aprovação da rede (ZHANG;
XUE; LIU, 2019). Quando os demais nós veriﬁcarem se todas as transações contidas no
bloco são válidas, o bloco pode ser adicionado a blockchain através de uma função hash
criptográﬁca que conecta os blocos da estrutura, onde o hash do bloco n está vinculado ao
hash do bloco n+1 (OCHÔA et al., 2019).

Dentre as características da blockchain, as mais importantes segundo Hewa, Yliant-

tila e Liyanage (2021) são:

• Descentralização: concede autoridade para os membros da rede, garantindo redun-
dância em contraste com os sistemas centralizados operados por um terceiro conﬁável.
A descentralização reduz o risco de falhas e acaba melhorando a conﬁança do serviço
com disponibilidade garantida;

• Imutabilidade: os registros de transações no livro-razão, distribuídos entre os nós,
são permanentes e inalteráveis. A imutabilidade é uma característica que difere dos
sistemas de banco de dados centralizados. Os registros são resistentes a adulteração
computacional com a existência de links criptográﬁcos;

• Link criptográﬁco: o link criptográﬁco entre cada registro é classiﬁcado em ordem
cronológica construindo uma cadeia de integridade pela blockchain. A assinatura

Capítulo 2. Fundamentos

3

digital veriﬁca a integridade de cada registro usando técnicas de hashing e criptograﬁa
de chave assimétrica. Violar a integridade do registro do bloco ou da transação acaba
tornando o registro e o bloco inválidos.

A segurança da blockchain parte dos avanços da criptograﬁa e do design e implemen-
tação da blockchain (Bitcoin, Ethereum, etc.). Foram realizadas propostas de blockchain,
com o passar do tempo, para melhorar a eﬁciência da cadeia criptográﬁca de blocos, por
exemplo, incorporar árvores Merkle e colocar vários documentos em um bloco (ZHANG;
XUE; LIU, 2019). A blockchain foi construída para garantir diversas características em rela-
ção a segurança, como consistência, resistência a adulteração, pseudonimato e resistência a
ataques de gasto duplo e Distributed Denial of Service (DDoS). Porém, mesmo com o nível
atual de segurança que a blockchain consegue prover, em alguns cenários ainda faltam
propriedades adicionais de segurança e privacidade (ZHANG; XUE; LIU, 2019).

2.2 Contratos Inteligentes

Os contratos inteligentes podem ser considerados como um programa que é execu-
tado quando condições predeterminadas são atendidas (autoexecutável) e que está implan-
tado na blockchain, podendo ser utilizado em serviços ﬁnanceiros, saúde e governo. É capaz
de suportar funções e mecanismos programáveis complexos para automatizar acordos e
outros tipos de ﬂuxos (SHI et al., 2020).

Esse tipo de contrato, que pode ser utilizado na blockchain, permite que as partes
possam fazer o uso dele para criar terceiros virtuais de conﬁança que se comportaram
de acordo com as regras acordadas entre ambos, dessa forma permitindo a criação de
protocolos complexos com um risco de não cumprimento muito baixo (KALODNER et al.,
2018).

Na rede blockchain do Ethereum os contratos inteligentes são desenvolvidos for-
malmente em código de alto nível através do Solidity (linguagem de programação) e são
compilados para serem executados pela Máquina Virtual Ethereum (EVM). No conceito do
Solidity os contratos inteligentes são um conjunto de códigos, dados, funções e estados,
que estão em um especíﬁco endereço na rede blockchain do Ethereum (ETHEREUM, 2017).

Para que uma conta interaja com um contrato ou para que ocorra interações entre
contratos, deve-se ter o nome e os argumentos da função, assim surge a Application Binary
Interface (ABI) que é uma lista das funções e argumentos do contrato organizado no formato
de um JavaScript Object Notation (JSON) , assim que ele é compilado. Dessa forma, utiliza-
se da ABI para fazer o hash da deﬁnição da função e então criar o bytecode EVM necessário
para chamar a função (ETHEREUM, 2021).

Capítulo 2. Fundamentos

4

2.3 Algoritmos de Criptograﬁa

Os algoritmos criptográﬁcos se dividem em dois tipos, os de chave simétrica ou
chave privada, que ainda podem ser divididos em algoritmos que operam em um único bit
ou em grupos de bits, e os de chave assimétrica ou chave pública. A criptograﬁa de chave
pública foi criada em 1976 quando W. Diﬃe e M. Hellman, propuseram esta nova ideia, a
qual foi seguida por R. L. Rivest, A. Shamir, e L. Adleman, os criadores do algoritmo RSA
(OLIVEIRA et al., 2014). O surgimento da criptograﬁa baseada em curvas elípticas, que é
um tipo especial de chave pública, foi inicialmente proposta por Miller e Koblitz no ﬁnal
dos anos 1980, a qual foi baseada em algoritmos e aplicações de chave pública até então já
existentes (OLIVEIRA et al., 2014).

Os algoritmos de chave simétrica vão possuir uma chave (privada) que é igual para
ambas as partes que estão trocando informações e deve permanecer em segredo, pois ela
será utilizada para criptografar e descriptografar as informações, é um método simples que
facilita a criptograﬁa entretando o problema dessa forma reside no compartilhamento da
chave entre as partes, pois se alguém conseguir interceptar essa troca e obter acesso a chave
a pessoa terá acesso para criptografar e descriptograr as informações (OLIVEIRA, 2012).
Por outro lado os algoritmos de chave assimétrica segundo Singh, Khan e Singh (2016), são
algoritmos que dependem do uso de uma chave pública e de uma chave privada. A chave
pública será livremente distribuída sem comprometer de alguma maneira a chave privada, a
qual deve ser mantida em segredo. A chave pública é utilizada para criptografar mensagens
de texto simples e veriﬁcar assinaturas, já a chave privada é usada para assinar mensagens e
descriptografar os textos criptografados para obter as mensagens em texto simples (SINGH;
KHAN; SINGH, 2016).

Dessa forma, pode-se observar que a criptograﬁa acaba sendo o mecanismo principal
para se conseguir garantir a segurança dos dados nos sistemas de informação atuais. No
trabaho será utilizado o Advanced Encryption Standard (AES) em conjunto com o RSA ou o
ECC, para assim criar um criptossistema híbrido com objetivo de aumentar a complexidade
e força da criptograﬁa. A seguir será abordado os algoritmos RSA, ECC e AES.

2.3.1 RSA

O algoritmo de criptograﬁa RSA de chave assimétrica tornou-se o padrão para cripto-
graﬁa de chave pública sendo amplamente utilizado. Sua segurança reside no problema de
fatoração de inteiros e o seu processo de descriptograﬁa não é eﬁciente como seu processo
de criptograﬁa (MAHTO; YADAV, 2017). Para uma segurança de dados melhor e mais forte, o
RSA acaba necessitando de tamanhos de chave maiores, o que implica em mais sobrecarga
sobre os sistemas. Dessa forma, para os sistemas que possuem restrição de memória, o RSA
se torna uma segunda opção (MAHTO; YADAV, 2017).

Capítulo 2. Fundamentos

5

O funcionamento do algoritmo RSA se baseia em números primos, assim quanto
maior for o número escolhido mais segura a chave será. O cálculo das chaves pode ser feita
através dos seguintes passos segundo Sousa (2019):

• Escolher dois números primos: os números escolhidos em uma implementação real
serão muito maiores como o RSA de 2048-4096 bits, porém com o intuito de facilitar
os cálculos e o entendimento os numeros serão P = 3 e Q = 11;

• Calcular o produto dos dois números P e Q: calculando N = 3 * 11 = 33, esse resultado

será utilizado depois na cifragem e na decifragem;

• Calcular a função totiente de Euler: a fórmula totiente(N) = (P - 1) * (Q - 1) é utilizada
para calcular o número de coprimos à um número, sendo que coprimo é um número
que o máximo divisor comum entre ele e outro número é 1. Calculando com o número
do exemplo totiente(33) = (3 – 1) * (11 – 1) = 2 * 10 = 20, assim o N possui 20 coprimos;

• Escolher um número E que seja um dos coprimos de N: dos coprimos de N temos 1, 2,
4, 5, 7, 8, 10, 13, 14, 16, 17, 19, 20, 23, 25, 26, 28, 29, 31 e 32, assim pode-se escolher, por
exemplo, o número 17 para ser o valor de E que vai compor a chave pública;

• O E e o D devem ser tais que a seguinte fórmula seja verdadeira: E * D mod totiente(N)
= 1. Portanto assumimos que 17 * D mod 20 precisa ser igual a 1. Realizando o calculo
obtêm-se que o valor de D = 13 satisfaz a condição do resto da divisão ser igual a um.

Finalizando esses passos, se obtêm tudo que é necessário para começar a criptografar

através do algoritmo RSA:

• A chave pública é: E = 17, N = 33;

• A chave privada é: D = 13, N = 33.

Para realizar a criptograﬁa, por exemplo da mensagem “9”, será utilizada a seguinte
fórmula: Crip = ME mod N. No exemplo, Crip = 917 mod 33 = 16677181699666569 mod
33 = 15, assim o texto criptografado é “15”.

Para realizar a descriptograﬁa do texto “15”, que só é possivel com a chave privada,
será utilizada a seguinte fórmula: Decrip = CripD mod N. No exemplo, Decrip = 1513 mod
33 = 1946195068359375 mod 33 = 9, assim o texto criptografado volta ao texto original “9”.

2.3.2 ECC

A segurança do algoritmo de criptograﬁa ECC de chave assimétrica reside no uso
das propriedades matemáticas da curva elíptica para realizar o cálculo das chaves criptográ-
ﬁcas (problema do logaritmo discreto sobre curvas elípticas)(MAHTO; YADAV, 2017). É um

Capítulo 2. Fundamentos

6

sistema mais adequado e promissor para dispositivos que possuem restrição de memória
(Smartphone e Smartcards), além de ser utilizado em blockchains, como por exemplo a do
Bitcoin a blockchain com o maior valor de mercado atualmente. O ECC consegue manter
os níveis de segurança de forma equivalente ao RSA e requer comparativamente menores
parâmetros para criptograﬁa e descriptograﬁa do que o RSA (MAHTO; YADAV, 2017).

Segundo Mahto e Yadav (2017), uma curva elíptica C sobre um campo ﬁnito primo é
deﬁnida por uma equação na forma y2 = x3 + ax + b satisfazendo a restrição 4a3 + 27b2 (cid:54)= 0.
O cálculo das chaves pode ser feita através dos seguintes passos:

• Deﬁnir os elementos públicos globais: Eq (a, b) a curva elíptica com os parâmetros a,
b e q, onde q é um primo ou inteiro na forma 2m. Selecione G que é o ponto na curva
elíptica de ordem n;

• Geração de chave do usuário A: selecione a chave privada nA sendo nA < n. Calcular

a chave pública PA através da formula PA = nA * G;

• Geração de chave do usuário B: selecione a chave privada nB sendo nB < n. Calcular

a chave pública PB através da fórmula PB = nB * G;

• Cálculo da chave secreta pelo usuário A: feita pela fórmula K = nA * PB;

• Cálculo da chave secreta pelo usuário B: feita pela fórmula K = nB * PA.

Para realizar a criptograﬁa pelo usuário A usando a chave pública do usuário B são

realizados os seguintes passos:

• Usuário A escolhe a mensagem Pm, sendo Pm um ponto (x, y) codiﬁcado com a
ajuda da mensagem de texto simples m, ou seja, é o ponto usado para criptografar e
descriptografar, e um número inteiro positivo aleatório k;

• O texto cifrado será Cm = k * G, Pm + k * PB .

Para realizar a descriptograﬁa pelo usuário B usando a sua chave privada são realiza-

dos os seguintes passos:

• O texto cifrado é Cm;

• O texto plano será Pm = Pm + k * PB - nB * (k * G)

= Pm + k (nB * G) - nB * (k * G).

Capítulo 2. Fundamentos

2.3.3 AES

7

O algoritmo de criptograﬁa AES de chave simétrica foi desenvolvido em 1998 por
Joan Daemen e Vincent Rijmen, permite um tamanho de bloco de dados ﬁxo de 128 bits e
suporta tamanho de chave de 128, 192, e 256 bits, além de qualquer combinação de dados
(PATIL et al., 2016). Segundo Oliveira (2012) é um dos algoritmos de chave simétrica mais
populares, sendo adotado como padrão pelo governo dos Estados Unidos, e considerado o
substituto do Data Encryption Standard (DES), devido sua rapidez, fácil execução e pouca
exigência de memória.

Sendo a cifra de bloco de chave simétrica mais utilizada dentro da segurança de
computadores, principalmente pela sua padronização pelo NIST e também por todas as
cripto análises publicadas sobre este algoritmo, conseguindo resistir a diversos tipos de
ataques (SARAIVA et al., 2019). Assim, torna-se uma escolha ideal para a criptograﬁa de dados
de maior volume, devido a sua performance, podendo ser combinado com a segurança de
um algoritmo de chave assimétrica.

3 Tecnologias e Ferramentas

8

3.1 Rede Blockchain do Ethereum

Na blockchain do Ethereum, existe a EVM, que é um computador canônico, o qual
todos os membros da rede Ethereum concordam. Cada nó da rede mantêm uma cópia
do estado deste computador e qualquer participante pode transmitir uma solicitação de
transação para que este computador execute (ETHEREUM, 2022). Quando uma solicitação
é realizada os outros participantes da rede veriﬁcam, validam e executam o cálculo, o qual
causa uma mudança de estado da EVM que será conﬁrmada e propagada por toda a rede
ou pela a maioria da rede (ETHEREUM, 2022).

A rede do Ethereum é uma rede blockchain não-permissionada, ou seja, possui
acesso aberto sem a necessidade de autenticação ou a existência de uma entidade central,
assim qualquer usuário pode criar uma carteira e fazer parte da rede, até podendo se tornar
um nó minerador e tentar validar os blocos em troca de uma taxa paga em Ether (ETH) por
esse processamento realizado (WÜST; GERVAIS, 2018).

Os mecanismos criptográﬁcos da rede vão garantir que as transações sejam veri-
ﬁcadas como válidas e então adicionadas ao blockchain, não podendo ser adulteradas
posteriormente devido a diﬁculdade de realizar alguma adulteração, além disso também
garantem que todas as transações sejam assinadas e executadas com as devidas permissões
(ETHEREUM, 2022). O Ethereum utiliza o mecanismo de consenso POW, desse modo o
usuário que deseja adicionar um novo bloco à cadeia deve resolver um problema compu-
tacional difícil que vai requerer muito poder de computação, esse processamento que é
conhecido como mineração, uma tentativa e erro de força bruta, quem calcular com sucesso
o resultado será recompensado em ETH (ETHEREUM, 2022).

O ETH é a criptomoeda nativa do Ethereum, a qual possibilita um mercado para
computação provêndo um incentivo econômico para que os participantes veriﬁquem e
executem solicitações de transação e forneçam também recursos computacionais para a
rede (ETHEREUM, 2022). O participante que transmite uma solicitação de transação deve
oferecer alguma quantidade de ETH para a rede como recompensa, que é conhecido como
Gas Fees (taxas de gás), o valor vai corresponder ao tempo necessário para fazer o cálculo, o
que acaba evitando a ação de membros maliciosos da rede com intuito de atrapalharem a
execução da blockchain com scripts que consomem muitos recursos (ETHEREUM, 2022),
pois eles terão que pagar por esse tempo de execução. A recompensa é concedida ao usuário
(nó minerador neste caso) que eventualmente realizar o trabalho de veriﬁcar, executar,
enviar e transmitir a transação para a rede blockchain.

Capítulo 3. Tecnologias e Ferramentas

9

O Ethereum é a primeira plataforma de blockchain de código aberto que oferece
uma linguagem de contrato inteligente completa para os desenvolvedores implantarem
seus contratos e Decentralized Applications (DApp) ao custo de uma taxa paga à rede no
momento da migração do contrato para a blockchain (SHI et al., 2020).

3.2 IPFS

O IPFS é um sistema de arquivos distribuído (peer-to-peer) para armazenar, compar-
tilhar e acessar arquivos, sites, aplicativos e dados com objetivo de tornar a web atualizável,
resiliente e mais aberta (IPFS, 2022).

Existem três princípios fundamentais para compreender o IPFS segundo o site oﬁcial

do IPFS (2022):

• Identiﬁcação única por meio de endereçamento de conteúdo: os endereços de acesso
as informações são baseados no conteúdo e não na sua localização, assim quando é
adicionado um novo arquivo no IPFS esse arquivo é dividido em pedaços chamados
“IPFS’s objects” (protegidos por criptograﬁa, sistema de hash e assinatura digital) que
vão possuir um Content Identiﬁer (CID), o qual é um registro permanente do arquivo,
além disso os “IPFS’s objects” guardam até 256kb de dados e também podem conter
links para outros objetos que estão na rede;

• Vinculação de conteúdo por meio de Directed Acyclic Graphs (DAG): a estruturada
do IPFS é um grande DAG, especiﬁcamente um Merkle DAG onde cada nó tem um
identiﬁcador que é o resultado do hash do conteúdo do nó. A representação de seu
conteúdo é feita em blocos e cada bloco tem uma raiz Merkle, isso signiﬁca que
diferentes partes do arquivo podem vir de diferentes fontes. As Merkle DAGs só podem
ser construídas a partir das folhas, cada nó em um Merkle DAG é a raiz de um (sub)
Merkle DAG em si e os nós na Merkle DAG são imutáveis;

• Descoberta de conteúdo por meio de Distributed Hash Tables (DHT): o IPFS usa uma
tabela de hash distribuída, que é uma tabela dividida entre todos os pares da rede
descentralizada, para armazenar as chaves e valores. O projeto “libp2p” é a parte do
IPFS que fornece o DHT e controla os pares que se conectam e conversam entre si.
Utiliza-se o DHT para encontrar a localização atual dos pares que estão armazenando
o conteúdo que está sendo buscado.

Por exemplo, quando outros nós vão procurar por um conteúdo eles perguntam
para os nós pares quem está armazenando o conteúdo que possui um determinado CID, os
nós começam a responder e assim é possível se ter acesso a localização do conteúdo que
se deseja. Após encontrar essa localização o IPFS utiliza o Bitswap para solicitar e enviar

Capítulo 3. Tecnologias e Ferramentas

10

blocos entre os pontos, permitindo realizar a conexão aos pares de peers que possuem o
conteúdo que está sendo buscado. Os nós que baixarem um determinado arquivo da rede
vão possuir uma cópia na cache, e dessa forma se tornam provedores daquele conteúdo, o
qual podem fornecer por um tempo ou descartar para limpar espaço de memória (IPFS,
2022).

Portanto o IPFS permite que os membros da rede armazenem apenas o conteúdo
que estão interessados, além de algumas informações de indexação que são utilizadas para
ajudar a descobrir qual nó está armazenando que conteúdo. Além disso, se for adicionado
uma nova versão de um arquivo, será feito um novo hash diferente e com um novo CID, assim
garantindo a resistência a adulteração e censura, pois não são sobrescritas as alterações no
arquivo original, além da reutilização de partes comuns do arquivo para minimizar custos
de armazenamento (IPFS, 2022). O IPFS utiliza o sistema de nomenclatura descentralizado
InterPlanetary Name System (IPNS) e o DNSLink para mapear CIDs para nomes Domain
Name System (DNS) legíveis por humanos e utiliza criptograﬁa de transporte para proteger
os dados enviados entre dois pontos (IPFS, 2022).

Para os desenvolvedores blockchain o endereçamento de conteúdo IPFS permite
o armazenamento de grandes arquivos fora de uma blockchain especíﬁca, pois ao invés
de armazenar o arquivo na blockchain, que pode ser custoso, pode-se armazenar apenas
os links imutáveis e permanentes, que vão referenciar o arquivo armazenado dentro do
IPFS, nas transações que serão persistidas na blockchain, possibilitando o carimbo de data
e hora e a proteção do conteúdo sem ter que adicionar os dados de maior volume na própria
blockchain (IPFS, 2022).

3.3 Truﬄe Suite

O Ganache, o Truﬄe e o Drizzle formam a coleção de ferramentas conhecida como
Truﬄe Suite, que são softwares feitos especiﬁcamente para o desenvolvimento na blockchain
que até grandes empresas como a Amazon e a Microsoft utilizam (TRUFFLESUITE, 2022a).
Dentre as três ferramentas serão abordados o Ganache e o Truﬄe, os quais serão utilizados
para o desenvolvimento da DApp (Decentralized Application) proposta neste trabalho.

3.3.1 Truﬄe

O Truﬄe é um ambiente de desenvolvimento, framework de teste e pipeline de ativos

para blockchains usando a Ethereum Virtual Machine (EVM) (TRUFFLESUITE, 2022b).

Segundo o site do TruﬄeSuite (2022b), as funcionalidades que o desenvolvedor

consegue usufruir ao utilizar o Truﬄe são:

• Compilação, vinculação, implantação e gerenciamento binário integrado de contrato

Capítulo 3. Tecnologias e Ferramentas

11

inteligente;

• Teste de contrato automatizado;

• Estrutura de implantação e migração programável e extensível;

• Gerenciamento de rede para implantação em redes públicas e privadas;

• Gerenciamento de pacotes com EthPM & NPM, utilizando o padrão ERC190;

• Console interativo para comunicação direta do contrato;

• Pipeline de construção conﬁgurável;

• Executor de script externo que executa scripts em um ambiente Truﬄe.

3.3.2 Ganache

O Ganache permite o seu usuário ter uma blockchain pessoal para desenvolvimento
de DApps possibilitando que o desenvolvedor desenvolva, implemente e teste seus DApps
em um ambiente seguro e determinístico. É possível desenvolver para, por exemplo, a rede
do Ethereum e Corda. Além disso, através do Ganache é possível testar como a DApp afeta a
blockchain e examinar detalhes como suas contas, saldos, criações de contratos inteligentes
e custos de gás (TRUFFLESUITE, 2022c).

3.4 MetaMask

O MetaMask é uma carteira criptografada (digital) e um gateway para aplicativos da
blockchain, que possibilita aos usuários o gerenciamento de suas contas, chaves e tokens
de várias maneiras, incluindo carteiras de hardware, além de isolar o usuário do contexto
do site (METAMASK, 2021). Está disponível como uma extensão de navegador e como um
aplicativo móvel.

Para os desenvolvedores, é possível interagir com a API do Ethereum (globalmente
disponível) que identiﬁca os usuários de navegadores compatíveis com web3 e sempre
que acontecer uma solicitação de uma assinatura de transação, o MetaMask irá solicitar ao
usuário uma conﬁrmação dessa transação, bem como indicar o custo dela (METAMASK,
2021). O MetaMask já vem conﬁgurado com algumas conexões para a rede blockchain do
Ethereum e para várias redes de teste através da API do Infura. Além disso, atualmente o
MetaMAsk é compatível com qualquer outra blockchain (públicas e privadas) que exponha
uma API JSON RPC (Remote Procedure Calling) compatível com Ethereum (METAMASK,
2021).

Capítulo 3. Tecnologias e Ferramentas

12

3.5 React

O React é uma biblioteca JavaScript para construir interfaces de usuário. Essa biblio-
teca é declarativa, o que faz com que seu código seja mais previsível e simples de depurar,
baseada em componentes o que torna fácil passar diversos tipos de dados ao longo da sua
aplicação e ainda assim manter o estado fora do Document Object Model (DOM) (REACT,
2022b). Os componentes do React implementam um método “render()” que vai receber
os dados de entrada e retornar o que deve ser exibido, além disso um componente pode
manter os dados do estado interno (REACT, 2022b). O React facilita a interface com outras
bibliotecas e frameworks.

O React faz uso do JavaScript XML (JSX) que não é obrigatório, sendo uma extensão
de sintaxe para JavaScript que produz “elementos” do React e que facilita o desenvolvimento
de aplicações ao mostrar, por exemplo, mensagens mais úteis de erro e aviso. O uso do
JSX está no motivo do React adotar o fato de que a lógica de renderização é inerentemente
acoplada com outras lógicas de interface de usuário (manipulação de eventos, mudança de
estado com o tempo, preparação de dados para exibição, etc.) (REACT, 2022a). Os elementos
React são objetos simples e o responsável por atualizar o DOM para exibir os elementos
React é o React DOM, o qual compara um elemento novo e seus ﬁlhos com os anteriores e
somente vai aplicar as modiﬁcações necessárias (REACT, 2022a).

3.6 Node.js

O Node.js é como um runtime JavaScript assíncrono e orientado a eventos, projetado
para criar aplicativos de rede escaláveis. Os usuários do Node.js não precisam se preocupar
com travamento de processos, pois quase nenhuma função no Node.js executa de forma
direta a entrada e saída, assim o processo nunca é bloqueado, exceto quando for utilizado
métodos síncronos da biblioteca padrão do Node.js para executar a entra e saída (NODE.JS,
2022).

Inﬂuenciado por sistemas como o Event Machine do Ruby e o Twisted do Python,
o Node.js apresenta um loop de eventos como uma construção em tempo de execução,
sendo que não existe uma chamada que vai iniciar o evento de loop, ele simplesmente entra
no loop de eventos após executar o script de entrada e sai do loop de eventos quando não
existem mais retornos de chamada a serem executados (NODE.JS, 2022).

Mesmo que tenha sido projetado sem threads, é possível fazer o uso de vários nú-
cleos de um ambiente, através dos processos ﬁlhos que podem ser gerados usando a API
child_process.fork(). Utilizando do módulo de cluster, que possibilita compartilhar soquetes
entre processos e assim fazer o balanceamento de carga em seus núcleos (NODE.JS, 2022).

Portanto, acaba sendo comum a escolha do Node.js para o desenvolvimento de

Capítulo 3. Tecnologias e Ferramentas

13

aplicações escaláveis, e no caso do desenvolvimento de DApps essa plataforma também
acaba sendo muito preferida em conjunto com o React, assim desenvolvendo o front-end e
back-end em JavaScript.

3.7 WEB3

A WEB 3.0 possui como foco a descentralização, diferente da WEB 1.0 e WEB 2.0,
além de trazer também algumas características adicionais como ser veriﬁcável, autogover-
nado, sem permissão e distribuído . Os aplicativos Web3 (DApps) são executados em redes
descentralizadas, em blockchains ou até mesmo uma combinação dos dois formando, por
exemplo, um protocolo criptoeconômico, já que a criptomoeda desempenha um grande
papel em muitos desses protocolos, já que fornece um incentivo ﬁnanceiro (tokens) para os
nós que quiserem participar da criação, governança, contribuição ou melhoramento de um
projeto (DABIT, 2021).

Os projetos que são desenvolvidos em cima desse sistema da Web3 acabam ofere-
cendo uma variedade de serviços como computação, armazenamento, hospedagem entre
outros serviços que eram fornecidos, principalmente, por provedores de nuvem. Os usuá-
rios que consomem esses serviços da Web3 pagam para usar o protocolo, mas nesse caso o
dinheiro vai diretamente para os participantes da rede eliminando intermediários desne-
cessários (DABIT, 2021).

No desenvolvimento da DApp do presente trabalho será utilizada a biblioteca Web3
que é empregada para conectar-se à rede Ethereum a partir de um aplicativo. A ABI é dada
à biblioteca Web3, a qual usa para dar acesso programático ao contrato implantado, neste
caso, na rede do Ethereum. Um objeto da classe Web3 deve ser instanciado para se utilizar
de suas funções. Cada instância da biblioteca Web3 pode-se conectar a uma rede Ethereum
diferente (PANDA; SATAPATHY, 2021). A instância do Web3 vai requer uma camada de
comunicação conhecida como provedor, que atua como um meio entre a biblioteca Web3
e a rede Ethereum, e cada provedor tem um conjunto de métodos para enviar ou receber
uma solicitação da rede Ethereum(PANDA; SATAPATHY, 2021).

3.8 API do Infura

A API do Infura é alimentada por uma arquitetura orientada a microsserviços que é
escalonada dinamicamente fornecendo acesso instantâneo por Hypertext Transfer Protocol
Secure (HTTPS) e WebSockets à rede Ethereum, ou seja, fornece uma infraestrutura para
DApps de maneira fácil e rápida (INFURA, 2022). Através do Infura os desenvolvedores
podem se conectar a Ethereum e IPFS via HTTPS e WebSocket com tempos de resposta e
disponibilidade satisfatórios. Além disso, a plataforma disponibiliza um painel que mostra

Capítulo 3. Tecnologias e Ferramentas

14

o desempenho do aplicativo e o uso da API, detalhando as solicitações de métodos especíﬁ-
cos, tempo de uso e outras funcionalidades que podem ajudar o desenvolvedor durante a
contrução da sua aplicação (INFURA, 2022).

Algums recursos disponíveis pela API do Infura segundo o site da plataforma Infura

(2022):

• Suporta mainnet e testnets via JSON-RPC compatível com o cliente, HTTPS e Windows

Sharepoint Services (WSS);

• Funciona com as últimas atualizações de rede com garantia mínima de 99,9% de

tempo de atividade;

• Conecta seu aplicativo com uma linha de código sem sincronização e sem conﬁgura-

ções complicadas;

• Permite conﬁgurar, monitorar e analisar seus aplicativos com o painel de controle do

Infura;

• Acesso aos dados do nó do arquivo Ethereum disponíveis como um adicional;

• Acesso 24 horas por dia, 7 dias por semana a equipes de suporte especializado e a

comunidade de desenvolvedores experientes do Infura.

4 DApp

15

No projeto da DApp deﬁniu-se uma arquitetura composta por seis componentes,
conforme pode ser observado na Figura 1. A partir desta arquitetura busca-se o desenvol-
vimento de uma DApp que possa garantir a proteção da privacidade dos dados de saúde
armazenados em uma blockchain, usando mecanismos de criptograﬁa.

Figura 1 – Esquema da arquitetura

Fonte: Do autor, 2022

A seguir são descritos os componentes da arquitetura:

• Usuário: vai realizar o acesso a aplicação, enviar e receber dados (informações, ar-
quivos e permissões), além de conﬁrmar as transações e pagar a taxa da persistência
desses dados na blockchain;

• DApp: responsável por se comunicar com a interface da carteira digital (MetaMask),
com a blockchain (Ethereum) enviando e recebendo os dados, com o banco descen-
tralizado (IPFS) enviando os arquivos e tratando o hash de retorno, com o usuário
recebendo e mostrando os dados requisitados, e por ﬁm, realizar a criptograﬁa/-
descriptograﬁa do hash, da chave privada do AES, do arquivo e da chave privada
compartilhada na concessão de permissão;

Capítulo 4. DApp

16

• Interface de Carteira Digital (MetaMask): responsável por gerenciar as transações
realizadas na DApp, solicitando a conﬁrmação do usuário e debitando a taxa para a
persistência dos dados na blockchain;

• Blockchain (Ethereum): responsável por guardar os contratos inteligentes que regem
como as informações pertinentes do arquivo e da permissão serão armazenadas,
como por exemplo, o hash que é utilizado para se ter acesso ao arquivo no IPFS, o
endereço do usuário que realizou uma transação e o endereço do usuário a qual
está sendo cedida a permissão, realizando dessa forma o link do respectivo usuário a
determinada informação dentro dos contratos inteligentes;

• Sistema de arquivos descentralizado (IPFS): responsável por receber os arquivos
criptografados da DApp, armazená-los e devolver um respectivo hash único que
indica onde se encontra essa determinada informação na rede do IPFS;

• Criptograﬁa: esse é o componente chave para garantir a segurança e privacidade
dos dados armazenados na arquitetura proposta, pois através dos algoritmos de
criptograﬁa RSA ou ECC a aplicação criptografa o hash e a chave privada do AES antes
de enviar essas informações para a blockchain; Com o AES é feita a criptograﬁa do
arquivo e da chave privada compartilhada na concessão da permissão. Dessa forma,
somente o usuário que possui acesso a chave privada para descriptografar esse hash e
a chave privada do AES, vai conseguir ter acesso às informações armazenadas. Este
processo, garante que as informações na blockchain e no IPFS ﬁquem seguras.

Na sequência foram deﬁnidos os requisitos funcionais e não funcionais para a DApp.
Os requisitos funcionais tem por ﬁnalidade descrever o comportamento da aplicação e as
funções que devem ser previstas. Como requisitos funcionais, temos:

• Realizar Login: a aplicação só estará disponível após login do usuário pelo MetaMask;

• Informar chaves de criptograﬁa: toda vez que o usuário logar na aplicação serão
geradas suas chaves (pública e privada); a aplicação possui um espaço para que o
usuário informe suas chaves; na primeira vez que acessar a aplicação pode guardar
suas chaves da forma que preferir, e no próximo login pode informar as suas chaves;

• Armazenar informações: o usuário pode enviar informações a serem armazenadas
no IPFS, de forma segura através da criptograﬁa AES, o qual gera um hash para se ter
acesso ao conteúdo na rede, esse hash e a chave privada do AES, gerada aleatoriamente,
serão armazenados de forma criptografada na blockchain do Ethereum, através de
um dos algoritmos de chave assimétrica (ECC ou RSA), para garantir a privacidade e o
controle do acesso aos dados;

Capítulo 4. DApp

17

• Conﬁrmar ou rejeitar transações: o usuário, após enviar uma requisição para armaze-
nar informações ou uma permissão nos respectivos contratos, pode aceitar ou rejeitar
a transação através do MetaMask;

• Buscar informações: o usuário pode buscar as informações que possui armazenadas
no IPFS através do hash armazenado na blockchain, de acordo com o seu usuário
logado;

• Conceder permissão: o usuário A pode conceder permissão de acesso a um arquivo
que possui armazenado no IPFS para um usuário B, através de algumas informações
como o hash armazenado na blockchain, o tempo especíﬁco que a permissão vai ter
de validade, o endereço do usuário B e a chave pública do usuário B;

• Visualizar arquivos com permissão: um usuário que teve uma permissão concedida
por outro usuário a um arquivo, pode ter acesso para visualizar esse arquivo dentro
do tempo que foi estipulado pelo usuário que cedeu a permissão.

Já com relação aos requisitos não funcionais, que são premissas e/ou restrições

técnicas para a aplicação, foram elencados:

• DApp: a aplicação possuirá as características de uma aplicação descentralizada;

• Armazenamento da aplicação: a aplicação não armazena nenhum dado de forma

permanente e centralizada, apenas temporariamente;

• Segurança dos dados: os arquivos enviados ao IPFS serão criptografados pelo algo-
ritmo AES. O hash, que identiﬁca o local dos dados, e a chave privada do AES (utilizada
para criptografar o arquivo) serão criptografados utilizando o RSA ou o ECC, antes
de serem armazenados na blockchain, assim permitindo que o usuário consiga aces-
sar novamente os seus dados de forma segura. A chave privada compartilhada na
permissão será criptografada pelo AES.

Considerando a arquitetura da Figura 1, a seguir é detalhado o funcionamento para

cada um dos casos de uso dos requisitos funcionais incorporados na Dapp:

• 1. Realizar Login:

– 1. O usuário acessa a aplicação (DApp) que permite o envio/recebimento de
arquivos, sendo necessário o usuário estar logado a uma interface Web3 de
carteira digital no navegador, como o MetaMask;

– 2. A DApp estabelece uma conexão com a interface de carteira digital (MetaMask)

no navegador para realizar as transações com a blockchain;

Capítulo 4. DApp

18

– 3. A interface conecta com a blockchain para o gerenciamento das transações;

– 4. Assim é estabelecida a conexão da DApp com a blockchain para as transações;

– 5. Por ﬁm, é feita a conexão da DApp com a blockchain do Ethereum via Web3

para o envio e recebimento de dados.

• 2. Informar chaves de criptograﬁa:

– 1. Quando o usuário realiza o login é gerado sua chave pública e privada;

– 2. O usuário então pode pegar e salvar suas chaves da forma que achar melhor;

– 3. Quando o usuário acessar novamente a DApp ele poderá fornecer suas chaves
para a aplicação utilizar na criptograﬁa e descriptograﬁa das informações.

• 3. Armazenar informações:

– 1. O usuário logado na DApp envia os arquivos e informações a serem armazena-

dos;

– 2. A DApp criptografa com o AES os arquivos e envia ao IPFS;

– 3. O IPFS retorna um hash que indica onde está o arquivo na sua rede;

– 4. Antes da DApp enviar os dados, o hash do arquivo e a chave privada do AES

são criptografados pela DApp utilizando RSA ou ECC;

– 5. Após a criptograﬁa, os dados são enviados para serem armazenados na block-

chain, através do contrato de armazenamento.

• 4. Conﬁrmar ou rejeitar transações:

– 1. A blockchain solicita a conﬁrmação da transação ao MetaMask;

– 2. O MetaMask solicita para o usuário conﬁrmar ou rejeitar a transação;

– 3. Se a transação for conﬁrmada é realizado o pagamento do “gas” (taxa) da rede,

senão é cancelado o envio dos dados;

– 4. Após a conﬁrmação, as informações são adicionadas na blockchain.

• 5. Buscar informações:

– 1. Após o usuário logar na aplicação (como demonstrado na etapa de login), a

DApp vai buscar suas informações armazenadas na blockchain;

– 2. A blockchain retorna as informações armazenadas para a aplicação utilizar;

– 3. O hash do arquivo e a chave privada do AES são descriptografados, possibili-

tando assim o acesso ao arquivo no IPFS;

– 4. O usuário visualiza as informações e acessa o arquivo armazenado no IPFS

através do hash.

Capítulo 4. DApp

• 6. Conceder permissão:

19

– 1. Para o usuário A conceder uma permissão ele vai precisar informar uma des-
crição, o tipo do arquivo, o hash do arquivo, o tempo de validade da permissão,
o endereço e a chave pública do usuário a qual será cedida a permissão, neste
caso usuário B;

– 2. Antes de fazer o envio da permissão, a aplicação vai buscar a chave privada
do AES e o hash do arquivo que o usuário A está compartilhando, para assim
descriptografar com a chave privada do usuário A e criptografar com a chave
pública do usuário B fornecida pelo usuário A;

– 3. Criptografada e protegida as informações é feito o envio dos dados para a

blockchain, através do contrato de permissão.

• 7. Visualizar arquivos com permissão:

– 1. O usuário B que recebeu uma permissão sobre um arquivo de outro usuário A

vai poder visualizar o arquivo dentro do tempo estipulado pelo usuário A;

– 2. Quando o tempo para visualizar o arquivo estiver válido, será feita a descrip-
tograﬁa da chave privada do AES e do hash com a chave privada do usuário B,
assim permitindo com que o usuário B acesse e visualize o arquivo do usuário A
armazenado no IPFS.

– 3. Terminado o tempo de validade da permissão o usuário B não vai ter mais

acesso ao arquivo pela DApp;

Para um entendimento de como os componentes do sistema interagem durante
todo o processo, foram construídos quatro diagramas de sequência. O diagrama da Figura 2
apresenta as mensagens trocadas na interação dos objetos nos casos de usos realizar login e
buscar informações. Inicialmente, é realizado o login no MetaMask para assim ser possível
acessar a DApp. Acessando a DApp são estabelecidas as conexões necessárias, se o usuário
possuir arquivos armazenados e permissões essas informações já são buscadas e mostradas
para o usuário. Dessa forma, o usuário pode acessar um arquivo que será buscada através
do hash no IPFS.

O diagrama da Figura 3 traz a representação da sequência de operações dos casos de
uso armazenar informações e conﬁrmar ou rejeitar transações. Após o usuário ter realizado
o login no MetaMask, pode realizar o envio de um arquivo a ser armazenado, podendo
também enviar uma descrição. A DApp vai criptografar o arquivo através do AES e enviar
para o IPFS, o qual vai retornar o hash que pode ser utilizado para encontrar esse conteúdo
na rede do IPFS. A DApp faz a criptograﬁa do hash e da chave do AES para assim enviar
para a blockchain do Ethereum os dados. Quando é feita uma chamada para armazenar
informações no Ethereum, o MetaMask vai conﬁrmar com o usuário o pagamento da taxa

Capítulo 4. DApp

20

Figura 2 – Diagrama de sequência para o login e busca de arquivos

Fonte: Do autor, 2022

para a rede, se for realizado o pagamento as informações são gravadas, senão o proceseso é
cancelado.

O diagrama da Figura 4 traz a representação da sequência de operações do caso de
uso conceder permissão. Um usuário A pode enviar uma permissão de algum arquivo que
tenha armazenado para outro usuário B, sendo necessário ser enviado essencialmente o
endereço e a chave publica do usuário B, o hash do arquivo a ser compartilhado e o tempo de
duração da permissão. Enviadas essas informações, a DApp vai criptografar o hash e a chave
do AES do arquivo compartilhado com a chave pública do usuário B. Após a criptograﬁa
é feito o envio para a blockchain do Ethereum, também é necessário aceitar ou rejeitar a
transação pelo MetaMask.

O diagrama da Figura 5 traz a representação da sequência de operações do caso
de uso visualizar arquivos com permissão. Um usuário B que recebeu permissões sobre
arquivos de outros usuários, vai conseguir acessar e visualizar dentro do tempo de duração
da permissão concedida aos arquivos. Quando o usuário for acessar um arquivo, a DApp
vai realizar a descriptograﬁa do hash para buscar o arquivo no IPFS e da chave do AES para
descriptografar o arquivo e permitir que o usuário B consiga visualizar.

Capítulo 4. DApp

21

Figura 3 – Diagrama de sequência para o envio de arquivos e gerenciamento das transações

Fonte: Do autor, 2022

Figura 4 – Diagrama de sequência para o envio de uma permissão

Fonte: Do autor, 2022

Capítulo 4. DApp

22

Figura 5 – Diagrama de sequência para visualizar arquivos com permissão

Fonte: Do autor, 2022

5 Implementações

23

Este capítulo apresenta detalhes quanto a implementação da DApp. O front-end e o
back-end da DApp foram desenvolvidos com JavaScript, HTML5, React e o Node.js, e a parte
do contrato inteligente em Solidity. O código1 para a construção da DApp foi adaptado a
partir de revisões feitas nas documentações das tecnologias descritas, alguns projetos de
código aberto descentralizados desenvolvidos por McCubbin (2022) e também pesquisas
nas documentações de bibliotecas de criptograﬁa.

5.1 Comunicação com a Blockchain

Inicialmente é necessário estabelecer a comunicação com um gateway para a rede
blockchain do Ethereum, neste caso o Meta Mask, para assim estabelecermos a comunicação
com a blockchain. Na Figura 1 podemos visualizar a parte do código responsável por essa
comunicação, sendo necessário importar para o projeto a biblioteca Web3.

Figura 6 – Comunicação com o MetaMask

Fonte: Do autor, 2022

Depois de estabelecer a comunicação anterior, é realizado o carregamento dos dados
da blockchain. Na Figura 7 é feita a busca pelas contas conectadas, pelo identiﬁcador da
rede blockchain e pelos contratos implantados na rede, que neste caso são o CriptDStorage,
que é o contrato responsável pela lógica de armazenamento, e o CriptDPermission, que é o
contrato responsável pela a lógica das permissões.

1 Código disponível em: https://github.com/SegaBR/DApp

Capítulo 5. Implementações

24

Figura 7 – Carregando a conta, buscando o ID da rede e dados do contrato

Fonte: Do autor, 2022

Na Figura 8 é realizada a busca pelos dados armazenados e relacionados com cada
contrato, no caso deste código, está sendo feita a busca dos dados do contrato CriptDStorage
responsável pela lógica de armazenagem do arquivo.

Figura 8 – Carregando dados do contrato

Fonte: Do autor, 2022

Na Figura 9 é realizada uma chamada ao contrato inteligente CriptDStorage, que
faz um envio de armazenamento de um arquivo para a blockchain, chamando a função
"uploadFile"do contrato inteligente e enviando as informações necessárias que a função
vai utilizar. O método "send"que é chamado vai indicar qual é o usuário que está fazendo
a requisição e que vai realizar o pagamento da taxa necessária para a rede do Ethereum

Capítulo 5. Implementações

25

persistir os dados. A transação é ﬁnalizada quando é gerado o hash da transação.

Figura 9 – Enviando dados ao contrato

Fonte: Do autor, 2022

5.2 Comunicação com o IPFS

Para estabelceler a comunicação com o IPFS primeiramente é feita uma inicialização,
como pode ser observado na Figura 10, onde são informados os dados para estabelecer a
comunicação que será realizada através da API do Infura.

Figura 10 – Inicialização do IPFS

Fonte: Do autor, 2022

Através do código da Figura 11 podemos realizar o envio de um arquivo para ser
armazenado no IPFS, a variável result retorna o hash, o qual é o CID que é utilizado para
buscar esse conteúdo dentro da rede do IPFS.

Através do código da Figura 12 podemos realizar a busca de um arquivo armazenado
no IPFS, através do link formado pelo hash, é feita a busca utilizando do Axios que é um
cliente HTTP baseado em promessas para o node.js que utiliza XMLHttpRequests. Assim,
é recuperado o arquivo e transformado em um buﬀer para ser possível descriptografar e
disponibilizar para o usuário acessar.

Capítulo 5. Implementações

26

Figura 11 – Envio de arquivo para o IPFS

Fonte: Do autor, 2022

Figura 12 – Busca arquivo no IPFS

Fonte: Do autor, 2022

5.3 Criptograﬁa

Em relação a criptograﬁa implementada na aplicação ela é dividida dentre os três

algortimos utilizados RSA, ECC e AES.

5.3.1 RSA

A Figura 13 apresenta como é feita a geração das chaves de 3072 bits do algortimo

RSA através da biblioteca node-forge.

O código da Figura 14 mostra a função que realiza a criptograﬁa do dados com o

RSA.

Na Figura 15 é mostrada a função que realiza a descriptograﬁa com o RSA. As chaves

ﬁcam armazenadas temporariamente no state da aplicação.

Capítulo 5. Implementações

27

Figura 13 – Gerar Chaves RSA

Fonte: Do autor, 2022

Figura 14 – Criptografar RSA

Fonte: Do autor, 2022

Figura 15 – Descriptografar RSA

Fonte: Do autor, 2022

5.3.2 ECC

O código apresentado na Figura 16 mostra a geração das chaves de 256 bits do
algoritmo ECC através da biblioteca ecccrypto utilizando a implementação do Elliptic Curve
Integrated Encryption Scheme (ECIES) e da curva elíptica secp256k12. Na Figura 17 é
mostrada a função que realiza a criptograﬁa com o ECC. A Figura 18 possui o a função
que realiza a descriptograﬁa com o RSA. As chaves ﬁcam armazenadas temporariamente no
state da aplicação, devido como é implementado o ECC na biblioteca, é necessário fazer um
tratamento do objeto retornado, neste caso em formato JSON e realizando um encode64 do
resultado para compactar as informações.

5.3.3 AES

Na Figura 19 é mostrada como é realizado a criptograﬁa do AES com tamanho de
chave de 256 bits e através da biblioteca crypto. A chave utilizada para criptografar os arqui-

Capítulo 5. Implementações

28

Figura 16 – Gerar Chaves ECC

Fonte: Do autor, 2022

Figura 17 – Criptografar ECC

Fonte: Do autor, 2022

Capítulo 5. Implementações

29

Figura 18 – Descriptografar ECC

Fonte: Do autor, 2022

vos é gerada aleatoriamente também através da biblioteca crypto. Na Figura 20 é realizada a
descriptograﬁa do AES e de acordo com o algoritmo utilizado, é feita a descriptograﬁa da
chave secreta.

Capítulo 5. Implementações

30

Figura 19 – Criptografar AES

Fonte: Do autor, 2022

Figura 20 – Descriptografar AES

Fonte: Do autor, 2022

6 Interface da DApp

31

Na Figura 21 pode-se obervar a tela do MetaMask que é utilizada para geranciar as
transações, já conectado na rede blockchain local simulada pelo Ganache. A interface do
MetaMask trás informações de saldo da conta dos seus ativos, o seu endereço na rede e o
histórico de transações, bem como outras conﬁgurações mais avançadas que podem ser
feitas.

Figura 21 – Tela do MetaMask

Fonte: Do autor, 2022

A Figura 22 apresenta a interface da DApp responsável por mostrar a chave pública e
privada geradas para o usuário, o qual pode fazer uso delas como também informar e salvar
outras chaves que ele está utilizando.

Na Figura 23 pode-se obervar a tela responsável por mostrar os arquivos que o
usuário possui armazenados, sendo possível realizar o download, e também é onde ele pode
realizar o envio de mais arquivos, sendo informada uma descrição e selecionado o arquivo
que se deseja enviar.

Capítulo 6. Interface da DApp

32

Figura 22 – Tela das chaves

Fonte: Do autor, 2022

Figura 23 – Tela dos arquivos

Fonte: Do autor, 2022

A interface responsável por mostrar as permissões que o usuário já enviou e para
realizar o envio de mais permissões está na Figura 24. O usuário pode informar uma descri-
ção, o tipo do arquivo, o endereço do usuário B que vai receber a permissão, a chave pública
do usuário B, o hash do arquivo que está sendo compartilhado e, por ﬁm, a data do início
que a permissão vai começar a ser válida e a data do ﬁm da válidade da permissão, ou seja,
o tempo de duração da permissão.

Na Figura 25 pode-se obervar a tela responsável por mostrar os arquivos que os
outros usuários compartilharam com o usuário que está logado atualmente na DApp, ou

Capítulo 6. Interface da DApp

33

Figura 24 – Tela das permissões

Fonte: Do autor, 2022

seja, os arquivos que o usuário A recebeu a permissão para visualizar e fazer o download,
pelo tempo de duração da permissão, de outro usuário B, C entre outros.

Capítulo 6. Interface da DApp

34

Figura 25 – Tela dos arquivos com permissões

Fonte: Do autor, 2022

7 Considerações Finais

35

Este relatório técnico apresentou detalhes da implementação da DApp proposta
no trabalho de TCC, que realiza o controle do armazenamento dos dados do usuário de
forma descentralizada através da blockchain, o armazenamento dos arquivos no IPFS e
da criptograﬁa com os algoritmos RSA ou ECC, em conjunto com AES. O intuito da Dapp
é garantir a privacidade dos dados, além de colocar o controle do gerenciamento desses
dados sob responsabilidade do usuário.

Além de trazer o fundamentos das tecnologias utilizadas, foram abordadas as fer-
ramentas necessárias para o desenvolvimento. A arquitetura da Dapp foi especiﬁcada,
juntamente com o detalhamento dos seus requisitos funcionais. Foram descritos os meca-
nismos de comunicação com o MetaMask, a blockchain e o IPFS, bem como detalhados os
processos de criptograﬁa com as bibliotecas especíﬁcas de cada algoritmo, e apresentada a
interface da Dapp para o usuário.

Como trabalhos futuros, pretende-se refatorar o código para obter o melhor desem-
penho e otimização do código. Além disso, também realizar a implementação da escolha de
utilização de um algoritmo de criptograﬁa ou de outro, ou seja, podendo deixar a cargo do
usuário a escolha de qual algoritmo quer utilizar e também deixar a aplicação com suporte
para múltiplas chaves criptográﬁcas que o usuário possa possuir.

Referências

36

DABIT, N. Contract ABI Speciﬁcation. 2021. Disponível em: <https://www.freecodecamp.
org/news/what-is-web3/>. Acesso em: 10 jan 2022. 13

ETHEREUM. Introdução aos Smart Contracts. 2017. Disponível em: <https://
solidity-portuguese.readthedocs.io/pt/latest/introduction-to-smart-contracts.html>.
Acesso em: 10 jan 2022. 3

ETHEREUM. Contract ABI Speciﬁcation. 2021. Disponível em: <https://docs.soliditylang.
org/en/develop/abi-spec.html>. Acesso em: 10 jan 2022. 3

ETHEREUM. Intro To Ethereum. 2022. Disponível em: <https://ethereum.org/en/
developers/docs/>. Acesso em: 10 jan 2022. 8

FENG, Q. et al. A survey on privacy protection in blockchain system. Journal of Network
and Computer Applications, v. 126, p. 45–58, 2019. ISSN 1084-8045. Disponível em:
<https://www.sciencedirect.com/science/article/pii/S1084804518303485>. 2

HEWA, T.; YLIANTTILA, M.; LIYANAGE, M. Survey on blockchain based smart
contracts: Applications, opportunities and challenges. Journal of Network and
Computer Applications, Elsevier, v. 177, p. 102857, 2021. ISSN 1084-8045. Disponível em:
<https://www.sciencedirect.com/science/article/pii/S1084804520303234>. 2

INFURA. The Infura Ethereum API. 2022. Disponível em: <https://infura.io/product/
ethereum>. Acesso em: 10 jan 2022. 13, 14

IPFS. How IPFS works. 2022. Disponível em: <https://ipfs.io/#how>. Acesso em: 10 jan 2022.
9, 10

KALODNER, H. et al. Arbitrum: Scalable, private smart contracts. In: 27th USENIX
Security Symposium (USENIX Security 18). Baltimore, MD: USENIX Association, 2018. p.
1353–1370. ISBN 978-1-939133-04-5. Disponível em: <https://www.usenix.org/conference/
usenixsecurity18/presentation/kalodner>. 3

MAHTO, D.; YADAV, D. K. Rsa and ecc: a comparative analysis. International journal
of applied engineering research, v. 12, n. 19, p. 9053–9061, 2017. Disponível em:
<https://www.ripublication.com/ijaer17/ijaerv12n19_140.pdf>. 4, 5, 6

MCCUBBIN, G. DAPP University. 2022. Disponível em: <https://github.com/
dappuniversity>. Acesso em: 10 jan 2022. 23

METAMASK. Introduction. 2021. Disponível em: <https://docs.metamask.io/guide/>.
Acesso em: 10 jan 2022. 11

NAKAMOTO, S. Bitcoin: A peer-to-peer electronic cash system. Decentralized Business
Review, p. 9, 2008. Disponível em: <https://bitcoin.org/bitcoin.pdf>. 1

NODE.JS. About Node.js. 2022. Disponível em: <https://nodejs.org/en/about/>. Acesso em:
10 jan 2022. 12

Referências

37

OCHÔA, I. S. et al. Fakechain: A blockchain architecture to ensure trust in social media
. [S.l.: s.n.], 2019. p. 105–118. ISBN 978-3-030-29237-9. 2
networks. In:

OLIVEIRA, P. Roberto de et al. Energy consumption analysis of the cryptographic key
generation process of rsa and ecc algorithms in embedded systems. IEEE Latin America
Transactions, v. 12, n. 6, p. 1141–1148, 2014. 4

OLIVEIRA, R. Criptograﬁa simétrica e assimétrica: os principais algoritmos de cifragem.
Revista Segurança Digital, v. 5, p. 11–24, 03 2012. 4, 7

PANDA, S. K.; SATAPATHY, S. C. An investigation into smart contract deployment on
ethereum platform using web3.js and solidity using blockchain. In: Data Engineering and
Intelligent Computing. [S.l.]: Springer, 2021. p. 549–561. 13

PATIL, P. et al. A comprehensive evaluation of cryptographic algorithms: Des, 3des, aes,
rsa and blowﬁsh. Procedia Computer Science, v. 78, p. 617–624, 2016. ISSN 1877-0509.
1st International Conference on Information Security & Privacy 2015. Disponível em:
<https://www.sciencedirect.com/science/article/pii/S1877050916001101>. 7

REACT. Introduzindo JSX. 2022. Disponível em: <https://pt-br.reactjs.org/docs/
introducing-jsx.html>. Acesso em: 10 jan 2022. 12

REACT. React. 2022. Disponível em: <https://pt-br.reactjs.org/>. Acesso em: 10 jan 2022. 12

SARAIVA, D. A. et al. Prisec: Comparison of symmetric key algorithms for iot devices.
Sensors, MDPI, v. 19, n. 19, p. 4312, 2019. 7

SHI, S. et al. Applications of blockchain in ensuring the security and privacy of electronic
health record systems: A survey. Computers & Security, v. 97, p. 101966, 2020. ISSN 0167-4048.
Disponível em: <https://www.sciencedirect.com/science/article/pii/S016740482030239X>.
3, 9

SINGH, S. R.; KHAN, A. K.; SINGH, S. R. Performance evaluation of rsa and elliptic curve
cryptography. In: 2016 2nd International Conference on Contemporary Computing and
Informatics (IC3I). [S.l.: s.n.], 2016. p. 302–306. 4

SOUSA, R. Entendendo algoritmo RSA (de verdade). 2019. Disponível em: <https:
//hackingnaweb.com/criptograﬁa/entendendo-algoritmo-rsa-de-verdade/>. Acesso em:
10 jan 2022. 5

TRUFFLESUITE. Home. 2022. Disponível em: <https://truﬄesuite.com/index.html>.
Acesso em: 10 jan 2022. 10

TRUFFLESUITE. Overview. 2022. Disponível em: <https://truﬄesuite.com/docs/truﬄe/
index.html>. Acesso em: 10 jan 2022. 10

TRUFFLESUITE. Overview. 2022. Disponível em: <https://truﬄesuite.com/docs/ganache/
index.html>. Acesso em: 10 jan 2022. 11

WÜST, K.; GERVAIS, A. Do you need a blockchain? In: IEEE. 2018 Crypto Valley Conference
on Blockchain Technology (CVCBT). [S.l.], 2018. p. 45–54. 8

ZHANG, R.; XUE, R.; LIU, L. Security and privacy on blockchain. ACM Comput. Surv.,
Association for Computing Machinery, New York, NY, USA, v. 52, n. 3, jul 2019. ISSN
0360-0300. Disponível em: <https://doi.org/10.1145/3316481>. 1, 2, 3

