2
2
0
2

n
u
J

3
1

]

R
C
.
s
c
[

1
v
9
1
0
6
0
.
6
0
2
2
:
v
i
X
r
a

SBvote: Scalable Self-Tallying Blockchain-Based
Voting

Ivana Stanˇc´ıkov´a and Ivan Homoliak

Brno University of Technology, Czech Republic

Abstract. Decentralized electronic voting solutions represent a promis-
ing advancement in electronic voting. One of the e-voting paradigms, the
self-tallying scheme, oﬀers strong protection of the voters’ privacy while
making the whole voting process veriﬁable. Decentralized smart contract
platforms became interesting practical instantiation of the immutable
bulletin board that this scheme requires to preserve its properties. Exist-
ing smart contract-based approaches employing the self-tallying scheme
(such as OVN or BBB-Voting) are only suitable for a boardroom voting
scenario due to their scalability limitation. The goal of our work is to
build on existing solutions to achieve scalability without losing privacy
guarantees and veriﬁability. We present SBvote, a blockchain-based self-
tallying voting protocol that is scalable in the number of voters, and
therefore suitable for large-scale elections. The evaluation of our proof-
of-concept implementation shows that the protocol’s scalability is limited
only by the underlying blockchain platform. We evaluated the scalability
of SBvote on two public smart contract platforms – Gnosis and Har-
mony. Despite the limitations imposed by the throughput of blockchain
platform, SBvote can accommodate elections with millions of voters.

Keywords: E-voting • scalability • privacy • blockchain • smart con-
tracts.

1

Introduction

Voting is an essential means of achieving a collective decision. Traditionally, in
large-scale voting such as national elections, the participants cast anonymous pa-
per ballots that are later tallied by a trusted authority. Following the advances
in information technology, electronic voting systems have been introduced. Elec-
tronic voting takes place either in a controlled environment of a polling station
via a dedicated machine or through the Internet via voters’ own devices.

While several small-scale or boardroom e-voting protocols with decentralized
architecture have been proposed [21,29], large-scale electronic voting systems
mostly follow a centralized model [1,9]. However, a centralized entity in control
of the voting process represents a single point of failure as well as a possible
element for misbehavior. Therefore, we strive to leverage existing decentralized
boardroom voting protocols and extend them to support large-scale voting.

The veriﬁability of many e-voting protocols depends on the assumed existence
of a public bulletin board that should provide append-only modiﬁcations and

 
 
 
 
 
 
2

I. Stanˇc´ıkov´a, I. Homoliak

immutability of the historical data [16]. All participants can read the data on
the public bulletin board and use them to verify the correctness of the voting
process. Voting systems such as Helios [1] implement the public bulletin board
as a single web server. This, however, introduces the possibility of several issues,
including unavailability of the server (e.g., due to a denial-of-service attack) or
censorship by a malicious authority controlling the server.

Other systems [21,29,33] instantiate the public bulletin board on a blockchain
with a smart contract platform. On top of the immutability and append-only
features, such blockchains also provide correct execution of a code that enables
decentralized e-voting schemes to utilize public veriﬁability of the data submitted
to the bulletin board (e.g., votes and a tally). Protocols such as Open Vote
Network (OVN) [21] and BBB-Voting [29] use smart contracts to orchestrate the
procedures of the boardroom voting protocol. The distributed nature of these
protocols also eliminates the need to rely on the authority to tally the votes. In
these approaches, referred to as self-tallying voting, any participant can perform
and verify the tally computation.

Since BBB-Voting, in contrast to OVN, provides more than two voting choices
and enables the recovery of faulty participants, we base our work on BBB-Voting.
In detail, our goal is to build a voting protocol that resolves the scalability limi-
tation of BBB-Voting while maintaining maximum voter privacy. We introduce
SBvote, a decentralized blockchain-based voting protocol that provides scala-
bility in the number of participants by grouping them into voting booths in-
stantiated as dedicated smart contracts that are controlled and veriﬁed by the
aggregation smart contract. As a result, our approach is suitable for privacy-
preserving self-tallying large-scale e-voting.

Contributions. We make the following contributions:

i) We introduce SBvote as an extension of the BBB-Voting protocol, which en-
ables scalability in the number of voters. SBvote introduces multiple voting
smart contracts booths that are managed and aggregated by a main smart
contract.

ii) Our extended solution maintains all properties of decentralized e-voting, in-
cluding public veriﬁability, perfect ballot secrecy, and fault tolerance. More-
over, it improves the privacy of voters within booths.

iii) We made a proof-of-concept implementation and evaluated it on two smart
contract platforms, Harmony and Gnosis (formerly known as xDai). We
achieved the best scalability results using the Harmony blockchain, allowing
us to run elections with 1.5M voters and two candidates within a two-days
interval.

Organization. The rest of the paper is organized as follows. Essential prelimi-
naries are presented in Section 2. We introduce SBvote in Section 3 and evaluate
its scalability in Section 4. We provide the security analysis of SBvote and dis-
cuss its properties in Section 5. We review the related work in Section 6 and
ﬁnally conclude our paper in Section 7.

SBvote: Scalable Self-Tallying Blockchain-Based Voting

3

2 Preliminaries

This section brieﬂy reviews the properties of voting protocols and provides a
short description of blockchains and smart contracts. Finally, we describe the
BBB-Voting protocol on which we base our work.

2.1 Voting

We provide a list of several desired properties of voting protocols in the following.
Privacy: The votes remain anonymous. Only the voter herself knows which can-
didate she voted for. Privacy protection is a crucial attribute of voting systems
used in practice and is very important in publicly veriﬁable voting schemes.
Perfect Ballot Secrecy: was deﬁned by Kiayias and Yung [18], and it extends
the privacy property. In a scheme with perfect ballot secrecy, a partial result can
only be revealed if all remaining voters collude to uncover it.
Self-Tallying: ensures that any interested party can compute the tally without
unblinding the individual votes.
Fault Tolerance: The protocol allows for excluding faulty participants in a
publicly veriﬁable manner without restarting the whole voting protocol.
Veriﬁability: ensures that the correctness of the voting process can be checked.
Veriﬁability includes individual veriﬁability (allowing the voter to verify her vote
has been counted) and universal veriﬁability (allowing any interested party to
verify all cast votes have been correctly tallied). Furthermore, the veriﬁability
of a voting system can be described as follows [4]:

– cast-as-intended: a voter can verify the encrypted vote contains her choice

of candidate,

– recorded-as-cast: a voter can verify the system recorded her vote correctly,
– tallied-as-recorded: any interested party is able to verify whether the ﬁnal

tally corresponds to the recorded votes.
A voting system satisfying all these properties is end-to-end veriﬁable.
Dispute-Freeness: The protocol’s design prevents disputes among involved
parties by allowing anyone to verify whether a participant followed the protocol.
Completeness: All valid votes are included in the ﬁnal tally.

2.2 Blockchains and Smart Contracts

Blockchain is a continuously growing distributed database consisting of blocks
maintained by a network of consensus nodes (i.e., that run a consensus proto-
col). Once the consensus nodes agreement on a new block, it is added to the
blockchain. The blocks are cryptographically linked to ensure the immutabil-
ity of the entire ledger, and they contain records of cryptocurrency transfers
executed within the network.

Orders to execute transfers are communicated to the network in messages
called transactions. The block may also contain application code written in a
supported language on blockchain platforms that support smart contracts. This
code is invoked by a transaction containing execution orders (i.e., function calls

4

I. Stanˇc´ıkov´a, I. Homoliak

of a smart contract). The blockchain network then acts as a decentralized com-
putation platform – the blockchain nodes execute the smart contract code.

On many smart contract platforms (such as Ethereum [31]), the execution
complexity of smart contract invocations is measured in units of gas. The sender
of a transaction containing a smart contract function call has to pay for the
consumed gas to cover the expenditure made by the nodes for carrying out the
computation. The gas price is volatile and based on the demand on the network.

2.3 BBB-Voting

BBB-Voting [29] is a system for boardroom voting supporting k ≥ 2 choices.
The basic protocol used in BBB-Voting consists of ﬁve phases (i.e., registration,
setup, pre-voting, voting, tally) and an optional fault-recovery phase. In the ﬁrst
phase, a voting authority registers eligible voters and their wallet addresses. In
the second phase, common generator g ∈ F∗
p is chosen, where p = 2·q +1 and q is
a prime. The number of participants is denoted as n and n < p − 1. To represent
k candidates, independent generators {f1, ..., fk} in F∗
p are selected. Each voter
Pi then creates her ephemeral private key as xi ∈R F∗
p and ephemeral public
key as gxi . All ephemeral public keys are submitted to a smart contract. The
multi-party computation (MPC) key for each participant is computed by the
smart contract in the third phase as follows:

h = gyi =

i−1
(cid:89)

j=1

gxj /

n
(cid:89)

gxj ,

j=i+1

(1)

j<i xj − (cid:80)

j>i xj and (cid:80)

where yi = (cid:80)
i xiyi = 0. In the fourth phase, voter Pi
computes her blinding key gxiyi and then submits her blinded vote Bi = gxiyifj
to the smart contract, where fj ∈ f1, ..., fk denotes the selected candidate. A
1-out-of-k non-interactive zero-knowledge (NIZK) proof of set membership is
submitted to the smart contract along with the blinded vote. Next, the smart
contract veriﬁes the correctness of such a vote. During the ﬁfth phase of the
protocol, the tally of votes is computed oﬀ-chain by an arbitrary party and sub-
mitted to the smart contract. The smart contract veriﬁes that the tally satisﬁes
the following equation:

n
(cid:89)

i=1

Bi =

n
(cid:89)

i=1

gxiyif = g

(cid:80)

i xiyif = f1

ct1f2

ct2...fk

ctk .

(2)

The protocol also includes an optional fault-recovery extension that can be
placed after the voting phase. This phase is useful if one or more participants
have stalled and have not cast their blinded votes.

The BBB-Voting scheme provides perfect ballot secrecy, fairness, public ver-
iﬁability, self-tallying feature, dispute-freeness, resistance to serious failures, and
maximizes the voters’ privacy (see Section 2.1). Also, it introduces several op-
timizations of the implementation to decrease the costs of the protocol and ac-
commodate a larger number of participants than the previous approaches (i.e.,
OVN [21]).

SBvote: Scalable Self-Tallying Blockchain-Based Voting

5

BBB-Voting is designed as a single smart contract on the Ethereum block-
chain. Nevertheless, BBB-Voting is intended only for boardroom voting with a
low number of involved participants. Hence it does not provide scalability as
might be required in national elections. Another limitation of BBB-Voting is the
low number of stalling participants the system can recover from in a single fault
recovery round due to the block gas limit.

3 Scalable Voting Protocol

In this section, we propose SBvote, a scalable e-voting protocol that is based on
BBB-Voting (see Section 2.3).

3.1 System Model

We focus on a decentralized e-voting that provides all desired properties of e-
voting schemes mentioned in Section 2.1 and provides scalability in the number
of the participants. We also assume a centralized authority that is responsible for
the enrollment of the participants and shifting the stages of the protocol. How-
ever, the authority can neither change nor censor the votes of the participants,
and it cannot compromise the privacy of the votes.

We assume that a public bulleting board required for e-voting is instantiated
by a blockchain platform that moreover supports the execution of smart con-
tracts. We assume that all participants of voting have their thin clients that can
verify the inclusion of their transactions in the blockchain as well as the correct
execution of the smart contract code.

Adversary Model. We consider an adversary that passively listens to commu-
nication on the blockchain network. She cannot block, modify, or replace any
transaction on the network. The adversary can link a voter’s IP address to her
blockchain address. However, she does not possess the computational resources
to break the cryptographic primitives used in the blockchain platform and the
voting protocol. The adversary cannot access or compromise the voter’s device
or the user interface of the voting application. We assume that in each voting
group of n participants, at most t of them can be controlled by the adversary
and disobey the voting protocol, where t ≤ n − 2 and n ≥ 3.

3.2 Proposed Approach

Involved Parties. Our proposed approach has the following actors and compo-
nents: (1) a participant P (also referred to as a voter ) who chooses a candidate
and casts a vote, (2) a voting authority VA who is responsible for the registra-
tion of participants and initiating actions performed by smart contracts, (3) the
main contract MC, which assigns participants to voting booths, deploys booth
contracts, and aggregates the ﬁnal tally from booth contracts, (4) a booth con-
tract BC, which is replicated into multiple instances while each instance serves

6

I. Stanˇc´ıkov´a, I. Homoliak

a limited number of participants. New instances might be added on-demand to
provide scalability.
Protocol. We depict our protocol in Figure 1. SBvote follows similar phases
as BBB-Voting but with several alterations that enable better scalability. Just
like in BBB-Voting, the registration phase assumes the existence of an Identity
Management (IDM) system that allows VA to authenticate users and generate a
list of eligible voters. In BBB-Voting, the setup phase of the protocol allows users
to submit their ephemeral public keys. However, in contrast to BBB-Voting,
SBvote requires additional steps to set up the booth contracts. First, eligible
voters are assigned to voting groups, and then BC is deployed for each voting
group. Once the setup is ﬁnished, voters proceed to submit their ephemeral
public keys during a sign-up phase. These keys are further used to compute
multi-party computation (MPC) keys within each voting group during a pre-
voting phase. In the voting phase, voters cast their blinded votes along with
corresponding NIZK proofs. The NIZK proof allows the smart contract to verify
that the blinded vote correctly encrypts one of the valid candidates. If some
of the voters who submitted their ephemeral public keys have failed to cast
their vote, the remaining active voters repair their votes in the subsequent fault
recovery phase. This is achieved by removing the stalling voters’ key material
from the encryption of the correctly cast votes. The key material has to be
provided by each active voter along with NIZK proof of correctness. After the
votes are repaired, the tallies for individual voting groups are computed during a
booth tally phase. Then, partial results are aggregated to obtain the ﬁnal tally.
In the following, we describe the phases of our protocol in more detail. Phases

2–6 are executed in parallel in each of the voting groups/booth contracts.

In this phase, the participants interact with VA to register as
Registration.
eligible voters for the voting. A suitable IDM system is required, allowing the
VA to verify participants’ identities and eligibility to participate in the voting.
Each participant creates her blockchain wallet address and registers it with the
VA. The VA stores a mapping between a participant’s identity and her wallet
address.
Phase 1 (Setup). First, the voting authority deploys the main contract to the
blockchain. Then, VA enrolls the wallet addresses of all registered participants
to MC within a transaction.1 Once all the registered participants have been
enrolled, VA triggers MC to pseudo-randomly2 distribute enrolled participants
into groups whose size is pre-determined and ensures a certain degree of privacy.
In every group, the participants agree on the parameters of the voting. Let
n be the number of participants in the group and k the number of candidates.
We specify the parameters of voting as follows:

1 Note that in practice this step utilizes transaction batching to cope with the limits

of the blockchain platform (see Section 3.3).

2 Note that distributed randomness protocols such as RoundHound [27] might be used
for this purpose, however, in this work we assume a trusted randomness source that
is agreed upon by all voters (e.g., a hash of some Bitcoin block).

SBvote: Scalable Self-Tallying Blockchain-Based Voting

7

1) a common generator g ∈ F∗
2) k independent generators {f1, ..., fk} in F∗
is the smallest integer such that 2m > n.

p, where p = 2 · q + 1, q is a prime and n < p − 1.
, where m

p such that fi = g2(i−1)m

Then, VA deploys a booth contract BC for each group of participants with
these previously agreed upon voting parameters. MC stores a mapping between
a participant’s wallet address and the group she was assigned to.

Phase 2 (Sign-Up). Eligible voters enrolled in the setup phase review the
candidates and the voting parameters. Each voter who intends to participate
obtains the address of the BC she was assigned to by MC. From this point
onward, each participant interacts only with her BC representing the group she
is part of. Every participant Pi creates her ephemeral key pair consisting of a
private key xi ∈R F∗
p and public key gxi. The Pi then sends her public key to
BC. By submitting an ephemeral public key, the participant commits to cast a
vote later. Furthermore, participants are required to send a deposit within this
transaction. If the voter does not cast her vote or later does not participate in
the potential fault recovery phase, she will be penalized by losing the deposit.
Voters who participate correctly retrieve their deposit at the end of the voting.

Phase 3 (Pre-Voting). In this step, each BC computes synchronized multi-
party computation (MPC) keys from the participants’ ephemeral public keys
submitted in the previous step. To achieve scalability, the MPC keys are com-
puted independently in each BC over the set of ephemeral public keys within
the group. The MPC key for participant Pi is computed as follows:

h = gyi =

i−1
(cid:89)

gxj /

n
(cid:89)

gxj ,

(3)

j<i xj −(cid:80)

where yi = (cid:80)

j=1
i xiyi = 0 (see Hao et al. [14] for the proof).
The computation of MPC keys is triggered by VA in each BC. After the
computation, each participant obtains her MPC key from BC and proceeds to
compute her ephemeral blinding key as gxiyi using her private key xi.

j>i xj and (cid:80)

j=i+1

Phase 4 (Voting). Before participating in this phase of the protocol, each
voter must create her blinded vote and a NIZK proof of its correctness. The
blinded vote of the participant Pi is Bi = gxiyifj, where fj ∈ f1, ..., fk represents
her choice of a candidate. The participant casts the blinded vote by sending it
to BC in a transaction cast(Bi, πM ), where πM is a 1-out-of-k NIZK proof of
set membership. This proof allows the BC to verify that the vote contains one
of the candidate generators from f1, ..., fk without revealing the voter’s choice.
BC performs a check of the proof’s correctness and accepts well-formed votes.
Construction and veriﬁcation of the NIZK proof are depicted in Figure 2.

Phase 5 (Fault-Recovery). The use of synchronized MPC keys ensures a vote
cast by each voter contains a key material shared with every other voter within
the group. If some of the voters within a group stall during the voting phase, the
tally cannot be computed from the remaining data. Therefore, we include a fault-

8

I. Stanˇc´ıkov´a, I. Homoliak

Figure 1: Overview of SBvote protocol.

verifyproofcompute key repair materialand NIZK proof of correctness πC verify group tallyverify NIZK proof πC and repair vote verify NIZK proof of membership πMcompute and store  MPC keys (gyji)store ephemeral PK (gxji) aggregate group talliescompute eph. keypair (xi, gxi)store #participants & wallet addressesassign Pi  to group Gj  wallet address of Pi compute blinding key (gxiyi)SETUPVOTINGidentity proof   tx cast {Blinded vote, πM}Pi      VAPi     ParticipantAuthorityGROUP TALLYMCtx enroll { wallet addresses of verified P[] }VAtx submitPK {eph. PK of Pi}Pi   anyone may submit tally       tx tally { ct1, …, ctk}    off-chain transferon-chain transferBlockchainSmartContractP1, P2, ...,Pn  event signupFinishedcompute ct1, …, ctk using blinded votesevent PublishResults(FinalTally)Identity verification (e.g., with 3rd party IDMor verifiable credentials)event MPCKeysComputedPRE-VOTINGtx triggerMPC {}VAtransfer by all Pi / BjREGISTRATIONBCjBlockchainSmartContractPj1, Pj2, ...,Pjm tx assign {# of groups}VAtx deployBCs {}VAtx deployBC {Gj}MCcall obtainBCaddr {Pi}SIGN-UPFAULT RECOVERYevent missingVotes   tx repair {repair data, πC}PiFINAL TALLYtx provide {Group Tally}BCjSBvote: Scalable Self-Tallying Blockchain-Based Voting

9

Participant Pi
( h ← gyi , vi)

Smart Contract
( h ← gyi )

Select vi ∈ {1, ..., k},
U se choice generators
fl ∈ {f1 , ..., fk } ⊆ F∗
p ,
P ublish x ← gxi
P ublish Bi ← hxi fl
w ∈R
∀l ∈ {1, .., k} \ vi :

F∗
p

F∗
p

1. rl , dl ∈R
2. al ← x−dl grl
Bi
3. bl ← hrl (
fl

)−dl

f or vi :
1. avi
2. bvi

← gw
← hw

c ← Hzk({{al}, {bl }}l)

dl

f or vi :
1. dvi
2. dvi
3. rvi
4. q ← p − 1
← rvi
5. rvi

← (cid:80)
l(cid:54)=vi
← c − dvi
← w + xidvi

mod q

∀l : {al }, {bl },
{rl}, {dl }(cid:45)

Ψ ← {∀l : {al }, {bl}}
c ← Hzk(Ψ )
(cid:80)

?
= c

l dl

∀l ∈ {1, .., k}
1. grl ?
2. hrl ?

= alxdl
Bi
= bl (
fl

)dl

Figure 2: Non-interactive zero-knowledge proof of 1-out-of-k set membership.

recovery phase, where remaining voters provide BC with the key material they
share with each stalling voter, enabling BC to repair their votes. In detail, for a
stalling voter Pj and an active voter Pi (i (cid:54)= j), the shared key material gxixj
consists of the stalling voter’s ephemeral public key gxj (previously published in
BC) and the active voter’s ephemeral private key xi. The active voters send the
shared key material to BC along with a NIZK proof depicted in Figure 3. The
NIZK proof allows the BC to verify that the shared key material provided by
the voter corresponds to the ephemeral public keys gxi and gxj .

Suppose some of the previously active voters become inactive during the
fault-recovery phase (i.e., do not provide the shared key material needed to
repair their votes). In that case, the fault-recovery phase can be repeated to
exclude these voters. Note that this phase takes place in groups where all the
voters who committed to vote during the sign-up phase have cast their votes.

Phase 6 (Booth Tallies). At ﬁrst, the tally has to be computed for each group
separately. Computation of the result is not performed by the BC itself. Instead,
VA (or any participant) obtains the blinded votes from the BC, computes the
tally, and then sends the result back to BC. BC veriﬁes whether a provided
tally ﬁts Equation 4.

n
(cid:89)

i=1

Bi =

n
(cid:89)

i=1

gxiyif = g

(cid:80)

i xiyif = f1

ct1f2

ct2...fk

ctk .

(4)

Phase 7 (Final Tally). Once BC obtains a correctly computed tally, it sends

10

I. Stanˇc´ıkov´a, I. Homoliak

P articipant Pi

xj , xi

A ← gxi , B ← g
Let wi, ∈r Fp
xixj
C ← g
m1 ← gwi
m2 ← Bwi
c ← Hzk (A, B, m1, m2 )
ri ← wi + cxi

Smart Contract
A ← gxi , B ← g

xj

C, ri, m1, m2(cid:45) c ← Hzk (A, B, m1 , m2)
gr ?
Br ?

= m1Ac
= m2 Cc

Figure 3: NIZK proof verifying correspondence of gxixj to public keys A =
gxi, B = gxj .

it to MC. MC collects and summarizes the partial tallies from individual booths
and announces the ﬁnal tally once all booths have provided their results. The
participants can also review the partial results from already processed booths
without waiting for the ﬁnal tally since the booths tallies are processed indepen-
dently.

3.3 Design Choices and Optimizations

We introduce several speciﬁc features of SBvote, which allow us to achieve the
scalability and privacy properties.

Storage of Voters’ Addresses. If we were to store the voters’ wallet addresses
in the booth contracts, it would cause high storage overhead and thus high
costs. However, we proposed to store these addresses only in MC, while booth
contracts can only query MC whenever they require these addresses (i.e., when
they verify whether a voter belongs to the booth’s group). As a result, this
eliminates the costs of transactions when deploying booth contracts, saving the
blockchain storage space.

Elimination of Bottlenecks. The main focus of our proposed approach is the
elimination of the bottlenecks that limit the total number of voters and the size
of the voting groups. In particular, passing the data within a single transaction
could potentially exceed the block gas limit.

The scalability of the Setup phase of SBvote is straightforward to resolve since
it does not involve any transient integrity violation checks (excluding checking
for duplicates). In all these cases, VA splits the data into multiple independent
transactions. Similarly, each active voter can send the key material required
to repair her vote in several batches in the Fault-Recovery phase, allowing the
system to recover from an arbitrary number of stalling participants.

In contrast to the Setup and Fault-Recovery phases, batching in the Pre-
Voting phase is not trivial since it requires transient preservation of integrity
between consecutive batches of the particular voting group. Therefore, we used
a custom batching mechanism, which eliminates this bottleneck while also opti-
mizing the cost of the MPC computation.

SBvote: Scalable Self-Tallying Blockchain-Based Voting

11

Algorithm 1 Pre-computation of right side values of Equation 3
Inputs:

– the number of voters n
– batch size for MPC computation mpc batch
– array of voters’ ephemeral public keys voterP Ks

Outputs:

– pre-computed right side values right markers

right markers.push(right tmp)

1: right tmp ← 0
2: if n mod mpc batch (cid:54)= 0 then
3:
4: end if
5: for i ← 0 to n do
6:
7:
8:
9:
10: end for

right markers.push(right tmp)

end if
right tmp ← right tmp × voterP Ks[n − i]

if n mod mpc batch = (i − 1) mod mpc batch then

MPC Batching and Optimization. If computed independently for each par-
ticipant, the computation of MPC keys leads to a high number of overlapping
multiplications. Therefore, we optimize this step by dividing the computation
into two parts, respecting both sides of the expression in Equation 3 and reusing
accumulated values for each side.

First, we pre-compute the right part (i.e., divisor) of Equation 3, which con-
sists of a product of ephemeral public keys of voters with a higher index than
the current voter’s one (i.e., i in Equation 3). The product is accumulated and
saved in the contract’s storage at regular intervals during a single iteration over
all ephemeral public keys. The size of these intervals corresponds to the batch
size chosen for the computation of the remaining (left side) of the equation. We
refer to these saved values as right markers (see Algorithm 1). We only choose to
save the right markers instead of saving all accumulated values due to the high
cost of storing data in the contract’s persistent storage. Though the intermedi-
ate values between right markers have to be computed again later, they are only
kept in memory (not persistent between consecutive function calls). Therefore,
they do not signiﬁcantly impact the cost of the computation.

The second part of the computation is processed in batches. First, the right-
side values for all voters within the current batch are obtained using the pre-
computed right marker corresponding to this batch (see lines 1–5 of Algorithm 2).
Then, the left part of Equation 3 is computed for each voter within the batch,
followed by evaluating the entire equation to obtain the MPC key (lines 6–9 of
Algorithm 2). This left-side value is not discarded; therefore, computing the left
side for the next voter’s MPC key only requires single multiplication. The last
dividend value in the current batch is saved in the contract’s storage to allow its
reuse for the next batch.

4 Evaluation

To evaluate the scalability of SBvote, we created an implementation of the proto-
col, which builds on BBB-Voting [29]. We used the Truﬄe framework and Solidity

12

I. Stanˇc´ıkov´a, I. Homoliak

Algorithm 2 Computation of a batch of MPC keys
Inputs:

– array of voters’ ephemeral public keys voterP Ks
– batch size for MPC computation mpc batch
– start index start and the end index end of the current batch
– pre-computed right side value for the ﬁrst index in batch right marker
– left side value from the previous batch act lef t

Outputs:

– left side value at the last index of the current batch act lef t
– array of MPC keys for the current batch mpc keys

Compute right side values for the batch:
1: right tab[mpc batch − 1] ← right marker
2: for i ← 0 to mpc batch do
3:
j ← mpc batch − i
4:
right tab[j − 1] ← right tab[j] × voterP Ks[i − 1]
5: end for
Compute the current batch of MPC keys:
6: for i ← start to end do
7:
8: end for
9: mpc keys[i] ← act lef t ÷ right tab[i] mod mpc batch

act lef t ← act lef t × voterP Ks[i − 1]

programming language to implement the smart contract part and Javascript for
the client API of all other components. We also utilized the Witnet library [30]
for on-chain elliptic curve operations on the standardized Secp256k1 curve [25].
Although Solidity was primarily intended for Ethereum and its Ethereum Vir-
tual Machine (EVM), we have not selected Ethereum for our evaluation due
to its high operational costs and low transactional throughput. However, there
are many other smart contract platforms supporting Solidity and EVM, out of
which we selected Gnosis [32] and Harmony [15] due to their low costs and high
throughput.

MPC batch size. The MPC keys in the Pre-Voting phase are computed in
batches (see Section 3.3). In detail, there is a pre-computed value available for
the ﬁrst voter in each batch. This results in a trade-oﬀ between high overhead
cost (in terms of units of gas) when selecting a small batch size resulting in many
transactions and high execution cost due to utilizing fewer pre-computed values
with larger batch sizes. Figure 4 illustrates how the batch size aﬀects the cost of
the computation per voter.

The number of candidates. The number of candidates our voting system can
accommodate remains limited. This is due to the block gas limit of a particular
platform. In detail, we can only run voting with a candidate set small enough
so that the vote-casting transaction does not exceed the underlying platform’s
block gas limit. Such transaction must be accompanied by a NIZK proof of set
membership (i.e., proof that the voter’s encrypted choice belongs to the set of
candidates), and the size of the candidate set determines its execution complex-
ity. Figure 5 illustrates this dependency. Our experiments show the proposed
system can accommodate up to 38 candidates on Harmony and only 14 candi-
dates on Gnosis.

SBvote: Scalable Self-Tallying Blockchain-Based Voting

13

Figure 4: The cost [gas] per voter of the
MPC key computation based on the
chosen batch size.

Figure 5: The cost [gas] of casting a
vote based on the number of candi-
dates.

Figure 6: Maximum num-
ber of candidates (5-day
voting phase).

(a) On Gnosis.

(b) On Harmony.

Figure 7: The maximum number of voters SBvote
can accommodate.

The total number of participants. The time period over which the voters
can cast their ballots typically lasts only several days in real-life elections. The
platform’s throughput over a restricted time period and the high cost of the
vote-casting transactions result in a trade-oﬀ between the number of voters and
the number of candidates. We evaluated the limitations of the proposed voting
protocol on both Harmony and Gnosis, as shown in Figure 6 and Figure 7. Note
that in these examples, we considered only the voting phase of the protocol
to be time-restricted. We determined that with two candidates, the proposed
system can accommodate ∼1.5M voters over a 2-day voting period or up to 3.8M
voters over a 5-day voting period on the Harmony blockchain. However, with 38
candidates (maximum possible on Harmony), over a 5-day voting period, only
216K voters can participate.

5 Security Analysis and Discussion

We discuss the properties and scenarios aﬀecting the security of SBvote.

Privacy. Within each voting group, SBvote maintains perfect ballot secrecy.
The adversary, as deﬁned in Section 3.1, cannot reveal a participant’s vote
through a collusion of all remaining participants since adversary can control
at most n − 2 participants. The privacy of votes can be violated only if all

Gas consumption per voter7,75E+047,763E+047,777E+047,79E+047,803E+047,817E+047,83E+04MPC batch size501502503504501000 voters1500 voters3000 voters2643200864001296001728002160002743200864001296001728002160002843200864001296001728002160002943200864001296001728002160003043200864001296001728002160003143200864001296001728002160003243200864001296001728002160003343200864001296001728002160003443200864001296001728002160003543200864001296001728002160003643200864001296001728002160003743200864001296001728002160003843200864001296001728002160001 day2 days3 days4 days5 days# of candidates/voting phase lengthHow many candidates in a 2-day voting# of votersGnosisHarmony5000073810000041915000021920000021225000001230000009MAximum number of candidates0481216202428323640Number of voters50000100000150000200000250000300000HarmonyGnosisHow many candidates in a 5-day voting# of votersGnosisHarmony500001438150000738250000419350000219450000212550000012Maximum number of candidates0481216202428323640Number of voters50000150000250000350000450000550000HarmonyGnosisHow many candidates in a 5-day voting-1# of votersGnosisHarmony800001438160000738240000419320000419400000219480000212Maximum # of candidates0481216202428323640# of voters80000160000240000320000400000480000HarmonyGnosisMaximum number of candidates based on the number of votersTable 12430000030000000364000003000000048500000300000005106000003000000061270000030000000714800000300000008169000003000000091900000030000000102110000030000000112320000030000000122530000030000000132740000030000000142950000030000000153160000030000000163370000030000000173580000030000000183790000030000000194000000030000000Cost [units of gas]8,333E+061,667E+072,5E+073,333E+074,167E+075E+07The number of candidates234567891011121314151617181920Gnosis (xDai) block size limit2Maximum number of candidates0481216202428323640Number of voters50000150000250000350000450000550000HarmonyGnosisRM costVotersMPC_batch8010RM_batchRM_batchgas in buildRMper voterMPC_batch*110184342223042,775MPC_batch*220159561319945,1625MPC_batch*330153384119173,0125MPC_batch*440147222618402,825MPC_batch*550147232318404,0375MPC_batch*660147259518407,4375MPC_batch*770147304418413,05MPC_batch*880141156117644,5125RightMarkers comp cost depends on the number of MPC batches prepared in one RM batchGas consumption per voter1500017250195002175024000Pre-computation batch size1020304050607080MPC cost# of voters/MPC_batch50100150200250500750950100078192776627760777613776907827778811796561250150077680782687894617502000gas cost per voter for different size of MPC_batchHow many voters max — Gnosis# of candidates/voting phase length1 day2 days3 days4 days5 days21036802073603110404147205184003691201382402073602764803456004691201382402073602764803456005345606912010368013824017280063456069120103680138240172800734560691201036801382401728008172803456051840691208640091728034560518406912086400101728034560518406912086400111728034560518406912086400121728034560518406912086400131728034560518406912086400141728034560518406912086400How many voters max — Harmony# of candidates/voting phase length1 day2 days3 days4 days5 days2777600155520023328003110400388800035184001036800155520020736002592000438880077760011664001555200194400053024006048009072001209600151200062592005184007776001036800129600072160004320006480008640001080000817280034560051840069120086400091728003456005184006912008640001012960025920038880051840064800011129600259200388800518400648000121296002592003888005184006480001386400172800259200345600432000148640017280025920034560043200015864001728002592003456004320001686400172800259200345600432000178640017280025920034560043200018864001728002592003456004320001986400172800259200345600432000204320086400129600172800216000214320086400129600172800216000224320086400129600172800216000234320086400129600172800216000244320086400129600172800216000254320086400129600172800216000# of candidates/voting phase lengthMaximum number of voters0,00E+005,00E+051,00E+061,50E+062,00E+062,50E+063,00E+063,50E+064,00E+06Number of candidates24681012141618202224262830323436381 day2 days3 days4 days5 daysMaximum number of voters0,00E+007,50E+041,50E+052,25E+053,00E+053,75E+054,50E+055,25E+056,00E+05The number of candidates2345678910111213141 day2 days3 days4 days5 daysVoting phase duration:77000777507850079250800005010015020025050075095010001500Voting phase duration:1RM costVotersMPC_batch8010RM_batchRM_batchgas in buildRMper voterMPC_batch*110184342223042,775MPC_batch*220159561319945,1625MPC_batch*330153384119173,0125MPC_batch*440147222618402,825MPC_batch*550147232318404,0375MPC_batch*660147259518407,4375MPC_batch*770147304418413,05MPC_batch*880141156117644,5125RightMarkers comp cost depends on the number of MPC batches prepared in one RM batchGas consumption per voter1500017250195002175024000Pre-computation batch size1020304050607080MPC cost# of voters/MPC_batch50100150200250500750950100078192776627760777613776907827778811796561250150077680782687894617502000gas cost per voter for different size of MPC_batchHow many voters max — Gnosis# of candidates/voting phase length1 day2 days3 days4 days5 days21036802073603110404147205184003691201382402073602764803456004691201382402073602764803456005345606912010368013824017280063456069120103680138240172800734560691201036801382401728008172803456051840691208640091728034560518406912086400101728034560518406912086400111728034560518406912086400121728034560518406912086400131728034560518406912086400141728034560518406912086400How many voters max — Harmony# of candidates/voting phase length1 day2 days3 days4 days5 days2777600155520023328003110400388800035184001036800155520020736002592000438880077760011664001555200194400053024006048009072001209600151200062592005184007776001036800129600072160004320006480008640001080000817280034560051840069120086400091728003456005184006912008640001012960025920038880051840064800011129600259200388800518400648000121296002592003888005184006480001386400172800259200345600432000148640017280025920034560043200015864001728002592003456004320001686400172800259200345600432000178640017280025920034560043200018864001728002592003456004320001986400172800259200345600432000204320086400129600172800216000214320086400129600172800216000224320086400129600172800216000234320086400129600172800216000244320086400129600172800216000254320086400129600172800216000# of candidates/voting phase lengthMaximum number of voters0,00E+005,00E+051,00E+061,50E+062,00E+062,50E+063,00E+063,50E+064,00E+06Number of candidates24681012141618202224262830323436381 day2 days3 days4 days5 daysMaximum number of voters0,00E+007,50E+041,50E+052,25E+053,00E+053,75E+054,50E+055,25E+056,00E+05The number of candidates2345678910111213141 day2 days3 days4 days5 daysVoting phase duration:77000777507850079250800005010015020025050075095010001500Voting phase duration:114

I. Stanˇc´ıkov´a, I. Homoliak

participants in a voting group vote for the same candidate. However, this is a
natural property of voting protocols, which output the tally rather than only the
winning candidate. SBvote mitigates this problem by implementing transaction
batching that eliminates bottlenecks aﬀecting the size of the voting groups. This
allows the authority to maintain a suﬃciently large size of the voting groups to
lower the probability of a unanimous vote within the groups. We refer the reader
to the work of Ullrich [28] that addresses the issue of unanimous voting and the
probability of its occurrence.

Deanonymization & Linking Addresses. In conventional blockchains, the
network-level adversary might be able to link the participant’s address with her
IP address. Such an adversary can also intercept the participant’s blinded vote;
however, she cannot extract the vote choice due to the privacy-preserving feature
of our voting protocol. Therefore, even if the adversary were to tie the IP address
to the participant’s identity, the only information it would be able to obtain is
whether she has voted. Nevertheless, to prevent the linking of addresses, the
participant can use VPNs or anonymization services such as Tor.

Re-Voting. It is important to ensure that no re-voting is possible, which is to
avoid any inference about the ﬁnal vote of a participant in the case she would
reuse her ephemeral blinding key to change her vote during the voting stage.
Such a re-voting logic can be easily enforced by the smart contract, while the
user interface of the participant should also not allow re-voting. Also, note that
ephemeral keys are one-time keys and thus are intended to use only within one
instance of e-voting protocol to ensure the security and privacy of the protocol. If
a participant were to vote in a diﬀerent instance of e-voting, she would generate
new ephemeral keys.

Forks in Blockchain. Since our protocol does not contain any two-phase com-
mitment scheme with revealed secrets, its security is not impacted by accidental
or malicious forks. Temporary forks do not impact the voting stage as well since
the same votes can be resubmitted again by client interfaces.

Self-Tallying Property. We note that the self-tallying property only holds
within each voting group, not for the voting instance as a whole. The main
contract aggregates the booth tallies, not the actual blinded votes. However, the
integrity of this step is enforced by the smart contract and is fully veriﬁable since
all booth tallies are publicly available on the blockchain.

Veriﬁability. SBvote achieves both individual and universal veriﬁability. By
querying the booth contract, each voter can verify her vote has been recorded.
Each voter, as well as any interested third party, can verify the booth tally since
it satisﬁes the self-tallying property, i.e., the Equation 4 would not hold should
any vote be left out. Any party can verify the ﬁnal tally aggregated by the main
contact by querying the booth contracts to obtain individual booth tallies.

Platform-Dependent Limitations. Although our system itself does not limit
the number of participants, the required transactions are computationally inten-

SBvote: Scalable Self-Tallying Blockchain-Based Voting

15

sive, which results in high gas consumption. Therefore, large-scale voting using
our system might be too demanding for the underlying smart contract platform.
As a potential solution, public permissioned blockchains dedicated to e-voting
might be utilized.

Adversary Controlling Multiple Participants in Fault Recovery. One
issue that needs to be addressed in the fault recovery is an adversary controlling
multiple participants and letting them stall one by one in each fault recovery
round. Even though the fault recovery mechanism will eventually ﬁnish with no
new stalling participants, such behavior might increase the costs paid by remain-
ing participants who are required to submit counter-party shares in each round
of the protocol. For this reason, similar to the voting stage, we require the fault
recovery stage to penalize stalling participants by losing the deposit they put
into the smart contract at the beginning of our protocol. On the other hand, the
adversary can cause a delay in the voting protocol within a particular booth,
which, however, does not impact other booths. To further disincentivize the ad-
versary from such behavior, the fault-recovery might require additional deposits
that could be increased in each round by some constant, while all deposits could
be redeemed at the tally stage.

Tally computation. Tallying the results in individual booths requires an ex-
haustive search for a solution of Equation 4 with (cid:0)n+k−1
(cid:1) possible solutions [14],
where n is the number of votes and t is the number of candidates. Therefore, the
authority should select the size of the voting groups accordingly to the budget
and available computational resources (see [29] for experimental evaluation).

k−1

6 Related Work

In this section, we provide a brief survey of existing e-voting solutions.

Several protocols have been proposed, focusing on ensuring the vote’s privacy
rather than breaking the map between the voter and her ballot. Cohen and
Fisher [8] proposed a veriﬁable voting scheme where the participants cannot
unveil the votes. However, the election authority in this scheme has the ability
to read any vote. Cohen [7] provided an extension to this scheme, where the
function of authority is distributed among an arbitrary number of tellers. At
least one honest teller is suﬃcient to ensure the privacy of the votes.

Several other works based on the approach from [8], such as [11,5,10,24]. The
multi-authority protocol proposed by Cramer et al. [11] employs the ElGamal
cryptosystem to guarantee vote privacy. This protocol can tolerate malicious
behavior of a constant fraction of authorities. Baudron et al. [3] focused on
multi-candidate elections with hierarchical levels of authorities.

Kiayias and Yung [18] introduced a new voting paradigm with properties
they deﬁned – self-tallying, perfect ballot secrecy, and dispute-freeness. The pro-
tocol presented by Groth [13] improved the computational complexity of [18] but

16

I. Stanˇc´ıkov´a, I. Homoliak

required more rounds of computation as a trade-oﬀ. Hao et al. [14] further im-
proved this approach and created a 2-round self-tallying voting scheme. Khader
et al. [17] proposed a variant of [14] that also ensures fairness and robustness.

Protocols based on [8] and [18] as well as other approaches ([20,23,1,9,6]) re-
quire a public bulletin board (PBB), deﬁned as a broadcast channel with mem-
ory. As deﬁned, PBB is not aﬀected by denial-of-service attacks and allows each
participant to write solely in her designated section in an append-only manner.
To achieve these properties in practice, Cramer et al. [11] suggest implementing
PBB as a set of replicated servers running a Byzantine agreement protocol. The
introduction of blockchain technology brought a suitable solution for a practical
instantiation of PBB since it oﬀers the required properties of immutability and
accessibility.

McCorry et al. [21] were the ﬁrst to implement the self-tallying scheme using
smart contracts on Ethereum. However, their system, the Open Vote Network,
is only suitable for a small-scale (boardroom) voting. Venugopalan et al. [29]
presented BBB-Voting, also a boardroom voting protocol, but with several im-
provements in contrast to OVN. BBB-voting [29] supports multiple candidate
choices and provides cost-optimized implementation on Ethereum. Seifelnasr et
al. [26] improved the scalability of [21] by reducing the storage requirements and
delegating the tally computation to an oﬀ-chain entity.

Besides the implementations of the self-tallying approach, other blockchain-
based voting systems have been proposed, such as Zhang et al. [35], Alvi et
al. [2], Dagher et al. [12] (BroncoVote), Killer et al. [19] (Provotum) or Zhang
et al. [34] (Chaintegrity). Blockchain-based voting was also criticized by Park et
al. [22] for bringing additional security issues rather than improvements.

7 Conclusion

In this paper, we present a scalable self-tallying blockchain-based voting proto-
col. We made an implementation of the protocol and evaluated its performance
on two EVM-compatible platforms – Gnosis and Harmony. We showed that
our protocol is fully scalable to accommodate large-scale voting, with the only
limitation being the throughput of the underlying blockchain platform. Our ex-
periments show that our system can run voting with millions of participants on
a suﬃciently fast blockchain (e.g., Harmony).

In our future work, we will focus on replacing the NIZK proofs of the vot-
ing phase with zk-SNARKs to achieve a constant complexity of vote casting
independent of the number of candidates. Further, we intend to investigate the
techniques used to increase the throughput of smart contract platforms (e.g.,
sharding) and analyze the impact of these approaches on the security properties
and scalability of SBvote.

SBvote: Scalable Self-Tallying Blockchain-Based Voting

17

References

1. Adida, B.: Helios: Web-based open-audit voting. In: Proceedings of the 17th
USENIX Security Symposium, July 28-August 1, 2008, San Jose, CA, USA. pp.
335–348. USENIX Association, Berkeley, California (2008)

2. Alvi, S.T., Uddin, M.N., Islam, L., Ahamed, S.: A privacy-aware digital voting sys-
tem employing blockchain and smart contracts. In: 2020 IEEE Asia-Paciﬁc Con-
ference on Computer Science and Data Engineering (CSDE). pp. 1–6. IEEE (2020)
3. Baudron, O., et al.: Practical multi-candidate election system. In: PODC ’01. pp.

274–283. ACM, New York, NY, USA (2001)

4. Benaloh, J., Rivest, R., Ryan, P.Y., Stark, P., Teague, V., Vora, P.: End-to-end

veriﬁability. arXiv preprint arXiv:1504.03778 (2015)

5. Benaloh, J.C., Yung, M.: Distributing the power of a government to enhance the
privacy of voters. In: PODC ’86. pp. 52–62. ACM, New York, NY, USA (1986)
6. Clarkson, M.R., Chong, S., Myers, A.C.: Civitas: Toward a secure voting system.
In: 2008 IEEE Symposium on Security and Privacy (sp 2008). pp. 354–368. IEEE
(2008)

7. Cohen, J.D.: Improving privacy in cryptographic elections (1986)
8. Cohen, J.D., Fischer, M.J.: A robust and veriﬁable cryptographically secure elec-
tion scheme. In: SFCS ’85. pp. 372–382. IEEE Computer Society, Washington, DC,
USA (1985)

9. Cortier, V., Gaudry, P., Glondu, S.: Belenios: a simple private and veriﬁable elec-
tronic voting system. In: Foundations of Security, Protocols, and Equational Rea-
soning, pp. 214–238. Springer (2019)

10. Cramer, R., Franklin, M., Schoenmakers, B., Yung, M.: Multi-authority secret-
ballot elections with linear work. In: International Conference on the Theory and
Applications of Cryptographic Techniques. pp. 72–83. Springer (1996)

11. Cramer, R., Gennaro, R., Schoenmakers, B.: A secure and optimally eﬃcient multi-
authority election scheme. In: EUROCRYPT ’97, Konstanz, Germany, May 11-15,
1997, Proceeding. vol. 1233, pp. 103–118. Springer, New York City (1997)

12. Dagher, et al.: Broncovote: Secure voting system using ethereum’s blockchain.
In: ICISSP 2018, Funchal, Madeira - Portugal, January 22-24, 2018. pp. 96–107.
SCITEPRESS, Set´ubal, Portugal (2018)

13. Groth, J.: Eﬃcient maximal privacy in boardroom voting and anonymous broad-
cast. In: Juels, A. (ed.) Financial Cryptography. pp. 90–104. Springer Berlin Hei-
delberg, Berlin, Heidelberg (2004)

14. Hao, F., Ryan, P.Y.A., Zielinski, P.: Anonymous voting by two-round public dis-

cussion. IET Information Security 4(2), 62–67 (2010)

15. Gnosis chain. on-line, https://www.xdaichain.com
16. Heather, J., Lundin, D.: The append-only web bulletin board. In: International
Workshop on Formal Aspects in Security and Trust. pp. 242–256. Springer (2008)
17. Khader, D., Smyth, B., Ryan, P.Y.A., Hao, F.: A fair and robust voting system by
broadcast. In: (EVOTE 2012), July 11-14, 2012, Castle Hofen, Bregenz, Austria.
pp. 285–299. GI, Bonn, Germany (2012)

18. Kiayias, A., Yung, M.: Self-tallying elections and perfect ballot secrecy. In: Nac-
cache, D., Paillier, P. (eds.) Public Key Cryptography. pp. 141–158. Springer Berlin
Heidelberg, Berlin, Heidelberg (2002)

19. Killer, C., Rodrigues, B., Scheid, E.J., Franco, M., Eck, M., Zaugg, N., Scheitlin,
A., Stiller, B.: Provotum: A blockchain-based and end-to-end veriﬁable remote elec-
tronic voting system. In: 2020 IEEE 45th Conference on Local Computer Networks
(LCN). pp. 172–183 (2020). https://doi.org/10.1109/LCN48667.2020.9314815

18

I. Stanˇc´ıkov´a, I. Homoliak

20. Lueks, W., Querejeta-Azurmendi, I., Troncoso, C.: {VoteAgain}: A scalable
coercion-resistant voting system. In: 29th USENIX Security Symposium (USENIX
Security 20). pp. 1553–1570 (2020)

21. McCorry, P., Shahandashti, S.F., Hao, F.: A smart contract for boardroom voting
with maximum voter privacy. In: Financial Cryptography and Data Security -
21st International Conference, FC 2017, Sliema, Malta, April 3-7, 2017, Revised
Selected Papers. pp. 357–375. Springer-Verlag, Berlin, Heidelberg (2017)

22. Park, S., Specter, M., Narula, N., Rivest, R.L.: Going from bad to worse: from

internet voting to blockchain voting (2020)

23. Ryan, P.Y.A., Bismark, D., Heather, J., Schneider, S., Xia, Z.: Prˆet `a voter: a
voter-veriﬁable voting system. IEEE Trans. Information Forensics and Security
4(4), 662–673 (2009)

24. Schoenmakers, B.: A simple publicly veriﬁable secret sharing scheme and its ap-
plication to electronic voting. In: CRYPTO’ 99. pp. 148–164. Springer Berlin Hei-
delberg, Berlin, Heidelberg (1999)

25. SEC, S.: 2: Recommended elliptic curve domain parameters. Standards for Eﬃcient

Cryptography Group, Certicom Corp (2000)

26. Seifelnasr, M., Galal, H.S., Youssef, A.M.: Scalable open-vote network on ethereum.
In: International Conference on Financial Cryptography and Data Security. pp.
436–450. Springer (2020)

27. Syta, E., Jovanovic, P., Kogias, E.K., Gailly, N., Gasser, L., Khoﬃ, I., Fischer, M.J.,
Ford, B.: Scalable bias-resistant distributed randomness. In: 2017 IEEE Sympo-
sium on Security and Privacy (SP). pp. 444–460. Ieee (2017)

28. Ullrich, P.: The risk to breach vote privacy by unanimous voting. Journal of Infor-

mation Security and Applications 35, 168–174 (2017)

29. Venugopalan, S., Homoliak, I., Li, Z., Szalachowski, P.: Bbb-voting: 1-out-of-k
blockchain-based boardroom voting. arXiv preprint arXiv:2010.09112 (2020)

30. Witnet Team: elliptic-curve-solidity. [Online] (2019)
31. Wood, G.: Ethereum: A secure decentralized generalized transaction ledger. [On-

line] (2014)

32. Gnosis chain. on-line, https://www.xdaichain.com
33. Yang, Y., Guan, Z., Wan, Z., Weng, J., Pang, H.H., Deng, R.H.: Priscore:
blockchain-based self-tallying election system supporting score voting. IEEE Trans-
actions on Information Forensics and Security 16, 4705–4720 (2021)

34. Zhang, S., Wang, L., Xiong, H.: Chaintegrity: blockchain-enabled large-scale e-
voting system with robustness and universal veriﬁability. International Journal of
Information Security 19(3), 323–341 (2020)

35. Zhang, W., et al.: A privacy-preserving voting protocol on blockchain. In: CLOUD
2018, San Francisco, CA, USA, July 2-7, 2018. pp. 401–408. IEEE, Washington,
DC (2018)

