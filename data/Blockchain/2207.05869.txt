2
2
0
2

l
u
J

2
1

]

R
C
.
s
c
[

1
v
9
6
8
5
0
.
7
0
2
2
:
v
i
X
r
a

Achieving Almost All Blockchain Functionalities
with Polylogarithmic Storage

Parikshit Hegde1, Robert Streit1, Yanni Georghiades1, Chaya Ganesh2, and
Sriram Vishwanath1

1 The University of Texas at Austin, TX, USA {hegde, rpstreit,
yanni.georghiades, sriram}@utexas.edu
2 Indian Institute of Science, KA, India
chaya@iisc.ac.in

Abstract. In current blockchain systems, full nodes that perform all of
the available functionalities need to store the entire blockchain. In addi-
tion to the blockchain, full nodes also store a blockchain-summary, called
the state, which is used to eﬃciently verify transactions. With the size of
popular blockchains and their states growing rapidly, full nodes require
massive storage resources in order to keep up with the scaling. This leads
to a tug-of-war between scaling and decentralization since fewer entities
can aﬀord expensive resources. We present hybrid nodes for proof-of-work
(PoW) cryptocurrencies which can validate transactions, validate blocks,
validate states, mine, select the main chain, bootstrap new hybrid nodes,
and verify payment proofs. With the use of a protocol called trimming,
hybrid nodes only retain polylogarithmic number of blocks in the chain
length in order to represent the proof-of-work of the blockchain. Hybrid
nodes are also optimized for the storage of the state with the use of
stateless blockchain protocols. The lowered storage requirements should
enable more entities to join as hybrid nodes and improve the decentral-
ization of the system. We deﬁne novel theoretical security models for
hybrid nodes and show that they are provably secure. We also show that
the storage requirement of hybrid nodes is near-optimal with respect to
our security deﬁnitions.

Keywords: Blockchains, Cryptocurrency, Storage, NIPoPoW, Hybrid
Nodes, Trimming

1

Introduction

Blockchains enable a group of untrusting parties to securely maintain a dis-
tributed ledger without relying on a trusted third party. Instead, the power to
decide what is recorded in the blockchain is distributed amongst a set of de-
centralized nodes. This property is desirable for applications used by a set of
mutually distrustful parties, such as a digital currency. For this reason, cryp-
tocurrencies are a fundamental application of blockchains and are increasingly
growing in popularity. In this paper, we focus on cryptocurrencies built on top of
a proof-of-work (PoW) blockchain employing the longest chain rule. A blockchain
node for a cryptocurrency typically has the following functionalities:

 
 
 
 
 
 
2

P. Hegde et al.

1. Transaction validation: When the node receives a new transaction, it checks
if the transaction is valid with respect to the transactions already conﬁrmed
in the blockchain.

2. Block validation: When the node receives a new block, it veriﬁes that the
block hash is valid, all the transactions in the block are valid, and the block
otherwise follows all of the conventions imposed by the protocol.

3. State Validation: Given a summary of currency ownership in the system,

called the state, the node veriﬁes that the state is consistent with the
blockchain.

4. Mining: The node can append a block to the blockchain by verifying its
contents and producing a PoW for the block. A node which does not mine
blocks is assumed to have mining power 0.

5. Chain Selection: Given a set of conﬂicting chains, the node can choose the
main chain which has the most PoW. Any two honest nodes which receive
the same set of conﬂicting chains in the same order must select the same
main chain.

6. Bootstrapping new nodes to the blockchain: A node can provide new nodes

entering the system with the blockchain.

7. Serving payment proofs: Given a transaction tx, the node can provide a proof

of tx’s inclusion in the blockchain.

8. Veriﬁcation of payment proofs: Given a proof of transaction tx’s inclusion in

the blockchain, the node can verify the correctness of the proof.

In order to have all of the functionalities above, a node must verify and
store the entire blockchain. We will refer to such nodes as full nodes. Popular
systems like Bitcoin and Ethereum also allow for other types of nodes with more
limited functionalities [35, 29]. For instance, pruned nodes initially download
the entire blockchain and verify it. However, they later prune the blockchain,
meaning that they discard block data and only retain block headers for blocks
older than the most recent k blocks in the blockchain. By retaining a summary of
the blockchain called the state, they can still perform all desired functionalities
except for serving proofs of payment and bootstrapping new nodes. Lightweight
nodes only download the block-headers, and their only functionality is to verify
payment proofs provided by full nodes. Importantly, full nodes are necessary to
bootstrap both pruned and lightweight nodes into the blockchain.

Since full nodes need to store the entire blockchain, their resource require-
ments can be high. This is an entry barrier that makes fewer nodes partici-
pate, which leads to a centralization of trust. In this paper, we optimize storage
requirements in order to lower this entry barrier. In deference to the storage
capabilities of modern computational hardware, we divide storage into two cat-
egories. The ﬁrst is cold storage, which is accessed infrequently and is stored on
disk. This includes older blocks that are deep inside the blockchain. The second is
hot storage, which is accessed frequently and is stored in memory. Naturally, the
blockchain state used to validate blocks and transactions is kept in hot storage.
In this paper, we propose a new class called hybrid nodes. Hybrid nodes
have all of the above functionalities except for the ability to provide payment

Achieving Almost All Blockchain Functionalities with Polylog. Storage

3

proofs. Importantly, hybrid nodes can bootstrap new hybrid nodes into the sys-
tem, meaning they do not depend on any other type of nodes, including full
nodes. Moreover, if B is the length of the blockchain, hybrid nodes only require
polylog(B) cold storage to represent the PoW of the chain. This is achieved by
a process we call trimming, an extension of non-interactive-proofs-of-proof-of-
work [25] (henceforth, NIPoPoW). NIPoPoW is a protocol that enables a prover
(which is most often a full node) to provide payment proofs of polylog(B) size
rather than the traditional B size, but NIPoPoW still requires the prover to
store the entire blockchain. We extend these techniques further in our trimming
protocol to securely remove blocks and reduce storage.

We now comment on the practical implications of our proposed protocols for
hybrid nodes. There are two main components of a blockchain with signiﬁcant
storage requirements for hybrid nodes. First is the storage required to represent
the PoW of the chain, which is used by the consensus protocol. In traditional
systems, since the entire chain of block-headers must be stored, the storage re-
quirements for this component at the time of writing could be in the order of
100s of megabytes for systems such as Bitcoin and Ethereum. Our trimming
protocols for hybrid nodes can decrease this requirement to the order of 100s of
kilobytes. While 100MB might not seem large, if one wishes to run a number
of blockchains on a single device then the storage requirement can quickly mul-
tiply into the gigabytes range if methods such as trimming are not employed.
Moreover, since hybrid nodes only store polylog(B) number of block headers,
their storage requirement grows slower with time too. The second component
that requires storage is the blockchain state (UTXO or account-based for cryp-
tocurrencies). For instance, the size of Bitcoin’s UTXO set is roughly 4GB [3].
However, some novel stateless blockchain protocols reduce this storage require-
ment to the order of kilobytes by requiring clients to provide payment proofs [1].
In Section 7 and Appendix J, we show that hybrid nodes can employ stateless
blockchain protocols, thus optimizing both their PoW and state storage.

Previous works, speciﬁcally CoinPrune and SecurePrune [28, 33], achieve the
same functionalities as hybrid nodes with lower storage requirements than full
nodes. They achieve this by storing a commitment to the blockchain-state in the
blocks and pruning blocks that are deep in the blockchain. However, their storage
requirement still scales linearly with blockchain length. Moreover, these works
provide a largely qualitative analysis of their respective protocols. In contrast,
we perform a rigorous security analysis and provide proofs that hybrid nodes
are secure.

Concurrent with the initial submission of our work, we were made aware of
an independent work that uses a modiﬁcation of NIPoPoWs to obtain polyloga-
rithmic storage [24]. Although both protocols are similarly motivated, we believe
that our security deﬁnitions and the corresponding analysis are novel and crucial
to this area. Of particular note, we believe that security against a trim-attack
(see Section 5), is crucial for the operation of hybrid nodes. Unlike our protocol,
[24] claim to not require optimism for succinctness (see further in Theorem 3

4

P. Hegde et al.

and Remark 1). However, we note that it doesn’t seem economically viable for an
adversary to expend resources to simply hurt the succinctness of hybrid nodes.

We defer the discussion of other related works which aim to optimize

blockchain storage to Appendix A.

We now summarize our results and outline the organization of the paper.
In section 2, we introduce the basic model and notation. In section 3, we sum-
marize CoinPrune and NIPoPoW, which are building blocks for our protocol.
In section 4, we explain the properties of the hybrid node’s chain and describe
the trimming protocol, though we defer the description of chain selection and
state veriﬁcation protocols to Appendix C due to space constraints. In section 5,
we introduce novel security deﬁnitions for hybrid nodes, including trim-attacked,
congruence, state-attacked, and bootstrap-attacked. In section 6, we show that
hybrid nodes satisfy all the security properties with high probability, and we
also discuss the polylogarithmic storage requirement and the lower bound on
the storage requirement. For brevity, formal proofs for these results are deferred
to Appendices E-H. In section 7, we illustrate that when combined with stateless
blockchain protocols, hybrid nodes are optimized both in terms of cold and hot
storage. And, we examine directions for future work in Section 8.

Our primary contributions are the protocols associated with the hybrid nodes
and the novel security deﬁnitions and their associated theorems. These are in
sections 4, 5 and 6.

2 Model and Notation

In this work, we consider a set of nodes running a PoW blockchain. We model the
system using continuous time, which accurately models systems with high hash-
rates such as Bitcoin and Ethereum[2, 15]. In this section, we restrict the model
description to the essentials required to describe our protocol. Supplemental
model details used for security analysis are deferred to Appendix B.

Several communication models are considered in the literature. The simplest
is the synchronous model where a block broadcast by a node at a certain time
is received by all other nodes immediately [17, 16]. Since time is continuous,
no more than one block is mined at any given time, implying only one block
could be in communication at any given time. More complicated communication
models with communication delays are also considered in the literature [30, 36].
For the sake of simplicity, we consider the synchronous model in this paper and
leave it to future work to transfer our results to more complicated communication
models. Note that because of synchronous communication, all honest nodes have
knowledge of the same set of blocks at any given time.

Basic Blockchain Notation The honest (longest-)chain at time t is repre-
sented by Ct. The number of blocks in Ct is called the chain-length and is denoted
as Bt. When the time t is clear from context, we may drop the subscript and refer
to it as just C. Blocks in C are indexed as an array in a similar convention to the
Python programming language, meaning that C[i] is denoted as block i. Since it

Achieving Almost All Blockchain Functionalities with Polylog. Storage

5

is convenient, we refer to a block by its index i and not its contents. C[0] is called
the genesis block. C[i1 : i2] represents the segment of the chain from block i1 to
block (i2 − 1). If at any time an honest node hears of another chain D which is
longer than Ct, then it adopts D as the honest chain (i.e., Ct+ = D, where t+
indicates the time incrementally after t). The last common block between two
chains C and D is called the latest common ancestor (LCA), and is denoted as
b = LCA(C, D). Speciﬁcally, Ct[: b + 1] = D[: b + 1], and Ct[b + 1 :] ∩ D[b + 1 :] = ∅.
When a new block ¯b is appended to C, we denote the extended chain as C ¯b.

In our model, hybrid nodes do not store the entire chain Ct, but instead store
a trimmed version which contains fewer blocks than Ct. The trimming protocol
and its associated notation is described in Section 4.

Blockchain State When a new transaction is submitted, a node must check if
it is “valid” with respect to the chain Ct. This could be accomplished by pars-
ing through the complete log of transactions in Ct. However, due to the rapidly
increasing size of Ct, it is far more eﬃcient for a node to validate transactions
against a summary of the chain called the state, and denoted as state(Ct). Equiv-
alently, we may refer to the state as state(Bt), where Bt is the length of the chain
Ct. Validating a transaction against Ct is equivalent to validating it with respect
to state(Ct), so using state(Ct) is preferred due to its smaller hot storage require-
ment. After a new block ¯b is added to the chain, the new state is computed as
¯b) = F (state(Ct), ¯b), where F () is a function that applies the transac-
state(Ct
tions in ¯b to state(Ct). When the new block is clear from context, we denote the
function simply as F (state(Ct)), and when the function is applied on n sequential
new blocks, we denote the operation as state(Ct b1b2 . . . bn) = F n(Ct). Two types
of states are popular: 1) UTXO-based State: this stands for unspent transaction
output, and is used by Bitcoin. The UTXO state consists of a list of unspent
coins. A new transaction is valid with respect to the state, if it consumes one or
more of these coins, and creates new coins whose total value is no larger than
the consumed coins; 2) Account Based State: This is used in Ethereum. An
account-based state consists of a vector of key-value mappings, with one map-
ping corresponding to each user. The key establishes the user’s identity, and the
value establishes the balance in the user’s account. A user can issue a transaction
that transfers a part of his account’s balance to another user.

Interlinks In traditional blockchains like Bitcoin, each block contains a link
(using a hash) to the previous block in the chain. To enable hybrid nodes to
store the blockchain in a succinct way, we employ a clever link structure called
the interlink. Interlinks were introduced in [23] and further developed in [25].

In the interlink model, a block contains the following information: 1) trans-
actions in the block; 2) the Merkle root x of all the transactions in the block; 3)
the Merkle root y (state(Bt)) of the corresponding blockchain state; 4) the block
index i; 5) the interlink, which contains hash links to several previous blocks and
is described in detail in the following paragraphs; 6) the random nonce η; and 7)
the block hash id = H(η, x, y, i, interlink), where H() is a hash function. For

6

P. Hegde et al.

Fig. 1. An example of the interlink structure (inspired by Figure 1 of [11]). At the
bottom of each block is its index, and the block’s height signiﬁes its superblock level.
Each block has a link to the closest ancestor at every level, which is shown by the
arrows linking blocks to ancestors. Notice all the blocks are contained in level 0, and
only the genesis block is in level 4.

a block to be valid, id must contain at least T leading 0’s. Equivalently, we say
that id ≤ 2−T . All the information in the block except the list of transactions is
referred to as the block-header. Observe that the id of the block can be veriﬁed
given just the block-header.

To describe the interlink, we ﬁrst need to deﬁne superblocks. A level-µ su-
perblock is a block with id ≤ 2−(T +µ). Since a valid block satisﬁes id ≤ 2−T ,
all valid blocks are level-0 superblocks. The genesis block is deﬁned to be a su-
perblock of every level from 0 to ∞. And, a level-µ superblock is also a level-µ(cid:48)
superblock for all 0 ≤ µ(cid:48) ≤ µ, since 2−(T +µ) ≤ 2−(T +µ(cid:48)).

The interlink data-structure in a block contains a link to the previous
superblock of level µ for every level µ that is in the chain Ct up to that block.
Since the previous block will always be a superblock of level at least 0, the
interlink always contains a link to the previous block (thus, without any further
modiﬁcation, the security properties of the blockchain are unaﬀected). Also, since
the genesis block is of all possible levels, a link to the genesis block is always
included. A pictorial example of this is shown in Figure 1.

Using interlinks, it is possible to “skip” over blocks when traversing the
blockchain. To be more speciﬁc, it is useful to deﬁne notation for “traversing the
blockchain at level-µ”. For any given chain C, the level-µ upchain, denoted C ↑µ,
is the sequence of all level-µ superblocks in C. That is,

C ↑µ(cid:44)

b : b ∈ C, and id(b) ≤ 2−(T +µ)(cid:111)
(cid:110)

.

(1)

Note that although it is convenient to use set-notation to deﬁne it, C ↑µ is a
sequence with the order of its blocks being the same as they are in C. From the
deﬁnition of the interlink, each block in the upchain C ↑µ contains a reference to
the previous block in the upchain. Therefore, it is possible to traverse through
C ↑µ. Additionally, a chain C(cid:48) is called a level-µ superchain if all its blocks are
level-µ superblocks. That is, if the underlying chain of C(cid:48) is C, then C(cid:48) ⊆ C ↑µ.
We use square-brackets to index C ↑µ, similar to a python array. However, at
times it is useful to refer to blocks in C ↑µ according to the block’s index in C.
In this case, we use curly-braces to index C ↑µ. This is best illustrated using an
example. Consider, C = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, and let C ↑µ= {0, 3, 4, 7, 10}.

Achieving Almost All Blockchain Functionalities with Polylog. Storage

7

In this case, C ↑µ [3 :] = {7, 10}, but C ↑µ {3 :} = {3, 4, 7, 10}. As a further illus-
tration of the upchain notation, in the blockchain in Figure 1, C ↑2= {0, 4, 8, 12}.

3 Preliminaries

Before describing our protocol, we summarize CoinPrune [28] and NIPoPoW
[25]. Our protocol builds upon both of these protocols.

CoinPrune In CoinPrune, similar to our model, blocks contain commitments to
the blockchain-state. The protocol selects a pruning point k blocks from the tip of
the chain. All blocks after the pruning point are retained completely, while only
block headers are retained prior to the pruning point. The state of the blockchain
at the pruning point is also stored. Then, the PoW in the chain can be established
since the block headers for the entire chain are preserved. Furthermore, since the
state at the pruning point is preserved and a commitment to it is stored in the
blocks, the state corresponding to each block after the pruning point can be
recovered. Refer to Figure 2 for a visual description.

Fig. 2. An instance of CoinPrune. Complete square-boxes indicate the complete blocks
after the pruning point, and incomplete boxes indicate block-headers of blocks before
the pruning point. The variables yi are the state-commitments of the respective states
stored in the block headers. They are shown separately from the block only for em-
phasis. The state at the pruning point is stored, and its validity is conﬁrmed by the
state-commitments yi’s.

While our method for establishing the state of the blockchain is similar to
CoinPrune, we deviate in the way we establish the PoW of the chain. We note
that although CoinPrune improves storage compared to full nodes, they still
store the entire block-header chain prior to the pruning point. Thus, their stor-
age requirement still scales linearly in the length of the chain, albeit the multi-
plicative constant may be very small. In contrast, we retain only a subset of the
block headers, leading to sublinear storage requirement in the number of blocks
in the blockchain. To accomplish this, we take inspiration from NIPoPoW.

NIPoPoW NIPoPoW is a protocol that is used to provide succinct proofs of
payments to lightweight clients. Payment proofs have two components. First, the
proof needs to establish the amount of PoW in the blockchain, and second, it
needs to contain a proof of inclusion of the payment in the chain. Traditionally,

8

P. Hegde et al.

the PoW of the chain is established by sending the entire chain of block headers
to the lightweight client. NIPoPoWs optimize this step by making the following
observation. Informally, by the property of concentration around the means,
the µ-upchain C ↑µ of an underlying chain C is such that 2µ|C ↑µ| ≈ |C| (as
an illustration, in Figure 1, superblocks of level-2 appear roughly every 22 = 4
blocks). Recall that a level-µ superblock is 2µ times harder to ﬁnd than a regular
block (i.e., a level-0 superblock). Therefore, if 2µ|C ↑µ| ≈ |C|, then it is as hard
for an adversary to create a fork around C ↑µ with level-µ superblocks as it is to
create a fork around C with level-0 superblocks. Therefore, it is suﬃcient to just
provide C ↑µ as a proof of the PoW of the chain. For a large enough level µ, C ↑µ
is much smaller in size than the underlying chain C, thus making NIPoPoWs
much faster than traditional protocols.

Our protocol diﬀers from NIPoPoWs in several ways. First, the goal of our
protocol is to optimize a hybrid node’s storage while retaining almost all of a
full node’s functionalities, while the goal of NIPoPoWs is to provide succinct
payment proofs. Second, NIPoPoWs do not optimize the prover’s storage since
the prover must still store the entire blockchain. Third, NIPoPoWs are one-time
proofs of payment, meaning they need to be generated afresh for every new proof
request, whereas our protocol proceeds in an iterative manner throughout the
blockchain’s execution. In particular, we employ diﬀerent level ranges (elabo-
rated in the next section) in order to optimize storage throughout time, whereas
NIPoPoW only uses a single level range. Fourth, since our end goal is diﬀerent,
our security requirements are diﬀerent from NIPoPoWs. Lastly, we note that
since our security models are diﬀerent, we use vastly diﬀerent parameters in our
protocol compared to NIPoPoW, and also do novel analysis.

4 Trimming Protocol

In this section we describe our protocol to trim the blockchain. Other associated
protocols that compare trimmed-chains to select the main chain, and that verify
the blockchain state are described in Appendix C due to lack of space.

First, we start with an intuitive description of the trimmed chain which is
best understood by referring to the example in Figure 3. Similar to NIPoPoWs,
the high-level idea in our approach is to retain only a subset of (super)blocks
in order to represent the proof of work of the chain. Let the trimmed chain be
denoted by P t (subscript t may be omitted when time is clear from context). P
is a subset of the complete blockchain C, i.e., P ⊆ C. And, it has an associated
number B(cid:48)
t are retained,
including their data and block headers. That is, P{B(cid:48) :} = C[B(cid:48) :]. We refer
to P{B(cid:48) :} as the untrimmed tail. Blocks to the left of B(cid:48) may be trimmed,
meaning P{: B(cid:48)} ⊆ C[: B(cid:48)]. Only the block-headers of the blocks in P{: B(cid:48)}
are retained. The blocks that are not in P{: B(cid:48)} are permanently deleted by
the hybrid node. Here is where we diﬀer from pruning. In pruning, all the block
headers are retained. In trimming, blocks are completely deleted, including their
headers.

t called the trimming point. All blocks to the right of B(cid:48)

Achieving Almost All Blockchain Functionalities with Polylog. Storage

9

Fig. 3. An example of a trimmed chain at an honest node. Notice how it is partitioned
into distinct level ranges, each beginning once its predecessor ends. We show a portion
of the second level range, P{Lf (2) : Ll(2)}. The greyed blocks with dashed outlines
represents blocks that have been trimmed. Like Figure 1, the height of the (super)block
is its highest level. Furthermore, after the trimming point, B(cid:48), is the untrimmed tail
where all the blocks are retained.

The trimmed section of P is further partitioned into level-ranges, each level-
range corresponding to a unique level µ. A level-range is spread contiguously
over a region of the blockchain, and each level range begins at the point its
predecessor ends. We denote the starts and ends of level ranges by level-range
functions Lf : Z+ → Z+ and Ll : Z+ → Z+. We deﬁne Lf (µ) as the index of the
ﬁrst block in level-range µ. Similarly, Ll(µ) is the last block in the level-range µ.
Beyond a certain level µh, called the highest level, the level-range functions are
0: Lf (µ) = Ll(µ) = 0 for µ > µh. Also, below a certain level µ < µl, called the
lowest level, we have Lf (µ) = Ll(µ) = B(cid:48) − 1. Notice then that for µl ≤ µ < µh,
we have Ll(µ + 1) + 1 = Lf (µ). The level ranges are also pictorially shown in
the example in Figure 3.

At level-range µ, we are primarily interested in level-µ superblocks. As ex-
plained with the intuition of NIPoPoW, we need to weigh level-µ superblocks by
2µ. In order to avoid confusion with PoW, which traditionally does not look at
super-levels, we call this notion of weighted PoW simply as the weight at level-µ.
For the level-range µ, we denote the weight-function W (P, µ) as,

W (P, µ) = 2µ|P{Lf (µ) : Ll(µ) + 1} ↑µ|.

Our trimming protocol in Algorithm 1 ensures that a higher level-range pre-
cedes a lower-level range (as illustrated in Figure 3). Therefore, we can compute
the sum of work from the genesis block up to and including level range µ by,
S(P, µ) = (cid:80)

W (P, µ(cid:48)).

Since hybrid nodes do not have access to the underlying chain, S(P, µ) can be
interpreted as their estimate of the PoW up to block Ll(µ). Note that W (P, µ)
and S(P, µ) are functions of the level-range functions as well. However, we as-
sume that the level-range functions are implicitly deﬁned by P in order to keep
the notation minimal.

µ≤µ(cid:48)≤µh

10

P. Hegde et al.

Algorithm 1: Trimming Protocol

input

: P :: My (trimmed) chain
Q :: The trimming interval
µh :: Highest level-range in P
Lf (), Ll() :: Level-Range functions
g(), f (), ∆() :: Protocol parameter-functions
goodδ,g() :: Good-Superchain function (see Appendix C)

1 on event P has grown by Q blocks since the last trimming attempt:
2

B(cid:48) = P[−1] − ∆(P)
for µ from µh + 1 down to 1 do

g ← g(P, µ)
f ← f (P, µ)
if | P{Lf (µ) : B(cid:48)} ↑µ | ≥ f and goodδ,g(P{Lf (µ) : B(cid:48)} ↑µ, µ) then

P, Lf , Ll, success ←trim(P, Lf , Ll, B(cid:48), µ, g, f )
if success=1 then

break

3

4

5

6

7

8

9

10

return

11
12 func trim(D, Lf , Ll, B(cid:48), µ, g, f ):
E ← D{Lf (µ) : B(cid:48)} ↑µ
13
A ← E[−f ]

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

for µ(cid:48) from µ − 1 to 0 do
α ← D{A : B(cid:48)} ↑µ(cid:48)
E ← E ∪α

if |α| ≥ f and goodδ,g(α, µ(cid:48)) then

A ← α[−f ]

if |α| ≥ f and goodδ,g(α, µ(cid:48)) then

Lf (µ(cid:48)), Ll(µ(cid:48)) ← B(cid:48) − 1, for all µ < µ(cid:48)
Ll(µ) ← B(cid:48) − 1
D ← D{: Lf (µ)} ∪ E ∪ D{B(cid:48) :}
return D, Lf , Ll, 1

else

return D, Lf , Ll, 0

The trimming procedure is detailed in Algorithm 1. We brieﬂy describe it
here. Trimming is attempted every time the chain grows by Q blocks (line 1).
We call Q the trimming interval. The trimming point is set by the required
chain-tail length (line 2). Given that µh is the highest level-range in the current
trimmed chain, we attempt to trim it further to level µh + 1. If trimming to
that level is not possible, we try to do it to one level lower and so on (line 3).
Trimming to a level µ can be attempted if the speciﬁed range of blocks contains
enough level-µ superblocks, and if the corresponding µ-upchain is good (line 6).

Achieving Almost All Blockchain Functionalities with Polylog. Storage

11

Roughly, a µ-upchain C ↑µ is good if its weight represents the weight of the
other level upchains ( | C ↑µ | ≈ 2(µ−µ(cid:48))| C ↑µ(cid:48)
|, µ(cid:48) < µ). For the full deﬁnition
of good-superchain, see Appendix C. Given condition on line 6 is satisﬁed, the
trim function is called for level µ (line 7).

The trim function is very similar to the goodness-aware Prove algorithm of
the NIPoPoW protocol [25, Algorithm 8]. In the trim function, the µ-upchain is
obtained ﬁrst (line 13). Next, the (µ − 1)-level upchain under the last f blocks
of the µ-level upchain is also added (lines 17 and 18). If the (µ − 1)-level upchain
is good, then the (µ − 2)-level upchain under its last f blocks is added (lines
20 and 21). Otherwise, the (µ − 2)-level upchain under the last f blocks of the
µ-upchain are added. This procedure continues until level 0.

At the end, the trim function checks if the trimming was a “success” by
checking if level 0 of the trimmed chain is good. The trim being a success means
that it is at least as hard for an adversary to create a longer fork around the
trimmed chain, as it would be to do so around the complete chain. Intuitively, this
is because the necessary levels of the upchains in this range are good, meaning
that they represent the PoW of their corresponding downchains.

In case the trim is a success, the trim function along with the new level
range functions are returned (lines 23 to 27) indicating that the trim can be
used. Otherwise, the old trimmed chain and level range functions are returned
(lines 28 and 29).

Chain Selection Hybrid nodes need to have a protocol, Compare(C(1), C(2)),
to chose the main chain given two conﬂicting chains, C(1) and C(2). Full nodes
(that store the entire blockchain) simply choose the longer of the two chains as
the main chain. The chain selection protocol for hybrid nodes is a little more
complicated since they do not store the entire chain. At a high level, they use
the sum of the cumulative weight, S(P, 0), of the trimmed portion of a chain
and the length of untrimmed section of the chain as a proxy for the chain length.
The complete algorithm involves some more details which are described in full
in Appendix C.2.

State Veriﬁcation Similar to CoinPrune [28], a short commitment to the state
at the block is stored in every block. Therefore, a hybrid node can verify the
correctness of the blockchain’s state by comparing it to the corresponding state
commitment. The protocol is called state − verify and is presented with more
details in Appendix C.3.

Hybrid Node’s Functionalities Here, we describe how a hybrid-node employ-
ing the trimming algorithm has the functionalities claimed in Section 1. Since a
hybrid node stores the state of the blockchain at its tip, it can perform trans-
action validation, block validation and state validation. Using the Compare(·, ·)
protocol from Appendix C.2, a hybrid node can select the main chain given
competing chains. As a consequence, the node can perform mining as well.

12

P. Hegde et al.

A new node joining the system can choose the main chain using the

Compare(·, ·) protocol, and verify the state using the state-verify protocol from
Appendix C.3. Thus, hybrid nodes can bootstrap other hybrid nodes into the
system.

The hybrid node veriﬁes payment proofs as follows. In traditional systems like
Bitcoin, the prover provides the chain of block-headers in order to establish the
PoW, and then provides a short proof for the transaction’s inclusion (inclusion-
proof) in the chain. In NIPoPoWs the prover provides a superchain (which is
logarithmic in the size of the underlying chain) in order to establish the PoW.
In either case, the hybrid node can use the Compare(·, ·) protocol to compare
the given chain (superchain) to its own trimmed chain. If the two chains only
diﬀer near the tail and the inclusion-proof is consistent with the provided chain,
then the hybrid node approves the prover’s payment proof. Otherwise, it returns
false.

5 Security Deﬁnitions

Security from Trim Attack Consider the dangerous attack scenario de-
picted in Figure 4, where the adversary provides a trimmed-chain P (2) which
is “longer” than the honest chain P (1) (i.e. Compare(P (1), P (2)) = P (2)) and
the LCA between the two chains precedes the honest chain’s trimming point:
b = LCA(P (1), P (2)) < B(cid:48)(1). Denote b1 to be the (super)block after b in P (2).
The honest node cannot verify the state transition from b to b1. This is because
the honest node only has access to block headers and not the full state, meaning
they can only verify the validity of the block headers, but not of the state tran-
sition between the blocks. Moreover, even if the honest node had access to the
state at those blocks, there may be a number of blocks between b and b1 that
were skipped during the trimming.

Fig. 4. A trim-attack. The honest chain is shown in black, and adversary’s chain in red.
Complete square-boxes indicate the complete blocks beyond the trimming point, and
incomplete boxes indicate block-headers of blocks before the trimming point. Curved
arrows indicate that the corresponding blocks may not be subsequent blocks.

Therefore, if at any time the adversary is able to create a fork as in Figure
4, they could arbitrarily alter the state of the chain to their advantage. For
instance, the adversary could transfer all of the chain’s cryptocurrency into their

Achieving Almost All Blockchain Functionalities with Polylog. Storage

13

own accounts. One approach to circumventing this problem is to have the hybrid
node re-download the blockchain from a full node in case it encounters a fork
preceding its trimming point. However, in that case the security of the system
would again rely on the small number of full nodes. We require that hybrid nodes
can work independently from full nodes to keep the system as decentralized
as possible. To accomplish this, we ensure that there exists no time when an
adversary is able to create a fork from beyond a hybrid node’s trimming point.

Deﬁnition 1 (Attack on the trimmed Chain). Let ω be the ﬁxed random-
ness3. Let P (1)
t,ω be the honest trimmed chain at some honest node at time t.
Let P (2)
t,ω be the adversary’s trimmed chain. Let B(cid:48)(P (1)) and B(cid:48)(P (2)) be their
respective trimming points. Let bt,ω be the LCA block between them: bt,ω =
LCA(P (1)
t,ω). Then, we say that the system is trim-attacked if there exists
a time t such that the adversarial trimmed chain is declared to be longer than
the honest trimmed chain and the LCA block is before the honest node’s trimming
point. That is,

t,ω, P (2)

trim-attacked = {ω :∃t s.t. bt,ω < B(cid:48)(P (1)

t,ω), and Compare(P (1)

t,ω, P (2)

t,ω) = P (2)

t,ω}.

Congruence Since hybrid nodes only have access to trimmed chains P, we need
that the selection of the main trimmed-chain made according to Compare(·, ·) is in
agreement with the underlying complete chains. We formalize this by a property
called congruence.

Deﬁnition 2 (Congruence). Given any two (complete) chains C(1) and C(2)
with corresponding trimmed chains P (1) and P (2), they are said to be congruent
with each other if, |C(1)| > |C(2)| =⇒ Compare

P (1), P (2)(cid:17)

= P (1) .

(cid:16)

State Security Hybrid nodes do not have access to transaction history pre-
ceding their trimming point. Instead, they rely on the state at the trimming
point, state(B(cid:48)
t), to compute state at the tip of the chain. State is veriﬁed using
state-verify (Algorithm 3). Firstly, if the adversary launches a trimming attack
(Deﬁnition 1), then they could change the state of the blockchain arbitrarily.
Additionally, the state of the hybrid node is also attacked if at any point the
adversary can create a diﬀerent state, state(cid:48), that also passes through state-verify.

Deﬁnition 3 (Attack on the State). Let ω be the ﬁxed randomness. At some
time t, let the trimming point of an honest chain P (1)
t,ω, and let its
associated state be state(1)(B(cid:48)(1)
t,ω). Let the trimming point of the adversary’s chain
P (2)
t,ω The state of the honest node
is said to be attacked, denoted by state-attacked , if there is either a trim-attack

t,ω, and let its claimed state be state(2)

t,ω be B(cid:48)(1)

t,ω be B(cid:48)(2)

3 randomness is w.r.t., the stochastic model described in Appendix B

14

P. Hegde et al.

or there exists a time t such that, state(2)
against the chain. Denoting, P t,ω = Compare(P (1)

t,ω (cid:54)= state(1)(B(cid:48)
t,ω, P (2)

t,ω), we deﬁne,

t,ω), such that it veriﬁes

state-attacked = {ω : ω ∈trim-attacked}

(cid:91)

{ω : ∃t such that state-verify(state(2)

t,ω, P t,ω) = 1}.

Bootstrapping Security When a new (honest) node joins the system, it down-
loads (possibly trimmed) copies of the blockchain from a number of other hybrid
or full nodes. It then chooses the main chain using the Compare(·, ·) protocol and
then downloads and veriﬁes the state using the state-verify protocol. In order to
show that it adopts the honest trimmed chain and the honest state, we deﬁne
bootstrapping security below.

Deﬁnition 4 (Bootstrapping Security). A joining node is said to be securely
bootstrapped into the system if, at the point of it joining, it adopts a trimmed
chain that is not trim-attacked with respect to the system’s honest chain, and
it adopts a state which is not state-attacked with respect to the system’s honest
state. Otherwise, the node is said to be bootstrap-attacked.

In our system model, we assume that the mining rate of the honest parties
and the adversary remains constant. This might seem to be counter-factual to
Deﬁnition 4 because it assumes that nodes can join the system. We remark that
we make the constant mining rate assumption to make the rigorous security
analysis tractable. Practically, we conjecture that if the rate of nodes joining
and leaving the system is nearly equal and small enough, then the constant
mining rate assumption is a good model for the system.

6 Security Results for Hybrid Nodes

The protocol has security parameters k, k(cid:48) ∈ N, a, c ∈ R+, and δ ∈ (0, 1).
Referring to the protocol parameter-functions from Alogrithm 1 are deﬁned
as: ∆(P) = k(cid:48) + a log (S(P, 0) + |P{B(cid:48) :}|), g(P, µ) = k + a log S(P, µ), and
f (P, µ) = c · g(P, µ). We simply state the results here without proof. The proofs
can be found in Appendix E. All the results are with respect to the stochastic
model deﬁned in Appendix B.

First, we show if the honest nodes have the majority of mining power, we can
choose security parameters such that our protocol is secure against a trim-attack.

Theorem 1 (Security of the trimmed Chain). Assume an honest major-
ity, λh > λa, where λh and λa are the mining rates of the honest and adver-
sarial nodes respectively. Let the trimming algorithm (Algorithm 1) parameters
k, k(cid:48), c, a, δ satisfy,

k(cid:48) = k − a log (cid:0)((1 + δ2) + δ)/δ(cid:1) ,

1 < (1 − δ)5 λh
λa

c − 1
c

,

a ≥

8
δ2 ,

1 < (1 − δ)3 λh
λa

c(cid:48) − 1
c(cid:48)

c − 1 − c(cid:48)
c

,

Achieving Almost All Blockchain Functionalities with Polylog. Storage

15

where 2 < c(cid:48) < c is some constant. Then4, P(trim-attacked) = negl(k).

As a corollary to the above theorem, we can conclude the chain-selection made
by hybrid-nodes is consistent with underlying chain lengths.

Corollary 1. The congruence property holds except with probability negl(k).

Theorem 2 (State Security). Assuming honest majority, λh > λa, and that
the security parameters are as in Theorem 1, then, P(state-attacked) = negl(k).

Corollary 2 (Bootstrapping Security). Assume the arrival process of new
nodes is independent of the randomness of the blockchain system. If we further
assume that a new node contacts at least one honest node and that there is honest
mining majority, then bootstrap-attacked occurs with probability negl(k).

In the next theorem, we provide an upper bound on the cold-storage required
to store the trimmed chain. This theorem relies on the assumption that a par-
ticular kind of adversary is absent. We further comment on this in Remark 1.
Additionally, we also note that the following theorem doesn’t account for the
storage required to store the state at the trimming point. We discuss optimizing
the storage for the state using stateless blockchains in Section 7.

Theorem 3 (Optimistic Succinctness). Assuming that all the nodes are
honest, the cold-storage requirements for a hybrid node to store the trimmed-
chain P is O(log4 B) with high probability in k. Here, B is the length of the
underlying chain C.

Remark 1 (Need of Optimism for Succinctness). Since our protocol is an ex-
tension of NIPoPoWs, we need to rely on optimism for succinctness as well. In
particular, note that when trimming we need to ensure that the level ranges are
“good”. We have also shown that under honest behaviour, the sizes of the dif-
ferent upchains concentrate around the mean, thus leading to good level-ranges
with high probability. However, an adversary with a small mining power could
launch an attack which hampers the concentrations around the means and thus
makes good-superchains more unlikely. This attack is formally described in [25].
We note that, just like in NIPoPoWs, the adversary can only hurt the succinct-
ness of our model, but not its security. Although the economics of launching an
attack on the hybrid node’s succinctness is yet to be studied formally, we venture
to guess that such an attack wouldn’t be economically viable to the adversary.

Clearly, the size of the untrimmed tail is a lower bound on the cold-storage
required. In the next theorem we prove that the length of the chain tail has to
be at least log B in order to protect a hybrid node against a trim-attack. This
implies that our protocol is near-optimal in terms of cold storage, since it only
requires polylog(B) storage.

Theorem 4 (Vulnerability of Short Tails). Let the blockchain length be Bt
at time t, and the trimming point be B(cid:48)
t = o(log Bt)) >
(cid:15), for some (cid:15) > 0, then there exists an adversary with small mining power,
λa < λh, such that P(trim-attacked) = 1.
4 In our work, negl(k) = e−Ω(k) < 1

t. If at all times t, P (Bt − B(cid:48)

poly(k) .

16

P. Hegde et al.

7 Optimizing State Storage with Stateless Blockchains

Our trimming protocol optimizes the amount of cold storage required to repre-
sent the PoW in the blockchain. In this section, we outline how our work can
interface with methods optimizing the storage of the state. Furthermore, a de-
tailed description is found in App. J. In hybrid nodes, states need to be stored
in cold and hot storage. Along with the length of the blockchain, the size of
the blockchain-state is rapidly increasing with time. For instance, at the time of
writing Bitcoin’s UTXO state is almost 4GB in size, which motivates lessening
high storage and veriﬁcation time by extending our work to optimize both the
state’s cold-storage at the trimming point, and its hot-storage at the chain tip.
We described that storing state-commitments in the blocks enables one to
securely establish the state of a trimmed chain, by use of the state-verify protocol
described in Algorithm 3. In a diﬀerent line of work, called stateless blockchains,
state-commitments are used to reduce the amount of hot-storage required for
transaction validation, thus speeding up validation. We claim that when hybrid
nodes are used in stateless-blockchains, then state commitments can serve a dual
purpose: 1) they can be used to establish the state of the trimmed chain; 2) and,
they can be used to perform stateless transaction validation.

Stateless validation, ﬁrst proposed by Todd [38], is a scheme where nodes val-
idating transactions store a short cryptographic state-commitment rather than
the entire state. A client then provides a membership proof that the node can
verify against the commitment. Recently, several constructions have been devel-
oped to perform stateless validation in both the UTXO and account-based state
models using various cryptographic primitives [10, 13, 4, 39, 34, 1, 19].

Stateless blockchains optimize hot-storage by obviating the need to store the
state at the tip of the chain in the RAM. At this point, the state at the trimming
point is still stored in the cold storage. We can use this to provide an interface
from trimming to stateless blockchains: First, if the proof for some client becomes
outdated past the trimming point because it was oﬄine for a long time, then
the client can recompute its latest proof by querying a hybrid node for state(B(cid:48)
t)
and the untrimmed chain tail. Second, if a fork in the chain makes the proofs
of several clients invalid, they can all recompute their proofs by contacting the
hybrid node similarly. In App. J, we describe a way to optimize the cold-storage
of the state at the trimming point as well.

8 Future Directions

In this paper, we presented hybrid nodes which use trimming to optimize the
cold-storage required to represent the PoW in the chain. When used in conjunc-
tion with stateless blockchains, we illustrated that hybrid nodes are optimized
both in terms of cold and hot storage. In this section, we lay out some directions
for future work.

We assume that there is honest majority, λh > λa, throughout the execution
of the blockchain protocol. Given that we use novel security models, it will be in-
teresting to study if it is economically viable for an adversary to acquire massive

Achieving Almost All Blockchain Functionalities with Polylog. Storage

17

resources in order to attain a majority mining power temporarily, and launch an
attack such as a trim − attack. Similarly, it will be interesting to study the eco-
nomics of an adversary who simply attempts to hurt the succinctness of hybrid
nodes. In hurting the succinctness, fewer nodes would join as hybrid nodes. Thus,
an adversary could attempt to take advantage of the reduced decentralization.
We have proved in Theorem 4, that our protocol is near-optimal in terms
of the storage it requires to represent a blockchain’s PoW if it is to be secure
against a trim − attack. However, it is at the moment unclear if further storage
optimization in terms of storing the state is possible for a node that needs to
have all the functionalities of a hybrid node (without assuming properties on the
clients as we do in Section 7).

In our analysis, we assume that the block id’s have a constant diﬃculty target
throughout the blockchain’s execution. It may be useful to relax this assumption
in order to make our model closer to practical systems.

Finally, our work in this paper has mainly focused on theoretical analysis.
An interesting line of work would be to implement the protocol and study the
practical gains of using hybrid nodes.

References

[1] Agrawal, S. and Raghuraman, S. “KVaC: Key-Value Commitments for
Blockchains and Beyond”. In: International Conference on the Theory
and Application of Cryptology and Information Security. Springer. 2020,
pp. 839–869.

[2] Bitcoin Hash Rate. Available at https://www.coinwarz.com/mining/

bitcoin/hashrate-chart (2021/04/29).

[3] Bitcoin UTXO size. Available at https://tinyurl.com/cr7w2ep5 (2021/09/13).
[4] Boneh, D., B¨unz, B., and Fisch, B. “Batching techniques for accumulators
with applications to iops and stateless blockchains”. In: Annual Interna-
tional Cryptology Conference. Springer. 2019, pp. 561–586.

[5] Bonneau, J. et al. “Coda: Decentralized Cryptocurrency at Scale.” In:

IACR Cryptol. ePrint Arch. 2020 (2020), p. 352.

[6] B¨unz, B. et al. “Flyclient: Super-light clients for cryptocurrencies”. In:
2020 IEEE Symposium on Security and Privacy (SP). IEEE. 2020, pp. 928–
946.

[7] Canonne, C. A Short Note on Poisson Tail Bounds. Available at http://

www.cs.columbia.edu/~ccanonne/files/misc/2017-poissonconcentration.
pdf (2021/05/18).

[8] Catalano, D. and Fiore, D. “Vector commitments and their applications”.
In: International Workshop on Public Key Cryptography. Springer. 2013,
pp. 55–72.

[9] Chen, W. et al. Reducing Participation Costs via Incremental Veriﬁca-
tion for Ledger Systems. Tech. rep. Cryptology ePrint Archive, Report
2020/1522, 2020.

18

P. Hegde et al.

[10] Chepurnoy, A., Papamanthou, C., and Zhang, Y. “Edrax: A Cryptocur-
rency with Stateless Transaction Validation.” In: IACR Cryptol. ePrint
Arch. 2018 (2018), p. 968.

[11] Daveas, S. et al. “A Gas-Eﬃcient Superlight Bitcoin Client in Solidity”. In:
Proceedings of the 2nd ACM Conference on Advances in Financial Tech-
nologies. AFT ’20. New York, NY, USA: Association for Computing Ma-
chinery, 2020, pp. 132–144. isbn: 9781450381390. doi: 10.1145/3419614.
3423255. url: https://doi.org/10.1145/3419614.3423255.

[12] Dembo, A. et al. “Everything is a race and nakamoto always wins”. In:
Proceedings of the 2020 ACM SIGSAC Conference on Computer and Com-
munications Security. 2020, pp. 859–878.

[13] Dryja, T. “Utreexo: A dynamic hash-based accumulator optimized for the
Bitcoin UTXO set.” In: IACR Cryptol. ePrint Arch. 2019 (2019), p. 611.
[14] Dubhashi, D. and Panconesi, A. “Concentration of measure for the anal-
ysis of randomised algorithms”. In: Draft Manuscript, http://www. brics.
dk/ale/papers. html (1998).

[15] Ethereum Hash Rate. Available at https://www.coinwarz.com/mining/

ethereum/hashrate-chart (2021/04/29).

[16] Eyal, I. and Sirer, E. G. “Majority is not enough: Bitcoin mining is vul-
nerable”. In: International conference on ﬁnancial cryptography and data
security. Springer. 2014, pp. 436–454.

[17] Garay, J., Kiayias, A., and Leonardos, N. “The bitcoin backbone protocol:
Analysis and applications”. In: Annual international conference on the the-
ory and applications of cryptographic techniques. Springer. 2015, pp. 281–
310.

[18] Gaˇzi, P., Kiayias, A., and Russell, A. “Tight consistency bounds for bit-
coin”. In: Proceedings of the 2020 ACM SIGSAC Conference on Computer
and Communications Security. 2020, pp. 819–838.

[19] Gorbunov, S. et al. “Pointproofs: aggregating proofs for multiple vector
commitments”. In: Proceedings of the 2020 ACM SIGSAC Conference on
Computer and Communications Security. 2020, pp. 2007–2023.

[20] Kadhe, S., Chung, J., and Ramchandran, K. “SeF: A Secure Fountain Ar-

chitecture for Slashing Storage Costs in Blockchains”. In: CoRR abs/1906.12140
(2019). arXiv: 1906.12140. url: http://arxiv.org/abs/1906.12140.
[21] Karantias, K., Kiayias, A., and Zindros, D. “Compact storage of superblocks
for nipopow applications”. In: Mathematical Research for Blockchain Econ-
omy. Springer, 2020, pp. 77–91.

[22] Kattis, A. and Bonneau, J. “Proof of Necessary Work: Succinct State Ver-
iﬁcation with Fairness Guarantees.” In: IACR Cryptol. ePrint Arch. 2020
(2020), p. 190.

[23] Kiayias, A., Lamprou, N., and Stouka, A.-P. “Proofs of proofs of work with
sublinear complexity”. In: International Conference on Financial Cryptog-
raphy and Data Security. Springer. 2016, pp. 61–78.

Achieving Almost All Blockchain Functionalities with Polylog. Storage

19

[24] Kiayias, A., Leonardos, N., and Zindros, D. Mining in Logarithmic Space.
Cryptology ePrint Archive, Report 2021/623. https://ia.cr/2021/623.
2021.

[25] Kiayias, A., Miller, A., and Zindros, D. “Non-interactive proofs of proof-of-
work”. In: International Conference on Financial Cryptography and Data
Security. Springer. 2020, pp. 505–522.

[26] Kiayias, A., Polydouri, A., and Zindros, D. “The Velvet Path to Superlight

Blockchain Clients”. In: (2020).

[27] Li, S. et al. “PolyShard: Coded Sharding Achieves Linearly Scaling Eﬃ-
ciency and Security Simultaneously”. In: Trans. Info. For. Sec. 16 (Jan.
2021), pp. 249–261. issn: 1556-6013. doi: 10.1109/TIFS.2020.3009610.
url: https://doi.org/10.1109/TIFS.2020.3009610.

[28] Matzutt, R. et al. “How to Securely Prune Bitcoin’s Blockchain”. In: 2020
IFIP Networking Conference (Networking). IEEE. 2020, pp. 298–306.
[29] Nodes and Clients. Available at https://ethereum.org/en/developers/

docs/nodes-and-clients/ (2021/05/20).

[30] Pass, R., Seeman, L., and Shelat, A. “Analysis of the blockchain proto-
col in asynchronous networks”. In: Annual International Conference on
the Theory and Applications of Cryptographic Techniques. Springer. 2017,
pp. 643–673.

[31] Perard, D. et al. “Erasure Code-Based Low Storage Blockchain Node”.
In: 2018 IEEE International Conference on Internet of Things (iThings)
and IEEE Green Computing and Communications (GreenCom) and IEEE
Cyber, Physical and Social Computing (CPSCom) and IEEE Smart Data
(SmartData). 2018, pp. 1622–1627. doi: 10 . 1109 / Cybermatics _ 2018 .
2018.00271.

[32] Raman, R. K. and Varshney, L. R. “Dynamic Distributed Storage for Scal-
ing Blockchains”. In: CoRR abs/1711.07617 (2017). arXiv: 1711.07617.
url: http://arxiv.org/abs/1711.07617.

[33] Reddy, B. S. “securePrune: Secure block pruning in UTXO based blockchains

using Accumulators”. In: 2021 International Conference on COMmunica-
tion Systems & NETworkS (COMSNETS). IEEE. 2021, pp. 174–178.
[34] Reyzin, L. et al. “Improving authenticated dynamic dictionaries, with ap-
plications to cryptocurrencies”. In: International Conference on Financial
Cryptography and Data Security. Springer. 2017, pp. 376–392.

[35] Running a Full Node. Available at https://bitcoin.org/en/full-node

(2021/05/20).

[36] Sankagiri, S., Gandlur, S., and Hajek, B. “The Longest-Chain Protocol
Under Random Delays”. In: arXiv preprint arXiv:2102.00973 (2021).
[37] Sompolinsky, Y. and Zohar, A. “Bitcoin’s security model revisited”. In:

arXiv preprint arXiv:1605.09193 (2016).

[38] Todd, P. Making UTXO Set Growth Irrelevant With Low-Latency De-
layed TXO Commitments. Available at https://petertodd.org/2016/
delayed-txo-commitments (2021/05/24).

20

P. Hegde et al.

[39] Tomescu, A. et al. “Aggregatable subvector commitments for stateless
cryptocurrencies”. In: International Conference on Security and Cryptog-
raphy for Networks. Springer. 2020, pp. 45–64.

[40] Valiant, P. “Incrementally veriﬁable computation or proofs of knowledge

imply time/space eﬃciency”. In: Theory of Cryptography Conference. Springer.
2008, pp. 1–18.

Achieving Almost All Blockchain Functionalities with Polylog. Storage

21

A Other Related Works

Coding Based Storage Reduction Several recent works have employed erasure-
codes to reduce cold storage costs in blockchains [31, 27, 20, 32]. The core idea
in these works is that each node stores a coded version of a random subset of the
blockchain. A new joining node can then download the coded fragments from
several nodes and reconstruct the entire blockchain. Although this does lead to
a signiﬁcant reduction in storage requirements, the storage in these methods has
an information theoretic lower bound of Ω(B/N ), where B is the length of the
blockchain and N is the number of nodes [27]. In our proposed method, the cold
storage cost scales poly-logarithmically in the length of the blockchain.

Incrementally Veriﬁable Computation Incrementally veriﬁable computation (IVC)
is an orthogonal approach, initially proposed for general settings by Valiant [40].
IVC’s provide a succinct argument of knowledge that some state is correctly
computed from the initial state of computation (and all preceding states of
computation) by performing a recursive composition of state transitions. In the
context of blockchains, [22, 5, 9] employ IVC to reduce state veriﬁcation time.
For the sake of comparison, we note that these methods are based on generic
techniques, like applying a Succinct Non-interactive ARgument of Knowledge
(SNARK) on a suitable compliance predicate and recursively composing such
SNARKs, which result in concretely high overhead costs for the prover. Further-
more, in [22], which is most directly related to our work amongst the three, the
authors acknowledge that their approach does not lessen storage requirements
of mining nodes. In contrast, the hybrid nodes which have mining capability and
more.

Lightweight Clients with Sublinear Complexity Recall lightweight clients only
seek to verify payment proofs. Apart from NIPoPoW, another popular method
that has sublinear complexity for lightweight clients is FlyClient [6]. It uses
probabilistic block sampling and a novel commitment scheme called merkle-
mountain-ranges. FlyClient is more versatile that NIPoPoW’s in that it doesn’t
require optimism for succinctness, and it allows for varying block diﬃculties.
Unfortunately, at the moment, we don’t believe the FlyClient protocol can be
used for hybrid nodes. In addition to theoretical works, there have been recent
works that have also studied practical aspects of NIPoPoW and FlyClient [21,
11, 26].

B Additional Model Details

B.1 Communication Model

Several communication models are considered in the literature. The simplest is
the synchronous model where a block broadcast by a node at a certain time is
received by all other nodes immediately [17, 16]. Since time is continuous, no
more than one block is mined at any given time, implying only one block could be

22

P. Hegde et al.

in communication at any given time. More complicated communication models
with communication delays are also considered in the literature [30, 36]. For the
sake of simplicity, we consider the synchronous model in this paper and leave
it to future work to transfer our results to more complicated communication
models.

B.2 Additional Notation

We deﬁne the notion of a downchain slightly diﬀerent from [23]. Let C(cid:48) ⊆ C ↑µ
be a level-µ superchain. Let C(cid:48)[0] = C ↑µ [j]. Then, the corresponding downchain
is deﬁned as,

C(cid:48) ↓(cid:44)

(cid:40)

C[C ↑µ [j − 1] + 1 : C(cid:48)[−1]],
C[: C(cid:48)[−1]],

if j > 0,
if j = 0.

(2)

B.3 Stochastic Model for the Blockchain.

In order to study the behavior of the blockchain, we consider a stochastic model
for the blockchain which has been used previously in the literature to study
blockchain security [12, 18, 37]. The stochastic model allows us to abstract away
the cryptographic details of PoW mining and focus speciﬁcally on the dynamics
of the blockchain growth. In particular, we model PoW mining as calls to an
ideal random functionality. At each query, independent of everything else, the
ideal functionality returns “success” with a small probability p and “failure”
otherwise. After describing our protocol and its analysis, we interpret our results
under popular cryptographic models such as the model used by Pass., et al [30]
and the Bitcoin Backbone Model [23] in Section I.

Since we use a continuous time model, we represent mining as a Poisson
process as has been used in previous works [18, 12]. Let Ω be the sample-space,
and let ω ∈ Ω denote an outcome (also called ﬁxed randomness). Let the overall
mining process of honest nodes be a Poisson process of rate λh and let the
adversary’s mining be a Poisson process of rate λa. The honest and adversarial
processes are independent of each other. Honest blocks add their mined blocks
to the tip of their longest chains and immediately broadcast the block. However,
the adversary could add their mined block at any point on the chain. Moreover,
the adversary may choose to keep their mined blocks secret and broadcast them
at any future time of their choice. Once a block is broadcast, all the honest nodes
receive it immediately. Honest nodes are said to have a majority if λh > λa.

Observe that a level-µ superblock is 2µ times harder to ﬁnd than a regular
block. In other words, a regular block is a level-µ superblock with probability
2−µ. Therefore, the arrival process for honest (adversarial) level-µ superblocks
is a Poisson process of rate λh/2µ
( λa/2µ). Here as well, the honest and ad-
versarial arrival processes are independent of each other. However, we note that
the arrival processes for honest (adversarial) level-µ1 and level-µ2 superblocks
are not independent even if µ1 (cid:54)= µ2. This is because a level-µ1 superblock is
also a level-µ2 superblock if µ1 ≥ µ2.

Achieving Almost All Blockchain Functionalities with Polylog. Storage

23

Next, we also capture the state-commitment process using the ideal random
functionality. Recall that we include the Merkle-root y(state) of the state at that
point in the block header. An adversary could attempt to produce a malicious
state, state(cid:48) (cid:54)= state, which also produces the same Merkle-root y(state). During
this attempt, the adversary would query the tuple (state(cid:48), y(state)) to the random
functionality and receive “success” with a very small probability q and “failure”
otherwise, independently of everything else. If the adversary receives a success,
we say state(cid:48) ≡ state. Here, q can be assumed to be very small compared to
the block success probability p. This is because a block requires only the ﬁrst T
bits of the hash-string to be 0, whereas in the case of the malicious state, the
entire hash-string has to match the original commitment y. In other words, the
adversary must ﬁnd a collision on the hash function used in the Merkle tree,
which is assumed to occur only with negligible probability with respect to p.
Assume that the adversary tries to ﬁnd a malicious state at the tip of the chain
at some time t. By time s ≥ t, let Nt(s) denote the number of subsequent blocks’
states for which the adversary’s malicious state sequence is equivalent to, i.e.,

F n(state(cid:48)(Ct)) ≡ F n(state(Ct))

, for all 0 ≤ n < Nt(s).

Then, Nt(s) is a Poisson process of rate λs, where λs << λa because q << p.

C Our Protocols: Further Details

The notion of a superchain’s weight being approximately equal to the PoW of
the corresponding downchain was formalized as superquality in [25]. Adding to
this idea, we deﬁne a notion of a dominant superchain below.

Good Superchain First, we require that every suﬃciently large suﬃx of the
upchain weighs at least (1 − δ) times the amount of PoW of its corresponding
downchain.

Deﬁnition 5 (Superquality). Let C be a blockchain, and C ↑µ be its level-µ
upchain. C ↑µ is said to have (δ, g) superquality, for δ > 0 and g ∈ N, if for all
g(cid:48) ≥ g, the following is true:

|C ↑µ [−g(cid:48) :]| ≥ (1 − δ)2−µ|C ↑µ [−g(cid:48) :] ↓|.

Next, we deﬁne a dominant superchain.

Deﬁnition 6 (Dominant Superchain). Consider a
µ-superchain C(cid:48) of an underlying chain, C = C(cid:48) ↓, and parameter g ∈ N. C(cid:48) is
said to be a dominant superchain with parameter g if the following is true. Let

24

P. Hegde et al.

P (cid:48) ⊆ C be any trimmed chain with associated level range functions L(cid:48)
Let, µ1 ≤ µ(cid:48) ≤ µ, and L(cid:48)

f (µ(cid:48)) ≤ l ≤ L(cid:48)

l(µ(cid:48)). Then,

f and L(cid:48)
l.

2µ1 |P (cid:48){l :L(cid:48)

l(µ(cid:48)) + 1} ↑µ1 |
(cid:88)
2µ(cid:48)(cid:48)
|P (cid:48){L(cid:48)

+

f (µ(cid:48)(cid:48)) : L(cid:48)

l(µ(cid:48)(cid:48)) + 1] ↑µ(cid:48)(cid:48)

| ≥ 2µg,

(3)

µ(cid:48)(cid:48)<µ(cid:48)

implies that,

|P (cid:48) ↑µ| ≥ 1.

As intuition, ﬁrst note that C(cid:48) and P (cid:48) have the same underlying downchain.
We are interested in the weight of P (cid:48) to the right of a block l in level range µ(cid:48).
For reasons that will be clear from our trimming and chain-compare protocols
(Algorithms 1 and 2), we allow weighing the ﬁrst level range µ(cid:48) using a diﬀerent
level µ1 ≤ µ(cid:48). Then, the dominant-superchain property says that if P (cid:48) has a
weight that is large enough, then it contains at least 1 level-µ superblock.

A superchain is a good-superchain if it has superchain quality and is a dom-

inant superchain.

Deﬁnition 7 (Good Superchain). A µ-superchain C(cid:48) of an underlying chain
C = C(cid:48) ↓, is a good-superchain, denoted goodδ,g(C(cid:48), µ), if it satisﬁes superquality
with parameters (δ, g) and is a dominant superchain with parameter g.

Intuitively, if all the respective quantities above are equal to their mean
values, then C ↑µ is a good superchain. As long as an adversary does not try to
violate the concentration around the means, a superchain is a good superchain
with high probability. The proof for superquality can be found in [25]. The proof
for dominant superchain property can be found in Appendix G.

C.1 Trimming

With the notion of a good superchain deﬁned, our trimming protocol description
from Section 4 can be completed by specifying the parameter functions used in
Algorithm 1. We next describe our trimming protocol. The protocol has security
parameters k, k(cid:48) ∈ N, a, c ∈ R+, and δ ∈ (0, 1). The length of the untrimmed
tail that is left untouched is dictated by the function ∆(P). If we denote B(cid:48) to
be the old trimming point, then let5,

∆(P) = k(cid:48) + a log (S(P, 0) + |P{B(cid:48) :}|) .

(4)

When P{: B(cid:48)} is trimmed to a certain level µ, we ﬁrst ensure that the relevant
upchain is a good superchain. The parameter g used here for level µ is given by,

g(P, µ) = k + a log S(P, µ).

(5)

5 Unless otherwise mentioned, logarithms are to the base e.

Achieving Almost All Blockchain Functionalities with Polylog. Storage

25

Apart from requiring that the µ-upchain is a good-superchain, we require
that there are “enough” number of superblocks of that level µ. This is given by

f (P, µ) = c · g(P, µ)

(6)

We require the functions ∆, g and f to depend on the logarithm of the es-
timated PoW to obtain strong concentration bounds, which achieves security
properties. As far as we know, this notion was ﬁrst used to obtain strong secu-
rity for blockchains in [37] where the authors call it “logarithmic waiting time”.

C.2 Comparing Work in trimmed Chains
Hybrid nodes need to have a protocol, Compare(C(1), C(2)), to chose the main
chain given two conﬂicting chains, C(1) and C(2). Full nodes (that store the
entire blockchain) simply choose the longer of the two chains as the main chain.
The chain selection protocol for hybrid nodes is a little more complicated since
they do not store the entire chain. At a high level, they use the sum of the
cumulative weight, S(P, 0), of the trimmed portion of a chain and the length of
untrimmed section of the chain as a proxy for the chain length. Next, we explain
this algorithm more formally.

Let P (1) and P (2) be two trimmed chains with underlying (complete) chains
C(1) and C(2). We need a protocol, Compare(P (1), P (2)), that outputs P (1) if
|C(1)| > |C(2)|, otherwise it outputs P (2). We allow error with small probability
given by the security deﬁnitions in Section 5.

The protocol is shown in Algorithm 2 and we summarize it here. First, only
the parts of the chains after their LCA block need to be compared (line 1). The
algorithm assigns weights to each chain, denoted Weight(P), and declares the
chain with the higher weight the winner (line 5). The weight is assigned to (the
non-common part of) a trimmed chain as follows. If the chain doesn’t have a
long enough untrimmed tail, then its weight is set to 0 (line 8). If the LCA block
b is after the trimming point, then the weight is set to the number of blocks
after b (lines 11 and 12). Otherwise, the level range in which b lies is computed
(line 14). For the ﬁrst level range, a set M of levels is formed with enough
number of superblocks of that level (line 16). Then, the highest PoW among the
upchains in set M is considered (line 17). For all subsequent level-ranges, the
PoW corresponding their level is added (lines 18 to 20). At the end, the PoW of
the untrimmed-tail is added and returned (line 22).

The Compare(·, ·) algorithm is used in two ways. First, by hybrid-nodes to
compute the main chain when they receive another (trimmed) chain which is
not the same as their trimmed chain. Second, by new hybrid-nodes to bootstrap
into the system. The new node receives (trimmed) chains from other nodes, and
then calls Compare(·, ·) on pairs of chains, until it is left with 1 winner.

C.3 State Veriﬁcation

Similar to CoinPrune [28], a short commitment to the state at the block is
stored in every block. Therefore, a hybrid node can verify the correctness of the

26

P. Hegde et al.

Algorithm 2: Compare(·, ·) Protocol to compare work in trimmed
chains

input

: P (1), L(1)
P (2), L(2)

f , L(1)
f , L(2)

l

l

, B(cid:48)(1) :: Chain 1
, B(cid:48)(2) :: Chain 2

, B(cid:48)(1), b)
, B(cid:48)(2), b)

l

f , L(1)
f , L(2)

1 b = LCA(P (1), P (2))
2 W (1) = Weight(P (1), L(1)
3 W (2) = Weight(P (2), L(2)
4
5 return argmax(W (1), W (2))
6
7 func Weight(P, Lf , Ll B(cid:48), b):
8

l

if |P{B(cid:48) :}| < ∆(g(P, 0) + |P{B(cid:48) :}|) then

9

10

11

12

13

14

15

16

17

18

19

20

21

22

return 0

if b ≥ B(cid:48) then

return |P{b :}|

ˆµ ← such that Lf (ˆµ) ≤ b ≤ Ll(ˆµ)

M =

(cid:110)

µ(cid:48) : |P ↑µ(cid:48)

{b : Ll(ˆµ) + 1}| ≥ f (P, ˆµ)

(cid:111)

W = maxµ(cid:48)∈M ∪{0}
for µ from ˆµ − 1 to 0 do

(cid:110)

2µ(cid:48)

|P ↑µ(cid:48)

{b : Ll(ˆµ) + 1}|

(cid:111)
.

if |P ↑µ {Lf (µ) : Ll(µ) + 1}| ≥ f (P, µ) then
W = W + 2µ|P ↑µ {Lf (µ) : Ll(µ) + 1}|.

return W + |P{B(cid:48) :}|

blockchain’s state by comparing it to the corresponding state commitment. The
protocol is called State − Verify and is presented with more details in Algorithm
3, and it is summarized in the following paragraph.

After a new node adopts a trimmed chain P with trimming point B(cid:48), it needs
to download the state, state(B(cid:48)), at its trimming point. Since all blocks to the
right of the trimming point are retained, the node can compute all the states
corresponding to blocks in the untrimmed tail. In order to verify the state, the
node checks whether the Merkle-root of the computed state for each block in
the untrimmed tail matches its corresponding Merkle-root y stored within the

Achieving Almost All Blockchain Functionalities with Polylog. Storage

27

block-header. If the Merkle-roots do not match at any block in the untrimmed
tail, then the algorithm returns False. This is shown in Algorithm 3.

Algorithm 3: State − Verify Protocol to verify the state of a trimmed
chain

input

: P :: trimmed chain
B(cid:48) :: trimming point
state(B(cid:48)) :: State at trimming point

1 for i from 0 to B − B(cid:48) do
Compute state(B(cid:48) + i)
2
if Merkle − root(state(B(cid:48) + i)) (cid:54)= y(B(cid:48) + i) then

3

return False

4
5 return True

D Poisson Process Preliminaries

X is a Poisson random variable with rate λ, denoted X ∼ P oisson(λ), if its
probability distribution satisﬁes,

P(X = x) = e−λ λx
x!

,

for x ∈ Z+.

Let A(t) be a random process indexed by time t ≥ 0. Denote A(t1, t2) =
A(t2) − A(t1), where t2 ≥ t1. A is a Poisson point process (or simply, Poisson
process) of rate λ, denoted as A ∼ P P P (λ), if,

A(t) ∼ P oisson(λt), for all t ≥ 0,

and for disjoint intervals (t1, t2) and (t3, t4),

A(t1, t2) is independent of A(t3, t4).

Since the range of A is the positive integers, and can be shown to be non-
decreasing with time, it can be thought of as a counting process. We also note
the fact the time between two successive events in A is called the interarrival
time, and it is distributed as an exponential random variable of rate λ.

First, we recall concentration bounds for a Poisson random variable, without

proof. The proof is obtained by applying Chernoﬀ Bound [7].

Lemma 1. Let X ∼ P oisson(λ), for some λ > 0. Then, for any x > 0,

P(X ≥ λ + x) ≤ e− −x2
P(X ≤ λ − x) ≤ e− −x2

2(λ+x) ,

2(λ+x) .

28

P. Hegde et al.

In the following lemma, we upper bound and lower the time required for n

events to occur in a Poisson process.

Lemma 2. Let A ∼ P P P (λ). Let T be a random variable indicating the time
taken for n events to occur in the Poisson process. That is, A(T ) = n. Then,
except with probability e−n δ(cid:48) 2
e−n δ(cid:48) 2

. Similarly, except with probability

2 , T ≤ n(1+δ(cid:48))

2 , T ≥ n(1−δ(cid:48))

λ

.

λ

Proof. Recall that in Poisson point process, interarrival times are i.i.d., exponen-
tial. Therefore, for X1, . . . , Xn
i=1 Xi. We can use Chernoﬀ
bound on T as follows:

iid∼ exp(λ1), T d= (cid:80)n

(cid:18)

P

T ≥

(cid:19)

n(1 + δ(cid:48))
λ1

≤ e−n sups>0

(cid:16) s(1+δ(cid:48) )
λ1

+log(1−s/λ1)

(cid:17)

,

= e−n(δ(cid:48)−log(1+δ(cid:48))),
≤ e−n δ(cid:48) 2
2 .

The upper bound is obtained similarly.

Lemma 3. Let A1 ∼ P P P (λ1) and A2 ∼ P P P (λ2) be independent Poisson
point processes, where λ2 < λ1.

Assume that A1 observers n events in a certain time range. Then, A2 observes

at most (1 + δ(cid:48))2λ2/λ1n events except with probability 2e− nλ2

2λ1

δ(cid:48) 2

.

Similarly, assuming that A2 observers n events, A1 observes at most (1 +

δ(cid:48))2λ1/λ2n events except with probability 2e− n

2 δ(cid:48) 2

.

Proof. From Lemma 2, the time required from process A1 to observe n events
is upper bounded by n(1 + δ(cid:48))/λ1 except with probability e−nδ(cid:48) 2/2. So, over
this range of time, except with probability e−n δ(cid:48) 2
2 , A2 is stochastically upper
bounded by Y ∼ P oisson
. Now, applying the bound for a Poisson
random variable from Lemma 1,

n λ2(1+δ(cid:48))
λ1

(cid:17)

(cid:16)

(cid:18)

Y ≥

P

nλ2
λ1

(cid:19)

(1 + δ(cid:48))2



≤ exp


−

n

(cid:17)2

(cid:16) λ2(1+δ(cid:48))
λ1
(1 + δ(cid:48))2

2n λ2
λ1

δ(cid:48)2




 ,

(cid:18)

= exp

−

(cid:19)

.

δ(cid:48)2

nλ2
2λ1

Therefore, over the time when A1 observes n events, A2 ≤ (1 + δ(cid:48))2λ2/λ1n

except with probability 2e− nλ2

2λ1

δ(cid:48) 2

.

The other bound is obtained similarly.

Achieving Almost All Blockchain Functionalities with Polylog. Storage

29

Lemma 4. Let A1 ∼ P P P (λ1) and A2 ∼ P P P (λ2) be independent Poisson
point processes, and A = A1 + A2. Given that over some range of time A = n,
then A1 ≤ nλ1
λ1+λ2

(1 + δ(cid:48)) except with probability e− nλ1

3(λ1+λ2)

δ(cid:48) (2)
3

.

(cid:16)

Proof. Given A, A1 behaves like a binomial random variable: (A1
Bin
standard Chernoﬀ bound for binomial random variables.

(cid:12)
(cid:12)A = n) ∼
. Therefore, the upper bound on A1 is obtained by using the

λ1
λ1+λ2

n,

(cid:17)

E Security Proofs

Let’s recall the notation. P (1) is the honest trimmed chain and P (2) is the adver-
sarial chain. The underlying chains be C(1) and C(2) respectively. Their respective
trimming points are B(cid:48)(1)(t) and B(cid:48)(2)(t), and their respective chain lengths are
B(1) and B(2). Let b = LCA(P (1), P (2)). And, b(cid:48) = LCA(C(1), C(2)). Trivially,
b(cid:48) ≥ b. Observe that b(cid:48) and b may not be equal because the trimmed chains may
skip blocks and thus have an earlier LCA block.

L(1)(·) is the level range function for P (1), and L(2) for P (2). Denote,

µ(1) such that L(1)(µ(1) + 1) < b ≤ L(1)(µ(1)),
µ(2) such that L(2)(µ(2) + 1) < b ≤ L(2)(µ(2)).

From the method by which Weight() function in Algorithm 2 chooses levels,
for the level ranges of µ(1) and µ(2), the Weight() function might use levels
ˆµ(1) ≤ µ(1) and ˆµ(2) ≤ µ(2) respectively (see line 16 and 17 of Algorithm 2). For
subsequent level ranges, the corresponding levels are used by Weight() (see line
20).

First, we bound the gap between the LCA of the pruned chains, b, and the

LCA of the underlying chains, b(cid:48).

Lemma 5. Denote,

(cid:40)

M = max

2ˆµ(1)

g

(cid:16)

P (1), µ(1)(cid:17)

,

2µ(1)−1g

(cid:16)

P (1), µ(1) − 1

(cid:17)

(cid:41)

.

M essentially indicates the maximum of PoW of the ﬁrst and second level ranges
of the honest trimmed chain.

Let b(cid:48) be in the µ(cid:48)(2)-level range in P (2). That is,

If µ(cid:48)(2) = µ(2), then,

L(2)(µ(cid:48)(2) + 1) < b(cid:48) ≤ L(2)(µ(cid:48)(2)).

2ˆµ(2)

|P (2){b + 1 : b(cid:48) + 1} ↑ˆµ(2)

| ≤ M.

30

Otherwise,

2ˆµ(2)

P. Hegde et al.

|P (2){b + 1 : L(µ(2)) + 1} ↑ˆµ(2)
2µW (2)(P (2), µ)

(cid:88)

+

|

µ(2)>µ>µ(cid:48) (2)

+ 2µ(cid:48) (2)

|P{L(µ(cid:48)(2)) + 1 : b(cid:48) + 1} ↑µ(cid:48) (2)

| ≤ M.

The above two equations essentially convey that the weight of the adversary’s
trimmed chain P (2) between b and b(cid:48) is upper bounded by M .

Proof (Proof of Lemma 5). This is a direct consequence of the dominant-superchain
property.

Next, we upper bound the weight of a trimmed chain.

Lemma 6. Let C be a blockchain and P be its corresponding trimmed chain
2. If |C| = B, then except with probability
produced by Algorithm 1. Let δ ≤ 1/
Baδ2 /2−1 , S(P, 0) + |P{B(cid:48) :}| ≤ ((1 + δ)2 + δ)B.

negl(k)

√

Proof. Let µ be the highest level with S(P, µ) ≥ δB. This means that, for all
µ(cid:48) ≤ µ,

|P{Lf (µ(cid:48)) : Ll(µ(cid:48)) + 1} ↑µ(cid:48)
By Lemma 3, we get that for every µ(cid:48) ≤ µ,

| ≥ k + a log(δB).

|P{Lf (µ(cid:48)) : Ll(µ(cid:48)) + 1} ↑µ(cid:48)

| ≤ (1 + δ2) (Ll(µ(cid:48)) − Lf (µ(cid:48)) + 1) ,

except with probability

2e− k+a log(δB)

2

δ2

=

negl(k)
Baδ2/2

.

From Lemma 9, the number of level-ranges in P is at most log B/ log 2, except

with probability negl(k)/Ba/4. Therefore, by a union bound,

S(P, 0) + |P{B(cid:48) :}| ≤ ((1 + δ)2) + δ)B,

except with probability,

log B ·

negl(k)
Baδ2/2

+

negl(k)
Ba/4

=

negl(k)
Baδ2/2−1

.

Next, we prove Theorem 1.

E.1 Proof of Theorem 1

Proof (Proof of Theorem 1). The proof is by induction on the length of the
honest blockchain B(1).

Achieving Almost All Blockchain Functionalities with Polylog. Storage

31

As the base case, consider B(1) = ck. Since no trimming has occurred up to

this point, the probability of a trim-attack up to this point is 0.

As the induction hypothesis, assume that up to chain-length B, the adversary
wasn’t able to create a fork from beyond a honest node’s trimming point. That
is,

∀t such that B(1)
(cid:16)

P (1)
t

, P (2)
t

LCA

t < B, Compare

(cid:16)

P (1)
t

, P (2)
t

(cid:17)

= P (2)
t

implies that

(cid:17)

≥ B(1)

t − ∆(S(P (1)

t

, 0) + |P{B(cid:48)(1)

t

:}|).

(7)

For the induction step, consider a time t when the length of the honest chain
t = B. As a contradiction, assume that the adversary has created a secret
<

= P (2), and b = LCA

P (1), P (2)(cid:17)
(cid:16)

P (1), P (2)(cid:17)

(cid:16)

is B(1)
chain P (2)
t
B − ∆(S(P (1)

such that, Compare
, 0) + |P{B(cid:48)(1)

:}|).
We now split into two cases based on the location of b:

t

t

Case 1: b ≥ δB By superchain quality of P (1), we have,

S(P (1), µ(1)) ≥ (1 − δ)b,

≥ (1 − δ)δB.

Moreover, since P (2) shares blocks with P (1) up to block b, we have,

S(P (2), µ(2)) ≥ (1 − δ)b,

≥ (1 − δ)δB.

(8)

(9)

As a consequence of Lemma 5, the weight of P (2) between blocks b and b(cid:48) is

upper bounded by M .

Next, we deﬁne a block b(cid:48)(cid:48) ≥ b(cid:48) which is such that all level ranges in P (2){b(cid:48)(cid:48) :}
are of size at least c(cid:48)g(P (1), µ(1)), for some 1 < c(cid:48) < c. In order to ensure this,
b(cid:48)(cid:48) can be deﬁned as,

b(cid:48)(cid:48) =




b(cid:48),



L(2)
l

if |P (2){b(cid:48) + 1 : Ll(µ(cid:48)(2)) + 1} ↑µ(cid:48) (2)

|

≥ c(cid:48)(k + a log((1 − δ)δB)),

(10)

(µ(cid:48)(2)) + 1, otherwise,

where µ(cid:48)(2) is the level range in which block b(cid:48) resides in P (2). If b(cid:48) > b, then
µ(cid:48)(2) ≤ max{ˆµ(1), µ(1) − 1}. Therefore, the weight of P (2) between b(cid:48) and b(cid:48)(cid:48) is
upper bounded by c(cid:48)M .

Let b∗ be the earliest block such that all blocks in P (2){b∗ + 1 :} were mined

by the adversary. Then, by the induction hypothesis,

b∗ − b(cid:48)(cid:48) ≤ ∆(S(P (1)

t

, 0) + |P (1)

t {B(cid:48)(1) :}|).

32

P. Hegde et al.

The above statement is proved as follows. Assume there was a time t∗ when b∗
was in a honest node’s chain, but at a later time t the block after b(cid:48)(cid:48) in P (2)
is
not in the honest node’s chain Ct. By the induction hypothesis,

t

b∗ − b(cid:48)(cid:48) ≤ ∆(S(P (1)
≤ ∆(S(P (1)

t∗ , 0) + |P (1)
, 0) + |P (1)

t∗ {B(cid:48)(1) :}|),
t {B(cid:48)(1) :}|).

t

Given, k(cid:48) = k − a log (cid:0)((1 + δ2) + δ)/δ(cid:1). Therefore, from Lemma 6, except

with probability negl(k)

Baδ2/2−1 ,

∆(S(P (1)

t

, 0) + |P (1)

t {B(cid:48)(1) :}|) ≤ g(P (1), µ(1)).

Therefore,

Weight(P (2), b∗) ≥

c(cid:48) − 1
c(cid:48)

c − 1 − c(cid:48)
c

Weight(P (1), b).

Since, each level range in P (2){b∗ :} contains at least g(P (1), µ(1)) number of
corresponding superblocks, we have that except with probability negl(k) log B/Baδ2/2,
the time required T required by the adversary is lower bounded as,

T ≥

(1 − δ)
λa

c(cid:48) − 1
c(cid:48)

c − 1 − c(cid:48)
c

Weight(P (1), b).

In this time, except with probability negl(k)/Baδ2/2, the honest chain growth

is lower bounded as,

|C{b :}| ≥ (1 − δ)2 λh
λa

c(cid:48) − 1
c(cid:48)

c − 1 − c(cid:48)
c

Weight(P (1), b).

We know from superquality property that Weight(P (1), b) ≥ (1 − δ)|C{b :}|.

Therefore, we reach a contradiction if,

(1 − δ)3 λh
λa

c(cid:48) − 1
c(cid:48)

c − 1 − c(cid:48)
c

> 1.

(11)

Case 2: b < δB The reason to consider this case separately is because when
b < δB, the corresponding level-range containing b may not have enough number
of blocks for us to obtain a strong concentration bound. Therefore, we jump
ahead to a level which contains enough superblocks. Let ˜µ(2) be the highest-
level in P (2) such that,

S(P (2), ˜µ(2)) ≥ δB.

In case b(cid:48) falls in the level range of ˜µ(2) or below, then the same analysis
for Case 1 holds. In particular, if the relation in (11) is satisﬁed, we reach a
contradiction except with probability negl(k)

Baδ2/2−1 .

Achieving Almost All Blockchain Functionalities with Polylog. Storage

33

Otherwise, if b(cid:48) falls in a level-range higher than ˜µ(2), we set,

b(cid:48)(cid:48) = L(2)

f (˜µ(2)).

Since b < δB, we have,

Weight(P (2), b(cid:48)(cid:48)) ≥ (1 − δ)Weight(P (2), b),

(x)
≥ (1 − δ)Weight(P (1), b),

(y)
≥ (1 − δ)3B.

(x) follows because we assume that P (2) beats P (1). (y) follows by superchain
quality of the honest chain and the fact that b < δB.

By the same argument of the induction hypothesis used in Case 1, except
Baδ2/2−1 , (c − 1)/c fraction of the blocks in P (2){b(cid:48)(cid:48) :} were
Baδ2/2 , by the time that

with probability
mined by the adversary. Again, except with probability negl(k)
the adversary mines those blocks, the length of the honest chain would be,

negl(k)

|C{b + 1 :}| ≥ (1 − δ)5 λh
λa

c − 1
c

B.

The above equation is a contradiction if,

(1 − δ)5 λh
λa

c − 1
c

> 1.

(12)

End Case 2

There are at most B − ∆(P (1)) unique choices that can be made for block b.
For each choice, the conclusions of Case 1 and Case 2 hold except with probability
Baδ2 /2−1 . Therefore, taking a union bound over all choices of b, the conclusions
hold except with probability negl(k)

Baδ2/2−2 . This completes the induction step.

negl(k)

The induction step at chain-length B is violated with probability negl(k)

Baδ2 /2−2 .

Therefore, summing over all chain lengths, we have,

P(trim − attacked) ≤

∞
(cid:88)

negl(k)
Baδ2/2−2

,

(13)

B=1
= negl(k),

where the last equation follows since aδ2/2 − 2 ≥ 2.

E.2 Proofs of Other Theorems:

Proof (Proof of Corollary 1). We have proved in Theorem 1 that the adversary
cannot create a longer fork from before a honest node’s trimming point except

34

P. Hegde et al.

with probability negl(k). Since a honest node retains all blocks after the trimming
point, comparing two trimmed chains that diﬀer only after the trimming point is
equivalent to comparing the underlying chains (see line 11 and 12 in Algorithm
2).

Proof (Proof Sketch of Theorem 2). In order to pass through the state − verify
protocol in Algorithm 3, the adversary has to produce a malicious state at the
trimming point of an honest node, such that it veriﬁes against all the states
corresponding to the untrimmed chain tail. In Section B.3, we explained that
the adversary’s process of generating a malicious state sequence is a Poisson
process of rate λs, where λs << λa. Therefore, from the same argument as in
Theorem 1, we can prove that there exists no time when the adversary can create
such a malicious state.

Proof (Proof of Corollary 2). This is a corollary of Theorems 1 and 2. Since, the
probability that there exists a time when the system is either
trim − attacked or state − attacked is very small, the probability that an arriving
node sees the system attacked in either way is negligible in k.

Proof (Proof Sketch of Theorem 3). Assume that all relevant quantities con-
centrate strongly around their means. First, the highest level-range would be
µh = O(log B). This is because, a level µh is 2µh times harder to ﬁnd than a
level-0 superblock.

Next, a level range of level-µ would contain at most O(log B) µ-superblocks.
Because, if there were more, then it could be trimmed to level-(µ + 1). Since we
also retain suﬃxes of length O(log B) blocks of every lower level, level-range µ
would contain about O(log2 B) blocks. Adding across all the µh number of level
ranges, the trimmed portion of P would contain about O(log3 B) blocks. And,
the untrimmed tail would contain at most O(log B) blocks.

Since an interlink contains a link to the previous superblock of every level,
the size of the interlink would be O(log B), thus making the size of each block
O(log B). Therefore, the total storage requirement would be O(log4 B). These
statements are proved more rigorously in appendix H.

F Trimming Attack

Here we prove Theorem 4.

Proof (Proof of Theorem 4). Let f (x) = c0 log(1 + x), for some small constant
c0. Deﬁne a sequence (αi)i as follows:

α0 = 0,
α1 = 1,

αi = 2f





i−1
(cid:88)



αj

 ,

i ≥ 2.

j=1

Achieving Almost All Blockchain Functionalities with Polylog. Storage

35

The adversarial attack follows a sequence of attempts. The ith attempt be-
gins when |Ct| = (cid:80)i−1
j=0 αj. At this point, the adversary abandons the previous
attempt and starts mining on a secret chain Dt forking away from Ct at this
tip. The attempt lasts until one of Ct or Dt reach a length of
+ 1.
If D reaches the length ﬁrst, then the adversary waits until C reaches a length
of (cid:80)i
j=0 αj, at which point it publishes D. Since, D will be longer than C, the
honest nodes will adapt D. The fact that this is a successful trimming attack
follows from the following claim:
Claim 5 For all large enough i, αi ≥ f ((cid:80)i

j=0 αj

(cid:16)(cid:80)i

(cid:17)

j=1 αj)

From the deﬁnition of the attack, the length of the honest chain when adver-
sary publishes his secret chain is (cid:80)i
j=1 αi) is an upperbound
on the number of blocks between the trimming point and the tip of the chain
for the honest node, since B − B(cid:48) = o(log B). Therefore, the above claim shows
that the adversary has successfully created a fork from before a trimming point
of any node. To prove the claim, for large enough i we have,

j=1 αi. Recall, f ((cid:80)i





i−1
(cid:88)





αj

 + f



αi = f



αj

 ,

i−1
(cid:88)

j=1

j=1





i−1
(cid:88)

j=1





i
(cid:88)

j=1

(a)
≥ f

(b)
≥ f



αj

 + f (αi),



αj

 .

(a) follows because 2c0 log(z) ≤ z. (b) follows by the sub-additivity of log(1 + z).
The below two claims are needed to compute the probability of a successful

attack attempt.

Claim 6 αi ≤ c1 log i, for all i ≥ 2 and c1 = 1 + 4c0.

Assuming c0 ≤ 1/4, 1 ≤ c1 ≤ 2. We will prove the above claim by induction.
As the base case, α2 = 2c0 log(1 + α11) = 2c0 log 2 ≤ c1 log 2. Assume that the
claim is true for all j ≤ i − 1. Then,



αi = 2c0 log

1 +



αj

 ,

i−1
(cid:88)

j=1

≤ 2c0 log(1 + (i − 1)c1 log i),
(a)
≤ 2c0 log(ic1 log i),
= 2c0 log i + 2c0 log c1 + 2c0 log log i,
(b)
≤ 2c0 log i + 2c0 log i + log i,
= (4c0 + 1) log i.

36

P. Hegde et al.

(a) follows since c1 ≥ 1. (b) follows since i ≥ 2 ≥ c1.

The probability of the adversary’s ith attempt succeeding is e−c2αi, for some

constant c2 [37].
Claim 7 (cid:80)∞

i=1 e−c2αi = ∞.

To prove the claim,

∞
(cid:88)

i=2

∞
(cid:88)

e−c2αi =

e−2c0c2 log(1+(cid:80)i−1

j=1 αi),

i=2
∞
(cid:88)

(a)
≥

i=2
∞
(cid:88)

i=2
∞
(cid:88)

i=2
∞
(cid:88)

=

(b)
≥

(c)
=

i=2
= ∞.

e− log(1+(cid:80)i−1

j=1 αj ),

,

1 + (cid:80)i−1

1
j=1 αj
1
1 + (cid:80)i−1
j=1 c1 log i

,

1
1 + c1i log i

,

(a) follows since c0 can be made as small as desired. (b) follows from Claim 6.
(c) can be veriﬁed to diverge using the integral test.

Since the attack-attempts are carried over disjoint sections of the blockchain,
all the attempts are mutually independent. Therefore, from Claim 7 and the
second Borel-Cantelli Lemma, we have,

P(trim − attacked) = 1.

G Dominant Superchain

We will use the following concentration bound for sums of independent, but not
necessarily identically distributed, Bernoulli random variables. It can be proved
by an elementary application of Chernoﬀ bound and can be found in [14].

Lemma 7. Let {Xi}n
Xi ∼ Bernoulli(pi). Let Sn = (cid:80)n

i=1 be a sequence of independent random variables with
i=1 pi. Then, for 0 < ε < 1,

i=1 Xi, and sn = (cid:80)n

P (Sn ≤ (1 − ε)sn) ≤ e− ε2

2 sn .

We now prove the high likelihood of dominant superchains.

Achieving Almost All Blockchain Functionalities with Polylog. Storage

37

Lemma 8. Let C be a blockchain and C ↑µ be its corresponding level-µ upchain.
Then, for any k ∈ N and g ≥ k + a log(|C|). Then, if a ≥ 8, C ↑µ is a dominant
superchain with high probability in k and |C|.

Proof. Consider a starting block b1 ≥ C[0] and ending block b2 ≤ C[−1].

First, observe that if C[b1 : b2 + 1] ↑µ≥ 1, then any trimmed chain P starting
at b1 and ending at b2, and with its highest level range being at most µ, will
contain at least one level-µ superblock. This is because a level-µ superblock,
call it b3, is also a level-µ(cid:48) superblock for any µ(cid:48) ≤ µ. Therefore, the interlink
data-structure ensures that a there is a level range µ(cid:48), which contains a link to
b3.

Let P (cid:48) be the trimmed chain of the highest weight starting at b1 and ending
at b2, and with its highest level-range being at most µ. Assume that it satisﬁes
the premise as deﬁned in equation 3. That is,

2µ1 |P (cid:48){l :L(cid:48)

l(µ(cid:48)) + 1} ↑µ1 |
(cid:88)
2µ(cid:48)(cid:48)
|P (cid:48){L(cid:48)

+

f (µ(cid:48)(cid:48)) : L(cid:48)

l(µ(cid:48)(cid:48)) + 1] ↑µ(cid:48)(cid:48)

| ≥ 2µg.

µ(cid:48)(cid:48)<µ(cid:48)

It is useful re-arrange the equation by dividing both sides by 2µ.

2µ1−µ|P (cid:48){l :L(cid:48)

l(µ(cid:48)) + 1} ↑µ1 |
(cid:88)

2µ(cid:48)(cid:48)−µ|P (cid:48){L(cid:48)

+

f (µ(cid:48)(cid:48)) : L(cid:48)

l(µ(cid:48)(cid:48)) + 1] ↑µ(cid:48)(cid:48)

| ≥ g.

(14)

µ(cid:48)(cid:48)<µ(cid:48)

Given that a block is a level-µ(cid:48)(cid:48) superblock, let X be an indicator variable for
it also to be a level-µ superblock. Then, P(X = 1) = 2µ(cid:48)(cid:48)−µ. Therefore, we can
associate a sequence of Bernoulli random variables {Xi}n
i=1 with P, where Xi
indicates whether the the ith superblock as taken in (14) is a level-µ superblock.
Denoting P(Xi = 1) = pi, equation (14) says that,

sn =

n
(cid:88)

i=1

pi ≥ g.

Now, using Lemma 7, we can lower bound Sn = (cid:80)n

i=1 Xi, as,

P(Sn ≤ 1) ≤ e− (1−1/g)2

2

g,

≤ e−g/4,
negl(k)
Ba/4

≤

,

where we denote B = |C|. There are totally B ways to choose b1, and then
B − b1 ways to choose b2. Therefore, there are totally at most B2 ways to choose
b1 and b2. Taking a union bound over all possible starting points b1 and ending
points b2, we conclude there exists at least one level-µ superblock in C with high
probability if a ≥ 8.

38

P. Hegde et al.

H Succinctness

Lemma 9. When the length of the blockchain C is B, the highest-level of su-
perblock in the corresponding trimmed chain P is at most log B/ log 2 except with
probability negl(k)/Ba/4.

Proof. Let µ = log B/ log 2. Then, weight of 1 level-µ superblock is 2µ = B.
Therefore, g(P, µ) ≥ B.

Also, |C ↑µ| ∼ P oisson(1). Therefore, applying the Poisson concentration

bound,

P (|C ↑µ| ≥ g(P, µ)) ≤ P (|C ↑µ| ≥ 1 + (k − 1) + a log B) ,
≤ e− k−1+a log B
negl(k)
Ba/4

=

,

.

4

The proof is complete by observing that if |C ↑µ| < g(P, µ), then the chain won’t
be trimmed to this level.

Next, we show that individual level ranges aren’t too big.

Lemma 10. Let P be a trimmed chain of an underlying chain C obtained by the
trimming protocol. Let Lf and Ll be the associated level range functions. Then,
for every level µ, |P{Lf (µ) + 1 : Ll(µ)} ↑µ| ≤ 4f (P, µ), with high probability.

Proof. As a contradiction, assume that there were a level µ, such that |P{Lf (µ)+
1 : Ll(µ)} ↑µ| ≤ 4f (P, µ). Then, from Lemma 3, with high probability, we would
have |P{Lf (µ) + 1 : Ll(µ)} ↑µ+1| ≤ f (P, µ). This means that the trimming
protocol would have trimmed this range to level µ + 1.

Now we are ready to prove the optimistic succinctness theorem.

Proof (Proof Theorem 3). From Lemma 9 we know that the highest level is
O(log B) with high probability. And, from Lemma 10, the number of µ-level
superblocks in level range µ is O(log B) with high probability.

According to the construction of level range µ in the trimming protocol, it
contains O(log B) superblock of level-µ(cid:48) for each level µ(cid:48) < µ. Therefore, each
level range contains O(log2 B) blocks with high probability. And, since there are
at most O(log B) level ranges, the number of blocks in the trimmed section of
P is O(log3 B) blocks. Since, the untrimmed tail consists of O(log B) blocks, P
totally contains O(log3 B) blocks.

Each block has the interlink, which in turn contains a link to the previous
superblock of every level. Since there are at most O(log B) level of superblocks,
the size of the interlink is O(log B). This makes the overall size of P as O(log4 B).

Achieving Almost All Blockchain Functionalities with Polylog. Storage

39

I Our Protocol in the Random Oracle Model

In our analysis, we have modelled PoW mining as calls to an ideal random
functionality which returns a “success” with a small probability, and “failure”
otherwise, independent of everything else. However, in current PoW systems,
mining is performed by making calls to a random oracle hash function, H :
{0, 1}∗ → {0, 1}κ, where κ is a security parameter. Since the output space of
H is ﬁnite, we cannot have our formulation of trim − attacked in Deﬁnition 1
as a security model. This is because trim − attacked considers time from 0 to
inﬁnity, during which time the hash function H is going to experience collisions
with probability 1. In particular, in order to ensure that H doesn’t experience
collisions with high probability, one can only run the blockchain for poly(κ) time
(or, poly(κ) rounds in the discrete time model)6.

In [30], the authors denote our ideal random functionality as Ftree. They
prove that when a blockchain is run for poly(κ) rounds, the Ftree model and the
random oracle model are statistically close (see Lemma 5.1 in [30]). Using this,
they prove that if a blockchain protocol is secure under the Ftree model, it is
secure under the random oracle model for poly(κ) number of rounds as well. We
can employ this result in transferring our security deﬁnitions in Section 5 to the
more realistic random oracle model for hashing. For example, Theorem 1 would
imply that an adversary without a majority of the mining power cannot create a
longer-fork from before a honest node’s trimming point at any point during the
poly(κ) rounds of blockchain execution (instead of inﬁnite number of rounds).
Similar arguments hold under the Bitcoin Backbone model[23] as well.

J Optimizing Storage with Stateless Blockchains

Our trimming protocol optimizes the amount of cold storage required to repre-
sent the PoW in the blockchain. In this section, we describe how our work can
be interfaced to other methods that optimize the storage of the state. In hybrid
nodes, states need to be stored both in cold and hot storage. The state at the
trimming point, state(B(cid:48)
t), needs to be stored in cold-storage in order to recover
the state at the chain tip when forks are created. Conversely, the state at the
tip of the chain, state(Bt), needs to be stored in hot-storage in order to perform
transaction and block validation. Along with the length of the blockchain, the
size of the blockchain-state is also rapidly increasing with time. For instance, at
the time of writing Bitcoin’s UTXO state is almost 4GB in size, which motivates
lessening high storage and veriﬁcation time burdens by extending our work to
optimize both the state’s cold-storage at the trimming point, and its hot-storage
at the chain tip.

So far, we have described that storing state-commitments in the blocks en-
ables one to securely establish the state of a trimmed chain, by use of the
state-verify protocol described in Algorithm 3. In a diﬀerent line of work, called

6 poly(κ) means polynomial in κ.

40

P. Hegde et al.

stateless blockchains, state-commitments are used to reduce the amount of hot-
storage required for transaction validation, thus speeding up validation. In this
section, we illustrate that when hybrid nodes are used in stateless-blockchains,
then state commitments can serve a dual purpose: 1) they can be used to estab-
lish the state of the trimmed chain; 2) and, they can be used to perform stateless
transaction validation.

Stateless validation, ﬁrst proposed by Todd [38], is a scheme where nodes val-
idating transactions store a short cryptographic state-commitment rather than
the entire state. A client then provides a membership proof that the node can
verify against the commitment. Recently, several constructions have been devel-
oped to perform stateless validation in both the UTXO and account-based state
models using various cryptographic primitives [10, 13, 4, 39, 34, 1, 19]. As an ex-
ample, the following is how stateless validation of an account-based state would
work via vector commitments, a primitive allowing one to commit to an ordered
sequence of values in a way that allows one to later open the commitment at a
speciﬁc position in the sequence, with proof that the ith value is the ith commit-
ted message (see [8]). Suppose an account is represented by a tuple of the form
mapping a public key to a balance: (pki, vi), and that party 1 want to transfer
an amount m to party 2. Then, the transaction submitted by party 1 takes the
form tx = (pk1, v1, pk2, m, π, σ) where pk1 is the public key of the source ac-
count, pk2 is the public key of the destination account, v1 is the initial balance
of pk1, m is the amount being transferred, π is a proof of membership of (pk1, v1)
in the commitment, and σ is a signature of (v1, pk2, m, π) under pk1. In order to
validate a transaction, a node checks that m < v1, the validity of the signature,
and the validity of the proof with respect to the public commitment y(Bt). If
the checks passes, the commitment is updated to reﬂect the change in the two
accounts: (pk1, −m) and (pk2, +m). With each such update, users update their
proofs π so that they remain valid with respect to the latest commitment.

As a ﬁrst step, observe that stateless blockchains optimize hot-storage by
obviating the need to store the state at the tip of the chain in the RAM. At this
point, the state at the trimming point is still stored in the cold storage. We can
use this to provide an interface from trimming to stateless blockchains: Firstly,
if the proof for some client becomes outdated past the trimming point because
it was oﬄine for a long while, then the client can recompute its latest proof by
querying a hybrid node for state(B(cid:48)
t) and the untrimmed chain tail. Secondly,
if a fork in the chain makes the proofs of several clients invalid, they can all
recompute their proofs by contacting the hybrid node similarly.

Now, we describe a way to optimize the cold-storage of the state at the
trimming point as well. In order to do this, we need to make an assumption
on the clients. At every point, the client needs to store its membership proof
corresponding to every block in the untrimmed tail of hybrid nodes. This enforces
a couple of constraints on clients. First, the storage requirements of a client would
scale logarithmically in the length of the blockchain as well, since the length of
the chain-tail grows logarithmically. Second, the clients need to be online very
often so that their proofs never get outdated. If this is too cumbersome, clients

Achieving Almost All Blockchain Functionalities with Polylog. Storage

41

can alternatively delegate the job of saving and updating proofs to proof-serving
nodes [10]. In this case, the hybrid node need not store the entire state at the
trimming point either. This is because, even in the event that a fork is created
in the untrimmed-tail, all the clients would have their proofs corresponding to
the forking point. In this case, a joining hybrid node would no longer need to
use the state-verify protocol, since just the state commitment suﬃces. The rest
of the hybrid node’s protocols proceed as before.

