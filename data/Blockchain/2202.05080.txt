2
2
0
2

b
e
F
0
1

]

R
P
.
h
t
a
m

[

1
v
0
8
0
5
0
.
2
0
2
2
:
v
i
X
r
a

On an Asymptotic Criterion for Blockchain Design:
The Asynchronous Composition Model

Partha S. Dey1 and Aditya Gopalan2
1Department of Mathematics, University of Illinois at Urbana-Champaign, e-mail: psdey@illinois.edu

2Department of Industrial and Enterprise Systems Engineering, University of Illinois at Urbana-Champaign,
e-mail: gopalan6@illinois.edu

Abstract: Inspired by blockchains, we introduce a dynamically growing model of rooted
Directed Acyclic Graphs (DAGs) referred to as the asynchronous composition model, sub-
ject to i.i.d. random delays (ξt)t with ﬁnite mean. The new vertex at time t is connected
to vertices chosen from the graph G(t−ξt)+ according to a construction function f and
the graph is updated by taking union with the graph Gt−1. This process corresponds to
adding new blocks in a blockchain, where the delays arise due to network communication.
The main question of interest is the end structure of the asynchronous limit of the graph
sequence as time increases to inﬁnity.

We consider the following construction functions of interest, a) Nakamoto construction
fNak, in which a vertex is uniformly selected from those furthest from the root, resulting
in a tree, and b) mixture of construction functions (fk)1(cid:54)k(cid:54)∞, where in fk a random set
of k leaves (all if there are less than k in total) is chosen without replacement.

The main idea behind the analysis is decoupling the time-delay process from the DAG
process and constructing an appropriate regenerative structure in the time-delay process
giving rise to Markovian behavior for a functional of the DAG process. We establish that
the asynchronous limits for fNak, (fk)k(cid:62)2, and any non-trivial mixture f are one-ended,
while the asynchronous limit for f1 has inﬁnitely many ends, almost surely. We also
study fundamental growth properties of the longest path for the sequence of graphs for
fNak. In addition, we prove a phase transition on the (time and sample-path dependent)
probability of choosing f1 such that the asynchronous limit either has one or inﬁnitely
many ends. Finally, we show that the construction f∞ is an appropriate limit of the
(fk)k.

MSC2020 subject classiﬁcations: Primary 60G50, 60J20, 05C80; Secondary 60F05.
Keywords and phrases: blockchain, distributional recursion, renewal processes, Markov
chain, random networks, stability, central limit theorem.

Contents

2
1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
2 Deﬁnitions and Main Result . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3 Regenerative Behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
4 Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
5 Proofs for Regenerative Behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
6 Proofs of Main Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
7 Discussion and Further Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
Acknowledgments.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34

1

 
 
 
 
 
 
Dey & Gopalan/Asynchronous Composition Model

2

1. Introduction

In this article, we introduce a novel model for dynamically growing directed graphs, here-
after referred to as the asynchronous composition model. Mainly inspired by blockchains, this
model may also be of independent interest as a time-indexed random graph process outside
the blockchain context. We also use an integer-valued asynchronous recursion to analyze the
growth rate of one such asynchronous composition related to the Bitcoin system; this cor-
responds to asynchronous composition in a more general setting outside of random graph
growth processes. The class of asynchronous recursions introduced in this paper is a new
class of max-type distributional recursions whose analysis does not follow the techniques in
the survey paper [2]. The analysis of asynchronous recursions may also be of independent
interest.

Let B∗ denote the space of all rooted, ﬁnite, and connected directly acyclic graphs (or
DAGs) with each vertex marked with a non-negative integer. Let ξ := (ξt)t(cid:62)1 be a sequence
of non-negative integers. We interpret ξ as the time delay process: the value of ξt (cid:62) 1 is the
delay seen by the process at time t, including the passage of a single time step. We proceed by
composing the function f , but with asynchrony arising from the delay dynamics. Here, we use
the word asynchronous to mean that the sequence of delays ξ is not identically the constant
one; otherwise, we use the word synchronous. This terminology is based on the broader area
of distributed systems and explains the model’s name. Let θ := (θt)t(cid:62)1 be a sequence of real
numbers in [0, 1]; this sequence drives the graph dynamics at any given time step.

We assume that the sequence ξ are i.i.d. N-valued random variables and θ are i.i.d. U(0, 1)
random variables independent of ξ. Thus, our process is driven by two sources of randomness:
the sequence ξ drives the delay, and the sequence θ provides a source of edge-randomness for
each time step. We now formally deﬁne the model.

Deﬁnition 1.1 (Asynchronous Composition Model). The asynchronous composition model
(ACM) with construction function f evolves in discrete time as follows:

– At time t = 0, we are given a ﬁnite DAG, G0 = (V0, E0) ∈ B∗, such that all vertices in

G0 are marked 0.

– At each time t (cid:62) 1, the DAG Gt := (Vt, Et) is determined as follows:

Vt = Vt−1 ∪ {t}, Et = Et−1 ∪ {(t, v) | v ∈ f (G(t−ξt)+, θt)},

where f : (G, u) (cid:55)→ 2V (G) is given and x+ := max{x, 0}. For simplicity of notation, we
write

Gt := Gt(f ) = Gt−1 ∪ f (G(t−ξt)+, θt) for t (cid:62) 1.

(1.1)

– All vertices are marked by the time at which they are created. We refer to the vertex of

mark i (cid:62) 1 as the i-th vertex or as vertex i.

Throughout this paper, we say the vertex at time t connects to each vertex given by the

function f (G(t−ξt)+, θt).

Intuitively, the function f in Deﬁnition 1.1 provides a random set of vertices to which the
new vertex will connect. Any such function f can be considered as a construction function
for a blockchain system, which determines how a new block is attached to a blockchain. In

Dey & Gopalan/Asynchronous Composition Model

3

this article, we will consider f such that f (G, ·) is a random subset of the leaf set, i.e., set of
vertices with in-degree zero. In Section 1.2, we discuss the relevance of this model to blockchain
systems in detail.

In the blockchain context, we discuss the importance of one-endedness in the temporal limit
of Gt, both with and without delays. This problem corresponds to determining which con-
struction functions f are such that the temporal limit of Gt is one-ended in both synchronous
and asynchronous operations. The deﬁnition of a graph limit is made precise in Section 2.3.
Our primary focus is a class of construction functions based on the Iota [21] protocol; this is
one of the more widely used protocols for which one-endedness has not yet been established.
The Iota protocol uses a construction function that behaves as follows: given a DAG G, a pair
of vertices is chosen through some (unspeciﬁed in [21]) measure. The new vertex connects to
both vertices in this pair. In this paper, we assume that this measure is uniform for simplicity.
The uniformity assumption is also made in King’s analysis of the Iota protocol [19].

t(cid:62)1

For the rest of this paper, we assume that E ξ < ∞; more speciﬁcally, for technical reasons
our proofs require the assumption that E ξ1+δ < ∞ for some δ > 0. When E ξ = ∞, using the
fact that E ξ = (cid:80)
P(ξ (cid:62) t), one can easily see that the degree of the root vertex diverges
to inﬁnity almost surely; hence the limiting graph will not be locally ﬁnite. Thus the limits
considered in this paper do not exist when E ξ = ∞. Moreover, it will be clear that this
situation is undesirable in the blockchain context. Even in the E ξ < ∞ case, the two cases
P(ξ = 1) > 0 and P(ξ = 1) = 0 behave diﬀerently. We discuss this further in Section 1.1.
Also, not every function with a one-ended synchronous limit has a one-ended asynchronous
limit; this presents a fundamental challenge to the analysis.

Assume that fNak is the Nakamoto construction function, where a vertex is chosen uniformly
from those at the maximum hop distance from the root. For k (cid:62) 1, we denote by fk the
construction function, which chooses a set of k leaves uniformly at random from the set of
k-tuples of leaves. If less than k leaves for k (cid:62) 2, we chose all leaves in the graph. The function
f∞ is such that all leaves are chosen in the graph. Our main results are summarized as follows.
Detailed statements are given in Section 2.5.

– Theorem 2.15 – For the Nakamoto construction function fNak, we prove a closed-form
expression for the growth rate of the longest path to the root in Gt. This expression
corresponds precisely to the fraction of conﬁrmed vertices in the asynchronous limit.
This expression for the growth rate is a universal upper bound on the growth rate of
the same quantity for any construction function.

– Theorem 2.17 and 2.18 – The synchronous limit of f1 has as many ends as leaves
in G0. We show that the asynchronous limit of f1 has inﬁnitely many ends almost
surely, even starting from a single vertex at time zero. In particular, the number of
leaves in Gt(f1) grows as Θ(
t). However, for any mixture f of the (fk)k such that
P(f = f1) < 1, we show that both the synchronous and asynchronous limits of Gt(f )
are almost surely one-ended. See ﬁgure 1 below for two simulated graphs with f = f1
and f = f2, respectively.

√

– Theorem 2.19 – Finally, we consider the time-varying construction functions (ft)t,
which is a mixture of the (fk)k for every t. We identify (up to order) the state-based
threshold for P(ft = f1) above which the asynchronous limit is one-ended. We also
prove that the graph process related to the function f∞ is an appropriate limit of the
processes related to the (fk)k, as expected.

Dey & Gopalan/Asynchronous Composition Model

4

Fig 1. Sample G1000 with f1 and f2, respectively, with Geometric(3/4) delay distribution. Graphs were drawn
using Kamada-Kawai spring layout from python networkx module.

The crucial step in our analysis is decoupling the delay dynamics and the graph dynam-
ics built on top. We deﬁne the notion of time-delay graph in Section 1.1 below. Moreover,
recurrence of speciﬁc local graph structure will imply one-endedness.

When P(ξ = 1) > 0, it suﬃces to know the number of leaves at the regeneration times.
Indeed it will be shown in Lemma 2.12 that if there are inﬁnitely many regeneration times
where the new vertex connects to a unique single leaf, the limit graph is one-ended. When
P(ξ = 1) (cid:62) 0, we use a more complicated state space at the regeneration intervals of length
r := min{k (cid:62) 1 | P(ξ = k) > 0}, which reduces to the previous state space when P(ξ = 1) > 0.
We consider a speciﬁc ﬁnite graph structure over a sequence of consecutive regeneration
intervals, which implies that all initially present leaves are conﬁrmed. This structure can
easily be seen when ξ = r a.s. This regenerative DAG structure, for r = 3, is shown pictorially
in Figure 2. This state-space is explicitly described in Section 6.4.2.

Fig 2. Graph representation (in two ways) of regenerative block structure for the DAG process for the function
f2 when r = 3. Vertices before label 1 represent the graph before the beginning of the event being depicted. Here,
vertices 1, 2, 3 are conﬁrmed in the limit, when the time interval [10, 12] is a regeneration interval.

1.1. Time-Delay Graph

Given the delay sequence ξ = (ξt)t(cid:62)0, we construct a time-delay graph on the vertex set Z+
as follows. Each vertex i (cid:62) 1 connects to vertex (i − ξi)+; and vertex 0 has out-degree 0.

341526789101112341526789101112Dey & Gopalan/Asynchronous Composition Model

5

The time-delay graph is always a tree. When the period d of the support of ξ is greater
than 1, this tree has d ends. Otherwise, it is one-ended. Note that the in-degree of a vertex
in the time-delay graph depends on future times, so stopping time-based arguments are not
applicable. However, when E ξ < ∞ and P(ξ = 1) > 0, we show in Corollary 3.2 that there are
inﬁnitely many “regeneration times”; these times correspond to “synchronization moments”
in a more descriptive network model such as the one in [16]. Regeneration time corresponds
to all vertices t0 in the time-delay graph such that there are no edges between vertices to the
left and the right of t0. See ﬁgure 3 for a simulated time-delay graph.

Fig 3. A sample time-delay graph, with linear and tree representation, respectively, with Geometric(1/2) delay.
The regeneration times are given by red vertices. The third graph is ACM with Nakamoto construction function
built with the given delay process (red vertices represent anchor vertices).

We show that the graph process at the regeneration times deﬁnes a Markov chain on B∗.
When this graph has its edges reversed, the regeneration times correspond to renewals or
vertices such that any inﬁnite path leading away from 0 passes through said vertices. This
process with the reversed edges is studied more carefully by Baccelli and Sodre [5].

When P(ξ = 1) = 0 with E ξ < ∞, we do not have the existence of any regeneration
times; however a similar analysis can be carried out with “regeneration intervals” of length
r := min{i | P(ξ = i) > 0}. See ﬁgure 4 for a simulated time-delay graph with r = 2.

1.2. Relevance to Blockchain

Blockchain protocols are a new class of network consensus protocols that were introduced by
Nakamoto’s Bitcoin whitepaper [20]. Each node in the network creates new data, called blocks,
and the nodes exchange these blocks through pairwise communication [16, 14, 15, 13] with
the goal of network-wide synchronization. This communication is subject to potentially un-
bounded delay.

The blocks correspond to vertices in a DAG; each vertex has an out-degree at least one.
The choice of the outgoing edges is a form of distributed trust; see [20, 16, 9] for more details.

Dey & Gopalan/Asynchronous Composition Model

6

Fig 4. A sample time-delay graph, with linear and tree representation, respectively, with 1+Geometric(1/2)
delay. The regeneration intervals are given by red vertices. The third graph is ACM with f2 construction function
built with the given delay process (red vertices represent regenerative block structure for the DAG process).

A vertex, trusted by all network nodes, is called a conﬁrmed vertex. Under this terminology,
we can express the blockchain problem as follows.

Given a DAG, which vertices are conﬁrmed?

We defer our comments about conﬁrmed vertices until the end of this subsection for organi-
zational clarity.

When E ξ = ∞, inﬁnitely many vertices will connect to the vertices with mark 0. In
this situation, the distributed trust dynamics can be interpreted as a system that makes no
progress: for example, if there are only N nodes in the network, this situation corresponds to
nodes verifying some information more than once. Thus, the local ﬁniteness of the limit is a
crucial consideration for blockchain design.

Due to communication delay, at any time t, nodes may not be synchronized; thus, the
problem of achieving consensus on the set of conﬁrmed vertices is a complex issue. Recent work
(see [16]) shows that the asymptotic property of almost sure one-endedness of the blockchain
DAG allows nodes to agree on an inﬁnite subset of conﬁrmed vertices in the limit as time
t → ∞. Imprecisely, one-endedness is a topological property of an inﬁnite graph, implying
“growth to inﬁnity only in one direction.” This concept is closely related to ends in a general
topological space [11]. See Section 2.3 for a rigorous deﬁnition.

Thus, any eﬀectively designed blockchain protocol achieves eventual one-endedness in syn-
chronous and asynchronous operations, even though no real-world network can be genuinely
synchronous. This paper provides a general framework to analyze the asynchronous dynamics
of synchronously deﬁned blockchain protocols. Speciﬁcally, we abstract the network synchro-
nization problem to the behavior of the random variables ξ and the attachment of new vertices

Dey & Gopalan/Asynchronous Composition Model

7

to the blockchain DAG to the construction function f to isolate the DAG dynamics. To our
knowledge, this is the ﬁrst paper to isolate the DAG dynamics of general blockchain protocols.
While King [19] does study a related model that works only studies a restricted functional of
the graph process and not the process itself.

Many practical considerations, such as the security of blockchain implementation, inherently
depend on successful consensus dynamics and thus the guarantee of eventual one-endedness.
We hope that through a uniﬁed study of blockchain consensus dynamics, such considerations
can also be uniﬁed, rather than studied on a case-by-case basis, as is presently the state-of-
the-art (e.g. [9, 22]).

1.2.1. Conﬁrmed Vertices

In Nakamoto’s original Bitcoin whitepaper [20] and subsequent work on blockchain security
such as [9, 22], the deﬁnition of a “conﬁrmed” vertex is at least the k–th vertex on the
path from (one of) the furthest leaf (leaves) to the root. This deﬁnition holds only for the
construction function given in Nakamoto’s protocol.

There are several problems with this deﬁnition, many of which arise even in Nakamoto’s
Bitcoin protocol analysis. First, this deﬁnition refers to vertices as conﬁrmed, even if they
may eventually be “unconﬁrmed” due to the behavior of network delays (even without an
adversarial agent). Second, even if deﬁned for a particular construction function, the deﬁnition
of a conﬁrmed block should be invariant to the delay model. We note that network instability
(e.g., in the sense of instability of the Markov models studied by [16]; the same concept is a
key question in the analysis of queueing networks [6]) may lead to a limit graph with more
than one end. In this case, the previous notion of a conﬁrmed block includes vertices that
should not be conﬁrmed (and the set of “conﬁrmed” vertices is not monotone).

A similar situation also arises in this paper where the support of the delays ξ does not
include 1, despite the existence of regeneration intervals with ﬁnite expected inter-regeneration
lengths. The main diﬃculty with this deﬁnition is that conﬁrmation and one-endedness are
properties of limits of the process (thus, of an inﬁnite graph) which cannot be inferred from the
pre-limit process. Moreover, this deﬁnition does not readily generalize to other constructions.
Instead, we use the asymptotic deﬁnition of a “conﬁrmed vertex” given in Gopalan et
al. [16]: a vertex is conﬁrmed if all but ﬁnitely many future vertices reference it. This deﬁnition
resolves all of the issues mentioned above. Furthermore, an asymptotic approach to studying
conﬁrmation in such systems is more mathematically tractable.

1.3. Related Work

The time-delay model in our paper is closely related to the work of Baccelli and Sodre [5].
In their model, at each time t (indexed by Z), a new vertex marked t is added to a tree
with a directed edge to the vertex t + νt, where the (νt)t are i.i.d. One can think of this
graph as having edges pointing to the future. Note that when E ν1 < ∞, this process, with
reversed edges pointing to the past, uniquely determines the sequence ξ in our paper. We
called this new graph with reversed edges the time-delay graph. Their future edge direction
allows them to use stopping time methods to determine a renewal structure and study the
unimodularity of the resulting tree. In the delay graph process, the regeneration times are not
stopping times, which adds additional diﬃculty to the analysis. Moreover, the asynchronous

Dey & Gopalan/Asynchronous Composition Model

8

composition model constructs graphs and trees with a more complicated structure, and we
cannot immediately use their results to analyze our limiting graphs. The caveat to a more
complicated analysis is that the time-delay graph as speciﬁed in our model more realistically
captures delay dynamics in an internet network system, where diﬀerent nodes in the network
will learn of a piece of data at diﬀerent times. This is achieved with our time-delay graph,
whereas with edges pointing to the future, all nodes learn of any given data instantly. In
Section 2.6, we mention a generalization of the ACM model combining both forward and
backward delays.

In our model, recurrence of “regeneration intervals” in the time-delay graph plays a crucial
role in deﬁning a Markov chain for the actual DAG dynamics. Regenerative analysis for
graphs based on the one-dimensional integer lattice is already present in the random growth
model literature. For example, in the long-range last–passage percolation on the real line [12],
long-range ﬁrst–passage percolation in the one dimension case [8], among others.

King [19] studies the function f2, which is in the main class of functions of interest in this
paper. As with the work of Baccelli and Sodre [5], the delay graph in [19] has edges pointing
to the future; but in [19] the delays are a ﬁxed constant. This particular case is the same as
setting ξt = k in our model for some ﬁxed k, for all times t. The author proves the existence
of a stationary distribution for the number of leaves in the limit graph for this function. In
the particular case of that paper, we note that this result implies one-endedness of the limit
graph, but the author does not consider the topology of the limit graph. In this paper, along
with our emphasis on the topological properties of the limit graph, we consider a more general
process with random delays.

As with many stochastic growth models, our analysis is concerned with studying limiting
behavior in space and time. We brieﬂy contrast the model in this paper with those in other
well-studied classes of problems, such as preferential attachment model, percolation, and uni-
modular random graphs. Our recursion in equation (1.1) closely resembles the dynamics of
preferential attachment when the delays ξ are equal to one. However, we note that the model
with random delays is not well-studied, and the analysis requires diﬀerent techniques.

In addition, unlike in preferential attachment and percolation, where the goal is to study
the local graphical structure and the number of connected components, we study the (topo-
logical) end structure of the limiting graph, which cannot be directly inferred from the local
properties. Both the delay and the study of the end structure are motivated by the blockchain
application [16]. Finally, recent work on unimodular random graphs [3] studies the end struc-
ture of stochastic growth processes on a class of trees. The models in those papers do not
directly incorporate delays, and thus, the analysis does not apply to our problem. Also, our
problem statement and primary analysis are concerned with DAGs and are not restricted to
trees.

Analysis of asymptotic properties of limiting inﬁnite graphs has also been used to study
convergence properties for opinion dynamics in social networks [1]. In this paper, the main
question about the limit graph is whether every ﬁnite subgraph has ﬁnite in-degree. This
condition is related to but not necessarily equivalent to the end structure we study in this
paper. However, as discussed above, the limiting end structure is of key importance in the
blockchain context.

Dey & Gopalan/Asynchronous Composition Model

9

1.4. Organization of the Paper

The paper is structured as follows. In Section 2, we state our main results and the requisite
deﬁnitions which we use in this paper. We also describe our notations there. In Section 3, we
discuss the regenerative behavior of the time-delay graph. We discuss some examples of asyn-
chronous composition in Section 4. In Sections 5 and 6, we prove the statements concerning
the regenerative behavior in the time-delay graph and our main results, respectively. Finally,
in Section 7, we discuss our results and some directions for future work.

2. Deﬁnitions and Main Result

For the rest of this paper, the term graph always refers to a directed acyclic graph (DAG).

2.1. Assumptions

We use ξ and θ to refer random variables distributed identically to ξ1 and θ1, respectively, for
clarity of presentation. We will assume the following throughout the rest of the article:

• P(ξ (cid:62) 1) = 1 and E ξ1+δ < ∞ for some δ > 0,
• θ ∼ Uniform([0, 1]).

2.2. Notations

For the rest of the article, we will follow the notations enumerated below for easy reference.

• For any real numbers x, y, we denote:

x ∧ y = min(x, y); x ∨ y = max(x, y); x+ = x ∧ 0; x− = (−x) ∧ 0.

• For a graph G = (V, E), we use the notation u → v if there is a directed path from
the vertex u to the vertex v in G. It is clear from the deﬁnition of the asynchronous
composition model that for any vertex u, u (cid:54)→ u.

• B(cid:63)(B(cid:63)) denote the set of all rooted, connected DAGs with ﬁnitely (inﬁnitely) many

vertices.

ξj) for 1 (cid:54) i (cid:54) j (cid:54) ∞.

• ξ := (ξt)t(cid:62)1 is the i.i.d. driving sequence of delays. We use the notation ξj

i := (ξi, ξi+1, . . .,

• θ := (θt)t(cid:62)1 is the i.i.d. driving sequence for the randomness at any instant. We use the

notation θj

i := (θi, θi+1, . . . , θj) for 1 (cid:54) i (cid:54) j (cid:54) ∞ and

f t(G; θt

1, ξt

1) := Gt where Gt = Gt−1 ∪ f (G(t−ξt)+, θt),

t = 1, 2, . . .

for any G ∈ B∗.

• Ft := σ(ξ1, . . . , ξt, θ1, . . . , θt) is the σ-algebra generated by the trajectories up to time t.
• If needed, we will use the notation Gt(f ) instead of Gt to emphasize that the asyn-

chronous composition is with respect to the function f .

• We denote by (τk)k(cid:62)1 the sequence of regeneration times as given in Deﬁnition 2.13, with
τ1 (cid:62) 0 being the ﬁrst regeneration time after time 0. We denote by (˜τk)k(cid:62)0 the sequence
of instants at the beginning of regeneration intervals, as given in Deﬁnition 2.14

Dey & Gopalan/Asynchronous Composition Model

10

• We denote by γi := τi+1 − τi and ˜γi := ˜τi+1 − ˜τi for i (cid:62) 1.
• We will use the calligraphic letter At to denote a set at time t, and the corresponding
roman letter At to denote the cardinality of that set. We will use the corresponding
notation ˆAk = Aτk to denote the same set at the k-th regeneration time, along with
the corresponding notation ˆAk. We also use the notation ˜Ak = A˜τk to denote the same
set at the ﬁrst instant of the k-th regeneration interval, along with the corresponding
notation ˆ˜Ak.

• We introduce the following:

– L(G) denotes the set of leaves (nodes with out-degree one) in the graph G, and

L(G) its size.

– It,s := L(Gs) ∩ L(Gt)c for t (cid:62) s, is the set of leaves at time s which are not leaves

at time t. It,s is the size of It,s.

• We will use the shorthand Lt, Lt for L(Gt), L(Gt), respectively. Similarly, we will use

ˆLk, ˆLk, ˜Lk, ˜Lk for L(Gτk ), L(Gτk ), L(G˜τk ), L(G˜τk ), respectively.

2.3. Inﬁnite Graphs

A graph G = (V, E) is inﬁnite if V is inﬁnite. An inﬁnite graph G is locally ﬁnite if all vertices
v ∈ V have ﬁnite degree.

We deﬁne B(cid:63) as the set of all rooted, locally ﬁnite, connected DAGs. Clearly, B(cid:63) ⊆ B(cid:63).
However, the notion of endedness is only relevant for inﬁnite graphs. We make the idea precise
below. We deﬁne a ray as a semi-inﬁnite directed path in an inﬁnite graph G ∈ B(cid:63).
Deﬁnition 2.1 (See [17]). Two inﬁnite rays p1 and p2 in G are equivalent if there exists a third
inﬁnite ray p3 such that |p1 ∩ p3| = |p2 ∩ p3| = ∞, where the intersection is taken over vertices.

Lemma 2.2. Two inﬁnite rays p1 and p2 in G are equivalent iﬀ for any ﬁnite subgraph S
containing the root which only has a single component, the following holds: for any vertices
v1 ∈ G \ S and v2 ∈ G \ S are on p1 and p2, respectively, there exists a vertex v3 ∈ G \ S such
that there is a directed path from v3 to v1 and a directed path from v3 to v2.

Proof of the above lemma follows easily from standard arguments (see [10]). Being equiv-
alent deﬁnes an equivalence relation on the set of inﬁnite rays in G. Note that Deﬁnition 2.2
is analogous to constructing ends in a general topological space by using the compact-open
topology.
Deﬁnition 2.3 (See [17]). The graph G is n-ended if the equivalence relation in Deﬁnition 2.1
separates inﬁnite rays of G into n equivalence classes; each class is called an end. If there is
only a single equivalence class, G is one-ended. If there are no inﬁnite rays, G has 0 ends.

Observe that the deﬁnition of ends can be extended such that any ﬁnite graph has 0 ends.
Moreover, due to K¨onig’s Lemma, any locally ﬁnite inﬁnite graph has at least one end. From
this deﬁnition, it is clear that the number of ends in an inﬁnite graph cannot be inferred from
the properties of any ﬁnite subgraph.

We endow B(cid:63) with the metric d∗, deﬁned as follows.

Deﬁnition 2.4 ([3, Chapter 2]). The function

d∗(G1, G2) :=

1
1 + s

Dey & Gopalan/Asynchronous Composition Model

11

where s is the supremum of all integers such that the s–balls w.r.t. the hop distance centered
at the roots of G1 and G2 agree, is a metric on B(cid:63).

It is easily checked (see [3]) that B(cid:63) is a complete metric space. All limits in this paper are
in B(cid:63). For the rest of this paper, we will denote by G0 the graph consisting of a single root
vertex marked 0 and no edges.

Deﬁnition 2.5. The synchronous limit is given by

f ∞(G0; θ, 1) := lim
n→∞

f n(G0; θn

1 , 1)

where the limit is w.r.t. the d∗ metric.

For all functions considered in this paper, the existence of the synchronous limit is imme-

diate, and we omit proofs for brevity.

Deﬁnition 2.6. The asynchronous limit is given by

G∞(f ) := lim
t→∞

Gt(f ) = lim
t→∞

f t(G0, θt

1, ξt

1),

where the limit is w.r.t. the d∗ metric.

Observe that the synchronous limit is the particular case of the asynchronous limit when

ξt ≡ 1 for all t (cid:62) 1.
Deﬁnition 2.7. The function f is k-ended if f ∞(G; θ∞, 1) is k-ended for any ﬁnite G ∈ B(cid:63).

2.3.1. Inﬁnite Graphs and Blockchain

A vertex v in the (synchronous or asynchronous) limit of the function f is conﬁrmed if w → v
for all but ﬁnitely many w > v. We state a lemma from [16] which identiﬁes crucial properties
of limiting blockchain graphs. In the interest of self-containedness, we include proof of this
lemma.

Lemma 2.8 ([16, Lemmas 3.4 and 3.5]). If a locally ﬁnite inﬁnite graph G is one-ended,
then it has inﬁnitely many conﬁrmed vertices. Conversely, if G has inﬁnitely many conﬁrmed
vertices, then there is a one-ended subgraph of G which contains all of the conﬁrmed vertices.

Proof. Suppose that G is one-ended. Fix any inﬁnite ray p1; we will show that each vertex
contained in p1 is conﬁrmed. For any other inﬁnite ray p2, we have a ray p3 which intersects
both p1 and p2 inﬁnitely often. This implies that for any vertex v in p1, all but ﬁnitely many
vertices in p2 have a path to v. This part of the result then follows since G is locally ﬁnite.

Next, suppose that G has inﬁnitely many conﬁrmed vertices and denote by ˆG the subgraph
(cid:4)

of the conﬁrmed vertices. The result follows immediately from Deﬁnition 2.2.

We note that, a spanning tree for a graph G is a subgraph G(cid:48) = (V, E(cid:48)), where E(cid:48) ⊆ E, the
root in G(cid:48) is the same as the root in G, and each (non-root) vertex in G(cid:48) has a unique path
to the root. We add the following easy corollary, which is a new result:

Corollary 2.9. A locally ﬁnite inﬁnite graph G has inﬁnitely many conﬁrmed vertices iﬀ it
has a one-ended spanning tree.

Dey & Gopalan/Asynchronous Composition Model

12

In practice, it is far easier to check the one-endedness of a graph than to establish the exis-
tence of a one-ended spanning tree. So we do not use the corollary even if it expresses a tighter
condition for the existence of inﬁnitely many conﬁrmed vertices. It follows from Lemma 2.8
that a critical question related to the design of blockchain systems is the determination of
which one-ended functions have one-ended asynchronous limits.

2.3.2. Some Technical Lemmas

The following technical lemmas are helpful in our analysis, and we put them here to simplify
the presentation later in the paper.
Lemma 2.10. Let (Tt)t be a sequence of ﬁnite trees with Tt ⊆ Tt+1 for all t (cid:62) 0. Suppose
the number of leaves is non-decreasing in t and diverges to inﬁnity, and that any leaf in Tt is
such that for some s > t, that leaf is not a leaf in Ts. If T := limt→∞ Tt exists in B(cid:63), then T
has inﬁnitely many ends.

Proof. Fix any graph Tt. Any leaf in Tt is part of an inﬁnite path in T . Thus, if there are k
leaves in Tt, then T has at least k ends. The result follows since the number of leaves in Tt
(cid:4)
tends to inﬁnity.

Lemma 2.11. Let T ∈ B(cid:63) be an inﬁnite tree. T is one-ended iﬀ it has inﬁnitely many
conﬁrmed vertices.

Proof. If T is one-ended, then it has inﬁnitely many conﬁrmed vertices by Lemma 2.8. Suppose
T has inﬁnitely many conﬁrmed vertices. Since T is a tree, there exists an inﬁnite path p
consisting of conﬁrmed vertices. However, since T is a tree, all inﬁnite paths must intersect p
(cid:4)
inﬁnitely often.

From the deﬁnition of one-endedness, it follows easily that for an inﬁnite graph G, G is

one-ended iﬀ any two rays are equivalent.

Lemma 2.12. Let G ∈ B(cid:63) be an inﬁnite graph. Suppose that there is an inﬁnite sequence of
vertices (vi)i such that any inﬁnite path passes through vi for all i. Then G is one-ended.
Proof. In this case, all rays are clearly equivalent. The result follows from the deﬁnition. (cid:4)

In Lemma 2.12, the vertices in the sequence (vi)i can be thought of as anchor vertices.

2.4. Deﬁnitions for the Delay Process

For the rest of this paper, we denote by

r := min
n∈N

{n : P(ξ = n) > 0}

(2.1)

the minimal point in the support of ξ. The following deﬁnitions provide an important struc-
tural framework for our analysis.
Deﬁnition 2.13. An integer t (cid:62) 0 is a regeneration time for the delay sequence (ξs)s(cid:62)0 if ξt = 1
and ξt+s (cid:54) s for all s (cid:62) 1.

Dey & Gopalan/Asynchronous Composition Model

13

Note that, t is a regeneration time iﬀ 1 (cid:54) ξt+s (cid:54) s ∨ 1 for all s (cid:62) 0. For regeneration time
to exist, clearly we need P(ξ = 1) > 0 or r = 1. In the general case, we deﬁne “regeneration
interval” of length r as follows.
Deﬁnition 2.14. The interval [t, t + r) is a regeneration interval if ξt+s = r for s ∈ [0, r) and
ξt+s (cid:54) s for all s (cid:62) r.

Here also, note that t is the starting point of a regeneration interval iﬀ r (cid:54) ξt+s (cid:54) s ∨ r for
all s (cid:62) 0. Clearly, Deﬁnitions 2.13 and 2.14 agree when r = 1. It can be easily checked that
both regeneration times and regeneration intervals have the Markov property.

2.5. Main Results and Proof Highlights

We introduce the following functions which are the main focus of our analysis:

– fNak is the Nakamoto function, where a vertex is chosen uniformly from those at the

maximum hop distance from the root.

– In f1(G) a single leaf is chosen uniformly at random from G.
– For k (cid:62) 2, fk(G) chooses a uniformly selected set of k leaves from G if possible; otherwise

all leaves in G are chosen.

– In f∞(G) all leaves in G are chosen.
– We denote by f any random mixture of (fi)i(cid:62)1 such that P(f = f1) < 1.

It is clear that all of fNak, (fk)k(cid:62)1, f, f∞ have one-ended synchronous limits. In addition,
(fk)k(cid:62)2 and f, f∞ are one-ended functions, but f1 is not. Our main results are as follows. For
the remainder of this paper, the almost sure existence of limits is obvious and we omit proofs.
We begin with an analysis of the Nakamoto construction fNak, which is the canonical
construction for blockchain systems. It is easy to check that, Gt(fNak) is a tree for all t (cid:62) 1.
The asynchronous recursion given by

Xt = Xt−1 ∨ (1 + X(t−ξt)+), t (cid:62) 1,
X0 = 0

(2.2)

determines the length of the longest path from any leaf to the root or the height of the tree
at time t for fNak.
Theorem 2.15. Let χ be an integer-valued random variable with P(χ (cid:62) k) = (cid:81)k
for k (cid:62) 1. We have,

P(ξ (cid:62) i),

i=1

Xt
t

a.s.−−→ λ :=

1
E(χ)

and

1
√
t

· (Xt − λt)

(d)
−−→ N(0, λ3 Var(χ))

as t → ∞. Furthermore, 1
as n → ∞. Deﬁne

n X(cid:98)nt(cid:99) → λt converges uniformly a.s. on the compact subsets of R+

Zn(t) := n−1/2 · (X(cid:98)nt(cid:99) − λnt), t (cid:62) 0.

Then Zn(·) w−→ Z(·), which is a zero-drift Brownian motion with variance parameter λ3 Var(χ).
Remark 2.1. Note that, in Theorem 2.15 the random variable χ has moments of all order as
P(χ (cid:62) k) (cid:54) P(ξ (cid:62) k)k (cid:54) (E ξ/k)k for all k (cid:62) 1.

Dey & Gopalan/Asynchronous Composition Model

14

Remark 2.2. When ξ ∼ Geometric(p) with P(ξ = k) = pqk−1, k (cid:62) 1, we have P(χ (cid:62) k) =
(cid:81)k
i=1 qi−1 = qk(k−1)/2, k (cid:62) 1. Thus, in this particular example, the asymptotic growth rate of
the longest chain in Theorem 2.15 is given by λ = 1/ (cid:80)∞
k=1 qk(k−1)/2. This is related to the
Jacobi Theta Functions. It is an interesting question on how to estimate q based on the chain
length from sample observations.

It is easy to biject the instants when Xt increases by exactly one with the conﬁrmed
blocks in G∞(fNak). Thus, the recursion 2.2 also characterizes the fraction of blocks which
are conﬁrmed in the asynchronous limit.

To prove the ﬁrst statement, we note that the intervals in which the process Xt is constant
have i.i.d. durations, since they depend solely on the i.i.d. delays ξ which occur after the
moment of any increment. If an increment occurs at time s, the next increment occurs at the
ﬁrst instant when t − ξt (cid:62) s; from this fact it is easy to compute the expected duration for
a constant segment of the trajectory of Xt; the result follows by applying the strong law of
large numbers. The second, third, and fourth convergence results in Theorem 2.15 follow from
the renewal central limit theorem, the functional strong law of large numbers, and Donsker’s
theorem for renewal processes, respectively.

Theorem 2.16. The asynchronous limit of fNak exists and is one-ended, almost surely.

Note that if there are two regeneration intervals beginning at times t and t + r − 1, then
there are also regeneration intervals beginning at all times in [t + 1, t + r). An increment to
the height process Xt almost surely occur in the interval [t, t + r) at, say t∗. With probability
uniformly bounded away from 0 each of r consecutive vertices connect to the same given
vertex chosen at the time t∗ of the increment of Xt. The vertex added at time t∗ will be
conﬁrmed in the limit. Moreover, this event happens inﬁnitely often. Thus, the asynchronous
limit exists and is one-ended. Moreover, from the analysis it will be clear that the limiting
DAG G∞(fNak) is a tree with an inﬁnite spine (containing the conﬁrmed vertices) and with
ﬁnite trees hanging from each vertex in the spine.

Moreover, if we enumerate the vertices in C := {t (cid:62) 1 | Xt − Xt−1 = 1, t is the starting time
of a regeneration interval of length 2r} as 0 < v1 < v2 < · · · , we have i.i.d. block structure in
between two consecutive vertices [vi, vi+1) in C. We can call the vertices in C, anchor vertices.
See ﬁgure 3 (third picture) for a simulated graph with vertices in C marked in red.

Next, we present the results for fk, k (cid:62) 1 and their mixtures.

Theorem 2.17. The asynchronous limit G∞(f1) exists and has inﬁnitely many ends, almost
surely. Furthermore, the expected number of leaves in Gt(f1) is ΘP(t1/2).
Remark 2.3. One can guess from the results of the above Theorem 2.17 that t−1/2·Lt converges
in distribution to some non-trivial limit as t → ∞; however, we do not pursue this result here.

The end structure in Theorem 2.17 is as follows. When r = 1, at the regeneration times,
the functional describing the number of leaves is a non-decreasing Markov chain which tends
to inﬁnity almost surely. The result follows since the limit must be a tree. A similar analysis
holds for r (cid:62) 2, as the limit is also a tree here.

The growth rate follows by examining the second moment of the number of leaves. We ﬁrst
show that E(Lt+1 −Lt | Ft) ≈ 1/Lt; from which it follows that E(L2
t | Ft) is of constant
order. Finally, an upper bound follows from induction and Jensen’s inequality; a lower bound
follows immediately from the upper bound.

t+1 −L2

Dey & Gopalan/Asynchronous Composition Model

15

For fk with k (cid:62) 2 or f being a mixture of fk’s with P(f = f1) < 1, we have the same

endedness behavior for the synchronous and the asynchronous model as stated below.

Theorem 2.18. The asynchronous limits G∞(fk) and G∞(f ) are one-ended, almost surely,
for k (cid:62) 2.

Remark 2.4. Limiting statements (similar to Theorem 2.15) about linear growth and distri-
butional and process limits of the height process can be proved for the construction functions
in Theorem 2.18; we omit the statements and proofs for brevity.

We brieﬂy highlight the connection between Theorems 2.17, 2.18 and other ﬁelds of study.
Namely, the relationship between the end structure of the asynchronous limits G∞(f1) and
G∞(f2) resembles a power-of-two result, often seen in queueing/scheduling and combinatorics.
The relationship between the end structure of G∞(f1) and G∞(f ) resembles the stabilizability
of an unstable system by an arbitrarily small control.

In the r = 1 case, the key step in the proof of Theorem 2.18 is an application of Foster’s
theorem [7] for the B(cid:63)-valued Markov chain given by the graph sequence at the regeneration
times. The number of leaves in the graph acts as a Lyapunov function and induces a N-valued
Markov chain. Stability implies that the induced Markov chain will hit the value 1 inﬁnitely
often, giving an inﬁnite sequence of conﬁrmed vertices.

More generally, if r (cid:62) 2, we work with the regeneration intervals. A similar analysis can be
done to prove inﬁnitely many occurrences of a a particular leaf geometry, which implies the
existence of inﬁnitely many conﬁrmed vertices.

Finally, existence and one-endedness of the limit follows easily from Lemma 2.12 when

r = 1 and the fact that any two inﬁnite paths are equivalent if r > 1.

Similar to the proof of Theorem 2.17, we show that the expected increment of the number
of leaves at any time is bounded above by a sub-linear function; the expected decrement is ob-
viously a positive constant. See ﬁgure 5 for a simulated graph with f = f2 and Geometric(3/4)
delay.

Fig 5. Conﬁrmed vertices (Blue) in the f2 case with Geometric(3/4) delay distribution.

When the composition function is graph dependent, one can prove a phase transition.

Dey & Gopalan/Asynchronous Composition Model

16

Theorem 2.19. Deﬁne

ˆfk,l :=

(cid:40)

fk w.p. α√
l
f1

otherwise.

For ﬁxed k (cid:62) 2, deﬁne the function g : B∗ × [0, 1] → B∗ such that g(·) = ˆfk,l(·) whenever the
argument has l leaves. There exist constants 0 < c1 < c2 < ∞ such that the asynchronous
limit of exists and is g is one-ended if α > c2 and has inﬁnitely many ends if α < c1, almost
surely.

This result follows quickly from combining the results of Theorems 2.17 and 2.18. Finally,

we will prove the following limiting commutative diagram behavior.

Theorem 2.20. The following diagram commutes

Gt(fk)

k→∞

Gt(f∞)

t→∞

t→∞

G∞(fk)

k→∞

G∞(f∞)

where the convergence holds in the sense of distributional convergence in the space (B∗, d∗).
Moreover, with coupled delays, the convergences are almost sure if E ξ1+δ < ∞ for some δ > 0.

This result follows from the following key observation. Suppose that at some regeneration
time t, that there is only 1 leaf in the graph Gt(f∞) – call such a moment a special time.
Let k = kt be the maximum number of leaves in the sequence L1, L2, . . . , Lt. Then, we have
Gt(fj) = Gt(f∞) for all j (cid:62) k. Clearly, this value kt is non-decreasing function of t; the result
follows as there are inﬁnitely many special times.

2.6. Model Generalization

We note that our results hold in a special case of the following generalization of the model. This
model is based on combining the “forward” delays of Baccelli and Sodre [5] and King [19], with
the “backward” delays in our model. In an application context, the forward delays represent
the computation time required to create a new block and the backward delays represent the
time required to access data.

Denote by (νt)t a sequence of i.i.d. N-valued random variables with irreducible support

(gcd({n ∈ N : P(ν1 = n) > 0}) = 1). We assume that E ν1 < ∞ and deﬁne

Gt = Gt−1 ∪ f (G(t−ξt)+),
where G(t−ξt)+ is a subgraph of G(t−ξt)+ which consists of those vertices s such that s + νs (cid:54)
(t − ξt)+. This corresponds to the vertex t taking νt units of time to be created, and then to
begin propagating, which is more realistic in the blockchain application context.

The “forward” delay process connecting t to t + νt for t (cid:62) 1 has renewals which are
stopping times. When P(ξ = 1) > 0, all of our results hold as-is since the intersection of
independent renewal processes is again a renewal process with well understood gap distribution
(see [4]), and since the regeneration times posses the required Markov property. We speciﬁcally
point out the diﬀerence in the requirements on ν1 and ξ1 for this setting: for ν1, we require
irreducibility of the support, but for ξ1, we require only information about its minimum value.
For the more general situation, see the comments in Section 7.

Dey & Gopalan/Asynchronous Composition Model

17

3. Regenerative Behavior

Recall our standing assumption that E ξ < ∞. Here we will analyze structure of the time-
delay graph depending on whether P(ξ = 1) > 0 or not. In the ﬁrst case, we will prove
existence of inﬁnitely many pivotal points or “regeneration points” giving linear structure for
the time-delay graph. In the second case, there is almost surely no regeneration points. In
fact, depending on the g.c.d. of Supp(ξ) the time-delay graph can have a periodic structure.
However, we will show that there exists inﬁnitely many “regeneration intervals”, disconnecting
the future from the past. The regenerative structure is one crucial ingredient for the subsequent
analysis for the ACM.

3.1. Regeneration Times: P(ξ = 1) > 0

We deﬁne Et := (cid:84)
delay random variables (ξs)s(cid:62)0 are i.i.d. ∼ ξ. Thus, we have for all t (cid:62) 0

s(cid:62)0{ξs+t (cid:54) s ∨ 1} as the event that t is a regeneration time. Recall that the

P(Et) = q := P(ξ = 1)

∞
(cid:89)

s=1

P(ξ (cid:54) s).

Note that, q > 0 as P(ξ = 1) > 0 and E ξ = (cid:80)∞
s=0
We also deﬁne

P(ξ > s) < ∞. We will use α := P(ξ = 1).

Nn :=

n
(cid:88)

t=0

1Et

as the number of regeneration points in the time interval {1, 2, . . . , n}. We can compute the
mean and variance of Nn easily.
Lemma 3.1. Assume that P(ξ = 1) > 0 and E ξ < ∞. Then E Nn = nq for all n (cid:62) 1 and
n−2 Var(Nn) → 0 as n → ∞.

If we assume that E ξ2 < ∞, then it follows from the proof that n−1 Var(Nn) converges
to a constant as n → ∞. But, we do not need this result for our analysis. As an immediate
corollary of Lemma 3.1 we get the following result.

Corollary 3.2. There exist inﬁnitely many regeneration times, almost surely.

Proof. It is easy to see that (Nn)n(cid:62)1 is an increasing sequence of random variables converging
a.s. to some integer-valued random variable N∞, which can possibly take the value ∞. Using
Lemma 3.1 and Chebyshev’s inequality we have for any ε > 0

P (|Nn/n − q| > ε) (cid:54) Var(Nn)/ε2n2 → 0 as n → ∞.

Thus Nn/n → q in probability as n → ∞. Since q > 0, this proves that N∞ = ∞ a.s.

(cid:4)

The following corollary follows from similar arguments to above; we omit the proof.

Corollary 3.3. There exist inﬁnitely many regeneration times (Ti)i such that Ti + 1 is also
a regeneration time, almost surely.

Dey & Gopalan/Asynchronous Composition Model

18

Denote by

0 (cid:54) τ1 < τ2 < · · · < · · ·

an increasing enumeration of all the regeneration points in the interval {0, 1, 2, . . . , ∞}.

We consider a more general delay process for all times t ∈ Z, from which the system
dynamics at all times t ∈ Z+ are uniquely determined. Speciﬁcally, let (ξi)i∈Z be i.i.d. We
denote by

Jt := (t − ξt, t) ⊆ Z

for all t ∈ Z. Denote by A := ∪t∈ZJt. It follows that the random set Z \ A := {. . . < τ−1 <
τ0 < 0 (cid:54) τ1 < . . .} is such that

γk := τk+1 − τk
are i.i.d. for all k ∈ Z. For k (cid:62) 1, the times τk are precisely the regeneration times from the
time-delay process.
Lemma 3.4. The random variables (γk)k(cid:62)1 are i.i.d. with E γ1 = 1/q. Moreover, if E ξk < ∞
for some k (cid:62) 2, then E γk

1 < ∞.

Proof. The fact that (γk)k(cid:62)1 are i.i.d. mainly follows from the fact that conditional on the
event Et = {t is a regeneration time}, (ξt+s)s(cid:62)1 is distributed as independent ( ˆξs)s(cid:62)1 where
ˆξs

d= (ξ | ξ (cid:54) s), s (cid:62) 1 and that the event Et depends only on the future, (ξs)s(cid:62)t.
For an event A0,s depending only on ξi, i ∈ (0, s], we write At,s when the random variables
ξi, i ∈ (0, s] are replaced by ξt+i, i ∈ (0, s]. Fix 0 (cid:54) t1 < t2 < . . . < tk and events A(i)
, i (cid:62)
1. We also use ˆP to denote P(· | E0), i.e., the case when ξt, t (cid:62) 1 is replaced by independent
ˆξt

d= (ξ | ξ (cid:54) t). Thus we have

ti,ti+1−ti

P(τ1 = t1, τi+1 = ti, A(i)

ti,ti+1−ti

, 1 (cid:54) i < k)

= P(τ1 = t1) · ˆP(τi = ti+1 − t1, A(i)

ti−t1,ti+1−ti

, 1 (cid:54) i (cid:54) k − 1).

By induction, this equals

P(τ1 = t1) ·

k−1
(cid:89)

i=1

ˆP(τ1 = ti+1 − ti, A(i)

0,ti+1−ti

).

This proves the i.i.d. structure for (γk)k(cid:62)1.

From the independence result, it follows that at the regeneration times, the graph Gτk
satisﬁes the Markov property. The fact that E γ1 = 1/q follows from the renewal theorem.
Finally, the second part of this lemma follows from the following Propositions 3.5 and 3.6. (cid:4)
Proposition 3.5. E γβ

1 < ∞ iﬀ E τ β−1
1 < ∞, for any ﬁxed β (cid:62) 1.
1 < ∞ if E ξβ < ∞, for any ﬁxed β (cid:62) 1.
Proofs of Propositions 3.5 and 3.6 are given in Sections 5.2 and 5.3, respectively.

Proposition 3.6. E τ β−1

Dey & Gopalan/Asynchronous Composition Model

19

3.2. Regeneration Intervals: P(ξ = 1) = 0

In this case we consider the more general setting where P(ξ = 1) (cid:62) 0; for which it suﬃces to
assume that P(ξ = 1) = 0. This case can be interpreted as allowing the minimum delay to be
greater than 1. Similar results hold for regeneration intervals as for regeneration times, which
we state next; for brevity we omit the proofs. Deﬁne

˜Et :=

(cid:92)

{ξt+s = r}

s∈[0,r)

(cid:92)

s(cid:62)r

{ξt+s (cid:54) s} =

(cid:92)

{ξt+s (cid:54) s ∨ r}

s(cid:62)0

to be the event that the interval [t, t + r) is a regeneration interval. Since the (ξi)i are i.i.d.
we have

Similar to above, we deﬁne

since E ξ < ∞. We deﬁne

P( ˜Et) :=

(cid:89)

s(cid:62)0

P(ξ (cid:54) s ∨ r).

˜q :=

(cid:89)

s(cid:62)0

P(ξ (cid:54) s ∨ r) > 0,

˜Nn :=

n
(cid:88)

t=0

1 ˜Et

as the number of regeneration windows in the ﬁrst n + 1 segments.
Lemma 3.7. E ˜Nn = n˜q for all n (cid:62) 1 and n−2 Var( ˜Nn) → 0 as n → ∞.

In what follows we refer to regeneration windows by the ﬁrst time in those windows; this

is without loss of generality by the construction of the segmented time.

Corollary 3.8. There exist inﬁnitely many regeneration windows, almost surely.

We denote by (˜τk)k(cid:62)1 the sequence of times such that [˜τk, ˜τk + r) are regeneration intervals.

Corollary 3.9. There exists inﬁnitely many times (Ti)i such that [Ti, Ti+r) and [Ti+r, Ti+2r)
are both regeneration intervals, almost surely.
Lemma 3.10. The random variables (˜γi)i(cid:62)1 are i.i.d. with E ˜γ1 = 1/˜q. Moreover, if E ξk < ∞
for some k > 1, then E ˜γk

1 < ∞.

Lemma 3.10 follows from an identical argument to Lemma 3.4, which can be seen as follows.
Indeed, suppose that time is “pre-chunked” into intervals [rk + a, r(k + 1) + a), where k ∈ Z
and a is ﬁxed. Indeed, on these chunks, the previous argument holds to identify regeneration
windows; the result follows since ξ is i.i.d. and a is arbitrary.

4. Applications

4.1. Nakamoto Function fNak

It is clear that the synchronous and asynchronous limits of the Nakamoto construction are
inﬁnite trees.

Dey & Gopalan/Asynchronous Composition Model

20

Lemma 4.1. Almost surely, the asynchronous limit of the Nakamoto construction exists and
is one-ended.

Proof. Here we give a direct proof for the r = 1 case. The general case is stated in Theo-
rem 2.16. From Corollary 3.3, we know that there are inﬁnitely many pairs of consecutive
regeneration times; it is easy to see that the ﬁrst vertex added in any of these pairs will be al-
most surely conﬁrmed as t → ∞. If this vertex is at distance s from the root, the s-ball around
the root is ﬁxed henceforth so the limit exists. Then, the result follows from Lemma 2.11. (cid:4)

4.2. Bounded Functions

Deﬁnition 4.2. A construction function f : B∗ × [0, 1] → B∗ is bounded if there exists b ∈ N
such that all new edges in f (G, u) terminate at vertices of mark at least

k := sup

{mark(v)} − b.

v∈V (G)

The following assumption states the contextual requirement that in the absence of delay,

every (non-zero) block should be conﬁrmed:

Assumption 4.3. For any function used in a blockchain, every non-zero vertex is conﬁrmed
in the synchronous limit.
Lemma 4.4. Let f be a one-ended bounded function satisfying Assumption 4.3 and P(ξ =
1) > 0. Then, almost surely, the asynchronous limit G∞(f ) exists and is one-ended.

To prove Lemma 4.4, we need the following proposition.

Proposition 4.5. Let f be a one-ended bounded function and let b be the associated bounding
constant. Then, in the synchronous limit, each vertex v > b is such that for any vertex u of
mark at most v − b − 1, there is a directed path v → u.

Proof. Follows immediately from Assumption 4.3 and the fact that f is one-ended.

(cid:4)

Proof of Lemma 4.4. Let b be as in Deﬁnition 4.2. Let Rt be the event which occurs if ξt =
. . . = ξt+4b−1 = 1 and t + 4b − 1 is a regeneration time.

Observe from the mutual independence of the (ξt)t that P(Rt) = P(ξ = 1)4b−1 P(Et), which
is bounded away from 0. Recall from Corollary 3.3 the almost sure existence of an inﬁnite
sequence of times (tk)k such that the event Rtk occurs.

Any vertex arriving at or after time tk with an edge to a vertex in Gtk−1 must arrive before
tk + b. Since supk(k − bk) (cid:54) b, no vertex arriving after time tk + 4b − 1 has an edge to any
vertex arriving before time tk +2b. In particular, all such vertices arriving after time tk +4b−1
have a path to vertex tk + 2b. Similarly, supk(k − bk) (cid:54) b implies that the vertex tk + 2b has
a path to all vertices in the set tk, tk + 1, . . . , tk + b − 1. Thus, vertex tk + 2b has a path to all
vertices older than tk which lie on an inﬁnite ray ending within G0. Hence, the vertex tk + 2b
is almost surely conﬁrmed.

The almost sure existence and one-endedness of the limit follows from Lemma 2.12.

(cid:4)

Dey & Gopalan/Asynchronous Composition Model

21

4.3. A Two-Ended Function with a One-Ended Asynchronous Limit

We show the (perhaps surprising) fact that the number of ends in the asynchronous limit need
not dominate the number of ends in the synchronous limit.

We consider the construction f , which behaves as follows. The construction f is independent
of the driving sequence so we omit the driving random variables below. Below, we use the
notation that f n(·) is the n-th iterate of asynchronous composition. For a DAG G0 ∈ B∗,
f (G0) gives the vertex marked with (m − 1)+ where m is the largest mark in G0.

It is clear that the synchronous limit f t(G0) is two-ended as t → ∞ because of the periodic
structure. However, the asynchronous limit can be one-ended. A similar example can be
constructed for any period d (cid:62) 2.
Lemma 4.6. Assume that, P(ξ = 1) P(ξ = 2) > 0. Almost surely, the asynchronous limit
G∞(f ) exists and is one-ended.

Proof. We show the existence of an inﬁnite sequence of conﬁrmed vertices, and conclude via
Lemma 2.12. Indeed for t (cid:62) 3, consider the event that ξt = 1, ξt+1 = 2, and time t + 2 is a
regeneration time. From Corollary 3.3, this event occurs almost surely for inﬁnitely many t.
If t is some such event where this event occurs, then all inﬁnite paths pass through the vertex
added at time t − 2; hence the vertex t − 2 is almost surely conﬁrmed as t → ∞. The result
(cid:4)
follows.

4.4. Asynchronous Limit of f1

In this subsection, we consider the number of ends in the asynchronous limit of the construc-
tion f1. The behavior of the asynchronous composition of f1 plays a key role in the proof of
our main result.

Lemma 4.7. Almost surely, the asynchronous limit G∞(f1) exists and has inﬁnitely many
ends.
Proof. Here we present the proof for the simple case when P(ξ = 1) P(ξ = 2) > 0. The general
case is considered in Theorem 2.17.

Let (τk)k(cid:62)1 be the sequence of regeneration times and recall that ˆLk := |L(Gτk )|. It suﬃces
to show that, almost surely, ˆLk → ∞ and every leaf in Gτk remains a leaf for only ﬁnitely
many time steps. The existence of the limit then follows from the fact that every vertex’s
degree is ﬁxed and ﬁnite after the ﬁrst regeneration time at which it is not a leaf; hence the
graph G∞ is locally ﬁnite as desired. For a locally ﬁnite inﬁnite tree, these two conditions are
equivalent to having inﬁnitely many ends; see Lemma 2.10.

We ﬁrst show that ˆLk → ∞ a.s. Indeed, suppose otherwise; hence limk→∞ ˆLk = L < ∞
with positive probability. Now, ﬁx an integer n ∈ N. It follows that P( ˆLk+1 − ˆLk > 0 | ˆLk =
n) (cid:62) ρ
n > 0, where ρ = P(τk+1 = τk + 1, ξτk+1 = 2). Thus, almost surely, L > n. It follows
that ˆLk → ∞ a.s. since n is arbitrary.

We now show that almost surely, any leaf in Gτk remains a leaf for only ﬁnitely many time
steps. Note that the leaf count process is non-decreasing and can increase by at most one in
consecutive time points. Fix some regeneration time τk and suppose that ˆLk = n. Fix any leaf
v ∈ L(Gτk ). The probability p that v remains a leaf for inﬁnitely many time steps is bounded
by p (cid:54) (cid:81)∞
(cid:4)

i=n(1 − 1/i) = 0. The result follows.

Dey & Gopalan/Asynchronous Composition Model

22

4.5. Asynchronous Limit of f∞

Lemma 4.8. Almost surely, the asynchronous limit of G∞(f∞) exists and is one-ended.
Proof. Here, we consider the case when P(ξ = 1) > 0. The general r proof follows essentially
the same idea presented in the f2 case. Recall from Corollary 3.3 that there are inﬁnitely
many pairs of consecutive regeneration times; obviously the ﬁrst vertex in any such pair will
be conﬁrmed as t → ∞; and will be such that any inﬁnite path to the root passes through
(cid:4)
this vertex. We conclude via Lemma 2.12.

5. Proofs for Regenerative Behavior

5.1. Proof of Lemmas 3.1 and 3.7

Here we consider the general case r (cid:62) 1, i.e., P(ξ = r) > 0 and P(ξ < r) = 0. Recall that,
˜q = (cid:81)∞
s=0

P(ξ (cid:54) s ∨ r). We have

Var( ˜Nn) =

n
(cid:88)

t=1

P( ˜Et) + 2

(cid:88)

P( ˜Es ˜Et) − n2 ˜q2.

1(cid:54)s<t(cid:54)n

We denote by ˜qt the truncated product ˜qt := (cid:81)t−1
s=0
˜q as t → ∞. In particular, for t (cid:62) r, we have

P(ξ (cid:54) s ∨ r) for t (cid:62) 0 which decreases to

(cid:32)

0 (cid:54) ˜qt − ˜q (cid:54) ˜qt

1 −

∞
(cid:89)

(cid:33)

(1 − P(ξ > s))

(cid:54)

s=t+1

∞
(cid:88)

s=t+1

P(ξ > s).

Clearly, the events ( ˜Et)t>0 are identically distributed. Moreover for t > s, we have

˜Et ∩ ˜Es = ˜Et

t−s−1
(cid:92)

{ξs+i (cid:54) i},

i=0

(5.1)

so that P( ˜Et ∩ ˜Es) = ˜q ˜qt−s. In particular, we have

Var( ˜Nn) = n˜q + 2˜q

n
(cid:88)

t=1

(n − t)˜qt − n2 ˜q2 = n˜q(1 − ˜q) + 2˜q

n
(cid:88)

t=1

(n − t)(˜qt − ˜q).

(5.2)

Finally we get

1

n2 Var( ˜Nn) (cid:54) 1

n

˜q(1 − ˜q) +

2˜q
n

n
(cid:88)

(˜qt − ˜q) → 0 as n → ∞.

t=1

This completes the proof.

Dey & Gopalan/Asynchronous Composition Model

23

5.2. Proof of Proposition 3.5

Let h : Z → R be a function such that h(0) = 0 and denote by

H(x) :=

x
(cid:88)

i=0

h(i),

x ∈ N.

We can re-express h(x) = DH(x) = H(x + 1) − H(x), where D is the discrete derivative
operator. It follows from a standard result of Palm theory [18, Chapter 6] that

E(h(τ1)) = P(E0) E H(γ1) = q E H(γ1),

but we include a heuristic proof below for completeness. Our result then follows by picking
H(x) = xβ for β > 1.

For t (cid:62) 0, deﬁne λt = min{τi : τi (cid:62) t, i (cid:62) 1} as the next generation time after time t.

Clearly, λt − t d= λ0 = τ1

Fix some large integer n. Suppose that there are Kn := max{k (cid:62) 0 | τk (cid:54) n} many

regeneration times in the interval [0, n]. By stationarity, we see that:

n E(h(λ0)) =

n−1
(cid:88)

t=0

E(h(λt − t)).

Denote by Yj := (τj−1, τj] the j-th interval in between two consecutive regeneration times
after time 0 for j (cid:62) 1. For t ∈ Yj, we have λt = τj. In particular, we have (cid:80)
h(λt − t) =
H(γj) − H(0) = H(γj). Thus

t∈Yj

n E(h(λ0)) = E Kn · E H(γ1) + O(1).

Finally, the result follows by scaling by 1
as E Kn/n → q.

n and passing to the limit using the renewal theorem

5.3. Proof of Proposition 3.6

Let F denote the distribution function of ξ. Here, we consider the case when we have F (1) =
P(ξ = 1) > 0. Deﬁne the positive random variable

V := 1 + max
i(cid:62)0

(ξi − i ∨ 1) (cid:62) 1

where ξi, i (cid:62) 0 are i.i.d. ∼ F . For any k (cid:62) 1 we have P(V (cid:54) k) = F (k) (cid:81)∞
that

i=k F (i). It is clear

P(V = 1) = q = F (1)

F (i).

∞
(cid:89)

We also have that for k (cid:62) 0

P(V > k) = 1 − F (k)

∞
(cid:89)

i=k

F (i)

(cid:54) 1 − F (k) + F (k)

∞
(cid:88)

i=k

i=1

(1 − F (i)) (cid:54) 2 E(ξ − k)+ (cid:54) 2 E(ξ1(ξ > k)).

(5.3)

Dey & Gopalan/Asynchronous Composition Model

24

Fig 6. Stochastic domination in the proof of Proposition 3.6 with (cid:96) = 15, Vi = ti−1 − ti, i (cid:62) 1.

To analyze the distributional properties of τ1, ﬁrst we note that, P(τ1 = 0) = q and for any

(cid:96) (cid:62) 1

P(τ1 (cid:62) (cid:96)) = P(there is no regeneration time in [0, l)).

(5.4)

Fix t0 := (cid:96)−1 and consider the event that there is no regeneration time in [0, l]. Deﬁne V0 := ∞.
Here we have no restriction about the time delay graph in the interval [t0 + 1, t0 + V0). Deﬁne

V1 := 1 + max
0(cid:54)i<V0

(ξt0+i − i ∨ 1) d= V.

If t0 is not a regeneration time, we have V1 > 1. Note that V1 involves all the delay r.v.s in the
interval I0 := [t0, t0 + V0). Moreover, in the time delay graph, there can be no regeneration
time in the interval [t1 + 1, t0) where t1 := t0 − V1. We deﬁne

V2 := 1 + max
0(cid:54)i<V1

(ξt1+i − i ∨ 1).

If t1 is not a regeneration time, we have V2 > 1. Again, V2 involves all the delay r.v.s in the
interval I1 := [t1, t0).

Continuing this process, with tn := tn−1 − Vn, Vn+1 := 1+ max0(cid:54)i<Vn(ξtn+i − i ∨ 1) involving
edges from the interval In := [tn, tn−1), n (cid:62) 1 and so on, we see that (Vi)i(cid:62)0 is a Markov chain
with V0 = ∞ and given Vn = k (cid:62) 1, we have

Vn+1

d= 1 + max
0(cid:54)i<k

(ξi − i ∨ 1).

The ﬁrst regeneration time can be obtained when Vn hits 1. This process is described pictorially
in Figure 6.
Deﬁne

N := inf{n (cid:62) 0 | Vn = 1} (cid:62) 1,

the hitting time to 1 for the Markov chain. Deﬁne the random variable

S :=

N
(cid:88)

n=1

Vn =

∞
(cid:88)

n=1

Vn1n(cid:54)N (cid:62) 1.

Thus, we have the following relation

{There is no regeneration point in [0, l)} = {S > (cid:96)}.

(5.5)

102345678910111213141516t4=1t3=4t2=8t1=11t0=14V4=3V3=4V2=3V1=3V0=1Dey & Gopalan/Asynchronous Composition Model

25

In particular, using equations (5.4) and (5.5), we have τ1
moments of τ1 we need to get an upper bound for the moments of S. Note that,

d= S − 1. Thus, to control the

P(V2 = 1 | V1 = k) =

k−1
(cid:89)

i=0

P(ξ (cid:54) i ∨ 1) (cid:62) q for all k ∈ [1, ∞].

Thus N is stochastically dominated by a Geometric(q) random variable. It is also easy to see
that S is stochastically dominated by (cid:80) (cid:98)N
i=0 (cid:98)Vi, where ( (cid:98)Vi)i(cid:62)1 are i.i.d. random variables such
that (cid:98)V1 ∼ V | V > 1 and are independent of (cid:98)N ∼ Geometric(q).

In particular, for β > 1, we get that

E(τ1 + 1)β−1 = E Sβ−1 (cid:54) E (cid:98)V β−1

1

· E (cid:98)N β−1 < ∞

< ∞ or E V β−1 < ∞.

if E (cid:98)V β−1
1

Assume that E ξβ < ∞ for some β > 1. We have using equation (5.3) that

E V β−1 =

(cid:88)

((k + 1)β−1 − kβ−1) P(V > k)

k(cid:62)0
(cid:54) 2β

(cid:88)

(k + 1)β−2 E(ξ1(ξ > k)) (cid:54) 2β E(ξ + 1)β < ∞

where the ﬁrst inequality follows from equation (5.3). This completes the proof.

k(cid:62)0

6. Proofs of Main Results

In this section we present the proofs of our main results. The proof of Theorem 2.18 depends
on the value of r; and we separate that proof into the two cases where r = 1 and r > 1.

6.1. Proof of Theorem 2.15

Denote π0 = 0, and for k (cid:62) 1, we inductively deﬁne πk = minn∈N{n > πk−1 : Xn (cid:62) k}.
From the i.i.d. assumption on the (ξi)i, it is easy to see that the random variables χk :=
πk+1 − πk, k (cid:62) 0 are i.i.d.. Note that the sequence (χk)k denotes the lengths of intervals where
Xt stays constant. It follows from the strong law of large numbers that

Xt
t

a.s.−−→

1
E(χ1)

.

Finally, we compute the distribution of χ1 as follows. Note that the ﬁrst time of increment
for Xt after time 0 is the ﬁrst time when ξi < i. Using the independence of (ξi)i, we get that
P(χ1 (cid:62) k) = (cid:81)k

P(ξi (cid:62) i); the result follows.

Observe that this proof works even when r > 1 because for i (cid:54) r, we have P(ξi (cid:62) i) = 1.
The second convergence is an immediate consequence of the renewal central limit theorem.
The third convergence follows from the functional strong law of large numbers. Finally, the
last convergence follows from Donsker’s theorem for renewal processes.

i=1

Dey & Gopalan/Asynchronous Composition Model

26

6.2. Proof of Theorem 2.16

Here we present the proof for the general case r (cid:62) 1. Observe that if there are two regeneration
intervals beginning at the instants t0 and t0 + r, then there are also regeneration windows
beginning at all of the instants in (t0, t0 + r). We call such a regeneration interval [t0, t0 + 2r)
a long regeneration interval beginning at t0.

Fix a long regeneration interval beginning at t0. Note that, almost surely, there is an inﬁnite
sequence of such regeneration intervals with ﬁnite expected inter-duration. We consider the
instant ρ of the last increment of the height process Xt before time t0. If ρ (cid:54) t0 − r, then there
is an increment of Xt at time t∗ = t0. In this case, with probability r−r, each leaf vertex in the
regeneration interval beginning at t0 + r connects to the leaf added at time t∗, as the height
process will stay constant in the interval [t0, t0 + r). From the deﬁnition of a regeneration
interval, the leaf added at time t∗ will be conﬁrmed in the asynchronous limit. If ρ = t0 − i
for some i = 1, 2, . . . , r − 1, then there is an increment of Xt at time t∗ = t0 + r − i. The
same argument can be used to show that P(a long regeneration window contains a conﬁrmed
vertex) (cid:62) r−r > 0.

It follows that the asynchronous limit exists and has inﬁnitely many conﬁrmed vertices,
almost surely. Since the asynchronous limit is a tree, it immediately follows that it is one-
ended.

This proof reduces to the previous, and simpler, argument in Lemma 4.1 when r = 1.
Indeed, recall the previous argument that if two consecutive instants are regeneration times,
then the vertex added at the ﬁrst instant is conﬁrmed in the limit as t → ∞.

6.3. Proof of Theorem 2.17

First we present the proof for the r = 1 case. Proof for the general r case is essentially the
same. The fact that G∞(f1) has inﬁnitely many ends is established in Lemma 4.7 in the
special case when P(ξ = 1) P(ξ = 2) > 0.

It is easy to see that Lt = L(Gt), the number of leaves at time t, is a non-decreasing
function of t with 0 (cid:54) Lt+1 − Lt (cid:54) 1 a.s. for all t. Here we will show that the expected number
of leaves grows as Θ(t1/2). Since, ( ˆLk)k(cid:62)1 is a Markov chain, it follows that Lt → ∞ almost
surely and thus G∞(f1) has inﬁnitely many ends by Lemma 2.10.

Without loss of generality we can assume that E0 holds, i.e., 0 is a regeneration time.
Otherwise, we can shift the time to the ﬁrst regeneration time τ1, which is a tight random
variable. In particular, conditional on the event that 0 is a regeneration time, the delays (ξt)t(cid:62)1
are independent and satisfy (ξt | E0) ∼ (ξ | ξ (cid:54) t) for all t (cid:62) 1. We use ˆξt for ξt conditioned
on E0.

For the function f1, we have:

V (Gt) = V (Gt−1) ∪ {t} and E(Gt) = E(Gt−1) ∪ {(t, (cid:96)t)},

where the vertices ((cid:96)t)t(cid:62)1 are independent and satisfy (cid:96)t ∼ Unif(L(Gt− ˆξt

)). We denote by

It,s := L(Gs) ∩ L(Gt)c for t (cid:62) s,

the set of leaves in Gs which are not leaves in Gt anymore. We denote by It,s := |It,s| the
number of such leaves in Gs. Observe that

Lt − Lt−1 = 1{(cid:96)t ∈ It−1,t− ˆξt

}.

Dey & Gopalan/Asynchronous Composition Model

27

This follows since for the function f1, at most a single new leaf can be added in any time step,
and the number of leaves cannot decrease at any time step.

Let Ft be the σ-algebra generated by the delays ˆξ1, ˆξ2, . . . , ˆξt and the leaf choices (cid:96)1, (cid:96)2, . . . , (cid:96)t.

We can express the conditional probability as

(cid:16)

P

(cid:96)t ∈ It−1,t− ˆξt

(cid:17)

(cid:12)
(cid:12) Ft−1

=

t
(cid:88)

i=1

P( ˆξt = i) ·

It−1,t−i
Lt−i

.

(6.1)

We begin with the upper bound. As noted above, the function f1 implies that

It−1,t−i (cid:54) (i − 1) ∧ Lt−i, and that

Lt−1 (cid:54) Lt−i − It−1,t−i + (i − 1 − It−1,t−i).

Re-arranging, we get

Lt−i (cid:62) Lt−1 + 2It−1,t−i − (i − 1).

ab
We now use the identity
b+2a−(i−1)
equation (6.1). In particular, we have

(cid:54) b(i−1)
b+(i−1)

(cid:54) i − 1 for 0 (cid:54) a (cid:54) i − 1 < b to bound

(cid:16)

P

(cid:96)t ∈ It−1,t− ˆξt

(cid:17)

(cid:12)
(cid:12) Ft−1

=

t
(cid:88)

i=1

P( ˆξt = i) ·

It−1,t−i
Lt−i

(cid:54) 1
Lt−1
(cid:54) 2
Lt−1

Lt−1
(cid:88)

(i − 1) P( ˆξt = i) + P

(cid:16) ˆξt − 1 (cid:62) Lt−1 | Ft−1

(cid:17)

i=1
E( ˆξt − 1)+.

Here, the ﬁrst inequality follows by breaking the interval [1, t] into sub-intervals [1, Lt−1] and
[Lt−1 +1, t]; and by bounding the term It−1,t−i/Lt−i by (i−1)/Lt−1 in the ﬁrst subinterval and
by 1 in the second. Recall from the model that ˆξt is independent of Ft−1, so that E(( ˆξt − 1)+ |
Ft−1) = E( ˆξt − 1)+. By taking c := supt 2 E( ˆξt − 1)+, it follows that

In particular, we have

(cid:16)

P

(cid:96)t ∈ It−1,t− ˆξt

| Ft

(cid:17)

(cid:54) c
Lt−1

for all t.

E(Lt | Ft−1) (cid:54) Lt−1 +

c
Lt−1

.

We conclude by examining the diﬀerence of the second moments L2
t − L2

t−1. We have that
}, which follows from expanding (Lt−1 + 1)2. Thus,

t−1 = (2Lt−1 + 1)1{(cid:96)t ∈ It−1,t−1− ˆξt

t − L2

L2
in follows that

E(L2

t | Ft−1) − L2

t−1

(cid:54) (2Lt−1 + 1)

c
Lt−1

(cid:54) 2c +

1
Lt−1

(cid:54) 2c + 1.

By induction, we have that E L2
t
E Lt (cid:54) (cid:112)E(L2
t ) (cid:54) (cid:112)(2c + 1)t + L2
establish a lower bound. Observe that

(cid:54) (2c + 1)t + L2
0. Hence by Jensen’s inequality we have
0, which establishes the upper bound for E Lt. We now

E(Lt | Ft−1) (cid:62) Lt−1 +

c1
Lt−1

Dey & Gopalan/Asynchronous Composition Model

28

for some constant c1 > 0. Since E Lt (cid:54) (cid:112)(2c + 1)t + L2
by induction that

0 and E(1/Lt−1) (cid:62) 1/ E Lt−1, it follows

E Lt (cid:62)

t−1
(cid:88)

i=1

c1
(cid:112)(2c + 1)i + L2

0

√

= Θ(

t).

6.4. Proof of Theorem 2.18

Let At be the event that f (cid:54)= f1 at time t. Clearly, (At)t(cid:62)1 are i.i.d.

6.4.1. Case 1: r = 1

Recall that ˆLk denotes the number of leaves at time τk, for k (cid:62) 1. Moreover, ( ˆLk)k is an
N-valued Markov Chain. Thus, it suﬃces to show that it is positive recurrent.

Note that, at any time if the delay is 1 and f1 is not chosen at that time, the number of

leaves goes down by at least one. Thus

P( ˆL2 = (cid:96) − 1 | ˆL1 = (cid:96)) (cid:62) P(ξ = 1, A1) > 0

and similarly P( ˆL2 = (cid:96) + 1 | ˆL1 = (cid:96)) > 0 for all (cid:96) (cid:62) 1. Thus, ˆLk is irreducible.

If ( ˆLk)k(cid:62)1 is positive recurrent, there exists a sequence of regeneration times (τjl)l(cid:62)1 such
that ˆLjl = 1. It follows that all inﬁnite paths in G∞(f ) pass through the vertices added at
the times (τjl)l(cid:62)1, which in turn establishes the result.

We show that ( ˆLk)k is positive recurrent using Foster’s Theorem. As the Markov chain is

time homogenous, it suﬃces to show the following.
Lemma 6.1. There exists (cid:96)0 < ∞ such that E( ˆL2 − ˆL1 | ˆL1 = (cid:96)) (cid:54) −ε for some ε > 0,
whenever (cid:96) (cid:62) (cid:96)0.

Proof. Recall that, γ1 = τ2 − τ1 is the gap between the ﬁrst two consecutive regeneration
times. Using the Markov structure, thus we have

E( ˆL2 − ˆL1 | ˆL1 = (cid:96)) = E(Lγ1 − L0 | L0 = (cid:96), E0)

= E((Lγ1 − (cid:96))+ | L0 = (cid:96), E0) − E((Lγ1 − L0)− | L0 = (cid:96), E0).

We consider the two terms separately. First, we upper bound the term

E((Lt ∨ (cid:96) − Lt−1 ∨ (cid:96))+ | L0 = (cid:96), E0)

= P(Lt − Lt−1 = 1, Lt−1 (cid:62) (cid:96) | L0 = (cid:96), E0).

Recall from the proof of Theorem 2.17 that It,s is the number of vertices which are leaves
at time s and are not leaves at time t > s. We also continue the notation from there (ξt |
d= (ξt | ξt (cid:54) t); or equivalently, we use ˆξt when conditioning on the event that 0 is a
E0) ∼ ˆξt
regeneration time.

As in the proof of Theorem 2.17, we have

P(Lt − Lt−1 = 1 | Ft−1) =

t
(cid:88)

i=1

P( ˆξt = i) ·

It−1,t−i
Lt−i

.

(6.2)

Dey & Gopalan/Asynchronous Composition Model

29

Recall from the process dynamics that Lt−i > Lt−1 −i and that It−1,t−i < i. We can substitute
these bounds into (6.2), which yields

P(Lt − Lt−1 = 1 | Ft−1) (cid:54)

t
(cid:88)

i=1

P( ˆξt = i) ·

(cid:18)

i − 1
Lt−1 − i + 1

(cid:19)

∧ 1

.

For any k ∈ {1, 2, . . . , t}, we can upper bound the rhs as

k − 1
Lt−1 − k + 1

+ P( ˆξt > k) (cid:54)

k − 1
Lt−1 − k + 1

+

E ˆξt
k

.

Note that E ˆξt (cid:54) sups(cid:62)1
nearest integer to

√

E ˆξs < ∞. We can now optimize over k by choosing k to be the

Lt−1. Thus, for some universal constant c ∈ (0, ∞), we have

P(Lt − Lt−1 = 1 | Ft−1) (cid:54)

√

c
Lt−1

for all t.

It follows that

E ((Lt ∨ (cid:96) − Lt−1 ∨ (cid:96))+ | Ft, L0 = (cid:96), E0)

= P(Lt − Lt−1 = 1, Lt−1 (cid:62) (cid:96) | L0 = (cid:96), E0) (cid:54) c (cid:96)−1/2.

We can now bound E((Lγ1 − (cid:96))+ | L0 = (cid:96), E0). Indeed, we have

E((Lγ1 − (cid:96))+ | L0 = (cid:96), E0) (cid:54)

=

∞
(cid:88)

t=1
∞
(cid:88)

E((Lt ∨ (cid:96) − Lt−1 ∨ (cid:96))+ · 1γ1(cid:62)t | L0 = (cid:96), E0)

P(Lt − Lt−1 = 1, Lt−1 (cid:62) (cid:96), γ1 (cid:62) t | L0 = (cid:96), E0)

t=1
Using H¨older’s inequality for p, q > 1, 1

E((Lγ1 − (cid:96))+ | L0 = (cid:96), E0) (cid:54)

p + 1

q = 1, we get
c(cid:96)−1/2(cid:17)1/p

(cid:16)

(cid:54) c1/p(cid:96)−1/(2p)

∞
(cid:88)

·

t=1
(cid:16)

∞
(cid:88)

i=1

P(γ1 (cid:62) t)1/q

E γβ

1 /tβ(cid:17)1/q

,

1 < ∞. Using Propositions 3.5 and 3.6, we have E ξβ < ∞ implies that
1 < ∞. Under our assumption that E ξ1+δ < ∞ for some δ > 0, taking β = 1 + δ > q > 1,

for β > q > 1 with E γβ
E γβ
we get that

E((Lγ1 − (cid:96))+ | L0 = (cid:96), E0) (cid:54) c1(cid:96)−1/(2p)

(6.3)

for some constants c1 > 0, p > 1.

Now, we bound E((Lγ1 − (cid:96))− | L0 = (cid:96), E0). Observe that when (cid:96) (cid:62) 2, we have

E((Lγ1 − (cid:96))− | L0 = (cid:96), E0) (cid:62) P(ξ1 = 1, A1) > 0
as when f (cid:54)= f1, ξ1 = 1 there is a decrease in the number of leaves. Combining the bounds (6.3)
and (6.4), for suﬃciently large (cid:96), we have

(6.4)

E( ˆL2 − ˆL1 | ˆL1 = (cid:96)) (cid:54) c1(cid:96)−1/(2p) − P(ξ1 = 1, A1) (cid:54) −ε,

for some constants ε > 0. The result follows.

(cid:4)

Dey & Gopalan/Asynchronous Composition Model

30

6.4.2. Case 2: r > 1

We consider the Markov chain X(t), given by the leaf geometry of the sequence (Gt, Gt+1,
. . . , Gt+r−1). Speciﬁcally, X(t) takes values of r–tuples of ﬁnite DAGs with maximum path
length r. When r = 1, there is a natural bijection of this state space with the natural numbers
N, which identiﬁes the following analysis with the previous one. One-endedness of the limit
G∞(f2) follows again from the positive recurrence of Xt.

To see this, suppose that Lt = r for some t such that the interval [t, t + r) is a regeneration
interval. We deﬁne an event of positive probability such that all the vertices in the regeneration
interval [t, t + r) satisﬁes the property that all vertices of mark at least t + r(r + 1) have a path
to each vertex in this regeneration interval. Hence all vertices in this regeneration interval
are conﬁrmed in G∞(f2); and from the positive recurrence of X(t) it follows that this event
occurs inﬁnitely often.

For convenience, we temporarily renumber the vertices in the window [t, t + r(r + 1)) by
[1, 2, . . . , 1 + r(r + 1)). With positive probability, the function f1 is not chosen in this interval.
When the number of leaves is at the minimum value r, the vertex number 1 must have out-
degree 1; vertex number 2 has out-degree 2, one of the vertices connected to by vertex number
2 is also connected to by vertex number 1. We proceed similarly so that each of the r leaves
present when vertex 1 is added is connected to by at least one of the vertices 1, 2, . . . , r. All
other vertices t connect to t − r and t − r − 1. It is obvious that since the last r vertices
correspond to a regeneration window, each of the ﬁrst r vertices are conﬁrmed. This is shown
pictorially in Figure 2, for r = 3. In the ﬁgure, we only draw 2 outgoing edges for the vertices;
as any f (cid:54)= f1 adds at least 2 edges for each vertex whenever possible.

Thus, let [ti, ti + r) be a sequence of disjoint regeneration intervals such that all vertices
in each interval are conﬁrmed in G∞(f2). From the previous property of our event, any two
inﬁnite rays in G∞(f2) each pass through the regeneration intervals [t2i, t2i + r) for all i ∈ N.
For i (cid:62) 2, the vertices in the regeneration interval along the inﬁnite rays each have a path to a
vertex in the regeneration interval [t2i−1, t2i−1 + r); which in turn has a path to vertices along
the inﬁnite paths contained in the regeneration interval [t2(i−1), t2(i−1)+r). This establishes
one-endedness of the limit.

We now show that X(t) is recurrent. For a regeneration interval [t, t + r), we deﬁne

Vt :=

r−1
(cid:88)

i=0

ˆLt+i.

Once again, we apply Foster’s theorem to get the required result. We will prove the following
result.
Lemma 6.2. For suﬃciently large (cid:96), E(Vτ2 − Vτ1 | Vτ1 = (cid:96)) (cid:54) −ε for some ε > 0.

Note that there are only ﬁnitely many states such that Vτ1 < k for any k.

Proof. Similarly to the proof in Subsection 6.4.1, we express the expectation into its positive
and negative components,

E(V˜τ2 − V˜τ1 | V˜τ1 = (cid:96)) = E((V˜τ2 − V˜τ1)+ | V˜τ1 = (cid:96)) − E((V˜τ2 − V˜τ1)− | V˜τ1 = (cid:96)).

Dey & Gopalan/Asynchronous Composition Model

31

We now analyze each one separately. For the positive component, the proof and conclusions
in Case 1 hold here, which can be seen by noting that for the sums in the previous proof,
((cid:80)t

i=r ·)+ (cid:54) (cid:80)t
We analyze the negative component as follows. Observe that when (cid:96) (cid:62) 2r + r, we have

i=1(·)+, and the same for inﬁnite sums.

E((V˜τ2 − V˜τ1)− | V˜τ1 = (cid:96)) (cid:62) P(cid:0)ξr = r,

r
(cid:92)

i=1

Ai, O (cid:12)

(cid:12) V0 = (cid:96), ˜τ1 = 0(cid:1) (cid:62) ε > 0.

Here the event O given ˜τ1 = 0 is as follows. Number all the (cid:96) (cid:62) 2r + r leaves present in
G0 by 1, 2, . . . , (cid:96) in order of oldest-to-newest. Then O is the event that each vertex added in
the interval [0, r) chooses a disjoint pair of leaves from the set 1, 2, . . . , (cid:96) − r. Notice that the
probability of this event is non-decreasing in (cid:96) (cid:62) 2r + r.

The remainder of this proof follows exactly as for Case 1 in Section 6.4.1.

(cid:4)

6.5. Proof of Theorem 2.19

We observe, using the results of Theorems 2.17 and 2.18, that

c1√
l

−

kα
√
l

(cid:54) E(Lt+1 − Lt | Lt = l) (cid:54) c2√
l

−

kα
√
l

,

for appropriate positive constants c1 < c2.

1 = c1 −kα and c(cid:48)

2 = c2 −kα. Using the identity a3/2 −b3/2 = (

√

√

a−

b)(a+b+

√

ab),

Deﬁne c(cid:48)
we observe that

t+1 − L3/2
L3/2

t ≈ (Lt+1 + Lt) ·

√

Lt+1 − Lt
√
Lt+1 +

Lt

.

Conditioning on Lt = l, it follows that

c(cid:48)
1

(cid:54) E(L3/2

t+1 − L3/2

t

| Lt = l) (cid:54) c(cid:48)
2.

Since for any l, it occurs with positive probability that Lt = l and Lt+1 = 1, the result follows
from Foster’s theorem when kα > c2; the result is obvious when kα < c1.

6.6. Proof of Theorem 2.20

The convergence in time is an immediate consequence of one-endedness and we omit the proof
for brevity. The remainder of the result may be expressed as the following lemmas:
Lemma 6.3. For any time t (cid:62) 0, limk→∞ Gt(fk) = Gt(f∞) a.s. when the driving sequences
for each function are coupled.

Proof. For any time t, the sequence of DAGs (Gi(fn))1(cid:54)i(cid:54)t have strictly less than t + 1 leaves;
(cid:4)
hence the DAGs (Gt(fn))n>t are all equal to Gt(f∞); the result follows.

Lemma 6.4. limk→∞ d∗(G∞(fk), G∞(f∞)) = 0 a.s. when the driving sequences for each
function are coupled.

Proof. We call a time t special if

Dey & Gopalan/Asynchronous Composition Model

32

1. [t, t + r), and [t + r, t + 2r) are regeneration intervals, and
2. |L(Gt(f∞))| = r.

From Lemma 4.8, there exist, almost surely, inﬁnitely many special times (κi)i(cid:62)1 with

0 (cid:54) κ1 < κ2 < · · · .

Let Mi := mint∈[κi,κi+1] |L(Gt(f∞))|, and let Di be the hop distance between the vertices
added at times κi and κi+1. Both (Mi)i and (Di)i are sequences of positive ﬁnite integer-valued
random variables with inﬁnite support. Furthermore it is clear that both Mi, Di (cid:54) κi+1 − κi.
Assume, WLOG, that 0 is a special time. For any i, we have that maxt(cid:54)κi |L(Gt(f∞))| (cid:54)
max1(cid:54)k(cid:54)i Mk; furthermore we have that the hop distance of the κi-th vertex from the root is
given by D1 + D2 + · · · + Di.

The key step of this proof is the fact that maxt(cid:54)κi |L(Gt(f∞))| (cid:54) k implies that for all
j (cid:62) k, and with coupled delays, Gt(fj) = Gt(f∞) for times t (cid:54) κi. In particular, we have that

d∗(G∞(fj), G∞(f∞)) (cid:54)

sup
j(cid:62)k

1
1 + D1 + D2 + · · · + Dh

whenever max
1(cid:54)l(cid:54)h

Ml (cid:54) k.

Thus, for any ε > 0 and positive integer h, we have

P(sup
j(cid:62)k

d∗(G∞(fj), G∞(f∞)) > ε/(1 + ε))

(cid:54) P( max
1(cid:54)l(cid:54)h

Ml > k) + P(D1 + D2 + · · · + Dh < 1/ε).

The remainder of the result is an application of concentration inequality.

First, we assume that E ξ2 < ∞; this can be easily relaxed. We want to choose h such that

h E D1 > 1/ε, say h E D1 = 2/ε. We have, by Chebyshev’s inequality




h
(cid:88)

P



Dj < 1/ε


 = P



h
(cid:88)

(E D1 − Dj) >

h E D1

1
2


 (cid:54) 4 Var(D1)
(E D1)2

·

1
h

,

(6.5)

j=1

j=1

whenever E D2

1 < ∞ and

P( max
1(cid:54)l(cid:54)h

Ml > k) = 1 − (1 − P(M1 > k))h (cid:54) h P(M1 > k) (cid:54) h P(κ2 − κ1 > k).

We choose h ≈ P(κ2 − κ1 > k)−1/2 and εk = 2/(h E D1) ≈ (cid:112)P(κ2 − κ1 > k) to get the bound

d∗(G∞(fj), G∞(f∞)) > εk/(1 + εk)) (cid:54) constant · (cid:112)P(κ2 − κ1 > k).

P(sup
j(cid:62)k

Thus the a.s. convergence result follows when E D2

1 < ∞.

Note that if two consecutive times are regeneration times, the second is special. Hence
κ2 − κ1 is bounded by geometric many i.i.d. sum of ˜γi’s. Clearly, the condition E D2
1 < ∞
holds when E(κ2 − κ1)2 < ∞. From Propositions 3.5 and 3.6, this holds when P(ξ = 1) > 0
and E ξ2 < ∞.

More generally, if E ξ1+δ < ∞ for some δ > 0, we have E(κ2 − κ1)1+δ < ∞. Moreover, we
can obtain a bound of the order O(h−δ) in equation (6.5) and the rest of this proof follows by
taking h ≈ P(κ2 − κ1 > k)−1/(1+δ). Note that for convergence in distribution, we only require
(cid:4)
ﬁniteness of the ﬁrst moment of ξ.

Dey & Gopalan/Asynchronous Composition Model

33

7. Discussion and Further Questions

This article introduces the asynchronous composition model as a tool for the asymptotic anal-
ysis of blockchain construction functions. We show the eﬃcacy of asynchronous composition
for studying the end structure of limiting blockchain graphs and by studying the Nakamoto
construction from the Bitcoin protocol and the construction f2 from the Iota protocol. Using
the related idea of an asynchronous recursion, we also explicitly characterize the growth rate
of the longest path to the root under the Nakamoto function. This rate is the key parameter
used in the security analyses of that construction but has not been previously characterized.
A large variety of questions may be posed from the asynchronous composition model.

1. Modeling I: We consider the model generalization discussed in Section 2.6. It is non-
trivial to extend the results to the generalization when r > 1, or when the support of
ν1 is not irreducible; but this is nevertheless an important practical model as it is more
realistic than the “standard” ACM.

2. Modeling II: We can also generalize the model with a weighted version. Suppose each
vertex v has a weight at time t given by wt(v) ∈ [0, ∞). If v is not present before time
t, deﬁne ws(v) = 0, s < t. Initially, at time 0 all vertices are assigned an initial weight
w0(v), v ∈ G0. A new vertex arriving at time t, connects to vertices chosen proportional
to the vertex weights at time (t − ξt)+. The new and the old vertices it connects to,
gets their weight at time t updated according to some weight update rule. For all other
vertices weights stays the same. One can ask questions about properties of the limiting
graph for diﬀerent weight update rules. In our case, the initial assigned weights are
1in-degree=0 and the weight update rule is that the new vertex gets weight 1 and old
vertices get weight 0.

3. Which values (in Z+ ∪ {∞}) can the number of ends in asynchronous composition take?

This qualitative question is analogous to the question in percolation and unimodular
random graphs. For percolation, there can be 0, 1, or ∞ inﬁnite components; any uni-
modular random graph has 0, 1, 2, or ∞ ends.
Due to our restriction of the process to B(cid:63), we know that there cannot be 0 ends
in the asynchronous limit. We conjecture that there can only be 1 or ∞ ends in the
asynchronous limit for any construction f and non-constant irreducible delay measure
ξ.

4. Fix a construction function f , and let Ξ be the space of non-constant irreducible proba-
bility distributions on N. Is the number of ends in the asynchronous limit invariant to
Ξ?

This question arises purely from the asynchronous composition model but does not have
an analog in the model of percolation or unimodular graphs. There is practical impor-
tance to this question in the context of blockchain systems. If there exists a function
whose asynchronous limit is only one-ended for a speciﬁc ξ ∈ Ξ, then such a function
may not work in all network situations arising in a blockchain system.

5. Fix ξ ∈ Ξ as above. Does every one-ended function have a one-ended asynchronous

limit?

This question can be interpreted as, “given any ﬁxed network behavior, can any one-

Dey & Gopalan/Asynchronous Composition Model

34

ended construction function be used in a blockchain system?” We conjecture that this
statement is true, at least when r = 1. Indeed, an intuition for this may be as follows.
Since the function is one-ended, the synchronous limit is one-ended for any ﬁnite graph.
Thus, in asynchronous operation, if the delay process satisﬁes r = 1 for inﬁnitely many
suﬃciently long disjoint intervals, one may be able to conclude that the asynchronous
limit is also one-ended. This intuition is a critical idea in many of the proofs in this
paper, although the construction functions we consider are more limited in scope.

6. Do graph properties of preferential attachment, such as degree distribution, remain in-

variant under asynchronous composition?

Note that the standard preferential attachment model corresponds to synchronous limits
in the terminology of this paper. We can deﬁne a delay version of this model by taking f
to be a set of vertices chosen according to a function of the degree in the given graph. The
martingale structure from the synchronous case will not be present anymore. However,
it is interesting to see if the degree distribution still converges in distribution and the
eﬀect of the delay on the power-law parameter.

7. Theory of asynchronous recursions and delay-diﬀerential equations.

The asynchronous recursion we consider in this paper is a max-type distributional re-
cursion. However, due to the random delays, the analysis does not fall into any class
discussed in the well-known survey paper [2]. It is also unclear how to deﬁne a continu-
ous counterpart to this kind of recursion; and how the discrete and continuous versions
would be related. It may be of independent interest to develop the theory of such recur-
sions and delay-diﬀerential equations.

Acknowledgments.

The authors would like to thank Abishek Sankararaman for initial discussions and constructive
comments that improved the quality of this paper.

References

[1] Acemoglu, D., Dahleh, M. A., Lobel, I. and Ozdaglar, A. (2011). Bayesian learn-

ing in social networks. Rev. Econ. Stud. 78 1201–1236. MR2896020

[2] Aldous, D. J. and Bandyopadhyay, A. (2005). A survey of max-type recursive dis-

tributional equations. Ann. Appl. Probab. 15 1047–1110. MR2134098

[3] Aldous, D. and Lyons, R. (2007). Processes on unimodular random networks. Electron.

J. Probab. 12 no. 54, 1454–1508. MR2354165

[4] Alexander, K. S. and Berger, Q. (2016). Local asymptotics for the ﬁrst intersection
of two independent renewals. Electron. J. Probab. 21 Paper No. 68, 20. MR3580034
[5] Baccelli, F. and Sodre, A. (2019). Renewal processes, population dynamics, and

unimodular trees. J. Appl. Probab. 56 339–357. MR3986940

[6] Bramson, M. (2008). Stability of queueing networks. Lecture Notes in Mathematics
1950. Springer, Berlin Lectures from the 36th Probability Summer School held in Saint-
Flour, July 2–15, 2006. MR2445100

[7] Br´emaud, P. (2020). Probability theory and stochastic processes. Universitext. Springer,

Cham. MR4174397

Dey & Gopalan/Asynchronous Composition Model

35

[8] Chatterjee, S. and Dey, P. S. (2016). Multiple phase transitions in long-range ﬁrst-
passage percolation on square lattices. Comm. Pure Appl. Math. 69 203–256. MR3434612
[9] Dembo, A., Kannan, S., Tas, E. N., Tse, D., Viswanath, P., Wang, X. and
Zeitouni, O. (2020). Everything is a Race and Nakamoto Always Wins. In Proceed-
ings of the 2020 ACM SIGSAC Conference on Computer and Communications Security
859–878. Association for Computing Machinery, New York, NY, USA.

[10] Diestel, R. (2018). Graph theory, ﬁfth ed. Graduate Texts in Mathematics 173.

Springer, Berlin Paperback edition of [MR3644391]. MR3822066

[11] Diestel, R. and K¨uhn, D. (2003). Graph-theoretical versus topological ends of graphs.
J. Combin. Theory Ser. B 87 197–206. Dedicated to Crispin St. J. A. Nash-Williams.
MR1967888

[12] Foss, S., Martin, J. B. and Schmidt, P. (2014). Long-range last-passage percolation

on the line. Ann. Appl. Probab. 24 198–234. MR3161646

[13] Fralix, B. (2020). On classes of Bitcoin-inspired inﬁnite-server queueing systems.

Queueing Syst. 95 29–52. MR4102496

[14] Frolkova, M. and Mandjes, M. (2019). A Bitcoin-inspired inﬁnite-server model with

a random ﬂuid limit. Stoch. Models 35 1–32. MR3945344

[15] Gopalan, A. and Stolyar, A. (2021). Data Flow Dissemination in a Network. arXiv

preprint arXiv:2110.09648.

[16] Gopalan, A., Sankararaman, A., Walid, A. and Vishwanath, S. (2020). Stability
and Scalability of Blockchain Systems. Proc. ACM Meas. Anal. Comput. Syst. 4.
[17] Halin, R. (1964). ¨Uber unendliche Wege in Graphen. Math. Ann. 157 125–137.
[18] Kallenberg, O. (2017). Random measures, theory and applications. Probability Theory

and Stochastic Modelling 77. Springer, Cham. MR3642325

[19] King, C. (2021). The ﬂuid limit of a random graph model for a shared ledger. Adv. in

Appl. Probab. 53 81–106. MR4232750

[20] Nakamoto, S. (2019). Bitcoin: A peer-to-peer electronic cash system Technical Report,

Manubot.

[21] Popov, S. (2016). The tangle. cit. on 131.
[22] Sankagiri, S., Gandlur, S. and Hajek, B. (2021). The Longest-Chain Protocol Under

Random Delays. arXiv preprint arXiv:2102.00973.

