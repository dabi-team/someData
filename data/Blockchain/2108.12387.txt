1
2
0
2

g
u
A
7
2

]

C
D
.
s
c
[

1
v
7
8
3
2
1
.
8
0
1
2
:
v
i
X
r
a

1

NimbleChain:
Low-latency consensusless cryptocurrencies in
general-purpose permissionless blockchains

Paulo Silva, Miguel Matos, Jo ˜ao Barreto
INESC-ID, Instituto Superior T ´ecnico, Universidade de Lisboa
{paulo.mendes.da.silva, miguel.marques.matos, joao.barreto}@tecnico.ulisboa.pt

Abstract—Nakamoto’s seminal work gave rise to permissionless blockchains – as well as a wide range of proposals to mitigate its
performance shortcomings. Despite substantial throughput and energy efﬁciency achievements, most proposals only bring modest (or
marginal) gains in transaction commit latency. Consequently, commit latencies in today’s permissionless blockchain landscape remain
prohibitively high for latency-sensitive geo-distributed applications.
This paper proposes NimbleChain, which extends standard permissionless blockchains with a fast path that delivers consensusless
promises of commitment. This fast path supports cryptocurrency transactions and only takes a small fraction of the original commit
latency, while providing consistency guarantees that are strong enough to ensure correct cryptocurrencies. Since today’s
general-purpose blockchains also support smart contract transactions, which typically have (strong) sequential consistency needs,
NimbleChain implements a hybrid consistency model that also supports strongly-consistent applications. To the best of our knowledge,
NimbleChain is the ﬁrst system to bring together fast consensusless transactions with strongly-consistent consensus-based
transactions in a permissionless setting.
We implement NimbleChain as an extension of Ethereum and evaluate it in a 500-node geo-distributed deployment. The results show
that the average latency to promise a transaction is an order of magnitude faster than consensus-based commit, with minimal overhead
when compared with a vanilla Ethereum implementation.

Index Terms—Distributed systems, permissionless blockchains, cryptocurrencies, smart contracts, hybrid consistency

(cid:70)

1 INTRODUCTION

The majority of permissionless blockchains, including main-
stream ones such as Bitcoin [45] or Ethereum [61], rely on the
foundations of Nakamoto’s seminal consensus protocol [45].
In these systems, the probability that a given block has
stabilized grows with the number of blocks that succeed
it in the chain. Hence, by setting a high enough threshold
to consider a block – and the transactions therein – as
committed, one can ensure an arbitrarily low probability
of the block being discarded. This is commonly known as
ﬁnality and has been formalized as a persistence property by
Garay et al. [17].

Permissionless blockchains can thereby be used as a
(probabilistic) total-order broadcast service with unique fea-
tures, in particular their resilience to Sybil attacks which
characterize permissionless environments. Permissionless
blockchains support a wide range of geo-distributed ap-
plications, from cryptocurrencies to general-purpose smart
contracts, but unfortunately they are also known for their
poor performance.

In recent years, the research community has contributed
improvements to permissionless block-
with important
chains – from improvements of Nakamoto’s longest chain
rule [58], [61], [33], [57], [35], hierarchical and parallel
chains [16], [48], [62], [4], sharded blockchains [38], [32],
[63], [14], Layer-2 approaches [52], [23], [41], [11], [24]
BFT-based blockchains [31], [49], [1], [19], [44], [37], and

Proof-of-X alternatives [28], [64], [19], [3], [12], [2], [8].
These approaches have focused mostly on improvements to
throughput and/or energy efﬁciency, bringing only modest
improvements to commit latency. Some notable exceptions
reduce commit latencies by sacriﬁcing security or scala-
bility (as we discuss in §8). In fact, as of today, commit
latencies remain notably high in mainstream permissionless
blockchains – around 1 hour in Bitcoin and 3 minutes in
Ethereum.

Such high commit latencies are especially prohibitive
for many applications that require low-latency transactions.
Examples range from merchant applications that need to
deliver goods quickly (< 30 seconds) [27], such as point-
of-sale purchases and retail vending machines, take-away
stores, online shopping, supermarket checkouts and bike
sharing systems [10], [27], [5], [22], to blockchain-backed IoT
devices and applications [23]. To overcome the high commit
delays, merchants and service providers frequently adopt
risky 0- or 1-conﬁrmation policies [10], which accept trans-
actions as granted well before the underlying blockchain can
provide sufﬁciently strong guarantees of their persistence.
Such policies are inherently vulnerable to double-spending
attacks.
The

latencies of mainstream permission-
commit
less blockchains reﬂect
two well-known limitations of
Nakamoto’s consensus protocol: for the sake of correctness,
blocks need to be generated (on average) at a slow pace
with respect to network latency, and a transaction should

 
 
 
 
 
 
only be considered as committed (i.e., persistent) after it is
followed by a long sequence of (slowly generated) blocks
in the chain [17]. To further complicate matters, a recent
study [54] concluded that, due to the emergence of pow-
erful mining pools, blockchain systems should wait for
even larger blockchain sufﬁxes before committing, which
means that commit latency is bound to increase, rather than
decrease.

This paper focuses on improving the latency of general-
purpose permissionless blockchains. Our work is inspired
by recent results by Guerraoui et al. [21], which have proved
that the actual consistency needs of a cryptocurrency can be
satisﬁed without resorting to consensus.

As a ﬁrst contribution, we propose an extension to the
traditional issue/commit model, by introducing the notion
of promise of commitment, or simply promise. A promise is
a new event in a transaction’s life cycle. Informally, when
a process promises a transaction t, that means that t will
be eventually committed by every correct process, even
if t is part of a double-spending attempt by a malicious
user, while satisfying any causal dependencies of t. Hence,
the promise event captures weaker consistency guarantees
than the commit event, as different processes may promise
transactions in different orders (i.e., the promise event is
not totally ordered). Still, the guarantees of the promise
event are strong enough to fulﬁl the consistency needs of
cryptocurrencies and other applications.

To be effectively advantageous, a system implementing
the novel issue/promise/commit model should ensure that,
for most transactions, a large portion of correct processes (if
not all) actually promise such transactions much earlier than
they commit them.

As a second contribution, we address the above goal
by proposing NimbleChain. NimbleChain extends permis-
sionless blockchains based on the Bitcoin Backbone Protocol
(BBP) [17] with a consensusless promise fast path. This fast path
allows cryptocurrency transactions, which constitute the
bulk of today’s most important permissionless blockchains
(i.e., almost 100% in Bitcoin [6] and 44% in Ethereum [54])
to be promised substantially faster than the original com-
mit, in a large portion of correct processes. Since today’s
general-purpose blockchains also support smart contract
transactions, which typically have (strong) sequential con-
sistency needs, NimbleChain implements a hybrid consis-
tency model that supports both types of transactions. To the
best of our knowledge, NimbleChain is the ﬁrst system to
bring together fast consensusless transactions with strongly-
consistent consensus-based transactions in a permissionless
setting.

As a third contribution, we implement NimbleChain
as an extension of the Ethereum blockchain, which demon-
strates the practicality of our proposal. Furthermore, we
show that NimbleChain can also extend most recent propos-
als for high-throughput and mid-latency blockchains, which
are still built on Nakamoto’s consensus foundations.

As a ﬁnal contribution, an evaluation with 500 pro-
cesses in a realistic geo-distributed environment that shows
that NimbleChain’s consensusless fast path reduce the com-
mit latencies of cryptocurrency transactions by an order of
magnitude with negligible overhead when compared with
Ethereum.

2

The rest of the paper is organized as follows. §2 provides
background on permissionless blockchains and describes a
generic baseline protocol. §4 presents NimbleChain, which
extends the baseline with consensusless transactions. §5
describes how we can leverage NimbleChain ’s promises to
implement low-latency cryptocurrencies. §6 evaluates our
implementation of NimbleChain as an extension of Ethe-
reum in a large-scale geo-distributed scenario. §7 discusses
the limitations of NimbleChain. §8 surveys related work. §9
concludes the paper.

2 BACKGROUND

In this section we provide background on: i) the Bitcoin
backbone protocol [17] which abstracts permissionless block-
chains such as Bitcoin or Ethereum and serves as the basis
of our work; and on ii) the intuition behind consensuless
cryptocurrencies which obviate the need for consensus.

At their core, most permissionless blockchains rely on
the consensus protocol proposed by Nakamoto for Bit-
coin [45]. Despite the many proposed extensions and vari-
ations to that protocol over the years, such as different
chain selection rules [51] or Proof-of-Work alternatives [28],
mainstream permissionless blockchains are still based on
the principles of Namamoto’s proposal. Several efforts
have studied its correctness properties. Among such works,
Garay et al. [17] have formalised the Bitcoin backbone protocol
(BBP), which captures the core of Nakamoto’s protocol in a
versatile way that covers today’s most relevant permission-
less blockchains, such as Bitcoin and Ethereum, and can be
extended to build new blockchain protocols.

In this work, we consider the BBP as our starting point,

which we will extend in the following sections.

2.1 Assumptions.

The BBP runs on a peer-to-peer network of processes and
relies on the following assumptions [17], [47], [50], [28]. First,
Byzantine adversaries control less than 50% of the total min-
ing power that is used to produce blocks and do not have
computational power to subvert the standard cryptographic
primitives. Any message broadcast by a correct process is
delivered to every correct process with high probability, and
with a maximum delay of D [50], [47], [53], [28]. This is often
a hidden assumption of permissionless blockchains systems
but it is in fact a critical aspect of the system that we do not
only expose but embrace. In fact, in Nakamoto consensus
the difﬁculty of the Proof-of-Work (PoW) puzzle is based on
the maximum delivery delay D [47], [53], and hence this is
an assumption shared by Bitcoin and Ethereum. The same
applies to proof-of-stake blockchains such as Ouroboros [28]
and Algorand [19] which assume a bounded delay. The
correctness of BBP, and systems such as Bitcoin or Etherum,
thus depends on the premise that the system takes much
longer to generate a new block than to propagate it [17]. Let
us denote B as the overall average block generation time.
Hence, we assume that r = D/B is relatively small [17].

For presentation simplicity, we assume that all processes
can produce blocks. Moreover, we also assume that each cor-
rect client is collocated with a correct processes participating
in the protocol. Devising robust solutions to support correct

clients that interact with possibly Byzantine processes run-
ning the protocol is an open problem, which is orthogonal
to our work. [26].

A transaction is signed by the process that issues it. The
body of a transaction is an application-dependent payload
(e.g. the target account and amount to transfer in a cryp-
tocurrency transaction, or, in a smart contract transaction,
the target smart contract, its method and arguments). Each
transaction also carries a local sequence number, which is
consecutively unique for that issuer. Note that a Byzantine
process p can submit two or more transactions with the same
sequence number, with the intention of having some correct
processes commit one transaction (and, hence, discard the
other one(s) as invalid), and other corrects processes decide
in the opposite direction. We denote such transactions as
double spending transactions.

2.2 Properties.

We start by deﬁning the event of committing a transaction as
follows. If a correct process p has a block b in its blockchain
followed by at least C other blocks, we say that every
transaction included in b is committed at p.

Garay et al. [17] proved that BBP ensures the two key
properties below associated with the commit event, with
high probability1.
Persistence: If process p commits a block b, and consequently
the transactions in b, then any correct process has block b in
the same position in the blockchain, from this moment on.
Liveness: if a correct process submits a transaction t then all
correct process eventually commit t.

Two important corollaries can be easily drawn from the
above properties. The ﬁrst one is that, if a correct process p
commits a transaction t, then all other correct processes will
eventually commit t. A second corollary is that, if a correct
process p commits transaction tA and, later, transaction tB,
then any other correct process q will commit both transac-
tions in the same order – in other words, the commit event
is totally ordered.

Together, the above properties and the associated corol-
laries constitute strong consistency guarantees, which BBP
provides with high probability. These enable many geo-
distributed applications to operate even when operating
under an adversarial permissionless environment. For in-
stance, state-machine replication can be built on top of BBP
through smart contracts. Yet, these guarantees are provided
at the cost of a high latency.

2.3 BBP Algorithm.

At a high-level, the BBP algorithm works as follows. Each
process holds a local ledger of transactions that consolidates
two components: a local copy of the blockchain (or, simply,
local chain) and the mempool. The local chain is organized
as a cryptographically linked list of blocks. Blocks have
a monotonically increasing gap-free sequence number and

1. For presentation simplicity, we present a formulation that is sim-
pler than Garay et al.’s original one. Namely, we omit some parameters
that are orthogonal to our contributions in this paper, and explicitly use
the term commit.

3

each block includes a totally-ordered sequence of transac-
tions. The mempool is a local queue of individual transac-
tions not yet included in the local chain. The transactions in
the mempool are ordered after the transactions in the chain.
When receiving a transaction, a process performs a series
of validations such as checking for funds, checking whether
another transaction with the same identiﬁer already exists
in the local ledger (i.e. a double-spend attempt) and ver-
ifying the transaction’s digital signature, among others. If
the transaction is valid and not yet in the local chain, it is
inserted in the mempool.

Processes initially share the same genesis block b0 and
produce blocks by selecting a subset of transactions in
the mempool and creating a proof that depends on these
transactions and on the last block in the local chain. The
proof is a Sybil-proof leader election mechanism, such as
PoW, that ensures the process legally produced the block.
The puzzle difﬁculty of PoW is a function of D [50].

Upon producing a new block, a process appends it to its
local chain and broadcasts it. When a block is delivered, it
is validated before being included in the local chain. Due
to concurrency, it is possible that two or more processes
produce two competing blocks bi+1 and b(cid:48)
i+1 that extend the
sequence (b0, . . . , bi). Processes will select either sequence
(b0, . . . , bi, bi+1) or (b0, . . . , bi, b(cid:48)
i+1), using a chain selection
rule (CSR). In Nakamoto consensus, the CSR corresponds to
selecting the chain with greatest PoW effort. By relying on
the CSR, the BBP protocol will make the system converge
by gradually agreeing on an increasing common blockchain
preﬁx. Blocks, and the transactions therein, are considered
committed, when followed by a sequence of C blocks.

2.4 Consensusless Transactions.

Our work hinges on the observation, previously identiﬁed
by Guerraoui et al. [21], that cryptocurrency transactions,
also known as asset transfer transactions, do not need
consensus. The intuition behind this observation is the fol-
lowing. In an asset transfer scenario, the system maintains a
set of accounts where each account maintains the number
of assets held, for instance the amount of Bitcoins in a
given account. Each account has a single owner that can
withdraw funds from this account and transfer them to
other accounts. The other users in the system can only read
the accounts balance and transfer funds to it (from their
own accounts). Therefore, it is the sole responsibility of
the account owner to order the withdrawal transactions.
Intuitively, this removes the need for consensus and the
account owner does not need to coordinate with any other
process in the system (i.e. formally such system can be used
to implement a sequential object type of consensus number
of 1 in Herlihy’s hierarchy [25]. We refer the reader to the
work of Guerraoui et al. for a formal description and proof
of this observation [21].

Note however that permissionless blockchains also serve
transactions issued by other applications with strong con-
sistency requirements, such as those issued to/by smart
contracts, which do require consensus. We describe in the
next sections how NimbleChain combines these different
transaction types in an hybrid consistency model.

3 PROMISE OF COMMITMENT

NimbleChain extends the life-cycle of a transaction, t, with
an additional event, a promise of commitment of t, which we
abbreviate to promise of t.

The main motivation behind the promise event is that
many applications, such as cryptocurrencies, do not need
the strong, total order guarantees provided by the (slow)
commit event. Instead, the semantics of such applications
only require weaker consistency guarantees, which the
promise event delivers. Next, we ﬁrst provide the intuition
behind the promise event and later formally formulate the
corresponding properties.

We start by informally presenting the ﬁrst guarantee
associated with the promise event. Whenever a process p
is able to anticipate – through some means, as we discuss
later on – that correct processes will eventually commit t,
p can expose such a priori guarantee by promising t. For
applications that do not require a total order, the promise
event allows them to continue their processing without
waiting for slow-paced (consensus-based) commit to deter-
mine the ﬁnal order where t will be placed in the (totally
ordered) distributed ledger. Naturally, the earlier a process
p promises t (relatively to the instant when p commits t), the
higher the above beneﬁt will be.

Note that, when a process is not able to safely anticipate
the promise of t, it can simply promise t when it is about to
commit t. However, this behaviour brings no beneﬁt, so it is
desirable that a process only rarely resorts to this case.

One important corollary is that the above guarantee
associated with the promise event is strong enough to resist
double-spend attempts. More precisely, suppose a byzantine
process issues two conﬂicting transactions, t(cid:48) and t(cid:48)(cid:48) in an at-
tempt to double-spend. Recall that the power of BBP ensures
that, if one of such transactions, say t(cid:48), commits, then the
other(s) conﬂicting transaction(s) will not. Hence, if a correct
process promises t(cid:48), then that process can immediately infer
that, even if the issuer of t(cid:48) maliciously tried to double-
spend, correct processes will choose t(cid:48) as the one to commit
and, thus, discard any conﬂicting transactions.

While the above guarantees of the promise event may
seem appealing, they are too weak for applications whose
semantics entail causal dependencies across transactions.
For instance, let us consider a correct process p1, that com-
mits a transaction t1, issued by some other process. Based on
the effects of t1, p1 decides to issue t2. Therefore, t2 causally
depends on t1. Since t2 is issued by a correct process, the
liveness property of BBP ensures that t2 will eventually
commit (on every correct process) after t1 has committed. In
other words, both transactions will commit in causal order
at every correct process. It is easy to generalize this example
and prove that, as long as new transactions are issued
(at some correct process) after their causal dependencies
have committed (at the same process), then BBP implicitly
ensures causal order.

When we introduce the promise event to the transac-
tion’s life-cycle, it becomes desirable to allow processes to
issue new transactions as soon as their causal dependencies
have been promised – since this will translate to latency
improvements. However, it is important that this change
does not threaten causal order guarantees on which many

4

applications rely. To illustrate, consider that p1 observes
that t1 (issued by some other process) has been promised,
and, consequently, decides to issue t2. Note that at this
point, t1 and t2 may not yet have committed anywhere.
Moreover, correct processes other that p1 may not even have
promised t1. Intuitively, anomalies such as a correct process
later promising or committing t2 and t1 in this order (i.e.,
violating causal order) should not be allowed.2

Finally, we can capture the above informal guarantees by

formulating the following properties.

Eventually committed upon promised: if a correct process
promises a transaction t then all correct process eventually
commit t.

Causal order: if a correct process promises (resp., com-
mits) a transaction t then that process has already promised
(resp., committed) every transaction on which t causally
depends.

In the latter, we assume that transactions carry a meta-
data ﬁeld that denotes its causal dependencies (using some
suitable causality tracking mechanism). Further, the causal
dependencies of a transaction t issued by correct process p
observe the following:

•

•

they must include every transaction that p has previ-
ously issued;
they may optionally include transactions issued by
processes other than p, under the condition that they
have already been promised by p when p issues t.

Finally, we remark that, in general-purpose blockchains,
different applications or different operations of a given
application, might have distinct consistency demands. This
explains why we decided to add the promise event to the
original issue/commit model, rather than simply replacing
the commit event with the promise event. The richer is-
sue/promise/commit event set offers a hybrid consistency
model. It allows different applications, or different opera-
tions from the same application, to choose whether to wait
for a transaction to be promised or committed, depending
on the required guarantees.

4 NIMBLECHAIN
In this section we present NimbleChain’s algorithm and
correctness arguments. §4.1 describes the main insight be-
hind NimbleChain and an overview of its main components.
§4.2 then details the main algorithm of NimbleChain. §4.3
discusses how NimbleChain can be tuned to maximize its
resilience. Finally, §4.4 details how NimbleChain enforces
causal order and §4.5 presents NimbleChain’s correctness
arguments.

4.1 Insight and overview

As discussed in §2, BBP offers a predictable outcome for cor-
rectly issued transactions – eventually they are guaranteed
to commit. However, when it comes to double-spending

2. Note that most blockchains, including BBP, already take causal
dependencies into account when committing cryptocurrency transac-
tions and, as such, prevent causality anomalies in that scope. However,
causal order is not enforced by the blockchain to transactions from
generic applications, in particular to generic smart contract applica-
tions.

transactions, the outcome is unpredictable – from a set of
double-spending transactions, {t, t(cid:48), ...}, the protocol will
non-deterministically select one transaction to commit and
discard the remaining ones. For this reason, if a process
p wishes to know whether some transaction t, issued by
another process, will eventually commit, p needs to wait
for the slow consensus-based BBP to agree on a decision
regarding t.

The main goal of NimbleChain is to enable processes
to correctly anticipate, well ahead in time, for which trans-
actions the (eventual) decision of BBP will be to commit
them. Whenever a process p is able to anticipate that with
high probability for some transaction t, p can immediately
promise t.

Before explaining how NimbleChain achieves this goal,
let us start by discussing a straw man proposal. In the
following, for a given transaction t, we denote by C(t) the
set of transactions with the same identiﬁer (issuer, sequence
number) as t. By deﬁnition, C(t) always has a single element
if a correct process issued t; otherwise, C(t) may have
additional transactions, which conﬂict with each other and
represent a double-spending attempt.

We can now sketch the following straw man proposal.
Whenever a correct process p receives some transaction t, p
executes the three steps below:

1)

Selection: p proposes t to every other correct pro-
cess and waits until the system agrees (by some
means) on pre-selecting some transaction tselected
from C(t) (note that, if t is issued by a correct
process, tselected = t);
2) Promise: p promises tselected;
3) Deterministic commit: ﬁnally, enforce BBP to commit

the selected transaction, tselected.

To ensure step 3, correct processes engage in a coor-
dinated effort that we hereafter designate as deterministic
BBP commit. Concretely, a deterministic BBP commit of
some transaction tselected is accomplished by having every
correct process reject: (i) the inclusion of any transaction that
conﬂicts with tselected in their mempools; and (ii) any chain
that contains any transaction that conﬂicts with tselected.

It is easy to show that these rejection conditions effec-
tively eliminate the non-determinism of the BPP when han-
dling double-spending transactions (when C(tselected) has
more transactions than tselected). Concretely, such conditions
ensure that the whole mining power of correct processes
will be used towards appending the pre-selected transac-
tion, tselected, to their chains and continuing building on a
chain with tselected (without replacing the chain containing
tselected with alternative chains with a conﬂicting transac-
tion) until tselected eventually is followed by enough blocks
to commit (in the same way as with transactions issued by
correct processes).

However, the selection step (1) of this approach implic-
itly requires solving consensus, which is precisely what BBP
achieves. Hence, anticipating one consensus protocol with
another one does not suggest any tangible advantage.

The design of NimbleChain is inspired by the high-level
recipe of this straw man proposal. We introduce fundamen-
tal adaptations to the above recipe to reach a practical and
effective approach.

5

Fig. 1: Transaction life cycles in NimbleChain.

In a nutshell, NimbleChain handles transactions accord-
ing to two parallel paths, which we call the fast and slow
paths. Transactions are handled in each path through distinct
protocols and NimbleChain consolidates their outcomes to
ensure they reach consistent decisions. These paths relate to
the straw man proposal as follows: the selection step (1) is
replaced by NimbleChain’s fast path, and the deterministic
BPP commit step (3) by NimbleChain ’s slow path.

At the core of this adaptation lies a fundamental disrup-
tion: the selection stage – as implemented by NimbleChain
’s fast path – no longer resorts to consensus. More precisely,
the fast path promises transactions through a lightweight
consensusless ageing-based protocol. This protocol is best-
effort by nature, in the sense that, in worst-case scenarios,
one or more correct processes pundecided may not be able to
promise in the fast path. As we explain next, such scenarios
only arise due to double-spend transactions.

The key insight of NimbleChain is that, if at least one
correct process pdecided promises a transaction tselected, then
every correct process pundecided will actively contribute to
the deterministic BBP commit of tselected (instead of any
transaction conﬂicting with tselected). Therefore, the full
set of correct processes engages in the deterministic BBP
commit of tselected. This ensures that, with high probability,
BBP will eventually commit t and, hence, even pundecided
will later promise/commit tselected.

From the perspective of a process p, the life cycle of a
transaction t can follow one out of the scenarios that Figure
1 depicts:

• Process p may promise t ﬁrst via the fast path and,
later, commit t via the slow path (Figure 1 top).
• Alternatively, p may not be able to reach a fast-path
decision for t and, later, the slow path commits t –
this means that t is simultaneously promised and
committed (Figure 1 bottom).
Finally, p may decide to not promise t in the fast
path and, subsequently, the slow path decides to
not commit t (for being part of a double-spending
attempt), which implies that t is discarded (in other
words, the process decides to neither promise nor
commit t).

•

Table 1 summarizes the essential differences between

both paths.

double spendingtfast pathagep(t)slow path (Bitcoin Backbone Protocol)tttimep issues/receives tp promises tp commits ttfastpathslow path (Bitcoin Backbone Protocol)ttimeP receives tp promises+commits t or t'successfully agedno fast pathdecisionP receives t't'ort'System
Ethereum

NimbleChain

Event
Commit
Promise
Commit

Double-spending-resistant
Yes
Yes
Yes

Consistency
Total order
Causal
Total+causal ∼3m

Latency
∼3min
Typically ∼4s to ∼25s

Consensus-based
Always
Typically no
Always

TABLE 1: Summary of the promise/commit events in NimbleChain, compared to Ethereum (as an instance of BBP).

6

Algorithm 1: Ageing protocol (NimbleChain ’s fast
path)

Fig. 2: Local state of a process in NimbleChain.

4.2 Main algorithm

We now present the main algorithm of NimbleChain, which
materializes the insight described previously. For presen-
tation simplicity, we here assume that transactions have
no causal dependencies, hence different correct processes
are free to commit them in arbitrary orders. We lift this
simpliﬁcation in §4.4.

In NimbleChain, the state maintained by each process
corresponds to BBP state (namely, a local chain and a mem-
pool), plus extra metadata for each transaction as depicted
in Figure 2. Next, we detail the algorithms of the main
components of NimbleChain, its fast and slow paths.

Fast path: transaction ageing. The fast path protocol con-
sists of the ageing protocol in Algorithm 1, which leverages
the a-priori knowledge of a maximum propagation delay D.
When receiving a transaction t, a process p assigns to t
a timestamp based on p’s local clock. From that instant on,
we say that t is ageing (ln. 23).

We denote by agep(t) the age of a transaction t at process
p. Its value is determined by function age in Algorithm 1,
depending on whether t is already aged (ln. 7), still ageing
(ln. 10) or in none of such states (ln. 12).

Initially, agep(t) =⊥. Once a transaction starts aging, its
age is measured in units of D. We also deﬁne a system-
wide parameter ageing threshold (AT). AT has a minimum
value of 4 but it can assume other values, which provide a
trade-off between latency and resiliency which we analyze
in further detail in §4.3. For presentation simplicity, this
section assumes AT = 4.

If t ages up to AT without p receiving any double-spend
of t, we say that t has successfully aged at p. As a result, p
promises t (ln. 19). As an important corollary, transactions
issued by correct processes (which, by deﬁnition, do not
have double-spends) will always successfully age and hence
be promised in the fast path at every correct process. As we
discuss in §4.4, causal dependencies may introduce some
exceptions to this corollary.

If, otherwise, p receives a transaction t(cid:48) that conﬂicts
with t before p has promised t, p stops the ageing of t and
registers for how long t had aged until then (i.e., agep(t) is
frozen at such value, see ln. 29). In this case, the fast path
has not been able to promise t. Therefore, p needs to wait
for the eventual commit or discard of t through BBP’s slow
path.

1 Initially
2

ageingTxs ← ∅;
agedTxs ← ∅;

4 Function age(transaction t)):
5

(tprevious, age) ←
lookup(agedTxs, t.issuer, t.seqno);
if tprevious then
return age;

(tprevious, receivedtime) ←
lookup(ageingTxs, t.issuer, t.seqno);
if tprevious then

return now − receivedtime;

else

return ⊥;

13 Procedure AgeingMonitor:
14

while true do

15

16

17

18

19

for each (t, receivedtime) in ageingTxs do

if now − received = AT then
remove(ageingTxs, t);
add(agedTxs, (t, AT ));
promise(t);

20 Upon receiving transaction t:
21

tprevious ←
lookup(agedTxs ∪ ageingTxs, t.issuer, t.seqno);
if tprevious = null then

add(ageingTxs, t, now);

else

if tprevious (cid:54)= t then

reject t from mempool;
(tprevious, receivedtime) ←
lookup(ageingTxs, t.issuer, t.seqno);
if tprevious then

remove(ageingTxs, tprevious);
add(agedTxs, (t,
now − receivedtime));

3

6

7

8

9

10

11

12

22

23

24

25

26

27

28

29

Further, since t(cid:48) was received when p was already ageing
a conﬂicting transaction (t), p rejects t(cid:48) from its mempool (ln.
26) and, furthermore, does not age t(cid:48). Therefore, agep(t(cid:48))
remains ⊥. Consequently, when multiple transactions con-
ﬂict, a correct process p will only age one of them (either
successfully or not), i.e., the ﬁrst transaction that p received
among multiple conﬂicting transactions.

Figure 3 illustrates both scenarios, the successful and
unsuccessful ageing of a transaction. Most transactions suc-
cessfully age (thus are promised via the fast path) before

Local state of a processageageageageageLegendttt...blockchainmempoolpromised+committedpromisedttttttttttttttttttblock i-1...block iblock i+Cstill ageingttttunsuccessfully aged (due to double-spending)Blocks committed by BBP7

Algorithm 2: C-bound deterministic BBP commit
(NimbleChain ’s slow path)
1 Upon receiving chain b0, ..., bn:
2

for each bi(0 ≥ i ≥ n) not yet in the local chain do

3

4

5

for each transaction t ∈ bi do
if RSS(t) > n − i then

reject chain sufﬁx bi, ..., bn;

/* Simplest implementation

6 Function RSS(transaction t)):
7

if age(t) ≥ AT − 2 then

8

9

10

return C;

else

return 0;

/* Progressive variant (see §4.3)

11 Function RSS(transaction t)):

/* Assuming AT = 2(C + 1)
return (cid:98)agep(t)/2(cid:99);

12

*/

*/

*/

for speciﬁc transactions. These extensions affect the incom-
ing transaction and chain validation routines3 , which are
external to BBP and, thus, can be modiﬁed without hurting
the correctness of the underlying BBP. We provide details on
our concrete extension of Ethereum in §6.1.

Intuitively, the goal is to have any correct process p
engage (through its local BBP node) in the deterministic
BBP commit of some transaction t as soon as either: i) p
has promised t; or ii) p is aware that at least one other
correct process may have already promised t. NimbleChain
implements the above goal by having each process p engage
in the deterministic BBP commit of t as soon as agep(t)
reaches a value of AT − 2 (or higher).

To illustrate, let us consider the example depicted of
Figure 4 (top). In this example, at least one correct process
pA promises t ( 3(cid:13) in Fig. 4, top), once agepA (t) = AT .
From Lemma 1, we know that any correct process pB with
a diverging view on t’s age will, in the worst case, have
agepB (t) = AT − 2 = 2 ( 4(cid:13)), with high probability. There-
fore, every correct process (including pA and pB) will, with
high probability, engage in the deterministic BBP commit of
t. This ensures that BBP’s slow path will eventually commit
t ( 5(cid:13)) with high probability. In fact, even if some correct
processes do not promise t in their fast path – namely,
if they receive a double-spend of t that prevents them
from successfully ageing t ( 2(cid:13)) – such processes will later
promise+commit t once they learn about the slow path’s
decision.

Figure 4 bottom illustrates another possible scenario
where agepi(t) lies between 0 and 2 across different correct
processes. In these scenarios, correct processes such as pA
reach a state with agep(t) = 2 ( 3(cid:13) in Figure 4, below) and
thus engage in the deterministic BBP commit of t and reject
chains with any double-spending transaction t(cid:48). In contrast,
other correct processes such as pB observe lower values of

3. More precisely, inside the content validation predicate (V (·)) and the
environment (more precisely, where the input tapes of each process are
determined) according to Garay et al.’s terminology [17].

Fig. 3: Examples illustrating that the age of some transaction
t at different processes can diverge up to 2.

reaching the local committed chain. Transactions issued by
malicious processes that are part of a double-spend may
have their ageing stopped, and their outcome will only be
eventually decided by BBP’s slow path.

It is worth noting that, since transactions are delivered
at different times at distinct processes, their ageing state is
not guaranteed to be consistent across the system. Figure 3
illustrates some possible inconsistencies. It may occur that
t successfully ages (thus, is promised in the fast path) in
some processes (within an interval of D), but does not in
others. Further, in those processes where t does not age
successfully, its age may be ﬁxed at different values (at
distinct processes). Still, since the behaviour of the broadcast
layer is bounded by a maximum delivery delay (D), the
following lemma is satisﬁed.

Lemma 1. If a correct process p successfully ages a transaction
t (i.e., agep(t) = AT ) then, with high probability: (1) for any
correct process q, ageq(t) (cid:54)=⊥ and ageq(t) ≥ AT − 2; further,
(2) for any transaction t(cid:48) that conﬂicts with t, then ageq(t(cid:48)) =⊥
for every correct process q.

that either

Proof. (1) Suppose, by contradiction,
(a)
ageq(t) < AT − 2 or (b) ageq(t) =⊥; this implies that either
(a) q received t(cid:48) either less than 2D after q ﬁrst received t,
or (b) that q received t(cid:48) before t, respectively. It is easy to
show that, since p received t ﬁrst and t(cid:48) more than 4D after
(since agep(t) = AT ), hypothesis (a) and (b) only occur
in executions where t or t(cid:48) was delivered at q or p (resp.)
more than D after they were broadcast by their issuer, which
contradicts the assumption of a bounded delivery delay, D.
(2) Suppose, by contradiction, that ageq(t(cid:48)) (cid:54)=⊥. This implies
that q received t(cid:48) before t, which corresponds to hypothesis
(b) above, which is impossible under the bounded delivery
delay assumption.

Slow path: deterministic BBP commit. We now focus on
the slow path of NimbleChain. The slow path uses BBP as
its back-end to agree on committing or discarding trans-
actions. By taking advantage of the extensible design of
BBP, we customize it with relatively simple extensions that
enable NimbleChain to trigger deterministic BBP commit

4 (AT)tDProcess p1Process p2agep1(t) =agep2(t) =01234 (AT)0123ttp1 promises tp2 promises t13tDProcess p1Process p2agep1(t) =agep2(t) =0120p1 stops ageing tt'p2 stops ageing tDdoublespending8

Fig. 4: Example of NimbleChain handling a transaction that is part of a double-spending attempt, with AT = 4. Top:
transaction successfully ages (thus, is promised via fast path) in at least one correct process. Bottom: transaction does not
successfully age in any correct process.

agepB (t) and, thus, remain open to accept chains with either
t or t(cid:48) ( 4(cid:13)). This can be problematic if the Byzantine process
that issued the double-spend further manages to extend the
current main chain with a new block comprising t(cid:48). In this
situation, processes like pA will reject such new chain, while
processes like pB will accept the new chain (by the longest
chain rule of BBP).

We call this a fragmentation attack. It introduces an artiﬁ-
cial fork that divides the mining power of correct processes
across two fragments, denoted A and B in Figure 4. While
the fragmentation persists, it may harm the robustness of
BBP.

While the correct system is fragmented, the attacker’s
mining power will be temporarily closer to the largest
correct fragment’s mining power. In an extreme scenario,
a resourceful attacker that manages to execute a successful
fragmentation attack (or a series of fragmentation attacks)
might beneﬁt from temporary supremacy over the correct
system. This would provide the attacker with an opportu-
nity window to generate an alternative chain at faster than
the system of correct processes., For instance, this faster
generated chain could be used to commit a double-spending
transaction t(cid:48) that conﬂicts another transaction t that the
correct system had previously promised or committed. Note
that, to succeed, this attack requires that the temporary
mining supremacy (as enabled by the fragmentation attack)
last long enough for the attacker to generate C blocks.

Hence, NimbleChain needs to be able to self-heal upon
any successful fragmentation attack. To explain how Nim-
bleChain achieves that, Figure 4 bottom depicts the two pos-
sible scenarios that may occur upon a successful fragmenta-
tion attack. A ﬁrst fragmentation scenario ( 5(cid:13)) is when the
fragment of correct processes engaged in the deterministic
BBP commit of t are able to grow their chain faster than the

opposite fragment (holding a chain with t(cid:48)), but not vice-
versa. It is easy to show that this fragment will be naturally
healed by BBP’s longest chain selection rule as soon as the
main chain grows to be larger than the opposite fragment’s
chain. This may require between 2 and C new blocks.

The second scenario ( 6(cid:13)), however, may take longer to
heal. In the case where the fragment holding a chain with
t(cid:48) happens to have the majority of correct processes, then
it is likely that this chain will tend to grow faster than the
chain with t. This implies that the chances of the above-
mentioned merging with the t(cid:48) chain will quickly drop to
a negligible probability, which would tend to produce a
permanent fragmentation.

NimbleChain prevents the possibility of a permanent
fragmentation by employing a C-bounded deterministic BBP
commit. Algorithm 2 presents this method, which we ex-
plain next.

The method is based on a notion that we call the required
replacement sufﬁx (RRS) for a transaction t on some process
p, or simply RRSp(t). In its simplest formulation (ln. 6),
RRSp(t) is C for those transactions which p has aged to
at least AT − 2 (i.e., the age that makes p engage in the
deterministic BBP commit of a transaction); and 0 otherwise.
When a process p receives a new chain that contains
some transaction t(cid:48) that conﬂicts with a transaction t that
p has seen before, the decision about whether to accept the
conﬂicting chain is driven by the current value of RSSp(t).
More precisely, the conﬂicting chain is only accepted if the
block containing t(cid:48) is sufﬁxed by at least RSSp(t) blocks (ln.
5).

In practice, this condition has no effect when t has not
yet aged up to AT − 2 (hence, RSSp(t) = 0). Otherwise,
it means that p had already engaged in a deterministic BBP
commit of t (thus, RSSp(t) = C) and, as such, p will reject

...b1b0tb0tb'1tall correctprocessesagepA(t)=4RSSpA(t)=CagepB(t)=2RSSpB(t)=Cb0tt'④b1b0tb1+Call correctprocessestimesomecorrectprocessessomecorrectprocesses①②③⑤...pA promised tall committed t...b'1b0tb0t'b1b0b'1tall correctprocessesagepB(t)=0RSSpB(t)=0agepA(t)=2RSSpA(t)=Cb0tall correctprocessest'④timeb1+khealing time:2 to C new blocks in main chainfragment Afragment B①②③⑥...b'1b0t'all correctprocessesb'1+Cthealing time:C new blocks in main chain⑤all committed t'any chain that contains any double-spend t(cid:48) except if the
block with t(cid:48) is followed by at least C blocks in that chain –
i.e., t(cid:48) is committed. In this case, such process will accept the
chain containing t(cid:48) and, consequently, promise+commit t(cid:48)
and discard t. Consequently, the C-bounded policy ensures
that, in this worst-case scenario, the fragmentation is healed
after C blocks are generated.

Finally, we remark that adopting a C-bound determin-
istic BBP commit approach (instead of an unbounded ap-
proach) still ensures that NimbleChain handles the ﬁrst
fragmentation scenario ( 5(cid:13)) robustly. Recall the assumption
behind the persistence property of BBP: the probability
that Byzantine processes are able to generate a fork C-
blocks long (relatively to the main chain) faster than the
correct processes is arbitrarily low. Further, consider the ﬁrst
fragmentation scenario where a correct process pA promises
t while correct process pB with agep2 (t) = 2 engaged in
a C-bounded deterministic BBP commit of t. Now, let us
suppose, per impossible, that, before BBP commits t, pB
accepts a chain where t(cid:48) (a double-spending of t) is sufﬁxed
by C blocks – therefore not only pB would commit t(cid:48), but
would also withdraw its contribution to the deterministic
BBP commit of t. However, for such a chain containing t(cid:48) to
exist, it must have been generated by Byzantine processes,
which contradicts our initial assumption.

4.3 Trading fast path latency for robustness

The previous section showed that, with the minimal AT = 4
value, a single fragmentation attack may take up to C
rounds to heal. In this section, we explain how NimbleChain
can be conﬁgured to substantially mitigate the chances
of success of the above attack. The key idea is that, by
increasing AT , NimbleChain can reduce the time it takes
to heal fragmentation attacks from C to the time it takes for
the fastest fragment’s chain to generate 2 blocks, with high
probability. This improved robustness comes at the cost of a
higher fast path latency.

Before describing how NimbleChain can reduce the
above vulnerability window, let us recall the two fragmen-
tation scenarios in Figure 4, which assume AT = 4. In both
scenarios, every correct process has received transaction t
and an attacker is mining an alternative chain that contains
a double-spend transaction t(cid:48). While some correct processes
will accept the alternative chain as long as it meets the
standard BBP requirements, others will be more reluctant
and impose the additional constraint that, in the alternative
chain, the block with t(cid:48) must be followed by at least C
blocks.

As shown in Figure 4, with AT = 4, RRSpi(t) may differ
between 0 and C for different correct processes. Intuitively,
this upper bound on the divergence across RRSpi(t) di-
rectly determines the time – in terms of block generation
rounds – that a fragmentation attack may take to heal.
Therefore, if we can lower this upper bound, ideally down
to 1, we can minimize the healing time.

We achieve this by extending the algorithm described in
the previous section with a progressive variant (ln. 11, Alg.
2) where each process gradually increments RRS in 2D
steps. More precisely, we deﬁne RRSp(t) = (cid:98)agep(t)/2(cid:99). To
enable this progressive variant, while ensuring that p only

9

promises transaction t once every correct process pi is en-
gaged in a C-bounded BBP commit of t (i.e., RRSpi(t) = C),
we need to redeﬁne AT = 2(C + 1).

As an example, suppose that process p receives a trans-
action t. Initially, RRSp(t) = 0. If p does not observe any
double-spend of t, RRSp(t) will grow to 1, 2, ... every 2D,
until it reaches RRSp(t) = C once agep(t) = C × 2D.
Finally, 2D later, t successfully ages at p and, hence, p
promises t (at agep(t) = 2(C + 1)).

To understand the impact of this new conﬁguration,
Figure 5 revisits the fragmentation scenarios from Figure 4.
As before, a successful fragmentation attack has split the set
of correct processes into two divergent fragments: fragment
A, whose processes hold t in their local ledger and now have
RRSpA (t) = 1 (instead of RRSpA (t) = C as per the orig-
inal formulation); and fragment B, whose processes have
RRSpB (t) = 0 and, consequently, have accepted a chain
with transaction t(cid:48), a double-spend of t, which the attacker
produced and disseminated. On the one hand, a process
in fragment A does not accept the chain held by fragment
B, since it holds a block with a double-spend of t that is
not sufﬁxed by at least one block (due to RRSpB (t) = 1).
On the other hand, a process in fragment B will not accept
the chain of fragment A since it has a lower height than
fragment B’s main chain (due to the longest-chain rule).

Let us ﬁrst consider the scenario where fragment A is
faster in extending its chain ( 5(cid:13)) than fragment B. In this
case, as soon as A’s chain grows 2 blocks, processes in B will
start accepting that (according to the longest-chain rule). Let
us, instead, analyse the reverse situation, where fragment
B’s chain grows faster ( 6(cid:13)). The fragmentation may now
heal as soon as fragment B appends a single new block to its
chain. These represent substantial improvements in healing
time relatively to the AT = 4 conﬁguration, which could
take up to C blocks to heal in worst-case scenarios. .

We remark that the above upper bounds are also ob-
served in concurrent scenarios, where more than one block
is produced either at the same fragment or across different
fragments. Furthermore, we highlight that the 1 or 2 blocks
needed to heal a fragmentation can be produced by any pro-
cess in either fragment, which means that the healing speed
is determined by the aggregate resources of the correct
nodes (i.e., not restricted to the largest correct fragment’s
resources). For generality, it is easy to prove that these
upper bounds on the healing time are also valid to scenarios
where: i) the fragmentation attack occurs when t had a
higher age; and, ii) the fragmentation attack simultaneously
aims at multiple double-spending transactions. For space
limitations, we omit the analysis of such scenarios in the
paper.

Summing up, NimbleChain can be conﬁgured between
two extremes and offer a trade-off between fast path la-
tency and robustness against fragmentation attacks. Table 2
summarizes the trade-off between both extremes of AT . For
intermediate AT conﬁgurations, we can have RRS grow in
increments of k units such that 1 < k < C.

4.4 Ensuring causal order

We now describe how NimbleChain handles causal depen-
dencies consistently across the slow and fast paths. Depen-
dencies are speciﬁed in an additional transaction ﬁeld using

10

Fig. 5: Example of NimbleChain healing from a fragmentation attack, with its most robust conﬁguration (AT = 2(C + 1)).

AT

Upon successful ageing

Upon fragmenta-
tion

Causal commit
latency

4
2(C+1)

4D
2D(C + 1)

Speedup
(vs. BBP commit)
C/4r
aprox. r/2

Healing time

up to C × B
up to 2B

TABLE 2: Trade-off between causal commit performance
and fragmentation healing time in function of AT . The
speedup is relative to a BBP commit latency of C × B.

some suitable causality tracking mechanism. Moreover, the
mempool comprises two distinct queues: a ready queue,
which contains the transactions that are ready to be included
in the next block; and a pending queue, which contains trans-
actions that, despite being valid, are still missing causal de-
pendencies. More precisely, for any transaction t appended
to the mempool’s ready queue, every transaction on which
t causally depends on must already be promised in that
process. Note that this condition implies that the transac-
tions on which t causally depends will precede t in the local
ledger’s order. Any valid transaction that does not (yet)
satisfy the previous condition is temporarily enqueued in
pending. Furthermore, whenever a process promises a new
transaction, the dependencies in pending are re-evaluated
and any transaction whose dependencies are satisﬁed is
moved to the ready queue.

It is worth noting that the mempool of mainstream
blockchain implementations already include both queues.
For instance, in account-based blockchains (such as Ethe-
reum), when a process receives a transaction with a se-
quence number that is not consecutive to the latest known
transaction from the same account, it is placed in a pending
queue until the gap in sequence numbers is ﬁlled. Nim-
bleChain reuses such existing queue. Still, NimbleChain
adds the additional condition that, besides sequence num-
ber dependencies, any explicit dependencies of the transac-
tion must also be met before it is moved to the ready queue.
Further, NimbleChain ensures that any transaction in a
block that a correct process tries to generate is preceded
(in the corresponding chain order) by its causal dependen-
cies. Moreover, causal dependencies are also enforced for
transactions in chains received from processes – if the causal
dependencies are not satisﬁed the chain is discarded.

Causal dependencies affect both paths of NimbleChain.
Regarding the fast path’s ageing protocol, a transaction t
that successfully ages will not be promised until all of its

dependencies were promised. Concerning the slow path,
the above-mentioned constraints ensure that the underlying
BBP will only handle transactions whose causal dependen-
cies are promised.

Finally, we remark that, while the algorithm described in
the previous sections ensured that every transaction issued
by a correct process would be promised via the fast path
at every correct process, this no longer holds when trans-
actions have causal dependencies. As an example, suppose
that a correct process p has promised a transaction t1 that
was issued by a Byzantine process as part of a double-
spend attempt; and, after observing t1, p issues t2, which
causally depends on t1. Recall that, since t1 is part of a
double-spending attempt, t1 may not successfully age (i.e.,
be promised via fast-path) at some (or all) process. In that
case, some (or all) processes will only promise t1 via the
slow path. Hence, even though t2 was issued from a process
that had promised t1 via its fast path, the processes that had
not done so will delay t2’s commit until the outcome of t1 is
determined by the slow path.

4.5 Correctness

We next prove that that NimbleChain, with high probability,
satisﬁes the properties associated with the new promise
event (as introduced in §3).

In the following, we assume that there is a negligible
probability that an attacker, by spending a slice x of its
mining power to perform a fragmentation attack (or a series
of fragmentation attacks) for some period T , manages to
reduce the average mining power of the largest correct
fragment by more than x during T . In §6, we empirically
support this assumption based on an experimental evalua-
tion of NimbleChain when operating under fragmentation
attacks.

Theorem 1. NimbleChain satisﬁes the eventually committed
upon promised property with high probability; i.e., if a correct
process promises a transaction t then all correct process eventually
commit t.

Proof. Assuming no causal dependencies. We start by con-
sidering the case where t has no causal dependencies. We
distinguish two cases, depending on whether t is issued
correctly or not.

Case 1: t issued correctly. In this case, the t will always
successfully age at every correct process and, hence, every

b'1b0tb0t'b1b0b'1tall correctprocessesagepB(t)=0RSSpB(t)=0agepA(t)=2RSSpA(t)=1b0tall correctprocessest'④timehealing time: 2 new blocks in main chainfragment Afragment B①②③⑥thealing time: 1 new block in main chain⑤b'1b0all correctprocessesb'2t'b2process will promise t. Furthermore, in this case, the slow-
path commit of t simply follows BBP with no modiﬁcations.
Therefore, since BBP guarantees the liveness property, every
correct process (which inevitably promises t) will eventually
commit t.

Case 2: t issued by a Byzantine process as part of
a double-spending attempt. Now, let us consider that t
is issued by a Byzantine process that also issues at least
one double-spending transaction t(cid:48) with the same sequence
number as t. Consider T0 as the time some correct process
p promises t. Therefore, at T0, t has already aged at least
AT at p; consequently, by Lemma 1, at T0, in every other
correct process, t has aged for at least AT − 2. This implies
that, at T0, every correct process has engaged in a C-bound
deterministic BBP commit. Hence, at T0, every correct pro-
cess will refuse to include t(cid:48) in its mempool and will reject
any chain containing t(cid:48) unless t(cid:48) is followed by C blocks in
that chain. Let us assume, by contradiction, that, with non-
negligible probability, at some later time, Tt(cid:48) , process q is the
ﬁrst correct process that receives and accepts a chain with t(cid:48)
followed by C blocks, thereby committing t(cid:48). From T0 until
Tt(cid:48) , every correct process excludes t(cid:48), while t is processed (as
a valid transaction) by the correct system. Hence, during this
period, the correct processes treat t in the same way as any
transaction issued by a correct process (i.e., the processing
of t is not affected by the fact that there is a conﬂicting
transaction, t(cid:48)).

By our initial assumption, with non-negligible probabil-
ity, a correct process q commits t(cid:48) at Tt(cid:48) , upon receiving a
chain that must have been produced by a Byzantine process
(or system of processes). By BBP’s persistence property, this
implies that no correct process had been able to commit t
at Tt(cid:48) . Therefore, our initial assumption allows a Byzantine
process (or system of processes) to be able to generate, with
a non-negligible property, a (C + 1)-long chain (the chain
comprising a block with t(cid:48) followed by C blocks) faster
than the system of correct processes. This corresponds to
Nakamoto’s formulation of a double-spending attack [45],
which constitutes a well-known violation of BBP’s persis-
tence property. Therefore, the initial assumption must be
false. Consequently, every correct process will eventually
commit t, which is the same transaction that p promised.

Generalizing to causal dependencies. We now gener-
alize to transactions with non-empty causal dependency
sets. This case can be proved by induction over the partial
order deﬁned by the causal dependency relation. Let us
consider that transaction t depends on t1, t2, ..., tn and a
correct process p promises t. The only difference in this case,
when compared to cases 1 and 2 above, is that for a correct
process q to commit t, there is now an additional condition
that must be met, i.e., that q has already committed t’s causal
dependencies. Let us assume, by contradiction, that at least
one causal dependency of t, say ti, is never committed
by q, which consequently prevents t from ever committing
at q. By the causal order property, we know that, since p
promised t, then p must have already promised every causal
dependency of t, including ti. Therefore, the eventually com-
mitted upon promised property implies that ti will eventually
commit at every correct process, which contradicts the initial
assumption.

11

Theorem 2. NimbleChain satisﬁes the causal order property
with high probability; i.e., if a correct process promises (resp.,
commits) a transaction t then that process has already promised
(resp., committed) every transaction on which t causally depends.

Proof. Suppose, by contradiction, that a correct process
promises transaction t2 before it has promised transaction
t1, where t2 causally depends on t1. This implies that t2
had been added to p’s ready queue, which could only
happen after p had promised t1, which contradicts the initial
hypothesis. The causal order regarding the commit event
can also be proved by a similar contradiction argument.
Assume, by contradiction, that correct process p commits t2
before p has committed t1, where t2 causally depends on t1.
Hence, t2 exists in a block in p’s local chain. This block has
either been generated by p with transactions taken from p’s
ready queue, or generated by another process and received
by p. In either way, since any transaction in a new block
(generated or received by p) has its causal dependencies
satisﬁed in the corresponding chain, then p’s chain also
includes t1 in a preceding position (in the same block as
t2 or in a preceding block). Consequently, if p committed
t2 since its block is sufﬁxed by C blocks, then p must have
committed t1 before that instant. This contradicts the initial
hypothesis.

Since NimbleChain’s slow-path consists of an instance
of BBP customised with two extensions that do not modify
the backbone protocol that is presented and analysed in
[17], the persistence and liveness properties of BBP are
naturally satisﬁed by NimbleChain. Therefore, we skip the
corresponding proofs.

5 LOW-LATENCY CRYPTOCURRENCIES WITH NIM-
BLECHAIN

As discussed in §2.4, a notable application that can beneﬁt
from the weaker guarantees of the promise event provided
by NimbleChain is a cryptocurrency. We now detail how.

A cryptocurrency can be abstracted as as an instance of
the asset-transfer object type deﬁned by Guerraoui et al.
[21]. An asset transfer object maintains a set of accounts,
where each account is associated with an owner client that
is the only one allowed to issue transfers withdrawing
from this account. To do so, the owner client can invoke
a transfer(a,b,x) to transfer x from account a to account b.
There is a second operation, read(a), which every process
can invoke to read the balance of account a.

Traditional permissionless blockchains, such as BBP, im-
plement the asset-transfer object type by relying on the
consensus-based commit event, as follows.

•

•

transfer(a,b,x). When the process that owns account
a wishes to execute transfer(a,b,x), it reads the current
balance of a (see next) and, if the balance is sufﬁcient,
issues a new transaction whose payload transfers x
from account a to account b.
read(a). The read(a) operation is implemented by
returning a’s balance from the state that results from
the ordered execution of every committed transac-
tion in the local chain.

Guerraoui et al. [21] prove that, in fact, the asset-transfer
object type can be correctly implemented in a consensusless
fashion. They also present (and prove correct) an actual con-
sensusless implementation of the asset-transfer object type
based on message passing. The algorithm they propose re-
lies on a secure broadcast layer that exposes a broadcast and
a deliver event (for messages), while offering uniform reli-
able delivery with source order guarantees despite Byzantine
faults. The complete algorithm by Guerraoui et al. deﬁnes
which state each process maintains in order to know, in an
efﬁcient way, which outgoing transactions have been issued
by that process, as well as which incoming transactions have
delivered and validated at that process. Further, it deﬁnes
how, based on that state, the causal dependencies ﬁeld of a
newly-issued transaction can be efﬁciently encoded.

We can port their approach to NimbleChain by replacing
the underlying secure broadcast layer with NimbleChain.
Concretely, by simply replacing the broadcast and deliver
events in Guerraoui et al.’s algorithm with the issue and
promise events of NimbleChain ’s interface. The key insight
to this transformation is that the properties that Guerraoui
et al. require from the secure broadcast layer (namely, in-
tegrity, agreement, validity and source order [21]) are also
satisﬁed by NimbleChain ’s promises with high probability.
We prove this later on this section.

Below, we present a high-level summary of the algorithm
that results from porting Guerraoui et al.’s to rely on Nim-
bleChain ’s interface. For lower-level details, we refer the
reader to [21].

•

•

transfer(a,b,x). When a processes p that owns ac-
count a executes the transfer(a,b,x) operation, it con-
ﬁrms that account a has enough funds and, if so,
issues a transaction t, whose payload describes the
requested operation. Further, the causal dependen-
cies ﬁeld of the new transaction t is the set of transac-
tions comprising: i) every previously issued outgoing
transfer transaction (i.e., transferring funds from a);
and ii) every incoming transaction (i.e., transferring
funds to a) already promised by process p.
read(a). The read(a) operation is implemented by
returning a’s balance from the state that results from
the ordered execution of every promised transaction
in the local chain.

Recall that, for most transactions, NimbleChain ’s fast-
path ensures that most correct processes are able to promise
such transactions much sooner than the time that BBP slow-
path takes to commit them. Therefore, the above implemen-
tation of the asset-transfer object achieves important latency
improvements.

The above promise-based implementation is correct ac-
cording to the speciﬁcation of the asset-transfer object type
[21]. In other words, the above implementation correctly
supports a cryptocurrency. The following lemma states this.

Lemma 2. The proposed promise-based implementation of trans-
fer(a,b,x) and read(a) is a correct implementation of an asset-
transfer object type [21].

12

correct in [21], we prove that NimbleChain’s issue and
promise events satisfy, with high probability, the properties
of the secure broadcast layer underlying Guerraoui et al.’s
implementation. We take the properties of the broadcast
layer that underlies Guerraoui et al.’s algorithm (namely,
integrity, agreement, validity and source order [21]) and re-
formulate them by renaming the broadcast and deliver events
by the issue and promise events (of our proposed blockchain
model), respectively, the resulting properties are satisﬁed by
NimbleChain with high probability.
Integrity: a correct process promises a transaction t from a process
p at most once and, if p is correct, only if p previously issued t.
This is ensured since transactions in BBP are digitally signed
and carry a unique identiﬁer.
Agreement: if processes p and q are correct and p promises t,
then q promises t. Let us recall that, if a correct process p
promises some transaction t, then p eventually commits t
(by the eventually committed upon promised property). Hence,
any other correct process q also eventually commits t (by
BBP’s persistence property), thus, by deﬁnition of promise,
q also promises t.
Validity: if a correct process p issues t, then p promises t. This is
ensured since any transaction t issued by a correct process
p is eventually committed by p (by BBP’s liveness property)
therefore, by deﬁnition of promise, p also promises t.
Source order: if p and q are correct processes and both promise
transactions t and t(cid:48), both issued by the same process r, then
they do so in the same order. Let us ﬁrst consider the case
where t and t(cid:48) have distinct sequence numbers. Therefore,
the causal order property guarantees that both p and q
will promise both transactions in order deﬁned by their
sequential numbers. Let us, instead, assume by contradic-
tion that t and t(cid:48) have the same sequence number and are
promised by p and q. Therefore, by the eventually committed
upon promised property, p and q will eventually commit both
transactions. Still, by deﬁnition, distinct transactions with
the same sequential number are conﬂicting and, therefore,
at most one of them can be committed. This contradicts the
initial assumption.

We conclude with two ﬁnal remarks. First, although
Guerraoui et al.’s algorithm was originally proposed in
the context of permissioned systems, adapting it to exploit
NimbleChain ’s primitives enables it the work in per-
missionless environments. Furthermore, while the original
proposal supported a stand-alone cryptocurrency system,
the above adaptation to NimbleChain integrates the low-
latency cryptocurrenty in a richer ecosystem where other
applications with stronger consistency requirements may
also co-exist. For instance, this hybrid consistency ecosys-
tem enables processes to issue smart contract transactions
(via the issue/commit interface), whose execution costs are
charged from cryptocurrency accounts which may receive
incoming transfers as deﬁned above (via the issue/promise
interface).

6 EVALUATION

Proof. To show that the above implementation is equivalent
to Guerraoui et al.’s message passing asset-transfer object
implementation, which was originally proposed and proved

In this section, we evaluate NimbleChain with the goal of
answering the following questions: i) what are the latency
improvements that NimbleChain brings to applications with

13

cated the estimated mining power of the top-13 most pow-
erful mining pools of Ethereum to a subset of 13 processes
(concretely, 24.0%, 21.3%, 13.2%, 12.1%, 5.7%, 1.9%, 1.8%,
1.5%, 1.4%, 1.3%, 1.1%, 1.0% and 1.0%, according to [15]).
The remaining mining power was uniformly distributed
across the remaining 487 processes.

We adjusted the block production probability to mimic
Ethereum’s rate of 3 blocks per minute [15]. Moreover, we
extended both NimbleChain and Ethereum implementa-
tions to log transaction events such as generation, reception,
dissemination and state change and block events (such as
insertion to the local chain and forks) to allow a posteriori
ofﬂine processing for our evaluation. We use the same
codebase, client and PoW component for the NimbleChain
and Ethereum. Every correct process is parameterised with
C = 12, the current standard commit threshold in Ethe-
reum [61].

We ran each experiment for one hour with 500 processes
for both NimbleChain and Ethereum, using 5 machines
equipped with a mix of Intel(R) Xeon(R) CPUs. We empir-
ically found this conﬁguration of machines to be able to
accommodate 500 processes without becoming overloaded
and hence compromising the ﬁdelity of the results. The
processes run on an emulated network using Kollaps [20]
with internet latencies to model the geo-distributed na-
ture of permissionless blockchains. As suggested by pre-
vious measurement studies [18], [54], we used an aver-
age latency value of 120ms, and a conservative value for
D = 8 × 120ms = 960ms. Each node started with the same
local chain, consisting of a single genesis block. We injected
8 transactions per second, as common in Ethereum [15]. All
results are the average of 5 runs.

6.2 Promise and commit latencies

In this section, we study transaction latency as perceived
from a process p, which we deﬁne as the time from the
moment a given transaction t is issued (at some process, not
necessarily p) and the moment p triggers the event that is
required by the application semantics associated with t (i.e.,
either promise or commit). We evaluate transaction latency
for two transaction types, with distinct consistency needs:
cryptocurrency transactions, which only require promises;
and smart contract transactions, which need to be commit-
ted.

We consider 3 scenarios: i) 100% cryptocurrency transac-
tions; ii) 100% smart contract transactions; iii) and a mixed
ratio of 44% cryptocurrency and 66% smart contract trans-
actions as observed in Ethereum [54]. We evaluate these 3
scenarios considering no Byzantine behaviour. (We study
Byzantine behaviour in the next section.)

We consider NimbleChain conﬁgured with AT = 2(C +
1), the most robust conﬁguration. Due to lack of space, we
do not evaluate NimbleChain conﬁgured with AT = 4,
which is a less robust conﬁguration that would present even
lower values for promise latency.

Figure 6 presents our results. As expected, the aver-
age transaction latency for cryptocurrency transactions is
around one order of magnitude lower with NimbleChain
(promise latency) than with Ethereum (commit latency), as
shown in Figure 6 (top).

Fig. 6: Transaction latency: 100% cryptocurrency transac-
tions (above); 100% smart contract transactions (middle);
mixed cryptocurrency and smart contract transactions

different consistency needs, and ii) what is the impact of
fragmentation attacks? Next, we detail the evaluation sce-
nario, metrics and discuss our results.

6.1 Implementation, deployment and workload.

We implemented NimbleChain as an extension of Ethereum
using the reference Geth 1.7 implementation [13]. The imple-
mentation required ≈ 3000 new lines of code to implement
NimbleChain and changing ≈ 300 lines of code in Geth.

For experimental purposes, we also developed a custom
client that, using the regular API, injects transactions in
the system according to real transaction traces from Ether-
scan [15] (a sample of transactions from block 5306612 up
to block 6222336). The workload has no information about
causality (aside from the implicit dependencies among
transactions issued from the same account) and hence we set
each transaction to depend on the most recently promised
transaction – and, transitively, from the causal dependencies
of that transaction. Note that this is a conservative choice,
since it increases the probability that some NimbleChain
processes will have to wait for causal dependencies.

To run experiments with a large number of processes we
replaced the PoW component with a probabilistic mining
selection process that follows a Poisson distribution and
mimics the block production distribution.

To reﬂect the non-uniform mining power distribution
of today’s mainstream permissionless blockchains, we allo-

 0 0.2 0.4 0.6 0.8 1 0 500 1000 1500 2000 2500 3000CDF 100% cryptocurrencyEthereumNimbleChain 0 0.2 0.4 0.6 0.8 1 0 500 1000 1500 2000 2500 3000CDF 100% smart contracts 0 0.2 0.4 0.6 0.8 1 0 500 1000 1500 2000 2500 3000CDF mixedTime (sec)14

6.3 Fragmentation attacks

To perform a fragmentation attack (or a series of fragmen-
tation attacks) for some period T , an attacker must allocate
a portion x of its mining power to that purpose during T .
As a return from such investment, the attacker will reduce
the average mining power of the largest correct fragment
by y during T . To be proﬁtable to the attacker, y must be
higher than x. Otherwise, a rational attacker will not have
any tangible beneﬁt, and thus will not carry on the attack.
The main goal of this section is to study the impact of
fragmentation attacks, and consequently answer the above
question.

Recall that a fragmentation attack involves broadcasting
a transaction t and immediately starting to produce a block
with a double-spend t(cid:48). Later, the attacker broadcasts t(cid:48) in
an attempt that different correct processes will receive it at
different ages of t. This will result in some correct processes
choosing RRSp(t) = a and others RRSq(t) = a + δ, where
a denotes the age that t had when the former received t(cid:48) and
δ depends on the AT parameter (as discussed in §4.3).

We empirically found that the most advantageous case
for the attacker was with a = 0, i.e., some correct processes
p receive t(cid:48) when agep(t) = 0, while other processes q
receive t(cid:48) when ageq(t) > 0 (i..e, either 1 or 2). Hence, in
this analysis, we consider a = 0.

As detailed in §4.3, the divergent fragments of correct
processes eventually converge when at most 2 new blocks
are generated from either fragment (and delivered), when
AT = 2(C + 1). In contrast, when AT = 4, the divergent
fragments of correct processes may require C blocks to
converge. In the meantime, the attacker may perform a burst
of consecutive fragmentation attacks with the intention to
keep the system fragmented for a longer period, by creating
a new fragmentation before the current one is healed.

In these experiments, we assumed the attacker holds
24% of the resources, which corresponds to the largest
mining pool in Ethereum [54]. The attacker continuously
performs a fragmentation attack to weaken the aggregate
resources owned by correct processes, by making them
adhere to distinct fragments. The attacker uses its total
mining power to perform the fragmentation attack series
(x = 24%). For space limitations, we omit scenarios where
the attacker only spends a fraction of its total mining power
(x < 24%). Our analysis of lower values of x yielded similar
observations as the ones that we present next.

Further, we artiﬁcially instrumented the delivery proto-
col to ensure a fragmentation ratio that is favorable to the
attacker: 80% of nodes randomly considered RRSp(t1) = 0
and could accept a malicious block immediately, while the
remaining 20% considered RRSp(t1) = 1 for AT = 2(C +1)
or RRSp(t1) = C for AT = 4. In a real scenario, it would
be very unlikely for the attacker to be able to reach such
precise fragmentation, since he does not control the network
latency. We tested other values for the fragmentation ratio
(e.g. 50%-50%, 70%-30% and 60%-40%), which yielded sim-
ilar conclusions. Due to lack of space, we do not present
them here.

Figure 7 shows the results as stacked histogram. The y-
axis expresses the percentage of resources owned by each
fragment and the x-axis represents time, in seconds. The

Fig. 7: Fragment adoption during a fragmentation attack,
comparing NimbleChain with AT = 4 (top) and AT =
2(C +1) (middle) against the Ethereum baseline (bottom, no
fragmentation attack) The y-axis expresses the percentage
of resources owned by each fragment of correct processes,
where 100% in the same colour (light grey) means that every
correct process’ local chain is identical. The x-axis represents
time, in seconds.

Fig. 8: Mining power utilization, average largest fragment
CPU and fairness upon fragmentation attack.

Smart contract transaction commit times with Ethereum
are very similar to NimbleChain’s, which suggests that the
overhead of NimbleChain on the underlying protocol is
negligible, as shown in Figure 6 (middle). NimbleChain
seems to slightly outperform Ethereum at the head, due
to slightly different transaction ordering criteria in the
mempool. As an example, causal dependencies are ordered
before a dependent transaction regardless of their price.
Hence, such dependencies may reach the blockchain earlier
in NimbleChain than in Ethereum.

Figure 6 (bottom) depicts the mixed scenario and shows
an interesting trend. Cryptocurrency transactions continue
to perform much faster in NimbleChain (promise latency)
than in Ethereum (commit latency), while smart contracts
commit at roughly the same pace with the results showing
a clear inﬂection point between each transaction type.

 0 0.2 0.4 0.6 0.8 1baselineAT=2(C+1)AT=4Mining power utilizationAverage largest fragment CPUFairnesslight colored layer represents the percentage of resources
owned by honest processes in the largest (i.e., with the high-
est mining power) fragment at a given moment. It is worth
noting that, even in the baseline, the mere generation of a
new block by a correct process (with or without a concurrent
fork) causes short periods where the correct processes are
not perfectly synchronized (i.e., in the same local chain
state), which quickly end as the system synchronizes again.
This is an intrinsic characteristic of BBP.

As expected, the results for AT = 4 (Figure 7 top) show
a long-lasting fragmentation since processes require a long
sufﬁx of C blocks before accepting a chain with t(cid:48)
1. For
AT = 2(C + 1) (Figure 7 middle) we observe a much faster
healing since processes require only 1 block before accepting
a chain with t(cid:48)
1. This conﬁrms that AT = 4 trades a
decreased latency in the fast path for less robustness against
fragmentation attacks, while AT = 2(C + 1) provides more
robustness at the expense of a higher latency in the fast path.
To conclude our analysis of the fragmentation attack,
we evaluate its impact on two metrics originally proposed
by Eyal et al. [16]. The mining power utilization (MPU) is
the ratio between the aggregate work of the main chain
and all produced blocks. Fairness is the ratio between the
number of blocks generated by the largest honest miner
and all produced blocks. In a fair system, the fairness ratio
should be identical to the mining power of the reference
miner, which holds 21.3% mining power in this experiment
(corresponding to the 2nd most resourceful miner). We also
measure the average CPU power of the largest fragment.

The results are presented in Figure 8. As it is possible to
observe, the MPU decreases from its baseline value when
an attack is carried out. Further, MPU decreases as AT
decreases. The average CPU owned by the largest fragment
during the attacks also decreases as AT decreases. These are
expected results, since the mining power is scattered among
fragments.

Most importantly, the decrease in both metrics is consid-
erably lower than the mining power the attacker invested
to put the attack in practice. This is true even for the least
robust variant of NimbleChain, AT = 4. This means that
the attacker does not reach a break even point. Therefore,
the analyzed attack is not proﬁtable for a rational attacker.
Instead of using his mining power to slow down the correct
system’s ability to advance the main chain (through frag-
mentation), it would be more proﬁtable for the attacker to
employ the same mining power to accelerate the generation
of his malicious chain (an attack vector that is possible in
standard BBP). This observation empirically supports the
assumption in §4.5 on the impact of fragmentation attacks.
Finally, and as expected, the fragmentation periods cause
fairness deviations in NimbleChain. While vanilla Ethererum
is the closest to the desired fairness target (ideally, 21.3%),
the fairness of NimbleChain ’s variants are still within a 10%
distance from the ideal target.

7 DISCUSSION

Assumptions on network propagation. The design of Nim-
bleChain depends on the assumption of a well-known
maximum delivery delay, D. Of course, NimbleChain may
behave incorrectly if the D assumption is not met by the

15

underlying network. More precisely, a period of arbitrary
propagation delays (beyond D) can violate our assumption
that the age and RSS that two correct processes assign
to some transaction do not diverge by more than 2 and 1
(respectively). An arbitrary divergence across the ages each
process sees may lead to pathological situations where two
double-spending transactions are able to successfully age at
distinct processes. Further, an arbitrary divergence in RSS
may compromise the ability of NimbleChain to heal upon a
fragmentation attack.

We remark that a maximum network propagation time
is a standard assumption in permissionless blockchains. For
instance, every permissionless blockchain mentioned in §8
relies on this assumption. Further, different works have
studied vulnerabilities that are possible if the D assumption
is violated. For instance, an unexpectedly high block propa-
gation delay may slow down the time the system converges
upon forks, which provides an advantage to a resourceful
attacker to temporarily beneﬁt from lower mining power
utilization from the correct processes [17]. An eclipse attack
[40] can isolate a subset of correct processes from the remain-
ing correct system – which can be translated to arbitrarily
increasing D from the outside to the eclipsed partition –,
allowing a resourceful attacker to control the evolution of
the blockchain within the partition.

Still, we acknowledge that NimbleChain might be more
sensitive than BBP to smaller sporadic violations of D,
and/or smaller periods where D is violated, during which
NimbleChain’s properties are violated but BBP’s hold. This
is a natural consequence of a protocol that reaches a decision
over a shorter time window. This consequence is shared
with every proposal
in §8 that provides lower commit
latencies than BBP.

Performance with higher delivery delays. In absolute
terms, NimbleChain depends on D being low enough to
ensure a low fast path latency. Hence, one may rush to
the conclusion that the speedup that NimbleChain intro-
duces relatively to the baseline BBP-based permissionless
blockchain depends on D. However, that is not correct. Let
us suppose that NimbleChain was used in a low-quality
network whose D was much higher than the one that
previous studies ﬁnd in real permissionless blockchains [29],
[30]. In that case, the PoW difﬁculty (and, hence, the block
generation time, B) would need to be adjusted accordingly,
in order to keep the r = D/B rate low enough to ensure
the (probabilistic) correctness of BBP. This readjustment of
D and B would not only increase the fast path latency of
NimbleChain, but also the commit latency of BBP. Therefore,
the speedup of NimbleChain would remain the same. This
conclusion is in line with Table 2, which shows that the
speedup of NimbleChain depends on f and C, not on D.

8 RELATED WORK

Improvements over longest chain rule. GHOST [58], par-
tially implemented in Ethereum [61], improves Nakamoto’s
original longest chain rule by allowing all blocks generated
by honest participants to contribute to the commit of the
main chain. This enables convergence even with higher
block generation rates. A different approach, followed by
inclusive blockchain protocols [33] and PHANTOM [57],

organizes blocks as directed-acyclic graphs (DAG) of blocks
instead of a totally-ordered list in order to optimize per-
formance. More recently, Conﬂux [35] combines the main
principles behind GHOST and DAG-based solutions in an
adaptive fashion to provide them with better liveness guar-
antees.

Hierarchical

Despite the signiﬁcant throughput gains (e.g., Conﬂux
is able to improve GHOST’s throughput by 32x), these
approaches still rely on consensus as the only path to com-
mit. Consequently, they only bring modest commit latency
savings (e.g., 25% latency gains in Conﬂux with respect
to GHOST). NimbleChain can be plugged to any of these
systems and enhance them with substantially lower commit
latencies, while retaining their throughputs.
and

Chains. Alternative
Parallel
blockchain organizations include hierarchical and parallel
chains. In Bitcoin-NG [16], key blocks are generated at a
similar rate as Bitcoin. Still, in-between two key blocks,
the miner of the previous key block can generate many
microblocks that contain transactions. FruitChain [48]
adopts a similar hierarchical approach. OHIE uses parallel
instances of BBP and then deterministically sorts blocks to
reach a total order [62]. In all these proposals, the total order
of the main chain is determined by only a fraction of blocks
(key blocks). Hence, the remaining blocks (microblocks),
which carry the actual transactions, can be safely generated
at much higher rates than BBP allows, thus increasing
throughput. Unlike NimbleChain, these proposals focus on
improving throughput, not commit latency. For example,
Bitcoin-NG does not improve commit latency [16] and
OHIE’s average commit latency is around 10 minutes [62].

One notable exception is Prism [4], which supports low-
latency and high-throughput honest transactions by resort-
ing to parallel voting chains, which determine the total order
of blocks in the main chain. Besides high throughput, Prism
also improves commit latency. Still, their simulation-based
evaluation results are around 2x higher than the causal
commit latency of NimbleChain’s most robust conﬁguration
(40 to 58 sec with β = 0.3 [4]). Since all the above proposals
are optimizations over BBP’s foundations, NimbleChain
can supplement any of them with the low-latency of our
consensusless commit fast path.

Blockchains based on Byzantine Fault Tolerance (BFT).
A relevant body of proposals leverages BFT protocols, exe-
cuted among small committees of processes, to improve the
performance of permissionless blockchains. Proposals such
as ByzCoin [31], Thunderella [49] and Solida [1] combine
BBP with BFT protocols. In contrast, proposals such as
Algorand [19], HoneyBadger [44], and Stellar [37] are even
more disruptive. These approaches can achieve comparable
commit latencies as NimbleChain’s most robust conﬁgu-
ration (e.g., in Algorand [19]’s best-case setting, 22 sec).
However, they signiﬁcantly change the trust assumptions
of permissionless blockchains, as BFT consensus requires
that 2/3 of the validators must be trusted. Further, most of
these proposals are highly disruptive and, as such, cannot
incrementally extend existing mainstream permissionless
blockchains.

Sharding. Proposals such as Elastico [38], OmniLedger
[32], Rapid-Chain [63], Monoxide [59] or Ethereum 2.0 [14]
to multiple parallel blockchains cooperating via
resort

16

sharding, where a small committee maintains each shard.
This approach achieves substantial throughput gains (up to
thousands of transactions per second), however at the cost
of security, since the smaller shards are vulnerable to pow-
erful attackers. Since sharded proposals typically assume
(multiple) BBP-based blockchain instances, NimbleChain
can be generalized to supplement sharded proposals with
a low-latency consensusless fast path. Some sharded pro-
posals have also been shown to achieve comparable commit
latency savings as NimbleChain (e.g., [32], [63]). Still, such
results are possible in networks with much lower RTT than
the one considered in our paper and only in speciﬁc best-
case workloads.

Layer-2 proposals. Layer-2 proposals employ an addi-
tional protocol layer that handles (and commits) transac-
tions and use the permissionless blockchain as a backend
anchor to ensure consistency in the presence of malicious
behaviour. In that sense, NimbleChain ﬁts into this broad
category. Among the most relevant proposals, so-called off-
chain solutions such as the Lightning Network [52] and
FastPay [23] rely on a separate network of payment channels
and allow two or more parties to exchange currency without
committing in the blockchain. However, these proposals
have important shortcomings. They work at the expense
of temporarily locking payment guarantees (often called
collaterals) in the blockchain if a party misbehaves. While
proposals based on payment networks are not tailored to
unidirectional payment ﬂows (as typical in retail payments
from customers to merchants [41]), alternatives based on
payment hubs [11], [24] either impose trusted entities or
increased locked funds.

More recently, Snappy [41] proposes a novel on-chain
smart-contract-based alternative that mitigates the above-
mentioned shortcomings and achieves payment commit
latency in the order of a few seconds. Still, Snappy has
important scalability limitations in the number of payment
recipient processes (up to 200 statekeeping merchants [41]).
Further, since Snappy payments require smart contract in-
vocations, they cost 8x more than simple transactions (in
Snappy’s Ethereum-based implementation [41]). In contrast,
NimbleChain neither requires collaterals, nor restricts scala-
bility, nor increases transaction cost.

Proof-of-X alternatives. Another research avenue has
proposed permissionless consensus algorithms that replace
PoW with energy-efﬁcient alternatives, such as Proof-of-
Stake [28], [64], [19], [3], Proof-of-Space [12], [2] or Proof-
of-Elapsed-Time [8]. Among such proposals, some are still
based on a variant of BBP, despite replacing the PoW leader
election component by a PoX alternative (e.g., [28], [64], [12],
[2]). Therefore, NimbleChain’s consensusless fast path can
be integrated onto such proposals.

Weakly-consistent blockchains. Like NimbleChain,
some proposals attempt to obtain partial orders instead of
total orders for cryptocurrency transactions. In the permis-
sionless world, notable proposals include SPECTRE [56],
TrustChain [46], ABC [55] and Avalanche [53]. In the context
of permissioned blockchains, Astro [9] exploits Byzantine
reliable broadcast [39] to build a payment system. All these
proposals exploit the fact that cryptocurrecy transfer trans-
actions do not need to be totally-ordered, hence can be
managed by weaker primitives than consensus. Like Nim-

bleChain’s consensusless fast path, the above proposals can
serve the weak consistency needs of some applications such
as cryptocurrencies. Still, these proposals cannot directly
support general-purpose blockchains, whose application
ecosystem comprises applications with weaker consistency
demands (such as cryptocurrencies) and strong sequential
consistency (such as most smart contracts). In contrast,
NimbleChain’s hybrid consistency model is tailored to such
mixed ecosystems.

Hybrid-consistency replication. The dichotomy be-
tween weak and strong consistency is well studied in the
context of traditional geo-replicated systems [7]. It is well
established that one needs to forfeit strong consistency to
obtain the high availability, low latency, partition tolerance
and high scalability that geo-replicated systems demand [7].
It is also known that many geo-distributed applications do
not require strong consistency for every operation [36] and
that many such applications are dominated by operations
that are correct even if executed over a weakly-consistent
view. This observation has motivated the advent of geo-
replicated systems supporting hybrid (or mixed) consis-
tency models [43], [42], [34]. To the best of our knowledge,
NimbleChain is the ﬁrst to introduce hybrid consistency
models to permissionless environments.

9 CONCLUSIONS AND FUTURE WORK

This paper proposes NimbleChain, which extends standard
permissionless blockchains with a fast path that delivers
consensusless promises of commitment. This fast path supports
cryptocurrency transactions and only takes a small fraction
of the original commit latency, while providing consis-
tency guarantees that are strong enough to ensure correct
cryptocurrencies. Since today’s general-purpose blockchains
also support smart contract transactions, which typically
have (strong) sequential consistency needs, NimbleChain
implements a hybrid consistency model that also supports
strongly-consistent applications. To the best of our knowl-
edge, NimbleChain is the ﬁrst system to bring together
fast consensusless transactions with strongly-consistent
consensus-based transactions in a permissionless setting.

Our evaluation conducted in a realistic geo-distributed
environment with 500 processes shows that the average
latency to promise a transaction is an order of magnitude
faster than consensus-based commit. Overall, we believe
that our approach of bringing fast transactions to permis-
sionless blockchains as an extension to existing blockhains,
rather than proposing a new system from scratch, is a step in
the direction of bringing these results closer to adoption by
de facto blockchain systems such as Ethereum or Bitcoin thus
beneﬁting both the academic and industry communities.

Our work unveils new research avenues. Although this
paper focuses on cryptocurrencies as the obvious appli-
cation to beneﬁt from the consensusless admit fast path
of NimbleChain, our proposal can also provide important
beneﬁts to smart contracts which have (a subset of) transac-
tions with weaker consistency needs. As an example, smart
contracts that employ the ERC20 Token Standard [60] to
transfer some asset may have weaker consistency needs.
However, providing a hybrid consistency model to smart
integration of this
contract programs requires a careful

model into smart contract execution runtimes, as well as
providing programmers with the adequate abstractions to
help them build smart contract methods that can safely run
with weaker guarantees.

17

REFERENCES

[1]

Ittai Abraham, Dahlia Malkhi, Kartik Nayak, Ling Ren, and
Alexander Spiegelman. Solida: A cryptocurrency based on recon-
ﬁgurable byzantine consensus. OPODIS, 2017.

[2] Hamza Abusalah, Jo”el Alwen, Bram Cohen, Danylo Khilko,
Krzysztof Pietrzak, and Leonid Reyzin. Beyond hellman’s time-
memory trade-offs with applications to proofs of space. Cryptol-
ogy ePrint Archive, Report 2017/893, 2017.

[3] Avi Asayag, Gad Cohen, Ido Grayevsky, Maya Leshkowitz, Ori
Rottenstreich, Ronen Tamari, and David Yakira. Helix: A scalable
and fair consensus algorithm, white paper, available at, 2018.
[4] Vivek Bagaria, Sreeram Kannan, David Tse, Giulia Fanti, and
Pramod Viswanath. Prism: Deconstructing the blockchain to
approach physical limits. In Proceedings of the 2019 ACM SIGSAC
Conference on Computer and Communications Security, CCS ’19, page
585–602, New York, NY, USA, 2019. Association for Computing
Machinery.

[5] Tobias Bamert, Christian Decker, Lennart Elsen, Roger Watten-
hofer, and Samuel Welten. Have a snack, pay with bitcoins.
In
IEEE P2P 2013 Proceedings, pages 1–5. IEEE, 2013.
Stefano Bistarelli, Ivan Mercanti, and Francesco Santini. An anal-
ysis of non-standard transactions. Frontiers in Blockchain, 2:7, 2019.
In PODC,

[7] Eric A Brewer. Towards robust distributed systems.

[6]

volume 7, 2000.

[8] Lin Chen, Lei Xu, Nolan Shah, Zhimin Gao, Yang Lu, and Wei-
dong Shi. On security analysis of proof-of-elapsed-time (poet).
In International Symposium on Stabilization, Safety, and Security of
Distributed Systems, pages 282–297. Springer, 2017.

[9] Daniel Collins, Rachid Guerraoui,

Jovan Komatovic, Petr
Kuznetsov, Matteo Monti, Matej Pavlovic, Yvonne-Anne Pigno-
let, Dragos-Adrian Seredinschi, Andrei Tonkikh, and Athanasios
Xygkis. Online payments by merely broadcasting messages.
In
2020 50th Annual IEEE/IFIP International Conference on Dependable
Systems and Networks (DSN), pages 26–38. IEEE, 2020.

[10] Maya Dotan, Yvonne-Anne Pignolet, Stefan Schmid, Saar Tochner,
and Aviv Zohar. Sok: Cryptocurrency networking context, state-
of-the-art, challenges. In Proceedings of the 15th International Con-
ference on Availability, Reliability and Security, ARES ’20, New York,
NY, USA, 2020. Association for Computing Machinery.

[11] Stefan Dziembowski, Lisa Eckey, Sebastian Faust, and Daniel
Malinowski. Perun: Virtual payment hubs over cryptocurrencies.
In 2019 IEEE Symposium on Security and Privacy, SP 2019, San
Francisco, CA, USA, May 19-23, 2019, pages 106–123. IEEE, 2019.

[12] Stefan Dziembowski, Sebastian Faust, Vladimir Kolmogorov, and
Krzysztof Pietrzak. Proofs of space. In Annual Cryptology Confer-
ence, pages 585–605. Springer, 2015.

[13] ETHDEV and the Ethereum community. Geth. https://github.

com/ethereum/go-ethereum/wiki/geth, 2017.
[14] ETHDEV and the Ethereum community.

Ethereum 2.0:
Sharding roadmap. https://github.com/ethereum/wiki/wiki/
Sharding-roadmap, 2019.

[15] Etherscan. Etherscan - ethereum blockchain explorer. https://

etherscan.io/, 2021.

[16] Ittay Eyal, Adem Efe Gencer, Emin G ¨un Sirer, and Robbert Van Re-
nesse. Bitcoin-ng: A scalable blockchain protocol. In NSDI, pages
45–59, 2016.

[17] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin
In Annual Inter-
backbone protocol: Analysis and applications.
national Conference on the Theory and Applications of Cryptographic
Techniques, pages 281–310. Springer, 2015.

[18] Adem Efe Gencer, Soumya Basu, Ittay Eyal, Robbert van Renesse,
and Emin G ¨un Sirer. Decentralization in bitcoin and ethereum
networks. arXiv preprint arXiv:1801.03998, 2018.

[19] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and
Nickolai Zeldovich. Algorand: Scaling byzantine agreements for
cryptocurrencies. In Proceedings of the 26th Symposium on Operating
Systems Principles, pages 51–68. ACM, 2017.

[20] Paulo Gouveia, Jo˜ao Neves, Carlos Segarra, Luca Liechti, Shady
Issa, Valerio Schiavoni, and Miguel Matos. Kollaps: Decentralized
In Proceedings of the Fifteenth
and dynamic topology emulation.
European Conference on Computer Systems, EuroSys ’20, New York,
NY, USA, 2020. Association for Computing Machinery.

[21] Rachid Guerraoui, Petr Kuznetsov, Matteo Monti, Matej Pavloviˇc,
and Dragos-Adrian Seredinschi. The consensus number of a
In Proceedings of the 2019 ACM Symposium on
cryptocurrency.
Principles of Distributed Computing, pages 307–316. ACM, 2019.
[22] Hanyue Guo, Jiting Zhou, Jiaqi Wang, and Xiaodong Wang. A bike
sharing system based on blockchain platform. In MATEC Web of
Conferences, volume 232, page 01027. EDP Sciences, 2018.

[23] Zijiang Hao, Raymond Ji, and Qun Li. Fastpay: A secure fast
payment method for edge-iot platforms using blockchain. In 2018
IEEE/ACM Symposium on Edge Computing (SEC), pages 410–415.
IEEE, 2018.

[24] Ethan Heilman, Leen Alshenibr, Foteini Baldimtsi, Alessandra
Scafuro, and Sharon Goldberg. Tumblebit: An untrusted bitcoin-
In 24th Annual Network
compatible anonymous payment hub.
and Distributed System Security Symposium, NDSS 2017, San Diego,
California, USA, February 26 - March 1, 2017. The Internet Society,
2017.

[25] Maurice Herlihy. Wait-free synchronization. ACM Trans. Program.

Lang. Syst., 13(1):124–149, January 1991.

[26] Yiwen Hu, Sihan Wang, Guan-Hua Tu, Li Xiao, Tian Xie, Xinyu
Lei, and Chi-Yu Li. Security threats from bitcoin wallet smart-
phone applications: Vulnerabilities, attacks, and countermeasures.
In Proceedings of the Eleventh ACM Conference on Data and Applica-
tion Security and Privacy, CODASPY ’21, page 89–100, New York,
NY, USA, 2021. Association for Computing Machinery.

[27] Ghassan O. Karame, Elli Androulaki, and Srdjan Capkun. Double-
spending fast payments in bitcoin. In Proceedings of the 2012 ACM
Conference on Computer and Communications Security, CCS ’12, page
906–917, New York, NY, USA, 2012. Association for Computing
Machinery.

[28] Aggelos Kiayias, Alexander Russell, Bernardo David, and Ro-
man Oliynykov. Ouroboros: A provably secure proof-of-stake
blockchain protocol. In Annual International Cryptology Conference,
pages 357–388. Springer, 2017.

[29] Eleftherios Kokoris Kogias, Philipp Jovanovic, Nicolas Gailly, Is-
mail Khofﬁ, Linus Gasser, and Bryan Ford. Enhancing bitcoin
security and performance with strong consistency via collective
In 25th USENIX Security Symposium (USENIX Security
signing.
16), pages 279–296, 2016.

[30] Eleftherios Kokoris-Kogias. Robust and scalable consensus for
sharded distributed ledgers. Cryptology ePrint Archive, Report
2019/676, 2019. https://eprint.iacr.org/2019/676.

[31] Eleftherios Kokoris-Kogias, Philipp Jovanovic, Nicolas Gailly, Is-
mail Khofﬁ, Linus Gasser, and Bryan Ford. Enhancing bitcoin
security and performance with strong consistency via collective
signing. In Proceedings of the 25th USENIX Conference on Security
Symposium, SEC’16, page 279–296, USA, 2016. USENIX Associa-
tion.

[32] Eleftherios Kokoris-Kogias, Philipp Jovanovic, Linus Gasser, Nico-
las Gailly, Ewa Syta, and Bryan Ford. Omniledger: A secure, scale-
out, decentralized ledger via sharding. In 2018 IEEE Symposium on
Security and Privacy (SP), pages 583–598. IEEE, 2018.

[33] Yoad Lewenberg, Yonatan Sompolinsky, and Aviv Zohar. Inclusive
In Rainer B ¨ohme and Tatsuaki Okamoto,
block chain protocols.
editors, Financial Cryptography and Data Security - 19th International
Conference, FC 2015, San Juan, Puerto Rico, January 26-30, 2015,
Revised Selected Papers, volume 8975 of Lecture Notes in Computer
Science, pages 528–547. Springer, 2015.

[34] Cheng Li, Daniel Porto, Allen Clement, Johannes Gehrke, Nuno
Preguic¸a, and Rodrigo Rodrigues. Making geo-replicated systems
In Proceedings of the
fast as possible, consistent when necessary.
10th USENIX Conference on Operating Systems Design and Implemen-
tation, OSDI’12, pages 265–278, Berkeley, CA, USA, 2012. USENIX
Association.

[35] Chenxing Li, Peilun Li, Dong Zhou, Zhe Yang, Ming Wu, Guang
Yang, Wei Xu, Fan Long, and Andrew Chi-Chih Yao. A decen-
tralized blockchain with high throughput and fast conﬁrmation.
In 2020 USENIX Annual Technical Conference (USENIX ATC 20),
pages 515–528. USENIX Association, July 2020.

18

the Twenty-Third ACM Symposium on Operating Systems Principles,
SOSP ’11, pages 401–416, New York, NY, USA, 2011. ACM.
[37] Marta Lokhava, Giuliano Losa, David Mazi`eres, Graydon Hoare,
Nicolas Barry, Eli Gafni, Jonathan Jove, Rafał Malinowsky, and Jed
McCaleb. Fast and secure global payments with stellar. In Proceed-
ings of the 27th ACM Symposium on Operating Systems Principles,
SOSP ’19, page 80–96, New York, NY, USA, 2019. Association for
Computing Machinery.

[38] Loi Luu, Viswesh Narayanan, Chaodong Zheng, Kunal Baweja,
Seth Gilbert, and Prateek Saxena. A secure sharding protocol
In Proceedings of the 2016 ACM SIGSAC
for open blockchains.
Conference on Computer and Communications Security, CCS ’16, page
17–30, New York, NY, USA, 2016. Association for Computing
Machinery.

[39] Dahlia Malkhi and Michael Reiter. A high-throughput secure
reliable multicast protocol. Journal of Computer Security, 5(2):113–
127, 1997.

[40] Yuval Marcus, Ethan Heilman, and Sharon Goldberg.

Low-
resource eclipse attacks on ethereum’s peer-to-peer network. IACR
Cryptology ePrint Archive, 2018:236, 2018.

[41] Vasilios Mavroudis, Karl W ¨ust, Aritra Dhar, Kari Kostiainen, and
Srdjan Capkun. Snappy: Fast on-chain payments with practical
collaterals. In 27th Annual Network and Distributed System Security
Symposium, NDSS 2020, San Diego, California, USA, February 23-26,
2020. The Internet Society, 2020.

[42] Matthew Milano and Andrew C Myers. Mixt: a language for
mixing consistency in geodistributed transactions. In Proceedings
of the 39th ACM SIGPLAN Conference on Programming Language
Design and Implementation, pages 226–241. ACM, 2018.

[43] Matthew P Milano and Andrew C Myers. Mixing consistency
in geodistributed transactions: Technical report. Technical report,
2016.

[44] Andrew Miller, Yu Xia, Kyle Croman, Elaine Shi, and Dawn Song.
The honey badger of bft protocols. In Proceedings of the 2016 ACM
SIGSAC Conference on Computer and Communications Security, pages
31–42. ACM, 2016.

[45] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system.

2008.

[46] Pim Otte, Martijn de Vos, and Johan Pouwelse. Trustchain: A sybil-
resistant scalable blockchain. Future Generation Computer Systems,
2017.

[47] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the
In Annual Inter-
blockchain protocol in asynchronous networks.
national Conference on the Theory and Applications of Cryptographic
Techniques, pages 643–673. Springer, 2017.

[48] Rafael Pass and Elaine Shi. Fruitchains: A fair blockchain.

In
Proceedings of the ACM Symposium on Principles of Distributed
Computing, PODC ’17, page 315–324, New York, NY, USA, 2017.
Association for Computing Machinery.

[49] Rafael Pass and Elaine Shi. Hybrid consensus: Efﬁcient consensus
in the permissionless model. In Andr´ea W. Richa, editor, 31st In-
ternational Symposium on Distributed Computing, DISC 2017, October
16-20, 2017, Vienna, Austria, volume 91 of LIPIcs, pages 39:1–39:16.
Schloss Dagstuhl - Leibniz-Zentrum f ¨ur Informatik, 2017.

[50] Rafael Pass and Elaine Shi. Rethinking large-scale consensus. In
2017 IEEE 30th Computer Security Foundations Symposium (CSF),
pages 115–129. IEEE, 2017.

[51] George Pˆırlea and Ilya Sergey. Mechanising blockchain consensus.
In Proceedings of the 7th ACM SIGPLAN International Conference on
Certiﬁed Programs and Proofs, pages 78–90. ACM, 2018.

[52] Joseph Poon and Thaddeus Dryja. The bitcoin lightning network:
Scalable off- chain instant payments. https://lightning.network/
lightning-network-paper.pdf, 2016.

[53] Team Rocket, Maofan Yin, Kevin Sekniqi, Robbert van Renesse,
and Emin G ¨un Sirer. Scalable and probabilistic leaderless bft
consensus through metastability, 2020.

[54] Paulo Silva, David Vavˇriˇcka, Jo˜ao Barreto, and Miguel Matos.
Impact of geo-distribution and mining pools on blockchains: A
In 2020 50th Annual IEEE/IFIP International
study of ethereum.
Conference on Dependable Systems and Networks (DSN), pages 245–
252. IEEE Computer Society, jul 2020.

[55] Jakub Sliwinski and Roger Wattenhofer. Abc: Asynchronous
arXiv preprint arXiv:1909.10926,

blockchain without consensus.
2019.

[36] Wyatt Lloyd, Michael

J. Freedman, Michael Kaminsky, and
David G. Andersen. Don’t settle for eventual: Scalable causal
In Proceedings of
consistency for wide-area storage with cops.

[56] Yonatan Sompolinsky, Yoad Lewenberg, and Aviv Zohar. Spectre:
Serialization of proof-of-work events: Conﬁrming transactions via
recursive elections, 2016.

19

[57] Yonatan Sompolinsky, Shai Wyborski, and Aviv Zohar. Phantom
and ghostdag: A scalable generalization of nakamoto consensus.
Cryptology ePrint Archive, Report 2018/104, 2018. https://eprint.
iacr.org/2018/104.

[58] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate trans-
In Rainer B ¨ohme and Tatsuaki
action processing in bitcoin.
Okamoto, editors, Financial Cryptography and Data Security - 19th
International Conference, FC 2015, San Juan, Puerto Rico, January 26-
30, 2015, Revised Selected Papers, volume 8975 of Lecture Notes in
Computer Science, pages 507–527. Springer, 2015.

[59] Jiaping Wang and Hao Wang. Monoxide: Scale out blockchains
In 16th {USENIX} Sympo-
with asynchronous consensus zones.
sium on Networked Systems Design and Implementation ({NSDI} 19),
pages 95–112, 2019.

[60] Bitcoin Wiki. The erc20 token standard. https://en.bitcoinwiki.

org/wiki/ERC20, 2018.

[61] Gavin Wood et al. Ethereum: A secure decentralised generalised
transaction ledger. Ethereum project yellow paper, 151:1–32, 2014.
[62] H. Yu, I. Nikolic, R. Hou, and P. Saxena. Ohie: Blockchain scaling
made simple. In 2020 IEEE Symposium on Security and Privacy (SP),
pages 90–105, Los Alamitos, CA, USA, may 2020. IEEE Computer
Society.

[63] Mahdi Zamani, Mahnush Movahedi, and Mariana Raykova.
In Proceedings
Rapidchain: Scaling blockchain via full sharding.
of the 2018 ACM SIGSAC Conference on Computer and Communica-
tions Security, CCS ’18, page 931–948, New York, NY, USA, 2018.
Association for Computing Machinery.

[64] Vlad Zamﬁr.

Casper

the

friendly

by construction blockchain consensus protocol.
paper:
pers/CasperTFG/CasperTFG.pdf, 2017.

https://github.com/ethereum/research/blob/master/

ghost: A correct
White
pa-

