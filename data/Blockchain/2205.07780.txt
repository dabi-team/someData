Prisma: A Tierless Language for Enforcing
Contract-Client Protocols in Decentralized
Applications (Extended Version)

David Richter ! (cid:18)
Technical University of Damstadt, Germany

David Kretzler ! (cid:18)
Technical University of Damstadt, Germany

Pascal Weisenburger ! (cid:18)
University of St. Gallen, Switzerland

Guido Salvaneschi ! (cid:18)
University of St. Gallen, Switzerland

Sebastian Faust ! (cid:18)
Technical University of Damstadt, Germany

Mira Mezini ! (cid:18)
Technical University of Damstadt, Germany

Abstract

Decentralized applications (dApps) consist of smart contracts that run on blockchains and clients
that model collaborating parties. dApps are used to model ﬁnancial and legal business functionality.
Today, contracts and clients are written as separate programs – in diﬀerent programming languages
– communicating via send and receive operations. This makes distributed program ﬂow awkward to
express and reason about, increasing the potential for mismatches in the client-contract interface,
which can be exploited by malicious clients, potentially leading to huge ﬁnancial losses.

In this paper, we present Prisma, a language for tierless decentralized applications, where the
contract and its clients are deﬁned in one unit and pairs of send and receive actions that “belong
together” are encapsulated into a single direct-style operation, which is executed diﬀerently by
sending and receiving parties. This enables expressing distributed program ﬂow via standard
control ﬂow and renders mismatching communication impossible. We prove formally that our
compiler preserves program behavior in presence of an attacker controlling the client code. We
systematically compare Prisma with mainstream and advanced programming models for dApps and
provide empirical evidence for its expressiveness and performance.

2012 ACM Subject Classiﬁcation Software and its engineering → Distributed programming lan-
guages; Software and its engineering → Domain speciﬁc languages; Software and its engineering →
Compilers

Keywords and phrases Domain Speciﬁc Languages, Smart Contracts, Scala

Funding David Richter: German Federal Ministry of Education and Research iBlockchain project
(BMBF No. 16KIS0902)
David Kretzler: German Federal Ministry of Education and Research iBlockchain project (BMBF
No. 16KIS0902); German Research Foundation (DFG, SFB 1119 CROSSING); BMBF and the
Hessian Ministry of Higher Education, Research, Science and the Arts within their joint support of
the National Research Center for Applied Cybersecurity ATHENE
Pascal Weisenburger: The University of St. Gallen (IPF, No. 1031569)
Guido Salvaneschi: German Federal Ministry of Education and Research iBlockchain project (BMBF
No. 16KIS0902); German Research Foundation (DFG, SFB 1119 CROSSING); Hessian LOEWE
initiative (emergenCITY); Swiss National Science Foundation (SNSF, No. 200429)
Sebastian Faust: German Federal Ministry of Education and Research iBlockchain project (BMBF

2
2
0
2

y
a
M
6
1

]
L
P
.
s
c
[

1
v
0
8
7
7
0
.
5
0
2
2
:
v
i
X
r
a

 
 
 
 
 
 
2

Prisma: A Tierless Language for Enforcing Protocols

No. 16KIS0902); German Research Foundation (DFG, SFB 1119 CROSSING); BMBF and the
Hessian Ministry of Higher Education, Research, Science and the Arts within their joint support of
the National Research Center for Applied Cybersecurity ATHENE
Mira Mezini: German Federal Ministry of Education and Research iBlockchain project (BMBF No.
16KIS0902); German Research Foundation (DFG, SFB 1119 CROSSING); BMBF and the Hessian
Ministry of Higher Education, Research, Science and the Arts within their joint support of the
National Research Center for Applied Cybersecurity ATHENE

1

Introduction

dApps enable multiple parties sharing state to jointly execute functionality according to a
predeﬁned agreement. The main component is the smart contract – the predeﬁned agreement
– that regulates the interaction between the dApp’s clients. Client–contract interactions can
be logically described by state machines [78, 60, 61, 82] specifying which party is allowed to
do what and when.

dApps can operate without centralized trusted intermediaries by relying on a blockchain
and its consensus protocol. To this end, a contract is deployed to and executed on the
blockchain, which guarantees its correct execution; clients that run outside of the blockchain
can interact with the contract via transactions. A key feature of dApps is that they can
directly link application logic with transfer of monetary assets. This enables a wide range of
correctness/security-sensitive business applications, e.g., for cryptocurrencies, crowdfunding,
and public oﬀerings,1 and make them, at the same time, an attractive target for attackers.
The latter is aggrevated by the fact that contracts can be called by any client in the
network, including malicious ones that try to force the contract to deviate from the intended
behavior [47]. These issues demand programming models that ensure the correctness and
security of dApps by-design, especially given the fact that contract code cannot be updated
after deployment.

We address correctness and security of the client–contract interaction of dApps by
enforcing the execution order of contract code. Deviations from the intended interaction
protocols due to implementation errors and/or malicious attacks are indeed a critical threat
(besides issues with arithmetic or buﬀer overﬂows, etc.). In recent years, there have been
several large attacks exploiting ﬂawed program ﬂow control in smart contracts. Most famously,
attackers managed to steal around 50 M USD [9, 47] from a decentralized autonomous
organization, the DAO. In two attacks on the Parity multi-signature wallet, attackers stole
respectively froze cryptocurrencies worth 30 M USD [27] respectively 150 M USD [69].

Programming dApps. The design space of dApp programming languages can be structured
along two dimensions – similar to other multi-party applications – based on: (1) how the
involved parties (contract and clients) are deﬁned, and (2) how the correctness of their
interactions is ensured.

There are two choices for (1): a local versus a global model. In a local model, parties are
deﬁned each in a separate local program and their interactions are encoded via send and receive
eﬀects. In contrast, in a global model, parties are deﬁned within one shared program and

1 700 K to 2.7 M contracts have been deployed per month between July 2020 and June 2021 [15] on
the Ethereum blockchain – the most popular dApps platform [38]. Some dApps manage tremendous
amounts of assets, e.g., Uniswap [17] – the largest Ethereum trading platform had a daily trading
volume of 0.5 B – 1.5 B USD in June 2021.

D. Richter, D. Kretzler, P. Weisenburger, G. Salvaneschi, S. Faust, M. Mezini

3

interactions are encoded via combined send-and-receive operations with no eﬀects visible to the
outside world. The local model is followed by actor systems [18] or by approaches stemming
from process calculi [54]; the global model by tierless [71, 37, 31, 32, 49, 79, 80, 72, 83] and
choreographic [55, 64, 51] languages.

The local model requires an explicitly speciﬁed protocol for governing the inter-process
send-receive relations to ensure that every send eﬀect has a corresponding receive eﬀect in
an interacting – separately deﬁned – process. In contrast, with a global model, there is no
need to separately specify such a protocol. All parties run the same program in lock-step,
where a single send-and-receive operation performs a send when executed by one party and
a receive on the other party. Due to this encapsulation of the communication eﬀects, there is
no non-local information to track – the program’s control ﬂow deﬁnes the correct interaction
and a standard System-F-style type system is suﬃcient.

Approaches to dApp programming – industrial or research ones – follow a local model,
thus rely on explicitly specifying the client–contract interaction protocol. Moreover, the
contract and clients are implemented in diﬀerent languages, hence, developers have to master
two technology stacks. The dominating approach in industry uses Solidity [63] for the
contract and JavaScript for clients. Solidity relies on developers expressing the protocol
using assertions in the contract code, which are checked at run time [13]. Failing to correctly
introduce assertions may give parties illegal access to monetary values to the detriment of
others [65, 58]. In research, contract languages [39, 33, 74, 75, 35, 34, 66, 25] have been
proposed that rely on advanced type systems such as session types, type states, and linear
types. There, processes are typed by the protocol (of side-eﬀects such as sending and
receiving) that they follow on evaluation, and non-compliant processes are rejected by the
type-checker.

The global model has not been explored for dApp programming. This is unfortunate
given the potential to get by with a standard typing discipline and to avoid intricacies and
potential mismatches of a two-language stack. Our work ﬁlls this gap by proposing Prisma –
the ﬁrst language that features a global programming model for Ethereum dApps. While we
focus on the Ethereum blockchain, we believe our techniques to be applicable to other smart
contract platforms.

Prisma. Prisma enables interleaving contract and client logic within the same program
and adopts a direct style (DS) notation for encoding send-and-receive operations akin to
languages with baked-in support for asynchronous interactions, e.g., via async/await [24, 73].
DS addresses several shortcomings with the currently dominant encoding of the protocol’s
ﬁnite state machines (FSM) as one method per transition [63, 33, 74, 75, 35, 34].

First, FSM style corresponds to a control-ﬂow graph of basic blocks, which is low-level
and more suited to be written by a compiler than by a human – Prisma leaves it to the
compiler to map down high-level declarative DS to low-level FSM style. More importantly,
ensuring safety in FSM style requires a form of dependent types, as the type of an action
depends on the current state. Second, with FSM style, the contract is a passive entity whose
execution is driven by clients. The DS encoding, in contrast, allows the contract to actively
ask clients for input. The latter style naturally ﬁts an execution model where a dominant
acting role controls the execution and diverts control to other parties when their input is
needed, which matches well the dApp setting.

Overall, Prisma relieves the developer from the responsibility of correctly managing
distributed, asynchronous program ﬂows and the heterogeneous technology stack. Instead,
the burden is put on the compiler, which distributes the program ﬂow by means of selective

4

Prisma: A Tierless Language for Enforcing Protocols

continuation-passing-style (CPS) translation and defunctionalisation and inserts guards
against malicious client interactions. We needed to develop a CPS translation for the code
that runs on the Ethereum Virtual Machine (EVM) since the EVM has no built-in support
for concurrency primitives to suspend execution and resume later, which could be used to
implement asynchronous communication. While CPS translations are well-known, we cannot
use them out-of-the-box because the control ﬂow is interwoven with distribution in our case.
Given that CPS translations reify control ﬂows into values, a CPS translation that does
not take distribution into account would allow malicious clients to force the contract to
deviate from the intended control ﬂow by passing a spoofed value to the contract. Thus, it is
imperative to prove correctness of our distributed CPS translation and ensure control-ﬂow
integrity of the contract. We formally deﬁne the compilation steps and prove them sound
and, by doing so, eliminate the risk of programmers implementing unsafe interactions that
can potentially be exploited.

Contributions. We make the following contributions:

1. We introduce Prisma2, a global language for tierless dApps with direct-style client–
contract interactions and explicit access control, implemented as an embedded DSL in
Scala. Further, Prisma automatically enforces the correct program ﬂow (Section 2).
2. A core calculus, MiniPrisma, which formalizes both Prisma and its compiler, as well as a
proof that our compiler preserves the source program behavior in presence of an attacker
that controls the client code (Section 3).

3. Case studies which show that Prisma can be used to implement common applications

without prohibitive performance overhead (Section 5).

4. A comparison of Prisma with a session type and a type state smart contract programming
language and the mainstream programming Solidity/JavaScript model. (Section 6).

2

Prisma in a Nutshell

We present Prisma by the example of a TicTacToe game, demonstrating that client and
contract are written in a single language, where protocols are expressed by control ﬂow
(instead of relying on advanced typing disciplines) and enforced by the compiler.

Example. TicTacToe is a two-player game over a 3 × 3 board in which players take turns in
writing their sign into one of the free ﬁelds until all ﬁelds are occupied, or one player wins by
owning three ﬁelds in any row, column, or diagonal. The main transaction of a TicTacToe
dApp is move(x,y) used by a player to occupy ﬁeld (x,y). A move(x,y) is valid if it is the sender’s
turn and (x,y) is empty. Before the game, players deposit their stakes, and after the game,
the stakes are paid to the winner.

Fig. 1 depicts possible control ﬂows with transitions labeled by client actions that trigger
them. Black arrows depict intended control ﬂows. The dApp starts in the funding state
where both parties deposit stakes via Fund(c). Next, parties execute Move(x, y) until one
party wins or the game ends in a draw. Finally, any party can invoke a payout of the stakes
via Payout().3 Red dashed arrows illustrate the eﬀects of a mismanaged control ﬂow: a

2 Prisma implementation and case studies are publicly available: https://github.com/stg-tud/prisma

(anonymized for double-blind review)

3 We omit handling timeouts on funding and execution for brevity.

D. Richter, D. Kretzler, P. Weisenburger, G. Salvaneschi, S. Faust, M. Mezini

5

Fund(c)

Move(x, y)

Fund(c)

Table 2 Location annotations.

Funding

Executing

Annotations Description

Payout() Payout()

Move(x, y)

Closed

Finished

Payout()

Figure 1 TicTacToe control ﬂow.

@co

@cl

@co @cl

@co @cross

@cl @cross

on contract
on clients
independent copies
on clients and contract
on contract, but also
accessible by client
(illegal combination)

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23

@prisma object TicTacToeModule {

@co @cl case class UU(x: U8, y: U8)

class TicTacToe(

val players: Arr[Address],
val fundingGoal: Uint) {

// u8 is an unsigned 8-bit integer
@co @cross var moves: U8 = "0".u8
@co @cross var winner: U8 = "0".u8
@co @cross val board: Arr[Arr[U8]] =

Arr.ofDim("3".u, "3".u)

@co def move(x: U8, y: U8): Unit =

{ /* ... */ }

@cl def updateBoard(): Unit =

{ /* ... */ }

@cl def fund(): (U256, Unit) =

(readLine("How much?").u, ())
@cl def decideMove(): (U256, UU) =
("0".u, UU(readLine("x-pos?"),
readLine("y-pos?"))

Figure 3 TicTacToe dApp.

24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46

@co val init: Unit = {

while (balance() < FUNDING_GOAL) {
awaitCl(_ => true) { fund() }

}
while (moves < "9".u && winner == "0".u) {

val pair: UU = awaitCl(a =>

a == players(moves % "2".u)) { decideMove() }

move(pair.x, pair.y)

}
awaitCl(a => true) {

readLine("Press (enter) for payout")
("0".u, ())

}
if (winner != "0".u) {

players(winner - "1".u).transfer(balance())

}
else {

players("0".u).transfer(balance() / "2".u)
players("1".u).transfer(balance()) // remainder

}

}

}

}

malicious player could trigger a premature payout preventing the counterpart to get ﬁnancial
gains.

Tierless dApps. Prisma is implemented as a DSL embedded into Scala. Hence, the Prisma
code we show resembles Scala. Prisma interleaves contract and client logic within the same
program. Annotations @co and @cl explicitly place declarations on the contract and on the
client, resp. (cf. Tab. 2). A declaration marked as both @co and @cl has two copies. For
security, code placed in one location cannot access deﬁnitions from the other — an attempt
to do so yields a compile-time error. Developers can overrule this constraint to enable clients
to read contract variables or call contract functions by combining @co with @cross. Combining
@cl with @cross is not allowed – information can only ﬂow from client to contract as part of a
client–contract interaction protocol.

There are three kinds of classes. Located classes are placed in one location (annotated
with either @co or @cl); they cannot contain located members (annotated with either @co or
@cl) and cannot cross the client–contract boundary, e.g., cannot be passed to or returned
from @cross functions. Portable classes are annotated with both @co and @cl. Their instances

6

Prisma: A Tierless Language for Enforcing Protocols

can be passed to and returned from @cross functions; they must not contain mutable ﬁelds.
Split classes have no location annotation; their instances live partly in both locations; they
cannot be passed to or returned from @cross functions and their members must be located.
Prisma code is grouped into modules. While client declarations can use and be used from
standard (non-Prisma) Scala code, contract declarations are not accessible from Scala code,
and can only reference contract code from other Prisma modules (because contract/client
code lives in diﬀerent VMs).

For illustration, consider the TicTacToe dApp (Fig. 3). The TicTacToeModule (Line 1) –
modules are called object in Scala – contains a portable class UU (Line 3) and a split class
TicTacToe (Line 5). Variables moves, winner, board (Lines 10, 11, 13) are placed on the contract
and can be read by clients (@co @cross). The updateBoard function (Line 17) is placed on the
client and updates client state (e.g., client’s UI). The move function (Line 15) is placed on the
contract and changes the game state (move). move is not annotated with @cross, because cross is
intended for functions that do not change contract state and can be executed out-of-order
without tampering with the client–contract interaction protocol.

Scala only has literals signed integers and signed longs, which are uncommon for use in
Ethereum. Prisma provides portable unsigned and signed integers for power-of-two bitsizes
between 23 to 28, with common arithmetic operations, e.g., "0".u8 is an unsigned 8-bit integer
of value 0 (Line 10).

Encoding client–contract protocols.
In Prisma, a client-contract protocol is encoded as
a split class containing dedicated awaitCl expressions for actively requesting and awaiting
messages from speciﬁc clients and standard control-ﬂow constructs. Hence, creating a new
contract instance corresponds to creating a new instance of a protocol; once created, the
contract instance actively triggers interactions with clients.

The awaitCl expressions have the following syntax:

def awaitCl[T](who: Addr => Bool)(body: => (Ether, T)): T
They take two arguments. The ﬁrst (who) is a predicate used by clients to decide whether
it is their turn and by the contract to decide whether to accept a message from a client.
This is unlike Solidity, where a function may be called by any party by default. By forcing
developers to explicitly deﬁne access control, Prisma reduces the risk of human failure. The
second argument (body) is the expression to be executed by the client. The client returns
a pair of values: the amount of Ether and the message to the contract. The former can
be accessed by the contract via the built-in value, the latter is returned by awaitCl. Besides
receiving funds via awaitCl, a contract can also check its current balance (balance()), and
transfer funds to an account (account.transfer(amount))).

For illustration, consider the deﬁnition of init on the right-hand side of Fig. 3, Line 24. It
deﬁnes the protocol of TicTacToe as follows. From the beginning of init the ﬂow reaches awaitCl
in Line 26 where the contract waits for clients to provide funding (by calling fund). Next,
the contract continues until awaitCl in Line 29 and clients execute decideMove (Line 21) until
the game ends with a winner (winner != 0) or a draw (moves >= 9). At this point, – awaitCl in
Line 33 – any party can request a payout and the contract executes to the end. The example
illustrates how direct-style awaitCl expressions and the multitier model enable encoding
multiparty protocols as standard control ﬂow, with protocol phases corresponding to basic
blocks between awaitCl expressions.

Compiling Prisma to Solidity. Prisma’s compiler splits contract methods that contain
awaitCl expressions into one method per awaitCl, each taking the result from the last awaitCl as

D. Richter, D. Kretzler, P. Weisenburger, G. Salvaneschi, S. Faust, M. Mezini

7

1
2
3
4
5
6
7
8
9

contract TTT { State phase = Funding; /*...*/

function Fund() public {

require(phase==Funding);
/*...*/; if (!(balance < FUNDING_GOAL)) phase=Exec }

function Move(int x, int y) public {

require(phase==Exec && sender==players(moves % 2));
/*...*/; if (!(moves < "9".u && winner == "0".u)) phase=Finished }

function Payout() public {

require(phase==Finished); /*...*/; phase=Closed }

Figure 4 Generated Solidity

an argument. The compiler also hardens the program ﬂow against malicious clients. Once
deployed, a contract is public and can be messaged by clients not generated by Prisma –
hence, we cannot assume that clients will actually execute the body passed to them by an
awaitCl expression. To cope with malicious clients trying to tamper with the control ﬂow of
the contract, the compiler generates code to store the current phase before giving control to
the client and to reject methods invoked by wrong clients or in the wrong phase.

For illustration, the code generated from init in Fig. 3 is schematically shown in Fig. 4.
Three methods are generated – one for each awaitCl expression in init – corresponding to
phases in the logical protocol (Fig. 1). The code up until the ﬁrst awaitCl (Line 26) is placed
in the constructor of the generated contract, which ends by setting the active phase to Funding.
The code between the ﬁrst and the second awaitCl either loops back to the ﬁrst awaitCl or
continues to the second one (Line 29), it is placed in the Fund method that requires the phase
to be Funding, and may change it to Exec, if the loop condition fails. Similarly, the method Move
is generated to contain the loop between the second and the third awaitCl (Line 33); and the
method Payout contains the code from the third awaitCl to the end of init. Only the second
awaitCl contains a (non-trivial) access control predicate, which shows up as an additional
assertion in the body of Move (Line 6).

3

Compilation and its Correctness

Prisma is compiled to Solidity and Scala. An important part of our compiler is CPS
translation. Using a standard CPS translation alone, however, is not suﬃcient because the
control ﬂow is intertwined with distribution. We need to consider that, while malicious
clients cannot change the code executed by the contract, they can run diﬀerent code on
the client side than what was assigned to them. Therefore, clients can pass unintended
continuations to the contract. To ensure the correctness of our compiler, we formalize a
selective CPS translation, defunctionalisation toghether with the process of guarding against
unintendend jumps. Assuming the worst case, i.e., all clients are malicious and replace
their code completely executing arbitrary code instead, we prove guarding contract code is
suﬃcent to guarantee that behavior of the contract execution is preserved by compilation.
The compilation process is key in hiding the complexity of enforcing distributed program
ﬂow from the developer – hence, correctness is critical.

We present the core calculus (Section 3.1) MiniPrisma∗ – a hybrid language that includes
elements of both the source (MiniPrismas) and the compilation target (MiniPrismat), while
abstracting over details of both Scala and Solidity. We deﬁne a hybrid language because
the source and the target share many constructs – the hybrid language allows us to focus
on how the diﬀerences are compiled.
We model the compiler as a sequence of steps that transform MiniPrisma∗ programs via
several intermediate representations.

8

Prisma: A Tierless Language for Enforcing Protocols

We deﬁne MiniPrisma∗ semantics as a reduction relation over conﬁgurations consisting
of traces of evaluation events and expressions being evaluated. We distinguish between
a good semantics, which evaluates the program in the usual way, and a bad semantics,
which models attackers by ignoring client instructions and producing arbitrary values that
are sent to the contract.

We prove secure compilation by showing that the observable behavior of the programs
before and after compilation is equivalent. We capture the observable program behavior
by the trace of events generated during program evaluation (as guided by the semantic
deﬁnition) and show trace equivalence of programs before and after compilation.

In more concrete terms, the last point guarantees the integrity for the control ﬂow of the
contract in the presence of malicious clients. Note that compiler correctness in a traditional
sense (i.e., preservation of the semantics through compilation) is not suﬃcient in the presence
of malicious attackers that can tamper with parts of the code.

More speciﬁcally, the compiler preserves control ﬂow by inserting additional guards in
places where the basic blocks of the program have been separated and distributed onto
diﬀerent computers by the CPS translation. This ensures that the control ﬂow among
the parties is guaranteed not to change after compilation. In particular, we consider that
malicious attackers may tamper with certain parts of the code (the client code). Therefore
the guards have to be placed on the contract side. Our guarantees hold despite clients
tampering with the code.

For example, in the source code of the TicTacToe game (Section 2), it is immediately
visible that the players take alternating turns. Yet, the compiled code is separated and
distributed into small chunks of code. Parties execute a chunk and then wait for other parties,
which will decide on a move that inﬂuences where, when, and how to proceed execution. Our
proof shows that we still ensure that control ﬂow of the contract of the original program
even under attack.

3.1 Syntax

The syntax of MiniPrisma∗ (Fig. 5), has three kinds of identiﬁers id, i, j, from unspeciﬁed
sets of distinct names. Pure identiﬁers id are for function arguments and let bindings;
mutable variables i are for heap variable assignment and access. In the target program,
mutable variables j (who, state, clfn, cofn) generated by the compiler can also appear. We
call compiler-generated identiﬁers synthetic. Normal identiﬁers are separated from synthetic
ones to distinguish compiler generated and developer code. Deﬁnitions d and deﬁnitions
for synthetic identiﬁers b are semicolon-separated lists of declarations that assign values to
variables and annotate either the contract or the client location. Each program P consists of
deﬁnitions d and synthetic deﬁnitions b followed by the main contract expression m. Program
P corresponds to a single Prisma split class, d and b to methods and generated methods, and
m to a constructor containing the initialisation of its class members (such as the body of
init, Fig. 3).

Constants c are unsigned 256 bit integer literals and built-in operators. MiniPrisma∗
supports tuples introduced by nesting pairs (::) and eliminated by pattern matching. Tuples
allow multiple values to cross tiers in a single message. Values v are constants, value pairs,
and lambdas. Patterns x are constants, pattern pairs, and variables. Expressions e are
constants, expression pairs, lambdas, variables, variable accesses/assignments, bindings and
function applications.

D. Richter, D. Kretzler, P. Weisenburger, G. Salvaneschi, S. Faust, M. Mezini

9

id ∈ ID

i ∈ I

j ∈ {who, state, clfn, cofn}

(deﬁnition)

(synthetic deﬁnition)

(program)

(constant)

(value)
(pattern)
(expression)

d

b

::= @co this.i = v; d

| @cl this.i = v; d | ()

::= @co this.j = v; b

| @cl this.j = v; b | ()

P

::= d; b; m

c

::= 0 | 1 | 2 | ... | true | false

| () | && | + | == | < | try
| »= | trmp | Done | More

v
x
e

::= c | v :: v | x→e
::= c | x :: x | id
::= c | e :: e | x→e | id
| this.i | this.i := e
| this.j | this.j := e
| x=e; e | e e

(main expression)

m ::= c | m :: m | x→e | id

| this.i | this.i := m
| this.j | this.j := m
| x=m; m | m m
| awaitCls(e, ()→e) | awaitClt(c, ()→e)

Figure 5 MiniPrisma∗ syntax.

m0 c m1 = c(m0, m1)

(m0, ..., mn) = m0 :: ... :: mn :: ()
m0; m1 = () = m0; m1

assert(m0); m1 = true = m0; m1

x ← e1; m2 = x = awaitClt(() → e1); m2

if let x = m1 then e2 else e3 = try(m1, x → e2, () → e3)

Figure 6 Syntactic sugar.

Main expressions m may further contain remote client expressions, embedding client code
into contract code and waiting for its result. The source client expression awaitCls(e, () → e)
can be answered by any client whose address fulﬁlls the predicate speciﬁed as ﬁrst argument.
awaitCls corresponds to direct-style remote access via awaitCl in Prisma. We use the syntax
form awaitClt(c, () → e) to model the execution of code e on the speciﬁed client c. awaitClt
has no correspondence in the source syntax. Our compilation ﬁrst splits the predicate from
the source client expressions into a separate access control guard. Then, it eliminates client
expressions, turning the contract into a passive entity that stops and waits for client input.

We now map the hybrid language MiniPrisma∗ to the source and target languages,
MiniPrismas and MiniPrismat. MiniPrismas has all expressions of MiniPrisma∗, except those
that contain (cid:29)= (bind), trmp (trampoline), Done, More, awaitClt, or synthetic identiﬁers j.
MiniPrismat has all expressions of MiniPrisma∗ except those that contain awaitCls, awaitClt, (cid:29)= .
(cid:29)= and awaitClt may neither appear in source nor target programs; the former is only an
intermediate compiler construct, the latter is used to track of the current evaluating location.

10

Prisma: A Tierless Language for Enforcing Protocols

(frame)

(atom)

(context)

F

::= awaitCls((cid:3), () → e) | (cid:3) e | e (cid:3)

| (cid:3) :: e | e :: (cid:3) | x = (cid:3); e | x = e; (cid:3)
|

this.i := (cid:3) | this.j := (cid:3)
::= this.i | this.j | c | id | x → e

a

E ::= (cid:3) | E :: m | v :: E | E m | v E

|

x = E; m | this.i := E | this.j := E

(event)
(synthetic events)
(conﬁguration)

::= wr(c, i, v) p | msg(c, v) p | ()
::= wr(c, j, v) q | ()

p
q
C ::= p; q; c; m

Figure 7 Frames, Events and conﬁgurations.

initA(d; b; m) = initA(d; b); 0; m
initA(d; b)

= (wr(0, i, v) | ∀ (@co this.i = v) ∈ d)
(wr(0, j, v) | ∀ (@co this.j = v) ∈ b)
(wr(c, i, v) | ∀ (@cl this.i = v) ∈ d, c ∈ A)
(wr(c, j, v) | ∀ (@cl this.j = v) ∈ b, c ∈ A)

Figure 8 Initialization.

In Fig. 6, we deﬁne some syntactic sugar to improve readability. We use
Syntactic sugar.
inﬁx binary operators and tuple syntax for nested pairs ending in the unit value (); we elide
the let expression head for let bindings matching (), assert(x) is a let binding matching true;
we use monadic syntax for let bindings of eﬀectful expressions; if let x = m then e else e is
the application of the built-in try function.

Events and conﬁgurations.
In Fig. 7, we deﬁne left-to-right evaluation contexts E [45];
and compilation frames F [70], such that every expression decomposes into a frame-redex
pair F e or is an atom a. Events p and q are lists that capture the observable side-eﬀects of
evaluating expressions. They are either (a) state changes wr(c, i, v) and wr(c, j, v), from the
initial deﬁnitions or variable assignment, where i and j are the variable being assigned, c the
location, and v the assigned value, or (b) client-to-contract communication msg(c, v), where
c is the address of the client and v the sent value. Conﬁgurations C = p; q; cm, represent
a particular execution state, where p (and q) are traces of normal (and synthetic) events
produced by the evaluation, c is the evaluating location, and m is the expression under
evaluation.

Initialization.
Initialization in Fig. 8 generates the initial program conﬁguration, which
models the decentralized application with a single contract and multiple clients. We model a
ﬁxed set of clients A interacting with a contract. The initialization of a program d; b; m to
a conﬁguration p; q; 0; m leaves the expression m untouched and generates a list of events –
one write event for each normal and synthetic deﬁnition. Location 0 represents the contract.

3.2 Compilation

The compiler eliminates language features not supported by the compilation target one by
one, lowering the abstraction level from (1) direct style communication (DS) – which needs
language support for !-notation [5] – through the intermediate representations of (2) monadic

D. Richter, D. Kretzler, P. Weisenburger, G. Salvaneschi, S. Faust, M. Mezini

11

mnf 0(d; b; m)
mnf (F e)
mnf (a)

= d; b; trmp(mnf ((Done, m)))
= assoc(id0=e; mnf (F id0))
= a

assoc(x0=(x1=m1; m0); m2) = assoc(x1=m1; assoc(x0=m0; m2))
= m
assoc(m)

Figure 9 Monadic normal form transformation.

normal form (MNF) – which needs support for do-notation [2] – and (3) continuation-passing
style (CPS) – which needs higher-order functions – to (4) explicitly encoding ﬁnite state
machines (FSM) – for which ﬁrst-order functions suﬃce. In the following, we provide an
intuition for the compiler steps and subsequently their formal deﬁnitions.

First, the compilation steps mnf and assoc transform DS remote communication awaitCle
to variable bindings (x ← e) and nested let bindings are ﬂattened such that a program is
preﬁxed by a sequence of let expressions. Second, step guard generates access control guards
around client expressions to enforce correct execution even when clients behave maliciously.
Third, step cps transforms previously generated let bindings for remote communication
(x ← e1; m2) to monadic bindings e1 (cid:29)= x → m2. Fourth, step defun transforms functions
into data structures that can be sent over the network and are interpreted by a function (i.e.,
an FSM) on the other side. Compared to standard defunctionalization, we handle two more
issues. First, we defunctionalize the built-in higher-order operator ( (cid:29)= ) by wrapping the
program expression into a call to a trampoline trmp(...) and transforming the bind operator
(... (cid:29)= x → ...) to the (More, ..., ...) data structure; the trampoline repeatedly interprets
the argument of More until it returns Done instead of More signaling the program’s result.
Second, we keep contract and client functions separate by generating separate synthesized
interpreter functions, called cofn and clfn, thereby splitting the code into the parts speciﬁc
to contract and client.

MNF transformation (Fig. 9). The mnf 0 function wraps the main expression m into a
call to the trampoline with the pair (Done, m) – signaling the ﬁnal result – as argument.
Then, mnf transforms expressions recursively, binding sub-expressions to variables, resulting
in a program preﬁxed by a sequence of let bindings. As recursive calls to mnf may return
chains of let bindings, we apply assoc to produce a ﬂat chain of let bindings. Given a let
binding, whose sub-expressions are in MNF, associativity recursively ﬂattens the expression,
by moving nested let bindings to the front, (... (... m0; m1); m2 = ... m0; (... m0; m2)),
creating a single MNF expression (i.e., assoc is composition for MNF terms).

Guarding (Fig. 10). We insert access-control guards for remote communication expressions
←s to enforce (i) the execution order of contract code after running the client expression
and (ii) that the correct client invokes the contract continuation. The transformation sets
the synthetic variable state to a unique value before the client expression, and stores the
predicate to designate valid clients in the synthetic variable who. After the client expression,
the generated code asserts that the contract is in the same state, and checks that the sender
fulﬁlls the predicate. The assertion trivially holds in the sequential execution of the source
language, but after more compilation steps the client will be responsible for calling the correct
continuation on the contract. Since client code is untrusted, the contract needs to ensure
that only the correct client can invoke only the correct continuation.

12

Prisma: A Tierless Language for Enforcing Protocols

guard 0(d; b; trmp(m))

= d; b; trmp(guard(m))

guard

(cid:18) x ←s (e0, () → e1);

(cid:19)

m2

guard(x = e0; m1)
guard(m)

Figure 10 Guarding.









=

this. who := e0; this. state := c;
x ←s (() → true, () → e1);
assert(this. state == c &&

this. who(this. sender));









this. state := 0; guard(m2)
where c fresh
= x = e0; guard(m1)
= m

cps0(d; b; trmp(m))

= d; b; trmp(cps(m))

cps(x ←s (() → true, e0); m1) = e0 (cid:29)= (x → cps(m1))
cps(x = e0; m1)
cps(m)

= x = e0; cps(m1)
= m

Figure 11 Continuation-passing style transformation.

defun0(d; b; e)

= defun(d; coclfn(b, id, assert(false), assert(false)); e)

where

id fresh

d; coclfn(b, id,

e1,alt,

e2,alt
);

(() → e1) (cid:29)= (x → e2)























=

d; coclfn(b, id,

if let (c :: fv(() → e1)) = id

then e1 else e0

1,alt,

if let (c :: x :: fv(x → e0
2 else e0

then e0

2,alt);
(More, c :: fv(() → e1), c :: fv(x → e0

2)) = id

2))































defun

defun

defun

d; coclfn(b, id,
e1,alt, e2,alt);

x = e0; e1
d; coclfn(b, id,
e1,alt, e2,alt);









e

coclfn(b, id, e1,alt, e2,alt)

Figure 12 Defunctionalization.

where
and

c fresh
d; coclfn(b, id, e0
1,alt, e0
defun(d; coclfn(b, id, e1,alt, e2,alt); e2)

2,alt); e0

2 =

= d; coclfn(b, id, e1,alt, e2,alt); x = e0; defun(e1)

= d; coclfn(b, id, e1,alt, e2,alt); e

= @cl this. clfn = id → e1,alt;

@co this. cofn = id → e2,alt; b

D. Richter, D. Kretzler, P. Weisenburger, G. Salvaneschi, S. Faust, M. Mezini

13

CPS transformation (Fig. 11). The cps transformation turns the chains of let bindings
produced by mnf into CPS. The chain contains three cases of syntax forms: (1) monadic
binding (x ← ...; m1), (2) let binding (x = e0; m1), or (3) ﬁnal expression. For (1), cps
replaces the monadic binding with an explicit call to the bind operator (... (cid:29)= (x → cps(m1))).
For (2) and (3), cps recurses into the tail of the chain. This resembles do-notation desugaring
(e.g., in Haskell).

Defunctionalization (Fig. 12). The defun function transforms the chains of let bindings
and bind operators produced by cps, which contains three cases of syntax forms: (1) a bind
operator (e1 (cid:29)= e2), or (2) a let binding (x = e1; e2), or (3) the ﬁnal expression. For (1), e1
and e2 are replaced by data structures that contain values for the free variables in e1 and e2
and are tagged with a fresh ID. The body of the expression is lifted to top-level synthetic
deﬁnitions. For this, defun modiﬁes the synthetic deﬁnitions b by extracting the body e1,alt
of the synthetic clfn deﬁnition and the body e2,alt of cofn, and by adding an additional
conditional clause to these deﬁnitions. The added clause answers to requests for a given ID
with evaluating the original expression. For (2) and (3), defun recurses into the expressions.
After defunctionalization, lambdas x → e0 are lifted and assigned a top-level identiﬁer
id0 and lambda applications, id0(e1), are replaced with calls to a synthesized interpreter
function fn(id0, e1). The latter branches on the identiﬁer and executes the code that was
lifted out of the original function.

Compiling. The comp function composes the compiler steps after mnf :

= defun ◦ cps ◦ guard

comp
comp0 = defun0 ◦ cps0 ◦ guard 0

3.3 Semantics

We model the semantics as a reduction relation over conﬁgurations p; q; c; m → p0; q0; c0; m0.
Location c = 0 denotes contract execution, otherwise execution of client of address c. We
distinguish good (→g) and bad (→b) evaluations (Fig. 14 and 15); shared rules are in black,
without subscript (→).

Attacker model. Attackers can control an arbitrary number of clients and make them
send arbitrary messages. Hence, the bad semantics can answer a request to a client with an
arbitrary message from an arbitrary id. We use evaluation with bad semantics to show that
our compiler enforces access control against malicious clients.

Good evaluations of client expressions in the source language (Rgs) and calls to the
trampoline in the target language (Rgt) reduce to a client that fulﬁls the given predicate.
We require that predicates evaluate purely. Hence, p and q do not change in the evaluation.
On the other hand, bad evaluation of client expressions in the source language (Rbs) and of
calls to the trampoline in the target (Rbt) ignore the predicate, choosing an arbitrary client.
The trampoline ends, when it reaches Done (Rt). Further, after chosing a client to evaluate,
the good evaluation (Rg) continues to reduce the client expression to a value, while the bad
evaluation (Rb) replaces the expression e with a (manipulated) arbitrary value v0. Both
evaluations (Rg, Rb) emit the message event msg(c, v) and an assignment to the special
variable sender, when a client expressions is reduced to a value v, to record the client–contract
interaction.

14

Prisma: A Tierless Language for Enforcing Protocols

[c
[id
0 :: e0

⇒ c] = []
⇒ v] = [id 7→ v]
⇒ e0

1)] = [e0

⇒ (e0

0] · [e1

⇒ e0
1]

[(e0 :: e1)

Figure 13 Pattern matching.

(Rgs)

p; q; 0; v(c) →∗ p; q; 0; true
p; q; 0; awaitCls(v, () → e) →g p; q; 0; awaitClt(c, () → e)

(Rbs)
p; q; 0; awaitCls(v, () → e) →b p; q; 0; awaitClt(c, () → e)

(Rgt)

p; q; 0; trmp

(Rbt)

p; q; 0; trmp









More,
v1 :: e1,
v2 :: e2

More,
v1 :: e1,
v2 :: e2

p; q; 0; v(c) →∗ p; q; 0; true



 →g p; q; 0;

(cid:18) id = awaitClt(c, this.clfn(v1 :: e1));

(cid:19)

trmp(this.cofn(v2 :: id :: e2))



 →b p; q; 0;

(cid:18) id = awaitClt(c, this.clfn(v1 :: e1));

(cid:19)

trmp(this.cofn(v2 :: id :: e2))

(Rt)
p; q; 0; trmp(Done, v) → p; q; 0; v

(Rg)

p; q; c; e →∗ p0; q0; c; v
p; q; 0; awaitClt(c, () → e) →g p; q msg(c, v) wr(0, sender, c); 0; v

(Rb)
p; q; 0; awaitClt(c, () → e) →b p; q msg(c, v0) wr(0, sender, c); 0; v0

Figure 14 Evaluation (1/2).

Common Evaluation (Fig. 15). Expressions are reduced under the evaluation context E on
the current location (Re), assignment to variables is recorded in the trace (Rset◦), accessing
a variable is answered by the most recent assignment to it from the trace in the current
location (Rget◦). For synthetic variables, we use the synthetic store (Rget†, Rset†).
Binary operators are deﬁned as unsigned 256 bit integer arithmetic; we only show the rule
for addition (Rop). Further, we give rules for conditionals (Rt, Rf), let binding (Rlet) and
function application (Rlam) using pattern matching.

Pattern matching (Fig. 13). Matching [x
⇒v] is a partial function, matching patterns x
with values v, returning substitution of variables id to values. Matching is recursively deﬁned
over pairs; it matches constants to constants, identiﬁers to values by generating substitutions,

(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
D. Richter, D. Kretzler, P. Weisenburger, G. Salvaneschi, S. Faust, M. Mezini

15

if p; q; 0; m → p0; q0; 0; m0
if wr(c, i, v) ∈ p
if wr(c, j, v) ∈ q

(Re)
p; q; 0; E[m]
(Rget◦) p; q; c; this.i
(Rget†) p; q; c; this.j
(Rset◦) p; q; c; this.i := v
(Rset†) p; q; c; this.j := v
(Rop)

p; q; c; v0 + v1


→ p0; q0; 0; E[m0]
→ p; q; c; v
→ p; q; c; v
→ p wr(c, i, v); q; c; ()
→ p; q wr(c, j, v); c; ()
→ p; q; c; v0



(Rt)

p; q; c;


 → p; q; c; e0
0

if let x = v
then e0
else e1
if let x = v
then e0
else e1
(Rapp) p; q; c; (x → e) v
→ p; q; c; e0
(Rlet) p; q; c; let x = v; m → p; q; c; m0

 → p; q; c; e1

p; q; c;

(Rf)







if v0 = v0 + v1

if e0

0 = [x

⇒v] e0

if e0 = [x
if m0 = [x

⇒v] e
⇒v] m

Figure 15 Evaluation (2/2).

and fails otherwise. Substitutions [id7→v], in turn, can be applied to terms e, written [id7→v] e
(capture-avoiding substitution). Substitutions σ compose right-to-left (σσ0)x = σ(σ0x).

3.4 Secure Compilation

We prove that the observable behavior of the contract before and after compilation is
equivalent. We capture the observable behavior by execution traces and show that trace
equivalence holds even when the program is attacked, i.e., reduced by →∗
b .

Modelling Observable Behavior. The only source of observable nondeterminism in the
bad semantics is the evaluation of awaitCls and awaitClt. As clients decisions on message
sending are inﬂuenced by the state of contract variables, tracking incoming client messages
If
and state changes in the trace suﬃces to capture the observable program behavior.
the observable behavior is the same for the source and the compiled programs, they are
indistinguishable. Thus, behavior preservation amounts to trace equality on programs before
and after compilation. Further, it suﬃces to model equality for non-stuck traces. The
evaluation gets stuck (program crash) on assertions that guard against deviations from the
intended program ﬂow. The Ethereum Virtual Machine reverts contract calls that crash, i.e.,
state changes of crashed calls do not take eﬀect, hence, stuck traces are not observable.

Since bad evaluation is nondeterministic, we work with not just programs, expressions
and conﬁgurations, but program sets, expression sets, and conﬁguration sets. Let p; q; m ⇓ be
the trace set of the conﬁguration p; q; 0; m, e.g., the set of tuples of the ﬁnal event-sequence
p0 and value v of all reduction chains that start in p; q; 0; m and end in p0; 0; q0; v. Our trace
set deﬁnition does not include synthetic events q0 of the ﬁnal conﬁguration. Synthetic events
are introduced through compilation; excluding them allows us to put source and target trace
sets in relation. Further, let the trace set of a conﬁguration set T ⇓, be the union of the
trace sets for each element:

p; q; m ⇓ = { (p0, v) | (p; q; 0; m) →∗

b (p0; q0; 0; v) }

T ⇓ =

[

p; q; m ⇓

p;q;m∈T

(cid:90)
(cid:90)
(cid:90)
16

Prisma: A Tierless Language for Enforcing Protocols

We say that two conﬁguration sets T and S are equivalent, denoted by T ≈ S, iﬀ T and

S have the same traces sets:

(T ≈ S) ⇔ (T ⇓ = S ⇓)

By this deﬁnition, two expressions that eventually evaluate to the same value with the
same trace are related by trace equality. We use this notion of trace equality to prove that a
source program is trace-equal to its compiled version by evaluating the compiled program
forward →∗

b and the original program backward ←∗

b until conﬁgurations converge.

Secure Compilation. Theorem 1 states our correctness property, which says that observable
traces generated the malicious evaluation of programs are preserved (≈) by compilation. The
malicious evaluation models that client code has been replaced with arbitrary code, while
contract code is unchanged. The preservation of observable traces implies the integrity of
the (unchanged) contract code. Secure compilation guarantees that developers can write safe
programs in the source language without knowledge about the compilation or the distributed
execution of client/contract tiers.

(cid:73) Theorem 1 (Secure Compilation). For each program P over closed terms, the trace set
of the program under attack equals the trace set of the compiled program under attack:
∀P. { initA(comp0(mnf 0((P )))) } ≈ { initA(P ) }.

We ﬁrst show that trace equality holds for the diﬀerent compiler steps. Some compiler
steps are deﬁned as a recursive term-to-term transformation on open terms, whereas traceset
equality is deﬁned by reducing terms to values, i.e., on closed terms. Since all evaluable
programs are closed terms, we show that the compiler steps preserve the traceset of an open
⇒ v]. We formulate the necessary lemmas and sketch
term e that is closed by substitution [x
the proofs – the detailed proof is in Appendix C.

(cid:73) Lemma 1 (assoc correct). { p; q; [x

⇒v] assoc(m) } ≈ { p; q; [x

⇒v] m }

(cid:73) Lemma 2 (mnf correct). { p; q; [x

⇒v] mnf (m) } ≈ { p; q; [x

⇒v] m }

(cid:73) Lemma 3 (mnf’ correct). { initC (mnf 0(d; b; m)) } ≈ { initC (d; b; m) }

(cid:73) Lemma 4 (comp correct). { [x

⇒v] initA(comp(d; b; trmp(m))) } ≈ { initA(d; b; trmp([x

⇒v] m)) }

(cid:73) Lemma 5 (comp’ correct). { [x

⇒v] initA(comp0(d; b; trmp(m))) } ≈ { initA(d; b; trmp([x

⇒v] m)) }

Proof sketch. Lemma 1–5 hold by chain of transitive trace equality relations. We show
that a term is trace-equal to the same term after compilation, by evaluating the compiled
program (→∗) and the original program (←∗) until conﬁgurations converge. In the inductive
case, we can remove the current compiler step in redex position under traceset equality (≈)
since traces before and after applying the compiler step are equal by induction hypothesis.
An interesting case is the proof of comp for P = d; b; awaitCl(e0, () → e1). The compiler
transforms the remote communication awaitCls into the use of a guard and a trampoline.
The compiled program steps to the use of awaitClt, the source program to awaitCls. In
the attacker relation →b, arbitrary clients can send arbitrary values with awaitClt, lead-
ing to additional traces compared to the ones permitted in the source program. where
communication is modeled by awaitCls. We observe that awaitCls generates the trace el-
ements msg(c, v), wr(0, sender, c) for all v and that awaitClt generates the trace elements
msg(c0, v), wr(0, sender, c0) for all v, c0, which diﬀer for c0 6= c.

(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
D. Richter, D. Kretzler, P. Weisenburger, G. Salvaneschi, S. Faust, M. Mezini

17

Compilation adds an assert expression (Fig. 10) evaluated after receiving a value from
a client. The assert gets stuck for conﬁgurations that produce trace elements with c0 6= c,
removing the traces of such conﬁgurations from the trace set, leaving only the traces where
c0 = c. Hence, the trace set before and after compilation is equal under attack.

4

Implementation

Prisma is a language embedded into Scala as a host language. Prisma’s features are im-
plemented as a source-to-source macro that transforms Scala code to Scala code. The
implementation entails 21 Scala ﬁles, 3 412 lines of Scala source code (non-blank, non-
comment) licensed under Apache 2.0 Open Source. In addition to the source code of the
compiler, we implemented several case studies in Prisma. We further implemented the case
studies in Solidity, and test runners in JavaScript for them. A visual comparison of the LOC
for the Prisma vs the Solidity case studies can be found in Appendix B.

Prisma contains implementation of the serialisable datatypes, portable between Scala and
the EVM (ﬁxed-size arrays, dynamic arrays, unsigned integers of length of powers of two up
to 256 bit). Our compiler implementation is based on Scala macros. The compiler phases are
macros recursing over the Scala AST: namely the guarding phase, and the “simplifying” phase
(including MNF translation, CPS translation of terms, defunctionalisation) and the translation
of (a subset) of Scala expressions and types to an custom intermediate representation based on
Scala case classes. The intermediate representation is translated to Solidity code, and passed
to the Solidity compiler (solc). Our runtime wraps web3j [6] (for invoking transactions and
interacting with the blockchain in general) and headlong [3] (for serialisation/deserialisation in
the Ethereum-speciﬁc serialisation format), as well code to parse of Solidity and Ethereum
error messages to translate them to Scala error messages.

The backend to Solidity is well separated. By disabling the compilation step to Solidity
in the compilation pipeline, we could also run distributed code on multiple JVMs instead,
for example. In this case, the “contract code” would be executed by a computer to serve as
the “server”, and other computers would run the “client code” to interact with the server.

5

Evaluation

We evaluate Prisma along two research questions:

RQ1 Does Prisma support the most common dApps scenarios?
RQ2 Do Prisma’s abstractions aﬀect performance?

Case Studies and Expressiveness (RQ1). Five classes of smart contract applications have
been identiﬁed [23]: Financial, Wallet, Notary, Game, and Library. To answer RQ1, we
implemented at least one case study per category in Prisma. We implemented an ERC-20
Token,4 a Crowdfunding, and an Escrowing dApp as representatives of ﬁnancial dApps.
We cover wallets by implementing a multi-signature wallet, a special type of wallet that
provides a transaction voting mechanism by only executing transactions, which are signed
by a ﬁxed fraction of the set of owners. We implemented a general-purpose notary contract
enabling users to store arbitrary data, e.g., document hashes or images, together with a

4 A study investigating all blocks mined until Sep 15, 2018 [67], found that 72.9 % with an accumulated

market capitalization of 12.7 B USD.

18

Prisma: A Tierless Language for Enforcing Protocols

Token

Fund

Escrow

Wallet

Notary

Rock-P-S

TicTacToe

Hangman

CCheckers

Library

Reuse

Channel

Prisma

Solidity

T

F

E

W

N

RPS

T3

Hm

CC

Lib

Re

Ch

T

F

E

W

N

RPS

T3

Hm

CC

Lib

Re

Ch

Prisma

Solidity

T

F

E

W

N

RPS

T3

Hm

CC

Lib

Re

Ch

0

500 1,000 1,500

−10 −5 0

5

10

0

50

100

150

−20 −10 0

10

20

Gas usage [kGas]

Gas overhead [%]

Gas usage [kGas]

Gas overhead [%]

(a) Gas usage per deploy-
ment.

(b) Gas overhead per
deployment.

(c) Gas usage per inter-
action.

(d) Gas overhead per
interaction.

Figure 16 The cost of abstraction. Gas overhead of contracts written with Prisma vs. Solidity.

(The right plot displays minima, averages, maxima.)

submission timestamp and the data owner. As games, we implemented TicTacToe (Section 2),
Rock-Paper-Scissors, Hangman and Chinese Checkers. Rock-Paper-Scissors makes use of
timed commitments [19], i.e., all parties commit to a random seed share and open it after all
commitments have been posted. The same technique can be used to generate randomness
for dApps in a secure way. To reduce expensive code deployment, developers outsource
commonly used logic to library contracts. We demonstrate library-based development in
Prisma by including a TicTacToe library to our case studies and another TicTacToe dApp
which uses that library instead of deploying the logic itself.

We implemented a state channel [62, 43, 42] for TicTacToe in Prisma. State channels
are scalability solutions enabling parties to move their dApp to a non-blockchain consensus
system, falling-back to the blockchain in case of disputes.

Our case studies are between 1 K and 7.5 K bytes which is a representative size: Smart
contracts are not built for large-scale applications since the gas model limits the maximal
computation and storage volumes and causes huge fees for complex applications. The median
(average, lower quantile, upper quantile) of the bytecode size of distinct contracts deployed
at the time of writing is at 4 K (5.5 K, 1.5 K, 7.5 K) [16]. We further elaborate on the case
studies in Appendix A.

Performance of Prisma DApps (RQ2). Performance on the Ethereum blockchain is usually
measured in terms of an Ethereum-speciﬁc metric called gas. Each instruction of the Ethereum
Virtual Machine (EVM) consumes gas which needs to be paid for by the users in form of
transaction fees credited to the miner. We refer to the Ethereum yellow paper [1] for an
overview of the gas consumption of the diﬀerent EVM instructions. To answer RQ2, we
implement our case studies in both Prisma and in Solidity/JavaScript and compare their gas
consumption. Unlike prior work, we do not model a custom gas structure, but consider the
real EVM gas costs [85].

Experimental setup. We execute each case study on diﬀerent inputs to achieve diﬀerent
execution patterns that cover all contract functions. Each contract invocation that includes
parameters with various sizes (e.g., dynamic length arrays) is executed with a range of realistic
inputs, e.g., for Hangman, we consider several words (2 to 40 characters) and diﬀerent order
of guesses, covering games in which the guesser wins and those in which they lose. Prisma

D. Richter, D. Kretzler, P. Weisenburger, G. Salvaneschi, S. Faust, M. Mezini

19

and Solidity/JavaScript implementations are executed on the same inputs.

We perform the measurements on a local setup. As the execution in the Ethereum VM
is deterministic, a single measurement suﬃces. We set up the local Ethereum blockchain
with Ganache (Core v2.13.2) on the latest supported hard fork (Muir Glacier). All contracts
are compiled to EVM byte code with solc (v0.8.1, optimized on 20 runs). We diﬀerentiate
contract deployment and contract interaction. Deployment means uploading the contract to
the blockchain and initializing its state, which occurs just once per application instance. A
single instance typically involves several contract interactions, i.e., transactions calling public
contract functions.

Results. Fig. 16 shows the average gas consumption of contract deployment (Fig. 16a) and
interaction (Fig. 16c) as well as the relative overhead of Prisma vs. Solidity/JS of deployment
(Fig. 16b) and interaction (Fig. 16d). As the gas consumption of contract invocations depends
heavily on the executed function, the contract state, and the inputs, we provide the maximal,
minimal and averaged overhead. The results show that the average gas consumption of
Prisma is close to the one of Solidity/JS. Our compiler achieves a deployment overhead of
maximally 6 % The interaction overhead is below 10 % which at most amounts to 3.55 K gas.5
Prisma’s deployment overhead is mainly due to the automated ﬂow control. To guarantee
correct execution, Prisma manages a state variable for dApps with more than one state. The
storage reserved for and the code deployed to maintain the state variable cause a constant
cost of around 45 K gas. In Solidity, developers manually check whether ﬂow control is needed
and, if so, may derive the state from existing contract variables to avoid a state variable if
possible.

The Token, Notary, Wallet and Library case studies do not require ﬂow control: each
function can be called by any client at any time. Hence, their overhead is small. Escrow,
Hangman and Rock-Paper-Scissors require a state variable, also in Solidity – which partially
compensates the overhead of Prisma’s automated ﬂow control. Crowdfunding, Chinese
Checkers, TicTacToe (Library and Channel) do not require an explicit state variable in
Solidity, as the state can be derived from the contract variables, e.g., the number of moves.
Thus, these case studies have the largest deployment overhead.

While the average relative interaction overhead is constantly below 10 % e.g., in Crowd-
funding, TicTacToe Channel, and Rock-Paper-Scissors. Yet, case studies with such spikes
also involve interactions that are executed within the same dApp instance with a negative
overhead and amortize the costs of more costly transactions. These deviations are also mainly
due to automated ﬂow control. In EVM, setting a zero variable to some non-zero value costs
more gas (20 K gas) than changing its value (5 K gas) [85], and setting the value to zero saves
gas. Occupying and releasing storage via the state variable can cost or save gas in a diﬀerent
way than in traditional dApps without an explicit state variable, leading to diﬀerent (and
even negative) overhead in diﬀerent transactions.

As Prisma preserves the number of contract interactions, the on-chain execution time
of dApps is not aﬀected by our compiler. In Ethereum, the estimated conﬁrmation time
for transactions is 3-5 minutes (assuming no congestion), which makes on-chain execution
dominate the total execution time. Thus, the overhead of Prisma, if any, is negligible.

Note that per se it is not possible to achieve a better gas consumption in Prisma than in
Solidity – every contract compiled from Prisma can be implemented in Solidity. Given the
abstractions we oﬀer beyond the traditional development approach, and the sensibility of
smart contracts to small changes in instructions, we conclude that our abstractions come

5 equals 0.59 USD based on gas price and exchange course of April 15, 2021

20

Prisma: A Tierless Language for Enforcing Protocols

Table 17 Related work.

Language Encoding Perspective Protocol

Solidity
Obsidian
Nomos

FSM
FSM
MNF

Local
Local
Local

Assertions
Type states
Session types

Prisma

DS

Global

Control ﬂow

with acceptable cost. We are conﬁdent that further engineering eﬀort can eliminate the
observed overhead.

Threats to validity. The main threat is that the manually written code may be optimized
better or worse than the code generated by the compiler. We mitigate this threat by applying
all gas optimizations, our compiler performs automatically, to the Solidity implementations.
An external threat is that changes in the gas pricing of Ethereum may aﬀect our evaluation.
For reproducibility, we state the Ethereum version (hard fork), we used in the paper.

6 Discussion and Related Work

Smart Contract Languages for Enforcing Protocols. We compare Prisma to Solidity,
Obsidian [33, 35, 34], and Nomos [39, 40]. We highlight these languages as those also
address the correctness of the client–contract interactions. Tab. 17 overviews the features of
the surveyed languages for (a) the perspective of deﬁning interacting parties, (b) the used
encoding of the interaction eﬀects, and (c) the method used to check the contract-client
interaction protocol. Fig. 4, 18, and 19 show code snippets in these languages, each encoding
the TicTacToe state machine from Fig. 1. All three languages focus solely on the contract
and do not state how clients are developed, hence only contract code is shown.

All three approaches take a local perspective on interacting parties: Contract and
clients are deﬁned separately, and their interaction is encoded by explicit send and receive
side eﬀects. In Solidity and Obsidian, receive corresponds to arguments and send to return
values of methods deﬁned in the contract classes. In Nomos, send and receive are expressed as
procedures operating over a channel – given a channel c, sending and receiving is represented
by explicit statements (x = recv c; ... and send c x; ...).

The approaches diﬀer in the encoding style of communication eﬀects. Solidity and
Obsidian adopt an FSM-style encoding: Contract ﬁelds encode states, methods encode
transitions. The contract in Fig. 4 represents FSM states via the phase ﬁeld with initial
state Funding (Line 1). The Fund, Move and Payout methods are transitions, e.g., Payout transitions
the contract into the ﬁnal state Closed (Line 9). The FSM-style encoding results in an
implicitly-everywhere concurrent programming model, which is complex to reason about and
unﬁtting for dApps because the execution model of blockchains is inherently sequential – all

1
2
3
4
5
6
7
8

asset contract TTT {

state Funding{}; state Executing{}; state Finished{}; state Closed{}
transaction Fund(TTT@Funding>>(Funding|Executing) this, int c) {

/*...*/; if (/* enough funds? */) -> Executing else -> Funding }

transaction Move(TTT@Executing>>(Executing|Finished) this, int x, int y) {

/*...*/; if (/* game over? */) -> Finished else -> Executing }

transaction Payout(TTT@Finished>>Closed this) {

/*...*/; -> Closed } }

Figure 18 Obsidian.

D. Richter, D. Kretzler, P. Weisenburger, G. Salvaneschi, S. Faust, M. Mezini

21

1
2
3
4
5
6
7
8
9
10
11

=

int -> +{ notenough: Funding, enough: Executing }

type Funding
type Executing = int -> int -> +{ notdone: Executing, done: Finished }
type Finished =
proc contract funding : . |{*}- ($ s : Funding) = {

int -> 1

a = recv $ s ; /* ... */
if /* enough funds? */ then $ s .notenough; $ s <- funding
else $ s .enough; $ s <- executing }

proc contract executing : . |{*}- ($ s : Executing) = {

x = recv $ s ; y = recv $ s ; /* ... */
if /* game over? */ then $ s .notdone; $ s <- executing

else $ s .done; z = recv $ s ; close $ s }

Figure 19 Nomos.

NomosR

NomosS

Ψ; Γ, (y:A) ‘ P :: (c : B)
Ψ; Γ ‘ (y←recv c; P ) :: (c : A (cid:40) B)

Ψ; Γ ‘ P :: (c : B)

Ψ; Γ, (w:A) ‘ (send c w; P ) :: (c : A ⊗ B)

Obsidian
(transaction T m(t.(s»s0) x){...}) ∈ memberst0
∆, e:t.s ‘ e0.m(e) : T a ∆, e:t.s0

Figure 20 Excerpts of simpliﬁed Nomos and Obsidian typing rules.

method invocations are brought into a world-wide total order. Nomos adopts the monadic
normal form (MNF) via do-notation to order eﬀects. While the implementation of TicTacToe
in FSM style requires three methods(Fund, Move, Payout – one per transition), we only need
two methods in MNF-style (funding, executing – one per state with multiple entry points),
and a single method in DS-style (init). For instance, the sequence of states and transitions
Executing M ove(x,y)
−−−−−−→ Closed in Nomos can be written sequentially in
do-notation by inlining the last function which only has a single entry point. Still, do-notation
can be cumbersome (e.g., funding and executing in Nomos are separate methods that cannot
be inlined since they have multiple entry points and model loops).

−−−−−−→ F inished P ayout()

All three languages require an explicit protocol for governing the send–receive interac-
tions, to ensure that every send eﬀect has a corresponding receive eﬀect in an interacting –
separately deﬁned – party. In Solidity, developers express the protocol via run-time assertions
to guard against invoking the methods in an incorrect order (e.g., require(phase==Finished) in
Fig. 4, Line 3). Unlike Solidity, which does not support statically checking protocol compli-
ance, Nomos and Obsidian employ behavioral typing for static checks. Deployed contracts
may interact with third-party, potentially manipulated clients. Compile-time checking alone
cannot provide security guarantees. Yet, complementing run-time enforcement with static
checks helps detecting cases that are guaranteed to fail at run time ahead of time.

Obsidian employs typestates to increase safety of contract–client communication. Con-
tracts deﬁne a number of typestates; A method call can change the typestate of an object,
and calling a method on a receiver that is in the wrong typestate results in a typing error.
Each method in Fig. 18 is annotated with the state in which it can be called, e.g., Payout
requires state Finished, and transitions to Closed (Line 7).

Nomos employs session types. The session types Funding, Executing, Finished in Fig. 19 encode
the protocol. Receiving a message is represented by a function type, e.g., in the Funding state,
we receive an integer int -> ... (Line 1). We respond by either repeating the funding (Funding),

22

Prisma: A Tierless Language for Enforcing Protocols

or continuing to the next state of the protocol (Executing). This is represented by internal
choice +{ ... } that takes multiple possible responses giving each of them a unique label
(notenough and enough). Type 1 indicates the end of a protocol (Line 3). The contract processes
funding (Line 4) and executing (Line 8) implement the protocol. The recv operation (Line 5)
takes a session-typed channel of form T -> U, returns a value of type T and changes the type of
the channel to U. A session type for internal choice (+{ ... }), requires the program to select
one of the oﬀered labels (e.g., $ s .notenough in Line 6 and $ s .enough in Line 7), e.g., in the left
and right branch of a conditional statement.

Type systems. We show excerpts of simpliﬁed typing rules for Nomos and Obsidian
(Fig. 20). Nomos rules have the form Ψ; Γ ‘ P :: (c:A). A process P oﬀers a channel c of type
A with values in context Ψ and channels in Γ. We can see that variables change their type
to model the linearity of session types in the NomosS (and NomosR) rule: Sending (and
receiving) changes the type of the channel c from A(cid:40)B to B (and A⊗B to B). Obsidian
rules have the form ∆ ‘ e:t a ∆0. An expression e has type t in context ∆ and changes ∆
to ∆0. We can see that variables change their type on method invocation (Obsidian): A
method m in class t0 with arguments ei of type ti, returning T, changes the type state of the
arguments from si to s0
i. For Prisma, instead, a standard judgement Γ ‘ e : T suﬃces for
communication. Variables do not change their type. awaitCl(p){b} has type T in context Γ if
p is a predicate of Addr and b is a pair of Ether and T :

Prisma
Γ ‘ p : Addr → Bool

Γ ‘ b : Ether × T

Γ ‘ awaitCl(p){ b } : T

Prisma. As shown in Tab. 17, Prisma occupies an unexplored point in the design space:
global instead of local perspective on interacting parties, direct style (DS) instead of FSM or
MNF encoding of eﬀects, and control ﬂow instead of extra protocol for governing interactions.
Prisma takes a global perspective on interacting parties. The parties execute the same
program, where pairs of send and receive actions that “belong together” are encapsulated
into a single direct-style operation, which is executed diﬀerently by sending and receiving
parties. Hence, dApps are modeled as sequences and loops of send-receive-instructions shared
by interacting parties. Due to the global direct style perspective, it is syntactically impossible
to deﬁne parties with mismatching send and receive pairs. Hence, a standard System-F-like
type system suﬃces. The interaction protocol follows directly from the sequential control
ﬂow of interaction points in the program – the compiler can automatically generate access
and control guards with correctness guarantees. Semantically, Prisma features a by-default-
sequential programming model, intentionally making the sequential execution of methods
explicit, including interaction eﬀects.

The global direct-style model also leads to improved design of dApps: No programmatic
state management on the contract and no so-called callback hell [44] on the client. The
direct style is also superior to Nomos’ MNF style. The tierless model avoids boilerplate:
Client code can directly access public contract variables, unlike JavaScript code, which has
to access them via a function call that requires either an await expression or a callback;6
additionally, the developer has to implement getters for public variables with complex data
types such as arrays.7 We provide some code measurements (lines of code and number of
cross-tier control-ﬂow calls) of our Prisma and Solidity/JS dApp case studies in Appendix B.

6 Obsidian and Nomos do not provide any client design, so we can only compare to Solidity/JavaScript.
7 For simple data types the getter is generated automatically.

D. Richter, D. Kretzler, P. Weisenburger, G. Salvaneschi, S. Faust, M. Mezini

23

Finally, using one language for both the contract and the clients naturally enables static
type safety of values that cross the contract–client boundary: an honest, non-compromized
client cannot provide inconsistent input, e.g., with wrong number of parameters or falsely
encoded types.8 In a setting with diﬀerent language stacks, it is not possible to statically
detect type mismatches in the client–contract interaction; e.g.„ Solidity has a type bytes for
byte arrays, which does not exist in JavaScript (commonly used to implement clients of a
Solidity contract). Client developers need to encode byte arrays using hexadecimal string
representations starting with “0x”, otherwise they cannot be interpreted by the contract.

Other Related Work. Smart contract languages. Harz and Knottenbelt [53] survey smart
contract languages, Hu et al. [56] survey smart contract tools and systems, Wöhrer and
Zdun [84] give an overview of design patterns in smart contracts. Brünjes and Gabbay [28]
distinguish between imperative and functional smart contract programming. Imperative
contracts are based on the account model; the most prominent language is Solidity [4].
Functional ones [29, 77, 76] are based on EUTxO (Extended Unspent Transaction Output)
model [50]. State channels [30, 62, 43, 42] optimistically optimize contracts for the functional
model. Prisma does not yet support compilation to state channels but we plan to treat them
as another kind of tier.

Smart contracts as state machines. Scilla [78] is an automata-based compiler for contracts.
FSolidM [60] enables creating contracts via a graphical interface. VeriSolid [61] generates
contracts from graphical models enriched with predicates based on computational tree logic.
EFSM tools [82] generate contracts from state machines and linear temporal logic. Prisma
avoids a separate speciﬁcation but infers transactions and their order from the control ﬂow
of a multitier dApp.

Analysis tools. Durieux et al. [41] and Ferreira et al. [46] empirically validate languages
and tools and relate design patterns to security vulnerabilities, extending the survey by
Di Angelo and Salzer [20]. Our work is complementary, targeting the correctness of the
distributed program ﬂow. For vulnerabilities not related to program ﬂow (e.g., front-running,
or bad randomness), developers (using Solidity/JavaScript or Prisma) can use the surveyed
analysis tools.

Multitier languages. Multitier programming was pioneered by Hop [79, 80]. Modeling a
persistent session in client–server applications with continuations was mentioned by Quein-
nec [71] and elaborated in Links [37, 49]. Eliom [72] supports bidirectional client–server
communication for web applications. ScalaLoci [83] generalizes the multitier model to generic
distributed architectures. Our work specializes it to the dApp domain and its speciﬁc prop-
erties. Giallorenzo et al. [52] establish interesting connections between multitier (subjective)
and choreographic (objective) languages – two variants of the global model. Prisma adopts
the subjective view, which naturally ﬁts the dApp domain, where a dominant role (contract)
controls the execution and diverts control to other parties (clients) to collect their input.

Eﬀectful programs and meta-programming. MNF and CSP are widely discussed as
intermediate compiler forms [22, 48, 57, 59, 36]. F# computation expressions [68] support
control-ﬂow operators in monadic expressions. OCaml supports a monadic and applicative
let [11]: more ﬂexible than do-notation but still restricted to MNF. Idris’ !-notation [5]
inspired the GHC proposal for monadic inline binding [10]. Scala supports eﬀectful programs
through coroutines [8], async/await [73], monadic inline binding [26], Dsl.scala [86] and

8 Recall that in dApps checking cross-tier type-safety is not a security feature but a design-time safety

feature (due to the open-world assumption of the execution model of public ledgers).

24

REFERENCES

a (deprecated) compiler plugin for CPS translation [7]. The dotty-cps-async macro [81]
supports async/await and similar eﬀects for the Dotty compiler.

7

Conclusion

We proposed Prisma, the ﬁrst global language for dApps that features direct style communi-
cation. Compared to the state of the art, Prisma (a) enables the implementation of contract
and client logic within the same development unit, rendering intricacies of the heterogeneous
technology stack obsolete and avoiding boilerplate code, (b) provides support for explicitly
encoding the intended program ﬂow and (c) reduces the risk of human failures by enforcing
the intended program ﬂow and forcing developers to specify access control.

Unlike previous work that targeted challenges in the development of dApps with advanced
typing disciplines e.g., session types, our model does not exhibit visible side eﬀects and gets
away with a standard System-F-style type system. We describe the design and the main
features of Prisma informally, deﬁne its formal semantics, formalize the compilation process
and prove it correct. We demonstrate Prisma’s applicability via case studies and performance
benchmarks.

We plan to generate state channels – to optimistically cost-optimize dApps – similar to
how we generate state machines from high-level logic. Further, we believe that our technique
for deriving the communication protocol from direct-style control ﬂow generalizes beyond
the domain of smart contracts and we will explore its further applicability.

References

1 Ethereum yellow paper. https://ethereum.github.io/yellowpaper/paper.pdf.
2 Haskell 2010: Language Report. Expressions. Do Expressions. https://www.haskell.
org/onlinereport/haskell2010/haskellch3.html#x8-470003.14. Accessed 14-11-
2020.

3 Headlong (github repository). https://github.com/esaulpaugh/headlong.
4 Solidity documentation. https://docs.soliditylang.org/en/v0.8.1/.
5 The Idris Tutorial. Interfaces. Monads and do-notation. !-notation. http://docs.
idris-lang.org/en/latest/tutorial/interfaces.html#notation. Accessed 14-
11-2020.

6 Web3j: Web3 java ethereum Ðapp api (github repository). https://github.com/

web3j/web3j.

7 scala-continuations. the scala delimited continuations plugin and library. https://

github.com/scala/scala-continuations, 2013.

8 Coroutines is a library-level extension for the scala programming language that introduces

ﬁrst-class coroutines. https://github.com/storm-enroute/coroutines, 2015.

9 Analysis of the dao exploit.

https://hackingdistributed.com/2016/06/18/

analysis-of-the-dao-exploit/, 2016. Accessed 14-11-2020.

10 Discussion

on GHC Pre-Proposal.
ghc-proposals/pull/64, 2017. Accessed 14-11-2020.

https://github.com/ghc-proposals/

11 Ocaml: Add "monadic" let operators. https://github.com/ocaml/ocaml/pull/1947,

2018.

12 Perun network. https://perun.network, 2020.
13 Solidity documentation - common patterns. https://docs.soliditylang.org/en/v0.

7.4/common-patterns.html, 2020. Accessed 14-11-2020.

REFERENCES

25

14 Statechannels. https://statechannels.org/, 2020.
15 Google cloud bigquery: Contract deployment per month.

https://console.
cloud.google.com/bigquery, 2021. Query: SELECT EXTRACT(MONTH FROM
c.block_timestamp) AS m, EXTRACT(YEAR FROM c.block_timestamp) AS y,
COUNT(c.address) FROM ‘bigquery-public-data.ethereum_blockchain.live_contracts‘
AS c GROUP BY m, y ORDER BY y, m; Accessed 07-07-2021.

16 Google

cloud bigquery:

https://console.cloud.google.
com/bigquery,
(SELECT DISTINCT
c.bytecode,(LENGTH(c.bytecode)-2)/2 as s FROM ‘[...]live_contracts‘ AS c) SELECT
PERCENTILE_CONT(d.s, [0, 0.25, 0.5, 0.75, 1]) OVER () AS M FROM d LIMIT 1;
Accessed 14-11-2021.

Contract
Query:

WITH d

2021.

size.

as

17 Uniswap info. https://v2.info.uniswap.org/home, 2021. Accessed 07-07-2021.
18 Gul Agha. Actors: A Model of Concurrent Computation in Distributed Systems. MIT

Press, Cambridge, MA, USA, 1986.

19 Marcin Andrychowicz, Stefan Dziembowski, Daniel Malinowski, and Lukasz Mazurek.
Secure multiparty computations on bitcoin. In 2014 IEEE Symposium on Security and
Privacy, SP 2014, Berkeley, CA, USA, May 18-21, 2014, pages 443–458. IEEE Computer
Society, 2014. doi:10.1109/SP.2014.35.

20 Monika Di Angelo and Gernot Salzer. A survey of tools for analyzing ethereum smart
contracts. In IEEE International Conference on Decentralized Applications and Infras-
tructures, DAPPCON 2019, Newark, CA, USA, April 4-9, 2019, pages 69–78. IEEE,
2019. doi:10.1109/DAPPCON.2019.00018.

21 Monika Di Angelo and Gernot Salzer. Wallet contracts on ethereum. CoRR,
abs/2001.06909, 2020. URL: https://arxiv.org/abs/2001.06909, arXiv:2001.
06909.

22 Andrew W. Appel. Compiling with Continuations. Cambridge University Press, 1992.
23 Massimo Bartoletti and Livio Pompianu. An empirical analysis of smart contracts:
platforms, applications, and design patterns. In International conference on ﬁnancial
cryptography and data security, pages 494–509. Springer, 2017.

24 Gavin M. Bierman, Claudio V. Russo, Geoﬀrey Mainland, Erik Meijer, and Mads
Torgersen. Pause ’n’ play: Formalizing asynchronous c#.
In James Noble, editor,
ECOOP 2012 - Object-Oriented Programming - 26th European Conference, Beijing,
China, June 11-16, 2012. Proceedings, volume 7313 of Lecture Notes in Computer Science,
pages 233–257. Springer, 2012. doi:10.1007/978-3-642-31057-7\_12.

25 Sam Blackshear, Evan Cheng, D. Dill, Victor Gao, B. Maurer, T. Nowacki, Alistair Pott,
S. Qadeer, Dario Russi, Stephane Sezer, Tim Zakian, and Run tian Zhou. Move: A
language with programmable resources. 2019.

26 Flavio W. Brasil and Sameer Brenn. Monadless - syntactic sugar for monad composition

in scala. https://github.com/monadless/monadless.

27 Lorenz Breidenbach, Phil Daian, Ari Juels, and Emin Gün Sirer.

An in-
hackingdistributed.com/2017/07/22/

depth look at the parity multisig bug.
deep-dive-parity-bug/, 2016. Accessed 14-11-2020.

28 Lars Brünjes and Murdoch James Gabbay. Utxo- vs account-based smart contract
blockchain programming paradigms. In Tiziana Margaria and Bernhard Steﬀen, editors,
Leveraging Applications of Formal Methods, Veriﬁcation and Validation: Applications -
9th International Symposium on Leveraging Applications of Formal Methods, ISoLA 2020,
Rhodes, Greece, October 20-30, 2020, Proceedings, Part III, volume 12478 of Lecture Notes

26

REFERENCES

in Computer Science, pages 73–88. Springer, 2020. doi:10.1007/978-3-030-61467-6\
_6.

29 Manuel Chakravarty, Roman Kireev, Kenneth MacKenzie, Vanessa McHale, Jann Müller,
Alexander Nemish, Chad Nester, Michael Peyton Jones, Simon Thompson, Rebecca
Valentine, and Philip Wadler. Functional blockchain contracts. 2019. URL: https:
//iohk.io/en/research/library/papers/functional-blockchain-contracts/.
30 Manuel M. T. Chakravarty, Sandro Coretti, Matthias Fitzi, Peter Gazi, Philipp Kant,
Aggelos Kiayias, and Alexander Russell. Hydra: Fast isomorphic state channels. IACR
Cryptol. ePrint Arch., 2020:299, 2020. URL: https://eprint.iacr.org/2020/299.
31 Kwanghoon Choi and Byeong-Mo Chang. A theory of RPC calculi for client–server model.
Journal of Functional Programming, 29, 2019. doi:10.1017/S0956796819000029.
32 Kwanghoon Choi and Byeong-Mo Chang. A theory of RPC calculi for client-server model.

J. Funct. Program., 29:e5, 2019. doi:10.1017/S0956796819000029.

33 Michael J. Coblenz. Obsidian: a safer blockchain programming language. In Sebastián
Uchitel, Alessandro Orso, and Martin P. Robillard, editors, Proceedings of the 39th
International Conference on Software Engineering, ICSE 2017, Buenos Aires, Argentina,
May 20-28, 2017 - Companion Volume, pages 97–99. IEEE Computer Society, 2017.
doi:10.1109/ICSE-C.2017.150.

34 Michael J. Coblenz, Gauri Kambhatla, Paulette Koronkevich, Jenna L. Wise, Celeste
Barnaby, Jonathan Aldrich, Joshua Sunshine, and Brad A. Myers. User-centered program-
ming language design in the obsidian smart contract language. CoRR, abs/1912.04719,
2019. URL: http://arxiv.org/abs/1912.04719, arXiv:1912.04719.

35 Michael J. Coblenz, Reed Oei, Tyler Etzel, Paulette Koronkevich, Miles Baker, Yannick
Bloem, Brad A. Myers, Joshua Sunshine, and Jonathan Aldrich. Obsidian: Typestate
and assets for safer blockchain programming. CoRR, abs/1909.03523, 2019. URL:
http://arxiv.org/abs/1909.03523, arXiv:1909.03523.

36 Youyou Cong, Leo Osvald, Grégory M. Essertel, and Tiark Rompf. Compiling with
continuations, or without? whatever. Proc. ACM Program. Lang., 3(ICFP):79:1–79:28,
2019. doi:10.1145/3341643.

37 Ezra Cooper, Sam Lindley, Philip Wadler, and Jeremy Yallop. Links: Web programming
without tiers. In Proceedings of the 5th International Conference on Formal Methods for
Components and Objects, FMCO’06, pages 266–296, Berlin, Heidelberg, 2007. Springer-
Verlag. URL: http://dl.acm.org/citation.cfm?id=1777707.1777724.

38 Dapp.com.

2020 q2 dapp market report.

https://www.dapp.com/article/

q2-2020-dapp-market-report, 2020.

39 Ankush Das, S. Balzer, J. Hoﬀmann, and F. Pfenning. Resource-aware session types for

digital contracts. ArXiv, abs/1902.06056, 2019.

40 Ankush Das, Jan Hoﬀmann, and Frank Pfenning. Nomos: A protocol-enforcing, asset-

tracking, and gas-aware language for smart contracts. 2021.

41 Thomas Durieux, João F. Ferreira, Rui Abreu, and Pedro Cruz. Empirical review of
automated analysis tools on 47, 587 ethereum smart contracts. In Gregg Rothermel
and Doo-Hwan Bae, editors, ICSE ’20: 42nd International Conference on Software
Engineering, Seoul, South Korea, 27 June - 19 July, 2020, pages 530–541. ACM, 2020.
doi:10.1145/3377811.3380364.

42 Stefan Dziembowski, Lisa Eckey, Sebastian Faust, Julia Hesse, and Kristina Hostáková.
Multi-party virtual state channels. In Yuval Ishai and Vincent Rijmen, editors, Advances
in Cryptology - EUROCRYPT 2019 - 38th Annual International Conference on the
Theory and Applications of Cryptographic Techniques, Darmstadt, Germany, May 19-23,

REFERENCES

27

2019, Proceedings, Part I, volume 11476 of Lecture Notes in Computer Science, pages
625–656. Springer, 2019. doi:10.1007/978-3-030-17653-2\_21.

43 Stefan Dziembowski, Sebastian Faust, and Kristina Hostáková. General state channel
networks. In David Lie, Mohammad Mannan, Michael Backes, and XiaoFeng Wang,
editors, Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communi-
cations Security, CCS 2018, Toronto, ON, Canada, October 15-19, 2018, pages 949–966.
ACM, 2018. doi:10.1145/3243734.3243856.

44 Jonathan Edwards. Coherent reaction. In Shail Arora and Gary T. Leavens, editors,
Companion to the 24th Annual ACM SIGPLAN Conference on Object-Oriented Pro-
gramming, Systems, Languages, and Applications, OOPSLA 2009, October 25-29, 2009,
Orlando, Florida, USA, pages 925–932. ACM, 2009. doi:10.1145/1639950.1640058.
45 Matthias Felleisen and Robert Hieb. The revised report on the syntactic theories
of sequential control and state. Theor. Comput. Sci., 103(2):235–271, 1992. doi:
10.1016/0304-3975(92)90014-7.

46 João F. Ferreira, Pedro Cruz, Thomas Durieux, and Rui Abreu. Smartbugs: A framework
to analyze solidity smart contracts. CoRR, abs/2007.04771, 2020. URL: https://arxiv.
org/abs/2007.04771, arXiv:2007.04771.

47 Klint Finley. A $50 million hack just showed that the dao was all too human. Wired, 6

2016.

48 Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen. The essence
of compiling with continuations.
In Robert Cartwright, editor, Proceedings of the
ACM SIGPLAN’93 Conference on Programming Language Design and Implementation
(PLDI), Albuquerque, New Mexico, USA, June 23-25, 1993, pages 237–247. ACM, 1993.
doi:10.1145/155090.155113.

49 Simon Fowler, Sam Lindley, J. Garrett Morris, and Sára Decova. Exceptional asynchronous
session types: Session types without tiers. Proceedings of the ACM on Programming
Languages, 3(POPL):28:1–28:29, January 2019. doi:10.1145/3290341.

50 Murdoch James Gabbay. What is an eutxo blockchain? CoRR, abs/2007.12404, 2020.

URL: https://arxiv.org/abs/2007.12404, arXiv:2007.12404.

51 Saverio Giallorenzo, Fabrizio Montesi, and Marco Peressotti. Choreographies as objects,

2020. arXiv:2005.09520.

52 Saverio Giallorenzo, Fabrizio Montesi, Marco Peressotti, David Richter, Guido Salvaneschi,
and Pascal Weisenburger. Multiparty languages: The choreographic and multitier cases
(pearl).
In Anders Møller and Manu Sridharan, editors, 35th European Conference
on Object-Oriented Programming, ECOOP 2021, July 11-17, 2021, Aarhus, Denmark
(Virtual Conference), volume 194 of LIPIcs, pages 22:1–22:27. Schloss Dagstuhl - Leibniz-
Zentrum für Informatik, 2021. doi:10.4230/LIPIcs.ECOOP.2021.22.

53 Dominik Harz and William J. Knottenbelt. Towards safer smart contracts: A survey
of languages and veriﬁcation methods. CoRR, abs/1809.09805, 2018. URL: http:
//arxiv.org/abs/1809.09805, arXiv:1809.09805.

54 C. A. R. Hoare. Communicating sequential processes. Commun. ACM, 21(8):666–677,

August 1978. doi:10.1145/359576.359585.

55 Kohei Honda, Aybek Mukhamedov, Gary Brown, Tzu-Chun Chen, and Nobuko Yoshida.
Scribbling interactions with a formal foundation.
In Raja Natarajan and Adeg-
boyega K. Ojo, editors, Distributed Computing and Internet Technology - 7th Inter-
national Conference, ICDCIT 2011, Bhubaneshwar, India, February 9-12, 2011. Proceed-
ings, volume 6536 of Lecture Notes in Computer Science, pages 55–75. Springer, 2011.
doi:10.1007/978-3-642-19056-8\_4.

28

REFERENCES

56 Bin Hu, Zongyang Zhang, Jianwei Liu, Yizhong Liu, Jiayuan Yin, Rongxing Lu, and
Xiaodong Lin. A comprehensive survey on smart contract construction and execution:
Paradigms, tools and systems. CoRR, abs/2008.13413, 2020. URL: https://arxiv.
org/abs/2008.13413, arXiv:2008.13413.

57 Andrew Kennedy. Compiling with continuations, continued. In Ralf Hinze and Norman
Ramsey, editors, Proceedings of the 12th ACM SIGPLAN International Conference on
Functional Programming, ICFP 2007, Freiburg, Germany, October 1-3, 2007, pages
177–190. ACM, 2007. doi:10.1145/1291151.1291179.

58 Loi Luu, Duc-Hiep Chu, Hrishi Olickel, Prateek Saxena, and Aquinas Hobor. Making
In Proceedings of the 2016 ACM SIGSAC Conference on
smart contracts smarter.
Computer and Communications Security, CCS ’16, page 254–269, New York, NY, USA,
2016. Association for Computing Machinery. doi:10.1145/2976749.2978309.

59 Luke Maurer, Paul Downen, Zena M. Ariola, and Simon L. Peyton Jones. Compiling
without continuations. In Albert Cohen and Martin T. Vechev, editors, Proceedings of the
38th ACM SIGPLAN Conference on Programming Language Design and Implementation,
PLDI 2017, Barcelona, Spain, June 18-23, 2017, pages 482–494. ACM, 2017. doi:
10.1145/3062341.3062380.

60 Anastasia Mavridou and Aron Laszka. Designing secure ethereum smart contracts: A
ﬁnite state machine based approach. In Sarah Meiklejohn and Kazue Sako, editors,
Financial Cryptography and Data Security - 22nd International Conference, FC 2018,
Nieuwpoort, Curaçao, February 26 - March 2, 2018, Revised Selected Papers, volume
10957 of Lecture Notes in Computer Science, pages 523–540. Springer, 2018. doi:
10.1007/978-3-662-58387-6\_28.

61 Anastasia Mavridou, Aron Laszka, Emmanouela Stachtiari, and Abhishek Dubey.
Verisolid: Correct-by-design smart contracts for ethereum. In Ian Goldberg and Tyler
Moore, editors, Financial Cryptography and Data Security - 23rd International Confer-
ence, FC 2019, Frigate Bay, St. Kitts and Nevis, February 18-22, 2019, Revised Selected
Papers, volume 11598 of Lecture Notes in Computer Science, pages 446–465. Springer,
2019. doi:10.1007/978-3-030-32101-7\_27.

62 Andrew Miller, Iddo Bentov, Surya Bakshi, Ranjit Kumaresan, and Patrick McCorry.
Sprites and state channels: Payment networks that go faster than lightning. In Ian
Goldberg and Tyler Moore, editors, Financial Cryptography and Data Security - 23rd
International Conference, FC 2019, Frigate Bay, St. Kitts and Nevis, February 18-22,
2019, Revised Selected Papers, volume 11598 of Lecture Notes in Computer Science, pages
508–526. Springer, 2019. doi:10.1007/978-3-030-32101-7\_30.

63 Mix. These are the top 10 programming languages in blockchain. https://thenextweb.
com/hardfork/2019/05/24/javascript-programming-java-cryptocurrency/,
2019. Accessed 14-11-2020.

64 Fabrizio Montesi, Claudio Guidi, and Gianluigi Zavattaro. Service-oriented programming
with jolie. In Athman Bouguettaya, Quan Z. Sheng, and Florian Daniel, editors, Web Ser-
vices Foundations, pages 81–107. Springer, 2014. doi:10.1007/978-1-4614-7518-7\
_4.

65 Ivica Nikolić, Aashish Kolluri, Ilya Sergey, Prateek Saxena, and Aquinas Hobor. Finding
the greedy, prodigal, and suicidal contracts at scale. In Proceedings of the 34th Annual
Computer Security Applications Conference, ACSAC ’18, page 653–663, New York, NY,
USA, 2018. Association for Computing Machinery. doi:10.1145/3274694.3274743.

66 Reed Oei, Michael J. Coblenz, and Jonathan Aldrich. Psamathe: A DSL with ﬂows for

REFERENCES

29

safe blockchain assets. CoRR, abs/2010.04800, 2020. URL: https://arxiv.org/abs/
2010.04800, arXiv:2010.04800.

67 Gustavo A Oliva, Ahmed E Hassan, and Zhen Ming Jack Jiang. An exploratory study of
smart contracts in the ethereum blockchain platform. Empirical Software Engineering,
pages 1–41, 2020.

68 Tomas Petricek and Don Syme. The f# computation expression zoo. In PADL, volume

8324 of Lecture Notes in Computer Science, pages 33–48. Springer, 2014.

69 Sergey Petrov. Another parity wallet hack explained, 2017. URL: https://medium.

com/@Pr0Ger/another-parity-wallet-hack-explained-847ca46a2e1c.

70 Andrew M. Pitts. Operational semantics and program equivalence. In Gilles Barthe,
Peter Dybjer, Luís Pinto, and João Saraiva, editors, Applied Semantics, International
Summer School, APPSEM 2000, Caminha, Portugal, September 9-15, 2000, Advanced
Lectures, volume 2395 of Lecture Notes in Computer Science, pages 378–412. Springer,
2000. doi:10.1007/3-540-45699-6\_8.

71 Christian Queinnec. The inﬂuence of browsers on evaluators or, continuations to program
web servers. In Martin Odersky and Philip Wadler, editors, Proceedings of the Fifth
ACM SIGPLAN International Conference on Functional Programming (ICFP ’00),
Montreal, Canada, September 18-21, 2000, pages 23–33. ACM, 2000. doi:10.1145/
351240.351243.

72 Gabriel Radanne, Jérôme Vouillon, and Vincent Balat. Eliom: A core ML language for
tierless web programming. In Atsushi Igarashi, editor, Proceedings of the 14th Asian
Symposium on Programming Languages and Systems, APLAS ’16, pages 377–397, Berlin,
Heidelberg, November 2016. Springer-Verlag. doi:10.1007/978-3-319-47958-3_20.

73 Scala. Scala async rfc. http://docs.scala-lang.org/sips/pending/async.html.
74 Franklin Schrans, Susan Eisenbach, and Sophia Drossopoulou. Writing safe smart
contracts in ﬂint. In Stefan Marr and Jennifer B. Sartor, editors, Conference Companion of
the 2nd International Conference on Art, Science, and Engineering of Programming, Nice,
France, April 09-12, 2018, pages 218–219. ACM, 2018. doi:10.1145/3191697.3213790.
75 Franklin Schrans, Daniel Hails, Alexander Harkness, Sophia Drossopoulou, and Susan
Eisenbach. Flint for safer smart contracts. CoRR, abs/1904.06534, 2019. URL: http:
//arxiv.org/abs/1904.06534, arXiv:1904.06534.

and

analysing

Marlowe:
2020.

76 Pablo Lamela Seijas, Alexander Nemish, David Smith, and Simon THomp-
on
implementing
URL: https://iohk.io/en/research/library/papers/

son.
blockchain.
marloweimplementing-and-analysing-financial-contracts-on-blockchain/.
77 Pablo Lamela Seijas and Simon J. Thompson. Marlowe: Financial contracts on blockchain.
In Tiziana Margaria and Bernhard Steﬀen, editors, Leveraging Applications of Formal
Methods, Veriﬁcation and Validation. Industrial Practice - 8th International Symposium,
ISoLA 2018, Limassol, Cyprus, November 5-9, 2018, Proceedings, Part IV, volume
11247 of Lecture Notes in Computer Science, pages 356–375. Springer, 2018. doi:
10.1007/978-3-030-03427-6\_27.

contracts

ﬁnancial

78 Ilya Sergey, Vaivaswatha Nagaraj, Jacob Johannsen, Amrit Kumar, Anton Trunov,
and Ken Chan Guan Hao. Safer smart contract programming with scilla. PACMPL,
3(OOPSLA):185:1–185:30, 2019. doi:10.1145/3360611.

79 Manuel Serrano, Erick Gallesio, and Florian Loitsch. Hop, a language for programming
the web 2.0. In Companion to the 21th ACM SIGPLAN Conference on Object-Oriented
Programming, Systems, Languages, and Applications, OOPSLA Companion ’06, New
York, NY, USA, 2006. ACM.

30

REFERENCES

80 Manuel Serrano and Vincent Prunet. A glimpse of Hopjs. In Proceedings of the 21st
ACM SIGPLAN International Conference on Functional Programming, ICFP ’16, pages
180–192, New York, NY, USA, 2016. ACM. doi:10.1145/2951913.2951916.

81 Ruslan Shevchenko. dotty-cps-async - experimental cps transformer for dotty. https:

//github.com/rssh/dotty-cps-async.

82 Dmitrii Suvorov and Vladimir Ulyantsev. Smart contract design meets state machine
synthesis: Case studies. CoRR, abs/1906.02906, 2019. URL: http://arxiv.org/abs/
1906.02906, arXiv:1906.02906.

83 Pascal Weisenburger, Mirko Köhler, and Guido Salvaneschi. Distributed system de-
velopment with ScalaLoci. Proceedings of the ACM on Programming Languages,
2(OOPSLA):129:1–129:30, October 2018. doi:10.1145/3276499.

84 Maximilian Wöhrer and Uwe Zdun. From domain-speciﬁc language to code: Smart
contracts and the application of design patterns. IEEE Softw., 37(4):37–42, 2020. doi:
10.1109/MS.2020.2993470.

85 Gavin Wood. Ethereum: A secure decentralised generalised transaction ledger. https:
//ethereum.github.io/yellowpaper/paper.pdf, 2014. Ethereum Yellow Paper: A
Formal Speciﬁcation of Ethereum, a Programmable Blockchain. BERLIN VERSION
0e0eba8 – 2021-11-02. Accessed 14-11-2020.

86 Bo Yang. Dsl.scala - a framework to create embedded domain-speciﬁc languages in scala.

https://github.com/ThoughtWorksInc/Dsl.scala.

A

Case studies

This section describes the implemented case studies in detail. Bartoletti and Pompianu [23]
identify ﬁve classes of smart contract applications: Financial, Notary, Game, Wallet, and
Library. Our case studies include at least one application per category (Table 21).
In
addition, we consider scalability solutions.

Financial. These apps include digital tokens, crowdfunding, escrowing, advertisement,
insurances and sometimes Ponzi schemes. A study investigating all blocks mined until
September 15th, 2018 [67], found that 72.9 % of the high-activity contracts are token
contracts compliant to ERC-20 or ERC-721, which have an accumulated market capitalization
of US $ 12.7 billion. We have implemented a fungible Prisma token of the ERC-20 standard.
Further, we implemented crowdfunding and escrowing case studies. These case studies
demonstrate how to send and receive coins with Prisma, which is the basic functionality of
ﬁnancial applications. Other ﬁnancial use cases can be implemented in Prisma with similar
techniques.

Notary. These contracts use the blockchain to store data immutably and persistently,
e.g., to certify their ownership. We implemented a general-purpose notary contract enabling
users to store arbitrary data, e.g., document hashes or images, together with a submission
timestamp and the data owner. This case study demonstrates that Notaries are expressible
with Prisma.

Games. We implemented TicTacToe (Section 2), Rock-Paper-Scissors, Hangman and
Chinese Checkers. Hangman evolves through multiple phases and hence beneﬁts from the
explicit control ﬂow deﬁnition in Prisma more than the other game case studies. The game
Chinese Checkers is more complex than the others, in regard to the number of parties, the
game logic and the number of rounds, and hence, represents larger applications. Rock-
Paper-Scissors illustrates how randomness for dApps is securely generated. Every Ethereum
transaction, including the executions of contracts, is deterministic – all participants can

REFERENCES

31

validate the generation of new blocks. Hence, secure randomness is negotiated among parties:
in this case, by making use of timed commitments [19], i.e., all parties commit to a random
seed share and open it after all commitments have been posted. The contract uses the sum
of all seed shares as randomness. If one party aborts prior to opening its commitment, it
is penalized. In Rock-Paper-Scissors both parties commit to their choice – their random
share – and open it afterwards. Other games of chance, e.g., gambling contracts, use the
same technique.

Wallet. A wallet contract manages digital assets, i.e., cryptocurrencies and tokens, and
oﬀers additional features such as shared ownership or daily transaction limits. At August 30,
2019, 3.9 M of 17.9 M (21 %) deployed smart contracts have been diﬀerent types of wallet
contracts [21]. Multi-signature wallets are a special type of wallet that provides a transaction
voting mechanism by only executing transactions, which are signed by a ﬁxed fraction of the
set of owners. Wallets transfer money and call other contracts in their users stead depending
on run-time input, demonstrating calls among contracts in Prisma. Further, a multi-signature
wallet uses built-in features of the Ethereum VM for signature validation, i.e., data encoding,
hash calculation, and signature veriﬁcation, showing that these features are supported in
Prisma.

Libraries. As the cost of deploying a contract increases with the amount of code in
Ethereum, developers try to avoid code repetitions. Contract inheritance does not help: child
contracts simply copy the attributes and functions from the parent. Yet, one can outsource
commonly used logic to library contracts that are deployed once and called by other contracts.
For example, the TicTacToe dApp and the TicTacToe channel in our case studies share
some logic, e.g., to check the win condition. To demonstrate libraries in Prisma, we include a
TicTacToe library to our case studies and another on-chain executed TicTacToe dApp which
uses such library instead of deploying the logic itself. Libraries use a call instruction similar
to wallets, although the call target is typically known at deployment and can be hard-coded.
Scalability solutions. State channels [62, 43, 42] are scalability solutions, which enable a
ﬁxed group of parties to move their dApp to a non-blockchain consensus protocol: the execu-
tion falls-back to the blockchain in case of disputes. Similar to multi-signature wallets, state
channels use built-in signature validation. We implemented a state channel for TicTacToe9
to demonstrate that Prisma supports state channels.

B

Empirical Evaluation of Design Quality

In Section 6, we argued that with Prisma, (a) we provide communication safety with a
standard system-F-like type-system, (b) the program ﬂow can be deﬁned explicitly and is
enforced automatically, (c) dApp developers need to master a single technology that covers
both tiers, (d) cross-tier type-safety can be checked at compile-time, and (e) the code is
simpler and less verbose due to reduced boilerplate code for communication and less control
ﬂow jumps. The claims (a), (c), and (d) are a direct consequence of Prisma’s design and do
not require further evidence. Claim (c) has been formally proven in Section 3. It remains to
investigate claim (e), i.e., in which extent Prisma reduces the amount of code and error-prone
control-ﬂow jumps.

To this end, we implemented all case studies with equivalent functionality in Prisma and
in Solidity/JavaScript. The JavaScript client logic is in direct style using async/await – the
Solidity contract needs to be implemented as a ﬁnite-state-machine. We keep the client logic

9 A general solution is a much larger engineering eﬀort and subject of industrial projects [12, 14]

32

REFERENCES

Figure 21 Categories and Cross-tier calls.

Category

Case study

Cross-tier calls

Prisma LoC Solidity LoC JavaScript LoC

48

27

33

41

16

41

31

86

141

141

29

56

50

63

56

52

36

77

52

83

47

–

52

177

Solidity
JavaScript
Prisma

Financial

Token

Crowdfunding

Escrow

Wallet

Multi-signature wallet

Notary

General-purpose notary

Game

Rock Paper Scissors

TicTacToe

Hangman

Chinese Checkers

Library

TicTacToe library

TicTacToe using library

Scalability TicTacToe channel

4

11

9

3

3

12

5

15

4

–

5

9

79

59

63

76

32

79

61

119

167

167

53

177

Token
Crowdfunding

Escrow

Wallet
Notary

TicTacToe
Rock-Paper-Scissors

Hangman

Chinese Checkers
TTT Library

TTT via Library

TTT Channel

0

20

40

60

80

100

120

140

160

180

200

220

240

Figure 22 LOC in Solidity/JavaScript and Prisma.

of our case studies (in both, the Prisma and the Solidity implementation) as basic as possible,
not to compare the client logic in Scala and in JavaScript but rather focus on the dApp
semantics. A complex client logic would shadow the interaction with the contract logic –
limited in size due to the gas semantics.

We start with comparing LOCs in the case studies (Figure 22). The results in Figure 22
show that case studies written in Prisma require only 55 – 89 % LOC compared to those
implemented in Solidity/JavaScript. One exception is the standalone library, which has no
client code and hence does not directly proﬁt from the tierless design.

Second, we consider occurrences of explicit cross-tier control-ﬂow calls in the Solidity/-
JavaScript dApps (cf. Table 21), which complicate control ﬂow, compared to Prisma, where
cross-tier access is seamless. In the client implementations, 6 – 18 % of all lines trigger a
contract interaction passing the control ﬂow to the contract and waiting for the control ﬂow

REFERENCES

33

to return. From the contract code in ﬁnite-state-machine style, it is not directly apparent at
which position the program ﬂow continues, once passed back from clients to contract, i.e.,
which function is called by the clients next. Direct-style code, on the other hand, ensures
that the control ﬂow of the contract always continues in the line that passed the control ﬂow
to the client by invoking an awaitCl expression.

34

REFERENCES

comp0(d; b; trmp(m))

= d; coclfn(b, id, assert(false), assert(false)); trmp(comp(m))

where

id fresh







comp

d; coclfn(b, id,

e1,alt,
e2,alt);







tmp ←s (() → e1); e2

comp

comp

(cid:18) d; coclfn(b, id, e1,alt, e2,alt);

(cid:19)

x = e0; e1

(cid:18) d; coclfn(b, id, e1,alt, e2,alt);

(cid:19)

e

=

=

=


















d; coclfn(b, id,

if let (c :: fv(() → e1)) = id then e1 else e0
if let (c :: x :: fv(x → e0

2)) = id then
assert(this. state == c && this. who(this. sender));
this. state := 0; e0
2

1,alt,

else
e0
2,alt);

this. who := e0; this. state := c;
(More, c :: fv(() → e1), c :: fv(x → e0

2))


















where
and

c fresh
d; coclfn(b, id, e0

1,alt, e0
defun(d; coclfn(b, id, e1,alt, e2,alt); e2)

2,alt); e0

2 =

(cid:18) d; coclfn(b, id, e1,alt, e2,alt);

(cid:19)

x = e0; defun(e1)

(cid:18) d; coclfn(b, id, e1,alt, e2,alt);

(cid:19)

e

coclfn(b, id, e1,alt, e2,alt)

= (@cl this. clfn = id → e1,alt); (@co this. cofn = id → e2,alt); b

Figure 23 comp0 and comp.

= fv(m0) ∪ fv(m1)
fv(m0 :: m1)
= fv(m) \ fv(x)
fv(x → m)
= {id}
fv(id)
fv(m0 m1)
= fv(m0) ∪ fv(m1)
fv(awaitCl∗((m0, () → m1) = fv(m0) ∪ fv(m1)
fv(let x = m0; m1)
fv(this.i := m0)
fv(this.j := m0)
fv(this.i)
fv(this.j)
fv(c)

= fv(m0) ∪ fv(m1) \ fv(x)
= fv(m0)
= fv(m0)
= {}
= {}
= {}

Figure 24 Free variables.

C

Proofs

We provide the deﬁnition of comp0 and comp in Figure 23, the deﬁnition for the free variables
for a given term fv in Figure 24 and the detailed proofs for the theorem and the lemmas on
the following pages.

REFERENCES

35

(cid:73) Theorem 1 (Secure Compilation). For all programs P over closed terms, the trace set of
evaluating the program under attack equals the trace set of evaluating the compiled program
under attack, i.e.,

∀P. { initA(comp0(mnf 0((P )))) } ≈ ... ≈ { initA(P ) }

Proof.

Lemma 3
≈
Lemma 5
≈

initA(comp0(mnf 0(P )))
initA(mnf 0(P ))
initA(P )

(cid:74)

Extensions For simplicity, our deﬁnition of initialization uses a ﬁxed set of clients. Yet, the
malicious semantics does not actually depend on the ﬁxed set of clients, but instead models
an attacker that is in control of all clients with the capability of sending messages from any
client, not bound to the ﬁxed set. Hence, it is straightforward to extend the proofs to the
setting of a dynamic set of clients, e.g., clients joining and leaving at run time.

Further, our trace equality relation deﬁnes that all programs in the relation eventually
reduce to values, ﬁltering out programs that loop or get stuck. Below, we outline an approach
to prove trace equality for looping or stuck programs by showing that such programs loop
with the same inﬁnite trace or get stuck at the same trace, respectively. To this end, we
track the number of steps done via a step-indexed trace equality relation:

p; q; e ⇓n = { (p0, v) | (p; q; e) →n (p0; q0; v) }

T ⇓n =

[

p; q; e ⇓n

p;q;e∈T

With this deﬁnition, we can no longer use just equality of traces as the left and right
program may take a diﬀerent number of steps to produce the same events. Instead, we
move from an equality relation to a relation stating non-disagreement, which says that –
independently of how long we run either statement – the traces will never be in disagreement:

(T ≈n S) ⇔ (T ⇓n #set S ⇓n)

where #set is deﬁned on trace sets as

T #setS ⇔ (∀t∈T. ∃s∈S. t #trace s) ∧ (∀s∈S. ∃t∈T. t #trace s)

and #trace on event traces as

(ev,
(ev,
(ev1,
(ev,

())
#trace
tail1) #trace
tail1) #trace
tail1) #trace

(ev,
(ev,
(ev2,
(ev,

tail2) = true
())
= true
tail2) = f alse
tail2) = tail1 #trace tail2

.

36

REFERENCES

(cid:73) Lemma 1 (assoc preserves traces). assoc is deﬁned as a recursive term-to-term transfor-
mation on open terms, whereas traceset equality is deﬁned by reducing terms to values, i.e.,
on closed terms. Since all valid programs are closed terms, we show that assoc preserves the
traceset of an open term e that is closed by substitution [x
For all terms e, traces p, traces q, values v, patterns x,

⇒ v].

{ p; q; [x

⇒v] assoc(e) } ≈ ... ≈ { p; q; [x

⇒v] e }

Proof. By induction over term structure.

Case

e = (let x1 = (let x0 = e0; e1); e2).

We know x0 /∈ fv(e2) since e2 is not in the scope of the x0 binding, and that all identiﬁers

are distinct, which can always be achieved by α-renaming.

x0 /∈ fv(e2)

According to ≈, we only consider terms that reduce to a value. Therefore, let φ be the
⇒v] with trace p evaluates to a value v0 producing

judgement that the term e0 closed by [x
trace p0.

φ ≡

(p; q; [x

⇒v]e0 →∗ p p0; q; v0)

The lemma holds by the following chain of transitive relations. We evaluate the compiled
program from top to bottom ( →∗) and the original program from bottom to top ( ←∗) until
conﬁgurations converge. The induction hypothesis (IH) allows the removal of assoc in redex
position under traceset equality (≈).

def. e
=

def. assoc
=

IH
≈

⇒

def.
=

φ
→∗

Rlet
→

IH
≈

def.

⇒; x0 /∈ fv(e2)

=

Rlet
←

φ
←∗

⇒

def.
=

def. e
=

⇒v] assoc(e)

(cid:8) p; q; [x
(cid:8) p; q; [x
(cid:8) p; q; [x
(cid:8) p; q; [x
(cid:8) p; q; let x0 = [x

⇒v] assoc(let x1 = (let x0 = e0; e1); e2)

⇒v] assoc(let x0 = e0; assoc(let x1 = e1; e2))

⇒v] let x0 = e0; assoc(let x1 = e1; e2)

⇒v] e0; [x

⇒v] assoc(let x1 = e1; e2)

⇒v] assoc(let x1 = e1; e2) | ∀ v0 p0, φ (cid:9)
(cid:9)

⇒v] assoc(let x1 = e1; e2) | ∀ v0 p0, φ

⇒v] let x1 = e1; e2 | ∀ v0 p0, φ

⇒v0, x

(cid:8) p p0; q; let x0 = v0; [x
(cid:8) p p0; q; [x0
(cid:8) p p0; q; [x0
⇒v0, x
(cid:8) p p0; q; let x1 = [x0
(cid:8) p p0; q; let x1 = (let x0 = v0; [x

⇒v0, x

⇒v]e1; [x

⇒v]e2 | ∀ v0 p0, φ

⇒v]e1); [x

⇒v]e2 | ∀ v0 p0, φ (cid:9)

(cid:8) p; q; let x1 = (let x0 = [x
(cid:8) p; q; [x
(cid:8) p; q; [x

⇒v] e

⇒v] let x1 = (let x0 = e0; e1); e2

⇒v]e0; [x

⇒v]e1); [x

⇒v]e2

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
REFERENCES

37

Case

e 6= (let x1 = (let x0 = e0; e1); e2).

If e is not of nested let form, we simply apply the deﬁnition of assoc.

(cid:8) p; q; [x
(cid:8) p; q; [x

⇒v] assoc(e) (cid:9)
(cid:9)

⇒v] e

def. assoc
=

(cid:74)

(cid:90)
(cid:90)
38

REFERENCES

(cid:73) Lemma 2 (mnf preserves traces). mnf is deﬁned as a recursive term-to-term transformation
on open terms, whereas traceset equality is deﬁned by reducing terms to values, i.e., on
closed terms. Since all valid programs are closed terms, we show that mnf preserves the
traceset of an open term e that is closed by substitution [x
For all terms e, traces p, traces q, values v, patterns x,

⇒ v].

{ p; q; [x

⇒v] mnf (e) } ≈ ... ≈ { p; q; [x

⇒v] e }

Proof. By induction over term structure.

Case e = e0 e1.

According to ≈, we only consider terms that reduce to a value. Therefore, let φ0 be the
⇒v] with trace p evaluates to a value v0 producing
⇒v] with trace p p0 evaluates

judgement that the term e0 closed by [x
trace p0. Let φ1 be the judgement that the term e1 closed by [x
to a value v1 producing trace p p0 p1.

φ0 ≡

(p; q; [x

⇒v] e0 →∗ p p0; q; v0)

φ1 ≡

(p p0; q; [x

⇒v] e1 →∗ p p0 p1; q; v1)

Let id0 be the fresh identiﬁer mnf produces.

id0 fresh

The lemma holds by the following chain of transitive relations. We evaluate the compiled
program from top to bottom ( →∗) and the original program from bottom to top ( ←∗) until
conﬁgurations converge. The induction hypothesis (IH) allows the removal of mnf in redex
position under traceset equality (≈).

⇒v] mnf (e)

⇒v] mnf (e0 e1)

(cid:8) p; q; [x
(cid:8) p; q; [x
(cid:8) p; q; [x
(cid:8) p; q; [x
(cid:8) p; q; let id0 = [x
(cid:8) p; q; let id0 = [x

(cid:8) p p0; q; let id0 = v0; [x
(cid:8) p p0; q; [id07→v0, x
(cid:8) p p0; q; [id07→v0, x
(cid:8) p p0; q; let id1 = [id07→v0, x
(cid:8) p p0; q; let id1 = [id07→v0, x
(cid:8) p p0; q; let id1 = [x

def. e
=

def. mnf
=

Lemma 1
≈

⇒

def.
=

IH
≈

φ0
→∗

Rlet
→

Lemma 1
≈

⇒

def.
=

IH
=

id0 fresh
=

φ1
→∗

⇒v] assoc(let id0 = mnf (e0); assoc(let id1 = mnf (e1); id0 id1))

⇒v] let id0 = mnf (e0); assoc(let id1 = mnf (e1); id0 id1)

⇒v] mnf (e0); [x

⇒v] assoc(let id1 = mnf (e1); id0 id1)

⇒v] e0; [x

⇒v] assoc(let id1 = mnf (e1); id0 id1))

⇒v] assoc(let id1 = mnf (e1); id0 id1) | ∀ v0 p0, if φ0

⇒v] assoc(let id1 = mnf (e1); id0 id1) | ∀ v0 p0, if φ0

⇒v] let id1 = mnf (e1); id0 id1 | ∀ v0 p0, if φ0

⇒v] mnf (e1); v0 id1 | ∀ v0 p0, if φ0

⇒v] e1; v0 id1 | ∀ v0 p0, if φ0

⇒v] e1; v0 id1 | ∀ v0 p0, if φ0

(cid:8) p p0 p1; q; let id1 = v1; v0 id1 | ∀ v0 v1 p0 p1, if φ0, φ1

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
REFERENCES

39

Rlet
→

φ1
←∗

φ0
←∗

⇒

def.
=

def. e
=

(cid:8) p p0 p1; q; v0 v1 | ∀ v0 v1 p0 p1, if φ0, φ1

(cid:8) p p0; q; v0 [x

⇒v] e1 | ∀ v0 p0, if φ0

⇒v] e0) [x

⇒v] e1

(cid:8) p; q; ([x
(cid:8) p; q; [x
(cid:8) p; q; [x

⇒v] e0 e1

⇒v] e

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

Case

e = let id0 = e0; e1.

According to ≈, we only consider terms that reduce to a value. Therefore, let φ be the
⇒v] with trace p evaluates to a value v0 producing

judgement that the term e0 closed by [x
trace p0.

φ0 ≡

(p; q; [x

⇒v] e0 →∗ p p0; q; v0)

The lemma holds by the following chain of transitive relations. We evaluate the compiled
program from top to bottom ( →∗) and the original program from bottom to top ( ←∗) until
conﬁgurations converge. The induction hypothesis (IH) allows the removal of mnf in redex
position under traceset equality (≈).

⇒v] mnf (e)

(cid:8) p; q; [x
(cid:8) p; q; [x
(cid:8) p; q; [x
(cid:8) p; q; [x
(cid:8) p; q; let id0 = [x
(cid:8) p; q; let id0 = [x

⇒v] mnf (let id0 = v0; e1)

⇒v] assoc(let id0 = mnf (e0); mnf (e1))

⇒v] let id0 = mnf (e0); mnf (e1)

⇒v] mnf (e0); [x

⇒v] mnf (e1)

⇒v] e0; [x

⇒v] mnf (e1)

(cid:8) p p0; q; let id0 = v0; [x
(cid:8) p p0; q; [id07→v0, x
(cid:8) p p0; q; [id07→v0, x
(cid:8) p p0; q; [x

⇒v] mnf (e1) | ∀ v0 p0, if φ0

⇒v] mnf (e1) | ∀ v0 p0, if φ0

⇒v] e1 | ∀ v0 p0, if φ0

⇒v] let id0 = v0; e1 | ∀ v0 p0, if φ0

⇒v] let id0 = e0; e1

(cid:8) p; q; [x
(cid:8) p; q; [x

⇒v] e

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

def. e
=

def. mnf
=

Lemma 1
≈

⇒

def.
=

IH
≈

φ0
→∗

Rlet
→

IH
≈

Rlet
←

φ0
←∗

def. e
=

Case The other cases of e are proved analogously.

(cid:74)

(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
40

REFERENCES

(cid:73) Lemma 3 (mnf’ preserves trace). mnf 0 is deﬁned on programs. To evaluate a program, it
is initialized with a set of clients A. mnf 0 preserves the traceset of (closed) programs P for
any set of clients A.

For all P ,

{ initA(mnf 0(P )) } ≈ ... ≈ { initA(P ) }

Proof. By induction over term structure.

Case

P = (d; b; e0).

Initializing the deﬁnitions d; b with A produces the trace p and the state q.

initA(d; b) = p; q

According to ≈, we only consider terms that reduce to a value. Therefore, let φ be the

judgement that the term e0 closed by [x

⇒v] in trace p produces a value v0 and trace p0.

φ ≡

(p; q; e0 →∗ p p0; q; v0)

The lemma holds by the following chain of transitive relations. We evaluate the compiled
program from top to bottom ( →∗) and the original program from bottom to top ( ←∗) until
conﬁgurations converge, using Lemma 2.

(cid:8) initA(mnf 0(P ))
(cid:8) initA(mnf 0(d; b; e0))
(cid:8) initA(d; b; trmp(mnf e(Done(e0))))
(cid:8) p; q; trmp(mnf e(Done(e0)))
(cid:8) p; q; trmp(Done(e0))

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

(cid:8) p p0; q; trmp(Done(v0)) | ∀ v0 p0, if φ (cid:9)
(cid:9)
(cid:8) p p0; q; v0 | ∀ v0 p0, if φ

(cid:8) p; q; e0
(cid:8) initA(d; b; e0)
(cid:8) initA(P )

(cid:9)

(cid:9)

(cid:9)

def. P
=

def. mnf 0
=

def. initA=

Lemma 2
≈

φ
→∗

Rdone
→

φ
←∗

def. initA=

def. P
=

(cid:74)

(cid:90)
REFERENCES

41

(cid:73) Lemma 4 (comp preserves traces). comp is deﬁned on programs. To evaluate a program,
it is initialized with a set of clients A. comp preserves the traceset of (closed) programs P
for any set of clients A.

For all deﬁnitions b, deﬁnitions d, terms e, values v, patterns x,

{ [x

⇒v] initA(comp(d; b; trmp(e))) } ≈ ... ≈ { initA(d; b; trmp([x

⇒v] e)) }

Proof. By induction over term structure.

Case

e = let x = awaitCls((e0, () →e1)); e2.

comp expects the deﬁnitions b to be of form:





b =

@cl this.clfn = id → e1,alt;
@co this.cofn = id → e2,alt;
brest





comp is deﬁned recursively and applied to the term e2. Intuitively, comp transforms e2
2 and b to b0 by moving the part of e2 that comes after the awaitCls call into the cofn

to e0
deﬁnition inside b. The recursive call is given as follows:

(d; b0; trmp(e0

2)) = comp(d; b; trmp(e2))





b0 =

@cl this.clfn = id → e0
@co this.cofn = id → e0
brest

1,alt;
2,alt;





After the recursive call, comp moves the transformed e0
2,alt.

1,alt and e00

in e0 and b00 with e00

2 into the cofn deﬁnition, resulting

φ ≡

(cid:0) { d; b00; trmp(e0) (cid:9) = (cid:8) comp(d; b; trmp(e)) } (cid:1)





b00 =

@cl this.clfn = id → e00
@co this.cofn = id → e00
brest

1,alt;
2,alt;





e00
1,alt =

e00
2,alt =










if let (c :: fv(() →e1)) = id
then e1
else e0

2,alt





if let (c :: x :: fv(x →e0
2)) = id
then assert(this.state == c && this.sender == this.who);

this.state := 0; e0
2

else e0

2,alt






Let p; q be the trace and state produced by initializing d; b with A, and p; q0 for initializing

d; b0, and p; q00 for initializing d; b00.

initA(d; b) = p; q

initA(d; b0) = p; q0
initA(d; b00) = p; q00

(cid:90)
(cid:90)
42

REFERENCES

According to ≈, we only consider terms that reduce to a value. Therefore, let φ0 be the

judgement that the term e0 closed by [x

⇒v] in trace p produces a value v0 and trace p1.

φ0(qφ) = (p; qφ; [x

⇒v] e0 → p p1; qφ; v0)

We deﬁne φ1 based on φ:

φ

=
(cid:8) d; b00; trmp(e0) (cid:9) = (cid:8) comp(d; b; trmp(e)) (cid:9)
→ generalize [x
⇒v] initA(...)
⇒v] initA(d; b00; trmp(e0)) (cid:9) = (cid:8) [x
(cid:8) [x
→ (= → ≈)
(cid:8) [x
→ IH
(cid:8) [x
→ def. initA
(cid:8) p; q00; trmp([x
≡

⇒v] initA(d; b00; trmp(e0)) (cid:9) ≈ (cid:8) [x

⇒v] e0) (cid:9) ≈ (cid:8) p; q; trmp([x

⇒v] e) (cid:9)

⇒v] initA(d; b00; trmp(e0)) (cid:9) ≈ (cid:8) initA(d; b; trmp([x

⇒v] e)) (cid:9)

⇒v] initA(comp(d; b; trmp(e))) (cid:9)

⇒v] initA(comp(d; b; trmp(e))) (cid:9)

φ1

The lemma holds by the following chain of transitive relations. We evaluate the compiled
program from top to bottom ( →∗) and the original program from bottom to top ( ←∗) until
conﬁgurations converge.

def. e
=

def. comp
=

def. initA=

⇒

def.
=

φ0(q00)
→∗

Rset†, Rset†
→

(cid:8) [x
(cid:8) [x



⇒v] initA(comp(d; b; trmp(e)))
⇒v] initA(comp(d; b; trmp(let x3 = awaitCls((e0, () →e1))); e2)) (cid:9)

⇒v] initA(d; b00; trmp(


[x
this.who := e0; this.state := c;
More(c :: fv(() →e1), c :: fv(x →e0

2))))




















⇒v] trmp(

p; q00; [x
this.who := e0; this.state := c;
More(c :: fv(() →e1), c :: fv(x →e0

2))

p; q00; trmp(
this.who := [x
More(c :: [x

⇒v] e0; this.state := c;

⇒v] fv(() →e1), c :: [x

⇒v] fv(x →e0

2)))

p p1; q00; trmp(
this.who := v0; this.state := c;
More(c :: [x
| ∀ v0 p1, if φ0

⇒v] fv(() →e1), c :: [x

⇒v] fv(x →e0

2)))

p p1; q00 [who7→v0, state7→c];
trmp(More(c :: [x
| ∀ v0 p1, if φ0

⇒v] fv(() →e1)), c :: [x

⇒v] fv(x →e0

2))

(cid:9)




















(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
REFERENCES

43

Rmore
→

Rbt
→

case v0
0 = v0
=

Rlet, Rget, Rapp, Rt,
Rget, Rop, Rget,
Rget, Rop, Rop
→∗

def. ≈
≈

Rlet, Rset
→

v0
0 = v0
=

φ1≈

Rlet, Rbs
←

φ0(q)
←∗

⇒

def.
=

def. e
=

def. initA=

p p1; q00 [who7→v0, state7→c];
tmp ←t this.clfn(c :: [x
trmp(this.cofn(c :: tmp :: [x
| ∀ v0 p1, if φ0

⇒v] fv(() →e1));
⇒v] fv(x →e0

2)))

p p1 msg(v0
let tmp = v0
| ∀ v0 p1 v0

2) wr(0, sender, v0

0, v0
2; trmp(this.cofn(c :: tmp :: [x
0 v0

2, if φ0

0); q00 [who7→v0, state7→c];
2)))

⇒v] fv(x →e0

p p1 msg(v0
let tmp = v0
| ∀ v0 p1 v0

p p1 msg(v0
let tmp = v0
| ∀ v0 p1 v0

2) wr(0, sender, v0

0, v0
2; trmp(this.cofn(c :: tmp :: [x
0 v0
2, if v0
0 6= v0, φ0
0, v0
2) wr(0, sender, v0
2; trmp(this.cofn(c :: tmp :: [x
0 v0
2, if v0
0 = v0, φ0
0, v0
2) wr(0, sender, v0

p p1 msg(v0
trmp(assert(false); this.state := 0; [x
| ∀ v0 p1 v0

0 v0
0, v0

2, if v0
0 6= v0, φ0
2) wr(0, sender, v0

p p1 msg(v0
trmp(assert(true); this.state := 0; [x
2, if v0
| ∀ v0 p1 v0

0 = v0, φ0

0 v0

0); q00 [who7→v0, state7→c];
2)))

⇒v] fv(x →e0

0); q00 [who7→v0, state7→c];
2)))

⇒v] fv(x →e0

0); q00 [who7→v0, state7→c];

⇒v0

2, x

⇒v] e0

2))

0); q00 [who7→v0, state7→c];

⇒v0

2, x

⇒v] e0

2)

0, v0

2) wr(0, sender, v0

p p1 msg(v0
trmp(assert(true); this.state := 0; [x
2, if v0
| ∀ v0 p1 v0

0 = v0, φ0

0 v0

0); q00 [who7→v0, state7→c];

⇒v0

2, x

⇒v] e0

2)

p p1 msg(v0
⇒v0
trmp([x
| ∀ v0 p1 v0

0, v0
2, x
0 v0

2) wr(0, sender, v0
⇒v] e0
2)

2, if v0

0 = v0, φ0

0); q00 [who7→v0, state7→0];

p p1 msg(v0, v0
⇒v0
2, x
trmp([x
| ∀ v0 p1 v0
2, if φ0

2) wr(0, sender, v0); q00 [who7→v0, state7→0];
⇒v] e0

2)



































p p1 msg(v0, v0
⇒v0
2, x
trmp([x
| ∀ v0 p1 v0
2, if φ0

2) wr(0, sender, v0); q;
⇒v] e2)


(cid:26) p p1; q; trmp(let x = awaitCls(v0, () →[x

| ∀ v0 p1, if φ0

⇒v] e1); [x

⇒v] e2)

⇒v] e0, () →[x

⇒v] e1); [x

⇒v] e2)

⇒v] let x = awaitCls(e0, () →e1); e2)

(cid:8) p; q; trmp(let x = awaitCls([x
(cid:8) p; q; trmp([x
(cid:8) p; q; trmp([x
⇒v] e)
(cid:8) initA(b; d; trmp([x

⇒v] e))


































(cid:27)

(cid:9)

(cid:9)

(cid:9)

(cid:9)

Case

e = x0.

Let p; q be the trace and state produced by initializing d; b with A.

initA(d; b) = p; q

The traceset equality holds by deﬁnition of comp and initA.

(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
44

REFERENCES

def. e
=

def. comp
=

def. initA=

⇒

def.
=

def. e
=

def. initA=

⇒v] initA(comp(d; b; trmp(e))) (cid:9)
⇒v] initA(comp(d; b; trmp(x0))) (cid:9)
⇒v] initA(d; b; comp(trmp(x0))) (cid:9)
(cid:9)

(cid:8) [x
(cid:8) [x
(cid:8) [x
(cid:8) p; q; [x
(cid:8) p; q; trmp([x
(cid:8) p; q; trmp([x
⇒v] e)
(cid:8) initA(d; b; trmp([x

⇒v] trmp(x0)

⇒v] x0)

⇒v] e))

(cid:9)

(cid:9)

(cid:9)

(cid:74)

(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
(cid:90)
REFERENCES

45

(cid:73) Lemma 5 (comp’ preserves traces). comp0 is deﬁned on programs. To evaluate a program,
it is initialized with a set of clients A. comp0 preserves the traceset of (closed) programs P
for any set of clients A.

For all deﬁnitions b, deﬁnitions d, terms e0,

{ initA(comp0(d; b; trmp(e0))) } ≈ ... ≈ { initA(d; b0; trmp(e0)) }

Proof. By induction over term structure.

Case

P = (d; b; e0).

Intuitively, comp0 prepends the deﬁnitions b with initial deﬁnitions for clfn and cofn that

only contain assert(false), such that comp can be applied.





b0 =

@cl this.clfn = id → assert(false);
@co this.cofn = id → assert(false);
b





The lemma holds by deﬁnition of comp0, and Lemma 4.

(cid:8) initA(comp0(d; b; trmp(e0))) (cid:9)
(cid:8) initA(comp(d; b0; trmp(e0)) (cid:9)
(cid:9)
(cid:8) initA(d; b0; trmp(e0))

def. comp0
=

Lemma 4
≈

(cid:74)

