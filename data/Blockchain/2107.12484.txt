1
2
0
2

l
u
J

6
2

]

C
O
.
h
t
a
m

[

1
v
4
8
4
2
1
.
7
0
1
2
:
v
i
X
r
a

Constant Function Market Makers: Multi-Asset Trades
via Convex Optimization

Guillermo Angeris
angeris@stanford.edu

Akshay Agrawal
akshayka@stanford.edu

Alex Evans
ahe4nc@gmail.com

Tarun Chitra
tarun@gauntlet.network

Stephen Boyd
boyd@stanford.edu

July 2021

Abstract

The rise of Ethereum and other blockchains that support smart contracts has led
to the creation of decentralized exchanges (DEXs), such as Uniswap, Balancer, Curve,
mStable, and SushiSwap, which enable agents to trade cryptocurrencies without trust-
ing a centralized authority. While traditional exchanges use order books to match
and execute trades, DEXs are typically organized as constant function market makers
(CFMMs). CFMMs accept and reject proposed trades based on the evaluation of a
function that depends on the proposed trade and the current reserves of the DEX. For
trades that involve only two assets, CFMMs are easy to understand, via two functions
that give the quantity of one asset that must be tendered to receive a given quantity of
the other, and vice versa. When more than two assets are being exchanged, it is harder
to understand the landscape of possible trades. We observe that various problems of
choosing a multi-asset trade can be formulated as convex optimization problems, and
can therefore be reliably and eﬃciently solved.

1

Introduction

In the past few years, several new ﬁnancial exchanges have been implemented on blockchains,
which are distributed and permissionless ledgers replicated across networks of computers.
These decentralized exchanges (DEXs) enable agents to trade cryptocurrencies, i.e., digital
currencies with account balances stored on a blockchain, without relying on a trusted third
party to facilitate the exchange. DEXs have signiﬁcant capital ﬂowing through them; the
four largest DEXs on the Ethereum blockchain (Curve Finance [Ego19], Uniswap [ZCP18,
AZS+21], SushiSwap [Sus20], and Balancer [MM19]) have a collective trading volume of
several billion dollars per day.

1

 
 
 
 
 
 
Unlike traditional exchanges, DEXs typically do not use order books. Instead, most DEXs
(including Curve, Uniswap, SushiSwap, and Balancer) are organized as constant function
market makers (CFMMs). A CFMM holds reserves of assets (cryptocurrencies), contributed
by liquidity providers. Agents can oﬀer or tender baskets of assets to the CFMM, in exchange
for another basket of assets.
If the trade is accepted, the tendered basket is added to
the reserves, while the basket received by the agent is subtracted from the reserves. Each
accepted trade incurs a small fee, which is distributed pro-rata among the liquidity providers.
CFMMs use a single rule that determines whether or not a proposed trade is accepted.
The rule is based on evaluating a trading function, which depends on the proposed trade and
the current reserves of the CFMM. A proposed trade is accepted if the value of the trading
function at the post-trade reserves (with a small correction for the trading fee) equals the
value at the current reserves, i.e., the function is held constant. This condition is what gives
CFMMs their name. One simple example of a trading function is the product [Lu17,But17],
implemented by Uniswap [ZCP18] and SushiSwap [Sus20]; this CFMM accepts a trade only
if it leaves the product of the reserves unchanged. Several other functions can be used, such
as the sum or the geometric mean (which is used by Balancer [MM19]).

For trades involving just two assets, CFMMs are very simple to understand, via a scalar
function that relates how much of one asset is required to receive an amount of the other,
and vice versa. Thus the choice of a two-asset trade involves only one scalar quantity: how
much you propose to tender (or, equivalently, how much you propose to receive).

For general trades, in which many assets may be simultaneously exchanged, CFMMs are
more diﬃcult reason about. When multiple assets are tendered, there can be many baskets
that can be tendered to receive a speciﬁc basket of assets, and vice versa, there are many
choices of the received basket, given a ﬁxed one that is tendered. Thus the choice of a
multi-asset trade is more complex than just specifying an amount to tender or receive. In
this case the trader may wish to tender and receive baskets that are most aligned with their
preferences or utility (e.g., one that maximizes their risk-adjusted return).

In all practical cases, including the ones mentioned above, the trading function is con-
cave [AC20]. In this paper we make use of this fact to formulate various multi-asset trading
problems as convex optimization problems. Because convex optimization problems can be
solved reliably and eﬃciently (in theory and in practice) [BV04], we can solve the formulated
trading problems exactly. This gives a practical solution to the problem of choosing among
many possible multi-asset trades: the trader articulates their objective and constraints, and
a solution to this problem determines the baskets of assets to be tendered and received.

Outline. We start by surveying related work in §1.1. In §2, we give a complete description
of CFMMs, describing how agents may trade with a CFMM, as well as add or remove
In §3 we study some basic properties of CFMMs, many of which rely on the
liquidity.
concavity of the trading function. In §4 we examine trades involving just two assets, and
show how to understand them via two functions that give the amount of asset received for
a given quantity of the tendered asset. Finally, in §5 we formulate the general multi-asset
trading problem as a convex optimization problem, and give some speciﬁc examples.

2

1.1 Background and related work

Blockchain. CFMMs are typically implemented on a blockchain: a decentralized, permis-
sionless, and public ledger. The blockchain stores accounts, represented by cryptographic
public keys, and associated balances of one or more cryptocurrencies. A blockchain allows
any two accounts to securely transact with each other without the need for a trusted third
party or central institution, using public-key cryptography to verify their identities. Execut-
ing a transaction, which alters the state of the blockchain, costs the issuer a fee, typically
paid out to the individuals providing computational power to the network. (This network
fee depends on the amount of computation a transaction requires and is paid in addition to
the CFMM trading fee mentioned above and described below.)

Blockchains are highly tamper resistant: they are replicated across a network of com-
puters, and kept in consensus via simple protocols that prevent invalid transactions such as
double-spending of a coin. The consensus protocol operates on the level of blocks (bundles
of transactions), which are veriﬁed by the network and chained together to form the ledger.
Because the ledger is public, anyone in the world can view and verify all account balances
and the entire record of transactions.

The idea of a blockchain originated with a pseudonymously authored whitepaper that

proposed Bitcoin, widely considered to be the ﬁrst cryptocurrency [Nak08].

Cryptocurrencies. A cryptocurrency is a digital currency implemented on a blockchain.
Every blockchain has its own native cryptocurrency, which is used to pay the network trans-
action fees (and can also be used as a standalone currency).

A given blockchain may have several other cryptocurrencies implemented on it. These
additional currencies are sometimes called tokens, to distinguish them from the base currency.
There are thousands of tokens in circulation today, across various blockchains. Some, like the
Uniswap token UNI, give holders rights over the governance of a protocol, while others, like
USDC, are stablecoins, pegged to the market value of some external or real-world currency
or commodity.

Smart contracts. Modern blockchains, such as Ethereum [But13,Woo14], Polkadot [Woo16],
and Solana [Yak18], allow anyone to deploy arbitrary stateful programs called smart con-
tracts. A contract’s public functions can be invoked by anyone, via a transaction sent through
the network and addressed to the contract. (The term ‘smart contract’ was coined in the
1990s, to refer to a set of promises between agents codiﬁed in a computer program [Sza95].)
Because creators are free to compose deployed contracts or remix them in their own appli-
cations, software ecosystems on these blockchains have developed rapidly.

CFMMs are implemented using smart contracts, with functions for trading, adding liquid-
ity, and removing liquidity. Their implementations are usually simple. For example, Uniswap
v2 is implemented in just 200 lines of code. In addition to DEXs, many other ﬁnancial appli-
cations have been deployed on blockchains, including lending protocols (e.g., [aav21,com21])
and various derivatives (e.g., [uma21, dyd21]). The collection of ﬁnancial applications run-
ning on blockchains is known as decentralized ﬁnance, or DeFi for short.

3

Exchange-traded funds. CFMMs have some similarities to exchange-traded funds (ETFs).
A CFMM’s liquidity providers are analogous to an ETF’s authorized participants; adding
liquidity to a CFMM is analogous to the creation of an ETF share, and subsequently remov-
ing liquidity is analogous to redemption. But while the list of authorized participants for an
ETF is typically very small, anyone in the world can provide liquidity to a CFMM or trade
with it.

Comparison to order books.
In an order book, trading a basket of multiple assets
for another basket of multiple assets requires multiple separate trades. Each of these trades
would entail the blockchain fee, increasing the total cost of trading to the trader. In addition,
multiple trades cannot be done at the same time with an order book, exposing the trader to
the risk that some of the trades go through while others do not, or that some of the trades
will execute at unfavorable prices.
In a CFMM, multiple asset baskets are exchanged in
one trade, which either goes through as one group trade, or not at all, so the trader is not
exposed to the risk of partial execution.

Another advantage of CFMMs over order book exchanges is their eﬃciency of storage,
since they do not need to store and maintain a limit order book, and their computational
eﬃciency, since they only need to evaluate the trading function. Because users must pay
for computation costs for each transaction, and these costs can often be nonnegligible in
some blockchains, exchanges implementing CFMMs can often be much cheaper for users to
interact with than those implementing order books.

Previous work. Academic work on automated market makers began with the study of
scoring rules within the statistics literature, e.g., [Win69]. Scoring rules furnish probabilities
for baskets of events, which can be viewed as assets or tokens in a prediction market. The
output probability from a scoring rule was ﬁrst proposed as a pricing mechanism for a binary
option (such as a prediction market) in [Han03]. Unlike CFMMs, these early automated
market makers were shown to be computationally complicated for users to interact with.
For example. Chen [CFL+08] demonstrated that computing optimal arbitrage portfolios in
logarithmic scoring rules (the most popular class of scoring rules) is #P-hard.

The ﬁrst CFMM on Ethereum (the most commonly used blockchain for smart con-
tracts) was Uniswap [ZCP18, AZS+21]. The ﬁrst formal analysis of Uniswap was ﬁrst done
in [AKC+20] and extended to general concave trading functions in [AC20]. Evans [Eva20]
ﬁrst proved that constant mean market makers could replicate a large set of portfolio value
functions. The converse result was later proven, providing a mechanism for constructing a
trading function that replicates a given portfolio value function [AEC21b]. Analyses of how
fees [EAC21, TW20] and trading function curvature [AEC20, Aoy20, AI21] aﬀect liquidity
provider returns are also common in the literature. Finally, we note that there exist investi-
gations of privacy in CFMMs [AEC21a], suitability of liquidity provider shares as a collateral
asset [CAEK21], and the question of triangular arbitrage [WCDW21] in CFMMs.

4

1.2 Convex analysis and optimization

Convex analysis. A function f : D
and

→

R, with D

⊆

Rn, is convex if D is a convex set

f (θx + (1

θ)y)

θf (x) + (1

θ)f (y),

−

≤

−

θ

≤

1 and all x, y
for 0
valued function that maps Rn to R
concave if

f is convex [BV04, Chap. 3].

≤

∈

∪ {∞}

D. It is common to extend a convex function to an extended-
D. A function f is

, with f (x) = +

for x

∞

(cid:54)∈

When f is diﬀerentiable, an equivalent characterization of convexity is

−

f (z)

f (x) +

f (x)T (z

x),

∇
D. A diﬀerentiable function f is concave if and only if for all z, x

−

≥

for all z, x

∈

D we have

∈

f (z)

f (x) +

f (x)T (z

x).

(1)

∇
The right hand side of this inequality is the ﬁrst-order Taylor approximation of the function
f at x, so this inequality states that for a concave function, the Taylor approximation is a
global upper bound on the function.

≤

−

By adding (1) and the same inequality with x and z swapped, we obtain the inequality

∇
valid for any concave f and z, x

f is a monotone operator [RB16].

∈

−∇

(

f (z)

f (x))T (z

x)

0,

≤

−

− ∇

(2)

D. This inequality states that for a concave function f ,

Convex optimization. A convex optimization problem has the form

f0(x)
minimize
subject to fi(x)

0,
gi(x) = 0,

≤

i = 1, . . . , m
i = 1, . . . , p,

∈

→

R and inequality

Rn is the optimization variable, the objective function f0 : D

R are convex, and the equality constraint functions gi : Rn

where x
constraint functions fi : D
→
R are aﬃne, i.e., have the form gi(x) = aT
R. (We assume
the domains of the objective and inequality functions are the same for simplicity.) The
goal is to ﬁnd a solution of the problem, which is a value of x that minimizes the objective
function, among all x satisfying the constraints fi(x)
0, i = 1, . . . , m, and gi(x) = 0,
i = 1, . . . , p [BV04, Chap. 4]. In the sequel we will refer to the problem of maximizing a
concave function, subject to convex inequality constraints and aﬃne equality constraints, as
f0 subject
a convex optimization problem, since this problem is equivalent to minimizing
to the constraints.

→
Rn and bi

i x + bi for some ai

≤

−

∈

∈

Convex optimization problems are notable because they have many applications, in a
wide variety of ﬁelds, and because they can be solved reliably and eﬃciently [BV04]. The
It has applications
list of applications of convex optimization is large and still growing.

5

in vehicle control [SB08, Bla16, LB14], ﬁnance [CT06, BBD+17], dynamic energy manage-
ment [MBBW19], resource allocation [ABN+21], machine learning [FHT01,BPC+11], inverse
design of physical systems [AVB21], circuit design [HBL01,BKPH05], and many other ﬁelds.
In practice, once a problem is formulated as a convex optimization problem, we can
use oﬀ-the-shelf solvers (software implementations of numerical algorithms) to obtain so-
lutions. Several solvers, such as OSQP [SBG+20], SCS [OCPB16], ECOS [DCB13], and
COSMO [GCG19], are free and open source, while others, like MOSEK [ApS19], are com-
mercial. These solvers can handle problems with thousands of variables in seconds or less,
and millions of variables in minutes. Small to medium-size problems can be solved ex-
tremely quickly using embedded solvers [DCB13, SBG+20, WB10] or code generation tools
[MB12, CPDB13, BSM+17]. For example, the aerospace and space transportation company
SpaceX uses CVXGEN [MB12] to solve convex optimization problems in real-time when
landing the ﬁrst stages of its rockets [Bla16].

Domain-speciﬁc languages for convex optimization. Convex optimization problems
are often speciﬁed using domain-speciﬁc languages (DSLs) for convex optimization, such as
CVXPY [DB16, AVDB18] or JuMP [DHL17], which compile high-level descriptions of prob-
lems into low-level standard forms required by solvers. The DSL then invokes a solver and
retrieves a solution on the user’s behalf. DSLs vastly reduce the engineering eﬀort required
to get started with convex optimization, and in many cases are fast enough to be used in
production. Using such DSLs, the convex optimization problems that we describe later can
all be implemented in just a few lines of code that very closely parallel the mathematical
speciﬁcation of the problems.

2 Constant function market makers

In this section we describe how CFMMs work. We consider a DEX with n > 1 assets, labeled
1, . . . , n, that implements a CFMM. Asset n is our numeraire, the asset we use to value and
assign prices to the others.

2.1 CFMM state

Reserve or pool. The DEX has some reserves of available assets, given by the vector
R

+, where Ri is the quantity of asset i in the reserves.

Rn

∈

Liquidity provider share weights. The DEX maintains a table of all the liquidity
providers, agents who have contributed assets to the reserves. The table includes weights
representing the fraction of the reserves each liquidity provider has a claim to. We denote
these weights as v1, . . . , vN , where N is the number of liquidity providers. The weights are
0, and (cid:80)N
nonnegative and sum to one, i.e., v
i=1 vi = 1. The weights vi and the number
of liquidity providers N can change over time, with addition of new liquidity providers, or
the deletion from the table of any liquidity provider whose weight is zero.

≥

6

State of the CFMM. The reserves R and liquidity provider weights v constitute the state
of the DEX. The DEX state changes over time due to any of the three possible transactions: a
trade (or exchange), adding liquidity, or removing liquidity. These transactions are described
in §2.2 and §2.6.

2.2 Proposed trade

A proposed trade (or proposed exchange) is initiated by an agent or trader, who proposes to
trade or exchange one basket of assets for another. A proposed trade speciﬁes the tender
basket, with quantities given by ∆
+, which is the basket of assets the trader proposes to
give (or tender) to the DEX, and the received basket, the basket of assets the trader proposes
to receive from the DEX in return, with quantities given by Λ
+. Here ∆i (Λi) denotes
the amount of asset i that the trader proposes to tender to the DEX (receive from the DEX).
In the sequel we will refer to the vectors that give the quantities, i.e., ∆ and Λ, as the tender
and receive baskets, respectively.

Rn

Rn

∈

∈

The proposed trade can either be rejected by the DEX, in which case its state does not
change, or accepted, in which case the basket ∆ is transfered from the trader to the DEX,
and the basket Λ is transfered from the DEX to the trader. The DEX reserves are updated
as

where R+ denotes the new reserves. A proposed trade is accepted or rejected based on a
simple condition described in §2.3, which always ensures that R+

0.

R+ = R + ∆

Λ,

(3)

−

≥

Disjoint support of tender and receive baskets.
Intuition suggests that a trade would
not include an asset in both the proposed tender and receive baskets, i.e., we should not
have ∆i and Λi both positive. We will see later that while it is possible to include an asset
in both baskets, it never makes sense to do so. This means that ∆ and Λ can be assumed to
have disjoint support, i.e., we have ∆iΛi = 0 for each i. This allows us to deﬁne two disjoint
sets of assets associated with a proposed or accepted trade:

=

i

∆i > 0
}

,

=

i

.
Λi > 0
}

T

R
are the indices of assets the trader proposes to give to the DEX, in exchange for the
, it means that the proposed trade does not involve

. If j

{

{

|

|

T

Thus
assets with indices in
asset j, i.e., ∆j = Λj = 0.

R

(cid:54)∈ T ∪ R

{

=

=

i
}

Two-asset and multi-asset trades. A very common type of proposed trade involves
only two assets, one that is tendered and one that is received, i.e.,
= 1. Suppose
= j. Then we have ∆ = δei and Λ = λej, where ei denotes the
and
T
}
0 is the quantity of asset j the trader wishes to receive in exchange
ith unit vector, and λ
≥
for the quantity δ
0 of asset i. (This is referred to as exchanging asset i for asset j.)
When a trade involves more than two assets, it is called a multi-asset trade. We will study
two-asset and multi-asset trades in §4 and §5, respectively.

, with i

|R|

|T |

R

≥

=

{

j

7

(cid:54)
2.3 Trading function

Trade acceptance depends on both the proposed trade and the current reserves. A proposed
trade (∆, Λ) is accepted only if

ϕ(R + γ∆

−

Λ) = ϕ(R),

(4)

R is the trading function associated with the CFMM, and the parameter
(0, 1] introduces a trading fee (when γ < 1). The ‘constant function’ in the name CFMM

+ →

where ϕ : Rn
γ
refers to the acceptance condition (4).

∈

We can interpret the trade acceptance condition as follows. If γ = 1, a proposed trade is
accepted only if the quantity ϕ(R) does not change, i.e., ϕ(R+) = ϕ(R). When γ < 1 (with
typical values being very close to one), the proposed trade is accepted based on the devalued
tendered basket γ∆. The reserves, however, are updated based on the full tendered basket
∆ as in (3).

Properties. We will assume that the trading function ϕ is concave, increasing, and dif-
ferentiable. Many existing CFMMs are associated with functions that satisfy the additional
property of homogeneity, i.e., ϕ(αR) = αϕ(R) for α > 0.

2.4 Trading function examples

We mention some trading functions that are used in existing CFMMs.

Linear and sum. The simplest trading function is linear,

ϕ(R) = pT R = p1R1 +

+ pnRn,

· · ·

with p > 0, where pi can be interpreted as the price of asset i. The trading condition (4)
simpliﬁes to

γpT ∆ = pT Λ.

We interpret the righthand side as the total value of received basket, at the prices given by
p, and the lefthand side as the value of the tendered basket, discounted by the factor γ.

A CFMM with p = 1, i.e., all asset prices equal to one, is called a constant sum market
maker. The CFMM mStable, which held assets that were each pegged to the same currency,
was one of the earliest constant sum market makers.

Geometric mean. Another choice of trading function is the (weighted) geometric mean,

ϕ(R) =

n
(cid:89)

i=1

Rwi
i

,

where total w > 0 and 1T w = 1. Like the linear and sum trading functions, the geometric
mean is homogeneous.

8

CFMMs that use the geometric mean are called constant mean market makers. The
CFMMs Balancer [MM19], Uniswap [ZCP18], and SushiSwap [Sus20] are examples of con-
stant mean market makers. (Uniswap and SushiSwap use weights wi = 1/n, and are some-
times called constant product market makers [AKC+20, AC20].)

Other examples. Another example combines the sum and geometric mean functions,

ϕ(R) = (1

−

α)1T R + α

n
(cid:89)

i=1

Rwi
i

,

∈

[0, 1] is a parameter, w

0, and 1T w = 1. This trading function yields a
where α
CFMM that interpolates between a constant sum market (when α = 0) and a constant
geometric mean market (when α = 1). Because it is a convex combination of the sum and
geometric mean functions, which are themselves homogeneous, the resulting function is also
homogeneous.

≥

The CFMM known as Curve [Ego19] uses the closely related trading function

ϕ(R) = 1T R

n
(cid:89)

i=1

α

−

R−
i

1

,

where α > 0. Unlike the previous examples, this trading function is not homogeneous.

2.5 Prices and exchange rates

In this section we introduce the concept of asset (reported) prices, based on a ﬁrst order
approximation of the trade acceptance condition (4). These prices inform how liquidity can
be added and removed from the CFMM, as we will see in §2.6.

Unscaled prices. We denote the gradient of the trading function as P =
ϕ(R). We
refer to P , which has positive entries since ϕ is increasing, as the vector of unscaled prices,

∇

Pi =

∇

ϕ(R)i =

∂ϕ
∂Ri

(R),

i = 1, . . . , n.

(5)

To see why these numbers can be interpreted as prices, we approximate the exchange accep-
tance condition (4) using its ﬁrst order Taylor approximation to get

when γ∆

−

0 = ϕ(R + γ∆

Λ)

ϕ(R)

ϕ(R)T (γ∆

Λ) = P T (γ∆

Λ),

−
≈ ∇
Λ is small, relative to R. We can express this approximation as

−

−

−

(cid:88)

γ

Pi∆i

i

∈T

PiΛi.

(cid:88)

i

∈R

≈

(6)

The righthand side is the value of the received basket using the unscaled prices Pi. The
lefthand side is the value of the tendered basket using the unscaled prices Pi, discounted by
the factor γ.

9

Prices. The condition (6) is homogeneous in the prices, i.e., it is the same condition if we
scale all prices by any positive constant. The reported prices (or just prices) of the assets
are the prices relative to the price of the numeraire, which is asset n. The prices are

pi =

Pi
Pn

,

i = 1, . . . , n.

(The price of the numeraire is always 1.) In general the prices depend on the reserves R.
(The one exception is with a linear trading function, in which the prices are constant.) In
terms of prices, the condition (6) is

(cid:88)

γ

pi∆i

i

∈T

piΛi.

(cid:88)

i

∈R

≈

(7)

We observe for future use that the prices for two values of the reserves R and ˜R are the

same if and only if

for some α > 0.

ϕ( ˜R) = α

∇

ϕ(R),

∇

Geometric mean trading function prices. For the special case ϕ(R) = (cid:81)n
wi > 0 and (cid:80)n

i=1 wi = 1, the unscaled prices are

i=1 Rwi

i

P =

∇

1
1
1
n ),
2 , . . . , wnR−
1 , w2R−
ϕ(R) = ϕ(R)(w1R−

and the prices are

pi =

wiRn
wnRi

,

i = 1, . . . , n.

(8)

, with

(9)

Exchange rates.
asset i for asset j, the exchange rate is

In a two-asset trade with ∆ = δei and Λ = λej, i.e., we are exchanging

Eij = γ ∇
∇

ϕ(R)i
ϕ(R)j

= γ

Pi
Pj

= γ

pi
pj

.

This is approximately how much asset j you get for each unit of asset i, for a small trade.
Note that EijEji = γ2 < 1, when γ < 1, i.e., round-trip trades lose value.

These are ﬁrst order approximations. We remind the reader that the various condi-
tions described above are based on a ﬁrst order Taylor approximation of the trade acceptance
condition. A proposed trade that satisﬁes (7) is not (quite) valid; it is merely close to valid
when the proposed trade baskets are small compared to the reserves. This is similar to the
midpoint price (average of bid and ask prices) in an order book; you cannot trade in either
direction exactly at this price.

10

Reserve value. The value of the reserves (using the prices p) is given by

V = pT R = ∇
∇
When ϕ is homogeneous we can use the identity
value as

.

(10)

ϕ(R)T R = ϕ(R) to express the reserves

V = pT R =

.

(11)

ϕ(R)T R
ϕ(R)n

∇
ϕ(R)
ϕ(R)n

∇

2.6 Adding and removing liquidity

In this section we describe how agents called liquidity providers can add or remove liquidity
from the reserves. When an agent adds liquidity, she adds a basket Ψ
+ to the reserves,
resulting in the updated reserves R+ = R+Ψ. When an agent removes liquidity, she removes
Ψ. (We
a basket Ψ
will see below that the condition for removing liquidity ensures that R+
0.) Adding or
removing liquidity also updates the liquidity provider share weights, as described below.

+ from the reserves, resulting in the updated reserves R+ = R

Rn

Rn

≥

−

∈

∈

Liquidity change condition. Adding or removing liquidity must be done in a way that
preserves the asset prices. Using (8), this means we must have

ϕ(R+) = α

∇

ϕ(R),

∇

(12)

for some α > 0. (We will see later that α > 1 corresponds to removing liquidity, and α < 1
corresponds to adding liquidity.) This liquidity change condition is analogous to the trade
exchange condition (4). We refer to Ψ as a valid liquidity change if this condition holds.

The liquidity change condition (12) simpliﬁes in some cases. For example, with a linear
trading function the prices are constant, so any basket can be used to add liquidity, and any
0,
basket with Ψ
≤
the domain of ϕ.)

R can be removed. (The constraint comes from the requirement R+

≥

Liquidity change condition for homogeneous trading function. Another simpliﬁ-
cation occurs when the trading function is homogeneous. For this case we have, for any
α > 0,

ϕ(αR) =

ϕ(R),

∇

∇

(by taking the gradient of ϕ(αR) = αϕ(R) with respect to R). This means that Ψ = νR, for
ν > 0, is a valid liquidity change (provided ν
1 for liquidity removal). In words: you can
≤
add or remove liquidity by adding or removing a basket proportional to the current reserves.

Liquidity provider share update. Let V = pT R denote the value of the reserves before
the liquidity change, and V + = (p+)T R+ = pT R+ the value after. The change in reserve
pT Ψ when removing liquidity.
value is V +

V = pT Ψ when adding liquidity, and V +

V =

−

−

−

11

Equivalently, pT Ψ is the value of the basket a liquidity provider gives, when adding liquidity,
V )/V +.
or receives when removing liquidity. The fractional change in reserve value is (V +
When liquidity provider j adds or removes liquidity, all the share weights are adjusted
pro-rata based on the change of value of the reserves, which is the value of the basket she
adds or removes. The weights are adjusted to

−

v+
i =

(cid:40)

viV /V + + (V +
viV /V +

−

V )/V + i = j
= j.

i

(13)

Thus the weight of liquidity provider j is increased (decreased) by the fractional change in
reserve value when she adds (removes) liquidity. These new weights are also nonnegative
and sum to one.

When ϕ is homogeneous and we add liquidity with the basket Ψ = νR, with ν > 0, we

have V+ = (1 + ν)pT R, so

V /V + = 1/(1 + ν),

(V +

−

V )/V + = ν/(1 + ν).

The weight updates for adding liquidity Ψ = νR are then

v+
i =

(cid:40)

(vi + ν)/(1 + ν)
vi/(1 + ν)

i = j
= j.
i

For removing liquidity with the basket Ψ = νR, we replace ν with
vj.
along with the constraint ν

≤

ν in the formulas above,

−

2.7 Agents interacting with CFMMs

Agents seeking to trade or add or remove liquidity make proposals. These proposals are
accepted or not, depending on the acceptance conditions given above. A proposal can be
rejected if another agent’s proposed action is accepted (processed) before their proposed
action, thus changing R and invalidating the acceptance condition.

Slippage thresholds. One practical and common approach to mitigating this problem
during trading is to allow agents to set a slippage threshold on the received basket. This
slippage threshold, represented as some percentage 0
1, is simply a parameter that
speciﬁes how much slippage the agent is willing to tolerate without their trade failing. In
this case, the agent presents some trade (∆, Λ) along with a threshold η, and the contract
accepts the trade if there is some number α satisfying η
α such that the trade (∆, αΛ)
can be accepted. In other words, the agent allows the contract to devalue the output basket
by at most a factor of η. If no such value of α exists, the trade fails.

≤

≤

≤

η

12

(cid:54)
(cid:54)
Maximal liquidity amounts. While setting slippage thresholds can help with reducing
the risk of trades failing, another possible failure mode can occur during the addition of
liquidity. A simple solution to this problem is that the liquidity provider speciﬁes some
basket Ψ to the CFMM contract, and the contract accepts the largest possible basket Ψ−
such that Ψ−
Ψ−, to the liquidity provider. In
other words, Ψ can be seen as the maximal amount of liquidity a user is willing to provide.

Ψ, returning the remaining amount, Ψ

−

≤

3 Properties

In this section we present some basic properties of CFMMs.

3.1 Properties of trades

If we replace the trading function ϕ with ˜ϕ = h

Non-uniqueness.
ϕ, where h is concave,
increasing, and diﬀerentiable, we obtain another concave increasing diﬀerentiable function.
The associated CFMM has the same trade acceptance condition, the same prices, the same
liquidity change condition, and the same liquidity provider share updates as the original
CFMM.

◦

Maximum valid receive basket. Any valid trade satisﬁes ϕ(R + γ∆
in particular R + γ∆
follows that

Λ) = ϕ(R), so
0. Since we assume ∆ and Λ have non-overlapping support, it

−

−

≥

Λ

A valid trade cannot ask to receive more than is in the reserves.

Λ

R.

≤

Non-overlapping support for valid tender and receive baskets. Here we show why
a valid proposed trade with ∆k > 0 and Λk > 0 for some k does not make sense when γ < 1,
justifying our assumption that this never happens. Let ( ˜∆, ˜Λ) be a proposed trade which
coincides with (∆, Λ) except in the kth components, which we set to
˜∆k = ∆k
> 0. Evidently ˜∆

˜Λk = Λk

τ /γ,

−

τ,

γ∆k, Λk
where τ = min
{

}

0, ˜Λ
≥
Λ = R + γ ˜∆

≥

−
0, and
˜Λ,

−

R + γ∆

−

so the proposed trade ( ˜∆, ˜Λ) is also valid. If the trader proposes this trade instead of (∆, Λ),
the net change in her assets is

˜∆ = Λ

˜Λ

−

∆ +

−

(cid:18) 1

γ −

(cid:19)
1

τ ek.

The last vector on the right is zero in all entries except k, and positive in that entry. Thus
the valid proposed trade ( ˜∆, ˜Λ) has the same net eﬀect as the trade (∆, Λ), except that the
trader ends up with a positive amount more of the kth asset. Assuming the kth asset has
value, we would always prefer this.

13

Trades increase the function value. For an accepted nonzero trade, we have

ϕ(R+) = ϕ(R + ∆

Λ) > ϕ(R + γ∆

Λ) = ϕ(R),

−

−
R + γ∆

since ϕ is increasing and R + ∆
greater, whenever γ < 1.

Λ

−

≥

Λ, with at least one entry being strictly

−

We can derive a stronger inequality using concavity of ϕ, which implies that

ϕ(R + γ∆

−
This can be re-arranged as

Λ)

≤

ϕ(R + ∆

Λ) + (γ

1)

∇

−

ϕ(R + ∆

−

−

Λ)T ∆.

ϕ(R+)

≥

ϕ(R) + (1

−

γ)(P +)T ∆,

where P + =
∇
value increases at least by (1

ϕ(R+) are the unscaled prices at the reserves R+. This tells us the function
γ) times the value of tendered basket at the unscaled prices.

−

Trading cost is positive. Suppose (∆, Λ) is a valid trade. The net change in the trader’s
Λ) as the decrease in value of the trader’s
holdings is Λ
holdings due to the proposed trade, evaluated at the current prices. We can interpret δ as a
trading cost, evaluated at the pre-trade prices, and now show it is positive.

∆. We can interpret δ = pT (∆

−

−

Since ϕ is concave, we have

ϕ(R + γ∆

Λ)

−

≤

ϕ(R) +

∇

ϕ(R)T (γ∆

Λ).

−

Using ϕ(R + γ∆

−

Λ) = ϕ(R), this implies

0

ϕ(R)T (γ∆

≤ ∇

Λ) = P T (γ∆

Λ).

−

−

From this we obtain

P T (∆

−

Λ) = P T (γ∆

Λ) + (1

−

−

γ)P T ∆

(1

−

≥

γ)P T ∆.

Dividing by Pn gives

(1

δ

≥

−

γ)pT ∆.

Thus the trading cost is always at least a factor (1
basket.

−

γ) of pT ∆, the total value of the tendered

The trading cost δ is also the increase in the total reserve value, at the current prices.
So we can say that each trade increases the total reserve value, at the current prices, by at
least (1

γ) times the value of the tendered basket.

−

14

3.2 Properties of liquidity changes

Liquidity change condition interpretation. One natural interpretation of the liquidity
change condition (12) is in terms of a simple optimization problem. We seek a basket Ψ that
maximizes the post-change trading function value subject to a given total value of the basket
at the current prices,

maximize ϕ(R+)
subject to pT (R+
Rn

R)

−

≤

M.

(14)

Here the optimization variable is R+
+, and M is the desired value of the basket Ψ at the
current prices, for adding liquidity, or its negative, for removing liquidity. The optimality
conditions for this convex optimization problem are

∈

pT (R+

R)

−

≤

M,

ϕ(R+)

∇

−

νp = 0,

ϕ(R)/

ϕ(R)n, the second condition is

where ν

≥

0 is a Lagrange multiplier. Using p =
ν

∇

ϕ(R+) =

∇

ϕ(R)n ∇

∇

∇
ϕ(R),

which is (12) with α = ν/
since Ψ = R+

R.

−

∇

ϕ(R)n. We can easily recover the trading basket Ψ from R+

Liquidity provision problem. When the trading function is homogeneous, it is easy to
understand what baskets can be used to add or remove liquidity: they must be proportional
to the current reserves. In other cases, it can be diﬃcult to ﬁnd an R+ that satisﬁes (12).
In the general case, however, the convex optimization problem (14) can be solved to ﬁnd the
basket Ψ that gives a valid liquidity change, with M denoting the total value of the added
basket (when M > 0) or removed basket (when M < 0).

Liquidity change and the gradient scale factor α. Suppose that we add or remove
liquidity. Since ϕ is concave (2) tells us that

ϕ(R+)

(
∇

− ∇

ϕ(R))T (R+

R)

0.

≤

−

Using

ϕ(R+) = α

∇

∇

ϕ(R), this becomes

(α

1)

ϕ(R)T (R+

R)

0.

≤
If we add liquidity, we have R+

∇

−

−

We have

∇
ϕ(R)T (R+

ϕ(R) > 0.

= 0, so
R) > 0. From the inequality above we conclude that α < 1. If we remove

0 and R+

≥

−

−

R

R

∇
liquidity, a similar arguments tells us that α > 1.

−

4 Two-asset trades

Two-asset trades, sometimes called swaps, are some of the most common types of trades
performed on DEXs. In this section, we show a number of interesting properties of trades
in this common special case.

15

(cid:54)
4.1 Exchange functions

Suppose we exchange asset i for asset j, so ∆ = δei and Λ = λej, with δ
trade acceptance condition (4) is

≥

0, λ

≥

0. The

ϕ(R + γδei

λej) = ϕ(R).

(15)

−
The lefthand side is increasing in δ and decreasing in λ, so for each value of δ there is at most
one valid value of λ, and for each value of λ, there is at most one valid value of δ. In other
words, the relation (15) between λ and γ deﬁnes a one-to-one function. This means that
two-asset trades are characterized by a single parameter, either δ (how much is tendered) or
λ (how much is received).

R, where F (δ) is the unique λ that
Forward exchange function. Deﬁne F : R+ →
satisﬁes (15). The function F is called the forward exchange function, since F (δ) is how
much of asset j you get if you exchange δ of asset i. The forward exchange function F is
increasing since ϕ is componentwise increasing and nonnegative since F (0) = 0. We will
now show that the function F is concave.

Concavity. Using the implicit function theorem on (15) with λ = F (δ), we obtain

F (cid:48)(δ) = γ ∇
∇

ϕ(R(cid:48))i
ϕ(R(cid:48))j

,

(16)

where we use R(cid:48) = R + γδei
will show that, for any nonnegative trade amounts δ, δ(cid:48)

−

F (δ)ej to simplify notation. To show that F is concave, we

0, the function F satisﬁes

≥

which establishes that F is concave.

F (δ(cid:48))

≤

F (cid:48)(δ)(δ(cid:48)

−

δ) + F (δ),

(17)

We write R(cid:48)(cid:48) = R + γδ(cid:48)ei

F (δ(cid:48))ej, and note that ϕ(R) = ϕ(R(cid:48)) = ϕ(R(cid:48)(cid:48)) from the

deﬁnition of F . Since ϕ is concave it satisﬁes

−

ϕ(R(cid:48))T (R(cid:48)(cid:48)

so

∇

R(cid:48))

−

≥
0

ϕ(R(cid:48)(cid:48))

ϕ(R(cid:48))T (R(cid:48)(cid:48)

≤ ∇

R(cid:48)) + ϕ(R(cid:48)),

−

0. Using the deﬁnitions of R(cid:48)(cid:48) and R(cid:48), we have

γ(δ(cid:48)

δ)

∇

−

ϕ(R(cid:48))i

−

(F (δ(cid:48))

−

F (δ))

ϕ(R(cid:48))j.

∇

≤

Dividing by

ϕ(R(cid:48))j and using (16), we obtain (17).

∇

Reverse exchange function. Deﬁne G : R+ →
, where G(λ) is the unique δ
is there is no such δ. The function F is called the reverse
that satisﬁes (15), or G(λ) =
exchange function, since F (λ) is how much of asset i you must exchange, to receive λ of
asset j. In a similar way to the forward trade function, the reverse exchange function is
nonnegative and increasing, but this function is convex rather than concave. (This follows
from a nearly identical proof.)

∪ {∞}

∞

R

16

Forward and reverse exchange functions are inverses. The forward and reverse
exchange functions are inverses of each other, i.e., they satisfy

G(F (δ)) = δ,

F (G(λ)) = λ,

when both functions are ﬁnite.

Analogous functions for a limit order book market. There are analogous functions
in a market that uses a limit order book. They are piecewise linear, where the slopes are the
diﬀerent prices of each order, while the distance between the kink points is equal to the size
of each order. The associated functions have the same properties, i.e., they are increasing,
inverses of each other, F is concave, and G is convex.

Evaluating F and G.
In some important special cases, we can express the functions F
and G in a closed form. For example, when the trading function is the sum function, they
are

F (δ) = min

γδ, Rj

,

}

{

G(λ) =

(cid:40)

λ/γ
+

∞

λ/γ
Rj
≤
otherwise.

When the trading function is the geometric mean, the functions are

(cid:32)

F (δ) = Rj

1

Rwi/wj
i
(Ri + γδ)wi/wj

−

(cid:33)

,

G(λ) =

(cid:32)

Ri
γ

Rwj /wi
j

(Rj

−

λ)wj /wi −

(cid:33)
1

,

whenever λ < Rj, and G(λ) =

otherwise.

∞

On the other hand, when the forward and reverse trading functions F and G cannot be
expressed analytically, we can use several methods to evaluate them numerically [PTFV92,
§9]. To evaluate F (δ), we ﬁx δ and solve for λ in (15). The lefthand side is a decreasing
function of λ, so we can use simple bisection to solve this nonlinear equation. Newton’s
method can be used to achieve higher accuracy with fewer steps. Exploiting the concavity of
ϕ, it can be shown an undamped Newton iteration always converges to the solution. With
superscripts denoting iteration, this is

λk+1 = λk +

ϕ(R + γδei

λkej)

−

ϕ(R + γδei

ϕ(R)

,

−
λkej)j

∇

−

with starting point based on the exchange rate,

λ0 = δEij = δ

γpi
pj

.

(It can be shown that the convergence is monotone decreasing.) We note that one of the
largest CFMMs, Curve, uses a trading function that is not homogeneous and uses this method
in production [Ego19].

17

Figure 1: Left. Forward exchange functions for two values of the reserves. Right. Reverse exchange
functions for the same two values of the reserves.

Slope at zero. Using (16), we see that F (cid:48)(0+) = Eij, i.e., the one-sided derivative at 0 is
exactly the exchange rate for assets i and j. Since F is concave, we have

F (δ)

≤

F (cid:48)(0+)δ = Eijδ.

(18)

This tells us that the amount of asset j you will receive for trading δ of asset i is no more
than the amount predicted by the exchange rate.

The one-sided derivative of the reverse exchange function G at 0 is G(cid:48)(0+) = Eji. The

analog of the inequality (18) is

G(λ)

≥

G(cid:48)(0+)λ = γ−

2Ejiλ,

(19)

which states that the amount of asset i you need to tender to receive an amount of asset j
is at least the amount predicted by the exchange rate.

Examples. Figure 1 shows the forward and reverse exchange functions for a constant
geometric mean market with two assets and weights w1 = .2 and w2 = .8, and γ = 0.997.
We show the functions for two values of the reserves: R = (1, 100) and R = (0.1, 10). The
exchange rate is the same for both values of the reserves and equal to E12 = γw1R2/w2R1 =
25.

4.2 Exchanging multiples of two baskets

Here we discuss a simple generalization of two-asset trade, in which we tender and receive a
multiple of ﬁxed baskets. Thus, we have ∆ = δ ˜∆ and Λ = λ˜Λ, where λ
0 scale

0 and δ

≥

≥

18

0.00.51.01.52.02.53.0δ051015202530λR=(1,100)R=(.1,10)0.00.51.01.52.02.53.0λ0.000.050.100.150.200.250.30δR=(1,100)R=(.1,10)the ﬁxed baskets ˜∆ and ˜Λ. When ˜∆ = ei and ˜Λ = ej, this reduces to the two-asset trade
discussed above.

The same analysis holds in this case as in the simple two-asset trade. We can introduce
the forward and reverse functions F and G, which are inverses of each other. They are
increasing, F is concave, G is convex, and they satisfy F (0) = G(0) = 0. We have the
inequality

F (δ)
where E is the exchange rate for exchanging the basket ˜∆ for the basket ˜Λ, given by

Eδ,

≤

E = γ ∇
∇
There is also an inequality analogous to (19), using this deﬁnition of the exchange rate. We
mention two speciﬁc important examples in what follows.

.

ϕ(R)T ˜∆
ϕ(R)T ˜Λ

Liquidating assets. Let ∆
+ denote a basket of assets we wish to liquidate, i.e.,
exchange for the numeraire. We can assume that ∆n = 0. We then ﬁnd the α > 0 for which
(∆, αen) is a valid trade, i.e.,

∈

Rn

ϕ(R + γ∆

−

αen) = ϕ(R).

(20)

We can interpret α as the liquidation value of the basket ∆ . We can also show that the
γpT ∆.
liquidation value is at most as large as the discounted value of the basket; i.e., α
To see this, apply (1) to the left hand side of (20), which gives, after cancelling ϕ(R) on

≤

both sides,

Rearranging, we ﬁnd:

ϕ(R)T (γ∆

∇

αen)

0.

≥

−

α

≤

γ

ϕ(R)T ∆
ϕ(R)n

∇
∇

= γpT ∆.

Purchasing a basket. Let Λ
meraire. We ﬁnd α > 0 for which (αen, Λ) is a valid trade, i.e.,

∈

+ denote a basket we wish to purchase using the nu-

Rn

ϕ(R + γαen

Λ) = ϕ(R).

−

(1/γ)pT Λ, i.e.,
We interpret α as the purchase cost of the basket Λ. It can be shown that α
the purchase cost is at least a factor 1/γ more than the value of the basket, at the current
prices. This follows from a nearly identical argument to that of the liquidation value.

≥

19

Figure 2: Valid tendered baskets (∆3, ∆4) for the received basket Λ = (2, 4, 0, 0).

5 Multi-asset trades

We have seen that two-asset trades are easy to understand; we choose the amount we wish to
tender (or receive), and we can then ﬁnd the amount we will receive (or tender). Multi-asset
trade are more complex, because even for a ﬁxed receive basket Λ, there are many tender
baskets that are valid, and we face the question of which one should we use. The same is
true when we ﬁx the tendered basket ∆: there are many baskets Λ we could receive, and
we need to choose one. More generally, we have the question of how to choose the proposed
trade (∆, Λ). In the two-asset case, the choice is parametrized by a scalar, either δ or λ. In
the multi-asset case, there are more degrees of freedom.

Example. We consider an example with n = 4, geometric mean trading function with
weights wi = 1/4 and fee γ = .997, with reserves R = (4, 5, 6, 7). We ﬁx the received basket
to be Λ = (2, 4, 0, 0). There are many valid tendered baskets, which are shown in ﬁgure 2.
The plot shows valid values of (∆3, ∆4), since the ﬁrst two components of ∆ are zero.

5.1 The general trade choice problem

We formulate the problem of choosing (∆, Λ) as an optimization problem. The net change
∆. The trader judges a net change in holdings using a utility
in holdings of the trader is Λ
−
˜∆).
, where she prefers (∆, Λ) to ( ˜∆, ˜Λ) if U (Λ
function U : Rn
∪ {−∞}
→
The value
is used to indicate that a change in holdings is unacceptable. We will assume
that U is increasing and concave. (Increasing means that the trader would always prefer

∆) > U (˜Λ

−∞

R

−

−

20

020406080100∆30102030405060∆4to have a larger net change than a smaller one, which comes from our assumption that all
assets have value.)

To choose a valid trade that maximizes utility, we solve the problem

maximize U (Λ
∆)
subject to ϕ(R + γ∆

−

Λ) = ϕ(R), ∆

0, Λ

0,

≥

≥

−

(21)

with variables ∆ and Λ. Unfortunately the constraint ϕ(R + γ∆
(unless the trading function is linear), so this problem is not in general convex.

−

Λ) = ϕ(R) is not convex

Instead we will solve its convex relaxation, where we change the equality constraint to

an inequality to obtain the convex problem

maximize U (Λ
∆)
subject to ϕ(R + γ∆

−

(22)

Λ)

ϕ(R), ∆

0, Λ

0,

−
which is readily solved. It is easy to show that any solution of (22) satisﬁes ϕ(R + γ∆
Λ) =
ϕ(R), and so is also a solution of the problem (21). (If a solution satisﬁes ϕ(R + γ∆
Λ) >
ϕ(R), we can decrease ∆ or increase Λ a bit, so as to remain feasible and increase the
objective, a contradiction.)

−
−

≥

≥

≥

Thus we can (globally and eﬃciently) solve the non-convex problem (21) by solving the

convex problem (22).

No-trade condition. Assuming U (0) >
, the solution to the problem (22) can be
−∞
∆ = Λ = 0, which means that trading does not increase the trader’s utility, i.e., the trader
should not propose any trade. We can give simple conditions under which this happens for
the case when U is diﬀerentiable. They are

≤
for some α > 0. We can interpret the set of prices p for which this is true, i.e.,

∇

≤

γp

α

U (0)

p,

(23)

K =

p

{

∈

Rn

+ |

γp

α

∇

≤

U (0)

,
p for some α > 0
}

≤

as the no-trade cone for the utility function U . (It is easy to see that K is a convex polyhedral
cone.)

∇

We interpret

U (0) as the vector of marginal utilities to the trader, and p as the prices
of the assets in the CFMM. For γ = 1, the condition says that we do not trade when the
marginal utility is a positive multiple of the current asset prices; if this does not hold, then
the solution of the trading problem (22) is nonzero, i.e., the trader should trade to increase
her utility. When γ < 1, the trader will not trade when the prices are in K.

To derive condition (23), we ﬁrst derive the optimality conditions for the problem (22).

We introduce the Lagrangian

L(∆, Λ, λ, ω, κ) = U (Λ

∆) + λ(ϕ(R + γ∆

Λ)

−

−

−

ϕ(R)) + ωT ∆ + κT Λ,

21

where λ
constraints. The optimality conditions for (22) are feasibility, along with

+ are dual variables or Lagrange multipliers for the

+, and κ

R+, ω

∈

∈

∈

Rn

Rn

The choice ∆ = 0, Λ = 0 is feasible, and satisﬁes this condition if

∇∆L = 0,

∇ΛL = 0.

∇∆L(0, 0, λ, ω, κ) = 0,

∇ΛL(0, 0, λ, ω, κ) = 0.

These are

U (0) + λγ

−∇

ϕ(R) + ω = 0,

∇

U (0)

∇

λ

∇

−

ϕ(R) + κ = 0,

which we can write as

≤
Dividing these by λPn, we obtain (23), with α = 1/(λPn).

∇

∇

∇

≥

U (0)

λγ

ϕ(R),

U (0)

ϕ(R).

λ

∇

5.2 Special cases

Linear utility. When U (z) = πT z, with π
0, we can interpret π as the trader’s private
≥
prices of the assets, i.e., the prices she values the assets at. From (23) we see that the trader
will not trade if her private asset prices satisfy

γp

απ

p

≤

≤

(24)

for some α > 0.

In the special case where π satisﬁes

(π2, . . . , πn) = λ(p2, . . . , pn),

for λ

≥

0, i.e., π is collinear with p except in the ﬁrst entry, (24) is satisﬁed if and only if

If λ = 1, then this simpliﬁes to the condition

λγp1 ≤

π1 ≤

λγ−

1p1.

π1 ≤
(This will arise in an example we present below.)

γp1 ≤

γ−

1p1.

Rn on the assets over
Markowitz trading. Suppose the trader models the return r
Rn and covariance matrix
some period of time as a random vector with mean E r = µ
E(r
+, the return is
rT z; the expected portfolio return is µT z and the variance of the portfolio return is zT Σz. In
κzT Σz,
Markowitz trading, the trader maximizes the risk-adjusted return, deﬁned as µT z

n. If the trader holds a portfolio of assets z

µ)T = Σ

Rn
×

µ)(r

Rn

−

−

∈

∈

∈

∈

−

22

where κ > 0 is the risk-aversion parameter [Mar52, BBD+17]. This leads to the Markowitz
trading problem

maximize µT z
subject to z = zcurr

−

κzT Σz

−
ϕ(R + γ∆
0, Λ
∆

≥

∆ + Λ
Λ)
0,

≥

−
≥

ϕ(R)

(25)

with variables z, ∆, Λ, where zcurr is the trader’s current holdings of assets. This is the
general problem (22) with concave utility function

U (Z) = µT (zcurr + Z)

−

κ(zcurr + Z)T Σ(zcurr + Z).

A well-known limitation of the Markowitz quadratic utility function U , i.e., the risk-
adjusted return, is that it is not increasing for all Z, which implies that the trading function
relaxation need not be tight. However, for any sensible choice of the parameters µ and Σ,
it is increasing for the values of Z found by solving the Markowitz problem (25), and the
relaxation is tight. As a practical matter, if a solution of (25) does not satisfy the trading
constraint, then the parameters are inappropriate.

Rm on the assets
Expected utility trading. Here the trader models the returns r
over some time interval as random, with some known distribution. The trader seeks to
maximize the expected utility of the portfolio return, using a concave increasing utility
R to introduce risk aversion. (Thus we use the term utility function
function ψ : R
to refer to both the trading utility function U : Rn
R and the portfolio return utility
+ →
function ψ : R
R, but the context should make it clear which is meant.) This leads to
the problem

→

→

∈

maximize E ψ(rT z)
subject to z = zcurr

−
ϕ(R + γ∆
0, Λ
∆

≥

∆ + Λ
Λ)
0,

≥

−
≥

ϕ(R)

(26)

where the expectation is over r. This is the general problem (22), with utility

U (Z) = E ψ(rT (zcurr + Z)),

which is concave and increasing.

This problem can be solved using several methods. One simple approach is to replace the
expectation with an empirical or sample average over some Monte Carlo samples of r, which
leads to an approximate solution of (26). The problem can also be solved using standard
methods for convex stochastic optimization, such as projected stochastic gradient methods.

5.3 Numerical examples

In this section we give two numerical examples.

23

Figure 3: Solutions Λ
asset 1 is varied by the factor t from the CFMM price. The blue curve shows asset 1.

∆ for the linear utility maximization problem, as the private price for

−

Linear utility. Our ﬁrst example involves a CFMM with 6 assets, geometric mean trading
function with equal weights wi = 1/6, and trading fee parameter γ = .9. (We intentionally
use an unrealistically small value of γ so the no-trade condition is more evident.) We take
reserves

The corresponding prices are given by (9),

R = (1, 3, 2, 5, 7, 6).

p = (R6/R1, R6/R2, . . . , 1) = (6, 2, 3, 6/5, 6/7, 1).

We consider linear utility, with the trader’s private prices given by

π = (tp1, p2, . . . , pn),

where t is a parameter that we vary over the interval t
[1/2, 2]. For t = 1, we have π = p,
i.e., the CFMM prices and the trader’s private prices are the same (and not surprisingly, the
trader does not trade). As we vary t, we vary the trader’s private price for asset 1 by up to
a factor of two from the CFMM price.

∈

The family of optimal trades are shown in ﬁgure 3, as a function of the parameter t. We
∆ versus t, which shows assets in the tender basket as negative and the received
plot Λ
basket as positive. The blue curve shows asset 1, which we tender when t is small, and
receive when t is large. The no-trade region is clearly seen as the interval t

[0.9, 1.1].

−

∈

Markowitz trading. Our second example uses nearly the same CFMM and reserves as
the previous example, but with a more realistic trading fee parameter γ = .997. (This is a

24

0.60.81.01.21.41.61.82.0t−0.8−0.6−0.4−0.20.00.20.40.6Λ−∆Λ1−∆1Λ2−∆2Λ3−∆3Λ4−∆4Λ5−∆5Λ6−∆6Figure 4: Solutions Λ
aversion parameter κ is varied.

−

∆ for instances of an example Markowitz trading problem as the risk-

common choice of trading fee for many CFMMs.) We solve the Markowitz trading problem
(25), with current holdings

zcurr = (2.5, 1, .5, 2.5, 3, 1),

mean return

µ = (

.01, .01, .03, .05,

.02, .02),

−

−
6 are drawn from the standard
R6
and covariance Σ = V T V /100, where the entries of V
×
normal distribution. We solve the optimal trading problem for values of the risk aversion
2 and 101. (For all of these values, the trading constraint is
parameter κ varying between 10−
tight.) These optimal trades are shown in ﬁgure 4. It is interesting to note that depending
on the risk aversion, we either tender or receive assets 2 and 3.

∈

The CVXPY code for the Markowitz optimal trading problem is given below. In this
snippet we assume that mu, sigma, gamma, kappa, R, and z_curr have been previously deﬁned.
Note that the code closely follows the mathematical description of the problem given in (25).

6 Conclusion

We have provided a general description of CFMMs, outlining how users can interact with
a CFMM through trading or adding and removing liquidity. We observe that many of the
properties of CFMMs follow from concavity of the trading function. In the simple case where
two assets are traded or exchanged, it suﬃces to specify the amount we wish to receive (or
tender), which determines the amount we tender (receive), by simply evaluating a convex

25

10−210−1100101κ−30−20−100Λ−∆Λ1−∆1Λ2−∆2Λ3−∆3Λ4−∆4Λ5−∆5Λ6−∆6import cvxpy as cp

delta = cp.Variable(6)
lam = cp.Variable(6)

z = z_curr - delta + lam
R_new = R + gamma*delta - lam

objective = cp.Maximize(z.T @ mu - kappa*cp.quad_form(z, sigma))
constraints = [

cp.geo_mean(R_new) >= cp.geo_mean(R),
delta >= 0,
lam >= 0

]

problem = cp.Problem(objective, constraints)
problem.solve()

Listing 1: Markowitz trading CVXPY code.

(concave) function. Multi-asset trades are more complex, since the set of valid trades is multi-
dimensional, i.e., multiple tender or received baskets are possible. We formulate the problem
of choosing from among these possible valid trades as a convex optimization problem, which
can be globally and eﬃciently solved.

26

Acknowledgements

The authors would like to acknowledge Shane Barratt for useful discussions. Guillermo
Angeris is supported by the National Science Foundation Graduate Research Fellowship
under Grant No. DGE-1656518. Akshay Agrawal is supported by a Stanford Graduate
Fellowship.

References

[aav21]

Aave. https://aave.com, 2021.

[ABN+21] Akshay Agrawal, Stephen Boyd, Deepak Narayanan, Fiodar Kazhamiaka, and
Matei Zaharia. Allocation of fungible resources via a fast, scalable price discov-
ery method. arXiv preprint arXiv:2104.00282, 2021.

[AC20]

Guillermo Angeris and Tarun Chitra. Improved price oracles: Constant function
In Proceedings of the 2nd ACM Conference on Advances in
market makers.
Financial Technologies, pages 80–91, New York NY USA, October 2020. ACM.

[AEC20]

Guillermo Angeris, Alex Evans, and Tarun Chitra. When does the tail wag the
dog? Curvature and market making. arXiv preprint arXiv:2012.08040, 2020.

[AEC21a] Guillermo Angeris, Alex Evans, and Tarun Chitra. A note on privacy in constant
function market makers. arXiv preprint arXiv:2103.01193, 2021.

[AEC21b] Guillermo Angeris, Alex Evans, and Tarun Chitra. Replicating market makers.

arXiv preprint arXiv:2103.14769, 2021.

[AI21]

Jun Aoyagi and Yuki Ito. Liquidity implications of constant product market
makers. Available at SSRN 3808755, 2021.

[AKC+20] Guillermo Angeris, Hsien-Tang Kao, Rei Chiang, Charlie Noyes, and Tarun
Chitra. An analysis of Uniswap markets. Cryptoeconomic Systems, November
2020.

[Aoy20]

[ApS19]

[AVB21]

Jun Aoyagi. Liquidity provision by automated market makers. Available at
SSRN 3674178, 2020.

MOSEK ApS.
https://docs.mosek.com/9.1/pythonapi/index.html, 2019.

MOSEK Optimizer API

for

Python

9.1.5.

Guillermo Angeris, Jelena Vuˇckovi´c, and Stephen Boyd. Heuristic methods and
performance bounds for photonic design. Optics Express, 29(2):2827, January
2021.

27

[AVDB18] Akshay Agrawal, Robin Verschueren, Steven Diamond, and Stephen Boyd. A
rewriting system for convex optimization problems. Journal of Control and
Decision, 5(1):42–60, 2018.

[AZS+21] Hayden Adams, Noah Zinsmeister, Moody Salem, River Keefer, and Dan Robin-

son. Uniswap v3 core. Technical report, 2021.

[BBD+17]

Stephen Boyd, Enzo Busseti, Steven Diamond, Ronald Kahn, Kwangmoo Koh,
Peter Nystrup, and Jan Speth. Multi-period trading via convex optimization.
Foundations and Trends in Optimization, 3(1):1–76, 2017.

[BKPH05] Stephen Boyd, Seung-Jean Kim, Dinesh Patil, and Mark Horowitz. Digital
circuit optimization via geometric programming. Operations Research, 53(6),
2005.

[Bla16]

Lars Blackmore. Autonomous precision landing of space rockets. The BRIDGE,
26(4), 2016.

[BPC+11]

Stephen Boyd, Neal Parikh, Eric Chu, Borja Peleato, and Jonathan Eckstein.
Distributed optimization and statistical learning via the alternating direction
method of multipliers. Foundations and Trends® in Machine learning, 3(1):1–
122, 2011.

[BSM+17] Goran Banjac, Bartolomeo Stellato, Nicholas Moehle, Paul Goulart, Alberto
Bemporad, and Stephen Boyd. Embedded code generation using the OSQP
solver. In IEEE Conference on Decision and Control, 2017.

[But13]

[But17]

[BV04]

Vitalik Buterin. Ethereum: A next-generation smart contract and decentralized
application platform, 2013.

Vitalik
https://vitalik.ca/general/2017/06/22/marketmakers.html, 2017.

Buterin.

path

On

independence.

Stephen Boyd and Lieven Vandenberghe. Convex Optimization. Cambridge
University Press, Cambridge, UK ; New York, 2004.

[CAEK21] Tarun Chitra, Guillermo Angeris, Alex Evans, and Hsien-Tang Kao. A note on

borrowing constant function market maker shares. 2021.

[CFL+08] Yiling Chen, Lance Fortnow, Nicolas Lambert, David Pennock, and Jennifer
Wortman. Complexity of combinatorial market makers. In Proceedings of the
9th ACM Conference on Electronic Commerce, pages 190–199, 2008.

[com21]

Compound. https://compound.ﬁnance, 2021.

[CPDB13] Eric Chu, Neal Parikh, Alexander Domahidi, and Stephen Boyd. Code gen-
In European Control

eration for embedded second-order cone programming.
Conference, pages 1547–1552. IEEE, 2013.

28

[CT06]

[DB16]

Gerard Cornuejols and Reha T¨ut¨unc¨u. Optimization Methods in Finance. Cam-
bridge University Press, 2006.

Steven Diamond and Stephen Boyd. CVXPY: A Python-embedded model-
ing language for convex optimization. Journal of Machine Learning Research,
17(83):1–5, 2016.

[DCB13]

Alexander Domahidi, Eric Chu, and Stephen Boyd. ECOS: An SOCP solver
In 2013 European Control Conference (ECC), pages
for embedded systems.
3071–3076, Zurich, July 2013. IEEE.

[DHL17]

Iain Dunning, Joey Huchette, and Miles Lubin. JuMP: A modeling language
for mathematical optimization. SIAM review, 59(2):295–320, 2017.

[dyd21]

dydx. https://dydx.exchange, 2021.

[EAC21]

Alex Evans, Guillermo Angeris, and Tarun Chitra. Optimal fees for geometric
mean market makers. arXiv preprint arXiv:2104.00446, 2021.

[Ego19]

[Eva20]

Michael Egorov. StableSwap - eﬃcient mechanism for Stablecoin liquidity.
page 6, 2019.

Alex Evans. Liquidity provider returns in geometric mean markets. arXiv
preprint arXiv:2006.08806, 2020.

[FHT01]

Jerome Friedman, Trevor Hastie, and Robert Tibshirani. The Elements of Sta-
tistical Learning, volume 1. Springer Series in Statistics, 2001.

[GCG19] Michael Garstka, Mark Cannon, and Paul Goulart. COSMO: A conic operator
In 2019 18th European Control

splitting method for large convex problems.
Conference (ECC), pages 1951–1956, Naples, Italy, June 2019. IEEE.

[Han03]

[HBL01]

[LB14]

[Lu17]

Robin Hanson. Combinatorial information market design. Information Systems
Frontiers, 5(1):107–119, 2003.

Maria Hershenson, Stephen Boyd, and Thomas Lee. Optimal design of a CMOS
IEEE Transactions on Computer-aided
op-amp via geometric programming.
design of integrated circuits and systems, 20(1):1–21, 2001.

Thomas Lipp and Stephen Boyd. Minimum-time speed optimisation over a ﬁxed
path. International Journal of Control, 87(6):1297–1311, 2014.

Lu.

Alan
https://blog.gnosis.pm/building-a-decentralized-exchange-in-ethereum-
eea4e7452d6e, 2017.

decentralized

exchange

Building

a

in Ethereum.

[Mar52]

Harry Markowitz. Portfolio selection. The Journal of Finance, 7(1):77–91, 1952.

29

[MB12]

Jacob Mattingley and Stephen Boyd. CVXGEN: A code generator for embedded
convex optimization. Optimization and Engineering, 13(1):1–27, 2012.

[MBBW19] Nicholas Moehle, Enzo Busseti, Stephen Boyd, and Matt Wytock. Dynamic

energy management. arXiv preprint arXiv:1903.06230, 2019.

[MM19]

Fernando Martinelli and Nikolai Mushegian. Balancer: A non-custodial portfo-
lio manager, liquidity provider, and price sensor. 2019.

[Nak08]

Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008.

[OCPB16] Brendan O’Donoghue, Eric Chu, Neal Parikh, and Stephen Boyd. Conic opti-
mization via operator splitting and homogeneous self-dual embedding. Journal
of Optimization Theory and Applications, 169(3):1042–1068, June 2016.

[PTFV92] William Press, Saul Teukolsky, Brian Flannery, and William Vetterling. Nu-
merical Recipes: The Art of Scientiﬁc Computing. Cambridge University Press,
1992.

[RB16]

[SB08]

Ernest Ryu and Stephen Boyd. A primer on monotone operator methods. Ap-
plied Computational Math, 2016.

Gregory Stewart and Francesco Borrelli. A predictive control framework for
In IEEE Conference on Decision and
industrial turbodiesel engine control.
Control (CDC), pages 5704–5711, 2008.

[SBG+20] Bartolomeo Stellato, Goran Banjac, Paul Goulart, Alberto Bemporad, and
Stephen Boyd. OSQP: An operator splitting solver for quadratic programs.
Mathematical Programming Computation, February 2020.

[Sus20]

Sushi. The SushiSwap project, 2020.

[Sza95]

[TW20]

Nick Szabo. Smart contracts. Extropy: Journal of Transhumanist Thought, 16,
1995.

Martin Tassy and David White. Growth rate of a liquidity provider’s wealth in
xy = c automated market makers, 2020.

[uma21]

UMA project. https://umaproject.org, 2021.

[WB10]

Yang Wang and Stephen Boyd. Fast evaluation of quadratic control-Lyapunov
policy. IEEE Transactions on Control Systems Technology, 19(4):939–946, 2010.

[WCDW21] Ye Wang, Yan Chen, Shuiguang Deng, and Roger Wattenhofer. Cyclic arbitrage

in decentralized exchange markets. Available at SSRN 3834535, 2021.

[Win69]

Robert Winkler. Scoring rules and the evaluation of probability assessors. Jour-
nal of the American Statistical Association, 64(327):1073–1078, 1969.

30

[Woo14]

[Woo16]

[Yak18]

[ZCP18]

Gavin Wood. Ethereum: A secure decentralised generalised transaction ledger,
2014.

Gavin Wood. Polkadot: Vision for a heterogeneous multi-chain framework,
2016.

Anatoly Yakovenko.
blockchain, 2018.

Solana: A new architecture for a high performance

Yi Zhang, Xiaohong Chen, and Daejun Park. Formal speciﬁcation of constant
product (xy = k) market maker model and implementation. 2018.

31

