1
2
0
2

p
e
S
5

]

R
C
.
s
c
[

1
v
2
1
0
2
0
.
9
0
1
2
:
v
i
X
r
a

1

Post-Quantum VRF and its Applications in
Future-Proof Blockchain System

Zengpeng Li, Teik Guan Tan, Pawel Szalachowski, Vishal Sharma, and Jianying Zhou

Abstractâ€”A veriï¬able random function (VRF in short) is a powerful pseudo-random function that provides a non-interactively public
veriï¬able proof for the correctness of its output. Recently, VRFs have found essential applications in blockchain design, such as random
beacons and proof-of-stake consensus protocols. To our knowledge, the ï¬rst generation of blockchain systems used inherently inefï¬cient
proof-of-work consensuses, and the research community tried to achieve the same properties by proposing proof-of-stake schemes where
resource-intensive proof-of-work is emulated by cryptographic constructions. Unfortunately, those most discussed proof-of-stake
consensuses (e.g., Algorand and Ouroborous family) are not future-proof because the building blocks are secure only under the classical
hard assumptions; in particular, their designs ignore the advent of quantum computing and its implications. In this paper, we propose a
generic compiler to obtain the post-quantum VRF from the simple VRF solution using symmetric-key primitives (e.g., non-interactive
zero-knowledge system) with an intrinsic property of quantum-secure. Our novel solution is realized via two efï¬cient zero-knowledge
systems ZKBoo and ZKB++, respectively, to validate the compiler correctness. Our proof-of-concept implementation indicates that even
today, the overheads introduced by our solution are acceptable in real-world deployments. We also demonstrate potential applications of a
quantum-secure VRF, such as quantum-secure decentralized random beacon and lottery-based proof of stake consensus blockchain
protocol.

Index Termsâ€”Future-Proof Blockchain, Post-Quantum, Veriï¬able Random Function, Random Beacon Protocol, Proof-of-Stake
Consensus.

âœ¦

1 INTRODUCTION

Public distributed ledgers constitute a new class of systems.
Recently they gained a lot of attention from academic and
industry researchers, various businesses, governments, and
other organizations, e.g., [1], [2]. Thanks to distributed and
authenticated append-only data structures, these systems
provide transparency, availability, and censorship resistance.
However, the main novelty and breakthrough introduced by
public distributed ledgers is a consensus protocol that is
open to anyone and does not require any privileged entities.
Currently, a lot of attention is attracted by proof of stake
(PoS) blockchains, which solve the energy inefï¬ciency of proof
of work (PoW) protocols. Instead of holding a PoW-based
competition to decide who is the round leader (adding a
block of transactions), in PoS systems, a leader is chosen via
a cryptographic lottery from available network nodes, with
their chances of winning is proportional to the number of
coins they hold.

A worrying trend in the blockchain community is to ig-
nore security lessons learned from the previous designs and
deployments of critical systems. It especially concerns as if
adopted, and blockchains are supposed to â€œprovide trustâ€ and
be long-lived. Thus their security is critical. Besides common
security threats, some potential risks can be foreseen. One

â€¢

â€¢

â€¢

Z. Li is with the Shandong University Qingdao Campus, China. (E-mail:
zengpeng@email.sdu.edu.cn.)
T.G. Tan, P. Szalachowski and J. Zhou are with the Singapore University
of Technology and Design, Singapore. (E-mail: {pawel, teikguan tan, jiany-
ing zhou}@sutd.edu.sg.)
V. Sharma
mail: v.sharma@qub.ac.uk.)

the Queenâ€™s University Belfast, UK,

is with

(E-

of the most severe is the advent of quantum computing
as a functional quantum computer could easily undermine
the security of the most distributed ledgers, making them
practically useless. Although, quantum computing is still a
premature organization, like NIST and Google, they concern
about post-quantum cryptographic methods to mitigate risk
for quantum computer destruction [3]. We do not see such a
trend in the blockchain community, however.

Additionally, many consensus protocols involve allocating
the creation of block creator, whose selection procedure, most
often than not, requires a method for collective randomness
sampling. To our knowledge, computers are based on a Turing
machine that is a deterministic device, and the same input
seed always produces the same output sequence. Thus, com-
puters are bad at the generation of randomnesses, and their
outputs are pseudo-random. During the randomness sam-
pling, adversarially biased hashes (known as grinding attacks
or randomness-biasing attacks) imply that a (malicious) miner
can re-create a block multiple times until it is likely that the
miner can create a second block shortly afterward. In other
words, the adversary can bias the nonce that is used to seed
the hash since the adversary can place arbitrary seeds in the
blocks it contributes.

Indeed, randomness-biasing (or grinding) attacks can be
mitigated (even thwarted) by ensuring that a miner is not
able to inï¬‚uence the next leader election by using an unbiased
source of randomness or a deterministic leader election. Obliv-
iously, real-world entropy is not suitable for use as a seed for
blockchain randomness [4], [5]. In reality, there are two main
approaches to blockchain randomness in production, one is
the novel approach of â€œtwo-lookbackâ€ mechanism proposed

 
 
 
 
 
 
1, e.g., ğ‘ ğ‘‘ğ‘Ÿ = ğ»

by Snow White [6], another is using the veriï¬able random
function (VRF) such as Algorand [7] and Ouroboros Praos [8],
etc, or using RANDAO supported by veriï¬able delay function
(VDF). Concretely, the randomness (i.e., seed) published at
round ğ‘Ÿ is determined using a deterministic hashing function
with the preceding randomness from 2ğœ† to ğœ† in Snow White.
Similarly, in Algorand, the randomness (i.e., seed) published at
round ğ‘Ÿ is determined using VRF with the seed of the previous
round ğ‘Ÿ
ğ‘Ÿ
, and the initial value of the
1 k
seed ğ‘ ğ‘‘0. The uniqueness of the pseudorandom output of VRF
enhances the bias resistance, as it stands against any adversary
independently from the number of corrupted servers that the
adversary controls. However, Snow White only achieves a
weak uniqueness with some tolerable errors, supported by
strict requirements for the participants. An important observa-
tion is that these mentioned VRFs are based on non-quantum-safe
hardness assumptions so that they can not remain secure in the
quantum computing era. Thus, the observations as mentioned
above promote us to ask the following question.

ğ‘ ğ‘‘ğ‘Ÿ
(

âˆ’

âˆ’

)

Is it possible to propose a post-quantum veriï¬able random
function that beneï¬ts random beacon and proof of stake
consensus protocol in the coming quantum era?

Contributions and Technical Route.This question can be
answered in the afï¬rmative. In other words, our goal is to ex-
plore how to remain secure for the PoS blockchain consensus
in the quantum era. Inspired by recent PoS-based blockchain
systems [7], [8] and quantum-resistant cryptographic primi-
tives [9], [10], the crux of fulï¬lling the main goal is turning
into how to construct an efï¬cient post-quantum VRF based
on the existing quantum-secure cryptographic primitives, e.g.,
symmetric-based cryptographic building blocks. The main
reason is that the uniqueness of the pseudorandom output of
VRF enhances the bias resistance and beneï¬ts cryptographic
lottery-based proof of stake consensus protocol.

Very recently, Kiltz et al. [11] have provided determin-
istic signatures that are secure under the standard chosen
message attack in the quantum random oracle model, which
is obtained via Fiat-Shamir transformation, a paradigm of
combining a hash function and an identiï¬cation scheme to
produce a digital signature scheme. Kiltz et al. [11] also pro-
vide a practical instantiation of a signature scheme, Dilithium-
QROM, with a tight security reduction in the QROM from the
Module-LWE assumption over the lattice. Although various
lattice-based pseudorandom functions (in short PRFs) are
proposed in succession, these PRFs are not enabling to achieve
the public veriï¬ability and guarantee to play the role of the
traditional ğ»
in the large-scale network due to the overhead
(Â·)
they introduce.

2

â€¢

â€¢

revealing vsk). Thus, we effectively have a deterministic
output with uniqueness functionality.
Post-Quantum Random Beacon via proposed VRF. To
prevent the adversary from predicting who is the follow-
ing block creator while remaining secure in the quantum
era, we offer a quantum-safe decentralized random bea-
con without depending on a third party. In that case,
a straightforward way, either using the â€œtwo-lookbackâ€
mechanism to hash past ğœ† blocks in Snow White or
using VRF to hash the previous block in Algorand and
Ouroboros Paros, etc, to generate randomness is not a
proper approach. Thus, post-quantum decentralized ran-
domness is generated using the technique of quantum-
safe distributed-VRF in section 5, which is achieved by
combining the techniques of veriï¬able secret sharing and
VRF from symmetric primitives.
Post-Quantum PoS via proposed VRF. VRF is becoming
the core of the cryptographic lottery-based PoS consen-
sus protocol. The crux of fulï¬lling the goal of post-
quantum PoS is turning into the instantiation of post-
quantum VRF. In that case, armed with the constructed
post-quantum VRF, as discussed in section 6, we en-
able to eliminate the VRF based on number theoretical
assumptions in Algorand, and we only require that in
each round each node evaluates a post-quantum VRF to
check whether they have been sampled as part of that
roundâ€™s committee. Meanwhile, the number of committee
members is binomial (i.e., depending on the stake distri-
bution), so the amount of work needed to verify the other
committeesâ€™ messages is also binomial.

Organization. This work is organized as follows. The
next section 3 is for preliminaries. In section 4 we present our
motivations and observations, and we discuss how to con-
struct a post-quantum VRF with an implementation and eval-
uation of our concrete instantiation. In section 5, we present
the ï¬rst application of VRF in random beacon. In section 6,
then we present the second application of VRF in proof of
stake. Finally, section 7 is for conclusion.

2 RELATED WORK

The concept of VRF is very similar to the concept of signature.
Thus, there are two main approaches for the construction
of VRFs: 1) a direct approach (e.g., [12]), or 2) an indirect
approach using signatures that have the â€œuniquenessâ€ prop-
erty (e.g., [13]). There is also a close relation between VRFs,
signatures, and ZKPs. Below, we revisit some related works.

Below, we summarize our main contributions along with

2.1 Revisiting Veriï¬able Random Function

the technical route.

â€¢

Post-Quantum VRF. We construct a post-quantum
VRF from symmetric-key primitives by using the post-
quantum ZKP systems in section 4. In a nutshell, the
methodology is using a pseudo-random function to gen-
erate the output of VRF ğœ
m
)
â†
with the secret key vsk while introducing a quantum-safe
zero-knowledge proof (ZKP) system to append a proof
of knowledge of secret key vsk, where the proof is used
to show that â„ is pre-image of the output ğœ (without

for â„ = ğ»1 (

ğ»2 (

vsk, â„

)

To our knowledge, VRF is an important cryptographic tool
in blockchain consensus and random beacon. The essence of
VRF is a mathematical operation that takes some inputs and
produces a random number along with proof of authenticity
that the random number was generated by the submitter. The
appended proof can be veriï¬ed by any challenger to ensure
the random number generation is valid. To our knowledge,
Goldwasser and Ostrovsky [13] introduced an invariant sig-
nature that is called a unique signature afterward, and they
have shown how to transform a unique signature to the

VRF in a fairly straightforward way. Subsequently, Micali,
Rabin, and Vadhan [14] pointed out that if a digital signature
scheme is with the uniqueness property, then ideal hashing
and unique signature provide an elementary implementation
of a VRF. The existing constructions of VRF [12], [15] based on
several theoretical assumptions cannot guarantee security in
the coming quantum era. Recently, lattice-based VRF schemes
are proposed, e.g., [16], but these schemes do not have good
performance in the real world. Thus, achieving a practical
post-quantum VRF is an open question. Very recently, an
independent and similar result with us was proposed by Buser
et al. [17], they used the XMSS signature as the building block
to design quantum-secure VRF, their methodology is using
the unique signature (e.g., XMSS signature) as the beginning
point.

2.2 Revisiting Post-Quantum Zero-Knowledge

Recent advances in quantum computing have increased the
interest
in post-quantum cryptography research, such as
lattice-based, code-based, multivariate-quadratic (MQ), and
hash-based cryptography. Lattice-based cryptographic is more
versatile than others, it has a solid theoretical foundation and
problems (e.g., CVP, SVP, SIS, and LWE) and can realize var-
ious cryptographic primitives. and hash-based cryptography
enables to reduce greatly the size of the ZKPâ€™ statement by us-
ing pseudorandom functions instead of signatures wherever
possible.

Notably, there exist ZKPs that only use collision-resistant
hash functions and hence are plausibly post-quantum se-
cure. Popular examples include Aurora [21], ZKBoo [18],
ZKB++ [9], and ZK-STARK (zero-knowledge scalable trans-
parent argument of knowledge) [20]. Other notable ZKPs like
Bulletproofs or libsnark rely on cryptographic assumptions
that are known to be vulnerable to quantum attacks (e.g.,
the hardness of discrete log in certain elliptic curve groups).
Inspired by the work of Sonic [23], Table 1 is used to illus-
trate asymptotic efï¬ciency comparison of the post-quantum
ZKP security for arithmetic circuits. ZK-STARK [20] aims to
provide fast and scalable solutions while ensuring ï¬nancial
security. Armed with ZK-STARK, transaction encryption is
possible. The acronym ZK-SNARK means â€œZero-Knowledge
Succinct Non-Interactive Argument of Knowledge,â€ the most
important property is that the proof length does not depend
on the length of statements. There are currently two leading
technologies (i.e., Monero, and ZCash) offering their cryp-
tocurrencies while striving to solve protection issues. In partic-
ular, Monero uses ZK-STARK that provides the ability to con-
duct anonymous transactions. However, Zcash is supported
by ZK-SNARK to create a shielded transaction. Compared
with ZK-SNARK, Bulletproof is the short non-interactive zero-
knowledge range proof that requires no trusted setup, while
verifying a bulletproof is more time-consuming than verifying
a SNARK proof.

2.3 Revisiting Post-Quantum Signatures

Obviously, there are similarities between the VRF and the
unique signature, and some unique results enable to provide
a VRF in a straightforward way. According to our investiga-
tion [12], there is a direct approach to construct VRF, which

3

can bypass the unique signature as intermediation. To achieve
quantum-safe, No one doubts that lattice-based cryptography
still objects to further research, but hash-based signatures are
well understood. There are many reasons to use hash-based
schemes The interesting point is that the hash-based signature
could reduce a message to a small representation of characters
that can be signed easily. Whereas a hash-based solution only
needs a secure hash function for the same procedure.

Below, we revisit classical digital signature schemes with a
comparison of the post-quantum signatures in Table 2. There
are two generic paradigms to obtain the lattice-based signa-
ture schemes [31], one is hash-and-sign signature paradigm, e.g.,
Ducas-Lyubashevsky-Prest signature [24], and another is Fiat-
Shamir signature paradigm, such as G Â¨uneysu-Lyubashevsky-
P Â¨oppelmann [32] and BLISS [25]. Unfortunately for them,
these schemes are less efï¬cient and without the unique prop-
erty.

Notably, the current quantum-resistant hash-based signa-
tures, such as SPHINCS1 [33], SPHINCS+
2 [34], and EPID
signature [35] etc, cannot satisfy practical performances and
cannot provide the public veriï¬ability. Remarkably, Picnic is
the ï¬rst quantum-safe signature with public veriï¬ability from
symmetric-key proposed by Chase et al. [9] using the â€œPlay-
MPC-in-the-Headâ€ paradigm [36]. But the signature size of
Picnic3 is near to 40 KBytes. Thus, various optimizations
are proposed to shorten the length of keys and signatures
while improving the computation performance [10]. Notably,
very recently, an independent and similar result with us was
proposed by Buser et al. [17], they used the XMSS signature
as the building block to design quantum-secure VRF, their
methodology is using the unique signature (e.g., XMSS signa-
ture) as the beginning point.

2.4 Revisiting Random Beacons

The need to generate a large number of high-quality ran-
dom numbers is a largely unrecognized requirement of a
production blockchain consensus community. The public ran-
domness beacon enables to issue periodically (i.e., at regular
intervals) fresh unpredictable and unbiased random values
that was ï¬rst proposed by Rabin [37] for contract signing.
Afterwards, several applications for cryptographic primitives,
such as anonymous browsing [38], and blockchain [7], [39],
etc, have been invented. The original idea of Rabin cannot
work without supporting a trusted third party. Thus, a dis-
tributed random beacon that could guarantee output delivery
and uniformly distribute the randomness for participants is
requested. Recently, some elegant distributed random beacon
schemes are proposed for blockchain consensus protocols,
such as Ouroboros [40] and HydRand [41] supported by pub-
lic veriï¬able secret sharing (or PVSS), Algorand [7], Ouroboros
Praos [8], and decentralized random beacon [42] are armed
with VRFs. However, the aforementioned solutions cannot
remain secure in the quantum computing era. Designing
a post-quantum random beacon is increasingly attracted to
researchersâ€™ interest.

1. https://sphincs.cr.yp.to/papers.html
2. https://sphincs.org/resources.html
3. https://microsoft.github.io/Picnic/

TABLE 1: Overview of Feasibly Quantum-Resistant Proof Systems.

4

Scheme

Performance

Size

Assumption Untrusted

Prover

Veriï¬er

CRS

Proof

ğ‘ ğ‘˜

Setup

ZKBoo [18]
Ligero [19]
ZK-STARK [20]
Aurora [21]
Bootle et al. [22]

ğ‘› log ğ‘›
ğ‘› log ğ‘›
ğ‘› polylog ğ‘›
ğ‘› log ğ‘›
ğ‘›

ğ‘ log ğ‘
ğ‘ log ğ‘

â„ log â„
â„ log â„

+
+
polylog ğ‘›

ğ‘ log ğ‘

â„ log â„

+
ğ‘›

ğ‘›
0
0
0
0

âˆšğ‘›
âˆšğ‘›
log2 ğ‘›
âˆšğ‘›
âˆšğ‘›

CRHF
CRHF
CRHF
CRHF
CRHF

âœ—
âœ“
âœ“
âœ“
âœ“

- The communication complexity of ZKB++ is more than halved compared to ZKBoo, not
affecting the computational complexity. This is done by using six different optimizations
that are designed to compress all messages sent as much as possible.

- ğ‘› is the number of gates, ğ‘‘ is the depth of the circuit, â„ is the width of the subcircuits, ğ‘ is
the number of copies of the subcircuits, â„“ is the size of the instance, and ğ‘¤ is the size of the
witness.

- CRHF stands for collision-resistant hash functions.
- âœ“ denotes that the scheme does have this property.
- âœ— denotes that the scheme does not have this property.

TABLE 2: Overview of Post-Quantum Signature Schemes.

Performance

NTRU-GPV [24]
BLISS-BI [25]
Falcon-512 [26]âˆ—
Dilithium-medium [27]
Dilithium-recommended [27]
qTESLA-p-I [28]
qTESLA-p-III [28]
MQDSS-31-64 [29]
HmFev(256,15,3,16) [30]
Rainbow(16,32,32,32) [30]
SPHINCS+ âˆ’
Picnic L1 FS [28]
Picnic2 L1 FS [28]

128 [28]

Sign

â‰ˆ

1200
717
617
2044
2071
2848
6176
64
61
48
16976
32944
12062

Size[Byte]
ğ‘ğ‘˜

ğ‘ ğ‘˜

1792
896
897
1184
1472
14880
39712
34032
83100
145500
32
33
33

NONE
256
4097
2800
3504
5184
12352
24
20
â‰ˆ
18
64
49
49

NTRU-based

Ring-based

Lattice-based

MQ-based

Hash-based

* https://github.com/open-quantum-safe/liboqs

3 PRELIMINARIES AND BUILDING BLOCKS

)

ğœ†

in poly

, ğ»2 (Â·)

and ğ»3 (Â·)

In this section, we review and list deï¬nitions and notations
that will be used in the following principal contents. We begin
by denoting ğœ† as the security parameter, then we review the
standard deï¬nition of the pseudo-randomness functions ğ»
,
(Â·)
ğ»1 (Â·)
time. Apart from the well
(
known pseudo-randomness property, the key one-way states
that it is hard to ï¬nd a key such that the function Fkey maps
a given input ğ‘¥ to a given output ğ‘¦. Fkey is instantiated by
SHA-256 that provides 128 bits of pre-image resistance against
quantum adversaries.
(Non-interactive) Zero-Knowledge (NIZK). For every ğœ†,
is
denoted as an efï¬ciently computable binary relation, for any
as the language consisting of
pair
LR
statements in â„, i.e.
â„
, where ğ‘¥ is
ğ‘¤ s.t.
ğ‘¥
|âˆƒ
{
a statement and ğ‘¤ is the associated witness. In other words,
ğœ†
that
there is a polynomial time algorithm running in poly
(
)
decides whether
Rğœ† consists
of two polynomial time algorithms, prover ğ‘ƒ and veriï¬er ğ‘‰ ,
and proceeds as follows.

) âˆˆ Rğœ†. A Sigma protocol for

, we denote
=

) âˆˆ R

ğ‘¦, ğ‘¤

ğ‘¥, ğ‘¤

ğ‘¥, ğ‘¤

) âˆˆ

LR

R

}

(

(

(

â€¢ (

â€¢

1ğœ†, ğ‘ ğ‘˜ :=

(

ğ‘¦, ğ‘¤

) â†

Com

a, st
is executed by ğ‘ƒ, and he
keeps the corresponding state st privately and sends the
commitment a to the veriï¬er ğ‘‰ .
a challenge c sampled at random in
by ğ‘‰ , given ğ‘¦ and a.

ğœ† is generated

0, 1

))

{

}

(

â€¢

â€¢

(

â†

1ğœ†, ğ‘ ğ‘˜ :=

Prove

, st, c
)

ğ‘¦, ğ‘¤
z
)
and outputs a response z.
ğ‘‰ executes Verify
a, c, z
(
1.

(
is valid. If it is, Verify

(
1ğœ†, ğ‘ğ‘˜ := ğ‘¦, a, c, z

(

)

is executed by ğ‘ƒ given c,

)
1ğœ†, ğ‘ğ‘˜ := ğ‘¦, a, c, z

checks whether
returns

)

When it is clear in the context, we omit 1ğœ† for convenience.
In this setting, ğ‘ğ‘˜ is denoted as ğ‘¦ and ğ‘ ğ‘˜ is denoted as
.
)
Additionally, a NIZK of knowledge can be transformed from
any public-coin zero-knowledge proof (e.g., Sigma-protocol)
by using the Fiat-Shamir transform.

ğ‘¦, ğ‘¤

(

Veriï¬able Random Function. A VRF [14] consists of algo-
and satisï¬es the following
rithms
(
syntaxes.

VrfGen, VrfEval, VrfVrfy

)

â€¢

â€¢

â€¢

)

1ğœ†
)
vsk, m

vpk, vsk
VrfGen
outputs a pair of keys
;
(
)
(
outvrf, ğœ‹vrf)
outputs a pair
VrfEval
, where outvrf
(
vsk, m
is the output value from evaluation function Eval
,
)
and ğœ‹vrf is the proof of correctness given vsk, i.e., ğœ‹vrf â†
Prove
(
=
VrfVrfy
Eval
is
)
valid and 0 otherwise.

vsk, ğœ
vpk, outvrf, m, ğœ‹vrf)
using ğœ‹vrf,

that
then return 1 if outvrf

(
vsk, m

veriï¬es

outvrf

(

(

)

(

.

(

(

(

require

to pass

= Vrfy

when outvrf1

In other words,

vpk, m, outvrf1, outvrf2, ğœ‹vrf1, ğœ‹vrf2)
vpk, outvrf1, m, ğœ‹vrf1)
â‰  outvrf2.

the property of uniqueness,
Additionally, we
provability and pseudorandomness. Uniqueness implies that
no values
can satisfy the
vpk, outvrf2,
equation VrfVrfy
m, ğœ‹vrf2)
for
every m, only a unique value outvrf = Eval
vsk, m
(
)
the
implies
enables
=
vpk, m, outvrf, ğœ‹vrf)
outvrf, ğœ‹vrf)
that VrfVrfy
and ğœ‹vrf
VrfEval
vsk.
given
is
)
Pseudorandomness means that for any probabilistic polynomial-
time (PPT) adversary, it is hard to distinguish the function
values from real random ones, which can be guaranteed by
hashing function Eval
. Formally, for any PPT adversary
who did not call its oracle on message m,
A2)
for some

A
the following probability is at most 1

=
1 if
(
computable

veriï¬cation. Provability

(
vsk, m

(A1,

negl

(Â·)

=

ğœ†

(

2
/

+

(

)

5

Pr ï£®
ğ‘ = ğ‘ â€²
ï£¯
ï£¯
ï£¯
ï£¯
ï£¯
ï£°

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

negligible function negl

vpk, vsk
) â†
(
ğ‘
0, 1
;
â† {
}
outvrf1 â† {

0, 1

(Â·)
VrfGen

;

1ğœ†

in the security parameter ğœ†,
m, st
(
outvrf0 â†
ğ‘ â€² â† A

VrfEval
1
Eval

VrfEval
2

(
( Â·)
(

) â† A

) ;

(

)

ğœ†

(

ğ‘
}

(

vpk
)
;

( Â·)
vsk, m
outvrfğ‘, st

)

;

)

Remark 3.1. We remark that, in general, the post-quantum VRF
could be achieved if the cryptographic building blocks are quantum
security. We omit to introduce the quantum adversary with the
advantages to capture the quantum-secure deï¬nition.

Â· Â· Â·

Distributed-VRF. Below, the deï¬nition is adopted from [42].
, ğ‘†ğ‘› communicate via pair-
In setup phase, ğ‘› servers ğ‘†1, ğ‘†2,
wise private and authenticated channels. They have access
to an append-only public board where every server can post
messages, and these posts cannot be repudiated by their
senders. A setup interaction is then run between ğ‘› servers
to build a global public key ğ‘ğ‘˜, individual serversâ€™ public
veriï¬cation keys vpk1, vpk2,
, vpkğ‘›, and individual serversâ€™
, vskğ‘›. The serversâ€™ secret and veri-
secret key vsk1, vsk2,
for ğ‘– = 1, 2,
, ğ‘› will later enable
ï¬cation keys
(
Â· Â· Â·
any subset of ğ‘¡
1 servers to non-interactively compute the
veriï¬able random value Eval
.
âˆˆ D
(
On the contrary, any set of at most ğ‘¡ servers cannot learn any
information on Eval
for any m not previously com-
ğ‘¡, ğ‘›
(non-interactive) distributed-VRF consists of
puted. A
(
:
the following algorithms

DistKG, PartialEval, Combine, Vrfy

Â· Â· Â·
vskğ‘–, vpkğ‘–)
+

on a plaintext m

vsk, m

vsk, m

Â· Â· Â·

)

)

)

(

]

,

ğ‘›

ğ‘›

)

)

(

{

{

âˆˆ [

âˆˆ [

â€¢ (

1ğœ†, ğ‘¡, ğ‘›

DistKG

vvkğ‘– }ğ‘–

vskğ‘–, vvkğ‘–, m

(
vskğ‘– }ğ‘–

, vskğ‘› }
PartialEval

Â· Â· Â·
of serversâ€™ veriï¬cation keys.

)
vpk,
is a fully
]) â†
distributed key generation algorithm that takes as input
a security parameter 1ğœ†, the number of participating
servers ğ‘›, and the threshold parameter ğ‘¡;
it outputs
a set of qualiï¬ed servers QUAL, a global public key
vsk1,
vpk, a list
of serverâ€™s secret keys, a list
{
, vvkğ‘›}
vvk1,
{
Â· Â· Â·
outvrfğ‘–, ğœ‹vrfğ‘– ) â†
is a partial
â€¢ (
(
evaluation algorithm that takes as input server ğ‘†ğ‘– âˆˆ
QUAL, secret key vskğ‘– , and veriï¬cation key vvkğ‘–,
a plaintext m, and outputs either a triple ğœ‹vrfğ‘– =
ğ‘–, outvrfğ‘–, respğ‘–, cğ‘– )
is the ğ‘–-th evaluation
(
share and respğ‘– is a non-interactive proof of correct partial
evaluation.
outvrf, ğœ‹vrf) â†
is a combina-
tion algorithm that takes as input the global public key
vpk, the veriï¬cation key vvk, a message m, and a set
ğœ€ =
nğœ‹vrfğ‘–1,
o of partial function evaluations
1 different servers, and out-
origination from
of pseudo-random function
puts either a pair
value outvrf and correctness proof ğœ‹vrf, or
.
âŠ¥
0, 1
is a veriï¬cation al-
gorithm that takes as input the public key vpk, a set of
veriï¬cation key vvk, a plaintext m, and a proof ğœ‹vrf, then
outputs 1 or 0 (i.e., accept or reject).

, ğœ‹vrfğ‘–
|ğœ€ |
ğœ€
ğ‘¡
| â‰¥
outvrf, ğœ‹vrf)

vpk, vvk, m, outvrf, ğœ‹vrf)

, where outvrfğ‘–

vpk, vvk, m, ğœ€

Combine

Vrfy

} â†

â€¢ {

â€¢ (

Â· Â· Â·

|
(

+

(

)

(

Additionally, the distributed VRF satisï¬es the following
properties. 1) Consistency, meaning that no matter which
collection of correctly offered shares is used to compute
the function on a plaintext m the same random value
outvrf = F
is obtained. 2) Domain-range correctness,
meaning that every computed value outvrf belongs to the
. 3) Probability means that the uniquely
range domain
recovered value outvrf = F
passes the veriï¬cation

vsk, m

vsk, m

R

)

(

(

)

)

(

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£º
ï£»

vsk, m

passes the veriï¬cation.

test. 4) Uniqueness means that for every plaintext m a unique
outvrf = F
Linear Decomposition of a Circuit. ZKP schemes atop
.
-
MPC-in-the-head paradigm [36] uses an explicit linear
.
)
decomposition of a circuit ğœ™ : â„ğ‘š
â„â„“ over an arbitrary
ï¬nite ring â„. Here ğœ™ can be expressed by an ğ‘›-gate arithmetic
circuit over the ring, and supports multiplication by constant,
binary addition and binary multiplication gates. Below, the
-decomposition of a circuit ğœ™ is deï¬ned for the
linear
(
statement ğ‘¦ = ğœ™

2, 3

2, 3

â†’

(

)

ğ‘–

ğ‘—

â€¢

+

0

1

0

|)

|)

ğ‘¤

ğ‘¤

âˆ’

âˆ’

1)

ğ‘–
)ğ‘—

1, ğ‘›

Â· Â· Â· |

Â· Â· Â· |

âˆˆ [

â†
1, ğ‘¡

ğ‘–
1, tp(
)ğ‘—

. Picks random tapes
, ğ‘¤2 =
1
âˆ’
ğ‘¤2 for a pseudoran-
0

ğ‘¤
|
|
ğ‘–
ğ‘–
Updğœ™ (
, tp(
, view(
)ğ‘—
)ğ‘—
+
+
ğ‘–
. Takes as input the view(
)ğ‘—
]
ğ‘–
1 and tp(
)ğ‘—
+

with a witness ğ‘¤.
ğ‘¤
(
)
Share
ğ‘¤, tp1, tp2, tp3)
ğ‘¤1, ğ‘¤2, ğ‘¤3) â†
(
â€¢ (
â„ğ‘š. Output ğ‘¤1 = G1 (
tp1, tp2, tp3 âˆˆ
, and ğ‘¤3 = ğ‘¤
ğ‘¤1 âˆ’
ğ‘¤
1
G2 (
|)
âˆ’
Â· Â· Â· |
dom generator Gğ‘– seeded with tpğ‘– , where Gğ‘– (
-bit.
outputs the ï¬rst
1
view(
view(
,
)
ğ‘—
]
âˆˆ [
ğ‘–
and tp(
and ğ‘–
of
)ğ‘—
ğ‘–
the participant ğ‘ƒ ğ‘— as well as view(
1 of ğ‘ƒ ğ‘—
1.
)ğ‘—
+
Computes the participant ğ‘ƒ ğ‘— â€™s view of the output wire
of gate gğ‘– and appends it to the view. wğ›¿ is denoted as ğ›¿-
th wire, and w(
is referred to the value of wğ‘˜ in the view
ğ›¿
of ğ‘ƒ ğ‘— . It is notable that the Updğœ™ operation depends on the
type of gate gğ‘— and supports the operation of addition by
constant, multiplication by constant, binary addition and
binary multiplication gates.
â€“ Addition by constant (wğ‘ = wğ‘ +
ğ›¿). Outputs w(
ğ‘—
ğ‘—
if ğ‘— = 1. Otherwise, outputs w(
)ğ‘ .
)ğ‘
â€“ Multiplication by constant (wğ‘ = ğ›¿
wğ‘). Outputs w(
ğ‘

)ğ‘ +

= w(

= w(

ğ‘—
)ğ‘

=

ğ›¿

+

)

)

ğ‘—

ğ‘—

ğ‘—

Â·

wğ‘). Outputs w(

ğ‘—
ğ‘—
)ğ‘ = w(
w(
ğ‘ .
)ğ‘ +
)
ğ‘—
ğ‘—
)ğ‘ = w(
wğ‘). Outputs w(
)ğ‘
ğ‘—
1
ğ‘
ğ‘
PRGğ‘—
PRGğ‘— (
)
)
1 (
ğ‘ +
+
is the ğ‘-th output seeded with tpğ‘— .

ğ‘—
)ğ‘

) âˆ’

w(

Â·
,

)

+

+

Â·

ğ‘—

. Selects the â„“ output wires of the

ğ‘—

)

1

+

â€“ Binary addition (wğ‘ = wğ‘ +
â€“ Binary multiplication (wğ‘ = wğ‘ Â·
ğ‘—
w(
w(
w(
w(
)
ğ‘
ğ‘
ğ‘ +
Â·
ğ‘
where PRGğ‘— (
Output
(

ğ‘¦ ğ‘— â†
)
ğ‘›
circuit as stored in view(
)ğ‘—
= ğ‘¦1 +
ğ‘¦

ğ‘¦1, ğ‘¦2, ğ‘¦3)

)
view (

ğ‘›
)ğ‘—

ğ‘—

â€¢

â€¢

(

â†

Rec

ğ‘¦3. Reconstructs ğ‘¦.

.
ğ‘¦2 +
Non-Interactive ZKBoo atop MPC-in-the-head Paradigm.
Ishai-Kushilevitz-Ostrovsky-Sahai (IKOS) [36] proved a sur-
prising result in 2007 that even semi-honest multiparty com-
putation (MPC) is sufï¬cient to obtain ZKPs. Additionally,
IKOS paradigm [36] enables to provide a transformation to
obtain a zero-knowledge protocol from symmetric primitives
with low communication complexity. As we know, ZKBoo
and ZKB++ build on the MPC-in-the-head paradigm of Ishai
et al. [36], And we conclude their main ideas as follows. For
the public ğœ™ and the word ğ‘¦
âˆˆ Lğœ™ , the prover is with the
witness ğ‘¤ such that ğ‘¦ = ğœ™
ğ‘¤
is denoted
(
as the commitment, ğ»
is the public hash function for the
prover and veriï¬er, and the integer ğ‘¡ is the number of parallel
iterations.
resp
. The prover simulates
an MPC protocol â€œin their headâ€, commits to the state
and transcripts of all players. More concretely,
1) For ğ‘– = 1 to ğ‘¡, set ğ‘Ÿğ‘– as the iteration label, and for
ğ‘–
ğ‘–
ğ‘— = 1 to 3, to obtain an output view(
)ğ‘— and share ğ‘¦ (
,the
)ğ‘—
ğ‘–
ğ‘–
ğ‘–
1 , tp(
2 , tp(
player ğ‘ƒ ğ‘— picks random tapes tp(
and de-
)
)
3
composites the witness ğ‘¤ as follows:

stmt := ğ‘¦, wits := ğ‘¤

. In addition, Com

Proveğ» (

â†

(Â·)

(Â·)

)

)

â€¢

)

w(

ğ‘—
)ğ‘ .

ğ›¿

Â·

â€¢

ğ‘¤ (
(

Share

ğ‘–
2 , ğ‘¤ (
)

ğ‘–
1 , ğ‘¤ (
)

ğ‘–
ğ‘–
ğ‘–
2 , tp(
ğ‘¤, tp(
a) shares
;
)
)
)
3 ) â†
3 )
(
b) computes the ğ‘–-th view of participant
ğ‘—,
i.e.,
ğ‘–
ğ‘–
ğ‘–
, tp(
1, tp(
Updğœ™ (
Updğœ™ (Â· Â· Â·
, ğ‘¤ (
)ğ‘—
)ğ‘—
)ğ‘—
1)
+
+
ğ‘–
result ğ‘¦ (
, and outputs partial
)ğ‘— â†
view(

Updğœ™ (

ğ‘–
1 , tp(
)

)ğ‘— â†

view(

ğ‘–
)ğ‘—

ğ‘¤ (

ğ‘–

ğ‘–

Â· Â· Â· ) Â· Â· Â· )
Output
;
)ğ‘— )
(
c) ï¬nally commits

ğ‘–
, op(
ct(
)ğ‘—
(
ğ‘–
ğ‘–
2 , ğ‘¦ (
1 , ğ‘¦ (
ğ‘¦ (
)
)
2) ğ‘ƒ ğ‘— computes the challenge ğ‘

and sets ğ‘ (

) =

(

ğ‘–

, view(

ğ‘–
)ğ‘—

)

ğ‘–

)ğ‘— ) â†
ğ‘–
3 , ct(
)

ğ‘–
tp(
Com
)ğ‘—
(
ğ‘–
ğ‘–
ğ‘–
1 , ct(
2 , ct(
.
)
)
)
3 )
2
1
ğ»
),
), ğ‘ (
ğ‘ (
(
â†
Â· Â· Â·
for ğ‘– =
ğ‘–
1, 2, 3
) âˆˆ {

ğ‘¡

, ğ‘ (

ğ‘–

ğ‘¡

,

[

}

â†

), ğ‘§ (

ğ‘ (
(

ğ‘–
op(
)ğ‘
(
1
), ğ‘§ (
,
) )
stmt

where ğ‘ can be interpreted as ğ‘ (

) =
creates ğ‘§ (
resp =
1
ğ‘ (
(cid:0)(
Verifyğ» (

,
) )
1, ğ‘¡
.
]
3) For ğ‘– = 1 to ğ‘¡, set ğ‘Ÿğ‘– as the iteration label, the player ğ‘ƒ ğ‘—
ğ‘–
, op(
. Then the player ğ‘ƒ ğ‘— outputs
)ğ‘
1)
+
ğ‘¡
2
2
,
), ğ‘§ (
ğ‘ (
.
))(cid:1)
))
Â· Â· Â·
(
:= ğ‘¦, resp
ğ‘
. The veriï¬er â€œcorruptsâ€
)
a random subset of the simulated players by seeing
their complete state, then the veriï¬er checks that the
computation was done correctly from the perspective of
the corrupted players, and if so, the veriï¬er has some
assurance that the output is correct and the prover knows
ğ‘¥ . Iterating this for many rounds, then the veriï¬er gets
high assurance.
1) For ğ‘– = 1 to ğ‘¡, set ğ‘Ÿğ‘– as the iteration label, the veri-
),
, ğ‘ (
,
) )
1, 2, 3
. Then
ğ‘–
ğ‘–
ğ‘ â€²(
1
) +
(cid:9)
, outputs Reject. Other-
ğ‘–
, sets ntp(
)ğ‘—

ğ»
ï¬er computes the challenge ğ‘ â€² â†
ğ‘–
where ğ‘ â€² can be interpreted as ğ‘ â€²(
the veriï¬er validates if there exists ğ‘—
ğ‘–
ct (
such that Open
)ğ‘—
ğ‘ â€²(

ğ‘ (
), ğ‘ (
(
) âˆˆ {
âˆˆ (cid:8)

wise, for all ğ‘—

)ğ‘— )
), ğ‘ â€²(

Â· Â· Â·
}
), ğ‘ â€²(

, op(
ğ‘–

, view(

âŠ¥
1

=

(

1

2

ğ‘¡

ğ‘–

ğ‘–

ğ‘–

Open

ct(

ğ‘–
)ğ‘—

ğ‘–

, op(

)ğ‘— )
2) Next, the veriï¬er validates Rec

(

(

ğ‘–
2 , ğ‘¦ (
)

ğ‘–
1 , ğ‘¦ (
ğ‘¦ (
)

?= ğ‘¦. If
the validation does not pass, then outputs Reject. If
?=
there exists ğ‘—
ğ‘–
Output
view(
)ğ‘—
outputs Reject. For each wire value w(
1
w(

âˆˆ (cid:8)
. If the validation does not pass, then
viewğ‘’ , if
output Reject.

, then validates ğ‘¦ (

ğ‘–
)
3 )

), ğ‘ â€²(

) +

ğ‘’
)ğ‘—

ğ‘–
)ğ‘—

ğ‘ â€²(

âˆˆ

1

(cid:9)

âˆ’

)

(

)

)

ğ‘–

ğ‘–

ğ‘—

ğ‘—

, view(
ğ‘’
3) The veriï¬er outputs Accept.

â‰  Updğœ™ (

view(
ğ‘’

1
1 , tpğ‘’, tpğ‘’
âˆ’
+

ğ‘’
)ğ‘—

1)

+

)ğ‘— o â†

) +

(cid:9)

âˆˆ (cid:8)
.

4 POST-QUANTUM VERIFIABLE RANDOM FUNCTION

An observation is that Algorand does not adopt the Dodis-
Yampolskiy VRF that depends on the costly bilinear pair-
ing and cannot service the large-scale PoS network. In-
stead, Algorand recommends to adopt the Goldberg-Naor-
Papadopoulos-Reyzin VRF [43] in his realization that by-
passes the unique signature as intermediation. Thus, to pre-
vent quantum computer attacks while servicing the large-scale
lottery-based PoS consensus protocol (e.g., Algorand), in this
work, we present an instance of quantum secure VRF from
symmetric primitives for random beacon and lottery-based
PoS consensus protocol; however, unlike previous construc-
tion, we realize it in a quantum resilient way, i.e., the proposed
VRF isnâ€™t based on hard problems from number theory.
Quantum-secure signature. Before presenting our quantum-
secure VRF construction, we ï¬rst present an indirect approach
using signatures that have the â€œuniquenessâ€ property. In-
spired by the spirit of hash-based signature from Fiat-Shamir
for Schnorr signature, it is easy to design a quantum-safe sig-
nature scheme by integrating a (weakly complete) quantum-

secure identiï¬cation protocol (or Î£ protocol), the methodology
of the signature from Fiat-Shamir is summarized as follows.

6

.

(

)

)

(

)

k

a

ğ»

â†

â†

a, st

, 2) ğ‘

ğ‘ ğ‘˜
(

Com

Prove

â€¢

â€¢

â€¢

, ğ‘ ğ‘˜ := s

ğ‘…, and ğ‘£ğ‘˜ := y = OWF

1ğœ†
Gen
)
(
, it takes ğ‘ ğ‘˜ and a message ğ‘š as input, and
ğ‘ ğ‘˜, ğ‘š
Sign
(
ğ‘ ğ‘˜ := s, os := ğ‘Ÿ
ğ‘š
,
generates 1)
) â†
(
k
â†
)
denotes
and
3)
concatenation.
where
ğ‘ ğ‘˜ := s, st, c
it runs
. If z is not valid,
z
)
(
another round. It keeps running until z is valid. Finally it
returns the signature ğœ :=
a, c, z
rejects
Vrfy
if
,
)
= 0.
ğ‘š
ğ‘¦, ğ‘š,
(
In short, the OWF family

ğ¾ğœ† is used for key gener-
{
ation in both signature schemes, the public key is an image
ğ‘¦ = ğ‘“
of a one-way function ğ‘“ and secret key ğ‘¥ , and a
signature is an NIZK proof ğœ‹ of ğ‘¥ , that incorporates a message
to be signed.

there exists Vrfy

ğ‘£ğ‘˜, ğ‘š, ğœ
a, z, ğ»

ğ‘“ğ‘˜ }ğ‘˜

it
a

(
(

)))

:=

ğ‘£ğ‘˜

ğ‘¥

k

)

(

)

(

(

âˆˆ

.

4.1 Provably Secure VRF from Symmetric Primitives

Notably, there are two issues that may prevent some kinds of
signature schemes with uniqueness from being used straight-
forwardly as a VRF. Firstly, the signature may not be unique
by given the message x and the public key ğ‘ğ‘˜. Secondly, the
signature ğœx is unpredictable but not pseudorandom (e.g., sig-
natures could contain some bias and be distinguishable from
a random distribution.) In addition, VRF derived from unique
signatures presents strong unbiasibility properties due to the
uniqueness, even in the presence of active adversaries, of the
corresponding pseudorandom value. Thus, it is not enough to
obtain a VRF with uniqueness and pseudorandomness from
the quantum-secure unique signature in a fairly straightfor-
ward way. Indeed, according to our investigation [12]4, there
is a direct approach to construct VRF, which can bypass the
unique signature as intermediation.

As mentioned earlier, any VRF has three components,
generator, evaluator, and veriï¬er. The evaluator executes two
functions, the evaluation and the prover. The paradigm of
post-quantum VRF is achieved by leveraging concepts to-
gether with symmetric cryptography and quantum-safe ZKP
systems to create a signature. In a nutshell, this paper intro-
duces a new post-quantum VRF by using the ideas of [43]
for construction of the evaluation function and ideas of [11]
for construction of the prover based on a quantum-safe ZKP
for the uniqueness property. An important difference between
this proposed VRF construction and [43], [11] is the fact that
in the proposed VRF both the evaluator, and veriï¬er should
have access to the same secret key. Thus, the use of a priori
post-quantum symmetric key protocol is also required.

To make it understand easily, our VRF evaluation function
uses deterministic hash functions to hash the message and
appends a quantum-safe proof of knowledge for the witness
secret key, where the prover can convince the veriï¬er that she
knows a secret key without disclosing the secret key itself.
There is a public key vpk associated with a secret seed vsk and
a pesudorandom hash function F
, then it satisï¬es 1)
(
computable given the corresponding vsk, where outvrf
calculated by using hash functions ğ»2 (
4. https://www.cs.bu.edu/âˆ¼goldbe/projects/vrf

â† K
is efï¬ciently
is
. 2) A proof

with a random key k
vsk, m

(
vsk, ğ»1 (

outvrf, ğœ‹vrf)

= VrfEval

(Â·)

m

))

)

(

))

outvrf, vsk
)
vsk, ğ»1 (

ğœ‹vrf is computable given the vsk, and a natural approach is
. 3) No
the quantum-safe ZKP by invoking Prove
adversary can distinguish outvrf by computing ğ»2 (
m
from a random value without explicitly querying for m.
Equality of ZKBoo. In addition, to guarantee the uniqueness
without disclosing the secret key, a equality of quantum-
secure ZKP system is used to prove that the public key and the
output of VRF have same pre-image secret key here. Below,
we present the equality of ZKBoo system as a warm-up, which
is an independent contribution. Here, regarding the relation
, ğœ = ğ»2 (
: ğ›¼ = F
, the equality of
(
L
=
k, ğ‘ 
ğ›¼, k; ğ‘ 
and
ZKBoo proceeds relations
{(
ğ‘ , â„
synchronously. In particular, the
Lğ»2
prover proceeds as depicted in Fig.1 and the veriï¬er proceeds
as depicted in Fig. 2.

)
: ğœ = ğ»2 (

k, ğ‘ 
)
LF1
)}

)}
: ğ›¼ = F

ğ›¼, k, ğœ, â„; ğ‘ 

ğœ, â„; ğ‘ 

ğ‘ , â„

{(

{(

)}

=

=

)

)

(

Equality Proof Algorithm of ZKBoo.

â€¢

ğ‘–

â†

for

and

Share

)ğ›¼,3) â†
)ğœ,3) â†

ZKP.Proveğ» (

ğ‘–
ğ‘–
ğ‘–
1 , ğ›¼.tp (
ğ‘ , ğ›¼.tp (
2 , ğ›¼.tp (
)
)
)
3 )
(
ğ‘–
ğ‘–
ğ‘–
1 , ğœ.tp (
2 , ğœ.tp (
ğ‘ , ğœ.tp(
)
)
)
3 )
(
ğ‘–
and ğœ.tp (
.
)ğ‘—

resp
stmt, wits
for the iteration label
)
ğ‘– = 1 to ğ‘¡ and the dummy participant label ğ‘— = 1 to 3.
1) compute
ğ‘–
ğ‘–
ğ›¼,1, ğ‘  (
ğ‘  (
ğ›¼,1, ğ‘  (
)
)
(
ğ‘–
ğ‘–
ğ‘–
Share
ğœ,1, ğ‘  (
ğœ,1, ğ‘  (
ğ‘  (
)
)
(
ğ‘–
random tapes ğ›¼.tp (
)ğ‘—
2) compute ğ›¼.view (
)ğ‘— â†
ğ‘–
UpdF(
UpdF (Â· Â· Â·
UpdF (
ğ‘  (
)ğ‘—
ğ‘–
and compute ğœ.view (
)ğ‘— â†
ğ‘–
Updğ»2 (
Updğ»2 (Â· Â· Â·
Updğ»2 (
ğ‘  (
)ğ‘—
(see ZKBoo for details);
Output
3) obtain ğ›¼.stmt (
ğ›¼.view (
(
ğ‘–
ğœ.view (
;
)ğ‘— )
Com

ğ‘–
1, ğœ.tp (
, ğ‘  (
)ğ‘—
)
ğ‘—
+

)ğ‘— â†
Output

ğ‘–
, ğ›¼.tp (
)ğ‘—
+

ğ‘–
1, ğ›¼.tp (
)ğ‘—

1) Â· Â· Â· ) Â· Â· Â· )

ğ‘–
, ğ‘  (
)ğ‘—
+

, ğœ.tp (
ğ‘—

ğœ.stmt(

)ğ‘— )

and

ğ‘–

ğ‘–

ğ‘–

ğ‘–

ğ‘–

ğ‘–

ğ‘–

ğ‘–
)ğ‘—

(
, ğ›¼.op (
ğ‘–
)ğ‘—

) â†

) â†
Com

(
ğœ.tp (

(

ğ‘–
)ğ‘—

ğ›¼.tp (
ğ‘–
)ğ‘—

)ğ‘— )

, ğ›¼.view (
ğ‘–
)ğ‘— )

;

, ğœ.view(

)
1) Â· Â· Â· ) Â· Â· Â· )
+

4) commit
and

)ğ‘— â†
ğ‘–
ğ›¼.ct (
)ğ‘—
(
ğ‘–
ğœ.ct(
, ğœ.op(
)ğ‘—
) =
ğ‘–
5) create ğ›¼.ğ‘ (
ğ‘–
1 , ğ›¼.stmt(
ğ›¼.stmt (
)
(
) =
ğ‘–
ğœ.ğ‘ (
ğœ.stmt (

(

ğ‘–
ğ‘–
2 , ğœ.stmt(
1 , ğœ.ct(
)
)
6) compute the challenge internally chlg

ğ‘–
1 , ğœ.stmt(
)

ğ‘–
3 , ğœ.ct(
)

(

ğ‘–
2 , ğ›¼.ct(
)

ğ‘–
)
3 )
ğ‘–
ğ‘–
2 , ğœ.ct(
)
)
3 )
1, 2, 3
}
âˆˆ {

;
, i.e.,

ğ‘
ğ»

1

â†
ğ›¼.ğ‘ (
(
7) create ğ›¼.ğ‘§ (
ğ‘–

2
, ğ›¼.ğ‘ (
) , ğ›¼.ğ‘ (
),
Â· Â· Â·
ğ‘–
) =
ğ‘–
ğ›¼.op (
)ğ‘
(
ğ‘–
ğ‘–
) =
, ğœ.op (
ğœ.op (
)ğ‘
)ğ‘
8) output ğ›¼.resp =
+
1
,

ğœ.ğ‘§ (

) , ğ›¼.ğ‘§ (

ğ›¼.ğ‘ (

(

1

2

1)

ğ‘¡

1

ğœ.ğ‘ (
ğ‘–
)
1)
+

) k
, ğ›¼.op (
ğ‘
;

), ğœ.ğ‘ (
and

2

),

, ğœ.ğ‘ (

ğ‘¡

;

) )

Â· Â· Â·

ğ›¼.ğ‘ (
(cid:0)(
ğœ.resp =
ğœ.ğ‘ (

1

(cid:0)(

) )

(

) , ğ›¼.ğ‘§ (

2

,

) )

Â· Â· Â·

) , ğœ.ğ‘§ (

2

ğœ.ğ‘ (

) , ğœ.ğ‘§ (

2

1

,

) )

(

,

) )

Â· Â· Â·

and

,

,

ğ‘¡

ğ›¼.ğ‘ (

) , ğ›¼.ğ‘§ (

ğ‘¡

(

ğ‘¡

ğœ.ğ‘ (

) , ğœ.ğ‘§ (

ğ‘¡

(

) )(cid:1)

.

) )(cid:1)

Fig. 1: Equality Proof Algorithm of ZKBoo.

Post-Quantum VRF via ZKBoo. Armed with the equality of
ZKBoo, the detailed post-quantum VRF via ZKBoo is depicted
in Fig. 3 for key generation, Fig. 4 for evaluation, and Fig. 5
for veriï¬cation. Notably, we only present a post-quantum VRF
via ZKBoo. Indeed, it is easy to obtain a quantum-secure VRF
via other candidates post-quantum ZKP, such as ZKB++ and
ZKSTARK, but we ignore the details here.

7

for the iteration label ğ‘– = 1

ğ‘–

) and ğ›¼.ğ‘§ (
) ,
) sequences;

â€¢

ğ‘–

ğ‘–

ğ‘¡

1

2

1

ğ»

â†

ğ›¼.ğ‘ (

) and ğœ.ğ‘§ (

Equality Veriï¬cation Algorithm of ZKBoo.
stmt := ğ‘¦, resp
)

ğ‘
to ğ‘¡ and the dummy participant label ğ‘— = 1 to 3.
1) parse ğ›¼.resp into the sequence of ğ›¼.ğ‘ (
ğ‘–

Verifyğ» (

, ğ›¼.ğ‘ (
ğ‘–
), ğ‘ â€²(

and parse ğœ.resp into ğœ.ğ‘ (
2) compute the challenge ğ‘ â€² â†
), ğœ.ğ‘ (
),
ğœ.ğ‘ (
) , ğ›¼.ğ‘ (
),
) k
Â· Â· Â·
Â· Â· Â·
(
ğ‘–
ğ‘ â€²(
ğ‘—
, then set
3) validate
1
) +
}
âˆˆ {
ğ‘–
ğ‘–
ğ‘–
ğ‘–
, ğ›¼.op (
ğ›¼.ct (
, ğ›¼.view (
ğ›¼.tp (
Open
)ğ‘—
)ğ‘—
)ğ‘— } â†
)ğ‘—
(
ğ‘–
ğ‘–
ğ‘–
ğ‘–
, ğœ.op(
ğœ.ct(
, ğœ.view(
ğœ.tp(
Open
)ğ‘—
)ğ‘—
)ğ‘— } â†
)ğ‘—
(
ğ‘–
ğ‘–
ğ‘–
2 , ğ›¼.stmt (
ğ›¼.stmt (
4) validate Rec
1 , ğ›¼.stmt (
)
)
)
3 )
?= ğœ.stmt;
ğ‘–
ğ‘–
ğ‘–
1 , ğœ.stmt(
and Rec
2 , ğœ.stmt(
)
)
)
3 )
(
), ğ‘ â€²(
ğ‘ â€²(
1
5) validate
,
) +
}
âˆˆ {
âˆƒ
?= Output
ğ‘–
ğ‘–
ğ›¼.view (
ğ›¼.stmt (
)ğ‘— )
)ğ‘—
(
?= Output
ğ‘–
ğ‘–
ğœ.view (
)ğ‘— )
)ğ‘—
ğ›¼.viewğ‘’ and
ğ›¼.w(
6) validate

(
ğœ.stmt (

ğœ.stmt(

, ğœ.ğ‘ (

ğœ.w(

and

and

{
{

)
)

âˆ€

2

ğ‘—

;

ğ‘–

ğ‘–

ğ‘¡

;

) )

;
?= ğ›¼.stmt

(
âˆˆ

âˆ€

then validate
ğ›¼.w(
and
ğœ.w(

ğ‘’
)ğ‘—
?= UpdF(
?= UpdF(

ğ‘’
)ğ‘—

ğ‘’
)ğ‘—

ğ›¼.view (
ğ‘’

ğ‘—

1

âˆ’

)

, ğ›¼.view (
ğ‘’

ğœ.view (
ğ‘’
7) output 1 if all validations are passed.

, ğœ.view(
ğ‘’

âˆ’

)

)

ğ‘—

1

ğ‘’
)ğ‘—

âˆˆ

ğœ.viewğ‘’ ,

âˆ€

ğ‘—

)

1
1 , ğ›¼.tpğ‘’, ğ›¼.tpğ‘’
âˆ’
+
ğ‘—
1
1 , ğœ.tpğ‘’, ğœ.tpğ‘’
âˆ’
+

1)

+

;

1)

+

Fig. 2: Equality Veriï¬cation Algorithm of ZKBoo.

VrfGen of Post-Quantum VRF via ZKBoo.

â€¢ (

vsk, vpk

1ğœ†
) â†
1) Choose a secret key ğ‘ 

VrfGen

(

.

)
â† D

and a random key
for the pseudo-random function F, and

k
â† K
return vsk

k, ğ‘ 

.

)

â† (

2) Compute the public key
= F

vpk := ğ›¼ = F

k, vsk
)

(

k, ğ‘ 

.

)

(

4.2 Post-Quantum VRF Security Analysis

every input m.
,

Importantly, the proposed VRF isnâ€™t based on hard problems
from number theory, and the hard problems the proposed VRF
relies on for security relate only to symmetric cryptographic
primitives that are thought to be secure against quantum at-
tacks, and quantum security can be guaranteed easily. Below,
we analyze uniqueness and pseudorandomness sketchily.
Uniqueness Analysis. The uniqueness property requires
there should be only one provable VRF output
that
outvrf
every
such that outvrfâ€² â‰ 
vpk, m,
(cid:0)
=
outvrfâ€², ğœ‹vrfâ€²))
outvrfâˆ—,
the property
VrfVrfy
there is an
of uniqueness using a contradiction.
If
adversary that violates
the
â‰  m
adversary can come up with a message mâ€²(
)
stmtâ€²
contains
given vsk. The
generated statement
vpk := ğ›¼, outvrfâ€²
:= ğ»1 (
:= ğœ â€²)
for â„â€²
, and proof
mâ€²)
(
ğœ‹vrfâ€² contains ğœ‹vrfâ€² =
:= ğ‘§ â€²)
chlgâ€²
such that
(
:= ğ›½ â€² = ğ»3 (
ğœ â€²)
an incorrect VRF output value outvrfâ€²
is
vsk, â„â€² = ğ»1 (
computed for ğœ â€² = ğ»2 (
and a different

outvrfâˆ—, ğœ‹vrfâˆ—)(cid:1)
(
following VrfVrfy
(
outvrfâˆ—, ğœ‹vrfâˆ—))

for
outvrfâ€², ğœ‹vrfâ€²)
the
vpk, m,

computational uniqueness,

(
. We prove

In particular,

:= ğ‘ â€², respâ€²

vpk, m,

mâ€²))

for

(

(

(

ğ‘–
2 , ğ›¼.stmt(
)

ğ‘–
3 , ğ›¼.ct(
)

ğ‘–
1 , ğ›¼.ct(
)

Fig. 3: Key Generation of Post-QuantumVRF via ZKBoo.

and

VrfEval of Post-Quantum VRF via ZKBoo.

.

.

)

m
)
k, ğ‘ 

VrfEval

outvrf, ğœ‹vrf) â†
â€¢ (
1) Compute â„ = ğ»1 (
2) Regarding ğ›¼ = F
(
ğ‘ , â„

vsk :=
k, ğ‘ 
,ğ‘š
(
(
)
, ğœ = ğ»2 (
, and ğ›½ = ğ»3 (
ğ‘ , â„
ğœ
)
) âˆˆ LF for a circuit F, and
ğœ = ğ»2 (
) âˆˆ Lğ»2 for a circuit ğ»2, invoke the quality
of post-quantum ZKP system for the relation
, ğœ = ğ»2 (
=
by
and the
(

L
)
(
inputting the statement stmt :=
witness wits := vsk = ğ‘ , then obtain the proof of
knowledge of secret key to prove the output
(
is the correct hash output. In particular, invoke

ğ‘ , â„
ğ›¼, k, ğœ, â„

ğ›¼, k, ğœ, â„; ğ‘ 

: ğ›¼ = F

)}
)

ğ›¼, ğœ

k, ğ‘ 

{(

)

)

)

stmt, wits
)

â†

resp

ğ›¼, k; ğ‘ 
)
ğœ, â„; ğ‘ 

ZKP.Proveğ» (
as depicted in Fig.1 to proceed relations
LF =
: ğ›¼ = F
k, ğ‘ 
{(
(
=
: ğœ = ğ»2 (
Lğ»2
{(
)
a computation integrity proof
ğœ‹vrf =
chlg := ğ‘, resp :=
ğ›¼.resp, ğœ.resp
internally the challenge ğ‘ is involved.

)}
ğ‘ , â„

and

)}

))

(

(

, where

respectively, and return

3) Last return the output of veriï¬able random
ğ›½, stmt
)

and the proof of

function outvrf =
correctness ğœ‹vrf.

(

Fig. 4: Evaluation of Post-Quantum VRF via ZKBoo.

VrfVrfy of Post-Quantum VRF via ZKBoo.

â€¢

VrfVrfy

1) verify â„ ?= ğ»1 (

vpk, outvrf)
;
)

m

((

, m, ğœ‹vrf)

.

2) invoke the equality veriï¬cation of ZKBoo to

validate

stmt, ğœ‹vrf)

ZKP.Verifyğ» (
as depicted in Fig. 2 for relations
: ğ›¼ = F
LF =
k, ğ‘ 
ğ›¼, k; ğ‘ 
)}
{(
(
)
: ğœ = ğ»2 (
=
ğœ, â„; ğ‘ 
ğ‘ , â„
Lğ»2
{(
)}
stmt, ğœ‹vrf)
3) Return 1 if ZKP.Verifyğ» (

and

)

otherwise.

respectively;

= 1 holds, and 0

Fig. 5: Veriï¬cation of Post-Quantum VRF via ZKBoo.

message mâ€². Note that the correctness output of VRF outvrf
:= ğ›½ = ğ»3 (
ğœ
via VrfEval is computed as outvrf
for the
)
corresponding ğœ = ğ»2 (
vsk, â„ := ğ»1 (
. Since outvrfâ€² â‰  outvrf
m
))
(i.e., ğ›½ â€² â‰  ğ›½), we have ğœ â€² â‰  ğœ, where ğœ â€² := ğ»2 (
vsk, â„â€² := ğ»1 (
mâ€²))
vsk, â„ := ğ»1 (
and ğœ := ğ»2 (
for the same vsk. Now,
m
))
ğœ‹vrfâ€² =
chlgâ€², respâ€²)
for a challenge ğ‘ â€² and a response ğ‘§ â€²
(
= 1 supported by
vpk, outvrfâ€²)
, mâ€², ğœ‹vrfâ€²)
ensures that VrfVrfy
((
= 1 of the
stmt :=
, ğœ‹vrfâ€² =
ğ‘ â€², ğ‘§ â€²))
ğ›¼, ğœ â€², ğ›½ â€²)
the ZKP.Verifyğ» (
(
(
equality of ZKBoo system.
VrfVrfy
(Â·)
),
ğœ.ğ‘â€²(
, ğ›¼.ğ‘ (
) ,
ğ‘ â€²
, ğœ.ğ‘â€²(
)
Â· Â· Â·
Â· Â· Â·
â†
ğ‘–
ğ‘–
ğ‘–
ğ‘–
ğ‘–
ğ‘–
) =
ğ‘–
1 , ğ›¼.ct (
3 , ğ›¼.ct (
2 , ğ›¼.stmt(
1 , ğ›¼.stmt(
2 , ğ›¼.ct (
where ğ›¼.ğ‘ (
)
)
)
)
)
)
3 )
ğ‘–
ğ‘–
ğ‘–
ğ‘–
ğ‘–
, ğœ.ctâ€²(
, ğœ.stmtâ€²(
, ğœ.stmtâ€²(
, ğœ.ctâ€²(
, ğœ.ctâ€²(
and ğœ.ğ‘â€²(
)
)
)
)
3
2
3
2
1
Below, we use the extract ğ‘ â€² to perform validations as follows.
ğ‘ â€²(
ğ‘—
), ğ‘ â€²(
such
if
1
) +
âˆˆ
{
âˆ€
}
ğ‘–
ğ‘–
ğ›¼.ct (
, ğ›¼.view (
, ğ›¼.op (
Open
and
)ğ‘—
)ğ‘— } â†
)ğ‘— )
ğ‘–
ğ‘–
ğœ.ct (
, then continue;
Open
)ğ‘— )
)ğ‘—
)ğ‘— } â†
(
ğ‘–
ğ‘–
), ğ‘ â€²(
ğ‘ â€²(
ğ‘—
such that
) +
âˆƒ

ğ‘–
ğ›¼.tp (
that
)ğ‘—
{
ğ‘–
, ğœ.view(
ğœ.tp(
)ğ‘—
{
if
Otherwise,

ensures to extract the exact one challenge

ğ»
ğ›¼.ğ‘ (
ğ›¼.stmt (
ğ‘–

1) Firstly, validate

(
, ğœ.op (
1

(
ğœ.stmtâ€²(
1

âŠ¥ â†

âˆˆ {

) =

}

k

(

(

)

1

1

ğ‘¡

ğ‘¡

)

)

ğ‘–

ğ‘–

ğ‘–

ğ‘–

ğ‘–

8

ğ‘–

ğ‘–

(

(

ğ‘–
)ğ‘—

and

ğœ.ct (

ğ›¼.ct (

Open

, then

, ğ›¼.op (

, ğœ.op (

ğœ.stmt (

(
ğ‘–
1 , ğœ.stmt(
)

ğ‘–
Open
)ğ‘— )
)ğ‘—
abort the validation.
2) Then validate Rec

)ğ‘— )
âŠ¥ â†
?= ğ›¼.stmt
ğ‘–
ğ‘–
ğ‘–
ğ›¼.stmt (
2 , ğ›¼.stmt (
1 , ğ›¼.stmt (
)
)
)
3 )
?= ğœ.stmt, if pass the
ğ‘–
ğ‘–
and Rec
2 , ğœ.stmt (
)
)
3 )
validation, then continue the following validation; other-
wise, abort it.
), ğ‘ â€²(
3) Next, validate if
âˆƒ
ğ‘–
ğ‘–
Output
and ğœ.stmt(
)ğ‘—
)ğ‘—
)
continue; otherwise, then abort.

ğ‘–
such that ğ›¼.stmt (
)ğ‘—
, then

) +
}
?= Output

ğœ.view (

ğ›¼.view (

âˆˆ {

ğ‘ â€²(

?=

1

(

(

(

ğ‘—

ğ‘–

ğ‘–

ğ‘–

ğ›¼.w(

ğ‘’
)ğ‘—

and
?=

and

4) Finally,

validate

if

âˆ€
UpdF(
ğ‘’
ğœ.w(
)ğ‘—

ğœ.w(

âˆˆ
ğ‘—
âˆ’

ğ‘’
)ğ‘—
ğ›¼.view (
ğ‘’
?= UpdF(

âˆ€
ğœ.viewğ‘’ ,
ğ‘—

1

)

, ğ›¼.view(
ğ‘’
1

ğ‘—

âˆˆ
validate

then
1
1 , ğ›¼.tpğ‘’, ğ›¼.tpğ‘’
âˆ’
+
ğ‘—
, ğœ.view (
)
ğ‘’

)

1)
+
1
1 , ğœ.tpğ‘’, ğœ.tpğ‘’
âˆ’
+

ğ‘–

âˆ’

ğœ.view (
)
ğ‘’
5) output 1 if all validations are passed.
ğ‘–
is not identical to ğœ.ğ‘ (
vsk, â„ = ğ»1 (
mâ€²))

:=
Notably, ğœ.ğ‘â€²(
vsk, â„â€² = ğ»1 (
. In addition, ğ»2
ğ»2 (
is a random oracle, its output is random, and the probability
that it equals the unique value determined by its inputs
according that the right side of equation (4.1) is negligible.

) because of ğœ â€²
m

â‰  ğœ := ğ»2 (

;

1)

+

))

)

)ğ‘— )
ğ›¼.viewğ‘’

ğ›¼.w(

ğ‘’
)ğ‘—

ğ‘ = ğ»
?= ğ»

1

ğ›¼.ğ‘ (

) , ğ›¼.ğ‘ (

2

),

, ğ›¼.ğ‘ (

ğ‘¡

)

1

ğœ.ğ‘ (

, ğœ.ğ‘ (

ğ‘¡

)

(

)
ğœ.ğ‘â€²(
(4.1)
Hence, only one (i.e., ğ‘ â€² or ğ‘) satisï¬es the above validations.

Â· Â· Â·
ğ‘¡
, ğ›¼.ğ‘ (
)

, ğœ.ğ‘â€²(

ğ›¼.ğ‘ (

k
),

Â· Â· Â·

Â· Â· Â·

Â· Â· Â·

) ,

k

)

(

1

1

.

)

2

),

), ğœ.ğ‘ (
ğ‘¡

))

ğ‘„ 2

mâ€²)

vsk, ğ»1 (

vsk, ğ»1 (
m
)

m
and â„â€² = ğ»1 (

Thus, we have arrived at our contradiction.
Collision-Resistance Analysis. Below, we prove the property
of collision-resistance using a contradiction. If ğ»2 is a col-
ğœ-to-1) hash function that every output of
lision resistant
(
ğ»2 has at most ğœ preimage in ğ”¾, we assume that if there
happens a collision, then ğœ = ğ»2 (
should equal to
, where â„ = ğ»1 (
ğœ â€² = ğ»2 (
for
mâ€²))
some m â‰  mâ€². In this setting, for every â„, there are at most ğœ
possible â„â€² values that can cause a collision. Because â„ and â„â€²
are obtained via random oracle queries, then a pair that causes
a collision is unlikely to be found after ğ‘„ queries to ğ»1, as long
as the size of ğ”¾ is larger than ğœ
Â·
Pseudorandomness Analysis. Below we analyze the pseu-
dorandomness based on the collision-resistance hash func-
tion under the random oracle model. Depending on the
VRF deï¬nition, the pseudorandomness deï¬nition implies that
the pseudorandomness adversary does not know the secret
m, outvrf)
VRF key vsk, but must distinguish between pairs
where outvrf is the VRF hash output on input m, and pairs
where ğ‘Ÿ is a random value. This adversary knows the
m, ğ‘Ÿ
(
)
public values vpk = F
k, vsk
, and it can easily compute
)
ğœ = ğ»2 (
and â„ = ğ»1 (
vsk, â„
for any m if he knows the
m
)
vsk. However, even vpk and â„ are public but vsk is kept
privately, and ğœ = ğ»2 (
vsk, ğ»1 (
looks random, thus, the
pseudorandomness adversary cannot distinguish ğ›½
ğœ
)
from a randomness distribution because ğ›½0 is pseudorandom
in the range of ğ»3.

ğ»3 (

2.
/

â†

m

))

(

)

(

)

.

)

4.3 Post-Quantum VRF Evaluation

To evaluate the performance of VRF, we are primarily inter-
ested in understanding the time consumed in the generation
of the proposed signature followed by the hashing time and
the total time, including key generation, signing, proof of
zero-knowledge, veriï¬cation, and block formation, when the
number of blocks is considered as a part of the blockchain.

9

TABLE 3: Performance of Feasibly VRF via ZKBoo and ZKB++.

Scheme

KeyGen
Signing
Proof
Veriï¬cation

Scheme

KeyGen
Signing
Proof
Veriï¬cation

Scheme

KeyGen
Signing
Proof
Veriï¬cation

Scheme

KeyGen
Signing
Proof
Veriï¬cation

Scheme

ZKBoo
20-Round

ZKB++
20-Round

Output.Size

Execution.Time Output.Size

Execution.Time

256 bit
256 bit
245920 Byte
âœ—

< 1 ms
< 1 ms
24 ms
16 ms

256 bit
256 bit
128800 Bytes
âœ—

<1 ms
< 1 ms
24 ms
15 ms

40-Round

40-Round

Output.Size

Execution.Time Output.Size

Execution.Time

256 bit
256 bit
491840 Byte
âœ—

< 1 ms
< 1 ms
28 ms
18 ms

256 bit
256 bit
257600 Byte
âœ—

< 1 ms
< 1 ms
29 ms
17 ms

60-Round

60-Round

Output.Size

Execution.Time Output.Size

Execution.Time

256 bit
256 bit
737760 Byte
âœ—

< 1 ms
< 1 ms
35 ms
23 ms

256 bit
256 bit
386400 Byte
âœ—

< 1 ms
< 1 ms
36 ms
22 ms

80-Round

80-Round

Output.Size

Execution.Time Output.Size

Execution.Time

256 bit
256 bit
983680 Byte
âœ—

< 1 ms
< 1 ms
42 ms
28 ms

256 bit
256 bit
515200 Byte
âœ—

< 1 ms
< 1 ms
42 ms
25 ms

100-Round

100-Round

Output.Size

Execution.Time Output.Size

Execution.Time

KeyGen
Signing
Proof
Veriï¬cation

256 bit
256 bit
1249600 Byte
âœ—

< 1 ms
< 1 ms
50 ms
33 ms

256 bit
256 bit
644000 Byte
âœ—

< 1 ms
< 1 ms
50 ms
32 ms

To evaluate these overheads, we wrote a proof-of-concept
blockchain in C++. The developed code is evaluated on IntelÂ®
Coreâ„¢I5-8250U 8th Gen machine with 8GB RAM on an Asus
series workstation.

We provide implementations and experimental evalua-
tions of concrete quantum secure VRF using by integrating
the post-quantum zero-knowledge proof systems, such as
ZKBoo and ZKB++, as shown in Table 1. To our knowledge,
ZKBoo and ZKB++ are one of the hash-based NIZK protocols
known to exist in the random oracle model, it is based on the
â€œMPC-in-the-headâ€ approach to zero-knowledge, and it can
generate (resp. verify) a non-interactive proof for the SHA-1
circuit in approximately 13ms (resp. 5ms), with a proof size
of 444KB. In our realization, to simulate the real-world scene,
we used SHA-256 for hashing and was built on top of the
ZKBoo and ZKB++ 5. ZKBoo and ZKB++ libraries are used
to prove knowledge of pre-images of SHA-256. The following
Table 3 gives results for the execution time and output size
of key generation, signing, proof, and veriï¬cation, which is

5. (https://github.com/Sobuno/ZKBoo)

illustrated in terms of time consumed per hash operation, and
it presented as an average value after looping 100 times for all
the execution modes.

Notably, ZKB++ is an improved version of ZKBoo with
NIZK proofs that are less than half the size of ZKBoo proofs,
and it shows that this size reduction comes at no extra
computational cost. Similarly, in our proof-of-concept real-
ization, the output size of VRF realized via ZKB++ is more
than halved than VRF realized by ZKBoo, not affecting the
computational complexity. As shown in Table 3, regarding the
execution time of algorithms, such as block formation, key-
generation, and signing, each operation is in 1 millisecond,
because of which the value of microseconds doesnâ€™t make
any material difference. In addition, proof generation is the
dominant operation, which on average consumes more than
99.0% of the total execution time. Thus, we use the average
time in milliseconds to estimate the running time for these
sub-algorithms. These results help to understand the reach
of practical observations when such a system is deployed
in actual practice. The trade-off between the size and the

computational complexity will certainly require conï¬guration
considerations, and these results can help in understanding
such requirements.

5 APPLICATION 1: QUANTUM-SAFE DECENTRAL-
IZED RANDOM BEACON

A cryptographic beacon (also known as a randomness beacon)
is a service that provides a public source of randomness.
The beacon continuously emits new random data (a beacon
record) at a regular rate. If everybody agrees that thereâ€™s no
way to predict the following output from the beacon, it can
be relied on as a provider of fair random values. The random
values emitted by the beacon can trivially be used for any
public lottery, contract signing, voting protocols, and ZKP
systems, etc. These applications require random values that
cannot be predicted prior to being generated but are made
public after generation. Importantly, in the blockchain era,
many consensus protocols [6], [7], [39], [8] involve allocating
the creation of block creator, whose selection procedure most
often than not requires a method for collective randomness
sampling. Obliviously, random beacon also plays an integral
part in the design of new blockchain consensus protocols (e.g.,
PoS) for a fair and unpredictable distribution of validator
responsibilities. The basic reason is that each election begins
when public and unbiased random beacon publishes a uni-
form random number. Consequently, how to design the ver-
iï¬able, bias-resistant, and the unpredictable random number
has recently enjoyed increasing attention [4], [5], [42]. This
section gives our random beacon solution via the proposed
VRF while remaining secure in the quantum era.

5.1 Random Beacon Generation

An observation is that if blockchain nodes get different inputs
on building blocks, then forks will happen. Thus, to generate
uniform randomness, the most straightforward idea is to
obtain uniform randomness by hashing past blocks. But the
hashes of blocks can be subject to adversarial inï¬‚uence. For
example, the random number can be biased in a way so that
corrupted nodes are allowed to be selected more often. Thus,
no one can guarantee security when this kind of randomness
sources with adversarial bias are used for block proposer
selection.

To address this point, Snow White [6] proposed a novel
â€œtwo-lookbackâ€ mechanism to determine present and future
randomness depending on its own past blocks, which ad-
dresses this kind of aâ€œrandomness-biasing attacksâ€ and â€œadap-
tive key selection attacksâ€ simultaneously, but this approach
cannot guarantee perfect uniqueness for randomness as ex-
plained earlier. Ouroboros Paros randomness is secure for
block production [8] and inherits the incentive structure of
the Ouroboros family. In their approach, all block producers
have a VRF keys, which they register with locked stake,
and they depend on a central clock and operate a trusted
random beacon using VRF to board-cast a random num-
ber to all participants in each epoch. In Algorand [7], the
randomness (i.e., seed) published at round ğ‘Ÿ is determined
using VRF with the seed of the previous round ğ‘Ÿ
1, e.g.,
âˆ’
ğ‘ ğ‘‘ğ‘Ÿ = ğ»
is a deterministic

, where uSign

uSign

ğ‘Ÿ

(

ğ‘ ğ‘‘ğ‘Ÿ
(

1)k

âˆ’

)

ğ‘ ğ‘‘ğ‘Ÿ
(

1)

âˆ’

10

(Â·)

under the leader round ğ‘Ÿ, and the initial
signature uSign
value of the seed ğ‘ ğ‘‘0 bootstraps seed selection. However, the
problem is that Algorand does not specify how to initialize
ğ‘ ğ‘‘0.6 In that case, the participant who has set the initial seed
ğ‘ ğ‘‘0 may have again launched a grinding attack to bias the
blockchain consensus protocol.

Indeed, secret randomness produced by these VRFs can
determine when they produce new blocks. A priori, there is
a risk that block producers could grind via VRF keys to bias
results. Thus, VRF inputs must include public randomness
created only after the VRF key. Therefore, during the epoch,
the fresh public on-chain randomness is created by hashing
together all the VRF outputs revealed in block creation. In this
way, we cycle between private but veriï¬able randomness and
collaborative public randomness. But an observation is that
these kinds of approaches rely on a trusted party. To avoid
reliance on a trusted party, a common approach is to use a
mechanism that veriï¬ably allows the distributed computation
of an unpredictable and unbiased source of randomness. The
distributed VRFs are proposed recently, e.g., [42] a candidate
approach to bypass dependence on the central party. Addi-
tionally, how to construct a post-quantum distributed VRF
itself is an exciting research problem and deserves further
deep investigation.

5.2 Decentralized Random Beacon Generation

In this section, we resort to the distributed VRF from sym-
metric primitives to generate the quantum-safe decentralized
random beacon (DRB). Very recently, DRSs have recently gained
a lot of traction as a key component for leader(s) election in
decentralized public ledger technologies. Indeed, as discussed
in [42], a conventional DRB provides a way to agree on a
randomly chosen leader in a distributed approach for PoS
blockchains (e.g., Dï¬nity [39], Ethereum 2.0 [44], and Om-
niLedger [45]), without the need for a coordinator. Thus, in
this paper, following the research line of DRB, we give a
quantum-safe (veriï¬able) DRB approach. As we know, DRBs
are a particular case of veriï¬able multi-party computation
protocol, and they can be straightforwardly obtained from a
post-quantum (veriï¬able) distributed VRF.
Quantum-Safe DRB via Distributed VRF. Our goal is to pro-
vide a quantum-safe bias-resistant public randomness in the
familiar
-threshold security model in hash-based cryp-
tography and Byzantine consensus protocols. The quantum
security can be guaranteed by using hash-based cryptography,
as explained in the post-quantum VRF construction. Thus,
armed with these techniques, in our distributed-VRF based
DRB protocol, we consider the synchronous network where
messages are eventually delivered and a Byzantine adversary
-threshold security model. In this setting, we pick a
in
1 inputs, where ğ‘“ is denoted as the
function with ï¬xed ğ‘“
number of dishonest peers, ğ‘¡ = ğ‘“
1 is the threshold of
veriï¬able secret sharing, and ğ‘› = 3ğ‘“
1 is denoted as the list
of peers that participate in DRB protocol.

ğ‘¡, ğ‘›
(

ğ‘¡, ğ‘›
(

+
+

+

)

)

â€¢ (

vsk, vpk
â€“ Deal phase.

) â†

DVRF.DistKG

1ğœ†

(

)

6. In Algorand, the authors mentioned â€œa random number, part of the

system description, and thus publicly known.â€

0

=

ğ›¼ğ‘–,1ğ‘§

+ Â· Â· Â· +

mod ğ‘

ğ›¼ğ‘–,ğ‘¡ğ‘§ğ‘¡
(
2) The dealer ğ‘†ğ‘– selects a secret key vskğ‘– := ğ‘˜ğ‘– â†

1) The dealer (i.e., each node server) ğ‘†ğ‘– selects a ğ‘¡-
ğ‘¡
ğ‘§ğ‘˜ =
ğ‘˜=0 ğ›¼ğ‘–,ğ‘˜ Â·
ğ‘§
degree random polynomial fğ‘– (
)
Ã
over â„¤ğ‘ for ğ›¼ğ‘–,ğ‘˜ âˆˆ
â„¤ğ‘.
ğ›¼ğ‘–,0 +
)
â„¤ğ‘ and
sets ğ›¼ğ‘–,0 = fğ‘– (
:= vskğ‘–. Next, the dealer computes
)
the corresponding public key vpkğ‘–
and
secret key shares sskğ‘–, ğ‘— := fğ‘– (
ğ‘›. Then
the dealer ğ‘†ğ‘– broadcasts commitments cmtğ‘–,ğ‘˜ â†
= PRG
ğ›¼ğ‘–,ğ‘˜ Â·
ğ‘ ğ‘‘
ğ›¼ğ‘–,ğ‘˜)
of each coefï¬cient
Com
(
(
ğœ† for a
ğ›¼ğ‘–,ğ‘˜ for 1
0, 1
ğ‘¡ and the seed ğ‘ ğ‘‘
ğ‘˜
â‰¤
3ğœ†,
0, 1
pseudorandom generator PRG :
and a random ğ‘…

k, vskğ‘–)
(
ğ‘—
â‰¤

}
â†’ {

for 1

) âŠ• (

= F

0, 1

3ğœ†.

â‰¤

â‰¤

ğ‘…

}

)

)

ğ‘—

3) Output vpkğ‘–,

â€“ Reconstruction phase.

0, 1
âˆˆ {
sskğ‘–, ğ‘— (cid:9) ğ‘—

}
ğ‘›

âˆˆ [

(cid:8)

and

(cid:8)

]

â† {
ğœ†
{
}
cmtğ‘–,ğ‘˜ (cid:9)ğ‘˜

.

]

ğ‘¡
âˆˆ [

1) Validate
ğ‘¡
ğ‘˜=1 (
Ã

ğ‘¡
ğ‘—ğ‘˜
cmtğ‘–,ğ‘˜ ) Â· (
ğ‘˜=1(
Ã
= PRG
ğ‘—ğ‘˜
cmtğ‘–,ğ‘˜ ) Â· (
)
2) Compute vskğ‘– =
keep it privately.

?= PRG
ğ‘…
ğ‘“ğ‘– (
ğ‘ ğ‘‘
as
)
(
) âŠ• (cid:0)
(cid:1)
ğ‘¡
ğ‘…(cid:17).
ğ‘˜=1 ğ›¼ğ‘–,ğ‘˜ Â·
ğ‘ ğ‘‘
) âŠ• (cid:16)(cid:0) Ã
(
=
ğ‘–
QUAL ğ‘“ğ‘— (
QUAL sskğ‘–, ğ‘— and
ğ‘—
Ã
3) Output the veriï¬cation key vvkğ‘– = F

ğ‘—
) Â·
ğ‘—ğ‘˜
(cid:1) Â·

Ã

)

âˆˆ

âˆˆ

ğ‘—

(
QUAL F

k, vskğ‘– )
(

and the
=

k, vskğ‘– )

)
vskğ‘–, â„

.
)
stmt; wits

âˆˆ

Ã‰ğ‘–

k, vskâˆ—

QUAL vskğ‘– )

= F
)
DVRF.PartialEval

common public key vpkâˆ— =
.
F
ğ‘–
(Ã
ğœ‹vrf, outvrf) â†
vskğ‘–, vvkğ‘–, m
â€¢ (
(
and outvrfğ‘– := ğ‘£ğ‘– = ğ»2 (
1) Compute â„ = ğ»1 (
)
2) Execute the quantum-safe ZKP Proveğ» (
:= ğ‘£ğ‘–

m

(

âˆˆ

(

:=

, vvkğ‘–

vskğ‘–, â„

for stmt

k, vskğ‘– ))

â„, outvrfğ‘– = ğ»2 (
(
: vvkğ‘– := F

to prove outvrfğ‘–
vskğ‘–
F
lations

)
is the correct output given
:=
and wits := vskğ‘– . In particular, two re-
k, vskğ‘–)o and
)o are pro-
Lğ»2
ceeded respectively, as depicted in Fig.1. Then re-
turn a computation integrity proof ğœ‹vrfğ‘– =
:=
ğ‘–, chlgğ‘–
(
ğ‘ğ‘–, respğ‘–
, where internally
the challenge ğ‘ğ‘– is involved.

LF =
n(
outvrfğ‘–, â„; vskğ‘–)
n(

: outvrfğ‘– := ğ»2 (

vvkğ‘– .resp, outvrfğ‘– .resp

vvkğ‘–, k; vskğ‘– )

(
vskğ‘–, â„

:=

))

=

(

)

â€¢

â€¢

ğœ€

DVRF.Combine
(
1) Parse list ğœ€ =

vpkâˆ—, vvkâˆ—, m, ğœ€
nğœ‹vrf ğ‘—1, ğœ‹vrf ğ‘—2,

.

)

2) Then,

|

|

ğ›½

ğ‘¡

+

Ã

Â· Â· Â·

Â· Â· Â·

|ğœ€ |

, ğœ‹vrf ğ‘—

| â‰¥

o of

, vvkğ‘—

ğœ€
âˆˆ [ |
ğ‘–1,
{

. Notably, vvkâˆ— =
ğ¼ =

|ğœ€ |
identify an index subset

|]
Â· Â· Â·
it satisï¬es the veriï¬cation of ZKP,

such that
ZKP.Verifyğ» (
for
relations
ZKP.Verifyğ» (
every ğ‘–
âˆˆ
the next step. If no such subset exists, outputs 0.

1
partial function evaluation candidates originating from
ğœ€
different servers, and obtains veriï¬cation keys
|
vvkğ‘—1, vvkğ‘—2,
vvkğ‘—ğ›½ .
, ğ‘–ğ‘¡
1}
+
i.e.,
2
If
and
Lğ»2
= 1 (i.e., accept) holds for
ğ‘–, chlgğ‘–, respğ‘– )
, then continue
(
= ğ»2 (
vskâˆ—, â„
m
)
can be done from the shares of any qualiï¬ed set QUAL
of participants by calculating the Lagrange interpola-
tion ğ‘£âˆ— =
and
vskğ‘– =
ğ‘—

stmt, ğœ‹vrf)
LF
stmt, ğœ‹vrf)
ğ¼ , where ğœ‹vrf =

as depicted in Fig.
respectively.

for â„ = ğ»1 (

vskğ‘–, â„

))

)

âˆˆ

ğ‘—

3) Reconstruct outvrfâˆ— := ğ‘£âˆ— (

âˆˆ

âˆˆ

Ã

, where ğ‘£ğ‘– = ğ»2 (
ğœ†0,ğ‘–,ğ¼ )
ğ‘£ğ‘– Â·
ğ‘–
ğ¼ (
Ã
=
ğ‘–
QUAL ğ‘“ğ‘— (
QUAL sskğ‘–, ğ‘— .
)
Ã
ğœ‹vrfğ‘– }ğ‘–
4) Output ğ‘£âˆ— and ğœ‹vrfâˆ— â† {
ğ¼ .
DVRF.Vrfy
vpkâˆ—, vvkâˆ—, m; ğœ‹vrfâˆ—)
(
1) Parse ğœ‹vrfâˆ— =
{
ğ‘–, chlgğ‘–, respğ‘– )
(

ğ¼ such that
ğ¼ .
stmt, ğœ‹vrf)
2) Validate ZKP.Verifyğ» (

ğœ‹vrfğ‘– }ğ‘–
âˆˆ
for ğ‘–
âˆˆ

= ğ‘¡

+

âˆˆ

ğ¼

|

1, where ğœ‹vrf =

|
?= 1 by revoking the

11

âˆˆ

ğ¼ (

ğ‘–
Ã

veriï¬cation Verifyğ» (Â·)
?=
ğ‘£ğ‘– Â·

of the quantum-resistant ZKP.
ğœ†0,ğ‘–,ğ¼ )
3) Check if ğ‘£âˆ—
.
Our proposed unbiasable quantum-safe DRB protocol
ensures the properties quantum security, unbiasability, unpre-
dictability, and availiability. Additionally, the proposed DRB
is practical as it only depends on hash-based functions with
small scale communication overhead. The post-quantum se-
curity is clear because the unbiasable quantum-safe DRB is
based on the post-quantum VRF, so we ignore the detailed
analysis. Below, we give a high-level analysis for the other
properties.

â€¢

â€¢

â€¢

ğ‘“

+

+

Unpredictability implies that no party (includes the ad-
versarial nodes) could predict (or precompute) anything
about the future random output values. If the participants
follow the DRB protocol, the ï¬nal random number ğ‘£âˆ—
contains ğ‘›â€² â‰¥
1 secrets. We require there are at most
ğ‘“ malicious peers. Thus an adversary cannot obtain the
underlying secret before it is revealed or recovered during
the speciï¬c round. Please refer to [5, Theorem 3] for
details.
Availability (also known as liveness) implies that no single
party (including the colluding adversary) is allowed to
prevent progress. The property is obtained because if the
threshold ğ‘¡ = ğ‘“
1 of the veriï¬able secret-sharing is given,
then at least ğ‘¡ honest nodes out of the total 2ğ‘“
1 positive
voters are able to collaborate to recover the secrets.
Unbiasability means a random beacon value is statistically
indistinguishable from a uniformly random. Notably, the
threshold of veriï¬able secret sharing ğ‘¡ = ğ‘“
1 is given
in advance, preventing dishonest participants from re-
covering the honest secrets. If at least ğ‘¡ honest partic-
ipants share messages successfully, then the Byzantine
agreement (with at least 2ğ‘“
1 participants) will achieve
+
the validity of these shares as discussed in availability. In
this case, each honest participant could recover othersâ€™
secret shares. Further, the Byzantine agreement ensures
that all honest participants generate a consistent copy
of the randomness number. Thus ğ‘›â€² > ğ‘“ secrets will be
ğ‘“ , meaning the
recovered after the barrier point or ğ‘›â€² â‰¤
protocol fails. Thus, we say the protocol is to prevent the
adversary from biasing the random output.

+

+

6 APPLICATION 2: QUANTUM-SAFE PROOF OF
STAKE CONSENSUS PROTOCOL

Obtaining the quantum-safe blockchain straightforwardly
from the existing PoW and PoS is non-trivial because the
existence of blockchain consensuses, including PoW and PoS,
are designed upon the traditional hard-problem assumptions
(i.e., cryptographic puzzles) without the property of quantum
resistance. In essence, PoS consensus protocols (e.g., Snow
White [6], DFINITY [39], and Algorand [7] etc) are similar
to PoW protocols to some extent, because they are from
proof systems, and the participants elect the creator who can
create the next block. In particular, regarding chain-based
leader election in PoS consensus, Ouroboros [40] replaces
energy-consuming cryptographic puzzles by ï¬nding a solu-
tion (i.e., ğœğ‘– = Signğ‘ ğ‘˜ğ‘– (
to satisfy the veriï¬cation
= 1 for the state stğ‘– =
requirement of Vrfyğ‘ğ‘˜ğ‘– (

stğ‘–, dtğ‘–, slotğ‘— ))
ğœğ‘–,

stğ‘–, dtğ‘–, slotğ‘— ))

(

(

âˆ’

Bğ‘–

1)

ğ»
, where the signature is the existential unforgeability
under chosen message attack resistance scheme. Similarly,
the lottery-based consensus mechanism (e.g., Algorand [7])
is based on a fast Byzantine agreement protocol, and the
agreement is not performed between all users in the network.
Instead, it is conï¬ned to a small randomly chosen committee
of users for each round. Algorand pioneered the use of VRF
for secret encryption and lottery to run a consensus agree-
ment with the election committee. This enables the Algorand
blockchain to achieve the scale and performance required
to support millions of users. The core election process in
< T,
Algorand [7] can be expressed as VRF
where the signature ğœ is a result of a (valid) payment pay
relative to the stake (or the transfer amounts of money units)
ğ‘. In that case, we explore the utility of the proposed quantum-
secure VRF in the lottery-based Algorand.

, round, ğ‘ğ‘˜, ğœ

Bğ‘– )

â„
(

(

)

To obtain the quantum-safe PoS, we trim the quantum-
secure VRF inequality by denoting the difï¬culty value dynam-
ically as the product of the stake owned by each elector and
the target value ï¬xed by the system. Further, following the
methodology of Algorand, every user performs secret self-
selection based on his/her VRF secret key for each block. If
the quantum-secure VRF value that the user obtains is less
than some threshold, then the user is selected to serve on the
committee to perform an agreement for the block. Then, in
each round, each node needs to check to evaluate a quantum-
secure VRF to check whether they have been sampled as part
of that roundâ€™s committee. The number of committee mem-
bers is binomial (i.e., depending on the stake distribution), so
the amount of work that needs to be done to verify the other
committee membersâ€™ messages is also binomial.

(

k

vsk

stakes
)

Evaluation of Transaction. We implement a proof of concept
of our scheme to compare against the Algorand VRF. Our
evaluation indicates that our construction does not introduce
any prohibitive overheads, further, the proposed constructions
are practiced even today. For instance, the transmission of the
overhead introduced per every block is an additional 824KB
which accounts for around 8% of the 10MB Algorand block
size. To evaluate the block formation for quantum-secure
PoS consensus, when the number of blocks is considered
as a part of the blockchain. The prover program takes as
input the secret key and simulated stakes, then the prover
program will generate the proof of computation of ğ»
vsk
)
and ğ»
using ZKBoo or ZKB++. In our proof of
concept implementation, proof generation using ZKB++ takes
an additional 61 milliseconds overhead when comparing with
the Algorand VRF. Meanwhile, the veriï¬er will check the
proof to be sure that the prover knows the pre-image of vsk
and owns stakes. Notably, the veriï¬cation step is the most
time-consuming part. In PoS-blockchain, the results will vary
as per the number of rounds of ZKBoo (or ZKB++) used
in each round of every epoch in the underlying protocol.
This can be understood in Table 3, which shows that with
additional rounds, the security will increase for a system using
either of the approaches. There is a trade-off that for every
epoch in PoS, the rounds of ZKBoo (or ZKB++) will also
cause execution overheads. However, given the advantages of
security and not so tighter impact on the performance, these
solutions can be considered for implementing quantum-safe

(

12

blockchains.

We emphasize that designing a practical post-quantum
VRF for quantum-safe PoS consensus is an important urgent
open problem. First of all, blockchain systems should be
long-lived by design. From their current deployments, we
know that any (even purely technical) protocol-level change
is challenging to be introduced in practice and may result in
a platform fork, where part of the community â€œbelievesâ€ in
the old system (without the change) and other parts in the
new system (with the change applied).7 Secondly, due to their
potential and promises, the security of blockchain systems
should be treated critically. Even though one could argue that
quantum computing is not a short-term threat, we stress that
due to deployability and governance of these systems it may
be challenging to update them in the future.

7 CONCLUSION

The focus of this work is to explore the probability of how
to design a post-quantum random beacon and PoS consensus
layer. Therefore, the crux of fulï¬lling the main goal is turning
into how to construct a practical post-quantum VRF. Inspired
by the relationship between the unique signature and VRF, we
started with the quantum-resistant hash-based signature and
integrated the signature with the post-quantum ZKP system
to obtain a post-quantum VRF. More speciï¬cally, a quantum-
resistant PoS consensus framework is instantiated with our
proposed post-quantum VRF by combining the hash func-
tions and quantum-secure ZKP from symmetric primitives.
Furthermore, we rigorously analyzed and proved the security
of our construction. Additionally, we implemented a proof of
concept of the system supported by the ZKBoo and ZKB++,
and our conducted experiments indicate that the scheme is
deployable even as for today.

Notably, deï¬ning the application layer and its security is
out of scope for this work. However, in the future, we would
like to extend our system by a post-quantum application
layer, where user transactions are also guaranteed quantum-
resistant without introducing prohibitive overheads. Further,
we just provided a proof-of-concept realization. The existing
post-quantum ZKP system can be used in our VRF construc-
tion, such as Ligero and ZK-STARK. We leave these works in
the future.

REFERENCES

[1] H. Wang, Q. Wang, and D. He, â€œBlockchain-based private provable
data possession,â€ IEEE Transactions on Dependable and Secure Comput-
ing, pp. 1â€“1, 2019, dOI: 10.1109/TDSC.2019.2949809.

[2] X. Li, J. Xu, X. Fan, Y. Wang, and Z. Zhang, â€œPuncturable signa-
tures and applications in proof-of-stake blockchain protocols,â€ IEEE
Transactions on Information Forensics and Security, pp. 1â€“1, 2020, dOI:
10.1109/TIFS.2020.3001738.

[3] L. Chen, L. Chen, S. Jordan, Y.-K. Liu, D. Moody, R. Peralta,
R. Perlner, and D. Smith-Tone, Report on post-quantum cryptography.
US Department of Commerce, National Institute of Standards and
Technology, 2016.
I. Cascudo and B. David, â€œSCRAPE: scalable randomness attested
by public entities,â€ in Proc. ACNS 2017, D. Gollmann, A. Miyaji, and
H. Kikuchi, Eds., vol. 10355, 2017, pp. 537â€“556.

[4]

7. In fact, such forks happened to mainstream platforms like Bitcoin or

Ethereum.

13

[28] E. Alkim, P. S. L. M. Barreto, N. Bindel, P. Longa, and J. E. Ricardini,
â€œThe lattice-based digital signature scheme qtesla,â€ IACR Cryptology
ePrint Archive, Report2019/85, 2019, https://eprint.iacr.org/2019/085.
J. Rijneveld, S. Samardjiska, and
P. Schwabe, â€œFrom 5-pass mq-based identiï¬cation to mq-
based signatures,â€ in Proc. Asiacrypt 2016, 2016, pp. 135â€“165,
http://cryptojedi.org/papers/#mqdss.

[29] M.-S. Chen, A. H Â¨ulsing,

[30] M. Chen, W. Li, B. Peng, B. Yang, and C. Cheng, â€œImplementing 128-
bit secure MPKC signatures,â€ IEICE Transactions, vol. 101-A, no. 3,
pp. 553â€“569, 2018, http://eprint.iacr.org/2017/636.

[31] T. Espitau, P. Fouque, B. GÂ´erard, and M. Tibouchi, â€œLoop-abort faults
on lattice-based ï¬at-shamir and hash-and-sign signatures,â€ in Proc.
SAC 2016, 2016, pp. 140â€“158.

[32] T. G Â¨uneysu, V. Lyubashevsky, and T. P Â¨oppelmann, â€œPractical lattice-
based cryptography: A signature scheme for embedded systems,â€ in
Proc. CHES 2012, 2012, pp. 530â€“547.

[33] D. J. Bernstein, D. Hopwood, A. H Â¨ulsing, T. Lange, R. Niederhagen,
L. Papachristodoulou, M. Schneider, P. Schwabe, and Z. Wilcox-
Oâ€™Hearn, â€œSPHINCS: practical stateless hash-based signatures,â€ in
Proc. EUROCRYPT 2015, Part I, 2015, pp. 368â€“397.

[34] D. J. Bernstein, C. Dobraunig, M. Eichlseder, S. Fluhrer, S.-L. Gazdag,
A. H Â¨ulsing, P. Kampanakis, S. KÂ¨olbl, T. Lange, M. M. Laurid-
sen, F. Mendel, R. Niederhagen, C. Rechberger, J. Rijneveld, and
P. Schwabe, â€œSphincs+,â€ in SPHINCS+, 2017.

[35] D. Boneh, S. Eskandarian, and B. Fisch, â€œPost-quantum EPID signa-
tures from symmetric primitives,â€ in Proc. CT-RSA 2019, 2019, pp.
251â€“271.

[36] Y. Ishai, E. Kushilevitz, R. Ostrovsky, and A. Sahai, â€œZero-knowledge
from secure multiparty computation,â€ in Proc. 39th ACM STOC 2007,
2007, pp. 21â€“30.

[37] M. O. Rabin, â€œTransaction protection by beacons,â€ J. Comput. Syst.

Sci., vol. 27, no. 2, pp. 256â€“267, 1983.

[38] R. Dingledine, N. Mathewson, and P. F. Syverson, â€œTor: The second-
generation onion router,â€ in Proc. 13th USENIX 2004. USENIX, 2004,
pp. 303â€“320.

[39] T. Hanke, M. Movahedi, and D. Williams, â€œDï¬nity technol-
system,â€ in arxiv.org, 2018,

consensus

ogy overview series
https://arxiv.org/pdf/1805.04548.pdf.

[40] A. Kiayias, A. Russell,
â€œOuroboros: A provably
protocol,â€ in Proc. CRYPTO 2017, Part
https://eprint.iacr.org/2016/889.pdf.

B. David,
secure

proof-of-stake

and R. Oliynykov,
blockchain
I, 2017, pp. 357â€“388,

[41] P. Schindler, A. Judmayer, N. Stifter, and E. R. Weippl, â€œHydrand: Ef-
ï¬cient continuous distributed randomness,â€ in 2020 IEEE Symposium
on Security and Privacy, SP 2020, San Francisco, CA, USA, May 18-21,
2020.

IEEE, 2020, pp. 73â€“89.

[42] D. Galindo, J. Liu, M. Ordean, and J.-M. Wong, â€œFully distributed
veriï¬able random functions and their application to decentralised
random beacons,â€ Cryptology ePrint Archive, Report 2020/096,
2020.

[43] S. Goldberg, M. Naor, D. Papadopoulos, and L. Reyzin, â€œNSEC5 from
elliptic curves: Provably preventing DNSSEC zone enumeration with
shorter responses,â€ IACR Cryptology ePrint Archive, vol. 2016, p. 83,
2016.

[44] V. Buterin, â€œEthereum 2.0 mauve paper,â€ 2018. [Online]. Available:

https://wiki.polkadot.network/docs/en/learn-randomness

[45] E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly, E. Syta, and
B. Ford, â€œOmniledger: A secure, scale-out, decentralized ledger via
sharding,â€ in Proc. IEEE SP 2018.
IEEE Computer Society, 2018, pp.
583â€“598.

[5] E. Syta, P. Jovanovic, E. Kokoris-Kogias, N. Gailly, L. Gasser, I. Khofï¬,
M. J. Fischer, and B. Ford, â€œScalable bias-resistant distributed ran-
domness,â€ in Proc. IEEE SP 2017.
IEEE Computer Society, 2017, pp.
444â€“460.

[6] P. Daian, R. Pass, and E. Shi, â€œSnow white: Robustly reconï¬gurable
consensus and applications to provably secure proofs of stake,â€ in
Proc. FC 2019, 2019.
S. Micali, â€œALGORAND: the efï¬cient and democratic ledger,â€ CoRR,
abs/1607.01341, 2016, http://arxiv.org/abs/1607.01341.

[7]

[8] B. David, P. Gazi, A. Kiayias, and A. Russell, â€œOuroboros praos: An
adaptively-secure, semi-synchronous proof-of-stake blockchain,â€ in
Proc. EUROCRYPT 2018, Part II, 2018, pp. 66â€“98.

[9] M. Chase, D. Derler, S. Goldfeder, C. Orlandi, S. Ramacher,
C. Rechberger, D. Slamanig, and G. Zaverucha, â€œPost-quantum zero-
knowledge and signatures from symmetric-key primitives,â€ in Proc.
ACM SIGSAC CCS 2017, 2017, pp. 1825â€“1842.

[10] J. Katz, V. Kolesnikov, and X. Wang, â€œImproved non-interactive zero
knowledge with applications to post-quantum signatures,â€ in Proc
ACM SIGSAC CCS 2018, 2018, pp. 525â€“537.

[11] E. Kiltz, V. Lyubashevsky, and C. Schaffner, â€œA concrete treatment
of ï¬at-shamir signatures in the quantum random-oracle model,â€ in
Proc. EUROCRYPT 2018, Part III, vol. 10822, 2018, pp. 552â€“586.

[12] D. Papadopoulos, D. Wessels, S. Huque, M. Naor,

J. VË‡celÂ´ak,
L. Reyzin, and S. Goldberg, â€œMaking nsec5 practical
for
dnssec,â€ Cryptology ePrint Archive, Report 2017/099, 2017,
https://eprint.iacr.org/2017/099.

[13] S. Goldwasser and R. Ostrovsky, â€œInvariant signatures and non-
interactive zero-knowledge proofs are equivalent (extended ab-
stract),â€ in Advances in Cryptology - CRYPTO 1992, 1992, pp. 228â€“245.
[14] S. Micali, M. O. Rabin, and S. P. Vadhan, â€œVeriï¬able random func-

tions,â€ in Proc. 40th FOCS 1999, 1999, pp. 120â€“130.

[15] L. Kohl, â€œHunting and gathering - veriï¬able random functions from
standard assumptions with short proofs,â€ in Proc. PKC 2019, Part II,
vol. 11443, 2019, pp. 408â€“437.

[16] S. Yamada, â€œAsymptotically compact adaptively secure lattice ibes
and veriï¬able random functions via generalized partitioning tech-
niques,â€ in Proc. CRYPTO 2017, Part III, vol. 10403, 2017, pp. 161â€“193.
[17] M. Buser, R. Dowsley, M. F. Esgin, S. K. Kermanshahi, V. Kuchta,
J. K. Liu, R. Phan, and Z. Zhang, â€œPost-quantum veriï¬able random
function from symmetric primitives in pos blockchain,â€ IACR
Cryptol. ePrint Arch., vol. 2021, p. 302, 2021. [Online]. Available:
https://eprint.iacr.org/2021/302

[18] I. Giacomelli, J. Madsen, and C. Orlandi, â€œZkboo: Faster zero-
knowledge for boolean circuits,â€ in Proc. 25th USENIX Security 2016,
2016, pp. 1069â€“1083.

[19] S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam, â€œLigero:
Lightweight sublinear arguments without a trusted setup,â€ in Proc.
ACM SIGSAC CCS 2017, 2017, pp. 2087â€“2104.

[20] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev, â€œScalable,
transparent, and post-quantum secure computational
integrity,â€
IACR Cryptology ePrint Archive, vol. 2018, p. 46, 2018. [Online].
Available: http://eprint.iacr.org/2018/046

[21] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P.
Ward, â€œAurora: Transparent succinct arguments for R1CS,â€ in Proc.
EUROCRYPT 2019, 2019, pp. 103â€“128.

[22] J. Bootle, A. Cerulli, E. Ghadaï¬, J. Groth, M. Hajiabadi, and S. K.
Jakobsen, â€œLinear-time zero-knowledge proofs for arithmetic circuit
satisï¬ability,â€ in Proc. ASIACRYPT 2017, 2017, pp. 336â€“365.

[23] M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn, â€œSonic:
Zero-knowledge snarks from linear-size universal and updatable
structured reference strings,â€ IACR Cryptol. ePrint Arch., vol. 2019,
p. 99, 2019. [Online]. Available: https://eprint.iacr.org/2019/099
[24] L. Ducas, V. Lyubashevsky, and T. Prest, â€œEfï¬cient identity-based
encryption over NTRU lattices,â€ in Proc. ASIACRYPT 2014, Part II,
2014, pp. 22â€“41.

[25] L. Ducas, A. Durmus, T. Lepoint, and V. Lyubashevsky, â€œLattice
signatures and bimodal gaussians,â€ in Proc. CRYPTO 2013, Part I,
2013, pp. 40â€“56.

[26] P.-A. Fouque, J. Hoffstein, P. Kirchner, V. Lyubashevsky, T. Pornin,
T. Prest, T. Ricosset, G. Seiler, W. Whyte, and Z. Zhang, â€œFalcon:
Fast-fourier lattice-based compact signatures over ntru,â€ in falcon-
sign, 2017, https://falcon-sign.info/.

[27] L. Ducas, E. Kiltz, T. Lepoint, V. Lyubashevsky, P. Schwabe, G. Seiler,
and D. StehlÂ´e, â€œCrystals-dilithium: A lattice-based digital signature
scheme,â€ IACR Trans. Cryptogr. Hardw. Embed. Syst., vol. 2018, no. 1,
pp. 238â€“268, 2018.

