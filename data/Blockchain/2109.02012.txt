1
2
0
2

p
e
S
5

]

R
C
.
s
c
[

1
v
2
1
0
2
0
.
9
0
1
2
:
v
i
X
r
a

1

Post-Quantum VRF and its Applications in
Future-Proof Blockchain System

Zengpeng Li, Teik Guan Tan, Pawel Szalachowski, Vishal Sharma, and Jianying Zhou

Abstract—A veriﬁable random function (VRF in short) is a powerful pseudo-random function that provides a non-interactively public
veriﬁable proof for the correctness of its output. Recently, VRFs have found essential applications in blockchain design, such as random
beacons and proof-of-stake consensus protocols. To our knowledge, the ﬁrst generation of blockchain systems used inherently inefﬁcient
proof-of-work consensuses, and the research community tried to achieve the same properties by proposing proof-of-stake schemes where
resource-intensive proof-of-work is emulated by cryptographic constructions. Unfortunately, those most discussed proof-of-stake
consensuses (e.g., Algorand and Ouroborous family) are not future-proof because the building blocks are secure only under the classical
hard assumptions; in particular, their designs ignore the advent of quantum computing and its implications. In this paper, we propose a
generic compiler to obtain the post-quantum VRF from the simple VRF solution using symmetric-key primitives (e.g., non-interactive
zero-knowledge system) with an intrinsic property of quantum-secure. Our novel solution is realized via two efﬁcient zero-knowledge
systems ZKBoo and ZKB++, respectively, to validate the compiler correctness. Our proof-of-concept implementation indicates that even
today, the overheads introduced by our solution are acceptable in real-world deployments. We also demonstrate potential applications of a
quantum-secure VRF, such as quantum-secure decentralized random beacon and lottery-based proof of stake consensus blockchain
protocol.

Index Terms—Future-Proof Blockchain, Post-Quantum, Veriﬁable Random Function, Random Beacon Protocol, Proof-of-Stake
Consensus.

✦

1 INTRODUCTION

Public distributed ledgers constitute a new class of systems.
Recently they gained a lot of attention from academic and
industry researchers, various businesses, governments, and
other organizations, e.g., [1], [2]. Thanks to distributed and
authenticated append-only data structures, these systems
provide transparency, availability, and censorship resistance.
However, the main novelty and breakthrough introduced by
public distributed ledgers is a consensus protocol that is
open to anyone and does not require any privileged entities.
Currently, a lot of attention is attracted by proof of stake
(PoS) blockchains, which solve the energy inefﬁciency of proof
of work (PoW) protocols. Instead of holding a PoW-based
competition to decide who is the round leader (adding a
block of transactions), in PoS systems, a leader is chosen via
a cryptographic lottery from available network nodes, with
their chances of winning is proportional to the number of
coins they hold.

A worrying trend in the blockchain community is to ig-
nore security lessons learned from the previous designs and
deployments of critical systems. It especially concerns as if
adopted, and blockchains are supposed to “provide trust” and
be long-lived. Thus their security is critical. Besides common
security threats, some potential risks can be foreseen. One

•

•

•

Z. Li is with the Shandong University Qingdao Campus, China. (E-mail:
zengpeng@email.sdu.edu.cn.)
T.G. Tan, P. Szalachowski and J. Zhou are with the Singapore University
of Technology and Design, Singapore. (E-mail: {pawel, teikguan tan, jiany-
ing zhou}@sutd.edu.sg.)
V. Sharma
mail: v.sharma@qub.ac.uk.)

the Queen’s University Belfast, UK,

is with

(E-

of the most severe is the advent of quantum computing
as a functional quantum computer could easily undermine
the security of the most distributed ledgers, making them
practically useless. Although, quantum computing is still a
premature organization, like NIST and Google, they concern
about post-quantum cryptographic methods to mitigate risk
for quantum computer destruction [3]. We do not see such a
trend in the blockchain community, however.

Additionally, many consensus protocols involve allocating
the creation of block creator, whose selection procedure, most
often than not, requires a method for collective randomness
sampling. To our knowledge, computers are based on a Turing
machine that is a deterministic device, and the same input
seed always produces the same output sequence. Thus, com-
puters are bad at the generation of randomnesses, and their
outputs are pseudo-random. During the randomness sam-
pling, adversarially biased hashes (known as grinding attacks
or randomness-biasing attacks) imply that a (malicious) miner
can re-create a block multiple times until it is likely that the
miner can create a second block shortly afterward. In other
words, the adversary can bias the nonce that is used to seed
the hash since the adversary can place arbitrary seeds in the
blocks it contributes.

Indeed, randomness-biasing (or grinding) attacks can be
mitigated (even thwarted) by ensuring that a miner is not
able to inﬂuence the next leader election by using an unbiased
source of randomness or a deterministic leader election. Obliv-
iously, real-world entropy is not suitable for use as a seed for
blockchain randomness [4], [5]. In reality, there are two main
approaches to blockchain randomness in production, one is
the novel approach of “two-lookback” mechanism proposed

 
 
 
 
 
 
1, e.g., 𝑠𝑑𝑟 = 𝐻

by Snow White [6], another is using the veriﬁable random
function (VRF) such as Algorand [7] and Ouroboros Praos [8],
etc, or using RANDAO supported by veriﬁable delay function
(VDF). Concretely, the randomness (i.e., seed) published at
round 𝑟 is determined using a deterministic hashing function
with the preceding randomness from 2𝜆 to 𝜆 in Snow White.
Similarly, in Algorand, the randomness (i.e., seed) published at
round 𝑟 is determined using VRF with the seed of the previous
round 𝑟
𝑟
, and the initial value of the
1 k
seed 𝑠𝑑0. The uniqueness of the pseudorandom output of VRF
enhances the bias resistance, as it stands against any adversary
independently from the number of corrupted servers that the
adversary controls. However, Snow White only achieves a
weak uniqueness with some tolerable errors, supported by
strict requirements for the participants. An important observa-
tion is that these mentioned VRFs are based on non-quantum-safe
hardness assumptions so that they can not remain secure in the
quantum computing era. Thus, the observations as mentioned
above promote us to ask the following question.

𝑠𝑑𝑟
(

−

−

)

Is it possible to propose a post-quantum veriﬁable random
function that beneﬁts random beacon and proof of stake
consensus protocol in the coming quantum era?

Contributions and Technical Route.This question can be
answered in the afﬁrmative. In other words, our goal is to ex-
plore how to remain secure for the PoS blockchain consensus
in the quantum era. Inspired by recent PoS-based blockchain
systems [7], [8] and quantum-resistant cryptographic primi-
tives [9], [10], the crux of fulﬁlling the main goal is turning
into how to construct an efﬁcient post-quantum VRF based
on the existing quantum-secure cryptographic primitives, e.g.,
symmetric-based cryptographic building blocks. The main
reason is that the uniqueness of the pseudorandom output of
VRF enhances the bias resistance and beneﬁts cryptographic
lottery-based proof of stake consensus protocol.

Very recently, Kiltz et al. [11] have provided determin-
istic signatures that are secure under the standard chosen
message attack in the quantum random oracle model, which
is obtained via Fiat-Shamir transformation, a paradigm of
combining a hash function and an identiﬁcation scheme to
produce a digital signature scheme. Kiltz et al. [11] also pro-
vide a practical instantiation of a signature scheme, Dilithium-
QROM, with a tight security reduction in the QROM from the
Module-LWE assumption over the lattice. Although various
lattice-based pseudorandom functions (in short PRFs) are
proposed in succession, these PRFs are not enabling to achieve
the public veriﬁability and guarantee to play the role of the
traditional 𝐻
in the large-scale network due to the overhead
(·)
they introduce.

2

•

•

revealing vsk). Thus, we effectively have a deterministic
output with uniqueness functionality.
Post-Quantum Random Beacon via proposed VRF. To
prevent the adversary from predicting who is the follow-
ing block creator while remaining secure in the quantum
era, we offer a quantum-safe decentralized random bea-
con without depending on a third party. In that case,
a straightforward way, either using the “two-lookback”
mechanism to hash past 𝜆 blocks in Snow White or
using VRF to hash the previous block in Algorand and
Ouroboros Paros, etc, to generate randomness is not a
proper approach. Thus, post-quantum decentralized ran-
domness is generated using the technique of quantum-
safe distributed-VRF in section 5, which is achieved by
combining the techniques of veriﬁable secret sharing and
VRF from symmetric primitives.
Post-Quantum PoS via proposed VRF. VRF is becoming
the core of the cryptographic lottery-based PoS consen-
sus protocol. The crux of fulﬁlling the goal of post-
quantum PoS is turning into the instantiation of post-
quantum VRF. In that case, armed with the constructed
post-quantum VRF, as discussed in section 6, we en-
able to eliminate the VRF based on number theoretical
assumptions in Algorand, and we only require that in
each round each node evaluates a post-quantum VRF to
check whether they have been sampled as part of that
round’s committee. Meanwhile, the number of committee
members is binomial (i.e., depending on the stake distri-
bution), so the amount of work needed to verify the other
committees’ messages is also binomial.

Organization. This work is organized as follows. The
next section 3 is for preliminaries. In section 4 we present our
motivations and observations, and we discuss how to con-
struct a post-quantum VRF with an implementation and eval-
uation of our concrete instantiation. In section 5, we present
the ﬁrst application of VRF in random beacon. In section 6,
then we present the second application of VRF in proof of
stake. Finally, section 7 is for conclusion.

2 RELATED WORK

The concept of VRF is very similar to the concept of signature.
Thus, there are two main approaches for the construction
of VRFs: 1) a direct approach (e.g., [12]), or 2) an indirect
approach using signatures that have the “uniqueness” prop-
erty (e.g., [13]). There is also a close relation between VRFs,
signatures, and ZKPs. Below, we revisit some related works.

Below, we summarize our main contributions along with

2.1 Revisiting Veriﬁable Random Function

the technical route.

•

Post-Quantum VRF. We construct a post-quantum
VRF from symmetric-key primitives by using the post-
quantum ZKP systems in section 4. In a nutshell, the
methodology is using a pseudo-random function to gen-
erate the output of VRF 𝜎
m
)
←
with the secret key vsk while introducing a quantum-safe
zero-knowledge proof (ZKP) system to append a proof
of knowledge of secret key vsk, where the proof is used
to show that ℎ is pre-image of the output 𝜎 (without

for ℎ = 𝐻1 (

𝐻2 (

vsk, ℎ

)

To our knowledge, VRF is an important cryptographic tool
in blockchain consensus and random beacon. The essence of
VRF is a mathematical operation that takes some inputs and
produces a random number along with proof of authenticity
that the random number was generated by the submitter. The
appended proof can be veriﬁed by any challenger to ensure
the random number generation is valid. To our knowledge,
Goldwasser and Ostrovsky [13] introduced an invariant sig-
nature that is called a unique signature afterward, and they
have shown how to transform a unique signature to the

VRF in a fairly straightforward way. Subsequently, Micali,
Rabin, and Vadhan [14] pointed out that if a digital signature
scheme is with the uniqueness property, then ideal hashing
and unique signature provide an elementary implementation
of a VRF. The existing constructions of VRF [12], [15] based on
several theoretical assumptions cannot guarantee security in
the coming quantum era. Recently, lattice-based VRF schemes
are proposed, e.g., [16], but these schemes do not have good
performance in the real world. Thus, achieving a practical
post-quantum VRF is an open question. Very recently, an
independent and similar result with us was proposed by Buser
et al. [17], they used the XMSS signature as the building block
to design quantum-secure VRF, their methodology is using
the unique signature (e.g., XMSS signature) as the beginning
point.

2.2 Revisiting Post-Quantum Zero-Knowledge

Recent advances in quantum computing have increased the
interest
in post-quantum cryptography research, such as
lattice-based, code-based, multivariate-quadratic (MQ), and
hash-based cryptography. Lattice-based cryptographic is more
versatile than others, it has a solid theoretical foundation and
problems (e.g., CVP, SVP, SIS, and LWE) and can realize var-
ious cryptographic primitives. and hash-based cryptography
enables to reduce greatly the size of the ZKP’ statement by us-
ing pseudorandom functions instead of signatures wherever
possible.

Notably, there exist ZKPs that only use collision-resistant
hash functions and hence are plausibly post-quantum se-
cure. Popular examples include Aurora [21], ZKBoo [18],
ZKB++ [9], and ZK-STARK (zero-knowledge scalable trans-
parent argument of knowledge) [20]. Other notable ZKPs like
Bulletproofs or libsnark rely on cryptographic assumptions
that are known to be vulnerable to quantum attacks (e.g.,
the hardness of discrete log in certain elliptic curve groups).
Inspired by the work of Sonic [23], Table 1 is used to illus-
trate asymptotic efﬁciency comparison of the post-quantum
ZKP security for arithmetic circuits. ZK-STARK [20] aims to
provide fast and scalable solutions while ensuring ﬁnancial
security. Armed with ZK-STARK, transaction encryption is
possible. The acronym ZK-SNARK means “Zero-Knowledge
Succinct Non-Interactive Argument of Knowledge,” the most
important property is that the proof length does not depend
on the length of statements. There are currently two leading
technologies (i.e., Monero, and ZCash) offering their cryp-
tocurrencies while striving to solve protection issues. In partic-
ular, Monero uses ZK-STARK that provides the ability to con-
duct anonymous transactions. However, Zcash is supported
by ZK-SNARK to create a shielded transaction. Compared
with ZK-SNARK, Bulletproof is the short non-interactive zero-
knowledge range proof that requires no trusted setup, while
verifying a bulletproof is more time-consuming than verifying
a SNARK proof.

2.3 Revisiting Post-Quantum Signatures

Obviously, there are similarities between the VRF and the
unique signature, and some unique results enable to provide
a VRF in a straightforward way. According to our investiga-
tion [12], there is a direct approach to construct VRF, which

3

can bypass the unique signature as intermediation. To achieve
quantum-safe, No one doubts that lattice-based cryptography
still objects to further research, but hash-based signatures are
well understood. There are many reasons to use hash-based
schemes The interesting point is that the hash-based signature
could reduce a message to a small representation of characters
that can be signed easily. Whereas a hash-based solution only
needs a secure hash function for the same procedure.

Below, we revisit classical digital signature schemes with a
comparison of the post-quantum signatures in Table 2. There
are two generic paradigms to obtain the lattice-based signa-
ture schemes [31], one is hash-and-sign signature paradigm, e.g.,
Ducas-Lyubashevsky-Prest signature [24], and another is Fiat-
Shamir signature paradigm, such as G ¨uneysu-Lyubashevsky-
P ¨oppelmann [32] and BLISS [25]. Unfortunately for them,
these schemes are less efﬁcient and without the unique prop-
erty.

Notably, the current quantum-resistant hash-based signa-
tures, such as SPHINCS1 [33], SPHINCS+
2 [34], and EPID
signature [35] etc, cannot satisfy practical performances and
cannot provide the public veriﬁability. Remarkably, Picnic is
the ﬁrst quantum-safe signature with public veriﬁability from
symmetric-key proposed by Chase et al. [9] using the “Play-
MPC-in-the-Head” paradigm [36]. But the signature size of
Picnic3 is near to 40 KBytes. Thus, various optimizations
are proposed to shorten the length of keys and signatures
while improving the computation performance [10]. Notably,
very recently, an independent and similar result with us was
proposed by Buser et al. [17], they used the XMSS signature
as the building block to design quantum-secure VRF, their
methodology is using the unique signature (e.g., XMSS signa-
ture) as the beginning point.

2.4 Revisiting Random Beacons

The need to generate a large number of high-quality ran-
dom numbers is a largely unrecognized requirement of a
production blockchain consensus community. The public ran-
domness beacon enables to issue periodically (i.e., at regular
intervals) fresh unpredictable and unbiased random values
that was ﬁrst proposed by Rabin [37] for contract signing.
Afterwards, several applications for cryptographic primitives,
such as anonymous browsing [38], and blockchain [7], [39],
etc, have been invented. The original idea of Rabin cannot
work without supporting a trusted third party. Thus, a dis-
tributed random beacon that could guarantee output delivery
and uniformly distribute the randomness for participants is
requested. Recently, some elegant distributed random beacon
schemes are proposed for blockchain consensus protocols,
such as Ouroboros [40] and HydRand [41] supported by pub-
lic veriﬁable secret sharing (or PVSS), Algorand [7], Ouroboros
Praos [8], and decentralized random beacon [42] are armed
with VRFs. However, the aforementioned solutions cannot
remain secure in the quantum computing era. Designing
a post-quantum random beacon is increasingly attracted to
researchers’ interest.

1. https://sphincs.cr.yp.to/papers.html
2. https://sphincs.org/resources.html
3. https://microsoft.github.io/Picnic/

TABLE 1: Overview of Feasibly Quantum-Resistant Proof Systems.

4

Scheme

Performance

Size

Assumption Untrusted

Prover

Veriﬁer

CRS

Proof

𝑠𝑘

Setup

ZKBoo [18]
Ligero [19]
ZK-STARK [20]
Aurora [21]
Bootle et al. [22]

𝑛 log 𝑛
𝑛 log 𝑛
𝑛 polylog 𝑛
𝑛 log 𝑛
𝑛

𝑐 log 𝑐
𝑐 log 𝑐

ℎ log ℎ
ℎ log ℎ

+
+
polylog 𝑛

𝑐 log 𝑐

ℎ log ℎ

+
𝑛

𝑛
0
0
0
0

√𝑛
√𝑛
log2 𝑛
√𝑛
√𝑛

CRHF
CRHF
CRHF
CRHF
CRHF

✗
✓
✓
✓
✓

- The communication complexity of ZKB++ is more than halved compared to ZKBoo, not
affecting the computational complexity. This is done by using six different optimizations
that are designed to compress all messages sent as much as possible.

- 𝑛 is the number of gates, 𝑑 is the depth of the circuit, ℎ is the width of the subcircuits, 𝑐 is
the number of copies of the subcircuits, ℓ is the size of the instance, and 𝑤 is the size of the
witness.

- CRHF stands for collision-resistant hash functions.
- ✓ denotes that the scheme does have this property.
- ✗ denotes that the scheme does not have this property.

TABLE 2: Overview of Post-Quantum Signature Schemes.

Performance

NTRU-GPV [24]
BLISS-BI [25]
Falcon-512 [26]∗
Dilithium-medium [27]
Dilithium-recommended [27]
qTESLA-p-I [28]
qTESLA-p-III [28]
MQDSS-31-64 [29]
HmFev(256,15,3,16) [30]
Rainbow(16,32,32,32) [30]
SPHINCS+ −
Picnic L1 FS [28]
Picnic2 L1 FS [28]

128 [28]

Sign

≈

1200
717
617
2044
2071
2848
6176
64
61
48
16976
32944
12062

Size[Byte]
𝑝𝑘

𝑠𝑘

1792
896
897
1184
1472
14880
39712
34032
83100
145500
32
33
33

NONE
256
4097
2800
3504
5184
12352
24
20
≈
18
64
49
49

NTRU-based

Ring-based

Lattice-based

MQ-based

Hash-based

* https://github.com/open-quantum-safe/liboqs

3 PRELIMINARIES AND BUILDING BLOCKS

)

𝜆

in poly

, 𝐻2 (·)

and 𝐻3 (·)

In this section, we review and list deﬁnitions and notations
that will be used in the following principal contents. We begin
by denoting 𝜆 as the security parameter, then we review the
standard deﬁnition of the pseudo-randomness functions 𝐻
,
(·)
𝐻1 (·)
time. Apart from the well
(
known pseudo-randomness property, the key one-way states
that it is hard to ﬁnd a key such that the function Fkey maps
a given input 𝑥 to a given output 𝑦. Fkey is instantiated by
SHA-256 that provides 128 bits of pre-image resistance against
quantum adversaries.
(Non-interactive) Zero-Knowledge (NIZK). For every 𝜆,
is
denoted as an efﬁciently computable binary relation, for any
as the language consisting of
pair
LR
statements in ℝ, i.e.
ℝ
, where 𝑥 is
𝑤 s.t.
𝑥
|∃
{
a statement and 𝑤 is the associated witness. In other words,
𝜆
that
there is a polynomial time algorithm running in poly
(
)
decides whether
R𝜆 consists
of two polynomial time algorithms, prover 𝑃 and veriﬁer 𝑉 ,
and proceeds as follows.

) ∈ R𝜆. A Sigma protocol for

, we denote
=

) ∈ R

𝑦, 𝑤

𝑥, 𝑤

𝑥, 𝑤

) ∈

LR

R

}

(

(

(

• (

•

1𝜆, 𝑠𝑘 :=

(

𝑦, 𝑤

) ←

Com

a, st
is executed by 𝑃, and he
keeps the corresponding state st privately and sends the
commitment a to the veriﬁer 𝑉 .
a challenge c sampled at random in
by 𝑉 , given 𝑦 and a.

𝜆 is generated

0, 1

))

{

}

(

•

•

(

←

1𝜆, 𝑠𝑘 :=

Prove

, st, c
)

𝑦, 𝑤
z
)
and outputs a response z.
𝑉 executes Verify
a, c, z
(
1.

(
is valid. If it is, Verify

(
1𝜆, 𝑝𝑘 := 𝑦, a, c, z

(

)

is executed by 𝑃 given c,

)
1𝜆, 𝑝𝑘 := 𝑦, a, c, z

checks whether
returns

)

When it is clear in the context, we omit 1𝜆 for convenience.
In this setting, 𝑝𝑘 is denoted as 𝑦 and 𝑠𝑘 is denoted as
.
)
Additionally, a NIZK of knowledge can be transformed from
any public-coin zero-knowledge proof (e.g., Sigma-protocol)
by using the Fiat-Shamir transform.

𝑦, 𝑤

(

Veriﬁable Random Function. A VRF [14] consists of algo-
and satisﬁes the following
rithms
(
syntaxes.

VrfGen, VrfEval, VrfVrfy

)

•

•

•

)

1𝜆
)
vsk, m

vpk, vsk
VrfGen
outputs a pair of keys
;
(
)
(
outvrf, 𝜋vrf)
outputs a pair
VrfEval
, where outvrf
(
vsk, m
is the output value from evaluation function Eval
,
)
and 𝜋vrf is the proof of correctness given vsk, i.e., 𝜋vrf ←
Prove
(
=
VrfVrfy
Eval
is
)
valid and 0 otherwise.

vsk, 𝜎
vpk, outvrf, m, 𝜋vrf)
using 𝜋vrf,

that
then return 1 if outvrf

(
vsk, m

veriﬁes

outvrf

(

(

)

(

.

(

(

(

require

to pass

= Vrfy

when outvrf1

In other words,

vpk, m, outvrf1, outvrf2, 𝜋vrf1, 𝜋vrf2)
vpk, outvrf1, m, 𝜋vrf1)
≠ outvrf2.

the property of uniqueness,
Additionally, we
provability and pseudorandomness. Uniqueness implies that
no values
can satisfy the
vpk, outvrf2,
equation VrfVrfy
m, 𝜋vrf2)
for
every m, only a unique value outvrf = Eval
vsk, m
(
)
the
implies
enables
=
vpk, m, outvrf, 𝜋vrf)
outvrf, 𝜋vrf)
that VrfVrfy
and 𝜋vrf
VrfEval
vsk.
given
is
)
Pseudorandomness means that for any probabilistic polynomial-
time (PPT) adversary, it is hard to distinguish the function
values from real random ones, which can be guaranteed by
hashing function Eval
. Formally, for any PPT adversary
who did not call its oracle on message m,
A2)
for some

A
the following probability is at most 1

=
1 if
(
computable

veriﬁcation. Provability

(
vsk, m

(A1,

negl

(·)

=

𝜆

(

2
/

+

(

)

5

Pr 
𝑏 = 𝑏 ′







(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

negligible function negl

vpk, vsk
) ←
(
𝑏
0, 1
;
← {
}
outvrf1 ← {

0, 1

(·)
VrfGen

;

1𝜆

in the security parameter 𝜆,
m, st
(
outvrf0 ←
𝑏 ′ ← A

VrfEval
1
Eval

VrfEval
2

(
( ·)
(

) ← A

) ;

(

)

𝜆

(

𝑏
}

(

vpk
)
;

( ·)
vsk, m
outvrf𝑏, st

)

;

)

Remark 3.1. We remark that, in general, the post-quantum VRF
could be achieved if the cryptographic building blocks are quantum
security. We omit to introduce the quantum adversary with the
advantages to capture the quantum-secure deﬁnition.

· · ·

Distributed-VRF. Below, the deﬁnition is adopted from [42].
, 𝑆𝑛 communicate via pair-
In setup phase, 𝑛 servers 𝑆1, 𝑆2,
wise private and authenticated channels. They have access
to an append-only public board where every server can post
messages, and these posts cannot be repudiated by their
senders. A setup interaction is then run between 𝑛 servers
to build a global public key 𝑝𝑘, individual servers’ public
veriﬁcation keys vpk1, vpk2,
, vpk𝑛, and individual servers’
, vsk𝑛. The servers’ secret and veri-
secret key vsk1, vsk2,
for 𝑖 = 1, 2,
, 𝑛 will later enable
ﬁcation keys
(
· · ·
any subset of 𝑡
1 servers to non-interactively compute the
veriﬁable random value Eval
.
∈ D
(
On the contrary, any set of at most 𝑡 servers cannot learn any
information on Eval
for any m not previously com-
𝑡, 𝑛
(non-interactive) distributed-VRF consists of
puted. A
(
:
the following algorithms

DistKG, PartialEval, Combine, Vrfy

· · ·
vsk𝑖, vpk𝑖)
+

on a plaintext m

vsk, m

vsk, m

· · ·

)

)

)

(

]

,

𝑛

𝑛

)

)

(

{

{

∈ [

∈ [

• (

1𝜆, 𝑡, 𝑛

DistKG

vvk𝑖 }𝑖

vsk𝑖, vvk𝑖, m

(
vsk𝑖 }𝑖

, vsk𝑛 }
PartialEval

· · ·
of servers’ veriﬁcation keys.

)
vpk,
is a fully
]) ←
distributed key generation algorithm that takes as input
a security parameter 1𝜆, the number of participating
servers 𝑛, and the threshold parameter 𝑡;
it outputs
a set of qualiﬁed servers QUAL, a global public key
vsk1,
vpk, a list
of server’s secret keys, a list
{
, vvk𝑛}
vvk1,
{
· · ·
outvrf𝑖, 𝜋vrf𝑖 ) ←
is a partial
• (
(
evaluation algorithm that takes as input server 𝑆𝑖 ∈
QUAL, secret key vsk𝑖 , and veriﬁcation key vvk𝑖,
a plaintext m, and outputs either a triple 𝜋vrf𝑖 =
𝑖, outvrf𝑖, resp𝑖, c𝑖 )
is the 𝑖-th evaluation
(
share and resp𝑖 is a non-interactive proof of correct partial
evaluation.
outvrf, 𝜋vrf) ←
is a combina-
tion algorithm that takes as input the global public key
vpk, the veriﬁcation key vvk, a message m, and a set
𝜀 =
n𝜋vrf𝑖1,
o of partial function evaluations
1 different servers, and out-
origination from
of pseudo-random function
puts either a pair
value outvrf and correctness proof 𝜋vrf, or
.
⊥
0, 1
is a veriﬁcation al-
gorithm that takes as input the public key vpk, a set of
veriﬁcation key vvk, a plaintext m, and a proof 𝜋vrf, then
outputs 1 or 0 (i.e., accept or reject).

, 𝜋vrf𝑖
|𝜀 |
𝜀
𝑡
| ≥
outvrf, 𝜋vrf)

vpk, vvk, m, outvrf, 𝜋vrf)

, where outvrf𝑖

vpk, vvk, m, 𝜀

Combine

Vrfy

} ←

• {

• (

· · ·

|
(

+

(

)

(

Additionally, the distributed VRF satisﬁes the following
properties. 1) Consistency, meaning that no matter which
collection of correctly offered shares is used to compute
the function on a plaintext m the same random value
outvrf = F
is obtained. 2) Domain-range correctness,
meaning that every computed value outvrf belongs to the
. 3) Probability means that the uniquely
range domain
recovered value outvrf = F
passes the veriﬁcation

vsk, m

vsk, m

R

)

(

(

)

)

(









vsk, m

passes the veriﬁcation.

test. 4) Uniqueness means that for every plaintext m a unique
outvrf = F
Linear Decomposition of a Circuit. ZKP schemes atop
.
-
MPC-in-the-head paradigm [36] uses an explicit linear
.
)
decomposition of a circuit 𝜙 : ℝ𝑚
ℝℓ over an arbitrary
ﬁnite ring ℝ. Here 𝜙 can be expressed by an 𝑛-gate arithmetic
circuit over the ring, and supports multiplication by constant,
binary addition and binary multiplication gates. Below, the
-decomposition of a circuit 𝜙 is deﬁned for the
linear
(
statement 𝑦 = 𝜙

2, 3

2, 3

→

(

)

𝑖

𝑗

•

+

0

1

0

|)

|)

𝑤

𝑤

−

−

1)

𝑖
)𝑗

1, 𝑛

· · · |

· · · |

∈ [

←
1, 𝑡

𝑖
1, tp(
)𝑗

. Picks random tapes
, 𝑤2 =
1
−
𝑤2 for a pseudoran-
0

𝑤
|
|
𝑖
𝑖
Upd𝜙 (
, tp(
, view(
)𝑗
)𝑗
+
+
𝑖
. Takes as input the view(
)𝑗
]
𝑖
1 and tp(
)𝑗
+

with a witness 𝑤.
𝑤
(
)
Share
𝑤, tp1, tp2, tp3)
𝑤1, 𝑤2, 𝑤3) ←
(
• (
ℝ𝑚. Output 𝑤1 = G1 (
tp1, tp2, tp3 ∈
, and 𝑤3 = 𝑤
𝑤1 −
𝑤
1
G2 (
|)
−
· · · |
dom generator G𝑖 seeded with tp𝑖 , where G𝑖 (
-bit.
outputs the ﬁrst
1
view(
view(
,
)
𝑗
]
∈ [
𝑖
and tp(
and 𝑖
of
)𝑗
𝑖
the participant 𝑃 𝑗 as well as view(
1 of 𝑃 𝑗
1.
)𝑗
+
Computes the participant 𝑃 𝑗 ’s view of the output wire
of gate g𝑖 and appends it to the view. w𝛿 is denoted as 𝛿-
th wire, and w(
is referred to the value of w𝑘 in the view
𝛿
of 𝑃 𝑗 . It is notable that the Upd𝜙 operation depends on the
type of gate g𝑗 and supports the operation of addition by
constant, multiplication by constant, binary addition and
binary multiplication gates.
– Addition by constant (w𝑏 = w𝑎 +
𝛿). Outputs w(
𝑗
𝑗
if 𝑗 = 1. Otherwise, outputs w(
)𝑎 .
)𝑏
– Multiplication by constant (w𝑏 = 𝛿
w𝑎). Outputs w(
𝑏

)𝑎 +

= w(

= w(

𝑗
)𝑏

=

𝛿

+

)

)

𝑗

𝑗

𝑗

·

w𝑏). Outputs w(

𝑗
𝑗
)𝑐 = w(
w(
𝑏 .
)𝑎 +
)
𝑗
𝑗
)𝑐 = w(
w𝑏). Outputs w(
)𝑎
𝑗
1
𝑐
𝑐
PRG𝑗
PRG𝑗 (
)
)
1 (
𝑏 +
+
is the 𝑐-th output seeded with tp𝑗 .

𝑗
)𝑎

) −

w(

·
,

)

+

+

·

𝑗

. Selects the ℓ output wires of the

𝑗

)

1

+

– Binary addition (w𝑐 = w𝑎 +
– Binary multiplication (w𝑐 = w𝑎 ·
𝑗
w(
w(
w(
w(
)
𝑎
𝑏
𝑏 +
·
𝑐
where PRG𝑗 (
Output
(

𝑦 𝑗 ←
)
𝑛
circuit as stored in view(
)𝑗
= 𝑦1 +
𝑦

𝑦1, 𝑦2, 𝑦3)

)
view (

𝑛
)𝑗

𝑗

•

•

(

←

Rec

𝑦3. Reconstructs 𝑦.

.
𝑦2 +
Non-Interactive ZKBoo atop MPC-in-the-head Paradigm.
Ishai-Kushilevitz-Ostrovsky-Sahai (IKOS) [36] proved a sur-
prising result in 2007 that even semi-honest multiparty com-
putation (MPC) is sufﬁcient to obtain ZKPs. Additionally,
IKOS paradigm [36] enables to provide a transformation to
obtain a zero-knowledge protocol from symmetric primitives
with low communication complexity. As we know, ZKBoo
and ZKB++ build on the MPC-in-the-head paradigm of Ishai
et al. [36], And we conclude their main ideas as follows. For
the public 𝜙 and the word 𝑦
∈ L𝜙 , the prover is with the
witness 𝑤 such that 𝑦 = 𝜙
𝑤
is denoted
(
as the commitment, 𝐻
is the public hash function for the
prover and veriﬁer, and the integer 𝑡 is the number of parallel
iterations.
resp
. The prover simulates
an MPC protocol “in their head”, commits to the state
and transcripts of all players. More concretely,
1) For 𝑖 = 1 to 𝑡, set 𝑟𝑖 as the iteration label, and for
𝑖
𝑖
𝑗 = 1 to 3, to obtain an output view(
)𝑗 and share 𝑦 (
,the
)𝑗
𝑖
𝑖
𝑖
1 , tp(
2 , tp(
player 𝑃 𝑗 picks random tapes tp(
and de-
)
)
3
composites the witness 𝑤 as follows:

stmt := 𝑦, wits := 𝑤

. In addition, Com

Prove𝐻 (

←

(·)

(·)

)

)

•

)

w(

𝑗
)𝑎 .

𝛿

·

•

𝑤 (
(

Share

𝑖
2 , 𝑤 (
)

𝑖
1 , 𝑤 (
)

𝑖
𝑖
𝑖
2 , tp(
𝑤, tp(
a) shares
;
)
)
)
3 ) ←
3 )
(
b) computes the 𝑖-th view of participant
𝑗,
i.e.,
𝑖
𝑖
𝑖
, tp(
1, tp(
Upd𝜙 (
Upd𝜙 (· · ·
, 𝑤 (
)𝑗
)𝑗
)𝑗
1)
+
+
𝑖
result 𝑦 (
, and outputs partial
)𝑗 ←
view(

Upd𝜙 (

𝑖
1 , tp(
)

)𝑗 ←

view(

𝑖
)𝑗

𝑤 (

𝑖

𝑖

· · · ) · · · )
Output
;
)𝑗 )
(
c) ﬁnally commits

𝑖
, op(
ct(
)𝑗
(
𝑖
𝑖
2 , 𝑦 (
1 , 𝑦 (
𝑦 (
)
)
2) 𝑃 𝑗 computes the challenge 𝑐

and sets 𝑎 (

) =

(

𝑖

, view(

𝑖
)𝑗

)

𝑖

)𝑗 ) ←
𝑖
3 , ct(
)

𝑖
tp(
Com
)𝑗
(
𝑖
𝑖
𝑖
1 , ct(
2 , ct(
.
)
)
)
3 )
2
1
𝐻
),
), 𝑎 (
𝑎 (
(
←
· · ·
for 𝑖 =
𝑖
1, 2, 3
) ∈ {

𝑡

, 𝑎 (

𝑖

𝑡

,

[

}

←

), 𝑧 (

𝑎 (
(

𝑖
op(
)𝑐
(
1
), 𝑧 (
,
) )
stmt

where 𝑐 can be interpreted as 𝑐 (

) =
creates 𝑧 (
resp =
1
𝑎 (
(cid:0)(
Verify𝐻 (

,
) )
1, 𝑡
.
]
3) For 𝑖 = 1 to 𝑡, set 𝑟𝑖 as the iteration label, the player 𝑃 𝑗
𝑖
, op(
. Then the player 𝑃 𝑗 outputs
)𝑐
1)
+
𝑡
2
2
,
), 𝑧 (
𝑎 (
.
))(cid:1)
))
· · ·
(
:= 𝑦, resp
𝑏
. The veriﬁer “corrupts”
)
a random subset of the simulated players by seeing
their complete state, then the veriﬁer checks that the
computation was done correctly from the perspective of
the corrupted players, and if so, the veriﬁer has some
assurance that the output is correct and the prover knows
𝑥 . Iterating this for many rounds, then the veriﬁer gets
high assurance.
1) For 𝑖 = 1 to 𝑡, set 𝑟𝑖 as the iteration label, the veri-
),
, 𝑎 (
,
) )
1, 2, 3
. Then
𝑖
𝑖
𝑐 ′(
1
) +
(cid:9)
, outputs Reject. Other-
𝑖
, sets ntp(
)𝑗

𝐻
ﬁer computes the challenge 𝑐 ′ ←
𝑖
where 𝑐 ′ can be interpreted as 𝑐 ′(
the veriﬁer validates if there exists 𝑗
𝑖
ct (
such that Open
)𝑗
𝑐 ′(

𝑎 (
), 𝑎 (
(
) ∈ {
∈ (cid:8)

wise, for all 𝑗

)𝑗 )
), 𝑐 ′(

· · ·
}
), 𝑐 ′(

, op(
𝑖

, view(

⊥
1

=

(

1

2

𝑡

𝑖

𝑖

𝑖

Open

ct(

𝑖
)𝑗

𝑖

, op(

)𝑗 )
2) Next, the veriﬁer validates Rec

(

(

𝑖
2 , 𝑦 (
)

𝑖
1 , 𝑦 (
𝑦 (
)

?= 𝑦. If
the validation does not pass, then outputs Reject. If
?=
there exists 𝑗
𝑖
Output
view(
)𝑗
outputs Reject. For each wire value w(
1
w(

∈ (cid:8)
. If the validation does not pass, then
view𝑒 , if
output Reject.

, then validates 𝑦 (

𝑖
)
3 )

), 𝑐 ′(

) +

𝑒
)𝑗

𝑖
)𝑗

𝑐 ′(

∈

1

(cid:9)

−

)

(

)

)

𝑖

𝑖

𝑗

𝑗

, view(
𝑒
3) The veriﬁer outputs Accept.

≠ Upd𝜙 (

view(
𝑒

1
1 , tp𝑒, tp𝑒
−
+

𝑒
)𝑗

1)

+

)𝑗 o ←

) +

(cid:9)

∈ (cid:8)
.

4 POST-QUANTUM VERIFIABLE RANDOM FUNCTION

An observation is that Algorand does not adopt the Dodis-
Yampolskiy VRF that depends on the costly bilinear pair-
ing and cannot service the large-scale PoS network. In-
stead, Algorand recommends to adopt the Goldberg-Naor-
Papadopoulos-Reyzin VRF [43] in his realization that by-
passes the unique signature as intermediation. Thus, to pre-
vent quantum computer attacks while servicing the large-scale
lottery-based PoS consensus protocol (e.g., Algorand), in this
work, we present an instance of quantum secure VRF from
symmetric primitives for random beacon and lottery-based
PoS consensus protocol; however, unlike previous construc-
tion, we realize it in a quantum resilient way, i.e., the proposed
VRF isn’t based on hard problems from number theory.
Quantum-secure signature. Before presenting our quantum-
secure VRF construction, we ﬁrst present an indirect approach
using signatures that have the “uniqueness” property. In-
spired by the spirit of hash-based signature from Fiat-Shamir
for Schnorr signature, it is easy to design a quantum-safe sig-
nature scheme by integrating a (weakly complete) quantum-

secure identiﬁcation protocol (or Σ protocol), the methodology
of the signature from Fiat-Shamir is summarized as follows.

6

.

(

)

)

(

)

k

a

𝐻

←

←

a, st

, 2) 𝑐

𝑠𝑘
(

Com

Prove

•

•

•

, 𝑠𝑘 := s

𝑅, and 𝑣𝑘 := y = OWF

1𝜆
Gen
)
(
, it takes 𝑠𝑘 and a message 𝑚 as input, and
𝑠𝑘, 𝑚
Sign
(
𝑠𝑘 := s, os := 𝑟
𝑚
,
generates 1)
) ←
(
k
←
)
denotes
and
3)
concatenation.
where
𝑠𝑘 := s, st, c
it runs
. If z is not valid,
z
)
(
another round. It keeps running until z is valid. Finally it
returns the signature 𝜎 :=
a, c, z
rejects
Vrfy
if
,
)
= 0.
𝑚
𝑦, 𝑚,
(
In short, the OWF family

𝐾𝜆 is used for key gener-
{
ation in both signature schemes, the public key is an image
𝑦 = 𝑓
of a one-way function 𝑓 and secret key 𝑥 , and a
signature is an NIZK proof 𝜋 of 𝑥 , that incorporates a message
to be signed.

there exists Vrfy

𝑣𝑘, 𝑚, 𝜎
a, z, 𝐻

𝑓𝑘 }𝑘

it
a

(
(

)))

:=

𝑣𝑘

𝑥

k

)

(

)

(

(

∈

.

4.1 Provably Secure VRF from Symmetric Primitives

Notably, there are two issues that may prevent some kinds of
signature schemes with uniqueness from being used straight-
forwardly as a VRF. Firstly, the signature may not be unique
by given the message x and the public key 𝑝𝑘. Secondly, the
signature 𝜎x is unpredictable but not pseudorandom (e.g., sig-
natures could contain some bias and be distinguishable from
a random distribution.) In addition, VRF derived from unique
signatures presents strong unbiasibility properties due to the
uniqueness, even in the presence of active adversaries, of the
corresponding pseudorandom value. Thus, it is not enough to
obtain a VRF with uniqueness and pseudorandomness from
the quantum-secure unique signature in a fairly straightfor-
ward way. Indeed, according to our investigation [12]4, there
is a direct approach to construct VRF, which can bypass the
unique signature as intermediation.

As mentioned earlier, any VRF has three components,
generator, evaluator, and veriﬁer. The evaluator executes two
functions, the evaluation and the prover. The paradigm of
post-quantum VRF is achieved by leveraging concepts to-
gether with symmetric cryptography and quantum-safe ZKP
systems to create a signature. In a nutshell, this paper intro-
duces a new post-quantum VRF by using the ideas of [43]
for construction of the evaluation function and ideas of [11]
for construction of the prover based on a quantum-safe ZKP
for the uniqueness property. An important difference between
this proposed VRF construction and [43], [11] is the fact that
in the proposed VRF both the evaluator, and veriﬁer should
have access to the same secret key. Thus, the use of a priori
post-quantum symmetric key protocol is also required.

To make it understand easily, our VRF evaluation function
uses deterministic hash functions to hash the message and
appends a quantum-safe proof of knowledge for the witness
secret key, where the prover can convince the veriﬁer that she
knows a secret key without disclosing the secret key itself.
There is a public key vpk associated with a secret seed vsk and
a pesudorandom hash function F
, then it satisﬁes 1)
(
computable given the corresponding vsk, where outvrf
calculated by using hash functions 𝐻2 (
4. https://www.cs.bu.edu/∼goldbe/projects/vrf

← K
is efﬁciently
is
. 2) A proof

with a random key k
vsk, m

(
vsk, 𝐻1 (

outvrf, 𝜋vrf)

= VrfEval

(·)

m

))

)

(

))

outvrf, vsk
)
vsk, 𝐻1 (

𝜋vrf is computable given the vsk, and a natural approach is
. 3) No
the quantum-safe ZKP by invoking Prove
adversary can distinguish outvrf by computing 𝐻2 (
m
from a random value without explicitly querying for m.
Equality of ZKBoo. In addition, to guarantee the uniqueness
without disclosing the secret key, a equality of quantum-
secure ZKP system is used to prove that the public key and the
output of VRF have same pre-image secret key here. Below,
we present the equality of ZKBoo system as a warm-up, which
is an independent contribution. Here, regarding the relation
, 𝜎 = 𝐻2 (
: 𝛼 = F
, the equality of
(
L
=
k, 𝑠
𝛼, k; 𝑠
and
ZKBoo proceeds relations
{(
𝑠, ℎ
synchronously. In particular, the
L𝐻2
prover proceeds as depicted in Fig.1 and the veriﬁer proceeds
as depicted in Fig. 2.

)
: 𝜎 = 𝐻2 (

k, 𝑠
)
LF1
)}

)}
: 𝛼 = F

𝛼, k, 𝜎, ℎ; 𝑠

𝜎, ℎ; 𝑠

𝑠, ℎ

{(

{(

)}

=

=

)

)

(

Equality Proof Algorithm of ZKBoo.

•

𝑖

←

for

and

Share

)𝛼,3) ←
)𝜎,3) ←

ZKP.Prove𝐻 (

𝑖
𝑖
𝑖
1 , 𝛼.tp (
𝑠, 𝛼.tp (
2 , 𝛼.tp (
)
)
)
3 )
(
𝑖
𝑖
𝑖
1 , 𝜎.tp (
2 , 𝜎.tp (
𝑠, 𝜎.tp(
)
)
)
3 )
(
𝑖
and 𝜎.tp (
.
)𝑗

resp
stmt, wits
for the iteration label
)
𝑖 = 1 to 𝑡 and the dummy participant label 𝑗 = 1 to 3.
1) compute
𝑖
𝑖
𝛼,1, 𝑠 (
𝑠 (
𝛼,1, 𝑠 (
)
)
(
𝑖
𝑖
𝑖
Share
𝜎,1, 𝑠 (
𝜎,1, 𝑠 (
𝑠 (
)
)
(
𝑖
random tapes 𝛼.tp (
)𝑗
2) compute 𝛼.view (
)𝑗 ←
𝑖
UpdF(
UpdF (· · ·
UpdF (
𝑠 (
)𝑗
𝑖
and compute 𝜎.view (
)𝑗 ←
𝑖
Upd𝐻2 (
Upd𝐻2 (· · ·
Upd𝐻2 (
𝑠 (
)𝑗
(see ZKBoo for details);
Output
3) obtain 𝛼.stmt (
𝛼.view (
(
𝑖
𝜎.view (
;
)𝑗 )
Com

𝑖
1, 𝜎.tp (
, 𝑠 (
)𝑗
)
𝑗
+

)𝑗 ←
Output

𝑖
, 𝛼.tp (
)𝑗
+

𝑖
1, 𝛼.tp (
)𝑗

1) · · · ) · · · )

𝑖
, 𝑠 (
)𝑗
+

, 𝜎.tp (
𝑗

𝜎.stmt(

)𝑗 )

and

𝑖

𝑖

𝑖

𝑖

𝑖

𝑖

𝑖

𝑖
)𝑗

(
, 𝛼.op (
𝑖
)𝑗

) ←

) ←
Com

(
𝜎.tp (

(

𝑖
)𝑗

𝛼.tp (
𝑖
)𝑗

)𝑗 )

, 𝛼.view (
𝑖
)𝑗 )

;

, 𝜎.view(

)
1) · · · ) · · · )
+

4) commit
and

)𝑗 ←
𝑖
𝛼.ct (
)𝑗
(
𝑖
𝜎.ct(
, 𝜎.op(
)𝑗
) =
𝑖
5) create 𝛼.𝑎 (
𝑖
1 , 𝛼.stmt(
𝛼.stmt (
)
(
) =
𝑖
𝜎.𝑎 (
𝜎.stmt (

(

𝑖
𝑖
2 , 𝜎.stmt(
1 , 𝜎.ct(
)
)
6) compute the challenge internally chlg

𝑖
1 , 𝜎.stmt(
)

𝑖
3 , 𝜎.ct(
)

(

𝑖
2 , 𝛼.ct(
)

𝑖
)
3 )
𝑖
𝑖
2 , 𝜎.ct(
)
)
3 )
1, 2, 3
}
∈ {

;
, i.e.,

𝑐
𝐻

1

←
𝛼.𝑎 (
(
7) create 𝛼.𝑧 (
𝑖

2
, 𝛼.𝑎 (
) , 𝛼.𝑎 (
),
· · ·
𝑖
) =
𝑖
𝛼.op (
)𝑐
(
𝑖
𝑖
) =
, 𝜎.op (
𝜎.op (
)𝑐
)𝑐
8) output 𝛼.resp =
+
1
,

𝜎.𝑧 (

) , 𝛼.𝑧 (

𝛼.𝑎 (

(

1

2

1)

𝑡

1

𝜎.𝑎 (
𝑖
)
1)
+

) k
, 𝛼.op (
𝑐
;

), 𝜎.𝑎 (
and

2

),

, 𝜎.𝑎 (

𝑡

;

) )

· · ·

𝛼.𝑎 (
(cid:0)(
𝜎.resp =
𝜎.𝑎 (

1

(cid:0)(

) )

(

) , 𝛼.𝑧 (

2

,

) )

· · ·

) , 𝜎.𝑧 (

2

𝜎.𝑎 (

) , 𝜎.𝑧 (

2

1

,

) )

(

,

) )

· · ·

and

,

,

𝑡

𝛼.𝑎 (

) , 𝛼.𝑧 (

𝑡

(

𝑡

𝜎.𝑎 (

) , 𝜎.𝑧 (

𝑡

(

) )(cid:1)

.

) )(cid:1)

Fig. 1: Equality Proof Algorithm of ZKBoo.

Post-Quantum VRF via ZKBoo. Armed with the equality of
ZKBoo, the detailed post-quantum VRF via ZKBoo is depicted
in Fig. 3 for key generation, Fig. 4 for evaluation, and Fig. 5
for veriﬁcation. Notably, we only present a post-quantum VRF
via ZKBoo. Indeed, it is easy to obtain a quantum-secure VRF
via other candidates post-quantum ZKP, such as ZKB++ and
ZKSTARK, but we ignore the details here.

7

for the iteration label 𝑖 = 1

𝑖

) and 𝛼.𝑧 (
) ,
) sequences;

•

𝑖

𝑖

𝑡

1

2

1

𝐻

←

𝛼.𝑎 (

) and 𝜎.𝑧 (

Equality Veriﬁcation Algorithm of ZKBoo.
stmt := 𝑦, resp
)

𝑏
to 𝑡 and the dummy participant label 𝑗 = 1 to 3.
1) parse 𝛼.resp into the sequence of 𝛼.𝑎 (
𝑖

Verify𝐻 (

, 𝛼.𝑎 (
𝑖
), 𝑐 ′(

and parse 𝜎.resp into 𝜎.𝑎 (
2) compute the challenge 𝑐 ′ ←
), 𝜎.𝑎 (
),
𝜎.𝑎 (
) , 𝛼.𝑎 (
),
) k
· · ·
· · ·
(
𝑖
𝑐 ′(
𝑗
, then set
3) validate
1
) +
}
∈ {
𝑖
𝑖
𝑖
𝑖
, 𝛼.op (
𝛼.ct (
, 𝛼.view (
𝛼.tp (
Open
)𝑗
)𝑗
)𝑗 } ←
)𝑗
(
𝑖
𝑖
𝑖
𝑖
, 𝜎.op(
𝜎.ct(
, 𝜎.view(
𝜎.tp(
Open
)𝑗
)𝑗
)𝑗 } ←
)𝑗
(
𝑖
𝑖
𝑖
2 , 𝛼.stmt (
𝛼.stmt (
4) validate Rec
1 , 𝛼.stmt (
)
)
)
3 )
?= 𝜎.stmt;
𝑖
𝑖
𝑖
1 , 𝜎.stmt(
and Rec
2 , 𝜎.stmt(
)
)
)
3 )
(
), 𝑐 ′(
𝑐 ′(
1
5) validate
,
) +
}
∈ {
∃
?= Output
𝑖
𝑖
𝛼.view (
𝛼.stmt (
)𝑗 )
)𝑗
(
?= Output
𝑖
𝑖
𝜎.view (
)𝑗 )
)𝑗
𝛼.view𝑒 and
𝛼.w(
6) validate

(
𝜎.stmt (

𝜎.stmt(

, 𝜎.𝑎 (

𝜎.w(

and

and

{
{

)
)

∀

2

𝑗

;

𝑖

𝑖

𝑡

;

) )

;
?= 𝛼.stmt

(
∈

∀

then validate
𝛼.w(
and
𝜎.w(

𝑒
)𝑗
?= UpdF(
?= UpdF(

𝑒
)𝑗

𝑒
)𝑗

𝛼.view (
𝑒

𝑗

1

−

)

, 𝛼.view (
𝑒

𝜎.view (
𝑒
7) output 1 if all validations are passed.

, 𝜎.view(
𝑒

−

)

)

𝑗

1

𝑒
)𝑗

∈

𝜎.view𝑒 ,

∀

𝑗

)

1
1 , 𝛼.tp𝑒, 𝛼.tp𝑒
−
+
𝑗
1
1 , 𝜎.tp𝑒, 𝜎.tp𝑒
−
+

1)

+

;

1)

+

Fig. 2: Equality Veriﬁcation Algorithm of ZKBoo.

VrfGen of Post-Quantum VRF via ZKBoo.

• (

vsk, vpk

1𝜆
) ←
1) Choose a secret key 𝑠

VrfGen

(

.

)
← D

and a random key
for the pseudo-random function F, and

k
← K
return vsk

k, 𝑠

.

)

← (

2) Compute the public key
= F

vpk := 𝛼 = F

k, vsk
)

(

k, 𝑠

.

)

(

4.2 Post-Quantum VRF Security Analysis

every input m.
,

Importantly, the proposed VRF isn’t based on hard problems
from number theory, and the hard problems the proposed VRF
relies on for security relate only to symmetric cryptographic
primitives that are thought to be secure against quantum at-
tacks, and quantum security can be guaranteed easily. Below,
we analyze uniqueness and pseudorandomness sketchily.
Uniqueness Analysis. The uniqueness property requires
there should be only one provable VRF output
that
outvrf
every
such that outvrf′ ≠
vpk, m,
(cid:0)
=
outvrf′, 𝜋vrf′))
outvrf∗,
the property
VrfVrfy
there is an
of uniqueness using a contradiction.
If
adversary that violates
the
≠ m
adversary can come up with a message m′(
)
stmt′
contains
given vsk. The
generated statement
vpk := 𝛼, outvrf′
:= 𝐻1 (
:= 𝜎 ′)
for ℎ′
, and proof
m′)
(
𝜋vrf′ contains 𝜋vrf′ =
:= 𝑧 ′)
chlg′
such that
(
:= 𝛽 ′ = 𝐻3 (
𝜎 ′)
an incorrect VRF output value outvrf′
is
vsk, ℎ′ = 𝐻1 (
computed for 𝜎 ′ = 𝐻2 (
and a different

outvrf∗, 𝜋vrf∗)(cid:1)
(
following VrfVrfy
(
outvrf∗, 𝜋vrf∗))

for
outvrf′, 𝜋vrf′)
the
vpk, m,

computational uniqueness,

(
. We prove

In particular,

:= 𝑐 ′, resp′

vpk, m,

m′))

for

(

(

(

𝑖
2 , 𝛼.stmt(
)

𝑖
3 , 𝛼.ct(
)

𝑖
1 , 𝛼.ct(
)

Fig. 3: Key Generation of Post-QuantumVRF via ZKBoo.

and

VrfEval of Post-Quantum VRF via ZKBoo.

.

.

)

m
)
k, 𝑠

VrfEval

outvrf, 𝜋vrf) ←
• (
1) Compute ℎ = 𝐻1 (
2) Regarding 𝛼 = F
(
𝑠, ℎ

vsk :=
k, 𝑠
,𝑚
(
(
)
, 𝜎 = 𝐻2 (
, and 𝛽 = 𝐻3 (
𝑠, ℎ
𝜎
)
) ∈ LF for a circuit F, and
𝜎 = 𝐻2 (
) ∈ L𝐻2 for a circuit 𝐻2, invoke the quality
of post-quantum ZKP system for the relation
, 𝜎 = 𝐻2 (
=
by
and the
(

L
)
(
inputting the statement stmt :=
witness wits := vsk = 𝑠, then obtain the proof of
knowledge of secret key to prove the output
(
is the correct hash output. In particular, invoke

𝑠, ℎ
𝛼, k, 𝜎, ℎ

𝛼, k, 𝜎, ℎ; 𝑠

: 𝛼 = F

)}
)

𝛼, 𝜎

k, 𝑠

{(

)

)

)

stmt, wits
)

←

resp

𝛼, k; 𝑠
)
𝜎, ℎ; 𝑠

ZKP.Prove𝐻 (
as depicted in Fig.1 to proceed relations
LF =
: 𝛼 = F
k, 𝑠
{(
(
=
: 𝜎 = 𝐻2 (
L𝐻2
{(
)
a computation integrity proof
𝜋vrf =
chlg := 𝑐, resp :=
𝛼.resp, 𝜎.resp
internally the challenge 𝑐 is involved.

)}
𝑠, ℎ

and

)}

))

(

(

, where

respectively, and return

3) Last return the output of veriﬁable random
𝛽, stmt
)

and the proof of

function outvrf =
correctness 𝜋vrf.

(

Fig. 4: Evaluation of Post-Quantum VRF via ZKBoo.

VrfVrfy of Post-Quantum VRF via ZKBoo.

•

VrfVrfy

1) verify ℎ ?= 𝐻1 (

vpk, outvrf)
;
)

m

((

, m, 𝜋vrf)

.

2) invoke the equality veriﬁcation of ZKBoo to

validate

stmt, 𝜋vrf)

ZKP.Verify𝐻 (
as depicted in Fig. 2 for relations
: 𝛼 = F
LF =
k, 𝑠
𝛼, k; 𝑠
)}
{(
(
)
: 𝜎 = 𝐻2 (
=
𝜎, ℎ; 𝑠
𝑠, ℎ
L𝐻2
{(
)}
stmt, 𝜋vrf)
3) Return 1 if ZKP.Verify𝐻 (

and

)

otherwise.

respectively;

= 1 holds, and 0

Fig. 5: Veriﬁcation of Post-Quantum VRF via ZKBoo.

message m′. Note that the correctness output of VRF outvrf
:= 𝛽 = 𝐻3 (
𝜎
via VrfEval is computed as outvrf
for the
)
corresponding 𝜎 = 𝐻2 (
vsk, ℎ := 𝐻1 (
. Since outvrf′ ≠ outvrf
m
))
(i.e., 𝛽 ′ ≠ 𝛽), we have 𝜎 ′ ≠ 𝜎, where 𝜎 ′ := 𝐻2 (
vsk, ℎ′ := 𝐻1 (
m′))
vsk, ℎ := 𝐻1 (
and 𝜎 := 𝐻2 (
for the same vsk. Now,
m
))
𝜋vrf′ =
chlg′, resp′)
for a challenge 𝑐 ′ and a response 𝑧 ′
(
= 1 supported by
vpk, outvrf′)
, m′, 𝜋vrf′)
ensures that VrfVrfy
((
= 1 of the
stmt :=
, 𝜋vrf′ =
𝑐 ′, 𝑧 ′))
𝛼, 𝜎 ′, 𝛽 ′)
the ZKP.Verify𝐻 (
(
(
equality of ZKBoo system.
VrfVrfy
(·)
),
𝜎.𝑎′(
, 𝛼.𝑎 (
) ,
𝑐 ′
, 𝜎.𝑎′(
)
· · ·
· · ·
←
𝑖
𝑖
𝑖
𝑖
𝑖
𝑖
) =
𝑖
1 , 𝛼.ct (
3 , 𝛼.ct (
2 , 𝛼.stmt(
1 , 𝛼.stmt(
2 , 𝛼.ct (
where 𝛼.𝑎 (
)
)
)
)
)
)
3 )
𝑖
𝑖
𝑖
𝑖
𝑖
, 𝜎.ct′(
, 𝜎.stmt′(
, 𝜎.stmt′(
, 𝜎.ct′(
, 𝜎.ct′(
and 𝜎.𝑎′(
)
)
)
)
3
2
3
2
1
Below, we use the extract 𝑐 ′ to perform validations as follows.
𝑐 ′(
𝑗
), 𝑐 ′(
such
if
1
) +
∈
{
∀
}
𝑖
𝑖
𝛼.ct (
, 𝛼.view (
, 𝛼.op (
Open
and
)𝑗
)𝑗 } ←
)𝑗 )
𝑖
𝑖
𝜎.ct (
, then continue;
Open
)𝑗 )
)𝑗
)𝑗 } ←
(
𝑖
𝑖
), 𝑐 ′(
𝑐 ′(
𝑗
such that
) +
∃

𝑖
𝛼.tp (
that
)𝑗
{
𝑖
, 𝜎.view(
𝜎.tp(
)𝑗
{
if
Otherwise,

ensures to extract the exact one challenge

𝐻
𝛼.𝑎 (
𝛼.stmt (
𝑖

1) Firstly, validate

(
, 𝜎.op (
1

(
𝜎.stmt′(
1

⊥ ←

∈ {

) =

}

k

(

(

)

1

1

𝑡

𝑡

)

)

𝑖

𝑖

𝑖

𝑖

𝑖

8

𝑖

𝑖

(

(

𝑖
)𝑗

and

𝜎.ct (

𝛼.ct (

Open

, then

, 𝛼.op (

, 𝜎.op (

𝜎.stmt (

(
𝑖
1 , 𝜎.stmt(
)

𝑖
Open
)𝑗 )
)𝑗
abort the validation.
2) Then validate Rec

)𝑗 )
⊥ ←
?= 𝛼.stmt
𝑖
𝑖
𝑖
𝛼.stmt (
2 , 𝛼.stmt (
1 , 𝛼.stmt (
)
)
)
3 )
?= 𝜎.stmt, if pass the
𝑖
𝑖
and Rec
2 , 𝜎.stmt (
)
)
3 )
validation, then continue the following validation; other-
wise, abort it.
), 𝑐 ′(
3) Next, validate if
∃
𝑖
𝑖
Output
and 𝜎.stmt(
)𝑗
)𝑗
)
continue; otherwise, then abort.

𝑖
such that 𝛼.stmt (
)𝑗
, then

) +
}
?= Output

𝜎.view (

𝛼.view (

∈ {

𝑐 ′(

?=

1

(

(

(

𝑗

𝑖

𝑖

𝑖

𝛼.w(

𝑒
)𝑗

and
?=

and

4) Finally,

validate

if

∀
UpdF(
𝑒
𝜎.w(
)𝑗

𝜎.w(

∈
𝑗
−

𝑒
)𝑗
𝛼.view (
𝑒
?= UpdF(

∀
𝜎.view𝑒 ,
𝑗

1

)

, 𝛼.view(
𝑒
1

𝑗

∈
validate

then
1
1 , 𝛼.tp𝑒, 𝛼.tp𝑒
−
+
𝑗
, 𝜎.view (
)
𝑒

)

1)
+
1
1 , 𝜎.tp𝑒, 𝜎.tp𝑒
−
+

𝑖

−

𝜎.view (
)
𝑒
5) output 1 if all validations are passed.
𝑖
is not identical to 𝜎.𝑎 (
vsk, ℎ = 𝐻1 (
m′))

:=
Notably, 𝜎.𝑎′(
vsk, ℎ′ = 𝐻1 (
. In addition, 𝐻2
𝐻2 (
is a random oracle, its output is random, and the probability
that it equals the unique value determined by its inputs
according that the right side of equation (4.1) is negligible.

) because of 𝜎 ′
m

≠ 𝜎 := 𝐻2 (

;

1)

+

))

)

)𝑗 )
𝛼.view𝑒

𝛼.w(

𝑒
)𝑗

𝑐 = 𝐻
?= 𝐻

1

𝛼.𝑎 (

) , 𝛼.𝑎 (

2

),

, 𝛼.𝑎 (

𝑡

)

1

𝜎.𝑎 (

, 𝜎.𝑎 (

𝑡

)

(

)
𝜎.𝑎′(
(4.1)
Hence, only one (i.e., 𝑐 ′ or 𝑐) satisﬁes the above validations.

· · ·
𝑡
, 𝛼.𝑎 (
)

, 𝜎.𝑎′(

𝛼.𝑎 (

k
),

· · ·

· · ·

· · ·

) ,

k

)

(

1

1

.

)

2

),

), 𝜎.𝑎 (
𝑡

))

𝑄 2

m′)

vsk, 𝐻1 (

vsk, 𝐻1 (
m
)

m
and ℎ′ = 𝐻1 (

Thus, we have arrived at our contradiction.
Collision-Resistance Analysis. Below, we prove the property
of collision-resistance using a contradiction. If 𝐻2 is a col-
𝜏-to-1) hash function that every output of
lision resistant
(
𝐻2 has at most 𝜏 preimage in 𝔾, we assume that if there
happens a collision, then 𝜎 = 𝐻2 (
should equal to
, where ℎ = 𝐻1 (
𝜎 ′ = 𝐻2 (
for
m′))
some m ≠ m′. In this setting, for every ℎ, there are at most 𝜏
possible ℎ′ values that can cause a collision. Because ℎ and ℎ′
are obtained via random oracle queries, then a pair that causes
a collision is unlikely to be found after 𝑄 queries to 𝐻1, as long
as the size of 𝔾 is larger than 𝜏
·
Pseudorandomness Analysis. Below we analyze the pseu-
dorandomness based on the collision-resistance hash func-
tion under the random oracle model. Depending on the
VRF deﬁnition, the pseudorandomness deﬁnition implies that
the pseudorandomness adversary does not know the secret
m, outvrf)
VRF key vsk, but must distinguish between pairs
where outvrf is the VRF hash output on input m, and pairs
where 𝑟 is a random value. This adversary knows the
m, 𝑟
(
)
public values vpk = F
k, vsk
, and it can easily compute
)
𝜎 = 𝐻2 (
and ℎ = 𝐻1 (
vsk, ℎ
for any m if he knows the
m
)
vsk. However, even vpk and ℎ are public but vsk is kept
privately, and 𝜎 = 𝐻2 (
vsk, 𝐻1 (
looks random, thus, the
pseudorandomness adversary cannot distinguish 𝛽
𝜎
)
from a randomness distribution because 𝛽0 is pseudorandom
in the range of 𝐻3.

𝐻3 (

2.
/

←

m

))

(

)

(

)

.

)

4.3 Post-Quantum VRF Evaluation

To evaluate the performance of VRF, we are primarily inter-
ested in understanding the time consumed in the generation
of the proposed signature followed by the hashing time and
the total time, including key generation, signing, proof of
zero-knowledge, veriﬁcation, and block formation, when the
number of blocks is considered as a part of the blockchain.

9

TABLE 3: Performance of Feasibly VRF via ZKBoo and ZKB++.

Scheme

KeyGen
Signing
Proof
Veriﬁcation

Scheme

KeyGen
Signing
Proof
Veriﬁcation

Scheme

KeyGen
Signing
Proof
Veriﬁcation

Scheme

KeyGen
Signing
Proof
Veriﬁcation

Scheme

ZKBoo
20-Round

ZKB++
20-Round

Output.Size

Execution.Time Output.Size

Execution.Time

256 bit
256 bit
245920 Byte
✗

< 1 ms
< 1 ms
24 ms
16 ms

256 bit
256 bit
128800 Bytes
✗

<1 ms
< 1 ms
24 ms
15 ms

40-Round

40-Round

Output.Size

Execution.Time Output.Size

Execution.Time

256 bit
256 bit
491840 Byte
✗

< 1 ms
< 1 ms
28 ms
18 ms

256 bit
256 bit
257600 Byte
✗

< 1 ms
< 1 ms
29 ms
17 ms

60-Round

60-Round

Output.Size

Execution.Time Output.Size

Execution.Time

256 bit
256 bit
737760 Byte
✗

< 1 ms
< 1 ms
35 ms
23 ms

256 bit
256 bit
386400 Byte
✗

< 1 ms
< 1 ms
36 ms
22 ms

80-Round

80-Round

Output.Size

Execution.Time Output.Size

Execution.Time

256 bit
256 bit
983680 Byte
✗

< 1 ms
< 1 ms
42 ms
28 ms

256 bit
256 bit
515200 Byte
✗

< 1 ms
< 1 ms
42 ms
25 ms

100-Round

100-Round

Output.Size

Execution.Time Output.Size

Execution.Time

KeyGen
Signing
Proof
Veriﬁcation

256 bit
256 bit
1249600 Byte
✗

< 1 ms
< 1 ms
50 ms
33 ms

256 bit
256 bit
644000 Byte
✗

< 1 ms
< 1 ms
50 ms
32 ms

To evaluate these overheads, we wrote a proof-of-concept
blockchain in C++. The developed code is evaluated on Intel®
Core™I5-8250U 8th Gen machine with 8GB RAM on an Asus
series workstation.

We provide implementations and experimental evalua-
tions of concrete quantum secure VRF using by integrating
the post-quantum zero-knowledge proof systems, such as
ZKBoo and ZKB++, as shown in Table 1. To our knowledge,
ZKBoo and ZKB++ are one of the hash-based NIZK protocols
known to exist in the random oracle model, it is based on the
“MPC-in-the-head” approach to zero-knowledge, and it can
generate (resp. verify) a non-interactive proof for the SHA-1
circuit in approximately 13ms (resp. 5ms), with a proof size
of 444KB. In our realization, to simulate the real-world scene,
we used SHA-256 for hashing and was built on top of the
ZKBoo and ZKB++ 5. ZKBoo and ZKB++ libraries are used
to prove knowledge of pre-images of SHA-256. The following
Table 3 gives results for the execution time and output size
of key generation, signing, proof, and veriﬁcation, which is

5. (https://github.com/Sobuno/ZKBoo)

illustrated in terms of time consumed per hash operation, and
it presented as an average value after looping 100 times for all
the execution modes.

Notably, ZKB++ is an improved version of ZKBoo with
NIZK proofs that are less than half the size of ZKBoo proofs,
and it shows that this size reduction comes at no extra
computational cost. Similarly, in our proof-of-concept real-
ization, the output size of VRF realized via ZKB++ is more
than halved than VRF realized by ZKBoo, not affecting the
computational complexity. As shown in Table 3, regarding the
execution time of algorithms, such as block formation, key-
generation, and signing, each operation is in 1 millisecond,
because of which the value of microseconds doesn’t make
any material difference. In addition, proof generation is the
dominant operation, which on average consumes more than
99.0% of the total execution time. Thus, we use the average
time in milliseconds to estimate the running time for these
sub-algorithms. These results help to understand the reach
of practical observations when such a system is deployed
in actual practice. The trade-off between the size and the

computational complexity will certainly require conﬁguration
considerations, and these results can help in understanding
such requirements.

5 APPLICATION 1: QUANTUM-SAFE DECENTRAL-
IZED RANDOM BEACON

A cryptographic beacon (also known as a randomness beacon)
is a service that provides a public source of randomness.
The beacon continuously emits new random data (a beacon
record) at a regular rate. If everybody agrees that there’s no
way to predict the following output from the beacon, it can
be relied on as a provider of fair random values. The random
values emitted by the beacon can trivially be used for any
public lottery, contract signing, voting protocols, and ZKP
systems, etc. These applications require random values that
cannot be predicted prior to being generated but are made
public after generation. Importantly, in the blockchain era,
many consensus protocols [6], [7], [39], [8] involve allocating
the creation of block creator, whose selection procedure most
often than not requires a method for collective randomness
sampling. Obliviously, random beacon also plays an integral
part in the design of new blockchain consensus protocols (e.g.,
PoS) for a fair and unpredictable distribution of validator
responsibilities. The basic reason is that each election begins
when public and unbiased random beacon publishes a uni-
form random number. Consequently, how to design the ver-
iﬁable, bias-resistant, and the unpredictable random number
has recently enjoyed increasing attention [4], [5], [42]. This
section gives our random beacon solution via the proposed
VRF while remaining secure in the quantum era.

5.1 Random Beacon Generation

An observation is that if blockchain nodes get different inputs
on building blocks, then forks will happen. Thus, to generate
uniform randomness, the most straightforward idea is to
obtain uniform randomness by hashing past blocks. But the
hashes of blocks can be subject to adversarial inﬂuence. For
example, the random number can be biased in a way so that
corrupted nodes are allowed to be selected more often. Thus,
no one can guarantee security when this kind of randomness
sources with adversarial bias are used for block proposer
selection.

To address this point, Snow White [6] proposed a novel
“two-lookback” mechanism to determine present and future
randomness depending on its own past blocks, which ad-
dresses this kind of a“randomness-biasing attacks” and “adap-
tive key selection attacks” simultaneously, but this approach
cannot guarantee perfect uniqueness for randomness as ex-
plained earlier. Ouroboros Paros randomness is secure for
block production [8] and inherits the incentive structure of
the Ouroboros family. In their approach, all block producers
have a VRF keys, which they register with locked stake,
and they depend on a central clock and operate a trusted
random beacon using VRF to board-cast a random num-
ber to all participants in each epoch. In Algorand [7], the
randomness (i.e., seed) published at round 𝑟 is determined
using VRF with the seed of the previous round 𝑟
1, e.g.,
−
𝑠𝑑𝑟 = 𝐻
is a deterministic

, where uSign

uSign

𝑟

(

𝑠𝑑𝑟
(

1)k

−

)

𝑠𝑑𝑟
(

1)

−

10

(·)

under the leader round 𝑟, and the initial
signature uSign
value of the seed 𝑠𝑑0 bootstraps seed selection. However, the
problem is that Algorand does not specify how to initialize
𝑠𝑑0.6 In that case, the participant who has set the initial seed
𝑠𝑑0 may have again launched a grinding attack to bias the
blockchain consensus protocol.

Indeed, secret randomness produced by these VRFs can
determine when they produce new blocks. A priori, there is
a risk that block producers could grind via VRF keys to bias
results. Thus, VRF inputs must include public randomness
created only after the VRF key. Therefore, during the epoch,
the fresh public on-chain randomness is created by hashing
together all the VRF outputs revealed in block creation. In this
way, we cycle between private but veriﬁable randomness and
collaborative public randomness. But an observation is that
these kinds of approaches rely on a trusted party. To avoid
reliance on a trusted party, a common approach is to use a
mechanism that veriﬁably allows the distributed computation
of an unpredictable and unbiased source of randomness. The
distributed VRFs are proposed recently, e.g., [42] a candidate
approach to bypass dependence on the central party. Addi-
tionally, how to construct a post-quantum distributed VRF
itself is an exciting research problem and deserves further
deep investigation.

5.2 Decentralized Random Beacon Generation

In this section, we resort to the distributed VRF from sym-
metric primitives to generate the quantum-safe decentralized
random beacon (DRB). Very recently, DRSs have recently gained
a lot of traction as a key component for leader(s) election in
decentralized public ledger technologies. Indeed, as discussed
in [42], a conventional DRB provides a way to agree on a
randomly chosen leader in a distributed approach for PoS
blockchains (e.g., Dﬁnity [39], Ethereum 2.0 [44], and Om-
niLedger [45]), without the need for a coordinator. Thus, in
this paper, following the research line of DRB, we give a
quantum-safe (veriﬁable) DRB approach. As we know, DRBs
are a particular case of veriﬁable multi-party computation
protocol, and they can be straightforwardly obtained from a
post-quantum (veriﬁable) distributed VRF.
Quantum-Safe DRB via Distributed VRF. Our goal is to pro-
vide a quantum-safe bias-resistant public randomness in the
familiar
-threshold security model in hash-based cryp-
tography and Byzantine consensus protocols. The quantum
security can be guaranteed by using hash-based cryptography,
as explained in the post-quantum VRF construction. Thus,
armed with these techniques, in our distributed-VRF based
DRB protocol, we consider the synchronous network where
messages are eventually delivered and a Byzantine adversary
-threshold security model. In this setting, we pick a
in
1 inputs, where 𝑓 is denoted as the
function with ﬁxed 𝑓
number of dishonest peers, 𝑡 = 𝑓
1 is the threshold of
veriﬁable secret sharing, and 𝑛 = 3𝑓
1 is denoted as the list
of peers that participate in DRB protocol.

𝑡, 𝑛
(

𝑡, 𝑛
(

+
+

+

)

)

• (

vsk, vpk
– Deal phase.

) ←

DVRF.DistKG

1𝜆

(

)

6. In Algorand, the authors mentioned “a random number, part of the

system description, and thus publicly known.”

0

=

𝛼𝑖,1𝑧

+ · · · +

mod 𝑞

𝛼𝑖,𝑡𝑧𝑡
(
2) The dealer 𝑆𝑖 selects a secret key vsk𝑖 := 𝑘𝑖 ←

1) The dealer (i.e., each node server) 𝑆𝑖 selects a 𝑡-
𝑡
𝑧𝑘 =
𝑘=0 𝛼𝑖,𝑘 ·
𝑧
degree random polynomial f𝑖 (
)
Í
over ℤ𝑞 for 𝛼𝑖,𝑘 ∈
ℤ𝑞.
𝛼𝑖,0 +
)
ℤ𝑞 and
sets 𝛼𝑖,0 = f𝑖 (
:= vsk𝑖. Next, the dealer computes
)
the corresponding public key vpk𝑖
and
secret key shares ssk𝑖, 𝑗 := f𝑖 (
𝑛. Then
the dealer 𝑆𝑖 broadcasts commitments cmt𝑖,𝑘 ←
= PRG
𝛼𝑖,𝑘 ·
𝑠𝑑
𝛼𝑖,𝑘)
of each coefﬁcient
Com
(
(
𝜆 for a
𝛼𝑖,𝑘 for 1
0, 1
𝑡 and the seed 𝑠𝑑
𝑘
≤
3𝜆,
0, 1
pseudorandom generator PRG :
and a random 𝑅

k, vsk𝑖)
(
𝑗
≤

}
→ {

for 1

) ⊕ (

= F

0, 1

3𝜆.

≤

≤

𝑅

}

)

)

𝑗

3) Output vpk𝑖,

– Reconstruction phase.

0, 1
∈ {
ssk𝑖, 𝑗 (cid:9) 𝑗

}
𝑛

∈ [

(cid:8)

and

(cid:8)

]

← {
𝜆
{
}
cmt𝑖,𝑘 (cid:9)𝑘

.

]

𝑡
∈ [

1) Validate
𝑡
𝑘=1 (
Í

𝑡
𝑗𝑘
cmt𝑖,𝑘 ) · (
𝑘=1(
Í
= PRG
𝑗𝑘
cmt𝑖,𝑘 ) · (
)
2) Compute vsk𝑖 =
keep it privately.

?= PRG
𝑅
𝑓𝑖 (
𝑠𝑑
as
)
(
) ⊕ (cid:0)
(cid:1)
𝑡
𝑅(cid:17).
𝑘=1 𝛼𝑖,𝑘 ·
𝑠𝑑
) ⊕ (cid:16)(cid:0) Í
(
=
𝑖
QUAL 𝑓𝑗 (
QUAL ssk𝑖, 𝑗 and
𝑗
Í
3) Output the veriﬁcation key vvk𝑖 = F

𝑗
) ·
𝑗𝑘
(cid:1) ·

Í

)

∈

∈

𝑗

(
QUAL F

k, vsk𝑖 )
(

and the
=

k, vsk𝑖 )

)
vsk𝑖, ℎ

.
)
stmt; wits

∈

É𝑖

k, vsk∗

QUAL vsk𝑖 )

= F
)
DVRF.PartialEval

common public key vpk∗ =
.
F
𝑖
(Í
𝜋vrf, outvrf) ←
vsk𝑖, vvk𝑖, m
• (
(
and outvrf𝑖 := 𝑣𝑖 = 𝐻2 (
1) Compute ℎ = 𝐻1 (
)
2) Execute the quantum-safe ZKP Prove𝐻 (
:= 𝑣𝑖

m

(

∈

(

:=

, vvk𝑖

vsk𝑖, ℎ

for stmt

k, vsk𝑖 ))

ℎ, outvrf𝑖 = 𝐻2 (
(
: vvk𝑖 := F

to prove outvrf𝑖
vsk𝑖
F
lations

)
is the correct output given
:=
and wits := vsk𝑖 . In particular, two re-
k, vsk𝑖)o and
)o are pro-
L𝐻2
ceeded respectively, as depicted in Fig.1. Then re-
turn a computation integrity proof 𝜋vrf𝑖 =
:=
𝑖, chlg𝑖
(
𝑐𝑖, resp𝑖
, where internally
the challenge 𝑐𝑖 is involved.

LF =
n(
outvrf𝑖, ℎ; vsk𝑖)
n(

: outvrf𝑖 := 𝐻2 (

vvk𝑖 .resp, outvrf𝑖 .resp

vvk𝑖, k; vsk𝑖 )

(
vsk𝑖, ℎ

:=

))

=

(

)

•

•

𝜀

DVRF.Combine
(
1) Parse list 𝜀 =

vpk∗, vvk∗, m, 𝜀
n𝜋vrf 𝑗1, 𝜋vrf 𝑗2,

.

)

2) Then,

|

|

𝛽

𝑡

+

Í

· · ·

· · ·

|𝜀 |

, 𝜋vrf 𝑗

| ≥

o of

, vvk𝑗

𝜀
∈ [ |
𝑖1,
{

. Notably, vvk∗ =
𝐼 =

|𝜀 |
identify an index subset

|]
· · ·
it satisﬁes the veriﬁcation of ZKP,

such that
ZKP.Verify𝐻 (
for
relations
ZKP.Verify𝐻 (
every 𝑖
∈
the next step. If no such subset exists, outputs 0.

1
partial function evaluation candidates originating from
𝜀
different servers, and obtains veriﬁcation keys
|
vvk𝑗1, vvk𝑗2,
vvk𝑗𝛽 .
, 𝑖𝑡
1}
+
i.e.,
2
If
and
L𝐻2
= 1 (i.e., accept) holds for
𝑖, chlg𝑖, resp𝑖 )
, then continue
(
= 𝐻2 (
vsk∗, ℎ
m
)
can be done from the shares of any qualiﬁed set QUAL
of participants by calculating the Lagrange interpola-
tion 𝑣∗ =
and
vsk𝑖 =
𝑗

stmt, 𝜋vrf)
LF
stmt, 𝜋vrf)
𝐼 , where 𝜋vrf =

as depicted in Fig.
respectively.

for ℎ = 𝐻1 (

vsk𝑖, ℎ

))

)

∈

𝑗

3) Reconstruct outvrf∗ := 𝑣∗ (

∈

∈

Í

, where 𝑣𝑖 = 𝐻2 (
𝜆0,𝑖,𝐼 )
𝑣𝑖 ·
𝑖
𝐼 (
Í
=
𝑖
QUAL 𝑓𝑗 (
QUAL ssk𝑖, 𝑗 .
)
Í
𝜋vrf𝑖 }𝑖
4) Output 𝑣∗ and 𝜋vrf∗ ← {
𝐼 .
DVRF.Vrfy
vpk∗, vvk∗, m; 𝜋vrf∗)
(
1) Parse 𝜋vrf∗ =
{
𝑖, chlg𝑖, resp𝑖 )
(

𝐼 such that
𝐼 .
stmt, 𝜋vrf)
2) Validate ZKP.Verify𝐻 (

𝜋vrf𝑖 }𝑖
∈
for 𝑖
∈

= 𝑡

+

∈

𝐼

|

1, where 𝜋vrf =

|
?= 1 by revoking the

11

∈

𝐼 (

𝑖
Í

veriﬁcation Verify𝐻 (·)
?=
𝑣𝑖 ·

of the quantum-resistant ZKP.
𝜆0,𝑖,𝐼 )
3) Check if 𝑣∗
.
Our proposed unbiasable quantum-safe DRB protocol
ensures the properties quantum security, unbiasability, unpre-
dictability, and availiability. Additionally, the proposed DRB
is practical as it only depends on hash-based functions with
small scale communication overhead. The post-quantum se-
curity is clear because the unbiasable quantum-safe DRB is
based on the post-quantum VRF, so we ignore the detailed
analysis. Below, we give a high-level analysis for the other
properties.

•

•

•

𝑓

+

+

Unpredictability implies that no party (includes the ad-
versarial nodes) could predict (or precompute) anything
about the future random output values. If the participants
follow the DRB protocol, the ﬁnal random number 𝑣∗
contains 𝑛′ ≥
1 secrets. We require there are at most
𝑓 malicious peers. Thus an adversary cannot obtain the
underlying secret before it is revealed or recovered during
the speciﬁc round. Please refer to [5, Theorem 3] for
details.
Availability (also known as liveness) implies that no single
party (including the colluding adversary) is allowed to
prevent progress. The property is obtained because if the
threshold 𝑡 = 𝑓
1 of the veriﬁable secret-sharing is given,
then at least 𝑡 honest nodes out of the total 2𝑓
1 positive
voters are able to collaborate to recover the secrets.
Unbiasability means a random beacon value is statistically
indistinguishable from a uniformly random. Notably, the
threshold of veriﬁable secret sharing 𝑡 = 𝑓
1 is given
in advance, preventing dishonest participants from re-
covering the honest secrets. If at least 𝑡 honest partic-
ipants share messages successfully, then the Byzantine
agreement (with at least 2𝑓
1 participants) will achieve
+
the validity of these shares as discussed in availability. In
this case, each honest participant could recover others’
secret shares. Further, the Byzantine agreement ensures
that all honest participants generate a consistent copy
of the randomness number. Thus 𝑛′ > 𝑓 secrets will be
𝑓 , meaning the
recovered after the barrier point or 𝑛′ ≤
protocol fails. Thus, we say the protocol is to prevent the
adversary from biasing the random output.

+

+

6 APPLICATION 2: QUANTUM-SAFE PROOF OF
STAKE CONSENSUS PROTOCOL

Obtaining the quantum-safe blockchain straightforwardly
from the existing PoW and PoS is non-trivial because the
existence of blockchain consensuses, including PoW and PoS,
are designed upon the traditional hard-problem assumptions
(i.e., cryptographic puzzles) without the property of quantum
resistance. In essence, PoS consensus protocols (e.g., Snow
White [6], DFINITY [39], and Algorand [7] etc) are similar
to PoW protocols to some extent, because they are from
proof systems, and the participants elect the creator who can
create the next block. In particular, regarding chain-based
leader election in PoS consensus, Ouroboros [40] replaces
energy-consuming cryptographic puzzles by ﬁnding a solu-
tion (i.e., 𝜎𝑖 = Sign𝑠𝑘𝑖 (
to satisfy the veriﬁcation
= 1 for the state st𝑖 =
requirement of Vrfy𝑝𝑘𝑖 (

st𝑖, dt𝑖, slot𝑗 ))
𝜎𝑖,

st𝑖, dt𝑖, slot𝑗 ))

(

(

−

B𝑖

1)

𝐻
, where the signature is the existential unforgeability
under chosen message attack resistance scheme. Similarly,
the lottery-based consensus mechanism (e.g., Algorand [7])
is based on a fast Byzantine agreement protocol, and the
agreement is not performed between all users in the network.
Instead, it is conﬁned to a small randomly chosen committee
of users for each round. Algorand pioneered the use of VRF
for secret encryption and lottery to run a consensus agree-
ment with the election committee. This enables the Algorand
blockchain to achieve the scale and performance required
to support millions of users. The core election process in
< T,
Algorand [7] can be expressed as VRF
where the signature 𝜎 is a result of a (valid) payment pay
relative to the stake (or the transfer amounts of money units)
𝑎. In that case, we explore the utility of the proposed quantum-
secure VRF in the lottery-based Algorand.

, round, 𝑝𝑘, 𝜎

B𝑖 )

ℎ
(

(

)

To obtain the quantum-safe PoS, we trim the quantum-
secure VRF inequality by denoting the difﬁculty value dynam-
ically as the product of the stake owned by each elector and
the target value ﬁxed by the system. Further, following the
methodology of Algorand, every user performs secret self-
selection based on his/her VRF secret key for each block. If
the quantum-secure VRF value that the user obtains is less
than some threshold, then the user is selected to serve on the
committee to perform an agreement for the block. Then, in
each round, each node needs to check to evaluate a quantum-
secure VRF to check whether they have been sampled as part
of that round’s committee. The number of committee mem-
bers is binomial (i.e., depending on the stake distribution), so
the amount of work that needs to be done to verify the other
committee members’ messages is also binomial.

(

k

vsk

stakes
)

Evaluation of Transaction. We implement a proof of concept
of our scheme to compare against the Algorand VRF. Our
evaluation indicates that our construction does not introduce
any prohibitive overheads, further, the proposed constructions
are practiced even today. For instance, the transmission of the
overhead introduced per every block is an additional 824KB
which accounts for around 8% of the 10MB Algorand block
size. To evaluate the block formation for quantum-secure
PoS consensus, when the number of blocks is considered
as a part of the blockchain. The prover program takes as
input the secret key and simulated stakes, then the prover
program will generate the proof of computation of 𝐻
vsk
)
and 𝐻
using ZKBoo or ZKB++. In our proof of
concept implementation, proof generation using ZKB++ takes
an additional 61 milliseconds overhead when comparing with
the Algorand VRF. Meanwhile, the veriﬁer will check the
proof to be sure that the prover knows the pre-image of vsk
and owns stakes. Notably, the veriﬁcation step is the most
time-consuming part. In PoS-blockchain, the results will vary
as per the number of rounds of ZKBoo (or ZKB++) used
in each round of every epoch in the underlying protocol.
This can be understood in Table 3, which shows that with
additional rounds, the security will increase for a system using
either of the approaches. There is a trade-off that for every
epoch in PoS, the rounds of ZKBoo (or ZKB++) will also
cause execution overheads. However, given the advantages of
security and not so tighter impact on the performance, these
solutions can be considered for implementing quantum-safe

(

12

blockchains.

We emphasize that designing a practical post-quantum
VRF for quantum-safe PoS consensus is an important urgent
open problem. First of all, blockchain systems should be
long-lived by design. From their current deployments, we
know that any (even purely technical) protocol-level change
is challenging to be introduced in practice and may result in
a platform fork, where part of the community “believes” in
the old system (without the change) and other parts in the
new system (with the change applied).7 Secondly, due to their
potential and promises, the security of blockchain systems
should be treated critically. Even though one could argue that
quantum computing is not a short-term threat, we stress that
due to deployability and governance of these systems it may
be challenging to update them in the future.

7 CONCLUSION

The focus of this work is to explore the probability of how
to design a post-quantum random beacon and PoS consensus
layer. Therefore, the crux of fulﬁlling the main goal is turning
into how to construct a practical post-quantum VRF. Inspired
by the relationship between the unique signature and VRF, we
started with the quantum-resistant hash-based signature and
integrated the signature with the post-quantum ZKP system
to obtain a post-quantum VRF. More speciﬁcally, a quantum-
resistant PoS consensus framework is instantiated with our
proposed post-quantum VRF by combining the hash func-
tions and quantum-secure ZKP from symmetric primitives.
Furthermore, we rigorously analyzed and proved the security
of our construction. Additionally, we implemented a proof of
concept of the system supported by the ZKBoo and ZKB++,
and our conducted experiments indicate that the scheme is
deployable even as for today.

Notably, deﬁning the application layer and its security is
out of scope for this work. However, in the future, we would
like to extend our system by a post-quantum application
layer, where user transactions are also guaranteed quantum-
resistant without introducing prohibitive overheads. Further,
we just provided a proof-of-concept realization. The existing
post-quantum ZKP system can be used in our VRF construc-
tion, such as Ligero and ZK-STARK. We leave these works in
the future.

REFERENCES

[1] H. Wang, Q. Wang, and D. He, “Blockchain-based private provable
data possession,” IEEE Transactions on Dependable and Secure Comput-
ing, pp. 1–1, 2019, dOI: 10.1109/TDSC.2019.2949809.

[2] X. Li, J. Xu, X. Fan, Y. Wang, and Z. Zhang, “Puncturable signa-
tures and applications in proof-of-stake blockchain protocols,” IEEE
Transactions on Information Forensics and Security, pp. 1–1, 2020, dOI:
10.1109/TIFS.2020.3001738.

[3] L. Chen, L. Chen, S. Jordan, Y.-K. Liu, D. Moody, R. Peralta,
R. Perlner, and D. Smith-Tone, Report on post-quantum cryptography.
US Department of Commerce, National Institute of Standards and
Technology, 2016.
I. Cascudo and B. David, “SCRAPE: scalable randomness attested
by public entities,” in Proc. ACNS 2017, D. Gollmann, A. Miyaji, and
H. Kikuchi, Eds., vol. 10355, 2017, pp. 537–556.

[4]

7. In fact, such forks happened to mainstream platforms like Bitcoin or

Ethereum.

13

[28] E. Alkim, P. S. L. M. Barreto, N. Bindel, P. Longa, and J. E. Ricardini,
“The lattice-based digital signature scheme qtesla,” IACR Cryptology
ePrint Archive, Report2019/85, 2019, https://eprint.iacr.org/2019/085.
J. Rijneveld, S. Samardjiska, and
P. Schwabe, “From 5-pass mq-based identiﬁcation to mq-
based signatures,” in Proc. Asiacrypt 2016, 2016, pp. 135–165,
http://cryptojedi.org/papers/#mqdss.

[29] M.-S. Chen, A. H ¨ulsing,

[30] M. Chen, W. Li, B. Peng, B. Yang, and C. Cheng, “Implementing 128-
bit secure MPKC signatures,” IEICE Transactions, vol. 101-A, no. 3,
pp. 553–569, 2018, http://eprint.iacr.org/2017/636.

[31] T. Espitau, P. Fouque, B. G´erard, and M. Tibouchi, “Loop-abort faults
on lattice-based ﬁat-shamir and hash-and-sign signatures,” in Proc.
SAC 2016, 2016, pp. 140–158.

[32] T. G ¨uneysu, V. Lyubashevsky, and T. P ¨oppelmann, “Practical lattice-
based cryptography: A signature scheme for embedded systems,” in
Proc. CHES 2012, 2012, pp. 530–547.

[33] D. J. Bernstein, D. Hopwood, A. H ¨ulsing, T. Lange, R. Niederhagen,
L. Papachristodoulou, M. Schneider, P. Schwabe, and Z. Wilcox-
O’Hearn, “SPHINCS: practical stateless hash-based signatures,” in
Proc. EUROCRYPT 2015, Part I, 2015, pp. 368–397.

[34] D. J. Bernstein, C. Dobraunig, M. Eichlseder, S. Fluhrer, S.-L. Gazdag,
A. H ¨ulsing, P. Kampanakis, S. K¨olbl, T. Lange, M. M. Laurid-
sen, F. Mendel, R. Niederhagen, C. Rechberger, J. Rijneveld, and
P. Schwabe, “Sphincs+,” in SPHINCS+, 2017.

[35] D. Boneh, S. Eskandarian, and B. Fisch, “Post-quantum EPID signa-
tures from symmetric primitives,” in Proc. CT-RSA 2019, 2019, pp.
251–271.

[36] Y. Ishai, E. Kushilevitz, R. Ostrovsky, and A. Sahai, “Zero-knowledge
from secure multiparty computation,” in Proc. 39th ACM STOC 2007,
2007, pp. 21–30.

[37] M. O. Rabin, “Transaction protection by beacons,” J. Comput. Syst.

Sci., vol. 27, no. 2, pp. 256–267, 1983.

[38] R. Dingledine, N. Mathewson, and P. F. Syverson, “Tor: The second-
generation onion router,” in Proc. 13th USENIX 2004. USENIX, 2004,
pp. 303–320.

[39] T. Hanke, M. Movahedi, and D. Williams, “Dﬁnity technol-
system,” in arxiv.org, 2018,

consensus

ogy overview series
https://arxiv.org/pdf/1805.04548.pdf.

[40] A. Kiayias, A. Russell,
“Ouroboros: A provably
protocol,” in Proc. CRYPTO 2017, Part
https://eprint.iacr.org/2016/889.pdf.

B. David,
secure

proof-of-stake

and R. Oliynykov,
blockchain
I, 2017, pp. 357–388,

[41] P. Schindler, A. Judmayer, N. Stifter, and E. R. Weippl, “Hydrand: Ef-
ﬁcient continuous distributed randomness,” in 2020 IEEE Symposium
on Security and Privacy, SP 2020, San Francisco, CA, USA, May 18-21,
2020.

IEEE, 2020, pp. 73–89.

[42] D. Galindo, J. Liu, M. Ordean, and J.-M. Wong, “Fully distributed
veriﬁable random functions and their application to decentralised
random beacons,” Cryptology ePrint Archive, Report 2020/096,
2020.

[43] S. Goldberg, M. Naor, D. Papadopoulos, and L. Reyzin, “NSEC5 from
elliptic curves: Provably preventing DNSSEC zone enumeration with
shorter responses,” IACR Cryptology ePrint Archive, vol. 2016, p. 83,
2016.

[44] V. Buterin, “Ethereum 2.0 mauve paper,” 2018. [Online]. Available:

https://wiki.polkadot.network/docs/en/learn-randomness

[45] E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly, E. Syta, and
B. Ford, “Omniledger: A secure, scale-out, decentralized ledger via
sharding,” in Proc. IEEE SP 2018.
IEEE Computer Society, 2018, pp.
583–598.

[5] E. Syta, P. Jovanovic, E. Kokoris-Kogias, N. Gailly, L. Gasser, I. Khofﬁ,
M. J. Fischer, and B. Ford, “Scalable bias-resistant distributed ran-
domness,” in Proc. IEEE SP 2017.
IEEE Computer Society, 2017, pp.
444–460.

[6] P. Daian, R. Pass, and E. Shi, “Snow white: Robustly reconﬁgurable
consensus and applications to provably secure proofs of stake,” in
Proc. FC 2019, 2019.
S. Micali, “ALGORAND: the efﬁcient and democratic ledger,” CoRR,
abs/1607.01341, 2016, http://arxiv.org/abs/1607.01341.

[7]

[8] B. David, P. Gazi, A. Kiayias, and A. Russell, “Ouroboros praos: An
adaptively-secure, semi-synchronous proof-of-stake blockchain,” in
Proc. EUROCRYPT 2018, Part II, 2018, pp. 66–98.

[9] M. Chase, D. Derler, S. Goldfeder, C. Orlandi, S. Ramacher,
C. Rechberger, D. Slamanig, and G. Zaverucha, “Post-quantum zero-
knowledge and signatures from symmetric-key primitives,” in Proc.
ACM SIGSAC CCS 2017, 2017, pp. 1825–1842.

[10] J. Katz, V. Kolesnikov, and X. Wang, “Improved non-interactive zero
knowledge with applications to post-quantum signatures,” in Proc
ACM SIGSAC CCS 2018, 2018, pp. 525–537.

[11] E. Kiltz, V. Lyubashevsky, and C. Schaffner, “A concrete treatment
of ﬁat-shamir signatures in the quantum random-oracle model,” in
Proc. EUROCRYPT 2018, Part III, vol. 10822, 2018, pp. 552–586.

[12] D. Papadopoulos, D. Wessels, S. Huque, M. Naor,

J. Vˇcel´ak,
L. Reyzin, and S. Goldberg, “Making nsec5 practical
for
dnssec,” Cryptology ePrint Archive, Report 2017/099, 2017,
https://eprint.iacr.org/2017/099.

[13] S. Goldwasser and R. Ostrovsky, “Invariant signatures and non-
interactive zero-knowledge proofs are equivalent (extended ab-
stract),” in Advances in Cryptology - CRYPTO 1992, 1992, pp. 228–245.
[14] S. Micali, M. O. Rabin, and S. P. Vadhan, “Veriﬁable random func-

tions,” in Proc. 40th FOCS 1999, 1999, pp. 120–130.

[15] L. Kohl, “Hunting and gathering - veriﬁable random functions from
standard assumptions with short proofs,” in Proc. PKC 2019, Part II,
vol. 11443, 2019, pp. 408–437.

[16] S. Yamada, “Asymptotically compact adaptively secure lattice ibes
and veriﬁable random functions via generalized partitioning tech-
niques,” in Proc. CRYPTO 2017, Part III, vol. 10403, 2017, pp. 161–193.
[17] M. Buser, R. Dowsley, M. F. Esgin, S. K. Kermanshahi, V. Kuchta,
J. K. Liu, R. Phan, and Z. Zhang, “Post-quantum veriﬁable random
function from symmetric primitives in pos blockchain,” IACR
Cryptol. ePrint Arch., vol. 2021, p. 302, 2021. [Online]. Available:
https://eprint.iacr.org/2021/302

[18] I. Giacomelli, J. Madsen, and C. Orlandi, “Zkboo: Faster zero-
knowledge for boolean circuits,” in Proc. 25th USENIX Security 2016,
2016, pp. 1069–1083.

[19] S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam, “Ligero:
Lightweight sublinear arguments without a trusted setup,” in Proc.
ACM SIGSAC CCS 2017, 2017, pp. 2087–2104.

[20] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev, “Scalable,
transparent, and post-quantum secure computational
integrity,”
IACR Cryptology ePrint Archive, vol. 2018, p. 46, 2018. [Online].
Available: http://eprint.iacr.org/2018/046

[21] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P.
Ward, “Aurora: Transparent succinct arguments for R1CS,” in Proc.
EUROCRYPT 2019, 2019, pp. 103–128.

[22] J. Bootle, A. Cerulli, E. Ghadaﬁ, J. Groth, M. Hajiabadi, and S. K.
Jakobsen, “Linear-time zero-knowledge proofs for arithmetic circuit
satisﬁability,” in Proc. ASIACRYPT 2017, 2017, pp. 336–365.

[23] M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn, “Sonic:
Zero-knowledge snarks from linear-size universal and updatable
structured reference strings,” IACR Cryptol. ePrint Arch., vol. 2019,
p. 99, 2019. [Online]. Available: https://eprint.iacr.org/2019/099
[24] L. Ducas, V. Lyubashevsky, and T. Prest, “Efﬁcient identity-based
encryption over NTRU lattices,” in Proc. ASIACRYPT 2014, Part II,
2014, pp. 22–41.

[25] L. Ducas, A. Durmus, T. Lepoint, and V. Lyubashevsky, “Lattice
signatures and bimodal gaussians,” in Proc. CRYPTO 2013, Part I,
2013, pp. 40–56.

[26] P.-A. Fouque, J. Hoffstein, P. Kirchner, V. Lyubashevsky, T. Pornin,
T. Prest, T. Ricosset, G. Seiler, W. Whyte, and Z. Zhang, “Falcon:
Fast-fourier lattice-based compact signatures over ntru,” in falcon-
sign, 2017, https://falcon-sign.info/.

[27] L. Ducas, E. Kiltz, T. Lepoint, V. Lyubashevsky, P. Schwabe, G. Seiler,
and D. Stehl´e, “Crystals-dilithium: A lattice-based digital signature
scheme,” IACR Trans. Cryptogr. Hardw. Embed. Syst., vol. 2018, no. 1,
pp. 238–268, 2018.

