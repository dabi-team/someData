2
2
0
2

r
a

M
1
3

]

R
C
.
s
c
[

1
v
7
5
0
0
0
.
4
0
2
2
:
v
i
X
r
a

ElectAnon: A Blockchain-Based, Anonymous, Robust and
Scalable Ranked-Choice Voting Protocol

CEYHUN ONUR and ARDA YURDAKULâˆ—, BoÄŸaziÃ§i University, Department of Computer Engineering,
Turkey

Remote voting has become more critical in recent years, especially after the Covid-19 outbreak. Blockchain
technology and its benefits like decentralization, security, and transparency have encouraged remote voting
systems to use blockchains. Analysis of existing solutions reveals that anonymity, robustness, and scalability
are common problems in blockchain-based election systems. In this work, we propose ElectAnon, a blockchain-
based, ranked-choice election protocol focusing on anonymity, robustness, and scalability. ElectAnon achieves
anonymity by enabling voters to cast their votes via zero-knowledge proofs anonymously. Robustness is
realized by removing the direct control of the authorities in the voting process by using timed-state machines.
Results show that ElectAnon is scalable amongst existing works as it reduces the gas consumption up to 89%
compared to previous works. The proposed protocol includes a candidate proposal system and swappable
tallying libraries. An extension is also proposed to minimize the trust assumption on election authorities. Our
code is available on https://github.com/ceyonur/electanon.

Additional Key Words and Phrases: elections, voting systems, i-voting, blockchains, distributed systems, smart
contracts, zero-knowledge proofs

1 INTRODUCTION
The recent COVID-19 pandemic has pushed existing systems and procedures to be implemented
remotely. Legacy election systems, which oblige voters to go to a specific place to cast a ballot,
have also been impacted by the pandemic. For example, almost half of the votes were cast through
mail voting in the US 2020 presidential election [9]. Internet voting, or simply i-voting, has enabled
voters to cast their ballots remotely, unlike those legacy voting systems which require voters to
show up in a specific place like voting booths. Research shows that internet voting can be a better
solution in pandemic periods, as it can give faster results and be more cost-effective when compared
to mail voting [20] [19].

The i-voting brings possible advantages like reduced operational costs for elections, time-saving,
increased voter participation, and improved transparency in elections. Estonia and Switzerland are
two early adopters of i-voting in nationwide government elections [4]. An Estonian governmental
agency, Enterprise Estonia (EAS), reported that the i-voting saved approximately 11,000 working
days cumulatively in the 2011 Estonian parliamentary election [35]. The same report mentions that
the saved costs were roughly equal to â‚¬504,000.

Blockchain has emerged as a new paradigm to solve concerns like censorship and single point
of failure using a decentralized infrastructure. Blockchain technology offers distributed, secure,
privacy-preserving, and immutable ledgers. These innovations are found to be very suitable for
voting systems [16]. Many existing blockchain-based applications use voting mechanisms, such as
decentralized autonomous organizations (DAOs) [11]. We think that just as blockchains can be
helpful for voting systems, voting systems can also be beneficial for blockchains.

In this work, we analyze and discuss secure election requirements along with state-of-the-art
solutions in blockchain-based election systems. Analyzing existing solutions has shown us that
anonymity, robustness, and scalability are common problems. They cannot achieve anonymity
because election authorities can know voter identities during voting. Robustness is also not assured
as most of the protocols are disruptable in the voting process or require additional assistance from

Authorsâ€™ address: Ceyhun Onur, ceyhun.onur@boun.edu.tr; Arda Yurdakul, yurdakul@boun.edu.tr, BoÄŸaziÃ§i University,
Department of Computer Engineering, Istanbul, Turkey, 34342.

 
 
 
 
 
 
2

Ceyhun Onur and Arda Yurdakul

authorities to tally votes. Most of the works use complex encryption and decryption schemes to
preserve privacy. We find that these complex schemes are inefficient for blockchains and cause
high voting transaction costs, making existing systems unscalable.

In the light of these analyses, we propose ElectAnon, a blockchain-based ranked-choice election
protocol focusing on anonymity, robustness, and scalability. We aim to achieve privacy through
anonymity in the proposed protocol using zero-knowledge proofs. This not only brings a novel so-
lution for privacy issues but also increases the scalability by replacing complex encryption schemes
with zero-knowledge proof schemes, which are more optimized and efficient for blockchains.
ElectAnon minimizes manual transitions between election phases to achieve robustness. ElectAnon
aims to reduce voting gas costs to increase scalability.

Our main contributions in this work are presented as follows:

â€¢ We gather known secure election requirements and extend them. Anonymity is derived
from existing Privacy requirements. The current definition of Robustness is expanded by
adding Autonomy to it. Scalability is also redefined and included in blockchain-based election
requirements.

â€¢ A privacy-preserving, anonymous, blockchain-based voting protocol is proposed. The proto-

col fulfills the discussed election requirements.

â€¢ The protocol inherits a scalable ranked-choice voting system to conduct more democratized

elections.

â€¢ A candidate proposal system is included in the protocol to provide an end-to-end decentralized

election experience.

â€¢ A modular and algorithm-agnostic mechanism is used in tallying to switch between dif-
ferent methods easily. Two ranked-choice tallying methods, Borda Count and Tideman, are
implemented and analyzed.

â€¢ The Merkle Forest extension is proposed for adjusting trust assumptions and conducting even

more trustless election environments.

We used Ethereum Virtual Machine (EVM) [8] based smart contracts and an EVM-based zero-
knowledge tool called Semaphore [15] in our implementations. Our work supports other EVM-
based blockchain platforms. ElectAnon can be especially beneficial for decentralized autonomous
organizations (DAOs) because of its inherently democratic voting protocol and the ability to work
with existing EVM-based smart contracts.

Performance tests are conducted in the Ethereum and Avalanche local test networks to measure
the scalability of the implemented solution. We see that our work can run feasibly up to 100,000
voters. Moreover, we show our work can increase the number of voters indefinitely with increased
costs. Test results show that our work reduces the total election gas consumption by 89% compared
to existing solutions.

2 BACKGROUND AND PRELIMINARIES

2.1 Blockchain and Ethereum
The pioneer whitepaper of blockchain technology, Bitcoin, was published in 2008 by an anonymous
identity, Satoshi Nakomoto [28]. Bitcoin proposes secure, agreeable and decentralized asset transfers
in peer-to-peer networks. Bitcoin brought a groundbreaking approach to asset transfers with modern
cryptography techniques. It does not only offer a way to decentralize asset transfers but also reduce
transaction costs in comparison to traditional banking. Bitcoin also brings a rewarding system
called Proof of Work to incentivize network participants to contribute to network security actively.
A fee in every transfer (transaction) is deducted as a reward. Bitcoin has some basic scripting to

ElectAnon: A Blockchain-Based, Anonymous, Robust and Scalable Ranked-Choice Voting Protocol

3

support features like time-locking transactions and multi-owner transactions. However, this has
turned out insufficient to support many application use cases.

Vitalik Buterin proposed Ethereum in 2014 to address issues with Bitcoin [8]. Ethereum aims to
become a global and decentralized computer that can run many different applications called smart
contracts [8]. Ethereum has been a massive success since its release in 2015. Smart contracts are
applied in various industries like finance, logistics, insurance, entertainment and art. The article
reports that the number of smart contracts deployed on the Ethereum network was almost 1.5
million in 2020 [33]. Today, it remains the second-largest cryptocurrency, just one place behind
Bitcoin.

2.2 Decentralized Autonomous Organizations
Decentralized Autonomous Organization (DAO) is yet another blockchain concept in recent years.
DAO can be defined as "an organization that requires no central management"[11]. In DAOs,
organizational decisions are made through proposals and elections conducted with smart contracts
in the blockchain. Each proposal defines an administrative operation like hiring new employees
and managing resources. DAOs distribute tokens to investors as voting power. A recent article
shows that the DAO member number peaked at 700,000 in September 2021 [2].

2.3 Zero-Knowledge Proofs and zk-SNARKs
Zero-Knowledge proofs provide a way to prove the existence of the knowledge without revealing
the knowledge itself. Use cases include anonymous authorizations, private payments, computation
off-loading and electronic voting [32] [26].

Zero-Knowledge Succinct Non-Interactive Argument of Knowledge or simply zk-SNARK brought
an efficient zero-knowledge protocol that reduces the number of rounds to verify proofs [32].
zk-SNARK proofs are "succinct" and can be verified in milliseconds, and their proof sizes can be as
small as a few hundred bytes long.

zk-SNARKs are widely used in blockchains to preserve privacy and off-load heavy computations
for scalability. Zcash is a well-known blockchain platform that uses zk-SNARKs [6]. Zcash offers full-
private blockchain transactions that completely hide sender and receiver addresses and transaction
amounts. The success of Zcash has led other blockchain platforms to use zk-SNARKs. Ethereum
optimized zk-SNARK operations and reduced their gas costs with the Istanbul upgrade [13]. Aztec
[40] and StarkNet [37] are two side networks developed with zk-SNARKs to off-load Ethereum
transactions.

zk-SNARKs are constructed with complex arithmetic equations called circuits [30]. There are
circuit compilers that can abstract these equations and generate circuits using higher-level languages.
Circom [1] and Zokrates [44] are two popular zk-SNARK circuit compilers. They support basic
software-language concepts like variables, functions, control flows. These languages can declare
private input signals which are not revealed in proofs. They can also generate smart contract
verifiers to verify proofs on-chain.

Typical steps for generating and verifying zk-SNARK proofs are listed as follows:

(1) A high-level program (circuit) is designed by writing the logic for the zero-knowledge

computation.

(2) The circuit is compiled into a set of low-level arithmetic equations.
(3) Verification and proving keys are generated with the compiled circuit.
(4) Prover executes the compiled circuit with given public and private inputs and generates the

witness result.

(5) Prover generates the proof with the witness and the proving key.

4

Ceyhun Onur and Arda Yurdakul

(6) Prover sends the generated proof and public inputs to the verifier.
(7) Verifier verifies the proof with the verification key.

2.4 Semaphore
The Semaphore is a zero-knowledge protocol and set of tools for anonymous signaling [15]. It uses
a circuit and a smart contract to prove these three properties:

(1) An identity is eligible to broadcast a signal.
(2) The signal truly belongs to the identity owner
(3) The signal is not broadcasted twice.

The Semaphore aims to prove these properties without revealing extractable information about
the user identity. As a result, users can broadcast various signals without revealing their actual
identities. A valid proof verifies that the user is indeed on the eligible list. Eligible lists are defined
with Merkle trees so that identity verification can be efficiently done with Merkle proofs. The
Semaphore contains a Circom zk-SNARK circuit, smart contracts, and a Javascript library.

Semaphore can be used in many use cases like private transactions, anonymous authentication,

mixers, and private voting. We adopted and utilized the Semaphore in our voting protocol.

2.5 Ranked Choice Voting
Ranked Choice Voting (RCV) enables voters to sort their candidate preferences and vote with a
sorted list, i.e., preference list. Each preference in the list gives a ranked score to the respective
candidate. James Anest discusses the depths of RCV and its potential contributions to conduct more
"democratic" elections in his work [5]. The author states that RCV can encourage candidates to
enter elections without worrying about spoiling votes for other candidates. RCV also encourages
voters to participate in elections because it enables voters to express their preferences without
worrying about wasting their votes. One of the debates claims that RCV could be too complicated
for voters [10]. However, Anest argues that with the advances in computer technology, the RCV
can be used in large-scale elections [5]. ElectAnon uses the ranked choice-voting electoral system
to provide more democratic setups.

2.6 Ranking and Unranking Permutations
Myrvold & Ruskey developed an efficient algorithm to rank & unrank permutation lists [27]. The
ranking algorithm takes a permutation list (ğœ‹), size of the list (ğ‘›), and its inverse (ğœ‹ âˆ’1); then outputs
the corresponding rank integer (ğ‘Ÿ ). Each rank integer represents a permutation list, since there can
be at most ğ‘›! different permutations, the rank integer (ğ‘Ÿ ) can be in the range of between [0...ğ‘›! âˆ’ 1].
The unrank algorithm takes ğ‘›, ğ‘Ÿ , and an identity permutation ğœ‹ â€² and outputs the corresponding
permutation list ğœ‹. Both ranking and unranking algorithms have linear (ğ‘‚ (ğ‘›)) arithmetic operation
complexity, making them efficient to compute.

ElectAnon uses a ranked-choice electoral system. We used the aforementioned rank & unrank
algorithms to encode/decode preference lists. Instead of storing the whole list, we were able to
compute the rank of each preference list and store the corresponding integer rank in the smart
contract. Voters compute ranks of their preference lists off-chain(offline) in the voting phase, so
it also off-loads the computation. Our tallying function in the smart contract unranks these rank
integers and computes preference lists to obtain results.

2.7 Secure Election Requirements
Some requirements must be satisfied to conduct a secure online election. D.A Gritzalis identified
some of these requirements in his work in 2002 [14]. Gritzalisâ€™ requirements are still valid even

ElectAnon: A Blockchain-Based, Anonymous, Robust and Scalable Ranked-Choice Voting Protocol

5

today. Recent work [18] in 2021 mentions a similar set of requirements for secure blockchain-based
online elections. We gathered and presented existing definitions of Eligibility, Uniqueness, Privacy,
Fairness, Soundness, Universal Verifiability, Individual Verifiability secure election requirements. We
also expanded current definitions of Privacy and Robustness. We also introduce Scalability as a
secure online election requirement.

2.7.1 Eligibility. Only eligible voters should be able to cast ballots in an election [14]. The eligibility
of a voter is generally decided by election owners & authorities.

2.7.2 Uniqueness. No voter can cast more than one ballot in an election. In other words, each voter
can vote only once [14] [41].

Fairness. No intermediate results should be available. Voters should not be able to alter their

2.7.3
preferences according to intermediate results [14] [18].

Soundness. Only valid ballots should be taken into account in the tallying process. Invalid

2.7.4
votes should be discarded and not be tallied [18].

2.7.5 Universal Verifiability. The fairness and the correctness of an election result must be univer-
sally verifiable. Even non-participants must be able to validate the election result [43] [42].

Individual Verifiability. Voters must be able to verify that their ballots are cast correctly in

2.7.6
the election [43] [42].

2.7.7 Privacy and Anonymity. Votes should not be distinguishable in terms of who cast them. It
also means that no one should be able to figure out which voter used which ballot [43].

Online voting can be susceptible to linking a digital identity to the actual identity via linkage
attacks [25]. This could carry a higher risk if a party, like the election authority, knows the real
identities. We expand the Privacy requirement by ensuring that no operation in an election can be
linked to actual identities. We call this Anonymity of voters. If the Anonymity is guaranteed, then
no parties, even election authorities, can know who interacted with the election protocol during
the voting process.

2.7.8 Robustness. This condition ensures the inability of any parties to disrupt an ongoing election
[18]. Shirazi et al. expand the Robustness by adding tallying availability on top of voting availability
[36]. Voting availability ensures that eligible voters can finish the voting process without disruption.
Tallying availability ensures that valid votes can be tallied correctly without any interruption. We
think Robustness is crucial for blockchain systems since each transaction requires a transaction fee
and cost. If a disruption happens after vote casting, it means that this cost would be for nothing.
Most internet-voting protocols typically consist of different phases like Initialization, Voting and
Tallying [3]. We extend the Robustness requirement by adding autonomy, which ensures that there
can be no halting/freezing between phase changes.

Self-Tallying. Everyone should be able to calculate the election result and come up with the
2.7.9
same result as others [42]. This ensures there is no need for authorities or any specific actors to
calculate the election result. Everyone, even non-participants, should be able to learn the election
result without depending on other parties.

Scalability. We define Scalability as the maximum number of voters and candidate counts
2.7.10
in an election. Most blockchain platforms have a fixed capacity of transaction and block size. It
means that the Scalability in those systems is more evident and can be easily measurable.

6

Ceyhun Onur and Arda Yurdakul

3 RELATED WORKS
We have iterated over some most qualified works mentioned in Trends in blockchain-based electronic
voting systems [31]. We evaluated these works in the following aspects: Eligibility, Uniqueness,
Privacy, Anonymity, Fairness, Soundness, Universal Verifiability, Individual Verifiability, Robustness
and Scalability. Table 1 categorizes and summarizes this evaluation. We have identified Anonymity,
Robustness and Scalability are three common problems in the prior works.

Anonymity was not considered thoroughly in the related works. Prior studies try to accomplish
Privacy by keeping votes encrypted and secret. In the previous works, election authorities hold
the information of votersâ€™ real identities and their public keys and blockchain addresses. This is
needed to form a list of eligible voters properly so that Eligibility can be reassured. Most blockchain
addresses are pseudo-anonym by design [23]. As a result, blockchain addresses can be traced to link
the user with their chain activities. However, when voters act in an election (vote, commit, register,
etc.), election authorities can know which address uses which function. Election authorities may
form and enhance a link between the voter identity/blockchain address and the vote usage pattern.
In blockchain-based voting systems, it can expose a link between voter identities and different
blockchain activities. These blockchain activities can include transactions, token balances, and
ownerships. If Anonymity is not guaranteed, then election authorities can link actual identities to
these blockchain activities. This link can be further enhanced and break Anonymity if the same list
of eligible voters is used many times. We think studies like Yang et al. [41], McCorry et al. [24],
Priscore [42] suffer from this issue; since they need to repeat their elections in case of abandoned
votes.

The Robustness also could not be adequately achieved in prior works. Works like Yang et al. [41]
and Chaintegrity [43] depend on third-party actors to decrypt ballots in tallying. This violates
Robustness, as third-party actors can disrupt the election by providing invalid credentials or not
providing credentials at all. Some other works like McCorry et al. [24] and PriScore [42] use shared
secret-key encryption to encrypt votes and distribute these shared keys to registered voters. The
scheme requires a sufficient number of keys to be revealed for decryption. It means that if voters
abandon their votes and do not reveal their shared keys, the remaining votes cannot be decrypted.
McCorry et al. [24] try to solve this by incentive mechanisms of depositing and refunding assets.
However, if the political advantages of the election exceed economic incentives, voters can still
disrupt the election by abandoning their votes. PriScore [42] tries to solve this with additional
cryptographic operations; however, it fails to apply it for more than one abandoned vote. Every
blockchain transaction costs additional fees. So a large-scale election setup can be very costly,
especially the cases like nationwide elections. As a result, Robustness becomes a very crucial
requirement in blockchain-based voting. In our work, we tried to minimize the risk of disruption
during voting and eliminated the possibility of election repetition.

Scalability is another aspect that could not be adequately achieved in prior works. We think
that this is because most of the previous works try to preserve privacy with complex encryp-
tion/decryption schemes like homomorphic encryption, ElGamal encryption, and shared key
encryptions. Gas consumption is a solid indicator of scalability since transactions have a maximum
consumable gas limit in Ethereum. Works like McCorry et al. [24], Panja et al. [29] and Priscore
[42] use Ethereum as the blockchain platform and provide their gas consumptions. We tried to
evaluate their work in todayâ€™s Ethereum gas limit standards. We found that these works either hit
a maximum gas limit with a relatively small voter set, or consume too much gas, making them
practically impossible. We tried to minimize the voter-side gas consumption in our work so that it
can be practically possible to conduct a large-scale election with Ethereum.

ElectAnon: A Blockchain-Based, Anonymous, Robust and Scalable Ranked-Choice Voting Protocol

7

Table 1. Evaluation table of selected blockchain-based e-voting studies

Election requirement

Work

Scalable Electoral System

Platform

McCorry et al.[24]
Chaintegrity [43]
Yang et al. [41]
Panja et al.[29]
Priscore [42]

E U P A F
âœ“ x âœ“ x âœ“ âœ“ âœ“ âœ“ o
x âœ“ âœ“ âœ“ x
âœ“ âœ“ âœ“ x
âœ“ âœ“ âœ“ x
âœ“ x
o âœ“ o
âœ“ x âœ“ x âœ“ âœ“ âœ“ âœ“ o
x âœ“ âœ“ âœ“ âœ“ o
âœ“ o

S UV IV R S-T
âœ“
x
o
âœ“
o
o
ElectAnon (this work) âœ“ âœ“ âœ“ âœ“ âœ“ âœ“ âœ“ âœ“ âœ“ âœ“

Yes-No
Choose-One
Ranked Choice
Ranked-Choice
Ranked-Choice
Ranked-Choice
E: Eligibility, U: Uniqueness, P: Privacy, A: Anonymity, F: Fairness, S: Soundness,
UV: Universal Verifiability IV: Individual Verifiability, R: Robustness, S-T: Self-Tallying
âœ“: implemented, x: not implemented, o: partially implemented

x
x
x
x
x
âœ“

Public/Ethereum
Abstract
Abstract
Public/Ethereum
Public/Ethereum
Public/Ethereum

4 SYSTEM MODEL
ElectAnon is a self-tallying, privacy-preserving election protocol implemented with EVM smart
contracts and the Semaphore [15] zero-knowledge tool. The protocol aims to support all of the
requirements mentioned in the Section 2.7. The protocol utilizes a ranked-choice electoral system.
There are three system actors: Election Authority, Proposers and Voters. The protocol flows in a
timeline of six phases: Setup, Register, Proposal, Commit, Reveal, and Completed. Different actors
take different actions in each phase. An overview of our protocol flow and the timeline is presented
in Figure 1.

Fig. 1. ElectAnon Timeline

4.1 System Actors

â€¢ Election Authority (ğ¸ğ´) is responsible for system setup and initialization. ğ¸ğ´ decides on system
parameters and initializes the election by deploying the smart contract to the blockchain. ğ¸ğ´
is also responsible for registering eligible proposers and voters to the system. ğ¸ğ´ role can be
distributed to multiple parties. In this work, we used a single ğ¸ğ´ for the sake of simplicity.
â€¢ Proposers (ğ‘ƒğ‘…) can propose their answers for the election question. Each proposed answer
(proposal) becomes a candidate in the election. Each proposer can only register a single
proposal. Proposals are in the form of arbitrary strings. Proposals are registered only during
the Proposal state.

â€¢ Voters (ğ‘‰ ) can vote for candidates during the Commit state. Voters also participate in the

Reveal state to reveal their committed votes.

TimeSETUPActors: Election Authority(EA) Actions:  1. Set time-out parameters foreach phase of the election 2. Set election parameters 3. Deploy smart contractsREGISTERActors: EA, Voter, Proposer Actions:  1. Voters and proposersapply for entering theelection 2. EA registers proposersand voters 3. EA starts the electionActors: Proposer Actions:  Register candidatesPROPOSALCOMMITActors: Voter  Actions:  1. Decide on the vote 2. Generate a one-timesecret 3. Blind the vote with thesecret 4. Commit the blinded vote 5. Self-verify existence ofthe vote in the electionsystemREVEALActors: Voter Actions:  1. Reveal vote commitment 2. Self-verify that vote istalliedCOMPLETEDActors: Everyone Actions: Query the election resultsstart of theelectionend ofproposalphaseend ofcommitmentphaseend ofrevealphase8

Ceyhun Onur and Arda Yurdakul

4.2 States
ElectAnon protocol implements a timed-transition state machine for each phase. Each state has a
timed-transition guard with a lifetime/deadline for these states. If any state-specific transaction
(function call) is received after this lifetime, the transaction is rejected, and no changes occur in the
blockchain. For example, if the proposal lifetime is selected as 30 blocks, any call to the Proposal
state-specific function is rejected after 30 blocks. In addition to lifetimes, there are also conditional
transitions in functions to safely change the state to the next one.

Setup State. Election Authority (ğ¸ğ´) initializes election parameters and the protocol at this
4.2.1
state. ğ¸ğ´ decides on the election question, an arbitrary string representing various question topics.
For example, "who should be the president" in a presidential election and "which platform should
be used" in organizational decisions.

ğ¸ğ´ prepares the Semaphore zero-knowledge circuit (Circ) in this state. The circuit defines a
static tree-level parameter inside the circuit code. The tree-level specifies the maximum depth of
the Merkle tree. The parameter also indicates the maximum voter count since voters are registered
through Merkle trees. The maximum voter count equals the Merkle tree leaf count, which is
2tree-level. ğ¸ğ´ can alter the tree-level parameter in the circuit to change the maximum voter count.
The Semaphore circuit and smart contract use 20 levels by default. It means that a maximum
220 = 1.048.576 number of voters can fit into the Merkle tree.

ğ¸ğ´ must also announce the zero-knowledge verification (VerifyK) and the proving keys (ProveK);
so that voters can verify the circuit and generate zero-knowledge proofs. These keys are generated
with the given circuit ğ¶ğ‘–ğ‘Ÿğ‘ as shown in the equation 1.

ğ‘”ğ‘’ğ‘›ğ‘ ğ¾ (Circ) âˆ’â†’ (VerifyK, ProveK)
(1)
ğ¸ğ´ can store these keys and the circuit in a place where every voter can access, preferably a
decentralized storage like The InterPlanetary File System (IPFS)[7]. The storage address (ğ‘ˆ ğ‘…ğ¿) can
be put in the smart contract so that voters can fetch keys to generate their proofs.

ğ¸ğ´ generates the verifier smart contract (VerifierSC) with the verifier key (VerifyK). The verifier
smart contract is embedded in the main smart contract (MainSC) so that these two can be combined
and deployed as a single smart contract (ğ‘†ğ¶). ğ¸ğ´ decides on the election parameters to conduct
a custom election. These parameters are tree-level, maximum candidate count, proposal lifetime,
commit lifetime, and reveal lifetime. The tree-level should be the same as the one in the circuit ğ¶ğ‘–ğ‘Ÿğ‘.
The maximum candidate count indicates the maximum number of proposals that can be registered
as candidates. Each lifetime (ğ¿ğ‘‡ ) parameter defines the lifespan of the related state in terms of
block number. For example, proposal lifetime indicates the lifespan of the proposal state. ğ¸ğ´ can
deploy the smart contract (ğ‘†ğ¶) with these parameters. This phase is completed when the contract
is deployed. Figure 2 shows the sequence diagram for this state.

ElectAnon: A Blockchain-Based, Anonymous, Robust and Scalable Ranked-Choice Voting Protocol

9

Fig. 2. Setup State Sequence Diagram

4.2.2 Register State. In this state, ğ¸ğ´ starts forming eligible proposer and voter lists. Proposers send
their blockchain addresses to ğ¸ğ´ to propose in the election. Voters generate and send a commitment
of their identities to ğ¸ğ´.

Voters generate their identity (ğ¼ğ·ğ‘– ) and identity commitment (ğ¼ğ·ğ¶ğ‘– ) with the identity generation
function (ğ‘”ğ‘’ğ‘›ğ¼ ğ·ğ‘– ). The function takes a random seed ğ‘ ğ‘– and generates the ğ¼ğ·ğ‘– which contains
following components: a private key and public key pair (ğ‘ƒğ‘Ÿğ‘–ğ‘£ğ¾ğ‘–, ğ‘ƒğ‘¢ğ‘ğ¾ğ‘– ), a nullifier (ğ‘ğ‘¢ğ‘™ğ‘™ğ‘– ) and a
trapdoor (Trapi).

The identity commitment ğ¼ğ·ğ¶ğ‘– is constructed by hashing ğ‘ƒğ‘¢ğ‘ğ¾ğ‘–, ğ‘ğ‘¢ğ‘™ğ‘™ğ‘– and ğ‘‡ğ‘Ÿğ‘ğ‘ğ‘– . Voters send
their ğ¼ğ·ğ¶ğ‘– to ğ¸ğ´ to be registered as an eligible voter for the election through a secure channel.
Voters never send the actual identity ğ¼ğ·ğ‘– , but a hash of the ğ¼ğ·ğ‘– which is ğ¼ğ·ğ¶ğ‘– . The identity ğ¼ğ·ğ‘–
must be kept secret by the voter. The Equation 2 shows ğ¼ğ·ğ‘– and ğ¼ğ·ğ¶ğ‘– generation.

ğ‘”ğ‘’ğ‘›ğ¼ ğ·ğ‘– (ğ‘ ğ‘– ) âˆ’â†’ (ğ‘ƒğ‘Ÿğ‘–ğ‘£ğ¾ğ‘–, ğ‘ƒğ‘¢ğ‘ğ¾ğ‘–, ğ‘ğ‘¢ğ‘™ğ‘™ğ‘–,ğ‘‡ğ‘Ÿğ‘ğ‘ğ‘– ) : ğ¼ğ·ğ‘–
â„(ğ‘ƒğ‘¢ğ‘ğ¾ğ‘–, ğ‘ğ‘¢ğ‘™ğ‘™ğ‘–,ğ‘‡ğ‘Ÿğ‘ğ‘ğ‘– ) âˆ’â†’ ğ¼ğ·ğ¶ğ‘–

(2)

ğ¸ğ´ generates a Merkle-tree root ğ‘€ğ‘…ğ‘† from all collected identity commitments, then submits
ğ‘€ğ‘…ğ‘† along with the list of collected ğ¼ğ·ğ¶s to the smart contract. The smart contract has a function,
addVoters, for Merkle tree registration. The function takes the ğ¼ğ·ğ¶ list and the corresponding ğ‘€ğ‘…ğ‘† .
Due to the gas limit of Ethereum, ğ¼ğ·ğ¶ list size has a limit. In our experiments, we found this limit is
approximately 30.000 ğ¼ğ·ğ¶s in a single addVoters call. ğ¸ğ´ can split ğ¼ğ·ğ¶ list into smaller batches (like
30.000 per call) and issue them with multiple calls to the smart contract. ğ¼ğ·ğ¶s must be added to the
smart contract in the same order as they are used when constructing the Merkle-tree root. This
must be maintained correctly by the ğ¸ğ´ so that voters can safely reconstruct the same Merkle tree.
ğ¸ğ´ can change the state machine to the next state, when it confirms the register state is successfully
done. Figure 3 shows the sequence diagram for this state.

10

Ceyhun Onur and Arda Yurdakul

Fig. 3. Register State Sequence Diagram

4.2.3 Proposal State. Proposers can send their proposals to the smart contract (ğ‘†ğ¶) at this state. ğ‘†ğ¶
assigns a candidate ID (ğ¶ğ¼ğ·ğ‘– ) for each proposal. Voters use ğ¶ğ¼ğ·s in their preference lists. Proposals
are not stored in the smart contract; they are announced and stored in the blockchain as event logs.
The smart contract removes proposers from the eligible list after proposing to ensure they can only
submit once. The smart contract publishes a ProposedEvent, which contains the assigned candidate
ID (ğ¶ğ¼ğ·ğ‘– ) and the proposal string. Figure 4 shows the sequence diagram for this state. In addition to
lifetime, the state changes when all registered proposers successfully propose or the total proposal
count reaches the maximum candidate count. ğ¸ğ´ can choose to register more than the maximum
candidate count proposers in the Register state to increase the chance of having enough proposals
for the election.

ElectAnon: A Blockchain-Based, Anonymous, Robust and Scalable Ranked-Choice Voting Protocol

11

Fig. 4. Proposal State Sequence Diagram

4.2.4 Commit State. Voters cast their ballots in the Commit state. Each voter investigates the
candidate list and decides its preference list. The candidate list can be fetched from the blockchain
by filtering ProposedEvent events. ElectAnon uses a ranked-choice electoral system. In this system,
voters need to prepare their preferences as a sorted list, from the most preferred to the least
preferred. Voters need to prepare a list that contains every registered candidate. Each of these
preference lists is a permutation of [1, 2, 3, ..., ğ‘›ğ‘ ], where ğ‘›ğ‘ is the candidate count. ElectAnon uses
an encoding algorithm to rank & unrank each specific preference list[27]. As explained in the
Section 2.6, this algorithm efficiently maps a given permutation list to a single rankID integer.
Instead of storing the whole list, we store a single voteID (rankID) in the contract. After finalizing
their decisions, voters can get the rank of their preference list with the ranking algorithm, which
results in voteID (ğ‘‰ ğ¼ğ·ğ‘– ).

ElectAnon uses vote hashes (ğ‘‰ ğ» s) to hide the plaintext ğ‘‰ ğ¼ğ·s to preserve Fairness. Voters can
hash their ğ‘‰ ğ¼ğ·ğ‘– with a secret key VSkğ‘– to safely mask their ğ‘‰ ğ¼ğ·ğ‘– . This provides a way to generate
indistinguishable vote hashes VH ğ‘– from a plaintext ğ‘‰ ğ¼ğ·ğ‘– . Each voter locally stores their ğ‘‰ ğ¼ğ·ğ‘– and
ğ‘‰ ğ‘†ğ‘˜ğ‘– for later use. They should keep ğ‘‰ ğ¼ğ·ğ‘– and ğ‘‰ ğ‘†ğ‘˜ğ‘– as a secret to preserve their privacy.

â„(VIDğ‘–, VSki) âˆ’â†’ VH ğ‘–
Voters generate Merkle trees to obtain their Merkle proofs to prove their eligibility to vote.
Merkle tree leaves (ğ¼ğ·ğ¶s) can be fetched from blockchain by filtering VotersAddedEvent event logs.
Voters also obtain the Merkle tree-level from the smart contract. With all of these, each voter can
generate the Merkle tree and the Merkle proof ğ‘€ğ‘ƒğ‘– with their own ğ¼ğ·ğ¶ğ‘– . The equation 4 shows
how to generate the Merkle proof.

(3)

ğ‘”ğ‘’ğ‘›ğ‘‡ğ‘Ÿğ‘’ğ‘’ (ğ¼ğ·ğ¶ğ¿ğ‘–ğ‘ ğ‘¡,ğ‘‡ğ‘Ÿğ‘’ğ‘’ğ¿ğ‘’ğ‘£ğ‘’ğ‘™) âˆ’â†’ ğ‘€ğ‘’ğ‘Ÿğ‘˜ğ‘™ğ‘’ğ‘‡ğ‘Ÿğ‘’ğ‘’
ğ‘”ğ‘’ğ‘›ğ‘€ğ‘’ğ‘Ÿğ‘˜ğ‘™ğ‘’ğ‘ƒğ‘Ÿğ‘œğ‘œ ğ‘“ (ğ‘€ğ‘’ğ‘Ÿğ‘˜ğ‘™ğ‘’ğ‘‡ğ‘Ÿğ‘’ğ‘’, ğ¼ ğ·ğ¶ğ‘– ) âˆ’â†’ ğ‘€ğ‘’ğ‘Ÿğ‘˜ğ‘™ğ‘’ğ‘ƒğ‘Ÿğ‘œğ‘œ ğ‘“ (ğ‘€ğ‘ƒğ‘– )

(4)

Upon completing the steps above, each voter can start generating the witness and the zero-
knowledge proof (ğ‘ƒğ‘– ) with the Semaphore circuit (ğ¶ğ‘–ğ‘Ÿğ‘). Voters can fetch the circuit (ğ¶ğ‘–ğ‘Ÿğ‘) and
the proving key (ğ‘ƒğ‘Ÿğ‘œğ‘£ğ‘’ğ¾) from the IPFS with the ğ‘ˆ ğ‘…ğ¿ provided in the smart contract. The circuit
expects the following inputs: the vote hash (ğ‘‰ ğ» ğ‘– ), the identity commitment (ğ¼ğ·ğ‘– ), the Merkle proof

12

Ceyhun Onur and Arda Yurdakul

ğ‘€ğ‘ƒğ‘– , the external nullifier (ğ¸ğ‘¥ğ‘¡ğ‘ ), and the signature (ğ‘†ğ‘–ğ‘”ğ‘›ğ‘– ). The ğ¸ğ‘¥ğ‘¡ğ‘ is the same as the contract
address and accessible from the smart contract. ğ‘†ğ‘–ğ‘”ğ‘›ğ‘– is obtained by signing the ğ‘‰ ğ»ğ‘– with the
private key ğ‘ƒğ‘Ÿğ‘–ğ‘£ğ¾. The circuit outputs the witness, which contains a verification for the Merkle
root ğ‘€ğ‘…ğ¶ and the nullifier hash ğ‘ ğ»ğ‘– . A detailed explanation about ğ‘€ğ‘…ğ¶ and ğ‘ ğ»ğ‘– is given at the
end of this section. Voters can use this witness result and the ğ‘ƒğ‘Ÿğ‘œğ‘£ğ‘’ğ¾ to generate their proofs ğ‘ƒğ‘– .
ğ‘”ğ‘’ğ‘›ğ‘Š ğ‘–ğ‘¡ğ‘›ğ‘’ğ‘ ğ‘  (ğ¶ğ‘–ğ‘Ÿğ‘, ğ‘‰ ğ»ğ‘–, ğ¼ğ·ğ‘–, ğ‘€ğ‘’ğ‘Ÿğ‘˜ğ‘™ğ‘’ğ‘ƒğ‘Ÿğ‘œğ‘œ ğ‘“ , ğ¸ğ‘¥ğ‘¡ğ‘ , ğ‘†ğ‘–ğ‘”ğ‘›ğ‘– ) âˆ’â†’ ğ‘Š ğ‘–ğ‘¡ğ‘›ğ‘’ğ‘ ğ‘  : ğ‘€ğ‘…ğ¶, ğ‘ ğ»ğ‘–
ğ‘”ğ‘’ğ‘›ğ‘ƒğ‘Ÿğ‘œğ‘œ ğ‘“ (ğ‘Š ğ‘–ğ‘¡ğ‘›ğ‘’ğ‘ ğ‘ , ğ‘ƒğ‘Ÿğ‘œğ‘£ğ‘’ğ¾) âˆ’â†’ ğ‘ƒğ‘–

(5)

The commitVote function in the smart contract expects three inputs from voters. These inputs
are ğ‘‰ ğ» ğ‘– , ğ‘ ğ»ğ‘– and ğ‘ƒğ‘– . The verifier smart contract (VerifSC) expects 2 additional inputs to verify ğ‘ƒğ‘– .
These inputs are ğ¸ğ‘¥ğ‘¡ğ‘ and the Merkle tree root ğ‘€ğ‘…ğ‘† . ğ¸ğ‘¥ğ‘¡ğ‘ is defined as the contracts deployed
blockchain address. ğ‘€ğ‘…ğ‘† is the registered Merkle root in the Register state. The smart contract
then verifies the given proof ğ‘ƒğ‘– to ensure the proof is intact with given inputs. As a result, the
contract rejects or accepts the proof. If the proof is accepted, nullifier hash (ğ‘ ğ»ğ‘– ) is marked as used
to prevent the double-voting. The smart contract stores the vote hash VH ğ‘– in a mapping keyed
with votersâ€™ blockchain addresses for later use. Figure 5 shows the sequence diagram for this state.

Fig. 5. Commit State Sequence Diagram

ElectAnon: A Blockchain-Based, Anonymous, Robust and Scalable Ranked-Choice Voting Protocol

13

The Commit state ends with two conditions. The first one is the timed transition which changes
the state after commitLifetime. The smart contract will reject any transaction (function call) made
after this time. The other one checks if every voter has committed already.

The Semaphore Proof. It is worth mentioning how the Semaphore proof ğ‘ƒğ‘– is constructed and

works in our voting protocol. In general, the proof ensures these three properties:

(1) The voter identity is in the eligible voter list.
(2) The same identity is not used to cast a vote hash twice.
(3) The vote hash is indeed generated by the identity which created the proof.

The circuit guarantees the first property with Merkle trees and Merkle proofs. Voters form their
Merkle proof (ğ‘€ğ‘ƒğ‘– ) and use it as a private input in the circuit. The circuit also takes each subcom-
ponent of ğ¼ğ·ğ‘– as private inputs. These subcomponents are ğ‘ƒğ‘¢ğ‘ğ¾ğ‘– , ğ‘ğ‘¢ğ‘™ğ‘™ğ‘– and ğ‘‡ğ‘Ÿğ‘ğ‘ğ‘– . The circuit
re-generates the ğ¼ğ·ğ¶ğ‘– by hashing ğ‘ƒğ‘¢ğ‘ğ¾ğ‘– , ğ‘ğ‘¢ğ‘™ğ‘™ğ‘– and ğ‘‡ğ‘Ÿğ‘ğ‘ğ‘– as in Equation 2. The circuit continues
with generating the Merkle root ğ‘€ğ‘…ğ¶ by the generated ğ¼ğ·ğ¶ğ‘– along with given ğ‘€ğ‘ƒğ‘– private input.
The circuit puts the resulting Merkle tree root ğ‘€ğ‘…ğ¶ into the proof ğ‘ƒğ‘– . The smart contract verifies
ğ‘ƒğ‘– and checks whether the root in the proof ğ‘€ğ‘…ğ¶ is verifiable with the registered root ğ‘€ğ‘…ğ‘† . As
a result, the verifier verifies that voters indeed generated the correct Merkle tree root with their
ğ¼ğ·ğ¶ğ‘– and ğ‘€ğ‘ƒğ‘– . With this, ElectAnon verifies that the voter is eligible since the ğ¼ğ·ğ¶ğ‘– is indeed a
member of the eligible voter Merkle tree.

The circuit ensures the second property with a nullifier hash (ğ‘ ğ»ğ‘– ). As told before, the circuit
takes ğ¼ğ·ğ‘– subcomponents as private inputs. One of these subcomponents is identity nullifier (ğ‘ğ‘¢ğ‘™ğ‘™ğ‘– ),
which is a random integer. The circuit hashes following inputs to obtain ğ‘ ğ»ğ‘– : identity nullifier
(ğ‘ğ‘¢ğ‘™ğ‘™ğ‘– ), external nullifier (ğ¸ğ‘¥ğ‘¡ğ‘ ), Merkle proof (ğ‘€ğ‘ƒğ‘– ). The circuit puts ğ‘ ğ»ğ‘– into the proof ğ‘ƒğ‘– .

â„(ğ‘ğ‘¢ğ‘™ğ‘™ğ‘–, ğ¸ğ‘¥ğ‘¡ğ‘ , ğ‘€ğ‘ƒğ‘– ) âˆ’â†’ ğ‘ ğ»ğ‘–

(6)
In the verification, the smart contract takes ğ‘ ğ»ğ‘– from the voter as input and verifies that it matches
the one in the ğ‘ƒğ‘– . Additionally, the smart contract marks and stores this ğ‘ ğ»ğ‘– as used and invalidates
any future calls with the same ğ‘ ğ»ğ‘– . This prevents double voting with the same ğ‘ ğ»ğ‘– . The zero-
knowledge proof ensures that ğ‘ ğ»ğ‘– is constructed correctly with components of ğ‘ğ‘¢ğ‘™ğ‘™ğ‘–, ğ¸ğ‘¥ğ‘¡ğ‘ , ğ‘€ğ‘ƒğ‘– .
So reforging a new ğ‘ ğ»ğ‘– would require a change in these components. ğ¸ğ‘¥ğ‘¡ğ‘ is provided by the
smart contract itself to the verifier, so the voter has no direct control over it. If the voter provides
an invalid ğ¸ğ‘¥ğ‘¡ğ‘ in the proof generation, the verifier will not validate the proof. ğ‘ğ‘¢ğ‘™ğ‘™ğ‘– and ğ‘€ğ‘ƒğ‘– is a
part of ğ¼ğ·ğ¶ğ‘– , so reforging ğ‘ğ‘¢ğ‘™ğ‘™ğ‘– would result in a completely different ğ¼ğ·ğ¶ â€²
ğ‘– . This would invalidate
the proof ğ‘ƒğ‘– as this new ğ¼ğ·ğ¶ â€²

ğ‘– would not be in the eligible list.

Voters sign their vote hashes (VH ğ‘– ) with their private key ğ‘ƒğ‘Ÿğ‘–ğ‘£ğ¾ğ‘– . The circuit takes the voter
public key ğ‘ƒğ‘¢ğ‘ğ¾ğ‘– and the signature ğ‘†ğ‘–ğ‘”ğ‘›ğ‘– as private inputs. Then, it checks the signature ğ‘†ğ‘–ğ‘”ğ‘›ğ‘–
with the given public key ğ‘ƒğ‘¢ğ‘ğ¾ğ‘– . This completes the last property since it can verify that the voter
indeed generates ğ‘‰ ğ»ğ‘– .

4.2.5 Reveal State. In the Reveal state, voters can reveal their vote hashes VH ğ‘– with the revealVote
function. The contract stores VH ğ‘– in the Commit state within a map of addresses to vote hashes. It
means voters need to reveal their commitments with the same blockchain address they used in the
Commit state. Each voter provides inputs of voteID (VIDğ‘– ) and the vote secret key VSkğ‘– to the smart
contract. The smart contract checks if the hash of these two inputs (VH â€²
ğ‘– ) is equal to the one that
was stored (VH ğ‘– ) in the previous state.

â„(VIDğ‘–, VSkğ‘– ) âˆ’â†’ VH â€²
ğ‘–

VH â€²
ğ‘–

?= VH ğ‘–

(7)

14

Ceyhun Onur and Arda Yurdakul

If theyâ€™re not equal, the smart contract rejects the transaction. If hash holds, the smart contract
deletes the stored VH ğ‘– in the contract to guarantee that it is not revealed twice.

The contract passes the ğ‘‰ ğ¼ğ·ğ‘– , the candidate count (ğ‘›ğ‘ ), and the storage mapping Tally Storage
(ğ‘‡ ğ‘†) to the tally library. ğ‘‡ ğ‘† is required to keep revealed votes in the storage so that tally libraries
can use revealed votes. The tally library defines a tally function that tallies revealed results. The
library can change the ğ‘‡ ğ‘†, which means that each revealed ğ‘‰ ğ¼ğ· is counted accordingly and put
into the contract storage through ğ‘‡ ğ‘†. The tally function may differ for each tallying algorithm and
implementation. Figure 6 shows the sequence diagram for this state.

Fig. 6. Reveal State Sequence Diagram

The state is changed if the timed-transition revealLifetime exceeds or all committed votes are
successfully revealed. Voters must reveal their votes within this lifetime; otherwise, they cannot be
counted.

ElectAnon: A Blockchain-Based, Anonymous, Robust and Scalable Ranked-Choice Voting Protocol

15

4.2.6 Completed State. Everyone can call the electionResult function to get the election result in
this state. This function is a view function, meaning that calling it will not create state-changing
transactions in the blockchain and requires no transaction fees. The smart contract uses a tallying
library to calculate the results. The tallying library uses the populated tallying storage ğ‘‡ ğ‘† and
calculates the election result. The election result shows the candidate ID (ğ¶ğ¼ğ·ğ‘– ) of the winner. Note
that the smart contract publishes ProposedEvent for each proposal in the previous Proposal state.
The actual proposal string can be fetched by filtering these ProposedEvent with the winner ğ¶ğ¼ğ·ğ‘– to
find the winner proposal. Figure 7 shows the sequence diagram for this state.

Fig. 7. Completed State Sequence Diagram

5 TALLYING LIBRARIES
Our tallying algorithms are implemented with Solidity [38] libraries. The main smart contract can
load another tallying library by importing it in the Setup phase. This change should be done before
the contract deployment. A different tallying algorithm can be used through libraries while still
keeping the core functionalities of the main smart contract like revealVote and commitVote. Tallying
libraries have two main functions, tally and calculateResult. The tally function is used in the the
Reveal state and is responsible for counting the votes and putting them into the tallying storage
ğ‘‡ ğ‘†. The calculateResult function is used in the Completed state and announces the winner ID by
interpreting the given tallying storage ğ‘‡ ğ‘†. These two functions can be customized for each tallying
algorithm.

5.1 Borda Count Library
The Borda Count was devised by Jean Charles de Borda in 1781 [12]. In the basic form, each ballot
holds a sorted list of candidates. Each of these candidates is assigned a score based on their orders
in the list. At the end of the election, each of these scores for the candidateID is summed together.
As a result, the candidate with the maximum total score wins the election.

16

Ceyhun Onur and Arda Yurdakul

We implement Borda Count tallying algorithm as a tallying library. The tally function takes
voteID (ğ‘‰ ğ¼ğ·) and then unranks it into the related preference list. The preference list represents
a sorted list of candidates. The function scores each of sorted candidates in a decreasing scores
of [ğ‘›ğ‘, ğ‘›ğ‘ âˆ’ 1, ğ‘›ğ‘ âˆ’ 2, ..., 1], where ğ‘›ğ‘ is the candidate count, i.e preference list size. These scores
are added to the tally storage ğ‘‡ ğ‘† in a map of candidateIDs to their respective cumulative score.
calculateResult function of this library compares each cumulative score of candidates and then
returns the candidateID with the maximum score. We used this library as the main tallying library
in our experiments.

5.2 Tideman Library
The Tideman Method [39], also known as Ranked pairs, is a tallying method devised by T. N.
Tideman in 1987 [39]. The method collects the ranked preferences and compares each candidate
in a pairwise fashion. These pairwise comparisons are sorted by their winnerâ€™s vote dominance
against the loser. The algorithm starts locking the winners against losers in this sorted order by
constructing a directed graph. The one that is not locked by another candidate, the vertex with an
in-degree of 0, becomes the winner. If any cycle occurs in the locking, that pair is ignored. The
method guarantees both the Majority and Condorcet rules. T. N. Tideman states that Borda is not
the Condorcet method, unlike the Tideman method. The Tideman also guarantees the Majority
Rule by ensuring that the election winner is selected as the majorityâ€™s first choice. Unlike Tideman,
Borda does not guarantee the Majority Rule [17].

We implement the Tideman Method as a tallying library to support both Majority Rule and
Condorcet criterion. The tally function increments how many times voteID (ğ‘‰ ğ¼ğ·) is used and then
stores it in the tally storage ğ‘‡ ğ‘†. It means that the tally function tracks the count of ğ‘‰ ğ¼ğ·s in their
encoded (ranked) forms in the election. The calculateResult function unranks ğ‘‰ ğ¼ğ·s into preference
lists and follows the Tideman algorithm to calculate the winner.

6 MERKLE FOREST
ElectAnon uses Merkle trees to prove eligibility of voter identity commitments efficiently. On the
other hand, the original Semaphore smart contract calculates the Merkle tree on the smart contract
(on-chain). Calculating the Merkle tree on-chain provides a safe way to keep the Merkle tree root
intact with the registered leaves. This calculation has a very high gas consumption since it requires
multiple hash operations per tree level. So, we eliminated it by off-loading this calculation to the
election authority. The Election Authority calculates the Merkle tree root off-chain then sends it to
the smart contract along with Merkle tree leaves (identity commitments). This introduces a trust
assumption in authority to honestly calculate this Merkle tree.

We propose the Merkle Forest solution to reduce the trust assumption on election authority. In
this solution, each Merkle tree root is calculated with a zero-knowledge circuit and verified on
the chain. The circuit takes a fixed-size leaf-list as a private input. Then it forms a Merkle tree
from these leaves and generates the Merkle root. It also hashes all elements in the given list input
with the Keccak-256 hash function to obtain the hash output. The proof outputs both the Merkle
tree root and the hash output. The smart contract takes the leaf-list, the Merkle tree root, and
the zero-knowledge proof as inputs. The smart contract computes the Keccak-256 hash of the
given leaf-list and verifies the given zero-knowledge proof with the given Merkle tree root and the
calculated hash of the leaf-list. In this way, the smart contract can ensure that the given Merkle
tree root is indeed calculated with the given leaf-list. After a successful verification, the root is
registered to the ElectAnon smart contract with a tree index. A new tree must be constructed and
registered to the smart contract to register more voters. This is because zk-SNARK circuits do not
support dynamic-size arrays. For instance, if the fixed tree size in the circuit is set to 256, each

ElectAnon: A Blockchain-Based, Anonymous, Robust and Scalable Ranked-Choice Voting Protocol

17

tree can hold at most 256 voters. In order to register 2560 for the election, these 2560 voters must
be split into ten trees. Smart contract stores tree roots within a mapping[treeIndex] => treeRoot
structure. The smart contract publishes an event when a tree is registered. The event contains
treeIndex, treeRoot, and leaves so that voters can track which tree theyâ€™re registered. In the Commit
state, each voter must specify their tree index; so that the smart contract can fetch the Merkle
root of that particular tree and verify the Semaphore proof of the voter. Note that ElectAnon
already has a zero-knowledge proof construction from the Semaphore circuit. This Merkle Forest
approach adds another zero-knowledge circuit and verifier to the ElectAnon to verify that Merkle
tree constructions are done faithfully. With this method, the smart contract can verify that each
Merkle tree root input is correctly constructed from the given Merkle tree leaves.

We have realized that the Keccak-256 hash function is inefficient for zero-knowledge proofs.
However, it is an efficient hash function for EVM-based smart contracts. The keccak-256 hash
function is only required when leaf inputs are private. If we can remove this necessity by making
the leaf list a public input, we can also remove the Keccak-256 hash function from the circuit. With
that, the verifier smart contract can take the complete leaf-list as the input and verify the remaining
Merkle tree construction proof with this list input. We also implemented a circuit that can take
public inputs of tree leaves and requires no Keccak-256 hash function in this work. We wanted to
compare these two different versions. We used Zokrates [44] as the main zk-SNARK toolbox in
our implementations. We conducted experiments for both of these Merkle Forest implementations
(with and without Keccak-256) in the Section 8.3.

7 SECURITY ANALYSIS
In this section, we analyze ElectAnon with aspects defined in the Election requirement section.

7.1 Eligibility
At the Register state, each voter generates an identity commitment ğ¼ğ·ğ¶ğ‘– and submits it to the
election authority (ğ¸ğ´). ğ¸ğ´ decides votersâ€™ eligibility and forms a Merkle tree (ğ‘€ğ‘‡ ) with these
eligible ğ¼ğ·ğ¶s. ğ¸ğ´ registers the Merkle tree root (ğ‘€ğ‘…ğ‘† ) and the identity commitment list (ğ¼ğ·ğ¶s) to
the smart contract. At the Commit state, voters create proofs to prove that they own a valid identity
commitment ğ¼ğ·ğ¶ğ‘– , and they can generate the correct Merkle tree root with their Merkle proofs
ğ‘€ğ‘ƒğ‘– . The smart contract verifies this proof with the registered ğ‘€ğ‘…ğ‘† . At the end of this verification,
the protocol verifies that the ğ¼ğ·ğ¶ğ‘– is indeed in the eligible voter set. The smart contract rejects
transactions without valid proof; thus ElectAnon ensures Eligibility.

7.2 Uniqueness
The Semaphoreâ€™s double-signaling prevention ensures Uniqueness [15]. Voter identity ğ¼ğ·ğ‘– includes
a random-secret nullifier ğ‘ğ‘¢ğ‘™ğ‘™ğ‘– . Each voter generates the zero-knowledge proof ğ‘ƒğ‘– with private
inputs of their nullifier ğ‘ğ‘¢ğ‘™ğ‘™ğ‘– and an external nullifier ğ¸ğ‘¥ğ‘¡ğ‘ . The smart contract verifies that ğ‘ ğ»ğ‘– is
correctly generated by the voter with the ğ‘ƒğ‘– . The smart contract also stores this ğ‘ ğ»ğ‘– and invalidates
any call with the same ğ‘ ğ»ğ‘– . Each of these ğ‘ ğ»ğ‘– s are unique to their ğ¼ğ·ğ‘– . So in order to reforge a
valid ğ‘ ğ»ğ‘– , one must regenerate a new ğ¼ğ·ğ‘– . However, if this ğ¼ğ·ğ‘– is not registered in the eligible set,
the proof will still fail due to the Eligibility proof. So each voter can only vote once with their valid
ğ¼ğ·ğ‘– ; thus ElectAnon achieves Uniqueness.

7.3 Privacy and Anonymity
Privacy is ensured by preserving the anonymity of voter identities. We assume voters send their
identity commitments (ğ¼ğ·ğ¶ğ‘– ) to Election Authority (ğ¸ğ´) in a secure, private channel. The protocol

18

Ceyhun Onur and Arda Yurdakul

aims to keep identities ğ¼ğ·ğ‘– and their commitments ğ¼ğ·ğ¶ğ‘– secret when voters cast their votes. If one
of them is revealed in the voting time, then ğ¸ğ´ can distinguish voters and learn about their votes.
In the Commit state, voters generate zero-knowledge proofs without revealing their identity
commitments ğ¼ğ·ğ‘– or ğ¼ğ·ğ¶ğ‘– . The zero-knowledge proof ğ‘ƒğ‘– proves that the vote is indeed generated
by the voter. Voters generate their zero-knowledge proofs in their local offline environments. The
zero-knowledge circuit ğ¶ğ‘–ğ‘Ÿğ‘ takes voter identity ğ¼ğ·ğ‘– as a private input and generates the proof ğ‘ƒğ‘– .
The zero-knowledge compiler ensures that the given private input of ğ¼ğ·ğ‘– is not revealed in the ğ‘ƒğ‘– .
The smart contract takes ğ‘ƒğ‘– as input but does not require ğ¼ğ·ğ‘– or ğ¼ğ·ğ¶ğ‘– . As a result, no identity ğ¼ğ·ğ‘–
or their commitment counterpart ğ¼ğ·ğ¶ğ‘– is revealed.

Voters still interact with the smart contract through their blockchain addresses. We assume
they use a new and fresh blockchain address when they first interact with the smart contract in
Commit state. Any reuse of these addresses in other blockchain applications can compromise their
anonymity. Voters also need to keep their ğ¼ğ·ğ¶ğ‘– and ğ¼ğ·ğ‘– secret. If these assumptions hold, then even
the ğ¸ğ´ cannot deduct any information about voter identities. ElectAnon ensures Anonymity since
no one can distinguish any voter operation and link them to actual voter identities. This satisfies
Privacy since no one can link a vote to the real voter identity.

7.4 Fairness
ElectAnon voting phase consists of two consecutive states, Commit and Reveal. Voters commit the
hash of the vote (ğ‘‰ ğ» ğ‘– ) without revealing the actual vote ID (ğ‘‰ ğ¼ğ·ğ‘– ) in the Commit state. This is
done by hashing the ğ‘‰ ğ¼ğ·ğ‘– with a random vote key (VSkğ‘– ). These VSkğ‘– and the ğ‘‰ ğ¼ğ·ğ‘– must be kept
secret until the end of the Commit state to guarantee the Fairness is preserved. In the Reveal state,
voters provide their plaintext ğ‘‰ ğ¼ğ·ğ‘– along with ğ‘‰ ğ‘†ğ‘˜ğ‘– as their inputs to the smart contract. The smart
contract verifies that committed hashes can be reconstructed with these inputs. Then these revealed
votes are stored in the smart contract to be tallied. This ensures that commitments do not reveal
any information about actual votes, and theyâ€™re not modifiable once theyâ€™re committed. ElectAnon
guarantees that no-intermediate results are obtainable in the Commit state, and committed votes
are not alterable. Thus, ElectAnon satisfies the Fairness requirement.

7.5 Soundness
ElectAnon encodes ranked-choice lists into single integer vote IDs (ğ‘‰ ğ¼ğ·). Each of these ğ‘‰ ğ¼ğ·s
represents a permutation of candidate IDs. For a list of size ğ‘›ğ‘ , there can be at most ğ‘›ğ‘ ! permutations.
It means that ğ‘‰ ğ¼ ğ·s can be in range of [0, ğ‘›ğ‘ ! âˆ’ 1]. This is easily detectable in the Reveal state as
ğ‘‰ ğ¼ğ·s are revealed in this state. ElectAnon checks the revealed ğ‘‰ ğ¼ğ·ğ‘– and rejects the transaction if it
is not in the valid range. ElectAnon achieves Soundness by securing that invalid votes cannot be
revealed and tallied.

7.6 Universal Verifiability
ElectAnon uses blockchain technology. Blockchain technology ensures that every transaction is
transparent and verifiable by the whole network. ElectonAnon is a self-tallying protocol so that
everyone can calculate results independently. With these two aspects, ElectAnon achieves Universal
Verifiability.

7.7 Individual Verifiability
Voters can verify that their committed vote hashes (ğ‘‰ ğ» s) are successfully cast in the ballot by
verifying blockchain transaction inputs. They can also ensure that their revealed votes are tallied
correctly by verifying that transactions contain their plaintext (ğ‘‰ ğ¼ğ·) inputs. Thus ElectAnon
achieves Individual Verifiability.

ElectAnon: A Blockchain-Based, Anonymous, Robust and Scalable Ranked-Choice Voting Protocol

19

7.8 Robustness
ElectAnon includes a timed-transition state machine in the smart contract to ensure autonomy so
election protocol can change states without interruption. The Register is the only state that the
protocol requires a manual transition from the election authority (ğ¸ğ´). There is no voter-smart
contract interaction required before the Commit state. Even if ğ¸ğ´ disrupts the protocol, it will not
affect any votes or voters.

ElectAnon ensures votersâ€™ activities do not affect each other. In the Reveal state, voters reveal
their votes. If a voter abandons a committed vote, others will not be affected by it, and the election
can safely continue to tally.

ElectAnon guarantees that a started election will not be disrupted by any means. As a result,
ElectAnon achieves voting availability. Moreover, ElectAnon is a self-tallying protocol. It means
that everyone can tally the result without requiring any external assistance. By that, ElectAnon also
satisfies the tallying availability. ElectAnon ensures Robustness by combining voting availability,
tallying availability, and autonomy.

8 EXPERIMENTS AND RESULTS
We deployed ElectAnon to a local Ethereum network by using the Hardhat [22] tool. Hardhat
provides local ethereum networks, gas consumption reports, and a wallet pre-filled with accounts.
We used Solidity version 0.8.7 and the latest Ethereum fork London. We used a MacBook Pro with
an 8-core 3.2GHz Apple M1 chip and 16 GB Ram, running on macOS BigSur (Version 11) to conduct
our tests.

We measured gas consumption of functions that voters use in the election protocol. Figure 8
shows measured gas consumptions for commitVote, revealVote, and calculateResult. We run them
in 2 different setups. In the first one, we fixed the voterCount to 10 and increased the candidate
count linearly. In the second setup, we used a fixed candidate count of 10 and increased voter
counts exponentially. We found that commitVote has a ğ‘‚ (1) gas complexity. The function consumes
approximately 315.000 gas per transaction. Since the function verifies the zero-knowledge proofs, it
consumes relatively more gas than other functions. Weâ€™ve seen that the function revealVote is only
affected by the candidate count. The consumption function is approximately: ğ‘›ğ‘ âˆ— 8000 + 39000 and
thus linear with ğ‘‚ (ğ‘›ğ‘ ). Votes are counted in revealVote function, and voteIDs (ğ‘‰ ğ¼ğ·s) are unranked
with the Ranking/Unranking permutation algorithm [27]. The algorithm takes a linear time to
unrank the rankID to a permutation list. As expected, it causes a linear gas consumption with respect
to candidate count ğ‘›ğ‘ . We found that voter count does not affect n revealVote. There is a down-slope
in between voterCount=10 and 100. This is because there is an additional map initialization cost
when revealVote is called for the first time. Hardhat gas-reporter takes an average gas consumption
if the same function is used more than once. Eventually, the average value becomes closer to the
maximum when there are few voters and becomes closer to the minimum when there are more
voters. The calculateResult function is not affected by the voter count, but it has linear complexity
with the candidate count ğ‘‚ (ğ‘›ğ‘ ). This is because the Borda Count tally library partially tallies the
results in the revealVote function. The calculateResult function iterates over each candidate ID in
the tally storage ğ‘‡ ğ‘† and finds the candidate with the maximum score, then reports it. As a result,
the function cost increases linearly with respect to candidate count.

The smart contract deployment takes a total of 3,458,406 gas. The deployment is done only
once by the election authority. Figure 9 shows gas consumptions for addVoters, addProposers,
propose, toProposalState, which are mainly used by the election authority and proposers. The gas
consumption of addProposers is proportional to the candidate (proposal) count. The cost function
of addProposers is 50180 + (23586 âˆ— ğ‘›ğ‘ ) which is ğ‘‚ (ğ‘›ğ‘ ). The measured gas consumptions of propose

20

Ceyhun Onur and Arda Yurdakul

Fig. 8. Voter Functions

and the toProposalState are ğ‘‚ (1) and fairly low. addVotersâ€™s gas cost is directly related to the voter
count. We tried to register all voter commitments in a single addVoters function, e.g. 1000 voter
registration in a single call. Ethereum has a block gas capacity which changes between 15 and 20
million gas. We could add 10,000 voter IDs in a single transaction without exceeding the block
limit. In our tests, we found that addVoters call exceeds this limit with approximately 30,000 voters.
Election Authority can issue multiple calls to keep adding new IDs. For example, 100,000 voters
can be added by splitting vodeIDs into ten different addVoters calls with 10,000 voters for each.

Fig. 9. Election Authority Functions

Merkle trees must be generated by both election authority and voters. We analyzed functions of
generating Merkle tree (genTree) and Merkle proof (genMerkleProof ) with increased voter count.
Figure 10 shows these results. We found that the tree can be constructed within 42 minutes for
100,000 voters. Merkle proof generation takes only 6 seconds for 100,000 voters. Merkle tree and
proof generation have a linear relation with the voter count. The generated Merkle proof file size is

10203040500100,000200,000300,000400,000CandidateCountGasConsumptionvoterCount=10commitVoterevealVoteelectionResult101001,00010,00050,000100,000150,000200,000250,000300,000VoterCountcandidateCount=10110203040500200,000400,000600,000800,0001,000,0001,200,000CandidateCountGasConsumptionvoterCount=10addVotersaddProposersproposetoProposalState101001,00010,000100,0001,000,00010,000,000VoterCountcandidateCount=101ElectAnon: A Blockchain-Based, Anonymous, Robust and Scalable Ranked-Choice Voting Protocol

21

165,5 megabytes for 100,000 voters. The file contains all Merkle proofs for every individual leaf. It
means voters can grab the file and find their related Merkle proofs without generating the tree.

Fig. 10. Merkle Tree Functions

We also analyzed the Semaphore circuit setup times, file sizes, and the witness & proof generation
times. Results can be found in the table 2. Results show that compiling the circuit and generating
keys take almost 15 minutes and 250-megabyte file size. This is reasonably feasible since it is a
one-time setup only. Each voter uses genID and genIDCommit functions to generate identity and
commitments. In the table, it can be seen that these functions take sub-second times. Voters use
genWitness and genProof to generate their zero-knowledge proofs. They take around 10 secs to
generate a proof with the Semaphore circuit.

Table 2. The Semaphore Circuit & Function Times

Operation

Compile Circuit
Key Generation
Generate Verifier Contract

Time
(sec)
206
703
0.39

File Size
(mb)
132
128
0.01

Function

genID
genIDCommit
genWitness
genProof

Time
(sec)
0.027504
0.099805
1.622
8.446

We conducted tests for our Tideman algorithm. The algorithm heavily uses graphs, matrixes,
and sorting algorithms which are very costly for smart contracts. We reduced storage costs by
using the rank & unranking permutation algorithm. We see that the Tideman library is capable
of running with 250 voters and 10 candidates. The calculateResult function hits the 30 million gas
limit with more than 250 voters and thus cannot be used for more than 250 voters. The function is
a view function that does not consume actual transaction fees. This makes it a viable option for
small-scale elections. We show the Tideman algorithm gas consumption results for 250 voters and
10 candidates in the table 3.

8.1 Comparison
We compared the ElectAnon with similar works like McCorry et al.[24] and PriScore [42]. McCorry
et al. [24] conducted their gas consumption tests with 40 voters. PriScore [42] also shows gas
costs for each of their different functions. We computed their total gas costs for 40 voters and 10
candidates. We also run our tests with 40 voters and 10 candidates setup. A comparison table can

101001,00010,000100,0000.0010.010.11101001,00010,000VoterCountElapsedSecondMerkleTreeTimegenTreegenMerkleProof101001,00010,000100,000101001,00010,000100,000VoterCountSizeinKBMerkleProofFileSize122

Ceyhun Onur and Arda Yurdakul

Table 3. Tideman Gas Results (voterCount=250, candidateCount=10)

Entity: Transaction Gas Cost
4,065,760
Deployment
276,929
addVoters
286,064
addProposers
42,155
propose
71,877
toProposalState
312,382
commitVote
84,454
revealVote
21,113,398
electionResult

be found in Table 4. We found that ElectAnon offers an 83% and 89% decrease in total election gas
costs compared to McCorry et al. [24] and Priscore [42], respectively.

Table 4. Gas Comparison Table (voterCount=40, candidateCount=10)

Entity: Transaction McCorry et al.[24] Priscore [42] This Work
A: Deploy
A: Add Voters
A: Add Proposers
A: State Change
P: Propose
V: Register
V: Commit
V: Vote
A: Tally
Authority Total
Proposer Total
Voter Total
Election Total

-
-
-
-
-
-
1,107,374
3,579,468
60,096
60,096
-
4,686,842
187,533,776

6,215,811
2,153,461
-
3,320,433
-
763,118
70,112
2,490,412
746,485
12,436,190
-
3,323,642
145,381,870

3,430,754
113,963
286,040
71,877
42,681
-
312,856
105,140
48,937
3,665,531
42,681
417,996
20,812,181

8.2 Discussion
At the time of writing this work, the gas price in Ethereum is equivalent to nearly 100 gwei, and
one ETH price is approximately $4,500. A gwei equals to 109 ETH, so a gwei roughly equals to
$4, 500/109 = $0.0000045. It means that, a single gas costs 100 âˆ— $0.0000045 = $0.00045. In our work,
voters total gas cost is 417,996 which makes $0.00045 âˆ— 417, 996 = $188.09. We considered running
the ElectAnon in another Ethereum Virtual-Machine compatible network, Avalanche. Avalanche
implements a novel consensus mechanism with proof-of-stake Sybil protection [34]. It offers a
faster finalization time with fairly low gas fees when compared to Ethereum. The Avalanche gas
price changes between 25-150 nAVAX (equivalent to gwei) [21]. The current price of Avalanche is
$85 on average. If we take the gas price as nearly 100 nAVAX, then our voting transactions costs
100/109 âˆ— $85 âˆ— 417, 996 = $3.55. We run an election with 10 voters and 10 candidates in Avalanche
local network. We found that ElectAnon is compatible with the Avalanche network, and it costs
the same gas as the Ethereum network. However, since gas prices and the AVAX price are much
lower than the Ethereum main network, it significantly reduces the election cost.

In our tests, we found that the voter functions, i.e. commitVote, revealVote, calculateResult, are
not affected by the increased voter count. It means that voters do not pay for extra gas in case
of a large-scale election. The cost of election authority increases with both candidate count for

ElectAnon: A Blockchain-Based, Anonymous, Robust and Scalable Ranked-Choice Voting Protocol

23

addProposers and voter count for addVoters. We assume that the election authority has enough
resources to conduct the election.

A possible bottleneck of ElectAnon could be adding voters to the eligible list. It costs almost a
total of 10,000,000 gas for 10,000 voter registration. 10,000,000 gas, i.e 10,000 voters, almost costs
$5000 in Ethereum. It means that a single leaf insertion costs approximately 5000/10, 000 = $0.5.
This is a fair cost for small to medium scale elections, i.e. up to 10,000 voters. The gas cost increases
linearly. A large-scale election with 1,000,000 voters would cost approximately $500.000. Even
though our work offers the best gas consumption amongst others like McCorry et al. [24] and
Priscore [42], $500.000 is still too much. The total USD cost can be decreased using the Avalanche
network, which has a significantly lower gas price. The same total cost to register 1,000,000 voters
can be decreased to almost 100/109 âˆ— $85 âˆ— 10, 000, 000 âˆ— 100 = $8500 in the Avalanche.

8.3 Merkle Forest
We also run tests for the Merkle forest Extension with various fixed tree sizes. Each size represents
the total leaf size, and thus the maximum voter count can fit into one tree. We show results for
two different implementations in Table 5. One of the implementations uses the Keccak-256 hash
function; the other one uses public input lists. Implementation with the Keccak-256 hash function
consumes less gas. It is because the smart contract takes a single hash input. Whereas in the other
implementation without Keccak-256, all leaves are passed to the verifier to be verified. Giving a
complete list instead of a single hash increases the gas consumption with respect to increased
voter count. We see that the implementation without the Keccak-256 hash function produces fewer
circuit constraints. As a result, generation times and file sizes are much lower.

We think that the circuit with Keccak-256 is more feasible for a smart contract approach since it
consumes almost one-quarter of gas compared to the one without Keccak-256. Inserting a 256-sized
tree with the Keccak-256 circuit consumes 482,409 gas, whereas the implementation without Merkle
forest extensions consumes 276,929 for 200 voter registration. Itâ€™s possible to generate a 256-size
tree circuit and insert multiple trees to the smart contract, thus increasing the total voter count
with several rounds. We think the Merkle forest extension can be a feasible option for small-scale
elections.

Table 5. Test Results for Merkle Forest Implementations

Used
Keccak

Size Constraints

Compile
Time

Setup
Time

Witness
Time

Proof
Time

Deploy
Gas

Insert
Gas

Insert Gas per
Size

Compiled
Size
(MB)

Proving
Key Size
(MB)

Yes
No

Yes
No

Yes
No

Yes
No

Yes
No

16
16

32
32

64
64

128
128

256
256

661,908
39,601

1,326,724
81,874

2,656,356
166,321

5,162,019
335,281

10,173,347
673,201

0:00:29
0:00:12

0:01:05
0:00:27

0:02:53
0:01:02

0:05:18
0:02:16

0:30:49
0:07:56

0:04:44
0:00:24

0:09:42
0:00:53

0:21:06
0:01:52

0:37:37
0:03:17

1:16:15
0:06:48

0:00:10
0:00:07

0:00:22
0:00:16

0:00:53
0:00:34

0:01:36
0:01:08

0:03:17
0:02:17

0:00:30
0:00:11

0:01:07
0:00:25

0:02:28
0:00:53

0:04:29
0:01:48

0:10:03
0:03:55

1,404,004
1,714,373

1,405,936
2,128,664

1,404,004
2,948,257

322,106
419,031

332,534
558,448

353,931
839,127

20,131.625
26,189.4375

10,391.6875
17,451.5

5530.171875
13,111.35938

1,404,016
4,595,134

396,685
1,405,349

3099.101563
10,979.28906

1,404,640
7,890,686

482,409
2,559,015

1884.410156
9996.152344

452
292

957
636

1900
1300

3900
2700

7800
5400

229
14

459
28

918
57

1800
114

3500
228

9 CONCLUSION AND FUTURE WORK
In this work, we proposed a blockchain-based, anonymous ranked-choice voting protocol. Our work,
ElectAnon, ensures anonymity with zero-knowledge proofs. We used a zero-knowledge gadget,

24

Ceyhun Onur and Arda Yurdakul

Semaphore [15], which provides anonymous membership proofs with the efficient zk-SNARK
technique. Our protocol also provides efficient mechanisms for ranked-choice voting. We used an
effective algorithm [27] to encode and decode our ranked-choice lists with integers. ElectAnon is
designed to be robust and uninterruptible in the voting phase. We implemented the protocol in
Ethereum smart contracts to ensure decentralization and robustness. We also defined some of the
most critical election requirements and provided a deep-down analysis of prior works. We also
discussed and analyzed alternative extensions like Merkle Forest and the Tideman method for our
protocol. We have run experiments and shown the results. We also compared our work with prior
works. Our protocol not only assures critical election requirements but also scales to be used in
large-scale elections. Overall, we show that ElectAnon can especially be beneficial for governance
applications like decentralized autonomous organizations (DAOs).

Our current voting scheme expects voters to decide their preferences for all candidates. In other
words, each preference list must contain all possible candidates. This can be a burden for elections
with many candidates, as voters have to evaluate all candidates and form a list of all candidates
sorted by their preferences. It can be avoided by specifying a smaller preference list size. For
example, suppose there are 50 candidates, the election can require voters to decide on a smaller
number like 10 or 5 candidates as their preference lists. So voters can evaluate a smaller candidate
subset instead of the whole set. Authors of the Ranking and unranking permutations in linear time
[27] mention a possible extension to accomplish ğ‘˜-permutations of an ğ‘›-set. As future work, we
aim to implement this approach for our preference list encoding to reduce the required list size,
and thus usability can be increased.

ACKNOWLEDGMENTS
This research was partially supported by BoÄŸaziÃ§i University Scientific Research Projects (BAP) No:
17A01P7.

REFERENCES
[1] 2021. Circom. https://github.com/iden3/circom original-date: 2021-10-11T07:55:24Z.
[2] 2021. Ownerless Ownership, Trustless Trust â€” DAOs, the Future of Governance. https://beincrypto.com/ownerless-

ownership-trustless-trust-daos-the-future-of-governance/

[3] Sufyan Al-Janabi and Noor Hamad. 2019. Security of Internet Voting Schemes: A Survey. SSRN Scholarly Paper ID

3459657. Social Science Research Network, Rochester, NY. https://papers.ssrn.com/abstract=3459657

[4] R. Michael Alvarez, Thad E. Hall, and Alexander H. Trechsel. 2009. Internet Voting in Comparative Perspective: The
Case of Estonia. PS: Political Science & Politics 42, 3 (2009), 497â€“505. https://doi.org/10.1017/S1049096509090787

[5] Jim Anest. 2009. Ranked choice voting. Journal of Integral Theory and Practice 4, 3 (2009), 23â€“40.
[6] Eli Ben Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza.
2014. Zerocash: Decentralized Anonymous Payments from Bitcoin. In 2014 IEEE Symposium on Security and Privacy.
459â€“474. https://doi.org/10.1109/SP.2014.36

[7] Juan Benet. 2014. IPFS - Content Addressed, Versioned, P2P File System. (07 2014).
[8] Vitalik Buterin. 2014. A next-generation smart contract and decentralized application platform. Etherum (2014). Issue

January.

[9] Drew Desilver. 2021.

Mail-in voting became much more common in 2020 primaries as COVID-19
spread. https://www.pewresearch.org/fact-tank/2020/10/13/mail-in-voting-became-much-more-common-in-2020-
primaries-as-covid-19-spread/

[10] Todd Donovan, Caroline Tolbert, and Kellen Gracey. 2019.

Choice Voting.
arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1111/ssqu.12651

Social Science Quarterly 100, 5 (2019), 1768â€“1776.

Self-Reported Understanding of Ranked-
https://doi.org/10.1111/ssqu.12651

[11] Youssef El Faqir, Javier Arroyo, and Samer Hassan. 2020. An Overview of Decentralized Autonomous Organizations
on the Blockchain. In Proceedings of the 16th International Symposium on Open Collaboration (Virtual conference,
Spain) (OpenSym 2020). Association for Computing Machinery, New York, NY, USA, Article 11, 8 pages. https:
//doi.org/10.1145/3412569.3412579

ElectAnon: A Blockchain-Based, Anonymous, Robust and Scalable Ranked-Choice Voting Protocol

25

[12] Peter Emerson. 2013. The original Borda count and partial voting. Social Choice and Welfare 40, 2 (Feb. 2013), 353â€“358.

https://doi.org/10.1007/s00355-011-0603-9

[13] Ethereum Foundation. 2019. Istanbul. https://eth.wiki/roadmap/istanbul
[14] Dimitris A Gritzalis. 2002. Principles and requirements for a secure e-voting system. Computers & Security 21, 6 (2002),

539â€“556. https://doi.org/10.1016/S0167-4048(02)01014-3

[15] Kobi Gurkan, WJ Koh, and Barry Whitehat. 2020. Community Proposal: Semaphore: Zero-Knowledge Signaling on

Ethereum. Accessed: Jul 1 (2020), 2021.

[16] FriÃ°rik Ã*. HjÃ¡lmarsson, Gunnlaugur K. HreiÃ°arsson, Mohammad Hamdaqa, and GÃ­sli HjÃ¡lmtÃ½sson. 2018. Blockchain-
Based E-Voting System. In 2018 IEEE 11th International Conference on Cloud Computing (CLOUD). 983â€“986. https:
//doi.org/10.1109/CLOUD.2018.00151 ISSN: 2159-6190.

[17] Michelle Reeb Homp, Alyssa Seideman, and Sean Gravelle. 2019. Contemporary Mathematics: Contemporary Mathe-

matics at Nebraska. https://mathbooks.unl.edu/Contemporary/

[18] Uzma Jafar, Mohd Juzaiddin Ab Aziz, and Zarina Shukur. 2021. Blockchain for Electronic Voting Systemâ€”Review and

Open Research Challenges. Sensors 21, 17 (2021). https://doi.org/10.3390/s21175874

[19] Toby S. James. 2021. New development: Running elections during a pandemic. Public Money & Management 41, 1

(2021), 65â€“68. https://doi.org/10.1080/09540962.2020.1783084 arXiv:https://doi.org/10.1080/09540962.2020.1783084

[20] Robert Krimmer, David Duenas-Cid, and Iuliia Krivonosova. 2021. Debate: safeguarding democracy during pandemics.
Social distancing, postal, or internet votingâ€”the good, the bad or the ugly? Public Money & Management 41, 1 (2021),
8â€“10. https://doi.org/10.1080/09540962.2020.1766222 arXiv:https://doi.org/10.1080/09540962.2020.1766222

[21] Ava Labs. 2021. Transaction Fees. https://docs.avax.network/learn/platform-overview/transaction-fees
[22] Nomic Labs. 2019. Ethereum development environment for professionals by Nomic Labs. https://hardhat.org/
[23] Shlomi Linoy, Natalia Stakhanova, and Suprio Ray. 2021. De-anonymizing Ethereum blockchain smart contracts through
code attribution. International Journal of Network Management 31, 1 (2021), e2130. https://doi.org/10.1002/nem.2130
arXiv:https://onlinelibrary.wiley.com/doi/pdf/10.1002/nem.2130 e2130 nem.2130.

[24] Patrick McCorry, Siamak F. Shahandashti, and Feng Hao. 2017. A Smart Contract for Boardroom Voting with Maximum
Voter Privacy. In Financial Cryptography and Data Security, Aggelos Kiayias (Ed.). Springer International Publishing,
Cham, 357â€“375.

[25] Martin M Merener. 2012. Theoretical Results on De-Anonymization via Linkage Attacks. Trans. Data Priv. 5, 2 (2012),

377â€“402.

[26] Eduardo Morais, Tommy Koens, Cees van Wijk, and Aleksei Koren. 2019. A Survey on Zero Knowledge Range Proofs

and Applications. arXiv:1907.06381 [cs.CR]

[27] Wendy Myrvold and Frank Ruskey. 2001. Ranking and unranking permutations in linear time. Inform. Process. Lett. 79,

6 (2001), 281â€“284. https://doi.org/10.1016/S0020-0190(01)00141-7

[28] Satoshi Nakamoto. 2008. Bitcoin: A peer-to-peer electronic cash system. Decentralized Business Review (2008), 21260.
[29] Somnath Panja, Samiran Bag, Feng Hao, and Bimal Roy. 2020. A Smart Contract System for Decentralized Borda
Count Voting. IEEE Transactions on Engineering Management 67, 4 (2020), 1323â€“1339. https://doi.org/10.1109/TEM.
2020.2986371

[30] Juha Partala, Tri Hong Nguyen, and Susanna Pirttikangas. 2020. Non-Interactive Zero-Knowledge for Blockchain: A

Survey. IEEE Access 8 (2020), 227945â€“227961. https://doi.org/10.1109/ACCESS.2020.3046025

[31] MichaÅ‚ Pawlak and Aneta Poniszewska-MaraÅ„da. 2021. Trends in blockchain-based electronic voting systems. Infor-

mation Processing & Management 58, 4 (2021), 102595. https://doi.org/10.1016/j.ipm.2021.102595

[32] Maksym Petkus. 2019. Why and How zk-SNARK Works. arXiv:1906.07221 [cs.CR]
[33] Giuseppe Antonio Pierro, Roberto Tonelli, and Michele Marchesi. 2020. Smart-Corpus: an Organized Repository of

Ethereum Smart Contracts Source Code and Metrics. arXiv:2011.01723 [cs.SE]

[34] Team Rocket. 2018. Snowflake to avalanche: A novel metastable consensus protocol family for cryptocurrencies.

Available [online].[Accessed: 4-12-2018] (2018).

[35] SCOOP4C. 2021-11-18. Estonian Internet voting SCOOP4C.
[36] Fatemeh Shirazi, Stephan Neumann, Ines Ciolacu, and Melanie Volkamer. 2011. Robust electronic voting: Introducing

"https://scoop4c.eu/cases/estonian-internet-voting"

robustness in Civitas. 47 â€“ 55. https://doi.org/10.1109/REVOTE.2011.6045915

[37] StarkWare. 2021. StarkNet Alpha 2. https://medium.com/starkware/starknet-alpha-2-4aa116f0ecfc
[38] Solidity Team. 2015. Solidity Programming Language. https://soliditylang.org//
[39] T. N. Tideman. 1987. Independence of Clones as a Criterion for Voting Rules. Social Choice and Welfare 4, 3 (1987),

185â€“206. http://www.jstor.org/stable/41105866

[40] Zachary J. Williamson. 2018.

AztecProtocol/AZTEC.
7a020f4ced9680f6e4a452fe570671aac0802471/AZTEC.pdf original-date: 2018-11-26T13:50:05Z.

https://github.com/AztecProtocol/AZTEC/blob/

[41] Xuechao Yang, Xun Yi, Surya Nepal, Andrei Kelarev, and Fengling Han. 2020. Blockchain voting: Publicly verifiable
online voting protocol without trusted tallying authorities. Future Generation Computer Systems 112 (2020), 859â€“874.

26

Ceyhun Onur and Arda Yurdakul

https://doi.org/10.1016/j.future.2020.06.051

[42] Yang Yang, Zhangshuang Guan, Zhiguo Wan, Jian Weng, Hwee Hwa Pang, and Robert H. Deng. 2021. PriScore:
Blockchain-Based Self-Tallying Election System Supporting Score Voting. IEEE Transactions on Information Forensics
and Security 16 (2021), 4705â€“4720. https://doi.org/10.1109/TIFS.2021.3108494

[43] Shufan Zhang, Lili Wang, and Hu Xiong. 2019. Chaintegrity: blockchain-enabled large-scale e-voting system with

robustness and universal verifiability. International Journal of Information Security 19 (2019), 323â€“341.

[44] ZoKrates. 2017. ZoKrates. https://github.com/Zokrates/ZoKrates

