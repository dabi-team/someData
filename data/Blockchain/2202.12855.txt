Atomic cross-chain exchanges of shared assets
Krishnasuri Narayanam
IBM Research, India
knaraya3@in.ibm.com

Venkatraman Ramakrishna
IBM Research, India
vramakr2@in.ibm.com

Dhinakaran Vinayagamurthy
IBM Research, India
dvinaya1@in.ibm.com

Sandeep Nishad
IBM Research, India
sandeep.nishad1@ibm.com

2
2
0
2

p
e
S
0
1

]

R
C
.
s
c
[

3
v
5
5
8
2
1
.
2
0
2
2
:
v
i
X
r
a

ABSTRACT
A core enabler for blockchain or DLT interoperability is the ability
to atomically exchange assets held by mutually untrusting own-
ers on different ledgers. This atomic swap problem has been well-
studied, with the Hash Time Locked Contract (HTLC) emerging as
a canonical solution. HTLC ensures atomicity of exchange, albeit
with caveats for node failure and timeliness of claims. But a bigger
limitation of HTLC is that it only applies to a model consisting of
two adversarial parties having sole ownership of a single asset in
each ledger. Realistic extensions of the model in which assets may
be jointly owned by multiple parties, all of whose consents are re-
quired for exchanges, or where multiple assets must be exchanged
for one, are susceptible to collusion attacks and hence cannot be
handled by HTLC. In this paper, we generalize the model of asset ex-
changes across DLT networks and present a taxonomy of use cases,
describe the threat model, and propose MPHTLC, an augmented
HTLC protocol for atomic multi-owner-and-asset exchanges. We
analyze the correctness, safety, and application scope of MPHTLC.
As proof-of-concept, we show how MPHTLC primitives can be
implemented in networks built on Hyperledger Fabric and Corda,
and how MPHTLC can be implemented in the Hyperledger Labs
Weaver framework by augmenting its existing HTLC protocol.

CCS CONCEPTS
• Computing methodologies → Distributed computing method-
ologies; • Software and its engineering → Software creation
and management; • Networks → Network protocols.

KEYWORDS
blockchain, distributed ledger technology, fair exchange, HTLC,
shared assets, co-ownership, atomicity, interoperability

ACM Reference Format:
Krishnasuri Narayanam, Venkatraman Ramakrishna, Dhinakaran Vinayaga-
murthy, and Sandeep Nishad. 2022. Atomic cross-chain exchanges of shared
assets. In Proceedings of AFT ’22: Conference on Advances in Financial Tech-
nologies (AFT ’22). ACM, New York, NY, USA, 18 pages. https://doi.org/
XXXXXXX.XXXXXXX

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
AFT ’22, September 19–21, 2022, Cambridge, MA
© 2022 Association for Computing Machinery.
ACM ISBN 978-1-4503-XXXX-X/18/06. . . $15.00
https://doi.org/XXXXXXX.XXXXXXX

1 INTRODUCTION
The existence of diverse blockchain and distributed ledger tech-
nologies (DLTs) and networks, especially permissioned ones, have
spurred research [4, 8], development [3, 33], and standardization
[21, 27] efforts in interoperability. If networks cannot interoperate,
their business processes (contracts) cannot interlink and their assets
get trapped in silos, preventing them from scaling up and decreas-
ing their relevance in the overall blockchain economy [3, 27]. A
key interoperation enabler is the atomic swap [38], or the ability to
exchange assets in two different ledgers/networks (we will use these
terms interchangeably for systems that manage shared assets using
blockchain or DLT ) between a pair of owners atomically; i.e., the ex-
change happens or both ledgers revert to their original states. This
problem has gained increased salience with the emergence of De-
centralized Finance (DeFi) [20] and Central Bank Digital Currencies
(CBDCs) [39]. But, as we will see, the state-of-the-art, and exist-
ing models and solutions, are inadequate for complex exchanges
involving multiple owners and assets, which require new solutions.
The canonical asset swap can be understood through an example.
Alice and Bob possess accounts in both the Bitcoin and Ethereum
Main networks. They come to an (off-chain) agreement whereby
Alice will give Bob 10 BTC in exchange for, say, 12 ETH. The ex-
pected outcome of this exchange/swap is that a transfer of 10 BTC
from Alice to Bob is confirmed on the Bitcoin network while simul-
taneously a transfer of 12 ETH from Bob to Alice is confirmed on
the Ethereum Mainnet. Both transfers occur or neither does, ideally
without requiring a trusted mediator or complex cross-network
synchronization (e.g., linking clocks, coordinating block confirma-
tion frequencies). A similar example can be conceived between two
permissioned networks, built on, e.g. Hyperledger Fabric and Corda,
using tokens designed for those DLT platforms [1, 2]. Delivery-vs-
payment (DvP), a common DeFi use case, offers additional motiva-
tion. Consider a DLT network where different commercial banks
possess retail accounts of a Central Bank Digital Currency (CBDC)
and another DLT network where banks allow investors to trade
securities (e.g. bonds). The transfer of a bond on the latter must
simultaneously accompany a CBDC payment on the former [22].
From these examples, we can extrapolate a general model of
exchanging an asset 𝑀, owned by party 𝑋 in ledger L1, for asset 𝑁 ,
owned by party 𝑌 in ledger L2 (Figure 1). The canonical solution
to complete such atomic swaps is the Hash Time Locked Contract
(HTLC) [34]. This describes both a contract that supports the lock-
ing and claiming of an asset within a fixed time duration and a
protocol (see Figure 2), whose "happy path" is as follows:

• 𝑋 hashes secret 𝑠 to produce 𝐻 = 𝐻𝑎𝑠ℎ(𝑠)

 
 
 
 
 
 
AFT ’22, September 19–21, 2022, Cambridge, MA

Krishnasuri Narayanam, Venkatraman Ramakrishna, Dhinakaran Vinayagamurthy, and Sandeep Nishad

Figure 1: Asset Exchange (Atomic Swap) Model

• 𝑋 locks 𝑀 on L1, specifying 𝑌 as the recipient, with 𝐻 as guard
for duration 𝑇 using a blockchain or smart contract transaction
• 𝑌 similarly locks 𝑁 on L2 with 𝐻 (now publicly known), speci-

fying 𝑋 as the recipient, for duration 𝑇 /2

• 𝑋 claims 𝑁 on L2 by revealing 𝑠 (which, when hashed, must

match 𝐻 ) via a transaction within 𝑇 /2

• 𝑌 similarly claims 𝑀 on L1 by supplying 𝑠 (now publicly known)

after 𝑋 ’s claim but within 𝑇

This protocol works because (i) both 𝑋 and 𝑌 have visibility into
both ledgers, be they in public or permissioned networks, (ii) 𝑋 ’s
secret is revealed to 𝑌 only after both assets are locked, (iii) the
secret is revealed in public within a transaction for any claimers to
use, (iv) 𝑌 has sufficient time to make a claim after 𝑋 does so by
revealing 𝑠; if 𝑌 locks immediately after 𝑋 does, 𝑋 has up to 𝑇 /2 to
make its claim, leaving 𝑌 at least 𝑇 /2 before the expiration of 𝑋 ’s
lock, and (v) only 𝑋 and 𝑌 will be able to claim assets as designated
recipients. To support HTLC, a DLT platform must enable asset
locking (or enforce any general constraint) for a fixed time duration.
Can HTLC be generalized for atomic exchanges of more than two
assets and joint ownership (or co-ownership) of assets by multiple
parties? In one extension to the basic model, we can add party 𝑊
to the mix so that 𝑋 and 𝑊 co-own 𝑀 in L1 (Figure 3), with the
desired outcome of 𝑋 and𝑊 co-owning 𝑁 in L2 and 𝑌 owning 𝑀 in
L1. E.g., 𝑀 is a title to property owned jointly by two parties, who
are willing to sell it to a third party in exchange for money being
transferred to a joint account held by them. In another extension,
𝑊 owns a third asset 𝑅 in L1, and the desired outcome is that
𝑌 acquires 𝑀 and 𝑅 in L1 in exchange for transferring 𝑁 in L2
jointly to 𝑋 and 𝑊 (Figure 4). E.g., 𝑀 and 𝑅 are separate titles to
two co-located properties that are sold together to a third party in
exchange for money being transferred to the owners’ joint account.
Though these scenarios seem superficially similar to the base case,
application of the basic HTLC protocol in either is susceptible to
attack whereby 𝑋 can cheat 𝑊 by colluding with 𝑌 so that 𝑊 loses
ownership of its asset while both 𝑋 and 𝑌 gain something, as we will
see in Section 2. Addressing such flaws and creating a generalized
HTLC solution for generalized asset exchanges is the goal of this
paper, whose contributions can be summarized as follows:

• A generalized model of asset exchanges across DLT networks
with a taxonomy of use cases exhaustively covering all atomic
cross-network transaction possibilities. We present an associated

threat model, call out desired safety properties, and identify the
shortcomings of HTLC with respect to these properties.

• An augmented HTLC protocol MPHTLC, using multi-party com-
putation (MPC), for atomic multi-party-and-asset exchanges that
is proven secure in this model.

• An implementation of this protocol in the open-source Hyper-
ledger Labs Weaver framework to facilitate generic atomic multi-
party-and-asset exchanges between distributed applications built
on Hyperledger Fabric and Corda networks. We also perform a
simple evaluation to show that MPHTLC is practically usable.
In Section 2, we generalize the asset exchange (or atomic swap)
problem, and model the scenarios and resulting threats exhaustively.
Our solution for the general model that handles these threats is
described in Section 3 and its efficacy is analyzed in Section 4.
Practical design considerations, and suggestive implementations
on two prominent DLT platforms, are discussed in Section 5. After
covering related work in Section 6, we conclude with suggestions
for future work in Section 7.

2 GENERALIZING ASSET EXCHANGES
In this section, we will comprehensively analyze and categorize
the modes of asset exchanges that a group of parties can carry out
across two distributed ledgers. We will scope the problem space,
define basic and complex transaction types, and present a formal
generalized asset exchange (GAE) model. Then we will show that
conventional HTLC when applied to this model is prone to attacks,
and identify remedies which lead to our solution.

2.1 Asset Co-Ownership
Before describing the model, we will define what we mean by co-
ownership of an asset and state the properties expected from a DLT
to manage such co-ownership. Conventionally, ownership of an
asset in a blockchain or smart contract system implies sole authority
to change the state of that asset, lock (freeze) its state until certain
conditions are met, or transfer it to another owner. The state of
an asset is subject to change according to rules defined in scripts
(e.g., Bitcoin [12]) or contracts (e.g., Ethereum [15], Hyperledger
Fabric [5]). DLT systems are expected to ensure, through consensus
mechanisms and well-vetted scripts/contracts, that only rightful
owners can lock assets, change their properties, or transfer them.
We define co-ownership as the ability of a ledger or smart con-
tract system to enforce similar integrity rules on assets where the

Atomic cross-chain exchanges of shared assets

AFT ’22, September 19–21, 2022, Cambridge, MA

Figure 2: Hash Time Locked Contract (HTLC) Protocol

Figure 3: Jointly Owned Asset Exchange

Figure 4: Multi-Asset Exchange

owner is a collective rather than a single entity. Any state update or
transfer or lock must require the consent of some or all members of
the collective (i.e., co-owners). A typical way to enforce this is mul-
tisig, or multiple signatures, [14, 43], where the contract requires a
quorum of signatures on a transaction to update ledger state. Our

minimal expectation from a smart contract system is its ability to
enforce multiple or unanimous consent on asset modifications, i.e.,
allow an asset to be governed by multiple users.

AFT ’22, September 19–21, 2022, Cambridge, MA

Krishnasuri Narayanam, Venkatraman Ramakrishna, Dhinakaran Vinayagamurthy, and Sandeep Nishad

2.2 Basic Transaction Types
Let us analyze cross-ledger exchange transactions (or simply cross-
ledger exchanges), i.e., transactions that involve multiple asset own-
ership changes in two ledgers possibly with atomicity requirements.
Figures 1, 3, and 4, illustrate examples. We can identify and cate-
gorize patterns within cross-ledger exchanges; elements of these
categories vary only in the number of co-owners and in the numbers
of assets involved in the transactions. We will prove that these pat-
terns exhaustively cover all permutations where arbitrary numbers
of assets with arbitrary co-owner sets are to be exchanged across
two ledgers. To start with, we can identify certain fundamental
operations on which cross-ledger exchanges are built:

• Creation of an asset with assignment of one or more co-owners
• Destruction of an asset with every co-owner losing ownership
• Changes to the co-ownership set of an asset: add co-owner(s),

remove co-owner(s), or both simultaneously

Since exchange scenarios take the existence of the assets in question
for granted, we can disregard the first two operations and focus on
co-ownership changes. As described earlier, addition or removal of
co-owners requires existing co-owners’ consents, typically using
signatures, though the precise consent criteria can vary with ledger
or contract without changing the semantics of ownership change.
(For example, if an asset has more than one co-owner, the replace-
ment of one of the co-owners may or may not require consent of
the other co-owners.) Therefore, without loss of generality, we will
assume in this paper that consent from co-owners is required for
any addition or remove of an asset’s co-owners in the context of
an atomic exchange. Now we can list the cross-ledger exchanges
that are built on these fundamental operations:

• Unconnected Local Transfers (ULTs): A pair of asset transfers in
two ledgers where neither the initial nor the final owner of one
asset matches the initial or final owner of the other asset (as
illustrated in Figure 5a). In effect, these transfers are not interde-
pendent and can be executed simply as smart contract invocations
localized to the respective ledgers. None of the involved parties
have an atomicity requirement.

• Cross-Ledger Replacements (CLRs): A pair of transfers where the
initial owner of one asset is the same as the final owner of the
other (as illustrated in Figure 5b).

• Cross-Ledger Swaps (CLSs): A pair of transfers where the initial
owner of one asset is the same as the final owner of the other and
vice versa (as illustrated in Figure 5c and also earlier in Figure 1).

A CLR can be viewed as a ULT pair with more constraints, where
𝑋 == 𝑊 , i.e., 𝑋 and 𝑊 are combined into a single logical entity.
From 𝑋 ’s perspective (though not from 𝑌 ’s or 𝑍 ’s), the two transac-
tions must happen atomically. Similarly, a CLS can be viewed as a
CLR with more constraints, where 𝑌 == 𝑍 , and both 𝑋 and 𝑌 desire
atomicity. As we can see, more constraints create more atomicity
requirements. Even though ULTs have no atomicity requirements,
it is necessary to list them here for completion. A general cross-
ledger exchange (defined later in this section) will be built on a
combination and extrapolation of all these basic types, with some
subset of parties desiring atomicity.

Our classification covers the possibility of ULT participants
{𝑋, 𝑌, 𝑍,𝑊 } desiring atomicity for their pair of transfers. Using

HTLC, the first locker (say 𝑋 ) can share the secret through an off-
chain communication channel with the first claimer (say 𝑊 ). To
the ledger/contract, this effectively combines X and W into a single
logical entity, and the resulting scenario becomes congruent to a
CLR. Further, if the second locker (𝑍 ) and second claimer (𝑌 ) are the
same logical (or real-world) entity, the scenario morphs into a CLS.
Hence, enforcing atomicity on a pair of ULTs (the most general
transfer pair in a 2-ledger system) must correspond to a CLR or a
CLS pattern, proving that our categorization of basic transaction
types is exhaustive. Without an atomicity requirement, a ULT pair
can simply be enforced through a pair of smart contract invoca-
tions in the respective ledgers in any sequence, while a CLS can
be enforced using HTLC. A CLR can also be enforced using HTLC
if the shared entity (𝑋 in Figure 5b) locks 𝑀 first and then claims
𝑁 from 𝑍 by revealing its secret. Also, CLRs can be augmented
by adding multiple co-owners in place of 𝑋 or by adding multiple
asset owners in L1, that would jointly claim 𝑁 in L2 (as with the
CLS augmentations in Figures 3 and 4). Hence, we can treat CLRs
and CLSs as similar exchange problems requiring similar solutions.

2.3 Complex Cross-Ledger Transactions
We can build arbitrarily complex transactions using the basic trans-
actions as building blocks simply by:
• Adding more co-owners to each asset (Figure 3)
• Involving more assets in the exchange (Figure 4)
In general, a complex transaction involves a set of arbitrary co-
ownership transfers of an arbitrary set of assets within two ledgers,
some of which require cross-network atomicity guarantees. We
claim that this can be expressed as a union of ULTs, CLRs, and
CLSs where each asset has one or more co-owners (let us call the
generalized multi-co-owner variants as gULT, gCLR and gCLS re-
spectively). We assume that the contracts reflect the intents of the
group of parties involved in the exchanges: i.e., some transactions
require atomicity and others do not. We can assume, without loss
of generality, that all transactions in an exchange scenario require
atomicity and that the users have already excluded those that do not.
Also, for any asset that is being replaced or swapped, we assume
that all co-owners of those assets are actively involved in the cross-
network transaction, even if some of those co-owners’ roles are
purely limited to one ledger. A ledger/contract can always exclude
such co-owners from cross-network transactions, by allowing them
to just endorse (sign) a local transfer, which the ledger can pro-
cess concurrently with a complex atomic cross-ledger transaction.
Our model and solution will manage just the complex cross-ledger
transaction, which existing ledgers are not equipped for.

For example, let us augment the CLR model in Figure 5b to add
an initial co-owner 𝑊 for asset M in ledger L1, so that 𝑋 and 𝑊
together transfer 𝑀 to 𝑌 . But in ledger L2, 𝑊 still does not take
part in any transaction. We can represent this as follows:
• L1 : 𝑀 : {𝑋,𝑊 } → {𝑌 }
• L2 : 𝑁 : {𝑍 } → {𝑋 }
From 𝑊 ’s perspective, the first transaction is a ULT. Hence this
transaction pair is a combination of a ULT and a CLR. 𝑊 just needs
to endorse 𝑋 ’s locking of 𝑀 in 𝑌 ’s favor by signing the transaction.
But the final outcome requires atomic commitments; hence we
can merge this ULT into the CLR and require 𝑊 and 𝑋 to lock 𝑀

Atomic cross-chain exchanges of shared assets

AFT ’22, September 19–21, 2022, Cambridge, MA

Figure 5: Basic Transaction Types: (a) Unconnected Local Transactions, (b) Cross-Ledger Replacement, (c) Cross-Ledger Swap

jointly. We encounter the exact same possibilities and outcome if
we augment a CLS (Figure 5c) as follows:

• L1 : 𝑀 : {𝑋,𝑊 } → {𝑌 }
• L2 : 𝑁 : {𝑌 } → {𝑋 }
𝑊 plays an ancillary role by simply doing a ULT to 𝑌 , but that ULT
can be merged with the CLS, making 𝑊 an active participant in
the swap. Merging ULTs into atomic transactions preserves the
final outcome (i.e., co-ownership changes remains the same), while
making analysis and solution-building easier. Therefore, we can
assume merging as default without our model losing any power.

Here is a scenario that shows how a complex transaction is a
composition of basic transactions. This is illustrated in Figure 6
(symbols will be explained later.) The following are the asset trans-
fers (or asset ownership changes) occurring in the two ledgers:

• L1 : 𝐶𝑢𝑟𝑟𝑒𝑛𝑐𝑦 : {𝑋, 𝑌 } → {𝑊 , 𝑌 , 𝑍 }
• L1 : 𝑆𝑒𝑐𝑢𝑟𝑖𝑡𝑦 : {𝑇 , 𝑈 } → {𝑉 }
• L1 : 𝐷𝑖𝑎𝑚𝑜𝑛𝑑 : {𝑍 } → {𝑉 }
• L2 : 𝐶𝑎𝑟 : {𝑇 } → {𝑇 , 𝑈 ,𝑊 }
• L2 : 𝐻𝑜𝑢𝑠𝑒 : {𝑍 } → {𝑇 , 𝑋, 𝑌 }
By inspection, we can deconstruct this set of transactions:

• L1 : 𝐶𝑢𝑟𝑟𝑒𝑛𝑐𝑦 : {𝑋, 𝑌 } → {𝑊 , 𝑌 , 𝑍 } and L2 : 𝐻𝑜𝑢𝑠𝑒 : {𝑍 } →
{𝑇 , 𝑋, 𝑌 } together comprise a gCLS from the perspective of {𝑋, 𝑌 }
as one group of co-owners and {𝑍 } as another. 𝑊 and 𝑇 are sim-
ply claimants and don’t play an active role in the swap, but their
endorsements (i.e., digital signatures on the transfer transactions)
are needed to finalize the transactions; hence, their roles can be
merged into the CLS as a whole. (Note: excluding 𝑊 and 𝑇 still
leaves multiple co-owners ({𝑋, 𝑌 , 𝑍 }) for the two assets being
swapped, so this scenario is a complex swap according to our

model. As we will see in Section 2.6, such an exchange cannot be
handled as a simple swap using classic HTLC.)

• L1 : 𝑆𝑒𝑐𝑢𝑟𝑖𝑡𝑦 : {𝑇 , 𝑈 } → {𝑉 } and L2 : 𝐶𝑎𝑟 : {𝑇 } → {𝑇 , 𝑈 ,𝑊 }
together comprise a gCLR from 𝑈 ’s perspective. 𝑇 simply gives or
shares its co-ownership and 𝑉 and 𝑊 simply take co-ownerships,
but their roles can be merged into the gCLR as a whole. It is up the
the users whether or not to complete this gCLR independent of
the above gCLS, but if they so intend, it can be enforced atomically
with the gCLS, in effect merging the two exchanges into a single
atomic exchange. This is the default assumption our solution will
make when presented with a set of transactions (see Section 3).
• L1 : 𝐷𝑖𝑎𝑚𝑜𝑛𝑑 : {𝑍 } → {𝑉 } is a ULT as it is unconnected to the
other transactions in the set. But, if the users so intend, this can
be completed atomically with the other transactions, and that is
the default assumption our solution will make when presented
with a set of transactions (see Section 3).

2.4 Generalized Asset Exchange Model
We now formally model the problem of atomically changing co-
ownership configurations of assets in two independent ledgers,
where the co-owners across all assets belong to a common limited
size group of parties.

Definition 2.1 (generalized asset exchange: GAE). This is a tuple

⟨L1, L2, P, A1, A2, IO1, IO2, AE1, AE2, FO1, FO2⟩ where:
• L1 and L2 are two distinct ledgers
• P is a common set of parties with accounts in both L1 and L2
• A1 is a set of assets on L1
• A2 is a set of assets on L2
• IO1 is the initial asset ownership function in L1, defined as IO1 :

A1 → 2P − {∅}

AFT ’22, September 19–21, 2022, Cambridge, MA

Krishnasuri Narayanam, Venkatraman Ramakrishna, Dhinakaran Vinayagamurthy, and Sandeep Nishad

• IO2 is the initial asset ownership function in L2, defined as IO2 :

A2 → 2P − {∅}

• AE1 is a set of assets in L1 to be exchanged, where AE1 ⊆ A1
• AE2 is a set of assets in L2 to be exchanged, where AE2 ⊆ A2
• FO1 is the final asset ownership function in L1 after the exchange,

defined as FO1 : A1 → 2P − {∅}, where:
– ∀𝑎 ∈ A1 − AE1, FO1 (𝑎) = IO1 (𝑎), and
– ∀𝑎 ∈ AE1, FO1 (𝑎) ∈ 2P − {∅} ∧ FO1 (𝑎) ≠ IO1 (𝑎)

• FO2 is the final asset ownership function in L2 after the exchange,

defined as FO2 : A2 → 2P − {∅}, where:
– ∀𝑎 ∈ A2 − AE2, FO2 (𝑎) = IO2 (𝑎), and
– ∀𝑎 ∈ AE2, FO2 (𝑎) ∈ 2P − {∅} ∧ FO2 (𝑎) ≠ IO2 (𝑎)

In plain language, GAE represents the transfer of co-ownerships
of one set of assets in one ledger in exchange for the transfer of
co-ownerships of another set of assets in the other ledger, atom-
ically. The standard atomic swap assumption of common parties
across ledgers is represented by P. Initial co-ownership of assets
are represented by the definitions of IO1 and IO2 where each as-
set maps to a non-empty subset of P. The definitions of FO1 and
FO2 indicate that (i) the final co-owners of each asset being trans-
ferred are drawn from the full set of parties regardless of their
initial ownership statuses, (ii) assets are not expunged from the
ledger, and (iii) an asset’s final co-ownership is different from its
initial co-ownership. The function mappings remain unchanged
for assets outside the swap lists AE1 and AE2. The range for each
co-ownership function is the power set of P, excluding the null
set, indicating that each asset can have one or more co-owners
drawn from P. The null set is excluded because we wish to avoid
handling assets in GAE that are created from scratch or destroyed
in the course of a cross-ledger exchange. We limit our scenarios to
assets exchanging hands because the incentive and trust models
we consider in this paper only apply to those scenarios.

The example in Figure 6 illustrates this definition and the tuple
elements. From the definition, we can define partitions of the co-
owners in order to reason about the exhaustiveness of the definition
and the threat models they present, as follows for 𝑖 ∈ [2]:
• G𝑖 is the asset co-ownership giver function in L𝑖 , defined as

G𝑖 : AE𝑖 → 2P − {∅}, where G𝑖 (𝑎) = IO𝑖 (𝑎) − FO𝑖 (𝑎)

• K𝑖 is the asset co-ownership keeper (sharer) function in L𝑖 , de-
fined as K𝑖 : AE𝑖 → 2P − {∅}, where K𝑖 (𝑎) = IO𝑖 (𝑎) ∩ FO𝑖 (𝑎)
• T𝑖 is the asset co-ownership taker function in L𝑖 , defined as

K𝑖 : AE𝑖 → 2P − {∅}, where K𝑖 (𝑎) = FO𝑖 (𝑎) − IO𝑖 (𝑎)

(Note: as we mentioned earlier, the null set is excluded from the
giver, keeper, and taker function ranges because we do not consider
unattached assets that are created or destroyed in a GAE instance.)
As should be clear from these definitions, ∀𝑎 ∈ AE1, we have
that G1 (𝑎)∪K1 (𝑎)∪T1 (𝑎) = IO1 (𝑎)∪FO1 (𝑎) and ∀𝑎 ∈ AE2, G2 (𝑎)∪
K2 (𝑎) ∪ T2 (𝑎) = IO2 (𝑎) ∪ FO2 (𝑎).

Let us express cross-network transactions in GAE parlance,
starting with the basic types discussed in Section 2.2. Table 1 shows
the givers, keepers, and takers, of the transactions illustrated in
Figure 5, each transaction involving the exchange of assets 𝑀 and
𝑁 . We can spot a few conditionals from these tables:

ULT

CLR

CLS

L1
L2

Ledger Asset:Transfer
𝑀 : {𝑋 } → {𝑌 }
𝑁 : {𝑍 } → {𝑊 }
𝑀 : {𝑋 } → {𝑌 }
𝑁 : {𝑍 } → {𝑋 }
𝑀 : {𝑋 } → {𝑌 }
𝑁 : {𝑌 } → {𝑋 }
Table 1: Co-Ownership Sets

G
T
K
{𝑋 } ∅ {𝑌 }
{𝑍 } ∅ {𝑊 }
{𝑋 } ∅ {𝑌 }
{𝑍 } ∅ {𝑋 }
{𝑋 } ∅ {𝑌 }
{𝑌 } ∅ {𝑋 }

L1
L2

L1
L2

Ledger

L1

L2

Asset:Transfer
G
𝐶𝑢𝑟𝑟𝑒𝑛𝑐𝑦 : {𝑋, 𝑌 } → {𝑊 , 𝑌, 𝑍 }
{𝑋 }
𝑆𝑒𝑐𝑢𝑟𝑖𝑡𝑦 : {𝑇 , 𝑈 } → {𝑉 }
{𝑇 , 𝑈 }
𝐷𝑖𝑎𝑚𝑜𝑛𝑑 : {𝑍 } → {𝑉 }
{𝑍 }
𝐶𝑎𝑟 : {𝑇 } → {𝑇 , 𝑈 ,𝑊 }
∅
𝐻𝑜𝑢𝑠𝑒 : {𝑍 } → {𝑇 , 𝑋, 𝑌 }
{𝑍 }
Table 2: CLS Co-Ownership Sets

K
{𝑌 }
∅
∅
{𝑇 }
∅

T
{𝑊 , 𝑍 }
{𝑉 }
{𝑉 }
{𝑈 ,𝑊 }
{𝑇 , 𝑋, 𝑌 }

• In the CLR, (G1 (𝑀) ∪ K1 (𝑀)) ∩ T2 (𝑁 ) ≠ ∅ and (G2 (𝑁 ) ∪

• In the CLS, (G1 (𝑀) ∪ K1 (𝑀)) ∩ T2 (𝑁 ) ≠ ∅ and (G2 (𝑁 ) ∪

K2 (𝑁 )) ∩ T1 (𝑀) = ∅

K2 (𝑁 )) ∩ T1 (𝑀) ≠ ∅

We can therefore distinguish ULTs, CLRs, and CLSs using these
conditionals. Table 2 shows the co-ownership sets corresponding
to the complex transaction of Figure 6. The above conditionals hold
for the CLS transaction (𝐶𝑢𝑟𝑟𝑒𝑛𝑐𝑦 for 𝐻𝑜𝑢𝑠𝑒), the CLR transaction
(𝑆𝑒𝑐𝑢𝑟𝑖𝑡𝑦 for 𝐶𝑎𝑟 ), and the ULT transaction (𝐷𝑖𝑎𝑚𝑜𝑛𝑑) are decon-
structed earlier. If we merge all transactions in the two ledgers
respectively and take the unions of the G, K, and T sets, we end up
with the conditional above that corresponds to a CLS.

Now, with multiple assets and co-owners, consider the following

sets of parties:

(cid:216)

S12 = (cid:169)
(cid:173)
𝑎 ∈A E1
(cid:171)

G1 (𝑎) ∪

(cid:216)

𝑎 ∈A E1

K1 (𝑎)(cid:170)
(cid:174)
(cid:172)

(cid:216)

T2 (𝑎)

𝑎 ∈A E2

(cid:216)

T1 (𝑎)

∩

∩

(cid:216)

S21 = (cid:169)
(cid:173)
𝑎 ∈A E2
(cid:171)

G2 (𝑎) ∪

(cid:216)

K2 (𝑎)(cid:170)
(cid:174)
(cid:172)

𝑎 ∈A E1

𝑎 ∈A E2
We can thus extrapolate the conditionals to complex transactions
with multiple assets and co-owners. GAE is a combination of
• only gULTs if both S12 and S21 are empty.
• only gCLRs and gULTs if only one of S12 and S21 are empty.
• all gCLSs, gCLRs and gULTs if neither of S12 and S21 is empty.
In plain language, if no giver or keeper gets anything in return
for a transfer in another ledger, then the transactions are local and
unconnected. If only a single group of co-owners get recompensed,
the transactions will only involve cross-ledger replacements. And if
there are two sets of co-owners get recompensed by each other, the
transactions must involve cross-ledger swaps. Using the above test,
we can verify that the examples in Figures 3 and 4 map to gCLSs
and that the complex transaction in Figure 6 contains gCLSs.

• In the ULT pair, (G1 (𝑀) ∪ K1 (𝑀)) ∩ T2 (𝑁 ) = ∅ and (G2 (𝑁 ) ∪

K2 (𝑁 )) ∩ T1 (𝑀) = ∅

GAE therefore exhaustively covers all basic and complex trans-
action types as we have defined them. It also covers all possible

Atomic cross-chain exchanges of shared assets

AFT ’22, September 19–21, 2022, Cambridge, MA

Figure 6: Generalized 2-Ledger Asset Exchange Example

cross-ledger exchanges in which atomicity is required. The above
conditionals also tell us how to determine the combinations of basic
transaction types within a GAE instance.

(2) for all 𝑎1 ∈ AE1,𝑃 , the owners of 𝑎1 at the end of the protocol
are according to IO1 (𝑎1) and for all 𝑎2 ∈ AE2,𝑃 , the owners of
𝑎2 at the end of the protocol are according to IO2 (𝑎2).

2.5 Threat model and Properties
Threat model: Let us identify the factors that pose threats to the
integrity of a GAE instance. We assume that all participants in P
are rational, and that they can arbitrarily deviate from a specified
exchange protocol, collude with other participants, and attempt
to maximize the value that they gain through the protocol. We
also assume collective integrity of a network maintaining a shared
ledger, i.e., rogue miners or block creators cannot override honest
network members to finalize fraudulent or spam transactions.
Properties: We desire the atomicity property from a protocol that
accomplishes GAE. Atomicity ensures for each party that follows
the protocol that the assets it co-owns or would co-own either all
move to the desired final state or all remain in the original state,
even if other parties deviate from the protocol.

Definition 2.2 (Atomicity in GAE). For every participant 𝑃 ∈ P,
let AE1,𝑃 = {𝑎|𝑃 ∈ (IO1 (𝑎) ∪ FO1 (𝑎))} and let AE2,𝑃 = {𝑎|𝑃 ∈
(IO2 (𝑎) ∪ FO2 (𝑎))}. A protocol for GAE is atomic if exactly one
of the following holds:
(1) for all 𝑎1 ∈ AE1,𝑃 , the owners of 𝑎1 at the end of the protocol
are according to FO1 (𝑎1) and for all 𝑎2 ∈ AE2,𝑃 , the owners
of 𝑎2 at the end of the protocol are according to FO2 (𝑎2).

2.6 HTLC limitations
Let us categorize GAE instances from single-asset-per-ledger and
single-co-owner-per-asset to multiples of these, and separately
analyze the threats they face. In the basic CLR and CLS cases, and
also in a case where a party keeps its co-ownership rather than
gives it to another (see below), the conventional HTLC as described
in Section 1 can be used without it being susceptible to attack.
• L1 : 𝑀 : {𝑋 } → {𝑋, 𝑌 }
• L2 : 𝑁 : {𝑌 } → {𝑋 }

Now we will analyze all the permutations of GAE involving
multiple co-owners and multiple assets in each ledger in below
cases. Because HTLC is known to enforce atomicity for singly-
owned assets, we will try to apply it to these scenarios to determine
whether it satisfies the properties listed earlier.
(1) Multiple co-owners locking a single asset in one ledger and claim-
ing a single asset in another ledger: This is the scenario in Figure 3
and which we can represent as follows:
• L1 : 𝑀 : {𝑋,𝑊 } → {𝑌 }
• L2 : 𝑁 : {𝑌 } → {𝑋,𝑊 }
Conventional HTLC can be applied in two different ways: (i) 𝑋
and 𝑊 agree offline on a secret; either of them locks 𝑀 with its

AFT ’22, September 19–21, 2022, Cambridge, MA

Krishnasuri Narayanam, Venkatraman Ramakrishna, Dhinakaran Vinayagamurthy, and Sandeep Nishad

hash and signatures (i.e., consents) of both 𝑋 and 𝑊 , following
which 𝑌 locks 𝑁 with the same hash; either 𝑋 or 𝑊 claims 𝑁
(on behalf of both parties), and then 𝑌 claims 𝑀 (illustrated in
Figure 9 in Appendix D), (ii) 𝑋 and 𝑊 independently lock 𝑀 in
either sequence using two different secrets (the contract deems
𝑀 to be locked only when both 𝑋 and 𝑊 have submitted their
respective transactions), following which 𝑌 locks 𝑁 with both
the hashes; 𝑋 and 𝑊 submit claims to 𝑁 (by revealing their
respective secrets in any order), following which 𝑌 claims 𝑀
using both the revealed secrets (Figure 11 in Appendix D).
Threats/Attacks: Both approaches are vulnerable to collusion
between 𝑌 and one of 𝑋 and 𝑊 to cheat the other: (i) after 𝑀 is
locked, either of its co-owners (let’s say 𝑊 ) may strike a deal
with 𝑌 to give 𝑀 away (using the same hash lock) and 𝑌 in
turn will lock 𝑁 only for that party (in this case, 𝑊 ) rather than
jointly to 𝑋 and 𝑊 ; 𝑊 may also provide some other incentive
to 𝑌 to encourage it to collude against 𝑋 ; since 𝑋 has already
locked away its co-ownership of 𝑀 using a secret that 𝑊 also
possesses, it is left at a disadvantage (illustrated in Figure 10 in
Appendix D) (ii) if 𝑋 submits its claim in L2 first by revealing its
secret, 𝑊 may avoid revealing its secret and submitting a claim,
following which 𝑌 may allow its earlier lock to lapse and instead
lock 𝑁 again only in favor of 𝑊 ; having revealed its secret, 𝑋 is
now at a disadvantage as 𝑌 can claim its share of 𝑀 but 𝑊 now
will get all of 𝑁 instead of having to co-own it with 𝑋 (illustrated
in Figure 12 in Appendix D). In this protocol, the party that
acts first (i.e., submits a claim) stands at a disadvantage as its
co-owner may collude with its counterparty(ies) to rob it of its
rightful share of an asset.
Incidentally, if 𝑌 locks 𝑁 first, these attacks will not be possible,
but if 𝑌 is replaced with multiple co-owners, then these threats
will still apply regardless of the lock sequence.

(2) Co-owners locking multiple assets in one ledger and claiming a
single asset in another ledger: This is the scenario in Figure 4:
• L1 : 𝑀 : {𝑋 } → {𝑌 }
• L1 : 𝑅 : {𝑊 } → {𝑌 }
• L2 : 𝑁 : {𝑌 } → {𝑋,𝑊 }
Conventional HTLC can be applied in the same two ways as in
case (1) and suffers from the same collusion possibilities. The
only difference is that 𝑌 gains two assets instead of one if it
colludes with either 𝑋 or 𝑊 . If 𝑌 were to lock 𝑁 first, it could
simply lock in favor of either 𝑋 or 𝑊 (whoever the colluding
party is). This procedure does not present any interesting fea-
tures, because 𝑌 has the power of unilateral action regardless
of how the other parties behave. The same threat possibilities
apply if 𝑌 is replaced with multiple co-owners.

(3) Multiple co-owners locking a single asset in one ledger and claim-

ing multiple assets in another ledger:
• L1 : 𝑀 : {𝑋,𝑊 } → {𝑌 }
• L2 : 𝑅 : {𝑌 } → {𝑋 }
• L2 : 𝑁 : {𝑌 } → {𝑊 }
If conventional HTLC is applied with 𝑀 being locked first, it
will suffer from the same threats as in cases (1) and (2). But if 𝑌
were to lock both 𝑅 and 𝑁 in L2 first, then conventional HTLC
will work without posing any new threats.

If 𝑌 is replaced with multiple co-owners, say {𝑌, 𝑍 }, the attacks
described in case (1) will be possible (either 𝑌 or 𝑍 colluding
with 𝑋 and 𝑊 ).

(4) Co-owners locking multiple assets in one ledger and claiming

multiple assets in another ledger:
• L1 : 𝑀 : {𝑋 } → {𝑌 }
• L1 : 𝑅 : {𝑊 } → {𝑌 }
• L2 : 𝑁 : {𝑌 } → {𝑋 }
• L2 : 𝑃 : {𝑌 } → {𝑊 }
If conventional HTLC is applied with 𝑀 and 𝑅 being locked
first as in case (2), it will face the same threats. If 𝑌 were to lock
𝑁 and 𝑃 first, it could simply lock one of those assets in favor
of either 𝑋 or 𝑊 (whoever the colluding party is). On the other
hand, if 𝑌 locked both its assets first and then waited for both
𝑋 and 𝑊 to lock theirs, then HTLC will fulfil the exchange. But
if 𝑌 were replaced with multiple co-owners, the same threat
possibilities apply as in case (1).

By induction, the above breakup of cases and the threats identified
can be extrapolated to a generic GAE instance. The threat faced by
conventional HTLC when applied to GAE is that there is no mech-
anism to enforce a joint lock and claim over more than one asset by
more than one co-owner. We must therefore (i) ensure that parties
can jointly lock one or more assets without revealing the secret to
any of them in clear, and (ii) ensure that parties jointly locking one
or more assets for transfer in one ledger cannot unilaterally make
claims in the other ledger. We will address these challenges by cre-
ating primitives for these operations and providing an augmented
HTLC protocol in the next section.

3 SOLUTION: MULTI-PARTY HASH TIME

LOCKED CONTRACT (MPHTLC)

We present an augmented form of HTLC, called MPHTLC, to solve
GAE.The basic capabilities required of a ledger (or a smart con-
tract system over it) is that it supports hash and time locks on
assets. Therefore, any ledger that is capable of implementing con-
ventional HTLC [34] will also be able to implement MPHTLC. We
also make the practical assumption that both participating ledgers
have known (or predictable) upper and lower bounds for transac-
tion, or block, confirmation times. As a consequence, we can safely
assume that no adversary in our threat model can arbitrarily speed
up or slow down either of the ledgers. This ensures predictability
and a priori selection of asset time lock durations, preventing the
counterparties from racing each other or denying each other ade-
quate time to mount their claims. In addition, we will utilize secure
multi-party computation (MPC) protocols [17, 25, 47], to enforce
the ability to jointly lock and claim assets, which we identified as a
key requirement to handle the threats.

3.1 MPHTLC protocol
In a GAE instance, let us define O1 as the set of initial co-owners
of assets AE1 in L1 (givers and keepers, as defined in Section 2) as

(cid:216)

O1 =

𝑎 ∈A E1

(cid:216)

IO1 (𝑎) = (cid:169)
(cid:173)
𝑎 ∈A E1
(cid:171)

G1 (𝑎) ∪

(cid:216)

𝑎 ∈A E1

K1 (𝑎)(cid:170)
(cid:174)
(cid:172)

Let the cardinality of O1, or |O1|, be 𝑛. Here are the protocol steps:

Atomic cross-chain exchanges of shared assets

AFT ’22, September 19–21, 2022, Cambridge, MA

(1) Let 𝑥1, 𝑥2, . . . , 𝑥𝑛 be the secrets chosen by the 𝑛 parties of O1
respectively in L1. They compute a hash 𝐻 = 𝐹1 (𝑥1, 𝑥2, . . . , 𝑥𝑛)
where 𝐹1 is an MPC protocol (see Section 3.2) among the 𝑛
parties. Note: no information about the secrets 𝑥1, 𝑥2, . . . , 𝑥𝑛 is
revealed during the computation other than the output 𝐻 itself.
(2) Each asset 𝑎 ∈ AE1 is locked by one of its initial co-owners (𝑜 ∈
IO1 (𝑎)) using hash 𝐻 in L1 with expiration duration 𝑇 in favor
of the parties in FO1 (𝑎). All initial co-owners of 𝑎 in IO1 (𝑎) are
required to sign the lock transaction before it is submitted to
the chain. It is up to the ledger/contract to determine if each
asset is to be locked using a separate transaction or if all assets
are to be locked together in a single transaction. The contract(s)
validate the signatures from all the co-owners of each asset and
if valid, locks the assets pending either the supply of the secret
pre-image corresponding to 𝐻 or the passing of 𝑇 time units.
(3) Each asset 𝑎 ∈ AE2 is locked by one of its initial co-owners
(𝑜 ∈ IO2 (𝑎)) after verifying that all the locks in Step (2) have
been committed in favor of the expected final owners with
appropriate time locks in L1. The locks in L2 are created using
same hash 𝐻 from L1 with an expiration duration 𝑇 /2 in favor
of the parties in FO2 (𝑎), pending either the supply of the secret
pre-image corresponding to 𝐻 or the passing of 𝑇 /2 time units.
All initial co-owners of 𝑎 in IO2 (𝑎) are required to sign the lock
transaction before it is submitted to the chain. Note that hash 𝐻
can be obtained from L1, because IO2 (𝑎) ⊆ P and all members
of P have read access to both ledgers.

(4) The 𝑛 parties of O1 in L1 first verify that all the locks in Steps
(2) and (3) have been committed in favor of the expected fi-
nal owners with appropriate time locks in L1 and L2 respec-
tively. If these checks are successful, the 𝑛 parties compute
𝑥 = 𝐹2 (𝑥1, 𝑥2, . . . , 𝑥𝑛) such that 𝐻𝑎𝑠ℎ(𝑥) = 𝐻 , using their re-
spective secrets chosen in Step 1 as inputs. Here, 𝐹2 is an MPC
protocol (described in Section 3.2) between the 𝑛 parties.
(5) Every asset 𝑎 ∈ AE2 can now be claimed by its final owners
FO2 (𝑎) in L2 if the secret 𝑥 is revealed before time duration
𝑇 /2 elapses. If the transfer of 𝑎 is part of a gCLS or a gCLR,
i.e., if the intersection of O1 and FO2 (𝑎) is not ∅, there will be
at least one party with an incentive to reveal the secret. If the
intersection is ∅, then the transfer of 𝑎 is a gULT with respect to
the transfers in L1; as described in Section 2.2, this will require
an off-chain sharing of the secret among parties if and only
if this gULT must be conducted atomically with transfers in
L1. All assets in AE2 get transferred to the final co-owners
as defined by the FO2 function once any party reveals 𝑥 in L2
within 𝑇 /2. At this stage, the revelation of the secret benefits
all claiming parties equally, and gives no advantage to a subset.
If nobody supplies 𝑥 in L2 within 𝑇 /2, the co-owners remain
as defined by IO2. All transfers occur or no transfer occurs,
thereby satisfying the cross-ledger atomicity property. Lastly,
depending on how the assets were locked, the claim should be
submitted via a single transaction for all locked assets or using
one transaction per locked asset.

(6) Every asset 𝑎 ∈ AE1 can now be claimed by its final owners
FO1 (𝑎) in L1 by supplying the secret 𝑥 within duration 𝑇 . 𝑥
is already public in L2 and therefore known to every party in
P. Every asset in AE1 gets transferred to its final co-owners
as defined by FO1 once any party reveals 𝑥 in L1 within 𝑇 . If

nobody supplies 𝑥 in L1 (which would be irrational on their
part), then the co-owners remain as defined by IO1.

Timing Considerations: If each asset has a separate lock and claim
transaction, there is a potential hazard that must be managed as fol-
lows. In Step 5, there may be an asset 𝑎 ∈ AE2 whose claimers don’t
overlap with O1, i.e., T2 (𝑎) ∪ O1 = ∅. These claimers are depen-
dent on some party in O1 revealing 𝑥. But if parties in O1 compute
MPC 𝐹2 to reveal 𝑥 close to the timeout 𝑇 /2, these non-overlapping
claimers may lose the chance to claim their assets. Therefore, the
time locks on such assets should have extra tolerance. And because
we can determine these assets a priori, by inspecting the GAE
tuple, the contracts can enforce this. A suggestive guideline would
be to use 𝑇 /4 as the timeout for every asset in L2 that has at least
one claimant belonging to O1, and 𝑇 /2 for the other assets in L2.
The timeout for every asset in L1 remains 𝑇 as 𝑥, once revealed in
L2, is immediately available for claiming in L1.

3.2 Selection of the MPC functions 𝐹1 and 𝐹2
The 𝑛 parties output 𝐻 = 𝐻𝑎𝑠ℎ (𝑔(𝑥1, 𝑥2, . . . , 𝑥𝑛)) by participat-
ing in an MPC protocol 𝐹1 with (𝑥1, 𝑥2, . . . , 𝑥𝑛) as their respective
inputs, where 𝑔 can be any function with the following properties:

(1) The output of 𝑔 contains sufficient entropy for input from each
party, such that inputs of any 𝑛 − 1 parties cannot be used to
guess the output with non-negligible probability.

(2) The output of function 𝑔 need not hide information about the
inputs 𝑥1, 𝑥2, . . . , 𝑥𝑛. This is what differentiates 𝑔 from, say, a
secret sharing protocol.

(3) The one-wayness of 𝐻 ought to be retained when hashing
𝑔(𝑥1, 𝑥2, . . . , 𝑥𝑛) instead of 𝑥1, 𝑥2, . . . , 𝑥𝑛. Note: the security of
HTLC assumes one-wayness of 𝐻 on randomly chosen inputs.
In our instantiation of MPHTLC, 𝑔 is an identity function which
outputs 𝑥1, 𝑥2, . . . , 𝑥𝑛, but any 𝑔 satisfying the above properties can
be used. Any maliciously secure MPC protocol with fairness can
be used for 𝐹1, where the malicious security protects against par-
ticipants arbitrarily deviating from the protocol and the fairness
property guarantees that either all the parties get the output or none
of them do. The fairness property ensures that the same output
hash is obtained by all the parties in O1 and is a valid hash accord-
ing to the inputs 𝑥1, 𝑥2, . . . , 𝑥𝑛. Note again that no information is
revealed about the secrets 𝑥1, 𝑥2, . . . , 𝑥𝑛 during the computation of
𝐻𝑎𝑠ℎ (𝑔(𝑥1, 𝑥2, . . . , 𝑥𝑛)) = 𝐻 , other than the final output 𝐻 . The
above mentioned properties of 𝑔 do not affect the confidentiality
provided by the MPC protocol.

The MPC protocol 𝐹2 among the 𝑛 parties of O1 in L1 (used
during the claim phase) involves computing 𝑥 = 𝑔(𝑥1, 𝑥2, . . . , 𝑥𝑛)
using their respective inputs 𝑥1, 𝑥2, . . . , 𝑥𝑛 chosen in Step 1. Note
that 𝐻𝑎𝑠ℎ(𝑥) = 𝐻 . We use an MPC protocol with fairness and hence
either all the parties in O1 obtain 𝑥 or none of them do.

A discussion on Fair MPC protocols. Fairness in MPC is exten-
sively studied in the cryptography literature, and there are different
possibilities of instantiating a fair MPC based on the requirements
of MPHTLC. It is possible to achieve fairness with just point-to-
point secure communication between each pair of individual parties
if less than one-third of the parties are malicious [10, 25], and with

AFT ’22, September 19–21, 2022, Cambridge, MA

Krishnasuri Narayanam, Venkatraman Ramakrishna, Dhinakaran Vinayagamurthy, and Sandeep Nishad

the use of a broadcast network to protect up to ⌈𝑛/2⌉ − 1 parties be-
ing malicious [25, 36]. If the goal is to protect against a majority of
the parties being malicious, it is proven that the standard definition
of fairness is impossible to achieve this without additional assump-
tions [19], and this impossibility holds even in the presence of a
trusted hardware without trusted clocks [35]. There are different
relaxed definitions of fairness proposed in the literature that protect
against a dishonest majority of parties [6, 13, 24, 26]. But if a use
of MPHTLC demands the standard definition of fairness against a
dishonest majority of parties, there are protocols that use public
blockchains, financial penalties and sometimes additionally trusted
hardware like Intel SGX (to make the protocol more efficient) to
enable this [7, 11, 18, 31, 35].

The fairness property is sufficient if all the assets are locked
in a single transaction. But in the variant that assets are locked
separately across multiple transactions, there is an additional hazard
that we need to address. Fairness ensures that either all the parties
get the output or none of them do, but it does not specify any time
bound on when the parties get the output if they do. There could
exist fair MPC protocols where one of the parties delays the output
“release” to whenever they want to. This is a concern when the
assets are individually locked since a party can delay the output
release to just before the timeout 𝑇 /2, and hence, due to network
delays, there will invariably be some parties at a disadvantage.
Though all the parties will get the output, some of them might
get it before the timelock expires and some might get it after. To
protect against this, we need a “timeliness” property in the fair
MPC protocol which ensures that, if the parties were to get the
output, there is a pre-specified time bound before which all of them
should get it, and after which none of them should. We note that it is
possible to augment the protocol in [18] based on secure hardware
with this property, additionally assuming the existence of a trusted
clock inside the trusted hardware [16, 49]. Informally, in [18], there
is a release token posted on a bulletin board (instantiated using
a public blockchain) to initiate the release of the MPC output. A
proof of posting this token is then verified by a program installed
and attested in the secure hardware before it returns the MPC
output. Now, this program additionally needs to check whether the
release token is posted on the bulletin board before a certain time
bound. We defer a detailed discussion on fair MPC protocols with
the timeliness property to future work.

3.3 Instantiations
We now instantiate the MPHTLC protocol for a couple of scenarios,
that also provides an intuition on how MPHTLC avoids the attacks
identified as possible with conventional HTLC in Section 2.5. Across
all the cases, we discovered that collusion attacks are possible when

• multiple co-owners must lock an asset first before making a joint
claim for an asset in another ledger, as described in case (1) in
Section 2.5 (also see Figure 3)

• co-owners of different assets must lock their respective assets
first before making a joint claim for an asset in another ledger,
as described in case (2) in Section 2.5 (also see Figure 4)

MPHTLC applied to case (1) goes as follows (also see Figure 7).

(1) Let 𝑠1 and 𝑠2 be the secrets chosen by 𝑋 and 𝑊 respectively.
They compute a hash 𝐻 = 𝐹1 (𝑠1, 𝑠2) where 𝐹1 is a MPC protocol
instance agreed by both of them.

(2) Party 𝑋 locks the asset 𝑀 using 𝐻 in L1 till time 𝑇 with the

signature of the party 𝑊 for party 𝑌 , or vice versa.

(3) Party 𝑌 locks the asset 𝑁 using 𝐻 in L2 till time 𝑇 /2 for both

the parties 𝑋 and 𝑊 .

(4) Parties 𝑋 and 𝑊 in L1 compute 𝑠 = 𝐹2 (𝑠1, 𝑠2) using their re-
spective secrets chosen in Step 1 above where 𝐹2 is a another
MPC protocol instance chosen by them such that 𝐻𝑎𝑠ℎ(𝑠) = 𝐻 .
(5) Party 𝑋 (or 𝑊 ) submits a claim on asset 𝑁 in L2 by revealing

the secret 𝑠 before time 𝑇 /2 elapses.

(6) Party 𝑌 submits a claim on asset 𝑀 in L1 by using the secret 𝑠

(obtained from ledger L2) before time 𝑇 elapses.

This protocol avoids the two hazards identified in Section 2.5, at
lock time and at claim time, as follows:
• Neither 𝑋 nor 𝑊 knows the secret at the end of Step 2, and hence
neither can collude with 𝑌 to get the latter to lock 𝑁 only in favor
of one of them. If 𝑌 chooses not to execute Step 3, the protocol
will end with no change in either ledger’s state.

• There is exactly one secret, which is only revealed in Step 4, so
𝑋 nor 𝑊 will be left at a disadvantage. If either of them reveals 𝑠
in that step, both will collectively co-own 𝑁 . If neither reveals 𝑠,
the protocol will end with no change in either ledger’s state.
MPHTLC applied to case (2) goes as follows (also see Figure 13

in Appendix E).
(1) Let 𝑠1 and 𝑠2 be the secrets chosen by 𝑋 and 𝑊 respectively.
They compute a hash 𝐻 = 𝐹1 (𝑠1, 𝑠2) where 𝐹1 is an MPC proto-
col instance agreed by both of them.

(2) Party 𝑋 locks asset 𝑀 using 𝐻 in L1 for time 𝑇 for party 𝑌 .
Similarly, 𝑊 locks asset 𝑅 using 𝐻 in L1 for time 𝑇 for 𝑌 .
(3) Party 𝑌 locks asset 𝑁 using 𝐻 in L2 for time 𝑇 /2 for both the

parties 𝑋 and 𝑊 .

(4) Parties 𝑋 and 𝑊 in L1 compute 𝑠 = 𝐹2 (𝑠1, 𝑠2) using their re-
spective secrets chosen in Step 1 above where 𝐹2 is an another
MPC protocol instance chosen by them such that 𝐻𝑎𝑠ℎ(𝑠) = 𝐻 .
(5) Party 𝑋 (or 𝑊 ) submits a claim on asset 𝑁 in L2 by revealing

the secret 𝑠 before time 𝑇 /2 elapses.

(6) Party 𝑌 submits a claim on assets 𝑀 and 𝑋 in L1 by using the
secret 𝑠 (obtained from ledger L2) before time 𝑇 elapses.
This protocol avoids the same two hazards in the same ways as
discussed for the previous use case.

4 ANALYSIS
We now prove the atomicity property of our MPHTLC protocol in
our threat model that all parties are rational and the adversarial
parties can arbitrarily deviate from the protocol.

We state some basic assumptions before we prove atomicity:
• At least one party in O1 has incentive to claim a locked asset in

L2.

• For each asset locked in L1, there exists at least one party in P

that has an incentive to claim it.

• The time lock duration can be determined by the parties based
on the environmental considerations to ensure that the claimers
are left with sufficient time.

Atomic cross-chain exchanges of shared assets

AFT ’22, September 19–21, 2022, Cambridge, MA

Figure 7: Multi-Party Hash Time Locked Contract (MPHTLC) Protocol

• The completion time of the fair MPC protocol is predictable.

Claim 1. MPHTLC is atomic according to Definition 2.2.

Proof. We will start by arguing atomicity for the variant of
MPHTLC where there is a single transaction in L1 (respectively
L2) which locks all the assets in AE1 (respectively AE2). The
honest parties (that follow the protocol) in O1 proceed with the
MPC 𝐹2 only if the contracts are appropriate in L1 and L2, and if
they proceed, the fairness property of the MPC protocol ensures
that all or none of the parties in O1 obtain the pre-image. If none
of them obtain the pre-image, then all assets in AE2 and later the
ones in AE1 revert to their initial owners. And if all the parties
obtain the pre-image, since at least one of them has the incentive to
do the claim in L2, the assets in AE2 would go to the final owners
according to FO2. And on seeing the pre-image used, a party that
has an incentive to claim a locked asset in L1 (we assumed there
exists at least one) does so. The protocol allows sufficient time for
this party to succeed with the claim in L1, and hence the assets in
AE1 would also go their final owners as prescribed by FO1.

In the variant where each asset is locked and claimed via separate
transactions, the extra time available for parties not in O1 facilitates
their asset claims even if no party in O1 submits a claim in L2 until
very close to their timeout. The rest of the argument follows, with
the help of our assumption that there exists at least one party in P
□
to have the incentive to claim each locked asset in L1.

Claim 2. MPHTLC results in a Nash equilibrium for parties en-

gaged in a set of asset swaps (gCLSs).

We provide an informal proof of this claim using a high-level
game-theoretic argument, based on a proof in Belotti et al. [9] that
conventional HTLC results in Nash equilibrium. We limit GAE
scenarios under consideration to those involving only gCLSs (i.e.,
all parties are involved in a set of swaps across 2 ledgers, like the
scenarios in Figures 3 and 4). We argue that if none of the target co-
owners of an asset 𝑎 (i.e., FO2 (𝑎)) bother to claim it in Step 5 (after
completing Step 4 and revealing the secret), then it is guaranteed
that at least one or more of these co-owners always get cheated

by one or more other co-owners, who can collude with current
co-owners of 𝑎 (i.e., IO2 (𝑎)) in L2. (This is the hazard we identified
in Section 2.6 and avoided in MPHTLC.)

We informally prove our argument with reference to the gCLS
illustrated in Figure 3, where multiple co-owners of a single asset in
one ledger are attempting to swap another single asset in the other
ledger with a single owner. Let us follow the MPHTLC protocol
applied to this scenario (see Section 3.3). Let’s assume the protocol
has proceeded as expected until the end of Step 4. Now, if neither 𝑋
nor 𝑊 bothers to claim 𝑁 in L2 before time 𝑇 /2 elapses, 𝑌 ’s lock
expires. Now, one of the co-owners of 𝑀 (say 𝑊 ) can collude with
𝑌 to obtain 𝑁 all for itself (excluding 𝑋 ) via a hash lock using the
same 𝐻 . Then it proceeds to reveal secret 𝑠, and claims 𝑁 . 𝑌 in turn
can claim 𝑀 in L1 using 𝑠 before 𝑇 elapses.

But note that this fraud on the part of 𝑊 requires it to race 𝑋
to collude with 𝑌 , and there is no guarantee that it will win. The
loser of this race stands to lose all of 𝑁 instead of a co-ownership
of 𝑁 , which it was guaranteed to get had it followed protocol (i.e.,
Step 5). Therefore, it is in the interest of both 𝑊 and 𝑋 to reveal
the secret in Step 4 rather than let 𝑇 /2 elapse without claiming
𝑁 . As we assumed that all parties in a GAE are rational, none of
them would pick the alternate strategy described above. Speaking
generally, at least one member of O1 is guaranteed to reveal the
secret within 𝑇 /2. Hence, following the MPHTLC protocol results
in the best outcome for the parties involved (an equilibrium), and
there is no incentive for parties to deviate from it.

5 IMPLEMENTATION
Any DLT that can support HTLC can also support MPHTLC through
simple changes in the core logic of the locking and claiming mod-
ules (DLT’s smart contract). For a DLT to support MPHTLC (or
plain HTLC), it needs to support the locking (or freezing) of state
for a finite time period (a time lock).

A typical DLT application model has 2 layers: the Contracts
layer has business logic in contracts which run on peers and update
state through consensus, whereas the Applications layer consists
of client applications which invoke transactions on contracts. Any

AFT ’22, September 19–21, 2022, Cambridge, MA

Krishnasuri Narayanam, Venkatraman Ramakrishna, Dhinakaran Vinayagamurthy, and Sandeep Nishad

asset exchange protocol (HTLC or MPHTLC) requires implemen-
tation in both layers to protect asset integrity against Byzantine
failures; just an Applications layer implementation without decen-
tralized trust (consensus) guarantees cannot protect asset integrity.
Core MPHTLC capabilities of locking, claiming, and signature veri-
fications can be built as smart contracts while client layer apps can
submit lock and claim transaction requests to these contracts.

We will show how an existing atomic swap capability built on
HTLC can be augmented to support MPHTLC between permis-
sioned DLTs like Hyperledger Fabric and Corda. From several inter-
operation framework candidates (Polkadot [44], Cosmos [32], Cac-
tus [33] and Weaver [3]), we picked Hyperledger Labs Weaver [3],
which supports HTLC and does not require changes to Fabric or
Corda. (Note: our protocol can be implemented on a permissionless
network too, as long as the network supports conventional HTLC.)

Figure 8: Fabric Network and Decentralized App Architec-
ture

For Fabric, Weaver supports HTLC through: (i) a special chain-
code (contract) called the Interop Chaincode that contains hash-time
locks, and asset claim operations, and (ii) client library (API/SDK) to
trigger lock and claim transactions from the Applications layer (see
Figure 8). Time locks are enforced in contract logic by comparing
the timestamp presented in a claim transaction to a peer’s local
time; the assumption is that peers’ local times are approximately in
sync and therefore a consensus on expiration can be reached. Any
asset management application’s chaincode needs to be modified
only to trigger locks and claims by invoking the Interop Chain-
code. The client application can then submit asset lock and claim
instructions to its chaincode using the Weaver API and libraries,
and expose hashes and secrets after revelation via API functions.
We implemented our protocol by creating a fork1 of open source
Weaver repository. To support MPHTLC in Fabric, we implemented
the capabilities described in Section 3.1 directly in the Weaver
Interop Chaincode and client SDK. Application developers will need
to change very little (just additional API calls in both layers) apart
from enforcing the properties of asset co-ownerships.

In Corda, CorDapps deployed on network nodes scope business
logic in the Contracts layer and flows (in the Applications layer)
(see Figure 15 in Appendix G). To support HTLC, Weaver offers a

1github.com/mphtlc/weaver-dlt-interoperability

special Interop CorDapp that contains features similar to those de-
scribed earlier for Fabric (locks, claims, and time lock enforcement).
Any CorDapp that manages assets must, as in the Fabric case, be
augmented to exercise the Interop CorDapp (contract features and
client libraries). To support MPHTLC in Corda using Weaver, we
modified the Interop CorDapp to create a flow so that multiple co-
owners (instead of a single one) in a GAE instance sign the lock
transactions (Steps 2 and 3 in Section 3.1), while multiple co-owners
(instead of a single one) sign the claims (Steps 5 and 6 in Section 3.1).
As an aside, multiple co-owners can reclaim/unlock an asset if it is
unclaimed before timeout. A CorDapp developer need only insert
calls to these bulk lock/claim/unlock functions in his code. ( See
Appendices A and C for API details for both DLTs.)

Experimental Evaluation: We evaluated our Weaver implementa-
tion of GAE by creating a sample application for co-owned assets
in both Corda and Fabric. We ran our experiments on a Virtual Ma-
chine with 8-cores of Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHz,
16GB RAM, and 64-bit Ubuntu 18.04 as the OS. Table 3 reports the
latency for locking an asset, querying a locked asset state, claim,
and unlock. Latency is computed as the time taken by the respec-
tive API (SDK) calls to complete execution. 2nd (Fabric 2P) and 3rd
(Corda 2P) columns in Table 3 report latencies for asset exchange
operations for two parties co-owning one shared asset before and
after the asset exchange. We also observe that the time required
for the API execution is proportional to the number of parties in-
volved in each of these transactions (lock/claim/unlock) since we
need to collect the consent from all these parties. We expect the
time to run the MPC tasks 𝐹1 and 𝐹2 will be about a second and
a few milliseconds respectively (by extrapolating the results in
[17]). MPC overhead will increase the overall operational latency
of MPHTLC, but not by a significant amount. With increase in
number of participants, we expect that the runtime operation of
𝐹1 and 𝐹2 will increase, but only by a fraction of one second as
suggested by Choudhuri et al. [17].

Table 3: Latency for MPHTLC operations

Operation Fabric 2P (s) Corda 2P(s)
2.124
Locks
0.019
Queries
2.121
Claims
2.128
Unlocks

7.486
0.366
5.898
5.892

6 RELATED WORK
Atomic cross-chain swaps between a pair of mutually distrusting
parties without using trusted intermediaries a well-studied prob-
lem [34]. The model and solution have been extended to multiple
parties in multiple distinct ledgers [29, 30]. Efforts have been made
to add robustness to crash faults and address vulnerabilities in
HTLC-like solutions [42, 46, 48]. But all of these works assume
singly-owned assets and a single pair of assets across a bilateral
link; none of these works consider co-ownerships or multiple assets
on a ledger like we do. Therefore, none of the proposed solutions
can directly work for our setting, nor can the graph model in [29]
be directly extended to model our scenarios. However, the three

Atomic cross-chain exchanges of shared assets

AFT ’22, September 19–21, 2022, Cambridge, MA

attributes of a cross-chain atomic swap protocol defined by Herlihy
in [29] in terms of the guarantees that one such protocol offers
are also applicable to our proposed MPHTLC protocol. There also
exist several HTLC implementations ([23, 37, 40]), but none support
scenarios involving co-owned assets.

Some of these works address threats that are orthogonal to the
those we address. E.g., in [46], Xue and Herlihy handle sore loser
(or lockup griefing attacks [28]) in n-party swaps, where one party
decides to halt participation midway, leaving the other party’s
assets locked up for a long duration. Our contribution, distinct
from theirs, is to extrapolate the basic two-party HTLC model to
handle multiple assets and co-owners and provide a solution that
ensures atomicity and asset integrity. MPHTLC is susceptible to
sore loser attacks too, but Xue and Herlihy’s technique for singly-
owned assets (associating premiums to escrows and paying these
premiums to counterparties upon refunding) [46] will be equally
effective for MPHTLC. Analysis and implementation of MPHTLC
handling sore loser attacks is beyond the scope of this paper though.
As an aside, this also allows us to sidestep the question of external
market prices of assets impacting the exchange protocol.

In literature, we find other game-theoretic analyses of HTLC-
based cross-chain atomic swaps [9, 45] as well as DLT-agnostic and
cryptocurrency-agnostic techniques for universal atomic swaps us-
ing transaction signature verification [41]. But none of these works
analyze atomic swaps involving assets co-owned by a group of
mutually distrusting parties, as we do. Uniquely, our work prevents
co-owners of an asset swapping it for another asset without the
consent of all the co-owners of that asset.

7 CONCLUSION AND FUTURE WORK
Cross-chain atomic swaps and the HTLC protocol have been stud-
ied in recent years. In this paper, we have presented a general asset
exchange model (GAE) whereby assets can be co-owned and mul-
tiple assets can be simultaneously exchanged. We have shown that
HTLC cannot be applied directly to fulfil GAE exchanges because
of potential for collusion and fraud. We have presented a solution,
MPHTLC (Multi-Party Hash Time Locked Contract), for GAE, and
analyzed its correctness and atomicity properties. We have demon-
strated how the protocol can be easily implemented in the Weaver
interoperability framework. We intend to demonstrate the practical
worth of MPHTLC in DeFi scenarios by implementing our solution
contracts on a permissionless network like Ethereum. Lastly, our
conjecture is that MPHTLC can be extrapolated to multiple ledgers
(see Appendix F), and we will investigate this in future work.

REFERENCES
[1] 2019.

Introduction to Token SDK in Corda.

https://www.corda.net/blog/

introduction-to-token-sdk-in-corda/ Published on 16-Jul-2019.

Stathakopoulou, Marko Vukolic, Sharon Weed Cocco, and Jason Yellick. 2018.
Hyperledger fabric: a distributed operating system for permissioned blockchains.
In EuroSys. ACM, 30:1–30:15.

[6] N. Asokan, Victor Shoup, and Michael Waidner. 1998. Optimistic Fair Exchange

of Digital Signatures (Extended Abstract). In EUROCRYPT. 591–606.

[7] Carsten Baum, Bernardo David, and Rafael Dowsley. 2020. Insured MPC: Efficient

Secure Computation with Financial Penalties. In FC. 404–420.

[8] Rafael Belchior, André Vasconcelos, Sérgio Guerreiro, and Miguel Correia. 2022.
A Survey on Blockchain Interoperability: Past, Present, and Future Trends. ACM
Comput. Surv. 54, 8 (2022), 168:1–168:41. https://doi.org/10.1145/3471140
[9] Marianna Belotti, Stefano Moretti, Maria Potop-Butucaru, and Stefano Secci. 2020.

Game Theoretical Analysis of Cross-Chain Swaps. In (ICDCS).

[10] Michael Ben-Or, Shafi Goldwasser, and Avi Wigderson. 1988. Completeness The-
orems for Non-Cryptographic Fault-Tolerant Distributed Computation (Extended
Abstract). In STOC. 1–10.

[11] Iddo Bentov and Ranjit Kumaresan. 2014. How to Use Bitcoin to Design Fair

Protocols. In CRYPTO II. 421–439.

[12] Bitcoin. 2021. Bitcoin Script.

https://en.bitcoin.it/wiki/Script Accessed on

10-Dec-2021.

[13] Manuel Blum. 1983. How to Exchange (Secret) Keys. ACM Trans. Comput. Syst.

1, 2 (1983), 175–193.

[14] Wietze Bronkema. 2020. Multi Signatures.

https://medium.com/mycrypto/

introduction-to-multisig-contracts-33d5b25134b2 Published on 16-Jan-2020.

[15] Vitalik Buterin. 2015. Ethereum Whitepaper.

https://ethereum.org/en/

whitepaper/ Accessed on 10-Dec-2021.

[16] Shanwei Cen and Bo Zhang. 2017. Trusted Time and Monotonic Counters with
Intel Software Guard Extensions Platform Services. https://community.intel.com/
legacyfs/online/drupal_files/managed/1b/a2/Intel-SGX-Platform-Services.pdf.
[17] Arka Rai Choudhuri, Matthew Green, Abhishek Jain, Gabriel Kaptchuk, and Ian
Miers. 2017. Fairness in an Unfair World: Fair Multiparty Computation from
Public Bulletin Boards. In ACM CCS. 719–728.

[18] Arka Rai Choudhuri, Matthew Green, Abhishek Jain, Gabriel Kaptchuk, and Ian
Miers. 2017. Fairness in an Unfair World: Fair Multiparty Computation from
Public Bulletin Boards. In ACM CCS. 719–728.

[19] Richard Cleve. 1986. Limits on the Security of Coin Flips when Half the Processors

Are Faulty (Extended Abstract). In STOC. 364–369.

[20] Sid Coelho-Prabhu. 2020. A Beginner’s Guide to Decentralized Finance
(DeFi). https://blog.coinbase.com/a-beginners-guide-to-decentralized-finance-
defi-574c68ff43c4 Published on 7-Jan-2019.

[21] Ms Emily Dawson. 2016. ISO/TC 307: Blockchain and distributed ledger tech-

nologies. https://www.iso.org/committee/6266604.html

[22] Banque de France. 2021. Experiment on the use of Central Bank Digital Currency
(CBDC). https://www.banque-france.fr/en/communique-de-presse/experiment-
use-central-bank-digital-currency-cbdc.

[23] Decred. 2017. Decred-compatible cross-chain atomic swapping. https://github.

com/decred/atomicswap

[24] Juan A. Garay, Philip D. MacKenzie, Manoj Prabhakaran, and Ke Yang. 2006.
Resource Fairness and Composability of Cryptographic Protocols. In TCC. 404–
428.

[25] Oded Goldreich, Silvio Micali, and Avi Wigderson. 1987. How to Play any Mental
Game or A Completeness Theorem for Protocols with Honest Majority. In STOC.
218–229.

[26] Shafi Goldwasser and Yehuda Lindell. 2005. Secure Multi-Party Computation

without Agreement. J. Cryptol. 18, 3 (2005), 247–287.

[27] Thomas Hardjono, Martin Hargreaves, Ned Smith, and Venkatraman Ramakr-
ishna. 2021. Interoperability Architecture for DLT Gateways (Active Internet-
Draft). https://datatracker.ietf.org/doc/draft-hardjono-sat-architecture/
[28] Ethan Heilman, Sebastien Lipmann, and Sharon Goldberg. 2020. The Arwen
Trading Protocols (Full Version). Cryptology ePrint Archive, Paper 2020/024.
https://eprint.iacr.org/2020/024 https://eprint.iacr.org/2020/024.
[29] Maurice Herlihy. 2018. Atomic Cross-Chain Swaps. In (PODC).
[30] Maurice Herlihy, Liuba Shrira, and Barbara Liskov. 2019. Cross-chain Deals and

Adversarial Commerce. VLDB 13, 2 (2019), 100–113.

[31] Aggelos Kiayias, Hong-Sheng Zhou, and Vassilis Zikas. 2016. Fair and Robust
Multi-party Computation Using a Global Transaction Ledger. In EUROCRYPT II.
705–734.

[2] 2021. Hyperledger Fabric Token SDK. https://labs.hyperledger.org/labs/fabric-

[32] Jae Kwon and Ethan Buchman. 2016. Cosmos Whitepaper. https://whitepaper.

token-sdk.html Accessed on 15-Dec-2021.

[3] 2021. Weaver: DLT Interoperability (Hyperledger Labs). https://github.com/

hyperledger-labs/weaver-dlt-interoperability Accessed on 30-Aug-2022.
[4] Ermyas Abebe, Dushyant Behl, Chander Govindarajan, Yining Hu, Dileban
Karunamoorthy, Petr Novotný, Vinayaka Pandit, Venkatraman Ramakrishna,
and Christian Vecchiola. 2019. Enabling Enterprise Blockchain Interoperability
with Trusted Data Transfer (Industry Track). In Middleware. ACM, 29–35.
[5] Elli Androulaki, Artem Barger, Vita Bortnikov, Christian Cachin, Konstanti-
nos Christidis, Angelo De Caro, David Enyeart, Christopher Ferris, Gennady
Laventman, Yacov Manevich, Srinivasan Muralidharan, Chet Murthy, Binh
Nguyen, Manish Sethi, Gari Singh, Keith Smith, Alessandro Sorniotti, Chrysoula

io/document/582/cosmos-whitepaper Accessed on 15-Dec-2021.

[33] Hart Montgomery, Hugo Borne-Pons, Jonathan Hamilton, Mic Bowman, Peter
Somogyvari, Shingo Fujimoto, Takuma Takeuchi, Tracy Kuhrt, and Rafael Bel-
chior. 2020. Hyperledger Cactus Whitepaper. https://github.com/hyperledger/
cactus/blob/master/docs/whitepaper/whitepaper.md Accessed on 15-Dec-2021.
[34] Tier Nolan. 2013. Alt chains and atomic transfers. https://bitcointalk.org/index.

php?topic=193281.0 Accessed on 15-Dec-2021.

[35] Rafael Pass, Elaine Shi, and Florian Tramèr. 2017. Formal Abstractions for Attested

Execution Secure Processors. In EUROCRYPT I. 260–289.

[36] Tal Rabin and Michael Ben-Or. 1989. Verifiable Secret Sharing and Multiparty

Protocols with Honest Majority (Extended Abstract). In STOC. 73–85.

AFT ’22, September 19–21, 2022, Cambridge, MA

Krishnasuri Narayanam, Venkatraman Ramakrishna, Dhinakaran Vinayagamurthy, and Sandeep Nishad

[37] Daira Hopwood Sean Bowe. 2017. Hashed Time-Locked Contract transactions.

https://github.com/bitcoin/bips/blob/master/bip-0199.mediawiki

[38] Andrey Sergeenkov. 2021. A Beginner’s Guide to Atomic Swaps. https://www.
coindesk.com/tech/2021/08/20/a-beginners-guide-to-atomic-swaps/ Published
on 20-Aug-2021.

[39] Shobith Seth. 2022. Central Bank Digital Currency (CBDC).

https://www.
investopedia.com/terms/c/central-bank-digital-currency-cbdc.asp Accessed on
09-Mar-2022.

[40] SynthSwap. 2021. Cross asset swaps using Curve and Synthetix. https://github.

com/curvefi/curve-cross-asset-swaps

[41] Sri AravindaKrishnan Thyagarajan, Giulio Malavolta, and Pedro Moreno-Sánchez.
2021. Universal Atomic Swaps: Secure Exchange of Coins Across All Blockchains.
Cryptology ePrint Archive, Report 2021/1612.

[42] Amr El Abbadi Victor Zakhary, Divyakant Agrawal. 2019. Atomic Commitment

Across Blockchains. https://arxiv.org/abs/1905.02847

[43] Bitcoin Wiki. 2021. Multi Signatures. https://en.bitcoin.it/wiki/Multi-signature

Accessed on 10-Dec-2021.

[44] Gavin Wood. 2016.

Polkadot: Vision for a Heterogeneous Multi-Chain
https://github.com/w3f/polkadot-white-paper/raw/master/

Framework.
PolkaDotPaper.pdf Accessed on 15-Dec-2021.

[45] Jiahua Xu, Damien Ackerer, and Alevtina Dubovitskaya. 2021. A Game-Theoretic

Analysis of Cross-Chain Atomic Swaps with HTLCs. In (ICDCS).

[46] Yingjie Xue and Maurice Herlihy. 2021. Hedging Against Sore Loser Attacks in

Cross-Chain Transactions. In (PODC).

[47] Andrew Chi-Chih Yao. 1982. Protocols for Secure Computations (Extended

Abstract). In FOCS. 160–164.

[48] Victor Zakhary, Divy Agrawal, and Amr El Abbadi. 2020. Atomic Commitment

Across Blockchains. VLDB 13, 9 (2020), 1319–1331.

[49] Fan Zhang, Ethan Cecchetti, Kyle Croman, Ari Juels, and Elaine Shi. 2016. Town
Crier: An Authenticated Data Feed for Smart Contracts. In ACM CCS. 270–282.

A TESTING ASSET EXCHANGE WITH

CO-OWNERS

We demonstrate asset exchange of a bond in a Fabric network net-
work1 with tokens on Corda network Corda_Network, where both
the bond and tokens are shared/co-owned. (the github repository
fork containing the source code changes to the Weaver DLT interop-
erability framework will be includeded in the camera ready version
if this paper gets accepted)

Alice and Bob co-own a bond on network1 while PartyA and
PartyB co-own tokens in Corda_Network. Here Alice and Bob in
Fabric network1 correspond to PartyA (CORDA_PORT=10006) and
PartyB (CORDA_PORT=10009) in Corda_Network respectively. Al-
ice’s ownership of bond on Fabric network is transferred to Bob (i.e.,
Bob will be the sole owner of the bond) in exchange for a transfer
of Bob’s ownership of tokens on Corda network to Alice (i.e., Alice
will be the sole owner of the tokens).

Basic capabilities implemented in our modification of Weaver
are as follows for an MPHTLC instance (see the README in the
project repository for specific commands to run):
• Creation of a shared bond on Fabric network
• Creation of shared tokens on Corda network
• Exercising MPHTLC for asset exchange on shared assets

B EVALUATION OF APIS: MPHTLC VS. HTLC
We evaluate the overhead for MPHTLC over conventional HTLC, by
considering the transaction latencies for lock/query/claim/unlock
of an asset using HTLC APIs and using MPHTLC APIs with single
co-owner. We ran our experiments on a Virtual Machine with 8-
cores of Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHz, 16GB RAM,
and 64-bit Ubuntu 18.04 as the OS.

Table 4 reports the latency for locking an asset, querying a locked
asset state, claiming a locked asset, and unlocking a locked asset.
Latency is computed as the time taken by the respective API (SDK)

calls to complete execution. 2nd column (Corda 1P (MPHTLC)) in
Table 4 reports latencies for asset exchange operations with one
party co-owning a shared asset before asset exchange and another
one party co-owning the same shared asset after asset exchange.
And 3rd column (Corda (HTLC)) in Table 4 reports latencies for
asset exchange operations with a party owning a simple asset before
asset exchange and a different party owning the same simple asset
after asset exchange. We observe that the times required for the API
execution is almost the same for both MPHTLC APIs and HTLC
APIs (the asset being exchanged is owned by single owner).

Table 4: Transaction latencies: HTLC vs. MPHTLC

Operation Cora 1P (MPHTLC) Corda (HTLC)

Locks
Queries
Claims
Unlocks

3.595
0.381
3.783
2.010

3.611
0.358
4.056
1.871

Similar comparison of API execution overhead for MPHTLC vs.
HTLC is carried out on Fabric platform as well, and the transaction
latencies are in the same range when the assets being exchanged
are owned by single owners.

C API FOR ASSET EXCHANGE WITH

CO-OWNERS

We extended Weaver DLT Interoperability framework to add the
functionality of asset exchange with co-owners. Here we present
the APIs (i.e. how Layer-2 Application will interact with Layer-1)
for lock, claim and reclaim (this doesn’t include other changes in
interoperation chain code for Fabric and interoperation CorDapp for
Corda that we have in our MPHTLC implementation). The Fabric
API is implemented in NodeJS and Corda API is implemented in
Kotlin/Java. We also compare these APIs for MPHTLC with current
Weaver’s APIs for HTLC.

C.1 Creation of MPHTLC Lock
• Fabric:

createSharedHTLC = async(

contract: Contract, assetType: string,
assetID: string, lockerECert: string,
recipientECert: string, hashPreimage: string,
hashValue: string, expiryTimeSecs: number,
timeoutCallback: (c: Contract, t: string,
i: string, l: string, r: string,
p: string, v: string) => any)

Here 𝑙𝑜𝑐𝑘𝑒𝑟𝐸𝐶𝑒𝑟𝑡 and 𝑟𝑒𝑐𝑖𝑝𝑖𝑒𝑛𝑡𝐸𝐶𝑒𝑟𝑡 are comma separated PEM
certs of lockers and recipients respectively. That’s the only dif-
ference as compared to existing 𝑐𝑟𝑒𝑎𝑡𝑒𝐻𝑇 𝐿𝐶 API in Weaver for
Fabric.
• Corda:

createHTLC(

proxy: CordaRPCOps, assetType: String,
assetId: String, recipientParty: String,
hashBase64: String, expiryTimeSecs: Long,

Atomic cross-chain exchanges of shared assets

AFT ’22, September 19–21, 2022, Cambridge, MA

from all the recipients (due to time constraints) and hence we can
observe that the execution times of different transactions are less
when compared to that of Corda.

D HTLC AUGMENTATIONS AND SAMPLE

ATTACKS

Figures 9 and 11 represent HTLC augmentations for shared assets,
and figures 10 and 12 represent sample attacks on these modified
HTLC workflows respectively.

E MPHTLC WORKFLOW INSTANCE
Sample MPHTLC workflow is captured in figure 13.

F GAE MODEL WITH MORE THAN TWO

LEDGERS

The discussion till now has focused on parties present in two ledgers.
The GAE model naturally extends to the multi-ledger scenario
where more than two ledgers are involved. Consider the asset ex-
change scenario in Figure 14. This is similar to the scenario intro-
duced in Figure 4. The only difference here is that the assets W
and R reside in different ledgers.

Our MPHTLC protocol can be directly extended to support this
multi-ledger scenario. The change from the MPHTLC protocol in
Figure 13 is to have the locks and claims on the assets applied in
the respective ledgers. We defer to future work to formally write
down the multi-ledger GAE model, thoroughly investigate the
base scenarios and prove that the base cases and the solution to
them are complete for a multi-ledger GAE.

G CORDA NETWORK ARCHITECTURE IN

WEAVER

Figure 15 describes the architecture of the decentralized apps in a
Corda network.

timeSpec: Int, getAssetStateAndRefFlow: String,
deleteAssetStateCommand: CommandData,
issuer: Party, observers: List<Party>,

observers: List<Party>, coOwners: List<Party>)
Here the difference from existing HTLC API is that 𝑐𝑜𝑂𝑤𝑛𝑒𝑟𝑠
are passed as a list of Corda RPC Parties, in contrast to caller
being assumed as sole owner/locker in Weaver HTLC for Corda.

C.2 MPHTLC Claim of Locked Asset
• Fabric:

claimSharedAssetInHTLC = async (

contract: Contract, assetType: string,
assetID: string, lockerECert: string,
recipientECert: string, hashPreimage: string)
Here 𝑙𝑜𝑐𝑘𝑒𝑟 𝐸𝐶𝑒𝑟𝑡 and 𝑟𝑒𝑐𝑖𝑝𝑖𝑒𝑛𝑡𝐸𝐶𝑒𝑟𝑡 are comma separated PEM
certs of lockers and recipients respectively. That’s the only differ-
ence as compared to existing 𝑐𝑙𝑎𝑖𝑚𝐴𝑠𝑠𝑒𝑡𝐼𝑛𝐻𝑇 𝐿𝐶 API in Weaver
for Fabric.

• Corda: There’s no change in the API.

C.3 MPHTLC Unlock of Locked Asset
• Fabric:

reclaimSharedAssetInHTLC = async (

contract: Contract, assetType: string,
assetID: string, lockerECert: string,
recipientECert: string)

Here 𝑙𝑜𝑐𝑘𝑒𝑟 𝐸𝐶𝑒𝑟𝑡 and 𝑟𝑒𝑐𝑖𝑝𝑖𝑒𝑛𝑡𝐸𝐶𝑒𝑟𝑡 are comma separated PEM
certs of lockers and recipients respectively. That’s the only dif-
ference as compared to existing 𝑟𝑒𝑐𝑙𝑎𝑖𝑚𝐴𝑠𝑠𝑒𝑡𝐼𝑛𝐻𝑇 𝐿𝐶 API in
Weaver for Fabric.

• Corda: There’s no change in the API.

C.4 Query on MPHTLC Locked State
• Fabric:

isSharedAssetLockedInHTLC = async (

contract: Contract, assetType: string,
assetID: string, recipientECert: string,
lockerECert: string)

Here 𝑙𝑜𝑐𝑘𝑒𝑟 𝐸𝐶𝑒𝑟𝑡 and 𝑟𝑒𝑐𝑖𝑝𝑖𝑒𝑛𝑡𝐸𝐶𝑒𝑟𝑡 are comma separated PEM
certs of lockers and recipients respectively. That’s the only dif-
ference as compared to existing 𝑖𝑠𝐴𝑠𝑠𝑒𝑡𝐿𝑜𝑐𝑘𝑒𝑑𝐼𝑛𝐻𝑇 𝐿𝐶 API in
Weaver for Fabric.

• Corda: There’s no change in the API.

Note that, collecting the consent/signature from the co-owners is
achieved in Corda via the transfer of flow session to all the required
signers in an automated fashion during the execution of any of
these transactions. On the other hand, in Fabric, we don’t have this
facility to collect the signatures from the co-owners automatically.
However, one way to implement this is by collecting the signatures
on the hash value (of the secret used for locking) from the required
parties manually and validating all the required signatures inside
the interoperation chaincode. In our Fabric implementation, we
only validate if the transaction submitter is captured as one of the
recipients in the lock state during claim/unlock (and one of the
co-owners during lock creation) but do not collect the signatures

AFT ’22, September 19–21, 2022, Cambridge, MA

Krishnasuri Narayanam, Venkatraman Ramakrishna, Dhinakaran Vinayagamurthy, and Sandeep Nishad

Figure 9: HTLC Protocol with Multiple Signatures

Figure 10: Attack on HTLC Protocol with Multiple Signatures

Atomic cross-chain exchanges of shared assets

AFT ’22, September 19–21, 2022, Cambridge, MA

Figure 11: HTLC Protocol with Multiple Secrets

Figure 12: Attack on HTLC Protocol with Multiple Secrets

AFT ’22, September 19–21, 2022, Cambridge, MA

Krishnasuri Narayanam, Venkatraman Ramakrishna, Dhinakaran Vinayagamurthy, and Sandeep Nishad

Figure 13: Multi-Party Hash Time Locked Contract (MPHTLC) Protocol

Figure 14: Cross-chain atomic swaps with more than two ledgers

Figure 15: Corda Network and Decentralized App Architecture

