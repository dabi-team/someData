SmartSync: Cross-Blockchain Smart Contract
Interaction and Synchronization

Martin Westerkamp
Service-centric Networking
Technische Universit¨at Berlin
Berlin, Germany
westerkamp@tu-berlin.de

Axel K¨upper
Service-centric Networking
Technische Universit¨at Berlin
Berlin, Germany
axel.kuepper@tu-berlin.de

2
2
0
2

n
a
J

1
2

]

R
C
.
s
c
[

1
v
1
0
7
8
0
.
1
0
2
2
:
v
i
X
r
a

Abstract—Cross-Blockchain communication has gained trac-
tion due to the increasing fragmentation of blockchain networks
and scalability solutions such as side-chaining and sharding. With
SmartSync, we propose a novel concept for cross-blockchain
smart contract
interactions that creates client contracts on
arbitrary blockchain networks supporting the same execution
environment. Client contracts mirror the logic and state of
the original
instance and enable seamless on-chain function
executions providing recent states. Synchronized contracts supply
instant read-only function calls to other applications hosted
on the target blockchain. Hereby, current limitations in cross-
chain communication are alleviated and new forms of contract
interactions are enabled. State updates are transmitted in a
veriﬁable manner using Merkle proofs and do not require trusted
intermediaries. To permit lightweight synchronizations, we in-
troduce transition conﬁrmations that facilitate the application
of veriﬁable state transitions without re-executing transactions
of the source blockchain. We prove the concept’s soundness
by providing a prototypical implementation that enables smart
contract forks, state synchronizations, and on-chain validation
on EVM-compatible blockchains. Our evaluation demonstrates
SmartSync’s applicability for presented use cases providing
access to recent states to third-party contracts on the target
blockchain. Execution costs scale sub-linearly with the number
of value updates and depend on the depth and index of corre-
sponding Merkle proofs.

Index Terms—Blockchain interoperability, Smart Contracts,

Sidechains

I. INTRODUCTION

During the last decade, blockchain technology has expe-
rienced rapid development resulting in a growing number
of blockchain networks. While novel forms of consensus
algorithms [1], [2], [3] and smart contract execution environ-
ments [4] pose opportunities for a wide range of use cases,
we observe an increasing fragmentation of applications across
multiple blockchain networks. This tendency is contradictory
to the initial proposition of smart contracts to provide de-
centralized and highly available applications, as it constitutes
a new form of lock-in effect towards the host blockchain.
Because the network is isolated, smart contracts are only
interoperable with other smart contracts in the same network.
Current proposals to enable cross-chain function calls entail
multiple transactions on the initiating blockchain and cannot
cater use cases that require instant responses. Furthermore,
contracts need to be adjusted to support cross-blockchain calls,

as speciﬁc message formats and fallback functions are required
to process return values.

Due to the limitations of current cross-chain solutions,
use cases that require up-to-date read-only access cannot be
implemented efﬁciently. For example, registries such as the
Ethereum Name Service (ENS) provide mappings between
human-readable names and a plethora of attributes. These at-
tributes may include account addresses of a set of blockchains.
Hereby, a link is created between multiple wallets of a user on
various blockchain networks that may be utilized for further
processing or transfers. By providing cross-chain access to
such registries, users will be enabled to perform a single name
registration on a blockchain of their choice and use it across
multiple blockchain networks.

that

One of the most prominent application domains enabled
by blockchain technology is Decentralized Fincance (DeFi),
which provides ﬁnancial products without involving interme-
diaries. Most DeFi applications require trusted data, such as
price feeds,
is typically delivered by oracles [5]. As
an alternative to external oracles, Automated Market Makers
(AMMs) like Uniswap have proven to provide reliable on-
chain price estimations [6]. Up until now, only smart contracts
hosted on the same blockchain as the AMM could beneﬁt
from the provided data. Allowing smart contract queries across
blockchain networks will permit hosting applications on the
best-suited blockchain while retrieving data feeds cross-chain.
We enable such use cases and remedy shortcomings of
isolated smart contract states by developing a novel concept
called SmartSync for smart contract synchronization across
blockchains. Here, a secondary contract is created on the target
blockchain that reﬂects the logic and current state of a smart
contract on the source blockchain. State updates are synchro-
nized by regularly applying storage proofs that are veriﬁed
based on a trusted storage root. Our approach is agnostic to
the storage root source, as long as it is trusted and available on-
chain. Thus, it is applicable to chain relays, notary schemes,
sharding as proposed for Ethereum 2.0 [2] or related concepts
such as Polkadot or Cosmos [7], [8]. As synchronizations
can be initiated within the same block of a function call,
applications can rely on recent states. While smart contract
calls are currently limited to their host blockchain or shard,
SmartSync provides synchronized replicas of remotely hosted

 
 
 
 
 
 
smart contract instances. These replicas provide all view func-
tions of the original contract. As a result, third-party contracts
are enabled to execute the logic of a contract that was initially
deployed on another blockchain network to retrieve veriﬁed
information. To prove the concept’s soundness, we provide
a prototypical implementation of SmartSync1 and publish it
under an open source license.

Our contributions are as follows: We propose a novel
concept for synchronizing smart contracts across multiple
blockchain networks and introduce a new form of state
transition conﬁrmation to facilitate trustless, lightweight state
updates. A prototypical implementation including off-chain
client and respective smart contracts is provided and published.
The prototype is used to prove the concept’s feasibility and
evaluate implied operational costs.

II. PRELIMINARIES
In this Section, we ﬁrst introduce common terms that are
used in the following. Thereafter, multiple approaches for
providing state roots across blockchains are presented, as
SmartSync utilizes derived Merkle proofs to enable trustless
synchronizations. Third, different approaches of cross-chain
smart contract portability are categorized.

A. Deﬁnitions

We base our concept on the assumption that two blockchain
instances A and B exist in parallel and support the same
execution environment for smart contracts. Information is only
transmitted in one direction from A to B. Therefore, we
also refer to A as source and B as target blockchain in
the following. To exemplify the applicability of our concept,
we presume an Ethereum-like implementation of state storage
for our model [9]. Thus, the model incorporates an account-
based model to represent the state rather than utilizing unspent
transaction outputs (UTXOs) [10].

Each blockchain is composed of a sequence of block
headers H. We denote H A
t as the head of blockchain A at
time t and H A
t+1 as the subsequent block header. Block headers
hold information proving their validity according to the applied
consensus algorithm and a reference to the current state. The
global state is deﬁned as the union of all account states. Each
account is identiﬁed by an address and owned by external
users or smart contracts. Every account holds a state that is
composed of a set of key/value pairs f : K → V .

We deﬁne the state of contract C at time t and instantiated

on blockchain A as

S(C A

t ) = {(k1, v1), (k2, v2), ...(kn, vn)}.

The Merkle hash tree function m maps the entire state to
a storage root R, so that m : S(C A
t ). The
Merkle proof (cid:81)(R(C A
t ), (k, v)) proves that (k, v) ∈ S(C A
t ).
Equivalently, S(H A
t ) represents the global state and the re-
spective Merkle hash tree function maps an account C A
to
t
the global state root R(H A
t ) proves
C A

t ), so that (cid:81)(R(H A
t ) ⊆ S(H A

t ). Note that S(C A

t ) → R(C A

t ∈ S(H A

t ), C A

t ).

1https://github.com/disco-project/smart-sync

B. Cross-chain State Roots

Account-based blockchains represent their global state in
is referred to as state
Merkle trees [9]. The tree’s root
root and enables proving the presence of a speciﬁc account
state at a given time. Providing a state root of a primary
blockchain to a secondary blockchain permits accessing the
primary blockchain’s state. In the following, we present three
approaches for transferring state roots between blockchains.

1) Chain Relays: Chain relays reﬂect the consensus mecha-
nism of a primary blockchain on a secondary blockchain [11].
Block headers of a primary blockchain are submitted, validated
and stored on a secondary blockchain if the validation was
successful according the primary blockchain’s consensus rules.
Once a block header is deemed ﬁnal by the relay, it can be
utilized to prove the inclusion of transactions, state or events
within the primary blockchain on the secondary blockchain.
As block headers comprise corresponding Merkle roots, the
submission of Merkle proofs enables inclusion proofs without
requiring trusted intermediaries. A plethora of chain relays
exist that validate block headers within smart contracts [12],
off-chain programs using zkSNARKs [13], or by applying an
optimistic approach [14].

2) Sharding: The objective of blockchain sharding is to en-
hance throughput by distributing transactions and applications
among multiple shards and processing them in parallel [15].
While UTXO variants exist [15], [16], account-based imple-
mentations operate on a shared state root that is accessible
through a hub blockchain [7], [8], [2]. The shared state root
subsumes the state of all connected shards and is relayed back
from the hub to all shards. As a result, cross-shard applications
are enabled by processing states, transactions or events through
Merkle proofs derived from the shared state root.

3) Notary Schemes: Notary schemes facilitate arbitrary
information exchange between blockchains by introducing
trusted notaries [11]. As no complex validation is required,
the scheme’s implementation is comparatively simple. For
instance, transferred data may be trusted if it was signed by a
predeﬁned quorum of notaries.

C. Smart Contract Portability

The term smart contract portability subsumes mecha-
nisms that enable the migration of smart contracts between
blockchain instances, including logic and state. Smart con-
tracts are typically hosted on a single blockchain and inherit
its security and performance properties. As a prerequisite for
smart contract portability, source and target blockchains must
support the same execution environment. We distinguish three
types of smart contract portability: forks, moves, and the novel
synchronization scheme presented in this paper.

1) Smart Contract Forks: Similar to blockchain forks,
smart contract forks describe the creation of a second instance
that exists in parallel to the original instance and is based on a
shared history [17]. Smart contract forks are typically created
on a second blockchain instance to overcome shortcomings
of the primary host blockchain. Reasons for creating smart
contract forks on different blockchains are manifold:

• Incentives of validators (or miners) of the host blockchain
may not be aligned with those of smart contract users.
While validators typically intend to receive high rewards,
smart contracts seek for high throughput, short waiting
times, and low fees.

• Different applications require different degrees of se-
curity. While a smart contract’s target application may
be aligned with the host blockchain’s at
the time of
deployment, its security may decrease over time.

• During a smart contract’s life cycle, external requirements

may change.

transaction, as the state migration process is executed previ-
ously in a veriﬁable manner. Furthermore, complex queries can
be achieved on-chain following the original contract logic.

As a prerequisite, a smart contract fork is created to migrate
logic and current state of the target contract onto a secondary
blockchain. In contrast to smart contract forks, however, only
those functions are callable that do not modify the state. As
the primary contract exists in parallel and remains callable,
the states of primary and secondary contract may diverge over
time. We present a synchronization mechanism that ensures
only valid state updates are applied.

• Over time, better suited blockchain networks may become

available for a given use-case.
To create a smart contract fork,
the executing entity ﬁrst
retrieves the stored bytecode and state. The state does not
necessarily have to reﬂect the latest state, but it can also be
retrieved from a preceding block, depending on the intention.
While the bytecode is easily retrievable using any synchro-
nized full-node client, the state must be reconstructed, i.e. all
key/value pairs must be retrieved. Prior work suggested to
reconstruct the state by retrieving all transactions ever sent to
the target contract in order to observe each state transition [17].
The current state is rebuild by applying all state transitions
consecutively. In case many transactions have modiﬁed the
contract state, this process introduces signiﬁcant overhead.
Today, node client implementations provide more elaborate
traceability functions that permit retrieving all occupied keys
of a smart contract. In our synchronization concept, we use
this mechanism to facilitate rapid contract forks during the
initialization phase prior to synchronization.

2) Smart Contracts Moves: Fynn et al. have proposed a
mechanism for moving smart contracts between ledgers [18].
In contrast to smart contract forks, where two or more in-
stances of a contract exist in parallel, a smart contract move
suspends the primary contract before enabling the secondary
instance. The authors propose dedicated instructions to the
virtual machine to facilitate preconditional locking and unlock-
ing of migrated contracts. Beneﬁcial to users is the decreased
risk of dispersion across multiple instances. On the downside,
moving contracts is only feasible for authorized entities and
users must adhere to the move decision. Compared to this
approach, smart contract forks favor the risk of fragmentation
over centralization.

III. SMART CONTRACT SYNCHRONIZATION

The objective of smart contract synchronization is to pro-
vide instant read-only access to a contract that was initially
deployed to another blockchain. Instant access is characterized
as on-chain function invocation that terminates in a single
transaction. A secondary contract
is created on the target
blockchain that mirrors the original source contract. Hereby,
the smart contract’s functionality and state becomes available
to other smart contracts on the secondary blockchain for
retrieving information, e.g.
through getter methods, while
changing its state is prevented. Consequently, smart contracts
hosted on a remote blockchain can be used within a single

A. Synchronization Conditions

As the contract state may divert from a forked instance, a
mechanism for synchronizing the state over time is required.
Given the decentralized nature of blockchain applications, we
derive the following conditions that must be met to guarantee
valid state updates:

• Equality. The secondary contract’s state must reﬂect a
state of the primary that was valid at a given point in time
according to the source blockchain’s consensus rules.
• Completeness. The entire state must be captured, includ-

ing new, updated and deleted variables.

• Succession. Each synchronization update must reﬂect a

state that succeeded the previous state.

• Trustlessness. The execution must not depend on any

trusted intermediary.

Frequent synchronizations are required to provide valid states
over time. Thus, the depicted conditions are expected to be
met at the time of synchronization. The frequency must be
deﬁned by the referencing contract, as different applications
may have distinct needs in terms of timeliness.

B. Initialization Process

Before a smart contract can be synchronized, its state and
logic must be duplicated via a smart contract fork. While prior
work relied on external validation [17] in the process, we
introduce a veriﬁable migration scheme that utilizes a trusted
state root. Before the source contract’s state can be applied on
the target blockchain, its bytecode and state must be retrieved
either by replaying past transactions or using a blockchain
client’s extended database access.

Contract separation. First, the original contract is split
into dedicated logic and proxy contracts. The proxy contract
maintains the contract state and delegates all function calls
to the logic contract, which in turn executes function logic
based on the proxy contract state. This pattern enables the
implementation of migration and synchronization logic within
the proxy contract while keeping the source contract’s logic
separated. Hereby, the contract logic’s validity is maintained,
as it
is not modiﬁed. The proxy contract supplies setter
methods that enable distributing the initialization over multiple
transactions. After the entire state was replicated, the function
cannot be invoked anymore, ensuring the state’s integrity. For
further details on how to prevent future invocations without
polluting the proxy contract’s state, we refer to [17].

owned account (EOA) or internally by other smart con-
tracts [9]. As the objective of smart contract synchronization is
to replicate the primary contract’s state and the state is derived
from transactions, it is intuitive to record all past transactions
sent to the contract on the primary blockchain and apply them
on the secondary blockchain. For instance, Figure 1 illustrates
a contract C A that is forked and deployed to blockchain B. In
the following, three transactions are sent to C A modifying its
state. To reﬂect the resulting state on C B, all three transactions
would have to be executed sequentially on blockchain B. The
synchronization contract ﬁrst veriﬁes the inclusion of each
transaction on A using a Merkle-proof attesting its inclusion
in a block that is provided by the relay contract. Thereafter,
the correct sequence is conﬁrmed, i.e. no transaction may be
skipped and the submission must adhere to the correct order.
By re-executing all transactions, the same state will be reached
as on the source contract. However, multiple challenges exist
following such an approach.

Transactions cannot be re-executed natively, as the account
matching the signing key pair either does not exist on the target
blockchain or is likely to be in a distinct state, compared to
the source blockchain. Furthermore, corresponding accounts
must hold sufﬁcient funds to compensate for transaction fees
and a linked nonce is incremented every time a transaction is
sent. Thus, all accounts that have sent transactions to contract
C on blockchain A must hold sufﬁcient funds and be in
an equivalent state. In addition, transactions are targeted to
a speciﬁc address necessitating equivalent addresses on both
blockchains. As these requirements can never be guaranteed,
native execution of source transactions are not applicable.

Alternatively, transactions could be executed in an emulated
environment. For instance, in case of Ethereum, the Ethereum
Virtual Machine (EVM) could be implemented within a smart
contract that executes every transaction decoupled from the
sender’s account state and contract address on the target
blockchain. However, such emulation will come at the cost
of increased complexity and thus execution costs. Despite
the inherent additional fees for synchronization, it cannot be
guaranteed that all transactions can be replicated, as the limit
of execution steps within a block may be exceeded. As a
result, an attacker could create a transaction executing complex
logic to prevent its replication on the target ledger, effectively
stalling contract synchronization.

Replaying every single transaction also incurs overhead with
regards to storage operations. Figure 1 presents an example
where variable a is ﬁrst changed from six to seven before
being changed back to six. While the result is equivalent,
these operations cannot be subsumed and must be executed
sequentially. Moreover, to prove the inclusion of every trans-
action, respective storage roots must be provided by the relay
contract. As a result, optimized concepts that reproduce only
a subset of historic storage roots, such as zkRelay [13], cannot
be utilized, inducing overhead during synchronization.

Fig. 1: Simpliﬁed contract state capturing the initial migration
and synchronization of a diverted state. Green highlighting
indicates transaction triggered value changes, purple illustrates
the initial fork state and blue marks synchronized values.

t+x), C B

Veriﬁcation. While external veriﬁcation of the resulting
state was required previously, we introduce a mechanism
that ensures validity on-chain. For this purpose, a dedicated
SmartSync contract is introduced on the target blockchain
that
traces and veriﬁes all migrated smart contracts from
a speciﬁc source blockchain. After successfully migrating a
contract, a transaction is submitted to the SmartSync contract
indicating the migration is ﬁnished. To prove its correct-
ness, two Merkle proofs are submitted: (cid:81)(R(H A
t ) and
(cid:81)(R(H B
t+x), where x ≥ 1. They both depict account
proofs indicating the existence of a speciﬁc account tuple
on the respective blockchain. The ﬁrst proof guarantees the
submission of a correct contract state and is veriﬁed using the
source blockchain’s state root. The second proof conﬁrms the
correct application of the contract’s source state on blockchain
B. We assume header H B
t+x is available to the contract as an
historic state. For instance, Ethereum permits accessing header
hashes of the 256 most recent blocks [9]. In case the target
ledger does not provide the respective block hash to smart
contracts, the contract state’s Merkle root can be computed
within the SmartSync contract during submission.

t ), C A

C. Synchronization Process

The objective of smart contract synchronization is to pro-
vide a secondary instance of a smart contract on a remote
blockchain. The contract state is synchronized regularly, pro-
viding access to its current state to arbitrary contracts on
the secondary blockchain. The synchronization process is
unidirectional, thus, the primary contract remains unaffected
of derived synchronized contracts. Furthermore, the secondary
contract’s state is only modiﬁable by proving the state was
obtained from the primary contract. As a prerequisite, we
assume a smart contract fork is created and veriﬁed as depicted
in Section III-B. To capture all conditions and challenges for
smart contract synchronization, we ﬁrst introduce a na¨ıve ap-
proach and elaborate our concept based on it in the following.

1) Na¨ıve approach: The state of smart contracts is the result
of executed contract logic that is triggered by transactions.
Transactions are either initiated externally using an externally-

2) Veriﬁable state updates: We present a method that
utilizes state proofs for synchronizing contract states across
blockchains to solve the shortcomings of simple transaction

a = 5 b = 3TX 1TX 2TX 3a = 5 b = 3a = 5 b = 3a = 6 b = 3 a = 7 b = 4 a = 6 b = 4 a = 6 b = 4Contract C:Blockchain AContract C:Blockchain BForkSynchronizea = 5 b = 3Fig. 2: Left: Merkle tree of an account state derived from source chain. Center: Multi proof of an updated state: 0x03 is deleted
(red), 0x42 is modiﬁed (yellow) and 0x02 is added (green). Right: Transition Conﬁrmation calculated on the target chain.

replication. Instead of proving the inclusion of transactions
sent to the source contract, the resulting state is used for
updates. To prove the presence of a particular key-value pair
in the contract state, two Merkle proofs are required. First, the
account proof (cid:81)(R(H A
t ), C A
t ) documents the inclusion of an
account tuple within a block header H, where R(H A
t ) is the
global state root at time t. Second, storage proofs notarize
the inclusion of a speciﬁc key-value pair (cid:81)(R(C A
t ), (k, v))
in the account state, where R(C A
t ) is is the account state
root at time t. Applying these proofs on the target ledger
permits proving the addition, change or deletion of single key-
value pairs. Proving the result of executed transactions rather
than replaying state transitions results in more efﬁcient state
updates in case of multiple write operations at a single key
location. For instance, Figure 1 depicts multiple updates of
multiple values. Utilizing storage proofs permits to skip all
intermediary changes and apply the veriﬁed ﬁnal result.

The application of single key-value proofs meets all con-
ditions deﬁned in Section III-A but Completeness. Equality
is met as the combination of account and storage proof
ensures the presented key-value pair existed on blockchain A
at some time. Only updates newer than the previous update are
accepted. Succession and Trustlessness are established via the
utilized state root. Furthermore, anyone can submit account
and storage proofs, rendering the entire process veriﬁable.
Completeness, however, is not assured, as storage proofs are
independent from each other. An attacker could submit only a
subset of state updates to induce an inconsistent state. While
it would be impossible to add variables that are not part of
the source contract, delete variables that haven’t been deleted
or modify values that haven’t been modiﬁed, concealing a
subset of state updates poses a serious vulnerability. Figure 2
depicts a state transition S(C A
t+x), where x > 0 and
includes three updates. To fully capture the state transition, all
three updates must be applied via dedicated storage proofs.
However,
in the executing entity
and therefore violate the Trustlessness condition. Moreover,
submitting a single storage proof for each modiﬁcation creates
considerable overhead, as each proof must be veriﬁed inde-
pendently. To overcome both issues, we introduce transition
conﬁrmations based on multi proofs.

this would require trust

t ) → S(C A

3) Multi proofs: Multi proofs describe a mechanism for
proving the inclusion of multiple values using a single
proof and have been proposed to overcome inefﬁciencies
when querying multiple values [19]. While common Merkle
proofs reﬂect a path within the respective Merkle tree,
multi proofs share nodes of paths and thus depict sub-trees
with substituting hash values where the tree was pruned.
As a result, a set of key-value pairs can be included in
a proof (cid:81)(R(C A
t ), {(k1, v1), (k2, v2), ...(kn, vn)}), indicating
that {(k1, v1), (k2, v2), ...(kn, vn)} ∈ S(C A
t ). For instance, to
prove the inclusion of keys 0x00 and 0x03 in Figure 2, only
the leaf values and two branch hashes of layers one and two of
the tree are required. The efﬁciency of multi proofs depends
on the index of the target leaf values. The more branches are
shared, the more efﬁcient a multi proof becomes in comparison
to single proofs.

While multi proofs increase efﬁciency, they do not solve
the threat of withholding parts of the resulting state. Attackers
could submit valid multi proofs including only a subset of key-
value pairs involved in the original state transition. Updating
the secondary contract state by applying a multi proof could
thus result in an inconsistent state.

4) Transition conﬁrmations: The objective of transition
conﬁrmations is to guarantee Completeness. Thus, the entire
state transition result must be captured,
including all cre-
ate, update and delete operations. Transition conﬁrmations
are not submitted externally, but computed on-chain based
on a multi proof. As the state of the source contract
is
not accessible from the target ledger2, we utilize the fact
that the latest target contract state S(C B
t+x) equals the pri-
mary state S(C A
t ) →
S(C A
t+y), where y > x > 0. The submitted multi proof
(cid:81)(R(C A
t+y), {(k1, v1), (k2, v2), ...(kn, vn)}) indicates inclu-
sion of respective key-value pairs given the Merkle root, but
fails to create a link to the previous state S(C A
t ). Transition
conﬁrmations create such a link by replacing all values of
the multi proof’s key-value set with the original values of the
state transition. The original values are available during the

t ) of original state transition S(C A

2Submitting Merkle proofs for each primary key-value pair would be
possible but require considerable overhead that is avoidable by accessing the
currently synchronized state on the target ledger.

ABCDEFGHIJKLMKeyValue0x000x120x030x320x420x200x170x080x840x130x480x300x720x29NOPQRFGSJKT0x000x120x420x840x020x440x840x130x170x080x030x00ABCDEFGHIJK0x000x120x030x320x420x200x170x080x840x13State TreeMulti ProofTransition ConfirmationClientComputationOn-ChainComputationt ) = S(C B

computation, as they constitute the target contract’s current
state S(C A
t+x). Therefore, they are retrievable by
reading from the respective key location on the ledger. While
the multi proof’s values are substituted, the actual paths remain
equivalent. Hereby, it is ensured that the entire state was
captured, as withheld state updates would be reﬂected in
changed paths. The computed transition conﬁrmation depicts
a valid multi proof of the initial state S(C B
t+x) if all changed
values of the state transitions are reﬂected in the submitted
multi proof:

(cid:89)

(R(C A

t+y), {(k1, vt+y
t+x), {(k1, vt+x

), (k2, vt+y
2
), (k2, vt+x

1

2

1

(cid:89)

(R(C B

), ...(kn, vt+y

n )}) →

), ...(kn, vt+x

n )})

Thus, the transition conﬁrmation is validated equivalently to a
multi proof and we expect the computed Merkle root to equal
the previous state’s Merkle root if all changes were captured
and different otherwise, as illustrated in Figure 2. The rationale
is that a multi proof is a pruned version of the original Merkle
tree and includes those key-value pairs that have been modiﬁed
during a state transition. Withholding a subset of updates will
be disclosed by this kind of transition check, as the withheld
set is captured in a hashed branch:

(cid:89)

t+y), {(k1, vt+y
(R(C A
(cid:89)
(R(C B

1

t+x), {(k1, vt+x

1

),(cid:24)(cid:24)(cid:24)(cid:24)(cid:24)(cid:58) ∅
(k2, vt+y
2
), ...(kn, vt+x

n )})

), ...(kn, vt+y

n )}) (cid:57)

When computing the transition conﬁrmation’s Merkle root, it
becomes evident that the result is different from the original
root in case the submitted multi proof is incomplete.

While the sole validation of a multi proof could not capture
the state transition depicted in Figure 2, the computed transi-
tion conﬁrmation ensures correct state updates. For instance,
let us assume an attacker submits a multi proof including state
updates at keys 0x03 and 0x24 but withholding the value
addition at key 0x02. To create a transition conﬁrmation, the
values at key locations 0x03 and 0x42 are read from the target
ledger and inserted in the multi proof to build the transition
conﬁrmation. As Node P remains unaffected, the tree root
would be calculated from nodes B and P instead of B and
C, resulting in a hash different to A. Thus, it becomes evident
that an incomplete multi proof was passed and the state update
is aborted.

5) Workﬂow: The combination of account proof, multi
proof and on-chain computed transition conﬁrmation enables
veriﬁable state replication of smart contracts across multiple
blockchain instances. In the following, we depict the required
steps to synchronize state updates from a primary contract to a
secondary client contract hosted on a remote blockchain. The
entire workﬂow is illustrated in Figure 3.

The process is initiated by any entity motivated to update
an expired state on the target blockchain. Motivation may be
intrinsic as a depending smart contract of interest requires
a recent state or it may be triggered externally through a
monetary incentive system. As external incentive layers exceed
the focus of this work, we refer to [12], [20], [14] for further

Fig. 3: Synchronization workﬂow of SmartSync.

reading and leave its application on the presented use case
for future work. The external entity runs a SmartSync client
having access to clients of blockchains A and B.

After retrieving the account proof from the source client, all
transactions sent to the smart contract since the last update are
retrieved and replayed locally (Steps 1-3). Replaying respec-
tive transactions results in a set of key-value pairs representing
the consequential state update. Thereafter, a storage proof is
retrieved from the source node for each key-value pair (Step 4)
and combined to a multi proof (Step 5). Both, account and
multi proof are submitted to the proxy contract on the target
blockchain in Step 6. The account proof veriﬁcation takes
place within the proxy contract and presumes a respective
block header to be available within the relay contract. In
case the block header is unavailable, the relay contract must
be updated accordingly before starting the synchronization
process. After verifying the multi proof, it is used for creating
the transition conﬁrmation that ensures all state updates are
included in the multi proof (Steps 7-8). While the multi proof
utilizes the Merkle root stored in the passed account proof, i.e.
the new storage root, the transition conﬁrmation is based on the
current storage root that is stored within the smart contract and
updated for each synchronization. If the transition conﬁrmation
is deemed valid, the state updates included in the multi proof
are applied to the proxy state (Steps 9-10).

Utilizing the resulting storage state of the source contract
permits subsuming multiple transactions, reducing storage
and execution costs. In case the state update is too large
to be executed within a single transaction, a previous state
subsuming less transactions must be utilized ﬁrst.

Blockchain AClientPrimaryContract: Ctransactions: TXsproofsynchronize (accountProof, multiProof)verifyaccountProofgetStorageRootstorageRootBlockchain BClientverifymultiProof123678createoptimizedMerkle proofreturnverifytransition conf.createtransition conf.9updateState104storageProofsSmartSync ClientgetAccountProof(C)getTransactions(C)5RelayContractSecondaryContract(State Proxy)getStorageProofs(keys)stateDiffreplay(TXs)IV. EVALUATION

To evaluate SmartSync, a prototypical implementation of
the concept was created that permits forking and synchronizing
smart contracts between blockchains supporting the EVM. The
implementation is published under an open source license. The
prototype provides a client including command line interface
to retrieve states and proofs from the source blockchain,
create corresponding multi proofs and submit them to the
target blockchain. Furthermore, a proxy contract is supplied
that retrieves, validates and applies state updates, delegates
read-only function calls to the logic contract and prevents
write operations other than synchronizations. To prevent the
delegation of function calls that would modify the state, the
execution context must be static. When retrieving a function
call, the proxy contract’s fallback function is executed, as
it is the default operation in case the function signature is
unknown. The fallback function conﬁrms the execution context
is static and delegates the call to the logic contract. Hereby,
the executed logic operates on the state of the proxy contract
that is a replica of the source contract.

The application of smart contract synchronization entails
execution costs on the target blockchain. As SmartSync is
agnostic to the state root’s source, we neglect the evaluation of
corresponding application costs. Ethereum measures execution
costs by assigning a fee called gas to every operation of
the EVM [9]. To determine the gas costs of synchronization
operations, multiple contracts are deployed and synchronized.
Each contract holds a mapping of different size, resulting in
storage tries of variable depth. First, we analyze the costs of
updating a single value depending on its index in the Merkle
tree. As indicated in Figure 4a, the costs increase with the
value’s storage height within the tree, as the corresponding
Merkle proof requires more nodes to be submitted. Each
additional node results in increasing costs for parameter size
and proof validation. Large contract storage sizes lead to
deeper Merkle trees and thus drive synchronization costs. Fur-
thermore, execution costs depend on the node types included in
the Merkle proof. Ethereum utilizes modiﬁed Merkle Patricia
trees to store values [9]. We observe that proofs containing
more extension nodes are cheaper than those containing branch
nodes, as depicted in Figure 4a for heights 3, 5 and 6. As
branches contain up to 17 elements, more bytes must be passed
compared to extension nodes holding a two items.

Second, we evaluate the gas costs when updating multiple
values in a single synchronization transaction. As for single
values, updates incur less gas costs for smaller storage sizes,
as illustrated in Figure 4b. Synchronization costs per value
decrease with an increasing number of values subsumed in a
single transaction. Thus, gas costs increase sub-linearly. As
multi proofs share nodes of the original Merkle tree, fewer
nodes have to be submitted and validated, the more nodes are
shared. The effect can be observed in Figure 4b, indicated by
jitter in gas costs for each storage size.

Lastly, we measure the latency of synchronization updates
including the retrieval of state proofs, computation of multi-

proofs and execution on the target blockchain. The bench-
mark was executed on a machine equipped with an Intel
Core i7-6700HQ 266 CPU at 2,60 GHz and 16 GB memory.
Source and target blockchains are private Ethereum networks
performing instant mining. Our results show that updating a
single value takes between 91 ms and 475 ms for updating a
single value, depending on the Merkle tree’s depth. An update
transaction that includes multiple values requires 119 ms for
10 values and grows linearly to 1,879 ms for 1,000 values.
As the involved latency remains well within the block mining
times of most blockchain networks, the concept is suitable for
applications requiring timely updates.

V. RELATED WORK
Most cross-chain protocols target the exchange or transfer of
tokens across blockchain networks [21], [22], [23], [24], [25].
As SmartSync captures elaborate smart contract functionality
going beyond token handling, we present concepts proposing
cross-chain smart contract interaction in the following.

HyperService is a concept for enabling cross-chain smart
contract invocations [26]. The approach includes a domain-
speciﬁc language that generates decentralized applications uti-
lizing multiple interacting smart contracts which are deployed
to separate blockchain networks. A state model is created to
track the global application state on a dedicated blockchain
for cross-chain communication. Thus, a hub blockchain or-
chestrates cross-chain smart contract interaction. In contrast,
SmartSync enables instant smart contract queries after syn-
chronization and does not implement any abstraction to enable
access to decentralized applications.

Nissl et al. have proposed a concept that also enables cross-
chain function calls, but does not implement an abstraction
layer and does not require a mediating blockchain to or-
chestrate interaction [27]. Instead, smart contract invocations
are executed by intermediaries and checked by validators
who ﬁnalize transactions. In case misbehaviour is obeserved,
deposited funds get reduced. While the concept permits cross-
chain function calls, multiple contract invocations and waiting
times are required. Furthermore, the approach is only secure
under economic assumtions, while SmartSync derives its secu-
rity from Merkle proofs and a trusted state root. Chainbridge3
constitutes a similar protocol but relies on a trusted federation
rather than economic safeguarding. In comparison, SmartSync
permits instant read-only function calls of synchronized con-
tracts but cannot invoke functions across blockchains.

The Cross-Chain Messaging Protocol (XCMP)4 enables
sending messages between shards in the Polkadot ecosys-
tem [7]. As shard communication is implemented via the relay
chain mechanism, delays are low and its setup is comparable
to SmartSync. However, it does not focus on smart contract
replication across shards but facilitates communication by
providing dedicated message queues mediated by bilateral
channels between shards. Instant function calls are not possible
and smart contracts must implement the message mechanism.

3https://chainbridge.chainsafe.io/
4https://research.web3.foundation/en/latest/polkadot/XCMP/

(a) Updating a single value at different storage locations in the
storage tree

(b) Updating multiple values using a single multi proof

Fig. 4: Gas costs of synchronization processes including different update set sizes.

VI. DISCUSSION

Different use cases have speciﬁc requirements on the refresh
period of depending smart contracts. For instance, DeFi appli-
cations typically rely on up-to-date data, while registries such
as the ENS do not change as regularly. SmartSync can cater for
both use cases given the storage root is updated in time. Chain
relay and target contract can be updated in the same block as
the calling contract execution to provide the most recent state.
In case SmartSync is applied to provide accessibility across
shards, the utilization of synchronized contracts may behave
equivalently to locally hosted contracts. This is the case if the
calling contract requires a state of the latest created block and
the block creation time is deterministic, as typically provided
by Proof-of-Stake (PoS)-based blockchains.

Synchronized smart contracts may also depend on other
smart contracts. Synchronizing only a single contract without
considering dependencies could lead to unexpected behavior.
Therefore, all referenced contracts and libraries must be mi-
grated and synchronized. Previous work on smart contract
forks proposed the analysis of logic and state during migration
and recursively deploying dependencies [17]. As contract
addresses change during deployment, they are substituted for
each reference. Replacing addresses in the state results in
a distinct state and thus Merkle root, leading to complex
veriﬁcation during deployment. In case of synchronizations,
the same mechanism could be applied. As the contract’s
Merkle root is deemed valid after migration, the computed
transition conﬁrmation also utilizes a valid root and does not
need to be modiﬁed to create valid results. Therefore, the
presented concept is applicable even if reference addresses
were replaced during the initial migration.

SmartSync promotes read-only access for synchronized
smart contracts and does not provide cross-chain write oper-
ations. While other approaches target such write access [28],
[27], multiple steps including locking is required to maintain

atomicity. As a result, the process is time-intensive and may
lead to additional overhead in case the timeout period is
exceeded. Therefore, our solution leaves the responsibility
of invoking transactions across multiple blockchains to the
external application. Depending smart contracts hosted on
another blockchain network are put in a desired state that
is subsequently proven on the target blockchain. Hereby, the
resulting state becomes accessible through simple function
calls. Time consuming locking mechanisms are mitigated and
instant function execution is enabled on the target blockchain.

VII. CONCLUSION

In this paper, we presented SmartSync, a novel concept
for synchronizing smart contracts across multiple blockchain
networks. The state of a remotely hosted smart contract is
synchronized periodically in a veriﬁable manner. No trust
in executing entities is required, enabling all participants to
perform state updates. Furthermore, we introduced transition
conﬁrmations that prove correct smart contract state transitions
on a secondary blockchain based on a multi proof. As the
entire smart contract is migrated from the source blockchain,
the contract’s state and logic become accessible on the target
network. Hereby, instant read-only function calls by depending
smart contracts are rendered possible, facilitating use cases
such as cross-chain registries or oracles. Our open source im-
plementation proves the concept’s soundness and demonstrates
timely updates of contract states.

In the future, the presented solution will foster overarching
architectures that include off-chain components as well as
on-chain workﬂows executed on multiple blockchains. Pro-
viding atomicity within such workﬂows depicts a potential
task for future research. Required state updates are initiated
sequentially and become available after synchronization. Thus,
SmartSync constitutes a foundation for applications that utilize
smart contracts across multiple blockchain networks.

600800100023456Storage height in merkle treeGas used (Thousand)Storage size101001000010200255075100#valuesGas used (Million)Storage size101001000REFERENCES

[1] A. Kiayias, A. Russell, B. David, and R. Oliynykov, “Ouroboros: A
provably secure proof-of-stake blockchain protocol,” in Advances in
Cryptology – CRYPTO 2017, J. Katz and H. Shacham, Eds. Cham:
Springer International Publishing, 2017, pp. 357–388.

[2] V. Buterin, D. Hernandez, T. Kamphefner, K. Pham, Z. Qiao,
D. Ryan, J. Sin, Y. Wang, and Y. X. Zhang, “Combining GHOST
and casper,” CoRR, vol. abs/2003.03052, 2020. [Online]. Available:
https://arxiv.org/abs/2003.03052

[3] A. Stewart and E. Kokoris-Kogia, “GRANDPA: a byzantine ﬁnality
[Online]. Available:

gadget,” CoRR, vol. abs/2007.01560, 2020.
https://arxiv.org/abs/2007.01560

[4] S. N. Khan, F. Loukil, C. Ghedira-Guegan, E. Benkhelifa, and A. Bani-
Hani, “Blockchain smart contracts: Applications, challenges, and future
trends,” Peer-to-peer Networking and Applications, 2021.

[5] B. Liu, P. Szalachowski, and J. Zhou, “A ﬁrst look into deﬁ oracles,”
in 2021 IEEE International Conference on Decentralized Applications
and Infrastructures (DAPPS), 2021.

[6] “Uniswap Oracles,”

https://docs.uniswap.org/protocol/V2/concepts/

core-concepts/oracles, Accessed: 2021-08-12.

[7] G. Wood, “Polkadot: Vision for a Heterogeneous Multi-chain Frame-
work,” 2016, https://polkadot.network/PolkaDotPaper.pdf Accessed:
2021-03-18.

[8] J. Kwon and E. Buchman, “Cosmos: A Network of Distributed
https://github.com/cosmos/cosmos/blob/master/

Ledgers,”
WHITEPAPER.md Accessed: 2021-07-20.

2018,

[9] G. Wood, “Ethereum: a secure decentralised generalised trans-
action ledger,” Ethereum Project Yellow Paper, 2021, https://
ethereum.github.io/yellowpaper/paper.pdf. Accessed: 2021-07-05.
[10] S. Nakamoto, “Bitcoin: A Peer-to-Peer Electronic Cash System,” 2008,

http://www.bitcoin.org/bitcoin.pdf. Accessed: 2021-05-02.

[11] V. Buterin, “Chain Interoperability,” 2016.
[12] “BTC Relay,” https://github.com/ethereum/btcrelay, Accessed: 2021-07-

14.

[13] M. Westerkamp and J. Eberhardt, “zkRelay: Facilitating Sidechains
using zkSNARK-based Chain-Relays,” in 2020 IEEE European Sym-
posium on Security and Privacy Workshops (EuroS&PW), 2020, pp.
378–386.

[14] P. Frauenthaler, M. Sigwart, C. Spanring, M. Sober, and S. Schulte, “Eth
relay: A cost-efﬁcient relay for ethereum-based blockchains,” in 2020
IEEE International Conference on Blockchain (Blockchain), 2020, pp.
204–213.

[23] M. Herlihy, “Atomic Cross-Chain Swaps,” in Proceedings of

[15] E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly, E. Syta, and
B. Ford, “OmniLedger: A Secure, Scale-Out, Decentralized Ledger via
the
2018 ACM Symposium on Principles of Distributed Computing, ser.
PODC ’18. New York, NY, USA: Association for Computing

Sharding,” in 2018 IEEE Symposium on Security and Privacy (SP), 2018,
pp. 583–598.

[16] L. Luu, V. Narayanan, C. Zheng, K. Baweja, S. Gilbert, and
P. Saxena, “A secure sharding protocol for open blockchains,” in
Proceedings of
the 2016 ACM SIGSAC Conference on Computer
and Communications Security, ser. CCS ’16. New York, NY, USA:
Association for Computing Machinery, 2016, p. 17–30.
[Online].
Available: https://doi.org/10.1145/2976749.2978389

[17] M. Westerkamp, “Veriﬁable Smart Contract Portability,” in 2019 IEEE
International Conference on Blockchain and Cryptocurrency (ICBC),
May 2019, pp. 1–9.

[18] E. Fynn, A. Bessani, and F. Pedone, “Smart contracts on the move,” in
2020 50th Annual IEEE/IFIP International Conference on Dependable
Systems and Networks (DSN), 2020, pp. 233–244.

[19] A. Mizrahi, N. Koren, and O. Rottenstreich, “Optimizing merkle proof
size for blockchain transactions,” in 2021 International Conference on
COMmunication Systems NETworkS (COMSNETS), 2021, pp. 299–307.
[20] J. Teutsch and C. Reitwießner, “A scalable veriﬁcation solution for

blockchains,” arXiv preprint arXiv:1908.04756, 2019.

[21] A. Zamyatin, D. Harz, J. Lind, P. Panayiotou, A. Gervais, and W. Knot-
tenbelt, “XCLAIM: Trustless, Interoperable, Cryptocurrency-Backed
Assets,” in 2019 IEEE Symposium on Security and Privacy (SP), May
2019, pp. 193–210.

[22] P. Gaˇzi, A. Kiayias, and D. Zindros, “Proof-of-Stake Sidechains,” in
2019 2019 IEEE Symposium on Security and Privacy (SP).
Los
Alamitos, CA, USA: IEEE Computer Society, may 2019, pp. 677–694.
[Online]. Available: https://doi.org/
Machinery, 2018, p. 245–254.
10.1145/3212734.3212736

[24] M. Borkowski, M. Sigwart, P. Frauenthaler, T. Hukkinen, and S. Schulte,
“Dextt: Deterministic Cross-Blockchain Token Transfers,” IEEE Access,
vol. 7, pp. 111 030–111 042, 2019.

[25] M. Herlihy, B. Liskov, and L. Shrira, “Cross-chain deals and adversarial

commerce,” The VLDB Journal, 2021.

[26] Z. Liu, Y. Xiang, J. Shi, P. Gao, H. Wang, X. Xiao, B. Wen, and
Y.-C. Hu, “Hyperservice: Interoperability and programmability across
heterogeneous blockchains,” in Proceedings of the 2019 ACM SIGSAC
Conference on Computer and Communications Security, ser. CCS ’19.
New York, NY, USA: Association for Computing Machinery, 2019, p.
549–566. [Online]. Available: https://doi.org/10.1145/3319535.3355503
[27] M. Nissl, E. Sallinger, S. Schulte, and M. Borkowski, “Towards cross-
blockchain smart contracts,” in 2021 IEEE International Conference on
Decentralized Applications and Infrastructures (DAPPS), 2021.
[28] P. Robinson and R. Ramesh, “General purpose atomic crosschain trans-
actions,” in 2021 3rd Conference on Blockchain Research Applications
for Innovative Networks and Services (BRAINS), 2021, pp. 61–68.

