A Survey of Layer-Two Blockchain Protocols

Ankit Gangwal*, Haripriya Ravali Gangavalli†, and Apoorva Thirupathi†

1

2
2
0
2

l
u
J

6
2

]

R
C
.
s
c
[

3
v
2
3
0
8
0
.
4
0
2
2
:
v
i
X
r
a

Abstract—After the success of the Bitcoin blockchain, came
several cryptocurrencies and blockchain solutions in the last
decade. Nonetheless, Blockchain-based systems still suffer from
low transaction rates and high transaction processing latencies,
which hinder blockchains’ scalability. An entire class of solutions,
called Layer-1 scalability solutions, have attempted to incremen-
tally improve such limitations by adding/modifying fundamental
blockchain attributes. Recently, a completely different class of
works, called Layer-2 protocols, have emerged to tackle the
blockchain scalability issues using unconventional approaches.
Layer-2 protocols improve transaction processing rates, periods,
and fees by minimizing the use of underlying slow and costly
blockchains. In fact, the main chain acts just as an instrument
for trust establishment and dispute resolution among Layer-
2 participants, where only a few transactions are dispatched
to the main chain. Thus, Layer-2 blockchain protocols have
the potential to transform the domain. However, rapid and
discrete developments have resulted in diverse branches of Layer-
2 protocols. In this work, we systematically create a broad
taxonomy of such protocols and implementations. We discuss
each Layer-2 protocol class in detail and also elucidate their
respective approaches, salient features, requirements, etc. More-
over, we outline the issues related to these protocols along with
a comparative discussion. Our thorough study will help further
systematize the knowledge dispersed in the domain and help the
readers to better understand the ﬁeld of Layer-2 protocols.

Index Terms—Blockchain, Layer-2, Off-chain, Scalability.

I. INTRODUCTION

Blockchain is a digital

ledger of assets (e.g., ﬁnancial
transactions) that is typically managed by a network of peer-
to-peer nodes. It provides a transparent and decentralized
approach for publicly-veriﬁable and tamper-evident record
keeping. Its unique properties help in eliminating the control
of a centralized authority, provide ubiquity, and facilitate
fairness via its underlying consensus protocol. Blockchain
is essentially the fundamental building block of Bitcoin [1],
which is a decentralized cryptocurrency - or, simply a digital
cash system - towards which researchers have been working
over multiple decades [2, 3]. Blockchain helps in establishing
an agreement between mutually distrusting entities even in the
absence of a trusted third party. After the success of Bitcoin,
a multitude of ﬁnancial and non-ﬁnancial ﬁelds have been
dramatically transformed by the idea of utilizing a blockchain-
based distributed public ledger.

According to a widely accepted belief, called blockchain
trilemma [4], blockchains can prioritize only two features
among decentralization, security, and scalability. Decentral-
ization reﬂects the fundamental nature of a blockchain while
security is an absolute requirement. Therefore, achieving

* Corresponding author: Ankit Gangwal (gangwal@iiit.ac.in)
† Both authors contributed equally.
All authors are with International Institute of Information Technology

Hyderabad, 500032, India.

scalability has always remained a challenge for blockchain
researchers and developers. Even after a decade of its birth,
Bitcoin still suffers from high transaction latency and fails
to handle transaction load when compared to conventional
payment systems. One of the key factors behind the limited
scalability of blockchain is directly related to its core work-
ing principle, i.e., their underlying consensus protocol. As a
representative example, a block in the Bitcoin blockchain can
ﬁt only a limited number of transactions while the Bitcoin
network adapts itself to generate only one block every ten
minutes on average. Such calibrations have severely restricted
to roughly ten Transactions Per
its transaction throughput
Second (TPS) [5] while regular payment systems, such as
VISA and PayPal, handle thousands of TPS.

To tackle the issue of scalability, researchers from both
academia and industry have proposed different solutions for
scaling blockchains. The primary class of such solutions,
commonly known as Layer-1 solutions, mainly targets and im-
proves the working principles of blockchains by (i) modifying
block data [6–8]; (ii) proposing alternative consensus mecha-
nisms [9–15];(iii) sharding the network [16–20]; or (iv) using
solutions based on Directed Acyclic Graphs (DAG) [21–
23] (cf. Fig. 1). Since Layer-1 solutions involve changing the
core design elements of blockchains, these solutions typically
lack backward compatibility. As a representative example,
modifying the consensus mechanism of a blockchain that is
already in-use leads to blockchain forking. Similarly, sharding
protocols make signiﬁcant changes to the overall network
layout. Thus, Layer-1 solutions come with critical issues that
hinder their implementation in practice [24].

Fig. 1. Layer-1 scalability solutions.

The limitations of Layer-1 solutions induced an orthog-
onal research direction for blockchain scalability, generally
called Layer-2 blockchain protocols. These protocols aim to
scale blockchains without altering the underlying consensus
mechanism of the concerned blockchain or modifying the
Layer-1 trust assumptions. These solutions are called Layer-
2 as they are primarily built over the stack of blockchain
layer -1)
layers (cf. Fig. 2), where the lowest
represents the hardware, layer 0 comprises the network of
nodes used for information exchange, the blockchain executes
in the layer 1 of the stack, and Layer-2 scalability solutions sit
in layer 2. Layer-2 protocols do not broadcast every transaction

level (i.e.,

E.g., Avalanche [28], IOTA [29]Layer 1 ScalabilitySolutionsE.g., SegWit [6], Txilm [7]BlockdataE.g., Algorand [25], Bitcoin-NG [9]Alternative ConsensusAlgorithmsE.g., Chainspace [26], Elastico [27]ShardingDAG 
 
 
 
 
 
on the underlying main chain, they instead enable participants
to execute off-the-chain transactions over an authenticated
communication medium. As a result, transaction load on the
main chain is immensely reduced without compromising on
backward compatibility. The transactions in Layer-2 protocols
are secured with collateral (e.g., in payment channels [30–33])
or with delayed ﬁnality (e.g., in commit chains [34]).

Fig. 2. Blockchain layered stack, common in blockchain community.

Motivation: The unique and promising features of Layer-
2 protocols have attracted the attention of researchers in
the community. As a result, the research efforts on Layer-
2 blockchain scalability protocols are continuing to expand
pervasively. Different Layer-2 solutions come with their own
set of goals, assumptions, requirements, advantages, etc. There
is little clarity - especially for new entrants to the community
- to map, understand, and evaluate different Layer-2 solutions.
Despite the existence of a rich body of literature on various
Layer-2 solutions, a comprehensive study to cover the state of
the art detailing their characteristics, limitations, issues, etc. is
still missing. Thus, navigating through this research space is
not straight forward; especially when the ﬁeld is growing at a
fast pace in different directions. We aim to ﬁll such gap in the
literature by consolidating and systematizing the information
about the state of the art of Layer-2 blockchain protocols.

Contribution: In this paper, we survey various Layer-2
blockchain scalability protocols proposed over the years since
the birth of Bitcoin in 2009. Our aim is to present a holistic
view of this research ﬁeld. To the best of our knowledge, our
work is the ﬁrst such study. We create a broad taxonomy of
Layer-2 protocols and implementations and discuss each pro-
tocol class in detail. In particular, we explain their respective
approaches, key characteristics, advantages, limitations, etc.
We also discuss the key networking aspects, security concerns,
and privacy issues present in the literature. Finally, we present
a comparative discussion to help readers assess the feasibility
of different Layer-2 solutions.

Organization: The remainder of this paper is organized as
follows. Section II covers the key fundamental concepts and
related works. We discuss in detail different Layer-2 protocols
in Section III. Section IV describes networking aspects while
Section V focuses on security and privacy issues. We present

2

a comparative discussion on different Layer-2 scalability solu-
tions in Section VI. Finally, Section VII concludes the paper.

II. BACKGROUND
We introduce the key building blocks of Layer-2 protocols

in Section II-A and the related works in Section II-B.

A. Blockchain and HTLC

Blockchain is an immutable, linked-list style, append-only
chain of blocks, where each block stores transactions sent
among network entities. Typically, each transaction reﬂects an
exchange of digital assets between network peers. Participants
in the network execute a consensus algorithm to achieve a
common agreement about the state of the blockchain, which
there are a
also helps in maintaining its integrity. Today,
number of consensus algorithms available. Different consen-
sus algorithms follow fundamentally different approaches to
achieve distinct goals. Another key aspect
is whether the
access to blockchain is open or restricted. In the former case,
the blockchain is permissionless while the latter represents
a permissioned blockchain. Finally,
the scripting language
supported by the blockchain deﬁnes its expressiveness. As
a representative example, the Bitcoin blockchain uses a sim-
ple and Turing-incomplete script [1] while Ethereum uses a
Turing-complete language to support a more powerful smart
contract [35]. While Layer-2 protocols can be built upon both
permissioned and permissionless blockchains, the expressive-
ness of the underlying blockchain plays an important role in
designing Layer-2 protocols built upon it. Importantly, Layer-
2 protocols assume that the underlying blockchain will only
include valid transactions to the ledger.

The key to a successful P2P transaction system without
a central entity relies on a simple and efﬁcient trust-based
mechanism. Hash Time Locked Contract (HTLC) [32, 36, 37]
provides such a solution and acts as the fundamental construc-
tion for several Layer-2 protocols. As a representative exam-
ple, HTLC implementation can be observed in the Lightning
network. The core idea of HTLC includes a hash veriﬁcation
and time expiration. Fig. 3 shows an example of using HTLC
in payment channels.

Fig. 3. A representative example of using HTLC

Consider a payment channel network from A to C through
B, where A is the sender and C is the receiver of funds. C

Layer 0: NetworkLayer -1: HardwareLayer 1: BlockchainTimeBlock nBlock n+1Layer 2: Scalability protocols... BACPayment ChannelPayment ChannelSecret ZSecret Z2345HTLC  1.000 BTC + 5 blocksB to CHTLC  1.001 BTC + 6 blocksA to BHash(Z)1generates a secret Z and computes its hash Hash(Z). Then,
C communicates Hash(Z) to A. A locks the required funds
(including a fee for transfer to intermediaries) in his channel to
B and shares Hash(Z) with B in a locking script. B can retrieve
the funds only if it can produce Z corresponding to Hash(Z). B
further locks funds in his channel with C and passes Hash(Z)
to C; B reduces the time to reveal Z and makes some margin on
the fee. C can claim these funds only if it can produce Z. Since
C knows Z, it can redeem funds in the channel between B and
C by revealing Z to B, which can further collect the funds from
the channel between B and A. So, intermediaries receive a fee
for relaying the transaction. It is worth mentioning that each
party can safely participate without worrying about losing their
funds as funds frozen in the channel are returned to the original
sender when the secret is not produced. Once the secret is
revealed, each involved intermediary would work to redeem its
payment from the previous channel before the time expiration.

B. Related works

Several efforts from both academia and industry have been
made to address the scalability issues in blockchains. These
efforts have targeted different aspects of blockchains start-
ing from ﬁnding alternative consensus algorithms, modifying
block size, sharding, DAG, Layer-2 protocols, etc. Continuous
and rapid developments in this research area have led to many
parallel as well as distinct branches of works. Many works
have attempted to systematize the knowledge in the rich body
of the literature.

Several works, such as [38, 39], survey scaling solutions
that directly engage with the fundamental building blocks
of the blockchains. Layer-2 scaling solutions remain out of
the scope of such surveys. Only a brief literature on the
survey of Layer-2 solutions exists; many of which focus on
creating a taxonomy. Authors in [40] classify Layer-2 solutions
along a few dimensions. However, their classiﬁcation omits
major protocols such as bisection protocols, commit chains,
and TEE (Trusted Execution Environment)-based solutions.
Similarly, the works [41, 42] focus on only popular Layer-
2 protocols. Authors in [43] discuss various categories of
Layer-2 protocols while the work [44] focuses primarily on
the network and routing aspects of Layer-2 solutions.

Our paper aims at furnishing a comprehensive guide for
Layer-2 protocols, starting with a much broader taxonomy, a
detailed explanation of each protocol, their salient features,
and their key concerns. To the best of our knowledge, our
work covers all the solutions present as of December 2021.

III. LAYER-TWO BLOCKCHAIN PROTOCOLS
In this section, we elucidate different Layer-2 protocol
along with their requirements, working procedures, salient
features, etc. In Fig. 4, we depict the taxonomy of different
blockchain scalability solutions at Layer-1 as well as Layer-2.
Here, a box represents a class/subclass while implementations
in a class/subclass are mentioned below respective boxes.
These protocols can be broadly categorized into four
classes,
i.e., channels, side/child chains, cross chains, and
hybrid solutions. We now describe each of the categories.

3

A. Channels

One of the key Layer-2 protocols to achieve scalability
along with privacy is channels. Channels enable any pair
of users to create private mediums for their transactions.
The main idea is to enable transactions to happen off the
main blockchain and yet maintain the same level of security
as an on-chain transaction. For transactions’ security, a set
of rules are predeﬁned and agreed between the participants.
Channels can be mainly classiﬁed into two main categories,
i.e., state channels and payment channels. State channels
(discussed in Section III-A1) are generalized versions while
payment channels (discussed in Section III-A2) are speciﬁc
to payment-oriented applications. For this reason, we show
payment channels in a branch nested from the state channels
in Fig. 4. Payment channels have been further improvised to
form a network and a hub.

1) State channels: A state channel [45] is a channel that
allows the exchange/transfer of states between two or more
participants. These states can represent any arbitrary applica-
tion (e.g., voting, auctions). Typically, a channel can be built
upon threshold signatures - often referred to as multisig - and
instructions for timelocks [130], where the participants sign
a multisig contract and lock in funds to participate in such
a transfer. In practice, state channels are established using a
smart contract as shown in Fig. 5. On these channels, the
states are exchanged among all the participants who enter the
branched-out channel of states. Once all the transactions are
complete, the participants commit the ﬁnal state of the channel
to the main chain via the contract.

Fig. 5. Typical lifecycle of a state channel.

Such a channel is especially useful when states are ex-
changed between the participants frequently because off-chain
state exchange is far more faster than on-chain exchanges.
Thus, state channels greatly improve the slow transaction rate
of parent blockchain.
Lifecycle: The typical lifecycle of a state channel consists of
establishment, execution, and termination phases. To establish
the channel, the participants ﬁrst lock some funds (or assets)
using a smart contract on the main chain. The sum of the
initially locked funds is the capacity of the established channel.
Before proceeding with execution the participants wait for the

Each participant lock in an amountonto a multisig smart contract toenter the state channel, branchingfrom the main chainChannel initializationAll parties agree to sign andpublish channel's final state viasmart contractMain ChainExchange of states in state channel4

Fig. 4. Taxonomy of blockchain scalability solutions.

conﬁrmation of fund locking on the main chain. Moreover,
the locked funds can not be used outside the channel. In
the execution phase, a transaction happens by an exchange
of states between participants. A transaction redistributes the
funds from the last agreed states. After exchanging states, the
involved participants sign and authorize the new states as valid
and true. This new state is then shared with other participants
and the order of states is logged. Next, a participant publishes
the ﬁnal state of the channel to the smart contract, which
veriﬁes the signatures. Now for the duration of a challenge
period, participants other than the publisher are allowed to
check if the state is correct. In case of dispute, one can
publish the appropriate ﬁnal state disapproving the previously
published state. All the other participants are informed about
it, and the challenge period restarts. Typically, the state with
the highest version number is considered the latest state. The

latest state is executed after the challenge period ends to reﬂect
each participants’ state.
State replacement: A transaction in state channels is essentially
equivalent
to replacing the old state with the new state.
State replacement should ideally happen once for transaction
ﬁnality. But to accommodate disagreements among partici-
pants about the new proposed state, some state replacement
techniques offer a dispute mechanism. Overall, there are four
main state replacement techniques:

• Replace-by-Incentive (RbI): The sender of a transaction
signs and announces a new state. The receiver needs to
countersign it to accept the announced state. The motiva-
tion of the receiver to accept the state is an incentive;
a higher incentive converts to higher chances of state
acceptance [30, 48, 131].

• Replace-by-Timelock (RbT): A state has an associated

Blockchain ScalabilitySolutionsLayer 1Layer 2Alternative Consensus AlgorithmsBlockdataShardingDAGCompact Block Relay (BIP 152) [8], SegWit [6], Txilm [7]Algorand [25], Bitcoin-NG [9], Casper [89], Ouroboros [90],  Permacoin [12], Sawtooth [14], scp [91], Spacemint [13]Aleph [102], Avalanche [28], Blockclique [103], Blockmania [104], Byteball [105], CAPER [106], CDAG [107],  Chainweb [108], Conflux [109], DEXON [110], DLattice [111], Eunomia [112], GHOST [113], Graphchain [114],  Haootia [115], Hashgraph [116], Inclusive [117], IOTA [29], JointGraph [118], Lachesis [119], Meshcash [120], Nano [121], Obyte [122], OHIE [123], PARSEC [124], Phantom [125], Prism [126], Spectre [127], StreamNet [128], Vite [129]Anon [92], Chainspace [26], Elastico [27], Harmony [93], Logos [94], Monoxide [95],  Omniledger [96], Ostraka [97], Rapidchain [98], SSChain [99], Stegos [100], Zilliqa [101]Hybrid SolutionsBisection Protocols Trusted ExecutionEnvironments Arbitrium [82] TrueBit [83] BITE [84] Teechain [85] Teechan [86] Tesseract [87] ZLite [88]Cross ChainsCeler [69]Connext [70] DeXTT [71]Loom [72]POA [73]Waterloo [74]Notary Schemes Blockchain ofBlockchains 0X [75]Tokrex [76]AION [77]ARK [78]Cosmos [79]Komodo [80]PolkaDot [81]Side/Child ChainsNon-custodialCommit Chains Plasma ChainsRollupszk RollupsOptimistic RollupsCartesi [60]Fuel Network [61]Offchain Labs [62]OMG Network [63]Optimism [64]Aztec 2.0 [65] Loopring [66] Starkware [67] zkSync [68]DAppChains [53]Liquid [54] Matic [55] SKALE [56]CustodialLiquidity Network [57] NOCUST [58] Polygon's PoS [59]ChannelsSprites [45]Trinity [46]State ChannelsPayment ChannelNetworksPayment ChannelsPayment Channel Hubs A2L [49]Bolt [50] Tumblebit [51] Perun [52] Lightning Network [33]OUTPACE [47] Raiden Network [48]timelock in terms of either absolute or relative blockchain
block height. As the blockchain’s block height increases
with time, the remaining timelock on a state decreases.
Before the expiry of timelock, a state can be replaced with
a newer state. Intuitively, a state with the lowest timelock
gets included in the blockchain before older states. Post
timelock expiry, the transactions represented in a state are
written to the blockchain and can not be replaced [32].
• Replace-by-Revocation (RbR): There might be a situation
where participants want to revoke a state submitted to the
blockchain. To do so, all the participants must together
propose a new state within a time window deﬁned by the
parent blockchain [33].

• Replace-by-Version (RbV): Here, the version of a state is
represented by an incrementing counter. A higher version
number means a newer state. So, a state with a higher
number can replace the older state [45, 52, 132–134].

RbI and RbT allow the latest state to be inserted into
the blockchain only once. The participants in RbR and RbV
can invalidate the submitted state via a dispute process of
presenting counter-evidence. The dispute process leads to
either a closure dispute or a command dispute. A closure
dispute proceeds towards closing the channel and resolving
the dispute exclusively on the underlying blockchain. After
the dispute is raised, the relevant parties provide evidences
within a ﬁxed time duration. At
the end of the evidence
submission step, any one of the participants processes the
evidences to resolve the dispute [52, 133]. Instead of closing
the channel, command disputes execute a set of commands on
the parent-chain to resolve disputes. After command execution,
the channel resumes its operation off-chain. The blockchain
provides a ﬁxed time duration to collect commands from the
participants and executes all the collected commands to ﬁnd
a resolution [45]. Some solutions [134, 135] extend dispute
process expiry time to support the execution of a large number
of commands. However, both the dispute resolution mecha-
nisms assume the relevant participants to be always online.
Watching services [132, 136–138] help participants subvert
the requirement of staying online by taking the responsibility
of observing disagreements.
Advantages: The main advantage of using state channels is
that all the exchanges happen inside the channel. Unlike main
chain transactions where each transaction is broadcast, state
channels only publish the ﬁnal states onto the parent-chain
offering more privacy. Instant transaction ﬁnality is another
advantage, i.e., as soon as all the participants authorize a state
update, transaction in that state can be safely considered ﬁnal.
Furthermore, state channels are very economical; especially
when state updates are expected to happen frequently between
participants. It is so as the cost of updating the states inside the
channel is cheaper compared to main chain transaction fees.
Limitations: State channels are not suggested for scenarios
where the participants are not ﬁxed, i.e., the participants come
and leave or whose addresses are not known. Essentially, all
the participants must open dedicated channels and be present
for state exchange to occur. Furthermore, the dispute process
induces an always online assumption. Watching services help

5

here, but such services increase the cost for the participants.
2) Payment channels: Enabling blockchains to support
(micro-) payments with near-instant conﬁrmation, fewer on-
chain transactions, and reduced fees has been one of the
major scalability goals [139–142]. Payment channels tailor
state channels for payment-speciﬁc applications. Initially de-
signed to support one-way payments [30], payment channels
evolved into bi-directional channels [32, 33] to empower each
participant to send and receive payments.
Lifecycle: Similar to state channels, the lifecycle of a pay-
ment channel comprises establishment, execution, and termi-
nation/dispute of the payment channel. The payer creates a
channel by setting an expiration time, a settlement delay, and
a public key to verify claims against the channel. The payee
checks if the parameters of the payment channel are suitable
for its speciﬁc requirements, e.g., destination, settlement delay,
channel ID, etc. Importantly, there can be multiple channels
between the same pair of participants. Thus, it is important to
check the attributes of a channel before initiating a payment.
The payer creates a signed claim for the required amount of
payment in the channel, which it sends to the payee as the
payment for goods or services. It is worth noting that this
communication happens “off-ledger” over a communication
medium suitable for the payer and payee. The payee veriﬁes
the claim to ensure that the claim amount is greater than or
equal to the total value of the services provided. At this point,
the payee can release the goods to the payer because the
payment has been assured. The payee is now free to redeem a
claim for the authorized amount at any point in time. As the
claim values are cumulative, redeeming the largest, i.e., the
most recent, claim is sufﬁcient for the payee to get the full
amount. A channel closure request can lead to two scenarios
depending upon whether some funds are still remaining in the
channel. If the channel has no funds remaining in it, then
the channel can close immediately. Otherwise, the request
to close the channel serves as an intimation to the payee to
redeem any outstanding claims by the end of settlement delay.
The channel expires after the settlement delay has elapsed
or the planned expiration time for the channel has arrived.
Further transactions can only close the channel, returning any
unclaimed funds to the payer. However, an expired channel
can last indeﬁnitely on the ledger in its expired state because
the ledger can not close it with a closure transaction.
Channel extensions: Payment channels help channel partici-
pants to avoid publishing every transaction on the main chain
and wait for subsequent conﬁrmations. Thus, the payments
are processed faster and ﬁnalized instantly. Fig. 6 shows a
typical bi-directional channel, where two participants transact
with each other in either direction after locking funds during
channel setup. Closing the channel reﬂects their respective
ﬁnal state on the main chain.

Such an approach is especially useful when the participants
frequently transact. However, there are some limitations asso-
ciated with the payment channels starting with the creation of
the channel. Setting up a channel requires locking funds exclu-
sively to the channel. The initial fund locking is also not instant
and requires conﬁrmation from the main chain. Moreover,
there must be a dedicated channel between the participants.

6

authors in [147] introduce a novel cryptographic primitive
for channel synchronization that is independent of the
parent blockchain’s scripting language, and therefore it
removes bottlenecks induced by scripts.

• Payment channel hubs [50–52] aim to further optimize
PCNs by introducing a special node called a hub. A hub
acts as the center of a star topology and relays payment
to connected nodes. The core idea here is to reduce rout-
ing overheads and funds locked by individual nodes in
PCNs [148]. Multiple inter-connected hubs in a network
can lead to reduced routing length, and consequently,
reduced routing cost and collateral cost at each channel.
However, the total funds required by a hub to lock can
grow signiﬁcantly with the increasing number of channels
and transaction volume. The situation can worsen when
the transactions ﬂow majorly in one direction, requiring
expensive and slow rebalancing operations [149].

• Channel extensions with intermediaries require interme-
diaries to actively participate in related transactions. Two-
party [150] and multi-party [151] virtual channels relax
such requirements. Virtual channels give an illusion to the
payer and payee of having a direct channel between them.
Virtual channels are established when all intermediaries
between the payer and payee lock funds for a ﬁxed time
duration. Setting up a virtual channel between a pair of
participants comes at the cost of installing a new virtual
channel for each intermediary, where each intermediary
must oversee its channels’ closure. The main advantage
of virtual channels is that channels can be created and
closed without blockchain interaction [151].

B. Side/Child chains

A side chain [152, 153] is an independent distributed ledger
running in parallel
to the main chain. Its primary goals
include reducing the load on the main chain by transferring
computationally heavy work off the chain. It also allows assets
to be transferred across different blockchains. A side chain
generally utilizes its own consensus mechanism (e.g., proof-of-
authority, proof-of-stake) to process transactions. Side chains
use a two-way bridge, called a two-way peg, to communicate
and exchange funds with the main chain (cf. Fig. 7). The
usability of any side chain depends on its ability to swiftly
exchange information with the main chain and quickly process
the transactions. Typically, side chains use custom block
parameters to process transactions efﬁciently. In what follows,
we explain the pegging mechanism used by side chains.
Lifecycle: The two-way peg mechanism allows funds to be
transferred between the main chain and side chain at a deter-
ministic exchange rate. Simpliﬁed Payment Veriﬁcation (SPV)
peg is used as the two-way peg. It starts with transferring
required funds in the main chain to a special output. Such
an output is unlocked by an SPV proof-of-possession inside
the side chain. The SPV proof contains a list of block
headers showcasing the proof-of-work and a cryptographic
proof as evidence (i.e., proof-of-inclusion) that the output was
indeed created in one of those blocks. SPV-based pegs enable
veriﬁers to conﬁrm the existence of the special output without

Fig. 6. A simpliﬁed lifecycle of a typical payment channel.

Therefore, such constraints limit the usage of payment chan-
nels for micropayments. Nevertheless, several solutions have
been proposed to improvise on payment channels, including
channel factories, Payment Channel Network (PCN), payment
channel hubs, and virtual channels.

• In channel factories [143, 144], many participants jointly
fund a factory. In particular, n participants jointly lock
funds in an n-party deposit, which is then used to
create payment channels for each pair of depositors.
to establish a direct
Whenever two participants want
channel between them, all depositors update the n-party
deposit to re-allocate funds for the new channel. The
advantage here is that there is no need to fund and set up
separate payment channels for each pair of participants.
Nonetheless, opening a factory via n-party fund locking
still requires conﬁrmation from the parent chain.

• Payment channels in their original form require partic-
ipants to have a direct link or channel between them.
Such requirement limits the potential, and to some ex-
tent scalability, of the payment channels. The reason is
the practicality (i.e., channel setup delay, locked funds
required, etc.) of having a direct channel with many, if
not all, participants. PCNs [33] help with the requirement
of having a direct channel by creating a network of
channels. PCNs have attracted a lot of attention from
both academia and industry. The idea behind PCNs is
that if A has a channel with B, who has a channel with
C. Then, PCN enables A to transact with C via B, i.e.,
A→B→C. B gets an incentive in terms of a small fee for
participating in such a transaction. PCNs primarily utilize
conditional payment constructions, such as HTLC (cf.
Section II-A) [32, 33]. The payer conditionally locks the
fund of a transaction such that the payee can redeem
the funds only if the locking condition is met. Another
parameter in this conditional lock is an expiry time, which
stimulates faster resolution of the lock by the payee as
well as intermediaries. Such conditional transactions must
be atomic in nature, meaning that either the transaction
should execute completely from the payer to payee or not
execute at all. This property helps in providing security
for the funds locked by the participating intermedi-
aries [49, 145, 146]. In HTLC-based solutions, the overall
amount of funds locked as collateral along the payment
path increases with the length of the payment path.
Furthermore, increasing payment length also increases the
time for which the funds are reserved. Authors in [45]
use a global PreimageManager smart contract to convert
a local channel dispute to a global problem, which helps
the
in reducing collateral

locking time. Alternatively,

Tx1Tx2TxnBABAChannel setupChannel close56AB56AB47AB65AB38AB3838A ⟶ B1 B ⟶ A2 A ⟶ B3 7

in a chain parallel to the main chain (as explained above) with
its own consensus mechanism and security assumptions. On
the contrary, the assets and their states are secured via smart
contracts on the main chain in non-custodial side chains. Two
major classes in non-custodial side chains are Commit (and,
Plasma) chains (discussed in Section III-B1) and Rollups (dis-
cussed in Section III-B2).

1) Commit chains: Channel-based solutions, such as PCN,
require participants to open dedicated channels, where funds
are locked within the channels and can not be reused elsewhere
unless withdrawn from channels; participants must remain
online for fund reception, etc. Commit chains [58, 154] were
introduced to address such issues present in channel-based
scalability solutions. As shown in Fig. 8, commit chains
employ a non-custodial operator that initializes and maintains
a commit chain while a smart contract prevents the operator
from misbehaving.

Fig. 8. An overview of commit chain operations.

Lifecycle: Participants willing to join the commit chain ﬁrst
register with the operator to get an account ID on the commit
the
chain. Participants lock funds via the smart contract;
operator reads and updates corresponding account IDs on the
commit chain. Recipients do not need to deposit any funds.
To transfer funds, the sender authorizes the operator to deduct
its account. The operator processes the transactions among
the participants off the chain. The operator also periodically
commits the latest state of participants’ account balances to
the main chain through the smart contract using constant-
sized checkpoints. The participants observe the checkpoints
and challenge the operator via the smart contract in case of
a dispute. The smart contract penalizes the operator if found
misbehaving, and it also halts the commit chain to recover
the balances from the last known stable checkpoint. Finally,
a participant can withdraw funds by submitting a withdrawal
request to the operator, or it can force exit with the help of
the smart contract to close and refund all its account IDs.
Advantages: Registering with a commit chain requires no on-
chain transaction. Though participants are advised to come
online periodically to observe checkpoints, they still receive

Fig. 7. A generalized view of side chains.

downloading the entire main chain. Synchronizing the two
chains involves a conﬁrmation period and a contest period.
The conﬁrmation period corresponds to the time required for
the ﬁnality of a transaction on the main chain that binds funds
to a special output (as mentioned above). After a ﬁnalized
SPF proof is created in the main chain, the funds reﬂect on
the side chain in a frozen state. The duration of such freezing
is referred to as the contest period, during which new proofs
can be published to contest the validity of the locked special
output. Contest period helps in preserving the integrity of fund
conversion between the main chain and a given side chain.

The funds inside a side chain can move within it without
any interaction with the main chain. However, funds remain
bonded to the parent chain and can not be transferred further
to other chains. Redeeming the funds from a side to the main
chain follows the same procedure, i.e., the funds from side
chain are locked to a special output, which is then spent using
the corresponding SPV proof on the main chain.
Advantages: Side chains act as secondary blockchains that
provide diverse features and ﬂexibility to their main chains.
A side chain has its own independent consensus protocol, and
it can control the block parameters. Hence, the transactions on
side chains are typically executed faster as compared to main
chains. Such processing capabilities also help in reducing the
load on the main chain via transaction ofﬂoading. Side chains
are permanent that can keep running. A new participant can
join the same side chain. In contrast, adding participants to the
state channel network requires creating a new state channel
for each participant. Finally, any compromise or damage
remains conﬁned to the side chain only, leaving the main
chain unaffected. Such an attribute can be utilized for testing
applications before their deployment to the main chain.
Limitations: A two-way pegged side chain is slower in execu-
tion as a participant needs to wait for a conﬁrmation period as
well as a contest period to access the funds on either chain.
Another concern is the centralization of mining power on
side chains, especially on newer ones. The initial investment
required to stabilize the mining process of a side chain and
its interoperability with different blockchains constitute the
bottleneck of its success. Moreover, the security of funds in a
side chain is handled by the side chain. Thus, disputes in side
chains are local that can not be resolved in the main chain.

Side chains can be classiﬁed into two categories, namely,
custodial and non-custodial. Custodial side chains move assets

Each side chain has its own consensus mechanism2-way peg bridgeSide ChainPeg inPeg out Main ChainMaintains commit chain Periodic updatesRead checkpoints,   exit,   depositDispute challengePrepare latest stateof all user accounts Refute challengeMain ChainDisputeRegister, transact,withdrawReadfunds while being ofﬂine like any on-chain transactions.
Without collateral from an operator, commit chains offer
eventual ﬁnality. Such an attribute is useful from the operator’s
perspective. However, an operator may also choose to insure
transactions by staking collateral to provide instant ﬁnality.
Unlike typical side chains, a commit chain is dependent on
its parent chain’s consensus mechanism, which provides it the
same level of security as its parent chain.
Limitations: Although the non-custodial operator is kept in
check by the smart contract, it is still the single point of
failure. Another issue is that the participants should maintain
the commit chain data, which is not published on the parent
chain while creating checkpoints, to challenge the operator and
exit the commit chain [58].
Plasma chains: Another related concept is Plasma [155] chain.
Plasma chains have critical limitations and issues compared to
commit chains. Hence, we brieﬂy explain its key concept and
concerns. We refer the interested readers to the work [155]
for a detailed description. Commit chain implementations,
such as NOCUST [58], are account-based systems. Plasma
chain proposes a UTXO-based ledger system running over
an account-based blockchain, e.g., Ethereum. Plasma enables
multiple blockchains to exist as branches of a tree with the help
of a series of smart contracts. Each branch (i.e., blockchain)
can have sub-branches (i.e., child chains). Each Plasma chain
maintains its own block validation mechanism, which can be
independent of its parent chain. However, all computations
in the hierarchy of chains are globally enforced/dependent on
one single root chain. Plasma chains suffer from several issues,
such as steadily growing data storage costs, high computation
requirements, and no native support for instant ﬁnality.

2) Rollups: Rollups are non-custodial side chain solutions
that aim at reducing the load on the main chain. Rollups
employ data compression techniques along with a smart con-
tract for scaling Layer-1 chains. The concept is analogous
to Plasma chain, except Rollups retain minimal data (in the
form of a Merkle root) on-chain about state updates. Such
data facilitate on-chain veriﬁcation and faster withdrawals.
The transactions execute off the chain in batches and are
bundled together for on-chain veriﬁcation. In particular, the
smart contract maintains the Merkle root (referred to as
state root, cf. Fig. 9) on-chain from the current state (e.g.,
individual balances) of the Rollup. The same root can also be
computed/veriﬁed from the data available on-chain. However,
the Merkle tree is not stored on-chain to save space. A new
state root is computed after a batch of transactions induces
balance updates. Anyone can publish the batch by including
the transactions in a compressed form, the previous state root,
and the newly computed state root. If the current state root
in the contract matches the previous state root mentioned in
the new batch, the contract updates its state root to the new
state root. If a batch requires external inputs (or outputs), the
required funds are transferred to the contract before processing
(or sent to outputs after processing) the transactions.

8

Fig. 9. An abstract presentation of Rollups.

Since anyone can publish the batch of transactions, the
process of preventing frauds and verifying the new state root
leads to two types of rollups, namely Optimistic and Zero-
Knowledge (zk) Rollups.

• Optimistic Rollups: Such Rollups take an optimistic
approach and assume that transactions are valid unless
challenged. Thus, no computation for veriﬁcation is done
by default to signiﬁcantly improve scalability. However,
the contract maintains a history of state root updates
along with corresponding batch hashes. Challenging a
batch requires publishing a proof of incorrect computa-
tions (called fraud proofs) on-chain, which is veriﬁed by
the contract. Upon veriﬁcation, the contract reverts the
incorrect batch along with all subsequent batches.

• zk Rollups: Contrary to Optimistic Rollups, zk Rollups
suspect every transaction. Every batch contains a crypto-
graphic proof (called validity proof), which proves that
the new state root indeed matches the output of executing
the batch of transactions. Such proofs are constructed us-
ing zk-SNARK and PLONK protocol [156]. Computing
validity proofs is complex, but their on-chain veriﬁcation
happens quickly.

Advantages: Rollups use compression to reduce transaction
footprint on-chain that saves space and scales the Layer-1
chain. Another key advantage is their ability to bypass the
data availability problem [157] with fraud proofs. Optimistic
Rollups are suitable for general-purpose computations while
zk Rollups are ﬁt for simple payment scenarios.
Limitations: The net
throughput of Optimistic Rollups is
limited. On another side, the cost and complexity of computing
validity proofs for zk Rollups are high.

C. Cross Chains

A huge number of fundamentally different blockchains -
in terms of consensus, goals, features, etc. - emerged after
the success of the Bitcoin blockchain. Apart from scalabil-
ity, another major issue with a multitude of blockchains is
interoperability. Interoperability not only propels application

Main ChainOn-chainRollup contractTransaction datatransferredTransaction datatransferredState root: 0x123456State root: 0x678901InitializeCurrent state root: 0x123456234A⟶B; A⟶C; B⟶CTransaction batchNew state root:  0x678901Prev. state root: 0x1234560x123456A:10B:20C:30D:400x678901A:5B:18C:37D:40portability and ﬂexibility further, but
in
improving blockchain scalability by ofﬂoading transactions
from one blockchain to another [158].

it can also assist

Cross chains are used to transfer assets between differ-
ent blockchains. Basically, they facilitate a communication
medium between different independent blockchains. Different
blockchains have different consensus mechanisms. Transfer-
ring assets between a blockchain with weak consensus to a
blockchain with strong consensus can lead to potential safety
risks. Cross chains help in establishing a mutual trust proce-
dure between users on different blockchains who are interested
in swapping assets. In essence, cross chains act as the inter-
mediary platform for inter-blockchain transactions [159, 160].
Celer Network [69] employs a layered architecture with
clear abstraction for quick development of generalized state
channel as well as side chain suites to support rapid off-chain
state transition. Celer network sits between the blockchain and
the decentralized applications (“dApps”). Its main component,
is an off-chain technology that supports different
cStack,
blockchains. cStack consists of three main components: cCha-
nnel, cRoute, and cOS. cChannel comprises generalized state
channels for transactions. cRoute handles routing. cOS is the
core component that handles several tasks including resolving
dependencies between on-chain and off-chain states, node fail-
ures, and uniﬁed implementations of on-/off-chain modules.
Celer network aims to bring Internet scale to every blockchain
while supporting high availability and stable liquidity. Other
earlier cross chains are based on HTLC [71], relays (or, side
chains) [73, 74], smart contracts [70]. However, there are two
state-of-the-art approaches to realize cross chains, i.e., notary
scheme [75, 76] and blockchain of blockchains [77–81].

1) Notary schemes: A notary is an entity that actively ob-
serves multiple blockchains and listens for transaction events,
such as smart contract execution on a chain. It creates a
transaction in a chain when a corresponding event happens on
another chain. Crypto exchanges, e.g., Binance and Coinbase,
are examples of such notary schemes. In practice, exchanges
maintain order books to match sellers and buyers. Here, two
distrusting parties form an agreement indirectly through the
notary. Exchanges that handle and execute trades on behalf
of a customer - by holding the customer’s private keys - are
centralized exchanges while typical decentralized exchanges
only offer match-making services. Decentralized exchanges,
such as 0x [75], take a smart contract-based approach (called
automated market makers) to constitute a real-time price-
adjustment system that replaces the on-chain order books.

2) Blockchain of blockchains: A blockchain of blockchains,
or simply the Internet of blockchains, prioritizes customiz-
ability along with interoperability. The general idea here is
to build an ecosystem, where independent blockchains can
share data and/or tokens with each other via a backbone
chain. The backbone chain only facilitates a platform for inter-
chain communication programmatically and does not act as
the central entity. The customizability perspective emphasizes
shortening the blockchain development cycle from years to
months [79]. To summarize, a blockchain of blockchains
provides a platform for reusing network, data, incentive, con-
sensus, and layer of contracts to tailor customized, application-

9

speciﬁc, interoperable blockchains. Two prominent solutions
in this domain are Cosmos [79] and Polkadot [81].

Cosmos creates a decentralized network of independent
blockchains. These blockchains are called “zones”, where each
zone can have its own constraints on its assets. To enable trans-
actions between zones, Cosmos follows a bridge-hub model.
There are multiple hubs present in the network, and each hub
can connect multiple zones. Hubs help in reducing the number
of connections required to connect different zones. Registering
with a hub enables a zone to communicate with all the other
zones connected via this hub. Zones communicate with each
other only via hubs using Cosmos’s Inter-Blockchain Com-
munication (IBC) protocol. A hub acts as a mutually trusted
intermediary that enables zones to share updates regarding
their states with other zones. Polkadot introduces globally
coherent dynamic data structures called “parachains” hosted in
parallel while the main chain is called the “relay” chain. State
transition validation is performed by relay-chain validators.
Polkadot deﬁnes Cross-Consensus Message Format (XCM)
and Cross-Chain Message Passing (XCMP) for inter-parachain
communication. Polkadot supports connecting hundreds of
parachains directly to the relay chain, but only for a short to
medium-term. Long-term connections and nested parachains
are still under development. A detailed comparison of different
cross chain solutions can be found in work [158].

D. Hybrid solutions

Hybrid solutions help in further improving the scalabil-
ity of off-chain protocols. These solutions are called hybrid
because they change a few fundamental properties of off-
chain solutions. We identify two categories of such solutions,
where one aims to reduce on-chain dependence of dispute
resolution mechanisms while the other uses secure execution
mechanisms to eliminate trust requirements among peers. The
former category is called bisection protocols (discussed in
Section III-D1) while the latter (explained in Section III-D2)
is implemented using Trusted Execution Environments (TEE).
1) Bisection protocols: Existing dispute resolution mecha-
nisms in off-chain solutions typically execute on-chain. Thus,
these solutions are not purely off-chain, at least from the dis-
pute handling perspective. Bisection protocols form a branch
of Layer-2 solutions that primarily aim at
improving the
dispute resolution mechanism. These protocols take part of the
computations off-chain, thus helping to reduce the load on the
main chain. Generally, bisection protocols involve two steps.
First, a user presents minimal evidence to a veriﬁer to testify
the validity of its transaction. Next, when users contradict each
other, a veriﬁer inspects evidence from contradicting users to
determine the correct state. Truebit [83] and Arbitrum [82]
employ such dispute resolution mechanisms.

Truebit was introduced as a blockchain enhancement to
improve the computational efﬁciency of smart contracts at a
reduced cost. It ports computations from the main chain to
the off-chain. Truebit depends on judges, who have limited
computational power. These judges are mutually trusted by
all the participants. Given a computational problem, the user
who solves it, called the solver, publishes the solution as well

as the sub-problems used to reach the solution. A challenge
period is set aside during which other users can challenge
the published solution - such a user is called a challenger.
If a challenge is raised, the judges solve the sub-problems
recursively using binary search; this is to reduce the problem
size by half in each iteration. The solution provided by the
judges is mutually agreed to be the correct solution by all
participants. The judges compare their correct solution with the
solutions provided by the solver and the challenger to identify
and penalize the cheating participant.

On another side, Arbitrum uses a Virtual Machine (VM) to
implement a smart contract. A user can create a VM and desig-
nate other users as VM managers. An honest manager enforces
the VM to follow VM’s coded functionality. Any change in
the state of the VM has to be approved by all the managers.
There might be scenarios where managers do not agree with
each other about the state of the VM. Such disagreements
should be raised within a challenge period after a new state
has been committed. In case of a conﬂict among the managers,
the veriﬁers/miners invoke a bisection protocol to reduce the
conﬂict down to single-instruction execution. Now, managers
present their outcome for that single-instruction execution.
The veriﬁers can verify the presented outcomes efﬁciently to
identify and punish the cheating participant.

2) TEE-based solutions: A trusted execution environment,
e.g., Intel SGX [161, 162], is typically an isolated and safe-
guarded area inside a CPU, where the integrity and conﬁden-
tiality of loaded data are protected. TEE-based solutions for
blockchain scalability utilize integrity protection offered by
TEEs to eliminate the on-chain collateral used for establishing
trust among participants. In fact, TEE is used as a mutually
trusted entity in such solutions because they offer a higher
level of security for application execution.

Teechan[86] uses TEEs to enable two mutually distrusting
nodes to transact with each other. Here, a channel is set up
between the two nodes by exchanging secrets via their TEEs.
As long as the channel
the nodes can exchange
is open,
funds with each other in a peer-to-peer manner using TEE-
supported operations; even without involving the parent Bit-
coin blockchain. The TEEs bear the responsibility to maintain
and update the channel’s state securely throughout the chan-
nel’s lifetime. Upon channel termination, the TEEs create a
Bitcoin transaction to be added to the parent chain. During
the entire lifetime of such a channel, only two transactions are
reﬂected on-chain; one for channel establishment using a 2-of-
2 multisig Bitcoin address and the other for channel closure.
To summarize, Teechan reduces the load on the parent chain
and increases transaction throughput among distrusting nodes.
is another such solution that executes
off-chain transactions asynchronously with the main chain.
Teechain employs TEE-protected treasuries to preserve the
correct channel state. Teechain forms a chain of committee that
holds replicated states of treasuries to handle treasury failures.
Some other prominent solutions leveraging features of TEEs
are Tesseract [87], BITE [84], and ZLiTE [88]. Tesseract is
a TEE-based cryptocurrency exchange, BITE focuses on the
privacy of Bitcoin lightweight clients, and ZLiTE improves
the privacy of Zcash lightweight clients by involving TEE-

Teechain [85]

10

equipped servers. Nevertheless, all TEE-based solutions rely
upon the integrity of the TEEs while TEEs have their own
vulnerabilities and concerns [163, 164].

IV. NETWORK ISSUES

Layer-2 protocols are built on top of Layer-1 blockchains.
Enabling participants to transact with each other off the chain
may require an overhead communication network to help, for
instance, ﬁnding a payment path between participants that do
not have a direct connection. Routing, re-balancing, stability,
and privacy are the key concerns related to such overhead
networks. We take the example of channel-based solutions to
brieﬂy discuss these issues. We refer the interested readers
for an in-depth analysis of network
to works [43, 44]
management issues and a comparison of routing algorithms.

1) Routing: For a transaction to occur between distant
participants in a network, a payment path must be estab-
lished from the payer to the payee involving intermediate
nodes. Deciding such a payment route involves various factors,
i.e., inter-node channel capacity, length of the route, cost-
effectiveness, and availability of the nodes participating in
the transaction. Several works on routing algorithms have
attempted to ﬁnd the most efﬁcient path for the transactions.
These routing algorithms can be broadly classiﬁed into two
categories, namely, global routing (e.g.,
[165] and Di Stasi
et al. [166]) and local routing (e.g., SilentWhispers [167] and
SpeedyMurmurs [168]). The source of the payment in global
routing makes use of the global view of the network to ﬁnd the
optimal path. The performance of such source routing depends
on the accuracy of the available global view. By pre-computing
paths, these routing algorithms attempt to minimize the overall
communication overheads and latencies. However, their scala-
bility is limited by the cost of maintaining an accurate global
view and path computations on the source. On another side,
local routing algorithms utilize the local information and take
a greedy approach. Local routing algorithms are inherently
scalable but are less efﬁcient due to local optimizations.

2) Re-balancing: Exhaustion of capacity in payment chan-
nels is a recurring problem. A naive and inefﬁcient solution
is to close the channel and refund it, which results in at
least two transactions. Protocols like REVIVE [149] allow
nodes to safely rebalance their skewed channel with the
help of funds available in their other existing channels. An
untrusted third party, called a leader, is elected to execute the
channel rebalancing process. After receiving nodes’ requests
and preferences, the leader coordinates with the nodes to freeze
relevant channels. The frozen channels are now rebalanced
using linear programming and commitments signed by all the
nodes. After the process, the nodes lose funds from their one
or more payment channels to gain equal funds on the others.
Initial Layer-2 solutions, par-
ticularly channel-based, require participants to remain on-
line to monitor transactions and handle disputes. To address
such a limitation, participants can engage watchtowers to
detect discrepancies on their behalf while they are ofﬂine.
Watchtowers get a fee for their services. On the contrary,

3) Stability and privacy:

watchtowers are penalized from their collateral for failing to
report disputes [176]. A key concern with watchtowers is that
a watchtower may be bribed to cheat its customers for mutual
gains. If the bribe is higher than the collateral, the watchtower
may act dishonestly. On another side, routing payments over a
network of nodes may lead to privacy issues, such as disclosing
information about the payer and payee. Malovolta et al. [145]
attempt to formally deﬁne the privacy requirements over PCNs
and implement Fulger and Rayo using Multi-Hop HTLC smart
contract to handle transaction concurrency. However, a routing
protocol that learns the capacity of payment channels over a
period of time can bypass their privacy notions.

V. SECURITY AND PRIVACY ISSUES

In this section, we discuss the security and privacy attacks
on different Layer-2 protocols. TABLE I presents a summary
of all such attacks present in the literature. We clarify their
setup requirements, impact, affected parties, and key preven-
tion/mitigation techniques.

A. Wormhole attack

Wormhole attack [147] steals rewards of PCN intermedi-
aries. A payment is typically relayed through multiple inter-
mediaries in PCN since a direct channel may not exist between
payer and payee. In such a scenario, the intermediaries are
aware of their immediate neighbors and may not be aware
of other nodes on the path, sometimes even about the payer
and payee. An attacker with just two malicious nodes on the
path from the payer to payee can launch wormhole attack. The
name wormhole denotes how the funds are rerouted through a
wormhole channel between the malicious nodes of the attacker.
In PCN, the payment is locked in a cryptographic lock, i.e.,
HTLC (cf. Section II), which is routed to the payee. Each
intermediate node that relays the payment retains a small fee,
which is the difference between the amount it will receive
from the channel with the previous node and the amount it
will pay to the channel with the next node. Once the payee
reveals the key to the lock, it is routed back to the payer. While
the key travels back to the payer, it sequentially unlocks funds

11

in the channels on the path. However, a malicious node can
bypass the key to another malicious nodes, skipping all the
nodes/channels between these two malicious node. As a result,
the benign nodes assume that the transaction has failed, and
they return to their original state while the malicious nodes
steal the reward from the benign nodes.

Fig. 10. Wormhole attack stealing rewards of intermediaries.

Fig. 10 depicts a scenario for wormhole attack. For higher
impact, the attack requires the malicious nodes to be closer
to the sender (S) and receiver (R). To make a payment from
S to R, S locks the original payment amount along with the
total reward, i.e., the sum of fees for all intermediaries. Out of
all the nodes which agreed to participate in the payment, two
nodes A1 and A2 are malicious nodes. When R reveals the
HTLC secret to A2, it pays the original payment amount to R.
Now A2 bypasses the HTLC secret to A1. A1 uses the HTLC
secret to receive the sum of the original payment and the total
reward. Thus, A1 and A2 stole the rewards by colluding and
bypassing the intermediate nodes, which will return to their
original state assuming that the transaction has failed.
Countermeasures: The main reasons behind wormhole attack
are: (1) the same HTLC secret
is used to unlock funds
from each channel on the payment path, and (2) each chan-
nel can be unlocked independently. Anonymous Multi-Hop
Lock (AMHL) [147] communicates path-speciﬁc secret infor-
mation to nodes and makes locks interdependent to ensure that
the funds are unlocked only in a hierarchical manner.

B. Flood and loot

Flood and loot [169] is a systemic attack on the Lightning
network. The attacker controls two nodes in the network,
where one node acts as the source of the payment while the

TABLE I
A SUMMARY OF MAJOR ATTACKS ON Layer-2 SOLUTIONS.

Attack

Impact

Affected parties

No. of adversary
nodes needed

Wormhole [147]

Intermediaries’
frozen;
transaction processing reward is stolen.

incurs a loss of useful

temporarily
time;

funds

are

Flood
and loot [169]

Attacker claims disputed transaction; ex-
ploits replace by fee policy.

Grieﬁng [37]

Time dilation [170]
(eclipse)

Network stalling; capacity exhaustion; may
incur channel force-closing fee; eliminating
competitors from the network.
Victim isolated from the network; feeds
blocks to the victim at a slower rate; funds
can be stolen.

Balance
lockdown [172]

Adversary gets a dominant position; blocks
the victim’s ability to act as an intermediary.

All nodes along the path
between adversary nodes.

All nodes that agree to
open a channel with at-
tacker’s source node.

All nodes participating in
the payment path towards
the attacker.
Primarily, trust-minimized
Bitcoin light clients with
limited connections.
Middle nodes in multi-hop
payments. Typically, it tar-
gets a single node that re-
lays many payments.

Balance
discovery [173, 174]

Balance between a pair of victim nodes
disclosed; nodes’ privacy compromised.

The pair of nodes targeted
by attacker.

Congestion [175]

No monetary gains; stalls or paralyzes net-
work; DoS affects competitors’ gains.

All nodes participating in
the transaction between
attacker’s source and des-
tination node.

Two

Two

One

Multiple

One

One

One

Setup and launch

Key prevention/mitigation approaches

Adversary sets up an additional round of communi-
cation to share and bypass the HTLC secret.

Adversary establishes several channels through vic-
tims and sends a multitude of payments. While set-
tling payments attacker’s source node forces victims
to create several blockchain transactions all at once.

Adversary refuses to resolve payments off-chain,
locking victims’ funds for entire duration of contract.

Adversary deploys hundreds of Sybil nodes, opens a
payment channel with the victim, then eclipses/time-
dilates the victim.

AMHL offers interoperable, secure, and privacy-
preserving cryptographic construction that works in
both script-based and scriptless.
Reduce the maximum number of unresolved HTLCs;
allow more time (blocks) to claim HTLCs on the
blockchain; use anchor commitment output; use non-
replaceable HTLC transactions.
Limit the number of incoming channels; faster HTLC
resolution; constant payment
incentiviz-
ing/punishing nodes; grieﬁng penalty.

locktime;

Increase adoption of BIP 157 [171]; anonymize peer-
to-peer protocols; engage watchtower.

Adversary aims to disrupt the availability of a victim,
opens a channel with the victim, sends self-destined
payments that go and come back via the victim.

Increase AER to reduce attack proﬁtability; reduce
the maximum length of a route; minimize/forbid
loops in a payment route.

Adversary opens a channel with one of the two
victim nodes. It tries to disclose the balance between
victims by routing invalid payments. The value of
payments typically follows a binary search pattern.

Adhere to protocol speciﬁcations and prevent pay-
ments with values higher than maximum allowed
limits; clients should resist closing a channel upon
receiving malformed payments.

Adversary overloads channels with unresolved re-
quests to block high liquidity channels and discon-
nect/isolate individual/pair of nodes.

Avoid paths with loops; enforce fast HTLC res-
olution; reduce route length; limit the number of
maximum concurrent payments.

RSWormhole tunnelA1A2Amount sent +total rewardsAmount sentRewards of all intermediariesbetween A1 and A2 stolenA2 passesHTLC secret to A1other node is the destination of the payment. Nodes that partic-
ipate in forming channels between source and target nodes are
affected by ﬂood and loot attack. The key idea of the attack
is to trigger closing of multiple channels simultaneously. In
such a scenario, the victim nodes can only resort to the parent
blockchain to claim their funds locked into corresponding open
HTLCs. Thus, victim nodes benignly overload the blockchain,
which opens a window of opportunity for the attacker to steal
the funds. In particular, the attack leverages the replace-by-fee
policy [177] employed in the Bitcoin blockchain.

The attacker’s source node opens multiple channels through
the victim nodes to the attacker’s target node. The attacker
initiates multiple HTLC payments from the source to target
node, accepts these payments at the target node, but refuses
to resolve them at the source node. As the timeout for HTLCs
approach, victims are compelled to close the channels with
the source node and claim open HTLCs on the blockchain.

(a) Establishing channels

(b) Excessively loading channels with HTLCs

(c) Resolving payments on the last hop

12

nodes. It is worth mentioning that a given victim can be
participating in multiple distinct paths from source to target,
which is much worse for such a victim node (see Fig. 11(a)).
Now, source node commences (preferably when blockchain
fees are low) multiple HTLC payments to the target node
using the channels previously created (see Fig. 11(b)). The
aim is to use as many channels as possible with maximum
funds utilization. Next, the target node acts honestly, reveals
the secret to the victim node, settles HTLC, and gets the
payment (see Fig. 11(c)). The victim nodes forward the
secret to the next node in the chain, which is source node
in this case. Source node refuses to respond, leaving open
HTLCs in the channels (see Fig. 11(c)). As the timeouts
for HTLCs approach,
the victim node tries to close the
channels with the source node to claim all open HTLCs
on the blockchain. Consequently, numerous transactions to-
wards the parent blockchain are induced simultaneously (see
Fig. 11(d)). Not all transactions will enter the blockchain due
to congestion. At the same time, the replace-by-fee protocol
will allow transactions offering higher fees to replace other
conﬂicting transactions. Thus, the attacker raises the fee for
his transactions to exceed those of the victims to claim the
funds using replace-by-fee policy.
Countermeasures: There are two prominent countermeasures
for this attack. The ﬁrst one is to limit the maximum number of
HTLCs that can remain unresolved at any point in time. This
limitation will decrease the number of transactions competing
to include in the blockchain in a given window of time. So, the
attacker will require more victims to trigger the race conditions
necessary for the attack. The second one is to use reputation
scores, where channel opening requests from unknown coun-
terparts is given a lower priority, which reduces the scope
of locking larger funds in such channels. Another solution is
to use anchor commitment output [178] that manipulates the
way transaction fees are paid. However, anchor outputs remain
ineffective for an attacker with sufﬁciently large capital.

C. Grieﬁng attack

Unlike most of the other attacks on Layer-2 protocols,
grieﬁng attack [37] is not directly motivated by stealing funds
or information. It instead focuses on stalling payment networks
by exhausting the channel capacity. It steals useful time of
benign participants by preventing them from processing further
transactions, which eventually leads to temporal loss of funds,
decreased network throughput, and routing disruption.

(d) Waiting for all HTLCs to expire (approx. the same time) and collecting
unspent outputs

Fig. 11. Different stages of a ﬂood and loot attack.

Fig. 12. Grieﬁng attack to stall network and participants.

Importantly, a node can become a victim of ﬂood and loot
attack only if it opens a channel with the attacker’s source
node. Fig. 11 depicts the different steps of a simpliﬁed ﬂood
and loot attack. In the ﬁrst step, the attacker establishes a
number of channels from source node to target node via victim

Fig. 12 illustrates a representative grieﬁng attack setup,
where A is transferring p funds to B over a payment path
A→D→C→B, and each intermediate node charges a process-
ing fee p(cid:48). A forwards a conditional payment to D using an
off-chain contract, where it locks p + 2p(cid:48) funds for a time

Attacker'ssource nodeBalance:  1-δ,  δWaiting for all HTLCs to expire, approx. thesame time, and collecting unspent outputsVictimAttacker'starget nodeBalance: 0, 1Attacker'ssource nodeReplace by Feetakes placeHTLC 1HTLC n...Flood and lootPreimagesreturnedAttacker ignores returned preimage HTLCs nearing timeoutBalance: 0, 0Unresolved: 1Resolving payments on the last hopVictimAttacker'ssource nodeAttacker'starget nodeBalance: 0, 1XBalance: 0, 0 Unresolved: 1Excessively loading channels with HTLCsVictimAttacker'starget nodeBalance: 0, 0Unresolved: 1Attacker'ssource nodeHTLC 1HTLC n...HTLC 1HTLC n...Balance: 1, 0Establishing channelsVictimAttacker'ssource nodeAttacker'starget nodeBalance: 1, 0Attacker'ssource nodeBalance:  1-δ,  δWaiting for all HTLCs to expire, approx. thesame time, and collecting unspent outputsVictimAttacker'starget nodeBalance: 0, 1Attacker'ssource nodeReplace by Feetakes placeHTLC 1HTLC n...Flood and lootPreimagesreturnedAttacker ignores returned preimage HTLCs nearing timeoutBalance: 0, 0Unresolved: 1Resolving payments on the last hopVictimAttacker'ssource nodeAttacker'starget nodeBalance: 0, 1XBalance: 0, 0 Unresolved: 1Excessively loading channels with HTLCsVictimAttacker'starget nodeBalance: 0, 0Unresolved: 1Attacker'ssource nodeHTLC 1HTLC n...HTLC 1HTLC n...Balance: 1, 0Establishing channelsVictimAttacker'ssource nodeAttacker'starget nodeBalance: 1, 0Attacker'ssource nodeBalance:  1-δ,  δWaiting for all HTLCs to expire, approx. thesame time, and collecting unspent outputsVictimAttacker'starget nodeBalance: 0, 1Attacker'ssource nodeReplace by Feetakes placeHTLC 1HTLC n...Flood and lootPreimagesreturnedAttacker ignores returned preimage HTLCs nearing timeoutBalance: 0, 0Unresolved: 1Resolving payments on the last hopVictimAttacker'ssource nodeAttacker'starget nodeBalance: 0, 1XBalance: 0, 0 Unresolved: 1Excessively loading channels with HTLCsVictimAttacker'starget nodeBalance: 0, 0Unresolved: 1Attacker'ssource nodeHTLC 1HTLC n...HTLC 1HTLC n...Balance: 1, 0Establishing channelsVictimAttacker'ssource nodeAttacker'starget nodeBalance: 1, 0Attacker'ssource nodeBalance:  1-δ,  δWaiting for all HTLCs to expire, approx. thesame time, and collecting unspent outputsVictimAttacker'starget nodeBalance: 0, 1Attacker'ssource nodeReplace by Feetakes placeHTLC 1HTLC n...Flood and lootPreimagesreturnedAttacker ignores returned preimage HTLCs nearing timeoutBalance: 0, 0Unresolved: 1Resolving payments on the last hopVictimAttacker'ssource nodeAttacker'starget nodeBalance: 0, 1XBalance: 0, 0 Unresolved: 1Excessively loading channels with HTLCsVictimAttacker'starget nodeBalance: 0, 0Unresolved: 1Attacker'ssource nodeHTLC 1HTLC n...HTLC 1HTLC n...Balance: 1, 0Establishing channelsVictimAttacker'ssource nodeAttacker'starget nodeBalance: 1, 0Locked p+2p' funds for t+2t' timeLocked p+p' fundsfor t+t' timeLocked p funds for t timeADCTime's up! Still not respondedBperiod t + 2t(cid:48). Here, t(cid:48) indicates the deadline for conﬁrmation
time for on-chain settlement. D forwards the payment to C
using another off-chain contract locking p+p(cid:48) funds for a time
period t + t(cid:48). C forwards the payment to B using another off-
chain contract locking p funds for a time period t. In order to
claim p funds from C, B must resolve the payment within time
period t. Otherwise, C can claim a refund on-chain by closing
its channel with B; similar procedures to be followed by D and
then A. Nevertheless, C can go on-chain only after its contract
with B expires. As a result, B can block O(p) funds in each of
the preceding contracts for a time period t without losing any
funds. It is worth mentioning that the order of t can be days
for genuine users’ convenience. Thus, each of the involved
nodes can not utilize their funds for the entire duration of t.
The attacker can stall the network by simultaneously launching
multiple grieﬁng attacks from its single or multiple nodes.
Countermeasures: Apart from limiting the number of incom-
ing channels, faster contract resolution, and constant payment
locktime, incentivizing/punishing nodes is a crucial way to
tackle grieﬁng attack. Grieﬁng penalty [179] maneuvers along
the same idea, which punishes the attacker to pay a penalty
for compensating the victims’ lost time. This way it prevents
nodes from ever attempting to participate in such an attack.

D. Time dilation/eclipse attack

Time dilation attack [170] dilates a victim’s clock. As a
result, the victim always remains late in becoming aware of
the new blocks in the chain. In other words, the victim misses
updates from the network and keeps on working with outdated
information. To this end, the attacker eclipses a victim node
such that it cannot participate in the network owing to the
delayed block delivery. Although time dilation attack is an
expensive attack, it yields high returns in the form of stealing
the total channel capacity in a single eclipse period. Authors
in [180, 181] propose channel exhaustion and node isolation
attacks along similar avenues. For the sake of brevity, we
discuss only the time dilation attack.

Fig. 13. Eclipse attack where attacker dilates a user.

Fig. 13 depicts multiple malicious nodes eclipsing a victim
node. Typically, such an attack focuses on a single victim
node. Essentially, eclipsing a user means preventing it from

13

observing current network activities or state and cutting its
communication with other honest users. To do so, the at-
tacker must occupy every connection a victim can have using
pseudonymous nodes with pretend identities. After eclipsing
a victim, the attacker induces time dilation by introducing
a delay between the time it receives a block to the time it
will feed the block to the victim node. Time dilation attack is
commonly seen in Lightning networks and can be classiﬁed
- based on the target of the attack - into the following three
main categories:

• Target channel’s state ﬁnalization: It pushes the victim’s
observed block height several blocks behind the tip of
the main chain,
typically by negotiating a new state
committed to an outdated chain state.

• Target per-hop delay: Once the attacker gets ahead of
the victim’s block height by dilation, it routes a payment
through the victim, and at the same time ﬁnalizes the state
of their channel onto the blockchain. It stops the victim
from renegotiating through preimage disclosure, leaving
no option and funds with the victim.

• Target packet ﬁnalization: When a victim node knows
the preimage for an incoming contract, but the remote
peers do not respond on time, the victim node goes on-
chain a few blocks before the expiration time to claim
the contract. But, a dilated victim is bound to lose such
a race despite responding ahead of time.

Countermeasures: A solution to time dilation attack must
detect as well as mitigate the attack. Detecting whether a block
was delayed in being sent or delivered is complex due to high
false positive rate. Nevertheless, an abnormal routing failure
rate could be an indicator for detection. Similarly, mitigating
the attack is not straightforward mainly because identifying
attacker committed state or choosing the right channels from
multiple open channels is difﬁcult. Watchtowers [132, 136–
138] act as a substitute for a built-in defense mechanism, but
they come with assumptions on their honesty and efﬁciency.

E. Balance lockdown attack

Balance lockdown attack [172], also known as balance
availability attack, affects the ability of a victim node to suc-
cessfully participate in payment routing. The attack impedes
the victim node from taking part in any further transactions
by blocking their balance funds. Such an attack confers a
dominant position to the attacker, as well as reduces the
system’s efﬁciency. In particular, it enables the attacker to
block certain payment paths, giving a competitive advantage
to attacker-favored paths. The attacker has precise knowledge
about network topology using which the attacker routes a
payment via the victim node.

A multihop payment in a channel network is atomic in
nature, which means that the fund transfer can happen only
after the establishment of the complete payment path. Thus,
intermediate nodes on the payment path need to keep their
funds locked. An attacker can lock an amount p on each
victim node on the payment path just by sending a payment
of p through them. It is worth noting that the cost of sending
the payment and the time taken for the completion of the

Time Dilation/Eclipse attackOpen multiple channels toexhaust node connectionsRest of the networkTotally eclipsed astime is dilated Victimtransaction are the two key factors that decide the feasibility of
this attack. Hence, the attacker aims to increase the completion
time for the transaction as well as to minimize the cost of the
transaction. Authors in [172] show that the overall effect of
the attack can be captured by a parameter called Attack Effort
Ratio (AER), which is deﬁned as the ratio of capacity required
to launch the attack and the capacity that the attack effectively
blocks (cf Eq. 1).

AER =

CapacityRequired
CapacityBlocked

(1)

Another parameter, called Total Blocked Time (TBT),
to
measure attack’s effectiveness is deﬁned as the amount of time
for which the funds of victims are blocked in the transaction.
Countermeasures: An optimal solution to handle balance lock-
down attack should aim at increasing AER and reducing TBT.
AER can be increased by disallowing loops in payment routes
to minimize attacker’s proﬁtability. Another way to increase
AER is to limit the maximum length of payment routes, though
limiting route length may have an impact on the performance.
Regulating TBT is tricky and has to traded-off with AER.
Nevertheless, such trade-offs need detailed studies.

F. Balance discovery attack

Balance discovery attack [173, 174] affects PCN, in par-
ticular the Lightning network. A PCN comprises payment
channels with a ﬁxed deposit known as the channel capacity.
The total capacity of a channel is publicly known. However,
the individual balances on either side of a channel are not
disclosed to preserve the privacy of users participating in the
channel. Balance discovery attack aims to disclose individual
balances of users, thus compromising users’ privacy. Any node
creating a channel with a malicious node is vulnerable to this
attack. Moreover, the attack automatically extends to all the
immediate neighboring nodes of that victim node.

Fig. 14. Balance discovery attack where attacker tries to disclose the balance
between A and B.

Fig. 14 illustrates the setup for balance discovery attack.
Here,
two nodes A and B form a channel with a total
capacity C. We can safely assume that A and B perform some
transactions via their channel over the period of time, and their
current balances in the channel are α and β, respectively. It is
important to mention that the total channel capacity remains
unchanged, i.e., C = α + β. A malicious node M wants to
disclose α and β. To do so, M ﬁrst creates a channel with
A. This channel also facilitates M with a path to B through
A. Now, M sends a payment p to B through A. As long
as p is less than α, it can be sent successfully through the
route M→A→B. M increases the value of p and sends a new
payment to B. M repeats this process until an error occurs.
The last successful payment value p reﬂects the approximate
balance of A while β can be computed by subtracting α from

14

publicly known C. As an improvement, the value of p can
be efﬁciently calculated by using a binary search on lower
and higher payment bounds. Furthermore, M can also send
fake payments for probing such that none are ﬁnalized. Such
a strategy helps in reducing the cost of the attack.
Countermeasures: One straightforward countermeasure is to
limit the maximum allowed payment value. It would increase
the efforts required by the attacker, but it would also affect
the overall functionality of the system. The key approaches
to tackle balance discovery attack are dropping rate parame-
ter and dynamic absorption of negative balances [173]. The
former suggests each node to randomly deny a speciﬁed
percentage of transactions without disclosing the cause of
failure to the payment sender. Such a strategy will deceive the
attacker to assume that the payment has failed due to a lack
of funds. Consequently, the attacker will interpret the wrong
values of the balances. The latter advocates absorbing negative
channel balances to prevent accurate probing of the channel’s
remaining capacities.

G. Congestion attack

Similar to balance lockdown attack, the goal of congestion
attack [175] is to block victims’ funds at a lower cost. The
attack targets PCNs and obstructs several payment channels
at once for a long period of time. It exploits the trustless
payment mechanism and long HTLC expiration duration. In
particular, the attacker acts as both the source and destination
of a payment. It can establish multiple such payments for
wider coverage of the network. The attacker then sends funds
along each of such routes, blocking nodes on each route.

Fig. 15. Congestion attack over m payment routes.

Fig. 15 depicts a congestion attack on m payment routes,
where all nodes along the route 1 to m are blocked until the
attacker’s transaction completes. After joining the network, the
attacker evaluates different routes considering maximum route
length, available funds, contract expiration limits, etc. Next, it
establishes channels with two nodes along a target route such
that one of the nodes sees the attacker as the source while the
other node sees the attacker as the destination of the payment.

C = α + βBalancesBAβαMAttacker being SRC, DEST ofeach payment can delay finalexecution indefinitely1st hop target on route 1............nth hop target on route 1Route 1Route m.....15

The attacker can delay a transaction on such a route because it
is both the source and destination of the payment, which leaves
the nodes being blocked. Right before the HTLC expiration
time,
the attacker cancels the transaction and restores the
channels to their original state. At this point, it can relaunch the
attack to block the same path till the next HTLC expiry, which
can be in the order of weeks. Importantly, this attack can be
used in three ways: (1) to block high liquidity channels, (2) to
isolate multiple node pairs, and (3) to disconnect individual
nodes from the network.
Countermeasures: A simple approach to increase the number
of HTLCs supported by benign nodes would remain ineffective
as the attacker can take over all HTLCs with a larger volume of
payments. Nevertheless, the effect of the attack can be limited
by reducing the maximum allowed route length. Furthermore,
the nodes can regulate the number of maximum concurrent
payments with a peer based on its behavior.

VI. DISCUSSION

Different Layer-2 solutions aim to scale blockchains while
offering distinct functionalities based on different principles
and underlying technologies. In this section, we compare the
key categories of Layer-2 solutions. We have omitted cross
chains and hybrid solutions as properties of cross chains
implementations are highly dependent on chains targeted for
interoperability while hybrid solutions have diverse hardware
requirements. Thus, generalizing these categories may not
truly reﬂect
their characteristics. We compare these solu-
tions over multiple attributes that can be organized into four
categories, which are performance,
temporal requirements,
security considerations, and miscellaneous options. TABLE II
presents a summary of the comparisons.

In terms of performance, channels offer faster transaction
processing (i.e., almost instant Layer-2 transfers) at a meager
cost of transactions. However, channels require locking col-
laterals on-chain, while other solutions may not enforce this
requirement. In particular, each channel must have collateral

locked to start the operations. Thus, other solutions are per-
ceived as more capital efﬁcient than channels.

Withdrawing balances from channels requires just one on-
chain conﬁrmation. Commit chains and Optimistic Rollups
typically elongate withdrawal time for balance security and
dispute resolutions. Such longer durations can be shortened by
introducing risk insurers or liquidity providers. However, the
reliability of such insurers has its own concerns. Withdrawing
the balance on Layer-1 from zk Rollups takes fewer minutes
in the best case. The ﬁnality of a transaction reﬂects a
state, where the transaction can not be reverted on the main
chain. The underlying principles of channels offer instant
ﬁnality while other solutions typically offer delayed ﬁnality.
Nevertheless, instant ﬁnality can be tweaked on other Layer-2
solutions as well to reﬂect instant conﬁrmation to the user, but
full security guarantees remain exclusive to channels.

Most of the Layer-2 protocols use standard cryptographic
primitives, SNARKs and STARKs are heavily used in zero-
knowledge-based protocols. User liveness assumption is crit-
ical, which can be deﬁned as the requirement of a user to
remain online to receive/verify transactions, monitor disputes,
and handle misbehaving counterparties. Unlike channels, com-
mit chains enable users to receive transactions while remaining
ofﬂine. However, users are advised to come periodically online
to inspect checkpoint commitment. This assumption about a
user’s online status can be delegated to a trusted third-party
that monitors transactions on behalf of the user. Nonetheless,
such a third-party may compromise if the incentive to misbe-
have is greater than its guarantee deposit. Only commit chains
allow all users to successfully withdraw - mainly for security
reasons - in a short period of time, and all the protocols prevent
validators from conﬁscating the funds of participants.
Both Optimistic and zk Rollups offer support

import-
ing existing EVM-bytecode with minor modiﬁcations, and
thus, have a ﬂexible support for smart contracts. Transaction
deanonymization and user proﬁling are major privacy concerns
that only zk Rollups address by default [182–184].

TABLE II
A COMPARISON OF DIFFERENT Layer-2 SOLUTIONS.

Criteria

Aspect

Performance
and
operations

Temporal
requirements

Transaction Speed
Transaction cost
On-chain transaction
for account opening
Capital-efﬁcient

Withdrawal time

Finality

Instant transaction conﬁrmations
with full security guarantees
Cryptographic primitives used
User liveness
Mass exiting
Fund freezing by validators
Smart contract support
Imports existing
EVM-bytecode
Privacy options

Security
considerations

Support,
options,
and
miscellaneous

Channels

Fast
Very low

Yes

No
One
conﬁrmation

Instant

Yes,
self supported
Standard
Yes
No
No
Yes, limited

No

Limited

Commit
Chains
Moderate
Very low

No

Yes
Multiple
days
One
conﬁrmation
No,
parent-linked
Standard
Yes
Yes
No
Yes, limited

No

No

Optimistic
Rollups
Slow
Low

No

Yes
Multiple
days
One
conﬁrmation
No,
parent-linked
Standard
Delegable
No
No
Yes, ﬂexible

Yes

No

zk
Rollups
Slowest
Low

No

Yes
<10
minutes
<10
minutes
No,
parent-linked
New
No
No
No
Yes, ﬂexible

Yes

Full

VII. CONCLUSION
Scalability is a major issue for blockchain-based solutions.
Vast efforts, from both academia and industry, have been
put in different directions to tackle the blockchain scalability
issue. Such efforts have resulted in a rich literature of Layer-2
protocols that primarily aim to scale underlying main chains.
In this work, we ﬁrst create a broader taxonomy of Layer-2
protocols, which is followed by a detailed explanation of each
Layer-2 protocol class. These protocols bring scalability to the
main chains at the cost of different security assumptions and
guarantees. Thus, we discuss various issues associated with
these protocols and also compare them against each other. We
believe that our study offers better explanations and analyses
to help the readers understand the domain better.

REFERENCES

[1] S. Nakamoto, “Bitcoin: A Peer-to-Peer Electronic Cash

System,” https://bitcoin.org/bitcoin.pdf, 2008.

[2] D. Chaum, “Blind Signatures for Untraceable Pay-
ments,” in Advances in Cryptology, 1983, pp. 199–203.
[3] D. Chaum, A. Fiat, and M. Naor, “Untraceable Elec-
tronic Cash,” in Advances in Cryptology, 1988, pp. 319–
327.

[4] M. Conti, A. Gangwal, and M. Todero, “Blockchain
Trilemma Solver Algorand has Dilemma over Undecid-
able Messages,” in International Conference on Avail-
ability, Reliability and Security, 2019, pp. 1–8.

[5] K. Croman, C. Decker, I. Eyal, A. E. Gencer, A. Juels,
A. Kosba, A. Miller, P. Saxena, E. Shi, E. G. Sirer
et al., “On Scaling Decentralized Blockchains,” in In-
ternational Conference on Financial Cryptography and
Data Security, 2016, pp. 106–125.

[6] J. Levine, “Scalability Controversy: Understanding
Past Cryptocurrency Returns
through Segregated
Witness,” https://escholarship.org/content/qt0x670791/
qt0x670791.pdf, 2019.

[7] D. Ding, X. Jiang, J. Wang, H. Wang, X. Zhang, and
Y. Sun, “Txilm: Lossy Block Compression with Salted
Short Hashing,” arXiv preprint:1906.06500, 2019.
[8] “Compact Block Relay,” https://github.com/bitcoin/

bips/blob/master/bip-0152.mediawiki, 2020.

[9] I. Eyal, A. E. Gencer, E. G. Sirer, and R. Van Re-
nesse, “Bitcoin-NG: A Scalable Blockchain Protocol,”
in USENIX symposium on Networked Systems Design
and Implementation), 2016, pp. 45–59.

[10] R. Pass and E. Shi, “Hybrid Consensus: Efﬁcient Con-
sensus in the Permissionless Model,” in 31st Interna-
tional Symposium on Distributed Computing, 2017.
[11] A. Kiayias, A. Russell, B. David, and R. Oliynykov,
Proof-of-Stake
International

“Ouroboros: A Provably
Blockchain
in
Cryptology Conference, 2017, pp. 357–388.

Secure
Annual

Protocol,”

[12] A. Miller, A. Juels, E. Shi, B. Parno, and J. Katz,
“Permacoin: Repurposing Bitcoin Work for Data Preser-
vation,” in IEEE Symposium on Security and Privacy,
2014, pp. 475–490.

[13] S. Park, A. Kwon, G. Fuchsbauer, P. Gaži, J. Alwen,
and K. Pietrzak, “Spacemint: A Cryptocurrency Based

16

On Proofs Of Space,” in International Conference on
Financial Cryptography and Data Security, 2018, pp.
480–499.

[14] “Sawtooth,”
core, 2019.

https://github.com/hyperledger/sawtooth-

[15] L. Luu, V. Narayanan, K. Baweja, C. Zheng, S. Gilbert,
and P. Saxena, “SCP: A Computationally Scalable
Byzantine Consensus Protocol for Blockchains,” IACR
Cryptology ePrint Archive, no. 1168, 2015.

[16] “Sharding Roadmap,”

https://github.com/ethereum/

wiki/wiki/Sharding-roadmap, 2019.

[17] L. Luu, V. Narayanan, C. Zheng, K. Baweja, S. Gilbert,
and P. Saxena, “A Secure Sharding Protocol for Open
Blockchains,” in ACM Conference on Computer and
Communications Security, 2016, pp. 17–30.

[18] A. E. Gencer, R. van Renesse, and E. G. Sirer,
arXiv

Sharding with Aspen,”

“Service-oriented
preprint:1611.06816, 2016.

[19] M. Zamani, M. Movahedi, and M. Raykova, “Rapid-
chain: Scaling Blockchain via Full Sharding,” in ACM
Conference on Computer and Communications Security,
2018, pp. 931–948.

[20] E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly,
E. Syta, and B. Ford, “Omniledger: A Secure, Scale-
out, Decentralized Ledger via Sharding,” in IEEE Sym-
posium on Security and Privacy, 2018, pp. 583–598.

[21] Y. Sompolinsky, Y. Lewenberg, and A. Zohar, “SPEC-
TRE: A Fast and Scalable Cryptocurrency Protocol,”
IACR Cryptology ePrint Archive, vol. 2016, no. 1159,
2016.

[22] T. Zhou, X. Li, and H. Zhao, “DLattice: A Permission-
less Blockchain based on DPoS-BA-DAG Consensus
for Data Tokenization,” IEEE Access, vol. 7, pp. 39 273–
39 287, 2019.

[23] L. Cui, S. Yang, Z. Chen, Y. Pan, M. Xu, and K. Xu,
“An Efﬁcient and Compacted DAG-based Blockchain
Protocol for Industrial Internet of Things,” IEEE Trans-
actions on Industrial Informatics, vol. 16, no. 6, pp.
4134–4145, 2019.

[24] “Bitcoin Cash,” https://www.bitcoincash.org, 2008.
[25] J. Chen and S. Micali, “Algorand: A Secure And Ef-
ﬁcient Distributed Ledger,” Theoretical Computer Sci-
ence, vol. 777, pp. 155–183, 2019.

[26] M. Al-Bassam, A. Sonnino, S. Bano, D. Hrycyszyn, and
G. Danezis, “Chainspace: A Sharded Smart Contracts
Platform,” 2017.

[27] L. luu, V. Narayanan, C. Zheng, K. Baweja, S. Gilbert,
and P. Saxena, “Elastico : A Secure Sharding Protocol
For Open Blockchains,” in ACM Conference on Com-
puter and Communications Security, 2016, pp. 17–30.
[28] Ava Labs, “Avalanche,” https://www.avax.network/,

2018.

[29] W. F. Silvano and R. Marcelino, “Iota Tangle: A Crypto-
currency To Communicate Internet-of-Things Data,”
Future Generation Computer Systems, vol. 112, pp.
307–319, 2020.

Hearn,

[30] M.
nels
https://bitcointalk.org/index.php?topic=244656, 2013.

“Micro-payment
in

Implementation

Chan-
bitcoinj,”

now

[31] “bitcoinj,” https://bitcoinj.github.io/, 2019.
[32] C. Decker and R. Wattenhofer, “A Fast and Scalable
Payment Network with Bitcoin Duplex Micropayment
Channels,” in Symposium on Self-Stabilizing Systems,
2015, pp. 3–18.

[33] J. Poon and T. Dryja, “The Bitcoin Lightning Network:
Scalable Off-chain Instant Payments,” https://lightning.
network/lightning-network-paper.pdf, 2016.

[34] R. Khalil, A. Gervais, and G. Felley, “Nocust-a se-
curely scalable commit-chain,” IACR Cryptology ePrint
Archive, no. 642, 2018.

[35] G. Wood et al., “Ethereum: A Secure Decentralised
Generalised Transaction Ledger,” Ethereum project yel-
low paper, vol. 151, no. 2014, pp. 1–32, 2014.

[36] Bitcoin Wiki, “Hash Time Locked Contracts,” https://
en.bitcoin.it/wiki/Hash_Time_Locked_Contracts, 2019.
[37] D. Robinson, “HTLCs Considered Harmful,” in Pro-

ceedings of Stanford Blockchain Conf., 2019.

[38] G. Yu, X. Wang, K. Yu, W. Ni, J. A. Zhang, and R. P.
Liu, “Survey: Sharding in Blockchains,” IEEE Access,
vol. 8, pp. 14 155–14 181, 2020.

[39] G. Wang, Z. J. Shi, M. Nixon, and S. Han, “SoK:
Sharding on Blockchain,” in 1st ACM Conference on
Advances in Financial Technologies, 2019, pp. 41–61.
[40] S. Kim, Y. Kwon, and S. Cho, “A Survey of Scalability
Solutions on Blockchain,” in International Conference
on Information and Communication Technology Con-
vergence, 2018, pp. 1204–1207.

[41] A. Haﬁd, A. S. Haﬁd, and M. Samih, “Scaling
Blockchains: A Comprehensive Survey,” IEEE Access,
vol. 8, pp. 125 244–125 262, 2020.

[42] Q. Zhou, H. Huang, Z. Zheng, and J. Bian, “Solutions
to Scalability of Blockchain: A Survey,” IEEE Access,
vol. 8, pp. 16 440–16 455, 2020.

[43] L. Gudgeon, P. Moreno-Sanchez, S. Roos, P. McCorry,
and A. Gervais, “SoK: Layer-two Blockchain Proto-
cols,” in International Conference on Financial Cryp-
tography and Data Security, 2020, pp. 201–226.

[44] M.

Jourenko, K. Kurazumi, M. Larangeira, and
K. Tanaka, “SoK: A Taxonomy for Layer-2 Scalability
related Protocols for Cryptocurrencies,” IACR Cryptol-
ogy ePrint Archive, no. 352, 2019.

[45] A. Miller, I. Bentov, S. Bakshi, R. Kumaresan, and
P. McCorry, “Sprites and State Channels: Payment
Networks that go Faster than Lightning,” in Interna-
tional Conference on Financial Cryptography and Data
Security, 2019, pp. 508–526.

[46] T. Network, “Trinity: Universal Off-chain Scaling So-

lution,” https://trinity.tech/#/writepaper, 2020.

[47] AdEx Network,

“Introducing OUTPACE: Off-
Chain Unidirectional Trustless Payment Channels,”
https://www.adex.network/blog/introducing-outpace-
off-chain-unidirectional-trustless-payment-channels/,
2018.

17

Ethereum,” https://raiden.network/, 2018.

[49] E. Tairi, P. Moreno-Sanchez, and M. Maffei, “A2L:
Anonymous Atomic Locks for Scalability in Payment
Channel Hubs,” in IEEE Symposium on Security and
Privacy, 2021, pp. 1834–1851.

[50] M. Green and I. Miers, “Bolt: Anonymous Payment
Channels for Decentralized Currencies,” in ACM Con-
ference on Computer and Communications Security,
2017, pp. 473–489.

[51] E. Heilman, L. Alshenibr, F. Baldimtsi, A. Scafuro,
and S. Goldberg, “TumbleBit: An Untrusted Bitcoin-
compatible Anonymous Payment Hub,” in Network and
Distributed System Security Symposium, 2017, pp. 1–36.
[52] S. Dziembowski, L. Eckey, S. Faust, and D. Mali-
nowski, “PERUN: Virtual Payment Channels over Cryp-
tographic Currencies,” IACR Cryptology ePrint Archive,
no. 635, 2017.

[53] G. Konstantopoulos, “DAppChains: Scaling Ethereum
DApps through Sidechains,” https://medium.com/loom-
network, 2018.

[54] “Liquid,” https://liquid.net/, 2020.
[55] J. Kanani, S. Nailwal, and A. Arjun, “Matic Whitepa-
https://github.com/maticnetwork/whitepaper,

per,”
2021.

[56] I. SKALE Labs, “The SKALE Network : An Ethereum
Interoperable Elastic Blockchain Network,” https://
skale.network/whitepaper, 2020.

[57] “Liquidity Network,” https://liquidity.network/, 2020.
[58] R. Khalil, “NOCUST-A Non-Custodial 2nd-Layer
Blockchain Payment Hub,” Ph.D. dissertation, Master’s
thesis, Swiss Federal Institute of Technology, Zurich,
2018.

[59] “Polygon’s PoS,” https://polygon.technology/solutions/

polygon-pos, 2020.

[60] “Cartesi,”
pdf, 2020.

https://cartesi.io/cartesi_lightpaper_english.

[61] “Fuel Network,” https://fuel.sh/, 2020.
[62] “Offchain Labs’ Arbitrum,” https://arbitrum.io/, 2020.
[63] “OMG Network,” https://omg.network/, 2020.
[64] “Optimism,” https://www.optimism.io/, 2020.
[65] “Aztec 2.0,” https://aztec.network/, 2020.
[66] D. Wang, J. Zhou, A. Wang, and M. Finestone,
“Loopring: A Decentralized Token Exchange Protocol,”
2018.

[67] “Starkware,” https://starkware.co/, 2020.
[68] M. Labs, “zkSync: Bringing Trustless, Scalable Pay-

ments to Ethereum,” https://zksync.io/, 2019.

[69] M. Dong, Q. Liang, X. Li, and J. Liu, “Celer Net-
work: Bring Internet Scale to Every Blockchain,” arXiv
preprint:1810.00037, 2018.

[70] C. Network, “Connext : The Interoperability Protocol
of L2 Ethereum,” https://docs.connext.network/, 2016.
[71] M. Borkowski, M. Sigwart, P. Frauenthaler, T. Hukki-
nen, and S. Schulte, “DeXTT: Deterministic Cross-
blockchain Token Transfers,” IEEE Access, vol. 7, pp.
111 030–111 042, 2019.

[72] L. Network, “Intro to Loom Network,” https://loomx.

[48] R. Network, “Fast, Cheap, Scalable Token Transfers for

io/developers/en/intro-to-loom.html, 2016.

[73] P. K.

Igor Barinov, Viktor Baranov,

“POA
https://www.poa.network/v/master-1/for-

Network,”
users/whitepaper/poadao-v1, 2018.

[74] T. Baneth, “Waterloo - a Decentralized Practical
Bridge between EOS and Ethereum,” https://blog.
kyber.network/waterloo-a-decentralized-practical-
bridge-between-eos-and-ethereum-1c230ac65524,
2019.

[75] W. Warren and A. Bandeali, “0x: An Open Protocol for
Decentralized Exchange on the Ethereum Blockchain,”
https://github.com/0xProject/whitepaper, 2017.

[76] T. M. Mayer, C. Mai, and N. Jesse, “Tokrex: Meta-
system for Real-time Intra- and Cross-chain Swaps,”
https://tokrex.org/whitepapers/WhitePaper-Tokrex-
RealTimeIntraCrossChainSwaps.pdf, 2017.

[77] M. Spoke and N. Team, “AION: Enabling the
Decentralized Internet,” https://whitepaper.io/document/
31/aion-whitepaper, 2017.

[78] ARK, “ARK Ecosystem Whitepaper,” https://ark.io/

Whitepaper.pdf, 2019.

[79] B. Ethan and K. Jae, “Cosmos Whitepaper: A Network
Of Distributed Ledgers,” https://v1.cosmos.network/
resources/whitepaper, 2016.

[80] Komodo,

“Komodo

Whitepaper,”

https:

//komodoplatform.com/wp-content/uploads/2018/
06/Komodo-Whitepaper-June-3.pdf, 2018.

[81] G. Wood, “Polkadot: Vision For A Heterogeneous
Multi-chain Framework,” https://github.com/polkadot-
io/polkadotpaper/raw/master/PolkaDotPaper.pdf, 2016.
[82] H. Kalodner, S. Goldfeder, X. Chen, S. M. Weinberg,
and E. W. Felten, “Arbitrum: Scalable, Private Smart
Contracts,” in USENIX Security Symposium), 2018, pp.
1353–1370.

[83] J. Teutsch and C. Reitwießner, “A Scalable Veriﬁcation
Solution for Blockchains,” arXiv preprint:1908.04756,
2019.

[84] S. Matetic, K. Wüst, M. Schneider, K. Kostiainen,
G. Karame, and S. Capkun, “BITE: Bitcoin Lightweight
Client Privacy using Trusted Execution,” in USENIX
Security Symposium), 2019, pp. 783–800.

[85] J. Lind, O. Naor, I. Eyal, F. Kelbert, E. G. Sirer, and
P. Pietzuch, “Teechain: A Secure Payment Network with
Asynchronous Blockchain Access,” in ACM Symposium
on Operating Systems Principles, 2019, pp. 63–79.
[86] J. Lind, I. Eyal, P. Pietzuch, and E. G. Sirer, “Teechan:
Payment Channels using Trusted Execution Environ-
ments,” arXiv preprint:1612.07766, 2016.

[87] I. Bentov, Y. Ji, F. Zhang, L. Breidenbach, P. Daian,
and A. Juels, “Tesseract: Real-Time Cryptocurrency
Exchange using Trusted Hardware,” in ACM Conference
on Computer and Communications Security, 2019, pp.
1521–1538.

[88] K. Wüst, S. Matetic, M. Schneider, I. Miers, K. Kosti-
ainen, and S. ˇCapkun, “ZLiTE: Lightweight Clients for
Shielded Zcash Transactions using Trusted Execution,”
in International Conference on Financial Cryptography
and Data Security, 2019, pp. 179–198.

Gadget,” arXiv preprint:1710.09437, 2017.

18

[90] A. Kiayias, A. Russell, B. David, and R. Oliynykov,
Proof-of-stake
International

“Ouroboros: A Provably
Blockchain
in
Cryptology Conference, 2017, pp. 357–388.

Secure
Annual

Protocol,”

[91] M. Lokhava, G. Losa, D. Mazières, G. Hoare, N. Barry,
E. Gafni, J. Jove, R. Malinowsky, and J. McCaleb,
“Fast and Secure Global Payments with Stellar,” in ACM
Symposium on Operating Systems Principles, 2019, pp.
80–96.

[92] Z. Fathi, A. J. Rafsanjani, and F. Habibi, “Anon-
ISAC: Anonymity-Preserving Cyber Threat Information
Sharing Platform Based on Permissioned Blockchain,”
in Iranian Conference on Electrical Engineering, 2020,
pp. 1–5.

[93] H. Team, “Harmony: Technical Whitepaper,” https://

harmony.one/whitepaper.pdf, 2018.

[94] L. Josep, A. El-Fakdi, V. Torres, and X. Amen-
gual, “Logo Recognition By Consensus For Enabling
Blockchain Implementations,” in International Confer-
ence on Recent advances in Artiﬁcial Intelligence Re-
search and Development, vol. 300, 2017, p. 257.
[95] J. Wang and H. Wang, “Monoxide: Scale Out
Blockchains With Asynchronous Consensus Zones,” in
USENIX Symposium on Networked Systems Design and
Implementation), 2019, pp. 95–112.

[96] E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly,
E. Syta, and B. Ford, “Omniledger: A Secure, Scale-
out, Decentralized Ledger Via Sharding,” in IEEE Sym-
posium on Security and Privacy, 2018, pp. 583–598.

[97] A. Manuskin, M. Mirkin, and I. Eyal, “Ostraka: SecurE
Blockchain Scaling By Node Sharding,” in IEEE Euro-
pean Symposium on Security and Privacy Workshops,
2020, pp. 397–406.

[98] M. Zamani, M. Movahedi, and M. Raykova, “Rapid-
chain: Scaling Blockchain Via Full Sharding,” in ACM
Conference on Computer and Communications Security,
2018, pp. 931–948.

[99] H. Chen and Y. Wang, “SSchain: A Full Sharding
Protocol For Public Blockchain Without Data Migration
Overhead,” Pervasive and Mobile Computing, vol. 59,
p. 101055, 2019.

[100] S. AG, “Stegos : A Platform for Privacy Applications,”

https://stegos.com//docs/stegos-whitepaper.pdf, 2019.

[101] Z.

team, “ZILLIQA Technical Whitepaper,” https://

docs.zilliqa.com/whitepaper.pdf, 2017.

[102] A. G ˛agol and M. ´Swi˛etek, “Aleph: A Leaderless, Asyn-
chronous, Byzantine Fault Tolerant Consensus Proto-
col,” 2018.

[103] S. Forestier, D. Vodenicarevic, and A. Laversanne-Finot,
“Blockclique: Scaling Blockchains Through Transac-
tion Sharding In A Multithreaded Block Graph,” 2018.
[104] G. Danezis and D. Hrycyszyn, “Blockmania: From

Block Dags To Consensus,” 2018.

[105] A. Churyumov, “Byteball: A Decentralized System for
Storage and Transfer of Value,” https://byteball.org/
Byteball.pdf, 2016.

[89] V. Buterin and V. Grifﬁth, “Casper the Friendly Finality

[106] M. J. Amiri, D. Agrawal, and A. E. Abbadi, “CAPER: A

Cross-application Permissioned Blockchain,” Proceed-
ings of the VLDB Endowment, vol. 12, no. 11, pp. 1385–
1398, 2019.
[107] H. Gupta and D.

Janakiram, “CDAG: A Serial-
ized Blockdag for Permissioned Blockchain,” arXiv
preprint:1910.08547, 2019.

[108] W. Martino, M. Quaintance, and S. Popejoy, “Chain-
web: A Proof-of-work Parallel-chain Architecture For
Massive Throughput,” https://neironix.io/documents/
whitepaper/6793/chainweb-v15.pdf, 2018.

[109] C. li, P. Li, D. Zhou, W. Xu, F. Long, and A. Yao,
“Scaling Nakamoto Consensus To Thousands Of Trans-
actions Per Second,” 2018.

[110] T.-Y. Chen, W.-N. Huang, P.-C. Kuo, H. Chung, and T.-
W. Chao, “DEXON: A Highly Scalable, Decentralized
Dag-based Consensus Algorithm,” 2018.

[111] T. Zhou, X. Li, and H. Zhao, “DLattice: A Permission-
less Blockchain Based On DPoS-BA-DAG Consen-
sus For Data Tokenization,” IEEE Access, vol. 7, pp.
39 273–39 287, 2019.

[112] “Eunomia,” https://eunomia.social/, 2020.
[113] Y. Sompolinsky and A. Zohar, “Secure High-rate Trans-
action Processing In Bitcoin,” in International Confer-
ence on Financial Cryptography and Data Security,
2015, pp. 507–527.

[114] X. Boyen, C. Carr, and T. Haines, “Graphchain: A
Blockchain-free Scalable Decentralised Ledger,” in 2nd
ACM Workshop on Blockchains, Cryptocurrencies, and
Contracts, 2018, pp. 21–33.

[115] S. Tang, Q. Zhang, Z. Gao, J. Zheng, and D. Gu,
“Bracing A Transaction DAG with A Backbone Chain,”
IACR Cryptology ePrint Archive, p. 472, 2020.
[116] L. Baird, “The Swirlds Hashgraph Consensus Algo-
rithm: Fair, Fast, Byzantine Fault Tolerance,” Swirlds
Tech Reports SWIRLDS-TR-2016-01, 2016.

[117] Y. Lewenberg, Y. Sompolinsky, and A. Zohar, “Inclusive
Block Chain Protocols,” in International Conference on
Financial Cryptography and Data Security, 2015, pp.
528–547.

[118] F. Xiang, W. Huaimin, S. Peichang, O. Xue, and
Z. Xunhui, “Jointgraph: A DAG-based Efﬁcient Con-
sensus Algorithm for Consortium Blockchains,” Soft-
ware: Practice and Experience, vol. 51, no. 10, pp.
1987–1999, 2021.

[119] Q. Nguyen, A. Cronje, M. Kong, E. Lysenko, and
A. Guzev, “Lachesis: Scalable Asynchronous BFT on
DAG Streams,” 2021.

[120] I. Bentov, P. Hubáˇcek, T. Moran, and A. Nadler, “Tor-
toise and Hares Consensus: The Meshcash Framework
for Incentive-compatible, Scalable Cryptocurrencies,” in
International Symposium on Cyber Security Cryptogra-
phy and Machine Learning, 2021, pp. 114–127.
[121] C. LeMahieu, “Nano: A Feeless Distributed Crypto-
https://nano.org/en/whitepaper,

currency Network,”
p. 17, 2018.

[122] “Obyte,” https://obyte.org/, 2020.
[123] H. Yu, I. Nikoli´c, R. Hou, and P. Saxena, “Ohie:
Blockchain Scaling Made Simple,” in IEEE Symposium

19

on Security and Privacy, 2020, pp. 90–105.

[124] A. K. Jaiswal, “Parsec: A State Channel for the Internet

of Value,” arXiv preprint:1807.11378, 2018.

[125] Y. Sompolinsky and A. Zohar, “Phantom,” IACR Cryp-

tology ePrint Archive, no. 104, 2018.

[126] V. Bagaria, S. Kannan, D. Tse, G. Fanti, and
P. Viswanath, “Prism: Deconstructing The Blockchain
To Approach Physical Limits,” in ACM Conference
on Computer and Communications Security, 2019, pp.
585–602.

[127] Y. Sompolinsky, Y. Lewenberg, and A. Zohar, “SPEC-
TRE: A Fast and Scalable Cryptocurrency Protocol,”
IACR Cryptology ePrint Archive, no. 1159, 2016.
[128] Z. Yin, A. Ruan, M. Wei, H. Li, K. Yuan, J. Wang,
Y. Wang, M. Ni, and A. Martin, “StreamNet: A DAG
System with Streaming Graph Computing,” in Future
Technologies Conference, 2020, pp. 499–522.

[129] C. Liu, D. Wang, and M. Wu, “Vite: A High
Performance Asynchronous Decentralized Application
Platform,”
https://cryptorating.eu/whitepapers/VITE/
vite_en.pdf, 2018.

[130] “OP_CHECKLOCKTIMEVERIFY,”

https://github.

com/bitcoin/bips/blob/master/bip-0065.mediawiki,
2014.

[131] J.

Spilman,

“Anti DoS

for

tx

replacement,”

https://lists.linuxfoundation.org/pipermail/bitcoin-
dev/2013-April/002433.html, 2013.

[132] P. McCorry, S. Bakshi, I. Bentov, S. Meiklejohn, and
A. Miller, “Pisa: Arbitration outsourcing for state chan-
nels,” in ACM Conference on Advances in Financial
Technologies, 2019, pp. 16–30.

[133] P. McCorry, C. Buckland, S. Bakshi, K. Wüst, and
A. Miller, “You Sank My Battleship! A Case Study
to Evaluate State Channels as a Scaling Solution for
Cryptocurrencies,” in International Conference on Fi-
nancial Cryptography and Data Security, 2019, pp. 35–
49.

[134] J. Coleman, L. Horne, and L. Xuanji, “Counterfac-
tual: Generalized State Channels,” https:// l4.ventures/
papers/ statechannels.pdf , 2018.

[135] T. Close and A. Stewart, “Forcemove: An n-party State
Channel Protocol,” Magmo, White Paper, 2018.
[136] T. Dryja, “Unlinkable Outsourced Channel Monitoring,”

https://diyhpl.us/wiki/transcripts/scalingbitcoin/milan/
unlinkable-outsourced-channel-monitoring/, 2016.
[137] M. Khabbazian, T. Nadahalli, and R. Wattenhofer, “Out-
post: A Responsive Lightweight Watchtower,” in ACM
Conference on Advances in Financial Technologies,
2019, pp. 31–40.

[138] G. Avarikioti, F. Laufenberg, J. Sliwinski, Y. Wang, and
R. Wattenhofer, “Towards Secure and Efﬁcient Payment
Channels,” arXiv preprint:1811.12740, 2018.

[139] A. Dmitrienko, D. Noack, and M. Yung, “Secure Wallet-
assisted Ofﬂine Bitcoin Payments with Double-spender
Revocation,” in ACM on Asia Conference on Computer
and Communications Security, 2017, pp. 520–531.
[140] T. Takahashi and A. Otsuka, “Short Paper: Secure Of-
ﬂine Payments in Bitcoin,” in International Conference

20

on Financial Cryptography and Data Security, 2019,
pp. 12–20.

State-of-the-art Review,” Elsevier Network and Com-
puter Applications, vol. 149, 2020.

[141] K. Hu and Z. Zhang, “Fast Lottery-based Micropay-
ments for Decentralized Currencies,” in Australasian
Conference on Information Security and Privacy, 2018,
pp. 669–686.

[142] R. Pass and A. Shelat, “Micropayments for Decentral-
ized Currencies,” in ACM SIGSAC Conference on Com-
puter and Communications Security, 2015, pp. 207–
218.

[143] C. Burchert, C. Decker, and R. Wattenhofer, “Scalable
Funding of Bitcoin Micropayment Channel Networks,”
Royal Society Open Science, vol. 5, no. 8, p. 180089,
2018.

[144] A. R. Pedrosa, M. Potop-Butucaru, and S. Tucci-
Piergiovanni, “Scalable Lightning Factories for Bit-
coin,” in ACM/SIGAPP Symposium on Applied Com-
puting, 2019, pp. 302–309.

[145] G. Malavolta, P. Moreno-Sanchez, A. Kate, M. Maffei,
and S. Ravi, “Concurrency and Privacy with Payment
Channel Networks,” in ACM SIGSAC Conference on
Computer and Communications Security, 2017, pp.
455–471.

[146] C. Egger, P. Moreno-Sanchez, and M. Maffei, “Atomic
Multi-channel Updates with Constant Collateral
in
Bitcoin-compatible Payment Channel Networks,” in
ACM SIGSAC Conference on Computer and Commu-
nications Security, 2019, pp. 801–815.

[147] G. Malavolta, P. Moreno-Sanchez, C. Schneidewind,
A. Kate, and M. Maffei, “Anonymous Multi-Hop Locks
for Blockchain Scalability and Interoperability,” in Net-
work and Distributed System Security Symposium, 2019,
pp. 1–15.

[148] G. Avarikioti, G. Janssen, Y. Wang, and R. Wattenhofer,
“Payment Network Design with Fees,” in Data Privacy
Management, Cryptocurrencies and Blockchain Tech-
nology, 2018, pp. 76–84.

[149] R. Khalil and A. Gervais, “REVIVE: Rebalancing Off-
blockchain Payment Networks,” in ACM SIGSAC Con-
ference on Computer and Communications Security,
2017, pp. 439–453.

[150] S. Dziembowski, S. Faust, and K. Hostáková, “General
State Channel Networks,” in ACM SIGSAC Conference
on Computer and Communications Security, 2018, pp.
949–966.

[151] S. Dziembowski, L. Eckey, S. Faust, J. Hesse, and
K. Hostáková, “Multi-party Virtual State Channels,” in
Annual International Conference on the Theory and
Applications of Cryptographic Techniques, 2019, pp.
625–656.

[152] A. Back, M. Corallo, L. Dashjr, M. Friedenbach,
G. Maxwell, A. Miller, A. Poelstra,
J. Timón,
and P. Wuille, “Enabling Blockchain Innovations
with Pegged Sidechains,” http://kevinriggen.com/ﬁles/
sidechains.pdf, 2014.

[153] A. Singh, K. Click, R. M. Parizi, Q. Zhang, A. De-
hghantanha, and K.-K. R. Choo, “Sidechain Technolo-
gies in Blockchain Networks: An Examination and

[154] R. Khalil, A. Zamyatin, G. Felley, P. Moreno-Sanchez,
and A. Gervais, “Commit-Chains: Secure, Scalable Off-
Chain Payments,” IACR Cryptology ePrint Archive, no.
642, 2018.

[155] J. Poon and V. Buterin, “Plasma: Scalable Autonomous
Smart Contracts,” White paper, pp. 1–47, 2017.
[156] A. Gabizon, Z. J. Williamson, and O. Ciobotaru,
“PLONK: Permutations over Lagrange-bases for Oe-
cumenical Noninteractive arguments of Knowledge,”
IACR Cryptology ePrint Archive, no. 953, 2019.
[157] J. Song, “Data Availability Problem in Implementing
Plasma Design,” https://medium.com/onther-tech/data-
availability-problem-in-implementing-plasma-design-
6e23df1a147f, 2018.

[158] R. Belchior, A. Vasconcelos, S. Guerreiro, and M. Cor-
reia, “A Survey on Blockchain Interoperability: Past,
Present, and Future Trends,” ACM Computing Surveys,
vol. 54, no. 8, pp. 1–41, 2021.

[159] A. Zamyatin, D. Harz, J. Lind, P. Panayiotou, A. Ger-
vais, and W. J. Knottenbelt, “XCLAIM: Trustless, In-
teroperable, Cryptocurrency-backed Assets,” in IEEE
Symposium on Security and Privacy, 2019, pp. 193–
210.

[160] H. Tian, K. Xue, X. Luo, S. Li, J. Xu, J. Liu, J. Zhao,
and D. S. Wei, “Enabling Cross-chain Transactions:
A Decentralized Cryptocurrency Exchange Protocol,”
IEEE Transactions on Information Forensics and Se-
curity, vol. 16, pp. 3928–3941, 2021.

[161] Intel, “Intel Software Guard eXtensions (Intel SGX),”

https://www.intel.com/content/www/us/en/developer/
tools/software-guard-extensions/overview.html, 2021.

[162] V. Costan and S. Devadas, “Intel SGX Explained,” IACR

Cryptology ePrint Archive, no. 086, 2016.

[163] A. Nilsson, P. N. Bideh, and J. Brorsson, “A Sur-
vey of Published Attacks on Intel SGX,” arXiv
preprint:2006.13598, 2020.

[164] S. Fei, Z. Yan, W. Ding, and H. Xie, “Security Vulnera-
bilities of SGX and Countermeasures: A Survey,” ACM
Computing Surveys, vol. 54, no. 6, pp. 1–36, 2021.

[165] V. Sivaraman, S. B. Venkatakrishnan, M. Alizadeh,
G. Fanti, and P. Viswanath, “Routing Cryptocurrency
with the Spider Network,” in ACM Workshop on Hot
Topics in Networks, 2018, pp. 29–35.

[166] G. Di Stasi, S. Avallone, R. Canonico, and G. Ventre,
“Routing Payments on the Lightning Network,” in Inter-
national Conference on Internet of Things (iThings) and
IEEE Green Computing and Communications (Green-
Com) and IEEE Cyber, Physical and Social Computing
(CPSCom) and IEEE Smart Data (SmartData), 2018,
pp. 1161–1170.

[167] G. Malavolta, P. Moreno-Sanchez, A. Kate, and
M. Maffei, “SilentWhispers: Enforcing Security and
Privacy in Decentralized Credit Networks,” in Network
and Distributed Security Symposium, 2017, pp. 1–18.

[168] S. Roos, P. Moreno-Sanchez, A. Kate, and I. Goldberg,
“Settling Payments Fast and Private: Efﬁcient Decen-

tralized Routing for Path-based Transactions,” arXiv
preprint arXiv:1709.05748, 2017.

[169] J. Harris and A. Zohar, “Flood & Loot: A Systemic
Attack on the Lightning Network,” in ACM Conference
on Advances in Financial Technologies, 2020, pp. 202–
213.

[170] A. Riard and G. Naumenko, “Time-Dilation Attacks
on the Lightning Network,” arXiv preprint:2006.01418,
2020.

[171] “Peer Services,” https://github.com/bitcoin/bips/blob/

master/bip-0157.mediawiki, 2017.
[172] C. Pérez-Sola, A. Ranchal-Pedrosa,

J. Herrera-
Joancomartí, G. Navarro-Arribas, and J. Garcia-Alfaro,
“Lockdown: Balance Availability Attack Against
International
Lightning Network Channels,”
Conference on Financial Cryptography and Data
Security, 2020, pp. 245–263.

in

[173] J.

G.

Herrera-Joancomartí,

Navarro-Arribas,
A. Ranchal-Pedrosa, C. Pérez-Solà, and J. Garcia-
Alfaro, “On the Difﬁculty of Hiding the Balance of
Lightning Network Channels,” in ACM Asia Conference
on Computer and Communications Security, 2019, pp.
602–612.

[174] G. v. Dam, R. A. Kadir, P. N. Nohuddin, and H. B.
Zaman, “Improvements of the Balance Discovery At-
tack on Lightning Network Payment Channels,” in IFIP
International Conference on ICT Systems Security and
Privacy Protection, 2020, pp. 313–323.

[175] A. Mizrahi and A. Zohar, “Congestion Attacks in Pay-
ment Channel Networks,” in International Conference
on Financial Cryptography and Data Security, 2021,
pp. 170–188.

[176] Z. Avarikioti, O. S. Thyfronitis Litos, and R. Watten-

21

hofer, “Cerberus Channels: Incentivizing Watchtowers
for Bitcoin,” in International Conference on Financial
Cryptography and Data Security, 2020, pp. 346–366.

[177] D. A. Harding and P. Todd, “Opt-in Full Replace-
by-Fee Signaling in Bitcoin Improvement Proposal
125,”
https://github.com/bitcoin/bips/blob/master/bip-
0125.mediawiki, 2015.

[178] “Anchor Outputs, Lightning Network Speciﬁcations,”

https://github.com/lightningnetwork/lightning-
rfc/pull/688, 2019.

[179] S. Mazumdar, P. Banerjee, and S. Ruj, “Grieﬁng-
penalty: Countermeasure for Grieﬁng Attack in Light-
ning Network,” arXiv preprint:2005.09327, 2020.
[180] S. Tochner, S. Schmid, and A. Zohar, “Hijacking Routes
in Payment Channel Networks: A Predictability Trade-
off,” arXiv preprint:1909.06890, 2019.

[181] E. Rohrer, J. Malliaris, and F. Tschorsch, “Discharged
Payment Channels: Quantifying the Lightning Net-
work’s Resilience to Topology-based Attacks,” in IEEE
European Symposium on Security and Privacy Work-
shops, 2019, pp. 347–356.

[182] A. Biryukov and D. Feher, “Deanonymization of Hid-
den Transactions in Zcash,” University of Luxembourg,
pp. 1–15, 2018.

[183] F. Béres, I. A. Seres, A. A. Benczúr, and M. Quintyne-
Collins, “Blockchain is Watching You: Proﬁling and
Deanonymizing Ethereum Users,” in International Con-
ference on Decentralized Applications and Infrastruc-
tures, 2021, pp. 69–78.

[184] “Evaluating Ethereum L2 Scaling Solutions: A
Comparison
https://blog.matter-
Framework,”
labs.io/evaluating-ethereum-l2-scaling-solutions-a-
comparison-framework-b6b2f410f955, 2020.

