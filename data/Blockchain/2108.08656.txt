1
2
0
2

g
u
A
9
1

]

C
D
.
s
c
[

1
v
6
5
6
8
0
.
8
0
1
2
:
v
i
X
r
a

Max-min Fairness Based Faucet Design for Blockchains

Serdar Metin1,∗, Can ¨Ozturan1
Bo˘gazic¸i University, Bebek, ˙Istanbul, Turkey

Abstract

In order to have transactions executed and recorded on blockchains such as the
Ethereum Mainnet, fees expressed in crypto-currency units of the blockchain must
be paid. One can buy crypto-currency called Ether of the Ethereum blockchain
from exchanges and pay for the transaction fees.
In the case of test networks
(such as Rinkeby) or scientiﬁc research blockchains (such as Bloxberg), free
crypto-currency, Ether, is distributed to users via faucets. Since transaction slots
on the blocks, storage and smart contract executions are consuming blockchain
resources, Ethers are distributed by ﬁxed small amounts to users. Users may
have different amount of Ether requirements; some small amounts and some large
amounts during different times. As a result, rather than allowing the user to get
a ﬁxed small amount of Ether, a more general distribution mechanism that allows
a user to demand and claim arbitrary amounts of Ether, while satisfying fairness
among users, is needed. For this end, Max-min Fairness based schemes have been
used in centralized settings. Our work contributes a Max-min Fairness based algo-
rithm and its Solidity smart contract implementation that requires low transaction
costs independent of the number of users. This is important on the Ethereum
blockchain, since a smart contract execution with transaction costs depending on
the number of users would mean block gas limit exhaustion problem will eventu-
ally be met, making the smart contract ineffective. We report tests which conﬁrm
that the low transaction cost aims have been achieved by our algorithm.

Keywords: Blockhain, Faucet, Max-min Fairness, Resource Allocation

∗Corresponding author
Email addresses: serdar.metin@boun.edu.tr (Serdar Metin),

ozturaca@boun.edu.tr (Can ¨Ozturan)

Preprint submitted to arXiv.org

August 20, 2021

 
 
 
 
 
 
1. Introduction

Since its conception in 2008 with Bitcoin [1], blockchain technologies have
been the focus of much attention. Although successful at achieving its initially
proposed purpose of providing a peer-to-peer electronic cash system, Bitcoin was
conceived as an autonomous global currency with guaranteed scarcity, and as
such, offered limited programmability and functionality. The designers of the
following generation of blockchain systems mainly problematised this point and
endeavoured on expanding blockchain capabilities. With the introduction of smart
contracts by the Ethereum [2], the blockchain technology met Turing-complete
programming functionalities.

Our work aims to address a recurrent question in computer science, within the
blockchain context: the fair allocation of shared resources. We focus on the fair
allocation of intrinsic resources of blockchains. Since a blockchain is a distributed
ledger, operated in a distributed manner, the ability to operate on the blockchain
(e.g. executing a transaction or a smart contract function, or deploying a smart
contract) is a shared, limited resource. We look at the fair allocation of this re-
source.

In the Ethereum blockchain ecosystem that offers smart contract functionality,
the resource usage mentioned above are quoted in terms of gas, which refers to the
cost necessary to perform a transaction on the blockchain. The gas is priced using
the blockchain’s intrinsic crypto-currency, called Ether in the case of Ethereum.
Hence, just like a number of litres of petrol (priced as USD per litre) is needed in
order to have a car travel a number of kilometers, a number of gas units (priced as
Ether per gas unit) is needed to execute a number of instructions in a blockchain
transaction. Thus, the problem collapses down to the distribution of the system’s
intrinsic crypto-currency. In commercial public networks like Ethereum Mainnet,
the distribution process relies on the competition to create new Ether units of the
blockchain currency, and the trading of the already generated Ethers. However, on
test networks such as Rinkeby or scientiﬁc research blockchains such as Bloxberg
[3] alternative Ether distribution mechanisms are used.

A faucet is one such mechanism, which offers free currency to users accord-
ing to some predeﬁned policy. In general, faucets offer a ﬁxed amount of currency
for a given time period or block span. For example, Bloxberg blockchain provides
0.2 Ethers via its web based faucet [4]. However, this mechanism can be exploited
simply by making recurrent requests and accumulating the obtained currency. For
this reason, it cannot be accounted for as a fair distribution scheme. Max-min Fair-
ness [5, 6] is a distribution scheme that is widely employed in different contexts

2

where fairness is a system requirement (e.g. cpu scheduling, bandwidth allocation
etc.), and it can also be considered for the fair distribution of currency in faucet
systems.

On the Ethereum blockchain, the size of each block is bound by a maximum
amount of gas that can be spent per block. This upper bound on the gas amount
is known as the block gas limit. A contract function will not be able to execute
if its gas cost exceeds the block gas limit. We refer to this problem as the block
gas limit exhaustion problem. Hence, smart contract functions should be designed
and implemented in such a way that their execution does not consume too much
gas which may lead to block gas limit exhaustion problem. If gas limit is reached,
it will simply mean the contract function cannot be executed which in turn may
mean the smart contract can no longer operate properly.

In this work, we ﬁrst implement Max-min Fairness algorithm in the blockchain
context as a smart contract, as it is originally implemented in centralized systems.
After demonstrating the shortcomings of this implementation in the blockchain
context (i.e. block gas limit exhaustion problem), we contribute an algorithm
that actuates the Max-min Fairness scheme in the blockchain context without run-
ning into the original implementation’s shortcomings. We name our algorithm
Autonomous Max-min Fairness (AMF), since it is operated autonomously by the
users in the system, as opposed to the original algorithm, in which the distribution
operation is done centrally by an authority. Figure 1 illustrates the operations of
centralised and authority driven faucet smart contract implementation in (a) and
autonomous and decentralised implementation driven by crowds of users in (b).
In the former scenario, the distribution is done with a single call to the distribute
function by the authority node in the beginning of the epoch, whereas in the latter
the users make multiple calls to the claim function throughout the epoch in order
to obtain their own share.

We further extend the study to a weighted version of Max-min Fairness scheme,
in which case the users are assigned weights for their respective shares, according
to some prioritisation policy. In the tests we run, the weight of each user’s share
is deﬁned to be the reciprocal of the total demand volume of the user, up to and
including the then present demand. By discouraging unnecessary demands, this
policy leads to higher sharing incentives among users. Moreover, it secures fair-
ness of distribution in the long run, since latter allocations are mediated with the
former demands of a given user. We name this algorithm Weighted Autonomous
Max-min Fairness (WAMF).

The remainder of the article is organised as follows: In the next section, we re-
view the literature on related work. Having laid out the background on blockchain

3

Figure 1: The call sequences of the (a) Authority driven faucet, and (b) Autonomous faucet (driven
by crowds of users), in a distribution cycle. Blue arrows indicate low-cost transactions (demand
and claim), and red arrow indicates a high-cost transaction (distribute).

studies, in Section 3 we state our problem in the light of the observations from
Section 2. We continue with a section where we justify our design decisions
concerning the experimentation environment. Following that, in Section 5 the
Max-min Fairness scheme and its adaptation to the present context is explained.
In Section 6, the implementation details are laid out. Once the implementation is
explained, the results of the experiments are given in Section 7. We discuss the
results in Section 8, and conclude the article in Section 9 with the prospects of
possible follow-up studies.

2. Related Work

Blockchain technologies have been proposed for a number of user applications

(e.g. [7, 8, 9]), and also for background services (e.g. [10, 11]).

By the introduction of tokenised economies, blockchain systems are rendered

4

capable of governing allocation and trade of resources [12]. A token is a data
structure with certain attributes and operations deﬁned on them, serving for rep-
resenting items or value. The ﬁrst two standards that are developed for token
economies are ERC20 and ERC721, which deﬁne divisible and non-divisible, or
as they are so called, fungible and non-fungible tokens, respectively. Although
compatible with our setting, for reasons of simplicity we did not use token stan-
dards in our implementation.

In many areas in computer science where the problem of distributing shared re-
sources is encountered, Max-min Fairness [5, 6] has been considered a fair method
[13, 14]. It is also the main method employed in the present study.

The question of fair sharing ﬁrst arose in the context of operating systems,
where scheduling the resources of a single computer (e.g. processor time) among
processes was the main problem [15]; followed by the problem of distributing the
same resources among users [16], typically at the computer centres of universi-
ties. Similar problems are addressed in the computer networks literature over the
allocation of link bandwidth [17, 13]. Fair scheduling algorithms have also been
the focus of attention in grids [18].

With the advancements in distributed systems, and new paradigms in cluster
and high-performance computing, the problem of fairness evolved yet to larger
scales, and new questions arose. In this context, typically, service providers charge
users for the common resource that is demanded by, and allocated to them. The
same question is now expressed in terms of charging fairness: how much should
each demand cost, for it to be fair among clients [19] ? Should each type of
resource cost the same, and if not how are they traded [20] ?

3. Problem Statement

As indicated in Section 2, the criteria for fair allocation is intimately related
with the context the problem is situated in. A number of observations that stand
out to be relevant are as follows:

3.1. Abstraction for Demands: The level at which distribution is done

As observed in Section 2, the allocation may be done at process-level [15],
user-level [16], or group-level [21]. The faucet system that we contribute is de-
signed so as to provide fair distribution of internal currency among users, with
the assumption that the users are identiﬁed and registered for making demands.
Therefore, the abstraction for the demands are at the user level.

5

3.2. Abstraction for Resources: The number of resource types and their relation-

ship with each other

If the resources are abstracted to be homogeneous, the main problem is pricing
a unit resource [19]. On the other hand, if more than one type of resources ab-
stracted, the problem should be extended as to address how they are traded among
each other [20].

A key factor for determining the price of a cryptocurrency is its by then present
and ultimate total supply [22]. In the system we developed, the growth of the total
supply is predeﬁned by an immutable policy, securing the ground for a calculable
and predictable pricing mechanism. Since the domain we restricted the present
study into is non-commercial blockchain systems, pricing here does not refer to
monetary pricing, but rather the cost of operations in terms of intrinsic cryptocur-
rency.

For simplicity, abstraction for the resource is kept at single resource type,
which is the intrinsic currency of the blockchain ecosystem, which in our case
is the Ether cryptocurrency. With Ether, a user can pay for storage as well as exe-
cution cost of smart contract functions on the Ethereum blockchain, providing the
basis for a uniﬁed resource type.

3.3. Temporal Granularity: The frequency at which the allocation procedure

takes place

For addressing this issue, the blockchain is divided into epochs, which we
deﬁne as a constant number of successive blocks. According to the original Max-
min Fairness algorithm, the distribution should be done at the beginning of each
epoch, which we implemented as such. In the algorithms we develop, we also
expand the allocation procedure over the whole span of the epoch, to be decen-
trally carried out by users, in the so called claim rounds. The temporal setting will
further be described in Sections 6 and 7.

4. Design Decisions on the Experimentation Environment

Although there are a number of design decisions for setting up a blockchain
system to carry out experiments on, one key factor is the proof scheme employed
in the consensus protocol. In the present study, the experiments are carried out on
the Parity implementation of a permissioned Ethereum blockchain [23]. The main
concern for this choice is to decouple two independent, yet intertwined questions
speciﬁc to the blockchain environments. Blockchains are a means both for decen-
tralisation, and for securing digital trust. By decoupling these two questions and

6

allowing to concentrate on decentralisation premise, permissioned blockchains
are ideal experimentation environments for blockchain operation analysis. Let us
elaborate on that.

Various proof schemes, employed in blockchains’ consensus protocols, neces-
sitate different trust assumptions, and equivalently, offer different levels of digital
trust to the ecosystems they are embedded in. If one imagines proof schemes on a
scale for their provision of trust, Proof-of-Work (PoW) blockchains reside on one
extreme, since they assume no preliminary digital trust, and provide all the digital
trust needed via their operation. For this reason they are referred to as trustless
computation environments, in the sense that no prior trust is needed among the
users to be involved in the operation of the ecosystem. Initial blockchains such as
Bitcoin [1] and Ethereum [2] employ PoW based consensus protocols.

Although they can operate stand-alone trust-wise, PoW blockchains expend
enormous physical resources (e.g. electricity, processing power) and their oper-
ation is costly. Other proof schemes were proposed to replace PoW in order to
eliminate these costs. These schemes provided different levels of trust, compen-
sated by extra-digital measures to different extents, inversely proportional with the
former. Among these are: Proof-of-Space [24], Proof-of-Stake [25, 26], Proof-of-
Prestige [27], Proof-of-Activity [28], Proof-of-Useful-Work [29], with different
utilities and limitations they bear.

Proof-of-Authority (PoA) blockchains, residing on the other extreme, provide
no trust via their operation, and rely solely on extra-digital measures (e.g. reserve
the right to operate on the blockchain only to trusted parties) to secure trust.

The trust structure described above for PoA is equivalent to the trust structure
of the conventional computation environments, which is referred to as Pretty Good
Privacy (PGP) trust chain [30]. The PGP scheme secures trust with the assumption
of the presence of a trust anchor, a party that can be unconditionally trusted, and
from that point, other parties are trusted either by the direct reference of, or by a
chain of references rooted at the trust anchor. In the PoA setting, authority nodes
act as trust anchors.

We implemented our algorithms in Solidity programming language and run
on an Ethereum Virtual Machine (EVM) environment [31], and more speciﬁcally,
its Parity implementation, as mentioned above. The main reason for selecting
this framework is its wide use among blockchain ecosystems. Many blockchain
ecosystems and blockchain based systems utilise either EVM or virtual machines
similar to EVM, and support Solidity programming language for smart contracts
(e.g. [32, 33, 34, 35] etc.), and for this reason there are also studies available
on the performance [36], security [37], and inspection [38] of the programming

7

language. Not only is it a widespread programming language, Solidity is also
Turing complete [2], which makes it well suited for general purpose computations.
It is a high-level, easy to read, object oriented script language.

A number of smaller design decisions are taken concerning the parameters of
Parity Ethereum Virtual Machine and the procedure of the experiments, which is
left to be discussed in Section 7, since their explanation relies occasionally on the
implementation of the algorithms we present.

5. Max-min Fairness Model

The main objective of the Max-min Fairness scheme is to maximise the mini-
mum share given to a user, and its mechanism is based on a trivial fairness scheme,
where resources are uniformly distributed among the demanders, each one of the
n demanders obtaining 1
n of the resource. Max-min Fairness improves the trivial
scheme on the premise that not every demander would demand as much as the
share that is reserved for them. Accordingly, the Max-min Fairness allocation al-
gorithm takes recursive iterations over the list of demanders, reallocating unused
shares of the underdemanders among the overdemanders.

In the ﬁrst iteration, starting with the smallest demand and proceeding in the
ascending order, the algorithm allocates the demanders the minimum of 1
n of the
capacity (c) and their demands (i.e. min{ c
n , du}). At the end of the ﬁrst iteration,
some demanders are fully supplied, and some capacity is left over. The algorithm,
in turn, proceeds with updated n(cid:48) and c(cid:48), until either all demands are fully supplied,
or the capacity is depleted.

The operation of the scheme can be seen in Figure 2, and its pseudo-code
in Algorithm 1. In the pseudo-code the demand heaps are denoted by D0 and
D1, and individual demands in these heaps are represented by lower case letters,
subscripted with u, for user id number (i.e. du).

The balances of users are kept in a vector, and the balance of user u is repre-
sented with bu. At each iteration, the maximum available amount to be allocated
to each user is recalculated by dividing the remaining capacity by the number of
remaining demands, and denoted by s, representing the unit share.

To illustrate the operation of the algorithm we may consider the following ex-
ample: Suppose that a resource of 30 units will be shared among three users, with
the demands expressed as <4, 11, 15>. The algorithm distributes the resource in 3
iterations. The rounds and the shares assigned in each round can be seen in Table
1.

8

Leftover
Demand

User
Demands

Demand
Heap 0

Demand
Heap 1

Leftover
Capacity

Leftover
Demand

Supplied

Figure 2: The operation of Max-min Fairness Algorithm

Demands
Iteration 1
Iteration 2
Iteration 3
Total

User 1 User 2 User 3 Share Capacity
30
6
2
0

10
3
2

4
4
0
0
4

11
10
1
0
11

15
10
3
2
15

Table 1: An exemplary distribution according to Max-min Fairness scheme

9

How the unsatisﬁed demand, or the leftover capacity will be treated after a
distribution period is a decision of policy. In our current work, we implement a
policy that discards all the unsatisﬁed demands, in the case of capacity depletion,
and transfers the leftover capacity to the next distribution period, in the case of
satisfying all the demands.

The amount that is reserved for each epoch is denoted by C. We call this
amount the epoch capacity, and in the present study, we took it to be constant.
The actual amount that is distributed in an epoch is denoted by c, and it is at least
as much as C, since it is added to c at the beginning of each epoch (i.e. Algorithm
1 line 2).

In Algorithm 1, the lines 4 − 20 constitute the main, or outer loop of the
algorithm, which is responsible for repeating the inner loop (lines 10 − 18) until
either the demands or the capacity is depleted. It starts with calculating the share
(lines 5 − 9), and then starts the inner loop. Once the proceeding of the inner loop
is completed, the demand heaps exchange their functions (line 19) and the outer
loop takes another iteration.

The inner loop accounts for iterating on and processing the demands in the
active heap. In line 11 the demand volume and the user id at the root of the heap
is read into a variable and deleted from the heap. After that the minimum of user
demand and unit share (i.e. min{ c
n, du}) is assigned to the user in lines 12 − 14.
The control structure in lines 15−17 checks whether the demand is fully satisﬁed.
If not, the leftover demand is inserted to the heap with the user’s id (line 16) to be
processed in further iterations.

Another version of Max-min Fairness is weighted Max-min Fairness, in which
case the users are weighted over some predeﬁned policy, and the shares are calcu-
lated with the weights assigned to each user, individually. In this version, instead
of the number of demands, the total capacity is divided by the total weight in
order to calculate the unit share (s). In turn, the user share (su for user u) is calcu-
lated for each user by multiplying the unit share with the user’s weight. The users
are allocated the minimum of their demands, and their individually assigned user
shares.

10

Symbol Meaning

C

Di
U
c

s
u
dui

bu

Amount of resource that is added
to the existing capacity at every
epoch, C ∈ Z+
Set of demand heaps, i ∈ {0, 1}
Set of users u ∈ {u1, . . . , un}
The existing capacity, initialised
at 0, incremented by C at every
epoch
Unit share
User u, u ∈ U
Demand of user u stored on heap
Di
Resource balance of user u, bu ∈
Z≥0, u ∈ U

Table 2: Symbols used in CMF (Algorithm 1) and their meanings

Algorithm 1: Max-min Fairness (CMF)
1 FU N C T I O N: DI S T R I B U T E(D, U, c)
2 c ← c + C;
3 i ← 0;
4 while Di.size() > 0 and c > 0 do
5

if c < Di.size then

s ← 1 ;

else

s ←

(cid:106)

(cid:107)

;

c
Di.size

end
while Di.size > 0 and c > 0 do
(dui, u) ← Di.delM in();
a ← min (s, dui);
bu ← bu + a;
c ← c − a;
if dui > s then

D1−i.insert(dui − s, u);

end

6

7

8

9

10

11

12

13

14

15

16

17

18

end
i ← 1 − i;

19
20 end
21 return;

Accordingly, the formula for calculating the unit share s is:

11

s =

c
j=1 wj

(cid:80)n

and the user share su is given by:

su = wu · s = wu ·

c
j=1 wj

(cid:80)n

We develop autonomous algorithms called AMF (unweighted version) and
WAMF (weighted version) for actuating the Max-min Fairness scheme. In WAMF,
the weights are deﬁned to be the reciprocals of the total amount of demands users
have made up to the distribution time. This aims at incentivizing users to make
minimal demands suitable to their needs, in order not to be disadvantageous in the
long run. The implementation details of WAMF algorithm, as well as its pseudo-
code is presented in Section 6.

6. Implementation

The conventional setting to utilise Max-min Fairness typically includes a cen-
tral unit (either an individual process running on a central processor or a dedicated
administrative host in a computer network) calculating the shares and carrying out
the iterative assignments. This is applicable to the blockchain context, but not
without potential drawbacks. The main bottleneck in such an adaptation is the
block gas limit, which imposes an absolute upper bound for the number of opera-
tions that may take place within the processing of a single block. For this reason,
we implemented two algorithms and compared them. The implementations are
available at [39]

The ﬁrst algorithm is the Conventional Max-min Fairness (CMF). This algo-
rithm is implemented as if it operates in the conventional computational setting.
The demands are collected for a given time period or block span, which is re-
ferred to as an epoch in this study. At the beginning of the following epoch these
demands are supplied resources in the Max-min Fairness order by a single node
(typically an authority node) in one step with the distribute function.

In the second algorithm, the demands are collected in a given epoch, and the
demanders claim their reserved share by calling a claim function in the claim
rounds of the following epoch. We call this approach Autonomous Max-min Fair-
ness (AMF), since there is no need for a central node to carry out the execution,
and the system is operated autonomously by its users. The operation of AMF
emulates the original algorithm identically, except for the last iteration where the

12

distribution is in the ﬁrst come ﬁrst served order among overdemanders. Origi-
nally, the last iteration is in the ascending order of demand volumes, as are all the
preceding iterations.

We implemented both unweighted as well as the weighted versions of Max-
min Fairness for the AMF. The reason for not implementing a weighted version of
CMF is due to its gas cost structure (elaborated on in Section 7.1). In the following
subsections we give the implementation details of the algorithms.

6.1. Conventional Max-min Fairness

As it is in the conventional setting, CMF utilizes two min-heaps, exchanging
the demands among each other in each iteration. The operation scheme and the
pseudo-code is the same as it is described in Section 5 (i.e. Figure 2 and Algorithm
1).

Since Solidity does not offer a built-in data structure for min-heaps, we im-
plemented it during the development of CMF. We kept the implementation of the
min-heap minimal in order to keep the gas cost at minimal. Only the amount of
demand, and the id (i.e. unique user number given to each user) of the demanding
user is stored and operated on. The remainder of the user attributes are fetched
from other data structures when needed (e.g. while writing to user balance), by
using the user id as the key.

We used an array implementation of heap, a complete binary tree, where the
values are kept in a node array and the insert and delete minimum functions are
implemented so that they index and move the nodes according to the min-heap or-
ganisation. This is also immune to degeneration attacks, in which case an attacker
feeds the tree with selective input to make one branch grow disproportionately,
forcing heap functions run in O(n) instead of O(log(n)) time.

We present the performance of CMF, as well as the min-heap, in Section 7.1.

6.2. Autonomous Max-min Fairness

In AMF, the epochs are divided into claim rounds. At the end of each round,
the remaining number of demands, the remaining capacity, and the resulting share
is recalculated. The rounds proceed in this manner until either the capacity is de-
pleted, or all demands are supplied. The rounds are used to emulate the iterations
of the outer loop (lines 4 − 20 of Algorithm 1) of the distribute function.

In order to avoid repetition, we give the pseudo-code only for the weighted
version (WAMF), since it is more general as compared to the unweighted version
(AMF), the latter being the same algorithm with fewer steps. The pseudo-code
of WAMF is presented in Algorithm 2. The symbols for the additional variables,

13

and their meanings are given in Table 4. The calculation of weights is obscured
from the pseudo-code for the ease of review, and the weights are simply shown
as constant variables. The calculation of weights is described in detail in the next
subsection.

In AMF, instead of a single-handedly operating distribute function, there is a
claim function, which after necessary checks, allows the user assign her allocated
share to herself. Each user is expected to execute the function individually, to have
carried out the iterations of the inner loop of the distribute function (lines 10 − 18
of Algorithm 1), in a decentralized manner.

Any share unclaimed in its due round/epoch is lost. It is included in the fol-
lowing round/epoch as part of the leftover capacity. In a given epoch, users may
make new demands for the next epoch, while claiming their share for the previ-
ous. The time frame can be traced in Table 3 over the demands and corresponding
claims, and can be seen more explicitly in Figure 3.

Demand 1

Round 1
Epoch 1 Claim 0 Round 2
Round 3

Demand 2

Round 1
Epoch 2 Claim 1 Round 2
Round 3

Demand 3

Round 1
Epoch 3 Claim 2 Round 2
Round 3

Demand 4

Round 1
Epoch 4 Claim 3 Round 2
Round 3

Demand 5

Round 1
Epoch 5 Claim 4 Round 2
Round 3

User 1 User 2 User 3 Share Capacity
15

11

4

11
4

7
10
1

17
7

..
13
4

3
10
1

8
3

13
8

..
13

8
10
3
2
12
8

5
12

..
5

10
3
2
10
10
9

12

..
13
10

30
6
2
0
30
9
8

38
11

41
10
6

Table 3: An exemplary distribution carried out with AMF

In AMF the demands are kept in a map, rather than a min-heap, since it is nec-
essary for each user to be able to access their own demand entry, while claiming it.
In the present implementation, the demands are kept for one epoch, and claimed
in the following. For this reason, a circular buffer of size two is kept for each

14

Time

(cid:45)

Epoch-1

Epoch-2

Epoch-3

Epoch-4

Epoch-5

Demand-1

Claim-1

Demand-2

Claim-2

Demand-3

Claim-3

Demand-4

Claim-4

...

...

Figure 3: Time frame for the matching demand and claim function calls

user, in order to prevent an incoming demand in a given epoch to overwrite the
previous epoch’s demand, before it is claimed. This leads to a two dimensional
(2 x n) demand vector, where the demands for even and odd epochs are kept sep-
arately. Additionally, the variable for keeping the epoch in which the demand was
made (for preventing an obsolete demand to interfere with later demands) is im-
plemented; likewise as a circular buffer of size two, in order to separate between
the even and the odd epochs.

In addition to the restructured demand, and the newly introduced claim func-
tions, AMF includes a state update function, which is called at the beginning of
both. The state update function checks the block number, and calculates the epoch
and the round in which the called function will be executed (lines 3 and 10, re-
spectively). The number of blocks for the duration of an epoch and a round, is
also a parameter of the system, which we experimented on in the present study,
and commented on in the results section.

The pseudo-code in Algorithm 2 is organised in three functions, namely, up-
date state (lines 1 − 15), demand (lines 16 − 24), and claim (lines 25 − 45). At
the beginning of each function (in lines 2, 18, and 27) a local selector variable
(i) for the circular buffers is declared and deﬁned. When called in a given epoch,
the state update and the claim functions assume the same selector values, and de-
mand function assumes its binary complement. That is to say i values proceed as
< 0, 1, 0, 1, ... > for the state update and claim functions, and as < 1, 0, 1, 0, ... >
for the demand function.

In line 3, the epoch number (E) is checked for. If the value of E is found to
be obsolete, it is updated. Once the epoch number is updated, the round number,

15

Symbol Meaning

C
B
O
E
R
RE
ES
RS
U
Wi
a
u
dui
deui
ceu
cru
bu
wu
c

Amount of resource that is added to the existing capacity at every epoch, C ∈ Z+
Current block number
The block number at which the contract was deployed, offset
Epoch number
Round number
Reset epoch, the epoch at which the total weight was last reset
Number of blocks in an epoch, epoch span
Number of blocks in a round, round span
Set of users u ∈ {u1, . . . , un}
Total weight for even and odd epochs, i ∈ {0, 1}
Demand volume, amount
User u, u ∈ U
Demand of user u in list i, i ∈ {0, 1}
The last epoch user u made a demand, i ∈ {0, 1}
The last epoch user u made a claim
The last round user u made a claim
Resource balance of user u, bu ∈ Z+
Weight of user u
The existing capacity, initialised at 0, incremented by C at every epoch

Table 4: Symbols used in Algorithm 2 and their meanings

the capacity, and the unit share are also updated (lines 5 − 7), and the function
returns. If epoch number is found to be up-to-date, a similar check is done for the
round number in line 10. This check, when it returns positive, leads to the update
of the round number and the unit share (lines 11 − 12), and the function returns.
If no update is required, the function returns without making any changes in the
state.

After updating the state and setting the selector variable, in line 19 the demand
function checks whether the user has made a demand in the then present epoch.
If the user has made a demand, the function returns without registering the newly
arrived demand. If not, the demand amount (a) is written to the corresponding
slot in the circular demand buffer of the user, and the demand epoch of the user
is updated to be the then current epoch (lines 20 − 21). In the following line the
function checks whether any demands have been made by other users in the then
current epoch. If not, the total weight is set to the user’s weight (line 23), which
resets the total weight variable for the next epoch. The variable for keeping the
last epoch in which the total weight is reset (RE) is updated in line 24. If demands
have been made by other users prior to the then current call (i.e. RE = E) the

16

weight of the user is added to the total weight, to be accounted for in the next
epoch (line 26).

The claim function, similar to the demand function, starts with updating the
state and initiating the selector variable. It continues with a number of checks (line
33). Unless the demand has been done in the previous epoch and is greater than
0, or if the capacity is depleted, the function returns without taking any further
action. Following that in line 36 the function checks whether the user has made
any claims in the then current epoch. If so, the last round the user made a claim
is checked (line 37). If that also turns positive, which means the user has claimed
her fair share for the round, the function returns without making any assignments.
If the check in line 36 turns out negative, meaning this is the user’s ﬁrst claim
in the then present epoch, the variable for the last epoch the user made a claim
(ceu) is updated (line 41). After that, a similar variable for the round (cru) is up-
dated in line 41. Next, the assignment operations similar to the ones in Algorithm
1 is done in lines 44 − 46.

Note that this algorithm differs from the CMF algorithm in that the leftover
demands are not inserted into another heap; they remain in the map. Instead, the
fully satisﬁed demands are removed from the cumulative weight variable in lines
42 − 44, having the same effect as deleting the minimum in CMF algorithm. This
way, as long as there is an unsatisﬁed demand, the user’s weight is included in the
total weight, and the unit share is calculated accordingly. At the end of the epoch,
all demands are obsoleted.

17

Algorithm 2: Weighted Autonomous Max-min Fairness (WAMF)
1 FU N C T I O N: UP D A T E ST A T E(O, B, E, ES, RS)
2 i ← E mod 2;
3 if E < (cid:4) B−O

4

5

6

7

11

12

8
9 end

10 if R <

ES

(cid:5) then
(cid:5);
(cid:106) (B−O)%ES
RS

E ← (cid:4) B−O
R ←

ES

c ← c + C;
s ← (cid:98)c/Wi(cid:99);
return

(cid:107)

(cid:106) (B−O)%ES
RS
(cid:106) (B−O)%ES
RS

R ←

s ← c/Wi;
return;

(cid:107)

;

then
(cid:107)

;

13
14 end
15 return;
16 FU N C T I O N: DE M A N D(u, a)
17 UP D A T E ST A T E(O, B, E, ES, RS);
18 i ← (E + 1) mod 2;
19 if deui (cid:54)= E then
dui ← a;
20
deui ← E;
if RE < E then
Wi ← wu;
RE ← E;

23

24

22

21

25

26

else

Wi ← Wi + wu;

end

27
28 end
29 return;
30 FU N C T I O N: CL A I M(u)
31 UP D A T E ST A T E(O, B, E, ES, RS);
32 i ← E mod 2;
33 if deui (cid:54)= E − 1 or c = 0 or dui = 0 then
34
35 end
36 if ceu = E then
37

return;

if cru = R then
return;

38

end

ceu ← E;

39
40 else
41
42 end
43 cru ← R;
44 bu ← bu + min (dui, s ∗ wu);
45 dui ← dui − min (dui, s ∗ wu);
46 c ← c − min (dui, s ∗ wu);
47 if dui = 0 then
48
49 end
50 return;

Wi ← Wi − wu;

18

6.3. Weighted Autonomous Max-min Fairness

As the operation of the algorithm is described in Section 6.2, the only part that

is left to be explained in this subsection is the calculation of weights.

We deﬁned weights to be the multiplicative inverses of the total demand vol-
ume, up to and including the then present demand. This poses a problem in the
smart contract context, since Solidity does not offer ﬂoating point data types. In
other words, since the demand volumes are deﬁned to be positive integers, it is
not possible to keep weights as they are, since the value needs ﬂoating point data
type to be stored. Instead, we keep the total demand volume for each user (dtu for
user u), introduce an intermediary variable p (standing for precision) and take the
weight equal to:

(cid:22) p
dtu
We get rid of this intermediary variable while calculating the unit share. There-

wu =

(cid:23)

fore, instead of

we use:

since

s =

(cid:23)

(cid:22)

c
u=1 wu

(cid:80)n

s =

(cid:23)

(cid:22) c · p
(cid:80)n

u=1 wu

(cid:36)

s =

c · p

(cid:80)n

u=1

p
dtu

(cid:37)

(cid:36)

=

(cid:37)

c

(cid:80)n

u=1

1
dtu

Similarly, while calculating the user share we use the intermediary variable p:

s ·






(cid:106) p
dtu
p

(cid:107)






su =

As long as the value of p is larger than the total demand volume of the user, we
. For p = 10k, k ∈ Z + is the number of
obtain non-zero weights from
decimal places stored for weights.

(cid:106) p
dtu

(cid:107)

19

7. Results

In this section, we present the results over the gas costs used as the main
performance metric. The tests are run on Parity Ethereum 2.7.2, and the contracts
are implemented using Solidity 0.5.13, thus the gas costs are according to the
deﬁnitions given thereby.

In our tests, we run Parity in development mode and used its instant seal con-
sensus algorithm, in which each transaction is placed in an individual block and
inserted instantly to the blockchain. A convenient metric for measuring time is
the block number. In the deployment of the system, this metric can be used with
the block latency to come up with rough temporal estimations.

Since block latency is a policy parameter for each blockchain ecosystem, tak-
ing block number as the main temporal performance metric is convenient also in
terms of generalizability of the results. As it is presented here, our results are
independent of consensus algorithm, and block latency parameters.

The results for each algorithm are presented in the subsections below. The

data are available at [39]

7.1. CMF Results

As indicated in Section 6.1, in the CMF, the demand vector is implemented
as an array of two min-heaps, exchanging the demands among each other at each
iteration. The demands arriving from the users are collected in D0 for the span of
an epoch. At the end of the epoch, the distribute function is called by the authority
node, and the distribution is done. The ﬁrst iteration is done over D0, taking all
demands from the smallest to the largest, granting the available share to the user,
and ﬁnally either deleting the minimum demand, if it is completely supplied, or
deleting it from D0 and inserting it to D1, otherwise, to be supplied in the next
iterations if possible. The heaps exchange functions, and the process is repeated
until either all the demands are supplied, or the capacity for the epoch is exhausted
(see Algorithm 1)

Gas usage averages for n = 100 entry sets are shown in Table 5. For com-
parison, the gas performance of a general case heap implementation [40], called
Eth-heap, is provided next to our results:

Considering the 8.000.000 block gas limit, the heap operations impose an up-
per bound of 60 entries to be processed per block, on average, as seen with the cost
of operations in Table 5. This number is to be further lowered with the additional
cost of assignment operations, needed to record the fair share of each user to her
balance.

20

Function Present Study Eth-heap
101.261
170.448

95.459
133.272

Insert
Delete Minimum

Table 5: Average gas costs for Insert and Delete Minimum functions

The ﬁnding immediately implies that an algorithm implemented as a smart
contract and relying on a central node to carry out the distribute function, cannot
support more than ∼ 10 users, assuming that 3 iterations are necessary on average
for a distribution process to complete. The exact number is a function of how dis-
perse the demands are, since the number of delete/insert operations is dependent
on the number of iterations necessary to answer all the demands, which in turn is
dependent on how disperse the demands are.

This is also the reason why a weighted version of CMF has not been imple-
mented in the present study. The extra cost of calculating and storing weights will
make the weighted version perform even worse than the unweighted version.

7.2. AMF and WAMF Results

The ﬁrst advantage to be pointed out for AMF is that it virtually has no limit
for the number of users that the system can support. The average gas costs of
demand and claim functions for a system with 10, 50, 100 and 500 users can be
seen in Table 6. The tests have been carried over in a setting where users have
made demands, and claimed their demands in the succeeding epoch. The results
indicate that several demand and claim function calls can be included within a
block, without running into the block gas limit exhaustion problem.

Function

Demand

Claim
(Avg./Total)

No. of Users
10
50
100
500
10
50
100
500

AMF
70.245
67.351
66.989
66.700
46.800/140.401
42.240/126.720
42.114/126.344
42.047/126.143

WAMF
79.732
77.135
76.835
71.365
46, 643/145.931
44.852/134.558
44.763/134.289
45.319/135.959

Table 6: Average and total gas costs of AMF/WAMF demand and claim functions for various
numbers of users.

21

The results also indicate that the cost of demand and claim functions do not
grow with the growing number of users. On the contrary, there is a slight decrease
in the average costs, with the growing number of users. The reason for this is
the fact that in each epoch the ﬁrst call to both functions are costlier, since state
variables are updated in these calls. With large sample sizes, this difference tends
to even out better as compared to the relatively smaller sample sizes.

It should also be noted that the epochs and rounds should last enough for each
user to be able to make claims and demands. Since the instant seal engine de-
ployed in the tests place each transaction in an individual block, the epoch and
round spans are so chosen as to allow each user be able to make claims and de-
mands within an epoch. The parameters of the system that the tests have been
carried on have been shown in Table 7.

According to this, in a setting with n users, in the ﬁrst epoch, n blocks are
used for user registration function calls and 2n blocks are ﬁlled with empty trans-
actions in order to synchronise the process. The following demand function calls
occupied n more blocks, concluding the ﬁrst epoch. From the second epoch on,
the sequence is 3 rounds of claim in 3n blocks, followed by n blocks of demand
for the next epoch. Three sets are run (adding up to 4 epochs), and the averages
are collected.

Parameter
Number of Users

Epoch Capacity

Epoch Span

Round Span

Demand Interval

Value Deﬁnition

n The number of users

in the system
20n The amount

to be
distributed for each
epoch

4n The duration of an
epoch in number of
blocks

n The duration of a
round in number of
blocks

[10, 30) The interval

from
which the demands
are drawn

Table 7: The values used in the tests for AMF and WAMF.

One thing that should be accounted for is that the average cost of demand

22

function declines throughout the rounds. The reason for this is, some demands
have been fully supplied in the previous epoch, thus, fewer calls to claim function
lead to the full execution of the function (i.e. calls from users whose demands
have already been satisﬁed return without making any assignments). The average
claim costs of rounds for Max-min and Weighted Max-min Fairness schemes can
be seen in Table 8.

Round
1
2
3
Average
Total

AMF WAMF
67.211
64.677
36.158
32.717
32.589
28.749
45.319
42.047
135.959
126.143

Table 8: The costs of the claim functions over rounds, in a setting with n = 500 users.

The number of rounds, as indicated in Section 7.1 is a function of the initial
distribution of the demands. In our tests, we drew random demands from an ap-
proximately uniform distribution offered by Javascript Math.random() function,
in the range [10, 30), and the epoch capacity is set to 20n, so that on average the
overdemands and underdemands could balance each other out.

In all the simulations with a Python script, the distribution is completed in 3
iterations. Therefore, in the tests presented here, we run the system for 3 rounds
of claims. The results are cross-checked with the Python simulations and proved
identical. We suspect that with the parameters used in this study, 3 iterations might
be an upper bound, but we do not have a proof. Further investigation needs to be
carried out to in order to come up with a theoretical bound.

Another variable that can be parameterized according to the policy and that
would effect gas costs is the size of the variables used to represent amounts. The
size of the variables can be chosen smaller to save from the extra cost of unused
space. The necessary sizes for the variables is dependent on the total amount that
is planned to be distributed in the long run, maximum available allocation in an
epoch and the maximum number of epochs to distribute all the resource etc. In the
present study, all the variables are implemented as their 256 bit defaults, in order
not to lose generality.

23

8. Discussion

The main bottleneck, and the main performance metric of the present study
is the gas consumption, and this is arguably a natural approach for studies on
blockchain systems. However, the results presented in this study are not to be
taken for their absolute values. Low level improvements may be introduced in
coding or compilation, leading to lower transaction costs. The aim of this ap-
proach is to demonstrate the availability, and the cost structure of the Max-min
Fairness algorithm, and its different implementations.

Accordingly, the present study demonstrates, over the failure of CMF to sup-
port more than 10 users, that it is not feasible for Max-min Fairness scheme
to be implemented in the blockchain context as it is implemented in the con-
ventional computational settings.
In principle, because of the block gas limit,
blockchain systems are not well suited for algorithms, which cannot be efﬁciently
distributed to be processed by multiple computing parties, with partial data, and
asynchronously. A single transaction to carry out a function with heavy computa-
tional burden is not a working strategy while developing software for blockchain
systems.

This is in accordance with the distributed nature and the philosophy of the
blockchain systems. In contrast with the centralized systems, blockchains aim to
distribute both the work and the control among its users. For this reason, they are
incentive driven, as opposed to centralized systems, which are authority driven.
That is to say, centralized systems rely on an authorized component (e.g. operating
system kernels, load balancers, web servers etc.) to carry out the computation;
whereas blockchain systems rely on incentivising its users to operate the system
in a way that the outcome will turn out to be the desired computation. Both AMF
and WAMF are designed taking those points into consideration. Consequently,
they offer scalable solutions for blockchain systems.

Another possibility to consider is changing the capacity replenishment policy.
In the present study, the capacity is replenished by a constant quantity C at the
beginning of each epoch. Instead, the tests can be run with varying quantities of
replenishment over time, possibly according to some function of epoch number
(i.e. C = f (E)). This may serve as a distribution mechanism for systems that run
on donations, like election rallies or other types of fund raising projects, where
public transparency, responsibility, incentivisation, and participation are matters
of consideration. This kind of a distribution mechanism lends these projects the
opportunity to be publicly transparent, and make commitments (e.g. declaring the
weights for the expenditure items) prior to raising funds, since the system assures

24

the enforcement of declared commitments, by the virtue of its immutability.

9. Conclusion

In the present study we addressed the problem of fair distribution of shared
resources within the blockchain systems context. We worked on the intrinsic re-
sources of blockchains, and developed faucets as smart contracts, running dif-
ferent implementations of Max-min Fairness Algorithm, which is traditionally
accepted realizing fairness in the literature.

It has been demonstrated that the Max-min Fairness algorithm, as it is imple-
mented in the conventional programming contexts, cannot support a public system
because of the scaling of its gas cost structure. Two autonomous implementations
of the algorithm are offered as a solution, and the tests have shown that these
implementations can support wide public use of the system without running into
block gas limit exhaustion problem.

Although, in the present, the faucets are mainly utilised as tools for distributing
the native currency of the test networks, the operation of faucet systems need
not be limited to this use case. These systems have the ability to represent any
resource type, and accordingly, to fairly allocate them, as brieﬂy discussed in the
preceding section.

The faucet algorithms presented in this study are designed for single resource
planning. For the prospective studies we might propose focusing on multi-resource
planning problems. One way would be keeping each resource type separate and
distribute them in parallel, with the algorithms developed in the present study.
This will assume an independence of the supply and the value of the resources. If
the resources are dependent on each other, alternative solutions must be proposed
and evaluated.

References

[1] S. Nakamoto, et al., Bitcoin: A peer-to-peer electronic cash system, 2008.

[2] G. Wood, et al., Ethereum: A secure decentralised generalised transaction

ledger, Ethereum project yellow paper 151 (2014) 1–32.

[3] J. L. Friederike Kleinfercher,
the

trusted

whitepaper,
research
//bloxberg.org/wp-content/uploads/2020/02/bl\

infrastructure,

v1.1,

Sandra Vengadasalam, Bloxberg
https:

25

oxberg$_$whitepaper$_$1.1.pdf,
1-March-2020].

2020.

[Online;

accessed

[4] Bloxberg, Bloxberg Faucet, https://faucet.bloxberg.org/,

2020. [Online; accessed 17-September-2020].

[5] D. P. Bertsekas, R. G. Gallager, P. Humblet, Data networks, volume 2,

Prentice-Hall International New Jersey, 1992.

[6] S. Keshav, S. Kesahv, An engineering approach to computer network-
ing: ATM networks, the Internet, and the telephone network, volume 116,
Addison-Wesley Reading, 1997.

[7] M. Crosby, P. Pattanayak, S. Verma, V. Kalyanaraman, et al., Blockchain

technology: Beyond bitcoin, Applied Innovation 2 (2016) 71.

[8] G. Foroglou, A.-L. Tsilidou, Further applications of the blockchain, in: 12th
student conference on managerial science and technology, 2015, pp. 1–8.

[9] T.-T. Kuo, H.-E. Kim, L. Ohno-Machado, Blockchain distributed ledger
Journal of the

technologies for biomedical and health care applications,
American Medical Informatics Association 24 (2017) 1211–1220.

[10] D. D. F. Maesa, P. Mori, L. Ricci, Blockchain based access control,

in:
IFIP international conference on distributed applications and interoperable
systems, Springer, 2017, pp. 206–220.

[11] M. Samaniego, R. Deters, Virtual resources & blockchain for conﬁguration
management in iot., J. Ubiquitous Syst. Pervasive Networks 9 (2018) 1–13.

[12] M. Shirole, M. Darisi, S. Bhirud, Cryptocurrency token: An overview, in:
IC-BCT 2019: Proceedings of the International Conference on Blockchain
Technology, Springer Nature, 2020, p. 133.

[13] E. L. Hahne, Round-robin scheduling for max-min fairness in data networks,

IEEE Journal on Selected Areas in communications 9 (1991) 1024–1039.

[14] R. Gogulan, A. Kavitha, U. K. Kumar, Max min fair scheduling algorithm
using in grid scheduling with load balancing, International Journal of Re-
search in Computer Science 2 (2012) 41.

26

[15] C. A. Waldspurger, Lottery and stride scheduling: Flexible proportional-
share resource management, Ph.D. thesis, Massachusetts Institute of Tech-
nology, 1995.

[16] J. Kay, P. Lauder, A fair share scheduler, Communications of the ACM 31

(1988) 44–55.

[17] D. Nace, M. Pi´oro, Max-min fairness and its applications to routing and
load-balancing in communication networks: a tutorial, IEEE Communica-
tions Surveys & Tutorials 10 (2008) 5–17.

[18] N. D. Doulamis, A. D. Doulamis, E. A. Varvarigos, T. A. Varvarigou, Fair
IEEE Transactions on Parallel and Dis-

scheduling algorithms in grids,
tributed Systems 18 (2007) 1630–1648.

[19] P. Marbach, Priority service and max-min fairness, in: Proceedings. Twenty-
First Annual Joint Conference of the IEEE Computer and Communications
Societies, volume 1, IEEE, 2002, pp. 266–275.

[20] A. Ghodsi, M. Zaharia, B. Hindman, A. Konwinski, S. Shenker, I. Stoica,
Dominant resource fairness: Fair allocation of multiple resource types., in:
Nsdi, volume 11, 2011, pp. 24–24.

[21] S. Mohanty, S. C. Moharana, H. Das, S. C. Satpathy, Qos aware group-
based workload scheduling in cloud environment, in: Data Engineering and
Communication Technology, Springer, 2020, pp. 953–960.

[22] A. Hayes, What factors give cryptocurrencies their value: An empirical

analysis, Available at SSRN 2579445 (2015).

[23] Paritytech, parity ethereum, https://github.com/paritytech/
pa-rity-ethereum, 2019. [Online; accessed 19-November-2019].

[24] L. Ren, S. Devadas, Proof of space from stacked expanders, in: Theory of

Cryptography Conference, Springer, 2016, pp. 262–285.

[25] A. Kiayias, A. Russell, B. David, R. Oliynykov, Ouroboros: A provably
in: Annual International Cryp-

secure proof-of-stake blockchain protocol,
tology Conference, Springer, 2017, pp. 357–388.

[26] S. King, S. Nadal, Ppcoin: Peer-to-peer crypto-currency with proof-of-stake,

self-published paper, August 19 (2012) 1.

27

[27] M. Kr´ol, A. Sonnino, M. Al-Bassam, A. Tasiopoulos, I. Psaras, Proof-of-
prestige: A useful work reward system for unveriﬁable tasks, in: 2019 IEEE
International Conference on Blockchain and Cryptocurrency (ICBC), IEEE,
2019, pp. 293–301.

[28] I. Bentov, C. Lee, A. Mizrahi, M. Rosenfeld, Proof of activity: Extend-
ing bitcoin’s proof of work via proof of stake [extended abstract] y, ACM
SIGMETRICS Performance Evaluation Review 42 (2014) 34–37.

[29] M. Ball, A. Rosen, M. Sabin, P. N. Vasudevan, Proofs of useful work., IACR

Cryptol. ePrint Arch. 2017 (2017) 203.

[30] A. Abdul-Rahman, The pgp trust model,

in: EDI-Forum: the Journal of

Electronic Commerce, volume 10, 1997, pp. 27–31.

[31] C. Dannen, Introducing Ethereum and Solidity, Springer, 2017.

[32] L. Baird, M. Harmon, P. Madsen, Hedera: A governing council & public
hashgraph network, The trust layer of the internet, whitepaper 1 (2018) 1–
97.

[33] T. Foundation, Tron: Advanced decentralized blockchain platform, 2018.

[34] R. Cheng, F. Zhang, J. Kos, W. He, N. Hynes, N. Johnson, A. Juels,
A. Miller, D. Song, Ekiden: A platform for conﬁdentiality-preserving, trust-
worthy, and performant smart contracts,
in: 2019 IEEE European Sympo-
sium on Security and Privacy (EuroS&P), IEEE, 2019, pp. 185–200.

[35] F. A. Niloy, M. A. Nayeem, M. M. Rahman, M. N. U. Dowla, Blockchain-
based peer-to-peer sustainable energy trading in microgrid using smart con-
tracts,
in: 2021 2nd International Conference on Robotics, Electrical and
Signal Processing Techniques (ICREST), IEEE, 2021, pp. 61–66.

[36] M. W¨ohrer, U. Zdun, Design patterns for smart contracts in the ethereum
in: 2018 IEEE International Conference on Internet of Things
ecosystem,
(iThings) and IEEE Green Computing and Communications (GreenCom)
and IEEE Cyber, Physical and Social Computing (CPSCom) and IEEE
Smart Data (SmartData), IEEE, 2018, pp. 1513–1520.

[37] M. Wohrer, U. Zdun, Smart contracts: security patterns in the ethereum
in: 2018 International Workshop on Blockchain

ecosystem and solidity,
Oriented Software Engineering (IWBOSE), IEEE, 2018, pp. 2–8.

28

[38] S. Bragagnolo, H. Rocha, M. Denker, S. Ducasse, Smartinspect: solidity
in: 2018 International Workshop on Blockchain

smart contract inspector,
Oriented Software Engineering (IWBOSE), IEEE, 2018, pp. 9–18.

[39] S. Metin, blockchainfaucet, 2020. URL: https://github.com/

serdarmetin/blockchainFaucet.

[40] Z. Mitton, Priority Queue on Ethereum: eth-heap, 2018. URL: https:

//github.com/zmitton/eth-heap.

29

