BOSS: A Blockchain Off-State Sharing System

Shan Wang∗‡, Ming Yang∗, Tingjian Ge‡, Yan Luo‡, Xinwen Fu‡
∗ Southeast University. Email: shanwangsec@gmail.com, yangming2002@seu.edu.cn
‡University of Massachusetts Lowell. Email:{Yan Luo, Xinwen Fu}@uml.edu, ge@cs.uml.edu

1
2
0
2

p
e
S
5
1

]

R
C
.
s
c
[

1
v
6
2
6
7
0
.
9
0
1
2
:
v
i
X
r
a

Abstract—Blockchain has been applied to data sharing to
ensure the integrity of data and chain of custody. Sharing big data
such as large biomedical data ﬁles is a challenge to blockchain
systems since the ledger is not designed to maintain big ﬁles,
access control is an issue, and users may be dishonest. We call
big data such as big ﬁles stored outside of a ledger that includes
the blockchain and world state at a blockchain node as “off-state”
and propose an off-state sharing protocol for a blockchain system
to share big data between pairs of nodes. In our protocol, only
encrypted ﬁles are transferred. The cryptographic key is stored
in the world state in a secure way and can be accessed only by
authorized parties. A receiver has to request the corresponding
cryptographic key from the sender to decrypt such encrypted
ﬁles. All requests are run through transactions to establish
reliable chain of custody. We design and implement a prototypical
blockchain off-state sharing system, BOSS, with Hyperledger
Fabric. Extensive experiments were performed to validate the
feasibility and performance of BOSS.

Index Terms—Blockchain, Big File Sharing, Off-state, Hyper-

ledger Fabric

I. INTRODUCTION

A blockchain system can build trust in the data that it
maintains without a centralized authority. Data in conventional
blockchain systems is often stored in a ledger, which includes
a world state and a blockchain. The world state stores the
current system state such as the user cryptocurrency balance
in Bitcoin [1] and the blockchain saves all transaction history,
which contains operations on the world state and/or the data
used to update the world state. The whole transaction history
produces the current state values and can work as auditing
evidence. The ledger is often synchronized across all nodes.
Blockchain has been applied to a variety of data sharing
applications such as healthcare. A blockchain data sharing
system can prevent information tampering for the purpose of
auditing and establish the chain of custody, which refers to the
documentation that records the sequence of custody, transfer,
and other operations on the data. In these systems, shared data
is stored in the world state database. Users set or get shared
data through proposing transactions to the blockchain system.
The existing blockchain frameworks cannot be directly ap-
plied to big ﬁle sharing. Big ﬁles can be scientiﬁc and biomed-
ical data being collected and processed. Sharing such data
allows independent veriﬁcation of published scientiﬁc results
and enhances opportunities for new discoveries. With concerns
of intellectual property (IP) theft and industrial espionage, we
desire secure and trustworthy big ﬁle sharing systems that
record the chain of custody of the big ﬁles. However, given the
storage design of the ledger, it is impractical to store big ﬁles
in the world state and to use transactions to carry big ﬁles. A

blockchain system often maintains the same ledger across all
nodes. However, because of privacy, IP and storage concerns,
owners may not want to share those big ﬁles across all nodes.
A token based data sharing blockchain system has been
brieﬂy discussed in related work [2]. Shared data is stored
outside the blockchain system at a data center. This system
has the following issues: (i) It requires a centralized and
trusted data center. (ii) No actual protocols using tokens
are documented. (iii) The data center based approach is not
ﬂexible. In scenarios such as ﬁle sharing in biomedical ﬁelds,
to share data between each other’s
researchers may want
computers directly. There is no detail of the token based
sharing protocol in [2].

In this paper, we propose a novel big ﬁle sharing model.

Our major contributions can be summarized as follows.

1) We introduce a new concept “off-state” to a blockchain
system. A blockchain node may maintain a separate
storage from the ledger to store off-states such as big ﬁles,
which are outside of the ledger, particularly the world
state. Off-states do not need to be synchronized across
all nodes. Smart contracts manage sharing of off-states
such as big ﬁles.

2) To ensure the integrity and chain of custody of off-
states, we propose a novel off-state sharing protocol.
Off-sates are encrypted and signed before sharing. The
cryptographic key is stored in the world state database
and users have to request the key through transactions in
order to decrypt the transferred ﬁles. Mechanisms such as
private data collection (PDC) in Hyperledger Fabric [3]
can be used to ensure that the cryptographic key is kept
private and not publicly disclosed. These mechanisms
also defeat dishonest users.

3) We implement a prototypical blockchain off-state sharing
system (BOSS) with Hyperleger Fabric running our off-
state data sharing protocol. Extensive experiments are
performed to evaluate BOSS’ feasibility and performance
such as latency of the big ﬁle transfer between pairs of
blockchain nodes and parallel ﬁle transfer.

The rest of this paper is organized as follows. Section II in-
troduces the background knowledge. Section III introduces the
off-state sharing system model. The off-state sharing protocol
is presented in Section IV. We evaluate the prototypical off-
state sharing system, BOSS, in Section V. We discuss a few
related topics such as the execution timeout of chaincode (i.e.
smart contract in Hyperledger Fabric) in Section VI. Section
VII presents the related work. We conclude this paper in

 
 
 
 
 
 
Section VIII.

II. BACKGROUND

In this section, we introduce the data in blockchain systems,
storage limitations of a ledger, and Hyperledger Fabric, which
is a permissioned blockchain framework. For brevity, we will
call Hyperledger Fabric as Fabric in the rest of the paper.

A. Data in Conventional Blockchain Systems

A blockchain system is essentially a state machine repli-
cated across different nodes [4]. The state machine can be
formally deﬁned in Formula (1).

AP P LY (S, T x) → S(cid:48)orERROR,

(1)

where the state transition function AP P LY (.) takes a state
S and a transaction T x and outputs a new state S(cid:48) or an
error. A ledger includes a world state and a blockchain. The
world state stores the current state. The blockchain stores all
historical transactions. In Bitcoin [1], the world state is the
user cryptocurrency balance recorded in the UTXO (unspent
transaction output) ﬁeld of transactions. State transitions are
cryptocurrency transfers. In Ethereum [4], the world state is
made up of “accounts”. An account contains the cryptocur-
rency balance, code and data in smart contracts and others.
State transitions are direct transfers of values and information
between accounts controlled by smart contracts. In Fabric [3],
each peer node maintains a world state database. A transaction
records the operation of invoking a function in smart contract,
called chaincode in Fabric, which may work on the world state.

B. Storage Limitations of Conventional Blockchain Systems

In current blockchain frameworks, the data size and type
in ledgers are limited. We now show the limitations in three
popular blockchain frameworks, Bitcoin, Ethereum and Fabric.
1) World State Storage Limitation: In Bitcoin, the world
state UTXOs are just values in transactions indicating the
Bitcoin balance. It’s impossible to store large ﬁles in UTXOs.
In Ethereum, the world state consists of user accounts and
contract accounts. A user account only records the Ether
balance of the user. The contract account can store pairs of
keys and values of 32 bytes used by the smart contract [5].
Ethereum is not designed to store big ﬁles.

In Fabric,

the world state is stored in a database,

i.e.
LevelDB or CouchDB. LevelDB can only store simple key-
value pairs. CouchDB can store data in the JSON format, but
limits the maximum document body size to 8M bytes [6].
Fabric cannot store big ﬁles either.

2) Transaction and Block Size Limitation:

In Bitcoin,
to prevent attacks like DoS attacks and memory exhaustion
attacks, it restricts the block size to 1MB and transactions
greater than 100 KB are considered non-standard [7], [8].

In Ethereum, the gas consumed by a transaction is related
to the size of the data stored in the world state. It is quite
expensive to store big data. According to the yellow paper [9],
it requires 16 gas units for storing every non-zero byte of data
for a transaction. Storing 1MB (1024×1024 = 1048576 bytes)

Fig. 1. Three-phase transaction workﬂow in Fabric

data requires 16,777,216 gas units in addition to other fees.
Each block has a block gas limit, which limits the block size
too. The current block gas limit is 12,491,593 gas units/block
[10]. It means a block can maximally store about 0.74MB
data (12491593 ÷ 16777216 ≈ 0.74).

In Fabric, the preferred maximum size of each transaction
is 512KB while the absolute maximum transaction size
is 99MB. Nodes in Fabric adopt the grpc communication
protocol. The maximum inbound grpc message size is 100MB
[11]. Large transactions will decrease the system performance
in terms of transaction throughput [12].

C. Hyperledger Fabric

Fabric [3] is a popular permissioned blockchain framework.
It decouples the tasks of a node in blockchain systems such
as Ethereum [4] into three types of nodes, i.e. peers, orderers
and clients in charge of different tasks. Peers maintain ledgers
and smart contracts.

a

adopts

Transaction Workﬂow: Fabric

three-phase
“execute-order-validate” transaction workﬂow as shown in
Fig. 1: (1) A client/user proposes a transaction proposal to
the endorsers, which are speciﬁc peers and speciﬁed by the
endorsement policy; (2) The endorsers execute the chaincode,
sign the execution results, and return the results with
corresponding signatures to the client as proposal responses;
(3) If the returned execution results from different endorsers
are the same,
the client constructs a transaction, which
contains both the transaction proposal, proposal response
and a list of signatures (endorsements). The client sends the
transaction to the orderer nodes. (4) The orderer nodes collect
multiple transactions within a time period, bundle them into a
new block, and distribute the new block to all peers including
both endorsers and non-endorsers. (5) All peers validate the
transactions
transactions in the received new block. If all
are valid, each peer will update the world state according to
execution results. After validating all transactions, each peer
appends the new block to its local blockchain.

Peer 1 Peer2ClientTransaction ProposalTransaction ProposalTransactionBlock GenerationTransactionValidationChaincode ExecutionChaincode ExecutionProposal ResponseOrdererProposal ResponseTransactionGenerationBlockBlockTransactionValidationNotificationThree features of Hyperledger Fabric enable it suitable to

implement our blockchain big ﬁle sharing system.

1) Fine-grained data isolation: The Fabric introduces a
ﬁne-grained data isolation mechnism, i.e., private data collec-
tion (PDC). PDC data is sensitive and shared by only a subset
of peer nodes. A PDC is stored in the world state. Only PDC
member peers can store the original data, while PDC non-
member peers can only store the data hashes.

2) Customizable smart contracts: Smart contracts, also
called chaincode in Fabric, do not need to be identical at all
peers as long as the execution results across different endorser
peers are the same. Therefore, different peers can perform
different roles and tasks.

3) Multi-level endorsement policy: There are multiple lev-
els of endorsement policies in Fabric. An endorsement policy
stipulates which peers need perform as endorsers to endorse
a transaction. Endorsing involves executing smart contracts
and signing the execution results. Each smart contract has a
default chaincode-level endorsement policy that manages all
public data and PDC data in the world state. A collection-level
endorsement policy can be customized to speciﬁcally manage
the PDC data.

III. OFF-STATE DATA SHARING SYSTEM MODEL

In this section, we ﬁrst investigate the existing blockchain-
based big ﬁle sharing systems and their drawbacks. We then
present the challenges in big ﬁle sharing through blockchain
systems, and ﬁnally propose a new big ﬁle sharing model
through blockchain.

A. State-of-the-art Blockchain Based Big File Sharing Systems

Fig. 2 shows a blockchain-based data sharing model utiliz-
ing access tokens [2]. A user proposes a transaction to request
a token for data access. The transaction proposal
triggers
particular functions in the smart contract, which returns an
access token to the user. The user then uses the access token
to request the shared data from a data center, which is outside
of the blockchain system. This data sharing model may be
used for big ﬁle sharing.

The token based ﬁle sharing blockchain model has the
following issues: (i) It requires a centralized and trusted data
provider. The data center is controlled by the data provider.
The Blockchain system has no control over the actual data
access and cannot know the status of data sharing, e.g. whether
the data is actually shared. The integrity of chain of custody
cannot be ensured and audited, (ii) There is no detailed
presentation of the actual protocol in [2]. (iii) The data center
based approach is not ﬂexible. In scenarios such as ﬁle sharing
in biomedical ﬁelds, data owners may want to share data
between their workstations.

B. Design Challenges

We identify three challenges for a blockchain-based big ﬁle

sharing system.

Fig. 2. Token based blockchain data sharing system

1) Challenge 1—Storage Space Limitation: Big ﬁles refer
to ﬁles of large size, such as videos and biomedical data
ﬁles. Due to the storage limitations of ledgers as discussed
in Section II-B, it is impractical to store big ﬁles in ledgers
or pack big ﬁles in transactions.

2) Challenge 2—Privacy Requirement: Big ﬁles may be
sensitive. The owner may not want to share with everyone
and access control will be preferred. However, in a conven-
tional blockchain system, all nodes maintain the same data.
Therefore, the blockchain system cannot be directly used for
big ﬁle sharing.

3) Challenge 3—Security Requirement: In big ﬁle sharing,
the receiver of the big ﬁles may be dishonest and may
dishonestly deny she/he received the ﬁles from the owner.

C. Off-State Sharing System Model

We introduce the concept of “off-state”, which is stored at
blockchain nodes, but outside of ledgers, particularly the world
state. For example, the off-state can be big ﬁles. Therefore, we
generalize big ﬁle sharing as off-state sharing. Off-states can
be inconsistent across blockchain nodes and shared between
pairs of nodes. Smart contracts at blockchain nodes can
interact with off-states and perform the sharing operation.

Fig. 3 shows our novel blockchain system model that can
address the three challenges above for off-state data sharing.
Each node maintains a world state database and an off-state
storage space when needed. Nodes maintain their off-state data
individually. Users propose transactions to trigger the smart
contracts to transfer the ﬁles. The smart contracts at the sender
node transfers off-state data to the receiver node through a ﬁle
transfer protocol, not through transactions.

To summarize, we address the three challenges as follows.

World StateWorld StateWorld StateSmart ContractNode2Smart ContractNode3Smart ContractNode1TX1TX1TX1Data CenterUsersTX1: request accessaccess tokenshared data  access tokenFig. 3. Blockchain-based off-state sharing model

• To address Challenge 1—storage space limitation, we
introduce the concept of ‘off-state” and save big ﬁles off
the ledger.

• To address Challenge 2—privacy requirement, our proto-
col allows off-states to be shared between pairs of nodes,
not across all blockchain nodes. This feature saves storage
space at nodes that do not need off-state data.

• To address Challenge 3—security requirement, our pro-
tocol establishes the chain of custody of the off-state data
and records auditing evidence in the blockchain.

We will present the detailed off-state data sharing protocol in
Section IV.

IV. OFF-STATE SHARING PROTOCOL

Our protocol has two stages. In Stage 1, an owner prepares
the ﬁles to be shared with users and uploads the ﬁles to sender
peer nodes. In Stage 2, to establish the chain of custody,
a sender peer transfers an encrypted ﬁle to a receiver peer
and stores the symmetric encryption/decryption key (called
encryption key for brevity in the rest of the paper) in the
world state. A user has to request the encryption key through
a transaction to get the key, decrypt the encrypted ﬁle and
get the original ﬁle. These transactions establish the chain
of custody. In this section, we ﬁrst present the two stages
and then perform the security analysis. We use Fabric to
present particular protocol details and discuss the use of other
blockchain frameworks for the protocol in Section VI.

A. Stage 1: Preparing Off-State Data

A data owner uploads big ﬁles to the off-state storage
of her/his own blockchain node. The user also proposes a
transaction—“Tx: ﬁle upload”—to record the proﬁle of an
uploaded ﬁle into the world state. The ﬁle proﬁle in the
world state is public for searching. Fig. 4 illustrates the File
Profile entry in the world state,
(cid:104)file_name, H(F ),
owner, access_rule, description(cid:105), where H(F )

Fig. 4. Cryptographic lock mechanism for off-state

TABLE I
SUMMARY OF MAIN SYMBOLS.

Symbol
F
H(F )
Kaes
Fenc
H(Fenc)
Kprivate
Kpublic
Signature(Fenc)

Description
File to be transferred
Hash of F
Symmetric key
File encrypted using Kaes
Hash of Fenc
Private key to sign Fenc
Public key to verify digital signature
Digital signature of Fenc

is the hash of the ﬁle. H(F ) can be used to verify the integrity
of a received ﬁle.

B. Stage 2: Sharing Off-State Data

Fig. 5 shows the workﬂow of sharing off-state data, e.g.
a big ﬁle, in Fabric. It involves four transactions. These four
transactions follow the same transaction lifecycle as introduced
in Section II-C. However endorsers in each transaction can be
different according to the speciﬁc endorsement policy setting.
Fig. 5 shows which peers perform as endorsers to execute the
chaincode in each transaction lifecycle.

1) Phase 1: File Transfer Request: A user shall request
the transfer of a particular ﬁle stored at the sender peer and
the request shall pass the access control. In Fabric, a user can
propose a transaction to request a particular ﬁle, and the access
control is governed by a speciﬁc endorsement policy. For ex-
ample, the endorsement policy can be set as AND(Peer.Sender,
Peer.Receiver), which stipulates both sender peer and receiver
peer should agree on the ﬁle transfer. An endorser checks
if access rules in the corresponding File Profile are
satisﬁed through smart contracts, and records the results in an
Event entry of the world state. An Event entry is in the
(cid:104)event_ID, flag, file_name, sender,
form of
receiver(cid:105) as shown in Fig. 4, where the f lag is a Boolean
value indicating if the endorser permits the ﬁle transfer.
According to the transaction workﬂow in Fabric introduced
in Section II-C, when results (i.e. Event entry) returned
from different endorsers are the same, the transaction can
be generated, processed and recorded in a blockchain. The
same Event entries mean the sender and receiver reach a

Off-StateWorld StateNode1Off-StateWorld StateNode2Off-StateWorld StateNode3fileWorld StateWorld StateWorld StateSmart ContractNode2Smart ContractNode3Smart ContractNode1TXTXTXTXF2F1F3Off-StateOff-StateOff-StateF1Sender PeerReceiver PeerUserfile name𝐻(𝐹)owneraccess ruleevent ID𝑓𝑙𝑎𝑔file namesenderreceiverkey ID𝐻(𝐹𝑒𝑛𝑐)𝑲𝒂𝒆𝒔𝐾𝑝𝑢𝑏𝑙𝑖𝑐Signature(𝐹𝑒𝑛𝑐)𝐹𝑒𝑛𝑐𝐹sendlockdescriptionevent IDFile ProfileEventEncryption Key4) Phase 4: File Decryption: Finally, the user proposes
the last transaction —“Tx: ﬁle decryption”—to query Kaes
to decrypt Fenc. In Fabric, the endorsement policy can be
set as AND(Peer.Receiver) so that the receiver peer performs
as an endorser, which can access Fenc in its off-state stor-
age using smart contract. The receiver peer ﬁrst queries the
Encryption Key entry in the world state for Kaes and
then decrypt Fenc.

C. Security Analysis

We now show that the mechanisms in our off-state sharing
protocol can ensure the integrity of chain of custody of
the off-state data. That is, the user cannot deny that she/he
has received the requested off-state data. We assume the
underlying blockchain infrastructure, i.e. all peers, is secure,
and smart contracts execute as designed. The assumption is
reasonable since the peer administrators can adjust the user
privilege to meet the need.

An auditor can ﬁnd out if a user has received a transferred
ﬁle by searching for two transactions “Tx: key access” and
“Tx: ﬁle decryption” related to the particular ﬁle from the
blockchain. In our protocol, the receiver peer has to obtain
Kaes in order to decrypt the encrypted ﬁle Fenc, which the
sender sends. Kaes is stored in the world state of the ledger,
which guarantees the integrity of the data because of the
underlying blockchain framework. When a user proposes the
transaction “Tx: key access”, the receiver peer will receive
Kaes. Once the receiver peer obtains Kaes, the user has to
propose the transaction “Tx: ﬁle decryption” to get decrypted
ﬁle F . It can be observed that if the receiver peer does not
receive Fenc, the user will not propose “Tx: key access”. If
the receiver peer receives Fenc but the user does not propose
“Tx: key access” to request Kaes, the receiver peer can not
get the original ﬁle F .

An auditor can also ﬁnd out if a sender peer has transferred a
ﬁle by searching for “Tx: ﬁle transfer” related to the particular
ﬁle from the blockchain. In our protocol, “Tx: ﬁle transfer”
will trigger smart contracts to transfer a ﬁle in the off-state
storage and stores Encryption Key in the world state.
The integrity of “Tx: ﬁle transfer” can be guaranteed by the
underlying blockchain framework.

A user may wrongfully claim she/he receives a wrong ﬁle f .
The transaction history maintained by the blockchain system
actually provides proofs to dispute the claim. “Tx: ﬁle upload”
and “Tx: transfer request” can provide proofs to verify the
integrity of the transferred ﬁle. In our protocol, a ﬁle owner
records File Profile in the world state by proposing “Tx:
ﬁle upload”. The sender peer and receiver peer should agree
on a ﬁle sharing event which is recorded in the Event entry
by “Tx: transfer request”. The ﬁle name in Event is related
to a particular File Profile. “Tx: transfer request” in
blockchain can prove the sender and receiver peers have agreed
on transferring a speciﬁc ﬁle and H(F ) in File Profile
can be used to verify if f matches with H(F ).

Fig. 5. Four phases in the off-state sharing protocol

consensus, either denial of or agreement on the ﬁle transfer.
We call the corresponding transaction “Tx: transfer request”.

2) Phase 2: Encrypted File Transfer: After the ﬁle transfer
request is approved, the user proposes another transaction—
“Tx: ﬁle transfer”—to initiate the ﬁle transfer. In Fabric,
the endorsement policy for “Tx: ﬁle transfer” can be set as
AND(Peer.Sender), which means only the sender peer works
as an endorser. The sender peer/endorser ﬁrst checks f lag in
the corresponding Event entry. The ﬁle transfer continues
only if f lag is T rue.

The sender peer can then encrypt and sign the ﬁle, and
send the encrypted ﬁle to the receiver peer via a ﬁle transfer
protocol such as SFTP. The receiver peer stores the encrypted
ﬁle in its off-state storage. In Fabric, the encryption key and
related information of the encrypted ﬁle are put in the world
state as an Encryption Key entry which is a PDC. PDC
can guarantee that only PDC members can see the actual en-
cryption key and others only know its hash. In this phase, only
the sender peer is the PDC member. The Encryption Key
entry is in the form of (cid:104)key_ID, event_ID H(Fenc),
Kaes, Signature(Fenc), Kpublic (cid:105), where Kaes is the key
to decrypt the encrypted ﬁle.

3) Phase 3: Key Retrieval: A user ﬁrst checks if the
receiver peer has received the transferred ﬁle. Only after the
receiver peer has received the ﬁle does the user propose
a transaction—“Tx: key access”—to request Kaes from the
sender peer to decrypt the encrypted ﬁle Fenc. Otherwise,
the user does nothing. In Fabric, a user can send a query
to the receiver peer to check if Fenc exists. The
request
query request will not generate a transaction. Recall only the
sender peer stores the original Kaes and other nodes store
the hash. The endorsement policy for “Tx: key access” is set
as AND(Peer.Sender) so that the sender peer performs as an
endorser and adds the receiver peer to the PDC member list.
Therefore, the receiver peer will be able to retrieve Kaes.

Peer (Receiver ) Peer(Sender )UserTx: transfer requestTx: transfer requestencrypt file and set Encryption Key entryTx: file transferTx: key accessgrant receiver the access to Encryption Key entry Tx: file decryptionquery Encryption  Keyand decrypt file set Event entryset Event entrySender Node  Receiver NodeReceiver UserTx: request permissionTx: request permissionTx: file transferencrypt file and set Encryption Key entrysend encrypted fileTx: file transferTx: request keychange access of Encryption Key entryTx: request keyTx: decrypt fileTx:  decrypt fileget Encryption  Keyand decrypt file set Event entryset Event entryencrypted fileData OwnerTABLE II
BLOCKCHAIN NODE INFORMATION IN PROTOTYPICAL BOSS

Computer Role

OS Memory Disk

1

2

3

Sender

Receiver

Auditor

Ubuntu
18.04

Ubuntu
18.04

Ubuntu
16.04

64GB 1TB

32GB 1TB

64GB 1TB

CPU
Intel Xeon(R) Gold
6128 CPU@3.40GHz
×24 Processor
Intel Core i7-6700
CPU@3.40GHz
× 8 Processor
Intel Xeon(R) Gold
6128 CPU@3.40GHz
× 49 Processor

that a buffer size of more than 1MB will not reduce the latency
further. So we set the buffer size as 1MB in our system.

Fig. 7. SFTP latency versus buffer size

We use ﬁles of different types and various sizes to evaluate
BOSS’ feasibility and performance. Table III lists those test
ﬁles. Recall that a ﬁle sharing session involves four transac-
tions as shown in Fig. 5. We evaluate the latency of different
transactions and the latency of the whole session. We evaluate
how the ﬁle size and the parallel ﬁle transfers affect the latency.

TABLE III
TEST FILE LIST

Type
.pdf
.mp4
.tif
.zip
.rar
.zip

Size
67MB
218MB
576MB
1.2GB
2.6GB
5.3GB

Describtion
“C++ Primer Plus” eBook
An over 5 hours song list video
The image of Moon from NASA
A collection of medical images
The compressed ﬁle of one movie
The compressed ﬁle of two movies

TABLE IV
PERCENTAGE OF SFTP LATENCY IN “TX: FILE TRANSFER” LATENCY

Size
67MB
218MB
576MB
1.2GB
2.6GB
5.3GB

1 Parallel
75.30%
88.05%
92.43%
91.18%
86.24%
85.84%

2 Parallel
85.33%
92.82%
94.86%
85.13%
85.71%
83.56%

4 Parallel
93.38%
95.73%
87.50%
83.86%
84.36%
81.39%

8 Parallel
92.01%
84.13%
82.33%
83.71%
84.08%
82.68%

Fig. 6. Prototypical off-state sharing system (BOSS) based on Hyperledger
Fabric

V. EVALUATION

We have implemented a prototypical off-state sharing sys-
tem, BOSS, based on Hyperledger Fabric, and evaluate its
feasibility and performance in this section.

A. Experiment Setup

Fig. 6 shows the prototypical BOSS, which has three organi-
zations, i.e. org1, org2 and org3. Org1 and org2 are the sender
and the receiver, and each party contributes one peer node and
one client (user/owner) node. Org3 is an auditing organization,
and contributes one peer node and one orderer node. We
implement our off-state sharing protocol using chaincode of
Fabric and adopt SFTP [13] to perform ﬁle transfer.

It can be observed that

in our system, peer nodes are
different from the conventional Fabric peer nodes. We integrate
an off-state storage and the SFTP service into peer nodes of
interest. The chaincode can transfer and retrieve ﬁles from the
local off-state storage.

We implement the prototypical system and deploy it across
three physical computers. Table II lists the conﬁguration of the
computers for sender, receiver and auditor nodes. The sender
computer and the receiver computer are located in different
buildings on a university campus. All Fabric nodes run in
Docker containers, which form the Fabric network. We use
Golang to develop the chaincode and use Node.js to develop
the client application that a user uses to propose transactions
to the peer nodes.

B. Performance and Feasibility

We use Golang’s SFTP package to perform ﬁle transfer and
ﬁnd that the sender’s buffer size parameter affects speed and
latency of SFTP. The latency refers to how long it takes to
ﬁnish a particular operation. To ﬁnd an optimal buffer size, we
conduct SFTP with different buffer sizes between two docker
containers on physical Computer 1 and Computer 2 using a
576MB ﬁle and a 1.2GB ﬁle. Fig. 7 shows how the buffer size
affects the ﬁle transfer latency of SFTP. It can be observed

Chaincode:func AddFile ()func Agreement ()func Transfer ()func RequestKey ()func QueryKey ()Peer1Off-State@Node #1I/OWorld State:file recordevent recordI/OWorld State:file recordevent recordOrg 2 – ReceiverOrderer 1Client 11. Proposal2. Response1. Proposal2. Response3. TxOrg 1 – Sender4. Block5. Verify5. Verify4. BlockF1F3F2Chaincode:func AddFile ()func Agreement ()func Transfer ()func RequestKey ()func QueryKey ()Peer2Off-State@Node #2F4F6F5World State:file recordevent recordOrg 3 – Auditor5. VerifyChaincode:func AuditPolicy1 ()func AuditPolicy2 ()func AuditPolicy3 ()Peer3Client 2a. SCPb. SCPc. SFTP4. BlockChaincodePeer1Off-State@Peer 1Computer 2: Receiver@Org2Orderer 1Client 11. Proposal2. Response1. Proposal2. Response3. Tx Computer 1: Sender@Org14. Block5. Validate5. Validate4. BlockF1F3F2ChaincodePeer2Off-State@Peer 2F4F6F5Computer 3: Auditor@Org35. ValidateChaincodePeer3Client 2a. SFTPb. SFTPc. SFTP4. BlockWorld State:file profileevent encryption keyWorld State:file profileevent encryption keyWorld State:file profileevent encryption keyChaincode:func SetPermission ()func TransferFile ()func RequestKey ()Peer1Off-State@Peer 1Org 2 – ReceiverOrderer 1Client 11. Proposal2. Response1. Proposal2. Response3. TxOrg 1 – Sender4. Block5. Validate5. Validate4. BlockF1F3F2Chaincode:func SetPermission ()func DecryptFile()Peer2Off-State@Peer 2F4F6F5Org 3 – Auditor5. ValidateChaincode:func Audit ()Peer3Client 2a. SFTPb. SFTPc. SFTP4. BlockWorld State:file profileevent encryption keyWorld State:file profileevent encryption keyWorld State:file profileevent encryption key271.55196.48114.8386.3982.4782.5881.36658.36435.99250.62187.71182.05185.61189.165015025035045055065075010KB20KB200KB1MB100MB500MB1GBSFTP Latency (s)Buffer Size576MB1.2GBFig. 8. Transaction latency of “Tx: transfer re-
quest” and “Tx: key access”

Fig. 9. SFTP latency and transaction Latency of
“Tx: ﬁle transfer” and “Tx: ﬁle decryption”

Fig. 10. File sharing session latency

Fig. 11.
request” in different parallel transfer cases

Transaction latency of “Tx:

transfer

Fig. 12. Transaction latency of “Tx: key access”
in different parallel transfer cases

Fig. 13. Transaction latency of “Tx: ﬁle transfer”
in different parallel transfer cases

Fig. 14. SFTP latency in different parallel transfer
cases

Fig. 15. Transaction latency of “Tx: ﬁle decryp-
tion” in different parallel transfer cases

Fig. 16. Average ﬁle sharing session latency in
different parallel transfer cases

1) File Size: For each ﬁle in Table III, we conduct the ﬁle
transfer 32 times. Each time only one ﬁle transfer is performed.
The results are shown in Figs. 8–10.

Fig. 8 shows the latency of “Tx: transfer request” and “Tx:
key access” across different ﬁle sizes. It can be observed that
the latency of these two transactions are relatively stable and
the ﬁle size has minor affect on the latency. This is reasonable
since these two transactions only operate on the world state
data.

Fig. 9 shows the latency of “Tx: ﬁle transfer” and “Tx: ﬁle
decryption”. It can be observed that the latency of these two
transactions rapidly increase as the ﬁle size increases. The
reason is “Tx: ﬁle transfer” involves multiple cryptographic
calculations to encrypt ﬁles and uses SFTP to transfer the ﬁle.
Fig. 9 shows the latency of the SFTP transmission. Table IV
shows the percentage of the SFTP latency in the “Tx: ﬁle

transfer” latency. It can be observed that the SFTP latency
accounts for a large proportion of the whole “Tx: ﬁle transfer”
latency. “Tx: ﬁle decryption” involves multiple cryptographic
calculation to decrypt the ﬁle. So it is reasonable that its
latency is affected by the ﬁle size.

Fig. 10 shows the average latency of one ﬁle sharing session.
It can be observed that the latency of one ﬁle sharing session
rapidly increases as the ﬁle size increases. It is reasonable
because normally more time is needed to transfer larger ﬁles.

to ﬁnd out

2) Parallel Transfer: We also want

if we
can transfer multiple ﬁles in parallel between two nodes and
evaluate the performance. In our experiments, for each ﬁle,
the number of simultaneous parallel ﬁle transfer sessions is 1,
2, 4 and 8, denoted as 1-P, 2-P, 4-P and 8-P in Figs. 11–16,
which show the experiment results. In each case, the ﬁle is
transferred 32 times in total. For example, in the case of 4-P

FileSize67M218M576M1.2G2.6G5.3GLatency(s)22.533.544.55transfer requestkey accessFileSize67M218M576M1.2G2.6G5.3GLatency(s)020040060080010001200file transferSFTPfile decryption31.3157.04118.57243.03637.891262.7202004006008001000120067M218M576M1.2G2.6G5.3GLatency (s)File SizeFileSize67M218M576M1.2G2.6G5.3GLatency(s)22.533.544.551-P2-P4-P8-PFileSize67M218M576M1.2G2.6G5.3GLatency(s)22.533.544.551-P2-P4-P8-PFileSize67M218M576M1.2G2.6G5.3GLatency(s)0100020003000400050006000700080009000100001-P2-P4-P8-PFileSize67M218M576M1.2G2.6G5.3GLatency(s)0100020003000400050006000700080009000100001-P2-P4-P8-PFileSize67M218M576M1.2G2.6G5.3GLatency(s)02004006008001000120014001600180020001-P2-P4-P8-P31.3141.8567.77112.657.0486.81147.52304.58118.57244.05497.30977.67243.03544.581161.572227.06637.891397.922400.965297.641262.722493.734701.379730.880100020003000400050006000700080009000100001-P2-P4-P8-PLatency(s)ParallelNumber67M218M576M1.2G2.6G5.3G(4 parallel ﬁle transfer session), we perform the experiments
8 times and the ﬁle is transferred 32 times (4 × 8).

We make the following observations. As the number of
parallel sessions increases, the latency of “Tx: transfer request”
and “Tx: key access” is relatively stable as shown in Fig. 11
and Fig. 12. However the latency of “Tx: ﬁle transfer” and
“Tx: ﬁle decryption” increases as the number of parallel ses-
sions increases. Fig. 14 further shows the latency of SFTP in-
volved in “Tx: ﬁle transfer” in different parallel transfer cases.
Table IV shows the percentage of SFTP incurred latency in the
“Tx: ﬁle transfer” latency. It shows the same trend as “Tx: ﬁle
transfer” and accounts for the most of the transaction latency.
Fig. 16 shows the average latency of one ﬁle sharing session
in different parallel transfer cases. It can be observed that the
average ﬁle transfer session latency increases as the number of
parallel transfer sessions increases. This is reasonable because
simultaneous parallel ﬁle transfer sessions share the network
bandwidth. More sessions mean less network bandwidth for
each ﬁle transfer session.

VI. DISCUSSION

In this section, we discuss the impact of chaincode execution
timeout on big ﬁle sharing, potential implementation of BOSS
with other blockchain frameworks, difference between off-
state and off-chain and out-of-band distribution of received
ﬁles by users.

A. Chaincode Execution Timeout

timeout value is 30s. In BOSS,

In Fabric, chaincode has a system wide execution timeout
setting. The default
the
chaincode invokes SFTP for ﬁle transfer and waits for SFTP
to ﬁnish. However, 30s is far from enough for transferring a
big ﬁle and the chaincode will time out. This timeout setting
can be changed in the docker conﬁguration ﬁle of Fabric, but
cannot be changed at runtime based on the size of the ﬁle.
We ﬁnd setting the timeout to inﬁnity does not work in Fabric
either and plan to revise Fabric as future work so that we can
change the timeout ﬂexibly.

B. Implementation based on Other Blockchain Frameworks

Bitcoin is not appropriate to implement BOSS. First, Bitcoin
is a permissionless blockchain system. It is hard to implement
access control. Second, Bitcoin essentially is a blockchain-
based cryptocurrency application. There is no existing mech-
anism like smart contracts for programming. It will be a
challenge and tedious to develop other applications over it.

Enterprise Ethereum [14] can be used to implement a
blockchain off-state sharing system. Enterprise Ethereum [15]
[16] is a permissioned blockchain framework for enterprise
applications. It has many similar features to Fabric. First, there
is a private world state as well as a public world state for
each enterprise Ethereum node. The private world state is only
shared within a private group. Enterprise Ethereum provides
a private transaction manager, which can be used to keep
transactions private among a private group. The private world
state is similar to PDC in Fabric and can be used to manage

the encryption key access required by BOSS. Second, there
is a private contract mechanism. A private contract is only
available and executed on a subset of nodes. This is actually
similar to customizable chaincode in Fabric and is ﬂexible
for the sender/receiver peers to implement their own business
logic. Third, the language of smart contracts is Solidity [17]
in Ethereum. Solidity is a Turing-complete program language
which can be used to implement a business logic.

C. Difference between Off-State and Off-Chain

Off-state is different from off-chain [18]–[20], and existing
off-chain protocols can not be utilized to ensure the safety
of off-state data. The off-chain technique is designed to scale
the blockchain systems and improve transaction throughput.
It constructs transactions off-chains, and submits one trans-
action containing the ﬁnal results to update the world state.
Essentially, the off-chain protocol is designed to guarantee the
safety of the world state. The well-known off-chain technique
is the payment channel in Bitcoin [18]. A payment channel
ﬁrst locks some on-chain cryptocurrencies, i.e. the UTXOs
state. Then it constructs transaction off-chains to conduct
micropayments using locked cryptocurrencies, but does not
commit
these transactions involving micropayments to the
blockchain. At last, it commits one transaction that represents
ﬁnal micropayment results to the main blockchain to update
the UTXOs world state. Off-chain can not solve the storage
limitation issues or be used for big ﬁle sharing.

D. Out-of-band Data Distribution

Once the ﬁle is transferred to a user through BOSS, the user
may stealthily send the ﬁle to other parties through out-of-
band commnunication but not through BOSS. It will be hard
to trace those ﬁles. This is a generic problem in data sharing,
not speciﬁc to our system. Potential solutions include digital
watermark [21] and traitor tracing [22], which adds some addi-
tional information to the ﬁles. Another strategy will be to limit
the user capabilities with the ﬁles to particular workstations
and use physical security and particular conﬁgurations that
allow ﬁle transfer only through BOSS.

VII. RELATED WORK

Related work on blockchain-based data sharing systems
does not focus on the big ﬁle sharing. It does not address the
speciﬁc challenges in big ﬁle sharing or solve the problem.

A. Data Sharing in Ledgers

In most existing blockchain-based data sharing systems,
shared data is stored in ledgers. Users set or get shared
data through proposing transactions to the blockchain system.
Transactions are the carriers of the shared data. Wang et al.
[23] utilize the blockchain system as the back end to transmit
and store data from the front-end wireless body area networks
(WBAN). All blockchain nodes maintain the same data and
all participants such as doctors and insurance providers share
the same WBAN data. Zhang et al. [24] propose a blockchain-
based secure and privacy-preserving personal health informa-
tion (PHI) sharing scheme. The original PHI records are stored

in the ledger of the private blockchain of each hospital, and
the consortium blockchain keeps records of the indexes of the
PHI. Jiang et al. [25] propose a blockchain-based platform
for healthcare information exchange. They use two loosely
coupled blockchains to handle different kinds of healthcare
data,
including highly sensitive electronic medical records
(EMRs) and personal healthcare data (PHD). These existing
schemes are not suitable for big ﬁle sharing applications
because big ﬁles cannot be stored in blockchain ledgers due
to the storage limitation as analyzed in Section II-B.

B. Data Sharing Outside Ledgers

There are systems that store shared data outside the ledgers
in blockchain systems. Xia et al. [26] propose a blockchain-
based solution to sharing medical data among cloud ser-
vice providers. In their design, smart contracts retrieve re-
quested data from existing database infrastructure, outside
of a blockchain system. The retrieved results are recorded
in the blockchain. It is impractical to record big ﬁles in a
blockchain. Lu et al. [27] design a blockchain empowered
privacy-preserved data sharing architecture for industrial IoT.
They exploit the privacy-preserved federated learning algo-
rithm to learn the data model and share the data model instead
of revealing the actual data. They use the blockchain to retrieve
and manage the accessibility of data. Zhang et al. [2] choose
to store and exchange only reference pointers of the sensitive
data in the blockchain. A data requester should ﬁrst get a token
from the blockchain system and then use the token to access
original data in the database outside the blockchain.

These existing schemes do not focus on big ﬁle sharing.
They also fail
to consider security requirements such as
dealing with dishonest users, and fail to design a protocol
for secure off-state sharing. Wang et al. [28] ﬁnd misuse of
PDC in Fabric may endanger a blockchain system and BOSS
avoids such issues in the implementation.

VIII. CONCLUSION

In this paper, we solve a novel problem—how to securely
share big data ﬁles within a blockchain system and establish
the chain of custody of the shared data. Such a data sharing
application is critical for protecting intellectual property (IP)
theft and ﬁghting industrial espionage in ﬁelds including
biomedical research. We denote data such as big ﬁles stored at
a blockchain node but outside of the ledger as off-state. Three
challenges including storage space limitation, privacy require-
ment and security requirement are discovered in implementing
a blockchain off-state sharing system (BOSS). We carefully
present our off-state sharing protocol. The transactions gen-
erated by our protocol will serve as auditing evidence for
the chain of custody. We implement BOSS over Hyperledger
Fabric and conduct extensive experiments to evaluate the
feasibility and performance of BOSS.

REFERENCES

[1] A. M. Antonopoulos, Mastering Bitcoin: unlocking digital cryptocur-

rencies.

” O’Reilly Media, Inc.”, 2014.

[2] P. Zhang, J. White, D. C. Schmidt, G. Lenz, and S. T. Rosenbloom,
“Fhirchain: applying blockchain to securely and scalably share clinical
data,” Computational and structural biotechnology journal, vol. 16, pp.
267–278, 2018.

[3] E. Androulaki, A. Barger, V. Bortnikov, C. Cachin, K. Christidis,
A. De Caro, D. Enyeart, C. Ferris, G. Laventman, Y. Manevich et al.,
“Hyperledger fabric: a distributed operating system for permissioned
blockchains,” in Proceedings of the thirteenth EuroSys conference, 2018,
pp. 1–15.

[4] V. Buterin et al., “A next-generation smart contract and decentralized

application platform,” white paper, vol. 3, no. 37, 2014.

[5] Ethereum, “Ethereum builders guideline,” 2021, [Online]. (Accessed 26
March 2021). [Online]. Available: https://ethereumbuilders.gitbooks.io
/guide/content/en/what is ethereum.html

[6] CouchDB, “Couchdb: Base conﬁguration,” 2021, [Online]. (Accessed
6 Apirl 2021). [Online]. Available: https://docs.couchdb.org/en/latest/c
onﬁg/couchdb.html?highlight=max document siz

[7] B. Wiki, “Weaknesses,” 2021, [Online]. (Accessed 26 March 2021).

[Online]. Available: https://en.bitcoin.it/wiki/Weaknesses

[8] B. Forum, “New bitcoin vulnerability: A transaction that takes at least
3 minutes to be veriﬁed by a peer,” 2021, [Online]. (Accessed 26
March 2021). [Online]. Available: https://bitcointalk.org/index.php?to
pic=140078.0

[9] G. Wood, “Ethereum yellow paper,” 2021, [Online]. (Accessed 26
https://ethereum.github.io/yellowp

March 2021). [Online]. Available:
aper/paper.pdf

[10] Etherscan, “Ethereum average gas

[Online].
(Accessed 26 March 2021). [Online]. Available: https://etherscan.io/c
hart/gaslimit

limit chart,” 2021,

[11] Hyperledger, “Hyperledger

[Online].
//hyperledger.github.io/fabric-chaincode-java/main/api/index-all.html

(Accessed 26 March 2021).

fabric-chaincode-shim 2.3.1 api,” 2021,
https:

[Online]. Available:

[12] C. Gorenﬂo, S. Lee, L. Golab, and S. Keshav, “Fastfabric: Scaling
hyperledger fabric to 20 000 transactions per second,” International
Journal of Network Management, vol. 30, no. 5, p. e2099, 2020.
[13] Wikipedia, “Ssh ﬁle transfer protocol,” 2021, [Online]. (Accessed 6
Apirl 2021). [Online]. Available: https://en.wikipedia.org/wiki/SSH F
ile Transfer Protocol

[14] Ethereum, “Ethereum mainnet for enterprise,” 2021, [Online]. (Accessed
13 June 2021). [Online]. Available: https://ethereum.org/en/enterprise/
[15] H. Besu, “Hyperledger besu: Privacy,” 2021, [Online]. (Accessed 13
June 2021). [Online]. Available: https://besu.hyperledger.org/en/stable
/Concepts/Privacy/Privacy-Overview/

[16] GoQuorum, “Goquorum: Privacy,” 2021, [Online]. (Accessed 13 June
2021). [Online]. Available: https://docs.goquorum.consensys.net/en/sta
ble/Concepts/Privacy/ContractExtension/
[Online].

[17] Wikipedia, “Solidity,” 2021,

(Accessed 13 June 2021).

[Online]. Available: https://en.wikipedia.org/wiki/Solidity

[18] J. Poon and T. Dryja, “The bitcoin lightning network: Scalable off-chain

instant payments,” 2016.

[19] J. Coleman, L. Horne, and L. Xuanji, “Counterfactual: Generalized state

channels,” Acessed: Nov, vol. 4, p. 2019, 2018.

[20] S. Dziembowski, S. Faust, and K. Host´akov´a, “General state channel
networks,” in Proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security, 2018, pp. 949–966.

[21] R. G. Van Schyndel, A. Z. Tirkel, and C. F. Osborne, “A digital
watermark,” in Proceedings of 1st international conference on image
processing, vol. 2.

IEEE, 1994, pp. 86–90.
[22] D. Boneh and M. Franklin, “An efﬁcient public key traitor tracing
Springer,

scheme,” in Annual International Cryptology Conference.
1999, pp. 338–353.

[23] J. Wang, K. Han, A. Alexandridis, Z. Chen, Z. Zilic, Y. Pang, G. Jeon,
and F. Piccialli, “A blockchain-based ehealthcare system interoperating
with wbans,” Future Generation computer systems, vol. 110, pp. 675–
685, 2020.

[24] A. Zhang and X. Lin, “Towards secure and privacy-preserving data
sharing in e-health systems via consortium blockchain,” Journal of
medical systems, vol. 42, no. 8, pp. 1–18, 2018.

[25] S. Jiang, J. Cao, H. Wu, Y. Yang, M. Ma, and J. He, “Blochie:
a blockchain-based platform for healthcare information exchange,” in
2018 ieee international conference on smart computing (smartcomp).
IEEE, 2018, pp. 49–56.

[26] Q. Xia, E. B. Sifah, K. O. Asamoah, J. Gao, X. Du, and M. Guizani,
“Medshare: Trust-less medical data sharing among cloud service
providers via blockchain,” IEEE Access, vol. 5, pp. 14 757–14 767, 2017.
[27] Y. Lu, X. Huang, Y. Dai, S. Maharjan, and Y. Zhang, “Blockchain and
federated learning for privacy-preserved data sharing in industrial iot,”
IEEE Transactions on Industrial Informatics, vol. 16, no. 6, pp. 4177–
4186, 2019.

[28] S. Wang, M. Yang, Y. Zhang, Y. Luo, T. Ge, X. Fu, and W. Zhao,
“On private data collection of hyperledger fabric,” in 2021 IEEE 41st
International Conference on Distributed Computing Systems.
IEEE,
2021, pp. 1–11.

