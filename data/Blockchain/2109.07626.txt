BOSS: A Blockchain Off-State Sharing System

Shan Wang‚àó‚Ä°, Ming Yang‚àó, Tingjian Ge‚Ä°, Yan Luo‚Ä°, Xinwen Fu‚Ä°
‚àó Southeast University. Email: shanwangsec@gmail.com, yangming2002@seu.edu.cn
‚Ä°University of Massachusetts Lowell. Email:{Yan Luo, Xinwen Fu}@uml.edu, ge@cs.uml.edu

1
2
0
2

p
e
S
5
1

]

R
C
.
s
c
[

1
v
6
2
6
7
0
.
9
0
1
2
:
v
i
X
r
a

Abstract‚ÄîBlockchain has been applied to data sharing to
ensure the integrity of data and chain of custody. Sharing big data
such as large biomedical data Ô¨Åles is a challenge to blockchain
systems since the ledger is not designed to maintain big Ô¨Åles,
access control is an issue, and users may be dishonest. We call
big data such as big Ô¨Åles stored outside of a ledger that includes
the blockchain and world state at a blockchain node as ‚Äúoff-state‚Äù
and propose an off-state sharing protocol for a blockchain system
to share big data between pairs of nodes. In our protocol, only
encrypted Ô¨Åles are transferred. The cryptographic key is stored
in the world state in a secure way and can be accessed only by
authorized parties. A receiver has to request the corresponding
cryptographic key from the sender to decrypt such encrypted
Ô¨Åles. All requests are run through transactions to establish
reliable chain of custody. We design and implement a prototypical
blockchain off-state sharing system, BOSS, with Hyperledger
Fabric. Extensive experiments were performed to validate the
feasibility and performance of BOSS.

Index Terms‚ÄîBlockchain, Big File Sharing, Off-state, Hyper-

ledger Fabric

I. INTRODUCTION

A blockchain system can build trust in the data that it
maintains without a centralized authority. Data in conventional
blockchain systems is often stored in a ledger, which includes
a world state and a blockchain. The world state stores the
current system state such as the user cryptocurrency balance
in Bitcoin [1] and the blockchain saves all transaction history,
which contains operations on the world state and/or the data
used to update the world state. The whole transaction history
produces the current state values and can work as auditing
evidence. The ledger is often synchronized across all nodes.
Blockchain has been applied to a variety of data sharing
applications such as healthcare. A blockchain data sharing
system can prevent information tampering for the purpose of
auditing and establish the chain of custody, which refers to the
documentation that records the sequence of custody, transfer,
and other operations on the data. In these systems, shared data
is stored in the world state database. Users set or get shared
data through proposing transactions to the blockchain system.
The existing blockchain frameworks cannot be directly ap-
plied to big Ô¨Åle sharing. Big Ô¨Åles can be scientiÔ¨Åc and biomed-
ical data being collected and processed. Sharing such data
allows independent veriÔ¨Åcation of published scientiÔ¨Åc results
and enhances opportunities for new discoveries. With concerns
of intellectual property (IP) theft and industrial espionage, we
desire secure and trustworthy big Ô¨Åle sharing systems that
record the chain of custody of the big Ô¨Åles. However, given the
storage design of the ledger, it is impractical to store big Ô¨Åles
in the world state and to use transactions to carry big Ô¨Åles. A

blockchain system often maintains the same ledger across all
nodes. However, because of privacy, IP and storage concerns,
owners may not want to share those big Ô¨Åles across all nodes.
A token based data sharing blockchain system has been
brieÔ¨Çy discussed in related work [2]. Shared data is stored
outside the blockchain system at a data center. This system
has the following issues: (i) It requires a centralized and
trusted data center. (ii) No actual protocols using tokens
are documented. (iii) The data center based approach is not
Ô¨Çexible. In scenarios such as Ô¨Åle sharing in biomedical Ô¨Åelds,
to share data between each other‚Äôs
researchers may want
computers directly. There is no detail of the token based
sharing protocol in [2].

In this paper, we propose a novel big Ô¨Åle sharing model.

Our major contributions can be summarized as follows.

1) We introduce a new concept ‚Äúoff-state‚Äù to a blockchain
system. A blockchain node may maintain a separate
storage from the ledger to store off-states such as big Ô¨Åles,
which are outside of the ledger, particularly the world
state. Off-states do not need to be synchronized across
all nodes. Smart contracts manage sharing of off-states
such as big Ô¨Åles.

2) To ensure the integrity and chain of custody of off-
states, we propose a novel off-state sharing protocol.
Off-sates are encrypted and signed before sharing. The
cryptographic key is stored in the world state database
and users have to request the key through transactions in
order to decrypt the transferred Ô¨Åles. Mechanisms such as
private data collection (PDC) in Hyperledger Fabric [3]
can be used to ensure that the cryptographic key is kept
private and not publicly disclosed. These mechanisms
also defeat dishonest users.

3) We implement a prototypical blockchain off-state sharing
system (BOSS) with Hyperleger Fabric running our off-
state data sharing protocol. Extensive experiments are
performed to evaluate BOSS‚Äô feasibility and performance
such as latency of the big Ô¨Åle transfer between pairs of
blockchain nodes and parallel Ô¨Åle transfer.

The rest of this paper is organized as follows. Section II in-
troduces the background knowledge. Section III introduces the
off-state sharing system model. The off-state sharing protocol
is presented in Section IV. We evaluate the prototypical off-
state sharing system, BOSS, in Section V. We discuss a few
related topics such as the execution timeout of chaincode (i.e.
smart contract in Hyperledger Fabric) in Section VI. Section
VII presents the related work. We conclude this paper in

 
 
 
 
 
 
Section VIII.

II. BACKGROUND

In this section, we introduce the data in blockchain systems,
storage limitations of a ledger, and Hyperledger Fabric, which
is a permissioned blockchain framework. For brevity, we will
call Hyperledger Fabric as Fabric in the rest of the paper.

A. Data in Conventional Blockchain Systems

A blockchain system is essentially a state machine repli-
cated across different nodes [4]. The state machine can be
formally deÔ¨Åned in Formula (1).

AP P LY (S, T x) ‚Üí S(cid:48)orERROR,

(1)

where the state transition function AP P LY (.) takes a state
S and a transaction T x and outputs a new state S(cid:48) or an
error. A ledger includes a world state and a blockchain. The
world state stores the current state. The blockchain stores all
historical transactions. In Bitcoin [1], the world state is the
user cryptocurrency balance recorded in the UTXO (unspent
transaction output) Ô¨Åeld of transactions. State transitions are
cryptocurrency transfers. In Ethereum [4], the world state is
made up of ‚Äúaccounts‚Äù. An account contains the cryptocur-
rency balance, code and data in smart contracts and others.
State transitions are direct transfers of values and information
between accounts controlled by smart contracts. In Fabric [3],
each peer node maintains a world state database. A transaction
records the operation of invoking a function in smart contract,
called chaincode in Fabric, which may work on the world state.

B. Storage Limitations of Conventional Blockchain Systems

In current blockchain frameworks, the data size and type
in ledgers are limited. We now show the limitations in three
popular blockchain frameworks, Bitcoin, Ethereum and Fabric.
1) World State Storage Limitation: In Bitcoin, the world
state UTXOs are just values in transactions indicating the
Bitcoin balance. It‚Äôs impossible to store large Ô¨Åles in UTXOs.
In Ethereum, the world state consists of user accounts and
contract accounts. A user account only records the Ether
balance of the user. The contract account can store pairs of
keys and values of 32 bytes used by the smart contract [5].
Ethereum is not designed to store big Ô¨Åles.

In Fabric,

the world state is stored in a database,

i.e.
LevelDB or CouchDB. LevelDB can only store simple key-
value pairs. CouchDB can store data in the JSON format, but
limits the maximum document body size to 8M bytes [6].
Fabric cannot store big Ô¨Åles either.

2) Transaction and Block Size Limitation:

In Bitcoin,
to prevent attacks like DoS attacks and memory exhaustion
attacks, it restricts the block size to 1MB and transactions
greater than 100 KB are considered non-standard [7], [8].

In Ethereum, the gas consumed by a transaction is related
to the size of the data stored in the world state. It is quite
expensive to store big data. According to the yellow paper [9],
it requires 16 gas units for storing every non-zero byte of data
for a transaction. Storing 1MB (1024√ó1024 = 1048576 bytes)

Fig. 1. Three-phase transaction workÔ¨Çow in Fabric

data requires 16,777,216 gas units in addition to other fees.
Each block has a block gas limit, which limits the block size
too. The current block gas limit is 12,491,593 gas units/block
[10]. It means a block can maximally store about 0.74MB
data (12491593 √∑ 16777216 ‚âà 0.74).

In Fabric, the preferred maximum size of each transaction
is 512KB while the absolute maximum transaction size
is 99MB. Nodes in Fabric adopt the grpc communication
protocol. The maximum inbound grpc message size is 100MB
[11]. Large transactions will decrease the system performance
in terms of transaction throughput [12].

C. Hyperledger Fabric

Fabric [3] is a popular permissioned blockchain framework.
It decouples the tasks of a node in blockchain systems such
as Ethereum [4] into three types of nodes, i.e. peers, orderers
and clients in charge of different tasks. Peers maintain ledgers
and smart contracts.

a

adopts

Transaction WorkÔ¨Çow: Fabric

three-phase
‚Äúexecute-order-validate‚Äù transaction workÔ¨Çow as shown in
Fig. 1: (1) A client/user proposes a transaction proposal to
the endorsers, which are speciÔ¨Åc peers and speciÔ¨Åed by the
endorsement policy; (2) The endorsers execute the chaincode,
sign the execution results, and return the results with
corresponding signatures to the client as proposal responses;
(3) If the returned execution results from different endorsers
are the same,
the client constructs a transaction, which
contains both the transaction proposal, proposal response
and a list of signatures (endorsements). The client sends the
transaction to the orderer nodes. (4) The orderer nodes collect
multiple transactions within a time period, bundle them into a
new block, and distribute the new block to all peers including
both endorsers and non-endorsers. (5) All peers validate the
transactions
transactions in the received new block. If all
are valid, each peer will update the world state according to
execution results. After validating all transactions, each peer
appends the new block to its local blockchain.

Peer 1 Peer2ClientTransaction ProposalTransaction ProposalTransactionBlock GenerationTransactionValidationChaincode ExecutionChaincode ExecutionProposal ResponseOrdererProposal ResponseTransactionGenerationBlockBlockTransactionValidationNotificationThree features of Hyperledger Fabric enable it suitable to

implement our blockchain big Ô¨Åle sharing system.

1) Fine-grained data isolation: The Fabric introduces a
Ô¨Åne-grained data isolation mechnism, i.e., private data collec-
tion (PDC). PDC data is sensitive and shared by only a subset
of peer nodes. A PDC is stored in the world state. Only PDC
member peers can store the original data, while PDC non-
member peers can only store the data hashes.

2) Customizable smart contracts: Smart contracts, also
called chaincode in Fabric, do not need to be identical at all
peers as long as the execution results across different endorser
peers are the same. Therefore, different peers can perform
different roles and tasks.

3) Multi-level endorsement policy: There are multiple lev-
els of endorsement policies in Fabric. An endorsement policy
stipulates which peers need perform as endorsers to endorse
a transaction. Endorsing involves executing smart contracts
and signing the execution results. Each smart contract has a
default chaincode-level endorsement policy that manages all
public data and PDC data in the world state. A collection-level
endorsement policy can be customized to speciÔ¨Åcally manage
the PDC data.

III. OFF-STATE DATA SHARING SYSTEM MODEL

In this section, we Ô¨Årst investigate the existing blockchain-
based big Ô¨Åle sharing systems and their drawbacks. We then
present the challenges in big Ô¨Åle sharing through blockchain
systems, and Ô¨Ånally propose a new big Ô¨Åle sharing model
through blockchain.

A. State-of-the-art Blockchain Based Big File Sharing Systems

Fig. 2 shows a blockchain-based data sharing model utiliz-
ing access tokens [2]. A user proposes a transaction to request
a token for data access. The transaction proposal
triggers
particular functions in the smart contract, which returns an
access token to the user. The user then uses the access token
to request the shared data from a data center, which is outside
of the blockchain system. This data sharing model may be
used for big Ô¨Åle sharing.

The token based Ô¨Åle sharing blockchain model has the
following issues: (i) It requires a centralized and trusted data
provider. The data center is controlled by the data provider.
The Blockchain system has no control over the actual data
access and cannot know the status of data sharing, e.g. whether
the data is actually shared. The integrity of chain of custody
cannot be ensured and audited, (ii) There is no detailed
presentation of the actual protocol in [2]. (iii) The data center
based approach is not Ô¨Çexible. In scenarios such as Ô¨Åle sharing
in biomedical Ô¨Åelds, data owners may want to share data
between their workstations.

B. Design Challenges

We identify three challenges for a blockchain-based big Ô¨Åle

sharing system.

Fig. 2. Token based blockchain data sharing system

1) Challenge 1‚ÄîStorage Space Limitation: Big Ô¨Åles refer
to Ô¨Åles of large size, such as videos and biomedical data
Ô¨Åles. Due to the storage limitations of ledgers as discussed
in Section II-B, it is impractical to store big Ô¨Åles in ledgers
or pack big Ô¨Åles in transactions.

2) Challenge 2‚ÄîPrivacy Requirement: Big Ô¨Åles may be
sensitive. The owner may not want to share with everyone
and access control will be preferred. However, in a conven-
tional blockchain system, all nodes maintain the same data.
Therefore, the blockchain system cannot be directly used for
big Ô¨Åle sharing.

3) Challenge 3‚ÄîSecurity Requirement: In big Ô¨Åle sharing,
the receiver of the big Ô¨Åles may be dishonest and may
dishonestly deny she/he received the Ô¨Åles from the owner.

C. Off-State Sharing System Model

We introduce the concept of ‚Äúoff-state‚Äù, which is stored at
blockchain nodes, but outside of ledgers, particularly the world
state. For example, the off-state can be big Ô¨Åles. Therefore, we
generalize big Ô¨Åle sharing as off-state sharing. Off-states can
be inconsistent across blockchain nodes and shared between
pairs of nodes. Smart contracts at blockchain nodes can
interact with off-states and perform the sharing operation.

Fig. 3 shows our novel blockchain system model that can
address the three challenges above for off-state data sharing.
Each node maintains a world state database and an off-state
storage space when needed. Nodes maintain their off-state data
individually. Users propose transactions to trigger the smart
contracts to transfer the Ô¨Åles. The smart contracts at the sender
node transfers off-state data to the receiver node through a Ô¨Åle
transfer protocol, not through transactions.

To summarize, we address the three challenges as follows.

World StateWorld StateWorld StateSmart ContractNode2Smart ContractNode3Smart ContractNode1TX1TX1TX1Data CenterUsersTX1: request accessaccess tokenshared data  access tokenFig. 3. Blockchain-based off-state sharing model

‚Ä¢ To address Challenge 1‚Äîstorage space limitation, we
introduce the concept of ‚Äòoff-state‚Äù and save big Ô¨Åles off
the ledger.

‚Ä¢ To address Challenge 2‚Äîprivacy requirement, our proto-
col allows off-states to be shared between pairs of nodes,
not across all blockchain nodes. This feature saves storage
space at nodes that do not need off-state data.

‚Ä¢ To address Challenge 3‚Äîsecurity requirement, our pro-
tocol establishes the chain of custody of the off-state data
and records auditing evidence in the blockchain.

We will present the detailed off-state data sharing protocol in
Section IV.

IV. OFF-STATE SHARING PROTOCOL

Our protocol has two stages. In Stage 1, an owner prepares
the Ô¨Åles to be shared with users and uploads the Ô¨Åles to sender
peer nodes. In Stage 2, to establish the chain of custody,
a sender peer transfers an encrypted Ô¨Åle to a receiver peer
and stores the symmetric encryption/decryption key (called
encryption key for brevity in the rest of the paper) in the
world state. A user has to request the encryption key through
a transaction to get the key, decrypt the encrypted Ô¨Åle and
get the original Ô¨Åle. These transactions establish the chain
of custody. In this section, we Ô¨Årst present the two stages
and then perform the security analysis. We use Fabric to
present particular protocol details and discuss the use of other
blockchain frameworks for the protocol in Section VI.

A. Stage 1: Preparing Off-State Data

A data owner uploads big Ô¨Åles to the off-state storage
of her/his own blockchain node. The user also proposes a
transaction‚Äî‚ÄúTx: Ô¨Åle upload‚Äù‚Äîto record the proÔ¨Åle of an
uploaded Ô¨Åle into the world state. The Ô¨Åle proÔ¨Åle in the
world state is public for searching. Fig. 4 illustrates the File
Profile entry in the world state,
(cid:104)file_name, H(F ),
owner, access_rule, description(cid:105), where H(F )

Fig. 4. Cryptographic lock mechanism for off-state

TABLE I
SUMMARY OF MAIN SYMBOLS.

Symbol
F
H(F )
Kaes
Fenc
H(Fenc)
Kprivate
Kpublic
Signature(Fenc)

Description
File to be transferred
Hash of F
Symmetric key
File encrypted using Kaes
Hash of Fenc
Private key to sign Fenc
Public key to verify digital signature
Digital signature of Fenc

is the hash of the Ô¨Åle. H(F ) can be used to verify the integrity
of a received Ô¨Åle.

B. Stage 2: Sharing Off-State Data

Fig. 5 shows the workÔ¨Çow of sharing off-state data, e.g.
a big Ô¨Åle, in Fabric. It involves four transactions. These four
transactions follow the same transaction lifecycle as introduced
in Section II-C. However endorsers in each transaction can be
different according to the speciÔ¨Åc endorsement policy setting.
Fig. 5 shows which peers perform as endorsers to execute the
chaincode in each transaction lifecycle.

1) Phase 1: File Transfer Request: A user shall request
the transfer of a particular Ô¨Åle stored at the sender peer and
the request shall pass the access control. In Fabric, a user can
propose a transaction to request a particular Ô¨Åle, and the access
control is governed by a speciÔ¨Åc endorsement policy. For ex-
ample, the endorsement policy can be set as AND(Peer.Sender,
Peer.Receiver), which stipulates both sender peer and receiver
peer should agree on the Ô¨Åle transfer. An endorser checks
if access rules in the corresponding File Profile are
satisÔ¨Åed through smart contracts, and records the results in an
Event entry of the world state. An Event entry is in the
(cid:104)event_ID, flag, file_name, sender,
form of
receiver(cid:105) as shown in Fig. 4, where the f lag is a Boolean
value indicating if the endorser permits the Ô¨Åle transfer.
According to the transaction workÔ¨Çow in Fabric introduced
in Section II-C, when results (i.e. Event entry) returned
from different endorsers are the same, the transaction can
be generated, processed and recorded in a blockchain. The
same Event entries mean the sender and receiver reach a

Off-StateWorld StateNode1Off-StateWorld StateNode2Off-StateWorld StateNode3fileWorld StateWorld StateWorld StateSmart ContractNode2Smart ContractNode3Smart ContractNode1TXTXTXTXF2F1F3Off-StateOff-StateOff-StateF1Sender PeerReceiver PeerUserfile nameùêª(ùêπ)owneraccess ruleevent IDùëìùëôùëéùëîfile namesenderreceiverkey IDùêª(ùêπùëíùëõùëê)ùë≤ùíÇùíÜùíîùêæùëùùë¢ùëèùëôùëñùëêSignature(ùêπùëíùëõùëê)ùêπùëíùëõùëêùêπsendlockdescriptionevent IDFile ProfileEventEncryption Key4) Phase 4: File Decryption: Finally, the user proposes
the last transaction ‚Äî‚ÄúTx: Ô¨Åle decryption‚Äù‚Äîto query Kaes
to decrypt Fenc. In Fabric, the endorsement policy can be
set as AND(Peer.Receiver) so that the receiver peer performs
as an endorser, which can access Fenc in its off-state stor-
age using smart contract. The receiver peer Ô¨Årst queries the
Encryption Key entry in the world state for Kaes and
then decrypt Fenc.

C. Security Analysis

We now show that the mechanisms in our off-state sharing
protocol can ensure the integrity of chain of custody of
the off-state data. That is, the user cannot deny that she/he
has received the requested off-state data. We assume the
underlying blockchain infrastructure, i.e. all peers, is secure,
and smart contracts execute as designed. The assumption is
reasonable since the peer administrators can adjust the user
privilege to meet the need.

An auditor can Ô¨Ånd out if a user has received a transferred
Ô¨Åle by searching for two transactions ‚ÄúTx: key access‚Äù and
‚ÄúTx: Ô¨Åle decryption‚Äù related to the particular Ô¨Åle from the
blockchain. In our protocol, the receiver peer has to obtain
Kaes in order to decrypt the encrypted Ô¨Åle Fenc, which the
sender sends. Kaes is stored in the world state of the ledger,
which guarantees the integrity of the data because of the
underlying blockchain framework. When a user proposes the
transaction ‚ÄúTx: key access‚Äù, the receiver peer will receive
Kaes. Once the receiver peer obtains Kaes, the user has to
propose the transaction ‚ÄúTx: Ô¨Åle decryption‚Äù to get decrypted
Ô¨Åle F . It can be observed that if the receiver peer does not
receive Fenc, the user will not propose ‚ÄúTx: key access‚Äù. If
the receiver peer receives Fenc but the user does not propose
‚ÄúTx: key access‚Äù to request Kaes, the receiver peer can not
get the original Ô¨Åle F .

An auditor can also Ô¨Ånd out if a sender peer has transferred a
Ô¨Åle by searching for ‚ÄúTx: Ô¨Åle transfer‚Äù related to the particular
Ô¨Åle from the blockchain. In our protocol, ‚ÄúTx: Ô¨Åle transfer‚Äù
will trigger smart contracts to transfer a Ô¨Åle in the off-state
storage and stores Encryption Key in the world state.
The integrity of ‚ÄúTx: Ô¨Åle transfer‚Äù can be guaranteed by the
underlying blockchain framework.

A user may wrongfully claim she/he receives a wrong Ô¨Åle f .
The transaction history maintained by the blockchain system
actually provides proofs to dispute the claim. ‚ÄúTx: Ô¨Åle upload‚Äù
and ‚ÄúTx: transfer request‚Äù can provide proofs to verify the
integrity of the transferred Ô¨Åle. In our protocol, a Ô¨Åle owner
records File Profile in the world state by proposing ‚ÄúTx:
Ô¨Åle upload‚Äù. The sender peer and receiver peer should agree
on a Ô¨Åle sharing event which is recorded in the Event entry
by ‚ÄúTx: transfer request‚Äù. The Ô¨Åle name in Event is related
to a particular File Profile. ‚ÄúTx: transfer request‚Äù in
blockchain can prove the sender and receiver peers have agreed
on transferring a speciÔ¨Åc Ô¨Åle and H(F ) in File Profile
can be used to verify if f matches with H(F ).

Fig. 5. Four phases in the off-state sharing protocol

consensus, either denial of or agreement on the Ô¨Åle transfer.
We call the corresponding transaction ‚ÄúTx: transfer request‚Äù.

2) Phase 2: Encrypted File Transfer: After the Ô¨Åle transfer
request is approved, the user proposes another transaction‚Äî
‚ÄúTx: Ô¨Åle transfer‚Äù‚Äîto initiate the Ô¨Åle transfer. In Fabric,
the endorsement policy for ‚ÄúTx: Ô¨Åle transfer‚Äù can be set as
AND(Peer.Sender), which means only the sender peer works
as an endorser. The sender peer/endorser Ô¨Årst checks f lag in
the corresponding Event entry. The Ô¨Åle transfer continues
only if f lag is T rue.

The sender peer can then encrypt and sign the Ô¨Åle, and
send the encrypted Ô¨Åle to the receiver peer via a Ô¨Åle transfer
protocol such as SFTP. The receiver peer stores the encrypted
Ô¨Åle in its off-state storage. In Fabric, the encryption key and
related information of the encrypted Ô¨Åle are put in the world
state as an Encryption Key entry which is a PDC. PDC
can guarantee that only PDC members can see the actual en-
cryption key and others only know its hash. In this phase, only
the sender peer is the PDC member. The Encryption Key
entry is in the form of (cid:104)key_ID, event_ID H(Fenc),
Kaes, Signature(Fenc), Kpublic (cid:105), where Kaes is the key
to decrypt the encrypted Ô¨Åle.

3) Phase 3: Key Retrieval: A user Ô¨Årst checks if the
receiver peer has received the transferred Ô¨Åle. Only after the
receiver peer has received the Ô¨Åle does the user propose
a transaction‚Äî‚ÄúTx: key access‚Äù‚Äîto request Kaes from the
sender peer to decrypt the encrypted Ô¨Åle Fenc. Otherwise,
the user does nothing. In Fabric, a user can send a query
to the receiver peer to check if Fenc exists. The
request
query request will not generate a transaction. Recall only the
sender peer stores the original Kaes and other nodes store
the hash. The endorsement policy for ‚ÄúTx: key access‚Äù is set
as AND(Peer.Sender) so that the sender peer performs as an
endorser and adds the receiver peer to the PDC member list.
Therefore, the receiver peer will be able to retrieve Kaes.

Peer (Receiver ) Peer(Sender )UserTx: transfer requestTx: transfer requestencrypt file and set Encryption Key entryTx: file transferTx: key accessgrant receiver the access to Encryption Key entry Tx: file decryptionquery Encryption  Keyand decrypt file set Event entryset Event entrySender Node  Receiver NodeReceiver UserTx: request permissionTx: request permissionTx: file transferencrypt file and set Encryption Key entrysend encrypted fileTx: file transferTx: request keychange access of Encryption Key entryTx: request keyTx: decrypt fileTx:  decrypt fileget Encryption  Keyand decrypt file set Event entryset Event entryencrypted fileData OwnerTABLE II
BLOCKCHAIN NODE INFORMATION IN PROTOTYPICAL BOSS

Computer Role

OS Memory Disk

1

2

3

Sender

Receiver

Auditor

Ubuntu
18.04

Ubuntu
18.04

Ubuntu
16.04

64GB 1TB

32GB 1TB

64GB 1TB

CPU
Intel Xeon(R) Gold
6128 CPU@3.40GHz
√ó24 Processor
Intel Core i7-6700
CPU@3.40GHz
√ó 8 Processor
Intel Xeon(R) Gold
6128 CPU@3.40GHz
√ó 49 Processor

that a buffer size of more than 1MB will not reduce the latency
further. So we set the buffer size as 1MB in our system.

Fig. 7. SFTP latency versus buffer size

We use Ô¨Åles of different types and various sizes to evaluate
BOSS‚Äô feasibility and performance. Table III lists those test
Ô¨Åles. Recall that a Ô¨Åle sharing session involves four transac-
tions as shown in Fig. 5. We evaluate the latency of different
transactions and the latency of the whole session. We evaluate
how the Ô¨Åle size and the parallel Ô¨Åle transfers affect the latency.

TABLE III
TEST FILE LIST

Type
.pdf
.mp4
.tif
.zip
.rar
.zip

Size
67MB
218MB
576MB
1.2GB
2.6GB
5.3GB

Describtion
‚ÄúC++ Primer Plus‚Äù eBook
An over 5 hours song list video
The image of Moon from NASA
A collection of medical images
The compressed Ô¨Åle of one movie
The compressed Ô¨Åle of two movies

TABLE IV
PERCENTAGE OF SFTP LATENCY IN ‚ÄúTX: FILE TRANSFER‚Äù LATENCY

Size
67MB
218MB
576MB
1.2GB
2.6GB
5.3GB

1 Parallel
75.30%
88.05%
92.43%
91.18%
86.24%
85.84%

2 Parallel
85.33%
92.82%
94.86%
85.13%
85.71%
83.56%

4 Parallel
93.38%
95.73%
87.50%
83.86%
84.36%
81.39%

8 Parallel
92.01%
84.13%
82.33%
83.71%
84.08%
82.68%

Fig. 6. Prototypical off-state sharing system (BOSS) based on Hyperledger
Fabric

V. EVALUATION

We have implemented a prototypical off-state sharing sys-
tem, BOSS, based on Hyperledger Fabric, and evaluate its
feasibility and performance in this section.

A. Experiment Setup

Fig. 6 shows the prototypical BOSS, which has three organi-
zations, i.e. org1, org2 and org3. Org1 and org2 are the sender
and the receiver, and each party contributes one peer node and
one client (user/owner) node. Org3 is an auditing organization,
and contributes one peer node and one orderer node. We
implement our off-state sharing protocol using chaincode of
Fabric and adopt SFTP [13] to perform Ô¨Åle transfer.

It can be observed that

in our system, peer nodes are
different from the conventional Fabric peer nodes. We integrate
an off-state storage and the SFTP service into peer nodes of
interest. The chaincode can transfer and retrieve Ô¨Åles from the
local off-state storage.

We implement the prototypical system and deploy it across
three physical computers. Table II lists the conÔ¨Åguration of the
computers for sender, receiver and auditor nodes. The sender
computer and the receiver computer are located in different
buildings on a university campus. All Fabric nodes run in
Docker containers, which form the Fabric network. We use
Golang to develop the chaincode and use Node.js to develop
the client application that a user uses to propose transactions
to the peer nodes.

B. Performance and Feasibility

We use Golang‚Äôs SFTP package to perform Ô¨Åle transfer and
Ô¨Ånd that the sender‚Äôs buffer size parameter affects speed and
latency of SFTP. The latency refers to how long it takes to
Ô¨Ånish a particular operation. To Ô¨Ånd an optimal buffer size, we
conduct SFTP with different buffer sizes between two docker
containers on physical Computer 1 and Computer 2 using a
576MB Ô¨Åle and a 1.2GB Ô¨Åle. Fig. 7 shows how the buffer size
affects the Ô¨Åle transfer latency of SFTP. It can be observed

Chaincode:func AddFile ()func Agreement ()func Transfer ()func RequestKey ()func QueryKey ()Peer1Off-State@Node #1I/OWorld State:file recordevent recordI/OWorld State:file recordevent recordOrg 2 ‚Äì ReceiverOrderer 1Client 11. Proposal2. Response1. Proposal2. Response3. TxOrg 1 ‚Äì Sender4. Block5. Verify5. Verify4. BlockF1F3F2Chaincode:func AddFile ()func Agreement ()func Transfer ()func RequestKey ()func QueryKey ()Peer2Off-State@Node #2F4F6F5World State:file recordevent recordOrg 3 ‚Äì Auditor5. VerifyChaincode:func AuditPolicy1 ()func AuditPolicy2 ()func AuditPolicy3 ()Peer3Client 2a. SCPb. SCPc. SFTP4. BlockChaincodePeer1Off-State@Peer 1Computer 2: Receiver@Org2Orderer 1Client 11. Proposal2. Response1. Proposal2. Response3. Tx Computer 1: Sender@Org14. Block5. Validate5. Validate4. BlockF1F3F2ChaincodePeer2Off-State@Peer 2F4F6F5Computer 3: Auditor@Org35. ValidateChaincodePeer3Client 2a. SFTPb. SFTPc. SFTP4. BlockWorld State:file profileevent encryption keyWorld State:file profileevent encryption keyWorld State:file profileevent encryption keyChaincode:func SetPermission ()func TransferFile ()func RequestKey ()Peer1Off-State@Peer 1Org 2 ‚Äì ReceiverOrderer 1Client 11. Proposal2. Response1. Proposal2. Response3. TxOrg 1 ‚Äì Sender4. Block5. Validate5. Validate4. BlockF1F3F2Chaincode:func SetPermission ()func DecryptFile()Peer2Off-State@Peer 2F4F6F5Org 3 ‚Äì Auditor5. ValidateChaincode:func Audit ()Peer3Client 2a. SFTPb. SFTPc. SFTP4. BlockWorld State:file profileevent encryption keyWorld State:file profileevent encryption keyWorld State:file profileevent encryption key271.55196.48114.8386.3982.4782.5881.36658.36435.99250.62187.71182.05185.61189.165015025035045055065075010KB20KB200KB1MB100MB500MB1GBSFTP Latency (s)Buffer Size576MB1.2GBFig. 8. Transaction latency of ‚ÄúTx: transfer re-
quest‚Äù and ‚ÄúTx: key access‚Äù

Fig. 9. SFTP latency and transaction Latency of
‚ÄúTx: Ô¨Åle transfer‚Äù and ‚ÄúTx: Ô¨Åle decryption‚Äù

Fig. 10. File sharing session latency

Fig. 11.
request‚Äù in different parallel transfer cases

Transaction latency of ‚ÄúTx:

transfer

Fig. 12. Transaction latency of ‚ÄúTx: key access‚Äù
in different parallel transfer cases

Fig. 13. Transaction latency of ‚ÄúTx: Ô¨Åle transfer‚Äù
in different parallel transfer cases

Fig. 14. SFTP latency in different parallel transfer
cases

Fig. 15. Transaction latency of ‚ÄúTx: Ô¨Åle decryp-
tion‚Äù in different parallel transfer cases

Fig. 16. Average Ô¨Åle sharing session latency in
different parallel transfer cases

1) File Size: For each Ô¨Åle in Table III, we conduct the Ô¨Åle
transfer 32 times. Each time only one Ô¨Åle transfer is performed.
The results are shown in Figs. 8‚Äì10.

Fig. 8 shows the latency of ‚ÄúTx: transfer request‚Äù and ‚ÄúTx:
key access‚Äù across different Ô¨Åle sizes. It can be observed that
the latency of these two transactions are relatively stable and
the Ô¨Åle size has minor affect on the latency. This is reasonable
since these two transactions only operate on the world state
data.

Fig. 9 shows the latency of ‚ÄúTx: Ô¨Åle transfer‚Äù and ‚ÄúTx: Ô¨Åle
decryption‚Äù. It can be observed that the latency of these two
transactions rapidly increase as the Ô¨Åle size increases. The
reason is ‚ÄúTx: Ô¨Åle transfer‚Äù involves multiple cryptographic
calculations to encrypt Ô¨Åles and uses SFTP to transfer the Ô¨Åle.
Fig. 9 shows the latency of the SFTP transmission. Table IV
shows the percentage of the SFTP latency in the ‚ÄúTx: Ô¨Åle

transfer‚Äù latency. It can be observed that the SFTP latency
accounts for a large proportion of the whole ‚ÄúTx: Ô¨Åle transfer‚Äù
latency. ‚ÄúTx: Ô¨Åle decryption‚Äù involves multiple cryptographic
calculation to decrypt the Ô¨Åle. So it is reasonable that its
latency is affected by the Ô¨Åle size.

Fig. 10 shows the average latency of one Ô¨Åle sharing session.
It can be observed that the latency of one Ô¨Åle sharing session
rapidly increases as the Ô¨Åle size increases. It is reasonable
because normally more time is needed to transfer larger Ô¨Åles.

to Ô¨Ånd out

2) Parallel Transfer: We also want

if we
can transfer multiple Ô¨Åles in parallel between two nodes and
evaluate the performance. In our experiments, for each Ô¨Åle,
the number of simultaneous parallel Ô¨Åle transfer sessions is 1,
2, 4 and 8, denoted as 1-P, 2-P, 4-P and 8-P in Figs. 11‚Äì16,
which show the experiment results. In each case, the Ô¨Åle is
transferred 32 times in total. For example, in the case of 4-P

FileSize67M218M576M1.2G2.6G5.3GLatency(s)22.533.544.55transfer requestkey accessFileSize67M218M576M1.2G2.6G5.3GLatency(s)020040060080010001200file transferSFTPfile decryption31.3157.04118.57243.03637.891262.7202004006008001000120067M218M576M1.2G2.6G5.3GLatency (s)File SizeFileSize67M218M576M1.2G2.6G5.3GLatency(s)22.533.544.551-P2-P4-P8-PFileSize67M218M576M1.2G2.6G5.3GLatency(s)22.533.544.551-P2-P4-P8-PFileSize67M218M576M1.2G2.6G5.3GLatency(s)0100020003000400050006000700080009000100001-P2-P4-P8-PFileSize67M218M576M1.2G2.6G5.3GLatency(s)0100020003000400050006000700080009000100001-P2-P4-P8-PFileSize67M218M576M1.2G2.6G5.3GLatency(s)02004006008001000120014001600180020001-P2-P4-P8-P31.3141.8567.77112.657.0486.81147.52304.58118.57244.05497.30977.67243.03544.581161.572227.06637.891397.922400.965297.641262.722493.734701.379730.880100020003000400050006000700080009000100001-P2-P4-P8-PLatency(s)ParallelNumber67M218M576M1.2G2.6G5.3G(4 parallel Ô¨Åle transfer session), we perform the experiments
8 times and the Ô¨Åle is transferred 32 times (4 √ó 8).

We make the following observations. As the number of
parallel sessions increases, the latency of ‚ÄúTx: transfer request‚Äù
and ‚ÄúTx: key access‚Äù is relatively stable as shown in Fig. 11
and Fig. 12. However the latency of ‚ÄúTx: Ô¨Åle transfer‚Äù and
‚ÄúTx: Ô¨Åle decryption‚Äù increases as the number of parallel ses-
sions increases. Fig. 14 further shows the latency of SFTP in-
volved in ‚ÄúTx: Ô¨Åle transfer‚Äù in different parallel transfer cases.
Table IV shows the percentage of SFTP incurred latency in the
‚ÄúTx: Ô¨Åle transfer‚Äù latency. It shows the same trend as ‚ÄúTx: Ô¨Åle
transfer‚Äù and accounts for the most of the transaction latency.
Fig. 16 shows the average latency of one Ô¨Åle sharing session
in different parallel transfer cases. It can be observed that the
average Ô¨Åle transfer session latency increases as the number of
parallel transfer sessions increases. This is reasonable because
simultaneous parallel Ô¨Åle transfer sessions share the network
bandwidth. More sessions mean less network bandwidth for
each Ô¨Åle transfer session.

VI. DISCUSSION

In this section, we discuss the impact of chaincode execution
timeout on big Ô¨Åle sharing, potential implementation of BOSS
with other blockchain frameworks, difference between off-
state and off-chain and out-of-band distribution of received
Ô¨Åles by users.

A. Chaincode Execution Timeout

timeout value is 30s. In BOSS,

In Fabric, chaincode has a system wide execution timeout
setting. The default
the
chaincode invokes SFTP for Ô¨Åle transfer and waits for SFTP
to Ô¨Ånish. However, 30s is far from enough for transferring a
big Ô¨Åle and the chaincode will time out. This timeout setting
can be changed in the docker conÔ¨Åguration Ô¨Åle of Fabric, but
cannot be changed at runtime based on the size of the Ô¨Åle.
We Ô¨Ånd setting the timeout to inÔ¨Ånity does not work in Fabric
either and plan to revise Fabric as future work so that we can
change the timeout Ô¨Çexibly.

B. Implementation based on Other Blockchain Frameworks

Bitcoin is not appropriate to implement BOSS. First, Bitcoin
is a permissionless blockchain system. It is hard to implement
access control. Second, Bitcoin essentially is a blockchain-
based cryptocurrency application. There is no existing mech-
anism like smart contracts for programming. It will be a
challenge and tedious to develop other applications over it.

Enterprise Ethereum [14] can be used to implement a
blockchain off-state sharing system. Enterprise Ethereum [15]
[16] is a permissioned blockchain framework for enterprise
applications. It has many similar features to Fabric. First, there
is a private world state as well as a public world state for
each enterprise Ethereum node. The private world state is only
shared within a private group. Enterprise Ethereum provides
a private transaction manager, which can be used to keep
transactions private among a private group. The private world
state is similar to PDC in Fabric and can be used to manage

the encryption key access required by BOSS. Second, there
is a private contract mechanism. A private contract is only
available and executed on a subset of nodes. This is actually
similar to customizable chaincode in Fabric and is Ô¨Çexible
for the sender/receiver peers to implement their own business
logic. Third, the language of smart contracts is Solidity [17]
in Ethereum. Solidity is a Turing-complete program language
which can be used to implement a business logic.

C. Difference between Off-State and Off-Chain

Off-state is different from off-chain [18]‚Äì[20], and existing
off-chain protocols can not be utilized to ensure the safety
of off-state data. The off-chain technique is designed to scale
the blockchain systems and improve transaction throughput.
It constructs transactions off-chains, and submits one trans-
action containing the Ô¨Ånal results to update the world state.
Essentially, the off-chain protocol is designed to guarantee the
safety of the world state. The well-known off-chain technique
is the payment channel in Bitcoin [18]. A payment channel
Ô¨Årst locks some on-chain cryptocurrencies, i.e. the UTXOs
state. Then it constructs transaction off-chains to conduct
micropayments using locked cryptocurrencies, but does not
commit
these transactions involving micropayments to the
blockchain. At last, it commits one transaction that represents
Ô¨Ånal micropayment results to the main blockchain to update
the UTXOs world state. Off-chain can not solve the storage
limitation issues or be used for big Ô¨Åle sharing.

D. Out-of-band Data Distribution

Once the Ô¨Åle is transferred to a user through BOSS, the user
may stealthily send the Ô¨Åle to other parties through out-of-
band commnunication but not through BOSS. It will be hard
to trace those Ô¨Åles. This is a generic problem in data sharing,
not speciÔ¨Åc to our system. Potential solutions include digital
watermark [21] and traitor tracing [22], which adds some addi-
tional information to the Ô¨Åles. Another strategy will be to limit
the user capabilities with the Ô¨Åles to particular workstations
and use physical security and particular conÔ¨Ågurations that
allow Ô¨Åle transfer only through BOSS.

VII. RELATED WORK

Related work on blockchain-based data sharing systems
does not focus on the big Ô¨Åle sharing. It does not address the
speciÔ¨Åc challenges in big Ô¨Åle sharing or solve the problem.

A. Data Sharing in Ledgers

In most existing blockchain-based data sharing systems,
shared data is stored in ledgers. Users set or get shared
data through proposing transactions to the blockchain system.
Transactions are the carriers of the shared data. Wang et al.
[23] utilize the blockchain system as the back end to transmit
and store data from the front-end wireless body area networks
(WBAN). All blockchain nodes maintain the same data and
all participants such as doctors and insurance providers share
the same WBAN data. Zhang et al. [24] propose a blockchain-
based secure and privacy-preserving personal health informa-
tion (PHI) sharing scheme. The original PHI records are stored

in the ledger of the private blockchain of each hospital, and
the consortium blockchain keeps records of the indexes of the
PHI. Jiang et al. [25] propose a blockchain-based platform
for healthcare information exchange. They use two loosely
coupled blockchains to handle different kinds of healthcare
data,
including highly sensitive electronic medical records
(EMRs) and personal healthcare data (PHD). These existing
schemes are not suitable for big Ô¨Åle sharing applications
because big Ô¨Åles cannot be stored in blockchain ledgers due
to the storage limitation as analyzed in Section II-B.

B. Data Sharing Outside Ledgers

There are systems that store shared data outside the ledgers
in blockchain systems. Xia et al. [26] propose a blockchain-
based solution to sharing medical data among cloud ser-
vice providers. In their design, smart contracts retrieve re-
quested data from existing database infrastructure, outside
of a blockchain system. The retrieved results are recorded
in the blockchain. It is impractical to record big Ô¨Åles in a
blockchain. Lu et al. [27] design a blockchain empowered
privacy-preserved data sharing architecture for industrial IoT.
They exploit the privacy-preserved federated learning algo-
rithm to learn the data model and share the data model instead
of revealing the actual data. They use the blockchain to retrieve
and manage the accessibility of data. Zhang et al. [2] choose
to store and exchange only reference pointers of the sensitive
data in the blockchain. A data requester should Ô¨Årst get a token
from the blockchain system and then use the token to access
original data in the database outside the blockchain.

These existing schemes do not focus on big Ô¨Åle sharing.
They also fail
to consider security requirements such as
dealing with dishonest users, and fail to design a protocol
for secure off-state sharing. Wang et al. [28] Ô¨Ånd misuse of
PDC in Fabric may endanger a blockchain system and BOSS
avoids such issues in the implementation.

VIII. CONCLUSION

In this paper, we solve a novel problem‚Äîhow to securely
share big data Ô¨Åles within a blockchain system and establish
the chain of custody of the shared data. Such a data sharing
application is critical for protecting intellectual property (IP)
theft and Ô¨Åghting industrial espionage in Ô¨Åelds including
biomedical research. We denote data such as big Ô¨Åles stored at
a blockchain node but outside of the ledger as off-state. Three
challenges including storage space limitation, privacy require-
ment and security requirement are discovered in implementing
a blockchain off-state sharing system (BOSS). We carefully
present our off-state sharing protocol. The transactions gen-
erated by our protocol will serve as auditing evidence for
the chain of custody. We implement BOSS over Hyperledger
Fabric and conduct extensive experiments to evaluate the
feasibility and performance of BOSS.

REFERENCES

[1] A. M. Antonopoulos, Mastering Bitcoin: unlocking digital cryptocur-

rencies.

‚Äù O‚ÄôReilly Media, Inc.‚Äù, 2014.

[2] P. Zhang, J. White, D. C. Schmidt, G. Lenz, and S. T. Rosenbloom,
‚ÄúFhirchain: applying blockchain to securely and scalably share clinical
data,‚Äù Computational and structural biotechnology journal, vol. 16, pp.
267‚Äì278, 2018.

[3] E. Androulaki, A. Barger, V. Bortnikov, C. Cachin, K. Christidis,
A. De Caro, D. Enyeart, C. Ferris, G. Laventman, Y. Manevich et al.,
‚ÄúHyperledger fabric: a distributed operating system for permissioned
blockchains,‚Äù in Proceedings of the thirteenth EuroSys conference, 2018,
pp. 1‚Äì15.

[4] V. Buterin et al., ‚ÄúA next-generation smart contract and decentralized

application platform,‚Äù white paper, vol. 3, no. 37, 2014.

[5] Ethereum, ‚ÄúEthereum builders guideline,‚Äù 2021, [Online]. (Accessed 26
March 2021). [Online]. Available: https://ethereumbuilders.gitbooks.io
/guide/content/en/what is ethereum.html

[6] CouchDB, ‚ÄúCouchdb: Base conÔ¨Åguration,‚Äù 2021, [Online]. (Accessed
6 Apirl 2021). [Online]. Available: https://docs.couchdb.org/en/latest/c
onÔ¨Åg/couchdb.html?highlight=max document siz

[7] B. Wiki, ‚ÄúWeaknesses,‚Äù 2021, [Online]. (Accessed 26 March 2021).

[Online]. Available: https://en.bitcoin.it/wiki/Weaknesses

[8] B. Forum, ‚ÄúNew bitcoin vulnerability: A transaction that takes at least
3 minutes to be veriÔ¨Åed by a peer,‚Äù 2021, [Online]. (Accessed 26
March 2021). [Online]. Available: https://bitcointalk.org/index.php?to
pic=140078.0

[9] G. Wood, ‚ÄúEthereum yellow paper,‚Äù 2021, [Online]. (Accessed 26
https://ethereum.github.io/yellowp

March 2021). [Online]. Available:
aper/paper.pdf

[10] Etherscan, ‚ÄúEthereum average gas

[Online].
(Accessed 26 March 2021). [Online]. Available: https://etherscan.io/c
hart/gaslimit

limit chart,‚Äù 2021,

[11] Hyperledger, ‚ÄúHyperledger

[Online].
//hyperledger.github.io/fabric-chaincode-java/main/api/index-all.html

(Accessed 26 March 2021).

fabric-chaincode-shim 2.3.1 api,‚Äù 2021,
https:

[Online]. Available:

[12] C. GorenÔ¨Ço, S. Lee, L. Golab, and S. Keshav, ‚ÄúFastfabric: Scaling
hyperledger fabric to 20 000 transactions per second,‚Äù International
Journal of Network Management, vol. 30, no. 5, p. e2099, 2020.
[13] Wikipedia, ‚ÄúSsh Ô¨Åle transfer protocol,‚Äù 2021, [Online]. (Accessed 6
Apirl 2021). [Online]. Available: https://en.wikipedia.org/wiki/SSH F
ile Transfer Protocol

[14] Ethereum, ‚ÄúEthereum mainnet for enterprise,‚Äù 2021, [Online]. (Accessed
13 June 2021). [Online]. Available: https://ethereum.org/en/enterprise/
[15] H. Besu, ‚ÄúHyperledger besu: Privacy,‚Äù 2021, [Online]. (Accessed 13
June 2021). [Online]. Available: https://besu.hyperledger.org/en/stable
/Concepts/Privacy/Privacy-Overview/

[16] GoQuorum, ‚ÄúGoquorum: Privacy,‚Äù 2021, [Online]. (Accessed 13 June
2021). [Online]. Available: https://docs.goquorum.consensys.net/en/sta
ble/Concepts/Privacy/ContractExtension/
[Online].

[17] Wikipedia, ‚ÄúSolidity,‚Äù 2021,

(Accessed 13 June 2021).

[Online]. Available: https://en.wikipedia.org/wiki/Solidity

[18] J. Poon and T. Dryja, ‚ÄúThe bitcoin lightning network: Scalable off-chain

instant payments,‚Äù 2016.

[19] J. Coleman, L. Horne, and L. Xuanji, ‚ÄúCounterfactual: Generalized state

channels,‚Äù Acessed: Nov, vol. 4, p. 2019, 2018.

[20] S. Dziembowski, S. Faust, and K. Host¬¥akov¬¥a, ‚ÄúGeneral state channel
networks,‚Äù in Proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security, 2018, pp. 949‚Äì966.

[21] R. G. Van Schyndel, A. Z. Tirkel, and C. F. Osborne, ‚ÄúA digital
watermark,‚Äù in Proceedings of 1st international conference on image
processing, vol. 2.

IEEE, 1994, pp. 86‚Äì90.
[22] D. Boneh and M. Franklin, ‚ÄúAn efÔ¨Åcient public key traitor tracing
Springer,

scheme,‚Äù in Annual International Cryptology Conference.
1999, pp. 338‚Äì353.

[23] J. Wang, K. Han, A. Alexandridis, Z. Chen, Z. Zilic, Y. Pang, G. Jeon,
and F. Piccialli, ‚ÄúA blockchain-based ehealthcare system interoperating
with wbans,‚Äù Future Generation computer systems, vol. 110, pp. 675‚Äì
685, 2020.

[24] A. Zhang and X. Lin, ‚ÄúTowards secure and privacy-preserving data
sharing in e-health systems via consortium blockchain,‚Äù Journal of
medical systems, vol. 42, no. 8, pp. 1‚Äì18, 2018.

[25] S. Jiang, J. Cao, H. Wu, Y. Yang, M. Ma, and J. He, ‚ÄúBlochie:
a blockchain-based platform for healthcare information exchange,‚Äù in
2018 ieee international conference on smart computing (smartcomp).
IEEE, 2018, pp. 49‚Äì56.

[26] Q. Xia, E. B. Sifah, K. O. Asamoah, J. Gao, X. Du, and M. Guizani,
‚ÄúMedshare: Trust-less medical data sharing among cloud service
providers via blockchain,‚Äù IEEE Access, vol. 5, pp. 14 757‚Äì14 767, 2017.
[27] Y. Lu, X. Huang, Y. Dai, S. Maharjan, and Y. Zhang, ‚ÄúBlockchain and
federated learning for privacy-preserved data sharing in industrial iot,‚Äù
IEEE Transactions on Industrial Informatics, vol. 16, no. 6, pp. 4177‚Äì
4186, 2019.

[28] S. Wang, M. Yang, Y. Zhang, Y. Luo, T. Ge, X. Fu, and W. Zhao,
‚ÄúOn private data collection of hyperledger fabric,‚Äù in 2021 IEEE 41st
International Conference on Distributed Computing Systems.
IEEE,
2021, pp. 1‚Äì11.

