2
2
0
2

r
p
A
9
2

]

R
C
.
s
c
[

1
v
1
9
0
1
0
.
5
0
2
2
:
v
i
X
r
a

Blockchain in a nutshell

Duc A. Tran and Bhaskar Krishnamachari

Abstract Blockchain enables a digital society where people can contribute, collab-
orate, and transact without having to second-guess trust and transparency. It is the
technology behind the success of Bitcoin, Ethereum, and many disruptive applica-
tions and platforms that have positive impact in numerous sectors, including ï¬nance,
education, health care, environment, transportation, and philanthropy, to name a few.
This chapter provides a friendly description of essential concepts, mathematics, and
algorithms that lay the foundation for blockchain technology.

1 Introduction

Let us consider the following favorite game of our childhood: Alice and Bob each
bet $100 on the outcome of a coin toss, whether it is â€œheadâ€ or â€œtailâ€. Alice calls the
outcome and Bob is the tosser. Alice will win the bet if her guess is correct and Bob
will otherwise. It is so easy and simple a game, isnâ€™t it? Not really. What if Alice and
Bob play this game remotely or separated by a brick wall such that Alice does not
see the toss? How can Alice trust that Bob is honest? Bob can easily cheat; knowing
Aliceâ€™s prediction he can say the opposite outcome. Even in the case he is honest,
Alice may not be. She can run away not giving Bob the $100 she bet, assuming she
sprints so fast that he cannot catch her.

The above game is an example of a big real-world problem we see almost every-
where. That is, how to quickly process transactions for everybody, possibly involving
multiple people, in an environment not always honest, where people may not trust
one another?

Duc A. Tran (corresponding author)
University of Massachusetts, 100 Morrissey Blvd, Boston, MA 02125, e-mail: duc.tran@umb.edu

Bhaskar Krishnamachari
University of Southern California, 3740 McClintock Avenue, Los Angeles, CA 90089, e-mail:
bkrishna@usc.edu

1

 
 
 
 
 
 
2

Duc A. Tran and Bhaskar Krishnamachari

Our society has hundreds, thousands, of years been relying on the intermediaries
to solve that problem. If we do not trust each other, let us do the transaction through
a trusted middleman, hence the existence of banks for ï¬nancial activities, central
servers for storage and computation, or, at a larger scale, central governments for
maintaining the society. The trust put on the intermediaries is an assumed trust: we
assume that they will do what they are supposed to do. That is the perfect scenario,
which is not the case in practice. Mistakes are made by humans. Machines fail.
Hackers are always looking for ways to penetrate into systems. Even in an ideal
world where such errors or attacks do not happen, the conventional way of relying
on a central authority to store information, process transactions, or manage activities
for many people and institutions cannot scale. The authority is the bottleneck. It is
increasingly expensive in both money and time when there are more workloads.

This is where blockchain comes in. It is completely decentralized with no inter-
mediary involved. Blockchain overcomes the weaknesses of the centralized inter-
mediary approach in four crucial aspects: trust, security, privacy, and transparency.
Blockchain is trust-less; there is no need to raise the trust question. Bob and Alice
in the aforementioned betting game do not have to worry about the other cheat-
ing. Blockchain is secure; while a central server as a single point of contact can
be attacked or the data therein stored may maliciously be altered, blockchain as a
system always functions correctly 24/7. As identity privacy is of utmost importance
today, it can be leaked in a middleman-based system. Blockchain does not allow this
to happen as it is designed to hide personal identities. Lastly, about transparency,
while todayâ€™s banks may not disclose to us what they do behind closed doors with
our deposited money, blockchain makes all the transactions visible and veriï¬able.
Since there is no concept of personal identity on the blockchain, making transactions
visible does not cause loss of privacy.

Blockchain is capable to provide the above desirable properties thanks to its
architecture as a decentralized network utilizing many computers owned by people.
These computers collectively store and process transactions in a way that although
working autonomously they can still achieve consensus in decision making and be
robust against malfunctions, attacks, dishonesty, and self-interests. On the surface, we
can think of blockchain as an Internet-like infrastructure for processing transactions.
Using the Internet, one can send data from one computer to another without having
to worry about how the data ï¬nds its way to get delivered or whether the data can
be lost; the Internet takes care of all those things so that we can focus on the main
business job. Similarly, if people transact on the blockchain, they do not have to
worry about many what-ifs, including trust about whether the other side may act as
agreed upon or whether money may be lost or data maliciously changed. Blockchain
has its name because, as a digital ledger, the transactions are stored in blocks, each
new block appended to the previous to form a chain; hence the name blockchain.
Two consecutive blocks are mathematically linked in such a way that any change
in an existing block would violate the mathematics of the link with the next block.
The mathematical methods used for this linking are from the ï¬eld of mathematical
cryptography, hence the name crypto in â€œcryptocurrencies" we see trending today.

Blockchain in a nutshell

3

Trust is the biggest bottleneck in realizing transactions. It is the biggest bottleneck
in advancing the society. As a trust-less system, blockchain removes that bottleneck.
It makes sense that many consider blockchain the next big thing since the birth of
the Internet. The Internet removes the geographical constraint, moving people closer
for communication despite geographical distances. Blockchain, by removing the
trust distance, moves people closer for doing actual transactions. Putting blockchain
together with AI, a ï¬eld of great mention today, we can think of AI as the brain of a
system whereas Blockchain is the body. AI needs computing resources and training
data to realize its promise. Blockchain is no less important because it is the best way
to incentivize people to contribute computing power and good data, the only way if
we care about trust, security, privacy, and transparency.

Blockchain is still in an early application stage. The space for blockchain-based
developments is immense. To consider whether blockchain may apply to your busi-
ness, at least four out of six following conditions should hold: 1) data is shared by
multiple parties, 2) data is updated by multiple parties, 3) veriï¬cation is required, 4)
it is expensive to rely on intermediaries, 5) valid transactions must be eventually ex-
ecuted, and 6) transactions are inter-related. Most applications satisfy this, which are
found in almost every sector, including ï¬nancial services, product manufacturing,
energy and utilities, healthcare, e-government, retail and consumer, entertainment
and media, just to name a few.

According to Harvard Business Review [23], one can argue that Blockchain is not
only a disruptive technology, but has the potential to create new foundations for our
economic and social systems; it is a foundational technology. A recent PwC report
[39] projected that Blockchain by 2030 will potentially add 1.76 trillion USD to the
global GDP, create 40 million new jobs, and be used to support 10%-20% of global
business infrastructures. The 2020 annual global blockchain survey of Deloitte [13]
interviewing 1488 business leaders from 14 countries, who had certain knowledge
about Blockchain, found that 39% of the businesses applied Blockchain, a 23%
increase from 2019, 55% considered Blockchain a top-5 priority, and 82% would
hire blockchain staï¬€ within 12 months.

2 What is Blockchain

Having introduced the motivation for Blockchain and its potentials, we now focus
on what it actually is. To non-technical people, one can deï¬ne Blockchain based on
what it oï¬€ers: a computing technology for transaction recording and processing that
is safe (no loss or mutability of data possible), transparent (easy veriï¬cation and
tracing), and trust-less (conï¬dence of transacting without any intermediary). Tech-
nically, the most complete deï¬nition of Blockchain should see it as a decentralized
computing system of ï¬ve constituent components: decentralized networking, mathe-
matical cryptography, distributed consensus, transaction ledger, and smart contracts,
as illustrated in Figure 1:

4

Duc A. Tran and Bhaskar Krishnamachari

Fig. 1 The ï¬ve constituent components of blockchain: decentralized network, cryptography, con-
sensus, ledger, and contracts.

â€¢ Decentralized networking: For computing, Blockchain relies on a decentral-
ized network of computers, called blockchain nodes, that contribute comput-
ing resources to help store and process transactions. These computers work au-
tonomously and communicate with each other in a peer-to-peer (P2P) manner.
Most blockchain networks including Bitcoin adopt an unstructured P2P topology;
i.e., a node chooses its neighbors arbitrarily. Some networks such as Ethereum use
a structured one like Kademlia Distributed Hash Table [32] to optimize the P2P
communication. Unstructured P2P may be less eï¬ƒcient than structured P2P, but
the latter is more diï¬ƒcult to maintain, especially in a permissionless blockchain.
Ethereum uses Kademlia but only as an add-on assistance [45]; in other words, it
still works with any unstructured P2P topology, albeit less eï¬ƒcient if only so.
â€¢ Mathematical cryptography: Cryptographic methods used in blockchain provide
mathematical proofs that the blockchain must function as supposed to. Crypto-
graphic hash is used to link data blocks in the chain so that no data alteration is
allowed post recording into the blockchain. Each transaction is encrypted with
Public-Key cryptography to ensure that the sender is veriï¬able using digital sig-
nature and only the intended recipient of the transaction can be the receiver.
Transaction conï¬dentiality is achieved thanks to the method of Zero Knowledge
Proof [4]. The choice of cryptography to use determines the performance and
guarantees of the blockchain. For example, Dogecoin blockchain clones Bitcoin
but using simpler cryptographic functions to increase transaction throughput; the
mining in Dogecoin is based on SCRYPT which is faster and easier to run than
SHA256 used in Bitcoin. This, however, results in weaker security, less robust to
attacks by dishonest nodes.

â€¢ Transaction ledger: As a storage technology, Blockchain is a digital ledger that
stores the transactions chronologically in blocks which are added in an append-
only manner. This is the default data structure of the ledger for almost all
blockchain networks. However, some blockchain networks, for example, Hed-
era [3] and Fantom [36], design the ledger as a directed-acyclic graph (DAG)

Blockchain in a nutshell

5

of blocks (or transactions) instead of a chain structure which can only append
blocks. A chain is a simple case of DAG because it shares the property of being
directed-acyclic. The former oï¬€ers simplicity but the latter is more eï¬ƒcient in
transaction processing (for example, searching for a transaction is faster). The
ledger structure, the block structure, and the number of transactions in a block are
important considerations when designing the ledger component of the blockchain.
â€¢ Distributed consensus: When a decision needs to be made, for example whether
a transaction is valid, there is no central authority to decide. Instead, the decision
is made based on consensus reached among the participating nodes. Therefore,
a blockchain network must have a consensus protocol to make sure that every
transaction or block added to the blockchain is the one and only version of the
truth that is agreed upon by all the nodes. Proof-of-Work consensus [35], giving
more decision power to nodes with more hardware-computing power, is adopted
in early blockchain networks (Bitcoin, Litecoin, Ethereum in its original version).
Proof-of-Stake consensus [17], giving more decision power to nodes with more
ï¬nancial stake, is popular among todayâ€™s blockchain networks; its ï¬rst functioning
use for cryptocurrency was in Peercoin in 2012 [24]. The choice of consensus
protocol is the most critical consideration in designing a blockchain network.
â€¢ Smart contracts: A blockchain can be considered a non-conventional kind of
computers to perform certain tasks. Instead of being a computer integrating built-
in computing processing units (the CPUs), blockchain is a decentralized computer
utilizing hundreds or thousands of computers anywhere in the world. Applications
that run on the blockchain are implemented as â€œsmart contracts", a term coined
by Nick Szabo in the 1990s [43]. A smart contract is nothing but a computer
program; the term is used because an application deployed on the blockchain
always functions correctly as programmed, like executing the conditions in a
legal contract. This contract is smart because of its automated execution without
human intervention.

Next, we elaborate further on these components and their importance. We do not
attempt to cover every aspect and every detail. Instead, we select certain issues to
discuss hoping that the reader can have a quick understanding of what blockchain
is and requires. More details will follow later to dig deeper into the technicality of
blockchain.

2.1 The Blockchain Computer

We can view Blockchain as a computer whose architecture consists of three layers,
illustrated in Figure 2: the P2P networking layer, the consensus layer, and the logic
layer. For example, Bitcoin is a blockchain computer that implements all these layers,
whereas Ethereum implements the ï¬rst two layers, leaving the logic layer to appli-
cation developers. Bitcoin is a purpose-speciï¬c blockchain computer that performs
only one application: create a digital currency, the Bitcoin cryptocurrency as we all
know, and functions for moving this currency between accounts. This application is

6

Duc A. Tran and Bhaskar Krishnamachari

Fig. 2 Architecture of Blockchain as a new kind of computer.

a built-in logic of the Bitcoin blockchain, and as such smart contract is not a con-
cept of Bitcoin. On the other hand, Ethererum is a universal blockchain computer;
it was designed to enable deployment of arbitrarily-purposed applications on the
blockchain. Therefore, Ethereum is called a smart-contract blockchain network. In
contrast, Bitcoin is an application-speciï¬c blockchain, precisely a cryptocurrency
blockchain.

Viewing Blockchain as a computer is an intuitive observation. Essentially, a
computer is a machine that automates processing of applications, and it is thus
reasonable that blockchain can be seen as a computer, at least virtually. In early years,
with Desktop Computing, we have applications running on a desktop computer near
us, in our home or oï¬ƒce; we control this desktop computer. The past decade has
seen many businesses moving to Cloud Computing; the cloud provider controls the
â€œcloud computer" (AWS cloud of Amazon or Azure Cloud of Microsoft). The future,
very soon, we argue will be the era of Blockchain Computing; nobody controls the
blockchain computer.

This is a natural evolution in computing. Cloud Computing has replaced Desktop
Computing to reduce the cost to maintain the IT system for businesses and at
the same time more eï¬ƒciently utilize computing resources. It is a one-stop shop
to satisfy all computing needs so that companies can focus more time on their
business logic. Compared to Cloud Computing, Blockchain Computing oï¬€ers the
beneï¬t of decentralization and trust guarantees. The cloud provider has the power
to manipulate the cloud computer; we have to trust this organization. Blockchain
Computing is trustless and anyone can be a part owner of it.

2.2 The Blockchain State

To interact with the blockchain, one needs an address, or, interchangeably, an account.
The blockchain state consists of the set of addresses and information about them. As
the state changes from time to time, Blockchain can be modeled as a state machine.

Blockchain in a nutshell

7

It starts with a genesis state (when the blockchain is launched) and transitions from
one state to the next upon triggering events (when transactions are added to the
blockchain). We need to keep track of the blockchain state at any point of time.
Depending on how the blockchain is designed, the stateâ€™s data structure may diï¬€er. It
can be transaction-based (the state information consists of the list of transactions) or
account-based (the state information consists of account balances). The data structure
to represent transactions can also vary. We compare these models below, assuming
for simplicity that each transaction is a transfer of value (asset) between addresses.

2.2.1 Transaction-based Model

In the transaction-based model, known as Unspent Transaction Output (UTXO) [35]
conceived by Bitcoin, each transaction can send value to one or more recipients. It
consists of the following information:
â€¢ Output ï¬eld: A list of receiving addresses and the amount of fund to be sent to

â€¢

each respectively. Each transfer output is called a UTXO transaction.
Input ï¬eld: A list of UTXO transactions that will provide the fund for the transac-
tion. These UTXOâ€™s previously sent funds to the sender and currently are unspent.

Figure 3 provides an example of Bitcoin transactions. The very ï¬rst transaction
Tx1, called the genesis transaction, sends 25 BTC to Alice. The input ï¬eld is empty
because this is the very ï¬rst transaction of the blockchain operation, meaning Alice is
the ï¬rst recipient of Bitcoin (somebody has to be the ï¬rst recipient). This transaction
results in creation of a UTXO transaction, Tx1(#1). The second transaction Tx2 is
initiated by Alice, sending 17 BTC to Bob and the rest, 8 BTC, to herself. The total
fund to send, 17 + 8 = 25 BTC, comes from the fund that Alice previously received
in UTXO Tx1 (#1). Because Tx1 (#1) is unspent, she has enough money for Tx2.
After this execution, UTXO Tx1 (#1) is marked as â€œspentâ€ and new UTXO Tx2 (#1,
#2), are created and marked as â€œunspentâ€. Later, Bob initiates transaction Tx3 to
send 8 BTC to Charlie, with the remaining 9 BTC to himself. The total fund to send,
8 + 9 = 17 BTC, comes from the fund that he previously received in UTXO Tx2
(#2). Because Tx2 (#2) is unspent, he has enough money to execute Tx3. After this
execution, UTXO Tx2 (#2) is marked as â€œspentâ€ and new UTXO Tx3 (#4, #5) are
created.

The blockchain state is the set of current UTXO transactions. Each time a UTXO
transaction is used as an input in a new transaction, the input UTXO will be marked
as â€œspent" thus no longer usable and each output sending fund out will be created as
a new UTXO transaction. The new UTXO transaction(s) may be used later as input
providing funds to future transactions. The marking of input UTXO transactions as
â€œspent" is to avoid double spending, which means spending the same UTXO for two
diï¬€erent transactions. The UTXO blockchain state does not directly provide account
balances. To know how much Alice has in her account, one needs to sum all the
funds she received in current UTXO transactions.

8

Duc A. Tran and Bhaskar Krishnamachari

Fig. 3 The Unspent Transaction Output (UTXO) model: the blockchain state at the current time is
the list of all unspent transactions.

In the case that the total input fund has more than the output, the remaining
balance can be sent to the senderâ€™s own address to avoid losing fund. For example, in
transaction Tx4, Alice sends 3 BTC to Dave out of the 8 BTC she has available from
UTXO Tx2 (#3), but because UTXO Tx2 (#3) will be marked as â€œspentâ€, in order
not to lose the 8 âˆ’ 3 = 5 BTC she has remaining, she creates a new UTXO Tx4 (#7)
to send this 5 BTC to herself. She does not lose any money. In some blockchains, for
example, Bitcoin and Ethereum, Alice may not send all of the remaining balance to
her address; in this case, the leftover will be sent as reward to the blockchain node
that adds this transaction to the blockchain.

2.2.2 Account-based Model

The account-based model [6] is more intuitive. It is like the account model of a
bank. The state consists of the balance information for each address. When there is
a transaction, the balances of the senderâ€™s and receiverâ€™s accounts will be updated
immediately and saved in the state. Therefore, when queried the account balance of
an address is instantly available without any computation.

A transaction in the account-based model is much simpler than a UTXO trans-
action. The former consists of only one receiving address and the amount of fund
to send. It is much faster to verify if the sender has enough fund, which is done by
simply comparing two numbers: whether the senderâ€™s balance exceeds the amount
to send. In contrast, UTXO requires searching the blockchain state to see if the
input UTXOâ€™s are indeed unspent. Consequently, the account-based model oï¬€ers a
clear advantage when it comes to enabling â€œsmart contractsâ€ (computer programs to
deploy applications on the blockchain). For smart contracts, a transaction can be not

Blockchain in a nutshell

9

only a transfer of value, but also a call to a function of arbitrary logic; it contains code
data for executing this function. To process a transaction thus involves execution of
the code in the transaction. As smart contracts are computationally expensive, sim-
plicity of computation is important. UTXO creates computational overhead because
all spending transactions must be explicitly recorded.

UTXO is suitable for a cryptocurrency blockchain like Bitcoin which serves only
one application: transfer of money. Computation is not that complex. Another reason
is due to transparency and traceability. Back to Figure 3, if we want to know how
Dave received 3 BTC from Alice in transaction Tx4, we can trace all the way to the
beginning how the fund started and ï¬‚owed. We can ï¬nd that it started from Alice in
Tx1 (#1) to Alice in Tx2 (#3) to Dave in Tx4 (#6). In other words, every transfer has
a non-fungible path. With the account-based model, if Dave received 3 BTC from
Alice, this fund is fungible; we only know that this 3 BTC came from Alice, not
knowing any further where this particular 3 BTC arrived at Alice. In other words,
UTXO is more transparent. That said, one could argue that the account-based model
oï¬€ers better privacy.

2.3 The Chain Structure

By default, and adopted in all but a few unpopular blockchain designs, the blockchain
ledger follows a chain structure. The data is organized into a chain of data blocks:
ğ‘1, ğ‘2, ğ‘3, ...When new transactions need to be saved, they are put in a new block
which will be appended to the last block of the existing chain. In an account-based
blockchain, e.g., Ethereum, a block also contains the blockchain state information
(the balances of all the accounts at the current time).

Besides storing the transaction data, blockchain state if applicable, and necessary

header information, the block has two important attributes:
â€¢ Block ID ğ‘ğ‘–.ğ‘–ğ‘‘: This is set to the hash value of the block content using a cryp-
tographic hash function ğ»; i.e., ğ‘ğ‘–.ğ‘–ğ‘‘ = ğ» (ğ‘ğ‘–). This hash function is predeï¬ned
and publicly known.

â€¢ Previous hash ğ‘ğ‘–.ğ‘ğ‘Ÿğ‘’ğ‘£: This is set to the ID of the previous block ğ‘ğ‘–âˆ’1 to which

ğ‘ğ‘– is appended; i.e., ğ‘ğ‘–.ğ‘ğ‘Ÿğ‘’ğ‘£ = ğ‘ğ‘–âˆ’1.ğ‘–ğ‘‘.

It is noted that the block ID may not necessarily be stored in the block because it can
be computed from the blockâ€™s content.

The previous-hash information is critical in maintaining the data integrity of the
chain. If any part of any block is changed after it is recorded in the blockchain, this
will be detected. This is because for a new block to be added to the blockchain it
must pass a procedure called block validation. A new block ğ‘ğ‘–+1 is valid if and only
if
1. Previous-hash is consistent: ğ‘ğ‘–+1.ğ‘ğ‘Ÿğ‘’ğ‘£ = ğ» (ğ‘ğ‘–)
2. All the transactions in ğ‘ğ‘–+1 are valid
3. Previous block ğ‘ğ‘– is valid

10

Duc A. Tran and Bhaskar Krishnamachari

Let us put Step 2 aside (to be discussed later). The veriï¬cation in Step 1 requires
computing the hash value of ğ‘ğ‘– and comparing it with ğ‘ğ‘–+1.ğ‘ğ‘Ÿğ‘’ğ‘£. Step 3 requires
running the same block validation procedure to verify the validity of block ğ‘ğ‘–.
Consequently, the validation procedure for block ğ‘ğ‘–+1 requires checking whether the
previous-hash value stored in block ğ‘ ğ‘— equals the hash value of its previous block
ğ‘ ğ‘—âˆ’1 for all ğ‘— â‰¤ ğ‘– + 1. If an earlier block, say ğ‘ ğ‘—âˆ’1, has been changed from its original
value, when we compute its hash value, ğ» (ğ‘ ğ‘—âˆ’1), we will ï¬nd it not identical to the
previous-hash value ğ‘ ğ‘— .ğ‘ğ‘Ÿğ‘’ğ‘£ stored in block ğ‘ ğ‘— . This is a violation and as a result
the new block ğ‘ğ‘–+1 is concluded to be invalid and not added to the blockchain.

A consequence of block ğ‘ ğ‘— being changed is that the blockchain will never grow
beyond the time of this change. One might say, â€œthat means, the blockchain is useless
then, because just one blockâ€™s modiï¬cation halts the whole blockchainâ€. This is true
if the blockchain network consists of only one computer. In practice, the blockchain
network runs many computers, where the blockchain data is replicated on every
computer node. For a node to ensure that its blockchain copy is correct (same as
the globally correct version), it needs to compare its copy with that of the neighbors
and choose to use the longest1 blockchain as the correct one. Before this comparison
takes place, the node needs to check the validity of each neighborâ€™s blockchain copy,
which requires validating all the blocks in this copy. Therefore, if a blockchain copy
from some node contains a violation, this copy will fail the validation step. As such,
the bad copy will not be used by the honest nodes in the network.

2.4 Use of Cryptography

It is now clear that the data immutability of the blockchain is achieved thanks to
the previous-hash information linking between consecutive blocks in the blockchain.
However, in theory, a hash function may have diï¬€erent input values resulting in the
same hash output, meaning that block ğ‘ ğ‘—âˆ’1 can be changed from its original value
such that its hash value, ğ» (ğ‘ğ‘–âˆ’1), remains the same as before, which equals the
previous-hash value ğ‘ ğ‘— .ğ‘ğ‘Ÿğ‘’ğ‘£ stored in block ğ‘ ğ‘— . In this case, the block validation
procedure cannot detect the change. The choice of the hash function is therefore
critical. We should choose one so that even though such a block alteration without
being detected is theoretically possible, realizing it is practically impossible. For
this reason, the hash function ğ» used in blockchain must be a cryptographic hash
function, not any arbitrary hash function.

Recall that a hash function is a one-way function that takes an input of arbitrary
length to output a string of constant length, here assuming that values are represented
as binary strings. For example, SHA256 is a hash function that outputs a binary string
of 256 bits. A cryptographic hash function ğ» is a hash function with three properties:

1 Comparing based on blockchain length (the number of blocks in the blockchain) is adopted in most
blockchain networks, but other comparison criteria have also been explored, for example, choosing
the â€œheaviestâ€ blockchain copy as the correct one, where â€œheavinessâ€ is a weighted-generalization
of the length.

Blockchain in a nutshell

11

â€¢ Collision-resistant: It is infeasible to ï¬nd diï¬€erent input messages ğ‘¥ and ğ‘¦ such

that ğ» (ğ‘¥) = ğ» (ğ‘¦).

â€¢ Hiding: Given the output ğ‘ = ğ» (ğ‘¥), it is infeasible to ï¬nd an input ğ‘¥.
â€¢ Puzzle-friendly: If we know the hash value ğ‘ = ğ» (ğ‘Ÿ (cid:107)ğ‘¥) of an input message made
by concatenation of ğ‘Ÿ and ğ‘¥, and even if we know part of the input, ğ‘¥, we cannot
reconstruct the remaining input ğ‘Ÿ in time complexity faster than 2ğ‘› where ğ‘› is the
binary length of output ğ‘.
Because of these properties, knowing ğ‘ ğ‘— .ğ‘ğ‘Ÿğ‘’ğ‘£ = ğ» (ğ‘ ğ‘—âˆ’1), it is infeasible to ï¬nd
ğ‘(cid:48)
ğ‘—âˆ’1 â‰  ğ‘ ğ‘—âˆ’1 such that ğ» (ğ‘(cid:48)
ğ‘—âˆ’1) = ğ» (ğ‘ ğ‘—âˆ’1). With ğ» being a cryptographic hash
function, no one can alter an existing block not to be detected. The blockchain data
is tamper-proof.

Cryptographic methods also have many other uses in the operation of a blockchain.
Recall the coin bet between Alice and Bob at the start of this chapter, in which a
situation is what if Bob cheats. A cryptographic hash function ğ» can solve this
cheating problem as follows:
1. Alice: suppose that her prediction is ğ‘¥ (â€œheadâ€ or â€œtailâ€)

â€¢ Generate a secret random number ğ‘Ÿ (of some large binary length ğ‘›).
â€¢ Compute ğ‘ = ğ» (ğ‘Ÿ (cid:107)ğ‘¥) (called â€œprediction commitment").
â€¢ Send ğ‘ to Bob, instead of sending her prediction as raw data.

2. Bob: upon receipt of the prediction commitment ğ‘, he will send Alice the honest
outcome ğ‘¥âˆ— of the coin toss. Because the hash function ğ» is cryptographic, he
does not know the ground-truth prediction ğ‘¥ of Alice, and as such he has no
reason to cheat.

3. Alice: upon receipt of ğ‘¥âˆ—, if her guess is correct, i.e., ğ‘¥ = ğ‘¥âˆ— she will tell Bob that

she wins by sending him the secret number ğ‘Ÿ.

4. Bob: upon receipt of number ğ‘Ÿ, he will verify if the commitment ğ‘ he received

earlier from Alice equals ğ» (ğ‘Ÿ (cid:107)ğ‘¥âˆ—) and convincingly accept the loss.

This solution is called a Commitment Scheme in cryptography [12]. It is critical that
the secret ğ‘Ÿ generated by Alice must come from a large number space. If the binary
length ğ‘› was small, it would take short time for Bob to exhaustively try all possible
values of ğ‘Ÿ and combine with ğ‘¥=â€œheadâ€ or ğ‘¥=â€œtailâ€ to see which combination satisï¬es
ğ» (ğ‘Ÿ (cid:107)ğ‘¥) = ğ‘. When that combination is found, he can cheat by telling Alice that the
outcome is the opposite value of ğ‘¥ found in this combination. When ğ‘› is large, even
though ğ‘¥ can take only two possible values, â€œheadâ€ or â€œtailâ€, Bob cannot reconstruct
the secret ğ‘Ÿ thanks to the â€œpuzzle-friendlyâ€ property of ğ» as a cryptographic hash
function.

The above is a glimpse into how mathematical cryptography helps make a system
trustless. Alice and Bob do not need to question each otherâ€™s honesty thanks to the
Commitment Scheme. However, in the case Alice loses the bet, what if she runs
away? Intuitively, a solution is to at least require that they both have to deposit the
bet money in a lockbox which when the outcome is announced will be unlocked to
transfer all the money to the winner. This is to say that there is a lot more to do and
mathematical cryptography is the main tool to realize all that.

12

Duc A. Tran and Bhaskar Krishnamachari

2.5 Where is Blockchain Stored

As we explained earlier, the blockchain is a decentralized network of computers
contributing computing resources to help with transaction storage and processing.
Among these computers, where is the blockchain data stored? Should we distribute
the blocks in the blockchain ledger across these nodes so that some blocks are
on node 1, some blocks on node 2, etc.? We should not because if node 1 fails,
we cannot access the blocks stored there. Hence some redundancy is needed to
guarantee availability; that is, a block should be replicated on more than one node.
The next question then is, â€œ how much replication is enough?â€. In blockchain, the
blockchain ledger is replicated fully on every node: each node stores a full copy of
the entire blockchain. This is because of the blockchainâ€™s vision to provide complete
decentralization (no node depending on other nodes to access certain blocks) and
complete availability (it is always accessible even in the worst case of failure).

When a new node joins the blockchain network, it must discover existing nodes
as neighbors and connect P2P to them. The new node obtains a blockchain copy
from these neighbors. The list of blockchain nodes is available publicly. In most
blockchain networks, the P2P networking topology can be arbitrary; any existing
nodes can be selected at random, not geographically dependent.

Over the time, since nodes work autonomously and independently, their local
blockchain copies may disagree. To ensure consistency, they need to frequently, or
upon some triggering event such as adding new transactions, send their blockchain
copy to the neighbors or pull blockchain copies from the neighbors. When presented
with multiple blockchain copies, a node must decide which copy is the globally
correct one and uses it. As aforementioned, the default criterion is to choose the
longest copy.

2.6 How to Process a Transaction

When someone initiates a transaction with the blockchain, this is usually done in
a user-friendly front-end application that can interact with the blockchain network
via API calls. This transaction needs to be sent to a blockchain node (in practice,
multiple nodes in case one node may fail or behave wrongly) and will be processed
as follows:
â€¢ Each node ğ‘‹ on ï¬rst receipt of transaction Tx:

â€“ Transaction forwarding: forward transaction Tx to the neighbor nodes of ğ‘‹.
â€“ Transaction veriï¬cation: verify that the sender address of transaction Tx has
suï¬ƒcient fund to send. If so Tx is put into a mempool which is a queue of valid
transactions waiting to be put in a new block.

â€“ Blockchain creation: pull pending transactions from the mempool to include
in a new block ğ‘ and append this block to the existing blockchain ledger at

Blockchain in a nutshell

13

node ğ‘‹. Note that block ğ‘ must include the previous-hash information (the
hash value of the last block).

â€“ Block update: send the new block ğ‘ to the neighbor nodes of ğ‘‹.

â€¢ Each node ğ‘Œ on ï¬rst receipt of block ğ‘

â€“ Block forwarding: forward block ğ‘ to the neighbor nodes of ğ‘Œ .
â€“ Block validation: verify the validity of block ğ‘ on the existing blockchain
ledger of node ğ‘Œ . This validation requires checking on the consistency of
previous-hash information and the validity of every transaction in block ğ‘.
â€“ Block insertion: append block ğ‘ to the blockchain ledger if it is valid. Else,

ignore ğ‘.

To validate a transaction during the Block Validation step above may vary from
one blockchain design to another. In Bitcoin, we only need to verify that the sender of
the transaction has available fund to spend. This veriï¬cation is successful if the input
transactions exist in the blockchain state, meaning they are currently unspent, and
the sum of output amounts in these transactions is suï¬ƒcient. However, in a smart-
contract blockchain network like Ethereum, transaction validation may involve more
work than just checking the balance suï¬ƒciency. If a transaction involves a function
call to interact with a smart contract, the veriï¬cation will need to run this function
with the blockchain in the previous blockchain state (recorded in the previous block)
and if the resulted blockchain state does not match the blockchain state recorded in
the block under validation, the block is considered invalid.

The transaction processing procedure in blockchain is simple and allows for
autonomous processing at the blockchain nodes. This simplicity, however, leads to
several consistency problems. First, each transaction is broadcast to all the nodes
and so the same transaction may be added to diï¬€erent blocks created at diï¬€erent
nodes. We need to ensure that each transaction can only be added to the blockchain
once. Second, diï¬€erent nodes in parallel create diï¬€erent new blocks to attempt to
append to the (same) existing blockchain. We need to ensure that only one of them
will be added as the next block. Third, diï¬€erent nodes may have diï¬€erent copies of
the blockchain. We need to ensure that they have to agree on a copy as the globally
correct version. To resolve these inconsistencies, the nodes have to regularly agree on
the current state of the blockchain, and that is what we call consensus achievement.
We need a consensus protocol.

2.7 How to achieve consensus

Consensus is a research area of computing with more than 30 years of study before
blockchain became popular. It started in the 1970s with the NASA sponsored project,
â€œSoftware Implemented Fault Tolerance (SIFT)â€ [46], aimed to build a resilient air-
craft control system. The challenge was to replicate the system on multiple machines
such that the whole system can sustain multi-machine failures. The nominal work
by Lamport et al. in 1982 [29] formulated this challenge as the now well-known

14

Duc A. Tran and Bhaskar Krishnamachari

â€œByzantine Generalsâ€™ Problem" (BGP). It coined the notion of â€œByzantine Fault" to
model a condition in a distributed system where some nodes are unreliable and may
appear arbitrarily normal or malicious and collude with each other such that there is
no consistent information for the other nodes to declare their malfunction.

A Byzantine Fault Tolerance (BFT) system must avoid complete failure and for
that the nodes must agree on a concerted strategy and live by this consensus, knowing
that some nodes may fail or act maliciously. BGP laid the foundation for research
in distributed consensus. Companies like Google and Facebook started adopting
scientiï¬c results in BFT consensus for mission-critical services such as Google
Wallet and Facebook Credit. The birth of Bitcoin in 2009 [35] was the ï¬rst time that
consensus is realized in a large-scale practical environment in a permissionless and
decentralized manner. The distributed consensus implementation by NASA, Google,
or Facebook is not fully decentralized nor permissionless because the participating
computers are controlled by these organizations. The Bitcoin network is public,
requiring no permission for computers to participate and no centralized authority to
make decisions.

To describe BFT formally, consider a broadcast system of nodes where a sender
node needs to broadcast a message (value) to all the nodes in a peer-to-peer manner.
At the beginning, the sender receives an input value ğ‘š. The broadcast protocol
must result in that at the end each node ğ‘– will output a value ğ‘šğ‘–. The sender and
receivers may be honest or dishonest. This protocol achieves BFT if it satisï¬es two
requirements:
â€¢ Consistency: all honest nodes ğ‘– and ğ‘— must output the same value: ğ‘šğ‘– = ğ‘š ğ‘— .
â€¢ Validity: if the sender is honest, all honest nodes ğ‘– must output value ğ‘šğ‘– = ğ‘š.

A system can be consistent but not valid, when all honest nodes output the same
value but this value is not the same as the senderâ€™s: ğ‘šğ‘– = ğ‘š ğ‘— â‰  ğ‘š. A system can be
valid but not consistent, when the sender is dishonest and some honest nodes output
diï¬€erent values: ğ‘šğ‘– â‰  ğ‘š ğ‘— for some ğ‘–, ğ‘—. Thus, both requirements are needed.

Blockchain is a BFT system. To address inconsistencies due to the autonomous
and independent working of blockchain nodes, the standard solution is for every
node to agree on the consensus that the longest blockchain copy, the one with most
blocks, is the globally correct version. Because the blockchain copies shorter than
the correct blockchain are not used, nodes want to keep their copies as current
as possible because otherwise they would waste eï¬€orts adding their blocks to a
wrong blockchain. As discussed in the previous subsection, nodes frequently update
their blockchain copy to make sure its version is the latest (globally correct one).
Consequently, even though at times some transaction may be recorded in diï¬€erent
blockchain copies at diï¬€erent nodes, diï¬€erent blocks may append to the same last
block of the existing blockchain at diï¬€erent nodes, or diï¬€erent nodes may have
diï¬€erent blockchain copies, eventually these nodes will have the same blockchain
copy.

But that is just theory. If consensus eventuality happens too late, the aforemen-
tioned inconsistencies will cause the system to perform incorrectly; for example,
double spending can happen. Therefore, we need to 1) minimize the likelihood for

Blockchain in a nutshell

15

inconsistencies to happen, and 2) minimize the time it takes to reach blockchain-
consensus eventuality. Toward these, diï¬€erent consensus mechanisms have been
used for blockchain. Major among them are the methods of Practical Byzantine
Fault Tolerance (PBFT) [9], Proof of Work (PoW) [35], and Proof of Stake (PoS)
[17].

3 The Bitcoin Network

We present next the actual working of a real-world blockchain network: Bitcoin. It
is a blockchain network to build a peer-to-peer digital cash system, where the name
of the digital currency is bitcoin (BTC). It has a total supply of 21 million BTC to be
minted over time according to a deterministic schedule such that all will have been
minted in the year of 2140. Technically, it follows the general blockchain framework
described in the previous section. Speciï¬cally, it adopts the UTXO model for the
blockchain state and the chain structure for the ledger. Newly arriving transactions
will be put in a block to be appended to this chain. Any node can create blocks,
and in that case it is called a â€œminerâ€ and the process of creating a block is called
â€œminingâ€. The globally correct blockchain is chosen to be the longest one among all
the local copies. We focus below on the key ideas and methods that are characteristic
of Bitcoin implementation.

3.1 Addresses

To hold bitcoin, one needs to create a wallet. Each wallet corresponds to an address
ğ´, ğ¾ +
(the bitcoin address). When wallet ğ´ is created, it is associated with a pair (ğ¾ âˆ’
ğ´)
of 256-bit private key ğ¾ âˆ’
ğ´ and 256-bit public key ğ¾ +
ğ´ generated according to an
asymmetric cryptography method called Elliptic Curve Cryptography (ECC) [34,
25, 21]. Only the wallet owner knows the private key. The public key is publicly
available. The address of wallet ğ´ is a 160-bit hashed version of its public key ğ¾ +
ğ´:

ğ´ = ğ‘…ğ¼ ğ‘ƒğ¸ ğ‘€ ğ·160(ğ‘†ğ» ğ´256(ğ¾ +

ğ´)).

This is one-way cryptographic hashing using RIPEDMD160 and SHA256 hash
functions. Because only the owner has the private key to unlock the public key, no
one else can take ownership of a transaction that sends BTC to her. For ease of
human readability, Bitcoin addresses are encoded as â€œBase58Checkâ€, which uses 58
characters (a base-58 number system) and a checksum, to produce a string like this
example, â€œ1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy".

16

Duc A. Tran and Bhaskar Krishnamachari

3.2 Elliptic Curve Cryptography

The Elliptic Curve Cryptography (ECC) mentioned above is an approach to public-
key cryptography based on the algebraic structure of elliptic curves over ï¬nite ï¬elds.
The use of elliptic curves in cryptography was proposed in 1985 by Victor S.
Miller [34] and Neal I. Koblitz [25] and became popular in 2004. For cryptographic
purposes, an elliptic curve is a plane curve over a ï¬nite ï¬eld (rather than the real
numbers) with the following equation:

ğ‘¦2 â‰¡ ğ‘¥3 + ğ‘ğ‘¥ + ğ‘ (mod ğ‘)
The shape of the curve depends on the values given to ğ‘ and ğ‘. The size of the ï¬nite
ï¬eld is given by ğ‘, which deï¬nes the length of the keys we want to generate. The
points on the curve are limited to integer coordinates within the square matrix of
size ğ‘ Ã— ğ‘ only. For example, the curve in Figure 4 is ğ‘¦2 = ğ‘¥3 + 7 which is used in
Bitcoin, and the points in Figure 5 are integer points of ğ‘¦2 â‰¡ ğ‘¥3 + 7 (mod 17).

On the elliptic curve, we deï¬ne an algebraic operator on the points called â€œpoint
additionâ€. This operator allows to â€œaddâ€ points to obtain a point on the curve, as
follows (illustrated in Figure 4):
â€¢ Addition ğ‘ƒ + ğ‘„: Draw the line ğ‘ƒğ‘„ and let ğ‘… be the point where ğ‘ƒğ‘„ cuts the curve.

Point ğ‘ƒ + ğ‘„ is the mirrored point of ğ‘… over the x-axis.

â€¢ Double 2ğ‘ƒ = ğ‘ƒ + ğ‘ƒ: Draw the line tangent with the curve at point ğ‘ƒ and let ğ‘… be
the point where this line cuts the curve. Point 2ğ‘ƒ is the mirrored point of ğ‘… over
the x-axis.

â€¢ Multiplication ğ‘šğ‘ƒ = ğ‘ƒ + ğ‘ƒ + ... + ğ‘ƒ: This is the result of adding ğ‘ƒ with itself ğ‘š

times.

Despite its simplicity, a nice property of this operation on elliptic curves when
applied on a ï¬nite ï¬eld (i.e., all the points must be integer points in a ï¬nite square) is
the hardness to compute the discrete â€œlogarithmâ€ ğ‘š such that ğ‘šğ‘ƒ = ğ‘„ given points
ğ‘ƒ and ğ‘„. To date, no algorithm can reconstruct ğ‘š in time complexity faster than
exhaustive search (having to try all possible values for ğ‘š). On the other hand, if
some ğ‘š is given, it is easy to verify its correctness, that is to check whether ğ‘šğ‘ƒ = ğ‘„.
For example, if ğ‘š = 16, we need only log ğ‘š = 4 point additions for veriï¬cation: 2ğ‘ƒ,
4ğ‘ƒ = 2(2ğ‘ƒ), 8ğ‘ƒ = 2(4ğ‘ƒ), and 16ğ‘ƒ = 2(8ğ‘ƒ); in comparison, to ï¬nd the unknown ğ‘š
in ğ‘šğ‘ƒ = ğ‘„ would need 16 point additions.

Thanks to this property, ECC uses elliptic curves over ï¬nite ï¬elds to create a
secret that only the private key holder is able to unlock. We can think of ğ‘„ as the
public key and ğ‘š as the private key. The larger the key size, the larger the curve
space, and the harder the problem is to solve. For example, Secp256k1 with equation
ğ‘¦2 = ğ‘¥3 + 7 and ğ‘ = 2256 âˆ’ 232 âˆ’ 29 âˆ’ 28 âˆ’ 27 âˆ’ 26 âˆ’ 24 âˆ’ 1 is the ECC used by Bitcoin
to implement its public key cryptography. All integer points on this curve are valid
Bitcoin public keys.

Blockchain in a nutshell

17

Fig. 4 Point addition on the elliptic curve (ğ‘¦2 = ğ‘¥3 + 7): (left) adding two diï¬€erent points; (right)
adding two identical points.

Fig. 5 The integer points of the elliptic curve on a ï¬nite ï¬eld: ğ‘¦2 â‰¡ ğ‘¥3 + 7 (mod 17).

3.3 Transactions

Bitcoin transactions are based on the UTXO model. A transaction by default is a
transfer of BTC from a sender to one or more receivers. Every transaction must
have a digital signature of the sender who â€œsignsâ€ with her private key. This way,
anyone who knows her public key can verify that the signature is valid and the
transaction indeed comes from that sender. Each output UTXO is destined for a
receiving address. As we described earlier, each Bitcoin address is an encryption of
its public key. Only the owner of that address has the corresponding private key to
match. Hence, nobody but he can unlock the UTXO to use the fund.

18

Duc A. Tran and Bhaskar Krishnamachari

Fig. 6 Bitcoin joint payment: a transaction can use two or more input UTXOâ€™s that belong to
diï¬€erent payers to collectively provide the fund to send. These multiple payers need to co-sign the
transaction.

A transaction can also be a joint payment which takes as input multiple UTXO
transactions that belong to diï¬€erent addresses. For example, illustrated in Figure 6,
Alice and Bob jointly pay Charlie 25 BTC, where 17 BTC is funded by UTXO #20
of Alice and 8 BTC is funded by UTXO #29 of Bob. This joint transaction needs to
be signed by both Alice and Bob. Joint payments make it more diï¬ƒcult for outside
parties to determine who paid whom.

3.3.1 Transaction Fee

In a transaction, the input fund amount should be at least the output amount. The
leftover is called the â€œtransaction feeâ€ to be sent to the miner who puts this transaction
in a new block. Transaction fees are a way to incentivize miners to participate in
Bitcoin. Rational miners prefer transactions that oï¬€er high transaction fees and so
a transactionâ€™s sender should choose a generous fee to increase its chance to be
processed earlier. To determine the fee, the sender should consider the transaction
size and the network traï¬ƒc. A block can contain a maximum of 4 MB of data, thus
limiting the number of transactions included. A larger transaction will take up more
block data. Thus, larger transactions typically pay fees on a per-byte basis.

3.3.2 Transaction Consolidation

A consequence of Bitcoinâ€™s being a UTXO ledger is that one address may own many
small UTXO transactions. As such, when this address makes a large payment out,
it may need to include as input many UTXOâ€™s. Not only that the transaction size

Blockchain in a nutshell

19

Fig. 7 Bitcoin transaction consolidation: an owner can create a transaction to consolidate the funds
from many UTXOâ€™s he or she owns.

increases, but the transaction veriï¬cation will be more expensive since it involves
verifying many input UTXOâ€™s. For this large transaction to be included in a block,
the sender should pay a high transaction fee. Therefore, it is a good idea for her to
consolidate UTXO transactions if she owns too many of them. This can be done
easily by creating a new UTXO transaction that consumes these existing UTXO
transactions. For example, as illustrated in Figure 7, Alice has funds in UTXO #20
and UTXO #29 and consolidates them by creating UTXO #40. The decision for
transaction consolidation is made at the application level by the wallet owner.

3.3.3 Coinbase Transaction

Transaction fees are not the only incentive for the miners. For each block that is
successfully added to the blockchain, the miner who created this block will receive
a â€œblock rewardâ€. As of March 2022, it is 6.25 BTC per block, which will be halved
automatically after every 210,000 new blocks are added. To get the block reward, the
corresponding miner, say Bob, inserts into the block a special transaction called the
â€œcoinbase transactionâ€ that sends this 6.25 BTC to himself. This coinbase transaction
has no input UTXO, meaning this amount will be minted by the network. If the block
is validated and added to the blockchain, all the transactions in this block, including
Bobâ€™s coinbase transaction, are oï¬ƒcially recorded, eï¬€ectively sending the block
reward to Bob. Coinbase transactions are the only way to mint bitcoin. Except the
genesis bitcoin transfer, bitcoin is minted only by block mining, which is sent to the
miners.

20

3.4 Blocks

Duc A. Tran and Bhaskar Krishnamachari

Block creation is the main job of the miners. A miner pulls pending transactions
from the mempool, typically selecting those with high transaction fees (because
these fees will be paid to the miner) and put them into a block. This is called â€œblock
miningâ€. The very ï¬rst block was added to Bitcoin network timestamped at 2009-
01-03 13:15, called the genesis block, or block 0. It contains only one transaction,
which is a coinbase transaction. This block is hardcoded in the Bitcoin client node
software, so that when nodes join Bitcoin, they will always have the information
about the genesis block.

3.4.1 Block Structure

A Bitcoin block has the following structure: 1) Block size (4 bytes): the size of the
whole block in bytes; 2) Transaction count (variable size, 1 to 9 bytes): the number
of transactions in the block; 3) Transactions (variable size): the list of transactions
included in the block; and 4) Block header (80 bytes): important information useful
for block creation and validation. The block header consists of the following ï¬elds:
â€¢ Version (4 bytes): the version of the Bitcoin node software
â€¢ Previous hash (32 bytes): the hash (ID) of the previous block
â€¢ Merkle root hash (32 bytes): the hash value of the included transactions according

to Merkle Tree

â€¢ Timestamp (4 bytes): the block creation time in second (Unix epoch)
â€¢ Diï¬ƒculty target (4 bytes): a threshold number that is used for Bitcoinâ€™s Proof-of-

Work algorithm

â€¢ Nonce (4 bytes): a counter number that is used for Bitcoinâ€™s Proof-of-Work

algorithm

In Bitcoin, the ID of a block is a hash of its block header, not the whole block
content. It is the value resulted from hashing the block header twice through the
SHA256 algorithm. The block ID is not actually included inside the blockâ€™s data
structure. Anyone can obtain this ID by applying double-SHA256 hashing on the
blockâ€™s header.

3.4.2 Merkle Tree

The transactions are organized in the block as a Merkle Tree [33], a binary tree
where each internal node stores the hash value of the childrenâ€™s values. Figure 8
illustrates such a tree for Bitcoin, where there are eight transactions {ğ·1, ğ·2, ...,
ğ·8}, each stored in a leaf node, internal node ğ»1âˆ’4 = ğ» (ğ»1âˆ’2(cid:107)ğ»3âˆ’4), internal node
ğ»1âˆ’2 = ğ» (ğ»1(cid:107)ğ»2), internal node ğ»1 = ğ» (ğ·1), ğ»2 = ğ» (ğ·2), etc. Bitcoin uses
SHA2 for the hash function ğ».

Blockchain in a nutshell

21

Fig. 8 Merkle tree: a binary tree where each internal node stores the hash value of the childrenâ€™s.

The value at the tree root, e.g., ğ»1âˆ’8, is the Merkle root hash stored in Bitcoin
block header. There are two crucial properties. First, any change in the transaction
data causes a change in the Merkle root hash. As such, if a block is altered, whether
it is in the transaction data or the non-transaction part, the hash of the block will
change and be detected. Second, it is fast to verify the existence of a transaction
in the block. For example, to prove that transaction ğ·7 is in the block, the prover
only needs to provide four values as evidence: ğ»7, ğ»1âˆ’4, ğ»5âˆ’6, ğ»8. The veriï¬er will
compute the following

ğ‘¥ =

ğ‘¦ =

ğ‘§ =

(cid:18)

ğ‘¥(cid:107)ğ»5âˆ’6

(cid:19)

(cid:18)

= ğ»

ğ» (ğ»7(cid:107)ğ»8)
(cid:19)

ğ» (ğ»7(cid:107)ğ»8)(cid:107)ğ»5âˆ’6

(cid:18)

(cid:18)

ğ»

= ğ»

ğ» (ğ»7 (cid:107)ğ»8)(cid:107)ğ»5âˆ’6

(cid:19)

(cid:19)

(cid:107)ğ»1âˆ’4

ğ»

(cid:19)

(cid:18)

ğ»

ğ‘¦(cid:107)ğ»1âˆ’4

and compare ğ‘§ with ğ»1âˆ’8. Their equality means that transaction ğ·7 is in the block.
For a Merkle tree of ğ‘› transactions, it takes O (log ğ‘›) time for this veriï¬cation. It
would take O (ğ‘›) time if we naively store the transactions in an list-like structure.

A node in Bitcoin can be a non-miner node. It is only there to transact with the
network, uninterested in creating blocks to receive block reward. Because the block
header provides suï¬ƒcient information for veriï¬cation and transacting purposes,
the node needs the block header only, not the full block content. Since no actual
transactions are stored, the storage requirement for such a node is modest (only 80
bytes, which can easily be placed in the memory). So is the communication cost to
pull the blockchain copies from the neighbors (only pulling block headers).

22

Duc A. Tran and Bhaskar Krishnamachari

Fig. 9 Proof-of-Work mining algorithm in Bitcoin.

3.4.3 Block ID Rule

After choosing transactions to put in a new block and organizing them into a Merkle
tree, the miner needs to do a ï¬nal critical step on the block before submitting it to the
network (by block broadcasting as we described in the general blockchain framework
in Section 2.6). This step is called â€œminingâ€ or â€œtimestampingâ€. The block needs an
ID and recall that the ID is the hash value of the block header. In Bitcoin, the ID is
not arbitrary, but follows a rule that it must be less than a target value determined by
the diï¬ƒculty target value speciï¬ed in the block header:

ğ‘†ğ» ğ´256(ğ‘†ğ» ğ´256(ğ‘ğ‘™ğ‘œğ‘ğ‘˜_â„ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ))
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:123)(cid:122)
(cid:125)
(cid:124)
ğ¼ ğ·

< (65535 << 208)/ğ‘‘ğ‘– ğ‘“ ğ‘“ ğ‘–ğ‘ğ‘¢ğ‘™ğ‘¡ğ‘¦
(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)
(cid:123)(cid:122)
(cid:125)
ğ‘‡ ğ´ğ‘…ğºğ¸ğ‘‡

(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)

(cid:124)

.

(1)

The block header is known, except for two values that need to be ï¬lled: the
â„ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ_ğ‘›ğ‘œğ‘›ğ‘ğ‘’ value and the ğ‘ğ‘œğ‘–ğ‘›ğ‘ğ‘ğ‘ ğ‘’_ğ‘›ğ‘œğ‘›ğ‘ğ‘’ value. â„ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ_ğ‘›ğ‘œğ‘›ğ‘ğ‘’ is the nonce
attribute of the block header. ğ‘ğ‘œğ‘–ğ‘›ğ‘ğ‘ğ‘ ğ‘’_ğ‘›ğ‘œğ‘›ğ‘ğ‘’ is the value of the coinbase ï¬eld in the
coinbase transaction inserted by the miner to get the block reward. ğ‘ğ‘œğ‘–ğ‘›ğ‘ğ‘ğ‘ ğ‘’_ğ‘›ğ‘œğ‘›ğ‘ğ‘’
is set by the miner for ï¬‚exible purposes. We need to choose these two values such
that the resulted block ID satisï¬es the diï¬ƒculty target according to Inquality (1).

3.4.4 Proof-of-Work Mining

To ï¬nd a satisfactory block ID is not easy due to the double-SHA256 hashing.
No algorithm is better than brute force, which takes O (232): scanning all possible
combinations of â„ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ_ğ‘›ğ‘œğ‘›ğ‘ğ‘’ value and the ğ‘ğ‘œğ‘–ğ‘›ğ‘ğ‘ğ‘ ğ‘’_ğ‘›ğ‘œğ‘›ğ‘ğ‘’ value. A pseudocode
of the mining algorithm is given in Figure 9. The ï¬‚exibility for the miner to set
ğ‘ğ‘œğ‘–ğ‘›ğ‘ğ‘ğ‘ ğ‘’_ğ‘›ğ‘œğ‘›ğ‘ğ‘’ is important here because if we ï¬xed it, we might not be able to
ï¬nd â„ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ_ğ‘›ğ‘œğ‘›ğ‘ğ‘’ among all the 232 possible values such that the diï¬ƒculty target is
met. By allowing the miner to freely choose ğ‘ğ‘œğ‘–ğ‘›ğ‘ğ‘ğ‘ ğ‘’_ğ‘›ğ‘œğ‘›ğ‘ğ‘’, eventually the miner
will ï¬nd a satisfactory block ID.

Blockchain in a nutshell

23

In Inequality (1), if we increase ğ‘‘ğ‘– ğ‘“ ğ‘“ ğ‘–ğ‘ğ‘¢ğ‘™ğ‘¡ğ‘¦, the value of ğ‘‡ ğ´ğ‘…ğºğ¸ğ‘‡ will decrease,
making it more diï¬ƒcult to meet the inequality ğ¼ ğ· < ğ‘‡ ğ´ğ‘…ğºğ¸ğ‘‡. When Bitcoin started
with the genesis block, the diï¬ƒculty was set to ğ‘‘ğ‘– ğ‘“ ğ‘“ ğ‘–ğ‘ğ‘¢ğ‘™ğ‘¡ğ‘¦ = 1, the easiest. Over
the time, this target is dynamically adjusted depending on the transaction traï¬ƒc in
the network. The Bitcoin node software updates this diï¬ƒculty target such that the
blockchain grows at a rate of one new block for every 10 minutes.

The idea of making miners solve the above computationally expensive inequality
is to serve several purposes. If blocks are created too easily, since each newly created
block is broadcast to the network, the communication cost would be very expensive.
Worse, as the miners add blocks autonomously, many blocks simultaneously created
by diï¬€erent nodes will be appended to the same last block of the existing blockchain
(their local copy). This causes not only severe inconsistency and double spending
vulnerability, but also wasted eï¬€orts by most miners due to the fact that only one
block can append next to the existing global blockchain. Furthermore, malicious
nodes can spam the network by creating many fake blocks and broadcasting them.

Bitcoin resolves these problems by making the task of block creation diï¬ƒcult. A
miner must spend some provable eï¬€ort in order to create a block. This is analogous
to real-world miners spending eï¬€orts to discover gold; hence the term â€œBitcoin
miner/miningâ€. The found ID of the block is the proof, hence the term â€œProof-of-
Workâ€ (PoW) always associated with Bitcoin. The challenge of ï¬nding a good ID
satisfactory of Inequality (1) is called the PoW problem. The PoW protocol also
helps keep Bitcoin, as a currency, from inï¬‚ation. Its slow minting and ï¬nite supply
creates circulation scarcity, thus making its price valuable.

The concept of PoW is not new. It was proposed by Dwork and Naor [14] in 1992
to prevent email spamming. Every time you send an email, your computer must
solve a computational puzzle. The recipientâ€™s email program ignores your email if
you do not attach the solution to the puzzle; if you do, the solution veriï¬cation is
quick. A similar idea was proposed in HashCash by Adam Back in 1997 and formally
documented in 2002 [1] for anti-denial-of-service purposes. Bitcoin extended the
PoW idea of HashCash.

3.5 Mining Diï¬ƒculty

Achieving consensus in a permissionless environment is diï¬ƒcult due to Sybil at-
tacks. As nodes communicate with one another in unauthenticated communication
channels, a player can impersonate many others to outnumber the honest players and
disrupt the consensus. This does not apply to a permissioned environment where
the nodes are known to the authority. The choice of the diï¬ƒculty target for PoW is
critical. The more diï¬ƒcult it is, the more robust Bitcoin is against Sybil attacks, as
a bad player must pay a higher cost to harm the network.

24

Duc A. Tran and Bhaskar Krishnamachari

3.5.1 Diï¬ƒculty Setting

In Bitcoin, the PoW diï¬ƒculty is set such that 1) the network is BFT (Byzantine Fault
Tolerant) as long as more than half of the nodes are honest, say 51%, and 2) on
average only one block can be mined in each period of 10 minutes. To understand
how they are related, we present a theoretical method below to ï¬nd a good value for
PoW diï¬ƒculty (some derivations are similar to [42]).

Let ğ‘› denote the number of blockchain nodes and ğ‘ the probability that a given
node creates a block in a round (equal to 10-minutes in Bitcoin). We will set the
diï¬ƒculty target in Inequality (1) to ğ‘‡ ğ´ğ‘…ğºğ¸ğ‘‡ = ğ‘2ğ‘š where ğ‘š is the hash bit length
(256 bits for Bitcoin). Hence, ğ‘ indirectly represents the PoW diï¬ƒculty. For example,
if we set ğ‘ = 1, any given node will 100%-certainly create a block, because Inequality
(1) is always satisfactory regardless of any block ID. However, that would result in ğ‘›
blocks created, violating the 10-minute rule. Our goal is to ï¬nd a good value for ğ‘.
The probability that no honest node creates a block in a round is (1 âˆ’ ğ‘)0.51ğ‘›.
The probability to have a block created by some good node, hence a good block, in
a round is 1 âˆ’ (1 âˆ’ ğ‘)0.51ğ‘›. Consequently, the number of rounds it takes to mine a
good block is

Î› =

1
1 âˆ’ (1 âˆ’ ğ‘)0.51ğ‘›

.

Let Î” be the worse-case network propagation time. It takes this much time for the
mined block to reach all the honest nodes to be added to the good blockchain. An
honest node would not produce the next block during this Î” period to make sure
that the previous block must have reached all the nodes; else, the next block may
be invalid (when validated at other network nodes before the previous block arrives
there). Therefore, the block-mining eï¬ƒciency is the ratio between the mining time
to the actual time it takes for this block to be added to the blockchain:

ğ¸ =

Î›
Î› + Î”

=

1
1âˆ’(1âˆ’ ğ‘) 0.51ğ‘›
1âˆ’(1âˆ’ ğ‘) 0.51ğ‘› + Î”

1

=

1
1 + Î”(1 âˆ’ (1 âˆ’ ğ‘)0.51ğ‘›)

.

Let ğ‘ be the fraction of dishonest mining power, which is the total hashrate of all
the dishonest nodes. We need the hashrate of the honest nodes to exceed that of the
dishonest, i.e., (1 âˆ’ ğ‘) > ğ‘. However, due to the eï¬ƒciency ğ¸, the eï¬€ective hashrate
of the honest is (1 âˆ’ ğ‘)ğ¸, not (1 âˆ’ ğ‘). This block-mining eï¬ƒciency ğ¸ does not apply
to the dishonest nodes who can do whatever they want, for example sending block
after block without considering the Î” delay. So, we should have (1 âˆ’ ğ‘)ğ¸ > ğ‘. To
make the blockchain even more secure, we introduce a parameter ğœ– > 0 arbitrarily
small and make a more stringent requirement:

ğ‘’ ğ‘“ ğ‘“ ğ‘’ğ‘ğ‘¡ğ‘–ğ‘£ğ‘’ â„ğ‘ğ‘ â„ ğ‘Ÿğ‘ğ‘¡ğ‘’ ğ‘œ ğ‘“ ğ‘¡â„ğ‘’ â„ğ‘œğ‘›ğ‘’ğ‘ ğ‘¡
â„ğ‘ğ‘ â„ ğ‘Ÿğ‘ğ‘¡ğ‘’ ğ‘œ ğ‘“ ğ‘¡â„ğ‘’ ğ‘‘ğ‘–ğ‘ â„ğ‘œğ‘›ğ‘’ğ‘ ğ‘¡

> 1 + ğœ– .

(2)

The larger ğœ–, the more secure the network. The left hand side is

Blockchain in a nutshell

25

ğ‘’ ğ‘“ ğ‘“ ğ‘’ğ‘ğ‘¡ğ‘–ğ‘£ğ‘’ â„ğ‘ğ‘ â„ ğ‘Ÿğ‘ğ‘¡ğ‘’ ğ‘œ ğ‘“ ğ‘¡â„ğ‘’ â„ğ‘œğ‘›ğ‘’ğ‘ ğ‘¡
â„ğ‘ğ‘ â„ ğ‘Ÿğ‘ğ‘¡ğ‘’ ğ‘œ ğ‘“ ğ‘¡â„ğ‘’ ğ‘‘ğ‘–ğ‘ â„ğ‘œğ‘›ğ‘’ğ‘ ğ‘¡

=

(1 âˆ’ ğ‘)ğ¸
ğ‘

=

1 âˆ’ ğ‘
ğ‘(1 + Î”(1 âˆ’ (1 âˆ’ ğ‘)0.51ğ‘›))

,

and so we require

1 âˆ’ ğ‘
ğ‘(1 + Î”(1 âˆ’ (1 âˆ’ ğ‘)0.51ğ‘›))
1 âˆ’ ğ‘
ğ‘(1 + ğœ–)

> 1 + Î”(1 âˆ’ (1 âˆ’ ğ‘)0.51ğ‘›)

> 1 + ğœ–

1âˆ’ğ‘
ğ‘ (1+ğœ– ) âˆ’ 1
Î”

(1 âˆ’ ğ‘)0.51ğ‘› > 1 âˆ’

> 1 âˆ’ (1 âˆ’ ğ‘)0.51ğ‘›
1âˆ’ğ‘
ğ‘ (1+ğœ– ) âˆ’ 1
Î”
(cid:19) 1/(0.51ğ‘›)

1âˆ’ğ‘
ğ‘ (1+ğœ– ) âˆ’ 1
Î”

,

1 âˆ’ ğ‘ >

(cid:18)

1 âˆ’

â‡”

â‡”

â‡”

â‡”

which leads to the following important inequality

ğ‘ < 1 âˆ’

(cid:18)

1 âˆ’

1âˆ’ğ‘
ğ‘ (1+ğœ– ) âˆ’ 1
Î”

(cid:19) 1/(0.51ğ‘›)

.

(3)

What this means is that we should choose ğ‘ to satisfy this inequality and the larger
the gap between ğ‘ and this upper bound, the more secure the blockchain is. We can
choose a very small ğ‘ to make the mining diï¬ƒcult (because we set diï¬ƒculty target to
ğ‘‡ ğ´ğ‘…ğºğ¸ğ‘‡ = ğ‘2ğ‘š), but doing so will slow down the transaction processing. A good
ğ‘ is a reasonably high value still satisfying Inequality (3).

Inequality (3) also implies that given the same mining diï¬ƒculty ğ‘, the blockchain
becomes less secure if the value of the right-hand side upper bound is smaller,
because that creates a bigger risk for violating the inequality. The right-hand side
will be smaller if the network delay Î” is longer or if the dishonest hashrate ğ‘ is faster.
This explains why the security of a Bitcoin-like blockchain network is weakened in
a slow network environment.

3.5.2 Diï¬ƒculty Adjustment

Because each miner is solving the Proof of Work puzzle in parallel, on average the
time taken for the ï¬rst miner to solve it reduces inversely proportionally with the
number of miners. At times when there are a lot of miners active on the network,
the time to produce blocks will therefore be lower than when there are fewer miners
active on the network. Since the number of miners on the Bitcoin network is going
to change over time, unless some measure is employed, the block production time
would also vary. In particular, over time if more and more miners joined the network,
it would just keep decreasing. This is problematic as it could result in blocks being

26

Duc A. Tran and Bhaskar Krishnamachari

Fig. 10 Bitcoin PoW mining diï¬ƒculty adjustment over the time as of April 1, 2022. The y-axis is
measured in the number of â€˜0â€™ bits in the preï¬x of the diï¬ƒculty target.

produced too fast, increasing the bandwidth requirements on the network, and also
potentially result in more â€œforksâ€.

To prevent this, the diï¬ƒculty level of block production is periodically adjusted in
a decentralized manner in such a way as to ensure that on average a block is produced
or mined once every 10 minutes. Based on this 10-minute period, we can calculate
that once every 2 weeks, the total number of blocks produced should be 0.1 (block
/ minute) x 60 (minutes / hour) x 24 (hours / day) x 7 (days / week) x 2 (weeks) =
2016 blocks. The protocol therefore adjusts the diï¬ƒculty level after each epoch of
2016 blocks using the following equation: ğ· (ğ‘› + 1) = 2ğ· (ğ‘›)
, Where ğ· (ğ‘›) is the
diï¬ƒculty at epoch ğ‘›, and ğ‘‡ is the time taken in weeks to produce the previous 2016
blocks. If this time is shorter than 2 weeks, then that implies that there must be too
many miners on the network, and therefore the diï¬ƒculty level should be increased;
and on the contrary if this time is longer than 2 weeks, then that implies there are
too few miners on the network and therefore the diï¬ƒculty level should be decreased.
Each miner independently computes the new diï¬ƒculty and will only accept blocks
that meet the diï¬ƒculty that they computed. Figure 10 shows how the Bitcon mining
diï¬ƒculty has changed during the past year (April 2021 - April 2022).

ğ‘‡

3.6 Mining (Un)Fairness

Bitcoin is generally fair in that if a node contributes more computing power, which
is referred to â€œhashrateâ€, it can solve the PoW problem more quickly, thus having a
better chance to earn block reward. If a fast node A and a slow node B both want to add
a block to the existing blockchain at the same time, the block of A is more likely to be
born ï¬rst (with satisfactory block ID) and will be added to the blockchain copies in
the network before the block of B. Naturally, the PoW mechanism encourages nodes
to upgrade computing power to receive more block reward. This healthy competition
leads to a better Bitcoin network.

Blockchain in a nutshell

27

However, not all nodes are good citizens. We have honest nodes who follow the
protocol precisely and responsibly. There are selï¬sh nodes who follow the protocol
but do things to their beneï¬t at the cost of other nodes. The remainder is the nodes
who want to harm the network. To be equitably fair, a node contributing a fraction
of the network hashrate should have the same fraction of blocks accepted by the
network (thus being rewarded). For example, if a node contributes 20% of total
network hashrate, it should own 20% of the blocks in the blockchain. In this aspect,
Bitcoin can be very unfair. We show below that Bitcoin can encounter a situation
where the rate at which a good Bitcoin miner successfully adds a block to the
blockchain is much lower than its hashrate contribution.

3.6.1 Selï¬sh Miner Attack

First, let us explain how a selï¬sh miner A can abuse the network. Each time A has
created a block ğ‘, it does not broadcast the block to the network right away. Instead, A
waits on the event of receiving a new block from another miner, say block ğ‘ of miner
B. When this happens, A will immediately broadcast its block ğ‘ to the network, but
ignore block ğ‘ of miner B (not forwarding it further). If we generalize this strategy
such that A represents the pool of selï¬sh miners and B the pool of honest miners, the
blocks belonging to the selï¬sh will be faster to reach the blockchain nodes than the
honestâ€™s blocks. This is because while A honestly forwards every block, including
Bâ€™s, immediately upon its arrival, B ignores Aâ€™s blocks. As a result, not only B
receives more block reward, but also a lot of Aâ€™s eï¬€orts are wasted.

Bitcoinâ€™s vulnerability to Selï¬sh Mining Attacks was investigated by Eyal and
Sirer in [16]. It is shown that selï¬sh miners can collude to obtain a revenue larger
than their fair share. This attack is potentially serious in that rational miners may
prefer joining the selï¬sh miners leading to a 51% majority, thus destroying the
decentralization of Bitcoin.

3.6.2 Unfairness Severity

Next, let us see how unfair Bitcoin can be from a theoretical view given dishonest
behaviors. Consider the formulation in Subsection 3.5.1. It is shown in [42] that, in
an honest nodeâ€™s blockchain, the honest block fraction is approximately ğœ‡ = 1 âˆ’ 1
1+ğœ– .
Assume a blockchain network with zero propagation delay Î” = 0, which is ideal
for honest nodes because the block creation eï¬ƒciency is ğ¸ = 100%. The honest
hashrate is therefore (1 âˆ’ ğ‘)ğ¸ = 1 âˆ’ ğ‘. Recall ğ‘ as the total hashrate fraction of the
dishonest nodes. Inequality (2) becomes

1 âˆ’ ğ‘
ğ‘

> 1 + ğœ– .

As a result, we have

28

Duc A. Tran and Bhaskar Krishnamachari

ğœ‡ = 1 âˆ’

1
1 + ğœ–

< 1 âˆ’

ğ‘
1 âˆ’ ğ‘

=

1 âˆ’ 2ğ‘
1 âˆ’ ğ‘

which is smaller than the honest hashrate fraction (1 âˆ’ ğ‘).

What this means is that even in a network ideal for the honest nodes, the rate
at which they can add blocks to the blockchain, ğœ‡, is lower than the hashrate they
contribute to the network, (1 âˆ’ ğ‘). For example, when 51% of the network is honest
(i.e., ğ‘ = 49%), they own a fraction ğœ‡ < 1âˆ’2ğ‘
1âˆ’ğ‘ = 3.9% of the blocks on the blockchain.
The dishonest coalition with only 49% hash power owns 96% of the block creation.
So, Bitcoin mining may be unfair when it comes to block reward. Despite this
risk in theory, one may argue that it is unlikely or of little impact in practice. Miners
have ideological considerations and incentives to keep the network decentralized. If
a coalition grows so big to be a concern to the rest of the network, people may leave
Bitcoin due to the lack of decentralization; the coalition would not beneï¬t, of course.

3.7 Block Finality

A malicious miner makes a payment, then secretively creates a second conï¬‚icting
transaction using the same UTXO input in a new block, that allows him to recover
the fund. This is an example of the Double Spending problem. This is feasible if this
miner controls more than 50% hashrate of the whole network, mining faster than
the rest of the network combined. Therefore, his local chain is the longest among all
local copies and will be accepted by the network as the consensus for the globally
correct blockchain.

Even when the bad minor has less than 50% hashrate as in most cases, there is
still a non-zero chance that the bad miner can grow the longest blockchain. Although
this can only last for a short period of time, double spending is not impossible. To
minimize this risk, when somebody pays a merchant to buy something, the merchant
should wait some time to make sure the money is in before delivery. In Bitcoin, the
wait is for 6 block conï¬rmations, i.e., 6 blocks to be added after the block containing
the payment transaction.

Why 6 block conï¬rmations is enough? Consider a miner ğ´ with a fraction ğ‘ of
the total hashrate and a miner ğµ with a smaller fraction ğ‘ = 1 âˆ’ ğ‘ < 1/2. We are
interested in computing the probability that ğµâ€™s blockchain will be longer than ğ´â€™s
after ğ´ adds ğ‘˜ blocks if both nodes start at the same time. This is similar to a race
of two players in a Gambler Ruin problem. In this game, block creations form a
sequence of independent Bernoulli trials. Each trial is the creation of a block which
has two potential outcomes: â€œsuccessâ€ means that the block is created by ğ´ and
â€œfailureâ€ if the block is created by ğµ.

We observe this sequence until ğ´ has created ğ‘˜ blocks (i.e., ğ‘˜ successes). The
number of blocks ğµ created is a Negative Binomial random number, ğ‘‹ âˆ¼ ğ‘ ğµ(ğ‘˜, ğ‘),
which has the following probability mass function:

Blockchain in a nutshell

29

ğ‘ƒ(ğ‘‹ = ğ‘–) =

(cid:19)

(cid:18)ğ‘– + ğ‘˜ âˆ’ 1
ğ‘–

(1 âˆ’ ğ‘)ğ‘– ğ‘ğ‘˜ .

During the time that ğ´ has added ğ‘˜ blocks, the probability that ğµ has created

more than ğ‘˜ blocks, hence winning the race outright, is

ğ‘ƒ(ğ‘‹ > ğ‘˜) =

ğ‘ƒ(ğ‘‹ = ğ‘–) =

âˆ‘ï¸

ğ‘–>ğ‘˜

(cid:19)

(cid:18)ğ‘– + ğ‘˜ âˆ’ 1
ğ‘–

ğ‘ğ‘– ğ‘ğ‘˜ .

âˆ‘ï¸

ğ‘–>ğ‘˜

(4)

In the case that ğµ has created less than or equal to ğ‘˜ blocks, i.e., ğ‘– â‰¤ ğ‘˜, ğµ will be
behind by (ğ‘˜ âˆ’ ğ‘–) blocks and still has a probability (ğ‘/ğ‘) ğ‘˜âˆ’ğ‘– to catch up with ğ´ and
thus win. Summing up these probabilities will lead to the probability that ğµ will win
the race:

ğ‘ƒ(ğ‘˜) = ğ‘ƒ(ğ‘‹ > ğ‘˜) +

ğ‘˜
âˆ‘ï¸

ğ‘–=0

(ğ‘/ğ‘) ğ‘˜âˆ’ğ‘– ğ‘ƒ(ğ‘‹ = ğ‘–)

(cid:19)

(cid:18)ğ‘– + ğ‘˜ âˆ’ 1
ğ‘–

ğ‘ğ‘– ğ‘ğ‘˜ +

ğ‘˜
âˆ‘ï¸

ğ‘–=0

(ğ‘/ğ‘) ğ‘˜âˆ’ğ‘–

(cid:19)

(cid:18)ğ‘– + ğ‘˜ âˆ’ 1
ğ‘–

ğ‘ğ‘– ğ‘ğ‘˜

1 âˆ’

ğ‘˜
âˆ‘ï¸

ğ‘–=0

(cid:19)

(cid:18)ğ‘– + ğ‘˜ âˆ’ 1
ğ‘–

ğ‘˜
âˆ‘ï¸

(cid:19)

+

ğ‘ğ‘– ğ‘ğ‘˜

(cid:19)

(cid:18)ğ‘– + ğ‘˜ âˆ’ 1
ğ‘–

ğ‘ğ‘˜ ğ‘ğ‘–

=

âˆ‘ï¸

ğ‘–>ğ‘˜

(cid:18)

=

ğ‘–=0
(cid:18)ğ‘– + ğ‘˜ âˆ’ 1
ğ‘–

= 1 âˆ’

ğ‘˜
âˆ‘ï¸

ğ‘–=0

(cid:19)

(ğ‘ğ‘– ğ‘ğ‘˜ âˆ’ ğ‘ğ‘˜ ğ‘ğ‘–).

(5)

(6)

(7)

(8)

This probability converges exponentially to zero as ğ‘˜ increases. Grunspan and Perez-
Marco [19] provides a closed form for this probability

ğ‘ƒ(ğ‘˜) = ğ¼4 ğ‘ğ‘ (ğ‘˜, 1
2

)

where ğ¼ (.) is the regularized incomplete beta function:

ğ¼ğ‘¥ (ğ‘, ğ‘) =

Î“(ğ‘ + ğ‘)
Î“(ğ‘)Î“(ğ‘)

âˆ« ğ‘¥

0

ğ‘¡ ğ‘âˆ’1 (1 âˆ’ ğ‘¡)ğ‘âˆ’1ğ‘‘ğ‘¡.

For Bitcoin, it is recommended that we wait for ğ‘˜ = 6 block conï¬rmations before
assuming that the transaction is ï¬nal, which is enough for ğ‘ƒ(ğ‘˜) to be extremely
small. For example, ğ‘ƒ(6) = 0.0005914 for ğ‘ = 0.1. A block becomes â€œï¬nalâ€, hence
the blockchain up to this block is considered â€œï¬nalityâ€, if it is followed by this many
block conï¬rmations. Thus, Bitcoin ï¬nality is not instant. Instead, it is guaranteed
asymptotically.

30

Duc A. Tran and Bhaskar Krishnamachari

4 Smart Contract Blockchains

Bitcoin is an example of an application-speciï¬c blockchain network where the only
application logic is to serve digital payments. Although it allows for some limited
programmability, it does not provide arbitrary programmability. As many appli-
cations in the real world, not necessarily ï¬nancial, can beneï¬t from blockchain
technology, having a dedicated blockchain network for each individual application
is not realistic.

This is the motivation for Ethereum, the ï¬rst blockchain network created by
Vitalik Buterin et al. in 2012 [6] to be a universal blockchain computer that can run
applications of arbitrary purposes. To develop such applications, developers write
computer programs called â€œsmart contracts". Ethereum, therefore, is said to be a
smart contract blockchain. Other public smart contract blockchain networks include
Algorand [10], Tezos [18], and Solana [48].

4.1 Smart Contract

Smart contracts are written using a high-level programming language (e.g., Solidity,
Viper, Flint, Bamboo). Solidity is the most popular language for smart contract
networks. It is Turing-complete, meaning that it can simulate any computation. In
contrast, Script, the programming language of Bitcoin, is not Turing-complete. Script
is thus very light and suitable for Bitcoin. Bitcoin does not need a universal language
because digital currency is the only purpose of Bitcoin.

Compared to Bitcoin, a smart contract blockchain has an additional layer of
functioning because of the smart contract capability. When a smart contract is
deployed, it is submitted as a transaction to the blockchain network to run on every
node. Each node needs a runtime environment to execute the bytecode of the smart
contract. On Ethereum, this is called the Ethereum Virtual Machine (EVM), a
powerful sandboxed virtual stack embedded with each full Ethereum node. EVM is
where all Ethereum accounts and smart contracts live. It maintains the consensus
for the blockchain. While the smart contract language used in Ethereum is Solidity
which is Turing-complete, EVM is a quasi-Turing complete machine. Quasi, because
EVM can theoretically run every smart contract but its execution will stop and be
reverted if exceeding the resource allocation limit speciï¬ed by the deployer.

As an analogy, let us compare running a computer program on a single computer
versus the Ethereum blockchain computer. In the former case, all the state of the
program is stored on the computer which is the only point of contact for the user
and if this computer fails, all the state will be lost. In the blockchain case, the
computer program is deployed and runs simultaneously on all computer nodes of
the blockchain; these nodes independently and autonomously keep track of the
programâ€™s state. A user can interact with the program using any node. If a node fails,
the program is still running on the other nodes. The consensus mechanism of the
blockchain ensures that the states on all the nodes are identical.

Blockchain in a nutshell

31

Fig. 11 The IERC20 interface for ERC-20 tokens. ERC-20 tokens must implement these functions.

The source codes of deployed smart contracts are visible to the public. Therefore,
there is nothing to hide in the working of a smart contract and people can be assured
that it will work as programmed. That said, in certain cases, a complex smart contract
may contain bugs and other security holes that are not easily seen; to ï¬x them is
a headache after the application is already deployed with many users; note that the
blockchain is immutable. Therefore, a professional project should have its smart
contracts certiï¬ed by reputable smart contract auditors.

4.2 Token Creation

Bitcoin (BTC) is the only native token (digital currency) of the Bitcoin blockchain
network. Its users transact with each other (paying one another) using BTC. A smart
contract network also has a native token (e.g., ETH for Ethereum), whose main use
is for the users to deploy smart contracts and interact with them. To deploy a smart
contract on Ethereum, one must pay a certain amount in ETH. This amount depends
on the computational complexity of the contract. Besides ETH, many secondary
tokens can be created to serve diï¬€erent applications. For example, one can build a
loyalty application on top of Ethereum and implement the loyalty point as a token,
or a countryâ€™s government can issue a central bank digital currency (CBDC) as a
token on top of Ethereum.

A token is implemented in the form of a simple smart contract. If the token is meant
to be a kind of digital currency, this contract stores the token balance information
for each account (blockchain address) and includes essential functions to enable a
sender to transfer tokens to a receiver (needed for a real-world payment transaction),
a spender to transfer tokens on behalf of their owner to a receiver (useful for a
trading exchange or a bank to transfer money from someoneâ€™s account to a payee,
of course with permission only), or in many cases, mint new and burn existing
tokens (useful for a government to cope with inï¬‚ation crises). Figure 11 shows the
interface for token smart contracts in Ethereum with six required functions. Events
can be emitted from a smart contract so that front-end applications can watch and
be instantly notiï¬ed of their happening.

For ease of token creation, several token standards have been deï¬ned and template
smart contracts created. The ï¬rst standards were deï¬ned for the Ethereum network
and their counterparts later followed for other smart contract networks. For Ethereum,

32

Duc A. Tran and Bhaskar Krishnamachari

Fig. 12 A basic smart contract of an ERC-20 token implementing IERC20 interface.

ERC-20 is the standard for fungible tokens, ERC-721 for non-fungible tokens (NFT),
and ERC-1155 for generic multi-tokens (one that can represent a fungible token or
a non-fungible token or a multiple of them). For example, ERC-20 is used for
implementing a cryptocurrency, ERC-721 for digitally representing a physical asset
uniquely and non-duplicatable as an NFT, and ERC-1155 for digitally representing
equity shares of a company. A basic Solidity smart contract implementation of
ERC-20 is shown in Figure 12.

4.3 Transaction Processing

Since a transaction may involve interacting with a smart contract by calling a func-
tion in the smart contract, the processing is not simply a veriï¬cation such as check-
ing fund availability. Let us explain this for the case of Ethereum. The Ethereum
blockchain adopts the account-based state model; its state consists of a set of ac-
counts (blockchain addresses) and their corresponding information. There are two
types of accounts:
â€¢ Externally-owned account: one that is owned by a normal user (like a bitcoin

account). The state for an external account is its ETH balance.

Blockchain in a nutshell

33

â€¢ Contract account: one that represents a deployed smart contract. The state for a
contract account consists of its ETH balance, contract code, and a storage area to
save the run-time state of the contract.

The Ethereum blockchain protocol is essentially the same as that in the blockchain
framework we presented in Subsection 2.6, the main diï¬€erence being in transaction
processing and block validation steps.

A transaction is a transfer of asset/value and optional data from a sender to a
receiver. Speciï¬cally, it has a sender who initiates the transaction, a receiver who
receives the transaction, a value (amount of tokens) to be transferred from the sender
to the receiver, and a data part if the receiver is a contract account. If the transaction
is received by a contract account, the corresponding contract code will be executed,
taking as input the data included in the transaction. Ethereum introduces a concept
called â€œgas feeâ€ to represent how much ETH the transaction will pay the miner. A
transaction contains two values, ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ‘”ğ‘ğ‘  and ğ‘”ğ‘ğ‘ ğ‘ğ‘Ÿğ‘–ğ‘ğ‘’.
â€¢ The ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ‘”ğ‘ğ‘  value represents the maximum number of computational steps the
transaction execution is allowed to take. The sender should have an idea as to how
complex the transaction is and determines this value properly. If the miner takes
more steps than this threshold allows, the transaction will halt and be reverted.
â€¢ The ğ‘”ğ‘ğ‘ ğ‘ğ‘Ÿğ‘–ğ‘ğ‘’ value is the ETH fee the sender will pay the miner per computational
step. To expedite the processing, the sender should increase ğ‘”ğ‘ğ‘ ğ‘ğ‘Ÿğ‘–ğ‘ğ‘’ so that the
miner would include the transaction in the next block.

Upon a transaction, the state transition happens as follows:

1. Check if the transaction is well-formed and valid. Else, terminate.
2. Set transaction fee to ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ‘”ğ‘ğ‘  Ã— ğ‘”ğ‘ğ‘ ğ‘ğ‘Ÿğ‘–ğ‘ğ‘’. Subtract this fee from the senderâ€™s

balance. If the balance is not suï¬ƒcient, terminate.

3. Initialize ğº ğ´ğ‘† = ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ğ‘”ğ‘ğ‘ , minus a certain quantity of gas per byte to pay for the

byte count in the transaction.

4. Transfer the value speciï¬ed in the transaction from the senderâ€™s balance to the

receiverâ€™s balance.

â€¢
â€¢

If the receiver does not exist, create it.
If the receiver exists and is a contract account, run the contract code either to
completion or until the execution runs out of ğº ğ´ğ‘†.

5. If this transfer fails: revert all state changes except the payment of the fees, and

add the fees to the minerâ€™s account.

6. Else, refund the remaining ğº ğ´ğ‘† to the sender, and send the fees paid for gas

consumed to the miner.

4.4 Block Validation

In Ethereum, a block contains a list of transactions and the blockchain state obtained
by applying these transactions to the previous state (stored in the previous block). The

34

Duc A. Tran and Bhaskar Krishnamachari

Fig. 13 The Train smart contract: this contract will be called later by the Booking smart contract.

creation of a new block requires PoW mining similar to Bitcoin (although, Ethereum
is transitioning to Proof-of-Stake consensus in version 2.0). The validation of a
block requires checking the cryptographic link with the previous block as usual,
but in addition, it has to replay the running of all the transactions in the block.
Speciï¬cally, a miner validates a new block as follows:

1. Verify that the previous block referenced exists and is valid.
2. Verify that the timestamp of the new block is greater than that of the previous

block and less than 15 minutes into the future.

3. Verify that the new blockâ€™s ID, diï¬ƒculty target, transaction Merkle root are valid.
4. Starting from the previous blockchain state (stored in the previous block):

â€¢ Run a sequence of state transitions as a result of applying all the transactions

â€¢

in the new block, one by one.
If any such transaction replay fails or if the total gas consumed exceeds the
limit, terminate.

5. If the Merkle tree root of the ï¬nal state in the above step equals that stored in the

new block, then the new block is valid. Else, invalid.

4.5 Contract Interoperability

In a smart contract blockchain network, one can call another contract inside a con-
tract. For example, consider a Travel Booking application: allow people to purchase
a train ticket and reserve a hotel such that each booking is atomic - either both reser-
vations succeed or neither do. This is referred to as the â€œtrain-and-hotelâ€ problem
popular as a case study in Ethereum research community2.

We have three smart contracts:

â€¢ Train smart contract (Figure 13): keep status of all train bookings. A user can

book a train ticket by calling the booking() function of this contract.

2 This problem is described on this page: https://eth.wiki/sharding/Sharding-FAQs.

Blockchain in a nutshell

35

Fig. 14 The Hotel smart contract: this contract will be called later by the Booking smart contract.

Fig. 15 The Booking smart contract: this contract calls the Train contract and Hotel contract.

â€¢ Hotel smart contract (Figure 14): keep status of all hotel bookings. A user can

book a hotel room by calling the booking() function of this contract.

â€¢ Booking smart contract (Figure 15): A user can book a trip (a hotel and a train)

by calling the order() function of this contract.

The Booking smart contract calls the other two contracts. Intuitively, it is just
like calling another computer program inside a computer program. However, the
advantage of running this application on the blockchain is that in the case one of the
two bookings fails even though the other was order() function call will fail and,
as a result, reverting the successful booking. The user will not lose any money. In
the traditional deployment of this application on a non-blockchain environment, it
would be more complex to the revert the userâ€™s successful booking.

The use of a Turing-complete language like Solidity for smart contract networks
and the capability for contracts to call one another open limitless creativity when
it comes to application. For any computer application in the real world, in theory,
we can develop an equivalent version to run on the blockchain. This is why, with
the birth of Ethereum and recent smart contract network alternatives, we have been
witnessing many businesses enter the blockchain space, most notably in the ï¬nance
ï¬eld with Decentralized Finance (DeFi).

36

Duc A. Tran and Bhaskar Krishnamachari

5 Blockchain Scalability

Every transaction is broadcast to the whole network. So is every block. Block
validation takes time and eï¬€orts too. Due to the chain topology of the blockchain,
the fact that only one block can be the next node of the chain leads to many completing
blocks being wasted, eï¬€ectively reducing transaction throughput. On the other hand,
we want blockchain to be the universal computer for every one, for every application,
if at all possible. Unfortunately, scalability remains a top challenge of blockchain
technology [20].

5.1 The Blockchain Trilemma

Blockchain is aimed at three goals: decentralized, secure, and scalable. They cannot
be all perfectly realized, at least according to Ethereumâ€™s founder, Vitalik Buterin,
who originated the term â€œScalability Trilemmaâ€ for blockchain [8]:
â€¢ Decentralized: Set to provide trustless computing, Blockchain does not rely on a
central point of control. It needs to be decentralized such that nodes participate
autonomously and equally to each other.

â€¢ Secure: The blockchain must operate as expected, robust to malfunctions and
attacks. As we discussed in the previous section, Blockchain is a Byzantine Fault
Tolerant system. The more failures of a large threshold of nodes it can sustain,
the better security it provides.

â€¢ Scalable: Meant to be a â€œworldâ€ computer for all people to run all applications,
Blockchain should scale with increasingly growing amounts of transactions. This
is in terms of both storage and computation demands.

The decentralization goal requires as many nodes as possible to participate in the
block validation. Having more validator nodes, however, leads to more diï¬ƒculty in
maintaining consensus, thus security. Both decentralization and security goals are
achievable only with small-scale blockchain networks (network size or transaction
volume). As such, the scalability goal is not met.

Blockchains are often forced to make trade-oï¬€s in this trilemma. Bitcoin oï¬€ers
excellent decentralization and security, but unattractive scalability. Due to the 10-
minute block creation rule to guarantee security, the transaction processing is slow,
on the order of 2-5 transactions per second (tps). This is not practical for real-world
payment at merchants. Traditional credit card systems such as Visa and Mastercard
are 3 to 4 orders of magnitude faster.

On the other hand, Solana, a smart contract network created in 2017 by Anatoly
Yakovenko et al. [48], sacriï¬ces decentralization for scalability. It is very fast. Solana
does not use PoW consensus which is of course slow. It is based on a unique
Proof-of-History (PoH) consensus algorithm, a variation of Proof-of-Stake (PoS).
In theory, Solanaâ€™s claimed throughput can be as high as 710,000 tps; the practically
observed number is about 50,000 tps, still much faster than Bitcoin. However, as

Blockchain in a nutshell

37

pointed out by many, Solana is vulnerable to centralization. In Solana, like other
PoS networks, the decision to add a block to the blockchain is made among a small
subset of â€œvalidatorâ€ nodes. Since fewer nodes involve in the consensus decision, it
is faster than Bitcoin where all nodes can be miners. The problem with Solana is
that the Solana Foundation is the only entity developing core nodes (validators) on
the blockchain. This means Solana has a central point of control that reduces the
networkâ€™s overall decentralization. In comparison, several core node developers are
building on Ethereum (e.g. Go Ethereum, OpenEthereum, Nevermind, and Besu).
As of April 1, 2022, the number of Solana validator nodes is estimated to be around
1,100 nodes; in comparison, the PoS Ethereum network already has more than
200,000 nodes.

Comparing Ethereum (the PoS version) and Bitcoin, both oï¬€er excellent decen-
tralization. Ethereum is faster, but the tradeoï¬€ is in security where Bitcoin is the
superior, mainly due to PoW which has a higher entry barrier for block generation
and higher cost to attack. An attacker would need to acquire 51%+ of the compu-
tational power in the network, whereas a PoS attacker would need to acquire 51%+
of the money within that system. To get the computational power in PoW, not only
the attacker needs money but also physical eï¬€orts to acquire hardware. This external
and physical factor makes PoW less vulnerable to attacks.

5.2 Layer-2 Scalability

Changing the core design, whether the consensus mechanism, block structure (chain
or DAG), or cryptographic methods, at layer-1 of a blockchain network has tradeoï¬€s
due to the scalability trilemma. In 2016, at the peak then of high Ethereum gas fee,
Joseph Poon and Vitalik Buterin introduced the approach of layer-2 scalability that
applies to Ethereum, and, in theory, any layer-1 blockchain. The proposed solution,
called Plasma [37], builds a high-throughput blockchain network anchored atop
the layer-1 blockchain as follows: 1) layer-2 transaction processing: users transact
on the layer-2 blockchain, hence very fast; and 2) layer-1 transaction ï¬nality: state
information records of completed transactions are saved in the layer-1 blockchain,
hence assuring security against dishonest transactions.

For example, Polygon3 is a layer-2 smart contract blockchain on top of Ethereum
network as layer 1. Polygon started with the Plasma approach in the early stage and
now is one of the most successful blockchain networks. It is noted that the idea of
layer-2 scalability was actually applied in the Lightning Network [38], created by
Joseph Poon and Thaddeus Dryja in 2015. The scaling method used is called State
Channels. This, however, is suitable only to a payment network like Bitcoin (as a fast
payment protocol on layer 2), but not to a general smart contract network. Another
scaling method often referenced is Sidechain [2], which is a much simpler and less
secure version of Plasma.

3 https://polygon.technology

38

Duc A. Tran and Bhaskar Krishnamachari

The invention of Plasma opened a new direction in blockchain scalability, leading
to more advanced solutions such as Optimistic Rollups4 and ZK Rollups5, which are
trending today [41]. To explain the layer-2 scalabilityâ€™s concept and feasibility, let us
describe how Plasma works below. We hope that this will be helpful to the reader in
understanding recently emerging scalability methods.

5.2.1 Plasma Scaling

There are several variants of Plasma. For example, Plasma Cash [26] is a Plasma
solution for non-fungible tokens (NFT). We present a basic version of Plasma - the
original proposal [37], which is for fungible assets below.

The Plasma Chain: First, we need to build a separate blockchain network to serve
as the layer-2. We refer to this as Plasma Chain and to the layer-1 chain as Root Chain.
Any blockchain design can work for Plasma Chain as long as it is fast and scalable;
for example, Proof-of-Stake or Proof-of-Authority is a better choice than Proof-of-
Work for the consensus mechanism. In the initial Plasma proposal, Plasma Chain
adopts the UTXO state model (Bitcoin-like). Although this model is not suitable for
enabling smart contracts at layer 2, for simplicity we assume this model to explain
the core idea of layer-2 scalability.

Plasma Chain processes transactions and creates blocks as usual functionalities of
the chain. However, there is an additional step for the validator nodes (those that can
produce blocks on Plasma Chain) after they have added each block to Plasma Chain:
need to save a record of it on Root Chain. This is called an on-chain â€œblock commitâ€
or â€œcheckpointâ€. By â€œon-chain" we mean layer-1 activity, whereas â€œoï¬€-chain" we
mean layer-2. Adding a block to Plasma Chain provides its ï¬nality on Plasma Chain.
Committing this block to Root Chain provides its ï¬nality on Root Chain, which is the
â€œï¬nalizedâ€ ï¬nality. The latest checkpoint is the proof that all transactions (and the
funds) are permanent up to this point. Blocks are committed on-chain by interacting
with a smart contract on Root Chain. There is also an entity, called Plasma Operator,
which is watching events from this smart contract and will respond accordingly on
Plasma Chain.

The Root Contract: We need to create a smart contract on Root Chain; let us name

it Root Contract. It provides the following functionalities:
â€¢ Block Submission: Root Contract maintains a list of Plasma block headers,
each essentially consisting of the Merkle root of the corresponding original block
and the time it is added to the list; transactions are not included. The contract has
a public function for inserting such a block into this list. This function is called
by Plasma Chainâ€™s validator nodes after they have validated a block; alternatively,
this can be called by Plasma Operator who watches block insertions on Plasma
Chain. It is noted that because Root Contract simply saves the headers of the

4 https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/optimistic_rollups/
5 https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/zk-rollups/

Blockchain in a nutshell

39

Plasma blocks, not the actual transactions, it cannot know by itself their validity
(honest or malicious purpose).

â€¢ Fund Deposit: Bob needs some fund in his account before doing any transfer on
Plasma Chain. The contract has a public function for anyone like him to deposit
this fund. Once this fund is deposited on Root Chain, an event will be emitted
to notify Plasma Operator who will mint a new UTXO with the corresponding
amount of fund on Plasma Chain for Bob. The amount of fund in circulation on
Plasma Chain is the total amount of all deposits (minus withdrawn funds if any).
â€¢ Fund Withdrawal: Alice can withdraw fund from Root Chain. The contract has
a public function to allow so, which asks her to provide the proof for the fund used
to withdraw. A withdrawal must correspond to some unspent UTXO on Plasma
Chain. The fund proof includes the position of an unspent UTXO belonging to
Alice on Plasma Chain and the Merkle proof for this UTXO in its corresponding
Plasma block. Because the contract cannot tell instantly whether this UTXO is
indeed unspent on Plasma Chain, the withdrawal is not immediate. It has to wait
a dispute period, e.g., 7 days, during which anyone can challenge. If the challenge
is valid, the contract will revert the withdrawal.

â€¢ Fraud Proofs: The contract has a public function to allow anyone to challenge
the validity of a malicious block committed from Plasma Chain or a withdrawal
request within its dispute period. In the case of challenging Aliceâ€™s withdrawal
request above, if Bob observes that the UTXO used in the withdrawal is also
spent on the Plasma Chain, he will provide the position of this invalid UTXO
on Plasma Chain and the Merkle proof of its existence there as input to the
withdrawal-challenge function. The contract will see if this proof matches the
corresponding block record in the Plasma block list of the contract. If matching,
Aliceâ€™s withdrawal will be reverted.

Example: Consider a Plasma Chain on top of Ethereum for people to make ETH

payments.

1. Alice deposits 10 ETH to Root Contract on Root Chain. As a result, Plasma
Operator will mint 10 ETH for her on Plasma Chain (this ETH on Plasma Chain
is actually a wrapped version of the Ethereum ETH). At this time, the Plasma
blockchain consists of only 1 UTXO:

ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 1 : âˆ… â†’ ğ´ğ‘™ğ‘–ğ‘ğ‘’ : 10

2. On Plasma Chain, Alice transfers 5 ETH to Bob. The new blockchain state is:

ğ‘ ğ‘ğ‘’ğ‘›ğ‘¡ : ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 1 : âˆ… â†’ ğ´ğ‘™ğ‘–ğ‘ğ‘’ : 10
ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 2 : ğ´ğ‘™ğ‘–ğ‘ğ‘’ â†’ ğ´ğ‘™ğ‘–ğ‘ğ‘’ : 5
ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 3 : ğ´ğ‘™ğ‘–ğ‘ğ‘’ â†’ ğµğ‘œğ‘ : 5

3. Bob then transfers 3 ETH to Charlie. The new blockchain state is:

40

Duc A. Tran and Bhaskar Krishnamachari

ğ‘ ğ‘ğ‘’ğ‘›ğ‘¡ : ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 1 : âˆ… â†’ ğ´ğ‘™ğ‘–ğ‘ğ‘’ : 10
ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 2 : ğ´ğ‘™ğ‘–ğ‘ğ‘’ â†’ ğ´ğ‘™ğ‘–ğ‘ğ‘’ : 5
ğ‘ ğ‘ğ‘’ğ‘›ğ‘¡ : ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 3 : ğ´ğ‘™ğ‘–ğ‘ğ‘’ â†’ ğµğ‘œğ‘ : 5
ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 4 : ğµğ‘œğ‘ â†’ ğµğ‘œğ‘ : 2
ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 5 : ğµğ‘œğ‘ â†’ ğ¶â„ğ‘ğ‘Ÿğ‘™ğ‘–ğ‘’ : 3

4. Charlie transfers 2 ETH to Alice. The new blockchain state is:

ğ‘ ğ‘ğ‘’ğ‘›ğ‘¡ : ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 1 : âˆ… â†’ ğ´ğ‘™ğ‘–ğ‘ğ‘’ : 10
ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 2 : ğ´ğ‘™ğ‘–ğ‘ğ‘’ â†’ ğ´ğ‘™ğ‘–ğ‘ğ‘’ : 5
ğ‘ ğ‘ğ‘’ğ‘›ğ‘¡ : ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 3 : ğ´ğ‘™ğ‘–ğ‘ğ‘’ â†’ ğµğ‘œğ‘ : 5
ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 4 : ğµğ‘œğ‘ â†’ ğµğ‘œğ‘ : 2
ğ‘ ğ‘ğ‘’ğ‘›ğ‘¡ : ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 5 : ğµğ‘œğ‘ â†’ ğ¶â„ğ‘ğ‘Ÿğ‘™ğ‘–ğ‘’ : 3
ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 6 : ğ¶â„ğ‘ğ‘Ÿğ‘™ğ‘–ğ‘’ â†’ ğ¶â„ğ‘ğ‘Ÿğ‘™ğ‘–ğ‘’ : 1
ğ‘ˆğ‘‡ ğ‘‹ğ‘‚ 7 : ğ¶â„ğ‘ğ‘Ÿğ‘™ğ‘–ğ‘’ â†’ ğ´ğ‘™ğ‘–ğ‘ğ‘’ : 2

5. At this time, on Plasma Chain, Alice has 7 ETH (from UTXO 2 and UTXO 7),
Bob has 2 ETH (from UTXO 4), and Charlie has 1 ETH (from UTXO 6). Note
that the above transactions were included in Plasma blocks of Plasma Chain and
their headers have been saved in Root Contract.

6. Bob requests to withdraw 2 ETH (calling the withdrawal function of Root Contract
on Root Chain). He inputs to this function UTXO 4 as the source for the fund. The
withdrawal request is pending for 7 days. During these 7 days, no one challenges
this request because UTXO 4 is not spent on Plasma Chain during the dispute
period. Therefore, Root Contract sends 2 ETH (of Root Chain) to Bob. It is noted
that Bob did not have to deposit fund on Ethereum in order to withdraw.

7. Alice requests to withdraw 5 ETH using UTXO 3. During the 7-day dispute
period, Charlie who watches Plasma Chain observes that UTXO 3 was spent on
Plasma Chain. He will challenge the withdrawal by submitting the Merkle proof
of this UTXO 3 to Root Contract. This proof is valid, thus canceling Aliceâ€™s
withdrawal.

It is important that those users who have fund on Plasma Chain should watch the
chain frequently to make sure their funds are safe. This requires downloading the
chain and verify its correctness. If a user detects or suspects something wrong, the
userâ€™s wallet (software) will automatically request to withdraw funds.

To avoid spammers and those submitting irresponsible withdrawals while en-
couraging fraud reporting, one can design Root Contract such that each withdrawal
request must include a penalty bond that will be collected to reward the challenger
in the case of bad withdrawal. To enable fast withdrawals (7 days is too long), a
Plasma solution can involve Liquidity Providers who are incentivized to advance the
fund to the withdrawers while taking the risk of bad withdrawals. A solution, e.g,.
Polygon, can also require that Alice burn the fund on Plasma Chain before requesting
to withdraw it on Root Chain; she needs to submit the proof of this burn.

Blockchain in a nutshell

41

The on-chain block commit in Plasma is the key diï¬€erence between it and the
Sidechain scaling approach [2]; the latter is often mistakenly considered the same as
Plasma but it is very diï¬€erent. Sidechain also has a smart contract like Root Contract
with functions for deposits and withdrawals, but does not have block commits. It is
simpler but a major cons is that the sidechain can stop producing blocks and lock
everyoneâ€™s funds up forever. Sidechain is thus much less secure. With Plasma, the
block list in the Root Contract is the proof that users have their funds and thus can
withdraw them.

5.2.2 Rollups Scaling

The Plasma approach is more suitable for token transfer transactions, but not for
smart contracts. The Rollups approach [7] was born to be general-purpose. The
layer-2 blockchain in Rollups can run smart contracts. For example, one can run an
EVM inside the layer-2 chain, allowing existing Ethereum applications to migrate to
Rollups without re-writing the smart contract code.

Rollups can be considered a hybrid Plasma approach. Plasma keeps all the trans-
action data oï¬€-chain and, as such, Root Chain cannot verify Plasma transactions,
leaving room for Plasma Chain to do things maliciously. In Rollups, part of trans-
action data is saved on the Root Chain in addition to block headers. As a result,
Root Chain can verify transactions too, thus providing an additional layer to enhance
security and decentralization. It is noted that Rollups does not save all transactions
on Root Chain because doing so makes the Rollups chain meaningless; it does not
do any scaling. If Rollups saved none of transaction data, it would become Plasma.
To reduce the amount of transaction data saved on Root Chain, it saves only the in-
formation necessary to verify transactions. Transaction data involving state storage
remains on the Rollups chain.

There are two main Rollups approaches: Optimistic Rollups and Zero-Knowledge
(ZK) Rollups. The former resembles Plasma in that it also uses fraud proofs to
challenge invalid fund withdrawals and invalid layer-2 transactions. ZK Rollups is
more disruptive in that it allows instant withdrawals.
â€¢ Optimistic Rollups: The name â€œoptimisticâ€ comes from the assumption in this
approach that the transaction data submitted to Root Chain is correct. After
the Rollups chain commits a batch of transactions to Root Chain, they will be
considered permanently ï¬nalized if no one submits a fraud proof to challenge
any transaction. Whenever a fraud proof is submitted, the suspicious transaction
will be re-validated: it will be replayed on Root Chain using the block state
and transaction data information already saved in Root Contract. The replay of
such transaction is similar to that in the transaction veriï¬cation procedure of
Ethereum. Noticeable implementations of Optimistic Rollups include Optimism6
and Arbitrum7.

6 https://www.optimism.io
7 https://oï¬€chainlabs.com/

42

Duc A. Tran and Bhaskar Krishnamachari

â€¢ ZK Rollups: ZK Rollups leverages a cryptographic method called zk-SNARK
(Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) [11]. A zk-
SNARK is a cryptographic proof that allows one party to prove that it possesses
certain information without revealing that information. The veriï¬cation of the
proof is quick and cheap. When a batch of transactions are to be committed on
Root Chain, a zk-SNARK proof is computed for this data to prove its validity and
sent along to Root Chain. Root Contract veriï¬es this proof on Root Chain when
receiving a withdrawal request; if valid, the fund is released immediately. No-
ticeable implementations of ZK Rollups include dYdX8, Loopring [44], zkSync
[15], and ZKSpace9.

To understand ZK Proofs, suppose that Alice wants to prove to Bob her knowing
of a value ğ‘¥ such that ğ‘“ (ğ‘¥) = ğ‘œğ‘¢ğ‘¡ ğ‘ğ‘¢ğ‘¡ for a given ğ‘œğ‘¢ğ‘¡ ğ‘ğ‘¢ğ‘¡. Can she do that without
disclosing value ğ‘¥? For example, can Alice provide a proof that she knows a secret
value having a given SHA256 hash without revealing this secret? This is called
a zero-knowledge proof. A related example is the well-known Yaoâ€™s Millionairesâ€™
Problem [31]: can two millionaires, Alice and Bob, know who is richer without
revealing their actual wealth? Mathematically put, with two numbers ğ‘ and ğ‘, can
we determine whether ğ‘ â‰¤ ğ‘ without revealing the actual values of ğ‘ and ğ‘?

zk-SNARK is a method for computing ZK proofs. First, assume that we can write
a computer program to implement a boolean function ğ¶ (ğ‘œğ‘¢ğ‘¡ ğ‘ğ‘¢ğ‘¡, ğ‘¥) that returns true
if and only if ğ‘“ (ğ‘¥) = ğ‘œğ‘¢ğ‘¡ ğ‘ğ‘¢ğ‘¡. For example, if ğ‘“ is SHA256:

boolean function C(output, x) {

return (SHA256(x) == output);

}

A zk-SNARK is a set of three functions, ğºğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘œğ‘Ÿ (), ğ‘ƒğ‘Ÿğ‘œğ‘£ğ‘’ğ‘Ÿ (), and ğ‘‰ ğ‘’ğ‘Ÿğ‘– ğ‘“ ğ‘–ğ‘’ğ‘Ÿ (),

deï¬ned as follows.

ğºğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘œğ‘Ÿ (ğœ†, ğ¶) â†’ ( ğ‘ğ‘˜, ğ‘£ğ‘˜)
ğ‘ƒğ‘Ÿğ‘œğ‘£ğ‘’ğ‘Ÿ ( ğ‘ğ‘˜, ğ‘œğ‘¢ğ‘¡ ğ‘ğ‘¢ğ‘¡, ğ‘¥) â†’ ğ‘ğ‘Ÿ ğ‘“
ğ‘‰ ğ‘’ğ‘Ÿğ‘– ğ‘“ ğ‘–ğ‘’ğ‘Ÿ (ğ‘£ğ‘˜, ğ‘œğ‘¢ğ‘¡ ğ‘ğ‘¢ğ‘¡, ğ‘ğ‘Ÿ ğ‘“ ) â†’ {ğ‘¡ğ‘Ÿğ‘¢ğ‘’, ğ‘“ ğ‘ğ‘™ğ‘ ğ‘’}

(9)

(10)

(11)

â€¢ ğºğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘œğ‘Ÿ (): this is called the key generator. It takes as input a secret parameter
ğœ† and program ğ¶ and outputs a pair of keys called a â€œproving keyâ€ ğ‘ğ‘˜, and a
â€œveriï¬cation keyâ€ ğ‘£ğ‘˜. These keys are publicly known. It is noted that the secret
parameter ğœ† must be known to no one except the generator.

â€¢ ğ‘ƒğ‘Ÿğ‘œğ‘£ğ‘’ğ‘Ÿ (): this is called the prover: Alice calls this function taking as input the
proving key ğ‘ğ‘˜, the public value ğ‘œğ‘¢ğ‘¡ ğ‘ğ‘¢ğ‘¡, and her secret value ğ‘¥ that she wants to
prove that ğ‘“ (ğ‘¥) = ğ‘œğ‘¢ğ‘¡ ğ‘ğ‘¢ğ‘¡. This function will output a value called â€œproof" ğ‘ğ‘Ÿ ğ‘“ .
Alice will send this proof to Bob.

â€¢ ğ‘‰ ğ‘’ğ‘Ÿğ‘– ğ‘“ ğ‘–ğ‘’ğ‘Ÿ (): this is called the veriï¬er: Bob uses this function to take as input the
veriï¬cation key ğ‘£ğ‘˜, the public value ğ‘œğ‘¢ğ‘¡ ğ‘ğ‘¢ğ‘¡, and the proof ğ‘ğ‘Ÿ ğ‘“ he received from

8 https://dydx.exchange
9 https://zks.org

Blockchain in a nutshell

43

Alice. This function returns true iï¬€ the proof is correct; i.e., the prover knows a
value ğ‘¥ satisfying ğ‘“ (ğ‘¥) = ğ‘œğ‘¢ğ‘¡ ğ‘ğ‘¢ğ‘¡.

As another example, suppose that Alice wants to transfer tokens of some ERC-
20 cryptocurrency to somebody. Using the standard ERC-20 smart contract, the
public sees the account balance of Alice, ğ‘ğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’, and the amount she sends,
ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’. In many cases, it is desirable to hide these numbers. For this purpose, we
can implement a smart contract that makes public only the following hashes of
these numbers, ğ‘ğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’ğ‘‚ğ‘™ğ‘‘ = ğ‘†ğ» ğ´256(ğ‘ğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’), ğ‘ ğ‘’ğ‘›ğ‘¡ğ‘‰ ğ‘ğ‘™ğ‘¢ğ‘’ = ğ‘†ğ» ğ´256(ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’),
and ğ‘ğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’ğ‘ğ‘’ğ‘¤ = ğ‘†ğ» ğ´256(ğ‘ğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’ âˆ’ ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’). Knowing these hashed values, the
miner (Bob) cannot know the raw values, ğ‘ğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’ and ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’, but can still verify
whether the transfer is valid. In this example, Alice is the prover and miner Bob is
the veriï¬er. The corresponding program code to deï¬ne the logic for this veriï¬cation,
which is input into zk-SNARK, is as follows:

boolean function C(output, x) {

return (x.balance >= x.value

&& SHA256(x.balance) == output.balanceOld
&& SHA256(x.value) == output.sentValue
&& SHA256(x.balance-x.value) == output.balanceNew);

}

Here, ğ‘œğ‘¢ğ‘¡ ğ‘ğ‘¢ğ‘¡ is the object consisting of the three hashed values that Bob observes
and ğ‘¥ is the secret information about the senderâ€™s balance and value sent. With this
program code ğ¶, the key generator will take it as input, together with a random
parameter ğœ†, to generate a proving key ğ‘ğ‘˜ and a veriï¬cation key ğ‘£ğ‘˜. Alice and Bob
use these two keys to prove and verify as above.

There is tradeoï¬€ between Optimistic versus ZK Rollups. Due to mathematical
complexity, generic constructions for ZK protocols are too expensive to be used in
practice. Thus far, it has been suitable for only a few speciï¬c applications such as
payments and token exchanges, like what is mainly served by Plasma. Optimistic
Rollups, on the other hand, thanks to its simplicity, supports layer-2 smart contracts
better. It, however, requires more storage in Root Contract (data needed to replay
transactions for veriï¬cation purposes). In contrast, with ZK proofs that can readily
verify transactions, ZK Rollups requires less storage for Root Contract.

6 Blockchain Interoperability

Existing blockchain networks are each on their own island isolated from one another.
Bitcoin users can only transact with other Bitcoin owners, but not with Ethereum
users. Decentralized applications on Ethereum cannot make calls to those on other
blockchain networks. Data on one blockchain cannot be shared outside either. This
is analogous to the early days of Internet, where diï¬€erent â€œinternetsâ€ (networks)
were developed independently to serve their own purposes or groups of users. They

44

Duc A. Tran and Bhaskar Krishnamachari

adopted diï¬€erent technologies and architectures that do not speak the same language.
However, the Internet today is universally interoperable in that even though it consists
of many Internet providersâ€™ networks, any two computers or applications regardless
of where they belong can communicate with each other.

Interoperability between the chains must be a top priority for blockchain. This
should be seamless so that one should focus on the logic of the application with-
out having to worry about which underlying blockchain technology stacks to use.
Imagine the complexities that would arise for a supply-chain company if it runs the
product tracking application on a blockchain and the payment application on another
blockchain, and these two blockchains are not compatible.

At the least, we should enable interoperability for digital assets. We should be able
to transfer or exchange assets between diï¬€erent networks without intermediaries such
as a centralized crypto exchange. This would allow a Bitcoin user to pay Bitcoin
to a merchant that runs its Point-of-Sale software built on Ethereum. This would
beneï¬t immensely decentralized ï¬nance (DeFi) applications that would be able to
tap into all populations of users who own various types of assets. The next level
of interoperability is for cross-chain exchanges of arbitrary data. This would enable
smart contracts and applications on diï¬€erent blockchains to communicate and share
information. This kind of interoperability is of course much more diï¬ƒcult to achieve.
Eï¬€orts to realize blockchain interoperability remain fragmented. Protocols, how-
ever, have taken shape into three main approaches: Atomic Swap, Chain Bridge, and
Chain Hub.

6.1 Atomic Swap

Atomic Swap [22] is a simple solution for two users to swap assets without involving
any third party. They can be on the same chain or diï¬€erent chains. Suppose that
Alice wants to transfer some asset X to Bob who in return transfers some asset Y to
her. In a naive scenario, Alice will just send X to Bob and expects him to send Y to
her. The problem is, in the real world, Bob could just take her asset and run away.

Atomic Swap guarantees that the exchange succeeds or else, nothing happens
without either side losing asset. It works as follows. Alice and Bob each need to
create a Hash-Time Locked Contract (HTLC) [38] to deposit their respective asset.
Speciï¬cally, Alice will do:
1. Generate a secret key ğ‘˜ ğ´ğ‘™ğ‘–ğ‘ğ‘’. Only she knows it at this time.
2. Compute a crypto-hash value of this key, ğ‘š = ğ» (ğ‘˜ ğ´ğ‘™ğ‘–ğ‘ğ‘’). The hash function ğ» is

known to Bob.

3. Create a Hash-Time Locked smart contract (HTLC) on her chain to deposit asset
X with a lock and an expiration time. This HTLC has a function to unlock X if it
is called before expiration and input with a key ğ‘˜ such that ğ» (ğ‘˜) = ğ‘š.
â€¢
â€¢

If asset X is unlocked, it will be transferred to the caller.
If X remains locked at expiration time, it will be returned to Alice.

Blockchain in a nutshell

4. Send the hash value ğ‘š to Bob.

On his side, Bob will do:

45

1. Create a Hash-Time Locked smart contract (HTLC) on his chain to deposit asset
Y with a lock and an expiration time. This HTLC has a function to unlock Y if it
is called before expiration and input with a key ğ‘˜ such that ğ» (ğ‘˜) = ğ‘š. This value
ğ‘š is the hash value sent from Alice.

2. Wait until the above unlock function is called and succeeds.

If asset Y remains locked at expiration time, it will be returned to Bob.

â€¢
â€¢ Else, the input key ğ‘˜ must equal the secret key of Alice, ğ‘˜ ğ´ğ‘™ğ‘–ğ‘ğ‘’. Therefore,
Bob knows this private key. He will call the HTLC of Alice inputting this key
ğ‘˜ = ğ‘˜ ğ´ğ‘™ğ‘–ğ‘ğ‘’ to unlock asset ğ‘‹ and have it transferred to him.

Atomic Swap will not do anything if Alice does not claim asset Y on Bobâ€™s
contract, because if so Bob has no knowledge of her secret key to claim asset X
on Aliceâ€™s contract. If Alice does claim, Bob will know this key and claim his part
too. No third party is involved here. On the other hand, Atomic Swap is not instant.
It depends on the actions of Alice and Bob. Alice must send the hash value ğ‘š to
Bob for him to set up his smart contract. She must then by herself contact his smart
contract and vice versa.

6.2 Chain Bridge

While Atomic Swap is for swapping assets, Chain Bridge enables transfers of assets
cross chains. To illustrate its idea and feasibility, suppose that we want to bridge
a smart contract blockchain X (token USDX) with a smart contract blockchain Y
(token USDY). A basic Chain Bridge solution needs to write two smart contracts,
one on X and one on Y. The bridge is owned by an entity called Bridge Operator, who
watches events emitted from these contracts. Bridge Operator also has a liquidity
pool ğ¿ğ‘ƒğ‘‹ of ğ‘›ğ‘‹ USDX on X and a liquidity pool ğ¿ğ‘ƒğ‘Œ of ğ‘›ğ‘Œ UDXY on Y.

Suppose that Alice on chain X wants to transfer 10 USDX to Bob on chain Y.
For simplicity, 1 USDX = 1 USDY and so he will receive 10 UDXY. The transfer
happens as follows:
â€¢ On Chain X: Alice calls the contract on X to deposit 10 USDX to the liquidity

pool ğ¿ğ‘ƒğ‘‹ on X. The new pool amount will become ğ‘›ğ‘‹ := ğ‘›ğ‘‹ + 10.

â€¢ Bridge Operator detects this deposit and does the step below.
â€¢ On Chain Y: Bridge Operator calls the contract Y to transfer to Bob 10 USDY

from the liquidity pool ğ¿ğ‘ƒğ‘Œ . The new pool amount will be ğ‘›ğ‘Œ := ğ‘›ğ‘Œ âˆ’ 10.

Since X and Y are existing chains in which Bridge Operator has no authority to
mint assets, the liquidity pools are needed to provide instant liquidity for the transfer.
The reserve amounts ğ‘›ğ‘‹ and ğ‘›ğ‘Œ set the maximum amount one can transfer to X and
Y, respectively. Thus, the more reserves, the more transfer volume is allowed. One
can be creative by encouraging Liquidity Providers to contribute to these pools.

46

Duc A. Tran and Bhaskar Krishnamachari

In the case that Bridge Operator owns one of the two chains, say chain X, we do
not need liquidity pool ğ¿ğ‘ƒğ‘‹ . In place of ğ¿ğ‘ƒğ‘‹ , Bridge Operator simply mints new
USDX to the receiver anytime receiving a transfer from chain Y. Similarly, Bridge
Operator burns USDX of the sender when needing to transfer it to chain Y. This
is the solution often used when designing a new blockchain network that wants to
bridge with an existing blockchain (e.g. Ethereum, so that the new network can host
a wrapped version of ETH).

A challenge with Chain Bridge is how to ensure security given the role of Bridge
Operator [30]. For maximal security, Bridge Operator needs to be decentralized;
ideally, it can itself be a blockchain network. However, that would lead to implemen-
tation complexities. In fact, no bridging solution has adopted such a method fully.
One can resort to the cryptographic method of secure multi-party communication to
partially decentralize the role of Bridge Operator, as in the Multichain framework10,
but to date weak security remains the biggest concern for Chain Bridge. Many hacks
targeted bridge solutions, most noticeable being the attack on Axie Inï¬nity just this
year (March 2022) incurring a loss of 600+ million USD.

6.3 Chain Hub

Bridging is the interoperability solution to make two blockchains talk to each other.
If there are ğ‘› blockchains, we would need ğ‘›(ğ‘› âˆ’ 1)/2 bridges to enable any two
chains to communicate directly. Chain Hub is an approach that builds the Internet of
blockchains by providing a â€œhubâ€ connecting to all the blockchains and dedicated to
passing messages between them. More than that, this hub itself is a blockchain net-
work, thus providing maximal decentralization and security. Cosmos [28], Polkadot
[5], and Avalanche [40] are major solutions adopting this approach. They call the
â€œhubâ€ by diï¬€erent names (Relay in Polkadot and Avalanche, or Hub in Cosmos).

For example, consider Polkadot [47], whose architecture is illustrated in Figure
16. Polkadot is a network of heterogeneous blockchain shards called â€œparachainsâ€.
These chains connect to and are secured by a chain called Relay Chain; this is the
hub of Polkadot. Existing blockchains or those not of Polkadot network are called
external networks which can talk to any parachain via bridges. There are four main
roles for Polkadot keepers: validators, nominators, collators, and ï¬shermen.

â€¢ Validators: They must be among the nodes that form Relay Chain. Once new
blocks have been validated in their parachains, they must be ratiï¬ed on Relay
Chain. First, a subgroup of validators is chosen randomly to ratify each new
parachain block. This results in a new block to add to Relay Chain. This block
will be validated on Relay Chain as usual by all the validators.

â€¢ Nominators: They are stake-holding parties who risk capital to nominate nodes
to become validators. Nominators get earnings if their nominees are chosen
as validators. The method to choose validators from nominations is based on

10 https://multichain.org/

Blockchain in a nutshell

47

Fig. 16 Polkadot network: Blockchains (parachains) communicate with each other via Relay Chain.
Parachain consensus is ensured by the Collators who are the validators of the parachain. Inter-
parachain consensus is ensured by the Validators who are nodes on Relay Chain.

Nominated Proof of Stake (NPoS) consensus [5]. In some sense, the validators
are similar to the mining pools of current PoW blockchains and the nominators
are similar to the miners who join these pools.

â€¢ Collators: They must be among the parachain nodes. On their parachain, they au-
thor new blocks and execute transactions as usual (like miners in PoW blockchains
or validators in PoS blockchains). In addition, as collators, they provide validators
with valid parachain blocks (and zero-knowledge proofs) as candidate blocks to
ratify on Relay Chain. We can think of collators as â€œlocal helpersâ€ of validators
on each parachain.

â€¢ Fishermen: They are â€œbounty huntersâ€ who monitor Relay Chain and parachains
to report irregularities committed by the nodes. They are rewarded by submitting
a timely proof showinng that at least one bonded party misbehaved. The ï¬shermen
are an additional layer for enhancing the network security.

Polkadot can connect a set of independent blockchains while providing pooled
security and trust-free cross-chain transactability, which is thanks to Relay Chain with
contributions from the above players. However, a Chain Hub solution like Polkadot
requires building blockchains from scratch, which must use the same development
framework (e.g., Substrate11 in Polkadot or Tendermint [27] in Cosmos) and abide a
shared communication protocol. As such, a blockchain network adopting Chain Hub
cannot interface with existing blockchains or those using non-compatible designs.

11 https://www.parity.io/technologies/substrate/

48

Duc A. Tran and Bhaskar Krishnamachari

Chain Hub is therefore called a layer-0 blockchain interoperability solution. In the
future, one hopes that Chain Hub will be successful and widely adopted. When that
happens, we will realize the true vision of Blockchain being a universal computer or
the next-generation Internet.

7 Conclusions

This chapter has presented how blockchain works fundamentally, together with
selective case studies, methods, and challenges, that help the reader understand this
technology quickly to be suï¬ƒciently ready for further adventures. The coverage
includes what blockchain is, its architecture and components, how it works for
Bitcoin with Proof-of-Work consensus, the view of smart contract blockchains as
universal computers, and open challenges in scalability and interoperability, the
top-2 priorities for blockchain technology. It should become now clear that there is
no limit in potential applications of blockchain and emerging business models that
otherwise are not feasible with conventional non-blockchain computing. However,
despite its promise, blockchain technology is still in its infancy. Like the evolution
of the Internet, it takes time for a new technology to mature and be widely accepted
by traditional businesses. Technically, besides the foremost importance of scalability
and interoperability, many other challenges remain to address as we go more deeply
into each component of the blockchain architecture: how to optimize the peer-to-peer
networking layer, innovate consensus mechanisms to be eco-friendly, incentivize
and evaluate contributions to the security and decentralization of the blockchain,
develop smart contracts that are bug-free, enable decentralized ï¬nance for everybody,
and apply eï¬€ectively to other meaningful real-world problems. All that makes the
research and development of blockchain technology interesting.

Acknowledgements Duc A. Tranâ€™s work for this chapter was partially funded by Vingroup Joint
Stock Company and supported by Vingroup Innovation Foundation (VINIF) under project code
VINIF.2021.DA00128. Bhaskar Krishnamachariâ€™s work was supported in part by the USC Viterbi
Center for Cyberphysical Systems and the Internet of Things.

References

1. Back, A.: Hashcash - a denial of service counter-measure (2002). URL http://www.

hashcash.org/papers/hashcash.pdf

2. Back, A., Corallo, M., Dashjr, L., Friedenbach, M., Maxwell, G., Miller, A., Poelstra, A.,
TimÃ³n, J., Wuille, P.: Enabling blockchain innovations with pegged sidechains (2014). URL
https://www.peercoin.net/whitepapers/peercoin-paper.pdf

3. Baird, L., Harmon, M., Madsen, P.: Hedera: A public hashgraph network and governing council

(2020). URL https://hedera.com/hh_whitepaper_v2.1-20200815.pdf

4. Blum, M., Feldman, P., Micali, S.: Non-interactive zero-knowledge and its applications (ex-
In: J. Simon (ed.) Proceedings of the 20th Annual ACM Symposium on

tended abstract).

Blockchain in a nutshell

49

Theory of Computing, May 2-4, 1988, Chicago, Illinois, USA, pp. 103â€“112. ACM (1988).
DOI 10.1145/62212.62222. URL https://doi.org/10.1145/62212.62222

5. Burdges, J., Cevallos, A., Czaban, P., Habermeier, R., Hosseini, S., Lama, F., Alper, H.K., Luo,
X., Shirazi, F., Stewart, A., Wood, G.: Overview of polkadot and its design considerations.
CoRR abs/2005.13456 (2020). URL https://arxiv.org/abs/2005.13456

6. Buterin, V.: Ethereum: A next-generation smart contract and decentralized application platform

(2014). URL https://ethereum.org/en/whitepaper

7. Buterin, V.: An incomplete guide to rollups (2021). URL https://vitalik.ca/general/

2021/01/05/rollup.html

8. Buterin, V.: Why sharding is great: demystifying the technical properties (2021). URL https:

//vitalik.ca/general/2021/04/07/sharding.html

9. Castro, M., Liskov, B.: Practical byzantine fault tolerance. In: Proceedings of the Third Sym-
posium on Operating Systems Design and Implementation, OSDI â€™99, p. 173â€“186. USENIX
Association, USA (1999)

10. Chen, J., Micali, S.: Algorand: A secure and eï¬ƒcient distributed ledger. Theor. Comput. Sci.
777, 155â€“183 (2019). DOI 10.1016/j.tcs.2019.02.001. URL https://doi.org/10.1016/
j.tcs.2019.02.001

11. Chen, T., Lu, H., Kunpittaya, T., Luo, A.: A review of zk-snarks (2022)
12. DamgÃ¥rd, I.: Commitment schemes and zero-knowledge protocols.

In: I. DamgÃ¥rd (ed.)
Lectures on Data Security, Modern Cryptology in Theory and Practice, Summer School,
Aarhus, Denmark, July 1998, Lecture Notes in Computer Science, vol. 1561, pp. 63â€“86.
Springer (1998). DOI 10.1007/3-540-48969-X\_3. URL https://doi.org/10.1007/
3-540-48969-X_3

13. Deloitte: Deloitteâ€™s 2020 global blockchain survey (2020). URL https://www2.deloitte.
com/mt/en/pages/technology/articles/2020-global-blockchain-survey.html
14. Dwork, C., Naor, M.: Pricing via processing or combatting junk mail. In: Proceedings of the
12th Annual International Cryptology Conference on Advances in Cryptology, CRYPTO â€™92,
p. 139â€“147. Springer-Verlag, Berlin, Heidelberg (1992)

15. Ethworks: Zero-knowledge blockchain scalability (2018). URL https://ethworks.io/

assets/download/zero-knowledge-blockchain-scaling-ethworks.pdf

16. Eyal, I., Sirer, E.G.: Majority is not enough: Bitcoin mining is vulnerable. Commun. ACM
61(7), 95â€“102 (2018). DOI 10.1145/3212998. URL https://doi.org/10.1145/3212998
17. Gilad, Y., Hemo, R., Micali, S., Vlachos, G., Zeldovich, N.: Algorand: Scaling byzantine
agreements for cryptocurrencies. In: Proceedings of the 26th Symposium on Operating Sys-
tems Principles, SOSP â€™17, p. 51â€“68. Association for Computing Machinery, New York, NY,
USA (2017). DOI 10.1145/3132747.3132757. URL https://doi.org/10.1145/3132747.
3132757

18. Goodman, L.M.: Tezos: a self-amending crypto-ledger (white paper) (2014). URL https:

//tezos.com/whitepaper.pdf

19. Grunspan, C., PÃ©rez-Marco, R.: The mathematics of bitcoin. CoRR abs/2003.00001 (2020).

URL https://arxiv.org/abs/2003.00001

20. Haï¬d, A., Haï¬d, A.S., Samih, M.: Scaling blockchains: A comprehensive survey. IEEE Access

8, 125244â€“125262 (2020). DOI 10.1109/ACCESS.2020.3007251

21. Hankerson, D., Menezes, A.: Elliptic Curve Cryptography, pp. 397â€“397. Springer US, Boston,

MA (2011)

22. Herlihy, M.: Atomic cross-chain swaps. In: Proceedings of the 2018 ACM Symposium on
Principles of Distributed Computing, PODC â€™18, p. 245â€“254. Association for Computing
Machinery, New York, NY, USA (2018). DOI 10.1145/3212734.3212736. URL https:
//doi.org/10.1145/3212734.3212736

23. Iansiti, M., Lakhani, K.: The truth about blockchain:. Harvard business review 95, 118â€“127

(2017)

24. King, S., Nadal, S.: Ppcoin: Peer-to-peer crypto-currency with proof-of-stake (2012). URL

https://www.peercoin.net/whitepapers/peercoin-paper.pdf

25. Koblitz, N.: Elliptic curve cryptosystems. Mathematics of Computation 48(177), 203â€“209

(1987)

50

Duc A. Tran and Bhaskar Krishnamachari

26. Konstantopoulos, G.: Plasma cash: Towards more eï¬ƒcient plasma constructions (2019). DOI

10.48550/ARXIV.1911.12095. URL https://arxiv.org/abs/1911.12095

27. Kwon, J.: Tendermint: Consensus without mining (2014). URL https://tendermint.com/

static/docs/tendermint.pdf

28. Kwon, J., Buchman, E.: A network of distributed ledgers (2016). URL https://v1.cosmos.

network/resources/whitepaper

29. Lamport, L., Shostak, R., Pease, M.: The byzantine generals problem. ACM Trans. Program.
Lang. Syst. 4(3), 382â€“401 (1982). DOI 10.1145/357172.357176. URL https://doi.org/
10.1145/357172.357176

30. Lan, R., Upadhyaya, G., Tse, S., Zamani, M.: Horizon: A gas-eï¬ƒcient, trustless bridge for
cross-chain transactions (2021). DOI 10.48550/ARXIV.2101.06000. URL https://arxiv.
org/abs/2101.06000

31. Lin, H.Y., Tzeng, W.G.: An eï¬ƒcient solution to the millionairesâ€™ problem based on homo-
morphic encryption. In: Proceedings of the Third International Conference on Applied Cryp-
tography and Network Security, ACNSâ€™05, p. 456â€“466. Springer-Verlag, Berlin, Heidelberg
(2005)

32. Maymounkov, P., Mazieres, D.: Kademlia: A peer-to-peer information system based on the xor

metric. Peer-to-Peer Systems pp. 53â€“65 (2002)

33. Merkle, R.C.: A digital signature based on a conventional encryption function. CRYPTO â€™87,

p. 369â€“378. Springer-Verlag, Berlin, Heidelberg (1987)

34. Miller, V.S.: Use of elliptic curves in cryptography.

In: H.C. Williams (ed.) Advances in
Cryptology â€” CRYPTO â€™85 Proceedings, pp. 417â€“426. Springer Berlin Heidelberg, Berlin,
Heidelberg (1986)

35. Nakamoto, S.: Bitcoin: A peer-to-peer electronic cash system (2008). URL https:

//bitcoin.org/bitcoin.pdf

36. Nguyen, Q., Cronje, A., Kong, M., Lysenko, E., Guzev, A.: Lachesis: Scalable asynchronous
bft on dag streams (2021). DOI 10.48550/ARXIV.2108.01900. URL https://arxiv.org/
abs/2108.01900

37. Poon, J., Buterin, V.: Plasma: Scalable autonomous smart contracts (2017). URL https:

//plasma.io/plasma.pdf

38. Poon, J., Dryja, T.: The bitcoin lightning network: Scalable oï¬€-chain instant payments (2017).

URL https://lightning.network/lightning-network-paper.pdf

39. PwC: Time for trust: The trillion-dollar reason to rethink blockchain pwc projected (2020).

URL https://www.pwc.com/timefortrust

40. Rocket, T., Yin, M., Sekniqi, K., van Renesse, R., Sirer, E.G.: Scalable and probabilistic
leaderless BFT consensus through metastability. CoRR abs/1906.08936 (2019). URL http:
//arxiv.org/abs/1906.08936

41. Sguanci, C., Spatafora, R., Vergani, A.: Layer 2 blockchain scaling: a survey. ArXiv

abs/2107.10881 (2021)

42. Shi, E.: Foundations of distributed consensus and blockchains (book manuscript) (2020). URL

https://www.distributedconsensus.net

43. Szabo, N.: The idea of smart contracts (1997). URL https://nakamotoinstitute.org/

the-idea-of-smart-contracts

44. Wang, D., Zhou, J., Wang, A.: Loopring: A decentralized token exchange protocol (2018).

URL https://loopring.org/resources/en_whitepaper.pdf

45. Wang, T., Zhao, C., Yang, Q., Zhang, S., Liew, S.C.: Ethna: Analyzing the underlying
IEEE Trans. Netw. Sci. Eng. 8(3), 2131â€“
peer-to-peer network of ethereum blockchain.
2146 (2021). DOI 10.1109/TNSE.2021.3078181. URL https://doi.org/10.1109/TNSE.
2021.3078181

46. Wensley, J.H.: Sift: Software implemented fault tolerance. In: Fall Joint Computer Conference,
Part I, AFIPS â€™72 (Fall, part I), p. 243â€“253. Association for Computing Machinery, New York,
NY, USA (1972). DOI 10.1145/1479992.1480025

47. Wood, G.: Polkadot white paper

(2016).

URL https://polkadot.network/

PolkaDotPaper.pdf

48. Yakovenko, A.: Solana: A new architecture for a high performance blockchain v0.8.13 (2017).

URL https://solana.com/solana-whitepaper.pdf

