1
2
0
2

l
u
J

7
1

]

R
C
.
s
c
[

1
v
9
7
2
8
0
.
7
0
1
2
:
v
i
X
r
a

Anonymous Blockchain-based System
for Consortium(cid:63)

Qin Wang1,2, Shiping Chen2, Yang Xiang1

1 Swinburne University of Technology, Melbourne, Australia
2 CSIRO Data61, Sydney, Australia
qinwang@swin.edu.au

Abstract. Blockchain brings various advantages to online transactions.
However, the total transparency of these transactions may leakage users’
sensitive information. Requirements on both cooperation and anonymity
for companies/organizations become necessary. In this paper, we pro-
pose a Multi-center Anonymous Blockchain-based (MAB) system, with
joint management for the consortium and privacy protection for the par-
ticipants. To achieve that, we formalize the syntax used by the MAB
system and present a general construction based on a modular design.
By applying cryptographic primitives to each module, we instantiate our
scheme with anonymity and decentralization. Furthermore, we carry out
a comprehensive formal analysis of the proposed solution. The results
demonstrate our constructed scheme is secure and eﬃcient.

Keywords: Blockchain, Anonymity, Multi-center, Consortium

1

Introduction

Blockchain technology, along with the widespread Bitcoin [2], has garnered insur-
mountable glories and attention from our society. More and more entrepreneurs
and companies, including some world’s biggest banks and technology ﬁrms, are
investing massive amounts of resources, talent, and money to develop blockchain-
based applications. Driven from the Bitcoin system, blockchain can be regarded
as a distributed ledger with the advantages of irreversibility, pseudonymity, and
unforgeability. The stability of the chain relies on miners, who use their elec-
tric power and computational hardware (i.e., consensus on PoW) or their digital
stakes and public authorities (i.e., consensus on PoS, DPoS, PoA) to make the
system proceed in consistency. However, the malicious behavior conducted by
the miners and leaders, such as creating forks, may threaten the security of
blockchain due to the centralization of resources. To avoid the issues, the con-
cept of consortium blockchain has shown its superiority in many ﬁelds, includ-
ing the joint management of organizations, the coin issuance of banks, and the
censorship of governments. The multi-center technique can smoothly distribute
centralized authorities into multiple entities, which brings relatively balanced

(cid:63) This work has been accepted by ACM TMIS [1].

 
 
 
 
 
 
powers across diﬀerent entities. Also, the outcomes of the consortium blockchain
will be beneﬁcial to both academia and industry.

For academia, most of the studies in consortium blockchain focus on the im-
plementation of joint control and supervision. For example, based on partially
blind threshold signatures, Wu et al. [3] proposed a secure joint trading scheme
on top of Bitcoin. The scheme allowed multiple participants to jointly manage
one account, where no one could open it without supports from others. After
that, by incorporating the secret-sharing method and attribute-based encryp-
tion scheme, Zhou et al. [4] proposed a Distributed Bitcoin Account Manage-
ment (DBAM) framework to realize the hierarchically cooperated management
scheme, especially suitable for enterprises and companies. Each account achieved
ﬁne-grained management among participants and prevented private keys from
unexpected recovery. Crain et al. [5] presented a targeting consortium blockchain
based on the resilience optimal Byzantine consensus. This scheme described a
simple and modular Byzantine consensus algorithm that mainly relied on ran-
domization but not leaders and signatures. The algorithm simpliﬁed the problem
of validating blocks, which makes it avoid the Sybil attacks.

For the industry, there are more and more companies and organizations work-
ing together to establish their own consortium blockchains. The Linux Founda-
tion put forwards a PBFT based project called Hyperledger [6] to sever as the ba-
sic foundation of the blockchain. The idea was to create a cross-industry standard
and an open-source development library so that business users could build their
customized solutions, such as R3CEV’s ledger, Corda [7], etc. Corda fundamen-
tally created an environment where each party could access the same data with
the rules that all participants agree. Chinese companies also follow the above
steps. The Chinaledger Alliance [8] was sponsored by Wanxiang Blockchain Lab
in 2015. They have created an open-source blockchain protocol and set standards
across the industries to make sure the regulatory compliance can be satisﬁed.
Moreover, the Post-Trade Distributed Ledger (PTDL) Group [9] improved the
post-trade space which greatly beneﬁts industrial members.

However, although numerous approaches of consortium blockchains are pro-
posed and developed, they still confront the privacy-preserving problem across
diﬀerent parties in the consortium. More speciﬁcally, the plain contents (includes
amounts, addresses, etc.) on the transactions can be freely accessed by the pub-
lic, which may unconsciously leak some sensitive information of the members.
For example, a malicious user can easily ﬁnd the accounts with massive coins
and trace the accounts to target the real entities by connecting them through
some activities such as withdrawing coins by KYC, or exchanging coins oﬄine.
Such kinds of situations severely threaten the security of users’ assets, especially
for the users like ﬁnical service providers in open banking [10].

To address the privacy problem, several approaches are proposed. For exam-
ple, the conﬁdential transaction, originally proposed by Adam Back [11], further
developed by the Bitcoin Core Developer Gregory Maxwell [12,13], aims to en-
hance the privacy of transactions. Their idea was to embed the cryptographic
commitment technique into the Bitcoin model. This idea was further modiﬁed

2

by Shen et al. on Menero [14]. In their implementation, Shen et al. employed the
ring signature to confuse the participants from the input end, together with the
Pedersen Commitment as the homomorphic tool to operate ciphertexts. Based
on that, Ring-CT 2.0 [15] was proposed to formalize the previous version and
accelerate the computing eﬃciency via the cryptographic accumulator. Zerocoin
and Zerocash [16] developed a method to confuse the sources of the transactions
and change the mere pseudonymity into real anonymity, through the mint and
pour step by using the non-interactive zero-knowledge proof (NIZKP). The sen-
sitive information on the ledger was packaged into an envelope without leaking.
Wang et al. [17] proposed a privacy-preserving scheme to encrypt the original val-
ues from plaintexts to ciphertext through the homomorphic Paillier encryption
system with the commitment proofs on its balance. The concept was designed
as a compatible layer on top of the Bitcoin protocol. However, these solutions
only ﬁt the public blockchains, ignoring the scenarios of consortium. Therefore,
considering both sides, the consequent question comes,

Could we establish a consortium blockchain for the group users while protect-

ing the privacy of their sensitive data shown on transactions?

Meeting such requirements is diﬃcult. On the one side, due to the fact that
a consortium blockchain grants several nodes with powerful authority, how to
balance the power of group members becomes the ﬁrst concern. On the other
side, blockchain is a public distributed ledger where all users can see and ac-
cess the content of transactions. Protecting the privacy of sensitive data needs
to seal the plaintexts into ciphertexts. This further brings questions on how to
ensure multiple ciphertexts can be correctly executed and how to guarantee the
value inside ciphertext is within the legal range. All these concerns should be
fulﬁlled without any strong or extra assumptions. The proposed system should
be compatible with various speciﬁcations and forms of applications. State-of-the-
art systems can hardly well address such problems. For instance, Gai et al. [18]
proposed a consortium blockchain-oriented approach to solving the problem of
privacy leakage of the group users that were located in nearby geographic posi-
tions. They mainly created noises (noise-based privacy-preserving approach) to
hide the trading distribution trends for the system rather than screening individ-
ual privacy. However, the scheme only protects the system against a few types
of attacks such as data mining-based attacks. This limits its application to other
scenarios. Ra et al. [19] provided an anonymous protocol for privacy in a consor-
tium blockchain. The protocol achieved privacy via transaction authentications
by group members. This design is insuﬃcient for universal applications because
their solution relies on a strong assumption in which all the group members are
trusted. This is unacceptable for real-world settings.

Contributions. To solve the proposed issues, our system attempts to meet both
requirements on decentralization (for consortium scenarios) and privacy (for sen-
sitive information). Speciﬁcally, our motivation in this paper covers two aspects,
1) to establish a consortium chain for group members, and 2) to simultaneously
protect their privacy of sensitive data recorded on-chain. To meet the ﬁrst re-
quirement, we need to make the involved parties or group members mutually

3

combined through certain techniques (as shown in Joint Management Module).
To meet the second requirement, we need to make the plaintext messages safely
sealed through an encryption algorithm (as presented in Homomorphic Encryp-
tion Module). The question here is how to guarantee the encrypted values are
correctly executed under the operations like addition and subtraction. Thus,
the procedures of veriﬁcation are necessary (as described in RangeVer Module
and EqulityVer). Our scheme is designed and constructed on these decoupled
functions. In this paper, we design a multi-center anonymous blockchain-based
system (MAB system) to address the problems. Our construction is deﬁned in
formal modules and instantiated with several cryptographic primitives. The con-
crete construction is presented with security analyses and computation analyses.
Here, we summarise the contributions of the paper as follows.

– We propose a multi-center anonymous blockchain-based (MAB) system to
solve the problems of decentralization and privacy. The scheme is designed
under the strictly formalized modules. Speciﬁcally, we have deﬁned ﬁve mod-
ules as the basic elements to represent the functional blocks, covering the
cooperation on the generation of trapdoors, the encryption on plain data,
and the veriﬁcation of ciphertexts. Consequently, by revoking the essential
modules, we have presented the general construction of the MAB system
under a strictly deﬁned secure environment. Finally, we have speciﬁed each
module with a practical algorithm to make the whole system ﬂow through
the blockchain-based system.

– We empower the MAB system with the advantages of decentralization, pri-
vacy, and eﬃciency. Speciﬁcally, we have achieved the properties on 1) de-
centralization by making participants jointly generate a system master key
under the help of threshold key generation of RSA; 2) privacy by realizing
the concealment of the amounts of transactions through using homomorphic
Paillier cryptosystem to hide the plaintexts, and the commitment proofs
to keeping the balance and equality correct; 3) eﬃciency by making the
protocol easily and ﬂexibly extended with auxiliary functions such as pre-
processing, ﬁlter, etc.

– We provide formal security analyses on correctness, non-malleability, and
balance. Speciﬁcally, we have stated the rigorous security deﬁnitions and the
corresponding proofs of the MAB system, where the results turn out to be se-
cure under our requirements. Based on each customized module, the security
guarantee of our proposed system is not only driven by the hard mathemat-
ical problems and assumptions, but also the robust blockchain system. Ac-
cording to the speciﬁc scheme, we proceed with the security deﬁnitions and
proofs step by step, ensuring the properties on anonymity, non-malleability,
and balance.

The rest of the paper is organized as follows. Section 2 provides the building
blocks. Section 3 presents the general construction of our MAB system. Section
4 deﬁnes the security models. Section 5 shows the concrete construction with
the implementation skeleton. Section 6 provides security analyses and eﬃciency

4

analyses. Section 7 presents the related works with discussions. Finally, we con-
clude the paper in Section 8. Appendix A provides security proofs, Appendix B
brieﬂy introduces blockchain and Appendix C presents the system workﬂow.

2 Cryptographic Building Blocks

In this section, we introduce the building blocks used in our construction.

RSA Keys in Threshold{A}. The protocol aims to achieve the generation of
a shared RSA key, that is, to make the consortium parties jointly generate a
publicly known RSA modulus N = pq without revealing its factorization. The
encryption exponent is delivered to the public, and each party holds a share
of the private exponent that enables threshold decryption. It is traditional to
generate the parameter under a centralized party, however, the trust of authori-
ties is always at worrisome risk. Numerous cryptographic protocols are requiring
the RSA modulus N = pq where none of the parties know its factorization.
The original Fiat-Shamir protocol [20] uses modulus N where no one knows its
factorization, and the same does to [21][22]. Threshold cryptography [23] is an
enlightened way to generate the shared RSA keys. The constructions that pro-
vide the t−out of−k RSA threshold signature schemes can be found in [24][25].

Homomorphic Cryptosystem{B}. Homomorphic encryption belongs to the public
key cryptography system, and it is a cryptographic theory based on computa-
tional complexity and mathematical problems. Homomorphic operations include
addition, multiplication, and other operations. Although full homomorphic en-
cryption schemes [26][27] realize arbitrary homomorphism of transactions, the
extremely high cost of computation makes it out of reach. Two examples of
Homomorphic Encryption schemes are additive ElGamal [28] and Paillier En-
cryption [29], and both of them have been successfully applied in the design of
e-voting schemes in the past. The additive encryption schemes are also employed
by various state-of-the-art approaches on privacy-preserving protocols.

Commitment on Range Proof{C}. Range proof is used to prove a committed
value that lies in a speciﬁc interval. The scheme is based on the trapdoor com-
mitment scheme which usually consists of two phases, 1) commit phase, and 2)
reveal phase. The receiver sends a committed value in cyphertext, and then the
sender can reveal the secret value for veriﬁcation but the receiver knows nothing
about the exact value. Range commitment conﬁrms that the committed value
lies in the rough interval without revealing the exact value. The proof was ﬁrst
proposed in [30], and developed in [31,32]. As shown in these references, CFT
Proof [31] fulﬁlled the aim of proof, but it required an exceedingly large ex-
pansion rate from [0, b] into [−2120b, 2120b] when compared to [32]. The method
in [32] can limit the internal value to the range [a, b] with negligible deviation,
but the protocol is complicated. Wu et al. [3] has proposed a relatively eﬃcient
scheme with the proof content of x ∈ [a; b] and the expansion rate was δ = 1.

5

Commitment on Equality Proof{D}. The commitment to equality proof, some-
times called Indicative Commitment Proof, is a special scheme used to prove
whether two committed values are equal or not. The traditional commitment
speciﬁes one committed value according to the trapdoor information, while the
indicative commitment executes for two committed values. The unique prop-
erty is that it allows two owners who hold trapdoor information to distinguish
whether two committed values in the unreadable format are equal, without re-
vealing commitments. The protocol is derived from equality proof of two discrete
logarithms from [33,34], combined with knowledge proof of discrete logarithm
‘modulo n’. Moreover, the work [35] provided a general form of an equality proof
between two committed numbers in diﬀerent moduli.

Fig. 1. Scheme Model: The ﬁgure brieﬂy presents two major features of our scheme,
jointly control and privacy protection. Group members obtain their separately shared
key to co-generate the started parameter, and none of them can singly decrypt it. They
use cokeygen parameters to encrypt messages transmitted on the chain, where the
messages are conﬁdentially protected from the public. After receiving the ciphertexts,
the members will use their secret keys to decrypt them.

3 System Construction

In this section, we brieﬂy review basic cryptographic primitives used for our
general construction and then present the formal deﬁnitions of each module
towards their corresponding functional requirements. Based on rigorous deﬁni-
tions, we construct the complete general construction of the MAB system. The
system is composed of ﬁve modules including Joint Management, Homomorphic
Cryptosystem, Range Veriﬁcation, Equality Veriﬁcation, and Blockchain-based
System. We design these ﬁve modules according to key functions used in our
scheme. Each of the modules separately represents a customized function to
meet the requirements. Speciﬁcally, the homomorphic cryptosystem (module)
realizes the function of making two encrypted values correctly executed with
addition/subtraction operations. However, users, to their views, cannot know

6

whether the output value is correct or not. Thus, another two veriﬁcation mod-
ules are introduced. The range veriﬁcation (module) solves the problems on
whether an encrypted value is negative and the equality veriﬁcation (module)
ensures the sum of input values are consistent with the sum of operating out-
put values. Similarly, the joint management (module) realizes the function where
multiple participants are required to co-generate a secrete key for the subsequent
decryption. Finally, the formalized security deﬁnitions are stated which contains
anonymity, non-malleability, and balance. Here, we provide a high-level design
of our system for simplicity as in Table.1.

Table 1. High-level Design

Modules

Notation Participated Entities Functionality

Joint Management

Homomorphic Cryptosystem

Range Veriﬁcation

Equality Veriﬁcation

Blockchain

Π1

Π2

Π3

Π4

Π5

Consortium Member

Secure bootstrap

Common User

Common User

Common User

Seal sensitive data

Prevent theft

Correctness/Integrity

Consortium Member

Secure platform

3.1 Construction on Modules

Joint Management. The module aims to corporately generate a shared private
key. That is, the consortium parties jointly generate a publicly known RSA
modulus N = pq without revealing its factorization. We extend the vague model
into a formal module CoKeyGen based on the Building Block A, to represent
the process of Joint Management in a real environment. Only when most of
the consortium members (larger than the threshold) achieve an agreement, the
factorization can be calculated to decrypt the ciphertext.

Deﬁnition 1 (CoKeyGen) The CoKeyGen module is composed of four prob-
abilistic polynomial algorithms deﬁned as

Π1 = (rdmP ara, coN, BipriT est, KeyGen)

with the following syntax:

(cid:5) rdmPara(1λ, k): When inputting a security parameter λ, each party i secretly
picks a secret n−bit integer pi. The p = p1 + ... + pk cannot be divisible via
trial division by any prime in range. The second iteration for qi operates as
the same.

(cid:5) coN(pi, qi): When inputting each party’s parameter piand qi, the algorithm
outputs the public value of N where N = (p1 + ... + pk)(q1 + ... + qk). N is
not divisible by small primes in range.

7

(cid:5) BipriTest(N ): When inputting a distributed computation by k parties, the
algorithm examines that N is the product of two primes. If it fails, go back
to step 1.

(cid:5) KeyGen(N, e): When inputting a public encryption exponent e, the k parties

jointly generate a secret decryption exponent d as the key.

Homomorphic Encryption. The module aims to encrypt metadata with the prop-
erty of homomorphism for convenient calculation and operation. It can conﬁden-
tially calculate the values in ciphertext while the obtains the correct results. We
input the encrypted data and then process some operations to obtain an unread-
able output. After the decryption, the results of the output data are consistent
with the way they operate in plaintext. According to the Building Block B, we
extended it into a formal module HomoEnc to represent the process of Homo-
morphic Encryption.

Deﬁnition 2 (HomoEnc) The HomoEnc module is composed of four proba-
bilistic polynomial algorithms deﬁned as

Π2 = (HKeyGen, HEnc, HOper, HDec)

with the following syntax:

(cid:5) HKeyGen(1λ): When inputting a security parameter λ, the algorithm outputs
public parameters pms which can be implicitly a part of the input of the
following algorithms.

(cid:5) HEnc(pk, m): when inputting a public key pki and a massage m, the algo-

rithm outputs an encrypted number ci = HEnc(pki, m).

(cid:5) HOper(ci, cj): When inputting several cyphertexts such as ci and cj, the

algorithm executes operations and outputs c = ci ⊗ cj.

(cid:5) HDec(sk, c): When inputting a secret key sk and the operated cyphertext c,

the algorithm outputs m = HDec(sk, c).

The inherent homomorphism can be applied to various ﬁelds such as voting
protocols, threshold cryptosystems, and secret sharing schemes. The scheme also
possesses the properties of being self-reducible and self-blinding. Moreover, the
cryptosystem is convincingly secure under the chosen-plaintext attack in the
standard model such as the Paillier Cryptosystem, which is suitable for hiding
the number of transactions on top of the blockchain-based system [17].

Range Veriﬁcation. The module aims to verify the hidden data lied in a speciﬁed
interval [a, b]. The veriﬁcation can correctly ensure the rough range without
leaking any plain values. According to the Building Block C, we extended it
into a formal module RangeV er, to represent the process of Range Veriﬁcation.
The veriﬁcation improves privacy by hiding the metadata in transactions while
ensuring the values are limited in the speciﬁc range.

8

Deﬁnition 3 (RangeVer) The RangeVer module is composed of four proba-
bilistic polynomial algorithms deﬁned as

Π3 = (RKeyGen, RCom, RInact, RV er)

with the following syntax:

(cid:5) RKeyGen(1λ): To input a security parameter λ, the algorithm outputs the
public parameter pk, the random number r and the trapdoor private key sk.
(cid:5) RCom(pk, x): To input a public key pk and a committed number x, the al-

gorithm outputs a commitment CM = RCom(pk, x).

(cid:5) RInact(pk, CM, r): To input the parameter pk, r and the commitment CM ,
the algorithm executes the interactive protocol and outputs the intermediate
parameter (w, s) on the reveal phase.

(cid:5) RVer(w, s, CM, a, b, sk): To input a secret key sk, the commitment CM , and
an expected interval [a, b], the algorithm outputs 0/1, where 1 represents the
committed number lies in the given interval, otherwise, it outputs 0.

Equality Veriﬁcation. The module aims to verify the equality between the input
sum and the output sum in transaction scripts. The veriﬁcation will not leak
any plain values while ensuring equality. According to the Building Block D,
we extended it into a formal module BanlanceV er to represent the process of
Equality Veriﬁcation. The indicative features are reﬂected in the form of 0 or
1 rather than a concrete committed value. Only when the secret values inside
commitments are equal, the algorithm outputs 1, otherwise, outputs 0.

Deﬁnition 4 (EqualityVer) The Equality module is composed of four proba-
bilistic polynomial algorithms deﬁned as

Π4 = (EKeyGen, ECom, EInact, EV er)

with the following syntax:

(cid:5) EKeyGen(1λ): To input a security parameter λ, the algorithm outputs the
public parameter pk, the random number r and the trapdoor private key sk.
(cid:5) ECom(pk, x): To input the public keys pk, pk(cid:48) and the committed numbers
x, y, the algorithm outputs unreadable commitments C = BCom(pk, x) and
CM (cid:48) = BCom(pk(cid:48), y).

(cid:5) EInact(pk, CM, CM (cid:48), r): To input the parameter pk, r and the commitment
CM, CM (cid:48), the algorithm executes the interactive protocol and outputs the
intermediate parameter (w, s).

(cid:5) EVer(w, s, CM, CM (cid:48), sk): To input a secret key sk, two commitments CM
and CM (cid:48), and parameters w and s, the algorithm outputs 0 or 1, where 1
represents two committed numbers inside commitments are equal, otherwise,
the algorithm outputs 0.

9

Blockchain-based System. The blockchain-based trading system is inherently a
distributed ledger with the properties of irreversibility, traceability, and persis-
tence. It provides an environment for distributed applications. The system adopts
the framework of Nakamoto [2] to achieve credible records, distributed storage,
and transparent transactions. It uses the token as the measurement unit to moti-
vate the participants. The system is formed layer by layer through transactions,
data blocks, and a unidirectional chain. The records on the generated blockchain
are irreversible and persistent. We deﬁne it into a formal module BChain in a
simple way to capture the main structures of Blockchain-based System.

Deﬁnition 5 (BChain) The BChain module represents the Blockchain-based
System that has three layers stated as transactions, blocks, and a unidirectional
chain, and each layer contains several sub-algorithms. The system is deﬁned as

Π5 =(T x[M int, Spend, Contract], Block[T xConf irm, P our],

Chain[Consensus, Recall, Expand])

with the following syntax:

Tx[Mint,Spend,Contract]: Tx layer consists of three sub-algorithms deﬁned as:
(cid:5) Mint(1λ, T Outi−1, reward): To input a security parameter λ for the key
generation, the output value T Outi−1 from last trading address and the
reward from miner if it is the ﬁrst conﬁrmed transaction, the algorithm
outputs a public parameter pk, a trapdoor private key sk, and the total
transaction value for veriﬁcation if needed. If it represents an enhanced
privacy scheme with certain cryptographic primitives, the Mint of the
coin needs to be integrated with the corresponding algorithms such as
ring signature and zero-knowledge.

(cid:5) Spend(T Ini, address): To input the results T ini, the algorithm sends

coins to receivers according to its pk or address.

(cid:5) Contract(Θ, F): If the system is Turing-complete, it will execute a spe-
ciﬁc algorithm whenever the trigger conditions are satisﬁed. To input
the trigger condition Θ and the algorithm F, the initial states will be op-
erated and transmitted according to its predeﬁned rules. The most mature
Turing-complete system is Ethereum[36], whose Distributed Apps(DAPPs)
include ENS, Gnosis, Maker, etc.

Block[TxConﬁrm,Pour]: Block layer consists of two sub-algorithms:

(cid:5) TxConﬁrm(M, C, T x): Entity M ∈ M veriﬁes the existing transactions
T x in the pool and generates a unique identiﬁcation in hash-tree, which
contains not only the amounts but also the possible contracts. There is
only one winner Mi who successfully builds up the block according to the
consensus mechanism C. The conﬁrmed block acts as an intermediate
layer connect the transactions and chains. The entity M ∈ M represents
the persons who successfully conﬁrm blocks, including miners in POW,
stakeholders in POS, candidates in DPOS, etc.

(cid:5) Pour(T, A, S): According to the predeﬁned strategies S, the pour algo-
rithm aims to mix/confuse the plain metadata in transactions tx ∈ T or

10

a unique identiﬁcation such as address ∈ A. Note that the pour process
is designed especially for the cryptocurrency with strong privacy, and
the component of mix represents diﬀerent strategies, such as the mixed
coins in Zcash[37][38] and the mixed addresses in RingCT[39].

Chain[Consensus,Recall,Expand]: Chain layer consists of three sub-algorithms:
(cid:5) Consensus(M, C): Consensus C focuses on who can ﬁnally build the blocks
and how to maintain the consistence. The inputs from entities M will be
recorded on chain after an agreement according to its strategy C.

(cid:5) Recall(F, C): ‘recall’ represents the rollback of f orks ∈ F according to the

consensus mechanism C. Most forks converge into one main chain.

(cid:5) Expand(∆, E): ‘expand’ contains the possible methods E with the aim
to improve the scalability and performance. The methods includes at-
tach side-chains to the main-chain such as the embedded sidechain and
Lightning Network, or directly approve multiple parallel chains such as
DAG-based blockchains.

3.2 Construction of MAB

Based on the above-mentioned modules, we proceed to present the general con-
struction of our Multi-center Anonymous Blockchain-based (MAB) system.

Deﬁnition 6 (MAB) The Multi-center Anonymous Blockchain-based System
is composed of ﬁve modules as

Π = M AB(CoKeyGen, HomoEnc, RangeV er, EqualityV er, BChain)

which can also be denoted by the tuple as Π = (Π1, Π2, Π3, Π4, Π5).

Transaction Flow:
(pm, qm) Π1←−− rdmP ara(1λ) distribute parameters pi and qi for two iterations
(N, dm) Π1←−− CoN (pm, qm) compute the public parameter N
(0/1) Π1←−− BipriT est(N, T ) biprimity test for integer N under the strategy T
(d) Π1←−− KeyGen(N, e) jointly generate the consortium private key
(pki) Π5←−− T x[M int](d, 1λ, addri) generate the public key for encryption
(ci) Π2←−− HEnc(pki, mi) homomorphically encrypt the metadata in transactions
(CM ) Π2←−− HOper(ci, ..., ck) homomorphic operation used for veriﬁcations
(w, s) Π3←−− RInact(CM, pk, r) execute the interactive protocol of range proof
(0/1) Π3←−− RV er(w, s, [a, b], CM ) verify the validity in the speciﬁed range
(u, v) Π4←−− EInact(CM, CM (cid:48), pk, r(cid:48)) execute the protocol of equality proof
(0/1) Π4←−− EV er(u, v, CM, CM (cid:48)) verify the equality between In-sum and Out-sum
) Π5←−− T x[Spend](ci, addri) transfer the coin from senders to receivers
(caddri
i
(0/1) Π5←−− Block[T xConf irm](M, T x) conﬁrm Tx in blocks
(mi) Π2←−− HDec(ci, ski) decrypt the ciphertext under the private key

11

The strictly deﬁned modules could be substantiated by speciﬁc protocols ac-
cording to the requirements. By calling the modules, our MAB system achieves
properties and functions on the Joint Management for organizations, the Ho-
momorphic Encryption for metadata, the Range Veriﬁcation, and the Equality
Veriﬁcation for correct data. Here, we provide the complete workﬂow of MAB
between the senders and the receivers by calling sub-algorithms and modules.

4 Security Deﬁnitions

Our MAB system, denoted as Π, aims to achieve the security properties of
Anonymity, Non-malleability and Balance, which are strictly deﬁned as below.
The adversary is represented as A for short, and Adv represents the advantage
of an experiment. pms, CM, m, r are the parameters, commitments, massages,
and random numbers, respectively.

Anonymity. The property requires that the encrypted metadata shown on the
transaction, such as the transferring value is completely hidden in a commit-
ment CM , and the proof used in the protocol is at least computationally zero-
knowledge. These two facts ensure that the adversary A has at most negligible
advantage in guessing the plain information.

Deﬁnition 7 (Anonymity) The MAB system Π is anonymous-secure (ANY),
if for all PPT adversaries A and suﬃciently large λ, it holds that

AdvANY

Π,A (λ) < negl(λ)

where AdvAN Y
deﬁne as follows,

Π,A (λ) := P r[AN Y (Π, A, λ)] is A’s advantage in the experiment

A(c) = b :











(CM, c) ← HEnc/HOper/KeyGen(1k);
CM 1 ← RV er(CM );
CM 2 ← EV er(CM );
(c0, c1) ← A(CM 1, CM 2);
b ← {0, 1};
(cid:63)c ← HDec(CM 1, CM 2, cb)











.

Non-malleability. The property requires that a malicious user cannot fake any
transactions or others’ identities after observing an honestly generated transac-
tion. Namely, a commitment cannot be opened to two diﬀerent values. There-
fore, it is infeasible for attackers to produce a valid transaction or identity that
shares the same information inside the ciphertext or the commitment. The non-
malleability has already covered the linkability property, which aims to distin-
guish the diﬀerence between the participants.

Deﬁnition 8 (Non-malleability) The MAB system Π is non-malleability(N-
MAL), if for all PPT adversaries A and suﬃciently large λ, it holds that

AdvN-MAL

Π,A (λ) < negl(λ)

12

Π,A

where AdvN −M AL
(λ) := P r[N − M AL(Π, A, λ)] is A’s advantage in the exper-
iment deﬁne as follows. Note that, the left column is the preconditions of the
experiment, and the right column shows the procedure of the experiment. The
equation marked with (cid:63) represents the condition used to decide whether A wins
the experiment after the challenges,

m0 (cid:54)= m1 ∧ CM (m0, r0) = CM (m1, r1) :

(cid:20) (pms) ← KeyGen(1k);
(cid:63)(m0, r0, m1, r1) ← A(pms);

(cid:21)

.

Balance. The balance property consists of two parts, which requires that 1)
any malicious user cannot spend negative value from others; technically, the
committed numbers inside the ciphertexts should lie in a speciﬁc interval; and 2)
each transaction can keep the balance and quality between inputs and outputs;
technically, it is to prove that the quality of two unrelated committed values
without revealing the commitments.

Deﬁnition 9 (Balance) The MAB system Π is balance-secure(BAL), if for
all PPT adversaries A and suﬃciently large λ, it holds that

AdvBAL

Π,A (λ) < negl(λ)

where AdvBAL
ﬁne as follows,

Π,A (λ) := P r[BAL(Π, A, λ)] is A’s advantage in the experiment de-

m0, m1 ∈ Z; r0, r1 ∈ Z :









(pms) ← KeyGen(1k);
c0 ← HEnc(pms, m0, r0),
c1 ← HEnc(pms, m1, r1);
(cid:63)1 ← RV er(c0, c1);
(cid:63)1 ← EV er(c0, c1);









.

5

Instantiations

5.1 Concrete construction

In this subsection, we present an instantiation of our MAB system under the
formalized syntax. Our exempliﬁed protocol extends the privacy-preserving pro-
tocol of Wang et al. [17] with the feature of multi-centers. We specify each
module with the customized algorithms for concrete construction. The steps of
the modules are explained as follows.

Π1 : To jointly generate the trapdoor of RSA keys in transactions, technically,
we employ the threshold scheme [23] to divide a complete key into several
shares and distribute them to multiple parties. The protocol publicly outputs
an RSA modulus N = pq, but none of the parties know the factorization
of N . Each participant holds a share of private exponents that enable the
threshold decryption.

13

Π2 : To hide the plain data in transactions, technically, we employ the homo-
morphic Paillier encryption scheme [29] to encrypt the plain amounts into
ciphertexts. The scheme is based on the composite residuosity class problem,
which is provably secure under the appropriate intractability assumptions in
the standard model. The algorithm hides the original plain amounts, and
only the receivers who own the private keys can decrypt the ciphertexts.
Π3 : To ensure the positiveness of the encrypted values in transactions, techni-
cally, we employ the proof of committed numbers lied in speciﬁc intervals
[40] to keep the value in range. The veriﬁcation is essential to guarantee the
security of individual accounts. This step prevents the deception inside the
ciphertext from the attackers.

Π3 = PK{x, r| E = E(x, r) mod n ∧ x ∈ [a, b]}

Π4 : To verify the equality between the input sums and the output sums, tech-
nically, we employ the proof of the equality of two committed numbers [32]
to guarantee their consistency inside two blind commitments. We link it by
ensuring the similarity of basic parameters, such as the generators of gd and
gβ in veriﬁcation, and the random number rd and hβ in encryption.

Π4 = PK{x, r1, r2|E = E1(x, r1) mod n1 ∧ F = E2(x2, r2) mod n2}

(pm, qm) Π1←−− rdmP ara(1λ): Distribute parameters pm and qm for two itera-
tions. Each party or group member m selects an integer pm and keeps it secret.
Then the k parties compute p = p1 + ... + pm + ... + pk where p is indivisible by
any primes less than some bound through a trial division test. If the step returns
true, the parties execute the second iteration by q = q1 + ... + qm + ... + qk.

(N, di) Π1←−− CoN (pm, qm): The k parties using a private distributed compu-
tation to compute the public parameter N = (p = p1 + ... + pm + ... + pk)(q =
q1 + ... + qm... + qk). After that the parties further perform trail divisions to test
whether N is indivisible by any small primes in certain range.

(0/1) Π1←−− BipriT est(N, T ): The k parties engage in a private distributed
computation, via the biprimity test T , to test the integer N is the product of
two primes. When this step returns true, then move into the next step. Note
that the biprimality test is k − 1 private.

(d) Π1←−− KeyGen(N, e): to input public encryption e, the parties jointly gen-
erate the consortium private key, and output a shared secret decryption exponent
d. We can see that the RSA parameter N is related to the setup of the system
in the next step, and the secret exponent d under the cooperated generation can
be regarded as the trapdoor of the encryption system.

(pki, pkd) Π5←−− T x[M int](1λ, addri, N, p, q): For diﬀerent receiver (distributed
nodes) i, the system inputs the primes pi = p, qi = q, ni = N , and generates
the public key pki = (ni, gi) for encryption, where gi ∈ Z
such that gi ≡
1 mod ni, and secret key ski = λi for decryption where λi = lcm(pi − 1)(qi − 1).
Simultaneously, the system generates another pkd = (nd, gd) as the parameter
for the veriﬁcation in dumb account with no private key to spend money, where

n2
i

14

nd is a large safe composite number. The system then generates Vα(gα, hα) and
Vβ(gβ, hβ), where gα is an element of large order in Z∗
and hα is an element of
nα
the group generated by gα such that both the discrete logarithm of gα in base
hα and the discrete logarithm of hβ in base gα are unknown to the sender. The
same does to gβ and hβ.

(ci, cid) Π2←−− HEnc(mi, pki, pkd): The sender called Alice ﬁrstly computes
the input-sum m = min = DecpkAlice (cin ⊗ 50reward)(if Alice is miner). Em-
ploy the Paillier cryptosystem to homomorphically encrypt the plain amounts
m1, m2, ..., mi into ciphertexts c1, c2, ..., ci under the diﬀerent pk1, pk2, ..., pki
from the receiver i. Simultaneously encrypt them under the system’s pkd in par-
allel to the veriﬁcation steps. Instead of being sent into the receivers’ accounts,
the encrypted bitcoins under the system pkd are sent into the dumb account.
Speciﬁcally, it goes as: ci = Encpki(mi) = gmi
i mod n2
in transaction layer
i
and cid = Encpkd (mi) = gmi
d in veriﬁcation layer. Note that the ran-
dom number is rd = hβ, which is an element of the group generated by gβ ∈ Z∗
.
nβ
Clearly, system has encrypted the same amount mi in two layers with diﬀerence
on public keys.

d mod n2

d rnd

i rni

(CM ) Π2←−− HOper(cj, ..., ck): In the encryption process, Alice sends her
coins to the receivers under pki, and sends the same amounts to the dumb ac-
count under pkd. The system executes homomorphic operation CM = (cid:81) cid =
HOper(cid, ..., ckd) used for veriﬁcation.

1 hr1 mod n, E3 = Eα

1 hr1 mod n ∧ E3 = Eα

2 hr2 mod n}, PK2{ω, r∗ : F = gωhr3

(0/1) Π3←−− RInact, RV er(Vα, Vβ, CM, pk, m, mi): Execute the interactive pro-
tocol of range proof. For simplicity, gd, hd, nd are written as g, h, n, and the
commitment made by Alice for each mi: Ei0(mi, r) = gmihr mod n, Ei1, Ei2,
Ei3, Fi, Vi are written as E0(mi, r), E1, E2, E3, F , V to represent a typical
one of them. The algorithm goes: 1) Alice sends (V, E2, E3, F ) to Bob, where
E1 = gx−ahr = gyhr mod n, E2 = Eα
2 hr2 mod n, F =
gωhr3 mod n, V = gv/E3 = gωh−rα2−r1α−r2 mod n. 2) Bob computes E1, U ,
where E1 = E(x, r)/ga = gyhr mod n, U = gv/E3 = gωh−rα2−r1α−r2 mod n.
3) Alice, Bob compute separately PK1, PK2, PK3, where PK1{α, r1, r2 : E2 =
Eα
mod n ∧ U =
gωhr∗
mod n},PK3{ω, r3 : F = gωhr3 mod n ∧ ω ∈ [−2t+l+s+T , 2t+l+s+T ]}. 4)
Bob checks the correctness of PKi(i = 1, 2, 3) and that v > 2t+l+s+T , which
convinces Bob that x > a (we set a = 0). 5) For each mi, repeat step 1-4 to
prove mi > 0 (i ∈ {1, 2, ..., i}). Note that the steps will be iterated for i times
for every mi and if all succeed, the system returns 1, and then goes to the next.
(0/1) Π4←−− EInact, EV er(CM, CM (cid:48), pk, r(cid:48)): Execute the interactive proto-
col of equality proof. To verify the output-sum (cid:80) mi inside cooperated cipher
(cid:81) ci equals to input-sum m in the commitment, we need to guarantee a)the
secret m = (cid:80) mi in E and F from Alice are identical, and b) the operated
ciphertext H = (cid:81) cid is equal to the committed number F . It proceeds as
1) Alice makes two committed number E and F , where E = Eα(m, rα) =
gm
α hrα
β . 2) Alice computes W1, W2, where W1 =
1 hη1
2 mod n2, ω ∈ {1, ..., 2i+tb − 1}, η1 ∈ {1, ..., 2l+t+sn −
gω

α , F = Eβ((cid:80) mi, rβ) = gm
1 mod n1, W2 = gω

β hrβ

2 hη2

15

i

1+m(cid:48)

1 hD1

2 hD2

rnd
d mod n2

1 E−u mod n1||gD

i = gm(cid:48)
2+...+m(cid:48)
2...c(cid:48)
d
(cid:80) mi
hrβ
β mod nβ = g
d

1}, η2 ∈ {1, ..., 2l+t+sn − 1}. 3) Alice sends to Bob with (u, D, D1, D2), where
u = H(W1||W2), D = ω + ux, D1 = η1 + ur1, D2 = η2 + ur2. 4) Bob
checks whether u = u(cid:48), where u(cid:48) = H(gD
2 F −u mod n2).
If successful, goes to next. 5) System in dumb account computes H, where
(cid:80) m(cid:48)
H = (cid:81) cid = c(cid:48)
rnd
1c(cid:48)
d = g
d. 6) Compute F ,
i
d
(cid:80) mi
rnd
d mod n2
where F = g
d, and parameters are speciﬁed
β
as rd = hβ, rβ = nd, nβ = n2
d, and gd = gβ. 7) Check wether H equals to F , where
(cid:80) m(cid:48)
(cid:80) mi
i = (cid:80) mi, sys-
d. If yes, means (cid:80) m(cid:48)
rnd
d mod n2
H = g
d, F = g
i
d
d
tem returns 1.
(caddri
i

) Π5←−− TAlice[Spend](0/1, ci, addri): The transaction, denoted as TAlice,
is broadcast to the P2P network to form a new block, and the contents on scripts
are unrecognisable strings c from the latest transaction and the related addri.
The same pattern is suitable for all others. Note that before the transaction is
spent, the dumb account will be discarded automatically, since it exists only for
the veriﬁcation without private keys.

rnd
d mod n2

(0/1) Π5←−− Block[T xConf irm](M, TAlice): Miners M verify the collected Tx,

including TAlice, into a conﬁrmed blocks under the speciﬁc mechanism.

(mi) Π2←−− HDec(ci, ski): Receiver decrypt the ciphertext under the private
key ski as mi = L(cλi
and x ∈ Sn = {u <
L(gλi
n2|x = 1 mod n}. The decrypted values are conﬁdentially transferred from the
sender to the receiver.

mod ni, where L(x) = x−1
n

i mod n2
i )
i mod n2
i )

5.2 Key Functions

In this section, we emphasize two types of functions in our scheme. Here, we list
their logic with the workﬂow in Fig.3 at Appendix C.

Function Design. We provide example codes, including CoKeyGen and Ho-
moEnc, to show how we establish the functions. Our design presents the basic
logic of the aforementioned modules.

Function of CoKeyGen. This function attempts to achieve the generation of a
shared RSA key. Consortium parties are required to corporately generate a pub-
licly known RSA modulus N = pq without revealing its factorization. Suppose
there are k parties (k committee members), each party will generate their own
private parameter pi and qi. A systematic parameter is obtained by separately
combining the parameter shares from committee members together, where any
one cannot individually reverse the single share. The BipriTest checks whether
the generated systematic parameter is the product of two primes. If not passed,
the algorithm returns. If passed, k parties jointly generate a secrete decryp-
tion exponent as the systematic private key. Corporately generating the key by
individual members indicates their mutual relationship as well as restrictions.

16

Algorithm 1: CoKeyGen

Input: Security parameter λ, public encryption exponent e
Output: private key exponent d

while 1 ≤ i ≤ k do

(pi, qi)= rdmPara(1λ, k) % generate key shares for each participants

end
N=coN(pi, qi){ % generate the systematic parameter

p = Σpi;
q = Σqi;
N = pq ;

};
while 1 ≤ i ≤ k do

0/1=BipriTest(N) % check the conditions
if 1 then

return “Passed”;
d=KeyGen(N,e) % check the systematic key exponent

else

return “Failed”;
go to N=coN(pi, qi);

end

end

Function of HomoEnc. This function attempts to encrypt the plaintext mes-
sages m and decrypt the encrypted messages c. The encrypt metadata with the
property of homomorphism for correct additive calculations of encrypted mes-
sages. The algorithm includes both the encryption procedure and the decryption
procedure. For the encryption, we input the plain messages m and the public key
of users pk and obtains the operated ciphertext c. For the decryption, we input
the encrypted messages c and the public and private key pair of users pk, sk,
and obtains the decrypted plaintext m. The results of the output messages are
consistent with the way they operate in plaintext.
Transaction Flow. By calling the modules (functions) speciﬁed as above, we
provide the work ﬂow in Fig.3 at Appendix C. For easy understanding, the
structure of the system is presented in two layers including transaction layer
and veriﬁcation layer. Each layer will provide a speciﬁc function.

6 Analysis of MAB

6.1 Security Analysis

In this section, we provide the security analyses of our protocol in detail.

Theorem 1 (Anonymity) Assuming that the discrete logarithm problem is
hard in Gq, the strong RSA assumption is hard, and the commitment proof is
sound in the random oracle model, our proposed MAB protocol is anonymous.

17

Algorithm 2: HomoEnc

Input: public key pki, message m
Output: -

c = HEnc(pk, m) % encrypted the messages under the user’s public key
while True do

r = prime(round(math.log(pk.n, 2))))
if r ¿ 0 and r ¡ pk.n then

break

else

return

end

end
x = pow(r, pk.n, pk.nsquare) ;
c = (pow(pk.g, m, pk.nsquare) ∗ x) ;
return c
}

m= HDec(sk, pk, c) % decrypt the encrypted messages under the user’s

private key

x = pow(cipher, sk.l, pk.nsq) − 1
m = ((x//pk.n) ∗ sk.m)
return m
}

Theorem 2 (Non-malleability) Assuming that the discrete logarithm prob-
lem is hard in Gq, the strong RSA assumption is hard, and the commitment proof
is sound under random oracles, our proposed MAB protocol is non-malleable.

Theorem 3 (Balance) Assuming that the discrete logarithm problem is hard
in Gq, the strong RSA assumption is hard, and the commitment proof is sound
in the random oracle model, our proposed MAB protocol is balanced.

As shown above, our scheme achieves the properties of anonymity, non-

malleability, and balance. Detailed proofs are presented in Appendix A.

6.2 Eﬃciency Analysis

In this section, we provide the theoretical computation complexity of our scheme,
including the sub-algorithms of Joint KeyGen, Encryption, Veriﬁcation, Decryp-
tion, and Blockchain. We employ the τa, τm, τM , τE, τH to represent the unit
times of the operations on addition, multiplication, modular multiplication, mod-
ular exponentiation, hash function operation, respectively. τtd is for trial division
test while τbp is for biprimality test. τT x represents the P2P broadcasting time
and I/O writing time, and τBl is the block conﬁrmation time by miners. The
detailed evaluations are shown in Table 2. Not that, these estimations are purely
indicative, and are not derived from an actual implementation.

18

From the second column of Table 2, we obtain that our scheme is theoret-
ically eﬃcient since each unit of τ is usually small in practice. The encryption
and decryption take time at the same level. The veriﬁcation costs most of the
time since the operations are complex with the commitment proofs. The time of
blockchain varies according to the underlying platform and its consensus.

Table 2. Performance Evaluation

Complexity Unit of Time

Joint KeyGen τbp + 3τtd + 2kτa + τm
Encryption
Veriﬁcation
Decryption
Blockchain

2iτM + 4iτE
(2i + 3)τm + (7i + 8)τM + (12i + 14)τE + 2τH
2τm + 2iτE
iτT x + τBl

7 Related Work with Discussions

7.1 Types of Blockchain

Generally, three types of blockchains are know to the public, namely private
chain, consortium chain and public chain. The rule to distinguish these three
types of blockchain is the size of powerful members. A powerful member means
the person who has the right to conduct key procedures of blockchain, such
as packaging transactions, proposing blocks, and executing consensus. Private
chain is the smallest blockchain in scale since only one person participates in
the network. The person deploys the chain on his own and utilizes it for a brief
simulation and experimental test, which is suﬃciently ﬂexible for further devel-
opment. Any blockchain projects can be used as a private chain, like Ethereum
[36], Bitcoin [2], etc. Consortium chain and public chain have no restrictions on
the size of members. The key diﬀerence between the consortium chain and the
public chain is whether they are permissioned. The consortium chain is permis-
sioned, where two entities are involved, the committee node and the common
node. A group of members, also called the committee, have the power of pack-
aging blocks and executing consensus. Becoming the member requires meeting
certain conditions. For example, schemes adopting PoS-based mechanisms make
the users who hold the most stakes become the committee member. In contrast,
the common node can only send and synchronize blocks from committee nodes.
Famous consortium blockchain projects are Hyperledger [6], R3 Corda, and the
Post-Trade Distributed Ledger (PTDL) Group (Webpage linkages can be found
in the footnotes on Page 2). The public chain is permissionless, where all nodes
can equally and freely join in or leave the network. This type of project maxi-
mumly improve the participation of the blockchain, since everyone can compete
for rewards and proﬁts. Typical projects are Bitcoin [2] and Ethereum [36].

19

7.2 Consortium Blockchain

Blockchain can be classiﬁed into three general types, private, consortium, and
public blockchain [41][42]. The private blockchain is deployed and maintained by
a single organization, and it has weak centralization and low transaction costs.
Public blockchain allows anyone to access the system and complete to generate
the blocks and it is completely decentralized where the participants do not trust
each other. Consortium Blockchain, as the balance between the private chain
and public chain, speciﬁes a group of members as the committee to maintain
the chain. The consortium blockchain is suitable to establish decentralized ap-
plications with the features of multi-center regulation and high performance.
Consortium blockchain is practically suitable for numerous ﬁelds, including art
auction [43], ﬁnancial service [10], etc.

To establish a consortium blockchain for group members, the priority is to
establish a membership selection mechanism for the committee. The member-
ship selection selects the nodes who can participate in the decision of consensus,
to determine the blocks and the direction of the chain. Therefore, the (par-
tially) permissioned consensus [44], with certain restrictions on node participa-
tion, is necessary for the system design. Pre-deﬁned conditions in permissioned
blockchains limit the size, behaviors, and power of the committee members.
BFT-style protocols, as the most prevailing adopted consensus mechanisms in
industries, serve for numerous companies and organizations like Linux Founda-
tion, IBM’s Hyperledger [6], R3CEV’s Corda, Chinaledger, etc. The protocols
aim to address the Byzantine Problem in a distributed system. They solve the
fault tolerance issues against the unpredictable behaviors of malicious nodes such
as hardware errors, network congestion, and malicious attacks. PBFT [45] makes
the BFT algorithm practical, and its variants are widely applied to blockchain
systems. The solutions includes the dBFT of NEO [46], the BFT of Hotstuﬀ [47],
the PoS+PBFT of Tendermint [48], the vote-based BFT of Algorand [49], etc.

7.3 Privacy-Enhancing Blockchain

The privacy of blockchain presents whether a blockchain can guarantee conﬁden-
tiality for the data stored on it. For the blockchains purely targeted for trading
and exchanging, the leakage of transaction information (amount, address, etc.)
may exposure the privacy of users in real life. For the blockchain systems which
employ the smart contract to support sophisticated logic, they confront addi-
tional risks in all layers. An adversary may attack the contracts by analyzing
the vulnerabilities of deployed codes. Therefore, the privacy of sensitive data
is urgently because the potential scope of blockchain is beyond merely virtual
currencies. A primary example is to hide the bill amount in daily life [50].

There are several cryptographic tools used to enhance the privacy of the
blockchain systems. 1) Crypto Commitment: This method aims to hide the plain-
texts by encrypted them without losing the feature of being operable. Therefore,
it requires the commitment scheme to have homomorphic property. The origi-
nal concept of the conﬁdential transaction was proposed by Adam Back [11],

20

further developed by Gregory Maxwell [12,13]. Their idea was to embed the
cryptographic commitment technique into the Bitcoin model. Wang et al. [17]
proposed a scheme by using the homomorphic Paillier encryption system with
the commitment proofs on its balance. 2) Ring Signature: It is a type of digital
signature used to hide the identity in the group. This idea was ﬁrstly adopted
by Menero [14]. The scheme confuses the participants at the input end, together
with the Pedersen Commitment as the homomorphic tool to operate ciphertexts.
Later, the improved Ring-CT [15] was proposed to enhance the protocols with
higher eﬃciency and better privacy. 3) Zero-Knowledge Proof (ZKP): ZKP rep-
resents a series of protocols with the aim to prove the correctness of speciﬁed
value to someone without exactly revealing it. Zerocoin/Zerocash [16] was the
ﬁrst blockchains system to adopt the ZKP technique. It proposed a method to
confuse the sources of the transactions, which changes the mere pseudonymity
into real anonymity. The sensitive information on the ledger was hidden through
the steps of mint and pour.

8 Conclusion

In this paper, we propose a Multi-center Anonymous Blockchain-based system
under the strictly deﬁned security environment, which provides the properties on
1) improving the privacy of metadata presented on the ledgers; 2) realizing the
joint management in the consortiums. To achieve the system, ﬁrstly, we provide
the general construction by formalizing ﬁve modules based on cryptographic
primitives to reconstruct the functional blocks of our scheme, which achieves the
cooperation on the generation of trapdoors, the encryption on plain data, and the
veriﬁcation on ciphertexts. Secondly, we customize each module by employing
relatively matured algorithms to build the concrete construction. The modules
employ the techniques on the threshold RSA, the Paillier cryptosystem, and the
commitment proof. Finally, we present the rigorous security deﬁnitions and the
corresponding proofs of our scheme. The results demonstrates that the proposed
scheme is strictly secure and practically eﬃcient.
Acknowledgement. Sincere appreciations to my previous supervisor Prof. Qian-
hong Wu (Beihang University, China) for his ever discussion with me on the idea.
Part of the construction has followed my previous solution in [17]. Also, this work
has been partially completed during my Master’s study at Beihang University.

References

1. Qin Wang, Shiping Chen, and Yang Xiang. Anonymous blockchain-based system
for consortium. ACM Transactions on Management Information Systems (TMIS),
12(3):1–25, 2021.

2. Satoshi Nakamoto. Bitcoin: a peer-to-peer electronic cash system, 2008.
3. Qianhong Wu, Xiuwen Zhou, Bo Qin, Jiankun Hu, Jianwei Liu, and Yong Ding.
Secure joint bitcoin trading with partially blind fuzzy signatures. Soft Computing,
21(11):3123–3134, Jun 2017.

21

4. X. Zhou, Q. Wu, B. Qin, X. Huang, and J. Liu. Distributed bitcoin account man-
agement. In 2016 IEEE Trustcom/BigDataSE/ISPA, pages 105–112, Aug 2016.

5. Tyler Crain, Vincent Gramoli, Mikel

Larrea,

(leader/randomization/signature)-free
blockchains. CoRR, abs/1702.03068, 2017.

byzantine

and Michel Raynal.
consortium

for

consensus

6. Elli Androulaki et al. Hyperledger fabric: a distributed operating system for per-
missioned blockchains. In Proceedings of the Thirteenth European Conference on
Computer Systems Conference (EuroSys), pages 1–15, 2018.

7. R3 corda. http: // www. corda. net , 2019.
8. Chinaledeger. http: // www. chinaledger. com , 2019.
9. Post-trade distributed ledger (ptdl) group. http: // www. ptdlgroup. org , 2019.
10. Zhiyu Xu et al. Ppm: A provenance-provided data sharing model for open bank-
In Proceedings of the Australasian Computer Science Week

ing via blockchain.
Multiconference (ACSW), pages 1–8, 2020.

11. Adam Beck. bitcoins with homomorphic value. Bitcointalk, 2014.
12. G. Maxwell. Coinjoin: Bitcoin privacy for the real world, 2013.
13. G. Maxwell. Conﬁdential transactions, 2015.
14. S. Noether. Ring signature conﬁdential transcation for monero, 2015.
15. Shi-Feng Sun et al. Ringct 2.0: A compact accumulator-based (linkable ring sig-
nature) protocol for blockchain cryptocurrency monero. In Computer Security –
ESORICS 2017, pages 456–474, Cham, 2017.

16. E. B. Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza.
Zerocash: Decentralized anonymous payments from bitcoin. In 2014 IEEE Sym-
posium on Security and Privacy (SP), pages 459–474, May 2014.

17. Qin Wang et al. Preserving transaction privacy in bitcoin. Future Generation

Computer Systems, 2017.

18. Keke Gai, Yulu Wu, Liehuang Zhu, Meikang Qiu, and Meng Shen. Privacy-
preserving energy trading using consortium blockchain in smart grid. IEEE Trans-
actions on Industrial Informatics, 15(6):3548–3558, 2019.

19. Gyeong-Jin Ra, Daehee Seo, Md Zakirul Alam Bhuiyan, and Im-Yeong Lee. An
anonymous protocol for member privacy in a consortium blockchain. In Interna-
tional Conference on Security, Privacy and Anonymity in Computation, Commu-
nication and Storage (SpaCCS), pages 456–464. Springer, 2019.

20. Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identiﬁ-
cation and signature problems. In Advances in Cryptology — CRYPTO’ 86, pages
186–194, Berlin, Heidelberg, 1987. Springer Berlin Heidelberg.

21. Uriel Feige, Amos Fiat, and Adi Shamir. Zero-knowledge proofs of identity. Journal

of Cryptology, 1(2):77–94, Jun 1988.

22. Matthew Franklin and Stuart Haber. Joint encryption and message-eﬃcient secure

computation. Journal of Cryptology, 9(4):217–232, Sep 1996.

23. Dan Boneh and Matthew Franklin. Eﬃcient generation of shared rsa keys.

In
Advances in Cryptology — CRYPTO ’97, pages 425–439, Berlin, Heidelberg, 1997.
Springer Berlin Heidelberg.

24. Yvo Desmedt and Yair Frankel. Shared generation of authenticators and signa-
tures. In Advances in Cryptology — CRYPTO ’91, pages 457–469, Berlin, Heidel-
berg, 1992. Springer Berlin Heidelberg.

25. Tal Rabin. A simpliﬁed approach to threshold and proactive rsa.

In Advances
in Cryptology — CRYPTO ’98, pages 89–104, Berlin, Heidelberg, 1998. Springer
Berlin Heidelberg.

26. Craig Gentry. A Fully Homomorphic Encryption Scheme. PhD thesis, Stanford,

CA, USA, 2009. AAI3382729.

22

27. Marten van Dijk, Craig Gentry, Shai Halevi, and Vinod Vaikuntanathan. Fully
homomorphic encryption over the integers. In Advances in Cryptology – EURO-
CRYPT 2010, pages 24–43, Berlin, Heidelberg, 2010. Springer Berlin Heidelberg.
28. T. Elgamal. A public key cryptosystem and a signature scheme based on discrete
logarithms. IEEE Transactions on Information Theory, 31(4):469–472, Jul 1985.
29. Pascal Paillier. Public-key cryptosystems based on composite degree residuosity
classes. In Advances in Cryptology — EUROCRYPT ’99, pages 223–238. Springer
Berlin Heidelberg, 1999.

30. Ernest F. Brickell, David Chaum, Ivan B. Damg˚ard, and Jeroen van de Graaf.
Gradual and veriﬁable release of a secret (extended abstract).
In Advances in
Cryptology — CRYPTO ’87, pages 156–166, Berlin, Heidelberg, 1988. Springer
Berlin Heidelberg.

31. Agnes Chan, Yair Frankel, and Yiannis Tsiounis. Easy come — easy go divisible
In Advances in Cryptology — EUROCRYPT’98, pages 561–575, Berlin,

cash.
Heidelberg, 1998. Springer Berlin Heidelberg.

32. Fabrice Boudot. Eﬃcient proofs that a committed number lies in an interval. In
Advances in Cryptology — EUROCRYPT 2000, pages 431–444, Berlin, Heidelberg,
2000. Springer Berlin Heidelberg.

33. David Chaum and Torben Pryds Pedersen. Wallet databases with observers. In
Advances in Cryptology — CRYPTO’ 92, pages 89–105, Berlin, Heidelberg, 1993.
Springer Berlin Heidelberg.

34. David Chaum, Jan-Hendrik Evertse, and Jeroen van de Graaf. An improved proto-
col for demonstrating possession of discrete logarithms and some generalizations. In
Advances in Cryptology — EUROCRYPT’ 87, pages 127–141, Berlin, Heidelberg,
1988. Springer Berlin Heidelberg.

35. Jan Camenisch and Markus Michels. Proving in zero-knowledge that a number is
the product of two safe primes. In Advances in Cryptology — EUROCRYPT ’99,
pages 107–122, Berlin, Heidelberg, 1999. Springer Berlin Heidelberg.

36. Gavin Wood et al. Ethereum: A secure decentralised generalised transaction ledger.

Ethereum project yellow paper, 151(2014):1–32, 2014.

37. George Kappos, Haaroon Yousaf, Mary Maller, and Sarah Meiklejohn. An empiri-
cal analysis of anonymity in zcash. In 27th USENIX Security Symposium (USENIX
Security), pages 463–477, 2018.

38. Ian Miers, Christina Garman, Matthew Green, and Aviel D Rubin. Zerocoin:
Anonymous distributed e-cash from bitcoin. In 2013 IEEE Symposium on Security
and Privacy (SP), pages 397–411. IEEE, 2013.

39. Shen Noether. Ring signature conﬁdential transactions for monero. IACR Cryp-

tology ePrint Archive, 2015:1098, 2015.

40. Q-h Wu, J-h Zhang, and Y-m Wang. Simple proofs that a committed number is

in a speciﬁc interval. Acta Electronica Sinica, 32(7):1071–1073, 2004.

41. Shehar Bano et al. Sok: Consensus in the age of blockchains.

In Proceedings
of the 1st ACM Conference on Advances in Financial Technologies (AFT), pages
183–198, 2019.

42. Juan Garay and Aggelos Kiayias. Sok: A consensus taxonomy in the blockchain
era. In Cryptographers’ Track at the RSA Conference (CT-RSA), pages 284–318.
Springer, 2020.

43. Ziyuan Wang et al. Artchain: Blockchain-enabled platform for art marketplace. In
2019 IEEE International Conference on Blockchain (Blockchain), pages 447–454.
IEEE, 2019.

44. Christian Cachin and Marko Vukoli´c. Blockchain consensus protocols in the wild.

arXiv preprint arXiv:1707.01873, 2017.

23

45. Miguel Castro and Barbara Liskov. Practical byzantine fault tolerance. In Pro-
ceedings of the Third USENIX Symposium on Operating Systems Design and Im-
plementation (OSDI), pages 173–186, 1999.

46. Qin Wang et al. Security analysis on dbft protocol of neo. In International Con-
ference on Financial Cryptography and Data Security (FC), pages 20–31. Springer,
2020.

47. Maofan Yin et al. Hotstuﬀ: Bft consensus with linearity and responsiveness. In
Proceedings of the 2019 ACM Symposium on Principles of Distributed Computing
(PODC), pages 347–356. ACM, 2019.

48. Yackolley Amoussou-Guenou, Antonella Del Pozzo, Maria Potop-Butucaru, and
Sara Tucci-Piergiovanni. Correctness and fairness of tendermint-core blockchains.
arXiv preprint arXiv:1805.08429, 2018.

49. Yossi Gilad et al. Algorand: Scaling byzantine agreements for cryptocurrencies.
In Proceedings of the 26th Symposium on Operating Systems Principles (SOSP),
pages 51–68. ACM, 2017.

50. Qin Wang, Longxia Huang, et al. Blockchain enables your bill safer. IEEE Internet

of Things Journal, 2020.

51. Eiichiro Fujisaki and Tatsuaki Okamoto. Statistical zero knowledge protocols to
prove modular polynomial relations. In Advances in Cryptology — CRYPTO ’97,
pages 16–30, Berlin, Heidelberg, 1997. Springer Berlin Heidelberg.

52. Qin Wang, Jiangshan Yu, Shiping Chen, and Yang Xiang. Sok: Diving into dag-

based blockchain systems. arXiv preprint arXiv:2012.06128, 2020.

Appendix A: Proof for Theorems

8.1 Proof for Theorems 1

Proof (Anonymity) The proof proceeds via the following games. We set a se-
rious (cid:97)i where the adversary A interacts with a challenger C, as in the ANY ex-
periment. More precisely, we describe a sequence of games ((cid:97)real, (cid:97)1, (cid:97)2, (cid:97)3, (cid:97)4)
to show that AdvAN Y
Π,A (λ) is negligibly diﬀerent from that in the real experiment.
We deﬁne (cid:97)real to be the original experiment. We also deﬁne advver to be the
advantage in encryption’s experiment, advprf to be the advantage in distinguish-
ing the pseudo-random function prf from a random one, and advver to be the
advantage towards the hiding property of commitments.

Game (cid:97)1: The game (cid:97)1 modiﬁes (cid:97)real by replacing the ciphertexts with
the encryptions on random stings. We modify (cid:97)real so that C simulates each
encryption process. More speciﬁcally, once A outputs ciphertext c, there is c(cid:48) =
ε(pk, r) to be generated where r is the uniformly selected messages from the m
in plaintext space. By the Lemma 1, we get

|adv(cid:97)1 − adv(cid:97)real| ≤ negl(λ).

Game (cid:97)2: The game (cid:97)2 modiﬁes (cid:97)1 by calling the simulator to replace the
pms and all signatures of knowledge in commitment proofs. We modify (cid:97)1 so
that C simulates each commitment proofs. More precisely, instead of invoking
KeyGen(1λ, RV er, EV er), C invokes Sim = (1λ, RV er, EV er). For each invo-
cation of the veriﬁcation algorithm, C computes πver ← Sim(trap, m) without

24

using any witnesses. Since the commitment proof is perfect zero knowledge shown
in [51,3,31], the simulated proof πver in is identical to it computed in the real
experiment. Therefore, we get

|adv(cid:97)2 − adv(cid:97)1| ≤ negl(λ).

Game (cid:97)3: The game (cid:97)3 modiﬁes (cid:97)2 by confusing its addresses selection.
Intuitively, the game diﬀers from the previous one during the challenge phase
when the output address is chosen uniformly at random. More speciﬁcally, in
this game we set hi = hα
i−1, and the distribution parameter r is uniformly at
random. Thus, based on the hidden property with homomorphism, we get that

adv(cid:97)3 = adv(cid:97)2 .

Game (cid:97)4: We describe the game (cid:97)4 as follows. Set the b ∈ {0, 1} at random,
C samples pms ← KeyGen. As in the ANY experiment, C sends pms to A,
and then initialises two oracles OMAB
. C provides A two responses
separately in OMAB
for each step running in the experiment. Then
A sends to C a message (Q, Q(cid:48)) which contains two kinds of queries in the same
type. According to the query type q, C acts in slight diﬀerence:

and OMAB

and OMAB

1−b

1

2

b

qM int : Q = Q(cid:48) = M int(addac) = a

employ a random string ν to replace the apk in address,
the same does to Q(cid:48)

qEnc : Q = (Enc, pms, addac, m),
Q(cid:48) = (Enc, pms, add(cid:48)
ac, m)
employ cEnc = (ν||pms||m) instead of cEnc = (a||pms||m),
the same does to Q(cid:48)

qRV er : Q = (RV er, pms, addac, m),
Q(cid:48) = (RV er, pms, add(cid:48)
ac, m)

employ CR = (ν||pms||m) instead of CR = (a||pms||m),
the same does to Q(cid:48)

qEV er : Q = (EV er, pms, addac, m),
Q(cid:48) = (EV er, pms, add(cid:48)
ac, m)

employ CE = (ν||pms||m) instead of CE = (a||pms||m),
the same does to Q(cid:48)

It is clear that the response to A is independently of b ∈ {0, 1}. Therefore, A’s
advantage in (cid:97)4 is 0 since the view is no diﬀerence from b or b(cid:48) = 1 − b where
P r[b = b(cid:48)] = 1/2. So we get

|adv(cid:97)4 − adv(cid:97)3| ≤ negl(λ).

Lemma 1 Under the CCRA assumption, Game (cid:97)1 is computationally indis-
tinguishable from Game (cid:97)real. More precisely, for all PPT adversaries A and
suﬃciently large λ, it holds that

|adv(cid:97)1 − adv(cid:97)real| ≤ negl(λ)

25

where advEnc is the maximum of A’s advantage in the encryption scheme, and
qe represents encryption queries.

Proof Suppose that there exists an adversary A that can distinguish (cid:97)1 and
(cid:97)real with non-negligible probability. We can then design an eﬃcient distin-
guisher D to solve the CCRA problem [29]. CCRA represents the Computational
Composite Residuosity Assumption which states that: given c ∈ Z∗
n2 and n = pq,
there is no polynomial-time algorithm to successfully compute m in c = gmrn
mod n where m ∈ Zn and r ∈ Z∗
n2. The reduction from this to standard CCRA
assumption draws the conclusion of the indistinguishability.

Without loss of genarity, we assume that A makes at most qk and qe queries
to HKeyGen and HEnc respectively. For some j ∈ {1, ..., qk} when A makes the j-
th query of the HKeyGen, query the challenger to obtain the public keys (pk0, pk1)
in response to A. At the time A issues the qe query resulting in the ciphertext
ci under pk0, while query the challenger to get the ciphertext c(cid:48)
i = HEnc(pkb, m)
under pkb, where b is the bit chosen by challenger. A outputs b(cid:48) as a guess in
the experiment. When b = 0, A’s view of the interaction is identical to that of
(cid:97)real, while when b = 1, A’s view represents the intermediate simulator that the
key is substituted. Eventually, D outputs 1 if b(cid:48) = b.

We assume that advEnc is the maximum of A’s advantage in the encryption
scheme, Evt1 represents the ﬁrst event mention above while Evt2 towards the
second, then we can induce that

advEnc =|adv(cid:97)1 − adv(cid:97)real|

=P r[D(c) = 1|Evt1 ∧ Evt2] − P r[D(gmrn) = 1|Evt1 ∧ Evt2]

=

P r[D(c) = 1] − P r[D(gmrn) = 1]
P r[Evt1 ∧ Evt2]

=2qe · advCCRA
≤negl(λ)

D

Hence, under the CCRA assumption and the securities of building blocks in

each module, our protocol is anonymous as shown above.

8.2 Proof for Theorems 2

Proof (Non-malleability) Set T be the set of transactions generated by OMAB
in response to queries, recall that A wins the N-MAL experiment where there ex-
ists tx ∈ T satisﬁes: on input tx (cid:54)= tx(cid:48), then output V erif y(pms, tx(cid:48), pk) = 1.
To achieve the goal, a malicious attacker needs to 1) break the encryption system
by solving the hard problem of strong RSA after the KeyGen step, denoted as
EventRSA; 2) break the commitments by solving the hard problem of DL in Ver-
iﬁcation step, denoted as EventDL. To simulate the attack, we employ a random
RSA and a DL instance under the simulated games separately, such that if there
exists an adversary that can slander honest spending, then the designed protocol

26

can be reduced to the mathematical problem. We suppose there is an eﬃcient ad-
versary A that can break the non-malleability of our protocol with non-negligible
probability (cid:15). We can use A as a subroutine to design an eﬃcient algorithm A∗
to solve the hard problem in Gq.

EventRSA: The strong RSA problem states as follow: given an RSA modulus
n and a random element ν ∈ Z∗
n, it is hard to ﬁnd e > 1 and u such that z = ue.
Now, to reduce the EventRSA to the hard mathematic problem above, we simulate
the following interaction. Given the random strong RSA instance (N, u), the
algorithm A∗ selects (g, h) and the co-generated parameters (p, q) in Π1 as the
KeyGen, where the parameters can be set as (N, u, p, q, g, h). It generates the
(c1, ..., ck) in Π2 and Π3. To reduce the event of dishonesty, A∗ produces valid
j /∈ C by the extraction from π, note that j∗ ∈ [qa] is
output (π, CM ) and c(cid:48) = c∗
randomly picked by A∗. A extracts ω from π and employs the resulting value to
compute the solution of strong RSA instance. Here, we conclude the advantage
probability which states as follow

advEventRSA =qe · advRSA

≤qe · P r[advA(abort)] · P r[j∗ ∈ S ∩ S∗|abort] · P r[abort]
=qe · P r[advA ∧ j∗ ∈ S ∩ S∗|abort] · P r[abort]
≤qe · P r[A∗(m, (CM (cid:48)d)e) = m]
≤negl(λ)

EventDL: Given the random DL instance (h0, h1) where h1 = hα

0 , the algo-
rithm A∗ inputs pms by running the KeyGen. Then, A∗ randomly picks j∗ ∈ [qa]
and randomly selects xi ∈ Zq, so that the address can be driven as pki = [hxi
0 |i (cid:54)=
j∗] while pki = [hxi
1 |i = j∗]. Note that skj∗ = α · xj∗ inside the equation in the
revoking process. After the setting, A∗ simulates OMAB in the experiment. At
the end of the algorithm, A outputs (S, tx, π) and (S∗, tx∗, π∗). If A succeeds
in the experiment with the requirements 1) tx∗ (cid:54)= tx and S ∩ §∗ = ∅ , and 2)
V erif y(pms, tx∗, pk) = 1, it means A can solve the DL problem behind the al-
gorithm. Technically, check whether j∗ ∈ S ∩ S∗, outputs a random guess if it
not; otherwise, use the trapdoor to extract the valid witness (S∗, tx∗, π∗), where
it contains secret key skj∗ that pkj∗ = h∗
, so that α = skj∗ /xj∗ as the
DL solution of h1 to h0.

α·x∗
j
0 = h
0

Eventually, we suppose that A∗ succeeds to solve the DL problem, and set
abort as the event that A∗ aborts while abort as the complementary event. If
abort does not happen, the simulated experiment is the same the the real from
the A’s view. If j∗ ∈ S ∩ S∗, A∗ can successfully solve the discrete logarithm,
which obtains α from h1 = hα
0 . From the above, we reduce the EventDL to hard

27

problem and conclude its advantage probability as follows:

advEventDL =qa · advDL

≤qa · P r[advA(abort)] · P r[j∗ ∈ S ∩ S∗|abort] · P r[abort]
=qa · P r[advA ∧ j∗ ∈ S ∩ S∗|abort] · P r[abort]
≤qa · P r[advA ∧ j∗ ∈ S ∩ S∗]
≤qa · P r[A∗(h0, hα
≤negl(λ)

1 ) = α]

Hence, under the RSA and DL assumption, the protocol is non-malleable in

the random oracle.

8.3 Proof for Theorems 3

Proof (Balance) According to the requirements, the balance property contains
both range veriﬁcation and equality veriﬁcation. Intuitively, for each transaction,
A did not spend money more than the amount that A has, and the amount from
the receivers should match the senders. Formally, we deﬁne (cid:15) := AdvBAL
Π,A (λ),
and our goal is to show that (cid:15) is negligible in λ. The transactions induced by the
BAL experiment are balanced with all but non-negligible probability. Suppose, by
the way of contradiction, A can induce, with non-negligible probability, a trans-
action ledger that is not balanced. According to aforementioned requirements, we
show how to reach a contradiction via our commitment proofs and we explain
VerifyRange and VerifyEquality in sequence.

VerifyRange:
The receiver Bob was acknowledged by PK1 that

E1 = gyhr mod n
E2 = Eα
E3 = Eα

1 hr1 = gαyhαr+r1 mod n
2 hr2 = gα2yhα2r+αr1+r2 mod n

and was also acknowledged by PK2 that

so that

F = gωhr3 mod n
V = gv/E3 = gωh−rα2−r1α−r2 mod n

gv = V E3

= gωh−rα2−r1α−r2 gα2yhα2r+αr1+r2
= gα2y+ωh0
= gα2y+ω mod n

28

and from the equations we get

v = α2y + ω mod ϕ(n)

where ϕ(n) is a Totient function. Here, the sender Alice knows neither the fac-
torization of n nor the function ϕ(n). From the strong-RSA assumption, there
only exists v = α2y + ω. Since Bob has veriﬁed that v > 2t+l+s+T and convinces
from PK3 that

ω ∈ [−2t+l+s+T , 2t+l+s+T ],

so we get

y > 0.

Otherwise, if y < 0, we obtain

v = α2y + ω ≤ ω ≤ 2t+l+s+T

which contradicts to v > 2t+l+s+T in the RangeVer step.

From the above, we can prove y = mi − a > 0, and mi > a, where a = 0.
The correctness analysis can be applied to each mi for i ∈ {1, 2, ..., i}. Therefore,
vaddr→A (cid:62) 0 for each sender, and after that we go into the next:
VerifyEquality: From the veriﬁcation step [32], we can see

u = H(Wα||Wβ) = (gω

αhηα

α mod nα||gω

β hηβ

β mod nβ).

and if two committed numbers E and F are equal, we have:

u(cid:48) =H(gD

hurα+ηα
α

α E−u mod nα||gD

α hDα
=H(gum+ω
α
=H(gum+ω−um
α
α mod nα||gω
αhηα
=(gω

α hrα
hurα+ηα−urα
α
β hηβ

(gm

β mod nβ)

β hDβ

β F −u mod nβ)
α )−u mod nα||gum+ω

β hrβ
hurβ +ηβ
β
hurβ +ηβ −urβ
mod nα||gum+ω−um
β
β

(gm

β )−u mod nβ)
mod nβ)

β

=u.

and then, we focus on the operated ciphertext H and the committed number F
from Alice:

(cid:89)

H =

(cid:80) m(cid:48)
rnd
d mod n2
c(cid:48)
i = g
i
d
d
(cid:80) mi
(cid:80) mi
hrβ
β mod nβ = g
F = g
d
β

rnd
d mod n2

d

where rd = hβ , rβ = nd are randomly selected , and nβ = n2
generated above. If H equals to F where

d, and gd = gβ are

(cid:80) m(cid:48)
H = g
i
d

rnd
d mod n2

(cid:80) mi
d = g
d

rnd
d mod n2

d = F

we can clearly conclude that:

(cid:88)

m(cid:48)

i =

(cid:88)

mi = m

29

which means that the input-sum equals to the output-sum, and the veriﬁcation
turns to be equal. Otherwise, if the accounts that are either from the senders’ or
the receivers’ will be attacked by the A, the commitments H and F will change in
accumulation by the exponential operations, which leads to an inside signiﬁcant
diﬀerence as the contradiction. Therefore, vreward + vunspend + vaddr→A =
vA→addr + vself .

As shown above, the adversary A can neither steal coins from others by in-
putting a negative value nor attack the systems by changing the amounts in
dishonesty. Therefore, the proposed MAB system both passes the veriﬁcation of
range and equality, which ensures the balanced security of the system.

Appendix B: Skeleton of Blockchain

Blockchain can be regarded as a distributed ledger to record the activities in the
form of transactions, then these transactions are organized into a hierarchical
structure as a block, and last the blocks are arranged in an irreversibly ordered
sequence. Each block is guarded by cryptography techniques to provide a strong
guarantee of security. The way to compete for the rights of packaging transactions
relies on a series of rules called t the consensus mechanism. New blocks can only
be committed into the main chain when the consistency of decisions reaches.
Therefore, blockchain ensures that once a block is committed, the transaction
cannot be tampered with and compromised, and consequently the integrity and
correctness of the data recorded on transactions are guaranteed. Fig.2 provides
a skeleton of the blockchain-based system. This is the most prevailing structure
adopted by current blockchain systems [2][36][46][47][41]. Other structures such
as DAG-based blockchains systems refer to [52].

Fig. 2. Skeleton of the Blockchain-based System

Appendix C: System Workﬂow

30

Fig. 3. The sequence diagram of scheme instantiation: Users jointly generate their
threshold key-start parameters and then use them to encrypt the message on the
blockchain. After receiving the encrypted message, group members have to reach an
agreement to decrypt it. Note that we use U seri to represent the group members.

31

