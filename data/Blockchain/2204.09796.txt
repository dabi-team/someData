Distributed Runtime VeriÔ¨Åcation of Metric
Temporal Properties for Cross-Chain Protocols

Ritam Ganguly‚àó, Yingjie Xue‚Ä†, Aaron Jonckheere‚àó, Parker Ljung‚Ä†, Benjamin Schornstein‚Ä†,
Borzoo Bonakdarpour‚àó, and Maurice Herlihy‚Ä†
‚àóMichigan State University {gangulyr, jonckh16, borzoo}@msu.edu
‚Ä†Brown University {yingjie xue, parker ljung, benjamin schornstein, mph}@brown.edu

2
2
0
2

r
p
A
0
2

]

C
D
.
s
c
[

1
v
6
9
7
9
0
.
4
0
2
2
:
v
i
X
r
a

Abstract‚ÄîTransactions involving multiple blockchains are im-
plemented by cross-chain protocols. These protocols are based on
smart contracts, programs that run on blockchains, executed by a
network of computers. Because smart contracts can automatically
transfer ownership of cryptocurrencies, electronic securities,
and other valuable assets among untrusting parties, verifying
the runtime correctness of smart contracts is a problem of
compelling practical
interest. Such veriÔ¨Åcation is challenging
since smart contract execution is time sensitive, and the clocks
on different blockchains may not be perfectly synchronized. This
paper describes a method for runtime monitoring of blockchain
executions. First, we propose a generalized runtime veriÔ¨Åcation
technique for verifying partially synchronous distributed com-
putations for the metric temporal
logic (MTL) by exploiting
bounded-skew clock synchronization. Second, we introduce a
progression-based formula rewriting scheme for monitoring MTL
speciÔ¨Åcations which employs SMT solving techniques and report
experimental results.

I. INTRODUCTION

Blockchain technology [1], [2] is a blockbuster in this
era. It has drawn extensive attention from both industry and
academia. With blockchain technology, people can trade in
a peer-to-peer manner without mutually trusting each other,
removing the necessity of a trusted centralized party. The
concept of decentralization appears extremely appealing, and
the transparency, anonymity, and persistent storage provided
by blockchain make it more attractive. This revolutionary tech-
nology has triggered many applications in industry, ranging
from cryptocurrency [3], non-fungible tokens [4], internet of
things [5] to health services [6], etc.

Besides the huge success of cryptocurrencies known as
blockchain 1.0, especially Bitcoin [2], blockchain 2.0, known
as smart contracts [7], is also promising in many scenarios.
Smart contract is a program running on the blockchain. Its
execution is triggered automatically and enforced by condi-
tions preset in the code. In this way, the transfer of assets can
be automated by the rules in the smart contracts, and human
intervention cannot stop it. A typical smart contract implemen-
tation is provided by Ethereum [8], which uses Solidity [8],
which is a Turing-complete language. However, automating
the transactions by smart contracts also has its downsides.
If the smart contract has bugs and does not do what
is
expected, then lack of human intervention may lead to massive
Ô¨Ånancial losses. For example, as pointed out by [9], the Parity
Multisig Wallet smart contract [10] version 1.5 included a
vulnerability which led to the loss of 30 million US dollars.

Fig. 1: Hedged Two-party Swap

Thus, developing effective techniques to verify the correctness
of smart contracts is both urgent and important to protect
against possible losses. Furthermore, when a protocol is made
up of multiple smart contracts across different blockchains,
the correctness of protocols also need to be veriÔ¨Åed.

In this paper, we advocate for a runtime veriÔ¨Åcation (RV)
approach, to monitor the behavior of a system of blockchains
with respect to a set of temporal logic formulas. Applying RV
to deal with multiple blockchains can be reduced to distributed
RV, where a centralized or decentralize monitor observes the
behavior of a distributed system in which processes do not
share a global clock. Although RV deals with Ô¨Ånite executions,
the lack of a common global clock prohibits it from having
a unique ordering of events in a distributed setting. Put
it another way, the monitor can only form a partial order
of event which may result in different veriÔ¨Åcation verdicts.
Enumerating all possible ordering of events at run time incurs
in an exponential blow up, making the approach not scalable.
To add to this already complex task, most speciÔ¨Åcation for
verifying blockchain smart contracts, come with a time bound.
This means, not only the ordering of the events are at play
when verifying, but also the actual physical time of occurrence
of the event dictates the veriÔ¨Åcation verdict.

In this paper, we propose an effective, sound and complete
solution to distributed RV for timed speciÔ¨Åcations expressed
in the metric temporal logic (MTL) [11]. To present a high-
level view of MTL, consider the two-party swap protocol [4]
shown in Fig 1. Alice and Bob, each in possession of Apricot
and Banana blockchain assets respectively, wants to swap their
assets between each other without being a victim of sore-
loser attack. There is a number of requirements that should
be followed by conforming parties to discourage any attack

1

AliceBobApricot BlockchainBanana BlockchainEscrowùë•apricot coins‚Ñé,ùë°!Escrow ybanana coins‚Ñé,ùë°"Send  s:ùêªùë†=‚Ñéto redeemDeposit premium ùëù#+ùëù$Deposit premium ùëù$Send  s:ùêªùë†=‚Ñéto redeem 
 
 
 
 
 
Apr

Ban

SetUp

Deposit(pb)

1

3

Escrow(h, tA)
Apr

5

Redeem(bob)

7

SetUp

Deposit(pa + pb)

Escrow(h, tB)

Redeem(alice)

1

seg1

4

Ban

6

seg2

7

Fig. 2: Progression Example

on themselves. We use the metric temporal logic (MTL) [11]
to express such requirements. One such requirement, where
Alice should not redeem her asset before Bob within eight
time units can be represented by the MTL formula:

œïspec = ¬¨Apr.Redeem(bob) U [0,8)Ban.Redeem(alice).

We consider a fault proof central monitor which has the
complete view of the system but has no access to a global
clock. In order to limit the blow-up of states posed by the
absence of a global clock, we make a practical assumption
about the presence of a bounded clock skew (cid:15) between the
local clocks of every pair of processes. This is guaranteed by
a synchronization algorithm (e.g. NTP [12]). This setting is
known to be partially synchronous when we do not assume
any presence of a global clock and limit
the impact of
asynchrony within clock drifts. Such an assumption limits the
window of partial orders of events only within (cid:15) time units
and signiÔ¨Åcantly reduces the combinatorial blow-up caused
by nondeterminism due to concurrent. Existing distributed
RV techniques either assume a global clock when working
with time sensitive speciÔ¨Åcations [13], [14] or use untimed
speciÔ¨Åcations when assuming partial synchrony [15], [16].

We introduce an SMT1-based progression-based formula
rewriting technique over distributed computations which takes
into consideration the events observed thus far to rewrite the
speciÔ¨Åcations for future extensions. Our monitoring algorithm
accounts for all possible orderings of events without explicitly
generating them when evaluating MTL formulas. For example,
in Fig. 2, we see the events and the time of occurrence in
the two blockchains, Apricot(Apr) and Banana(Ban) divided
into two segments, seg1 and seg2 for computational purposes.
Considering maximum clock skew (cid:15) = 2 and the speciÔ¨Åcation
œïspec, at the end of the Ô¨Årst segment, we have two possible
rewritten formulas for the next segment:

œïspec1 = ¬¨Apr.Redeem(bob) U [0,4)Ban.Redeem(alice)
œïspec2 = ¬¨Apr.Redeem(bob) U [0,3)Ban.Redeem(alice)

This is possible due to the different ordering and different time
of occurrence of the events Deposit(pb) and Deposit(pa+
pb). In other words, the possible time of occurrence of the
event Deposit(pb) (resp. Deposit(pa + pb)) is either 2, 3
or 4 (resp. 3, 4, or 5) due to the maximum clock skew of 2.
Likewise, at the end of seg2, we have œïspec1 evaluate to true
where as œïspec2 evaluate to false. This is because, even if we

1SatisÔ¨Åability modulo theories (SMT) is the problem of determining
whether a formula involving Boolean expressions comprising of more complex
formulas involving real numbers, integers, and/or various data structures is
satisÔ¨Åable.

consider the scenario when Ban.Redeem(alice) occurs
before Apr.Redeem(bob), a possible time of occurrence
of Ban.Redeem(alice) is 8 (resp. 6) which makes œïspec2
(resp. œïspec1 ) evaluate to false (resp. true).

We have fully implemented our technique2 and report
the results of rigorous experiments on monitoring synthetic
data, using benchmarks in the tool UPPAAL [17], as well as
monitoring correctness, liveness and conformance conditions
for smart contracts on blockchains. We put our monitoring
algorithm to test studying the effect of different parameters on
the runtime and report on each of them. Using our technique
we learn not to use a value of ‚àÜ (transaction deadline) that is
comparable to the value of clock skew (cid:15) when designing the
smart contract.

Organization: Section II presents the background con-
cepts. Formal statement of our RV problem is discussed in
Section III. The formula progression rules and the SMT-based
solution are described in Sections IV and V, respectively,
while experimental results are analyzed in Section VI. Related
work is discussed in Section VII before we make concluding
remarks in Section VIII. The appendix includes more details
about our case studies.

II. PRELIMINARIES
In this section, we present an overview of the distributed

computations and the metric temporal logic (MTL).

A. Distributed Computation

We consider a loosely coupled asynchronous message pass-
ing system, consisting of n reliable processes (that do not
fail), denoted by P = {P1, P2, ¬∑ ¬∑ ¬∑ , Pn}. As a system, the
processes do not share any memory or have a common global
clock. Channels are assumed to be FIFO and lossless. In our
model, we represent each local state change by an event and a
message activity (send or receive) is represented by an event as
well. Message passing does not change the state of the process
and we disregard the content of the message as it is of no use
for our monitoring technique. Here, we refer to a global clock
which will act as the ‚Äúreal‚Äù timekeeper. It is to be noted that
the presence of this global clock is just for theoretical reasons
and it is not available to any of the individual processes.

We make an assumption about a partially synchronous
system. For each process Pi, where i ‚àà [1, n], the local clock
can be represented as a monotonically increasing function
: Z‚â•0 ‚Üí Z‚â•0, where ci(G) is the value of the local
ci
clock at global time G. Since we are dealing with discrete-
time systems, for simplicity and without loss of generality,
we represent time with non-negative integers Z‚â•0. For any
two processes Pi and Pj, where i (cid:54)= j, we assume:

‚àÄG ‚àà Z‚â•0. | ci(G) ‚àí cj(G) |< (cid:15),

where (cid:15) > 0 is the maximum clock skew. The value of (cid:15)
is constant and is known to the monitor. This assumption is
met by the presence of a clock synchronization algorithm, like
NTP [12], to ensure bounded clock skew among all processes.

2https://github.com/ritam9495/rv-mtl-blockc

2

We denote an event on process Pi by ei

œÉ, where œÉ = ci(G),
that is the local time of occurrence of the event at some global
time G.

DeÔ¨Ånition 1: A distributed computation consisting of n
processes is represented by the pair (E, (cid:32)), where E is a set
of events partially ordered by Lamport‚Äôs happened-before ((cid:32))
relation [18], subject to the partial synchrony assumption:

‚Ä¢ For every process Pi, 1 ‚â§ i ‚â§ n, all the events happening

on it are totally ordered, that is,

‚àÄœÉ, œÉ(cid:48) ‚àà Z‚â•0 : (œÉ < œÉ(cid:48)) ‚Üí (ei
œÉ

(cid:32) ei

œÉ(cid:48));

‚Ä¢ If e is a message sending event in a process and f is
the corresponding message receiving event in another
process, then we have e (cid:32) f ;

œÉ, ej

‚Ä¢ For any two processes Pi and Pj and two corresponding
œÉ(cid:48) ‚àà E, if œÉ + (cid:15) < œÉ(cid:48) then, ei
œÉ(cid:48), where
œÉ

events ei
(cid:15) is the maximum clock skew, and
‚Ä¢ If e (cid:32) f and f (cid:32) g, then e (cid:32) g. (cid:4)
DeÔ¨Ånition 2: Given a distributed computation (E, (cid:32)), a
subset of events C ‚äÜ E is said to form a consistent cut if
and only if when C contains an event e, then it should also
contain all such events that happened before e. Formally,

(cid:32) ej

‚àÄe ‚àà E.(e ‚àà C) ‚àß (f (cid:32) e) ‚Üí f ‚àà C. (cid:4)

The frontier of a consistent cut C, denoted by front(C) is
the set of all events that happened last in each process in the
cut. That is, front(C) is a set of ei
last for each i ‚àà [1, |P|] and
ei
last ‚àà C. We denote ei
last as the last event in Pi such that
œÉ (cid:54)= ei
œÉ ‚àà C.(ei
‚àÄei

last) ‚Üí (ei
œÉ
B. Metric Temporal Logic (MTL) [19], [20]

last).

(cid:32) ei

Let I be a set of nonempty intervals over Z‚â•0. We deÔ¨Åne

an interval, I, to be

[start, end ) (cid:44) {a ‚àà Z‚â•0 | start ‚â§ a < end }
where start ‚àà Z‚â•0, end ‚àà Z‚â•0 ‚à™ {‚àû} and start < end . We
deÔ¨Åne AP as the set of all atomic propositions and Œ£ = 2AP
as the set of all possible states. A trace is represented by a
pair which consists of a sequence of states, denoted by Œ± =
s0s1 ¬∑ ¬∑ ¬∑ , where si ‚àà Œ£ for every i > 0 and a sequence of non-
negative numbers, denoted by ¬ØœÑ = œÑ0œÑ1 ¬∑ ¬∑ ¬∑ , where œÑi ‚àà Z‚â•0
for all i > 0. We represent the set of all inÔ¨Ånite traces by a
pair of inÔ¨Ånite sets, (Œ£œâ, Zœâ
‚â•0). The trace sksk+1 ¬∑ ¬∑ ¬∑ (resp.
œÑkœÑk+1) is represented by Œ±k (resp. œÑ k). For an inÔ¨Ånite trace
Œ± = s0s1 ¬∑ ¬∑ ¬∑ and ¬ØœÑ = œÑ0œÑ1 ¬∑ ¬∑ ¬∑ , ¬ØœÑ is a increasing sequence,
meaning œÑi+1 ‚â• œÑi, for all i ‚â• 0.

Syntax.: The syntax of metric temporal logic (MTL) for

inÔ¨Ånite traces are deÔ¨Åned by the following grammar:

œï ::= p | ¬¨œï | œï1 ‚à® œï2 | œï1 U Iœï2

where p ‚àà AP and U I is the ‚Äòuntil‚Äô temporal operator with
time interval I. Note that other propositional and temporal
operators can be represented using the ones mentioned above.
For example, true = p ‚à® ¬¨p, false = ¬¨true, œï1 ‚Üí œï2 =
¬¨œï1 ‚à® œï2, œï1 ‚àß œï2 = ¬¨(¬¨œï1 ‚à® ¬¨œï2),
I œï = true U Iœï
I ¬¨œï) (‚Äúalways‚Äù). We denote
(‚Äúeventually‚Äù) and
the set of all MTL formulas by Œ¶MTL.

I œï = ¬¨(

3

Semantics: The semantics of metric temporal logic (MTL)
is deÔ¨Åned over the trace, Œ± = s0s1 ¬∑ ¬∑ ¬∑ and ¬ØœÑ = œÑ0œÑ1 ¬∑ ¬∑ ¬∑ as
follows:
(Œ±, ¬ØœÑ , i) |= p
(Œ±, ¬ØœÑ , i) |= ¬¨œï
(Œ±, ¬ØœÑ , i) |= œï1 ‚à® œï2
(Œ±, ¬ØœÑ , i) |= œï1 U Iœï2

iff p ‚àà si
iff
iff
iff ‚àÉj ‚â• i.œÑj ‚àí œÑi ‚àà I ‚àß (Œ±, ¬ØœÑ , j) |=
œï2 ‚àß ‚àÄk ‚àà [i, j), (Œ±, ¬ØœÑ , k) |= œï1

(Œ±, ¬ØœÑ , i) (cid:54)|= œï
(Œ±, ¬ØœÑ , i) |= œï1 ‚à® (Œ±, ¬ØœÑ , i) |= œï2

It is to be noted that (Œ±, ¬ØœÑ ) |= œï holds if and only if (Œ±, ¬ØœÑ , 0) |=
œï.

In the context of runtime veriÔ¨Åcation, we introduce the
notion of Ô¨Ånite MTL. The truth values are represented by the
set B2 = {(cid:62), ‚ä•}, where (cid:62) (resp. ‚ä•) represents a formula that
is satisÔ¨Åed (resp. violated) given a Ô¨Ånite trace. We represent
the set of all Ô¨Ånite traces by a pair of Ô¨Ånite sets, (Œ£‚àó, Z‚àó
‚â•0).
For a Ô¨Ånite trace, Œ± = s0s1 ¬∑ ¬∑ ¬∑ sn and ¬ØœÑ = œÑ0œÑ1 ¬∑ ¬∑ ¬∑ œÑn the only
semantic that needs to be redeÔ¨Åned is that of U (‚Äòuntil‚Äô) and
is as follows:

[(Œ±, ¬ØœÑ , i) |=F œï1 U Iœï2] =

Ô£±
Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£≥

(cid:62) if ‚àÉj ‚â• i.œÑj ‚àí œÑi ‚àà I

([Œ±j |=F œï2] = (cid:62)) ‚àß ‚àÄk ‚àà
[i, j) : ([Œ±k |=F œï1] = (cid:62))

‚ä• otherwise.

In order to further illustrate the difference between MTL and
Ô¨Ånite MTL, we consider the formula œï = I p and a trace Œ± =
s0s1 ¬∑ ¬∑ ¬∑ sn and ¬ØœÑ = œÑ0œÑ1 ¬∑ ¬∑ ¬∑ œÑn. We have [(Œ±, ¬ØœÑ ) |=F œï] = (cid:62)
if for some j ‚àà [0, n] we have œÑj ‚àí œÑ0 ‚àà I and p ‚àà si,
otherwise ‚ä•. Now, consider the formula œï = I p we have
[(Œ±, ¬ØœÑ ) |=F œï] = ‚ä• if for some j ‚àà [0, n] we have œÑj ‚àí œÑ0 ‚àà I
and p (cid:54)‚àà si, otherwise (cid:62).

III. FORMAL PROBLEM STATEMENT

In a partially synchronous system, there are different or-
dering of events that is possible and each unique ordering of
events [21] might evaluate to different verdicts. In other words,
a partially synchronous distributed computation (E, (cid:32)) may
have different ordering of events primarily due to the different
interleavings of events that is possible. Thus, it is possible to
have different verdicts for the same distributed computation
for the different ordering of events.

Let (E, (cid:32)) be a distributed computation. A sequence of
consistent cuts is of the form C0C1C2 ¬∑ ¬∑ ¬∑ , where for all i ‚â• 0,
we have (1) Ci ‚äÇ Ci+1 and (2) |Ci| + 1 = |Ci+1|, and (3)
C0 = ‚àÖ. The set of all sequences of consistent cuts be denoted
by C. We note that we view time interval I in the syntax of
MTL is in terms of the physical (global) time G. Thus, when de-
riving all the possible traces given the distributed computation
(E, (cid:32)), we have to account for all different orders in which
the events could possibly had occur with respect to G. This
involves replacing the local time of occurrence of an event, ei
œÉ
with the set of event {ei
œÉ(cid:48) | œÉ(cid:48) ‚àà [max{0, œÉ ‚àí (cid:15) + 1}, œÉ + (cid:15))}.
is
This is to account for the maximum clock drift
possible on the local clock of a process when compared
to the global clock. For example, given the computation in
Figure 3, a maximum clock skew (cid:15) = 2 and a MTL formula,

that

P1

P2

a
1

a
2

¬¨a
4

b
5

Fig. 3: Trace Example

œï = a U [0,6)b, one has to consider all possible traces including
(a, 1)(a, 2)(b, 4)(¬¨a, 5) |= œï and (a, 1)(a, 2)(¬¨a, 4)(b, 5) (cid:54)|=
œï. The contradictory result is due to the different time of
occurrence of event that needs to be considered.

Given a sequence of consistent cuts, it is evident that for
all j > 0, |Cj ‚àí Cj‚àí1| = 1 and event Cj ‚àí Cj‚àí1 is the last
event that was added onto the cut Cj. To translate monitoring
of a distributed system into monitoring a trace, We deÔ¨Åne a
sequence of natural numbers as ¬ØœÄ = œÄ0œÄ1 ¬∑ ¬∑ ¬∑ , where œÄ0 = 0
and for each j ‚â• 1, we have œÄj = œÉ, such that front(Cj) ‚àí
front(Cj‚àí1) = {ei
œÉ}. To maintain time monotonicity, we only
consider sequences where for all i ‚â• 0, œÄi+1 ‚â• œÄi.

The set of all traces that can be formed from (E, (cid:32)) is

deÔ¨Åned as:

Tr(E, (cid:32)) =

(cid:110)

front(C0)front(C1) ¬∑ ¬∑ ¬∑ | C0C1 ¬∑ ¬∑ ¬∑ ‚àà C

(cid:111)
.

In the sequel, we assume that every sequence Œ± of frontiers in
Tr(E, (cid:32)) is associated with a sequence ¬ØœÄ. Thus, to comply
with the semantics of MTL, we refer to the elements of
Tr(E, (cid:32)) by pairs of the form (Œ±, ¬ØœÄ). Now that we have a
set of all possible traces, we evaluate an MTL formula œï with
respect to the computation (E, (cid:32)) as follows:

[(E, (cid:32)) |=F œï] =

(cid:110)

(Œ±, ¬ØœÄ, 0) |=F œï | (Œ±, ¬ØœÄ) ‚àà Tr(E, (cid:32))

(cid:111)
.

This boils down to having a set of verdicts, since a dis-
tributed computation may involve several traces and each trace
might evaluate to a different verdict.

Overall Idea of our solution.: To solve the above problem
(evaluating all possible verdicts), we propose a monitoring
approach based on formula-rewriting (Section IV) and SMT
solving (Section V). Our approach involves iteratively(1) chop-
ping a distributed computation into a sequence of smaller
segments to reduce the problem size and (2) progress the MTL
formula for each segment for the next segment, which results
in a new MTL formula by invoking an SMT solver. Since each
computation/segment corresponds to a set of possible traces
due to partial synchrony, each invocation of the SMT solver
may result in a different verdict.

IV. FORMULA PROGRESSION FOR MTL

We start describing our solution by explaining the formula

progression technique.

DeÔ¨Ånition 3: A progression function is of the form Pr :
Œ£‚àó √ó Z‚àó
‚â•0 √ó Œ¶MTL ‚Üí Œ¶MTL and is deÔ¨Åned for all Ô¨Ånite
traces (Œ±, ¬ØœÑ ) ‚àà (Œ£‚àó, Z‚àó
‚â•0)
and MTL formulas œï ‚àà Œ¶MTL, such that (Œ±.Œ±(cid:48), ¬ØœÑ .¬ØœÑ (cid:48)) |= œï if
and only if (Œ±(cid:48), ¬ØœÑ (cid:48)) |= Pr(Œ±, ¬ØœÑ , œï). (cid:4)

‚â•0), inÔ¨Ånite traces (Œ±(cid:48), ¬ØœÑ (cid:48)) ‚àà (Œ£œâ, Zœâ

It

is to be noted that compared to the classic formula
regression technique in [22], here the function Pr takes a
Ô¨Ånite trace as input, while the algorithm in [22] rewrite the
formula after every observed state. When monitoring a par-
tially synchronous distributed system, where multiple verdicts
are possible and no unique ordering of events are possible,
the classical state-by-state formula rewriting technique is of
little use. The motivation of our approach comes from the fact
that for computation reasons, we chop the computation into
smaller segments and the veriÔ¨Åcation of each segment is done
through an SMT query. A state-by-state approach would incur
in a huge number of SMT queries being generated.

Let I = [start, end ) denote an interval. By I ‚àí œÑ ,
we mean the interval I (cid:48) = [start (cid:48), end (cid:48)), where start (cid:48) =
max{0, start ‚àí œÑ } and end (cid:48) = max{0, end ‚àí œÑ }. Also, for
two time instances, œÑi and œÑ0, we let InInt(i) return true or
false depending upon the whether œÑi ‚àí œÑ0 ‚àà I.

Progressing atomic propositions. For an MTL formula of the
form œï = p, where p ‚àà AP, the result depends on whether
or not p ‚àà Œ±(0). This marks as our base case for the other
temporal and logical operators:

Pr(Œ±, ¬ØœÑ , œï) =

(cid:40)

if p ‚àà Œ±(0)
true
false if p (cid:54)‚àà Œ±(0)

Progressing negation. For an MTL formula of the form œï =
¬¨œÜ, we have:

Pr(Œ±, ¬ØœÑ , œï) = ¬¨Pr(Œ±, ¬ØœÑ , œÜ).

Progressing disjunction. Let œï = œï1 ‚à® œï2. Apart from the
trivial cases, the result of progression of œï1 ‚à® œï2 is based on
progression of œï1 and/or progression of œï2:

Pr(Œ±, ¬ØœÑ , œï) =

true

false

œï(cid:48)
2

œï(cid:48)
1

1 ‚à® œï(cid:48)
œï(cid:48)
2

Ô£±

Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≥

if Pr(Œ±, ¬ØœÑ , œï1) = true ‚à®
Pr(Œ±, ¬ØœÑ , œï2) = true
if Pr(Œ±, ¬ØœÑ , œï1) = false ‚àß
Pr(Œ±, ¬ØœÑ , œï2) = false
if Pr(Œ±, ¬ØœÑ , œï1) = false ‚àß
Pr(Œ±, ¬ØœÑ , œï2) = œï(cid:48)
2
if Pr(Œ±, ¬ØœÑ , œï2) = false ‚àß
Pr(Œ±, ¬ØœÑ , œï1) = œï(cid:48)
1
if Pr(Œ±, ¬ØœÑ , œï1) = œï(cid:48)
Pr(Œ±, ¬ØœÑ , œï2) = œï(cid:48)
2

1 ‚àß

Always and eventually operators. As shown in Algorithms 1
and 2, the progression for ‚Äòalways‚Äô, ( I œï) and ‚Äòeventually‚Äô,
I œï) depends on the value of InInt(i) and the progression
(
of the inner formula œï. In Algorithm 1 and 2, we divide the
algorithm into three cases: (1) line 4, corresponds to if the I is
within the sequence ¬ØœÑ ; (2) line 6, corresponds to where I starts
in the current trace but its end is beyond the boundary of the
sequence ¬ØœÑ , and (3) line 9, corresponds to if the entire interval
I is beyond the boundary of sequence ¬ØœÑ . In Algorithm 1, we
are only concerned about the progression of œï on the sufÔ¨Åx
(Œ±i, ¬ØœÑ i) if InInt(i) = true. In case, InInt(i) = false the

4

Algorithm 1 Always

Algorithm 2 Eventually

i‚àà[0,|Œ±|]

1: function Pr(Œ±, ¬ØœÑ , I œï)
if Istart ‚â§ œÑ|Œ±| ‚àí œÑ0 then
2:
if Iend ‚â§ œÑ|Œ±| ‚àí œÑ0 then
3:
return (cid:86)
4:
else
5:
return (cid:86)
6:
end if
7:
else
8:
return [I‚àí(œÑ|Œ±|‚àíœÑ0)) œï
9:
end if
10:
11: end function

i‚àà[0,|Œ±|]

(cid:0)InInt(i) ‚Üí Pr(Œ±i, ¬ØœÑ i, œï)(cid:1)

(cid:0)InInt(i) ‚Üí Pr(Œ±i, ¬ØœÑ i, œï)(cid:1)‚àß [I‚àí(œÑ|Œ±|‚àíœÑ0)) œï

I œï)

i‚àà[0,|Œ±|]

1: function Pr(Œ±, ¬ØœÑ ,
if Istart ‚â§ œÑ|Œ±| ‚àí œÑ0 then
2:
if Iend ‚â§ œÑ|Œ±| ‚àí œÑ0 then
3:
return (cid:87)
4:
else
5:
return (cid:87)
6:
end if
7:
else
8:
return
9:
end if
10:
11: end function

[I‚àí(œÑ|Œ±|‚àíœÑ0)) œï

i‚àà[0,|Œ±|]

(cid:0)InInt(i) ‚àß Pr(Œ±i, ¬ØœÑ i, œï)(cid:1)
(cid:0)InInt(i) ‚àß Pr(Œ±i, ¬ØœÑ i, œÜ)(cid:1) ‚à® [I‚àí(œÑ|Œ±|‚àíœÑ0)) œï

Algorithm 3 Until

1: function Pr(Œ±, ¬ØœÑ , œï1 U I œï2)
if Istart ‚â§ œÑ|Œ±| ‚àí œÑ0 then
2:
if Iend ‚â§ œÑ|Œ±| ‚àí œÑ0 then
3:
return
else

i‚àà[0,|Œ±|]

(cid:16) (cid:86)

return

(cid:16) (cid:86)

4:
5:
6:

i‚àà[0,|Œ±|]
(cid:17)

œï1 U (I‚àí(œÑ|Œ±|‚àíœÑ0)œï2

end if
7:
else
8:
return (cid:0) (cid:86)
9:
end if
10:
11: end function

i‚àà[0,|Œ±|] Pr(Œ±i, ¬ØœÑ i, œï1)(cid:1) ‚àß œï1 U (I‚àí(œÑ|Œ±|‚àíœÑ0)œï2

(cid:0)(œÑi < Istart + œÑ0) ‚Üí Pr(Œ±i, ¬ØœÑ i, œï1)(cid:1)(cid:17)
(cid:0)(œÑi < Istart + œÑ0) ‚Üí Pr(Œ±i, ¬ØœÑ i, œï1)(cid:1)(cid:17)

(cid:16) (cid:87)

‚àß

j‚àà[0,|Œ±|]
(cid:16) (cid:87)

‚àß

(cid:0)InInt(j) ‚àß Pr(Œ±, ¬ØœÑ ,

[0,œÑj ‚àíœÑ0) œï1) ‚àß Pr(Œ±j , ¬ØœÑ j , œï2)(cid:1)(cid:17)

j‚àà[0,|Œ±|]

(cid:0)InInt(j) ‚àß Pr(Œ±, ¬ØœÑ ,

[0,œÑj ‚àíœÑ0) œï1) ‚àß Pr(Œ±j , ¬ØœÑ j , œï2)(cid:1) ‚à®

consequent drops and the entire condition equates to true.
In other words, equating over all i ‚àà [0, |Œ±|], we are only
left with conjunction of Pr(Œ±i, ¬ØœÑ i, œï) where InInt(i) = true.
In addition to this, we add the initial formula with updated
interval for the next trace. Similarly, in Algorithm 2, equating
over all i ‚àà [0, |Œ±|], if InInt(i) = false the corresponding
Pr(Œ±i, ¬ØœÑ i, œï) is disregarded and the Ô¨Ånal formula is a disjunc-
tion of Pr(Œ±i, ¬ØœÑ i, œï) with InInt(i) = true.

[0,œÑi‚àíœÑ0) œï1 (resp.

Progressing the until operator. Let the formula be of the form
œï1 U Iœï2. According to the semantics of until œï1 should be
evaluated to true in all states leading up to some i ‚àà I, where
œï2 evaluates to true. We start by progressing œï1 (resp. œï2) as
[œÑi,œÑi+1) œï2) for some i ‚àà I. Since, we
[œÑi,œÑi+1) œï2, on the trace
are only verifying the sub-formula,
sequence (Œ±, ¬ØœÑ ), it is equivalent to verifying the sub-formula
[0,1) œï2 ‚â° œï2 over the trace sequence (Œ±i, ¬ØœÑ i). Similar to
Algorithms 1 and 2, in Algorithm 3 we need to consider three
cases. In lines 4, 6 and 9, following the semantics of until
operator, we make sure for all i ‚àà [0, |Œ±|], if œÑi < Istart +
œÑ0, œï1 is satisÔ¨Åed in the sufÔ¨Åx (Œ±i, ¬ØœÑ i). In addition to this
there should be some j ‚àà [0, |Œ±|] for which if InInt(j) =
[0,œÑj ‚àíœÑ0) œï1
true, then the trace satisÔ¨Åes the sub-formula
[œÑj ,œÑj +1) œï2). In lines 6 and 9, we also accommodate
and
for future traces satisfying the formula œï1 U Iœï2 with updated
intervals.

Example: In Fig. 4, the time line shows propositions and
[0,6) r ‚Üí (¬¨p U [2,9)q).
their time of occurrence, for formula
The entire computation has been divided into 3 segments,
(Œ±, ¬ØœÑ ), (Œ±(cid:48), ¬ØœÑ (cid:48)), and (Œ±(cid:48)(cid:48), ¬ØœÑ (cid:48)(cid:48)) and each state has been repre-

5

(‚àÖ, 1)
0

(Œ±, ¬ØœÑ )

1
(‚àÖ, 2)

(‚àÖ, 3)
2

(Œ±(cid:48), ¬ØœÑ (cid:48))

(Œ±(cid:48)(cid:48), ¬ØœÑ (cid:48)(cid:48))

(‚àÖ, 4)
1

0
({r}, 3)

2
(‚àÖ, 5)

(‚àÖ, 6)
0

({p}, 7)
2

1
({q}, 7)

Fig. 4: Progression example.

sented by (s, œÑ ):

‚Ä¢ We start with segment (Œ±, ¬ØœÑ ). First we evaluate

[0,6) r,
which requires evaluating Pr(Œ±i, ¬ØœÑ i, r) for i ‚àà {0, 1, 2},
all of which returns the verdict false and there by
[0,4) r. Next, to evaluate
rewriting the sub-formula as
the sub-formula ¬¨p U [2,9)q, we need to evaluate (1)
Pr(Œ±i, ¬ØœÑ i, ¬¨p) for i ‚àà {0, 1} since œÑi ‚àí œÑ0 < 2 and
both evaluates to true, (2) Pr(Œ±, ¬ØœÑ ,
[0,2) ¬¨p) which also
evaluates to true and (3) Pr(Œ±2, ¬ØœÑ 2, q) which evaluates
as false. Thereby, the rewritten formula after observing
(Œ±, ¬ØœÑ ) is

[0,3) r ‚Üí (¬¨p U [0,6)q).

‚Ä¢ Similarly, we evaluate the formula now with respect to
(Œ±(cid:48), ¬ØœÑ (cid:48)), which makes the sub-formula
[0,3) r evaluate
to true at œÑ = 3 and the sub-formula ¬¨p U [0,6)q (there
is no such i ‚àà {0, 1, 2} where œÑi ‚àí œÑ0 < 0 and for all
j ‚àà {0, 1, 2}, Pr(Œ±(cid:48)j, ¬ØœÑ (cid:48)j, q) = false) is rewritten as
¬¨p U [0,4)q.

‚Ä¢ In (Œ±(cid:48)(cid:48), ¬ØœÑ (cid:48)(cid:48)), for j = 1, Pr(Œ±(cid:48)(cid:48), ¬ØœÑ (cid:48)(cid:48),

[0,2) ¬¨p) = true and
Pr(Œ±(cid:48)(cid:48)j, ¬ØœÑ (cid:48)(cid:48)j, q) = true, and thereby rewriting the entire
formula as true.

V. SMT-BASED SOLUTION

The sequence of consistent cuts starts from {} and ends at E.

A. SMT Entities

SMT entities represent (1) sub-formulas of the MTL spec-
iÔ¨Åcation, and (2) variables used to represent the distributed
computation. After we have the verdicts for each of the
individual sub-formulas, we use the progression laws dis-
cussed in Section IV to construct the formula for the future
computations.

Distributed Computation We represent a distributed compu-
tation (E, (cid:32)) by function f : E ‚Üí {0, 1, . . . , |E| ‚àí 1}. To
represent the happen-before relation, we deÔ¨Åne a E √ó E matrix
(cid:32) ej
œÉ][ej
œÉ(cid:48)] = 1 represents ei
called hbSet where hbSet[ei
œÉ
œÉ(cid:48)
œÉ, ej
œÉ][ej
for ei
œÉ(cid:48) ‚àà E. Also, if |œÉ ‚àí œÉ(cid:48)| ‚â• (cid:15) then hbSet[ei
œÉ(cid:48)] = 1,
else hbSet[ei
œÉ(cid:48)] = 0. This is all done in the pre-processing
phase of the algorithm and in the rest of the paper, we represent
events by the set E and a happen-before relation by (cid:32) for
simplicity.

œÉ][ej

In order to represent the possible time of occurrence of an

event, we deÔ¨Åne a function Œ¥ : E ‚Üí Z‚â•0, where

‚àÄei

œÉ ‚àà E.‚àÉœÉ(cid:48) ‚àà [max{0, œÉ ‚àí (cid:15) + 1}, œÉ + (cid:15) ‚àí 1].Œ¥(ei

œÉ) = œÉ(cid:48)

To connect events, E, and propositions, AP, on which the
MTL formula œï is constructed, we deÔ¨Åne a boolean function
¬µ : AP √ó E ‚Üí {true, false}. For formulas involving non-
boolean variables (e.g., x1 + x2 ‚â§ 7), we can update the func-
tion ¬µ accordingly. We represent a sequence of consistent cuts
that start from {} and end in E, we introduce an uninterpreted
function œÅ : Z‚â•0 ‚Üí 2E to reach a verdict given, it satisÔ¨Åes
all the constrains explained in V-B. Lastly, to represent the
sequence of time associated with the sequence of consistent
cuts, we introduce a function œÑ : Z‚â•0 ‚Üí Z‚â•0.

B. SMT Constrains

Once we have the necessary SMT entities, we move onto
including the constrains for both generating a sequence of
consecutive cuts and also representing the MTL formula as
a SMT constrain.

Consistent cut constrains over œÅ: In order to make sure the
sequence of cuts represented by the uninterpreted function œÅ,
is a sequence of consistent cuts, i.e., they follow the happen-
before relations between events in the distributed system:

‚àÄi ‚àà [0, |E|].‚àÄe, e(cid:48) ‚àà E.

(cid:16)

(e(cid:48) (cid:32) e)‚àß(cid:0)e ‚àà œÅ(i)(cid:1)(cid:17)

‚Üí (cid:0)e(cid:48) ‚àà œÅ(i)(cid:1)

Next, we make sure that in the sequence of consistent cuts,
the number of events present in a consistent cut is one more
than the number of events that were present in the consistent
cut before it:

‚àÄi ‚àà [0, |E|). | œÅ(i + 1) |=| œÅ(i) | +1

Next, we make sure than in the sequence of consistent cuts,
each consistent cut includes all the events that were present in
the consistent cut before it, i.e, it is a subset of the consistent
cut prior in the sequence.

‚àÄi ‚àà [0, |E|].œÅ(i) ‚äÇ œÅ(i + 1)

6

œÅ(0) = ‚àÖ; œÅ(|E|) = E

The sequence of time reÔ¨Çects the time of occurrence of the
event that has just been added to the sequence of consistent
cut:

‚àÄi ‚â• 1.œÑ (i) = Œ¥(ei

œÉ), such that œÅ(i) ‚àí œÅ(i ‚àí 1) = {ei

œÉ}

And Ô¨Ånally, we make sure the monotonosity of time is
maintained in the sequence of time

‚àÄi ‚àà [0, |E|).œÑ (i + 1) ‚â• œÑ (i)

Constrains for MTL formulas over œÅ: These constrains will
make sure that œÅ will not only represent a valid sequence
of consistent cuts but also make sure that
the sequence
of consistent cuts satisfy the MTL formula. As is evident,
a distributed computation can often yield two contradicting
evaluation. Thus, we need to check for both satisfaction
and violation for all the sub-formulas in the MTL formula
provided. Note that monitoring any MTL formula using our
progression rules will result in monitoring sub-formulas which
are atomic propositions, eventually and globally temporal
operators. Below we mention the SMT constrain for each
of the different sub-formula. Violation (resp. satisfaction) for
atomic proposition and eventually (resp. globally) constrain
will be the negation of the one mentioned.

œï = p

(cid:95)

e‚ààfront(œÅ(0))

¬µ[p, e] = true, for p ‚àà AP

œï = I œï

œï = I œï

(satisfaction, i.e., (cid:62))
‚àÉi ‚àà [0, |E|].œÑ (i) ‚àí œÑ (0) ‚àà I ‚àß œÅ(i) (cid:54)|= œï
(violation, i.e., ‚ä•)
‚àÉi ‚àà [0, |E|].œÑ (i) ‚àí œÑ (0) ‚àà I ‚àß œÅ(i) |= œï
(satisfaction, i.e., (cid:62))

A satisÔ¨Åable SMT instance denotes that
the uninterpreted
function was not only able to generate a valid sequence of
consistent cuts but also that the sequence satisÔ¨Åes or violates
the MTL formula given the computation. This result is then
fed to the progression cases to generate the Ô¨Ånal verdict.

C. Segmentation and Parallelization of Distributed Computa-
tion

We know that predicate detection, let alone runtime veriÔ¨Å-
cation, is NP-complete [23] in the size of the system (number
of processes). This complexity grows to higher classes when
working with nested temporal operators. To make the problem
computationally viable, we aim to chop the computation,
(E, (cid:32)) into g segments, (seg1, (cid:32)), (seg2, (cid:32)), ¬∑ ¬∑ ¬∑ , (segg, (cid:32)).
This involves creating small SMT-instances for each of the
segments which improves the runtime of the overall problem.
In a computation of length l, if we were to chop it into g
segments, each segment would of the length l
g + (cid:15) and the set
of events included in it can be given by:

segj =

(cid:110)

ei
œÉ | œÉ ‚àà

i ‚àà [1, | P |]

(cid:20)
max(cid:0)0,
(cid:111)

(j ‚àí 1) √ó l
g

‚àí (cid:15)(cid:1),

(cid:21)

‚àß

j √ó l
g

Note that monitoring of a segment should include the events
that happened within (cid:15) time of the segment actually starting
since it might include events that are concurrent with some
other events in the system not accounted for in the previous
segment.

VI. CASE STUDY AND EVALUATION
In this section, we analyze our SMT-based solution. We
note that we are not concerned about data collections, data
transfer, etc, as given a distributed setting, the runtime of the
actual SMT encoding will be the most dominating aspect of the
monitoring process. We evaluate our proposed solution using
traces collected from benchmarks of the tool UPPAAL [17]3
models (Section VI-A) and a case study involving smart
contracts over multiple blockchains (Section VI-B).

A. UPPAAL Benchmarks

1) Setup: We base our synthetic experiments on 3 different
UPPAAL benchmark models described in [24]. The Train Gate
models a railway control system which controls access to a
bridge. The bridge is controlled by a gate/operator and can be
accessed by one train at a time. We monitor two properties:

(cid:94)

œï1 = (

i‚ààP
(cid:94)

œï2 =

¬¨Train[i].Cross) U Train[1].Cross

(cid:0)Train[i].Appr ‚Üí

i‚ààP

(Gate.Occ U Train[i].Cross)(cid:1)

where P is the set of trains.

Fischer‚Äôs Protocol is a mutual exclusion protocol for n
processes. We verify Ô¨Årst, that no two process (P) enter the
critical section (cs) at the same time and second, all request
(req) should be followed by the processes able to access the
critical section within some time.

œï3 = (

œï4 = (

(cid:88)

i‚ààP
(cid:94)

i‚ààP

P[i].cs ‚â§ 1)

P[i].req ‚Üí I P[i].cs)

The Gossiping People is a model consisting of n people
who wish to share their secret with each other. We monitor
Ô¨Årst, that each Person gets to know about everyone else‚Äôs
secret within some time bound and second, each Person
has secrets to share inÔ¨Ånitely often.

(cid:94)

i,j‚ààP

(i (cid:54)= j) ‚Üí Person[i].secret[j])

(

I Person[i].secrets)

œï5 = I(

œï6 =

(cid:94)

i‚ààP

3UPPAAL is a model checker for a network of timed automata. The tool-
set is accompanied by a set of benchmarks for real-time systems. Here, we
assume that the components of the network are partially synchronized.

7

Each experiment involves two steps: (1) distributed com-
putation/trace generation and (2) trace veriÔ¨Åcation. For each
UPPAAL model, we consider each pair of consecutive events
are 0.1s apart, i.e., there are 10 events per second per process.
For our veriÔ¨Åcation step, our monitoring algorithm executes
on the generated computation and veriÔ¨Åes it against an MTL
speciÔ¨Åcation. We consider the following parameters (1) pri-
mary which includes time synchronization constant ((cid:15)), (2)
MTL formula under monitoring, (3) number of segments (g),
(3) computation length (l), (4) number of processes in the
system (P), and (5) event rate. We study the runtime of our
monitoring algorithm against each of these parameters. We
use a machine with 2x Intel Xeon Platinum 8180 (2.5 Ghz)
processor, 768 GB of RAM, 112 vcores with gcc version 9.3.1.
2) Analysis: We now study each of the parameters individ-
ually and analyze how it effects the runtime of our monitoring
approach. All results correspond to (cid:15) = 15ms, |P| = 2,
g = 15, l = 2sec, a event rate of 10events/sec and œï4 as the
speciÔ¨Åcation unless mentioned otherwise.

Impact of different formula. Fig. 5a shows that runtime
of the monitor depends on two factors: the number of sub-
formulas and the depth of nested temporal operators. Com-
paring œï3 and œï6, both of which consists of the same number
of predicates but since œï6 has recursive temporal operators,
it takes more time to verify and the runtime is comparable to
œï1, which consists of two sub-formulas. This is because veri-
Ô¨Åcation of the inner temporal formula often requires observing
states in the next segment in order to come to the Ô¨Ånal verdict.
This accounts for the more runtime for the monitor.

Impact of epsilon. Increasing the value of time synchro-
nization constant ((cid:15)), increases the possible number of con-
current events that needs to be considered. This increases
the complexity of verifying the computation and there-by
increasing the runtime of the algorithm. In addition to this,
higher values of (cid:15) also correspond to more number of possible
traces that are possible and should be taken into consideration.
We observe that
the runtime increases exponentially with
increasing the time synchronization constant in Fig. 5b. An
the
interesting observation is with longer segment
runtime increases at a higher rate than with shorter segment
length. This is because with longer segment length and higher
(cid:15), it equates to a larger number of possible traces that the
monitoring algorithm needs to take into consideration. This
increases the overall runtime of the veriÔ¨Åcation algorithm by
a considerable amount and at a higher pace.

length,

Impact of segment frequency. Increasing the segment fre-
quency makes the length of each segment lower and thus
verifying each segment
involves consideration of a lower
number of events. We observe the effect of segment frequency
on the runtime of our veriÔ¨Åcation algorithm in Fig. 5c. With
increasing the segment frequency, the runtime decreases unless
it reaches a certain value (here it is ‚âà 0.6) after which the
beneÔ¨Åt of working with a lower number of events is overcast
by the time required to setup each SMT instances. Working

500

100

50

10

5

1

500

100

50

10

5

1

)
s
(

e
m

i
t
n
u
R

)
s
(

e
m

i
t
n
u
R

œï1œï2œï3œï4œï5œï6

1

2

4

3
Number of Processes |P|

7

5

g = 40
g = 25
g = 20
g = 15
g = 12
g = 10
g = 8
g = 7

)
s
(

e
m

i
t
n
u
R

500

100

50

10

5

1

10

0.5

1

2
Time Synchronization Constant (cid:15)(s)

2.5

1.5

3

(a) Different Formula

(b) Epsilon

|P| = 1; œï6
|P| = 1; œï4
|P| = 2; œï6
|P| = 2; œï4
|P| = 3; œï6
|P| = 3; œï4
|P| = 4; œï6
|P| = 4; œï4

500

100

50

10

5

1

)
s
(

e
m

i
t
n
u
R

3.5

0.25

0.5

0.75

1

1.25

1.5

1.75

2

Segment Frequency (sec‚àí1)

(c) Segment Frequency

|P| = 1; œï6
|P| = 1; œï4
|P| = 2; œï6
|P| = 2; œï4
|P| = 3; œï6
|P| = 3; œï4
|P| = 4; œï6
|P| = 4; œï4

|P| = 1; œï6
|P| = 1; œï4
|P| = 2; œï6
|P| = 2; œï4
|P| = 3; œï6
|P| = 3; œï4
|P| = 4; œï6
|P| = 4; œï4

)
s
(

e
m

i
t
n
u
R

500

100
50

10
5

1

|P| = 1; œï6
|P| = 1; œï4
|P| = 2; œï6
|P| = 2; œï4
|P| = 3; œï6
|P| = 3; œï4
|P| = 4; œï6
|P| = 4; œï4

500

100

50

)
s
(

e
m

i
t
n
u
R

10

5

10

20

30

40

50

Computation length (l)

1

2

3

No. of solutions (/segment)

4

5

7

9

11

13

15

Event Rate (event/sec)

(d) Computation Length

(e) Number of Process

(f) Event Rate

Fig. 5: Impact of different parameters on synthetic data

with higher number of segments equates to solving more
number of SMT problem for the same computation length.
Setting up the SMT problem requires a considerable amount
of time which is seen by the slight increase in runtime for
higher values of segment frequency.

Impact of computation length. As it can be inferred from the
previous results, the runtime of our veriÔ¨Åcation algorithm is
majorly dictated by the number of events in the computation.
Thus, when working with a longer computation, keeping the
maximum clock skew and the number of segments constant,
we should see a longer veriÔ¨Åcation time as well. Results in
Fig. 5d makes the above claim true.

Impact of number truth values per segment. In order to take
into consideration all possible truth values of a computation,
we execute the SMT problem multiple times, with the verdict
of all previous executions being added to the SMT problem
such that no two verdict is repeated. Here in Fig. 5e we see
that the runtime is linearly effected by increasing number
of distinct verdicts. This is because, the complexity of the
problem that the SMT is trying to solve does not change when
trying to evaluate to a different solution.

Impact of event-rate. Increasing the event rate involves more
number of events that needs to be processes by our veriÔ¨Åcation
algorithm per segment and thereby increasing the runtime at
an exponential rate as seen in Fig. 5f. We also observe that
with higher number of processes, the rate at which the runtime

of our algorithm increases is higher for the same increase in
event rate.

B. Blockchain

1) Setup: We implemented the following cross-chain proto-
cols from [25]: two-party swap, multi-party swap, and auction.
The protocols were written as smart contracts in Solidity and
tested using Ganache, a tool that creates mocked Ethereum
blockchains. Using a single mocked chain, we mimicked
cross-chain protocols via several (discrete) tokens and smart
contracts, which do not communicate with each other.

We use the hedged two-party swap example from [25] to
describe our experiments. The implementation of the other two
protocols are similar. Suppose Alice would like to exchange
her apricot tokens with Bob‚Äôs banana tokens, using the hedged
two-party swap protocol shown in Fig. 1. This protocol pro-
vides protection for parties compared to a standard two-party
swap protocol [26], in that if one party locks their assets to
exchange which is refunded later, this party gets a premium
as compensation for locking their assets. The protocol consists
of six steps to be executed by Alice and Bob in turn. In our
example, we let the amount of tokens they are exchanging
be 100 ERC20 tokens and the premium pb be 1 token and
pa + pb be 2 tokens. We deploy two contracts on both apricot
blockchain(the contract is denoted as ApricotSwap) and ba-
nana blockchain (denoted as BananaSwap) by mimicking the
two blockchains on Ethereum. Denote the time that they reach
an agreement of the swap as startT ime. ‚àÜ is the maximum

8

time for parties to observe the state change of contracts by
others and take a step to make changes on contracts. In our
experiment, ‚àÜ = 500 milliseconds. By the deÔ¨Ånition of the
protocol, the execution should be:

‚Ä¢ Step 1. Alice deposits 2 tokens as premium in

BananaSwap before ‚àÜ elapses after startT ime .

‚Ä¢ Step 2. Bob should deposit 1 token as premium in

ApricotSwap before 2‚àÜ elapses after startT ime.

‚Ä¢ Step 3. Alice escrows her 100 ERC20 tokens to

ApricotSwap before 3‚àÜ elapses after startT ime.
‚Ä¢ Step 4. Bob escrows her 100 ERC20 tokens
BananaSwap before 4‚àÜ elapses after startT ime.
‚Ä¢ Step 5. Alice sends the preimage of the hashlock to
BananaSwap to redeem Bob‚Äôs 100 tokens before 5‚àÜ
elapses after startT ime. Premium is refunded.

to

‚Ä¢ Step 6. Bob sends the preimage of the hashlock to
ApricotSwap to redeem Alice‚Äôs 100 tokens before 6‚àÜ
elapses after startT ime. Premium is refunded.

If all parties all conforming, the protocol is executed as
above. Otherwise, some asset refund and premium redeem
events will be triggered to resolve the case where some party
deviates. To avoid distraction, we do not provide details here.
Each smart contract provides functions to let parties
deposit premiums DepositPremium(), escrow an as-
set EscrowAsset(), send a secret
to redeem assets
RedeemAsset(), refund the asset if it is not redeemed after
timeout, RefundAsset(), and counterparts for premiums
RedeemPremium() and RefundPremium(). Whenever
a function is called successfully (meaning the transaction sent
to the blockchain is included in a block),
the blockchain
emits an event
that we then capture and log. The event
interface is provided by the Solidity language. For example,
when a party successfully calls DepositPremium(), the
PremiumDeposited event emits on the blockchain. We
then capture and log this event, allowing us to view the values
of PremiumDeposited‚Äôs declared Ô¨Åelds: the time when it
emits, the party that called DepositPremium(), and the
amount of premium sent. Those values are later used in the
monitor to check against the speciÔ¨Åcation.

2) Log Generation and Monitoring: Our tests simulated
different executions of the protocols and generated 1024,
4096, and 3888 different sets of logs for the aforementioned
protocols, respectively. We use the hedged two-party swap
as an example to show how we generate different logs to
simulate different execution of the protocol. On each contract,
we enforce the order of those steps to be executed. For
example, step 3 EscrowAsset() on the ApricotSwap
cannot be executed before Step 1 is taken, i.e. the premium
is deposited. This enforcement in the contract restricted the
number of possible different states in the contract. Assume we
use a binary indicator to denote whether a step is attempted
by the corresponding party. 1 denotes a step is attempted,
and 0 denotes this step is skipped. If the previous step is
skipped, then the later step does not need to be attempted
since it will be rejected by the contract. We use an array
to denote whether each step in taken for each contract. On

9

each contract, the different execution of those steps can be
[1,1,1] means all steps are attempted, or [1,1,0] meaning the
last step is skipped, and so on. Each chain has 4 different
executions. We take the Cartesian product of arrays of two
contracts to simulate different combinations of executions on
two contracts. Furthermore, if a step is attempted, we also
simulate whether the step is taken late, or in time. Thus
we have 26 possibilities of those 6 steps. In summary, we
succeeded generating 4 ¬∑ 4 ¬∑ 26 = 1024 different logs.

In our testing, after deploying the two contracts, we it-
erate over a 2D array of size 1024 √ó 12, and each time
takes one possible execution denoted as an array length of
12 to simulate the behavior of participants. For example,
[1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] means the Ô¨Årst step is attempted
however it is late, and the steps after second step are all
attempted in time. Indexed from 0, the even index denotes
if a step is attempted or not and the odd index denotes the
former step is attempted in time or late. By the indicator given
by the array, we let parties attempt to call a function of the
contract or just skip. In this way, we produce 1024 different
logs containing the events emitted in each iteration.

We check the policies mentioned in [25]: liveness, safety,
sore loser attacks. Live-
and ability to hedge against
ness means that Alice should deposit her premium on
the banana blockchain within ‚àÜ from when the swap
[0,‚àÜ) ban.premium_deposited(alice)) and
started(
then Bob should deposit his premiums, and then they escrow
their assets to exchange, redeem their assets (i.e. the assets
are swapped), and the premiums are refunded. In our testing,
we always call a function to settle all assets in the contract
if the asset transfer is triggered by timeout. Thus, in the
speciÔ¨Åcation, we also check all assets are settled:

œïliveness = [0,‚àÜ) ban.premium_deposited(alice)‚àß

[0,2‚àÜ) apr.premium_deposited(bob)‚àß
[0,3‚àÜ) apr.asset_escrowed(alice)‚àß
[0,4‚àÜ) ban.asset_escrowed(bob)‚àß
[0,5‚àÜ) ban.asset_redeemed(alice)‚àß
[0,6‚àÜ) apr.asset_redeemed(bob)‚àß
[0,5‚àÜ) ban.premium_refunded(alice)‚àß
[0,6‚àÜ) apr.premium_refunded(bob)‚àß
[6‚àÜ,‚àû) apr.all_asset_settled(any)‚àß
[5‚àÜ,‚àû) ban.all_asset_settled(any)

to protect

Safety is provided only for conforming parties, since if one
party is deviating and behaving unreasonably, it is out of
them. Alice should
the scope of the protocol
always deposit her premium Ô¨Årst to start the execution of the
protocol(
and proceed if Bob proceeds with the next step. For
then Alice
example,
should
to
asset
[0,2‚àÜ) apr.premium_deposited(bob) ‚Üí
exchange(
[0,3‚àÜ) apr.asset_escrowed(alice)). Alice should

[0,‚àÜ) ban.premium_deposited(alice))

premium,
escrow her

deposits
ahead

his
and

if Bob

always

go

2-party swap; g = 1
3-party swap; g = 2
aunction; g = 2

500

100
50

10
5

1

)
s
(

e
m

i
t
n
u
R

4

8

12
No. of events

16

20

24

28

Fig. 6: Blockchain Experiments

never release her secret if she does not redeem, which means
Bob should not be able to redeem unless Alice redeems,
which is expressed as ¬¨apr.asset_redeemed(bob) U
ban.asset_redeemed(alice):

œïalice conform = [0,‚àÜ) ban.premium_deposited(alice)‚àß

(cid:0)

(cid:0)

[0,2‚àÜ) apr.premium_deposited(bob) ‚Üí
[0,3‚àÜ) apr.asset_escrowed(alice)(cid:1) ‚àß
[0,4‚àÜ) ban.asset_escrowed(bob) ‚Üí
[0,5‚àÜ) ban.asset_redeemed(alice)(cid:1) ‚àß

(cid:0)¬¨apr.asset_redeemed(bob) U

ban.asset_redeemed(alice)(cid:1)

By deÔ¨Ånition, safety means a conforming party does not end
up with a negative payoff. We track the assets transferred
from parties and transferred to parties in our logs. Thus,
a conforming party is safe. e.g. Alice, is speciÔ¨Åed as the
œïalice saf ety:

œïalice safety =œïalice conform ‚Üí

(cid:0) (cid:88)

amount ‚â•

(cid:88)

amount(cid:1)

TransTo = alice

TransFrom = alice

To enable a conforming party to hedge against the sore loser
attack if they escrow assets to exchange which is refunded
in the end, our protocol should guarantee the aforementioned
party get a premium as compensation, which is expressed as
œïalice hedged:

œïalice hedged = (cid:0)œïalice conform‚àß

apr.asset_escrowed(alice)‚àß
apr.asset_refunded(any)(cid:1) ‚Üí

(cid:0)

(cid:88)

amount ‚â•

TransferTo = alice

(cid:88)

amount

TransferFrom = alice

+ apr.premium.amount(cid:1)

3) Analysis of Results: We put our monitor to test the traces
generated by the TrufÔ¨Çe-Ganache framework. To monitor the
2-party swap protocol we do not divide the trace into multiple
segments due to the low number of events that are involved

10

in the protocol. On the other hand both, 3-party swap and
auction protocol involves a higher number of events and thus
we divide the trace into two segments (g = 2). In Fig. 6,
we show how the runtime of the monitor is effected by the
number of events in each transaction log.

Additionally, we generate transaction logs with different
values for deadline (‚àÜ) and time synchronization constant ((cid:15))
to put the safety of the protocol in jeopardy. We observe both
true and false verdict when (cid:15) (cid:39) ‚àÜ. This is due to the
non deterministic time stamp owning to the assumption of
a partially synchronous system. The observed time stamp of
each event can at most be off by (cid:15). Thus, we recommend not
to use a value of ‚àÜ that is comparable to the value of (cid:15) when
designing the smart contract.

VII. RELATED WORK

Centralized and decentralized online predicate detection
in an asynchronous distributed system have been studies
in [27], [28]. Extensions to include temporal operators appear
in [29], [30]. The line of work in [27]‚Äì[31] considers a
fully asynchronous system. A SMT-based predicate detection
solution has been introduced in [32]. On the other hand,
runtime monitoring for synchronous distributed system has
been studied in [33]‚Äì[35]. This approach has shortcoming,
the major one being the assumption of a common global
clock shared among all the processes. Finally, fault-tolerant
monitoring, where monitors can crash, has been investigated
in [36] for asynchronous and in [37] for synchronized dis-
tributed processes.

Runtime monitoring of time sensitive distributed system
has been studied in [13], [14], [38], [39]. With the onset
of blockchains and the security vulnerability posed by smart
contracts have been studied in [40]‚Äì[44]. The major area that
these work lack is all of them consider the system to be
synchronous with the presence of a global clock. However,
smart contracts often include multiple blockchains and thus
we consider a partially synchronous system where a synchro-
nization algorithm limits the maximum clock skew among
processes to a constant. An SMT-based solution was studied
in [15], which we extend to include more expressive time
bounded logic.

VIII. CONCLUSION

In this paper, we study distributed runtime veriÔ¨Åcation.
We propose a technique which takes an MTL formula and
a distributed computation as input. By assuming partial syn-
chrony among all processes, Ô¨Årst we chop the computation
into several segments and then apply a progression-based
formula rewriting monitoring algorithm implemented as a
SMT decision problem in order to verify the correctness of the
distributed system with respect to the formula. We conducted
extensive synthetic experiments on trace generated by the
UPPAAL tool and a set of blockchain smart contracts.

For future work, we plan to study the trade off among
accuracy and scalability of our approach. Another important
extension of our work is distributed runtime veriÔ¨Åcation where

the processes are dynamic, i.e., the process can crash and
can also restore its state at any given time during execution.
This will let us study a wide range of applications including
airspace monitoring.

REFERENCES

[1] Y. Lu, ‚ÄúThe blockchain: State-of-the-art and research challenges,‚Äù Jour-
nal of Industrial Information Integration, vol. 15, pp. 80‚Äì90, 2019.
[2] S. Nakamoto, ‚ÄúBitcoin: A peer-to-peer electronic cash system,‚Äù Decen-

tralized Business Review, p. 21260, 2008.

[3] M. Herlihy, ‚ÄúAtomic cross-chain swaps,‚Äù in Proceedings of the 2018
ACM symposium on principles of distributed computing, 2018, pp. 245‚Äì
254.

[4] M. Herlihy, B. Liskov, and L. Shrira, ‚ÄúCross-chain deals and adversarial

commerce,‚Äù The VLDB Journal, pp. 1‚Äì19, 2021.

[5] K. Christidis and M. Devetsikiotis, ‚ÄúBlockchains and smart contracts for
the internet of things,‚Äù Ieee Access, vol. 4, pp. 2292‚Äì2303, 2016.
[6] J. Xu, K. Xue, S. Li, H. Tian, J. Hong, P. Hong, and N. Yu, ‚ÄúHealthchain:
A blockchain-based privacy preserving scheme for large-scale health
data,‚Äù IEEE Internet of Things Journal, vol. 6, no. 5, pp. 8770‚Äì8781,
2019.

[7] L. W. Cong and Z. He, ‚ÄúBlockchain disruption and smart contracts,‚Äù
The Review of Financial Studies, vol. 32, no. 5, pp. 1754‚Äì1797, 2019.
Springer, 2017, vol.

[8] C. Dannen, Introducing Ethereum and solidity.

318.

[9] J. Ellul and G. J. Pace, ‚ÄúRuntime veriÔ¨Åcation of ethereum smart
contracts,‚Äù in 2018 14th European Dependable Computing Conference
(EDCC).

IEEE, 2018, pp. 158‚Äì163.

[10] P. Technologies, As of 2017. [Online]. Available: https://github.com/

paritytech/parity

[11] R. Koymans, ‚ÄúSpecifying Real-Time Properties with Metric Temporal

Logic,‚Äù RealTime Systems, vol. 2, no. 4, pp. 255‚Äì299, 1990.

[12] D. Mills, ‚ÄúNetwork time protocol version 4: Protocol and algorithms
speciÔ¨Åcation,‚Äù Internet Requests for Comments, RFC Editor, RFC 5905,
June 2010.

[13] D. Basin, F. Klaedtke, S. M¬®uller, and E. ZÀòalinescu, ‚ÄúMonitoring metric
Ô¨Årst-order temporal properties,‚Äù J. ACM, vol. 62, no. 2, may 2015.
[Online]. Available: https://doi.org/10.1145/2699444

[14] J. Worrell, J. Ouaknine, and H.-M. Ho, ‚ÄúOn the expressiveness and
monitoring of metric temporal logic,‚Äù Logical Methods in Computer
Science, vol. 15, 2019.

[15] R. Ganguly, A. Momtaz, and B. Bonakdarpour, ‚ÄúDistributed Runtime
VeriÔ¨Åcation Under Partial Synchrony,‚Äù in 24th International Conference
on Principles of Distributed Systems (OPODIS 2020), vol. 184,
2021, pp. 20:1‚Äì20:17. [Online]. Available: https://drops.dagstuhl.de/
opus/volltexte/2021/13505

[16] A. Momtaz, N. Basnet, H. Abbas, and B. Bonakdarpour, ‚ÄúPredicate
monitoring in distributed cyber-physical systems,‚Äù in Proceedings of the
21st International Conference on Runtime VeriÔ¨Åcation (RV), 2021, pp.
3‚Äì22.

[17] K. G. Larsen, P.Pattersson, and W. Yi, ‚ÄúUPPAAL in a nutshell,‚Äù
International Journal on Software Tools for Technology Transfer, vol. 1,
no. 1-2, pp. 134‚Äì152, 1997.

[18] L. Lamport, ‚ÄúTime, clocks, and the ordering of events in a distributed
system,‚Äù Commun. ACM, vol. 21, no. 7, p. 558‚Äì565, jul 1978. [Online].
Available: https://doi.org/10.1145/359545.359563

[19] R. Alur and T. A. Henzinger, ‚ÄúLogics and models of real time: A survey,‚Äù
in Real-Time: Theory in Practice, J. W. de Bakker, C. Huizing, W. P.
de Roever, and G. Rozenberg, Eds. Berlin, Heidelberg: Springer Berlin
Heidelberg, 1992, pp. 74‚Äì106.

[20] ‚Äî‚Äî, ‚ÄúA really temporal logic,‚Äù J. ACM, vol. 41, no. 1, p. 181‚Äì203,

jan 1994. [Online]. Available: https://doi.org/10.1145/174644.174651

[21] A. Bauer and Y. Falcone, ‚ÄúDecentralised ltl monitoring,‚Äù in FM 2012:
Berlin,

Formal Methods, D. Giannakopoulou and D. M¬¥ery, Eds.
Heidelberg: Springer Berlin Heidelberg, 2012, pp. 85‚Äì100.

[22] K. Havelund and G. Rosu, ‚ÄúMonitoring programs using rewriting,‚Äù in
Proceedings of the 16th IEEE International Conference on Automated
Software Engineering, ser. ASE ‚Äô01. USA: IEEE Computer Society,
2001, p. 135.

[23] V. K. Garg, Elements of Distributed Computing. USA: John Wiley &

Sons, Inc., 2002.

[24] G. Behrmann, A. David, and K. G. Larsen, ‚ÄúA tutorial on UPPAAL,‚Äù in
Formal Methods for the Design of Real-Time Systems: 4th International
School on Formal Methods for the Design of Computer, Communication,
and Software Systems, SFM-RT 2004, no. 3185, 2004, pp. 200‚Äì236.

[25] Y. Xue and M. Herlihy, ‚ÄúHedging against sore loser attacks in cross-

chain transactions,‚Äù arXiv preprint arXiv:2105.06322, 2021.

[26] T. Nolan, ‚ÄúAlt chains and atomic transfers,‚Äù https://bitcointalk.org/index.

php?topic=193281.0, May, 2013, bitcoin Forum.

[27] H. Chauhan, V. K. Garg, A. Natarajan, and N. Mittal, ‚ÄúA distributed
abstraction algorithm for online predicate detection,‚Äù in Proceedings of
the 32nd IEEE Symposium on Reliable Distributed Systems (SRDS),
2013, pp. 101‚Äì110.

[28] N. Mittal and V. K. Garg, ‚ÄúTechniques and applications of computation
slicing,‚Äù Distributed Computing, vol. 17, no. 3, pp. 251‚Äì277, 2005.

[29] V. A. Ogale and V. K. Garg, ‚ÄúDetecting temporal

logic predicates
on distributed computations,‚Äù in Proceedings of the 21st International
Symposium on Distributed Computing (DISC), 2007, pp. 420‚Äì434.
[30] M. Mostafa and B. Bonakdarpour, ‚ÄúDecentralized runtime veriÔ¨Åcation
of LTL speciÔ¨Åcations in distributed systems,‚Äù in Proceedings of the
29th IEEE International Parallel and Distributed Processing Symposium
(IPDPS), 2015, pp. 494‚Äì503.

[31] K. Sen, A. Vardhan, G. Agha, and G.Rosu, ‚ÄúEfÔ¨Åcient decentralized
monitoring of safety in distributed systems,‚Äù in Proceedings of the 26th
International Conference on Software Engineering (ICSE), 2004, pp.
418‚Äì427.

[32] V. T. Valapil, S. Yingchareonthawornchai, S. S. Kulkarni, E. Torng,
and M. Demirbas, ‚ÄúMonitoring partially synchronous distributed systems
using SMT solvers,‚Äù in Proceedings of the 17th International Conference
on Runtime VeriÔ¨Åcation (RV), 2017, pp. 277‚Äì293.

[33] L. M. Danielsson and C. S¬¥anchez, ‚ÄúDecentralized stream runtime
veriÔ¨Åcation,‚Äù in Proceedings of the 19th International Conference on
Runtime VeriÔ¨Åcation (RV), 2019, pp. 185‚Äì201.

[34] C. Colombo and Y. Falcone, ‚ÄúOrganising LTL monitors over distributed
systems with a global clock,‚Äù Formal Methods in System Design, vol. 49,
no. 1-2, pp. 109‚Äì158, 2016.

[35] B. Bonakdarpour and B. Finkbeiner, ‚ÄúRuntime veriÔ¨Åcation for hyper-
ltl,‚Äù in Proceedings of the 16th International Conference on Runtime
VeriÔ¨Åcation, 2016, pp. 41‚Äì45.

[36] B. Bonakdarpour, P. Fraigniaud, S. Rajsbaum, D. A. Rosenblueth,
and C. Travers, ‚ÄúDecentralized asynchronous crash-resilient runtime
veriÔ¨Åcation,‚Äù in Proceedings of the 27th International Conference on
Concurrency Theory (CONCUR), 2016, pp. 16:1‚Äì16:15.

[37] L. Lamport and N. Lynch, Handbook of Theoretical Computer Science.
Amsterdam: Elsevier Science Publishers B. V., 1990, vol. B, ch. 18:
Distributed Computing: Models and Methods.

[38] D. Basin, F. Klaedtke, and S. M¬®uller, ‚ÄúMonitoring security policies
with metric Ô¨Årst-order temporal logic,‚Äù in Proceedings of the 15th ACM
Symposium on Access Control Models and Technologies, ser. SACMAT
‚Äô10. New York, NY, USA: Association for Computing Machinery, 2010,
p. 23‚Äì34. [Online]. Available: https://doi.org/10.1145/1809842.1809849
[39] P. Thati and G. Ros¬∏u, ‚ÄúMonitoring algorithms for metric temporal logic
speciÔ¨Åcations,‚Äù Electron. Notes Theor. Comput. Sci., vol. 113, no. C, p.
145‚Äì162, jan 2005.

[40] A. Garc¬¥ƒ±a, E. Cambronero, C. Colombo, L. D¬¥ƒ±az, and G. Pace, Runtime
VeriÔ¨Åcation of Contracts with Themulus, 09 2020, pp. 231‚Äì246.
[41] S. Azzopardi, J. Ellul, and G. J. Pace, ‚ÄúRuntime monitoring processes
across blockchains,‚Äù in Fundamentals of Software Engineering, H. Hojjat
and M. Massink, Eds. Cham: Springer International Publishing, 2021,
pp. 142‚Äì156.

[42] S. Azzopardi, G. Pace, F. Schapachnik, and G. Schneider, ‚ÄúOn the
speciÔ¨Åcation and monitoring of timed normative systems,‚Äù in Runtime
VeriÔ¨Åcation, L. Feng and D. Fisman, Eds. Cham: Springer International
Publishing, 2021, pp. 81‚Äì99.

[43] X. Chen, D. Park, and G. Ros¬∏u, ‚ÄúA language-independent approach
to smart contract veriÔ¨Åcation,‚Äù in Leveraging Applications of Formal
Methods, VeriÔ¨Åcation and Validation. Industrial Practice, T. Margaria
and B. Steffen, Eds. Cham: Springer International Publishing, 2018,
pp. 405‚Äì413.

[44] D. Park, Y. Zhang, M. Saxena, P. Daian, and G. Ros¬∏u, ‚ÄúA
formal veriÔ¨Åcation tool for ethereum vm bytecode,‚Äù in Proceedings
of
the 2018 26th ACM Joint Meeting on European Software
Engineering Conference and Symposium on the Foundations of
Software Engineering, ser. ESEC/FSE 2018. New York, NY, USA:
Association for Computing Machinery, 2018, p. 912‚Äì915. [Online].
Available: https://doi.org/10.1145/3236024.3264591

11

IX. APPENDIX

Here, in Section IX-A we explain how the different UPPAAL
models work and in Section IX-B we dive into the MTL
speciÔ¨Åcations we use to verify 3-party swap and the auction
protocol.

A. UPPAAL Models

Below we explain in details how each of the UPPAAL
models work. In respect
to our monitoring algorithm, we
consider multiple instances of each of the models as different
processes. Each event consists of the action that was taken
along with the time of occurrence of the event. In addition to
this, we assume a unique clock for each instance, synchronized
by the presence of a clock synchronization algorithm with a
maximum clock skew of (cid:15).

a) The Train-Gate: It models a railway control system
which controls access to a bridge for several trains. The bridge
can be considered as a shared resource and can be accessed
by one train at a time. Each train is identiÔ¨Åed by a unique
id and whenever a new train appears in the system, it sends
a appr message along with it‚Äôs id. The Gate controller has
two options: (1) send a stop message and keep the train in
waiting state or (2) let the train cross the bridge. Once the
train crosses the bridge, it sends a leave message signifying
the bridge is free for any other train waiting to cross.

leave[id]

Safe

Cross

appr[id]

Appr

Start

stop[id]

go[id]

Stop

Fig. 7: Train model

The gate keeps track of the state of the bridge, in other
words the gate acts as the controller of the bridge for the trains.
If the bridge is currently not being used, the gate immediately
offers any train appearing to go ahead, otherwise it sends a
stop message. Once the gate is free from a train leaving
the bridge, it sends out a go message to any train that had
appeared in the mean time and was waiting in the queue.

12

go[front()]

Free

appr[e]

Occ

leave[id]

appr[e]

stop[tail()]

Fig. 8: Gate model

It

b) The Fischer‚Äôs Protocol:

is a mutual exclusion
protocol designed for n processes. A process always sends
in a request to enter the critical section (cs). On receiving the
request, a unique pid is generated and the process moves to a
wait state. A process can only enter into the critical section
when it has the correct id. Upon exiting the critical section,
the process resets the id which enables other processes to
enter the cs

A

id = 0

req

id = 0

id = pid

id = 0

id == pid

cs

wait

Fig. 9: Fischer model

Start

start()

exchange()

Call

talk()

listen()

Listen

Fig. 10: Gossiping people model

c) The Gossiping People: The model consists of n
people, each having a private secret they wish to share with
each other. Each person can Call another person and after
a conversation, both person mutually knows about all their
secrets. With respect to our monitoring problem, we make
sure that each person generates a new secret that needs to be
shared among others inÔ¨Ånitely often.

B. Blockchain

Below shows the speciÔ¨Åcations we used to verify the
correctness of hedged three-party swap and auction protocols,

as shown in [25]. The structure of the speciÔ¨Åcations are similar
to that of hedged two-party swap protocol.

a) Liveness: Below shows the speciÔ¨Åcation to liveness,

if all the steps of the protocol has been taken:

1) Hedged 3-Party Swap Protocol: The three-party swap
example we implemented can be described as a digraph where
there are directed edges between Alice, Bob and Carol. For
simplicity, we consider each party transfers 100 assets. Trans-
fer between Alice and Bob is called ApricotSwap, meaning
Alice proposes to transfer 100 apricot tokens to Bob, transfer
between Bob and Carol called BananaSwap, meaning Bob
proposes to transfer 100 banana tokens to Carol,
transfer
between Carol and Alice, called CherrySwap, meaning Carol
proposes to transfer 100 cherry tokens to Alice. Different
tokens are managed by different blockchains (Apricot, Banana
and Cherry respectively).

We denote the time they reach an agreement of the swap as
startT ime. ‚àÜ is the maximum time for parties to observe the
state change of contracts by others and take a step to make
changes on contracts. According of the protocol, the execution
should follow the following steps:

‚Ä¢ Step 1. Alice deposits 3 tokens as escrow premium in

ApricotSwap before ‚àÜ elapses after startT ime .

‚Ä¢ Step 2. Bob deposits 3 tokens as escrow premium in
BananaSwap before 2‚àÜ elapses after startT ime .
‚Ä¢ Step 3. Carol deposits 3 tokens as escrow premium in

CherrySwap before 3‚àÜ elapses after startT ime.
tokens

deposits

Alice

4.

‚Ä¢ Step

3

redemption premium in
4‚àÜ elapses after startT ime.

CherrySwap

as
before

‚Ä¢ Step

5.

Carol

deposits

2

tokens

redemption premium in BananaSwap
5‚àÜ elapses after startT ime .

as
before

‚Ä¢ Step 6. Bob deposits 1 token as redemption premium
in ApricotSwap before 6‚àÜ elapses after startT ime.

‚Ä¢ Step

7. Alice

tokens
ApricotSwap before 7‚àÜ elapses after startT ime.

100 ERC20

escrows

to

‚Ä¢ Step 8. Bob escrows 100 ERC20 tokens to BananaSwap

before 8‚àÜ elapses after startT ime.

‚Ä¢ Step

9. Carol

tokens
CherrySwap before 9‚àÜ elapses after startT ime.

100 ERC20

escrows

to

œïliveness = [0,‚àÜ) apr.depositEscrowPr(alice)
‚àß [0,2‚àÜ) ban.depositEscrowPr(bob)
‚àß [0,3‚àÜ) che.depositEscrowPr(carol)
‚àß [0,4‚àÜ) che.depositRedemptionPr(alice)
‚àß [0,5‚àÜ) ban.depositRedemptionPr(carol)
‚àß [0,6‚àÜ) apr.depositRedemptionPr(bob)
‚àß [0,7‚àÜ) apr.assetEscrowed(alice)
‚àß [0,8‚àÜ) ban.assetEscrowed(bob)
‚àß [0,9‚àÜ) che.assetEscrowed(carol)
‚àß [0,10‚àÜ) che.hashlockUnlocked(alice)
‚àß [0,11‚àÜ) ban.hashlockUnlocked(carol)
‚àß [0,12‚àÜ) apr.hashlockUnlocked(bob)
‚àß assetRedeemed(alice)
‚àß assetRedeemed(bob)
‚àß assetRedeemed(carol)
‚àß EscrowPremiumRefunded(alice)
‚àß EscrowPremiumRefunded(bob)
‚àß EscrowPremiumRefunded(carol)
‚àß RedemptionPremiumRefunded(alice)
‚àß RedemptionPremiumRefunded(bob)
‚àß RedemptionPremiumRefunded(carol)

‚Ä¢ Step 10. Alice sends the preimage of the hashlock to
CherrySwap to redeem Carol‚Äôs 100 tokens before 10‚àÜ
elapses after startT ime.

‚Ä¢ Step 11. Carol sends the preimage of the hashlock to
BananaSwap to redeem Bob‚Äôs 100 tokens before 11‚àÜ
elapses after startT ime.

‚Ä¢ Step 12. Bob sends the preimage of the hashlock to
ApricotSwap to redeem Alice‚Äôs 100 tokens before 12‚àÜ
elapses after startT ime.

If all parties are conforming, the protocol is executed as
above. Otherwise, some asset refund and premium redeem
events will be triggered to resolve the case where some party
deviates. To avoid distraction, we do not provide details here.

b) Safety: Below shows the speciÔ¨Åcation to check if
an individual party is conforming. If a party is found to
be conforming we ensure that there is no negative payoff
for the corresponding party. SpeciÔ¨Åcation to check Alice is

13

conforming:

œïalice conf = [0,‚àÜ) apr.depositEscrowPr(alice)
‚àß (cid:0)
[0,3‚àÜ) che.depositEscrowPr(carol) ‚Üí
[0,4‚àÜ) che.depositRedemptionPr(alice)(cid:1)

‚àß (cid:0)¬¨che.depositRedemptionPr(alice) U
che.depositEscrowPr(carol)(cid:1)‚àß
(cid:0)

[0,6‚àÜ) apr.depositRedemptionPr(bob) ‚Üí
[0,7‚àÜ) apr.assetEscrowed(alice)(cid:1)

‚àß (cid:0)¬¨apr.assetEscrowed(alice) U
apr.depositRedemptionPr(bob)(cid:1)
‚àß (cid:0)

[0,9‚àÜ) che.assetEscrowed(carol) ‚Üí
[0,10‚àÜ) che.hashlockUnlocked(alice)(cid:1)

‚àß (cid:0)¬¨che.hashlockUnlocked(alice) U
che.assetEscrowed(carol)(cid:1)‚àß
(cid:0)¬¨ban.hashlockUnlocked(carol) U
che.hashlockUnlocked(alice)(cid:1)
‚àß (cid:0)¬¨apr.hashlockUnlocked(bob) U
che.hashlockUnlocked(alice)(cid:1)

SpeciÔ¨Åcation to check conforming Alice does not have a
negative payoff:

œïalice safety = œïalice conform ‚Üí

(cid:0) (cid:88)

amount ‚â•

(cid:88)

amount(cid:1)

TransTo = alice

TransFrom = alice

c) Hedged: Below shows the speciÔ¨Åcation to check that,
if a party is conforming and its escrowed asset is refunded,
then it gets a premium as compensation.
œïalice hedged = (cid:0)œïalice conform

‚àß apr.assetEscrowed(alice)(cid:1)
‚Üí (cid:0) (cid:88)

amount

TransTo = alice

‚â•

(cid:88)

amount

TransFrom = alice

+ apr.redemptionPremium.amount(cid:1)

2) Auction Protocol: In the auction example, we consider
Alice to be the auctioneer who would like to sell a ticket
(worth 100 ERC20 tokens) on the ticket (tckt) blockchain,
and Bob and Carol bid on the coin blockchain and the
winner should get the ticket and pay for the auctioneer what
they bid, and the loser will get refunded. We denote the time
that they reach an agreement of the auction as startT ime.
‚àÜ is the maximum time for parties to observe the state
change of contracts by others and take a step to make changes
on contracts. Let T icketAuction be a contract managing
the ‚Äúticket‚Äù on the ticket blockchain, and CoinAuction be
a contract managing the bids on the coin blockchain. The
protocol is briefed as follows.

‚Ä¢ Setup. Alice generates two hashes h(sb) and h(sc). h(sb)
is assigned to Bob and h(sc) is assigned to Carol. If
Bob is the winner, then Alice releases sb. If Carol is
the winner, then Alice releases sc. If both sb and sc are
released in T icketAuction, then the ticket is refunded.
If both sb and sc are released in CoinAuction , then all
coins are refunded. In addition, Alice escrows her ticket
as 100 ERC20 tokens in T icketAuction and deposits 2
tokens as premiums in CoinAuction.

‚Ä¢ Step 1 (Bidding). Bob and Carol bids before ‚àÜ elapses

after startT ime.

‚Ä¢ Step 2 (Declaration). Alice sends the winner‚Äôs secret to
both chains to declare a winner before 2‚àÜ elapses after
startT ime.

‚Ä¢ Step 3 (Challenge). Bob and Carol challenges if they
see two secrets or one secret missing, i.e. Alice cheats,
before 4‚àÜ elapses after startT ime. They challenge by
forwarding the secret released by Alice using a path
signature scheme [3].

‚Ä¢ Step 4 (Settle). After 4‚àÜ elapses after startT ime, on
the CoinAuction, if only the hashlock corresponding
to the actual winner is unlocked, then the winner‚Äôs bid
goes to Alice. Otherwise, the winner‚Äôs bid is refunded.
Loser‚Äôs bid is always refunded. If the winner‚Äôs bid is
refunded, all bidders including the loser gets 1 token as
premium to compensate them. On the T icketAuction, if
only one secret is released, then the ticket is transferred
to the corresponding party who is assigned the hash of
the secret. Otherwise, the ticket is refunded.

a) Liveness: Below shows the speciÔ¨Åcation to check that,
if all parties are conforming, the winner (Bob) gets the ticket
and the auctioneer gets the winner‚Äôs bid.

œïliveness = [0,‚àÜ) coin.bid(bob)

‚àß [0,2‚àÜ) coin.declaration(alice, sb)
‚àß [0,2‚àÜ) tckt.declaration(alice, sb)
‚àß (4‚àÜ,‚àû) coin.redeemBid(any)
‚àß (4‚àÜ,‚àû) coin.refundPremium(any)
‚àß (cid:0)coin.bid(carol) ‚Üí

[0,‚àÜ) coin.refundBid(any)(cid:1)
‚àß tckt.redeemTicket(any)
‚àß ¬¨coin.challenge(any)
‚àß ¬¨tckt.challenge(any)

b) Safety: Below shows the speciÔ¨Åcation to check that,
if a party is conforming, this party does not end up worse off.
Take Bob (the winner) for example.

14

SpeciÔ¨Åcation to deÔ¨Åne Bob is conforming:

œïbob conform = [0,‚àÜ) coin.bid(bob)

(cid:16)(cid:0)coin.declaration(alice, sc)‚à®

‚àß
coin.challenge(carol, sc)(cid:1) ‚Üí
‚àß (cid:0)tckt.declaration(alice, sc)‚à®
tckt.challenge(carol, sc)‚à®
tckt.challenge(bob, sc)(cid:1)(cid:17)

(cid:16)(cid:0)coin.declaration(alice, sb)‚à®

‚àß
coin.challenge(carol, sb)(cid:1) ‚Üí
‚àß (cid:0)tckt.declaration(alice, sb)‚à®
tckt.challenge(carol, sb)‚à®
tckt.challenge(bob, sb)(cid:1)(cid:17)

(cid:16)(cid:0)tckt.declaration(alice, sc)‚à®

‚àß
tckt.challenge(carol, sc)(cid:1) ‚Üí
‚àß (cid:0)coin.declaration(alice, sc)‚à®
coin.challenge(carol, sc)‚à®
coin.challenge(bob, sc)(cid:1)(cid:17)

(cid:16)(cid:0)tckt.declaration(alice, sb)‚à®

‚àß
tckt.challenge(carol, sb)(cid:1) ‚Üí
‚àß (cid:0)coin.declaration(alice, sb)‚à®
coin.challenge(carol, sb)‚à®
coin.challenge(bob, sb)(cid:1)(cid:17)

SpeciÔ¨Åcation to deÔ¨Åne Bob does not end up worse off:

œïbob safety = œïbob conform ‚Üí

(cid:16)(cid:0)coin.refundBid(any)
‚àß coin.redeemPremium(any)(cid:1)‚à®

tckt.redeemTicket(any)

(cid:17)

c) Hedged: Below shows the speciÔ¨Åcation to check that,
if a party is conforming and its escrowed asset is refunded,
then it gets a premium as compensation.

œïbob hedged =

(cid:16)

œïbob conforming

‚àß (cid:0)tckt.refundTicket(alice)‚à®
tckt.redeemTicket(carol)(cid:1)(cid:17)
(cid:0)coin.refundBid(any)
‚àß coin.redeemPremium(any)(cid:1)

‚Üí

15

