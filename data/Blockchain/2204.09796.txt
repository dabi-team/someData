Distributed Runtime Veriï¬cation of Metric
Temporal Properties for Cross-Chain Protocols

Ritam Gangulyâˆ—, Yingjie Xueâ€ , Aaron Jonckheereâˆ—, Parker Ljungâ€ , Benjamin Schornsteinâ€ ,
Borzoo Bonakdarpourâˆ—, and Maurice Herlihyâ€ 
âˆ—Michigan State University {gangulyr, jonckh16, borzoo}@msu.edu
â€ Brown University {yingjie xue, parker ljung, benjamin schornstein, mph}@brown.edu

2
2
0
2

r
p
A
0
2

]

C
D
.
s
c
[

1
v
6
9
7
9
0
.
4
0
2
2
:
v
i
X
r
a

Abstractâ€”Transactions involving multiple blockchains are im-
plemented by cross-chain protocols. These protocols are based on
smart contracts, programs that run on blockchains, executed by a
network of computers. Because smart contracts can automatically
transfer ownership of cryptocurrencies, electronic securities,
and other valuable assets among untrusting parties, verifying
the runtime correctness of smart contracts is a problem of
compelling practical
interest. Such veriï¬cation is challenging
since smart contract execution is time sensitive, and the clocks
on different blockchains may not be perfectly synchronized. This
paper describes a method for runtime monitoring of blockchain
executions. First, we propose a generalized runtime veriï¬cation
technique for verifying partially synchronous distributed com-
putations for the metric temporal
logic (MTL) by exploiting
bounded-skew clock synchronization. Second, we introduce a
progression-based formula rewriting scheme for monitoring MTL
speciï¬cations which employs SMT solving techniques and report
experimental results.

I. INTRODUCTION

Blockchain technology [1], [2] is a blockbuster in this
era. It has drawn extensive attention from both industry and
academia. With blockchain technology, people can trade in
a peer-to-peer manner without mutually trusting each other,
removing the necessity of a trusted centralized party. The
concept of decentralization appears extremely appealing, and
the transparency, anonymity, and persistent storage provided
by blockchain make it more attractive. This revolutionary tech-
nology has triggered many applications in industry, ranging
from cryptocurrency [3], non-fungible tokens [4], internet of
things [5] to health services [6], etc.

Besides the huge success of cryptocurrencies known as
blockchain 1.0, especially Bitcoin [2], blockchain 2.0, known
as smart contracts [7], is also promising in many scenarios.
Smart contract is a program running on the blockchain. Its
execution is triggered automatically and enforced by condi-
tions preset in the code. In this way, the transfer of assets can
be automated by the rules in the smart contracts, and human
intervention cannot stop it. A typical smart contract implemen-
tation is provided by Ethereum [8], which uses Solidity [8],
which is a Turing-complete language. However, automating
the transactions by smart contracts also has its downsides.
If the smart contract has bugs and does not do what
is
expected, then lack of human intervention may lead to massive
ï¬nancial losses. For example, as pointed out by [9], the Parity
Multisig Wallet smart contract [10] version 1.5 included a
vulnerability which led to the loss of 30 million US dollars.

Fig. 1: Hedged Two-party Swap

Thus, developing effective techniques to verify the correctness
of smart contracts is both urgent and important to protect
against possible losses. Furthermore, when a protocol is made
up of multiple smart contracts across different blockchains,
the correctness of protocols also need to be veriï¬ed.

In this paper, we advocate for a runtime veriï¬cation (RV)
approach, to monitor the behavior of a system of blockchains
with respect to a set of temporal logic formulas. Applying RV
to deal with multiple blockchains can be reduced to distributed
RV, where a centralized or decentralize monitor observes the
behavior of a distributed system in which processes do not
share a global clock. Although RV deals with ï¬nite executions,
the lack of a common global clock prohibits it from having
a unique ordering of events in a distributed setting. Put
it another way, the monitor can only form a partial order
of event which may result in different veriï¬cation verdicts.
Enumerating all possible ordering of events at run time incurs
in an exponential blow up, making the approach not scalable.
To add to this already complex task, most speciï¬cation for
verifying blockchain smart contracts, come with a time bound.
This means, not only the ordering of the events are at play
when verifying, but also the actual physical time of occurrence
of the event dictates the veriï¬cation verdict.

In this paper, we propose an effective, sound and complete
solution to distributed RV for timed speciï¬cations expressed
in the metric temporal logic (MTL) [11]. To present a high-
level view of MTL, consider the two-party swap protocol [4]
shown in Fig 1. Alice and Bob, each in possession of Apricot
and Banana blockchain assets respectively, wants to swap their
assets between each other without being a victim of sore-
loser attack. There is a number of requirements that should
be followed by conforming parties to discourage any attack

1

AliceBobApricot BlockchainBanana BlockchainEscrowğ‘¥apricot coinsâ„,ğ‘¡!Escrow ybanana coinsâ„,ğ‘¡"Send  s:ğ»ğ‘ =â„to redeemDeposit premium ğ‘#+ğ‘$Deposit premium ğ‘$Send  s:ğ»ğ‘ =â„to redeem 
 
 
 
 
 
Apr

Ban

SetUp

Deposit(pb)

1

3

Escrow(h, tA)
Apr

5

Redeem(bob)

7

SetUp

Deposit(pa + pb)

Escrow(h, tB)

Redeem(alice)

1

seg1

4

Ban

6

seg2

7

Fig. 2: Progression Example

on themselves. We use the metric temporal logic (MTL) [11]
to express such requirements. One such requirement, where
Alice should not redeem her asset before Bob within eight
time units can be represented by the MTL formula:

Ï•spec = Â¬Apr.Redeem(bob) U [0,8)Ban.Redeem(alice).

We consider a fault proof central monitor which has the
complete view of the system but has no access to a global
clock. In order to limit the blow-up of states posed by the
absence of a global clock, we make a practical assumption
about the presence of a bounded clock skew (cid:15) between the
local clocks of every pair of processes. This is guaranteed by
a synchronization algorithm (e.g. NTP [12]). This setting is
known to be partially synchronous when we do not assume
any presence of a global clock and limit
the impact of
asynchrony within clock drifts. Such an assumption limits the
window of partial orders of events only within (cid:15) time units
and signiï¬cantly reduces the combinatorial blow-up caused
by nondeterminism due to concurrent. Existing distributed
RV techniques either assume a global clock when working
with time sensitive speciï¬cations [13], [14] or use untimed
speciï¬cations when assuming partial synchrony [15], [16].

We introduce an SMT1-based progression-based formula
rewriting technique over distributed computations which takes
into consideration the events observed thus far to rewrite the
speciï¬cations for future extensions. Our monitoring algorithm
accounts for all possible orderings of events without explicitly
generating them when evaluating MTL formulas. For example,
in Fig. 2, we see the events and the time of occurrence in
the two blockchains, Apricot(Apr) and Banana(Ban) divided
into two segments, seg1 and seg2 for computational purposes.
Considering maximum clock skew (cid:15) = 2 and the speciï¬cation
Ï•spec, at the end of the ï¬rst segment, we have two possible
rewritten formulas for the next segment:

Ï•spec1 = Â¬Apr.Redeem(bob) U [0,4)Ban.Redeem(alice)
Ï•spec2 = Â¬Apr.Redeem(bob) U [0,3)Ban.Redeem(alice)

This is possible due to the different ordering and different time
of occurrence of the events Deposit(pb) and Deposit(pa+
pb). In other words, the possible time of occurrence of the
event Deposit(pb) (resp. Deposit(pa + pb)) is either 2, 3
or 4 (resp. 3, 4, or 5) due to the maximum clock skew of 2.
Likewise, at the end of seg2, we have Ï•spec1 evaluate to true
where as Ï•spec2 evaluate to false. This is because, even if we

1Satisï¬ability modulo theories (SMT) is the problem of determining
whether a formula involving Boolean expressions comprising of more complex
formulas involving real numbers, integers, and/or various data structures is
satisï¬able.

consider the scenario when Ban.Redeem(alice) occurs
before Apr.Redeem(bob), a possible time of occurrence
of Ban.Redeem(alice) is 8 (resp. 6) which makes Ï•spec2
(resp. Ï•spec1 ) evaluate to false (resp. true).

We have fully implemented our technique2 and report
the results of rigorous experiments on monitoring synthetic
data, using benchmarks in the tool UPPAAL [17], as well as
monitoring correctness, liveness and conformance conditions
for smart contracts on blockchains. We put our monitoring
algorithm to test studying the effect of different parameters on
the runtime and report on each of them. Using our technique
we learn not to use a value of âˆ† (transaction deadline) that is
comparable to the value of clock skew (cid:15) when designing the
smart contract.

Organization: Section II presents the background con-
cepts. Formal statement of our RV problem is discussed in
Section III. The formula progression rules and the SMT-based
solution are described in Sections IV and V, respectively,
while experimental results are analyzed in Section VI. Related
work is discussed in Section VII before we make concluding
remarks in Section VIII. The appendix includes more details
about our case studies.

II. PRELIMINARIES
In this section, we present an overview of the distributed

computations and the metric temporal logic (MTL).

A. Distributed Computation

We consider a loosely coupled asynchronous message pass-
ing system, consisting of n reliable processes (that do not
fail), denoted by P = {P1, P2, Â· Â· Â· , Pn}. As a system, the
processes do not share any memory or have a common global
clock. Channels are assumed to be FIFO and lossless. In our
model, we represent each local state change by an event and a
message activity (send or receive) is represented by an event as
well. Message passing does not change the state of the process
and we disregard the content of the message as it is of no use
for our monitoring technique. Here, we refer to a global clock
which will act as the â€œrealâ€ timekeeper. It is to be noted that
the presence of this global clock is just for theoretical reasons
and it is not available to any of the individual processes.

We make an assumption about a partially synchronous
system. For each process Pi, where i âˆˆ [1, n], the local clock
can be represented as a monotonically increasing function
: Zâ‰¥0 â†’ Zâ‰¥0, where ci(G) is the value of the local
ci
clock at global time G. Since we are dealing with discrete-
time systems, for simplicity and without loss of generality,
we represent time with non-negative integers Zâ‰¥0. For any
two processes Pi and Pj, where i (cid:54)= j, we assume:

âˆ€G âˆˆ Zâ‰¥0. | ci(G) âˆ’ cj(G) |< (cid:15),

where (cid:15) > 0 is the maximum clock skew. The value of (cid:15)
is constant and is known to the monitor. This assumption is
met by the presence of a clock synchronization algorithm, like
NTP [12], to ensure bounded clock skew among all processes.

2https://github.com/ritam9495/rv-mtl-blockc

2

We denote an event on process Pi by ei

Ïƒ, where Ïƒ = ci(G),
that is the local time of occurrence of the event at some global
time G.

Deï¬nition 1: A distributed computation consisting of n
processes is represented by the pair (E, (cid:32)), where E is a set
of events partially ordered by Lamportâ€™s happened-before ((cid:32))
relation [18], subject to the partial synchrony assumption:

â€¢ For every process Pi, 1 â‰¤ i â‰¤ n, all the events happening

on it are totally ordered, that is,

âˆ€Ïƒ, Ïƒ(cid:48) âˆˆ Zâ‰¥0 : (Ïƒ < Ïƒ(cid:48)) â†’ (ei
Ïƒ

(cid:32) ei

Ïƒ(cid:48));

â€¢ If e is a message sending event in a process and f is
the corresponding message receiving event in another
process, then we have e (cid:32) f ;

Ïƒ, ej

â€¢ For any two processes Pi and Pj and two corresponding
Ïƒ(cid:48) âˆˆ E, if Ïƒ + (cid:15) < Ïƒ(cid:48) then, ei
Ïƒ(cid:48), where
Ïƒ

events ei
(cid:15) is the maximum clock skew, and
â€¢ If e (cid:32) f and f (cid:32) g, then e (cid:32) g. (cid:4)
Deï¬nition 2: Given a distributed computation (E, (cid:32)), a
subset of events C âŠ† E is said to form a consistent cut if
and only if when C contains an event e, then it should also
contain all such events that happened before e. Formally,

(cid:32) ej

âˆ€e âˆˆ E.(e âˆˆ C) âˆ§ (f (cid:32) e) â†’ f âˆˆ C. (cid:4)

The frontier of a consistent cut C, denoted by front(C) is
the set of all events that happened last in each process in the
cut. That is, front(C) is a set of ei
last for each i âˆˆ [1, |P|] and
ei
last âˆˆ C. We denote ei
last as the last event in Pi such that
Ïƒ (cid:54)= ei
Ïƒ âˆˆ C.(ei
âˆ€ei

last) â†’ (ei
Ïƒ
B. Metric Temporal Logic (MTL) [19], [20]

last).

(cid:32) ei

Let I be a set of nonempty intervals over Zâ‰¥0. We deï¬ne

an interval, I, to be

[start, end ) (cid:44) {a âˆˆ Zâ‰¥0 | start â‰¤ a < end }
where start âˆˆ Zâ‰¥0, end âˆˆ Zâ‰¥0 âˆª {âˆ} and start < end . We
deï¬ne AP as the set of all atomic propositions and Î£ = 2AP
as the set of all possible states. A trace is represented by a
pair which consists of a sequence of states, denoted by Î± =
s0s1 Â· Â· Â· , where si âˆˆ Î£ for every i > 0 and a sequence of non-
negative numbers, denoted by Â¯Ï„ = Ï„0Ï„1 Â· Â· Â· , where Ï„i âˆˆ Zâ‰¥0
for all i > 0. We represent the set of all inï¬nite traces by a
pair of inï¬nite sets, (Î£Ï‰, ZÏ‰
â‰¥0). The trace sksk+1 Â· Â· Â· (resp.
Ï„kÏ„k+1) is represented by Î±k (resp. Ï„ k). For an inï¬nite trace
Î± = s0s1 Â· Â· Â· and Â¯Ï„ = Ï„0Ï„1 Â· Â· Â· , Â¯Ï„ is a increasing sequence,
meaning Ï„i+1 â‰¥ Ï„i, for all i â‰¥ 0.

Syntax.: The syntax of metric temporal logic (MTL) for

inï¬nite traces are deï¬ned by the following grammar:

Ï• ::= p | Â¬Ï• | Ï•1 âˆ¨ Ï•2 | Ï•1 U IÏ•2

where p âˆˆ AP and U I is the â€˜untilâ€™ temporal operator with
time interval I. Note that other propositional and temporal
operators can be represented using the ones mentioned above.
For example, true = p âˆ¨ Â¬p, false = Â¬true, Ï•1 â†’ Ï•2 =
Â¬Ï•1 âˆ¨ Ï•2, Ï•1 âˆ§ Ï•2 = Â¬(Â¬Ï•1 âˆ¨ Â¬Ï•2),
I Ï• = true U IÏ•
I Â¬Ï•) (â€œalwaysâ€). We denote
(â€œeventuallyâ€) and
the set of all MTL formulas by Î¦MTL.

I Ï• = Â¬(

3

Semantics: The semantics of metric temporal logic (MTL)
is deï¬ned over the trace, Î± = s0s1 Â· Â· Â· and Â¯Ï„ = Ï„0Ï„1 Â· Â· Â· as
follows:
(Î±, Â¯Ï„ , i) |= p
(Î±, Â¯Ï„ , i) |= Â¬Ï•
(Î±, Â¯Ï„ , i) |= Ï•1 âˆ¨ Ï•2
(Î±, Â¯Ï„ , i) |= Ï•1 U IÏ•2

iff p âˆˆ si
iff
iff
iff âˆƒj â‰¥ i.Ï„j âˆ’ Ï„i âˆˆ I âˆ§ (Î±, Â¯Ï„ , j) |=
Ï•2 âˆ§ âˆ€k âˆˆ [i, j), (Î±, Â¯Ï„ , k) |= Ï•1

(Î±, Â¯Ï„ , i) (cid:54)|= Ï•
(Î±, Â¯Ï„ , i) |= Ï•1 âˆ¨ (Î±, Â¯Ï„ , i) |= Ï•2

It is to be noted that (Î±, Â¯Ï„ ) |= Ï• holds if and only if (Î±, Â¯Ï„ , 0) |=
Ï•.

In the context of runtime veriï¬cation, we introduce the
notion of ï¬nite MTL. The truth values are represented by the
set B2 = {(cid:62), âŠ¥}, where (cid:62) (resp. âŠ¥) represents a formula that
is satisï¬ed (resp. violated) given a ï¬nite trace. We represent
the set of all ï¬nite traces by a pair of ï¬nite sets, (Î£âˆ—, Zâˆ—
â‰¥0).
For a ï¬nite trace, Î± = s0s1 Â· Â· Â· sn and Â¯Ï„ = Ï„0Ï„1 Â· Â· Â· Ï„n the only
semantic that needs to be redeï¬ned is that of U (â€˜untilâ€™) and
is as follows:

[(Î±, Â¯Ï„ , i) |=F Ï•1 U IÏ•2] =

ï£±
ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£³

(cid:62) if âˆƒj â‰¥ i.Ï„j âˆ’ Ï„i âˆˆ I

([Î±j |=F Ï•2] = (cid:62)) âˆ§ âˆ€k âˆˆ
[i, j) : ([Î±k |=F Ï•1] = (cid:62))

âŠ¥ otherwise.

In order to further illustrate the difference between MTL and
ï¬nite MTL, we consider the formula Ï• = I p and a trace Î± =
s0s1 Â· Â· Â· sn and Â¯Ï„ = Ï„0Ï„1 Â· Â· Â· Ï„n. We have [(Î±, Â¯Ï„ ) |=F Ï•] = (cid:62)
if for some j âˆˆ [0, n] we have Ï„j âˆ’ Ï„0 âˆˆ I and p âˆˆ si,
otherwise âŠ¥. Now, consider the formula Ï• = I p we have
[(Î±, Â¯Ï„ ) |=F Ï•] = âŠ¥ if for some j âˆˆ [0, n] we have Ï„j âˆ’ Ï„0 âˆˆ I
and p (cid:54)âˆˆ si, otherwise (cid:62).

III. FORMAL PROBLEM STATEMENT

In a partially synchronous system, there are different or-
dering of events that is possible and each unique ordering of
events [21] might evaluate to different verdicts. In other words,
a partially synchronous distributed computation (E, (cid:32)) may
have different ordering of events primarily due to the different
interleavings of events that is possible. Thus, it is possible to
have different verdicts for the same distributed computation
for the different ordering of events.

Let (E, (cid:32)) be a distributed computation. A sequence of
consistent cuts is of the form C0C1C2 Â· Â· Â· , where for all i â‰¥ 0,
we have (1) Ci âŠ‚ Ci+1 and (2) |Ci| + 1 = |Ci+1|, and (3)
C0 = âˆ…. The set of all sequences of consistent cuts be denoted
by C. We note that we view time interval I in the syntax of
MTL is in terms of the physical (global) time G. Thus, when de-
riving all the possible traces given the distributed computation
(E, (cid:32)), we have to account for all different orders in which
the events could possibly had occur with respect to G. This
involves replacing the local time of occurrence of an event, ei
Ïƒ
with the set of event {ei
Ïƒ(cid:48) | Ïƒ(cid:48) âˆˆ [max{0, Ïƒ âˆ’ (cid:15) + 1}, Ïƒ + (cid:15))}.
is
This is to account for the maximum clock drift
possible on the local clock of a process when compared
to the global clock. For example, given the computation in
Figure 3, a maximum clock skew (cid:15) = 2 and a MTL formula,

that

P1

P2

a
1

a
2

Â¬a
4

b
5

Fig. 3: Trace Example

Ï• = a U [0,6)b, one has to consider all possible traces including
(a, 1)(a, 2)(b, 4)(Â¬a, 5) |= Ï• and (a, 1)(a, 2)(Â¬a, 4)(b, 5) (cid:54)|=
Ï•. The contradictory result is due to the different time of
occurrence of event that needs to be considered.

Given a sequence of consistent cuts, it is evident that for
all j > 0, |Cj âˆ’ Cjâˆ’1| = 1 and event Cj âˆ’ Cjâˆ’1 is the last
event that was added onto the cut Cj. To translate monitoring
of a distributed system into monitoring a trace, We deï¬ne a
sequence of natural numbers as Â¯Ï€ = Ï€0Ï€1 Â· Â· Â· , where Ï€0 = 0
and for each j â‰¥ 1, we have Ï€j = Ïƒ, such that front(Cj) âˆ’
front(Cjâˆ’1) = {ei
Ïƒ}. To maintain time monotonicity, we only
consider sequences where for all i â‰¥ 0, Ï€i+1 â‰¥ Ï€i.

The set of all traces that can be formed from (E, (cid:32)) is

deï¬ned as:

Tr(E, (cid:32)) =

(cid:110)

front(C0)front(C1) Â· Â· Â· | C0C1 Â· Â· Â· âˆˆ C

(cid:111)
.

In the sequel, we assume that every sequence Î± of frontiers in
Tr(E, (cid:32)) is associated with a sequence Â¯Ï€. Thus, to comply
with the semantics of MTL, we refer to the elements of
Tr(E, (cid:32)) by pairs of the form (Î±, Â¯Ï€). Now that we have a
set of all possible traces, we evaluate an MTL formula Ï• with
respect to the computation (E, (cid:32)) as follows:

[(E, (cid:32)) |=F Ï•] =

(cid:110)

(Î±, Â¯Ï€, 0) |=F Ï• | (Î±, Â¯Ï€) âˆˆ Tr(E, (cid:32))

(cid:111)
.

This boils down to having a set of verdicts, since a dis-
tributed computation may involve several traces and each trace
might evaluate to a different verdict.

Overall Idea of our solution.: To solve the above problem
(evaluating all possible verdicts), we propose a monitoring
approach based on formula-rewriting (Section IV) and SMT
solving (Section V). Our approach involves iteratively(1) chop-
ping a distributed computation into a sequence of smaller
segments to reduce the problem size and (2) progress the MTL
formula for each segment for the next segment, which results
in a new MTL formula by invoking an SMT solver. Since each
computation/segment corresponds to a set of possible traces
due to partial synchrony, each invocation of the SMT solver
may result in a different verdict.

IV. FORMULA PROGRESSION FOR MTL

We start describing our solution by explaining the formula

progression technique.

Deï¬nition 3: A progression function is of the form Pr :
Î£âˆ— Ã— Zâˆ—
â‰¥0 Ã— Î¦MTL â†’ Î¦MTL and is deï¬ned for all ï¬nite
traces (Î±, Â¯Ï„ ) âˆˆ (Î£âˆ—, Zâˆ—
â‰¥0)
and MTL formulas Ï• âˆˆ Î¦MTL, such that (Î±.Î±(cid:48), Â¯Ï„ .Â¯Ï„ (cid:48)) |= Ï• if
and only if (Î±(cid:48), Â¯Ï„ (cid:48)) |= Pr(Î±, Â¯Ï„ , Ï•). (cid:4)

â‰¥0), inï¬nite traces (Î±(cid:48), Â¯Ï„ (cid:48)) âˆˆ (Î£Ï‰, ZÏ‰

It

is to be noted that compared to the classic formula
regression technique in [22], here the function Pr takes a
ï¬nite trace as input, while the algorithm in [22] rewrite the
formula after every observed state. When monitoring a par-
tially synchronous distributed system, where multiple verdicts
are possible and no unique ordering of events are possible,
the classical state-by-state formula rewriting technique is of
little use. The motivation of our approach comes from the fact
that for computation reasons, we chop the computation into
smaller segments and the veriï¬cation of each segment is done
through an SMT query. A state-by-state approach would incur
in a huge number of SMT queries being generated.

Let I = [start, end ) denote an interval. By I âˆ’ Ï„ ,
we mean the interval I (cid:48) = [start (cid:48), end (cid:48)), where start (cid:48) =
max{0, start âˆ’ Ï„ } and end (cid:48) = max{0, end âˆ’ Ï„ }. Also, for
two time instances, Ï„i and Ï„0, we let InInt(i) return true or
false depending upon the whether Ï„i âˆ’ Ï„0 âˆˆ I.

Progressing atomic propositions. For an MTL formula of the
form Ï• = p, where p âˆˆ AP, the result depends on whether
or not p âˆˆ Î±(0). This marks as our base case for the other
temporal and logical operators:

Pr(Î±, Â¯Ï„ , Ï•) =

(cid:40)

if p âˆˆ Î±(0)
true
false if p (cid:54)âˆˆ Î±(0)

Progressing negation. For an MTL formula of the form Ï• =
Â¬Ï†, we have:

Pr(Î±, Â¯Ï„ , Ï•) = Â¬Pr(Î±, Â¯Ï„ , Ï†).

Progressing disjunction. Let Ï• = Ï•1 âˆ¨ Ï•2. Apart from the
trivial cases, the result of progression of Ï•1 âˆ¨ Ï•2 is based on
progression of Ï•1 and/or progression of Ï•2:

Pr(Î±, Â¯Ï„ , Ï•) =

true

false

Ï•(cid:48)
2

Ï•(cid:48)
1

1 âˆ¨ Ï•(cid:48)
Ï•(cid:48)
2

ï£±

ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£´ï£³

if Pr(Î±, Â¯Ï„ , Ï•1) = true âˆ¨
Pr(Î±, Â¯Ï„ , Ï•2) = true
if Pr(Î±, Â¯Ï„ , Ï•1) = false âˆ§
Pr(Î±, Â¯Ï„ , Ï•2) = false
if Pr(Î±, Â¯Ï„ , Ï•1) = false âˆ§
Pr(Î±, Â¯Ï„ , Ï•2) = Ï•(cid:48)
2
if Pr(Î±, Â¯Ï„ , Ï•2) = false âˆ§
Pr(Î±, Â¯Ï„ , Ï•1) = Ï•(cid:48)
1
if Pr(Î±, Â¯Ï„ , Ï•1) = Ï•(cid:48)
Pr(Î±, Â¯Ï„ , Ï•2) = Ï•(cid:48)
2

1 âˆ§

Always and eventually operators. As shown in Algorithms 1
and 2, the progression for â€˜alwaysâ€™, ( I Ï•) and â€˜eventuallyâ€™,
I Ï•) depends on the value of InInt(i) and the progression
(
of the inner formula Ï•. In Algorithm 1 and 2, we divide the
algorithm into three cases: (1) line 4, corresponds to if the I is
within the sequence Â¯Ï„ ; (2) line 6, corresponds to where I starts
in the current trace but its end is beyond the boundary of the
sequence Â¯Ï„ , and (3) line 9, corresponds to if the entire interval
I is beyond the boundary of sequence Â¯Ï„ . In Algorithm 1, we
are only concerned about the progression of Ï• on the sufï¬x
(Î±i, Â¯Ï„ i) if InInt(i) = true. In case, InInt(i) = false the

4

Algorithm 1 Always

Algorithm 2 Eventually

iâˆˆ[0,|Î±|]

1: function Pr(Î±, Â¯Ï„ , I Ï•)
if Istart â‰¤ Ï„|Î±| âˆ’ Ï„0 then
2:
if Iend â‰¤ Ï„|Î±| âˆ’ Ï„0 then
3:
return (cid:86)
4:
else
5:
return (cid:86)
6:
end if
7:
else
8:
return [Iâˆ’(Ï„|Î±|âˆ’Ï„0)) Ï•
9:
end if
10:
11: end function

iâˆˆ[0,|Î±|]

(cid:0)InInt(i) â†’ Pr(Î±i, Â¯Ï„ i, Ï•)(cid:1)

(cid:0)InInt(i) â†’ Pr(Î±i, Â¯Ï„ i, Ï•)(cid:1)âˆ§ [Iâˆ’(Ï„|Î±|âˆ’Ï„0)) Ï•

I Ï•)

iâˆˆ[0,|Î±|]

1: function Pr(Î±, Â¯Ï„ ,
if Istart â‰¤ Ï„|Î±| âˆ’ Ï„0 then
2:
if Iend â‰¤ Ï„|Î±| âˆ’ Ï„0 then
3:
return (cid:87)
4:
else
5:
return (cid:87)
6:
end if
7:
else
8:
return
9:
end if
10:
11: end function

[Iâˆ’(Ï„|Î±|âˆ’Ï„0)) Ï•

iâˆˆ[0,|Î±|]

(cid:0)InInt(i) âˆ§ Pr(Î±i, Â¯Ï„ i, Ï•)(cid:1)
(cid:0)InInt(i) âˆ§ Pr(Î±i, Â¯Ï„ i, Ï†)(cid:1) âˆ¨ [Iâˆ’(Ï„|Î±|âˆ’Ï„0)) Ï•

Algorithm 3 Until

1: function Pr(Î±, Â¯Ï„ , Ï•1 U I Ï•2)
if Istart â‰¤ Ï„|Î±| âˆ’ Ï„0 then
2:
if Iend â‰¤ Ï„|Î±| âˆ’ Ï„0 then
3:
return
else

iâˆˆ[0,|Î±|]

(cid:16) (cid:86)

return

(cid:16) (cid:86)

4:
5:
6:

iâˆˆ[0,|Î±|]
(cid:17)

Ï•1 U (Iâˆ’(Ï„|Î±|âˆ’Ï„0)Ï•2

end if
7:
else
8:
return (cid:0) (cid:86)
9:
end if
10:
11: end function

iâˆˆ[0,|Î±|] Pr(Î±i, Â¯Ï„ i, Ï•1)(cid:1) âˆ§ Ï•1 U (Iâˆ’(Ï„|Î±|âˆ’Ï„0)Ï•2

(cid:0)(Ï„i < Istart + Ï„0) â†’ Pr(Î±i, Â¯Ï„ i, Ï•1)(cid:1)(cid:17)
(cid:0)(Ï„i < Istart + Ï„0) â†’ Pr(Î±i, Â¯Ï„ i, Ï•1)(cid:1)(cid:17)

(cid:16) (cid:87)

âˆ§

jâˆˆ[0,|Î±|]
(cid:16) (cid:87)

âˆ§

(cid:0)InInt(j) âˆ§ Pr(Î±, Â¯Ï„ ,

[0,Ï„j âˆ’Ï„0) Ï•1) âˆ§ Pr(Î±j , Â¯Ï„ j , Ï•2)(cid:1)(cid:17)

jâˆˆ[0,|Î±|]

(cid:0)InInt(j) âˆ§ Pr(Î±, Â¯Ï„ ,

[0,Ï„j âˆ’Ï„0) Ï•1) âˆ§ Pr(Î±j , Â¯Ï„ j , Ï•2)(cid:1) âˆ¨

consequent drops and the entire condition equates to true.
In other words, equating over all i âˆˆ [0, |Î±|], we are only
left with conjunction of Pr(Î±i, Â¯Ï„ i, Ï•) where InInt(i) = true.
In addition to this, we add the initial formula with updated
interval for the next trace. Similarly, in Algorithm 2, equating
over all i âˆˆ [0, |Î±|], if InInt(i) = false the corresponding
Pr(Î±i, Â¯Ï„ i, Ï•) is disregarded and the ï¬nal formula is a disjunc-
tion of Pr(Î±i, Â¯Ï„ i, Ï•) with InInt(i) = true.

[0,Ï„iâˆ’Ï„0) Ï•1 (resp.

Progressing the until operator. Let the formula be of the form
Ï•1 U IÏ•2. According to the semantics of until Ï•1 should be
evaluated to true in all states leading up to some i âˆˆ I, where
Ï•2 evaluates to true. We start by progressing Ï•1 (resp. Ï•2) as
[Ï„i,Ï„i+1) Ï•2) for some i âˆˆ I. Since, we
[Ï„i,Ï„i+1) Ï•2, on the trace
are only verifying the sub-formula,
sequence (Î±, Â¯Ï„ ), it is equivalent to verifying the sub-formula
[0,1) Ï•2 â‰¡ Ï•2 over the trace sequence (Î±i, Â¯Ï„ i). Similar to
Algorithms 1 and 2, in Algorithm 3 we need to consider three
cases. In lines 4, 6 and 9, following the semantics of until
operator, we make sure for all i âˆˆ [0, |Î±|], if Ï„i < Istart +
Ï„0, Ï•1 is satisï¬ed in the sufï¬x (Î±i, Â¯Ï„ i). In addition to this
there should be some j âˆˆ [0, |Î±|] for which if InInt(j) =
[0,Ï„j âˆ’Ï„0) Ï•1
true, then the trace satisï¬es the sub-formula
[Ï„j ,Ï„j +1) Ï•2). In lines 6 and 9, we also accommodate
and
for future traces satisfying the formula Ï•1 U IÏ•2 with updated
intervals.

Example: In Fig. 4, the time line shows propositions and
[0,6) r â†’ (Â¬p U [2,9)q).
their time of occurrence, for formula
The entire computation has been divided into 3 segments,
(Î±, Â¯Ï„ ), (Î±(cid:48), Â¯Ï„ (cid:48)), and (Î±(cid:48)(cid:48), Â¯Ï„ (cid:48)(cid:48)) and each state has been repre-

5

(âˆ…, 1)
0

(Î±, Â¯Ï„ )

1
(âˆ…, 2)

(âˆ…, 3)
2

(Î±(cid:48), Â¯Ï„ (cid:48))

(Î±(cid:48)(cid:48), Â¯Ï„ (cid:48)(cid:48))

(âˆ…, 4)
1

0
({r}, 3)

2
(âˆ…, 5)

(âˆ…, 6)
0

({p}, 7)
2

1
({q}, 7)

Fig. 4: Progression example.

sented by (s, Ï„ ):

â€¢ We start with segment (Î±, Â¯Ï„ ). First we evaluate

[0,6) r,
which requires evaluating Pr(Î±i, Â¯Ï„ i, r) for i âˆˆ {0, 1, 2},
all of which returns the verdict false and there by
[0,4) r. Next, to evaluate
rewriting the sub-formula as
the sub-formula Â¬p U [2,9)q, we need to evaluate (1)
Pr(Î±i, Â¯Ï„ i, Â¬p) for i âˆˆ {0, 1} since Ï„i âˆ’ Ï„0 < 2 and
both evaluates to true, (2) Pr(Î±, Â¯Ï„ ,
[0,2) Â¬p) which also
evaluates to true and (3) Pr(Î±2, Â¯Ï„ 2, q) which evaluates
as false. Thereby, the rewritten formula after observing
(Î±, Â¯Ï„ ) is

[0,3) r â†’ (Â¬p U [0,6)q).

â€¢ Similarly, we evaluate the formula now with respect to
(Î±(cid:48), Â¯Ï„ (cid:48)), which makes the sub-formula
[0,3) r evaluate
to true at Ï„ = 3 and the sub-formula Â¬p U [0,6)q (there
is no such i âˆˆ {0, 1, 2} where Ï„i âˆ’ Ï„0 < 0 and for all
j âˆˆ {0, 1, 2}, Pr(Î±(cid:48)j, Â¯Ï„ (cid:48)j, q) = false) is rewritten as
Â¬p U [0,4)q.

â€¢ In (Î±(cid:48)(cid:48), Â¯Ï„ (cid:48)(cid:48)), for j = 1, Pr(Î±(cid:48)(cid:48), Â¯Ï„ (cid:48)(cid:48),

[0,2) Â¬p) = true and
Pr(Î±(cid:48)(cid:48)j, Â¯Ï„ (cid:48)(cid:48)j, q) = true, and thereby rewriting the entire
formula as true.

V. SMT-BASED SOLUTION

The sequence of consistent cuts starts from {} and ends at E.

A. SMT Entities

SMT entities represent (1) sub-formulas of the MTL spec-
iï¬cation, and (2) variables used to represent the distributed
computation. After we have the verdicts for each of the
individual sub-formulas, we use the progression laws dis-
cussed in Section IV to construct the formula for the future
computations.

Distributed Computation We represent a distributed compu-
tation (E, (cid:32)) by function f : E â†’ {0, 1, . . . , |E| âˆ’ 1}. To
represent the happen-before relation, we deï¬ne a E Ã— E matrix
(cid:32) ej
Ïƒ][ej
Ïƒ(cid:48)] = 1 represents ei
called hbSet where hbSet[ei
Ïƒ
Ïƒ(cid:48)
Ïƒ, ej
Ïƒ][ej
for ei
Ïƒ(cid:48) âˆˆ E. Also, if |Ïƒ âˆ’ Ïƒ(cid:48)| â‰¥ (cid:15) then hbSet[ei
Ïƒ(cid:48)] = 1,
else hbSet[ei
Ïƒ(cid:48)] = 0. This is all done in the pre-processing
phase of the algorithm and in the rest of the paper, we represent
events by the set E and a happen-before relation by (cid:32) for
simplicity.

Ïƒ][ej

In order to represent the possible time of occurrence of an

event, we deï¬ne a function Î´ : E â†’ Zâ‰¥0, where

âˆ€ei

Ïƒ âˆˆ E.âˆƒÏƒ(cid:48) âˆˆ [max{0, Ïƒ âˆ’ (cid:15) + 1}, Ïƒ + (cid:15) âˆ’ 1].Î´(ei

Ïƒ) = Ïƒ(cid:48)

To connect events, E, and propositions, AP, on which the
MTL formula Ï• is constructed, we deï¬ne a boolean function
Âµ : AP Ã— E â†’ {true, false}. For formulas involving non-
boolean variables (e.g., x1 + x2 â‰¤ 7), we can update the func-
tion Âµ accordingly. We represent a sequence of consistent cuts
that start from {} and end in E, we introduce an uninterpreted
function Ï : Zâ‰¥0 â†’ 2E to reach a verdict given, it satisï¬es
all the constrains explained in V-B. Lastly, to represent the
sequence of time associated with the sequence of consistent
cuts, we introduce a function Ï„ : Zâ‰¥0 â†’ Zâ‰¥0.

B. SMT Constrains

Once we have the necessary SMT entities, we move onto
including the constrains for both generating a sequence of
consecutive cuts and also representing the MTL formula as
a SMT constrain.

Consistent cut constrains over Ï: In order to make sure the
sequence of cuts represented by the uninterpreted function Ï,
is a sequence of consistent cuts, i.e., they follow the happen-
before relations between events in the distributed system:

âˆ€i âˆˆ [0, |E|].âˆ€e, e(cid:48) âˆˆ E.

(cid:16)

(e(cid:48) (cid:32) e)âˆ§(cid:0)e âˆˆ Ï(i)(cid:1)(cid:17)

â†’ (cid:0)e(cid:48) âˆˆ Ï(i)(cid:1)

Next, we make sure that in the sequence of consistent cuts,
the number of events present in a consistent cut is one more
than the number of events that were present in the consistent
cut before it:

âˆ€i âˆˆ [0, |E|). | Ï(i + 1) |=| Ï(i) | +1

Next, we make sure than in the sequence of consistent cuts,
each consistent cut includes all the events that were present in
the consistent cut before it, i.e, it is a subset of the consistent
cut prior in the sequence.

âˆ€i âˆˆ [0, |E|].Ï(i) âŠ‚ Ï(i + 1)

6

Ï(0) = âˆ…; Ï(|E|) = E

The sequence of time reï¬‚ects the time of occurrence of the
event that has just been added to the sequence of consistent
cut:

âˆ€i â‰¥ 1.Ï„ (i) = Î´(ei

Ïƒ), such that Ï(i) âˆ’ Ï(i âˆ’ 1) = {ei

Ïƒ}

And ï¬nally, we make sure the monotonosity of time is
maintained in the sequence of time

âˆ€i âˆˆ [0, |E|).Ï„ (i + 1) â‰¥ Ï„ (i)

Constrains for MTL formulas over Ï: These constrains will
make sure that Ï will not only represent a valid sequence
of consistent cuts but also make sure that
the sequence
of consistent cuts satisfy the MTL formula. As is evident,
a distributed computation can often yield two contradicting
evaluation. Thus, we need to check for both satisfaction
and violation for all the sub-formulas in the MTL formula
provided. Note that monitoring any MTL formula using our
progression rules will result in monitoring sub-formulas which
are atomic propositions, eventually and globally temporal
operators. Below we mention the SMT constrain for each
of the different sub-formula. Violation (resp. satisfaction) for
atomic proposition and eventually (resp. globally) constrain
will be the negation of the one mentioned.

Ï• = p

(cid:95)

eâˆˆfront(Ï(0))

Âµ[p, e] = true, for p âˆˆ AP

Ï• = I Ï•

Ï• = I Ï•

(satisfaction, i.e., (cid:62))
âˆƒi âˆˆ [0, |E|].Ï„ (i) âˆ’ Ï„ (0) âˆˆ I âˆ§ Ï(i) (cid:54)|= Ï•
(violation, i.e., âŠ¥)
âˆƒi âˆˆ [0, |E|].Ï„ (i) âˆ’ Ï„ (0) âˆˆ I âˆ§ Ï(i) |= Ï•
(satisfaction, i.e., (cid:62))

A satisï¬able SMT instance denotes that
the uninterpreted
function was not only able to generate a valid sequence of
consistent cuts but also that the sequence satisï¬es or violates
the MTL formula given the computation. This result is then
fed to the progression cases to generate the ï¬nal verdict.

C. Segmentation and Parallelization of Distributed Computa-
tion

We know that predicate detection, let alone runtime veriï¬-
cation, is NP-complete [23] in the size of the system (number
of processes). This complexity grows to higher classes when
working with nested temporal operators. To make the problem
computationally viable, we aim to chop the computation,
(E, (cid:32)) into g segments, (seg1, (cid:32)), (seg2, (cid:32)), Â· Â· Â· , (segg, (cid:32)).
This involves creating small SMT-instances for each of the
segments which improves the runtime of the overall problem.
In a computation of length l, if we were to chop it into g
segments, each segment would of the length l
g + (cid:15) and the set
of events included in it can be given by:

segj =

(cid:110)

ei
Ïƒ | Ïƒ âˆˆ

i âˆˆ [1, | P |]

(cid:20)
max(cid:0)0,
(cid:111)

(j âˆ’ 1) Ã— l
g

âˆ’ (cid:15)(cid:1),

(cid:21)

âˆ§

j Ã— l
g

Note that monitoring of a segment should include the events
that happened within (cid:15) time of the segment actually starting
since it might include events that are concurrent with some
other events in the system not accounted for in the previous
segment.

VI. CASE STUDY AND EVALUATION
In this section, we analyze our SMT-based solution. We
note that we are not concerned about data collections, data
transfer, etc, as given a distributed setting, the runtime of the
actual SMT encoding will be the most dominating aspect of the
monitoring process. We evaluate our proposed solution using
traces collected from benchmarks of the tool UPPAAL [17]3
models (Section VI-A) and a case study involving smart
contracts over multiple blockchains (Section VI-B).

A. UPPAAL Benchmarks

1) Setup: We base our synthetic experiments on 3 different
UPPAAL benchmark models described in [24]. The Train Gate
models a railway control system which controls access to a
bridge. The bridge is controlled by a gate/operator and can be
accessed by one train at a time. We monitor two properties:

(cid:94)

Ï•1 = (

iâˆˆP
(cid:94)

Ï•2 =

Â¬Train[i].Cross) U Train[1].Cross

(cid:0)Train[i].Appr â†’

iâˆˆP

(Gate.Occ U Train[i].Cross)(cid:1)

where P is the set of trains.

Fischerâ€™s Protocol is a mutual exclusion protocol for n
processes. We verify ï¬rst, that no two process (P) enter the
critical section (cs) at the same time and second, all request
(req) should be followed by the processes able to access the
critical section within some time.

Ï•3 = (

Ï•4 = (

(cid:88)

iâˆˆP
(cid:94)

iâˆˆP

P[i].cs â‰¤ 1)

P[i].req â†’ I P[i].cs)

The Gossiping People is a model consisting of n people
who wish to share their secret with each other. We monitor
ï¬rst, that each Person gets to know about everyone elseâ€™s
secret within some time bound and second, each Person
has secrets to share inï¬nitely often.

(cid:94)

i,jâˆˆP

(i (cid:54)= j) â†’ Person[i].secret[j])

(

I Person[i].secrets)

Ï•5 = I(

Ï•6 =

(cid:94)

iâˆˆP

3UPPAAL is a model checker for a network of timed automata. The tool-
set is accompanied by a set of benchmarks for real-time systems. Here, we
assume that the components of the network are partially synchronized.

7

Each experiment involves two steps: (1) distributed com-
putation/trace generation and (2) trace veriï¬cation. For each
UPPAAL model, we consider each pair of consecutive events
are 0.1s apart, i.e., there are 10 events per second per process.
For our veriï¬cation step, our monitoring algorithm executes
on the generated computation and veriï¬es it against an MTL
speciï¬cation. We consider the following parameters (1) pri-
mary which includes time synchronization constant ((cid:15)), (2)
MTL formula under monitoring, (3) number of segments (g),
(3) computation length (l), (4) number of processes in the
system (P), and (5) event rate. We study the runtime of our
monitoring algorithm against each of these parameters. We
use a machine with 2x Intel Xeon Platinum 8180 (2.5 Ghz)
processor, 768 GB of RAM, 112 vcores with gcc version 9.3.1.
2) Analysis: We now study each of the parameters individ-
ually and analyze how it effects the runtime of our monitoring
approach. All results correspond to (cid:15) = 15ms, |P| = 2,
g = 15, l = 2sec, a event rate of 10events/sec and Ï•4 as the
speciï¬cation unless mentioned otherwise.

Impact of different formula. Fig. 5a shows that runtime
of the monitor depends on two factors: the number of sub-
formulas and the depth of nested temporal operators. Com-
paring Ï•3 and Ï•6, both of which consists of the same number
of predicates but since Ï•6 has recursive temporal operators,
it takes more time to verify and the runtime is comparable to
Ï•1, which consists of two sub-formulas. This is because veri-
ï¬cation of the inner temporal formula often requires observing
states in the next segment in order to come to the ï¬nal verdict.
This accounts for the more runtime for the monitor.

Impact of epsilon. Increasing the value of time synchro-
nization constant ((cid:15)), increases the possible number of con-
current events that needs to be considered. This increases
the complexity of verifying the computation and there-by
increasing the runtime of the algorithm. In addition to this,
higher values of (cid:15) also correspond to more number of possible
traces that are possible and should be taken into consideration.
We observe that
the runtime increases exponentially with
increasing the time synchronization constant in Fig. 5b. An
the
interesting observation is with longer segment
runtime increases at a higher rate than with shorter segment
length. This is because with longer segment length and higher
(cid:15), it equates to a larger number of possible traces that the
monitoring algorithm needs to take into consideration. This
increases the overall runtime of the veriï¬cation algorithm by
a considerable amount and at a higher pace.

length,

Impact of segment frequency. Increasing the segment fre-
quency makes the length of each segment lower and thus
verifying each segment
involves consideration of a lower
number of events. We observe the effect of segment frequency
on the runtime of our veriï¬cation algorithm in Fig. 5c. With
increasing the segment frequency, the runtime decreases unless
it reaches a certain value (here it is â‰ˆ 0.6) after which the
beneï¬t of working with a lower number of events is overcast
by the time required to setup each SMT instances. Working

500

100

50

10

5

1

500

100

50

10

5

1

)
s
(

e
m

i
t
n
u
R

)
s
(

e
m

i
t
n
u
R

Ï•1Ï•2Ï•3Ï•4Ï•5Ï•6

1

2

4

3
Number of Processes |P|

7

5

g = 40
g = 25
g = 20
g = 15
g = 12
g = 10
g = 8
g = 7

)
s
(

e
m

i
t
n
u
R

500

100

50

10

5

1

10

0.5

1

2
Time Synchronization Constant (cid:15)(s)

2.5

1.5

3

(a) Different Formula

(b) Epsilon

|P| = 1; Ï•6
|P| = 1; Ï•4
|P| = 2; Ï•6
|P| = 2; Ï•4
|P| = 3; Ï•6
|P| = 3; Ï•4
|P| = 4; Ï•6
|P| = 4; Ï•4

500

100

50

10

5

1

)
s
(

e
m

i
t
n
u
R

3.5

0.25

0.5

0.75

1

1.25

1.5

1.75

2

Segment Frequency (secâˆ’1)

(c) Segment Frequency

|P| = 1; Ï•6
|P| = 1; Ï•4
|P| = 2; Ï•6
|P| = 2; Ï•4
|P| = 3; Ï•6
|P| = 3; Ï•4
|P| = 4; Ï•6
|P| = 4; Ï•4

|P| = 1; Ï•6
|P| = 1; Ï•4
|P| = 2; Ï•6
|P| = 2; Ï•4
|P| = 3; Ï•6
|P| = 3; Ï•4
|P| = 4; Ï•6
|P| = 4; Ï•4

)
s
(

e
m

i
t
n
u
R

500

100
50

10
5

1

|P| = 1; Ï•6
|P| = 1; Ï•4
|P| = 2; Ï•6
|P| = 2; Ï•4
|P| = 3; Ï•6
|P| = 3; Ï•4
|P| = 4; Ï•6
|P| = 4; Ï•4

500

100

50

)
s
(

e
m

i
t
n
u
R

10

5

10

20

30

40

50

Computation length (l)

1

2

3

No. of solutions (/segment)

4

5

7

9

11

13

15

Event Rate (event/sec)

(d) Computation Length

(e) Number of Process

(f) Event Rate

Fig. 5: Impact of different parameters on synthetic data

with higher number of segments equates to solving more
number of SMT problem for the same computation length.
Setting up the SMT problem requires a considerable amount
of time which is seen by the slight increase in runtime for
higher values of segment frequency.

Impact of computation length. As it can be inferred from the
previous results, the runtime of our veriï¬cation algorithm is
majorly dictated by the number of events in the computation.
Thus, when working with a longer computation, keeping the
maximum clock skew and the number of segments constant,
we should see a longer veriï¬cation time as well. Results in
Fig. 5d makes the above claim true.

Impact of number truth values per segment. In order to take
into consideration all possible truth values of a computation,
we execute the SMT problem multiple times, with the verdict
of all previous executions being added to the SMT problem
such that no two verdict is repeated. Here in Fig. 5e we see
that the runtime is linearly effected by increasing number
of distinct verdicts. This is because, the complexity of the
problem that the SMT is trying to solve does not change when
trying to evaluate to a different solution.

Impact of event-rate. Increasing the event rate involves more
number of events that needs to be processes by our veriï¬cation
algorithm per segment and thereby increasing the runtime at
an exponential rate as seen in Fig. 5f. We also observe that
with higher number of processes, the rate at which the runtime

of our algorithm increases is higher for the same increase in
event rate.

B. Blockchain

1) Setup: We implemented the following cross-chain proto-
cols from [25]: two-party swap, multi-party swap, and auction.
The protocols were written as smart contracts in Solidity and
tested using Ganache, a tool that creates mocked Ethereum
blockchains. Using a single mocked chain, we mimicked
cross-chain protocols via several (discrete) tokens and smart
contracts, which do not communicate with each other.

We use the hedged two-party swap example from [25] to
describe our experiments. The implementation of the other two
protocols are similar. Suppose Alice would like to exchange
her apricot tokens with Bobâ€™s banana tokens, using the hedged
two-party swap protocol shown in Fig. 1. This protocol pro-
vides protection for parties compared to a standard two-party
swap protocol [26], in that if one party locks their assets to
exchange which is refunded later, this party gets a premium
as compensation for locking their assets. The protocol consists
of six steps to be executed by Alice and Bob in turn. In our
example, we let the amount of tokens they are exchanging
be 100 ERC20 tokens and the premium pb be 1 token and
pa + pb be 2 tokens. We deploy two contracts on both apricot
blockchain(the contract is denoted as ApricotSwap) and ba-
nana blockchain (denoted as BananaSwap) by mimicking the
two blockchains on Ethereum. Denote the time that they reach
an agreement of the swap as startT ime. âˆ† is the maximum

8

time for parties to observe the state change of contracts by
others and take a step to make changes on contracts. In our
experiment, âˆ† = 500 milliseconds. By the deï¬nition of the
protocol, the execution should be:

â€¢ Step 1. Alice deposits 2 tokens as premium in

BananaSwap before âˆ† elapses after startT ime .

â€¢ Step 2. Bob should deposit 1 token as premium in

ApricotSwap before 2âˆ† elapses after startT ime.

â€¢ Step 3. Alice escrows her 100 ERC20 tokens to

ApricotSwap before 3âˆ† elapses after startT ime.
â€¢ Step 4. Bob escrows her 100 ERC20 tokens
BananaSwap before 4âˆ† elapses after startT ime.
â€¢ Step 5. Alice sends the preimage of the hashlock to
BananaSwap to redeem Bobâ€™s 100 tokens before 5âˆ†
elapses after startT ime. Premium is refunded.

to

â€¢ Step 6. Bob sends the preimage of the hashlock to
ApricotSwap to redeem Aliceâ€™s 100 tokens before 6âˆ†
elapses after startT ime. Premium is refunded.

If all parties all conforming, the protocol is executed as
above. Otherwise, some asset refund and premium redeem
events will be triggered to resolve the case where some party
deviates. To avoid distraction, we do not provide details here.
Each smart contract provides functions to let parties
deposit premiums DepositPremium(), escrow an as-
set EscrowAsset(), send a secret
to redeem assets
RedeemAsset(), refund the asset if it is not redeemed after
timeout, RefundAsset(), and counterparts for premiums
RedeemPremium() and RefundPremium(). Whenever
a function is called successfully (meaning the transaction sent
to the blockchain is included in a block),
the blockchain
emits an event
that we then capture and log. The event
interface is provided by the Solidity language. For example,
when a party successfully calls DepositPremium(), the
PremiumDeposited event emits on the blockchain. We
then capture and log this event, allowing us to view the values
of PremiumDepositedâ€™s declared ï¬elds: the time when it
emits, the party that called DepositPremium(), and the
amount of premium sent. Those values are later used in the
monitor to check against the speciï¬cation.

2) Log Generation and Monitoring: Our tests simulated
different executions of the protocols and generated 1024,
4096, and 3888 different sets of logs for the aforementioned
protocols, respectively. We use the hedged two-party swap
as an example to show how we generate different logs to
simulate different execution of the protocol. On each contract,
we enforce the order of those steps to be executed. For
example, step 3 EscrowAsset() on the ApricotSwap
cannot be executed before Step 1 is taken, i.e. the premium
is deposited. This enforcement in the contract restricted the
number of possible different states in the contract. Assume we
use a binary indicator to denote whether a step is attempted
by the corresponding party. 1 denotes a step is attempted,
and 0 denotes this step is skipped. If the previous step is
skipped, then the later step does not need to be attempted
since it will be rejected by the contract. We use an array
to denote whether each step in taken for each contract. On

9

each contract, the different execution of those steps can be
[1,1,1] means all steps are attempted, or [1,1,0] meaning the
last step is skipped, and so on. Each chain has 4 different
executions. We take the Cartesian product of arrays of two
contracts to simulate different combinations of executions on
two contracts. Furthermore, if a step is attempted, we also
simulate whether the step is taken late, or in time. Thus
we have 26 possibilities of those 6 steps. In summary, we
succeeded generating 4 Â· 4 Â· 26 = 1024 different logs.

In our testing, after deploying the two contracts, we it-
erate over a 2D array of size 1024 Ã— 12, and each time
takes one possible execution denoted as an array length of
12 to simulate the behavior of participants. For example,
[1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] means the ï¬rst step is attempted
however it is late, and the steps after second step are all
attempted in time. Indexed from 0, the even index denotes
if a step is attempted or not and the odd index denotes the
former step is attempted in time or late. By the indicator given
by the array, we let parties attempt to call a function of the
contract or just skip. In this way, we produce 1024 different
logs containing the events emitted in each iteration.

We check the policies mentioned in [25]: liveness, safety,
sore loser attacks. Live-
and ability to hedge against
ness means that Alice should deposit her premium on
the banana blockchain within âˆ† from when the swap
[0,âˆ†) ban.premium_deposited(alice)) and
started(
then Bob should deposit his premiums, and then they escrow
their assets to exchange, redeem their assets (i.e. the assets
are swapped), and the premiums are refunded. In our testing,
we always call a function to settle all assets in the contract
if the asset transfer is triggered by timeout. Thus, in the
speciï¬cation, we also check all assets are settled:

Ï•liveness = [0,âˆ†) ban.premium_deposited(alice)âˆ§

[0,2âˆ†) apr.premium_deposited(bob)âˆ§
[0,3âˆ†) apr.asset_escrowed(alice)âˆ§
[0,4âˆ†) ban.asset_escrowed(bob)âˆ§
[0,5âˆ†) ban.asset_redeemed(alice)âˆ§
[0,6âˆ†) apr.asset_redeemed(bob)âˆ§
[0,5âˆ†) ban.premium_refunded(alice)âˆ§
[0,6âˆ†) apr.premium_refunded(bob)âˆ§
[6âˆ†,âˆ) apr.all_asset_settled(any)âˆ§
[5âˆ†,âˆ) ban.all_asset_settled(any)

to protect

Safety is provided only for conforming parties, since if one
party is deviating and behaving unreasonably, it is out of
them. Alice should
the scope of the protocol
always deposit her premium ï¬rst to start the execution of the
protocol(
and proceed if Bob proceeds with the next step. For
then Alice
example,
should
to
asset
[0,2âˆ†) apr.premium_deposited(bob) â†’
exchange(
[0,3âˆ†) apr.asset_escrowed(alice)). Alice should

[0,âˆ†) ban.premium_deposited(alice))

premium,
escrow her

deposits
ahead

his
and

if Bob

always

go

2-party swap; g = 1
3-party swap; g = 2
aunction; g = 2

500

100
50

10
5

1

)
s
(

e
m

i
t
n
u
R

4

8

12
No. of events

16

20

24

28

Fig. 6: Blockchain Experiments

never release her secret if she does not redeem, which means
Bob should not be able to redeem unless Alice redeems,
which is expressed as Â¬apr.asset_redeemed(bob) U
ban.asset_redeemed(alice):

Ï•alice conform = [0,âˆ†) ban.premium_deposited(alice)âˆ§

(cid:0)

(cid:0)

[0,2âˆ†) apr.premium_deposited(bob) â†’
[0,3âˆ†) apr.asset_escrowed(alice)(cid:1) âˆ§
[0,4âˆ†) ban.asset_escrowed(bob) â†’
[0,5âˆ†) ban.asset_redeemed(alice)(cid:1) âˆ§

(cid:0)Â¬apr.asset_redeemed(bob) U

ban.asset_redeemed(alice)(cid:1)

By deï¬nition, safety means a conforming party does not end
up with a negative payoff. We track the assets transferred
from parties and transferred to parties in our logs. Thus,
a conforming party is safe. e.g. Alice, is speciï¬ed as the
Ï•alice saf ety:

Ï•alice safety =Ï•alice conform â†’

(cid:0) (cid:88)

amount â‰¥

(cid:88)

amount(cid:1)

TransTo = alice

TransFrom = alice

To enable a conforming party to hedge against the sore loser
attack if they escrow assets to exchange which is refunded
in the end, our protocol should guarantee the aforementioned
party get a premium as compensation, which is expressed as
Ï•alice hedged:

Ï•alice hedged = (cid:0)Ï•alice conformâˆ§

apr.asset_escrowed(alice)âˆ§
apr.asset_refunded(any)(cid:1) â†’

(cid:0)

(cid:88)

amount â‰¥

TransferTo = alice

(cid:88)

amount

TransferFrom = alice

+ apr.premium.amount(cid:1)

3) Analysis of Results: We put our monitor to test the traces
generated by the Trufï¬‚e-Ganache framework. To monitor the
2-party swap protocol we do not divide the trace into multiple
segments due to the low number of events that are involved

10

in the protocol. On the other hand both, 3-party swap and
auction protocol involves a higher number of events and thus
we divide the trace into two segments (g = 2). In Fig. 6,
we show how the runtime of the monitor is effected by the
number of events in each transaction log.

Additionally, we generate transaction logs with different
values for deadline (âˆ†) and time synchronization constant ((cid:15))
to put the safety of the protocol in jeopardy. We observe both
true and false verdict when (cid:15) (cid:39) âˆ†. This is due to the
non deterministic time stamp owning to the assumption of
a partially synchronous system. The observed time stamp of
each event can at most be off by (cid:15). Thus, we recommend not
to use a value of âˆ† that is comparable to the value of (cid:15) when
designing the smart contract.

VII. RELATED WORK

Centralized and decentralized online predicate detection
in an asynchronous distributed system have been studies
in [27], [28]. Extensions to include temporal operators appear
in [29], [30]. The line of work in [27]â€“[31] considers a
fully asynchronous system. A SMT-based predicate detection
solution has been introduced in [32]. On the other hand,
runtime monitoring for synchronous distributed system has
been studied in [33]â€“[35]. This approach has shortcoming,
the major one being the assumption of a common global
clock shared among all the processes. Finally, fault-tolerant
monitoring, where monitors can crash, has been investigated
in [36] for asynchronous and in [37] for synchronized dis-
tributed processes.

Runtime monitoring of time sensitive distributed system
has been studied in [13], [14], [38], [39]. With the onset
of blockchains and the security vulnerability posed by smart
contracts have been studied in [40]â€“[44]. The major area that
these work lack is all of them consider the system to be
synchronous with the presence of a global clock. However,
smart contracts often include multiple blockchains and thus
we consider a partially synchronous system where a synchro-
nization algorithm limits the maximum clock skew among
processes to a constant. An SMT-based solution was studied
in [15], which we extend to include more expressive time
bounded logic.

VIII. CONCLUSION

In this paper, we study distributed runtime veriï¬cation.
We propose a technique which takes an MTL formula and
a distributed computation as input. By assuming partial syn-
chrony among all processes, ï¬rst we chop the computation
into several segments and then apply a progression-based
formula rewriting monitoring algorithm implemented as a
SMT decision problem in order to verify the correctness of the
distributed system with respect to the formula. We conducted
extensive synthetic experiments on trace generated by the
UPPAAL tool and a set of blockchain smart contracts.

For future work, we plan to study the trade off among
accuracy and scalability of our approach. Another important
extension of our work is distributed runtime veriï¬cation where

the processes are dynamic, i.e., the process can crash and
can also restore its state at any given time during execution.
This will let us study a wide range of applications including
airspace monitoring.

REFERENCES

[1] Y. Lu, â€œThe blockchain: State-of-the-art and research challenges,â€ Jour-
nal of Industrial Information Integration, vol. 15, pp. 80â€“90, 2019.
[2] S. Nakamoto, â€œBitcoin: A peer-to-peer electronic cash system,â€ Decen-

tralized Business Review, p. 21260, 2008.

[3] M. Herlihy, â€œAtomic cross-chain swaps,â€ in Proceedings of the 2018
ACM symposium on principles of distributed computing, 2018, pp. 245â€“
254.

[4] M. Herlihy, B. Liskov, and L. Shrira, â€œCross-chain deals and adversarial

commerce,â€ The VLDB Journal, pp. 1â€“19, 2021.

[5] K. Christidis and M. Devetsikiotis, â€œBlockchains and smart contracts for
the internet of things,â€ Ieee Access, vol. 4, pp. 2292â€“2303, 2016.
[6] J. Xu, K. Xue, S. Li, H. Tian, J. Hong, P. Hong, and N. Yu, â€œHealthchain:
A blockchain-based privacy preserving scheme for large-scale health
data,â€ IEEE Internet of Things Journal, vol. 6, no. 5, pp. 8770â€“8781,
2019.

[7] L. W. Cong and Z. He, â€œBlockchain disruption and smart contracts,â€
The Review of Financial Studies, vol. 32, no. 5, pp. 1754â€“1797, 2019.
Springer, 2017, vol.

[8] C. Dannen, Introducing Ethereum and solidity.

318.

[9] J. Ellul and G. J. Pace, â€œRuntime veriï¬cation of ethereum smart
contracts,â€ in 2018 14th European Dependable Computing Conference
(EDCC).

IEEE, 2018, pp. 158â€“163.

[10] P. Technologies, As of 2017. [Online]. Available: https://github.com/

paritytech/parity

[11] R. Koymans, â€œSpecifying Real-Time Properties with Metric Temporal

Logic,â€ RealTime Systems, vol. 2, no. 4, pp. 255â€“299, 1990.

[12] D. Mills, â€œNetwork time protocol version 4: Protocol and algorithms
speciï¬cation,â€ Internet Requests for Comments, RFC Editor, RFC 5905,
June 2010.

[13] D. Basin, F. Klaedtke, S. MÂ¨uller, and E. ZË˜alinescu, â€œMonitoring metric
ï¬rst-order temporal properties,â€ J. ACM, vol. 62, no. 2, may 2015.
[Online]. Available: https://doi.org/10.1145/2699444

[14] J. Worrell, J. Ouaknine, and H.-M. Ho, â€œOn the expressiveness and
monitoring of metric temporal logic,â€ Logical Methods in Computer
Science, vol. 15, 2019.

[15] R. Ganguly, A. Momtaz, and B. Bonakdarpour, â€œDistributed Runtime
Veriï¬cation Under Partial Synchrony,â€ in 24th International Conference
on Principles of Distributed Systems (OPODIS 2020), vol. 184,
2021, pp. 20:1â€“20:17. [Online]. Available: https://drops.dagstuhl.de/
opus/volltexte/2021/13505

[16] A. Momtaz, N. Basnet, H. Abbas, and B. Bonakdarpour, â€œPredicate
monitoring in distributed cyber-physical systems,â€ in Proceedings of the
21st International Conference on Runtime Veriï¬cation (RV), 2021, pp.
3â€“22.

[17] K. G. Larsen, P.Pattersson, and W. Yi, â€œUPPAAL in a nutshell,â€
International Journal on Software Tools for Technology Transfer, vol. 1,
no. 1-2, pp. 134â€“152, 1997.

[18] L. Lamport, â€œTime, clocks, and the ordering of events in a distributed
system,â€ Commun. ACM, vol. 21, no. 7, p. 558â€“565, jul 1978. [Online].
Available: https://doi.org/10.1145/359545.359563

[19] R. Alur and T. A. Henzinger, â€œLogics and models of real time: A survey,â€
in Real-Time: Theory in Practice, J. W. de Bakker, C. Huizing, W. P.
de Roever, and G. Rozenberg, Eds. Berlin, Heidelberg: Springer Berlin
Heidelberg, 1992, pp. 74â€“106.

[20] â€”â€”, â€œA really temporal logic,â€ J. ACM, vol. 41, no. 1, p. 181â€“203,

jan 1994. [Online]. Available: https://doi.org/10.1145/174644.174651

[21] A. Bauer and Y. Falcone, â€œDecentralised ltl monitoring,â€ in FM 2012:
Berlin,

Formal Methods, D. Giannakopoulou and D. MÂ´ery, Eds.
Heidelberg: Springer Berlin Heidelberg, 2012, pp. 85â€“100.

[22] K. Havelund and G. Rosu, â€œMonitoring programs using rewriting,â€ in
Proceedings of the 16th IEEE International Conference on Automated
Software Engineering, ser. ASE â€™01. USA: IEEE Computer Society,
2001, p. 135.

[23] V. K. Garg, Elements of Distributed Computing. USA: John Wiley &

Sons, Inc., 2002.

[24] G. Behrmann, A. David, and K. G. Larsen, â€œA tutorial on UPPAAL,â€ in
Formal Methods for the Design of Real-Time Systems: 4th International
School on Formal Methods for the Design of Computer, Communication,
and Software Systems, SFM-RT 2004, no. 3185, 2004, pp. 200â€“236.

[25] Y. Xue and M. Herlihy, â€œHedging against sore loser attacks in cross-

chain transactions,â€ arXiv preprint arXiv:2105.06322, 2021.

[26] T. Nolan, â€œAlt chains and atomic transfers,â€ https://bitcointalk.org/index.

php?topic=193281.0, May, 2013, bitcoin Forum.

[27] H. Chauhan, V. K. Garg, A. Natarajan, and N. Mittal, â€œA distributed
abstraction algorithm for online predicate detection,â€ in Proceedings of
the 32nd IEEE Symposium on Reliable Distributed Systems (SRDS),
2013, pp. 101â€“110.

[28] N. Mittal and V. K. Garg, â€œTechniques and applications of computation
slicing,â€ Distributed Computing, vol. 17, no. 3, pp. 251â€“277, 2005.

[29] V. A. Ogale and V. K. Garg, â€œDetecting temporal

logic predicates
on distributed computations,â€ in Proceedings of the 21st International
Symposium on Distributed Computing (DISC), 2007, pp. 420â€“434.
[30] M. Mostafa and B. Bonakdarpour, â€œDecentralized runtime veriï¬cation
of LTL speciï¬cations in distributed systems,â€ in Proceedings of the
29th IEEE International Parallel and Distributed Processing Symposium
(IPDPS), 2015, pp. 494â€“503.

[31] K. Sen, A. Vardhan, G. Agha, and G.Rosu, â€œEfï¬cient decentralized
monitoring of safety in distributed systems,â€ in Proceedings of the 26th
International Conference on Software Engineering (ICSE), 2004, pp.
418â€“427.

[32] V. T. Valapil, S. Yingchareonthawornchai, S. S. Kulkarni, E. Torng,
and M. Demirbas, â€œMonitoring partially synchronous distributed systems
using SMT solvers,â€ in Proceedings of the 17th International Conference
on Runtime Veriï¬cation (RV), 2017, pp. 277â€“293.

[33] L. M. Danielsson and C. SÂ´anchez, â€œDecentralized stream runtime
veriï¬cation,â€ in Proceedings of the 19th International Conference on
Runtime Veriï¬cation (RV), 2019, pp. 185â€“201.

[34] C. Colombo and Y. Falcone, â€œOrganising LTL monitors over distributed
systems with a global clock,â€ Formal Methods in System Design, vol. 49,
no. 1-2, pp. 109â€“158, 2016.

[35] B. Bonakdarpour and B. Finkbeiner, â€œRuntime veriï¬cation for hyper-
ltl,â€ in Proceedings of the 16th International Conference on Runtime
Veriï¬cation, 2016, pp. 41â€“45.

[36] B. Bonakdarpour, P. Fraigniaud, S. Rajsbaum, D. A. Rosenblueth,
and C. Travers, â€œDecentralized asynchronous crash-resilient runtime
veriï¬cation,â€ in Proceedings of the 27th International Conference on
Concurrency Theory (CONCUR), 2016, pp. 16:1â€“16:15.

[37] L. Lamport and N. Lynch, Handbook of Theoretical Computer Science.
Amsterdam: Elsevier Science Publishers B. V., 1990, vol. B, ch. 18:
Distributed Computing: Models and Methods.

[38] D. Basin, F. Klaedtke, and S. MÂ¨uller, â€œMonitoring security policies
with metric ï¬rst-order temporal logic,â€ in Proceedings of the 15th ACM
Symposium on Access Control Models and Technologies, ser. SACMAT
â€™10. New York, NY, USA: Association for Computing Machinery, 2010,
p. 23â€“34. [Online]. Available: https://doi.org/10.1145/1809842.1809849
[39] P. Thati and G. RosÂ¸u, â€œMonitoring algorithms for metric temporal logic
speciï¬cations,â€ Electron. Notes Theor. Comput. Sci., vol. 113, no. C, p.
145â€“162, jan 2005.

[40] A. GarcÂ´Ä±a, E. Cambronero, C. Colombo, L. DÂ´Ä±az, and G. Pace, Runtime
Veriï¬cation of Contracts with Themulus, 09 2020, pp. 231â€“246.
[41] S. Azzopardi, J. Ellul, and G. J. Pace, â€œRuntime monitoring processes
across blockchains,â€ in Fundamentals of Software Engineering, H. Hojjat
and M. Massink, Eds. Cham: Springer International Publishing, 2021,
pp. 142â€“156.

[42] S. Azzopardi, G. Pace, F. Schapachnik, and G. Schneider, â€œOn the
speciï¬cation and monitoring of timed normative systems,â€ in Runtime
Veriï¬cation, L. Feng and D. Fisman, Eds. Cham: Springer International
Publishing, 2021, pp. 81â€“99.

[43] X. Chen, D. Park, and G. RosÂ¸u, â€œA language-independent approach
to smart contract veriï¬cation,â€ in Leveraging Applications of Formal
Methods, Veriï¬cation and Validation. Industrial Practice, T. Margaria
and B. Steffen, Eds. Cham: Springer International Publishing, 2018,
pp. 405â€“413.

[44] D. Park, Y. Zhang, M. Saxena, P. Daian, and G. RosÂ¸u, â€œA
formal veriï¬cation tool for ethereum vm bytecode,â€ in Proceedings
of
the 2018 26th ACM Joint Meeting on European Software
Engineering Conference and Symposium on the Foundations of
Software Engineering, ser. ESEC/FSE 2018. New York, NY, USA:
Association for Computing Machinery, 2018, p. 912â€“915. [Online].
Available: https://doi.org/10.1145/3236024.3264591

11

IX. APPENDIX

Here, in Section IX-A we explain how the different UPPAAL
models work and in Section IX-B we dive into the MTL
speciï¬cations we use to verify 3-party swap and the auction
protocol.

A. UPPAAL Models

Below we explain in details how each of the UPPAAL
models work. In respect
to our monitoring algorithm, we
consider multiple instances of each of the models as different
processes. Each event consists of the action that was taken
along with the time of occurrence of the event. In addition to
this, we assume a unique clock for each instance, synchronized
by the presence of a clock synchronization algorithm with a
maximum clock skew of (cid:15).

a) The Train-Gate: It models a railway control system
which controls access to a bridge for several trains. The bridge
can be considered as a shared resource and can be accessed
by one train at a time. Each train is identiï¬ed by a unique
id and whenever a new train appears in the system, it sends
a appr message along with itâ€™s id. The Gate controller has
two options: (1) send a stop message and keep the train in
waiting state or (2) let the train cross the bridge. Once the
train crosses the bridge, it sends a leave message signifying
the bridge is free for any other train waiting to cross.

leave[id]

Safe

Cross

appr[id]

Appr

Start

stop[id]

go[id]

Stop

Fig. 7: Train model

The gate keeps track of the state of the bridge, in other
words the gate acts as the controller of the bridge for the trains.
If the bridge is currently not being used, the gate immediately
offers any train appearing to go ahead, otherwise it sends a
stop message. Once the gate is free from a train leaving
the bridge, it sends out a go message to any train that had
appeared in the mean time and was waiting in the queue.

12

go[front()]

Free

appr[e]

Occ

leave[id]

appr[e]

stop[tail()]

Fig. 8: Gate model

It

b) The Fischerâ€™s Protocol:

is a mutual exclusion
protocol designed for n processes. A process always sends
in a request to enter the critical section (cs). On receiving the
request, a unique pid is generated and the process moves to a
wait state. A process can only enter into the critical section
when it has the correct id. Upon exiting the critical section,
the process resets the id which enables other processes to
enter the cs

A

id = 0

req

id = 0

id = pid

id = 0

id == pid

cs

wait

Fig. 9: Fischer model

Start

start()

exchange()

Call

talk()

listen()

Listen

Fig. 10: Gossiping people model

c) The Gossiping People: The model consists of n
people, each having a private secret they wish to share with
each other. Each person can Call another person and after
a conversation, both person mutually knows about all their
secrets. With respect to our monitoring problem, we make
sure that each person generates a new secret that needs to be
shared among others inï¬nitely often.

B. Blockchain

Below shows the speciï¬cations we used to verify the
correctness of hedged three-party swap and auction protocols,

as shown in [25]. The structure of the speciï¬cations are similar
to that of hedged two-party swap protocol.

a) Liveness: Below shows the speciï¬cation to liveness,

if all the steps of the protocol has been taken:

1) Hedged 3-Party Swap Protocol: The three-party swap
example we implemented can be described as a digraph where
there are directed edges between Alice, Bob and Carol. For
simplicity, we consider each party transfers 100 assets. Trans-
fer between Alice and Bob is called ApricotSwap, meaning
Alice proposes to transfer 100 apricot tokens to Bob, transfer
between Bob and Carol called BananaSwap, meaning Bob
proposes to transfer 100 banana tokens to Carol,
transfer
between Carol and Alice, called CherrySwap, meaning Carol
proposes to transfer 100 cherry tokens to Alice. Different
tokens are managed by different blockchains (Apricot, Banana
and Cherry respectively).

We denote the time they reach an agreement of the swap as
startT ime. âˆ† is the maximum time for parties to observe the
state change of contracts by others and take a step to make
changes on contracts. According of the protocol, the execution
should follow the following steps:

â€¢ Step 1. Alice deposits 3 tokens as escrow premium in

ApricotSwap before âˆ† elapses after startT ime .

â€¢ Step 2. Bob deposits 3 tokens as escrow premium in
BananaSwap before 2âˆ† elapses after startT ime .
â€¢ Step 3. Carol deposits 3 tokens as escrow premium in

CherrySwap before 3âˆ† elapses after startT ime.
tokens

deposits

Alice

4.

â€¢ Step

3

redemption premium in
4âˆ† elapses after startT ime.

CherrySwap

as
before

â€¢ Step

5.

Carol

deposits

2

tokens

redemption premium in BananaSwap
5âˆ† elapses after startT ime .

as
before

â€¢ Step 6. Bob deposits 1 token as redemption premium
in ApricotSwap before 6âˆ† elapses after startT ime.

â€¢ Step

7. Alice

tokens
ApricotSwap before 7âˆ† elapses after startT ime.

100 ERC20

escrows

to

â€¢ Step 8. Bob escrows 100 ERC20 tokens to BananaSwap

before 8âˆ† elapses after startT ime.

â€¢ Step

9. Carol

tokens
CherrySwap before 9âˆ† elapses after startT ime.

100 ERC20

escrows

to

Ï•liveness = [0,âˆ†) apr.depositEscrowPr(alice)
âˆ§ [0,2âˆ†) ban.depositEscrowPr(bob)
âˆ§ [0,3âˆ†) che.depositEscrowPr(carol)
âˆ§ [0,4âˆ†) che.depositRedemptionPr(alice)
âˆ§ [0,5âˆ†) ban.depositRedemptionPr(carol)
âˆ§ [0,6âˆ†) apr.depositRedemptionPr(bob)
âˆ§ [0,7âˆ†) apr.assetEscrowed(alice)
âˆ§ [0,8âˆ†) ban.assetEscrowed(bob)
âˆ§ [0,9âˆ†) che.assetEscrowed(carol)
âˆ§ [0,10âˆ†) che.hashlockUnlocked(alice)
âˆ§ [0,11âˆ†) ban.hashlockUnlocked(carol)
âˆ§ [0,12âˆ†) apr.hashlockUnlocked(bob)
âˆ§ assetRedeemed(alice)
âˆ§ assetRedeemed(bob)
âˆ§ assetRedeemed(carol)
âˆ§ EscrowPremiumRefunded(alice)
âˆ§ EscrowPremiumRefunded(bob)
âˆ§ EscrowPremiumRefunded(carol)
âˆ§ RedemptionPremiumRefunded(alice)
âˆ§ RedemptionPremiumRefunded(bob)
âˆ§ RedemptionPremiumRefunded(carol)

â€¢ Step 10. Alice sends the preimage of the hashlock to
CherrySwap to redeem Carolâ€™s 100 tokens before 10âˆ†
elapses after startT ime.

â€¢ Step 11. Carol sends the preimage of the hashlock to
BananaSwap to redeem Bobâ€™s 100 tokens before 11âˆ†
elapses after startT ime.

â€¢ Step 12. Bob sends the preimage of the hashlock to
ApricotSwap to redeem Aliceâ€™s 100 tokens before 12âˆ†
elapses after startT ime.

If all parties are conforming, the protocol is executed as
above. Otherwise, some asset refund and premium redeem
events will be triggered to resolve the case where some party
deviates. To avoid distraction, we do not provide details here.

b) Safety: Below shows the speciï¬cation to check if
an individual party is conforming. If a party is found to
be conforming we ensure that there is no negative payoff
for the corresponding party. Speciï¬cation to check Alice is

13

conforming:

Ï•alice conf = [0,âˆ†) apr.depositEscrowPr(alice)
âˆ§ (cid:0)
[0,3âˆ†) che.depositEscrowPr(carol) â†’
[0,4âˆ†) che.depositRedemptionPr(alice)(cid:1)

âˆ§ (cid:0)Â¬che.depositRedemptionPr(alice) U
che.depositEscrowPr(carol)(cid:1)âˆ§
(cid:0)

[0,6âˆ†) apr.depositRedemptionPr(bob) â†’
[0,7âˆ†) apr.assetEscrowed(alice)(cid:1)

âˆ§ (cid:0)Â¬apr.assetEscrowed(alice) U
apr.depositRedemptionPr(bob)(cid:1)
âˆ§ (cid:0)

[0,9âˆ†) che.assetEscrowed(carol) â†’
[0,10âˆ†) che.hashlockUnlocked(alice)(cid:1)

âˆ§ (cid:0)Â¬che.hashlockUnlocked(alice) U
che.assetEscrowed(carol)(cid:1)âˆ§
(cid:0)Â¬ban.hashlockUnlocked(carol) U
che.hashlockUnlocked(alice)(cid:1)
âˆ§ (cid:0)Â¬apr.hashlockUnlocked(bob) U
che.hashlockUnlocked(alice)(cid:1)

Speciï¬cation to check conforming Alice does not have a
negative payoff:

Ï•alice safety = Ï•alice conform â†’

(cid:0) (cid:88)

amount â‰¥

(cid:88)

amount(cid:1)

TransTo = alice

TransFrom = alice

c) Hedged: Below shows the speciï¬cation to check that,
if a party is conforming and its escrowed asset is refunded,
then it gets a premium as compensation.
Ï•alice hedged = (cid:0)Ï•alice conform

âˆ§ apr.assetEscrowed(alice)(cid:1)
â†’ (cid:0) (cid:88)

amount

TransTo = alice

â‰¥

(cid:88)

amount

TransFrom = alice

+ apr.redemptionPremium.amount(cid:1)

2) Auction Protocol: In the auction example, we consider
Alice to be the auctioneer who would like to sell a ticket
(worth 100 ERC20 tokens) on the ticket (tckt) blockchain,
and Bob and Carol bid on the coin blockchain and the
winner should get the ticket and pay for the auctioneer what
they bid, and the loser will get refunded. We denote the time
that they reach an agreement of the auction as startT ime.
âˆ† is the maximum time for parties to observe the state
change of contracts by others and take a step to make changes
on contracts. Let T icketAuction be a contract managing
the â€œticketâ€ on the ticket blockchain, and CoinAuction be
a contract managing the bids on the coin blockchain. The
protocol is briefed as follows.

â€¢ Setup. Alice generates two hashes h(sb) and h(sc). h(sb)
is assigned to Bob and h(sc) is assigned to Carol. If
Bob is the winner, then Alice releases sb. If Carol is
the winner, then Alice releases sc. If both sb and sc are
released in T icketAuction, then the ticket is refunded.
If both sb and sc are released in CoinAuction , then all
coins are refunded. In addition, Alice escrows her ticket
as 100 ERC20 tokens in T icketAuction and deposits 2
tokens as premiums in CoinAuction.

â€¢ Step 1 (Bidding). Bob and Carol bids before âˆ† elapses

after startT ime.

â€¢ Step 2 (Declaration). Alice sends the winnerâ€™s secret to
both chains to declare a winner before 2âˆ† elapses after
startT ime.

â€¢ Step 3 (Challenge). Bob and Carol challenges if they
see two secrets or one secret missing, i.e. Alice cheats,
before 4âˆ† elapses after startT ime. They challenge by
forwarding the secret released by Alice using a path
signature scheme [3].

â€¢ Step 4 (Settle). After 4âˆ† elapses after startT ime, on
the CoinAuction, if only the hashlock corresponding
to the actual winner is unlocked, then the winnerâ€™s bid
goes to Alice. Otherwise, the winnerâ€™s bid is refunded.
Loserâ€™s bid is always refunded. If the winnerâ€™s bid is
refunded, all bidders including the loser gets 1 token as
premium to compensate them. On the T icketAuction, if
only one secret is released, then the ticket is transferred
to the corresponding party who is assigned the hash of
the secret. Otherwise, the ticket is refunded.

a) Liveness: Below shows the speciï¬cation to check that,
if all parties are conforming, the winner (Bob) gets the ticket
and the auctioneer gets the winnerâ€™s bid.

Ï•liveness = [0,âˆ†) coin.bid(bob)

âˆ§ [0,2âˆ†) coin.declaration(alice, sb)
âˆ§ [0,2âˆ†) tckt.declaration(alice, sb)
âˆ§ (4âˆ†,âˆ) coin.redeemBid(any)
âˆ§ (4âˆ†,âˆ) coin.refundPremium(any)
âˆ§ (cid:0)coin.bid(carol) â†’

[0,âˆ†) coin.refundBid(any)(cid:1)
âˆ§ tckt.redeemTicket(any)
âˆ§ Â¬coin.challenge(any)
âˆ§ Â¬tckt.challenge(any)

b) Safety: Below shows the speciï¬cation to check that,
if a party is conforming, this party does not end up worse off.
Take Bob (the winner) for example.

14

Speciï¬cation to deï¬ne Bob is conforming:

Ï•bob conform = [0,âˆ†) coin.bid(bob)

(cid:16)(cid:0)coin.declaration(alice, sc)âˆ¨

âˆ§
coin.challenge(carol, sc)(cid:1) â†’
âˆ§ (cid:0)tckt.declaration(alice, sc)âˆ¨
tckt.challenge(carol, sc)âˆ¨
tckt.challenge(bob, sc)(cid:1)(cid:17)

(cid:16)(cid:0)coin.declaration(alice, sb)âˆ¨

âˆ§
coin.challenge(carol, sb)(cid:1) â†’
âˆ§ (cid:0)tckt.declaration(alice, sb)âˆ¨
tckt.challenge(carol, sb)âˆ¨
tckt.challenge(bob, sb)(cid:1)(cid:17)

(cid:16)(cid:0)tckt.declaration(alice, sc)âˆ¨

âˆ§
tckt.challenge(carol, sc)(cid:1) â†’
âˆ§ (cid:0)coin.declaration(alice, sc)âˆ¨
coin.challenge(carol, sc)âˆ¨
coin.challenge(bob, sc)(cid:1)(cid:17)

(cid:16)(cid:0)tckt.declaration(alice, sb)âˆ¨

âˆ§
tckt.challenge(carol, sb)(cid:1) â†’
âˆ§ (cid:0)coin.declaration(alice, sb)âˆ¨
coin.challenge(carol, sb)âˆ¨
coin.challenge(bob, sb)(cid:1)(cid:17)

Speciï¬cation to deï¬ne Bob does not end up worse off:

Ï•bob safety = Ï•bob conform â†’

(cid:16)(cid:0)coin.refundBid(any)
âˆ§ coin.redeemPremium(any)(cid:1)âˆ¨

tckt.redeemTicket(any)

(cid:17)

c) Hedged: Below shows the speciï¬cation to check that,
if a party is conforming and its escrowed asset is refunded,
then it gets a premium as compensation.

Ï•bob hedged =

(cid:16)

Ï•bob conforming

âˆ§ (cid:0)tckt.refundTicket(alice)âˆ¨
tckt.redeemTicket(carol)(cid:1)(cid:17)
(cid:0)coin.refundBid(any)
âˆ§ coin.redeemPremium(any)(cid:1)

â†’

15

