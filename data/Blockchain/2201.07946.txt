Babylon:
Reusing Bitcoin Mining to Enhance Proof-of-Stake Security

Ertem Nusret Tas
Stanford University
nusret@stanford.edu

Fisher Yu
Hash Laboratories
fisher.yu@hashlabs.cc

David Tse
Stanford University
dntse@stanford.edu

Sreeram Kannan
University of Washington, Seattle
ksreeram@uw.edu

2
2
0
2

n
a
J

0
2

]

R
C
.
s
c
[

1
v
6
4
9
7
0
.
1
0
2
2
:
v
i
X
r
a

ABSTRACT
Bitcoin is the most secure blockchain in the world, supported by the
immense hash power of its Proof-of-Work miners, but consumes
huge amount of energy. Proof-of-Stake chains are energy-efficient,
have fast finality and accountability, but face several fundamental
security issues: susceptibility to non-slashable long-range safety
attacks, non-slashable transaction censorship and stalling attacks
and difficulty to bootstrap new PoS chains from low token valuation.
We propose Babylon, a blockchain platform which combines the
best of both worlds by reusing the immense Bitcoin hash power
to enhance the security of PoS chains. Babylon provides a data-
available timestamping service, securing PoS chains by allowing
them to timestamp data-available block checkpoints, fraud proofs
and censored transactions on Babylon. Babylon miners merge mine
with Bitcoin and thus the platform has zero additional energy cost.
The security of a Babylon-enhanced PoS protocol is formalized by
a cryptoeconomic security theorem which shows slashable safety
and liveness guarantees.

1 INTRODUCTION
1.1 From Proof-of-Work to Proof-of-Stake
Bitcoin, the most valuable blockchain in the world, is secured by a
Proof-of-Work protocol that requires its miners to solve hard math
puzzles by computing many random hashes. As of this writing,
Bitcoin miners around the world are computing in the aggregate
roughly 1.4 Ã— 1021 hashes per second. This hash power is the basis
of Bitcoinâ€™s security, as an attacker trying to rewrite the Bitcoin
ledger or censor transactions has to acquire a proportional amount
of hash power, making it extremely costly to attack the protocol.
However, this security also comes at a tremendous energy cost.

Many newer blockchains eschew the Proof-of-Work paradigm in
favor of energy-efficient alternatives, the most popular of which is
Proof-of-Stake (PoS). A prominent example is Ethereum, which is
currently migrating from PoW to PoS, a process 6 years in the mak-
ing. Other prominent PoS blockchains include Cardano, Algorand,
Solana, Polkadot, Cosmos Hub and Avalanche among others. In ad-
dition to energy-efficiency, another major advantage of many PoS
blockchains is their potential to hold protocol violators accountable
and slash their stake as punishment.

Contact author: DT.

1

1.2 Proof-of-Stake Security Issues
Early attempts at proving the security of PoS protocols were made
under the assumption that the majority or super-majority of the
stake belongs to the honest parties (e.g., [12, 16, 22, 23]). However,
modern PoS applications such as cryptocurrencies are increasingly
run by economic agents driven by financial incentives, that are not
a priori honest. To ensure that these agents follow the protocol
rules, it is crucial to incentivize honest behavior through economic
rewards and punishments for protocol-violating behavior. Towards
this goal, Buterin and Griffith [18] advocated the concept of ac-
countable safety, the ability to identify validators who have prov-
ably violated the protocol in the event of a safety violation. In lieu
of making an unverifiable honest majority assumption, this ap-
proach aims to obtain a cryptoeconomic notion of security for these
protocols by holding protocol violators accountable and slashing
their stake, thus enabling an exact quantification of the penalty
for protocol violation. This trust-minimizing notion of security is
central to the design of important PoS protocols such as Gasper
[19], the protocol supporting Ethereum 2.0, and Tendermint [15],
the protocol supporting the Cosmos ecosystem. However, there are
several fundamental limitations to achieving such trust-minimizing
cryptoeconomic security for PoS protocols:

(1) Safety attacks are not slashable: While a PoS protocol with
accountable safety can identify attackers, slashing of their
stake is not always possible. thus implying a lack of slash-
able safety. For example, a long-range history-revision attack
can be mounted using old coins after the stake is already with-
drawn and therefore cannot be slashed [12, 17, 23, 24]. These
attacks are infeasible in a PoW protocol like Bitcoin as the
attacker needs to counter the total difficulty of the existing
longest chain. In contrast, they become affordable in a PoS
protocol since the old coins have little value and can be bought
by the adversary at a small price. Such long-range attacks is a
long-known problem with PoS protocols, and there have been
several approaches to deal with them (Section 2). In Section
4.1, we show a negative result: no PoS protocol can provide
slashable safety without external trust assumptions. A typical
external trust assumption used in practice is off-chain social-
consensus checkpointing. But since this type of checkpointing
cannot be done very frequently, the stake lock-up period has
to be set very long (e.g., 21 days is a typical lock-up period for
Cosmos zones), reducing the liquidity of the system. Moreover,

 
 
 
 
 
 
social consensus cannot be relied upon in smaller blockchains
with an immature community.

the existing Bitcoin hash power, Babylon enhances the security of
PoS chains at no extra energy cost.

Ertem Nusret Tas, David Tse, Fisher Yu, and Sreeram Kannan

(2) Liveness attacks are not accountable or slashable: Exam-
ples of these attacks include protocol stalling and transaction
censorship. Unlike safety attacks where adversary double-signs
conflicting blocks, such attacks are hard to be held accountable
in a PoS protocol. For example, Ethereum 2.0 attempts to hold
protocol stalling accountable by slashing non-voting attesters
through a process called inactivity leak [14]. However, as we
discuss in Section 4.2, an attacker can create an alternative
chain and make it public much later, in which the honest at-
testers would not be voting and would therefore be slashed.
Moreover, there is no known mechanism to hold the censoring
of specific transactions accountable. In this context, we show
in Section 4.2 that accountable liveness, let alone slashable live-
ness, is impossible for any PoS protocol without external trust
assumptions.

(3) The bootstrapping problem: Even if a PoS protocol could
provide slashable security guarantees, the maximum financial
loss an adversary can suffer due to slashing does not exceed the
value of its staked coins. Thus, the cryptoeconomic security of
a PoS protocol is proportional to its token valuation. Many PoS
chains, particularly ones that support one specific application,
e.g., a Cosmos zone, start small with a low token valuation. This
makes it difficult for new blockchains to support high-valued
applications like decentralized finance or NFTs.

1.3 Reusing Bitcoin Mining to Provide

External Trust

Figure 1: The Babylon architecture. Babylon is a PoW chain
merge mined by Bitcoin miners and used by the PoS proto-
cols to obtain slashable security.

The PoS security issues above cannot be resolved without an exter-
nal source of trust. But a strong source of trust already exists in the
blockchain ecosystem: Bitcoin mining. Built on this observation, we
propose Babylon, a blockchain platform which reuses the existing
Bitcoin hash power to enhance the security for any PoS chain which
uses the platform (Figure 1). Babylon is a PoW blockchain on which
multiple PoS chains can post information and use the ordering and
availability of that information to obtain cryptoeconomic security
guarantees while retaining all of their desirable features such as fast
finalization. Babylon is mined by the Bitcoin miners via a technique
called merge mining [2, 3, 5], which enables the reuse of the same
hash power on multiple chains (cf. Appendix B). Thus, by reusing

2

1.4 Babylon: A Data-available
Timestamping Service

A major reason behind the security issues of PoS protocols de-
scribed in Section 1.2 is the lack of a reliable arrow of time. For
example, long-range attacks exploit the inability of late-coming
nodes to distinguish between the original chain and the adversaryâ€™s
history-revision chain that is publicized much later [23, 24]. Baby-
lon resolves these security limitations by providing a data-available
timestamping service to the PoS chains.

To obtain slashable security guarantees, full nodes of the PoS
protocols post commitments of protocol-related messages, e.g., fi-
nalized PoS blocks, fraud proofs, censored PoS transactions, onto
the Babylon PoW chain (Figure 2). Babylon checks if the messages
behind these commitments are available and provides a timestamp
for the messages by virtue of the location of its commitments in the
Babylon chain. This enables PoS nodes, including the late-coming
ones, to learn the time and order in which each piece of data was
first made public. PoS nodes can then use the timestamps on this
data in conjunction with the consensus logic of the native PoS
protocol to resolve safety conflicts, identify protocol violators and
slash them before they can withdraw their stake in the event of
safety or liveness violations. For example, whenever there is a safety
violation in a PoS protocol causing a fork, timestamps on Babylon
can be used to resolve the fork by choosing the branch with the
earlier timestamp (Figure 2). Whenever there is a proof of double-
signing or liveness violation recorded on Babylon, responsible PoS
participants can be irrefutably identified and slashed using the
information on Babylon.

To resolve the security issues of PoS protocols, Babylon, in ad-
dition to timestamping PoS data, has to guarantee that this data is
available, i.e., has been publicized to the honest PoS nodes, when it
is timestamped. Otherwise an adversary that controls the majority
stake can mount a non-slashable long range attack by posting suc-
cinct commitments of finalized, yet private PoS blocks on Babylon
and releasing the block data to the public much later, after the ad-
versarial stake is withdrawn (Figure 3). Thus, Babylon must also
provide the additional functionality of checking for the availability
of the PoS data it is timestamping. This functionality cannot be
satisfied by solutions that timestamp PoS data by posting its suc-
cinct commitments directly on Bitcoin or Ethereum [32], whereas
posting all of the data raises scalability concerns (cf. Section 2 for
more discussion). Thus, it necessitates a new PoW chain, Babylon,
whose miners are instructed to check for the availability of the
timestamped data in the view of the PoS nodes.

Babylon is minimalistic in the sense that it provides a data-
available timestamping service and no more. It does not execute the
transactions on the PoS chains, does not keep track of their partici-
pants and in fact does not even need to understand the semantics
of the PoS block content. It also does not store the PoS data. All
Babylon needs to do is to check the availability of the PoS data it is
timestamping and make this data public to the PoS nodes, which
can be done efficiently (eg. [7, 36]). This minimalism allows the

Babylon:
Reusing Bitcoin Mining to Enhance Proof-of-Stake Security

Figure 2: Timestamping on Babylon. Babylon PoW chain provides a record of the times events happen on the PoS chains, thus
enabling PoS nodes to resolve safety violations on the PoS chain. For instance, since the checkpoints of the blocks in the top
branch of the PoS chain appears earlier on Babylon than the checkpoints of the blocks in the bottom branch, the canonical
PoS chain in this case follows the top branch.

Figure 3: An adversary that controls a super-majority of stake finalizes PoS blocks on two conflicting chains. It keeps the
blocks on one of the chains, the attack chain, private, and builds the other, the canonical one in public. It also posts succinct
commitments of blocks from both chains to a timestamping service, e.g., Bitcoin or Ethereum. Commitments from the attack
chain are ignored by the nodes since their data is not available and might be invalid. Finally, after withdrawing its stake and
timestamping it on the PoW chain, the adversary publishes the private attack chain. From the perspective of a late-coming
node, the attack chain is the canonical one as it has an earlier timestamp on block ğ‘ and its contents are now available. However,
this is a safety violation. Moreover, as the adversary has withdrawn its stake, it cannot be slashed or financially punished.

scalability of Babylon to support the security of many PoS chains
simultaneously.

nodes, called validators, lock their funds for staking and run the
PoS consensus protocol by proposing and voting for blocks1.

1.5 High-level Description of the Protocol
The Babylon architecture consists of two major components: the
Babylon PoW chain (Babylon for short), merge-mined by Bitcoin
miners, hereafter referred to as Babylon miners, and the Babylon-
enhanced PoS protocols each maintained by a distinct set of PoS
nodes (nodes for short). The Babylon-enhanced PoS protocol is con-
structed on top of a standard accountably-safe PoS protocol which
takes PoS transactions as input and outputs a chain of finalized
blocks called the PoS chain.

Babylon miners are full nodes towards Babylon, i.e., download
and verify the validity of all Babylon blocks. They also download the
data whose commitments are sent to Babylon for timestamping, but
do not validate it. PoS full nodes download and verify the validity
of all PoS blocks in their respective chains. All PoS nodes act as
light clients towards Babylon. Thus, they rely on Babylon miners to
hand them valid Babylon blocks, and download only the messages
pertaining to their PoS protocol from Babylon. A subset of PoS full

PoS nodes can send different types of messages to Babylon for
timestamping (Figure 2). These messages are typically succinct
commitments of PoS data such as finalized PoS blocks, censored
transactions and fraud proofs identifying misbehaving PoS val-
idators. Finalized PoS blocks whose commitments are included in
Babylon are said to be checkpointed by the Babylon block that
includes the commitment.

PoS nodes use the timestamped information on Babylon to re-
solve safety violations and slash protocol violators as described
below (cf. Section 5 for details):
(1) Fork-choice rule: If there is a fork on the PoS chain due to
a safety violation, then the canonical chain of the Babylon-
enhanced PoS protocol follows the fork whose first check-
pointed block has the earlier timestamp on Babylon (Figure 2).
Thus, Babylon helps resolve safety violations on the PoS chains.

1Not every PoS full node is necessarily a validator. Full nodes that are not validators
still download PoS blocks and process their transactions to obtain the latest PoS state.

3

(2) Stake withdrawal and slashing for double-signing: A val-
idator can input a withdrawal request into the PoS protocol
to withdraw its funds locked for staking. A stake withdrawal
request is granted, as a transaction in a later PoS block, if the
PoS block containing the request is timestamped, i.e. check-
pointed, by a Babylon block that is at least ğ‘˜ğ‘¤-block deep in
the longest Babylon chain and no fraud proof of the valida-
tor double-signing has appeared on Babylon (Figure 5). On
the other hand, if a fraud proof against this validator exists,
then the validator is slashed. Here, ğ‘˜ğ‘¤ determines the stake
withdrawal delay.

(3) Slashing for transaction censoring: If a node believes that
a transaction is being censored on the PoS chain, it can submit
the transaction to Babylon along with a censorship complaint.
Upon observing a complaint on the Babylon chain, validators
stop proposing or voting for PoS blocks that do not contain
the censored transaction. PoS blocks excluding the censored
transaction and checkpointed on Babylon after the censorship
complaint are labeled as censoring. Validators that propose or
vote for censoring blocks are slashed.
Although Babylon is a timestamping service, granularity of
time as measured by its blocks depends on the level of its se-
curity. For instance, if the adversary can reorganize the last ğ‘˜ğ‘
blocks on the Babylon chain, it can delay the checkpoints of
PoS blocks sent to the miners before a censorship complaint
until after the complaint appears on Babylon. Thus, to avoid
slashing honest validators that might have voted for these
blocks, PoS blocks checkpointed by the first ğ‘˜ğ‘ Babylon blocks
following a censorship complaint are not labelled as censoring.
Since this gives the adversary an extra ğ‘˜ğ‘ blocktime to censor
transactions, ğ‘˜ğ‘ is an upper bound on the worst-case finaliza-
tion latency of transactions when there is an active censorship
attack.

(4) Slashing for stalling: If a PoS node believes that the growth
of the PoS chain has stalled due to missing proposals or votes,
it submits a stalling evidence to Babylon. Upon observing a
stalling evidence, validators record proposals and votes ex-
changed over the next round of the PoS protocol on Babylon.
Those that fail to propose or vote, thus whose protocol mes-
sages do not appear on Babylon within ğ‘˜ğ‘ blocks of the stalling
evidence, are slashed. Again, the grace period of ğ‘˜ğ‘ blocks
protects honest validators from getting slashed in case the
adversary delays their messages on Babylon.

We note that the Babylon checkpoints of finalized PoS blocks
are primarily used to resolve safety violations and slash adversarial
validators in the event of safety and liveness attacks. Hence, Babylon
does not require any changes to the native finalization rule of the
PoS protocols using its services, and preserves their fast finality
propert in the absence of censorship or stalling attacks.

Majority of the Babylon-specific add-ons used to enhance PoS
protocols treat the PoS protocol as a blackbox, thus are applicable
to any propose-vote style accountably-safe PoS protocol. In fact,
the only part of the Babylon-specific logic in Section 5 that uses
the Tendermint details is the part used to slash stalling attacks on
liveness. Hence, we believe that Babylon can be generalized to apply

4

Ertem Nusret Tas, David Tse, Fisher Yu, and Sreeram Kannan

to PoS protocols such as PBFT [20], HotStuff [35], and Streamlet
[21].

1.6 Security Theorem
Using Babylon, accountably-safe PoS protocols can overcome the
limitations highlighted in Section 1.2 and obtain slashable security.
To demonstrate this, we augment Tendermint [16] with Babylon-
specific add-ons and state the following security theorem for Babylon-
enhanced Tendermint. Tendermint was chosen as it provides the
standard accountable safety guarantees [15].

The Babylon chain is said to be secure for parameter ğ‘Ÿ , if the
ğ‘Ÿ -deep prefixes of the longest Babylon chains in the view of honest
nodes satisfy safety and liveness as defined in [25]. A validator ğ‘£
is said to become slashable in the view of an honest node if ğ‘£ was
provably identified as a protocol violator and has not withdrawn its
stake in the nodeâ€™s view. Formal definitions of safety and liveness for
the Babylon-enhanced PoS protocols, slashability for the validators
and security for the Babylon chain are given in Section 3.

Theorem 1. Consider a synchronous network where message de-
lays between all nodes are bounded, and the average time between
two Babylon blocks is set to be much larger than the network delay
bound. Then, Babylon-enhanced Tendermint satisfies the following
security properties if there is at least one honest PoS node at all times:

â€¢ Whenever the safety of the PoS chain is violated, either of the

following conditions must hold:

â€“ S1: More than 1/3 of the active validator set becomes slash-

able in the view of all honest PoS nodes.

â€“ S2: Security of the Babylon chain is violated for parameter

ğ‘˜ğ‘¤/2.

â€¢ Whenever the liveness of the PoS chain is violated for a duration
of more than Î˜(ğ‘˜ğ‘ ) block-time as measured in mined Babylon
blocks, either of the following conditions hold:

â€“ L1: More than 1/3 of the active validator set becomes slash-

able in the view of all honest PoS nodes.

â€“ L2: Security of the Babylon chain is violated for parameter

ğ‘˜ğ‘ /2.

Proof of Theorem 1 is given in Appendix D. Note that this is a
cryptoeconomic security theorem as it explicitly states the slashing
cost to the attacker to cause a safety or liveness violation (condi-
tions S1 and L1 respectively). There is no trust assumption on the
PoS validators such as having an honest majority. There are trust
assumptions on the Babylon miners (as reflected by conditions S2
and L2), but these trust assumptions are also quantifiable in terms
of the economic cost of the attacker to acquire the hash power to
reorganize certain number of Babylon blocks.
Specific implications of the theorem are:

(1) Slashable safety: Conditions S1 and S2 together say that,
when the PoS chain is supported by Babylon, the attacker
must reorganize ğ‘˜ğ‘¤/2 blocks on Babylon if it does not want
to be slashed for a safety attack on the PoS chain. Since ğ‘˜ğ‘¤ is
the stake withdrawal delay and determines the liquidity of the
staked funds, S2 quantifies the trade-off between stake liquidity
and the attackerâ€™s cost. When reorganization cost of Babylon is
high as is the case for a chain merge-mined with Bitcoin, this

Babylon:
Reusing Bitcoin Mining to Enhance Proof-of-Stake Security

trade-off also implies much better liquidity than in the current
PoS chains (e.g., 21 days in Cosmos).

(2) Slashable liveness: Conditions L1 and L2 together say that,
with Babylonâ€™s support, the attacker must reorganize ğ‘˜ğ‘ /2
blocks on Babylon if it does not want to be slashed for a live-
ness attack on the PoS chain. Since ğ‘˜ğ‘ is the worst-case latency
for the finalization of transactions under an active liveness at-
tack, L2 quantifies the trade-off between the worst-case latency
under attack and the attackerâ€™s cost.

1.7 Bootstapping New PoS Chains
In a PoS protocol with slashable security, the attack cost is deter-
mined by the token value (cf. Section 1.2). On protocols with low
initial valuation, this low barrier to attack pushes away high-valued
applications that would have increased the token value. To break
this vicious cycle, new PoS protocols can use Babylon as a second
layer of finalization. For instance, PoS nodes can require the check-
point of a finalized PoS block to become, e.g., ğ‘˜ blocks deep in the
Babylon PoW chain before they consider it finalized. Then, to vio-
late the security of the ğ‘˜-deep and finalized PoS blocks, the attacker
must not only forgo its stake due to slashing, but also acquire the
hash power necessary to reorganize Babylon for ğ‘˜ blocks. For this
purpose, it has to control over half of the total hash power for a
duration Î˜(ğ‘˜) blocks2[9]. Thus, by increasing ğ‘˜, the attack cost can
be increased arbitrarily. Through this extra protection provided by
Babylon, newer PoS protocols can attract high value applications
to drive up their valuation.

Note that a large ğ‘˜ comes at the expense of finalization latency,
which no longer benefits from the fast finality of the PoS protocol.
This tradeoff between latency and the parameter ğ‘˜ can be made
individually or collectively by the PoS nodes in a manner that suits
the nodesâ€™ or the protocolâ€™s security needs. Moreover, once the
valuation of the protocol grows sufficiently large, the parameter ğ‘˜
can be decreased in proportion to the slashing costs, and eventually
removed altogether, enabling the PoS protocols to regain fast finality
after a quick bootstrapping period.

1.8 Outline
Section 2 surveys the related work and analyzes alternative times-
tamping solutions in terms of their ability to provide slashable
security. Section 3 introduces the model and the formal definitions
used throughout the paper. Section 4 formalizes the impossibility re-
sults for slashable safety and accountable liveness of PoS protocols.
Sections 5 and 6 give a detailed description of a Babylon-enhanced
PoS protocol, and discuss Babylonâ€™s potential for scalability. Fi-
nally, Section 7 provides a reference design for Babylon-enhanced
Tendermint using Cosmos SDK.

2 RELATED WORKS
2.1 Long-range Attacks
Among all the PoS security issues discussed in Section 1.2, long
range history revision attacks is the most well-known, [12, 17, 23,
24] and several solutions have been proposed: 1) checkpointing

2Reorganizing one Bitcoin block costs about USD $0.5M, as of this writing [4]. Perhaps
more importantly, 0% of this hash power is available on nicehash.com.

5

via social consensus (e.g., [11, 13, 17, 23]); 2) use of key-evolving
signatures (e.g., [12, 22, 27]); 3) use of verifiable delay functions, i.e.,
VDFs (e.g., [34]); 4) timestamping on an existing PoW chain like
Ethereum [32] or Bitcoin [10].

Social Consensus. Social consensus refers to a trusted com-
2.1.1
mittee of observers, potentially distinct from the PoS nodes, which
periodically checkpoint finalized PoS blocks that have been made
available. It thus attempts to prevent long range attacks by making
the adversarial blocks that are kept private distinguishable from
those on the canonical PoS chain that contain checkpoints.

Social consensus suffers from vagueness regarding the size and
participants of the checkpointing committee. For instance, a small
oligarchy of trusted nodes would lead to a centralization of trust,
anathema to the spirit of distributed systems. Conversely, a large
committee would face the problem of reaching consensus on check-
points in a timely manner. Moreover, the question of who belongs
in the committee complicates the efforts to quantify the trust as-
sumptions placed on social consensus, in turn making any security
valuation prone to miscalculations. For instance, a re-formulation of
Theorem 1 in this setting would claim slashable security as long as
the social consensus checkpoints are â€˜trustworthyâ€™, without much
insight on how to value this trust in economic terms. In comparison,
the trust placed on Babylon is quantifiable and equals the cost of
acquiring the hash power necessary to reorganize the Babylon PoW
chain, which is well-known [4].

2.1.2 Key-evolving Signatures. Use of key-evolving signatures re-
quires validators to forget old keys so that a history revision attack
using old coins cannot be mounted. However, an adversarial ma-
jority can always record their old keys and use them to attack the
canonical chain by creating a conflicting history revision chain
once they withdraw their stake. This way, they can cause a safety
violation, yet upon detection, avoid any slashing of the stake as
it was already withdrawn. Hence, key-evolving signatures cannot
prevent long range attacks without an honest majority assumption,
thus cannot provide slashable security.

Security has been shown for various PoS protocols [12, 22] using
key-evolving signatures under the honest majority assumption,
which ensures that the majority of validators willingly forget their
old keys. However, this is not necessarily incentive-compatible as
there might be a strong incentive for the validators to remember
the old keys in case they become useful later on. Thus, key-evolving
signatures render the honest majority assumption itself question-
able by asking honest validators for a favor which they may be
tempted to ignore.

2.1.3 VDFs. As was the case with key-evolving signatures, VDFs
cannot prevent long range attacks without the honest majority as-
sumption, thus cannot provide slashable security. For instance, an
adversarial majority can build multiple conflicting PoS chains since
the beginning of time, and run multiple VDF instances simultane-
ously for both the public PoS chain and the attack chains that are
kept private. After withdrawing their stakes, these validators can
publish the conflicting attack chains with the correct VDF proofs.
Thus, VDFs cannot prevent an adversarial majority from causing a
safety violation at no slashing cost.

Another problem with VDFs is the possibility of finding faster
functions [8], which can then be used to mount a long range attack,
even under an honest majority assumption.

2.1.4 Timestamping on Bitcoin or Ethereum. Timestamping directly
on an existing PoW chain, e.g., Bitcoin [10] or Ethereum [32] suffers
from the fact that these PoW chains do not check for the availability
of the committed data in the view of the PoS nodes, thus, as a solu-
tion, is vulnerable to the attack on Figure 3. To mitigate the attack,
either all of the committed PoS data, e.g., all the PoS blocks, must
be posted on the PoW chain to guarantee their availability, or an
honest majority must certify the timestamps to prevent unavailable
PoS blocks from acquiring timestamps on the PoW chain.

The first mitigation creates scalability issues since in this case,
miners must not only verify the availability of the PoS data, which
can be done through lightweight methods such as data availability
sampling [7, 36], but also store the data of potentially many different
PoS protocols indefinitely.

The second mitigation was implemented by [32] through an
Ethereum smart contract which requires signatures from over 2/3
of the PoS validators to timestamp changes in the validator sets.
Since [32] assumes honest majority, signatures from 2/3 of the
validators imply that the signed changes in the validator set are
due to transactions within available and valid PoS blocks. However,
the second mitigation cannot be used to provide cryptoeconomic
security without trust assumptions on the validators. In contrast,
Babylon miners are modified to do data availability checks, which
enables Babylon to rely on the miners themselves rather than an
honest majority of PoS validators for data availability.

2.2 Hybrid PoW-PoS Protocols
A Babylon-enhanced PoS protocol is an example of a hybrid PoW-
PoS protocol, where consensus is maintained by both PoS validators
and PoW miners. One of the first such protocols is the Casper FFG
finality gadget used in conjunction with a longest chain PoW proto-
col [18]. The finality gadget is run by PoS validators as an overlay
to checkpoint and finalize blocks in an underlay PoW chain, where
blocks are proposed by the miners. The finality gadget architec-
ture is also used in many other PoS blockchains, such as Ethereum
2.0 [19] and Polkadot [33]. Babylon can be viewed as a "reverse"
finality gadget, where the miners run an overlay PoW chain to
checkpoint the underlay PoS chains run by their validators. Our
design of Babylon that combines an existing PoW protocol with
PoS protocols also leverages off insights from a recent line of work
on secure compositions of protocols [28, 29, 31].

2.3 Blockchain Scaling Architectures
Scaling blockchains is a longstanding problem. A currently popular
solution on Ethereum and other platforms is the shift of transaction
execution from a base blockchain to rollups, which execute state
transitions and post state commitments on the blockchain. Emerg-
ing projects like Celestia [6] take this paradigm further by removing
execution entirely from the base blockchain and having it provide
only data availability and ordering. In contrast, the main goal of
the present work is not on scalability but on enhancing existing
or new PoS protocols with slashable security. While rollups derive
their security entirely from the base blockchain, the PoS protocols

Ertem Nusret Tas, David Tse, Fisher Yu, and Sreeram Kannan

are autonomous and have their own validators to support their
security. In this context, the main technical challenge of this work
is how to design the architecture such that the Babylon PoW chain
augments the existing security of the PoS protocols with slashable
security guarantees. Nevertheless, to scale up our platform to sup-
port many PoS protocols, we can leverage off scaling techniques
such as efficient data availability checks [7, 36] and sharding [1].
More discussions can be found in Section 6.

3 MODEL
Validators: PoS nodes that run the PoS consensus protocol are called
validators. Each validator is equipped with a unique cryptographic
identity. Validators are assumed to have synchronized clocks.

There are two sets of validators: passive and active. Validators
stake a certain amount of coins to become active and participate
in the consensus protocol. Although staked coins cannot be spent,
active validators can send withdrawal requests to withdraw their
coins. Once a withdrawal request by an active validator is finalized
by the PoS protocol, i.e., included in the PoS chain, the validator
becomes passive and ineligible to participate in the consensus pro-
tocol. The passive validator is granted permission to withdraw its
stake and spend its funds once a withdrawal delay period has passed
following the finalization of the withdrawal request.

Let ğ‘› denote the total number of validators that are active at
any given time. The number of passive validators is initially zero
and grows over time as active validators withdraw their stakes and
become passive.

Environment and Adversary: Transactions are input to the valida-
tors by the environment Z. Adversary A is a probabilistic poly-time
algorithm. A gets to corrupt a certain fraction of the validators
when they become active, which are then called adversarial valida-
tors. It can corrupt any passive validator.

Adversarial validators surrender their internal state to the ad-
versary and can deviate from the protocol arbitrarily (Byzantine
faults) under the adversaryâ€™s control. The remaining validators are
called honest and follow the PoS protocol as specified.

Networking: Validators can send each other messages. Network is
synchronous, i.e. A is required to deliver all messages sent between
honest validators, miners and nodes within a known upper bound
Î”.

Accountability: We assume that the PoS protocol supported by
Babylon has an accountable safety resilience of ğ‘“a (parameter ğ‘‘ as
defined in [26]), i.e., ğ‘“a adversarial validators (that are potentially
passive) are irrefutably identified by all PoS nodes as having vio-
lated the protocol in the event of a safety violation, and no honest
validator can be identified as a protocol violator. Moreover, for the
culpable validators, PoS nodes can create an irrefutable fraud proof
showing that they violated the protocol.

Safety and Liveness for the PoS Protocols: Let PoSLOGğ‘¡

ğ‘– denote
the chain of finalized PoS blocks, i.e., the PoS chain, in the view of
a node ğ‘– at time ğ‘¡. Then, safety and liveness for the PoS protocols
are defined as follows:

Definition 1. Let ğ‘‡fin be a polynomial function of the security
parameter ğœ of the PoS protocol Î . We say that Î  is ğ‘‡fin-secure if the
PoS chain satisfies the following properties:

6

Babylon:
Reusing Bitcoin Mining to Enhance Proof-of-Stake Security

â€¢ Safety: For any time slots ğ‘¡, ğ‘¡ â€² and honest PoS nodes ğ‘–, ğ‘—, either
ğ‘— or vice versa. For any honest
for all times ğ‘¡ and

ğ‘– is a prefix of PoSLOGğ‘¡ â€²

ğ‘– is a prefix of PoSLOGğ‘¡ â€²
ğ‘–

PoSLOGğ‘¡
PoS node ğ‘–, PoSLOGğ‘¡
ğ‘¡ â€² such that ğ‘¡ â‰¤ ğ‘¡ â€².

â€¢ Tfin-Liveness: If Z inputs a transaction tx to the validators at
some time ğ‘¡, then, tx appears at the same position in PoSLOGğ‘¡ â€²
ğ‘–
for any time ğ‘¡ â€² â‰¥ ğ‘¡ + ğ‘‡fin and for any honest PoS node ğ‘–.
A PoS protocol is said to satisfy ğ‘“s-safety or ğ‘“l-ğ‘‡fin-liveness if
it satisfies safety or ğ‘‡fin-liveness whenever the number of active
adversarial validators is less than or equal to ğ‘“s or ğ‘“l respectively.
ğ‘¡
ğ‘– denote
Safety and Liveness for the Babylon Chain: Let PoWChain
the longest, i.e., canonical, Babylon chain in the view of a miner
or PoS node ğ‘– at time ğ‘¡. Then, safety and liveness for the Babylon
chain are defined as follows:

Definition 2 (From [25]). Babylon is said to be secure for pa-

rameter ğ‘Ÿ â‰¥ 1, ğ‘Ÿ âˆˆ Z, if it satisfies the following two properties:

â€¢ Safety: If a transaction tx appears in a block which is at least
ğ‘Ÿ -deep in the longest Babylon chain of an honest node or miner,
then, tx will eventually appear and stay at the same position in
the longest Babylon chain of all honest nodes or miners forever.
â€¢ Liveness: If a valid transaction tx is received by all honest miners
for more than ğ‘Ÿ block-time, then tx will eventually appear at an
ğ‘Ÿ -deep block in the longest Babylon chain of all honest nodes or
miners. No invalid transaction ever appears at an ğ‘Ÿ -deep block in
the longest Babylon chain held by any honest node or miner.

Thus, if Babylon satisfies security for the parameter ğ‘Ÿ , ğ‘Ÿ -deep pre-
fixes of the longest chains held by the honest nodes are consistent
with each other, grow monotonically, and transactions received by
the honest miners for more than ğ‘Ÿ block-time enter and stay in the
longest Babylon chain observed by the honest nodes forever.

Slashability: Slashing refers to the process of financial punish-

ment for the active validators detected as protocol violators.

Definition 3. A validator v is said to be slashable in the view of

a PoS node c if,

(1) c provably identified v as having violated the protocol for the

first time at some time ğ‘¡, and,

(2) v has not withdrawn its stake in câ€™s view by time ğ‘¡.

If a validator v is observed to be slashable by all honest PoS
nodes, no transaction that spends the coins staked by v will be
viewed as valid by the honest PoS nodes.

4 IMPOSSIBILITY RESULTS FOR

PROOF-OF-STAKE PROTOCOLS
4.1 Safety Violation is not Slashable
Without additional trust assumptions, PoS protocols are susceptible
to various flavors of long range attacks, also known as foundersâ€™
attack, posterior corruption or costless simulation. In this context,
[23, Theorem 2] formally shows that even under the honest ma-
jority assumption for the active validators, PoS protocols cannot
have safety due to long range attacks without additional trust as-
sumptions. Since slashable safety is intuitively a stronger result
than guaranteeing safety under the honest majority assumption,

7

Figure 4: Inactivity leak attack. At the top is adversaryâ€™s
private attack chain. At the bottom is the public canonical
chain built by the honest validators. Due to inactivity leak,
honest & adversarial validators lose their stake on the attack
and canonical chains respectively. A late-coming node can-
not differentiate the canonical and attack chains.

[23, Theorem 2] thus rules out any possibility of providing PoS pro-
tocols with slashable safety without additional trust assumptions.
This observation is formally stated by Theorem 3 in Appendix A.

4.2 Liveness Violation is not Accountable
Without additional trust assumptions, PoS nodes cannot identify
any validator to have irrefutably violated the PoS protocol in the
event of a liveness violation, even under a synchronous environ-
ment. To illustrate the intuition behind this claim, we show that
inactivity leak [14], proposed as a financial punishment for inactive
Ethereum 2.0 validators, can lead to the slashing of honest valida-
torsâ€™ stake with non-negligible probability. Consider the setup on
Figure 4, where adversarial validators build a private attack chain
that forks off the canonical one and stop communicating with the
honest validators. As honest validators are not privy to the adver-
saryâ€™s actions, they cannot vote for the blocks on the attack chain.
Thus, honest validators are inactive from the perspective of the
adversary and lose their stake on the attack chain due to inactivity
leak. On the other hand, as the adversarial validators do not vote
for the blocks proposed by the honest ones, they too lose their stake
on the public, canonical chain (Figure 4). Finally, adversary reveals
its attack chain to a late-coming node which observes two con-
flicting chains. Although the nodes that have been active since the
beginning of the attack can attribute the attack chain to adversarial
action, a late-coming node could not have observed the attack in
progress. Thus, upon seeing the two chains, it cannot determine
which of them is the canonical one nor can it irrefutably identify
any validator slashed on either chains as adversarial or honest.

To formalize the impossibility of accountable liveness for PoS
protocols, we extend the notion of accountability to liveness viola-
tions and show that no PoS protocol can have a positive accountable
liveness resilience, even under a synchronous network with a static
set of ğ‘› active validators that never withdraw their stake. For this
purpose, we adopt the formalism of [26] summarized below: During
the runtime of the PoS protocol, validators exchange messages, e.g.,
blocks or votes, and each validator records its view of the protocol
by time ğ‘¡ in an execution transcript. If a node observes that ğ‘‡fin-
liveness is violated, i.e., a transaction input to the validators at some
time ğ‘¡ by Z is not finalized in the PoS chain in its view by time
ğ‘¡ + ğ‘‡fin, it invokes a forensic protocol: The forensic protocol takes

transcripts of the validators as input, and outputs an irrefutable
proof that a subset of them have violated the protocol rules. This
proof is sufficient evidence to convince any node, including late-
coming ones, that the validators identified by the forensic protocol
are adversarial.

Forensic protocol interacts with the nodes in the following way:
Upon observing a liveness violation on the PoS chain, a node asks
the validators to send their transcripts. It then invokes the forensic
protocol with the transcripts received from the validator. Finally,
through the forensic protocol, it constructs the irrefutable proof of
protocol violation by the adversarial validators, and broadcasts this
proof to all other nodes.

Using the formalization above, we next define accountable live-
ness resilience and state the impossibility theorem for accountable
liveness on PoS protocols in the absence of additional trust assump-
tions:

Definition 4. ğ‘‡fin-accountable liveness resilience of a protocol
is the minimum number ğ‘“ of validators identified by the forensic
protocol to be protocol violators when ğ‘‡fin-liveness of the protocol is
violated. Such a protocol provides ğ‘“ -ğ‘‡fin-accountable-liveness.

Theorem 2. Without additional trust assumptions, no PoS proto-
col provides both ğ‘“a-ğ‘‡fin-accountable-liveness and ğ‘“s-safety for any
ğ‘“a, ğ‘“s > 0 and ğ‘‡fin < âˆ.

Proof is presented in Appendix A and generalizes the indistin-
guishability argument for the conflicting chains from the inactivity
leak attack. It rules out any possibility of providing accountable
liveness for PoS protocols even under a Î”-synchronous network
and a static set of active validators.

A corollary of Theorem 2 is that PoS protocols cannot have a

positive slashable liveness resilience:

Definition 5. ğ‘‡fin-slashable liveness resilience of a protocol is
the minimum number ğ‘“ of validators that are slashable in the view
of all PoS nodes per Definition 3 when ğ‘‡fin-liveness of the protocol is
violated. Such a protocol provides ğ‘“ -ğ‘‡fin-slashable-liveness.

Corollary 1. Without additional trust assumptions, no PoS pro-
tocol provides both ğ‘“s-safety and ğ‘“l-ğ‘‡fin-slahable-liveness for any
ğ‘“s, ğ‘“l > 0 and ğ‘‡fin < âˆ.

Proof of Corollary 1 follows from the fact that accountable live-
ness resilience of PoS protocols is zero without additional trust
assumptions.

5 PROTOCOL
In this section, we specify how to obtain slashable security for any
accountably-safe PoS protocol using Babylon-specific add-ons. Un-
less stated otherwise, the accountably-safe PoS protocol is treated
as a black-box which takes PoS transactions as its input and out-
puts a chain of finalized PoS blocks containing these transactions.
We assume that the consensus-related messages required to verify
finalization of PoS blocks can be accessed by viewing the contents
of the child blocks.

For concreteness, sections below focus on the interaction be-

tween the Babylon chain and a single PoS protocol.

8

Ertem Nusret Tas, David Tse, Fisher Yu, and Sreeram Kannan

5.1 Handling of Commitments by Babylon
PoS nodes timestamp messages by posting their commitments on
Babylon. A commitment â„ is a succinct representation of a piece of
data ğ·3. Babylon miners receive commitments from the PoS nodes
as pairs (tx, ğ·), where tx is a Babylon transaction that contains the
commitment â„, and ğ· is the associated data. Upon receiving such a
pair, miners validate â„ against ğ·, i.e., check if â„ is a succinct commit-
ment of ğ·, on top of other transaction validation procedures for tx.
However, since Babylon is a generic data-available timestamping
service, miners do not check the syntax or semantics of the data
ğ·. If the validation succeeds, miners consider the commitment â„
valid and include tx in the next Babylon block mined. They do not
include the data ğ· in the Babylon blocks.

Whenever a miner propagates a Babylon transaction to its peers,
either directly or as part of the block body, it also attaches the
associated data, so that the peers receiving the transaction can also
validate its availability. Since PoS nodes act as light clients of the
Babylon chain and are connected to the peer-to-peer network of the
Babylon miners, they also obtain the data broadcast by the miners.
This ensures the availability of data across all honest PoS nodes
once its commitment is validated and published by the Babylon
miners.

Miners merge-mine the Babylon chain following the longest
chain rule (cf. Appendix B for more details). A Babylon block is
said to be valid in the view of a miner if the Babylon transactions
included in the block are valid in the minerâ€™s view.

5.2 Generation and Validation of

Commitments

There are two types of commitments: message commitments and
checkpoints. Message commitment refers to the hash of the whole
message. For example, to timestamp a list of censored transactions,
a PoS node sends the hash of the list to the miners as the message
commitment â„ and the whole list as the data ğ· (Algorithm 2). Then,
to validate the commitment, miners and PoS nodes check if the
hash of the data matches the commitment (Algorithms 1 and 3).

Checkpoints are commitments of finalized PoS blocks. A single
checkpoint can commit to multiple consecutive blocks from the
same PoS chain. To post a checkpoint on Babylon for consecutive
blocks ğµ1, ..., ğµğ‘›, a PoS node first extracts the transaction roots txrğ‘– ,
ğ‘– = 1, .., ğ‘›, from the header ğµğ‘– .header of each block (Algorithm 2).
Then, using a binding hash function ğ» , it calculates the following
commitment4:

â„ = ğ» (ğµ1.header||...||ğµğ‘›.header||txr1||...||txrğ‘›).

(1)

Finally, it sends the commitment â„, i.e., the checkpoint, to the min-
ers along with the data ğ· which consists of (i) the block headers
ğµ1.header, .., ğµğ‘›.header, (ii) the block bodies, and (iii) the transac-
tion roots txr1, .., txrğ‘› separately from the headers.

Upon receiving a checkpoint or observing one on Babylon, min-
ers and PoS nodes parse the associated data ğ· into the block headers,

3In a real-world implementation, commitments will also carry metadata such as a
PoS chain identifier, submitterâ€™s signature and public key. The metadata will not be
validated by the Babylon miners.
4In a real-world application, commitment also contains the header of block ğµğ‘›+1 as it
contains the signatures necessary to verify the finalization of block ğµğ‘› . We omit this
fact above for brevity.

Babylon:
Reusing Bitcoin Mining to Enhance Proof-of-Stake Security

Figure 5: Delayed granting of withdrawal request and slashing. A validator for the PoS chain-1 sends a stake withdrawal
request to its chain which is captured by the PoS block A. Block A is in turn checkpointed by the Babylon block b. This stake
withdrawal request will only be granted and executed at a later PoS block B, where B is generated by a validator that observes
the checkpoint of block A in block b become at least ğ‘˜ğ‘¤ deep in Babylon and that there is no fraud proof. On the other hand,
the validator for the PoS chain-2 is not granted its withdrawal request and is slashed, since a fraud proof appears on Babylon
before block b becomes ğ‘˜ğ‘¤-deep.

Figure 6: Slashing for censoring. A censored transaction tx is submitted to Babylon through a censorship complaint, and
included in a Babylon block ğ‘. Suppose A is the last PoS block honest nodes proposed or voted for before they observed the
censorship complaint on Babylon. Let ğ‘ â€² denote the first Babylon block containing a checkpoint and extending ğ‘ by at least 2ğ‘˜ğ‘
blocks. Since finalized PoS blocks are checkpointed frequently on Babylon, A will be checkpointed by ğ‘ â€², or a Babylon block in
its prefix. Then, any PoS block, e.g., B, checkpointed by a Babylon block following ğ‘ â€² must have been proposed or voted upon
by the validators after they have observed the censorship complaint, and must include tx. However, B, which is checkpointed
by ğ‘ â€²â€² extending ğ‘ â€², does not contain tx, thus, is a censoring block. Hence, validators that have proposed and voted for B will
be slashed for censorship. Here, the 2ğ‘˜ğ‘ grace period on Babylon between ğ‘ and ğ‘ â€² ensures that the honest validators are not
slashed for voting upon PoS blocks excluding the censored transactions, before they observed the censorship complaint.

block bodies and transaction roots. Miners view the commitment as
valid if (i) expression (1) calculated using ğµ1.header, .., ğµğ‘›.header
and txr1, .., txrğ‘› matches the received commitment, and (ii) the
roots txr1, .., txrğ‘› commit to the transactions in the bodies of the
blocks ğµ1, .., ğµğ‘› (Algorithm 1). PoS full nodes view the commitment
as valid if conditions (i) and (ii) above are satisfied, (iii) txr1, .., txrğ‘›
are the same as the transaction roots within the block headers
ğµ1.header, .., ğµğ‘›.header and (iv) the checkpointed PoS blocks are
finalized in the given order within the PoS chain in their view (Al-
gorithm 3). Although each header already contains the respective
transaction root, a Babylon miner does not necessarily know the
header structure of different PoS protocols. Thus, miners receive

transaction roots separately besides the block headers and bodies.
Note that miners cannot check if the transaction root txrğ‘– it got
for a block ğµğ‘– is the same as the root within the header ğµğ‘– .header.
However, honest PoS nodes can detect any discrepancy between
the transaction roots in the headers and those given as part of the
data ğ·, and ignore incorrect commitments.

Checkpoints are designed to enable light clients towards the
PoS protocol to identify the checkpointed PoS blocks when they
observe a commitment on Babylon. Unlike full nodes, PoS light
clients do not download bodies of PoS blocks, thus cannot check if
txrğ‘– commits to the body of ğµğ‘– . However, since they do download
PoS block headers, these light clients can extract the transaction

9

Ertem Nusret Tas, David Tse, Fisher Yu, and Sreeram Kannan

Figure 7: Slashing for stalling. A stalling evidence for height â„, where validators failed to finalize any PoS block, is submitted
to Babylon and captured by the Babylon block ğ‘. Upon observing ğ‘ with a stalling evidence, validators enter a new Tendermint
round whose messages are recorded on Babylon. During this round, they submit their proposals, prevotes and precommits to
Babylon. Validators, whose proposals do not appear on Babylon between ğ‘ and ğ‘1, are deemed to be unresponsive and slashed
for stalling the protocol. Similarly, validators, whose votes for the proposal selected from the interval [ğ‘, ğ‘1) are missing
between ğ‘1 and ğ‘2, are slashed. Here, the ğ‘˜ğ‘ block intervals between ğ‘, ğ‘1 and ğ‘2 ensure that the proposals, prevotes and
precommits submitted on time by the honest validators appear on Babylon in the appropriate interval, thus preventing honest
validators from getting slashed for stalling.

roots from the headers, calculate expression (1) and compare it
against the commitment on Babylon to verify its validity. PoS light
clients trust the Babylon miners to check if the transaction roots
txrğ‘– indeed commit to the data in the bodies of the checkpointed
blocks.

5.3 Checkpointing the PoS Chain
Nodes send checkpoints of all finalized blocks on the PoS chain
to the Babylon miners every time they observe the Babylon chain
grow by ğ‘˜ğ‘ blocks5. We say that a Babylon block ğ‘ checkpoints a
PoS block ğµ in the view of a node c (at time ğ‘¡) if (i) ğµ is a finalized &
valid block in the PoS chain in câ€™s view, and (ii) ğ‘ is the first block
within the longest Babylon chain in câ€™s view (at time ğ‘¡) to contain
a valid checkpoint of ğµ alongside other PoS blocks.

Checkpoints that do not include information about new PoS
blocks are ignored by the PoS nodes during the interpretation of the
commitments on Babylon. Thus, given two consecutive checkpoints
on the Babylon chain that are not ignored by a PoS node, if they
do not commit to conflicting PoS blocks, then the latter one must
be checkpointing new PoS blocks extending those covered by the
earlier one.

Fork-choice Rule: (Figure 2, Algorithm 4) If there are no forks
on the PoS chain, i.e., when there is a single chain, it is the canonical
PoS chain.

If there are multiple PoS chains with conflicting finalized blocks,
i.e., a safety violation, in the view of a node c at time ğ‘¡, c orders
these chains by the following recency relation : Chain A is earlier
than chain B in câ€™s view at time ğ‘¡ if the first PoS block that is on
A but not B, is checkpointed by an earlier Babylon block than the
one checkpointing the first PoS block that is on B but not A, on câ€™s
canonical Babylon chain at time ğ‘¡. If only chain A is checkpointed
in this manner on câ€™s canonical Babylon chain, then A is earlier.
If there are no Babylon blocks checkpointing PoS blocks that are
exclusively on A or B, then the adversary breaks the tie for c. The
canonical PoS chain PoSLOGğ‘¡
is taken by c to be the earliest chain
c

5In reality, PoS nodes do not submit a commitment of all of the blocks on the PoS
chain in their view. They submit commitments of only those blocks that were not
captured by previous checkpoints on Babylon.

10

in this ordering at time ğ‘¡. Thus, Babylon provides a total order
across multiple chains when there is a safety violation on the PoS
chains.

5.4 Stake Withdrawals and Slashing for Safety

Violations

Since the PoS protocol provides accountable safety, upon observ-
ing a safety violation on the PoS chain, any node can construct a
fraud proof that irrefutably identifies ğ‘›/3 adversarial validators as
protocol violators, and send it to Babylon. Fraud proof contains
checkpoints for conflicting PoS blocks along with a commitment,
i.e., hash, of the evidence, e.g., double-signatures, implicating the
adversarial validators. Hence, it is valid as long as the checkpoints
and the commitments are valid, and serves as an irrefutable proof
of protocol violation by ğ‘›/3 adversarial validators.

Stake withdrawal: (Figure 5, Algorithm 5) To withdraw its
stake, a validator v first sends a special PoS transaction called the
withdrawal request to the PoS protocol. Given ğ‘˜ğ‘¤, v is granted
permission to withdraw its stake in the view of a PoS node once
the node observes that

(1) A block ğµ on its canonical PoS chain containing the withdrawal
request is checkpointed by a block ğ‘ on its longest Babylon
chain, i.e., the longest Babylon chain in its view.

(2) There are ğ‘˜ğ‘¤ blocks building on ğ‘ on its longest Babylon chain,
where ğ‘˜ğ‘¤, chosen in advance, determines the withdrawal delay.
(3) There does not exist a valid fraud proof implicating v in the

nodeâ€™s longest Babylon chain.

Once the above conditions are also satisfied in vâ€™s view, it submits
a withdrawal transaction to the PoS protocol, including a reference
to the ğ‘˜ğ‘¤-th Babylon block building on ğ‘. Honest nodes consider
the withdrawal transaction included in a PoS block ğµâ€² as valid if
ğµâ€² extends ğµ, the block with the withdrawal request, and the above
conditions are satisfied in their view.

Slashing for Safety Attacks: Stake of a validator becomes
slashable in the view of any PoS node which observes that condi-
tion (3) above is violated. In this case, nodes that sent the fraud
proofs on Babylon can receive part of the slashed funds as reward
by submitting a reward transaction to the PoS chain.

Babylon:
Reusing Bitcoin Mining to Enhance Proof-of-Stake Security

5.5 Slashing for Liveness Violations
In the rest of this section, a validator or PoS nodeâ€™s Babylon chain,
i.e., the Babylon chain in the view of a PoS node or validator, refers
to the ğ‘˜ğ‘ /2-deep prefix of the longest chain in their view. As a
liveness violation can be due to either censorship, i.e., lack of chain
quality, or stalling, i.e., lack of chain growth, we analyze these two
cases separately:

5.5.1 Censorship Resilience. (Figure 6, Algorithm 6) PoS nodes
send commitments of censored PoS transactions to Babylon via
censorship complaints. A complaint is valid in the minersâ€™s view if
the commitment matches the hash of the censored transactions.

Upon observing a valid complaint on its Babylon chain, a valida-
tor includes the censored PoS transactions within the new blocks
its proposes unless they have already been included in the PoS
chain or are invalid with respect to the latest PoS state. Similarly,
among new PoS blocks proposed, validators vote only for those
that include the censored transactions in the blockâ€™s body or prefix
if the transactions are valid with respect to the latest PoS state.

Suppose a censorship complaint appears within some block ğ‘ on
a validator ğ‘â€™s Babylon chain (Figure 6). Let ğ‘ â€² be the first block on
ğ‘â€™s Babylon chain that checkpoints a new PoS block and extends ğ‘
by at least 2ğ‘˜ğ‘ blocks. Then, a PoS block ğµ is said to be censoring
in ğ‘â€™s view if (i) it is checkpointed by a block ğ‘ â€²â€², ğ‘ â€² â‰º ğ‘ â€²â€² in ğ‘â€™s
Babylon chain, and (ii) ğµ does not include the censored transactions
in neither its body nor its prefix (cf. Algorithm 6 for a function
that detects the censoring PoS blocks with respect to a censorship
complaint).

Slashing for Censorship Attacks. Stake of a validator becomes
5.5.2
slashable in an honest PoS node ğ‘â€™s view if the validator proposed
or voted for a PoS block ğµ that is censoring in ğ‘â€™s view (e.g., block
B in Figure 6).

Stalling Resilience. (Figure 7, Algorithm 7) A node detects
5.5.3
that the PoS protocol has stalled if no new checkpoint committing
new PoS blocks appears on its Babylon chain within 2ğ‘˜ğ‘ blocks
of the last checkpoint. In this case, it sends a stalling evidence to
Babylon. Stalling evidence is labelled with the smallest height â„
at which a PoS block has not been finalized yet and contains a
checkpoint for the PoS blocks from smaller heights. Hence, it is
valid in the minersâ€™ view if the included checkpoint is valid.

Stalling evidence signals to the validators that they should here-
after publish the PoS protocol messages, previously exchanged over
the network, on Babylon until a new PoS block is finalized. For
instance, in the case of Babylon-enhanced Tendermint, a stalling
evidence on Babylon marks the beginning of a new round whose
proposals and votes are recorded on Babylon. Thus, upon observ-
ing the first stalling evidence that follows the last checkpoint on
Babylon by 2ğ‘˜ğ‘ blocks, validators stop participating in their previ-
ous rounds and enter a new, special Tendermint round for height
â„, whose messages are recorded on-Babylon. Each of them then
pretends like the next round leader and sends a proposal message
to Babylon for the new round.

In the rest of this section, we focus on Tendermint [16] as the
Babylon-enhanced PoS protocol for the purpose of illustration. A
summary of Tendermint is given in Appendix C.1. The following
paragraphs explain how a Tendermint round is recorded on Babylon

in the perspective of a validator ğ‘ (cf. Algorithm 7). A detailed
description of this can be found in Appendix C.2

Let ğ‘ denote the Babylon block that contains the first stalling evi-
dence observed by ğ‘ (Figure 7). Let ğ‘1 and ğ‘2 denote the first blocks
in ğ‘â€™s Babylon chain that extend ğ‘ by ğ‘˜ğ‘ and 2ğ‘˜ğ‘ blocks respectively.
If a new checkpoint for a PoS block finalized at height â„ appears
between ğ‘ and ğ‘1, ğ‘ stops participating in the round on-Babylon
and moves to the next height, resuming its communication with
the other validators through the network. Otherwise, if there are
â‰¥ 2ğ‘“ + 1 non-censoring proposal messages signed by unique valida-
tors between ğ‘ and ğ‘1, ğ‘ and every other honest validator selects
the message with the largest validRound as the unique proposal of
the round.

Once ğ‘ decides on a proposal ğµ and observes ğ‘1 in its Babylon
chain, it signs and sends prevote and precommit messages for ğµ
to Babylon. Upon seeing ğ‘2 in its Babylon chain, ğ‘ finalizes ğµ if
there are more than 2ğ‘“ + 1 prevotes and precommits for ğµ, signed
by unique validators, between ğ‘1 and ğ‘2. In this case, ğ‘2 is des-
ignated as the Babylon block that has checkpointed block ğµ for
height â„. After finalizing ğµ, ğ‘ moves to the next height, resuming
its communication with other validators through the network.

Slashing for Stalling Attacks. Consider the validator ğ‘ and
5.5.4
the on-Babylon Tendermint round described above and suppose
there is no new checkpoint for a PoS block finalized at height â„
between ğ‘ and ğ‘1 (Figure 7). Then, if there are less than 2ğ‘“ + 1
uniquely signed non-censoring proposals between ğ‘ and ğ‘1, stake
of each validator with a censoring or missing proposal becomes
slashable in ğ‘â€™s view. Similarly, if there are less than 2ğ‘“ + 1 uniquely
signed prevotes or precommits between ğ‘1 and ğ‘2 for the proposal
ğµ selected by ğ‘, stake of each validator with a missing prevote or
precommit for ğµ between ğ‘1 and ğ‘2 becomes slashable in ğ‘â€™s view.
To enforce the slashing of the validatorâ€™s stake in the case of
censorship or stalling, PoS nodes can submit a reward transaction
to the PoS chain, upon which they receive part of the slashed funds.
No validator is slashed by the slashing rules for censorship or
stalling if there is a safety violation on the PoS chains, in which
case slashing for safety (cf. Section 5.4) takes precedence.

6 SCALABILITY OF THE PROTOCOL
Babylon protocol above can be used by different PoS protocols si-
multaneously, which raises the question of how much data Babylon
miners can check for availability at any given time. To address this,
we first review the three physical limits that determine the amount
and speed of on-chain data generation by the PoS blockchains:

(1) hot storage capacity, which caps the amount of data generated

before cold storage or chain snapshot have to kick in;

(2) execution throughput, which limits the data generation speed
to how fast transactions and blocks can be created, validated,
and executed;

(3) communication bandwidth, which limits the data generation
speed to how fast transactions and blocks can be propagated
throughout the P2P network.

11

Since Babylon does not permanently store6 any PoS chain data,
it does not have to match aggregated storage capacity of the PoS
chains to provide data protection. Thus, there is no storage issue
for Babylon to scale, namely, to support many PoS protocols.

On the other hand, Babylonâ€™s data processing speed, i.e. the
speed with which miners validate data availability, must match the
total data generation speed across the PoS chains. Currently, the
data generation speed of individual PoS chains is mostly limited by
the execution rather than communication bandwidth. As Babylon
only downloads the PoS data without executing it, it should also
able to accommodate many PoS chains from the speed perspective.
In the unlikely case that a certain PoS protocol is only limited
by the communication bandwidth and thus generates large blocks
frequently, Babylon could potentially apply sampling-based proba-
bilistic data availability checks [7, 36] to significantly reduce the
amount of data it needs to download and process per block, which
is a promising future research direction.

7 REFERENCE DESIGN WITH COSMOS SDK
Cosmos is a well-known open-source blockchain ecosystem that en-
ables customizable blockchains [30]. It also enables inter-blockchain
communications by using Cosmos Hub (ATOM) as the trust anchor.
Therefore, Cosmos provides both the tools through its SDK and
the ecosystem required to demonstrate the implementation of a
Babylon-enhanced PoS blockchain protocol. To this end, we first
briefly review how essential Cosmos modules work together to
protect the security of the Cosmos zones, i.e., its constituent PoS
blockchains, and then show how Babylon can enhance the security
of these zones via a straightforward module extension.

7.1 Cosmos Overview
Cosmos encapsulates the core consensus protocol and network-
ing in its Tendermint consensus engine, which uses Tendermint
BFT underneath. Several interoperable modules have been built to
work with this consensus engine together as a complete blockchain
system. Each module serves a different functionality such as autho-
rization, token transfer, staking, slashing, etc., and can be configured
to meet the requirements of the application. Among these modules,
the following are directly related to security:

â€¢ evidence module, which enables the submission by any proto-
col participant, and handling of the evidences for adversarial
behaviors such as double-signing and inactivity;

â€¢ slashing module, which, based on valid evidence, penalizes
the adversarial validators by means such as stake slashing and
excluding it from the BFT committee;

â€¢ crisis module, which suspends the blockchain in case a pre-
defined catastrophic incident appears, e.g., when the sum of
stakes over all the accounts exceed the total stake of the system;
â€¢ gov module, which enables on-chain blockchain governance
in making decisions such as software updates and spending
community funds.

We note that these modules currently are not able to handle
the aforementioned attacks such as long range attacks and trans-
action censorship. Moreover, in case catastrophic incidents such

6Babylon may store the data committed in the recent Babylon blocks for the synchro-
nization between Babylon nodes.

Ertem Nusret Tas, David Tse, Fisher Yu, and Sreeram Kannan

Figure 8: Enhancing Cosmos zones via a new BE (Babylon-
enhancement) module.
as chain forking appear, system cannot recover from halt by itself.
The incident can only be resolved via human intervention, which
can be either proactive or reactive: Under proactive human inter-
vention, stakeholders of the system regularly agree on and publish
checkpoints on the blockchain to prevent long range attacks. Under
reactive human intervention, when a forking incident happens,
stakeholders get together to decide on a fork as the canonical chain.
Since both types of interventions require stakeholder meetings,
they are part of â€œsocial consensusâ€.

7.2 Enhancing Cosmos Security with Babylon
To enhance the security of Cosmos PoS chains with Babylon, we
add a new module called BE (Babylon-enhancement) to the Cosmos
SDK. This module executes the protocol described in Section 5 and
only requires straightforward interactions with existing Cosmos
modules. Some of the key interactions are as follows (Figure 8):

BE implements the Babylon-specific add-ons such as the fork-
choice rule specified in Section 5.3 to output the canonical PoS
chain. It monitors the PoS chain and creates the messages spec-
ified in Section 5 such as checkpoints, fraud proofs, censorship
complaints and stalling evidences. It communicates with the gov
module to obtain approval for the expenditure of community funds
to pay for the Babylon transaction fees. It submits the messages
mentioned above, through a customized client (Figure 10) to the
Babylon chain and uses Babylon transactions to pay the miners.
It also monitors the existing messages created for the same PoS
chain and timestamped on Babylon. In case any adversarial action
is detected through the interpretation of the messages on Babylon,
it submits the evidences to the evidence module and then works
with the slashing module to slash the adversarial validators on the
PoS chain. In the case of forking on the PoS chain, it interacts with
the crisis module to temporarily suspend the system, and proposes
resolution via the gov module to recover the system, where the res-
olution is derived using the fork-choice rule specified in Section 5.3.
When withdrawal requests and Babylon-related PoS transactions
are submitted to the Tendermint consensus engine, it helps the
engine verify such transactions.

All the above interactions can be supported by existing Cosmos
modules via API and data format configurations. These configura-
tions are explained below:

12

Babylon:
Reusing Bitcoin Mining to Enhance Proof-of-Stake Security

â€¢ Tendermint consensus engine: redirect the validation of stake
withdrawal transactions and Babylon-related slashing transac-
tions to the BE module.

â€¢ evidence module: add evidence types such as fraud proofs,
censorship complaint and stalling evidence, corresponding to
Babylon-related violations;

â€¢ slashing module: define the appropriate slashing rules as de-

scribed in Sections 5.4, 5.5.2 and 5.5.4;

â€¢ crisis module: add handling of safety violations reported by the

BE module;

â€¢ gov module: add two proposal types (i) to use community funds
to pay for Babylon transaction fees and (ii) to execute fork
choice decision made by the BE module.

ACKNOWLEDGEMENTS
We thank Joachim Neu, Lei Yang and Dionysis Zindros for several
insightful discussions on this project.

REFERENCES
[1] Ethereum Wiki: On sharding blockchains FAQs. https://eth.wiki/sharding/

Sharding-FAQs. Accessed: 2022-01-12.

[22] Jing Chen and Silvio Micali. Algorand: A secure and efficient distributed ledger.

Theoretical Computer Science, 777:155â€“183, 2019.

[23] Phil Daian, Rafael Pass, and Elaine Shi. Snow white: Robustly reconfigurable
In Financial

consensus and applications to provably secure proof of stake.
Cryptography and Data Security, FC â€™19, 2019.

[24] Evangelos Deirmentzoglou, Georgios Papakyriakopoulos, and Constantinos Pat-
sakis. A survey on long-range attacks for proof of stake protocols. IEEE Access,
7:28712â€“28725, 2019.

[25] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The Bitcoin backbone proto-
col: Analysis and applications. In EUROCRYPT 2015, pages 281â€“310, 2015.
[26] Sreeram Kannan, Kartik Nayak, Peiyao Sheng, Pramod Viswanath, and Gerui
Wang. BFT protocol forensics. In Conference on Computer and Communications
Security, CCS â€™21, 2021.

[27] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov.
Ouroboros: A provably secure proof-of-stake blockchain protocol. In CRYPTO
2017, pages 357â€“388, 2017.

[28] Joachim Neu, Ertem Nusret Tas, and David Tse. Ebb-and-flow protocols: A
resolution of the availability-finality dilemma. In Symposium on Security and
Privacy, S&P â€™21. IEEE, 2021.

[29] Joachim Neu, Ertem Nusret Tas, and David Tse. The availability-accountability
dilemma and its resolution via accountability gadgets. In Financial Cryptography
and Data Security, FC â€™22, 2022.

[30] List of modules in Cosmos SDK. https://docs.cosmos.network/master/modules/.

Accessed: Nov 2021.

[31] Suryanarayana Sankagiri, Xuechao Wang, Sreeram Kannan, and Pramod
Viswanath. Blockchain cap theorem allows user-dependent adaptivity and final-
ity. In Financial Cryptography and Data Security, FC â€™21, 2021.

[32] Selma Steinhoff, Chrysoula Stathakopoulou, Matej Pavlovic, and Marko VukoliÄ‡.
BMS: Secure Decentralized Reconfiguration for Blockchain and BFT Systems,
2021.

[2] Merged mining specification.

https://en.bitcoin.it/wiki/Merged_mining_

[33] Alistair Stewart and Eleftherios Kokoris-Kogia. GRANDPA: A Byzantine finality

specification. Accessed: 2021-11-3.

[3] Namecoin. https://www.namecoin.org/. Accessed: 2021-11-3.
[4] Pow 51% attack cost. https://www.crypto51.app/. Accessed: 2021-11-3.
[5] Rsk. https://www.rsk.co/. Accessed: 2021-11-3.
[6] Mustafa Al-Bassam. Lazyledger: A distributed data availability ledger with

client-side smart contracts. 2019.

[7] Mustafa Al-Bassam, Alberto Sonnino, Vitalik Buterin, and Ismail Khoffi. Fraud
and data availability proofs: Detecting invalid blocks in light clients. In Financial
Cryptography and Data Security, FC â€™21, 2021.

[8] VDF Alliance. VDF Alliance FPGA Competition. https://supranational.atlassian.

net/wiki/spaces/VA/pages/36569208/FPGA+Competition, 2019.

[9] Georgia Avarikioti, Lukas KÃ¤ppeli, Yuyi Wang, and Roger Wattenhofer. Bitcoin
security under temporary dishonest majority. In Financial Cryptography and
Data Security, FC â€™19, 2019.

[10] Sarah Azouvi. Securing membership and state checkpoints of bft and pos
blockchains by anchoring onto the bitcoin blockchain. https://www.youtube.
com/watch?v=k4SacbLrypc, 2021. ConsensusDays 21.

[11] Sarah Azouvi, George Danezis, and Valeria Nikolaenko. Winkle: Foiling long-
range attacks in proof-of-stake systems. In Proceedings of the 2nd ACM Conference
on Advances in Financial Technologies, AFT â€™20, page 189â€“201, 2020.

[12] Christian Badertscher, Peter GaÅ¾i, Aggelos Kiayias, Alexander Russell, and Vassilis
Zikas. Ouroboros Genesis: Composable proof-of-stake blockchains with dynamic
availability. In Conference on Computer and Communications Security, CCS â€™18,
pages 913â€“930, 2018.

[13] Simon Barber, Xavier Boyen, Elaine Shi, and Ersin Uzun. Bitter to better â€” how
to make bitcoin a better currency. In Angelos D. Keromytis, editor, Financial
Cryptography and Data Security, pages 399â€“414, Berlin, Heidelberg, 2012. Springer
Berlin Heidelberg.

[14] Carl Beekhuizen. Validated, staking on eth2: #1 - incentives. https://blog.
ethereum.org/2020/01/13/validated-staking-on-eth2-1-incentives/, 2020. Ac-
cessed: 2021-11-3.

[15] Ethan Buchman. Tendermint: Byzantine fault tolerance in the age of blockchains,

2016.

[16] Ethan Buchman, Jae Kwon, and Zarko Milosevic. The latest gossip on BFT

consensus, 2018.

[17] Vitalik Buterin. Proof of stake: How i learned to love weak subjectivity, 2014.

Accessed: 2021-04-20.

[18] Vitalik Buterin and Virgil Griffith.

Casper the friendly finality gadget.

arXiv:1710.09437, 2019.

[19] Vitalik Buterin, Diego Hernandez, Thor Kamphefner, Khiem Pham, Zhi Qiao,
Danny Ryan, Juhyeok Sin, Ying Wang, and Yan X Zhang. Combining ghost and
casper. arXiv:2003.03052, 2020.

[20] Miguel Castro and Barbara Liskov. Practical Byzantine fault tolerance. In Sympo-
sium on Operating Systems Design and Implementation, OSDI â€™99, page 173â€“186.
USENIX Association, 1999.

[21] Benjamin Y. Chan and Elaine Shi. Streamlet: Textbook streamlined blockchains.

In Advances in Financial Technologies, AFT â€™20, page 1â€“11. ACM, 2020.

13

gadget. arXiv:2007.01560, 2020.

[34] Anatoly Yakovenko.

Solana: A new architecture for a high performance

blockchain v0.8.13. https://solana.com/solana-whitepaper.pdf, 2019.

[35] Maofan Yin, Dahlia Malkhi, Michael K. Reiter, Guy Golan Gueta, and Ittai Abra-
ham. HotStuff: BFT consensus with linearity and responsiveness. In Symposium
on Principles of Distributed Computing, PODC â€™19, page 347â€“356, 2019.

[36] Mingchao Yu, Saeid Sahraei, Songze Li, Salman Avestimehr, Sreeram Kannan,
and Pramod Viswanath. Coded Merkle tree: Solving data availability attacks in
blockchains. In Financial Cryptography and Data Security, FC â€™18, 2018.

A PROOFS FOR SECTION 4
To formalize slashable safety and its absence thereof, we define
slashable safety resilience for the PoS protocols and state the impos-
sibility theorem for slashable safety in the absence of additional
trust assumptions:

Definition 6. Slashable safety resilience of a protocol is the min-
imum number ğ‘“ of validators that become slashable in the view of
all honest PoS nodes per Definition 3 in the event of a safety violation.
Such a protocol provides ğ‘“ -slashable-safety.

Theorem 3. Assuming a common knowledge of the initial set
of active validators, without additional trust assumptions, no PoS
protocol provides both ğ‘“s-slashable-safety and ğ‘“l-ğ‘‡fin-liveness for any
ğ‘“s, ğ‘“l > 0 and ğ‘‡fin < âˆ.

Proof. For the sake of contradiction, suppose there exists a PoS
protocol Î  that provides ğ‘“l-ğ‘‡fin-liveness and ğ‘“s-slashable-safety
for some ğ‘“l, ğ‘“s > 0 and ğ‘‡fin < âˆ without any additional trust
assumptions.

Let ğ‘› be the number of active validators at any given time. Let ğ‘ƒ,
ğ‘„ â€² and ğ‘„ â€²â€² denote disjoint sets of validators such that ğ‘ƒ := {vğ‘–, ğ‘– =
1, .., ğ‘›}, ğ‘„ â€² := {vâ€²

ğ‘– , ğ‘– = 1, .., ğ‘›} and ğ‘„ â€²â€² := {vâ€²â€²

ğ‘– , ğ‘– = 1, .., ğ‘›}.

Next, we consider the following two worlds, where the adver-

sarial behavior is designated by (A, Z):

World 1: (A, Z) provides ğ‘ƒ as the initial set of active validators.
Validators in ğ‘„ â€² are honest. Validators in ğ‘ƒ and ğ‘„ â€²â€² are adversarial.

At time ğ‘¡ = 0, Z inputs transactions txâ€²

ğ‘– , ğ‘– = 1, .., ğ‘›, to the
validators in ğ‘ƒ, where txâ€²
ğ‘– causes vğ‘– âˆˆ ğ‘ƒ to become passive and
vâ€²
ğ‘– âˆˆ ğ‘„ â€² to become active. Validators in ğ‘ƒ emulate a set of honest
validators with equal size, except that they record every piece of
information in their transcripts. Since ğ‘“l > 0 and ğ‘‡fin < âˆ, there
exists a constant time ğ‘‡ such that upon receiving transcripts from
the set of active validators at time ğ‘‡ , clients output a ledger Ledger
for which txâ€²
ğ‘– âˆˆ Ledger, ğ‘– = 1, .., ğ‘›. Thus, the set of active validators
at time ğ‘‡ is ğ‘„ â€² in the view of any client. As passive validators
withdraw their stake within a constant time ğ‘‡ â€², by time ğ‘‡ + ğ‘‡ â€², all
validators in ğ‘ƒ have withdrawn their stake.

In parallel to the real execution above, (A, Z) creates a simulated
execution in its head where a different set of transactions, txâ€²â€²
ğ‘– , ğ‘– =
1, .., ğ‘›, is input to the validators in ğ‘ƒ at time ğ‘¡ = 0. Here, txâ€²â€²
ğ‘– causes
vğ‘– âˆˆ ğ‘ƒ to become passive and vâ€²â€²
ğ‘– âˆˆ ğ‘„ â€²â€² to become active. Then,
upon receiving the transcripts of the simulated execution at time
ğ‘‡ , clients would output a ledger Ledgerâ€² for which txâ€²â€²
ğ‘– âˆˆ Ledgerâ€²,
ğ‘– = 1, .., ğ‘›. Then, the set of active validators at time ğ‘‡ would be ğ‘„ â€²â€²
in the view of any client. As passive validators can withdraw their
stake within a constant time ğ‘‡ â€², all validators in ğ‘ƒ withdraw their
stake in the simulated execution by time ğ‘‡ + ğ‘‡ â€².

Finally, (A, Z) spawns a PoS client c at time ğ‘‡ + ğ‘‡ â€², which
receives transcripts from both the simulated and real executions.
Since Ledger and Ledgerâ€² conflict with each other and ğ‘“s > 0, there
is a safety violation, and c identifies a set of irrefutably adversarial
validators by invoking the forensic protocol, a non-empty subset
of which is slashable. As the validators in ğ‘ƒ have withdrawn their
stake and those in ğ‘„ â€² are honest and did not violate the protocol,
this set includes at least one slashable validator from ğ‘„ â€²â€².

World 2: World 2 is the same as World 1, except that (i) valida-
tors in ğ‘„ â€² are adversarial and those in ğ‘„ â€²â€² are honest, and (ii) the
transactions txâ€²
ğ‘– , ğ‘– = 1, .., ğ‘›, are swapped in the description,
i.e. txâ€²
ğ‘– and vice versa.
***

ğ‘– and txâ€²â€²
ğ‘– is replaced by txâ€²â€²

Finally, as World 1 and 2 are indistinguishable, c again identifies
a validator from ğ‘„ â€²â€² as slashable in World 2 with probability at
least 1/2. However, the validators in ğ‘„ â€²â€² are honest in World 2,
and could not have been identified as irrefutably adversarial, i.e.
â–¡
contradiction.

Following theorem is used for the proof of Theorem 2.

Theorem 4. For any SMR protocol that is run by ğ‘› validators
and satisfies ğ‘“s-safety and ğ‘“l-ğ‘‡fin-liveness with ğ‘“s, ğ‘“l > 0 (assuming
Byzantine faults) and ğ‘‡fin < âˆ, it must be the case that ğ‘“s < ğ‘› âˆ’ ğ‘“l.
Proof. For the sake of contradiction, assume that there exists
an SMR protocol Î  that provides ğ‘“l-ğ‘‡fin-liveness for some ğ‘“l > 0,
ğ‘‡fin < âˆ and ğ‘“s-safety for ğ‘“s = ğ‘› âˆ’ ğ‘“l. Then, the protocol should
be safe when there are ğ‘› âˆ’ ğ‘“l adversarial validators. Let ğ‘ƒ, ğ‘„ and ğ‘…
denote disjoint sets consisting of ğ‘“l, ğ‘“l and ğ‘› âˆ’ 2ğ‘“l > 0 validators re-
spectively, where we assume ğ‘“l < ğ‘›/2. Next, consider the following
worlds with two clients c1 and c2 prone to omission faults, where
the adversarial behavior is designated by (A, Z):

World 1: Z inputs tx1 to all validators. Those in ğ‘ƒ and ğ‘… are
honest and the validators in ğ‘„ are adversarial. There is only one
client c1. Validators in ğ‘„ do not communicate with those in ğ‘ƒ and ğ‘…;

Ertem Nusret Tas, David Tse, Fisher Yu, and Sreeram Kannan

they also do not respond to c1. Since ğ‘ƒ âˆªğ‘… has size ğ‘›âˆ’ ğ‘“l and consists
of honest validators, via ğ‘“l-liveness, upon receiving transcripts from
the validators in ğ‘ƒ and ğ‘…, c1 outputs the ledger [tx1] by time ğ‘‡fin.
World 2: Z inputs tx2 to all validators. Those in ğ‘„ and ğ‘… are
honest and the validators in ğ‘ƒ are adversarial. There is only one
client c2. Validators in ğ‘ƒ do not communicate with those in ğ‘„
and ğ‘…; they also do not respond to c2. Since ğ‘„ âˆª ğ‘… has size ğ‘› âˆ’ ğ‘“l
and consists of honest validators, via ğ‘“l-liveness, upon receiving
transcripts from the validators in ğ‘„ and ğ‘…, c2 outputs the ledger
[tx2] by time ğ‘‡fin.

World 3: Z inputs tx1 to the validators in ğ‘ƒ, tx2 to the validators
in ğ‘„, and both transactions to the validators in ğ‘…. Validators in ğ‘ƒ
are honest, those in ğ‘„ and ğ‘… are adversarial. There are two clients
this time, c1 and c2. Validators in ğ‘„ do not send any message to
any of the validators in ğ‘ƒ; they also do not respond to c1. Z also
omits any message sent from the validators in ğ‘ƒ to c2.

Validators in ğ‘… perform a split-brain attack where one brain
interacts with ğ‘ƒ as if the input were tx1 and it is not receiving any
message from ğ‘„ (real execution). Simultaneously, validators in ğ‘„
and the other brain of ğ‘… start with input tx2 and communicate with
each other exactly as in world 2, creating a simulated execution.
The first brain of ğ‘… only responds to c1 and the second brain of ğ‘…
only responds to c2.

Since worlds 1 and 3 are indistinguishable for c1 and the honest
validators in ğ‘ƒ, upon receiving transcripts from the validators in
ğ‘ƒ and the first brain of ğ‘…, c1 outputs [tx1] by time ğ‘‡fin. Similarly,
since worlds 2 and 3 are indistinguishable for c2, upon receiving
transcripts from the validators in ğ‘„ and the second brain of ğ‘…, c2
outputs [tx2] by time ğ‘‡fin.

Finally, there is a safety violation in world 3 since c1 and c2
output conflicting ledgers. However, there are only ğ‘“s = ğ‘› âˆ’ ğ‘“l
adversarial validators in ğ‘„ and ğ‘…, which is a contradiction.

Proof for ğ‘“l â‰¥ ğ‘›/2 proceeds via a similar argument, where sets
ğ‘ƒ, ğ‘„ and ğ‘… denote disjoint sets of sizes ğ‘› âˆ’ ğ‘“l, ğ‘› âˆ’ ğ‘“l and 2ğ‘“l âˆ’ ğ‘› > 0
â–¡
respectively.

Proof of Theorem 2 is given below:

Proof of Theorem 2. For the sake of contradiction, suppose
there exists a PoS protocol Î  with a static set of validators that pro-
vides ğ‘“a-ğ‘‡fin-accountable-liveness and ğ‘“s-safety for some ğ‘“a, ğ‘“s > 0
and ğ‘‡fin < âˆ without any additional trust assumptions. Then, there
exists a forensic protocol which takes transcripts sent by the val-
idators as input, and in the event of a liveness violation, outputs
a non-empty set of validators which have irrefutably violated the
protocol rules.

Let ğ‘“l denote the liveness resilience of Î . By Theorem 4, ğ‘“l <
ğ‘› âˆ’ ğ‘“s, i.e., ğ‘“l â‰¤ ğ‘› âˆ’ 2 as ğ‘“s > 0. By definition of accountable
liveness resilience, ğ‘“l â‰¥ ğ‘“a > 0. Let ğ‘š â‰¥ 1 denote the maximum
integer less than ğ‘› âˆ’ ğ‘“l â‰¥ 2 that divides ğ‘›. Let ğ‘ƒğ‘– , ğ‘– = 1, .., ğ‘›/ğ‘š (i.e.
ğ‘– âˆˆ [ğ‘›/ğ‘š]) denote sets of size ğ‘š that partition the ğ‘› validators into
ğ‘›/ğ‘š disjoint, equally sized groups. We next consider the following
worlds indexed by ğ‘– âˆˆ [ğ‘›/ğ‘š] where Z inputs a transaction tx to all
validators at time ğ‘¡ = 0 and the adversarial behavior is designated
by (A, Z):

World ğ‘–: Validators in ğ‘ƒğ‘– are honest. Validators in each set ğ‘ƒ ğ‘— ,
ğ‘— â‰  ğ‘–, ğ‘— âˆˆ [ğ‘›/ğ‘š], are adversarial and simulate the execution of ğ‘š

14

Babylon:
Reusing Bitcoin Mining to Enhance Proof-of-Stake Security

honest validators in their heads without any communication with
the validators in the other sets. Validators in each ğ‘ƒ ğ‘— , ğ‘— âˆˆ [ğ‘›/ğ‘š]
generate a set of transcripts such that upon receiving transcripts
from the set of validators in ğ‘ƒ ğ‘— at time ğ‘‡fin, a client outputs a
(potentially empty) ledger Ledgerğ‘— , ğ‘— âˆˆ [ğ‘›/ğ‘š]. As |ğ‘ƒ ğ‘— | < ğ‘› âˆ’ ğ‘“l,
validators in ğ‘ƒğ‘– do not hear from the validators in ğ‘ƒ ğ‘— , ğ‘— â‰  ğ‘–, and
the validators in ğ‘ƒ ğ‘— , ğ‘— â‰  ğ‘– simulate the execution of the honest
validators in world ğ‘— respectively, tx âˆ‰ Ledgerğ‘— for any ğ‘— âˆˆ [ğ‘›/ğ‘š].
Finally, (A, Z) spawns a client at time ğ‘‡fin, which receives tran-
scripts from both the real and the multiple simulated executions.
Since tx âˆ‰ Ledgerğ‘— for any ğ‘— âˆˆ [ğ‘›/ğ‘š], there is a liveness violation
in the clientâ€™s view. As ğ‘“a > 0, by invoking the forensic proto-
col with the transcripts received, client identifies a subset ğ‘†ğ‘– of
validators as irrefutably adversarial.

***

Finally, by definition of ğ‘†ğ‘– ,

it should be the case that
ğ‘†ğ‘– âŠ† (cid:208)ğ‘— âˆˆ [ğ‘›/ğ‘š],ğ‘—â‰ ğ‘– ğ‘ƒ ğ‘— . However, as worlds ğ‘–, ğ‘– âˆˆ [ğ‘›/ğ‘š] are in-
distinguishable for the client, there exists a world ğ‘–âˆ—, ğ‘–âˆ— âˆˆ [ğ‘›/ğ‘š],
such that a node from ğ‘ƒğ‘–âˆ— is identified as adversarial in world ğ‘–âˆ—
with probability at least ğ‘š/ğ‘› â‰¥ 1/ğ‘›, which is non-negligible. This
â–¡
is a contradiction.

Note that when the number of validators ğ‘› is large and ğ‘“l = ğ‘› âˆ’ 2,
probability that the forensic protocol for accountable liveness makes
a mistake and identifies an honest validator as adversarial can
be small. However, assuming that ğ‘› is polynomial in the security
parameter of the PoS protocol, this probability will not be negligible
in the security parameter.

B MERGE MINING AND CLIENT

APPLICATIONS

Miners merge-mine the Babylon chain following the longest chain
rule. To merge-mine Babylon blocks, miners calculate hashes of
blocks containing both Bitcoin and Babylon transactions. Whenever
a miner finds a block with its hash falling into the Babylon range,
it shares the Babylon transactions in this block with its Babylon
client, which extracts a Babylon block from the received contents (cf.
Figure 9). Hash of this block is then sent over Bitcoinâ€™s peer-to-peer
network to be included as a Bitcoin transaction [2]. Babylon blocks
have the same structure as Bitcoin blocks. Size of the Babylon range
determines the chain difficulty, in turn, the growth rate ğœ† for the
Babylon chain.

Babylon client is run by the Bitcoin miners in parallel with the
Bitcoin client. Besides exchanging nonces and hashes with the
mining software for merge-mining, Babylon client also records the
commitments submitted by the PoS chains and checks for data
availability. Thus, miners follow the same longest chain mining
protocol as regular Bitcoin clients, except for the fact that they also
check for the availability of the PoS blocks before accepting their
commitments.

Similar to miners, each PoS node using Babylon runs a special
Babylon-embedded PoS chain client (Figure 10). This client is built
on top of an existing PoS client, but augmented with Babylon-
specific add-ons to allow the PoS node to post commitments and
checkpoints to Babylon as well as interpret the timestamps of these
messages.

15

C STALLING RESILIENCE
C.1 Tendermint Summary
Tendermint consensus proceeds in heights and rounds. Each height
represents a new consensus instance and the validators cannot
move on to the next height before a unique block is finalized for
the previous one. Heights consist of rounds, each with a unique
leader that proposes a PoS block. Goal of each round is to finalize a
block for its height.

Rounds are divided into three steps: propose, prevote and pre-
commit. An honest round leader proposes a block for its round at
the beginning of the propose step. Then, during the respective steps,
validators send prevote and precommit messages for the proposed
block or a nil block, depending on the proposal and their inter-
nal states. Each honest validator maintains four variables which
affect its decision whether to prevote for a proposal: lockedValue,
lockedRound, validValue and validRound. lockedValue denotes
the most recent non-nil block for which the validator sent a pre-
commit message. validValue denotes the most recent non-nil block
for which the validator has observed 2ğ‘“ + 1 prevotes. Recency of
a block is determined by the round it was proposed for by the
leader of that round. Thus, lockedRound and validRound refer
to the rounds for which lockedValue and validValue were pro-
posed respectively. At the beginning of each height, lockedValue,
lockedRound, validValue and validRound are reset to âŠ¥, âˆ’1, âŠ¥ and
âˆ’1 respectively.

C.1.1 Propose. If the leader of a round ğ‘Ÿ , height â„, is honest, it
broadcasts the following proposal message at the beginning of the
round if its validRound â‰¥ 0: âŸ¨PROPOSAL, â„, ğ‘Ÿ, ğ‘£ = validValue, ğ‘£ğ‘Ÿ =
validRoundâŸ©. Otherwise, it proposes a new valid PoS block ğµ:
âŸ¨PROPOSAL, â„, ğ‘Ÿ, ğ‘£ = ğµ, ğ‘£ğ‘Ÿ = âˆ’1âŸ©. Similarly, upon receiving a
proposal message âŸ¨PROPOSAL, â„, ğ‘Ÿ, ğ‘£, ğ‘£ğ‘Ÿ âŸ© (from the round leader)
during the propose step of round ğ‘Ÿ and height â„, an honest validator
broadcasts the following prevote message âŸ¨PREVOTE, â„, ğ‘Ÿ, ğ‘–ğ‘‘ (ğ‘£)âŸ©
for the proposal if either (i) ğ‘£ is the same block as its lockedValue,
or (ii) ğ‘£ğ‘Ÿ is larger than its lockedRound. Otherwise, it sends a pre-
vote for a nil block: âŸ¨PREVOTE, â„, ğ‘Ÿ, ğ‘›ğ‘–ğ‘™âŸ©. Thus, by proposing its
validValue instead of a new block when ğ‘£ğ‘Ÿ â‰  âˆ’1, an honest leader
ensures that honest validators locked on blocks from previous
rounds will be prevoting for its proposal instead of nil blocks.

If the honest validator does not observe any proposal message
within a timeout period of its entry to the propose step, it sends
a prevote for a nil block. After sending its prevote, it leaves the
propose step and enters the prevote step.

C.1.2 Prevote. Once in the prevote step, the honest validator waits
until it receives 2ğ‘“ + 1 prevotes, for potentially different blocks,
upon which it activates a prevote countdown. If it observes 2ğ‘“ +
1 prevotes for a valid block ğµ proposed for round ğ‘Ÿ and height
â„ during this time, it sends the following precommit message
âŸ¨PRECOMMIT, â„, ğ‘Ÿ, ğ‘–ğ‘‘ (ğµ)âŸ© and enters the precommit step. It also
updates its lockedValue, lockedRound, validValue and validRound
to ğµ, ğ‘Ÿ , ğµ and ğ‘Ÿ respectively. If the honest validator receives 2ğ‘“ + 1
prevotes for nil blocks, it sends a precommit message for a nil block:
âŸ¨PRECOMMIT, â„, ğ‘Ÿ, ğ‘›ğ‘–ğ‘™âŸ©.

If the honest validator does not receive 2ğ‘“ + 1 prevotes for a
valid block ğµ before the countdown expires, it sends a precommit

Ertem Nusret Tas, David Tse, Fisher Yu, and Sreeram Kannan

Figure 9: Interaction of the Babylon client run by Babylon miners with the mining software in the context of merge-mining.
Babylon client uses the same hashing results generated by the Bitcoin miners as a Bitcoin client, but the criterion of mining
a new Babylon block based on those results is different from that of mining a Bitcoin block.

Figure 10: Interaction between the Babylon-embedded PoS chain client and the Babylon client in the context of timestamping
PoS block commitments.

for a nil block. After sending its precommit, it leaves the prevote
step and enters the precommit step.

C.1.3 Precommit. Finally, during the precommit step, our honest
validator waits until it receives 2ğ‘“ + 1 precommit messages, for
potentially different blocks, upon which it activates a precommit
countdown. If it observes 2ğ‘“ + 1 precommit messages for a valid
block ğµ proposed for round ğ‘Ÿ and height â„, it finalizes ğµ for height â„
and moves on to the next height â„ + 1. Otherwise, if the countdown
expires or there are 2ğ‘“ + 1 precommit messages for nil blocks,
validator enters the next round ğ‘Ÿ + 1 without finalizing any block
for height â„.

Timeout periods for proposal, prevote and precommit steps are
adjusted to ensure the liveness of Tendermint under Î” synchrony
when there are at least 2ğ‘“ + 1 honest validators. On the other hand,
the two step voting process along with the locking mechanism
guarantees its safety by preventing conflicting blocks from receiv-
ing more than 2ğ‘“ + 1 prevotes for the same round and more than
2ğ‘“ + 1 precommits for the same height.

C.2 Details of Stalling Resilience through

Babylon

This section presents a detailed description of how a Tendermint
round is recorded on Babylon and interpreted by the nodes when
the PoS chain is stalled. For the rest of this section, we assume that
the Babylon chain in the view of a node refers to the ğ‘˜ğ‘ /2-deep
prefix of the longest Babylon chain in its view.

To clarify the connection between censorship and stalling, we
extend the definition of censoring blocks presented in Section 5.5.1
to proposals recorded on Babylon: Consider an honest PoS node ğ‘
and let ğ‘ be a Babylon block containing a valid censorship complaint

in ğ‘â€™s Babylon chain, i.e., the longest Babylon chain in ğ‘â€™s view.
Define ğ‘ â€² as the first block on ğ‘â€™s Babylon chain that contains a
checkpoint and extends ğ‘ by at least 2ğ‘˜ğ‘ blocks. Then, a proposal
message (cf. Appendix C.1.1) for a block ğµ is said to be censoring
in ğ‘â€™s view if (i) the proposal was sent in response to a stalling
evidence within a block ğ‘ â€²â€² such that ğ‘ â€² â‰º ğ‘ â€²â€² and comes after the
checkpoint in ğ‘ â€² in ğ‘â€™s Babylon chain, and (ii) ğµ does not include
the censored transactions neither in its body nor within its prefix.
The 2ğ‘˜ğ‘ lower bound on the gap between ğ‘ and ğ‘ â€² ensures that all
finalized PoS blocks which exclude the censored transactions and
were proposed or voted upon by honest validator are checkpointed
by ğ‘ â€² or other Babylon blocks in its prefix, thus leaving no room to
accuse an honest validator for censorship.

Next, we describe a Tendermint round recorded on-Babylon in
the perspective of an honest validator ğ‘. Suppose there is a stalling
evidence for some height â„ on ğ‘â€™s Babylon chain and the evidence
is at least 2ğ‘˜ğ‘ blocks apart from the last preceding checkpoint.
Then, upon observing the first such stalling evidence recorded by
a Babylon block ğ‘, ğ‘ enters a new Tendermint round for height
â„, whose messages are recorded on-Babylon, and freezes the pa-
rameters lockedValue, lockedRound, validValue and validRound
in its view. If ğ‘ has observed a new valid Tendermint block become
finalized at the height â„ by that time, it sends a new checkpoint
to Babylon for that block. Otherwise, ğ‘ signs and sends a pro-
posal message to Babylon, pretending as the leader of the new
round. Since the round is recorded on Babylon, its number roundğ‘
is set to a special value, Babylon. Thus, ğ‘â€™s PROPOSAL message is
structured as âŸ¨PROPOSAL, â„, Babylon, ğ» (ğ‘£), ğ‘£ğ‘Ÿ âŸ©, where either (i)
(ğ‘£, ğ‘£ğ‘Ÿ ) = (validValue, validRound) held by ğ‘ if ğ‘â€™s validValue â‰¥ 0,
or (ii) (ğ‘£, ğ‘£ğ‘Ÿ ) = (ğµ, âˆ’1), where ğµ is a new PoS block created by ğ‘, if
ğ‘â€™s validValue = âˆ’1 (cf. Appendix C.1.1). If ğ‘£ğ‘Ÿ â‰¥ 0 and ğ‘ proposed

16

Babylon:
Reusing Bitcoin Mining to Enhance Proof-of-Stake Security

its validValue as the proposal ğ‘£, it also sends a commitment of the
2ğ‘“ + 1 prevote messages for ğ‘£ to Babylon along with the proposal.
This is to convince late-coming PoS nodes that the 2ğ‘“ + 1 prevote
messages for ğ‘£ were indeed seen by ğ‘ before it proposed ğ‘£.

Note that ğ‘ only includes the hash of the proposed block ğ‘£ in
the proposal message unlike the proposals in Tendermint (cf. Ap-
pendix C.1.1). To ensure that other PoS nodes can download ğ‘£ if
needed, miners check its availability before accepting ğ‘â€™s proposal
message as valid. Similarly, miners check the availability of pre-
votes upon receiving a proposal that proposes a validValue held by
the validator.

Let ğ‘1 and ğ‘2 denote the first blocks on ğ‘â€™s Babylon chain that
extend ğ‘ by ğ‘˜ğ‘ and 2ğ‘˜ğ‘ blocks respectively. If ğ‘ (or any honest PoS
node) observes a checkpoint for a PoS block finalized at height â„
between ğ‘ and ğ‘1, it stops participating in the round recorded on-
Babylon and moves to the next height, resuming its communication
with the other validators through the network. Otherwise, if there
are â‰¥ 2ğ‘“ + 1 non-censoring proposal messages signed by unique
validators between ğ‘ and ğ‘1, it selects the non-censoring valid
block proposed with the largest ğ‘£ğ‘Ÿ as the proposal of the â€˜Babylon
roundâ€™ emulated on-Babylon. If there are multiple proposals with
the highest ğ‘£ğ‘Ÿ , ğ‘ selects the one that appears earliest between ğ‘ and
ğ‘1 on Babylon. Selecting the proposal with the largest ğ‘£ğ‘Ÿ ensures
that the honest validators can later prevote and precommit for that
block without violating Tendermint rules (cf. Appendix C.1.1).

Once ğ‘ decides on a proposal ğµ and observes ğ‘1 in its Baby-
lon chain, if it is locked on PoS block, it checks if ğµ is the same
block as its lockedValue or if the proposalâ€™s ğ‘£ğ‘Ÿ is larger than its
lockedRound (cf. Appendix C.1.1). If so, it sends the following pre-
vote and precommit messages for the selected proposal to Babylon:
âŸ¨PREVOTE, â„,
Babylon, ğ‘–ğ‘‘ (ğµ)âŸ© and âŸ¨PRECOMMIT, â„, Babylon, ğ‘–ğ‘‘ (ğµ)âŸ© (cf. Sections
C.1.2 and C.1.3). If ğ‘ is not locked on any PoS block, it directly sends
the prevote and precommit messages. Unlike in Tendermint, ğ‘ does
not wait to observe 2ğ‘“ + 1 prevote messages for ğµ before it sends
its precommit message. This is because the purpose of the round
emulated on Babylon is to catch unresponsive validators stalling
the protocol, thus, does not need the two step voting. However, it
still keeps the two step voting for the purpose of consistency with
the Tendermint rounds that happened off-Babylon.

Finally, upon observing ğ‘2 in its Babylon chain, ğ‘ finalizes ğµ if
there are more than 2ğ‘“ +1 prevotes and precommits for ğµ, signed by
unique validators, between ğ‘1 and ğ‘2. In this case, ğ‘2 is designated
as the Babylon block that has checkpointed the finalized block for
height â„. Upon finalizing ğµ, ğ‘ moves to the next height, resuming
its communication with the other validators through the network.
If ğ‘ observes no new checkpoints and less than 2ğ‘“ + 1 uniquely
signed non-censoring proposals between ğ‘ and ğ‘1, it does not send a
prevote or precommit, and instead attempts to restart the round on-
Babylon by sending a new stalling evidence. Similarly, if ğ‘ observes
less than 2ğ‘“ + 1 uniquely signed prevotes or precommits for the
selected proposal ğµ between ğ‘1 and ğ‘2, it does not finalize ğµ, again
restarting the round on-Babylon. Finally, if ğ‘ observes a fraud proof
on Babylon that implies a safety violation on the PoS chains, it stops
participating in the Tendermint round on-Babylon and temporarily
halts finalizing new PoS blocks.

D PROOF OF THEOREM 1
We prove Theorem 1 below by showing properties S1-S2 and L1-L2
for the PoS chains.

D.1 Proof of the Safety Claims S1 & S2

Proposition 1. If a transaction tx is sent to the miners at time
ğ‘¡ â€²
ğ‘¡
ğ‘¡ + Î” such that |PoWChain
c| â‰¤ ğ¿ for all nodes c, tx âˆˆ PoWChain
câ€²
ğ‘¡ â€²
for any honest node câ€², where |PoWChain

| = ğ¿ + ğ‘˜ğ‘¤/2.

Proof of Proposition 1 follows from the ğ‘˜ğ‘¤/2-security of Baby-

lon.

Proposition 2. Consider a PoS block ğµ âˆˆ PoSLOGğ‘¡

ğ‘– , check-
ğ‘¡
pointed by a Babylon block ğ‘ âˆˆ PoWChain
ğ‘– . Then, there cannot
be any Babylon block in the prefix of ğ‘ that checkpoints a PoS block
conflicting with ğµ. If ğµ âˆˆ PoSLOGğ‘¡
ğ‘– and is not checkpointed in ğ‘–â€™s view
ğ‘¡
by time ğ‘¡, then there cannot be any Babylon block ğ‘ â€² âˆˆ PoWChain
ğ‘–
that checkpoints a PoS block conflicting with ğµ.

Proof. For the sake of contradiction, suppose there exists a
Babylon block ğ‘ â€² âª¯ ğ‘ such that ğ‘ â€² checkpoints a PoS block ğµâ€² that
conflicts with ğµ. Then, via the fork-choice rule in Section 5.3, ğµ âˆ‰
PoSLOGğ‘¡
ğ‘– , i.e. contradiction. Similarly, if ğµ is not checkpointed in
ğ‘¡
ğ‘–â€™s view by time ğ‘¡ and there exists a Babylon block ğ‘ â€² âˆˆ PoWChain
ğ‘–
such that ğ‘ â€² checkpoints a PoS block ğµâ€² that conflicts with ğµ, again
via the fork-choice rule in Section 5.3, ğµ âˆ‰ PoSLOGğ‘¡
ğ‘– , i.e. contradic-
â–¡
tion.

To show the safety claims S1 and S2, we prove that if Babylon
is secure with parameter ğ‘˜ğ‘¤/2, then whenever there is a safety
violation on the PoS chains, at least 1/3 of the validator set becomes
slashable in the view of all honest PoS nodes.

Proof. Suppose there is a safety violation on the PoS chains and
PoSLOGğ‘¡
ğ‘– observed by an honest node ğ‘– at time ğ‘¡ conflicts with
PoSLOGğ‘¡ â€²
ğ‘— observed by an honest node ğ‘— at time ğ‘¡ â€² â‰¥ ğ‘¡. Let ğµ1
and ğµ2 denote the first two conflicting PoS blocks on PoSLOGğ‘¡
ğ‘–
and PoSLOGğ‘¡ â€²
ğ‘— respectively. Via synchrony, by time ğ‘¡ â€² + Î”, every
honest node observes ğµ1 and ğµ2, their prefixes and the protocol
messages attesting to their PoS-finalization. Since the PoS protocol
has an accountable safety resilience of 1/3, upon inspecting the
blocks, their prefixes and the associated messages, any node can
irrefutably identify 1/3 of the validator set for ğµ1 and ğµ2 as having
violated the protocol, and submit a fraud proof to Babylon by time
ğ‘¡ â€² + Î”. Let ğ‘† denote the set of the adversarial validators witnessed
by the fraud proof.

For the sake of contradiction, assume that there is a validator
v âˆˆ ğ‘† that has not become slashable in the view of an honest node
c. Then, there exists a time ğ‘¡0 and a PoS block ğµâ€²
containing vâ€™s
2
withdrawal request such that ğµâ€²
is checkpointed by a Babylon block
2
ğ‘¡0
ğ‘ â€²
c and there is no fraud
that is at least ğ‘˜ğ‘¤-deep in PoWChain
2
ğ‘¡0
proof showing vâ€™s misbehavior on PoWChain
c (cf. Section 5.4).
Now, suppose ğ‘ â€²
has not become at least ğ‘˜ğ‘¤/2 deep in the longest
2
Babylon chain in the view of any node, including adversarial ones,
by time ğ‘¡ â€² + Î”. In this case, since the fraud proof submitted to the
Babylon chain by time ğ‘¡ â€² + Î” will appear and stay in the canonical
Babylon chain of all honest nodes within ğ‘˜ğ‘¤/2 block-time of ğ‘¡ â€² by

17

ğ‘¡0
Proposition 1, fraud proof will be on PoWChain
c as well. However,
this is a contradiction, implying that there must be at least one,
potentially adversarial, node ğ‘— â€², which observes ğ‘ â€²
become ğ‘˜ğ‘¤/2
2
deep in its longest Babylon chain at some time ğ‘  â‰¤ ğ‘¡ â€² + Î”.

Next, we analyze the following cases:

ğ‘¡
ğ‘– such
â€¢ Case 1: There exists a Babylon block ğ‘1 âˆˆ PoWChain

that ğ‘1 checkpoints ğµ1 and ğ‘1 âª¯ ğ‘ â€²

ğ‘¡
ğ‘– .
2 âˆˆ PoWChain

ğ‘¡
ğ‘– such
â€¢ Case 2: There exists a Babylon block ğ‘1 âˆˆ PoWChain

that ğ‘1 checkpoints ğµ1 and ğ‘ â€²

2 â‰º ğ‘1.

â€¢ Case 3: ğ‘ â€²
ğ‘¡
â€¢ Case 4: There does not exist a Babylon block ğ‘1 âˆˆ PoWChain
ğ‘–

ğ‘¡
ğ‘– .
2 âˆ‰ PoWChain

ğ‘¡
ğ‘– .
2 âˆˆ PoWChain

checkpointing ğµ1 at time ğ‘¡ and ğ‘ â€²
Case 1: ğ‘1 âª¯ ğ‘ â€²
2

ğ‘¡ â€²
ğ‘— , which
. By Proposition 2, ğ‘1 âˆ‰ PoWChain
ğ‘ 
implies that the ğ‘˜ğ‘¤/2 blocks building on ğ‘ â€²
ğ‘— â€² are not
in PoWChain
2
ğ‘¡ â€²
ğ‘— at time ğ‘¡ â€² â‰¥ ğ‘  âˆ’ Î”. However, this is a contradiction
in PoWChain
with the ğ‘˜ğ‘¤/2-safety of Babylon.

Case 2: ğ‘ â€²

2 â‰º ğ‘1. If ğµâ€²

conflicts with ğµ1, as ğµ1 âˆˆ PoSLOGğ‘¡
ğ‘– ,
via Proposition 2, ğ‘ â€²
2 â‰º ğ‘1 cannot be true, i.e. contradiction. On
the other hand, if ğ‘ â€²
2 â‰º ğ‘1 and ğµâ€²
does not conflict with ğµ1, then
2
ğµâ€²
2 â‰º ğµ1, in which case v cannot be in the validator set ğ‘† that voted
for ğµ1, i.e. contradiction.
ğ‘¡
ğ‘¡
ğ‘– . Suppose ğ‘¡ â‰¥ ğ‘ . Since PoWChain
2 âˆ‰ PoWChain
ğ‘–
does not contain the ğ‘˜ğ‘¤/2 Babylon blocks following ğ‘ â€²
in ğ‘— â€²â€™s
2
canonical Babylon chain at time ğ‘ , in this case, Babylon cannot be
safe with parameter ğ‘˜ğ‘¤/2, i.e., contradiction.

Case 3: ğ‘ â€²

2

On the other hand, if ğ‘¡ < ğ‘ , we consider the following sub-cases:

ğ‘¡ â€²
ğ‘— such
â€¢ Case 3-a: There exists a Babylon block ğ‘2 âˆˆ PoWChain

that ğ‘2 checkpoints ğµ2 and ğ‘2 âª¯ ğ‘ â€²
2

.

ğ‘¡ â€²
ğ‘— such
â€¢ Case 3-b: There exists a Babylon block ğ‘2 âˆˆ PoWChain

that ğ‘2 checkpoints ğµ2 and ğ‘ â€²
ğ‘¡ â€²
ğ‘— .
2 âˆ‰ PoWChain

â€¢ Case 3-c: ğ‘ â€²
ğ‘¡ â€²
â€¢ Case 3-d: There does not exist a Babylon block ğ‘2 âˆˆ PoWChain
ğ‘—

2 â‰º ğ‘2.

checkpointing ğµ2 at time ğ‘¡ â€² and ğ‘ â€²

ğ‘¡ â€²
ğ‘— .
2 âˆˆ PoWChain

2

Case 3-a: ğ‘2 âª¯ ğ‘ â€²
. In this case, as ğ‘¡ < ğ‘ , by time ğ‘  + Î”, node ğ‘–
2
would have observed both PoS blocks ğµ1 and ğµ2 along with their
prefixes and sent a fraud proof to the Babylon miners. Then, by
Proposition 1, the fraud proof will appear in the prefix of the ğ‘˜ğ‘¤-
th Babylon block building on ğ‘ â€²
in câ€™s canonical Babylon chain.
2
However, this is a contradiction with the assumption that v has
withdrawn its stake in câ€™s view.

2 â‰º ğ‘2. If ğµâ€²

conflicts with ğµ2, as ğµ2 âˆˆ PoSLOGğ‘¡ â€²
Case 3-b: ğ‘ â€²
ğ‘— ,
via Proposition 2, ğ‘ â€²
2 â‰º ğ‘2 cannot be true, i.e. contradiction. On
the other hand, if ğ‘ â€²
2 â‰º ğ‘2 and ğµâ€²
does not conflict with ğµ2, then
2
ğµâ€²
2 â‰º ğµ2, in which case v cannot be in the validator set ğ‘† that voted
for ğµ2, again a contradiction.
ğ‘¡ â€²
ğ‘¡ â€²
ğ‘— does not
ğ‘— . In this case, PoWChain
2 âˆ‰ PoWChain
contain the ğ‘˜ğ‘¤/2 Babylon blocks following ğ‘ â€²
in ğ‘— â€²â€™s canonical
2
Babylon chain at time ğ‘  â‰¤ ğ‘¡ â€² + Î”. However, this contradicts with
the ğ‘˜ğ‘¤/2-safety of the Babylon chain.

Case 3-c: ğ‘ â€²

ğ‘¡ â€²
Case 3-d: There does not exist a Babylon block ğ‘2 âˆˆ PoWChain
ğ‘—
ğ‘¡ â€²
ğ‘— . In this case,
2 âˆˆ PoWChain
ğ‘— , via Proposition 2,

checkpointing ğµ2 at time ğ‘¡ â€² and ğ‘ â€²
if ğµâ€²
2

conflicts with ğµ2 and ğµ2 âˆˆ PoSLOGğ‘¡ â€²

Ertem Nusret Tas, David Tse, Fisher Yu, and Sreeram Kannan

ğ‘¡ â€²
ğ‘ â€²
ğ‘— cannot be true, i.e. contradiction. On the other
2 âˆˆ PoWChain
hand, if ğµâ€²
2 â‰º ğµ2, v cannot be in the validator set ğ‘† that voted for ğµ2,
again a contradiction. Finally, if ğµ2 âª¯ ğµâ€²
also checkpoints
2
ğµ2 by the monotonicity of checkpoints (cf. Section 5.3), which is
a contradiction with the assumption that there does not exist a
ğ‘¡ â€²
ğ‘— checkpointing ğµ2 at time ğ‘¡ â€².
Babylon block ğ‘2 âˆˆ PoWChain

, then ğ‘ â€²
2

conflicts with ğµ1, as ğµ1 âˆˆ PoSLOGğ‘¡

ğ‘¡
Case 4: There does not exist a Babylon block ğ‘1 âˆˆ PoWChain
ğ‘–
ğ‘¡
checkpointing ğµ1 at time ğ‘¡ and ğ‘ â€²
ğ‘– . In this case, if
2 âˆˆ PoWChain
ğµâ€²
2 âˆˆ
2
ğ‘¡
ğ‘– cannot be true, implying contradiction. On the other
PoWChain
hand, if ğµâ€²
2 â‰º ğµ1, v cannot be in the validator set ğ‘† that voted for ğµ1,
again a contradiction. Finally, if ğµ1 âª¯ ğµâ€²
also checkpoints
2
ğµ1 by the monotonicity of checkpoints (cf. Section 5.3), which is
a contradiction with the assumption that there does not exist a
ğ‘¡
ğ‘– checkpointing ğµ1 at time ğ‘¡.
Babylon block ğ‘1 âˆˆ PoWChain

ğ‘– , via Proposition 2, ğ‘ â€²

, then ğ‘ â€²
2

Thus, by contradiction, we have shown that if the Babylon chain
satisfies ğ‘˜ğ‘¤/2-security, none of the validators in the set ğ‘† can with-
draw their stake in the view of any honest node by time ğ‘¡ â€² + Î”.
Moreover, since they have been irrefutably identified as protocol
violators by every honest node by time ğ‘¡ â€² + Î”, they are slashable
per Definition 3. Consequently, whenever there is a safety violation
on the PoS chains, at least 1/3 of the validators become slashable if
â–¡
Babylon satisfies ğ‘˜ğ‘¤/2-security.

No honest validator becomes slashable in the view of any PoS
node due to a safety violation since fraud proofs never identify
an honest validator as a protocol violators via the accountability
guarantee provided by Tendermint [15]. Thus, even if the adversary
compromises the security of the Babylon chain, it cannot cause
honest validators to get slashed for a safety violation on the PoS
chain. However, when the security of the Babylon chain is violated,
honest validators might be subjected to slashing for censorship
and stalling as the arrow of time determined by Babylon is dis-
torted. Since accountable liveness is impossible without external
trust assumptions, slashing of honest nodes is unavoidable if the
adversary can cause arbitrary reorganizations of blocks on Babylon.
This point is addressed in the next section.

D.2 Proof of the Liveness Claims L1 & L2
In this section, we prove that if Babylon is secure with parameter
ğ‘˜ğ‘ /2 â‰¤ ğ‘˜ğ‘¤/2, whenever there is a liveness violation exceeding
Î˜(ğ‘˜ğ‘ ) block-time, at least 1/3 of the active validator set becomes
slashable in the view of all honest nodes. Let ğ‘“ denote the safety
and liveness resilience of Tendermint such that ğ‘› = 3ğ‘“ + 1. In the
rest of this section, we assume that there is no safety violation
on the PoS chains and there is no fraud proof posted on Babylon
that accuses ğ‘“ + 1 active validators of equivocating on prevote or
precommit messages. We will relax this assumption and consider
the interaction between safety and liveness violations at the end of
this section.

In the rest of this section, we will assume that the Babylon chain
is ğ‘˜ğ‘ /2-secure per Definition 2 unless stated otherwise. Moreover,
in this section, Babylon chains in the view of honest nodes or
validators will refer to the ğ‘˜ğ‘ /2-deep prefix of the longest chain in
their view. Under the ğ‘˜ğ‘ /2-security assumption for Babylon, this
reference ensures that (i) the Babylon chains observed by different

18

Babylon:
Reusing Bitcoin Mining to Enhance Proof-of-Stake Security

honest nodes at any given time are prefixes of each other, and
(ii) the data behind every commitment appearing on the Babylon
chains held by the honest nodes is available per Definition 2.

Let PoWChain

ğ‘¡ , without any node specified, denote the shortest
Babylon chain in the view of the honest nodes at time ğ‘¡. Thus,
ğ‘¡ is a prefix of all Babylon chains held by the honest
PoWChain
nodes at time ğ‘¡. Moreover, by the synchrony assumption, we deduce
that all Babylon chains held by the honest nodes at time ğ‘¡ âˆ’ Î” are
ğ‘¡ , we can
prefixes of PoWChain
state the liveness property of the Babylon chain in the following
way:

ğ‘¡ . Using the notation PoWChain

Proposition 3. If a transaction tx is sent to the miners at time ğ‘¡ +Î”
ğ‘¡ â€²
, where |PoWChain

ğ‘¡ â€²
ğ‘¡ | = ğ¿, tx âˆˆ PoWChain

| =

such that |PoWChain
ğ¿ + ğ‘˜ğ‘ .

Proof of Proposition 3 follows from the ğ‘˜ğ‘ /2-security of Babylon.
As stated in Section 5.5, at least one honest node sends check-
points for new finalized PoS blocks every time it observes the
Babylon chain grow by ğ‘˜ğ‘ blocks. Moreover, if a PoS block is fi-
nalized for the first time in an honest nodeâ€™s view at time ğ‘¡, it is
finalized in every honest nodeâ€™s view by time ğ‘¡ +Î” via the synchrony
assumption.

Proposition 4. Suppose a PoS block is finalized in the view of
ğ‘¡ | = ğ¿. Then, a
ğ‘¡ â€²
, where

an honest node at time ğ‘¡ such that |PoWChain
checkpoint for the finalized block appears in PoWChain
|PoWChain

| = ğ¿ + 2ğ‘˜ğ‘ .

ğ‘¡ â€²

Proof of Proposition 4 follows from Proposition 3 and the as-

sumption above.

ğ‘¡ â€²
ğ‘¡ | = ğ¿ and |PoWChain

Lemma 1. Suppose |PoWChain

| = ğ¿ +
5ğ‘˜ğ‘ for times ğ‘¡, ğ‘¡ â€², and the height of the last PoS block finalized in any
honest nodeâ€™s view by time ğ‘¡ is â„ âˆ’ 1. Then, either a new non-censoring
Tendermint block for height â„ is checkpointed within the interval
(ğ‘¡, ğ‘¡ â€²] or ğ‘“ + 1 active validators must have violated the slashing rules
for censorship and stalling in Sections 5.5.2, C.2 and 5.5.4 in the view
of all honest nodes.

ğ‘¡ğ‘– | =
Proof. Let ğ‘¡ğ‘– denote the first time such that |PoWChain
ğ¿ + ğ‘–ğ‘˜ğ‘ . If no new checkpoint for height â„ appears on the Babylon
chain by time ğ‘¡2, at least one honest node must have sent a stalling
evidence to Babylon by that time. Thus, via Proposition 3, by time ğ‘¡3,
there exists a stalling evidence recorded in a block ğ‘ in the Babylon
chains held by all honest nodes. Similarly, by time ğ‘¡4, block ğ‘1 that
extends ğ‘ by ğ‘˜ğ‘ blocks appears in the Babylon chain of all honest
nodes. At this point, there are three possibilities:
(1) There is a new checkpoint in the prefix of ğ‘1 that commits to

a new PoS block finalized for height â„.

(2) There are less than 2ğ‘“ + 1 proposal messages signed by unique
validators, proposing non-censoring PoS blocks between ğ‘ and
ğ‘1.

(3) There are 2ğ‘“ + 1 or more proposal messages signed by unique
validators, proposing non-censoring PoS blocks between ğ‘ and
ğ‘1.

Case 1 implies that there is a new checkpoint in every honest nodeâ€™s
view by time ğ‘¡ â€² and case 2 implies that more than ğ‘“ + 1 active

19

validators must have violated the slashing rules in Sections 5.5.2
and 5.5.4 in the view of all honest nodes.

If case 3 happens, validators are required to send prevote and
precommit messages for the unique non-censoring PoS block ğµ
selected as described in Section C.2 by time ğ‘¡4. Moreover, by time
ğ‘¡5, block ğ‘2 that extends ğ‘1 by ğ‘˜ğ‘ blocks appears in the Babylon
chain of all honest nodes. Thus, if case 3 happens, there are two
possibilities at time ğ‘¡5:
(1) There are less than 2ğ‘“ + 1 prevote or precommit messages for

ğµ, signed by unique validators, between ğ‘1 and ğ‘2.

(2) There are 2ğ‘“ + 1 or more prevote and precommit messages for

ğµ, signed by unique validators, between ğ‘1 and ğ‘2.

In the former case, more than ğ‘“ + 1 active validators must have
violated the slashing rules in Section 5.5.4 in the view of all honest
nodes. In the latter case, block ğµ is PoS-finalized and block ğ‘2 acts
as a new checkpoint for the PoS block at height â„ as stated in
â–¡
Section C.2.

Lemma 2. No honest validator violates the slashing rules for cen-
sorship and stalling in Sections 5.5.2, C.2 and 5.5.4 in the view of any
honest node.

Proof. Censorship: Suppose a Babylon block ğ‘ containing a
censorship complaint first appears in the Babylon chains of all
ğ‘¡0 | = ğ¿. Let ğ‘¡ğ‘– denote the first
honest nodes at time ğ‘¡0, |PoWChain
ğ‘¡ğ‘– | = ğ¿ + ğ‘–ğ‘˜ğ‘ . For the sake of contradic-
time such that |PoWChain
tion, suppose an honest validator proposed or voted (precommit
or commit) for a censoring PoS block ğµ. Let ğ‘ â€² denote the Babylon
block containing the first checkpoint after ğ‘ that is more than 2ğ‘˜ğ‘
blocks apart from ğ‘. Given ğ‘ and ğ‘ â€², there are two cases for ğµ:

â€¢ ğµ is PoS-finalized and checkpointed by a Babylon block ğ‘ â€²â€²
such that ğ‘ â€² â‰º ğ‘ â€²â€² in all of the Babylon chains held by the
honest nodes.

â€¢ A proposal for ğµ appears in response to a stalling evidence
recorded by a Babylon block ğ‘ â€²â€² such that ğ‘ â€² â‰º ğ‘ â€²â€² (cf. Sec-
tion C.2).

Let â„ denote the largest height for which a PoS block was final-
ized in the view of any honest node by time ğ‘¡0. Then, by Proposi-
tion 4, a checkpoint for that block appears in the Babylon chains
held by all honest nodes by time ğ‘¡2 in the prefix of the 2ğ‘˜ğ‘ -th block
extending ğ‘. Thus, by the monotonicity of checkpoints, the check-
point within block ğ‘ â€² must cover the PoS block finalized for height
â„ + 1. Moreover, since honest validators cannot propose or vote
for PoS blocks at heights â‰¥ â„ + 2 before a block for height â„ + 1 is
finalized, if an honest validator proposed or voted for a PoS block
excluding the censored transactions by time ğ‘¡0, by definition, this
block must have been proposed for height â„ + 1 or lower. Conse-
quently, as honest validators would not propose or vote for new
PoS blocks excluding the censored transactions after time ğ‘¡0, such
a block can only be finalized at heights â‰¤ â„ + 1 and its checkpoint
can only appear as a checkpoint either in block ğ‘ â€² or within some
other Babylon block in its prefix. Hence, given the first case above,
it is not possible for an honest validator to have proposed or voted
for ğµ, i.e. contradiction.

In the second case, by Proposition 3, any stalling evidence recorded
by a Babylon block ğ‘ â€²â€² such that ğ‘ â€² â‰º ğ‘ â€²â€², must have been sent after
block ğ‘ was observed by every honest node on their Babylon chains.

From the explanation above, we know that a block that excludes
the censored transactions and voted upon or proposed by honest
validators can only be finalized at heights â‰¤ â„ +1 and its checkpoint
can only appear as a checkpoint either in block ğ‘ â€² or within some
other Babylon block in its prefix. Thus, if a proposal for block ğµ
appears in response to a stalling evidence recorded by ğ‘ â€² or one
of its descendants, ğµ must be for a height larger than â„ + 1. Since
no honest validator proposes or votes for PoS blocks from heights
larger than â„ + 1 that does not contain the censored transactions,
it is not possible for an honest validator to have proposed ğµ, i.e.
contradiction. Consequently, no honest validator could have com-
mitted a slashable offense per the rules in Sections 5.5.2 and C.2,
thus become slashable, in the view of any honest node.

Stalling: Consider a stalling evidence for height â„ recorded
by a Babylon block ğ‘ that is first observed by every honest node
ğ‘¡0 | = ğ¿. Define ğ‘1 and ğ‘2 as the
at time ğ‘¡0 such that |PoWChain
Babylon blocks that extend ğ‘ by ğ‘˜ğ‘ and 2ğ‘˜ğ‘ blocks respectively in
the Babylon chains of all honest nodes. For the sake of contradiction,
suppose there is no checkpoint between ğ‘ and ğ‘1 for height â„ and
a proposal message by an honest validator is missing in the same
interval. In this case, the validator could not have seen a PoS block
finalized for height â„ by time ğ‘¡0 as it would have otherwise sent
a checkpoint for it and the checkpoint would have been recorded
between ğ‘ and ğ‘1 by Proposition 3. Hence, the validator must have
sent a proposal message by time ğ‘¡0, which would appear between
ğ‘ and ğ‘1 by Proposition 3.

Next, assume that there are at least 2ğ‘“ + 1 proposal messages
for non-censoring blocks between ğ‘ and ğ‘1, and no checkpoint for
height â„. For the sake of contradiction, suppose that prevote or
precommit messages by an honest validator ğ‘ are either missing
between the blocks ğ‘1 and ğ‘2 or ğ‘ sent these messages for a PoS
block that is different from the proposal selected by another hon-
est node ğ‘ â€². In either case, ğ‘ becomes slashable for stalling in the
view of ğ‘ â€². To rule out both cases, we first show that all honest
validators choose the same block as their proposal, under our ini-
tial assumption that there is no fraud proof accusing ğ‘“ + 1 active
validators.

If all of the proposal messages between ğ‘ and ğ‘1 for non-censoring
PoS blocks have ğ‘£ğ‘Ÿ = âˆ’1, then all honest validators choose the block
proposed by the earliest message between ğ‘ and ğ‘1 as the proposal
of the on-Babylon Tendermint round (cf. Section C.2). If there is
only one proposal message between ğ‘ and ğ‘1 with ğ‘£ğ‘Ÿ â‰  âˆ’1 for a
non-censoring PoS block, then all honest validators choose this
block as the proposal for the on-Babylon Tendermint round. Finally,
suppose there are at least two proposal messages between ğ‘ and
ğ‘1 with ğ‘£ğ‘Ÿ â‰  âˆ’1 and for different non-censoring PoS blocks. Then,
different PoS blocks must have acquired at least 2ğ‘“ + 1 prevote
messages for the same round ğ‘£ğ‘Ÿ â‰  âˆ’1 of the latest height â„ (cf.
Section C.1). For different PoS blocks to acquire 2ğ‘“ + 1 prevote
messages for the same round ğ‘£ğ‘Ÿ of height â„, at least ğ‘“ + 1 validators
from the active validator set must have sent prevotes for conflicting
blocks proposed for the same round ğ‘£ğ‘Ÿ . In this case, a fraud proof
implicating these ğ‘“ + 1 current validators will be created by an hon-
est node and will eventually appear on the Babylon chain, which
contradicts with our assumption on fraud proofs. Thus, under this
assumption, either the maximum ğ‘£ğ‘Ÿ among all proposal messages
is greater than âˆ’1, in which case the messages with the largest ğ‘£ğ‘Ÿ

20

Ertem Nusret Tas, David Tse, Fisher Yu, and Sreeram Kannan

propose the same non-censoring PoS block, or all of them have
ğ‘£ğ‘Ÿ = âˆ’1, in which case the non-censoring block within the earliest
proposal on the Babylon chain between ğ‘ and ğ‘1 is selected by the
nodes. Hence, in any of the cases, ğ‘ could not have chosen, as its
proposal for the on-Babylon round, a PoS block that is different
from the proposal selected by another honest node ğ‘ â€².

Finally, if ğ‘â€™s lockedRound = âˆ’1, then it directly sends prevote
and precommit messages for the selected proposal upon observ-
ing block ğ‘1 (cf. Section C.2). Otherwise, if its lockedRound â‰  âˆ’1,
its âˆ’1 â‰  validRound â‰¥ lockedRound, and, as an honest valida-
tor, ğ‘ must have sent a proposal message with ğ‘£ğ‘Ÿsent equal to its
validRound. Then, for the ğ‘£ğ‘Ÿsel of the selected proposal, which is
the maximum among the ğ‘£ğ‘Ÿ values of all the proposals between
ğ‘ and ğ‘1, thus ğ‘£ğ‘Ÿsel â‰¥ ğ‘£ğ‘Ÿsent = lockedRound â‰¥ lockedRound of ğ‘,
there are two cases:

â€¢ ğ‘£ğ‘Ÿsel exceeds ğ‘â€™s lockedRound, in which case ğ‘ sends prevote
and precommit messages for the proposal upon seeing block
ğ‘1.

â€¢ ğ‘£ğ‘Ÿsel = lockedRound = validRound = ğ‘£ğ‘Ÿsent â‰  âˆ’1. In this case,
ğ‘ has sent a proposal message with the largest ğ‘£ğ‘Ÿ and must
have proposed the same PoS block as the one suggested by
the selected proposal message via the reasoning above, which
is validValue by Tendermint rules (cf. Section C.1.1). As ğ‘â€™s
lockedRound = validRound, it should be the case that ğ‘â€™s
lockedValue = validValue unless again there are ğ‘“ + 1 active
validators that sent prevote messages for conflicting blocks
at round lockedRound. Thus, ğ‘ again sends prevote and pre-
commit messages for the selected proposal upon seeing block
ğ‘1.

Thus, ğ‘ sends prevote and precommit messages upon seeing ğ‘1 for
the selected proposal which is the same across all honest nodes,
and these votes appear on Babylon in the view of all honest nodes
between blocks ğ‘1 and ğ‘2 by Proposition 3. Consequently, ğ‘ could
not have committed a slashable offense per the rules in Section 5.5.4,
and thus become slashable, in the view of any node ğ‘ â€², i.e., contra-
â–¡
diction.

Liveness part of Theorem 1 is proven below:

ğ‘¡ğ‘– | =
Proof. Let ğ‘¡ğ‘– denote the first time such that |PoWChain
ğ¿ + ğ‘–ğ‘˜ğ‘ . Suppose a censorship complaint is sent to Babylon at time
ğ‘¡0. Then, by Proposition 3, the complaint appears in the Babylon
chain of every honest node within some block ğ‘ by time ğ‘¡1. Let
â„ âˆ’ 1 be the height of the last PoS block finalized in any honest
nodeâ€™s view by time ğ‘¡3.

Suppose no more than ğ‘“ active validators violate the slashing
rules in Sections 5.5.2, C.2 and C.2 in the view of all honest nodes.
Then, via Lemma 1, a new non-censoring PoS block for height â„ is
checkpointed by some Babylon block ğ‘ â€² within the interval (ğ‘¡3, ğ‘¡8].
Similarly, again via Lemma 1, a new non-censoring PoS block ğµ
for a height larger than â„ is checkpointed by some Babylon block
ğ‘ â€²â€² by the time ğ‘¡13. As ğµ is non-censoring and appears within a
Babylon block ğ‘ â€²â€² such that ğ‘ â€² â‰º ğ‘ â€²â€² (cf. Sections 5.5.1 and C.2), by
definition of censoring blocks, it includes the censored transactions.
Consequently, unless ğ‘“ + 1 active validators violate the slashing
rules for censorship and stalling in the view of all honest nodes, any

Babylon:
Reusing Bitcoin Mining to Enhance Proof-of-Stake Security

valid PoS transaction becomes finalized and checkpointed within
13ğ‘˜ğ‘ blocktime of the time censorship is detected.

Finally, via Lemma 2, no honest validator violates the slashing
rules for censorship and stalling in Sections 5.5.2, C.2 and 5.5.4 in
the view of any honest node. Hence, if there is a liveness violation
for a duration of more than 13ğ‘˜ğ‘ block-time, either of the following
conditions must be true:

â€¢ L1: More than ğ‘“ + 1 â‰¥ ğ‘›/3 active validators, all of which are
adversarial, must have violated the slashing rules for censorship
and stalling in the view of all honest nodes. Thus, these protocol
violators will be identified as irrefutably adversarial in the view
of all honest nodes. As they are active validators and have not
withdrawn their stake, they also become slashable in the view
of all honest nodes.

â€¢ L2: The Babylon chain is not secure with parameter ğ‘˜ğ‘ /2.
This concludes the proof of the liveness claims in Theorem 1 under
the assumption that no fraud proof appears on Babylon accusing
ğ‘“ + 1 validators of a slashable offense for safety.

Finally, we relax the assumption on the fraud proof and safety.
Suppose there is a fraud proof on Babylon implicating ğ‘“ + 1 active
validators in a safety violation on the PoS chains. Then, the PoS
protocol is temporarily halted and no validator can be slashed for
any slashing rule other than for a safety violation (cf. Section 5.4).
This precaution prevents adversarial validators from making honest
ones slashable due to censorship or stalling in the event of a safety
violation on the PoS chains; however, results in a liveness violation
as the PoS protocol stops finalizing new blocks temporarily. Note
that if the Babylon chain is secure with parameter ğ‘˜ğ‘ /2, by the
assumption ğ‘˜ğ‘ â‰¤ ğ‘˜ğ‘¤, it is also secure with parameter ğ‘˜ğ‘¤. Hence,
if the protocol halts due to a safety violation on the PoS chains, at
least one of the following conditions should be true:

â€¢ Babylon chain is not secure with parameter ğ‘˜ğ‘ /2, implying

clause L2.

â€¢ Babylon chain is secure with parameters ğ‘˜ğ‘ and ğ‘˜ğ‘¤, implying
that at least ğ‘“ +1 > ğ‘›/3 adversarial validators become slashable
in the view of all honest nodes via the proof Section D.1, i.e.,
clause L1.

Thus, even though the halting of the protocol due to a safety viola-
tion could cause a liveness violation, the liveness claims of Theo-
rem 1 hold in this case as well. This concludes the liveness proof. â–¡

21

Algorithm 1 Validation of the commitments sent to Babylon by the miners. Returns true if the commitment is valid given the data ğ·.

function pow_validate_commitment(commitment, data, type)

Ertem Nusret Tas, David Tse, Fisher Yu, and Sreeram Kannan

3:

6:

9:

12:

15:

18:

21:

if type == checkpoint

âŠ² Parse the data for the checkpoint.
block_headers, transaction_roots, block_bodies â† parse_block_data(data)
âŠ² Check if the transaction roots sent as part of the data commit to the PoS block bodies.
for (block_header, transaction_root, block_body) â† block_headers, transaction_roots, block_bodies

if transaction_root â‰  ğ» (block_body)

return False

end if

end for
âŠ² Check if the checkpoint was correctly calculated.
if commitment == ğ» (block_headers || transaction_roots)

return True

end if
return False

else if type == message

âŠ² Check if the message commitment was correctly calculated.
if commitment == ğ» (data)

return True

end if
return False

end if
end function

Algorithm 2 Generation of the commitments by the PoS nodes. Returns the calculated commitment.

function generate_commitment(data, type)

if type == checkpoint

block_headers, transaction_roots, block_bodies â† parse_block_data(data)
return ğ» (block_headers || transaction_roots)

else if type == message
return ğ» (data)

end if
end function

3:

6:

22

Babylon:
Reusing Bitcoin Mining to Enhance Proof-of-Stake Security

Algorithm 3 Validation of the commitments on Babylon by the full PoS nodes. Returns true if the commitment is valid given the data ğ·.

3:

6:

9:

12:

15:

18:

21:

24:

27:

30:

function pos_validate_commitment(commitment, data, type)

if type == checkpoint

âŠ² Parse the data for the checkpoint.
block_headers, transaction_roots, block_bodies â† parse_block_data(data)
for ğ‘– â† 0, .., ğ‘™ğ‘’ğ‘›(block_headers) âˆ’ 1

block_header â† block_headers[i]
transaction_root â† transaction_roots[i]
block_body â† block_bodies[i]
âŠ² Check if the checkpointed PoS blocks were finalized.
if !is_finalized(block_header)

return False

end if
âŠ² Check if the checkpointed PoS blocks form a consecutive sequence on the PoS chain.
if ğ‘– â‰  ğ‘™ğ‘’ğ‘›(block_headers) âˆ§ !block_headers[ğ‘– + 1].is_ancestor(block_header || block_body)

return False

end if
âŠ² Check if the checkpoint was calculated with the correct transaction roots and if these roots commit to the PoS block body.
if transaction_root â‰  block_header.transaction_root âˆ¨ transaction_root â‰  ğ» (block_body)

return False

end if

end for
âŠ² Check if checkpoint was correctly calculated.
if commitment == ğ» (block_headers || transaction_roots)

return True

end if
return False

else if type == message

âŠ² Check if the message commitment was correctly calculated.
if commitment == ğ» (data)

return True

end if
return False

33:

end if
end function

23

Algorithm 4 Identifying the canonical PoS chain when there is a safety violation on the PoS chain. Returns the canonical PoS chain.

function identify_PoS_chain(Babylon_chain, PoS_blocktree)

Ertem Nusret Tas, David Tse, Fisher Yu, and Sreeram Kannan

PoS_canonical â† []
âŠ² Obtaining a sequence of valid checkpoints and the associated data from the PoW chain. Note that if there are two consecutive valid
checkpoints on Babylon such that the second checkpoint commits to blocks conflicting with those of the first one, the second one is not
returned.

commitments, data â† Babylon_chain.get_valid_checkpoints()
children â† [PoS_blocktree.genesis_block]
next â† True
âŠ² ğ‘– keeps track of which checkpoint in the sequence of returned valid checkpoints PoS node is currently considering.
ğ‘– â† 0
if ğ‘– â‰¥ ğ‘™ğ‘’ğ‘›(commitments)

block_headers, transaction_roots, block_bodies â† âŠ¥, âŠ¥, âŠ¥

else

cur_commitment â† commitments[0]
cur_data â† data[0]
block_headers, transaction_roots, block_bodies â† parse_block_data(cur_data)

end if
while children â‰  âˆ…

for PoS_block â† children

âŠ² Check if the current PoS block is committed by a valid and early checkpoint, and should be part of the canonical PoS chain.
if PoS_block.header âˆˆ block_headers

children â† PoS_blocktree.get_children(PoS_block)
next â† False
PoS_canonical â† PoS_canonical + [PoS_block]
âŠ² All of the blocks in the current checkpoint are accounted for. PoS node now considers the PoS blocks attested by the next

valid checkpoint.

if PoS_block.header == block_headers[-1]

ğ‘– â† ğ‘– + 1
if ğ‘– â‰¥ ğ‘™ğ‘’ğ‘›(commitments)

block_headers, transaction_roots, block_bodies â† âŠ¥, âŠ¥, âŠ¥

else

cur_commitment â† commitments[i]
cur_data â† data[i]
block_headers, transaction_roots, block_bodies â† parse_block_data(cur_data)

end if

end if
Break

end if

end for
âŠ² If there is no checkpoint to help decide which children of a block on the PoS chain to follow as the next block on the canonical PoS

chain, decision is made in favor of the first child returned by the get_children function.

if next

PoS_canonical â† PoS_canonical + [children[0]]
children â† PoS_blocktree.get_children(children[0])

end if
next â† True

end while
return PoS_canonical

3:

6:

9:

12:

15:

18:

21:

24:

27:

30:

33:

36:

39:

42:

45: end function

24

Babylon:
Reusing Bitcoin Mining to Enhance Proof-of-Stake Security

Algorithm 5 Granting stake withdrawal request and slashing protocol violators in the event of a safety violation. Returns true if the
withdrawal request for the specified validator is to be granted in the view of the PoS node running the function, slashes the stake of the
validator if there is a fraud proof accusing it.

function grant_withdrawal_request(Babylon_chain, validator)

commitments, data â† Babylon_chain.get_valid_checkpoints()
âŠ² get_all_checkpointed_blocks returns all checkpointed, valid and finalized PoS blocks given a sequence of commitments and data.
pos_blocks â† get_all_checkpointed_blocks(commitments, data)
PoS_block â† âŠ¥
for block â† blocks

if âˆƒ withdrawal_req by validator âˆˆ block

PoS_block â† block
Babylon_block_height â† Height of the Babylon block containing the checkpoint for PoS_block

end if

end for
âŠ² Without a checkpoint for the PoS block containing the withdrawal request, request cannot be granted.
if PoS_block == âŠ¥
return False

end if
âŠ² If the checkpoint of the PoS block containing the request is not sufficiently deep in Babylon in the view of the PoS node, then the

request is not granted.

if ğ‘™ğ‘’ğ‘›(Babylon_chain) â‰¤ Babylon_block_height + ğ‘˜ğ‘¤

return False

end if
âŠ² If the checkpoint of the PoS block containing the request is indeed ğ‘˜ğ‘¤ deep in Babylon in the view of the PoS node, then the request is

granted only after checking for the fraud proofs as specified by condition (3) in Section 5.4

Babylon_fragment â† Babylon_chain[Babylon_block_height : Babylon_block_height + kw]
commitments, fraud_proofs â† Babylon_fragment.get_valid_fraud_proofs()
for fraud_proof â† fraud_proofs

if fraud_proof accuses validator

âŠ² Validator is slashed if there is a valid fraud proof on Babylon that irrefutably accuses the validator.
slash_validator(validator, fraud_proof)
return False

end if

end for
return True

end function

3:

6:

9:

12:

15:

18:

21:

24:

27:

30:

Algorithm 6 Identifying all censoring PoS blocks with respect to a censorship complaint on Babylon. Takes as input the canonical Babylon
chain, height of the Babylon block with the censorship complaint, and the canonical PoS chain. Slashes the validators that proposed or voted
for the censoring blocks.

function is_block_censoring(Babylon_chain Babylon_block_height, PoS_block, PoS_canonical)

commitments, censored_txs â† Babylon_chain[Babylon_block_height].get_valid_censorship_complaint()
âŠ² Get all checkpoints that extend the Babylon block with the censorship complaint by at least 2ğ‘˜ğ‘ blocks.
commitments, data â† Babylon_chain[Babylon_block_height + 2ğ‘˜ğ‘ :].get_valid_checkpoints()
âŠ² Parse over these checkpoints starting from the second one as stated in Section 5.5.1
for ğ‘– â† 1, .., ğ‘™ğ‘’ğ‘›(data) âˆ’ 1

block_headers, transaction_roots, block_bodies â† parse_block_data(data)
âŠ² Detect the censoring blocks on the PoS chain as attested by each checkpoint.
for PoS_block â† block_headers, block_bodies

if censored_txs âˆ‰ PoS_canonical[: PoS_block] âˆ§ censored_txs valid w.r.t the state of PoS_canonical[: PoS_block]

Slash validators that proposed and voted upon PoS_block

end if

end for

3:

6:

9:

12:

end for

15: end function

25

Algorithm 7 Emulating a Tendermint round on Babylon when there is a stalling evidence. This function is evoked by validators if a stalling
evidence is observed on the ğ‘˜ğ‘¤/2-deep prefix of the longest Babylon chain. There are ğ‘› = 3ğ‘“ + 1 active validators in total.

function emulate_round_on_Babylon

Ertem Nusret Tas, David Tse, Fisher Yu, and Sreeram Kannan

3:

6:

9:

12:

15:

18:

21:

24:

27:

30:

33:

36:

39:

42:

upon stalling_evidence âˆˆ Babylon_block

checkpoint_height â† Babylon_chain.get_last_checkpoints_height()
commitment, data â† Babylon_chain.get_last_checkpoint()
block_headers, transaction_roots, block_bodies â† parse_block_data(data)
âŠ² Stalling evidence is taken into consideration only if it comes to Babylon at least 2ğ‘˜ğ‘ blocks after the last checkpoint on Babylon.
if Babylon_block.height â‰¥ checkpoint_height + 2ğ‘˜ğ‘

âŠ² If the validator has observed new PoS blocks finalized at the heights not covered by the last checkpoint, it sends a checkpoint for

the new PoS blocks instead of emulating the round on Babylon.

if last_finalized_PoS_block.header âˆ‰ block_headers

Send checkpoint to Babylon

else

âŠ² See Appendix C.2 for more information on how proposal messages are selected and structured.
Send Tendermint proposal to Babylon

end if

end if
end upon
âŠ² This is block ğ‘1 on Figure 7.
upon Babylon block with height checkpoint_height + 3ğ‘˜ğ‘

proposals â† Babylon_chain[âˆ’kc :].get_non_censoring_proposals()
if ğ‘™ğ‘’ğ‘›(proposals) < 2ğ‘“ + 1

Slash validators with missing or censoring proposals
Send new stalling evidence
return

else

âŠ² Proposal with the largest validRound is selected, details are in Appendix C.2.
round_proposal â† select_round_proposal(proposals)
âŠ² See Appendix C.2 for more information on how prevotes and precommits are structured.
Send prevote and precommit to Babylon for round_proposal

end if
end upon
âŠ² This is block ğ‘2 on Figure 7.
upon Babylon block with height checkpoint_height + 4ğ‘˜ğ‘

prevotes â† Babylon_chain[âˆ’kc :].get_prevotes(proposal)
precommits â† Babylon_chain[âˆ’kc :].get_precommits(proposal)
if ğ‘™ğ‘’ğ‘›(prevotes) < 2ğ‘“ + 1 âˆ¨ ğ‘™ğ‘’ğ‘›(precommits) < 2ğ‘“ + 1

Slash validators whose prevotes and precommits are missing for round_proposal
Send new stalling evidence
return

else

Finalize round_proposal

end if
end upon
end function

26

