ACCEPTED AT IEEE INTERNET OF THINGS JOURNAL

1

BEdgeHealth: A Decentralized Architecture for
Edge-based IoMT Networks Using Blockchain

Dinh C. Nguyen, Member, IEEE, Pubudu N. Pathirana, Senior Member, IEEE,
Ming Ding, Senior Member, IEEE, and Aruna Seneviratne, Senior Member, IEEE

1
2
0
2

p
e
S
9
2

]
P
S
.
s
s
e
e
[

1
v
5
9
2
4
1
.
9
0
1
2
:
v
i
X
r
a

Abstract—The healthcare industry has witnessed signiﬁcant
transformations in e-health services by using mobile edge com-
puting (MEC) and blockchain to facilitate healthcare operations.
Many MEC-blockchain-based schemes have been proposed, but
technical challenges still remain, such as low
some critical
quality of services (QoS), data privacy and system security
vulnerabilities. In this paper, we propose a new decentralized
health architecture, called BEdgeHealth that integrates MEC and
blockchain for data ofﬂoading and data sharing in distributed
hospital networks. First, a data ofﬂoading scheme is proposed
where mobile devices can ofﬂoad health data to a nearby
MEC server for efﬁcient computation with privacy awareness.
Moreover, we design a data sharing scheme which enables data
exchanges among healthcare users by leveraging blockchain
and interplanetary ﬁle system. Particularly, a smart contract-
based authentication mechanism is integrated with MEC to
perform decentralized user access veriﬁcation at the network
edge without requiring any central authority. The real-world
experiment results and evaluations demonstrate the effectiveness
of the proposed BEdgeHealth architecture in terms of improved
QoS with data privacy and security guarantees, compared to the
existing schemes.

Index Terms—Blockchain, mobile edge computing, healthcare,

data ofﬂoading, data sharing, security.

I. INTRODUCTION

Recent advances in mobile edge computing (MEC) and
Internet of Medical Things (IoMT) technologies have pro-
moted smart e-health services [2] in the healthcare industry. In
hospital networks, health data collected from mobile devices
(MDs), i.e., smartphones, laptops, and tablets, can be ofﬂoaded
to nearby MEC servers for low-latency data execution, which
thus helps improve users’ computation experience, enhance
quality of services (QoS) and reduce computing burden on
local devices. Further, MEC also enables the ubiquitous shar-
ing of health data acquired from the ofﬂoading phase among
health users to support healthcare delivery [3]. For example,
a doctor can exploit health data at the network edge to serve
disease diagnosis and treatment, and patients can gain medical
beneﬁts such as medication advice in a low-latency fashion.

*Part of this work has been accepted at the IEEE Global Communications

Conference (GLOBECOM), Taiwan, 2020 [1].

Dinh C. Nguyen is with School of Engineering, Deakin University, Waurn
Ponds, VIC 3216, Australia, and also with the Data61, CSIRO, Docklands,
Melbourne, Australia (e-mail: cdnguyen@deakin.edu.au).

Pubudu N. Pathirana is with School of Engineering, Deakin University,
Waurn Ponds, VIC 3216, Australia (email: pubudu.pathirana@deakin.edu.au).
(email:

the Data61, CSIRO, Australia

Ming Ding

is with
ming.ding@data61.csiro.au).

Aruna Seneviratne is with School of Electrical Engineering and Telecom-
munications, University of New South Wales (UNSW), NSW, Australia
(email: a.seneviratne@unsw.edu.au).

Particularly, blockchain, a disruptive technology for enabling
healthcare in recent years, is able to provide high security
for health data sharing due to its unique features such as
decentralization, traceability, and immutability [4]. In fact,
blockchain can ensure reliable data exchange among health-
care users such as healthcare providers, insurance companies,
and patients in smart healthcare environments like cooperative
hospital networks [5], by using immutable data ledgers and
smart contracts [4]. Enabled by the computing efﬁciency of
MEC and the security features of blockchain, the combination
of these two emerging technologies has been regarded as the
key enabler for smart healthcare services, i.e., data ofﬂoading
and data sharing, in distributed hospital settings [2].

However, realizing the potential of such a comprehensive
system in healthcare still faces non-trivial challenges. First,
how to ofﬂoad IoT healthcare data to the MEC servers to
support e-health applications while guaranteeing both high
QoS (i.e., minimal service latency) and data privacy is a critical
issue. Most traditional approaches [6], [7] only either focus on
the QoS problem of network latency and energy usage or data
privacy for the healthcare ofﬂoading, while building a holistic
framework with all these factors taken into consideration is
vitally necessary. Second, some data sharing solutions in [8]
rely on a centralized cloud architectur which is prone to single-
point failures and raises trust concerns from third party. The
storage of electronic health records (EHRs) in central cloud
also incurs high communication overhead, although it requires
less data management efforts. Final, some blockchain-based
proposals for health data sharing have been introduced in
recent works [9]–[11]. However, these schemes often use a
classic interplanetary ﬁle system (IPFS) which relies on a
global Distributed Hash Table (DHT) for health data storage
and sharing, leading to high data retrieval latency. To be clear,
to access a record stored on an IPFS node, one needs to refer
to a DHT to obtain the hash and then returns to the IPFS node
for retrieving data, which incurs high data sharing overhead.
Moreover, the potential of blockchain for healthcare sharing
scenarios with MEC in cooperative hospital networks has not
been adequately investigated.

To ﬁll these research gaps, this paper proposes a new decen-
tralized health architecture which integrates a data ofﬂoading
scheme and a data sharing scheme for distributed hospital
networks with MEC and blockchain. Particularly, we design a
new decentralized smart contract associated with IPFS running
on top of the MEC network which brings two key beneﬁts.
is able to provide authentication
First,
and traceability in the data sharing [9]. Any upload events

the smart contract

 
 
 
 
 
 
ACCEPTED AT IEEE INTERNET OF THINGS JOURNAL

2

or user access behaviours in the hospital network will be
authenticated and traced by the contract without the need of
external authority. Further, any modiﬁcation or alternation on
the data record will lead to a change on hash value, which
can be also traced by the contract. Second, the combination of
smart contract and IPFS helps accelerate the data retrieval rate.
Here, we make an improvement in IPFS design by eliminating
the global DHT. Instead, we store directly the hash values of
data records in the smart contract at each of the MEC servers,
which improves the data lookup and data retrieval rates in the
data sharing.

A. Motivations and Contributions

First, the work in [12] makes us realize that the research on
health data ofﬂoading and data sharing is of great practical sig-
niﬁcance in facilitating smart healthcare. Second, the existing
studies on mobile health data ofﬂoading [13], [14] motivate
us to focus on the MEC framework for highly efﬁcient health
data computation. Moreover, the analysis in [15], [9] and
the preliminary results from our recent work [10] reveal that
blockchain can provide promising health data sharing solutions
with improved QoS and enhanced security. Third, the in-depth
discussion in [4] highlights the urgent need of developing a
comprehensive architecture of data ofﬂoading and data sharing
for improving the healthcare quality. Therefore, the above
existing works strengthen our determination to implement a
comprehensive healthcare architecture by using blockchain,
IPFS, smart contract and MEC technologies. The key con-
tributions of this paper are summarized as follows:

1) We propose a new decentralized health architecture for
a cooperative hospital network, called BEdgeHealth that
integrates blockchain and MEC for data ofﬂoading and
data sharing with user QoS and security awareness.
2) We propose a privacy-aware health data ofﬂoading
scheme where MDs can ofﬂoad data tasks to a nearby
MEC server for efﬁcient computation. An optimization
algorithm is built on each MD to minimize the ofﬂoading
cost of energy consumption, processing time, and mem-
ory usage with respect to system constraints.

3) We develop a data sharing scheme enabled by the cooper-
ation of blockchain, MEC, smart contract and IPFS in the
distributed hospital network. Particularly, a decentralized
authentication mechanism associated with a distributed
IPFS storage is built to implement access control and
data management at the network edge without requiring
third party, in order to enhance the sharing security and
improve data retrieval rate.

4) We conduct real-world experiments to evaluate the effec-
tiveness of the proposed BEdgeHealth architecture. The
implementation results and discussions demonstrate the
superior performance of our proposed approach over the
existing works.

B. Organization

The remainder of the paper is organized as follows. Sec-
tion II discusses the literature works related to health data
ofﬂoading and data sharing. In Section III, we introduce our

decentralized health architecture where the network compo-
nents and blockchain are explained. We then present our
data ofﬂoading scheme in Section IV where the ofﬂoading
model is formulated. Next, Section V introduces the health
data sharing scheme using blockchain in distributed hospitals.
The experimental results are provided in Section VI, while
Section VII presents the security analysis and discussions.
Finally, Section VIII concludes the paper and highlights some
possible future works.

II. RELATED WORKS

In this section, we survey the literature works related to

health data ofﬂoading and sharing in healthcare.

A. Health Data Ofﬂoading

Many data ofﬂoading approaches have been proposed to
support healthcare. In [6], mobile healthcare data can be
ofﬂoaded to cloud for processing, analysis, and storage, but
it remains high latency incurred by ofﬂoading data to remote
clouds. Also, the ofﬂoading privacy is not considered, which
puts sensitive health data at risks of external attacks. Another
work in [12] proposed an IoT architecture for executing
healthcare applications on clouds, but the optimization for
memory usage of MDs in the ofﬂoading has been overlooked.
In fact, there is close relationship between memory usage
and the data task as investigated in the recent work [16].
That is, the higher size of data tasks to be ofﬂoaded, the
higher device memory required to handle the task. Therefore,
it is important to consider device memory usage in the data
task ofﬂoading. Other works in [7], [13], [14] concentrated
on ofﬂoading security issues in healthcare. For example, the
research in [13] used a hash function and a key cryptosystem
for data security. Also, the ofﬂoading privacy issues were also
solved in [7], [14] by using consensus algorithms and learning-
based privacy preservation techniques with respect to response
time and delay requirements. However, the above studies lack
the joint consideration of all QoS constraints (i.e., network
latency, energy consumption and memory usage) and privacy
awareness, which are the important aspects of practical health
data ofﬂoading systems [3].

B. Health Data Sharing

Several solutions using blockchain have been introduced
for health data sharing. Our preliminary work in [1] pro-
posed a decentralized health data sharing based on blockchain
and MEC for federated hospitals. The work [8] presented a
privacy-preserved data sharing scheme enabled by the con-
junction of a tamperproof consortium blockchain and cloud
storage. Furthermore, the authors in [15] described a hybrid
architecture of using both blockchain and edge-cloud nodes
where smart contracts are employed to monitor access be-
haviours and transactions. Despite data privacy enhancements,
such solutions [8], [15] mainly rely on central cloud servers
for EHRs storage, which remains single-point failure bottle-
necks and incurs high communication overhead. Further, the
performances of smart health contract have not been evaluated.

ACCEPTED AT IEEE INTERNET OF THINGS JOURNAL

3

Fig. 1: The proposed healthcare architecture with MEC and blockchain.

Another work in [9] employed an IPFS system with Ethereum
blockchain for EHRs sharing over clouds, but the important
performance metrics such as data retrieval speed and security
capability have not been veriﬁed. Moreover,
the work in
[11] described a privacy-preserving EHRs sharing by using
blockchain in the Ethereum. Blockchain stores hash values
of EHRs while raw data is kept on the cloud server. The
authors also constructed a stealth authorization framework to
achieve privacy-preserving access authorization delivery over
the hospital network. The study in [17] suggested an EdgeCare
model that uses edge computing for healthcare management in
decentralized health environments. The local authorities were
employed to perform access veriﬁcation for the data ofﬂoading
and sharing, but healthcare storage has not been considered.
Also, a privacy-preserving sharing scheme for IoTs including
healthcare was also considered in [18] by using a classic IPFS
system with a global DHT look-up solution that results in
unnecessary communication overhead.

III. SYSTEM MODEL

In this section, we present a new health architecture in

hospital networks and then describe our blockchain design.

A. Proposed Healthcare Architecture with MEC and
Blockchain

Here, we propose a decentralized health architecture as
shown in Fig. 1. The proposed architecture consists of a
network of cooperative hospitals linked by a blockchain ledger.
Each hospital is controlled by an MEC server which executes
the data tasks ofﬂoaded by MDs and also communicates with

other MEC servers for data sharing. Here, we consider a set
of MEC servers as M = {1, 2, ..., M }, each MEC server m
is located at a hospital HPm. We assume that each hospital
has a set of MDs N = {1, 2, ..., N } which collect data from
a set of patient J = {1, 2, ..., J} using IoMT devices. Then,
this data is ofﬂoaded to the MEC server for computation via
the data ofﬂoading scheme. Note that here we consider at each
hospital HPm, a MD n can collect health data from different
patients. We also assume that there is a set of healthcare users
(HUs) U = {1, 2, ..., U } such as doctors, clinicians who may
be situated at any hospital and want to access data on the MEC
network via the data sharing scheme (healthcare users, users
and HUs are used interchangeably throughout the paper). The
details of each network components are explained as follows.

• MEC servers: Each MEC server acts as a coordinator
that manages a group of MD devices in its hospital
to provide low-latency computation services in the data
ofﬂoading scheme. The MEC server also links with the
other MEC servers from other hospitals in a peer-to-
peer (P2P) manner to build a decentralized data sharing
network. We consider a realistic scenario that MEC
servers may be semi-trusted, which means that the MEC
server may be curious about health data and misbehaves
in the data sharing. To overcome these challenges, we
store sensitive EHRs data in the IPFS, instead of in the
MEC server’s hard drive, while the hash value of data
record is kept in the smart contract so that any data
retrieval behaviours are traced on the blockchain in a
transparent manner.

• Healthcare users (HUs): HUs such as doctors and

Remote EHRs sharingLocal EHRs sharingHealthcare usersData offloadingIoMT devicesMEC Server 2Hospital 2IPFS storageMDMDData offloadingIoMT devicesMEC Server mHospital mIPFS storageMDMDData offloadingIoMT devicesMEC Server 3Hospital 3IPFS storageMDMDData offloadingIoMT devicesMEC Server 1Hospital 1IPFS storageMobile device (MD)MDData offloadingGlobal blockchainPeer-to-peer communicationLocal blockchainSmart contractsData sharingACCEPTED AT IEEE INTERNET OF THINGS JOURNAL

4

clinicians across federated hospitals may be interested in
EHRs data for providing healthcare, e.g., medical diagno-
sis. Considering the realistic health settings that the HUs
are not trusted, we develop an access control mechanism
based on smart contracts to perform authentication of user
access behaviours, which will be presented in Section V.
Only authenticated users are able to retrieve data in the
IPFS, while malicious users are detected and prevented.
• Mobile devices (MDs): MDs such as smartphones,
laptops are responsible for gathering data from IoMT
sensors. The MD can use its hardware to execute its data
tasks or ofﬂoad them to a nearby MEC server by data
ofﬂoading. In this paper, we use smartphones as MDs
to collect data from wearable sensors and perform data
computation.

• IPFS storage: As MEC servers are semi-trusted, in our
paper, raw EHRs collected from IoMT and data processed
from the ofﬂoading phase are uploaded to the decen-
tralized off-chain IPFS platform running on top of the
MEC network. IPFS introduces low-latency and fast de-
centralized archiving with reliable P2P content delivery,
which has been investigated in healthcare scenarios [19];
and thus it is well suitable for our health applications.
Specially, in our work, we make an improvement in the
IPFS design by replacing the global DHT with smart
contracts to manage the hash records of health data,
aiming to solve communication latency issues remained
in classic IPFS systems [9], [10].

• Smart contract: A smart contract can be regarded as a
self-operating computer program which is automatically
executed when speciﬁc conditions are met [4]. Each
contract has an account that contains data and codes with
programmable logic functions. In our paper, we design
a contract called access control smart contract (ACSC).
Each MEC server holds a copy of smart contracts and
any their new events (i.e., user access) are updated at
other MEC servers via the global blockchain network.
The details of our contract design will be explained in
the following section.

B. Blockchain Design

Blockchain is the heart of our decentralized healthcare ar-
chitecture. In this paper, we suggest using a permissioned Hy-
perledger Fabric [20] blockchain platform based on practical
Byzantine fault tolerance (PBFT) consensus to implement our
healthcare system. The Hyperledger Fabric blockchain only al-
lows authenticated users to join the network, and the validation
is performed by only pre-selected nodes with high computing
capability, i.e., MEC servers in our scenario, without mining
requirements for lightweight entities like mobile users. This
would improve the transaction performance, i.e., low transac-
tion latency, compared to permissionless blockchains such as
Ethereum [20]. As shown in Fig. 1, we consider two types of
blockchain for our healthcare architecture: a global blockchain
and local blockchains.

• Global blockchain: It interconnects all MEC servers
together for hospital communications under the control

of all MEC servers. Once a data storage event at each
MEC server occurs (triggered by the ofﬂoading process),
this MEC server broadcasts an ofﬂoading transaction to
the other MEC servers for global updates. Moreover, in
the data sharing phase, when a mobile user performs a
data request to an MEC server, this MEC server also
creates a sharing transaction and broadcasts it to other
MEC servers in the hospital network.

• Local blockchain: Each hospital deploys a local hospital
to link the local MEC server with its mobile users. This
local blockchain is controlled by the local MEC server.
When a mobile user performs a data request to the MEC
server, he creates a sharing transaction and submits it to
the local blockchain so that the MEC server can process
the request and return the data. If the MEC server can
look up data locally, the server will return immediately
to the user. Otherwise, it asks the other MEC servers to
ﬁnd the address of the requested data and then responds
the user.

Remark: It is worth noting that in the proposed healthcare
architecture as illustrated in Fig. 1, blockchain is only used
in the sharing scheme, while we assume that the ofﬂoading
network is private and thus does not need to apply blockchain
in the ofﬂoading scheme. In fact, this assumption holds in
practical hospital settings [21] where each MD is managed by
its healthcare provider such as a physician who uses the device
to only collect data from his trusted patients and ofﬂoad it to
the MEC server in each medical test.

In the following sections, we will present our designs for a
data ofﬂoading scheme and a data sharing scheme in details.

IV. HEALTH DATA OFFLOADING

In this section, we introdude the ofﬂoading scheme and then

formulate the ofﬂoading model in details.

A. Ofﬂoading Model

Here, we focus on formulating the ofﬂoading model for a
representative hospital. Based on the QoS requirements (i.e.,
latency, energy consumption), each health data task can be
executed at the MD or at the MEC server via task ofﬂoading.
Accordingly, we introduce an ofﬂoading decision policy for
each MD n denoted by a binary variable xn ∈ {0, 1}. Here
xn = 0 means that the MD n decides to process its data task
locally, and xn = 1 indicates that the MD n ofﬂoads its task
to the MEC server. For the sake of simplicity, we assume that
each MD n has a task Yn to be executed, which can be deﬁned
by a variable Yn = (Dn, X l
n, T max
), where Dn expresses
n
the size of the input data (in bit), X l
n denotes the required
number of CPU cycles of the task, and T max
speciﬁes the
maximum permissible latency (in second) to accomplish the
task Yn. Motivated by the experimental results of our recent
work [22], in this paper we propose an ofﬂoading architecture
as shown in Fig. 2 which consists of two main modules: task
proﬁle and decision maker installed on each MD n.

n

- Task proﬁle: This module is responsible for collecting all
task information such as the data task Yn, energy consumption
(En), processing time (Tn) and memory usage (Mn), by using

ACCEPTED AT IEEE INTERNET OF THINGS JOURNAL

5

includes three parts: the task encryption time at the MD n,
the time for transmitting the task to the MEC server, and
the task execution time at the MEC server. Then, let denote
X enc
n as mobile CPU utilization for encrypting the task
Yn (in CPU cycles/bit) and edge CPU utilization (in CPU
cycles/bit), respectively, the total ofﬂoading time is speciﬁed
as

n , X e

T of f load
n

=

n

DnX enc
f l
n

+

Dn
Rn

+

DnX e
n
f e
n

,

(2)

where f e
n is deﬁned as the computational resource (in CPU
cycles/second) allocated by the MEC server to accomplish
the task Yn, which should not exceed the available edge
computational budget f e. Also, Rn is the data transmission
rate of the MD n (in bit/second).

Moreover, the energy consumption for the ofﬂoading is
mainly characterized by the encryption energy and transmis-
sion energy [23]. Then, we deﬁne Eenc
as battery consumption
when encrypting the task Yn at the MD n which is measured
by mobile measurement tools. Moreover, according to [22],
the transmission energy is computed by

n

Etrans
n

= pn

Dn
Rn

,

(3)

where pn is the transmission power of the MD n. Hence, the
total ofﬂoading energy is speciﬁed by

Eof f load

n

= Eenc

n + Etrans

n

.

(4)

The ofﬂoading process also incurs a memory usage cost for
encryption, deﬁned as M of f load
, which can be also obtained
through mobile measurement tools [23]. Accordingly, the total
ofﬂoading time, energy consumption and memory usage can
be expressed respectively as

n

Tn = (1 − xn)T local
En = (1 − xn)Elocal
Mn = (1 − xn)M local

+ xnT of f load
n
n
n + xnEof f load
n
+ xnM of f load
n

n

,

,

(5)

(6)

(7)

.

3) Ofﬂoading Problem Formulation: Based on above for-
mulations, we derive the optimization problem to jointly
optimize time latency, energy consumption and memory usage
under system constraints as follows

(P 1) : min

x

subject to

N
(cid:88)

(αtTn + αeEn + αmMn)

n

n=1
(C1) : xn ∈ {0, 1}, ∀n ∈ N ,
(C2) : Tn ≤ T max
, n ∈ N ,
(C3) : Rn ≥ Rmin
(C4) : Mn ≤ M max
, n ∈ N ,
(C5) : 0 < pn ≤ Pn, n ∈ N ,
n ≤ f e, n ∈ N .
(C6) : 0 < f e

, n ∈ N ,

n

n

(8)

where x = [x1, x2, ..., xN ] is the ofﬂoading decision vector
of all MDs n ∈ N , and αt, αe, αm are the weights of time,
energy and memory cost, respectively. In the problem (P1), the
constraint (C1) implies that each task can be either executed
locally or ofﬂoaded to the MEC server. Further, the total task
execution time should not exceed a maximum latency value

Fig. 2: The data ofﬂoading scheme.

mobile performance measurement tools. Therefore, a task pro-
ﬁle of a MD n can be formulated as a tuple [Yn, En, Tn, Mn]
which is then stored in a database of the MD n for supporting
the ofﬂoading decision process. Details of the modelling of
each component in the task proﬁle will be presented in the
following section.

- Decision maker: This module receives task proﬁle infor-
mation collected by the proﬁle module to make ofﬂoading
decisions. Similar to [23], we employ an integer linear pro-
gramming model to develop a decision making algorithm on
MDs. By using proﬁle information, the algorithm analyses and
makes decisions whether the data task should be ofﬂoaded to
the MEC server or not. The main objective is to determine an
optimal computation decision for each task to minimize the
ofﬂoading cost of energy consumption, execution latency and
memory usage.

B. Ofﬂoading Formulation

In the literature, the existing schemes [7], [12]–[14] lack
a joint consideration of important QoS metrics in health data
ofﬂoading, including processing time, energy consumption and
memory usage. Moreover, data privacy issues in the ofﬂoading
have not been solved [6]. Motivated by the limitations of
current schemes, we here formulate the health data ofﬂoading
problem by taking these factors into account. Two computation
modes are considered, namely local execution and ofﬂoading.

1) Local Execution: When a MD decides to execute the
task Yn locally (xn = 0), it uses its resource to process
healthcare data. We denote X l
n, f l
n as mobile CPU utilization
for task n (in CPU/bit) and mobile computational capacity (in
CPU/sec), respectively. Then, the local execution time can be
calculated as

T local
n

=

DnX l
n
f l
n

.

(1)

We also deﬁne Elocal

and M local
as battery consumption (in
n
Mah) and memory usage (in MByte), which can be measured
by mobile measurement tools [23].

n

2) Ofﬂoading to the MEC Server:

In the case of task
ofﬂoading (xn = 1), the data task needs to be encrypted
for privacy before transmitting to the MEC server. Here we
employ an Advanced Encryption Standard (AES) encryption
function installed in each MD to encrypt healthcare data due
to its less energy consumption and low latency [24]. Thus,
the time required to accomplish a task in the ofﬂoading mode

Decision makerWireless channelEdge serverOffloadLocal executionMobile DeviceTask profile Health data tasks𝑥𝑛𝐷𝑛 𝐷𝑛  1−𝑥𝑛 𝐷𝑛 ACCEPTED AT IEEE INTERNET OF THINGS JOURNAL

6

n

n

n

n = Dn/T max

(C2). The constraint (C3) is added to guarantee the reliability
of the task ofﬂoading at a MD n, where Rmin
is the minimum
transmission rate and speciﬁed by Rmin
. This
condition ensures that the transmission time of MD n during
the ofﬂoading process is not too long, and thus the computation
of the data task can be completed before the deadline T max
.
(C4) deﬁnes that the memory used for task computation must
not exceed the available mobile memory. (C5) shows the trans-
mission power constraint of each MD, and the constraint (C6)
shows that the MEC server must allocate a positive computing
resource to each MD under an available computation budget
f e. In this paper, we employed a particle swarm optimization
(PSO) [25] model written in java to build the above ofﬂoading
optimization algorithm in Android phones. The PSO algorithm
has proven its superior advantages over its counterparts like
genetic algorithm in terms of extremely low computational
cost and simple implementation on Android devices for mobile
ofﬂoading applications like healthcare [26].

C. Health Data Storage

The raw health data associated with the analysed results
from the data ofﬂoading scheme are stored in the IPFS system
running on top of the MEC network. We here analyze a
representative hospital HPm where there is an MEC server m
along with its network of MDs n (n ∈ N ) and patients P IDj
(j ∈ J ). The data storage process is implemented through
four steps.

1) The raw health data of the patient P IDj collected
from the MD n is ofﬂoaded to the MEC sever m for
computation. For simplicity, here we assume that each
patient j has a health data record. Then, the MEC server
aggregates the raw data and the analysed result and adds
them into a data record identiﬁed by the patient ID j as

Cj = (rawdata||analyzedResult).

(9)

2) Instead of storing the data and analysed results in the

MEC server’s hard drive, we encrypt these data as

C enc

j ← Enc(Cj, P KMm),

(10)

where P KMm is the private key of the MEC m (its
creation will be explained in the following section). Then
we put this data to the IPFS storage node located on top
of the MEC server for data security.

3) Uploading the data to the IPFS storage would automati-
cally return a cryptographic hash of its content by using
a hash function HIP F S:

hj = HIP F S(C enc

j

, timestamp).

(11)

Here, we keep the hash value in the smart contract on
the MEC server for fast data look-up, instead of relying
on the classic DHT.

4) The storage of a data record in the IPFS node at
the MEC server m is synchronized with other IPFS
nodes at other hospitals via the P2P network for
global data sharing. The MEC server m also adds

(hj, P IDj, P KMm, timestamp) as a transaction includ-
ing the EHRs’ hash hj and broadcasts it to the global
blockchain network:

M ECm → ∗ : (hj, P IDj, P KMm, timestamp). (12)

The other MEC servers will receive the transaction and
extract the ofﬂoading information hj, P IDj that is then
stored on the database of the ACSC contract. The details
of contract design will be presented in the following
section.

V. HEALTH DATA SHARING

The health data records stored in the IPFS from the data
ofﬂoading scheme are then used in the data sharing scheme in
federated hospitals. To provide authentication for data sharing,
a smart contract-based access control solution is adopted at
the network edge without requiring any central authority like
previous works [8], [15]. This not only reduces authentication
latency but also increases the reliability of data sharing.
Moreover, the integration of smart contract into IPFS enables
the replica of hash value of data records across the edge
network which helps accelerate the data retrieval rate while the
data traceability is achieved. In the following, we explain our
proposed data sharing scheme as shown in Fig. 1, including
two key parts: user authentication and data retrieval.

A. User Authentication with MEC and Smart Contract

The user authentication process consists of three phases:
initialization phase, user registration phase, and data retrieval
phase, which are explained as follows.

1)

Initialization Phase: Each hospital is initilized by its
MEC server. In this phase, a key is set up by the MEC server
for data sharing establishment. Also, the MEC server m in
each hospital sets up the private key and the public key.

2) Registration Phase: This phase is invoked whenever a
HU wants to register to the MEC server for the ﬁrst time. To
do so, the user joins the local blockchain network and follows
the steps as below.

• Each HU u submits a transaction Tregu to the MEC server

m as Tregu for registration:

Tregu = (P KUu||IDu||timestamp).

(13)

• The MEC server m decodes the Tregu to obtain the user’s
public key as P KUu ← Tregu .getSenderP ublicKey().
• Then, the MEC server decodes the transaction to get
the user ID. First, it decodes the transaction Tregu , then
ﬁnally obtain the user ID as an unique address ADDu:

deTu ← abiDecoder.decodeM ethod(Tregu),

(14)

ADDu ← web3.eth.getData(deTu([IDu])).

(15)

• The MEC server checks user information and stores
{P KUu, ADDu} as the user identiﬁcation information
in the contract database.

ACCEPTED AT IEEE INTERNET OF THINGS JOURNAL

7

• The MEC server then calculates the hash value of the

• In the case of successful request validation, the MEC

register transaction Tregu as:

server m will calculate the signature of Tdecu as

HHU u ← Hash(Tregu , SKMm),
which is then published to the local hospital blockchain
network for tracing. The MEC server m also broadcasts
its public key P KMm to the user that is necessary for
the future user data access.

(16)

3) User Authentication Phase: It is supposed that a HU
u wants to access the patient’s EHRs stored on the MEC
network for their medical tasks. To obtain the EHRs of the
target patient, the HU u needs to know his patient identity
P IDj so that the MEC server can locate the address of this
patient in the hospital network during EHRs sharing. The data
retrival process is presented by the following key steps.

• A HU u prepares a data retrieval request Trequ involved
a target patient ID P IDj and the address of patient’s
hospital HPw (w ∈ M). Thus, the target patient address
on the hospital network can be expressed as Paddr =<
P IDj, HPw >, i.e., the 5th patient in the 3th hospital.
Then, the request Trequ can be speciﬁed by

Trequ ← (P KUu||IDu||Paddr||timestamp),

(17)

where each compoment in Trequ is formatted with an
index in the array index = [1 − 4], i.e., the index of
P KUu is 1. This format is necessary for transaction
decoding later.

• To ensure privacy, the user request should be encrypted
with the MEC m’s public key P KMm (obtained from
the registratrion phase) as Tencu ← Enc(Trequ, P KMm)
and submits it to the MEC m.

• At the edge side, the MEC server m decrypts the user
request Tenpu as Tdecu ← Dec(Trequ , SKMm). To
provide security for the EHRs sharing, user authentication
is highly essential. To do so, the MEC server extracts the
user’s public key from the request as

P ubu ← Tdecu .getSenderP ublicKey().

(18)

It also decodes the transaction Tdecu to obtain the request
information ReqInfu:

deTdecu ← abiDecoder.decodeM ethod(Tdecu ),

(19)

ReqInfu ← web3.eth.getData(deTdecu [DataIndex]),
(20)

and then obtains the user identity Idenu as

Idenu = ReqInfu(Index[indexIden]).

(21)

• The MEC server will check and authenticate the received
user identiﬁcation information < P ubu, Idenu >, and
then put them into user mapping as

U M APP Ku = M ap < P ubu => P KUu >,

U M APIDu = M ap < Idenu => IDu >,

(22)

(23)

by using the smart contract (see in Algorithm 1). If both
U M APP Ku → true and U M APIDu → true, the user
request is validated successfully, otherwise a penalty is
issued for access prevention.

Sigu ← Hash(Tdecu , SKMm),

(24)

Finally, the MEC server will issue a certiﬁcate Certu as

Certu = {Sigu, P KUu, IDu, timestamp},

(25)

which is then sent to the HU u via the local blockchain
for successful authentication proof.

B. Health Data Retrieval with MEC and Blockchain

After successful authentication, the MEC server m will
locate the requested EHRs based on the patient information
< P IDj, HPw >← ReqInfu(Index[indexP IDu]) that is
deﬁned in the authentication phase. In fact, the patient and
the user may be located in the same hospital or in different
hospitals. For example, a patient may only stay at a hospital
for his treatment, but in some cases (e.g., seeking treatment for
a new disease), he wants to visit a different doctor in another
hospital. Motivated by this realistic scenario, here we consider
two cases: (1) The patient and the user are in the same hospital
and (2) The patient and the user are in different hospitals.

Case 1: The patient and the user are in the same
hospital: In this case, the MEC server ﬁnds that the HU
and the patient are in the same hospital by checking HPw
information. It is supposed that the HU u communicates with
the MEC server m to request the data record of the patient
P IDj in the same hospital, then the data retrieval process is
implemented by the following steps:

• The MEC server m ﬁrst veriﬁes the request information
P IDj by refering to the ACSC contract
to perform
mapping between the patient record stored in the contract
P IDsc

j and information in the request P IDreq
j => P IDreq

U M APP IDj = M ap < P IDsc

j > .

(26)

:

j

the request

information is

If U M APP IDj → true,
veriﬁed for ready data retrieval.
the

on

extract

patient

received

• Based

sends a request

information,
the
the hash value hj
ACSC contract will
represents the patient j’s health record. Then,
that
the contract
to the IPFS storage
for data retrieval using the hash by a command:
C enc
i.e.,: ipfs get /ipfs/
j
Qmd84db7be0690ebb015f1cD9d9491cE18076c.
• Since the data stored on the IPFS was encrypted in the
storage process (see in Section IV-C), we need to decrypt
to obtain the real data as

= GETIP F S(hj),

Cj ← Dec(C enc

j

, SKMm).

(27)

The MEC m then returns the data Cj via a secure channel
to the requestor.

• Finally,

the MEC server m adds a conjunction of
(P KUu, hj, P KMm, timestamp) as a transaction and
broadcasts it to the global blockchain network:

M ECm → ∗ : (P KUu, hj, P KMm, timestamp).

(28)

ACCEPTED AT IEEE INTERNET OF THINGS JOURNAL

8

Fig. 3: The proposed health data sharing procedure with MEC and IPFS.

Case 2: The patient and the user are in different
hospitals: In this case, the MEC server will seek the address
of the patient in the MEC network. Due to all patient addresses
(P IDj, HPw) are stored on the ACSC contract replicated
across the global hospital network, an MEC server at a
hospital can know exactly where the requested patient data is
currently located. Hence, an MEC server only needs to send
the data request to the destination MEC server (using HPw
information) that contains the requested data for data retrieval,
without broadcasting the request to all MEC servers. This
strategy not only saves data lookup time but also saves network
bandwidth and potentially reduces the trafﬁc congestion on the
global blockchain network. The data retrieval process in this
case is summarized as the following steps:

• The MEC server m ﬁrst also veriﬁes the request infor-
mation P IDj from the user P KUu by refering to the
ACSC contract, and then performs mapping to verify
that the patient information P IDj is correct. Then, it
also identiﬁes which MEC server is currently storing the
requested data by checking HPw information. Here, we
assume that an MEC server M ECy, (y#m, y ∈ M) is
holding the requested data.

• After identifying the destination MEC server y, the MEC
server m will send a transaction for data retrieval request:

M ECm → M ECy : (P IDj, P KUu, P KMm, time).
(29)
• Based on the patient information P IDj, the ACSC con-
tract in the MEC y obtains the hash value hj. Next, the
contract sends a request to the IPFS node in the MEC
y by a command: C enc
j = GETIP F S(hj), which is then
decrypted to obtain the real data:

Cj ← Dec(C enc

j

, SKMy).

(30)

• The MEC server y then transmits the collected data Cj to
the MEC server m so that the server m returns it to the
requestor. Finally, the MEC server y adds a conjunction
of (P KUu, hj, P KMy, timestamp) as a transaction and
broadcasts it to the global blockchain network:

M ECy → ∗ : (P KUu, hj, P KMy, timestamp).

(31)

Finally, all MEC servers update the user access events and
acheive a synchronization over the data sharing across the
hospital network.

The data retrieval process for two cases are shown in Fig. 3,
and the data sharing is summarized in Algorithm 1. Here,
lines (5-8) present the pre-processing steps when a HU u
submits a request to the MEC server. Then, the MEC server
will authenticate the request using the ACSC, by verifying the
identiﬁcation information (P KUu, IDu) (lines 9-18). For the
request authenticated by the contract, the MEC server speciﬁes
whether the patient and the user are in the same hospital or in
the different hospitals. The MEC server will refer to the IPFS
storage for data retrieval based on patient information P IDj
before returning to the HU u (in lines 19-38).

VI. EXPERIMENTAL RESULTS AND EVALUATIONS

In this section, we present experiments and perform imple-

mentation evaluations in details.

A. Experiment Settings

We implemented a testbed to evaluate the proposed BEdge-
Health architecture. We employed three computers (Microsoft
Windows 10 64-bit, Intel core i7 at 3.4 GHz, 8GB of RAM)
to work as MEC servers where each MEC server represents
a hospital. Each server will connect with a network of MDs
via a Cisco access point. Here we used Sony Android mobile
phones as MDs for data ofﬂoading and data sharing tasks
with Qualcomm Snapdragon 845 processor, 2GB memory,
and a battery capacity of 2870mAh. In our study, healthcare
data and programming code are necessary. For a speciﬁc case
study, we used Biokin sensors [10] developed by our lab as
IoMT devices to collect simultaneously human motion data
(including acceleration and gyroscope time-series data) with
the size from 100 KB to 5 MB. This data is stored in separate
ﬁles to be executed by an analysis program integrated in both
Android phones and the MEC server. By using a programmed
data analysis algorithm, we can estimate the movement dis-
order of a patient to serve doctors during clinical decisions
[10]. The experiment parameters are set up as follows: task
CPU workload X l
n = [0.8 − 1.5] Gcyles, maximum latency

Healthcare UserMEC 1Hospital 1IPFSSend a request Look up on the contractDecrypt dataReturn the requested dataMEC 2Hospital 2IPFSMEC 3Hospital 3IPFSHealthcare UserMEC 1Hospital 1IPFSSend a request Look up on the contractRead and decrypt the data on IPFSSend a request Send a request Return dataReturn dataSynchronizeSynchronizea) Case 1: The patient and the user are in the same hospital.b) Case 2: The patient and the user are in the different hospitals.Read health data on IPFS Return dataRead and decrypt the data on IPFSACCEPTED AT IEEE INTERNET OF THINGS JOURNAL

9

Algorithm 1 Health data sharing with MEC and blockchain
1: Input: P IDj , HPw, P KUu, IDu, Trequ
2: Output: Authu, Cj
3: Initialization: (by the user HU u)
4: Encrypt the request: Tencu and submits it to the MEC m
5: Pre-processing the request (by MEC)
6: The MEC m decrypts
Dec(Trequ , SKMm)

request Tenpu as Tdecu ←

7: Obtain the user’s public key: P ubu ← Tdecu .getSenderP ublicKey()

the user

8: Decode Tdecu and get the user identity Idenu
9: Authentication (by the ACSC contract)
10: if msg.sender == M ECm then
11:
12:
13:
14:

P Kcheck = policy[EHRresource][action].P KUu
Idencheck = policy[EHRresource][action].IDu
if P KcheckIdencheck → true then

Authu ← AccessResult(msg.sender, Accepted, true, time)
Accept the user request

15:
16:

else

Authu ← AccessResult(msg.sender, Denied, f alse, time)
Refuse the user request

w then

end if

if HPw == HP sc

17:
18: end if
19: while Authu → true do
20:
21:
22:
23:
24:
25:
26:
27:

(Case 1: The patient and the user are in the same hospital)
if P IDsc

j == P IDj then
Get the data on IPFS: Cenc
j = GETIP F S (hj )
Decrypt to obtain the real data Cj ← Dec(Cenc
j

, SKMm)

end if
The MEC m returns the data Cj to the HUu
The MEC m adds a transaction to the global blockchain network:
M ECm → ∗ : (P KUu, hj , P KMm, timestamp)

else if HPw! = HP sc

w then

(Case 2: The patient and the user are in different hospitals)
if P IDsc

j == P IDj then

Communicate with the MEC y: M ECm → M ECy
(P IDj , P KUu, P KMm, timestamp)
Get the data on IPFS: Cenc
j = GETIP F S (hj )
Decrypt to obtain the real data Cj ← Dec(Cenc
j

, SKMy)

end if
The MEC y returns data Cj to the MEC m and then the HU u
The MEC y adds a transaction to the global blockchain network:
M ECy → ∗ : (P KUu, hj , P KMy, timestamp)

:

28:
29:
30:
31:

32:
33:
34:
35:
36:

end if
37:
38: end while

n

threshold T max
= 10 second, device computing capability
f l
n = 1 GHz, edge computing capability f e = 5 GHz. The
maximum transmission power Pn of MDs is set to 20 mW,
and the minimum transmission rate requirement Rmin
n = 0.5
Mbps. For mobile performance evaluations, we employed a
Firebase Performance Monitoring1 service to measure process-
ing time, battery consumption, and memory usage. The mobile
application for the ofﬂoading optimization was implemented
using Android studio 3.5.

For blockchain deployment, two Hyperledger Fabric plat-
forms version 1.3 were used to build the global blockchain on
the MEC system and the local blockchain on the MEC-device
system. The PBFT consensus was implemented by MEC
servers, while devices only joined the blockchain network
for data request. We followed the instructions in the ofﬁcial
Hyperledger Fabric tutorial to install required ﬁles and docker
images [27]. The smart contract was implemented in docker
to serve user authentication and data retrieval [28]. We also
installed the JavaScript version of the IPFS platform in the

1https://ﬁrebase.google.com/docs/perf-mon

MEC system [29]. Each of three MEC servers holds an IPFS
node which is embedded with the Fabric blockchain to perform
data storage and data sharing. To highlight the merits of the
proposed BEdgeHealth architecture, we compare our scheme
with the related works using different performance metrics
which are presented as follows.

B. Evaluation of Data Ofﬂoading Performance

We compare our edge ofﬂoading scheme with two baselines:
local execution [10] (only executing data on devices) and
cloud computation [23] (ofﬂoading to the cloud server) to
prove the advantages of our scheme. A set of health data ﬁles
with different sizes (200 KB-1000 KB) collected from sensors
is used in our evaluations. We implement each test with 10
times to obtain average values, and evaluate the ofﬂoading
performance of these schemes on processing time, energy
consumption, and memory usage. We present two settings with
different weight values to evaluate the tradeoff among these
three performance metrics, as shown in Fig. 4 and Fig. 5.

Fig. 4 shows the ofﬂoading performances with αe =
1/3, αt = 1/3, αm = 1/3. For the processing time, it consists
of execution time in the local case, and encryption time,
ofﬂoading time and remote execution time in the edge and
cloud ofﬂoading cases. From Fig. 4(a), we can see that our
edge ofﬂoading scheme consumes less energy when processing
the health data tasks. As an example, ofﬂoading a 200 KB ﬁle
consumes in the edge scheme less 11% energy than that in
the case of local computation and less 5% energy than that
in the cloud scheme. Specially, the energy usage of the edge
scheme becomes more efﬁcient when the data size increases.
For instance, the edge ofﬂoading scheme can save 21.3%
energy when executing a 1000 KB ﬁle, compared to the local
scheme.

Fig. 4(b) indicates the average processing time of three
schemes, with a signiﬁcant performance improvement in the
proposed edge scheme. For example, executing a 200KB ﬁle
by the edge scheme only consumes 1.1 sec, whereas it requires
about 1.3 sec and 1.5 sec in the cloud and local schemes,
respectively. This leads to a 10-18% time saving of data
execution by using our edge scheme. Further, the proposed
edge scheme saves up to 31% and 15% time when computing
a 1000 KB ﬁle, compared to the local and cloud schemes,
respectively. We also found with the selected human motion
dataset, although data encryption is integrated in ofﬂoading,
the edge-cloud ofﬂoading schemes still achieves better ofﬂoad-
ing performances than the local scheme, showing the efﬁciency
of the proposed encryption technique.

Moreover,

illustrated in
the memory performance is
Fig. 4(c). The edge and cloud schemes have the same memory
usage due to using the same encryption function for the
ofﬂoading. However, these schemes achieve greater memory
performances, with 5% and 9% memory savings compared
to the local scheme when executing a 200 KB and 1000 KB
ﬁle, respectively. Note that the above implementation results
were obtained from the proposed ofﬂoading application with
human motion data and current hardware settings of devices
and MEC servers. Different mobile applications with other

ACCEPTED AT IEEE INTERNET OF THINGS JOURNAL

10

)
h
a
M

(

n
o
i
t
p
m
u
s
n
o
c

y
r
e
t
t
a
B

)
h
a
M

(

n
o
i
t
p
m
u
s
n
o
c

y
r
e
t
t
a
B

10

8

6

4

2

0

10

8

6

4

2

0

Local execution [10]
The cloud scheme [23]
The proposed edge scheme

Local execution [10]
The cloud scheme [23]
The proposed edge scheme

Local execution [10]
The cloud scheme [23]
The proposed edge scheme

)
c
e
s
(

e
m

i
t

g
n
i
s
s
e
c
o
r
P

5

4

3

2

1

0

)

B
M

(

e
g
a
s
u

y
r
o
m
e
M

120

100

80

60

40

20

0

Local execution [10]
The cloud scheme [23]
The proposed edge scheme

t
s
o
c

g
n
i
d
a
o
ﬂ
f
o

l
a
t
o
T

60

40

20

0

200

400

600
Size of healthcare data ﬁle (KB)

800

1000

200

400

600
Size of healthcare data ﬁle (KB)

800

1000

200

400

600
Size of healthcare data ﬁle (KB)

800

1000

200

400

600
Size of healthcare data ﬁle (KB)

800

(a) Battery consumption.

(b) Processing time.

(c) Memory usage.

(d) Total ofﬂoading cost.

Fig. 4: Comparison results for health data ofﬂoading with αe = 1/3, αt = 1/3, αm = 1/3.

Local execution [10]
The cloud scheme [23]
The proposed edge scheme

Local execution [10]
The cloud scheme [23]
The proposed edge scheme

Local execution [10]
The cloud scheme [23]
The proposed edge scheme

)
c
e
s
(

e
m

i
t

g
n
i
s
s
e
c
o
r
P

10

8

6

4

2

0

)

B
M

(

e
g
a
s
u

y
r
o
m
e
M

200

150

100

50

0

t
s
o
c

g
n
i
d
a
o
ﬂ
f
o

l
a
t
o
T

60

40

20

0

Local execution [10]
The cloud scheme [23]
The proposed edge scheme

200

400

600
Size of healthcare data ﬁle (KB)

800

1000

200

400

600
Size of healthcare data ﬁle (KB)

800

1000

200

400

600
Size of healthcare data ﬁle (KB)

800

1000

200

400

600
Size of healthcare data ﬁle (KB)

800

1000

1000

(a) Battery consumption.

(b) Processing time.

(c) Memory usage.

(d) Total ofﬂoading cost.

Fig. 5: Comparison results for health data ofﬂoading with αe = 2/3, αt = 1/6, αm = 1/6.

health data types such as videos and different hardware settings
can achieve different ofﬂoading performances. However, in
general, the proposed edge ofﬂoading scheme yields the best
performances with reduced time latency, energy consumption,
and better memory savings among three schemes for any task
size. As a result, our edge scheme shows an signiﬁcant im-
provement in the ofﬂoading performance with lower ofﬂoading
cost, compared to the cloud scheme and the local scheme, as
indicated in Fig. 4(d).

Next, we investigate the ofﬂoading performances of three
schemes with αe = 2/3, αt = 1/6, αm = 1/6, as illustrated
in Fig. 5. Based on the objective function in the optimization
problem (P1), a larger αe value will give more penalty on
the energy consumption. Particularly, the performance gap
between the edge scheme and other schemes in this setting
is larger than that in the previous setting in Fig. 4 due to
the increased latency and memory cost and reduced energy
consumption. Moreover, our scheme achieves the best perfor-
mance with lowest ofﬂoading cost among three schemes. For
instance, when the task size is 1000 KB, the ofﬂoading cost
of our edge scheme is 29.5, compared to 34.2 in the cloud
scheme and 38.3 in the local scheme. The experimental results
from two tradeoff settings in Fig. 4 and Fig. 5 demonstrate the
advantage of our proposed edge scheme over the baselines,
showing its efﬁciency in health ofﬂoading applications.

TABLE I: Authentication cost test.

Authentication functions
Hash function
Request encryption
Transaction decoding
Request decryption
User veriﬁcation
PBFT consensus commitment

Computation Cost
5.6 ms
12.3 ms
3.2 ms
4.1 ms
22.5 ms
30 ms

Centralized authentication scheme [11]
Our scheme with decentralized authentication

1,000

800

600

400

200

)
s

m

(

e
m

i
t

n
o
i
t
a
c
i
t
n
e
h
t
u
A

2

4

6

8

10

12

The number of healthcare users

Fig. 6: Authentication latency with different numbers of
healthcare users.

C. Evaluation of Data Sharing Performance

For data sharing, we investigated the authentication cost,
latency, request acceptance probability, and

data retrieval
blockchain performance.

1) Authentication Cost: We calculate the computation cost
for the authentication process. Here, a user leverages his

smartphone to submit a request with 160 bit to its MEC server
for data retrieval in the blockchain network. The MEC server
performs some functions such as encryption, decryption, trans-
action decoding for user veriﬁcation. As shown in Table I,
the computation costs are small, and the latency of PBFT
consensus is acceptable and thus suitable for time-sensitive

ACCEPTED AT IEEE INTERNET OF THINGS JOURNAL

11

)
s
(

y
c
n
e
t
a
l

l
a
v
e
i
r
t
e
r

a
t
a
D

8

6

4

2

Centralized MEC-based sharing without IPFS [17]
MEC-based sharing with classic IPFS [18]
Our scheme with decentralized IPFS and contract

Cloud-based scheme [8]
Distributed MEC with a central authority [7]
Our scheme with cooperative distributed MEC

)
s
(

y
c
n
e
t
a
l

l
a
v
e
i
r
t
e
r

a
t
a
D

10

8

6

4

2

2

4

6

8

10

12

2

4

6

8

10

12

The number of data requests

The number of data requests

(a) Data retrieval latency under blockchain designs.

(b) Data retrieval latency under network designs.

Fig. 7: Data retrieval rate under different numbers of data requests.

healthcare applications.

Besides, we also compare the authentication latency of
our proposed scheme with a centralized scheme [11] with
the different number of healthcare users. In the proposed
scheme, we organize the access authentication at the network
edge where each MEC server authenticates its users by the
distributed smart contract. Meanwhile, the scheme [11] relies
on a central authority to implement its user authentication.
As shown in Fig. 6, our scheme exhibits a lower latency
compared to the baseline [11]. This is because that the use
of decentralized smart contract enables fast authentication at
the network edge without passing a remote authority, which
thus reduces communication overhead in the authentication
process.

2) Data Retrieval Latency: We investigated the data re-
trieval latency of our proposed model from blockchain design
and network design perspectives as shown in Fig. 7. We used
smartphones to send data requests continuously to the MEC
servers to record the results. In terms of blockchain design,
we use two existing works for comparison. The ﬁrst one
is a centralized edge-based health sharing scheme without
IPFS [17] which used a centralized MEC server to serve a
large hospital network and health data was stored in a classic
database. The second one is an edge blockchain health sharing
scheme with classic IPFS [18] that integrated blockchain and
edge computing without IPFS design improvement.

From Fig. 7(a), we can see that when the number of requests
the baseline [17] has the highest data retrieval
increases,
latency due to the queuing latency in the centralized MEC
server. The baseline [18] used a classic IPFS storage with
a global DHT look-up solution that results in unnecessary
communication overhead. By contrast, our scheme provides
a fully decentralized solution with distributed MEC and smart
contracts, which allows to implement request veriﬁcation and
data look-up at the network edge without using the global
DHT. As a result, our scheme can achieve a minimal data
retrieval latency.

Next, we evaluated the data retrieval latency from a network
design perspective as shown in Fig. 7(b). We leveraged a
cloud-based scheme [8] and a distributed MEC with a central
authority [7] as the baselines for comparison. For cloud com-
puting implementation, we employed Amazon cloud services
to communicate with smartphones [10]. The results in Fig. 7(b)
clearly show a signiﬁcant improvement in our decentralized
scheme with a much lower retrieval latency. This is because
our scheme combines MEC, distributed smart contracts, and
decentralized IPFS for fast data retrieval, without passing any
external authority during the data sharing. Meanwhile, the
work in [8] relies on a remote cloud model which remains
high latency due to excessive communication overhead. Also,
the work in [7] used a central authority for request veriﬁcation
that consumes a certain overhead for communication between
the MEC servers and the authority in the request veriﬁcation.
The above experiment results demonstrate a lower retrieval
latency cost of our approach in comparison with the existing
works.

3) Request Acceptance Probability: We added a time
threshold δu in the request
transaction Trequ to set up a
new transaction involving the latency condition: Trequ ←
(P KUu||IDu||Paddr||δu||timestamp). This threshold repre-
sents the maximum latency that a request needs to be re-
sponded by returning the data to the requestor before the
δu deadline (successful request); otherwise,
is
regarded as a failed one. Here we introduce an acceptance
probability function which is deﬁned as the number of suc-
cessful requests per the total requests. As shown in Fig. 8,
the request acceptance probability of our scheme is higher
than that of the other baselines [17] and [7]. Although the
probability reduces when the number of requests increases due
to the longer queue time, our decentralized scheme still yields
the best performance. This can be explained by the signiﬁcant
processing time saving achieved in our scheme thanks to an
optimized edge computing and decentralized smart contract
design.

the request

ACCEPTED AT IEEE INTERNET OF THINGS JOURNAL

12

)

%

(

y
t
i
l
i
b
a
b
o
r
p

e
c
n
a
t
p
e
c
c
a

l
u
f
s
s
e
c
c
u
S

90

80

70

Centralized edge-based health sharing [17]
Distributed MEC with centralized authority [7]
Our scheme with decentralized authority

2

4

6

8

10

12

The number of data requests

Fig. 8: Request acceptance probability under different numbers
of data requests.

2,000

1,500

1,000

500

)
s

m

(

y
c
n
e
t
a
l

n
o
i
t
c
a
s
n
a
r
T

0

1

Ethereum blockchain [18]
Our Hyperledger blockchain

20

40
The number of transactions

60

80

Fig. 9: Comparison on transaction latency of Hyperledger and
Ethereum blockchains.

4) Blockchain Performance: Next, we evaluate the perfor-
mance of our permissioned Hyperledger Fabric blockchain
and compare it with the popular permissionless Ethereum
blockchain used in [18]. We run the ACSC contract on three
computers and use smartphones to send transaction contin-
uously to the computers to measure the average transaction
latency in the local blockchain. As indicated in Fig. 9, our pro-
posed Hyperledger Fabric blockchain exhibits a much lower
transaction latency, compared to the Ethereum blockchain un-
der the varying number of transactions. This experiment result
shows the suitability of using Hyperledger Fabric blockchain
for time-sensitive healthcare applications like our scenario.

VII. SECURITY ANALYSIS AND DISCUSSIONS

A. Security Analysis

In this sub-section, we present the attack model and then
analyze theoretically some key security features acheived by
our blockchain design.

1) Attack Model: We consider two types of attacks: internal

attack and external attack.

- Internal attack: According to our design description in
the previous sections, the MEC servers and healthcare users
in this paper are considered semi-trusted in the data sharing,
while the MDs are regarded as fully trusted entities in the
the
private ofﬂoading. Under the semi-trusted assumption,
MEC servers would be honest but curious about the health
data and thus can infer some sensitive information from
transactions on the blockchain.

- External attack: During data ofﬂoading and sharing,
external attackers can gain access to obtain health information.
For example, an adversary can attack the MEC server to
obtain patient information ofﬂoaded from MDs. Also, the data
sharing may be vulnerable due to the data threats on the
communication between the MEC server and healthcare users.
Next, we present the main security properties of our pro-
posed BEdgeHealth scheme, and explain how these properties
make our scheme resilient to security threats.

2) Security Analysis: Our scheme is able to provide four
important security features, including data privacy, authentica-
tion, traceability, and conﬁdentiality.

2.1) Data privacy: Our scheme can preserve data privacy in
both data ofﬂoading and data sharing schemes. In data ofﬂoad-
ing, the health data is actually encrypted by an AES encryption
function in MDs when performing the ofﬂoading. Moreover,
the health data ofﬂoaded from MDs is encrypted by using the
j ← Enc(Cj, P KMm)(cid:1).
private key of the MEC server (cid:0)C enc
An external adversary may not decrypt the data due to the
lack of MEC server’s private key. Thus,
the health data
privacy is preserved. In the data sharing, the data request
is also encrypted (cid:0)Tencu ← Enc(Trequ , P KMm)(cid:1) so that
private user information is protected against threats. Moreover,
the data transactions stored in the blockchain cannot changed
or modiﬁed by using immutable ledgers. Unlike recent works
[9], [10], [15] with a centralized IPFS on a third-party cloud
which may remain data leakage, our architecture provides
strong data control in the MEC network under the management
of blockchain without a third party. This would eliminate
single-point failures and avoid illegal data usage for better
data privacy control.

2.2) Authentication: In our BEdgeHealth scheme, the data
sharing is authenticated in a decentralized manner with the
help of the distributed ACSC contract. In our design, the
smart contract works independently with the MEC server
which means the authentication policies cannot be controlled
by the misbehaving MEC server but managed by the global
blockchain network. Any contract updates are reﬂected on
the blockchain network and monitored by all MEC servers.
This would avoid the risks of contract modiﬁcations caused by
internal attacks and hence ensure reliable contract operations.
In the data sharing, the data retrieval is executed only if the
user information P KUu, IDu is authenticated by the contract.
that our
BEdgeHealth framework is running on a blockchain network
where any data access events and user behaviours are traced by
all entities that cannot achieved in the existing works [7], [8],
[11]. A user request to our BEdgeHealth system is registered

2.3) Traceability: This is ensured by the fact

ACCEPTED AT IEEE INTERNET OF THINGS JOURNAL

13

by an MEC server and broadcast to all other entities in both
global blockchain and local blockchains. As a result, all MEC
servers and users have acknowledged a data access event
when it occurs. Furthermore, one can easily trace the origin
where data is modiﬁed or updated through transaction logs.
Moreover, we store health data on IPFS associated with smart
contracts, instead of in the MEC server’s hard drive to achieve
traceability over data usage. To be clear, the raw data is stored
in the IPFS while the hash value of data is kept in the smart
contract. Hence, any modiﬁcation or change behaviours on a
data record will lead to a change in its hash value, and thus
the smart contract can detect for prevention. Moreover, since
all activities at an MEC server are recorded and synchronized
on the global blockchain, other MEC servers can also trace
them in a transparent manner.

2.4) Conﬁdentiality: In BEdgeHealth,

the conﬁdentiality
of health communications is guaranteed by exploiting the
standard cryptographic primitives. We employ key-based en-
cryption solutions coupled with digital signatures for our
ofﬂoading and sharing schemes. An external attack cannot
gain access to the health communication due to the lack of
private keys of entities (i.e., MEC servers or health users).
Even if an external adversary tries to modify or change the
communication protocol, the message digest on blockchain
would detect such malicious actions. In fact, to modify the
metadata on blockchain, an attack needs an extensive com-
putation capability to gain the power control from all MEC
servers, which may be nearly impossible to achieve in practice
[2]. Hence, the user conﬁdentiality can be preserved.

Based on the above implementation results and discussions,
we summarize the key features of our proposed BEdgeHealth
architecture and compare with the related works in Table II.
The comparison results demonstrate the advantages of our
scheme over the conventional schemes, showing the usability
of our BEdgeHealth architecture in practical e-health applica-
tions.

B. Discussions

In this article, we present a decentralized BEdgeHealth
architecture in hospital networks with a data sharing scheme
and a data ofﬂoading scheme, and their performances are
also veriﬁed via real-world experiments. By using MEC, our
scheme is able to provide efﬁcient health data ofﬂoading
services at the network edge, proximity to MDs and IoMT
networks, for user QoE improvement. Moreover, the health
data can be stored and shared over the distributed hospital
networks using blockchain without the need of central author-
ity. We incorporate smart contracts with IPFS for enabling
reliable access authentication and fast data retrieval in order to
facilitate the data exchange among healthcare users. However,
the integration of smart contracts in IPFS possibly intro-
duces new challenges, including security vulnerabilities which
can include timestamp dependence, mishandled exceptions,
reentrancy attacks on smart contracts [30], [31], and fake
authorization caused by misbehaving MEC servers. These
security issues may result in privacy leakage or system logic
modiﬁcations in the data storage process on IPFS; and thus

TABLE II: Comparison of security features between our proposed scheme and the
existing works.

Features

Decentralization
Data privacy
Decentralized
storage
Authentication
Traceability
Conﬁdentiality
Ofﬂoading and
sharing services

[7]

(cid:88)

(cid:88)

(cid:88)

[8]
(cid:88)
(cid:88)

(cid:88)

(cid:88)

[11]
(cid:88)
(cid:88)

(cid:88)

(cid:88)

Schemes
[17]
(cid:88)
(cid:88)

(cid:88)
(cid:88)
(cid:88)

[18]
(cid:88)
(cid:88)
(cid:88)

(cid:88)
(cid:88)

Our scheme
(cid:88)
(cid:88)
(cid:88)

(cid:88)
(cid:88)
(cid:88)
(cid:88)

more research efforts should be made for the full realization of
smart contract-based IPFS in health data sharing applications.
For example, developing an incentive mechanism may be
very useful to solve fake authentication issues [32]. More
speciﬁcally, an incentive scheme can be designed and deployed
across the MEC network, aiming to incentivize the MEC
server with efﬁcient authentication and punish the MEC server
with misbehaving authentication. In this way, we can mitigate
the possibility of fake authentication among MEC servers.

At present, the health data ofﬂoading scheme in our BEdge-
Health architecture has been launched commercially at Royal
Victorian Eye and Ear Hospital, Melbourne city, Australia
for supporting the clinical assessments of cerebellar disease
[33]. This project aims to use Biokin sensors [10] associated
with a Biokin mobile app to collect real-world health data
from patients diagnosed with cerebellar disease and then
ofﬂoad to the MEC server for medical analysis. Besides, our
health data sharing with blockchain has been implemented in
the testbed environment at Networked Sensing and Control
(NSC) lab, Deakin University on the Hyperledger blockchain
platform. We set up MEC servers located in different hospi-
tals in Melbourne city and connect with an MEC server at
our university, aiming to implement a health sharing among
doctors working in cerebellar disease. The implementation
results achieved in this work demonstrate the practicality and
feasibility of our proposed BEdgeHealth model in real-world
health applications.

VIII. CONCLUSIONS AND FUTURE WORK

This paper has proposed a new decentralized health architec-
ture, called BEdgeHealth that employs MEC and blockchain
for health data ofﬂoading and sharing in distributed hospital
networks. We have ﬁrst proposed a privacy-aware data ofﬂoad-
ing scheme where MDs can ofﬂoad IoMT health data to the
nearby MEC server under system constraints. Then, a new data
sharing scheme is introduced by using blockchain and smart
contracts to enable secure data exchange among healthcare
users in different hospitals. To realize access management, we
have developed an ACSC contract that enables decentralized
user authentication at
the network edge without requiring
central authority, which would ensure authentication reliability
and reduce network latency. We have implemented various
real-world experiments to verify the effectiveness of the pro-
posed BEdgeHealth architecture. The implementation results
have demonstrated the signiﬁcant advantages of the proposed
ofﬂoading scheme over the other baseline methods in terms of
reduced time latency, energy consumption, and better memory

ACCEPTED AT IEEE INTERNET OF THINGS JOURNAL

14

[18] P. C. M. Arachchige, P. Bertok, I. Khalil, D. Liu, S. Camtepe, and
M. Atiquzzaman, “A trustworthy privacy preserving framework for
machine learning in industrial IoT systems,” IEEE Transactions on
Industrial Informatics, 2020.

[19] R. Kumar, N. Marchang, and R. Tripathi, “Distributed off-chain storage
of patient diagnostic reports in healthcare system using IPFS and
blockchain,” in 2020 International Conference on COMmunication
Systems & NETworkS (COMSNETS), 2020, pp. 1–5.

[20] S. Pongnumkul, C. Siripanpornchana, and S. Thajchayapong, “Perfor-
mance analysis of private blockchain platforms in varying workloads,”
in 26th International Conference on Computer Communication and
Networks (ICCCN), 2017, pp. 1–6.

[21] T. Banerjee, M. Enayati, J. M. Keller, M. Skubic, M. Popescu, and
M. Rantz, “Monitoring patients in hospital beds using unobtrusive
depth sensors,” in 36th Annual International Conference of the IEEE
Engineering in Medicine and Biology Society, 2014, pp. 5904–5907.

[22] D. C. Nguyen, P. N. Pathirana, M. Ding, and A. Seneviratne, “Privacy-
preserved task ofﬂoading in mobile blockchain with deep reinforcement
learning,” IEEE Transactions on Network and Service Management, pp.
1–1, 2020.

[23] I. Elgendy, W. Zhang, C. Liu, and C.-H. Hsu, “An efﬁcient and secured
framework for mobile cloud computing,” IEEE Transactions on Cloud
Computing, pp. 1–1, 2018.

[24] B. S. Kumar, V. R. Raj, and A. Nair, “Comparative study on AES and
RSA algorithm for medical images,” in 2017 International Conference
on Communication and Signal Processing (ICCSP), 2017, pp. 0501–
0504.

[25] K. Tamilarasi and A. Jawahar, “Medical data security for healthcare
applications using hybrid lightweight encryption and swarm optimization
algorithm,” Wireless Personal Communications, pp. 1–22, 2020.
[26] S. K. ElKady and H. M. Abdelsalam, “A modiﬁed particle swarm
optimization algorithm for solving capacitated maximal covering lo-
cation problem in healthcare systems,” in Applications of Intelligent
Optimization in Biology and Medicine, 2016, pp. 117–133.

[27] “Hyperledger

fabric,” Accessed Jun. 2020.

[Online]. Available:

https://www.hyperledger.org/use/fabric

[28] “Docker software,” Accessed Jun. 2020. [Online]. Available: https:

//www.docker.com/get-started

[29] “Interplanetary ﬁle system (ipfs),” Accessed Jun. 2020.

[Online].

Available: https://docs.ipfs.io/

[30] S. Rouhani and R. Deters, “Security, performance, and applications of
smart contracts: A systematic survey,” IEEE Access, vol. 7, pp. 50 759–
50 779, 2019.

[31] M. Wohrer and U. Zdun, “Smart contracts: security patterns in the
ethereum ecosystem and solidity,” in 2018 International Workshop on
Blockchain Oriented Software Engineering (IWBOSE), 2018, pp. 2–8.
[32] E. K. Wang, Z. Liang, C.-M. Chen, S. Kumari, and M. K. Khan, “PoRX:
A Reputation Incentive Scheme for Blockchain Consensus of IIoT,”
Future Generation Computer Systems, vol. 102, pp. 140–151, Jan. 2020.
[33] D. Phan, N. Nguyen, P. N. Pathirana, M. Horne, L. Power, and D. Sz-
mulewicz, “A random forest approach for quantifying gait ataxia with
truncal and peripheral measurements using multiple wearable sensors,”
IEEE Sensors Journal, vol. 20, no. 2, pp. 723–734, 2019.

usage. Moreover, the data sharing scheme can achieve fast data
retrieval with improved blockchain performance, compared to
the existing works. The evaluations also prove the high system
security of our design, showing the feasibility of the proposed
model for healthcare applications.

Future work is in progress to extend our blockchain-MEC
model to many other healthcare systems, including speech and
video data management and secure real-time health monitoring
systems.

REFERENCES

[1] D. C. Nguyen, P. N. Pathirana, M. Ding, and A. Seneviratne,
“Blockchain and edge computing for decentralized EMRs sharing in
federated healthcare,” in 2020 IEEE Global Communications Conference
(GLOBECOM), 2020.

[2] M. A. Rahman, M. S. Hossain, G. Loukas, E. Hassanain, S. S. Rahman,
M. F. Alhamid, and M. Guizani, “Blockchain-based mobile edge com-
puting framework for secure therapy applications,” IEEE Access, vol. 6,
pp. 72 469–72 478, 2018.

[3] P. Verma and S. K. Sood, “Fog assisted-IoT enabled patient health
monitoring in smart homes,” IEEE Internet of Things Journal, vol. 5,
no. 3, pp. 1789–1796, 2018.

[4] T. McGhin, K.-K. R. Choo, C. Z. Liu, and D. He, “Blockchain in
healthcare applications: Research challenges and opportunities,” Journal
of Network and Computer Applications, 2019.

[5] A. Yazdinejad, G. Srivastava, R. M. Parizi, A. Dehghantanha, K.-
K. R. Choo, and M. Aledhari, “Decentralized authentication of dis-
tributed patients in hospital networks using blockchain,” IEEE Journal
of Biomedical and Health Informatics, 2020.

[6] M. Asif-Ur-Rahman, F. Afsana, M. Mahmud, M. S. Kaiser, M. R.
Ahmed, O. Kaiwartya, and A. James-Taylor, “Toward a heterogeneous
mist, fog, and cloud-based framework for the internet of healthcare
things,” IEEE Internet of Things Journal, vol. 6, no. 3, pp. 4049–4062,
2018.

[7] R. Saha, G. Kumar, M. K. Rai, R. Thomas, and S.-J. Lim, “Privacy
ensured e-healthcare for fog-enhanced IoT based applications,” IEEE
Access, vol. 7, pp. 44 536–44 543, 2019.

[8] J. Liu, X. Li, L. Ye, H. Zhang, X. Du, and M. Guizani, “BPDS: A
blockchain based privacy-preserving data sharing for electronic medical
records,” in 2018 IEEE Global Communications Conference (GLOBE-
COM), 2018, pp. 1–6.

[9] S. Wang, Y. Zhang, and Y. Zhang, “A blockchain-based framework for
data sharing with ﬁne-grained access control in decentralized storage
systems,” IEEE Access, vol. 6, pp. 38 437–38 450, 2018.

[10] D. C. Nguyen, P. N. Pathirana, M. Ding, and A. Seneviratne,
“Blockchain for secure EHRs sharing of mobile cloud based e-health
systems,” IEEE Access, vol. 7, pp. 66 792–66 806, 2019.

[11] S. Jiang, H. Wu, and L. Wang, “Patients-controlled secure and privacy-
preserving EHRs sharing scheme based on consortium blockchain,” in
2019 IEEE Global Communications Conference (GLOBECOM), 2019,
pp. 1–6.

[12] R. M. Abdelmoneem, A. Benslimane, E. Shaaban, S. Abdelhamid,
and S. Ghoneim, “A cloud-fog based architecture for IoT applications
dedicated to healthcare,” in IEEE International Conference on Commu-
nications (ICC), 2019, pp. 1–6.

[13] D. Giri, M. S. Obaidat, and T. Maitra, “Sechealth: An efﬁcient fog
based sender initiated secure data transmission of healthcare sensors for
e-medical system,” in IEEE Global Communications Conference, 2017,
pp. 1–6.

[14] M. Min, X. Wan, L. Xiao, Y. Chen, M. Xia, D. Wu, and H. Dai,
“Learning-based privacy-aware ofﬂoading for healthcare IoT with energy
harvesting,” IEEE Internet of Things Journal, vol. 6, no. 3, pp. 4307–
4316, 2018.

[15] H. Guo, W. Li, M. Nejad, and C.-C. Shen, “Access control for electronic
health records with hybrid blockchain-edge architecture,” in 2019 IEEE
International Conference on Blockchain, 2019, pp. 44–51.

[16] H. H. Elazhary and S. F. Sabbeh, “The W5 framework for computation
ofﬂoading in the internet of things,” IEEE Access, vol. 6, pp. 23 883–
23 895, 2018.

[17] X. Li, X. Huang, C. Li, R. Yu, and L. Shu, “Edgecare: leveraging
edge computing for collaborative data management in mobile healthcare
systems,” IEEE Access, vol. 7, pp. 22 011–22 025, 2019.

