2
2
0
2

g
u
A
1
2

]
T
G
.
s
c
[

1
v
7
3
9
9
0
.
8
0
2
2
:
v
i
X
r
a

1

An Incentive-Compatible Mechanism for
Decentralized Storage Network

Iman Vakilinia, Senior Member, IEEE, Weihong Wang, and Jiajun Xin,

Abstract—The dominance of a few big companies in the storage market arising various concerns including single point of failure,
privacy violation, and oligopoly. To eliminate the dependency on such a centralized storage architecture, several Decentralized Storage
Network (DSN) schemes such as Filecoin, Sia, and Storj have been introduced. DSNs leverage blockchain technology to create a
storage platform such that the micro storage providers can also participate in the storage market. To verify the accurate data storage by
the storage providers during a storage contract, DSNs apply a Proof of Storage (PoS) scheme to continuously inspect the storage
service. However, continuous veriﬁcation of the storage provider imposes an extra cost to the network and therefore end-users.
Moreover, DSN’s PoS veriﬁcation is vulnerable to a service denying attack in which the storage provider submits valid PoS to the
network while denying the service to the client.
Considering the beneﬁts and existing challenges of DSNs, this paper introduces a novel incentive-compatible DSN scheme. In this
scheme, the PoS is conducted only if the client submits a challenge request. We model the storage service as a repeated dynamic
game and set the players’ payoffs such that the storage provider’s dominant strategy is to honestly follow the storage contract. Our
proposed mechanism leverages the smart-contract and oracle network to govern the storage agreement between the client and
storage provider efﬁciently. Furthermore, our scheme is independent of a speciﬁc blockchain platform but can be plugged into any
blockchain platform with smart-contract execution capability. As a proof of concept, we have implemented our scheme using solidity
language and chainlink oracle network. The performance analysis demonstrates the applicability of our scheme.

Index Terms—Decentralized Storage Network, Blockchain, Smart Contract, Mechanism Design

(cid:70)

1 INTRODUCTION

N OWADAYS giant companies dominate the data storage

market. The centralized architecture of such storage
providers arises a number of concerns. First, data centers
are more vulnerable to the single point of failure causing
the data breach, data outage, and facilitating censorship.
Second, such companies misuse clients’ personal data to
earn more proﬁt. Third, prices and rules are dictated by
a few big players causing oligopoly. This is due to the
lack of competitiveness and the small number of service
providers [1].

The Decentralized Storage Network (DSN) has offered
a storage platform where micro storage providers can also
participate in the storage market. DSNs leverage blockchain
technology to facilitate the management of the storage
service. Blockchain applies the distributed ledger to store
transaction histories, and the information is stored across a
network of computers instead of on a single server. Utilizing
the smart contract, various incentivization mechanisms can
be developed on top of the blockchain to automatically
moves digital assets following arbitrary pre-speciﬁed rules.
DSNs provide an algorithmic storage market to clients
and storage providers. The client can outsource the data
storage by making a payment to the network. On the other
hand, the storage providers share their storage resources
with the network in return for a premium. To satisfy data
conﬁdentiality, clients’ data is encrypted end-to-end at the

•

I.Vakilinia is with the School of Computing, University of North Florida,
Jacksonville, FL, 32224.
E-mail: i.vakilinia@unf.edu

• W.Wang and J.Xin are with The Hong Kong University of Science and

Technology.

client side and storage providers do not have access to
the decryption keys. This can offer enhanced security and
privacy by eliminating the central entity that controls the
data. Moreover, micro storage providers can rent out their
excessive storage resources, improve the network through-
put and reduce the maintenance cost of data centers. As
a result, the storage service can be delivered cheaper with
more players and options.

One of the main challenges in the decentralized storage
network is to verify the correct storage of data by the storage
provider. To this end, a DSN platform should be equipped
with a Proof of Storage (PoS) scheme to monitor the honest
behavior of the storage provider for storing the outsourced
data intact [2]. Currently, DSNs perform PoS periodically
during the storage contract to ensure the accurate storage of
the data by the storage provider [3], [4], [5]. However, such
a continuous veriﬁcation is costly and it is vulnerable to a
malicious storage provider that submits PoS to the DSNs
nodes while refusing service to the client.

To improve the DSN’s performance and protect the client
from service denying attack, in this paper, we present and
analyze a novel decentralized storage scheme in which it is
not required to verify the storage service constantly but only
once challenged. To this end, we design a new Incentive-
Compatible mechanism such that players achieve their best
outcomes by choosing their actions truthfully. More specif-
ically, we design a repeated dynamic game such that the
storage provider’s strategy for honestly sharing the stored
data is the only subgame-perfect equilibrium. We utilize the
smart contract and oracle network to enforce the rules of our
proposed storage game. Eliminating the continuous storage
veriﬁcation signiﬁcantly improves the performance of the

 
 
 
 
 
 
DSN. On the other hand, our incentive design supports
clients from the service denying attack as we explain further
in next sections.

Our proposed scheme has the following beneﬁts com-

pared with the existing DSNs:

• Current DSNs require continuous proof from the
storage provider to ensure that the data is stored ac-
curately. This process is costly and causes a waste of
energy. However, in our scheme, the storage provider
does not need to continuously prove the correct stor-
age but only when the client challenges the storage
provider.

• Current DSNs require adding third-party services
or a new blockchain platform to intervene in the
examination of honest behavior of client and storage
providers. However, our proposed mechanism does
not require a new service but it is pluggable on any
blockchain with smart-contract execution capability
(e.g., Ethereum).

• The proof of storage in the current DSNs requires
storage providers to proof the storage to the DSNs’
network nodes. This can cause a service denying
attack such that a dishonest storage provider only
provides proof to the network nodes while rejecting
service to the client. This threat is not credible in our
scheme as we discuss later on.

• Current DSNs are unable to manage the number of
data requests from clients. As a result, a dynamic
pricing model such as pay-as-you-go cannot be im-
plemented. We discuss how our proposed model can
manage the number of requests to support diverse
storage services based on the volume of retrieval
requests.

To achieve these goals, ﬁrst we model a storage contract
as a repeated dynamic game. Then, we set the players’
payoffs such that the dominant strategy of the storage
provider is to provide the storage service honestly. Finally,
we implement our proposed scheme using a smart-contract
and oracle network. To the best of our knowledge, this work
is the ﬁrst to investigate an incentive-compatible challenge-
based decentralized storage mechanism utilizing the smart-
contract and oracle network.

The rest of the paper is organized as follows. The next
section reviews major works in the ﬁeld of the decentralized
storage network. In section 3, we overview the decentralized
storage network’s components. Details of our proposed
mechanisms are described in section 4. The experiment re-
sults have been discussed in section 5. Finally, we conclude
our paper in Section 6.

2 RELATED WORK
2.1 Decentralized Storage Network

Filecoin [3], sia [4], storj [5], and swarm [6] are the most well-
known platforms utilizing the blockchain technology to
implement the DSN. Such platforms leverage the blockchain
asset management capabilities to enforce incentive models
for clients and storage providers.

Filecoin [3] runs on a blockchain with a native protocol
token (also called “Filecoin”) which miners earn by provid-
ing storage to clients. Clients spend Filecoin hiring miners

2

to store or distribute data. Filecoin miners compete to mine
blocks with sizable rewards, but Filecoin mining power is
proportional to active storage, which directly provides a
useful service to clients. To earn Filecoin, storage providers
must prove they are storing the data properly. The Filecoin
network veriﬁes that data is stored securely through cryp-
tographic proofs. Storage providers submit their storage
proofs in new blocks to the network and validate new
blocks sent from the network. Filecoin applies the Proof-
of-Spacetime, where a veriﬁer can check if a prover is
storing the outsourced data for a range of time. Filecoin
works as an incentive layer on top of the Interplanetary File
System (IPFS). IPFS [7] is a p2p storage network. Content
is accessible through peers located anywhere in the world.
These nodes relay information, store it, or do both. IPFS uses
content addressing rather than location based addressing to
ﬁnd data. A content identiﬁer, or CID, is a label used to point
to material in IPFS. It doesn’t indicate where the content is
stored, but it forms a kind of address based on the content
itself.

Storj [5] is another well-known DSN. Stoj utilizes a
service called satellite to manage the decentralized stor-
age system. Satellites are responsible for verifying storage,
data repair service, receiving and distributing payments,
managing storage nodes, account management and autho-
rization system, and storing storage metadata. Storj ex-
tends the probabilistic nature of common per-ﬁle proofs-
of-retrievability to range across all possible ﬁles stored by
a speciﬁc node. Figueiredo et al. [1] have investigated the
security of the Storj network and explored a DoS vulnera-
bility within Storj’s dev./test environment which was exper-
imentally evaluated to be highly feasible. The attack results
in the inability of developers to access their test data and
storage providers missing out on their payments. However,
the authors pointed out that Storj’s production system is not
vulnerable to such an attack as long as multiple satellites
running on load-balanced clusters of servers.

Sia [4] is also a famous DSN. Sia runs its own blockchain.
Sia’s blockchain stores the ﬁle contract. This contract in-
cludes the terms of the storage agreement such as pricing
and uptime commitment. Sia divides ﬁles into 30 segments
and uploads each segment in different nodes. This distri-
bution assures that no one host represents a single point of
failure and reinforces overall network uptime and redun-
dancy.

Swarm [6] is a distributed storage platform and content
distribution service. The primary objective of Swarm is to
provide a decentralized and redundant store of Ethereum’s
public record, in particular, to store and distribute decen-
tralized applications’ code and data as well as blockchain
data. From an economic point of view, it allows participants
to efﬁciently pool their storage and bandwidth resources in
order to provide these services to all participants. The goal
is a peer-to-peer serverless hosting, storage, and serving
solution that is DDoS-resistant, has zero downtime, is fault-
tolerant and censorship-resistant as well as self-sustaining
due to a built-in incentive system.

2.2 Proof of Storage

One of the main challenges for having a robust DSN is
to audit that the storage provider is honestly storing data

intact. To this end, a Proof of Storage (PoS) scheme is used.
A similar notion of PoS is Proof of Data Possession (PDP).
If the storage provider fails to provide the proof, then it will
be penalized by the DSN.

PoS schemes have been studied widely in the literature
for centralized setting [8], [9], [10], [11]. However, such
schemes are not necessarily applicable in the DSNs as in the
decentralized setting the veriﬁcation must be cheap, and the
proof and public parameters must be succinct.

Filecoin has introduced a new proof scheme, called Proof
of Spacetime (PoSt), where a veriﬁer can check if a prover
has indeed stored the outsourced data they committed to
over space (i.e., storage) and over a period of time. In
PoSt, the prover generates sequential PoS and recursively
composes the executions to generate a short proof. Filecoin’s
PoSt applies zk-SNARKs [12] to generate succinct proofs
which are short and easy to verify [3].

Storj [5] introduces the satellite component as a third
party to audit the storage service. However, using such a
third party service weakens the decentralized architecture.
Moreover, storj utilizes the reputation based system for
storage providers based on the history of their service.

Sia [4] uses a Merkle tree based auditing scheme such
that the host is required to demonstrate the possession of a
random segment. A storage provider must present a certain
number of proofs to the network within the time frames
speciﬁed in the ﬁle contract to get fully paid.

Recently, several research studies have investigated new
methods to improve the proof of storage for DSNs [2], [13],
[14]. Du et al. [14] have proposed a new framework for
auditing the data in the DSNs using pairing based cryp-
tography and zero-knowledge proof. Yu et al. [15] have de-
signed a data-time sampling strategy that randomly checks
the integrity of multiple ﬁles at each time slot with high
checking probability. Furthermore, this research proposes a
fair sampling strategy by designing an arbitration algorithm
with a veriﬁable random function.

Besides, Vector Commitments (VCs) can also serve as
a PoS solution. VCs can commit to a list of values to a
digest, and later provide succinct proof to prove one value
is the committed value in some speciﬁc location. However,
vector commitment has different limitations. RSA based
VCs require a trusted setup for the hidden order group [13],
[16], [17], [18]. A class group [19] can be used to generate
the hidden order group instead of the trusted setup, but
it is still not practical due to calculation overheads. Bilinear
groups based VCs [16], [20], [21], [22] require at least a linear
number of public parameters as common reference strings
which limits its adoption in decentralized settings. Lattice
based VCs [23] have the pros of post-quantum security,
simple setup, and cons of larger communication as well as
computation overhead due to the lattice itself.

A relative notion is Proof of Retrievability (PoR) [24],
[25], [26], [27], [28], [29], [30], [31]. PoR guarantees that only
if a server stores entire ﬁles without loss, it can provide a
valid proof. While in PoS, the server can still provide a valid
PoS proof with some part of the ﬁle lost with non-negligible
probability. However, the stronger guarantees come with a
price. Most PoR schemes require heavy cryptography tools,
assumptions, or large overhead.

3

2.3 Motivation

Inspired by the previous schemes, in this paper we present
a novel game-theoretic challenge-based storage contract
mechanism for DSNs. To this end, our proposed mechanism
allows the client to submit a challenge request indicating
that the storage provider has not shared the outsourced
data. Once the challenge request is received, smart-contract
and oracle network conduct the storage veriﬁcation. In con-
trast with previous works, our scheme is designed such that
it does not require a continuous veriﬁcation of storage but
it only executes once the client submits a challenge request.
The mechanism is designed such that the dominant strategy
for the storage provider is to honestly store and share data
with the client. On the other hand, the client’s dominant
strategy is to not submit a challenge request if the storage
service has been delivered accurately. Moreover, our scheme
prevents the dishonest storage provider to deliver PoS to the
DSN while refusing the storage service to the client. This
design signiﬁcantly decreases veriﬁcation overhead costs in
the current DSNs. We leverage the oracle network to alle-
viate the DSN’s execution cost. Furthermore, our proposed
scheme is independent of an underlying blockchain layer
and can be executed on top of every generic blockchain with
smart-contract execution capabilities such as Ethereum and
Bitcoin. Our scheme leverages the Merkle tree for the PoS as
we describe in section 4.

3 OVERVIEW
In this section, we review the system architecture of the
storage service in a decentralized storage network utilizing
blockchain technology.

A DSN provides a platform for a storage provider to
offer the storage service to clients. A client aims to purchase
the storage service to store and access her data for a spec-
iﬁed time period. On the other hand, a storage provider
aims to sell his storage service to host the client’s data in
return for a premium. In a nutshell, a DSN is equipped with
two main components of payment settlement and storage
veriﬁcation. In the payment settlement module, the DSN
charges the client for the storage service and makes the
payment to the storage provider. Moreover, in case the stor-
age provider fails to provide the committed storage service,
the DSN penalizes the storage provider and compensates
the client accordingly. In the veriﬁcation module, the DSN
veriﬁes that the storage provider is delivering the storage
service accurately. To this end, the storage provider should
submit proof of storage to the DSN, and DSN veriﬁes the
correctness of such proofs.

Once the client and the storage provider agree on a stor-
age service, they enroll in a storage contract. This contract
conveys the storage Service Level Agreement (SLA) which
speciﬁes the storage service including the duration of the
contract, premium, quality of service, and compensation
rates.

DSNs leverage public blockchain technology to enforce
storage contracts. Blockchain technology has offered an
agreeable platform for parties to make payments with-
out a single trusted third party. Blockchains are managed
ledger.
by a peer-to-peer network to manage a digital
Recorded data on a public blockchain is publicly accessible

and tamper-resistant. A smart contract is a code in the
blockchain that automatically enforces a contract between
two parties without any help from a single third party.
Therefore, there is no need for an intermediary between
contracting entities to enforce the contract. Accordingly, in a
blockchain enabled DSN scheme, there is not a single party
controlling any storage contract.

In a DSN storage service, the client may encrypt her
data before submitting it to the storage provider to protect
the conﬁdentiality of her data. Moreover, DSNs can provide
redundancy, high-availability, and fail-over by storing the
data in multiple nodes in the network.

Note that the details of storage techniques that the stor-
age provider is using to store the client’s data are out of the
scope of this paper. In other words, we assume the storage
provider manages his storage resources including redun-
dancy, server location, backup services, network bandwidth,
etc to maximize his payoff following the SLA.

3.1 Design Goal

The primary goal of DSN’s mechanism design is to ensure
that the storage provider stores the client’s data and returns
it upon the client’s request following the SLA. The storage
service should be examined, and the client should be com-
pensated in case of a storage failure. The client should pay
the storage provider if the storage service has been deliv-
ered ﬂawlessly. We aim to improve the current methods of
PoS in DSNs by eliminating the requirement of continuous
veriﬁcation of the data storage on the storage provider.
The mechanism should be incentive-compatible such that
the players can earn their best outcome by choosing their
actions truthfully.

Moreover, we consider the following side features in our

design goal:

• Blockchain platform independent. Current DSN
systems work on their own customized blockchain
platforms. This causes an extra overhead cost for
the DSN. We aim to propose a compatible stor-
age scheme that is pluggable to available generic
blockchain platforms with smart-contract execution
compatibility (e.g., Ethereum).

• Prevent service denying attack. Currently available
DSNs are vulnerable to a service denying attack such
that a dishonest storage provider denies providing
the expected service to the client while successfully
submitting PoS to the DSN network. In this case, the
storage provider receives the service fee while the
client has not received the expected service. We aim
to protect the DSN network from such a fraudulent
storage provider.

• On-chain efﬁciency. On-chain storage and compu-
tation are costly. Therefore, the proposed scheme
should minimize the on-chain storage and compu-
tation without compromising security expectations.
• Counting requests. Many storage services expect
to count the number of requests from the client to
dynamically calculate the cost of service. So far, the
available DSNs do not provide storage services based
on the number of requests. We will discuss how our
proposed mechanism can accomplish this task.

4

4 AN INCENTIVE-COMPATIBLE MECHANISM FOR
THE STORAGE CONTRACT
In this section, we discuss our proposed mechanism for an
incentive-compatible decentralized storage system based on
smart-contract. First, we model and analyze the storage con-
tract as a repeated dynamic game, and then we discuss the
design of the storage contract utilizing the smart-contract
and oracle network.

4.1 Storage Contract As a Repeated Dynamic Game

The mechanism design objective is to place a set of rules for
the storage service to meet the requirements. A mechanism
can be speciﬁed by a game g : M → X where M is the
set of possible input messages and X is the set of possible
outputs of the mechanism. In the storage system model,
players are the storage provider and the client. A rational
player chooses his strategy to increase his/her utility. We
assume players are rational self-interested such that they
aim to maximize their proﬁt.

In the design of a decentralized storage network, the

following questions need to be answered:

• How the mechanism can verify the
provider’s honest behavior of sharing data?

storage

• What is the payment channel for the service?
• How the mechanism can charge the client for the

service?

• How the mechanism can penalize the storage
provider for loss of data or low quality service?

A naive model is to have a Trusted Third Party (TTP)
mediate between the client and storage provider. In this
case, the client requests data from TTP, and TTP receives
data from the storage provider. TTP can check the integrity
of data by storing the hash of data and verifying it whenever
receiving data from the storage provider, and then forward
it to the client. Upon successful execution of the service,
TTP charges the client and pays the storage provider. On the
other hand, if the storage provider fails to provide data back
to the client, TTP charges the storage provider and pays the
client for the data loss or low quality service according to the
contract. Although this model ensures the storage service
expectations, it is inefﬁcient, expensive, and not scalable
due to the requirement of having a TTP as a middleman
for every request and response. On the other hand, ﬁnding
such a TTP is impractical, and such a design resembles a
centralized architecture where the TTP acts as a central party
and can be potentially bribed.

To solve this problem, DSNs rely on a blockchain plat-
form to act as a TTP to remove a single central entity to
manage the system. On the other hand, DSNs minimize
TTP intervention in the data recovery process such that
the client retrieves data from the storage provider directly.
However, the DSN continuously veriﬁes the proof of storage
from the storage provider to ensure the storage provider is
storing the data truthfully. DSNs utilize blockchain asset
management features to deliver the fees among players.
Although this method notably improves the naive solution
mentioned above, there are two main issues that remain:

•

First, the continuous veriﬁcation of storage is costly
for the network.

•

Second, a dishonest storage provider can successfully
submit the proof of storage to the DSNs while refus-
ing the service to the client.

To solve these issues, in our model the DSN does not
continuously verify the storage service but whenever the
client submits a challenge request. In our model, the client
directly requests data from the storage provider, and the
storage provider sends back data directly to the client. How-
ever, as a dishonest storage provider might refuse to provide
data back or send back incorrect data, the mechanism is
equipped with a challenging option. In this case, the client
can send a challenge request to the TTP, and TTP veriﬁes
the data that the storage provider returns back. Therefore,
in our mechanism, the interaction between the client and
the storage provider can be modeled as a repeated dynamic
game. Once the storage contract starts, in the ﬁrst stage of
the game, the storage provider can choose between Sharing
data or Not Sharing data strategies. Here, sharing means that
the storage provider honestly follows the storage contract
and shares the client’s data upon the client’s data request.
On the other hand, not sharing, indicates that the storage
provider refuses the service to return data upon the client’s
request.

Afterward, the client can choose Challenging or Not Chal-
lenging the storage provider. Challenging means that the
client submits a challenge request to the DSN indicating that
the storage provider has not shared data. Not challenging
indicates that the client does not submit a challenge request.
Upon receiving the challenge request, DSN performs the
storage veriﬁcation.

Once the storage provider is challenged, then his strat-
egy set is to Proof of storage or Not Proof of storage. Proof
means that the storage provider submits the proof of storage
to the DSN. Not Proof means that the storage provider
does not submit the proof of storage or fails to submit the
accurate proof of storage to the DSN. This repeated dynamic
game is depicted in Fig 1.

The goal of our mechanism design is to ensure that the
subgame-perfect-equilibrium of this dynamic game is {Share,
No Challenge}. In other words, we aim to design a mech-
anism in which storing and sharing data is the storage
provider’s dominant strategy, and the client’s dominant
strategy is to not submit a challenge request. To achieve this
goal, ﬁrst, we investigate the players’ payoffs in the leaf
nodes, and then we set payoffs such that the Sharing and
No Challenge strategies are the dominant strategies for the
storage provider and the client, respectively.

5

Fig. 1: Dynamic Game of the storage contract

chooses Proof, then it should provide proof of storage, oth-
erwise, if the storage provider fails to proof, then the storage
provider will be penalized according to the contract.

We assume the data has a value for the client. In other
words, the client receives compensation in return for the
data loss caused by the storage provider. Note that, failure
of proof is the worst outcome for the storage provider as
the storage provider will be penalized the compensation
amount, and we have:

Si∈{1,3,4,6} >> Sj∈{2,5}

(1)

Following the backward induction, the storage provider
would choose proof action unless he lost data or cannot
provide the service. This is because the cost of No Proof is
the cost of compensation for the client, and we have:

S1 >> S2

, S6 >> S5

(2)

As the mechanism’s goal is to ensure that the storage
provider chooses the Sharing strategy, the cost of Proof
should be higher than the cost of Sharing. Therefore, we
have:

S3 >> S1

, S4 >> S6

(3)

On the other hand, as the mechanism’s goal is to en-
sure that the client chooses No challenge when the storage
provider honestly shared data, then we should have the
following:

C3 > C1

(4)

To this end, the mechanism makes the Challenging re-

As can be seen in Fig 1, there are six possible outcomes

quest costly for the client. Let X represent this cost.

for our storage contract game.

At the ﬁrst stage of the game, the storage provider’s
action set is {Share, No Share}. The goal of our mechanism
is to ensure that the Sharing action is the best strategy for
the storage provider. However, Sharing is costly because
of the cost of storage, data retrieval, backup, and network
bandwidth required for successful sharing.

In the second stage, the client action set is {Challenge,
No Challenge}. By choosing the Challenge strategy, the client
claims that the storage provider has not shared data. If the
client chooses to challenge, then the storage provider has
two options as {Proof, Not Proof }. If the storage provider

On the other side, as we want the storage provider
chooses Sharing, the client should choose Challenge when the
data has not been shared by the storage provider. To achieve
this goal, the mechanism should motivate the client for
choosing the challenge once the data has not been shared.
However, the challenge is costly as we discussed earlier. To
cover the cost of the challenge, our mechanism is designed
such that the Proof strategy enforces a copy of data to be
sent out to the client to improve the payoff of the challenge
strategy in case of not sharing. On the other hand, once
the data has not been shared, there is a possibility that the
storage provider cannot provide the storage service (e.g.,

Storage ProviderNot ShareShareChallengeNo ChallengeClient(S4, C4)ProofStorage Provider No Proof(S5, C5)(S6, C6)No ChallengeChallenge(S3, C3)ProofClientNo Proof(S2, C2)(S1, C1)Storage Providerdue to the data loss). Let P represent the probability that
the storage provider cannot present the storage service. Let
V represent the value of accessing data for the client. Then,
the client’s expected utility for choosing the challenge can
be modeled as:

Cc = P.(C5) + (1 − P).(V) − X

(5)

Note that here C4 < 0 as the client has not received
the service. On the other hand the mechanism sets Cc > 0,
therefore we have Cc > C4. Using the backward induction,
it can be seen that the subgame-perfect-equilibrium of this
game is {Share, No Challenge} strategy proﬁle.
Example

In this section, we provide an example to clarify the
proposed mechanism. For simplicity, we consider the utility
of players as a number without the declaration of a speciﬁc
currency.

Consider that the compensation cost is indicated as
“1, 000” in the storage contract. In other words, if the storage
provider is unable to retrieve the client’s data, then the
storage provider should pay the client “1, 000”. Let the cost
of losing data for the client be “500”, and the client’s beneﬁt
of reading data is “5”. The cost of requesting the challenge is
“1”, and the cost of proof of storage for the storage provider
is “3”. Finally, let the beneﬁt of not sharing data with the
client is “2”, and the beneﬁt of sharing data be “1” for
the storage provider (note that this is the payoff that the
storage provider earns by charging the client for providing
the correct storage service). Therefore, the dynamic game
tree of this game can be depicted as Fig 2.

Fig. 2: Dynamic Game of the example storage contract

Using the backward induction, it can be seen that the
{Share, No Challenge} is the subgame nash equilibrium of
the game.

4.2 Scheme details

Identifying the storage contract requirements and the play-
ers’ payoffs, now we discuss the design architecture to
satisfy the design goal.

We utilize the smart-contract to act as a TTP to manage
the agreement between the client and the storage provider.
Smart-contract is powered by blockchain technology. The
blockchain is managed by a peer-to-peer network to manage
a digital ledger. A smart-contract is a code in the blockchain
that automatically enforces a contract between two parties

6

without any help from a third party. Therefore, there is no
need for an intermediary between contracting entities to
enforce the contract. A public blockchain network capable
of executing the smart-contract is used as a platform for
developing the DSN.

In our proposed model, ﬁrst the client and storage
provider reach a storage agreement. The agreement includes
the following information: Length of contract, Merkle root
of data, premium, delivery time, and compensation. For
example, a storage provider makes an agreement with a
client to store her 1 TB data for the length of 1 year for the
premium of $20, if the storage provider fails to return data,
then the storage provider will be penalized by $40, and the
time window for delivering data after client’s request is 20
minutes.

This agreement will be speciﬁed in the smart-contract
and deployed on the blockchain. Note that, the Merkle root
of data is stored on-chain which will be used for veriﬁcation
of data. Storing the whole data on the blockchain is too
costly, therefore Merkle-tree is used to minimize the cost
of the storage veriﬁcation process as we discuss later on.
Moreover, the smart-contract includes the client’s premium
as well as the storage provider’s collateral asset. Upon the
successful storage service, the premium will be automati-
cally transferred to the storage provider. On the other hand,
if the storage provider fails to provide the storage service,
the client will be automatically compensated through the
collateral asset of the storage provider following the contract
details.

Note that the blockchain platform is an isolated network,
and it cannot pull in or push data out to any external
system. This problem is known as the oracle problem [32],
[33]. To solve this problem, the oracle network has been
presented. Oracle network provides a trusted source for
accessing off-chain data to the blockchain. Moreover, it can
perform arbitrary programs more efﬁciently compared with
the smart-contract, due to the fact that fewer resources are
needed to execute the code. Leveraging the oracle network,
the challenge request in our scheme works as follows:

The client submits a challenge request by calling the challenge
function of the smart-contract with the speciﬁc data segment
number to be challenged. Once the challenge request has been
received by the smart-contract, the oracle network will submit a
challenge to the storage provider. Upon receiving the challenge
request from the oracle network, the storage provider should send
the challenged data along with the Merkle path to the oracle.
In the next step, the oracle network ﬁrst calculates the Merkle
root and compares it with the Merkle root in the storage contract
stored on-chain. If they match, then the oracle sends a copy of
the data to the client. Otherwise, the oracle sends a fail signal
to the smart-contract, and the smart-contract will transfer the
compensation fund from the storage provider account to the client
account following the pre-speciﬁed agreement.

The interaction between different components of our

scheme is depicted in Fig 3.

As can be seen, the data transfer is done off-chain. The
only on-chain operation is the challenge request. Note that
in this scheme, the storage provider should send the chal-
lenged data to the oracle network, and the oracle network
forwards the data back to the client. There are two main
reasons for this design.

Storage ProviderNot ShareShareChallengeNo ChallengeClient(2, -500)ProofStorage Provider No Proof(-998, 500)(-1, 4)No ChallengeChallenge(1, 5)ProofClientNo Proof(-1000, 1005)(-2, 4)Storage Provider7

•

•

•

(d, h) ← Setup(1λ, D, sz). This algorithm takes as input
the security parameter λ, outsourced data D, and segment
size sz. The algorithm outputs a digest of data d which is
used to verify the proof and the Merkle tree height h.
π ← Prove(D, c). This algorithm takes as input the data
D and the challenge number c. Here, c is the identiﬁer of
the challenged data. The algorithm outputs a proof π to
prove the storage of data segments corresponding to the
challenged node number c.
0/1 ← Verify(d, n, c, π). This algorithm takes as input
the digest d, the Merkle tree height h, the challenge
number c, and the proof π. It outputs 1 if the proof π
is a valid proof, and it outputs 0 otherwise.

Cryptographic building blocks
Cryptographic secure hash function. We use a cryptographic
secure hash function H ← Hash(x) that is a collision and
pre-image resistant.
Digital signature. We use the standard EU-CMA secure
digital signature function [34] that contains three func-
tions: 1) (pk, sk) ← KeyGen:(1λ); 2) σ ← Sign(sk, m); 3)
1/0 ← Verify(pk, m, σ).
Our construction

Our construction is based on the Merkle tree. First, the
data D is divided into a set of segments S = {s1, . . . , sm}
where each segment has the size of sz. Here, m should be
the power of 2. Segments with 0 bits are padded to meet this
requirement. The hash of each segment builds the leaves of
the Merkle tree. The parent node is the hash of its child
nodes.

The Merkle tree root is labeled with the number 0, its two
children nodes with the number 1 and 2. All the other nodes’
numbers follow the same incremental manner. Following
this numbering, the last node number is 2m − 2, and we
have h = log(m).

The Prove function outputs the sibling nodes of the chal-
lenged node’s Merkle path and the corresponding segments
needed to calculate the challenged node. the Verify function
checks if the node generated by the segments has a valid
Merkle path towards the Merkle root.

For example, assume a Merkle tree as depicted in Figure
4. Here, the challenged number is 8. The proof π includes
the raw data of segment s2 to generate leaf node 8, and the
sibling nodes of the Merkle path for node 8, which includes
node numbers 2, 4, and 7. In order to verify the proof π,
the veriﬁer ﬁrst calculates the leaf node based on the data
of segment s2 received from the prover. Then, it calculates
node 3 using nodes 7 and 8, calculates node 1 using nodes 3
and 4, and calculates node 0 using nodes 1 and 2. Finally, it
checks if the calculated root is the same as the Merkle root
stored on-chain.

Fig. 4: Merkle tree example.

Fig. 3: Interaction of different components in the proposed
challenge based DSN storage contract

•

•

First, it prevents the service denying attack which
we explained earlier. This is due to the fact that
if the storage provider refuses service to the client,
the client receives a copy of data with the challenge
request if the storage provider can pass the proof.
Therefore, the storage provider cannot deny service
to the client while prooﬁng the storage to the DSN.
Second, when the storage provider has not shared
data, the mechanism should provide incentives for
the client to submit the challenge. By forwarding
the data, we add the value to the client’s payoff
for choosing the challenge strategy to achieve our
desired subgame perfect equilibrium as we discussed
in the previous section.

Challenge Level

To improve the efﬁciency of the scheme, we consider
different levels for the challenge request. Let us motivate
this feature by an example. Assume the client outsourced
a very large dataset of 100 TB to a storage provider. If
there is no challenge level option for the system, the storage
provider should forward the whole data back to the client
upon the challenge request submitted by the client. This can
be a resource consuming task. To solve this problem, we
consider that the client and storage provider agree to split
data into a speciﬁc number of segments. In the challenging
phase, the client can submit challenges for a set of segments.
The price of challenge requests is an increasing function of
the size and number of the data segments being challenged.
For example, assume the outsourced data of size 100 TB is
divided into 100,000 segments of 1 GB size. The client can
submit challenges for any number of segments, however,
submitting a challenge for larger data is more costly for the
client to deter a malicious client to cause a denial of service
attack on the storage provider. We explain how our proof of
storage scheme can handle this feature in the next section.

4.2.1 Proof of Storage

Proof of Storage (PoS) scheme allows a veriﬁer to check if a
storage provider is storing the client’s data at the time of
the challenge. We follow the deﬁnitions from [9] with minor
modiﬁcations.

Deﬁnition 1. Given security parameter λ, the PoS scheme is
a tuple of three probabilistic polynomial-time (PPT) algorithms
(Setup, Prove, Verify):

Blockchain NetworkOracle NetworkStorage ProviderClientSmart ContractOff-Chain Data TransferOff-Chain VerificationChallengeThe process of storing the Merkle root of data on-
chain is as follows. First, the client and storage provider
generate their public/private key pairs. Let (pkc, skc) and
(pksp, sksp) to denote their public/private key pairs respec-
tively. Client runs Setup, signs the Merkle root and Merkle
Tree height, and passes (d, h, Sign(skc, d||h)) to the storage
provider. The storage provider runs Setup separately, and
if it gets the same result, he then signs (d, h), and sends
(d, h, Sign(skc, d||h), Sign(sksp, d||h)) to the smart-contract.
The smart-contract veriﬁes signatures and stores d on-chain
for future proof of storage veriﬁcation.
Discussion

Based on our deﬁnition of PoS, several different tentative
solutions can be applied. Various cryptographic accumula-
tors [18], [35] and vector commitments [13], [16], [17], [18]
are valid solutions. However, we choose the Merkel tree to
construct the PoS based on mainly two reasons.

Firstly, in the decentralized settings, we desire no trusted
setup and less public parameters which limits the use of
RSA and bilinear pairing based solutions.

Secondly, the cost of the proof and veriﬁcation has been
considered in the incentive layer. The major concern of our
scheme is the digest size because the digest needs to be
stored on-chain. On this point, the Merkle tree is a good
solution as we only need to store the Merkle root on-chain
which is a hash value.

4.2.2 Counting the number of requests

The number of requests for retrieving data during the stor-
age contract is an important factor in pricing the storage
service. This is due to the fact that the number of retrieval
requests directly impacts the storage provider’s workload.
For example, consider that a client demands a service with
a maximum of 5 retrieval times in a year. On the other
hand, another client demands 1000 retrieval times in a year.
Therefore, the storage service should be able to dynamically
charge clients based on the number of reading requests.
Currently, DSNs do not support the number of requests in
the storage service.

A naive approach is to apply request counting. In this
case, the client ﬁrst signs a request for data and sends it
to the storage provider. The storage provider then veri-
ﬁes the signature and sends the data back to the client.
However, as a malicious storage provider might refuse to
send data, the client should send back a signed acknowl-
edgment message upon successful delivery of data. On the
other hand, a malicious client refuses to send back the
signed acknowledgment message. To solve this issue, one
simple approach is to split the data into smaller pieces and
send the next portion of data upon receiving the previous
message acknowledgment. Although such an approach is
appropriate in the network layer with TCP protocol, in
the application layer this approach is too costly as every
acknowledgment message should be signed and veriﬁed.
Moreover, there is no guarantee that the client sends the last
message acknowledgment.

To solve the naive approach, in our scheme we follow
our proposed dynamic game-theoretic approach for chal-
lenging the storage provider. In our model, the client only
sends a signed request message. The storage provider has
two options, whether send or not to send the data. Then, it

8

is the client’s choice to challenge or not challenge. Following
our dynamic game tree, the best outcome will be reached
through sharing and not challenging strategies.

For cashing out the number of requests, the storage
provider only needs to submit the last signed request mes-
sage. Note that the request message includes a counter
indicating the number of requests so far that have been
submitted by the client.

5 IMPLEMENTATION

In this section, ﬁrst, we describe the details of our imple-
mentation, and then we discuss the performance evaluation
of our proposed mechanism. We use the Solidity (version
0.8.7) programming language to implement our smart con-
tract. For the smart contract development, we use Kovan as
our Blockchain solution which is an Ethereum test network
allowing for blockchain development testing. We use Remix
IDE to develop, deploy and administer the smart contract.
In our implementation, we use Chainlink’s oracle [36] which
is currently the most popular oracle network and has the
majority share of the oracle market [37].

Considering gas fees and expensive on-chain calculation
costs, we only record the basic information and the Merkle
root value of the ﬁle on-chain. The storing of the original
outsourced data and the veriﬁcation process are done off-
chain. Thus, we need to build a connection with the off-
chain data. Every time the client makes an on-chain chal-
lenge request, the Chainlink core will route the assignment
to an external adapter which performs a request to the
API provided by the storage provider. The storage provider
computes the Merkle path of the challenging piece. The
external adapter processes the response using the Merkle
path to calculate the root value and compares it to the on-
chain stored value. Afterward, the external adapter passes
the veriﬁcation result back to the core. The core reports the
result to the CHAINLINK-SC which in turn passes the result
on-chain.

We use the EthBool core adapter provided by Chainlink
to convert data to Solidity’s format. We also set up a Chain-
link external adapter to complete custom computations.
The external adapter is written in JavaScript programming
language and runs as an HTTP Server in Node.js (version
16.13.1). We simulate the storage provider as an HTTP
server in Node.js (version 16.13.1). It provides APIs for
calculating Merkle root, accessing the original ﬁle, and gen-
erating Merkle path. We divide the ﬁle with the segment size
chosen by the client. The hash values of the slices are the leaf
nodes of the Merkle tree. Therefore, we can build the Merkle
tree and calculate the Merkle root. For demonstration, we
also developed a website that provides the clients with basic
interaction with our system. The client can upload a ﬁle for
storage to the storage provider, record the Merkle root on
the blockchain and challenge the storage provider. We use
the React library to develop the front-end application and
use Parcel as the building tool.

The implementation of our proposed scheme is accessi-
ble to the public through the following GitHub repository
link:

https://github.com/podiumdesu/ICM-DSN

9

Fig. 5: Computation cost of File reading, Merkle path generation, merkle root calculation, and Merkle path veriﬁcation for
ﬁles of 10MB, 50MB, and 100MB with varying segment size

The cost of storage contract deployment, recording a
storage task, and submitting a challenge request is de-
picted in Table 1. Note that once the storage contract is
deployed, different storage tasks can be recorded on top of
it. Moreover, to decrease the cost of on-chain deployment,
a pooling approaches can be applied [38] without affecting
the integrity of the scheme.

TABLE 1: Gas cost for the storage contract

Operation

Contract on-chain Deployment
Recording a Storage Task
Challenge Request

Gas units

2,491,606
202,001
192,101

5.1 Performance analysis

In the subsequent experiments, we have used a macOS
(version 12.0.1) laptop with an Apple M1 Pro CPU and 32
GB of memory for the performance analysis of our scheme.
We conducted our evaluation over ﬁles with various sizes of
10MB, 50MB, 100MB, 500MB, and 1GB. The computing time

is calculated with varying segment sizes for the ﬁles. We
included various settings for our evaluation. Speciﬁcally, we
look at comparisons between four dimensions of ﬁle reading
time, Merkle root calculating time, Merkle path generation
time, and Merkle path veriﬁcation time. Figures 5 demon-
strate the computation cost of ﬁle reading time, Merkle
rot calculation, Merkle path generation, and Merkle path
veriﬁcation for ﬁles with sizes of 10MB, 50MB, and 100MB.
Figures 6 demonstrates the same settings for ﬁles with sizes
of 100MB, 500MB, and 1GB.

As can be seen, with the increase in segment size, the
computation cost for ﬁle reading time, Merkle root cal-
culation, and Merkle path generation is decreasing at a
decreasing rate. Merkle path veriﬁcation is fast, and its time
is also decreasing with the increase of the segment size.

When the ﬁle sizes of the same segment size increase,
the time of ﬁle reading, Merkle root calculating and Merkle
path generation has the same growth. In contrast, the time
of Merkle path veriﬁcation time is almost the same at a very
small value. The detailed values of our experimental results
are presented in Appendix 1.

128B256B512B1KB2KB4KB8KB16KB32KB64KB128KBSegment size (Byte)00.511.52File reading time (ms)10410MB50MB100MB05001000128B256B512B1KB2KB4KB8KB16KB32KB64KB128KBSegment size (Byte)05001000150020002500Merkle path generation time (ms)10MB50MB100MB020406080128B256B512B1KB2KB4KB8KB16KB32KB64KB128KBSegment size (Byte)05001000150020002500Merkle root calculating time (ms)10MB50MB100MB020406080128B256B512B1KB2KB4KB8KB16KB32KB64KB128KBSegment size (Byte)0.020.0250.030.0350.040.0450.050.0550.06Merkle path verification time (ms)10MB50MB100MB10

Fig. 6: Computation cost of File reading, Merkle path generation, merkle root calculation, and Merkle path veriﬁcation for
ﬁles of 100MB, 500MB, and 1GB with varying segment size

6 CONCLUSION

REFERENCES

In this paper, we have introduced a novel game-theoretic
mechanism for the decentralized storage network allowing
the client to challenge the storage provider. This allows
us to eliminate the requirement of having continuously
verifying the storage provider which in turn improves the
performance of DSNs. Moreover, the client is protected from
service denying attack where a dishonest storage provider
submits proof of storage to the network while refusing
service to the client. Our proposed model is pluggable into
any blockchain platform with smart contract execution ca-
pability. We leverage the smart contract and oracle network
to govern the rules of the storage contract. We have imple-
mented our scheme using Solidity language and Chainlink
oracle network. The performance result demonstrates the
applicability of our scheme.

[1]

S. de Figueiredo, A. Madhusudan, V. Reniers, S. Nikova, and
B. Preneel, “Exploring the storj network: a security analysis,” in
Proceedings of the 36th Annual ACM Symposium on Applied Comput-
ing, pp. 257–264, 2021.

[2] G. Ateniese, L. Chen, M. Etemad, and Q. Tang, “Proof of storage-
time: Efﬁciently checking continuous data availability,” in Proceed-
ings of the 25th network and distributed system security symposium
(NDSS), pp. 1–15, Internet Society, 2020.
“Filecoin: A decentralized storage network,” tech. rep., Protocol
Labs, 2017.

[3]

[4] D. Vorick and L. Champine, “Sia: Simple decentralized storage,”

[5]

tech. rep., 2014.
“Storj: A decentralized cloud storage network framework,” tech.
rep., Storj Labs, Inc., 2018.

[7]
[8]

[6] V. Tron, A. Fischer, D. N. A, Z. Felf ¨oldi, and N. Johnson, “swap,
swear and swindle: incentive system for swarm,” tech. rep., Ether-
sphere, 2016. Ethersphere Orange Papers 1.
IPFS, “Interplanetary ﬁle system.”
S. Dziembowski, S. Faust, V. Kolmogorov, and K. Pietrzak, “Proofs
of space,” in Advances in Cryptology - CRYPTO 2015 - 35th Annual
Cryptology Conference, Santa Barbara, CA, USA, August 16-20, 2015,
Proceedings, Part II (R. Gennaro and M. Robshaw, eds.), vol. 9216
of Lecture Notes in Computer Science, pp. 585–605, Springer, 2015.

128B256B512B1KB2KB4KB8KB16KB32KB64KB128KBSegment size (Byte)00.511.522.5File reading time (ms)105100MB500MB1GB0500010000128B256B512B1KB2KB4KB8KB16KB32KB64KB128KBSegment size (Byte)00.511.522.5Merkle path generation time (ms)104100MB500MB1GB0200400600800128B256B512B1KB2KB4KB8KB16KB32KB64KB128KBSegment size (Byte)00.511.522.5Merkle root calculating time (ms)104100MB500MB1GB0200400600800128B256B512B1KB2KB4KB8KB16KB32KB64KB128KBSegment size (Byte)0.020.040.060.080.10.120.140.160.18Merkle path verification time (ms)100MB500MB1GB11

[31] B. Fisch, J. Bonneau, N. Greco, and J. Benet, “Scaling proof-
of-replication for ﬁlecoin mining,” tech. rep., Technical report,
Stanford University, 2018. https://web. stanford. edu . . . , 2018.

[32] Chainlink, “What is the blockchain oracle problem?,” tech. rep.,

2020.

[33] A. Egberts, “The oracle problem-an analysis of how blockchain or-
acles undermine the advantages of decentralized ledger systems,”
Available at SSRN 3382343, 2017.

[34] J. Katz and Y. Lindell, Introduction to modern cryptography. CRC

press, 2020.

[35] E. Ghosh, O. Ohrimenko, D. Papadopoulos, R. Tamassia, and
N. Triandopoulos, “Zero-knowledge accumulators and set alge-
bra,” in Advances in Cryptology - ASIACRYPT 2016 - 22nd Inter-
national Conference on the Theory and Application of Cryptology and
Information Security, Hanoi, Vietnam, December 4-8, 2016, Proceed-
ings, Part II (J. H. Cheon and T. Takagi, eds.), vol. 10032 of Lecture
Notes in Computer Science, pp. 67–100, 2016.

[36] “Chainlink 2.0: Next steps in the evolution of decentralized stor-

age networks,” tech. rep., Chainlink Labs, 2021.

[37] M. Kaleem and W. Shi, “Demystifying pythia: A survey of chain-
link oracles usage on ethereum,” in International Conference on
Financial Cryptography and Data Security, pp. 115–123, Springer,
2021.

[38] I. Vakilinia, S. Vakilinia, S. Badsha, E. Arslan, and S. Sengupta,
“Pooling approach for task allocation in the blockchain based de-
centralized storage network,” in 2019 15th International Conference
on Network and Service Management (CNSM), pp. 1–6, IEEE, 2019.

APPENDIX
Appendix A.

The detailed computation cost for our performance anal-
ysis on ﬁles with different sizes is presented in the following
tables.

[9] G. Ateniese, R. Burns, R. Curtmola, J. Herring, L. Kissner, Z. Peter-
son, and D. Song, “Provable data possession at untrusted stores,”
in Proceedings of the 14th ACM conference on Computer and commu-
nications security, pp. 598–609, 2007.

[10] G. Ateniese, R. Di Pietro, L. V. Mancini, and G. Tsudik, “Scalable
and efﬁcient provable data possession,” in Proceedings of the 4th
international conference on Security and privacy in communication
netowrks, pp. 1–10, 2008.

[11] C. C. Erway, A. K ¨upc¸ ¨u, C. Papamanthou, and R. Tamassia, “Dy-
namic provable data possession,” ACM Transactions on Information
and System Security (TISSEC), vol. 17, no. 4, pp. 1–29, 2015.

[12] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza,
“Snarks for c: Verifying program executions succinctly and in zero
knowledge,” in Annual cryptology conference, pp. 90–108, Springer,
2013.

[13] M. Campanelli, D. Fiore, N. Greco, D. Kolonelos, and L. Nizzardo,
“Incrementally aggregatable vector commitments and applica-
tions to veriﬁable decentralized storage,” in International Confer-
ence on the Theory and Application of Cryptology and Information
Security, pp. 3–35, Springer, 2020.

[14] Y. Du, H. Duan, A. Zhou, C. Wang, M. H. Au, and Q. Wang,
“Enabling secure and efﬁcient decentralized storage auditing with
blockchain,” IEEE Transactions on Dependable and Secure Computing,
2021.

[15] H. Yu, Q. Hu, Z. Yang, and H. Liu, “Efﬁcient continuous big data
integrity checking for decentralized storage,” IEEE Transactions on
Network Science and Engineering, vol. 8, no. 2, pp. 1658–1673, 2021.
[16] D. Catalano and D. Fiore, “Vector commitments and their applica-
tions,” in International Workshop on Public Key Cryptography, pp. 55–
72, Springer, 2013.

[17] R. W. Lai and G. Malavolta, “Subvector commitments with appli-
cation to succinct arguments,” in Annual International Cryptology
Conference, pp. 530–560, Springer, 2019.

[18] D. Boneh, B. B ¨unz, and B. Fisch, “Batching techniques for accu-
mulators with applications to iops and stateless blockchains,” in
Annual International Cryptology Conference, pp. 561–586, Springer,
2019.

[19] J. Buchmann and H. C. Williams, “A key-exchange system based
on imaginary quadratic ﬁelds,” Journal of Cryptology, vol. 1, no. 2,
pp. 107–118, 1988.

[20] B. Libert and M. Yung, “Concise mercurial vector commitments
and independent zero-knowledge sets with short proofs,” in The-
ory of Cryptography Conference, pp. 499–517, Springer, 2010.

[21] S. Gorbunov, L. Reyzin, H. Wee, and Z. Zhang, “Pointproofs:
Aggregating proofs for multiple vector commitments,” in Pro-
ceedings of the 2020 ACM SIGSAC Conference on Computer and
Communications Security, pp. 2007–2023, 2020.

[22] S. Srinivasan, A. Chepurnoy, C. Papamanthou, A. Tomescu, and
Y. Zhang, “Hyperproofs: Aggregating and maintaining proofs in
vector commitments,” Cryptology ePrint Archive, 2021.

[23] C. Papamanthou, E. Shi, R. Tamassia, and K. Yi, “Streaming
authenticated data structures,” in Annual International Conference
on the Theory and Applications of Cryptographic Techniques, pp. 353–
370, Springer, 2013.

[24] H. Shacham and B. Waters, “Compact proofs of retrievability,” in
International Conference on the Theory and Application of Cryptology
and Information Security, pp. 90–107, Springer, 2008.

[25] A. Juels and B. S. Kaliski Jr, “Pors: Proofs of retrievability for large
ﬁles,” in Proceedings of the 14th ACM conference on Computer and
communications security, pp. 584–597, Acm, 2007.

[26] K. D. Bowers, A. Juels, and A. Oprea, “Proofs of retrievability:
Theory and implementation,” in Proceedings of the 2009 ACM
workshop on Cloud computing security, pp. 43–54, 2009.

[27] D. Cash, A. K ¨upc¸ ¨u, and D. Wichs, “Dynamic proofs of retrievabil-
ity via oblivious ram,” Journal of Cryptology, vol. 30, no. 1, pp. 22–
57, 2017.

[28] Y. Dodis, S. Vadhan, and D. Wichs, “Proofs of retrievability
via hardness ampliﬁcation,” in Theory of Cryptography Conference,
pp. 109–127, Springer, 2009.

[29] E. Stefanov, M. van Dijk, A. Juels, and A. Oprea, “Iris: A scalable
cloud ﬁle system with efﬁcient integrity checks,” in Proceedings of
the 28th Annual Computer Security Applications Conference, pp. 229–
238, 2012.

[30] E. Shi, E. Stefanov, and C. Papamanthou, “Practical dynamic
proofs of retrievability,” in Proceedings of the 2013 ACM SIGSAC
conference on Computer & communications security, pp. 325–336,
2013.

TABLE 2: File with the size of 10MB

Segment Size

Number of Seg-
ments

Tree Height

File
Time (ms)

Reading

128 bytes
256 bytes
512 bytes
1024 bytes
2048 bytes
4KB
8KB
16KB
32KB
64KB
128KB

81920
40960
20480
10240
5120
2560
1280
640
320
160
80

17
16
15
14
13
12
11
10
9
8
7

1787.904
927.353
537.782
285.219
183.741
120.084
77.793
56.051
45.227
41.836
37.5

Path

Root

Merkle
Calculating
Time (ms)
238.09
95.722
56.897
29.52
15.773
8.305
5.104
2.083
1.185
0.725
0.605

Merkle
Generating
Time (ms)
208.206
99.334
52.63
24.91
12.442
6.529
3.31
2.108
1.342
0.587
0.237

Merkle
Veriﬁcation
Time (ms)
0.04561
0.045473
0.038086
0.037828
0.032765
0.031265
0.025769
0.023075
0.021736
0.021259
0.022016

12

Path

TABLE 3: File with the size of 50MB

Segment Size

Number of Seg-
ments

Tree Height

File
Time (ms)

Reading

128 bytes
256 bytes
512 bytes
1024 bytes
2048 bytes
4KB
8KB
16KB
32KB
64KB
128KB

409600
204800
102400
51200
25600
12800
6400
3200
1600
800
400

19
18
17
16
15
14
13
12
11
10
9

8950.15
4672.522
2515.876
1347.252
786.049
526.626
363.279
272.149
216.035
189.12
170.561

Path

Root

Merkle
Calculating
Time (ms)
982.823
491.322
277.763
138.973
67.828
31.673
18.832
10.909
5.435
2.535
1.441

Merkle
Generating
Time (ms)
946.094
504.713
264.181
130.389
62.617
32.167
16.647
7.483
4.442
2.575
1.62

Path

Merkle
Veriﬁcation
Time (ms)
0.046496
0.043598
0.042748
0.034638
0.032882
0.031378
0.026893
0.026698
0.026167
0.026538
0.025657

TABLE 4: File with the size of 100MB

Segment Size

Number of Seg-
ments

Tree Height

File
Time (ms)

Reading

128 bytes
256 bytes
512 bytes
1KB
2KB
4KB
8KB
16KB
32KB
64KB
128KB

819200
409600
204800
102400
51200
25600
12800
6400
3200
1600
800

20
19
18
17
16
15
14
13
12
11
10

18014.235
9195.558
5049.277
2758.359
1547.833
1020.346
702.577
562.009
432.415
378.376
351.862

Path

Root

Merkle
Calculating
Time (ms)
2244.158
1013.982
578.276
301.883
141.994
59.108
30.809
18.067
10.992
6.522
2.69

Merkle
Generating
Time (ms)
2006.815
994.447
521.768
269.799
135.149
66.528
29.473
17.364
7.898
4.389
2.538

Path

Merkle
Veriﬁcation
Time (ms)
0.059693
0.055185
0.052264
0.044779
0.041836
0.038147
0.034908
0.03352
0.028791
0.027291
0.024287

TABLE 5: File with the size of 500MB

Segment Size

Number of Seg-
ments

Tree Height

File
Time (ms)

Reading

128 bytes
256 bytes
512 bytes
1KB
2KB
4KB
8KB
16KB
32KB
64KB
128KB

4096000
2048000
1024000
512000
256000
128000
64000
32000
16000
8000
4000

22
21
20
19
18
17
16
15
14
13
12

94737.491
46169.824
25267.874
13553.087
7354.601
5156.859
3368.927
2534.908
2041.117
1886.029
1792.042

Path

Root

Merkle
Calculating
Time (ms)
9818.019
5388.3
2489.126
1464.32
741.567
325.235
184.248
74.448
38.056
23.166
13.81

Merkle
Generating
Time (ms)
10132.573
4969.759
2534.864
1348.817
743.942
315.587
152.093
79.405
37.963
19.252
9.572

Path

Merkle
Veriﬁcation
Time (ms)
0.098665
0.082575
0.060895
0.058168
0.055256
0.052793
0.047618
0.042676
0.038281
0.030165
0.027942

13

TABLE 6: File with the size of 1GB

Segment Size

Number of Seg-
ments

Tree Height

File
Time (ms)

Reading

128 bytes
256 bytes
512 bytes
1KB
2KB
4KB
8KB
16KB
32KB
64KB
128KB

8192000
4096000
2048000
1024000
512000
256000
128000
64000
32000
16000
8000

23
22
21
20
19
18
17
16
15
14
13

202395.99
97338.305
51409.273
28270.954
16586.863
10458.671
6790.474
5085.178
4101.697
3798.152
3446.469

Path

Root

Merkle
Calculating
Time (ms)
22132.426
11019.89
4939.284
2449.939
1404.678
714.115
312.334
214.378
86.309
41.595
23.972

Merkle
Generating
Time (ms)
23687.559
10064.421
4955.69
2510.657
1435.893
636.902
288.44
150.928
73.861
39.496
20.959

Path

Merkle
Veriﬁcation
Time (ms)
0.166503
0.129042
0.104241
0.069888
0.062182
0.060185
0.054482
0.043327
0.03741
0.034669
0.030534

