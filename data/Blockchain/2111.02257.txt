1
2
0
2

v
o
N
3

]

R
C
.
s
c
[

1
v
7
5
2
2
0
.
1
1
1
2
:
v
i
X
r
a

Chirotonia: A Scalable and Secure e-Voting
Framework based on Blockchains and Linkable
Ring Signatures

Antonio Russo
Antonio Fern´andez Anta
IMDEA Networks Institute
Madrid, Spain
email: antonio.russo@imdea.org
email: antonio.fernandez@imdea.org

Mar´ıa Isabel Gonz´alez Vasco
Departamento de Matem´atica Aplicada
Universidad Rey Juan Carlos
Mostoles, Madrid, Spain
email: mariaisabel.vasco@urjc.es

Simon Pietro Romano
DIETI
University of Napoli, Federico II
Naples, Italy
email: spromano@unina.it

Abstract—In this paper we propose a comprehensive and
scalable framework to build secure-by-design e-voting systems.
Decentralization, transparency, determinism, and untamperabil-
ity of votes are granted by dedicated smart contracts on a
blockchain, while voter authenticity and anonymity are achieved
through (provable secure) linkable ring signatures. These,
in
combination with suitable smart contract constraints, also grant
protection from double voting. Our design is presented in detail,
focusing on its security guarantees and the design choices that
allow it to scale to a large number of voters. Finally, we present
a proof-of-concept implementation of the proposed framework,
made available as open source.

Index Terms—E-voting, linkable ring signatures, blockchain,

smart contracts, Ethereum.

I. INTRODUCTION

Building an e-voting system represents a big challenge, due
to strong requirements in terms of conﬁdentiality, integrity and
availability. Such a system must preserve these properties not
only when facing external attackers, but also in the presence
of malicious insiders, like regular or administrative users who
misbehave and try to undermine the correct operation of the
e-voting system. It is usually expected from an electronic
voting scheme that it provides at least the same guarantees as
those of a classic (paper-based) voting system, while adding
the advantages of a modern electronic system, like remote
participation and information processing speed.

In this paper we propose a decentralized, secure, and
scalable framework for e-voting systems based on linkable ring
signatures, a blockchain, and smart contracts. The blockchain
provides a reliable repository for the data used by the e-
voting system, and the support for the smart contracts that
deﬁne the computation performed in each phase of a voting
process. The blockchain also relieves from the need of having
a centralized solution for a veriﬁed bulletin board. Then, the
voting ballots are signed with linkable ring signatures, which
is a cryptographic tool that allows only legal voters to sign,
and detects duplicated signers without revealing identities or
ballot contents. In this paper we also adopt a linkable ring
signature scheme using Elliptic Curve Cryptography (ECC),

which grants very short keys and signatures, hence making
the framework scalable.

A. Related Work

There are a number of secure e-voting systems proposed
in the literature. The Helios system [1] is generally used
as a reference due to its simple voting workﬂow, and its
privacy and veriﬁability properties achieved through zero-
knowledge proofs [12]. Its main drawback is that it requires the
existence of a trusted central server, which is responsible for
identifying voters, as well as for storing, shufﬂing, decrypting,
and publishing ballots.

The Belenios system [9] is based on Helios but improves
it by providing universal veriﬁability, even in the presence of
a dishonest bulletin board (the element used for making data
publicly available for veriﬁability checks). As Helios, Belenios
has a complete open source implementation that is able to
handle a reasonably large number of voters. However, also as
Helios, it still requires a trusted central server for the major
process phases in order to ensure vote correctness.

Benaloh and Tuinstra [4] proposed a receipt-free voting
system able to guarantee coercion resistance, ballot privacy,
and veriﬁability via interactive zero-knowledge proofs. Un-
fortunately, their system requires a trusted central authority
that continuously interacts with the voters during the voting
process. Moreover, voters must not be able to communicate
with external entities during the voting process. Compared
with classic paper ballot voting, the overhead of this system
in terms of deployment effort and actions required from the
voters is unfortunately not trivial. The advantages provided are
the determinism and quick aggregations of the result. Remote
voting is hardly achievable.

The D-DEMOS suite [8] (which is built on top of Helios [1])
takes a step further in the guarantees and properties that are en-
sured. It adopts Veriﬁed Secret Sharing [24], Zero Knowledge
Proofs, and applies segregation of duties for the main tasks
of the voting process. All the properties are provided in the
assumption that, for each vote, an Election Authority setups

 
 
 
 
 
 
the system, distributes the required cryptography information
to all
the involved actors (included voters, with different
data for each of them), and gets destroyed without colluding
with any party. A key requirement of D-DEMOS in order to
ensuring the system properties is that the Election Authority
gets destroyed and does not share the secret information it
generated on behalf of the other entities. In fact, even if its
computations can be veriﬁed, it is not possible to avoid that
a malicious Election Authority shares secret information of
voters with other parties; this would enable them to vote on
behalf of the voters. In our approach all the tasks necessary
for the voting session setup are publicly veriﬁable, they do not
involve any secret generation on behalf of other parties and,
for each new vote session, voters can directly compute and
submit a new valid ballot with the information they already
hold.

To our knowledge,

in the distributed and decentralized
setting we want to provide, there are two main relevant works.
First, Liu and Wang [22] propose an e-voting system that uses
a blockchain paired with blind signatures. Voters’ privacy is
granted by computing blind signatures of ballots, with third
parties being in charge of identifying voters and signing back
data. This requires the identiﬁcation process to be run for each
vote and for each identiﬁcation authority. Then the blockchain
acts as an auditable communication channel among parties.
In contrast, in our proposal the identiﬁcation process can be
reused over many voting sessions, voters can submit their
ballots without waiting for other entities to come into play,
and the blockchain is an active validator for the used data.

Second, Lyu et al. [23] is the existing work more relevant
to our framework, since it also combines a blockchain, smart
contracts, and ring signatures. Their voting protocol is very
similar to the one proposed here, yet there are some relevant
differences. For instance, in their proposal, voters are respon-
sible for running a distributed key generation protocol, thus
involving a signiﬁcant amount of processing and communica-
tion for large pools of voters, making it hard to go beyond a
small number of users (the authors use up to 40 users in their
tests). In contrast, as we will see, our design smoothly scales
up to thousands of voters.

B. Contributions

In this work we propose a framework to build e-voting
systems based on a blockchain, smart contracts, and linkable
ring signatures. The framework is realized as a set of protocols
and tools that can be used in a wide range of e-voting
scenarios. More precisely, we provide:

• A modular approach to build distributed, secure, veriﬁ-

able, and scalable e-voting systems.

• A set of tools to implement such systems in different

e-voting scenarios.

• A formal security analysis supporting our choice of a
linkable ring signature scheme, as proposed in [21].
• A proof-of-concept implementation that can be run in
any Ethereum-compliant blockchain, demonstrating the
practical feasibility of our approach.

C. Paper Roadmap

In Section II we introduce the blockchain properties we
leverage and our main cryptographic tool: linkable ring sig-
natures. Section III-A presents the concrete signature scheme
adopted, describing the security properties it satisﬁes (our full
paper version provides a complete formal security analysis),
while Section III-B focuses on its storage efﬁciency. Our
e-voting framework is presented in Section IV, where we
describe the involved actors and their interactions. Section V
provides the details of the identiﬁcation process and the pro-
posed ways to guarantee conﬁdentiality and anonymity. Next,
a complete list of features achieved by our design is depicted
in Section VI. Finally, Section VII presents our choices for
the implemented proof of concept, and Section VIII wraps up
with some ﬁnal conclusions.

II. BUILDING BLOCKS

A. Blockchain and Smart Contracts

The chain-of-blocks data structure, paired with a Byzantine
Fault Tolerant consensus (see [7, 19]) results in a powerful and
nifty way to realise an untamperable Distributed Ledger. We
will not go into details of blockchain foundations and its wide
range of implementations. Indeed, we model the blockchain
properties as a replicated database and a deterministic exe-
cution environment, resilient to a bounded set of Byzantine
failures. We refer to the code that is stored and executed in
the blockchain as Smart Contract [29] and to the activation of
a piece of it as a transaction. Thanks to the chain-of-blocks
data structure, any modiﬁcation to the system state is audited
in an untamperable manner on the blockchain itself as part of
the state (e.g., a transaction that calls a function in a smart
contract is stored including information on the called function
and all the parameters passed as arguments).

B. Linkable Ring Signatures

Ring signatures are cryptographic constructions, ﬁrst in-
troduced by Rivest, Shamir and Tauman [26], allowing for
the creation of signatures on behalf of a group of signers,
while hiding the identity of the actual signer among the group.
In [21], so-called linkable ring signatures were introduced as
an extension to ring signatures, adding the feature of providing
a public way of determining whether two signatures have
actually been produced by the same signer. As pointed out
in [2], these constructions are particularly suited for e-voting
schemes, as linkability prevents voters from casting multiple
votes while anyonymity is preserved within the group of
registered voters. Formally:

Deﬁnition 1 (Linkable ring signature scheme): A link-
able ring signature scheme is deﬁned by four probabilis-
tic polynomial-time algorithms (KeyGen, Sign, Verify, Link)
such that:

• KeyGen(1(cid:96)), the key generation algorithm, takes as an
input the security parameter (cid:96) and outputs a pair (pk, sk)
of public (veriﬁcation) and secret (signing) keys,

• Sign(1(cid:96), skπ, pk1, . . . , pkn, m), the signature algorithm,
takes as input the security parameter (cid:96), a secret key skπ,

for some π ∈ {1, . . . , n}, a message m (which is assumed
to belong to a public message space M(cid:96)) and a list of
public keys pk1, . . . , pkn, and outputs a signature σ.
• Verify(1(cid:96), pk1, . . . , pkn, m, σ), the veriﬁcation algorithm,
takes as input the security parameter (cid:96), a list of public
keys pk1, . . . , pkn, a message m ∈ M(cid:96) and a signature
σ, and outputs a bit b ∈ {0, 1} (namely, 1 if the signature
is recognized as valid w.r.t. the list of public keys, and 0
otherwise).

• Link(σ1, σ2, m1, m2), the linking algorithm, takes as an
input two signatures, σ1, σ2, and two messages, m1, m2,
and outputs a bit β ∈ {0, 1}, indicating whether the two
signatures have been produced by the same user or not.

There are two obvious correctness requirements to add
to the above deﬁnition imposing that, indeed, properly con-
structed signatures can be veriﬁed and linked as intended.
Furthermore, our usage of a linkable signature scheme requires
that certain security properties are fulﬁlled, which we infor-
mally list below:

• Unforgeability: only those belonging to the designed
group of voters can produce a valid signature (which will
be validated with respect to the election census).

• Anonymity: the actual identity of a signer remains hidden

within the signing group.

• Linkability: different uses of the same secret key can be

identiﬁed through the public information.

• Non-framability: it is not possible for an adversary to
interfere with the correctness of linkability, even if he/she
is able to corrupt (a polynomial number of) group mem-
bers. Namely, even seeing a number of signatures of a
prescribed honest user, and controlling some legitimate
signers, he/she should not be able to produce a new
signature that will
link with the honest user without
his/her secret key 1

In the appendices, we give formal deﬁnitions (Appendix B)
and security proofs (Appendix C) for the concrete instantiation
of a linkable ring signature scheme we use in our design,
which we describe in the next section and have implemented
in our proof of concept (see Section VII). While we follow the
approach of [21], it is worth mentioning two main differences
in our security analysis. First, we allow for corruptions in the
unforgeability deﬁnition, which are not considered in [21].
This is particularly relevant for our use case, as a collusion
of malicious users of the system should indeed not be able
to produce a valid signature that can be veriﬁed using a set
of public keys from honest users. Second, we include non-
framability as a desirable property, which in particular for our
use case implies that a collusion of voters may not produce
a valid signature (e.g., vote) that can be linked with another
(honest) user, thus preventing him/her from casting a vote.

1Deviating from [21] we work with the (stronger, and more realistic)
deﬁnition from [2] where the case of colluding malicious users is captured, as
the adversary is allowed to query for (a polynomial number of) secret keys.

III. PROPOSED LINKABLE RING SIGNATURE SCHEME

A. Signature Scheme

Elliptic curve cryptography (ECC) constructions make use
of an elliptic curve deﬁned over a ﬁnite ﬁeld K, which is
ﬁxed and made public through two coefﬁcients a, b (see [13]).
Namely, the curve is deﬁned as the set of points (x, y) ∈ K 2
fulﬁlling y2 = x3 + ax + b. Moreover, a group law + is
deﬁned on this set of points, and typically a cyclic subgroup
E of this group is ﬁxed, selecting a generator G. Under certain
conditions, it is assumed that the associated discrete logarithm
problem — which in additive notation is described as the
problem of ﬁnding the integer a such that a given point P ∈ E
is the result of adding up G with itself a times, i.e., P = a·G,
— is computationally hard. Moreover, many cryptographic
constructions rely on the hardness of two related problems:
Computational and Decisional Difﬁe Hellman, usually referred
to as CDH and DDH (see [6] for details on these problems).

We describe now our modiﬁcation of the proposal in [21].
Once the security parameter (cid:96) is ﬁxed, we assume there is a
public directory specifying a cyclic group E of order g within
the group of points of an elliptic curve over a ﬁnite ﬁeld Fp
of size p (g, p are polynomial in (cid:96)). Moreover, there is also
a ﬁxed generator G for E that we assume publicly known.
Furthermore, two different (public) hash functions H and H2P
are chosen and made public:

H : {0, 1}∗ → Fp, H2P : {0, 1}∗ → E.

With these ingredients, a linkable ring signature scheme can

be deﬁned as follows:

Key Generation. KeyGen(1(cid:96)) takes as an input the security
parameter (cid:96) and selects uniformly at random an integer sk
within {1, . . . , g − 1}. Then, it sets pk = sk · G and outputs
the resulting pair (pk, sk) of public (veriﬁcation) and secret
(signing) keys.

Signature Generation. Sign(1(cid:96), skπ, pk1, . . . , pkn, m), given
a public key tuple PK n = (pk1, . . . , pkn), a pair (skπ, pkπ),
where π ∈ {1, . . . , n}, starts by setting

L = H2P (HPK (PK n)), T = skπ · L.

Here, HPK is a hashing procedure (that could actually be
replaced by others, as in the generic construction of [21])
deﬁned for public key tuples as follows. Given

PK i = (pk1, ..., pki)

0 < i ≤ n,

we set (|| stands for the string concatenation operator),

(cid:40)

HPK (PK i) :=

H(pk1)
H(HPK (PK i−1)||pki)

if i = 1
if i > 1.

Let us denote by x ∈R X the selection, uniformly at
random, of an element x from the set X. Values s1, . . . , sn
are computed, starting from index π as follows:

u ∈R {1, . . . , g − 1}, s(cid:48)

π ∈R {1, . . . , g − 1}

Aπ = s(cid:48)

π · G + u · pkπ, Bπ = s(cid:48)

π · L + u · T

cπ = H(m||T ||Aπ||Bπ)).

while for coefﬁcients i = π + 1, ..., n, 1, ..., π − 1:

si ∈R {1, . . . , g − 1}, Ai = si · G + ci−1 · pki

Bi = si · L + ci−1 · T, ci = H(m||T ||Ai||Bi)).

Finally, sπ is computed as sπ = s(cid:48)

π + skπ(u − cπ−1)
and c = cn (All computations in the subindexes i above
are done mod p). The output signature σ is deﬁned as σ =
(PK n, T, s1, . . . , sn, c).
Signature Veriﬁcation. Verify(1(cid:96), pk1, . . . , pkn, m, σ) ﬁrst
performs the following computations from the input values
m, PK n and σ

L = H2P (HPK (PK n)), c0 = c

. Furthermore, it builds, for i = 1, ..., n,

Ai = si · G + ci−1 · pki, Bi = si · L + ci−1 · T,

ci = H(m||T ||Ai||Bi).

Using cyclic groups over ﬁnite ﬁelds (i.e., which we call non-
ECC case), both T and the public keys belong to the same
group as the private keys, so each signature needs a space of
384 + 384(n + 1) = 384(n + 2) bytes, while storing the ring
of public keys requires 384 · n bytes.

TABLE I
STORAGE REQUIREMENTS IN BYTES OF LINKABLE RING SIGNATURES
OVER ELLIPTIC CURVES (256 BIT SECRET KEY) VERSUS THE ORIGINAL
PROPOSAL FROM [21] (3072 BIT SECRET KEY)

Signers
10
100
1000

ECC PKs
640
6400
64000

ECC Sig
416
3296
32096

non-ECC PKs
3840
38400
384000

non-ECC Sig
4608
39168
384768

Public key’s ring size in the ECC case is roughly one ﬁfth
of the non-ECC case, but the most important saving in storage
comes for signature sizes: the ECC signature length is less than
one tenth of the non-ECC case. As we will see in Section IV-B,
a signature is saved in the blockchain per each ballot, so the
saving in space with the ECC approach is huge.

IV. VOTING FRAMEWORK

Finally, if cn equals c0, it outputs 1. Otherwise, it outputs 0
and rejects the signature as invalid.

Linkability Check. Link(σ1, σ2, m1, m2), given

σ1 = (PK n, T1, s1, . . . , sn, c), σ2 = (PK n, T2, ˆs1, . . . , ˆsn, ˆc),

This section presents the design of the proposed system.
We start by deﬁning the different actors involved in its
construction. Then, we will move to describe their interactions.
In Appendix A we provide sequence diagrams that summarize
the voting protocol.

outputs 1 if an only if T1 = T2.

We are able to formally assess the following result:
Theorem 1: The ring signature scheme presented attains
unforgeability, anonymity, linkability, and non-framability in
the random oracle model2 and under the DDH assumption in
the underlying cyclic group E generated by G.

B. Efﬁciency (storage)

Our choice of an ECC linkable ring signature scheme is due
to economy in keys and signatures sizes. Assuming private
keys of 256 bits (32 bytes), Table I summarizes the space
required for public keys and signatures compared to the same
implementation in a group of prime order (reaching the same
security level as with ECC).

We also assume that the list of public keys P Kn does not
change once registration ends, so it can be saved once for all
the signatures referring to the whole list. For the ECC case, it
is useful for smart contract computations to have public keys
(that are points in the curve) saved in an uncompressed form,
so both coordinates are stored. Hence, for n voters, the length
of the signature is the tag T length, n times the ring coefﬁcient
si length, plus the anchor coefﬁcient cn length. For the ECC
case, in bytes, the signature length is 64+32(n+1) = 32(n+3)
(because T is an elliptic curve point, while the coefﬁcients
have the same size as the private key); the public key is an
elliptic curve point, so its length is 64 · n = 32 · 2n bytes.

2proofs in the random oracle model work under the assumption that the
hash functions involved behave as idealized/truly random functions (see [3])

A. Actors

The voting process is divided into phases, in which different
actors play speciﬁc roles. Each actor is intended to be an
independent entity for simplicity, but nothing prevents an actor
from being a set of cooperating subjects, leveraging blockchain
and smart contracts capabilities or, as an alternative, legal con-
tracts or other constraints. We will mention related scenarios
in the subsequent Section V.

a) Voter: A voter is the entity engaged in the voting
process with the aim to express his/her vote. Voters own
enough information for being correctly identiﬁed (Line 1
Alg. 1), as well as to store and manage secret data linked
to their digital identity. It is their own responsibility to make
correct computations following the scheme speciﬁcation in
order to generate and submit a valid ballot.

IdentityManager.SIGNUP(IDData, pk)

Algorithm 1 Code for Voter
1: Init: IDData ← Voter Identiﬁcation Data
2: Init: (pk, sk) ← KeyGen()
3: function SIGNUP( )
4:
5: function VOTE(v)
6:
7:
8:
9:
10: function GETRESULT( )
11:

return BallotBox.Result

P KS ← IDStorage.Get()
ballot ← Encrypt(v, ConfManager.PublicKey)
σ ← Sign(sk, P KS, ballot) (cid:46) Computes the ring signature
BallotBox.VOTE(σ, ballot)

b) Organizer: The Organizer is the entity that conﬁgures
and selects parameters characterizing a concrete voting event,
i.e., vote’s properties and voters’ rights. It is responsible for
setting up the overall voting session.

Algorithm 2 Code for Organizer
1: Init: deploy ID Storage, Ballot Box, Conﬁdentiality Manage
2: Init: conﬁgure vote open, vote close
3: upon (ConfManager.SecretKey (cid:54)= ∅) do
4:
5:
6:
7: end upon

Ballots ← BallotBox.Get()
Result ← Decrypt(Ballots, ConfManager.SecretKey)
BallotBox.SETRESULT(Result)

c) Identity Manager: Identiﬁcation is taken care of by the
so-called Identity Manager. Its main task is to identify actors
involved in the voting process and to register them (Line 2
and 4 Alg. 3) in the platform according to the policies deﬁned
by the Organizer. The label derived from the IDData works
as identiﬁer for the voter and can be useful to match the list
of registered voters to some external public one.

Algorithm 3 Code for Identity Manager
1: function SIGNUP(IDData, pk)
2:
3:
4:

label ← LabelFromIDData(IDData)
call IDStorage.SIGNUP(pk, label)

if VerifyIdentity(IDData) then

d) Conﬁdentiality Manager: When required, a Conﬁden-
tiality Manager is responsible to guard and distribute informa-
tion necessary to encrypt and decrypt votes. This is a sensitive
component, and Section V-B goes in depth about possible
solutions that guarantee conﬁdentiality with and without a
Conﬁdentiality Manager.

Algorithm 4 Smart Contract for Conﬁdentiality Manager
1: Init: PublicKey ← DistrP KGeneration()
2: Init: SecretKey ← ∅
3: upon (vote close) do
4:
5: end upon

SecretKey ← DistrSKGeneration()

(cid:46) event ﬁred/enabled by the blockchain

B. Voting Protocol

To describe the voting process we introduce two more

components:

• the ID Storage (see Alg. 5) is the bulletin board of eligible

voters.

• the Ballot Box (see Alg. 6) is the storage of valid ballots.

Algorithm 5 Smart Contract for ID Storage.
1: Init: P ublicKeys ← ∅
2: function SIGNUP(pk, label)
3:
4:

if ¬ BallotBox.active then

P ublicKeys ← P ublicKeys||< pk, label >

(cid:46) Only by the Identity Manager

if σ.T /∈ T ags ∧ active then (cid:46) The scheme Link function

Algorithm 6 Smart Contract for Ballot Box. p is the total
number of possible choices for a ballot.
1: Init: choices ← {v0, ..., vp}
2: Init: active ← f alse
3: Init: Ballots ← ∅; T ags ← ∅; Result ← ∅
4: function VOTE(σ, b)
5:
6:
7:
8: upon (vote open) do
9:
10: end upon
11: upon (vote close) do
active ← f alse
12:
13: end upon
14: function SETRESULT(R)
Result ← R
15:

if Verify(BallotBox.P ublicKeys, b, σ) then

(cid:46) event ﬁred/enabled by the blockchain

(cid:46) event ﬁred/enabled by the blockchain

Ballots ← Ballots ∪ b

(cid:46) Only by Organizer

active ← true

1) Setup: The Organizer deploys and conﬁgures on the
blockchain the three smart contracts that hold the public
information for the voting session: ID Storage, Ballot Box,
Conﬁdentiality Manager (Line 1 of Alg. 2). The Organizer
conﬁgures, in this phase, the ﬁring for the vote opening and
vote closing events. Moreover,
the Organizer declares the
tolerance to failures for the Identity Manager and the Con-
ﬁdentiality Manager if they adopt any threshold mechanism
(K out of N discussed in Sections V-A and V-B).

2) Registration: Voters are required to sign up (Line 3
Alg. 1) to the system by providing (a) information that allows
to prove their identity and (b) the public key they are going to
use for the vote (Line 4 Alg. 1). This is a simpliﬁcation of a
typical certiﬁcate issuing procedure, since the outcome is not a
signed certiﬁcate but a registration on the ID Storage contract.
Only voters who sign up strictly before the vote opening will
be allowed to vote.

3) Vote Opening: The Ballot Box is set to active (Line 9 of
Alg. 6) so it begins to accept ballots and the ID Storage stops
accepting new public keys. The vote opening/closing event
reported in Algorithms 2, 5 and 6 is pointed as an external
condition, since it is enforced by leveraging the blockchain
and smart contract property of referring to the constant-time
block issuance process. In this way, operations are constrained
in respect to time. Anyway, if this property is not available in
the chosen system deployment, the Organizer is in charge of
ﬁring those events by writing them in the blockchain.

4) Voting: Eligible voters interact with the platform in order
to get the information required for voting. In order to submit a
valid ballot, voters: (1) fetch identities needed for the linkable
ring signature from the ID Storage (Line 1 Alg. 1), (2) use the
format/encoding deﬁned in the Ballot Box to create a ballot,
encrypt it by fetching information from the Conﬁdentiality
Manager (Line 7 Alg. 1), (3) compute the linkable ring
signature (Line 8 Alg. 1) and ﬁnally (4) anonymously send
their vote to the system (Line 9 Alg. 1).

With the above ingredients, the framework phases are de-

5) Vote Closing: The same considerations made for the

scribed as follows:

Vote Opening hold for the Closing event.

6) Tally: Once the Voting Phase has been closed,
the
Conﬁdentiality Manager is in charge of releasing the Secret
Key paired with the Public Key published for ballot encryption
(Line 4 Alg. 4). Once done, anyone, thanks to the information
publicly available on the blockchain, is able to decrypt ballots
and compute the ﬁnal result.

V. PROTOCOL DETAILS AND DESIGN CHOICES

This section gives details on how our framework achieves
Identiﬁcation, Conﬁdentiality, Anonymity and Scalability in
different application scenarios.

A. Identiﬁcation

Identiﬁcation is a vital step in the vote startup. There are
many known and well assessed procedures employed nowa-
days for mapping real identities to digital ones, like adopting
multiple factors of authentication and/or relying on certiﬁcate
authorities. We deliberately wrap any of these procedures in
the IDData variable (Line 1 Alg. 1). The Identity Manager
is thus responsible for mapping the chosen identiﬁcation
procedures to our system. Since achieving resilience to Byzan-
tine failures (unwanted or malicious failures and deliberate
misbehavior) is one of our major goals, it is recommended
to distribute the identiﬁcation responsibility among a set of
entities. That is, multiple entities should contribute to the
Identity Manager’s operation and can leverage the smart
contract capabilities in order to cooperate (e.g., use a K out
of N threshold mechanism).

Moreover, to let failures be as independent as possible, the
Identity Manager should implement different voters’ identiﬁ-
cation procedures (that is, in our construction, implement dif-
ferent VerifyIdentity(IDData) functions in Line 2 of Alg. 3).

B. Conﬁdentiality

Our system guarantees secrecy to voters and avoids un-
wanted early result disclosures. To this aim, there are several
concrete solutions that may be implemented. Indeed, a Ballot
box built on the blockchain can be compared to a transparent
box with unfolded paper inside and anyone being able to take
note of added votes. The vote result is known step by step
during the Voting Phase and, in most use cases, this is not a
desired possibility because real time results may inﬂuence the
voters who haven’t voted yet. That is why a mean to obfuscate
votes contents during the Voting Phase is required.

1) Ballot encoding and encryption: Each participating en-
tity can acquire information about choices encoding from the
Ballot Box (Line 1 Alg. 6). Then, we rely on the fact that the
Encrypt function in Line 7 of Alg. 1 is always able to provide
a different ciphertext at each execution even if encrypting
this
the same plaintext. If encryption were deterministic,
is trivially achieved by embedding a random salt at each
encryption (non-deterministic schemes, like RSA-OAEP [3],
will do the job without modiﬁcations).

2) Conﬁdentiality Manager: The Conﬁdentiality Manager
is the component in charge of providing the public key used
to encrypt ballots during the Voting Phase. From the trustwor-
thiness perspective, the Conﬁdentiality Manager has the pos-
sibility to completely invalidate a voting session because the
tally directly depends on the secret key disclosure. Hence, for
an attacker, it would be sufﬁcient to compromise the Conﬁden-
tiality Manager to void the result of the voting session. For this
reason, the responsibility of generating a key pair at the correct
time is shared among a set of cooperating entities. Properly
designed for use cases like ours, the Ethereum Distributed
Key Generation (ETHDKG) [27] allows different entities to
generate and share a key pair with a threshold mechanism of
K out of N for private key disclosure. It exploits Shamir’s
Secret Sharing [28] and Veriﬁable Secret Sharing [11], and
relies on the blockchain as an auditable communication mean.
In particular the whole ETHDKG protocol is executed before
vote opening, resulting in the master public key for ballot
encryption (Line 1 Alg. 4). As soon as the vote is closed, the
individual secret key shares are revealed in order to execute
the Tally Phase (Line 4 Alg. 4). If K is the number of shares
required to reconstruct the secret key and N the number of
Conﬁdentiality Manager members, the tolerance to malicious
behavior is min(K −1, N −K); in fact the system correctness
can be undermined in two cases: (1) the secret is disclosed
before the Tally Phase, so K entities disclosed earlier; or
(2) the secret is never disclosed because N − K + 1 entities
do not correctly participate in the secret reconstruction. Since
both cases must be avoided, tolerance to failing entities is the
minimum between the two.

3) Vote Claim: As an alternative to the distributed key
generation, a two step procedure is possible. (Submit Step)
The voters do not encrypt their ballots and they do not submit
the ballot content in the voting phase. Instead, they (1) salt
the ballot content, (2) compute a hash of it, (3) ring-sign
the hash string, and (4) they send to the Ballot Box the ring
signatures along with the hash string. If the signature is valid,
then both, signature and hash string, are immutably stored
in the blockchain and, since ballots are salted, there is no
feasible way for a computationally bounded adversary to invert
the hash and derive the original ballot. When the tally begins
(Redeem Step), voters can

submit their ballots to the smart contract which will accept
only those with a matching hash stored in the previous step.
Although this seems to solve the conﬁdentiality problem

there are some important drawbacks to take into account:

• The voters must interact one more time with the platform
to claim their vote in the Tally Phase, and this can be an
issue for effective participation with a large number of
voters (i.e., if a “participation threshold” exists, it should
be reached not only during the Voting Phase but also
during the tally interaction).

• The voters need to store their ballot somewhere, waiting
for the Voting Phase to ﬁnish. The device or system they
rely on should be kept secure during this time.

• During the Tally Phase results are collected in a time
window, so a voter could decide to submit or not his/her
ballot depending on the ongoing result. In some cases,
this would void the neutrality of the system.

If the voting use case does not need to be resilient to these
issues, this is an effective solution to guarantee conﬁdentiality.

C. Anonymity

Ring signatures grant anonymity, providing at the same
time the required authenticity guarantees. This solves the
problem of recognizing a ballot as valid without disclosing
the underlying voter identity, thanks to the fact that a ring
signature obfuscates the link between a signature and the
related signer.

On the blockchain interaction side, in Line 9 of Alg. 1
the voter directly calls a method of a smart contract that
causes a state change in the blockchain; unfortunately this
is not usually possible for several reasons. First, a voter
may not have enough storage or computation resources to
run a full or light blockchain client. This can be easily
overcome by sending transactions to a set of nodes acting
as mediators for the submission of end-users’ transactions. A
second, more relevant, issue is that a blockchain user must sign
his/her own transaction with a valid blockchain identity. The
word “valid” can have, in this case, two different meanings:
in a permissioned blockchain it means that the identity is
authorized to submit transactions, while in a permissionless
one it means that the identity has enough resources to create
an acceptable transaction. Neither condition pairs well with an
anonymous and scalable ballot submission. The former would
mean to identify the actual user behind the identity, so voiding
the linkable ring signature property. The latter would imply
the voter to procure by himself/herself the needed resources,
which is usually not scalable on a large non-technical voter
base. Moreover, the resource (cryptocurrency) procurement
should preserve anonymity. We present three ways to solve
this problem.

1) Anonymization Proxy: The anonymization proxy is a
component
that acts as a proxy between voters and the
blockchain. In practice it is responsible of taking valid votes,
packing them in transactions, and submitting them to the
blockchain. Multiple authorized anonymization proxies can be
provided to avoid a single point of failure and trust. Voters
can autonomously choose which (one or more) they prefer
and they can send the ballot without being identiﬁed. If they
require advanced anonymity guarantees, they can leverage any
anonymization technique for ordinary web interactions (e.g.
Onion routing). After the submission, they can easily check
that their operations have been effectively executed on the
blockchain, thanks to its transparency. On the Organizer’s
side this has advantages, since there is no need to ensure
write access to the blockchain to each voter, but only to
the authorized proxies, who can also pack ballots in less
transactions and optimize execution costs.

environment. This means that the application logic of the
voting system can be directly embedded in the transactions
semantics. Mapping to our case, it is possible to validate
the transactions of ballots’ submissions directly through the
attached linkable ring signature. The Tendermint SDK [5] is
an example framework on which such implementation could
be based.

3) Vote Token: There can be some scenarios in which
requiring a physical interaction is not a problem (i.e., a plenary
meeting of association members). In this case it is possible to
think of some vote token to be randomly pulled out of a box
by each voter, who can then use it to claim the resources
(cryptocurrency) necessary to submit a vote to the system,
using a throwaway address generated on the ﬂy. Furthermore,
tokens can be accumulated for future votes.

D. Scalability

The voting system should easily scale in the presence of
a large base of actors. In particular, the number of voters is
expected to be orders of magnitude higher than the number of
all the other participating entities.

Since scalability currently is a key issue in blockchain-based
systems, we take special care dealing with it and furthermore
compare our design with similar proposals. Our metric will be
in terms of required communication rounds (c), and read (r)
and write (w) operations on the blockchain for each Voting
Phase. When several information pieces are available to be
written/read, they are assumed to be accessed in a single opera-
tion. Among all possible deployment choices, we will consider
a setup similar to the two related works based on blockchain
[23, 22]: we assume to have M voters and to impose Ki on Ni
threshold mechanisms for voters identiﬁcation and Ke on Ne
secret sharing threshold for ballot encryption. Table II shows
a comparison with these two proposals [22, 23]. The former is
based on blind signatures and the latter, like ours, on linkable
ring signatures.

In the Registration Phase, voters must successfully identify
themselves with at least Ki different identity managers; so,
a voter has at least a communication round with each one of
them. Unlike [22], this process can be reused indeﬁnitely for
any subsequent voting session, even if not initially scheduled.
Any subsequent vote can directly start its protocol considering
this phase as already completed. This is really efﬁcient for
recurring votes with a great number of voters in common.

Then, voters read the ring of public keys and the encryption
key from the blockchain, and they submit their ballot along
with the ring signature; this translates into 1 read and 1 write
in the blockchain per voter. Providing conﬁdentiality through
the ETHDKG [27] protocol requires 2 rounds of interactions
by the Ne Conﬁdentiality Managers, in which each of them
has to write to the blockchain in both rounds (Encryption) in
order to publish the master public key. In the Tally Phase it is
enough that Ke Conﬁdentiality managers disclose their secrets
to decrypt ballots.

2) Application Speciﬁc Blockchain: An application speciﬁc
blockchain can be realised with an ad-hoc designed execution

For the vote claim solution of Section V-B, Conﬁdentiality
Managers are not required, and ballot encryption/decryption is

TABLE II
SUMMARY TABLE OF READS r AND WRITES w ON THE BLOCKCHAIN
GLOBALLY REQUIRED BY THE SYSTEM IN EACH PHASE IN c
COMMUNICATION ROUNDS. NOTE THAT M, Km ARE USUALLY MUCH
GREATER THAN Ne, Ke

Phase

Setup

Our Framework
c
w
1
1
Ki
2
1
1

r
-
-
Ne
M
-

Blind Sig. [22]

w
1

r
-

Not required
Not provided
2M Ki
1

2M Ki
-

r
-

c
1

Alt. LRS [23]
c
w
1
1
Not provided
2M M 2
2Ki M M 1
1

Km

1

-

Registration M Ki
2Ne
Encryption
M
Voting
Ke
Tally

completely eliminated at the cost of a second communication
round for the voter in the Tally Phase. In that case, Tally Phase
cost becomes M writes and no distributed key generation
protocol is required, avoiding the Encryption and Decryption
costs.

VI. PROPERTIES AND ADDITIONAL FEATURES

We now discuss relevant additional properties achieved by
our design, which include and extend those reported in [22].
For each one of them we provide an informal deﬁnition and
discuss why we are able to fulﬁll it.

1) Required properties: Required properties are those that
must be granted for any use case of the e-voting system, as
they encompass the minimal correctness and security prereq-
uisites needed for any application scenario:

a) Veriﬁability: The ID Storage (Alg. 5) and the Bal-
lot Box are implemented by smart contracts, leveraging the
blockchain capabilities. That is, each method invocation is
permanently stored in the system. All ballots remain saved
and publicly visible along with their attached linkable ring
signature. So, a voter, who knows which his/her own ballot is,
can verify the correctness of both the ballot submission and the
tally (Individual Veriﬁability). From the global system point
of view (Universal Veriﬁability), every entity can read the ID
Storage and verify the linkable ring signature, checking that all
saved ballots are legitimate. Finally, the saved result (Line 6
Alg. 2) can be veriﬁed through the secret key published by the
Conﬁdentiality Manager. The Organizer saves back the result
to the Ballot Box only as a convenience, since the secret key
for decryption is already public at that moment.

b) Legitimacy: Only those who have the right to vote
can take part in the voting process, and only for as long
as they’re granted to participate. The satisfaction of this
property is directly tied to the Identity Manager correctness.
That’s why a K out of N mechanism is recommended. Each
information in the ID Storage is provided by the (or K out
of N ) Identity Manager through signed transaction submitted
to the blockchain. The label, saved along with the public key
(Line 4, Alg. 5), acts as a public identiﬁer for each voter in
the list, so anyone who knows the list of allowed voters, can
check it against the registered one (e.g., in our deployment
in Section V, we set the label as the SHA256 of the voter’s
email). Beyond this, the linkable ring signature, paired with the
deterministic execution environment of the blockchain, ensures
that only identities registered in the ID Storage can create and

successfully submit valid ballots. In fact, signature veriﬁcation
is implemented in the Ballot Box smart contract, so double
votes are detected through the linkability and non-frameability
properties.

c) Completeness: All ballots are correctly interpreted
and vote accounting is accurate. In our design, when ballot
then the
secrecy is not required (but only anonymity is),
Tally Phase consists of a simple count function over publicly
available data. The same result is achieved with the vote claim
solution in Par. V-B3 after the redeem step. Note that in this
case there is the possibility that included ﬁngerprints (stored
along with the ring signatures) are not redeemed, resulting
in uncounted ballots. Depending on the use case,
this is
acceptable or not.

When using Conﬁdentiality Managers that cooperate by
leveraging ETHDKG [27], completeness is guaranteed if the
distributed key generation algorithm is correctly followed.
Tolerance to failures is analysed in Section V-B2.

d) Neutrality: The voting outcome cannot be inﬂuenced
neither by the voting process itself nor by the tools used
to vote. In the Conﬁdentiality Section V-B, we explain how
our design allows for the vote result to be hidden during
a voting session, in order to avoid inﬂuencing voters with
already accepted ballots.

e) Auditability: The whole voting procedure must be
auditable during and after the vote. In our case, this feature
is provided by the blockchain, which gives the abstraction
of an append-only register that allows auditing all methods’
invocations on the components implemented through smart
contracts (ID Storage, Ballot Box, Conﬁdentiality Manager).
f) Consistency: The voting result is the same for all
correct actors and stakeholders. Correct voters submit ballots
using the encoding rules deﬁned in the Ballot Box (Line 1
Alg. 6) smart contract. From the system point of view, the
deterministic execution layer of the blockchain, paired with
its consensus algorithm, ensures that all nodes execute trans-
actions in the exact same order, hence constructing exactly the
same system state for all involved smart contracts.

2) Information Security: Standard security properties, in
general referred as the CIA triad [16]: conﬁdentiality, integrity,
and availability. We will refer to data conﬁdentiality, data
integrity, system integrity, and availability as deﬁned in [17]
and brieﬂy comment on how our framework has been designed
to achieve them:

a) Data Conﬁdentiality: Data should not be disclosed to
system entities unless they have been authorized to access it.
In Section V-B we discussed about conﬁdentiality of ballots as
the possibility to not disclose them during the Voting Phase.
In respect to voters we also analysed a solution for their
anonymity in Section V-C beyond the mere theoretical usage
of the linkable ring signature.

b) Data Integrity: Data should not be changed, de-
stroyed, or lost in an unauthorized or accidental manner. As
long as the Byzantine fault tolerant consensus algorithm of
the blockchain remains valid, all the constraints coded in the
e-voting session smart contract are respected and no one can

tamper with them. Linkable ring signature veriﬁcation is coded
inside the Ballot box smart contract.

c) System Integrity: The system should perform its in-
tended function in a unimpaired manner, free from deliber-
ate or inadvertent unauthorized manipulation. Note that each
change in system state happens through signed transactions
that execute deterministic pieces of code. So any modiﬁcation
is authenticated and propagates the same changes to all nodes.
d) Availability: The system should be accessible, or
usable or operational upon demand, by an authorized system
entity, according to its performance speciﬁcations. Due to
the distributed nature of the blockchain, the system remains
available as long as the underlying consensus algorithm is
correctly run by a subset of nodes; the minimum number of
nodes in the subset is deﬁned by the blockchain.

Some issues with availability can arise when allowing ballot
replacement as a coercion countermeasure (see below). In fact,
since each legitimate signer would be allowed to submit as
many ballots as he/she wants, then all submitted ballots should
be accepted. The problem resides in the fact that creating
fake linkable ring signatures (by using random coefﬁcients)
is much more efﬁcient than verifying them. For this reason an
attacker could undermine the system’s availability by ﬂooding
it with many fake signatures. Anyway our approach based
on the anonymization proxy (Section V-C1) can apply known
Denial-of-Service countermeasures for protecting endpoints
while the vote token approach (Section V-C3), involving a
physical action for each submission, is a natural mitigation.

3) Additional Features: The following features can either
be required or not by different kinds of voting systems. Still,
it is desirable that a voting system is able to provide them.

a) Archive: Vote results should be stored with proved
integrity. Each blockchain node holds a complete copy of
data and history of operation on those data; thus integrity is
guaranteed by the blockchain.

b) Coercion resistance: The system should protect voters
from being deprived of their rights. In particular, it should
prevent:

• Simulation: it should not be possible to impersonate a

legitimate voter;

• Forced absence: voters may not be denied to vote;
• Coerced vote: voters may not be forced to vote in a

predeﬁned way.

For our design, we have that:
• Simulation: for this, an attacker should either steal the
private key of a voter after the vote phase started or
make the Identity Manager replace the key from the
right voter with his/her own public key. In the ﬁrst case
we assume that a voter is able to correctly store his/her
secret information; hardware tokens or trusted execution
environments can be useful for this purpose, too. For the
second case, a voter can detect that his/her public key is
wrong by directly checking on the blockchain, so he/she
can rerun the identiﬁcation process. Moreover, several
Identity Managers can be present, each one possibly

owning a different identiﬁcation process, making it even
harder for an attacker to succeed.

• Forced absence: access to the blockchain is assumed
ubiquitous. Moreover, voting steps can be automated
using scripts; thus users may prepare votes and set up
thier submission for a speciﬁc (later) time. Anonymity
of the linkable ring signature ensures a voter that no one
can link back to the ballot he/she submitted. Finally, non-
framability does not allow any adversary, even if formed
by a collusion of other legitimate signers, to deny vote
of a honest user by forging his/her link tag T .

• Coerced vote: voters may be enabled to submit valid
ballots an undeﬁned number of times, as linkability tags
allow for enforcing subsequent ballots to overwrite previ-
ous ones. Moreover voters may schedule some automatic
vote submission right before the Voting Phase deadline.
Anyway, we consider this workaround only a mitigation,
since this legitimate double ballot submission can be
easily detected by a coercer, given the auditability of the
blockchain system, if he/she was able to take note of the
linkability tag submitted by the coerced voter.

VII. IMPLEMENTATION

We validate the feasibility of our proposal with a working
implementation. Ring signatures and the blockchain are points
of paramount importance, so our proof of concept implemen-
tation mainly focuses on them.

A. Smart Contract

The most natural choice for rapidly prototyping a working
concept based on a blockchain is to rely on the Ethereum
ecosystem of software. The ID Storage and the Ballot Box are
implemented in a single smart contract that stores the voting
session state, voters information, and ballot data. The smart
contract also implements linkable ring signature veriﬁcation,
so only ballots with valid signatures are actually stored.
Signature algorithms reside in a separate library so they can
be reused across different deployments of the system. The
Organizer, Conﬁdentiality Managers and Identity Managers
appear with their Ethereum addresses, they can hence be either
individuals or other smart contracts like in the case of [27].

B. Signature Algorithm

The signature scheme described in Section III-A has been
implemented in Solidity within the Ballot Box leveraging the
BN256 curve since the Ethereum Virtual Machine has opcodes
for the sum and multiplication on it. [10].3).

Moreover, in our schema, the public keys hash gets com-
puted cumulatively at at each new added public key. This
particularly suits the blockchain environment since the com-
putation is spread across multiple transactions.

3With an application-speciﬁc blockchain there would not have been any
constraint in reference to this, indeed the execution layer may be customized
as needed.

C. Proof of concept

We implemented the whole voting process by providing
scripts to accomplish each phase we described for each in-
volved actor. Conﬁdentiality is provided through the ETHDKG
[27] smart contract. The codebase [25] is in Python, except
for the smart contracts that are written in Solidity, the smart
contract oriented programming language of the Ethereum
blockchain.

The scripts can target any Web3 (the Ethereum standard
RPC interface) compliant node. We also provide a ready-to-
go testnet through a Docker container.

D. Real deployment

Our voting framework has been successfully deployed and
used in the elections of university ofﬁcers. The three distinct
elections involved 428 total voters with a participation of 408
voters in the registration phase, and 398 in the voting phase.
Although we are going to produce and publish a full report
of this ﬁrst use of the system (and of the subsequent already
scheduled ones), we think it is worth citing here the main
characteristics of the event:

• The overall architecture was made of a blockchain, a
blockchain explorer, a web server acting as Identity
Manager, a web server acting as anonymization proxy
for vote submission, an administration portal and a web
application for voters to interact with the system.

• The signature algorithm has been implemented in plain
Javascript to compute the signature in a common browser.
• Voters generated a Voting Card locally in their browser.
The Voting Card included a keypair,
the voter email
and a signature of the email, as a string, using the
generated keypair. The secret key was encrypted with
a password and the public key was sent to the Identity
Manager. The identity was veriﬁed by integrating our
system with the university ones through SAML 2.0.
Voters then downloaded the Voting Card from the browser
in order to store it on their device.

• We deployed a permissioned blockchain with Hyper-
ledger Besu that is fully Ethereum compliant. We ran
4 nodes with the Istanbul Byzantine Fault Tolerant con-
sensus algorithm [18] (a tweak of [7]). Each node was
deployed and administered by a distinct entity.

• During the voting phase, voters selected their chosen can-
didate, uploaded the Voting Card to the browser and in-
serted the password to decrypt the secret key. The browser
computed the linkable ring signature and encrypted the
ballot choice, and sent both to the anonymization proxy
that redirected the signature and ballot to the blockchain.
The transaction hash and a link to the blockchain explorer
was given back to the voter as receipt.

• We did not integrate the Ethereum DKG[27], yet, so the
administration portal generated an RSA key pair and pub-
lished the public key to the Ballot Box. Once the voting
phase was over, the members of the electoral committee
requested ballots decryption on the administration portal.

Decryption was computed as soon as all the members of
the committee asked the decryption with their personal
accounts.

VIII. CONCLUSION

The presented framework leverages the blockchain and link-
able ring signature capabilities to create a comprehensive solu-
tion for e-voting in a wide range of scenarios. We show how
our design can address the requirements of a voting system
and provide a collection of additional features. In particular
our proposal ﬁts voting scenarios where coercion resistance
and receipt freeness are not a key concern. Indeed, our system
cannot be considered receipt-free because of its individual
veriﬁability property. Moreover, even though simulation and
forced absence are to some extent prevented, coercions are not
fully remedied, since a fully remote workﬂow can’t prevent a
voter to be physically conditioned.

Our plan is to integrate the Ethereum DKG to guarantee
conﬁdentiality and neutrality to the platform, and to make
a step further in the scalability of the framework, by acco-
modating the system to support a larger number of voters
(thousands). This,
in particular, will allow us to tune up
deployment choices for different election scenarios.

IX. ACKNOWLEDGEMENT

We are grateful

to Javier Herranz for

fruitful discus-
sions and pointers to relevant
literature on ring signa-
ture schemes. This work is partially supported by the
NATO Science for Peace and Security program (grant
G5448), by the Spanish Ministerio de Ciencia e Innovaci´on
(MICINN) grant PID2019-109379RB-I00, and by the Re-
gional Government of Madrid (CM) grant EdgeData-CM
(P2018/TCS4499) cofounded by FSE & FEDER. This paper
is part of the R&D&I project PID2019-109805RB-I00 funded
by MCIN/AEI/10.13039/501100011033 (ECID).

REFERENCES

[1] Ben Adida. “Helios: Web-based Open-Audit Voting”.
In: Proceedings of the 17th USENIX Security Sympo-
sium. USENIX Association, 2008, pp. 335–348.
[2] Michael Backes et al. “Ring Signatures: Logarithmic-
Size, No Setup - from Standard Assumptions”. In: Ad-
vances in Cryptology - EUROCRYPT 2019. Vol. 11478.
LNCS. Springer, 2019, pp. 281–311.

[3] Mihir Bellare and Phillip Rogaway. “Random Oracles
Are Practical: A Paradigm for Designing Efﬁcient Pro-
tocols”. In: Proceedings of the 1st ACM Conference
on Computer and Communications Security. New York,
NY, USA: ACM, 1993, pp. 62–73. ISBN: 0897916298.
Josh Cohen Benaloh and Dwight Tuinstra. “Receipt-free
secret-ballot elections (extended abstract)”. In: Proceed-
ings of the Twenty-Sixth Annual ACM Symposium on
Theory of Computing. ACM, 1994, pp. 544–553.
[5] Ethan Buchman. “Tendermint: Byzantine fault tolerance

[4]

in the age of blockchains”. PhD thesis. 2016.

[6] Ran Canetti and Mayank Varia. “Decisional Difﬁe–
Hellman Problem”. In: Encyclopedia of Cryptography
and Security. Ed. by Henk C. A. van Tilborg and Sushil
Jajodia. Boston, MA: Springer US, 2011, pp. 316–319.
[7] Miguel Castro and Barbara Liskov. “Practical Byzan-
tine Fault Tolerance”. In: Proceedings of
the Third
USENIX Symposium on Operating Systems Design and
Implementation (OSDI). USENIX Association, 1999,
pp. 173–186.

[8] Nikos Chondros et al. “Distributed, end-to-end veriﬁ-
able, and privacy-preserving internet voting systems”.
In: Comput. Secur. 83 (2019), pp. 268–299. DOI: 10.
1016/j.cose.2019.03.001. URL: https://doi.org/10.1016/
j.cose.2019.03.001.

[9] V´eronique Cortier, Pierrick Gaudry, and St´ephane
Glondu. “Belenios: A Simple Private and Veriﬁable
Electronic Voting System”. In: Foundations of Security,
Protocols, and Equational Reasoning - Essays Dedi-
cated to Catherine A. Meadows. Vol. 11565. LNCS.
Springer, 2019, pp. 214–238.

[10] EIP-1108: Reduce alt bn128 precompile gas costs.
https : / / eips . ethereum . org / EIPS / eip - 1108. Accessed:
2021-04-13.

[11] Paul Feldman. “A Practical Scheme for Non-interactive
Veriﬁable Secret Sharing”. In: 28th Annual Symposium
on Foundations of Computer Science. IEEE Computer
Society, 1987, pp. 427–437.

mation Security and Privacy: 9th Australasian Confer-
ence, ACISP 2004. Vol. 3108. LNCS. Springer, 2004,
pp. 325–335.

[22] Yi Liu and Qi Wang. “An E-voting Protocol Based
on Blockchain”. In: IACR Cryptol. ePrint Arch. 2017
(2017), p. 1043.
Jiazhuo Lyu et al. “A Secure Decentralized Trustless
E-Voting System Based on Smart Contract”. In: Pro-
ceedings of TrustCom/BigDataSE 2019. IEEE, 2019,
pp. 570–577.

[23]

[24] Torben P. Pedersen. “A Threshold Cryptosystem with-
out a Trusted Party (Extended Abstract)”. In: Advances
in Cryptology - EUROCRYPT ’91. Vol. 547. LNCS.
Springer, 1991, pp. 522–526.

[25] Proof of concept Repository. https : / / github . com /
russanto/chirotonia poc. Accessed: 2021-08-01.
[26] Ronald L. Rivest, Adi Shamir, and Yael Tauman.
“How to Leak a Secret”. In: Advances in Cryptology
- ASIACRYPT 2001. Vol. 2248. LNCS. Springer, 2001,
pp. 552–565.

[27] Philipp Schindler et al. “ETHDKG: Distributed Key
Generation with Ethereum Smart Contracts”. In: IACR
Cryptol. ePrint Arch. 2019 (2019), p. 985.

[28] Adi Shamir. “How to Share a Secret”. In: Commun.

ACM 22.11 (1979), pp. 612–613.

[29] Nick Szabo. “Formalizing and Securing Relationships

on Public Networks”. In: First Monday 2.9 (1997).

[14]

[15]

[16]

[12] Shaﬁ Goldwasser, Silvio Micali, and Charles Rackoff.
“The Knowledge Complexity of Interactive Proof Sys-
tems”. In: SIAM J. Comput. 18.1 (1989), pp. 186–208.
[13] Darrel Hankerson, Alfred J. Menezes, and Scott Van-
stone. Guide to Elliptic Curve Cryptography. Berlin,
Heidelberg: Springer-Verlag, 2003. ISBN: 038795273X.
Javier Herranz. Some Digital Signature Schemes with
Collective Signers. Tesi Doctoral, UPC, 2005.
Javier Herranz and Germ´an S´aez. “Forking Lemmas for
Ring Signature Schemes”. In: Progress in Cryptology -
INDOCRYPT 2003. Vol. 2904. LNCS. Springer, 2003,
pp. 266–279.
Information technology — Security techniques — Infor-
mation security management systems — Overview and
vocabulary. https://www.iso.org/standard/73906.html.
Accessed: 2021-04-15.
Internet Security Glossary, Version 2. https://tools.ietf.
org/pdf/rfc4949.pdf. Accessed: 2021-04-13.
Istanbul Byzantine Fault Tolerance. https://github.com/
ethereum/EIPs/issues/650. Accessed: 2021-07-17.
[19] Leslie Lamport, Robert E. Shostak, and Marshall C.
Pease. “The Byzantine Generals Problem”. In: ACM
Trans. Program. Lang. Syst. 4.3 (1982), pp. 382–401.
Joseph K. Liu, Victor K. Wei, and Duncan S. Wong.
Linkable Spontaneous Anonymous Group Signature for
Ad Hoc Groups. 2004.
Joseph K. Liu, Victor K. Wei, and Duncan S. Wong.
“Linkable Spontaneous Anonymous Group Signature
for Ad Hoc Groups (Extended Abstract)”. In: Infor-

[18]

[17]

[20]

[21]

APPENDIX

A. Voting workﬂow diagrams

We report the sequence diagrams that summarize the voting
protocol following the algorithms in Section IV-B in order to
give an overall picture of the interactions among the actors of
the framework.

B. Security Deﬁnitions for Linkable Ring Signature Schemes

We start by providing formal deﬁnitions of the main security
notions for linkable ring signatures as deﬁned in Section II-B,
essentially following (often verbatimely) [2].

2

Deﬁnition

(Linkability):

=
(KeyGen, Sign, Verify, Link) be a linkable ring signature
scheme, and consider the following experiment ExpLRS−Link
involving a probabilistic polynomial time adversary A:

LRS

Let

1) A outputs n tuples of the form (pki, σi, mi, Ri), for
some n polynomial in (cid:96). At this, R1, . . . Rn and R∗ are
sets of public keys (of ﬁnite size polynomial in (cid:96)). Also,
it outputs a triplet (σ∗, m∗, R∗). Denote by PK the set
{pk1, . . . , pkn.}

2) The experiment outputs 1 if the following conditions

hold:

• For all i = 1, . . . , n it holds Ri ⊆ PK and also

R∗ ⊆ PK .

• For all i = 1, . . . , n both Verify(Ri, mi, σi) = 1

and Verify(R∗, m∗, σ∗) = 1

Fig. 1. Sequence diagram of the registration phase

Fig. 3. Sequence diagram of the voting phase

Fig. 2. Sequence diagram of the registration phase with multiple identity
managers and using certiﬁcates.

Fig. 4. Sequence diagram of the tally phase. The “Close vote” message can be
substituted by a blockchain automatic lock, coded in the “Ballot box” smart
contract.

i

all

• For
have
Link(σ∗, σi, m∗, mi) = 0

(cid:54)=
Link(σi, σj, mi, mj)

j

∈

{1, . . . , n} we
0
=
and

Otherwise, the experiment outputs 0.

We say LRS attains linkability if for every probabilistic poly-
nomial time adversary A, it holds that the above experiment
outputs 1 with negligible probability only.

3

Deﬁnition

(Anonymity):

=
(KeyGen, Sign, Verify, Link) be a linkable ring signature
scheme, and consider the following experiment ExpLRS−Anon
involving a probabilistic polynomial time adversary A and a
challenger C:

LRS

Let

1) On input

the security parameter (cid:96), C makes n step
by step executions of Keygen(1(cid:96)), for some n ∈ N
polynomial in (cid:96), and gets as output the corresponding
pairs(pki, ski), i = 1, . . . , n. Also, it stores the random
coins involved in each key-pair generation ri. Further,
it chooses a bit b ∈ {0, 1} uniformly at random. The
public veriﬁcation keys {pk1, . . . , pkn} are forwarded
to A.

2) A outputs a set of veriﬁcation keys U ⊆ {pk1, . . . , pkn}
0, pk∗
1 ∈
1 are forwarded

and two challenge veriﬁcation keys pk∗
{pk1, . . . , pkn} \ U. Both U and pk∗
to the challenger C.

0, pk∗

3) C sends ri, for each pki ∈ U to the adversary (we
thus assume the corresponding ski are known to the
adversary from this point on),

4) Now, A sets a subset R of public keys and interacts
with the challenger, acting as a signing oracle. At this
point, A queries (adaptively) for a polynomial number
of signatures, each on a message m of its choice and all
on input R and a veriﬁcation key pk from U, with the
constraint that pk ∈ {pk1, . . . , pkn} \ U. The challenger
C outputs:

• a bit chosen uniformly at random, if

|{pk∗

0, pk∗

1} ∩ R| = 1,

• Sign(sk, m, R) – where sk is the signing key

corresponding to pk – if pk /∈ {pk∗
b , m, R) if pk = pk∗
0,
1−b, m, R) if pk = pk∗
1.

• Sign(sk∗
• Sign(sk∗

0, pk∗

1},

5) A outputs a bit β. Now the challenger sets as output for

the experiment the bit 1 if β = b.

We say LRS attains anonymity if for every probabilistic poly-
nomial time adversary A, it holds that the above experiment
outputs 1 with negligible advantage only, where the advantage
is deﬁned as

AdvLRS−Anon(A) = |P r[(ExpLRS−Anon) = 1] − 1/2|.

4

Deﬁnition

(Non-Frameability):
=
(KeyGen, Sign, Verify, Link) be a linkable ring signature
scheme, and consider the following experiment ExpLRS−Frame
involving a probabilistic polynomial time adversary A and a
challenger C:

LRS

Let

• Phase - I

1) On input the security parameter (cid:96), C makes n step
by step executions of Keygen(1(cid:96)), for some n ∈ N
polynomial in (cid:96), and gets as output the correspond-
ing pairs (pki, ski), i = 1, . . . , n. Also, it stores the
random coins involved in each key-pair generation
ri. Further, it initializes a set C = ∅. The public
veriﬁcation keys {pk1, . . . , pkn} are forwarded to
A.

2) A makes a polynomial number of queries to C :

– Signing query (sign, pk, m, R), for a message
m and a set of public keys R. The challenger
C will check if pk ∈ R and,
if so, output
Sign(sk, m, R) where sk is the matching secret
key to pk. Otherwise, it outputs an error message
⊥ .

– Corruption query (corrupt, pk), for a public key
pk ∈ {pk1, . . . , pkn}. The challenger adds pk to
C and returns to A the nonce r involved in its
generation (for A may can be assumed to know
the corresponding secret key sk).

3) A outputs a triplet (R∗, m∗, σ∗).

• Phase - II

1) The challenger provides all random coins ri, i =
1, . . . , n to A (so now we may assume the adversary
holds all involved secret keys),
2) A outputs a triplet (R†, m†, σ†)
3) Now the challenger sets as output for the experiment
the bit 1 provided that the following conditions hold:
– Verify(R∗, m∗, σ∗) = Verify(R†, m†, σ†) = 1
(i.e., both signatures output by A are valid),
– R∗ ⊆ {pk1, . . . , pkn}, and for all i such that
pki ∈ R∗, it holds pki /∈ C (i.e., al veriﬁcation
keys in R∗ are from uncorrupted users),

– σ∗ was not part of the output of a signing query,
– Link(σ∗, σ†, m∗, m†) = 1.

Now, the scheme LRS attains non-framability provided that

5

Deﬁnition

ExpLRS−Frame((cid:96)) outputs 1 with negligible probability only.
(Unforgeability):

=
(KeyGen, Sign, Verify, Link) be a linkable ring signature
scheme, and consider the following experiment ExpLRS−Unf
involving a probabilistic polynomial time adversary A and a
challenger C:

LRS

Let

1) On input

the security parameter (cid:96), C makes n step
by step executions of Keygen(1(cid:96)), for some n ∈ N
polynomial in (cid:96), and gets as output the corresponding
pairs (pki, ski), i = 1, . . . , n. Also, it stores the random
coins involved in each key-pair generation ri. Further,
it initializes a set C = ∅. The public veriﬁcation keys
{pk1, . . . , pkn} are forwarded to A.

2) A makes a polynomial number of signing queries to C,

described as follows:

• Signing query (sign, i, m, R), for a message m, and
index i and a set of public keys R. The challenger

C will check if pki ∈ R and, if so, output σ =
Sign(ski, m, R) where ski is the matching secret
key to pki. Otherwise, it outputs an error message
⊥ .

• Corruption query (corrupt, pk), for a public key
pk ∈ {pk1, . . . , pkn}. The challenger adds pk to
C and returns to A the nonce r involved in its
generation (we shall assumme thus that sk is then
accessible to A).

3) A outputs a triplet (R∗, m∗, σ∗). Now ExpLRS−Unf out-

puts 1 provided that:

• R∗ ⊆ {pk1, . . . , pkn}
• A never made a signing query of

the form

(sign, ·, m∗, R∗)

• Verify(R∗, m∗, σ∗) = 1.

Now, the scheme LRS attains unforgeability provided that
ExpLRS−Frame((cid:96)) outputs 1 with negligible probability only.

C. Security Analysis of our Linkable Ring Signature Scheme

The linkable ring signature scheme we present in III-A
can be proven to fulﬁll all aforementioned security deﬁni-
tions (under the random oracle model, and with the suitable
assumptions on the underlying group). As we have noted,
it is essentially a particular case of the scheme presented
in [21], where the underlying cyclic group is taken from a
ECC scenario, and can thus the subsequent discussion can be
essentially derived from the analysis in [21, 20]. There are
however some differences in the related security deﬁnitions,
for we have followed above the more recent
terminology
from [2]. In particular, we here include non-framability in
the presence of colluding malicious signers as a desirable
property. Most importantly, following Backes et al., we allow
for corruptions in the unforgeability deﬁnition, which is not
considered in [21]. This is particularly relevant for our use
case; a collusion of malicious users of the system should
indeed not be able to produce a valid signature that can be
veriﬁed using a set of public keys from honest users.

Unforgeability. The following theorem proves the unforge-
ability of the proposed scheme.

Theorem 2: The ring signature scheme presented in III-A
attains unforgeability in the random oracle model and under
the DLOG assumption in the underlying cyclic group E =
(G).
PROOF. Let Adv(A) denote the advantage of the adversary
against the unforgeability experiment, i.e.

Adv(A) = P r[ExpLRS−Unf = 1]

We will structure the proof in a game-based fashion, namely,
we start with a game that mimmicks the real attack and end in
a game in which the adversary’s advantage is easily bounded,
and for which we can bound the difference in the adversary’s
advantage between any two consecutive games. Following
standard notation, we denote by Adv(A, Gi) the advantage
of the adversary A in Game i.

Game 0. This ﬁrst game corresponds to a real attack. By
deﬁnition, Adv(A, G0) = Adv(A).

Game 1. We now assume all involved hash functions behave
in an ideal manner; namely, the outputs of H, H2P , HPK are
assumed to be chosen uniformly at random in the appropriate
range for each new entry, which is stored in a corresponding
hash list so that subsequent queries are answered consis-
tently. Queries to these hash functions will be modelled as
queries to random oracles OH , O =H2P , OHPK . We make
explicit the so-called random oracle assumption by assuming
Adv(A, G1) = Adv(A, G0).
Game 2. Let us assume the Adv(A, G2) ≥ 1
p((cid:96)) , for some
polynomial p. Namely, A, on input a certain set of ring public
keys {pk1, . . . , pkn} it outputs a valid signature (R∗, m∗, σ∗)
with non-negligible probability. We will see how to construct
a machine S, a simulator using A as a subroutine which, on
input a DLOG instance on the group E (p, g, G, Y ) will output
in polynomial time a solution, i.e., x ∈ {1, . . . , g − 1} Y =
x · G.

At this, S must simulate the challenger from the ExpLRS−Unf

game for A. Lets see how to do this.

Following the strategy from Theorem 4.2.

in [14], we
deﬁne µ = ( 5
6 )QC , where QC is a bound on the number of
corrupt calls from A (and is indeed polynomial in the security
parameter). SHould one restrict to adversaries which may not
corrupt any user, then set µ = 0.

Our simulator S will creat a table CORR in the following
way: for each i = 1, . . . , n a key pair is set by choosing a bit
ci (as ci = 0 with probability µ and ci = 1 with probability
1 − µ):

• if ci = 0, S selects uniformly at random ski ∈

{1, . . . , g − 1} and sets pki = ski · G,

• if ci = 1, S selects uniformly at random alphai ∈

{1, . . . , g − 1} and sets pki = alphai · Y,

The entries (i, pki, ski, ci) are stored in the CORR ta-
ble. Now the attacker is presented with the public keys
pk1, . . . , pkn for running ExpLRS−Unf .

Now whenever A makes a query of the form (Corrupt, pki),
for i = 1, . . . , n, S looks up in the CORR table and, if ci = 1,
forwards the answer αi to A, halting however if ci = 1. Note
that the probability that S halts is thus 1 − µQC ≤ 1
6 .

Now,

assume

called with
each
i ∈ {pk1, . . . , pkn} and the attacker has not queried

the
(sign, i, m, {pk(cid:48)

S
1, . . . , pk(cid:48)
m})

simulator

where

is

query

a
pk(cid:48)
(Corrupt, pk(cid:48)

i).

Assuming the simulator is actually controlling the random
oracle H2H , it is clear that it may simply be simulated by
choosing, on a query X, a random values rX ∈ {1, . . . , g − 1}
and outputting the curve point rx · G. As a result, we may
assume the simulator actually holds r ∈ {1, . . . , g − 1} so that

L = H2H (HPK ((pk1, . . . , pkn)) = r · G.

Note then that for each i = 1, . . . , m, it holds r · pk(cid:48)
i · L,
from which S can compute the needed values for signing

i = sk(cid:48)

in spite of ignoring the corresponding secret keys (for by
construction, sk(cid:48)

ix, for some x such that Y = x · G).

i = α(cid:48)

Now, here is how S constructs an answer for the given

query:

1) S chooses at random an index π ∈ {1, . . . , m},
2) For each i ∈ {1, . . . m},chooses independently and uni-
formly at random si ∈ {1, . . . , g − 1} and c1, . . . , cm ∈
Fp

3) back-patch the random oracle so that for each i =

1, . . . , m it holds:
Ai = si · G + ci−1 · pk(cid:48)

i, Bi = si · r · pk(cid:48)

π + ci−1 · r · pk(cid:48)
π.

4) Set T = r · pk(cid:48)

π, output

σ = (pk(cid:48)

1, . . . , pk(cid:48)

m, T, s1, . . . , sm, c)

Note that now, as argued in [20] for the signature simu-
lations and considering the halting probability of S, not all
invocations of A will produce a successful forgery, yet it will
indeed do so with non negligible probability.

Furthermore, either mimicking the rationale from [20] or
relying on the so-called forking lemma for ring signatures as
introduced in [14], we conclude that as A is able to produce a
successfull forgery, he can be used by S to get two different
forgeries w.r.t. the same ring of users R = {pk(cid:48)
m},
on the same message, reusing the same random values inputs.

1, . . . , pk(cid:48)

Let the corresponding signatures be:

σ = (R, T, s1, . . . , sm, c),

with associated hashes c1, . . . , cn and

m, c∗)

σ∗ = (R, T ∗, s∗

with associated hashes c∗

1, . . . , s∗
1, . . . , c∗
m.
From the aforementioned forking lemma it yields that there
must be a value π ∈ {1, . . . , m} such that the corresponding
π and Bπ = B∗
cπ = c∗
π
thus, in particular,

π, and, as a result it must be Aπ = A∗

x =

π(c∗
α(cid:48)

(mod q),

π = A∗
π.

π−1 · pk(cid:48)

π · G + c∗

Aπ = sπ · G + cπ−1 · pk(cid:48)
π = α(cid:48)
Now as pk(cid:48)

π = s∗
π · Y we have
sπ − s∗
π
π−1 − cπ−1)
which fulﬁlls x · G = Y. Summing up, S is able to output thus
the solution x as above with non negligible probability, so the
(cid:3)
desired result is proven.
Linkability. Informally, it is easy to see why the scheme from
Section III-A is unlinkable; indeed, to construct two correct
signatures linking to different users is to actually have their
private keys, so the hardness of DLOG should prevent an
adversary from breaking linkability. More formally, Liu et al.
state in Theorem 3 of [20] an analagous of the result we prove
below (essentially adapting their rationale):

Theorem 3: The ring signature scheme presented in III-A
attains linkability in the random oracle model and under the
DLOG assumption in the underlying cyclic group E = (G).

PROOF. Let Adv(A) denote the advantage of the adversary
against the linkability experiment, i.e.

Adv(A) = P r[ExpLRS−Link = 1]

Once again, we will structure the proof in a game-based
fashion and denote by Adv(A, Gi) the advantage of the
adversary A in Game i.

Game 0. This ﬁrst game corresponds to a real attack. By
deﬁnition, Adv(A, G0) = Adv(A).

Game 1. Again, we assume the involved hash functions
behave in an ideal manner; their queries will thus be modelled
as queries to random oracles OH , O =H2P , OHPK . The
random oracle assumption is thus made explicit by assuming
Adv(A, G1) = Adv(A, G0).

Now we can argue that Adv(A, G1) is bounded by the
probability of success of A in solving DLOG in E, just as
it is done in the proof of Theorem 3 from [21]. Indeed, let us
deﬁne a simulator S which will compute the DLOG of one
of the public keys {pk1, . . . , pkn} involved in the linkability
experiment ExpLRS−Link. We will again make use of a so-called
forking argument. Indeed, our simulator S interacts with A in
the linkability experiment, and so A succeeds by outputting a
pair of signatures σi, σj which are not linked and for which A
only was initially given one corresponding secret key (either
ski or skj). Let σ and σ(cid:48) be the mentioned signatures, and T
and T (cid:48) be the corresponding linkability tags (namely, of the
form ski · L and skk · L(cid:48) (note that the signatures may not be
veriﬁable with the same set of public keys, yet both the ring of
users corresponding to σ and the ring of users corresponding
to σ(cid:48) have public keys contained in pk1, . . . , pkn. It is easy
to see that, with non-negligible probability, σ and σ(cid:48) may
correspond to two different public keys π and π(cid:48) (see the
argument contained in the proof of Theorem 3 from [21]).

As a result, using the forking lemma twice (once for σ,
second time for σ(cid:48)) it follows that A can, by the forking
lemma for ring signatures (see [15, 14]), produce four different
forgeries: - two for the same set of public keys related to σ -
two for the same set of public keys related to σ(cid:48).

As a result, by the same argument used in the proof of
unforgeability above, A can both retrieve skπ and skpi(cid:48); given
that, by assumption, only one of these secret keys was already
known to A, to the adversary has indeed been able to solve
(cid:3)
DLOG for one of the public keys in {pk1, . . . , pkn}.

Anonymity. The following result can be attained following Liu
et al.s rationale from Theorem 2. As we are using a different
deﬁnition we include a sketch the proof below, which is a
straightforward adaptation of the one that can be found in [20].
Theorem 4: The ring signature scheme presented in III-A
attains anonymity in the random oracle model and under the
DDH assumption in the underlying cyclic group E = (G).
PROOF.
adversary against the anonymity experiment, i.e.

(sketch) Let Adv(A) denote the advantage of the

Adv(A) = P r[ExpLRS−Anon = 1]

Once again we structure the proof in a game-based fashion,
and we denote by Adv(A, Gi) the advantage of the adversary
A in Game i.

Game 0. This ﬁrst game corresponds to a real attack. By
deﬁnition, Adv(A, G0) = Adv(A).
Game 1. All involved hash functions are assumed to behave in
an ideal manner;as before, by the random oracle assumption,
that Adv(A, G1) = Adv(A, G0). Now we can argue that
Adv(A, G1) is bounded by the probability of success of A in
solving DDH in E. The main idea behind this argumentation
is that a polynomial time distinguisher D for the DDH in E
can be construced from a succesful adversary A winning the
anonymity game from Deﬁnition 3.

Let D be a probabilistic polynomial time algorithm that gets
as input a triplet (α, β, γ) ∈ E3, so that there exist uniformly
at random values a, b, c ∈ {1, . . . , g − 1} such that either α =
a · G, β = b · G and γ = c · G or α = a · G, β = b · G and
γ = ab · G. Our goal is to prove that D, using a successful
linkability adversary A, is able to distinguish (with probability
non-negligibly above 1
2 ) which is the case. Let then D act as
an anonymity challenger for A as follows:

1) D initially sets pkπ = α, and selects pki for i (cid:54)=
π choosing uniformly at random secret keys ski ∈
{1, . . . , g − 1},

2) for i = π, ..., n, 1, . . . , π − 1, D selects random si ∈

{1, . . . , g − 1} and sets

ci+1 = H(m||Ai||Bi)

with Ai, Bi computed as in the protocol speciﬁcation
form the above known values but ﬁxing (as D ignores
the secret key skπ) the values T = γ and back-patching
on the random oracle on L, i.e., ﬁxing L = β.

3) D outputs a signature

σ = (pk1, . . . , pkn, T, s1, . . . , sn, cn).

PROOF. Out main argument is that for ExpLRS−Frame to output
1, A must have actually forged a signature under one of the
public veriﬁcation keys presented by the challenger. Indeed,
notice that in Step 3 of Phase-1 of ExpLRS−Frame the adversary
A must output a triplet (R∗, m∗, σ∗) from identical inputs to
those presented in an execution of ExpLRS−Unf , i.e. :

1) On input the security parameter (cid:96), the challenger C
makes n step by step executions of Keygen(1(cid:96)), for
some n ∈ N polynomial
in (cid:96), and gets as output
the corresponding pairs (pki, ski), i = 1, . . . , n. Also,
it stores the random coins involved in each key-pair
generation ri. Further, it initializes a set C = ∅. The
public veriﬁcation keys {pk1, . . . , pkn} are forwarded
to A.

2) A makes a polynomial number of queries to C:

• Signing query (sign, pk, m, R), for a message m
and a set of public keys R. The challenger C will
check if pk ∈ {pk1, . . . , pkn} and, if so, output
Sign(sk, m, R) where sk is the matching secret key
to pk. Otherwise, it outputs an error message ⊥ .
• Corruption query (corrupt, pk), for a public key
pk ∈ {pk1, . . . , pkn}. Now C adds pk to C and
returns to A the corresponding secret key sk.

3) A outputs a triplet (R∗, m∗, σ∗).
Indeed, now the triplet (R∗, m∗, σ∗) is a winning triplet in

ExpLRS−Unf , for

• Verify(R∗, m∗, σ∗) = 1
• R∗ ⊆ {pk1, . . . , pkn} \ C (i.e., al veriﬁcation keys in R∗

are from uncorrupted users),

• σ∗ was not part of the output of a signing query.

Thus, non-framability is derived directly from unforgeability,
and so if follows from the DLOG assumption in the underlying
(cid:3)
cyclic group E = (G).

Now in the simulation D calls A with the corresponding
challenge and simulates the random oracles for him faithfully
(except for the query L and queries involved in the above
construction of the c(cid:48)

is, where consistency is mantained).

Now, suppose A outputs, after interacting with D, a bit ˆb.
Indeed, D will output 1 if indeed ˆb is a pointer to π. Clearly,
if the input triplet (α, β, γ) is not a Difﬁe-Hellman triplet,
all signers will be identical for A and thus its advantage is
exactly 1
2 . However, if the given triplet is indeed a Difﬁe-
Hellman triplet, A will have a non-negligible advantage, and
so will, by a simple probability argument, have D in solving
(cid:3)
the corresponding DDH instance.
Non-Framability. Intuitively, it is easy to see that an adver-
sary violating non-framability must indeed have succeeded
in a forging challenge, so non-framability is obtained from
unforgeability.

Theorem 5: The ring signature scheme presented in III-A
achieves non-framability in the random oracle model and
under the DLOG assumption in the underlying cyclic group
E = (G).

