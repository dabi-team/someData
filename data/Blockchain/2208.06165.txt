1

Customer Empowered Privacy-Preserving Secure
Veriﬁcation using Decentralized Identiﬁer and
Veriﬁable Credentials For Product Delivery Using
Robots

Chintan Patel, Member, IEEE

2
2
0
2

g
u
A
2
1

]

R
C
.
s
c
[

1
v
5
6
1
6
0
.
8
0
2
2
:
v
i
X
r
a

Abstract—In the age of respiratory illnesses like COVID-19,
we understand the necessity for a robot-based delivery system
to ensure safe and contact-free courier delivery. A blockchain-
based Dynamic IDentiﬁer (DID) gives people total power over
their identities while preserving auditability and anonymity. A
human mobile phone and a robot are machines created with a
chip, making it simple to deploy a physical unclonable function-
based veriﬁcation system between the robot and the customer.
This article presents a novel framework and a ﬁrst customer
veriﬁcation scheme for veriﬁed courier delivery utilizing the
blockchain-enabled DID and PUF-enabled robots. We employ
DID for customer authentication between a robot (a service
provider) and a customer and PUF for robot veriﬁcation by the
customer. We’ve also put the proposed work into practice and
demonstrated its capabilities in terms of throughput, latency,
computing cost, and communication cost. We also show formal
security proof for the proposed user veriﬁcation scheme based
on the tamarin prover.

Index Terms—Dynamic Identities, Robot Based Delivery Sys-
tem, Authentication, Physical Unclonable Function, Blockchain.

I. INTRODUCTION

The Robot-based product delivery is the future of the home
delivery system [1]. Nowadays, many big companies such
as Amazon and kiwibot started to deliver a product using
the robot. Amazon uses a six-wheeled robot named Amazon
Scout to deliver a product. These all the robots are electric
and help a lot in the UN’s movement toward net-zero carbon
emission by 2050. The robot-based delivery also achieves
contactless product delivery that can help the world recover
from pandemics such as COVID-19.

For successful product delivery using a robot, veriﬁcation
of robot by customer and veriﬁcation of customer by robot
is a need of today. Most of the existing robot-based delivery
companies use biometrics as a security veriﬁcation factor or
PIN as a veriﬁcation factor. In a biometric-based veriﬁcation
system, a customer can not assign a product delivery to their
friend or neighbour, while in the PIN-based delivery system,
if the customer forgets a PIN or doesn’t receive OTP on time,
then it can lead to delivery failure.

Protecting customer privacy is also a big challenge for e-
commerce companies. Any Man-In-The-Middle (MITM) can

Chintan Patel is a Postdoctoral Researcher with the Department of Com-

puter Science, University of Shefﬁeld, UK.
E-mail: chintan.p592@gmail.com

sometimes trace the customer purchase pattern and customer
purchase details. In 2021, 14 million amazon and eBay cus-
tomer purchase data were leaked, which is a big concern
for customer privacy. The only solution for this privacy and
tracing problem is self-sovereign identity (SSI) and the use of
a Decentralized Identiﬁer (DID) as an identity of the customer
that is generated new whenever the customer orders a product
and is securely veriﬁable through the centralized registry such
as blockchain.

In this paper, we propose a novel (to the best of our
knowledge ﬁrst) solution with a novel DID-based framework
for customer veriﬁcation. We use DID as an identiﬁer for
customer identiﬁcation and Physically Unclonable Function
(PUF) for robot veriﬁcation. Section 2 discusses the back-
ground and prelude related to the proposed work, followed by
contributed work in section 3. Section 4 provides the security
veriﬁcation for the proposed work using the tamarin prover and
key security properties. Section 5 discusses the experimental
study with a key performance analysis matrix, followed by a
conclusion and open challenges in section 6.

A. Related Work

During the COVID-19 pandemic, contactless delivery has
proven to be one of the most dependable methods for enabling
social isolation and protecting sensitive groups. So, there are
two possible approaches for this: The ﬁrst one is drone-
based delivery, and the second one is robot-based delivery.
In this paper, we focus on the robot-based delivery of the
product, and the proposed work can also apply to drone-
based product delivery. In 2021, starship achieved 1 million
autonomous deliveries using the robot. The tiny mile started
to deliver products using robots in the Toronto area in 2019.
In 2017, kiwibot achieved more than one lakh robot-based
deliveries. So many other companies focus on robot-based
delivery systems and future product delivery. Now a days, e-
commerce customer uses same identity and password based
mechanism that
leads to several critical and fundamental
security problems such as tracebility, password theft, wasting
time if password loss and so many others. There is a strong
need to design a user empowered system for e-commerce
industry where for each new order, customer generates new
identity by self and get validated.

The ﬁrst paper directly related to securing a robot-based
delivery system was proposed in 2021 by Wang et al. In this

 
 
 
 
 
 
paper author uses artiﬁcial intelligence for authenticating the
user. In 2022, Yang et al. proposed a customer authentication
scheme using QR codes and asymmetric encryption. The
author focuses on customer veriﬁcation using biometric, QR
code and PIN code technologies in the above-proposed work.
Authors in [1] don’t focus on the security of complete e-
commerce activity where the customer orders a product and
the customer receives a product and it lacks from securing
signiﬁcant operations of product delivery. They use the same
id each time for customer veriﬁcation, leading to traceability
and privacy problems also.

In 2019, Kortesniemi et al. [2] presented an idea for
improving privacy in the IoT ecosystem using DID. In 2020,
Fedrecheski [3] presented beneﬁts and challenges related to
self-sovereign identities for IoT environment and highlighted
that DID resolution is a key challenge for constraint devices.
In 2021, Samir et al. [4] presented a DID-based identity
management framework with an authentication and integrity
validation system for externally stored identities without the
need for disclosing information related to identities. In 2022,
Rohini et al. [5] presented the ﬁrst key exchange protocol for
EV charging based on DID and claimed that the proposed
protocol achieves privacy, accountability, anonymity and au-
thentication. Even though, there are several proposal for DID
based authentication, To the best of our knowledge, this is the
ﬁrst DID-based customer veriﬁcation scheme with physically
unclonable function enabled robot-based product delivery in
e-commerce services.

B. Motivation

In COVID - 19, people realize the need for a contactless
delivery system, and robots can play a pivotal role in this work
with their coequals, drones. The robot-based delivery system
should ensure veriﬁcation of both customers and the robot
so that the robot can get assurance that the receiving person
is the same who has ordered a product. At the same time,
the customer must ensure that the robot from whom they are
receiving a courier is a robot of the same company on which
they have placed the order. Nowadays, most e-commerce
companies use a centralized approach where customers must
register their identities with trusted servers. There is a high
probability that customers may lose their privacy if outsiders
or insiders compromise this trusted server. To the best of our
knowledge, this is the ﬁrst work focusing on robot veriﬁcation
based on PUF. A PUF ensures unique randomness during ver-
iﬁcation through challenge-response pairs, leading to secured
veriﬁcation of chip-based machines. In the proposed work,
DID stored in a permissioned blockchain solves numerous
critical problems for customer identity, authentication, and
centralized systems. At the same time, PUF enables secured
veriﬁcation of delivery robots by customers for any robot.

C. Contributions

This paper’s signiﬁcant contributions include:
• A novel
system.

framework for robot based product delivery

2

• A ﬁrst threat model with DID access capabilities to the

adversaries.

• A ﬁrst DID based privacy preserving customer veriﬁca-

tion scheme.

• A ﬁrst PUF based non deniable robot veriﬁcation scheme

for e-commerce industry.

• A rigorous Formal and Informal security analysis of
the proposed work using tamrin prover and security
properties respectively.

• A realtime experimental outcomes and performance anal-

ysis.

In the proposed scheme, the robot requires much less storage
(just one public key), less computation (just one signature ver-
iﬁcation and one encryption), and a very low communication
overhead. To the best of our knowledge, this is the foremost
work presented in this future-oriented research direction.

II. BACKGROUND AND PRELUDE

In this section, we discuss basic preludes used and consid-

ered for designing of the proposed work.

A. Decentralized Identiﬁer

a

(DID)

[6] provides

Decentralized Identiﬁer

self-
sovereignty to customers about their identities. Compared to
a traditional approach in which customers can have unique
identities, customers can have multiple identities and use those
identities to escape from tracing by the intruder. We use
the blockchain to store the DID documents in the proposed
framework. These DID documents contain the mapping be-
tween DID and related metadata (e.g., order detail in the
proposed framework). In the DID, there are holder, veriﬁer and
issuer entities. Trusted Issuer will issue veriﬁable credentials
to holder and holder will present his/her DID and veriﬁable
credential to the veriﬁer. The veriﬁer will retrieve the DID
document from the ledger and verify the veriﬁcation creden-
tials. In the proposed scheme, we consider the government
signed certiﬁcate as a veriﬁable credentials that proves name
and birth date of the customer. Here government is trusted
party and whose public key is available publicly for signature
veriﬁcation. Figure 1 shows resolved DID document generated
during customer veriﬁcation phase. DID resolution involves
three major entities: 1. Issuer (government here) who issues
veriﬁable credentials and writes those credentials to the ver-
iﬁable data registry. 2. Veriﬁer (service provider here) who
veriﬁes the veriﬁable presentation sent by the customer. And
3. Holder (customer here) who receives veriﬁable credentials
from different issuers and generates a veriﬁable presentation
from those veriﬁable credentials based on the need of a
veriﬁer. Here customer decides which veriﬁable credentials
are sufﬁcient to show to the veriﬁer. That’s why DID is called
Self-Sovereign Identity (SSI) also.

In the proposed scheme, the customer stores its DID with
order details in the DID document and registers these DID
documents to the permissioned blockchain by executing the
smart contract. A service enabler (e.g., the company’s ser-
vice provider server) in the proposed work needs to resolve
DID requests by accessing DID documents. Access to DID

3

have used raspberry pi for experimental purpose) that provides
unique challenge response pair. We consider that company
who provides service to the customer stores thousands of these
unique challenge-response pair for their robots and whenever
customer orders the product, it randomly selects one challenge
from the database (of robot who is going to provide service)
into customer mobile. Algorithm 1 presents
and store it
steps of PUF based veriﬁcation of robot (a.w.a customer also
partially) in the intelligent robotic delivery system. In this
paper, we haven’t consider that if robot is changed after order
and before delivery. Solution to this we can consider as a
future work.

Algorithm 1 : PUF Challenge Response Working

1: Manufacturer generates Challenge Response Pair (CRP),
2: Manufacturer securely store CRP database into cloud data

base of Service Provider,

3: Service Provider Randomly selects challenge and store in

to customer mobile device,

4: customer sends same challenge to the robot and receive

the response,

5: customer generates veriﬁcation request to service provider

with signed responce

6: Service provider veriﬁes challenge (send by customer) -

Response pair (send by robot to customer).

7: Service provider sends signed response to the customer

with valid (0) or invalid (1).

D. Elliptic Curve Difﬁe Hellman Key Exchange and Signature
Veriﬁcation

Elliptic Curve Cryptography (ECC) is a public key cryp-
tography technique that provides equal security to Rivest-
Shamir-Adleman (RSA) algorithm with very low computation
complexity compare to it. In the proposed scheme, we use
ECC to generate a public key and private key pairs of different
entities involved in the proposed framework. With the help of
Difﬁe hellman key exchange, entities share their keys securely
[7]. In the proposed scheme, entities use the ECC generated
public key for encryption purposes and the private key for
signature purposes. An ECC based signature generation and
veriﬁcation enables us to implement the proposed scheme in
any resource constraint devices. The algorithm 2 and algorithm
3 presents signature generation and signature veriﬁcation steps
using ECC.

Algorithm 2 : ECC Signature Generation by Signer

1: Compute eh = SIPh(message),
2: Generate kr where 1 ≤ k ≤ N,
3: Compute Gp(Xi,Yi)=kr * G, G is base point.
4: Compute ri = Xi (mod N).
5: Compute si = (k−1

r )(hi + ri ∗ dA) (mod N). dA is signer’s

secret key, hi is the ﬁxed length left most bits of eh.

6: Sign = (ri,si)

Fig. 1. Resolved DID Document

documents can be only possible when the service provider
server presents the customer’s request (containing DID signed
by their private key with valid metadata) to the blockchain
administrator. With the help of blockchain-enabled DID, we
can achieve non-traceability, dynamicity, tamper-proof data
storage, and full control of their own identity to the customer.
Zero Knowledge Proof (ZKP) allows an entity to validate the
truth of a statement without revealing any more information
about the argument. With the help of ZKP, customer can
present his/her VC to veriﬁer with preserving the privacy of
other details.

B. Blockchain

A blockchain is a publicly distributed ledger that contains
hash-connected blocks. Each block provides a tamper-proof
environment to store the DID documents. With the help of
permissioned blockchain, we can achieve decentralization,
immutability, auditability, restricted access, traceable log gen-
eration and transparency. All nodes in a blockchain execute
customer-deﬁned functions called a smart contract to store the
data. There are two types of blockchain that exists. One is
permissioned (or private), and the other is a permissionless
(or public) blockchain. Examples of permissioned blockchain
include L3COS, Hyperledger fabric, Quorum, and R3, while
Bitcoin and Ethereum are famous permissionless blockchain
applications. In the proposed framework, we use a permis-
sioned blockchain that the company’s blockchain administrator
maintains, and it has restricted access between the company’s
customer (who can store the DID) and the company’s service
provider server (who can resolve the DID into DID document)
for veriﬁcation purpose.

C. Physically Unclonable Function

Physically Unclonable Function (a.c.a. PUF) is widely
adopted hardware security approach for veriﬁcation of de-
vices. PUF works based on a consideration the each identical
hardware chip produced by manufacturer provides a unique
response to each challenge presented to it. PUF is proved
unclonable, unpredictable and random function that
takes
challenge as input and provides device dependent response.
Over the same PUF, if two device receives same challenge C
and those devices generate responses R1 and R2 respectively,
then it is always true that R1 (cid:54)= R2.

In the proposed scheme, company uses robot to deliver
the product and each robot contains a hardware chip (we

Algorithm 3 : ECC Signature Veriﬁcation by Veriﬁer

1: Compute eh = SIPh(message),
2: Compute ch = s−1,
3: Compute ui = hi * ch (mod N),
4: Compute uj = ri * ch (mod N),
5: Compute Gp(Xi,Yi) = ui * G + uj * QA. Here QA is

public key of signer.

6: Return invalid if Gp(Xi,Yi) = 0
7: Return valid if ri = Xi (mod N), else invalid

E. SIPHash : A Key based Hash Function

A hash function conducts a one-way calculation on a piece
of data, resulting in a series of bytes that, one believes,
is entirely unpredictable and cannot be employed to deduce
the original data. SIPHash was proposed by Jean-Philippe
Aumasson and Daniel J. Bernstein that is key-based hash
function and signiﬁcantly faster than other hash functions. It
is also proven to be secured against hash-collision attacks
and other attacks over hash functions. For agreed 128 bit
key Ki between customer Ui and Uj and message M1, Ui
generates 64 bit message authentication code (MAC) SIPHash
as SIPh(M1, Ki). SIPHash assures that, having M1 and
SIPh(M1, Ki), an attacker who is unaware of Ki cannot
compute Ki or SIPh(M2, Ki) any message M2 /∈ M1.
We have used SIPHash for computation time optimization
in hash computations and to achieve collision resistance as
well as unforgeability. Readers can also use one way hash
functions such as SHA-256 in place of SipHash based on their
application.

III. CONTRIBUTED WORK

In this section, we present a detailed discussion of our
contribution. First, we discuss a novel proposed framework
in which we present a novel DID-based framework to verify
a customer-based self-sovereign identity generated/controlled
customers themselves. And later, We discuss threat model to
the contributed work. Next, we discuss the customer veriﬁca-
tion approach in which the robot will get assurance that the
receiving customer is a customer of the company. We discuss
the robot veriﬁcation approach in which customers will get
assurance that the robot delivering a product is the same robot
sent by a company.

A. Proposed Framework

Decentralized Identiﬁer (DID) is a future of identity deriva-
tion for the billions of customers and devices. DID involves
numerous methods based on customer requirements and the
central registry used. DID empowers customers to create and
control their own identity, which is neither centralized nor
revocable. As shown in Fig. 2, we propose a DID-based frame-
work for customer veriﬁcation for the e-commerce company.
To the best of our knowledge and analysis, this framework is
highly applicable in many other services where the customer
is empowered for its own identity, and the service providers
want to verify the customer based on that identity. Veriﬁable
Credentials (VC) are used for creating a trust-building among

4

holder/customer and veriﬁer/service provider. customers can
receive multiple VCs from numerous issuers (i.e., government,
university, etc.), and based on the requirement of the service
provider, and use generates Veriﬁable Presentation (VP) from
VCs and forwards VP to the service provider for veriﬁcation.
The service provider veriﬁes the VP based on the issuer’s
signature on each VC.

Fig. 2. Proposed DID Framework

The proposed framework consists of seven basic steps from
DID creation to DID and VC veriﬁcation by the e-commerce
service provider. We consider permissioned blockchain man-
aged by the company’s Blockchain Administrator (BA) in the
proposed framework. This blockchain is accessible only by
the registered customer and the company’s authorized entities,
such as the service provider. The most important advantage
of using permissioned blockchain is that the BA only allows
veriﬁed issuers to register their DID and completely secures
system from fake issuers and fake VC attacks in DID. The
proposed framework consists of following steps :

1) Customer creates a DID (step 1) with hashed value of
order details and stores this DID in to permissioned
blockchain of the company (step 2).

2) Now, customer presents signed DID (using own private
key) and signed VCs (signed using issuer’s (i.e. gov-
ernment agency’s) private key) to the company’s service
provider server (step 3).

3) Company’s service provider starts DID veriﬁcation
phase and provides a DID to the permissioned
blockchain (step 4), resolves a DID into DID Document
(step 5) and receives this resolved DID Document (step
6). Here, company’s service provider will receive two
DID documents. First DID document consists of public
key of issuer and second DID document consists of
public key of customer and hashed value of order details.
Here, we considered that signed VCs of the customer
also contains DID information about issuer that helps
server to resolve the DID of issuer and permissioned
blockchain of the company consists a DID information
about all valid government issuers.

Company’s Delivery RobotxCompany’s Customer with Mobile DeviceChallengeResponse1010101010101011001100011001Company’s Private Cloud With PUF C-R Database For RobotxCompany’s Service Provider ServerSend Signed Randomly Chosen Challenge From RobotxDatabaseForward ChallengeSend ResponseSend Robot Challenge Verification RequestVerify Challenge Received From User and Response Received From RobotROBOT VERIFIED172345Send Signed Verification Bit[Ofornon verified, 1 for verified 4) Company’s service provider veriﬁes DID and order
details of the customer using public key received from
the DID document of customer and validates VCs using
public key derived from the DID document of the issuer
(step 7).

B. Threat Model

In this subsection, we consider two types of the threat
model. As the ﬁrst type of threat model, we consider an
adversary with DID-related access and another adversary
with access to all public channels and can receive, modify,
and delete the communicated messages. To the best of our
knowledge, this is the ﬁrst threat model that provides some
power to the adversaries related to DID accesses.
Type 1 Adversary −→ Adversary with DID and VCs access
capabilities:

• The adversary can access the permissioned blockchain.
• Customers’ privacy can leak if an adversary can access
order data in plain text, so the anonymity of customer
order details is a key challenge in managing customer
privacy.

• The adversary has access to the signed VCs of the

customer.

• An adversary can trace all the communication if the same

DID is used for multiple orders.

Type 2 Adversary −→ Adversary with communication channel
access capabilities:

• The adversary can eavesdrop, modify, and delete all com-
munication over a public channel between the customer,
service provider, and robots.

• Here we consider that service providers can have an
insider, the customer may try to fake order data, and
robots may try to cheat the company by selling products
to another customer.

C. Proposed Scheme

In this subsection, we propose a novel scheme for customer
veriﬁcation and robot veriﬁcation for the e-commerce com-
pany. The proposed scheme consists of three major phases. 1:
Customer Registration Phase 2: Customer Veriﬁcation Phase
and 3: Robot Veriﬁcation Phase. The customer veriﬁcation
phase consists of two sub phases : 2.1: Customer DID Veriﬁ-
cation Phase and 2.2: Customer VCs Veriﬁcation Phase.

1) Customer Registration Phase: The customer registra-
tion phase consists of two steps. In the ﬁrst step, the customer
obtains veriﬁable credentials (VCs) from the government
issuers, and in the second step, a customer obtains VCs
from the service provider company (valid only for a day)
by presenting the VCs obtained from the government issuers.
As per the policy of an e-commerce company, customers
can merge multiple VCs and create a veriﬁable presentation
(VP) to prove the eligibility for item purchase (i.e., country
(to assure location), date of birth (to assure customer not
buying the acidic item if they are below some age)). For the
Step 1, we assume that the customer has already obtained
valid VCs from the government issuers and they have stored

5

Fig. 3. Proposed Customer DID Veriﬁcation

them as a (V C)pr
Gvt, the service provider has DIDGvt and
blockchain have entries for the public key for government
issuers [5]. Here, each company’s service provider is also
having a (V C)pr
that is associated with DIDcomp and
veriﬁcation of this veriﬁable credential will prove that it is
valid service provider of the company.
Step 2: Obtaining VCs from the Company’s Service
Provider (CSP) :

Rcomp

1. The customer generates random number nu and send
message M1 = {nu, (V C)pr
Gvt} to the company’s service
provider. In message M1, nu plays a role of challenge by
the customer to CSP.

2. Upon receiving M1, CSP veriﬁes VCs issued by govern-
ment issuers. After successful veriﬁcation, The CSP generates
DIDcsp (separate for each new customer registration), public
key Vcsp and private key Rcsp. The CSP binds DIDcsp
and public key Vcsp in permissioned blockchain. Now CSP
generates random nonce ncsp and generates VC for customer
as V Cu = SIPh(ncsp||nu||(V C)pr
Gvt). Furthermore, CSP signs
this credential as (V Cu)pr
and response to challenge as
(nu)pr
using its private key. The CSP also receives cus-
tomer speciﬁc temporary T IDu and credential cru from the
blockchain administrator. These two parameters are only used
during registration step and valid only for one time use. Here,
the e-commerce company can decide whether to provide One
Time Credential (OTC) or One time Link (OTL) for registering
DID in the blockchain. The CSP creates a message M2 =
{(nu)pr
, DIDcsp, ncsp, T IDu, cru} and sends
to customer.

, (V Cu)pr

Rcsp

Rcsp

Rcsp

Rcsp

3. Upon receiving message M2 from CSP, customer veriﬁes
response to challenge by resolving DID of CSP. The customer
generates DIDu (separate for each new ), public key Vu and
private key Ru. Customer binds DIDu and public key Vu
with permissioned blockchain using pair {T IDu, cru}. Now
customer creates a response (ncsp)pr
and sends message M3 =
Ru
, DIDu} to the CSP. Customer stores {(V Cu)pr
{(ncsp)pr
,
Ru
DIDu, DIDcsp, Ru} in his/her secret memory of wallet.

Rcsp

4. Upon receiving message M3 from customer, CSP resolves

DID Permissioned BlockchainCompany’s Delivery RobotxCompany’s Customer with Mobile DeviceCompany’s Service Provider ServerPlace Order With DIDStore Signed Challenge Xto Mobile DeviceVerify DID123148756DIDu and veriﬁes response to challenge (ncsp)pr
using Vu.
Ru
After successful veriﬁcation, CSP gets assurance that customer
has registered his/her DID as well as has obtained VCs.

2) Customer and Order Veriﬁcation Phase: The customer
veriﬁcation phase consists of two-steps. In the ﬁrst step,
customer places an order with e-commerce company’s ser-
vice provider and receives order speciﬁc veriﬁable credentials
(OSVCs), and in the second step, the company’s robot veriﬁes
the customer, order details and OSVCs and deliver a product
to the veriﬁed customer.
Step 1 −→ Order Placing Phase by customer:

1. First, the customer picks the Product ID as P IDi (that
is part of the global trade item number and is unique for
each product) and product details (including ongoing price)
as P Di for that product ID from the company’s database. It
computes X1 = SIPh(P Di||P IDi). Next Customer generates
random nonce n∗
u and sign this nonce using ECDSA as
S1 = sign(n∗
u)P r
. Now customer creates a message M1 =
Ru
Enc(X1, S1, P IDi, (V Cu)pr
and sends {M1,
TS} to the CSP where TS is the current timestamp. Here, the
customer obtains a public key of the CSP by resolving DID of
the CSP that is available with him. We have used timestamp
veriﬁcation for two purposes. One is to prevent replay attacks,
and the other is to ensure that customers can order products
from any time zone.

, DIDu)P ub
Vcsp

Rcsp

Rcsp

i using P IDi and veriﬁes X ∗

2. After receiving message {M1, TS} from the customer,
CSP veriﬁes timestamp and time synchronization. Further-
more, CSP decrypts M1 using its private key and retrieves
{X1||S1||P IDi||(V Cu)pr
||DIDu}. First, it resolves customer DID and retrieves n∗
u af-
ter verifying signature S1. Next, CSP retrieves product details
i ||P IDi) ?=
1 = SIPh(P D∗
as P D∗
X1. Now, CSP veriﬁes (V Cu)pr
using own public key and
and validates eligibility of customer based on presented VCs
and product details. After these all validation, CSP generates
csp, generates OSVC = SIPh(n∗
n∗
u||X ∗
1 ) and signs it as
S2 = Sign(OSV C)pr
. Furthermore CSP generates S3 =
csp)pr
Sign(n∗
and send {M2, TS}
to customer.

, M2 = Enc(S2, S3)pub
Vu

csp||n∗

Rcsp

Rcsp

Rcsp

3. Upon receiving {M2, TS}, the customer veriﬁes times-
tamp, decrypts M2, and retrieves {S2,S3}. Customer veri-
ﬁes S3 using a CSP public key that customer has retrieved
after resolving DID of CSP. Now, the customer computes
X2 = SIPh(n∗
u) and generates order speciﬁc veriﬁable
presentation OSV P1 = {S2, X2}. Customer will use this
presentation while receiving a product.

csp||n∗

After this step, CSP selects Robotx for the delivery and
stores order speciﬁc public key of CSP (Vcsp) in secret
memory (that is secure element) of the Robotx. The CSP also
maintains {DIDu, Robotx} pair.
Step 2 −→ Customer, order details and OSVPs veriﬁcation
Phase by company’s robot: This step starts when robot
reaches for product delivery and

1. Robot generates a request towards the customer to present

the valid challenge, OSVC for to receive the product.

2.

Customer

Enc(OSV P1, DIDu, sign(n∗

presents
)pub
u)pr
Vcsp
Ru

M3

=
to the robot. Robot

forwards received message M3 to the CSP.

6

2 = SIPh(n∗

3. CSP decrypts M3 and retrieves {S2, X2, DIDu,
u)pr
sign(n∗
}. CSP resolves customer DID and veriﬁes signa-
Ru
u)pr
ture sign(n∗
csp||n∗
. Next CSP performs X ∗
u)
Ru
?= X2. After this two veriﬁcation, CSP veriﬁes S2 that is
signed order speciﬁc veriﬁable credential and contains order
details. If the S2 veriﬁcation succeed, it generates success
signal Succsign and if it is failed, it generates failure signal
F ailsign. Later it signs it as a S5 = Sign(Succsign)pr
or
S5 = Sign(F ailsign)pr
and sends back to the robot. Based
on stored public key of the CSP, robot veriﬁes S5 and decide
to deliver a product or not.

Rcsp

Rcsp

3) Robot Veriﬁcation Phase: The robot veriﬁcation phase
can transpire either in parallel to customer veriﬁcation, or it
can also transpire before or after the customer veriﬁcation
phase. In the proposed work, we have considered this step
after customer veriﬁcation step. Here, we have considered
that CSP maintains a PUF Challenge-Response Pair (CRP)
record for each in-service robot. As per shown in Fig. 4,
company’s private cloud maintains CRP for Robotx. This
database is accessible only by the admin team of CSP. The
robot veriﬁcation phase consists of two steps. Step one is
associated with challenge acquisition in which the customer
will request to CSP for the challenge, and CSP will select
and provide any random challenge from the CRP database
of Robotx. In step two, the customer will perform challenge
veriﬁcation through CSP. Here, we have not considered direct
robot veriﬁcation by the customer to control the customer’s
access to the robot. The E-commerce company can decide
to handle this veriﬁcation through CSP or directly between
customer and robot.
Step 1 −→ Challenge Acquisition by Customer:

1. The Customer Mobile Agent

(CMA) generates the
Robotverif y signal, n”” and sends it to CSP. Here we have
the customer is unaware of any informa-
considered that
tion about the robot. The CMA generates message M1 =
Enc((V Cu)pr
and
sends {M1, TS} to CSP.

, DIDu, Robotverif y)pub
Vcsp

, Sign(n””)pr
Ru

Rcsp

2. Upon receiving {M1, TS}, CSP performs time stamp
validation and later decrypts M1 using its own private key.
Next, CSP resolves DIDu and veriﬁes signature of n””.
Furthermore, CSP also validates V Cu using its public key.
After these validations, CSP randomly chooses Challengei
from the CRP database of the Robotx. The CSP generates
a message M2 = Enc(Sign(Challengei)pr
and sends
{M2, TS} it to the CMA.

)pub
Vu

Rcsp

3. Upon receiving {M2, TS}, CMA validates time stamp
and decrypts M2 using his/her own private key. The CMA
validates signature of Challengei upon resolving DIDcsp and
uses Challengei for next step.
Step 2 −→ Challenge Veriﬁcation by Customer:
as
and sends {S1, TS} to CSP.

CMA
The
Sign(Challengei)P r
Vu

Challengei

signs

S1

1.

=

2. Upon receiving {S1, TS},

the CSP validates times-
tamp and signature S1. The CSP resigns Challengei as S2
= Sign(Challengei)P r
and sends it to the Robotx. The
Robotx veriﬁes signature S2 using P ubVcsp and generates M3

Rcsp

TABLE I
CUSTOMER VERIFIABLE CREDENTIAL OBTAINING PHASE

7

Customer
Generate nu,
M1 = {(V Cu)pr

Gvt, nu},

Company Service Provider

M1−−→

M2←−−

Generate DIDu, Vu, Ru,

Bind {DIDu, Vu} to blockchain using {T IDu, cru},
store Ru in secret memory,
Sign (ncsp)pr
,
Ru
M3 = {(ncsp)pr
Ru

, DIDu},

Verify (V Cu)pr
Gvt,
Generate DIDcsp, Vcsp, Rcsp,
Bind {DIDcsp, Vcsp} to blockchain, store Rusp in secret memory,
Generate ncsp,
Generate V Cu = SIPh(nu||ncsp||(V Cu)pr
Sign (V Cu)pr
, (nu)pr
,
Rat
Rusp
X1 = SIPh(salt||(V CU )pr
Rat
Generate T IDu, cru,
M2 = {(nu)pr

, DIDcsp, ncsp, T IDu, cru},

, (V Cu)pr

Gvt),

),

Rusp

Rusp

Keep {DIDu, DIDcsp}
Store (V Cu)pr

,

Rcsp

M3−−→ Resolves DIDu and veriﬁes (ncsp)pr
Ru

,

IV. SECURITY VERIFICATION

A. Formal Security Veriﬁcation Using Tamarin Prover

In this section, we present formal security proof for the
proposed approaches using the tamarin prover. First we present
security proof for the customer veriﬁcation scheme followed
by robot veriﬁcation approach. To the best of our knowledge,
this is the ﬁrst formal security veriﬁcation for the customer
veriﬁcation system that uses decentralized identiﬁer.

A security protocol veriﬁcation tool called the Tamarin
prover allows both data manipulation and unrestricted veriﬁca-
tion in the metaphorical model [8]. Tamrin prover is a robust
asynchronous tool for security protocol design and evaluation.
takes as input a proposed security protocol, operations
It
performed by agents running the proposed protocol (e.g.,
the customer, the robot, and the trusted company’s service
provider), a delineation of the attacker, and a delineation of
the properties of the proposed protocol. In tamarin prover,
by manipulating network messages and making new ones,
the attacker and the protocol communicate with each other.
For to prove the security of proposed protocol, we have used
some built in cryptographic primitives of the tamarin prover
and representation of those functions are as follows in our
analysis. 1. For denoting asymmetric encryption : aenc, 2. For
denoting asymmetric decryption : adec, 3. For cryptographic
hash function : h, 4. For public key : pk, 5. For private key : k,
6. For signature generation : signg, 7. For signature generation
: signv. We can model the properties of these functions using
equations. An attacker in the tamarin prover is by default
a Dolev-Yao attacker who can intercept the network trafﬁc
and update, remove, and inject a message over a network.
However, it can not break the cryptographic primitives, such as

Fig. 4. Proposed Robot Veriﬁcation Approach

= Enc(Challengei, Responsei)P ub
Vcsp
TS} to the CSP.

. The Robotx sends {M3,

3. After validating timestamp, the CSP decrypts M3 and
retrieves {Challengei, Responsei} pair. After that CSP vali-
dates this pair with CRP database. Upon successful/failed vali-
dation, the CSP generates veriﬁcation bit V B1 (for successful)
or V B0 for failure and sign it as S3 = Sign(V B1)P r
and
sends {S3, TS} to the CMA.

Rcsp

4. The CMA validates the timestamp and signature of
the veriﬁcation bit using public key of CSP received upon
resolving DIDcsp. Based on the veriﬁcation bit, CMA informs
the customer to receive or decline the delivery.

Company’s Delivery RobotxCompany’s Customer with Mobile DeviceChallengeResponse1010101010101011001100011001Company’s Private Cloud With PUF C-R Database For RobotxCompany’s Service Provider ServerSend Signed Randomly Chosen Challenge From RobotxDatabaseForward ChallengeSend ResponseSend Robot Challenge Verification RequestVerify Challenge Received From User and Response Received From RobotROBOT VERIFIED172345Send Signed Verification Bit[Ofornon verified, 1 for verified TABLE II
ORDER PLACING AND CUSTOMER VERIFICATION PHASE

8

Company Service Provider

Robot

, DIDu)P ub
Vcsp

,

M1,TS
−−−−−→ ,

i ||P IDi)

?
= X1,

csp||n∗

u||X ∗
1 ),

,

i using P IDi,
1 = SIPh(P D∗
Rcsp

Verify TS
Resolves DIDu, verify S1,
Get P D∗
Verify X ∗
Verify (V Cu)pr
Generates n∗
csp,
Generates OSVC = SIPh(n∗
S2 = Sign(OSV C)pr
Rcsp
S3 = Sign(n∗
,
Rcsp
M2 = Enc(S2, S3)pub
Vu
M2,TS←−−−−−
Vcsp−−−→
Keep {DIDu, Robotx},

csp)pr

,

,

Customer
Step 1 −→ Order Placing:
Pick P IDi, P Di,
X1 = SIPh(P Di||P IDi),
Generate n∗
u, S1 = sign(n∗
M1 = Enc(X1, S1, P IDi, (V Cu)pr

u)P r
Ru

,

Rcsp

Verify TS ,
Decrypt M2,
Verify S3,

Compute X2 = SIPh(n∗

csp||n∗

u),

OSV P1 = {S2, X2},

T oRobotx
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
M3=Enc(OSV P1,DIDu,sign(n∗

u)pr
Ru

)pub
Vcsp

Step 2 −→ Customer veriﬁcation by robot:
Requesttocustomer
←−−−−−−−−−−−−−−

M3toCSP
←−−−−−−−

u)prRu ,
csp||n∗
u)

Decrypt M3,
veriﬁes sign(n∗
X ∗
2 = SIPh(n∗
Verify S2,
Generates Succsign,
S5 = Sign(Succsign)pr

?
= X2,

,

Rcsp

S5−−→

Verify S5 and signal,

breaking the encryption (ensuring conﬁdentiality) and chang-
ing the signature (ensuring integrity).

A state of the system is represented by a multiset of facts
that store the state’s information. The multiset rewriting rules
used for modeling the protocol operates states. Ex. out(m)
and in(m) represents that message m is forwarded over public
channel and message m is received from the public channel
respectively. Each rule is consists of set of premises (P), set
of operations (O) and set of conclusions (C) those we can
represent as :

P − [O] (cid:57)(cid:57)(cid:75) C

The conclusion’s facts will be added to the state while the
premises are removed to carry out the rule, which demands
that all of the premise’s facts be present in the current state. In
tamarin, ∼V, $V , #V , !F denotes that V is a fresh variable,
V is a public variable, and V is a temporal time-sensitive
variable, and F is a persistent fact respectively.

Now, with the help of rules, we will model the proposed
protocol. In the proposed protocol, we have deﬁned following
rules:

• PLATFORM SETUP
• ISSUER SETUP
• VERIFIER SETUP
• VC OBTAIN
• ORDER PLACING
• CUSTOMER VERIFY

With the help of lemmas, we will prove the important secu-
rity properties achieved in it. We have considered following
lemmas:

• Anonymity
• Privacy
• Authentication
• Veriﬁcation
• can be revoked
• signature nonlinkability

Fig. 5 shows outcome summary of the ”RobotDelivery.spthy”
ﬁle run over the tamrin prover installed in Windows Subsys-
tem for Linux (WSL). To read and get more details, readers
can refer to the [9] ﬁle. An outcome shows that the proposed
protocol is veriﬁed for all the six lemmas deﬁned for the
desired property veriﬁcation.

9

Fig. 5. Tamarin Prover Analysis Summary

B. Security Property Analysis

In this subsection, we analyze the proposed protocol us-
ing various security properties necessary for any robot-based
delivery system.

• Customer Anonymity and Privacy:

In the proposed
scheme, we don’t share any identity-related information
over the public channel in plaintext. The DID is registered
in and resolved through the private blockchain. The
customer purchase details are also veriﬁed in the hash
format; hence there is no chance for any insider to see the
customer order details in the plain text. Hence customer
anonymity and customer privacy are achieved.

• Order Unlinkability: In the proposed scheme, for any two
(cid:54)= DIDO2
consecutive orders O1 and O2, the DIDO1
u .
u
For each new order, a new DID is generated. Thus there
is no chance of identity linking. In each order Oi, we take
SIPh(P Di) to verify the product details, so the hash’s
randomness leads to the product’s unlinkability.

• Secure Customer Authentication and Veriﬁcation: In the
proposed scheme, the customer presents a veriﬁable cre-
dential to the V Cu CSP during the order placing phase,
and the CSP authenticates it through the full proof DID
resolution technique. During the customer veriﬁcation
phase, the customer presents the OSV C signed by CSP
to the robot, and those OSV C are also veriﬁed through
the DID resolution method; hence the customer is au-
thenticated two times in the complete product purchase
life cycle.

• Secure Robot Veriﬁcation: For the robot veriﬁcation, we
use the challenge-response-based PUF technique. In the
proposed scheme, the CSP selects random CRP from the
large CRP database and stores signed challenges into
CMA. The CMA uses it during product delivery. The
complete robot veriﬁcation occurs through the CSP, and
there is no direct interaction between the robot with the
customer. Hence, the proposed scheme achieves secure
robot veriﬁcation.
• Non-Repudiation:

In the proposed scheme, both veri-
ﬁable credentials (V Cu and OSV C) are signed by the
private key of the CSP, so there is no option available with
the CSP to deny signing those credentials. Similarly, the
user signs random nonce nu as a challenge using their

private key, so there is no option available to the cus-
tomer also of denying the signature. Hence, the proposed
scheme achieves non-repudiation or non-deniability.
• Secure against forgery attacks: In the proposed scheme,
both the veriﬁable credentials (V Cu and OSV C) are
issued by the CSP, and its private key signs them
both. Hence, no option is available to any customer to
forge/clone the CSP generated veriﬁable credentials.
• Secure against VCs loss/stolen: The V C and the OSV C
are stored in the CMA, and CMA is available only to the
customer. At the same time, DIDu is only available to
the customer and its new for each order. So, even if an
attacker captures any of V C or OSV C, it is impossible
to prove them to be a legitimate user. In the proposed
scheme, we verify product details as well. So, it is near
impossible for the attacker to get the credentials and use
them without full access to CMA.

• Credential Revocation :

In the proposed scheme, both
veriﬁable credentials (V Cu and OSV C) issued to the
customer are signed by the P rRcsp and P rRcsp is gen-
erated every time new for each customer order. And, the
CSP can any time terminate the entry of its DIDcsp
and P rVcsp from the blockchain through the blockchain
administrator. Hence after termination, the customer can
not use V Cu and OSV C for further veriﬁcation.

The proposed scheme also achieves security against im-
personation attack (only the user knows (V Cu) and OSV C,
forgery attack, reply attack (use of TS and nu), accountability
(using (V Cu)prGov veriﬁcation by CSP), minimal disclosure
(only limited information disclosed by the customer), and
security against reuse of credentials (for each order new V Cu
and OSV C).

V. EXPERIMENTAL STUDY AND PERFORMANCE ANALYSIS
This section demonstrates the experimental work related to
proposed user veriﬁcation and the proposed robot veriﬁcation
approach. We ﬁrst major the computation cost of the proposed
work based on several cryptographic operations. Then, we
major the computation time required by our implemented work
using the bigO python module. Following it, we have also
analyzed the communication cost in terms of the number of
bits communicated over public channels. There is an option
of accuracy analysis in robot veriﬁcation and user veriﬁcation

using machine learning, but that we have considered as future
work and not provided in this work.

A. Experimental Setup

As a mobile customer agent, we used the Blockstream
Green application, which supports multi-signature and two-
factor authentication. We have run this application over the
android operating system on a mobile device with 12 GB
RAM. As a robot, We have used raspberry pi 4 model B
with 4 GB RAM that comes with onboard wireless networking
and consumes less power than the computer. We have used a
DELL Alienware laptop with 12th Generation Intel Core i9-
12900HK (24 MB cache, 14 cores, 20 threads, up to 5.00
GHz Turbo) with 64 GB RAM system as a company’s service
provider server and that was connected with AWS Cloud
running a permissioned blockchain setup for implementation
of proposed work. For communication between customer,
robot, and CSP, we have used publish/subscribe based Mes-
sage Queuing Telemetry Transport (MQTT) protocol handling
communication channels through AWS MQTT broker running
on AWS cloud.

B. Performance Analysis

We have considered four major parameters for the perfor-
mance analysis of the proposed work. The ﬁrst parameter
is the end-to-end network latency that involves round trip
time required in the order placing phase by the customer,
customer veriﬁcation by the robot, and robot veriﬁcation by
the customer. We have considered the second parameter as a
computation cost in each step based on the individual time
taken by each cryptographic operation. The third parameter is
communication cost, which presents the total number of bits
communicated over the network in all three major phases. And
the last parameter is throughput, in which we have analyzed
the impact on end-to-end latency over the growing number of
orders.

TABLE III
INDIVIDUAL COMPUTATION COST

Operation
Hash Operation
ECDSA Sign
ECDSA Verify
ECC Encryption
ECC Decryption

Customer
1.01 ms
8.19 ms
11.61 ms
8.67 ms
9.33 ms

CSP
0.05 ms
2.03 ms
4.12 ms
6.32 ms
7.47 ms

Robot
-
-
5.23 ms
10.12 ms
-

10

Fig. 6. Throughput

We have used key-based SIPHash as a hash function that
provides the 64-bit output and leads to 64-bit DID, 64-bit
VC, and 64-bit hash output. The size of the retrieved product
ID (P ID) is 64-bit, the size of the challenge and response
is 128 bits each, and the size of the random numbers (nx)
generated is 64-bit. The veriﬁcation bit, success or failure
signal, and robot veriﬁcation request are of size 1 bit each.
Based on these individual costs, Table V represents the phase-
wise communication cost for the proposed scheme.

TABLE V
COMMUNICATION COST

Phases
Order Placing Phase
Customer Veriﬁcation Phase
Robot Veriﬁcation Phase

Communication Cost
448 bits
385 bits
578 bits

For communication purposes, we have used the pub-
lish/subscribe based MQTT protocol as an application layer
protocol, and the packets were transmitted in the javascript
format. The MQTT uses IP and TCP protocols as a network
layer and transport layer protocol. All the phases (including
the veriﬁable credential obtaining phase) were tested over the
public channel. The end-to-end latency does not include com-
putation time. Following Table VI presents cumulative end-to-
end communication delay (includes all four major networking
delays: queuing, processing,
transmission and propagation
delay) for each phase.

The ECDSA veriﬁcation can take more time for the ﬁrst time
because it also involves DID resolution. The robot takes less
time in ECDSA veriﬁcation because the CSP stores the public
key to verify the signature of the CSP. Table III shows average
time required for each operation by all entities and Table IV
represents phase-wise computation cost for the proposed work.

TABLE VI
END - TO - END LATENCY

Phases
Customer VC Obtaining Phase
Order Placing Phase
Customer Veriﬁcation Phase
Robot Veriﬁcation Phase

Communication Cost
59 ms
79 ms
102 ms
93 ms

TABLE IV
PHASE WISE COMPUTATION COST

Phases
Order Placing Phase
Customer Veriﬁcation Phase
Robot Veriﬁcation Phase

Customer
51.43 ms
8.67 ms
57.6 ms

CSP
18.72 ms
17.79 ms
37.68 ms

Robot
-
5.23 ms
15.35 ms

We have considered throughput as a distribution variation
in the end-to-end latency for each unit of increasing orders.
Fig. 6 presents the variation in end-to-end latency for each
phase over the increasing number of orders ranging from ten
requests to ten-thousand requests in parallel. It shows a minor
variation in latency for any number of orders in each phase.

11

this is the ﬁrst decentralized identiﬁer paper for customer
and robot veriﬁcation.

7) We haven’t used zk-SNARK or Zero-Knowledge Proof
(ZKP) for veriﬁcation of credentials, and it is an in-
teresting dimension to use ZKP for secured anonymous
veriﬁcation of veriﬁable credentials.

8) We haven’t explored the key sharing aspect followed
by symmetric encryption. So, the researcher can explore
the symmetric encryption after authenticated key sharing
for the DID-based customer veriﬁcation in e-commerce
product delivery.

9) The CSP stores its public key in the robot. There is a
high chance that if an attacker gets access to the robot
(ideally, it is near impossible), he may delete the public
key. In the proposed scheme, we have considered that
if any such incident occurs, the robot will ask the CSP
over the public channel for the public key. We can also
come up with any other better solution as future work
to this problem.

10) We have presented a scenario of the robot-based delivery
system, but the proposed work can be extended to the
drone-based delivery system, and it can also come with
numerous novel open challenges. To the best of our
knowledge, there does not exist any DID based drone
veriﬁcation or user veriﬁcation schemes.

REFERENCES

[1] W. Wang, P. Gope, and Y. Cheng, “An ai-driven secure and intelligent
robotic delivery system,” IEEE Transactions on Engineering Manage-
ment, pp. 1–16, 2022.

[2] Y. Kortesniemi, D. Lagutin, T. Elo, and N. Fotiou, “Improving the privacy
of iot with decentralised identiﬁers (dids),” Journal of Computer Networks
and Communications, vol. 2019, 2019.

[3] G. Fedrecheski, J. M. Rabaey, L. C. Costa, P. C. C. Ccori, W. T.
Pereira, and M. K. Zuffo, “Self-sovereign identity for iot environments: a
perspective,” in 2020 Global Internet of Things Summit (GIoTS).
IEEE,
2020, pp. 1–6.

[4] E. Samir, H. Wu, M. Azab, C. Xin, and Q. Zhang, “Dt-ssim: A decentral-
ized trustworthy self-sovereign identity management framework,” IEEE
Internet of Things Journal, vol. 9, no. 11, pp. 7972–7988, 2021.

[5] R. P. Parameswarath, P. Gope, and B. Sikdar, “User-empowered
privacy-preserving authentication protocol for electric vehicle charging
based on decentralized identity and veriﬁable credential,” ACM Trans.
Manage.
[Online]. Available:
https://doi.org/10.1145/3532869

Inf. Syst., apr 2022,

just Accepted.

[6] X. Fan, Q. Chai, L. Xu, and D. Guo, “Diam-iot: A decentralized
identity and access management framework for internet of things,” in
Proceedings of the 2nd ACM International Symposium on Blockchain
and Secure Critical Infrastructure, ser. BSCI ’20. New York, NY, USA:
Association for Computing Machinery, 2020, p. 186–191. [Online].
Available: https://doi.org/10.1145/3384943.3409436

[7] C. Patel and N. Doshi, Internet of things security: challenges, advances,

and analytics. CRC Press, 2018.

[8] S. Meier, B. Schmidt, C. Cremers, and D. Basin, “The tamarin prover for
the symbolic analysis of security protocols,” in International conference
on computer aided veriﬁcation. Springer, 2013, pp. 696–701.

[9] C. Patel, “Privacy preserving customer veriﬁcation for intelligent delivery
system using decentralized identiﬁer with physically unclonable function
enabled robots,” https://github.com/chintanp592/RobotDelivery.git, 2022.

VI. CONCLUSION AND OPEN CHALLENGES
In this section, we present a cursory discussion about the
contribution of this work and open challenges related to this
work. The open challenges can be much more, highlighting
the foremost ones related to contributed work.

A. Conclusions

The robot-based delivery system ensures cost-effective, con-
tactless, on-time delivery for e-commerce companies. In this
manuscript, we proposed a ﬁrst-time DID-based customer
veriﬁcation with PUF based robot veriﬁcation system. We pro-
posed a novel DID-based framework and a DID-based scheme
for secure product delivery after authenticated customer veri-
ﬁcation. We also presented security veriﬁcation using Tamarin
prover and key security property analysis. We discussed the
performance analysis of the proposed scheme based on end-
to-end latency, computation cost, communication cost, and
throughput and proceeded with the implementation of the
proposed work using real-time hardware and python language.
Overall, this is the ﬁrst and novel DID-based solution for
secure robot-based product delivery. There are some open
issues related to the work that we presented in the following
subsection.

B. Open Challenges and extension possibilities

In the proposed work,
1) we have contemplated that the customer can not cancel
the order once the robot
leaves for delivery. In the
future, we will provide a solution so that customers can
cancel/update their orders anytime. In that solution, We
will provide a novel cryptographic dynamic accumulator
for the e-commerce company to revoke the customer
in such a way that the customer veriﬁcation will not
succeed if the customer cancels/updates the order even
after the robot starts its product delivery journey.

2) We have considered the service provider entity a VCs is-
suer and veriﬁer. There is nothing wrong because issuers
of VCs are still trusted entities in DID mechanism. In
the future, we will introduce a separate entity for issuing
VCs and verifying VCs.
3) We haven’t discussed about

loss of private key by
customer. If customer loss his/her private key then it is
difﬁcult for the customer to recover the private key and
prove himself/herself as a legitimate customer. For that,
we will introduce a biometric DID as a tool to recover
the lost key with out any extra backup storage.

4) We have not discussed any work related to sharing
OSVC by the veriﬁed customer to a legitimate receiver
(for example, a friend or family member) in the cus-
tomer’s dearth. So in the future, we will also introduce
a solution for that challenge.

5) We haven’t discussed anything related to DID’s au-
ditability and privacy issues. If DID of the customer is
stolen, it can become difﬁcult to detect misuse of IT by
an adversary to communicate with CSP.

6) We haven’t provided a comparative performance analy-
sis of the proposed work because, as per our knowledge,

