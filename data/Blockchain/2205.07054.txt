2
2
0
2

y
a
M
4
1

]

R
C
.
s
c
[

1
v
4
5
0
7
0
.
5
0
2
2
:
v
i
X
r
a

CDEdit: A Highly Applicable Redactable
Blockchain with Controllable Editing Privilege and
Diversiﬁed Editing Types

Xiaofeng Chen
School of Cyber Science and Technology
Beihang University, China
Email: cryptocxf@buaa.edu.cn

Ying Gao*
School of Cyber Science and Technology
Beihang University, China
Key Laboratory of Aerospace Network Security,
Ministry of Industry and Information Technology, China
Email: gaoying@buaa.edu.cn

Abstract—Redactable blockchains allow modiﬁers or voting
committees with modiﬁcation privileges to edit the data on the
chain. Trapdoor holders in chameleon-based hash redactable
blockchains can quickly compute hash collisions for arbitrary
data, and without breaking the link of the hash-chain. How-
ever, chameleon-based hash redactable blockchain schemes have
difﬁculty solving the problem of multi-level editing requests
and competing for modiﬁcation privileges. In this paper, we
propose CDEdit, a highly applicable redactable blockchain with
controllable editing privilege and diversiﬁed editing types. The
proposed scheme increases the cost of
invalid or malicious
requests by paying the deposit on each edit request. At the
same time, the editing privilege is subdivided into request,
modiﬁcation, and veriﬁcation privileges, and the modiﬁcation
privilege token is distributed efﬁciently to prevent the abuse of the
modiﬁcation privilege and collusion attacks. We use chameleon
hashes with ephemeral trapdoor (CHET) and ciphertext policy
attribute-based encryption (CP-ABE) to implement two editing
types of transaction-level and block-level, and present a practical
instantiation and security analysis. Finally, the implementation
and evaluation show that our scheme only costs low-performance
overhead and is suitable for multi-level editing requests and
modiﬁcation privilege competition scenarios.

Index Terms—chameleon hash, editing types, modiﬁcation

privilege, redactable blockchainn

I. INTRODUCTION

A blockchain is a hash-chain formed by the hash of the
block linking the next block in chronological order. This hash-
chain linked by hash values makes the transaction content
immutable and improves the trustworthiness of the trans-
action information. On the other hand, the immutability of
transactions has become a new obstacle limiting blockchain
applications.

In an immutable blockchain, any transaction written by a
participant cannot be modiﬁed. Some malicious participants
may post information that contains sensitive or illegal data.
For instance, materials infringe on intellectual rights [1] and
child sexual abuse images [2]. This sensitive information
cannot be modiﬁed after being uploaded, which will have a
severe and irreversible impact on their lives. Moreover, the
General Data Protection Regulation (GDPR) [3] issued by the
European Union in 2018 states that any data subject must

request the responsible party to hide or delete data records
about individuals. Thus, there is a signiﬁcant need to edit the
data on the blockchain in practice.

Nowadays, redactable blockchains are mainly implemented
by the chameleon hash (CH) algorithm [4] [5], which uses
CH with a trapdoor key to replace the traditional collision-
resistant hash algorithm. In the editing mechanism with a
CH algorithm, the trapdoor holder can ﬁnd a collision in a
broad sense without changing the hash output and breaking the
hash link. According to the different data editing targets, there
are two redactable blockchains. Type one is coarse-grained
block-level (Bl-level) editing, which enables modiﬁcation of
the entire block by replacing the traditional Merkle root
hash with a CH. Type two is a ﬁne-grained transaction-
level (Tx-level) edit operation designed to modify a speciﬁc
transaction, more aligned with realistic requirements. The
PCHBA scheme [6] links the modiﬁed transactions to the
responsible modiﬁer and does not impose a privilege penalty
on the modiﬁer who abuses rewriting privilege. It does not
prevent the irresponsible modiﬁer from abusing the privilege
again the next time they edit. Although the KERB scheme [7]
uses the deposit deduction method to hold malicious modders
accountable and punishable. However, it does not reduce the
modiﬁcation privileges of malicious modiﬁers, resulting in the
inability to eliminate malicious behaviour. To the best of our
knowledge, most redactable blockchain protocols suffer from
two problems.

• It is challenging to manage and distribute the appropriate
editing privileges. The use of centralized editing privilege
control is subject to the risk of centralization [8], while
the management of editing privileges in multiple centres
leads to being very inefﬁcient.

• It is unable to handle edit requests with different gran-
ularity or conﬂicts. Inefﬁcient or ambiguous one-by-
one processing consumes system resources. It leads to
security issues such as conﬂicting data on-chain.

This work. This paper is inspired by [6] and [7]. We pro-
pose a highly applicable redactable blockchain with control-

 
 
 
 
 
 
lable editing privilege and diversiﬁed editing types (CDEdit).
CDEdit enables multi-level editing of data on-chain in permis-
sion settings (e.g. Hyperledger [9]). The main contributions are
summarized as follows.

The main contributions are summarized as follows.
1. Token-based controlled editing privileges. We propose
a mechanism to manage and distribute token-based edit-
ing privileges, in which privileged tokens at different
granularity are generated by a privileged token service
(PTS). The privilege token effectively prevents the mod-
iﬁer and owner from colluding to perform unauthorized
edits.

2. Conﬂict-free multi-level editing. We subdivide editing
privileges into diversiﬁed n-times Tx-level and Bl-level
editing to handle conﬂicting editing requests and reduce
latency, n is deﬁned as the number of edits. Speciﬁcally,
ﬁne-grained modiﬁcation privilege tokens are distributed
to modiﬁers with speciﬁed credibility levels to perform
multi-level editing operations.

3. Practical Instantiation. We present

the instantiation
and security analysis of CDEdit. The implementation
and evaluation show that our scheme only needs low
performance overhead and can resist conspiracy attacks.

.

II. OVERVIEW OF CDEDIT

The CDEdit consists of ciphertext policy attribute-based
encryption (CP-ABE) [10], and core mechanisms such as
chameleon hashes with ephemeral trapdoor (CHET) and digi-
tal signatures(Schnorr signature scheme [15] is used). PTS is
responsible for validating and ﬁltering editing requests and
issuing appropriate privilege tokens to the modiﬁer group.
The CP-ABE encryption algorithm encrypts the ephemeral
trapdoor in CHET under the access structure A. If a set
of attributes meet the access structure corresponding to the
ciphertext,
is not
a centralized control of editing privileges. A valid edited
transaction or block must have the following conditions: 1)
a token issued by PTS, 2) a valid access attribute policy, and
3) a CH trapdoor key pair.

it can be decrypted. Note that CDEdit

After the owner uploads a variable transaction to the
blockchain, the policy-based chameleon hash is output, which
contains ciphertext and signature. The upload of immutable
transactions is the same as that
in traditional blockchain,
which we will not discuss more. Considering the different
editing needs of different requesters and the convenience of
supervising illegal acts, the management and allocation of
editing privileges is necessary. In CDEdit, editing privileges
controlled and managed by classifying it into request privi-
lege, modiﬁcation privilege and veriﬁcation privilege. Request
privilege requires that legal modiﬁers have multi-level editing
requirements. This scheme requires a certain deposit amount
for each editing request to prevent system congestion caused
by blocking attacks. Modiﬁcation privilege is the permission
granted by PTS to the modiﬁer group to perform modiﬁcation.
Veriﬁcation privilege is a license held by all participants in the

system. veriﬁcation privilege provides the transparency and
accountability of data on the chain, and effectively identiﬁes
abnormal behaviour.

Due to the complexity of the actual environment, we assume
that the modiﬁer and the owner entity can intersect. CDEdit
provides n-times Tx-level edits and n-times Bl-level edits for
privilege token. Note that n-times edit is deﬁned as allowing
n-times edits in a reasonable time without multiple token and
key generation and veriﬁcation processes.

III. PRELIMINARIES

A. Blockchain Basics

Using the notation used by [11] and [12], we adopt the fol-
lowing model and notation to describe the blockchain: assume
that each block consists of a tuple Bi =< P reHi, xi, ctri, r >
, i ∈ [0, N ], B0 denotes genesis block and BN denotes the
latest block (head of the chain), P reHi ∈ {0, 1}K denotes
the pre-block hash of length K bits, xi ∈ {0, 1}∗ denotes
the current block data of arbitrary length (include the trans-
action root hash T Xroot and others), ctri ∈ N denotes the
randomness N once generated by consensus mechanism, and
the randomness r for the CH. A block Bi is valid iff

ValidateBlock D (Bi) :

= (H (ctri, G (Pre Hi, xi, r)) < D) ∩ (ctri < q) = 1.

Here, H : {0, 1}∗ → {0, 1}K and G : {0, 1}∗ → {0, 1}K
are collision-resistant hash function, they are called the outer
hash function and the inner hash function, respectively. The
parameter D ∈ N is the block’s difﬁculty level, and q ∈ N are
the maximum number of hash queries in each round of the
consensus process.

The rightmost block of blockchain C is called the head
of the chain, denoted by Head(C). Any chain C with a
head Head(C) := hP reHi, xi, ctri, ri can be extended to a
new longer chain C′ := C||Bi+1 by attaching a valid block
Bi+1 = hP reHi+1, xi+1, ctri+1, r′i such that P reHi+1 =
H(ctri, G(P reHi, xi, r)); the head of the new chain C′ is
Head(C′) := Bi+1. If C is a preﬁx of C′ we write C ≺ C′.

B. Ciphertext-policy attribute-based encryption

The PCH is constructed from CHET and CP-ABE schemes
[13]. The following section formally introduces the concept
of access structure associated with ciphertext in CP-ABE,
discusses how to encode access structures.

Access Structure. Let U denote the universe of attributes.
A collection A ∈ 2U \ {φ} of non-empty subsets is an access
structure on U. The subsets in A are called the authorized
sets, and the sets not in A are called the unauthorized sets. It
is called monotone if ∀B, C ∈ A : if B ∈ A and B ⊆ C the
C ⊆ A.

Monotone Span Program (MSP). As of previous work,
linear secret-sharing schemes (LSSS) [14] consist of a share-
generating matrix M with n1 rows and n2 columns which
encodes monotone access structures. The monotonic access
structure is usually represented as a Boolean formula on
attributes with AND and OR operators, which is satisﬁed if

the input attribute computes a value of 1. An alternative way
to represent such formulas is to think of access trees. In such
a tree, the leaf’s form the input attributes, while the inner
nodes are associated with the operators AND and OR. LSSS
with domain of secrets realizing access structure A is called
linear over Zq if: 1) The shares of a secret s ∈ Zq for each
attribute form a vector over Zq, and 2) For u = {1, ..., n1}, we
deﬁne a function π that maps the row u of M with attribute
π(u) from the attribute universe U. Then, the column vector
~v = (s, r2, . . . , rn2 )T , where s ∈ Zq is the secret to be shared
and r2, . . . , rn2 ∈ Zq are chosen at random. The M~v ∈ Z n1×1
is the vector of n1 shares of the secret s according to LSSS.
The share (M~v)u belongs to attribute π(u).

q

[14] states that every LSSS has the linear reconstruc-
tion property. Assume that LSSS is an MSP for the ac-
cess structure A, 1 = A(θ) is an authorized set and let
I ⊂ {1, 2, ..., n1} be deﬁned as I = {u ∈ [n1] ∩ π(u) ∈ θ}.
There exist the constants {γu ∈ Zq}u∈I such that for any valid
share {λu ∈ (M~v)u}u∈I of a secret s according to LSSS,
Pu∈I γuλu = s. Meanwhile, these constants {γu}u∈I can
be found in the polynomial time of the size of the matrix M.
For any unauthorized set θ′, no such {γu} exist.

C. Policy-Based Chameleon Hashes

A PCH [13] with message space M consists of ﬁve algo-
rithms {P P Gen, KGen, Hash, V erif y, Adapt} which are
deﬁned as follows.
• PCH.P P Gen

→ (skP CH , pkP CH ): On input a
security parameter λ ∈ N in unary, this algorithm outputs
the secret key skP CH and the public key pkP CH , where
pkP CH is implicitly available to all algorithms.

1λ
(cid:0)

(cid:1)

• PCH.KGen(skP CH, θ) → skθ: On input a secret key
skP CH and a set of attributes θ ⊆ U, the key generation
algorithm outputs a secret key skθ.

• PCH.Hash(pkP CH , m, A) → (h, r): On input a public
key pkP CH , access structure A ⊆ 2U, and a message
m ∈ M, and outputs a hash h and randomness r.

• PCH.V erif y(pkP CH, m, h, r) → b: On input public key
pkP CH , a message m ∈ M, a hash h, and a randomness
r, the algorithm outputs a decision bit b ∈ {0, 1}.

• PCH.Adapt(skθ, m, m′, h, r) → r′: On input a secret
key skθ, messages m, m′ ∈ M, hash value h and
randomness r, and outputs a randomness r′.

Note that we assume that the KGen outputs ⊥ if θ is not
contained in U and the Adapt algorithm always veriﬁes if the
hash it is given is valid, and output ⊥ otherwise.

IV. CDEDIT SYSTEM MODEL

A. Types of Modiﬁcation Privilege Token

CDEdit supports four types of tokens with different per-
mission semantics. Each of these different token types corre-
sponds to a collection of four levels of modiﬁers to enable
CDEdit system diversity and anti-collision request control for
modiﬁcation privileges.

• One-time Tx-level token (T1tk). It represents the simple
transaction modiﬁcation token in the system. A modiﬁer

who owns T1tk can only modify a transaction with
speciﬁc parameters.

• n-time Tx-level token (Tntk). The modiﬁer is allowed to
perform n-times Tx-level transaction modiﬁcation opera-
tions using the associated parameters or methods before
the token expires. Note that Tntk is higher than the
permission level of T1tk, i.e. the modiﬁer with Tntk can
also perform only a single Tx-level modiﬁcation.

• One-time Bl-level

the
token (B1tk). It
modiﬁer performs a modiﬁcation operation on a whole
data block by calling speciﬁc parameters. Since each
block contains several transactions, Btk has a higher edit
permission level than Ttk.

indicates that

• n-times Bl-level token (Bntk). It represents the super
token in the system, i.e. the highest permission level.
A modiﬁer who owns Bntk can replace n consecutive
blocks using the associated block parameter.

We deﬁne the sets of modiﬁers with different credibility
levels {m1T , mnT , m1B, mnB} respectively, and their mod-
iﬁcation privileges correspond to the above four types of
privileges token, i.e., {T1tk → m1T , Tntk → mnT , B1tk →
m1B, Bntk → mnB}. The PTS sets all privileges tokens
with an expiration time to avoid repeated invocations by
the modiﬁer. Speciﬁcally, the modiﬁer can only receive a
new token if the editor wants to continue performing edit
operations.

The modiﬁer sends a privilege token request reqtk =
(type||reqP ayload) to the PTS when it has an edit request,
where reqP ayload = (n||ID||index), type ∈ {Ttk, Btk} de-
notes the type of the edit object, n denotes the number of mod-
iﬁcations, ID is the identity of requester, index is the index
address of the edit target (transaction or block). PTS receives
the request and veriﬁes its validity, and then signs it with the
private key skpts, i.e. Signskpts(type||expire||reqP ayload),
where reqP ayload is an optional ﬁeld of the token request,
whose size varies depending on the type. The ﬁnal return to
the modiﬁer is a privilege token

pritk = (type||expire||index||time||deposit||Signskpts).

(1)
where expire encodes the expiration time, deposit denotes the
information of margin payment, and time is the timestamp of
pritk sent to the modiﬁer.

B. Formal Deﬁnitions

• Setup(1λ) → (SK, P K): It takes a security parameter
λ ∈ N as input, outputs a chameleon hash key pair
(sk, pk) and a key pair (skpts, pkpts).

• T kGen(skpts, reqtk, n) → pritk: It takes a secret key
skpts, a editions token request reqtk and n ∈ N, and
outputs a privilege token key pritk.

• KeyGen(sk, θ) → skθ: It takes the secret key set sk,
where sk includes the secret key skCHET of CHET and
the secret key msk of CP-ABE, and a set of attributes
θ ∈ U as input, outputs a secret key skθ, which is indexed
by an identity of modiﬁer.

PTS

(cid:311) Initialization

(cid:317) Audit

Modifiers

Return token

(cid:314) Send Token

CA

mnB

...

: Chameleon Hash

: Collision-resistance Hash

Bi-1

Bi

Bi+1

PreHi-1

TS

TXro ot

ctri-1

PreHi

TS

TXroot

ctri

PreHi+1

TS

TXro ot

ctri+1

(cid:315) Edit

m1B

...

Sign 

H12(H1||H2)

H34(H3||H4)

Tx1 

Tx2

Tx3

Tx4

(cid:312) Append

Owners

...

(cid:316) Verification

(cid:313) Request

Verification 

...

mnT

...

m1T

Fig. 1. CDEdit system model.

• Hash(pk, m, A, IDj) → (h, r, σ): It takes the chame-
leon pubic key pk, a message m := {T xID, xi} ∈ M,
an access policy A, and an owner identity IDj as
input, outputs a chameleon hash h, a randomness r, and
signature σ. Note that M = {0, 1}∗ denote a general
message space, T xID and xi denote the transaction data
and i-th block data, respectively.

• V erif ym(pritk, pkpts) → b: It takes the privilege token
pritk, a public key pkpts as input, and outputs a decision
bit b ∈ {0, 1}.

• V erif y(pk, m, h, r, σ) → b: It takes the public key pk,
a message m, chameleon hash h, randomness r, and
signature σ as input, and outputs a bit b.

• Adapt(skθ, m, m′, levelmi, h, r, σ) → (r′, σ′): It takes
the secret key skθ, a message m, a new message m′,
index i of the modiﬁer’s identity levelmi, chameleon hash
h, randomness r, and a signature σ as input, outputs a
new randomness r′ if 1 = A(θ) and a new signature σ′.
• Audit(sk, m, m′, r, r′, σ, σ′, h) → (levelmi,d): It takes
the chameleon secret key sk, messages m and m′, ran-
domness r and r′, signature σ and σ′, a chameleon hash
h as input, and outputs the new privilege level levelmi
of the modiﬁer mi, and accountability record d.

Correctness. We say that scheme CDEdit satisﬁes the
correctness property if for all security parameters λ ∈ N,
, for all θ ∈ U, for all
1λ
for all (sk, pk) ← Setup
(cid:0)
(cid:1)
pritk ← T kGen(skpts, pkpts, reqtk, n), for all θ ∈ A, for all
skθ ← KeyGen(sk, θ), for all m ∈ M, for all (h, r, σ) ←
Hash(pk, msk, m, A, IDj), for all m′ ∈ M, we have for
all (r′, σ′) ← Adapt(skθ, m, m′, levelmi, h, r, σ), that 1 =
V erif ym(pritk, pkpts) and 1 = V erif y(pk, m, h, r, σ) =
V erif y(pk, m′, h, r′, σ′).

C. System Model

The CDEdit system model contains four main types of
entities: central authority (CA), PTS, modiﬁers, and owners,
as shown in Fig.1. Assume that the transactions T x2 and
T x4 in boxed red are policy-based mutable transactions with
different access permissions, and that they can be modiﬁed
without changing the hash value. The transactions T x1 and
T x3 framed in blue are immutable transactions generated
by the owner using a collision-resistant hash. This T Xroot
is the root hash of the Merkle tree, which accumulates all
the transactions within the block. Thus, the i-th blocks is a
mutable block Bi = hP reHi, xi, ctri, ri generated by PCH,
where P reHi+1 = H(ctri, P CH(P reHi, xi, r)). These sys-
tem components are described below.

• CA represents the administrator in the permissioned
blockchain and is responsible for managing the PTS and
system initialization (see ①). CA broadcasts public pa-
rameters at system initialization and audits the modiﬁer’s
editing behaviour after receiving a report message from
the owner (see ⑦).

• Modiﬁer has the permission to send edit requests to
the PTS (see ③), and the permission to modify the
transactions or block data (see ⑤). A group of modi-
ﬁers is classiﬁed into different modiﬁer sets levelmi by
credibility level, i.e., a single Tx-level modiﬁer set m1T ,
a multiple Tx-level modiﬁer set mnT , a single Bl-level
modiﬁer set m1B and a multiple Bl-level modiﬁers set
mnB (credibility level from small to large m1T < mnT <
m1B < mnB).

• PTS is responsible for veriﬁcation of edit requests from
modiﬁers and providing the corresponding edit privilege
token (see ④) to the modiﬁer, i.e., assigning modiﬁcation
privileges. A privilege token determines the editing scope
of a particular modiﬁer set. Note that the sender of an edit

...
.........

...
......

CA
CA

PTS
PTS

Modifiers
Modifiers

Owners
Owners

System initialization
System initialization

Setup
Setup
Run 
Run 
‹
‹
(
(
sk
sk
msk
msk
‹
‹
(
(
pk
pk
mpk
mpk

l ﬁ
l ﬁ

(1 )
(1 )

,
,

sk pk
sk pk
,
,
)
)

(
(
sk
sk
CHET
CHET
,
,
pk
pk

CHET
CHET

CPABE
CPABE

CPABE
CPABE

,
,

pp
pp

)
)

)
)

(cid:311)
(cid:311)

,pp pk
,pp pk

Run 
Run 

Setup
Setup

l ﬁ
l ﬁ

(1 )
(1 )

(
(

sk
sk

,
,

pk
pk

)
)

pts
pts

pts
pts

ptspk
ptspk

(
(

Run 
Run 
sk
sk
q
q
ssk
ssk

q
q
KeyGen sk
, )
KeyGen sk
, )
‹
‹
(
ssk
sk
sk
)
,
,
(
ssk
)
‹
‹
KeyGen msk
(
(
KeyGen msk

CHET
CHET

CPABE
CPABE

Transaction and 
Transaction and 
block generation
block generation

ﬁ
ﬁ

(
(

sk
sk
)
)
q
q

skq
skq

Run 
Run 

Setup
Setup

l ﬁ
l ﬁ

(1 )
(1 )

level
level
m
m

q
q
, )
, )

(cid:312)
(cid:312)

Run 
Run 

Setup
Setup

l ﬁ
l ﬁ

(1 )
(1 )

ID
ID

j
j

,
,

,
,

',
',

ch h C c r s Run 
ch h C c r s Run 
,
,
A ID
,
,
A ID

,
,

Hash pk msk m
,
,
,
,
Hash pk msk m

,
,
ch h C c r s
ch h C c r s
)
)
,
,

',
',

,
,

,
,

,
,

(
(
ﬁ
ﬁ

(
(

)
)

j
j

Fig. 2. System initialization, transaction and block generation.

...
.........

...
......

PTS
PTS

Modifiers
Modifiers

Owners
Owners

Token distribution 
Token distribution 

Check 
Check 

req
req
tk
tk

deposit
deposit
, 
, 

(cid:313) Send 
(cid:313) Send 

req
req
tk
tk

 and make 
 and make 

deposit
deposit

Run 
Run 

TkGen sk
TkGen sk
(
(
priﬁ
priﬁ

tk
tk

req n
req n
, )
, )
tk
tk

,
,

pk
pk

,
,

pts
pts

pts
pts

(cid:314)
(cid:314)

tkpri
tkpri

Check 
Check 

tkpri ch h
tkpri ch h
,
,

,
,

'
'

Tx-level and 
Tx-level and 
Bl-level editing
Bl-level editing

Invalid 
Invalid 

Run 
Run 

Verify
Verify
m
m

(
(

pri
pri
tk
tk

,
,

Verify pk m ch h r
Verify pk m ch h r
,
,

',
',

(
(

,
,

,
,

,
,

pk
pk

ﬁ
ﬁ

)
b
b
)
pts
pts
ﬁ
ﬁ
bs
bs
)
)

Invalid 
Invalid 
Adapt sk m m level
Adapt sk m m level
,
,
,
,
',
',
q
q
m
m
sﬁ
sﬁ
',
',
r
r
( ',
( ',
')
')

(
(
s
s
)
)

Run 
Run 
ch h r
ch h r
,
,
,
,

,
,

(cid:315)(cid:3)
(cid:315)(cid:3)

r s
r s
( ',
( ',
')
')

Fig. 3. Token distribution, and Tx-level and Bl-level editing in CDEdit.

request does not necessarily belong to the same level of
modiﬁer group.

• The owner represents the primary participant and is
responsible for adding immutable or mutable transactions
(see ②). The owner can also send edit requests based on
modiﬁcation requirements, as well as validate the editing
behaviour of speciﬁc modiﬁers (see ③).

1) System Initialization.: This phase can be divided into
system setup, PTS setup, modiﬁer setup and owner setup, as
shown at the top of Fig. 2.

• System setup. CA chosen a parameter λ, and outputs
1λ
key pair (sk, pk) by running the algorithm Setup
(cid:0)
(cid:1)
(see ①), where sk = (mskCP −ABE, skCHET ), pk =
(mpkCP −ABE, pkCHET , pp), and pp ← SetupDS(1λ),
, while
(msk, mpk) is generated by SetupCP −ABE (cid:0)
(cid:1)
(skCHET , pkCHET ) is generated by SetupCHET (1λ).
CA selects
at-
tribute set θ, and outputs the secret key skθ ←
(skCHET , ssk) by KeyGen(sk, θ) algorithm, where
ssk ← KeyGen(mskCP −ABE, θ). Finally,
the CA
broadcasts the public parameter pp and the chameleon
public key pk to the network.

the CH secret key sk and the

1λ

• PTS setup. A trusted PTS is speciﬁed by CA and gen-
erates its own key pair (skpts, pkpts) by running the
Setup(1λ) algorithm. (skpts, pkpts) is used for subse-
quent PTS issuance and signing of the token.

• Modiﬁer setup. After receiving pp, pk from CA, the trans-
action modiﬁer runs Setup(1λ) algorithm to generate its
own identity information (or level) levelm. The initial
level is set by CA, such as m1T or m1B.

• Owner setup. After receiving pp, pk from the CA, the
transaction owner runs the Setup(1λ) algorithm to obtain
its own identity address information IDj.

2) Transaction and Block Generation.: In CDEdit, mutable
transactions and mutable blocks are allowed to be generated,
as shown at the bottom of Fig. 2.

• Generate mutable transactions. owner executes

the
Hash(pk, msk, m, p, IDj) to generate a PCH with mes-
sage m and upload it to the chain (see ②). Concretely,
a hash ch, a randomness r and ephemeral trapdoor etd
are generated by the Hash(pk, m) algorithm in CHET,
and bring etd into the Enc(mpk, R, A, IDj) algorithm
of CP-ABE to generate the ciphertext C. Then, the signed
message c generated using DS.KeyGen(pp, sk, etd) al-
gorithm is signed to obtain σ.

• Generate mutable block. The T Xroot is generated by sev-
eral transactions through multiple hashing algorithms, and
the timestamp T S constitutes the block data xi. Generate
a mutable block Bi = (P reHi, xi, ctri) by taking xi and
the pre-block hash P reHi, and the randomness ctri.

3) Token Distribution.: This phase is where the modiﬁer
obtains the token issued by the PTS, as shown at the top
of Fig. 3. First, the modiﬁer initiates an edit request reqtk
to the PTS and pays a certain amount of deposit (see ③).
After receiving reqtk, the PTS checks whether the deposit
paid satisﬁes the requested edit type cost, as well as ver-
iﬁes the corresponding parameter information and signature
λpts. Then, PTS generates the corresponding privilege token
pritk by T kGen(skpts, pkpts, reqtk, n) algorithm, where n
indicates the number of modiﬁcations. Finally, PTS distributes
pritk (see ④) to the set of modiﬁers of the relevant level
levelmi.

4) Tx-level and Bl-level editing.: As shown at the bot-
tom of Fig. 3, the modiﬁer group levelmi receives the to-
ken pritk and needs to check its validity and execute the
V erif ym((pritk, pkpts) algorithm to verify the token type
and the signature σpts of the token. Only pritk is valid to
continue the next operation. Otherwise, stop. Validating the
token before the actual edit execution can effectively ﬁlter out
invalid requests. Then choose to perform the following edit
types (see ⑤).

• Tx-level edit. Let m as transaction T xID, the modiﬁer
levelm satisfying the set of attributes S ∈ A starts
V erif y(pk, T xID, ch, h′, r, σ)
by
the
the
algorithm to
hash
of
(ch, h′)
algorithm
adaption
runs
pair

the
verify
and

validity
the

executing

• Bl-level

edit.

ID, levelm, ch, h′, r, σ) to output

Adapt(skθ, T xID, T x′
the new randomness r′ and the signature σ′.
xi

i-th
mutable block, ﬁnding a hash collision by the
i, levelm, ch, h′, r, σ)
Adapt(skθ, xi, x′
and
output (r′, σ′). Bl-level editing is similar to Tx-level
editing, where block Bi changes to B′
i.

Let m as

algorithm,

data

in

PTS
PTS

Edited Data 
Edited Data 
Verification
Verification

...
...

...
.........

Owners
Owners

Modifiers
Modifiers

(cid:316)
(cid:316)

check 
check 

r s
r s
',
',
'
'

If the Tx is valid, append to blockchain
If the Tx is valid, append to blockchain
Run 
Run 

Invalid 
Invalid 

Verify pk m ch h r
Verify pk m ch h r
,
,

',
',

',
',

(
(

,
,

If the Bi is valid, append to blockchain
If the Bi is valid, append to blockchain

check 
check 

iB
iB

ValidateBlock B
ValidateBlock B
i
i

(
(

D
D

bs ﬁ
bs ﬁ
')
')

',
',

)?
)?

Invalid 
Invalid 

PreH
PreH

+ =
+ =

1
1

i
i

H ctr G PreH x r
H ctr G PreH x r

',
',

(
(

(
(

,
,

,
,

i
i

i
i

i
i

check 
check 

PreH +
PreH +
1
i
i
1

'))?
'))?

Privilege Audit
Privilege Audit
Audit sk m m r r
,
,
Run 
Run 
Audit sk m m r r

',
',

(
(

,
,

,
,

ss
ss
,
',
',
,

',
',

ch h
,
,
ch h

')
')

ﬁ
ﬁ

level d
(
(
level d
m
m

,
,

)
)

(cid:317)
(cid:317)

Reward or deduct a deposit
Reward or deduct a deposit

level
level
m
m

 or reward 
 or reward 

deposit
deposit

Fig. 4. Edited data veriﬁcation and Privilege audit in CDEdit.

5) Edited Data Veriﬁcation.: As shown at the top of Fig. 4,
there are two types of Tx-level and Bl-level editing in the
CDEdit. Therefore, we also consider two kinds of data vali-
dation processes: mutable transaction veriﬁcation and mutable
block veriﬁcation.

• Mutable transaction veriﬁcation. Each participant veri-
ﬁes the validity of the received mutable transaction by
executing the V erif y (pk, T x′, ch, h′, r′, σ′) algorithm
with the chameleon public key pk, the message m′ and
the CH key pair (ch, h′). To reduce the veriﬁcation
overhead, the transaction owner is mainly responsible for
the veriﬁcation operation in CDEdit. If the transaction
is valid, the owner will modify the local copy of the
transaction, otherwise rejected.
• Mutable block veriﬁcation. First,

the owner runs the
i, ch, h′, r′, σ′) algorithm to verify the va-
V erif y(pk, x′
in the mutable block. Sec-
lidity of
ond, validate the validity of a mutable block by
V alidateBlockD(Bi), where D is the block’s difﬁculty
level. Third, verify whether the equation P reHi+1 =
H(ctri, P CH(P reHi, x′
in the
current mutable block.

i, r′)) holds by P reHi

the data xi

6) Privilege Audit.: Assume that the owner veriﬁes that the
modiﬁer has malicious behaviour, such as performing more
than n-times edits or stealing higher-level tokens, and the
owner sends a report message to the CA, as shown at the
bottom of Fig. 4. The CA receives a report from the owner,
it executes the Audit(sk, m, m′, r, r′, σ, σ′, ch, h′) algorithm
to audit the modiﬁer for malicious operations. If it has illegal
behaviour, CA will reduce the levelmi of the modiﬁer or even
kick out the modiﬁer group and reward part of the deposit to
the owner. Otherwise, CA will increase the credibility level of
the modiﬁer.

D. Secure Model

In the CDEdit system, we assume that the CA and PTS
are fully trusted and that owners and modiﬁers are untrusted

participants. Owners and modiﬁers may launch a conspiracy
attack where they try to come to perform unauthorized edit-
ing operations. Furthermore, CDEdit considers four security
properties, including indistinguishability, collision resistance,
and EUF-CMA security.

• Indistinguishability. Informally,

indistinguishability re-
quires that the adversary cannot distinguish whether the
randomness r of the Hash is new or was created using
an Adapt algorithm. Deﬁnition 4.1. A CDEdit scheme is
indistinguishable if for any PPT adversary A in the IND
A,CDEdit(λ), AdvIN D
experiment ExpIN D
A,CDEdit(λ) is negligi-
ble in λ.

AdvIND

A,CDEdit(λ) :=| Pr

ExpIND
(cid:2)

A,CDEdit(λ) = 1

(cid:3)

− 1/2 | .

• Collision Resistance. Informally, collision resistance in-
dicates that an insider with a secret key associated with
some of the attributes cannot discover the collision of
hashes associated with the policy. Also, they do not ﬁnd
the collision of hashes related to the key mismatching
policy by KeyGen oracle. Deﬁnition 4.2. A CDEdit
scheme is collision resistance if for any PPT adversary A
in the CR experiment ExpCR
A,CDEdit(λ)
is negligible in λ.

A,CDEdit(λ), AdvCR

AdvCR

A,CDEdit(λ) := Pr

ExpCR

A,CDEdit(λ) = 1

.

(cid:3)

(cid:2)

• EUF-CMA Security. The signature scheme DS is called
Existential Unforgeability Against Adaptive Chosen Mes-
sages Attacks, referred to as EUF-CMA security. Deﬁni-
tion 4.3. A CDEdit scheme is EUF-CMA secure if for any
PPT adversary A, the following advantage is negligible
in λ.

AdvEUF−CMA

A,CDEdit (λ) := Pr hExpEUF−CMA
V. INSTANTIATION AND SECURITY ANALYSIS

A,CDEdit (λ) = 1i .

A. Instantiation

To construct an efﬁcient and secure CDEdit scheme, we
rely on the latest CP-ABE scheme [10], known as FAME, and
the CHET scheme [16]. The FAME uses a hash function H1,
which maps arbitrary binary strings to elements of the group
G. In CDEdit, two types of inputs are given to a hash function
H1: inputs of the form (x, ℓ, t) or that of the form (v, ℓ, t),
where x is an arbitrary string, v is a positive integer, ℓ ∈
{1, 2, 3} and t ∈ {1, 2}. Then, we represent these two inputs
as xℓt and 0vℓt, respectively. Where 0 is used to distinguish
between these two strings. Moreover, we deﬁne the identity of
all participants as vectors and assume that the identity of the
owner IDj = (I1, · · · , Ij ) ∈ (Zq)j, the transaction modiﬁer
identity is levelmi = (I1, · · · , Ii) ∈ (Zq)i, where j ≤ i.

• Setup(1λ): It inputs a security parameter λ as input and
obtain (q, G, H, GT ,
e, g, h), where g is the generator of
group G, h is the generator of group H, (G, H, GT )
b
is groups of order q. Pick (a1, a2, b1, b2, x, y) ← Z∗
q,
{z1, · · · , zk} ← Zq, (d1, d2, d3) ← Zq, and d =
to calculate H1 = ha1 ,H2 = ha2,
d1 + d2 + d3,

 
 
j
Q

e(g, h)d1·a1+d3, T2 =
b

e(g, h)d2·a2+d3.Then,
T1 =
it outputs a master public key mpk = (g, h, H1,
b
H2, T1, T2, {gz1, · · · , gzk }, {hz1, · · · , hzk }) and a master
secret key msk = (a1, a2, b1, b2, gd1, gd2, gd3, {z1, · · · ,
zk}), chameleon key pair (sk, pk) = (x, hx), and PTS
e(g, h)y). We deﬁne a secret
key pair (skpts, pkpts) = (y,
i=0 h · hIi
credential as IDj =
k−i−1 for each user.
b
• T kGen(skpts, pkpts, reqtk, n): It inputs an edit request
reqtk = (type||n||IDj||index), n ∈ N, type and
index are arbitrary strings, to calculate σpts = k +
skpts · H(pkpts||reqtk||kg||deposit)), where kg = k ·
g, k ← Z∗
q , and outputs a privilege token pritk =
(reqtk, σpts, kg, time), where time is the given period.
• KeyGen(sk, θ): It inputs a chameleon secret key sk,
and a set of attributes θ, and picks R ← Zq,
(r1, r2) ← Z∗
q and r = r1 + r2, computes sk0 =
(hb1·r1, hb2·r2, hr, gR). For all y ∈ θ and t = {1, 2},
picks σy ← Zq, compute sky,t = H1(y1t)(b1·r1)/(at) ·
H1(y2t)(b2·r2)/(at) · H1(y3t)(r1+r2)/(at) · g(σy)/(at), and
set sky = (sky,1, sky,2, g−σy ). Then, it picks σ′ ← Zq,
for t = {1, 2}, computes

r1+r2
at

′
σ
at .

b1·r1
at

b2·r2
at

i
Q

sk′

·H1(013t)

·H1(012t)

t = gdt·H1(011t)

·g
(2)
2, gd3, g−σ
and sets sk′ = (sk′
). Then, it computes
mi · gR, sk2 = {gr
sk1 = gd · levelr
1}. Last,
outputs a secret key skθi = (x, sski), where sski =
(sk0, {sky}y∈θ, sk′, sk1, sk2), a modiﬁer’s identity in the
decryption key as levelmi =

i−1, · · · , gr

j=0 g · gIj

k−j−1.

1, sk′

′

• Hash(pk, m, M, IDj): To hash a message m under a
policy (M, π), and an identity IDj, an owner performs
the following. 1) compute p = pkr, where r ← Z∗
q is
a randomness; 2) compute ephemeral trapdoor etd =
H2(R), h′ = hetd. Note that R denote a short bit-string,
R ← Z∗
q ; 3) compute a CH ch = p · h′m; 4) generate
s), where
a veriﬁcation key pair as (sk, vk) = (s, IDj
s = s1 + s2,(s1, s2) ← Z∗
q ; 5) generate a ciphertext on
the message M = (r, R) with the policy (M, π) and
identity IDj, compute ct0 = (H s1
2 ,hs). Then, for
i = {1, · · · , n1} and ℓ = {1, 2, 3}, compute

1 ,H s2

cti,ℓ = H1(π(i)ℓ1)s1 · H1(π(i)ℓ2)s2 ·

(0jℓ1)s1 · H1(0jℓ2)s2](M)i,j .

n2

[H1

Y
j=1

(3)

· T s2

e(g, hd)s), ct1 = ct2 = IDj
b

where, (M)i,j denotes the (i, j)-th element of M. Then,
it computes ct = r ⊕ G(T s1
2 ), ct′ = R ⊕
1
s, ct3 = cts
1, and
H2(
C = (ct0, {cti}i∈n1, ct, ct′, ct1, ct2, ct3). 6) compute
signed message c = hsk+etd, and generate a signature
σ = esk + sk · H2(epk||c), where epk = gesk and
(epk, esk) denotes an ephemeral key pair. Eventually, it
output (m, p, h′, ch, C, c, epk, σ).

• V erif ym(pritk, pkpts): PTS has to verify the validity
of the pritk before proceeding with the modiﬁcation

operation. It inputs a pritk and pkpts, and outputs 1 if
σpts · g = kg + pkpts · H1(pkpts||reqtk||kg||deposit).
• V erif y(pk, m, p, h′, ch, C, c, epk, σ): Each user can ver-
ify whether a given hash (ch, h′) is valid, it outputs
1 if ch = p · h′m and
e(g, ct2)σ =
e(epk, ct1) ·
s.
e(g, ct3)H2(epk||c), where ct1 = ct2 = IDj
b
b
• Adapt(skθi, m, m′, p, h′, ch, C, c, epk, σ, levelmi): The
b
modiﬁer who is granted edit privileges performs the
following operations with the secret key skθi, a new
message m′ (if selected as Bl-level edit
then m′ =
T Xroot||T S), and an identity levelmi; 1) verify that
V erif y(pk, m, p, h′, ch, C, c, epk, σ) is equal to 1; 2)
For obtain the encrypted randomness r, and assuming
that attributes θ in sski satisﬁes the MSP (M, π), then
compute coefﬁcients {λi}i∈I . Now, compute

num =

den =

1 ·

e(sk′
b

ctλi

i,1, sk0,1) ·

e(

b

ctλi

i,3, sk0,3).

Y
i∈I

e(

b
e(
·

Y
i∈I

b

Y
i∈I

ctλi

i,2, sk0,2)

(4)

ctλi

π(i),1, ct0,1) ·

e(sk′
b
π(i),3, ct0,3).

ctλi

Y
i∈I
3 ·

·

e(sk′
b

Y
i∈I

2 ·

ctλi

π(i),2, ct0,2)

Y
i∈I

′

′
s

1, s′

2,(s′

1 + s′

1 · T s2

(5)
and output r = ct ⊕ G(den/num) = ct ⊕ G(T s1
2 ).
Here sk0,1, sk0,2, sk0,3 denote the ﬁrst, second and
third elements of sk0, and the same for ct0. 3) derive
a new randomness r′ = r + (m − m′)etd/x, and
compute p′ = pkr
, where etd = H2(R). 4) generate
a veriﬁcation key pair as (sk′, vk′) := (s′, IDj
), where
2) ← Z∗
s′ = s′
q . 5) generate a ciphertext
C′ on message M ′ = (r′, R) using randomness (s′
2),
under policy (M, π) and identity levelmi. 6) compute
+etd, and generate a signature
signed message c′ = hsk
σ′ = esk′ + sk′ · H2(epk′||c′), where epk′ = gesk′.
Eventually, it output (m′, p′, h′, ch, C′, c′, epk′, σ′).
Correctness. We use the Audit algorithm to ensure the
accountability of CDEdit system. All users can publicly verify
the correctness of a new version of a transaction or block. The
ﬁnal audit is performed by CA and includes the following: 1)
inputs (m, m′, p, p′, h′, ch, C′, c′, epk′, σ, σ′), and verify CH
ch = p · h′m = p′ · h′m
. 2) verify message signature pair
(c, σ) under (epk, vk), and (c′, σ′) under (epk′, vk′). 3) verify
the number of edits. Eventually, it output new levelmi and
accountability record d.

1, s′

′

′

B. Security Analysis

The owners and modiﬁers cannot edit without a CA-issued
privilege token, even if they decrypt an ephemeral trapdoor,
which means this scheme resists a conspiracy attack. As
detailed in Appendix, we have performed a security analysis
of the proposed scheme.

Theorem 5.1. If the CDEdit scheme is based on an indistin-
guishable CHET, then the CDEdit scheme is indistinguishable.

 Setup

1.2

1.0

0.8

0.6

0.4

)
s
(
s
e
m

i
t
n
u
R
e
g
a
r
e
v
A

0.2

0.0

)
s
(
e
m

i
t
n
u
R
e
g
a
r
e
v
A

1.2

 Adapt

 Hash

1.0

 KeyGen

 Verify

m

0.8

 Verify

 Audit

0.6

0.4

0.2

0.0

5
-

)
s

0
1
*
(

e
m

i
t
n
u
R
e
g
a
r
e
v
A

2.2

2.0

1.8

1.6

1.4

1.2

1.0

 TkGen

20

40

60

80

100

20

40

60

80

100

20

40

60

80

100

Number of Participants

Number of Attibutes

Number of Attributes

(a)

(b)

(c)

Fig. 5. The average runtime of system’s algorithms.

Theorem 5.2. If the CDEdit scheme is based on collision
then the

resistant CHET and an IND-CCA2 secure ABE,
CDEdit scheme is collision resistant.

Theorem 5.3. If the digital signature is EUF-CMA secure,

then the proposed CDEdit scheme is EUF-CMA secure.

VI. IMPLEMENTATION AND EVALUATION

To demonstrate the performance of our proposed CDEdit
system, we implement it in Python 3.6.9 using Charm 0.43
framework [17] and on a PC running 64-bit Ubuntu 18.04
LTS with Intel Core i5(1.60GHz×4) and 7.8GiB RAM. We
use MNT224 curve [18] for pairing because it is the best Type-
III curve in PBC, and it has around 96-bit security level [19].
Note that the CDEdit scheme does not change the chain length
but replaces the original blocks with new blocks. Therefore,
the mining difﬁculty and consensus algorithm (e.g., PBFT) of
the actual blockchain is not used as direct inﬂuencing factors.
We simulated the latency time of the CDEdit system for the
different number of participants and sets of attributes. The
implementation code is available on GitHub [20].

TABLE I
AVERAGE RUNNING TIME OF TX-LEVEL AND BL-LEVEL EDITS

Type

Edit Times

Tx-level

Bl-level

n one-time

n-times

n one-time

n-times

Average Runtime
tset + n(ttk + tkey + th + tver +
tverm + tad + tau)
t+(n−1)(th +2tver +tad +tau)
tset + n(ttk + tkey + tverm +
tad + tau)
t + (n − 1)(tver + tad + tau)

∗ tset, ttk, tkey , th, tver , tverm , tad, tau denote the run-
time of algorithms Setup, T kGen, KeyGen, Hash, V erif y,
V erif ym, Adapt, Audit, respectively. t denotes the total run-
time of all algorithms.

We applied CDEdit to an identity management scenario of
IoT devices in a region. We tested the performance of a set of
participating devices and attributes of 10, 20, · · · , 100, respec-
tively. It is shown experimentally that the runtime of Setup
algorithms increases linearly with the increase in the number
of devices and demonstrated in Fig. 5(a). The average running
time is only 1.2s even with 100 devices, which is acceptable
for practical applications. Further, we ﬁxed the number of

100

 n one-time Tx edits

 n-times Tx edit

 n one-time Bl edits

 n-times Bl edit

)
s
(
e
m

i
t
n
u
R
e
g
a
r
e
v
A

80

60

40

20

0

1

4

8

16

32

Number of Times Edit

Fig. 6. Runtime comparison for diversiﬁed editing.

devices to 120 and then experimented with KeyGen, Hash,
and Adapt algorithms to evaluate the relationship between
attribute size and average running time. From Fig. 5(b), it
can be seen that the performance of these algorithms shows a
linear relationship with the number of attributes or the policy
size. Even if the number of attributes is 100, the running time
of KeyGen algorithm is only 0.7s, Adapt algorithm is only
1.11s, and Hash algorithm is only 1.2s. We also evaluated
each validation algorithm to demonstrate performance beneﬁts.
As the number of attributes increases, the running time of
V erif ym algorithm is maintained between (0.0136, 0.042)ms,
V erif y algorithm is preserved between (0.155, 0.198)ms,
and Audit algorithm is supported between (0.34, 0.36)ms.
We have experimented with T kGen algorithms that run in
an average time of about (1.1, 2.2) ×10−5s and shown in
Fig. 5(c). As a result, the running time of each algorithm
of the CDEdit system is acceptable with its availability.
We conducted contrasted experiments with n one-time edits
and n-times edits to implement multi-level editing operations
for privilege tokens in our scheme, respectively. We set the
attribute size to 100, and collated the average running time of
Tx-level and Bl-level edits in n one-time edits and n-times
edits as shown in Table I.

Finally, we set n to 1, 4, 8, 16, 32, respectively. We discuss

 
 
 
 
 
 
 
the inﬂuence of the number of edits on the running time of
Tx-level and Bl-level edits, as shown in Fig. 6. In Bl-level
editing, it is assumed that a complete chain is already available,
regardless of the runtime of block generation. The n-times edit
has less runtime than n one-time edits because there is no need
to compute additional setup, token and keygen algorithms per
round. And the advantage becomes more and more obvious as
the number of edits increases.

VII. RELATED WORK

Since the concept of redactable blockchain was proposed
[12], exploring the management and distribution of edit-
ing privileges has always been the focus of researchers.
Ashritha [21] et al. proposed a secret-sharing based redactable
blockchain scheme that implements the editing operation by
securely distributing CH trapdoor keys to a predeﬁned group of
veriﬁers and through a voting consensus process. Nevertheless,
complex cryptographic tools to manage CH trapdoor keys are
inefﬁcient when the group of veriﬁers is large. Dealer et al.
[13] introduced a PCH function to control modiﬁcations in a
permissioned blockchain by CHET [16] at the ﬁne granularity
of trapdoor keys to the editor’s privilege. Any participant
in CHET who has a long-term trapdoor and an ephemeral
trapdoor can quickly compute the new randomness r′. But,
PCH is exposed to the risk of conspiracy attacks, where the
modiﬁer and owner can collide with each other to ﬁnd a set
of attributes that satisfy.

Concurrent and Independent Work. Puddu et al. [22]
have proposed µ-chain with mutable transactions, whose edit-
ing privileges are determined by the policy constructed from
the sender. However, transactions in the µ-chain are encrypted,
which reduces the audibility of the data written. Deuber et al.
[23] proposed a redactable blockchain with consensus-based
voting in a permissionless blockchain. The edit operation is
executed whenever and only when the user’s edit request
collects enough votes from the miner. Similarly, Thyagarajan
et al. [24] proposed a compatible Reparo generic protocol
and instantiated it on typical blockchain applications like
Ethereum and Bitcoin. Li et al. [25] proposed a redactable
blockchain with an instant editing function in the permission-
less blockchain, where the blockchain editing is decided jointly
by selecting a committee vote. Unfortunately, several of the
above redactable blockchains consensus-based voting suffer
from defects such as too long voting cycles, poor scalability,
and inefﬁciency. If the edit request cost is low, the system is
vulnerable to DDoS attacks and Sybil attacks [26]. We list the
comparison of utility features in the current major solutions
shown in Table II.

VIII. CONCLUSION

In this work, we proposed a highly applicable redactable
blockchain with controllable editing privilege and diversiﬁed
editing types. The proposed scheme supports multi-level edit-
ing at both Tx-level and Bl-level in blockchain and effec-
tively prevents malicious editing and conspiracy attacks. The
instantiation shows that the framework can be extended to

other permissioned blockchain applications. In future work,
we aim to further improve system performance and reduce
performance overhead, as well as extend to permissionless
blockchain systems.

REFERENCES

[1] S. Hargreaves, and S. Cowley, ”How porn links and ben bernanke snuck

into bitcoin’s code,” (2013).

[2] J. Mathew, ”Bitcoin: Blockchain could become ‘safe haven’for hosting

child sexual abuse images,” (2015).

[3] P. Voigt, and A. Von dem Bussche, ”The eu general data protection reg-
ulation (gdpr),” A Practical Guide, 1st Ed., Cham: Springer International
Publishing 10 (2017): 3152676.

[4] H. Krawczyk, and T. Rabin, ”Chameleon signatures,” Proc of the
Network and Distributed System Security Symp (NDSS 2000)Reston,
VA, USA: The Internet Society, 2000: 143-154.

[5] D. Zhang, J. Le, X. Lei, et al, ”Exploring the redaction mechanisms of
mutable blockchains: A comprehensive survey,” International Journal of
Intelligent Systems 36.9 (2021): 5051-5084.

[6] Y. Tian, N. Li, Y. Li, et al, ”Policy-based Chameleon Hash for
Blockchain Rewriting with Black-box Accountability,” Annual Com-
puter Security Applications Conference. 2020.

[7] S. Xu, J. Ning, J. Ma, et al, ”K-Time Modiﬁable and Epoch-Based
Redactable Blockchain,” IEEE Transactions on Information Forensics
and Security 16 (2021): 4507-4520.

[8] Y. Yuan, and F. Y. Wang, ”Editable blockchain: models, techniques and

methods,” Acta Automatica Sin-ica 46.5 (2020): 831-846.

[9] Hyperledger. https://www.hyperledger.org.
[10] S. Agrawal, and M. Chase, ”FAME: fast attribute-based message encryp-
tion,” Proceedings of the 2017 ACM SIGSAC Conference on Computer
and Communications Security. 2017: 665-682.

[11] J. Garay, A Kiayias, and N. Leonardos, ”The bitcoin backbone protocol:
Analysis and applications,” Annual
international conference on the
theory and applications of cryptographic techniques. Springer, Berlin,
Heidelberg, 2015: 281-310.

[12] G. Ateniese, B. Margri, D. Venturi,

”Redactable
blockchain–or–rewriting history in bitcoin and friends,” 2017 IEEE
European symposium on security and privacy (EuroS&P). IEEE, 2017:
111-126.

al,

et

[13] D. Derler, K. Samelin, D. Slamanig, et al, ”Fine-Grained and Controlled
Rewriting in Blockchains: Chameleon-Hashing Gone Attribute-Based,”
IACR Cryptol. ePrint Arch. 2019 (2019): 406.

[14] A. Beimel, ”Secure schemes for secret sharing and key distribution,”

(1996).

[15] C. P. Schnorr, ”Efﬁcient signature generation by smart cards,” Journal

of cryptology 4.3 (1991): 161-174.

[16] J. Camenisch, D. Derler, and S. Krenn, et al, ”Chameleon-hashes with
trapdoors,” IACR International Workshop on Public Key

ephemeral
Cryptography. Springer, Berlin, Heidelberg, 2017.

[17] J. A. Akinyele, C. Garman, I. Miers, et al, ”Charm: a framework for
rapidly prototyping cryptosystems,” Journal of Cryptographic Engineer-
ing 3.2 (2013): 111-128.

[18] A. Miyaji, M. Nakabayashi, and S. Takano, ”Characterization of elliptic
curve traces under FR-reduction,” International Conference on Informa-
tion Security and Cryptology. Springer, Berlin, Heidelberg, 2000.
[19] B. Yang, K. Yang, Y. Qin, et al, ”DAA-TZ: an efﬁcient DAA scheme
for mobile devices using ARM TrustZone,” International Conference on
Trust and Trustworthy Computing. Springer, Cham, 2015.

[20] 2021. CDEdit: A Highly Applicable Redactable Blockchain with
and Diversiﬁed Editing Types.

Controllable Editing Privilege
https://github.com/Cryptocxf/CDEdit. (2021).

[21] K. Ashritha, M. Sindhu, and K. V. Lakshmy, ”Redactable blockchain
using enhanced chameleon hash function,” 2019 5th International Con-
ference on Advanced Computing & Communication Systems (ICACCS).
IEEE, 2019.

[22] I. Puddu, A. Dmitrienko, and S. Capkun, ”µchain: How to forget without
hard forks,” IACR Cryptology ePrint Archive 2017/106 (2017).
[23] D. Deuber, B. Magri, and S. A. K. Thyagarajan, ”Redactable blockchain
in the permissionless setting,” 2019 IEEE Symposium on Security and
Privacy (SP). IEEE, 2019.

TABLE II
COMPARISON AMONG CURRENT REDACTABLE BLOCKCHAIN SOLUTIONS AND OURS

Schemes
Ateniese et.al. [12]
Deuber et.al. [23]
PCHBA [6]
KERB [7]
CDEdit

Type
Permissioned
Permissionless
Permissioned
Permissioned
Permissioned

Core Mechanism
CH,PKI
Consensus/Voting
PCH, Signatues
CH, Signatues

Redaction
Bl-level
Tx-level
Tx-level
Tx-level

PCH, Signatues,PTS Multi-level

∗Multi-level: Supporting both Tx-level and Bl-level. N/A: Not applicable.

n-time
×
×
×
X
X

Veriﬁcation
×
X
X
X
X

Collusion Resistant
×

N/A
X
X
X

[24] S. A. K. Thyagarajan, A. Bhat, B. Magri, et al, ”Reparo: Publicly
veriﬁable layer to repair blockchains,” arXiv preprint arXiv:2001.00486
(2020).

[25] X. Li, J. Xu, L. Yin, et al, ”Escaping from Consensus: Instantly
Redactable Blockchain Protocols in Permissionless Setting,” Cryptology
ePrint Archive (2021).

[26] J. R. Douceur, ”The sybil attack,” International workshop on peer-to-

peer systems. Springer, Berlin, Heidelberg, 2002.

APPENDIX

Proof of Theorem 5.1. The reduction is executed between
an adversary A and a simulator S. Assume that adversary A
can guess the CH value with a nonnegligible probability in
the proposed CDEdit. Let simulator S denote a distinguish
against CHET, who is given a chameleon public key pk∗ and
a HashOrAdapt oracle, aims to break the indistinguishability
of CHET. Let q be an upper bound on the queries made
to the Hash oracle. S randomly chooses i ∈ {1, · · · , q}
as a guess for the index of the HashOrAdapt query. Then,
the distinguisher S’s challenger directly hashes a message
Hash(pk∗, m) → (h, r).

• Setup: S generates n owners and corresponding identity

{IDj}, and sets up the game for A.

• Challenges: S randomly selects an owner as of the at-
tribute policy and sets its chameleon public key to pk∗ . S
can honestly generate a decryption key for any transaction
modiﬁer associated with that IDj and attribute set θ. If
A submits a tuple (mo, m1, A) in the i-th query, then
S randomly choose b ∈ {0, 1}, and obtains the CH
(hb, rb) from the HashOrAdapt oracle on the message
(m0, m1). Further, according to the protocol, S simulates
the message signature pair (c, σ) and the ciphertext C.
• Guess: Finally, S returns (hb, rb, σb) to A. S follows
the results of A output. If A guesses the random bit
correctly, S can break the indistinguishability of CHET.

Proof of Theorem 5.2. We prove the theorem in a sequence
of Game i ∈ {0, 1, 2, 3}, denoting by P r[Si] the success
probability of the adversary A in Game i. Assume that the
queries number to the Hash′ oracle be denoted by at most q.
• Game 0: This is the original CR security experiment for

collision resistant.

• Game 1: As Game 0, but S randomly guess the index
i∗ corresponding to the Hash′ oracle which return the
CH (h∗, C∗) which will be attacked by the adversary.
We store the hash (h∗, C∗) as well as the corresponding

randomness r∗ and the ephemeral trapdoor etd∗. If during
the simulation we detect that the guess is wrong, we will
abort. Otherwise the same winning probability in Game
1 as in Game 0, and has P r[S1] = P r[S0]/q.

• Game 2: As Game 1, but whenever S receives an adapt
query for a hash (h, C), where C = C∗ and not decrypt,
but directly adapt using etd∗. The same winning probabil-
ity in Game 2 as in Game 1 under the perfect correctness
of the encryption scheme, and has P r[S2] = P r[S1].
• Game 3: As Game 2, but S changes the simulation
of the Hash algorithm within the i∗-th query to the
QABE Enc(0|etd|, A)
Hash′
and locally store etd.

CHET oracle, and run C ←

of

the

,ABE

IND-CCA2

We claim that Game 2 and Game 3 are indistinguishable
i.e.,
QABE,
under
security
|P r[S3] − P r[S2]| 6= AdvIN D−CCA2
(λ). Next, we show that
we can use an adaptive IND-CCA challenger to effectively
interpolate between Game 2 and Game 3. Get mpk from
the IND-CCA challenger, make msk → ⊥, and continue
the respective oracles
honestly with other setups. Then,
provided by the challenger are used to simulate queries to
the key generation oracle. After the i∗-th query to Hash′
oracle, output (etd, 0|etd|, A, state) to the challenger
to
obtain (C∗, state), and set C → C∗. Further, for adaptive
queries with hash returned at the i∗-th query to Hash′, we
directly use etd for adapt without prior decryption. Note that
once it turns out that our guess of the index i∗ is wrong, this
ensures that we never have to answer queries which involve
queries against the challenger’s oracle. This means that we
can simulate Game 2 if the challenger chooses b = 0, and we
can simulate Game 3 if b = 1.

Proof of Theorem 5.3. Let simulator F be given a public key
pk∗ and a signature oracle OSign used to forge DS with the
aim of breaking the EUF-CMA security of DS. F randomly
chooses a CH, and setup its veriﬁcation key as pk∗. Then, F
randomly chooses i ∈ {1, 2, · · · , q} as a guess for the index of
the forgery with respect to that CH. F can honestly completes
the remainder of Setup. F obtains a signature σ from his
signature oracle OSign. F honestly generates the CH and the
ciphertext and returns (h, r, σ, C, c) to adversary A. Due to
the homomorphism of DS, the message-signature pair as well
as the veriﬁcation key can be perfectly modeled by F for any
adaptive query, and additionally the ephemeral trapdoor etd is

chosen by F . F records all the simulated CH in a set Q. When
forging attack occurs, i.e., A outputs (h∗, r∗, σ∗, C∗, c∗), F
check the following conditions:

• The forgery attack occurs on the q-th guess;
• The ciphertext C∗ encrypts the ephemeral trapdoor etd;
• The message-signature pair (c∗, σ∗) links to pk∗.
• The message-signature pair (c∗, σ∗) /∈ Q.
• 1 ← V erif y(vk∗, c∗, σ∗) and 1 ← V erif y (h∗, m∗, r∗).

