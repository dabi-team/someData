2
2
0
2

y
a
M
7
1

]

R
C
.
s
c
[

1
v
9
2
5
8
0
.
5
0
2
2
:
v
i
X
r
a

F3B: A Low-Latency Commit-and-Reveal Architecture to
Mitigate Blockchain Front-Running

Haoqian Zhang, Louis-Henri Merino, Vero Estrada-Galiñanes, Bryan Ford
École polytechnique fédérale de Lausanne(EPFL)
Lausanne, Switerland
{haoqian.zhang,louis-henri.merino,vero.estrada,bryan.ford}@epfl.ch

ABSTRACT
Front-running attacks, which benefit from advanced knowledge of
pending transactions, have proliferated in the cryptocurrency space
since the emergence of decentralized finance. Front-running causes
devastating losses to honest participants—estimated at $280M each
month—and endangers the fairness of the ecosystem. We present
Flash Freezing Flash Boys (F3B), a blockchain architecture to ad-
dress front-running attacks by relying on a commit-and-reveal
scheme where the contents of transactions are encrypted and later
revealed by a decentralized secret-management committee once
the underlying consensus layer has committed the transaction. F3B
mitigates front-running attacks because an adversary can no longer
read the content of a transaction before commitment, thus pre-
venting the adversary from benefiting from advance knowledge
of pending transactions. We design F3B to be agnostic to the un-
derlying consensus algorithm and compatible with legacy smart
contracts by addressing front-running at the blockchain architec-
ture level. Unlike existing commit-and-reveal approaches, F3B only
requires writing data onto the underlying blockchain once, estab-
lishing a significant overhead reduction. An exploration of F3B
shows that with a secret-management committee consisting of 8
and 128 members, F3B presents between 0.1 and 1.8 seconds of
transaction-processing latency, respectively.

KEYWORDS
security & privacy, decentralized finance, front-running

1 INTRODUCTION
Front-running is the practice of benefiting from advanced knowl-
edge of pending transactions by entering into a financial posi-
tion [1, 4, 16]. While benefiting some entities involved, this practice
puts others at a significant financial disadvantage, leading regula-
tors to judge this behavior as illegal (and unethical) in traditional
markets [16].

Once a significant problem for traditional (centralized) markets
addressed via regulations, front-running has now become a signif-
icant problem for decentralized finance (DeFi), given blockchain
transactions’ openness and pseudonymous nature and the difficul-
ties involved with pursuing miscreants across numerous jurisdic-
tions [12, 16, 30]. Since transactions are transparent before com-
mitment, adversaries can take advantage of the contents of those
pending transactions for their own financial gain by, for example,
creating their own transactions and positioning them in a specific
sequence with respect to the targeted transaction [2, 12, 16].

Front-running negatively impacts all honest DeFi actors, but
automated market makers (AMM) are particularly vulnerable due to
price slippage [2], i.e., the difference between expected and executed

1

prices. An estimate shows that front-running attacks amount to
$280 million in losses for DeFi actors each month [33]. In addition,
front-running attacks threaten the underlying consensus layer’s
security by incentivizing unnecessary forks [12, 14].

While there are existing approaches to address front-running
attacks, they are either inefficient or restricted to a specific applica-
tion or consensus algorithm. Namecoin, an early example of using
a commit-and-reveal approach to mitigate front-running attacks,
requires two rounds of communication to the underlying block-
chain [21]. Submarine further improves the commit-and-reveal
approach by hiding the addresses of smart contracts involved, but
induces three rounds of communication to the underlying block-
chain [21, 31], bringing significant latency overhead. Other solu-
tions focus on specific applications, e.g., FairMM only applies to
the market-maker-based exchange [10]. Other approaches apply
only to a specific consensus algorithm [42, 45].

We present Flash Freezing Flash Boys1 (F3B), a new blockchain
architecture with front-running protection that exhibits low trans-
action processing latency overhead while remaining legacy com-
patible with both the underlying consensus algorithm and smart
contract implementations. F3B addresses front-running by adopting
a commit-and-reveal design that involves encrypting transactions
and revealing them after they are committed by the consensus
group, as presented in Figure 1. By encrypting transactions, adver-
saries no longer have foreknowledge of the contents of transactions,
hindering their ability to launch successful front-running attacks.
While adversaries may launch speculative front-running attacks,
where the adversary guesses the contents of the transaction based
on side-channel information, these attacks have a greater chance
of failure and may prove to be unprofitable [2].

F3B builds on Calypso [25], an architecture that enables on-chain
secrets by introducing a secret-management committee (SMC) that
reveals these on-chain secrets when designated. In our setup, the on-
chain secrets are the encrypted transactions and the designated re-
veal period occurs when the consensus group irreversibly commits
the transaction on the blockchain. Once a transaction is revealed,
the consensus nodes can proceed with verifying and executing
a transaction. At this point, it is too late for malicious actors to
launch a front-running attack since the consensus group has already
irreversibly ordered the transaction on the blockchain.

To achieve practical front-running protection, the F3B architec-
ture must address several challenges: a) preventing a single point
of failure or compromise in the decryption process, b) mitigating
spamming of inexecutable encrypted transactions onto the under-
lying blockchain, and c) limiting latency overhead. To withstand

1The name Flash Boys comes from a popular book revealing this aggressive market-
exploiting strategy on Wall Street in 2014 [30].

 
 
 
 
 
 
known as mempool. Notably, these transactions are not yet irre-
versibly ordered, opening up the possibility for front-running attacks.
Further, under certain probabilistic consensus algorithms, such as
Proof-of-Work(PoW) or Poof-of-Stake(PoS), a transaction inserted
onto the blockchain can still be reordered by inducing a fork of the
underlying blockchain. Hence, to guarantee irreversible ordering
for probabilistic consensus algorithms, a transaction must receive
enough block confirmations—the number of blocks succeeding the
block containing the transaction [11, 26, 35].

2.2 Smart Contract & Decentralized Exchange
A smart contract is an executable computer program modeled af-
ter a contract or an agreement that executes automatically [41]. A
natural fit for smart contracts is on top of fault-tolerant consen-
sus algorithms, such as PBFT-style, PoW, and PoS, ensuring their
execution and integrity by all consensus nodes [24, 35, 49].

While Bitcoin utilizes smart contracts [35], it was not until
Ethereum’s introduction that the blockchain space realized Turing-
complete smart contracts, the backbone necessary for the creation
of complex decentralized exchanges. To operate complex smart con-
tracts, users need to pay gas, a pseudo-currency representing the
execution cost by miners. However, given the expressive nature of
smart contracts, they come with significant risks, from inadvertent
vulnerabilities to front-running. Front-running is, unfortunately,
exhibited by the lack of guarantees that the underlying blockchain
provides in terms of ordering while transactions wait to be com-
mitted.

2.3 Front-running Attacks & Mitigation
The practice of front-running involves benefiting from advanced
knowledge of pending transactions [1, 4, 16]. In itself, knowledge
of pending transactions is harmless but having the ability to act
on this information is where the true problem lies. In the context
of blockchains, a front-running attack is performed by an adver-
sary who can influence the order of transactions, provided that
transactions in the mempool are completely in the clear.

Cryptocurrencies mainly suffer three types of front-running at-
tacks [16]: displacement: displacing a targeted transaction with a
new transaction, insertion: inserting a transaction before the tar-
geted transaction, and suppression: delaying a targeted transac-
tion indefinitely. A recent study looking at the past five years of
Ethereum’s history has found that the most common attack is an
insertion attack, the most profitable attack is a displacement attack
and the most revenue-generating attack is a suppression attack [47].
In an ideal world, front-running protection would consist of an
immediate global ordering of each transaction as they are created
to prevent attackers from changing their order. In reality, such
global ordering is practically impossible, even if all participants
were honest due to clock synchronization issues [13] and consis-
tency problems if two transactions have the exact same time. By
including malicious participants, timings can naturally easily be
manipulated. A more practical solution is to encrypt transactions
such that the consensus group has no knowledge about transactions
when ordering them. This solution mitigates front-running attacks,
as an attacker cannot benefit from pending transactions if they are
encrypted.

Figure 1: Senders publish encrypted transactions to the con-
sensus group. Once the transactions are no longer pending,
the secret-management committee releases the keys.

the single point of failure or compromise, we adopt threshold cryp-
tosystems. To mitigate spamming, we introduce a storage fee for
storing encrypted transactions along with the traditional execu-
tion fee (e.g., Ethereum gas) and let free market forces determine
the price. To limit the latency overhead, we require F3B to only
write data once onto the underlying blockchain by delaying the
transaction execution time until commitment.

We implemented a prototype of F3B in Go [20]. We use Byz-
Coin [24], a state-of-art PBFT-style consensus protocol as our un-
derlying blockchain for our experiment. We model the Ethereum
blockchain with 13 seconds block time [5] and vary the number of
block confirmations before a transaction is considered irreversible.
Our analysis shows that for a committee size of 128, the latency
overhead is 1.77 seconds, equivalent to a low latency increase of
0.68% with respect to Ethereum blockchain under 20 block confir-
mations; in comparison, Submarine exhibits 200% latency overhead
since Submarine requires three rounds of communication with the
underlying blockchain [8, 31].
Our key contributions are:
(1) To our knowledge, this is the first work to systematically
evaluate threshold encryption at the blockchain architecture
layer for front-running protections at this level of scalability.
(2) An experimental analysis shows F3B’s viability by demon-
strating low latency overhead with respect to Ethereum.

2 BACKGROUND
In this section, we present a brief background on blockchain and
smart contracts for definition purposes, introduce background on
front-running attacks and various mitigation strategies and describe
a real-world DeFi actor that is significantly vulnerable to these
attacks: the Automated Market Marker (AMM).

2.1 Blockchain & Transaction Ordering
A blockchain is an immutable append-only ledger of ordered trans-
actions. However, its transactions go through a series of stages
before they are finally committed—irreversibly ordered—on the
blockchain. After a sender creates a transaction, one needs to prop-
agate the transaction among the consensus nodes, who then place
the transaction in a pool of pending transactions, most commonly

2

Secret-management committee(1) Publish encrypted transactionsSenders(2) Release keysafter commitmentConsensus Group2.4 Automated Market Maker
AMM is a decentralized exchange built on liquidity pools—pools of
assets provided by the exchange—rather than conventional order
books. AMM allows any user to trade between different assets using
the liquidity pool as the counterpart.

Consider an AMM’s liquidity pool holding two assets, 𝜏1 and 𝜏2,
whose balances are 𝑟1 and 𝑟2, respectively. When using the constant
product model, the total amount of 𝑟1𝑟2 remains constant when
carrying out a trade between these two assets. The rule indicates
that the larger the input Δ𝑟1 of trade, the smaller the exchange rate
between 𝑟2 and 𝑟1. We can intuitively reason that large transactions
with respect to the size of the liquidity pool cause significant price
slippage indicated by the difference between expected and executed
prices.

By launching a sandwich attack, i.e., an attack consisting of
one front-run and one back-run transaction with respect to the
targeted transaction, front-running actors can then profit from this
price slippage effect [2]. Fundamentally, the front-run transaction
reduces the exchange rate, while the back-run transaction benefits
from the improved exchange rate caused by the execution of the
victim’s transaction.

To provide long-term orders, Paradigm introduces the notion of
a scheduled AMM, allowing a trade not to be executed immediately
but in the future at a particular block height [15]. Smart contracts,
however, then store these scheduled AMM inputs, making it easier
for an adversary to launch sandwich attacks.

A natural approach to hinder adversaries’ exploitation of front-
running is to blind transaction inputs, such as to ensure the adver-
sary does not know the direction of the exchange: 𝜏1 to 𝜏2 or 𝜏2 to
𝜏1. Nevertheless, these actors can still launch a speculative sand-
wich attack using side-channels, such as determining the sender’s
balance for 𝜏1 and 𝜏2 and examining past transaction history, with
increased difficulty and cost but remains profitable [2].

A further improvement is to encrypt the entire transaction, not
only transaction inputs, effectively hiding the smart contract ad-
dress involved and rendering the speculative attack even harder
since an attacker needs to first infer the smart contract’s address.

to verify and execute the transaction in the execution order that
the commit transaction was committed on the blockchain.

This simple strawman mitigates front-running attacks since the
execution order is determined by the commit transaction and the
contents of the commit transaction do not expose the contents of
the reveal transaction but this strawman presents some notable
challenges: a) the sender must continuously monitor the blockchain
to determine when to reveal her transaction, b) the sender may not
be able to reveal her transaction due to a cryptokitties storm or
blockchain DoS attacks [16], c) this approach is subject to output
bias as consensus nodes, or sender may deliberately choose not
to reveal certain transactions after commitment [2], and d) this
approach has a significant latency overhead of over 100% given that
the sender must now send two transactions instead of one.

3.2 Strawman II: The Trusted Custodian
A straightforward method to remove the sender from the equation
after sending the first commit transaction is by employing a trusted
custodian. This commit transaction would then consist of the neces-
sary information for the trusted custodian to reveal the transaction
after the consensus group has committed the transaction on the
underlying blockchain.

This strawman also mitigates front-running attacks as the nodes
cannot read the content of the transaction before ordering but sig-
nificantly improves upon the challenges presented in the previous
strawman. However, the trusted custodian presents a single point of
failure: consensus nodes cannot decrypt and execute a transaction
if the custodian crashes. In addition, the trusted custodian repre-
sents a single point of compromise where the trusted custodian
may secretly act maliciously, such as colluding with front-running
actors for their own share of the profit. Instead, by employing a
decentralized custodian, we can mitigate the single point of fail-
ure and compromise issue and significantly make collusion more
difficult.

4 SYSTEM OVERVIEW
This section presents F3B’s system goals, architecture, and models.

3 STRAWMAN PROTOCOLS
In order to explore the challenges inherent in building a framework
like F3B, we first examine a couple of promising but inadequate
strawman approaches, simplified from state-of-art front-running
techniques [8, 31].

4.1 System Goals
Our system goals inspired by our strawman protocols (§3) are:

• Front-running protection: Preventing entities from launch-

ing front-running attacks.

• Decentralization: Mitigating a single point of failure or

3.1 Strawman I: Sender Commit-and-Reveal
The first strawman has the sender create two transactions: a com-
mit and a reveal transaction. The reveal transaction contains the
sensitive inputs that could give an adversary the necessary informa-
tion to launch a front-running attack while the commit transaction
namely contains a commitment (e.g. hash) of the reveal transaction
to prove the sender’s intent to transact at a specific time without
giving the sender the ability to change the contents of the reveal
transaction. The sender will proceed with propagating the com-
mit transaction and wait until it is included inside a block by the
consensus group before releasing the reveal transaction. Once the
reveal transaction is propagated, the consensus group can proceed

compromise.

• Confidentiality: Revealing a transaction only after the un-

derlying consensus layer commits it.

• Compatibility: Remaining agnostic to the underlying con-

sensus algorithm and smart contract implementation.

• Low latency overhead: Exhibiting low latency transaction-

processing overhead.

4.2 Architecture Overview
F3B, shown in Figure 1, mitigates front-running attacks by working
with a secret-management committee to manage the storage and
release of on-chain secrets. Instead of propagating their transac-
tions in cleartext, the sender now encrypts their transactions and

3

i.e., if an honest node or trustee broadcasts a message, and that
all honest nodes and trustees receive the message within a known
maximum delay [37].

4.4 Threat Model
We assume that the adversary is computationally bounded, that
cryptographic primitives we use are secure, and that the Diffie-
Hellman problem is hard. We further assume that all messages are
digitally signed, and the consensus nodes and the secret-manage-
ment committee only process correctly signed messages.

The secret-management committee has 𝑛 trustees, which 𝑓 can
fail or behave maliciously. We require 𝑛 ≥ 2𝑓 + 1 and set the secret-
recovery threshold to 𝑡 = 𝑓 + 1. We assume that the underlying
blockchain is secure: e.g., that at most 𝑓 ′ of 3𝑓 ′ + 1 consensus nodes
fail or misbehave in a PBFT-style blockchain, or the adversary
controls less than 50% computational power in a PoW blockchain
like Bitcoin or Ethereum.

We assume that attackers do not launch speculative front-running
attacks [2] but present a discussion on some mitigation strategies
to reduce side channel leakage in §10.

4.5 Blockchain Layer Approach
We can categorize front-running mitigation approaches into two
layers—the blockchain layer [8, 21, 31] and the application layer [10,
27, 34]. F3B is a systematic approach at the blockchain layer, ex-
hibiting some fundamental trade-offs.

On the one hand, blockchain layer approaches a) offer protection
to all smart contracts at once while an application layer approach
would require protection individually [21, 31], b) have access to
all transaction fields, ensuring that they can hide fields that are
not accessible from the application layer (e.g., the smart contract
address), and c) provide compatibility with existing smart contracts.
On the other hand, blockchain layer approaches a) cannot deal
with front-running attacks that benefit from time-delayed transac-
tions at the application layer (e.g., scheduled AMM) and b) require
modification to the underlying blockchain (e.g. scheduled hard
fork).

5 F3B PROTOCOL
We introduce the F3B’s protocol in this section, starting with pre-
liminaries that offer necessary background knowledge and then
presenting the full protocol that captures F3B’s detailed design.

5.1 Preliminaries
This subsection outlines a few preliminary knowledge, such as
the definition of transaction commitment and the cryptographic
primitives used in F3B.

Modeling the Underlying Blockchain. To compare F3B’s impact,
we model the underlying blockchain to involve a consensus proto-
col that commits transactions into a block linked to a previous block.
We define the underlying’s block time as 𝐿𝑏 seconds, e.g., on aver-
age, Ethereum has a block time of 13 seconds [5]. For PBFT-style
consensus algorithms, a transaction is committed once introduced
into a block. For probabilistic consensus algorithms (e.g., PoW or
PoS), a transaction is committed only after a certain number of

Figure 2: F3B per-transaction protocol steps: (1) Sending
an encrypted transaction to the underlying blockchain, (2)
Waiting for the transaction commitment, (3) Releasing the
key and executing the transaction

stores the corresponding secret keys with the secret-management
committee. Once the transaction is committed, the secret-manage-
ment committee releases the secret keys so that consensus nodes
of the underlying blockchain can verify and execute transactions.
Overall, the state machine replication of the underlying blockchain
is achieved in two steps: the first is about ordering transactions, and
the second is about the execution of transactions. As long as the
majority of trustees in the secret-management committee is secure
and honest and the key is revealed to the public when appropriate,
each consensus node can always maintain the same state.

Notably, F3B encrypts the entire transaction, not just inputs, as
other information such as the smart contract address may provide
enough information to launch a probabilistic front-running attack,
such as the Fomo3D attack [16] or a speculative attack [2].

4.3 System and Network Model
F3B’s architecture consists of three components: senders that pub-
lish (encrypted) transactions, the secret-management committee
that manages and releases secrets, and the consensus group that
maintains the underlying blockchain. While F3B supports various
consensus algorithms, such as PoW like Ethereum and PBFT-style
consensus algorithms like ByzCoin [24], F3B does require a forked
instance of the underlying blockchain to allow the consensus group
to commit encrypted transactions and process them after revealing
their contents. In a permissioned blockchain, the secret-manage-
ment committee and the consensus nodes can consist of the same
set of servers. For clarity, however, we discuss them as separate
entities. In addition, we interchangeably use the name “Alice” to
represent a generic sender. We assume that the membership of
the secret-management committee is static, but we discuss group
membership reconfiguration in §7.

For the underlying network, we assume that all honest blockchain
nodes and trustees of the secret-management committee are well
connected, that their communication channels are synchronous,

4

SenderSecret-managementcommitteeConsensusGroupWriteTransaction(ctx,ck)StoreACK/NACKBlockchainHeightBlockchainHeightWaitSharesofkExecutetxACK/NACK(1)(2)(3)additional blocks have been added to the chain (also known as
block confirmations2). We thus define that a transaction is com-
mitted after 𝑚 block confirmations. Thereby, in our baseline, the
transaction latency3 is 𝑚𝐿𝑏 . For PBFT-style consensus, the required
𝑚 is 1. Further, we assume that the underlying blockchain has a
throughput of 𝑇𝑏 tps.

Shamir Secret Sharing. A (𝑡, 𝑛)-threshold secret sharing scheme
enables a dealer to share a secret 𝑠 among 𝑛 trustees such that any
group of 𝑡 ≤ 𝑛 or more trustees can reconstruct 𝑠, but any group less
than 𝑡 trustees learn no information about 𝑠. While a simple secret
sharing scheme assumes an honest dealer, verifiable secret sharing
(VSS) allows the trustees to verify that the shares they received are
valid [17]. Public verifiable secret sharing (PVSS) further improves
VSS to allow a third party to check all shares [43].

Distributed Key Generation(DKG). DKG is a multi-party (𝑡, 𝑛)
key-generation process to collectively generate a private-public
key pair (𝑠𝑘, 𝑝𝑘) without relying on a single trusted dealer; each
trustee 𝑖 obtains a share 𝑠𝑘𝑖 of the secret key 𝑠𝑘, and collectively
obtains a public key 𝑝𝑘 [18]. Any client can now use 𝑝𝑘 to encrypt
a secret, and at least 𝑡 trustees must cooperate to retrieve this
secret [44].

5.2 Protocol Outline
Setup. At each epoch, the secret-management committee
5.2.1
runs a DKG protocol to generate a private key share 𝑠𝑘𝑖
𝑠𝑚𝑐 for each
trustee and a collective public key 𝑝𝑘𝑠𝑚𝑐 . To offer chosen ciphertext
attack protection and to verify the correctness of secret shares, we
utilize the TDH2 cryptosystem containing NIZK proofs [44].

5.2.2 Per-Transaction Protocol. We unpack the per-transaction pro-
tocol (Figure 2) as follows:

(1) Write Transaction: Alice, as the sender, first generates a sym-
metric key 𝑘 and encrypts it with 𝑝𝑘𝑠𝑚𝑐 , obtaining the re-
sulting ciphertext 𝑐𝑘 . Next, Alice creates her transaction and
symmetrically encrypts it using 𝑘, denoted as 𝑐𝑡𝑥 = 𝑒𝑛𝑐𝑘 (𝑡𝑥).
Finally, Alice sends (𝑐𝑡𝑥 , 𝑐𝑘 ) to the consensus group, who
writes the pair onto the blockchain.

(2) Wait for confirmations: The secret-management committee
waits for Alice’s transaction (𝑐𝑡𝑥 , 𝑐𝑘 ) to be committed on the
blockchain (after 𝑚 block confirmations).

(3) Key Reconstruction: Once committed, each secret-manage-
ment committee trustee reads 𝑐𝑘 from Alice’s transaction and
releases their decrypted share of 𝑘 along with a NIZK proof
of correctness for the decryption process. Consensus nodes
then verify the decrypted shares and use them to reconstruct
𝑘 by Lagrange interpolation of shares when there are at least
𝑡 valid shares. The consensus group finally symmetrically
decrypts the transaction 𝑡𝑥 = 𝑑𝑒𝑐𝑘 (𝑐𝑡𝑥 ) using 𝑘, allowing
them to verify and execute 𝑡𝑥. We denote the time for the
entire key reconstruction step as 𝐿𝑟 .

2For example, for Ethereum transactions, exchanges such as Kraken and Coinbase
require 20 and 35 block confirmations before the funds are credited to users’ ac-
counts [11, 26]
3For simplicity, we leave out the time for blockchain nodes to verify and execute
transactions, and assume that a transaction propagates the network within one block
time as to not contribute to transaction-processing latency.

(a) Execution and commitment time in Ethereum

(b) Execution and commitment time in F3B

Figure 3: In Ethereum, transactions are executed once in-
serted in the blockchain and committed after receiving
𝑚 block confirmations, while in F3B, transactions are en-
crypted, and their executions are postponed after receiving
𝑚 block confirmations when the secret-management com-
mittee releases the encryption keys. Both scenarios have a
similar commitment time.

5.3 Overhead Analysis
In the per-transaction protocol, (1) and (2) involve committing
a transaction on the underlying blockchain and waiting until its
committed, which takes 𝑚𝐿𝑏 time based on our baseline model
(§5.1). Further, comparing our protocol with the baseline, (3) is an
additional step, and we denote this overhead to be 𝐿𝑟 . The secret-
management committee actor may cause bottlenecks with respect
to the system’s throughput so we model the throughput of our
proposed protocol as 𝑚𝑖𝑛(𝑇𝑏,𝑇𝑠𝑚𝑐 ), assuming the secret-manage-
ment committee’s throughput is 𝑇𝑠𝑚𝑐 .

Figure 3 demonstrates the conceptual difference in commitment
and execution time between F3B and the baseline protocol. Since
the secret-management committee releases the secret keys with a
delay of 𝑚 blocks, this introduces an execution delay of 𝑚 blocks.
However, for both PBFT-style consensus algorithms (𝑚 = 1) and
probabilistic consensus algorithms, the recipient should not accept a
transaction until a transaction is committed for a variety of reasons,
such as double-spending. This indicates that F3B on a commercial
level is similar to the baseline protocol since it is the commitment
time of a transaction that is of use to the recipient4.

5.4 Protocol
In this section, we present the in-depth F3B protocol. We define a
cyclic group G of prime order 𝑞 with generators 𝑔 and ¯𝑔 that are

4In F3B, transaction finalization is slower due to the key reconstruction and delayed
execution after transaction commitment, but the overhead is insignificant compared
with commitment time, as we discuss in §11.

5

m block confirmationsExecution TimeCommitment TimeTime:m block confirmationsTime:known to all parties and define the following two hash functions:
H1 : G5 × {0, 1}𝑙 → G and H2 : G3 → Z𝑞.

Step 0: DKG Setup. For a given epoch, the secret-management
committee runs a DKG protocol to generate a shared public key
pksmc = 𝑔sksmc , and shares of the private key for each trustee de-
noted as sk𝑖 . The corresponding private key sksmc can only be
reconstructed by combining 𝑡 private key shares. All trustees also
know the verification keys ℎ𝑖 = 𝑔sk𝑖 . We assume that pksmc and ℎ𝑖
are written into the blockchain as metadata, e.g., in the first block
denoting the start of this epoch. Given the rarity of this recon-
figuration, we adopt the synchronous DKG protocol proposed by
Gennaro et al. [18], using the underlying blockchain to emulate
synchronous communication.

Step 1: Write Transaction. For the write transaction step, we use
the encryption protocol presented by the TDH2 cryptosystem [44]
Alice and the consensus group execute the following protocol to
write the txw on the underlying blockchain. Alice then starts the
protocol by performing the following steps to create the transaction
txw:

(1) Obtain the secret-management committee threshold collec-
tive public key pksmc from the underlying blockchain.
(2) Generate a symmetric key 𝑘 and encrypt the transaction tx
using authenticated symmetric encryption as 𝑐tx = enc𝑘 (tx).
(3) Embed 𝑘 as a point 𝑘 ′ ∈ G, and choose 𝑟, 𝑠 ∈ Z𝑞 at random.
(4) Compute:

(2) Verify the correctness of the ciphertext 𝑐𝑘 using the NIZK

proof by checking:

𝑒 = H1 (𝑐, 𝑢, ¯𝑢, 𝑤, ¯𝑤, 𝐿) ,

where 𝑤 =

𝑔𝑓
𝑢𝑒 and ¯𝑤 = ¯𝑔𝑓
¯𝑢𝑒 .

(3) If the txw is valid, choose 𝑠𝑖 ∈ Z𝑞 at random and compute:

𝑢𝑖 = 𝑢sk𝑖 , ˆ𝑢𝑖 = 𝑢𝑠𝑖 , ˆℎ𝑖 = 𝑔𝑠𝑖 ,
(cid:16)
𝑢𝑖, ˆ𝑢𝑖, ˆℎ𝑖
(4) Create and sign the share: share𝑖 = [𝑢𝑖, 𝑒𝑖, 𝑓𝑖 ]sigsk𝑖

, 𝑓𝑖 = 𝑠𝑖 + sk𝑖𝑒𝑖 .

𝑒𝑖 = H2

(cid:17)

, and send

it to the consensus group.

In stage (2), the NIZK proof ensures that log𝑔 𝑢 = log ¯𝑔 ¯𝑢, guaran-
teeing that whoever generated the txw knows the random value 𝑟 .
If one knows the value of 𝑟 , then they are capable of decrypting the
transaction; since it is impossible to generate txw without know-
ing the plaintext transaction, this property prevents replay attacks
mentioned in §9.2.

The following steps describe the operation of each node in the

consensus group.

(1) Upon receiving a share, each node in the consensus group

verifies the share by checking:

𝑒𝑖 = H2

(cid:16)
𝑢𝑖, ˆ𝑢𝑖, ˆℎ𝑖

(cid:17)

,

where ˆ𝑢𝑖 = 𝑢 𝑓𝑖
𝑢𝑖

𝑔𝑓𝑖
𝑒𝑖 .
ℎ𝑖
(2) After receiving 𝑡 valid shares, the set of decryption shares is

𝑒𝑖 and ˆℎ𝑖 =

𝑟
𝑐 = pk
smc

𝑘 ′, 𝑢 = 𝑔𝑟 , 𝑤 = 𝑔𝑠, ¯𝑢 = ¯𝑔𝑟 , ¯𝑤 = ¯𝑔𝑠,
𝑒 = H1 (𝑐, 𝑢, ¯𝑢, 𝑤, ¯𝑤, 𝐿) , 𝑓 = 𝑠 + 𝑟𝑒,

of the form:

{(𝑖, 𝑢𝑖 ) : 𝑖 ∈ 𝑆 },

where 𝐿 is the label of the underlying blockchain5.

(5) Finally, form the ciphertext 𝑐𝑘 = (𝑐, 𝐿, 𝑢, ¯𝑢, 𝑒, 𝑓 ) and con-
signed

struct the write transaction as txw = [𝑐𝑘, 𝑐tx]sigsk𝐴
with Alice’s private key sk𝐴.
(6) Send txw to the consensus group.
Upon receiving the txw, the consensus group commits it onto

the blockchain following its defined consensus rules.

Step 2: Wait for confirmations. Each trustee of the secret-man-
agement committee monitors the transaction txw by determining
which block the transaction is placed onto the blockchain and the
number of blocks that have passed since then. Once the number
of block confirmations is equal to 𝑚, indicating that the consensus
group commits the transaction, each trustee may proceed with the
following step.

Step 3: Key Reconstruction. For the key reconstruction step, each
trustee of the secret-management committee must provide its de-
cryption share along with a proof of correctness to the consensus
group who then reconstructs the shares.

Each trustee 𝑖 performs the following steps to release its decryp-

tion share along with proof of correctness.

(1) Extract 𝐿 from 𝑐𝑘 and verify that 𝐿 is consistent with the

underlying blockchain’s metadata.

5This can be the hash of the genesis block.

6

where 𝑆 ⊂ {1, ..., 𝑛} has a cardinality of 𝑡. Each node then
executes the recovery algorithm, which does the Lagrange
interpolation of the shares:

𝑟
smc =
pk

𝜆𝑖 ,

𝑢𝑖

(cid:214)

𝑖 ∈𝑆

where 𝜆𝑖 is the 𝑖𝑡ℎ Lagrange element.
(3) Recover the encoded encryption key:
𝑟
𝑟
smc)−1 = (pk
𝑘 ′ = 𝑐 (pk
smc

𝑟
smc)−1.
𝑘 ′)(pk

(4) Retrieve 𝑘 from 𝑘 ′ and decrypt the transaction 𝑡𝑥 = dec𝑘 (𝑐𝑡𝑥 ).
(5) Execute the transaction following the consensus group’s

defined rules.

In stage (1), the NIZK proof ensures that (𝑢, ℎ𝑖, 𝑢𝑖 ) is a Diffie-
Hellman triple, i.e., that 𝑢𝑖 = 𝑢sk𝑖 , guaranteeing the correctness of
the share.

6 ACHIEVING THE SYSTEM GOALS
In this section, we present how F3B achieves the system goals set
forth in §4.1.

Front-running protection: Preventing entities from launching

front-running attacks.

We reason the protection offered by F3B from the definition of
front-running: if an adversary cannot benefit from pending trans-
actions, he cannot launch front-running attacks. In F3B, the sole
entity that knows the content of a pending transaction is the sender,
who is financially incentivized not to release its contents. The key is

released only when a transaction is committed; thus, by definition,
the attacker has no chance to launch a front-running attack. How-
ever, we acknowledge that attackers may use metadata—such as the
sender’ address and transaction size—of the encrypted transaction
to launch speculative front-running attacks, as discussed in §4.4
and §10. We present a more comprehensive security analysis in §9.
Decentralization: Mitigating a single point of failure or compro-

mise.

Due to the properties of DKG [18] and THD2 [44] cryptosystems,
the secret-management committee can handle up to 𝑡 − 1 malicious
trustees and up to 𝑛 − 𝑡 offline trustees.

Confidentiality: Revealing a transaction only after the underly-

ing consensus layer commits it.

Each transaction is encrypted with the sender’s generated sym-
metric key and this key is encrypted with the secret-management
committee’s public key. Per our threat model, only 𝑓 trustees may
behave maliciously, ensuring that the symmetric key cannot be
revealed since 𝑓 + 1 trustees follow the protocol. We outline a more
detailed security analysis in §9.

Compatibility: Remaining agnostic to the underlying consensus

algorithm and smart contract implementation.

Since we are encrypting the entire transaction and require a
modification at the blockchain layer to adapt F3B, F3B does not
require modifications to existing smart contract implementations
and support various consensus algorithm (PBFT-style, PoW, PoS).
Low latency overhead: Exhibiting low latency transaction-pro-

cessing overhead.

Since F3B requires writing one transaction onto the underlying
blockchain, as in the baseline protocol, this feature enables F3B to
have a low latency overhead in comparison to front-running pro-
tection protocols which require multiple transactions. We present
an evaluation of this latency overhead in §11.

7 DEPLOYMENT
This section discusses a few considerations when F3B is deployed
on real-world blockchains.

Settling on block confirmations: To reliably provide front-running
protection, we must select a reasonable 𝑚: the number of block
confirmations. For a PBFT-style consensus, a transaction is irre-
versible once placed inside a block, and thus 𝑚 can safely be set to
1. However, for probabilistic consensus algorithms (e.g., PoW, PoS),
choosing 𝑚 is more precarious. On the one hand, a larger 𝑚 sug-
gests a better security level, rendering a successful front-running
attack less likely. On the other hand, a larger 𝑚 indicates more time
to commit a transaction, affecting the minimum baseline time until
commitment and execution across the entire blockchain network.
Unlike blockchains without F3B protection, the public cannot ob-
serve transactions until the consensus group commits to them and
the secret-management committee releases their corresponding
keys. The exact formula for choosing 𝑚 is out of the scope of this
paper but we refer to Gervais et al.’s proposed framework to sys-
tematically analyze the security and performance of proof-of-work
blockchain[19], which offers a reference for choosing 𝑚.

Storing encrypted transactions and delayed execution: Since all
transactions are encrypted, the consensus group cannot verify and

7

execute them until the secret-management committee releases
their corresponding keys, which is only done after the consen-
sus group commits a transaction on the underlying blockchain.
This process indicates that the consensus group must store the
transaction on the blockchain without any regard to its content.
Unfortunately, this brings a notable challenge as attackers can then
spam the blockchain by fabricating invalid transactions to flood
the blockchain with, causing a backlog of pending transactions.
Nonetheless, we present a mitigation technique in §8.1 involving a
storage fee.

A hard fork on existing blockchain: The easiest way to deploy
F3B is on a new blockchain. If an existing blockchain like Ethereum
decides to deploy F3B, this would require a scheduled hard fork,
given that all nodes need to adopt the new rules due to the different
execution workflow.

Reconfiguration of secret-management committee: The member-
ship of the secret-management committee needs to be reconfigured
at some predefined interval (each epoch) to allow for new trustees
and the removal of others. In addition, this helps to prevent a silent
violation of our threat model—the assumption that 𝑓 + 1 trustees
cannot collude—over a long period. Care must be taken when tran-
sitioning between two epochs so that pending transactions are
unaffected by the transition. This could involve having the de-
commissioned secret-management committee operate into a new
epoch until the remaining pending transactions are committed and
revealed.

Multiple secret-management committees: The secret-management
committee may inadvertently become the bottleneck of the under-
lying consensus protocol given its inability to achieve the same
throughput. Yet, a secret-management committee is agnostic to the
underlying blockchain layer, allowing for independently-operated
secret-management committees. We thus suggest adopting a shard-
ing strategy by allowing for numerous secret-management commit-
tees to operate in parallel, balancing pending transactions between
them. Each secret-management committee needs to run the DKG
protocol to set up its keys and store the public key pksmc and veri-
fication keys ℎ𝑖 to the underlying blockchain as well as define its
security parameters by choosing, for example, their committee size
and 𝑛-bit security level.

One option would then be for secret-management committees
to form at will and let users freely choose a secret-management
committee over another according to their preferences or needs.
This would naturally introduce a free market, where secret-man-
agement committees would compete with one another to provide
quality service at low cost.

Another option is pooling all qualifying nodes and randomly
sample them into multiple shards at the beginning of each epoch
using bias-resistant, distributed randomness [46]. The aggregated
sampling changes the threat model from an individual secret-man-
agement committee to all nodes. Under the assumption of a mildly
adaptive adversary [23, 32] where an adversary can compromise
a number of trustees with a time-delay, random sampling helps
ensure that the compromise of any single secret-management com-
mittee is harder to accomplish. While this does introduce additional
complexity for the setup of secret-management committees, this

overhead would not affect transaction-processing latency as it can
be bootstrapped during the previous epoch.

reached with some price fluctuations depending on the volume of
transactions.

Overall, we expect that, by adopting a sharding strategy, the
throughput of F3B increases linearly with the number of trustees
in secret-management committees.

Multiple blockchains: A secret-management committee can also
provide threshold encryption services for multiple blockchains
if it can monitor all the blockchains it supports and follow their
set of rules (e.g., the blockchains can have different values for 𝑚).
Recall that each blockchain is labeled with a distinct 𝐿 (e.g., the
genesis block’s hash), which allows the sender to designate which
blockchain their encrypted transactions belongs to.

8 INCENTIVE ANALYSIS
Each actor must be incentivized to operate and follow the protocol
honestly. In this section, we address some of the key incentives
in F3B to ensure protection against unsolicited transactions and
prevent the release of shares prematurely.

8.1 Spamming protection
As transactions are encrypted, the consensus group cannot verify or
execute transactions, opening up an availability attack that would
otherwise not be present in an open system. A malicious adversary
could spam the blockchain with inexecutable transactions (e.g.,
inadequate fees, malformed transactions), significantly hindering
the throughput of honest transactions. To prevent such an attack,
we introduce a storage fee alongside the traditional execution fee
(e.g., Ethereum gas) that makes it costly for an attacker to operate
this attack. The storage fee paid to miners covers the placement
of the transaction on the blockchain and can either vary based on
some parameter (e.g., size of the transaction) or be a flat fee. The
execution fee is not calculated until after the secret-management
committee reveals the transaction, given the lack of knowledge of
the transaction’s contents.

8.2 The operational incentive for a SMC
Similar to how consensus nodes are incentivized to maintain the
blockchain with block rewards and transaction fees, we need a
similar incentive structure for the secret-management committees.
In a permissioned blockchain system, becoming trustees of a secret-
management committee could be an added responsibility to the
consensus nodes and in exchange, receive storage fees as additional
income. In a permissionless blockchain system, such as a PoW
blockchain, the secret-management committee might differ from
miners, indicating that a payment channel needs to be established
between senders and the secret-management committee.

Now, how should a secret-management committee set the price?
We believe free market forces will automatically solve this problem
when multiple secret-management committees are competing with
each other to provide cheap and quality service. On the one hand,
if a secret-management committee sets the price too high, this will
discourage users from using this secret-management committee.
On the other hand, if a secret-management committee sets the price
too low, the trustees may not be able to cover the cost of running a
secret-management committee or handle the volume of incoming
transactions. In general, we can expect a price equilibrium to be

8.3 The incentive for not leaking the share
A corrupted secret-management committee might silently collab-
orate with the consensus group to front-run users’ transactions
by releasing the shares prematurely. Since this behavior is difficult
to detect—out of band collusion—we must provide an incentive
structure that (significantly) rewards anyone that can prove mis-
behavior by a trustee or the entire secret-management committee
to disincentivize such malicious activity. At the same time, we do
not want anyone to accuse a secret-management committee or a
specific trustee without repercussions if the secret-management
committee or trustee did not actually misbehave.

To accomplish our objective, each trustee of each secret-man-
agement committee must stake some amount of cryptocurrency in
a smart contract that handles disputes between a defendant (the
entire secret-management committee or a particular trustee) and
a plaintiff. To start a dispute, the plaintiff will invoke the smart
contract with the correct decryption share for a currently pending
transaction and their own stake. If the smart contract validates that
this is a correct decryption share and that the dispute started before
the transaction in question was revealed by the secret-management
committee, then the defendant’s stake is forfeited and sent to the
plaintiff.

At a protocol level, to prove a correct decryption share, the
where ˆ𝑢𝑖 =

plaintiff submits [𝑢𝑖, 𝑒𝑖, 𝑓𝑖 ] such that 𝑒𝑖 = H2
𝑢 𝑓𝑖
𝑒𝑖 and ˆℎ𝑖 =
𝑒𝑖 . Deploying such a mechanism would require the
𝑢𝑖
smart contract to access the ciphertext of a transaction (e.g., 𝑢 is
necessary to verify the submitted share), suggesting a modification
of the smart contract virtual machine.

(cid:16)
𝑢𝑖, ˆ𝑢𝑖, ˆℎ𝑖

𝑔𝑓𝑖
ℎ𝑖

(cid:17)

9 SECURITY ANALYSIS
This section introduces the security analysis of F3B’s protocol.

9.1 Front-running protection
We reason, from our threat model, why an attacker can no longer
launch front-running attacks with absolute certainty of a financial
reward, even with the collaboration of at most 𝑓 malicious trustees.
As we assume that the attacker does not launch speculative attacks
based on metadata of the encrypted transactions, the only way
the attacker can front-run transactions is by using the plaintext
content of the transaction. If the attacker cannot access the content
of the transaction before it is committed on the underlying block-
chain, the attacker cannot benefit from the pending transaction,
thus preventing front-running attacks (by the definition of front-
running). Since we assume that the symmetric encryption we use
is secure, the attacker cannot decrypt the transaction based on
its ciphertext. In addition, based on the properties of the TDH2
cryptosystem [44] and DKG [18] and our threat model, the attacker
cannot obtain the private key nor reconstruct of the symmetric key.
Recall that the attacker can only collude with at most 𝑓 trustees
and 𝑓 + 1 are required to recover or gain information about the
symmetric key.

8

9.2 Replay attack
We consider another scenario in which an adversary can copy a
pending (encrypted) transaction and submit it as their own transac-
tion to reveal the transaction’s contents before the victim’s transac-
tion is committed. By revealing the contents of the copied transac-
tion, the attacker can then trivially launch a front-running attack.
However, we present why the adversary is unable to benefit from
such a strategy.

In the first scenario, the adversary completely copies the cipher-
text 𝑐𝑘 , the encrypted transaction 𝑐tx from txw, and makes their
own write transaction tx′
w digitally signed with their signature.
However, when sending the transaction on the underlying block-
chain, the adversary’s tx′
w is decrypted no earlier than the victim’s
transaction txw.

In our second scenario, the adversary instead sends the transac-
tion to a blockchain with smaller 𝑚 block confirmations. Consider
two blockchains 𝑏1 and 𝑏2 whose required number of confirmation
blocks are 𝑚1 and 𝑚2 with 𝑚1 > 𝑚2. If the adversary changes
the label 𝐿 to 𝐿′ for the blockchain 𝑏2 instead of blockchain 𝑏1,
the secret-management committee will successfully decrypt the
transaction.

However, we argue that forming a valid write transaction with 𝐿′
by the adversary is hard. The adversary would need to generate an
𝑒 ′ = H1 (𝑐, 𝑢, ¯𝑢, 𝑤, ¯𝑤, 𝐿′) , 𝑓 = 𝑠 + 𝑟𝑒 ′, without knowing the random
parameter 𝑟 and 𝑠. Suppose the adversary generates 𝑢 = 𝑔𝑟 , ¯𝑢 = ¯𝑔𝑟 ′
with 𝑟 ≠ 𝑟 ′ and 𝑤 = 𝑔𝑠, ¯𝑤 = ¯𝑔𝑠′
w be
valid, we must have 𝑔𝑓 = 𝑤𝑢𝑒 and ¯𝑔𝑓 = ¯𝑤 ¯𝑢𝑒 which implies that
(𝑠 − 𝑠 ′) + 𝑒 (𝑟 − 𝑟 ′) = 0. Since 𝑟 ≠ 𝑟 ′ , the adversary only has a
negligible chance of having tx′

with 𝑠 ≠ 𝑠 ′. To have tx′

w pass verification.

10 OPTIMIZATION DISCUSSION
This section discusses some possible directions to optimize the
protocol. We leave the detailed analysis of those optimizations as
future work.

Not every node needs to do the reconstruction: Under our pro-
posed protocol, every consensus node needs to fetch the shares
and run the Lagrange interpolation to reconstruct the key. Would
it instead be possible for one of the consensus nodes to reconstruct
the symmetric key 𝑘 from the secret shares and propagate it to
other consensus nodes with a succinct proof?

We thus propose a solution that requires additional storage over-
head in exchange for faster verification: Instead of constructing
their encrypted transaction as (𝑐𝑘, 𝑐tx), the sender additionally adds
a hash of the symmetric key ℎ𝑘 = 𝐻 (𝑘) as the third entry, creating
the following signed write transaction: txw = [𝑐𝑘, 𝑐tx, ℎ𝑘 ]sigsk𝐴

During key reconstruction, after recovering or receiving 𝑘, con-
sensus nodes only need to verify whether the hash of 𝑘 is consistent
with the one (ℎ𝑘 ) published on the ledger. If it is consistent, consen-
sus nodes can continue to decrypt the transaction and propagate the
key 𝑘 to others. If it is inconsistent, the provided key 𝑘 is incorrect
and discards it.

.

Reducing storage overhead: In the TDH2 cryptosystem, the label
𝐿 is attached to the ciphertext during the encryption process, which
includes the information that can be used by a secret-management
committee to determine if the decryption is authorized [44]. While

9

we cannot remove 𝐿 since its used for protection against replay
attacks §9.2, each party (miners, secret-management committee,
sender) knows 𝐿 implicitly and can insert 𝐿 in their computation
and verification steps, allowing Alice to exclude 𝐿 from txw.

Metadata leakage: In our architecture, adversaries can only ob-
serve encrypted transactions until they are committed, thus prevent-
ing the revelation of transaction contents to launch front-running
attacks. Nevertheless, adversaries can rely on side channels such
as transaction metadata to launch speculative attacks. Concretely,
since the sender needs to pay the storage fee (§8.1) for publishing
an encrypted transaction to the underlying blockchain, this leaks
the sender’s address. Knowledge of the sender’s address can help in
launching a front-running attack since an adversary may be able to
predict the sender’s behavior based on history. In order to prevent
this second-order front-running attack, an underlying blockchain
needs to offer anonymous payment to users, such as Zerocash [40]
or a mixing service [50]. Another side-channel leakage is the size of
the encrypted transaction or the time the transaction is propagated.
A possible remedy for mitigating metadata leakage is PURBs [36].

Encryption based on block: Under our F3B architecture, each
transaction is encrypted with a key. However, this might not be
necessary as transactions are committed and executed on a per-
block basis; thus, transactions in the same block can be encrypted
with the same key by leveraging identity-based encryption [7]. By
adopting this batching approach, we expect that it can reduce the
latency and increase throughput; we leave this approach’s actual
performance and trade-offs as future work.

Key Storage and Node Catchup: In our protocol, if a new node
wants to join the consensus group, it cannot execute the histori-
cal transactions to catch up unless it obtains all decryption keys.
The secret-management committee or consensus group can store
those keys independently from the blockchain, but this requires
them to maintain an additional immutable ledger. Since consensus
nodes already maintain one immutable storage medium, namely
the underlying blockchain, the keys can be stored on this medium
as metadata, and the blockchain rule can require storing valid keys
to produce blocks.

However, this optimization brings about a timing issue, i.e., when
should the blockchain require the consensus group to store keys in
a block? From our protocol, the transaction is committed at block
height 𝑛 and revealed at block height 𝑛+𝑚, making the earliest block
to write the key at block height 𝑛 + 𝑚 + 1. With respect to the latest
block height to write the key, there is much more flexibility and
one needs to consider the balance between the delay tolerance for
all consensus nodes to retrieve the key and the time that consensus
nodes must retain the key. If we assume that the key reconstruction
step takes up to 𝛿 block times, the key should be written in or before
the block 𝑛 + 𝑚 + 𝛿.

While this setup would work well for for a blockchain with
fixed block time, care must be taken with respect to blockchains
where block time is probabilistic since the key may not have been
replicated to all consensus nodes at block height 𝑛 +𝑚 + 𝛿, inducing
some artificial delay for new blocks.

size of 128 with 20 block confirmations, F3B brings a 0.68% latency
overhead.

Figure 5 presents the latency comparison between the baseline
protocol (§5.1), the F3B protocol—varying the size of the secret-
management committee stated after “F3B-"—and a sender-only
commit-and-reveal protocol as presented in Strawman 1 (§3.1). Our
simulation adopts a fixed 13 seconds block time with 20 block
confirmations to commit a transaction consistent between different
comparisons; thus, any data written into the blockchain needs
13 ∗ 20 = 260 seconds.

As for the baseline protocol, sending a transaction only needs to
write data to the blockchain once. Hence, the total latency for base-
line is 260 seconds. Recall that in a sender-only commit-and-reveal
approach, the sender needs first to commit a hash to the blockchain
and then reveal the transaction, in which each step takes 260 sec-
onds. Those two steps cannot be parallelized since the hash must be
committed on the blockchain before sending the reveal transaction.
Otherwise, an adversary can read the reveal transaction and create
a fork of the blockchain, thwarting any front-running protection.
In practice, the protocol needs to offer enough buffer time to allow
the reveal transaction to be included in the blockchain, inducing
additional latency. This buffer time needs to be conservative in case
a cryptokitties storm or blockchain DoS attacks were to happen.
The Fomo3D attack blocked the Ethereum blockchain for about
three minutes [16], suggesting a reference for choosing the buffer
time. Hence, 260 ∗ 2 = 520 seconds is the lower bound of this ap-
proach. Further, this approach also suffers the leakage of the smart
contract address when submitting the commit transaction to the
blockchain. Submarine is a more advanced approach that hides
the smart contract address, but it requires the sender to send three
different transactions to the blockchain, suffering a 200% latency
overhead compared to the baseline [8, 31]

Compared with F3B, the reveal phase (Key Reconstruction step)
does not require writing any data onto the blockchain. We, there-
fore, emphasize a significant difference between F3B and other
commit-and-reveal approaches where F3B only requires sending
one transaction to the underlying blockchain. This advantage brings
a low latency overhead for Ethereum.

11.2 Throughput
With respect to throughput, we only focus on Key Reconstruction
(Step 3) as Write Transaction (Step 1) is identical to sending a
transaction to the underlying blockchain, except for some negligible
overhead due to the additional size of an encrypted transaction.

Figure 6 presents the throughput result of key reconstruction
with a secret-management committee consisting of 128 trustees.
If the keys are individually reconstructed, F3B can only provide
limited throughput due to the network transmission overhead on a
per-transaction basis and non-parallel execution. Instead, we can
batch the keys, reconstruct them concurrently and present them
in one network transmission. We present this batching effect in
Figure 6, varying the batching sizes to measure the throughput
and the corresponding latency. Increasing the batching size to 128,
can improve throughput to 13.2 txns/sec from 0.56 txns/sec. Our
result shows that the marginal improvement is negligible when
further increasing the batching size to 256 or 512. The increased

Figure 4: Overhead of F3B for varying sizes of the secret-
management committee.

Table 1: Latency Overhead for Ethereum Blockchain

Latency Overhead for different size of SMC

Confirmations

8

16

32

64

5
10
20
30
50

0.05% 0.10% 0.24% 0.74%
0.02% 0.05% 0.12% 0.37%
0.01% 0.03% 0.06% 0.19%
0.01% 0.02% 0.04% 0.12%
0.00% 0.01% 0.02% 0.07%

128

2.73%
1.36%
0.68%
0.45%
0.27%

11 EVALUATION
We implemented a prototype of F3B in Go [20], built on Calypso [25]
and supported by Kyber [29], an advanced cryptographic library.
We use ByzCoin [24], a PBFT-style consensus protocol as our un-
derlying blockchain. We instantiate our cryptographic primitives
using the Edward25519 elliptic curve with 128-bit security. We ran
our experiment on a server with 32GB of memory and 40 CPU cores
running at 2.1GHz.

11.1 Latency
In Figure 4, while varying the number of secret-management com-
mittee trustees from 8 to 128 nodes, we present the latency time a)
for setting up a DKG, b) for sending a transaction to the Byzcoin
blockchain (Step 1), c) for reconstructing the key (Step 3). Recall
that DKG setup is a one-time operation per epoch that can be boot-
strapped during the previous epoch; thus, b) and c) represent the
true transaction-latency of our solution.

We consider the transaction’s overall latency in F3B to be ex-
pressed as 𝑚𝐿𝑏 + 𝐿𝑟 (§5.2). To evaluate F3B with Ethereum’s con-
sensus model, we adopt 13 seconds as the expected block time [5].
Since there is no standard number of confirmations before a block is
considered committed, we vary both the number of confirmations
and the size of the secret-management committee, as summarized
in Table 1. Our result shows that, for example, based on a committee

10

8163264128Size of Secret-management Committee0.010.11101001000Latency Time(sec)DKG SetupWrite TransactionKey ReconstructionFigure 5: Latency comparison of F3B with the sender-only
commit-and-reveal approach, if they were deployed in the
Ethereum. Because F3B needs only one round interaction
with the underlying blockchain, it induces a small latency
overhead with respect to Ethereum.

Figure 6: Throughput performance of the key reconstruc-
tion with 128 trustees in the secret-management committee
for varying batching sizes.

throughput comes with the cost of higher latency: with the batching
size of 128, the key reconstruction takes 9.7 seconds to process,
equivalent to 3.7% latency overhead under 20 block confirmations
in the Ethereum blockchain.

12 RELATED WORK
Namecoin, a decentralized name service, is an early example of
using a commit-and-reveal approach to mitigate front-running
attacks [21]. In Namecoin, a user first sends a salted hash to the
blockchain and, after a certain number of blocks, broadcasts the
actual name when it is too late for an attacker to front-run the user,
similar to our Strawman I protocol (§3).

Later, Eskandari et al. [16] first systematized front-running at-
tacks on the blockchain by presenting three types of front-running
attacks: displacement, insertion, and suppression. Daian et al. [12]
first quantified front-running attacks from an economic point of
view, determining that front-running attacks can pose a security
problem of the underlying consensus layer by incentivizing unnec-
essary forks driven by the miner extractable value (MEV).

Previous works [34, 42] explore the idea of applying threshold
encryption at the blockchain layer to mitigate front-running attacks.
Schmid [42] proposed a secure causal atomic broadcast protocol
with threshold encryption to prevent front-running attacks but did
not provide a solution for integrating with a PoW blockchain nor
scale to a large number of trustees. A commercial crypto project
CodeChain [34] proposed to reveal transactions by their trustees
using the Shamir secret sharing scheme but did not offer imple-
mentation or experiment details. Submarine, an application layer
front-running protection approach, uses a commit-and-reveal strat-
egy to enable hiding the smart contract address, but it requires three
rounds of communication to the underlying blockchain, inducing a
high latency overhead [8, 31]. To our knowledge, our work is the

11

first solution to achieve legacy compatibility with both the consen-
sus algorithm and smart contract implementation while achieving
low latency overhead.

Other research adopts different approaches to mitigate front-
running. A series of recent studies focus on fair ordering [22, 27, 28],
but it alone cannot prevent a rushing adversary [2]. Wendy ex-
plores the possibility of combining fair ordering with commit-and-
reveal [28] but does not present quantitative overhead analysis.
Furthermore, F3B hides the content of all transactions before com-
mitment, unlike Wendy which only guarantees the fairness of trans-
actions with the same label. Although our approach has a higher
latency overhead than Wendy, we believe it is necessary as the
label can provide useful information for adversaries to launch a
front-running attack, such as the Fomo3D attack [16].

Some research adopts time-lock puzzles [39] to blind transactions.
Injective protocol [9] deploys a verifiable delay function [6] as proof-
of-elapsed-time to prevent front-running attacks. However, it is
still an open challenge to link the time-lock puzzle parameters to
the actual real-world delay [2].

Tesseract, proposed by Bentov et al., is an exchange prevent-
ing front-running attacks by leveraging a trusted execution envi-
ronment [3]. However, this approach brings an unreliable central-
ized component subject to a single point of failure and compro-
mise [38, 48].

Calypso is a framework that enables on-chain secrets by adopting
threshold encryption governed by a secret-management commit-
tee [25]. Calypso allows ciphertexts to be stored on the blockchain
and collectively decrypted by trustees according to a pre-defined
policy. F3B builds on Calypso to mitigate front-running attacks.

13 CONCLUSION
This paper introduces F3B, a blockchain architecture that addresses
front-running attacks by encrypting pending transactions with
threshold encryption. We performed an exploration demonstrating
that F3B can protect the Ethereum blockchain with a low latency

BaselineF3B-8F3B-16F3B-32F3B-64F3B-128     Strawman IMitigation Method0.010.11101001000Latency Time(sec)Round 1(Commit)Round 2(Reveal)1248163264128256512Performance for varying batching size with 128 nodes02468101214Throughput(tx/sec)ThroughputLatency0510152025303540Latency Time(sec)overhead. While acknowledging that widespread deployment of F3B
is challenging given the need for modifications with the blockchain
workflow, F3B provides substantial benefits: the blockchain, by
default, would now contain standard front-running protection for
all applications at once without requiring any modifications to
smart contracts themselves.

ACKNOWLEDGMENTS
The authors wish to thank Basescu Cristina and Simone Colombo
for their extremely helpful comments and suggestions. This re-
search was supported in part by U.S. Office of Naval Research grant
N00014-19-1-2361 and the AXA Research Fund.

REFERENCES
[1] 2018(?). Nasdaq: Front running. https://www.nasdaq.com/glossary/f/front-

[23] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. 2017.
Ouroboros: A provably secure proof-of-stake blockchain protocol. In Annual
international cryptology conference. Springer, 357–388.

[24] Eleftherios Kokoris Kogias, Philipp Jovanovic, Nicolas Gailly, Ismail Khoffi, Linus
Gasser, and Bryan Ford. 2016. Enhancing bitcoin security and performance
with strong consistency via collective signing. In 25th usenix security symposium
(usenix security 16). 279–296.

[25] Eleftherios Kokoris-Kogias, Enis Ceyhun Alp, Linus Gasser, Philipp Jovanovic,
Ewa Syta, and Bryan Ford. 2018. Calypso: Private data management for decen-
tralized ledgers. Cryptology ePrint Archive (2018).

[26] Kraken. 2022(?). Cryptocurrency deposit processing times.

https://support.

kraken.com/hc/en-us/articles/203325283- Accessed: 2022-03-03.

[27] Klaus Kursawe. 2020. Wendy, the good little fairness widget: Achieving order
fairness for blockchains. In Proceedings of the 2nd ACM Conference on Advances
in Financial Technologies. 25–36.

[28] Klaus Kursawe. 2021. Wendy Grows Up: More Order Fairness. In International
Conference on Financial Cryptography and Data Security. Springer, 191–196.
[29] kyber 2010 – 2022. https://github.com/dedis/kyberThe Kyber Cryptography

Library.

[30] Michael Lewis. 2014. Flash boys: a Wall Street revolt. WW Norton & Company.
[31] LibSubmarine. 2017(?). Defeat Front-Running on Ethereum. https://libsubmarine.

running. Accessed: 2022-04-17.

org Accessed: 2022-01-24.

[2] Carsten Baum, James Hsin-yu Chiang, Bernardo David, Tore Kasper Frederiksen,
and Lorenzo Gentile. 2021. SoK: Mitigation of Front-running in Decentralized
Finance. Cryptology ePrint Archive (2021).

[3] Iddo Bentov, Yan Ji, Fan Zhang, Lorenz Breidenbach, Philip Daian, and Ari Juels.
2019. Tesseract: Real-time cryptocurrency exchange using trusted hardware. In
Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications
Security. 1521–1538.

[4] Dan Bernhardt and Bart Taub. 2008. Front-running dynamics. Journal of Economic

Theory 138, 1 (2008), 288–296.

[32] Loi Luu, Viswesh Narayanan, Chaodong Zheng, Kunal Baweja, Seth Gilbert,
and Prateek Saxena. 2016. A secure sharding protocol for open blockchains. In
Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications
Security. 17–30.

[33] Edvardas Mikalauskas. 2021. 280 million stolen per month from crypto transac-
tions. https://cybernews.com/crypto/flash-boys-2-0-front-runners-draining-
280-million-per-month-from-crypto-transactions Accessed: 2022-02-16.
[34] Saad Najafi. 2020. Front-Running Attacks on Blockchain. https://medium.com/

codechain/front-running-attacks-on-blockchain-1f5ba28cd42b

[5] Blocks 2022. Blocks. https://ethereum.org/en/developers/docs/blocks Accessed:

[35] Satoshi Nakamoto. 2008. Bitcoin: A peer-to-peer electronic cash system. Decen-

2022-02-24.

[6] Dan Boneh, Joseph Bonneau, Benedikt Bünz, and Ben Fisch. 2018. Verifiable
delay functions. In Annual international cryptology conference. Springer, 757–788.
[7] Dan Boneh and Matt Franklin. 2001. Identity-based encryption from the Weil
pairing. In Annual international cryptology conference. Springer, 213–229.
[8] Lorenz Breidenbach, Phil Daian, Florian Tramèr, and Ari Juels. 2018. Enter
the Hydra: Towards Principled Bug Bounties and {Exploit-Resistant} Smart
Contracts. In 27th USENIX Security Symposium (USENIX Security 18). 1335–1352.
Injective Protocol: A Collision Resistant

[9] Eric Chen and Albert Chon. 2018.

Decentralized Exchange Protocol. (2018).

[10] Michele Ciampi, Muhammad Ishaq, Malik Magdon-Ismail, Rafail Ostrovsky, and
Vassilis Zikas. 2021. FairMM: A fast and frontrunning-resistant crypto market-
maker. Cryptology ePrint Archive (2021).
[11] Coinbase. 2022(?). Coinbase Confirmations.

https://help.coinbase.com/en/
coinbase/getting-started/crypto-education/glossary/confirmations Accessed:
2022-03-03.

[12] Philip Daian, Steven Goldfeder, Tyler Kell, Yunqi Li, Xueyuan Zhao, Iddo Bentov,
Lorenz Breidenbach, and Ari Juels. 2019. Flash boys 2.0: Frontrunning, transaction
reordering, and consensus instability in decentralized exchanges. arXiv preprint
arXiv:1904.05234 (2019).

[13] N Neha Dalwadi and C Mamta Padole. 2017. Comparative study of clock synchro-
nization algorithms in distributed systems. Advances in Computational Sciences
and Technology 10, 6 (2017), 1941–1952.
[14] dapp.org. 2020. Uniswap V2 Audit Report.
uniswapv2.html Accessed: 2022-01-22.

https://dapp.org.uk/reports/

[15] Hayden Adams Dave White, Dan Robinson. 2021. Time-weighted Average Market

Maker (TWAMM). https://www.paradigm.xyz/2021/07/twamm

[16] Shayan Eskandari, Mahsa Moosavi, and Jeremy Clark. 2019. Sok: Transparent

dishonesty: front-running attacks on blockchain. (2019).

[17] Paul Feldman. 1987. A practical scheme for non-interactive verifiable secret
sharing. In 28th Annual Symposium on Foundations of Computer Science (sfcs 1987).
IEEE, 427–438.

[18] Rosario Gennaro, Stanisław Jarecki, Hugo Krawczyk, and Tal Rabin. 1999. Secure
distributed key generation for discrete-log based cryptosystems. In International
Conference on the Theory and Applications of Cryptographic Techniques. Springer,
295–310.

[19] Arthur Gervais, Ghassan O Karame, Karl Wüst, Vasileios Glykantzis, Hubert
Ritzdorf, and Srdjan Capkun. 2016. On the security and performance of proof of
work blockchains. In Proceedings of the 2016 ACM SIGSAC conference on computer
and communications security. 3–16.

[20] Go. 2009. The Go Programming Language. https://go.dev
[21] Harry A Kalodner, Miles Carlsten, Paul Ellenbogen, Joseph Bonneau, and Arvind
Narayanan. 2015. An Empirical Study of Namecoin and Lessons for Decentralized
Namespace Design.. In WEIS. Citeseer.

[22] Mahimna Kelkar, Soubhik Deb, and Sreeram Kannan. 2021. Order-fair consensus

in the permissionless setting. Cryptology ePrint Archive (2021).

12

tralized Business Review (2008), 21260.

[36] Kirill Nikitin, Ludovic Barman, Wouter Lueks, Matthew Underwood, Jean-Pierre
Hubaux, and Bryan Ford. 2019. Reducing metadata leakage from encrypted files
and communication with purbs. Proceedings on Privacy Enhancing Technologies
2019, 4 (2019), 6–33.

[37] Rafael Pass, Lior Seeman, and Abhi Shelat. 2017. Analysis of the blockchain
protocol in asynchronous networks. In Annual International Conference on the
Theory and Applications of Cryptographic Techniques. Springer, 643–673.
[38] Hany Ragab, Alyssa Milburn, Kaveh Razavi, Herbert Bos, and Cristiano Giuf-
frida. 2021. Crosstalk: Speculative data leaks across cores are real. In 2021 IEEE
Symposium on Security and Privacy (SP). IEEE, 1852–1867.

[39] Ronald L Rivest, Adi Shamir, and David A Wagner. 1996. Time-lock puzzles and

timed-release crypto. (1996).

[40] Eli Ben Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers,
Eran Tromer, and Madars Virza. 2014. Zerocash: Decentralized anonymous
payments from bitcoin. In 2014 IEEE symposium on security and privacy. IEEE,
459–474.

[41] Alexander Savelyev. 2017. Contract law 2.0:‘Smart’contracts as the beginning of
the end of classic contract law. Information & communications technology law 26,
2 (2017), 116–134.

[42] Noah Schmid. 2021. Secure Causal Atomic Broadcast. https://crypto.unibe.ch/

archive/theses/2021.bsc.noah.schmid.pdf

[43] Berry Schoenmakers. 1999. A simple publicly verifiable secret sharing scheme and
its application to electronic voting. In Annual International Cryptology Conference.
Springer, 148–164.

[44] Victor Shoup and Rosario Gennaro. 1998. Securing threshold cryptosystems
against chosen ciphertext attack. In International Conference on the Theory and
Applications of Cryptographic Techniques. Springer, 1–16.

[45] Chrysoula Stathakopoulou, Signe Rüsch, Marcus Brandenburger, and Marko
Vukolić. 2021. Adding Fairness to Order: Preventing Front-Running Attacks
in BFT Protocols using TEEs. In 2021 40th International Symposium on Reliable
Distributed Systems (SRDS). IEEE, 34–45.

[46] Ewa Syta, Philipp Jovanovic, Eleftherios Kokoris Kogias, Nicolas Gailly, Linus
Gasser, Ismail Khoffi, Michael J Fischer, and Bryan Ford. 2017. Scalable bias-
resistant distributed randomness. Ieee, 444–460.

[47] Christof Ferreira Torres, Ramiro Camino, and Radu State. 2021. Frontrunner
Jones and the Raiders of the Dark Forest: An Empirical Study of Frontrunning
on the Ethereum Blockchain. In 30th USENIX Security Symposium (USENIX Secu-
rity 21). USENIX Association, 1343–1359. https://www.usenix.org/conference/
usenixsecurity21/presentation/torres

[48] Jo Van Bulck, Marina Minkin, Ofir Weisse, Daniel Genkin, Baris Kasikci, Frank
Piessens, Mark Silberstein, Thomas F Wenisch, Yuval Yarom, and Raoul Strackx.
2018. Foreshadow: Extracting the Keys to the Intel {SGX} Kingdom with Tran-
sient {Out-of-Order} Execution. In 27th USENIX Security Symposium (USENIX
Security 18). 991–1008.

[49] Gavin Wood et al. 2014. Ethereum: A secure decentralised generalised transaction

ledger. Ethereum project yellow paper 151, 2014 (2014), 1–32.

[50] Jan Henrik Ziegeldorf, Roman Matzutt, Martin Henze, Fred Grossmann, and
Klaus Wehrle. 2018. Secure and anonymous decentralized Bitcoin mixing. Future
Generation Computer Systems 80 (2018), 448–466.

13

