1

Protecting the Integrity of IoT Sensor Data and
Firmware With A Feather-Light Blockchain
Infrastructure

Dani¨el Reijsbergen, Aung Maw, Sarad Venugopalan, Dianshi Yang, Tien Tuan Anh Dinh, and Jianying Zhou
Singapore University of Technology and Design

2
2
0
2

r
p
A
0
3

]

R
C
.
s
c
[

1
v
5
8
1
0
0
.
5
0
2
2
:
v
i
X
r
a

Abstract—Smart cities deploy large numbers of sensors and
collect a tremendous amount of data from them. For example,
Advanced Metering Infrastructures (AMIs), which consist of
physical meters that collect usage data about public utilities such
as power and water, are an important building block in a smart
city. In a typical sensor network, the measurement devices are
connected through a computer network, which exposes them to
cyber attacks. Furthermore, the data is centrally managed at the
operator’s servers, making it vulnerable to insider threats.

Our goal is to protect the integrity of data collected by large-
scale sensor networks and the ﬁrmware in measurement devices
from cyber attacks and insider threats. To this end, we ﬁrst
develop a comprehensive threat model for attacks against data
and ﬁrmware integrity, which can target any of the stakeholders
in the operation of
the sensor network. Next, we use our
threat model to analyze existing defense mechanisms, including
signature checks, remote ﬁrmware attestation, anomaly detection,
and blockchain-based secure logs. However, the large size of
the Trusted Computing Base and a lack of scalability limit
the applicability of these existing mechanisms. We propose the
Feather-Light Blockchain Infrastructure (FLBI) framework to
address these limitations. Our framework leverages a two-layer
architecture and cryptographic threshold signature chains to
support large networks of low-capacity devices such as meters
and data aggregators. We have fully implemented the FLBI’s
end-to-end functionality on the Hyperledger Fabric and private
Ethereum blockchain platforms. Our experiments show that the
FLBI is able to support millions of end devices.

Index Terms—IoT, sensor networks, security, blockchains.

I. INTRODUCTION

As part of the global Smart Cities drive, IoT sensor net-
works have emerged that consist of hundreds of thousands
of measurement devices. This growth has been driven by the
development of efﬁcient IoT networking protocols [1] and
an abundance of low-power measurement devices. Advanced
Metering Infrastructures (AMIs), which consist of smart me-
ters that do not require manual readouts [2], are a prominent
example. Meters in an AMI take readings at high frequency
and send them to a utility company over a computer network.
Other examples of large-scale sensor networks include security
cameras, of which some 200,000 are planned to be installed in
Singapore by 2030 [3], and patient monitoring in a city-wide
healthcare system [4].

Meanwhile, sensor networks are also becoming valuable
targets for cyber attacks. For example, AMIs are tightly
coupled with critical infrastructures such as power, gas, and

978-1-6654-9538-7/22/$31.00 ©2022 IEEE

water [5], which attract powerful adversaries [6]. In particular,
by tampering with the integrity of AMI data, an attacker can
deceive a utility company into making incorrect grid balancing
decisions or sending incorrect bills. This can have a large-
scale, visible impact on people’s lives, e.g., attackers can cause
wide-area blackouts and cascading power line failures [7], [8].
Similarly, attacks against security cameras can impair crime-
ﬁghting efforts, whereas attacks against healthcare data can
endanger the lives of patients. An additional AMI security
threat involves the integrity of the ﬁrmware on the measure-
ment devices: by overwriting the ﬁrmware, an attacker can
seize control of the device, as witnessed by the recent Mirai,
VPNFilter, and Prowli botnets [9]. Attacks against data or
ﬁrmware integrity can remain undetected until the adverse
effects – e.g., incorrect load balancing decisions or a botnet
attack – have become evident. Detecting these attacks in a
timely manner is therefore an important security challenge.

Many solutions for securing data and ﬁrmware integrity
have been proposed for IoT networks [10], mobile networks,
and distributed systems. As a second contribution, we design
a blockchain framework, called the Feather-Light Blockchain
Infrastructure (FLBI), that addresses the above limitations. The
FLBI framework allows a consortium of operators and other
interested parties to maintain a secure log of measurement
and ﬁrmware updates. Our framework addresses the challenge
of minimizing the TCB through the use of a signature chain
that is maintained by the evolving consortium. The signa-
ture chain is veriﬁed inside the device bootloader. We keep
the added complexity minimal through the use of threshold
signatures [11], which shift
the computational burden to
the operators’ servers. To the best of our knowledge, this
is the ﬁrst application of chains of threshold signatures in
this context. The FLBI addresses the blockchain scalability
problem by using a two-layer blockchain architecture [12].
This architecture consists of a top-layer blockchain maintained
by the consortium members, and a large number of bottom-
layer blockchains running on low-capacity devices that are
in close proximity to the devices (e.g., data concentrators).
Although two-layer mechanisms have been proposed before in
the literature, they often lack a concrete, publicly accessible
implementation. Furthermore, the FLBI includes mechanisms
that defend against a variety of blockchain-speciﬁc attacks.
In particular, it distributes nodes evenly across bottom-layer
blockchains, introduces cooldown periods, and supports round-
robin leaders.

 
 
 
 
 
 
As a third contribution, we have developed end-to-end
implementations of the FLBI on both Hyperledger Fabric and
private Ethereum. We have evaluated their performance on
a testbed consisting of Raspberry Pis that represent bottom-
layer blockchain nodes, and an IoT development board with a
modiﬁed bootloader that represents an end device. By contrast,
many existing blockchain-based approaches for data integrity
lack realistic end-to-end experiments [13], [14], [15]. Our
experiments show that the FLBI is able to support millions of
devices. The code that we used for our experiments is publicly
available at https://github.com/FLBI-Team/ﬂbi.

In summary, we make the following contributions:
1) A comprehensive threat model for data and ﬁrmware
integrity that includes attacks against all the main entities
in an IoT sensor network – we survey existing defense
mechanisms and evaluate them within this model.

2) A blockchain framework for IoT data and ﬁrmware
integrity that minimizes the TCB through the use of
threshold signature chains, and which achieves scalability
through a two-layer architecture.

3) An end-to-end implementation of our framework with
real-world smart meters and an IoT development board.
Our experiments show that our framework can support
hundreds of thousands of end devices.

Throughout this work, we will focus on a single case study,

namely smart grids and AMIs, for illustrative purposes.

The structure of this paper is as follows. We ﬁrst give
an overview of the relevant background on smart grids,
blockchains, and digital signatures in Section II. We present
our system model and requirements in Section III, and the
corresponding threat model in Section IV. We discuss the
limitations of existing methods in Section V, and present the
FLBI framework that addresses them in Section VI. We present
our empirical results in Section VII, discuss related work in
Section VIII, and conclude the paper in Section IX.

II. BACKGROUND

Smart Meters. As mentioned in the introduction, we will
focus in this work on AMIs as an illustrative example of large-
scale sensor networks. The main building block in an AMI is
the smart meter, whose purpose is to convert a physical input
signal – e.g., power or water ﬂow – into a digital measurement.
The main components of the smart meter include the sensor,
a microcontroller unit (MCU) that runs the device ﬁrmware,
memory (ﬂash memory and RAM), and a communication
interface [16], [17]. Other components typically include the
power supply, an analog-to-digital converter (ADC), a real-
time clock, and an LCD display

The MCU is responsible for processing information from
the sensors, whereas the communication interface allows the
meter to interact with its operator (i.e., the utility company).
The measurements are stored on the MCU’s built-in ﬂash
memory until they are pulled by the operator. To enhance
security, a meter may also include secure components such
as a Trusted Platform Module (TPM) that can be used to sign
messages or for remote ﬁrmware attestation [18], [19], [20].
Another secure component is the built-in read-only memory

2

(ROM) on which secure, immutable elements of the ﬁrmware
(e.g., the bootloader) can be installed. Together, the TPM and
the secure memory (including the bootloader) comprise the
meter’s TCB. A graphical representation of the meter’s main
components can be found in Figure 1 in Section III.

Blockchains. A blockchain is a data structure that allows a
network of mutually distrusting parties to maintain a tamper-
resistant digital
ledger. Elementary write operations called
transactions are created by nodes within the network and
broadcast to the other nodes. Transactions are grouped into
blocks. Starting from the genesis block, the blockchain is
extended through a consensus protocol in which nodes are
consecutively selected to propose new blocks. When a node is
selected, it chooses a group of not-yet-included transactions,
decides on their ordering, and executes them sequentially. The
transactions are then added to a block alongside metadata such
as a timestamp and the hash of a previous block. Finally, the
block is transmitted across the network.

A chain can be constructed from any block to the genesis
block through the previous-block hashes. This protects against
data tampering: if as little as a single bit is changed in a
block,
then its hash is different and the chain is broken.
Blockchains can be permissionless, i.e., any node is allowed
to propose blocks if they meet certain requirements such
as computational power, or permissioned, i.e., only a ﬁxed,
known set of nodes can propose blocks [21]. In this work,
we focus on permissioned (or private) blockchains, and the
transactions are always calls to functions of smart contracts,
which are pieces of software uploaded to the blockchain.

Cryptographic Primitives.

Several security mechanisms
discussed in this paper, including the FLBI framework of
Section VI, use digital signatures. A digital signature scheme
[22] consists of the key generation, signing, and veriﬁcation
algorithms Key-Gen, Sig, and Ver as follows:

•

•

•

←

←

Sig(sk, m) takes a secret key sk and a message m as

Key-Gen(1λ) takes a security parameter λ as
(sk, pk)
input, and outputs a secret key sk and a corresponding
public key pk.
σ
input, and outputs a valid signature σ on m.
Ver(pk, m, σ) takes a public key pk, message m, and
v
signature σ as input, and outputs a value v
such
that if v = 1, then σ is a valid signature of m under pk
with overwhelming probability, and v = 0 if and only if
σ is an invalid signature of m under pk.

0, 1
}

∈ {

←

We focus on two main types of digital signature schemes.
The ﬁrst type relies on a single entity with a single secret key.
The second type uses threshold signatures [11]. In the latter
approach, n parties agree on a threshold t and participate in
the Key-Gen protocol. The output of Key-Gen consists of a
single shared public key pk and a set S =
with
a secret key ski for each participant i. The secret keys used
for Sig can be any set S∗
S with at least t members – i.e.,
at least t out of the original n members must collaborate to
generate the signature. However, the signature that is produced
is not necessarily more complex than one produced by the
ﬁrst type of signature scheme. Similarly, Ver is not necessarily
more complex for the second type of scheme than for the ﬁrst.
For the scheme used in our implementation [11], the resulting

sk1, . . . , skn

⊆

}

{

3

B. System Initialization

The data ﬂows in the system – measurements and ﬁrmware
binaries – can be digitally signed. In particular, the measure-
ments are signed by the smart meter’s TPM, and the ﬁrmware
binaries are signed by the OEM server. The digital signature
scheme used by these two entities need not be the same: the
TPM’s algorithms are denoted by TPM.Key-Gen, TPM.Sig,
and TPM.Ver, and the OEM server’s algorithms by OEM.Key-
Gen, OEM.Sig, and OEM.Ver. We assume that TPM.Key-
Gen is executed prior to the production of the meters, that the
resulting secret key skTPM is hardcoded in the TPM, and that
the public key pkTPM is shared with the utility company. We
also assume that OEM.Key-Gen has been executed prior to
the meters’ production, that the resulting secret key skOEM is
stored on the OEM’s server, and that the public key pkOEM is
either stored in the meter ﬁrmware or in the ROM (we discuss
this in more detail in Section V).

In our model, the meter’s ﬂash memory has two partitions:
the ﬁrst partition stores the current ﬁrmware version, and the
second a new binary that is checked after the next reboot.

C. Measurement Flow

After initialization, the normal ﬂow of measurement data

consists of steps 1-8 as depicted in Figure 1.

1.

In the ﬁrst step, the sensor generates a measurement
to the

input signal and sends it

x based on the physical
processing unit.

2 & 3. Next, the processing unit sends x to the TPM,
which produces a signature σx = TPM.Sig(skTPM, m). The
TPM sends σx back to the processing unit.

4 – 7. The processing unit then forwards x and σx to the
meter’s communications module, which sends this data to the
company server via the DCU and the WAN.

8. Finally, the company server receives both x and σx and
determines vx = TPM.Ver(pkTPM, x, σx). If vx = 1, then σx
is valid and x is sent to the storage. For additional security,
σx can be stored as well, as we discuss in Section V.

D. Firmware Flow

The normal ﬂow of ﬁrmware updates consists of steps i-v

as depicted in Figure 1.

i – iii.

In the ﬁrst step, the OEM creates a new ﬁrmware
binary b and produces a signature σb = OEM.Sig(skOEM, b).
This is then sent to the smart meter via the network and the
DCU – in practice, the update would typically be sent to the
utility companies’ servers ﬁrst, but this is considered part of
sending it through the network, i.e., step i. Note that sending
ﬁrmware updates via the DCUs relieves the OEM or company
server from sending a sizable ﬁrmware binary to potentially
millions of meters through direct connections.

iv. After it has been received by the meter, b and σb are
copied to the second partition of the meter’s ﬂash memory,
and a reboot is triggered.
v. After the reboot,

the bootloader checks whether a
ﬁrmware binary and signature are available on the second
partition and whether it is the same as the ﬁrst partition’s

Fig. 1: AMI system model.

signature is an ECDSA signature [23] that is as easy to verify
in a smart meter’s bootloader as a single-party signature.

III. SYSTEM MODEL AND REQUIREMENTS

A. System Model: Entities

Our system model consists of the following entities:
Input signal. This represents the physical process that the
meter is measuring, e.g., power ﬂow on a line, or water or gas
in a pipeline.

Smart meter. The meter itself consists of trusted and
untrusted components. Trusted components include the TPM,
the code in the ROM (including the bootloader), and the secure
memory. The untrusted parts include the sensor, the device
ﬁrmware, and the components controlled by the ﬁrmware, i.e.,
the RAM and ﬂash memory, the communications module, and
the processing unit. Other smart meter components – e.g., LCD
displays or the power supply – do not affect data integrity and
are therefore not included in the model.

MDMS server. This is a server run by the utility company.
It operates a Meter Data Management System (MDMS) [16],
[2], [10], [24], and is hence responsible for the storing and
processing of measurement data.

Data storage. This is where the measurement data is stored.

The storage can be seen as part of the MDMS system.

OEM server.

This is run by the Original Equipment
Manufacturer (OEM), i.e., the company that produces and
maintains the hardware and ﬁrmware of the meters. The OEM
is responsible for ﬁrmware updates, which are sent from the
OEM server.

DCUs. The meters are connected to Data Concentrator
Units (DCUs) over a Local Area Network (LAN). The rela-
tionship between the meters and the DCUs is many-to-one, and
the relationship between the DCUs and the company server is
also many-to-one. DCUs enhance the scalability of the system
by reducing the number of devices that the company server
needs to poll to retrieve measurements. DCUs are typically
located at a physically secure location in a building complex
or distribution substation [2], [25].

WAN. The DCUs communicate with the utility company
servers over a Wide Area Network (WAN), e.g., the Internet.
Firmware updates are sent over the same network.

DCUTrustedComputingBaseFirmwareSmartMeterinputsignalubootTPMsensormemorycomms.proc.OEMserverWANMDMSserverstoragex1,σx1x2,σx2...12345678iiiiiiivvbinary. If not, it computes vb = OEM.Ver(pkOEM, b, σb), and
if vb = 1, then b and σb are written to the ﬁrst partition.
If vb = 0, or if the ﬁrmware version is the same on both
partitions, then the bootloader loads the ﬁrst partition’s binary
and signature – if the signature is valid, it boots the ﬁrmware
from this partition, and terminates the boot process otherwise.

E. System Requirements

An AMI should meet the following security goals, which it

shares with IoT sensor networks in general:

•

Data integrity: each stored measurement corresponds
to the state of the physical input signal at the time of
recording.
Firmware integrity: the binary that is loaded by the
meter’s bootloader corresponds to the latest version that
has been produced by the OEM and received by the meter.
To have practical relevance, a design that meets our security
requirement should also satisfy the following system goals:

•

•

•

Scalability: it can handle the load generated by a real-
world AMI consisting of a large number of meters.
Deployability: it
AMIs.

incurs minimal changes to existing

IV. THREAT MODEL

In the previous section, we presented our model of the
normal ﬂow of measurement and ﬁrmware data. In our model,
four types of data are sent between the entities: the mea-
surement x, the ﬁrmware binary b, and the corresponding
signatures σx and σb. The goal of the attacker is to violate
data (or ﬁrmware) integrity by altering x (or b) before or at the
end of the ﬂow. The attack surface consists of the 7 different
entities in our model. For brevity, we denote the attack against
entity i by Ai for i = 1, . . . , 7.

Input signal & sensor (A1). If the attacker has direct access
to the meter, then it can be possible for her to tamper with the
input signal without touching the meter itself. For example, a
power sensor may be distorted by holding a magnet close to it,
or high-wattage devices can be disconnected from the meter’s
circuit and connected directly to the grid [26]. In this attack,
the integrity of the measurement x is altered at the source,
and σx is altered because x is changed before it is signed.
Tampering with the meter’s sensor has the same effect.

Meter ﬁrmware (A2). An attacker with direct access to the
meter may be able to replace the device ﬁrmware directly. For
example, the meter may have an input channel (such as a USB
port) that allows the attacker to ﬂash the ﬁrmware. There may
also be a zero-day vulnerability in the current ﬁrmware that
can be exploited, or it may be possible to physically replace
the ﬂash memory that contains the binary. This attack allows
the attacker to alter the version of b on either memory partition,
but not σb because this would require the OEM’s secret key. If
the attacker controls the device ﬁrmware or the communication
between the components in the device, then it is possible to
alter x, and additionally σx if x is changed before it is signed.
MDMS server (A3). The computer systems of the utility
company can be compromised, for example through hacking,

4

spear-phishing [6], or malicious insiders [27]. This may allow
the attacker to obtain passwords that give access to authorized
communication channels, or that give write access to the data
stored on the MDMS servers. This enables the attacker to alter
x, but not σx because the TPMs of the devices are not affected.
Access to the secure communication channel may also enable
the attacker to push malware to the meters via the DCUs if
updates pass by the MDMS servers on their way from the
OEM servers to the meters. As such, the attacker may send
an altered b to the meters via the DCUs, but not a matching
σb because that would require skOEM, the OEM’s secret key.
If there is a log of the ﬁrmware update history, then this can
also be overwritten by the attacker.

Data storage (A4).

If the attacker gains access to the
data storage, then she can alter the historical measurements
x1, x2, . . . , xn. However, she will not be able to alter the his-
torical signatures σx 1, σx 2, . . . , σx n since this would require
access to the TPM keys.

OEM Server (A5). The computer systems of the OEM
are vulnerable to the same types of attack as the MDMS
servers. Compromising the OEM servers may allow an attacker
to obtain the key skOEM that allows her to sign a malicious
ﬁrmware binary b, or to send such a b to the utility company
via the WAN. Hence, this enables her to alter both b and σb.
An attacker may even be able to retrieve TPM secret keys if
these have been stored, or during the production of the meters.
This would allow the attacker to alter measurement signatures
if A5 is combined with other attacks.

DCUs (A6). Compromising the ﬁrmware on the DCU may
allow the attacker to alter both x and b. However, it does not
allow for the signatures σx and σb to be altered.

WAN (A7). Although the communication between the
DCUs and OEM and MDMS servers can be made secure
using SSL/TLS, this can be compromised by an attacker, e.g.,
through the use of a forged X.509 certiﬁcate. The effects are
the same as for the DCUs (A6): the attacker can alter x and
b, but not σx and σb.

V. LIMITATIONS OF EXISTING COUNTERMEASURES

A. Existing Defense Mechanisms

In this section, we discuss four existing defense strategies
for data integrity attacks that are suitable in the context of AMI
data and ﬁrmware integrity. We identify which combinations of
defense mechanisms satisfy the requirements of Section III-E,
and discuss their limitations.

Signature Checks (D1, D2, D3, and D4). To prevent
arbitrary ﬁrmware from being installed,
the meters check
whether any new ﬁrmware binary b has a correct signature σb
[28], [29]. In practice, the OEM’s signature can be checked
immediately before an update [29], or after every reboot by
the bootloader which we assume to be stored on the smart
meter’s ROM [30], [28]. In our model, we have assumed the
latter. The public key that is used to verify the signature can
be stored on the (untrusted) ﬂash memory, or on the (trusted)
ROM. We label the ﬁrst case as D1, and the second case –
i.e., a hard-coded public key – as D2.

Similarly, the utility company veriﬁes measurement signa-
tures. The company can verify the signatures of incoming

measurements (D3) before storing them, and if the signatures
are stored then the signatures of historical measurements can
be veriﬁed as well (D4).

Remote Attestation (D5). In this mechanism, either the TPM
[19], [18], [24] or a cumulative attestation kernel [20] provides
remote attestation, or is able to sign messages with a version-
dependent private key. This allows the MDMS server to detect
ﬁrmware tampering by querying the meter’s current ﬁrmware
version and comparing it to a history of ﬁrmware updates
stored on the server. We include speciﬁcation-based intrusion
detection [31], [32] as a variation of this defense mechanism.
Anomaly Detection (D6). Anomaly detection is a means of
detecting data tampering. We consider two categories: in the
ﬁrst, the recent measurement patterns of a single meter are
compared to the measurements of the other meters [33]. In the
second, the recent measurements of a meter are compared to
the same meter’s historical usage pattern [34], [35], [36], [37].
Anomaly detection can also be used to detect ﬁrmware tam-
pering, but this requires data – e.g., memory jump sequences
[33] – outside our system model. The accuracy of anomaly
detection methods depends on factors such as the size and
recency of the training dataset, and the generality of the class
of anomalies that is considered, but a full discussion of these
aspects is beyond the scope of this paper.

Blockchains (D7). Blockchains have the property that as
long as (at least) a majority of the nodes (weighted by consen-
sus power) has not been compromised, then attempts to change
blockchain data are instantly detectable. This property can
be applied to secure the integrity of historical measurements,
and of the ﬁrmware update log on the MDMS server. Several
blockchain-based approaches have been proposed in the liter-
ature for this purpose [38], [13], [14], [15], [39]. A blockchain
can store aggregated, periodically uploaded metadata (e.g., a
hash of a large batch of measurements, or a hash of the entire
dataset), or the (encrypted) data itself. In either case, this data
is replicated on each node that participates in the blockchain.

B. Limitations

Table I summarizes the relationship between the different
data types and the attacks and defense mechanisms. For
measurements and the corresponding signatures, we distin-
guish between incoming measurements (“new”) and historical
(“log”) measurements that have already been stored. For the
binaries, we distinguish between the log of historical ﬁrmware
versions on the MDMS servers (“log”), the current (“curr.”)
ﬁrmware version on the meter’s ﬁrst partition, and the new
ﬁrmware binary on the meter’s second partition (“new”). Some
defense mechanisms require the integrity of certain data types
– e.g., remote attestation (D5) requires an accurate log of
ﬁrmware updates (b (log)), whereas anomaly detection (D6)
requires accurate training data (x (log)).

We can now identify the combinations of defense mech-
anisms that satisfy the requirements of data integrity and
ﬁrmware integrity as deﬁned in Section III-E. In particular,
data integrity is satisﬁed if integrity violations in new x can
be detected in all combinations of attack vectors in our threat
model – similarly, ﬁrmware integrity is guaranteed if integrity

5

TABLE I: Summary of the relationship between the various
data types and the attacks and defense mechanisms.

data type

threatened by

protected by

required by

x (log)
x (new)

σx (log)
σx (new)

b (log)
b (curr.)
b (new)

σb (log)
σb (curr.)
σb (new)

A4
A1−4, A6, A7

D4, D7
D3, D6

A5
A1, A2, A5

A3
A2
A2, A3, A5−7

A4
A5
A5

D7
D5
D1, D2

D6

D4
D3

D5
D1

D1, D2

violations in new b can always be detected in our threat
model. In the following, we discuss which combinations of
mechanisms satisfy data integrity and ﬁrmware integrity –
however, we ﬁnd that all of these have limitations.

Firmware Integrity.

signature checks can detect ﬁrmware
integrity violations. However, performing these checks in the
current ﬁrmware version (D1) is insecure unless the current
ﬁrmware version would be part of the TCB. However, this
would signiﬁcantly increase the TCB size. This limitation can
partially be addressed by periodically checking the current
ﬁrmware version through remote attestation (D5) – however,
this is slow and depends on the integrity of the log of ﬁrmware
versions on the MDMS servers, which itself would need a
blockchain (D7) to be secure. Furthermore, D1 is unable to
detect integrity violations if the OEM’s key has been stolen
and the attacker has signed the compromised binary (A5).

Performing the checks inside the bootloader (D2) addresses
the ﬁrst limitation by keeping the TCB small without needing
remote attestation for the current ﬁrmware version. However,
a na¨ıve implementation of D2 is still unable to detect attacks
when the OEM’s key is stolen – in fact, in this case, the
meters are unable to fully recover without a factory recall
as the OEM’s key is stored in the secure memory, and such
a recall would violate our requirement of deployability. In
Section VI, we show how to address this limitation of D2.
By using multiparty signatures and evolving signature chains,
the meter is able to recover from stolen OEM keys without
a recall. Furthermore, a cooldown period for the multiparty
signatures gives the OEM a time window to detect that its key
has been stolen. Verifying the multiparty signatures inside the
meter’s TCB is non-trivial – however, we show how this can
be done efﬁciently using threshold signatures.

Data Integrity.

incoming measurements x can be protected
by a blockchain-based log (D7) combined with anomaly detec-
tion (D6). This protects x from all attacks, including tampering
with the sensor or input signal (A1). If only hashes are logged
on the blockchain, then this mechanism can detect any form of
tampering with x. However, this combination of mechanisms
would not be able to recover from data tampering: it would
conclude that the training data has been tampered with, but
the attack would still render all forms of anomaly detection
using this dataset invalid in the future. This can be addressed
by storing all (encrypted) data on the blockchain. However,

6

B. Entities

Consortium Members. The consortium is the group of
companies and organizations that are involved in operating the
blockchains. The consortium must include utility companies
who operate meters and who add data to the bottom-layer
blockchains, and OEMs who add information about ﬁrmware
updates to the top-layer blockchain. 1 Other interested parties
such as regulators and consumer organizations can operate
nodes on both levels, even if they do not add measurements
or ﬁrmware updates.

For the FLBI framework to be sustainable in the long term,
it must be able to support periodic changes to the set of
consortium members. As such, the consortium’s membership
set is dynamic. For any update, if n = 3f + 1 members are in
the current set, then at least 2f + 1 need to agree to the update
through a digitally signed vote. Therefore, it is advisable that
n is large enough to recover from multiple failures (e.g.,
permanent losses of signing keys). Meanwhile, the consortium
should avoid including frivolous members who cannot be
trusted to respond to proposed updates, as the protocol can
tolerate at most f abstentions when the membership set is
updated. As such, a balance must be struck between including
too few or too many members. In the following, we assume
that n is roughly equal to 16.

Top-Layer Blockchain. The top-layer blockchain provides
access control – i.e.,
the public keys of the consortium
members, of the top-layer nodes, and the meters. It also
maintains a log of ﬁrmware updates and stores the latest
shared public key pki. A single smart contract called the top-
layer contract implements all functionalities of the top-layer
blockchain. Each consortium member runs a single top-layer
node on a highly available online computer, e.g., an MDMS
server. The computer that runs the top-layer node also runs
an application called the top-layer client
that provides an
interface to create smart contract transactions, e.g., consortium
updates or new ﬁrmware updates. The top-layer client also
transmits information to the bottom-layer nodes that belong to
the same company, e.g., to push ﬁrmware binaries and public
key updates. This mapping between top-layer nodes to bottom-
layer nodes is one-to-many. To produce threshold signatures,
the top-layer clients have the ability to communicate with each
other to interactively execute the Thres.Sig protocol.

To defend against blockchain-level attacks, the top-layer
to ensure that no bottom-
clients also execute a protocol
layer blockchain l becomes dominated by a single consortium
member c. In particular, when any c creates a proposal to add
a new node to l, then the other clients compute for all bottom-
layer blockchains how many nodes are controlled by c in that
blockchain. The high-layer nodes vote to reject the proposal
if l is not one of the bottom-layer blockchains on which c is
represented the least. That is: let ncl be the number of nodes
controlled by c in bottom-layer blockchain l, L the set of
bottom-layer blockchains, and Nl the total number of nodes
L. Let φcl = ncl/Nl be the fraction of nodes
in blockchain l

∈

1If there are OEMs who are responsible for some added meters but who
do not join the consortium, then information about their ﬁrmware updates can
be added by the utility companies as well.

Fig. 2: Design of the FLBI.

this requires that large quantities of data are stored on the
blockchain, so scalability is a limitation. In the next section,
we address this limitation through a two-layer architecture.

VI. THE FLBI FRAMEWORK

In this section, we present the FLBI framework, which
allows a consortium of operators and other interested parties
to address the limitations identiﬁed in Section V-B. In the
following, we ﬁrst discuss our notation and the entities that
participate in the FLBI. We then brieﬂy discuss the program-
ming code and the end-to-end protocols of the core pro-
cesses: measurement logging, ﬁrmware updates, and changes
to the consortium. A graphical representation of the two-layer
blockchain framework can be found in Figure 2. In this exam-
ple, a consortium consisting of 5 members operates a top-layer
blockchain. There are also many bottom-layer blockchains,
which are operated by nodes that run on low-power devices
owned by the consortium members. Each bottom-layer node
can have a large number of meters assigned to it.

A. Notation & Assumptions

In the following, we assume that each top-layer node can
sign messages. As such, its digital signature scheme consists
of the algorithms HLN.Key-Gen, HLN.Sig, HLN.Ver. During
initialization each top-layer node c runs HLN.Key-Gen, stores
the resulting secret key skHLN
with the other
top-layer nodes. Each meter j’s TPM has secret key skTPM
and
public key pkTPM

, and shares pkHLN

c

c

.

j

j

|

Ci
|

integer such that ni

We use the following notation for the threshold signature
scheme: Thres.Key-Gen, Thres.Sig and Thres.Ver. We denote
the set of members (represented as integers) after the ith
membership update by Ci. Let ni =
be the size of
3fi + 1.
Ci, and fi
the largest
The Thres.Key-Gen algorithm is run during initialization and
results in a shared public key pk0 and set of private keys
S0 =
. After the ith membership update,
i > 0, let pki be the shared public key, and ski,j be the secret
key of member j. Let Si be the set of secret keys after the ith
update, i.e., Si =
Ci. We assume that all the public
∈
keys and private keys are unique (i.e., even if Ci = Cj for
some i < j, we expect the members to generate new keys and
not reuse the old ones).

sk0,1, . . . , sk0,n

ski,j
{

j
}

≥

}

{

11223344551234123451245···top-layersmartcontractbottom-layersmartcontractbottom-layersmartcontractbottom-layersmartcontracttop-layernodes(runoncompanyservers)bottom-layernodes(runondevicesnearthemeters)meterscontrolled by c in l. In our protocol, the high-level clients vote
to reject adding a new node operated by consortium member
c∗ to l∗ unless φc∗l∗ = minl
L φc∗l. Hence, the protocol seeks
∈
to enforce that φcl < 1

3 for each c and l.
Bottom-Layer Blockchains. The bottom-layer blockchains
provide secure measurement
logging. Each bottom-layer
blockchain operates a single smart contract called the bottom-
layer contract. Each smart contract stores a different set of
measurement data, so there is no need for interaction between
different bottom-layer blockchains. The bottom-layer nodes
are run on devices that are situated close to the meters, e.g., on
the DCUs or on devices placed in the same secure location.
The computational power of the nodes is assumed to be at
least comparable to that of a Raspberry Pi 4.

Each bottom-layer blockchain node runs an application
called the bottom-layer client that listens for messages from
the high-level client. If it receives a public key update, it
will propose the same update to its blockchain if it has not
been proposed by another node already. If it is not the ﬁrst to
propose, it will vote to support updates that match the ones
that it has received and ignore other updates.

Meters: Finally, to address the challenge of recoverability,
we update the bootloader of the smart meter to support updates
to the public key stored in its ROM through signature chains.

C. Smart Contracts

Due to space limitations, we do not discuss the detailed
implementations of the smart contract functions and the clients
in the main text. However, a summary of the smart contract
functions is given in Table II, and the code used in the exper-
iments can be found at https://github.com/FLBI-Team/ﬂbi.

TABLE II: Overview of the smart contract functions

smart contract

functionality

top layer

ﬁrmware updates

access control

function name
putFirmware
vetoFirmware
checkFirmware
updateAdminKey

both layers

access control

proposePubKey
votePubKeyProposal

bottom layer

measurement logs

putMeasurement

D. End-to-End Protocols

We present a high-level overview of the end-to-end proto-
cols for measurement logging, ﬁrmware updates, and consor-
tium membership updates below.

For measurement logging, each measurement x is sent from
the meter to its bottom-layer node, which encrypts it and
uploads it to the bottom-layer blockchain through a call to
the putMeasurement function from Table II.

For ﬁrmware updates, a hash of the binary b is uploaded
by the OEM server to the blockchain, and after the end of the
cooldown period, the OEM asks a group of at least 2f + 1
other consortium members to produce a threshold signature
for the binary hash. The binary and signature are sent to the
meter, which hashes the binary, checks the signature for the
hash, and if successful boots the new ﬁrmware.

7

To

reﬂect

updates,

consortium membership

each
the OEM produces a chain
ﬁrmware update requires that
(pk0, σ1, pk1, . . . , σn, pkn) of alternating public keys and
signatures. Here, pk0 is the initial public key that is hard-
coded in the meter’s ROM, pki is the public key after the
1, pki) is
ith membership update, and σi = Thres.Sig(S∗i
−
the threshold signature for pki+1 produced by a group S∗i
1
−
that consists of at least 2fi+1 + 1 members of the i
1th
consortium. This process is depicted in Figure 3. The chain
is sent to the meter alongside the ﬁrmware binary. Next, the
bootloader veriﬁes the chain through the repeated veriﬁcation
of ECDSA signatures – if successful, the meter updates the
consortium’s public key to the last public key in the chain.
This ensures that the bootloader uses the current consortium’s
public key before checking the signature of the new binary.

−

Fig. 3: Evolution of the key/signature chain as members join
and leave the consortium.

E. Analysis: Security Against Blockchain Attacks

As discussed in Section V-B, blockchains have security
requirements that do not ﬁt into the system model. We provide
an informal analysis of two notable attacks in this section.

≥

Minority Attacks in the Bottom-Layer Blockchains.

In the
FLBI framework, the bottom layer consists of L blockchains
that can each be attacked independently. Each bottom-layer
blockchain uses PBFT [40] for consensus, which is secure
only if at most f out of the n
3f + 1 of the nodes are
compromised. It is a challenge to ensure that this threshold
holds in every bottom-layer blockchain. Most of the layer-
two and sharding proposals in the literature [41], [42] use
periodic reconﬁguration of the nodes among the bottom-layer
blockchains to achieve a diverse or unpredictable mixture of
nodes. Our setting allows for a simpler solution with a stricter
guarantee. The reason is that the nodes in different bottom-
layer blockchains are not
independent, because one entity
(e.g., a utility company) typically controls many nodes across
different bottom-layer blockchains. In Section VI, we have
described a protocol in which clients vote to reject proposals
to add a bottom-layer node to a chain unless it is the chain on
which the proposing entity is represented the least. As a result,
no single entity can concentrate its nodes in a single bottom-
3f + 1 requirement
layer blockchain, hence violating the n
if it is compromised by an attacker.

≥

pk0pk1Sig(S∗0,pk1)pk2Sig(S∗1,pk2)1234123456712346hardcodedinROMconsortiumCiafterimembershipupdatesC0C1C2chainofpublickeysandsignaturesgen.S0,pk0signpk1withS∗0S∗0⊆S0,|S∗0|≥3gen.S1,pk1signpk2withS∗1S∗1⊆S1,|S∗1|≥5gen.S2,pk2Network and timing attacks. Our network assumption is
partially synchronous – i.e., partitions are eventually resolved,
and nodes’ messages can eventually reach the rest of the net-
work. However, communication from the meters to the outside
world may be disrupted, due to attacks such as radio jamming,
DoS, or other network-level attacks. Such attacks quickly
become evident when a meter’s readings stop appearing on
the log. However, temporary network disruption may impact
the security of the top-layer blockchain operations. More
speciﬁcally, both ﬁrmware updates and changes to the access
control list use a cooldown period during which vetoes can be
cast. This period is important for preventing compromised keys
to sign malicious ﬁrmware. In particular, during this period the
signing key can be revoked, rendering the proposed ﬁrmware
invalid. If this cooldown period is implemented using a local
clock, then the adversary can disrupt the network until the
cooldown period is over, preventing any veto from making
it onto the blockchain. To mitigate this, we implement the
cooldown duration in terms of the number of blocks. For
instance, a cooldown period of T blocks means that a reject
vote must be cast within T blocks from the block in which
the proposal is recorded. In other words, after T blocks, the
proposal is considered to be valid. Our solution works with the
assumption that a transaction sent at the same time as block b
will get included in the blockchain at block b + T at the latest.
the desired
cool-down period length in minutes, by the average number
of blocks added to the blockchain per minute. However, an
adversary who controls one or more companies’ top-layer
nodes can inﬂuence the speed at which new blocks are added,
e.g., by spamming empty blocks. This threat
is mitigated
by using a round-robin consensus protocol to select block
proposers. An adversary who controls f out of n nodes and
who proposes new blocks in negligible time can at worst
reduce the duration of the cool-down period to n
f
n τ minutes,
−
f out of every n blocks will be proposed by non-
as n
compromised nodes. A round-robin protocol also protects
against censorship attacks, in which the adversary refuses
to include blacklisted transactions – e.g., a transaction that
revokes a key. Since one non-compromised node is selected
at least every n blocks, it will include the transaction and this
block will be committed if at least 2f + 1 non-compromised
nodes vote to support it. We do require a form of transaction
prioritization, as an adversary could otherwise attempt to ﬂood
the mempool – i.e., the list of pending transactions – of the
non-compromised nodes with spurious transactions. As such,
we give key revocations and vetoes a higher priority at the
level of the consensus protocol than other votes and limit the
ability of nodes to create this type of transaction.

A practical choice for T is to multiply τ ,

−

VII. PERFORMANCE EVALUATION

To evaluate the practical performance of the FLBI frame-
work, we have fully implemented it on top of both private
Ethereum and Hyperledger Fabric (“Fabric” for brevity). In
the following, we ﬁrst describe the experimental setup in
detail and then discuss the experimental results on transaction
throughput and latency. We note that we do not have an

8

appropriate baseline for an experimental comparison, because
the other blockchain approaches for data integrity that we are
aware of do not present realistic end-to-end experiments.

A. Experimental Setup

We use Fabric version 0.6, which supports the PBFT
consensus protocol and has higher performance than version
1.4 [21]. For Ethereum, we use geth version 1.9. The smart
contracts are written in Go and Solidity. We collect data
generated by 6 Ampohub B1 smart meters that run in our local
testbed, and replay it through a client running on a laptop.
The data ﬁelds include: meter identiﬁer, supplier identiﬁer,
metadata, power, voltage, and frequency readings.

Our setup consists of

two blockchains. The top-layer
blockchain consists of 4 nodes, such that each node has 16
GB RAM and an 8-core CPU. The bottom-layer blockchain
consists of up to 16 nodes, each node runs on a Raspberry
Pi (RPI) model 4B, each with 4 GB RAM and a 64 GB SD
card. The Raspberry Pis, which have limited computational
capabilities, represent the bottom-layer blockchain nodes. The
Pis are connected through a NETGEAR 24-Port gigabit Eth-
ernet unmanaged switch. Each Pi runs the Raspbian Buster
operating system. To evaluate the ﬁrmware update protocol,
we use a Linkit smart 7688 development board. In total, we
have added 259 lines of code to the TCB – in particular, to
U-Boot [43], which acts as the bootloader for the Linkit.

B. Blockchain performance

Figures 4a and 4b compare the performance of Hyperledger
and Ethereum using 4 nodes for measurement logging (i.e.,
using the putMeasurement function). Each measurement is
cryptographically hashed, timestamped, and signed before it is
sent to the blockchain. The peak throughputs of Hyperledger
and Ethereum are 60 and 200 transactions per second (txs), re-
spectively. The reason that Ethereum performs better is that it
parallelizes the signature veriﬁcations for multiple transactions
within the same block, as opposed to verifying them sequen-
tially. If each meter produces a reading every 30 minutes (as in
[44]), then a throughput of 60 txs means that 108, 000 meters
can be supported in each bottom-layer blockchain. In this
case, ten bottom-layer blockchains would be able to support
more than a million meters. Figures 4c and 4d show peak
throughput and latency with a varying number of nodes. We
can see that the throughput does not change for Hyperledger,
suggesting that consensus is not the bottleneck. However, the
throughput degrades signiﬁcantly for Ethereum, meaning that
the consensus protocol becomes a bottleneck as each bottom-
layer network grows in size.

To better understand this performance, we measure the
cost at the blockchain node. For Hyperledger, the consensus
latency is 20ms on average, and remains unchanged for
varying network sizes. Figure 6a shows the execution costs for
different types of transactions in Hyperledger. It can be seen
that the cost for normal transactions is in the order of tens
of milliseconds, which explains the low overall throughput.
Figure 6 shows the CPU and I/O utilization at the node. It
can be seen that none of the resources are fully utilized.

9

(a)

(b)

(c)

(d)

(e)

Fig. 4: (a) Throughput vs. load on 4 nodes for logging. (b) Latency vs. load on 4 nodes. (c) Max. throughput vs. number of
nodes. (d) Latency vs. load for 4-16 nodes in Hyperledger. (e) Latency of threshold key generation and signing algorithms.

Fig. 5: Latency breakdown for adding new meters and
ﬁrmware updates

These results suggest that the overall throughput can be further
improved by adding concurrency to transaction execution, to
ensure that more transactions can be executed simultaneously.
We have also tested the latency of the two main threshold
signature algorithms – Thres.Key-Gen and Thres.Sig – for
different consortium sizes. For our experiments, we have used
a library (https://github.com/binance-chain/tss-lib) that imple-
ments the protocol by Gennaro & Goldfeder [11]. We have
performed our experiments on the device that also runs the top-
layer blockchain nodes. The results are depicted in Figure 4e.
Key generation is the most expensive step, as it takes more
than a minute for 16 consortium members. However, this step
has to be performed only when the consortium is changed.
Signing takes slightly over 25 seconds for 16 members. This
step is performed only when a new ﬁrmware binary is signed.
By contrast, the cost of verifying the signature is the same
as verifying any ECDSA signature - on the Linkit device,
this took less than a tenth of a second. From this, we can
conclude that we have successfully shifted the computational
burden away from the low-power device’s TCB.

(a) Message size and Execution cost

(b) CPU (%) for putLogData calls

Fig. 6: Resource utilization with 16 nodes.

blockchain network at the OS level, and 2) verifying and
ﬂashing it at the hardware level. The cost includes: registering
the ﬁrmware to the blockchain, downloading the ﬁrmware to
the device, getting the new hash from the top-layer blockchain,
verifying the signature, and ﬁnally ﬂashing the new ﬁrmware.
The major cost comes from writing the new ﬁrmware to the
ﬂash memory partitions, which amounts to about 156s in total.
The protocol on the OS level takes less than 25s.

VIII. RELATED WORK

C. End-to-End latency

Figure 5a shows the end-to-end latency for adding a new
meter in the FLBI framework. The cost consists of adding a
public key to the top-layer blockchain, approving the new key,
requesting a proof, and adding the public key to the bottom-
layer blockchain. The entire process takes roughly 4s, and the
main cost comes from adding the key to each blockchain.

Figure 5b and 5c show the latency for updating the new
ﬁrmware on the device. There are two main procedures:
1) downloading and verifying the new ﬁrmware on the

Generic Mechanisms for Data Integrity. Generic mecha-
nisms that protect data integrity at any layer of an IoT sensor
network (device, network, or service) can be found in the
literature on IoTs, mobile networks, and distributed systems.
To protect
the device ﬁrmware, existing solutions include
code signing [45], deterministic builds [46], remote attestation
[19], anomaly detection [37], [35], [33], [36], and blockchain
solutions such as CHAINIAC [47]. To protect measurements
stored at the utility company servers, existing solutions in-
clude certiﬁcate transparency [48], witness cosigning [49], and
blockchains [38], [50], [51], [52], [53].

050100150200050100150200Load(tx/s)Throughput(tx/s)HyperledgerEthereum0501001502000100200300Load(tx/s)Latency(s)HyperledgerEthereum1234567101316100200300#NodesMax.Throughput(tx/s)HyperledgerEthereum4050607080020406080100Load(tx/s)Latency(s)4nodes10nodes16nodes468101214160204060#NodesLatency(s)KeyGenerationSigning68.177.19.6510.2788.27020406080100120140160180time (s)(c) Latency breakdown for firmware update -in hardwarestore new firmware+signaturerebootload+verify current firmwareload+verify new firmwareflash new firmware5.315210.10510152025time (s)(b) Latency breakdown for firmware update -OS level download new firmwareload current firmwarehash firmwaresget blockchain approvalverify signatures22.200.511.522.533.544.5time (s)(a) Latency for adding a new meterAdd meter (high level)Add meter (low level)bytesms0500100015002000020406080add Meter (HL)add Meter (LL)put Log Dataput FW UpdateMessage Size Execution TimeTime (s)CPU (%)01020304050255075100125Load 40 tx/sLoad 80 tx/seth Load 40 tx/seth Load 80 tx/sIf seen as individuals, each of these approaches falls short
in the context of security-critical sensor networks, and espe-
cially AMIs, for three reasons. First, AMIs involve multiple
stakeholders for whom privacy is important. In particular,
measurement logs can reveal valuable information about the
user, and the ﬁrmware typically contains business secrets.
The latter rules out approaches that would worsen privacy
by relying on multiple parties evaluating the source code or
attesting to the correspondence between the ﬁrmware’s source
code and binary [47], [50]. Second, individual mechanisms
have a narrow scope that fails to consider the interdependence
between attacks against the AMI’s different layers [54] or
components. For example, anomaly detection techniques that
aim to identify malicious ﬁrmware by identifying suspicious
measurements [36] will fail if the measurement logs have
been overwritten to include abnormal behavior. Third, due
to its critical nature, AMIs require strong guarantees against
Byzantine adversaries [40], which is not met by solutions such
as certiﬁcate transparency whose security depends on auditing
frequency and network conditions.

for Data Integrity.

Blockchain Mechanisms

In Section V, we have discussed how the second obstacle
can be overcome for remote attestation, anomaly detection,
and blockchain-based solutions within a unifying framework.
Several
blockchain mechanisms have been proposed in the literature
that address data integrity at
the device layer, but which
are not suitable in our context. Liang et al. [13] propose a
proof-of-work blockchain that is operated by the meters and
stores encrypted measurement data. However, proof-of-work
is vulnerable to 51% attacks by powerful miners [55] and is
known to waste computational resources, which is a major
obstacle on low-resource devices such as meters. They also
do not present an end-to-end implementation of their system,
but present simulation results instead.

Lee and Lee [14] propose an approach for secure IoT
ﬁrmware updates in which a number of high-power devices
maintain a proof-of-work blockchain that stores a history of
ﬁrmware versions. Low-power devices periodically query a
high-level node for the latest ﬁrmware version. If a new
ﬁrmware version is detected, it is sent to the requesting node
in a peer-to-peer manner. Although this method shares some
similarities with the one presented in Section VI, this work
does not address the question of how to recover the ﬁrmware
once it has been corrupted, as the software client that runs on
the meter and interacts with the blockchain is itself part of the
ﬁrmware, and therefore outside the TCB. Furthermore, it does
not consider data integrity beyond the ﬁrmware, and does not
present an implementation or experiments. Yohan and Lo [15]
present a similar approach that shares the same limitations.
Hu et al. [39] propose several optimizations compared to Lee
and Lee [14] and present an evaluation of a private Ethereum
chain run on an emulated Raspberry Pi (through Qemu-Pi).
However, they also do not consider recoverability or attacks
against data integrity beyond the device layer.

Two-Layer Blockchains.

In Section VI, we present a
blockchain framework that uses a two-layer protocol to achieve
scalability. The challenge of speeding up blockchains through
multi-layer protocols is an active research area. Proposals

10

generally fall into either of two categories: layer-two mecha-
nisms, which rely on a top-layer chain that connects a large
number of largely independent blockchains [12], and sharding
mechanisms, which partition the entire blockchain workload at
the level of the consensus protocol [42], [56]. As the bottom-
layer blockchains in our framework do not communicate, our
approach is part of the former category. Since there are, to
the best of knowledge, no off-the-shelf layer-two protocols
available that are suitable for large-scale data logging on the
bottom layers, we have implemented and tested our framework
in Hyperledger Fabric and private Ethereum.

IX. CONCLUSIONS & DISCUSSION

In this paper, we have presented a lightweight blockchain
framework for securing the integrity of data and device
ﬁrmware in IoT sensor networks. We have presented a com-
prehensive threat model that includes the interaction between
attacks on the network’s different entities. Our threat model
allows us to identify which defense mechanisms satisfy the
security goals of measurement data integrity and ﬁrmware
integrity while maintaining real-world scalability and deploy-
ability. We have identiﬁed three main limitations of existing
designs and addressed these through 1) a two-layer blockchain
design, 2) analysis of blockchain-speciﬁc attacks, and 3) a
novel application of threshold signatures that are veriﬁed in
the TCB of the meters. We have implemented our solution
using smart contracts in Ethereum and Hyperledger Fabric,
and have performed stress tests that show its applicability in
practice. We have made the code of the experiments publicly
available. In contrast to ﬁrmware code, the public availability
of the smart contract code implies that it can be audited –
therefore, it is less likely to contain zero-day vulnerabilities.
The FLBI framework is applicable in a broad range of
IoT settings – the main requirements are that 1) each device
collects data independently from other devices, 2) the devices
have TPM support, and 3) a consortium of interested parties
can be found to maintain a healthy balance of participants
in each bottom-layer blockchain (i.e., no entity controls more
than f out of 3f + 1 nodes). Regarding the latter require-
ment, we note that a blockchain solution in which a single
entity controls all the peers offers no security beyond that
of a centralized infrastructure. However, even in applications
in which the measurements collected by different operators
(e.g., healthcare providers) are fully independent, security can
be enhanced if they use bottom-layer blockchains to share
encrypted data.

With a throughput of 60-200 transactions per second and
32 bytes of meaningful payload (the hash) per transaction,
each bottom-layer blockchain has an estimated throughput of
approximately 2-6 kB/s. This may be sufﬁcient for (encrypted)
AMI or patient monitoring data, but less so for raw security
camera footage. However, in the latter case, it may be sufﬁcient
to store the output of a machine learning algorithm applied to
the raw video footage on the bottom-layer blockchains. This
requires that the bottom-layer devices have the capacity to
compute such output, but this is unlikely to be more compu-
tationally expensive than maintaining a blockchain node.

ACKNOWLEDGMENTS
This research / project is supported by the National Re-
search Foundation, Singapore, under its National Satellite of
Excellence Programme “Design Science and Technology for
Secure Critical Infrastructure” (Award Number: NSoE DeST-
SCI2019-0009). Any opinions, ﬁndings and conclusions or
recommendations expressed in this material are those of the
author(s) and do not reﬂect the views of National Research
Foundation, Singapore.

REFERENCES

[1] A. Al-Fuqaha, M. Guizani, M. Mohammadi, M. Aledhari, and
M. Ayyash, “Internet of things: A survey on enabling technologies,
protocols, and applications,” IEEE Communications Surveys & Tutorials,
vol. 17, no. 4, pp. 2347–2376, 2015.

[2] F. Skopik and P. Smith (Eds.), Smart grid security: Innovative solutions

for a modernized grid. Syngress, 2015.

[3] A. Aravindan, “Singapore to double police cameras to more than

200,000 over next decade,” Reuters, 2021.

[4] S. R. Islam, D. Kwak, M. H. Kabir, M. Hossain, and K.-S. Kwak,
“The Internet of Things for health care: a comprehensive survey,” IEEE
access, vol. 3, pp. 678–708, 2015.

[5] J. Liu, Y. Xiao, S. Li, W. Liang, and C. P. Chen, “Cyber security
and privacy issues in smart grids,” IEEE Communications Surveys &
Tutorials, vol. 14, no. 4, pp. 981–997, 2012.

[6] R. M. Lee, M. J. Assante, and T. Conway, “Analysis of the cyber
attack on the Ukrainian power grid,” Electricity Information Sharing
and Analysis Center (E-ISAC), 2016.

[7] S. Soltan, P. Mittal, and H. V. Poor, “BlackIoT: IoT botnet of high
wattage devices can disrupt the power grid,” in USENIX Security, 2018,
pp. 15–32.

[8] T. Shekari, C. Irvene, A. A. Cardenas, and R. Beyah, “MaMIoT:
Manipulation of energy market leveraging high wattage iot botnets,”
in ACM CCS, 2021, pp. 1338–1356.

[9] Y. Zheng, A. Davanian, H. Yin, C. Song, H. Zhu, and L. Sun, “FIRM-
AFL: high-throughput greybox fuzzing of iot ﬁrmware via augmented
process emulation,” in USENIX Security, 2019, pp. 1099–1114.
[10] I. Stellios, P. Kotzanikolaou, M. Psarakis, C. Alcaraz, and J. Lopez, “A
survey of IoT-enabled cyberattacks: Assessing attack paths to critical in-
frastructures and services,” IEEE Communications Surveys & Tutorials,
vol. 20, no. 4, pp. 3453–3495, 2018.

[11] R. Gennaro and S. Goldfeder, “Fast multiparty threshold ECDSA with

fast trustless setup,” in ACM CCS, 2018, p. 1179–1194.

[12] L. Gudgeon, P. Moreno-Sanchez, S. Roos, P. McCorry, and A. Gervais,
“SoK: Layer-two blockchain protocols,” in Financial Crypto. Springer,
2020, pp. 201–226.

[13] G. Liang, S. R. Weller, F. Luo, J. Zhao, and Z. Y. Dong, “Distributed
blockchain-based data protection framework for modern power systems
against cyber attacks,” IEEE Trans. Smart Grid, vol. 10, no. 3, pp. 3162–
3173, 2019.

[14] B. Lee and J.-H. Lee, “Blockchain-based secure ﬁrmware update for
embedded devices in an internet of things environment,” The Journal of
Supercomputing, vol. 73, no. 3, pp. 1152–1167, 2017.

[15] A. Yohan and N. Lo, “An over-the-blockchain ﬁrmware update frame-
work for IoT devices,” in IEEE Conference on Dependable and Secure
Computing, DSC 2018, Kaohsiung, Taiwan, December 10-13, 2018,
2018, pp. 1–8.

[16] P. Kumar, Y. Lin, G. Bai, A. Paverd, J. S. Dong, and A. P. Martin,
“Smart grid metering networks: A survey on security, privacy and open
research issues,” IEEE Communications Surveys and Tutorials, vol. 21,
no. 3, pp. 2886–2927, 2019.

[17] K. Sharma and L. M. Saini, “Performance analysis of smart metering for
smart grid: An overview,” Renewable and Sustainable Energy Reviews,
vol. 49, pp. 720–735, 2015.

[18] R. Sailer, X. Zhang, T. Jaeger, and L. Van Doorn, “Design and
implementation of a TCG-based integrity measurement architecture.” in
USENIX Security, 2004, pp. 223–238.

[19] C. Kil, E. C. Sezer, A. M. Azab, P. Ning, and X. Zhang, “Remote
attestation to dynamic system properties: Towards providing complete
system integrity evidence,” in IEEE/IFIP DSN, 2009, pp. 115–124.
[20] M. LeMay and C. A. Gunter, “Cumulative attestation kernels for
embedded systems,” IEEE Transactions on Smart Grid, vol. 3, no. 2,
pp. 744–760, 2012.

11

[21] T. T. A. Dinh, J. Wang, G. Chen, R. Liu, B. C. Ooi, and K.-L. Tan,
“BLOCKBENCH: A framework for analyzing private blockchains,” in
2017 ACM International Conference on Management of Data. ACM,
2017, pp. 1085–1100.

[22] S. Goldwasser, S. Micali, and R. L. Rivest, “A digital signature scheme
secure against adaptive chosen-message attacks,” SIAM Journal on
Computing, vol. 17, no. 2, pp. 281–308, 1988.

[23] D. Johnson, A. Menezes, and S. Vanstone, “The elliptic curve digital
information

signature algorithm (ECDSA),” International
security, vol. 1, no. 1, pp. 36–63, 2001.

journal of

[24] S. Sridhar, A. Hahn, and M. Govindarasu, “Cyber–physical system
security for the electric power grid,” Proceedings of the IEEE, vol. 100,
no. 1, pp. 210–224, 2011.

[25] F. Toledo, Smart metering handbook. PennWell Books, 2013.
[26] S. McLaughlin, B. Holbert, A. Fawaz, R. Berthier, and S. Zonouz, “A
multi-sensor energy theft detection framework for Advanced Metering
Infrastructures,” IEEE Journal on Selected Areas in Communications,
vol. 31, no. 7, pp. 1319–1330, 2013.

[27] I. Homoliak, F. Toffalini, J. Guarnizo, Y. Elovici, and M. Ochoa, “Insight
into insiders and IT: A survey of insider threat taxonomies, analysis,
modeling, and countermeasures,” ACM Computing Surveys (CSUR),
vol. 52, no. 2, pp. 1–40, 2019.

[28] Certicom, “Critical infrastructure protection for AMI using a compre-

hensive security platform.” 2018.

[29] M. Kedia, “Enhancing privacy and security in the smart-meter life cycle,”

2019.

[30] A. Schaller, T. Arul, V. van der Leest, and S. Katzenbeisser,
“Lightweight anti-counterfeiting solution for low-end commodity hard-
ware using inherent PUFs,” in International Conference on Trust and
Trustworthy Computing. Springer, 2014, pp. 83–100.

[31] R. Berthier and W. H. Sanders, “Speciﬁcation-based intrusion detection
for advanced metering infrastructures,” in IEEE PRDC, 2011, pp. 184–
193.

[32] P. Jokar, H. Nicanfar, and V. C. Leung, “Speciﬁcation-based intrusion
detection for home area networks in smart grids,” in 2011 IEEE Interna-
tional Conference on Smart Grid Communications (SmartGridComm).
IEEE, 2011, pp. 208–213.

[33] T. Golomb, Y. Mirsky, and Y. Elovici, “CIoTA: Collaborative IoT
anomaly detection via blockchain,” arXiv preprint arXiv:1803.03807,
2018.

[34] N. Laptev, S. Amizadeh, and I. Flint, “Generic and scalable framework
for automated time-series anomaly detection,” in ACM KDD, 2015, pp.
1939–1947.

[35] C. Feng, V. R. Palleti, A. Mathur, and D. Chana, “A systematic
framework to generate invariants for anomaly detection in industrial
control systems.” in NDSS, 2019.

[36] P. Jokar, N. Arianpoo, and V. C. Leung, “Electricity theft detection in
AMI using customers’ consumption patterns,” IEEE Transactions on
Smart Grid, vol. 7, no. 1, pp. 216–226, 2015.

[37] S. Hangal and M. S. Lam, “Tracking down software bugs using
automatic anomaly detection,” in Proceedings of the 24th International
Conference on Software Engineering. ICSE 2002, 2002, pp. 291–301.

[38] A. Maw, S. Adepu, and A. Mathur, “ICS-BlockOpS: Blockchain for
operational data security in industrial control system,” Pervasive and
Mobile Computing, vol. 59, p. 101048, 2019.

[39] J. Hu, L. Yeh, S. Liao, and C. Yang, “Autonomous and malware-
proof blockchain-based ﬁrmware update platform with efﬁcient batch
veriﬁcation for internet of things devices,” Computers & Security,
vol. 86, pp. 238–252, 2019.

[40] M. Castro and B. Liskov, “Practical Byzantine fault tolerance,” in OSDI,

vol. 99, 1999, pp. 173–186.

[41] H. Dang, T. T. A. Dinh, D. Loghin, E.-C. Chang, Q. Lin, and B. C. Ooi,
“Towards scaling blockchain systems via sharding,” in ACM SIGMOD,
2019, pp. 123–140.

[42] E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly, E. Syta, and
B. Ford, “Omniledger: A secure, scale-out, decentralized ledger via
sharding,” in IEEE S&P, 2018, pp. 583–598.

[43] U-Boot, https://github.com/u-boot/u-boot.
[44] A. Tan, “Smart meters to help more homes go green,” 2019.
[45] D. Kim, B. J. Kwon, K. Koz´ak, C. Gates, and T. Dumitras, “The broken
shield: Measuring revocation effectiveness in the Windows code-signing
PKI,” in USENIX Security, 2018, pp. 851–868.

[46] X. de Carn´e de Carnavalet and M. Mannan, “Challenges and impli-
cations of veriﬁable builds for security-critical open-source software,”
the 30th Annual Computer Security Applications
in Proceedings of
Conference, 2014, pp. 16–25.

12

[47] K. Nikitin, E. Kokoris-Kogias, P. Jovanovic, N. Gailly, L. Gasser,
I. Khofﬁ, J. Cappos, and B. Ford, “CHAINIAC: Proactive software-
update transparency via collectively signed skipchains and veriﬁed
builds,” in USENIX Security, 2017, pp. 1271–1287.

[48] B. Laurie, “Certiﬁcate transparency,” Commun. ACM, vol. 57, no. 10,

pp. 40–46, 2014.

[49] E. Syta, I. Tamas, D. Visher, D. I. Wolinsky, P. Jovanovic, L. Gasser,
N. Gailly, I. Khofﬁ, and B. Ford, “Keeping authorities “honest or bust”
with decentralized witness cosigning,” in IEEE S&P, 2016, pp. 526–545.
[50] M. Al-Bassam and S. Meiklejohn, “Contour: A practical system for
binary transparency,” in Workshop on Cryptocurrencies and Blockchain
Technology (CBT), 2018.

[51] A. Dorri, S. S. Kanhere, R. Jurdak, and P. Gauravaram, “LSB: A
lightweight scalable blockchain for IoT security and anonymity,” J.
Parallel Distrib. Comput., vol. 134, pp. 180–197, 2019.

[52] A. Dorri, S. S. Kanhere, and R. Jurdak, “Towards an optimized
blockchain for IoT,” in Second International Conference on Internet-
of-Things Design and Implementation. ACM, 2017, pp. 173–178.
[53] A. Dorri, S. S. Kanhere, R. Jurdak, and P. Gauravaram, “Blockchain for
iot security and privacy: The case study of a smart home,” in 2017 IEEE
international conference on pervasive computing and communications
workshops (PerCom workshops).

IEEE, 2017, pp. 618–623.

[54] A. Wang, A. Mohaisen, and S. Chen, “XLF: A cross-layer framework
to secure the internet of things (IoT),” in ICDCS, 2019, pp. 1830–1839.
[55] I. Homoliak, S. Venugopalan, D. Reijsbergen, Q. Hum, R. Schumi, and
P. Szalachowski, “The security reference architecture for blockchains:
Toward a standardized model for studying vulnerabilities, threats, and
defenses,” IEEE Communications Surveys & Tutorials, vol. 23, no. 1,
pp. 341–390, 2020.

[56] M. El-Hindi, C. Binnig, A. Arasu, D. Kossmann, and R. Ramamurthy,
“BlockchainDB: a shared database on blockchains,” Proceedings of the
VLDB Endowment, vol. 12, no. 11, pp. 1597–1609, 2019.

