2
2
0
2

b
e
F
1
2

]

R
C
.
s
c
[

3
v
6
2
9
3
1
.
6
0
1
2
:
v
i
X
r
a

CLOAK: Enabling Conﬁdential Smart Contract with Multi-party Transactions

Qian Ren§∗

Han Liu∗

Yue Li∗

Anne Victor∗

Hong Lei†∗

Lei Wang‡

Bangdao Chen§∗

§SSC Holding Company Ltd.
∗Oxford-Hainan Blockchain Research Institute
†School of Computer Science and Cyberspace Security, Hainan University
‡Department of Computer Science and Engineering, Shanghai Jiao Tong University

Abstract
In recent years, as blockchain adoption has been expanding
across a wide range of domains, e.g., supply chain and digital
asset, smart contracts’ conﬁdentiality has now become a fun-
damental demand for practical applications. However, while
new privacy protection techniques are emerging, how existing
ones can best ﬁt development settings is understudied. State-
of-art solutions lack architectural support of programming
interfaces thus can hardly reach general developers.

This paper proposes CLOAK, a pluggable and conﬁgurable
framework for developing and deploying conﬁdential smart
contracts. The key capability of CLOAK is to allow develop-
ers to develop and deploy practical solutions to Multi-party
Transaction (MPT) problems, i.e., to veriﬁably transact with
secret parameters and states owned by different parties by sim-
ply specifying it. To this end, CLOAK allows users to specify
privacy invariants in a declarative way, automatically gener-
ate runtime with enforced privacy, and deploy it to enable
the MPT on existing platforms. Additionally, we identify the
pitfalls and treats for achieving MPT, e.g., achieving public
veriﬁability and resisting byzantine adversaries with minimal
blockchain interaction. In our evaluation of both examples
and real-world applications, developers manage to deploy
business services on blockchain concisely by only developing
CLOAK smart contracts, whose size is less than 13.5% of the
deployed ones. Moreover, while previous works require at
least O(n) transactions to secure an MPT, CLOAK requires
only 2 transactions and reduces gas cost by 29% on average.
We believe that the insights learned from CLOAK pave
the way for public veriﬁable thus reusable general-purpose
multi-party computation achieved by harmonizing TEE and
blockchain.

1 Introduction

With the rapid development of both permissionless and per-
missioned blockchains, privacy issues have now become one
of the top concerns for smart contracts, i.e., keeping trans-
action inputs and contract states as secrets to non-relevant

participants. In many of the practical applications, privacy is
an essential property to achieve, e.g., avoiding malicious arbi-
trage on cryptocurrency, protecting sensitive information in a
cooperative business. Unfortunately, despite the importance
of smart contract privacy, most of the existing blockchains are
designed without privacy by nature [29,44]. For example, min-
ers of Ethereum verify transactions in a block by re-executing
them with the exact input and states. Consequently, private
data is shared within the entire network.

Figure 1: A simpliﬁed multi-party scenario

Conﬁdential smart contract. To address the aforementioned
problem, researchers have proposed various conﬁdential
smart contract solutions. In general, these approaches fall
into two categories that based on cryptography techniques
and trusted hardware respectively. For the former class of ap-
proaches, techniques including ring signature, homomorphic
encryption, and zero-knowledge proof (ZKP) are adopted to
achieve anonymity and privacy [5, 8, 11, 25]. For the latter,
Trusted Execution Environment (TEE), e.g., Intel SGX, is
used to provide conﬁdentiality and trustworthiness [12, 27].
More speciﬁcally, TEE is able to reveal sealed transactions
and execute them in enclaves, hiding input and contract states
with a veriﬁable endorsement from the hardware manufacture.
Limitations. However, while both classes of solutions pro-
vide architectural capabilities to enforce conﬁdential life-

1

MotivatingExamplesEn.1En.2En.3Enc(bid1)Enc(bid2)Enc(bid3)123CoreEnterprisebiddingProcure(uintbid1,uintbid2,uintbid3)The company with the lowest bid winsPays the winner with the second lowest bidPublish the lowest bid, hide other bids 
 
 
 
 
 
cycles of transactions, they are insufﬁcient for the develop-
ment of practical applications. Fig. 1 describes a scenario
of procurement bidding among multiple enterprises in sup-
ply chain applications. Speciﬁcally, each participant submits
its secret bid. The core enterprise selects a winner with the
lowest bid and pays the second-lowest bid by updating the
winner’s balance. Cryptography-based solutions suffer from
low performance and error-prone implementation since that
developers are required to implement a set of off-chain multi-
party computation (MPC) programs [21] and on-chain ver-
iﬁcation smart contracts [11, 25]. Most of TEE-based solu-
tions [12, 27, 35] support general conﬁdential smart contracts
with secrets owned by only one side in a single transaction.
These solutions process one source of conﬁdential bid input
at a time, cache intermediate bids, and generate ﬁnal states
when the bidding is completed thus lead to non-intuitively
program model. Although recent works [14,25] aim to enable
secure off-chain MPC programs, they suffer on low scalabil-
ity by requiring O(n) blockchain interactions. In summary,
literature solutions of conﬁdential smart contracts can hardly
ﬁt in the practical multi-party transactions, i.e., transactions
with secret inputs and states owned by different parties.
Challenges. Handling multi-party transactions on blockchain
faces the following challenges:

C1: Development cost for conﬁdentiality. Developing a
conﬁdential smart contract is time-consuming and error-prone
due to the lack of programming support. Given a privacy
speciﬁcation, the development commonly requires embed-
ding low-level controls into implementations for business
logic. Consequently, it becomes less ﬂexible for developers
to understand, develop and maintain such contracts and more.
C2: Interoperability with existing blockchains. Evaluat-
ing multi-party transactions involves reading and writing both
off-chain and on-chain data, e.g., off-chain parameters and
on-chain states. However, existing solutions are primarily for
off-chain one-time MPC programs, i.e., receive inputs and
deliver outputs off-chain, thus can hardly ﬁt into general ap-
plication domains, e.g. have combined off-chain and on-chain
inputs/outputs.

C3: Security design of multi-party transaction. Secur-
ing multi-party transactions requires efﬁciently resisting
byzantine adversaries, i.e., not only to resist adversaries to
abort protocols, peek at secrets, cheat on results etc., but also
guarantee the security with minimal blockchain interaction.
Contributions. In this paper, we formalize the Multi-party
Transaction (MPT) problem on blockchain for the ﬁrst time
and harmonize TEE and blockchain to build a general-purpose
MPT-enabled conﬁdential smart contract framework, CLOAK.
CLOAK allows developers to annotate MPT privacy invariants
in contract source code, then do the rest to enable MPT on
existing blockchains. Our main contributions are as follows:
• We ﬁrst identify and formalize the multi-party transaction
problem that transacts with secret parameters and states
owned by different parties in a public veriﬁable manner.

• We highlight a domain-speciﬁc language (against C1),
which allows developers to efﬁciently annotate MPT pri-
vacy invariants directly in developing smart contracts and
generate deployable code compliant to the speciﬁed privacy
invariants.

• We propose a novel MPT-enabled conﬁdential smart
contract framework;
It is interoperable with existing
blockchains (against C2), and achieves conﬁdentiality, pub-
lic veriﬁability, and ﬁnancial fairness under byzantine ad-
versaries in the cost of 2 transactions (against C3).

• We have applied CLOAK in several industrial applications,
including supply chain, e-governance, and more. CLOAK
has managed to greatly simplify the implementation of a
conﬁdential smart contract and reduce the gas cost of MPT.
Organization. This paper is organized as follows. Section 2
formally deﬁnes the multi-party transaction problem. Sec-
tion 3 illustrates advances of CLOAK to related works. Sec-
tion 4 shows the key design and overview of CLOAK. Section
5 answers how CLOAK helps developers specify MPT in an
intuitive manner (against C1) and enable MPT on existing
blockchains (against C2). Section 6 shows how our protocol
proceeds and resists byzantine adversaries (against C3). Fi-
nally, we claim system security in Section 7, evaluate CLOAK
in Section 8 and conclude in section 9.

2 Multi-party Transaction

In this section, we ﬁrst illustrate the public veriﬁability re-
quired by both public transactions (e.g., normal transactions
of Ethereum) and private transactions of conﬁdential smart
contracts [12, 27], then identify a new privacy problem called
Multi-party Transaction and elaborate its novelty and impact.
Currently, prominent blockchains (e.g., Ethereum [44]) are
typically modeled as State Machines. In these blockchains,
every single step of state transition is supposed to be veriﬁed
by all nodes. Thus, we say the state transition is publicly
veriﬁable and the transaction causing the transition has public
veriﬁability. Let’s go deep into public veriﬁability in Figure 2.

Public veriﬁability of public transactions. When a normal
transaction is packaged in a block, its transaction parameters,
old states, function logic, return values, and new states are all
public, therefore we call it PUT (public transaction). We say
a PUT has public veriﬁability since all nodes can re-execute
it to verify the state transition. Formally, in Figure 2, f refers
to the function logic of a transaction, e.g., a transaction for
rather transferring ETH or calling a function of a contract on
Ethereum; x refers to transaction parameters; r refers to return
values, s, s(cid:48) refers to old state and new state separately. We
formalize a PUT as the following formula. The proo f there
is for proving that a f taking parameters x, transfers the old
state s to s(cid:48) and gets return values r. Obviously, the proo f of
PUT can be the set of published x, s, f , s(cid:48), r and everyone can

2

relation means that anchored by public Cxi,Csi,C f ,Cs(cid:48)
,Cri, a
MPT conﬁdentially executes f (x1, . . . , xn, s1, . . . , si) and out-
puts private ri, s(cid:48)
i to their corresponding Pi. The privacy policy
of an MPT means that secrets are exactly fed by and delivered
to different parties Pi and their conﬁdentiality is kept in the
whole process.

i

MPT :

Cs1, . . . ,Csn
Cs(cid:48)
1

, . . . ,Cs(cid:48)

C f , Cx1 ,...,Cxn
=⇒
n,Cr1, . . . ,Crn, proo f
f (x1,...,xn)

=⇒ s(cid:48)

1, . . . , s(cid:48)

| s1, . . . , sn

n, r1, . . . , rn

Figure 2: Public veriﬁable state transition. PUT refers to a
public transaction. PRT refers to a private transaction that takes se-
crets from a single party. MPT refers to a multi-party transaction that
takes secrets from multiple parties. Dashed thick line arrows refer
to reading blockchain while solid thick line arrows refer to writing
blockchain. σ refers to the world state. C∗ refers to a commitment to
a secret ∗.

verify the PUT by re-executing it thus also trusting the state
transition caused by a sequence of PUT.

PUT :

f (x)
=⇒ s(cid:48), r, proo f

s

Public veriﬁability of private transactions. Similarly, as
for a private transaction (PRT) of conﬁdential smart contract
that takes secrets from a single party, although its x, s, s(cid:48), r and
even f can be private, it is also required to prove the validity
of it caused state transition from old state commitment to new
state commitment, i.e., a PRT also requires public veriﬁability.
As is shown in Figure 2, Let C∗ refer to a cryptographic com-
mitment of ∗, e.g. the hash or ciphertext of ∗. A PRT executes
f (x, s) off-chain, gets private return values r and new states
s(cid:48) and generates a proo f . The proo f proves that there are
indeed private f , x, s, s(cid:48), r matching their public commitments
C f ,Cx,Cs,Cs(cid:48),Cr ﬁts this relation: executing f (x, s) gets re-
turn value r and causes the state transition from s to s(cid:48). PRT
has been researched for several years and there are both ZKP-
based [11, 19, 25] and TEE-based [12, 35] solutions. However,
these solutions hardly consider or practically achieve a PRT
taking secrets from different parties.

PRT : Cs

C f , Cx
=⇒ Cs(cid:48),Cr, proo f | s

f (x)
=⇒ s(cid:48), r

Multi-party transaction. In this paper, we expand the public
veriﬁability of PRT to multi-party scenarios and call it Multi-
party Transaction (MPT). We model the MPT as the formula
below. The proo f achieves an MPT’s public veriﬁability by
proving both variables’ relation and privacy policy. Variables’

3

MPC with strong adversary model vs. MPT. MPC refers to
Multi-Party Computation. Typically, MPC constructs crypto-
graphic protocols to allow different parties to jointly compute
a target function without revealing their input secrets to each
other [45]. An MPC protocol can be formalized as following
formula, where f refers to the target function, xi, yi refer to
private input and output of a party Pi.

f (x1, x2, ..., xn) ⇒ y1, y2, ..., yn

MPC protocols under the strong adversary model, marked as
MMPC, consider malicious parties who can arbitrarily abort
or misbehave during the protocols. MMPC requires parties to
mutually prove their honest behavior in each protocol step so
that honest parties can identify misbehaviors in time and even
punish misbehaved parties. However, while both MPT and
MMPC solutions pursue keeping the conﬁdentiality of parties’
secrets and identifying misbehaviors, MPT distinguished from
MMPC in public veriﬁability and blockchain nativeness.

In terms of public veriﬁability, while MMPC focuses on
building the mutual trust of honest behavior among involved
parties, MPT focuses on making the public trust both multi-
party process and results. In fact, there are indeed many prac-
tical scenarios where a non-involved party of MPC needs
to verify both MPC process and results without trusting any
party, e.g., a regulation authority veriﬁes business compliance
without trusting any involved ﬁrms, or a miner veriﬁes the
state transition caused by an MPC process without trusting
any involved parties.

In terms of blockchain nativeness, while MMPC [14, 40]
just distinguishes a party’s inputs and outputs from others,
MPT furthermore distinguishes transaction parameters and
return values from states. As a result, while parties involved
in an MMPC feed their private inputs to the protocol without
any restriction, parties of an MPT can also feed transaction pa-
rameters without restriction but must feed old states matching
the states’ commitments on-chain. Moreover, current solu-
tions [14, 38] committing a part of MMPC inputs or outputs
on blockchain never consider sharing their committed data
with PRT [14, 25, 40]. Conversely, MPT is not considered as
a standalone transaction type of conﬁdential smart contract

DesignIdeaandWorkflow-,/0%,0&,0'1,/′3-,s1,/′"#$%#&"#$%#&Off-chainOn-chain0%',…,0%(,0&',…,0&(,0'-(,/(6(-),/)6)…6(6)…1(,/(*1),/)*…71883,0&*',…,0&*(,0+',…,0+(σσ%33PRTPUTMPT71883,0&*,0+Table 1: Comparison of CLOAK with related works. The (cid:108), (cid:119), (cid:109), (cid:53) refers to full, partial, not match and not-related respectively.
"Chain Agnostic" means the approach is integrated into the consensus of a speciﬁc chain. "Privacy Speciﬁcation" means the approach
proposes a method to specify privacy needs. "Negotiation" means the approach starts with apriori-unknown parties. "min(#TX)" means
how many transactions are required by the approach in absence of an adversary.

Approach

min(#TX) Conﬁdentiality

Adversary Model

Public Veriﬁability

#Parties #TEE Executors

x

s

f

r

s(cid:48) Policy

Chain
Agnostic

Privacy
Speciﬁcation

Negotiation

Financial
Fairness

Ethereum [44]
Ekiden [12]
Conﬁde [27]
Hawk [25]
Fastkitten [14]
LucidiTEE [38]
CLOAK

O(1)
O(1)
O(1)
O(n)
O(n)
O(n)
O(1)

(cid:53)
(cid:108)
(cid:108)
(cid:119)4
(cid:108)
(cid:108)
(cid:108)

1∗
1∗
1∗
n
n
n
n

(cid:53)
m − 11
(cid:98)m/3(cid:99)3
(cid:53)
1∗
m − 1
1∗

(cid:108) (cid:108) (cid:108) (cid:108) (cid:108) (cid:108)
(cid:109)2 (cid:108) (cid:108) (cid:109)2 (cid:108) (cid:108)
(cid:108) (cid:108) (cid:108) (cid:108) (cid:108) (cid:108)
(cid:108) (cid:109) (cid:108) (cid:108) (cid:109) (cid:109)
(cid:109) (cid:109)5 (cid:109) (cid:108) (cid:109)5 (cid:109)
(cid:108) (cid:109) (cid:108) (cid:108) (cid:119)6
(cid:119)6
(cid:108) (cid:108) (cid:108) (cid:108) (cid:108) (cid:108)

(cid:53)
(cid:108)
(cid:109)
(cid:108)
(cid:108)
(cid:108)
(cid:108)

(cid:53)
(cid:109)
(cid:108)
(cid:108)
(cid:109)
(cid:109)
(cid:108)

(cid:53)
(cid:53)
(cid:53)
(cid:109)
(cid:109)
(cid:108)
(cid:108)

(cid:53)
(cid:53)
(cid:53)
(cid:108)
(cid:108)
(cid:53)
(cid:108)

1 The tolerated number of corrupted compute nodes. 2 Transaction parameters x (resp. return values r) are received (resp. delivered) off-chain while not
committed on-chain. 3 We assume the Conﬁde’s undeclared consensus is BFT. 4 The manager is expected not to leak parties’ private data. 5 Fastkitten
does not commit the states of MPC programs. 6 LucidiTEE does not consider states owned by different parties.

but coexists with PRT and PUB in contracts. In our work,
the data structure of secrets’ commitments is well-designed
so that can be operated by an MPT as well as a PRT1. Most
importantly, while some solutions partially commit MMPC
only for recording the evaluation, all elements of MPT that
uniquely identify the evaluation are forced to be committed
on-chain. Because our commitment strategy make it trustwor-
thy to publicly verify the state transition, construct transaction
chain to reuse the MPT outputs, and re-executing the MPT
for an after-event audit, we believe our work paves the way
for public veriﬁable and reusable multi-party computation.

3 Related Work

Since our contributions involve a new language for specifying
multi-party privacy and a novel framework harmonizing TEE
and blockchain to enforce MPT, in this section, we elaborate
how CLOAK distinguishes from current privacy speciﬁcation
languages against smart contracts and conﬁdential smart con-
tract solutions utilizing MPC or TEE.
Privacy policy languages. In terms of expressive ability, we
ﬁrst consider privacy policy languages designed for contracts.
CCLe [27] and SecondState [39] only distinguishes values
between public and private. Zkay [11] allows annotating own-
ers of private data in simpliﬁed Solidity. However, Zkay is
designed for NIZK-based solutions and does not consider
multi-party scenarios. Then, we consider languages that sup-
port multi-party computation. Hawk [25] only support hard-
coded parties’ addresses and is designed for NIZK-based
payment system. MPCL [30], Wysteria [33], SecreC [3] and
ObliVM [26] also only distinguish values between public
and private. Differently, CLOAK allows developers to ﬁne-
grained annotate private values available to speciﬁc addresses
ignoring how many parties are involved and leave CLOAK
to recognize the transaction types, i.e., PUT, PRT, or MPT.
While Fairplay [28], SecreC, and ObliVM do not support

1The deﬁnition of PUT indicates its impossibility in involving secrets

general loops with private conditions due to the limitation of
ﬁx-round cryptographic algorithms, CLOAK runs the transac-
tion logic with plaintext secrets inside enclaves thus is free of
this limitation.
TEE-enforced conﬁdential smart contract. As is shown in
Table 2, Ekiden [12, 39] reveals and executes private transac-
tions in TEE to conﬁde transactions’ parameters and return
values, and contracts’ states. CCF [35] supports users to run
any typescript or C++-based application in a TEE-based per-
missioned blockchain. CONFIDE [27] designs a key protocol
to synchronize and hold a common public key between all
SGX. It also holds EVM and WASM in SGX to support kinds
of contracts. Because all above three solutions serve to handle
a private transaction from its single sender, they inherently
indicate PRT policy. However, Ekiden receives inputs and
delivers outputs off-chain without committing them on-chain
thus does not uniquely bind the PRT, therefore, losing its pub-
lic veriﬁability. While both CCF and CONFIDE integrate
TEE into the pipeline of their consensus thus being speciﬁc
to their blockchains, CLOAK is chain-agnostic and can enable
conﬁdential smart contracts on existing blockchain.
Transactions based on multi-party computation. Transac-
tions based on multi-party computation mean several parties
jointly execute a target function and commit part of the in-
formation on blockchain without revealing their secrets to
each other in the process. As is shown in Table 2, in terms
of conﬁdentiality, Hawk [25] requires an credible manager
to be tight-lipped thus just achieving partial conﬁdentiality.
In terms of public variability, the manager of Hawk updating
contract state with ZKP proof makes the multi-party policy
transparent to public veriﬁers, e.g., miners. FastKitten [14]
just records m-round MPC’ output on blockchain though addi-
tionally achieves the ﬁnancial fairness when malicious parties
or the unique operator misbehave. To the best of our knowl-
edge, CLOAK is the ﬁrst scheme that achieves public veriﬁa-
bility of MPT-caused state transitions by committing all inputs
(i.e., transaction parameters and old state), code, outputs (i.e.,
return values and new state), and multi-party privacy policy

4

on-chain. LucidiTEE does not distinguish parties identities in
committed states and policy. In terms of security, while Lucidi-
TEE [38] lacks a collateral system to punish malicious parties,
both Hawk and FastKitten [14] adopts challenge-response
protocols to punish malicious parties and the single operator/-
manager thus achieves ﬁnancial fairness. CLOAK furthermore
improves the challenge-response protocol of FastKitten [14]
thus also achieve ﬁnancial fairness. Moreover, in terms of scal-
ability, MPC-based works [34, 42, 43] allows m-round MPC
with penalties over Bitcoin, but relies on the claim-or-refund
functionality which requires complex and expensive transac-
tions and collateral thus making these solutions impractical.
Schemes adopting TEE to enhance MPC also requires high
money-cost [42, 43] and time-consume transactions [14] for
collateral, thus suffers on high-cost. In contrast, CLOAK re-
quires only a constant number of collateral transactions for
defending adversaries.

To the best of our knowledge, CLOAK is the ﬁrst to al-
low developers to specify PUT, PRT, and MPT in a single
contract simultaneously. It is also the ﬁrst to achieve public
veriﬁable state transition caused by MPT and resist byzantine
adversaries with normally only 2 transactions.

4 CLOAK Design

This section presents the overview of CLOAK, a novel MPT-
enabled conﬁdential smart contract framework. We ﬁrst model
the architecture of CLOAK, then introduce the workﬂow of
CLOAK, which helps users develop, deploy and send MPT.

4.1 Design challenges of CLOAK

Leveraging TEE and blockchain to build a general-purpose
MPT-enabled conﬁdential smart contract framework faces the
following challenges.

4.1.1 Support intuitive MPT speciﬁcation

Expressing multi-party privacy needs is not enough intuitive
now. The programming model of TEE requires developers
to carefully split normal application code into trusted part
and untrusted part, of which the trusted part should be exe-
cuted in trusted enclaves and the untrusted part be executed
in an untrusted environment. There is no intuitive connection
between TEEs’ programming model and MPT requirements.
Moreover, while ZKP-solution-oriented languages [11] do not
support multi-party scenarios. Current programming frame-
works considering multi-party privacy mainly focus on the
off-chain multi-party computation thus less considering the
features of smart contracts, e.g. parties’ identities are rep-
resented by addresses [4, 22] or the inputs of MPT split to
off-chain parameters and on-chain states. Besides, never of
the current languages support PUB, PRT, and MPT in one

contract so developers have to differently specify the privacy
needs of various transaction types by different tools or forms.
All these limitations motivate us to propose CLOAK lan-
guage. The core idea of CLOAK language is allowing de-
velopers to intuitively annotate the ownership (i.e., owners’
addresses) of private data without considering the type of
transactions. Then, CLOAK analyzes how many parties’ se-
crets are involved to infer the type of each transaction.

4.1.2 Achieving public veriﬁability of MPT

The challenge of achieving public veriﬁability of MPT is that
how to construct a well-structured proo f of which the struc-
ture and size are agnostic of x, s, f , r, s(cid:48) and privacy policy.

To design a general structure of proo f , we ﬁrst identify
a general framework for implementing conﬁdential smart
contract based on TEE. The framework marks as a tuple
(F ,P ,E,V ). F refers to the target function f of MPT. P
refers to the privacy policy of MPT. E refers to TEE, which
receives inputs x, s, runs f , delivers outputs r, s(cid:48), generates
proo f , and enforces the P in the whole process. V is a on-
chain veriﬁer that holds contract states and accepts new states
by verifying the state transition proved by proo f . Speciﬁcally,
when E successfully executes an MPT, it sends a signed trans-
action T Xcom. The proo f = (cid:104)HP , HF , ˆHCs, ˆHCx , ˆHCs(cid:48) , ˆHCr(cid:48) (cid:105)2
in T Xcom shows the endorsement of E against state transition
from s to s(cid:48) caused by the MPT. Therefore, if the V veriﬁes
that the HP , HF , ˆHCs in T Xcom match their required values, V
accepts the state transition.

4.1.3 Allowing nondeterministic MPT negotiation

Current works [14, 25, 40] assume that the setting of an MPC,
e.g., involved parities and target functions, has already been
known and ﬁxed, thus all their protocols start from speciﬁed
static settings. However, in a decentralized and open network,
there are deﬁnitely scenarios where a party joins an MPT
without the idea about other parties’ identities, e.g., a public
auction where bidders independently decide to join the auc-
tion. This is what we called nondeterministic participation,
i.e., a party joins an MPT without knowing the identities or
a total number of parties until the MPT proposal is settled.
Although [38] allows parties to autonomously bind data to a
speciﬁc MPC task, it costs O(n) transactions. One may think
we can require all parties to interact with a TEE off-chain
to negotiate with other parties to avoid the interaction with
a blockchain. However, if the negotiation is not settled by
the blockchain, the blockchain will neither knows when the
MPT starts nor be able to deduct the collateral of the TEE
Executor before evaluating the MPT. Consequently, the TEE
Executor colluded with some parties can arbitrarily drop or

2The HP (resp. HF ) refers to hash(P ) (resp. hash(F )). ˆHCs refers to

hash([Csi |1..n]), as well as ˆHCx , ˆHCs(cid:48) , ˆHCr

5

Figure 3: The overall workﬂow of CLOAK framework

delay MPT outputs without being discovered and punished
by the blockchain.

In this paper, we propose an nondeterministic negotiation
protocol to support the mentioned nondeterministic partici-
pation of MPT parties. The basic idea is to let a party send
an MPT proposal to start a negotiation process. Then, parties
agreeing on the MPT proposal can send their acknowledg-
ments and their inputs’ commitments to join the MPT. When
the negotiation is ﬁnished, TEE attaches parties’ identities and
inputs’ commitments in the proposal to get a settled proposal
and publishes the settled MPT proposal on the blockchain. In
this way, both parties and TEE proceed next depending on the
unique MPT proposal conﬁrmed on the blockchain.

4.1.4 Resisting adversary with minimal transactions

A CLOAK Executor running a TEE controls the TEE’s inter-
action with the environment. Thus, a malicious Executor can
abort the execution of the TEE or present Eclipse Attacks [12]
by dropping, delaying, and even mutating input and output
messages of TEE. Besides that, malicious parties can also
abort in any protocol stage to present a DoS attack. Current
works [14, 25, 42] resisting the above attacks require both par-
ties and the Executor to deposit collaterals at the beginning of
the protocol. Even though all parties and the Executor behave
honestly, these works lead to minimal O(n) transactions for
each MPC, which is high-cost and impractical.

In this paper, we design a one-deposit-multiple-transact
mechanism which only requires constantly 2 transactions
when all parties and the Executor behave honestly. Speciﬁ-
cally, the Executor and parties globally deposit coins to an
address controlled by TEE once. When they join an MPT,
the collaterals required for the MPT will be deducted from
their coins before executing MPT and refunded to them after
the MPT successfully completed. In this way, a party can
safely and concurrently join multiple MPT alongside at any
time the sum of deducted collaterals of these MPTs do not
exceed the party’s deposited coins. As for scenarios that ma-
licious Executor or parties present, we adopt an improved
challenge-response mechanism which additionally requires
O(m) transactions, where m is the number of malicious parties.
We stress that the challenge-response mechanism typically

will not be executed often due to the high ﬁnancial cost for
an adversary. Finally, we achieve O(1) transactions per MPT
in normal cases.

4.2 Architecture and workﬂow

The target blockchain architecture interoperable with CLOAK
is modeled as ABC. Here BC is a general-purpose smart con-
tract enabled blockchain on which the data are available to all
C, e.g., Ethereum [44]. C is a user/client sending transactions,
e.g., a digital wallet. There can be multiple C nodes (indicated
by !) but a single blockchain BC.

ABC := BC|!C

We design a CLOAK framework to enable conﬁdential smart
contract supporting both PRT and MPT on the ABC. A
blockchain with architecture ABC equips CLOAK in a plug-
gable manner to become a new architecture ACloak−BC, where
BC and C in ABC are enhanced to be CLOAK Blockchain (BC)
and CLOAK Client (C) respectively.

ACloak−BC := BC|E|!C|

CLOAK Blockchain (BC). This is a BC with deployed
CLOAK service smart contract, i.e., the CloakService (CS)
in Algorithm 1.
CLOAK Executor (E). A CLOAK Executor (E) is a server
holding a TEE. The TEE marks as E, which runs the CLOAK
enclave program in Algorithm 2.
CLOAK Client (C). A CLOAK Client is a C with CLOAK SDK.
C is able to interact with speciﬁed BC and E to send PRT or
MPT. We mark a CLOAK Client as C.

We leave the details of how to initialize an ABC to become
ACloak−BC in Appendix 9.1. Here we assume that the one-time
global initialization has been done and we get a BC (which
has deployed CS) and E (which publishes the public key pkE
and address adrE of E). Figure 3 shows the workﬂow of
CLOAK framework. It is mainly divided into three phases:
development, deployment, and transaction. We will brieﬂy
travel through these three phases and then introduce them in
detail in Section 5 and 6. Moreover, as PRT can be regarded
as 1-party MPT, we exemplify how CLOAK achieves MPT in
the follow-up part of this paper, without losing generality.

6

DesignIdeaandWorkflowSmart Contracte.g., Solidity, Go etc.Privacy InvariantCloak Smart ContractPrivate ContractPrivacy PolicyannotatePlaintext Tx1, Tx2, …e.g., Ethereum.Phase1:DevelopmentPhase2:DeploymentVerifier ContractPhase3:TransactionCloakBlockchainCloakExecutorCloakClient!"#{DEV}{Parties}deploydeploycompileTEEEnclave…Executor(E)transactCloakCompiler!$%&'($In the development phase, a developer uses CLOAK Lan-
guage, a domain-speciﬁc annotation language we will present
in Section 5, to intuitively annotate privacy invariants in a So-
lidity smart contract. The annotated contract calls a CLOAK
smart contract. Taking the CLOAK smart contract, CLOAK
Compiler identiﬁes transaction types, then generates the cor-
responding privacy enforcement code: a veriﬁer contract V ,
a private contract F , and a privacy policy P .

In the deployment phase, the developer deploys the gen-
erated V ,F ,P to ACloak−BC. Speciﬁcally, the developer ﬁrst
deploys V to BC. The V is constructed by hashes of F ,P
specifying that only state transitions caused by F ,P can be ac-
cepted. Then, the developer deploys F ,P to the E of CLOAK
Executor and binds the address of deployed V to form the
binding of (F ,P ,V ,E). Afterward, E in high-level is respon-
sible for enforcing P , evaluating F , and sending transactions
to V in achieving each MPT.

In the transaction phase, all parties of an MPT follow
CLOAK protocol πCLOAK to interact with the BC and E to
send MPT. The protocol proceeds in four stages. In these
stages, while the setup stage globally proceeds once for E
and each party, other stages proceed for each MPT. In the
following illustration, as E is just responsible for relaying
input and output messages of its E, we simplify the indi-
rect communications of parties->E->E (resp. BC->E->E) to
direct communications of parties->E (resp. BC->E) unless
otherwise stated.
• Global setup stage: When E is registered on BC.CS, all
parties can verify that E is initialized correctly by checking
its attestation report. πCLOAK ﬁrst requires E and all parties
to globally block their coins on BC. Speciﬁcally, E and
parties deposit their coins to E’s address. The collaterals
for joining each MPT will be deducted from these coins.

• (MPT) Negotiation stage: A party sends an MPT proposal
to E without knowing other parties a priori. E starts a non-
deterministic negotiation protocol. First, E generates an id
for the proposal and broadcasts the signed proposal with
the id to all parties. If a party is interested in or required by
the proposal, it responds an acknowledgment to E where
the acknowledgment includes signed commitment of the
party’s parameters. E keeps collecting parties’ acknowl-
edgments until the negotiation stage timeouts or collected
acknowledgments meet the settlement condition of negotia-
tion. Then, E sends a T Xp to BC. T Xp publishes the settled
MPT proposal which records settled parties’ identities and
parameters’ commitments. T Xp also deducts collaterals of
E and all parties for the MPT proposal in case one of them
aborts the MPT after the negotiation succeeds.

• (MPT) Execution stage: When T Xp has been conﬁrmed
on BC, each party sends their signed inputs (i.e., parame-
ters and old states) to E, which computes the MPT. Upon
receiving these inputs, E ﬁrst veriﬁes Proof-of-Publication
(PoP) [12, 14] of T Xp to ensure that T Xp has been con-

ﬁrmed on BC, which indicates that collaterals of parties
have been deducted3 and parties cannot change their param-
eters. Then, E checks that collected parties’ inputs meeting
their commitments in T Xp. In case E does not receive in-
puts from some parties, E needs to determine whether these
parties failed to send inputs or if E behaved maliciously
(e.g., by dropping messages). Therefore, E will punish E
unless it can prove that it reminded these parties but did
not receive the inputs. This proof is generated by perform-
ing a improved challenge-response protocol in [14] via the
blockchain: E publicly challenges these parties on BC. As
soon as this challenge transaction is conﬁrmed, these parties
need to respond publicly on BC by posting a response trans-
action with the ciphertext of their inputs. If these parties
respond, E can extract plaintext of their inputs and continue
with the protocol execution. If these parties did not respond,
E forwards the respective blocks as a transcript to E to
prove that these parties misbehaved, so that E sends T Xpns
to refund collaterals deducted by T Xp to all honest parties
and stop the protocol. Otherwise, if all parties’ inputs have
been successfully collected, E executes the MPT to get
outputs (i.e., return values and new states).

• (MPT) Distribution stage: When the execution stage ﬁn-
ished, E sends a T Xcom to commit the outputs on BC, so
that all parties seeing their outputs’ ciphertext in T Xcom
can decrypt the ciphertext to get their corresponding return
values and new states. Since T Xcom indicates the honesty of
both E and all parties during the protocol, this transaction
also refunds their collaterals respectively. In case E neither
stops the MPT by T Xpns nor completes the MPT by T Xcom
and leads to timeout, any party can send T Xout to punish E
and claim their collaterals back.

4.3 Adversary model

πCLOAK is executed by n parties and a CLOAK Executor E
(who owns the TEE E) to enforce MPT, and depends on TEE
to ensure its conﬁdentiality and integrity. In this paper, we
consider a byzantine adversary who can corrupt all parties
and E but not E. The compromised parties or E can behave
arbitrarily, e.g., scheduling processes as well as reordering,
delaying, mutating messages, however, can not break the con-
ﬁdentiality and integrity of TEE itself. Therefore, while a
party need not execute contracts themselves or hold TEE, we
assume honest party trust all attested TEE as well as their own
platforms and CLOAK Client C. Although we instantiate the
TEE in πCLOAK based on SGX, our design is TEE-agnostic.
In the following, we exemplify SGX to illustrate why the
conﬁdentiality and integrity assumption of TEE are practical.
We stress that although recent research showed some at-
tacks against SGX, the conﬁdentiality and integrity guaran-
tees of SGX are still trustworthy. Speciﬁcally, we assume

3In other words, both E and parties have enough balance in their globally
deposited coins and indeed deducted collaterals required by the speciﬁc MPT.

7

L ::=id | L[e]

(Location)

α ::=me | all | id | tee
τ ::=bool | uint256 | address | bin | mapping(τ1 ⇒ τ2@α2) | mapping(address!id ⇒ τ@α) | address[!id] | τ[@α]

(Privacy type)

(Data type)

e ::=c | me | L | reveal(e, α) | (cid:9)e | e1 ⊕ e2 | e1?e2 : e3 | · · ·

P ::=skip | τ@α id | L = e | P1; P2 | require(e) | i f e {P1} else {P2} | while e {P}
F ::=function f (τ1@α1 id1, . . . , τn@αn idn) returns τ@α {P; return e; }
C ::=contract id{(ﬁnal)?τ1@α1 id1; . . . (ﬁnal)?τn@αn idn; F1 . . . Fm}

(Expression)

(Statement)

(Function)

(Contract)

Figure 4: Syntax of CLOAK. The f and ’id’ are identiﬁers, c is a constant. Native functions are highlighted

that E has full control over the machine and consequently
can execute arbitrary code with root privileges. First, a ma-
licious E can exploit memory-corruption vulnerabilities [2]
in enclave code through the API between the host process
and the enclave. We assume a common code-reuse defense
such as control-ﬂow integrity (CFI) [1, 9], or ﬁne-grained
code randomization [15] to be in place and active. Then,
we consider architectural side-channel attacks, e.g., based on
caches [6]. These attacks can expose access patterns from
SGX enclaves (and therefore our CLOAK prototype). How-
ever, this prompted the community to develop several soft-
ware mitigations [20, 36, 37] and new hardware-based so-
lutions [13, 31]. A more serious Micro-architectural side-
channel attacks like Foreshadow [7] can extract plaintext data
and effectively undermine the attestation process CLOAK re-
lies on, leaking secrets and enabling the enclave to run a
different application than agreed on by the parties; however,
the vulnerability enabling Foreshadow was already patched
by Intel [24]. Therefore, since existing defenses already target
SGX vulnerabilities and since CLOAK ’s design is TEE agnos-
tic (i.e., it can also be implemented using ARM TrustZone or
next-generation TEEs), we consider mitigating side-channel
leakage as an orthogonal problem and out of scope for this pa-
per so that the conﬁdentiality and integrity of TEE devices is
still trustworthy. Therefore, users can trust the TEE integrity
attested by Intel Attestation Service.

We assume the common preﬁx, chain quality, and chain
growth of the blockchain are held so that honest parties and the
Executor can access and trusted the conﬁrmed transactions on
the blockchain. While the conﬁdentiality and integrity guar-
antees of SGX are still trustworthy, we note that CLOAK does
not, and cannot reasonably, prevent contracts from leaking
secrets intentionally or unintentionally through software bugs.

5 CLOAK Language

In this section, we present a domain-speciﬁc language, which
expands privacy invariants annotation - allows developers to
annotate privacy invariants intuitively at the place where the
data are deﬁned - to the MPT scenario (handling C1).

5.1 Language Syntax

CLOAK language is a domain-speciﬁc annotation language
for the conﬁdential smart contract; it allows developers to
declare an owner’s identity and annotate the owner’s private
data ignoring the number of owners a transaction involved.
CLOAK language is implemented based on Solidity [18] one
of the most inﬂuential smart contract languages [23]. Fig. 4
shows the syntax of CLOAK language; it consists of (mem-
ory) locations, data and privacy types, expressions, statements,
functions, and contracts. In order to focus on key insights,
CLOAK is deliberately kept simple.

Locations (L) consist of contract ﬁeld identiﬁers, function
arguments and local variables (‘id’, alphanumeric strings),
and mapping entries (L[e]).

A type declaration (τ@α) in CLOAK consists of a data
type (τ), and a privacy type (α) specifying the owner of a
construct. Privacy types consist of me, a pseudo-address indi-
cating public accessibility (all), a pseudo-address indicating
TEE accessibility (tee) and identiﬁers (covering state vari-
ables, array elements and mapping key tags). For readability,
we often omit all, writing τ instead of τ@all. Besides the well-
known data types (the bool and uint256), CLOAK supports ad-
dresses indicating accounts (address), and binary data captur-
ing signatures, public keys and ciphertexts (bin). In addition,
types include mappings, i.e., mapping(τ1 ⇒ τ2@α2) (resp. ar-
rays τ[@α]) and named mappings, i.e., mapping(address!id
⇒ τ@α) (resp. named arrays address[!id]), deﬁning name
‘id’ for the key of the map to be used in the value type τ@α
(resp. for the element of the array to be used in τ[@α]). It is
straightforward to extend CLOAK with additional types, such
as float and struct.

The only cloak-speciﬁc expressions are the runtime ad-
dress of the caller (me), common address of ¯E (tee), and re-
classiﬁcation of information (reveal). The highlighted expres-
sions can be viewed as evaluations of so-called native func-
tions g(e1, ..., en), including standard arithmetic and boolean
operators (captured by (cid:9), ⊕). It is straightforward to extend
CLOAK with additional native functions (as indicated by ‘...’).
Statements (P) in CLOAK are mostly standard. To declare
a local variable, we write τ@α id. If e does not evaluate to
true, require(e) throws an exception. While we only discuss

8

functions (F) which return a value, CLOAK also allows con-
structors and functions without return values. Contracts (C)
consist of contract ﬁeld declarations and function declarations,
where contract ﬁelds may be declared ﬁnal.

5.2 Specify Privacy Invariants

5.2.1 Invariants speciﬁcation exempliﬁed

With CLOAK language, users can intuitively specify the MPT
in Fig. 1 as a CLOAK smart contract, the .cloak ﬁle in
Listing 1. In line 2, the developer can declare the key of
balances as a temporary variable k, then specify that the cor-
responding value is owned by the account with address k,
e.g., balances[tenderer] is owned by the tenderer in line
23. In line 3, the developer speciﬁes mPrice to be public.
In lines 6-7, to handle an uncertain number of suppliers,
the developer declares owners p and their owned data sep-
arately in two dynamic arrays. In line 10, the return value
sPrice is owned by the winner. In lines 12-13, the devel-
oper reveals private data to another owner, which is forced
by CLOAK to avoid unconsciously leaking private data. In
lines 14-24, it computes the lowest price, the second-lowest
price, and the winner. The computation is based on the
operation between private data from different parties, e.g.,
bids[i]<sPrice, balances[tenderer]+=sPrice.
1 contract SupplyChain {

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

mapping(address !k => uint @k) balances ;
uint @all mPrice ;

function biddingProcure (
address[!p] parties ,
uint[@p] bids ,
address tenderer

) public
returns (address winner , uint @winner sPrice )

{
winner = parties [0];
uint mPrice = reveal( bids [0] , all );
sPrice = reveal( bids [0] , winner );
for (uint i = 1; i < parties .length; i ++)

{
if ( bids [i] < mPrice ) {

winner = parties [i ];
sPrice = mPrice ;
mPrice = bids [i ];

} else if ( bids [i] < sPrice ) {

sPrice = bids [i ];

}

}
balances [ tenderer ] -= sPrice ;
balances [ winner ] += sPrice ;

}

25
26 }

Listing 1: An exempliﬁed CLOAK smart contract (.cloak)

5.2.2 Type system exempliﬁed

We now discuss the type system. We present core rules of
CLOAK ’s type system (illustrated shortly) in Fig. 5. We write

Γ (cid:96) e : τ@α (resp. Γ (cid:13) L : τ@α) to indicate that expression
e (resp. location L) is of type τ@α under the typing con-
text Γ. We write g (cid:96) ∏n
i=1 τi@αi → τ@α (cid:46) F : β to express
that the ith argument of a native function g is of type τi@αi,
the return value is of type τ@α, where α, α1, . . . , αn ∈ {me,
all, id}, the function type of F which g belongs to is β ∈
P(cid:32) Γ(cid:48) to indicate that state-
{PUT, PRT, MPT}. We write Γ
ment P is well-typed and transforms the typing context Γ to
Γ(cid:48), capturing that P might declare new variables and thereby
modiﬁes the context.

Γ (cid:13) L : τ@α α provably evaluates to α(cid:48)
Γ (cid:96) L : τ@α(cid:48)
(a) reduce

Γ (cid:13) L : τ@α Γ (cid:96) e : τ@α(cid:48)
L=e(cid:32) Γ
Γ
(b) assign

(α = α(cid:48) ∨ α(cid:48) = all)

Γ (cid:96) e : τ@α
Γ (cid:96) reveal(e, α(cid:48)) : τ@α(cid:48)

(c) reveal

Figure 5: Selected typing rules for expressions

Fig. 5 shows the expression rules. The provable equal α
and α(cid:48) will be recorded as a same owner (Fig. 5a). The type
rule for assignments L = e (Fig. 5b) requires (a) typing the
target location L as τ@α, (b) the expression e as τ@α(cid:48), and
(c) α = α(cid:48) ∨ α(cid:48) = all. To avoid type errors, we must explic-
itly reclassify expression private to α to another owner α(cid:48)
(Fig. 5c).

(cid:96) g :

n
∏
i=1

τi@αi → τ@αo (cid:46)






F : PUT

F : PRT

F : MPT

∀ αi ∈ {all}

|αo\{all, tee}| = 1

(∃αi = tee) ∨
(|αo\{all}| ≥ 2)

Figure 6: Typing rules for functions. αo = {α1, · · · , αn} is the
uniﬁed owner set of all expressions in g

Fig. 6 shows the function rules recognizing the func-
tion type. We denote the uniﬁed owner set of g’s ex-
pressions as αo = {α1, . . . , αn}. For example, g include
τ1@all, τ2@id, τ3@me, τ4@all. Given me equals id (by
Fig. 5a) thereby αo = (all, me). The functions type of F
which g belongs to is typed as public transaction (PUT) iff
αo = {all}, private transaction (PRT) iff only one private ex-
pression exists but not owned by tee, and multi-party transac-
tion (MPT) iff g reads secrets from different parties. Here we
design the typing rules of PRT and MPT for two reasons. First,
since computational sparse PRT can be also implemented by
ZKP solutions, we distinguish it from MPT to allow devel-
opers in parallel implement PRT functions without TEE, e.g.,
[11], though we stress that it’s also easy to naturally support
PRT by regarding it as a 1-party MPT. Second, we classify the
scenarios involving tee-owned private data to MPT in reason

9

that it also needs evaluating the function in enclaves, thus
technically being equivalent to MPT in the compilation.

Taking a CLOAK smart contract, CLOAK ignores the anno-
tation to check the Solidity validation ﬁrst, then builds an Ab-
stract Syntax Tree (AST) for further analysis. It adopts rules
in Fig. 5 to infer expression owners and recognize function
type by Fig. 6. Then, CLOAK checks privacy invariants consis-
tency, e.g., prohibiting developers from implicitly assigning
private data to variables owned by others. For example, in
Listing 1 line 6-7, the developer declares the address array
_parties’s elements as p, and annotates the _bids’s elements
being private to p respectively. Therefore, CLOAK requires
the run-time length of _parties equals it of _bids. Next, in
line 20, the run-time owner of _bid[i], i.e., _parties[i], is
different from the owner of sPrice, thus CLOAK infers the
function being MPT.

5.3 Generate and Deploy Enforcement Code

With a speciﬁed CLOAK smart contract, CLOAK compiles the
contract to generate enforcement code, i.e. a veriﬁer contract
V that be deployed on blockchain to verify state transition, a
private contract F that will be conﬁdentially executed in TEE,
and a privacy policy P that holds ownership setting of the
CLOAK smart contract and is also deployed to and enforced
by TEE. We leave the details of V , F , P in Appendix 9.2.

In the deployment phase, a developer uses C to deploy
the generated enforcement code (i.e., V ,F ,P ) to ACLOAK−BC
(handling C2). Speciﬁcally, the developer ﬁrst deploys V to
BC. V is constructed by adrE and hashes of F ,P . In this way,
V only accepts state transition transactions that match the
F ,P in it and are sent by adrE . Then, the developer deploys
F ,P to E and binds adrV to F ,P . We leave the details of
how to deploy V , F , P to ACLOAK−BC in Appendix 9.2.

6 CLOAK Protocol

CLOAK protocol πCLOAK is used to enforce MPT in the trans-
action phase (handling C3). As is shown in Figure 7, given
a CLOAK blockchain BC, a party set ¯P (a set of C participat-
ing the MPT), and a CLOAK Executor E, where | ¯P| = n, we
stress that each Pi ∈ ¯P communicates with E of E by secure
channel, i.e., all messages sent by a party Pi to E is signed
by Pi and encrypted by pkE , while all messages sent by E to
Pi are also signed by E . Therefore, for simplicity, we omit
to mark ciphertext in communications between ¯P and E in
the following, but will explicitly mark the ciphertext in each
transaction sent to the blockchain.

ure 7. Before using CLOAK, a party Pi is supposed to globally
register its public key pki and deposit its coins Q in global
setup stage. We stress this stage happen only once for each
party. Then, three stages follows to evaluate an MPT. During
a negotiation stage, all parties negotiate to join an MPT and
ﬁnally, E commits settled MPT proposal with parties’ inputs
commitments and deducts their collateral on-chain. Then, an
execution stage follows for collecting plaintext of parame-
ters and old states from parties and executing MPT in the
TEE enclave to get outputs. When the execution ﬁnishes, the
protocol enters a distribution stage to commit outputs and
complete the MPT. We now explain the detailed protocol steps
in depth. The detailed interactions are displayed in Figure 7.
Algorithm 2 in Appendix 9.1 describes the CLOAK enclave
program E.

6.1.1 Negotiation stage

The negotiation stage uses an nondeterministic negotiation
protocol (Procnoneg) to guide parties to reach a consensus
on an MPT proposal and commit parameters xi on-chain4.
Procnoneg allows ¯P proceeds in two steps.

S1: One party who wants to call an MPT f send an MPT
proposal p = (cid:104) f , q,tn(cid:105) to E, in which tn means the time of
ﬁnishing the negotiation phase, q refers to required collaterals
for punishing malicious parties. Then, E generates a random
id idp for the proposed MPT and broadcasts the signed (cid:104)idp, p(cid:105)
to parties.

S2: Receiving (cid:104)idp, p(cid:105), each Pi interested in the MPT au-
tonomously computes the commitment Cxi of its parameter
xi and sends a signed acknowledgment ACKi = (cid:104)idp,Cxi(cid:105) to
E before tn. E receiving ACKi knows that Pi is interested in
the MPT. Then, E reads T X i
pk to get pki. pki will be used
for encrypting Pi’s secrets next. E keeps collecting ACKi. If
collected ACKi meet the settlement condition5 in p, E con-
structs the settled proposal p(cid:48) which expands p with parties’
addresses ¯P and the hash of parameter commitments HCx . E
then sends T Xp to conﬁrm the p(cid:48) on blockchain before exe-
cuting the MPT. T Xp also deducts q collateral of each party
respectively before executing the MPT. Then, E goes to the
execution stage. Otherwise, if the settlement condition is still
not satisﬁed and the time exceeds tn, the negotiation of the p
failed and E stops the protocol.

6.1.2 Execution stage

This stage aims to collect plaintext inputs from parties and
execute the MPT to get outputs. It also contains three steps.
S1: Upon T Xp is conﬁrmed on BC, E veriﬁes the Proof-of-
Publication (PoPp [10, 12]) of T Xp. Then, E reads f -needed

6.1 CLOAK Protocol in Transaction Phase

As explained in Section 4, our protocol πCLOAK used in the
transaction phase proceeds in four stages, depicted in Fig-

4As contracts’ storage, old state si has been committed on-chain.
5Settlement conditions of negotiation can be ﬂexible and conﬁgurable,
e.g., all inputs required by the MPT have been provided or the number of
parties exceeds a speciﬁc number.

10

CLOAK Clients ( ¯PC)

CLOAK Executor (EE F ,P

)

CLOAK
Blockchain (BCCS,V )

send T X i

pk ← BC.CS.register(pki)

send T X i

col ← BC.CS.deposit(Q)

Global
setup
stage

sends T X E

col ← BC.CS.deposit(Q)

initialize p ← (cid:104) f , q,tn(cid:105)
send p

+

E.generateIDp

generates idp
sends (cid:104)idp, p(cid:105)

Negotiation
stage
(Procnoneg)

generate a random number rx
i
generate Cxi ← Encpki (xi, rx
i )
send ACKi ← (cid:104)idp, HCxi

(cid:105)

E.propose

gets T X i

pk and reads pki

generates p(cid:48) ← (cid:104)adrV , f , ¯P, HCxi
sends T Xp ← BC.CS.propose(idp, p(cid:48), τres, τcom)

, q(cid:105)

veriﬁes PoPp and reads T Xp,Cs

send in ← (cid:104)xi, rx

i , si, rs
i (cid:105)

if Pj ∈ ¯PM is challenged
generate in ← (cid:104)xi, rx
i , si, rs
i (cid:105)
sends T Xres ← BC.CS.response(idp, EncpkE

(in))

E.execute

E.challenge

E.punish

if ¯PM ⊂ ¯P depart the protocol
sends T Xcha ← BC.CS.challenge(idp, ¯PM)

veriﬁes PoPres and reads T Xres

M ⊂ ¯PM still depart

if ¯P(cid:48)
sends T Xpns ← BC.CS.punish(idp, ¯P(cid:48)

M, q)

(cid:88)

(cid:88)

evaluate f (x) based on s
get s(cid:48), r

generates random numbers rs(cid:48)
,Cri ← Encpki (s(cid:48)

i , rr
i
i, rs(cid:48)
i ), Encpki (ri, rr
generates Cs(cid:48)
i )
i
generates proo f ← (cid:104)HP , HF , ˆHCs , ˆHCx , ˆHCs(cid:48) , ˆHCr (cid:105)
sends T Xcom ← BC.CS.complete(idp, proo f ,Cs,Cs(cid:48) ,Cr)

send T Xout ← BC.CS.timeout(idp)

E.complete

Execution
stage

Distribution
stage

↑ S1

↑ S2

↑ S1

↑ S2

↑ S3

Figure 7: The detailed CLOAK protocol πCLOAK. The ¯PC means parties holding CLOAK Client C. The EE F ,P
means a CLOAK Executor
holding a TEE device E with deployed F ,P . BCCS,V means the CLOAK Blockchain with deployed CLOAK service contract CS and veriﬁer
contract V . Double dashed arrows refer to reading from the blockchain and double arrows refer to sending a transaction to the blockchain.
Normal arrows mean off-chain communication. Procnoneg refers to Non-deterministic negotiation protocol. All parties Pi communicate with
the CLOAK Executor in secure channels, thus we omit to mark ciphertext in communications between ¯P and E for simplicity but explicitly
mark the ciphertext in each transaction published on BCCS,V . For parties’ private data, we refer the part of data d owned by Pi to di (e.g., xi, rx
i ),
and refer an array [di|1..n] including all di from n parties to d (e.g., x, rx). For operation based on these data, we similarly refer hash(di) to Hdi ,
and [hash(di)|1..n] to Hd (e.g., HCx refers to [hash(Cxi )|1..n]). Differently, we refer ˆHd (e.g., ˆHCx , ˆHCs ) to hash([di|1..n]).

11

6 from BC. Meanwhile, each party
old state commitments Cs
Pi knowing they are involved in T Xp sends inputs (i.e., param-
eters xi and old states si) to E. The E receiving Pi’s inputs
recomputes commitments of xi, si respectively to match them
with their commitments Cxi,Csi. If all involved parties’ inputs
are collected and matched, E goes to S3. Otherwise, if E ﬁnds
that some parties’ inputs mismatches their on-chain commit-
ments, or have not received some parties’ inputs before te, E
marks these parties as potentially misbehaved parties ¯PM and
returns ¯PM to E. Then, E calls challenge to send T Xcha to
challenge all parties in ¯PM on-chain. Then, E goes to S2.

S2: When T Xcha has been conﬁrmed on-chain, honest par-
ties in ¯PM are supposed to send a T Xres to publish their cipher-
text of inputs xi, si on BC. All published T Xres are required to
be conﬁrmed before block height τres. When the block height
goes to τres, E reads published T Xres and veriﬁes its PoPres.
For a party Pi in ¯PM, if E successfully reads matched inputs
res, E removes Pi from ¯PM. Otherwise, if PoPres
from its T X i
shows that no T X i
res is published or the inputs in T X i
res are
still mismatched, E keeps Pi in ¯PM. After that, if ¯PM becomes
empty, which means all inputs are collected, E goes to S3. On
the contrary, if ¯PM is not empty, which means the misbehavior
of parties left is conﬁrmed, E marks these misbehaved parties
as ¯P(cid:48)
M. Then, E sends T Xpns. The T Xpns calls BC.CS.punish
to refund deducted collaterals of all parties to only honest
parties on average and settle the MPT with ABORT.

S3: If all parties’ inputs are correctly collected, E replaces
the state of private contract F with old state s, then execute
f (x) to get MPT outputs, i.e., return values r and new state s(cid:48).

6.1.3 Distribution stage

i

i, ri thus getting Cs(cid:48)

This stage delivers s(cid:48)
i, ri to each Pi by publishing their com-
mitments on-chain. Speciﬁcally, E computes commitments
of s(cid:48)
,Cri. Then, E generates a proo f
and sends T Xcom = BC.CS.complete(idp, proo f ,Cs,Cs(cid:48),Cr)
to blockchain. The proo f = (cid:104)HP , HF , ˆHCs , ˆHCx , ˆHCs(cid:48) , ˆHCr (cid:105)
where HP (resp. HF ) refers to hash(P ) (resp. hash(F )) and
ˆHCs refers to hash([Csi|1..n]) as well as ˆHCx , ˆHCs(cid:48) , ˆHCr . The
proo f in T Xcom achieves the public veriﬁability of the MPT
by following way: The signed T Xcom means that E endorses
that by enforcing a privacy policy P (matching HP ), it takes
private x, s (matching ˆHCx , ˆHCs) from ¯P, evaluates f of a pri-
vate contract F (matching HF ), and gets private outputs s(cid:48), r
(matching ˆHCs(cid:48) , ˆHCr ). Therefore, by trusting the integrity and
conﬁdentiality of E, if BC.CS checks that HP , HF in proo f
match recorded HP , HF in V and the HCs in proo f matches
the current state commitments7 of V , BC.CS then accepts the
state transition and updates V ’s current state commitment
with Cs(cid:48), which signals the COMPLETE of the MPT. Otherwise,
if E departing the protocol does not complete (by T Xcom)

6The old states that the called MPT f read in execution. E reads f -needed

old states commitments from BC according to f ’s read set P f .PX .

7V reads current state commitments of V according to T Xcom.PX

12

or stop (by T Xpns) the MPT before the block height τcom, it
indicates that E departs the protocol by dropping T Xcom and
T Xpns or crashing. Then, any Pi can send T Xout to punish E
and refunds their collaterals with additional compensation.
T Xout also ﬁnishes the MPT with TIMEOUT.

7 System Security

In this section, we present the underlying protocol security
considerations of CLOAK. The architecture security is shown
in Appendix 9.3. To guarantee security for the protocol, we
require three security properties. Intuitively, they can be ex-
plained as the following:
Conﬁdentiality. During a period without any compromised
TEE, CLOAK guarantees that the inputs, return values, and
contract states of MPT are kept secret to their owners.
Public Veriﬁability. Everyone can verify that a state transi-
tion correctly results from an MPT which given committed
old states and parameters from different parties results in the
claimed committed return values and new states.
Financial Fairness. At least one of parties or the Executor is
honest, then either (i) the protocol correctly completes execu-
tion of MPT or (ii) all honest parties and the Executor know
that setup or negotiation failed and stay ﬁnancially neutral
or (iii) all honest parties and the Executor know the proto-
col abort, stay ﬁnancially neutral, and malicious parties or
Executor must have been ﬁnancially punished.

Theorem 1 (Informal statement). The protocol
πCLOAK satisﬁes conﬁdentiality, public veriﬁability,
ﬁnancial fairness

8 Evaluation

System implementations. We prototype CLOAK compiler
by ANTLR [32]. It generates P in JSON and contracts V ,F
in Solidity 0.8 [16]. We use Ganache [41] as BC and prototype
the CLOAK enclave program and its called EVM [17] in C++
as an application of CCF [35] with a single node.
Methodology and setup. To evaluate the effectiveness of
CLOAK, we propose 3 research questions.

• Q1: How does CLOAK language reduce the complexity of

developing conﬁdential smart contracts?

• Q2: What’s the cost of initialization, setup and deployment

for enabling MPT on a blockchain by using CLOAK?

• Q3: What’s the cost of sending MPT by using CLOAK?

The experiment is based on Ubuntu 18.04 with 32G memory
and 2.2GHz Intel(R) Xeon(R) Silver 4114 CPU. Although
the gas cost of a speciﬁc transaction is deterministic, it also
varies from transaction arguments. Therefore, we send each

transaction of CLOAK parsed contract 5 times with different
arguments to get the average.
Development Simplicity. To answer Q1, we apply CLOAK
on 8 contracts. The 8 contracts vary from LOC, scenarios, and
privacy needs. Contracts business involves energy, education,
blockchain infrastructure and so on. Their LOC distributes
from 29 to 1035, which is a representative LOC distribution of
Ethereum contracts [23]. Each of these contracts consists of
at least two of three function types (PUT, PRT, and MPT). Ta-
ble 2 shows the LOC of code before and after using CLOAK.
Speciﬁcally, for MPT related code, while developers sim-
ply annotate privacy invariants of MPT in Solidity contract,
CLOAK generates a total of 2.86-21.78X LOC, including 0.30-
4.11X LOC of veriﬁer contracts, 1.06-4.33X private contracts,
and 1.67-13.33X privacy policies. Therefore, CLOAK signif-
icantly reduces the development complexity of privacy in
cryptography understanding and code implementation.

Table 2: The LOC of code before and after using CLOAK.
#C refers to the number of transactions (PUT, PRT, MPT); The #Fa,
#Va, and #Pa refer to LOC of the CLOAK smart contract, private
contract, veriﬁer contract, and privacy policy respectively.

Name

#TX

#C #Fa #Va #Pa

MPT related

#C #F #V #P

PowerGrid
4(1, 1, 2)
11 36 39 114
29
60 71 146
Bidding
4(1, 1, 2)
22 56 61 137
70 73 164
46
SupplyChain 6(1, 4, 1)
9
39 37 120
71 110 118 357
Scores
6(1, 2, 3)
37 106 126 289
79 126 139 438
ERC20Token
11(4, 4, 3) 115 152 130 662
38 55 37 240
YunDou
14(11, 0, 3) 275 348 331 1172 99 105 58 433
Oracle
22(20, 0, 2) 329 323 333 1720 37 60 48 307
HTLC
39(31, 0, 8) 1035 858 576 2240 377 437 146 816

Gas cost of initialization and deployment. To answer Q2,
we discuss the gas cost of deploying CloakService and gen-
erated contracts. Speciﬁcally, we compile the CLOAK smart
contracts in Table 2. As is depicted in Figure 8. In global
initialization phase. deploying the CloakService to enable
CLOAK cost the CLOAK service provider 4.49M gas. In global
setup stage, each party pays 127k gas to register its public key
and 42k gas to deposit its coins. Then, for developers, they
pay 2.90-6.87X gas to deploy the transformed small contracts
(PoW.-ERC.), 1.49X gas to deploy the transformed Yun., 0.92X
gas to deploy the transformed Ran., and 0.05X to deploy the
transformed HTLC, where Yun.-HTLC are industrial contracts.
This result indicates that with the computation complexity
of original contracts growing, the gas cost of transformed
contracts relatively reduces. That is because the gas cost of
generated V to verify and update new state depends more on
how many state variables the V managed than how heavy the
computation is in original contracts. Therefore, CLOAK has
great potentiality in applying to industrial contracts.
Gas cost of sending MPT. To answer Q3, for all 8 contracts,
all their 24 MPT cost 0.71X gas to the Fastkitten on average.

Figure 8: The gas cost of CLOAK

Speciﬁcally, for the MPT with 1 party (classiﬁed as MPT by
tee), CLOAK cost 0.97X gas. However, for all MPT with at
least 2 parties, CLOAK cost 0.46-0.82X gas (0.71X on aver-
age). The result shows that the more parties involved in an
MPT, the more advantage CLOAK has in gas cost, e.g., for
10 parties, CLOAK costs only 0.46X gas against Fastkitten.
We stress that while our implementation is deﬁnitely not opti-
mized, we can furthermore adopt other methods to reduce the
gas cost. We discuss it in detail in Appendix 9.4.
Off-chain latency of sending MPT. Normally, all 24 MPT
complete in 6 second except that an bidding transaction with
6 parties completes in 8 seconds. We stress that only 0.1-0.39s
is cost for negotiation phase and 0.26-0.71s is for execution
and distribution phase. Most time 4-5s is spent on verifying
the PoPp of T Xp, which is also indicated in [14].

9 Conclusion

In this paper, we have ﬁrst identiﬁed and formalized the prob-
lem of the Multi-party Transaction which requires public veri-
ﬁability of a state transition caused by a multi-party computa-
tion process. We also developed a novel framework, CLOAK,
to enable conﬁdential smart contracts with mixed PUT, PRT,
and MPT on existing blockchains. To the best of our knowl-
edge, CLOAK advances in these aspects: introducing the ﬁrst
domain-speciﬁc language which allows developers to specify
PUT, PRT, and MPT in a single conﬁdential smart contract
by annotating privacy invariants at the place; the ﬁrst solution
achieving public veriﬁability of an MPT; supporting parties
negotiating MPT proposals without knowing each other’s
identity in prior; achieving ﬁnancial fairness under byzantine
adversary model. During our evaluation of CLOAK in both
examples and real-world smart contracts, the LOC of develop-
ing CLOAK smart contract is 13.5% less than deployed ones,
and CLOAK requires only 2 transactions to secure an MPT.

In conclusion, CLOAK achieves low-cost, secure, and pub-
lic veriﬁable MPT. It eliminates low-level, bug-prone, and
time-consuming MPT implementations for both developers
and users thus paving the way for general-purpose multi-party
privacy-preserved computation.

13

5000.0x1045250.0x1045500.0x1045750.0x1046000.0x104FastkittenmptinitializesetuporigindeployCSdep.reg.Pow.Bid.Sup.Sco.ERC.YunRan.HTLC11112113233321121022122111Different Phases of Contracts0.0x104200.0x104400.0x104Gas CostReferences

[1] Martín Abadi, Mihai Budiu, Ulfar Erlingsson, and Jay
Ligatti. Control-ﬂow integrity principles, implementa-
tions, and applications. ACM Transactions on Informa-
tion and System Security (TISSEC), 13(1):1–40, 2009.

[2] Andrea Biondo, Mauro Conti, Lucas Davi, Tommaso
Frassetto, and Ahmad-Reza Sadeghi.
The guards
dilemma: Efﬁcient Code-Reuse attacks against intel sgx.
In 27th USENIX Security Symposium (USENIX Security
18), pages 1213–1227, Baltimore, MD, August 2018.
USENIX Association.

[3] Dan Bogdanov, Peeter Laud, and Jaak Randmets.
Domain-polymorphic
privacy-
preserving applications. In Proceedings of the Ninth
Workshop on Programming Languages and Analysis for
Security, pages 53–65, 2014.

programming

of

[4] Niek J. Bouman. MPyC: Rapid-Prototyping MPC Com-

putations in Python, 10 2018.

[5] Sean Bowe, Alessandro Chiesa, Matthew Green, Ian
Miers, Pratyush Mishra, and Howard Wu. ZEXE: En-
abling Decentralized Private Computation. 2020 IEEE
Symposium on Security and Privacy, 2020.

[6] Ferdinand Brasser, Urs Müller, Alexandra Dmitrienko,
Kari Kostiainen, Srdjan Capkun, and Ahmad-Reza
Sadeghi. Software grand exposure: Sgx cache attacks
are practical. In 11th USENIX Workshop on Offensive
Technologies (WOOT 17), Vancouver, BC, August 2017.
USENIX Association.

[7] Jo Van Bulck, Marina Minkin, Oﬁr Weisse, Daniel
Genkin, Baris Kasikci, Frank Piessens, Mark Silberstein,
Thomas F. Wenisch, Yuval Yarom, and Raoul Strackx.
Foreshadow: Extracting the keys to the intel sgx king-
In 27th
dom with transient Out-of-Order execution.
USENIX Security Symposium (USENIX Security 18),
page 991–1008, Baltimore, MD, August 2018. USENIX
Association.

[8] Benedikt Bünz, Shashank Agrawal, Mahdi Zamani, and
Dan Boneh. Zether: Towards privacy in a smart contract
world. In Joseph Bonneau and Nadia Heninger, editors,
Financial Cryptography and Data Security, pages 423–
443, Cham, 2020. Springer International Publishing.

[10] Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang,
Jonathan Katz, Iddo Bentov, Yan Ji, Fan Zhang, Lorenz
Breidenbach, Philip Daian, and Ari Juels. Tesseract:
Real-Time Cryptocurrency Exchange Using Trusted
Hardware. Proceedings of the 2019 ACM SIGSAC
Conference on Computer and Communications Secu-
rity, pages 1521–1538, 2019.

[11] Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang,
Jonathan Katz, Samuel Steffen, Benjamin Bichsel,
Mario Gersbach, Noa Melchior, Petar Tsankov, and Mar-
tin Vechev. zkay: Specifying and Enforcing Data Privacy
in Smart Contracts. pages 1759–1776, 2019.

[12] Raymond Cheng, Fan Zhang, Jernej Kos, Warren He,
Nicholas Hynes, Noah Johnson, Ari Juels, Andrew
Miller, and Dawn Song.
Ekiden: A Platform for
Conﬁdentiality-Preserving, Trustworthy, and Perfor-
mant Smart Contracts. 2019 IEEE European Symposium
on Security and Privacy (EuroS&P), 00:185–200, 2019.

[13] Victor Costan, Ilia Lebedev, and Srinivas Devadas. Sanc-
tum: Minimal hardware extensions for strong soft-
ware isolation. In 25th USENIX Security Symposium
(USENIX Security 16), pages 857–874, 2016.

[14] Poulami Das, Lisa Eckey, Tommaso Frassetto, David
Gens, Kristina Hostáková, Patrick Jauernig, Sebastian
Faust, and Ahmad-Reza Sadeghi. FastKitten: Practi-
cal smart contracts on bitcoin. In 28th USENIX Secu-
rity Symposium (USENIX Security 19), pages 801–818,
Santa Clara, CA, August 2019. USENIX Association.

[15] Lucas Vincenzo Davi, Alexandra Dmitrienko, Stefan
Nürnberger, and Ahmad-Reza Sadeghi. Gadge me if
you can: secure and efﬁcient ad-hoc instruction-level
randomization for x86 and arm. In Proceedings of the
8th ACM SIGSAC symposium on Information, computer
and communications security, pages 299–310, 2013.

[16] Ethereum. Solc 0.5.17, July 2021.

[17] Ethereum Foundation. Ethereum virtual machine, Dec

2020.

[18] Ethereum Foundation. Solidity documentation, Dec

2020.

[19] Alex Gluchowski.

Zk rollup: scaling with zero-

knowledge proofs. 2019.

[9] Nathan Burow, Scott A Carr, Joseph Nash, Per Larsen,
Michael Franz, Stefan Brunthaler, and Mathias Payer.
Control-ﬂow integrity: Precision, security, and perfor-
mance. ACM Computing Surveys (CSUR), 50(1):1–33,
2017.

[20] Daniel Gruss, Julian Lettner, Felix Schuster, Olya Ohri-
menko, Istvan Haller, and Manuel Costa. Strong and
efﬁcient cache side-channel protection using hardware
transactional memory. In 26th USENIX Security Sympo-
sium (USENIX Security 17), pages 217–233, 2017.

14

[21] Marcella Hastings, Brett Hemenway, Daniel Noble, and
Steve Zdancewic. SoK: General Purpose Compilers for
Secure Multi-Party Computation. volume 00 of 2019
IEEE Symposium on Security and Privacy (SP), pages
1220–1237, 2019.

22nd USENIX Security Symposium (USENIX Security
13), pages 479–498, 2013.

[32] Terence Parr. Antlr(another tool for language recogni-

tion), Dec 2020.

[22] Marcella Hastings, Brett Hemenway, Daniel Noble, and
Steve Zdancewic. SoK: General Purpose Compilers
for Secure Multi-Party Computation. 2019 IEEE Sym-
posium on Security and Privacy (SP), 00:1220–1237,
2019.

[33] Aseem Rastogi, Matthew A Hammer, and Michael
Hicks. Wysteria: A programming language for generic,
mixed-mode multiparty computations. In 2014 IEEE
Symposium on Security and Privacy, pages 655–670.
IEEE, 2014.

[23] Péter Heged˝us. Towards Analyzing the Complexity
Landscape of Solidity Based Ethereum Smart Contracts.
Technologies, 7(1):6, 2019.

[24] Intel. Resources and response to side channel l1 terminal

fault, Dec 2021.

[34] Indrajit Ray, Ninghui Li, Christopher Kruegel, Ranjit
Kumaresan, Tal Moran, and Iddo Bentov. How to Use
Bitcoin to Play Decentralized Poker. Proceedings of
the 22nd ACM SIGSAC Conference on Computer and
Communications Security, 2015.

[25] Ahmed Kosba, Andrew Miller, Elaine Shi, Zikai Wen,
and Charalampos Papamanthou. Hawk: The Blockchain
Model of Cryptography and Privacy-Preserving Smart
Contracts. 2016 IEEE Symposium on Security and Pri-
vacy (SP), pages 839–858, 2016.

[35] Mark Russinovich, Edward Ashton, Christine Avanes-
sians, Miguel Castro, Amaury Chamayou, Sylvan Cleb-
sch, and et al. Ccf: A framework for building conﬁ-
dential veriﬁable replicated services. Technical report,
Microsoft Research and Microsoft Azure, 2019.

[26] Chang Liu, Xiao Shaun Wang, Kartik Nayak, Yan
Huang, and Elaine Shi. Oblivm: A programming frame-
work for secure computation. In 2015 IEEE Symposium
on Security and Privacy. IEEE, 2015.

[36] Jaebaek Seo, Byoungyoung Lee, Seong Min Kim, Ming-
Wei Shih, Insik Shin, Dongsu Han, and Taesoo Kim.
Sgx-shield: Enabling address space layout randomiza-
tion for sgx programs. In NDSS, 2017.

[27] David Maier, Rachel Pottinger, AnHai Doan, Wang-
Chiew Tan, Abdussalam Alawini, Hung Q Ngo, Ying
Yan, Changzheng Wei, Xuepeng Guo, Xuming Lu, Xi-
aofu Zheng, Qi Liu, Chenhui Zhou, Xuyang Song, Bo-
ran Zhao, Hui Zhang, and Guofei Jiang. Conﬁdentiality
Support over Financial Grade Consortium Blockchain.
pages 2227–2240, 2020.

[28] Dahlia Malkhi, Noam Nisan, Benny Pinkas, Yaron Sella,
et al. Fairplay-secure two-party computation system. In
USENIX Security Symposium, volume 4, page 9. San
Diego, CA, USA, 2004.

[29] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic
cash system. Decentralized Business Review, page
21260, 2008.

[30] Janus Dam Nielsen and Michael I Schwartzbach. A
domain-speciﬁc programming language for secure mul-
tiparty computation. In Proceedings of the 2007 work-
shop on Programming languages and analysis for secu-
rity, pages 21–30, 2007.

[31] Job Noorman, Pieter Agten, Wilfried Daniels, Raoul
Strackx, Anthony Van Herrewege, Christophe Huygens,
Bart Preneel, Ingrid Verbauwhede, and Frank Piessens.
Sancus: Low-cost trustworthy extensible networked de-
vices with a zero-software trusted computing base. In

[37] Ming-Wei Shih, Sangho Lee, Taesoo Kim, and Marcus
Peinado. T-sgx: Eradicating controlled-channel attacks
against enclave programs. In NDSS, 2017.

[38] Rohit Sinha. Luciditee: A tee-blockchain system for
policy-compliant multiparty computation with fairness.
2020.

[39] Second State and Oasis Labs. Conﬁdential Ethereum

Smart Contracts. Technical report, 12 2020.

[40] Bhavani Thuraisingham, David Evans, Tal Malkin,
Dongyan Xu, Arka Rai Choudhuri, Matthew Green, Ab-
hishek Jain, Gabriel Kaptchuk, and Ian Miers. Fairness
in an Unfair World: Fair Multiparty Computation from
Public Bulletin Boards. Proceedings of the 2017 ACM
SIGSAC Conference on Computer and Communications
Security, pages 719–728, 2017.

[41] trufﬂesuite. Ganache, July 2021.

[42] Edgar Weippl, Stefan Katzenbeisser, Christopher
Kruegel, Andrew Myers, Shai Halevi, Ranjit Kumare-
san, and Iddo Bentov. Amortizing Secure Computation
with Penalties. Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security,
2016.

15

[43] Edgar Weippl, Stefan Katzenbeisser, Christopher
Kruegel, Andrew Myers, Shai Halevi, Ranjit Ku-
maresan, Vinod Vaikuntanathan, and Prashant Nalini
Vasudevan.
Improvements to Secure Computation
with Penalties. Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security,
pages 406–417, 2016.

[44] Gavin Wood et al. Ethereum: A secure decentralised
generalised transaction ledger. Ethereum project yellow
paper, 2014.

[45] Andrew C Yao. Protocols for secure computations. In
23rd annual symposium on foundations of computer
science (sfcs 1982), pages 160–164. IEEE, 1982.

Appendix

9.1 Enable CLOAK on Existing Blockchain

To be interoperable with existing blockchains, CLOAK is de-
signed to depend on contract-based infrastructure to enable
MPT. The CLOAK Executor should globally initialize its TEE
and register E on an existing blockchain ﬁrst, then anyone
can deploy their generated enforcement code of the CLOAK
smart contract to enable MPT on the blockchain.

9.1.1 Setup CLOAK executor

The CLOAK Executor deploys the CLOAK enclave program
(Algorithm 1) in a TEE device to get its E. E ﬁrst calls setup
to generate a key pair and accounts inside E, i.e., (pkE , skE )
and (adrE , keyE ). Then, E publish the Attestation Report
REPias of its E.

9.1.2 Setup CLOAK blockchain

The CLOAK Executor deploys a CloakService (CS, Algo-
rithm 1) on an existing blockchain BC to get a CLOAK
blockchain BC. CS is constructed by the conﬁg of E, e.g.,
pkE and adrE , so that parties can authenticate E by REPias
and build secure channel with E by pkE . Moreover, CS also
allows parties to call CS.register to register their public keys,
so that E can get parties’ registered keys pki to encrypt pri-
vate data by their owners’ public keys. Finally, CS provides
several functions to follow πCLOAK and manage the life cycles
of MPT.

9.2 Enforcement Code Generation

9.2.1 Privacy policy generation

CLOAK generates a privacy policy P for a CLOAK smart
contract. To formally explain P , we ﬁrst model the privacy
policy of an basic annotated private data d as Pd = (cid:104)idd, τ@α(cid:105),

Algorithm 1: CLOAK service contract (CS)

// Can be deployed to any contract-enabled blockchain

1 Function constructor(pkE , adrE , adrE)

// called by CL O A K service provider
pkE , adrE ← pkE , adrE // for secure channel
adrE ← adrE
Prpls ← []

2

3

4

5 Function register(pki)

// called by T Xpk
ParPKs[msg.sender] ← pki

6

7 Function deposit(Q)

// called by T Xcol
Coins[msg.sender] ← Coins[msg.sender] + Q

8
9 Function propose(idp, p(cid:48), τres, τcom)

// called by T Xp from TEE, E
require(Prpls[idp] = /0)
Prpls[idp].{V , f , ¯P, HCx , q, τres, τcom, hcp} ←
p(cid:48).{adrV , f , ¯P, HCx , q}, τres, τcom, BC.getHeight()
// deduct collaterals before execution
Coins[adrE] ← Coins[adrE] − Prpls[idp].q
require(Coins[adrE] ≥ 0)
for Pi ∈ ¯P do

10

11

12

13

14

15

16

Coins[Pi] ← Coins[Pi] − Prpls[idp].q
require(Coins[Pi] ≥ 0)
Prpls[idp].status ← SETTLE
17
18 Function challenge(idp, ¯PM)

// called by T Xcha from TEE, E
require(Prpls[idp].status = SETTLE)
for Pi ∈ ¯PM do

Prpls[idp]. ¯P[Pi].cha ← true

19

20

21

22 Function response(idp, EncpkE

(in))

// called by T Xres from parties
require(Prpls[idp].status = SETTLE)
Prpls[idp]. ¯P[msg.sender].res ← EncpkE

(in)

24
25 Function punish(idp, ¯P(cid:48)

M)

// called by T Xpus from TEE, E
require(BC.getHeight() > Prpls[idp].hcp + τres)
require(Prpls[idp].status = SETTLE)
M |

| ¯P(cid:48)
|Prpls[idp]. ¯P− ¯P(cid:48)

)

M |+1

r f col = Prpls[idp].q ∗ (1 +
for Pi ∈ (Prpls[idp]. ¯P − ¯P(cid:48)

M) do

30

31

32

Coins[Pi] ← Coins[Pi] + r f col
Coins[adrE] ← Coins[adrE] + r f col
Prpls[idp].status ← ABORT
33 Function complete(idp, proo f ,Cs(cid:48) ,Cr)
// called by T Xcom from TEE, E
require(Prpls[idp].status = SETTLE)
if V .verify(proo f , Prpls[idp].Cx,Cs(cid:48) ,Cr) then

34

35

V .setNewState(Cs(cid:48) )
Prpls[idp].{Cr} ← {Cr}
r f col = Prpls[idp].q
for Pi ∈ Prpls[idp]. ¯P do

Coins[Pi] ← Coins[Pi] + r f col
Coins[adrE] ← Coins[adrE] + r f col
Prpls[idp].status ← COMPLETE

23

26

27

28

29

36

37

38

39

40

41

42

43 Function timeout(idp)

// called by T Xout from parties
require(BC.getHeight() > Prpls[idp].hcp + τcom)
require(Prpls[idp].status = SETTLE)
r f col = Prpls[idp].q ∗ (1 +
for Pi ∈ Prpls[idp]. ¯P do

1
|(Prpls[idp]. ¯P|

)

Coins[Pi] ← Coins[Pi] + r f col

Prpls[idp].status ← TIMEOUT

44

45

46

47

48

49

16

Algorithm 2: CLOAK enclave program (E)

// For setup of E and deployment of F ,P . For
simplicity, we ignore idp management logic

1 Function setup(κ, bcp)
2

pkE , skE , adrE , keyE ← Gen(1κ) // for new E
τres, τcom ← Gen(1κ) // secure parameters for PRT/MPT
return pkE

4
5 Function deploy(F ,P , adrV )
bind (cid:104)F ,P , adrV (cid:105)
6
return adrF

7

// For enforcement of PRT/MPT

8 Function generateIDp(p)
9

p ← p
idp ← Gen(1κ)
status ← GENERATEIDP
return (cid:104)idp, p(cid:105)

13 Function propose(ACK, T Xpk)
14

if status (cid:54)= GENERATEIDP or currentTime > p.tn or
MeetPolicy(ACK,P .P f . ¯P) (cid:54)= 1 then abort
p(cid:48) ← (cid:104)adrV , p. f , ¯P, ACK.HCx , p.q(cid:105)
status ← SETTLE
return T Xp(idp, p(cid:48), τres, τcom)

18 Function execute(in, T Xp, PoPp)
19

if status (cid:54)= SETTLE or verifyPoP(bcp, T Xp, PoPp) (cid:54)= 1 then

abort
¯PM ← /0
for xi, rx

i , si, rs

i in in.{x, rx, s, rs}
(xi, rx
pk.pki
(si, rs
i ) (cid:54)= PoPp.Csi then

if hash(EncT X i
or EncT X i

i )) (cid:54)= PoPp.T Xp.HCxi

pk.pki
¯PM ← ¯PM ∪ {Pi}

25

27

29

26

28

if | ¯PM| > 0 then
return ¯PM
status ← EXECUTE
s(cid:48), r ← evaluate F . f (x) based on s
bcp ← PoPp.getLastBlock()
,Cri ← Encpki (s(cid:48)
Cs(cid:48)
i
goto Dcomplete()
31
32 Function challenge( ¯PM)
33

i), Encpki (ri)

if status (cid:54)= SETTLE then abort
if | ¯PM| > 0 then

30

return T Xcha(idp, ¯PM)

36 Function punish(T Xcha, T Xres, PoPres)
37

if status (cid:54)= SETTLE or verifyPoP(bcp, T Xcha, PoPres) (cid:54)= 1

then abort
¯P(cid:48)
M ← /0
for Pi ∈ ¯PM do

res, PoPres) (cid:54)= 1

res.rx

i )) (cid:54)= PoPres.T Xp.HCxi

res.xi, T X i
res.rs

i )) (cid:54)= Csi then

if verifyPoP(bcp, T X i
or hash(Encpki (T X i
or Encpki (T X i
M ← ¯P(cid:48)
¯P(cid:48)
M| > 0 then
status ← ABORT
return T Xpns(idp, ¯PM)

res.si, T X i
M ∪ {Pi}

if | ¯P(cid:48)

47 Function complete()
48

if status (cid:54)= EXECUTE then abort
ˆHCx , ˆHCs , ˆHCs(cid:48) , ˆHCr ←
hash(Cx), hash(Cs), hash(Cs(cid:48) ), hash(Cr)
proo f ← (cid:104)HF , HP , ˆHCx , ˆHCs , ˆHCs(cid:48) , ˆHCr (cid:105)
status ← COMPLETE
return T Xcom(idp, proo f ,Cs,Cs(cid:48) ,Cr)

3

10

11

12

15

16

17

20

21

22

23

24

34

35

38

39

40

41

42

43

44

45

46

49

50

51

52

where idd is the identiﬁer of d. We deﬁne a complete set of
all sets consisting of Pd as PU .

P f = (cid:104)id f ,type f ,PX ,PR,PM,PO(cid:105) is the privacy policy
model of a function f , where type f ∈ {PUB, PRT, MPT},
and PX ,PR,PM,PO ∈ PU . Speciﬁcally, PX means parameter,
which includes function parameters with speciﬁed Pd; read,
the PR, records the Pd of state variables that the f needs for
execution; PM means mutate, which records the Pd of state
variables that the f will mutate; PO, which means return,
records the Pd of all return variables.

We model the privacy policy of a CLOAK smart contract
c as Pc = {PS,PF }, where PS ∈ PU and PF is a collection
of function privacy policy, i.e., PF = {P i
f |i = 1..n}. n is the
number of functions in c. Finally, Pc is what we called P in
our paper.

9.2.2 Private contract generation

To generate private contract F , CLOAK handles PUT, PRT,
and MPT transactions of a CLOAK smart contract in different
ways. First, CLOAK deletes all ownership annotations from
the CLOAK smart contract to get a pure Solidity smart con-
tract, which holds the computation logic of business without
considering privacy. Then, since users can send a PUT by
directly interacting with V on the blockchain, we delete the
PUT in the contract to get the private contract F .

9.2.3 Veriﬁer contract generation

CLOAK then generates a veriﬁer contract V . While leaving
the computation logic of PRT and MPT in F , CLOAK gen-
erates V to verify the PRT and MPT outputs and update the
state. Algorithm 3 shows the structure of V . V is constructed
by the address of TEE (adrE ) and hashes of P ,F . When
E seeks to complete the MPT by calling BC.CS.complete,
BC.CS.complete will ﬁrst call V .veri f y to check the valid-
ity of state transition, then update the state of V by calling
V .setNewStates.

9.3 Architecture Security

CLOAK aims to enable conﬁdential smart contracts with MPT
on any contract-enabled blockchain. Here, we analyze the
architecture security of CLOAK by considering its implemen-
tation. Possible adversaries can be malicious parties of MPT,
malicious executors, or a combination of both.

We note that parties of MPT are only required to send and
receive transactions from the blockchain and exchange pro-
tocol messages with the CLOAK Executor. Hence, although
we provide CLOAK Client to help parties follow our protocol,
parties can also implement the CLOAK Client by themselves
using a diverse set of entirely different code bases in prac-
tice, possibly using memory-safe languages such as Go and
Rust. Malicious parties are further limited to interacting with

17

tion. Although we take Solidity as a front-end language to
express private data and computation logic of MPT, the in-
sight behind CLOAK is essentially agnostic to language or
computation. Currently, CLOAK allows users to annotate the
data owner at where it was deﬁned. While it beneﬁts develop-
ers a lot in the intuitive expression of privacy requirements,
it also limits the expression ability to the language CLOAK
based. We note that for large data or complex data structures
which are not suitable to be stored on-chain, CLOAK can al-
low a developer to annotate the inputs’ commitments, such
as inputs hash, so that no matter what’s the data structure
or where the data is stored, it can be identiﬁed and used as
inputs to the MPT. As for more complex computation, a de-
veloper can just bind the code commitment (e.g., code hash)
on-chain, so that the code expressing complex computation
logic (e.g., AI training) by any language can be identiﬁed by
the commitment and executed in TEEs.
Toward low-cost layer-2 solutions. For simplicity, in this
paper, we indicate that each MPT executed by CLOAK Execu-
tor needs 2 transactions for committing MPT settings, inputs,
and the MPT results on-chain. Consequently, the gas cost
of an MPT only depends on how many parties it involved
and state variables it write. While CLOAK has guaranteed
advanced security of MPT, its gas cost can be further reduced.
For example, the more parties involved in an MPT, the lower
gas an T Xp costs against previous O(n) solutions. Moreover,
CLOAK Executor can cache many state transitions in TEE and
only update the ﬁnal new states to amortize the gas cost of a
single MPT. We can also develop more computation-intensive
MPT so that CLOAK can better take advantages of off-chain
execution of MPT and thus relatively reduce its on-chain cost.
Limitations of current implementation. For proof of con-
cept, we have not supported all the Solidity features, e.g.,
return statement in the middle of the function body, annota-
tion cross contract or library. These limits mainly affect the
development experience of developers. Developers have to
develop under limited language features or modify the audited
legacy code to meet CLOAK smart contract. We note that the
limits do not reduce the scientiﬁc advantage of our design and
the effectiveness of our experiment.

Algorithm 3: Veriﬁer contract (V )
// Generated by CL O A K

1 Function constructor(con f ig)

4

2

3

// contract creation by developer
HF ← con f ig.HF
HP ← con f ig.HP
adrE ← con f ig.adrE
5 Function getOldStates()
Cs ← current state
6
return Cs

7

8 Function setNewStates(Cs(cid:48) )

// indirectly called by T Xcom from CS
require(tx.origin = adrE )
current state ← Cs(cid:48)

11 Function verify(proo f ,Cx,Cs(cid:48) ,Cr)

// verify the proof of PRT/MPT
ˆHCs ← hash(V .getOldStates())
if proo f = (cid:104)HF , HP , ˆHCx , ˆHCs , ˆHCs(cid:48) , ˆHCr (cid:105) then

return true

return f alse

9

10

12

13

14

15

CLOAK Executor to proceed protocol, hence, we focus on the
CLOAK Executor in the following.

To prevent malicious CLOAK Executor from departing the
protocol, we assume that the goal of a malicious CLOAK Ex-
ecutor is to exploit the enclave program at runtime. Enclaves
have well-deﬁned program interfaces and any attack has to
be launched using these interfaces. A malicious CLOAK Ex-
ecutor can provide fake data through these interfaces to try
to exploit a memory-corruption vulnerability in the low-level
enclave code to launch (a) a code-reuse attack, e.g., by manip-
ulating enclave stack memory, or (b) a data-only attack, e.g.,
to leak information about private data of an MPT. For (a) we
assume a standard code-reuse defense such as control-ﬂow
integrity or ﬁne-grained code randomization. For (b) we stress
that the vulnerability leading to data leakages has been ﬁxed.
Although we prototype CLOAK Executor in C++, we note that
it’s easy to tackle both attack vectors by using memory-safety
languages, such as Python and Rust.

9.4 Discussion

Expanding annotations to meet real-world need. In cur-
rent syntax, the owner of private data is allowed to be {tee,
me, id}, each of which limits the owner to a speciﬁc account.
However, in the real world, the owner could be a group or
committee, which may have dynamic members. We can def-
initely expand the ownership annotation system to support
special owners. It’s also possible to allow an owner to transfer
his ownership to others, for which the CLOAK can match the
plaintext secret with on-chain ciphertext, encrypt the secret
with transferee’s public key and record the ownership transfer
event on-chain.
Expanding to multi-party privacy-preserved computa-

18

