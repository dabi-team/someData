How Does Blockchain Security Dictate Blockchain
Implementation?

Andrew Lewis-Pye
London School of Economics
a.lewis7@lse.ac.uk

Tim Roughgarden
Columbia University
tim.roughgarden@gmail.com

1
2
0
2

v
o
N
5

]

R
C
.
s
c
[

2
v
8
4
8
4
0
.
9
0
1
2
:
v
i
X
r
a

ABSTRACT
Blockchain protocols come with a variety of security guarantees.
For example, BFT-inspired protocols such as Algorand1 tend to be
secure in the partially synchronous setting, while longest chain
protocols like Bitcoin will normally require stronger synchronicity
to be secure. Another fundamental distinction, directly relevant to
scalability solutions such as sharding, is whether or not a single un-
trusted user is able to point to certiï¬cates, which provide incontro-
vertible proof of block conï¬rmation. Algorand produces such cer-
tiï¬cates, while Bitcoin does not. Are these properties accidental?
Or are they inherent consequences of the paradigm of protocol de-
sign? Our aim in this paper is to understand what, fundamentally,
governs the nature of security for permissionless blockchain pro-
tocols. Using the framework developed in [12], we prove general
results showing that these questions relate directly to properties of
the user selection process, i.e. the method (such as proof-of-work
or proof-of-stake) which is used to select users with the task of
updating state. Our results suï¬ƒce to establish, for example, that
the production of certiï¬cates is impossible for proof-of-work pro-
tocols, but is automatic for standard forms of proof-of-stake pro-
tocols. As a byproduct of our work, we also deï¬ne a number of
security notions and identify the equivalences and inequivalences
among them.

CCS CONCEPTS
â€¢ Computer systems organization â†’ Dependable and fault-
tolerant systems and networks.

KEYWORDS
blockchain; cryptocurrencies; proof-of-work; proof-of-stake; Byzan-
tine fault tolerant; longest-chain

ACM Reference Format:
Andrew Lewis-Pye and Tim Roughgarden. 2021. How Does Blockchain Se-
curity Dictate Blockchain Implementation? . In Proceedings of the 2021 ACM
SIGSAC Conference on Computer and Communications Security (CCS â€™21),
November 15â€“19, 2021, Virtual Event, Republic of Korea. ACM, New York,
NY, USA, 14 pages. https://doi.org/10.1145/3460120.3484752

1For an exposition of Algorand that explains how to achieve security in the partially
synchronous setting, see [7].

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proï¬t or commercial advantage and that copies bear this notice and the full cita-
tion on the ï¬rst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciï¬c permission
and/or a fee. Request permissions from permissions@acm.org.
CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea.
Â© 2021 Association for Computing Machinery.
ACM ISBN 978-1-4503-8454-4/21/11. . . $15.00
https://doi.org/10.1145/3460120.3484752

1 INTRODUCTION

Paradigms for blockchain protocol design. In the wake of Bitcoin
[14], thousands of cryptocurrencies have ï¬‚ooded the market. While
many of these currencies use only slight modiï¬cations of the Bit-
coin protocol, there are also a range of cryptocurrencies taking
radically diï¬€erent design approaches. Two informal distinctions
are between:

(1) Proof-of-stake (PoS)/proof-of-work (PoW). In a PoW proto-
col, users are selected and given the task of updating state,
with the probability any particular user is chosen being pro-
portional to their (relevant) computational power. In PoS
protocols, users are selected with probability depending on
their stake (owned currency).

(2) BFT2/longest-chain. As well as being a PoW protocol, Bit-
coin is the best known example of a longest chain proto-
col. This means that forks may occur in the blockchain, but
that honest miners will build on the longest chain. In a BFT
protocol, on the other hand, users are selected and asked
to carry out a consensus protocol designed for the permis-
sioned setting. So, roughly, longest chain protocols are those
which are derived from Bitcoin, while BFT protocols are de-
rived from protocols designed in the permissioned setting.
Algorand [8] is a well known example of a BFT protocol.

A formal framework for comparing design paradigms [12]. While
informal, these distinctions are more than aesthetic. For example,
BFT protocols like Algorand will tend to give security guarantees
that hold under signiï¬cantly weaker network connectivity assump-
tions than are required to give security for protocols like Bitcoin.
By developing an appropriate formal framework, it can then be
shown [12] that these diï¬€erences in security are a necessary con-
sequence of the paradigm of protocol design: The fact that Bitcoin
is a PoW protocol means that it cannot oï¬€er the same ï¬‚avour of
security guarantees as Algorand. A framework of this kind was de-
veloped in [12], according to which permissionless 3 protocols run
relative to a resource pool. This resource pool speciï¬es a balance
for each user over the duration of the protocol execution (such as
hashrate or stake), which may be used in determining which users
are permitted to update state. Within this framework, the idea that
protocols like Bitcoin require stronger connectivity assumptions
for security can be formalised as a theorem asserting that adaptive

2The acronym BFT stands for â€˜Byzantine-Fault-Tolerantâ€™.
3In the distributed computing literature, consensus protocols have traditionally been
studied in a setting where all participants are known to each other from the start of
the protocol execution. In the parlance of the blockchain literature, this is referred
to as the permissioned setting. What diï¬€erentiates Bitcoin [14] from these previously
studied protocols is that it operates in a permissionless setting, i.e. it is a protocol for
establishing consensus over an unknown network of participants that anybody can
join, with as many identities as they like in any role.

 
 
 
 
 
 
protocols cannot be partition secure â€“ these terms apply to permis-
sionless blockchain protocols and will be deï¬ned formally later on,
but, roughly, they can be summed up as follows:

â€¢ Liveness and security are deï¬ned in terms of a notion of con-
ï¬rmation for blocks. A protocol is live if the number of con-
ï¬rmed blocks can be relied on to increase during extended
intervals of time during which message delivery is reliable.
A protocol is secure if rollback on conï¬rmed blocks is un-
likely.

â€¢ Bitcoin being adaptive means that it remains live in the face
of an unpredictable size of resource pool (unpredictable lev-
els of mining).

â€¢ A protocol is partition secure if it is secure in the partially
synchronous setting, i.e. if the rollback of conï¬rmed blocks
remains unlikely even in the face of potentially unbounded
network partitions. The partially synchronous setting will
be further explained and formally deï¬ned in Section 2.

This paper: certiï¬cates. The way in which Algorand and other
BFT protocols achieve partition security is also worthy of note.
For all such protocols, protection against unbounded network par-
titions is provided through the production of certiï¬cates: These are
sets of broadcast messages whose very existence suï¬ƒces to estab-
lish block conï¬rmation and which cannot be produced by a (suit-
ably bounded) adversary given the entire duration of the execution
of the protocol. Bitcoin does not produce certiï¬cates, because the
existence of a certain chain does generally not prove that it is the
longest chain â€“ a user will only believe that a certain chain is the
longest chain until presented with a longer (possibly incompati-
ble) chain. Algorand does produce certiï¬cates, on the other hand,
because the very existence of a valid chain, together with appro-
priate committee signatures for all the blocks in the chain, suï¬ƒces
to guarantee (beyond a reasonable doubt) that the blocks in that
chain are conï¬rmed. We will formally deï¬ne what it means for a
protocol to produce certiï¬cates in Section 3.

The production of certiï¬cates is also functionally useful, beyond
providing security against network partitions. The production of
certiï¬cates means, for example, that a single untrusted user is able
to convince another user of block conï¬rmation (by relaying an ap-
propriate certiï¬cate), and this is potentially very useful in the con-
text of sharding. If a user wishes to learn the state of a blockchain
they were not previously monitoring, then it is no longer neces-
sary to perform an onboarding process in which one samples the
opinions of users until such a point that it is likely that at least one
of them was â€˜honestâ€™ â€“ one simply requests a certiï¬cate proving
conï¬rmation for a recently timestamped block.4

1.1 Overview of results.
The goal of this paper is to rigorously investigate to what extent
todayâ€™s protocols â€œhave to look the way they areâ€ given the secu-
rity guarantees they achieve. Such formal analyses are relevant to
the broader research community for several reasons, including: (i)
accurate intuitions of the community (e.g., that thereâ€™s fundamen-
tally only one way to achieve certain properties) can be formally
validated, with the necessary assumptions clearly spelled out; (ii)

4Such techniques can avoid the need to store block hashes in a sharding â€˜main chainâ€™,
and the information withholding attacks that come with those approaches.

inaccurate intuitions can be exposed as such; (iii) unexplored areas
of the protocol design space can naturally rise to the surface (e.g.,
Section 5.2); and (iv) new deï¬nitions (e.g., certiï¬cates) can enhance
our language for crisply describing and comparing competing solu-
tions (both present and future). In this paper, we prove three main
results, which each address this issue in a diï¬€erent setting.

The partially synchronous setting. The ï¬rst key question is:

Q1. Are certiï¬cates fundamental to partition security, or an ar-
tifact of Algorandâ€™s speciï¬c implementation? That is, are
certiï¬cates the only way for permissionless blockchain pro-
tocols to achieve security in the partially synchronous set-
ting?

Our ï¬rst main result, proved in the context of the framework of
[12], gives an aï¬ƒrmative response to Q1. Of course, all terms will
be explained and formally deï¬ned in later sections.

THEOREM 3.3. If a permissionless blockchain protocol is secure

in the partially synchronous setting, then it produces certiï¬cates.

Since it will be easily observed that the production of certiï¬cates
implies security, Theorem 3.3 shows that, in the partially synchro-
nous setting, the production of certiï¬cates is actually equivalent to
security.

The synchronous setting. What about Bitcoin? While Bitcoin
does not satisfy the conditions of Theorem 3.3, it clearly has some
non-trivial security. The standard formalisation in the literature
[10, 17] is that Bitcoin is secure in the synchronous setting, for
which there is an upper bound on message delivery time.5 Even
working in the synchronous setting, though, it is clear that Bitcoin
does not produce certiï¬cates. Again, we are led to ask whether this
is a necessary consequence of the paradigm of protocol design:

Q2. Could there be a Bitcoin-like protocol that, at least in the
synchronous setting, has as strong a security guarantee in
terms of the production of certiï¬cates as BFT-type protocols
do in the partially synchronous setting?

The answer depends on key features of the resource pool â€“ recall
that the resource pool speciï¬es a balance for each user over the
duration of the protocol execution, such as hashrate or stake. The
crucial distinction here is between scenarios in which the size of
the resource pool is known (e.g. PoS), and scenarios where the size
of the resource pool is unknown (e.g. PoW). As per the framework
in [12], we will refer to these as the sized and unsized settings,
respectively â€“ formal deï¬nitions will be given in Section 5. As al-
luded to above, we deï¬ne a protocol to be adaptive if it is is live in
the unsized setting, and it was shown in [12] that adaptive proto-
cols cannot be secure in the partially synchronous setting.

The synchronous and unsized setting. The term â€œnon-trivial
adversaryâ€, which is used in Theorem 5.1 below, will be deï¬ned
in Section 5 so as to formalise the idea that the adversary may
have at least a certain minimum resource balance throughout the
execution. With these basic deï¬nitions in place, we can then give
a negative answer to Q2.

5The synchronous setting will be further explained and formally deï¬ned in Section 2.

THEOREM 5.1 Consider the synchronous and unsized setting. If
a permissionless blockchain protocol is live then, in the presence of a
non-trivial adversary, it does not produce certiï¬cates.

So, while Theorem 3.3 showed that the production of certiï¬-
cates is necessary in the partially synchronous setting, Theorem
5.1 shows that the production of certiï¬cates isnâ€™t possible in the
unsized setting (in which PoW protocols like Bitcoin operate). Fol-
lowing on from our previous discussion regarding the relevance of
certiï¬cates to sharding, one direct application of this result is that
it rules out certain approaches to sharding for PoW protocols.

The synchronous and sized setting. In the sized setting (such
as for PoS protocols), though, it is certainly possible for protocols
to produce certiï¬cates. It therefore becomes a natural question to
ask how far we can push this:

Q3. Does the production of certiï¬cates come down purely to
properties of the process of user selection? Is it simply a
matter of whether one is in the sized or unsized setting?

Our ï¬nal theorem gives a form of positive response to Q3. We state
an informal version of the theorem below. A formal version will be
given in Section 5.

THEOREM 5.6 (INFORMAL VERSION). Consider the synchro-
nous and sized setting, and suppose a permissionless blockchain pro-
tocol is of â€˜standard formâ€™. Then there exists a â€˜recalibrationâ€™ of the
protocol which produces certiï¬cates.

Theorem 5.6 says, in particular, that all â€˜standardâ€™ PoS protocols
can be tweaked to get the strongest possible security guarantee,
since being of â€˜standard formâ€™ will entail satisfaction of a number
of conditions that are normal for such protocols. Roughly speak-
ing, one protocol will be considered to be a recalibration of an-
other if running the former just involves running the latter for
a computable transformation of the input parameters and/or us-
ing a diï¬€erent notion of block conï¬rmation. The example of Snow
White [3] may be instructive here (for the purposes of this example,
the particulars of the Snow White protocol are not important â€“ all
that matters is that, at a high level, Snow White might be seen as a
PoS version of Bitcoin, but with the fundamental diï¬€erences that it
operates in the sized setting, and that blocks have non-manipulable
timestamps). Snow White is a PoS longest chain protocol, and it is
not diï¬ƒcult to see that, with the standard notion of conï¬rmation,
it does not produce certiï¬cates â€“ an adversary can produce chains
of blocks which are not conï¬rmed, but which would be considered
conï¬rmed in the absence of other blocks which have been broad-
cast. So whether a block is conï¬rmed depends on the whole set of
broadcast messages. On the other hand, it is also not diï¬ƒcult to ad-
just the notion of conï¬rmation so that Snow White does produce
certiï¬cates. An example would be to consider a block conï¬rmed
when it belongs to a long chain of suï¬ƒcient density (meaning that
it has members corresponding to most possible timeslots) that it
could not likely be produced by a (suï¬ƒciently bounded) adversary.
We will see further examples like this explained in greater depth
in Section 5. Theorem 5.6 implies much more generally that PoS
protocols can always be modiï¬ed so as to produce certiï¬cates in
this way.

The punchline. Whether or not a permissionless blockchain pro-
tocol produces certiï¬cates comes down essentially to whether one
is working in the sized or unsized setting (e.g. whether the proto-
col is PoS or PoW). This follows from the following results that we
described above:

(i) According to the results of [12], only protocols which work
in the sized setting can be secure in the partially synchro-
nous setting. According to Theorem 3.3, all such protocols
produce certiï¬cates.

(ii) Theorem 5.1 tells us that, in the synchronous and unsized

setting, protocols cannot produce certiï¬cates.

(iii) Theorem 5.6 tells us that all standard protocols in the sized
and synchronous setting can be recalibrated to produce cer-
tiï¬cates.

1.2 Related work
There are a variety of papers from the distributed computing liter-
ature that analyse settings somewhere between the permissioned
and permissionless settings as considered here. In [15], for exam-
ple, Okun considered a setting which a ï¬xed number of processors
communicate by private channels, where each processor may or
may not have a unique identiï¬er, and where processors may or
may not be â€˜port awareâ€™, i.e. be able to tell which channel a mes-
sage arrives from. A number of papers [1, 6] have also considered
the problem of reaching consensus amongst unknown participants
(CUP). In the framework considered in those papers, the number
and the identiï¬ers of other participants may be unknown from the
start of the protocol execution. A fundamental diï¬€erence with the
permissionless setting considered here is that, in the CUP frame-
work, all participants have a unique identiï¬er and the adversary is
unable to obtain additional identiï¬ers to be able to launch a sybil
attack against the system, i.e. the number of identiï¬ers controlled
by the adversary is bounded.

The Bitcoin protocol was ï¬rst described in 2008 [14]. Since then,
a number of papers [10, 16] have developed frameworks for the
analysis of Bitcoin in which oracles are introduced for modelling
PoW. A more general form of oracle is required for modelling PoS
and other forms of permissionless protocol, however. In [12] a frame-
work was introduced that described a generalised form for such
oracles. We use that framework in this paper, but also develop that
framework in Sections 2.4, 2.5, 2.7, 2.8 and 4.3 to be appropriate
speciï¬cally for the analysis of blockchain protocols.

2 THE FRAMEWORK
We work within the framework of [12]. While we describe the
framework in its entirety here, we refer the reader to the the origi-
nal paper for further examples and explanations of the framework
set-up. Within Section 2, it is the deï¬nitions of Sections 2.4, 2.5, 2.7
and 2.8 that are new to this paper (all deï¬nitions of Sections 3, 4
and 5 are also new to this paper).

Most of this section can be brieï¬‚y summed up as follows â€“ all
undeï¬ned terms in the below will be formalised and deï¬ned in
later subsections.

â€¢ Protocols are executed by an unknown number of users,
each of which is formalised as a deterministic processor that
controls a set of public keys.

â€¢ Processors have the ability to broadcast messages to all other
processors. The duration of the execution, however, may be
divided into synchronous or asynchronous intervals. During
asynchronous intervals, an adversary can tamper with mes-
sage delivery as they choose. During synchronous intervals
there is a given upper bound on message delivery time. We
then distinguish two synchronicity settings. In the synchro-
nous setting it is assumed that there are no asynchronous in-
tervals, while in the partially synchronous setting there may
be unpredictably long asynchronous intervals.

â€¢ Amongst all broadcast messages, there is a distinguished set
referred to as blocks, and one block which is referred to as
the genesis block. Unless it is the genesis block, each block
ğµ has a unique parent block.

â€¢ To blackbox the process of user selection, whereby certain
users are selected and given the task of updating state, [12]
introduces two new notions: (1) Each public key is consid-
ered to have a certain resource balance, which may vary over
the execution, and; (2) The protocol will also be run relative
to a permitter oracle, which may respond to this resource bal-
ance. For a PoW protocol like Bitcoin, the resource balance
of each public key will be their (relevant) computational
power at the given timeslot.

â€¢ It is the permitter oracle which then gives permission to
broadcast messages updating state. To model Bitcoin, for ex-
ample, we sometimes have the permitter allow another user
to broadcast a new block, with the probability this happens
for each user being proportional to their resource balance.
â€¢ Liveness and security are deï¬ned in terms of a notion of con-
ï¬rmation for blocks. Roughly, a protocol is live if the number
of conï¬rmed blocks can be relied on to increase during ex-
tended intervals of time during which message delivery is
reliable. A protocol is secure if rollback on conï¬rmed blocks
is unlikely.

2.1 The computational model
Overview. There are a number of papers analysing Bitcoin [10, 16]
that take the approach of working within the language of the UC
framework of Canetti [5]. Our position is that this provides a sub-
stantial barrier to entry for researchers in blockchain who do not
have a strong background in security, and that the power of the
UC framework remains essentially unused in the subsequent anal-
ysis. Instead, we use a very simple computational model, which
is designed to be as similar as possible to standard models from
distributed computing (e.g. [9]), while also being adapted to deal
with the permissionless setting. We thus consider an information
theoretic model in which processors are simply speciï¬ed by state
transition diagrams. A permitter oracle is introduced as a generali-
sation of the random oracle functionality in the Bitcoin Backbone
paper [10]: It is the permitter oracleâ€™s role to grant permissions to
broadcast messages. The duration of the execution is divided into
timeslots. Each processor enters each timeslot ğ‘¡ in a given state ğ‘¥,
which determines the instructions for the processor in that times-
lot â€“ those instructions may involve broadcasting messages, as well

as sending requests to the permitter oracle. The state ğ‘¥ â€² of the pro-
cessor at the next timeslot is determined by the state ğ‘¥, together
with the messages and permissions received at ğ‘¡.

Since we focus on impossibility results, we simplify the presen-
tation by making the assumption that we are always working in
the authenticated setting, in which processors have access to pub-
lic/private key pairs. This assumption is made purely for the sake
of simplicity, and the results of the paper do not depend upon it.

Formal description. For a list of commonly used variables and
terms, see Table 1 in the appendix. We consider a ï¬nite6 system
of processors. Each processor ğ‘ is speciï¬ed by a state transition dia-
gram, for which the number of states may be inï¬nite. Amongst the
states of a processor are a non-empty set of possible initial states.
The inputs to ğ‘ determine which initial state it starts in. If a vari-
able is speciï¬ed as an input to ğ‘, then we refer to it as determined
for ğ‘, referring to the variable as undetermined for ğ‘ otherwise.
If a variable is determined/undetermined for all ğ‘, we simply re-
fer to it as determined/undetermined. Amongst the inputs to ğ‘ is
an inï¬nite set Uğ‘ of public keys, which are speciï¬c to ğ‘ in the
sense that if U âˆˆ Uğ‘ and Uâ€² âˆˆ Uğ‘â€² then U â‰  Uâ€² when ğ‘ â‰  ğ‘ â€².
A principal diï¬€erence between the permissionless setting (as con-
sidered here) and the permissioned setting (as studied in classical
distributed computing) is that, in the permissionless setting, the
number of processors is undetermined, and Uğ‘ is undetermined
for ğ‘ â€² when ğ‘ â€² â‰  ğ‘.

Processors are able to broadcast messages. To model permission-
less protocols, such as Bitcoin, in which each processor has limited
ability to broadcast new blocks (and possibly other messages), we
require any message broadcast by ğ‘ to be permitted for some public
key in Uğ‘ : The precise details are as follows. We consider a real-
time clock, which exists outside the system and measures time in
natural number timeslots. The duration D is a determined variable
that speciï¬es the set of timeslots (an initial segment of the natu-
ral numbers) at which processors carry out instructions. At each
timeslot ğ‘¡, each processor ğ‘ receives a pair (ğ‘€, ğ‘ƒ), where either or
both of ğ‘€ and ğ‘ƒ may be empty. Here, ğ‘€ is a ï¬nite set of messages
(i.e. strings) that have previously been broadcast by other proces-
sors. We refer to ğ‘€ as the message set received by ğ‘ at ğ‘¡, and say
that each message ğ‘š âˆˆ ğ‘€ is received by ğ‘ at timeslot ğ‘¡. ğ‘ƒ is referred
to as the permission set received by ğ‘ at ğ‘¡. Formally, ğ‘ƒ is a set of
pairs, where each pair is of the form (U, ğ‘€âˆ—) such that U âˆˆ Uğ‘ and
ğ‘€âˆ— is a potentially inï¬nite set of messages. If (U, ğ‘€âˆ—) âˆˆ ğ‘ƒ, then re-
ceipt of the permission set ğ‘ƒ means that each message ğ‘š âˆˆ ğ‘€âˆ— may
now be permitted for U. This is complicated slightly by our need
to model the authenticated setting within an information theoretic
model â€“ we do this by declaring that only ğ‘ is permitted to broad-
cast messages signed by keys in Uğ‘ . More precisely, ğ‘š âˆˆ ğ‘€âˆ— is
permitted for U if the following conditions are also satisï¬ed:

â€¢ ğ‘š is of the form (U, ğœ) â€“ thought of as â€˜the message ğœ signed

by Uâ€™.

6In [12], a potentially inï¬nite number of processors were allowed, but each processor
was given a single public key (identiï¬er). Here, we will ï¬nd it convenient to consider
instead a ï¬nite number of processors, each of which may control an unbounded num-
ber of public keys.

â€¢ For any ordered pair of the form (Uâ€², ğœ â€²) contained in (i.e.
which is a substring of) ğœ, either Uâ€² âˆˆ Uğ‘ , or else (Uâ€², ğœ â€²) is
contained in a message that has been received by ğ‘.

So, as suggested in the above, the latter bulleted conditions allow
us to model the fact that we work in the authenticated setting (i.e.
we assume the use of digital signatures) within an information the-
oretic computational model.

To complete the instructions for timeslot ğ‘¡, ğ‘ then broadcasts
a ï¬nite set of messages ğ‘€ â€², each of which must be permitted for
some U âˆˆ Uğ‘ , makes a request set ğ‘…, and then enters a new state
ğ‘¥ â€², where ğ‘¥ â€², ğ‘€ â€² and ğ‘… are determined by the present state ğ‘¥ and
(ğ‘€, ğ‘ƒ), according to the state transition diagram. The form of the
request set ğ‘… will be described shortly, together with how ğ‘… deter-
mines the permission set received at by ğ‘ at the next timeslot.

An execution is described by specifying the set of processors, the
duration, the initial states for all processors and by specifying, for
each timeslot ğ‘¡ â‰¥ 1:

(1) The messages and permission sets received by each proces-

sor;

(2) The instruction that each processor executes, i.e. what mes-
sages it broadcasts, what requests it makes, and the new
state it enters.

We require that each message is received by ğ‘ at most once
for each time it is broadcast, i.e. at the end of the execution it
must be possible to specify an injective function ğ‘‘ğ‘ mapping each
pair (ğ‘š, ğ‘¡), such that ğ‘š is received by ğ‘ at timeslot ğ‘¡, to a triple
(ğ‘ â€², ğ‘š, ğ‘¡ â€²), such that ğ‘¡ â€² < ğ‘¡, ğ‘ â€² â‰  ğ‘ and such that ğ‘ â€² broadcast ğ‘š at
ğ‘¡ â€².

2.2 The resource pool and the permitter
Informal Motivation. Who should be allowed to create and broad-
cast new Bitcoin blocks? More broadly, when deï¬ning a permis-
sionless protocol, who should be able to broadcast new messages?
For a PoW protocol, the selection is made depending on compu-
tational power. PoS protocols are deï¬ned in the context of speci-
fying how to run a currency, and select public keys according to
their stake in the given currency. More generally, one may consider
a scarce resource, and then select public keys according to their
corresponding resource balance. In [12], a framework was intro-
duced according to which protocols run relative to a resource pool,
which speciï¬es a resource balance for each public key over the
duration of the execution. The precise way in which the resource
pool is used to determine public key selection is then black boxed
through the use of the permitter oracle, to which processors can
make requests to broadcast, and which will respond depending on
their resource balance. To model Bitcoin, for example, one simply
allows each public key to make one request to broadcast a block at
each timeslot. The permitter oracle then gives a positive response
with probability depending on their resource balance, which in this
case is deï¬ned by hashrate. So, this gives a straightforward way to
model the process, without the need for a detailed discussion of
hash functions and how they are used to instantiate the selection
process.

the message state of ğ‘. Each execution happens relative to a (deter-
mined or undetermined) resource pool,7 which in the general case
is a function R : U Ã— D Ã— M â†’ Râ‰¥0, where U is the set of
all public keys, D is the duration and M is the set of all possible
sets of messages. R can be thought of as specifying the resource
balance of each public key at each timeslot, possibly relative to a
given message state. For each ğ‘¡ and ğ‘€, we suppose that certain
basic conditions are satisï¬ed:

Ã

U R (U, ğ‘¡, ğ‘€) > 0.

(a) If R (U, ğ‘¡, ğ‘€) â‰  0 then U âˆˆ Uğ‘ for some processor ğ‘;
(b) There are ï¬nitely many U for which R (U, ğ‘¡, ğ‘€) â‰  0, and;
(c)
Suppose that, after receiving messages and a permission set at
timeslot ğ‘¡, ğ‘â€™s message state is ğ‘€0, and that ğ‘€âˆ—
0 is the set of all
messages that are permitted for ğ‘ (i.e. for some U âˆˆ Uğ‘ ). We con-
sider two settings â€“ the timed and untimed settings. The form of
each request ğ‘Ÿ âˆˆ ğ‘… made by ğ‘ at timeslot ğ‘¡ depends on the setting,
as speciï¬ed below. While the following deï¬nitions might initially
seem abstract, shortly we will give examples to make things clear.
â€¢ The untimed setting. Here, each request ğ‘Ÿ made by ğ‘ must
be of the form (U, ğ‘€, ğ´), where U âˆˆ Uğ‘ , ğ‘€ âŠ† ğ‘€0 âˆª ğ‘€âˆ—
0 , and
where ğ´ is some (possibly empty) extra data. The permitter
oracle will respond with a pair (U, ğ‘€âˆ—), where ğ‘€âˆ— is a set
of strings that may be empty. The value of ğ‘€âˆ— will be as-
sumed to be a probabilistic function of the determined vari-
ables, (U, ğ‘€, ğ´), and of R (U, ğ‘¡, ğ‘€), subject to the condition
that ğ‘€âˆ— = âˆ… if R (U, ğ‘¡, ğ‘€) = 0. If modelling Bitcoin, for ex-
ample, ğ‘€ might be a set of blocks that have been received by
ğ‘, or that ğ‘ is already permitted to broadcast, while ğ´ spec-
iï¬es a new block extending the â€˜longest chainâ€™ in ğ‘€. If the
block is valid, then the permitter oracle will give permission
to broadcast it with probability depending on the resource
balance of U at time ğ‘¡. We will expand on this example below.
â€¢ The timed setting. Here, each request ğ‘Ÿ made by ğ‘ must be
of the form (ğ‘¡ â€², U, ğ‘€, ğ´), where ğ‘¡ â€² is a timeslot, and where U,
ğ‘€ and ğ´ are as in the untimed setting, The response (U, ğ‘€âˆ—)
of the permitter oracle will be assumed to be a probabilis-
tic function of the determined variables, (ğ‘¡ â€², U, ğ‘€, ğ´), and of
R (U, ğ‘¡ â€², ğ‘€), subject to the condition that ğ‘€âˆ— = âˆ… if R (U, ğ‘¡ â€², ğ‘€) =
0.

The permission set received by ğ‘ at timeslot ğ‘¡ + 1 is the set all of
responses from the permitter oracle to ğ‘â€™s requests at timeslot ğ‘¡.

To understand these deï¬nitions, it is instructive to consider how
they can be used to give a simple model for Bitcoin. To do so, we
work in the untimed setting, and we deï¬ne the set of possible mes-
sages to be the set of possible blocks. For each U âˆˆ Uğ‘ , we then
allow ğ‘ to make a single request of the form (U, ğ‘€, ğ´) at each times-
lot. As mentioned above, ğ‘€ will be a set of blocks that have been
received by ğ‘, or that ğ‘ is already permitted to broadcast. The entry
ğ´ will be data (without PoW attached) that speciï¬es a block extend-
ing the â€˜longest chainâ€™ in ğ‘€. If ğ´ speciï¬es a valid block, then the
permitter oracle will give permission to broadcast the block spec-
iï¬ed by ğ´ with probability depending on the resource balance of
U at time ğ‘¡ (which is determined by hashrate, and is independent
of ğ‘€). So, the higher Uâ€™s resource balance at a given timeslot, the

Formal speciï¬cation. At each timeslot ğ‘¡, we refer to the set of
all messages that have already been received or broadcast by ğ‘ as

7As described more precisely in Section 2.6, whether the resource pool is determined
or undetermined will decide whether we are in the sized or unsized setting.

greater the probability ğ‘ will be able to mine a block at that times-
lot. Of course, a non-faulty processor ğ‘ will always submit requests
of the form (U, ğ‘€, ğ´), for which ğ‘€ is ğ‘â€™s (entire) message state, and
such that ğ´ speciï¬es a valid block extending the longest chain in
ğ‘€.8

The motivation for considering the timed as well as the untimed
setting stems from one of the qualitative diï¬€erences between PoS
and PoW protocols. PoS protocols are best modelled in the timed
setting, where processors can look ahead to determine their per-
mission to broadcast at future timeslots (when their resource bal-
ance may be diï¬€erent than it is at present), i.e. with PoS protocols,
blocks will often have timestamps that cannot be manipulated, and
at a given timeslot, a processor may already be able to determine
that they have permission to broadcast blocks with a number of
diï¬€erent future timestamps. This means that, when modelling PoS
protocols, processors have to be able to make requests correspond-
ing to timeslots ğ‘¡ â€² other than the current timeslot ğ‘¡. We will specify
further diï¬€erences between the timed and untimed settings in Sec-
tion 2.6.

By a permissionless protocol we mean a pair (S, O), where S is
a state transition diagram to be followed by all non-faulty proces-
sors, and where O is a permitter oracle, i.e. a probabilistic function
of the form described for the timed and untimed settings above. It
should be noted that the roles of the resource pool and the permit-
ter oracle are diï¬€erent, in the following sense: While the resource
pool is a variable (meaning that a given protocol will be expected
to function with respect to all possible resource pools consistent
with the setting9), the permitter is part of the protocol description.

2.3 The adversary and the synchronous and

partially synchronous settings

While all non-faulty processors follow the state transition diagram
S speciï¬ed for the protocol, we allow a single undetermined pro-
cessor ğ‘ğ´ to display Byzantine faults, and we think of ğ‘ğ´ as be-
ing controlled by the adversary: In formal terms, the diï¬€erence be-
tween ğ‘ğ´ and other processors is that the state transition diagram
for ğ‘ğ´ might not be S. Placing bounds on the power of the adver-
sary means limiting their resource balance (since Uğ‘ğ´ is inï¬nite,
it does not limit the adversary that they control a single processor).
For ğ‘ âˆˆ [0, 1], we say the adversary is ğ‘-bounded if their total re-
source balance is always at most a ğ‘ fraction of the total, i.e. for all
ğ‘€, ğ‘¡,

R (U, ğ‘¡, ğ‘€) â‰¤ ğ‘ Â·

UâˆˆU R (U, ğ‘¡, ğ‘€).

It is standard in the distributed computing literature [13] to con-
sider a variety of synchronous, partially synchronous, or asynchro-
nous settings, in which message delivery might be reliable or sub-
ject to various forms of failure. We will suppose that the dura-
tion is divided into intervals that are labelled either synchronous
or asynchronous (meaning that each timeslot is either synchronous

UâˆˆUğ‘ğ´

Ã

Ã

or asynchronous). We will suppose that during asynchronous in-
tervals messages can be arbitrarily delayed or not delivered at all.
During synchronous intervals, however, we will suppose that mes-
sages are always delivered within Î” many timeslots. So if ğ‘¡1 â‰¤ ğ‘¡2,
ğ‘š is broadcast by ğ‘ at ğ‘¡1, if ğ‘ â€² â‰  ğ‘ and [ğ‘¡2, ğ‘¡2 + Î”] is a synchronous
interval contained in D, then ğ‘ â€² will receive ğ‘š by timeslot ğ‘¡2 + Î”.
Here Î” is a determined variable.

We then distinguish two synchronicity settings. In the synchro-
nous setting it is assumed that there are no asynchronous inter-
vals during the duration, while in the partially synchronous setting
there may be undetermined asynchronous intervals.

It will be useful to consider the notion of a timing rule, by which
we mean a partial function T mapping tuples of the form (ğ‘, ğ‘ â€², ğ‘š, ğ‘¡)
to timeslots. We say that an execution follows the timing rule T if
the following holds for all processors ğ‘ and ğ‘ â€²: We have that ğ‘ â€²
receives ğ‘š at ğ‘¡ â€² iï¬€ there exists some ğ‘ and ğ‘¡ < ğ‘¡ â€² such that ğ‘ broad-
casts the message ğ‘š at ğ‘¡ and T(ğ‘, ğ‘ â€², ğ‘š, ğ‘¡) â†“= ğ‘¡ â€². We restrict atten-
tion to timing rules which are consistent with the setting. Since
protocols will be expected to behave well with respect to all tim-
ing rules consistent with the setting, it will sometimes be useful
to think of the adversary as also having control over the choice of
timing rule.

2.4 The structure of the blockchain
Amongst all broadcast messages, there is a distinguished set re-
ferred to as blocks, and one block which is referred to as the gene-
sis block. Unless it is the genesis block, each block ğµ has a unique
parent block Par(ğµ), which must be uniquely speciï¬ed within the
block message. Each block is signed and broadcast by a single key,
Miner(ğµ), but may contain other broadcast messages which have
been signed and broadcast by other keys. No block can be broad-
cast by the processor ğ‘ that controls Miner(ğµ) at a point strictly
prior to that at which its parent enters ğ‘â€™s message state (it is conve-
nient to consider the genesis block a member of all message states
at all timeslots). Par(ğµ) is deï¬ned to be an ancestor of ğµ, and all
of the ancestors of Par(ğµ) are also deï¬ned to be ancestors of ğµ. If
ğµ is not the genesis block, then it must have the genesis block as
an ancestor. At any point during the duration, the set of broadcast
blocks thus forms a tree structure. If ğ‘€ is a set of messages, then
we say that it is downward closed if it contains the parents of all
blocks in ğ‘€. By a leaf of ğ‘€, we mean a block in ğ‘€ which is not
a parent of any block in ğ‘€. If ğ‘€ is downward closed set of blocks
and contains a single leaf, then we say that ğ‘€ is a chain.

Generalising the model to DAGs. It is only for the sake of
simplicity that we assume each block has a unique parent block.
The model is chosen to be a sweet spot of being expressible enough
to capture many diï¬€erent types of blockchains and not so cumber-
some as to obscure the main issues. Only small modiï¬cations are
then required to deal with DAGS etc.

8So, in this simple model, we donâ€™t deal with any notion of a â€˜transactionâ€™. It is clear,
though, that the model is suï¬ƒcient to be able to deï¬ne what it means for blocks to be
conï¬rmed, to deï¬ne notions of liveness (roughly, that the set of conï¬rmed blocks grows
over time with high probability) and security (roughly, that with high probability, the
set of conï¬rmed blocks is monotonically increasing over time), and to prove liveness
and security for the Bitcoin protocol in this model (by importing existing proofs, such
as that in [10]).
9Generally, protocols will be considered in a setting that restricts the set of resource
pools in certain ways, such as limiting the resource balance of the adversary.

2.5 The extended protocol and the meaning of

probabilistic statements

To deï¬ne what it means for a protocol to be secure or live, we
ï¬rst need a notion of conï¬rmation for blocks. This is a function
C mapping any message state to a chain that is a subset of that
message state, in a manner that depends on the protocol inputs,

including a parameter ğœ€ > 0 called the security parameter. The
intuition behind ğœ€ is that it should upper bound the probability of
false conï¬rmation. Given any message state, C returns the set of
conï¬rmed blocks.

In Section 2.2, we stipulated that a permissionless protocol is a
pair P = (S, O). In general, however, a protocol might only be con-
sidered to run relative to a speciï¬c notion of conï¬rmation C. We
will refer to the triple (S, O, C) as the extended protocol. Often we
will suppress explicit mention of C, and assume it to be implicitly
attached to a given protocol. We will talk about a protocol being
live, for example, when it is really the extended protocol to which
the deï¬nition applies. It is important to understand, however, that
the notion of conï¬rmation C is separate from P, and does not im-
pact the instructions of the protocol. In principle, one can run the
same Bitcoin protocol relative to a range of diï¬€erent notions of
conï¬rmation. While the set of conï¬rmed blocks might depend on
C, the instructions of the protocol do not, i.e. with Bitcoin, one can
require ï¬ve blocks for conï¬rmation or ten, but this does not aï¬€ect
the process of building the blockchain.

For a given permissionless protocol, another way to completely
specify an execution (beyond that described in Section 2.1) is via
the following breakdown:

(I1) The determined variables (such as Î” and ğœ€);
(I2) The set of processors and their public keys;
(I3) The state transition diagram for the adversary ğ‘ğ´;
(I4) The resource pool (which may or may not be undetermined);
(I5) The timing rule;
(I6) The probabilistic responses of the permitter.
With respect to the extended protocol (S, O, C), we call a partic-
ular set of choices for (I1)- (I5) a protocol instance. Generally, when
we discuss an extended protocol, we do so within the context of a
setting, which constrains the set of possible protocol instances. The
setting might restrict the set of resource pools to those in which the
adversary is given a limited resource balance, for example. When
we make a probabilistic statement to the eï¬€ect that a certain condi-
tion holds with at most/least a certain probability, this means that
the probabilisitic bound holds for all protocol instances consistent
with the setting. Where convenient, we may also refer to the pair
(P, C) as the extended protocol, where P = (S, O).

2.6 Deï¬ning the timed, sized and
multi-permitter settings

In Section 2.2, we gave an example to show how the framework
of [12] can be used to model a PoW protocol like Bitcoin. In that
context the resource pool is a function R : U Ã— D â†’ Râ‰¥0, which
is best modelled as undetermined, because one does not know in
advance how the hashrate of each public key (or even the total
hashrate) will vary over time. The ï¬rst major diï¬€erence for a PoS
protocol is that the resource balance of each public key now de-
pends on the message state (as is also the case for some proof-
of-space protocols, depending on the implementation), and may
also be a function of time.10 So the resource pool is a function

10It is standard practice in PoS blockchain protocols to require a participant to have
a currency balance that has been recorded in the blockchain for at least a certain
minimum amount of time before they can produce new blocks, for example. So, a

R : U Ã— D Ã— M â†’ Râ‰¥0. A second diï¬€erence is that R is deter-
mined, because one knows from the start how the resource balance
of each participant depends on the message state as a function of
time. Note that advance knowledge of R does not mean that one
knows from the start which processors will have large resource
balances throughout the execution, unless one knows which mes-
sages will be broadcast. A third diï¬€erence, to which we have al-
ready alluded, is that PoS protocols are best modelled in the timed
setting. A fourth diï¬€erence is that PoW protocols are best mod-
elled by allowing a single request to the oracle for each public key
at each timeslot, while this is not necessarily true of PoS protocols.

In [12], the sized/unsized, timed/untimed, and single/multi-permitter

settings were deï¬ned to succinctly capture these diï¬€erences. The
idea is that all permissionless protocols run relative to a resource
pool and the diï¬€erence between PoW and PoS and other permis-
sionless protocols is whether we are working in the sized/unsized,
timed/untimed, and single/multi-permitter settings. If one then comes
to consider a new form of protocol, such as proof-of-space, theo-
rems that have been proved for all protocols in the unsized setting
(for example) will still apply, so long as these new protocols are ap-
propriately modelled in that setting. So the point of this approach
is that, by blackboxing the precise mechanics of the processor se-
lection process (whereby processors are selected to do things like
broadcast new blocks of transactions), we are able to focus instead
on properties of the selection process that are relevant for protocol
design. This allows for the development of a general theory that
succinctly describes the relevant merits of diï¬€erent forms of proto-
col. The sized/unsized, timed/untimed, and single/multi-permitter
settings are deï¬ned below.

(1) The timed and untimed settings. There are two diï¬€er-
ences between the timed and untimed settings. The ï¬rst
concerns the form of requests, as detailed in Section 2.2. We
also require that the following holds in the timed setting: For
each broadcast message ğ‘š, there exists a unique timeslot ğ‘¡ğ‘š
such that permission to broadcast ğ‘š was given in response
to some request (ğ‘¡ğ‘š, U, ğ‘€, ğ´), and ğ‘¡ğ‘š is computable from ğ‘š.
We call ğ‘¡ğ‘š the timestamp of ğ‘š.

(2) The sized and unsized settings. We call the setting sized
if the resource balance is determined. By the total resource
balance we mean the function T : N Ã— M â†’ R>0 deï¬ned
ÃU R (U, ğ‘¡, ğ‘€). For the unsized setting, R and
by T (ğ‘¡, ğ‘€) :=
T are undetermined, with the only restrictions being:
(i) T only takes values in a determined interval [ğ›¼0, ğ›¼1], where
ğ›¼0 > 0 (meaning that, although ğ›¼0 and ğ›¼1 are determined,
protocols will be required to function for all possible ğ›¼0 >
0 and ğ›¼1 > ğ›¼0, and for all undetermined R consistent with
ğ›¼0, ğ›¼1, subject to (ii) below).11

(ii) There may also be bounds placed on the resource balance

of public keys owned by the adversary.

given participant may not be permitted to extend a given chain of blocks at timeslot
ğ‘¡, but may be permitted to extend the same chain at a later timeslot ğ‘¡ â€².
11We consider resource pools with range restricted in this way, because it turns out
to be an overly strong condition to require a protocol to function without any further
conditions on the resource pool, beyond the fact that it is a function to Râ‰¥0. Bitcoin
will certainly fail if the total resource balance decreases suï¬ƒciently quickly over time,
or if it increases too quickly, causing blocks to be produced too quickly compared to
Î”.

(3) The multi-permitter and single-permitter settings. In
the single-permitter setting, each processor may submit a
single request of the form (U, ğ‘€, ğ´) or (ğ‘¡, U, ğ‘€, ğ´) (depend-
ing on whether we are in the timed setting or not) for each
U âˆˆ Uğ‘ at each timeslot, and it is allowed that ğ´ â‰  âˆ…. In the
multi-permitter setting, processors can submit any number
of requests for each key at each timeslot, but they must all
satisfy the condition that ğ´ = âˆ….

PoW protocols will generally be best modelled in the untimed,
unsized and single-permitter settings. They are best modelled in
the untimed setting, because a processorâ€™s probability of being granted
permission to broadcast a block at timeslot ğ‘¡ (even if that block
has a diï¬€erent timestamp) depends on their resource balance at ğ‘¡,
rather than at any other timeslot. They are best modelled in the
unsized setting, because one does not know in advance of the pro-
tocol execution the amount of mining which will take place at a
given timeslot in the future. They are best modelled in the single-
permitter setting, so long as permission to broadcast is block-speciï¬c.
PoS protocols are generally best modelled in the timed, sized
and multi-permitter settings. They are best modelled in the timed
setting, because blocks will generally have non-manipulable times-
tamps, and because a processorâ€™s ability to broadcast a block may
be determined at a timestamp ğ‘¡ even through the probability of
success depends on their resource balance at ğ‘¡ â€² other than ğ‘¡. They
are best modelled in the sized setting, because the resource pool
is known from the start of the protocol execution. They are best
modelled in the multi-permitter setting, so long as permission to
broadcast is not block-speciï¬c, i.e. when permission is granted, it
is to broadcast a range of permissible blocks at a given position in
the blockchain.

All of this means that it will generally be straightforward to clas-
sify protocols with respect to the theorems from this paper that ap-
ply to them. Since Bitcoin and Prism [2] are PoW protocols, for ex-
ample, Theorem 5.1 applies to those protocols. Since Snow White,
Ouroboros [11] and Algorand are PoS protocols, Theorems 3.3 and
5.6 apply to those protocols. Note that there are a large number
of protocols, such as Tendermint [4] and Hotstuï¬€ [18], which are
formally described as permissioned protocols, but which can be im-
plemented as PoS protocols so that Theorems 3.3 and 5.6 will then
apply.

2.7 Deï¬ning liveness
There are a number of papers that successfully describe liveness
and security notions for blockchain protocols [10, 16]. Our interest
here is in identifying the simplest deï¬nitions that suï¬ƒce to express
our later results. To this end, it will be convenient to give a deï¬ni-
tion of liveness that is more ï¬ne-grained than previous deï¬nitions,
in the sense that it allows us to separate out the security parameter
and the number of timeslots in the duration (in previous accounts
the number of timeslots in the duration is a function of the secu-
rity parameter). Consider a protocol with a notion of conï¬rmation
C, and let |C(ğ‘€)| denote the number of blocks in C(ğ‘€) for any mes-
sage state ğ‘€. For timeslots ğ‘¡1 < ğ‘¡2, let ğ‘™1 be the maximum value
|C(ğ‘€1)| for any ğ‘€1 which is a message state of any processor at
any timeslot ğ‘¡ â‰¤ ğ‘¡1, and let ğ‘™2 be the minimum value |C(ğ‘€2)| for
any ğ‘€2 which is a message state of any processor at timeslot ğ‘¡2.

We say that [ğ‘¡1, ğ‘¡2] is a growth interval if ğ‘™2 > ğ‘™1. For any duration
D, let |D| be the number of timeslots in D. For â„“ğœ€,D which takes
values in N depending on ğœ€ and D, let us say that â„“ğœ€,D is sublin-
ear in D if, for each ğœ€ > 0 and each ğ›¼ âˆˆ (0, 1), â„“ğœ€,D < ğ›¼ |D| for
all suï¬ƒciently large values of |D| (the motivation for considering
sublinearity will be described shortly).

Deï¬nition 2.1. A protocol is live if, for every choice of security
parameter ğœ€ > 0 and duration D, there exists â„“ğœ€,D, which is sublin-
ear in D, and such that for each pair of timeslots ğ‘¡1 < ğ‘¡2 âˆˆ D the
following holds with probability at least 1 âˆ’ ğœ€: If ğ‘¡2 âˆ’ ğ‘¡1 â‰¥ â„“ğœ€,D and
[ğ‘¡1, ğ‘¡2] is entirely synchronous, then [ğ‘¡1, ğ‘¡2] is a growth interval.

So, roughly speaking, a protocol is live if the number of conï¬rmed
blocks can be relied on to grow during synchronous intervals of
suï¬ƒcient length. The reason we require â„“ğœ€,D to be sublinear in D
is so that the number of conï¬rmed blocks likely increases with suf-
ï¬cient increase in synchronous duration. For example, a protocol
that conï¬rms a block with probability only 2âˆ’ | D | at each timeslot
should not be considered live. Note also, that while Deï¬nition 2.1
only refers explicitly to protocols, it is really the extended protocol
to which the deï¬nition applies. The following stronger notion will
also be useful.

Deï¬nition 2.2. A protocol is uniformly live if, for every choice
of security parameter ğœ€ > 0 and duration D, there exists â„“ğœ€,D,
which is sublinear in D, and such that the following holds with
probability at least 1 âˆ’ ğœ€: For all pairs of timeslots ğ‘¡1 < ğ‘¡2 âˆˆ D, if
ğ‘¡2 âˆ’ ğ‘¡1 â‰¥ â„“ğœ€,D and [ğ‘¡1, ğ‘¡2] is entirely synchronous, then [ğ‘¡1, ğ‘¡2] is a
growth interval.

The diï¬€erence between being live and uniformly live is that the
latter deï¬nition requires that, with probability at least 1 âˆ’ ğœ€, all
appropriate intervals are growth intervals. The former deï¬nition
only requires the probabilistic bound to hold for each interval indi-
vidually. The readerâ€™s immediate reaction might be that it should
follow from the Union Bound that Deï¬nitions 2.1 and 2.2 are essen-
tially equivalent. This is not so. Firstly, this is because the protocol
and notion of conï¬rmation take the security parameter ğœ€ as input.
Nevertheless, one might think that if a protocol is live then a â€˜re-
calibrationâ€™, which takes some appropriate transformation of the
security parameter as input, should necessarily be uniformly live.
This does not follow (in part) because there is no guarantee that the
resulting â„“ğœ€,D will be sublinear in D â€“ see Section 4 for a detailed
analysis.

2.8 Deï¬ning security
Roughly speaking, security requires that conï¬rmed blocks normally
belong to the same chain. Let us say that two distinct blocks are in-
compatible if neither is an ancestor of the other, and are compatible
otherwise. Suppose that, for some processor ğ‘, the message state
at ğ‘¡ is ğ‘€. If ğµ âˆˆ C(ğ‘€), then we say that ğµ is conï¬rmed for ğ‘ at ğ‘¡.

Deï¬nition 2.3 (Security). A protocol is secure if the following
holds for every choice of security parameter ğœ€ > 0, for every ğ‘1, ğ‘2
and for all timeslots ğ‘¡1, ğ‘¡2 in the duration: With probability > 1 âˆ’ ğœ€,
all blocks which are conï¬rmed for ğ‘1 at ğ‘¡1 are compatible with all
those which are conï¬rmed for ğ‘2 at ğ‘¡2.

The following stronger notion will also be useful.

Deï¬nition 2.4 (Uniform Security). A protocol is uniformly se-
cure if the following holds for every choice of security parameter
ğœ€ > 0: With probability > 1 âˆ’ ğœ€, there do not exist incompatible
blocks ğµ1, ğµ2, timeslots ğ‘¡1, ğ‘¡2 and ğ‘1, ğ‘2 such that ğµğ‘– is conï¬rmed
for ğ‘ğ‘– at ğ‘¡ğ‘– for ğ‘– âˆˆ {1, 2}.

The diï¬€erence between security and uniform security is that the
latter requires the probability of even a single disagreement to be
bounded, while the former only bounds the probability of disagree-
ment for each pair of processors at each timeslot pair. Just as for
liveness and uniform liveness, it does not follow from the Union
Bound that security is essentially equivalent to uniform security.
In Section 4 we will perform a detailed analysis of the relationship
between these notions.

3 CERTIFICATES IN THE PARTIALLY

SYNCHRONOUS SETTING

The deï¬nitions of this and subsequent sections are all new to this
paper, unless explicitly stated otherwise. The rough idea is that
â€˜certiï¬catesâ€™ should be proofs of conï¬rmation. Towards formalis-
ing this idea, let us ï¬rst consider a version which is too weak.

Deï¬nition 3.1. If ğµ âˆˆ C(ğ‘€) then we refer to ğ‘€ as a subjective

certiï¬cate for ğµ.

We will say that a set of messages ğ‘€ is broadcast if every member
is broadcast, and that ğ‘€ is broadcast by timeslot ğ‘¡ if every member
of ğ‘€ is broadcast at a timeslot â‰¤ ğ‘¡ (diï¬€erent members potentially
being broadcast at diï¬€erent timeslots). If ğ‘€ is a subjective certiï¬-
cate for ğµ, then there might exist ğ‘€ â€² âŠƒ ğ‘€ for which ğµ âˆ‰ C(ğ‘€ â€²).
So the fact that ğ‘€ is broadcast does not constitute proof that ğµ is
conï¬rmed with respect to any processor. When do we get harder
forms of proof than subjective certiï¬cates? Deï¬nition 3.2 below
gives a natural and very simple way of formalising this.

Deï¬nition 3.2. We say that a protocol with a notion of conï¬r-
mation C produces certiï¬cates if the following holds with prob-
ability > 1 âˆ’ ğœ€ when the protocol is run with security parame-
ter ğœ€: There do not exist incompatible blocks ğµ1, ğµ2, a timeslot ğ‘¡
and ğ‘€1, ğ‘€2 which are broadcast by ğ‘¡, such that ğµğ‘– âˆˆ C(ğ‘€ğ‘– ) for
ğ‘– âˆˆ {1, 2}.

It is important to stress that, in the deï¬nition above, the ğ‘€ğ‘– â€™s are
not necessarily the message states of any processor, but are rather
arbitrary subsets of the set of all broadcast messages. The basic
idea is that, if a protocol produces certiï¬cates, then subjective cer-
tiï¬cates constitute proof of conï¬rmation. Algorand is an example
of a protocol which produces certiï¬cates: The protocol is designed
so that it is unlikely that two incompatible blocks will be produced
at any point in the duration together with appropriate committee
signatures verifying conï¬rmation for each.

Our next aim is to show that, in the partially synchronous set-
ting, producing certiï¬cates is equivalent to security. In fact, produc-
ing certiï¬cates is clearly at least as strong as uniform security, so
it suï¬ƒces to show that if a protocol is secure then it must produce
certiï¬cates.

Theorem 3.3. If a protocol is secure in the partially synchronous

Proof. Towards a contradiction, suppose that the protocol with
notion of conï¬rmation C is secure in the partially synchronous set-
ting, but that there exists a protocol instance12 In1 with security
parameter ğœ€, such that the following holds with probability â‰¥ ğœ€:
There exist incompatible blocks ğµ1, ğµ2, a timeslot ğ‘¡ and ğ‘€1, ğ‘€2
which are broadcast by ğ‘¡, such that ğµğ‘– âˆˆ C(ğ‘€ğ‘– ) for ğ‘– âˆˆ {1, 2}.
This means that the following holds with probability â‰¥ ğœ€ for ğ‘¡last,
which is the last timeslot in the duration: There exist incompati-
ble blocks ğµ1, ğµ2 and ğ‘€1, ğ‘€2 which are broadcast by ğ‘¡last, such that
ğµğ‘– âˆˆ C(ğ‘€ğ‘– ) for ğ‘– âˆˆ {1, 2}. Consider the protocol instance In2 which
has the same values for determined variables as In1, the same state
transition diagram for the processor of the adversary and the same
set of processors with the same set of public keys, except that now
there are two extra processors ğ‘1 and ğ‘2. Suppose that the resource
pool for In2 is the same as that for In1 when restricted to public
keys other than those in Uğ‘1 and Uğ‘2 , and that all keys in Uğ‘1 and
Uğ‘2 have zero resource balance throughout the duration. Suppose
further, that the timing rule for In2 is the same as that for In1
when restricted to tuples (ğ‘, ğ‘ â€², ğ‘š, ğ‘¡) such that ğ‘ âˆ‰ {ğ‘1, ğ‘2} and
ğ‘ â€² âˆ‰ {ğ‘1, ğ‘2}, but that now all timeslots are asynchronous. Accord-
ing to the deï¬nition of Section 2.2, and since all keys in Uğ‘1 and
Uğ‘2 have zero resource balance throughout the duration, it follows
by induction on timeslots that the probability distribution on the
set of broadcast messages is the same at each timeslot for In2 as for
In1, independent of which messages are received by ğ‘1 and ğ‘2. It
therefore holds for the protocol instance In2 that with probability
â‰¥ ğœ€ there exist incompatible blocks ğµ1, ğµ2, and ğ‘€1, ğ‘€2 which are
broadcast by ğ‘¡last, such that ğµğ‘– âˆˆ C(ğ‘€ğ‘– ) for ğ‘– âˆˆ {1, 2}. Now suppose
that ğ‘1 and ğ‘2 do not receive any messages until ğ‘¡last, and then re-
ceive the message sets ğ‘€1 and ğ‘€2 (if they exist) respectively. This
suï¬ƒces to demonstrate that the deï¬nition of security is violated
(cid:3)
with respect to ğ‘¡last, ğœ€, ğ‘1 and ğ‘2.

Corollary 3.4. Security and uniform security are equivalent in

the partially synchronous setting.

Proof. This follows from Theorem 3.3 and the fact that produc-
(cid:3)

ing certiï¬cates clearly implies uniform security.

4 SECURITY AND UNIFORM SECURITY IN

THE SYNCHRONOUS SETTING

Having dealt with the partially synchronous setting, our next task
is to consider the synchronous setting. To do so, however, we ï¬rst
need to formalise the notion of a recalibration.

4.1 Deï¬ning recalibrations
Theorem 3.3 seems to tie things up rather neatly for the partially
synchronous setting. In particular, the equivalence of security and
uniform security meant that we were spared having to carry out a
separate analysis for each security notion. It is not diï¬ƒcult to see,
however, that the two security notions will not be equivalent in
the synchronous setting. To see this, we can consider the example
of Bitcoin. Suppose ï¬rst that we operate in the standard way for
Bitcoin, and use a notion of conï¬rmation C that depends only on
the security parameter ğœ€, and not on the duration D, so that the

setting then it produces certiï¬cates.

12See Section 2.5 for the deï¬nition of a protocol instance.

number of blocks required for conï¬rmation is just a function of ğœ€.
In this case, the protocol is secure in the synchronous setting [10].
It is also clear, however, that this protocol will not be uniformly se-
cure in a setting where the adversary controls a non-zero amount
of mining power: If a ï¬xed number of blocks are required for con-
ï¬rmation then, given enough time, the adversary will eventually
complete a double spend (i.e. the adversary will double spend with
probability tending to 1 as the number of timeslots tends to inï¬n-
ity). That said, it is also not diï¬ƒcult to see how one might â€˜recali-
brateâ€™ the protocol to deal with diï¬€erent durations â€“ to make the
protocol uniformly secure, the number of blocks required for con-
ï¬rmation should be a function of both ğœ€ and D.

The point of this subsection is to formalise the idea of recali-
bration and to show that, if a protocol is secure, then (under fairly
weak conditions) a recalibration will be uniformly secure. The ba-
sic idea is very simple â€“ one runs the initial (unrecalibrated) pro-
tocol for smaller values of ğœ€ as the duration increases, but one has
to be careful that the resulting â„“ğœ€,D is sublinear in D.

Deï¬nition 4.1. We say (P2, C2) is a recalibration of the extended
protocol (P1, C1) if running P2 given certain inputs means running
P1 for a computable transformation of those inputs, and then ter-
minating after |D| many steps are complete.

So, if running P2 with security parameter ğœ€ and for ğ‘› many times-
lots means running P1 with input parameters that specify a secu-
rity parameter ğœ€/10 and that specify a duration consisting of 2ğ‘›
many timeslots, and then terminating after ğ‘› many timeslots have
been completed, then P2 is a recalibration of P1.13 Note also, that
we allow the recalibration to use a diï¬€erent notion of conï¬rmation.
In the following, we say that â„“ğœ€,D is independent of D if â„“ğœ€,D =
â„“ğœ€,Dâ€² for all ğœ€ > 0 and all D, Dâ€². When â„“ğœ€,D is independent of D,
we will often write â„“ğœ€ for â„“ğœ€,D .

Deï¬nition 4.2. In the bounded user setting we assume that there
is a ï¬nite upper bound on the number of processors, which holds
for all protocol instances.14

Proposition 4.3. Consider the synchronous and bounded user
setting. Suppose P satisï¬es liveness with respect to â„“ğœ€,D, that â„“ğœ€,D
is independent of D, and that for each ğ›¼ > 0, â„“ğœ€ < ğ›¼ğœ€âˆ’1 for all suf-
ï¬ciently small ğœ€ > 0. If P is secure, there exists a recalibration of P
that is uniformly live and uniformly secure.

The conditions on â„“ğœ€,D in the statement of Proposition 4.3 can
reasonably be regarded as weak, because existing protocols which
are not already uniformly secure will normally satisfy the condi-
tions that: (â€ ğ‘) â„“ğœ€,D is independent of D, and; (â€ ğ‘) For some con-
stant ğ‘ and any ğœ€ âˆˆ (0, 1), we have â„“ğœ€ < ğ‘ln 1
ğœ€ . The example of Bit-
coin might be useful for the purposes of illustration here. Bitcoin
is secure in the synchronous setting, and the number of blocks re-
quired for conï¬rmation is normally considered to be independent
of the duration. The number of blocks required for conï¬rmation

13The choices ğœ€/10 and 2ğ‘› are arbitrarily chosen for the purpose of example. The
reader might wonder why one should specify a duration of 2ğ‘› timeslots and then
terminate after ğ‘› many. This is because the instructions of the ï¬rst ğ‘› timesteps can
depend on the intended duration. In Algorand, committee sizes will depend on the
intended duration, for example.
14Note that the requirement here is that the number of processors is bounded, rather
than the number of public keys.

does depend on how sure one needs to be that an adversary can-
not double spend in any given time interval, but itâ€™s also true that
an adversaryâ€™s chance of double spending in a given time interval
decreases exponentially in the number of blocks required for con-
ï¬rmation as well. So Bitcoin is an example of a protocol satisfying
(â€ ğ‘) and (â€ ğ‘) above.

Proof of Proposition 4.3. It is useful to consider a security
notion that is intermediate between security and uniform security.
For the purposes of the following deï¬nition, we say that a block
is conï¬rmed at timeslot ğ‘¡ if there exists at least one processor for
whom that is the case.

Deï¬nition 4.4 (Timeslot Security). A protocol is timeslot secure
if the following holds for every choice of security parameter ğœ€ > 0,
and for all timeslots ğ‘¡1, ğ‘¡2 in the duration: With probability > 1 âˆ’ ğœ€,
all blocks which are conï¬rmed at ğ‘¡1 are compatible with all blocks
which are conï¬rmed at ğ‘¡2.

So the diï¬€erence between timeslot security and uniform security
is that the latter requires the probability of even a single disagree-
ment to be bounded, while the former only bounds the probabil-
ity of disagreement for each pair of timeslots. Similarly, the diï¬€er-
ence between security and timeslot security is that, for each pair
of timeslots, the latter requires the probability of even a single dis-
agreement to be bounded, while the former only bounds the prob-
ability of disagreement for each pair of processors at that timeslot
pair.

Now suppose P is live and secure, and that the conditions of
Proposition 4.3 hold. Then it follows directly from the Union Bound
that, if the number of users is bounded, then some recalibration of
P is live and timeslot secure and satisï¬es the conditions of Propo-
sition 4.3. Since a recalibration of a recalibration of P is a recalibra-
tion of P, our main task is therefore to show that, if P is live and
timeslot secure and the conditions of Proposition 4.3 hold, then
there exists a recalibration of P that is uniformly live and uniformly
secure.

So suppose (P, C) is live and timeslot secure, and that the condi-
tions of Proposition 4.3 hold. Suppose we are given ğœ€0 and D0 as
inputs to our recalibration (Pâ€², Câ€²). We wish to ï¬nd an appropriate
security parameter ğœ€1 and a duration D1 â‰¥ D0 to give as inputs
to P and C, so that uniform security is satisï¬ed with respect to ğœ€0
and D0 if we run P with inputs ğœ€1 and D1 and then terminate after
|D0 | many timeslots. The diï¬ƒculty is to ensure that â„“ğœ€1 remains
sublinear in D0. To achieve this, let ğ‘› := |D0 |, set ğœ€1 := ğœ€0/2ğ‘› and
choose |D1 | > ğ‘› + â„“ğœ€1, so that D0 is the ï¬rst ğ‘› timeslots in D1. This
deï¬nes the recalibration. It remains to establish uniform liveness
and uniform security.

For uniform liveness we must have that, for each ğ›¼ âˆˆ (0, 1),
< ğ›¼ğ‘› for all suï¬ƒciently large values of ğ‘› â€“ if this condition
â„“ğœ€1
holds then it follows from the Union Bound that our recalibration
will satisfy uniform liveness (and the required sublinearity in D0)
with respect to â„“ â€²
:= â„“ğœ€1 . The condition holds since we are given
that for each ğ›¼ > 0, â„“ğœ€ < ğ›¼ğœ€âˆ’1 for all suï¬ƒciently small ğœ€ > 0.
Suppose given ğ›¼ > 0, and put ğ›¼ â€² := ğ›¼ğœ€0/2. Then we have that, for
all suï¬ƒciently large ğ‘›:

ğœ€0,D0

â„“ğœ€1

< ğ›¼ â€²(ğœ€0/2ğ‘›)âˆ’1 = ğ›¼ğ‘›.

Next we must show that the conditions for uniform security are
satisï¬ed. Suppose P is given inputs ğœ€1 and D1 and is actually run for
|D1 | many timeslots. We aim to show that, with probability > 1âˆ’ğœ€0,
there do not exist incompatible blocks ğµ1, ğµ2, timeslots ğ‘¡1, ğ‘¡2 âˆˆ D0
and ğ‘1, ğ‘2 such that ğµğ‘– is conï¬rmed for ğ‘ğ‘– at ğ‘¡ğ‘– for ğ‘– âˆˆ {1, 2}. Let ğ‘¡last
be the last timeslot of the duration D1 and deï¬ne ğ‘¡ âˆ— := ğ‘¡last âˆ’ â„“ğœ€1 .
The basic idea is that the two following conditions hold with high
probability: (a) [ğ‘¡ âˆ—, ğ‘¡last] is a growth interval, and (b) There does
not exist ğ‘¡1 âˆˆ D0, processors ğ‘1, ğ‘2 and incompatible blocks ğµ1, ğµ2,
such that ğµ1 is conï¬rmed for ğ‘1 at ğ‘¡1 and ğµ2 is conï¬rmed for ğ‘2
at ğ‘¡last. When both these conditions hold, and since ğ‘¡ âˆ— > ğ‘›, this
suï¬ƒces to show that no incompatible and conï¬rmed blocks exist
during the duration D0. Now let us see that in more detail.

By the choice of D1, ğ‘¡ âˆ— > ğ‘›. It follows from the deï¬nition of

liveness that (â€ 1) below fails to hold with probability â‰¤ ğœ€1:
(â€ 1) [ğ‘¡ âˆ—, ğ‘¡last] is a growth interval.
Note that, so long as (â€ 1) holds, every user has more conï¬rmed
blocks at ğ‘¡last than any user does at any timeslot in D0. It also
follows from the Union Bound, and the deï¬nition of liveness and
timeslot security, that (â€ 2) below fails to hold with probability â‰¤
ğ‘›ğœ€1 = ğœ€0/2:

(â€ 2) There does not exist ğ‘¡1 âˆˆ D0, processors ğ‘1, ğ‘2 and incom-
patible blocks ğµ1, ğµ2, such that ğµ1 is conï¬rmed for ğ‘1 at ğ‘¡1
and ğµ2 is conï¬rmed for ğ‘2 at ğ‘¡last.

Now note that:

(a) If (â€ 1) and (â€ 2) both hold, then there do not exist incompat-
ible blocks ğµ1, ğµ2, timeslots ğ‘¡1, ğ‘¡2 âˆˆ D0 and ğ‘1, ğ‘2 such that
ğµğ‘– is conï¬rmed for ğ‘ğ‘– at ğ‘¡ğ‘– for ğ‘– âˆˆ {1, 2}.

(b) With probability > 1 âˆ’ ğœ€1 âˆ’ ğœ€0/2 â‰¥ 1 âˆ’ ğœ€0, (â€ 1) and (â€ 2) both

hold.

So uniform security is satisï¬ed with respect to ğœ€0 and D0, as re-
(cid:3)
quired.

Deï¬nition 4.5. We say P has standard functionality if it is uni-
formly live and uniformly secure. We say that a recalibration of P
is faithful if it has standard functionality when P does.

Proposition 4.3 justiï¬es concentrating on protocols which have
standard functionality where it is convenient to do so, since proto-
cols which are live and secure will have recalibrations with stan-
dard functionality, so long as the rather weak conditions of Propo-
sition 4.3 are satisï¬ed. Again, when we talk about the security and
liveness of a protocol, it is really the extended protocol that we are
referring to.

5 CERTIFICATES IN THE SYNCHRONOUS

SETTING

5.1 The synchronous and unsized setting
As outlined in the introduction, part of the aim of this paper is to
give a positive answer to Q3, by showing that whether a proto-
col produces certiï¬cates comes down essentially to properties of
the processor selection process. In the unsized setting protocols
cannot produce certiï¬cates. In the sized setting, recalibrated pro-
tocols will automatically produce certiï¬cates, at least if they are
of â€˜standard formâ€™. For the partially synchronous setting, the re-
sults of [12] and Section 3 already bear this out: The sized setting

is required for security and all secure protocols must produce cer-
tiï¬cates. The following theorem now deals with the unsized and
synchronous setting. Recall that, in the unsized setting, the total
resource balance belongs to a determined interval [ğ›¼0, ğ›¼1]. We say
that the protocol operates â€˜in the presence of a non-trivial adver-
saryâ€™ if the setting allows that the adversary may have resource
balance at least ğ›¼0 throughout the duration.

Theorem 5.1. Consider the synchronous and unsized setting. If a
protocol is live then, in the presence of a non-trivial adversary, it does
not produce certiï¬cates.

Proof. The basic idea is that the adversary with resource bal-
ance at least ğ›¼0 can â€˜simulateâ€™ their own execution of the protocol,
in which only they have non-zero resource balance, while the non-
faulty processors carry out an execution in which the adversary
does not participate. Simulating their own execution means that
the adversary carries out the protocol as usual, while ignoring mes-
sages broadcast by the non-faulty processors, but does not initially
broadcast messages when given permission to do so. Liveness (to-
gether with the fact that the resource pool is undetermined) guar-
antees that, with high probability, both the actual and simulated
executions produce blocks which look conï¬rmed from their own
perspective. These blocks will be incompatible with each other and,
once the adversary ï¬nally broadcasts the messages that they have
been given permission for, these blocks will all have subjective cer-
tiï¬cates which are subsets of the set of broadcast messages. This
suï¬ƒces to show that the protocol does not produce certiï¬cates.

More precisely, we consider two instances of the protocol In0
and In1 in the synchronous and unsized setting, which have the
same values for all determined variables â€“ including the same suf-
ï¬ciently small security parameter ğœ€ and the same suï¬ƒciently long
duration D â€“ and also have the same set of processors and the
same message delivery rule, but which diï¬€er as follows:

â€¢ In In0, a set of processors P0 control public keys in a set
U0, which are the only public keys that do not have zero re-
source balance throughout the duration. The total resource
balance T has a ï¬xed value, ğ›¼ say.

â€¢ In In1, it is the adversary who controls the public keys in U0,
and those keys have the same resource balance throughout
the duration as they do in In0. Now, however, another set
of processors P1 control public keys in a set U1 (disjoint
from U0), and the public keys in U1 also have total resource
balance ğ›¼ throughout the duration, i.e. the resource balances
of these keys always add to ğ›¼.

In In1, we suppose that the adversary simulates the processors in
P0 for In0 (which can be done with the single processor ğ‘ğ´), which
means that the adversary carries out the instructions for those pro-
cessors, with the two following exceptions. Until a certain timeslot
ğ‘¡ âˆ—, to be detailed subsequently, they:

(a) Ignore all messages broadcast by non-faulty processors, and;
(b) Do not actually broadcast messages when permitted, but
consider them received by simulated processors in P0 as per
the message delivery rule.

For In0 (so long as the duration is suï¬ƒciently long), liveness
guarantees the existence of a timeslot ğ‘¡0 for which the following
holds with probability > 1 âˆ’ ğœ€:

(â‹„0) At ğ‘¡0 there exists a set of broadcast messages ğ‘€0 and a block

ğµ0 such that ğµ0 âˆˆ C(ğ‘€0).

For In1, liveness guarantees the existence of a timeslot ğ‘¡1 for

which the following holds with probability > 1 âˆ’ ğœ€:

(â‹„1) At ğ‘¡1 there exists a set of broadcast messages ğ‘€1 and a block

ğµ1 such that ğµ1 âˆˆ C(ğ‘€1).

Choose ğ‘¡ âˆ— > ğ‘¡0, ğ‘¡1. Our framework stipulates that the instruc-
tions of the protocol for a given user at a given timeslot are a
deterministic function of their present state and the message set
and permission set received at that timeslot. It also stipulates that
the response of the permitter to a request (ğ‘¡ â€², U, ğ‘€, ğ´) is a prob-
abilistic function of the determined variables, (ğ‘¡ â€², U, ğ‘€, ğ´), and of
R (U, ğ‘¡ â€², ğ‘€). Since we are working in the unsized setting, In1 and
In0 have the same determined variables. It therefore follows by in-
duction on timeslots ğ‘¡ â‰¤ ğ‘¡ âˆ—, that the following is true at all points
until the end of timeslot ğ‘¡:
(â‹„2) The probability distribution for In0 on the set of permission
sets given by the permitter is identical to the probability dis-
tribution for In1 on the set of permission sets given by the
permitter to the adversary.

Now suppose that at timeslot ğ‘¡ âˆ— the adversary broadcasts all
messages for which they have been given permission by the per-
mitter. Note that, according to the assumptions of Section 2.4, any
block ğµ0 broadcast by the adversary at ğ‘¡ âˆ— will be incompatible with
any block ğµ1 that has been broadcast by any honest user up to that
point. Combining (â‹„0), (â‹„1) and (â‹„2), we see that (so long as ğœ€ is
suï¬ƒciently small that ğœ€ < 1âˆ’2ğœ€) the following holds with probabil-
ity > ğœ€ for ğ‘¡ âˆ— and In1: There exist incompatible blocks ğµ0, ğµ1, and
ğ‘€0, ğ‘€1 which are broadcast by the end of ğ‘¡ âˆ—, such that ğµğ‘– âˆˆ C(ğ‘€ğ‘– )
for ğ‘– âˆˆ {0, 1}. This suï¬ƒces to show that the protocol does not pro-
(cid:3)
duce certiï¬cates.

5.2 The synchronous and sized setting
The example of sized Bitcoin. Our aim in this subsection is to
show that, if we work in the synchronous and sized setting, and if
a protocol is of â€˜standard formâ€™, then a recalibration will produce
certiï¬cates. To make this precise, however, it will be necessary to
recognise the potentially time dependent nature of proofs of conï¬r-
mation. To explain this idea, it is instructive to consider the exam-
ple of Bitcoin in the sized setting: The protocol is Bitcoin, but now
we are told in advance precisely how the hash rate capability of
the network varies over time, as well as bounds on the hash rate of
the adversary.15 To make things concrete, let us suppose that the
total hash rate is ï¬xed over time, and that the adversary has 10%
of the hash rate at all times. Suppose that, during the ï¬rst couple
of hours of running the protocol, the diï¬ƒculty setting is such that
the network as a whole (with the adversary acting honestly) will
produce an expected one block every 10 minutes. Suppose further
that, after a couple of hours, we see a block ğµ which belongs to a
chain ğ¶, in which it is followed by 10 blocks. In this case, the con-
straints we have been given mean that it is very unlikely that ğµ
does not belong to the longest chain. So, at that timeslot, ğ¶ might
be considered a proof of conï¬rmation for ğµ, i.e. the existence of the

chain ğ¶ can be taken as proof that ğµ is conï¬rmed. The nature of
this proof is time dependent, however. The same set of blocks (i.e.
ğ¶) a large number of timeslots later would not constitute proof of
conï¬rmation.

If we now consider a PoS version of the example above, modi-
ï¬ed to work for Snow White rather than Bitcoin, then the proof
produced will not be time dependent. This is because PoS proto-
cols function in the timed setting, i.e. when permission is given to
broadcast ğ‘š in response to a request (ğ‘¡, U, ğ‘€, ğ´), other users are
able to determine ğ‘¡ from ğ‘š. In order to prove that (recalibrated)
protocols in the sized setting produce certiï¬cates, we will have to
make the assumption that we are also working in the timed setting.

Protocols in standard form. The basic intuition behind the pro-
duction of certiï¬cates in the sized setting can be seen from the
example of â€œSized Bitcoinâ€ above. Once a block is conï¬rmed, non-
faulty processors will work â€˜aboveâ€™ this block. So long as those
processors possess a majority of the total resource balance, and so
long as the permitter reï¬‚ects this fact in the permissions it gives,
then those non-faulty processors will broadcast a set of messages
which suï¬ƒces (by its existence rather than the fact that it is the full
message state of any user) to give proof of conï¬rmation. This proof
of conï¬rmation might be temporary, but it will not be temporary
in the timed setting.

This intuitive argument, however, assumes that the protocol sat-
isï¬es certain standard properties. As alluded to above, there is an
assumption that the set of messages broadcast by a group of proces-
sors will reï¬‚ect their resource balances and that the adversary will
have a minority resource balance. There is also an assumption that
broadcast messages will (in some sense) point to a particular posi-
tion on the blockchain. So we will have to formalise these ideas,
and the results we prove will only hold modulo the assumption
that these standard properties are satisï¬ed.

First, let us formalise the idea that messages always point to a

position on the blockchain.

Deï¬nition 5.2. We say that a protocol is in standard form if it

satisï¬es all of the following:

â€¢ The protocol has standard functionality (see Deï¬nition 4.5).
â€¢ Every broadcast message is â€˜attachedâ€™ to a speciï¬c block

(blocks being attached to themselves).

â€¢ While ğµ is conï¬rmed for ğ‘, the state transition diagram S
will only instruct ğ‘ to broadcast messages which are attached
to ğµ or descendants of ğµ.

Reï¬‚ecting the resource pool. Now let us try to describe how the
permitter might reï¬‚ect the resource pool. We will need a simple
way to say that one set of processors consistently has a higher
resource balance than another.

Deï¬nition 5.3. For Î˜ > 1, we say a set of public keys U1 dom-
inates another set U2, denoted U1 >Î˜ U2, if the following holds
for all sets of broadcast messages ğ‘€ and all timeslots ğ‘¡:

Ã•
UâˆˆU1

R (U, ğ‘¡, ğ‘€) > Î˜ Â· Ã•
UâˆˆU2

R (U, ğ‘¡, ğ‘€).

15Normally we think of PoW protocols as operating in the unsized setting, precisely
because such guarantees on the hash rate are not realistic.

Next, we will need to formalise the idea that, if one set of keys
dominates another, then they will be able to broadcast discernibly

diï¬€erent sets of messages. Recall that, in the timed setting, each
message ğ‘š corresponds to a timeslot ğ‘¡ğ‘š, which can be determined
from ğ‘š. We write M [ğ‘¡1, ğ‘¡2] to denote the set {ğ‘€ | âˆ€ğ‘š âˆˆ ğ‘€, ğ‘¡ğ‘š âˆˆ
[ğ‘¡1, ğ‘¡2]}. We will say that the set of keys U0 is directed to broadcast
ğ‘€ if, for every ğ‘š âˆˆ ğ‘€, there is some member of U0 that is given
permission to broadcast ğ‘š and is directed to broadcast ğ‘š by the
protocol. We will say that U0 is able to broadcast ğ‘€ if, for every
ğ‘š âˆˆ ğ‘€, there is some member of U0 that is given permission to
broadcast ğ‘š. We deï¬ne Mâˆ— := {ğ‘€ | ğ‘€ is ï¬nite}. We let T be the
set of functions ğ‘‡ : D Ã— M â†’ Râ‰¥0 (so that the total resource
balance T âˆˆ T). We say that a set of keys U0 has total resource
UâˆˆU0 R (U, ğ‘¡, ğ‘€). In the
balance ğ‘‡ : D Ã— M â†’ Râ‰¥0 if ğ‘‡ (ğ‘¡, ğ‘€) =
for each Î˜, ğœ€,ğ‘‡ ,
deï¬nition below, we say ğ‘Ÿ is sublinear in |D| if,
and for every ğ›¼ âˆˆ (0, 1), it holds that ğ‘Ÿ (Î˜, ğœ€,ğ‘‡ , |D|) < ğ›¼ |D| for all
suï¬ƒciently large |D|.

Ã

Deï¬nition 5.4. We say that (S, O, C) reï¬‚ects the resource pool
if there exist computable ï¬nite valued functions ğ‘Ÿ : R>1 Ã— R>0 Ã—
T Ã— N â†’ N and X : Mâˆ— Ã— R>1 Ã— R>0 Ã— T Ã— N â†’ 2Mâˆ—
, such that:

(1) ğ‘Ÿ is sublinear in |D|.
(2) If U1 âˆª U2 has total resource balance ğ‘‡ , and if U1 >Î˜ U2,
then, when the protocol is run with security parameter ğœ€ and
for |D| many timeslots, the following holds with probabil-
ity > 1âˆ’ğœ€: For all intervals of timeslots [ğ‘¡1, ğ‘¡2] with ğ‘¡2 âˆ’ğ‘¡1 â‰¥
ğ‘Ÿ (Î˜, ğœ€,ğ‘‡ , |D|), there exists some ğ‘€ âˆˆ M [0, ğ‘¡1) and an ele-
ment of X(ğ‘€, Î˜, ğœ€,ğ‘‡ , |D|) âˆ© M [ğ‘¡1, ğ‘¡2] which U1 is directed
to broadcast, while there does not exist any ğ‘€ â€² âˆˆ M [0, ğ‘¡1)
which is broadcast and such that U2 is able to broadcast
some element of X(ğ‘€ â€², Î˜, ğœ€,ğ‘‡ , |D|) âˆ© M [ğ‘¡1, ğ‘¡2].

So in Deï¬nition 5.4, ğ‘Ÿ speciï¬es a number of timeslots. Then X
speciï¬es certain sets of messages ğ‘€ such that, if U1 >Î˜ U2 and
U1 âˆª U2 has total resource balance ğ‘‡ , then U1 can be expected to
broadcast one of these sets ğ‘€ in any interval of suï¬ƒcient length
(i.e. the length speciï¬ed by ğ‘Ÿ ). To make this interesting, we also
have that U2 can be expected not to make such broadcasts. To see
why this is a natural and reasonable condition to assume, it is in-
structive to consider the example of Sized Bitcoin. Suppose that in
some execution the honest users always have at least 60% of the
mining power. Then, over any long period of time ğ‘Ÿ , we can be
fairly sure that honest users will get to make at least 50% of the ex-
pected number of block broadcasts, while the adversary is unlikely
to be able to make such broadcasts if ğ‘Ÿ is large enough. In fact, the
exponentially fast convergence for the law of large numbers guar-
anteed by bounds like Hoeï¬€dingâ€™s inequality, means ğ‘Ÿ only needs
to grow with ln 1/ğ‘, where ğ‘ is the probability of error (i.e. the
probability these conditions on the block broadcasts donâ€™t hold in
a given interval). It is therefore not diï¬ƒcult to see that Sized Bit-
coin would reï¬‚ect the resource pool if it could be implemented in
a timed setting. Similar arguments can be made for all well known
PoS protocols,16 and these are implemented in the timed setting.

Deï¬nition 5.5. In the bounded adversary setting it is assumed

that:

16The example of Snow White was discussed previously. As suggested in Section 1,
one way to deï¬ne X in the context of Snow White is to consider long chains of suï¬ƒ-
cient density, meaning that they have members corresponding to most possible times-
lots, that they cannot likely be produced by a (suï¬ƒciently bounded) adversary.

(i) U1 >Î˜ U2 for some determined input parameter Î˜ > 1,
where U1 is the set of keys controlled by non-faulty proces-
sors, and U2 is the the set of keys controlled by the adver-
sary.

(ii) (S, O, C) reï¬‚ects the resource pool.

Finally, we can now formalise the idea that under standard con-
ditions, standard protocols in the sized setting produce certiï¬cates.

Theorem 5.6. Consider the timed, bounded adversary and sized
setting. If P is in standard form, then there exists a faithful recalibra-
tion that produces certiï¬cates.

Proof. To deï¬ne our recalibration (Pâ€², Câ€²), suppose we are given
values for ğœ€, T , Î˜ and D. We need to specify a value ğœ€ â€² to give as in-
put to P (we will leave other values unchanged), and we must also
deï¬ne Câ€². Then we need to show that the new extended protocol
is uniformly live and produces certiï¬cates.

We deï¬ne ğœ€ â€² := ğœ€/4. Towards deï¬ning Câ€², suppose that P sat-
isï¬es uniform liveness with respect to â„“ğœ€â€²,D . We divide the dura-
tion into intervals of length > â„“ğœ€â€²,D , by deï¬ning ğ‘¡ğ‘– := ğ‘– Â· (â„“ğœ€â€²,D +
ğ‘Ÿ (Î˜, ğœ€ â€², T , |D|)). From the deï¬nition of uniform liveness we have
the following.
($1) With probability > 1 âˆ’ ğœ€/4 it holds that, for all ğ‘– with ğ‘¡ğ‘– â‰¤
|D|, all users have at least ğ‘– many conï¬rmed blocks by the
end of timeslot ğ‘¡ğ‘– .

Now suppose (P, C) satisï¬es Deï¬nition 5.4 with respect to ğ‘Ÿ and
:= ğ‘¡ğ‘– + ğ‘Ÿ (Î˜, ğœ€ â€², T , |D|). Let ğ¼ğ‘– be the
X. For each ğ‘– > 0, deï¬ne ğ‘¡ âˆ—
ğ‘–
interval [ğ‘¡ğ‘–, ğ‘¡ âˆ—
ğ‘– ], and write M [ğ¼ğ‘–] to denote M [ğ‘¡ğ‘–, ğ‘¡ âˆ—
ğ‘– ]. Let U1 be the
set of keys controlled by non-faulty processors, and let U2 be the
the set of keys controlled by the adversary. According to Deï¬nition
5.4, we can then conclude that:
($2) It holds with probability > 1 âˆ’ ğœ€/4 that, whenever ğ¼ğ‘– is con-
tained in the duration, there exists some ğ‘€ âˆˆ M [0, ğ‘¡ğ‘–) which
is broadcast and an element of X(ğ‘€, Î˜, ğœ€ â€², T , |D|) âˆ© M [ğ¼ğ‘–]
which U1 is directed to broadcast, while there does not ex-
ist any ğ‘€ â€² âˆˆ M [0, ğ‘¡ğ‘–) which is broadcast and such that U2
is able to broadcast some element of X(ğ‘€ â€², Î˜, ğœ€ â€², T , |D|) âˆ©
M [ğ¼ğ‘–].

Since P is uniformly secure, we also know that:
($3) With probability > 1 âˆ’ ğœ€/4, there do not exist incompati-
ble blocks ğµ1, ğµ2, timeslots ğ‘¡1, ğ‘¡2 and ğ‘ˆ1, ğ‘ˆ2 such that ğµğ‘– is
conï¬rmed for ğ‘ˆğ‘– at ğ‘¡ğ‘– for ğ‘– âˆˆ {1, 2}.

So now deï¬ne Xâˆ— (Î˜, ğœ€ â€², T , |D|) to be all those ğ‘€ = ğ‘€ â€² âˆª ğ‘€ â€²â€²
such that ğ‘€ â€² âˆˆ X(ğ‘€ â€²â€², Î˜, ğœ€ â€², T , |D|), and for which there exists ğ‘–
such that all of the following hold: (i) ğ¼ğ‘– âŠ† D; (ii) ğ‘€ â€² âˆˆ M [ğ¼ğ‘–],
ğ‘€ â€²â€² âˆˆ M [0, ğ‘¡ğ‘– ) and; (iii) For some chain ğ¶ of length ğ‘– with leaf ğµ,
all messages in ğ‘€ â€² are attached to ğµ or its descendants.

Now if ğ‘€ âˆˆ Xâˆ— (Î˜, ğœ€ â€², T , |D|), then let ğ‘€ â€², ğ‘€ â€²â€² be such that ğ‘€ â€² âˆˆ
X(ğ‘€ â€²â€², Î˜, ğœ€ â€², T , |D|) and (i)â€“(iii) above are satisï¬ed, let ğ‘–ğ‘€â€² be the
(unique) ğ‘– such that (i)â€“(iii) hold w.r.t. ğ‘€ â€², let ğ¶ be as speciï¬ed in
(iii) for ğ‘–ğ‘€â€² , and deï¬ne Câˆ— (ğ‘€) := ğ¶. We also deï¬ne Câˆ— (âˆ…) = âˆ…. This
function Câˆ— is almost the notion of conï¬rmation that we want for
our recalibration, but the problem is that it is only deï¬ned for very
speciï¬c values of ğ‘€. We will use Câˆ— to help us deï¬ne Câ€² that is
deï¬ned for all possible ğ‘€. Combining ($1), ($2) and ($3), and the

[3] Iddo Bentov, Rafael Pass, and Elaine Shi. 2016. Snow White: Provably Secure

Proofs of Stake. IACR Cryptology ePrint Archive 2016, 919 (2016).

[4] Ethan Buchman. 2016.

Tendermint: Byzantine fault tolerance in the age of

blockchains. Ph.D. Dissertation.

[5] Ran Canetti. 2001. Universally composable security: A new paradigm for crypto-
graphic protocols. In Proceedings 42nd IEEE Symposium on Foundations of Com-
puter Science. IEEE, 136â€“145.

[6] David Cavin, Yoav Sasson, and AndrÃ© Schiper. 2004. Consensus with unknown
participants or fundamental self-organization. In International Conference on Ad-
Hoc Networks and Wireless. Springer, 135â€“148.

[7] Jing Chen, Sergey Gorbunov, Silvio Micali, and Georgios Vlachos. 2018. ALGO-
RAND AGREEMENT: Super Fast and Partition Resilient Byzantine Agreement.
IACR Cryptol. ePrint Arch. 2018 (2018), 377.

[8] Jing Chen and Silvio Micali. 2016. Algorand. arXiv preprint arXiv:1607.01341

(2016).

[9] Cynthia Dwork, Nancy A. Lynch, and Larry Stockmeyer. 1988. Consensus in

the Presence of Partial Synchrony. J. ACM 35, 2 (1988), 288â€“323.

[10] Juan A Garay, Aggelos Kiayias, and Nikos Leonardos. 2018. The Bitcoin Back-

bone Protocol: Analysis and Applications. (2018).

[11] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov.
2017. Ouroboros: A provably secure proof-of-stake blockchain protocol. In An-
nual International Cryptology Conference. Springer, 357â€“388.

[12] Andrew Lewis-Pye and Tim Roughgarden. 2021. Byzantine Generals in the Per-

missionless Setting. arXiv preprint arXiv:2101.07095 (2021).

[13] Nancy A Lynch. 1996. Distributed algorithms. Elsevier.
[14] Satoshi Nakamoto et al. 2008. Bitcoin: A peer-to-peer electronic cash sys-

tem.(2008).

[15] Michael Okun. 2005. Distributed computing among unacquainted processors in

the presence of Byzantine failures. Hebrew University of Jerusalem.

[16] Rafael Pass, Lior Seeman, and abhi shelat. 2016. Analysis of the Blockchain

Protocol in Asynchronous Networks. eprint.iacr.org/2016/454.

[17] Ling Ren. 2019. Analysis of nakamoto consensus. Technical Report. Cryptology

ePrint Archive, Report 2019/943.(2019). https://eprint. iacr.org.

[18] Maofan Yin, Dahlia Malkhi, Michael K Reiter, Guy Golan Gueta, and Ittai Abra-
ham. 2019. HotStuï¬€: BFT consensus with linearity and responsiveness. In Pro-
ceedings of the 2019 ACM Symposium on Principles of Distributed Computing. 347â€“
356.

deï¬nition of Xâˆ—, it follows that with probability > 1 âˆ’ ğœ€ both of the
following hold:

(1) If ğ‘€, ğ‘€ â€² âˆˆ Xâˆ— (Î˜, ğœ€ â€², T , |D|) are both broadcast, then all
blocks in Câˆ— (ğ‘€) are compatible with all those in Câˆ— (ğ‘€ â€²).
(2) For every ğ‘– > 0 with ğ¼ğ‘– âŠ† D, there exists ğ‘€ âˆˆ Xâˆ— (Î˜, ğœ€ â€², T , |D|)
which is broadcast and such that, for some ğ‘€ â€², ğ‘€ â€²â€²: (i) ğ‘€ =
ğ‘€ â€² âˆª ğ‘€ â€²â€²; (ii) ğ‘€ â€² âˆˆ X(ğ‘€ â€²â€², Î˜, ğœ€ â€², T , |D|); (iii) ğ‘€ â€² âˆˆ M [ğ¼ğ‘–],
ğ‘€ â€²â€² âˆˆ M [0, ğ‘¡ğ‘–), and; (iv) For some chain ğ¶ of length ğ‘– with
leaf ğµ, all messages in ğ‘€ â€² are attached to ğµ or its descen-
dants.

In order to deï¬ne Câ€² for our recalibration, we can then proceed
as follows. Given arbitrary ğ‘€, choose ğ‘€ â€² âŠ† ğ‘€ such that ğ‘€ â€² âˆˆ
Xâˆ— (Î˜, ğœ€ â€², T , |D|) and Câˆ— (ğ‘€ â€²) is of maximal length, or if there exists
no ğ‘€ â€² satisfying these conditions then deï¬ne ğ‘€ â€² := âˆ…. We deï¬ne
Câ€²(ğ‘€) := Câˆ— (ğ‘€ â€²). It follows from (1) and (2) above that (Pâ€², Câ€²)
produces certiï¬cates and satisï¬es uniform liveness with respect to
ğœ€,D := â„“ğœ€â€²,D + 2ğ‘Ÿ (Î˜, ğœ€ â€², T , |D|).
â„“ â€²
(cid:3)

6 APPENDIX â€“ TABLE 1.

term
ğµ
C
D
Î”

meaning
a block
a notion of conï¬rmation
the duration
bound on message delay during synchronous
intervals
the security parameter
a protocol instance
a message
a set of messages
the set of all possible sets of messages
a permitter oracle
a processor
a permission set
a permissionless protocol
a request set
the resource pool
a state transition diagram
a message
a timeslot
a request in the timed setting
a timing rule
a public key
a request in the untimed setting
the set of all public keys
the set public keys for ğ‘

ğœ€
In
ğ‘š
ğ‘€
M
O
ğ‘
ğ‘ƒ
P
ğ‘…
R
S
ğœ
ğ‘¡
(ğ‘¡, U, ğ‘€, ğ´)
T
U
(U, ğ‘€, ğ´)
U
Uğ‘
Table 1: Some commonly used variables and terms.

REFERENCES
[1] Eduardo AP Alchieri, Alysson Neves Bessani, Joni da Silva Fraga, and FabÃ­ola
Greve. 2008. Byzantine consensus with unknown participants. In International
Conference On Principles Of Distributed Systems. Springer, 22â€“40.

[2] Vivek Bagaria, Sreeram Kannan, David Tse, Giulia Fanti, and Pramod Viswanath.
2019. Prism: Deconstructing the blockchain to approach physical limits. In Pro-
ceedings of the 2019 ACM SIGSAC Conference on Computer and Communications
Security. 585â€“602.

