How Does Blockchain Security Dictate Blockchain
Implementation?

Andrew Lewis-Pye
London School of Economics
a.lewis7@lse.ac.uk

Tim Roughgarden
Columbia University
tim.roughgarden@gmail.com

1
2
0
2

v
o
N
5

]

R
C
.
s
c
[

2
v
8
4
8
4
0
.
9
0
1
2
:
v
i
X
r
a

ABSTRACT
Blockchain protocols come with a variety of security guarantees.
For example, BFT-inspired protocols such as Algorand1 tend to be
secure in the partially synchronous setting, while longest chain
protocols like Bitcoin will normally require stronger synchronicity
to be secure. Another fundamental distinction, directly relevant to
scalability solutions such as sharding, is whether or not a single un-
trusted user is able to point to certiﬁcates, which provide incontro-
vertible proof of block conﬁrmation. Algorand produces such cer-
tiﬁcates, while Bitcoin does not. Are these properties accidental?
Or are they inherent consequences of the paradigm of protocol de-
sign? Our aim in this paper is to understand what, fundamentally,
governs the nature of security for permissionless blockchain pro-
tocols. Using the framework developed in [12], we prove general
results showing that these questions relate directly to properties of
the user selection process, i.e. the method (such as proof-of-work
or proof-of-stake) which is used to select users with the task of
updating state. Our results suﬃce to establish, for example, that
the production of certiﬁcates is impossible for proof-of-work pro-
tocols, but is automatic for standard forms of proof-of-stake pro-
tocols. As a byproduct of our work, we also deﬁne a number of
security notions and identify the equivalences and inequivalences
among them.

CCS CONCEPTS
• Computer systems organization → Dependable and fault-
tolerant systems and networks.

KEYWORDS
blockchain; cryptocurrencies; proof-of-work; proof-of-stake; Byzan-
tine fault tolerant; longest-chain

ACM Reference Format:
Andrew Lewis-Pye and Tim Roughgarden. 2021. How Does Blockchain Se-
curity Dictate Blockchain Implementation? . In Proceedings of the 2021 ACM
SIGSAC Conference on Computer and Communications Security (CCS ’21),
November 15–19, 2021, Virtual Event, Republic of Korea. ACM, New York,
NY, USA, 14 pages. https://doi.org/10.1145/3460120.3484752

1For an exposition of Algorand that explains how to achieve security in the partially
synchronous setting, see [7].

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea.
© 2021 Association for Computing Machinery.
ACM ISBN 978-1-4503-8454-4/21/11. . . $15.00
https://doi.org/10.1145/3460120.3484752

1 INTRODUCTION

Paradigms for blockchain protocol design. In the wake of Bitcoin
[14], thousands of cryptocurrencies have ﬂooded the market. While
many of these currencies use only slight modiﬁcations of the Bit-
coin protocol, there are also a range of cryptocurrencies taking
radically diﬀerent design approaches. Two informal distinctions
are between:

(1) Proof-of-stake (PoS)/proof-of-work (PoW). In a PoW proto-
col, users are selected and given the task of updating state,
with the probability any particular user is chosen being pro-
portional to their (relevant) computational power. In PoS
protocols, users are selected with probability depending on
their stake (owned currency).

(2) BFT2/longest-chain. As well as being a PoW protocol, Bit-
coin is the best known example of a longest chain proto-
col. This means that forks may occur in the blockchain, but
that honest miners will build on the longest chain. In a BFT
protocol, on the other hand, users are selected and asked
to carry out a consensus protocol designed for the permis-
sioned setting. So, roughly, longest chain protocols are those
which are derived from Bitcoin, while BFT protocols are de-
rived from protocols designed in the permissioned setting.
Algorand [8] is a well known example of a BFT protocol.

A formal framework for comparing design paradigms [12]. While
informal, these distinctions are more than aesthetic. For example,
BFT protocols like Algorand will tend to give security guarantees
that hold under signiﬁcantly weaker network connectivity assump-
tions than are required to give security for protocols like Bitcoin.
By developing an appropriate formal framework, it can then be
shown [12] that these diﬀerences in security are a necessary con-
sequence of the paradigm of protocol design: The fact that Bitcoin
is a PoW protocol means that it cannot oﬀer the same ﬂavour of
security guarantees as Algorand. A framework of this kind was de-
veloped in [12], according to which permissionless 3 protocols run
relative to a resource pool. This resource pool speciﬁes a balance
for each user over the duration of the protocol execution (such as
hashrate or stake), which may be used in determining which users
are permitted to update state. Within this framework, the idea that
protocols like Bitcoin require stronger connectivity assumptions
for security can be formalised as a theorem asserting that adaptive

2The acronym BFT stands for ‘Byzantine-Fault-Tolerant’.
3In the distributed computing literature, consensus protocols have traditionally been
studied in a setting where all participants are known to each other from the start of
the protocol execution. In the parlance of the blockchain literature, this is referred
to as the permissioned setting. What diﬀerentiates Bitcoin [14] from these previously
studied protocols is that it operates in a permissionless setting, i.e. it is a protocol for
establishing consensus over an unknown network of participants that anybody can
join, with as many identities as they like in any role.

 
 
 
 
 
 
protocols cannot be partition secure – these terms apply to permis-
sionless blockchain protocols and will be deﬁned formally later on,
but, roughly, they can be summed up as follows:

• Liveness and security are deﬁned in terms of a notion of con-
ﬁrmation for blocks. A protocol is live if the number of con-
ﬁrmed blocks can be relied on to increase during extended
intervals of time during which message delivery is reliable.
A protocol is secure if rollback on conﬁrmed blocks is un-
likely.

• Bitcoin being adaptive means that it remains live in the face
of an unpredictable size of resource pool (unpredictable lev-
els of mining).

• A protocol is partition secure if it is secure in the partially
synchronous setting, i.e. if the rollback of conﬁrmed blocks
remains unlikely even in the face of potentially unbounded
network partitions. The partially synchronous setting will
be further explained and formally deﬁned in Section 2.

This paper: certiﬁcates. The way in which Algorand and other
BFT protocols achieve partition security is also worthy of note.
For all such protocols, protection against unbounded network par-
titions is provided through the production of certiﬁcates: These are
sets of broadcast messages whose very existence suﬃces to estab-
lish block conﬁrmation and which cannot be produced by a (suit-
ably bounded) adversary given the entire duration of the execution
of the protocol. Bitcoin does not produce certiﬁcates, because the
existence of a certain chain does generally not prove that it is the
longest chain – a user will only believe that a certain chain is the
longest chain until presented with a longer (possibly incompati-
ble) chain. Algorand does produce certiﬁcates, on the other hand,
because the very existence of a valid chain, together with appro-
priate committee signatures for all the blocks in the chain, suﬃces
to guarantee (beyond a reasonable doubt) that the blocks in that
chain are conﬁrmed. We will formally deﬁne what it means for a
protocol to produce certiﬁcates in Section 3.

The production of certiﬁcates is also functionally useful, beyond
providing security against network partitions. The production of
certiﬁcates means, for example, that a single untrusted user is able
to convince another user of block conﬁrmation (by relaying an ap-
propriate certiﬁcate), and this is potentially very useful in the con-
text of sharding. If a user wishes to learn the state of a blockchain
they were not previously monitoring, then it is no longer neces-
sary to perform an onboarding process in which one samples the
opinions of users until such a point that it is likely that at least one
of them was ‘honest’ – one simply requests a certiﬁcate proving
conﬁrmation for a recently timestamped block.4

1.1 Overview of results.
The goal of this paper is to rigorously investigate to what extent
today’s protocols “have to look the way they are” given the secu-
rity guarantees they achieve. Such formal analyses are relevant to
the broader research community for several reasons, including: (i)
accurate intuitions of the community (e.g., that there’s fundamen-
tally only one way to achieve certain properties) can be formally
validated, with the necessary assumptions clearly spelled out; (ii)

4Such techniques can avoid the need to store block hashes in a sharding ‘main chain’,
and the information withholding attacks that come with those approaches.

inaccurate intuitions can be exposed as such; (iii) unexplored areas
of the protocol design space can naturally rise to the surface (e.g.,
Section 5.2); and (iv) new deﬁnitions (e.g., certiﬁcates) can enhance
our language for crisply describing and comparing competing solu-
tions (both present and future). In this paper, we prove three main
results, which each address this issue in a diﬀerent setting.

The partially synchronous setting. The ﬁrst key question is:

Q1. Are certiﬁcates fundamental to partition security, or an ar-
tifact of Algorand’s speciﬁc implementation? That is, are
certiﬁcates the only way for permissionless blockchain pro-
tocols to achieve security in the partially synchronous set-
ting?

Our ﬁrst main result, proved in the context of the framework of
[12], gives an aﬃrmative response to Q1. Of course, all terms will
be explained and formally deﬁned in later sections.

THEOREM 3.3. If a permissionless blockchain protocol is secure

in the partially synchronous setting, then it produces certiﬁcates.

Since it will be easily observed that the production of certiﬁcates
implies security, Theorem 3.3 shows that, in the partially synchro-
nous setting, the production of certiﬁcates is actually equivalent to
security.

The synchronous setting. What about Bitcoin? While Bitcoin
does not satisfy the conditions of Theorem 3.3, it clearly has some
non-trivial security. The standard formalisation in the literature
[10, 17] is that Bitcoin is secure in the synchronous setting, for
which there is an upper bound on message delivery time.5 Even
working in the synchronous setting, though, it is clear that Bitcoin
does not produce certiﬁcates. Again, we are led to ask whether this
is a necessary consequence of the paradigm of protocol design:

Q2. Could there be a Bitcoin-like protocol that, at least in the
synchronous setting, has as strong a security guarantee in
terms of the production of certiﬁcates as BFT-type protocols
do in the partially synchronous setting?

The answer depends on key features of the resource pool – recall
that the resource pool speciﬁes a balance for each user over the
duration of the protocol execution, such as hashrate or stake. The
crucial distinction here is between scenarios in which the size of
the resource pool is known (e.g. PoS), and scenarios where the size
of the resource pool is unknown (e.g. PoW). As per the framework
in [12], we will refer to these as the sized and unsized settings,
respectively – formal deﬁnitions will be given in Section 5. As al-
luded to above, we deﬁne a protocol to be adaptive if it is is live in
the unsized setting, and it was shown in [12] that adaptive proto-
cols cannot be secure in the partially synchronous setting.

The synchronous and unsized setting. The term “non-trivial
adversary”, which is used in Theorem 5.1 below, will be deﬁned
in Section 5 so as to formalise the idea that the adversary may
have at least a certain minimum resource balance throughout the
execution. With these basic deﬁnitions in place, we can then give
a negative answer to Q2.

5The synchronous setting will be further explained and formally deﬁned in Section 2.

THEOREM 5.1 Consider the synchronous and unsized setting. If
a permissionless blockchain protocol is live then, in the presence of a
non-trivial adversary, it does not produce certiﬁcates.

So, while Theorem 3.3 showed that the production of certiﬁ-
cates is necessary in the partially synchronous setting, Theorem
5.1 shows that the production of certiﬁcates isn’t possible in the
unsized setting (in which PoW protocols like Bitcoin operate). Fol-
lowing on from our previous discussion regarding the relevance of
certiﬁcates to sharding, one direct application of this result is that
it rules out certain approaches to sharding for PoW protocols.

The synchronous and sized setting. In the sized setting (such
as for PoS protocols), though, it is certainly possible for protocols
to produce certiﬁcates. It therefore becomes a natural question to
ask how far we can push this:

Q3. Does the production of certiﬁcates come down purely to
properties of the process of user selection? Is it simply a
matter of whether one is in the sized or unsized setting?

Our ﬁnal theorem gives a form of positive response to Q3. We state
an informal version of the theorem below. A formal version will be
given in Section 5.

THEOREM 5.6 (INFORMAL VERSION). Consider the synchro-
nous and sized setting, and suppose a permissionless blockchain pro-
tocol is of ‘standard form’. Then there exists a ‘recalibration’ of the
protocol which produces certiﬁcates.

Theorem 5.6 says, in particular, that all ‘standard’ PoS protocols
can be tweaked to get the strongest possible security guarantee,
since being of ‘standard form’ will entail satisfaction of a number
of conditions that are normal for such protocols. Roughly speak-
ing, one protocol will be considered to be a recalibration of an-
other if running the former just involves running the latter for
a computable transformation of the input parameters and/or us-
ing a diﬀerent notion of block conﬁrmation. The example of Snow
White [3] may be instructive here (for the purposes of this example,
the particulars of the Snow White protocol are not important – all
that matters is that, at a high level, Snow White might be seen as a
PoS version of Bitcoin, but with the fundamental diﬀerences that it
operates in the sized setting, and that blocks have non-manipulable
timestamps). Snow White is a PoS longest chain protocol, and it is
not diﬃcult to see that, with the standard notion of conﬁrmation,
it does not produce certiﬁcates – an adversary can produce chains
of blocks which are not conﬁrmed, but which would be considered
conﬁrmed in the absence of other blocks which have been broad-
cast. So whether a block is conﬁrmed depends on the whole set of
broadcast messages. On the other hand, it is also not diﬃcult to ad-
just the notion of conﬁrmation so that Snow White does produce
certiﬁcates. An example would be to consider a block conﬁrmed
when it belongs to a long chain of suﬃcient density (meaning that
it has members corresponding to most possible timeslots) that it
could not likely be produced by a (suﬃciently bounded) adversary.
We will see further examples like this explained in greater depth
in Section 5. Theorem 5.6 implies much more generally that PoS
protocols can always be modiﬁed so as to produce certiﬁcates in
this way.

The punchline. Whether or not a permissionless blockchain pro-
tocol produces certiﬁcates comes down essentially to whether one
is working in the sized or unsized setting (e.g. whether the proto-
col is PoS or PoW). This follows from the following results that we
described above:

(i) According to the results of [12], only protocols which work
in the sized setting can be secure in the partially synchro-
nous setting. According to Theorem 3.3, all such protocols
produce certiﬁcates.

(ii) Theorem 5.1 tells us that, in the synchronous and unsized

setting, protocols cannot produce certiﬁcates.

(iii) Theorem 5.6 tells us that all standard protocols in the sized
and synchronous setting can be recalibrated to produce cer-
tiﬁcates.

1.2 Related work
There are a variety of papers from the distributed computing liter-
ature that analyse settings somewhere between the permissioned
and permissionless settings as considered here. In [15], for exam-
ple, Okun considered a setting which a ﬁxed number of processors
communicate by private channels, where each processor may or
may not have a unique identiﬁer, and where processors may or
may not be ‘port aware’, i.e. be able to tell which channel a mes-
sage arrives from. A number of papers [1, 6] have also considered
the problem of reaching consensus amongst unknown participants
(CUP). In the framework considered in those papers, the number
and the identiﬁers of other participants may be unknown from the
start of the protocol execution. A fundamental diﬀerence with the
permissionless setting considered here is that, in the CUP frame-
work, all participants have a unique identiﬁer and the adversary is
unable to obtain additional identiﬁers to be able to launch a sybil
attack against the system, i.e. the number of identiﬁers controlled
by the adversary is bounded.

The Bitcoin protocol was ﬁrst described in 2008 [14]. Since then,
a number of papers [10, 16] have developed frameworks for the
analysis of Bitcoin in which oracles are introduced for modelling
PoW. A more general form of oracle is required for modelling PoS
and other forms of permissionless protocol, however. In [12] a frame-
work was introduced that described a generalised form for such
oracles. We use that framework in this paper, but also develop that
framework in Sections 2.4, 2.5, 2.7, 2.8 and 4.3 to be appropriate
speciﬁcally for the analysis of blockchain protocols.

2 THE FRAMEWORK
We work within the framework of [12]. While we describe the
framework in its entirety here, we refer the reader to the the origi-
nal paper for further examples and explanations of the framework
set-up. Within Section 2, it is the deﬁnitions of Sections 2.4, 2.5, 2.7
and 2.8 that are new to this paper (all deﬁnitions of Sections 3, 4
and 5 are also new to this paper).

Most of this section can be brieﬂy summed up as follows – all
undeﬁned terms in the below will be formalised and deﬁned in
later subsections.

• Protocols are executed by an unknown number of users,
each of which is formalised as a deterministic processor that
controls a set of public keys.

• Processors have the ability to broadcast messages to all other
processors. The duration of the execution, however, may be
divided into synchronous or asynchronous intervals. During
asynchronous intervals, an adversary can tamper with mes-
sage delivery as they choose. During synchronous intervals
there is a given upper bound on message delivery time. We
then distinguish two synchronicity settings. In the synchro-
nous setting it is assumed that there are no asynchronous in-
tervals, while in the partially synchronous setting there may
be unpredictably long asynchronous intervals.

• Amongst all broadcast messages, there is a distinguished set
referred to as blocks, and one block which is referred to as
the genesis block. Unless it is the genesis block, each block
𝐵 has a unique parent block.

• To blackbox the process of user selection, whereby certain
users are selected and given the task of updating state, [12]
introduces two new notions: (1) Each public key is consid-
ered to have a certain resource balance, which may vary over
the execution, and; (2) The protocol will also be run relative
to a permitter oracle, which may respond to this resource bal-
ance. For a PoW protocol like Bitcoin, the resource balance
of each public key will be their (relevant) computational
power at the given timeslot.

• It is the permitter oracle which then gives permission to
broadcast messages updating state. To model Bitcoin, for ex-
ample, we sometimes have the permitter allow another user
to broadcast a new block, with the probability this happens
for each user being proportional to their resource balance.
• Liveness and security are deﬁned in terms of a notion of con-
ﬁrmation for blocks. Roughly, a protocol is live if the number
of conﬁrmed blocks can be relied on to increase during ex-
tended intervals of time during which message delivery is
reliable. A protocol is secure if rollback on conﬁrmed blocks
is unlikely.

2.1 The computational model
Overview. There are a number of papers analysing Bitcoin [10, 16]
that take the approach of working within the language of the UC
framework of Canetti [5]. Our position is that this provides a sub-
stantial barrier to entry for researchers in blockchain who do not
have a strong background in security, and that the power of the
UC framework remains essentially unused in the subsequent anal-
ysis. Instead, we use a very simple computational model, which
is designed to be as similar as possible to standard models from
distributed computing (e.g. [9]), while also being adapted to deal
with the permissionless setting. We thus consider an information
theoretic model in which processors are simply speciﬁed by state
transition diagrams. A permitter oracle is introduced as a generali-
sation of the random oracle functionality in the Bitcoin Backbone
paper [10]: It is the permitter oracle’s role to grant permissions to
broadcast messages. The duration of the execution is divided into
timeslots. Each processor enters each timeslot 𝑡 in a given state 𝑥,
which determines the instructions for the processor in that times-
lot – those instructions may involve broadcasting messages, as well

as sending requests to the permitter oracle. The state 𝑥 ′ of the pro-
cessor at the next timeslot is determined by the state 𝑥, together
with the messages and permissions received at 𝑡.

Since we focus on impossibility results, we simplify the presen-
tation by making the assumption that we are always working in
the authenticated setting, in which processors have access to pub-
lic/private key pairs. This assumption is made purely for the sake
of simplicity, and the results of the paper do not depend upon it.

Formal description. For a list of commonly used variables and
terms, see Table 1 in the appendix. We consider a ﬁnite6 system
of processors. Each processor 𝑝 is speciﬁed by a state transition dia-
gram, for which the number of states may be inﬁnite. Amongst the
states of a processor are a non-empty set of possible initial states.
The inputs to 𝑝 determine which initial state it starts in. If a vari-
able is speciﬁed as an input to 𝑝, then we refer to it as determined
for 𝑝, referring to the variable as undetermined for 𝑝 otherwise.
If a variable is determined/undetermined for all 𝑝, we simply re-
fer to it as determined/undetermined. Amongst the inputs to 𝑝 is
an inﬁnite set U𝑝 of public keys, which are speciﬁc to 𝑝 in the
sense that if U ∈ U𝑝 and U′ ∈ U𝑝′ then U ≠ U′ when 𝑝 ≠ 𝑝 ′.
A principal diﬀerence between the permissionless setting (as con-
sidered here) and the permissioned setting (as studied in classical
distributed computing) is that, in the permissionless setting, the
number of processors is undetermined, and U𝑝 is undetermined
for 𝑝 ′ when 𝑝 ′ ≠ 𝑝.

Processors are able to broadcast messages. To model permission-
less protocols, such as Bitcoin, in which each processor has limited
ability to broadcast new blocks (and possibly other messages), we
require any message broadcast by 𝑝 to be permitted for some public
key in U𝑝 : The precise details are as follows. We consider a real-
time clock, which exists outside the system and measures time in
natural number timeslots. The duration D is a determined variable
that speciﬁes the set of timeslots (an initial segment of the natu-
ral numbers) at which processors carry out instructions. At each
timeslot 𝑡, each processor 𝑝 receives a pair (𝑀, 𝑃), where either or
both of 𝑀 and 𝑃 may be empty. Here, 𝑀 is a ﬁnite set of messages
(i.e. strings) that have previously been broadcast by other proces-
sors. We refer to 𝑀 as the message set received by 𝑝 at 𝑡, and say
that each message 𝑚 ∈ 𝑀 is received by 𝑝 at timeslot 𝑡. 𝑃 is referred
to as the permission set received by 𝑝 at 𝑡. Formally, 𝑃 is a set of
pairs, where each pair is of the form (U, 𝑀∗) such that U ∈ U𝑝 and
𝑀∗ is a potentially inﬁnite set of messages. If (U, 𝑀∗) ∈ 𝑃, then re-
ceipt of the permission set 𝑃 means that each message 𝑚 ∈ 𝑀∗ may
now be permitted for U. This is complicated slightly by our need
to model the authenticated setting within an information theoretic
model – we do this by declaring that only 𝑝 is permitted to broad-
cast messages signed by keys in U𝑝 . More precisely, 𝑚 ∈ 𝑀∗ is
permitted for U if the following conditions are also satisﬁed:

• 𝑚 is of the form (U, 𝜎) – thought of as ‘the message 𝜎 signed

by U’.

6In [12], a potentially inﬁnite number of processors were allowed, but each processor
was given a single public key (identiﬁer). Here, we will ﬁnd it convenient to consider
instead a ﬁnite number of processors, each of which may control an unbounded num-
ber of public keys.

• For any ordered pair of the form (U′, 𝜎 ′) contained in (i.e.
which is a substring of) 𝜎, either U′ ∈ U𝑝 , or else (U′, 𝜎 ′) is
contained in a message that has been received by 𝑝.

So, as suggested in the above, the latter bulleted conditions allow
us to model the fact that we work in the authenticated setting (i.e.
we assume the use of digital signatures) within an information the-
oretic computational model.

To complete the instructions for timeslot 𝑡, 𝑝 then broadcasts
a ﬁnite set of messages 𝑀 ′, each of which must be permitted for
some U ∈ U𝑝 , makes a request set 𝑅, and then enters a new state
𝑥 ′, where 𝑥 ′, 𝑀 ′ and 𝑅 are determined by the present state 𝑥 and
(𝑀, 𝑃), according to the state transition diagram. The form of the
request set 𝑅 will be described shortly, together with how 𝑅 deter-
mines the permission set received at by 𝑝 at the next timeslot.

An execution is described by specifying the set of processors, the
duration, the initial states for all processors and by specifying, for
each timeslot 𝑡 ≥ 1:

(1) The messages and permission sets received by each proces-

sor;

(2) The instruction that each processor executes, i.e. what mes-
sages it broadcasts, what requests it makes, and the new
state it enters.

We require that each message is received by 𝑝 at most once
for each time it is broadcast, i.e. at the end of the execution it
must be possible to specify an injective function 𝑑𝑝 mapping each
pair (𝑚, 𝑡), such that 𝑚 is received by 𝑝 at timeslot 𝑡, to a triple
(𝑝 ′, 𝑚, 𝑡 ′), such that 𝑡 ′ < 𝑡, 𝑝 ′ ≠ 𝑝 and such that 𝑝 ′ broadcast 𝑚 at
𝑡 ′.

2.2 The resource pool and the permitter
Informal Motivation. Who should be allowed to create and broad-
cast new Bitcoin blocks? More broadly, when deﬁning a permis-
sionless protocol, who should be able to broadcast new messages?
For a PoW protocol, the selection is made depending on compu-
tational power. PoS protocols are deﬁned in the context of speci-
fying how to run a currency, and select public keys according to
their stake in the given currency. More generally, one may consider
a scarce resource, and then select public keys according to their
corresponding resource balance. In [12], a framework was intro-
duced according to which protocols run relative to a resource pool,
which speciﬁes a resource balance for each public key over the
duration of the execution. The precise way in which the resource
pool is used to determine public key selection is then black boxed
through the use of the permitter oracle, to which processors can
make requests to broadcast, and which will respond depending on
their resource balance. To model Bitcoin, for example, one simply
allows each public key to make one request to broadcast a block at
each timeslot. The permitter oracle then gives a positive response
with probability depending on their resource balance, which in this
case is deﬁned by hashrate. So, this gives a straightforward way to
model the process, without the need for a detailed discussion of
hash functions and how they are used to instantiate the selection
process.

the message state of 𝑝. Each execution happens relative to a (deter-
mined or undetermined) resource pool,7 which in the general case
is a function R : U × D × M → R≥0, where U is the set of
all public keys, D is the duration and M is the set of all possible
sets of messages. R can be thought of as specifying the resource
balance of each public key at each timeslot, possibly relative to a
given message state. For each 𝑡 and 𝑀, we suppose that certain
basic conditions are satisﬁed:

Í

U R (U, 𝑡, 𝑀) > 0.

(a) If R (U, 𝑡, 𝑀) ≠ 0 then U ∈ U𝑝 for some processor 𝑝;
(b) There are ﬁnitely many U for which R (U, 𝑡, 𝑀) ≠ 0, and;
(c)
Suppose that, after receiving messages and a permission set at
timeslot 𝑡, 𝑝’s message state is 𝑀0, and that 𝑀∗
0 is the set of all
messages that are permitted for 𝑝 (i.e. for some U ∈ U𝑝 ). We con-
sider two settings – the timed and untimed settings. The form of
each request 𝑟 ∈ 𝑅 made by 𝑝 at timeslot 𝑡 depends on the setting,
as speciﬁed below. While the following deﬁnitions might initially
seem abstract, shortly we will give examples to make things clear.
• The untimed setting. Here, each request 𝑟 made by 𝑝 must
be of the form (U, 𝑀, 𝐴), where U ∈ U𝑝 , 𝑀 ⊆ 𝑀0 ∪ 𝑀∗
0 , and
where 𝐴 is some (possibly empty) extra data. The permitter
oracle will respond with a pair (U, 𝑀∗), where 𝑀∗ is a set
of strings that may be empty. The value of 𝑀∗ will be as-
sumed to be a probabilistic function of the determined vari-
ables, (U, 𝑀, 𝐴), and of R (U, 𝑡, 𝑀), subject to the condition
that 𝑀∗ = ∅ if R (U, 𝑡, 𝑀) = 0. If modelling Bitcoin, for ex-
ample, 𝑀 might be a set of blocks that have been received by
𝑝, or that 𝑝 is already permitted to broadcast, while 𝐴 spec-
iﬁes a new block extending the ‘longest chain’ in 𝑀. If the
block is valid, then the permitter oracle will give permission
to broadcast it with probability depending on the resource
balance of U at time 𝑡. We will expand on this example below.
• The timed setting. Here, each request 𝑟 made by 𝑝 must be
of the form (𝑡 ′, U, 𝑀, 𝐴), where 𝑡 ′ is a timeslot, and where U,
𝑀 and 𝐴 are as in the untimed setting, The response (U, 𝑀∗)
of the permitter oracle will be assumed to be a probabilis-
tic function of the determined variables, (𝑡 ′, U, 𝑀, 𝐴), and of
R (U, 𝑡 ′, 𝑀), subject to the condition that 𝑀∗ = ∅ if R (U, 𝑡 ′, 𝑀) =
0.

The permission set received by 𝑝 at timeslot 𝑡 + 1 is the set all of
responses from the permitter oracle to 𝑝’s requests at timeslot 𝑡.

To understand these deﬁnitions, it is instructive to consider how
they can be used to give a simple model for Bitcoin. To do so, we
work in the untimed setting, and we deﬁne the set of possible mes-
sages to be the set of possible blocks. For each U ∈ U𝑝 , we then
allow 𝑝 to make a single request of the form (U, 𝑀, 𝐴) at each times-
lot. As mentioned above, 𝑀 will be a set of blocks that have been
received by 𝑝, or that 𝑝 is already permitted to broadcast. The entry
𝐴 will be data (without PoW attached) that speciﬁes a block extend-
ing the ‘longest chain’ in 𝑀. If 𝐴 speciﬁes a valid block, then the
permitter oracle will give permission to broadcast the block spec-
iﬁed by 𝐴 with probability depending on the resource balance of
U at time 𝑡 (which is determined by hashrate, and is independent
of 𝑀). So, the higher U’s resource balance at a given timeslot, the

Formal speciﬁcation. At each timeslot 𝑡, we refer to the set of
all messages that have already been received or broadcast by 𝑝 as

7As described more precisely in Section 2.6, whether the resource pool is determined
or undetermined will decide whether we are in the sized or unsized setting.

greater the probability 𝑝 will be able to mine a block at that times-
lot. Of course, a non-faulty processor 𝑝 will always submit requests
of the form (U, 𝑀, 𝐴), for which 𝑀 is 𝑝’s (entire) message state, and
such that 𝐴 speciﬁes a valid block extending the longest chain in
𝑀.8

The motivation for considering the timed as well as the untimed
setting stems from one of the qualitative diﬀerences between PoS
and PoW protocols. PoS protocols are best modelled in the timed
setting, where processors can look ahead to determine their per-
mission to broadcast at future timeslots (when their resource bal-
ance may be diﬀerent than it is at present), i.e. with PoS protocols,
blocks will often have timestamps that cannot be manipulated, and
at a given timeslot, a processor may already be able to determine
that they have permission to broadcast blocks with a number of
diﬀerent future timestamps. This means that, when modelling PoS
protocols, processors have to be able to make requests correspond-
ing to timeslots 𝑡 ′ other than the current timeslot 𝑡. We will specify
further diﬀerences between the timed and untimed settings in Sec-
tion 2.6.

By a permissionless protocol we mean a pair (S, O), where S is
a state transition diagram to be followed by all non-faulty proces-
sors, and where O is a permitter oracle, i.e. a probabilistic function
of the form described for the timed and untimed settings above. It
should be noted that the roles of the resource pool and the permit-
ter oracle are diﬀerent, in the following sense: While the resource
pool is a variable (meaning that a given protocol will be expected
to function with respect to all possible resource pools consistent
with the setting9), the permitter is part of the protocol description.

2.3 The adversary and the synchronous and

partially synchronous settings

While all non-faulty processors follow the state transition diagram
S speciﬁed for the protocol, we allow a single undetermined pro-
cessor 𝑝𝐴 to display Byzantine faults, and we think of 𝑝𝐴 as be-
ing controlled by the adversary: In formal terms, the diﬀerence be-
tween 𝑝𝐴 and other processors is that the state transition diagram
for 𝑝𝐴 might not be S. Placing bounds on the power of the adver-
sary means limiting their resource balance (since U𝑝𝐴 is inﬁnite,
it does not limit the adversary that they control a single processor).
For 𝑞 ∈ [0, 1], we say the adversary is 𝑞-bounded if their total re-
source balance is always at most a 𝑞 fraction of the total, i.e. for all
𝑀, 𝑡,

R (U, 𝑡, 𝑀) ≤ 𝑞 ·

U∈U R (U, 𝑡, 𝑀).

It is standard in the distributed computing literature [13] to con-
sider a variety of synchronous, partially synchronous, or asynchro-
nous settings, in which message delivery might be reliable or sub-
ject to various forms of failure. We will suppose that the dura-
tion is divided into intervals that are labelled either synchronous
or asynchronous (meaning that each timeslot is either synchronous

U∈U𝑝𝐴

Í

Í

or asynchronous). We will suppose that during asynchronous in-
tervals messages can be arbitrarily delayed or not delivered at all.
During synchronous intervals, however, we will suppose that mes-
sages are always delivered within Δ many timeslots. So if 𝑡1 ≤ 𝑡2,
𝑚 is broadcast by 𝑝 at 𝑡1, if 𝑝 ′ ≠ 𝑝 and [𝑡2, 𝑡2 + Δ] is a synchronous
interval contained in D, then 𝑝 ′ will receive 𝑚 by timeslot 𝑡2 + Δ.
Here Δ is a determined variable.

We then distinguish two synchronicity settings. In the synchro-
nous setting it is assumed that there are no asynchronous inter-
vals during the duration, while in the partially synchronous setting
there may be undetermined asynchronous intervals.

It will be useful to consider the notion of a timing rule, by which
we mean a partial function T mapping tuples of the form (𝑝, 𝑝 ′, 𝑚, 𝑡)
to timeslots. We say that an execution follows the timing rule T if
the following holds for all processors 𝑝 and 𝑝 ′: We have that 𝑝 ′
receives 𝑚 at 𝑡 ′ iﬀ there exists some 𝑝 and 𝑡 < 𝑡 ′ such that 𝑝 broad-
casts the message 𝑚 at 𝑡 and T(𝑝, 𝑝 ′, 𝑚, 𝑡) ↓= 𝑡 ′. We restrict atten-
tion to timing rules which are consistent with the setting. Since
protocols will be expected to behave well with respect to all tim-
ing rules consistent with the setting, it will sometimes be useful
to think of the adversary as also having control over the choice of
timing rule.

2.4 The structure of the blockchain
Amongst all broadcast messages, there is a distinguished set re-
ferred to as blocks, and one block which is referred to as the gene-
sis block. Unless it is the genesis block, each block 𝐵 has a unique
parent block Par(𝐵), which must be uniquely speciﬁed within the
block message. Each block is signed and broadcast by a single key,
Miner(𝐵), but may contain other broadcast messages which have
been signed and broadcast by other keys. No block can be broad-
cast by the processor 𝑝 that controls Miner(𝐵) at a point strictly
prior to that at which its parent enters 𝑝’s message state (it is conve-
nient to consider the genesis block a member of all message states
at all timeslots). Par(𝐵) is deﬁned to be an ancestor of 𝐵, and all
of the ancestors of Par(𝐵) are also deﬁned to be ancestors of 𝐵. If
𝐵 is not the genesis block, then it must have the genesis block as
an ancestor. At any point during the duration, the set of broadcast
blocks thus forms a tree structure. If 𝑀 is a set of messages, then
we say that it is downward closed if it contains the parents of all
blocks in 𝑀. By a leaf of 𝑀, we mean a block in 𝑀 which is not
a parent of any block in 𝑀. If 𝑀 is downward closed set of blocks
and contains a single leaf, then we say that 𝑀 is a chain.

Generalising the model to DAGs. It is only for the sake of
simplicity that we assume each block has a unique parent block.
The model is chosen to be a sweet spot of being expressible enough
to capture many diﬀerent types of blockchains and not so cumber-
some as to obscure the main issues. Only small modiﬁcations are
then required to deal with DAGS etc.

8So, in this simple model, we don’t deal with any notion of a ‘transaction’. It is clear,
though, that the model is suﬃcient to be able to deﬁne what it means for blocks to be
conﬁrmed, to deﬁne notions of liveness (roughly, that the set of conﬁrmed blocks grows
over time with high probability) and security (roughly, that with high probability, the
set of conﬁrmed blocks is monotonically increasing over time), and to prove liveness
and security for the Bitcoin protocol in this model (by importing existing proofs, such
as that in [10]).
9Generally, protocols will be considered in a setting that restricts the set of resource
pools in certain ways, such as limiting the resource balance of the adversary.

2.5 The extended protocol and the meaning of

probabilistic statements

To deﬁne what it means for a protocol to be secure or live, we
ﬁrst need a notion of conﬁrmation for blocks. This is a function
C mapping any message state to a chain that is a subset of that
message state, in a manner that depends on the protocol inputs,

including a parameter 𝜀 > 0 called the security parameter. The
intuition behind 𝜀 is that it should upper bound the probability of
false conﬁrmation. Given any message state, C returns the set of
conﬁrmed blocks.

In Section 2.2, we stipulated that a permissionless protocol is a
pair P = (S, O). In general, however, a protocol might only be con-
sidered to run relative to a speciﬁc notion of conﬁrmation C. We
will refer to the triple (S, O, C) as the extended protocol. Often we
will suppress explicit mention of C, and assume it to be implicitly
attached to a given protocol. We will talk about a protocol being
live, for example, when it is really the extended protocol to which
the deﬁnition applies. It is important to understand, however, that
the notion of conﬁrmation C is separate from P, and does not im-
pact the instructions of the protocol. In principle, one can run the
same Bitcoin protocol relative to a range of diﬀerent notions of
conﬁrmation. While the set of conﬁrmed blocks might depend on
C, the instructions of the protocol do not, i.e. with Bitcoin, one can
require ﬁve blocks for conﬁrmation or ten, but this does not aﬀect
the process of building the blockchain.

For a given permissionless protocol, another way to completely
specify an execution (beyond that described in Section 2.1) is via
the following breakdown:

(I1) The determined variables (such as Δ and 𝜀);
(I2) The set of processors and their public keys;
(I3) The state transition diagram for the adversary 𝑝𝐴;
(I4) The resource pool (which may or may not be undetermined);
(I5) The timing rule;
(I6) The probabilistic responses of the permitter.
With respect to the extended protocol (S, O, C), we call a partic-
ular set of choices for (I1)- (I5) a protocol instance. Generally, when
we discuss an extended protocol, we do so within the context of a
setting, which constrains the set of possible protocol instances. The
setting might restrict the set of resource pools to those in which the
adversary is given a limited resource balance, for example. When
we make a probabilistic statement to the eﬀect that a certain condi-
tion holds with at most/least a certain probability, this means that
the probabilisitic bound holds for all protocol instances consistent
with the setting. Where convenient, we may also refer to the pair
(P, C) as the extended protocol, where P = (S, O).

2.6 Deﬁning the timed, sized and
multi-permitter settings

In Section 2.2, we gave an example to show how the framework
of [12] can be used to model a PoW protocol like Bitcoin. In that
context the resource pool is a function R : U × D → R≥0, which
is best modelled as undetermined, because one does not know in
advance how the hashrate of each public key (or even the total
hashrate) will vary over time. The ﬁrst major diﬀerence for a PoS
protocol is that the resource balance of each public key now de-
pends on the message state (as is also the case for some proof-
of-space protocols, depending on the implementation), and may
also be a function of time.10 So the resource pool is a function

10It is standard practice in PoS blockchain protocols to require a participant to have
a currency balance that has been recorded in the blockchain for at least a certain
minimum amount of time before they can produce new blocks, for example. So, a

R : U × D × M → R≥0. A second diﬀerence is that R is deter-
mined, because one knows from the start how the resource balance
of each participant depends on the message state as a function of
time. Note that advance knowledge of R does not mean that one
knows from the start which processors will have large resource
balances throughout the execution, unless one knows which mes-
sages will be broadcast. A third diﬀerence, to which we have al-
ready alluded, is that PoS protocols are best modelled in the timed
setting. A fourth diﬀerence is that PoW protocols are best mod-
elled by allowing a single request to the oracle for each public key
at each timeslot, while this is not necessarily true of PoS protocols.

In [12], the sized/unsized, timed/untimed, and single/multi-permitter

settings were deﬁned to succinctly capture these diﬀerences. The
idea is that all permissionless protocols run relative to a resource
pool and the diﬀerence between PoW and PoS and other permis-
sionless protocols is whether we are working in the sized/unsized,
timed/untimed, and single/multi-permitter settings. If one then comes
to consider a new form of protocol, such as proof-of-space, theo-
rems that have been proved for all protocols in the unsized setting
(for example) will still apply, so long as these new protocols are ap-
propriately modelled in that setting. So the point of this approach
is that, by blackboxing the precise mechanics of the processor se-
lection process (whereby processors are selected to do things like
broadcast new blocks of transactions), we are able to focus instead
on properties of the selection process that are relevant for protocol
design. This allows for the development of a general theory that
succinctly describes the relevant merits of diﬀerent forms of proto-
col. The sized/unsized, timed/untimed, and single/multi-permitter
settings are deﬁned below.

(1) The timed and untimed settings. There are two diﬀer-
ences between the timed and untimed settings. The ﬁrst
concerns the form of requests, as detailed in Section 2.2. We
also require that the following holds in the timed setting: For
each broadcast message 𝑚, there exists a unique timeslot 𝑡𝑚
such that permission to broadcast 𝑚 was given in response
to some request (𝑡𝑚, U, 𝑀, 𝐴), and 𝑡𝑚 is computable from 𝑚.
We call 𝑡𝑚 the timestamp of 𝑚.

(2) The sized and unsized settings. We call the setting sized
if the resource balance is determined. By the total resource
balance we mean the function T : N × M → R>0 deﬁned
ÍU R (U, 𝑡, 𝑀). For the unsized setting, R and
by T (𝑡, 𝑀) :=
T are undetermined, with the only restrictions being:
(i) T only takes values in a determined interval [𝛼0, 𝛼1], where
𝛼0 > 0 (meaning that, although 𝛼0 and 𝛼1 are determined,
protocols will be required to function for all possible 𝛼0 >
0 and 𝛼1 > 𝛼0, and for all undetermined R consistent with
𝛼0, 𝛼1, subject to (ii) below).11

(ii) There may also be bounds placed on the resource balance

of public keys owned by the adversary.

given participant may not be permitted to extend a given chain of blocks at timeslot
𝑡, but may be permitted to extend the same chain at a later timeslot 𝑡 ′.
11We consider resource pools with range restricted in this way, because it turns out
to be an overly strong condition to require a protocol to function without any further
conditions on the resource pool, beyond the fact that it is a function to R≥0. Bitcoin
will certainly fail if the total resource balance decreases suﬃciently quickly over time,
or if it increases too quickly, causing blocks to be produced too quickly compared to
Δ.

(3) The multi-permitter and single-permitter settings. In
the single-permitter setting, each processor may submit a
single request of the form (U, 𝑀, 𝐴) or (𝑡, U, 𝑀, 𝐴) (depend-
ing on whether we are in the timed setting or not) for each
U ∈ U𝑝 at each timeslot, and it is allowed that 𝐴 ≠ ∅. In the
multi-permitter setting, processors can submit any number
of requests for each key at each timeslot, but they must all
satisfy the condition that 𝐴 = ∅.

PoW protocols will generally be best modelled in the untimed,
unsized and single-permitter settings. They are best modelled in
the untimed setting, because a processor’s probability of being granted
permission to broadcast a block at timeslot 𝑡 (even if that block
has a diﬀerent timestamp) depends on their resource balance at 𝑡,
rather than at any other timeslot. They are best modelled in the
unsized setting, because one does not know in advance of the pro-
tocol execution the amount of mining which will take place at a
given timeslot in the future. They are best modelled in the single-
permitter setting, so long as permission to broadcast is block-speciﬁc.
PoS protocols are generally best modelled in the timed, sized
and multi-permitter settings. They are best modelled in the timed
setting, because blocks will generally have non-manipulable times-
tamps, and because a processor’s ability to broadcast a block may
be determined at a timestamp 𝑡 even through the probability of
success depends on their resource balance at 𝑡 ′ other than 𝑡. They
are best modelled in the sized setting, because the resource pool
is known from the start of the protocol execution. They are best
modelled in the multi-permitter setting, so long as permission to
broadcast is not block-speciﬁc, i.e. when permission is granted, it
is to broadcast a range of permissible blocks at a given position in
the blockchain.

All of this means that it will generally be straightforward to clas-
sify protocols with respect to the theorems from this paper that ap-
ply to them. Since Bitcoin and Prism [2] are PoW protocols, for ex-
ample, Theorem 5.1 applies to those protocols. Since Snow White,
Ouroboros [11] and Algorand are PoS protocols, Theorems 3.3 and
5.6 apply to those protocols. Note that there are a large number
of protocols, such as Tendermint [4] and Hotstuﬀ [18], which are
formally described as permissioned protocols, but which can be im-
plemented as PoS protocols so that Theorems 3.3 and 5.6 will then
apply.

2.7 Deﬁning liveness
There are a number of papers that successfully describe liveness
and security notions for blockchain protocols [10, 16]. Our interest
here is in identifying the simplest deﬁnitions that suﬃce to express
our later results. To this end, it will be convenient to give a deﬁni-
tion of liveness that is more ﬁne-grained than previous deﬁnitions,
in the sense that it allows us to separate out the security parameter
and the number of timeslots in the duration (in previous accounts
the number of timeslots in the duration is a function of the secu-
rity parameter). Consider a protocol with a notion of conﬁrmation
C, and let |C(𝑀)| denote the number of blocks in C(𝑀) for any mes-
sage state 𝑀. For timeslots 𝑡1 < 𝑡2, let 𝑙1 be the maximum value
|C(𝑀1)| for any 𝑀1 which is a message state of any processor at
any timeslot 𝑡 ≤ 𝑡1, and let 𝑙2 be the minimum value |C(𝑀2)| for
any 𝑀2 which is a message state of any processor at timeslot 𝑡2.

We say that [𝑡1, 𝑡2] is a growth interval if 𝑙2 > 𝑙1. For any duration
D, let |D| be the number of timeslots in D. For ℓ𝜀,D which takes
values in N depending on 𝜀 and D, let us say that ℓ𝜀,D is sublin-
ear in D if, for each 𝜀 > 0 and each 𝛼 ∈ (0, 1), ℓ𝜀,D < 𝛼 |D| for
all suﬃciently large values of |D| (the motivation for considering
sublinearity will be described shortly).

Deﬁnition 2.1. A protocol is live if, for every choice of security
parameter 𝜀 > 0 and duration D, there exists ℓ𝜀,D, which is sublin-
ear in D, and such that for each pair of timeslots 𝑡1 < 𝑡2 ∈ D the
following holds with probability at least 1 − 𝜀: If 𝑡2 − 𝑡1 ≥ ℓ𝜀,D and
[𝑡1, 𝑡2] is entirely synchronous, then [𝑡1, 𝑡2] is a growth interval.

So, roughly speaking, a protocol is live if the number of conﬁrmed
blocks can be relied on to grow during synchronous intervals of
suﬃcient length. The reason we require ℓ𝜀,D to be sublinear in D
is so that the number of conﬁrmed blocks likely increases with suf-
ﬁcient increase in synchronous duration. For example, a protocol
that conﬁrms a block with probability only 2− | D | at each timeslot
should not be considered live. Note also, that while Deﬁnition 2.1
only refers explicitly to protocols, it is really the extended protocol
to which the deﬁnition applies. The following stronger notion will
also be useful.

Deﬁnition 2.2. A protocol is uniformly live if, for every choice
of security parameter 𝜀 > 0 and duration D, there exists ℓ𝜀,D,
which is sublinear in D, and such that the following holds with
probability at least 1 − 𝜀: For all pairs of timeslots 𝑡1 < 𝑡2 ∈ D, if
𝑡2 − 𝑡1 ≥ ℓ𝜀,D and [𝑡1, 𝑡2] is entirely synchronous, then [𝑡1, 𝑡2] is a
growth interval.

The diﬀerence between being live and uniformly live is that the
latter deﬁnition requires that, with probability at least 1 − 𝜀, all
appropriate intervals are growth intervals. The former deﬁnition
only requires the probabilistic bound to hold for each interval indi-
vidually. The reader’s immediate reaction might be that it should
follow from the Union Bound that Deﬁnitions 2.1 and 2.2 are essen-
tially equivalent. This is not so. Firstly, this is because the protocol
and notion of conﬁrmation take the security parameter 𝜀 as input.
Nevertheless, one might think that if a protocol is live then a ‘re-
calibration’, which takes some appropriate transformation of the
security parameter as input, should necessarily be uniformly live.
This does not follow (in part) because there is no guarantee that the
resulting ℓ𝜀,D will be sublinear in D – see Section 4 for a detailed
analysis.

2.8 Deﬁning security
Roughly speaking, security requires that conﬁrmed blocks normally
belong to the same chain. Let us say that two distinct blocks are in-
compatible if neither is an ancestor of the other, and are compatible
otherwise. Suppose that, for some processor 𝑝, the message state
at 𝑡 is 𝑀. If 𝐵 ∈ C(𝑀), then we say that 𝐵 is conﬁrmed for 𝑝 at 𝑡.

Deﬁnition 2.3 (Security). A protocol is secure if the following
holds for every choice of security parameter 𝜀 > 0, for every 𝑝1, 𝑝2
and for all timeslots 𝑡1, 𝑡2 in the duration: With probability > 1 − 𝜀,
all blocks which are conﬁrmed for 𝑝1 at 𝑡1 are compatible with all
those which are conﬁrmed for 𝑝2 at 𝑡2.

The following stronger notion will also be useful.

Deﬁnition 2.4 (Uniform Security). A protocol is uniformly se-
cure if the following holds for every choice of security parameter
𝜀 > 0: With probability > 1 − 𝜀, there do not exist incompatible
blocks 𝐵1, 𝐵2, timeslots 𝑡1, 𝑡2 and 𝑝1, 𝑝2 such that 𝐵𝑖 is conﬁrmed
for 𝑝𝑖 at 𝑡𝑖 for 𝑖 ∈ {1, 2}.

The diﬀerence between security and uniform security is that the
latter requires the probability of even a single disagreement to be
bounded, while the former only bounds the probability of disagree-
ment for each pair of processors at each timeslot pair. Just as for
liveness and uniform liveness, it does not follow from the Union
Bound that security is essentially equivalent to uniform security.
In Section 4 we will perform a detailed analysis of the relationship
between these notions.

3 CERTIFICATES IN THE PARTIALLY

SYNCHRONOUS SETTING

The deﬁnitions of this and subsequent sections are all new to this
paper, unless explicitly stated otherwise. The rough idea is that
‘certiﬁcates’ should be proofs of conﬁrmation. Towards formalis-
ing this idea, let us ﬁrst consider a version which is too weak.

Deﬁnition 3.1. If 𝐵 ∈ C(𝑀) then we refer to 𝑀 as a subjective

certiﬁcate for 𝐵.

We will say that a set of messages 𝑀 is broadcast if every member
is broadcast, and that 𝑀 is broadcast by timeslot 𝑡 if every member
of 𝑀 is broadcast at a timeslot ≤ 𝑡 (diﬀerent members potentially
being broadcast at diﬀerent timeslots). If 𝑀 is a subjective certiﬁ-
cate for 𝐵, then there might exist 𝑀 ′ ⊃ 𝑀 for which 𝐵 ∉ C(𝑀 ′).
So the fact that 𝑀 is broadcast does not constitute proof that 𝐵 is
conﬁrmed with respect to any processor. When do we get harder
forms of proof than subjective certiﬁcates? Deﬁnition 3.2 below
gives a natural and very simple way of formalising this.

Deﬁnition 3.2. We say that a protocol with a notion of conﬁr-
mation C produces certiﬁcates if the following holds with prob-
ability > 1 − 𝜀 when the protocol is run with security parame-
ter 𝜀: There do not exist incompatible blocks 𝐵1, 𝐵2, a timeslot 𝑡
and 𝑀1, 𝑀2 which are broadcast by 𝑡, such that 𝐵𝑖 ∈ C(𝑀𝑖 ) for
𝑖 ∈ {1, 2}.

It is important to stress that, in the deﬁnition above, the 𝑀𝑖 ’s are
not necessarily the message states of any processor, but are rather
arbitrary subsets of the set of all broadcast messages. The basic
idea is that, if a protocol produces certiﬁcates, then subjective cer-
tiﬁcates constitute proof of conﬁrmation. Algorand is an example
of a protocol which produces certiﬁcates: The protocol is designed
so that it is unlikely that two incompatible blocks will be produced
at any point in the duration together with appropriate committee
signatures verifying conﬁrmation for each.

Our next aim is to show that, in the partially synchronous set-
ting, producing certiﬁcates is equivalent to security. In fact, produc-
ing certiﬁcates is clearly at least as strong as uniform security, so
it suﬃces to show that if a protocol is secure then it must produce
certiﬁcates.

Theorem 3.3. If a protocol is secure in the partially synchronous

Proof. Towards a contradiction, suppose that the protocol with
notion of conﬁrmation C is secure in the partially synchronous set-
ting, but that there exists a protocol instance12 In1 with security
parameter 𝜀, such that the following holds with probability ≥ 𝜀:
There exist incompatible blocks 𝐵1, 𝐵2, a timeslot 𝑡 and 𝑀1, 𝑀2
which are broadcast by 𝑡, such that 𝐵𝑖 ∈ C(𝑀𝑖 ) for 𝑖 ∈ {1, 2}.
This means that the following holds with probability ≥ 𝜀 for 𝑡last,
which is the last timeslot in the duration: There exist incompati-
ble blocks 𝐵1, 𝐵2 and 𝑀1, 𝑀2 which are broadcast by 𝑡last, such that
𝐵𝑖 ∈ C(𝑀𝑖 ) for 𝑖 ∈ {1, 2}. Consider the protocol instance In2 which
has the same values for determined variables as In1, the same state
transition diagram for the processor of the adversary and the same
set of processors with the same set of public keys, except that now
there are two extra processors 𝑝1 and 𝑝2. Suppose that the resource
pool for In2 is the same as that for In1 when restricted to public
keys other than those in U𝑝1 and U𝑝2 , and that all keys in U𝑝1 and
U𝑝2 have zero resource balance throughout the duration. Suppose
further, that the timing rule for In2 is the same as that for In1
when restricted to tuples (𝑝, 𝑝 ′, 𝑚, 𝑡) such that 𝑝 ∉ {𝑝1, 𝑝2} and
𝑝 ′ ∉ {𝑝1, 𝑝2}, but that now all timeslots are asynchronous. Accord-
ing to the deﬁnition of Section 2.2, and since all keys in U𝑝1 and
U𝑝2 have zero resource balance throughout the duration, it follows
by induction on timeslots that the probability distribution on the
set of broadcast messages is the same at each timeslot for In2 as for
In1, independent of which messages are received by 𝑝1 and 𝑝2. It
therefore holds for the protocol instance In2 that with probability
≥ 𝜀 there exist incompatible blocks 𝐵1, 𝐵2, and 𝑀1, 𝑀2 which are
broadcast by 𝑡last, such that 𝐵𝑖 ∈ C(𝑀𝑖 ) for 𝑖 ∈ {1, 2}. Now suppose
that 𝑝1 and 𝑝2 do not receive any messages until 𝑡last, and then re-
ceive the message sets 𝑀1 and 𝑀2 (if they exist) respectively. This
suﬃces to demonstrate that the deﬁnition of security is violated
(cid:3)
with respect to 𝑡last, 𝜀, 𝑝1 and 𝑝2.

Corollary 3.4. Security and uniform security are equivalent in

the partially synchronous setting.

Proof. This follows from Theorem 3.3 and the fact that produc-
(cid:3)

ing certiﬁcates clearly implies uniform security.

4 SECURITY AND UNIFORM SECURITY IN

THE SYNCHRONOUS SETTING

Having dealt with the partially synchronous setting, our next task
is to consider the synchronous setting. To do so, however, we ﬁrst
need to formalise the notion of a recalibration.

4.1 Deﬁning recalibrations
Theorem 3.3 seems to tie things up rather neatly for the partially
synchronous setting. In particular, the equivalence of security and
uniform security meant that we were spared having to carry out a
separate analysis for each security notion. It is not diﬃcult to see,
however, that the two security notions will not be equivalent in
the synchronous setting. To see this, we can consider the example
of Bitcoin. Suppose ﬁrst that we operate in the standard way for
Bitcoin, and use a notion of conﬁrmation C that depends only on
the security parameter 𝜀, and not on the duration D, so that the

setting then it produces certiﬁcates.

12See Section 2.5 for the deﬁnition of a protocol instance.

number of blocks required for conﬁrmation is just a function of 𝜀.
In this case, the protocol is secure in the synchronous setting [10].
It is also clear, however, that this protocol will not be uniformly se-
cure in a setting where the adversary controls a non-zero amount
of mining power: If a ﬁxed number of blocks are required for con-
ﬁrmation then, given enough time, the adversary will eventually
complete a double spend (i.e. the adversary will double spend with
probability tending to 1 as the number of timeslots tends to inﬁn-
ity). That said, it is also not diﬃcult to see how one might ‘recali-
brate’ the protocol to deal with diﬀerent durations – to make the
protocol uniformly secure, the number of blocks required for con-
ﬁrmation should be a function of both 𝜀 and D.

The point of this subsection is to formalise the idea of recali-
bration and to show that, if a protocol is secure, then (under fairly
weak conditions) a recalibration will be uniformly secure. The ba-
sic idea is very simple – one runs the initial (unrecalibrated) pro-
tocol for smaller values of 𝜀 as the duration increases, but one has
to be careful that the resulting ℓ𝜀,D is sublinear in D.

Deﬁnition 4.1. We say (P2, C2) is a recalibration of the extended
protocol (P1, C1) if running P2 given certain inputs means running
P1 for a computable transformation of those inputs, and then ter-
minating after |D| many steps are complete.

So, if running P2 with security parameter 𝜀 and for 𝑛 many times-
lots means running P1 with input parameters that specify a secu-
rity parameter 𝜀/10 and that specify a duration consisting of 2𝑛
many timeslots, and then terminating after 𝑛 many timeslots have
been completed, then P2 is a recalibration of P1.13 Note also, that
we allow the recalibration to use a diﬀerent notion of conﬁrmation.
In the following, we say that ℓ𝜀,D is independent of D if ℓ𝜀,D =
ℓ𝜀,D′ for all 𝜀 > 0 and all D, D′. When ℓ𝜀,D is independent of D,
we will often write ℓ𝜀 for ℓ𝜀,D .

Deﬁnition 4.2. In the bounded user setting we assume that there
is a ﬁnite upper bound on the number of processors, which holds
for all protocol instances.14

Proposition 4.3. Consider the synchronous and bounded user
setting. Suppose P satisﬁes liveness with respect to ℓ𝜀,D, that ℓ𝜀,D
is independent of D, and that for each 𝛼 > 0, ℓ𝜀 < 𝛼𝜀−1 for all suf-
ﬁciently small 𝜀 > 0. If P is secure, there exists a recalibration of P
that is uniformly live and uniformly secure.

The conditions on ℓ𝜀,D in the statement of Proposition 4.3 can
reasonably be regarded as weak, because existing protocols which
are not already uniformly secure will normally satisfy the condi-
tions that: (†𝑎) ℓ𝜀,D is independent of D, and; (†𝑏) For some con-
stant 𝑐 and any 𝜀 ∈ (0, 1), we have ℓ𝜀 < 𝑐ln 1
𝜀 . The example of Bit-
coin might be useful for the purposes of illustration here. Bitcoin
is secure in the synchronous setting, and the number of blocks re-
quired for conﬁrmation is normally considered to be independent
of the duration. The number of blocks required for conﬁrmation

13The choices 𝜀/10 and 2𝑛 are arbitrarily chosen for the purpose of example. The
reader might wonder why one should specify a duration of 2𝑛 timeslots and then
terminate after 𝑛 many. This is because the instructions of the ﬁrst 𝑛 timesteps can
depend on the intended duration. In Algorand, committee sizes will depend on the
intended duration, for example.
14Note that the requirement here is that the number of processors is bounded, rather
than the number of public keys.

does depend on how sure one needs to be that an adversary can-
not double spend in any given time interval, but it’s also true that
an adversary’s chance of double spending in a given time interval
decreases exponentially in the number of blocks required for con-
ﬁrmation as well. So Bitcoin is an example of a protocol satisfying
(†𝑎) and (†𝑏) above.

Proof of Proposition 4.3. It is useful to consider a security
notion that is intermediate between security and uniform security.
For the purposes of the following deﬁnition, we say that a block
is conﬁrmed at timeslot 𝑡 if there exists at least one processor for
whom that is the case.

Deﬁnition 4.4 (Timeslot Security). A protocol is timeslot secure
if the following holds for every choice of security parameter 𝜀 > 0,
and for all timeslots 𝑡1, 𝑡2 in the duration: With probability > 1 − 𝜀,
all blocks which are conﬁrmed at 𝑡1 are compatible with all blocks
which are conﬁrmed at 𝑡2.

So the diﬀerence between timeslot security and uniform security
is that the latter requires the probability of even a single disagree-
ment to be bounded, while the former only bounds the probabil-
ity of disagreement for each pair of timeslots. Similarly, the diﬀer-
ence between security and timeslot security is that, for each pair
of timeslots, the latter requires the probability of even a single dis-
agreement to be bounded, while the former only bounds the prob-
ability of disagreement for each pair of processors at that timeslot
pair.

Now suppose P is live and secure, and that the conditions of
Proposition 4.3 hold. Then it follows directly from the Union Bound
that, if the number of users is bounded, then some recalibration of
P is live and timeslot secure and satisﬁes the conditions of Propo-
sition 4.3. Since a recalibration of a recalibration of P is a recalibra-
tion of P, our main task is therefore to show that, if P is live and
timeslot secure and the conditions of Proposition 4.3 hold, then
there exists a recalibration of P that is uniformly live and uniformly
secure.

So suppose (P, C) is live and timeslot secure, and that the condi-
tions of Proposition 4.3 hold. Suppose we are given 𝜀0 and D0 as
inputs to our recalibration (P′, C′). We wish to ﬁnd an appropriate
security parameter 𝜀1 and a duration D1 ≥ D0 to give as inputs
to P and C, so that uniform security is satisﬁed with respect to 𝜀0
and D0 if we run P with inputs 𝜀1 and D1 and then terminate after
|D0 | many timeslots. The diﬃculty is to ensure that ℓ𝜀1 remains
sublinear in D0. To achieve this, let 𝑛 := |D0 |, set 𝜀1 := 𝜀0/2𝑛 and
choose |D1 | > 𝑛 + ℓ𝜀1, so that D0 is the ﬁrst 𝑛 timeslots in D1. This
deﬁnes the recalibration. It remains to establish uniform liveness
and uniform security.

For uniform liveness we must have that, for each 𝛼 ∈ (0, 1),
< 𝛼𝑛 for all suﬃciently large values of 𝑛 – if this condition
ℓ𝜀1
holds then it follows from the Union Bound that our recalibration
will satisfy uniform liveness (and the required sublinearity in D0)
with respect to ℓ ′
:= ℓ𝜀1 . The condition holds since we are given
that for each 𝛼 > 0, ℓ𝜀 < 𝛼𝜀−1 for all suﬃciently small 𝜀 > 0.
Suppose given 𝛼 > 0, and put 𝛼 ′ := 𝛼𝜀0/2. Then we have that, for
all suﬃciently large 𝑛:

𝜀0,D0

ℓ𝜀1

< 𝛼 ′(𝜀0/2𝑛)−1 = 𝛼𝑛.

Next we must show that the conditions for uniform security are
satisﬁed. Suppose P is given inputs 𝜀1 and D1 and is actually run for
|D1 | many timeslots. We aim to show that, with probability > 1−𝜀0,
there do not exist incompatible blocks 𝐵1, 𝐵2, timeslots 𝑡1, 𝑡2 ∈ D0
and 𝑝1, 𝑝2 such that 𝐵𝑖 is conﬁrmed for 𝑝𝑖 at 𝑡𝑖 for 𝑖 ∈ {1, 2}. Let 𝑡last
be the last timeslot of the duration D1 and deﬁne 𝑡 ∗ := 𝑡last − ℓ𝜀1 .
The basic idea is that the two following conditions hold with high
probability: (a) [𝑡 ∗, 𝑡last] is a growth interval, and (b) There does
not exist 𝑡1 ∈ D0, processors 𝑝1, 𝑝2 and incompatible blocks 𝐵1, 𝐵2,
such that 𝐵1 is conﬁrmed for 𝑝1 at 𝑡1 and 𝐵2 is conﬁrmed for 𝑝2
at 𝑡last. When both these conditions hold, and since 𝑡 ∗ > 𝑛, this
suﬃces to show that no incompatible and conﬁrmed blocks exist
during the duration D0. Now let us see that in more detail.

By the choice of D1, 𝑡 ∗ > 𝑛. It follows from the deﬁnition of

liveness that (†1) below fails to hold with probability ≤ 𝜀1:
(†1) [𝑡 ∗, 𝑡last] is a growth interval.
Note that, so long as (†1) holds, every user has more conﬁrmed
blocks at 𝑡last than any user does at any timeslot in D0. It also
follows from the Union Bound, and the deﬁnition of liveness and
timeslot security, that (†2) below fails to hold with probability ≤
𝑛𝜀1 = 𝜀0/2:

(†2) There does not exist 𝑡1 ∈ D0, processors 𝑝1, 𝑝2 and incom-
patible blocks 𝐵1, 𝐵2, such that 𝐵1 is conﬁrmed for 𝑝1 at 𝑡1
and 𝐵2 is conﬁrmed for 𝑝2 at 𝑡last.

Now note that:

(a) If (†1) and (†2) both hold, then there do not exist incompat-
ible blocks 𝐵1, 𝐵2, timeslots 𝑡1, 𝑡2 ∈ D0 and 𝑝1, 𝑝2 such that
𝐵𝑖 is conﬁrmed for 𝑝𝑖 at 𝑡𝑖 for 𝑖 ∈ {1, 2}.

(b) With probability > 1 − 𝜀1 − 𝜀0/2 ≥ 1 − 𝜀0, (†1) and (†2) both

hold.

So uniform security is satisﬁed with respect to 𝜀0 and D0, as re-
(cid:3)
quired.

Deﬁnition 4.5. We say P has standard functionality if it is uni-
formly live and uniformly secure. We say that a recalibration of P
is faithful if it has standard functionality when P does.

Proposition 4.3 justiﬁes concentrating on protocols which have
standard functionality where it is convenient to do so, since proto-
cols which are live and secure will have recalibrations with stan-
dard functionality, so long as the rather weak conditions of Propo-
sition 4.3 are satisﬁed. Again, when we talk about the security and
liveness of a protocol, it is really the extended protocol that we are
referring to.

5 CERTIFICATES IN THE SYNCHRONOUS

SETTING

5.1 The synchronous and unsized setting
As outlined in the introduction, part of the aim of this paper is to
give a positive answer to Q3, by showing that whether a proto-
col produces certiﬁcates comes down essentially to properties of
the processor selection process. In the unsized setting protocols
cannot produce certiﬁcates. In the sized setting, recalibrated pro-
tocols will automatically produce certiﬁcates, at least if they are
of ‘standard form’. For the partially synchronous setting, the re-
sults of [12] and Section 3 already bear this out: The sized setting

is required for security and all secure protocols must produce cer-
tiﬁcates. The following theorem now deals with the unsized and
synchronous setting. Recall that, in the unsized setting, the total
resource balance belongs to a determined interval [𝛼0, 𝛼1]. We say
that the protocol operates ‘in the presence of a non-trivial adver-
sary’ if the setting allows that the adversary may have resource
balance at least 𝛼0 throughout the duration.

Theorem 5.1. Consider the synchronous and unsized setting. If a
protocol is live then, in the presence of a non-trivial adversary, it does
not produce certiﬁcates.

Proof. The basic idea is that the adversary with resource bal-
ance at least 𝛼0 can ‘simulate’ their own execution of the protocol,
in which only they have non-zero resource balance, while the non-
faulty processors carry out an execution in which the adversary
does not participate. Simulating their own execution means that
the adversary carries out the protocol as usual, while ignoring mes-
sages broadcast by the non-faulty processors, but does not initially
broadcast messages when given permission to do so. Liveness (to-
gether with the fact that the resource pool is undetermined) guar-
antees that, with high probability, both the actual and simulated
executions produce blocks which look conﬁrmed from their own
perspective. These blocks will be incompatible with each other and,
once the adversary ﬁnally broadcasts the messages that they have
been given permission for, these blocks will all have subjective cer-
tiﬁcates which are subsets of the set of broadcast messages. This
suﬃces to show that the protocol does not produce certiﬁcates.

More precisely, we consider two instances of the protocol In0
and In1 in the synchronous and unsized setting, which have the
same values for all determined variables – including the same suf-
ﬁciently small security parameter 𝜀 and the same suﬃciently long
duration D – and also have the same set of processors and the
same message delivery rule, but which diﬀer as follows:

• In In0, a set of processors P0 control public keys in a set
U0, which are the only public keys that do not have zero re-
source balance throughout the duration. The total resource
balance T has a ﬁxed value, 𝛼 say.

• In In1, it is the adversary who controls the public keys in U0,
and those keys have the same resource balance throughout
the duration as they do in In0. Now, however, another set
of processors P1 control public keys in a set U1 (disjoint
from U0), and the public keys in U1 also have total resource
balance 𝛼 throughout the duration, i.e. the resource balances
of these keys always add to 𝛼.

In In1, we suppose that the adversary simulates the processors in
P0 for In0 (which can be done with the single processor 𝑝𝐴), which
means that the adversary carries out the instructions for those pro-
cessors, with the two following exceptions. Until a certain timeslot
𝑡 ∗, to be detailed subsequently, they:

(a) Ignore all messages broadcast by non-faulty processors, and;
(b) Do not actually broadcast messages when permitted, but
consider them received by simulated processors in P0 as per
the message delivery rule.

For In0 (so long as the duration is suﬃciently long), liveness
guarantees the existence of a timeslot 𝑡0 for which the following
holds with probability > 1 − 𝜀:

(⋄0) At 𝑡0 there exists a set of broadcast messages 𝑀0 and a block

𝐵0 such that 𝐵0 ∈ C(𝑀0).

For In1, liveness guarantees the existence of a timeslot 𝑡1 for

which the following holds with probability > 1 − 𝜀:

(⋄1) At 𝑡1 there exists a set of broadcast messages 𝑀1 and a block

𝐵1 such that 𝐵1 ∈ C(𝑀1).

Choose 𝑡 ∗ > 𝑡0, 𝑡1. Our framework stipulates that the instruc-
tions of the protocol for a given user at a given timeslot are a
deterministic function of their present state and the message set
and permission set received at that timeslot. It also stipulates that
the response of the permitter to a request (𝑡 ′, U, 𝑀, 𝐴) is a prob-
abilistic function of the determined variables, (𝑡 ′, U, 𝑀, 𝐴), and of
R (U, 𝑡 ′, 𝑀). Since we are working in the unsized setting, In1 and
In0 have the same determined variables. It therefore follows by in-
duction on timeslots 𝑡 ≤ 𝑡 ∗, that the following is true at all points
until the end of timeslot 𝑡:
(⋄2) The probability distribution for In0 on the set of permission
sets given by the permitter is identical to the probability dis-
tribution for In1 on the set of permission sets given by the
permitter to the adversary.

Now suppose that at timeslot 𝑡 ∗ the adversary broadcasts all
messages for which they have been given permission by the per-
mitter. Note that, according to the assumptions of Section 2.4, any
block 𝐵0 broadcast by the adversary at 𝑡 ∗ will be incompatible with
any block 𝐵1 that has been broadcast by any honest user up to that
point. Combining (⋄0), (⋄1) and (⋄2), we see that (so long as 𝜀 is
suﬃciently small that 𝜀 < 1−2𝜀) the following holds with probabil-
ity > 𝜀 for 𝑡 ∗ and In1: There exist incompatible blocks 𝐵0, 𝐵1, and
𝑀0, 𝑀1 which are broadcast by the end of 𝑡 ∗, such that 𝐵𝑖 ∈ C(𝑀𝑖 )
for 𝑖 ∈ {0, 1}. This suﬃces to show that the protocol does not pro-
(cid:3)
duce certiﬁcates.

5.2 The synchronous and sized setting
The example of sized Bitcoin. Our aim in this subsection is to
show that, if we work in the synchronous and sized setting, and if
a protocol is of ‘standard form’, then a recalibration will produce
certiﬁcates. To make this precise, however, it will be necessary to
recognise the potentially time dependent nature of proofs of conﬁr-
mation. To explain this idea, it is instructive to consider the exam-
ple of Bitcoin in the sized setting: The protocol is Bitcoin, but now
we are told in advance precisely how the hash rate capability of
the network varies over time, as well as bounds on the hash rate of
the adversary.15 To make things concrete, let us suppose that the
total hash rate is ﬁxed over time, and that the adversary has 10%
of the hash rate at all times. Suppose that, during the ﬁrst couple
of hours of running the protocol, the diﬃculty setting is such that
the network as a whole (with the adversary acting honestly) will
produce an expected one block every 10 minutes. Suppose further
that, after a couple of hours, we see a block 𝐵 which belongs to a
chain 𝐶, in which it is followed by 10 blocks. In this case, the con-
straints we have been given mean that it is very unlikely that 𝐵
does not belong to the longest chain. So, at that timeslot, 𝐶 might
be considered a proof of conﬁrmation for 𝐵, i.e. the existence of the

chain 𝐶 can be taken as proof that 𝐵 is conﬁrmed. The nature of
this proof is time dependent, however. The same set of blocks (i.e.
𝐶) a large number of timeslots later would not constitute proof of
conﬁrmation.

If we now consider a PoS version of the example above, modi-
ﬁed to work for Snow White rather than Bitcoin, then the proof
produced will not be time dependent. This is because PoS proto-
cols function in the timed setting, i.e. when permission is given to
broadcast 𝑚 in response to a request (𝑡, U, 𝑀, 𝐴), other users are
able to determine 𝑡 from 𝑚. In order to prove that (recalibrated)
protocols in the sized setting produce certiﬁcates, we will have to
make the assumption that we are also working in the timed setting.

Protocols in standard form. The basic intuition behind the pro-
duction of certiﬁcates in the sized setting can be seen from the
example of “Sized Bitcoin” above. Once a block is conﬁrmed, non-
faulty processors will work ‘above’ this block. So long as those
processors possess a majority of the total resource balance, and so
long as the permitter reﬂects this fact in the permissions it gives,
then those non-faulty processors will broadcast a set of messages
which suﬃces (by its existence rather than the fact that it is the full
message state of any user) to give proof of conﬁrmation. This proof
of conﬁrmation might be temporary, but it will not be temporary
in the timed setting.

This intuitive argument, however, assumes that the protocol sat-
isﬁes certain standard properties. As alluded to above, there is an
assumption that the set of messages broadcast by a group of proces-
sors will reﬂect their resource balances and that the adversary will
have a minority resource balance. There is also an assumption that
broadcast messages will (in some sense) point to a particular posi-
tion on the blockchain. So we will have to formalise these ideas,
and the results we prove will only hold modulo the assumption
that these standard properties are satisﬁed.

First, let us formalise the idea that messages always point to a

position on the blockchain.

Deﬁnition 5.2. We say that a protocol is in standard form if it

satisﬁes all of the following:

• The protocol has standard functionality (see Deﬁnition 4.5).
• Every broadcast message is ‘attached’ to a speciﬁc block

(blocks being attached to themselves).

• While 𝐵 is conﬁrmed for 𝑝, the state transition diagram S
will only instruct 𝑝 to broadcast messages which are attached
to 𝐵 or descendants of 𝐵.

Reﬂecting the resource pool. Now let us try to describe how the
permitter might reﬂect the resource pool. We will need a simple
way to say that one set of processors consistently has a higher
resource balance than another.

Deﬁnition 5.3. For Θ > 1, we say a set of public keys U1 dom-
inates another set U2, denoted U1 >Θ U2, if the following holds
for all sets of broadcast messages 𝑀 and all timeslots 𝑡:

Õ
U∈U1

R (U, 𝑡, 𝑀) > Θ · Õ
U∈U2

R (U, 𝑡, 𝑀).

15Normally we think of PoW protocols as operating in the unsized setting, precisely
because such guarantees on the hash rate are not realistic.

Next, we will need to formalise the idea that, if one set of keys
dominates another, then they will be able to broadcast discernibly

diﬀerent sets of messages. Recall that, in the timed setting, each
message 𝑚 corresponds to a timeslot 𝑡𝑚, which can be determined
from 𝑚. We write M [𝑡1, 𝑡2] to denote the set {𝑀 | ∀𝑚 ∈ 𝑀, 𝑡𝑚 ∈
[𝑡1, 𝑡2]}. We will say that the set of keys U0 is directed to broadcast
𝑀 if, for every 𝑚 ∈ 𝑀, there is some member of U0 that is given
permission to broadcast 𝑚 and is directed to broadcast 𝑚 by the
protocol. We will say that U0 is able to broadcast 𝑀 if, for every
𝑚 ∈ 𝑀, there is some member of U0 that is given permission to
broadcast 𝑚. We deﬁne M∗ := {𝑀 | 𝑀 is ﬁnite}. We let T be the
set of functions 𝑇 : D × M → R≥0 (so that the total resource
balance T ∈ T). We say that a set of keys U0 has total resource
U∈U0 R (U, 𝑡, 𝑀). In the
balance 𝑇 : D × M → R≥0 if 𝑇 (𝑡, 𝑀) =
for each Θ, 𝜀,𝑇 ,
deﬁnition below, we say 𝑟 is sublinear in |D| if,
and for every 𝛼 ∈ (0, 1), it holds that 𝑟 (Θ, 𝜀,𝑇 , |D|) < 𝛼 |D| for all
suﬃciently large |D|.

Í

Deﬁnition 5.4. We say that (S, O, C) reﬂects the resource pool
if there exist computable ﬁnite valued functions 𝑟 : R>1 × R>0 ×
T × N → N and X : M∗ × R>1 × R>0 × T × N → 2M∗
, such that:

(1) 𝑟 is sublinear in |D|.
(2) If U1 ∪ U2 has total resource balance 𝑇 , and if U1 >Θ U2,
then, when the protocol is run with security parameter 𝜀 and
for |D| many timeslots, the following holds with probabil-
ity > 1−𝜀: For all intervals of timeslots [𝑡1, 𝑡2] with 𝑡2 −𝑡1 ≥
𝑟 (Θ, 𝜀,𝑇 , |D|), there exists some 𝑀 ∈ M [0, 𝑡1) and an ele-
ment of X(𝑀, Θ, 𝜀,𝑇 , |D|) ∩ M [𝑡1, 𝑡2] which U1 is directed
to broadcast, while there does not exist any 𝑀 ′ ∈ M [0, 𝑡1)
which is broadcast and such that U2 is able to broadcast
some element of X(𝑀 ′, Θ, 𝜀,𝑇 , |D|) ∩ M [𝑡1, 𝑡2].

So in Deﬁnition 5.4, 𝑟 speciﬁes a number of timeslots. Then X
speciﬁes certain sets of messages 𝑀 such that, if U1 >Θ U2 and
U1 ∪ U2 has total resource balance 𝑇 , then U1 can be expected to
broadcast one of these sets 𝑀 in any interval of suﬃcient length
(i.e. the length speciﬁed by 𝑟 ). To make this interesting, we also
have that U2 can be expected not to make such broadcasts. To see
why this is a natural and reasonable condition to assume, it is in-
structive to consider the example of Sized Bitcoin. Suppose that in
some execution the honest users always have at least 60% of the
mining power. Then, over any long period of time 𝑟 , we can be
fairly sure that honest users will get to make at least 50% of the ex-
pected number of block broadcasts, while the adversary is unlikely
to be able to make such broadcasts if 𝑟 is large enough. In fact, the
exponentially fast convergence for the law of large numbers guar-
anteed by bounds like Hoeﬀding’s inequality, means 𝑟 only needs
to grow with ln 1/𝑝, where 𝑝 is the probability of error (i.e. the
probability these conditions on the block broadcasts don’t hold in
a given interval). It is therefore not diﬃcult to see that Sized Bit-
coin would reﬂect the resource pool if it could be implemented in
a timed setting. Similar arguments can be made for all well known
PoS protocols,16 and these are implemented in the timed setting.

Deﬁnition 5.5. In the bounded adversary setting it is assumed

that:

16The example of Snow White was discussed previously. As suggested in Section 1,
one way to deﬁne X in the context of Snow White is to consider long chains of suﬃ-
cient density, meaning that they have members corresponding to most possible times-
lots, that they cannot likely be produced by a (suﬃciently bounded) adversary.

(i) U1 >Θ U2 for some determined input parameter Θ > 1,
where U1 is the set of keys controlled by non-faulty proces-
sors, and U2 is the the set of keys controlled by the adver-
sary.

(ii) (S, O, C) reﬂects the resource pool.

Finally, we can now formalise the idea that under standard con-
ditions, standard protocols in the sized setting produce certiﬁcates.

Theorem 5.6. Consider the timed, bounded adversary and sized
setting. If P is in standard form, then there exists a faithful recalibra-
tion that produces certiﬁcates.

Proof. To deﬁne our recalibration (P′, C′), suppose we are given
values for 𝜀, T , Θ and D. We need to specify a value 𝜀 ′ to give as in-
put to P (we will leave other values unchanged), and we must also
deﬁne C′. Then we need to show that the new extended protocol
is uniformly live and produces certiﬁcates.

We deﬁne 𝜀 ′ := 𝜀/4. Towards deﬁning C′, suppose that P sat-
isﬁes uniform liveness with respect to ℓ𝜀′,D . We divide the dura-
tion into intervals of length > ℓ𝜀′,D , by deﬁning 𝑡𝑖 := 𝑖 · (ℓ𝜀′,D +
𝑟 (Θ, 𝜀 ′, T , |D|)). From the deﬁnition of uniform liveness we have
the following.
($1) With probability > 1 − 𝜀/4 it holds that, for all 𝑖 with 𝑡𝑖 ≤
|D|, all users have at least 𝑖 many conﬁrmed blocks by the
end of timeslot 𝑡𝑖 .

Now suppose (P, C) satisﬁes Deﬁnition 5.4 with respect to 𝑟 and
:= 𝑡𝑖 + 𝑟 (Θ, 𝜀 ′, T , |D|). Let 𝐼𝑖 be the
X. For each 𝑖 > 0, deﬁne 𝑡 ∗
𝑖
interval [𝑡𝑖, 𝑡 ∗
𝑖 ], and write M [𝐼𝑖] to denote M [𝑡𝑖, 𝑡 ∗
𝑖 ]. Let U1 be the
set of keys controlled by non-faulty processors, and let U2 be the
the set of keys controlled by the adversary. According to Deﬁnition
5.4, we can then conclude that:
($2) It holds with probability > 1 − 𝜀/4 that, whenever 𝐼𝑖 is con-
tained in the duration, there exists some 𝑀 ∈ M [0, 𝑡𝑖) which
is broadcast and an element of X(𝑀, Θ, 𝜀 ′, T , |D|) ∩ M [𝐼𝑖]
which U1 is directed to broadcast, while there does not ex-
ist any 𝑀 ′ ∈ M [0, 𝑡𝑖) which is broadcast and such that U2
is able to broadcast some element of X(𝑀 ′, Θ, 𝜀 ′, T , |D|) ∩
M [𝐼𝑖].

Since P is uniformly secure, we also know that:
($3) With probability > 1 − 𝜀/4, there do not exist incompati-
ble blocks 𝐵1, 𝐵2, timeslots 𝑡1, 𝑡2 and 𝑈1, 𝑈2 such that 𝐵𝑖 is
conﬁrmed for 𝑈𝑖 at 𝑡𝑖 for 𝑖 ∈ {1, 2}.

So now deﬁne X∗ (Θ, 𝜀 ′, T , |D|) to be all those 𝑀 = 𝑀 ′ ∪ 𝑀 ′′
such that 𝑀 ′ ∈ X(𝑀 ′′, Θ, 𝜀 ′, T , |D|), and for which there exists 𝑖
such that all of the following hold: (i) 𝐼𝑖 ⊆ D; (ii) 𝑀 ′ ∈ M [𝐼𝑖],
𝑀 ′′ ∈ M [0, 𝑡𝑖 ) and; (iii) For some chain 𝐶 of length 𝑖 with leaf 𝐵,
all messages in 𝑀 ′ are attached to 𝐵 or its descendants.

Now if 𝑀 ∈ X∗ (Θ, 𝜀 ′, T , |D|), then let 𝑀 ′, 𝑀 ′′ be such that 𝑀 ′ ∈
X(𝑀 ′′, Θ, 𝜀 ′, T , |D|) and (i)–(iii) above are satisﬁed, let 𝑖𝑀′ be the
(unique) 𝑖 such that (i)–(iii) hold w.r.t. 𝑀 ′, let 𝐶 be as speciﬁed in
(iii) for 𝑖𝑀′ , and deﬁne C∗ (𝑀) := 𝐶. We also deﬁne C∗ (∅) = ∅. This
function C∗ is almost the notion of conﬁrmation that we want for
our recalibration, but the problem is that it is only deﬁned for very
speciﬁc values of 𝑀. We will use C∗ to help us deﬁne C′ that is
deﬁned for all possible 𝑀. Combining ($1), ($2) and ($3), and the

[3] Iddo Bentov, Rafael Pass, and Elaine Shi. 2016. Snow White: Provably Secure

Proofs of Stake. IACR Cryptology ePrint Archive 2016, 919 (2016).

[4] Ethan Buchman. 2016.

Tendermint: Byzantine fault tolerance in the age of

blockchains. Ph.D. Dissertation.

[5] Ran Canetti. 2001. Universally composable security: A new paradigm for crypto-
graphic protocols. In Proceedings 42nd IEEE Symposium on Foundations of Com-
puter Science. IEEE, 136–145.

[6] David Cavin, Yoav Sasson, and André Schiper. 2004. Consensus with unknown
participants or fundamental self-organization. In International Conference on Ad-
Hoc Networks and Wireless. Springer, 135–148.

[7] Jing Chen, Sergey Gorbunov, Silvio Micali, and Georgios Vlachos. 2018. ALGO-
RAND AGREEMENT: Super Fast and Partition Resilient Byzantine Agreement.
IACR Cryptol. ePrint Arch. 2018 (2018), 377.

[8] Jing Chen and Silvio Micali. 2016. Algorand. arXiv preprint arXiv:1607.01341

(2016).

[9] Cynthia Dwork, Nancy A. Lynch, and Larry Stockmeyer. 1988. Consensus in

the Presence of Partial Synchrony. J. ACM 35, 2 (1988), 288–323.

[10] Juan A Garay, Aggelos Kiayias, and Nikos Leonardos. 2018. The Bitcoin Back-

bone Protocol: Analysis and Applications. (2018).

[11] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov.
2017. Ouroboros: A provably secure proof-of-stake blockchain protocol. In An-
nual International Cryptology Conference. Springer, 357–388.

[12] Andrew Lewis-Pye and Tim Roughgarden. 2021. Byzantine Generals in the Per-

missionless Setting. arXiv preprint arXiv:2101.07095 (2021).

[13] Nancy A Lynch. 1996. Distributed algorithms. Elsevier.
[14] Satoshi Nakamoto et al. 2008. Bitcoin: A peer-to-peer electronic cash sys-

tem.(2008).

[15] Michael Okun. 2005. Distributed computing among unacquainted processors in

the presence of Byzantine failures. Hebrew University of Jerusalem.

[16] Rafael Pass, Lior Seeman, and abhi shelat. 2016. Analysis of the Blockchain

Protocol in Asynchronous Networks. eprint.iacr.org/2016/454.

[17] Ling Ren. 2019. Analysis of nakamoto consensus. Technical Report. Cryptology

ePrint Archive, Report 2019/943.(2019). https://eprint. iacr.org.

[18] Maofan Yin, Dahlia Malkhi, Michael K Reiter, Guy Golan Gueta, and Ittai Abra-
ham. 2019. HotStuﬀ: BFT consensus with linearity and responsiveness. In Pro-
ceedings of the 2019 ACM Symposium on Principles of Distributed Computing. 347–
356.

deﬁnition of X∗, it follows that with probability > 1 − 𝜀 both of the
following hold:

(1) If 𝑀, 𝑀 ′ ∈ X∗ (Θ, 𝜀 ′, T , |D|) are both broadcast, then all
blocks in C∗ (𝑀) are compatible with all those in C∗ (𝑀 ′).
(2) For every 𝑖 > 0 with 𝐼𝑖 ⊆ D, there exists 𝑀 ∈ X∗ (Θ, 𝜀 ′, T , |D|)
which is broadcast and such that, for some 𝑀 ′, 𝑀 ′′: (i) 𝑀 =
𝑀 ′ ∪ 𝑀 ′′; (ii) 𝑀 ′ ∈ X(𝑀 ′′, Θ, 𝜀 ′, T , |D|); (iii) 𝑀 ′ ∈ M [𝐼𝑖],
𝑀 ′′ ∈ M [0, 𝑡𝑖), and; (iv) For some chain 𝐶 of length 𝑖 with
leaf 𝐵, all messages in 𝑀 ′ are attached to 𝐵 or its descen-
dants.

In order to deﬁne C′ for our recalibration, we can then proceed
as follows. Given arbitrary 𝑀, choose 𝑀 ′ ⊆ 𝑀 such that 𝑀 ′ ∈
X∗ (Θ, 𝜀 ′, T , |D|) and C∗ (𝑀 ′) is of maximal length, or if there exists
no 𝑀 ′ satisfying these conditions then deﬁne 𝑀 ′ := ∅. We deﬁne
C′(𝑀) := C∗ (𝑀 ′). It follows from (1) and (2) above that (P′, C′)
produces certiﬁcates and satisﬁes uniform liveness with respect to
𝜀,D := ℓ𝜀′,D + 2𝑟 (Θ, 𝜀 ′, T , |D|).
ℓ ′
(cid:3)

6 APPENDIX – TABLE 1.

term
𝐵
C
D
Δ

meaning
a block
a notion of conﬁrmation
the duration
bound on message delay during synchronous
intervals
the security parameter
a protocol instance
a message
a set of messages
the set of all possible sets of messages
a permitter oracle
a processor
a permission set
a permissionless protocol
a request set
the resource pool
a state transition diagram
a message
a timeslot
a request in the timed setting
a timing rule
a public key
a request in the untimed setting
the set of all public keys
the set public keys for 𝑝

𝜀
In
𝑚
𝑀
M
O
𝑝
𝑃
P
𝑅
R
S
𝜎
𝑡
(𝑡, U, 𝑀, 𝐴)
T
U
(U, 𝑀, 𝐴)
U
U𝑝
Table 1: Some commonly used variables and terms.

REFERENCES
[1] Eduardo AP Alchieri, Alysson Neves Bessani, Joni da Silva Fraga, and Fabíola
Greve. 2008. Byzantine consensus with unknown participants. In International
Conference On Principles Of Distributed Systems. Springer, 22–40.

[2] Vivek Bagaria, Sreeram Kannan, David Tse, Giulia Fanti, and Pramod Viswanath.
2019. Prism: Deconstructing the blockchain to approach physical limits. In Pro-
ceedings of the 2019 ACM SIGSAC Conference on Computer and Communications
Security. 585–602.

