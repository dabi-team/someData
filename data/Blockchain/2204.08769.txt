Bodyless Block Propagation: TPS Fully Scalable
Blockchain with Pre-Validation

Chonghe Zhao, Shengli Zhang, Senior Member, IEEE, Taotao Wang, Member, IEEE, Soung Chang Liew, Fellow,
IEEE

1

2
2
0
2

r
p
A
9
1

]
I

N
.
s
c
[

1
v
9
6
7
8
0
.
4
0
2
2
:
v
i
X
r
a

Abstract—The fundamental tradeoff between transaction per
second (TPS) and security in blockchain systems persists despite
numerous prior attempts to boost TPS. To increase TPS without
compromising security, we propose a bodyless block propagation
(BBP) scheme for which the block body is not validated and
transmitted during the block propagation process. Rather, the
nodes in the blockchain network anticipate the transactions
and their ordering in the next upcoming block so that these
transactions can be pre-executed and pre-validated before the
birth of the block. It is critical, however, all nodes have a
consensus on the transaction content of the next block.

This paper puts forth a transaction selection, ordering, and
synchronization algorithm to drive the nodes to reach such a
consensus. Yet, the coinbase address of the miner of the next
block cannot be anticipated, and therefore transactions that
depend on the coinbase address cannot be pre-executed and pre-
validated. This paper further puts forth an algorithm to deal
with such unresolvable transactions for an overall consistent and
TPS-efﬁcient scheme. With our scheme, most transactions do not
need to be validated and transmitted during block propagation,
ridding the dependence of propagation time on the number of
transactions in the block, and making the system fully TPS
scalable. Experimental results show that our protocol can reduce
propagation time by 4x with respect to the current Ethereum
blockchain, and its TPS performance is limited by the node
hardware performance rather than block propagation.

Index Terms—Blockchain, Bodyless Block, TPS, Block Propa-

gation, Block Validation

I. INTRODUCTION

In 2008, Satoshi Nakamoto proposed Bitcoin, a peer-to-
peer (P2P) electronic cash system [1]. Bitcoin fundamentally
challenged the role of traditional banking systems by enabling
decentralized money transfers over a network consisting of
untrusted nodes. The underlying enabling technology of Bit-
coin came to be known as blockchain. Blockchain is a secure,
veriﬁable, and tamper-proof distributed ledger technology for
recording transactions. The design of Bitcoin’s blockchain
integrates the advances of cryptography, distributed systems,
and P2P networks. Following this genesis design, many efforts
have been dedicated to the investigations and deployments
of other blockchain systems. Among them, perhaps the most
successful is Ethereum [2]. Ethereum introduces smart con-
tracts to enable execution of Turing-complete computing tasks,
greatly extending the application and usefulness of blockchain.
For example, the currently in-vogue Decentralized Finance

C. Zhao, S. Zhang and T. Wang are with the College of Electronics and
Information Engineering, Shenzhen University, Shenzhen 518060, China (e-
mail: zhaochonghe szu@163.com; zsl@szu.edu.cn; ttwang@szu.edu.cn).

S. Liew is with the Department of

Information Engineering, The
Chinese University of Hong Kong, Hong Kong SAR, China (e-mail:
soung@ie.cuhk.edu.hk)

(DeFi) [3], Non-Fungible Token (NFT) [4], and the Metaverse
[5] all rely on blockchains with smart contracts.

A weakness of the present blockchains is their low data
processing capability, as measured by transactions per second
(TPS). For example, the TPS of Bitcoin and Ethereum are 7
and 15, respectively, signiﬁcantly lower than that of centralized
systems. The low TPS cannot meet the needs of large-scale ap-
plications, imposing a fundamental limit on blockchain’s util-
ity. For example, the low TPS precludes Bitcoin and Ethereum
from massive money transfers of the same scale as mainstream
payment systems—for comparison, the TPS of VISA is around
2000. Furthermore, with the deployments of DeFi and NFT
applications, the Ethereum network is increasingly congested.
According to the Ethereum block explorer, Etherscan [6], the
average number of pending transactions on the network has
accumulated to 138,000. Improving blockchain’s TPS is of
paramount importance.

An intuitive but na¨ıve way to improve TPS is to enlarge
the block size so that each block can carry more transactions.
But large blocks decelerate their propagation on the network,
thereby compromising the blockchain’s security and integrity
[7] .

Fig. 1(a) illustrates the time spent in block propagation. In
Fig. 1(a), Node0 is the miner that has mined a block, and
it is propagating the block to all other nodes over several
communication hops. To fend off invalid blocks, each node
must verify the received block before forwarding it to the
neighbor nodes. Thus, block propagation time consists pri-
marily of block validation time and block transmission time
on the network.

Accordingly, we can accelerate block propagation by de-
creasing i) block transmission time and ii) block validation
time. To lower Bitcoin’s block transmission time, the Bitcoin
Improvement Proposal (BIP) 152 proposes to propagate com-
pact blocks in place of full blocks. In compact blocks, transac-
tion hashes replace the transactions in full blocks [8], thereby
compressing the block size. If a node receives a compact block
and does not have the transactions corresponding to speciﬁc
transaction hashes, the node needs to request the missing trans-
actions from other nodes. In situations where the transactions
at different nodes are vastly different, the needed transactions
for validation at a node may often be missing, triggering the
time-consuming request-response process and retarding block
propagation. Notably, while BIP152 may work in Bitcoin, it
does not work in Ethereum because the inter-block interval in
Ethereum is so short that the transaction differences between
nodes are quite substantial—the transactions in a new block
may not have time to propagate to all nodes yet by the time

 
 
 
 
 
 
2

Figure 1: Illustration of block propagations: (a) classical block propagation; (b) bodyless block propagation.

the new block is born1.

Assuming a similar idea as compact blocks, [9, 10] im-
proved the block propagation efﬁciency using a Bloom ﬁlter
and Invertible Bloom lookup tables (IBLT) for quick detection
of the missing transactions in the compressed blocks. However,
the block size still increases with the number of transaction
hashes in these schemes, and nodes still need extra time to
synchronize missing transactions in the block. In conclusion,
compact blocks may alleviate the block propagation problem
under certain conditions, they fall short in other situations and
its TPS scalability is limited. .

Another way to speed up block propagation is to reduce
block validation time. As pointed out in [11], block validation
time cannot be neglected and is the bottleneck of block
propagation for large block size. To shorten block validation
time, [12] proposed to probabilistically validate received new
blocks. Not validating all blocks, however, may compromise
security. Furthermore, selective block validation still does
not solve the aforementioned missing transaction issue when
there are missing transactions in blocks that are chosen for
validation.

This work puts forth a novel bodyless block propagation
(BBP) scheme for Ethereum-like blockchains. BBP nails block
propagation time to a constant level that does not increase with
the number of transactions in a block, thereby allowing many
transactions in block. In particular, BBP can reduce both block
transmission and validation times. The key is that BBP only
propagates the block header, ridding the dependence of block
propagation speed on the number of transactions in the block
body. A block can then pack a large number of transactions
in the unpropagated block body to boost TPS.

1Section II of this paper provides an experimental evidence to the failure

of compact block in Ethereum.

As shown in Fig. 1(b), the underpinning of BBP is that each
node anticipates the transactions in the upcoming next block
and pre-packs a blockbody based on the anticipated transac-
tions. The node pre-executes and pre-validates the anticipated
transactions before the next block is mined. To the extent that
the anticipated transactions of all nodes are the same and that
the miner of the next block also embeds the same transactions
in the block, then the block validation has already been done
by all nodes by the time the next block is mined. Only the
block header needs to be propagated. As soon as it receives the
block header, a node can verify that the validation information
in the header is the same as the validation information of
the pre-packed blockbody. The subtlety of realizing BBP, of
course, lies in the following technical challenges:

• How to ensure all nodes anticipate roughly the same
transactions to pre-pack a blockbody—Since there are
no presumed trusts among the decentralized blockchain
nodes, in principle, nodes can select and seal transac-
tions into blocks according to their own preferences. In
Ethereum, nodes typically select and order transactions
into blocks to maximize their GAS revenues. To align the
decisions of distributed trustless nodes, we must devise a
scheme to incentivize selﬁsh but rational nodes to follow
a common rule to pre-pack nearly identical blockbody.
• How to reconcile the anticipations in case nodes an-
ticipate slightly different transactions—Since blockchain
runs on decentralized P2P networks,
the transactions
available at different nodes may be different. Therefore,
even if all nodes follow the same rule to select trans-
actions to pre-pack blockbody, their blockbody may be
different. In Ethereum, just a single transaction difference
or a different transaction packing order in the block body
can result in different validation summary information in

Node NNode N Node 2 Node 2Node 0Node 0Node 1Node 1BlockBlockBlock...Block ValidationBlock Generation(Mining) Block TransmissionNode NNode N Node 2 Node 2Node 0Node 0Node 1Node 1...(a)  classical block propagation(b) bodiless block propagationBlock HeaderTransmissionBlock Pre-ValidationBlockHeaderBlockHeaderBlockHeaderBlockHeaderBlockHeaderBlockHeaderBlockHeaderBlockHeaderBlockHeaderthe block header. BBP would be ineffective if required
to re-assemble the block and re-validate all transactions
upon the block arrival when there is a slight difference in
the selected transactions and their order. What is needed
is a scheme to synchronize the transaction anticipations
of different nodes before the arrival of the new block.
• How to deal with the as-yet unavailable information
during the pre-validation process—Since some informa-
tion required to validate the block may not be available
yet before the arrival of the new block, the complete
execution of the block for a complete pre-validation is
not possible. For example, some transactions may involve
the Coinbase address associated with the miner, but the
successful miner is not know yet during the pre-validation
process at each node. The pre-validation of BBP must
deal with such unresolvable transactions for an overall
consistent and TPS-efﬁcient scheme.

This paper puts forth solutions and veriﬁes their effective-
ness in addressing the above challenges. The main contribu-
tions are as follows:

• We put forth a Time-speciﬁc transaction Selection and
Ordering (TSO) algorithm to disambiguate and align the
transaction selection and ordering at all nodes. Although
nodes can independently and freely select transactions for
blocks, rational nodes would not do so because they can
maximize their GAS revenues and save computing costs
by executing TSO. In addition, we propose a pre-packed
blockbody synchronization protocol with which the nodes
exchange pre-packed blockbody information with their
neighbors to synchronize their blockbody securely.

• We put forth a pre-validation algorithm to accelerate
block propagation. For block validation in Ethereum and
most blockchains that support smart contracts, nodes need
to execute the transactions to compute a global state
updated by the block. This computed global state is
checked against the global state contained in the block
header of the received block for validation purposes.
Since the execution order of the transactions matters
to the global state, by convention the transactions in a
block are executed sequentially. However, the Coinbase
transaction information of the block is not available yet
before the arrival of the new block. To achieve effective
pre-validation, we propose an algorithm to identify the
transaction chain that involves the Coinbase transaction.
Then, the pre-validation algorithm can pre-validate the
block to the largest possible extent, leaving only transac-
tions that depend on the Coinbase to be validated during
block propagation.

• We collected measurements over the Ethereum MainNet
to make sure our scheme is targeting the right pain
points. Our measurements show that i) block validation
time in Ethereum is primarily determined by transaction
executions; and ii) directly applying the compact-block
protocol to Ethereum causes poor performance since there
is a 90% probability of an extra round of communica-
tion for missing-transaction requests. This observation of
Ethereum inspires the focal point of the design of BBP.

3

• We implemented BBP and conducted experiments over
a large-scale blockchain network with many nodes to
evaluate its performance. We compare BBP with other
block propagation schemes based on the experimental
results. The experiment results show that BBP has the
least block propagation time. Compared with the current
protocol of Ethereum, BBP reduces the block propagation
time by 4x. Importantly, our work shows that BBP
has a constant-level block propagation time for blocks
with modest to large numbers of transactions, thereby
demonstrating the full TPS scalability of BBP.

The rest of this paper is organized as follows. Section II
examines and dissects the block propagation time of the
Ethereum system. An overview of our BBP protocol is also
given in Section III. Section IV follows by elaborating the
systematic design of BBP. Section V analyzes the block
propagation delays of different protocols and discusses our
experimental results. Section VI overviews related work. Sec-
tion VII concludes this work.

II. MEASUREMENT AND OBSERVATION ON ETHEREUM

In this section, we ﬁrst put forth a design principle for the
block propagation protocol. We then present the results of two
experiments on block validation time and block transmission
time in Ethereum. The following sections put forth our BBP
protocol that adheres to the design principle to tackle the pain
points observed from our experimental results.

A. The effect of block propagation time on TPS

=

nt
tg

We can write the TPS in the Ethereum blockchain as

T P S=

sb
sttg
where sb is the average size of a full block, st is the average
transaction size, tg is the average time interval between
two successive blocks, and nt = sb/st is the number of
transactions in the block. In the current Ethereum, a block
contains 200 transactions on average and tg is around 13-15s,
and thus the TPS of Ethereum is less than 15.

(1)

From eq. (1), increasing sb or decreasing tg is a simple way
to improve TPS. However, merely increasing sb or decreasing
tg does not work. To guarantee security, blocks need to be
propagated to almost all nodes in the blockchain network (e.g.,
90% of the nodes) is a security requirement. We denote the
time to propagate a block from the miner node to the 90%
of the nodes in the blockchain network by tl. The probability
of the occurrence of stale blocks (also called uncle blocks in
Ethereum) is denoted by pf . The relationship between tl and
pf can be approximated as [32]

tg

pf = 1 − e− tl
For the existing block propagation protocols in blockchain,
the block propagation time tl and the number of transactions
contained in the block nt have a linear relationship, expressed
as tl ≈ knt, where k is a constant. Using this relationship, we
can rewrite eq. (2) as:
pf = 1 − e− tl

tg = 1 − e− knt

tg = 1 − e−k∗T P S

(3)

(2)

From eq. (3), we can see that, with a ﬁxed tg, the increase
of nt would increase tl and pf , weakening the security of the
blockchain, since the blockchain system is more vulnerable to
various attacks (e.g., double-spend attacks [33]) when pf is
large. In other words, there is always a tradeoff between TPS
and security with the current blockchain network, in which the
block propagation time increases with the block size.2 We are
thus lead to the following design principle to tackle the TPS
scalability problem without sacriﬁcing security:

Design Principle: When and only when the block prop-
agation time is independent of the number of transactions
in a block, the TPS of blockchain can be scaled without
compromising system security.

B. Measurement on block validation time

In Ethereum, a node must validate a new block received
before forwarding it to neighbors to avoid propagating illegal
blocks. As such, the block validation time directly impacts the
efﬁciency of the block consensus process.

The block validation time consists of three components:
header validation time, transaction execution time, and data
storage time. We measured the three time components on the
Ethereum MainNet. We set up a local node that connects to the
Ethereum MainNet during the period of January 23, 2022 to
January 25, 2022. When the node received a new block from
its neighbor nodes, it performed the block validation process
and recorded the three time components.

The measured results are summarized in Fig. 2. The block
validation time and the three components are averaged over
blocks containing different numbers of transactions. From the
measured results, we can see that the total block validation
time increases with the number of transactions in a block
and transaction execution is the component dominating the
block validation time. The analysis in [11] shows that block
propagation time is mainly determined by block validation
time when the block size is large. Therefore, the focal point
for speeding up block propagation should be to decrease the
transaction execution time.

C. Measurement on matched-block probability

Although compact block has the potential to reduce block
transmission time, the performance of compact block propa-
gation depends much on the matched-block probability—how
well the transactions in the received block match with those
contained in the local transaction pools of nodes. We measured
the matched-block probability in Ethereum. The experimental
setup is shown in Fig. 3. When an Ethereum node receives
a new transaction, it selects some of its neighbor nodes to
forward the new transaction, and selects the remaining neigh-
bor nodes to forward the transaction hash [34]. If its neighbor
nodes receive the transaction hash but the transaction is not in
their local transaction pools, the neighbor nodes then request
the transaction by sending the transaction hash to the node
from which they received the transaction hash [34]. Moreover,

2Although this result is presented under the context of PoW, it also applies
to other consensus algorithms, including PoS, PoA, PBFT, so long as block
propagation time increases with the block size in the consensus process.

4

Figure 2: The measured results of the block validation time.

Figure 3: The experimental setup for measuring matched-block
probability in Ethereum.

when an Ethereum node receives a new block, it performs
the transaction pool reset [34] to delete the transactions in the
new block from its local transaction pool. Thus, if the neighbor
nodes receive the transaction request after the transaction pool
reset, they will not reply to any requests for the transactions
included in this new block.

In our experiment, we set up a node called NetworkOb-
serverNode, as shown in Fig. 3. When NetworkObserverNode
received a new block from one of its neighbor nodes (e.g.,
neighbor node 1 in Fig. 3), it extracted all transactions in
the block and converted all these transactions to a set of
hashes. Then,
it pretended to miss these transactions and
requested them from all its neighbor nodes except the node
from which it received the block (i.e., neighbor node 1 in Fig.
3) using the transaction hashes. Once a neighbor node received
a transaction request, it responded with the corresponding
transaction stored in its local transaction pool.

We saved all responses of the all neighbor nodes to Net-
workObserverNode and measured the matched-block proba-
bility. In particular, we measured two statistics. The ﬁrst is
the transaction match rate deﬁned as the ratio of the number
of matched transactions to the total number of transactions in
all recorded blocks. The second is the block match rate deﬁned
as the ratio of the number of completely matched blocks to

[1, 100][101, 200][201, 300][301, 400][401, 500]The number of transactions in a block050100150200250300350400Average time (ms)Tx ExecutionData StorageHeader Validation   NetworkObserverNode1. Block2. Get Txs in Block3. Txs2. Get Txs in Block3. Txs2. Get Txs in Block3. TxsNeighbor Node 1Neighbor Node 2Neighbor Node 3Neighbor Node N5

Figure 4: The measured transaction and block match rates in
Ethereum blockchain.

the number of all recorded blocks. Here, we point out that if
the hashes of all transactions in a block are not replied by
a neighbor node, it means that this block has been received
by this neighbor node and this neighbor node has performed
a transaction pool reset. Therefore, we did not record this
neighbor’s responses to the transactions of this block in our
statistics.

The experiment was conducted during the period of Decem-
ber 27, 2021 to January 7, 2022. To ensure good representation
and to smooth experimental results, we selected 10 neighbor
nodes distributed in different locations around the world. Each
of these nodes returned more than 100 responses to Net-
workObserverNode. The experimental results are summarized
in Fig. 4. We can see that the transaction match rate ﬂuctuates
within the range of [0.80, 0.94] among all the neighbor nodes,
and the block match rate ﬂuctuates within the range of [0.10,
0.20]. This means that the Ethereum nodes have already stored
around 90% of the transactions of a propagating block into
their local transaction pool before they receive the block; but
the matched-block probability is only a little more than 10%
(i.e., there is a good chance that some transactions in a block
are still missing).

We can therefore hypothesize that although using compact-
block-like protocols in Ethereum may reduce the block trans-
mission time, the probability of requiring extra communication
rounds to request missing transactions is very high (about
90%), and that the saving in transmission time via transmitting
transaction hashes may come at the cost of additional time ex-
pended in requesting and receiving the missing transmissions.
This hypothesis is borne out by our experiment in Section
V-C. By looking deeper into the missed transactions in each
block, we found three causes for the missing of transactions:
• Late Transactions: Usually, a transaction is broadcast
to nodes before the block that contains this transaction
is mined by a miner. Nevertheless, some transactions
may be received and included into a block by one
miner early on when the transactions were just created.
Due to network congestion, some nodes may not have
received these transactions yet when the block arrives. In

Figure 5: BBP node architecture as an extension of Tx-Pool.

other words, these transactions are received later than the
blocks that contain them.

• Local Transactions: According to the current transaction
selecting and ordering algorithm, miners include their
locally generated transactions into a mined block with
high priority. But these local transactions may offer a
low GAS price, and as a result, other nodes that receive
them during their propagation may delete them and not
store them into their local pools.

• Withheld Transactions: For high proﬁt or privacy, some
miners may not broadcast transactions with high GAS
price but withhold them for the blocks that they mine [3].
There are also other examples of transaction withholding.
For example, in the recent FlashBots project [35], some
users privately send their MEV transactions to miners
without propagating them to other nodes.

III. OVERVIEW OF BBP

The analysis in Section II indicates that, fundamentally,
we must remove the block propagation time’s dependency on
the number of transactions in a block to achieve full TPS
scalability. As shown in Fig. 1(b), the basic idea of bodiless
block propagation (BBP) is that only the block header is
transmitted between nodes, and a new block is pre-validated so
that the in situ block validation during the block propagation
is just a simple comparison of the pre-computed global state
and the global state embedded in the block header.

To implement BBP, we propose to extend the Ethereum
Tx-Pool implementation with the architecture shown in Fig.5.
This architecture adds a pre-packed blockbody (PPB) module
and a pre-validation module to the Tx-Pool. The PPB contains
a selected subset of transactions from the Tx-pool, and it is
used to generate the next block by the mining module. Each
node pre-executes the transactions in its PPB and pre-computes
the global state, and then stores the global state into the pre-
validation module.

In the ideal case, the PPBs of all nodes are the same, and
that this common PPB is the same as the blockbody of the next
block mined by the lucky miner. With a perfectly synchronized
PPBs, only the header of the newly mined block needs to
be transmitted. When a node receives the new block header,
for validation, the node only needs to compare the global
state in the block header and the global state stored in the
pre-validation module. However, the ideal scenario may not

VirginiaWashingtonAtlantaBeijing1Beijing2HangzhouNurembergBangkokMumbaiTokyoLocation00.10.20.30.40.50.60.70.80.91RateTx match rateBlock match rateTx PoolPre-packedBlockbodyPre-ValidationPPB-SyncTxBlock MiningBlock MiningP2P NetworkTx PoolPre-packedBlockbodyPre-Validationarise automatically in practice. We need to overcome several
technical challenges for that to happen.

Challenge 1: The ﬁrst challenge is how to ensure all
nodes (or the majority of them) pre-pack the same PPB, even
though these nodes are distributed and may behave selﬁshly.
The transactions in Tx-Pool and their packing order may
vary from node to node (this is the case for Ethereum). To
address this challenge, we propose a Time-speciﬁc transaction
Selection and Ordering (TSO) algorithm to ensure the ordered
transactions in the PPBs of honest nodes are the same with
high probability. We further propose a low-overhead PPB
synchronization protocol to synchronize the PPBs of neighbor
nodes to ensure that in most cases the PPBs are the same.

In blockchain, each miner is selﬁsh and tends to pack local,
high-priced, and private transactions into the blockbody for
high proﬁt. The miners contruct the block contents in the
blockchain to maximize their own beneﬁt (i.e., to maximize
MEV [3]). In our BBP scheme, this problem is well addressed.
A mined block different from the PPB in honest nodes (as-
suming most nodes are honest) has a much larger propagation
time because the validation time will be longer in the absence
of pre-validation information. As a result, such a mined block
has a high probability to become a stale/uncle block. This dis-
incentivizes a miner from adopting a blockbody different from
the “standard” PPB of the honest nodes.

Challenge 2: The second challenge is how to deal with
the as-yet unavailable information during the pre-validation
process. Even if PPB is perfectly synchronized among all
nodes, some required information may not be available yet.
For example, some transactions may involve the Coinbase
address associated with the miner, but the successful miner
is not known yet during the pre-validation process. Our
pre-validation algorithm identiﬁes the transaction chains that
involve the Coinbase address and only executes transactions
that do not involve the Coinbase address. The global state com-
puted during the pre-validation is thus an intermediate global
state. Based on the pre-validation result, the re-validation can
be very efﬁcient (if it is needed after the PPB is received).

IV. DESIGN OF BBP

This section presents the design of BBP. We assume
the transaction forwarding and PoW consensus protocols of
Ethereum as the building components of the blockchain.3
BBP is also compatible with other transaction forwarding
and consensus protocols. BBP changes the block forwarding
protocol. We give the details of the new elements in BBP:
pre-packed blockbody (PPB) generation, pre-packed block
pre-validation, pre-packed block synchronization, and bodiless
block forwarding protocol.

A. PPB generation

In BBP, each node retrieves a subset of transactions from its
local Tx-pool in a speciﬁc order to generate a PPB. In the ideal
case, all nodes have the same PPB and use the same PPB for

6

Figure 6: The priority of transactions selecting and ordering
in Ethereum and in TSO.

pre-validation. In Ethereum, however, the transaction selection
and ordering are decided individually by the miners, with
preference given to their own transactions and transactions
with high GAS price, as shown in Fig. 6(a) and explained in
Appendix. To facilitate the adoption of a common PPB among
nodes, we propose a Time-speciﬁc transaction Selection and
Ordering (TSO) algorithm to disambiguate transactions and
their order. The TSO algorithm is as follows.

TSO: As discussed in Section II, late transactions and local
transactions are two causes for dissimilar PPB at different
nodes. To eliminate these two causes, TSO follows three new
rules as described in Algorithm 1. First, only transactions
whose timestamp is earlier than a predetermined timestamp
threshold T are eligible to be selected. Second, among all the
eligible transactions, transactions with a higher GAS price are
selected and ordered with a higher priority. Finally, if two
or more selected transactions have the same GAS price, their
order is determined by their transaction hashes. The detailed
TSO algorithm is given in Algorithm 1 and the priority in TSO
is illustrated in Fig. 6(b).4

In Ethereum, even if different nodes select the same set
of transactions into one block, the transaction orders may
be different because varying network latencies may cause
different
timestamps for the same transaction at different
nodes. In TSO, the order is unambiguous once different nodes
select the same set of transactions through the timestamp
threshold T (once selected, GAS price and TxHash dictate the
order of the transactions, not the timestamp). However, varying
network latencies may still cause a problem for transaction
selection, where the selected transactions with a timestamp
around T may be slightly different among nodes. We propose
a two-prong approach to address this issue: time threshold
setting and PPB synchronization (see Section IV-C below for
the detail on the latter)

Time Threshold Setting: As mentioned above, each node
only picks the transactions received earlier than T . Our ﬁrst
remark on T is that all nodes can easily agree on the same
timestamp T for each block. The second point is that a small
value of T may help to guarantee that the transactions to be
selected will have arrived at all nodes when pre-validation
is to be done, but the selection of a small T may cause a
larger transaction commit latency. We propose to set T as the
timestamp carried in the current block, which is known by all

3Since the implementation aspect of our work is based on Ethereum, we
give a brief technical overview of the Ethereum blockchain in the appendix
for readers unfamiliar the the technical details of Ethereum.

4Note that for each account algorithm 1 needs to select the transaction with
the smallest nonce value, as speciﬁed by line 1 and line 11, before the selected
transactions from all accounts are prioritized according to Fig. 6(b)’s schema.

High PriorityLow PriorityLocal AccountGasPriceTimestampTimestamp ThresholdGasPriceTxHash(a)  Tx Ordering In Ethereum(b) Tx Ordering In TSOAlgorithm 1 TSO algorithm

Algorithm 2 Pre-validation algorithm

7

5:

6:

7:
8:
9:

10:

11:

12:

Require: a timestamp threshold T ; two empty sets G and
Gc; the transaction queues for all accounts: the transaction
queue for each account i is I[i], in which the transactions
of account i are sorted in ascending order by the transac-
tion nonce value.

Ensure: G

1: Copy the ﬁrst transactions of the all transaction queues to

the candidate set Gc.

2: Remove the transactions in Gc with timestamp later than

T .

3: while The block GAS limit is not reached do
4:

Select the transaction in Gc that has the highest GAS
price.
if More than one transaction has the same highest GAS
price then

Select the transaction in Gc that has the highest GAS
price and the highest Hash value.

end if
Append the selected transaction to G.
Remove the selected transaction from Gc.
Remove the selected transaction from its transaction
this transaction queue as the current
queue and set
transaction queue.
if The ﬁrst transaction of the current transaction queue
has a timestamp earlier than T then

Add this transaction to Gc.

end if

13:
14: end while

Figure 7: Structure of validation information computed by pre-
validation.

the nodes that have received the current block. This way, the
commit latency is also acceptable.

B. Pre-Validation of PPB

With the help of TSO and the PPB sychronization scheme
(see Section IV-C), BBP can ensure the majority of the nodes
have the same PPB for the pre-validation process. In Ap-
pendix, we explain how a node performs the block validation
in Ethereum. Our pre-validation module computes a validation
information consisting of three components, as shown in Fig.
7. The ﬁrst component BodyHash is similar to the ﬁeld of
T Xs-Hash in Ethereum block header, which is computed
from all
the transactions in PPB. The second component
UnexecutableTxs is all the transactions that cannot be executed
in advance. The third component is the IntermediateState. We
explain the second and components below:

Require:

initial state S0; the remaining transaction sequence

T x = [T x1, T x2, ..., T xn]

Ensure: Sj+1

1: i = 0, j = 0
2: while i < n do
3:
4:
5:
6:

j = j + 1

else

if Sj+1 = Exec(Sj, T x[i]) is successful then

Remove T x[i] from PPB

end if
i = i + 1

7:
8:
9: end while

Un-executable Transactions: In Ethereum and most emerg-
ing blockchains supporting Turing-complete computing tasks
with smart contracts, some transactions may involve the Coin-
base address and cannot be executed in advance. One example
is the MEV transaction that may invoke a smart contract to
privately pay tips to the Coinbase address so that it can be
sealed into the block as soon as possible [35]. But for PPB
pre-validation, the Coinbase address is not yet known, and
therefore Coinbase transactions cannot be executed in advance.
Similarly, all other transactions affected by the Coinbase
transactions cannot be executed in advance. For PPB, we need
to ﬁrst identify all the un-executable transactions among the
selected transactions.

We say that two transactions intersect if there is at least one
common accessed account between them. For example, in Fig.
8 (a), the accessed accounts of Tx1 are {A, B} (transfer 2 ether
from account A to account B), the accessed accounts of Tx2
are {B, C}, and the accessed accounts of Tx3 are {C, D}.
Tx1 and Tx2 intersect with the common account {B}, and
Tx1 and Tx3 do not intersect. In general, if two transactions
intersect, the global state depends on their execution order. If
two transactions do not intersect, they can be executed in any
order without affecting the ﬁnal global state as shown in Fig.
8(b).

Based on this deﬁnition, we can determine the sequence of
all un-executable transactions, sequence Ug, from PPB. We
ﬁrst ﬁnd the transactions which access the Coinbase address,
and append them to Ug. Then, all the transactions that intersect
with any transaction in Ug are append to Ug sequentially. This
process is repeated until all remaining transactions in PPB do
not intersect with any transaction in Ug.

Intermediate State: The transactions in PPB that are not
in Ug can be executed independently of the transactions in
Ug. Thus, we can execute the transactions not in Ug before
the next block is mined. Speciﬁcally, we ﬁrst execute the
remaining transactions in PPB not in Ug sequentially in the
same order as in PPB and store the resulting global state as
the intermediate state. The detailed pre-validation algorithm is
shown in Algorithm 2.

C. PPB Synchronization Protocol

As explained in Section IV-A, the PPBs at different nodes
may still be different due to transactions with a timestamp

Pre-validation BodyHashUn-executableTxs IntermediateStateBodyHashUn-executableTxs IntermediateState8

Figure 8: Illustration of the execution process with intersected and un-intersected transactions.

Figure 9: (a) PPB synchronization protocol; (b) BBP forwarding protocol.

near T . We propose a PPB synchronization protocol with
which neighbor nodes exchange information to synchronize
their PPBs. Fig. 9(a) illustrates the protocol. When Node1
assembles or modiﬁes its PPB, it sends out a checkSync
message, which carries the BodyHash, to its neighbors. If
the receiving Node2 ﬁnds that the received BodyHash is
different from its own, it sends back all the transactions in
its local PPB to Node1. In this way, Node1 and Node2 can
locate those different transactions5. With the rule in TSO and
treating Node1 and Node2 as a union node for which eligible
transactions for either Node1 and Node2 are eligible for the
union node, we add all eligible transactions to both PPBs
sorted in the order as described in Section IV-A. As a result,
we can obtain a synchronized PPB, the union of all the nodes’
initial PPB before synchronization.

To deal with the potential of a dishonest node’s attack
by inserting ineligible transactions in PPB, we modify the
above protocol a little. When a node ﬁnds some transactions
in its neighbor’s PPB that are not in its own PPB, only the
transactions in its local Tx-pool with local timestamps earlier
than T + δ are added to its own PPB. For transactions not

5This transaction localization process can be implemented more efﬁciently

with the algorithms in [10].

in its local Tx-pool or transactions with a local timestamp
later than T + δ, the node cannot add them into its local
PPB. Therefore, if an attacking node purposely modiﬁes the
timestamps of transactions so that its selected transactions
modiﬁed timestamps earlier than the threshold T , an honest
node will reject the invalid transactions, since the local times-
tamps for these transactions at the honest node are later than
T +δ. Here δ is a predetermined parameter to upper bound the
transaction propagation delay. The work in [34] measured that
a transaction would take no more than 1 second to propagate to
most standard Ethereum nodes, and thus we set δ = 1 second.

D. BBP Forwarding Protocol

As shown in Fig. 9(b), when a node successfully mines
a block,
it sends the block header to its neighbors that
have the same BodyHash and sends the full block to its
neighbors that have different BodyHash. When a node receives
a block header, it can conduct the PPB-validation procedure,
as described in the next paragraph. If the validation passes,
the block header will be forwarded along. There are rare
cases of different PPBs among a few nodes, since the PPB
synchronization can not be perfect. The miner sends the full

(a)(b)ATx1BATx1BATx1BBCTx2BCTx2BCTx23ETHCDTx3CDTx3CDTx31ETHRoot Node...A1ETHC0ETHB3ETHD2ETH...Global State Tree 1Tx1Tx3Tx3Tx1Root Node...A1ETHC0ETHB3ETHD2ETH...Global State Tree 22ETHRoot Node...A3ETHC1ETHB1ETHD1ETH...Initial Global State Tree Node 1Node 1Node 2Node 22. PPB-Validation1. Header3. Header Node 3Node 35.  Block4.  PPB-Validation6. Block ValidationNode 1Node 1Node 2Node 21. Update PPB3. Compare BodyHash2.  checkSync5. Locate different Txs 4.  All Txs in  local PPB 6. Update PPB（a）PPB synchronization（b）BBP forwarding protocolblock to a neighbor with a different BodyHash.6

PPB-Validation Procedure: With the pre-validation infor-
mation, a node can quickly verify the received block header.
First, it compares the local BodyHash with the T xs-Hash in
the received block header. If the two hashes are different, the
block bodies are different, and the node requests the full block
for validation as in Ethereum. If the BodyHash check passes,
the node then gets the Coinbase address from the block header,
with which the node can then execute the transactions in Ug
in order, based on the IntermediateState. If the ﬁnal global
state equals the one in the block header, this block will be
committed to local database, and the validation is successful.

V. PERFORMANCE MODELING AND EXPERIMENTAL
EVALUATION

Section V-A builds analytical models to understand factors
affecting the block-propagation performance of BBP, Legacy
Block Propagation (LBP) and Block-Hash Propagation (BHP)
of Ethereum, and the Compact Block Protocol (CBP) of
Bitcoin. We implemented the four protocols, and Sections V-
B and V-C also present experimental evaluations of the four
protocols over a test network.

A. Modeling block propagation latency

We assume that each link between different nodes has the
same transmission bandwidth. Denote the size of the block
header and body by sh and sbody , respectively. Then, sb =
sh +sbody is the size of the full block. The size of the message
with one hash is ﬁxed to shash. For some control messages,
such as getHeader, getBody, the message mainly contains a
hash, and the message size is approximated by shash. Let h be
the expected number of hops along paths over which a block
is broadcasted from a miner node to 90% of the nodes in the
blockchain network. The expected number of hops depends
on the network topology.

BBP propagation latency: Consider a propagation path of
BBP as shown in Fig. 9(b). Along this path, the proportion of
hops for which the receiver node and the sender node disagree
on PPB is denoted by γ. If the receiver’s PPB is different from
the sender’s PPB, then the sender needs to transmit the full
block to the receiver and the receiver needs to validate the full
block.7 The expected time used for this portion of hops can
be expressed as

γh(tv + tt + tc) = γh(ntte + nttw + th +

+ tc)

sb
bw

In the above, tv is the time to verify a block of nt transactions,
which is the sum of transaction execution time ntte, the global
state writing time nttw, and the block header veriﬁcation time
is th. The link transmission time is tt = sb/bw. The signal
propagation delay, which depends on the physical distance
between the two end nodes of a link, is tc.

6The neighbors’ BodyHash values can be remembered during the PPB
synchronization procedure. And this broadcasting can be more efﬁcient by
attaching those missing transactions in the block header for the rare cases of
non-synchronized PPBs.

7A hybrid validation scheme as in BHP could potentially be applied here

to further improve the propagation performance.

9

The sender and the receiver have the same PPB for the
other hops. Only a block header is transmitted, and a quick
PPB validation is applied. In this case, only the block header
and un-executable transactions need to be validated. Therefore,
the time used for this portion of hops can be expressed as

v + t(cid:48)

t + tc)

(1 − γ)h(t(cid:48)
= (1 − γ)h((nt − nu)tr + nute + th + sh
bw

+ tc)
In the above, the reduced link transmission time is t(cid:48)
t = sh/bw.
The validation time, t(cid:48)
v for BBP is the sum of un-executable
transaction execution time nute,
the IntermediateState
reading time (nt − nu)tr, and the block header veriﬁcation
time.8

From the above, the expected propagation delay of BBP can

be modeled as

tBBP = γh(ntte + nttw + th + sb
+ tc)
bw
+(1 − γ)h((nt − nu)tr + nute + th + sh
bw

+ tc)

(4)

As shown in eq. (4), if the PPB synchronization is perfect
(γ = 0) , and there is no un-executable transactions (nu = 0),
tBBP is determined by the computer variable reading time
nttr, which is typically very small. Therefore,
the block
propagation time of BBP is almost independent of the number
of transactions inside the block, and the time is much less than
receiving and storing those transactions. In other words, the
miners can package all transactions from Tx-pool in BBP as
long as the nodes can well propagate those transactions over
the network. In a real system, γ is not zero, but it can be
controlled with our PPB synchronization in Section V-C to a
small value (about 3.5% as shown in our experiments ) and
nu ≈ 0.01 as measured in Ethereum.

LBP propagation latency: Before the introduction of Com-
pact Block, Bitcoin used the legacy block propagation proto-
col. It works as shown in Fig.10 (a). When a node receives a
block, it ﬁrst validates the block header and body. If the block
passes validation, it announces an inv message to its neighbor
nodes. If a neighbor node did not receive this block before, it
replies with a getData message to request the full block. Since
the message only includes one hash, the size of getData and
inv is shash. Therefore, the expected propagation time delay
is

tLBP = h(tv + tt + tinv + tget + 3tc)

= h(ntte + nttw + th + 2shash+sb

+ 3tc)

bw

(5)

BHP propagation latency: Currently, Ethereum uses a hybrid
block propagation protocol, the Block-Hash protocol, as shown
in Fig. 10(b). Consider a Node1 that receives a new block
and suppose that its N neighbor nodes have not received this
block. Node1 ﬁrst veriﬁes the block header with the time th
√
N neighbor nodes to forward
and then randomly selects
the full block. The expected time for this procedure can be
expressed as

h(t(cid:48)

v + tt + tc) = h(th +

sb
bw

+ tc)

Then, Node1 further veriﬁes the full block with time tv and
N ) neighbor
forwards the block hash to the remaining (N −
nodes, such as Node3. When Node3 receives the block hash,
it ﬁrst waits for a constant time t1 (400ms). After that, it
sends a getHeader message to request the block header from

√

8The global state writing time is performed in a parallel manner.

10

Figure 10: The speciﬁc protocols of (a) LBP, (b) BHP, and (c) CBP.

one neighbor node that has sent the block hash. If Node3
receives the response of the block header, it then waits for a
constant time t2 (100ms) before sending a getBody message
to request the blockbody from a randomly selected neighbor
(assume node1 again) that has sent the block hash. Finally,
Node3 obtains the full block by assembling the received block
header and body. As shown in Fig. 10 (b), it is time-consuming
for a node to obtain the block through block hash. This
process is aborted if Node3 receives the block from another
neighbor node. The time for this complicated procedure can
be expressed as

h(tt + thash + 2tget + 5tc + tv + t1 + t2)
= h(ntte + nttw + th + nn sb+3shash

+ tc + tc(cid:48))

bw

(6)

where t(cid:48)
c = 4tc + t1 + t2 is a constant time delay. Suppose α
is the proportion of the hops that broadcast the block through
the block hash. The expected propagation time of BHP can be
expressed as:

tBHP = (1 − α)h(th + sb
bw
αh(ntte + nttw + th + sb+shash
= h(th + sb
bw

bw

+ tc)+

+ tc) + αh(ntte + nttw + 3shash

+ tc(cid:48))

bw

+ tc + tc(cid:48))

(7)

In Ethereum, α is typically much less than 1. Since the full
block is always transmitted in BHP, the transmission time of
the full block dominates.

CBP propagation latency: Bitcoin currently adopts compact
block propagation. Fig.10(c) shows how it works. When
Node1 receives a new block,
it validates the block and
generates a compact block version. The time for this process
is approximately tv.9 Then it announces this compact block
by sending an inv packet that contains the basic message
(e.g., the block hash) to its neighbor Node2. If Node2 does
not have this block, it replies with a getData message to
request the compact block from Node1. After Node2 receives
the compact block, it restores the new block with transactions
in its local transaction pool. If Node2 misses some transactions
in the compact block, it requests them from Node1. In the end,

9The node extracts the block header and transaction hashes to assemble the
compact block when it validates the block successfully. The time consumed
by the assembly process is negligible.

Node2 restores the new block with transactions collected from
its local transaction pool and Node1.

As with BHP, the size of getData, getM issedT xs and inv
can also be approximated by shash. And based on the above
discussion about CBP, its propagation latency can be estimated
as follows:

bw

bw

) + βh(2tc + shash+stxs

tCBP = h(tv + 3tc + 2shash+sc

)
(8)
where β is the proportion of the hops that the receiving node
needs to request missing transactions from the sender and stxs
is the expected size of all missed transactions in the compact
block. Recall that in Bitcoin, the block generation time is about
10 minutes, and within this time, the transactions are well
propagated all over the network before the new compact block
is announced. Most transactions within the block already exist
in the local transaction pool, and β is near zero. The block
validation dominates the total time. However, this is not the
case for Ethereum.

Discussion: As shown in the above models, each node
in BHP may receive more than one full block (full block
broadcasting) while the block validation is postponed to im-
prove the efﬁciency. As a result, it occupies more network
bandwidth and the transmission delays is linear with nt. CBP
and LBP only request the new block when needed, thus saving
communication bandwidth. But for both CBP and LBP, it is
necessary to complete the validation of the full block before
forwarding, and the validation time is linear with nr. In
our BBP, since PPB is almost completely synchronized and
un-executable transactions are near zero, its only needs to
propagate and validate the block header, and its propagation
time is independent to nt. Therefore, only PPB can approach
TPS scalability.

B. Experiment Setup

Experiment Testbed: The direct deployment of thousands of
physical machines over a large blockchain network topology
are complicated and expensive,
impossible. To run
our experiments, we built a multi-node network environment
based on docker container technology in the Linux server and

if not

Node 1Node 1 Node 2 Node 21.Block3.BlockNode 3Node 35.Block Hash7. getHeader8.Header10. getBody11.Body(b) BHP2. Validate Header4. Validate Block 6.Wait 100ms6.Wait 100ms1.BlockNode 1Node 1Node 2Node 24. inv(c) CBP2. Validate Block 3.Generate Compact Block5. getData6. Compact Block8. missedTXs7. getMissedTxs3.INV4.Get Data5.Block1.BlockNode 1Node 1Node 2Node 22.Block Validation(a) LBP11

Figure 11: The nodes distribution and expected link delays in
our experiments.

Table I: Parameter of the Docker network simulator

Parameter
Number of nodes
Block interval

Network topology

Average bandwidth
for each link
Packet loss rate for
each link

Values
1000
13-15s [6]
Power-law distribution and
small-world property [34]

55Mbps [38]

Randomly distributed over
(0%,1%)

physically connected 4 servers over a software-deﬁned net-
work. With this software-conﬁgurable semi-physical testbed,
we can simulate large-scale distributed networks. We fully
implemented the blockchain peers for the above four block-
propagation protocols based on the Ethereum software version
v1.8 [36]. The blockchain peer software was loaded and run
in each docker container. Performance data are recorded in a
log ﬁle and analyzed with shell/python programs.

Network Parameters and Topology: The most important
issue for the experimental testbed is the network environment
and topology. We implemented a network controller which can
conﬁgure and control the network parameters between any two
nodes in the testbed. Following the worldwide nodes’ geo-
graphical distribution as in [37], we classify the experimental
nodes into four groups to simulate the nodes in four dominant
continents: Asia, Oceania, North America and Europe. Based
on the link propagation latency measured with ping, we set
the distributions of the link latency as follows. The latency
of links inside a group is uniformly distributed over [10ms,
40ms] with a mean of 25ms; the latency of links between Asia
and Oceania/links between Oceania and North America/links
between North America and Europe is uniformly distributed
over [40ms, 60ms] with a mean of 50ms; the latency of links
between Asia and North America/links between Oceania and
Europe is uniformly distributed over [60ms, 90ms] with a
mean of 75ms; the latency of links between Asia and Europe
is uniformly distributed over [90ms, 110ms] with a mean of
100ms. The mean delays of links cross groups are shown in
Fig. 11.

The overlay P2P network of the blockchain is generated
based on the Ethereum node discovery algorithm, in the same
way as Ethereum.

Experimental Testbed Validation: In our experiment, we
built a testbed network to simulate the Ethereum blockchain
system with parameter settings as in Table I. As noted in Table
I, most parameter settings are drawn from prior work that

Figure 12: The processing time validating a BBP block versus
number of transactions nt number of non-executable transac-
tions nu.

studied Ethereum.

To validate our testbed, we compare the 90% block propaga-
tion delay of our testbed with real Ethereum. From December
21, 2021 to December 31, 2021, we recorded the number
of daily uncle blocks [6] in Ethereum to calculate the uncle
block probability pf (i.e., fork probability). According to the
measurement result, pf ﬂuctuated within the range of [0.055,
0.064] with an average value 0.059. Additionally, the block
interval is 13-15s during this period, with an average value of
14s. Using eq. (2), we compute that the 90% block propagation
delay on the actual Ethereum network is about 851ms. For our
testbed experimental results, as shown in Fig. 15, when nt is
200, the 90% block propagation delay of Ethereum protocol
is 829ms, close to the delay on the actual network. Therefore,
our Docker network testbed is a good tool to simulate to the
actual Ethereum network.

C. Experiment Results

This subsection presents experimental results to verify the
efﬁciency of BBP and compare its performance with LBP,
BHP and CBP. Speciﬁcally, we examine the block processing
time, the block transmission trafﬁc, and block propagation
delays of these propagation protocols in our testbed [39].

Block Processing Time: To demonstrate the efﬁciency of
the pre-validation algorithm, we measure the block processing
time of BBP, including the validation of the block header and
execution of transactions in the non-executable sequence as
in eq. (4). The experiment results are shown in Fig. 12, with
different block transactions nt and different sizes of the non-
executable sequence nu. From Fig. 12, we can see that the
local time is minimized when nu = 0 and is about 12ms
for nt = 2000. As nu increases, the block processing time
increases linearly. According to the data in Ethereum [6], there
are about 1-3 Coinbase address transactions in one block, and
nu is typically only around 1%.

PPB Synchronization: In BBP, each node assembles a pre-
packed blockbody with the TSO algorithm and synchronizes
PPB with its neighbors. We count the number of synchronized

50ms50ms50ms75ms100ms75msNorth America40%Asia 20%Oceania 20%Europe20%0  0.10.20.30.40.50.60.70.80.91  nu / nt50100150200250300350Processing Time(ms)nt=200nt=500nt=1000nt=2000Header ValidationTxs Execution12

Figure 13: The percentage of non-synchronized PPB versus
block size nt.

Figure 15: The 90% block propagation time with various
transaction number nt in a block.

Figure 14: The network trafﬁc generated by block propagation
versus block size nt.

Figure 16: The number of stale transactions within a period
of 1000 blocks.

PPBs and non-synchronized PPBs upon a block arrival during
the experiment and plot the proportion of non-synchronized
PPBs in Fig. 13. As shown in this ﬁgure, the percentage of
non-synchronized PPBs ﬂuctuates within the range of [1.8%,
6.8%], with an average value about 3.5% and it does not
depend on nt. Since 90% node propagation is good enough,
this 96.5% propotion of synchronization is a good result.

The Block Trafﬁc Load: We then measure the total network
trafﬁc induced by broadcasting blocks among all nodes. The
measurement results are shown in Fig. 14. Beneﬁting from
the bodiless design, the block trafﬁc load of BBP almost keeps
constant for various nt, while the block loads of the other three
protocols increase linearly with nt. When nt = 200, the block
trafﬁc of BBP is only 1/2 that of CBP, 1/4 that of LBP, and
1/10 that of BHP. BHP creates the most trafﬁc load because it
N neighbors, while CBP and LBP
broadcasts full blocks to
only request one full block when needed. It should be noted
that LBP and CBP incur one more round of communication.
Block Propagation Time: Fig. 15 shows the time for a block
to propagate to 90% of nodes in the network versus number
of transactions in a block. Due to the scalability of BBP, its

√

propagation time is almost constant for various nt, while for
other protocols, the propagation time linearly increases with
nt. Speciﬁcally, BBP needs the least amount of time among
all protocols, and it only needs 1/4 time of the BHP protocol
when nt = 500. The CBP performs worst in the setting since
the block interval tg (13-15s) is much shorter than that (10
minutes) in Bitcoin. As with our measurement in Section II,
over 90% nodes need to request the missing transactions with
one more round of communications.

Stale Transaction Number: When nt increases, not only
the block propagation time increases, but also the number of
stale transactions. A received transaction is regarded as a stale
transaction if it has been committed into a block according
to local recording. In this case, the transaction propagation
lags the block propagation, and the blockchain network does
not work properly anymore. As shown in Fig. 16, the number
of stale transactions for BBP is near zero while the numbers
of stale transactions for other block propagation protocols
increase exponentially when nt > 300. The reason is that
BBP only packs transactions prior to the current block and
leaves more time for the transactions to propagate.

100200300400500nt00.010.020.030.040.050.060.070.080.090.1100200300400500nt0510152025Traffic Overhead(GB)BBPBHPLBPCBP100200300400500nt0500100015002000250090% Propagation Delay(ms)BBPBHPLBPCBPBBPBHPLBPCBP100200300400500nt024681012Total Number of Stale TXs107BBPCBPLBPBHP13

VI. RELATED WORK

few nodes.

Improving TPS is a fundamental problem for the Ethereum
blockchain. To solve the problem, a divide-and-rule strat-
egy [13, 14] that divides the nodes and related transactions
into parallel groups for parallel processing can be effective.
The Ethereum sharding proposal [15] proposes to split the
world state and transaction history into different shards and
to allow parallel processing of the transactions in different
shards. While this strategy may increase TPS, it sacriﬁces
decentralization and security to a certain degree, since they
divide the whole network into a group of small networks.
Plasma [16] is an off-chain solution that extends the concept
of sidechains to reduce the number of transactions executed
by the main chain on Ethereum. The main chain only records
the execution results from sidechains periodically to seal the
periodic summaries. A drawback of Plasma is that it needs to
store a series of smart contracts on the main chain to process
the data from the sidechains, increasing the storage costs at
nodes. Moreover, Plasma merely supports the simple transfer
transactions and cannot perform complex procedures of smart
contracts.

The efﬁciency of consensus algorithms can directly de-
termine the speed of block generation and thus determines
the TPS. Therefore, there have been many efforts devoted
to change the consensus protocol of blockchain to improve
TPS. Under the Proof-of-Work (PoW) consensus adopted by
the current Bitcoin and Ethereum blockchains [17], every
node needs to execute all transactions in each block to val-
idate the block propagated on the network. PoW guarantees
decentralization, consistency, and security of the blockchain
simultaneously [18], but it also leads to low TPS. Assuming
PoW, [19–21] analyzed the relationship among block size,
conﬁrmation rate, and TPS. To increase TPS, it is necessary
to increase block generation rate. However, the increase of
block generation rate increases the fork rate blockchain, which
compromises security. To enhance security with the increase
of block generation rate, the GHOST protocol deals with the
high fork rate by resolving forks using the rule of heaviest
subtree [20]. The heaviest subtree rule can enable blockchain
to beneﬁt from the blocks generated by nodes in a high rate.
While this strategy can resist 50% of pure private attacks when
the fork rate is high [21], it is vulnerable to public-private
balance attacks [22]. In general, improving the TPS of PoW
while maintaining security is very challenging.

Replacing PoW with other consensus algorithms is another
approach to improve TPS in Ethereum. The Ethereum com-
munity has proposed to combine Proof-of-Stake (PoS) and
sharding to boost TPS [23]. But [24] points out that PoS
can only be used in the ﬁnality stage where a few nodes,
selected according to their stakes as the validators, would vote
on which shard should join the main chain. And this validation
conducted by a few nodes compromises the decentralization
and security of the blockchain. Another consensus protocol
that can achieve high TPS is Practical Byzantine Fault Toler-
ance (PBFT) [25] . However, the communication complexity
of PBFT is proportional to the square of the number of nodes
that PBFT can only be adopted in consortium chains with a

There have also been works [26, 27] arguing that PoW
is the only viable consensus algorithm in real blockchain
systems. Along this line of argument, changing/replacing the
PoW consensus algorithm is not feasible. Last but not least,
these new consensus protocols are incompatible with today’s
Bitcoin and Ethereum blockchains.

Optimizing the performance of

the P2P network of
blockchain is yet another way to boost TPS. Since the
data consistency of blockchain relies on the network-wide
the block propagation speed on the
broadcast of blocks,
network determines the performance limit of blockchain [28].
Investigations in [8, 29–31]proposed to decrease the block
propagation time by redesigning the block propagation pro-
tocol. Also, several works advocated building new network
infrastructures to speed up block propagation. For example,
[32] proposed to use a blockchain distribution network (BDN)
with high throughput servers to speed up the propagation of
large blocks. However, such an approach requires building a
new infrastructure controlled by a central authority, partially
offsetting decentralized blockchain’s many advantages.

The aforementioned works all modify/redesign the PoW
consensus protocol to scale TPS at the risk of introducing new
security issues. Unlike these works, our BBP protocol aims to
achieve the full TPS scalability of Ethereum-like blockchain
by only reworking the block propagation protocol and thus
preserving the strict security level afforded by the PoW
consensus protocol. Importantly, as a networking functionality,
BBP is compatible with various consensus algorithms and
other TPS-scaling schemes.

VII. CONCLUSION
The block propagation time in current blockchain networks,
consisting of block validation time and transmission time, is
the TPS performance bottleneck. Furthermore, the tradeoff be-
tween TPS and security is fundamental in today’s blockchains:
many solutions that boost TPS come at the expense of lowered
security. This paper proposes a bodyless block propagation
(BBP) mechanism with pre-validation that can speed up block
propagation by 5 times relative to Ethereum without compro-
mising security. More importantly, the block propagation time
in BBP is almost independent of the number of transactions in
a block. As a result, block propagation no longer limits TPS.
Implementing BBP amounts to just inserting a pre-packed
blockbody module and a pre-validation module as extensions
to the transaction pool. Thus, BBP is compatible with other
lower-layer and upper-layer blockchain techniques. Experi-
mental results corroborate the TPS scalability and superior
performance of BBP.

This appendix gives the backgrounds of Ethereum block-
chain related to our BBP design, including Ethereum’s its
account model, transaction selection and ordering algorithm,
block generation and validation process.

APPENDIX A
ACCOUNT MODEL IN ETHEREUM
Blockchain is essentially a distributed database (or ledger).
Blockchain nodes modify the data stored in the database in

14

Figure 17: Illustration of account model in Ethereum.

a decentralized but mutually consistent manner by running a
consensus algorithm. At present, there are two data storage
models [40], the Unspent Transaction Outputs (UTxO) model
of Bitcoin and the account model of Ethereum. The UTxO
model is stateless and only supports the token transfer func-
tion. By contrast, the account model is stateful and supports
the execution of generic programs on blockchain called smart
contracts. Ethereum adopts the account model with smart-
contract functionality to extend blockchain applications.

There are two types of accounts on Ethereum: the external
account and the contract account. External accounts are created
by blockchain users to receive, hold, and send ETH, and they
may invoke smart contracts to execute complex operations.
Contract accounts are used by smart contracts to store the
contract code and the related data. As shown in Fig. 17, each
account has its own state, and a global state tree organizes
and manages the states of all accounts in the blockchain. The
leaf nodes of the global state tree, indexed by the account
address, record the state of their corresponding accounts. The
state of the account consists of four ﬁelds: Nonce, Balance,
CodeHash, and StorageRoot [41, 42]. Both the external and
contract accounts have the ﬁrst two ﬁelds. Nonce records the
total number of transactions issued by the account, and each
transaction also contains a nonce value corresponding to the
account state. A transaction issued by an account must be
executed in ascending order of nonce10. Balance is the amount
of ETH currently owned by the account. The remaining two
ﬁelds are only related to contract accounts. CodeHash is a 256-
bit hash of the corresponding contract code. If a transaction
triggers the execution of a contract, it can access this ﬁeld to
extract the contract code to complete the desired operation.
In addition to CodeHash, there is also a StorageRoot ﬁeld in
the external account that points to the root state node of the
account storage tree, which records all the data related to an
account, such as the balance of ERC20 token [43].

The global state tree follows the format of the Merkle-
Patricia tree [42]; therefore, modifying the state of the leaf
node results in a totally different root value of the tree. The
root of the global state tree is recorded in the block header
as a snapshot of the blockchain when the miner generates
the block. As shown in Fig.18, upon receiving a new block,
each blockchain node sequentially executes the transactions
in the block using the Ethereum Virtual Machine (EVM) and
modify the global state accordingly. After executing all the

10Assuming the nonce of the account state is n, the nonce of a new
transaction issued by this account must be set to n + 1. If the nonce of
the transaction is smaller than n, the transaction is called a stale transaction.
And If the nonce of a transaction is larger than n + 1, the transaction is called
a future transaction. The stale transactions and future transactions cannot be
propagated.

Figure 18: The process of state transition by executing trans-
actions.

transactions, the blockchain node compares the root of the
new global state tree with the root in the block header. If the
two roots matches, the block is accepted and inserted into the
local blockchain of the node; otherwise, the node discards the
block.

APPENDIX B
TRANSACTION SELECTION AND ORDERING
A blockchain node follows the Balance-and-Nonce rules11
to issue a new transaction and propagate the transaction to
other nodes. When a user node receives the new transaction,
it validates the transaction based on the local global state
tree and the rules of the account model. If the transaction
is valid, the user node stores the transaction into its own
local transaction pool. Before the transaction is packed by
a miner node into a new block successfully, it will not be
executed. Currently, there are approximately 138,000 pending
transactions in the Ethereum network. However, due to the
limitation of the block size, each block can only include
about 200 transactions. The miner node selects a batch of
transactions from its local transaction pool and packs them
into the block. The transactions included in the new block
and their order decides the next state of the blockchain.

As show in Fig. 6(a), there are three sequential levels of
priorities for transaction selection and ordering in the current
Ethereum system. For a miner node, the transactions issued
by the its local account enjoy the highest priority (called local
transaction). In other words, in order to save transaction fees
and to accelerate its own transactions, the miner node would
ﬁrst pack its own transactions into the new block. As for the
transactions issued by other nodes, the GAS price 12 is the key
factor for transaction selection. To gain more transaction fees,
the miner node prefers to select the transactions with higher
GAS price ﬁrst. Lastly, if two or more transactions have the
same GAS price, the miner node selects the earliest transaction
based on timestamp.

APPENDIX C
BLOCK GENERATION AND VALIDATION PROCESS IN
ETHEREUM

Like Bitcoin, Ethereum also adopts the proof-of-work
(PoW) consensus algorithm to synchronize all the blockchain
nodes. There are two types of Ethereum nodes: the miner

11Account transfer amount and fees must smaller than the balance recorded
on the global state tree, and the transaction nonce must equal to the nonce+1
recorded on the global state tree.

12Each transaction needs to be executed by EVM, and every computational
step in EVM is priced in units of GAS. The price the user wishes to pay
per unit of GAS is GAS price. The transaction fees equal the GAS price
multiplied by the total GAS required to execute the transaction. That is, the
larger GAS price, the larger transaction fees.

Account StateNonceBalanceCodeHashStorageRootRoot NodeGlobal State TreeRoot NodeAccount Storage TreeLeaf NodeGlobal State(Parent Block)Global State(Tx1)Global State(Tx2)Global State(New Block)Tx1Tx2Tx3--Txn15

[3] Kaihua Qin, Liyi Zhou, and Arthur Gervais. Quantifying
blockchain extractable value: How dark is the forest?
arXiv preprint arXiv:2101.05511, 2021.

[4] Lennart Ante. Non-fungible token (nft) markets on the
ethereum blockchain: Temporal development, cointegra-
tion and interrelations. Available at SSRN 3904683, 2021.
[5] Haihan Duan, Jiaye Li, Sizheng Fan, Zhonghao Lin, Xiao
Wu, and Wei Cai. Metaverse for social good: A university
In Proceedings of the 29th ACM
campus prototype.
International Conference on Multimedia, pages 153–161,
2021.
[6] Etherscan.

https://etherscan.io/txsPending/. Accessed

January, 2022.

[7] Arthur Gervais, Ghassan O Karame, Karl W¨ust, Vasileios
Glykantzis, Hubert Ritzdorf, and Srdjan Capkun. On the
security and performance of proof of work blockchains.
In Proceedings of the 2016 ACM SIGSAC conference
on computer and communications security, pages 3–16,
2016.
[8] Matt

Compact

block

Corallo.
152.

lay.bip
https://github.com/bitcoin/bips/blob/master/bip-
0152.mediawiki, 2016.

[Online].

[9] Peter

Tschipper.

Buip-010

re-
Available:

xtreme
Available:

thinblocks.
https://github.com/BitcoinUnlimited/BUIP/blob/master/010.md,
2016.

[Online].

[10] A Pinar Ozisik, Gavin Andresen, Brian N Levine, Darren
Tapp, George Bissias, and Sunny Katkuri. Graphene: ef-
ﬁcient interactive set reconciliation applied to blockchain
propagation. In Proceedings of the ACM Special Interest
Group on Data Communication, pages 303–317. 2019.
[11] Yahya Shahsavari, Kaiwen Zhang, and Chamseddine
Talhi. A theoretical model for block propagation analysis
in bitcoin network. IEEE Transactions on Engineering
Management, 2020.

[12] Bing Liu, Yang Qin, and Xiaowen Chu. Reducing
forks in the blockchain via probabilistic veriﬁcation.
In 2019 IEEE 35th International Conference on Data
Engineering Workshops (ICDEW), pages 13–18. IEEE,
2019.

[13] Junfeng Xie, F Richard Yu, Tao Huang, Renchao Xie,
Jiang Liu, and Yunjie Liu. A survey on the scalability
IEEE Network, 33(5):166–173,
of blockchain systems.
2019.

[14] Qiheng Zhou, Huawei Huang, Zibin Zheng, and Jing
Bian. Solutions to scalability of blockchain: A survey.
IEEE Access, 8:16440–16455, 2020.

Foundation.

[15] Ethereum
ing
https://github.com/ethereum/wiki/wiki/ShardingFAQs,
2018.

Shard-
[Online].Available:

faqs.

[16] Joseph Poon and Vitalik Buterin.

Plasma: Scalable
autonomous smart contracts. White paper, pages 1–47,
2017.

[17] Leo Maxim Bach, Branko Mihaljevic, and Mario Za-
Comparative analysis of blockchain consensus
In 2018 41st International Convention on

gar.
algorithms.

Figure 19: The process of block generation and validation.

nodes and the user nodes. The miner nodes compete to
generate the next new block by solving a PoW puzzle. If
a miner node successfully generates a new block, it then
propagates the block to the other miner nodes and user nodes
via the underlying P2P network. The remaining miner nodes
and the user nodes perform the block validation process
upon receiving the new block. Overall, the operation of the
Ethereum blockchain system is a repeated process of block
generation and block validation, as described below.

Block Generation: Fig. 19 illustrates the block generation
process within a miner node. To generate a new block, the
miner node ﬁrst writes the necessary information into the
block header, including the current block number, timestamp,
miner address and so on. Then, the miner selects a subset of
transactions from its local transaction pool according to the
prioritization discussed in the last subsection. Next, the miner
node executes these transactions to update the global state tree
using EVM. After that, the miner node writes the root node of
the new global state tree into the block header; and then enters
the mining process to calculate a valid consensus proof. Once
a valid consensus proof is successfully calculated, a legal and
full block is generated. The miner node then propagates this
block to other Ethereum nodes and writes the new global state
into its local database. Once the miner node receives a new
block sent from another Ethereum node, it suspends its block
mining and enter the block validation process.

Block Validation: Fig. 19(b) illustrates the sequential pro-
cess of block validation. The Ethereum node ﬁrst validates the
correctness of the block header. For example, it checks whether
the timestamp of the new block is later than the timestamp of
the parent block, and whether the consensus proof is valid.
If the block header is correct, the node sequentially executes
all transactions in the block and obtains the new global state
locally. After that, the Ethereum node compares the root node
of local global state tree and the root node in the block header.
If the two root nodes are the same, it stores the modiﬁed state
and the new block to its local database. The Ethereum node
discards the block if any step fails in the process of block
validation.

REFERENCES

[1] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic
[Online]. Available: http://bitcoin.org,

cash system.
2008.

[2] Vitalik Buterin et al. Ethereum: A next-generation smart
contract and decentralized application platform. URL
com/ethereum/wiki/wiki/% 5BEnglish%
https://github.
5D-White-Paper, 7, 2014.

1.Header Writing2.Txs Selection3.Txs Execution4.PoW Calculation5.Data Storage2.Txs Execution3.Data Storage(a) Block Generation(b) Block Validation1.Header Validation16

[32] Uri Klarman, Soumya Basu, Aleksandar Kuzmanovic,
bloxroute: A scalable trustless
IEEE In-

and Emin G¨un Sirer.
blockchain distribution network whitepaper.
ternet of Things Journal, 2018.

[33] Carlos Pinz´on and Camilo Rocha. Double-spend attack
models with time advantange for bitcoin. Electronic
Notes in Theoretical Computer Science, 329:79–103,
2016.

[34] Taotao Wang, Chonghe Zhao, Qing Yang, Shengli Zhang,
and Soung Chang Liew. Ethna: Analyzing the underlying
IEEE
peer-to-peer network of ethereum blockchain.
Transactions on Network Science and Engineering, 2021.
https://github.com/ﬂashbots/pm. Accessed

[35] Flashbots.

January,2022.

[36] V. Buterin.

Go ethereum.
https://github.com/ethereum/go-ethereum/, 2014.

[Online]. Available:

[37] Ethernodes. https://www.ethernodes.org/. Accessed Jan-

uary, 2022.

[38] Adem Efe Gencer, Soumya Basu, Ittay Eyal, Robbert
Van Renesse, and Emin G¨un Sirer. Decentralization in
In International Con-
bitcoin and ethereum networks.
ference on Financial Cryptography and Data Security,
pages 439–457. Springer, 2018.

[39] Charles Anderson. Docker [software engineering]. Ieee

Software, 32(3):102–c3, 2015.

[40] Joachim Zahnentferner. Chimeric ledgers: Translating
and unifying utxo-based and account-based cryptocurren-
cies. Cryptology ePrint Archive, 2018.

[41] Sergei Tikhomirov. Ethereum: state of knowledge and
In International Symposium on
research perspectives.
Foundations and Practice of Security, pages 206–221.
Springer, 2017.

[42] Gavin Wood et al. Ethereum: A secure decentralised
generalised transaction ledger. Ethereum project yellow
paper, 151(2014):1–32, 2014.

Vogelsteller
standard.

Buterin.
Vitalik
[43] Fabian
[Online].Available:
Token
https://github.com/ethereum/EIPs/blob/master/EIPS/eip-
20.md/, 2015.

and

Information and Communication Technology, Electronics
and Microelectronics (MIPRO), pages 1545–1550. IEEE,
2018.

[18] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The
bitcoin backbone protocol: Analysis and applications.
In Annual international conference on the theory and
applications of cryptographic techniques, pages 281–
310. Springer, 2015.

[19] Peifang Ni, Hongda Li, and Dongxue Pan. Analysis of
bitcoin backbone protocol in the non-ﬂat model. Science
China Information Sciences, 63(3):1–14, 2020.

[20] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate
transaction processing in bitcoin. In International Con-
ference on Financial Cryptography and Data Security,
pages 507–527. Springer, 2015.

[21] Vivek Bagaria, Sreeram Kannan, David Tse, Giulia
Fanti, and Pramod Viswanath.
Deconstructing the
blockchain to approach physical limits. arXiv preprint
arXiv:1810.08092, 2018.

[22] Chenxin Li, Peilun Li, Dong Zhou, Zhe Yang, Ming Wu,
Guang Yang, Wei Xu, Fan Long, and Andrew Chi-Chih
Yao. A decentralized blockchain with high throughput
and fast conﬁrmation. In 2020 {USENIX} Annual Tech-
nical Conference ({USENIX}{ATC} 20), pages 515–528,
2020.

[23] Pos

in

ethereum.

[Online].Available:

https://github.com/ethereum/wiki/wiki/ShardingFAQs.
[24] Wenbing Zhao, Shunkun Yang, and Xiong Luo. On
consensus in public blockchains. In Proceedings of the
2019 International Conference on Blockchain Technol-
ogy, pages 1–5, 2019.

[25] Miguel Castro and Barbara Liskov. Practical byzantine
fault tolerance and proactive recovery. ACM Transactions
on Computer Systems (TOCS), 20(4):398–461, 2002.
[26] Oleg Andreev. Proof that proof-of-work is the only
solution to the byzantine generals’ problem, 2014. URL:
https://nakamotoinstitute. org/mempool/proof-that-proof-
of-work-is-the-only-solution-to-the-byzantinegenerals-
problem/(visited on 2017-07-09).

[27] Paul Sztorc. Nothing is cheaper than proof of work.
[Online].Available: http://www.truthcoin.info/blog/pow-
cheapest/, 2015.

[28] Till Neudecker and Hannes Hartenstein. Network layer
aspects of permissionless blockchains. IEEE Communi-
cations Surveys & Tutorials, 21(1):838–857, 2018.
[29] Lihao Zhang, Taotao Wang, and Soung Chang Liew.
Speeding up block propagation in blockchain network:
Uncoded and coded designs. Computer Networks, doi:
https://doi.org/10.1016/j.comnet.2022.108791, 2021.

[30] Christian Decker and Roger Wattenhofer.

Information
propagation in the bitcoin network. In IEEE P2P 2013
Proceedings, pages 1–10. IEEE, 2013.

[31] Nakul Chawla, Hans Walter Behrens, Darren Tapp, Dra-
gan Boscovic, and K Selc¸uk Candan. Velocity: Scalabil-
ity improvements in block propagation through rateless
erasure coding. In 2019 IEEE International Conference
on Blockchain and Cryptocurrency (ICBC), pages 447–
454. IEEE, 2019.

