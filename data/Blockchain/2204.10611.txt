Bridging Sapling: Private Cross-Chain Transfers

Aleixo Sanchez∗†
aleixo@web3.foundation

Alistair Stewart†
stewart.al@gmail.com

Fatemeh Shirazi‡
fatemeh@heliax.dev

∗ETH Z¨urich
Z¨urich, Switzerland

†Web3 Foundation
Zug, Switzerland

‡Heliax
Zug, Switzerland

2
2
0
2

r
p
A
2
2

]

R
C
.
s
c
[

1
v
1
1
6
0
1
.
4
0
2
2
:
v
i
X
r
a

Abstract—Interoperability is one of the main challenges of
blockchain technologies, which are generally designed as self-
contained systems. Interoperability schemes for privacy-focused
blockchains are particularly hard to design: they must integrate
with the unique privacy features of the underlying blockchain
so as to prove statements about speciﬁc transactions in protocols
designed to obfuscate them. This has led to users being forced
to weaken their privacy, e.g. by using centralised exchanges, to
move assets from one chain to another. We present ZCLAIM,
a framework for trustless cross-chain asset migration based on
the Zcash privacy-protecting protocol. ZCLAIM integrates with
an implementation of the Sapling version of Zcash on a smart-
contract capable issuing chain in order to attain private cross-
chain transfers. We show that a tokenised representation can be
created via a set of collateralised intermediaries without relying
on or revealing the total amount to any third party.

Index Terms—Privacy, Cross-Chain, Interoperability, Non-

interactive Zero-Knowledge Proof, Blockchain

I. INTRODUCTION

Since the creation of Bitcoin in 2009, thousands of crypto-
currencies and blockchains with a wide array of applications
have emerged. This fragmentation of the blockchain space has
created a market for interoperability solutions [1], [2], which
we loosely deﬁne here as the ability to verify a transaction
in a network other than the one in which it was created.
Unfortunately, the vast majority of blockchains are siloed,
not having been designed with interoperability in mind. This
results in signiﬁcant complexity required to design cross-chain
protocols; hence, this challenge has until recently mostly been
circumvented through the use of centralised exchanges. These
require trust and undermine anonymity, which is particularly
undesirable in the case of privacy-oriented cryptocurrencies
designed around the notion of payment anonymity. Despite a
mounting interest in recent years in the deployment of privacy
features in blockchain protocols, in particular of various zero-
knowledge proof primitives [3], little attention has been given
to maintaining the privacy achieved in this manner across
chains. That means users must reveal, or at least risk revealing,
their identity if they wish to move assets from one privacy-
preserving system to another. This acts as a major limitation
in the usability of these systems, as one can only durably
rely on the privacy guarantees of a given system by remaining
conﬁned to it.

To address this, in this work we introduce ZCLAIM1, a
protocol enabling private transactions across chains. This is
to the authors’ knowledge the ﬁrst scheme that succeeds
in maintaining privacy in cross-chain transfers. Our protocol
follows the structure of XCLAIM [5], a framework achieving
collateralised trustless asset migration by leveraging smart
contract logic, a dynamic set of economically incentivised,
trustless intermediaries and cross-chain state veriﬁcation. This
approach to interoperability falls under what is colloquially
referred to as the “wrapping” of assets.

ZCLAIM builds upon said framework by integrating with the
Zcash [6] protocol in such a way as to maintain anonymity. On
the chain on which the wrapped assets are issued, the issuing
chain, we assume an implementation of Sapling according to
its speciﬁcation [6] and introduce new transfer types, with
accompanying zk-SNARKs [7], to facilitate interoperability.
These transfers integrate with Zcash’s private or shielded
payment scheme and enable the issuing and redeeming of
value. Furthermore, we discuss the custom logic necessary
the issue and redeem protocols, and present
to carry out
and analyse a strategy to hide the transferred amount from
intermediaries.

The end result is a protocol enabling trustless cross-chain
transfers with similar privacy guarantees to those of Zcash
itself, which is considered to provide some of the strongest in
blockchain [3], [8].

The remainder of the paper is organized as follows. Sec-
tion II studies related work and provides a brief summary
of concepts in the Zcash protocol. Section III introduces a
high-level description of the ZCLAIM protocol. Section IV
discusses risks and attacks, and Section V presents and ana-
lyses an approach to maintain privacy against intermediaries.
Section VI considers current limitations and future work and,
ﬁnally, Section VII concludes the paper.

II. BACKGROUND

A. Related Work

Atomic swaps [9], the traditional approach to decentralised
cross-chain exchanges, allow users on two blockchains to swap
ownership of a pre-agreed amount of assets, guaranteeing that

1The ZCLAIM protocol is the contribution of a master’s thesis submitted
to ETH Z¨urich in collaboration with Web3 Foundation [4]. The thesis is
accessible under https://github.com/alxs/zclaim and contains a more
exhaustive and technical speciﬁcation of the protocol.

 
 
 
 
 
 
the exchange either happens in full or not at all. Atomic swaps
present limitations such as 1) requiring the establishing of
an external communication channel to ﬁnd and agree on a
swap, 2) an asymmetrical advantage for one out of the two
participants (“free option problem” [10]), and 3) relatively
long conﬁrmation delays. There are ongoing efforts to im-
plement atomic swaps between the privacy coin Monero [11]
and Bitcoin [12], [13] as well as Ethereum [14].

An alternative approach are asset migration protocols [15]
such as the one presented in this paper, in which a represent-
ation of an asset (its tokenised representation or “wrapped”
version) is created on a different chain, while those on the
original chain are locked until the process is reversed.

At least two different projects—Wrapped [16], a “provider
of wrapped layer-1 assets”, and the Ren Project, a generic
cross-chain transfer protocol [17]—offer tokenised repres-
entations of Zcash on Ethereum [18]. However, the former
relies on a centralised authority and neither of them supports
Zcash’s shielded payment scheme. The Zcash Foundation
announced [19] their intent to work on a “Zcash pegzone” [20]
for the Cosmos [21] ecosystem in 2020, with the goal of
enabling “shielded transfers from the pegzone to Zcash and
vice versa”; however, details on the project are scarce.

B. Zcash and Sapling

We now introduce basic concepts from Zcash used in this
work. For a formal deﬁnition of these concepts and the
cryptographic schemes employed in them, we refer the reader
to the Sapling version of the Zcash protocol speciﬁcation [6].
Some terms have been simpliﬁed for ease of understanding.

Zcash is an implementation of the Zerocash [22], [23]
payment scheme. It builds on Bitcoin’s [24] transparent pay-
ment scheme, adding a private payment scheme leveraging
zk-SNARKs [7] to enable private payments. This work only
concerns itself with the latter.

Transactions in Sapling can contain transparent

inputs,
outputs, and scripts, all of which work as in Bitcoin [24],
and shielded JoinSplit2, Spend and Output transfers. Spend
and Output transfers are analogous to transparent inputs and
outputs, respectively. Each Spend transfer spends a note, and
each Output transfer creates one. A note represents that a value
v is spendable by the recipient who holds the private key
to the destination shielded payment address. A note’s sender,
recipient and value are never revealed.

All Spend and Output transfers in a transaction, along with
any transparent inputs and outputs, are checked to balance by
verifying that the sum of all value commitments and of all
transparent values is equal to zero.

To each note there is a cryptographically associated note
commitment, which is added to the note commitment tree when
the note is created. Only notes whose note commitment is
in the note commitment tree can be spent. When the note is
spent, a nulliﬁer uniquely associated with that note must be

2We ignore JoinSplit transfers, which Sapling only supports for backwards

compatibility.

revealed and is then added to the nulliﬁer set. It is infeasible to
compute the nulliﬁer without the spending key corresponding
to the recipient’s shielded payment address, and only notes
whose nulliﬁer is not in the nulliﬁer set can be spent.

The main premise of Zcash’s shielded payment scheme is
that when a note is spent, the spender only proves that its
note commitment is in the note commitment tree. Revealing
its nulliﬁer also does not reveal which note commitment it
is associated with, which means that a spent note cannot be
linked to the transaction in which it was created.

The values required to spend a note are generally encrypted
to its recipient when it is created, though the protocol does not
enforce it. This has been a challenge in designing ZCLAIM,
since it is not enough to verify that a note exists in the note
commitment tree in order to verify a transaction. Instead, we
must also ensure that the counterparty receives these values.

III. ZCLAIM PROTOCOL
We introduce ZCLAIM, an adaptation of XCLAIM to Zcash
so as to facilitate private transfers to any blockchain that
supports custom logic and efﬁcient veriﬁcation of the required
cryptographic functions [4, Section 5.2].

We deﬁne the following terms:
• ZEC denotes the Zcash cryptocurrency.
• wZEC denotes wrapped ZEC, the tokenised representa-

tion of ZEC on the issuing chain.

• I is the issuing chain, on which wZEC will be created.
• i is an implementation-deﬁned existing currency on I.

A. Actors

The following actors participate in the protocol:
• Issuers lock ZEC on Zcash to request an equivalent

amount of wZEC on I.

• Redeemers destroy wZEC on I to request the corres-

ponding amount of ZEC on Zcash.

• Vaults are the non-trusted intermediaries that act as
custodians, safekeeping locked ZEC. Anyone can take
on the role of a vault by locking some collateral in i and
registering as such. Vaults are liable for fulﬁlling redeem
requests of wZEC for ZEC. They are incentivised by fees
they derive from transactions and in case of misbehaviour,
they face partial or total liquidation of their collateral.

B. Components

The functionality that ZCLAIM requires on the issuing chain

can be split into the following components.

1) Vault registry: The vault registry keeps a public list of
all registered vaults and their status. Each vault has a Zcash
shielded payment address (d, pkd) and an amount of collateral
associated with it. The collateral it keeps in i on the issuing
chain and thus the total amount of ZEC it is able to accept
are public; however, the amount of ZEC obligations to its
name, i.e. ZEC it participated in issuing and is accountable
for releasing, is not. It periodically proves that this amount
is properly backed by its collateral by submitting proofs of
balance, which consist of a zk-SNARK accounting for all
previous requests it has served.

2) Relay system: The relay system [25] keeps track of the
state of the Zcash chain. Speciﬁcally, it veriﬁes and stores
block headers, provides a mechanism to signal that consensus
has been reached on a given block similarly to an SPV or
light client [26], [27], and allows the veriﬁcation of Zcash
notes. Reaching consensus, in this context, requires fulﬁlling
implementation-speciﬁc criteria w.r.t. Zcash’s probabilistic ﬁ-
nality; a possible approach is discussed in Section IV-B. In
order to prove the existence of a note, users must provide an
inclusion proof, which consists of a Merkle path from its note
commitment to the root of the note commitment tree in the
block header of a previous block. On the other hand, the relay
system does not need to offer functionality to verify whether
a nulliﬁer already exists in the nulliﬁer set.

Block headers are submitted to the relay system by relayers,
which may or may not be economically incentivised. Other
protocol actors are likely to take on the additional role of
relayers if the cost associated with doing so is low and it is in
their interest to guarantee the stability of the protocol. Vaults,
for example, are in such a position: they need to run full nodes
of both chains, and the ﬁnancial damage they may incur from
an attack on the relay system as discussed in Section IV-B is
far greater than the cost of submitting headers.

3) Exchange rate oracle: The exchange rate oracle Oxr
provides an exchange rate that reﬂects the prevailing market
value of 1 ZEC in i. The design of the exchange rate oracle
falls outside the scope of this work, but a brief discussion on
exchange rate sourcing and security concerns can be found in
Section IV-C.

4) Protocol logic: The logic and state pertaining to the
issue and redeem protocols may but need not be contained
in a set of smart contracts. Alternative approaches to user-
deﬁned on-chain logic may allow these to be stored e.g. in
the runtime [28] or as precompiled modules [29].

C. Transfers and transactions

Along with Sapling’s Spend and Output transfers, the issu-
ing chain supports Mint and Burn transfers. A Mint transfer is
a transfer creating value of the issued currency, i.e. increasing
the circulating supply. A Burn transfer takes the burnt amount
out of circulation. Transactions in the issuing chain may con-
sist of any of the same components as a Sapling transaction,
and either a Mint or a Burn transfer. A transaction containing
a Mint transfer is a mint transaction, and one containing a
Burn transfer a burn transaction. Mint transfers contain a zk-
SNARK proving that a note has been sent to a vault on Zcash
and that the minted value corresponds to the locked value. In
Burn transfers, redeemers create a note they wish to receive
on Zcash and encrypt it to the vault, while publishing its
note commitment. The zk-SNARK in Burn transfers allows
redeemers to show that the value of said note matches the
burnt value. The transaction is only conﬁrmed once the vault
provides an inclusion proof for this note. We refer the reader
to the original speciﬁcation of this protocol [4, Section 5] for
concrete deﬁnitions of the aforementioned transfers and of zk-
SNARKs mentioned in this work.

D. Issuing and Redeeming

We deﬁne two sub-protocols, Issue and Redeem, adapted
from XCLAIM to address the challenges arising from integrat-
ing Zcash’s anonymity features.

The Issue sub-protocol allows issuers to lock ZEC with
vaults and mint wZEC on the issuing chain. In order to conceal
the transferred amount from the vaults, the issuer splits the
total into separate amounts beforehand and sends them to
n vaults such that no vault is able to deduce the total. We
present and analyse a possible splitting strategy to this end in
Section V-B. For each of these amounts, the issuer carries
out an Issue procedure, i.e. an instance of the Issue sub-
protocol. In short, the issuer proves that they have created
a note encrypted to a vault’s address and mints an equivalent
amount of wZEC in a mint transaction. The existence of this
note does not guarantee that it can be spent by the vault, hence
there is a challenge period during which vaults can void the
transaction by proving that the necessary values have not been
properly encrypted to them.

The Redeem sub-protocol allows a redeemer to receive ZEC
from vaults in exchange for burning wZEC on the issuing
chain. Redeemers shall employ the same splitting strategy as
issuers. For each individual amount, a redeemer submits a burn
transaction on the issuing chain which contains a commitment
to a note of equivalent value spendable by an address under
their control on Zcash. A vault then creates this note. Since the
vault must also learn the values from which the note is derived
in order to create it, there is a challenge period during which
it can challenge the request by showing that these were not
properly encrypted. If the values are correct, the vault must
create the note speciﬁed by the redeemer. Lastly, the vault
submits a proof showing that the note exists and the burn
transaction is ﬁnalised.

We present an overview of both sub-protocols. Diagrams

depicting these steps are shown in Fig. 1.

Issuing: Alice (issuer) locks funds with vault V on Zcash

to create units of wZEC on I.

0) Setup. V registers with the vault registry on I and locks

icol units of collateral, where it must hold that

icol ≥ vmax · (1 − f ) · σstd · xrcap

(III.1)

where vmax is the maximum amount of funds that can be
locked or burned per request, f is the ZCLAIM transaction
fee, and σstd is the standard collateralisation rate. These
values are implementation-deﬁned constants. xrcap is the
exchange rate at the time the vault provides a proof
of capacity as explained next. Further, V must provide
a shielded payment address on Zcash to which issuers
will send their funds and submit a proof of capacity to
the vault registry, which is a zk-SNARK proving that
Eq. (III.1) holds. V must periodically resubmit proofs of
capacity in order to remain available for requests.

1) Commit. Alice makes a request

to the issuing chain
to lock her funds with vault V with shielded payment
address (d, pkd)V. As part of this request, Alice locks

a shielded address on I. To this end, Alice provides an
inclusion proof for a note with note commitment cmn,
and further proves in zero knowledge that:
• she knows a note n with note commitment cmn,

recipient (d, pkd)V and value ZEClock

• wZECcreate = ZEClock(1 − f ), where f is the ﬁxed

fee rate the vault earns, and ZEClock ≤ vmax

issuing wZECcreate

• the trapdoor rcm was derived from nlock
The transaction Tmint
remains
pending until V conﬁrms it. If V fails to do so within
some ∆conﬁrmIssue , the same iw is deducted from V’s
collateral and transferred to Alice, and Tmint
is con-
ﬁrmed. This delay may be quite small, as it only needs
to allow for V to see and respond to Tmint on I.
Furthermore, Alice publishes a note ciphertext C V of the
note n symmetrically encrypted to V.

5) Conﬁrm/Challenge. V decrypts C V and veriﬁes whether
the resulting note has note commitment cmn. If that is
the case, V conﬁrms and the issuing process is complete.
On the other hand, if V ﬁnds that it cannot properly
decrypt C V, it may challenge the transaction by revealing
the shared secret used in the encryption while proving its
correctness in a zk-SNARK. It can then be veriﬁed on
chain that the encryption was erroneous, in which case
Tmint is discarded and Alice loses ZEClock and iw.
Redeeming: Dave (redeemer) burns wZEC on I and obtains

ZEC from vault V.

0) Setup. V is available to redeem, i.e. has not provided
a proof of insolvency to the vault registry since it last
participated in an Issue procedure. Vaults are available
for redeem requests by default. In order to be exempted
they need to periodically provide proofs
from them,
of insolvency, showing that their ZEC obligations are
smaller than vmax. This simpliﬁed requirement ensures
users will always be able to redeem the existing supply.
1) Burn. Dave makes a request to burn funds wZECburn
on I by locking iw as warranty collateral and submitting
a transaction Tburn .

2) Redeem request. In this transaction, Dave speciﬁes that he
would like to redeem ZEC from V in a note n with note
commitment cmn, and proves in zero knowledge that:
• he knows a note n with note commitment cmn and

value ZECrelease

• ZECrelease = wZECburn(1−f ), where f is the ﬁxed
fee rate that the vault earns, and wZECburn ≤ vmax
In redeem requests, vaults earn fees implicitly through
their ZEC obligations decreasing by a larger amount than
the ZEC amount they release.
In order to transmit the note values to V, Dave publishes
the note ciphertext C V of the note n encrypted to V.
Tburn is not conﬁrmed until V conﬁrms the release
of ZECrelease. If V fails to do so or to challenge it
within some ∆conﬁrmRedeem , iw is deducted from V’s
collateral and transferred to Dave, and Tburn is discarded.
∆conﬁrmRedeem , like ∆mint , will largely depend on how

(a) Issue

(b) Redeem

Figure 1. Simpliﬁed diagrams of ZCLAIM protocols.

a small amount of i, iw, her warranty collateral. This
is a ﬁxed amount large enough to compensate V for the
opportunity cost in case Alice does not follow through
with her request. Furthermore, it serves to prevent grief-
ing attacks in which the system is spammed with lock
requests, becoming unavailable to legitimate users.
2) Lock permit. Subsequently, a lock permit is created on
I, granting permission to Alice to lock her funds with
V. This permit contains a cryptographic nonce nlock that
Alice must include in the transaction locking the funds.
If she fails to execute step 4 within some ∆mint , her
warranty collateral iw is transferred to V. The constant
∆mint will largely depend on how fast the relay system
considers blocks to have reached consensus. As a point
of reference, popular cryptocurrency exchanges require a
depth of 24 blocks or 30 minutes [30], [31].

3) Lock. Alice creates a shielded transaction on Zcash,
sending ZEClock to V. Alice uses nlock to derive the
randomness rcm,
trapdoor,
used to generate the commitment for the output note n
addressed to V in this transaction.

the so-called commitment

4) Create. Alice makes a request to issue wZECcreate to

fast the relay system accepts blocks.

Operations performed by vaults:

3) Release. V releases ZECrelease to Dave by creating a

note n with note commitment cmn.

4) Conﬁrm/Challenge. V waits until the relay system signals
that consensus has been reached on the block in which n
was created and then submits an inclusion proof for this
note. Tburn is then conﬁrmed.
However, if upon decryption of C V V ﬁnds that the
resulting plaintext does not correspond to a note with
note commitment cmn, it may challenge the transaction
as in step 5 of the Issue protocol, in which case Tburn is
voided and Dave’s warranty collateral is transferred to V.
In this case, V does not execute step 3.

E. Operations

We now deﬁne abstract operations for the two protocols

introduced in the previous section.

An operation always results in a transaction. On I, this
may either be a monetary transfer or a change in state. Each
operation leads to a speciﬁc state of the protocol, and to each
state there is an implicitly associated set of legal operations
for each party.

We denote by T A

op the transaction on blockchain A resulting
from the successful execution of operation op. A may be either
Zcash, denoted by Z, or the issuing chain, denoted by I.
Certain transactions on I require conﬁrmation from the other
party involved in the Issue or Redeem procedure and may be
voided if this conﬁrmation is not provided within a certain
delay. We denote a transaction that is pending conﬁrmation as
(T I

op), and one that is voided as (cid:8)(cid:8)(cid:8)
(T I
op).
An operation that results in transaction Top, can be per-
formed in state StartingState and leads to state OutputState
is denoted by op → T A
op [StartingState → OutputState].
For simplicity, we omit non-monetary and warranty collateral
transactions as well as slashing, all of which take place only
on I. All operations can only be performed by a speciﬁc actor.

Operations performed by issuers:
• requestLock [IssueStart → AwaitingMint] requests per-
mission to lock funds with a vault. The issuer locks iw
as collateral.
• lock → T Z

lock [AwaitingMint → AwaitingMint] locks

ZEC with a vault.

• mint → (T I

mint ) [AwaitingMint → AwaitIssueConﬁrm]
allows the issuer to mint a hidden amount of wZEC on
I upon conﬁrmation.
If
the vault
∆conﬁrmIssue , T I
is deducted from the vault’s collateral.

to perform conﬁrmIssue within
fails
mint is automatically conﬁrmed and iw

Operations performed by redeemers:
• burn → (T I

burn ) [RedeemStart → AwaitRedeemConﬁrm]
requests a speciﬁc vault to release ZEC and burns an
equivalent amount of wZEC upon conﬁrmation. The
redeemer locks iw as collateral.
If the vault fails to perform conﬁrmRedeem within
∆conﬁrmRedeem , T I
burn is voided and iw is deducted from
the vault’s collateral.

• challengeIssue [AwaitIssueConﬁrm → IssueChallenged]
lock has not been correctly

allows a vault to prove that T Z
encrypted to it in (T I

mint ).

• challengeRedeem

RedeemChallenged]
allows
to prove
release has not been correctly encrypted to it in (T I
T Z

a vault

[AwaitRedeemConﬁrm

→
that
burn ).
[AwaitRedeemConﬁrm →

• release → T Z

release

AwaitRedeemConﬁrm] releases funds to a redeemer.
• conﬁrmIssue [AwaitIssueConﬁrm → IssueSuccess] al-
lock , con-

lows a vault to conﬁrm that it has received T Z
ﬁrming the pending (T I

• conﬁrmRedeem

release , conﬁrming the pending (T I

→
the vault has released
burn )

RedeemSuccess] proves that
funds
transaction.

in T Z

mint ) transaction.
[AwaitRedeemConﬁrm

• submitPOB [VaultRegistered|IssueStart|NotIssuing →
NotIssuing] submits a proof of balance. Vaults may
perform this operation in order to prevent liquidation
instead of submitPOC if they don’t wish to become
available for new lock requests.

• submitPOC [VaultRegistered|IssueStart|NotIssuing →

IssueStart] submits a proof of capacity.

• submitPOI

[NotRedeeming|RedeemStart
NotRedeeming] submits a proof of insolvency.

→

Based on these operations, the Issue and Redeem protocols
are summarised in pseudocode in Algorithms 1 and 2, respect-
ively.

Algorithm 1 Issue

Require: VAULT has enough collateral
1: VAULT executes submitPOC
2: if ISSUER executes requestLock and receives a lock permit then
3:
lock
4:
5:

ISSUER executes lock →T Z
if ISSUER executes mint →(T I

if VAULT executes challengeIssue within ∆conﬁrmIssue
then

mint ) within ∆mint then

T I
→ (cid:8)

(cid:8)(cid:8)
mint

else

6:
7:
8:

VAULT may execute conﬁrmIssue within ∆conﬁrmIssue

→ T I

mint

9:
10:
11:
12: end if

end if

end if

burn )

Algorithm 2 Redeem
Require: VAULT has not called submitPOI since last issuing
1: REDEEMER executes burn→(T I
2: if VAULT executes challengeRedeem within ∆conﬁrmRedeem
3: → (cid:8)(cid:8)(cid:8)
4: else
5:
6:

VAULT executes release→T Z
release
if VAULT executes conﬁrmRedeem within ∆conﬁrmRedeem
then

then

T I

burn

burn

→ T I
→ (cid:8)(cid:8)(cid:8)
T I

burn

else

7:
8:
9:
10:
11: end if

end if

IV. ATTACK VECTORS AND POINTS OF FAILURE

We discuss here a range of attacks and points of failure in
ZCLAIM and offer mitigation strategies. Where not speciﬁed
otherwise, the discussion on vulnerabilities presented in the
security analysis of XCLAIM [5, Section VII] also holds here.

A. Inference attacks

Without a robust splitting strategy, vaults may guess the
users’ identity through the amounts in lock and release trans-
actions in which they are involved.

In the simplest scenario, if a user locks an amount with
a vault which matches a recent transparent-to-shielded trans-
action, the vault may deduce the origin of the funds [32]
and infer the user’s identity from activity associated with the
transparent address.

The same attack is possible if a vault is able to deduce or
estimate the total from one or a small subset of the amounts
sent to it. The splitting strategy deﬁned in Section V-B aims
to prevent this sort of attack. The privacy provided by this
strategy is analysed in the remainder of said section.

Bitcoin-based blockchains (such as Zcash is) for mitigation
strategies [34], [37].

C. Exchange rate poisoning

If the exchange rate oracle is manipulated to provide
an erroneous price feed, the protocol may fail to maintain
proper collateralisation of the issued assets. An artiﬁcially
high exchange rate would allow vaults to issue ZEC or unlock
collateral such that they become undercollateralised after the
attack. On the other hand, an artiﬁcially low exchange rate
may trigger mass liquidation and allow users to buy vaults’
collateral at an unfair price.
is thus important

to guarantee the reliability of the
exchange rate oracle. Blockchain oracles aim to solve this
exact problem [38], [39], aggregating exchange rates from
different sources, leveraging economic incentives to reinforce
their veracity and providing dispute mechanisms in case of
discrepancies. These systems are, without question, safer than
relying on a single source to provide an exchange rate, though
they may still fail under certain circumstances [40].

It

B. Chain relay poisoning

D. Replay attacks on inclusion proofs

Chain relay poisoning involves an adversary triggering a
chain reorganisation such that a previously accepted transac-
tion is invalidated; in other words, bypassing the relay system’s
consensus validation mechanism.

Since Zcash has probabilistic ﬁnality,

this is in theory
always possible. However, a common practice consists in
deeming only blocks at depth h ≥ k to have reached con-
sensus, where k is a security parameter denoting the block
depth at which the likelihood of an adversary with computa-
tional power bounded by α ≤ 33% [33] triggering a chain
reorganisation becomes negligible. This threshold is usually
a low number due to the probability of a successful attack
decreasing exponentially with increasing depth. Nevertheless,
it must be noted that the dangerous assumption here is not the
threshold k but α. The costs required to reach this threshold
vary wildly for different cryptocurrencies and a more in-depth
exploration of the feasibility of such an attack on Zcash
is recommended in order to ﬁnd sensible values for these
parameters.

Furthermore, a poisoning attack may be successful well
below this threshold α if the relay system is deprived of
recent block header data [5, Section VII-A]. This is a common
vulnerability to interoperability schemes and may involve
intricate attacks in which relayers are isolated from the rest of
their peers in the network and misled to accept the attacker’s
chain as the longest, in what is commonly known as an eclipse
attack [34]. Note that as long as there is one honest relayer
connected to the rest of the network, the cost of attacking the
relay system is the same as that of running a 51% attack, since
block headers are veriﬁed based on proof of work and not on
the number of relayers submitting them.

Such attacks along with mitigation strategies have been
discussed previously in the literature [34], [35], [36], [37], and
we refer the reader in particular to analyses on Bitcoin and

ZCLAIM prevents replay attacks on lock and release trans-
action inclusion proofs, in which a user reuses a past lock
transaction to mint wZEC or a vault reuses a release transac-
tion to decrease their ZEC obligations, as follows.

The nonce npermit generated in lock permits must be used to
generate the note commitment trapdoor in lock transactions,
which is enforced in the zero knowledge proof in Mint
transfers. This ensures that every lock transaction is uniquely
associated with the corresponding Issue procedure. As for
release transactions, protection from replay attacks is implicit
since the note commitment is generated in advance by the
redeemer. A vault can only replay a release inclusion proof if
the redeemer purposefully chooses the same note values, most
notably the same note commitment trapdoor as in a previous
Burn transfer.

E. Counterfeiting

We deﬁne counterfeiting as the issuing of wZEC which
is not backed by an equivalent amount of collateral. As
previously outlined, vaults must periodically provide proofs of
balance showing that their ZEC obligations are collateralised
above a certain ratio. If a vault fails to do so and the exchange
rate changes by a certain margin since their last statement,
partial liquidation of their collateral is triggered. This ensures
the collateralisation ratio never falls below a certain minimum.
Furthermore, proofs of capacity ensure that such a statement
will hold after a mint. See [4, Section 5.12] for more details
on balance statements.

Note that wZEC does not need to be fully backed by ZEC,
which is impossible to guarantee while maintaining the vaults’
transaction history private. A vault may very well reuse ZEC
it has received to issue more wZEC; but it will remain unable
to unlock its collateral until it has released ZEC to redeemers
or acquired and burnt wZEC itself.

F. Sudden devaluation

Given the historically high volatility in cryptocurrency mar-
kets [41], [42], the risk of sudden, extreme devaluation of
either one of Zcash or the issuing currency w.r.t. the other is
non-negligible. In case of a drop in the valuation of Zcash,
ZCLAIM would continue to operate normally. In the opposite
case, the consequences would be similar to those discussed
in Section IV-C and ZCLAIM would eventually no longer
function. The strategy proposed in XCLAIM [5, p. 3] can be
employed to mitigate the risk.

V. SPLITTING STRATEGY AND ANALYSIS OF INFERENCE
ATTACKS

In this section, we demonstrate that vaults cannot infer the
total value prior to splitting. We consider a simple threat model
that describes what a single vault can infer from each quantity
received. We assume the user has an amount vtot to transfer
which is split among k vaults, where k is a low power of
two. If any vault receives an amount v, the vault knows that
vtot ≥ v. If the user transfers an amount vtot, then at least one
vault will receive vtot/k and so they can infer that the total
amount must be at least vtot/k. This means that at the very
high values of vtot, anonymity suffers.

We remark here that transaction fees on Zcash are generally
very low3, hence requiring a total of up to e.g. k = 16
transactions per transfer is a realistic solution. Nevertheless,
this also needs to be the case on the issuing chain.

A. A scale-independent prior

The amount received by each vault is used to assign a
probability to the total amount using Bayesian inference. This
relies on a prior distribution on the total amount a user
might wish to transfer. This amount may span many orders
of magnitude, but the scale must be kept private. We assume
that the total amount is an integer in the range [1, 2h − 1]. The
prior distribution is then sampled as T = 2N + A, where N is
chosen uniformly from the integers in [0, h], and A is chosen
uniformly from the integers in [0, 2N − 1].

B. Proposed splitting protocol

In our splitting protocol, each user splits their total amount
vtot into k pieces. We restrict the size of each piece to 0 or
powers of two. To attribute piece sizes, an obvious protocol
is to use the powers of two that correspond to the highest
1 bits in the binary representation of the total amount vtot.
However, this would give away information about the total,
since each piece would eliminate half the possible values. We
get around this only using pieces of sizes from 0 to 2m, where
m = h + 1 − log2 k. If vtot is large, many pieces must be of
size 2m, which unfortunately means there are less pieces to
use on bits.

If the total amount t to split is in [1, 2m−1] then the splitting

procedure is as follows:

3The default is 0.00001 ZEC [43], worth around 0.00176 USD at the time

of writing.

• Let e = max{1, 2(cid:98)log2 vtot(cid:99)+1−k/2}.
an integer
• Choose

i uniformly at

random from

[0, e(cid:98)vtot/e(cid:99)].

• When e > 1, do not transfer vtot − e(cid:98)vtot/e(cid:99) tokens.
• Split

into ei and
e((cid:98)vtot/e(cid:99) − i), then split each of those into powers of 2.

the remaining e(cid:98)vtot/e(cid:99) tokens

• If this gives less than k pieces, then pad with 0.
If the amount vtot is in [2m+1, 2h − 1], then the splitting

procedure is as follows:

• Let d = (cid:98)vtot/2m(cid:99) − 1, c = (cid:98)(k − d)/2(cid:99) and e = 2m−c.
• Split the total amount into d pieces of size 2m.
• Do not transfer vtot − e(cid:98)vtot/e(cid:99) tokens.
i uniformly at
• Choose

random from
[0, (cid:98)vtot/e(cid:99) − d2m/e] and split the remaining e(cid:98)vtot/e(cid:99) −
d2m tokens ﬁrstly into ie and e(cid:98)vtot/e(cid:99) − d2m − ie.
• Split these into powers of two and pad with 0s to form

an integer

k pieces.

Note that this never gives the user more than k pieces.

C. Forward probabilities

Assuming the user has a total of vtot

tokens, we now
consider the probability that a vault chosen at random from the
k vaults has a piece size of 2j, for some 0 ≤ j ≤ m. We write
X0, X1, . . . , Xm+1 to denote random variables indicating the
number of pieces of size 0, 1, . . . , 2m respectively. We write
T for the random variable of the total amount. The probability
that a randomly-chosen vault has a piece size of 2j−1 for some
1 ≤ j ≤ m + 1, given that the user had vtot in total, is then
E[Xj|T = vtot]/k.

Lemma V.1 If i is selected uniformly at random from the
integers in [0, 2c + a] for some integer 0 ≤ a < 2c, and
Yj denotes the jth bit of i, then:

i, E[(cid:80)

(i) For 0 ≤ j ≤ c, 1/4 ≤ Pr[Yj = 1] ≤ 3/4.
(ii) Pr[Yc+1 = 1] ≤ 1/2.
(iii) The expected number of 1s in the binary expansion of
j Yj], is between c/4 and (3c + 2)/4.
The lemma follows from the fact that selecting i from
[0, 2c −1] means that each bit would be 1 with probability 1/2,
and selecting i from [0, 2c + a] means that i is in [0, 2c − 1]
with probability over 1/2.

It follows easily from the deﬁnition of the protocol and

Lemma V.1 that:

Lemma V.2

(i) For 1 ≤ j ≤ m − k/2, E[Xj|T = vtot] ≤ 3/2
(ii) E[Xm|T = vtot] ≤ (cid:98)t/2m(cid:99)
(iii) E[X0|T = vtot] ≤ k
The following lemma requires analysing a great many cases,

for which there is no space here.

Lemma V.3

(i) For 1 ≤ j ≤ m − k/2, E[Xj] ≥ k/4h
(ii) m − k/2 < j < m + 1, E[Xj] ≥ max{m+1−j,log2 k}
(iii) E[Xm+1] ≥ 3(k − 2 log2 k)/4h
(iv) E[X0] ≥ k/8

2h

D. Inference step

We now assume that a vault has received an amount v,
an instance of a random variable V , and consider what
information we gain about T . It is evident that t ≥ v, so
many values of t can be ruled out. Nonetheless, here we show
that the probability of any particular value of t greater than
v is not substantially larger than the probability given by the
prior.

Theorem V.4 For any j, t with P r[T = t|V = 2j+1] > 0 and
either 1 ≤ j < m + 1 or t < 2m+1, we have:

Pr[T = vtot|V = 2j+1] ≤

Pr[T = vtot]

3h
min{k/2, max{m + 1 − j, log2 k}}

For V = 0, we have:

Pr[T = vtot|V = 0] ≤ 8 Pr[T = t]

For V = 2m, t ≥ 2m+1:

Pr[T = vtot|V = 2m] ≤ Pr[T = vtot]

4h(cid:98)t/2m(cid:99)
3(k − 2 log2 k)

Proof By Bayes rule, for v ∈ 0, 1, . . . 2m:

Pr[T = t|V = v] =

Pr[V = v|T = vtot] Pr[T = vtot]
Pr[V = v]

We are interested in upper bounding the ratio Pr[V =v|T =vtot]
This ratio is E[Xj |T =vtot]
for respective j, with Pr[V = v] =
E[Xj]/k. We may now simply substitute the upper bounds on
E[Xj|T = vtot] given by Lemma V.2, and the lower bounds
on E[Xj] given by Lemma V.3, to obtain the upper bound on
the ratio on each case.

Pr[V =v]

E[Xj ]

.

E. Analysis

Substantial anonymity is achieved if vtot is not close to its
maximum value. Conditioning on vtot > 2j+1 rules out n ≤ j,
and thus gives Pr[T = vtot|T > 2j+1] = Pr[T = vtot] h
h−j
Because of the choice of splitting procedure, receiving a piece
of size 2j + 1 gives k/2 possibilities for n, where j + 1 ≤ n ≤
j + k/2. This is why a factor of h
k/2 appears in the inequality
for this range. However for j + k/2 ≥ n > m + 1, pieces
of size 2m would be required, leaving fewer bits to use for
splitting and fewer possible n which satisfy j > m − k/2.
Hence we note that for larger values of vtot, the anonymity is
worse. However, crucially, the number of possible values for
n never falls below log2 k.

VI. LIMITATIONS AND FUTURE WORK

We have argued that ZCLAIM provides privacy in cross-
chain transfers, but many of the beneﬁts of interoperability
remain unattainable if privacy is to be maintained. Once
on the issuing chain, it is likely that interacting with the
chain in any way other than through plain transactions would
require the user to ﬁrst convert the wrapped shielded assets
to transparent assets. Private exchanges have been proposed

in the literature [44], but to the authors’ knowledge none
currently exists in the blockchain landscape.

There exist also a number of limitations inherent to the
current design of the protocol, such as the number of trans-
actions required for one cross-chain transfer following the
splitting strategy. As pointed out in Section V-B, this in not a
problem on the Zcash side. However, it imposes a limitation
on which blockchains can realistically function as an issuing
chain, as transaction fees on some blockchains can be orders
of magnitudes higher than Zcash’s.

Furthermore, the protocol presents a bootstrapping problem,
in that it depends on a sufﬁciently large number of vaults with
enough liquidity in order to function properly, which in turn
depend on serving enough requests to be proﬁtable.

The way issue and redeem availability is currently awarded,
i.e. via the vault proving that it has at least the equivalent
of vmax in free collateral or by it revealing that it holds no
ZEC obligations, respectively, is non-optimal and may reveal
information about the transacted amount. Other approaches
should be explored, such as issue and redeem requests being
assigned to vaults based on on-chain randomness, whereupon
the vault chooses whether to accept it or not. Additionally,
although the number of concurrent Issue or Redeem requests
being served by a vault is currently limited to one, we think
concurrent requests should be feasible with minor modiﬁc-
ations. It may also prove beneﬁcial to allow vaults to set
transaction fees themselves, allowing them to fend off network
congestion and at the same time incentivising competitiveness.
Furthermore, although the protocol as presented in this
paper assumes that the currency being wrapped is Zcash, it can
be adapted to any implementation of Sapling on another chain.
Such implementations currently exist e.g. on Tezos [45], [46]
and there are a number of adaptations of the Zerocash protocol
deployed in smart contracts, for instance on Ethereum [47] and
Quorum [48]. The changes required for compatibility would
mostly limit themselves to the relay system and note commit-
ment veriﬁcation, whereas the protocol logic is independent
of any speciﬁc implementation.

ZCLAIM is currently being adapted to the more recent
Orchard version of Zcash and is to be extended for usage with
multi-asset shielded pool extensions of the Zcash protocol.

VII. CONCLUSION
We have shown that it is possible to maintain the privacy-
preserving qualities of the Sapling speciﬁcation of Zcash in
cross-chain transfers. More generally speaking, we provide
a scheme for a decentralised cross-chain transfer protocol
that
integrates with a privacy-oriented cryptocurrency. We
show that no single intermediary can infer the total amount
transferred through the bridge.

ACKNOWLEDGEMENTS
The authors would like to thank Petar Tsankov for super-
vising the master’s thesis which made this work possible,
Jeff Burdges for his assistance with cryptography, Alfonso
Cevallos for useful discussions related to the splitting strategy,
and Elizabeth Herbert for editorial support.

REFERENCES

[1] S. Schulte, M. Sigwart, P. Frauenthaler, and M. Borkowski, “Towards
blockchain interoperability,” in International conference on business
process management. Springer, 2019, pp. 3–10.

[2] R. Belchior, A. Vasconcelos, S. Guerreiro, and M. Correia, “A survey
on blockchain interoperability: Past, present, and future trends,” ACM
Computing Surveys (CSUR), vol. 54, no. 8, pp. 1–41, 2021.

[3] R. Zhang, R. Xue, and L. Liu, “Security and privacy on blockchain,”
ACM Computing Surveys (CSUR), vol. 52, no. 3, pp. 1–34, 2019.
[4] A. Sanchez, “Conﬁdential cross-blockchain exchanges: Designing
a privacy-preserving interoperability scheme,” Unpublished master’s
thesis, ETH Z¨urich, Dec. 2020.

[5] A. Zamyatin, D. Harz, J. Lind, P. Panayiotou, A. Gervais, and W. Knot-
tenbelt, “XCLAIM: Trustless, interoperable, cryptocurrency-backed as-
sets,” in 2019 IEEE Symposium on Security and Privacy (SP).
IEEE,
Mar. 2019, pp. 193–210.

[6] D. Hopwood, S. Bowe, T. Hornby,

“Zcash
protocol speciﬁcation,” Electric Coin Company, Technical speciﬁcation,
Version 2020.1.15 [Overwinter+Sapling], 2020. [Online]. Available:
https://zips.z.cash/protocol/sapling.pdf

and N. Wilcox,

[7] A. Banerjee, M. Clear, and H. Tewari, “Demystifying the role of zk-
SNARKs in Zcash,” in 2020 IEEE Conference on Application, Inform-
ation and Network Security (AINS).

IEEE, 2020, pp. 12–19.

[8] Q. Feng, D. He, S. Zeadally, M. K. Khan, and N. Kumar, “A survey
on privacy protection in blockchain system,” Journal of Network and
Computer Applications, vol. 126, pp. 45–58, 2019.

[9] M. Herlihy, “Atomic cross-chain swaps,” in Proceedings of the 2018
ACM Symposium on Principles of Distributed Computing, ser. PODC
’18. New York, NY, USA: Association for Computing Machinery,
2018, pp. 245–254.

[10] [lightning-dev] an argument for single-asset lightning network. [Online].
Available: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018
-December/001752.html

[11] N. Van Saberhagen, “Cryptonote v 2.0,” Monero white paper, 2013.
[Online]. Available: https://www.getmonero.org/ru/resources/research-
lab/pubs/whitepaper annotated.pdf

[12] J. Gugger, “Bitcoin-monero cross-chain atomic swap,” Cryptology
ePrint Archive, Report 2020/1126, 2020. [Online]. Available: https:
//ia.cr/2020/1126

[13] CCS - Monero atomic swaps. [Online]. Available: https://ccs.getmoner

o.org/proposals/h4sh3d-atomic-swap-implementation.html

[14] noot/atomic-swap: ETH-XMR atomic

swap prototype.

[Online].

Available: https://github.com/noot/atomic-swap

[15] A. Zamyatin, M. Al-Bassam, D. Zindros, E. Kokoris-Kogias, P. Moreno-
Sanchez, A. Kiayias, and W. J. Knottenbelt, “SoK: Communication
across distributed ledgers,” in Financial Cryptography and Data Se-
curity. Springer Berlin Heidelberg, 2021, pp. 3–36.
[16] Wrapped. [Online]. Available: https://www.wrapped.com/
[17] Home · renproject/ren wiki. [Online]. Available: https://github.com/ren

project/ren/wiki

[18] Zcash — Ren client docs. [Online]. Available: https://renproject.github.
io/ren-js-v3-docs/classes/ renproject chains bitcoin.Zcash.html

[19] Z. F. Team. Bringing privacy to Cosmos with Zcash.

[Online].

Available: https://zfnd.org/bringing-privacy-to-cosmos-with-zcash/
[20] Github - ZcashFoundation/zcash-pegzone: A shielded pegzone bridging
Cosmos and Zcash. [Online]. Available: https://github.com/ZcashFoun
dation/zcash-pegzone

[21] J. Kwon and E. Buchman, “Cosmos: A network of distributed
ledgers,” Tendermint Inc., White paper. [Online]. Available: https:
//v1.cosmos.network/resources/whitepaper

[22] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer,
and M. Virza, “Zerocash: Decentralized anonymous payments from
Bitcoin,” in 2014 IEEE Symposium on Security and Privacy.
IEEE,
May 2014, pp. 459–474.

[23] ——, “Zerocash: Decentralized anonymous payments from Bitcoin
(extended version),” Cryptology ePrint Archive: Report 2014/349, May
2014. [Online]. Available: https://eprint.iacr.org/2014/349

[24] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” Bitcoin

white paper, 2008. [Online]. Available: https://bitcoin.org/bitcoin.pdf

[25] V. Buterin, “Chain interoperability,” R3, Tech. Rep., 2016. [Online].
Available: https://www.r3.com/wp-content/uploads/2017/06/chain inter
operability r3.pdf

[26] Simpliﬁed payment veriﬁcation (SPV) – BitcoinWiki.

[Online].

Available: https://en.bitcoinwiki.org/wiki/SPV

[27] A. Back, M. Corallo, L. Dashjr, M. Friedenbach, G. Maxwell,
A. Miller, A. Poelstra, J. Tim´on, and P. Wuille, “Enabling blockchain
innovations with pegged sidechains,” Tech. Rep., 2014.
[Online].
Available: https://blockchainlab.com/pdf/sidechains.pdf

[28] J. Burdges, A. Cevallos, P. Czaban, R. Habermeier, S. Hosseini, F. Lama,
H. K. Alper, X. Luo, F. Shirazi, A. Stewart et al., “Overview of Polkadot
and its design considerations,” Web3 Foundation, Tech. Rep., May 2020.
[29] The DFINITY Team, “The internet computer for geeks,” Cryptology
ePrint Archive, Report 2022/087, 2022. [Online]. Available: https:
//ia.cr/2022/087

[30] Cryptocurrency deposit processing times – Kraken. [Online]. Available:
https://support.kraken.com/hc/en-us/articles/203325283-Cryptocurrenc
y-deposit-processing-times

[31] How long until my crypto deposit reaches my account? – Gemini.
[Online]. Available: https://support.gemini.com/hc/en-us/articles/20542
4836-How-long-until-my-digital-asset-deposit-reaches-my-account
[32] J. Quesnelle, “On the linkability of Zcash transactions,” Dec. 2017,

arXiv:1712.01210 [cs.CR].

[33] A. Gervais, G. O. Karame, K. W¨ust, V. Glykantzis, H. Ritzdorf,
and S. Capkun, “On the security and performance of proof of work
blockchains,” in Proceedings of the 2016 ACM SIGSAC conference on
computer and communications security, 2016, pp. 3–16.

[34] E. Heilman, A. Kendler, A. Zohar, and S. Goldberg, “Eclipse attacks on
Bitcoin’s peer-to-peer network,” in 24th USENIX Security Symposium
(USENIX Security 15). Washington, D.C.: USENIX Association, Aug.
2015, pp. 129–144.

[35] K. W¨ust and A. Gervais, “Ethereum eclipse attacks,” ETH Zurich, Tech.

Rep., 2016.

[36] G. Xu, B. Guo, C. Su, X. Zheng, K. Liang, D. Wong, and H. Wang, “Am
I eclipsed? A smart detector of eclipse attacks for Ethereum,” Computers
& Security, vol. 88, p. 101604, Sep. 2019.

[37] B. Alangot, D. Reijsbergen, S. Venugopalan, and P. Szalachowski, “De-
centralized lightweight detection of eclipse attacks on Bitcoin clients,” in
2020 IEEE International Conference on Blockchain (Blockchain), 2020,
pp. 337–342.

[38] J. Peterson and J. Krug, “Augur: a decentralized, open-source platform
for prediction markets,” CoRR, vol. abs/1501.01042, 2015. [Online].
Available: http://arxiv.org/abs/1501.01042

[39] S. Ellis, A. Juels, and S. Nazarov, “Chainlink: A decentralized oracle
network,” SmartContract ChainLink Ltd., White paper, 2017. [Online].
Available: https://research.chain.link/whitepaper-v1.pdf

[40] S. K. Lo, X. Xu, M. Staples, and L. Yao, “Reliability analysis for
blockchain oracles,” Computers & Electrical Engineering, vol. 83, p.
106582, Feb. 2020.

[41] J. Fry and J. E.-T. Cheah, “Negative bubbles and shocks in cryptocur-
rency markets,” International Review of Financial Analysis, vol. 47, pp.
343–352, Feb. 2016.

[42] J. E.-T. Cheah and J. Fry, “Speculative bubbles in Bitcoin markets?
investigation into the fundamental value of Bitcoin,”

an empirical
Economics Letters, vol. 130, pp. 32–36, Feb. 2015.

[43] Zcash feature UX checklist — Zcash documentation.

[Online].
Available: https://zcash.readthedocs.io/en/latest/rtd pages/ux wallet c
hecklist.html#transactions

[44] M. B. da Gama, J. Cartlidge, A. Polychroniadou, N. P. Smart, and
Y. T. Alaoui, “Kicking-the-bucket: Fast privacy-preserving trading
using buckets,” Cryptology ePrint Archive, Report 2021/1549, 2021.
[Online]. Available: https://ia.cr/2021/1549

[45] L. Goodman, “Tezos: a self-amending crypto-ledger,” White paper,

2014. [Online]. Available: https://tezos.com/whitepaper.pdf

[46] Nomadic Labs - sapling integration in Tezos - tech preview. [Online].
Available: https://research-development.nomadic-labs.com/sapling-inte
gration-in-tezos-tech-preview.html

[47] A. Rondelet and M. Zajac, “ZETH: On integrating Zerocash on Eth-

ereum,” Apr. 2019, arXiv:1904.00905 [cs.CR].

[48] ZSL · ConsenSys/quorum wiki

· GitHub.
https://github.com/ConsenSys/quorum/wiki/ZSL

[Online]. Available:

