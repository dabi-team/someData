2
2
0
2

r
a

M
1

]

R
C
.
s
c
[

1
v
9
6
7
0
0
.
3
0
2
2
:
v
i
X
r
a

VOLCANO: Detecting Vulnerabilities of Ethereum Smart Contracts Using Code
Clone Analysis

NOAMA FATIMA SAMREEN, Ryerson University, Canada
MANAR H. ALALFI, Ryerson University, Canada

Ethereum Smart Contracts based on Blockchain Technology (BT) enables monetary transactions among peers on a blockchain network

independent of a central authorizing agency. Ethereum Smart Contracts are programs that are deployed as decentralized applications,

having the building blocks of the blockchain consensus protocol. This enables consumers to make agreements in a transparent and

conflict-free environment. However, there exists some security vulnerabilities within these smart contracts that are a potential threat

to the applications and their consumers and have shown in the past to cause huge financial losses. This paper presents a framework

and empirical analysis that use code clone detection techniques for identifying vulnerabilities and their variations in smart contracts.

Our empirical analysis is conducted using Nicad code clone detection tool on a dataset of approximately 50k Ethereum smart contracts.

We evaluated VOLCANO on two datasets, one with confirmed vulnerabilities and another with approximately 50k random smart

contracts collected from the Etherscan[1]. Our approach shows an improvement in detection of vulnerabilities in terms of coverage

and efficiency when compared to two of the publicly available static analysers to detect vulnerabilities in smart contracts. To the

best of our knowledge, this is the first study that uses a clone detection technique to identify vulnerabilities and their evolution in

Ethereum smart contracts.

CCS Concepts: • Security and privacy → Vulnerability scanners; Denial-of-service attacks; Distributed systems security; Software
and application security.

Additional Key Words and Phrases: Blockchain Technology, Ethereum Smart Contracts, Code Cloning, Security Vulnerabilities

Evolution

ACM Reference Format:
Noama Fatima Samreen and Manar H. Alalfi. 2018. VOLCANO: Detecting Vulnerabilities of Ethereum Smart Contracts Using Code

Clone Analysis. 1, 1 (March 2018), 18 pages. https://doi.org/XXXXXXX.XXXXXXX

1 INTRODUCTION

The advent of Ethereum[2] at the end of 2015 changed the way everyone looked at blockchain technology. Ethereum

Smart Contracts leverages blockchain technology to enable transactions among peers on a blockchain network inde-

pendent of a central authorizing agency. However, recent research to identify the existence of security vulnerabilities in

Ethereum Smart Contracts have shown that many applications have been exposed to attacks because of vulnerabilities

found in application level of Ethereum Smart Contracts. These vulnerabilities are a potential threat to their consumers

and have caused immense financial losses in the past. In a previous study, we have conducted a literature survey to

highlight the seriousness of these security vulnerabilities and compared some of the available tools that target the

Authors’ addresses: Noama Fatima Samreen, noama.samreen@ryerson.ca, Ryerson University, Department of Computer Science, Toronto, Ontario,
Canada; Manar H. Alalfi, manar.alalfi@ryerson.ca, Ryerson University, Department of Computer Science, Toronto, Ontario, Canada.

Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not
made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components
of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to
redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org.

© 2018 Association for Computing Machinery.
Manuscript submitted to ACM

Manuscript submitted to ACM

1

 
 
 
 
 
 
2

Noama Fatima Samreen and Manar H. Alalfi

detection of these security vulnerabilities in Ethereum Smart Contracts [3]. However, the revolutionary features of

Ethereum and the continual version updates of Solidity Programming language makes detection of vulnerabilities

and updating smart contracts much harder than traditional programs. Researchers have explored different ways to

identify these vulnerabilities. Prior code clone detection research in Ethereum smart contracts have shown that there

existed almost 81% of code cloning in smart contracts[4]. Therefore, we believe that if a vulnerable code pattern can be

obtained from a code base of confirmed vulnerabilities, then we might be able to use the vulnerable code pattern as a

code-signature to identify other vulnerable smart contracts. Hence, code clone detection technique could be an ideal

technique for vulnerabilities detection and should provide accurate results. Investigating code cloning in Ethereum

smart contracts from a vulnerability detection perspective, we need to address the following research questions:

• RQ1: Can we use clone detection techniques to generate a pattern of vulnerable code extracted from a dataset of

vulnerable/exploited smart contracts?

• RQ2: Can we use the vulnerability signature to detect similar vulnerabilities in a dataset of approximately 50k

smart contracts?

• RQ3: Can we find variants of these vulnerabilities in a Solidity programming language version-sorted dataset of

smart contracts?

To our knowledge, this is the first study that uses clone detection technique to identify the vulnerabilities and their

evolution in Ethereum smart contracts. Moreover, this paper presents the following contributions while investigating

the research questions:

(1) An empirical analysis of code clone detection technique to identify vulnerabilities in approximately 50k Ethereum

smart contracts.

(2) An comparison of the results produced by the proposed technique of detecting vulnerabilities when compared to

two of the publicly available static analysers to detect vulnerabilities in smart contracts.

(3) Vulnerability evolution analysis across different versions of the Solidity programming language;

(4) a literature review on available approaches of using code cloning to detect vulnerabilities in a system.

After the introduction, Section 2 briefly highlights the background of Ethereum smart contracts and code cloning in

general. Section 3 presents an overview of our approach, VOLCANO and a description of the datasets used for this study;

Section 4 shows the results of applying a cross-code clone detection tool to the datasets to detect vulnerabilities. Section

5 presents the evaluation of this approach when compared to two other publicly available static analysers to detect

vulnerabilities in smart contracts. Section 6 describes the studied approaches in the literature review of vulnerability

identification using code-clone detection technique, followed by a conclusion in Section 6.

2 BACKGROUND

2.1 Smart Contracts

Ethereum uses Smart-Contracts[2], which are computer programs that directly controls the flow or transfer of digital

assets. Implementing a Smart-Contract use case can pose few security challenges, like public visibility of the complete

source code of an application on a network, and validation and verification of the source code. Moreover, the immutability

of Blockchain technology makes patching discovered vulnerabilities in already deployed Smart-Contracts impossible.

Solidity
Smart contracts are typically written in a high-level Turing-complete programming language such as Solidity[5],

and then compiled to the Ethereum Virtual Machine (EVM) bytecode[2], a low-level stack-based language.

Manuscript submitted to ACM

VOLCANO: Detecting Vulnerabilities of Ethereum Smart Contracts Using Code Clone Analysis

3

2.2 Code Cloning

Code clone Terminology used in this study[6]:

(1) Code Fragment: It is a pattern of lines of code which can be of any granularity, e.g., function definition, or

sequence of statements.

(2) Code Clone: A code fragment is known as a code clone if the code fragment is either identical or similar to

another code fragment.

(3) Clone Pair: A pair of code fragments that are identical or similar.
(4) Clone Class: More than two code fragments that are identical or similar.
(5) Code Clone Type: Depending of the percentage of similarity between two code fragments, Code clones are

classified into following types:
(a) Code clones of Type-1: These are code fragments that are identical with variation in comments and blank

spaces.

(b) Code clones of Type-2: The code fragments that are identical with variations in identifier names, literals,
comments and blank spaces. These clones are also called blind renamed clones, where Blind Renaming is the
process of renaming all the identifiers to X without keeping a record of previously renamed identifier.
(c) Code clones of Type-2c: Similar to the Type 2 code clones, this type of code clones is consistently renamed,
which is process of renaming the identifiers to Xn. Where, n is the number of occurrences of the identifier
with respect to the previously renamed identifier.

(d) Code clones of Type 3-1: These are code clones that have similar code fragments with further modifications
than Type-2 code clones like changed, added, or removed statements, in addition to variations in identifiers,

literals, types, white-space, layout and comments.

(e) Code clones of Type 3-2c: These are code clones that have similar code fragments with further modifications
than Type-2c code clones. Type-3-2c can be considered as a hybrid of the Type 3-1 and Type 2c code clones in

that they are similar code fragments with changed, added, or removed statements, in addition to variations in

identifiers, literals, types that are consistently renamed.

(f) Code clones of Type 4: These are known as Functional Clones with two or more code fragments that

perform the same computation but are implemented by different syntactic variants.

3 APPROACH

Current research in vulnerability detection in Ethereum smart contracts use static, dynamic or combined program

analysis. We aim at developing a different approach to detect vulnerabilities in Ethereum smart contracts to achieve high

recall and precision. We believe that the evolution of programming languages that supports development of Ethereum

smart contracts is proportional to the evolution of known vulnerabilities in smart contracts. Therefore, we leverage the

code clone detection technique based on static analysis of smart contracts in a 4-step process to identify and investigate

the evolving nature of vulnerabilities in Ethereum smart contracts. [See Figure 1]

Our approach, VOLCANO, consists of four main stages:

(1) Vulnerability Dataset organization

This dataset consists of the smart contracts that have confirmed vulnerabilities in them. The Vulnerability

Dataset was collected from multiple open-source dataset repositories available on GitHub[7]. However, we

found inconsistencies in the categorization of smart contract vulnerabilities in our dataset sources. Therefore,

Manuscript submitted to ACM

4

Noama Fatima Samreen and Manar H. Alalfi

Fig. 1. Approach

we performed code clone detection using Nicad tool on the Vulnerability Dataset to generate a vulnerability

signature for each of the vulnerability type clone class present in the dataset and thereby efficiently segregate

and categorize the vulnerabilities. The final organization of our Vulnerability Dataset is presented in the Table 1.

For this empirical analysis, we set the Nicad tool to detect clones at the function granularity level. The main aim

of this step is to cluster vulnerabilities into different classes of clones. These classes can be used to generate a

vulnerability signature for each of the vulnerability clone class identified in this step and also to increase the

efficiency of identifying vulnerability clones in the Evaluation Dataset by having vulnerabilities clone classes

segregated in separate folders. The setup to segregate smart contracts in the Vulnerability Dataset followed the

detection of type 3-2 and type 3-2c code clones with a maximum difference threshold ranging from 0% to 30% to

extract and categorize clones of vulnerabilities. The generated code clone classes were manually analyzed to

confirm the existence of a vulnerability in them and categorize it.

(2) Vulnerability signature generation using code clone detection in the Vulnerability Dataset

Following the above step of segregating the code clone classes that contain different types of vulnerabilities,

a vulnerability signature was derived for each of the clone classes detected. The vulnerability signature is a

code pattern that corresponds to a type of known vulnerabilities in Ethereum smart contracts with a maximum

Manuscript submitted to ACM

VOLCANO: Detecting Vulnerabilities of Ethereum Smart Contracts Using Code Clone Analysis

5

Table 1. VULNERABILITY DATASET ORGANIZATION

S.no Vulnerability Type

1
2
3
4
5
6
7
8

Re-entrancy
Denial of Service (DOS)
Integer Underflow/Overflow
Call-To-Unknown
Out-of-Gas exception
Mishandled Exceptions
Mismatched Typecasting
Weak Modifiers
Total

No. of Smart
Contracts
37
17
16
44
14
54
7
33
222

No. of Vulnerability Instances

42
22
20
45
20
58
7
68
282

difference threshold of 30%. This was to account for slight variations in the vulnerability signature pattern

matching process.

(3) Vulnerability identification using cross-code clone detection between organized Vulnerability Dataset

and Evaluation Dataset
Our second dataset, Evaluation Dataset, contains smart contracts that were randomly collected over a period

of time from Etherscan[1]. We collected 49,969 Ethereum smart contracts written in Solidity programming

language and having at least one transaction from Etherscan[1]. These smart contracts were not initially filtered

for vulnerabilities and we used this dataset in this stage of our approach to identify vulnerabilities using the

vulnerability signatures generated from the Vulnerability Dataset in the previous stage. The setup to identify

the vulnerability code clones in the Evaluation Dataset was to detect type 3-2 and type 3-2c code clones with a

maximum difference threshold ranging from 0% to 30%. To efficiently identify code clone classes with vulnerability

signature, we added a comment before the start of a vulnerability signature to highlight the vulnerability type.

(4) Vulnerability evolution analysis across different versions of the Solidity programming language

The smart contracts in the Evaluation Dataset are organized using a python script that sorts the smart contracts

based on their Solidity programming language version number. Following this sorting, the cross-code clone

detection is repeated on the Sorted-Evaluation Dataset to analyze the difference between a vulnerability clone

class from a smart contract of an earlier version of Solidity programming language to that of the same in a newer

version.

4 RESULTS AND DISCUSSION

This study conducts an empirical analysis to understand the state of vulnerabilities in Ethereum smart contracts by

trying to study the patterns, extent, and variations of known vulnerabilities in Ethereum smart contracts by using code

clone detection techniques. The research questions highlighted in this research study are answered below:

RQ1: Can we use clone detection techniques to generate a pattern of vulnerable code extracted from a

dataset of vulnerable/exploited smart contracts?

Motivation: We have reviewed several research studies that have explored the possibility of applying code clone
detection techniques to detect vulnerabilities in software systems [See section 6]. However, none of the research works

Manuscript submitted to ACM

6

Noama Fatima Samreen and Manar H. Alalfi

we reviewed used code clone detection technique to form vulnerability signature of vulnerable code patterns from a

dataset of confirmed vulnerabilities in Ethereum smart contracts and further detect these vulnerabilities in a generic

dataset to understand the extent and evolution of these vulnerabilities.

Findings: Vulnerable code can form code clone classes. We use the Nicad[6] code clone detection tool to extract
these classes from a dataset of confirmed vulnerabilities in Ethereum smart contracts. Table 1 shows the preliminary

result of the vulnerability type classification and signature generation. The Table 1 is a snapshot of the vulnerable code

clone classes at a 0% difference threshold detected in our Vulnerability Dataset. We found eight vulnerability types
in our dataset: Reentrancy, Denial of Service(DoS), Integer Underflow/Overflow, Call-to-Unknown, Out-of-Gas Exception,
Mishandled Exceptions, Mismatched Typecasting, Weak Access Modifiers. These vulnerability types had a varied number of
smart contracts that belonged to multiple code clone classes. The vulnerable code clone classes were analyzed to derive

the vulnerability signature for each vulnerability. We validated the vulnerability signatures generated by comparing

them to the code examples from the research available in this field [3]. Each of the vulnerability types is described next

with references to the vulnerability signatures derived for each type.

Call-to-Unknown Vulnerability. Listings 1,2 presents the vulnerability-signatures extracted for the Call-to-Unknown
vulnerability. This vulnerability is related to access control issues. Accessing a contract’s functionality through its public

or external functions with improper function signatures or insecure visibility settings gives rise to this vulnerability in

a smart contract. In listing 1, a vulnerable smart contract gets initialized by an address which gets decided by line 2.

This is one of the common coding practices for defining access permissions like withdrawing the contract’s funds etc.

This makes the smart contract vulnerable as the initialization function can be called multiple times and by anyone via
msg.sender. Listing 2 is a code pattern that uses the built-in low level function delegatecall(). When a contract executes
delegatecall() to call another contract, then the latter contract’s code gets executed. The call-to-unknown vulnerability
rises when the contract’s interface is not checked before calling it or the return value of this external call is not checked.
(cid:7)

function initialize () public {

new_owner = msg . sender ;

}
(cid:10)(cid:6)

(cid:7)

Listing 1. Call-to-unknown Vulnerability Signature-1

function () payable {

if ( msg . data . length > 0)

owner . delegatecall ( msg . data );

}

(cid:10)(cid:6)

(cid:5)

(cid:5)

Listing 2. Call-to-unknown Vulnerability Signature-2

Denial of Service (DoS) Vulnerability. Listings 3,4,5,6 presents the extracted vulnerability-signatures for the Denial of
Service (DoS) vulnerability. An exploitation of the DoS vulnerability makes a smart contracts unavailable for service on
the Ethereum network. The major scenarios that can make a smart contract vulnerable to DoS attack are highlighted in
listings 3, 4, 5, 6. Listings 3 and 4 shows the usage of built-in functions suicide() and selfdestruct() without checking the
ownership of the smart contract or access permissions. Any external user can gain control of the smart contract and

call this function to suspend all the transactions of the smart contract and make it unavailable for service. Listing 5
shows the usage of the external call function send() inside a for-statement. If the send() function fails to execute, then the
Manuscript submitted to ACM

VOLCANO: Detecting Vulnerabilities of Ethereum Smart Contracts Using Code Clone Analysis

7

transaction is reverted and the loop is halted and make the smart contract unavailable for service. Similar to listing 5,
listing 6 shows the usage of the built-infunction require() inside a for-statement. The require() function takes a condition
that cannot be detected until execution time. This condition can be dependent on variables such as inputs or return
values from calls to external contracts. Therefore, using this function inside a for-statement can halt the loop and make
the smart contract unavailable for service.
(cid:7)

function kill ( address malicious ) external {

suicide ( malicious );
}

(cid:10)(cid:6)

(cid:7)

Listing 3. DoS Vulnerability Signature-1

function kill ( address malicious ) external {

selfdestruct ( malicious );
}

(cid:10)(cid:6)

(cid:7)

Listing 4. DoS Vulnerability Signature-2

function sendPayments () public returns ( bool ){

for ( uint i =0; i <n;i ++) {

addresses . send ( msg . sender );

}

return true ;

}

(cid:10)(cid:6)

(cid:7)

Listing 5. DoS Vulnerability Signature-3

function sendPayments () public returns ( bool ){

for ( uint i =0; i <n;i ++) {

require ( addresses . send ( msg . sender ));

}
return true ;

}

(cid:10)(cid:6)

Listing 6. DoS Vulnerability Signature-4

(cid:5)

(cid:5)

(cid:5)

(cid:5)

Reentrancy Vulnerability. Listing 7 shows the vulnerability signature derived for the re-entrancy vulnerability. A re-
entrancy attack can drain a smart contract of all its ether, which was first discovered in the Decentralised Autonomous

Organization (DAO) attack of 2016. As the name of the vulnerability suggests, re-entrancy occurs when an external

contract makes multiple calls to a contract before the initial call’s execution is completed. In listing 7, the vulnerability
scenario arises when an external function call send() is called to send out ether before updating the state variables. This
causes the fallback function of the contract receiving the ether is executed. If the fallback function of the receiving
contract calls the withdraw of ether again, then the send() is executed again as the state variable that hold the total
balance of ether is updated after the execution of the send() function is completed.
(cid:7)

function externalSend ( uint amountToSend ) {

if ( balance >= amountToSend )
msg . sender . call . value ( amountToSend ) () ;
balance -= amountToSend ; \\ state variable updated after external call function is executed

}

Manuscript submitted to ACM

8

(cid:10)(cid:6)

Noama Fatima Samreen and Manar H. Alalfi

Listing 7. Re-entrancy Vulnerability Signature

Integer Underflow/Overflow Vulnerability. Another common vulnerability in Ethereum smart contracts is Integer
underflow and overflow error. This vulnerability is not specific to Ethereum smart contracts construct; However, these

make the smart contracts exposed to malicious attacks with the motive of draining the victim smart contract of its

ether. Listing 8 shows the vulnerability signature of this type which includes a simple function that does not check for

integer underflow or overflow before performing arithmetic operations.
(cid:7)

function externalSend ( uint amountToSend ) {

if ( balance >= amountToSend )
msg . sender . call . value ( amountToSend ) () ;
balance -= amountToSend ; \\

}
(cid:10)(cid:6)

Listing 8. Integer Underflow/Overflow Vulnerability Signature

Mishandled Exceptions Vulnerability. The exception handling in Solidity programming language is not even for the
exceptions thrown during external calls like send(), call(), delegatecall(). The exceptions do not propagate in the code.
These external calls return a Boolean value, which will be set to false when an exception is thrown. However, when this

Boolean value is unchecked, the programmers are not notified in any other way about the exception and can expose

smart contracts to malicious transactions that may result in the exploitation of this vulnerability. Listing 9 shows the

vulnerability signature for this type.
(cid:7)

function externalCall ( uint str ) {

msg . sender . delegateCall ( str ); \\ without checking for return value

}
(cid:10)(cid:6)

Listing 9. Mishandled Exceptions Vulnerability Signature

Weak Access Modifiers Vulnerability. Listing 10 shows the vulnerability signature for weak access modifiers vulnerability.
When a modifier for a function or a parameter is not explicitly specified, then the default access modifier is public. The
public access modifier makes the smart contract vulnerable to the weak access modifiers vulnerability as these can be
manipulated by observing the hash values of the blocks appended to the Ethereum network.
(cid:7)

function initialize () public { // weak access modifier for the function initialize

new_owner = msg . sender ;

}
(cid:10)(cid:6)

(cid:7)

Listing 10. Weak Access Modifiers Vulnerability Signature

function externalSend ( uint amountToSend ) {

if ( balance >= amountToSend )

msg . sender . send ( amountToSend ); \\ gasless - send

}
(cid:10)(cid:6)

Listing 11. Out-of-Gas Exception Vulnerability Signature

Manuscript submitted to ACM

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

VOLCANO: Detecting Vulnerabilities of Ethereum Smart Contracts Using Code Clone Analysis

9

Table 2. CODE CLONES FROM A VULNERABILITY DATASET FOUND IN AN EVALUATION DATASET OF 50k SMART CONTRACTS
COLLECTED

Filtered,
Blind-Renamed
Type 3-2
(Inclusive of Type 1, 2)
32034
212

Filtered,
Consistent-Renamed
Type 3-2c
(Inclusive of Type 1, 2c)
19129
165

0%

30%

Clone Type

Clone

Clone Pairs
Total
Classes
Max Difference
Threshold

Out-of-Gas Exception Vulnerability. Listing 11 shows the vulnerability signatures derived from the code clone classes for
Out-of-Gas Exception vulnerability in the Vulnerability Dataset. When send() external function call is used to ether to
another smart contract, the fallback function of the receiving smart contract will be executed. If this function contains

code that would cost more than 2300 gas units to get executed, then the fallback function will revert due to insufficient

gas. The smart contract that was supposed to send the ether will keep the ether even though it was supposed to send it

to the receiving smart contract because it is not notified of the exception raised due to an unexpected revert sequence.

RQ2: Can we use the vulnerability signature to detect similar vulnerabilities in a dataset of approximately

50k smart contracts?

Motivation:

Code clone detection can identify code fragments that contains similar code patterns. Therefore, the cross-systems

code clone detection feature provided by the Nicad tool was used in efficiently detecting similar vulnerabilities in the

Evaluation Dataset.

Findings:
Our analysis resulted in code clone classes consisting of vulnerable code fragments from the Vulnerability Dataset as

well as code fragments from the smart contracts in the Evaluation Dataset. Therefore, we can confirm that the cross

code clone detection technique could successfully identify vulnerability code patterns that are similar or identical to the

vulnerability signatures generated. Table 2 shows the summary of the code clone classes discovered in the empirical

analysis using cross-code clone detection between our Vulnerability Dataset and Evaluation Dataset. This resulted in

212 clone classes that were of Type 3-2 (Filtered and Blind-Renamed) with maximum difference threshold of 0% and

165 clone classes of Type 3-2c (Filtered and Consistent-Renamed) with maximum difference threshold of 30%. Table 3

shows the detection of vulnerability clones in the Evaluation Dataset.

RQ3: Can we find variants of these vulnerabilities in a Solidity programming language version-sorted

dataset of smart contracts?

Motivation:

As the Solidity programming language updates its versions to safeguard against the known vulnerabilities, the

vulnerable code patterns change over time as well. This evolution can be studied by observing the variations in a

vulnerability across different versions of Solidity programming language.

Manuscript submitted to ACM

10

Noama Fatima Samreen and Manar H. Alalfi

Table 3. VULNERABILITY CLONES IN THE EVALUATION DATASET

Vulnerability Type

Clone Classes

Total Vulnerability
Instances

Re-entrancy
Denial of Service (DOS)
Integer Underflow/Overflow
Call-To-Unknown
Out-of-Gas exception
Mishandled Exceptions
Mismatched Typecasting
Weak Modifiers
Total

Type 3-2
28
23
29
32
17
14
12
18
164

Type 3-2c
22
22
23
29
14
11
8
15
145

10764
14189
18892
1078
1552
210
268
991
47944

Table 4. EVALUATION DATASET ORGANIZATION BY SOLIDITY VERSION

Solidity Version

ˆ0.3
ˆ0.4
ˆ0.5
ˆ0.6
ˆ0.7
ˆ0.8
Total

No. of Smart
Contracts
105
28920
13775
4400
2472
297
49969

Table 5. VULNERABILITY CLONE CLASSES IN THE SORTED-EVALUATION DATASET BASED ON THE VERSIONS OF SOLIDITY

Vulnerability Type

0.3

0.4

0.5

0.6

0.7

0.8

2
-
3
e
p
y
T
0
0
1
2
0
0
0
2
5

c
2
-
3
e
p
y
T
0
1
1
2
0
0
0
1
5

2
-
3
e
p
y
T
15
7
9
14
11
8
5
6
75

c
2
-
3
e
p
y
T
14
6
10
14
8
5
3
6
66

2
-
3
e
p
y
T
6
6
5
6
3
3
3
5
37

c
2
-
3
e
p
y
T
5
6
5
5
3
2
2
4
32

2
-
3
e
p
y
T
3
5
4
3
1
1
2
2
21

c
2
-
3
e
p
y
T
1
5
4
4
1
2
1
3
21

2
-
3
e
p
y
T
2
3
3
4
1
1
1
2
17

c
2
-
3
e
p
y
T
1
3
2
3
1
1
1
1
13

2
-
3
e
p
y
T
2
1
1
1
1
1
1
1
9

c
2
-
3
e
p
y
T
1
2
1
1
1
1
1
0
8

Re-entrancy
DoS
Integer U/O
Call To Unknown
Gas exception
Mis-Exceptions
Mis-Typecasting
Weak Modifiers
Total

Findings:
Table 4 shows the sorted evaluation dataset based on their Solidity version number. The Sorted-Evaluation Dataset

resulted in organization of the dataset into 6 sub-folders representing versions of Solidity programming language. The
smart contracts in our dataset used Solidity programming language with version ranging from 0.3 to 0.8 (including the
Manuscript submitted to ACM

VOLCANO: Detecting Vulnerabilities of Ethereum Smart Contracts Using Code Clone Analysis

11

Table 6. LOWEST SIMILARITY PERCENTAGE OF VULNERABILITY CLONE CLASSES IN THE SORTED-EVALUATION DATASET
BASED ON THE VERSIONS OF SOLIDITY

Vulnerability Type
Re-entrancy
DoS
Integer U/O
Call To Unknown
Gas exception
Mis-Exceptions
Mis-Typecasting
Weak Modifiers

0.3
NA
98%
88%
92%
NA
NA
NA
98%

0.4
98%
98%
98%
80%
98%
96%
80%
98%

Type 3-2c
0.6
96%
92%
88%
70%
82%
82%
80%
90%

0.5
98%
94%
98%
82%
98%
88%
80%
98%

0.7
82%
88%
76%
70%
78%
82%
70%
82%

0.8
70%
82%
70%
70%
70%
70%
70%
82%

sub-versions for each version). Table 5 shows the detection of vulnerability clones in the Sorted-Evaluation Dataset

based on their Solidity version number. From the total of 164 vulnerability-related clone classes of Type 3-2 and 145

vulnerability clone classes of Type 3-2c, we analyse the distribution of clone classes across different versions of the

Solidity programming language.

To analyze the changing patterns of vulnerabilities in newer Solidity versions, we observe the maximum difference

threshold, in other words, lowest similarity percentage between vulnerability signature and smart contract’s code

fragments recorded for each of the vulnerability types in different versions of Solidity programming language. This is

analysed only for the Type 3-2c code clone classes, as this type allows for a maximum difference threshold ranging from

0% to 30%. In Table 6, we see that the similarity percentage decreases for newer versions of Solidity when compared

to the earlier versions. It can be inferred from this observation that the vulnerability patterns undergo changes with

updates to the Solidity programming language.

5 EVALUATION

We conducted a preliminary survey of available tools and technologies implemented to detect vulnerabilities in Ethereum

smart contracts[8]. There are many static analysers in the market currently that provide vulnerabilities detection

for Ethereum smart contracts. However, many of the available tools does not meet our requirements for evaluation.

According to our research [8], [9], SmartCheck[10] and Slither[11] static analysis tools conform to the following

inclusion criteria relevant to our requirements:

(1) Publicly available with a Command Line Interface (CLI) - This requirement is suited to analyse our dataset of

approx. 50k smart contracts.

(2) Analyses smart contracts source code - The input to the tool is a smart contract .sol file and this source code is

only required to run the analysis.

(3) Vulnerabilities Detector - The tool detects vulnerabilities or common bad coding practices in smart contracts.

5.1 Vulnerabilities Detected by the Analysis Tools

We subjected both the datasets used in this study to Slither[11] and SmartCheck[10] static analyser using their CLI. We

observed that the number of vulnerability instances detected by both these tools is comparable to that detected by our

approach with a few exceptions arising due to a couple of vulnerability types identified by our approach. For example,

Manuscript submitted to ACM

12

Noama Fatima Samreen and Manar H. Alalfi

Table 7. VULNERABILITIES IDENTIFIED BY EACH TOOL PER CATEGORY IN VULNERABILITY DATASET

Vulnerability Type

Analysis Results

Re-entrancy
Denial of Service (DOS)
Integer Underflow/Overflow
Call-To-Unknown
Out-of-Gas exception
Mishandled Exceptions
Mismatched Typecasting
Weak Modifiers
Total

Slither
42
0
0
35
19
50
0
53
199

SmartCheck VOLCANO
42
0
18
40
19
50
7
0
176

42
22
20
45
20
58
7
68
282

Table 8. VULNERABILITIES IDENTIFIED BY EACH TOOL PER CATEGORY IN EVALUATION DATASET

Vulnerability Type

Analysis Results

Re-entrancy
Denial of Service (DOS)
Integer Underflow/Overflow
Call-To-Unknown
Out-of-Gas exception
Mishandled Exceptions
Mismatched Typecasting
Weak Modifiers
Total

Slither
10764
0
0
1078
1552
210
0
391
13995

SmartCheck VOLCANO
8745
0
18725
867
501
443
145
0
29426

10764
14189
18892
1078
1552
210
268
991
47944

the Denial of service vulnerability type is not supported by either of the two tools used to evaluate our approach. Again,

the Integer underflow and overflow vulnerability type was not detected by Slither and the Weak access modifiers type of

vulnerabilities were missed by the SmartCheck analysis tool. Therefore, the results for the Vulnerability Dataset show a

total of 199 vulnerability instances identified by Slither, 176 vulnerability instances identified by SmartCheck and 282

by our approach, VOLCANO. Also, in the table 8, we can observe the difference in number of vulnerability instances

detected between VOLCANO and the two other tools because of the vulnerability pattern coverage implemented by our

approach that accommodates for a maximum difference threshold of 30%.

5.2 Execution Time of the Analysis Tools

To compare the time of the execution for each of the tools used for evaluation, we recorded each individual analysis

time for both the datasets. This analysis time is measured by calculating the difference between the starting time and

the ending time of each analysis. Table 9 shows the average and total analysis times used by each tool to analyse 50k

smart contracts in our Evaluation Dataset. In the table 9, we can observe the significant difference in total analysis

time between VOLCANO and the two other tools. This difference in analysis time between the three tools is because

of the technique that each tool uses to analyse each smart contract. Slither and SmartCheck both parse the AST of

the contract to identify vulnerabilities, whereas VOLCANO is based on signature matching using Nicad code clone

Manuscript submitted to ACM

VOLCANO: Detecting Vulnerabilities of Ethereum Smart Contracts Using Code Clone Analysis

13

Table 9. ANALYSIS TIME RECORDED FOR EACH TOOL FOR EVALUATION DATASET

Analysis Tool
Slither
SmartCheck
VOLCANO

Average Analysis Time
00:00:05
00:00:10
00:00:01

Total Analysis Time
2 days, 21:26:38
5 days, 18:43:12
13:53:16

Fig. 2. GitHub Repository of used Datasets and Results

detection tool. NiCad’s incremental mode, in which a system that has already been analyzed is re-analyzed only for

new clones, is responsible for significantly reducing the analysis time used by our approach.

The datasets used in this research and a catalog of all the vulnerabilities detected in the Evaluation Dataset by

VOLCANO as well as SmartCheck and Slither are available on GitHub[12] and can be made publicly available upon

request.

6 RELATED WORK

6.1 Code Clone Detection Approaches for Vulnerability Detection

Usually, vulnerabilities in a system are detected using static code analysis of the source code. On the other hand, code

clone vulnerability in a software system is detected by identifying vulnerabilities that propagate in a system due to code

cloning. However, our focus of research is to study approaches that supports security vulnerability detection without

any adaptations or an approach that uses code clone detection technique within a system to generate a vulnerability

code pattern and then use this code pattern to detect its clones and variations in a target system.

Manuscript submitted to ACM

14

Noama Fatima Samreen and Manar H. Alalfi

Fig. 3. Catalog of Vulnerabilities Detected in Evaluation Dataset

Kim et al. [13] addresses the lack of scalability in code clone detection techniques to cover ever growing open-source

software systems. This approach targets accurate identification of all types of code clones. It even provides an built-

insupport for finding security vulnerabilities in large software programs that is resilient to common modifications in

cloned code while preserving the vulnerable conditions. It uses function level granularity and length filtering technique

to reduces the number of signature comparisons thereby ensuring a scalable approach. This approach is evaluated using

a dataset of C/C++ programs collected from over 25k repositories on GitHub. Vuddy uses vulnerability database such as

CVE - Common vulnerabilities and Exposures to discover code clones of vulnerabilities in the target programs.

Another approach studied in this research that leverages CVE is by Viertel et al. [14]. This research work uses an

existing token-based code clone detection tool, SourcererCC by Sajnani et al. [15]. This research was selected for study

in our review because the authors extend the SourcererCC tool to enable inter-project clone detection to find clones

between an external code repository and a project. This adaptation of the SourcererCC matches our proposed criteria

of using code cloning for security vulnerability detection. Like the evaluation of Vuddy by Kim et al. [13], this research

was also evaluated using open-source C/C++ programs collected from open-source repositories. Viertel et al. analyzed

the CVE database content of 20 reported vulnerabilities and detected their patterns in their C/C++ programs-based

dataset. The following approaches are coherent with the methodology of vulnerability code-pattern generation from a

vulnerability database and its detection in another large dataset to understand its evolution.

Chen et al. [16] uses Nicad code clone detection tool by Cordy and Roy [6] to generate android malware signatures

from a dataset of malicious android applications as a first step in their approach. Nicad provides a cross-clone detection

plugin to identify code clones in two different systems. Chen et al. leverages this plugin in the second step of their

Manuscript submitted to ACM

VOLCANO: Detecting Vulnerabilities of Ethereum Smart Contracts Using Code Clone Analysis

15

approach to detect malware and its variations in a dataset of benign applications. The authors evaluate their approach

by categorizing over 1000 android applications into 19 malware groups and generated malware signature of the 19

malware groups from a vulnerability extraction dataset. They proceed in detecting malware and its variations in a

dataset of benign applications with very low false positives and 96.88% accuracy of malware detection.

Finally, Liu et al. [17] proposes a new code clone detection tool, VFDetect, that follows the methodology of vulnerability

code pattern generation and identification in a target system. This approach uses vulnerability fingerprinting using

hashing of the feature sequences extracted from the diff files in a vulnerability database. This approach validates our

review criteria by detecting vulnerabilities in a target system by matching the fingerprint of the vulnerability generated.

The authors evaluate their approach by comparing the performance and efficiency of their approach with other code

clone detection tools such as, ReDeBug[18] and Vuddy[13]. This is the only research study in our review that compares

its results to other available state of the art tools.

6.2 Analysis and Discussion of Related Work

This Section discusses all studied approaches cited in the related work of this research, by following a criterion for

inclusion in our review. First, we have identified the criteria representing both the technique used as well as a baseline for

a comparison of target systems, purpose, and evaluation of the studied approaches. The main criteria of the considered

approaches are year of publication, code clone detection technique used, whether it is a novel approach, extension to an

existing approach or an application of an existing approach, purpose of the research and its evaluation.

Few research works targeting code cloning in Ethereum smart contracts were not included in the review as they did

not justify the defined criteria of approach inclusion. He et al. [19] and Kondo et al. [4] are two research studies that

investigated code clones in Ethereum smart contracts. However, none of these research studies highlights the security

vulnerabilities and their identification using code cloning.

Based on the used criteria, these approaches can be divided into three types. An built-in category with the support for

vulnerability detection incorporated in the proposed approach. A second category where an existing tool is extended to

include vulnerability detection by modifying the architecture of the underlying technology used. Lastly, a third category

that applies an existing code clone detection tool at different stages of a proposed framework to include vulnerability

detection possible.

For the type of code clones identified in the studied approaches, we observed that most approaches do not explicitly

mention it. However, only one work [13] specifies that their approach covers identification of all the types of code

clones.

In terms of suitability of the studied approaches to Ethereum smart contracts, we conclude that all the approaches

studied can be used to detect the vulnerabilities and its evolution in Ethereum smart contracts, however, we notice

that [16] uses Nicad [6] which is the only code clone detection tools discussed in this study that provides support for

Solidity programming language. Another point is that all the studied approaches have selected C/C++ programming

language as the target system in their evaluation.

7 THREATS TO VALIDITY

Threats to Internal Validity

One of the factors that can affect our results is that our approach, VOLCANO, is a signature-based vulnerability

detection method which can only detect instances of known vulnerabilities. Though our method can detect variants in

Manuscript submitted to ACM

16

Noama Fatima Samreen and Manar H. Alalfi

Table 10. Comparative table of the studied approaches using Code Clone Detection techniques for vulnerability detection

Authors/ Year

Code-Clone Detection Tech-
nique

Purpose

Kim et al./ 2017 [13] VUDDY- A scalable Approach
for Vulnerable Code Clone Dis-
covery

Viertel
2019[14]

et

al.

/

SourcererCC - Detecting Secu-
rity Vulnerabilities using Clone
Detection and Community
Knowledge

et

Chen
2015[16]

al.

/

Nicad - Detecting Android Mal-
ware Using Clone Detection

Liu et al. / 2017[17] VFDETECT: A Vulnerable Code
Clone Detection System Based
on Vulnerability Fingerprint

Increasing the scalability of vul-
nerability detection in a large
software system by reducing
the number of signature com-
parisons
Harnessing available example
source code of software vulner-
abilities, from a large-scale vul-
nerability database, which are
matched to code fragments us-
ing clone detection
Vulnerability signature gener-
ation using code clone detec-
tion in a vulnerable database
and identifying these vulnera-
ble code signatures and its vari-
ations in a generic database of
android applications
uses vulnerability fingerprint-
ing to match the pre-processed
code blocks in target project
with the fingerprint

Evaluation

Improved performance and ef-
ficiency of detecting vulnerable
clones.

Analyzed the CVE database con-
tent of 20 reported vulnerabili-
ties and detected their patterns
in open-source repositories of
C/C++ based projects

categorized over 1000 malicious
apps in 19 malware families
and detected vulnerabilities in
a benign applications dataset
with very low false positives
and high accuracy at 96.88%.

Evaluates by comparing results
from other code clone detec-
tion tools such as ReDeBug and
Vuddy

vulnerabilities, the extent of variations is limited to the threshold used for clone comparison. The vulnerability detection

in our method is based on clone clusters and to form a clone cluster, our detection tool requires at least two similar

code fragments. Thus, we have to eliminate some known vulnerabilities from the Vulnerability Dataset as we could not

find any clone cluster for those vulnerabilities in the Evaluation Dataset.

Threats to Construct Validity

The dataset analyzed in this research consisted of a subset of all the Solidity smart contracts deployed onto the Ethereum

main net that corresponds to ÐApps. In this paper we have established an empirical analysis on a dataset that is not

equally distributed in terms of various versions of Solidity programming language. The fact that some of the versions

of Solidity programming language contained higher number of smart contracts than others may have introduced a

measurement bias that can only be overcome with an even dataset that includes reasonably similar smart contracts

demographics for each version of Solidity programming language like the total number of smart contracts, their size and

complexity. We recognize that further research with an updated dataset may strengthen the vulnerabilities evolution

identified in our results.

Manuscript submitted to ACM

VOLCANO: Detecting Vulnerabilities of Ethereum Smart Contracts Using Code Clone Analysis

17

Threats to External Validity

The generalizability of our results can be affected by the fact that our dataset contains only a sub-set of smart contracts

from the Ethereum blockchain network. Our Vulnerability Dataset and Evaluation Dataset are not the most up-to-date,

and it only contains the smart contracts from January 2020 to December 2020.

8 CONCLUSION AND FUTURE WORK

Our research focuses on investigating the vulnerability classification, identification and evolution efficiently in Ethereum

smart contracts. This paper highlights the use of code clone detection techniques in this regard. This study provides a

review of the research status on use of code clone detection techniques as a replacement to the usual static analysis for

vulnerability identification. While filtering the approaches that use code cloning for generating vulnerability signature

from a vulnerability database, we have observed that few studies have been conducted concerning this topic. After

analyzing all the studied approaches, we were convinced that Ethereum smart contracts can benefit from code clone

detection techniques particularly in vulnerability signature generation and identification of its variations in different

versions of Solidity programming language. Therefore, following this literature review, we developed a framework that

use code clone detection technique for identifying vulnerabilities and their variations in smart contracts. We evaluated

VOLCANO on two datasets, one with confirmed vulnerabilities and another with approximately 50k random smart

contracts collected from the Etherscan[1]. This research provides promising results in the field of vulnerability evolution

and in the future, we would expand our Vulnerability Dataset to include known vulnerabilities from databases like

CVE[20] or OWASP[21] to detect potential vulnerabilities in Ethereum smart contracts.

REFERENCES
[1] “Etherscan home page,” Available: https://etherscan.io/. [Online]. Available: https://etherscan.io/
[2] “Ethereum home page,” Available: https://www.ethereum.org/. [Online]. Available: https://www.ethereum.org/
[3] A. Dika and M. Nowostawski, “Security vulnerabilities in ethereum smart contracts,” July 2018.
[4] M. Kondo, G. Oliva, Z. Jiang, A. E. Hassan, and O. Mizuno, “Code cloning in smart contracts: A case study on verified contracts from the ethereum

blockchain platform,” Empirical Software Engineering, vol. 25, 11 2020.

[5] “Solidity home page,” Available: https://solidity.readthedocs.io/en/v0.5.1/. [Online]. Available: https://solidity.readthedocs.io/en/v0.5.1/
[6] J. Cordy and C. Roy, “The nicad clone detector,” 06 2011, pp. 219–220.
[7] “Smartbugs repository,” Available: https://github.com/smartbugs/smartbugs/tree/master/dataset. [Online]. Available: https://github.com/smartbugs/

smartbugs/tree/master/dataset

[8] N. F. Samreen and M. H. Alalfi, “A survey of security vulnerabilities in ethereum smart contracts,” in Proceedings of the 30th Annual International

Conference on Computer Science and Software Engineering, ser. CASCON ’20. USA: IBM Corp., 2020, p. 73–82.

[9] A. P. C. Monteiro, “A study of static analysis tools for ethereum smart contracts,” 2019.
[10] “Smartcheck,” Available:https://github.com/smartdec/smartcheck. [Online]. Available: https://github.com/smartdec/smartcheck
[11] “Slither,” Available: https://github.com/crytic/slither. [Online]. Available: https://github.com/crytic/slither
[12] “Smartscan datasets,” Available:https://github.com/NoamaSamreen93/SmartScan-Dataset. [Online]. Available: https://github.com/NoamaSamreen93/

SmartScan-Dataset

[13] S. Kim, S. Woo, H. Lee, and H. Oh, “Vuddy: A scalable approach for vulnerable code clone discovery,” in 2017 IEEE Symposium on Security and Privacy

(SP), 2017, pp. 595–614.

[14] F. Viertel, W. Brunotte, D. Strüber, and K. Schneider, “Detecting security vulnerabilities using clone detection and community knowledge,” 07 2019,

pp. 245–252.

[15] H. Sajnani, V. Saini, C. K. Roy, and C. Lopes, SourcererCC: Scalable and Accurate Clone Detection.
Singapore: Springer Singapore, 2021, pp. 51–62.
[16] D. T. Chen J, Alalfi MH, “Detecting android malware using clone detection,” in JOURNAL OF COMPUTER SCIENCE AND TECHNOLOGY, 09 2015, p.

942–956.

[17] Z. Liu, Q. Wei, and Y. Cao, “Vfdetect: A vulnerable code clone detection system based on vulnerability fingerprint,” 10 2017, pp. 548–553.
[18] J. Jang, A. Agrawal, and D. Brumley, “Redebug: Finding unpatched code clones in entire os distributions,” 2012 IEEE Symposium on Security and

Privacy, pp. 48–62, 2012.

[19] N. He, L. Wu, H. Wang, Y. Guo, and X. Jiang, “Characterizing code clones in the ethereum smart contract ecosystem,” 05 2019.

Manuscript submitted to ACM

18

Noama Fatima Samreen and Manar H. Alalfi

[20] “Cve official website,” Available: https://www.cve.org/. [Online]. Available: https://www.cve.org/
[21] “Owasp top ten vulnerabilities,” Available: https://www.veracode.com/security/owasp-top-10. [Online]. Available: https://www.veracode.com/

security/owasp-top-10

[22] K. Ohno, N. Yoshida, W. Zhu, and H. Takada, “On the effectiveness of clone detection for detecting iot-related vulnerable clones,” CoRR, vol.

abs/2110.10493, 2021. [Online]. Available: https://arxiv.org/abs/2110.10493

[23] “Bitcoin home page,” Available: https://bitcoin.org/. [Online]. Available: https://bitcoin.org/
[24] “State of the dapps home page,” Available: https://stateofthedapps.com/. [Online]. Available: https://stateofthedapps.com/
[25] M. Saad, J. Spaulding, L. Njilla, C. A. Kamhoua, S. Shetty, D. Nyang, and A. Mohaisen, “Exploring the attack surface of blockchain: A systematic

overview,” CoRR, 2019.

[26] “Txl,” Available: http://txl.ca/. [Online]. Available: http://txl.ca/
[27] K. Wu, “An empirical study of blockchain-based decentralized applications,” 02 2019.
[28] G. Oliva, A. E. Hassan, and Z. Jiang, “An exploratory study of smart contracts in the ethereum blockchain platform,” Empirical Software Engineering,

vol. 25, 05 2020.

[29] M. di Angelo and G. Salzer, “Characterizing types of smart contracts in the ethereum landscape,” in Financial Cryptography and Data Security,
M. Bernhard, A. Bracciali, L. J. Camp, S. Matsuo, A. Maurushat, P. B. Rønne, and M. Sala, Eds. Cham: Springer International Publishing, 2020, pp.
389–404.

Manuscript submitted to ACM

