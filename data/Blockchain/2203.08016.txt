Formalising Decentralised Exchanges in Coq

Eske Hoy Nielsen !
Computer Science, Aarhus University

Danil Annenkov !
Computer Science, Aarhus University

Bas Spitters !
Computer Science, Aarhus University

Abstract

The number of attacks and accidents leading to signiﬁcant losses of crypto-assets is growing.
According to Chainalysis, in 2021, approx. $14 billion has been lost due to various incidents, and
this number is dominated by Decentralized Finance (DeFi) applications. In order to address these
issues, one can use a collection of tools ranging from auditing to formal methods. We use formal
veriﬁcation and provide the ﬁrst formalisation of a DeFi contract in a foundational proof assistant
capturing contract interactions.

We focus on Dexter2, a decentralized, non-custodial exchange for the Tezos network similar to
Uniswap on Ethereum. The Dexter implementation consists of several smart contracts. This poses
unique challenges for formalisation due to the complex contract interactions. Our formalisation
includes proofs of functional correctness with respect to an informal speciﬁcation for the contracts
involved in Dexter’s implementation. Moreover, our formalisation is the ﬁrst to feature proofs of
safety properties of the interacting smart contracts of a decentralized exchange. We have extracted
our contract from Coq into CameLIGO code, so it can be deployed on the Tezos blockchain.

Uniswap and Dexter are paradigmatic for a collection of similar contracts. Our methodology

thus allows us to implement and verify DeFi applications featuring similar interaction patterns.

2012 ACM Subject Classiﬁcation Security/Formal methods/Logic and Veriﬁcation

Keywords and phrases decentralised ﬁnance, smart contracts, proof assistants, formal veriﬁcation

1

Introduction

Decentralised Finance (DeFi) is an emerging technology that aims to remove third parties
in ﬁnancial transactions. DeFi crucially utilises distributed ledgers, such as blockchains.
The smart contract technology is built on top of the blockchain and forms a software layer
that allows for developing DeFi applications. One crucial property of smart contracts is
irreversibility, that is, the execution of a smart contract cannot be simply “cancelled” by one
of the parties, even though some of the contracts contain errors.

The interest in DeFi is growing, and so are the ﬁnancial losses due to hacker attacks.
According to Chainalysis [7], approximately $14 billion was lost in 2021 in cryptocurrency-
related crimes, including hacker attacks. Many of these cases are associated with DeFi
applications and quite a few consist of simple programming mistakes. So, it is important
that the software implementing DeFi is bug- and exploit-free.

Decentralised exchanges (DEXs) are one of the important applications of the DeFi
technology. They enable the exchange of digital assets without involving an intermediary.
Many DEXs are based on automated market makers (AMMs) — autonomous protocols that
deﬁne prices of the assets involved in the exchanges. AMMs are implemented as smart
contracts deployed on a blockchain; see [15] for an overview. In their terminology, we are
focusing on preventing middleware attacks, which include correct handling of reentrancy,
exceptions and mathematical operations.

In this work, we present an implementation methodology for developing and verifying
decentralised exchanges in Coq exempliﬁed by the Dexter2 exchange for the Tezos blockchain.

2
2
0
2

r
a

M
1
1

]

O
L
.
s
c
[

1
v
6
1
0
8
0
.
3
0
2
2
:
v
i
X
r
a

 
 
 
 
 
 
2

Formalising Decentralised Exchanges in Coq

Dexter2 is an improved version of the vulnerable Dexter1 protocol. The exchange is based
on the Uniswap v1 exchange protocol for Ethereum. Our Coq development follows the
original Dexter2 implementation written in CameLIGO closely. CameLIGO is a functional
programming language for the Tezos blockchain. A simpliﬁed version of this hand-written
implementation is deployed and used in the liquidity baking feature of the Tezos Granada
protocol. Hence, the protocol is an integral part of the Tezos blockchain.

The smart contract execution model used by Tezos and a number of modern blockchains1
is based on the message passing/actor model [9]; this is partially as a reaction to the problems
with reentrancy on the Ethereum blockchain. One of the biggest challenges in the veriﬁcation
of DEXs is the interaction of the smart contracts involved in the DEX, as it not only
requires reasoning about state invariants for a single contract but also about inter-contract
invariants. So far, such invariants have not been mechanically veriﬁed for this execution
model. The Mi-Cho-Coq framework was used to prove properties for contract functions in
isolation, but contract interactions were only subjected to randomised testing2. The main
Dexter2 contract was also veriﬁed for functional correctness by Runtime Veriﬁcation using
the (non-foundational) semi-automatic veriﬁer of the K-framework3. Safety properties were
stated, but not machine-checked.

The Ethereum blockchain uses a diﬀerent execution model which resembles ordinary
procedure calls in imperative programming languages. This, however, is a deceiving analogy,
because any contract being called is potentially adversarial, which opens the door for many
potential vulnerabilities. Most work on the veriﬁcation of smart contracts focus on single
contracts. Recent work on veriﬁcation [5] of smart contracts written in Ethereum’s Vyper
language, a simple language designed with security in mind, proves some properties of
interacting contracts. However, their example of a DEX contract is simpler and does
not feature all the interactions considered in our work. Their other examples show that
implementing communicating contracts is hard and requires knowledge of common pitfalls of
the Ethereum execution model.

Contributions

We present a methodology of developing DEX applications from implementation in Coq
to executable blockchain code.
As an example, we provide a full executable implementation of Dexter2 in Coq.
We prove functional correctness and important inter-contract invariants of the contracts
comprising Dexter2.
We extract an implementation in CameLIGO using ConCert’s veriﬁed extraction frame-
work based on MetaCoq.
During the formalisation, we have found minor mismatches between the informal spe-
ciﬁcation and the Dexter2 implementation. Since both were written by expert teams, we
believe this merely highlights the fact that speciﬁcation of programs is best done hand in
hand with formalisation.

Our contribution is available as part of the ConCert framework (https://github.com/AU-
COBRA/ConCert/tree/itp2022) and consists of approx. 5K LOC (implementation, proofs

1 E.g. Concordium, Æternity
2 https://research-development.nomadic-labs.com/follow-up-on-the-verification-of-

liquidity-baking-smart-contracts.html

3 https://runtimeverification.com/blog/dexter-2-s-formal-verification

E. H. Nielsen, D. Annenkov and B. Spitters

3

Figure 1 The ConCert framework

and machinery for reasoning about communicating contracts), plus ﬁxes to CameLIGO
extraction and the execution model. In the text, we refer to our formalisation using the
following link format:
path/to/file.v:lemma_name. The path starts at the root of the project’s
repository, and the optional lemma_name parameter refers to a deﬁnition in the ﬁle.

2

The ConCert Framework

Before explaining the details of our methodology, we ﬁrst introduce the ConCert framework,
since our work crucially uses its features. The ConCert framework is implemented in
the Coq proof assistant. The underlying foundation of Coq is the Calculus of Inductive
Constructions [6] (CIC) — a dependently typed functional programming language allowing
for expressing both programs and program properties. Coq also features proof automation
through tactics, extension through plugin development and meta-programming through
MetaCoq [11]. Since Coq comes with a functional programming language it is natural to
apply it for veriﬁcation of functional smart contract languages. It can be done by embedding
a language to Coq [13, 3]4 or extracting a program from Coq formalisation [8, 12, 1].

In the present work, we focus on veriﬁcation and extraction functionality of the ConCert
framework [3, 2]. We give a very brief overview of ConCert focusing on the smart contract
execution layer, and smart contract extraction.

2.1 Overview

The overview of the ConCert framework is presented in Figure 1. We start by developing a
smart contract as a function in Coq using the ConCert infrastructure. For a smart contract,
deﬁned as a function, we can state and prove functional correctness properties. Since smart
contracts are just ordinary functions that use blockchain-speciﬁc data types deﬁned in
ConCert, reasoning about them is as convenient as about any other function in Coq.

One of the key features of the ConCert framework is its support for reasoning about the
interaction between several smart contracts and the blockchain. That is, one can state and
prove properties about contract execution traces. Such proofs crucially use the execution
layer to reason about interacting contracts (see more details in Section 2.2), which enables us

4 github.com/formal-land/coq-of-ocaml

λCIC λ□CameLIGOLiquidityElmRustoptimiseeraseprintextract typesTConCertMetaCoqThe Coqproof assistantquoteTarget languagesFunctional correctnessContract interactionsExecution layerSmart contractsCertifying transformationsExtraction configurationRemappingpre-process4

Formalising Decentralised Exchanges in Coq

to capture properties beyond the mere functional correctness of a single contract invocation
(see Section 4.3.2).

One can obtain an executable implementation of the veriﬁed code in one of the supported
smart contract languages through code extraction. This code-generation procedure has
strong correctness guarantees based on a small trusted computing base of Coq, MetaCoq
and the pretty-printers into the target languages.

2.2 Smart Contract Execution Layer

The execution layer models parts of an account-based blockchain infrastructure for smart
contract execution. The account-based model was introduced by Ethereum as an alternative
to Bitcoin’s UTXO model. Our model allows us to reason about contract execution traces
and hence temporal properties of interacting smart contracts. Smart contracts in ConCert
use a similar model as a number of blockchains where a contract consists of two functions
(we use Coq syntax for function signatures):

init : Chain → ContractCallContext → Setup → option State

The initialisation function is called after the contract is deployed on the blockchain. The ﬁrst
parameter of type Chain gives access to data about the blockchain (e.g. current chain height).
The ContractCallContext parameter provides data about the current call (e.g. caller address,
amount sent to the contract). Setup represents initialisation parameters.

receive : Chain → ContractCallContext → State → option Msg

→ option (State ∗ list ActionBody)

The receive function represents the main functionality of the contract that is executed for
each call to the contract. Chain and ContractCallContext are the same as for init. The
parameter of type State is the current state of the contract; Msg is a user-deﬁned type of
messages that the contract accepts (the entrypoints of the contract). The result of a successful
execution is a new state and a list of actions represented with ActionBody. The actions can
be transfers, calls to other contracts (including itself), and contract deployments.

Both receive and init are ordinary Coq functions, making them convenient to reason
about. However, reasoning about the contract functions in isolation is not quite suﬃcient.
One call to receive potentially emits more calls, which can create complex call graphs
between deployed contracts. The execution model is given by an execution trace ChainedList
— the reﬂexive-transitive closure of the proof-relevant ChainStep relation, which essentially
captures the addition of a single block to the blockchain. In this step, any actions (like
contract calls) are executed. The type of traces ChainedList is deﬁned inductively and thus
comes with an induction principle. ConCert also features a contract_induction principle
that is more convenient for reasoning for many common properties on execution traces of
a single contract. ConCert provides two runnable implementations of the execution model
corresponding to depth-ﬁrst and breadth-ﬁrst orders of contract call execution. For more
details about the internals of the execution layer see [9]. The Tezos blockchain utilises the
depth-ﬁrst execution order. However, the ConCert model is not committing to a particular
execution order without additional assumptions. That means that one can obtain stronger
results for many properties, namely that a property holds regardless of the execution order
of the subsequent calls.

2.3 Code extraction

The Coq proof assistant provides extraction to OCaml, Haskell and Scheme out-of-the-
box. However, it does not support languages for smart contracts. Moreover, the standard

E. H. Nielsen, D. Annenkov and B. Spitters

5

extraction in Coq is implemented in OCaml and is not veriﬁed. Therefore, in order to obtain
an implementation suitable for deploying on a particular blockchain, the ConCert Framework
provides code extraction.

ConCert’s extraction uses the veriﬁed erasure procedure of the MetaCoq framework [11]
that provides a proof of computational soundness of the important erasure step of extraction.
The erasure procedure takes a Coq term λCIC and replaces computationally-irrelevant
parts of a Coq term with a special box node (cid:3) and produces an untyped representation
λ(cid:3). On top of this, ConCert adds extraction of typing information leading to the λT
(cid:3)
representation. The λT
(cid:3) terms are used as an intermediate representation, for which ConCert
implements certiﬁed optimisations and pretty-printers to several target languages. ConCert
also provides a proof-generating (certifying) pre-processing step featuring inlining and η-
expansion (see [1, Section 5.2]). In this work, we focus on extraction to CameLIGO —
a functional programming language for the Tezos blockchain. The details of conﬁguring
extraction are given in Section 4.4.

3

The Dexter Exchange

In order to demonstrate our approach, we implement and verify the Dexter Exchange
for the Tezos blockchain. Dexter features implementations patterns, such as delegating
the token bookkeeping functionality to a separate contract, that are common for multi-
contract applications. Moreover, the security audits, together with the various veriﬁcation
and speciﬁcation projects, make Dexter one of the most carefully studied smart contracts.
It is thus a good target for formalisation.
In this section, we describe the CameLIGO
implementation of the exchange. We provide the details of how we encode it in ConCert
in Section 4.

Dexter is an open-source, non-custodial, decentralized exchange on the Tezos blockchain
developed by CamelCase.
It allows exchanging tez (the currency of Tezos, also known
by its ISO-4217 code XTZ) with FA1.2 tokens. FA1.2 is a fungible token standard for
Tezos smart contracts. In the present work, we focus on Dexter25, which is a complete
rewrite of the original Dexter contract, written in CameLIGO. It improves upon the original
version by (i) ﬁxing fatal security ﬂaws6; (ii) adding a separate liquidity token contract;
(iii) adding support for FA2 tokens. FA2 is a newer token contract standard for Tezos.
Dexter2 allows trading both FA1.2 and FA2 tokens. Dexter2 delegates the responsibility
of tracking ownership of the exchange’s assets to a separate liquidity token contract. This
means that the Dexter2 exchange consists of three contracts: the main exchange contract
with which users interact, the token contract holding the traded tokens, and a liquidity token
contract. Dexter2 enables trades directly between two token types, such trades involve two
diﬀerent instances of Dexter2, i.e. a total of six diﬀerent interacting smart contracts. This
interaction between multiple contracts makes safety proofs non-trivial. Figure 2 illustrates
the interactions between the contracts when a user updates the token pool and adds liquidity.

3.1 The Dexter2 Smart Contracts

In this section, we introduce the three contracts in the Dexter2 exchange. The ﬁrst smart
contract is the token contract which implements the token that users can exchange using

5 https://gitlab.com/dexter2tz/dexter2tz/-/tree/master/
6 https://research-development.nomadic-labs.com/a-technical-description-of-the-dexter-

flaw.html

6

Formalising Decentralised Exchanges in Coq

Figure 2 Dexter2 features complex interaction patterns: callbacks, messages to multiple contracts

Dexter2. This contract can be either an FA1.2 or FA2 token contract. In this work, we do
not verify the token contract, since Dexter2 is designed to work with many diﬀerent token
contracts. Thus, there is limited gain in verifying a single token implementation.

3.1.1 Main contract

The second contract is the Constant Product Market Maker contract — an instance of an
automated market maker. This is the main contract, that users use to trade between tokens
and tez. It implements a constant product market exchange, which is a market where a
currency of type α can be traded for a currency of type β. The market reserves are denoted
as Rα > 0 and Rβ > 0. The idea of a constant product market exchange is that the value of
the market k = RαRβ remains constant when the fee of trading is 0, and can only increase
when the fee is positive. Each Dexter2 main contract can only be linked with one token
contract.

The main contract has eleven entrypoints. The addLiquidity and removeLiquidity entry-
points allow liquidity owners to deposit and withdraw from the reserves. Users are required to
deposit and withdraw an equivalent value of both currencies. The xtzToToken, tokenToToken
and TokenToXtz entrypoints allow users to trade between tez and tokens at a ﬁxed percentage
fee. The exchange rates are calculated dynamically at each invocation based on current
reserves. The main contract tracks the amount of tez, tokens, and liquidity tokens itself,
instead of communicating with the other contract, this results in lower gas fees and makes the
contract less dependent on execution order. Because of this, the number of tokens can drift
from the actual amount of tokens owned. Therefore, Dexter2 allows updating this counter
manually through the updateTokenPool entrypoint, which will call getBalanceOf on the token
contract. The setBaker, setManager, and setLqtAddress entrypoints are self-explanatory. A
baker is the Proof-of-Stake analogue of a miner in a Proof-of-Work protocol. Smart contracts
can delegate the power associated to their stake to bakers. The contract also has a default
entrypoint that can be used to donate tez to the contract.

3.1.2 Liquidity token contract

The third contract is the liquidity token contract. To allow trading, the main contract must
have a reasonable reserve of both currencies. To avoid the deployer of the exchange having
to put in this large reserve, Dexter2 incentivises users to deposit currency in the reserve.
The liquidity token contract is used to track ownership of the reserves. The liquidity tokens

CPMM contractadd_liquidityLiquidity token contractmint_or_burnFA2 tokencontractupdate_token_poolbalance_ofupdate_token_pool_internalupdate_operatorstransferE. H. Nielsen, D. Annenkov and B. Spitters

7

correspond to shares of the main contract’s assets. The liquidity token contract is an FA1.2
token contract with an extra entrypoint for minting and burning tokens.

Being an instance of the FA1.2 standard, the liquidity token contract includes ﬁve
entrypoints. These entrypoints enable transferring tokens, giving other users access to
manage your tokens, and functions for inspecting the contracts state such as getBalance.
The contract also has a mintOrBurn entrypoint which only the main contract may call. This
entrypoint is used to mint new liquidity tokens when users deposit assets and burn when
they withdraw.

4

Formalisation

We use the following methodology throughout our development. First, we implement contracts
comprising Dexter2 as Coq functions using the ConCert infrastructure. For these functions,
we verify functional correctness properties (properties of a single function call). Next, we state
and prove single-contract invariants independently. After that, we connect the individual
invariants through a theorem relating incoming and outgoing messages of the interacting
contracts to prove inter-contract invariants. Finally, we use the extraction pipeline of ConCert
to obtain a fully functional implementation of the smart contracts.

4.1 Implementation in ConCert

To model a smart contract in ConCert, we can either precisely embed it, or consider the
extracted smart contract. For Dexter2, we model the existing contract approximately, but
we believe faithfully. We outline some diﬀerences in the sections dedicated to the contracts
comprising Dexter2. We implement the contracts described in Section 3.1 as Coq functions
following the signatures enforced by the ConCert framework, as described in Section 2.2. That
is, we implement the type of messages (entrypoints), the state type, and the initialisation
setup for each contract. We then extract veriﬁed CameLIGO code, which behaves similar
to the original contract. This is currently the most convenient way to obtain fully veriﬁed
contracts on-chain.

4.1.1 Liquidity Token Contract

execution/examples/dexter2/Dexter2FA12.v.
Coq implementation:
The entrypoints are modelled using an inductive Msg type with a constructor for each
entrypoint.

Inductive Msg :=

| msg_mint_or_burn : mintOrBurn_param → Msg
| msg_get_total_supply : getTotalSupply_param → Msg
...

The contract’s state is represented using record types of Coq.

Record State := build_state { tokens : FMap Address N; allowances : FMap (Address ∗ Address) N;

admin : Address; total_supply : N}.

Where FMap is the type of ﬁnite maps (key-value maps), Address is part of the ConCert
infrastructure, and N is the type of binary natural numbers in Coq. In Coq, one can access
the ﬁelds of a record using the following projection syntax: state.(allowances).

The liquidity token contract contains several view entrypoints, which are entrypoints that
return part of the contract’s state without modifying the state. However, neither ConCert’s
execution model nor CameLIGO allow entrypoints to return data. Dexter2 uses callbacks to

8

Formalising Decentralised Exchanges in Coq

return the data to the sender. In CameLIGO this is straightforward to implement. However,
in ConCert, all entrypoints are bundled together in one inductive deﬁnition, which makes
modelling callbacks hard since the view entrypoint cannot take a name of a particular return
entrypoint as input. We get around this problem by deﬁning a FA12ReceiverMsg type that
contracts must use to be able to receive callbacks. It is deﬁned with one constructor for each
callback and a other_msg : Msg’→FA12ReceiverMsg constructor such that contracts can use it
to wrap their existing Msg type.

Inductive FA12ReceiverMsg {Msg’ : Type} ‘{Serializable Msg’} :=

| receive_total_supply : N → FA12ReceiverMsg
...
| other_msg : Msg’ → FA12ReceiverMsg.

This approach, however, is not as ﬂexible as in CameLIGO. It enforces the contracts
interacting with the Dexter implementation to use particular data types provided by us,
while in the original CameLIGO code it is suﬃcient to have entrypoints with certain names
and signatures. However, those restrictions do not aﬀect the safety properties we prove.

Another diﬀerence between CameLIGO and the functional language of Coq is that
CameLIGO allows throwing errors, i.e. stopping executing at any point in the code without
returning data. Since functions in Coq are pure, we follow the standard approach and use
the option monad to faithfully model this behaviour. The only diﬀerence is that we do not
provide the user with an error message in the case of failure. However, that does not aﬀect
the safety of the exchange.

4.1.2 Main Contract

execution/examples/dexter2/Dexter2CPMM.v.
Coq implementation:
Similarly to the liquidity token implementation, we implement all entry points of the main
contract as an inductive type with a constructor for each. The state is also implemented
using records.

Record State := build_state { tokenPool : N; xtzPool : N; lqtTotal : N;

selfIsUpdatingTokenPool : bool; lqtAddress : Address; ... }.

The source implementation of the main contract uses compile-time ﬂags to support both
FA1.2 and FA2 token standards. However, this means that the compiled code will only
support one or the other. In this work, we choose only to model the main contract with FA2
communication.

The main contract needs to be able to receive callbacks from FA2. The FA2 implementation
uses callbacks the same way as the liquidity token contract, meaning that the message type
for the main contract must be of type FA2ReceiverMsg.

Definition Msg := @FA2Token.FA2ReceiverMsg BaseTypes DexterMsg _.

The setBaker entrypoint allows delegating the contract’s balance to a baker. ConCert
does not model bakers, so this part of the implementation is omitted. Therefore it is not
possible to fully prove functional correctness of this entrypoint.

In Figure 3 we present an excerpt from the implementation. The implementation uses
option monad and custom division and subtraction operations. CameLIGO, like many other
languages, throws runtime errors from division by zero. Moreover, its subtraction operator
implicitly converts from natural numbers to integers, such that the subtraction of two natural
numbers produces a result of type integer. For other types, subtraction of positive numbers
will throw a runtime error if the result is negative. The main contract implementation relies

E. H. Nielsen, D. Annenkov and B. Spitters

9

Definition xtz_to_token (chain: Chain) (ctx: ContractCallContext)

(state: State) (param: xtz_to_token_param) : result :=

do _ ← throwIf state.(selfIsUpdatingTokenPool) ;
do _ ← throwIf (param.(xtt_deadline) ≤? chain.(current_slot))%nat ;
do tokens_bought ← div

((amount_to_N ctx.(ctx_amount)) ∗ 997 ∗ state.(tokenPool))
(state.(xtzPool) ∗ 1000 + ((amount_to_N ctx.(ctx_amount)) ∗ 997)) ;

do _ ← throwIf (tokens_bought <? param.(minTokensBought)) ;
do new_tokenPool ← sub state.(tokenPool) tokens_bought ;
let new_state := state<| xtzPool := state.(xtzPool) + (amount_to_N ctx.(ctx_amount)) |>

<| tokenPool := new_tokenPool |> in

let op := token_transfer state ctx.(ctx_contract_address) param.(tokens_to) tokens_bought in

Some (new_state, [op]).

Figure 3 xtz_to_token implementation

on these runtime errors to ensure the failure of entrypoints on inputs that would break safety.
Definition sub (n m : N) : option N := do _ ← throwIf (n <? m) ; Some (n − m).
Definition div (n m : N) : option N := do _ ← throwIf (m =? 0) ; Some (n / m).

4.2 Proof Techniques

Previous works on veriﬁcation of other smart contracts in ConCert have been limited to
properties involving incoming or outgoing traﬃc from arbitrary contracts, and have focused
on the perspective of one contract. To fully prove safety of interacting contracts this is
not enough. In this section, we discuss how we can achieve proofs of properties reasoning
about the interaction between two speciﬁc smart contracts and relating their state and traﬃc.
We will limit the scope to only considering invariants over two contract states. However,
the methodology should be applicable for reasoning about invariants over any number of
contracts.

Typically when proving an invariant over the state, incoming or outgoing actions, one
would use the contract_induction tactic provided by ConCert. This allows us to induct
over chain traces to prove properties that always hold on the contract’s state and actions.
However, contract_induction does not immediately work when reasoning about interacting
contracts. Since ConCert fully formalised the execution model of a blockchain we would be
able to prove the property by doing induction over chain traces. However, inducting over
chain traces usually gives long and complex proofs even for simple properties, because we
have to deal with weak types, (de)serialization, and low-level details of contracts execution.
Here we present an approach to use contract_induction to prove smaller isolated invariants
over single contracts and combine them to prove invariants over any number of contracts
modularly. For contracts A and B we consider proposition P of the following form:

P chainHeight currentSlot finalizedHeight

addrA addrB deployInfoA deployInfoB
stateA stateB balanceA balanceB
outActsA outActsB outTxsA outTxsB
incCallsA incCallsB

Here outActsA are actions emitted by A that have not been executed yet, outTxsA are actions
emitted by A that have been executed, and incCallsA are incoming calls executed by A. The
general idea is to prove the property from each contract’s perspective and then compose
the two. Let R be a proposition about the ﬁrst contract and Q be a proposition about the
second contract. If R ∧ Q → P, then we can use contract_induction as we normally would
to prove both R and Q. We observe that a contract’s state is uniquely determined by the
initial information given on deployment and all calls executed by the contract, since contracts

10

Formalising Decentralised Exchanges in Coq

cannot inspect or modify the state of another contract. That is, any part of a contract’s state,
outgoing actions, or balance can be expressed as a function f deployInfo incCalls. This
means we can eliminate both contracts state from P and reduce the problem to reasoning
about lists of incoming and outgoing messages from the two contracts. To be able to reason
about properties on messages sent between the two contracts we need to be able to relate
the messages sent with the messages received by the other contract.

Theorem 1 (Incoming equal to outgoing).

execution/theories/InterContractCommunication.v:incomming_eq_outgoing

Let π be a reachable blockchain state with contracts A and B deployed. Let TinB be the set
of incoming calls from A to B in the execution trace π, and let ToutA be the set of outgoing
calls from A to B in the execution trace π. Then TinB = ToutA.

We observe that Theorem 1 should hold for any blockchain with message passing execution
model. This allows us to relate the messages sent between the two contracts. We prove this
equality once and for all for any pair of contracts.

4.3 Properties

4.3.1 Functional Correctness

The developers of Dexter2 provide detailed informal speciﬁcations of both the liquidity and
main Dexter2 contracts7. We formalise both informal speciﬁcations and prove our contract
implementations to be functionally correct w.r.t the speciﬁcation, except for a few exceptions.
Due to the ConCert limitations, we do not prove that the setBaker entrypoint emits the
correct actions, and do not prove that the contract throws correct error messages.

To prove the implementations correct we prove the following three properties for each

entrypoint:

The state is updated correctly
The entrypoint emits the correct operations
Necessary and suﬃcient conditions for successful execution.

In contrast to proving state invariants and inter-contract communication properties proving
correctness of entrypoints is straightforward, since the contracts are implemented as functions
in Coq. The proofs are largely automated using custom tactics.

We found several mismatches between the informal speciﬁcation and the Dexter2 im-
plementation and found minor contradictions in the informal speciﬁcation. The ﬂaws in
the informal speciﬁcation (but not the implementation) would have led to vulnerabilities
similar to those found in Dexter1. We reached out to the developers who conﬁrmed that the
informal speciﬁcation was incorrect. Since both the implementation and the speciﬁcation
were written by expert teams, we believe this merely highlights the fact that speciﬁcation
of programs is best done hand in hand with formalisation. However, it is important that
informal speciﬁcation, implementation, and veriﬁcation are not all done by the same team.

4.3.2

Inter-Contract Communication

We demonstrate the inter-contract invariant proof methodology presented in Section 4.2 by
proving two key safety properties of Dexter2:

7 https://gitlab.com/dexter2tz/dexter2tz/-/blob/master/docs/informal-spec/dexter2.md

E. H. Nielsen, D. Annenkov and B. Spitters

11

Consistency between main contract state and tez balance8.
Consistency between main contract state and liquidity token contract state.

Consistency between the states and balances is critical as exchange rates would be calculated
incorrectly otherwise. Related works on Dexter2 formalisation have considered the same
safety properties but did not provide machine checked proofs.

Tez pool correct

In the Dexter2 exchange, the exchange’s tez is held by the main contract. The contract
manually tracks its balance of tez in the xtzPool variable of its state. To ensure that exchange
rates are calculated correctly it is important that this variable reﬂects the actual amount of
tez that the contract owns. Contract state is updated before emitted transfers are executed,
thus it is not possible to prove the variable and the actual balance equal at all times. However,
it should be the case that they are consistent after each chain of contract calls.

Theorem 2 (Tez pool correct).

execution/examples/dexter2/Dexter2CPMM.v:contract_balance_correct

Let π be a reachable blockchain state with the main contract deployed. Let b be the contract
balance, and let T be the set of transactions from the main contract that is in the execution
queue of π. Let x be the initial amount of tez given to the contract during deployment. If
x = 0 and T = ∅ (no pending transfers) then xtzPool is equal to the contract balance b.9

In Coq, we ﬁrst prove a more general version of the theorem stating that xtzPool is equal to
the contract balance minus any pending transfers. This is proven by induction on execution
traces. From this Theorem 2 follows trivially. Using the theorem we can further prove that
Dexter2 never attempts to transfer more tez than it has.

Liquidity supply correct

Liquidity tokens are stored in the liquidity token contract of the Dexter2 exchange. However,
the main contract needs to know the total amount of liquidity tokens when calculating
exchange rates. To decrease gas fees the main contract tracks this number itself instead of
requesting it from the liquidity token contract. Therefore, it is critical that the counters in
the two states are consistent. Note also that the pattern of delegating token management to
a separate token contract appears in other settings (cf. auction_token example in [5]). The
same implementation and proof techniques are applicable for such contracts as well.

We would like to formulate the property modularly, meaning that it should hold for any
liquidity token satisfying certain interface. The fact that Coq is based on dependent types
allows us to deﬁne the token interface along with a property, that it must satisfy in order for
the inter-contract invariant to hold. We deﬁne the required property for any given liquidity
token contract L with compatible entry points and state as follows:

Deﬁnition 1 (Liquidity token condition).

execution/examples/dexter2/Dexter2FA12.v:LqtTokenInterface

8 We use tez to denote the native currency of the modelled blockchain as opposed to tokens that can

represent various assets

9 Note that we do not assume explicitly that the initial value of xtzPool is zero. In ConcCert, the init
function takes care of generating valid initial state with zero xtzPool. The extracted code features a
wrapper that allows for initialising with valid data.

12

Formalising Decentralised Exchanges in Coq

For any π reachable blockchain state with L deployed at address aL. Let aM be the address of
the main contract recorded in the initial state of L. Let CM be the set of executed calls from
aM to aL in the execution trace π, let lL be the number of liquidity tokens, and let iL be the
initial amount of liquidity tokens. Then lL = iL +sum(map mintedAndBurnedT okens CM ),
that is the number of tokens is the initial supply plus minted tokens minus burned tokens.

Now, given any implementation of the liquidity token that satisﬁes Deﬁnition 1, we prove

the liquidity supply invariant in Theorem 3.

Theorem 3 (Liquidity supply correct).

execution/examples/dexter2/Dexter2CPMM.v:lqt_pool_correct_interface

Let π be a reachable blockchain state with the main contract deployed at address aM and any
compatible liquidity token contract that satisﬁes Deﬁnition 1 deployed at address aL. Let T
be the set of transactions from aM to aL in the execution queue of π. Let lM be the liquidity
token counter in the main contracts’ state and let lL be the actual amount of liquidity tokens
in the liquidity token contract. Let iM and iL be the initial amounts of liquidity tokens in the
two contracts after deployment. If the contracts are correctly paired, iM = iL, and T = ∅
then the contracts have consistent state lM = lL.

In Coq, the invariant is formulated the following way:

Definition lqtTotal_total_supply_invariant
(* Given a liquidity token interface *)
(i_lqt_contract : LqtTokenInterface) :=
forall bstate caddr_main caddr_lqt (trace : ChainTrace empty_state bstate),

(* main contract deployed at aM *)
env_contracts bstate caddr_main = Some (contract : WeakContract) →
(* liquidity token deployed at aL *)
env_contracts bstate caddr_lqt = Some (i_lqt_contract.(lqt_contract) : WeakContract) →
exists state_main state_lqt depinfo_main depinfo_lqt,

contract_state bstate caddr_main = Some state_main ∧
contract_state bstate caddr_lqt = Some state_lqt ∧
deployment_info Setup trace caddr_main = Some depinfo_main ∧
deployment_info Dexter2FA12.Setup trace caddr_lqt = Some depinfo_lqt ∧
(* initial amount iM *)
let initial_tokens_main := lqtTotal_ (deployment_setup depinfo_main) in
(* initial amount iL*)
let initial_tokens_lqt := initial_pool (deployment_setup depinfo_lqt) in
(state_main.(lqtAddress) = caddr_lqt →
state_lqt.(admin) = caddr_main →
(* iM = iL*)
initial_tokens_main = initial_tokens_lqt →
(* set of transactions from aM to aL T = ∅*)
filter (actTo state_main.(lqtAddress)) (outgoing_acts bstate caddr_main) = [] →
(* lM = lL *)
state_main.(lqtTotal) = state_lqt.(total_supply)).

We prove Theorem 3 using the method described in Section 4.2. We ﬁrst prove a single-
contract invariant describing the main contract’s liquidity counter in terms of the contract’s
incoming and outgoing messages.

Theorem 4 (Main contract liquidity counter correct).

execution/examples/dexter2/Dexter2CPMM.v:lqt_total_correct

Let π be a reachable blockchain state with the main contract deployed at address aM . Let aL
be the address of the liquidity token contract that the main contract is paired with. Let TL be
the set of executed transactions from aM to aL in the execution trace π, and let T be the set
of transactions from aM to aL in the execution queue of π. Let lM be the main contract’s
liquidity token counter and let iM be the initial amount of liquidity tokens. Then lM =
iM + sum(map mintedAndBurnedT okens TL) + sum(map mintedAndBurnedT okens T )

E. H. Nielsen, D. Annenkov and B. Spitters

13

Definition TT_remap_arith :=
remap <%% Z %%> "int"
[
; remap <%% N %%> "nat"

; remap <%% N.add %%> "addN"
; remap <%% N.sub %%> "subNTruncated"
; remap <%% N.modulo %%> "moduloN"
...
; remap <%% Z.add %%> "addInt"
; remap <%% Z.sub %%> "subInt"
; remap <%% div %%> "divN_opt"
...
(* conversion [N] → [Z] *)
; remap <%% Z.of_N %%> "z_of_N"
...

[ @inline] let addN (a: nat ) (b: nat ) = a + b

let subNTruncated (n: nat) (m: nat) : nat =

if n < m then 0n else abs (n−m)

let moduloN (n: nat) (m: nat) : nat =

match ediv n m with
| Some (_,r) → r
| None → 0n

let divN_opt (n: nat) (m: nat) : nat option =

match ediv n m with
| Some (q,_) → Some q
| None → None

].

let z_to_N (i: int) : nat = if i < 0 then 0n else abs i

Listing (1) Remapping

Listing (2) CameLIGO prelude

Figure 4 Remapping deﬁnition for extraction

Now, the proof Theorem 3 follows from using Theorem 1 that connects the two single-
contract invariants: Theorem 4 and the liquidity token condition. Having Theorem 3, we
can separate liquidity token implementation from the main contract. In our development, we
show that the liquidity token described in Section 4.1.1 indeed satisﬁes the liquidity token
condition. The statement that connects all implementation pieces together is given by

execution/examples/dexter2/Dexter2CPMM.v:lqt_pool_correct_lqt_fa12

4.4 Extraction

In order to produce an executable implementation that can be deployed on an actual
blockchain, one needs to generate smart contract code. A well-known technique called code
extraction can be used for that purpose. However, the standard code extraction targets
conventional (mostly functional) programming languages and not the languages for smart
contracts.

We utilise the extraction pipeline of ConCert (Section 2) in order to obtain source
code for the contracts comprising Dexter2 in the Coq proof assistant. We choose to use
CameLIGO as a target language since it is supported by the Tezos blockchain. CameLIGO
is a functional smart contract language from LIGO family of languages used as high-level
user-friendly programming languages for the Tezos blockchain. CameLIGO uses the syntax
of OCaml, but has some restrictions with respect to data types and recursive functions; see
[1, Section 5.3]. Code extraction to smart contract languages is somewhat diﬀerent from
extraction to conventional languages. Smart contracts utilise the blockchain infrastructure
that is accessible as part of their runtime. Therefore, some deﬁnitions from the execution
layer of ConCert must be remapped to their counterparts in the target blockchain. Moreover,
one has to carefully remap arithmetic operations to primitives of a target language since
extracting Coq representations would be either ineﬃcient or impossible due to restrictions
on data types.

We summarise our extraction eﬀort in the following points.

We update CameLIGO pretty-printing to support polymorphic deﬁnitions. This feature
was added recently and was not supported in ConCert before.
We specify a translation table that remaps Coq arithmetic operations for binary integer
numbers Z and binary natural numbers N, operations on ﬁnite maps provided by the
std++ library, and blockchain-speciﬁc infrastructure to CameLIGO.

14

Formalising Decentralised Exchanges in Coq

We extract the main contract and the liquidity token contract of Dexter2 to CameLIGO
code.

The important feature of the extraction functionality provided by ConCert is the ability
to run the whole extraction pipeline inside Coq. This feature allows us to keep the trusted
computing base smaller (e.g. the standard extraction is written in OCaml and executed
outside of the proof assistant).

Figure 4 presents a fragment of the remapping for numeric data types and numerical
operations along with corresponding hand-written CameLIGO deﬁnitions that we call the
prelude. We use remap <%% coq_def %%> "cameligo_def" to produce an entry in the transla-
tion table, where the <%% coq_def %%> notation uses MetaCoq metaprogramming facilities
to resolve the full name of the given deﬁnition. Note that remapping enhances the trusted
computing base. Therefore, it has to be done clearly and should be easy to audit. To have
better control over how the primitives are remapped, we provide a prelude where we specify
explicitly arithmetic operations for each numeric data type. The prelude serves as a model for
Coq arithmetic in CameLIGO. Many operations are simple wrappers around overloaded +,∗,
etc. of CameLIGO. Even though it looks trivial, there are subtle discrepancies between some
operations in Coq in CameLIGO. For example, we need to take special care of subtraction
and division. Subtraction of two natural numbers nat in CameLIGO is not a natural number,
but an integer int. In Coq, the subtraction of natural numbers is truncated, that is, n − m
returns zero if n < m. We implement subNTruncated that has the same behaviour as in Coq:
it returns a natural number and it is truncated in the same way. We also use safe partial
division function div : N → N → option N. Under the hood, it uses Euclidean division from
the standard library of Coq. However, the standard division in Coq returns zero when the
divisor is zero. We therefore implement a partial division function divN_opt in CameLIGO
and remap our div to it. Note that the CameLIGO division is also implemented as Euclidean
division followed by projection of the ﬁrst component (the quotient), thus there is no semantic
mismatch between the two implementations. The moduloN function is implemented similarly,
projecting the second component.

Parts of the blockchain infrastructure, such as call context, is created using Tezos build-in
operations for accessing meta-information. That is, we create an instance of the record type
cctx with ﬁelds corresponding to ConCert’s ContracCallContext.

let cctx_instance : cctx = { ctx_origin_ = Tezos.source;

ctx_from_ = Tezos.sender;
ctx_contract_address_ = Tezos.self_address;
ctx_contract_balance_ = Tezos.balance;
ctx_amount_ = Tezos.amount }.

This instance is passed as a parameter to the extracted contract in the wrapping code
generated by ConCert.

Contract calls are remapped to idiomatic CameLIGO code snippets that uses Tezos.
get_contract_opt for resolving a given address to a contract instance. Note, however, that
such resolution might fail, but it would correspond to a failed contract call

In Figure 5 we present an excerpt from the extracted code, namely code for xtz_to_token
(see Coq code in Figure 3). All arithmetic operations are remapped to the ones we speciﬁed in
the prelude that give us a way of auditing the remapping. One diﬀerence with the handwritten
version is multiple nested pattern-matchings. CameLIGO supports an eﬀectful construct
failwith, so the handwritten implementation uses it to return earlier from the function
when validation fails. In Coq code, we use the option monad and do-notations similar to
Haskell giving a similar user experience. After unfolding the monadic operations we get

E. H. Nielsen, D. Annenkov and B. Spitters

15

let xtz_to_token (chain: chain) (ctx: cctx) (state: dexter2CPMM_State) (param: dexter2CPMM_xtz_to_token_param)

: dEX2Extract_result =

match throwIf state.selfIsUpdatingTokenPool with

Some val0 →

(match throwIf (lebN param.xtt_deadline (current_slot chain)) with

Some val1 →
(match (divN_opt (multN (multN (mutez_to_natural (ctx_amount ctx)) 997n) state.tokenPool)

(addN (multN state.xtzPool 1000n) (multN (mutez_to_natural (ctx_amount ctx)) 997n))) with

Some val2 →
(match throwIf (ltbN val2 param.minTokensBought) with

Some val3 →
(match sub state.tokenPool val2 with

Some val4 →
let new_state = set_State_tokenPool (fun (a : nat) → val4)

(set_State_xtzPool (fun (a : nat) → addN state.xtzPool (mutez_to_natural (ctx_amount ctx)))

state) in

let op = token_transfer state (ctx_contract_address ctx) param.tokens_to val2 in

Some (new_state, (op :: ([]: (operation) list)))

| None → None: (dexter2CPMM_State ∗ (operation) list) option)

...

(* similar "None" cases are omitted *)
| None → (None: (dexter2CPMM_State ∗ (operation) list) option)

Figure 5 Extracted CameLIGO code

nested pattern-matching in the extracted code. Note that all parametric type constructors
not carrying values (e.g. None and empty lists) require explicit type annotations. In this
case, typing information preserved by the ConCert extraction pipeline allows us to produce
well-typed code. The functions with names set_State_∗ originate from the record update
syntax (also part on ConCert) that generates setters to record ﬁelds automatically.

In general, the proof-producing inlining step before extraction allows us to remove type
class instances from the extracted code. The option monad, that we mentioned before, adds
a lot of convenience along with the do-notation. However, it relies on type classes, which are
not supported in CameLIGO. Therefore, we use inlining in order to unfold the type class
instances and reveal their implementation.

As a result of extraction, we obtain two source ﬁles corresponding to the Dexter2 contracts
described in Sections 4.1.1 and 4.1.2. The source ﬁles contain CameLIGO code that can then
be compiled to Michelson as part of the build process. The Michelson code can be deployed
on the Tezos blockchain.

5

Related Work

Several works have already explored the correctness and safety of the Dexter2 decentralized
exchange. Dexter2 was formalised and veriﬁed for functional correctness by Nomadic Labs10
using Mi-Cho-Coq. Mi-Cho-Coq [4] is a Coq framework for formal veriﬁcation of Michelson
smart contracts. Michelson is the low-level on-chain language that CameLIGO compiles
to. The main Dexter2 contract was also veriﬁed for functional correctness and safety by
Runtime Veriﬁcation11 using the semi-automatic veriﬁer of the K-framework [14]. However,
their safety properties are not machine-checked and relied on assertions on the behaviour of
the other contracts used in the exchange. Later work by Nomadic Labs has veriﬁed some
safety properties of the main contract12 and performed property-based testing to test safety

10 https://gitlab.com/nomadic-labs/mi-cho-coq/-/blob/dexter_fa12lqt-verification/src/

contracts_coq/dexter_spec.v

11 https://runtimeverification.com/blog/dexter-2-s-formal-verification
12 https://research-development.nomadic-labs.com/progress-report-on-the-verification-of-

liquidity-baking-smart-contracts.html

16

Formalising Decentralised Exchanges in Coq

properties that could not be proven due to limitations of Mi-Cho-Coq13.

Another line of work is the veriﬁcation of interacting smart contracts in general. VerX [10]
is an automatic veriﬁer for temporal properties of interacting contracts on Ethereum. It is thus
similar to ConCert, which also considers temporal properties. VerX uses temporal quantiﬁers
to express properties of interacting contracts, which are then translated to predicates on
execution traces. However, they do not seem to prove complex properties of interacting
contracts.

The authors of [5] verify smart contracts written in the Vyper language for the Ethereum
blockchain. The work uses a ﬂavour of separation logic for a core of Vyper. The tool facilitates
modular proofs about inter-contract invariants similar to those presented in Section 4.3.2.
The technique is implemented as an automated veriﬁcation tool 2vyper using the Z3 SMT-
solver. The work veriﬁes some properties of the Uniswap14 contract. Uniswap has similar
functionality to Dexter2, but the implementation veriﬁed in 2vyper has the main contract
and the liquidity token merged to a single smart contract. This facilitates veriﬁcation, e.g.
the invariant that the total number of tokens is equal to the sum of balances, becomes a
single-contract invariant. The paper features an example of the auction contract that uses a
separate token contract to handle transfers along with an inter-contract invariant. It would
be interesting to see whether this functionality is suﬃcient to implement a version of Uniswap
that is split into three contracts, similarly to Dexter in the present paper. Note, however,
that Ethereum’s execution model is diﬀerent from the one of ConCert and Tezos. Therefore,
the implementation and the statements of invariants are not directly comparable. From the
implementation of the auction contract, it is clear that implementing interacting contracts
for Ethereum is hard and requires knowledge of common pitfalls and programming patterns,
such as using lock variables.

6

Conclusions

We have presented a methodology for developing and verifying decentralised exchanges. We
have used the Dexter2 exchange as an example, which we implemented in Coq using the
ConCert framework. Dexter2 is paradigmatic and exhibits many common implementation
idioms used in blockchains based on the message passing/actor model. That demonstrates
that our methodology is suitable for verifying implementations of similar DEX applications.
A key feature of our approach is the ability to reason about contract interactions and
inter-contract invariants. Another important functionality is code extraction of ConCert that
allows us to generate smart contract code. As a result, one gets a fully functional version of
the exchange in CameLIGO smart contract language for the Tezos blockchain.

We believe that most of our methodology is not speciﬁc to Coq and can be implemented
in other proof assistants based on type theory. Our veriﬁed extraction of smart contracts
depends on well-developed meta-programming, which may not be readily available in all
proof assistants.

In the future, we would like to connect our Dexter2 development to our ongoing work on

formalisation of token standards.

13 https://research-development.nomadic-labs.com/follow-up-on-the-verification-of-

liquidity-baking-smart-contracts.html

14 https://docs.uniswap.org/protocol/V1/introduction

E. H. Nielsen, D. Annenkov and B. Spitters

17

Acknowledgements

We would like to thank the LIGO team and in particular Tom Jack, Raphaël Cauderlier,
Exequiel Rivas, Rémi Lesénéchal and Gabriel Alfour for the pleasant discussions. This
research was partially supported by a grant from Nomadic Labs and by the Concordium
Blockchain Research Center.

References

1 Danil Annenkov, Mikkel Milo, Jakob Botsch Nielsen, and Bas Spitters. Extracting functional

programs from Coq, in Coq. ArXiv, abs/2108.02995, 2021.

2 Danil Annenkov, Mikkel Milo, Jakob Botsch Nielsen, and Bas Spitters. Extracting Smart
Contracts Tested and Veriﬁed in Coq. CPP’2021, page 105–121. Association for Computing
Machinery, 2021. doi:10.1145/3437992.3439934.

3 Danil Annenkov, Jakob Botsch Nielsen, and Bas Spitters. ConCert: A Smart Contract

4

Certiﬁcation Framework in Coq. CPP’2021, 2020. doi:10.1145/3372885.3373829.
Bruno Bernardo, Raphaël Cauderlier, Zhenlei Hu, Zhenlei Pesin, and Julien Tesson. Mi-Cho-
Coq, a framework for certifying Tezos Smart Contracts. FMBC19, 2019.

5 Christian Bräm, Marco Eilers, Peter Müller, Robin Sierra, and Alexander J. Summers.
Rich Speciﬁcations for Ethereum Smart Contract Veriﬁcation. Proc. ACM Program. Lang.,
5(OOPSLA), 2021. doi:10.1145/3485523.

6 Thierry Coquand and Christine Paulin. Inductively deﬁned types. In Per Martin-Löf and

Grigori Mints, editors, COLOG-88, pages 50–66, 1990.

7 Kim Grauer, Will Kueshner, and Henry Updegrave. Chainalysis 2022 Crypto Crime Report.

8

9

2022. URL: https://go.chainalysis.com/2022-Crypto-Crime-Report.html.
Pierre Letouzey. Programmation fonctionnelle certiﬁée – L’extraction de programmes dans
l’assistant Coq. PhD thesis, Université Paris-Sud, 2004. English version: https://www.irif.fr/
~letouzey/download/these_letouzey_English.ps.gz.
Jakob Botsch Nielsen and Bas Spitters. Smart Contract Interactions in Coq. In FMBC’2019,
2019. doi:10.1007/978-3-030-54994-7_29.

10 Anton Permenev, Dimitar Dimitrov, Petar Tsankov, Dana Drachsler-Cohen, and Martin
Vechev. VerX: Safety Veriﬁcation of Smart Contracts. In 2020 IEEE Symposium on Security
and Privacy (SP), pages 1661–1677, 2020. doi:10.1109/SP40000.2020.00024.

11 Matthieu Sozeau, Abhishek Anand, Simon Boulier, Cyril Cohen, Yannick Forster, Fabian
Kunze, Gregory Malecha, Nicolas Tabareau, and Théo Winterhalter. The MetaCoq Project.
Journal of Automated Reasoning, Feb 2020. doi:10.1007/s10817-019-09540-0.

12 Matthieu Sozeau, Simon Boulier, Yannick Forster, Nicolas Tabareau, and Théo Winterhalter.
Coq Coq Correct! Veriﬁcation of Type Checking and Erasure for Coq, in Coq. In POPL’2019,
2019. doi:10.1145/3371076.

13 Antal Spector-Zabusky, Joachim Breitner, Christine Rizkallah, and Stephanie Weirich. Total

Haskell is Reasonable Coq. CPP18, pages 14–27. ACM, 2018.

14 Andrei Stefănescu, Daejun Park, Shijiao Yuwen, Yilong Li, and Grigore Roşu. Semantics-Based
Program Veriﬁers for All Languages. In Proceedings of the 2016 ACM SIGPLAN International
Conference on Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA
2016, page 74–91. Association for Computing Machinery, 2016. doi:10.1145/2983990.2984027.
Jiahua Xu, Krzysztof Paruch, Simon Cousaert, and Yebo Feng. SoK: Decentralized Exchanges
(DEX) with Automated Market Maker (AMM) Protocols, 2022. arXiv:2103.12732.

15

