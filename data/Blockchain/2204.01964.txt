BcMON: Blockchain Middleware for Ofﬂine
Networks

2
2
0
2

r
p
A
5

]

R
C
.
s
c
[

1
v
4
6
9
1
0
.
4
0
2
2
:
v
i
X
r
a

Abstract—Blockchain is becoming a new generation of infor-
mation infrastructures. However, the current blockchain solutions
rely on a continuous connectivity network to query and modify
the state of the blockchain. The emerging satellite technology
seems to be a good catalyst to forward ofﬂine transactions to
the blockchain. However, this approach suffers expensive costs,
difﬁcult
interoperability, and limited computation problems.
Therefore, we propose BcMON, the ﬁrst blockchain middleware
for ofﬂine networks. BcMON incorporates three innovative de-
signs: 1) it reduces the costs of ofﬂine transactions accessing the
blockchain through Short Message Service (SMS), 2) it validates
the authenticity of ofﬂine cross-chain transactions by two-phase
consensus, 3) it supports ofﬂine clients to perform complex
queries and computations on the blockchains. The prototype of
BcMON has been implemented to evaluate the performance of
the proposed middleware, which can show its stability, efﬁciency,
and scalability.

Index Terms—Blockchain, Ofﬂine Network, Cross-Chain,

Computation

I. INTRODUCTION

Blockchain was ﬁrst used in a peer-to-peer electronic cash
system [1] to provide immutability through the chain data
structure, consensus, and redundant storage. Clients can query
and modify the state of the blockchain by full and light
nodes. A full node has a complete blockchain ledger. It
exploits memory to synchronize blockchain data, broadcast
transactions, verify transactions and update data in real-time.
A light node maintains the block headers of the ledger. It
can validate transactions by interacting with full nodes. Since
blockchain is an application protocol built on the Internet,
clients rely on a continuous connectivity network to interact
with blockchain nodes [2].

However, 2.9 billion people in the world have never used the
Internet, and parts of people who have used the Internet have
only occasional access to the Internet [3]. Although blockchain
technologies have developed rapidly in recent years, how to
conduct trusted interactions between the blockchain and ofﬂine
clients becomes a key challenge.

The feasible solution exploits satellites to relay ofﬂine
transactions to blockchain nodes [4][5]. Clients buy speciﬁc
transmission devices to connect to satellites and initiate trans-
actions. However, this approach has the following problems.
First, Expensive Costs. It requires blockchain solutions to
cooperate with centralized satellite companies to provide ac-
cess services. And the costs of connections are passed on to
clients. Moreover, it requires clients purchase expensive launch
equipment to use the service. Second, Difﬁcult Interoperability.
[4] and [6] build ofﬂine networks for Bitcoin and Ethereum
respectively. It is difﬁcult to adapt to different blockchains

quickly, and it is also impossible to achieve interoperability be-
tween them. Third, Limited Computation. Bitcoin’s blockchain
alone is 385GB as of March 2022 [7]. On-chain data is
becoming a valuable asset. Currently, ofﬂine clients can not
use on-chain data to perform complicated computations.

To deal with the challenges above, we propose BcMON,
the blockchain middleware for ofﬂine networks. BcMON is
composed of three components, including Ofﬂine Blockchain
Services (OFBS), Cross-chain Blockchain Service (CCBS),
and Computing Blockchain Service (CPBS). OFBS realizes
the interaction between ofﬂine clients and the blockchain.
Based on OFBS, CCBS realizes the interoperability between
ofﬂine clients and multiple blockchains. Based on OFBS and
CCBS, CPBS realizes that ofﬂine clients perform complex
queries and computations on the blockchains.

Main contributions of this paper are summarized as follows.

• We propose a blockchain middleware for the ofﬂine
network. To the best of our knowledge, this is the ﬁrst
work on blockchain middleware for the ofﬂine network.
We believe this is a timely study, as the blockchain is
widely used in many scenarios.

• We design SMS-based OFBS to reduce the costs of
ofﬂine transactions accessing the blockchain. To protect
the integrity of ofﬂine transactions, we propose a reliable
interaction mechanism based on ofﬂine channels.

• We propose CCBS to validate the authenticity of ofﬂine
cross-chain transactions. Moreover, we propose a two-
phase consensus to protect the atomicity and integrity of
ofﬂine cross-chain transactions.

• We propose CPBS to support ofﬂine clients to perform
complex queries and computations on the blockchains.
And we design a threshold signature-based interaction
mechanism to help ofﬂine clients validate results.

The rest of the paper is organized as follows. Ofﬂine
blockchain service design is introduced in Section II. Cross-
chain blockchain service design is presented in Section III.
Computing blockchain service design is elaborated in Section
IV. The proposed method is evaluated in Section V. Related
work is discussed in Section VI and and the paper is concluded
in Section VII.

II. OFFLINE BLOCKCHAIN SERVICE DESIGN

This section mainly describes the architecture of BcMON,

as shown in Figure 1.

 
 
 
 
 
 
Fig. 1: Architecture of BcMON

A. Architecture

The architecture is divided into four layers: the user layer,
channel layer, BcMON layer, and blockchain layer. And the
BcMON layer includes OFBS, CCBS, and CPBS.

a) User Layer: The user layer is composed of ofﬂine
clients in a weak communication environment. Ofﬂine clients
send data packets containing transactions to the BcMON layer,
which is the access to the blockchain network.

Ofﬂine clients are required to own accounts

in the
blockchain. Then they can exploit services supported by
the blockchain middleware. Some ofﬂine clients who have
occasional opportunities to connect to the Internet can in-
dependently generate public keys, private keys, and account
addresses. Other ofﬂine clients who have no chance to connect
to the Internet can entrust a trusted third party to escrow the
public and private keys, like operators of mobile phones.

b) BcMON Layer: The BcMON layer consists of three
components, including OFBS, CCBS, and CPBS. The un-
derlying network architecture of the three components is a
peer-to-peer network. And nodes of the three components are
composed of infrastructures with strong computing and storage
capabilities, like cell towers.

OFBS receives SMS messages from ofﬂine clients and
forwards them to speciﬁc middleware according to demands.
If ofﬂine clients initiate transactions with a single blockchain,
OFBS forwards data packets to the speciﬁc blockchains. See
details in Section II-B. If ofﬂine clients initiate transactions
with multiple blockchains, OFBS forwards data packets to
CCBS, and CCBS will perform operations, see details in
Section III. If ofﬂine clients initiate a transaction with complex
computation on on-chain data, OFBS forwards data packets
to CPBS, and CPBS will perform operations, see details in
Section IV.

c) Channel Layer: The channel layer consists of virtual
links between ofﬂine clients. Since ofﬂine clients have limited
resources and some blockchains have limited throughput,
frequent interactions with blockchains via OFBS are inefﬁcient
and wasteful of energy. Therefore, OFBS sets up virtual links
between ofﬂine clients, supported by smart contracts and SMS
services. Transactions initiated in the virtual links are not

Fig. 2: Workﬂow of OFBS

immediately submitted to the blockchain until the number
of transactions is up to the max buffer size or meets other
conditions.

d) Blockchain Layer: The blockchain layer consists of
multiple blockchains. Each blockchain is an independent de-
centralized network. The way that blockchains interact with
ofﬂine clients is OFBS. CCBS provides blockchain cross-
chain interoperability. CPBS provides complex queries and
computing power.

B. Workﬂow

Ofﬂine clients have little ability to connect to the Internet,
which gives them no chance to interact with the blockchains.
This section introduces the workﬂow of SMS-based OFBS to
achieve interactions between ofﬂine clients and blockchains.
OFBS is divided into on-chain and off-chain parts. For a better
demonstration of OFBS, a piece of a sequence diagram is
detailed in Fig. 2. Challenge 1: If a tree falls in the forest and
no one is around to hear it, does it make a sound [8]?

a) Initialize: SMS service providers initialize infras-
tructures (like cell towers) as relay nodes for peer-to-peer
networks. The initialization of infrastructure includes band-
width, buffer size, wakeup time, time out, and other required
information. Ofﬂine clients and relayers initialize private keys,
public keys, account addresses, and certiﬁcations. The private
key is used to sign transactions. The account address is used to
identify clients and relayers uniquely. The digital certiﬁcate is
used to access OFBS and blockchains. Moreover, SMS service

Blockchain LayerUser LayerShort-textMessageBcMONLayerChannel LayerOFBSCCBSCPBSFrom AddressToAddressTimeStampDataValueSignatureData PacketData PacketData PacketOn-ChainRequestForwardOfflineRequestCommitData PacketData PacketBlockchainDeviceproviders are required to deploy channel contracts in advance
on the consortium blockchains.

The channel contracts are the intermediary that transfers
state changes on the chain to off-chain to reduce the frequency
of interaction with the blockchain. The functions of the
contract include opening the channel, updating the channel,
and closing the channel. The channel used here is different
from the state channel [8]. The state channel requires clients
to be online, while the channel of OFBS can help ofﬂine clients
access blockchains.

b) OpenChannel: Ofﬂine clients packages short mes-
sages according to the SMS protocol speciﬁcation. The data
packet
includes the message content, destination number,
encoding format, type, and other information. And the message
content consists of the destination address, amount, signature,
and timestamp. The data packet is sent to relayers.

In the traditional SMS process, after relayers receive the
data packet, it forwards it to Short Message Center (SMC).
Then SMC delivers it to the corresponding base station where
the destination number is located. Finally, the base station
forwards it to the connected device.

In OFBS, the SMS-based data packet is forward to relay
nodes. Since relay nodes are a peer-to-peer network, they
need to execute consensus to maintain data integrity. Besides,
the data packet is signed by the private key, and relay nodes
can not modify the content. After relayers consensus, relayers
invoke OPENCHANNEL(), and the data packet is written into
the channel contract running on blockchain for consensus.
The channel contract will escrow balances of ofﬂine clients
for consequent transactions. After blockchain consensus, the
channel contract will emit OpenChannel Event. Relay nodes
monitor events and callback results to ofﬂine clients. See
details in Algorithm 1.

c) Off-chain Interaction: Since the channel is opened
by OFBS, ofﬂine clients can directly interact with each other
without trust. Ofﬂine clients initiate a SMS packet signed by
the private key to relay nodes. Relay nodes execute consensus
among nodes and select the leader. The leader broadcasts the
message to workers for votes. Nodes that receive the message
insert it into the database and push it to the queue. If the
last wakeup time is bigger than timeout and the number of
messages is bigger than the buffer size, relay nodes will
proceed with the message to the blockchain to update the
channel state. And the wakeup time is reset to the current
moment. See details in Algorithm 2.

Since ofﬂine clients can not directly query and modify the
balance on the chain, it is hard for them to check the validity of
transactions. Therefore, relay nodes need to ensure the transfer
account has sufﬁcient balance to support the transfer amount,
check the validity of nonce to prevent replay attacks, and
validate the signature of transactions.

d) Update Channel: OFBS sets the buffer pool and
wakeup timeout to reduce the cost of frequent interaction
with blockchains. If the update condition is met, messages
on the queue are packed by relay nodes and written into
the blockchain. We provide an on-chain aggregation method,

Algorithm 1 Channel Contract

channel[relay] = {relay,balance, nonce=0, txs,...}
emit open channel event

1: function OPENCHANNEL(client, relay, balance)
2:
3:
4: end function
5:
6: function UPDATECHANNEL(relay, balance, tx, serial)
7:
8:
9:
10:
11:
12:

channel[relay] = {relay, balance, nonce, txs, ...}
channel.Update += 1
if channel.Update == threshold then

Aggregate(channel[relay])
channel.Update == 0
emit update channel event

end if

13:
14: end function
15:
16: function CLOSECHANNEL(replayer, balance)
if Aggregate(channel[relay]) then
17:
refund and delete channel
18:
emit close channel event

19:
20:
21: end function

end if

Algorithm 2 Off-Chain Interaction

1: add modem(comport, baudrate, devid)
2: add worker(modem, buffer, wakeup, timeout)
3: add node(worker, mutex, requestPool, msgQueue)
4: deploy channel contract
5: for each node in nodes in parallel do
6:
7:
8:
9:
10:

send SMS request(uuid, mobile, message)
execute consensus among base stations
worker.EnqueueMessage(message, insertToDB=true)
if wakeup > timeout & len(messages) > buffer then

modem.SendSMS(mobile, message)
worker.EnqueueMessage(message, false)
proceed message to on-chain consensus
node.worker.wakeup = now

11:
12:
13:
14:
15: end for

end if

while the off-chain aggregation method refers to Section
III. Since we exploit consortium blockchains that provide
high throughput and storage capabilities, reducing on-chain
consumption costs is no longer our goal. Relay nodes invoke
UPDATECHANNEL(), update amounts of ofﬂine clients, and
emit UpdateChannel Event. Relay nodes monitor events and
callback results to ofﬂine clients. See details in Algorithm 1.
We support there are N relay nodes and F malicious nodes.
The aggregation threshold is T . We use X as a random
variable to identify the number of malicious nodes in OFBS.
Therefore, the probability of a faulty system is as follows.

P [X ≥ F] =

F
(cid:88)

X

C T −X
N −F C X
F
C T
N

(1)

e) Close Channel: When ofﬂine clients decide to quit
quick interaction with other clients, they can choose to close
the channel. Ofﬂine clients initiate a SMS request signed by
private keys to relay nodes. Relay nodes execute consensus and
proceed messages to on-chain consensus. Relay nodes invoke
CLOSECHANNEL() to submit the latest off-chain states and
aggregate states. Then they refund balances, delete channels,
and emit CloseChannel Event. After monitoring events, they
callback results to ofﬂine clients.

III. CROSS-CHAIN BLOCKCHAIN SERVICE DESIGN

Section II elaborates how ofﬂine clients interact with the
blockchain. Next, we introduce CCBS to validate the authen-
ticity of ofﬂine cross-chain transactions and propose a two-
phase consensus to protect atomicity and integrity. Challenge
2: How do ofﬂine clients interact with Hyperledger Fabric and
Xuperchain at the same time?

A. Overview

a) CCBS: CCBS is a blockchain middleware for cross-
chain transactions. It is based on OFBS to help ofﬂine clients
forward and callback cross-chain transactions. CCBS interacts
with the blockchain is to monitor proxy contracts deployed on
the blockchain, including SourceContract and DestContract.
CCBS has three types of nodes. Relay nodes are responsible
for off-chain consensus and aggregation. The leader node is
selected from relay nodes to monitor, broadcast, and aggregate
cross-chain transactions. Apart from the duties of relay nodes,
the monitoring nodes are the regulator of blockchains. These
nodes can access real-time transactions to audit.

b) Destination Contract (DestChain): DestChain is the
destination for cross-chain transactions. A cross-chain transac-
tion can get involved in more than one DestChain. Since CCBS
exploits contracts as interfaces, it can redirect multiple trans-
actions to many blockchains in one cross-chain transaction.
Besides, DestChain can be the SourceChain, which depends
on the relative relationship between blockchains.

c) Proxy Contract (SourceContract and DestContract):

The proxy contract is an interface for CCBS. For DestChain,
the proxy contract
is DestContract. Since one cross-chain
transaction can be forwarded to multiple blockchains, there
may be more than one DestContract deployed in blockchains.
For SourceChain,
is SourceContract.
the proxy contract
SourceContract receives cross-chain transactions, pushes them
to the pending queue, and deletes them after the callback.

d) Source Blockchain (SourceChain): SourceChain is the
source of cross-chain transactions. Ofﬂine clients ﬁrst initiate
a cross-chain request through OFBS to SourceContract on
the SourceChain. CCBS monitors the SourceContract and
proceeds with corresponding operations. CCBS also monitors
the DestContract on DestChain and callbacks related results
to SourceChain.

B. Workﬂow

The workﬂow of CCBS includes four main stages. For a
better demonstration of CCBS, a piece of a sequence diagram

TABLE I: MAIN SYMBOLS USED IN THIS PAPER

Denotion
evenk
sig
apubth
subsigth, subpubth
Sb, Db, Cp
Ri, Lj
g1, g2
e

Description
requests events generated by virtual spaces
Elliptic curve signatures
Aggregated threshold public keys of all nodes
Aggregated threshold public keys of part nodes
SourceChain, DestChain, and Proxy Contract
Relay and Leader in CCBS
Generators of multiplicative cyclic groups G1 and G2
The bilinear map: G1 × G2 → G3

bski, bpki, bsigi The private key, public key and signature of nodes in Bilinear Aggregate Signature

m, H

The message and hash function of messages

Fig. 3: Workﬂow of CCBS

is detailed in Fig. 3. The main symbols used in the article are
shown in Table I.

a) Initialize: Ofﬂine clients initialize the public key,
private key, account, certiﬁcate from blockchains or OFBS.
Relay nodes Ri of CCBS initialize the private key bski, public
key bpki of Bilinear Aggregate Signature, and other required
keys. Proxy Contract Cp should be deployed in advance in
multiple blockchains. And Ri should broadcast bpki to other
Ri, aiming to aggregate apubth. The aggregated public key
apubth is written to Cp in advance, which is used to verify
the authenticity of results from Ri.

b) Request Stage: An ofﬂine client initiates cross-chain
requestk(from, to, amount, data, ...)
through
transactions
the type of requestk is a
OFBS. OFBS determines if
then forwards requestk to CCBS.
cross-chain transaction,
CCBS ﬁrst invokes CROSSQUERY() to write requestk into
SourceContract of SourceChain C Sb
p . The requestk is added
into pending queues and emits RequestEvent.

Algorithm 3 Workﬂow
Require: request0...n

1: Lj ← select from Ri in consensus
2: CROSSQUERY(requestk) ← OFBS
3: RequestEvent ← Triggered by C Sb
p
4: Lj listen to RequestEvent
5: for each requestk ∈ request0...n in parallel do
Lj → HANDLEREQUEST(payload)
6:
for Ri in parallel do
7:
8:
9:
10:
11:

Ri → HANDLEPREPARE()
Ri → HANDLEAGGRE()
Ri → HANDLEREPLY()

end for
Lj → CROSSACCEPT() in C Db
Lj → CROSSCALLBACK() in C Sb
p

p

12:

13:
14: end for

c) Off-chain Stage: Relay nodes Ri elect a leader Lj
and Lj listens to RequestEvent of C Sb
p . Once Lj listen for a
non-empty message, Lj extracts requestk from RequestEvent.
Then Lj broadcast requestk to other Ri for the off-chain
consensus.

The off-chain consensus process is divided into four stages,
including Request, Prepare, Aggregate, and Reply stage. Al-
gorithms 4 shows the speciﬁc process. It should be noted that
the following process can be adapted into multiple DestChain
as shown in Fig. 3. For convenience, we only show a single
DestChain in the following process.

• Request: Lj executes HANDLEREQUEST(), and broad-
casts prepareMsg to Ri. Lj signs prepareMsg by the
private key so that Ri can verify the authenticity by the
public key of Lj.

• Prepare: Ri executes HANDLEPREPARE() to verify
prepareMsg from Lk. If veriﬁed, Ri signs aggregateMsg
by bski and broadcast aggregateMsg to other Ri, as
shown in (2)-(4).

gbski
i → bpki

H(m) → H, H bski → bsigi ∈ G2

e(g1, bsigi) = e(gbski

1

, H) = e(bpki, H)

(2)

(3)

(4)

• Aggregate: Ri collects bsigi of aggregateMsg and verify
the authenticity through bpki. If Ri receives enough ag-
gregateMsgs of same results, Ri executes HANDLEAG-
GREGATE() to aggregate bsigi and get the aggregated
signature subsigth and public key subpubth, as shown in
(5)-(7).

aggregateMsg ← Params(requestk)
Broadcast(Sign(aggregateMsg, bski)) to Ri

Algorithm 4 Off-chain Stage

(cid:46)Run on CCBS

1: function HANDLEREQUEST(payload)
requestk ← RequestEvent
2:
for each requestk ∈ request in parallel do
3:

end for

if Verify(prepareMsg,sigl, pkl) then

for Ri ∈ Relay Nodes in parallel do

prepareMsg ← requestk
Broadcast(Sign(prepareMsg, skl))

4:
5:
6:
7: end function
8:
9: function HANDLEPREPARE(payload)
10:
11:
12:
13:
14:
15:
16: end function
17:
18: function HANDLEAGGREGATE(payload)
for Ri ∈ Relay Nodes in parallel do
19:
collect bsigi of aggregateMsg
20:
if e(g1, bsigi) == e(bpki, H) then

end for

end if

end for

end if
subsigth ← (cid:81)w

21:
22:
23:
24:
25:
26: end function
27:
28: function HANDLEREPLY(payload)
29:
30:
31: end function

provide (requestk, subsigth, subpubth)
invoke CROSSACCEPT() of C Db

p

log.append(aggregateMsg, bsigi, bpki)

i=1 bsigi, subpubth ← (cid:81)w

i=1 bpki

e(g1, subsigth) =

w
(cid:89)

i=1

e(gbski
1

, Hi)

(7)

• Reply: Ri

to invoke
executes HANDLEREPLY()
CROSSACCEPT() of DestContract of DestChain C Db
p .
It provides requestk, subsigth and subpubth to C Db
p .
d) Execution Stage: C Db

exploits public keys of all relay
nodes apubth to veriﬁy (requestk, subsigth, subpubth), as
shown in (8)-(9). Mask represents the Ri who really signed.
If veriﬁed, C Db

execute operations and emits AcceptEvent.

p

p

multiSig ← bls.Multisig(subsigth, subpubth, mask)

(8)

multiSig.Verify(apubth, requestk)

(9)

Hi = H(mi), i = 1, 2, . . . , w

subsigth =

w
(cid:89)

i=1

bsigi

(5)

(6)

e) Callback Stage: Lj listens to AcceptEvent of C Db
and extracts the callback result resultk from eventk. Then
Lj broadcasts resultk to Ri and executes Off-chain Stage. Ri
executes HANDLEREPLY() to invoke CROSSCALLBACK()
of C Sb
and provide resultk, subsigth and subpubth to C Sb
p .
p

p

Algorithm 5 Proxy Contract (cid:46)Run on blockchains

1: function CROSSQUERY(payload)
2:
3:

Accept requestk from OFBS
apubth ← constructor()
pending[req] ← (requestk, apubth)
Emit RequestEvent

4:
5:
6: end function
7:
8: function CROSSACCEPT(payload)
9:

Accept (requestk, subsig, subpub, mask) from Ri
apubth ← constructor()
multiSig ← bls.Multisig(subsigth, subpubth, mask)
if multiSig.Verify(apubth, requestk) then
Accept (requestk and modify state

end if
Emit AccpetEvent

10:
11:
12:
13:
14:
15:
16: end function
17:
18: function CROSSCALLBACK(payload)
19:
20:

Accept (resultk, subsig, subpub, mask) from Ri
(requestk, apubth) ← pendingReq[req]
multiSig ← bls.Multisig(subsigth, subpubth, mask)
if multiSig.Verify(apubth, resultk) then
Delete requestk from pending[req]

21:
22:
23:
24:
25:
26: end function

end if
Emit CallbackEvent

C Sb
veriﬁes the authenticity of resultk, delete requestk
p
from pending queue and emit CallbackEvent. OFBS listens
to eventk and response resultk to ofﬂine clients.

The above process is as shown in Algorithm 3, 5 and 4.

IV. COMPUTING BLOCKCHAIN SERVICE DESIGN (CPBS)

In this section, we introduce CPBS to help ofﬂine clients im-
plement complex queries and computation on the blockchains.
Challenge 3: How can ofﬂine clients analyze account activity
using on-chain data from the past few months?

A. Overview

a) CPBS: CPBS is a blockchain middleware implement-
ing complex queries and computations for ofﬂine clients.
CCBS is composed of multiple relay nodes and constructs
a peer-to-peer network. It is based on OFBS to help ofﬂine
clients forward and callback results. It
is also based on
CCBS to help ofﬂine clients forward and callback results
from multiple blockchains. Therefore, when ofﬂine clients
only specify the data source involving one chain, it only needs
to combine OFBS and CPBS. Otherwise, it needs to combine
OFBS, CCBS, and CPBS to obtain results.

Single On-Chain Source Ofﬂine clients initiate tasks to
OFBS, and OFBS forwards them to CPBS. After request,
execute, aggregate, reply stages, relay nodes of OFBS callback
results to OFBS. Finally, OFBS callbacks results to ofﬂine
clients. See details in Section IV-B.

Fig. 4: Workﬂow of CPBS

Multiple On-Chain Sources The process of multiple on-
chain sources is similar to the single on-chain source. The
difference is that when data sources of tasks get involved in
multiple blockchains, relay nodes exploit CCBS to extract data
from multiple blockchains.

b) CompChain & CompContract: CompContract Cc is
an interface to receive tasks from ofﬂine clients, while Com-
pChain Cb is used for executing CompContract. Relay nodes
of CPBS monitor events of CompContract to see if there are
unresolved tasks.

c) DestChain: DestChain is the data source speciﬁed by
ofﬂine clients. Ofﬂine clients can specify multiple blockchains
there may be more than one
as data sources. Therefore,
DestChain.

d) Ofﬂine device: Ofﬂine clients issue tasks through
OFBS. For example, they can command CPBS to analyze
speciﬁed account activity using on-chain data from the past
few months.

B. Workﬂow

The workﬂow of CPBS includes four stages. For a better
demonstration of CPBS, a piece of a sequence diagram is
detailed in Fig. 4.

a) Request: Ofﬂine clients initiate taskk to OFBS. Since
ofﬂine clients interact with OFBS through SMS, we can prede-
ﬁne some classic tasks so that ofﬂine clients can enter numbers
to select tasks. For example, ofﬂine clients can enter number
1 to analyze account activities. Then OFBS forwards taskk to
CompContract Cc and CompChain Cb emits RequestEvent.

b) Execute: CPBS listens to RequestEvent and broadcast
taskk to relay nodes Ri. Ri gets the data from the speciﬁed
data source after it parses out taskk. If the speciﬁed data
source gets involved in multiple blockchains, Ri exploits
CCBS to obtain data. After Ri obtains data from data sources,
it executes taskk and output resultk. Ri signs resultk with
bski and broadcasts resultk, bsigi and bpki to other Ri.

c) Aggregate: Ri collects resultk, bsigi and bpki. If Ri
receives enough results, Ri aggregate the results and obtains
subpubth and subsigth, as shown in (5)-(7).

d) Reply: Ri writes resultk, subpubth and subsigth into
veriﬁes results, as shown in (8)-(9). If veriﬁed,
emits CallbackEvent. OFBS listens to CallbackEvent and

C Cb
c . C Cb
c
C Cb
c
response resultk to ofﬂine clients.

V. EXPERIMENTAL EVALUATIONS

This section evaluates the performance of the BcMON.
First, we conduct a security analysis. Second, we evaluate the
query performance of blockchain clients under poor network
connections. Third, we evaluate the overhead of OFBS, CCBS,
and OCBS.

A. Security Analysis

a) Illegal Transaction: Since ofﬂine clients have little
chance to connect to the Internet. It is hard to determine
whether ofﬂine clients have enough balance to pay the transfer
amount. And it is hard to verify the signatures of transactions
and whether the transaction is not a replay transaction. Bc-
MON constructs three types of blockchain middleware to con-
nect clients and blockchains. And the blockchain middlewares
are required to execute consensus when submitting results.

b) Modify transactions of ofﬂine clients: Relay nodes of
OFBS may do evil and modify transactions of ofﬂine clients.
Since transactions are signed by ofﬂine clients, the tampered
transaction will not pass veriﬁcations on the blockchain.

c) Ignore transactions of ofﬂine clients: Relay nodes of
OFBS may intentionally ignore transactions of some ofﬂine
clients. In general, relay nodes are represented by cell towers,
which are no incentive to ignore transactions of ofﬂine clients.
However, ofﬂine clients can replace SMS providers to change
relay nodes if this happens. Or they can quit the network when
there is an occasional internet connection.

d) Update old states of OFBS: Since OFBS exploits the
channel to reduce interactions with blockchains, relay nodes
of OFBS may update old states to the channel contracts. To
prevent this issue, OFBS uses the on-chain aggregation for
consensus among relay nodes. Therefore, the ﬁnal state of the
channel is the latest.

e) Atomicity and Consistency of CCBS: Ofﬂine clients
are hard to determine whether the transaction succeeds or
fails on blockchains. They also do not ensure consistency
on blockchains. Therefore, CCBS constructs a two-phase
consensus to keep atomicity and consistency.

TABLE II: Simulation Parameters

Parameter
DEFAULT
WIFI
EDGE
GPRS
Concurrent clients

MaxCount

Throughput

Target protocol
Device

Value
Default congifuration
τ =40, β=30000, ι=0.2
τ =300, β=250, ι=1.5
τ =500, β=50, ι=2
DEFAULT=100, WIFI=20, EDGE=10, GPRS=5
DEFAULT=[1000,10000,1000]
WIFI=[40,200,40],
EDGE=[40,120,20]
GPRS=[9,45,9]
DEFAULT=[100000,1000000,100000]
WIFI=[800,4000,800],
EDGE=[400,1200,200]
GPRS=[45,225,45]
tcp,udp,icmp
eth0

f) Correctness and completeness of CPBS: There are
malicious relay nodes of CPBS that return incorrect results.
CPBS is different from Oracle [9], which may yield differ-
ent results. Since the data sources come from blockchain,
they are deterministic data. Therefore, Correct results can be
aggregated as long as a sufﬁcient number of honest nodes
return the same correct results, verifying the correctness and
completeness.

B. Query Performance Under Poor Connection

We exploited Xuperchain V3.101

to construct a local
blockchain network. We queried the account, block, and
transaction through the blockchain client named xclient. Each
xclient is a grpc connect. Xuperchain is deployed on macOS
Catalina 10.15.4, CPU 2.3 GHz Intel Core i5 with two cores,
16 GB 2133 MHz LPDDR3, 304.2 Mbit/s, and Go1.17.1.
We initiated query requests concurrently through GoRoutine
to calculate the throughput and total time. Besides, we also
adjusted network connection (device, latency τ , bandwidth
β, and packet loss ι) through comcast2. Based on the above
settings, we simulated four network states (DEFAULT, WIFI,
EDGE, and GPRS) to evaluate the impact of the network
performance of blockchain. The parameters are shown in Table
II.

The asynchronous query requests exceed the QPS (Queries
Per Second) by two orders of magnitude, avoiding the impact
of boundary situations. Fig. 5 and 6 are the throughput and
query time of different network performances. The QPS used
by DEFAULT (Fig. 5 and Fig. 6 (a) is unbearable for WIFI,
EDGE and GPRS (Fig. 5 and Fig. 6 (b) (c) (d)). And the
network resources spent in querying blocks and accounts are
about 50% of the query transactions. In summary, blockchain
technology cannot be connected to the vast majority of people
worldwide.

C. Overhead of OFBS

The conﬁguration related to Xuperchain is the same as
Section V-B. We exploited contract-sdk-go to implement the

1https://github.com/xuperchain/xuperchain.git
2https://github.com/tylertreat/comcast

(a) DEFAULT

(b) WIFI

(c) EDGE

(d) GPRS

Fig. 5: Throughput

(a) DEFAULT

(b) WIFI

(c) EDGE

(d) GPRS

Fig. 6: Query Time

channel contract. The database for SMS is sqlite3. OFBS was
deployed on macOS Catalina 10.15.4, CPU 2.3 GHz Intel Core
i5 with two cores, 16 GB 2133 MHz LPDDR3, and 304.2
Mbit/s. We exploited PBFT [10] for the off-chain consensus
of OFBS. The on-chain consensus of Xuperchain is the default
conﬁguration of the SINGLE consensus. Since OFBS is the
blockchain middleware, it is irrelevant to the on-chain consen-

(a) Off-Chain

(b) OpenChannel

(c) UpdateChannel

Fig. 7: Service ime

sus. Moreover, Xuperchain supports the pluggable consensus.
Therefore, we choose the simplest on-chain consensus during
the experiment.

We divided the experiments into the off-chain and the
on/off-chain parts to evaluate the performance of OFBS. The
off-chain part is relevant with OFBS. It needs to evaluate the
off-chain service time when the number of relay nodes and
concurrent clients increases. Since the scenarios OFBS applied
are limited, we only exploited a small number of relay nodes
[4, 9, 1] to participate in the experiment. The on/off-chain part
includes the off-chain part and the on-chain part. It needs to
evaluate the total service time when the number of relay nodes,
concurrent clients, and the contract method is different.

Fig. 7 (a) shows the off-chain service time when the number
of relay nodes is [4, 9, 1] and the number of concurrent
clients is [10, 80, 10]. As can be seen from the ﬁgure, as
the average service
the number of relay nodes increases,
time per transaction increases. This reason is that the off-
chain SMS-based relay nodes need to access the database
frequently. Fig. 7 (b) and (c) show the total service time
when the number of relay nodes is [4, 9, 1], the number of
concurrent clients is [10, 80, 10], and the contract methods
are OpenChannel and UpdateChannel. The concurrent clients
initiate OpenChannel and UpdateChannel requests to modify
the state of the blockchain. And relay nodes of OFBS forward
requests to the blockchain after off-chain consensus. As can
be seen from the ﬁgure, OpenChannel consumes more time
than UpdateChannel. Moreover, combined with Fig. 7 (a), the
service time is mainly used to process on-chain transactions.

D. Overhead of CCBS

The conﬁguration of Xuperchain in OFBS is the same as
V-C. We simulated CCBS in Ubuntu 16.04 and shared the re-
sources of 2.0GHZ 8-vCPUs, 16G, and Go1.16.4 linux/amd64.
We exploited the homogeneous (FISCO BCOS and FISCO
BCOS) and heterogeneous (Ethereum Ropsten and FISCO
BCOS) blockchains to support seamless interactions. FISCO
BCOS was also deployed in Ubuntu 16.04 and conﬁgured
for four nodes and an organization. We connected Ethereum
Ropsten through Infura. The number of relay nodes of CCBS
is eight nodes if there are no special instructions. We compared
with Swap [11] to prove our efﬁciency since Swap also took
use of the proxy contract as a pivot.

Fig. 8 shows the off-chain consensus time when the number
of consequent transactions [50, 300, 50] and relay nodes [4,

Query categoryBlockTransactionAccountNumber of queries100000200000300000400000500000600000Queries per second020004000600080001000012000Query categoryBlockTransactionAccountNumber of queries1000150020002500300035004000Queries per second050100150200Query categoryBlockTransactionAccountNumber of queries400500600700800900100011001200Queries per second02468101214Query categoryBlockTransactionAccountNumber of queries5075100125150175200225Queries per second0.00.51.01.52.02.53.0Query categoryBlockTransactionAccountNumber of queries100000200000300000400000500000600000Queries time(s)010203040506070Query categoryBlockTransactionAccountNumber of queries1000150020002500300035004000Queries time(s)01020304050Query categoryBlockTransactionAccountNumber of queries400500600700800900100011001200Queries time(s)050100150200250Query categoryBlockTransactionAccountNumber of queries5075100125150175200225Queries time(s)050100150200250300350400Concurrent(tx)1020304050607080Node456789Times(s)010203040Concurrent(tx)1020304050607080Node456789Times(s)01020304050Concurrent(tx)1020304050607080Node456789Times(s)010203040(a) Heto of CCBS

(b) Heto of Swap

(a) Heto of CCBS

(b) Heto of Swap

(c) Homo of CCBS

(d) Homo of Swap

(c) Homo of CCBS

(d) Homo of Swap

Fig. 8: Consensus Time

Fig. 9: Validation Time

8, 1] increases. As can be seen from the ﬁgure, the off-chain
consensus time of CCBS is reduced by about 30% compared to
Swap in homogeneous and heterogeneous groups. Moreover,
the off-chain consensus time of CCBS in the two groups is
almost the same, while that of Swap is relatively different. The
reason is that CCBS has fewer interactions with blockchains
than Swap.

Fig. 9 shows the validation time when the number of
consequent transactions [50, 300, 50] and relay nodes [4, 8, 1]
increases. As can be seen from the ﬁgure, the validation time
of CCBS is reduced by 25% compared to Swap in homoge-
neous and heterogeneous groups, which has the same reasons
as above. Moreover, different approaches to deployment cause
the time difference of CCBS since the homogeneous groups
were deployed locally and part of heterogeneous groups were
deployed by the cloud.

Fig. 10 shows the performance of CCBS under large-scale
networks when the concurrent transaction is [10, 60, 10], the
number of relay nodes is [10, 60, 10], and the data volumes
are up to 10MB. It can be seen from the ﬁgure that CCBS has
good performance in the large-scale network.

E. Overhead of CPBS

The conﬁguration of Xuperchain in CPBS is the same as
Section V-C. Fig. 11 shows the overhead of CPBS when the
number of consequent transactions and relay nodes are [10,
80, 10]. The blue in Fig. 11(a) is the total overhead of the on-
chain and off-chain interaction, and the green is the overhead
of the off-chain interaction. Since the overhead of the off-
chain interaction is too small, we amplify it by 500 times. It
can be seen that the off-chain interaction of CPBS reﬂects the
efﬁciency of CPBS. Fig. 11(b) shows the overhead of CPBS
when the data volume increases. It can be seen that the number
of relay nodes has little effect on the latency of CPBS.

(a) (Node, Concurrent)

(b) (Node, Size)

(c) (Concurrent, Size)

Fig. 10: Process Time

(a) Interaction

(b) Data Size

Fig. 11: Overhead

VI. RELATED WORK

Blockchain has derived much middleware to support dif-
ferent applications. This section brieﬂy represents the most
related state-of-art, including 1) blockchain middleware for of-
ﬂine networks, 2) cross-chain middleware for ofﬂine networks,
and 3) computing Middleware for ofﬂine networks.

A. Blockchain middleware for ofﬂine networks

Yuntao W. et al. [12] proposed a lightweight blockchain-
based collaborative framework for space-air-ground integrated
network. They designed a delegated proof of stake consensus
to share spare computing resources. Ming F. et al. [13]
proposed a blockchain-based satellite communication network
to protect safety. This approach can quickly detect and defend
against cyber attacks. Chakrabarti C. et al. [14] proposed

Node45678Transaction50100150200250300Time(s) 0.000.330.671.001.331.672.002.332.673.000.40.60.81.01.2Node45678Transaction50100150200250300Time(s) 0.000.330.671.001.331.672.002.332.673.001.041.061.081.101.121.14Node45678Transaction50100150200250300Time(s) 0.000.330.671.001.331.672.002.332.673.000.40.60.81.01.2Node45678Transaction50100150200250300Time(s) 0.000.330.671.001.331.672.002.332.673.002.102.152.202.252.30Node45678Transaction50100150200250300Time(s) 0.001.112.223.334.445.566.677.788.8910.002.802.852.902.95Node45678Transaction50100150200250300Time(s) 0.001.112.223.334.445.566.677.788.8910.003.253.503.754.004.254.50Node45678Transaction50100150200250300Time(s) 0.000.330.671.001.331.672.002.332.673.000.1750.2000.2250.2500.2750.300Node45678Transaction50100150200250300Time(s) 0.000.330.671.001.331.672.002.332.673.000.20.40.60.81.0Node102030405060Concurrent(tx)1020304050607080Time(s) 0.852.303.755.206.658.109.5511.0012.4513.9024681012Node102030405060Data Size (KB)200040006000800010000Time(s) 1.777.2812.8018.3123.8229.3434.8540.3645.8751.3910203040Request102030405060Data Size (KB)200040006000800010000Time(s) 1.225.289.3313.3817.4321.4925.5429.5933.6537.70510152025301020304050607080Transaction0123456Time(s)On/Off-Chain(Off-Chain) × 5001020304050607080Node0.0000.0050.0100.0150.0200.025Time(s)(DataSize=1)× 4 DataSize=1024 a blockchain-based incentive scheme for the delay-tolerant
network to establish emergency communication networks.
Kongrath S. et al. [15] proposed MobiChain, a blockchain
for mobile commerce. This mechanism connects blockchain
with Sync Gateway [16] via local direct connection or internet
connection. However, those solutions are not work in ofﬂine
networks.

Blockstream [4] exploited satellite to broadcast the Bitcoin
blockchain around the world for free. SpaceChain [5] is
building a blockchain-based satellite network to deploy an
Ethereum node. kryptoradio[17] exploit DVB-T broadcasting
blockchain data, which is non-reliant on the internet. However,
these solutions require speciﬁc equipment for receiving signals
of the speciﬁc blockchain, which has expensive costs. And
the above solutions can not process the cross-chain transac-
tion and complex computation for ofﬂine clients in multiple
blockchains.

B. Cross-chain middleware for ofﬂine networks

The mainstream cross-chain middleware includes Notary,

Sidechain, Hash Locking, and Relay Chain [18].

Polkadot [19] proposed a relay chain-based cross-chain
framework. Cosmos [20] proposed that all blockchains share
Cross-chain Hub supported by Tendermint to complete data
exchange. However,
those solutions rely on a predeﬁned
system, which makes other blockchains need to adapt to this
system. Moreover, not all blockchains can connect to the relay
chain since they need to bid for slots.

Hyperledger Cactus [21] proposed a blockchain integration
solution based on hash locking[22]. The solution encapsulates
a gateway layer and an interaction between validators and
blockchains. Lys, L. et al. [23] proposed an atomic cross-
chain interaction scheme based on relayers and hash locking.
Qi M. et al. [24] proposed a cross-chain transaction platform
for high-value assets based on hash locking. However, those
solutions are used for transferring assets between blockchains,
which have limited applications.

Jin H. et al. [25] proposed a passive cross-chain method
based on monitor multiplexing reading. This method monitors
the state of the network through a listener. Zhuotao L. et
al. [26] proposed a secure interaction protocol for cross-
chain transactions. Pillai, B. et al. [27] proposed a cross-
chain interoperability protocol based on agents, which imple-
ments three-phase interactions between users and blockchains.
However, those solutions can not consider malicious nodes
in the protocol. Rui H. [28] proposed a cross-chain query
method to implement an authentic provenance query. Tian H.
et al. [11] proposed a cross-chain asset transaction protocol
based on validators and proxy contracts in Ethereum. However,
this protocol elects validators based on proof of work, which
leads to excessively long cross-chain transactions. The above
solutions are all required to connect to the Internet, which is
not suitable for ofﬂine clients.

C. Computing Middleware for ofﬂine networks

Harry K. et al. [29] proposed BlockSci, a blockchain
analysis platform based on an in-memory database. Weihui

Y. et al. [30] proposed LDV, a method based on directed
acyclic graph and historical data prune to reduce the storage
overhead of blockchain. Xiaohai D. et al. [31] proposed LVQ,
a lightweight veriﬁable query approach for Bitcoin, which is
based on Bloom ﬁlter integrated Merkle Tree, Merkle Tree,
and Sorted Merkle Tree. Haotian W. et al. [32] proposes VQL,
an efﬁcient and veriﬁable cloud query service for blockchain.
Cheng X. et al. [33] proposed APP, a data query structure
of access-policy-preserving grid-tree based on Merkle Tree.
Yijing L. et al. [34] proposed a decentralized learning method
based on oracles, which uses the data of off-chain producers
to provide consumers with highly credible computing results.
Muhammad M. et al. [35] proposed ChainSQL, a blockchain-
based database system to achieve data modiﬁcation of the
blockchain and query speed of the distributed databases si-
multaneously. Saide Z. et al. [36] proposed zkCrowd, which
distributes tasks through the public chain based on DpoS,
and dynamically executes tasks through the private subchain
based on PBFT. Weilin Z. et al. [37] proposed NutBaaS,
a blockchain-as-a-service platform that lowers development
thresholds through log-based network real-time monitoring.
However, the above solutions are all required to connect to
the Internet, which is not suitable for ofﬂine clients.

VII. CONCLUSIONS AND FUTURE WORKS

We introduce BcMON, including OFBS for ofﬂine clients
accessing the blockchain, CCBS for ofﬂine clients accessing
multiple blockchains, and CPBS for ofﬂine clients implement-
ing complex on-chain computation. To the best of our knowl-
edge, BcMON is the ﬁrst blockchain middleware for ofﬂine
networks. The prototype of BcMON has been implemented to
evaluate the performance of the blockchain middleware. We
will focus on modifying the network protocol to provide a
more efﬁcient ofﬂine network in future work.

ACKNOWLEDGEMENT

This work is supported by National Natural Science Foun-
dation of China (62072049), BUPT Excellent Ph.D. Stu-
dents Foundation (CX2021133) and BUPT Innovation and
Entrepreneurship Support Program (2022-YC-A112).

REFERENCES

[1] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” Decen-

tralized Business Review, p. 21260, 2008.

[2] X. Cong, L. Zi, and D.-Z. Du, “Dtnb: A blockchain transaction frame-
work with discrete token negotiation for the delay tolerant network,”
IEEE Transactions on Network Science and Engineering, vol. 8, no. 2,
pp. 1584–1599, 2021.

[3] “Measuring digital development facts and ﬁgures 2021,” Online, https://
www.itu.int/en/ITU-D/Statistics/Documents/facts/FactsFigures2021.pdf
Accessed Mar 30, 2022.

[4] “Blockstream satellite: Bitcoin blockchain broadcasts,” Online, https:

//blockstream.com/satellite/ Accessed Mar 21, 2022.

[5] “Spacechain: Community-based space platform,” Online, https://

spacechain.com/ Accessed Mar 30, 2022.

[6] “Smartmesh,” Online, https://smartmesh.io/ Accessed Mar 21, 2022.
[7] “Bitcoin blockchain size 2009-2022 — statista,” Online, https://
www.statista.com/statistics/647523/worldwide-bitcoin-blockchain-size/
Accessed Mar 21, 2022.

[8] J. Poon and T. Dryja, “The bitcoin lightning network: Scalable off-chain

instant payments,” 2016.

[33] C. Xu, J. Xu, H. Hu, and M. H. Au, “When query authentication
meets ﬁne-grained access control: A zero-knowledge approach,” in
Proceedings of the 2018 International Conference on Management of
Data, 2018, pp. 147–162.

[34] Y. Lin, Z. Gao, W. Shi, Q. Wang, H. Li, M. Wang, Y. Yang, and L. Rui,
“A novel architecture combining oracle with decentralized learning for
iiot,” IEEE Internet of Things Journal, 2022.

[35] M. Muzammal, Q. Qu, and B. Nasrulin, “Renovating blockchain with
distributed databases: An open source system,” Future generation com-
puter systems, vol. 90, pp. 105–117, 2019.

[36] S. Zhu, Z. Cai, H. Hu, Y. Li, and W. Li, “zkcrowd: a hybrid blockchain-
based crowdsourcing platform,” IEEE Transactions on Industrial Infor-
matics, vol. 16, no. 6, pp. 4196–4205, 2019.

[37] W. Zheng, Z. Zheng, X. Chen, K. Dai, P. Li, and R. Chen, “Nutbaas:
A blockchain-as-a-service platform,” Ieee Access, vol. 7, pp. 134 422–
134 433, 2019.

[9] K. Mammadzada, “Blockchain oracles,” Ph.D. dissertation, UNIVER-

SITY OF TARTU, 2019.

[10] M. Castro, B. Liskov et al., “Practical byzantine fault tolerance,” in

OSDI, vol. 99, 1999, pp. 173–186.

[11] H. Tian, K. Xue, X. Luo, S. Li, J. Xu, J. Liu, J. Zhao, and D. S.
Wei, “Enabling cross-chain transactions: A decentralized cryptocurrency
exchange protocol,” IEEE Transactions on Information Forensics and
Security, vol. 16, pp. 3928–3941, 2021.

[12] Y. Wang, Z. Su, N. Zhang, and D. Fang, “Disaster relief wireless
networks: Challenges and solutions,” IEEE Wireless Communications,
vol. 28, no. 5, pp. 148–155, 2021.

[13] M. Feng and H. Xu, “Msnet-blockchain: A new framework for securing
mobile satellite communication network,” in 2019 16th Annual IEEE
International Conference on Sensing, Communication, and Networking
(SECON).

IEEE, 2019, pp. 1–9.

[14] C. Chakrabarti and S. Basu, “A blockchain based incentive scheme for
post disaster opportunistic communication over dtn,” in Proceedings
of the 20th International Conference on Distributed Computing and
Networking, 2019, pp. 385–388.

[15] K. Suankaewmanee, D. T. Hoang, D. Niyato, S. Sawadsitang,
P. Wang, and Z. Han, “Performance analysis and application of mobile
blockchain,” in 2018 international conference on computing, networking
and communications (ICNC).

IEEE, 2018, pp. 642–646.

[16] D. Ostrovsky and Y. Rodenski, “Synchronizing data with the couchbase
sync gateway,” in Pro Couchbase Server. Springer, 2014, pp. 301–312.
[17] “Kryptoradio by koodilehto,” Online, https://kryptoradio.koodilehto.ﬁ/

Accessed Mar 21, 2022.

[18] V. Buterin, “Chain interoperability,” R3 Research Paper, 2016.
[19] G. Wood, “Polkadot: Vision for a heterogeneous multi-chain frame-

work,” White Paper, 2016.

[20] J. Kwon and E. Buchman, “A network of distributed ledgers,” Cosmos,

dated, pp. 1–41, 2018.

[21] Hyperledger, “Hyperledger cactus whitepaper,” https://github.com/

hyperledger/cactus/blob/main/whitepaper/whitepaper.md, 2020.

[22] B. website, “Hash time locked contracts,” https://en.bitcoin.it/wiki/

Hash Time Locked Contracts, 2019.

[23] L. Lys, A. Micoulet, and M. Potop-Butucaru, “Atomic cross chain
swaps via relays and adapters,” in Proceedings of the 3rd Workshop on
Cryptocurrencies and Blockchains for Distributed Systems, 2020, pp.
59–64.

[24] M. Qi, Z. Wang, D. Liu, Y. Xiang, B. Huang, and F. Zhou, “Acctp:
Cross chain transaction platform for high-value assets,” in International
Conference on Blockchain. Springer, 2020, pp. 154–168.

[25] H. Jin, X. Dai, and J. Xiao, “Towards a novel architecture for enabling
interoperability amongst multiple blockchains,” in 2018 IEEE 38th
International Conference on Distributed Computing Systems (ICDCS).
IEEE, 2018, pp. 1203–1211.

[26] Z. Liu, Y. Xiang, J. Shi, P. Gao, H. Wang, X. Xiao, B. Wen, and
Y.-C. Hu, “Hyperservice: Interoperability and programmability across
heterogeneous blockchains,” in Proceedings of the 2019 ACM SIGSAC
Conference on Computer and Communications Security, 2019, pp. 549–
566.

[27] B. Pillai, K. Biswas, and V. Muthukkumarasamy, “Cross-chain inter-
operability among blockchain-based systems using transactions,” The
Knowledge Engineering Review, vol. 35, 2020.

[28] R. Han, J. Xiao, X. Dai, S. Zhang, Y. Sun, B. Li, and H. Jin, “Vassago:
Efﬁcient and authenticated provenance query on multiple blockchains,”
in 2021 40th International Symposium on Reliable Distributed Systems
(SRDS).

IEEE, 2021, pp. 132–142.

[29] H. Kalodner, M. M¨oser, K. Lee, S. Goldfeder, M. Plattner, A. Chator,
and A. Narayanan, “Blocksci: Design and applications of a blockchain
analysis platform,” in 29th USENIX Security Symposium (USENIX
Security 20), 2020, pp. 2721–2738.

[30] W. Yang, X. Dai, J. Xiao, and H. Jin, “Ldv: A lightweight dag-
based blockchain for vehicular social networks,” IEEE Transactions on
Vehicular Technology, vol. 69, no. 6, pp. 5749–5759, 2020.

[31] X. Dai, J. Xiao, W. Yang, C. Wang, J. Chang, R. Han, and H. Jin,
“Lvq: A lightweight veriﬁable query approach for transaction history
in bitcoin,” in 2020 IEEE 40th International Conference on Distributed
Computing Systems (ICDCS).

IEEE, 2020, pp. 1020–1030.

[32] H. Wu, Z. Peng, S. Guo, Y. Yang, and B. Xiao, “Vql: Efﬁcient
and veriﬁable cloud query services for blockchain systems,” IEEE
Transactions on Parallel and Distributed Systems, vol. 33, no. 6, pp.
1393–1406, 2021.

