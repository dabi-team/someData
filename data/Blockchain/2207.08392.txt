2
2
0
2

g
u
A
7
2

]

R
C
.
s
c
[

2
v
2
9
3
8
0
.
7
0
2
2
:
v
i
X
r
a

Bitcoin-Enhanced Proof-of-Stake Security:
Possibilities and Impossibilities

Ertem Nusret Tas
Stanford University
nusret@stanford.edu

David Tse
Stanford University
dntse@stanford.edu

Fangyu Gai
BabylonChain
greferry@gmail.com

Sreeram Kannan
University of Washington, Seattle
ksreeram@uw.edu

Mohammad Ali Maddah-Ali
Stanford University
maddah.ali.ee@gmail.com

Fisher Yu
BabylonChain
ﬁshermanymc@babylonchain.io

Abstract—Bitcoin is the most secure blockchain in the world,
supported by the immense hash power of its Proof-of-Work
miners. Proof-of-Stake chains are energy-efﬁcient, have fast
ﬁnality but face several security issues: susceptibility to non-
slashable long-range safety attacks, low liveness resilience and
difﬁculty to bootstrap PoS chains from low token valuation. We
show that these security issues are inherent in any PoS chain
without an external trusted source, and propose a new protocol,
Babylon, where an off-the-shelf PoS protocol checkpoints onto
Bitcoin to resolve these issues. An impossibility result justiﬁes
the optimality of Babylon. A use case of Babylon is to reduce the
stake withdrawal delay: our experimental results show that this
delay can be reduced from weeks in existing PoS chains to less
than 5 hours using Babylon, at a transaction cost of less than
10K USD per annum for posting the checkpoints onto Bitcoin.

I. INTRODUCTION
A. From Proof-of-work to proof-of-stake

Bitcoin, the most valuable and arguably the most secure
blockchain in the world,
is supported by a proof-of-work
(PoW) protocol that requires miners to compute many random
hashes. Many newer blockchain projects eschew the proof-of-
work paradigm in favor of proof-of-stake (PoS). A prominent
example is Ethereum, which is currently migrating from PoW
to PoS, a process 6 years in the making. Other prominent PoS
blockchains include single chain ecosystems such as Cardano,
Algorand, Solana, Avalanche as well as multi-chain ecosys-
tems such as Polkadot and Cosmos. The Cosmos ecosystem
consists of many application-speciﬁc zones, all built on top of
the Tendermint PoS consensus protocol [22], [21].

PoS protocols replace computational work with ﬁnancial
stake as the means to participate in the protocol. To execute the
protocol as validators, nodes acquire coins of the PoS protocol,
and lock up their stake as collateral in a contract. This enables
the PoS protocol to hold protocol violators accountable, and
slash, i.e., burn their locked stake as punishment.

B. Proof-of-stake security issues

Security of PoS protocols has traditionally been shown
under the honest majority assumption, which states that the
honest parties hold the majority of the stake [29], [16], [28],

Contact author: DT

[22]. Introduced by Buterin and Grifﬁth [24], the concept
of accountable safety enhances the notion of security under
honest majority with the ability to provably identify protocol
violator in the event of a safety violation. Thus, accountable
safety not only implies security under an honest majority, but
also the identiﬁcation of protocol violators if a large quorum
of the validators are adversarial and cause a safety violation. In
lieu of making an unveriﬁable honest majority assumption, this
approach aims to obtain a cryptoeconomic notion of security
by holding protocol violators accountable and slashing their
stake, thus enabling an exact quantiﬁcation of the penalty for
protocol violation. This trust-minimizing notion of security is
central to the design of PoS protocols such as Gasper [25], the
protocol supporting PoS Ethereum, and Tendermint [22], [21],
supporting the Cosmos ecosystem. However, there are several
fundamental limitations to the security of the PoS protocols:
Safety attacks are not slashable: While a PoS protocol with
accountable safety can identify attackers, slashing of their
stake is not always possible, implying a lack of slashable
safety. For example, a posterior corruption attack can be
mounted using old coins after the stake is withdrawn, and
therefore cannot be slashed [23], [29], [16], [31]. These attacks
are infeasible in a PoW protocol like Bitcoin as the attacker
needs to counter the total difﬁculty of the existing longest
chain. In contrast, they become affordable in a PoS protocol
since the old coins have little value and can be bought by
the adversary at a small price. Posterior corruption is a long-
known problem with PoS protocols, and several approaches
have been proposed to deal with it under the honest majority
assumption (Section II). Theorem 1 in Section IV says that
no PoS protocol can provide slashable safety without external
trust assumptions. A typical external trust assumption used
in practice is off-chain social consensus checkpointing. As
social consensus is a slow process, this type of checkpointing
leads to a long withdrawal delay after a validator requests
to withdraw its stake (e.g., 21 days for Cosmos zones [10]),
which reduces the liquidity of the system. Moreover, social
consensus cannot be relied upon in smaller blockchains with
an immature community.
Low liveness resilience: PoS protocols such as Snow

 
 
 
 
 
 
2

Fig. 1: Babylon posts PoS block hashes and the validator signatures on them to Bitcoin. Ordering of these hashes enable clients to break
ties between conﬂicting PoS chains, and slash adversarial validators before they withdraw following a safety violation. The PoS chain in a
client c’s view is shown by the red circle. Dark blue blocks represent the checkpointed chain of PoS blocks in c’s view. The fast ﬁnality
rule determines the PoS chain, while the slow ﬁnality rule determines the checkpointed chain, which is always a preﬁx of the PoS chain.

Fig. 2: An adversary that controls a supermajority of active validators ﬁnalizes PoS blocks on an attack chain (top). It keeps the attack chain
private, yet posts the hashes of the private blocks and their signatures on Bitcoin. Once these checkpoints are deep in Bitcoin, adversary
helps build a conﬂicting chain (bottom) in public, and posts the hashes of its blocks and their signatures on Bitcoin. A client that sees the
earlier checkpoint for the unavailable blocks, and the later one for the public blocks has two options: (1) It can stop outputting the new
PoS blocks, or (2) it can ignore the earlier checkpoint and output the public blocks from the bottom chain. However, the adversary can later
publish the unavailable blocks, and convince a late-coming client to output the blocks from the top (attack) chain, causing a safety violation.
Moreover, as the adversary might have withdrawn its stake by the time the blocks in the top chain are published, it cannot be slashed. To
avoid this attack, clients choose to stall upon seeing block b, i.e. emergency-break, if they see a signed checkpoint for the unavailable blocks.

White [41], [29] and Ouroboros [36], [30], [16] guarantee
liveness as long as the fraction of adversarial stake is below
1/2. However, PoS protocols with accountable safety such
as Tendermint and Gasper cannot ensure liveness beyond an
adversarial fraction of 1/3. This low liveness resilience of 1/3
is a fundamental limitation of PoS protocols with accountable
safety, even under synchrony [46, Appendix B].
The bootstrapping problem: Even if a PoS protocol pro-
vides slashable safety, the maximum penalty an adversary
can suffer due to slashing does not exceed the value of its
staked coins. Thus, the cryptoeconomic security of a PoS
protocol
to its token valuation. Many PoS
chains, particularly ones that support one speciﬁc application
(e.g., Cosmos zones) start with a low token valuation. This
makes it difﬁcult for new PoS chains to support high-valued
applications (e.g., decentralized ﬁnance, NFTs). Similarly, a
PoS chain that experiences a signiﬁcant drop in token valuation
becomes more susceptible to attacks.

is proportional

C. Leveraging external trust

The main reason behind the security issues described above
is the absence of a reliable arrow of time. For instance, poste-
rior corruption attacks exploit the inability of the late-coming
clients to distinguish between the canonical chain minted by
the honest validators and the adversary’s history-revision chain
that is published much later [29], [31]. Hence, to guarantee
a slashable notion of safety, PoS protocols need an external
trust source that can periodically and publicly timestamp the
canonical chain. Social consensus can be viewed as one such

source of external trust, but because it is achieved off-chain, its
level of security is hard to quantify. In this paper, we explore
a more quantiﬁable approach, which is to use an existing
secure blockchain as a source of external trust. Given such
a trusted blockchain, we ask: What is the limit to the security
enhancement the trusted chain can provide to a PoS chain and
what is the optimal protocol that achieves this limit?

A natural example of such a trusted blockchain is Bitcoin.
The main result of the paper is the construction of Babylon,
where an off-the-shelf PoS protocol posts succinct information
to Bitcoin for security enhancement. Moreover, we show that
Babylon achieves the optimal security among all protocols that
do not post the entire PoS data to Bitcoin. Indeed, it is trivial
to see that if the PoS protocol is allowed to post its entire
data onto the trusted chain, the PoS protocol can inherit its
full security. But in a chain with low throughput like Bitcoin,
posting the entire data is clearly infeasible. Our result shows
exactly what the loss of security is from this limitation.

The idea of using a trusted parent chain to provide se-
curity to a PoS chain has been used in several
industry
projects and academic works. Most of these works focus on
mitigating speciﬁc attack vectors. For example, a recently
proposed protocol, BMS [47], uses Ethereum to keep track
of the dynamic validator set of a PoS chain to withstand
posterior corruption attacks. (That work was later extended
to a protocol using Bitcoin in a concurrent work [15] to ours.)
In our paper, we broaden the investigation to ﬁnd out the
best security guarantees a trusted public blockchain such as

Bitcoin can provide to a PoS chain, and construct an optimal
protocol, Babylon, that achieves these guarantees. A detailed
comparison of Babylon and other approaches is described in
Table I and Section II.

D. Babylon

A PoS protocol is executed by validators, which lock up
their stake in a contract on the PoS chain. The design of
Babylon speciﬁes the kind of information validators post on
Bitcoin and how this information is used by the clients, i.e.,
external observers of the protocol, to resolve attacks on the
PoS chain (cf. Figure 1). Its highlights are presented below:

a) Checkpointing: PoS protocol proceeds in epochs dur-
ing which the validator set is ﬁxed. At each epoch, the honest
validators sign the hash of the last PoS block of the epoch
(cf. Figure 1). They subsequently post the hash and their
signatures to Bitcoin as checkpoints. Ordering imposed on
these checkpoints by Bitcoin enable the clients to resolve
safety violations, and identify and slash adversarial validators
engaged in posterior corruption attacks before they withdraw
their stake.

b) Fast ﬁnality fork-choice rule (cf. Figure 1): To output
a PoS chain, a client c ﬁrst observes the conﬁrmed preﬁx of
the longest Bitcoin chain in its view. It then uses the sequence
of checkpoints on Bitcoin to obtain a checkpointed chain
of PoS blocks. While constructing the checkpointed chain,
PoS blocks with earlier checkpoints take precedence over
conﬂicting blocks with later checkpoints. Once c constructs the
checkpointed chain, it obtains the full PoS chain by attaching
the remaining PoS blocks that extend the checkpointed chain.
It stalls upon observing a fork among the later PoS blocks that
extend the checkpointed chain.

Since Bitcoin helps resolve earlier forks and obtain a unique
checkpointed chain, safety can only be violated for recent PoS
blocks in c’s view. Hence, adversarial validators cannot violate
the safety of older PoS blocks through long range posterior
corruption attacks after withdrawing their stake. On the other
hand, if a safety attack is observed for the recent PoS blocks,
c can detect the adversarial validators and enforce the slashing
of their stake. Protocol thus ensures slashable safety.

c) Emergency break: If the adversary controls a super-
majority of the validators,
it can sign the hashes of PoS
blocks privately, and keep the blocks hidden from the clients.
A client stops adding new blocks to its PoS chain if it
observes a signed checkpoint on Bitcoin, yet the corresponding
block is unavailable. This emergency break is necessary to
protect against data unavailability attacks (cf. Figure 2). If
the checkpoints consisted only of the block hashes, then the
adversary could stall the PoS chain by sending a single hash
and pretending like it is the checkpoint of an unavailable PoS
block. Thus, the signatures on the checkpoints ensure that the
adversary cannot cause an emergency break, unless it corrupts
the supermajority of the current validator set.

d) Fallback to Bitcoin: If a transaction is observed to
be censored, execution of the PoS protocol is halted, and
the hashes of all future PoS blocks and the corresponding

3

signatures on them are posted to Bitcoin, which is directly
used to order these blocks. This is analogous to operating the
PoS protocol as a rollup, where Bitcoin plays the role of the
parent chain and the PoS validators act like sequencers. A PoS
chain that uses Bitcoin directly to order its blocks is said to
be in the rollup mode.

e) Bitcoin safety & slow ﬁnality fork-choice rule: Clients
can achieve Bitcoin safety for their PoS chains if they adopt
a slow ﬁnality rule, where they only output the checkpointed
chain in their views. Clients wait until a PoS block or its
descendants are checkpointed on Bitcoin before outputting the
block as part of the PoS chain. In this case, the PoS chain is
always safe (assuming Bitcoin is secure), however, its latency
now becomes as large as Bitcoin latency.

E. Security guarantees

the time it

Table I summarizes the security guarantees achieved by
Babylon, assuming that Bitcoin is safe and live. Babylon
resolves the three PoS security issues presented in Section
I-B in the following way:
Safety: Under the fast ﬁnality rule, Babylon achieves slashable
safety via checkpointing, and stalling whenever data is un-
available. Slashable safety is not possible without an external
source of trust. Moreover, Babylon achieves this with a stake
withdrawal delay equal to the Bitcoin conﬁrmation latency,
i.e.,
takes for the timestamp of a withdrawal
request to be conﬁrmed on Bitcoin. To estimate this delay,
we implemented a checkpointing protocol and measured the
conﬁrmation latency for the checkpoints. See Section V.
Liveness: Babylon improves the liveness resilience from 1/3
to 1/2 by using Bitcoin as a fallback. However, when the
adversarial fraction exceeds 1/2, liveness cannot be guaran-
teed. As shown by Theorem 4, this is not Babylon’s fault, but
is inherent in any protocol that does not post the entire PoS
transaction data to Bitcoin. Then, the protocol is susceptible to
data unavailability attacks. In Section VI, we show one such
attack on inactivity leak, the method used by PoS Ethereum
and Cosmos to slash inactive validators [19], [5].
Bootstrapping: Under the slow ﬁnality rule, Babylon is safe
no matter how many adversarial validators there are, if Bitcoin
is secure. Thus, Babylon achieves Bitcoin safety, albeit at
the expense of Bitcoin conﬁrmation latency. Thus is useful
in a bootstrapping mode or for important transactions, where
slashable safety is not sufﬁcient.

F. Outline

The rest of the paper is organized as follows. Section II
reviews related work. Section III presents the model and
deﬁnitions of various security notions. In Section IV, we
show that slashable safety is not possible for PoS chains
without external trust. We then present Babylon 1.0, a Bitcoin-
checkpointing protocol that provides slashable safety. In Sec-
tion V, we provide measurements of conﬁrmation latency for
Bitcoin transactions containing checkpoints and demonstrate
the feasibility of checkpointing onto Bitcoin. In Section VI,
we show the impossibilty of liveness beyond a 1/2 adversarial

4

Safety

n/3-safe

n/3-safe

Liveness

Withdrawal

f < n/3

n/3 ≤ f < n/2

f ≥ n/2

PoS Latency

No guarantee

No guarantee

?

PoS Latency

No guarantee

No guarantee

Ethereum latency

KES [28]

BMS [47]

Babylon: fast ﬁnality

n/3-slashable safe

PoS Latency

Bitcoin Latency

No guarantee

Bitcoin latency

Babylon: slow ﬁnality

always safe

Bitcoin Latency

Bitcoin Latency

No guarantee

Bitcoin latency

TABLE I: The security guarantees of Babylon compared to other solutions, assuming the security of Bitcoin in the case of Babylon and the
security of Ethereum in the case of BMS. Here, f is the number of adversarial validators and n is the total number of validators. m-safe
means the protocol is safe whenever f < m, m-slashable-safe means that whenever safety is violated, m validators can be slashed (which
is a stronger property than m-safe). Stake withdrawals happen with Bitcoin latency on Babylon as long as liveness is satisﬁed, whereas it
happens with Ethereum latency on BMS. In theory, Algorand [28] can grant stake withdrawal requests in seconds as it uses key-evolving
signatures (KES) to recycle keys after every signature, but since KES is highly incentive incompatible, Algorand still uses social consensus
checkpointing.

fraction of validators, even when there is a data-limited source
of external trust. We then improve Babylon 1.0 to the full
Babylon protocol to provide the optimal liveness resilience. In
Section VII, we describe the slow ﬁnality rule that provides
Bitcoin safety to the PoS chains.

II. RELATED WORKS

A. Posterior corruption attacks

Among the PoS security issues discussed in Section I-B,
posterior corruption attacks is the most well-known, [23],
[29], [16], [31]. In a posterior corruption attack also known
as founders’ attack, long range attack, history revision attack
or costless simulation, adversary acquires the old keys of the
validators after they withdraw their stake. It then re-writes
the protocol history by building a conﬂicting attack chain
in private. The attack chain forks from the canonical one at
a past block, where the old keys constituted a majority of
the validator set. Subsequently, the adversary replaces the old
validators with new ones under its control, and reveals the
attack chain to the clients observing the system at a later time.
The adversary thus causes clients to adopt conﬂicting chains
at different times.

Without additional trust assumptions, it is impossible to
design a secure PoS protocol, even under an honest majority
assumption for the active, current validators [29, Theorem 2].
Thus, several solutions have been proposed: 1) checkpointing
via social consensus (e.g., [23], [29], [14], [17]); 2) use of key-
evolving signatures (e.g., [28], [36], [16]); 3) use of veriﬁable
delay functions (e.g., [49]); 4) timestamping on an existing
PoW chain like Ethereum [47] or Bitcoin [15].

1) Social consensus: Social consensus refers to a trusted
committee, distinct from the PoS validators, which periodically
checkpoints the ﬁnalized PoS blocks on the canonical chain.
It
this attempts to prevent posterior corruption attacks by
making the blocks on the attack chain distinguishable from the
checkpointed ones on the canonical chain. For instance, in PoS
Ethereum, clients identify the canonical chain with the help of
checkpoints received from their peers. Since no honest peer
provides a checkpoint on a private chain, posterior corruption
attacks cannot confuse new validators [13].

As clients might receive their checkpoints from different
peers, it is often difﬁcult to quantify the trust assumption

placed on social consensus. A small committee of peers shared
by all clients would imply centralization of trust, and make
security prone to attacks targeting few nodes. Conversely, a
large committee would face the problem of reaching con-
sensus on checkpoints in a timely manner, leading to long
withdrawal delays. For instance, Avalanche, Cosmos zones and
PoS Ethereum have withdrawal delays of 14, 21 and 131 days
respectively [8], [10], [40].

2) Key-evolving signatures (KES): KES requires the val-
idators to forget old keys so that a history revision attack
cannot be mounted. Security has been shown for various
PoS protocols using key-evolving signatures under the honest
majority assumption for the current, active validators [28],
[16]. This assumption is necessary to ensure that the majority
of the active validators willingly forget their old keys so that
they cannot be given to an adversary at a later time. However,
there might be a strong incentive for the validators to record
their old keys in case they later become useful. Thus, KES
render the honest majority assumption itself questionable by
asking honest validators for a favor which they may be tempted
to ignore for future gain. This observation is formalized in
Section IV-B, which shows that KES are not sufﬁcient to
provide slashable safety for PoS protocols.

3) Veriﬁable Delay Functions (VDFs): VDFs can help the
clients distinguish the canonical chain generated a long time
ago from an attack chain created much later, thus providing
an arrow of time for the clients and protecting the PoS
protocol from posterior corruption attacks. However, like KES,
VDFs standalone cannot provide slashable safety for PoS
protocols (cf. Section IV-B). Another problem with VDFs is
the possibility of ﬁnding faster functions [12], which can then
be used to mount a posterior corruption attack.

4) Timestamping the validator set: Posterior corruption
attacks can be thwarted by timestamping the PoS validator
set on an external public blockchain such as Ethereum [47]
and Bitcoin [15]. For instance, Blockchain/BFT Membership
Service (BMS) [47] uses an Ethereum smart contract as a
reconﬁguration service that records the changes in the current

1This is calculated for 130, 000 attesters with an average balance of 32
ETH to accurately model the targeted attester numbers on PoS Ethereum
using [40, Table 1].

validator set. When validators request to join or leave the cur-
rent set, the existing validators send transactions containing the
new validator set to the contract. Upon receiving transactions
with the same new validator set from sufﬁciently many existing
validators (e.g., from over 1/3 of the current validator set), the
contract replaces the current set with the new one.

The goal of BMS is to protect the PoS protocol against
posterior corruption attacks, where the adversary creates an
attack chain using the credentials of old validators. These old
validators are then replaced by new, adversarial ones that are
distinct from those on the canonical chain. However, if the
honest validators constitute over 2/3 of the current validator
set, the new adversarial validators cannot be validated and
recorded by the contract before the new validators on the
canonical chain. Hence, BMS enables the late-coming clients
the attack chain, providing security
to identify and reject
to PoS chains as long as the fraction of active adversarial
validators is bounded by 1/3 at any given time (cf. Table I). By
preventing posterior corruption attacks, BMS can also reduce
the withdrawal delay of the PoS protocols from weeks to the
order of minutes.

To prevent posterior corruption attacks, BMS requires an
honest supermajority assumption on the current set of valida-
tors, and as such, does not provide slashable safety. If the
adversary controls a supermajority of the validator set, it can
create an attack chain in private, simultaneous with the public
canonical chain, and post the validator set changes of the
private chain to the contract before the changes on the canon-
ical chain. Then, the late-coming clients could confuse the
canonical chain as an attack chain, and identify its validators
as protocol violators, which implies lack of slashable safety.
Unlike Babylon, BMS cannot ensure liveness if the fraction
of adversarial active validators exceeds 1/3 (cf. Table I).
Similarly, whereas Babylon that can provide Bitcoin safety
for young PoS chains and important transactions, BMS cannot
provide Ethereum safety to the constituent PoS protocols even
by adopting a slow ﬁnalization rule. This is because BMS
contract only keeps track of the PoS validators, and does not
receive any information about the PoS blocks themselves such
as block headers. Hence, BMS cannot prevent an adversarial
supermajority from ﬁnalizing conﬂicting PoS blocks.

B. Hybrid PoW-PoS protocols

A PoS protocol timestamped by Bitcoin is an example of a
hybrid PoW-PoS protocol, where consensus is maintained by
both the PoS validators and Bitcoin miners. One of the ﬁrst
such protocols is Casper FFG, a ﬁnality gadget used in con-
junction with a longest chain PoW protocol [24]. The ﬁnality
gadget is run by PoS validators as an overlay to checkpoint
and ﬁnalize blocks in an underlay PoW chain, where blocks
are proposed by the miners. The ﬁnality gadget architecture
is also used in many other PoS blockchains, such as PoS
Ethereum [25] and Polkadot [48]. Bitcoing timestamping can
be viewed as a "reverse" ﬁnality gadget, where the miners
run an overlay PoW chain to checkpoint the underlay PoS
chains run by their validators. In this context, our design that

5

combines Bitcoin with PoS protocols leverages off ideas from
a recent line of work on secure compositions of protocols [38],
[44], [39]. To improve the adversary fraction tolerable for
liveness from 1/3 to 1/2, Babylon also uses insights from
Thunderella [42], which combines a longest chain protocol
with a responsive BFT protocol.

C. Timestamping

Timestamping data on Bitcoin has been used for purposes
other than resolving the limitations of PoS protocols. For
instance, timestamping on Bitcoin was proposed as a method
to protect Proof-of-Work (PoW) based ledgers against 51%
attacks by [35]. However,
their construction requires the
Bitcoin network to contain observing miners, which publish
timestamps from the POW ledger to be secured, only if the
block data is available. This implies changing the Bitcoin
protocol to incorporate data-availability checks, whereas in
our work, we analyze the limitations of security that can be
achieved by using Bitcoin as is.

Two projects that use Bitcoin to secure PoS and PoW child
chains are Veriblock [43] and Komodo [9]. Both projects
suggest checkpointing child chains on Bitcoin to help resolve
forks. However, they lack proper security proofs, and do not
analyze how attacks on PoS chains can be made slashable.
Another use-case of timestamping, analyzed by [34], is posting
commitments of digital content to Bitcoin to ensure integrity
of the data. In this vein, [33] implements a web-based service
to help content creators prove their possession of a certain
information in the past by posting its timestamps on Bitcoin.

III. MODEL

Notation. Given a positive integer m, we denote the set
{1, 2, . . . , m} by [m]. We denote PoS blocks by capital B
and the Bitcoin blocks by lowecase b. We use the phrase
‘with overwhelming probability’ to label an event that happens
except with negligible probability in the security parameter λ.
Validators and clients. In the client-server setting of state
machine replication (SMR),
there are two sets of nodes:
validators and clients. Validators receive transactions as input,
and execute a SMR protocol. Their goal is to ensure that
the clients obtain the same sequence of transactions, thus, the
same end state. We assume that the transactions are batched
into blocks, and the sequence obtained by the clients is a
blockchain, denoted by L. Thus, we will hereafter refer to
the SMR protocols as blockchain protocols.

To output a chain, clients query the validators, which reply
with consensus messages. Upon collecting messages from a
subset S of the validators and donwloading blocks, each client
outputs a chain. Clients can query the validators at arbitrary
times, and might be ofﬂine in between queries. The set of
clients include honest validators, as well as external nodes
that observe the protocol infrequently.

The blockchain protocol has external validity: A transaction
in a given chain is valid with respect to its preﬁx if it satisﬁes
external validity conditions. A block is valid if it only contains

valid transaction. Clients output valid blocks and ignore invalid
ones.

Blocks and chains. Each block consists of a block header
and transaction data. Block headers contain (i) a pointer (e.g.,
hash) to the parent block, (ii) a vector commitment (e.g.,
Merkle root) to the transactions data, e.g., a Merkle root,
and (iii) protocol related messages. The total order across the
blocks in a chain together with the ordering of the transactions
by each block gives a total order across all transactions within
the chain.

For a block B, we say that B ∈ L, if B is in the chain
L. Similarly, we say tx ∈ L, if the transaction tx is included
in a block that is in L. A block B is said to extend B(cid:48), if
B(cid:48) can be reached from B by following the parent pointers.
Conversely, the blocks B and B(cid:48) are said to conﬂict with each
other if B(cid:48) does not extend B and vice versa. The notation
L1 ≺ L2 denotes that L1 is a strict preﬁx of L2, whereas
L1 (cid:22) L2 denotes that L1 is either a preﬁx of L2, or is the
same as L2. The chains L1 and L2 conﬂict with each other if
they contain conﬂicting blocks.

Environment and adversary. Transactions are input to the
validators by the environment Z. Adversary A is a probabilis-
tic polynomial time algorithm. Before the protocol execution
starts, adversary can corrupt a subset of validators, which are
subsequently called adversarial. These validators surrender
their internal states to the adversary and can deviate from the
protocol arbitrarily (Byzantine faults) under the adversary’s
control. The remaining validators are called honest and follow
the blockchain protocol as speciﬁed. Time is slotted, and the
validators are assumed to have synchronized clocks2.

Networking. Validators can broadcast messages to each
other and the clients. Messages are delivered by the adversary,
which can observe a message sent by an honest validator be-
fore it is received. Network is synchronous, i.e., the adversary
delivers the messages sent by an honest validator to all other
honest validators and clients within ∆ slots. Here, ∆ is a
known parameter. If a client observes the hash or header of
a block before slot r − ∆, yet has not seen the transaction
data by slot r, then the block is deemed to be unavailable in
the client’s view at slot r. Otherwise, the block is said to be
available. Clients only output available blocks as part of their
chains.

Security. Let Lc

r denote the chain outputted by a client c
at slot r. Let Tﬁn be a polynomial function of λ, security
parameter of the blockchain protocol. We say that the protocol
is Tﬁn-secure if the following properties are satisﬁed:

• Safety: For any slots r, r(cid:48) and clients c, c(cid:48), either Lc

preﬁx of Lc(cid:48)
of Lc

r(cid:48) or vice versa. For any client c, Lc

r(cid:48) for all slots r and r(cid:48), r(cid:48) ≥ r.

r is a
r is a preﬁx

• Tﬁn-Liveness: If Z inputs a transaction tx to an honest
r(cid:48) for any slot r(cid:48) ≥

validator at some slot r, then, tx ∈ Lc
r + Tﬁn and any client c.

Let f denote the upper bound on the number of adversarial
validators over the execution of the protocol. A PoS protocol

2Bounded clock offset can be captured as part of the network delay

6

provides fs-safety if it satisﬁes safety whenever f ≤ fs.
Similarly, a PoS protocol provides fl-Tﬁn-liveness if it satisﬁes
Tﬁn-liveness whenever f ≤ fl.

Accountable security. We formalize accountable safety
using the forensic protocol analysis [46]. During normal ex-
ecution, validators exchange messages (e.g., blocks or votes),
and each validator records all protocol-speciﬁc messages it
receives in an execution transcript. If a client observes a
safety violation, it invokes a forensic protocol by sending the
conﬂicting chains to the validators. Then, the honest validators
with information needed by the protocol send their transcripts
to the client. The forensic protocol takes these transcripts
as input, and outputs a proof that identiﬁes f adversarial
validators as protocol violators with overwhelming probability.
This proof is subsequently sent to all other clients, and serves
as evidence to convince them that the identiﬁed validators have
irrefutably violated the protocol rules. With overwhelming
probability, the forensic protocol does not identify any honest
validator as a protocol violator.

Deﬁnition 1. Accountable safety resilience of a blockchain is
the minimum number, f , of validators identiﬁed by the forensic
protocol when safety is violated. Such a protocol provides f -
accountable-safety.

In a blockchain with an accountable safety resilience of f ,
the forensic protocol detects f or more adversarial validators
as protocol violators, and does not identify any honest val-
idator in the event of a safety violation with overwhelming
probability.

Proof-of-Stake protocols. In a permissioned protocol, the
set of validators stays the same over time. This is in contrast
to PoS protocols that allow changes in the validator set. In
a Proof-of-Stake (PoS) protocol, nodes lock up stake in a
contract executed on the blockchain to become validators.
To distinguish the validators that are currently executing the
protocol at a given time from the old validators, we will refer
to the current validators as active and the older validators as
passive. We assume that each active validator has the same
stake, and is equipped with a unique cryptographic identity.
Once a validator becomes passive, it immediately becomes
adversarial if it has not been corrupted before, thus might
engage in posterior corruption attacks. Protocol execution
starts with an initial committee of n validators, and the contract
allows at most n validators to be active at any slot. We assume
that at all slots, there is a non-empty queue of nodes waiting
to stake their coins, and each validator leaving the active set
can immediately be replaced by a new validator.

The PoS protocol proceeds in epochs measured in the
number of blocks. For instance, if each epoch is scheduled
to last for m blocks and a client observes a chain of 5m + 3
PoS blocks, then the ﬁrst m blocks belong to the ﬁrst epoch,
the second m blocks to the second one, and so on, until the
last 3 blocks, which are part of the on-going epoch 6. During
an epoch, the active validator set is ﬁxed and the execution of
the PoS protocol mimicks that of a permissioned blockchain
protocol. Across epochs, the PoS protocol supports changes

in the active set through withdrawals. An active validator can
send a withdrawal request to the protocol to leave the active
set and retrieve its staked coin. At the end of each epoch,
clients inspect their chains and identify the validators whose
withdrawal requests have been included in the chain. Then, at
the next epoch, these validators are replaced with new ones
from the staking queue.

When a validator becomes leaves the active set, its coin is
not necessarily released by the contract immediately. Different
PoS protocols can have different withdrawal delays. The
to security, and will be
withdrawal mechanism is central
analyzed in subsequent sections. If a withdrawing validator’s
stake is ﬁrst released in the view of a client c at slot r, the
validator is said to have withdrawn its stake in c’s view at
slot r. In a live PoS protocol, if an honest validator sends a
withdrawal request at slot r, it should be able to withdraw its
stake in the view of all clients by slot r + T for some constant
T with overwhelming probability.

Model for Bitcoin. We model Bitcoin using the backbone
formalism [32] and treat it as a black-box blockchain proto-
col, which accepts transactions and outputs a totally ordered
sequence of Bitcoin blocks containing these transactions. To
output the Bitcoin chain conﬁrmed with parameter k at slot
r, a client c takes the longest chain of Bitcoin blocks in its
view, removes the last k blocks, and adopts the k deep preﬁx
as its Bitcoin chain at slot r. We denote the Bitcoin chain
outputted by a client c at slot r by Cc
r. If a Bitcoin block b
or transaction tx ﬁrst appears in the conﬁrmed Bitcoin chain
(hereafter called the Bitcoin chain) of a client c at slot r, we
say that tx or b has become conﬁrmed in c’s view at slot r.
We say that Bitcoin is secure with parameter k if it satisﬁes
safety and Tﬁn-liveness given the k-deep conﬁrmation rule.
Here, Tﬁn satisﬁes the following proposition:

Proposition 1 (Chain Growth). Suppose Bitcoin is secure with
parameter k with overwhelming probability. Then, for any
client c, if a transaction tx is sent to Bitcoin at slot r such that
|Cc
r(cid:48)| ≤ (cid:96) + k
with overwhelming probability.

r(cid:48) for any r(cid:48) ≥ r + Tﬁn, and |Cc

r−2∆| = (cid:96), tx ∈ Cc

If the adversarial fraction of the mining power is less than
1/2 − (cid:15) for some (cid:15) > 0, then there exists a parameter k
polynomial in λ such that Bitcoin is secure with parameter
k and satisﬁes the above proposition [32].

IV. OPTIMAL SAFETY

We next formalize the concept of slashable safety, and
analyze a simpliﬁed version of Babylon, called Babylon 1.0,
which achieves the optimal safety guarantees. The full Baby-
lon protocol with the optimal liveness guarantees is presented
in Section VI.

A. Slashable safety

A useful feature of the PoS protocols is the ability to
impose ﬁnancial punishments for protocol violators through
i.e., burning of their locked stake. Slashable
the slashing,
security extends the notion of accountability to PoS protocols.

7

A validator v becomes slashable in the view of a client c at
slot r if,
1) c has received or generated a proof through the forensic
protocol by slot r such that v is irrefutably identiﬁed as a
protocol violator,

2) v has not withdrawn its stake in c’s view by slot r.

In practice, once the contract that locks v’s stake receives
a proof accusing v, it will attempt to slash v’s stake if it is
not withdrawn yet. However, if liveness is violated, the chain
might not execute new transactions, and prevent the contract
from slashing v’s stake. Consequently, we opted to use the
word ‘slashable’ to indicate the conditional nature of slashing
on the resumption of chain activity after the security violation.
We discuss the conditions under which stake can be slashed
in Section VI-D.

Deﬁnition 2. Slashable safety resilience of a PoS protocol is
the minimum number f of validators that become slashable in
the view of all clients when safety is violated. Such a protocol
provides f -slashable-safety.

Slashable safety resilience of f implies that in the event of
a security violation, all clients identify f or more adversarial
validators as protocol violators before the validators withdraw
their stake, and no client identiﬁes any honest validator as a
protocol violator with overwhelming probability. By deﬁnition,
PoS protocols that provide f -slashable-safety also provide
f (cid:48)-accountable safety for some f (cid:48) ≥ f , and remain safe
if the number of adversarial active validators stay below f
throughout the protocol execution.

B. Slashable safety is not possible without external trust

Without additional trust assumptions, no PoS protocol can
provide slashable safety. Suppose there is a posterior corrup-
tion attack, and a late-coming client observes two conﬂicting
chains. As the client could not have witnessed the attack
in progress, it cannot distinguish the attack chain from the
canonical one. Hence, it cannot irrefutably identify any val-
idator active on either chain as a protocol violator. Although
the client might see that the old validators that have initiated
the posterior corruption attack violated the protocol rules by
signing conﬂicting blocks, these validators are not slashable as
they have already withdrawn their stake. Hence, no validator
becomes slashable in the client’s view. This fact is formalized
by the following theorem, proven in Appendix A:

Theorem 1. Assuming common knowledge of the initial set of
active validators, without additional trust assumptions, no PoS
protocol provides both fs-slashable-safety and fl-Tﬁn-liveness
for any fs, fl > 0 and Tﬁn < ∞.

Key-evolving signatures and VDFs. Although KES and
VDFs prevent long range attacks, as Theorem 1 indicates, they
cannot provide slashable safety. To emphasize this point, we
present the following attack. Suppose the adversary controls
a supermajority of the active validators. In the case of KES,
the adversarial active validators can record their old keys, and
use them to initiate a long range attack after withdrawing

their stake. They can thus cause a safety violation, yet, cannot
be slashed as the stake is withdrawn. In the case of VDFs,
the adversarial active validators can again construct a private
attack chain while they work on the canonical one, and run
multiple VDF instances simultaneously for both chains. After
withdrawing their stake, they publish the attack chain with
the correct VDF proofs, causing a safety violation without
any slashing of their stake.

C. Babylon 1.0 protocol with fast ﬁnality

Algorithm 1 The function used by the client c to ﬁnd the canonical
PoS chain at some slot r. It takes the blocktree T , the conﬁrmed
Bitcoin chain C, the sequence of checkpointed block hashes h on C
(in order of their epoch numbers) in c’s view at slot r as input, and
outputs Lc
r. The function GETACTIVEVALS takes a blocktree T , a
block B and an epoch number ep, and outputs the active validators
for the queried epoch as determined by the preﬁx of the given block.
The function ISSIGNED checks if there are signatures on the given
hash h from over 2n/3 of the active validators within the associated
checkpoint on Bitcoin. The function GETFINALIZEDBLOCKS returns
the ﬁnalized blocks within the given blocktree that correspond to the
preimage of the given checkpoint and its preﬁx. It returns ⊥ if one
of these blocks is unavailable or unﬁnalized. The function ISLAST
returns true iff the given PoS block is the last block of the provided
epoch. The function GETCHILDREN returns the set of children of the
given block within the blocktree.

h1, . . . , hm ← h
ckpt, ep, actval ← B0, 1, GETACTIVEVALS(T , B0, ep)
for i = 1 to m

(cid:46) Obtaining the checkpointed chain

Bi ← GETFINALIZEDBLOCKS(T , hi)
if Bi (cid:54)= ⊥ ∧ ckpt[−1] (cid:22) Bi

(cid:46) Adding blocks for epoch ep to ckpt
ckpt ← Bi
if ISLAST(T , Bi, ep)
ep ← ep + 1
actval ← GETACTIVEVALS(T , Bi, ep)

(cid:46) Chain ending at Bi

(cid:46) Send checkpoint to Bitcoin for L
return ckpt

(cid:46) Stall: Data Unavailable

if ISSIGNED(C, hi, actval)

1: function OUTPUTPOSCHAIN(T , h, C)
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
end while
25:
return L
26:
27: end function

end for
ch ← GETCHILDREN(T , ckpt[−1])
L ← ckpt
while |ch| = 1
L ← L (cid:107) ch
ch ← GETCHILDREN(T , ch)

end if
else if Bi = ⊥

end if

end if

(cid:46) Attach ch to chain

To provide PoS protocols with slashable safety, Bitcoin
can be used as an additional source of trust. Babylon 1.0 is
a checkpointing protocol which can be applied on any PoS
blockchain protocol with accountable safety (e.g., PBFT [26],
Tendermint [22], HotStuff [50], and Streamlet [27]) to upgrade
the accountability guarantee to slashable safety. We next
describe Babylon 1.0 applied on Tendermint, which satisﬁes
n/3-accountable safety.

8

Let c denote a client (e.g., a late-coming client, an honest
validator), whose goal is to output the canonical PoS chain
L that
is consistent with the chains of all other clients.
We assume that c is a full node that downloads the PoS
block headers and the corresponding transaction data upon
observing the protocol. It also downloads the Bitcoin blocks
and outputs a Bitcoin chain C, conﬁrmed with parameter k.
In the description below, ﬁnalized blocks refer to the PoS
blocks ﬁnalized by Tendermint (i.e., the blocks that gathered
a 2/3 quorum of pre-commit signatures by the corresponding
active validator set [22]). Finalization by Tendermint does not
necessarily mean that the block is included in the PoS chain
L outputted by any client. For instance, when the adversary
engages in a posterior corruption attack,
there would be
conﬂicting PoS blocks that look ﬁnalized, forcing the clients
to choose a subset of these blocks as part of their canonical
PoS chain. Algorithm 1 describes how clients can use Bitcoin
to construct the canonical chain from the ﬁnalized blocks.

a) Checkpointing the PoS chain: At the end of each
epoch, the honest active validators sign the hash of the last
ﬁnalized PoS block of the epoch. Then, an honest active
validator v sends a Bitcoin transaction called the checkpoint
transaction. The transaction contains the hash of the block,
its epoch and a quorum of signatures on the hash from
over 2n/3 active validators of the epoch. These signatures
can be a subset of the signatures (e.g., Tendermint’s pre-
commit signatures) that have ﬁnalized the block within the
PoS protocol. We hereafter refer to the block hash, epoch
number and the accompanying signatures within a checkpoint
transaction collectively as a checkpoints.

Suppose v observes multiple ﬁnalized and conﬂicting PoS
blocks. As Tendermint provides n/3-accountable safety, it can
generate a proof that irrefutably identiﬁes n/3 adversarial PoS
validators as protocol violators. In this case, v posts this proof,
hereafter called the fraud proof, to Bitcoin.

b) Fork-choice rule: (Alg. 1, Figure 1) To output the
canonical PoS chain Lc
r at some slot r, c ﬁrst constructs a
blocktree of ﬁnalized PoS blocks. Let hj, j ∈ [m], denote
the sequence of block hashes within checkpoints on Bitcoin,
listed from the genesis to the tip of Cc
r, the conﬁrmed Bitcoin
chain in c’s view at slot r. Starting at the genesis PoS block
B0, c constructs a checkpointed chain ckptc
r of PoS blocks by
sequentially going through these checkpoints. Let Bj denote
the block at the preimage of hj if the block is available in c’s
view at slot r. Suppose Bi from epoch ei is the last PoS block
appended to the checkpointed chain, and c has gone through
the sequence of checkpoints until hj, j ≥ i. Let ˜e = ei + 1 if
Bi is the last block of its epoch; and ˜e = ei otherwise.

1) (Alg. 1, Line 7) If (i) the block Bj+1 is from epoch
˜e, (ii) Bj+1 and every block in its preﬁx are available
and ﬁnalized in c’s view by the active validators of their
respective epochs, (iii) Bj+1 extends Bi, and (iv) the
checkpoint of hj+1 on Bitcoin contains 2n/3 signatures
by the active validators of the epoch ˜e, then c sets Bj+1
and its preﬁx as the checkpointed chain.

9

Fig. 3: There is an epoch e block containing a withdrawal request and the hash of the last epoch e block and the signatures from the
corresponding active validator set appear in a conﬁrmed Bitcoin block in a client’s view. The validator is granted permission to withdraw
its stake once the Bitcoin block with the checkpoint becomes k deep in the conﬁrmed Bitcoin chains of sufﬁciently many validators.

2) Emergency Break: (Alg. 1, Line 14, Figure 2) If (i)
Bj+1 or a block in its preﬁx is either unavailable or not
ﬁnalized by its respective validators in c’s view, and (ii) the
checkpoint of hj+1 on Bitcoin contains 2n/3 signatures
by the active validators of the epoch ˜e, then c stops going
through the sequence hj, j ∈ [m], and outputs Bi and its
preﬁx as the checkpointed chain3. This premature stalling
of the fork-choice rule is necessary to prevent the data
availability attack described by Figure 2.

3) If both of the cases above fail, c skips hj+1 and moves to
hj+2 and its pre-image block as the next candidate.
Unless case (2) happens, c sifts through hj, j ∈ [m], and
subsequently outputs the checkpointed chain ckptc
r. If (2) hap-
pens, then c outputs Bi and its preﬁx as both the checkpointed
chain ckptc
r. However, if c
had previously outputted ﬁnalized blocks extending Bi as part
of its PoS chain, it does not roll back these blocks. Instead,
it freezes its old PoS chain as Lc
r, and sends a checkpoint
transaction to Bitcoin for the block at the tip of Lc
r, with the
signatures that have previously ﬁnalized the block.

r and the canonical PoS chain Lc

Finally, suppose c outputs a checkpointed chain with some
block B at its tip. Then, starting at B, c traverses a path to the
leaves of the blocktree (Alg. 1, Line 21 onward). If there is a
single chain from B to a leaf, c outputs the leaf and its preﬁx
as the PoS chain Lc
r. Otherwise, c identiﬁes the last PoS block
B(cid:48) (potentially the same as B) in the subtree of B, which has
no conﬂicting siblings within the subtree, and outputs B(cid:48) and
its preﬁx as Lc
r. Since c attaches the latest ﬁnalized PoS blocks
to the tip of its PoS chain Lc
r, as long as there are no forks
among ﬁnalized PoS blocks, the time for transactions to enter
Lc
r matches the latency of the PoS protocol, hence rendering
fast ﬁnality to the protocol.

c) Stake withdrawals: (Figure 3) To withdraw its stake, a
validator v ﬁrst sends a PoS transaction called the withdrawal
request. It is granted permission to withdraw in a client c’s
view at slot r if
1) The withdrawal request appears in a PoS block B in c’s

checkpointed chain ckptc
r.

2) Checkpoint of B or one of its descendants appears in a

Bitcoin block that is at least k deep in Cc
r.

3) The client has not observed any fraud proof in Cc

r that
identiﬁes v as a protocol violator. Similarly, the client has

3The client c knows the active validator set for all epochs e ≤ ˜e. By
construction, the last block Bi in its checkpointed chain and every block in
Bi’s preﬁx are available in c’s view. If Bi is the last block of epoch ei, c
can infer the active validator set of epoch ei + 1 from Bi and its preﬁx.

not observed checkpoints for conﬂicting PoS blocks in Cc
r,
which were signed by v. (Signatures of v on conﬂicting
PoS blocks imply a protocol violation.)

Once the above conditions are satisﬁed in the validator v’s
view, it sends a withdrawal transaction to the PoS chain. An
honest active validator includes this transaction in its PoS
block proposal if the above conditions are satisﬁed in its
view. Upon observing a PoS proposal containing a withdrawal
the honest active validators wait for ∆ slots
transaction,
before they sign the block. Afterwards, they sign the proposal
only if the above conditions are also satisﬁed in their views.
By synchrony, if the conditions are satisﬁed in an honest
proposer’s view at the time of proposal, then they are satisﬁed
in the view of all honest active validators at the time of signing.
Thus, the ∆ delay ensures that v’s transaction is ﬁnalized by
the PoS chain despite potential, short-lived split views among
the honest active validators. Once the transaction is ﬁnalized,
the on-chain contract releases v’s locked coin.

d) Slashing: Suppose a validator v has provably violated
the protocol rules. Then, the contract on the PoS chain slashes
v’s locked coins upon receiving a fraud proof incriminating v
if the PoS chain is live and v has not withdrawn its stake.

If a client c observes a fraud proof incriminating v in its
conﬁrmed Bitcoin chain Cc
r at slot r, c does not consider v’s
signatures on future checkpoints as valid. It also does not
consider v’s signatures as valid when verifying the ﬁnality of
the PoS blocks checkpointed on Bitcoin for the ﬁrst time after
the fraud proof. For instance, suppose c observes a checkpoint
for a PoS block Bj in its Bitcoin chain. While verifying
whether Bj and the blocks in its preﬁx (that have not yet been
checkpointed yet) are ﬁnalized, c considers signatures only by
the active validators that have not been accused by a fraud
proof appearing in the preﬁx of the checkpoint on Bitcoin.

D. Security analysis
Proposition 2. Suppose Bitcoin is safe with parameter k with
overwhelming probability. Then, the checkpointed chains held
by the clients satisfy safety with overwhelming probability.

Proof is provided in Appendix C, and uses the fact that
the safety of Bitcoin implies consensus on the sequence of
checkpointed blocks.

Theorem 2 (Slashable Safety). Suppose Bitcoin is secure
with parameter k with overwhelming probability, and there is
one honest active validator at all times. Then, the Babylon
1.0 protocol with fast ﬁnality (Section IV-C) satisﬁes n/3-
slashable safety with overwhelming probability.

10

Theorem 3 (Liveness). Suppose Bitcoin is secure with pa-
rameter k with overwhelming probability, and the number of
adversarial active validators is less than n/3 at all times.
Then, the Babylon 1.0 protocol with fast ﬁnality (Section IV-C)
satisﬁes Tﬁn-liveness with overwhelming probability, where
Tﬁn = Θ(λ).

the number of transactions needed per checkpoint from 54
to 2. In each of the two transactions, the OP_RETURN also
includes a ﬁxed tag of 4 bytes for the letters ‘BBNT’ to signal
the Babylon checkpoints. This makes the total size of the
transactions 195 and 183 bytes, respectively.
B. Measurements

Proofs of Theorems 2 and 3 are presented in Appendix C.

V. EXPERIMENTS

Babylon allows a validator to withdraw its stake once the
checkpoint of the PoS block containing the withdrawal request
becomes k deep in the conﬁrmed Bitcoin chain. This implies
a withdrawal delay on the order of Bitcoin’s conﬁrmation la-
tency for the checkpoints, as opposed to the week long periods
imposed by many PoS chains (cf. Section II). To measure
the reduction in the withdrawal delay and to demonstrate the
feasibility of using Bitcoin for checkpointing, we implemented
a prototype checkpointer. We sent periodic checkpoints to the
Bitcoin Mainnet via the checkpointer to emulate the operation
of Babylon 1.0 securing a Cosmos zone and measured the
conﬁrmation times of the checkpoints.

A. Checkpoints

Our checkpointer utilizes Bitcoin’s OP_RETURN opcode,
which allows 80 bytes of arbitrary data to be recorded in an
unspendable transaction [4] (cf. [18] for an empirical study of
the data within OP_RETURN transactions). Checkpoints en-
visioned in Section IV-C consist of an epoch number, the hash
of the last PoS block of the epoch, and signatures by 2/3 of the
validator set. In Tendermint, the consensus protocol of Cosmos
zones, each pre-commit signature is of 64 bytes [3]. Although
Cosmos zones can autonomously determine the number of
active validators, prominent ones such as Osmosis and Cosmos
Hub feature 100 to 175 validators [11], [7]. However, if we
naively include signatures by 2/3 of 100 validators in the
checkpoints, a single checkpoint would be ∼ 4.3 kBytes,
requiring at least 54 separate Bitcoin transactions to post the
information within one checkpoint.

To reduce the number of transactions needed per checkpoint,
Cosmos zones can adopt Schnorr [45] or BLS [20] signatures
that allow signature aggregation. In our experiments, we
consider a Cosmos zone that uses BLS signatures. To construct
a checkpoint, we ﬁrst generate a hash of 32 bytes, representing
a block hash, and 67 BLS signatures on the hash, each of 48
bytes. They correspond to pre-commit signatures by a 2/3
quorum of 100 validators. We then aggregate these 67 BLS
signatures into a single one4. Thus, our checkpoints contains
(i) an epoch number of 8 bytes, (ii) a hash of 32 bytes, obtained
via Tendermint’s LastCommitHash [3], (iii) an aggregate BLS
signature of 48 bytes, and (iv) a bit map of 13 bytes5. This
implies a total size of 111 bytes per checkpoint, reducing

4It takes 0.143 ms to generate one BLS signature, and 0.042 ms to
aggregate 67 BLS signatures on an Apple Macbook Pro M1 machine using
the codebase [2].

5The bit map is included to emulate an actual implementation, where the
clients use the map to identify which validators’ signatures were aggregated.

In our experiment, we estimate the withdrawal delay of a
PoS protocol using Babylon 1.0. This delay consists of two
components: (i) the time to send the ﬁrst checkpoint for a PoS
block including the withdrawal request in its preﬁx, and (ii)
the time for the checkpoint to become conﬁrmed, i.e., k-deep
in Bitcoin, after it is sent. The ﬁrst component is captured by
the epoch length of the PoS protocol as a checkpoint is sent at
every epoch. In this context, we sent hourly checkpoints over
the duration of one day6, for an epoch length of one hour.
At every hour, two pairs of OP_RETURN transactions for
two identical checkpoints were broadcast: one pair sent with
a miner fee of 12 Satoshis/byte, and the other sent with a fee
of 3 Satoshis/byte. Given the transaction sizes, and the Bitcoin
price7, this implies a total cost of 1.07 USD per checkpoint
at the fee level of 12, and 0.27 USD per checkpoint at the
level of 3 Satoshis/byte. The fee levels were ﬁxed before
the experiments with the help of a Bitcoin transaction fee
estimator [1], which displayed 12 and 3 Satoshis as the fees
to have the transaction mined within the next block, and the
next 6 blocks, respectively.

For each checkpoint associated with a different fee, we
measured (i) the time Tk=6 for both transactions to be at least
k = 6 deep, and (ii) the time Tk=20 for both to be at least
k = 20 deep. The conﬁrmation depth k = 6 was chosen
following the conventional conﬁrmation rule for Bitcoin. The
depth k = 20 achieves a low probability (10−7) of safety
violation for the blocks containing the checkpoints [37, Figure
2]8. We report the mean and standard deviation for these
parameters across the 24 checkpoints in Table II9.

Checkpointing cost per annum Tk=6 (mins)

Tk=20 (mins)

9373 USD

2365 USD

69.7 ± 20.7

192.7 ± 26.1

77.0 ± 21.2

204.1 ± 31.2

TABLE II: Mean and standard deviation for Tk=6 and Tk=20 for the
checkpoints sent over a day at two different fee levels

Table II shows that at an annual cost of less than 10, 000
USD, a PoS chain using Babylon can reduce its withdrawal
delay from weeks to below 4 hours. The small cost of
checkpointing is achieved thanks to aggregate signatures, in
the absence of which the cost would be on the order of millions
of USD per year.

6Experiment was started at 1 am August 18, 2022, and run until 1 am

August 19 (PT).

71 BTC is taken as 23, 563.83 USD, the maximum Bitcoin price observed
on August 18, 2022, as reported by https://coinmarketcap.com/currencies/
bitcoin/historical-data/.

8This is for an adversary controlling 10% of the hash rate, given a network

delay of 10 seconds

9The data and the exact OP_RETURN bytes can be accessed at https:

//anonymous.4open.science/r/Babylon-checkpoints-7357/measurements.txt

11

for the canonical chain. At this point, inactivity leak kicks in,
and gradually slashes the stake of the adversarial validators on
the canonical chain to recover liveness. Similarly, the honest
validators lose their stake on the private attack chain due
to inactivity leak. Finally, the adversary publishes the attack
chain, which is subsequently adopted by a late-coming client.
As there are conﬂicting chains in different clients’ views, this
is a safety violation, and by accountable safety, the client
identiﬁes at least one validator as a protocol violator. Since the
client could not have observed the attack in progress, it cannot
distinguish the attack chain from the canonical one. As a result,
with non-negligible probability, it adopts the attack chain,
and identiﬁes the honest validators on the canonical chain
as protocol violators. This contradicts with the accountability
guarantee.

In the attack above, the data-limited timestamping service
cannot help the late-coming client distinguish between the
canonical and attack chains. The honest validators cannot
timestamp the entirety of public blocks on a data-limited
service. Thus, they cannot prove to a late-coming client that
the canonical chain was indeed public before the attack chain
was published. This enables the adversary to plausibly claim
to a late-coming client that the canonical chain was initially
private, and its private attack chain was the public one.

The proof of Theorem 4 is given in Appendix B, and
generalizes the attack on inactivity leak to any PoS or per-
missioned protocol. It exploits the indistinguishability of two
worlds with different honest and adversarial validator sets,
when the adversary controls over half of the validators, and
the timestamping service is data-limited.

B. Optimal liveness: full Babylon protocol with fast ﬁnality

We now analyze whether Bitcoin, despite its data limitation,
can help increase the liveness resilience of Babylon 1.0 pre-
sented in Section IV-C. Babylon 1.0 provides n/3-slashable-
safety and n/3-liveness; yet Theorem 4 only states that the
liveness resilence of an accountably safe protocol cannot
exceed n/2. To close this gap, we next improve Babylon 1.0
and achieve the optimal liveness resilience of n/2. Note that
by [46, Appendix B], liveness resilience of a PoS protocol
that provides n/3-accountable-safety cannot exceed n/3 in the
absence of external trust, so the improvement of Babylon’s
resilience from n/3 to n/2 depends crucially on the use of
the data-limited timestamping service. Indeed, if the adversary
controls f ∈ [n/3, n/2) of the active validators and violates
liveness, the improved protocol uses Bitcoin as a fallback
mechanism to guarantee eventual liveness.

The full Babylon protocol proceeds in two modes:
the
normal mode and the rollup mode, where Bitcoin plays a
more direct role in the ordering of the PoS blocks. Execution
starts and continues in the normal mode as long as no PoS
transaction is censored. If a transaction is observed to be
censored, clients can force the execution to switch to the
rollup mode. During the normal mode, checkpointing of the
PoS chain, fork-choice rule, stake withdrawals and slashing
work in the same way as described in Section IV-C (cf.

Fig. 4: Inactivity leak attack. At the top is adversary’s private attack
chain. At the bottom is the public canonical chain built by the honest
validators. Due to inactivity leak, honest and adversarial validators
lose their stake on the attack and canonical chains respectively. A late-
coming client cannot differentiate the canonical and attack chains.

VI. OPTIMAL LIVENESS
Babylon 1.0 provides slashable safety to Tendermint. How-
ever, the protocol guarantees liveness only when 2/3 of the
active validators is honest. We next explore how Babylon 1.0
can be improved to achieve the optimal liveness guarantees.

A. No liveness beyond 1/2 adversarial fraction

Our ﬁrst result is that no PoS protocol can achieve a liveness
resilience of fl ≥ 1/2 even with the help of Bitcoin, or for
that matter any timestamping service, unless the entirety of
the PoS blocks are uploaded to the service.

Timestamping service. Timestamping service is a consensus
protocol that accepts messages from the validators, and pro-
vides a total order across these messages. All messages sent
by the validators at any slot r are outputted in some order
determined by the service, and can be observed by all clients
at slot r + 1. If a client queries the service at slot r, it receives
the sequence of messages outputted by the service until slot
r. The service imposes limitations on the total size of the
messages that can be sent during the protocol execution.

Theorem 4. Consider a PoS or permissioned protocol with n
validators in a ∆ synchronous network such that the protocol
provides fs-accountable-safety for some fs > 0, and has
access to a timestamping service. Suppose each validator is
given an externally valid input of m bits by the environment
Z, but the number of bits written to the timestamping service
is less than m(cid:98)n/2(cid:99) − 1. Then, the protocol cannot provide
fl-Tﬁn-liveness for any fl ≥ n/2 and Tﬁn < ∞.

To give some intuition for the theorem, we analyze inac-
tivity leak, used by Cosmos zones [5] and proposed for PoS
Ethereum [19] to slash inactive validators and recover from
liveness attacks. We show that when the adversary controls
half of the validators, it can do a safety attack, where inactivity
leak results in a gradual slashing of the honest validators’ stake
in the view of late-coming clients.

Consider an accountably safe consensus protocol with the
setup on Figure 4. Half of the validators are adversarial, and
build an attack chain that is initially kept private. They do
not communicate with the honest validators or sign the blocks
on the public, canonical chain. As the honest validators are
not privy to the adversary’s actions, they also cannot sign the
blocks on the attack chain. Since only half of the validators are
voting for the public blocks, liveness is temporarily violated

12

Fig. 5: If tx1 is observed to be censored by an honest validator v, it sends a liveness transaction to Bitcoin. Once the liveness transaction
becomes 2k deep in v’s and the clients’ views, they enter the rollup mode. In the rollup mode, validators group transactions into bundles
and post signed hashes of these bundles on Bitcoin.

Alg. 2 for the complete fork-choice rule of the full Babylon
protocol). Thus, we next focus on how censorship is detected
and communicated by the clients, and the protocol execution
in the rollup mode.

r+Ttm

a) Checkpointing: If a transaction tx, input to an honest
validator by the environment Z at slot r, has not appeared in
Lv
in an honest validator v’s PoS chain, v sends a liveness
transaction to Bitcoin. The liveness transaction contains the
censored tx, and signals a liveness violation in v’s view. Here,
Ttm represents the latency for a transaction to be included in
a ﬁnalized Tendermint block.

Suppose there is a block b within an honest validator v’s
Bitcoin chain that contains a liveness transaction for some
censored tx. Upon observing b become k deep, v sends a
checkpoint transaction for the block at the tip of its PoS chain,
even if the block is not the last block of its epoch. If tx is not
in its checkpointed chain, v also stops executing Tendermint.
When b becomes 2k deep in its Bitcoin chain, if tx is still not
in v’s checkpointed chain, v enters the rollup mode.

Once in the rollup mode, each honest validator collects
transactions into bundles that are broadcast to all other valida-
tors. Upon observing a bundle of externally valid transactions,
honest validators sign the hash of the bundle. If an honest
validator observes a bundle whose hash has been signed by
over n/2 validators, it posts the hash of the bundle and the
signatures to Bitcoin.

b) Fork-choice rule (Figure 5, Alg. 2): Consider a client
c that observes the protocol at some slot r(cid:48) ≥ r+Ttm. Suppose
there is a block b within Cc
r(cid:48) that contains a liveness transaction
for some censored tx. Once b becomes k deep in c’s Bitcoin
chain, if tx is still not in c’s checkpointed chain, c freezes its
PoS chain. At this point, c also sends a checkpoint transaction
for the block at the tip of its PoS chain, even if the block is
not the last block of its epoch. Afterwards, c outputs new PoS
blocks as part of its PoS chain, only if these new blocks are
also part of its checkpointed chain (Alg. 2, Line 45). Note that
if c was previously awake and has already outputted blocks
beyond its checkpointed chain when the PoS chain was frozen,
it does not roll back these blocks. If c observes tx within its
checkpointed chain by the time b becomes 2k deep, it resumes
outputting new blocks as part of its PoS chain, and continues
the protocol execution in the normal mode. Otherwise, once
b becomes 2k deep in c’s Bitcoin chain, if tx is not yet in
c’s checkpointed chain, it enters the rollup mode (Figure 5,
Alg. 2, Line 6).

Once in the rollup mode, c ﬁrst constructs the checkpointed
chain by observing the preﬁx of its Bitcoin chain that ends at
the 2kth block extending b. Suppose Bi from epoch ei is the
last PoS block appended to this checkpointed chain, and it is
followed by a sequence hj, j ∈ [m], of signed hash values for
bundles in c’s Bitcoin chain. Let ˜e = ei + 1 if Bi is the last
block of epoch ei, and ˜e = ei otherwise. After constructing
the checkpointed chain, c sifts through hj, j ∈ [m], iteratively,
and for each j ∈ [m], acts as follows:
1) (Alg. 2, Line 36) If hj is signed by over n/2 active
validators of epoch ˜e, and its pre-image bundle is available
in c’s view, then c attaches the bundle to its PoS chain.
2) (Alg. 2, Line 38) If hj is signed by over n/2 active
validators of epoch ˜e, and its pre-image bundle is not
available in c’s view,
then c stops going through the
sequence hj, j ∈ [m], and returns its current PoS chain.
3) If neither of the conditions above are satisﬁed, c skips hj,

and moves to hj+1 as the next candidate.

The client c leaves the rollup mode when it sees the T th
btc
Bitcoin block extending b (cf. Alg. 2 Line 8). Here, Tbtc is a
protocol parameter for the duration of the rollup mode. After
exiting the rollup mode, validators treat the hash of the last
bundle as the parent hash for the new PoS blocks, and execute
the protocol in the normal mode10.

C. Safety analysis

Theorem 5. Suppose Bitcoin is secure with parameter k
with overwhelming probability, and there is one honest ac-
tive validator at all times. Then, the Babylon protocol (Sec-
tion VI-B) with fast ﬁnality satisﬁes n/3-slashable safety with
overwhelming probability.

The proof is presented in Appendix C.

D. Slashing and liveness after a safety violation

Theorem 5 states that as long as Bitcoin is secure, at least
n/3 adversarial validators become slashable in the view of all
clients when there is a safety violation. However, the theorem
does not specify whether these validators can be slashed at all.
Indeed, slashing can only be done if the PoS chain is live, a
condition that might not be true after a safety violation.

When blocks on two or more conﬂicting chains are ﬁnalized
by Tendermint, the chain with the earlier checkpoint in Bitcoin

10It is possible to support stake withdrawals during the rollup mode, once
the bundles containing withdrawal requests and signed by over half of the
active validators of epoch ˜e become k deep in Bitcoin.

Algorithm 2 The function used by the client c to ﬁnd the canonical
PoS chain Lc
r at a given slot r. Here, ti denotes the type of the
transaction on Bitcoin, which can either be a checkpoint transaction,
liveness transaction or a bundle. If ti is a checkpoint transaction or
bundle, hi denotes the block or bundle hash, whereas if ti is a liveness
transaction, hi denotes the censored transaction itself. The functions
are deﬁned in the caption of Algorithm 1 except for GETHEIGHT,
which returns the height of the Bitcoin block containing the given
block or bundle.

(cid:46) Chain ending at Bi

end if
(cid:46) Obtaining the checkpointed chain
if ti = checkpoint∧¬rmode∧ ISSIGNED(C, hi, actval)

end if

rmode, ht ← False, −1

censor, censortx, ht ← False, ⊥, −1

if censor ∧ GETHEIGHT(hi) ≥ ht + 2k

end if
else if Bi = ⊥
return ckpt

end if
if censor ∧ (censortx ⊆ ckpt)

Bi ← GETFINALIZEDBLOCKS(T , hi)
if Bi (cid:54)= ⊥ ∧ ckpt[−1] (cid:22) Bi

rmode, censor, censortx ← True, False, ⊥
else if rmode ∧ GETHEIGHT(hi) ≥ ht + 2k + Tbtc

ckpt ← Bi
if ISLAST(T , Bi, ep)
ep ← ep + 1
actval ← GETACTIVEVALS(T , Bi, ep)

1: function OUTPUTPOSCHAIN(T , h, C)
(t1, h1), . . . , (tm, hm) ← h
2:
ckpt, ep, actval ← B0, 1, GETACTIVEVALS(T , B0, ep)
3:
rmode, censor, censortx, ht ← False, False, ⊥, −1
4:
for i = 1 to m
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32:
33:
34:
35:
36:
37:
38:
39:
40:
41:
42:
43:
44:
45:
46:
47:
48:
end while
49:
return L
50:
51: end function

end for
L, ch ← ckpt, GETCHILDREN(T , ckpt[−1])
while |ch| = 1

end if
L, ch ← L (cid:107) ch, GETCHILDREN(T , ch)

Bi ← GETFINALIZEDBLOCKS(T , hi)
if Bi (cid:54)= ⊥

tx, ht ← hi, GETHEIGHT(hi)
if (tx (cid:54)⊆ ckpt) ∧ ¬censor

end if
(cid:46) Bundle detected

if rmode ∨ (censor ∧ |C| ≥ ht + k)

else if Bi = ⊥
return ckpt

else if ti = liveness ∧ ¬rmode

censor, censortx ← True, {tx}

censortx ← censortx ∪ {tx}

else if (tx (cid:54)⊆ ckpt) ∧ censor

ckpt ← ckpt (cid:107) Bi

Break

end if

end if

(cid:46) Attach Bi to the chain

(cid:46) Stall: Data Unavailable

else if ti = bundle ∧ rmode ∧ ISSIGNED(C, hi, actval)

(cid:46) Stall: Data Unavailable

(cid:46) Liveness block

13

is chosen as the canonical one. However, the honest active
validators might not unlock from the conﬂicting chains they
have previously signed and start extending the canonical chain,
as that would require them to sign conﬂicting blocks. Due to
the absence of signatures from these stuck validators, the PoS
chain might stall after a safety violation. Then, even though
the validators that have caused the safety violation become
slashable, the on-chain contract cannot slash them since the
chain itself is not live.

This issue of liveness recovery after a safety violation
is present in many BFT protocols, which strive to support
accountability. For example, Cosmos chains enter into a panic
state when safety is violated, and need a manual reboot based
on social consensus with slashing done off chain [6]. With
Bitcoin, however, this problem can be solved to an extent. As
in the case of stalling or censorship, after which the protocol
switches to the rollup mode, the honest validators can use
Bitcoin to unstuck from their respective forks, bootstrap the
PoS chain, and slash the adversarial validators if the honest
validators constitute over half of the active validator set.
They can use the same process described in Section VI-B for
entering the rollup mode: Once the PoS chain loses liveness,
an honest validator posts a liveness transaction to Bitcoin for
the censored PoS transactions. Soon afterwards, the honest
PoS validators enter the rollup mode. This is because new
checkpoints appearing on Bitcoin and signed by the slashable
validators will not be considered valid by the honest validators,
and cannot prevent the protocol from switching to the rollup
mode. Once in the rollup mode, with their majority, the honest
PoS validators can sign new bundles, and send the bundle
hashes along with their signatures to Bitcoin. Through these
new bundles, they can ﬁnalize the censored transactions, and
slash the adversarial validators that have become slashable via
the on-chain contract.

After n/3 adversarial active validators are slashed,
the
remaining n/2 honest validators constitute a supermajority of
the active validator set. By treating the last bundle of the rollup
mode as the new genesis block, they can switch back to the
normal mode, and continue ﬁnalizing new PoS blocks through
Tendermint (Alg. 2, Line 8). Thus, the PoS chain can bootstrap
liveness, and eventually return to the normal mode with fast
ﬁnality after the safety violation.

With the ability to bootstrap liveness after a safety violation,

we can state the following theorem:

Theorem 6. Suppose Bitcoin is secure with parameter k, and
the number of adversarial active validators is less than n/2 at
all times. Then, the Babylon protocol (Section VI-B) with fast
ﬁnality satisﬁes Tﬁn-liveness with overwhelming probability,
where Tﬁn is a polynomial in the security parameter λ.

The proof is presented in Appendix C.

VII. BABYLON WITH SLOW FINALITY: BITCOIN SAFETY

So far in the paper, we have focused on the scenario where
the clients of the PoS chain use the native fast ﬁnality rule,
where blocks are ﬁnalized upon gathering signatures from the

PoS validators. Since Bitcoin conﬁrmation operates at a slower
time scale, Bitcoin cannot protect the PoS chain against safety
attacks under the fast ﬁnality rule. Bitcoin instead makes these
attacks slashable by not allowing the attackers to withdraw
stake after signing conﬂicting blocks. To achieve Bitcoin safety
for transactions, a client can choose to use a slow ﬁnality rule,
which requires a PoS block to be checkpointed by Bitcoin in
addition to its ﬁnalization on the PoS chain. More speciﬁcally,
a client c using the slow ﬁnality rule sets its PoS chain to be the
same as its checkpointed chain at any time slot: Lc
r. A
major drawback of this scheme is its lateny: client now waits
until the PoS block hashes and the signatures are k deep in
Bitcoin, before it can output them as part of its PoS chain.

r = ckptc

Corollary 1. Suppose Bitcoin is secure with parameter k
with overwhelming probability, and there is an honest active
validator at all times. Then, the Babylon protocol with slow
ﬁnality satisﬁes safety with overwhelming probability.

Proof follows from Proposition 2. Corollary 1 holds for any

number of adversarial active validators less than n.

Corollary 2. Suppose Bitcoin is secure with parameter k
with overwhelming probability, and the number of active
adversarial validators is less than n/2 at all times. Then, the
Babylon protocol with slow ﬁnality satisﬁes Tﬁn-liveness with
overwhelming probability, where Tﬁn is a polynomial in the
security parameter λ.

Proof is given in Appendix C.

ACKNOWLEDGEMENTS

We thank Kamilla Nazirkhanova, Joachim Neu, Lei Yang
and Dionysis Zindros for several insightful discussions on this
project. We thank Dionysis Zindros also for his help with the
experiments.

Ertem Nusret Tas was supported by the Stanford Center for

Blockchain Research.

REFERENCES

[1] Bitcoin Transaction Fee Estimator & Calculator. https://coinmarketcap.

com/.

[2] blst. https://github.com/supranational/blst.
[3] Data structures.

https://docs.tendermint.com/master/spec/core/data_

structures.html.

[4] Op_return. https://en.bitcoin.it/wiki/OP_RETURN.
[5] Running a validator.
validator-setup.html.

https://hub.cosmos.network/main/validators/

[6] Running in production. https://docs.tendermint.com/v0.34/tendermint-

core/running-in-production.html.
overview.

[7] Validators

https://hub.cosmos.network/main/validators/

overview.html.

[8] What is staking? https://docs.avax.network/nodes/validate/staking.
[9] Komodo. Advanced blockchain technology,

focused on freedom.

https://docs.komodoplatform.com/whitepaper/introduction.html#
intoduction-to-komodo, 2018. Accessed: 2022-07-10.

14

[13] Aditya Asgaonkar.

Weak Subjectivity in Eth2.0.

https:

//notes.ethereum.org/\spacefactor\@m{}adiasg/weak-subjectvity-
eth2#Distributing-Weak-Subjectivity-Checkpoint-States, 2019.

[14] Sarah Azouvi, George Danezis, and Valeria Nikolaenko. Winkle: Foiling
long-range attacks in proof-of-stake systems. In AFT, pages 189–201.
ACM, 2020.

[15] Sarah Azouvi and Marko Vukolic. Pikachu: Securing pos blockchains
from long-range attacks by checkpointing into bitcoin pow using taproot.
arXiv:2208.05408, 2022.

[16] Christian Badertscher, Peter Gazi, Aggelos Kiayias, Alexander Russell,
and Vassilis Zikas. Ouroboros Genesis: Composable proof-of-stake
blockchains with dynamic availability. In CCS, pages 913–930. ACM,
2018.

[17] Simon Barber, Xavier Boyen, Elaine Shi, and Ersin Uzun. Bitter to better
In Financial Cryptography,
- how to make bitcoin a better currency.
volume 7397 of Lecture Notes in Computer Science, pages 399–414.
Springer, 2012.

[18] Massimo Bartoletti and Livio Pompianu. An analysis of bitcoin
In Financial Cryptography Workshops, volume
op_return metadata.
10323 of Lecture Notes in Computer Science, pages 218–230. Springer,
2017.

[19] Carl Beekhuizen.

Incen-
https://blog.ethereum.org/2020/01/13/validated-staking-on-eth2-

staking on eth2: #1 -

Validated,

tives.
1-incentives/, 2020.

[20] Dan Boneh, Ben Lynn, and Hovav Shacham. Short signatures from the
weil pairing. In ASIACRYPT, volume 2248 of Lecture Notes in Computer
Science, pages 514–532. Springer, 2001.

[21] Ethan Buchman. Tendermint: Byzantine fault tolerance in the age of

blockchains, 2016.

[22] Ethan Buchman, Jae Kwon, and Zarko Milosevic. The latest gossip on

BFT consensus. arXiv:1807.04938, 2018.

[23] Vitalik Buterin. Proof of stake: How i learned to love weak subjec-
https://blog.ethereum.org/2014/11/25/proof-stake-learned-love-

tivity.
weak-subjectivity/, 2014.

[24] Vitalik Buterin and Virgil Grifﬁth. Casper the friendly ﬁnality gadget.

arXiv:1710.09437, 2019.

[25] Vitalik Buterin, Diego Hernandez, Thor Kamphefner, Khiem Pham,
Zhi Qiao, Danny Ryan, Juhyeok Sin, Ying Wang, and Yan X Zhang.
Combining GHOST and Casper. arXiv:2003.03052, 2020.

[26] Miguel Castro and Barbara Liskov. Practical byzantine fault tolerance.

In OSDI, pages 173–186. USENIX Association, 1999.

[27] Benjamin Y. Chan and Elaine Shi. Streamlet: Textbook streamlined

blockchains. In AFT, pages 1–11. ACM, 2020.

[28] Jing Chen and Silvio Micali. Algorand: A secure and efﬁcient distributed

ledger. Theor. Comput. Sci., 777:155–183, 2019.

[29] Phil Daian, Rafael Pass, and Elaine Shi.

Snow white: Robustly
reconﬁgurable consensus and applications to provably secure proof of
In Financial Cryptography, volume 11598 of Lecture Notes in
stake.
Computer Science, pages 23–41. Springer, 2019.

[30] Bernardo David, Peter Gazi, Aggelos Kiayias, and Alexander Russell.
Ouroboros Praos: An adaptively-secure, semi-synchronous proof-of-
stake blockchain. In EUROCRYPT 2018, pages 66–98. Springer, 2018.
[31] Evangelos Deirmentzoglou, Georgios Papakyriakopoulos, and Constanti-
nos Patsakis. A survey on long-range attacks for proof of stake protocols.
IEEE Access, 7:28712–28725, 2019.

[32] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin
In EUROCRYPT (2),
backbone protocol: Analysis and applications.
volume 9057 of Lecture Notes in Computer Science, pages 281–310.
Springer, 2015.

[33] Bela Gipp, Norman Meuschke, and Andre Gernandt. Decentralized
trusted timestamping using the crypto currency bitcoin. In Proceedings
of the iConference 2015, 2015.

[34] Thomas Hepp, Patrick Wortner, Alexander Schönhals, and Bela Gipp.
Securing physical assets on the blockchain: Linking a novel object iden-
In CRYBLOCK@MobiSys,
tiﬁcation concept with distributed ledgers.
pages 60–65. ACM, 2018.

[10] Launch communications — june

community update.

https:

[35] Dimitris Karakostas and Aggelos Kiayias.

Securing proof-of-work

//blog.cosmos.network/launch-communications-june-community-
update-e1b29d66338, 2018.

[11] Guide to osmosis. https://www.coinbase.com/cloud/discover/protocol-

guides/guide-to-osmosis, 2022.

[12] VDF Alliance. VDF Alliance FPGA Competition. https://supranational.
atlassian.net/wiki/spaces/VA/pages/36569208/FPGA+Competition,
2019.

ledgers via checkpointing. In IEEE ICBC, pages 1–5. IEEE, 2021.
[36] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman
Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain
protocol. In CRYPTO (1), volume 10401 of Lecture Notes in Computer
Science, pages 357–388. Springer, 2017.

[37] Jing Li, Dongning Guo, and Ling Ren. Close latency-security trade-off
for the nakamoto consensus. In AFT, pages 100–113. ACM, 2021.

[38] Joachim Neu, Ertem Nusret Tas, and David Tse. Ebb-and-ﬂow protocols:
A resolution of the availability-ﬁnality dilemma. In IEEE Symposium
on Security and Privacy, pages 446–465. IEEE, 2021.

[39] Joachim Neu, Ertem Nusret Tas, and David Tse. The availability-
accountability dilemma and its resolution via accountability gadgets.
In Financial Cryptography and Data Security, FC ’22, 2022.

[40] Daejun Park and Aditya Asgaonkar. Analysis on weak subjectivity in

ethereum 2.0, 2021.

[41] Rafael Pass and Elaine Shi. The sleepy model of consensus.

In

ASIACRYPT 2017, pages 380–409. Springer, 2017.

[42] Rafael Pass and Elaine Shi. Thunderella: Blockchains with optimistic
In EUROCRYPT (2), volume 10821 of Lecture

instant conﬁrmation.
Notes in Computer Science, pages 3–33. Springer, 2018.

[43] Maxwell Sanchez and Justin Fisher. Proof-of-proof: A decentralized,
trustless, transparent, and scalable means of inheriting proof-of-work
security. https://veriblock.org/wp-content/uploads/2018/03/PoP-White-
Paper.pdf, 2018.

[44] Suryanarayana Sankagiri, Xuechao Wang, Sreeram Kannan, and Pramod
Viswanath. Blockchain CAP theorem allows user-dependent adaptivity
and ﬁnality. In Financial Cryptography (2), volume 12675 of Lecture
Notes in Computer Science, pages 84–103. Springer, 2021.

[45] Claus-Peter Schnorr. Efﬁcient identiﬁcation and signatures for smart
cards. In CRYPTO, volume 435 of Lecture Notes in Computer Science,
pages 239–252. Springer, 1989.

[46] Peiyao Sheng, Gerui Wang, Kartik Nayak, Sreeram Kannan, and Pramod
Viswanath. BFT protocol forensics. In CCS, pages 1722–1743. ACM,
2021.

[47] Selma Steinhoff, Chrysoula Stathakopoulou, Matej Pavlovic, and Marko
Vukolic. BMS: Secure Decentralized Reconﬁguration for Blockchain
and BFT Systems. arXiv:2109.03913, 2021.

[48] Alistair Stewart and Eleftherios Kokoris-Kogia. GRANDPA: A Byzan-

tine ﬁnality gadget. arXiv:2007.01560, 2020.

[49] Anatoly Yakovenko. Solana: A new architecture for a high performance
blockchain v0.8.13. https://solana.com/solana-whitepaper.pdf, 2019.
[50] Maofan Yin, Dahlia Malkhi, Michael K. Reiter, Guy Golan-Gueta, and
Ittai Abraham. Hotstuff: BFT consensus with linearity and responsive-
ness. In PODC, pages 347–356. ACM, 2019.

APPENDIX A
PROOF OF THEOREM 1

Proof. Towards contradiction, suppose there exists a PoS
protocol Π that provides fl-Tﬁn-liveness and fa-slashable-
safety for some integers fl, fa > 0 and Tﬁn < ∞.

Let n be the number of active validators at any given slot.
Let P , Q(cid:48) and Q(cid:48)(cid:48) denote disjoint sets of distinct validators:
i, i = 1, .., n} and Q(cid:48)(cid:48) =
P = {vi, i = 1, .., n}, Q(cid:48) = {v(cid:48)
{v(cid:48)(cid:48)
i , i = 1, .., n}. Let T < ∞ denote the time it takes for a
validator to withdraw its stake after its withdrawal transaction
is ﬁnalized by the PoS protocol. We consider the following
four worlds:

i, i = 1, .., n,

World 1: The initial set of active validators is P . Validators
in P and Q(cid:48) are honest. At slot 0, Z inputs transactions
tx(cid:48)
is the
withdrawal transaction for vi. Validators in P execute the PoS
protocol, and record the consensus messages they observe in
their transcripts. Suppose Z replaces each vi with v(cid:48)
i ∈ Q(cid:48) as
the new active validator.

to the validators in P . Here, tx(cid:48)
i

At slot Tﬁn+T , (A, Z) spawns the client c1. Upon querying
the validators, c1 receives messages from the validators in Q(cid:48).
By Tﬁn-liveness, for all i ∈ [n], tx(cid:48)
Tfin+T . Moreover, by
Tﬁn + T , all validators in P have withdrawn their stake in c1’s
view, and the set of active validators is Q(cid:48).

i ∈ Lc1

World 2: The initial set of active validators is P . Validators
in P and Q(cid:48)(cid:48) are honest. At slot 0, Z inputs transactions
tx(cid:48)(cid:48)
is the

i , i = 1, .., n, to the validators in P . Here, tx(cid:48)(cid:48)
i

15

withdrawal transaction for vi. Validators in P execute the PoS
protocol, and record the consensus messages they observe in
i ∈ Q(cid:48)(cid:48) as
their transcripts. Suppose Z replaces each vi with v(cid:48)(cid:48)
the new active validator.

At slot Tﬁn + T , (A, Z) spawns client c2. Upon querying
the validators, c2 receives messages from the validators in Q(cid:48)(cid:48).
By Tﬁn-liveness, for all i ∈ [n], tx(cid:48)(cid:48)
Tfin+T . Moreover, by
Tﬁn + T , all validators in P have withdrawn their stake in c2’s
view, and the set of active validators is Q(cid:48)(cid:48).

i ∈ Lc2

World 3: The initial set of active validators is P . Validators

in Q(cid:48) are honest. Validators in P and Q(cid:48)(cid:48) are adversarial.

At slot 0, Z inputs transactions tx(cid:48)

i, i = 1, .., n, to the
validators in P . Validators in P execute the PoS protocol,
and record the consensus messages they observe in their
transcripts.

Simultaneous with the execution above, (A, Z) creates a
simulated execution in its head, where a different sequence
of transactions, tx(cid:48)(cid:48)
i , i ∈ [n], are input to the validators in
P at slot 0. In the simulated execution, Z replaces each vi
i ∈ Q(cid:48)(cid:48) as the new active validator. As in the real
with v(cid:48)(cid:48)
execution, validators in P execute the PoS protocol, and record
the consensus messages they observe in their transcripts.

i ∈ Lc1

Finally, (A, Z) spawns two clients c1 and c2 at slot Tﬁn+T .
Upon querying the validators, c1 receives messages from
the validators in Q(cid:48) whereas c2 receives messages from the
validators in Q(cid:48)(cid:48). Since the worlds 1 and 3 are indistin-
guishable by c1 except with negligible probability, for all
i ∈ [n], tx(cid:48)
Tfin+T with overwhelming probability. Since
the worlds 2 and 3 are indistinguishable by c2 except with
negligible probability, for all i ∈ [n], tx(cid:48)(cid:48)
Tfin+T with over-
i /∈ Lc2
whelming probability. Similarly, for all i ∈ [n], tx(cid:48)
Tfin+T ,
and tx(cid:48)(cid:48)
Tfin+T conﬂict with
each other with overwhelming probability. Moreover, at slot
Tﬁn+T , in the view of c1 and c2, the set of active validators are
Q(cid:48) and Q(cid:48)(cid:48) respectively, and all validators in P have withdrawn
their stake.

Tfin+T . Thus, Lc1

Tfin+T and Lc2

i /∈ Lc1

i ∈ Lc2

As there is a safety violation and fa > 0, at least one
validator must have become slashable in the view of both
clients. By deﬁnition of the forensic protocol, with overwhelm-
ing probability, a validator from the set Q(cid:48)(cid:48) becomes slashable
in the clients’ views as (i) the validators in P have withdrawn
their stake in the clients’ view and (ii) those in Q(cid:48) are honest.
World 4: World 4 is the same as world 3, except that
the validators in Q(cid:48) are adversarial, those in Q(cid:48)(cid:48) are hon-
est, and the real and simulated executions are run with the
transactions tx(cid:48)(cid:48)
i respectively. As the worlds 3 and 4
are indistinguishable in the views of the clients except with
negligible probability, they again identify a validator from
Q(cid:48)(cid:48) as slashable in world 2 with non-negligible probability.
However, the validators in Q(cid:48)(cid:48) are honest in world 2, which is
a contradiction with the deﬁnition of the forensic protocol.

i and tx(cid:48)

APPENDIX B
PROOF OF THEOREM 4

Proof. Towards contradiction, suppose there exists a PoS
protocol Π that provides fs-accountable-safety, and fl-Tﬁn-

i , i ∈ [(cid:100)n/2(cid:101)], and txQ

liveness for some integers fs > 0, fl ≥ n/2, and Tﬁn < ∞.
Let P and Q denote two sets that partition the validators into
two groups of size (cid:100)n/2(cid:101) and (cid:98)n/2(cid:99) respectively. Consider the
following worlds, where Z inputs externally valid bit strings,
txP
j , j ∈ [(cid:98)n/2(cid:99)], to the validators in
P and Q respectively at the beginning of the execution. Here,
each validator i in P receives the unique string txP
i , and each
validator j in Q receives the unique string txQ
j . Each string
consists of m bits, where m is a polynomial in the security
parameter λ.

World 1: There are two clients c1 and c2. Validators in P
are honest, and those in Q are adversarial. In their heads, the
adversarial validators simulate the execution of (cid:98)n/2(cid:99) honest
validators that do not receive any messages from those in P
over the network. They also do not send any messages to P
and c1, but reply to c2.

Validators in Q send messages to the timestamping service
I as dictated by the protocol Π. There could be messages on I
sent by the validators in P that require a response from those
in Q. In this case, the validators in Q reply as if they are
honest validators and have not received any messages from
those in P over the network.

As |Q| = (cid:98)n/2(cid:99) ≤ fl, by the fl-liveness of Π, clients c1
and c2 both output txP
i , i ∈ [(cid:100)n/2(cid:101)] as part of their chains by
slot Tﬁn. Since there can be at most m(cid:98)n/2(cid:99) − 1 bits of data
on I, and txQ
j , j ∈ [(cid:98)n/2(cid:99)], consists of m(cid:98)n/2(cid:99) bits, c1 does
not learn and cannot output all of txQ
j , j ∈ [(cid:98)n/2(cid:99)], as part of
its chain by slot Tﬁn with overwhelming probability.

World 2: There are again two clients c1 and c2. Validators
in P are adversarial, and those in Q are honest. In their heads,
the adversarial validators simulate the execution of the (cid:100)n/2(cid:101)
honest validators from world 1, and pretend as if they do not
receive any messages from those in Q over the network. They
also do not send any messages to Q and c1, but reply to the
queries by c2. They send the same messages to I as those sent
by the honest validators within world 1.

As |P | = (cid:100)n/2(cid:101) ≤ fl, by the fl-liveness of Π, clients c1
and c2 both output txQ
j , j ∈ [(cid:98)n/2(cid:99)], as part of their chains
by slot Tﬁn. Since there can be at most m(cid:98)n/2(cid:99) − 1 bits of
data on I, and txP
i , i ∈ [(cid:100)n/2(cid:101)], consists of m(cid:100)n/2(cid:101) bits, c1
does not learn and cannot output all of txP
i , i ∈ [(cid:100)n/2(cid:101)], as
part of its chain by slot Tﬁn with overwhelming probability

i , i ∈ [(cid:100)n/2(cid:101)], and txQ

As the worlds 1 and 2 are indistinguishable by c2 except
with negligible probability, it outputs the same chain contain-
ing txP
j , j ∈ [(cid:98)n/2(cid:99)], in both worlds with
overwhelming probability. However, c1’s chain contains txP
i ,
i ∈ [(cid:100)n/2(cid:101)], but not txQ
j , j ∈ [(cid:98)n/2(cid:99)], in world 1, and txQ
j ,
j ∈ [(cid:98)n/2(cid:99)], but not txP
i , i ∈ [(cid:100)n/2(cid:101)], in world 2. This implies
that there is a safety violation in either world 1 or world 2
or both worlds with non-negligible probability. Without loss
of generality, suppose there is a safety violation in world 2.
In this case, c1 asks the validators for their transcripts, upon
which the adversarial validators in P reply with transcripts
that omit the messages received from the set Q. As fs > 0,
by invoking the forensic protocol with the transcripts received,

16

Fig. 6: Parameters r1, r2, r(cid:48)
1 and r∗
Theorem 2 and shown relative to each other.

2, r∗

1, r(cid:48)

2 deﬁned for the proof of

c1 identiﬁes a non-empty subset S ⊆ P of the adversarial
validators, and outputs a proof that the validators in S have
violated the protocol Π. However, in this case, an adversarial
validator in world 1 can emulate the behavior of c1 in world
2, and ask the validators for their transcripts. It can then
invoke the forensic protocol with the transcripts, and output a
proof that identiﬁes the same subset S ⊆ P of validators as
protocol violators. Since the two worlds are indistinguishable
by c2 except with negligible probability, upon receiving this
proof, it identiﬁes the honest validators in S ⊆ P as protocol
violators in world 1 as well with non-negligible probability,
which is a contradiction. By the same reasoning, if the safety
violation happened in world 1, an adversarial validator in
world 2 can construct a proof accusing an honest validator
in world 2 in c2’s view with non-negligible probability, again
a contradiction.

APPENDIX C
SECURITY PROOFS

(cid:22) Cc2

Proof of Proposition 2. Since Bitcoin is safe with parameter
k, without loss of generality, suppose Cc1
r2 . Let hi, i ∈
r1
[m1], and hj, j ∈ [m2], m1 ≤ m2, denote the sequence of
hash values within checkpoint transactions in c1’s and c2’s
views at slots r1 and r2 respectively. Note that the sequence
observed by c1 is a subset of the sequence observed by c2. Let
B1 denote the ﬁrst PoS block in ckptc1
r1 that is not available
or not ﬁnalized in c2’s view at slot r2, and deﬁne i1 as the
index of the hash of the block that extends or is the same as
B1. (If there is no such block B1, i1 = ∞.) Similarly, let B2
denote the ﬁrst PoS block in ckptc2
r2 that is not available or not
ﬁnalized in c1’s view at slot r1, and deﬁne i2 as the index of
the hash of the block that extends or is the same as B2. (If there
is no such block B2, i2 = ∞.) Note that if i1 < ∞, i2 = ∞,
and if i2 < ∞, i1 = ∞, due to Line 14 of Algorithm 1. In
the former case, i.e., if i1 < i2, ckptc2
r1 . In the latter
r2
(cid:22) ckptc2
case, i.e., if i2 ≤ i1, ckptc1
r2.
r1
If r2 ≥ r1 + ∆, any PoS block available in c1’s view at
slot r1 becomes available in c2’s view by slot r2. Similarly,
by the safety of Bitcoin with parameter k, if r2 ≥ r1 + ∆,
Cc1
r2 . Finally,
r1
by the safety of Bitcoin with parameter k, Cc
r2 for any
r1
r2 ≥ r1. Thus, ckptc
r1

r2 . In this case, i1 = ∞ and ckptc1
r1

(cid:22) ckptc2
(cid:22) Cc

≺ ckptc1

(cid:22) ckptc

(cid:22) Cc2

r2 .

Proof of Theorem 2. Suppose there are two clients c1, c2, and
slots r1, r2 ≥ r1 such that Lc1
r1 conﬂicts with Lc2
r2 . Let B1
r1 and Lc2
and B2 denote the earliest conﬂicting blocks in Lc1
r2

respectively. As B1 and B2 share a common parent, they also
share the same active validator set.

1 = ∞.). If r∗

Deﬁne ckpt1 = ckptc1

r1 and ckpt2 = ckptc2

and B1 /∈ ckptc
r(cid:48)
2

r1 and ckpt2 (cid:22) Lc2

r2 . By Propo-
sition 2, either ckpt1 (cid:22) ckpt2 or ckpt2 (cid:22) ckpt1. Since
ckpt1 (cid:22) Lc1
r2, B2 /∈ ckpt1 and B1 /∈ ckpt2.
By Proposition 2, for all clients c and slots r(cid:48)
1 ≤ r1 − ∆ and
2 ≤ r2 − ∆, it holds that B2 /∈ ckptc
r(cid:48)
(cf.
r(cid:48)
1
Figure 6).
Let r∗

2 > r1 − ∆ denote the ﬁrst slot B2 appears in the
checkpointed chain held by a client c∗
1 (If there is no such
2 = ∞.). Similarly, let r∗
slot, r∗
1 > r2 − ∆ denote the ﬁrst slot
B1 appears in the checkpointed chain held by a client c∗
2 (cf.
Figure 6. If there is no such slot, r∗
1 < ∞ or
r∗
2 < ∞, deﬁne b1 and b2 as the Bitcoin blocks containing the
hashes of the ﬁrst checkpoints that are either equal to B1 and
B2 or extend B1 and B2 in the checkpointed chains observed
by the clients c∗
2 and c∗
2 respectively. Then,
for any client c, if r∗
2 < ∞, b2 ∈
Cc
2 +∆. In this case, b1 and b2 are again the ﬁrst conﬁrmed
r∗
Bitcoin blocks containing the hashes of the checkpoints that
are either equal to B1 and B2 or extend B1 and B2 in the
checkpointed chains observed by c respectively.
clients

1 at slots r∗
1 and r∗
1 +∆; if r∗
1 < ∞, b1 ∈ Cc
r∗

con-
As
=
sensus
min(max(r1, r2), max(r∗
1, r2)) +
∆, both B1 and B2 are observed by all clients. Since B1 and
B2 are ﬁnalized and conﬂicting blocks, an honest validator
must have sent a fraud proof that incriminates at least n/3 of
the validators in the common active validator set of B1 and B2,
by slot r0. Here, r0 ≤ max(r1, r2) + ∆ ≤ r2 + ∆ ≤ r∗
1 + 2∆,
and r0 ≤ max(r1, r∗
2) + ∆ ≤ r∗

broadcast
by
slot
2), max(r1, r∗

their
r0
2), max(r∗

messages,

2 + 2∆.

1, r∗

the

2 + 2∆, if r∗

0 satisﬁes |Cc
r(cid:48)
0

r0−2∆| + k. As r0 ≤ r∗

By Proposition 1, for any client c, the fraud proof is in
| = |Cc
, where r(cid:48)
Cc
1 +
r(cid:48)
0
2∆, r∗
1 < ∞ and the checkpoint in b1 has always
been available, the earliest slot b1 can appear in c’s Bitcoin
chain is r0 − 2∆. Similarly, in this case, if r∗
2 < ∞ and the
checkpoint in b2 has always been available, the earliest slot
b2 can appear in c’s Bitcoin chain is r0 − 2∆. This implies
that if b1 (or b2) appears in c’s Bitcoin chain at all and contain
available checkpoints, the fraud proof will be included in either
the k-th block extending b1 (or b2), or in its preﬁx. Since the
active validators for the blocks B1 and B2 cannot withdraw
their stake in c’s view before b1 or b2 become k deep in c’s
Bitcoin chain, and as n/3 of these validators will be irrefutably
identiﬁed as protocol violators by c by slot r(cid:48)
0, at least n/3
validators become slashable in c’s view.

17

respectively. Let ˜r2 ≤ r2 < ∞ be the ﬁrst time B2 appears
in the pos chain of any client c. Since b1 (cid:22) b2 and B1 and
B2 conﬂict, c could not have observed either the block b1 or
the checkpoint for B1 as available before slot ˜r2. Suppose c
ﬁrst observes b1 at slot ˜r1 > ˜r2. If the checkpoint in b1 is
unavailable in c’s view, c sends a checkpoint transaction for
B2 or a block extending it by slot ˜r1, which appears within
k Bitcoin blocks of b1 in every client’s conﬁrmed Bitcoin
chain. Hence, as soon as a client outputs B1 as part of its
PoS chain, e.g., by some slot r(cid:48)
0, and ensures its visibility by
all clients, n/3 of the active validators for the blocks B1 and
B2 are irrefutably identiﬁed as protocol violators by all clients
by slot max(r(cid:48)
0, ˜r1) + ∆, and at least n/3 validators become
slashable in all views. On the other hand, if the checkpoint
in b1 is available in c’s view at slot ˜r1, then, a fraud proof is
generated and sent to Bitcoin by slot r(cid:48)
0 = ˜r1 + ∆. Again, n/3
of the active validators for the blocks B1 and B2 are irrefutably
identiﬁed as protocol violators by all clients by slot r(cid:48)
0, and at
least n/3 validators become slashable in all views.

Proof of Theorem 3. By Theorem 2, the Bitcoin checkpoint-
ing protocol satisﬁes n/3-slashable safety. Hence, if the num-
ber of active adversarial validators is less than n/3 at all slots,
it satisﬁes safety. Suppose a transaction tx is ﬁrst input to an
honest validator at some slot r by Z. Then, from slot r and
on, each honest validator v will include tx in its proposal until
v observes a PoS block containing tx become ﬁnalized. Let c(cid:48)
be the client that holds the longest PoS chain among all clients
at slot r. As the number of active adversarial validators is less
than n/3, clients never observe an unavailable or non-ﬁnalized
PoS block become checkpointed, thus never stop outputting
new PoS blocks as part of their checkpointed, and PoS chains
(cf. clause (2) in the fork-choice rule of Section IV-C). Hence,
by network synchrony and the safety of the PoS protocol, for
every client c, Lc(cid:48)
r+2∆. Then, for every client
c, either Lc(cid:48)
r = Lc
r+2∆.

r+∆ (cid:22) Lc(cid:48)
r ≺ Lc(cid:48)
In the former case, every client agrees on the validator set
at slot r + ∆. By [22, Lemma 7], there exists a ﬁnite Ttm that
is polynomial in the security parameter λ such that if every
client agrees on the validator set, a new block that extends Lc(cid:48)
r
is ﬁnalized and becomes part of the PoS chain in the clients’
views by slot r + Ttm except with probability negl(λ). In the
latter case, a new block that extends the longest PoS chain,
thus all PoS chains held by the clients at slot r, is ﬁnalized in
the view of c(cid:48) by slot r + 2∆, and becomes part of the PoS
chains in all clients’ views by slot r + 3∆ by synchrony.

r (cid:22) Lc
r+∆ or Lc(cid:48)

Without loss of generality, we next consider the case the
checkpoint in b1 is not available in the view of a client c when
c ﬁrst observes b1 in its Bitcoin chain. Since the slashability
of 1/3 of validators is implied by the proof above in the case
b2 (cid:22) b1, we assume b1 (cid:22) b2 in the arguments below. Upon
observing b1, c stalls its PoS chain, and sends a checkpoint
for the block at the tip of its PoS chain. Recall that b1 and b2
are the ﬁrst conﬁrmed Bitcoin blocks containing the hashes of
the checkpoints that are either equal to B1 and B2 or extend
B1 and B2 in the checkpointed chains observed by the clients

Finally, when the number of adversarial validators is less
than n/3, with probability at least 2/3, each block ﬁnal-
ized after slot r must have been proposed by an honest
validator. Then, for any given integer m > 1, by slot r +
(m + 1) max(Ttm, 3∆), the transaction tx will appear in each
client’s PoS chain except with probability m negl(λ)+(1/3)m.
Setting m = Θ(λ), it holds that m negl(λ) + (1/3)m =
negl(λ). Consequently, for m = Θ(λ), liveness is satisﬁed
with parameter Tﬁn that is linear in λ, except with probability
negl(λ).

r1 conﬂicts with Lc2

Proof of Theorem 5. Suppose there are two clients c1, c2, and
slots r1, r2 such that Lc1
r2. Let B1 and B2
denote the earliest conﬂicting PoS blocks or bundles in Lc1
r1
and Lc2
r2 respectively. Without loss of generality, let r1 and r2
be the ﬁrst slots B1 and B2 appear in c1’s and c2’s PoS chains
respectively.

By the safety of Bitcoin, Cc1

r1 is a preﬁx of Cc2

with overwhelming probability. By Proposition 2, ckptc1
preﬁx of ckptc2

r2 or vice versa.

r2 or vice versa
r1 is a

We ﬁrst consider the case where at least one of the blocks
is a bundle. Without loss of generality, let B1 be a bundle
and B denote the common parent of B1 and B2. Let b denote
the Bitcoin block with the liveness transaction that triggered
the rollup mode, during which h1, the hash of B1, and the
corresponding n/2 signatures appeared in Cc1
r1 . At slot r1, the
preﬁx of c1’s PoS chain ending at B1 consists of two pieces:
(i) a checkpointed chain outputted using the preﬁx of Cc1
r1 that
ends at the 2k-th block extending b, (ii) bundles extending
the checkpointed chain until B1. If B is also a bundle, the
next block in Lc2
r2 following B, i.e. B2, has to be the same
block as B1 due to the consistency of Cc1
r2 . However,
as B2 (cid:54)= B1, B cannot be a bundle.

r1 and Cc2

If B is not a bundle, it must be the last PoS block in c1’s
checkpointed chain preceding B1, implying that B1 is the ﬁrst
bundle in Lc1
r1. However, this again implies B1 = B2 since c1
and c2 agree on the ﬁrst block of the rollup mode whenever
Cc1
r1 and Cc2
r2 are consistent. As this is a contradiction, with
overwhelming probability, neither of the blocks B1 or B2 can
be a bundle.

Finally, if neither of B1 and B2 is a bundle, proof of

slashable safety proceeds as given for Theorem 2.

Proof of Theorem 6. As the number of honest active valida-
tors is > n/2 at all times, no PoS block or bundle hash with
an unavailable preimage can acquire signatures from over n/2
active validators of the corresponding epoch. Hence, there
cannot be any emergency break and the clients do not stop
outputting new PoS blocks or bundles as part of their PoS
chains while new checkpoints for available and ﬁnalized PoS
blocks continue to appear in Bitcoin.

Consider a transaction tx input to the honest validators at
some slot r by Z. If tx does not appear in Lv
in an
honest validator v’s view, v sends a liveness transaction to
Bitcoin containing tx at slot r + Ttm. Let R, polynomial in
the security parameter λ, denote the conﬁrmation latency of
Bitcoin with parameter k. Then, by the security of Bitcoin,
with overwhelming probability, for all clients c, the liveness
transaction appears in Cc
r1 within the same Bitcoin block b by
slot r1 = r + Ttm + R,

r+Ttm

Once a client c observes b become k deep in its Bitcoin
chain, which happens by some slot less than r1 + R, it sends a
checkpoint transaction for the block at the tip of its PoS chain.
Subsequently, b becomes at least 2k deep in c’s Bitcoin chain
by some slot r2 ≤ r1 + 2R with overwhelming probability.
In this case, there are two possibilities: (1) tx ∈ ckptc
r2, or
(2) tx /∈ ckptc
r2 . If (1) happens, then for all clients c, it holds

18

that tx ∈ Lc
r2. If (2) happens, then each client c enters the
rollup mode by slot r2. Once in the rollup mode, an honest
validator v prepares a bundle of transactions containing tx by
slot r2, which is viewed by all clients and signed by all honest
validators by slot r2 + ∆. Upon gathering these signatures,
i.e., by slot r2 + 2∆, v sends the hash of the bundle and the
signatures to Bitcoin. By the security of Bitcoin, the hash and
the signatures appear in the Bitcoin chain of each client c at
the same position by slot r3 = r2+2∆+R with overwhelming
probability. Since the PoS protocol is accountable, an honest
validator can never be identiﬁed as a protocol violator and can
never become slashable in the view of any client. This implies
that the signatures from the honest validators sufﬁce to pass
the n/2 threshold. Consequently, tx ∈ Lc
r3 for each client c.
Finally, setting Tﬁn = r3 − r = 2∆ + 4R + Ttm, which
is polynomial in λ, we observe that unless there is a safety
violation, Tﬁn-liveness holds for all clients.

Proof of Corollary 2. By Theorem 6, if the number of ad-
versarial active validators is less than n/2 at all times, the
Babylon protocol of Section VI-B with fast ﬁnalization satis-
ﬁes Tﬁn-liveness, where Tﬁn is a polynomial in the security
parameter λ. Thus, if a transaction tx is input to an honest
validator at some slot r, then for all clients c that follow
the fast ﬁnalization rule, tx will be in Lc
. If tx was
included in a bundle, then once tx enters Lc
, it is also in
ckptc
r+Tfin. On the other hand, if tx was included in a ﬁnalized
and available PoS block, it might be the case that the block
extends ckptc
r+Tfin , but is not checkpointed yet.

r+Tfin

r+Tfin

At the end of each epoch, an honest validator v sends
a checkpoint transaction for the ﬁnalized and available PoS
blocks extending its checkpointed chain. As the PoS protocol
is accountable, an honest validator can never be identiﬁed
as a protocol violator and can never become slashable in
the view of any client. Thus, the signatures from the honest
validators on v’s checkpoint are always viewed as valid by all
clients. Let R, polynomial in the security parameter λ, denote
the conﬁrmation latency of Bitcoin with parameter k. Let T ,
polynomial in the security parameter λ, denote an upper bound
on the duration of epochs.

Suppose the validator v sent its signed checkpoint for a
ﬁnalized and available PoS block containing tx at the end of
the epoch where it observed tx in its PoS chain, e.g., at some
slot r(cid:48) < r + Tﬁn + T . Then, with overwhelming probability,
for any client c, v’s signed checkpoint is in Cc
r(cid:48)+R. As the
valid signatures on the checkpoint by the honest validators
pass the n/2 threshold, with overwhelming probability, either
tx ∈ ckptc
r(cid:48)+R for all clients c, or there is a checkpoint in
the preﬁx of v’s checkpoint for conﬂicting PoS blocks. In the
latter case, the protocol enters the rollup mode as described
in Section VI-D, in which case tx would be included in a
bundle. Consequently, Babylon with slow ﬁnalization satisﬁes
T (cid:48)
ﬁn-liveness, where T (cid:48)
ﬁn ≤ Tﬁn + T + R is a polynomial in
the security parameter λ.

