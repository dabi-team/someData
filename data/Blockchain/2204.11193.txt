EXPLORING SECURITY PRACTICES OF SMART CONTRACT
DEVELOPERS

2
2
0
2

r
p
A
4
2

]

R
C
.
s
c
[

1
v
3
9
1
1
1
.
4
0
2
2
:
v
i
X
r
a

Tanusree Sharma, Zhixuan Zhou, Andrew Miller, Yang Wang
University of Illinois at Urbana-Champaign
(tsharma6, zz78, soc1024, yvw) @illinois.edu

ABSTRACT

Smart contracts are self-executing programs that run on blockchains (e.g., Ethereum). 680 million
US dollars worth of digital assets controlled by smart contracts have been hacked or stolen due
to various security vulnerabilities in 2021. Although security is a fundamental concern for smart
contracts, it is unclear how smart contract developers approach security. To help ﬁll this research
gap, we conducted an exploratory qualitative study consisting of a semi-structured interview and a
code review task with 29 smart contract developers with diverse backgrounds, including 10 early
stage (less than one year of experience) and 19 experienced (2-5 years of experience) smart contract
developers.
Our ﬁndings show a wide range of smart contract security perceptions and practices including vari-
ous tools and resources they used. Our early stage developer participants had a much lower success
rate (15%) of identifying security vulnerabilities in the code review task than their experienced coun-
terparts (55%). Our hierarchical task analysis of their code reviews implies that just by accessing
standard documentation, reference implementations and security tools is not sufﬁcient. Many devel-
opers checked those materials or used a security tool but still failed to identify the security issues.
In addition, several participants pointed out shortcomings of current smart contract security tooling
such as its usability. We discuss how future education and tools could better support developers in
ensuring smart contract security.

Keywords Smart contract, security, blockchain, developer

1

Introduction

Blockchains are cryptographic platforms that can securely host applications and enable the transfer of digital assets in a
decentralized manner. Smart contract blockchains like Ethereum are increasingly capable of supporting sophisticated
computations (a.k.a., decentralized apps or dApps) [1]. Smart contracts are program scripts that deﬁne customized
functions and rules during transactions, and can run autonomously once deployed on a blockchain [2]. To support this
unique form of computation, domain speciﬁc programming languages, such as Solidity and Vyper have been created
to allow developers to write smart contracts.

A wide variety of industry applications in ﬁnance, healthcare, and energy have been rapidly exploring the use of
blockchain technology and smart contracts to enable system transparency and traceability. Since deployed smart
contracts can perform critical functions of holding a considerable amount of digital assets, tokens or currencies in
circulation, they become a hotbed for attacks. According to DeFi Pulse 1, there is about $109B USD worth of total
value locked (TVL) as of November 2021 controlled by deployed smart contracts in Decentralized Finance (DeFi)
applications. While DeFi is a promising domain and has the potential to disrupt traditional ﬁnancial systems, there
has been several security incidents, in which digital tokens worth of millions of dollars have been stolen. In June
2016, vulnerabilities in the Maker DAO (decentralized autonomous organization) smart contract code were exploited
to empty out more than two million Ether, which were worth 40 million USD [3]. This attack exploited the reentrancy
vulnerability in the ‘splitDAO’ function of the code. Since the code was not designed carefully, a call to the function

1https://deﬁpulse.com/

 
 
 
 
 
 
that behaved as a regular call was modiﬁed into a recursive call and used to make multiple withdrawals, effectively
depleting the account. Section 2 provides a technical overview of blockchains and smart contracts.

More recently, since DeFi started skyrocketing in 2020, there has been a new wave of smart contract attacks that led
to the loss of hundreds of millions of dollars in value (e.g., [4]). Clearly, security is critical for smart contracts, and
various smart contract security resources and tools have been created. However, it is not clear how people who write
smart contracts (we denote as smart contract developers) think about and approach security in smart contract projects.
To help bridge this gap, we conducted an exploratory qualitative study consisting of a semi-structured interview and a
smart contract code review task with 29 smart contract developers with diverse backgrounds, including 10 early stage
(less than one year of experience) smart contract developers and 19 experienced developers (2-5 years of experience).

Research questions. Speciﬁcally, our study aims to answer the following research questions:

• RQ1: How do smart contract developers approach or ensure security for smart contracts? Are there any

differences between early stage and experienced developers?

• RQ2: How do smart contract developers conduct code reviews and whether they are able to identify common

smart contract security vulnerabilities in the code?

Summary of ﬁndings. Our study ﬁndings show that our participants have a wide variety of smart contract security
perceptions and practices, including various tools and resources they used. In general, the experienced developers
tended to have more awareness of smart contract security (e.g., vulnerabilities, best practices, resources, tools) and
perform better in the code review task than their early stage counterparts. Early stage developers tended to think
security is not important for their projects because they do not think their projects have much impact in part because
they are often not deployed in the mainnet and thus are not an interesting target for attackers. As a result, they often
lack motivations and awareness of smart contract security issues as well as resources and tools about smart contract
security. In the code review task, our early stage developer participants had a low success rate (15%) of identifying
security vulnerabilities in the reviewed code. In comparison, 55% of the experienced developers were able to identify
these common vulnerabilities and many used a combination of security tools such as static analysis, and interactive call
graphs. Our hierarchical task analysis [5] of their code reviews implies that just by accessing standard documentation,
reference implementations and security tools is not sufﬁcient. Many developers especially those early staged did check
those materials or use a security tool but still failed to identify the security issues. In addition, both experienced and
early stage developers expressed their challenges with existing smart contract security tools. They pointed out lack of
comprehensive tools to identify existing smart contract security vulnerabilities. They also found those tools hard to
use (e.g., their user interfaces and the fact that these are separate tools that they have to use outside of the compiler).

Main contributions. Our work makes the following contributions: (1) our rich interview data offer novel results on
the various security perceptions and practices of smart contract developers with diverse backgrounds; (2) results from
our smart contract code review task sheds light on how smart contract developers actually examine smart contract code
for security vulnerabilities; and (3) we discuss implications for security education and tools that could better support
developers in ensuring smart contract security.

2 Blockchain and Smart Contract

The ﬁnancial industry is seen as a primary user scenario of the blockchain concept. Blockchain is well known not only
because of its popular application - cryptocurrency, but also for the characteristics of solving the process inefﬁciencies
in ﬁnancial services, by tracing ownership over a longer chain of changing buyers overtime. It is a sequence of blocks,
which hold a complete list of tamper-resistant transaction records in a distributed fashion without any central authority
[6, 7]. Each block contains a timestamp, the hash value of the previous block, and a nonce, which is a random number
for verifying the hash using cryptographic means. [6]. It guarantees reliability and consistency of data by adopting
decentralized consensus mechanism [8, 9]. Blockchain ecosystem contains multiple components- a core blockchain
software that consists of client software such as Go Ethereum [10] in the case of Ethereum. People participating in a
blockchain network run this client software, called node, which is often bundled with software/hardware wallets [11].

The most popular blockchain systems, Bitcoin and Ethereum, Ethereum is a decentralized, open-source blockchain
with smart contract functionality. It enables developers to build decentralized applications with built-in economic
functions in smart contracts [12]. While providing high transparency, and neutrality, it also reduces/eliminates cen-
sorship, and reduces certain counterparty risks. Ether is the native cryptocurrency of this platform and second-largest
cryptocurrency by market capitalization2.

2https://coinmarketcap.com/

2

Smart contracts are essentially containers of code that encode real world contractual agreements in the digital realm
[13]. It is a protocol that can automatically verify and process the content that represents a binding agreement between
two or more parties, where every entity must fulﬁll their obligations of the contract. Once a smart contract is conﬁrmed
by the consensus protocol and submitted to the blockchain, it will be run in terms of the prior negotiation without the
interference of any third party. The code execution of smart contract is distributed and veriﬁed by the network nodes
in a decentralized blockchain network [12]. It can enable the encoding of complex logic including, payoff schedule,
investment assumptions, interest policy, conditional trading directives, pricing dependent on geographic or other en-
vironmental input, etc [14]. Gaming, music distribution, remote purchases, and many other business interactions can
utilize automatically-enforced smart contracts for secure and veriﬁed transactions, without a need for intermediaries
or third-party trust [14].

There are many smart contract languages, such as Solidity, Serpent, and Vyper. On Ethereum, the most popular smart
contract language is Solidity 3. Solidity is a JavaScript-like scripting language with static types. Solidity is strongly-
typed and has built-in constructs to interact with the Ethereum platform. Programs written in Solidity are compiled
into low-level untyped bytecode to be executed on the Ethereum platform by the Ethereum Virtual Machine (EVM).
The EVM is a low-level stack-machine with an instruction set for identifying contracts and calling out to different
contracts based on signatures, exception-related instructions, and transaction cost computation. Data is stored either
on the blockchain, in the form of persistent data structures, or in contract local memory. In Ethereum, solidity smart
contracts are generally designed to manipulate and hold funds denominated in Ether.

3 Related Work

3.1 User Studies of Security Practices

The existing studies on end-users and their attitude towards security and privacy of emerging technologies discussed
human factors of software security [15] and how developers were considered as the “weakest link.” Research high-
lighted the need for a deeper understanding of the evolving ﬁeld of software development [16]. To this end, [17]
outlined an agenda towards understanding developer’s attitude, available security development tools, and proposing
design suggestions to support developers in building secure applications. There was frequently cited research on
developer’s lack of security education [18] and security thinking during writing code [19], which was perceived as
the reason for different software vulnerabilities. The assumption was that if developers have learned about security,
they could better avoid vulnerabilities [20]. To advocate software security education, some presented that there was
a lack of security guidelines mandated by the industries [21], [22] which lead to the lack of ability [18] or proper
expertise [23] to identify vulnerabilities. In this work, we aim to uncover details about security practices in real-world
development and deployment in the emerging landscape of smart contracts.

3.2 Smart Contract Vulnerabilities

Smart contracts are running on distributed and permission-less networks, which leads to vulnerabilities due to the
malfunctioning of the smart contract execution. The ﬁnancial aspect of smart contracts makes them very tempting
attack targets, and a successful attack may allow the attacker to directly steal funds from the contracts. Recent litera-
ture introduces common vulnerabilities in EVM-based smart contracts, including re-entrancy [24, 25, 26], unhandled
exception [27, 28], integer overﬂow [29, 24], and unrestricted action or access control [30, 24]. For re-entrancy to
be exploited, there is a call to an external contract which invokes and re-entrant callback to the contract [26]. Some
low-level operation such as “send,” “transfer,” and “call” are dangerous and can lead to vulnerabilities if they do
not handle exceptions [27]. Severe consequences could happen by integer overﬂow where funds of a contract could
become completely frozen [24]. Lack of critical authorization check can lead to execution of arbitrary code [30].

Blockchain technologies are evolving dramatically which are creating design ﬂaws in smart contract languages. De-
velopers of decentralized apps are often confronted with changing platform features [31]. Thus, common software
weaknesses such as access control, incorrect calculation, race condition and many other security weaknesses may be
ampliﬁed on blockchain platforms 4. Also, smart contracts are utilized as an anonymous payment method, which is
an attractive target for hackers. The infamous disasters involving the DAO 5 and the Parity Wallet 6 have highlighted
such risks. Attackers exploited programming bugs to steal approximately $70M USD. Recently, a series of suspicious

3https://docs.soliditylang.org/en/v0.8.13/
4https://swcregistry.io/
5https://hackingdistributed.com/2017/07/22/deep-dive-parity-bug/
6https://fortune.com/2016/06/18/blockchain-vc-fund-hacked/4

3

transactions happened in yCREDIT smart contract where a number of minted tokens were inconsistent 7. xToken
suffered attacks with a loss of $24M USD. One attack was due to a ﬂash loans within the xSNXa contract 8. Recent
work shows systemic consensus-layer vulnerabilities due to miner extractable value (MEV) where attackers can front
run orders by observing and placing their own orders with higher gas fees [32].

Recent study identiﬁed 16 major vulnerabilities in smart contracts, and limitation of analysis tools to identify the
vulnerabilities [33]. Most of the known vulnerabilities in smart contracts are related to the fallback function where
attackers could hijack the invoked contract and force it to execute. A study [34] pointed out that there were 34,200
contracts marked as vulnerable in a million samples due to vulnerabilities related to contract programming languages’
design defects. Some research focused on demonstrating the difﬁculties of estimating vulnerabilities in practice [35].
They surveyed six academic projects with 21,270 vulnerable contracts within datalog based queries level exploit
discovery in EVM traces to contrast the reported and actual vulnerabilities in those smart contracts [24].

3.3 Smart Contract Security Methods/Tools

In order to ensure smart contract security, a wide variety of practices have been adopted to operate at different stages
of smart contract development life cycle.

Testing tools. A large number of tools have been developed to analyze either contract source code or its compiled
EVM bytecode [35], and look for known security issues, such as re-entrancy, overﬂow, etc. Some of the well-known
tools are Oyente 9, ZEUS [36], Maian10, SmartCheck [37], ContractFuzzer [38], Vandal [27], Ethainter [39], Securify
[25], and MadMax [14]. ConsenSys Diligence - an enterprise for comprehensive code reviews of smart contracts
developed Mythril 11 which supports detecting security vulnerabilities in EVM-compatible blockchain and MythX to
cover a wider range of security issues 12.
Development and testing frameworks. Trufﬂe 13 is the most common development framework for smart contracts.
It allows developers to write both unit and integration tests. Another development environment is Hardhat which
facilitates running tests, automatically checking code for mistakes, and interacting with a smart contract, runs on a
development network. It provides plugins for code coverage, measuring gas usage per unit test, automatically verifying
contracts on Etherscan, etc. As a local blcokchain, Ganache 14 is one of the most popular standalone implementation
of the EVM built for development purposes. There is also a go-to suite of tools for developers called Remix 15. It is
known for its convenient browser IDE which supports development, testing and deploying smart contract.

Code auditing. Code auditing is an integral part of the defensive programming paradigm, which attempts to reduce
errors before the software is released. Audits should preferably be performed while contracts are still in the testing
phase. However, given the relatively high cost of auditing (usually around 30,000 to 40,000 USD), some companies
choose to perform audits later in their development cycle 16. Some of the tools used frequently in auditing are Surya
17, Mythril 18, and MythX.Third party companies who perform audits include Trail of Bits, OpenZeppelin, ConsenSys
Diligence, etc. During audit, vulnerabilities are detected in three main ways: (1) extracting features of malicious code,
and doing semantic matching on source code; (2) using mathematical approaches to prove a system’s completeness,
where auditor speciﬁes every possible input and lists every situation that might happen; (3) generating a control ﬂow
graph by contract’s logic units by which auditor can traverse all code paths to detect logical design ﬂaws. Furthermore,
code auditing depends on many factors such as time, budget, and resources availability in different organizations. Code
auditing is an extra layer of security instead of a primary consideration. Recent research has been driving towards
security from the beginning posture rather than depending solely on auditing [40, 41]

Bug bounty programs. Another common practice for organizations is to run bounty programs. It remains ongoing
throughout a contract’s lifetime and allows community members to be rewarded for reporting vulnerabilities. Com-

7https://blocksecteam.medium.com/deposit-less-get-more-ycredit-attack-details-f589f71674c3
8https://blocksecteam.medium.com/deposit-less-get-more-ycredit-attack-details-f589f71674c3
9https://github.com/enzymeﬁnance/oyente
10https://github.com/ivicanikolicsg/MAIAN
11https://github.com/ConsenSys/mythril
12https://github.com/ConsenSys/mythril
13https://github.com/trufﬂesuite
14https://github.com/trufﬂesuite
15https://github.com/ethereum/remix
16https://solidiﬁed.io/
17https://github.com/ConsenSys/surya
18https://github.com/ConsenSys/mythril

4

panies or projects run bounty programs, e,g., the 0x project 19offers bounties as high as $100K USD for critical
vulnerabilities.

3.4 User Studies of (Secure) Smart Contract Development

Recent work has focused on security assessment tools for smart contracts [42] and comparing existing tools for their
capabilities to identify vulnerabilities[43, 39]. The majority of the tools were still in progress, and several shortcomings
were identiﬁed for improvement [44], such as the user interfaces for visualizing results. Also, the root causes for
the occurrence of severe smart contract vulnerabilities were discussed [45], but notably only technical factors were
covered. These approaches were helpful, however they did not address developers’ actual practices with the underlying
programming languages which could facilitate writing buggy code in the ﬁrst place. A closer look at the incidents
revealed that eventually a large number of vulnerabilities in smart contracts occurred because of developers’ mistakes
[45]. Hence, avoidance of vulnerabilities in smart contracts meant secure development with users in mind during the
development life cycle [42]. This included a well thought-out design as well as adhering to best-practice patterns for
ensuring security [42], and involving users/developers during the design process. Research proposed that developers’
needs should be considered as a primary requirement in new tool design for smart contracts [46].

There is a lack of empirical user studies that examine smart contract development, particularly security practices. One
exception is a study by Parizi et. al [47] where they compared the uses of smart contract languages: Solidity 20, Pact 21
and Liquidity 22. This study is focused on the usability aspect of smart contract programming languages by measuring
the amount of time for novice participants to complete programming tasks. To the best of our knowledge, our study
is one of the ﬁrst to empirically explore smart contract developers’ security perceptions and practices. Despite the
wide range of vulnerabilities and exploitation reported in smart contracts [35], and existing research on assessing the
effectiveness of security analysis tools [48], we still know little about whether, when and how smart contract developers
deal with the security aspect of their contract code. We try to bridge these research gaps in this work.

4 Method

Our study was inspired by user studies of software developers’ security practices (e.g., [49, 47, 50]). We conducted a
user study with smart contract developers. The study included a semi-structured interview to understand participants’
smart contract development experiences and practices particularly around the security aspect. The study also includes
a smart contract code review task to understand how developers identify vulnerabilities in smart contracts. Since
Solidity is the most popular language for smart contracts [51], and has a simple syntax [47], we decided to focus on
Solidity developers in our study. The study was approved by the IRB and conducted online during the summer of
2021. Each study session took about one hour and each participant was compensated a gift card worth of $30 US
dollars. The study data were collected upon participants’ permission. All quotes included in this paper have been
anonymized to protect privacy of the participants. Below we describe the protocol of our study.

4.1 Participant Recruitment

To help reach a wide range of developers, we recruited through different methods: (1) snowball sampling from our
contacts in the broader Ethereum community, (2) posting on our Twitter and Facebook as well as ethresear.ch and
Discord channels, and (3) contacting Solidity developers of public smart contract projects on GitHub.

We selected participants based on the responses of our screening survey. Respondents were invited to our study if they
met our selection criteria: a) is a solidity-based smart contract developer; b) has some smart contract development ex-
perience; c) should provide proper explanation of their developed smart contract(s). We did two waves of recruitment.
In total, we received 67 responses from our screening survey. We reached out to 38 of them via email based on our
selection criteria. In total, 29 people agreed to participate in our study. Eight participants were from word-of-mouth
by our contacts in the Ethereum community. Two were from GitHub public projects. 19 were from our postings
on Twitter, Facebook, Discord, and the ethresear.ch online forum. We decided not to recruit further because no new
insights emerged from our four latest study sessions, indicating a sign of theoretical saturation [52].

The participation in our study was completely voluntary, and participants were allowed to quit at any time. Each
participant received a $30 Amazon e-gift card upon completion of the study. The whole study lasted about one hour,

19https://0x.org/docs/guides
20https://solidity.readthedocs.io/en/develop/
21https://pact.kadena.io
22https://github.com/OCamlPro/liquidity

5

where the initial interview took about 25 minutes, the code review task 25 minutes, and the exit interview about 10
minutes.

4.2

Initial Interviews

Since we did not know much about the phenomenon under investigation (security practices of smart contract devel-
opers), we felt that an exploratory qualitative study would be appropriate since it will provide rich data about the
phenomenon. Therefore, we started with an semi-structured interview. In the study, we ﬁrst presented the study con-
sent to our participants. Once they have agreed, we proceeded with a semi-structured interview. We designed the
interview scripts based on our research questions outlined in the introduction section. The entire script can be found
in our study GitHub23. We started by asking about their general background including their usage of programming
languages, their role and experiences in developing software, as well as their experience and motivation on how they
started smart contract development. Sample questions are like “What role do you typically play in cryptocurrency
projects?”, “What programming languages do you use regularly?”, “ How did you learn smart contract develop-
ment?.” Then we asked a series of questions to understand their knowledge and experiences of developing smart
contracts and handling security issues thereof. Their experiences include tools for writing contracts, guidelines for
smart contract development, factors considered and challenges encountered during development.

To understand how smart contract developers tackle potential security risks in the development process, we also
asked about their current practices (e.g., use of coding standards, policies, and security analysis tools as well as any
educational resources) related to smart contract security. To get rich anecdotal data, we also asked about their personal
experiences and stories of how they handled speciﬁc smart contract security related issues in the past.

Thus, interview questions get at not only general practices but also speciﬁc cases (e.g., “What are the most frequent
security issues you have encountered? Please tell us about any incident that you can remember when your developed
smart contract was exposed to certain security vulnerabilities. What types of methods/tools are you/your organization
currently using to ensure the security of smart contracts? Have you used any automated security analysis tools? Can
you explain more about the tools? Is it easy or hard to use?”). Through qualitative analysis of interview data, we
identiﬁed coding themes emerged from the data on development practices of smart contract developers. Example
themes include “functionality correctness is a priority,” “security is not important when projects are deployed on
testnets,” “Solidity language limitations make smart contract security hard.” The code review task was designed to
show how “concretely” they go about reviewing the code and identifying potential vulnerabilities.

4.3 Smart Contract Code Review Task

The next study component was a smart contract code review task. Since code review is a common task in smart contract
development, this task was designed to understand how smart contract developers conduct code review particularly
for identifying security vulnerabilities. Each participant was asked to review one smart contract that we created.
Speciﬁcally, they were instructed to do the following: (1) share their computer screen and allow us to record the
screen with their permission to understand how they conduct the code review; (2) have at most 25 minutes for the code
review; (3) search/use any resources/tools they need; (4) i. review the code; ii. identify security vulnerabilities and/or
areas for improvement; iii. modify the code accordingly; (5) explain the modiﬁcations and rationale behind them.

4.3.1 Code Review Task Design

We designed this study component to model the real-world code review task that developers would be reasonably
expected to encounter in their smart contract development. We chose to include two vulnerabilities in each smart
contract where one vulnerability is more well-known and should be easier to identify than the other. We measured the
difﬁculty level of these vulnerabilities based on our pilot participants’ feedback. We also included some minor code
writing standard issues, such as indentation, space/tabs, and blank lines which should be easily detectable.

We chose four smart contract vulnerabilities based on the recent literature on smart contract exploitation ([24, 48])
and reports 24 on most frequent exploitation. The four chosen vulnerabilities are: 1) re-entrancy, 2) unchecked low
level calls, 3) integer overﬂow, and 4) improper access control. The ﬁrst two vulnerabilities were included in one
contract and the last two vulnerabilities in another contract. The contract code can be found in our study GitHub repo.
Table 1 summarizes the four security vulnerabilities we included in the code review task and ways to avoid/address
these vulnerabilities.

23Our

study repo includes

study scripts,

smart

contracts

for

the

code

review task,

analysis

code book:

https://github.com/AccountProject/SmartContract

24https://swcregistry.io/

6

Table 1: Vulnerabilities in code review task as well as effective strategies to address these vulnerabilities.

Vulnerability
Reentrancy

Unchecked
Calls

Low-Level

Integer Overﬂow

Improper Access Control

Description
Calling external contracts is that they can take over
the control ﬂow, and make changes to the data that
the calling function is not expecting.
This can lead to unexpected behaviour and break the
program logic. A failed call can even be caused by
an attacker, who may be able to further exploit the
application
An integer overﬂow occurs when an arithmetic oper-
ation attempts to create a numeric value that is out-
side of the range
Exposing initialization functions by wrongly naming
a function intended to be a constructor, the construc-
tor code ends up in the runtime byte code and can be
called by anyone to re-initialize the contract.

Possible Prevention Technique
Make sure it does not call an exter-
nal function or use the Checks-Effects-
Interactions pattern.
Ensure to handle the possibility that
the call will fail by checking the return
value.

Use of vetted safe math libraries
for arithmetic operations consistently
throughout the smart contract system.
Implement controls so withdrawals can
only be triggered by authorized parties
or according to the specs of the smart
contract system.

We created our two smart contracts using a boilerplate contract of ERC-20 token which provides basic functionalities to
transfer tokens and allow tokens to be approved so they can be spent by another account. The ERC20 token contract is
commonly used as a basis for smart contract (DeFi) projects. Numerous DeFi projects and open source smart contracts
adopt the ERC20 standard interface. The ERC20 standard interface can create tokens on Ethereum and can be re-used
by applications such as wallets and decentralized exchanges. We believed that most smart contract developers would
have some familiarity with this contract and our pilot study conﬁrmed our assumption. Our contracts for code review
have the same basic ERC-20 functionalities.

To select smart contracts vulnerabilities, we conducted an extensive review of exploited smart contracts from different
security vulnerability reports, such as Smart Contract Weakness Classiﬁcation and Test Cases (SWC) 25, Consensys
Known Attacks 26, different GitHub repositories and etherscan source code of abandoned or previously exploited
smart contracts 27. To make our code review task realistic for participants to complete in 25 minutes, we trimmed
down some auxiliary functions from the selected contract sample code. Both of the contracts for code review are
ERC-20 based and there are no major differences in size. We then modiﬁed the contract by adding the vulnerabilities.
We got feedback from solidity programmers and tested the contracts in our pilot. We included comments in the contract
code for participants to understand the overall context of the contract functions. We also added explicit comments to
those function that are not part of the ERC20 token standard (interface).

During the task, we provided the instructions verbally. After giving the instructions, we provided the GitHub link
which contained the smart contract for review to the participants through Zoom chat. We provided some extra time for
participants to set up their development environment before we started counting the 25-min task time. This set-up time
which was not counted in the 25 minutes. Since the target participants are very busy, we limited our study to about one
hour. Code review time (25 minutes) is based on the code length, which varies signiﬁcantly in practice (10-1000 lines
of code). It is a limitation but for practical reasons it was a trade-off between study time and participant’s availability.

4.4 Exit Interview

Once the task was completed or the time ran out, the participants were asked a few questions in the exit interview. We
asked their opinions about the task they worked on and how they perceived the difﬁculty of the task. We also asked
their overall experience with the code review task and if they would like to share any other experiences of security
practices in smart contract development. We also asked if they had any feedback on this study and whether this study
has changed their perspectives and/or attitudes towards smart contract security. Finally, we asked about their desired
features of security tools to help them better ensure smart contract security. We received the modiﬁed code by each
participant via email. This data allowed us to determine whether they correctly identiﬁed the vulnerabilities.

25https://swcregistry.io/
26https : //consensys.github.io/smart − contract − best − practices/knownattacks/
27https : //etherscan.io/directory/SmartC ontracts

7

4.5 Pilot study

We conducted two rounds of pilot study with a total of four smart contract developers to test our study design. We
revised our interview questions and code review tasks based on their feedback. Details of the pilot study and the
changes we made based on the pilot results are described in the Appendix 8.1.

4.6 Data Collection and Analysis

Study data were obtained primarily through Zoom audio/video/screen recording of the interviews and the code review
task upon participants’ permission. We collected each participant’s interview responses, smart contract code from the
code review task, think-aloud responses, and exit interview responses during the session. We transcribed the recordings
and analyzed the transcripts using thematic analysis [53].

4.6.1 Qualitative Data analysis

Two researchers performed open coding independently on a sample of the data (20%). Then they met regularly to
discuss the coding and reached a consensus on a shared code book before coding the remaining data. We calculated
the inter-coder reliability in Cohen’s Kappa, which was 0.94 and considered very good [54].

Our open coding followed an inductive analysis method to explore practices and behaviours towards smart contract
development. Our codebook includes 46 codes. Then data and concepts that belonged together were grouped into
sub-categories. Further abstraction of the data was performed by grouping sub-categories into generic categories, and
those into main categories. We then grouped related codes, organized them in high-level themes, and iterated this
process to ﬁnally produce 18 themes to interpret the results of smart contract developers’ security practices, security
concerns and individual experiences and challenges with tools and development methods. Some example themes are:
perceived priorities in smart contract development, use of information resources, use of development tools, use of
smart contract security tools, and limitations of smart contract security tools.

4.6.2 Assessing The Code Review Task Outcome

For the code review task, recorded videos of the participants performing the code review task were analyzed to measure
the success rate, based on whether a participant correctly identiﬁed the security vulnerabilities in the smart contract.
Prior to conducting the lab study, we created and veriﬁed the correct/secure solutions for each task. The general
ideas for these solutions are described in Table 1. This ensured that we could verify whether participants successfully
identify the vulnerabilities and provide a correct/secure answer or ﬁx. We also paid attention to how they conducted
the code review, e.g., whether and how they searched and used any resources/tools. Speciﬁcally, we conducted a
hierarchical task analysis [5], a common Human-Computer Interaction (HCI) technique, to break down the process of
how a participant performed the code review into detailed steps and to help identify how the processes of successful
and failed code reviews differ. We also checked whether their suggestions or modiﬁed code could potentially ﬁx the
vulnerabilities.

5 Findings

In this section, we present our study results in diverse views and practices of smart contract security. We have found
none of the early stage developers consider security as a main factor and lack awareness of relevant relevant informa-
tion resources and tools for smart contract security. We also discuss our lab study in terms of task success rate and
time to identify security vulnerabilities, use of different code review approach. We found that experienced developers
(3-5 years of experience) were able to identify these common vulnerabilities and many used a combination of security
tools such as static analysis, and interactive call graphs.

5.1 Participants

We had a total of 29 participants. 24 of them are male and the rest are female. More than one third of our participants
are from the US, and the rest are from many other countries, including India, China, Australia, Ghana, Egypt, Iran,
UK, Canada, Germany, New Zealand, Greece. Our participants include fourteen smart contract practitioners who work
full-time in the DeFi industry, three freelance smart contract developers, three software developers mainly worked in
other domains, eight college/graduate students, and one professor. Table 2 summarizes our participant demographics.

To explore the relationship between our participants’ different levels of Solidity development experiences and their
security practices, we categorized our participants into two groups: early-stage (less than 1 year of experience) and

8

ID
Early-Stage
P1
P3
P4
P5
P7
P9
P16
P20
P24
P28
Experienced
P2
P6
P8
P10
P11
P12
P13
P14
P15
P17
P18
P19
P21
P22
P23
P25
P26
P27
P29

Gender

Country

Occupation

Year(s) Exp.

Focus

Types of Projects Developed

USA
Male
USA
Male
Australia
Male
Male
India
Female USA
USA
Male
India
Male
Male
USA
Female Canada
Male

USA

Developer, DeFi Company
Masters Student, CSE
Researcher, DeFi Company
Bachelors student, CSE
Masters Student, CSE
Professor, CSE
Freelance Smart Contract Dev
Bachelor Student, CSE
PhD Student, CSE
Developer, De-Fi Industry

Female USA
USA
Male
Ghana
Male
Male
USA
Female China
Female Egypt
Male
Male
Male
Male
Male
Male
Male
Male
Male
Male
Male
Male
Male

Developer, DeFi Company
PhD Student, CSE
Freelance Smart Contract Dev
Developer, DeFi Company
Dev, DeFi Company
Freelance Smart Contract Dev
Software Developer
Iran
Co-Founder,dev, DeFi Company
UK
Software Developer
India
Software Developer
India
Dev, Deﬁ Company
USA
CTO, DeFi Company
USA
Bachelor Student
India
PhD Student, CSE
Germany
Developer, DeFi Industry
Australia
Developer and Researcher
Greece
Developer, DeFi Industry
Germany
Developer, DeFi Industry
Canada
New Zealand Developer, DeFi Industry

<1
<1
<1
<1
<1
<1
<1
<1
<1
<1

2-3
3-5
3-5
3-5
2-3
3-5
3-5
2-3
2-3
2-3
2-3
3-5
2-3
3-5
2-3
2-3
2-3
3-5
3-5

Distributed systems, cryptography
Security applications in Software
Smart Contract
React apps development
Security product on authorization
Security auditing of smart contracts
blockchain based project
Class project on Blockchain

Backend
Backend
R&D
Front-end
Backend
Backend
Backend
Backend
Full-Stack Research on blockchain
Backend

Distributed Ledger Technology

Software for Retail
Formal framework in cryptography
Blockchain software from scratch
Software for privacy, blockchain

Front end
Backend
Full-stack
Full-stack
Full-stack Application for ﬁnance, game, NFT
Full-Stack Blockchain based project
Backend
Backend
Backend
Backend
Full-stack
Backend
Backend
Backend
Backend
Backend
Backend
Backend
Backend

Application for health sector
Developed DAO, solidity projects
Machine learning and AI project
Smart contract for donations
Research and architecture in DeFi
Snapchat and DeFi token
Hyperledger and Ethereum related project
Blockchain for data storage
Financial smart contracts (Tracer)
Gaming / betting smart contract
Auditing Smart Contract
Layer 2 project in smart contract
De-Fi Project

Table 2: Participant demographics and background. We consider those with less than one year of experience in Solidity
as early-stage developers and those with longer experience as experienced developers.

experienced (2-5 years of experience) in Solidity smart contract development. We had 10 early-stage developer par-
ticipants and 19 experienced developer participants.

5.2 Programming and Development Background

Programming background. Our participants reported using multiple programming languages. Besides Solidity,
other languages mentioned are Python (55%), Javascript (39%), C++ (24%), Java (13%), and C (13%). Besides smart
contract development, they also reported other expertise such as backend development (69%), front end development
(7%), full-stack (21%) and research (4%).

Information resources used for smart contract development. Our participants mentioned a number of information
resources that they used for smart contract development. Common sources are Solidity documentation (34%), Google
search (31%), Stack Overﬂow (17%), YouTube (14%), as well as documents published by the Ethereum Foundation
(14%), OpenZeppelin 28 (14%), and ConsenSys 29(14%).

Tools for smart contract development. Participants mentioned a large set of tools they used to develop, deploy,
and test their smart contracts. Most frequently used tools included Trufﬂe (76%), Remix (55%), Ganache (38%),
HardHat(34%), and Wafﬂe (21%).

Practices of code re-use. 52% (15) of our participants (5 early-stage and 10 experienced developers) talked about
using code from open source libraries such as OpenZepplin, a popular implementation of the ERC-20 and other ERC
standards. For instance, P24 said “I try to use the libraries from OpenZepplin because they are kind of best practice,
for example, for access control and things like that.”

Experience in code review. 76% of our participants had different levels of Solidity code review experience. Some
conducted code review by pen and paper (P1,P6,P20, P25), some used automated test scripts/tools (e.g., OpenZepplin
ERC20 library) for code review (P2, P24, P26, P27), and some used both techniques (P14, P19, P24, P26). Seven
out of 10 early-stage developers had prior code review experience in Solidity. P1, P3 and P7 indicated that they had
experience but are not experts. Four out of 15 experienced developers did not have prior code review experience

28https://openzeppelin.com/
29https://consensys.net/

9

Figure 1: Participant success rates of identifying se-
curity issues. The average success rates for early
stage and experienced developers are 15% and 55%,
respectively.

Figure 2: Participant average time (minutes) to suc-
cessfully identify security vulnerabilities. The early
stage developers did not identify the low-level call
vulnerability.

in Solidity. However, among the seven participants who did not have code review experience in Solidity, three of
them had much code review experience in other languages, such as Python (P3), RUST (P8) and Golang (P22). Four
participants (P4, P5, P13, P17) did not have any prior code review experience in any language.

5.3 Perceptions of Smart Contract Security

Is security a priority in their smart contract development? We asked our participants their priorities in smart
contract development, most participants (83%) did not claim security as a top priority and cited three main reasons:
(1) they need to ship projects fast and security becomes secondary, (2) their projects forked other popular projects (e.g.,
Uniswap), which are often already vetted by the community, and (3) someone else internally or externally will conduct
security audits. However, the majority of participants considered functional correctness (66%) and gas optimization
(48%) as important priorities. Both are actually closely relevant to security. We saw functional correctness as a form
of security earlier. Gas optimization saves transaction cost but also reduces the possibilities of economic security
issues such as front-running (e.g., attackers observe a user’s buy transaction in the mempool and submit another buy
transaction with a higher gas fee to outbid the user’s transaction).

One early stage and 11 experienced developer participants mentioned security as one of the factors they considered
in smart contract development. Figure 6 in the Appendix presents the different factors our participants mentioned.
However, only ﬁve participants (P3, P11, P14, P26, P27) said that they considered security as a priority during de-
velopment. Except P3, all other four participants were experienced developers. They evaluated different aspects of
security. For instance, P11 explained: “I considered security the most important factor because you need to know the
address in the blockchain to send and receive, [...] the address should be unique and it’s secure and cannot be changed
by someone else.” P14 instead paid more attention to the reentrancy and front-running issues, and explained “[...] a
lot of security thought, can someone front run this? Can they reenter it? ”

Why (Solidity) smart contract security is hard? Five participants (P25, P14, P18, P19, P24) pointed out that the
Solidity language design has some inherent limitations for maintaining security. P25 (as well as P14, P18, P19, P24)
noted the ambiguity of Solidity programming language where function deﬁnition is not explicit: “It is very limited
and so this requires you to go through hoops to do very basic things like access that you could do easily in [a]
mainstream language”. He suggested that adopting functions like in Python. P19 spoke about another issue with
Solidity: “Contract work[s] like state machine when you send a transaction. It only appears like state changes. But
in regular program, you can differentiate read only calls and state changes. Solidity can not do that.” He also added
the difﬁculties of performing proper string and array manipulations due to a lack of direct language/library support in
Solidity. To ﬁll this gap, this participant created his own assembler to correspond between Solidity instructions and
machine code instructions.

5.4 Practices of Smart Contract Security

Our participants explained their practices of ensuring smart contract security. They shared their methods and their
experiences in working with other team members. We start by discussing the different strategies they followed.

Manual inspection of smart contracts. Eight (28%) participants reported using manual code inspection as the main
method for identifying security issues in their smart contracts. For instance, P28 tried to think as an attacker while he
read through the code. “Reading through the code and then thinking of how to steal everyone’s money or do something

10

0%20%40%60%80%ReentrancyLow-LevelCallOverflowAccessControlEarly (n=10)05101520ReentrancyLow-LevelCallOverflowAccessControlExperienced (n=14)Early (n=2)malicious.” As an other example, P6 combined ﬂow charts with manual code inspection: “I think step one always is
to draw ﬂow chart of where information are ﬂowing and where [...] coins can get stuck and protocols. To ﬁnd places
where reentrancy can happen. So, having a graph of good representation can solve a lot of logical issues. And then
trying to look at problems how calls are being made? Is there contracts gonna run out of gas? All that is just manual
code inspection. ” As P6 read through the code, he created ﬂow charts to help track the system logic but also identify
issues of reentrancy and gas cost.

Use of smart contract testing or security tools. Nine (31%) participants reported using smart contract tools for
security purposes. Testing or security tools, such as static analysis tools (17%), Trufﬂe testing suite (14%), Remix
security plugins (14%), MythX (7%) and Slither (3%).

Limitations of current smart contract security tools. About one third of our participants (P4, P6, P7, P12, P14, P19,
P22, P24, P25) spoke about the limitations of existing security tools for smart contracts. For example, P6 explained:
“I don’t think there are any automated tools [...] Even once you deploy the contract, having to write a constructor,
then testing that contract is a really cumbersome activity. It’s non-trivial, and there really exists no tool to help. Even
trufﬂe testing is quite hard to use in my experience.” P25 also complained about the Trufﬂe tool being slow: “I didn’t
like trufﬂe because it was a little slow. I had to rely on global imports into Files and then had to run all ﬁles from
command line using trufﬂe suit for testing which make iterative development complex.” P24 similarly stressed the
importance of better integration of security tools into the development process, saying “I don’t like to write code in an
IDE and use another tool to test. I like my compiler to do everything for me. I don’t like to use extra tool for checking
bugs and security.” Better understanding and improving the usability of smart contract security tools is a direction for
future research.

After presenting how our participants self-reported their security practices, next we will cover how they actually
behaved in identifying security issues in the code review task.

5.5 Findings from The Smart Contract Code Review Task

In this task, we asked our participants to review a smart contract to identify any security issues or areas of improvement.
We also asked their rationale for any code modiﬁcations.

Task performance of identifying security vulnerabilities. Overall, 55% of participants found at least one security
issue in the smart contract. 28% (N=8) of participants identiﬁed both (all) vulnerabilities in the smart contract. More
speciﬁcally, Reentrancy had the highest identiﬁcation success rate (53%), followed by improper access control (43%),
unchecked low-level call (40%) and lastly integer overﬂow (29%).

Figure 1 shows our participants’ performance (success rate) in identifying different security vulnerabilities. We ob-
serve that experienced developers had much higher success rate (55%) than their early stage counterparts (15%).
Table 3 summarizes each participant’s task performance as well as the method they used to identify the security issues.

In addition, we recorded and calculated how long participants took in successfully identifying each security issue,
as summarized in Table 4. We observed that for reentrancy early stage developers spent more time. None of the
early stage developers identiﬁed the low-level call vulnerability. Only one early stage developer (P28) identiﬁed the
overﬂow (about 7 minutes) and insecure access control issues (about 8 minutes). Code Review task time is detailed
in Table 4, Appendix 8.4. For participants who failed to identify any security issues, they all used up the 25-minute
period we gave them.

Developers with formal training in smart contracts were associated with better task performance. We also
explored how our participants learned to code smart contracts and observed a trend that those participants who had
formal educational training in smart contracts tended to do better in the code review task and had more awareness of
security practice. We found six out of eight participants (who identiﬁed both security vulnerabilities in code review
task) had formal training for writing smart contracts. Some of them (P 12, P 25, P 27) designed courses on smart
contract and has been teaching in universities and community groups. P27 said - “I learned smart contract coding as
a part of my research in school. Then I helped design and develop the technical content to lecturer where I was the one
to initiate that course in a college in Canada.” P28 mentioned formal learning for smart contract coding is important
to avoid known vulnerabilities. “There’s always new developers who are just throwing code out there as quickly and
fastly with very little testing, no peer code review, no security considerations, and no experience and learning. So
they’re introducing problems. A lot of seasoned developers with awareness stopped doing this ages ago, and there’s
always new developers popping up, launching code with known vulnerabilities in them.” We also found 10 out of 13
participants (who failed to identify any security vulnerabilities in code review task) relying on informal learning (e.g.,
YouTube, Stack Overﬂow, adhoc google search, Solidity docs) for smart contract coding. Future research can further
investigate the relationship between formal training and security practices of smart contracts.

11

Figure 3: P14’s process for the code review task1. He
used linting and static analysis tools.

Figure 4: P2’s process for the code review task1. P2
failed to identify any security vulnerabilities.

Different approaches to code review. Participants used different ways to identify security issues during the task.
Most of them manually read through the code. Only four of them used security assessment plugins and/or static
analysis tools.

For instance, P14 used linting and static analysis tools in his code review. He successfully identiﬁed both vulnerabil-
ities (reentrancy and unchecked low-level call) in the contract. We did a hierarchical task analysis [5] to break down
how a participant conducted the code review into detailed steps. Figure 3 illustrates P14’s code review process.

P14 started by quickly setting up his development environment, where he created a folder with a package manager and
installed development dependencies so he could compile the contract. He stressed the importance of having the folder
ready to compile ﬁrst. He explained,“ Let’s get some scripts, dev dependencies and I’m going to run that here and run
yarn. Things that will allow me to compile, check coverage, test, clean it. I will make sure that it’s linting as well. ”

After compilation, he started looking for possible security issues. He also manually went through the Open Zeppelin
implementation of ERC20, “I would literally track this whole thing and I’d use Open Zeppelin implementation. I can
go through this implementation and see if it’s good or not.” Importantly, he did not blindly take or trust the Open
Zeppelin implementation even though it is widely used. After manually checking the code, he explained some of the
possible vulnerabilities. For instance, he pointed out a potential reentrancy vulnerability in the withdraw function: “it
is withdrawing if the amount is less than the amount to just return false and subtracts the amount before it does the
accounting before it’s actually sending anything out, which is pretty crucial for preventing someone re-entering the
function, which would be really bad.” He then ran static analysis with Slither to conﬁrm his suspicion. He interpreted
the Slither output: “we can see if there’s any fatal errors. Yeah, so exactly- state variables written after the re-entering
pool. That’s only if it’s not successful. so I mean there’s reentrancy in over here.”

Unlike P14, many participants just did manual inspection of the code without using any security tools. For instance, P6
only did manual inspection. But he also searched information resources such as security best practices in the ofﬁcial
Solidity documentation and the Open Zepplin documentation. He also successfully identiﬁed both vulnerabilities (in-
teger overﬂow and improper access control) in the contract (task2) he reviewed. For instance, upon manual inspection,
he found that the amount of a local variable is calculated as the product of two other variables cnt and value. The
later can have an extremely large value which can overﬂow the product and make it zero (as shown in Figure 5). He
suggested using the Safe Math library.

P2, an early stage developer, was one of the 13 participants who did not ﬁnd any security vulnerabilities in the code
review task. He was assigned the same task (task 1) as P14. Figure 4 illustrates P2’s code review process. He started
by skimming through different functions of the code. After almost ﬁve minutes, he said, “This seems like a security
ﬂaw here in “transferfrom” function. I will look deeper later.” Then, he went through a few functions randomly, such
as “transferfrom”, “allowance,” and put another comment on the transfer function: “I did misread the “transferform”
before. I was looking at in a wrong direction. Now it makes a lot more sense and then you’re veriﬁed with a certain
amount of tokens.” At this point, he was not sure about vulnerabilities. For conﬁrming some of his suspicion, he
searched “ERC-20 code” and “Reentrancy,” in the Open Zeppelin contract example. He also read through some code
examples in GitHub repos that included ERC-20 code example. As the time was close to 25 minutes, he concluded:
“I don’t see anything major. Not really seen doing much wrong.”

What is interesting here is that even though P2 found and read some reference documentations about ERC20 (e.g.,
Open Zeppelin) similar to P14, P2 was still not able to identify the security issues. A similar example is P22 (whose

12

StartOpen contract via VS CodeUpload Task.sol code into new folderRun Yarn init for package manager (package.json)Add scripts for dev dependenciesInstall Yarn for compiling/checking test coverageLinting plugin working?Check Solidity version & MIT identifierReview ERC20 interface codeSkim through contractProper code syntax & standards?Reformat code accordinglyNoCross check contract code with Open Zepplin codeYes Identified possible vulnerability?Modify error with existing proprietary codeCompile code with HardHatRun Slither to confirm re- entrancyCompile codeEndNoUnchecked low level call?Re- Entrancy?YesNoYesYesYesNoNoreview process ﬂowchart is Figure9 the Appendix). In addition, many of our participants (e.g., P3, P15, P20, P21) who
did use security tool(s) also missed some security issues. These observations suggest that just by accessing standard
documentation, reference implementations and security tools is not sufﬁcient in helping developers (especially early
stage developers) identify security issues. We included a few more examples of how other participants performed the
code review task in the Appendix 8.3.

Code modiﬁcations for improvement. For the 16 participants who have successfully identiﬁed at least one vulner-
ability, seven of them modiﬁed the contract code for improvement and six (21% of all participants) correctly ﬁxed
the vulnerabilities. The modiﬁed code snippets are included in the Appendix 8.4. Due to the time constraints, the
other nine participants did not modify the code but verbally commented on how the contract code could be improved.
Conceptually, all the comments would ﬁx the security vulnerabilities.

False positives. We also observed that sometimes our participants incorrectly thought they identiﬁed security vul-
nerabilities, which were actually not vulnerabilities (i.e., false positives). Four (14%) participants had false positives
and they tended to have less prior experience with smart contract development. For instance, P1 thought there was a
security issue in the “approve” function (Figure 15 in Appendix). He explained, “it is possible for adversary to call the
function in StandardToken and this would bypass ‘whennotpaused’ modiﬁer.” However, there was a “Pausable” base
contract, which can implement an emergency stop mechanism where “whenNotPaused” modiﬁer was only callable
when the contract is not paused. Also when it is called by the owner to pause, it triggers the stopped state. Hence, one
cannot bypass the “whennotpaused” modiﬁer. P1 googled different keywords related to ERC20 and ﬁnally found the
Open Zeppelin ERC20 contracts for reference.

Resources used during the task. During the code review task, participants were told that they could use any re-
sources or tools. Most frequently searched resources include Solidity documentation (28%), Open Zepplin (17%), and
Google search with keywords (17%). Some of the search terms used were “parent contract call,” “safe math parent
class,” “fallback function,” “emit in solidity,” “reentrancy vulnerability example,” “example of transfer and withdraw
function,” “constructor example,” and “solidity version speciﬁc details.”

Tools/Frameworks used in the task. After sharing the GitHub link of our smart contracts for the code review task,
participants were initially using Remix (48%), VS code (28%), Sublime Text Editor (14%) and IntelliJ IDEA (3%), or
manually conducting code review on GitHub (7%) for the task. In addition, 24% of participants used a static analysis
tool, such as Remix static analyzer plugin, Slither, and Oyente, during the task. One participant used a dynamic
analysis tool, MythX during the code review task.

f u n c t i o n b a t c h T r a n s f e r ( a d d r e s s [ ]
whenNotPaused r e t u r n s
c n t =

u i n t
r e q u i r e ( c n t > 0 && c n t <= 2 0 ) ;
u i n t 2 5 6 amount = mul ( u i n t 2 5 6 ( c n t ) ,

r e c e i v e r s . l e n g t h ;

( b o o l ) {

v a l u e ) ;

r e c e i v e r s , u i n t 2 5 6

v a l u e ) p u b l i c

/ / below i s p o s s i b l e
r e q u i r e ( v a l u e > 0 && b a l a n c e s [ msg . s e n d e r ] >= amount ) ;

t a k e n c a r e o f by s u p e r . t r a n s f e r

/ / b a l a n c e s [ msg . s e n d e r ] = b a l a n c e s [ msg . s e n d e r ] . s u b ( amount ) ;
i ++) {
f o r
a r e

a d d r e s s ( 0 x0 ) −−> r e v e r t

i < c n t ;
r e c e i v e r s

i = 0 ;
i f

c h e c k s

i f

t r u e

r e c e i v e r s [ i ] ,

v a l u e ) ;

( u i n t
/ /
s u p e r . t r a n s f e r (
/ / b a l a n c e s [
/ /

r e c e i v e r s [ i ] ] = b a l a n c e s [

r e c e i v e r s [ i ] ] . add ( v a l u e ) ;

e m i t T r a n s f e r ( msg . s e n d e r ,

r e c e i v e r s [ i ] ,

v a l u e ) ; }

r e t u r n t r u e ;
}

}

Figure 5: Part of the contract code P6 reviewed and modiﬁed. The ﬁrst few lines had a overﬂow vulnerability where
local variable is calculated as the product of cnt and value. By having two receivers passed into batchT ransf er,
with that extremely large value, attacker can overﬂow amount and make it zero.

13

6 Discussion

6.1 Recap of Major Findings

Our study aimed to understand the security practices and challenges of smart contract developers. Overall, we found
that our participants had diverse perceptions and behaviors regarding smart contract security.

While the majority (83%) of all participants did not mention security as a priority in their smart contract development,
a large portion of all participants mentioned functional correctness (66%) and gas optimization (48%) as important
priorities, both of which are closely relevant to smart contract security.

Five participants said that they considered security as a priority in their smart contract development. Among the ﬁve
participants, only one of them was an early stage smart contract developer while the other four were experienced de-
velopers. Early stage developers tended to think security is not important for their projects since they felt their projects
have little impact in part because they are not deployed in the mainnet and thus are not an interesting target for attack-
ers. As a result, they often lack awareness of smart contract security issues as well as resources and tools about smart
contract security. While the impact of security vulnerabilities in smart contracts deployed on the testnet is limited,
there is a missed opportunity to motivate and educate (early stage) developers about smart contract vulnerabilities and
corresponding best practices. Prior research in traditional software development suggests that this kind of perception
can have a long-term negative effect on development practice [41]. Prior work on software security has also shown the
value of improving security education and awareness [55, 49].

In comparison, our experienced developer participants indicated that their companies or projects have faced security
issues, including known and edge cases. For security practices, they mentioned using best practices and resources,
such as Open Zeppelin contracts (reference implementations) and Solidity ofﬁcial documentation. However, their
responses also suggested that they tended to rely on security audits as the ﬁnal security evaluation.

In terms of their actual behavior in the code review task, early stage developer participants had a much lower success
rate (15%) of identifying security vulnerabilities in the reviewed code than their experienced counterparts (55%). The
majority (72%) of all participants only did manual inspection of the code where they tried to run through possible
execution traces to ﬁnd out vulnerabilities as well as edge cases. 20% of early stage developers used security tool(s)
in the code review, compared with a higher percentage (32%) of their experienced counterparts. The early stage
developers only used Remix with its security plugin whereas the experienced developers used more tools such as static
and dynamic analysis tools (e.g., Slither, MythX). Our hierarchical task analysis of their code reviews implies that just
by accessing standard documentation, reference implementations and security tools is not sufﬁcient. Many developers
checked those materials or used a security tool but still failed to identify the security issues.

In addition, one third of the participants pointed out many limitations of smart contract security tools, such as lack of
comprehensive libraries, integration of these tools as part of the IDE as well as complex user interfaces. How to make
existing smart contract security tools more usable is an important direction for future work.

6.2 Smart Contract Security vs Traditional Software Security

There exists systematic software security guidelines, NIST 30 and OWASP 31 to facilitate secure software development
practices amongst business owners and software developers for traditional software. These help software producers
to mitigate the potential impact of exploitation, and address the root causes of vulnerabilities to prevent future recur-
rences. Compared with traditional software, smart contract development is a relatively new landscape. With the recent
boom of the DeFi industry (since 2020), a new pool of developers joined this industry and started writing smart con-
tracts. Their knowledge of and experience with smart contract security vary widely, as observed in our study. There
are some information resources on smart contract security, such as ConsenSys and Solidity documentations, which
provide design patterns that developers should follow. However, we are not aware of a framework for organizations to
properly assess and communicate smart contract security during the development life cycle.

Apply software security solutions in smart contracts. Our results suggest some similarity of practices and chal-
lenges between smart contract and general software security. Thus some security strategies of software development
can be applied to smart contracts. For instance, some participants indicated the importance of relevant documentations
within the IDEs which can support their learning in smart contract development. The literature on secure software en-
gineering has made similar suggestions (e.g., [56, 55]). Our participants also desired well-structured, context-speciﬁc
security warnings. This aligns with prior literature that suggests effective security warning to reduce cryptographic

30https://csrc.nist.gov/Projects/ssdf
31https://owasp.org/www-project-security-knowledge-framework/

14

API misuse [49]. The prior literature on cryptographic APIs [55] suggests that simpliﬁed libraries can promote se-
curity. However, it might not be the case in the domain of smart contracts. Many participants in our study explicitly
requested the security/testing libraries to be more comprehensive in covering most if not all security issues. Further
research is needed to investigate this idea. Our study also highlights the inconvenience of using different tools and
plugins to detect different vulnerabilities.

Why is smart contract security different and difﬁcult? Smart contract security have some fairly unique or more
prominent characteristics and often have a signiﬁcant ﬁnancial impact, especially for DeFi projects. It is fairly easy
to monetize the attacks (e.g., “stealing” tokens and passing them to a mixer before selling them). In addition, the
system states are visible on public blockchains and the smart contract code is often open-sourced, thus the public
nature makes them targets for attacks. Besides, the additional economic considerations (e.g., incentive mechanisms,
gas cost) add more complexities to smart contract security (i.e., economic security) [57]. Furthermore, in the smart
contract development ecosystem, there is wide reuse of library code or interactions with other smart contracts (DeFi
projects known as “money lego” because they can be created by composing smart contracts from different projects)
[58]. This composability, however, also opens the door for trusting and calling untested and potentially vulnerable or
even malicious smart contracts.

6.3

Implications for Smart Contract Security

Our study results provide a number of implications for smart contract security education and tools. Speciﬁcally, we
will discuss the implications for smart contract education, compilers, libraries, development frameworks, IDEs, and
testnets.

Education. Our results suggest that accessing documentations, reference implementations and security tools is not
enough in helping developers identify smart contract security vulnerabilities. Education that improves their motivation,
knowledge and awareness regarding smart contract security is crucial. While there are many reading materials for
educational purposes, we believe what is missing is hands-on exercises or labs for smart contract security, similar to
the SEED projects for computer security in general [59]. Once these educational materials (e.g., hands-on labs) are
created, they should be brought up when corresponding security issues are detected (i.e., teachable moments) in the
various components of the smart contract ecosystem (e.g., compilers, security tools, IDEs, testnets).

Compilers. Our results indicate that most of our early-stage developer participants were not familiar with the basic
smart contract security concepts and common vulnerabilities. Some suggested integrating security analyses (e.g., static
analysis) directly into the Solidity compiler, so that they can obtain the security assessment without any extra step.

Code libraries. Some participants commented that current security libraries fall short of covering edge cases. Most
of the recent tools work on the byte code for identifying security vulnerabilities. The parser and symbolic execution
engine work solely on the byte code, so if developers see a potential integer under/overﬂow, they will report it, but
they do not know where it occurs in the source code. A direct mapping between security vulnerabilities and source
code would be valuable.

Error / warning messages. Many participants noted the error messages from current testing libraries can be over-
whelming and hard to understand. For instance, P23 felt the error messages lack actionable insights. The (security)
error messages can be improved by including links to detailed explanations, known incidents, and how to correct the
issues. Since many early-stage developers did not see the importance of security in smart contracts, connecting their
own code (vulnerabilities) to past incidents of security vulnerabilities might improve their awareness of smart contract
security. Some participants also suggested having better GUIs to present those information. For instance, P7 compared
the Solidity tools to that of another language Python, which has a nice graphical user interface to show where exactly
the problems are in the code and how signiﬁcant the effect can be. Creating hierarchical GUIs where developers can
see an outline of issues and can then zoom into speciﬁc issue or information would make the security assessment
outputs less overwhelming.

Formal veriﬁcation. In addition to static analysis, some participants also felt that many vulnerabilities could have
been avoided with the help of formal analysis and veriﬁcation, which were not built into Solidity. They believed that
formal veriﬁcation can enhance code coverage in terms of correctness, because they are based on mathematical proofs.
Future research and development could create more formal veriﬁcation tools for smart contract security.

Integrated Development Environments (IDEs). Our study suggested integrating security concepts into IDEs. A
checklist of common smart contract security issues inside IDEs would be useful. The security tools (e.g., static
analysis) can show which common security issues from the list are present in the code. Many participants liked the
convenience of the web-based Remix IDE, but wished its features can match those in the desktop-based IDE (e.g.,
Visual Studio Code) where more security plugins are available. Some of them also desired the security plugins can be

15

more discoverable, either by enabling them by default or providing better search capability (e.g., creating a list of all
security-related plugins).

Development frameworks. Some participants mentioned existing development frameworks to be heavy-weighted and
difﬁcult to learn and use the security functionalities. For instance, P6 noted Trufﬂe, a popular smart contract develop-
ment framework is “unwieldy” to learn and run security tests. One possibility is for these development frameworks to
include a “security mode” where security analyses are automatically done as part of the compilation process.

Testnets. Many of our early stage developer participants said they did not consider security as a priority in their
smart contract development because they mostly deployed their projects in testnets where the (security) bugs have
no real impact. While this sentiment might be understandable, this observation raises the question of whether a
separate testnet could be designed speciﬁcally for smart contract security education and testing. For instance, the
testnet is deployed with hands-on labs, which include smart contacts that purposefully embed existing smart contract
vulnerabilities (imagine a vulnerable version of OpenZeppelin ERC20 contracts) and developers need to reuse or
interact with these contracts. This testnet could help developers experience and learn how to mitigate these security
vulnerabilities.

6.4 Limitations and Future Research

Our exploratory qualitative study has many limitations. First, we have a small sample size (29 participants), and
thus we cannot claim our results can necessarily be generalized to the broader smart contract developer population.
However, our participants were smart contract developers with diverse levels of experience and backgrounds, and our
ﬁndings do present the real practices in this community. Future research can conduct large-scale follow-up surveys to
help answer more quantitative questions such as the frequency of different types of smart contract security practices.

Our sample included many students, which one may wonder if they can represent some of the smart contract de-
velopment practices. We note that “smart contract developers” are not bound to those who have a formal title as a
(full-time) smart contract developer. All of our participants had experience in developing smart contracts and thus met
our criteria of smart contract developer. In addition, the emerging smart contract (and DeFi) space has developers from
very diverse backgrounds and with different levels of experience (including students), not just full-time developers.
Many students are indeed creators of DeFi projects. In popular DeFi hackathons such as ETHGlobal and Encode, most
participants were students. We see our diverse sample as a strength since it ﬁts with the diversity of the smart contract
developer population.

Our study focused on Solidity, the most popular programming language for smart contracts. There are other smart
contract languages such as Viper and RUST. Further studies are needed to smart contract security practices in other
languages. In addition, we only tested four common smart contract vulnerabilities in our code review task. Future
research is needed to investigate other smart contract vulnerabilities such as front running, ﬂash loan attacks, upgrad-
able proxy and delegate calls which may require developers to have a good understanding of the economic aspects of
DeFi projects (e.g., incentive mechanisms of Ethereum, token economics, how token prices interplay with automatic
market makers in decentralized exchanges).

Last but not least, our participants were asked about security practices in the interviews before doing the code review
task. Therefore, the interviews could prime our participants to think more about security in the code review and did
better than they would otherwise. We also noticed a positive association between years of experience and successfully
identifying security vulnerabilities in the code review task, this hypothesis however needs to be tested in future large-
scale studies.

7 Conclusion

To understand smart contract developers’ security perceptions and practices, we conducted an exploratory qualitative
study consisting of a semi-structured interview and a code review task. We found that many developers rely on others
or external audits to ensure security of their projects. When they do assess smart contract security, they often do
it manually and ﬁnd a lack of security resources and tools. Given the recent rise of smart contract projects (e.g.,
decentralized ﬁnance) and their associated security attacks, providing better educational materials and tool support
especially for novice developers is paramount for the healthy growth of this domain.

16

References

[1] Gavin Wood et al. Ethereum: A secure decentralised generalised transaction ledger. Ethereum project yellow

paper, 151(2014):1–32, 2014.

[2] Wesley Egbertsen, Gerdinand Hardeman, Maarten van den Hoven, Gert van der Kolk, and Arthur van Rijsewijk.

Replacing paper contracts with ethereum smart contracts. Semantic Scholar, 35, 2016.

[3] Emin G¨un Sirer. Thoughts on the dao hack. Retrieved February, 18:2020, 2016.

[4] Jamie Redman. Flash Loan Attacks Drain 2 Binance Smart Chain Deﬁ Projects for $6 Million, May 2021.

[5] Neville A Stanton. Hierarchical task analysis: Developments, applications, and extensions. Applied ergonomics,

37(1):55–79, 2006.

[6] David LEE Kuo Chuen and Robert H Deng. Handbook of blockchain, digital ﬁnance, and inclusion: cryp-
tocurrency, ﬁntech, insurtech, regulation, Chinatech, mobile security, and distributed ledger. Academic Press,
2017.

[7] Dylan Yaga, Peter Mell, Nik Roby, and Karen Scarfone. Blockchain technology overview. arXiv preprint

arXiv:1906.11078, 2019.

[8] Michael Nofer, Peter Gomber, Oliver Hinz, and Dirk Schiereck. Blockchain. Business & Information Systems

Engineering, 59(3):183–187, 2017.

[9] Bob Blakley and Lorrie Cranor. A discussion of election security, cryptography, and exceptional access with

michael alan specter. IEEE Security & Privacy, 19(06):15–22, 2021.

[10] Go Ethereum. Ofﬁcial go implementation of the ethereum protocol. URl: https://geth. ethereum. org (visited on

01/25/2019), 2017.

[11] Nils Amiet. Blockchain vulnerabilities in practice. Digital Threats: Research and Practice, 2(2):1–7, 2021.

[12] Andreas M Antonopoulos and Gavin Wood. Mastering ethereum: building smart contracts and dapps. O’reilly

Media, 2018.

[13] Daniel Macrinici, Cristian Cartofeanu, and Shang Gao. Smart contract applications within blockchain technol-

ogy: A systematic mapping study. Telematics and Informatics, 35(8):2337–2354, 2018.

[14] Neville Grech, Michael Kong, Anton Jurisevic, Lexi Brent, Bernhard Scholz, and Yannis Smaragdakis. Mad-
max: Surviving out-of-gas conditions in ethereum smart contracts. Proceedings of the ACM on Programming
Languages, 2(OOPSLA):1–27, 2018.

[15] Matthew Green and Matthew Smith. Developers are not the enemy!: The need for usable security apis. IEEE

Security & Privacy, 14(5):40–46, 2016.

[16] Olgierd Pieczul, Simon Foley, and Mary Ellen Zurko. Developer-centered security and the symmetry of igno-

rance. In Proceedings of the 2017 New Security Paradigms Workshop, pages 46–56, 2017.

[17] Yasemin Acar, Sascha Fahl, and Michelle L Mazurek. You are not your developer, either: A research agenda
for usable security and privacy research beyond end users. In 2016 IEEE Cybersecurity Development (SecDev),
pages 3–8. IEEE, 2016.

[18] Daniela Oliveira, Marissa Rosenthal, Nicole Morin, Kuo-Chuan Yeh, Justin Cappos, and Yanyan Zhuang. It’s the
psychology stupid: how heuristics explain software vulnerabilities and how priming can illuminate developer’s
blind spots. In Proceedings of the 30th Annual Computer Security Applications Conference, pages 296–305,
2014.

[19] Justin Cappos, Yanyan Zhuang, Daniela Oliveira, Marissa Rosenthal, and Kuo-Chuan Yeh. Vulnerabilities as
blind spots in developer’s heuristic-based decision-making processes. In Proceedings of the 2014 New Security
Paradigms Workshop, pages 53–62, 2014.

[20] Glenn Wurster and Paul C Van Oorschot. The developer is the enemy. In Proceedings of the 2008 New Security

Paradigms Workshop, pages 89–97, 2008.

[21] Jim Witschey, Shundan Xiao, and Emerson Murphy-Hill. Technical and personal factors inﬂuencing developers’
adoption of security tools. In Proceedings of the 2014 ACM Workshop on Security Information Workers, pages
23–26, 2014.

[22] Jing Xie, Heather Richter Lipford, and Bill Chu. Why do programmers make security errors? In 2011 IEEE

symposium on visual languages and human-centric computing (VL/HCC), pages 161–164. IEEE, 2011.

17

[23] Dejan Baca, Kai Petersen, Bengt Carlsson, and Lars Lundberg. Static code analysis to detect software secu-
rity vulnerabilities-does experience matter? In 2009 International Conference on Availability, Reliability and
Security, pages 804–810. IEEE, 2009.

[24] Daniel Perez and Ben Livshits. Smart contract vulnerabilities: Vulnerable does not imply exploited. In 30th

{USENIX} Security Symposium ({USENIX} Security 21), 2021.

[25] Petar Tsankov, Andrei Dan, Dana Drachsler-Cohen, Arthur Gervais, Florian Buenzli, and Martin Vechev. Se-
curify: Practical security analysis of smart contracts. In Proceedings of the 2018 ACM SIGSAC Conference on
Computer and Communications Security, pages 67–82, 2018.

[26] Muhammad Izhar Mehar, Charles Louis Shier, Alana Giambattista, Elgar Gong, Gabrielle Fletcher, Ryan Sanay-
hie, Henry M Kim, and Marek Laskowski. Understanding a revolutionary and ﬂawed grand experiment in
blockchain: the dao attack. Journal of Cases on Information Technology (JCIT), 21(1):19–32, 2019.

[27] Lexi Brent, Anton Jurisevic, Michael Kong, Eric Liu, Francois Gauthier, Vincent Gramoli, Ralph Holz,
and Bernhard Scholz. Vandal: A scalable security analysis framework for smart contracts. arXiv preprint
arXiv:1809.03981, 2018.

[28] Loi Luu, Duc-Hiep Chu, Hrishi Olickel, Prateek Saxena, and Aquinas Hobor. Making smart contracts smarter. In
Proceedings of the 2016 ACM SIGSAC conference on computer and communications security, pages 254–269,
2016.

[29] Enmei Lai and Wenjun Luo. Static analysis of integer overﬂow of smart contracts in ethereum. In Proceedings

of the 2020 4th International Conference on Cryptography, Security and Privacy, pages 110–115, 2020.

[30] Jinshan Shi, Ru Li, and Wenhan Hou. A mechanism to resolve the unauthorized access vulnerability caused by

permission delegation in blockchain-based access control. IEEE Access, 8:156027–156042, 2020.

[31] Yongfeng Huang, Yiyang Bian, Renpu Li, J Leon Zhao, and Peizhong Shi. Smart contract security: A software

lifecycle perspective. IEEE Access, 7:150184–150202, 2019.

[32] Philip Daian, Steven Goldfeder, Tyler Kell, Yunqi Li, Xueyuan Zhao, Iddo Bentov, Lorenz Breidenbach, and
Ari Juels. Flash boys 2.0: Frontrunning in decentralized exchanges, miner extractable value, and consensus
instability. In 2020 IEEE Symposium on Security and Privacy (SP), pages 910–927. IEEE, 2020.

[33] Purathani Praitheeshan, Lei Pan, Jiangshan Yu, Joseph Liu, and Robin Doss. Security analysis methods on

ethereum smart contract vulnerabilities: a survey. arXiv preprint arXiv:1908.08605, 2019.

[34] Ivica Nikoli´c, Aashish Kolluri, Ilya Sergey, Prateek Saxena, and Aquinas Hobor. Finding the greedy, prodigal,
and suicidal contracts at scale. In Proceedings of the 34th Annual Computer Security Applications Conference,
pages 653–663, 2018.

[35] Daniel Perez and Benjamin Livshits. Smart contract vulnerabilities: Does anyone care.

arXiv preprint

arXiv:1902.06710, pages 1–15, 2019.

[36] Sukrit Kalra, Seep Goel, Mohan Dhawan, and Subodh Sharma. Zeus: Analyzing safety of smart contracts. In

Ndss, pages 1–12, 2018.

[37] Sergei Tikhomirov, Ekaterina Voskresenskaya, Ivan Ivanitskiy, Ramil Takhaviev, Evgeny Marchenko, and
Yaroslav Alexandrov. Smartcheck: Static analysis of ethereum smart contracts. In Proceedings of the 1st Inter-
national Workshop on Emerging Trends in Software Engineering for Blockchain, pages 9–16, 2018.

[38] Bo Jiang, Ye Liu, and WK Chan. Contractfuzzer: Fuzzing smart contracts for vulnerability detection. In 2018
33rd IEEE/ACM International Conference on Automated Software Engineering (ASE), pages 259–269. IEEE,
2018.

[39] Lexi Brent, Neville Grech, Siﬁs Lagouvardos, Bernhard Scholz, and Yannis Smaragdakis. Ethainter: a smart
contract security analyzer for composite vulnerabilities. In Proceedings of the 41st ACM SIGPLAN Conference
on Programming Language Design and Implementation, pages 454–469, 2020.

[40] Petri Puhakainen and Mikko Siponen. Improving employees’ compliance through information systems security

training: an action research study. MIS quarterly, pages 757–778, 2010.

[41] Hala Assal and Sonia Chiasson. ’think secure from the beginning’ a survey with software developers. In Pro-

ceedings of the 2019 CHI conference on human factors in computing systems, pages 1–13, 2019.

[42] Giuseppe Destefanis, Michele Marchesi, Marco Ortu, Roberto Tonelli, Andrea Bracciali, and Robert Hierons.
Smart contracts vulnerabilities: a call for blockchain software engineering? In 2018 International Workshop on
Blockchain Oriented Software Engineering (IWBOSE), pages 19–25. IEEE, 2018.

18

[43] Alexander Mense and Markus Flatscher. Security vulnerabilities in ethereum smart contracts. In Proceedings
of the 20th International Conference on Information Integration and Web-Based Applications & Services, pages
375–380, 2018.

[44] Ardit Dika. Ethereum smart contracts: Security vulnerabilities and security tools. Master’s thesis, NTNU, 2017.
[45] JIANG P LI XQ, T CHEN, et al. A survey on the security of blockchain systems. Future Generation Computer

Systems, 2018.

[46] Michael Coblenz, Joshua Sunshine, Jonathan Aldrich, and Brad A Myers. Smarter smart contract develop-
ment tools. In 2019 IEEE/ACM 2nd International Workshop on Emerging Trends in Software Engineering for
Blockchain (WETSEB), pages 48–51. IEEE, 2019.

[47] Reza M Parizi, Ali Dehghantanha, et al. Smart contract programming languages on blockchains: An empirical

evaluation of usability and security. In International Conference on Blockchain, pages 75–91. Springer, 2018.

[48] Sarwar Sayeed, Hector Marco-Gisbert, and Tom Caira. Smart contract: Attacks and protections. IEEE Access,

8:24416–24427, 2020.

[49] Peter Leo Gorski, Luigi Lo Iacono, Dominik Wermke, Christian Stransky, Sebastian M¨oller, Yasemin Acar,
and Sascha Fahl. Developers deserve security warnings, too: On the effect of integrated security advice on
cryptographic {API} misuse. In Fourteenth Symposium on Usable Privacy and Security ({SOUPS} 2018), pages
265–281, 2018.

[50] Hala Assal and Sonia Chiasson. Security in the software development lifecycle. In Fourteenth Symposium on

Usable Privacy and Security ({SOUPS} 2018), pages 281–296, 2018.

[51] Chris Dannen. Bridging the blockchain knowledge gap.

In Introducing Ethereum and solidity, pages 1–20.

Springer, 2017.

[52] Sharan B Merriam and Elizabeth J Tisdell. Qualitative research: A guide to design and implementation. John

Wiley & Sons, 2015.

[53] Richard E. Boyatzis. Transforming Qualitative Information: Thematic Analysis and Code Development. SAGE,

April 1998.

[54] Mary L McHugh. Interrater reliability: the kappa statistic. Biochemia medica, 22(3):276–282, 2012.
[55] Yasemin Acar, Michael Backes, Sascha Fahl, Simson Garﬁnkel, Doowon Kim, Michelle L Mazurek, and Chris-
tian Stransky. Comparing the usability of cryptographic apis. In 2017 IEEE Symposium on Security and Privacy
(SP), pages 154–171. IEEE, 2017.

[56] Alena Naiakshina, Anastasia Danilova, Christian Tiefenau, Marco Herzog, Sergej Dechand, and Matthew Smith.
Why do developers get password storage wrong? a qualitative usability study. In Proceedings of the 2017 ACM
SIGSAC Conference on Computer and Communications Security, pages 311–328, 2017.

[57] Reza M. Parizi, Amritraj, and Ali Dehghantanha. Smart Contract Programming Languages on Blockchains: An
Empirical Evaluation of Usability and Security. In Shiping Chen, Harry Wang, and Liang-Jie Zhang, editors,
Blockchain – ICBC 2018, Lecture Notes in Computer Science, pages 75–91, Cham, 2018. Springer International
Publishing.

[58] Xiangping Chen, Peiyong Liao, Yixin Zhang, Yuan Huang, and Zibin Zheng. Understanding code reuse in smart
contracts. In 2021 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER),
pages 470–479. IEEE, 2021.

[59] Wenliang Du. The SEED project: Providing hands-on lab exercises for computer security education. In IEEE

Security and Privacy Magazine, September/October, 2011.

8

appendix

8.1 Pilot Study

We conducted a pilot study with 4 smart contract developers to test our study design including interview questions and
code review tasks. For the code review task, ﬁrst we implemented ﬁve smart contracts, each including one common
smart contract security vulnerability (e.g., reentrancy, under/overﬂow, access control). We present details of these
smart contracts in Section 4.3.1.

First round pilot. In the ﬁrst two pilot sessions, we had participants who were doctoral student researchers in the
blockchain and smart contract security area. We conducted the interview and provided three contracts to each partic-
ipant for review. They felt the interview questions were good. For second part of study (code review tasks), we gave

19

Figure 6: Factors considered in smart contract devel-
opment: Early stage Vs Experienced Developers

Figure 7: Participant’s programming background:
Early stage Vs Experienced Developers

the pilot participants 10 minutes for each task (30 minutes in total for all 3 tasks). They provided suggestions on how
to improve the code review task to make it more realistic. For instance, they felt the time was too tight to review three
contracts, and suggested having each participant review only one contract, which should be more comprehensive and
realistic by having common functionalities. They mentioned that code review takes an effort, and might be distracting
without a realistic contract . Therefore, we created two basic smart contracts based on ERC20 token standard, which
have basic functionalities to transfer tokens as well as allow tokens to be approved so they can be spent by another
on-chain party. ERC20 is the most common token standard on Ethereum and should be familiar to smart contract
developers. The length of smart contract code varies signiﬁcantly: some library/interface code can be 20 lines, while
other more complicated contracts (e.g., Uniswap router code) can be several hundreds of lines. Practically, to ﬁt into
the time frame of our study, the code cannot be too long. Therefore, our 2 newly created smart contracts contain 80
lines of code on average. We chose an average of 80 lines of code based on this 1st round of pilot, which was sufﬁcient
to contain common vulnerabilities in the ERC20 form. We then embedded at least two common smart contract security
vulnerabilities in each contract.

Second round pilot. To test the updated study materials, we had a second round of pilot with another two participants
who were blockchain researchers/developers. The estimated time for the interview session was 30 minutes and 25
minutes for code review tasks and 5 minutes for exit interview. Speciﬁcally, we gave them 20 minutes to review the
code (each participant was assigned only one task). They were asked to: a) review the contract code; b) update the
code if necessary; c) can search for any resources online during the task. In addition, we gave them 5 minutes to
discuss the area of improvement and their rationale after the task.

They made suggestions on the interview questions. For instance, they suggested that we add questions to understand
what role(s) the participant played in their smart contract projects. Therefore, we added questions to learn: a) what
types of role they play in smart contract projects, and b) if they have any experience in deploying smart contracts in a
production system or mainnet/testnet. They thought the smart contracts for review were good, but suggested making
them ready to go compile from GitHub, which we did in the ﬁnal study.

8.2 Figure: Factors considered in Development and Tools/Programming Languages

We include ﬁgures representing different factors considered by early stage and experienced developers (Figure 6), and
their programming language background (Figure 7).

8.3 Figure: Task Flowcharts of Participants

This section includes ﬂowcharts of code review process which were most common among participants.

8.4 Code Review Improvement Suggestions: Task 1 and 2

This section includes examples of modiﬁed code snippets by participants who were able to identify security vulnera-
bilities.

20

02468101214Functional CorrectnessGas EfficiencySecurityCode Optimize Dev SpeedReadabilityMaintainableUpgrade AbilitiesCommunication in TeamModular CodeCost EffectiveMethod/ConditionFeaturesAccess ControlEarly Stage and ExperiencedEarly StageExperiencedFigure 8: Code Review Task Flowchart for P22 who manually reviewed smart contract for Task 2 and failed to identify
any vulnerabilities

Figure 9: Code Review Task Flowchart for P6 who manually reviewed the code and successful in identifying both
vulnerabilities in Task 2

21

StartOpen code via Remix IDESkim entire contract codeSearch for ERC20 token standards via InternetSkim through program functionsEndPossible improvements?Add comments/suggestionsMinimize/optimize codeYesUpdate variable name vulnerabilityUnderstand deployment costLook into Safe Math LibraryAdditional code optimization suggestionsNoStartOpen code via Remix IDERead the contract Skim through Safe Math LibrarySearch for library safe math solidity in GoogleRead Open Zeppelin documentation via safe mathEndModify Safe Math LibraryManually inspect each function for issuesIssue?Modify codeRequires additional information?YesResearch via the InternetNoNoYesm o d i f i e r onlyOwner ( ) {

r e q u i r e ( msg . s e n d e r == a d d r e s s ( owner ) )

;

;

}

Figure 10: Security vulnerability identiﬁcation (access control) and modiﬁcation by P6 during the task2. Tools used:
Remix, manual inspection.

f u n c t i o n t r a n s f e r F r o m ( a d d r e s s
o v e r r i d e p u b l i c
( b o o l
&& a l l o w a n c e [ from ] [ msg . s e n d e r ] >= t o k e n s ) {

from ,
s u c c e s s ) { i f

a d d r e s s

r e t u r n s

t o , u i n t 2 5 6 t o k e n s )

( b a l a n c e O f [ from ] >= t o k e n s

t h a t

t o t a l

s u p p l y o f 15 e23

i s

t h i s

c a v e a t

s a f e m a t h

s a f e , w i t h t h e

e t h e r < t y p e ( u i n t 2 5 6 ) . max

/ / no u s e o f
t o d o :
/ /
+
/ / a l l
b a l a n c e O f [ t o ] += t o k e n s ;
b a l a n c e O f [ from ] −= t o k e n s ;
a l l o w a n c e [ from ] [ msg . s e n d e r ] −= t o k e n s ;
e m i t T r a n s f e r ( from ,
r e t u r n t r u e ; } e l s e {
/ /
/ /
r e t u r n f a l s e ; }}

t y p i c a l l y a l o t o f
r e v e r t ( ’ I n s u f f i c i e n t

a l l o w a n c e ’ ) ;

c o n t r a c t s

t o k e n s ) ;

r e v e r t

t o ,

i n t h i s
i n s t e a d o f

c a s e

‘ r e t u r n f a l s e ‘

Figure 11: Security vulnerability identiﬁcation (low-level call) and modiﬁcation by P10 during the task. Tools used:
VS Code, manual inspection.

f u n c t i o n w i t h d r a w ( u i n t 2 5 6 amount ) p u b l i c

r e t u r n s

( b o o l

s u c c e s s ) {

c o n t r a c t s

t y p i c a l l y a l o t o f
r e v e r t ( ’ I n s u f f i c i e n t b a l a n c e ’ ) ;
( b a l a n c e O f [ msg . s e n d e r ] < amount )
/ /

/ /
/ /
i f
b a l a n c e O f [ msg . s e n d e r ] −= amount ;
t o t a l S u p p l y −= amount ;
( b o o l
r e q u i r e ( s u c c e s s ) ;
r e t u r n t r u e ; }

r e v e r t

i n t h i s

c a s e

i n s t e a d o f

‘ r e t u r n f a l s e ‘

r e t u r n f a l s e ;
s a f e b e c a u s e c h e c k a b o v e

s u c c e s s , ) = msg . s e n d e r . c a l l { v a l u e : amount } ( amount ) ;

Figure 12: Security vulnerability identiﬁcation (re-entrancy) and modiﬁcation by P10 during the task. Tool used:
Remix.

f u n c t i o n w i t h d r a w ( u i n t 2 5 6 amount ) p u b l i c

r e t u r n s

( b o o l

s u c c e s s ) {

( b a l a n c e s [ msg . s e n d e r ] < amount )

i f
b a l a n c e s [ msg . s e n d e r ] −= amount ;

r e t u r n f a l s e ;

i s

t o t a l S u p p l y −= amount ;
/ / T h e r e
some d a n g e r
/ / h t t p s : / / d o c s . s o l i d i t y l a n g . o r g /
( ! msg . s e n d e r . s e n d ( amount ) ) {
i f
/ / v u l n e r a b l e
/ / h t t p s : / / d o c s . s o l i d i t y l a n g . o r g /

t o r e e n t r a n c y a t t a c k :

i n u s i n g s e n d : c h e c k

b a l a n c e s [ msg . s e n d e r ] += amount ;

t o t a l S u p p l y += amount ;

r e t u r n f a l s e ; }

r e t u r n t r u e ; }

}

Figure 13: Security vulnerability identiﬁcation (re-entranccy) and modiﬁcation by P12 during the task. Tool used:
Remix.

22

f u n c t i o n t r a n s f e r F r o m ( a d d r e s s
( b o o l
o v e r r i d e p u b l i c

r e t u r n s

from ,
s u c c e s s ) {

a d d r e s s

t o , u i n t 2 5 6 t o k e n s )

/ / m o d i f i c a t i o n : a d d i n g r e q u i r e h e r e
r e q u i r e ( from ! = a d d r e s s ( 0 ) , ” Empty a d d r e s s
r e q u i r e ( t o ! = a d d r e s s ( 0 ) , ” Empty a d d r e s s
i f

i s n o t a l l o w e d ” ) ;

i s n o t a l l o w e d ” ) ;

( b a l a n c e s [ from ] >= t o k e n s && a l l o w e d [ from ] [ msg . s e n d e r ] >= t o k e n s &&

t o k e n s > 0 ) {
b a l a n c e s [ t o ] += t o k e n s ;
b a l a n c e s [ from ] −= t o k e n s ;
a l l o w e d [ from ] [ msg . s e n d e r ] −= t o k e n s ;
e m i t T r a n s f e r ( from ,
r e t u r n t r u e ;

t o k e n s ) ;

t o ,

} e l s e { r e t u r n f a l s e ; }}

Figure 14: Security vulnerability identiﬁcation (low-level unchecked calls) and modiﬁcation by P12 during the task.
Tools used: VS Code, manual inspection.

/ / Might be a v u l n e r a b i l i t y − s o m e t h i n g t o do w i t h m i n e r s

r e o r d e r i n g a p p r o v e

t x s

/ / I k i n d a remember a p p r o v e

f u n t i o n s h a v i n g a ” s e t

t o 0” k i n d a

l o g i

/ / l o o k d e e p e r

l a t e r

f u n c t i o n a p p r o v e ( a d d r e s s

s p e n d e r , u i n t 2 5 6 t o k e n s ) o v e r r i d e p u b l i c

r e t u r n s

( b o o l

s u c c e s s ) {

a l l o w e d [ msg . s e n d e r ] [ s p e n d e r ] = t o k e n s ;
e m i t A p p r o v a l ( msg . s e n d e r ,
r e t u r n t r u e ;

s p e n d e r ,

t o k e n s ) ;

}

Figure 15: False positive Security vulnerability identiﬁcation for task1 by P1

23

Table 3: Summary of participants’ task performance in the code review task where success rate (i.e., Rate) denotes
the percentage of participants who correctly identiﬁed a particular vulnerability; 0 : the participant did not identify the
vulnerability; 1: the participant identiﬁed the vulnerability. The middle section of the table shows the early-stage (¡ 1
year of experience) Solidity developer participants, whereas the bottom section of the table shows the experienced (2-5
years of experience) Solidity developer participants. Every participant either did Task 1 or Task 2. Task 1 includes
two vulnerabilities: reentrancy and unchecked low-level call. Task 2 includes two vulnerabilities: integer overﬂow
and improper access control. We also show the review method each participant used during the task. Most participants
did manual inspection of the code using an IDE or a test editor such as Remix, VS Code, Sublime, IntelliJ, or simply
viewing the code on GitHub. Remix and Hardhat are development/testing frameworks for smart contracts. Three
participants (P3, P15, P20) used Remix with a security plugin (sp), which does Solidity static analysis. Slither is a
static analysis tool and Oyente is an analysis tool based on symbolic execution.

ID
(Task 1)

Early
P4
P5
P7
P20

Exp.
P2
P10
P11
P12
P14
P18
P19
P23
P25
P27
P29

Low-Level
Call
Success

Reentrancy
Success
Rate: 53.3% Rate: 40%
Rate: 25%
0
0
0
1

Rate: 0%
0
0
0
0

Review
Method

Manual
Manual
Manual
Remix (sp)

Rate: 63.6% Rate: 54.5%
0
1
0
1
1
1
1
0
1
1
0

0
1
0
1
1
0
0
0
1
1
1

Manual
Manual
Manual
Manual
Hardhat+Slither
Manual
Manual
Manual
Manual+Remix (sp)
Manual+MythX
Manual+Remix (sp)

ID
(Task 2)

P1
P3
P9
P24
P16
P28

P8
P6
P13
P15
P17
P21
P22
P26

Access
Control
Success

0
0
0
0
0
1

Overﬂow
Success
Rate: 28.6% Rate: 42.9%
Rate: 16.7% Rate: 16.7%
0
0
0
0
0
1
Rate: 37.5% Rate: 62.5%
1
1
0
0
1
0
0
0

1
1
0
1
0
1
0
1

Review
Method

Manual
Remix (sp)
Manual
Manual
Manual
Manual

Manual
Manual
Manual
Remix (sp)
Manual
Remix+Oyente
Manual
Manual

Table 4: Average time for identifying each vulnerability by early stage and experienced developers. avgt: Average
Time

Reentrancy Low-Level Call

ID

Overﬂow

Access Control

ID
Early Stage
P20

18.18
avgt: 18.18

P28
avgt: 7.07

Experienced
P10
P12
P14
P18
P19
P25
P27
P29

5.08
11.98
12.44
13.07
13.50
6.23
12.13

avgt: 10.6

8.08
8.16
10.12

10.53
11.56
10.37
avgt: 10.4

P6
P8
P15
P17
P21
P26

24

7.07

9.08
9.17

9.13

8.31
avgt: 8.31

14.15
14.01
11.45

14.54
15.47

avgt: 10.1

avgt: 14.4

