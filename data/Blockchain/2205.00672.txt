SightSteeple:
Agreeing to Disagree with Functional Blockchain Consensus

Aditya Ahuja
Indian Institute of Technology Delhi
New Delhi, India
aahuja85@gmail.com

2
2
0
2

y
a
M
2

]

R
C
.
s
c
[

1
v
2
7
6
0
0
.
5
0
2
2
:
v
i
X
r
a

ABSTRACT

Classical and contemporary distributed consensus protocols, may
they be for binary agreement, state machine replication, or blockchain
consensus, require all protocol participants in a peer-to-peer system
to agree on exactly the same information as part of the consensus
payload. Although this model of consensus is extensively studied,
and is useful for most consensus based decentralized applications,
it falls short of defining correct distributed systems which mandate
participant credential based privileged visibility into the consensus
payload, through the consensus protocol itself.
We introduce a new paradigm for distributed consensus, called
functional blockchain consensus. Functional blockchain consensus
allows each blockchain protocol participant to agree on some dis-
tinct sub-information of the list of transactions, as a function of the
credentials of the participant in the blockchain system, instead of
agreeing on the entire list of transactions. We motivate two adver-
sary models, one with a standard crash-fault adversary and another
with a novel rational-fault adversary, to compromise functional
blockchain consensus. We then present two versions of a blockchain
protocol called SightSteeple, that achieves functional blockchain
consensus in the said fault models. SightSteeple relies on a novel
combination of standard blockchain consensus and functional en-
cryption, among other primitives, to achieve its goals of correctness.
Finally, we discuss practical uses of functional blockchain consen-
sus based asymmetric distributed ledgers, and motivate off-shoot
constructions that can result from this new consensus paradigm.

CCS CONCEPTS
• Security and privacy → Distributed systems security; Cryp-
tography.

KEYWORDS

Functional Blockchain Consensus, Hierarchical Blockchains

1 INTRODUCTION

Distributed consensus, which can manifest in the form of binary
agreement [21, 32], state machine replication [29, 38], or blockchain
consensus [5, 13, 37], requires a set of networked processes to agree
on some information. In each manifestation, the notion of con-
sensus is to agree on an identical snapshot of the information as
part of the consensus payload, symmetrically, by each of the pro-
cesses involved. Although this notion of consensus may be useful
for symmetric information based decentralized applications, it pre-
cludes decentralized applications requiring consensus on sensitive
information, where there is a need for privileged visibility into the
consensus payload for each of the participant processes.

From a pedagogical perspective, there is a lack of consensus

paradigms and protocols where visibility into the consensus pay-
load is predicated on the credentials of the consensus protocol
participants. Presently, distributed consensus is in general defined
for a peer-to-peer system, and to intentionally preclude the creden-
tials that the consensus protocol participants may possess: those
credentials, which may define the privilege of their visibility into
the consensus payload. Consequently, as at least an academic ex-
ercise, there is a need for defining paradigms for asymmetric con-
sensus: the consensus protocol participants may agree on some
sub-information, which is any information that may be inferred
from the complete consensus payload, as a function of their creden-
tials in the distributed system, once those credentials are established
and agreed to in a decentralized setting.

One way to achieve asymmetric consensus is to ensure that the
information contained in the consensus payload that is being con-
sidered by all processes is identical, however the agreed view1 or
summary of the payload, and the consequential distributed ledger,
is allowed to be different for different processes, as long as there
exists a hierarchy of inference across the views of each of the pro-
cesses. The hierarchy of inference should necessitate that some
views are implied by other views, thereby ensuring an asymmetric
consistency across all processes. Such credential based consensus
definitions and protocols for secure consensus payload views for
each of the involved processes (similar to secure information flow
[19]), resulting in continuously growing logs which are the output
of the consensus protocol, do not exist yet to the best of our knowl-
edge.

There is also a practical motivation for asymmetric consensus
based decentralized applications. For instance, cryptocurrencies
[7] with sensitive transactions may require asymmetric distributed
ledgers, which allow different processes to see different summaries
of the list of transactions, or allow processes to learn the list of trans-
actions only when certain preconditions are met. Decentralized
finance (DeFi) [36] applications may require hierarchical distributed
ledgers for selective portfolio exposure to enable asymmetrical ac-
cess to automated markets. There would also be, in general, a need
for asymmetric records for agreement on classified information in
information critical decentralized sectors requiring sensitive data
distribution [12].2

Given the explosion of blockchain based decentralized applica-
tions in recent times [12], there is a motivation for blockchain based
information flow hierarchies in decentralized applications and or-
ganizations, perhaps through separate yet hierarchical blockchains

1We use ‘view’ to denote any sub-information that can be implied by the complete
information contained in the consensus payload, and will formally define a view later.
2We motivate decentralized applications based on functional blockchain consensus, in
more detail, in Section 6.1.

 
 
 
 
 
 
, ,

Aditya Ahuja

across the blockchain protocol participants, especially in informa-
tion critical sectors as mentioned. Consequently, it is befitting and
opportune to consider, both as an academic exercise and a practical
curiosity, asymmetric blockchain consensus models and protocols,
for defining hierarchical blockchains: models that generalize stan-
dard blockchains by accommodating credential-based asymmetric
agreement on the list of transactions.

Our Contributions
In this paper, we make the following contributions3.

Introducing Functional Blockchain Consensus (Section 2). We present
a player model for consensus where blockchain protocol partici-
pants (or players) have different credentials towards their visibility
into the blockchain payload. We formally define a block payload
view, which is any information that can be inferred from the com-
plete list of transactions. We then introduce our new paradigm
of consensus, called functional blockchain consensus, which, given
the credentials of all players in the blockchain system, allows (i)
each honest player to agree on a distinct block payload view, as a
function of its credentials in the system, and (ii) allows each hon-
est player to know that its honest counterparts agree on a correct
block payload view. Functional blockchain consensus may result in
different blockchains for different players (with some blockchains
being implied by other blockchains), and so we formally show that
functional blockchain consensus is a generalization of traditional
blockchain consensus.

Presenting SightSteeple under a fail-stop adversary (Section 4).
Given a a partially synchronous network [22] with crash-fault ad-
versary that controls less than half of the players in the system, we
present our first functional blockchain consensus protocol called
SightSteeple-CFT. SightSteeple-CFT is constructed by amend-
ing the crash-fault tolerant version of the streamlined Streamlet
[13] blockchain protocol, and by using functional encryption for all
efficiently computable functions [24] (among other cryptographic
primitives).

Presenting SightSteeple under an economically incentivized, pay-
load view compromise adversary (Section 5). We motivate a new
adversary model under functional blockchain consensus, termed a
rational adversary. A rational adversary, apart from maximizing its
revenue through the consensus protocol (which may include any
combination of block rewards, transaction fees, or double spending
transactions), would simultaneously want to maximize its block
payload view and try to learn the complete list of transactions in-
stead of some summary of it. To that end, the adversary would be
willing to mislead the honest players towards learning incorrect
payload views. Under a rational adversary controlling less than
one-third of the players in the system, over a partially synchronous
network, we present our next protocol called SightSteeple-RFT.
SightSteeple-RFT is constructed by amending the Byzantine-fault
tolerant version of Streamlet, and by using verifiable functional
encryption schemes [3].

3Our contributions are inspired from and are a refinement to a patent application on
functional blockchain consensus [2].

Our goals, and open problems. In this work, we intend to initiate
the study of hierarchical visibility into the blockchain payload,
through a new functional blockchain consensus protocol. We dis-
cuss the impossibility of Byzantine-fault tolerant SightSteeple
(Section 5.1). We will not give exact construction of any functional
encryption scheme, but point out their existence and viability for
various distributed ledgers (Section 6.1). We will discuss the sub-
tleties of privilege alteration attacks, both on-chain and off-chain,
and point to possible solutions to harden the protocol (Section 6.2).
We will motivate future definitions on asymmetric smart contracts
and alternate asymmetric consensus paradigms, such as consensus
on transaction declassification, which might have a construction
similar to SightSteeple (Section 7).

Related Work
Asymmetric trust, and relaxing consensus. There have been pro-
posals to model asymmetric Byzantine quorum systems over an
asynchronous network, where each consensus protocol participant
is free to choose which participants it considers faulty, and which
it considers honest (non-faulty) [10], and consequential consensus
protocols have been proposed [11]. There have been proposals to
relax the definition of consensus (more specifically, relaxing the
definition of termination within consensus) in blockchains, over an
asynchronous network [33]. None of these contributions permit an
asymmetric visibility of the consensus payload, nor advocate for
asymmetry on the agreed information for the participants in the
protocol.
Hybrid blockchains. Hybrid blockchains, which have a public chain
and multiple private subchains to realize the decentralized appli-
cation [18, 42], are different from SightSteeple where blockchain
payload visibility can change for each player on the same chain.
Solutions at the intersection of blockchains and functional encryp-
tion. There have been proposals to outsource decryption under a
functional scheme, with incentivization, to blockchains [17]. Pri-
vacy preserving energy trading in blockchain empowered smart
grids has been proposed by leveraging functional encryption [34].
Secure distributed smart meters have been defined using a com-
bination of blockchains and functional encryption [39]. A power
efficient elliptic curve pairing crypto-processor has been proposed
for blockchains and functional encryption [4]. None of these con-
tributions define a consensus model that can be realized using a
combination of standard blockchains and functional encryption,
which is central to our contribution.

2 FUNCTIONAL BLOCKCHAIN CONSENSUS

In this section, we introduce functional blockchain consensus.

2.1 The Player Model

We refer to the blockchain protocol participants, which are (polynomial-
time) interactive Turing machines, as players. The set of players is
given by [𝑛] := {1, 2, ..., 𝑛}, where some players are honest (non-
faulty) and others are faulty. Further, each player 𝑖 ∈ [𝑛] has some
credentials 𝜅𝑖 ∈ {0, 1}∗, with the highest credential denoted by 𝜅∗.
Let C = (𝜅𝑖 )𝑖 ∈ [𝑛] denote the list of credentials for all players.
Further, there exists a third party for trusted setup, called init-party,

SightSteeple

, ,

that does not participate in consensus, but distributes the creden-
tials to each player.

3. Liveness: If some honest player with highest credentials receives
a valid block payload 𝑡𝑥𝑠 in some round, that payload will eventually
be summarized and finalized in each honest player’s blockchain.

2.2 Block Payload View
We first introduce a block payload view, which has a special con-
notation in functional blockchain consensus (not to be confused
with view change in state machine replication, or a real-time snap-
shot of the blockchain state in standard blockchains [13]). A block
payload view for a specific player in functional blockchain consen-
sus, is the sub-information of the list of transactions that the said
player agrees upon, and includes in its blockchain. We formalize
this through the following definition.

Definition 1 (Block Payload View). A set of functions F is a set
of block payload view functions iff ∀txs ∈ {0, 1}∗, ∀𝑓 ∈ F, 𝑓 (txs) is
implied by txs. Further there exists an identity function 𝑓 ∗ ∈ F, such
that ∀txs ∈ {0, 1}∗, 𝑓 ∗ (txs) = txs, and a null function 𝑓⊥ ∈ F, such
that ∀txs ∈ {0, 1}∗, 𝑓⊥ (txs) = ⊥.
Further, ∀txs ∈ {0, 1}∗, ∀𝑓 ∈ F, we call 𝑓 (txs) a block payload view
of txs under view function 𝑓 .

Examples of block payload views. Instances of block payload views
include view functions that provide the smallest transaction in the
list of transactions, or provide the sub-list of the transactions by a
particular transacting party (say Alice), or provide the sum of the
tokens exchanged in all the transactions in the transaction list.

Mapping players’ credentials to their permissible payload view.
Given a player with certain credentials, there needs to be a corre-
spondence between the player’s credentials and the view function
(s)he is eligible for. Let Ψ : {0, 1}∗ → F be the function, determined
by the init-party, that provides this mapping. Also, it is true that
Ψ(𝜅∗) = 𝑓 ∗.

2.3 Defining Functional Blockchain Consensus

Having presented the player model and introduced block payload
views, we now formally define functional blockchain consensus.

Definition 2 (Functional Blockchain Consensus). Assume
there exist 𝑛 players with credentials C, and each player is eligible to
learn a block payload view under the view function set F, through Ψ. A
blockchain protocol achieves ‘functional blockchain consensus’, if it at-
tains the following consensus goals (with all but negligible probability
in the security parameter), for each epoch 𝑒 of the blockchain system
when the block payload txs𝑒 is added consistently to the blockchain:

1. Functional Hierarchy Consistency: For each honest player 𝑖 ∈ [𝑛],
𝑖 ∈ F)𝑖 ∈ [𝑛] .

player 𝑖 agrees on (Ψ(𝜅𝑖 ) = 𝑓 𝑒

2. Block Payload View Integrity: For each honest player 𝑖 ∈ [𝑛],
𝑖 (txs𝑒 ), and 𝑖 knows that each honest player
𝑗 (txs𝑒 ). Further, if for some honest player
𝑖 (txs𝑒 ) = 𝑓 ∗ (txs𝑒 ) = txs𝑒 , then 𝑖 verifies that txs𝑒 is valid

player 𝑖 agrees on 𝑓 𝑒
𝑗 ∈ [𝑛], 𝑗 ≠ 𝑖 agrees on 𝑓 𝑒
𝑖 ∈ [𝑛], 𝑓 𝑒
(does not contain double spending transactions).

It is instructive to give an explanation of Definition 2. In the first
requirement for achieving functional blockchain consensus, each
honest player must agree that each player in the system is eligible
for a block payload view congruent to its credential in the system.
In the second requirement, it is ensured that each honest player
knows that each honest player did indeed learn a block payload
view in accordance with its view function. In the final requirement,
it is just ascertained that every valid block payload eventually goes
on-chain.

Kindly note that in the most general case, the credentials of each
player can be a function of time (which means that the correct
payload view function of the players can be a function of time).

2.4 Hierarchical Player Blockchains
We introduce some terminology first. We say a payload view is no-
tarized4 (similar terminology in Streamlet [13]), once it receives
a threshold of votes from some of the players and is eligible to
be eventually confirmed in the player’s blockchain. We say that a
notarized payload view is finalized once is is confirmed as a part of
the player’s blockchain.
For each player 𝑖 ∈ [𝑛], and an arbitrary epoch 𝑒, the player’s
blockchain under functional blockchain consensus, is given by
, 𝐻 ∗ (𝑓 𝑒′
(txs𝑒′
𝑒−1
𝑒
𝑖 (txs𝑒 )), with 𝑒 ′ < 𝑒, no-
)), 𝑓 𝑒
:= (chain
chain
𝑖
𝑖
𝑖
𝑖 (txs𝑒 ) linked to notarized 𝑓 𝑒′
tarized 𝑓 𝑒
), and chain0
𝑖 is the
𝑖
genesis block. The standard blockchain, which is ideal (correspond-
ing to the payload view function 𝑓 ∗), is given by
chain∗,𝑒
), txs𝑒 ), similarly. Note that each
player’s notarized blockchain might be a block-tree in general, with
the finalized blockchain being a sub-chain of the notarized block-
tree. We will denote each player 𝑖’s finalized blockchain by chain𝑖 ,
and the ideal finalized blockchain by chain∗ (dropping the epoch
superscript).

:= (chain∗,𝑒−1, 𝐻 ∗ (txs𝑒′

(txs𝑒′

View Functions’ Hierarchy. We first define the binary relation
⪯ over the set of credentials. ∀𝑖1, 𝑖2 ∈ [𝑛], 𝜅𝑖1 ⪯ 𝜅𝑖2 implies that
player 𝑖2 has no lesser credentials than player 𝑖1, and consequently
for each epoch 𝑒, payload view txs𝑒
= 𝑓𝑖1 (txs𝑒 ) should be implied
𝑖1
by payload view txs𝑒
= 𝑓𝑖2 (txs𝑒 ). This is denoted equivalently with
𝑖2
𝑓𝑖1 ⪯ 𝑓𝑖2 , or even chain𝑖1 ⪯ chain𝑖2 . From Definition 1, it is evident
that ∀𝑓 ∈ F, 𝑓⊥ ⪯ 𝑓 ⪯ 𝑓 ∗.
It is easy to see that (F, ⪯) is a partial order, as the binary relation
⪯ over F is reflexive, anti-symmetric and transitive5. ∀𝑓1, 𝑓2 ∈ F,
define dist⪯ (𝑓1, 𝑓2) to be the number of functions on the path be-
tween 𝑓1 and 𝑓2 in the partial order (F, ⪯). From Definition 1, it is
evident that ∀𝑓1, 𝑓2 ∈ F, dist⪯ (𝑓1, 𝑓2) ≤ dist⪯ (𝑓⊥, 𝑓 ∗).
For some 𝑆 ⊆ [𝑛], define inf ⪯ {𝑓𝑖 (txs)}𝑖 ∈𝑆 := {𝑓𝑗 (txs)} 𝑗 ∈𝑆 ∗ to be
the smallest 𝑆∗ (⊆ 𝑆) such that for each 𝑓𝑖 (txs) ∈ 𝑆, there exists

4An equivalent notion of a notarized block, is a mined block in Nakamoto consensus
blockchains [7].
5This partial order provides the hierarchy of inference on the consensus payload,
which was mentioned in Section 1.

, ,

Aditya Ahuja

𝑓𝑗 (txs) ∈ 𝑆∗ such that 𝑓𝑗 ⪯ 𝑓𝑖 . Similarly, for some 𝑆 ⊆ [𝑛], define
sup⪯ {𝑓𝑖 (txs)}𝑖 ∈𝑆 := {𝑓𝑗 (txs)} 𝑗 ∈𝑆 ∗ to be the smallest 𝑆∗ (⊆ 𝑆) such
that for each 𝑓𝑖 (txs) ∈ 𝑆, there exists 𝑓𝑗 (txs) ∈ 𝑆∗ such that 𝑓𝑖 ⪯ 𝑓𝑗 .

Hierarchical player blockchains generalize standard blockchains.
∀𝑖 ∈ [𝑛], ∀𝑒, if it is the case that 𝑓 𝑒
𝑖 = 𝑓 ∗, then it is true that
each honest player’s payload view is identical and contains all the
transactions for each block in each epoch: ∀𝑒, 𝑖 ∈ [𝑛], chain𝑖 =
chain∗. In this instance, each player’s blockchain under functional
blockchain consensus is no different than a standard blockchain.

2.5 Alternate Functional Consensus Models

We briefly discuss possibilities of asymmetric consensus in binary
agreement and state machine replication, which can be considered
in the context of functional blockchain consensus.

Functional Binary Agreement reduces to Binary Agreement. Binary
agreement requires a set of processes to agree on a bit. Firstly, note
that, binary agreement on constant functions on a bit do not re-
quire a consensus protocol. In case binary agreement is considered
on non-constant functions on a bit, it can be proved that all non-
constant functions on a bit are invertible, and so consequently any
functional binary agreement definition can be reduced to standard
binary agreement.

Functional Blockchain Consensus and Functional State Machine Repli-
cation Consensus are equivalent. State machine replication is a
method for providing a fault-tolerant service where replicas of
servers maintain the correct state of the service, and accept com-
mands from clients to update the state of the service. There are
direct parallels between functional blockchain consensus and a
possible ‘functional’ consensus for state machine replication: block
payload view is equivalent to a sub-state (a sub-automaton) of
the service. Thus, by replacing the list of transactions txs (the
blockchain payload) with state (the state of the system) and by
replacing block payload view functions in F with state machine
sub-state functions in F, in Definitions 1 and 2, an equivalent defi-
nition of functional state machine replication can be proposed.

3 PRELIMINARIES

We first present the preliminary assumptions and constructions
required by the SightSteeple protocols.

3.1 The Execution Model
The Player Model. We assume that the players [𝑛] are ordered
with non-increasing static credentials, by the init-party: ∀𝑖1, 𝑖2 ∈
[𝑛], 𝑖1 ≤ 𝑖2, 𝜅𝑖1 ⪯ 𝜅𝑖2 . We denote the subset of players that can
participate in block proposal (defined in Section 3.3) by [𝑚], where
𝑚 ≤ 𝑛. ∀𝑖 ∈ [𝑚], 𝜅𝑖 = 𝜅∗, and ∀𝑗 ∈ {𝑚 + 1, 𝑚 + 2, ..., 𝑛}, 𝜅 𝑗 ≺ 𝜅∗ (𝑗
has lower than highest credentials). We refer to all the players in
[𝑚] as head players.

Credentials’ Initialization. The init-party is a trusted benevolent
body that initializes the system by distributing the credentials, does
not participate in consensus, and cannot flag adversarial players.
During setup, the init-party makes Ψ public. Each player 𝑖 ∈ [𝑛]

only knows its 𝜅𝑖 through the init-party, unless 𝜅𝑖 = 𝜅∗, in which
case 𝑖 knows C through the init-party.

The Network Model. We assume that there exists a permissioned,
authenticated blockchain network of 𝑛 players. We assume that the
clocks of all players are synchronized, and block proposal occurs
in epochs. We assume that the network obeys partial synchrony
[22], where, there exists a known finite number of rounds Δ, and an
unknown Global Stablization Time 𝐺𝑆𝑇 , such that for any message
sent by any honest player at round 𝑟0, the said message is received
by all honest players in [𝑛] by round max(𝑟0, 𝐺𝑆𝑇 ) + Δ. We ignore
the impact of computation times of cryptographic routines on our
message delays (as in our base protocol Streamlet [13]).

The Fault Model. We assume there exists an unknown, static
partition of [𝑛], of honest and faulty players (H, A). The honest
players in H follow the protocol specification as is, and the faulty
players in A deviate from the specified protocol under the failure
types stated next.
We assume that given the static adversary, there is at least one
head player that is not compromised by it: at least one player in
[𝑚] is honest, to eliminate the possibility of double-spending by
the adversary (will be discussed in detail in Section 5.4). We will
first consider the traditional crash-fault adversary: once a player
is compromised by the adversary, it stops sending and received all
protocol specific messages. We will then define a novel rational-fault
adversary under the functional blockchain consensus paradigm:
briefly, a rational adversary would try to maximize its revenue
from participation in the consensus protocol, and simultaneously
try to maximize its visibility in the blockchain payload (the list of
transactions). We cover each adversary in detail in the relevant
sections that follow.

3.2 Streamlet: The Base Protocol

SightSteeple will be an amendment to the streamlined blockchain
protocol Streamlet [13]. Streamlet will be considered over a par-
tially synchronous network, with one of crash-fault or Byzantine-
fault adversaries. For each block, consensus in Streamlet takes
place in four stages: block proposal, block vote, block notarization
(when the block receives a threshold of votes), and block finalization
(when the block is confirmed). These four stages will be revised and
re-interpreted in SightSteeple. For details on Streamlet, please
see Appendix A.1.

3.3 Metablocks, Metachain and Player

Blockchains

The Metablock. In SightSteeple, we introduce a ‘metablock’ as
a super block containing encrypted information about the block
payload (the list of transactions txs). Each player can selectively
read part of the information contained in the metablock, as per its
privileges towards the block payload. Since only head players have
the highest credentials in the SightSteeple system, metablocks
can solely be proposed by them. We will denote, for each epoch 𝑒,
the metablock using M𝑒 .
The Metachain. The ‘metachain’ would simply be the blockchain of

SightSteeple

, ,

metablocks. We would denote, for each epoch 𝑒, the presently nota-
𝑒
rized metachain by mchain
(which may be a tree of metablocks),
and the final metachain at any epoch by mchain.

Player Blockchains are implied by the SightSteeple Metachain. Since
each metablock in the metachain contains information that can be
selectively inferred by each player, based on the encrypted infor-
mation on the list of transactions as part of the metablock, each
𝑒
𝑒
honest player 𝑖 ∈ [𝑛] can deduce chain
, for each
𝑖 from mchain
epoch 𝑒.

3.4 Basics of Functional Encryption

Functional encryption will be extensively employed in SightSteeple
to preferentially reveal information to each player as part of each
metablock. Under a functional encryption scheme [6], given the
encryption of a message msg ∈ {0, 1}∗, the decryptor can recover
𝑓 (msg) if provided with the secret key 𝑠𝑘𝑓 under the scheme by
the encryptor for a particular function 𝑓 . Under a verifiable func-
tional encryption scheme [3], the decryptor can validate 𝑓 from
the supplied secret key for decryption, and recover 𝑓 (𝑚), even if
the encryptor is faulty (malicious), and wants to fool the decryptor
by supplying a key 𝑠𝑘𝑓 ′ for some 𝑓 ′ ≠ 𝑓 . A functional encryption
scheme for all circuits [24] supports the functional encryption of
all efficiently computable functions over the message space {0, 1}∗.
We will denote the set of all efficiently computable functions as ˆF.
It is easy to see that F ⊆ ˆF. For details on functional encryption,
please see Appendix A.2.

3.5 Notation
Let 𝑒 denote an epoch of the metachain, and simultaneously that of
each player chain. 𝐿𝑒 will denote the metablock proposing epoch
leader, and is a random member of [𝑚]. Let 𝐻 ∗ denote a collision
resistant hash function, which is ideal under the random oracle
model (its image is uniformly distributed). Let ΓSig denote a signa-
ture scheme, ΓE denote a public key encryption scheme, ΓaFE [24]
denote a functional encryption scheme for all efficiently computable
functions, and ΓvFE [3] denote a verifiable functional encryption
scheme.

Given a message msg ∈ {0, 1}∗, define signed message under
scheme ΓSig by player 𝑖 as (msg)ΓSig.𝑖 and encrypted message under
scheme ΓE for player 𝑖 as (msg)ΓE.𝑖−1 .

Crash-fault tolerant Streamlet will be denoted by Π0
fault tolerant Streamlet will be denoted by Π0
tolerant SightSteeple protocol will be denoted by Πss
rational-fault tolerant version will be denoted by Πss
rft.

bft. The crash-fault
cft, and the

cft, and Byzantine-

4.1 Metablock Structure
The genesis block. The players in [𝑛] initialize the system by agree-
ing on the genesis block gen := (0, [𝑛], C, F, Ψ, ΓE, ΓaFE, 𝐻 ∗). The
𝑛
2 players vote on it (a vote
genesis block is notarized when at least
by a player is just a signed hash of the genesis block by that player).

The metablock. The metablock for SightSteeple-CFT is presented
next. In brief, the metablock contains the current epoch number 𝑒,
hash of the previous metablock M𝑒′
to which the current metablock
is linked, encryption of the list of transactions txs𝑒 under ΓaFE, and,
𝑒−1
for each player 𝑖, hash of the current player chain chain
, payload
𝑖
view function 𝑓 𝑒
for 𝑖, and the encryption of the secret key sk𝑓 𝑒
𝑖
𝑖
under ΓaFE, recoverable by 𝑖.
SS-CFT Metablock:
The Contents of M𝑒

H (by Leaders in H )

← 𝜙

Initialize M𝑒
H
.Add−(𝑒, 𝐻 ∗ (M𝑒′
M𝑒
H
∀𝑖 ∈ [𝑛]:
M𝑒
H

𝑒−1
.Add−(𝑖, 𝐻 ∗ (chain
𝑖

), ΓaFE.Encpp𝑒 (txs𝑒 ))

), 𝑓 𝑒

𝑖 , (ΓaFE.sk𝑓 𝑒

𝑖

)ΓE.𝑖−1 )

4.2 The SightSteeple-CFT Protocol
The SightSteeple-CFT Protocol Πss

cft is presented in Algorithm 1.

Protocol Outline. For each epoch, the metablock proposing leader
is elected as a random member of [𝑚], as a function of 𝑒. If the
leader is honest, it proposes M𝑒
H to the network (otherwise, no
metablock is proposed). On successfully receiving the metablock,
the honest players in [𝑛] reply by broadcasting their vote (denoted
by V𝑒
𝑖 , ∀𝑖 ∈ [𝑛]) over the network. The metablock is notarized once
it achieves a vote from at least all the honest players. The metablock
is finalized according to the finalization rule of the crash-fault tol-
erant version of Streamlet Π0

cft (Sec. 5 in [13]).

Algorithm 1: SightSteeple-CFT (Πss
cft)

Leader Election:
∀𝑒, 𝐿𝑒 := 𝐻 ∗ (𝑒) mod 𝑚

Metablock Proposal:
If 𝐿𝑒 ∈ H, M𝑒 = M𝑒
∀𝑒, 𝐿𝑒 broadcasts M𝑒

H. If 𝐿𝑒 ∈ A, M𝑒 = ⊥.

Metablock Vote:
∀𝑖 ∈ [𝑛], 𝑖 broadcasts V𝑒

𝑖 = (𝑖, 𝑒, 𝐻 ∗ (M𝑒 )).

We will use M.Add−msg to denote the addition of a message msg ∈
{0, 1}∗ to metablock M.

4 SIGHTSTEEPLE: CRASH FAULT TOLERANT

We present the first version of the SightSteeple functional blockchain
consensus protocol, in the presence of a crash-fault adversary A: all
adversarial players stop sending and receiving all messages related
to the the protocol. We assume |A| < 𝑛
2 .

Metablock Notarization:
𝑛
M𝑒 is notarized when at least
2 players vote for it.
Metablock Finalization (from Streamlet Π0
cft
If in any notarized metachain, there exist three hash-linked
metablocks with consecutive epoch numbers, the prefix of the
metachain up to the second of the three metablocks is considered
final. Further, when a metablock is finalized, its parent chain is
also finalized.

):

, ,

Aditya Ahuja

4.2.1 Correctness. We show that the SightSteeple-CFT protocol
is correct.

.

Theorem 3 (SS-CFT Correctness). The SightSteeple-CFT pro-
achieves functional blockchain consensus, in the presence

tocol Π𝑠𝑠
cft
of a crash-fault adversary A, with |A| < 𝑛
2
Proof. Since the notarization and finalization rules in Π𝑠𝑠
cft are equiv-
alent to those in Π0
cft metachain will be consistent across all
players (Theorem 12 in [13]). We will now show that Π𝑠𝑠
cft achieves
the three goals of functional blockchain consensus (Definition 2),
considering a consistent metablock M𝑒 from an arbitrary epoch 𝑒,
and remembering the metablock response from honest leaders is
M𝑒

H and crash-faulty leaders do not propose a metablock:

cft, the Π𝑠𝑠

(i) Functional Hierarchy Consistency: Since all honest players
vote on the genesis block which contains ([𝑛], C, F, Ψ), and vote
on the metablock M𝑒 which contains (𝑓 𝑒
𝑖 )𝑖 ∈ [𝑛] , it is implied that
all honest players agree on (Ψ(𝜅𝑖 ) = 𝑓 𝑒

𝑖 ∈ F)𝑖 ∈ [𝑛] .

(ii) Block Payload View Integrity: Since each honest player voted
on the metablock, which implies that it successfully received M𝑒 ,
it is true that each honest player knows that each honest player
𝑖 (txs𝑒 ). Further, since each honest head player
𝑖 ∈ [𝑛] agrees on 𝑓 𝑒
voted, it is true that txs𝑒 doesn’t contain double spending transac-
tions.

(iii) Liveness: The Π𝑠𝑠

cft block finalization rule. Thus, the liveness of Π𝑠𝑠

the Π0
by Theorem 13 in [13] (details in Appendix A.1).

cft metablock finalization rule is identical to
cft is implied
□

𝑖 contains:

The Πss
cft metachain implies each player chain. Consider, for any
𝑒
epoch 𝑒, the metachain mchain
and the most recent metablock
M𝑒 in it. Also consider, for each honest player 𝑖 ∈ [𝑛], the sub-
𝑖 of M𝑒 . M𝑒
metablock M𝑒
1. (𝑒, 𝐻 ∗ (M𝑒′
), ΓaFE.Enc(txs𝑒 ))
𝑒−1
), 𝑓 𝑒
2. (𝑖, 𝐻 ∗ (chain
𝑖
From both these messages, it is easy for player 𝑖 to imply
𝑒
𝑒−1
𝑖 = (chain
chain
𝑖
encrypted secret key sk𝑓 𝑒
under ΓaFE.

𝑖 (txs𝑒 )), by recovering the
𝑖 (txs𝑒 )

𝑖 under ΓE, followed by recovering 𝑓 𝑒

𝑖 , (ΓaFE.sk𝑓 𝑒

, 𝐻 ∗ (𝑓 𝑒′
𝑖

)ΓE.𝑖−1 )

(txs𝑒′

)), 𝑓 𝑒

𝑖

5 SIGHTSTEEPLE: RATIONAL FAULT

TOLERANT

5.1 Impossibility of (Secret Key based) BFT

SightSteeple

Asymmetric block payload visibility based on encrypted on-chain
information as part of the metablock, and a secret key per player,
can never be Byzantine fault tolerant. This is because an adversarial
player can just broadcast its secret key after the metablock final-
ization, thereby violating the payload view integrity on any lower
credential honest player. Due to this payload view malleability post
payload finalization, Byzantine-fault tolerant SightSteeple is im-
possible, as is formalized by the following attack.

Attack 1 (SightSteeple-BFT). Assume there exists a Byzantine
player 𝑖 ′ ∈ A, and an honest player 𝑖 ∈ H , with 𝜅𝑖 ⪯ 𝜅𝑖′ and
𝜅𝑖′ ⪯̸ 𝜅𝑖 . Assume at some epoch ˜𝑒 > 𝑒, the metablock M𝑒 is finalized,
then player 𝑖 ′ can violate the block payload view integrity of player 𝑖
for epoch 𝑒, by broadcasting ΓvFE.𝑠𝑘𝑓 𝑒
over the network at epoch ˜𝑒.
𝑖′

Consequently, SightSteeple need be proposed for a weaker adver-
sary.

5.2 Rational-fault Adversary: Motivation and

Definition

We consider rational players which wish to (i) maximize their rev-
enue from the block payload, in terms of block reward (if the proto-
col is incentivized, as in Bitcoin [7]), transaction fees, and by double
spending transactions in the payload which they are a part of; and
(ii) maximize their payload view (under ⪯).

Further, rational players may want to mislead honest players
by supplying them a secret key (under the functional encryption
scheme) for an incorrect view function, thereby forcing them to
agree to an incorrect view of the payload, and violating the block
payload view integrity for honest players, even when the metachain
is consistent. An example to illustrate such an attack on head play-
ers is given below. Consequence for honest head players under such
an attack is that they cannot propose payloads after the attack (as
payloads may not be notarizable), inducing an effective denial-of-
service (different from conventional DoS attacks as in [30]). Thus
it is imperative to design a protocol with verifiable view function
keys for resilience to a rational adversary.

Attack 2 (SightSteeple-RFT without Γ𝑣𝐹 𝐸 ). Let

˜𝑓 (txs) :=
txs with reduced value of each tx by 1 unit. Consider, for some epoch
𝑒, a rational leader 𝐿𝑒 = 𝑖 ′ ∈ A supplies 𝑠𝑘 ˜𝑓
instead of 𝑠𝑘𝑓 ∗ to an
honest 𝑖 ∈ [𝑚]. Now, for the smallest 𝑒 ′ > 𝑒, with 𝐿𝑒′ = 𝑖, if 𝑖 proposes
a metablock containing payload txs𝑒 , the said metablock will not be
notarized by any honest head player (due to the impression of double
spending).

Rational Players’ Utility Function. We present the utility of the ra-
tional adversary A, which is a function of the metablock proposed
and notarized in the current epoch 𝑒. Briefly, the utility function is a
convex combination of the revenue 𝜏A for the adversary resulting
from the potential confirmation of the payload txs𝑒 (which could
be any combination of block reward, if the consensus protocol is in-
centivized, transaction fees, or transactions by the adversary in the
payload), and the visibility into the payload given by the payload
view function 𝑓 𝑒
𝑖′ for each faulty player 𝑖 ′. We give the normalized
utility function 𝑣𝑒
A next, where 𝛽1, 𝛽2 ∈ (0, 1), with 𝛽1 + 𝛽2 = 1:
A (M𝑒 ) := 𝛽1 · 𝜏A (txs𝑒 ) + 𝛽2 ·
𝑣𝑒
(cid:205)𝑖′ ∈A

dist⪯ (𝑓⊥,𝑓 𝑒
𝑖′ )
dist⪯ (𝑓⊥,𝑓 ∗)

1
| A |

(1)

We assume that rational players wish to maximize their utility under
𝑣𝑒
A from participation in rational-fault tolerant SightSteeple, and
so would choose metablock proposal strategies to that end.

SightSteeple

, ,

5.3 Metablock Structure
The genesis block. The players in [𝑛] initialize the system by agree-
ing on the genesis block gen := (0, [𝑛], C, F, Ψ, ΓE, ΓvFE, 𝐻 ∗). The
genesis block is notarized when at least 2𝑛
3 players vote on it (a
vote by a player is just a signed hash of the genesis block by that
player).
We will modify the vote and notarization rule for the metablock.

The metablock (by honest leaders). The metablock for SightSteeple-
RFT by honest leaders is presented next. The metablock contains
the current epoch number 𝑒, hash of the previous metablock M𝑒′
to which the current metablock is linked, public parameters pp𝑒
under the scheme ΓvFE, encryption of the list of transactions txs𝑒
under ΓvFE, and, for each player 𝑖, hash of the current player chain
𝑒−1
, payload view function 𝑓 𝑒
for 𝑖, and the encryption of the
chain
𝑖
𝑖
secret key sk𝑓 𝑒

𝑖 under ΓvFE, recoverable by 𝑖.

SS-RFT Metablock:
The Contents of M𝑒

H by Leaders in H

← 𝜙

Initialize M𝑒
H
.Add−(𝑒, 𝐻 ∗ (M𝑒′
M𝑒
H
∀𝑖 ∈ [𝑛]:
M𝑒
H

𝑒−1
.Add−(𝑖, 𝐻 ∗ (chain
𝑖

), ΓvFE.pp𝑒, ΓvFE.Encpp𝑒 (txs𝑒 ))ΓSig.𝐿𝑒

that the secret key it received is that for Ψ(𝜅𝑖 ). The honest head
players also validate that txs𝑒 has no double spending transactions.
Post validation, the honest players in [𝑛] reply by broadcasting
their vote (denoted by V𝑒
𝑖 , ∀𝑖 ∈ [𝑛]) to the network. Each vote is
either a ‘yes’ vote if the validation succeeds, or a ‘no’ vote if the
validation fails. The metablock is notarized once it achieves a ‘yes’
vote from at least all the honest players, and receives no ‘no’ votes.
The metablock is finalized according to the finalization rule of the
Byzantine-fault tolerant version of Streamlet Π0
bft (Sec. 3 in [13]).

Rational Player Voting Policy. We now show that it is not necessary
for rational players to vote in order to maximize their utility under
𝑣𝑒
A , for any epoch 𝑒.

It is in the interest of rational players that, for the maximization of
the utility function 𝑣𝑒
A , ∀𝑒, M𝑒 is notarized: if M𝑒 is not notarized,
A = 0, but if M𝑒 is notarized, there is a possibility that M𝑒 would be
𝑣𝑒
finalized, and consequently 𝑣𝑒
𝑖′ ) > 0, ∀𝑖 ′ ∈
A
A). This implies that for metablocks M𝑒
A , no rational
player will ever vote no. Further, since honest players will always
vote ‘yes’ for M𝑒
A , consequently both these metablocks
will be notarized, the rational players need not vote ‘yes’.

> 0 (since dist⪯ (𝑓⊥, 𝑓 𝑒

H and ˜M𝑒

H and ˜M𝑒

), 𝑓 𝑒

𝑖 , (ΓvFE.sk𝑓 𝑒

𝑖

)ΓE.𝑖−1 )ΓSig.𝐿𝑒

Algorithm 2: SightSteeple-RFT (Πss
rft)

The metablock (by adversarial leaders). The metablock for Sight-
Steeple-RFT by rational leaders is also presented next. The metablock
is the same as that from the honest leaders, except that ∀𝑖 ∈ A, the
secret key sk𝑓 𝑒

𝑖 under ΓvFE is replaced by sk𝑓 ∗ .

SS-RFT Metablock:
˜M𝑒
The Contents of

A by Leaders in A

A ← 𝜙

Initialize ˜M𝑒
˜M𝑒
∀𝑖 ∈ [𝑛] \ A:
˜M𝑒
∀𝑖 ∈ A:
˜M𝑒

A .Add−(𝑒, 𝐻 ∗ (M𝑒′

), ΓvFE.pp𝑒, ΓvFE.Encpp𝑒 (txs𝑒 ))ΓSig.𝐿𝑒

𝑒−1
A .Add−(𝑖, 𝐻 ∗ (chain
𝑖

𝑒−1
A .Add−(𝑖, 𝐻 ∗ (chain
𝑖

), 𝑓 𝑒

𝑖 , (ΓvFE.sk𝑓 𝑒

𝑖

)ΓE.𝑖−1 )ΓSig.𝐿𝑒

), 𝑓 𝑒

𝑖 , (ΓvFE.skf ∗ )ΓE.𝑖−1 )ΓSig.𝐿𝑒

Note the need for a signature on metablock contents: a rational
head player, which is not the current epoch leader, can otherwise
propose the metablock.

5.4 The SightSteeple-RFT Protocol
The SightSteeple-RFT Protocol Πss
rft is presented in Algorithm 2.
For this protocol, it is assumed that for the rational adversary A,
|A| < 𝑛
3 .

Protocol Outline. For each epoch, the metablock proposing leader is
elected as a random member of [𝑚], as a function of 𝑒. If the leader
is honest, it proposes M𝑒
H to the network. Otherwise, the rational
leader proposes
A . On receiving the the first metablock from the
leader, each honest player 𝑖 in [𝑛] validates its contents to ensure

˜M𝑒

Leader Election:
∀𝑒, 𝐿𝑒 := 𝐻 ∗ (𝑒) mod 𝑚

A

H. If 𝐿𝑒 ∈ A, M𝑒 = ˜M𝑒

Metablock Proposal:
If 𝐿𝑒 ∈ H, M𝑒 = M𝑒
∀𝑒, 𝐿𝑒 broadcasts M𝑒
Metablock Validation and Vote (first M𝑒 from 𝐿𝑒 ):
Each honest 𝑖 ∈ [𝑛] asserts 𝑓 𝑒
=ΓvFE skΨ(𝜅𝑖 ) .
Each honest 𝑖 ∈ [𝑚] also asserts txs𝑒 has no double spending. If
assertions succeed for 𝑖, broadcast V𝑒
𝑖 = (𝑖, 𝑒, 𝐻 ∗ (M𝑒 ), yes)ΓSig.𝑖 ,
otherwise broadcast V𝑒

𝑖 = (𝑖, 𝑒, 𝐻 ∗ (M𝑒 ), no)ΓSig.𝑖 .

𝑖 = Ψ(𝜅𝑖 ) and sk𝑓 𝑒

𝑖

3 players vote ‘yes’, and no player

Metablock Notarization:
M𝑒 is notarized when at least 2𝑛
votes ‘no’.
Metablock Finalization (from Streamlet Π0
If in any notarized metachain, there exist three hash-linked
metablocks with consecutive epoch numbers, the prefix of the
metachain up to the second of the three metablocks is considered
final. Further, when a metablock is finalized, its parent chain is
also finalized.

bft

):

5.4.1 Correctness. We first show that the best metablock response
by rational head players is

˜M𝑒

A .

Lemma 4 (Rational Leader Metablock). Assuming that ratio-
nal players wish to maximize their utility under 𝑣𝑒
, the dominant
A
strategy on metablock proposal for each rational head player 𝑖 ′ ∈ [𝑚]
is 𝜎𝑖′
Proof. The payoff for rational leaders as part of 𝑣𝑒
A is on (i) the
revenue from the block payload confirmation; and (ii) the visibility

, for each epoch 𝑒 when 𝐿𝑒 = 𝑖 ′.

˜M𝑒
A

, ,

Aditya Ahuja

into the list of transactions. For (i), note that the rational leader
may attempt to fork the metachain to orphan some metablocks, if
it results in a higher revenue for it. The rational leader may also
consider announcing two metablocks in quick succession for the
same epoch in which it is a leader if it receives a second payload in
the same epoch which has a higher revenue possible6. For (ii), the
rational leaders’ payoff is maximized when all faulty players learn
txs𝑒, ∀𝑒. This can only happen when each faulty player receives the
secret key ΓvFE.sk𝑓 ∗ for each epoch in which a rational player is
elected leader.
Finally, it is easy to see that 𝑣𝑒
A = 0 if the rational leader’s block is
unnotarized, and 𝑣𝑒
> 0 if the rational leader’s block is notarized
A
(even if the payload related revenue is zero, the payload view payoff
is positive). Consequently, both (i) and (ii) are achievable only when
a rational leader’s metablock is notarized, which is only possible
when each honest player 𝑖 receives ΓvFE.sk𝑓 𝑒
𝑖 .
These arguments imply that the best choice of a metablock from
rational leaders 𝑖 ′ ∈ [𝑚] is
. □

A , denoted by the strategy 𝜎𝑖′
˜M𝑒
A

˜M𝑒

We now show that the SightSteeple-RFT protocol is correct.

.

Theorem 5 (SS-RFT Correctness). The SightSteeple-RFT pro-
achieves functional blockchain consensus, in the presence

tocol Π𝑠𝑠
rft
of a rational-fault adversary A, with |A| < 𝑛
3
Proof. Since the notarization and finalization rules in Π𝑠𝑠
rft are equiv-
alent to those in Π0
rft metachain will be consistent across
all players (Theorem 3 in [13]). We will now show that Π𝑠𝑠
rft achieves
the three goals of functional blockchain consensus (Definition 2),
considering a consistent metablock M𝑒 from an arbitrary epoch 𝑒,
and remembering the metablock response from honest leaders is
M𝑒

bft, the Π𝑠𝑠

H and that from rational leaders is

A (Lemma 4):

˜M𝑒

(i) Functional Hierarchy Consistency: Since all honest players
vote on the genesis block which contains ([𝑛], C, F, Ψ), and vote
‘yes’ on the metablock M𝑒 which contains (𝑓 𝑒
𝑖 )𝑖 ∈ [𝑛] , it is implied
that all honest players agree on (Ψ(𝜅𝑖 ) = 𝑓 𝑒

𝑖 ∈ F)𝑖 ∈ [𝑛] .

(ii) Block Payload View Integrity: Since each honest player voted
‘yes’ on the metablock (which is one of M𝑒
˜M𝑒
A ), and no player
voted ‘no’, it is implied that the verification of 𝑓 𝑒
𝑖 under ΓvFE suc-
ceeded for each honest player 𝑖 ∈ [𝑛], and so it is true that each
honest player knows that each honest player 𝑖 ∈ [𝑛] agrees on
𝑓 𝑒
𝑖 (txs𝑒 ). Further, since each honest head player voted ‘yes’, it is
true that txs𝑒 doesn’t contain double spending transactions.

H or

(iii) Liveness: The Π𝑠𝑠

bft block finalization rule. Thus, the liveness of Π𝑠𝑠

the Π0
by Theorem 6 in [13] (details in Appendix A.1).

rft metablock finalization rule is identical to
rft is implied
□

The Πss
rft metachain implies each player chain. Consider, for any
𝑒
epoch 𝑒, the metachain mchain
and the most recent metablock
M𝑒 in it. Also consider, for each honest player 𝑖 ∈ [𝑛], the sub-
metablock M𝑒

𝑖 of M𝑒 . M𝑒

𝑖 contains:

6Consider, for some epoch 𝑒, 𝑖′ receives txs𝑒
𝜏A (txs𝑒

2 ) > 𝜏A (txs𝑒

1 ). 𝑖′ would announce metablocks for both payloads.

1 at 𝑒 and txs𝑒

2 at 𝑒 + 𝜖 (for a small 𝜖), with

), 𝑓 𝑒

𝑖 , (ΓvFE.sk𝑓 𝑒

1. (𝑒, 𝐻 ∗ (M𝑒′
), ΓvFE.pp𝑒, ΓvFE.Enc(txs𝑒 ))ΓSig.𝐿𝑒
𝑒−1
2. (𝑖, 𝐻 ∗ (chain
)ΓE.𝑖−1 )ΓSig.𝐿𝑒
𝑖
From both these messages, it is easy for player 𝑖 to imply
𝑒−1
𝑒
𝑖 = (chain
chain
𝑖
encrypted secret key sk𝑓 𝑒
under ΓvFE.

𝑖 under ΓE, followed by recovering 𝑓 𝑒

𝑖 (txs𝑒 )), by recovering the
𝑖 (txs𝑒 )

, 𝐻 ∗ (𝑓 𝑒′
𝑖

(txs𝑒′

)), 𝑓 𝑒

𝑖

5.5 Special Case: Perfect SightSteeple-RFT

We outline a special case where each player, honest or rational-
faulty, agrees on a correct block payload view for each epoch of the
SightSteeple metachain. Given the player network [𝑛], consider
the case where, for each credential, there are at least 𝑎0 players
with that credential, and among those players, there is at least one
honest player, and less than 𝑎0 rational players. Now, by using a
single (𝑛, 𝑎0) threshold encryption [20] of the secret payload view
function key for all players with the same credential, the rational
leaders would be forced to encrypt the correct view function key
in the metablock for all faulty players (if the rational leader wants
its metablock to be notarized by the honest players). Consequently,
perfect SightSteeple-RFT can be achieved, where ∀𝑒, ∀𝑖 ∈ [𝑛], 𝑖
learns nothing other than 𝑓 𝑒
𝑖 (txs𝑒 ).
Giving an exact construction and correctness proof for this special
case of SightSteeple-RFT is left as a future exercise.

6 DISCUSSION
6.1 Functional Blockchain Consensus for

dApps

We discuss possible applications of asymmetric distributed ledgers
resulting from functional blockchain consensus.

Cryptocurrencies [7] with sensitive transactions. We demonstrate how
asymmetric distributed ledgers for cryptocurrencies with privileged
transactions, based on sub-types of functional encryption, can be
constructed, assuming the init-party is a cross-jursidictional net-
work of federal regulators. The first sub-type of functional encryp-
tion we consider is attribute based encryption (ABE) [27], which
allows recovery of the plaintext if the decryptor satisfies certain
attributes. Using ABE, SightSteeple can be defined to allow play-
ers in specific federal jurisdictions to learn the complete list of
transactions. The next sub-type of functional encryption we con-
sider is predicate encryption (PE) [6], which allows recovery of the
plaintext if some predicate on the plaintext is true (based on the key
held by the decryptor). SightSteeple can be defined with PE to
allow a subset of players to learn the list of transactions if a specific
transactor (say Alice) has a transaction in it. Finally, a functional
encryption scheme with the inner-product functionality (IP) [1]
can be used to learn the sum of a sub-sequence of the plaintext.
SightSteeple with IP can be used to allow players to learn the sum
value of all crypto-tokens exchanged in the list of transactions.

Asymmetric Decentralized Finance (DeFi) [36, 40] applications. We
present some asymmetric financial market solutions that can result
from functional blockchain consensus. First, asymmetric automated
markets may be defined by achieving functional blockchain con-
sensus on a subset of asset reserves per player (thereby locking in

SightSteeple

, ,

a sub-pool of assets in the smart contract corresponding to each
player). Next, asymmetric portfolio management and exposure can
be achieved through functional blockchain consensus, to facilitate
different DeFi protocols, such as protocols for loanable funds and
automated market makers, for different subsets of players. Finally,
derivative trading under different combinations o of synthetic as-
sets, futures, perpetual swaps and options, for different subsets of
players, may be achieved through functional blockchain consensus.
The init-party for such applications could be a benevolent dictator
[36], that initializes each application appropriately for financial
governance.

Other dApps [12]. As a final example, functional blockchain consen-
sus can facilitate the need for asymmetric records for agreement
on classified information in governance [16, 31] (for instance on
citizenship and voting records), healthcare [9, 26, 28] (on patient
healthcare records), and decentralized IoT network management
[12] requiring agreement on sensitive RFID sensor data such as
from supply chains, transportation networks, and inventory man-
agement.

6.2 Block Payload View Privilege Alteration

𝑖 (txs𝑒 ), with (Ψ(𝜅𝑖 ) = 𝑓 𝑒

It has been shown in Section 5.5, that perfect rational-fault toler-
ance in SightSteeple, where, ∀𝑒, each player 𝑖 ∈ [𝑛] provably
learns 𝑓 𝑒
𝑖 ∈ F)𝑖 ∈ [𝑛] , is only achievable
as a special case. In general, the rational players can violate their
privileges to learn the entire payload, whenever a rational head
player is elected as the metablock proposer. We revisit the privilege
alteration properties of SightSteeple, seen so far.

Inherent Collusion to Supersede Privilege. The adversary in Sight-
𝑖′ (txs𝑒 )}𝑖′ ∈A , for each epoch

Steeple-RFT implicitly learns sup⪯ {𝑓 𝑒
𝑒, as it controls all players in A.

Privilege alteration would be ineffective in escalated information
going on-chain for honest players. It has been established that, given
a rational-fault adversary, the metablock response by honest lead-
ers in the SightSteeple protocol is M𝑒
H, and the best metablock
˜M𝑒
response by rational leaders is
A (Lemma 4). In both instances,
it is true that the secret functional encryption key supplied for
each honest 𝑖 ∈ [𝑛] is no different from skΨ(𝜅𝑖 ) . This implies that
although the rational players might learn the entire list of transac-
tions, the correctness is preserved for all honest players.

Off-Chain Privilege Preservation. In future, in order to ensure
∀𝑒, each player 𝑖 ∈ [𝑛] provably learns 𝑓 𝑒
𝑖 (txs𝑒 ), with (Ψ(𝜅𝑖 ) =
𝑓 𝑒
𝑖 ∈ F)𝑖 ∈ [𝑛] , metablock proposal may be made an off-chain ac-
tivity. Options to outsource metablock creation include payload
view function key generation through decentralized blockchain-
based multi-party computation [41], or through dynamic decen-
tralized functional encryption [14], or through an alternate, oracle
blockchain system [17].

6.3 SightSteeple Protocol Optimization

The present version of SightSteeple has some overheads in terms
of space complexity of the proposed metablock, and overall com-
munication complexity per epoch of metablock proposal. Both
SightSteeple-CFT and SightSteeple-RFT have metablock size
|M𝑒 | ∈ Θ(𝑛). Further, since the base protocol Streamlet echoes
each message [15], the current communication complexity ∀𝑒 is
𝑛2 (|M𝑒 | + 𝑛|V𝑒 |) = Θ(𝑛3).
In future, we would like to reduce the metablock size, and supplant
the base protocol from Streamlet to HotStuff [38], to reduce the
communication complexity, and provide an API for implementation
[15, 35].

6.4 Function and Block Payload Privacy

We give a brief discussion on whether any information about the
payload, beyond what is presented in the metablock, is leaked, un-
der the associated functional encryption scheme. The following
arguments are based on message privacy (from Appendix A.2),
which translates to payload privacy in SightSteeple, remember-
ing that payloads are the functionally encrypted messages in the
metablocks.

Under crash-fault tolerance. ΓaFE achieves full message privacy [8],
which implies that SightSteeple-CFT achieves full payload pri-
vacy for each function in F, even though any of the players might
not be intending to infer extra information from what is conveyed
for them individually in the metachain.

Under rational-fault tolerance. Function Privacy [8] is not achieved
in the present version of SightSteeple, as the view functions are
public in the metablock, in order to ensure the functional hierarchy
consistency. Block payload security requirements are implied by
the re-instantiation of the verifiable functional encryption scheme
parameters per epoch, in SightSteeple-RFT. In the SightSteeple-
𝑛
RFT protocol, the adversary sees 1 payload and less than
3 func-
tions applied on the payload, in each epoch (which has a separate
instantiation of the verifiable functional encryption scheme parame-
ters). Thus SightSteeple-RFT requires at least 1-selective-message
𝑛
payload privacy and at least
3 -selective-function payload privacy
[8] (security notions outlined in A.2) under ΓvFE, proving which is
beyond the scope of this contribution.

7 FUTURE DIRECTIONS

We have initiated a new line of enquiry into functional blockchain
consensus, and proposed a first functional blockchain consensus
protocol SightSteeple providing an asymmetric visibility into the
list of transactions. To conclude, we outline some problems emerg-
ing from this contribution, that can be addressed in future.

Off-chain metablock creation for privilege preservation. Presently,
the block payload view decryption is part of the consensus protocol,
as part of the validation of the metablock. In future, SightSteeple
can be amended to eliminate privilege escalation by adversarial
metablock proposers, through outsourced (if needed verifiable) de-
cryption under a functional encryption scheme, using standard

, ,

blockchains [17].

In hidden credentials’ networks, understanding the tradeoff be-
tween expressiveness of function families F versus function-privacy
under various FE schemes. SightSteeple is constructed to reveal
the credentials and view functions for each player. In future, for
privacy, if the credentials and view functions per player need
not be revealed while achieving functional hierarchy consistency,
then function-private functional encryption schemes [8] may be
employed to achieve functional blockchain consensus. Given a
adversary A ⊆ [𝑛], collusion can be prevented using function-
private functional encryption, to prevent A from learning more
than {𝑓𝑖′ (txs)}𝑖′ ∈A , in terms of payload information and view func-
tions, for each payload txs going on-chain. However, in this case,
the permissible set of view functions F supported by the functional
encryption scheme is an open question, which may be addressed
in future.

Functional blockchain consensus in the BAR and ByRa models [29].
SightSteeple has been constructed to be resilient to crash-faults
and rational-faults. It has been shown that SightSteeple cannot be
appropriately modified to achieve Byzantine-fault tolerance (Sec-
tion 5.1). In future, alternate protocols for functional blockchain
consensus may be proposed for tolerance to a combination of Byzan-
tine and rational players in the presence of altruistic/honest players
(the BAR model), or functional blockchain consensus may be at-
tained in the absence of honest players altogether (identical to the
ByRa model of the Tenderstake [29] protocol).

Towards asymmetric smart contracts. Traditionally, for each par-
ticipant in the distributed system, the execution logic of the smart
contract is predicated on chain∗. Given the hierarchical player
blockchains resulting from SightSteeple, future functional smart
contracts in credential driven distributed systems, may base their
𝑒
𝑖 for player 𝑖 (or any process privy to
execution logic on chain
player 𝑖’s blockchain), or might even base their execution logic on
𝑒
𝑖 }𝑖 ∈ [𝑛] for each player7.
inf ⪯ {chain

Proposing declassification blockchain consensus. In the instance
that a peer-to-peer network requires agreement on sensitive infor-
mation that cannot be revealed in completion immediately, but can
safely be divulged in the future, a declassification blockchain pro-
tocol can be defined to reach the said goal. To that end, we propose
the following definition of declassification consensus, which may
be realized using a SightSteeple-like protocol in the future.

Proposed Definition (Declassification Consensus). Given a
declassification window 𝐻 , ∀ℎ, ∃𝑓 ∈ F, 𝑓 ≠ 𝑓 ∗, such that if the honest
players in [𝑛] finalize 𝑓 (txsℎ) at height ℎ, then they also finalize txsℎ
at height ℎ + 𝐻 .

We so believe that through this contribution, and through the pos-
sible future directions as stated above, SightSteeple would be a
stepping stone towards defining new consensus paradigms and
protocols for an asymmetric agreement on privileged information.

7We use the inf ⪯ notation on player blockchains to give the same implication as the
inf ⪯ notation on payload view in Section 2.4.

Aditya Ahuja

REFERENCES
[1] Michel Abdalla, Florian Bourse, Angelo De Caro, and David Pointcheval. 2015.
Simple functional encryption schemes for inner products. In IACR International
Workshop on Public Key Cryptography. Springer, 733–751.

[2] Poonam Ahuja, Deepak Ahuja, and Aditya Ahuja. WIPO International Publication
No. WO 2021/205241 A1, 14 Oct. 2021. System and method for establishing a
trusted functional blockchain consensus. https://patents.google.com/patent/
WO2021205241A1/en.

[3] Saikrishna Badrinarayanan, Vipul Goyal, Aayush Jain, and Amit Sahai. 2016.
Verifiable functional encryption. In International Conference on the Theory and
Application of Cryptology and Information Security. Springer, 557–587.

[4] Utsav Banerjee and Anantha P Chandrakasan. 2021. A Low-Power Elliptic
Curve Pairing Crypto-Processor for Secure Embedded Blockchain and Functional
Encryption. In 2021 IEEE Custom Integrated Circuits Conference (CICC). IEEE,
1–2.

[5] Shehar Bano, Alberto Sonnino, Mustafa Al-Bassam, Sarah Azouvi, Patrick Mc-
Corry, Sarah Meiklejohn, and George Danezis. 2019. SoK: Consensus in the age
of blockchains. In Proceedings of the 1st ACM Conference on Advances in Financial
Technologies. 183–198.

[6] Dan Boneh, Amit Sahai, and Brent Waters. 2011. Functional encryption: Defini-
tions and challenges. In Theory of Cryptography Conference. Springer, 253–273.
[7] Joseph Bonneau, Andrew Miller, Jeremy Clark, Arvind Narayanan, Joshua A
Kroll, and Edward W Felten. 2015. Sok: Research perspectives and challenges for
bitcoin and cryptocurrencies. In 2015 IEEE symposium on security and privacy.
IEEE, 104–121.

[8] Zvika Brakerski and Gil Segev. 2018. Function-private functional encryption in

the private-key setting. Journal of Cryptology 31, 1 (2018), 202–225.

[9] Builtin. (Online; Accessed 21-Feb-2022). Blockchain in Healthcare: 15 Examples.
https://builtin.com/blockchain/blockchain-healthcare-applications-companies
[10] Christian Cachin. 2021. Asymmetric distributed trust. In International Conference

on Distributed Computing and Networking 2021. 3–3.

[11] Christian Cachin and Luca Zanolini. 2021. Asymmetric Asynchronous Byzan-
tine Consensus. In Data Privacy Management, Cryptocurrencies and Blockchain
Technology. Springer, 192–207.

[12] Fran Casino, Thomas K Dasaklis, and Constantinos Patsakis. 2019. A systematic
literature review of blockchain-based applications: Current status, classification
and open issues. Telematics and informatics 36 (2019), 55–81.

[13] Benjamin Y Chan and Elaine Shi. 2020.

Streamlet: Textbook streamlined
blockchains. In Proceedings of the 2nd ACM Conference on Advances in Financial
Technologies. 1–11.

[14] Jérémy Chotard, Edouard Dufour-Sans, Romain Gay, Duong Hieu Phan, and
David Pointcheval. 2020. Dynamic decentralized functional encryption. In Annual
International Cryptology Conference. Springer, 747–775.

[15] Shir Cohen and Dahlia Malkhi. (Online; Accessed 21-Feb-2022). What They Did
not Teach you in Streamlet. https://dahliamalkhi.github.io/posts/2020/12/what-
they-didnt-teach-you-in-streamlet/

[16] ConsenSys. (Online; Accessed 21-Feb-2022). Blockchain in Government and Public
Sector. https://consensys.net/blockchain-use-cases/government-and-the-public-
sector/

[17] Hui Cui, Zhiguo Wan, Xinlei Wei, Surya Nepal, and Xun Yi. 2020. Pay as you
decrypt: Decryption outsourcing for functional encryption using blockchain.
IEEE Transactions on Information Forensics and Security 15 (2020), 3227–3238.
[18] Zhihua Cui, XUE Fei, Shiqiang Zhang, Xingjuan Cai, Yang Cao, Wensheng Zhang,
and Jinjun Chen. 2020. A hybrid blockchain-based identity authentication scheme
for multi-WSN. IEEE Transactions on Services Computing 13, 2 (2020), 241–251.
[19] Dorothy E Denning. 1976. A lattice model of secure information flow. Commun.

ACM 19, 5 (1976), 236–243.

[20] Yvo Desmedt and Yair Frankel. 1989. Threshold cryptosystems. In Conference on

the Theory and Application of Cryptology. Springer, 307–315.

[21] Danny Dolev and H. Raymond Strong. 1983. Authenticated algorithms for

Byzantine agreement. SIAM J. Comput. 12, 4 (1983), 656–666.

[22] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. 1988. Consensus in the
presence of partial synchrony. Journal of the ACM (JACM) 35, 2 (1988), 288–323.
[23] Sanjam Garg, Craig Gentry, Shai Halevi, Mariana Raykova, Amit Sahai, and
Brent Waters. 2016. Candidate indistinguishability obfuscation and functional
encryption for all circuits. SIAM J. Comput. 45, 3 (2016), 882–929.

[24] Sanjam Garg, Craig Gentry, Shai Halevi, and Mark Zhandry. 2014. Fully Secure
IACR Cryptol. ePrint Arch. 2014

Functional Encryption without Obfuscation.
(2014), 666.

[25] Sergey Gorbunov, Vinod Vaikuntanathan, and Hoeteck Wee. 2012. Functional
encryption with bounded collusions via multi-party computation. In Annual
Cryptology Conference. Springer, 162–179.

[26] Marko Hölbl, Marko Kompara, Aida Kamišalić, and Lili Nemec Zlatolas. 2018. A
systematic review of the use of blockchain in healthcare. Symmetry 10, 10 (2018),
470.

[27] Allison Lewko, Tatsuaki Okamoto, Amit Sahai, Katsuyuki Takashima, and Brent
Waters. 2010. Fully secure functional encryption: Attribute-based encryption

SightSteeple

, ,

and (hierarchical) inner product encryption. In Annual International Conference
on the Theory and Applications of Cryptographic Techniques. Springer, 62–91.
[28] Thomas McGhin, Kim-Kwang Raymond Choo, Charles Zhechao Liu, and De-
biao He. 2019. Blockchain in healthcare applications: Research challenges and
opportunities. Journal of Network and Computer Applications 135 (2019), 62–75.
[29] Conor McMenamin, Vanesa Daza, and Matteo Pontecorvi. 2021. Achieving State
Machine Replication without Honest Players. In Proceedings of the 3rd ACM
Conference on Advances in Financial Technologies.

[30] Michael Mirkin, Yan Ji, Jonathan Pang, Ariah Klages-Mundt, Ittay Eyal, and Ari
Juels. 2020. BDoS: Blockchain denial-of-service. In Proceedings of the 2020 ACM
SIGSAC conference on Computer and Communications Security. 601–619.
[31] Thays A Oliveira, Miquel Oliver, and Helena Ramalhinho. 2020. Challenges for
connecting citizens and smart cities: ICT, e-governance and blockchain. Sustain-
ability 12, 7 (2020), 2926.

[32] Elaine Shi. 2020. Foundations of Distributed Consensus and Blockchains. https:

//www.distributedconsensus.net/. Book (Publicly Available).

[33] Jakub Sliwinski and Roger Wattenhofer. 2019. Abc: Asynchronous blockchain

without consensus. arXiv preprint arXiv:1909.10926 (2019).

[34] Ye-Byoul Son, Jong-Hyuk Im, Hee-Yong Kwon, Seong-Yun Jeon, and Mun-Kyu
Lee. 2020. Privacy-preserving peer-to-peer energy trading in blockchain-enabled
smart grids using functional encryption. Energies 13, 6 (2020), 1321.

[35] Pramod Viswanath. (Online; Accessed 21-Feb-2022). Blockchain protocols with
finality: Streamlet and HotStuff. https://courses.grainger.illinois.edu/ece598pv/
sp2021/lectureslides2021/ECE_598_PV_course_notes14.pdf

[36] Sam M Werner, Daniel Perez, Lewis Gudgeon, Ariah Klages-Mundt, Dominik
Harz, and William J Knottenbelt. 2021. Sok: Decentralized finance (defi). arXiv
preprint arXiv:2101.08778 (2021).

[37] Yang Xiao, Ning Zhang, Wenjing Lou, and Y Thomas Hou. 2020. A survey of
distributed consensus protocols for blockchain networks. IEEE Communications
Surveys and Tutorials 22, 2 (2020), 1432–1465.

[38] Maofan Yin, Dahlia Malkhi, Michael K Reiter, Guy Golan Gueta, and Ittai Abra-
ham. 2019. HotStuff: BFT consensus with linearity and responsiveness. In Pro-
ceedings of the 2019 ACM Symposium on Principles of Distributed Computing.
347–356.

[39] Artem Yurchenko, Mahbuba Moni, Daniel Peters, Jan Nordholz, and Florian
Thiel. 2020. Security for Distributed Smart Meter: Blockchain-based Approach,
Ensuring Privacy by Functional Encryption.. In CLOSER. 292–301.

[40] Dirk A Zetzsche, Douglas W Arner, and Ross P Buckley. 2020. Decentralized

finance. Journal of Financial Regulation 6, 2 (2020), 172–203.

[41] Hanrui Zhong, Yingpeng Sang, Yongchun Zhang, and Zhicheng Xi. 2019. Secure
multi-party computation on blockchain: An overview. In International Symposium
on Parallel Architectures, Algorithms and Programming. Springer, 452–460.
[42] Saide Zhu, Zhipeng Cai, Huafu Hu, Yingshu Li, and Wei Li. 2019. zkCrowd: a
hybrid blockchain-based crowdsourcing platform. IEEE Transactions on Industrial
Informatics 16, 6 (2019), 4196–4205.

A BACKGROUND
A.1 Streamlet: Main Results

Streamlet [13] is a simple blockchain protocol where consensus
evolves in four streamlined stages to achieve consistency and live-
ness: (i) a block is proposed by a random leader on the set of all
players; (ii) the first correct block seen by honest players is voted
on; (iii) a block is considered ‘notarized’ once a threshold of play-
ers vote on it; and lastly (iv) notarized block(s) are finalized under
different finalization rules depending on the network model and
the power of the adversary.

For our contribution, we would only consider Streamlet over a
partially synchronous network [22], with a crash-fault adversary
of size < 𝑛
cft), or a Byzantine-fault
adversary of size < 𝑛
bft).

2 in the network (denoted by Π0

3 in the network (denoted by Π0

cft and Π0

For both Π0
bft, the block finalization rule states that if a
player sees three adjacent notarized blocks, with consecutive epoch
numbers, then the second of the three blocks, along with its parent
chain, is finalized. The same finalization rule is applied to Π𝑠𝑠
cft and
Π𝑠𝑠
rft.

cft and Π0

Further, for both Π0
bft, the proof of consistency is simi-
lar. First, it is shown that for any epoch, for any honest player’s
blockchain snapshot, at most one block is notarized. Next, it is
shown that given a block branch with three adjacent notarized
blocks with three consecutive epoch numbers, there cannot exist a
notarized block at length 2 in any competing branch. These basic
arguments lead to Theorems 3 and 12 on consistency for Byzantine-
fault tolerant Streamlet and crash-fault tolerant Streamlet re-
spectively, in [13].

The liveness theorems of Π0
given next.

cft and Π0

bft are also identical, and are

Streamlet Liveness (Theorems 6 and 13 in [13]). After GST,
suppose that there are 5 consecutive epochs 𝑒, 𝑒 + 1, ..., 𝑒 + 4, all with
honest leaders, then, by the beginning of epoch 𝑒 + 5, every honest
node must have observed a new final block that was not final at the
beginning of epoch 𝑒. Moreover, this new block was proposed by an
honest leader.

A.2 Fundamentals of Functional Encryption

Functional encryption differs from traditional encryption by al-
lowing the decryptor to recover any function of the message from
the encryption of the message, instead of allowing the decryptor
to recover the message from its encryption. We outline the basics
of function encryption and its variants relevant to our contribu-
tion. We then highlight various notions of security that different
functional encryption schemes may achieve.

A.2.1 Basic Functional Encryption. A functional encryption scheme
[6], given a set of functions F over some message space 𝑀, is a tuple
of four probabilistic polynomial time algorithms
(Setup, KeyGen, Enc, Dec) where, ∀𝑚 ∈ 𝑀:
(𝑝𝑝, 𝑚𝑠𝑘) ← Setup(1𝜆)
𝑠𝑘𝑓 ← KeyGen(𝑚𝑠𝑘, 𝑓 ) for some 𝑓 ∈ F
𝑐𝑡𝑥 ← Enc𝑝𝑝 (𝑚)
𝑓 (𝑚) ← Dec(𝑠𝑘𝑓 , 𝑐𝑡𝑥)
where the decryption succeeds with at least an overwhelming prob-
ability in the security parameter 𝜆. The parameters 𝑝𝑝 are public,
whereas the key 𝑚𝑠𝑘 to generate the function secret key(s) is pri-
vate.

Functional Encryption for all Circuits. A functional encryp-
A.2.2
tion scheme for all circuits has the same specification as a standard
functional encryption scheme, except that it supports functional-
ity (decryption) F for all efficiently computable functions on the
message space. Examples of such schemes are [23] and [24]. The
scheme [23] achieves selective-message message privacy, and the
scheme [24] achieves full message privacy (both security notions
defined below). We denote a functional encryption scheme for all
circuits by ΓaFE.

A.2.3 Verifiable Functional Encryption. A verifiable functional en-
cryption scheme [3] supports, in addition to the base algorithms
(Setup, KeyGen, Enc, Dec), two additional algorithms
(VerCT, VerKey), such that
0/1 ← VerCT(𝑝𝑝, 𝑐𝑡𝑥) (output true if the ciphertext was generated
using the correct public parameters)
0/1 ← VerKey(𝑝𝑝, 𝑓 , 𝑠𝑘𝑓 ) (output true if the secret function key

, ,

Aditya Ahuja

indeed corresponds to the function 𝑓 )
Verifiable functional encryption works by modifying an existing
functional encryption scheme. Reasonable candidates for the un-
derlying functional encryption scheme are [23] (which achieves
selective-message message privacy) and [25] (which achieves selective-
function message privacy). We denote a verifiable functional en-
cryption scheme by ΓvFE.
Security of Functional Encryption Schemes. We briefly dis-
A.2.4
cuss different notions of message privacy security of functional
encryption schemes [8]. This notion of security translates to the
security properties of the payload under SightSteeple. We will
denote the adversary by A.

Valid message privacy adversary. A is a valid (polynomial time)
message privacy adversary if for all functions {𝑓𝑖 }𝑖 ≤𝑇 for which it
queries the KeyGen oracle of the scheme for secret keys, and for all
messages {𝑚 𝑗 } 𝑗 ≤𝑇 ′ it receives encryptions of under the scheme, it
is true that 𝑓𝑖1 (𝑚 𝑗1 ) = 𝑓𝑖2 (𝑚 𝑗2 ), ∀𝑖1, 𝑖2 ∈ [𝑇 ], 𝑗1, 𝑗2 ∈ [𝑇 ′]. We will
assume that for each of the message privacy models below, A is a
valid message privacy adversary.

Full message privacy. Full message privacy dictates that, given an
adversary A, that can request for any number of function keys

from the key generation oracle of the scheme, under valid message
privacy, the encryptions of any two messages received from the
encryption oracle of the scheme, for A, are computationally indis-
tinguishable.

Selective-message message privacy. Given any two vectors of mes-
sages, where each message vector has length 𝑘, and allowing A
to request any number of function keys from the key generation
oracle of the scheme, under valid message privacy, 𝑘-selective-
message message privacy dictates that the encryptions of the two
message vectors received from the encryption oracle of the scheme,
are computationally indistinguishable for A. The scheme achieves
selective-message message privacy, if it is 𝑘-selective-message mes-
sage private for all polynomials 𝑘 in the security parameter.

Selective-function message privacy. Given secret keys of 𝑘 arbitrary
functions received from the key generation oracle of the scheme by
the adversary A, 𝑘-selective-function message privacy dictates that
the encryptions of any two messages received from the encryption
oracle of the scheme, are computationally indistinguishable for A.
The scheme achieves selective-function message privacy, if it is
𝑘-selective-function message private for all polynomials 𝑘 in the
security parameter.

