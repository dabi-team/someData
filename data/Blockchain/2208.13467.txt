Partition-Tolerant and Byzantine-Tolerant
Decision-Making for Distributed Robotic Systems
with IOTA and ROS 2

Farhad Keramat, Jorge Pe˜na Queralta, and Tomi Westerlund

1

2
2
0
2

g
u
A
9
2

]

O
R
.
s
c
[

1
v
7
6
4
3
1
.
8
0
2
2
:
v
i
X
r
a

Abstract—With the increasing ubiquity of autonomous robotic
solutions, the interest in their connectivity and in the cooperation
within multi-robot systems is rising. Two aspects that are a
matter of current research are robot security and secure multi-
robot collaboration robust to byzantine agents. Blockchain and
other distributed ledger technologies (DLTs) have been proposed
to address the challenges in both domains. Nonetheless, some
key challenges include scalability and deployment within real-
world networks. This paper presents an approach to integrating
IOTA and ROS 2 for more scalable DLT-based robotic systems
while allowing for network partition tolerance after deployment.
This is, to the best of our knowledge, the ﬁrst implementation
of IOTA smart contracts for robotic systems, and the ﬁrst
integrated design with ROS 2. This is in comparison to the
vast majority of the literature which relies on Ethereum. We
present a general IOTA+ROS 2 architecture leading to partition-
tolerant decision-making processes that also inherit byzantine
tolerance properties from the embedded blockchain structures.
We demonstrate the effectiveness of the proposed framework for
a cooperative mapping application in a system with intermittent
network connectivity. We show both superior performance with
respect to Ethereum in the presence of network partitions, and a
low impact in terms of computational resource utilization. These
results open the path for wider integration of blockchain solutions
in distributed robotic systems with less stringent connectivity and
computational requirements.

Index Terms—DLT; Multi-robot systems; IOTA; Smart con-

tracts; Blockchain; Ethereum; Cooperative mapping;

I. INTRODUCTION

Autonomous robots are revolutionizing industries and civil
applications. Two aspects that are part of today’s ubiquitous
robotic solutions are connectivity and teaming [1], [2], [3].
Indeed, many robots today are deployed as part of larger ﬂeets
or in teams, often heterogeneous and fruit of the combination
of robots from different vendors. In addition, the proliferation
of robotic systems is leading to increased connectivity and
reliance on multi-robot interaction or cloud-based services [4].
Maintaining security becomes more critical as robots become
more connected and ubiquitous. Additionally, multi-robot sys-
tems may be prone to malicious behavior from within the
system, while malfunctioning units or sensors can also lead to
unexpected functionality or results. In practical applications,
a key aspect and important part of a multi-robot systems is
collective decision-making [5], which is highly susceptible to

Farhad Keramat, Jorge Pe˜na Queralta and Tomi Westerlund are with the
Turku Intelligent Embedded and Robotic Systems (TIERS) Lab, University
of Turku, Turku, Finland, e-mails: {fakera, jopequ, tovewe}@utu.ﬁ.

Fig. 1: Large-scale deployments of connected robots often include
both cloud-based connectivity and local connectivity within subsets
of robots, leading to potential network partitions. Global peer-to-peer
connection cannot be always relied upon when deployments occur in
remote areas. This is particularly critical when considering traditional
blockchain-based solutions in which data is lost if a subset of robots
are disconnected for a period of time.

malicious behavior. However, the potential effects of byzantine
agents has not been always considered in the literature [6].

In general, as autonomous robotic solutions become more
widely deployed, more attention is put to connectivity and
management of larger-scale distributed systems. With in-
creased connectivity, however, also comes an increased risk
of cybersecurity threats [7]. A robot featuring different forms
or wireless connectivity opens the door to a number of
attack vectors. Indeed, recent research has shown that mul-
tiple commercial platforms are susceptible to hijacking from
different types of interfaces [8]. With robots being cyber-
physical systems that often interact with humans and their
environment, a security vulnerability becomes both a safety
and security risk. In this work, we focus on securing multi-
robot interaction and collaborative decision-making from the
perspective of a distributed networked system where data is
shared and collaborative decisions are made.

The advances in distributed ledger technologies (DLTs),
which offer consensus mechanisms among multiple untrusted
parties, have made them widely used in interconnected net-
work of devices in recent years. In addition to providing a con-
sensus mechanism, DLT integration also introduces identity
management, tamper-proof logging, and smart contract execu-

 
 
 
 
 
 
tion, all of which can beneﬁt distributed robotic systems [9].
The majority of solutions for the IoT and robotic applications
in the literature rely on Ethereum smart contracts [10], [11].
However, there are limitations in terms of throughput and
tolerance against network partitioning. Network partitioning is
one of the challenges in the integration of DLTs in distributed
and mobile robotic systems due to the highly dynamic network
topologies and limited bandwidths available. Multiple works
in the literature already show the potential of blockchain
technology for managing byzantine behaviour or consensus
in swarms of robots [12], [13]. In contrast to the majority of
Ethereum-based systems, IOTA has already been identiﬁed as
a solution to address these issues [14], but smart contracts
have not been available until very recently.

In this paper, we propose a methodology to achieve col-
lective decision-making in distributed robotic applications
in a partition-tolerant manner. We achieve this by utilizing
IOTA smart contract platform. This methodology inherently
integrates, as well, byzantine-tolerant processes. In addition,
we propose a novel architecture to integrate IOTA’s two-layer
structure with ROS 2.To the best of our knowledge, this is the
ﬁrst approach to integrate IOTA’s smart contracts with ROS 2
to leverage DLT in multi-robot systems. We chose a distributed
collaborative mapping task to demonstrate how the proposed
methodology can be applied on top of our architecture. The
distributed collaborative mapping task is simulated in larger-
scale in Gazebo as well as with a real-world experiment. The
implementations are open-source as the ﬁrst integration of
ROS 2 with IOTA’s smart contract.

In summary, the main contributions of this work are the

following:

(i) the ﬁrst general methodology for DLT-based robotic
applications
collective
to achieve partition-tolerant
decision-making, which also inherits byzantine tolerance
from the blockchain,

(ii) an architectural design for integrating IOTA and ROS 2

for distributed multi-robot systems, and

(iii) a demonstration of the applicability of the proposed
methodology and architecture for a multi-robot collab-
orative mapping application.

The rest of the paper is organized as follows. Section II
introduces previous research in the collective decision-making
problems and the use of distributed ledger technologies for
robotic systems and introduces the key concepts behind smart
contracts in both Ethereum and IOTA. Then, in Section IV we
describe the methodology to make partition-tolerant decision-
making protocols and how to design approaches for integrating
IOTA and ROS 2 into the same framework. A partition-tolerant
fault-tolerant distributed collaborative mapping algorithm is
shown in Section V, with a comparison between Ethereum and
IOTA. A discussion on scalability and future potential appears
in Section VI. Finally, Section VII concludes the work and lays
out the directions for future work.

II. RELATED WORKS

This section brieﬂy reviews the literature in robot cyberse-
curity, and the potential of blockchain and other distributed

2

ledger technologies for securing and building trust in robot
swarms.

Multiple research efforts have been directed towards se-
curing robotic systems. For example, in [15], Clark et al.
study security threats on robots at the hardware, ﬁrmware,
and application layer and lists possible attacks from spooﬁng
sensor data to denial of service attacks. In [16], the focus
is on the impact of the security attacks and suggests some
countermeasures. In another work, Higgins et al. look at both
robotics and security perspectives [17]. In this study, the the
authors compare swarm robotics use cases to similar tech-
nologies in order to ﬁnd the unique features making similar
security measurements unfeasible or ineffective. In general,
the security of swarm robotics is very crucial in defence,
healthcare, environmental, and commercial applications [18].
Collective decision-making is an essential element in swarm
robotics and have studied extensively. In these studies, all
robots in the swarm are assumed to be honest and protocol
obedient [19]. But a single intruder robot can easily affect
the entire system’s decision-making. For this reason, recent
studies have also taken into account probable faulty robots
to make their approach resilient against them. Sargeant and
Tomlinson [20] give a generic swarm model and how a mali-
cious intruder can be modeled in this context. In [21], Zikratov
et al. propose a dynamic trust management framework that
enables robots in an ad-hoc network to detect a compromised
device and an access control unit that expects newly joined
members to behave honestly up to a certain time to participate
in decision-making tasks. For multi-robot systems with time-
varying communication graphs dealing with malicious parties
is more challenging. In [22], a consensus approach is pro-
posed, resilient if communication graphs reunite in a bounded
time period. The method proposed in this work, is a more
general approach to solve this kind of issues.

Despite the recent research efforts to design and develop
decision-making methods that are fault-tolerant, the literature
contains mainly specialized approaches for speciﬁc use cases
or applications scenarios. To the best of our knowledge, there
is a lack of a generic and scalable collaborative decision-
making framework for distributed robotic systems. Within this
domain, an early work by Castell´o Ferrer pointed at the appli-
cability of blockchain technologies in swarm robotics [23].
The study discusses how this technology beneﬁts security,
distributed decision-making, and new business models in
robotics. The work also points out that applying blockchain
to resource constraint devices (e.g., mobile robots) can be
challenging. However, blockchain technology is still presented
as the potential infrastructure to ensure security and safety
regulations for robotics. In a more recent work, Afanasyev
et al. list open issues in combining blockchain and robotics
and certain application scenarios [24]. One of the beneﬁts of
blockchain technology is that robots can be assigned speciﬁc
tasks through smart contracts. In our study, we present smart
contracts as the backbone of collaborative decision-making.
A proof of concept showcasing blockchain in robotic swarms
was demonstrated by Strobel et al. in [12]. In the experiments
in [12], Robots in a swarm collaboratively reach an agreement
on the most common tile color in an environment with white

and black tiles. As opposed to conventional methods, the pro-
posed blockchain-based solution on Ethereum [25] can tolerate
malicious behavior. Another example of collective decision-
making in swarm robotics in [13] presents an in-depth study
of following-the-leader problems. In swarm robotics literature,
Ethereum is the most commonly used blockchain platform.
However, it comes with limitations in terms of scalability
and deployment in embedded systems. Other platforms have
emerged that potentially solve some of these issues, such as
Hyperledger Fabric [26] and IOTA [27]. These have already
been explored in some works, albeit more limited experiments
have been demonstrated [28], [14], [29].

From a system design perspective, blockchain technology
brings beneﬁts in terms of immutability of past data, and
distributed decision making, among others. However, it also
brings new challenges. In most existing use cases, blockchains
are deployed between nodes (e.g., computers or servers) with
a stable network connection. This assumption, nonetheless,
does not necessarily hold when operating swarms of mobile
robots. To address the issue of potentially intermittent con-
nectivity, Tran et al. proposed SwarmDAG [30]. SwarmDAG
is a system-level design based on directed acyclic graphs
(DAGs) that incorporates a membership management system
to handle new members. Early solutions like SwarmDAG,
however, become vulnerable to security issues that traditional
blockchains already solve (e.g., Sybil attacks). Next-generation
blockchain systems that are intrinsically based on DAGs, such
as IOTA, are able to provide both scalability and security.
For example, a surveillance system is presented in [14] that
also tolerates partitioning within the network while main-
taining secure consensus with IOTA. The research in [14]
was carried out before smart contracts were developed for
IOTA. The IOTA foundation has now introduced IOTA smart
contracts that run on chains over the core DAG structure. The
technology is therefore now ready for more complex designs
and the integration of distributed decision-making processes,
taking advantage of smart contracts and asynchronous calls
in IOTA. Compared to the state-of-the-art in blockchain-based
robotic systems, we propose in this paper a novel approach
with a general methodology for making virtually any decision-
making problem in a distributed and partition-tolerant manner,
given that it can be implemented as a smart contract with
a series of constraints. This allows for byzantine-tolerant
consensus in multi-robot systems and robot swarms without
strong connectivity requirements. At the same time, this solu-
tion achieves higher degrees of scalability when compared to
traditional blockchains that form the vast majority of the work
to date in DLTs within the robotics ﬁeld.

III. BACKGROUND
Blockchain systems, a subset of the wider domain of DLTs,
have grown in popularity over the past few years, partly owing
to the public interest around cryptocurrencies. Bitcoin [31]
was the ﬁrst cryptocurrency that removed the trust on a third
party to conduct a transaction between two entities. Although
ﬁnancial transactions were the initial objective, blockchains
can be used in a variety of use cases. In addition to en-
abling distributed decision-making, as we discussed earlier,

3

Fig. 2: Illustration of (a) a traditional blockchain, (b) the IOTA
Tangle, and (c) the two-layer ISCP architecture where we highlight
two possible chains anchored to different Table nodes.

blockchains also serve as a tamper-proof log. Blockchain
technology has been used in some robotics research just for
logging purposes to have a reliable history of events [32].
Smart contracts, which are computer programs automatically
executed when a set of conditions is fulﬁlled, have opened
up new possibilities for distributed applications (DApps). In
the following, we describe the key concepts behind the more
traditional Ethereum blockchain and the DAG-based IOTA
architecture. These different design approaches are illustrated
in Fig. 2.

Ethereum: Ethereum made a signiﬁcant impact on dis-
tributed ledger technologies by introducing Turing-complete
smart contracts. Solidity is Ethereum’s programming lan-
guage exclusively designed for coding smart contracts. A
Turing-complete smart contract has enabled Ethereum to be
widely adopted in a wide range of domains. Researchers
have also exploited Ethereum’s capabilities within multi-robot
systems [12]. While Ethereum introduced new possibilities
to blockchain systems, it still uses the classical single-chain
structure. Therefore, the intrinsic scalability problem remains.
In addition to scalability issues, and considering the perspec-
tive of the design of multi-robot systems, tolerating network
partitioning is imperative for real-world deployments in many
application scenarios. The Ethereum foundation is working on
Ethereum 2.0, which is posed to resolve many of the current
scalability issues by leveraging sharding (a new approach to
achieving consensus within subsets of the global network);
however, the solutions are not matured yet.

Tangle (IOTA): The Tangle, a DAG-based DLT, was
to solve some of the underlying
introduced by S. Popov.
deﬁciencies in classic blockchain systems [27]. The Tangle
is the underlying structure used by the IOTA DLT. Most of
the blockchain systems to date use blocks encapsulating a
set of transactions as their primary data structure. These data
blocks are then usually connected as a linked list by using the
hash of each block as the linking element between consecutive
entries in the list. In the Tangle, transactions themselves are
the primary data structures. Using individual transactions as
the primary data structure enables even nodes with limited

(a)(b)(c)resources to participate in the consensus. The DAG structure
is then generated as each transaction must refer to two previous
unconﬁrmed transactions based on the view of the Tangle that
the node that issues it has. The core idea behind the Tangle is
that keeping the ledger on a graph rather than a single (linear)
chain would allow for a certain level of ﬂexibility in terms of
network partitioning. This makes IOTA, a priori, an excellent
DLT solution for multi-robot systems [30], [14].

Shimmer (IOTA 2.0): The ﬁrst version of IOTA focused
on making the graph-based data structure functional while pre-
serving the security standards of most DLT solutions. In this
version, only basic transactions were possible (e.g., ﬁnancial
transactions, such as a exchange of tokens, or data publishing
for IoT devices). To keep the Tangle stable and secure, a
centralized Coordinator managed by the IOTA Foundation
was in charge of conﬁrming valid transactions. To achieve
full decentralization,
the IOTA Foundation redesigned the
Tangle and launched Shimmer as the second version of IOTA.
GoShimmer is the Go implementation of Shimmer clients,
which will be used in this work.

Wasp (IOTA Smart Contracts): Due to the graph-based
data structure in the Tangle, embedding a smart contract
mechanism in IOTA was a bigger challenge than in traditional
blockchain. In general terms, smart contracts are made possi-
ble in a blockchain through a state machine that has a state that
can be altered by entering a new block. Such state machine
requires a global state and is therefore not directly embeddable
within the Tangle. To solve this issue, the IOTA Foundation
uses the Tangle as a ﬁrst layer, on top of which they introduce
the IOTA Smart Contract Platform (ISCP) as a second layer.
Wasp refers to the Go implementation of the ISCP client.
ISCP clients or Wasp nodes can create a chain in this second
layer. Each of these chains can be compared to an Ethereum
blockchain, in this case having every block anchored to the
ﬁrst layer. Other Wasp nodes can join the chain, and all the
Wasp nodes participating in a chain form a chain committee.
Similar to an Ethereum blockchain, committee members can
run smart contracts in the chains they belong to. Each chain
committee has a ﬁnite number of members, meaning they
can run a byzantine fault tolerant (BFT) algorithm to reach
consensus. BFT consensus algorithms can tolerate at most one-
third of byzantine members. It is possible to make virtually
any number of chains on top of the ﬁrst layer with different
committees. In addition, these chains can interact with each
other, referred to as asynchronous calls in ISCP. Asynchronous
calls enable smart contracts to call a method of another smart
contract
is worth mentioning that,
while global connectivity is not required at all times within
the Tangle, running a smart contract requires consensus to be
reached by members of the corresponding Wasp committee.
Therefore, at least two-thirds of the nodes participating in a
chain need to be in a common network partition when chain
blocks are committed. This requirement does not extend to two
chains interacting through asynchronous calls except when the
calls occur.

in a different chain. It

Robotics Middleware: the Robot Operating System (ROS)
is the de-facto standard in today’s autonomous robots [33].
From the perspective of multi-robot systems and distributed

4

networked systems, the original ROS 1 version has certain
limitations, mainly due to the existence of a certain node
managing the interaction between the different actors in the
system. The new ROS 2 version solves this with the introduc-
tion of the data distribution service (DDS) standard for the
lower-level communication middleware. DDS also provides
a security extension empowering ROS 2 itself. Only ROS 2
is a natural selection for integration with distributed ledger
technologies. In addition to the DLT platform in use, the
distributed communication and security that DDS enable are
crucial features for a secure and trustable system. This work
does not aim at replacing those features, but instead compli-
menting them with an additional channel for building trust and
implementing collaborative decision-making processes. ROS 2
already provides tools for data encryption and data access
control.

In summary, to address the network partitioning problem
in multi-robot systems, and enable dynamic network topolo-
gies, IOTA is a promising solution. This has already been
showcased with a proof of concept
in the literature [14],
however, with the lack of smart contracts for more complex
integrations. With an IOTA-based system, disconnected robots
or separate groups of robots can still operate on the same
global Tangle, with the corresponding transactions in separate
subgraphs that are merged whenever global connectivity is
regained. With the introduction of ISCP and the asynchronous
calls, in addition to this, we can also design systems that
run distributed applications inherently able to tolerate network
partitioning. In this paper, we propose a general approach for
making distributed, partition-tolerant decision-making tasks
through IOTA smart contracts. We design such approach to
be integrated with ROS 2 in a seamless way. This integration
is two-directional, with ROS 2 feeding data to the IOTA Tangle
and IOTA smart contracts being used to implement function-
ality that replaces distributed ROS 2 nodes. In particular, we
exploit the asynchronous calls for connecting chains that live
in different network partitions.

IV. METHODOLOGY

This section covers the overall system design, including
how robots operate with the two-layered IOTA architecture
and how IOTA is bridged with ROS 2. The section focuses
on how smart contracts are designed and deployed to allow
for network partitions and intermittent connectivity while
maintaining global consensus at the end of a distributed multi-
robot mission.

A. Problem Deﬁnition

Collaborative decision-making processes in multi robot sys-
tems often refer to any method that requires the combination
of input, or data, from different robots and processes the
data or makes a decision based on it in a decentralized man-
ner. Examples include distributed role allocation algorithms,
distributed perception, cooperative mapping, or decentralized
formation control, among others. We assume in all cases that
robots operate as individual entities and that the decision-
making process is not governed by a central authority. These

5

Fig. 3: Illustration of the integration of ROS 2 with the IOTA tangle (layer 1) and IOTA smart contracts (layer 2) enabling secure, distributed
and partition-tolerant decision-making. The main network partition, represented in black, includes the core CONTROLLER SWARM chain as
well as other nodes with global connectivity. In orange and blue we illustrate two examples of transactions (both layer-1 and layer-2 chains)
related to mobile robots that have intermittent connectivity and thus create their own network partitions. These partitions can also be formed
by groups of robots that remain locally connected but globally disconnected to the rest of the network. Both layer-1 and layer-2 nodes are
bridged to ROS 2, with layer-1 nodes being passive listeners that dump ROS 2 data to the tangle. Layer-2 nodes have full bi-directional
communication between IOTA and ROS 2 and implement the integration interface.

processes are used to achieve agreement and specialization
in multi-robot systems [5]. In this work, we focus only on
reaching agreements on a series or variables, often referred to
as consensus problems.

The core objective of this work is to provide a framework
for collaborative decision-making in a multi-robot system
based on IOTA. To this end, we integrate IOTA smart contracts
with ROS 2 nodes, in a way that data fed to IOTA from ROS 2
is processed within smart contracts. The results of such process
are then fed back to ROS 2 topics, even though ROS services
or actions could also be implemented in the future. To achieve
this goal, this section covers the ﬁrst two contributions of our
work:

i. First, we introduce a methodology and architecture for
integrating IOTA with ROS 2 nodes. We explain how
ROS 2 data and processes can be either be part of the
IOTA Tangle or be implemented as smart contracts in
IOTA’s second layer.

ii. Second, we propose an strategy for enabling partition-
tolerant decision-making through the combination of mul-
tiple smart contracts in different chains, each existing in
its own network partition within the Tangle.

In addition to introducing this approach, our experimental
results reported in the next section focus on a proof of concept
of the proposed methodology with a cooperative mapping use
case, covering the third contribution of our work.

B. System Architecture: Integrating IOTA and ROS 2

To leverage IOTA’s smart contracts in the multi-robot sys-
tems, we propose an integration of ROS 2 with the two-layer
IOTA architecture illustrated in Fig. 3 as described in the
following:

Goshimmer network: Designed for lightweight IoT nodes,
every robot in the system can run a shimmer node. A cloud
ﬂeet management system, or ﬁxed sensors and infrastructure
with connectivity can also be part of the Goshimmer network.
In fact, the more nodes that participate in the network, the
more secure that IOTA’s Tangle is. Therefore, and within the
system performance limits, the Goshimmer network is a good
place to publish higher frequency transactions (e.g., raw sensor
data from the robots that can be also used for validation in
different processes later on).

Goshimmer nodes running in the robots are thus also ROS 2
listeners, i.e., they subscribe to a topic and re-publish the data
in the Tangle. The nodes can also be conﬁgured to publish
data from the Tanble (e.g., metadata from other transactions,
data about the Tangle topology, or even the node’s own real-
time performance data). To implement this, we integrate the
Goshimmer library with rclgo, the ROS 2 client library for Go.
Publishing ROS 2 messages on the Tangle would generate a
tamper-proof log of events.

Wasp committees: Running a Wasp node on every robot
in the system is unnecessary; instead, we propose to run Wasp
nodes on the robots with higher processing power or the cloud
ﬂeet management system. In order to maintain security, Wasp
nodes must be distributed evenly throughout the system. We

propose that at least 3f + 1 robots with higher processing
power run a Wasp node in each subgroup of robots that might
have intermittent connectivity to tolerate f malicious robot.
Every Wasp node should be connected to a Goshimmer node to
interact with L1. Since we proposed to run a Goshimmer node
on every robot, a Wasp node should connect to the Goshimmer
node running on the same robot.

According to applications running on the multi-robot sys-
tem, Wasp nodes should create chains and form committees.
All the robots working on an application can operate on a
single chain in case they don’t use interchain asynchronous
calls. If the application utilizes interchain asynchronous calls,
Wasp nodes should be distributed on the different chains
accordingly.

ROS 2 bridge: We have implemented a ROS 2 listener
node with rclgo that subscribes to a topic and forwards these
messages or hash of the messages to Goshimmer nodes.
Goshimmer nodes will use these data to create new trans-
actions in order to keep the network alive. Keeping these
messages on the ledger will provide a complete log of events
in multi-robot systems. In addition to a ROS 2 listener node,
a ROS 2 talker node can be implemented to read on-ledger
transactions and publish them for log reviewing and validating
processes.

For Wasp nodes, a similar approach is utilized to interact
with ROS 2. A Go script is utilized to call methods of smart
contracts and also retrieve the results from it. This script
consists of a ROS 2 subscriber which listens on a topic to
receive the command to call a method from a smart contract
on the chain speciﬁed with ChainID. If the method has a
returning value, the script will retrieve the value and publish
it on a predeﬁned topic. Also, ROS 2 actions could be a better
alternative instead of using a listener and talker topics.

Figure. 3 illustrates part of the Tangle and the Wasp chain
blocks anchored to the Tangle. In the ﬁgure, time increases
from left to right. Empty squares show L1 transactions created
by Goshimmer nodes. In each transaction, the header includes
the hash of two referred transactions and a metadata part. This
metadata can be dumped ROS 2 messages or the anchored
state of a chain. Filled squares inside an empty square shows
a block of the L2 chain created by the Wasp committee.
Three chains are shown in this ﬁgure, colored blue, orange,
and black, with only one smart contract deployed on each
chain. Methods called from each smart contract are depicted
in squares connected by arrows to the block where this call
happened. For example, the submitV ote method from the
orange chain is called twice, and later transf erV otes method
is called. These method calls are also through the IOTA-ROS2
bridge.

C. Partition-Tolerant Collaborative Decision Making

As we have described earlier, current solutions that leverage
DLTs in robotics are not able to deal with network partitions.
Indeed, if two robots are meant to share data regularly on
a blockchain, but they remain disconnected for part of the
data gathering process, a problem raises in terms of how
can the individual chains be merged. We discuss here how

6

asynchronous calls in the ISCP can solve this issue. Our
objective is to enable multiple robots to achieve consensus in
terms of global mission parameters or variables (e.g., a shared
map or a bijective role allocation), while maintaining local
consensus within their internal systems or local subnetwork.

pragma solidity ˆ0.8.7;

contract MainContract {

VOTE[] votes;

function submitVote (VOTE memory vote) {

// Some code goes here
votes.push(vote);
// Rest of the code goes here

}

function aggregate () returns result {

// Implementation goes here
return result;

}

}

Listing 1: General smart contract deﬁnition (Ethereum’s
Solidity) for a collaborative decision making implementation.

Collaborative decision-making processes can be typically
implemented on a smart contract following the example in
Listing. 1. This example, for the Ethereum blockchain, has
been followed by different works in the liteature. The col-
laborative decision-making process then proceeds as follows.
Every entity that is participating in the task has a vote. These
votes could be any type of data based on the goal they are
going to achieve. Every participant can submit their vote with
the submitV ote function of the smart contract. aggregate is
a view function (only reads data from the ledger and doesn’t
change anything) used for aggregating the votes to get the ﬁnal
result of consensus.

Such collaborative decision making processes which can be
formulated as a smart contract similar to the general form men-
tioned above can become partition tolerant. Partition tolerance
is achieved by the multiple chains introduced by ISCP. In order
to make a smart contract partition tolerance, we propose that
it should be divided into two separate smart contracts. First, a
CONTROLLER SWARM smart contract should be deployed on
the CONTROLLER chain. Second, every group of robots that
may at some point be disconnected from the core network for
a certain amount of time should create their own chain and
deploy a new instance of an AGENT SWARM smart contract
on the chain.

The AGENT SWARM contract is responsible to store the
votes on the ledger, so that
they are saved in case that
these robots disconnect from the rest of the network through
the submitV ote function. In addition,
this smart contract
provides the transf erV otes function that can be called by
any member on this chain to transfer the stored votes to the
CONTROLLER chain. This function uses an asynchronous call
to the submitV otes function of CONTROLLER SWARM smart
contract. The CONTROLLER SWARM contract implements the
aggregator function that aggregates all the votes from the dif-
ferent chains. These smart contracts are illustrated in Listing. 2
and Listing. 3.

name: ControllerSwarm
structs:
VOTE:

# Data structure of votes goes here

state:

votes: VOTE[]
# Other state variables goes here

funcs:

submitVotes:
params:

votes: VOTE[]

aggregate:
results:

result: RESULT

# Other functions may be also defined here

Listing 2: ControllerSwarm smart contract schema.

name: AgentSwarm
structs:
VOTE:

# Data structure of votes goes here

state:

votes: VOTE[]
# Other state variables goes here

funcs:

submitVote:
params:

vote: VOTE
transferVotes: {}
# Other functions may also be defined here

Listing 3: AGENT SWARM smart contract schema.

D. Eventual Consistency

in this case,

Based on Brewer’s CAP conjecture for a distributed sys-
tem [34], we cannot achieve consistency, availability, and
partition tolerance simultaneously. As It is proposed to make
the collaborative decision making tasks partition tolerant in a
distributed manner, the consistency will not be acquired any-
more. As mentioned in the previous section, the submitV otes
function of the AGENT SWARM smart contract is called when
the chain members are again connected to the rest of the
network. Therefore,
the system has eventual
consistency. Every group of swarms on a chain can be
disconnected for a while, but when they are connected to
the CONTROLLER chain, the system will reach an eventual
consistency. This assumption does not lead to any degradation
of the functionality of the robotic system. Indeed, if a robot or
group of robots remains disconnected from the CONTROLLER
chain, then they can maintain operation within the ledgers
deﬁned in their own network partition, unrelated to the rest of
the system. If the disconnection is a result of a malfunction,
then it is out of the scope of this work to provide connectivity
maintenance or recovery methods, with the robotics literature
containing solutions to such challenges.

To achieve more robust multi-robot systems using DLTs,
it is worthy to prefer partition tolerance over consistency.
However it is possible to have eventual consistency that is
sufﬁcient in many scenarios. If we want to choose consistency,
then we might loose some part of the data. In next section, we
will demonstrate a scenario that loosing data how can affect
the overall decision making problem.

7

V. EXPERIMENTAL RESULTS

In this section, we focus on a speciﬁc proof of concept
to demonstrate the usability and applicability of the proposed
methods. The vast majority of indoor mobile robots today use
2D lidars for navigation and mapping, with mapping being
a key step for a robot to achieve situational awareness. We
choose cooperative mapping as a representative task involving
consensus (agreement on the ﬁnal map of the operational
environment) and the aggregation of data from different robots
(the individual maps). This task includes role allocation,
and agreement between the entities. At the same time, the
individual maps can be checked against the real-time sensor
data published in the Tangle. Finally, collaborative mapping
is an excellent example of a consensus problem requiring a
partition-toleran implementation for real-world applications.
The network partitioning is highly probable due to undis-
covered heterogeneous environments. Also, byzantine entities
might alter the collaboratively created map to exclude some
areas to be navigated, or even expose other robots to real
hazards by altering their local maps. In summary, we choose
a simple and intuitive approach for collaborative mapping to
demonstrate the method proposed in the previous section.

l×w

Algorithm 1: Compare two maps
Input: Ml×w, M (cid:48)
Output: T rue or F alse
comply ← T rue;
T ← 0.2;
T (cid:48) ← 0.2;
foreach Wn×n in Ml×w do

foreach W (cid:48)

n×n in M (cid:48)
S ← {wi×j = w(cid:48)
D ← {wi×j (cid:54)= w(cid:48)
U ← {wi×j = U };
U(cid:48) ← {w(cid:48)
i×j = U };
|U|
n2 < T ∧
comply ← F alse

if

l×w do
i×j, wi×j (cid:54)= U };
i×j, wi×j (cid:54)= U, w(cid:48)

i×j (cid:54)= U };

|U(cid:48)|
n2 < T ∧

|D|
|D|+|S|

> T (cid:48) then

return comply

A. Partition-Tolerant Collaborative Mapping

For the collaborative mapping application, we consider a
rectangular area to be mapped. We assume that the rectangle
has a known size of L × W . We also assume that there are
multiple robots that are going to participate in this task as a
service. The area is divided into l × w sized cells. The cells
are considered to be small enough so that the topology does
not change signiﬁcantly from different viewpoints, and so that
a single lidar scan is enough for mapping the cell. Each cell
should be visited by k ≥ 3f + 1 robots, such that at most f
out of them are byzantine.

First, robots should register their identity to take part in the
mapping task. Second, each robot is assigned to a randomly
selected cell in the area. Third, the robot travels to the assigned
cell to map it. Fourth, the robot submits the built map to the

8

Fig. 4: Integration of ROS 2 and IOTA smart contract for the cooperative mapping application use case.

Algorithm 2: Smart contract map submission
Input: Ml×w
Data: M List of submitted maps
complies ← 0;
contracts ← 0;
foreach M (cid:48)

l×w in M do

comply ← compare (Ml×w, M (cid:48)
if comply then

l×w);

complies ← complies + 1;
complied(M (cid:48)

l×w) ← complied(M (cid:48)

l×w) + 1;

else

contracts ← contracts + 1;
contracted(M (cid:48)

l×w) ← contracted(M (cid:48)

l×w) + 1;

complied(Ml×w) ← complies;
contracted(Ml×w) ← contracts;
M.append(Ml×w);

Algorithm 3: Smart contract merge function
Data: M List of submitted maps
global map ← ∅;
foreach Ml×w in M do
if complied(M (cid:48)

agent(Ml×w) ← byzantine;

l×w) < contracted(Ml×w) then

if agent(Ml×w) is not byzantine then

global map.append(Ml×w);

return global map;

smart contract. The smart contract based on the received map
merges them.

We deﬁne every local map as a 2D matrix of size Ml×w.
The resolution for creating the map is a ﬁxed and predeﬁned
value. Every entry of the matrix is ﬁlled by the robot with out
of three values ({O, F, U }) representing occupied, free, and
unknown, respectively.

To implement this partition-tolerant collaborative mapping
on a smart contract, we deﬁne ﬁve main functions. First, a
role allocation function to assign a random cell to each robot
which is going to participate in the inspection. This function
is responsible to assign each cell for at least k ≥ 3f + 1
robots to tolerate f byzantine robot. Second, a function that is
responsible of comparing two maps as deﬁned in Algorithm 1.
This function will return a true or false value indicating where
the two input maps are complying (true) or conﬂicting (false).
This comparison function will then be used in the submission
function. The third function is the submission function, deﬁned
in Algorithm 2. For every new map that is submitted to the
smart contract, it is compared to the all previous submitted
ones. For each map, two values are stored. The comply() value
of the map, representing the number of maps complying with
this map, and the conf lict(), deﬁned in the same way for the
number of maps with which it conﬂits.

The ﬁfth function, namely map merging,

is deﬁned in
Algorithm 3. The merging function is responsible for merging
the maps. In this context, merging is the aggregate function
of the general smart contract deﬁned in the previous section.
Equivalently, the generic votes deﬁned earlier are now maps
in this application, and the generic submitV ote function is
implemented through the map submission function.

Inspector Robot 31Inspector Robot 2Inspector Robot 1Inspector Robot 7 ( Byzantine)Inspector Robot 6Inspector Robot 5Wasp ClientGoShimmerClientInspector Robot 0 (Byzantine)ros_rplidarcartographerpath_planneranomaly_injectROS2 NodesInspector Robot 4Wasp ClientGoShimmerClientros_rplidarcartographerpath_plannerROS2 NodesSwarm Operator / Cloud InterfaceWasp ClientGoShimmerClientRobot Trajectories GeneratorROS2 NodesCharging Station NetworkWasp ClientGoShimmerClientmerged_map_publisherROS2 Nodes9

Fig. 5: Mapping results in the Gazebo simulation where eight robots map a small town. The dark blue lines represent the lidar scan range
for each of the robots; the robot paths are omitted to improve visualization. Each individual map is generated by the robots locally using
cartographer. The ﬁnal map obtained through the IOTA smart contracts is shown in the bottom left, where the anomalies detected in the data
submitted by two of the robots have been effectively eliminated.

B. Multi-Robot Gazebo Simulation

town-like environment

For the purpose of testing the proposed partition-tolerant
collaborative mapping task with a larger number of robots,
is designed in the Gazebo
a small
simulator. The simulation environment is shown in Fig. 5.
Eight robots are deployed in the simulator to map the town.
We set two of these robots as byzantine agents. Their objective
is to try to fool other robots by inserting certain random walls
on their local town maps. Each robot scans the surrounding
environment with a 2D lidar while navigating the town on a
predeﬁned path. The output of the 2D lidar and the odometry
data generated by Gazebo simulator are used for mapping
using the Cartographer ROS 2 implementation [35]. A ROS 2
node is implemented in order to emulate the behavior of
byzantine agents. The ﬁnal local maps (either directly the
output of the Cartographer node or the altered maps generated
by the nodes running in the byzantine agents) are submitted
by robots to the Controller Swarm smart contract. The maps
that are submitted by each robot are shown in Fig. 5, each
covering a different area of the town and with the lack of a
global view. After inspecting the assigned cell, the robot will
submit its map to the smart contract. Another ROS 2 node is
implemented to call the merge function of the smart contract
and publish the results on a ROS 2 topic. The merged map
in different stages is illustrated in Fig. 6. In this experiment
Robot 0 and Robot 7 are byzantine robots. The maps submitted

by these robots are eliminated in the overall merged map when
enough data is available about the sections where byzantine
agents alter the real maps. It is worth noting at this point
that inserted data may temporarily appear in the merged map
until a high enough number of robots submit a map that
conﬂicts with the map submitted by the byzantine robot. For a
speciﬁc application and collaborative decision-making process
implementation, a byzantine behaviour can be potentially
designed in an adversarial manner to surpass the detection
mechanisms in the smart contract. However, our focus here
is not on deﬁning a robust byzantine agent detection strategy
bus instead on introducing a general way of building trust with
IOTA through a partition-tolerant implementation. Therefore,
more advanced smart contracts speciﬁcally designed to detect
altered data are out of the scope of this work.

The simulation results show that our method effectively en-
ables both byzantine-tolerant and partition-tolerant collabora-
tive mapping under certain conditions. Through the simulation,
we effectively emulate network disconnections as robots only
submit their local maps once their path is ﬁnalized. In this
implementation, each robot individually forms its own Wasp
committee. In practice, several robots operating in nearby cells
can form a common Wasp committee.

C. Real-World Experiment

For real-world experiments we used a Dashgo indoor UGV
with an RPLIDAR A1 installed on top of it. For localization,

10

Fig. 6: Illustration of the map merging process as different robots submit their local maps in time. Once Robot 0 and Robot 1 have submitted
their maps to the smart contract, the overall map is updated as these two maps are not conﬂicting. The process continues with other local maps,
with anomalies being effectively eliminated once enough data is available about the corresponding map cells. An alternative implementation
might wait for a certain number of robots to submit their maps before merging the data, without changing the core processes.

)
s
d
n
o
c
e
s
(

e
m
T

i

n
o
i
t
u
c
e
x
E

2

1.5

1

0.5

0

R0

R1

R6

R7

R2

R3

R4

R5

Fig. 7: Execution time of SubmitV otes method of CONTROLLER
SWARM smart contract for each robot. The simulation environment
is divided in four cells or quadrants. Each robot navigates mainly
through two of the quadrants of the map and submits two separate
maps. The four bar colors in the graph represent these four cells.
Every map submitted is compared on a cell-by-cell basis only when
there is an intersection between maps.

we rely on an Optitrack MOCAP system providing global,
real-time, 6D pose estimation through ROS 2 topics. We create
a small maze to be navigated by robots. For the sake of
simplicity, we map different areas of the maze iteratively,
adding or removing physical elements in between to emulate
altered sensor data. The maze and the Dashgo UGV assembly
can be seen in Fig. 8. In practice, the same robot is operated

Fig. 8: Portion of the maze created for the mapping experiments. The
Dashgo UGV is also seen in the image.

four times to create the data for four different virtual agents.
This is done without loss of generality from the perspective of
the methods introduced in this paper. Four different GoShim-
mer and Wasp nodes are deployed in two sub-networks to
demonstrate the partition tolerance of the methods, with these
sub-networks simulating network disconnections. These nodes
are deployed on an UP Squared board placed on top of the
Dashgo UGV. Also, an UP Xtreme board is used to play the
role of charging station with its own GoShimmer and Wasp
nodes. The hardware speciﬁcations of these boards are listed in
Table. I. In this experiment, Robot 3 will simulate the network

(a) Robot 0(b) Robot 1(c) Robot 6(d) Robot 7(e) Robot 2(f) Robot 3(g) Robot 4(h) Robot 511

Fig. 9: Real-world maps merged by IOTA and Ethereum smart contracts.

TABLE I: Hardware Speciﬁcations of UP Squared and Xtreme
boards used for real-world experiments.

UP Squared

Up Xtreme

CPU
Mem / Disk

Intel Atom x7-E3950
8 GB / 64 GB

Intel Core i7-8665UE
16 GB / 64 GB

TABLE II: CPU and memory consumption of GoShimmer
nodes on UP Squared and Xtreme boards

UP Squared Up Xtreme

GoShimmer avg. CPU
GoShimmer avg. MEM)

25.85%
213.65 MB

20.16%
228.8 MB

disconnection. GoShimmer and Wasp nodes associated to
Robot 3 are deployed on a Docker network. The Robot 3 Wasp
node will create a chain and deploy the AGENT SWARM
smart contract. Other GoShimmer and Wasp nodes will use
another Docker network with a chain which another instance
of AGENT SWARM smart contract is deployed on. GoShimmer
and Wasp nodes of the charging station also has their own
Docker network and CONTROLLER SWARM smart contract
deployed on a chain. These Docker networks communicate
through an Docker overlay network. The White box in Fig. 8
is inserted as an anomaly while Robot 1 is navigating, which
corresponds to the byzantine robot mapping the area.

The raw lidar scan is published by GoShimmer nodes on the
Tangle. ROS 2 LaserScan messages, which are approximately
1.5 KB each, are published with a 5.5 Hz rate. The CPU and
memory consumption of every board is reported in Table. II.
The map created by each robot is illustrated in Fig. 9.

To see the difference between IOTA and Ethereum and how

partition-tolerance can beneﬁt this mapping process, the maps
are submitted to smart contracts deployed on both Ethereum
and IOTA networks. The map merging result of the Ethereum
and IOTA smart contracts are illustrated in Fig. 9. In the
merged map generated through the Ethereum smart contract
we can observe that the map submitted by the robot which was
in different sub-network was eliminated. This is effectively
caused because only one of the two chains created when robots
are disconnected remains at the end of the mission (Ethereum
discards the shortest chain, also deﬁned as the chain with
the lowest accumulated computational complexity). With the
IOTA-based implementation, this part of the map is included
and the anomaly wall effectively removed at the same time.

These results demonstrate the following. First, the IOTA-
based implementation is superior to more traditional Ethereum
implementation in terms of supporting network partitions. In
practice, this means that whenever robots disconnect in the
real world, their data is not necessarily lost. We quantify this
with the percentage of mapped area that results from IOTA
and Ethereum smart contracts and listed in Table III. IOTA
smart contracts achieve higher percentage of mapped area than
Ethereum smart contracts and even the union of robot maps
by masking the anomalies.

With the vast majority of the literature in DLT integrations
for robotics relying on traditional blockchains, this work solves
one of the key practical problems stopping more widespread
use of this technology. Second, the IOTA-based implementa-
tion is effectively able to detect and neutralize the behaviour
from the byzantine agents. This is a novel results from the
point of view of the technology in use, albeit several works
in the literature showcase such ability in Ethereum-based
solutions. Nonetheless, this result also shows that the IOTA-
based methods maintain the functionality of existing research

)
s
m

(

e
m
T

i

20

15

10

5

0

12

11

)
s
(

e
m
T

i

10

SysTime TaskClock UserTime

TimeElapsed

(a) CPU utilization time of the SubmitV otes
method measured with the Linux perf tool.

(b) Conﬁrmation time for
the SubmitV otes method.

Fig. 10: Distribution of the execution and conﬁrmation time for the
SubmitV otes method of the CONTROLLER SWARM smart contract
for each robot over multiple experimental runs. The actual CPU
utilization time is in the range of a few ms, while the default IOTA
network conﬁguration results in conﬁrmation times slightly over 10 s.
TABLE III: Percentage of total area mapped by each individual
robot, and percentage of total area generated by the Ethereum
and IOTA smart contracts merging the individual maps.

Map generator Mapped area (%) Note

Robot 0
Robot 1
Robot 2
Robot 3

∪3
i=0Roboti
Ethereum SC
IOTA SC

77.78 %
65.55 %
83.95 %
76.39 %

94.64 %
82.2. %
95.50 %

Byzantine agent

Disconnected agent

Agents 0 + 2

Agents 0 + 2 + 3

while extending applicability. Finally, a third conclusion from
the reported results is that this work opens the door to more
scalable and wider use of DLTs within distributed robotic
systems. While this is not proved in this paper, the DAG-
based architecture of IOTA and the nature of its solutions with
respect to Ethereum and other traditional blockchains mean
that more scalable solutions for more resource-constrained
real-world devices can be designed and developed. It is worth
noting that the Ethereum community is also working, with
different methods, towards a more scalable DLT, and proof-of-
authority implementations already bring some beneﬁts, albeit
not the network partition tolerance we look for in this work.

VI. DISCUSSION

In addition to the results above, we measure the CPU
utilization time and the conﬁrmation time for one of the smart
contract methods. Figure 10 shows these results. The CPU
utilization time indicates the actual impact of the IOTA smart
contract in terms of resource utilization. Using the Linux perf
tool, we measure the execution time of the SubmitVotes method
of the CONTROLLER SWARM smart contract. Figure 10a
the typical execution time is in the range of
shows that
10 ms to 20 ms, revealing the potential for scalability and the

12

ability of running multiple smart contracts in parallel. The
use of DLTs and the decentralized consensus mechanisms in
them, however, introduces a certain delay until a transaction is
conﬁrmed. In practice, this means that the transaction, in this
case the result of a smart contract method, is conﬁrmed by
the nodes in the Wasp Committee. Even if the actual network
delay is small in the experiments, the default conﬁguration of
the IOTA research network introduces two delays of about 5 s
each to avoid double spending. This results in conﬁrmation
times over 10 s reported in Fig. 10b. If a faster solution is
required, the network conﬁguration can be changed to reduce
the conﬁrmation time, given that the maximum network delay
is known (e.g., within a single Wasp Committee that always
maintains local connectivity or within a committee of nodes
that uses wired connectivity, such as a network of charging
stations). It is worth noting that this is a research network
where functionality takes precedence over performance. In any
case, the approach proposed in this paper is already valid for
scenarios where consensus is not required in real-time but low
impact on the use of computational resources is preferred.

In summary, we can conclude that distributed ledger tech-
nologies (DLTs) have potential to bring new standards of
to large-scale robotic systems. Speciﬁc
security and trust
domains of interest include collaborative multi-robot systems
and swarm robotic systems.

In addition, we have manifested that porting decision-
making tasks on blockchain will not consume extra power
compared to usual robotic tasks such as mapping. Despite all
these beneﬁts, there is a series of challenges that can be the
objective of further investigation. First, there should be prior
knowledge about the possible network splits since the discon-
nected nodes should still operate on the same chain. Second,
this framework can only be applied if there are enough nodes
in the network to form different chains. A third challenge is
the limited capability of smart contracts in executing heavy
decision-making tasks like machine learning based solutions.
In future work, we are investigating how this kind of heavy
process can be executed off-ledger. Fourth, based on the
current implementations, we are working to report a thorough
analysis of the performance of Wasp and GoShimmer nodes
in robotic applications communicating with ROS 2. Finally,
we have noted that the current version of IOTA supporting
smart contracts is a research network where functionality
is sought out over performance. Theoretically, the network
design implies a more scalable solutions. However, there is
a limited amount of real-world deployments. In any case, our
experiments prove the effectiveness for many applications that
do not require fast consensus for the smart contracts within the
Wasp committees, but where data is already fed in real-time
to the GoShimmer layer.

VII. CONCLUSION

This paper proposes a framework for partition-tolerant
decision-making processes in multi-robot systems. Smart con-
tracts that incorporate the mentioned constraints are split into
two smart contracts on IOTA’s smart contract platform, which
tolerates network partitioning. Furthermore, we demonstrate

13

[14] M´ario Gabriel Santos de Campos, Caroline PC Chanel, Corentin
Chauffaut, and J´erˆome Lacan. Towards a blockchain-based multi-uav
surveillance system. Frontiers in Robotics and AI, 2021.

[15] G. W. Clark et al. Cybersecurity issues in robotics. In CogSIMA, 2017.
[16] Jean-Paul A Yaacoub, Hassan N Noura, Ola Salman, and Ali Chehab.
Robotics cyber security: Vulnerabilities, attacks, countermeasures, and
recommendations. International Journal of Information Security, 2021.
[17] Fiona Higgins, Allan Tomlinson, and Keith M Martin. Threats to
International

the swarm: Security considerations for swarm robotics.
Journal on Advances in Security, 2(2&3), 2009.

[18] Fiona Higgins, Allan Tomlinson, and Keith M Martin. Survey on
In 2009 Fifth International

security challenges for swarm robotics.
Conference on Autonomic and Autonomous Systems. IEEE, 2009.
[19] Alan G Millard, Jon Timmis, and Alan FT Winﬁeld. Towards exogenous
In Conference towards

fault detection in swarm robotic systems.
Autonomous Robotic Systems. Springer, 2013.

[20] Ian Sargeant and Allan Tomlinson. Modelling malicious entities in
In 2013 IEEE/AIAA 32nd Digital Avionics Systems

a robotic swarm.
Conference (DASC). IEEE, 2013.

[21] Igor Zikratov, Oleg Maslennikov, Ilya Lebedev, Aleksandr Ometov, and
Sergey Andreev. Dynamic trust management framework for robotic
In Internet of Things, Smart Spaces, and Next
multi-agent systems.
Generation Networks and Systems. Springer, 2016.

[22] David Saldana, Amanda Prorok, Shreyas Sundaram, Mario FM Campos,
and Vijay Kumar. Resilient consensus for time-varying networks of
dynamic agents. In American control conference. IEEE, 2017.

[23] Eduardo Castell´o Ferrer. The blockchain: a new framework for robotic
swarm systems. In Future technologies conference. Springer, 2018.
[24] Ilya Afanasyev, Alexander Kolotov, Ruslan Rezin, Konstantin Danilov,
Alexey Kashevnik, and Vladimir Jotsov. Blockchain solutions for multi-
agent robotic systems: Related work and open questions. arXiv preprint
arXiv:1903.11041, 2019.

[25] Gavin Wood et al.

Ethereum: A secure decentralised generalised

transaction ledger. Ethereum project yellow paper, 151(2014), 2014.

[26] Elli Androulaki, Artem Barger, Vita Bortnikov, Christian Cachin, Kon-
stantinos Christidis, Angelo De Caro, David Enyeart, Christopher Ferris,
Gennady Laventman, Yacov Manevich, et al. Hyperledger fabric: a dis-
tributed operating system for permissioned blockchains. In Proceedings
of the thirteenth EuroSys conference, 2018.

[27] Serguei Popov. The tangle. White paper, 1(3), 2018.
[28] Salma Salimi, Jorge Pe˜na Queralta, and Tomi Westerlund. Towards
managing industrial robot ﬂeets with hyperledger fabric blockchain and
ros 2. arXiv e-prints, 2022.

[29] Salma Salimi, Paola Torrico Mor´on, Jorge Pe˜na Queralta, and Tomi
Westerlund. Secure heterogeneous multi-robot collaboration and docking
with hyperledger fabric blockchain. arXiv preprint, 2022.

[30] Jason A Tran, Gowri Sankar Ramachandran, Palash M Shah, Claudiu B
Danilov, Rodolfo A Santiago, and Bhaskar Krishnamachari. Swarmdag:
A partition tolerant distributed ledger protocol for swarm robotics.
Ledger, 4(Supp 1), 2019.

[31] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system.

Decentralized Business Review, 2008.

[32] Vasco Lopes, Nuno Pereira, and Lu´ıs A Alexandre. Robot workspace
monitoring using a blockchain-based 3d vision approach. In EEE/CVF
CVPR Workshops, 2019.

[33] Morgan Quigley, Ken Conley, Brian Gerkey, Josh Faust, Tully Foote,
Jeremy Leibs, Rob Wheeler, Andrew Y Ng, et al. Ros: an open-source
In ICRA workshop on open source software,
robot operating system.
volume 3. Kobe, Japan, 2009.

[34] Eric A Brewer. Towards robust distributed systems. In PODC, volume 7.

Portland, OR, 2000.

[35] Wolfgang Hess, Damon Kohler, Holger Rapp, and Daniel Andor. Real-
In 2016 IEEE international

time loop closure in 2d lidar slam.
conference on robotics and automation (ICRA). IEEE, 2016.

how IOTA’s two-layer structure and ROS 2 can be applied to
a multi-robot system in a novel architectural design. In order to
demonstrate the partition-tolerant framework and the proposed
architecture, we chose a distributed mapping problem for a
proof of concept. The distributed mapping task was ﬁrst sim-
ulated in the Gazebo with eight robots. We then tested our dis-
tributed mapping smart contracts in a real-world scenario and
compared the results to a baseline Ethereum implementation.
Our results demonstrate how network partitioning impacts
distributed decision-making outcomes in both cases, with only
the IOTA-based implementation being able to showcase both
byzantine-tolerant and partition-tolerant behaviour.

Future research will be directed towards more diverse ap-
plications and larger-scale experiments. Speciﬁcally, we will
work on problems requiring more complex data processing,
such as applications where neural networks are required for
data processing but cannot be directly implemented within
smart contracts.

ACKNOWLEDGMENT

This research work is supported by the R3Swarms project
funded by the Secure Systems Research Center (SSRC),
Technology Innovation Institute (TII).

REFERENCES

[1] Melanie Schranz, Martina Umlauft, Micha Sende, and Wilfried Elmen-
reich. Swarm robotic behaviors and current applications. Frontiers in
Robotics and AI, 7:36, 2020.

[2] Mohd Javaid, Abid Haleem, Ravi Pratap Singh, and Rajiv Suman.
Substantial capabilities of robotics in enhancing industry 4.0 implemen-
tation. Cognitive Robotics, 1:58–75, 2021.

[3] Jorge Pe˜na Queralta, Jussi Taipalmaa, Bilge Can Pullinen, Victor Kathan
Sarker, Tuan Nguyen Gia, Hannu Tenhunen, Moncef Gabbouj, Jenni
Raitoharju, and Tomi Westerlund. Collaborative multi-robot search
and rescue: Planning, coordination, perception, and active vision. Ieee
Access, 8:191617–191643, 2020.

[4] Olimpiya Saha and Prithviraj Dasgupta. A comprehensive survey of
recent trends in cloud robotics architectures and applications. Robotics,
7(3):47, 2018.

[5] Manuele Brambilla, Eliseo Ferrante, Mauro Birattari, and Marco Dorigo.
Swarm robotics: a review from the swarm engineering perspective.
Swarm Intelligence, 7(1), 2013.

[6] Reza Olfati-Saber and Richard M Murray. Consensus problems in
IEEE

networks of agents with switching topology and time-delays.
Transactions on automatic control, 49(9), 2004.

[7] Rufﬁn James White-Magner. Usable Security and Veriﬁcation for

Distributed Robotic Systems. PhD thesis, UC San Diego, 2021.

[8] V´ıctor Mayoral-Vilches. Robot hacking manual (rhm). arXiv preprint

arXiv:2203.04765, 2022.

[9] Jorge Pe˜na Queralta, Li Qingqing, Zhuo Zou, and Tomi Westerlund.
Enhancing autonomy with blockchain and multi-access edge computing
in distributed robotic systems. In 2020 Fifth International Conference
on Fog and Mobile Edge Computing (FMEC), pages 180–187. IEEE,
2020.

[10] Anum Nawaz, Jorge Pe˜na Queralta, Jixin Guan, Muhammad Awais,
Tuan Nguyen Gia, Ali Kashif Bashir, Haibin Kan, and Tomi Westerlund.
Edge computing to secure iot data ownership and trade with the
ethereum blockchain. Sensors, 20(14):3965, 2020.

[11] Jorge Pe˜na Queralta and Tomi Westerlund. Blockchain for mobile edge
In Mobile Edge

computing: Consensus mechanisms and scalability.
Computing, pages 333–357. Springer, 2021.

[12] Volker Strobel, Eduardo Castell´o Ferrer, and Marco Dorigo. Blockchain
technology secures robot swarms: A comparison of consensus protocols
and their resilience to byzantine robots. Frontiers in Robotics and AI,
7, 2020.

[13] Eduardo Castell´o Ferrer, Ernesto Jim´enez, Jose Luis Lopez-Presa, and
Javier Mart´ın-Rueda. Following leaders in byzantine multirobot systems
by using blockchain technology. IEEE Trans. on Robotics, 38(2), 2021.

14

Farhad Keramat received his B.S. degree in Elec-
trical Engineering and his M.Sc. degree in Secure
Communication and Cryptography, from University
of Tehran, Tehran, Iran,
in 2017 and 2020, re-
spectively. Since 2021, he has been a researcher
at
the Turku Intelligent Embedded and Robotic
Systems (TIERS) Group, University of Turku. His
research interests include distributed ledger tech-
nologies, multi-robot systems security and multi-
robot collaboration.

Jorge Pe ˜na Queralta received B.S. degrees in
mathematics and physics engineering from UPC
BarcelonaTech, Spain, in 2016, a M.Sc. (Tech.) de-
gree in Information and Communication Science and
Technology from the University of Turku, Finland,
and a M. Eng. degree in Electronics and Commu-
nication Engineering from Fudan University, China,
in 2018. Since 2018, he has been a researcher and
doctoral candidate at the Turku Intelligent Embed-
ded and Robotic Systems (TIERS) Group, University
of Turku. His research interests include multi-robot
systems, collaborative autonomy, distributed perception, and edge computing.

Tomi Westerlund is an Associate Professor of
Autonomous Systems and Robotics at the University
of Turku and a Research Professor at Wuxi Institute
of Fudan University, Wuxi, China. Dr. Westerlund
leads the Turku Intelligent Embedded and Robotic
Systems research group (tiers.utu.ﬁ), University of
Turku, Finland. His current research interest is in
the areas of Industrial IoT, smart cities and au-
tonomous vehicles (aerial, ground and surface) as
well as (co-)robots. In all these application areas,
the core research interests are in multi-robot systems,
collaborative sensing, interoperability, fog and edge computing, and edge AI.

