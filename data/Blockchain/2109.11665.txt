WebFlow: Scalable and Decentralized Routing for Payment
Channel Networks with High Resource Utilization

Xiaoxue Zhang, Shouqian Shi and Chen Qian
University of California, Santa Cruz

1
2
0
2

p
e
S
3
2

]
I

N
.
s
c
[

1
v
5
6
6
1
1
.
9
0
1
2
:
v
i
X
r
a

ABSTRACT
Payment channel networks (PCNs) have been designed and utilized
to address the scalability challenge and throughput limitation of
blockchains. Routing is a core problem of PCNs. An ideal PCN rout-
ing method needs to achieve 1) high scalability that can maintain
low per-node memory and communication cost for large PCNs,
2) high resource utilization of payment channels, and 3) the pri-
vacy of users. However, none of the existing PCN systems consider
all these requirements. In this work, we propose WebFlow, a dis-
tributed routing solution for PCNs, which only requires each user
to maintain localized information and can be used for massive-scale
networks with high resource utilization. We make use of two dis-
tributed data structures: multi-hop Delaunay triangulation (MDT)
originally proposed for wireless networks and our innovation called
distributed Voronoi diagram. We propose new protocols to generate
a virtual Euclidean space in order to apply MDT to PCNs and use
the distributed Voronoi diagram to enhance routing privacy. We
conduct extensive simulations and prototype implementation to
further evaluate WebFlow. The results using real and synthetic PCN
topologies and transaction traces show that WebFlow can achieve
extremely low per-node overhead and a high success rate compared
to existing methods.

KEYWORDS
Blockchain, Payment Channel Networks, Routing

1 INTRODUCTION
Blockchain is a promising solution for decentralized digital ledgers.
Since Bitcoin was invented in 2008 [18], there have been many other
payment systems emerging based on blockchains, such as Ripple [3],
Stellar [10], and Ethereum [9]. While blockchains have shown the
great success as decentralized digital ledgers, scalability remains a
huge problem with growing numbers of users and transactions [5,
20]. For instance, Bitcoin can only support 10 transactions per
second at peak in 2020 [2]. In contrast, some widely used centralized
payment hubs such as Visa and MasterCard can process more than
65,000 transaction messages per second as of June 30, 2019 [1]. The
reason for such a low throughput is that every node processes all
transactions and the consensus is achieved by proof-of-work, a time-
and resource-consuming process. Whenever a new block arrives,
all nodes in the network have to process it and update the state of
the blockchain. Hence using blockchains as a global transaction
system for massive users is impractical at this moment. There are
some improvements in basic blockchain such as Bitcoin-NG [8]
and Monoxide [24]. However, their performance is limited by the
processing capacity of the nodes and network bandwidth, and thus,
cannot be used as large-scale global transaction systems.

1

Figure 1: A multi-hop payment in a PCN.

The recently proposed concept of payment channel networks
(PCN) [12, 20] provides a high-throughput solution for block-chain
based payment systems. In a PCN, a user ğ‘ can conduct transactions
with another user ğ‘ through a bi-directional channel. For this chan-
nel, only two transactions need to be recorded on the blockchain:
opening and shutting down the channel. Each user commits a cer-
tain fund at the opening of this channel. Then they can make any
number of transactions that update the tentative distribution of
the channelâ€™s funds as long as the remaining funds allow. Fig. 1(a)
shows a simple example of a PCN. There is a channel ğ‘ âˆ’ğ‘ between
user ğ‘ and ğ‘ which includes $5 from ğ‘ and $5 from ğ‘, and a channel
ğ‘ âˆ’ ğ‘ between user ğ‘ and ğ‘ which includes $5 from ğ‘ and $5 from ğ‘.
When ğ‘ pays ğ‘ $3, the fund distribution in the channle ğ‘ âˆ’ğ‘ changes
to $2 for ğ‘ and $8 for ğ‘. These transactions only need to be signed
by the signatures of ğ‘ and ğ‘ but do not need to be broadcast to
the entire blockchain. Each user can establish channels to multiple
other users. But the channel is not always existed between two
arbitrary users, and two users sharing a channel usually reflects
some level of trust. A user can make a transaction with another
arbitrary user via a multi-hop path, where any two consecutive
users on the path share a channel. For example, if ğ‘ wants to make
a payment to another user ğ‘ without a direct channel, as shown
in Fig. 1(a). ğ‘ has direct channels to both ğ‘ and ğ‘. Hence they can
use the multi-hop path ğ‘ âˆ’ ğ‘ âˆ’ ğ‘ and adjust the fund distribution
on the channels ğ‘ âˆ’ ğ‘ and ğ‘ âˆ’ ğ‘ accordingly as in Fig. 1(b). The
PCN is a promising solution to achieve scalability of blockchains
because most transactions can be achieved in an off-chain manner.
The ultimate vision is that everyone can conduct payment transac-
tions with any other person in the world using a trust network [11]
without centralized organizations such as banks and governments.
The core problem of a PCN is routing, i.e., finding a path be-
tween two arbitrary users. Current routing solutions of PCNs can
be classified into two types. 1) Centralized routing that assumes
every user knows the entire network topology, including all nodes
(users), links (channels), and link balances (available funds on each
link). Then each user runs a centralized algorithm to determine the
routing paths [20, 23, 25]. This approach is not a scalable solution
because when a PCN includes many users, each user needs a large
memory space to store the network information and every change
on any link needs to broadcast to all users. The massive link state
updates could cause high network bandwidth cost and the memory

aMulti-hop payment pathof $3Channel$5: $5bChannel$5: $5c(a) Before paymentaChannel$2: $8bChannel$2: $8c(b) After payment 
 
 
 
 
 
Figure 2: Trade-off of PCN routing

Figure 3: Example of different routing methods for PCNs.

cost is a severe problem for mobile users. 2) Distributed routing for
which each user only knows and interacts with a small subset of
other users, independent of the entire network size [15, 21]. It is
ideal for large-scale PCNs.

Existing distributed routing methods for PCNs, however, have
a crucial limitation: they cannot effectively utilize the channel
resource in a PCN. We show an example of a PCN with 7 users
and 9 channels as in Fig. 3(a). One typical distributed routing for
PCNs is landmark routing [15], in which a spanning tree rooted at a
landmark user is generated as shown in Fig. 3(b). Every transaction
(such as the one from ğ‘ to ğ‘‘) will be sent to the landmark first.
The landmark knows the whole network topology and will find
the path to the destination ğ‘‘. This approach does not utilize non-
tree channels, and channel resources around the landmark could
quickly run out. One improvement is embedding-based routing,
which is designed to avoid some unnecessary hops in the landmark
routing [21]. It learns a vector embedding for each node. Each
node relays each transaction to the neighbor whose embedding is
closest to the destinationâ€™s embedding. Hence it is possible to utilize
some non-tree links in a subtree as shown in Fig. 3(c). However,
many transactions still need to pass through the landmark and
cause similar problems. Poor channel utilization means fewer
transactions can be successfully delivered in a PCN.

In this paper, we introduce WebFlow, a scalable and distributed
routing solution for PCNs with small per-node overhead and high
channel resource utilization. As in Fig. 3(d), WebFlow allows each
node to explore the routing paths without relying on certain â€œhot
spotsâ€ such as landmarks. Hence, the resource utilization is signifi-
cantly improved. Meanwhile, each node only stores the information
of a few neighbors without knowing the global topology. As shown
in Fig. 2, WebFlow provides significantly lower per-node overhead
compared to centralized, landmark, and embedding routing while
achieving similar channel resource utilization to that of central-
ized routing. In theory, centralized routing should always achieve
better resource utilization than all distributed routing because it
can apply any optimization. However, in our evaluation, we com-
pare WebFlow with two recent centralized LCN routing methods
[23, 25] in terms of resource utilization and found it ties with one
and outperforms the other.

WebFlow is a coordinated-based geographic routing protocol
for PCNs. It allows every node to calculate a set of Euclidean co-
ordinates and uses the coordinates to perform coordinated-based
greedy routing. We design a system that nodes maintain a multi-
hop Delaunay triangulation (MDT) [14] based on only the channels

with trusted users to achieve a high success ratio of pathfinding. To
further protect the anonymity of senders and recipients, our impor-
tant innovation is to use the property of a distributed Voronoi
diagram to achieve the routing tasks. Different from traditional
greedy routing, it does not require the coordinates of the destina-
tion in a routing message. Instead, it introduces a direction vector
to help to determine the path that hides the actual destination.
In summary, this paper makes the following contributions:

â€¢ We design WebFlow, a new routing protocol for PCNs
with low per-node overhead while achieves high resource
utilization.

â€¢ We propose an enhanced version of WebFlow to protect
user privacy, i.e., the identities of source and destination
of a transaction can be hidden, even if the attacker stands
on the path.

â€¢ We implement WebFlow based on real-world PCN topolo-
gies and transactions and build a prototype that can run
as a real system. The results show the claimed advantages
of WebFlow compared to the state-of-the-art protocols.

The rest of this paper is organized as follows. Section 2 introduces
the background of PCNs and the related work. The system overview
and model are presented in Section 3. We describe the detail design
of the WebFlow protocols in Section 4 and Section 5. Section 7
presents the evaluation results of WebFlow. Section 9 summarizes
our conclusions. This work does not raise any ethical issues.

2 RELATED WORK
PCNs provide a high-throughput solution for blockchains [12, 20].
To set up a payment channel, two users jointly create a transaction
in the blockchain that deposits money for a period of time. Each
user commits a certain fund in the opening of this channel. Then
the two users can make any number of transactions without broad-
casting them to the blockchain. Two users sharing a channel reflects
some level of trust. A user apparently cannot trust arbitrary users.
In this case, a user can make a payment to (or receive fund from)
another untrusted user via a multi-hop path, where any two consec-
utive users on the path share a channel. The ultimate vision is that
everyone can conduct payment transactions with any other person
in the world using a trust network [11] without the intervention of
centralized organizations such as banks and governments.

Routing is a challenging problem in a PCN. In Lightning Network
[20], each node locally maintains the network topology and a global
routing table. In current implementations, users pick the paths by
the shortest path and max-flow routing algorithms. However, it has

2

Node overheadLowGoodPoorHighResource utilizationCentralized LandmarkEmbeddedWebFlowabcdabcdabcdabcd(a) A PCN(b) Landmark routingLandmarkLandmarkChannelresourcearoundthe landmark could run out quickly(d) WebFlow(c) Embedding routingethree practical problems: 1) The per-node storage cost is ğ‘‚ (|ğ‘‰ |+|ğ¸|)
where |ğ‘‰ | and |ğ¸| denote the number of users and channels in the
network respectively; 2) the per-transaction computation cost is
ğ‘‚ (|ğ‘‰ | Â· |ğ¸|2) using the max-flow routing algorithm; 3) every update
of any channel will be broadcast to all nodes. Hence it leads to
scalability problems, especially for mobile users.

Recent work such as Spider [23] and Flash [25] use centralized
routing. Spider actively accounts for the cost of channel imbalance
by preferring routes that re-balance channels, and it proposes a
centralized offline routing algorithm to maximize the success vol-
ume of payments. But the centralized scheme still has high probing
overhead. Flash reduces the probing overhead by treating elephant
and mice payments differently. It requires each user to maintain
a routing table for mice payments, and periodically refreshes the
routing table when the local network topology is updated. It still
applies a huge memory cost for each user.

To reduce the per-node overhead in PCN, landmark routing and
embedding-based routing have been proposed as distributed rout-
ing. In landmark routing, a few users are selected as landmarks,
and they are responsible to store routes to all other nodes. Non-
landmark nodes only need to store routes to the landmarks. Silen-
tWhispers [15] utilizes landmark routing. It performs a periodic
breadth-first search to find the shortest path from the landmarks
to the sender and recipient. All paths need to go through the land-
marks, which makes the channels around the landmarks over-used
and some paths could be unnecessarily long. Other channels might
be under-used. Embedding-based routing is designed to avoid some
unnecessary hops in the landmark routing. It learns a vector embed-
ding coordinate for each user based on the structure of spanning
trees generated by landmarks. Each user relays transactions to the
neighbor whose embedding is closest to the recipientâ€™s embedding.
SpeedyMurmurs [21] uses embedding-based routing. Computing
and updating the coordinates as the topology and channel balances
change is a major challenge of this approach.

Other overlay network routing methods such as distributed hash
tables (DHTs) cannot be used for PCNs because one cannot be
forced to build a channel with an arbitrary user. In DHT, A node
picks its neighbors according to a certain structure and mapping
rules. But these neighbors might not be its direct neighbors in the
PCN, and the paths to these neighbors might be long, resulting
in a high routing stretch in the PCN. Kademlia [16] enforces a
structured topology. However, in reality, as users can set up and
shuttle down channels anytime, the topology is unstructured and
keeps changing.

There are many existing Ad-Hoc routing protocol such as DSR,
AODV and GPSR. However, GPSR only works for planar graphs. In
both DSR and AODV, route discovery is based on flooding, which
introduces considerable routing overhead, and can not be applied
to the large scale PCNs. Besides, the initial balance of a payment
channel is deposited by the users during the channel setup, and is
kept updating during each transaction. So the route maintenance
mechanism in both DSR and AODV may not work well in such
dynamic networks.

Compared to existing work, WebFlow is the first solution that
considers both the scalability of user overhead and channel resource
utilization in PCN routing.

3 OVERVIEW
3.1 Network Model
WebFlow is a distributed routing protocol for large-scale PCNs.
In a PCN, each user is called a node. The bi-directional payment
channel shared by two nodes is called a physical channel or direct
link, and these two nodes are called direct neighbors. The fund of one
direction of a link is called the balance of that direction. We model
a PCN as a graph ğº = (ğ‘‰ , ğ¸, Î¨), where ğ‘‰ is the set of nodes, ğ¸ is
the set of links with a weight function ğ‘¤, and ğœ“ğ‘¢ğ‘£,ğœ“ğ‘£ğ‘¢ âˆˆ Î¨ are the
balances of link ğ‘’ = (ğ‘¢, ğ‘£) in two directions. Furthermore, a path ğ‘ is
a sequence of links ğ‘’1...ğ‘’ğ‘˜ with ğ‘’ğ‘– = (ğ‘£ğ‘–, ğ‘£ğ‘–+1) for 1 â‰¤ ğ‘– â‰¤ ğ‘˜ âˆ’ 1. The
parameter ğœ“ describes the amount of funds that can be transferred
between two nodes sharing a link. The path of a transaction is
accepted only if the amount of this transaction is less than every
fund ğœ“1...ğœ“ğ‘˜ along this path. Every node knows the links and their
balances to its neighbors.

Problem definition. The routing problem of WebFlow is de-
scribed as follows. Consider a transaction ğ‘¡ initiated by sender ğ‘ 
that should be received by the recipient ğ‘Ÿ . WebFlow needs to find a
path from ğ‘  to ğ‘Ÿ , where two consecutive nodes on the path should
share a physical link (payment channel) and each link has enough
balance to make the payment to the next-hop. The success of rout-
ing implies that ğ‘  can make a transaction with ğ‘Ÿ by a sequence of
transactions involving other nodes, even if ğ‘  and ğ‘Ÿ have no trusted
channel. We have three objectives: 1) each node should have limited
memory and communication overhead, which is independent of
the network size; 2) WebFlow should achieve a high success rate
of transaction routing; 3) WebFlow should achieve high channel
resource utilization, which can be measured by in the total amount
of successfully-processed transaction funds over a period of time.

3.2 Attacker Model
We consider the user privacy of their transactions in a fully dis-
tributed PCN. Our primary attack scenario is the malicious users
interested in otherâ€™s financial situation. They are a group of honest-
but-curious users that passively observes the channels related to
them and tries to infer the source and destination of the transac-
tions. They only know the channels to their neighbors, but cannot
access the routing information stored at other honest users. The
attackers here aim to undermine the userâ€™s privacy and profit from
it rather than perform a denial-of-service attack.

Similar to PrivPay [17] and SpeedyMurmurs [21], our goal is to
hide values, and achieve anonymity of sender and receiver when
making transactions. We use the term value privacy, sender/receiver
anonymity respectively to refer to these three privacy goals.

Value privacy: We say that the PCN can achieve value privacy
if it is impossible for any adversary to know the total value of a
transaction between two honest users. Let ğ‘  and ğ‘Ÿ be two non-
compromised nodes, and ğ‘ is the transaction path from ğ‘  to ğ‘Ÿ . We
consider two situations: 1) all the nodes along the path are non-
compromised, and 2) there exist one or more malicious nodes on the
path. In the first case, the attacker cannot obtain any information
about the transaction value. In the second case, as a malicious node
can monitor how much funds go through itself, it could easily know
the transaction value along this path. To prevent this kind of attack,
we can just divide the total value into ğ‘˜ parts in advance, and select

3

(a) Network with random coordinates

(b) WebFlow coordinates

(c) The MDT of the set of nodes

Figure 4: Original PCN graph, the graph after node positioning, and MDT graph.

ğ‘˜ paths to complete this transaction. As the malicious node can only
know the value on the path where it exists, it canâ€™t know the total
value. Even if the malicious nodes on different paths collaborate,
they still do not know how many paths are chosen.

Sender anonymity: We say that a PCN can achieve sender anony-
mity if the adversary cannot determine the original sender of a
transaction.

Receiver anonymity: Similarly, a PCN has receiver anonymity if
the adversary cannot determine the actual receiver of a transaction.
We formally define a metric to evaluate the sender/recipient anony-
mity of a network and its routing algorithm as follows. The anonymity
measure follows the anonymity definition that has been used for
anonymous routing such as [7, 22, 27]. Anonymity is the state of
being not identifiable within a set of subjects, i.e., the anonymity set.
In a network with ğ‘ nodes, ideal anonymity is achieved when all
nodes look equally likely to be the sender or recipient to an attacker,
that is the anonymity set contains all the nodes in the network.
However, it is impossible in real-world systems. The attacker can
deduce that some nodes are more likely to be the sender or recipient
based on information leaked from the system. So the attacker can
assign each node ğ‘¢ a probability ğ‘ğ‘¢ as being the sender or recipient
of a transaction using knowledge of leaked information from the
system. All the nodes in the network are denoted as a finite set ğ‘‰ ,
where |ğ‘‰ | = ğ‘ . Then the system entropy is defined as:

ğ» (ğ‘‰ ) = âˆ’

âˆ‘ï¸

ğ‘¢ âˆˆğ‘‰

ğ‘ğ‘¢ğ‘™ğ‘œğ‘”2 (ğ‘ğ‘¢ )

(1)

If we have ideal anonymity, all nodes look equal to the attacker.
We can get ğ‘ğ‘¢ = 1
ğ‘ for all the nodes in the system. And the entropy
of ideal anonymity is ğ»ğ‘š (ğ‘‰ ) = log2 (|ğ‘‰ |). This is the maximum
entropy the system can achieve.

The anonymity of the system is measured by the entropy of this
system over the entropy of system ideal anonymity. The anonymity
of the system is measured as:

ğ» (ğ‘‰ )
ğ»ğ‘š (ğ‘‰ )

=

âˆ’ (cid:205)ğ‘¢ âˆˆğ‘‰ ğ‘ğ‘¢ğ‘™ğ‘œğ‘”2 (ğ‘ğ‘¢ )
log2 (|ğ‘‰ |)

(2)

Again, to measure the anonymity of our system, we need to
consider two situations: 1) no attacker on the path, and 2) one or
more attackers on the path. We use ğ‘‰ğ´ to denote the set of attackers,
and ğ‘ƒğ‘ to denote the path set. The anonymity of WebFlow will be
analyzed in detail in Section 6.

4

3.3 Analysis methodology of this work
From our observation of real PCN topologies, they are not any
regular graphs such as grids or trees. Hence, it is impossible to
use theoretical formulation to analyze the routing performance
or anonymity of a routing algorithm. In this paper, we will use
extensive simulations with both real and synthetic network
topologies to analyze the routing performance or anonymity. In
addition, we use prototype implementation to demonstrate that
WebFlow can work in practice.

4 BASELINE DESIGN OF WEBFLOW
To achieve distributed and scalable routing, WebFlow utilize the
idea of coordinate-based greedy routing that has been widely used
for wireless networks [13, 14]. The basic idea is that in wireless
networks, each node knows its geographic coordinates as well as its
neighborsâ€™. Then without knowing the whole topology, each node
can simply forward a packet to a neighbor who is geographically
closest to the destination. The major problem is that a node could
be a local minimum and none of its neighbors is closer to the
destination than itself. This problem can be solved in various ways
[13, 14]. Geographic greedy routing is very scalable because each
node only needs to know its direct neighbors.

We would like to apply the idea of coordinate-based greedy rout-
ing in WebFlow for PCNs. However, one immediate problem is that
many users do not want to share their geographic locations in PCNs
which could be a threat to their privacy. In addition, the geographic
distances of PCNs do not reflect the routing cost, while in wireless
networks distances can be an estimate of routing difficulties. Hence,
we propose to use virtual coordinates in a Euclidean space that
reflect the PCN topology features.

Every PCN has multiple web servers as its interface of registra-
tion and user interactions. The web servers in WebFlow do not
participate in routing and only support coordinates computation.
Hence it avoids the landmark limitations in landmark-based routing
[15, 21]. We assume there are no more than 1
3 malicious servers in
our systems. The malicious servers try to stop the progress of the
protocol by playing denial-of-service attack, or providing wrong
coordinates. To guarantee the correctness of virtual coordinates,
the user can simply send coordinate request to all the servers. If it
receives same results from more than half of the servers, the user
will adopt this virtual coordinate.

-200-1000100200300-200-100010020030020010001002003002001000100200300-200-1000100200300-200-1000100200300Figure 5: SVD analysis of PCNs

Figure 6: Voronoi diagram, Delaunay triangulation (DT), and MDT

4.1 Coordinates computation
For the PCN ğº = (ğ‘‰ , ğ¸, Î¨) in a Euclidean space ğ‘†, each node will be
assigned a set of coordinates ğ‘ğ‘† in ğ‘† by the web servers. The goal
is to let nodes maintain coordinates such that two neighbors are
relatively close in the Euclidean space. For two arbitrary nodes, their
network distance (e.g., in hop-count) would be proportional to their
Euclidean distance. In this way, coordinate-based greedy routing
will be more likely to succeed. We denote the actual hop-count
between nodes ğ‘¢ and ğ‘£ as â„ğ‘†
ğ‘¢ğ‘£. The Euclidean distance between the
coordinates of ğ‘¢ and ğ‘£ is denoted as ğ‘‘ğ‘†

ğ‘¢ğ‘£.

The web servers randomly select ğ‘˜ nodes ğ‘‡ = {ğ‘‡1, ...,ğ‘‡ğ‘˜ } called
anchors where ğ‘˜ = ğ‘‘ +1 if we use a ğ‘‘-dimensional Euclidean space. 1
For each anchor, the server recursively visits its neighbors, resulting
in a spanning tree. Then the server has ğ‘˜ spanning trees and knows
the hop-counts between all pairs among the anchors, i.e., a ğ‘˜ Ã— ğ‘˜
hop-count matrix characterizing the distances between every pair
,...,ğ‘ğ‘†
of anchors. The server should find a set of coordinates ğ‘ğ‘†
,
ğ‘‡ğ‘˜
ğ‘‡1
such that the Euclidean distance can reflect the hop-counts with
minimal errors. We apply an existing algorithm multi-dimensional
scaling [4] to obtain the coordinates. Once the coordinates of an-
chors, ğ‘ğ‘†
, are determined, each node contacts the web server
ğ‘‡1
to get the coordinates of anchors and their hop-counts to the an-
chors. Each node can determine its own coordinates by minimizing
the overall error between actual hops and computed distances to
these anchors. Since each user is responsible to compute its own co-
ordinate, the system can be scaled to large sizes. Actually, the most
time-consuming part in coordinate computation is initialization
when the web servers build a spanning tree for each anchor and
compute the coordinates of anchors. However, even for a real-world
PCN topology generated from Ripple network with 1,870 nodes, it
only takes 5 seconds to initialize. And it takes less than 10 ms for
each user to generate its own coordinate.

,...,ğ‘ğ‘†
ğ‘‡ğ‘˜

We show an example of a PCN in Fig. 4. Fig. 4(a) shows the
network topology with randomly assigned coordinates. After the
WebFlow coordinate assignment in a 2D space, the network is
shown in Fig. 4(b). We find that the WebFlow coordinates show a
better correlation between the Euclidean distances and hop counts.
Choice of dimensionality. One immediate question is that
how many dimensions of the Euclidean space we shall use to char-
acterize the network topologies of PCNs. We use Principal Com-
ponent Analysis (PCA) to find an appropriate dimensionality. PCA
relies on Singular Value Decomposition (SVD). The input of SVD is
an ğ‘› Ã— ğ‘› matrix ğ‘€ of the hop-counts of all nodes. SVD factors ğ‘€
into the product of three matrices ğ‘€ = ğ‘ˆ ğ‘†ğ‘‰ ğ‘‡ , where ğ‘† is a diagonal

1Note that for a ğ‘‘-dimensional Euclidean space, ğ‘˜ needs to be at least ğ‘‘ + 1[19].

5

matrix with non-negative elements ğ‘ ğ‘– . If singular values ğ‘ 1, ğ‘ 2, ..., ğ‘ ğ‘‘
are much larger than the rest, we may approximate ğ‘€ using ğ‘‘-
dimensional Euclidean spaces. We analyze two real-world payment
channel network topologies: Ripple [3] and Lightning [20], whose
details will be presented in Sec. 7. In Fig. 5 we show the singular
values of the two PCNs. We find the first three singular values of
Ripple and the first two of Lightning are significantly larger than
the rest. Hence in WebFlow we will use 3D space and show some
comparison with 2D and 4D in evaluation.

4.2 WebFlow Routing
One major challenge of greedy routing using virtual coordinates
is that it may stuck at a local minimum. WebFlow is based on a
distributed data structure called Multi-hop Delaunay triangulation
(MDT) [14]. An important feature of MDT is that, each node only
needs to maintain the link and path information to a few neighbor-
ing nodes, independent of the network size.

For a given set of nodes ğ‘‰ in a Euclidean space, the Voronoi
diagram is a partition of space into regions (called cells) such that
each cell contains one node and the node is closer to any point
in the cell than all other nodes. An example in Fig. 6(a) shows
the Voronoi diagram of a 2D space with 6 nodes. For all points in
Voronoi cell ğ‘‰ğ¶ (ğ‘¢), node ğ‘¢ is closer to them than any other node
in ğ‘‰ . A Delaunay triangulation, shown in Fig. 6(b), is a dual graph
of the Voronoi diagram, where two nodes in ğ‘‰ are connected if
their Voronoi cells share an edge. Two nodes ğ‘¢ and ğ‘£ are called DT
neighbors if they are connected in ğ·ğ‘‡ (ğ‘‰ ). An important proven
feature is that greedy routing on the DT edges (i.e., assuming all DT
neighbors are connected) always succeeds to find the destination
without encountering a local minimum [14].

However, in reality, not every DT edge is connected. In a PCN
two nodes cannot be forced to generate an actual channel. As shown
in Fig. 6(c), the DT edges ğ‘¢ğ‘£ and ğ‘ğ‘ are not connected. A MDT is a
distributed protocol to generate a distributed data structure such
that 1) each node knows its DT neighbors; 2) for a DT neighbor
without a direct channel to it, MDT provides a multi-hop channel
path to the DT neighbor. Hence greedy routing with an MDT can
guarantee to find an end-to-end path from a source to the destina-
tion, using the destination coordinates. This feature can be extended
to ğ‘‘-dimension for ğ‘‘ â‰¥ 2.

We denote ğ·ğ‘‡ (ğ‘‰ ) as a tuple {< ğ‘¢, ğ‘ğ‘¢ > |ğ‘¢ âˆˆ ğ‘‰ }, where ğ‘ğ‘¢ is
the set of ğ‘¢â€™s DT neighbors, which is locally maintained by ğ‘¢. The
set of ğ‘¢â€™s direct neighbors is denoted as ğ¶ğ‘¢ . Then ğ‘¢ determines its
DT neighbor ğ‘ğ‘¢ by calculating a local DT of ğ¶ğ‘¢ .

The major challenge of applying DT to PCNs is that two DT
neighbors may not have a physical channel. To address this problem,

05101520Dimension number00.20.40.60.81Normalized singular valueRippleLightninguvuVC(u)uvbca(a) Voronoi diagram with a set Vof nodes(b) Delaunay triangulation of the set of nodes (dashed lines)(c) MDT of the set of nodesthe MDT is specified as a 3-tuple {< ğ‘¢, ğ‘ğ‘¢, ğ¹ğ‘¢ > |ğ‘¢ âˆˆ ğ‘‰ }, where ğ¹ğ‘¢
is a soft-state forwarding table that helps to find multi-hop channel
path to the DT neighbors without direct channel. The extension
of MDT from DT is that a node in ğ‘ğ‘¢ is not necessarily directly
connected to node ğ‘¢ by physical channels. We say that those nodes
who are ğ‘¢â€™s DT neighbors but not direct neighbors communicate
via a virtual link with ğ‘¢. Even if two DT neighbors do not have
a channel, they can be connected by virtual link because there is
an underlying multi-hop path of real channels that connects one
DT neighbor to the other. Note that in WebFlow, no node should
maintain a global view of the MDT. Each node only maintains local
information < ğ‘¢, ğ‘ğ‘¢, ğ¹ğ‘¢ > that is independent of the network size.
The routing decisions are made locally. In addition, there are no
supernodes that handle most payments such as the landmarks in
landmark routing. Hence WebFlow is highly scalable and decen-
tralized. Given the destination coordinates, WebFlow routing
using the MDT graph always finds a path to the destination
based on local decisions of the nodes on the path.

The forwarding table ğ¹ğ‘¢ is used by ğ‘¢ to help to find the physical
path from one node to its DT neighbors. Every entry in ğ¹ğ‘¢ is speci-
fied by a 4-tuple < ğ‘ ğ‘œğ‘¢ğ‘Ÿğ‘ğ‘’, ğ‘ğ‘Ÿğ‘’ğ‘‘, ğ‘ ğ‘¢ğ‘ğ‘, ğ‘‘ğ‘’ğ‘ ğ‘¡ >, source and dest being
the node and its DT neighbor node in the path respectively, pred
and succ being the predecessor and successor nodes of ğ‘¢ in this
section of the path. For an example of a forwarding path, consider
the MDT graph in Figure 6(c). Nodes ğ‘¢ and ğ‘£ have no channel,
but a multi-hop path ğ‘¢ âˆ’ ğ‘ âˆ’ ğ‘£ supports the virtual link ğ‘¢ğ‘£. So the
currency is forwarding along the path ğ‘¢ âˆ’ ğ‘ âˆ’ ğ‘£. The forwarding
tuples using along the path in the nodes are: < âˆ’, âˆ’, ğ‘, ğ‘£ > in node
ğ‘¢, < ğ‘¢, ğ‘¢, ğ‘£, ğ‘£ > in node ğ‘, and < âˆ’, âˆ’, ğ‘, ğ‘¢ > in node ğ‘£.

The routing algorithms of WebFlow contain several MDT proto-
cols including the forwarding protocol, join protocol, and mainte-
nance protocol. The forwarding protocol determines how a node
should locally decide the next-hop node when routing to a receiver
in a correct MDT. The other protocols are used to maintain a correct
MDT graph. They are all decentralized algorithms.

4.2.1

Forwarding Protocol. Consider a payment ğ‘¡ initiated by
node ğ‘  that should be received by node ğ‘Ÿ , and the payment value is ğœ”.
For each node ğ‘¢ received forwarding request, it first checks whether
it is the receiver. If it is, ğ‘¢ does not need to forward. Otherwise, if ğ‘¢
can find a direct neighbor ğ‘£ closest to the receiver, it will check that
if the channel ğ‘¢ğ‘£ has enough capacity to support the payment. If
the channel can support the payment, that is ğœ“ğ‘¢ğ‘£ > ğœ”, ğ‘¢ sends the
payment to ğ‘£. Otherwise, ğ‘¢ finds the DT neighbor ğ‘£ â€² that is closest
to ğ‘Ÿ among all ğ‘¢â€™s DT neighbors. Then, ğ‘¢ needs to probe the virtual
link to check if the underlying multi-hop path of this virtual link
has enough capacity to support the payment. If it can, ğ‘¢ sends the
payment to ğ‘£ â€² using the virtual link.

If both situations fail due to channel capacity limitation, ğ‘¢ tra-
verses all of its direct neighbors to check if there exists a direct
neighbor ğ‘£ closer to the receiver with enough channel capacity
to support the payment. In other words, the Euclidean distance
ğ‘‘ (ğ‘£, ğ‘Ÿ ) < ğ‘‘ (ğ‘¢, ğ‘Ÿ ), and ğœ“ğ‘¢ğ‘£ > ğœ”. If such a direct neighbor does not
exist, ğ‘¢ selects 5 DT neighbors closer to the receiver. Note that ğ‘¢â€™s
DT neighbors that are closer to the receiver may be less than 5,
in this case, ğ‘¢ just selects all these satisfied DT neighbors. Then ğ‘¢
probes the virtual links to these selected DT neighbors until it finds
a DT neighbor with a virtual link that can support the payment.

6

If all these selected DT neighbors fail to fulfill the payment, we
assume that this payment is failed. Note that if ğ‘¢ selects too many
DT neighbors to probe, it will introduce large probing overhead
and communication cost. If ğ‘¢ only probes small number of DT
neighbors, it will lower the success ratio. We analyze the topology
generated from Ripple network and find that averagely each user
has 13 DT neighbors located in different direction. Considering
the trade off between communication cost and success ratio, we
choose 5 DT neighbors to probe in our design. The pseudo-code
of the forwarding algorithm at an intermediate node is shown in
Algorithm 1 in Appendix A.

From the observation of real PCNs, only a very small portion of
the transactions are with big amounts. In Ripple, only 10% of the
payments are of balances more than $1,740 USD, and the median
balances of payment are $4.8 USD [25]. We further introduce a
special design to treat large transactions. If a payment ğ‘¡ exceeds
a threshold, the sender randomly divides the large payment into
several micropayments ğ‘¡1, ğ‘¡2, ...ğ‘¡ğ‘˜ , and assigns each sub-payment a
random unique index. The sender treats these sub-payments as un-
related and independent payments. If the number of sub-payments
received by the receiver is less than the number informed by the
sender, we assume that this payment ğ‘¡ is failed. To better preserve
the value privacy, small payments are also assigned a random in-
dex. Thus, a malicious node seeing a payment going through it
cannot determine whether it is the total value or just part of the
value of a sub-payment. Since the index is randomly distributed,
the adversary cannot estimate the number of sub-payments or the
total value of the payment from the index.

4.2.2 New node joins. A PCN network topology is dynamic, as
new nodes may boots up while some existing nodes may get offline.
So we first consider a join protocol to deal with nodes booting up.
When a new node ğ‘¤ boots up and wants to join the network, it
first needs to discover its direct neighbors and assigns its coordi-
nate. Here, the direct neighbor can be any node that ğ‘¤ trusts and
wants to build a channel to make frequent transactions. In order to
get its coordinate, ğ‘¤ first needs to get the coordinates of anchors
from the web servers. Then it sends hop-count queries to its direct
neighbors and conclude its hop-count to each anchor. For example,
assume the hop-count information to an anchor ğ‘¤ collects from
its direct neighbors is {â„1, â„2, ...}. ğ‘¤ can deduce that its hop-count
to this anchor is ğ‘šğ‘–ğ‘›{â„1, â„2...} + 1. With these information, ğ‘¤ can
determine its own coordinate locally.

Then it will send a join request to its neighbor who is a DT node,
and try to find all of its DT neighbors. To begin its search, it must
find at least one neighbor working correctly in the system, say
ğ‘£. Node ğ‘¤ includes its coordinate in the join request and sends it
to ğ‘£. Now ğ‘£ can begin a greedy routing to get to node ğ‘ which is
closest to ğ‘¤. By the property of DT, the closest node to ğ‘¤ in the
Euclidean space must be a DT neighbor. So ğ‘ is definitely ğ‘¤â€™s DT
neighbor. Then ğ‘ sends a ğ½ğ‘‚ğ¼ ğ‘ _ğ‘Ÿğ‘’ğ‘ back to ğ‘¤ along the reverse
path. After receiving the ğ½ğ‘‚ğ¼ ğ‘ _ğ‘Ÿğ‘’ğ‘, ğ‘¤ begins an iterative search
to find other DT neighbors. After finding the paths to these DT
neighbors, ğ‘¤ locally store the paths as virtual links. ğ‘¤ also needs
to locally maintain the direct neighbor set ğ¶ğ‘¢ and DT neighbor set
ğ‘ğ‘¢ . Since ğ‘¤ boots up to be their new neighbor, they also need to
update their node sets ğ¶ğ‘¢ and ğ‘ğ‘¢ in the memory.

4.2.3 Node leaving and other changes. We now consider a main-
tenance protocol to deal with the situation when a node gets offline,
new channels emerge, or some channels shut down. This protocol is
designed to fix the structure of MDT. The MDT graph is correct only
if every node knows all of its DT neighbors. So in WebFlow, each
node ğ‘¢ queries some of its neighbors to see if they know mutual
neighbors that node ğ‘¢ does not know, and then sends neighbor-set
requests to them. If ğ‘¢ discovers a new neighbor from neighbor-set
replies, it will send a neighbor-set request to this new neighbor
if they are vertexes in the same simplex in ğ·ğ‘‡ (ğ¶ğ‘¢ ). Every node
runs this maintenance protocol locally, and every time when a node
finishes running it, it will wait for a time period ğ‘‡ğ‘š until running
it again. This helps to keep the MDT correct and guarantees that
the forwarding protocol works well.

4.3 Limitations
While MDT-based WebFlow routing protocol provides a high suc-
cess ratio and short forwarding paths for payment with low memory
cost in the payment channel network, it does not achieve all the
privacy goals defined in Section 3. Since we use Euclidean distance
to choose the node closest to the receiver, the coordinate of the re-
ceiver is exposed to all the nodes along the path as well as their DT
neighbors and direct neighbors. Once the adversary controls some
of these nodes, it can speculate what and where the sender and
receiver are with some probability, although it is still not sure about
the payment value. Even if we apply onion routing in WebFlow
as Lightning network did [20], each intermediary still knows the
coordinates of the immediately preceding and following nodes.
Transactions may still be tracked by malicious intermediary.

5 WEBFLOW-PE DESIGN
In this section, we present the routing protocol of WebFlow-PE, a
privacy enhancement version in WebFlow. The design of WebFlow-
PE is consistent with MDT-based WebFlow except forwarding
part. We first provide a high-level overview and intuition behind
WebFlow-PE and then provide a detailed protocol description.

5.1 WebFlow-PE Overview
One problem of the MDT routing algorithm in the basic design
of WebFlow in Section 4 is that the coordinate of the receiver is
exposed to all the nodes along the path as well as their neighbors.
If there are malicious nodes standing along the path, they can
somehow track the transaction and undermine privacy.

We extend the basic design of WebFlow to hide the coordinates
of all the nodes along the path and enhance user anonymity based
on an innovation called distributed Voronoi Diagram. As introduced
in Sec. 4, the Voronoi Diagram is the dual graph of the DT. It is very
easy for a node running WebFlow to know the boundaries of its
Voronoi cell: simply computing the bisectors of the line segments to
all its DT neighbors. If every node knows its Voronoi cell boundaries,
a distributed Voronoi Diagram is maintained.

Instead of using the destination coordinates, we propose to only
use a line with a direction (cid:174)ğ‘™ as the routing target. The sender ğ‘ 
generates (cid:174)ğ‘™ by making it intersect an arbitrary point in the Voronoi
cell of ğ‘  and another arbitrary point in the Voronoi cell of the
receiver ğ‘Ÿ , with a direction to the later as shown in Fig. 7(a).

Figure 7: An example of WebFlow-PE on the distributed
Voronoi diagram

The routing algorithm is that, at an intermediate node ğ‘£, ğ‘£ always
sends the payment to its DT neighbor whose Voronoi cell is the next
Voronoi cell intersecting with (cid:174)ğ‘™ along (cid:174)ğ‘™â€™s direction. To prove that
WebFlow-PE guarantees to find a path to ğ‘Ÿ , we prove the following
propositions.

Proposition 5.1. Suppose the Voronoi cell of ğ‘£, ğ‘‰ğ¶ (ğ‘£), intersects
with (cid:174)ğ‘™. The next Voronoi cell intersecting with (cid:174)ğ‘™ along (cid:174)ğ‘™â€™s direction
is the Voronoi cell of ğ‘£ â€², denoted by ğ‘‰ğ¶ (ğ‘£ â€²). Then ğ‘£ and ğ‘£ â€² are DT
neighbors.

Proof. Since ğ‘‰ğ¶ (ğ‘£ â€²) is the Voronoi cell intersecting with (cid:174)ğ‘™ next
to ğ‘‰ğ¶ (ğ‘£), ğ‘‰ğ¶ (ğ‘£) and ğ‘‰ğ¶ (ğ‘£ â€²) must share a Voronoi edge intersecting
with (cid:174)ğ‘™. By definition, two nodes sharing a Voronoi edge are DT
â–¡
neighbors.

Proposition 5.2. ğ‘£ knows a path to reach every DT neighbor of ğ‘£.
This is very easy to prove: 1) if ğ‘£ has a direct channel to its DT
neihgbor ğ‘£ â€², it can send the payment to ğ‘£ â€² directly; otherwise 2) ğ‘£ â€²
is a multi-hop DT neighbor and ğ‘£ can rely on MDT to get the path
to ğ‘£ â€².

Proposition 5.3. The routing of WebFlow-PE guarantees to reach

the destination ğ‘Ÿ .

Proof. Let the Voronoi cells intersecting with (cid:174)ğ‘™ are in a sequence
ğ‘‰ğ¶ (ğ‘ ), ğ‘‰ğ¶ (ğ‘£1), ğ‘‰ğ¶ (ğ‘£2), ..., ğ‘‰ğ¶ (ğ‘£ğ‘˜ ), ğ‘‰ğ¶ (ğ‘Ÿ ).... Since (cid:174)ğ‘™ intersects with
ğ‘‰ğ¶ (ğ‘ ) and ğ‘‰ğ¶ (ğ‘Ÿ ) by definition, ğ‘‰ğ¶ (ğ‘ ) and ğ‘‰ğ¶ (ğ‘Ÿ ) must exist in
the above sequence. WebFlow-PE routing using (cid:174)ğ‘™ will visit ğ‘‰ğ¶ (ğ‘ ),
ğ‘‰ğ¶ (ğ‘£1), ğ‘‰ğ¶ (ğ‘£2), ..., until reaching ğ‘‰ğ¶ (ğ‘£ğ‘˜ ) according to the routing
â–¡
algorithm.
How ğ‘Ÿ confirms that it is the receiver of the payment. ğ‘  and
ğ‘Ÿ need to first exchange a common secret for this transaction such
as a transaction key ğ‘˜, using classic secure Internet communication
such as TLS. In addition to (cid:174)ğ‘™, the sender will be a hash value ğ» (ğ‘˜)
to the payment routing, where ğ» is a cryptography hash function.
When ğ‘Ÿ receives a payment, it will compare ğ» (ğ‘˜) to the hash of
its transaction key and confirm that (cid:174)ğ‘™ intersects with ğ‘‰ğ¶ (ğ‘ ) and
ğ‘‰ğ¶ (ğ‘Ÿ ). After that, it can keep the payment and stop forwarding.

For each node along the path, it does not know the coordinates
of the sender or the receiver. The only information it could obtain
is (cid:174)ğ‘™. Each node can determine which DT neighbor is the next hop
according to the direction function. Besides, we also need to con-
sider the capacity of the channel. After a node determines the next
hop DT neighbor, it needs to check if the channel or multi-hop
path has enough capacity to support the payment. If not, the pay-
ment fails. We show the pseudo-code of the forwarding protocol

7

ğ‘ ğ‘£(cid:2869)ğ‘£(cid:2870)ğ‘£(cid:2871)ğ‘£(cid:2872)ğ‘£(cid:2873)ğ‘Ÿmalicious nodeğ‘(cid:2869)ğ‘(cid:3038)(a) A path by WebFlow-PE(b) An example of malicious nodes on the path(a) Channel Size Distribution of Ripple

(b) Transaction Size Distribution of Ripple

(c) Channel Size Distribution of Lightning

(d) Transaction Size Distribution of Lightning

Figure 8: Transaction dataset and channel size distribution used for real-world evaluations.

of WebFlow-PE at each node ğ‘¢ along the path in Algorithm 2 in
Appendix A.

Different from MDT-based routing protocol, we first find a path
for the payment and then probe the path to see if it has enough
capacity to support the payment. Since the path is pre-determined,
and it is static routing, it is more likely to fail than MDT-based rout-
ing protocol which is dynamic routing that combines the probing
and path finding process at the same time. We mentioned that the
direction function (cid:174)ğ‘™ can be the equation of any line intersecting the
Voronoi regions of the sender and receiver. If the path formed by the
first chosen (cid:174)ğ‘™ cannot support the payment, we may slightly adjust
the direction function (cid:174)ğ‘™ to form another path. But the question of
this naive thought is that it will not change the path a lot. And we
cannot determine whether it will increase the maximum capacity
of the path or decrease it, unfortunately. So it is not worth it to
find other paths by generating some different direction function
(cid:174)ğ‘™. It may not help a lot or even worsen the case while increasing
the probing overhead. So we simply assume a payment failed if the
path formed by the first chosen (cid:174)ğ‘™ does not have enough capacity to
support the payment.

Note that the only difference between MDT-based WebFlow and
WebFlow-PE is the forwarding protocol, and all the other designs
keep the same. So the users of WebFlow can easily switch between
these two routing protocols based on their demands, higher success
ratio, or better privacy.

6 PRIVACY ANALYSIS
We analyze the sender and recipient anonymity of our system in this
section. Our anonymity measurement follows the anonymity defi-
nition by Pfitzmann et al. [27]. We quantify WebFlowâ€™s anonymity
parameterized by:

â€¢ ğ‘ : network size,
â€¢ ğ‘“ : fraction of malicious nodes in the network,
â€¢ ğ¿: number of relay groups in a path, the average path

length,

â€¢ ğœŒ: average node degree.

ğ»ğ‘š (ğ‘‰ ) = âˆ’ (cid:205)ğ‘¢âˆˆğ‘‰ ğ‘ğ‘¢ğ‘™ğ‘œğ‘”2 (ğ‘ğ‘¢ )

The anonymity measure uses the entropy metric defined in Sec. 3.2,
as ğ» (ğ‘‰ )
. We show why the entropy metric is
better than the straightforward metric of the probability that the
attacker knows the sender or receiver in Appendix A.

log2 ( |ğ‘‰ |)

malicious nodes standing on the path, they can just guess some
nearby nodes with a higher probability to be the recipient. For
those payments that do not go through the attacker ğ´, all nodes
look equally likely to be a sender to ğ´. The probability of a path
that avoids the attacker is:

ğ‘ƒ =

(cid:1)

(cid:0)ğ‘ âˆ—(1âˆ’ğ‘“ )
ğ¿
(cid:0)ğ‘
ğ¿

(cid:1)

(3)

For those payments that unfortunately go through the attacker,
we can analyze the anonymity of the system using the entropy
definition. The anonymity measure of the system is:

ğ‘€ = (1 âˆ’ ğ‘ƒ) Ã—

âˆ’ (cid:205)ğ‘¢ âˆˆğ‘‰ ğ‘ğ‘¢ğ‘™ğ‘œğ‘”2 (ğ‘ğ‘¢ )
log2 (|ğ‘‰ |)

+ ğ‘ƒ Ã— 1

(4)

When there is an attacker on the path, if itâ€™s the last hop, it knows
the destination for sure. Otherwise, it will guess that the probability
of its nearby nodes to be the sender or recipient is ğ‘ğ‘¢ = 1
ğ¿Ã—ğœŒ . And
1âˆ’ 1
to
ğ¿
ğ‘ Â·(1âˆ’ğ‘“ )âˆ’ğœŒ

for other nodes, they have the same probability ğ‘ğ‘¢ =
be the sender or recipient.

In WebFlow-PE, same with MDT-based WebFlow, if a payment
does not go through the attacker, anonymity can be guaranteed.
What different is that, even if the adversary stands on the path
of payment, it can only guess its next hop to be the recipient and
its last hop to be sender with a probability 1
ğ¿ . If a path has more
than one malicious node standing on it, these malicious nodes can
collude to infer some information about this payment. For example,
they know that all nodes along the path between them cannot be
the sender or the recipient. Since they know the average length of
paths in the system according to historical data, they are more likely
to infer the sender and recipient. Figure 7(b) shows an example.
We assume that there are k malicious nodes on this path. For the
node ğ‘1, ğ‘ğ‘˜ and one hop before/after ğ‘1 and ğ‘ğ‘˜ respectively, the
.
probability of them to be the sender or recipient is: ğ‘ğ‘¢ =

1
ğ¿âˆ’(ğ‘˜âˆ’2)

For other neighbors of ğ‘1, ğ‘ğ‘˜ , they cannot be the sender or
recipient for certain. Since ğ‘1, ğ‘ğ‘˜ do not know who are the nodes or
how many nodes between them along the path, all the other nodes
except their neighbor looks equally to them. These nodes have the
1
same probability to be the sender or recipient: ğ‘ğ‘¢ = (1 âˆ’
ğ¿âˆ’(ğ‘˜âˆ’2) ) Â·
1
ğ‘ âˆ’2ğœŒâˆ’2 .

In MDT-based WebFlow, only the sender knows the source of
payment. All nodes along the path as well as some of their neighbors
only know the virtual coordinates of the recipient. So if there exist

Compared with both two versions of WebFlow, in landmark
routing such as SilentWhispers, once a landmark is compromised,
the system will have no privacy.

8

1001051010Channel Size (USD)00.20.40.60.81CDFmean = 8.312e+18median = 25010-1010-51001051010Transaction Size (USD)00.20.40.60.81CDFmean = 2.175e+10median = 300.511.52Channel Size (Satoshi)10700.20.40.60.81CDFmean = 2.927e+6median = 5e+510010510101015Transaction Size (Satoshi)00.20.40.60.81CDFmean = 1.901e+8median = 1.290e+6(a) Ripple

(b) Lightning

(c) Waxman

(d) Scale-free

Figure 9: Storage cost compared with benchmarks.

(a) Ripple

(b) Lightning

(c) Scale-free

(d) Waxman

Figure 10: Communication cost compared with benchmarks.

We will show the simulation results on the comparison of privacy

measures of different methods in the next section.

7 PERFORMANCE EVALUATION
In this section, we evaluate the performance of WebFlow comparing
to the existing off-chain routing algorithms, using both simula-
tion and prototype implementation. The evaluation aims to
answer the following research questions:

â€¢ How does the WebFlow routing perform with regard to
success ratio, success volume, and overhead under realistic
PCN topologies and traces?

â€¢ How do link capacity and network load affect WebFlowâ€™s

performance?

â€¢ How do these results compare to the performance of other

approaches?

7.1 Methodology
We study WebFlow with two real-world PCN topologies: Ripple [3]
and Lightning [20], as well as synthesis topologies. For real-world
PCNs, We grab the data from January 2013 to November 2016,
and remove nodes with only a single neighbor and links with no
funds from the topology. After processing, we get the network
topology with 1,870 active nodes and 17,416 edges in our simulation.
Similarly, we get the Lightning network topology with 2,511 nodes
and 36,016 edges on one day of December 2018 [25]. Since the
lightning network preserves the privacy of link balances, we cannot
get the exact balance distribution on the link. However, we still
can get the range of the link balance. Then, we evenly assign funds
over both directions of a link.

We generate payments by randomly sampling the Ripple trans-
actions for the Ripple topology. Due to the lack of sender-receiver
information in the trace of the Lightning network, we randomly

9

sample the transaction volumes and sender-receiver pairs. The dis-
tribution of transaction sizes and channel size is shown in Figure 8.
70% of the transactions in Ripple is less than 100$, and 70% of the
transactions in Lightning is less than 107 Satoshi. So we treat pay-
ments less than 100$ and 107 Satoshi as small payments in Ripple
and Lightning respectively. We assume that payments arrive at
senders sequentially. Concurrent payments will be considered in
the future work.

According to the observation of these two real-world topologies,
we additionally build two sets of synthesis PCN topologies based on
Waxman topology generation [26] and scale-free network model [6].
The link balances are assigned similar to those of Ripple. The pay-
ments are also generated by mapping the Ripple transactions to the
simulated topologies.

Benchmarks. We compare both routing methods of WebFlow -
MDT-based WebFlow (WF) and WebFlow-PE (WF-PE) - with the
following off-chain routing algorithms.

SilentWhispers (SW) [15]: A landmark-centered routing algo-
rithm in which nodes always send funds to landmarks, and rely on
landmarks to find the path. We set the number of landmarks to 3.
SpeedyMurmurs (SM) [21]: An embedding-based routing algo-
rithm that relies on assigning coordinates to nodes to find shorter
paths with reduced overhead. We set the number of landmarks to 3
as [21] suggests.

Spider [23]: The off-chain routing algorithm which considers
the dynamics of link balance. It balances paths by using those with
maximum available capacity, following a waterfilling heuristic. It
uses 4 edge-disjoint paths for each payment.

Flash [25]: The off-chain routing algorithm which differentiates
the treatment of elephant payments from mice payments. We set
the number of preserved paths for each receiver in mice payment
routing to 4, and the number of preserved paths for elephant routing

SPSMSWSpiderFlashWFWF-PESchemes102103104105Average states maintained in each nodeSPSMSWSpiderFlashWFWF-PESchemes102103104105106107Average states stored in each node (Bytes)SPSMSWSpiderFlashWFWF-PESchemes102103104105106107Average states stored in each node (Bytes)SPSMSWSpiderFlashWFWF-PESchemes102103104105106107Average states stored in each node (Bytes)SPSMSWSpiderFlashWFWF-PESchemes024681012Number of Probing MessagesSPSMSWSpiderFlashWFWF-PESchemes024681012Number of Probing MessagesSPSMSWSpiderFlashWFWF-PESchemes051015Number of Probing MessagesSPSMSWSpiderFlashWFWF-PESchemes0510152025Number of Probing Messages(a) Succ. ratio with all transactions

(b) Succ. volume with all transactions

(c) Succ. ratio with small transactions (d) Succ. volume with small transactions

Figure 11: Performance with varying transaction numbers in Ripple.

(a) Succ. ratio with all transactions

(b) Succ. volume with all transactions

(c) Succ. ratio with small transactions (d) Succ. volume with small transactions

Figure 12: Performance with varying transaction numbers in Lightning network.

to 20. The elephant-mice threshold is set such that 90 % of payments
are mice.

Shortest-Path (SP): It serves as the baseline. SP uses the path
with the fewest hops between the sender and receiver to route a
payment.

Metrics. We use communication and storage costs as the pri-
mary metrics for scalability. Similar to prior work [21, 25], we also
use success ratio and success volume as evaluation metrics for
resource utilization. Besides, we evaluate the anonymity of the
system. The success ratio is defined as the percentage of successful
payments whose demands are met overall generated payments. The
success volume describes the total size of all successful payments,
which is the throughput of the network. Before sending payments,
nodes need to probe the usable capacity of the candidate paths.
The number of probe messages describes the communication cost,
which is the probing overhead. The storage cost is computed by the
average number of distinct neighbors a node needs to know (and
store) to perform routing, including the coordinates of its neighbors
and the information of its related links. The definition of anonymity
of the system is defined in Section 6. We report the average results
over 5 runs.

7.2 Overall Performance and Overhead
We now evaluate the performance of WebFlow with different set-
tings of PCNs.

Storage cost in each node. We now show the storage efficiency
of WebFlow by comparing the average states maintained in each
node. In Shortest Path, Spider and Flash, every node needs to locally
store the topology of the network, including all the information of
the links. Besides, in Flash, each node needs to maintain a routing
table for each payment, and periodically refreshed it when the
local network topology updates. In SilentWhispers, the landmarks
need to store the network topology as well as the paths to all the

nodes. Each node only maintains the paths to all the landmarks.
For SpeedyMurmurs, the coordinate is assigned according to the
landmarks, and the length of the coordinate is depending on the
depth of the node in the spanning tree. Since there are always
several landmarks in the system, each node has to store several
coordinates. Different from these schemes, in WebFlow, nodes only
need to maintain the information of their neighbors, including
the coordinates and the links to them. Figure 9 shows the average
states maintained in each node. For both Ripple and Lightning, both
versions of WebFlow cost less than other routing algorithms.

Communication cost. We first evaluate communication cost
to see if our algorithms can achieve low overhead of routing. The
communication cost is computed as the total number of probing
messages sent over the network. Since SilentWhispers, SpeedyMur-
murs, Shortest Path, and WebFlow-PE are static routing schemes,
we consider the number of probing messages the same as their path
length. Spider and Flash use multiple paths. They first select several
paths and make payments after probing the path. Moreover, Flash
only probes a path when it cannot deliver the payment in full. So
the number of probing messages along a path is proportional to
the number of hops of the path in Spider and Flash. MDT-based
WebFlow only does probing if a node needs to reach a multi-hop
DT neighbor. In this case, the node will probe the path to its DT
neighbor to see if the path has enough capacity to support the
payment. Thus the number of probing messages might be even
less than the hop counts. Figure 10 shows the comparison results
with 1000 transactions. The results here demonstrate that WebFlow
indeed efficiently reduce the probing message overhead compared
to state of the art in all of the four topologies.

Performance with different network load. We also vary the
number of transactions to test the performance of our system with
different loads. With the increase of the number of transactions, the
success ratio of all schemes decreases in both Ripple and Lightning

10

10002000300040005000600070008000900010000Number of transactions55606570758085Succ. Ratio(%)WFFlashSpiderSWSMWF-PE10002000300040005000600070008000900010000Number of transactions01234567Succ. Volume(USD)106WFFlashSpiderSWWF-PESM10002000300040005000600070008000900010000Number of transactions6065707580859095Succ. Ratio(%)WFFlashSpiderSMSWWF-PE10002000300040005000600070008000900010000Number of transactions012345678Succ. Volume(USD)104WFFlashSpiderSWSMWF-PE10002000300040005000600070008000900010000Number of transactions4050607080Succ. Ratio(%)SpiderSWWFFlashWF-PESM10002000300040005000600070008000900010000Number of transactions-2024681012Succ. Volume(Satoshi)1010WFFlashSpiderSWWF-PESM10002000300040005000600070008000900010000Number of transactions657075808590Succ. Ratio(%)WFFlashSpiderSMSWWF-PE10002000300040005000600070008000900010000Number of transactions02468101214Succ. Volume(Satoshi)109WFFlashSpiderSWWF-PESMFigure 13: Routing succ. ratio
in Ripple

Figure 14: Routing succ. ratio
in Lightning

Figure 15: Anonymity of Rip-
ple

Figure
Lightning

16: Anonymity of

topologies as shown in Figure 11 and 12. This is because as more
transactions flowing into the network, more links are saturated in
one direction, making them cannot be used for future transactions.
Note that in both topologies, the success ratio of the case that only
considers small transactions is always higher than the case that
considers all the transactions. The reason is that large transactions
are easier to use up the links. Besides, large transactions are less
acceptable than small ones since there are fewer links with enough
capacity to support them. In most situations, MDT-based WebFlow
shows a higher success ratio and success volume compared to other
methods. The only exception is for the success ratio of Lightning,
where WebFlow has a lower success ratio than Spider.

Choice of Dimensionality. We perform experiments for rip-
ple and lightning networks embedded in 2D, 3D, and 4D virtual
spaces and evaluate the performance in terms of success ratio. Fig-
ure 13 and Figure 14 show the results of routing performance for
the two network topologies respectively. For both topologies, 3D
outperforms 2D. For 4D, the results are not much better than those
of 3D in ripple, and even has lower success rati in lightning. This
observation is consistent with the PCA results in Fig. 5. Besides,
in a 4-dimensional space, since nodes have more DT neighbors to
maintain and have to keep the coordinates of 4-tuples, both the
storage and communication costs will increase compared to 2D and
3D. Hence, we choose 3D in all other experiments.

Anonymity. We now demonstrate the comparison of anonymity
among WebFlow and Benchmarks. WebFlow-PE shows better anony-
mity measure as shown in Figs 15 and 16. In SilentWhispers and
Flash, as long as the attacker is standing on the path, it will know
exactly who the sender or recipient is. In MDT-based WebFlow,
since the node needs to compute the distance between its neigh-
bors and recipient to find the neighbor closest to the recipient, all
the nodes along the path will know the information about the re-
cipient. In SpeedyMurmurs, although it improves privacy by using
anonymous return addresses, attackers can still infer that some
nodes may be the sender or recipient with higher probability from
the knowledge of tree constructions. In WebFlow-PE, nodes can
only know the routing direction, instead of the coordinate of the
recipient, which reduces privacy leakage. This comparing result
does follow our analysis.

7.3 Testbed Evaluation
We conduct a testbed evaluation to further investigate WebFlowâ€™s
performance. We implement the prototype in Golang with TCP for
network communication. The prototype first generates the network
topology and assigns coordinates to each node at launch time. Upon

11

Table 1: Message format in our prototype.

Field
TransID
Type
Direction
Capacity
Commit

Description
A unique ID of a (partial) payment
Message type and routing scheme
Routing direction of this message
Probed link capacity
Total funds for this payment

seeing a new payment, it runs the routing algorithm and sends it out.
we represent each node of the PCN as a single process running in the
WebFlow prototype. We build a PCN topology based on Waxman
topology generations [26]. The routing algorithm includes three
functions: distributed routing, probing, and commit. We describe
the details in the following.

Distributed Routing. It is the most important part of our sys-
tem. We implement a simple distributed routing scheme that each
node is responsible for finding the next hop based on the received
message. We show the message format of our prototype in Table 1.
Type field shows the message type, and also includes 1 bit indi-
cating the scheme of routing. The destination field contains the
coordinates of the recipient in the MDT-based WebFlow scheme,
while shows the direction function in the WebFlow-PE scheme.
Upon receiving a ROUTE message, a node can get routing direc-
tion from this field and forward it to the next hop according to
the Type field. Besides, the nodes need to record TransID, last-hop,
and next-hop locally for further commitment. Recipient returns
ROUTE_ACK if path found, and ROUTE_NACK if path not found
or with insufficient capacity. In the MDT-based WebFlow scheme,
the nodes on the reversed path will replace the direction field with
the coordinate of its last hop and forward the modified message
to it. In the WebFlow-PE scheme, the recipient simply replaces the
direction field with a reversed direction function.

Probing. It is only used in the MDT-based WebFlow since the
node needs to collect the ever-changing link balance to determine
which link to chose for the next hop. While in WebFlow-PE, the path
is determined according to the protocol. We can simply commit the
payment without probing. In MDT-based WebFlow, probing only
takes place when a node finds that a candidate next hop is a DT
neighbor. It then probes the underlying physical path of the virtual
link to check if it can support the payment. This node initiates
probing by constructing a PROBE message for the virtual link and
initiates the Capacity field to the payment value. The intermediate
nodes compare their current balances with the Capacity field. If
their balances are less than the value in the Capacity field, they
replace the Capacity field with their current balances. Otherwise,
they do nothing. After receiving the probing message, the node

10002000300040005000600070008000900010000Number of transactions65707580Succ. ratio(%)2D3D4D10002000300040005000600070008000900010000Number of transactions40506070Succ. Ratio(%)2D3D4D10-310-210-1100Fraction of Adversary00.20.40.60.81Entropy based AnonymityWF-PEWFSMSWFlash10-310-210-1100Fraction of Adversary00.20.40.60.81Entropy based AnonymityWF-PESMWFSWFlashFigure 17: Testbed results of the 50-node network.

Figure 18: Testbed results of the 100-node network.

simply compares the value in the Capacity field with the value
in the Commit field, and determine whether this virtual link can
support this payment.

Commit. It is the simple step to commit the payment. After
finding a path for the payment, or each sub-payment, the sender
sends a COMMIT message in each path. All the intermediate nodes
receiving the message search for the next hop according to the
TransID stored locally. Then they update their balances according
to the COMMIT field and forward the message to the next hop. If
an intermediate node finds that its balance is less than the payment
amount, it constructs a COMMIT_NACK message sending back to
the sender. All the nodes that receive COMMIT_NACK messages
will then recover their balances.

Figure 17 and Figure 18 show the performance with different
link capacities. The success ratio and success volume of MDT-based
WebFlow are much higher than Shortest Path in both two topologies
with a different number of nodes. This is because we consider link
capacities when routing. The results demonstrate the effectiveness
of MDT-based WebFlow which selects a good path to improve
throughput. However, the performance of WebFlow-PE is similar to
Shortest Path. The reason is that the ideas of these two algorithms
are quite similar. We both first select a path without considering
link capacities and then check if the path can satisfy the payment.
The result is still acceptable since we achieve better anonymity at
the cost of lower performance in WebFlow-PE.

8 FUTURE WORK
In this work, WebFlow achieves low storage and communication
cost in dynamic PCNs. But there are several aspects we have not
taken into consideration yet and may further investigate in future.
Multi-path. Our existing design of MDT-based WebFlow only
uses one path for small payments. For large payments, we treat them
as several small payments and find a path for each sub-payment. It
can support many payments most of the time, but in some cases,
one channel may not have enough capacity to forward the payment.
In WebFlow-PE, we even only use one determined path for both
small and large payments. So we can consider using multi-path
for a payment stuck at the bottleneck. For MDT-based WebFlow,
if a node ğ‘¢ finds that it does not have any neighbor with enough
capacity to support the payment, ğ‘¢ can then divide the payment into
several parts, and relies on several neighbors to continue routing.
And we need to set an upper bound of multi-path to prevent too
many branches of the path. In this way, we can further support more
payments in the system. For WebFlow-PE, we can also realize multi-
path by selecting several intermediate nodes first before routing.

12

Here, the intermediate nodes can be virtual nodes that do not exist.
Because they only help to generate a direction function. The sender
can first generate some pairs of coordinates randomly to be served
as virtual intermediate nodes ğ‘£1, ğ‘£2 (we use 2 as an example). And it
generates the direction function (cid:174)ğ‘™1 based on sender and ğ‘£1, (cid:174)ğ‘™2 based
on ğ‘£1 and ğ‘£2, (cid:174)ğ‘™3 based on ğ‘£2 and recipient. Then the sender can first
routing to the direction of (cid:174)ğ‘™1, followed by (cid:174)ğ‘™2 and (cid:174)ğ‘™3. By selecting
different groups of virtual intermediate nodes, the sender will find
several paths based on different direction functions.

Concurrency. In the design of WebFlow, we assume that payments
come in sequence, and we can process them one at a time. But it
is unrealistic in real-world systems. There are a large number of
payments to be processed in the system and many of them may
come together. When finding paths for these concurrent payments,
if several payments want to use the same channel while routing,
two situations might happen. First, the two paths share this channel,
but a solution needs to be found when the channel capacity is not
sufficiently high. Second, the channel is reserved in a first-come-
first-serve manner. Then we need to provide a solution to find
another path for the second transaction.

Unilateral problem. In PCNs, channels can become unidirectional
over time, and thus block further transactions through them. This
happens especially when elephant payments coming. Besides, in
some other common application scenarios such as retail payments,
the payment flows are always from the customers to merchants.
It will easily lead to channel imbalance and seriously affected the
throughput. However, in our system, we assume that all the users
are equal, and payments flow in the PCN with balance. To support
more application scenarios such as retail payments, we may further
modify our system model, such as to treat customers and merchants
differently and assume their channels have different characteristics.

9 CONCLUSION
In this work, we present the design of a scalable and decentral-
ized routing solution called WebFlow for large and dynamic PCNs.
WebFlow includes two protocols: MDT-based WebFlow and WebFlow-
PE. The first one provides a high success rate and success volume
of payments. The second one, the privacy enhancement version of
WebFlow, achieves destination anonymity by using routing with a
distributed Voronoi diagram. Both protocols demonstrate low per-
node cost and high network resource utilization. The evaluation
results using simulations and prototype implementation demon-
strate that WebFlow significantly outperforms existing solutions,
especially on per-node cost efficiency, while maintaining high re-
source utilization and success rate.

rand[1000,1500)rand[1500,2000)rand[2000,2500)Link Capacity (USD)00.10.20.30.40.50.60.70.8Succ. Ratio (%)SPWebFlowWebFlow-PErand[1000,1500)rand[1500,2000)rand[2000,2500)Link Capacity (USD)024681012Succ. Volume (USD)105SPWebFlowWebFlow-PErand[1000,1500)rand[1500,2000)rand[2000,2500)Link Capacity (USD)00.10.20.30.40.50.60.70.8Succ. Ratio (%)SPWebFlowWebFlow-PErand[1000,1500)rand[1500,2000)rand[2000,2500)Link Capacity (USD)024681012Succ. Volume (USD)105SPWebFlowWebFlow-PEREFERENCES
[1] 2019. Visa Fact Sheet. https://usa.visa.com/dam/VCOM/global/about-visa/

documents/visa-fact-sheet-july-2019.pdf. (2019).

[2] 2020. Transaction Rate of Bitcoin. http://www.blockchain.com/en/charts/

transactions-per-second. (2020).

[4]

[3] Frederik Armknecht, Ghassan O Karame, Avikarsha Mandal, Franck Youssef,
and Erik Zenner. 2015. Ripple: Overview and outlook. In Proceedings of Springer
TRUST.
I. Borg and P. J. Groenen. 2005. Modern multidimensional scaling: Theory and
applications. Springer Science & Business Media.

[5] Kyle Croman, Christian Decker, Ittay Eyal, Adem Efe Gencer, Ari Juels, Ahmed
Kosba, Andrew Miller, Prateek Saxena, Elaine Shi, Emin GÃ¼n Sirer, et al. 2016.
On scaling decentralized blockchains. In Proceedings of Springer FC.

[6] NetworkX Developers. 2014.

https://networkx.github.io/documentation/

networkx-1.9.1/reference/generated/networkx.generators.random_graphs.
barabasi_albert_graph.html. (2014).

[7] Claudia Diaz, Stefaan Seys, Joris Claessens, and Bart Preneel. 2002. Towards

[8]

measuring anonymity. In Proceedings of PET.
Ittay Eyal, Adem Efe Gencer, Emin GÃ¼n Sirer, and Robbert Van Renesse. 2016.
Bitcoin-ng: A scalable blockchain protocol. In Proceedings of USENIX NSDI.
[9] Ethereum Foundation. 2020. Ethereum Project. http://www.ethereum.org/.

(2020).

[10] Stellar Development Foundation. 2020. Stellar website. http://www.stellar.org/.

(2020).

[11] Ryan Fugger. 2004. Money as IOUs in social trust networks and a proposal for a

decentralized currency network protocol. Technical Report.

[12] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zel-
dovich. 2017. Algorand: Scaling byzantine agreements for cryptocurrencies. In
Proceedings of ACM SOSP.

[13] B. Karp and H. Kung. 2000. Greedy Perimeter Stateless Routing for Wireless

Networks. In Proceedings of ACM Mobicom.

[14] Simon S Lam and Chen Qian. 2011. Geographic routing in d-dimensional spaces
with guaranteed delivery and low stretch. In Proceedings of ACM SIGMETRICS.
[15] Giulio Malavolta, Pedro Moreno-Sanchez, Aniket Kate, and Matteo Maffei. 2017.
SilentWhispers: Enforcing Security and Privacy in Decentralized Credit Net-
works.. In Proceedings of USENIX NDSS.

[16] Petar Maymounkov and David Mazieres. 2002. Kademlia: A peer-to-peer infor-
mation system based on the xor metric. In International Workshop on Peer-to-Peer
Systems. Springer, 53â€“65.

[17] Pedro Moreno-Sanchez, Aniket Kate, Matteo Maffei, and Kim Pecina. 2015. Pri-
vacy preserving payments in credit networks. In Proceedings of USENIX NDSS.
[18] Satoshi Nakamoto. 2019. Bitcoin: A peer-to-peer electronic cash system. Technical

Report. Manubot.

[19] TS Eugene Ng and Hui Zhang. 2002. Predicting Internet network distance with

[20]

coordinates-based approaches. In Proceedings of IEEE INFOCOM.
Joseph Poon and Thaddeus Dryja. 2016. The bitcoin lightning network: Scalable
off-chain instant payments. (2016).

[21] Stefanie Roos, Pedro Moreno-Sanchez, Aniket Kate, and Ian Goldberg. 2017.
Settling payments fast and private: Efficient decentralized routing for path-based
transactions. In Proceedings of USENIX NDSS.

[22] Andrei Serjantov and George Danezis. 2002. Towards an information theoretic

metric for anonymity. In Proceedings of PET.

[23] Vibhaalakshmi Sivaraman, Shaileshh Bojja Venkatakrishnan, Kathleen Ruan,
Parimarjan Negi, Lei Yang, Radhika Mittal, Giulia Fanti, and Mohammad Alizadeh.
2020. High Throughput Cryptocurrency Routing in Payment Channel Networks.
In Proceedings of USENIX NSDI.
Jiaping Wang and Hao Wang. 2019. Monoxide: Scale out blockchains with
asynchronous consensus zones. In Proceedings of USENIX NSDI.

[25] Peng Wang, Hong Xu, Xin Jin, and Tao Wang. 2019. Flash: efficient dynamic

[24]

routing for offchain networks. In Proceedings of ACM CoNEXT.

[26] Bernard M Waxman. 1988. Routing of multipoint connections. Proceedings of

IEEE JSAC.

[27] Li Zhuang, Feng Zhou, Ben Y Zhao, and Antony Rowstron. 2005. Cashmere:

Resilient anonymous routing. In Proceedings of USENIX NSDI.

13

A APPENDIX
A.1 Pseudocode

Algorithm 1 MDT-based WebFlow Forwarding Protocol at node ğ‘¢
Input: A payment sent to ğ‘Ÿ with demand ğœ”
Output: Next hop ğ‘£
1: if ğ‘‘ (ğ‘¢, ğ‘Ÿ ) == 0 then
2:
3: //Case 1: Search for direct neighbors
4: if there exists ğ‘£ |ğ‘£ âˆˆ ğ¶ğ‘¢ closest to the recipient then
5:

return ğ‘¢

if ğœ“ğ‘¢ğ‘£ â‰¥ ğœ” then
return ğ‘£

for each node ğ‘£ in ğ¶ğ‘¢ do

if ğ‘‘ (ğ‘£, ğ‘Ÿ ) < ğ‘‘ (ğ‘¢, ğ‘Ÿ ) and ğœ“ğ‘¢ğ‘£ â‰¥ ğœ” then

return ğ‘£

10:
11: //Case 2: Search for DT neighbors
12: if there exists ğ‘£ |ğ‘£ âˆˆ ğ‘ğ‘¢ closest to the recipient then
13:

Probe each channel of the virtual link from ğ‘¢ to ğ‘£ to obtain
their capacity ğœ“ğ‘
Find the bottleneck capacity ğœ”ğ‘šğ‘–ğ‘› = min ğœ“ğ‘
if ğœ”ğ‘šğ‘–ğ‘› â‰¥ ğœ” then

14:

15:

6:
7: else
8:

9:

return ğ‘£

16:
17: else
18:

i = 0
for each node ğ‘£ in ğ‘ğ‘¢ do

if ğ‘‘ (ğ‘£, ğ‘Ÿ ) < ğ‘‘ (ğ‘¢, ğ‘Ÿ ) and ğ‘– â‰¤ 5 then

ğ‘– + +
Probe each channel of the virtual link from ğ‘¢ to ğ‘£ to
obtain their capacity ğœ“ğ‘
Find the bottleneck capacity ğœ“ğ‘šğ‘–ğ‘› = min ğœ“ğ‘
if ğœ“ğ‘šğ‘–ğ‘› â‰¥ ğœ” then

19:

20:

21:

22:

23:

24:

25:
26: return Ã¸

return ğ‘£

Algorithm 2 WebFlow-PE Forwarding Protocol at node ğ‘¢
Input: The line with a direction (cid:174)ğ‘™ and demand ğœ”
Output: Next hop ğ‘£
1: // Case 1: ğ‘¢ is the recipient ğ‘Ÿ
2: if ğ‘¢ = ğ‘Ÿ then
return ğ‘¢
3:
4: // Case 2: continue routing
5: for each edges ğ‘’ğ‘– of ğ‘¢â€™s Voronoi region do
6:

Find ğ‘¢ğ‘– whose Voronoi region sharing edge ğ‘’ğ‘–
if ğ‘¢ğ‘– is not the last hop then

ğ‘£ = ğ‘¢ğ‘–
Probe each channel of the virtual link from ğ‘¢ to ğ‘£ to obtain
their capacity ğœ“ğ‘
Find the bottleneck capacity ğœ”ğ‘šğ‘–ğ‘› = min ğœ“ğ‘
if ğœ”ğ‘šğ‘–ğ‘› â‰¥ ğœ” then

return ğ‘£

else

return False

7:

8:

9:

10:

11:

12:

13:

14:

14

A.2 Privacy Metric
Why the entropy metric is better than the straightforward
metric of the probability that the attacker knows the sender
or receiver. The entropy definition of the system is more precise
than the straightforward probability definition of the probability
that the attacker knows the sender or receiver. For example, let us
consider sender anonymity in a network of 10000 nodes. In the first
system ğ‘†1 with attacker ğ´:

â€¢ ğ´ discovers the source of 10% of payments;
â€¢ ğ´ can limit sources of 30 % of payments to a small subset

of nodes, ğ‘’.ğ‘”. 50;

â€¢ For the other 60 % of payments, all nodes look equally

likely to be a sender to ğ´.
In another system ğ‘†2, the attacker ğ´:

â€¢ ğ´ discovers the source of 10% of payments;
â€¢ For the other 90 % of payments, all nodes look equally

likely to be a sender to ğ´.

Using the probability that ğ´ knows the sender or recipient to mea-
sure the anonymity of the system, ğ‘†1 and ğ‘†2 can achieve the same
anonymity of 0.9. In contrast, by entropy definition, the anonymity
of system ğ‘†1 is:

AS(ğ‘†1) = 10% Ã— 0 + 30% Ã—

âˆ’50Ã—log2
âˆ’10000Ã—log2

1
50

1
10000

+ 60% Ã— 1 = 0.60

And anonymity of system ğ‘†2 is:
AS(ğ‘†2) = 10% Ã— 0 + 90% Ã— 1 = 0.90.
Results show that ğ‘†2 has better anonymity than ğ‘†1. It true since
the attacker in ğ‘†1 knows more information about the sender than
that in ğ‘†2. So we know that the entropy definition provides better
evaluation of the system anonymity.

15

