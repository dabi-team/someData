SoK: TEE-assisted Conﬁdential Smart Contract

Rujia Li ∗†ð Qin Wang ‡ð, Qi Wang ∗, David Galindo †, Mark Ryan †
∗ Southern University of Science and Technology, China.
† University of Birmingham, United Kingdom.
‡ CSIRO Data61, Australia.

2
2
0
2

r
p
A
0
2

]

R
C
.
s
c
[

2
v
8
4
5
8
0
.
3
0
2
2
:
v
i
X
r
a

Abstract—The blockchain-based smart contract lacks privacy
since the contract state and instruction code are exposed to the
public. Combining smart-contract execution with Trusted Exe-
cution Environments (TEEs) provides an efﬁcient solution, called
TEE-assisted smart contracts, for protecting the conﬁdentiality of
contract states. However, the combination approaches are varied,
and a systematic study is absent. Newly released systems may fail
to draw upon the experience learned from existing protocols, such
as repeating known design mistakes or applying TEE technology
in insecure ways. In this paper, we ﬁrst investigate and categorize
the existing systems into two types: the layer-one solution and
layer-two solution. Then, we establish an analysis framework to
capture their common lights, covering the desired properties (for
contract services), threat models, and security considerations (for
underlying systems). Based on our taxonomy, we identify their
ideal functionalities, and uncover the fundamental ﬂaws and
reason for the challenges in each speciﬁcation’s design. We believe
that this work would provide a guide for the development of
TEE-assisted smart contracts, as well as a framework to evaluate
future TEE-assisted conﬁdential contract systems.

Index Terms—Conﬁdential Smart Contract, Blockchain,

Trusted Execution Environment (TEE)

I. INTRODUCTION

Smart contract was originally introduced by Szabo [1]
and further developed by Ethereum [2] in the blockchain
systems. The blockchain-based smart contracts [3], [4], [5]
adopt Turing-complete scripting languages to achieve com-
plicated functionalities [6] and execute the predeﬁned logic
through state transition replication over consensus algorithms
to realize ﬁnal consistency. Smart contracts enable unfamil-
iar and distributed participants to fairly exchange without
trusted third parties, and are further used to establish a
uniform approach for developing decentralized applications
(DApps [7]). However, blockchain-based smart contract lacks
conﬁdentiality. The state information and the instruction code
are completely transparent [8], [9], [10]. Any states with
their changes are publicly accessible and all users’ transaction
data and contract variables are visible to external observers.
Without privacy, building advanced DApps that rely on the
user’s sensitive data becomes a challenge [11], [12], [13],
[14]. For instance, smart contracts in Ethereum [2] cannot
be directly applied to Vickrey auction [15], [16] or e-voting
systems [17], [18], where the bid and vote require to be hidden
from the public. Moreover, DApps without privacy protection
might be prohibited by European Union because they go
against the General Data Protection Regulation [19], [20].

(cid:63): This paper has been accepted by PETs 2022.
ð: These authors contributed equally to this work.

Thus, the complete transparency of smart contracts constrains
their wide adoption. Recently, researchers have explored many
cryptographic solutions to solve these issues, including uti-
lizing techniques of zero-knowledge proof (ZKP) [21], [22],
[12], [23], [24], [25], homomorphic encryption (HE) [26] and
secure multiparty computation (MPC) [27]. However, these
approaches are merely applicable to applications requiring
simple computations.

Moving complex computations into secure hardware can
provide applications with privacy as well as good performance.
The use of the trusted execution environments (TEEs) [28],
[29], [30], [31], [32] becomes thus a general-purpose solution
for conﬁdential smart contracts. The TEE is a new feature
provided by recent commodity processors. It has the ability
to provide secure environments for running contract code
in isolation while guaranteeing execution integrity and state
conﬁdentiality. For instance, Intel(cid:114) Software Guard Extension
(Intel(cid:114) SGX) [33], [34], [35], [36] allows a user to create
a secure area called enclave. Afterwards, the user unitizes
the remote attestation protocol
to prove to remote parties
that the applications are indeed running inside an enclave.
Then, the enclave establishes a secure channel to communicate
with remote hosts, where the messages are encrypted. In this
way, SGX runs trusted codes in an enclave and uses the
CPU hardware to prevent attackers from seeing or tampering
with sensitive data. Such a technique provides the high-
level security for inside processes to resist attacks against
outside software, even the most privileged instruction from
the operating system. As a promising alternative, various
smart contract platforms taking advantages of TEEs have been
proposed, especially by companies working on consortium
blockchain platforms, such as Alibaba CONFIDE [37], Visa’s
LucidiTEE [38] and China’s CHANG’AN Chain [39], [40].

Although various TCSC protocols have been proposed,
newly released projects may fail to draw upon the experience
learned from existing protocols, such as repeating known de-
sign mistakes or applying cryptography in insecure ways. For
example, an absence of economic incentives will pose security
risks and decrease the protocol’s stability. However, the recent-
proposed TCSC scheme Hybridchain [41] repeats similar
pitfalls by simply combining the TEE with a permissioned
blockchain network, omitting considerations on the miner’s
incentive mechanism. The repeating of pitfalls comes from
twofold. Firstly, in-the-wild projects differ from one to another,
and a relatively unique model is absent, which narrows the
developers’ vision. Meanwhile, a uniﬁed evaluation framework

 
 
 
 
 
 
is missing, causing many security threats to be uncovered and
resulting in considerable loss from applications underpinning
the execution of conﬁdential smart contracts. This paper aims
to abstract a high-level framework to simply and clearly
systematize knowledge on current TCSC schemes. We attempt
to capture some commonalities among these projects regarding
their features, properties, and potential security vulnerability.
We believe that establishing evaluation criteria to measure
features and identify problems and ﬂaws of existing TCSC
protocols will offer a good guide for industry communities
and promote the DApps prosperity. Main contributions (a
visualized guideline in Fig.2) are:

• We provide a systematization of existing TCSC systems
driven from academic work and in production projects.
Based on their operating mechanisms and ways of com-
bination, we investigate and categorize a set of typical
the layer-one
protocols into two main classiﬁcations:
solution and the layer-two solution.

• We establish a uniﬁed evaluation framework for conﬁ-
dential smart contract systems. We consider two parts:
the smart contracts used as services, and underlying sup-
ported blockchain systems. Accordingly, the framework
covers three aspects: desirable properties for contract
threat model and security consideration for
services,
underlying systems. Speciﬁcally, we discuss two dif-
ferent types of desirable properties: typical properties
that inherit from traditional smart contracts and featured
privacy-related properties. Then, we emphasize practical
issues, pitfalls, and remedies in designing TEE-assisted
blockchains from four aspects (host/TEE/program secu-
rities and key management services).

• We conduct a comparative analysis of existing protocols
based on our evaluation framework. We discuss systems
both from their common designs (system classiﬁcation,
threat model) and distinguishing features (designs, prop-
erties). The common designs show us the consistent idea
when re-designing the system, while the distinguished
features highlight the ingenuity of each system design
that deviates from others (see Tab.III/Tab.IV).

• We further give a comprehensive discussion of current de-
signs and implementations, including a running example,
comparisons between layer-one and layer-two systems
from the perspectives of security, efﬁciency and easy-
adoption, and common issues on public veriﬁability.
Unfortunately, a mature design is still not ready for
large-scale applications. We thereby point out research
challenges in this ﬁeld, wishing to give insights for
communities on deﬁning their models and discovering
possible solutions of designing TCSC systems.

The rest of the paper is organized as follows. Sec.II gives
a high-level introduction on how to operate a conﬁdential
inside TEEs. Sec.III provides the system-
smart contract
atization methodology (system classiﬁcation and evaluation
framework). Layer-one and layer-two systems are analysed
in Sec.IV and Sec.V, respectively. Discussions are provided

in Sec.VI. Research challenges are summarised in Sec.VII.
Finally, Sec.VIII gives concluding remarks. Supplementary
details are stated in Appendix A-D.

II. A LIGHTNING TOUR

This section gives a high-level description and offers a
running example to illustrate how a typical conﬁdential smart
contract operates. From existing literature [42], [43], [41],
[44], [45], [46], establishing a conﬁdential smart contract
mainly requires four steps, namely invocation, computation,
consensus and response (see Fig. 1).

A. Overview

Invocation. In current blockchain systems, once a contract is
deployed successfully, the initial state and operational code
are replicated to distributed nodes. The state transition must
be based on an external message call that is represented as a
transaction Tx sent from a user. The TEE-assisted conﬁden-
tial contract, as a special type of smart contract, inherits the
state-triggering mechanism. The major difference between
conﬁdential contracts and original protocols lies in whether
a transaction has to carry the ciphertext cu encrypted by the
TEE’s public key.

Figure 1: TEE-assisted conﬁdential smart contract workﬂow.

Computation. Once receiving an invocation request (Tx with
an encrypted argument of cu) from the user, a TEE decrypts
the ciphertext cu and loads the contract source code and cur-
rent encrypted contract state cb fetched from the blockchain.
Then, the TEE decrypts the state cb using a TEE service
key, executes the contract logic, and outputs an execution
result mb. Afterwards, the TEE encrypts mb with a speciﬁc
user’s public key and obtains the ciphertext c(cid:48)
b. Next, the
TEE sends c(cid:48)

b to the blockchain network.

Consensus. After obtaining the encrypted state c(cid:48)

b carried by
Tx, the consensus algorithm starts to reach an agreement
over distributed nodes. In particular, when a blockchain
node receives a newly mined block, it will re-execute all
transactions inside the block. When a majority of consen-
sus nodes receive the same block and re-execute included
transactions, the state c(cid:48)
b with its carrier Tx is deemed to be
conﬁrmed and becomes immutable.

Response. The blockchain returns the ﬁnal state c(cid:48)

b and its
corresponding transaction Tx to the user, and this user
decrypts the ciphertext c(cid:48)
b to obtain the ﬁnal state. To be

2

emphasized, even the state c(cid:48)
b is publicly accessible, only the
user who owns the private key can obtain the ﬁnal plaintext.

B. An Running Example

From a bird’s eye view, a TCSC can be used as an ideal
contract-based black box [47] with secrecy and correctness.
This idea has been adopted by several advanced security
protocols [48], [49]. We provide a secret e-voting example
borrowed from Oasislabs [50].

In this example, the number of voter’s choices is not allowed
to be revealed until the voting is ﬁnished. Meanwhile, the
voter does not want other participants to know her choice.
A high-level overview is: a voter calls the contract inside
TEEs by sending a transaction with an encrypted argument
cu. Next, the TEE decrypts the argument cu and decrypts the
current encrypted state cb using the service key (see Tab.V
and Fig. 5 in Appendix A). Afterward, TEE conﬁdentially
executes the voting logic and correspondingly returns the
message m(cid:48)
b, and sends
c(cid:48)
b to the blockchain. Eventually, the voter fetches the ﬁnal
result c(cid:48)
b from the blockchain and decrypts it with her private
key to obtain the voting result voteresult (see Tab.I).

b. Then, the TEE encrypts m(cid:48)

b as c(cid:48)

Table I: Data workﬂow of an e-voting protocol based on TEE-
assisted conﬁdential smart contracts.

Stage

Voter

TEE

Blockchain

Invocation

votedata → cu;
cu → Tx

cb;

Computation

Consensus

Response

c(cid:48)
b → voteresult

cu → data; cb →
mb; data, mb →
b → c(cid:48)
m(cid:48)
b;

b; m(cid:48)

Tx → B;
c(cid:48)
b → B;

A TCSC can be well qualiﬁed for the role of decentralized
vote manager in an e-voting system [17], [51]. Once a
contract-based manager is deployed successfully, the voting
logic is loaded into a TEE and corresponding secret keys are
privately generated and stored inside TEEs. The encrypted
state is then conﬁrmed by the blockchain nodes. This offers the
e-voting protocol with conﬁdentiality, neutrality, auditability
and accountability. Firstly, the voter’s input cu is encrypted,
and intermediate parameters (e.g., mb) are privately processed
through TEEs. External attackers cannot obtain the knowl-
edge of sensitive information, and thus the conﬁdentiality is
achieved. Secondly, the predeﬁned voting logic only occurs
in the decentralized network when certain conditions are sat-
isﬁed, bringing neutrality for the access control management.
Thirdly, if a voter wants to vote for a candidate, she needs
to in advance build a channel to the TEE and then send
a transaction Tx to call the contract. Due to the protection
of encrypted channels, transaction arguments are kept secret.
Meanwhile, such invoking records in the form of transactions
remain visible and will become immutable, ensuring the voting
process accountable. Unfortunately, veriﬁability, as one of
fundamental properties, performs not smooth in the context of

3

encryption. Contracts that are executed inside TEEs make the
execution procedures lack public veriﬁability. Only the nodes
who install TEEs with correct corresponding keys can verify
the correctness of contract executions. However, the metadata
of the transaction Tx retains unencrypted, making it possible
to verify the absence of double spending.

III. SYSTEMATIZATION METHODOLOGY

To ﬁnd common aspects (e.g., offered functionality, design
model, adversary model), we extract recurring design patterns
from publicly available publications and projects, focusing
on systematization and evaluation of desirable properties (the
main target of TCSC) and potential pitfalls of underlying
systems. Our systematization methodology follows the idea
in [52]: classiﬁcation and evaluation. We ﬁrstly make a clas-
siﬁcation for the current systems and then deﬁne a framework
to evaluate them. Details are presented as below.

A. System Classiﬁcation

We classify the existing systems into two main categories:
layer-one solution (L1) and layer-two solution (L2). The
layer-one solution executes the contract
inside a TEE in
the blockchain, requiring every blockchain node to equip
the layer-two solution decouples contract
a TEE. Instead,
computations from the blockchain. It performs most of the
smart contract computations off-chain. For a clear understand-
ing, we make a comparison of the original blockchain (e.g.,
Ethereum), L1 solution, L2 solution. As in Tab.II, Ethereum
runs smart contracts (in EVM) and consensus procedures in
the same machine of distributed nodes. All the contract and
transaction operations are publicly veriﬁable due to their total
transparency. The layer-one solution performs such operations
(contract execution and consensus) in the same machine, but
contract operations are separate from consensus procedures.
In contrast, the layer-two solution makes both of them operate
independently. Contracts are executed outside the blockchain
network, while the consensus happens inside each node.

Table II: A comparison of Ethereum, L1 and L2 solution

Ethereu m

Solution

L 1

Solution

L 2

EVM and consensus in same machine

EVM and consensus in same TEE

Contract execution publicly veriﬁable

Contract execution peer veriﬁable

Consensus procedure publicly veriﬁable

(cid:51)

-
(cid:51)

(cid:51)

(cid:51)

(cid:51)

(cid:55)

(cid:55)

(cid:51)

(cid:51)

(cid:55)

(cid:55)

(cid:55)

(cid:55)

(cid:51)

B. Desirable Property

Ideally, moving smart contract executions into TEEs brings
additional privacy as well as maintaining the original beneﬁts
of blockchain systems. Therefore, we have identiﬁed the
desirable properties in two main categories: privacy-preserving
property and blockchain intrinsic feature.

Privacy-preserving property. The property of conﬁdentiality
is the most distinguished feature in TCSC.
A1. Speciﬁcation hidden. The source code of a smart contract
is hidden during the deployment and the subsequent
synchronization and execution.

A2. Input privacy. The inputs fed into a conﬁdential smart

contract are hidden from the public.

A3. Output privacy. The outputs returned from a conﬁdential

smart contract should be kept private.

A4. Procedure privacy. The execution procedure is hidden
from unauthorized parties. An adversary cannot learn the
operation knowledge inside a TEE.

A5. Address unlinkability. The address pseudonymity does not
entail strong privacy guarantees [53], [54]. This property
prevents an adversary to learn the address linkability by
observing users’ activities.

A6. Address anonymity. The contract caller’s identity (a
user who invokes a smart contract) is hidden from an
anonymity set [24] (see Appendix B).

Blockchain intrinsic feature. TEE-assisted smart contracts
inherit features given by original blockchain systems. We
summarize these features as follows.
A7. Code immutability. Once a contract is successfully de-

ployed, its source code cannot be altered.

A8. (Conﬁdential) state consistency. Executions happening at
a certain blockchain height will output the same result
across different nodes.

A9. Contract interoperability. A smart contract can call another

contract and be called by others.

A10. High availability. A smart contract is continuously ac-

cessible without the single point of failure.

A11. Decentralized execution. A smart contract runs over the

decentralized network.

A12. Automatic execution. A smart contract can be automati-

cally executed once conditions are satisﬁed.

A13. Gas mechanism. Operations running on the smart con-

tract will be charged with gas fees [2].

A14. Explicit invocation. Each invocation will be formatted as

a transaction and stored on blockchain.

T1. User adversary (active/passive). An attacker may control

network between users and TEE host nodes.

T2. TEE adversary (active/passive). An adversary may control
the network between TEE and

TEE hosts or control
blockchain platforms.

T3. Blockchain adversary (active/passive). An adversary may
drop, modify and delay the blockchain messages. But
the majority (or two-thirds) of the blockchain nodes are
assumed to be honest.

Note that adversaries are not necessarily exclusive. In some
cases, adversaries in different types may collude.

Security considerations. This section deﬁnes four metrics
regarding system security according to the data workﬂow:
approaches to enhance the security of a TEE host, counter-
measures to mitigate intrinsic TEE issues, methods to prevent
program ﬂaws or bugs inside TEEs, and solutions to clear up
the TEE key security dilemma.
TEE host security. A TEE and its interaction with the external
environment (e.g., with users or the blockchain) are operated
and controlled by a host (such as a L1 blockchain node). A
malicious host has abilities to abort the executions of a TEE,
delay and modify inputs, or even drop any ingoing or outgoing
messages. The following metrics discuss the approaches to
improve the TEE host’s security.
P1. Host punishment mechanism. Penalty mechanisms to re-

duce the risk of doing evil by a TEE host.

P2. Host incentive mechanism. Incentive mechanisms to pro-

mote a TEE host to behave honestly.

P3. Host fault tolerance. Solutions to make systems continu-

ally operate despite malfunctions or failures.

P4. Host authentication. Methods to check the identity and

the capability of a TEE host.

TEE security. A TEE has inevitable weaknesses. For example,
a TEE is vulnerable to side-channel attacks [55], [56]. These
innate weaknesses directly pose severe challenges to the design
and implementation of TEE-assisted contract systems. This
part deﬁnes the defence approaches against these threats.
P5. TEE attestation security. Methods to prevent TEE attesta-

tion service from being abnormally broken.

A15. Public veriﬁability. The procedure of contract execution

P6. TEE memory limitation. Methods to optimize the memory

and result are publicly veriﬁable.

A16. Consensus veriﬁability. The consensus procedure on the

(conﬁdential) state is publicly veriﬁable.

C. System Evaluation

Essentially, all TCSC systems share the same principle: a
TEE will handle the data from users. After that, encrypted
data ﬂows from the TEE to blockchain. The TEE plays a
crucial role. Thus, this part deﬁnes a framework for evaluating
underlying blockchain systems from four aspects: TEE host,
TEE security, TEE program, and TEE key management. This
framework aims to identify potential design ﬂaws and pitfalls
based on the threat model and data workﬂow.
Threat model. Our threat model mainly captures three types
of attackers, which are stated as follows.

size to prevent conﬁdential data overﬂow.

P7. TEE physical attacks. Approaches to prevent physical
attacks, such as the Spectre vulnerability or the Meltdown
vulnerability [57].

P8. TEE trusted timer. Approaches to provide a trusted timer

when running a TEE.

TEE program security. Even a TEE is secure as assumed, a
program bug may destroy the contract’s conﬁdentiality in the
real world. This part focuses on the measurements to prevent
TEE programs from ﬂaws or bugs.
P9. Workload measurement. The workload measurement ap-

proach to prevent an inﬁnite loop attack.

P10. Flaws detection. Formal techniques used for the mod-
elling and veriﬁcation of the source code of smart con-
tracts to reduce the vulnerabilities.

4

Figure 2: Systematization methodology. We delineate current conﬁdential smart contract systems along two principal axes. In the horizontal
axes, we identify two types of TEE-assisted systems according to the ways of combination. In the vertical axes, we give our analysis framework
in three aspects. The property corresponds to the conﬁdential smart contract service, providing the functionalities to the end-users. The threat
model and security consideration focus on their underlying blockchain systems that support upper-layer services. With these two axes as our
research methodology, we further present the related discussions and open challenges.

P11. User query restriction. The restriction on users’ queries,
aiming to avoid data leakage resulting from differential-
privacy analysis [58].

P12. Blockchain data conﬁrmation. Methods for a TEE to
check whether input data from blockchain has been
conﬁrmed to prevent the rollback attack [59].

P13. TEE output conﬂicts. Methods to avoid multiple TEEs to

produce a conﬂict result.

TEE key security. Various keys (cf. Appendix A) are involved
in the contract execution, including TEE internal keys such
as the attestation key and TEE service keys for state en-
cryption/decryption. Since service keys directly affect
the
protection of contract states, the key security evaluation in this
SoK mainly focuses on the generation, exchange, and storage
of the TEE service key.
P14. Distributed key protocol. The keys of conﬁdential con-

tracts are managed by a distributed protocol.

P15. Key rotation protocol. The TEE replaces an old key with

a fresh key for future contract encryption.

P16. Independent contract key. Each contract is associated

with a unique key, independent from the TEE.

P17. Independent TEE key. Each TEE has a unique key, and

different contracts share the same key.

Systematization summary. The system classiﬁcation shows
a general view of the TCSC systems. Desirable property
focuses on evaluating contract service provided by a TEE-
assisted blockchain system. Threat model describes the poten-
tial threats and system assumptions. Security considerations
show the evaluating indicator for current TEE-assisted sys-
tems. In the following section IV-B and V-B, we attempt to
answer the following questions: (i) What are the potential
pitfalls in each security aspect; (ii) Do these pitfalls have
signiﬁcant security impacts; (iii) Do the designers/developers
consider these pitfalls and accordingly come up with feasible
remedies in their systems; (iv) What are the remedies and do
they address above problems. Note that hundreds of TCSC

systems have been proposed in both industry and academia.
An exhaustive analysis is undesirable and infeasible. We only
selected the projects that provide publicly accessible technical
reports or academic papers.

IV. LAYER-ONE SOLUTION

The layer-one approach enables blockchain nodes to run
contracts in their isolated areas, as well as conducting the
consensus (see Fig. 3). This approach combines the consensus
procedure and state execution, either in terms of logically or
physically. The reason why we call this method layer-one is
that all executions are completed in the same layer of the
blockchain network. The key to such an approach is to equip
every blockchain node with a TEE. Indeed, this requires more
integration efforts, but also comes with several advantages.
The smart contract can implement stateful functionalities that
receive arguments and update states instantly. In particular, a
smart contract can directly access the ledger data stored in a
local disk, greatly saving time often wasted in the interactive
network communications.

Figure 3: Layer-one execution model

System model. In a layer-one execution model, the operation
of ledger update (consensus) and state transition (contract
execution) are coupled. Like Ethereum [2], smart contracts

5

run inside blockchain nodes. Assume that a user plans to
use the private contract; she only needs to upload data to
the blockchain service and wait for results. The remaining
procedures are completed by TEE-assisted distributed nodes.
A TEE in these nodes acts as a black box for data processing
and output targeted results without the data leakage. This
approach greatly improves convenience for users due to its
easy access and management. As illustrated in Fig.3, a generic
data ﬂow goes as follows: A contract creator deploys the
code into blockchain. Then, a user sends the transaction with
an encrypted argument to an arbitrary blockchain node. Her
request is conﬁdentially executed inside TEEs in this node
and output encrypted state. Then, the consensus algorithm in
this node broadcasts the encrypted results to peers. After the
encrypted results are conﬁrmed by other blockchain nodes,
users fetch on-chain results and decrypt them for the plaintext.

A. Property Evaluation

Privacy-preserving property. This property indicates that
contract states and the procedure of contract executions are
hidden from the public. To achieve privacy, layer-one systems
execute these conﬁdential contracts inside TEEs in every
distributed node. CCF [45], Fabric [60] and CONFIDE [37]
follow this straightforward design where conﬁdential contracts
are loaded to the TEE of each consensus node, which en-
crypts both the inputs and outputs of contract states, together
with their operating logic and predeﬁned rules. Enigma1 [61]
introduces the secret network and allows users to submit
their transactions together with encrypted data to miners. We
also notice that current
layer-one solutions only focus on
internal procedures rather than the linkability and anonymity
of addresses and transactions. This indicates that conﬁdential
smart contracts only protect the contents that have been loaded
into TEEs, while the data that relates to external users is out
of the scope of this work.

Blockchain intrinsic feature. The layer-one systems inherit
most of the features empowered by blockchain. More pre-
cisely, the properties of code immutability, high availability,
explicit invocation, decentralized execution, automatic execu-
tion and consensus veriﬁability remain the same because basic
contract executions still rely on their underlying blockchain
systems. Also, the property of (conﬁdential) state consistency
in Enigma [61], CCF [45] and Fabric [60] remains unchanged.
The states and executions from these systems follow the proce-
dures of online consensus processes. Then, the returned results
from inside TEEs still require to be conﬁrmed on-chain. This
makes their actions effectively perform the same functions
as a normal smart contract, except for that the contents of
states are transmitted from plaintext to ciphertext. In contrast,
the property of contract
interoperability is lost since the
contracts are executed in isolated TEEs. This isolation requires

1Enigma’s secret network consists of a list of secret nodes equipped
with TEE, which is categorised as a layer-one solution in the context of our
deﬁnition (Sec.III-A). We also note that such a secret network can be regarded
as a layer-two solution in the traditional classiﬁcations in terms of Ethereum,
namely, either on-Ethereum chain (L1) or off-Ethereum chain (L2).

additional communications such as dispatching keys through
the remote attestation service, bringing much complexity.

B. System Evaluation

The layer-one solution encapsulates TEE computations into
blockchain nodes. Every node in the network has to take
responsibility for conducting conﬁdential executions and per-
forming the consensus. The design to coordinate TEEs and
consensus within the same physical space brings many distin-
guished features. We start the analysis from their threat model
and then dive into each component of these systems.

Threat model. Users in the layer-one approach are assumed
to be unreliable. They may have mistakes unconsciously, like
dropping messages or mis-sending transactions. Even worse,
a malicious user can arbitrarily behave like faking messages,
identities, or compromising other nodes. As for TEE hosts, an
external attacker can monitor, eavesdrop or even compromise
part of involved TEE hosts among these distributed nodes, but
cannot block all trafﬁc transmitted in communication channels.
Subsequently, a TEE is supposed to work in a good condi-
tion: The attestation service is trusted, and the cryptographic
primitives used inside TEEs are secure. Meanwhile, as for the
blockchain network, the basic systems (ledgers) are assumed
to be robust [62], [63], [64]. When running the consensus, the
majority (might be two-third, depends on speciﬁc consensus
algorithms) of nodes are assumed to be honest [65]. Also,
forging smart contract codes or states will happen in honest
blockchain nodes with a negligible possibility. Based on that,
we analyse securities from four aspects.

TEE host security. Firstly, we focus on the security of TEE
hosts, or equally,
individual nodes that run TEEs. Unlike
classical blockchain systems, there are no explicit incentive
or punishment mechanisms in this solution. This is easy to
understand: A node with malicious behaviors will be instantly
moved out of the committee and replaced by a new honest
participant. Meanwhile, due to the fact that CCF [45] and
Enigma [61] rely on Tendermint (a BFT variant) consensus
algorithm, they can tolerate at most one-third of TEE Byzan-
tine nodes. But
the sacriﬁce is the increased difﬁculty in
synchronization, especially when every node has to establish
a secure channel for communications of distributed TEEs. In
layer-one systems, host authentication is necessary. The node
who wants to join the committee has to obtain permission
from communities by proving her TEE capability. For instance,
CONFIDE [37] builds a mutual authenticated protocol (MAP)
(supported by SGX remote attestation techniques [66]) among
blockchain nodes. Any nodes joining in the network have to
pass the authentication via MAP.

TEE security. Then, we analyse TEE-level securities. Attesta-
tion service is an essential part of TEE techniques. Systems in
the layer-one solution still require such services for network
connection and veriﬁcation. Enigma [61], Fabric [60] and
CCF [45] follow the original attestation mechanism with an
implicit rule: The Intel Attestation Service (IAS) should be
reliable. However, this cannot be guaranteed in the case of

6

IAS being comprised. In contrast, CONFIDE [37] utilizes a
customized Decentralized Attestation Service to provide the
robust authentication. As for memory limitations, layer-one
systems load contract executions and consensus algorithms
into one TEE-embedded node, causing an increase in disk
and memory usage of individual nodes. Once the usage of
TEE memory runs over the predeﬁned settings, a decrease
in the performance is inevitable [34]. This may further cause
an unpredictably severe result like system crash-down. Fortu-
nately, Fabric [60] mitigates such issues by separating the op-
erations into two types (execution and ordering) and delays the
transaction-ordering procedures after state-execution. Among
them, only the state-execution parts are processed inside TEEs.
This decreases computation complexity and limits the memory
usage to a suitable range. Physical attacks like the Spectre and
Meltdown vulnerabilities [57] are intrinsic design pitfalls that
may occur inside the TEE kernel. To our knowledge, no layer-
one solutions mention them or provide the remedies.

TEE program security. Next, we focus on the program-level
security. Issues like overburdening may frequently happen,
especially when a malicious developer deploys a contract
with inﬁnite loop logic. Unlike using the gas mechanism
in Ethereum [2], systems in the layer-one model constrain
their running programs by the time-out mechanism. It sets
a threshold, namely, a suitable range of time that allows
processing contract operations. When exceeding the time-
bound,
the system will abort under-processing states and
restart a new round. As for the ﬂaw detection, no formal
techniques or veriﬁcation tools, based on our observation, have
been applied to layer-one systems. This gap needs further
exploration. Similar to the previous discussion, the properties
of data veriﬁcation (covering both user data authenticity and
blockchain data conﬁrmation) and output conﬂicts are guar-
anteed by their underlying consensus algorithms. Each time
performing the consensus, these properties are automatically
checked. For instance, Enigma [61] relies on trusted validators,
who equip with TEEs to conduct the veriﬁcation procedure.
Such validators maintain both the privacy of executions inside
TEEs and the consistency of states that connects to peers.
Once conﬂicts occur, validators will quickly make decisions
on a block and remove another conﬂicting block. Fabric [60]
performs such a process inside TEEs among committee nodes
and then submits the passed results to its abstract ordering
service. This service prevents forks caused by conﬂicting
states, as well as proving a fact that: All executed messages
are valid and integral once reaching the consensus agreement.
It should be noted that, successful consensus procedures can
merely guarantee the integrity of transactions and states, rather
than linkability and authenticity that relates to physical entities.

TEE key management. Lastly, we move to the aspect of TEE
key management. In layer-one systems, the key management
service takes over the task of creating and managing keys
for activities like attestation, veriﬁcation, encryption, etc.
To achieve the key management service among distributed
nodes, several types of designs have been proposed. CCF [45]

relies on the public key infrastructure (PKI) for certiﬁcate
issuance, management, and revocation. It creates key pairs and
dispatches them to every participated TEE, where each TEE
holder is authenticated by the certiﬁcate. Similarly, Fabric [60]
adopts an admin peer to provision the speciﬁc decryption
key to chaincode enclave during bootstrapping. Enigma [61]
setups an independent key management component to reply
to the requests for encryption. Such designs help to simplify
complex management procedures, as well as providing dis-
tinguishable keys for each TEE. However, these independent
key management services lead to centralization even they are
maintained by a group of nodes in the committee. CON-
FIDE [37] mitigates this issue by proposing a decentralized
key management protocol. Two types of keys are involved
in this protocol: the asymmetric private key used to decrypt
conﬁdential transactions from clients and the symmetric states
root key used for state encryption/decryption between the
conﬁdential engine and storage service.

C. Pros and Cons

The layer-one solution provides a highly integrated ap-

proach towards conﬁdential smart contracts.

This method (L1) retains most blockchain fea-
tures such as high availability, rollback attack re-
sistance, decentralized execution, since the con-
tract workﬂow, data structure, and usage model
are consistent with existing systems.

The layer-one solution provides a consistent interface for
users without changing the customer’s habits transformed from
non-TEE blockchain systems. A user can use the layer-one
system by directly interacting with the blockchain interface,
without considering cumbersome and complicated operations
between the TEE and blockchain. However,
the layer-one
solution still confronts several common disadvantages.

Minimizing the size of Trusted Computing Base (TCB)
contributes to the TEE security [67]. In particular, a small
TCB has fewer errors and can reduce attack surfaces. However,
complicated interactive operations for contract execution and
consensus agreement in the L1 solution greatly increase the
size of TCB. Meanwhile, TEE products have limited secure
memory. For example, in the current implementation of Intel
SGX [35], the enclave page caches are constrained to 128 MB,
and only 93 MB of those is available for applications, which
limits the concurrent execution.

Furthermore,

the layer-one solution lacks compatibility,
which means being incompatible with existing blockchain sys-
tems. The solution integrates the consensus procedure and the
contract execution into the same blockchain node, requiring
every node having to equip a TEE hardware. Nevertheless, this
requirement is difﬁcult to be fulﬁlled in a public blockchain
while already in use (e.g., Ethereum [2]).

7

V. LAYER-TWO SOLUTION

The layer-two solution is a straightforward approach that
combines the TEE and blockchain to provide smart contracts
with conﬁdentiality while keeping scalability. In such systems,
the operations of smart contracts are decoupled from their un-
derlying blockchain systems. The smart contracts are executed
in an independent layer outside blockchain systems.

Figure 4: Layer-two execution model

System model. In a general layer-two solution, the blockchain
is used as a dispute resolution layer. The smart contract is
executed outside the blockchain, making TEEs act as an agent
between users and blockchain systems. Suppose that a user
aims to use a private contract. She ﬁrst needs to compile the
original contract code, push binary codes to a TEE, and then
upload execution results to the public ledger. As illustrated in
Fig.4, we extract a generic data ﬂow as follows. A user sends
the encrypted input data to a TEE-powered node. Then, the
TEE decrypts the input data and executes the contract. After
that, the encrypted execution results are sent to the blockchain
platform for veriﬁcation and storage. Finally, the user fetches
and decrypts the blockchain-conﬁrmed results.

A. Property Evaluation

Privacy-preserving property. The conﬁdential execution is
an essential property. In layer-two systems, such as [46],
[68], [69], the contract computations run inside Intel SGX
enclaves, while TZ4Fabric [44] moves contract executions
into ARM Trusted Zone. Since the contract state-transition
process happens inside TEEs, any intermediate states remain
invisible to the outside. Meanwhile, to achieve the full life-
cycle security for a smart contract, the input sent to a TEE
and the output returned from this TEE are also required to
be encrypted. For example, in ShadowEth [68], PDOs [46],
Phala [69] and Hybridchain [41],
invocation
arguments are encrypted with the TEE public key. They can
only be decrypted within the enclave. Also, before transferring
execution results to the blockchain (or users), the intermediate
(or ﬁnal) states in an enclave are encrypted. Some variants also
enhance the privacy-preserving properties from other aspects.
In Phala [69], only authorized queries to the contract will be
answered. The smart contract source codes in ShadowEth [68]
are hidden during the procedures of deployment and synchro-
nization. This further reduces the possibility of data leakage
in subsequent contract executions. Considering a ﬁxed address

the contract

8

may expose the user who has invoked the contract, PDOs [46]
also allows the user to use pseudonym addresses for submitting
a transaction (including TEE outputs) to the blockchain.

Blockchain intrinsic feature. ShadowEth [68] and Taxa [70]
introduce an external distributed service to manage the con-
tracts, achieving the properties of code immutability, high
availability and decentralized execution. Meanwhile, layer-
two systems satisfy state consistency for reasons that
the
encrypted states of contracts in different blockchain nodes
will eventually get consistent when reaching a successful
agreement. Intuitively, the contracts deployed in layer-two sys-
tems should retain the features given by original blockchains.
However, some fundamental properties are lost when using
layer-two solutions. For example, most layer-two systems lose
contract interoperability since each contract is executed in
different machines. Among all the evaluated systems, only
Phala [69] identiﬁes this issue and proposes a command
query responsibility segregation architecture to ensure certain
interoperability. Also, public veriﬁability is a crucial property
for the blockchain since it allows each contract invocation,
and contract execution to be publicly veriﬁable. Unfortunately,
contracts are executed in TEEs so that the outputs are en-
crypted. To check whether the TEE has executed contracts
following loaded contract speciﬁcations is a non-trivial task.

B. System Evaluation

Threat model. An attacker may control the network between
users and TEE hosts. Meanwhile, TEEs are assumed to always
produce correct results, and the smart contracts inside TEEs
cannot deviate from their speciﬁcations. The main difference
compared with the assumption of layer-one systems is that an
adversary can observe the network activities between the TEE
interfaces and active blockchain nodes.

TEE host security. Several layer-two solutions adopt incentive
or punishment mechanisms to encourage TEE hosts to provide
a stable and secure environment for executing conﬁdential
contracts. For example, Fastkitten [43] and Erdstall [75],
[76] propose penalty transactions, in which a host will be
punished if its malicious behavior has been identiﬁed. In
particular, if the TEE execution is aborted, the host will be
charged according to previous deposits. In Taxa [70], every
node can identify any faulty nodes with reliable proofs for
executing further economic punishment. On another route,
TEE hosts in Phala [69] will get paid by providing their
computing resources to users. Similarly, the remuneration in
ShadowEth [68] will be transferred to TEE hosts who execute
private contracts. These mechanisms can effectively prevent
malicious TEE hosts from an economic aspect. However,
they are powerless against external threats. An adversary may
directly terminate a TEE host at any time. Even worse, the
TEE provides users with an open interface that is vulnerable
to DoS [77] or single-point attack. To overcome such issues
and achieve fault tolerance, different methods are proposed.
Fastkitten provides low-level fault tolerance by periodically
saving an encrypted snapshot of current states in enclaves. If

Table III: Desired properties for current TEE-assisted conﬁdential smart contracts

Selected Examples

Privacy-Preserving Properties

Blockchain Intrinsic Beneﬁts

hidden
privacy
Inputprivacy
Speciﬁcation
Procedure

O utputprivacy
A ddress

unlinkability
anony mity
C odeim
A ddress

execution.
C ontractinteroperability
execution
Explicitinvocation
veriﬁability
consistency
availability.
m utable
m echanism
D ecentralized
C onsensus
A uto m atic
State
G as

Public

High

veriﬁability

Layer-one

2017, Enigma [61], [71]

2018, Fabric [60]

2019, CCF [45]

2020, CONFIDE [37]

Layer-two

2016, Hawk [21],

2018, PDOs [46]

2018, ShadowEth [68]

2019, Phala [69]

2019, Ekiden [42]

2019, Fastkitten [43]

2019, Avalon [72]

2020, Hybridchain [41]

2020, COMMITEE [73]

2020, PrivacyGuard [74]

2020, TZ4Fabric [44]

2020, Taxa [70]

2021, Erdstall [75], [76]

◦

◦

◦

◦

◦

•

•

◦

◦

◦

◦

◦

◦

◦

◦

◦

◦

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

•

◦

◦

◦

◦

•

•

◦

◦

◦

◦

◦

◦

◦

◦

◦

◦

◦

◦

◦

◦

•

◦

◦

◦

◦

◦

◦

◦

◦

◦

◦

◦

◦

↓

−

−

−

−

↓

−

−

↓

−

−

−

↓

↓

−

↓

↓

−

−

−

−

−

−

−

−

−

−

−

−

−

−

−

−

−

↓

↓

↓

↓

−

↓

−

−

↓

↓

−

↓

↓

↓

↓

−

↓

−

−

−

−

−

↓

−

↓

↓

↓

↓

↓

↓

↓

↓

↓

↓

−

−

−

−

−

−

−

↓

−

↓

↓

↓

↓

↓

↓

−

↓

−

−

−

−

−

−

−

−

−

↓

↓

↓

↓

↓

↓

−

↓

↓

−

−

↓

−

−

−

−

↓

−

↓

↓

↓

↓

↓

↓

↓

−

−

−

−

−

−

−

−

−

↓

−

−

↓

−

−

−

↓

↓

↓

↓

↓

−

↓

↓

↓

↓

↓

↓

↓

↓

↓

↓

↓

↓

−

−

−

−

−

−

−

−

−

−

−

−

−

−

−

−

−

• Support;
− Beneﬁt unchanged; ↓ Beneﬁt weakened; Layer-one solutions are in Yellow background.

Optionally support; ◦ Did not support.

the enclave fails, the TEE host can instantiate a new enclave
and restart the computation starting from the encrypted snap-
shot. Similarly, Taxa [70] stores a session ﬁle for maintaining
and recovering user’s requests. However, a malicious attacker
may directly terminate the TEE host, and Fastkitten does
not tolerate such host failures. Another technical route is to
maintain a secure network. ShadowEth maintains a group of
TEE nodes to ensure consistency via a Paxos-like [78] algo-
rithm. Taxa adopts TEE-enabled computing nodes powered by
a PBFT-derived PoS [79] algorithm. Any node in the network
has the same responsibility to privately execute smart contracts
and transfer execution results to the blockchain. However, this
brings additional authentication issues. A TEE host must be
carefully authenticated to ensure her TEE capability when
joining an external network.

Meanwhile, the systems PDOs [46], Phala [69], Ekiden [42]
and COMMITEE [73] introduce an expendable and inter-
changeable solution. TEEs are stateless: any particular TEE
can be easily replaced once it has clashed or ﬁnished its task.
Unfortunately, these solutions are along with new challenges.
Firstly, even if TEEs are changeable, detecting a compromised
TEE is still difﬁcult. For instance, PDOs can re-execute a

method multiple times for the veriﬁcation. Given the same
input parameters to different TEEs, TEEs are believed to work
securely only if their outcomes match. Then, the outputs of
enclaves are allowed to commit to the blockchain. COM-
MITEE adopts master/backup TEE host mechanism. If the
master TEE host is proved to be malicious, a backup TEE
host will continue to work without communications to the
master TEE host. Nevertheless, this model increases the attack
interface and makes the whole system vulnerable. Secondly,
TEE hosts are stateless. That means, to ensure an exceptional
execution is recoverable, any persistent state must be stored in
the blockchain or a trusted third party (TTP). However, for a
non-deterministic blockchain system such as Ethereum (PoS
version) [2], verifying whether an item has been stored on the
blockchain is a non-trivial task. Meanwhile, storing data in
TTPs may lead to the single-point failure, which goes against
the blockchain’s real intention.

TEE security. A contract runs inside TEE, and heavily de-
pends on remote attestation service. The SGX-supported
blockchain systems including PDOs [46], Fastkitten [43],
ShadowEth [68], Phala [69] and Ekiden [42] assume that
Intel Attestation Service (IAS) is trusted. IAS can correctly

9

and completely report whether a certain output with crypto-
graphic material (quote [80]) is produced by SGX-enabled
hardware. However, IAS might be compromised, posing a
risk to these architectures. A compromised or hijacked remote
attestation service may maliciously report an attestation with
the wrong cryptographic material that does not belong to its
corresponding TEE hardware, breaking the promised security.
Meanwhile, a centralized service might be crashed, causing
the leakage of private states. Unfortunately, none of layer-two
schemes consider these risks in designs or implementations.

As discussed, current TEE implementations have memory
limitations for conﬁdential executions. If the memory usage
exceeds the threshold,
it may confront signiﬁcant perfor-
mance and security issues [81]. Hybridchain [41] optimizes
the storage by maintaining transaction records outside Intel
SGX. Meanwhile, TZ4Fabric [44] minimizes TCB by avoiding
all the executions inside TEEs. However, these approaches
increase the implementation complexity. A well-known fact
is that a TEE is vulnerable to physical vulnerabilities [57].
Unfortunately, very few layer-two solutions provide remedial
measures to reduce the risk of being attacked.

TEE program security. A poorly-written contract might devi-
ate from designated functionalities and further leak the secret
information. This part discusses the potential pitfalls and
remedies when deploying contracts.

In original smart contract systems, gas mechanism is a pow-
erful tool to prevent inﬁnite loop attacks [2]. Since the layer-
two systems execute smart contract outside the blockchain,
a similar mechanism must be considered. Fastkitten [43] and
Hybridchain [41] protect against such attacks by using the
timeout mechanism. Limitations are ﬁrstly deﬁned on the max-
imum amount of execution steps that allow to perform inside a
TEE per round. Then, TEE monitors smart contract operations.
If the number of execution steps exceeds a predeﬁned thresh-
old, the enclave will terminate executions. ShadowEth [68]
combines a timeout mechanism with a remuneration mecha-
nism. Similar to the gas mechanism in Ethereum [2], TEE
hosts can still gain remuneration even if a contract exits
after timeout since they provide sufﬁcient computing power.
These mechanisms effectively protect against endless loops
and denial-of-service (DoS) launched by external attackers.

The TEE itself lacks self-awareness of input data, since it
cannot distinguish which state is fresh. A lack of input data
authentication makes the system vulnerable to the rollback
attack [82], [59]. A malicious user may attempt to invoke
the conﬁdential contract many times to seek the leaked secret
information. Authentication of the user’s identity is helpful to
prevent this attack. However, none layer-two solution provides
these remedies for these potential pitfalls. On the other hand,
the TEE input may come from a non-deterministic blockchain
system [83], [84], in which deciding whether an input has
been conﬁrmed is tricky. Fastkitten [43] and COMMITEE [73]
mitigate this issue by using a checkpoint mechanism. As for
TEE output conﬂicts, Ekiden [42] uses a probabilistic proof-
of-publication protocol to avoid the ambiguous input.

After the invocation of a private contract,

the outputs
returned from TEEs are uploaded on-chain for the ﬁnal con-
ﬁrmation. But a malicious TEE host may send an exceptional
result to the blockchain. Even worse, two hosts may publish
different updates towards the same contract simultaneously.
To prevent such malicious publications and to evade conﬂicts,
PDOs [46] depends on Coordination and Commit Log (CCL)
to manage the synchronization in the execution of interacting
contracts and enables a contract owner to decide on selecting
the enclave for contract executions, which effectively avoid
conﬂicts. Phala [69] adopts an event sourcing command query
responsibility segregation architecture to scale up and avoid
conﬂicts, in which the write operations are recorded as events
and read operations can be served by the current view of
states. Again, these solutions contradict the property of de-
centralization. Ekiden [42] and ShadowEth [68] rely on the
blockchain to resolve conﬂicts resulting from concurrency. In
particular, ShadowEth [68] requires a worker to specify the
version number with a timestamp when pushing data to the
blockchain. Even miners accept different responses at ﬁrst,
they will eventually reach an agreement by comparing version
number and the timestamp, with the help of the consensus
procedure. Yet, such an approach is inefﬁcient, especially in
non-deterministic blockchain systems.
TEEs key management. PDOs [46] uses a key provisioning
service to distribute private keys. The drawback is obvious:
A compromised provisioning service could make the entire
system fail. To increase the robustness of a private key,
Ekiden [42] designs a distributed key generation (DKG) [85]
protocol using the secret sharing scheme [86]. Even if one
key manager is compromised, an adversary cannot obtain
the entire key. However, this solution does not completely
solve the key leakage issue. The ﬁnal keys are assembled and
replicated among all end-TEEs. If an adversary compromises
an end-TEE, exposing all the contract state becomes a trivial
task. The key rotation technology, adopted by Ekiden [42],
Fastkitten [43], Phala [69] partially solves the above issue
by providing a short-term key in every epoch. An adversary
cannot corrupt a future or previous committed state, which
minimizes the possibility of key exposure to attackers and
further helps the layer-two system to achieve forward secrecy.
Also, layer-two projects such as COMMITEE [73] mitigate
these key issues by providing each TEE per secret key. Even
if a certain TEE’s private key were stolen, this only would
affect the smart contract running on that compromised TEE.
Furthermore, Phala Network [69], equips each contract with an
asymmetric key called the contract key, which also enhances
the key security to a certain degree.

C. Pros and Cons

The layer-two solution decreases computational burden and
avoids latency by decoupling the smart contract executions
from consensus mechanisms. The solution merely puts the
execution results on-chain rather than all processing states.
Meanwhile, the layer-two solution does not require a dedicated
public ledger, meaning that such a solution can smoothly

10

Table IV: Evaluation for current TEE-assisted conﬁdential smart contract systems

mechanism
punishment

mechanism
tolerance
authentication
fault
Host

Host

Examples
incentive
Host
Host

security
limitation
attacks
attestation
memory
physical
trusted
TEE
TEE
TEE
TEE

Measurement
restriction
timer
detection
Blockchain
query
Workload
Flaws
User
TEE

conﬁrmation
conﬂicts
data
output
Distributed

key
protocol
protocol
contract
TEE
key
rotation
Independent
Independent
Key

key

(cid:108)

(cid:108)

(cid:108)

(cid:108)

-

-

(cid:115)

(cid:115) (cid:63)
(cid:115) (cid:115) (cid:115) (cid:115)

(cid:115) (cid:108) (cid:115) (cid:115)

(cid:108)

-

-

-

(cid:115) (cid:115)

-

-

(cid:108)

(cid:115) (cid:115) (cid:108)

(cid:115) (cid:115) (cid:108)

(cid:115) (cid:115) (cid:108)

(cid:108)

(cid:108)

(cid:108)

(cid:115) (cid:115) (cid:108) (cid:115)

(cid:108) (cid:115) (cid:115) (cid:108)

(cid:109) (cid:115) (cid:108) (cid:115)

(cid:108) (cid:115) (cid:115) (cid:108)

(cid:115) (cid:115) (cid:108) (cid:115)

(cid:108) (cid:115) (cid:115) (cid:108)

(cid:115) (cid:115) (cid:115) (cid:108)

(cid:108) (cid:115) (cid:115) (cid:115)

(cid:108) (cid:115) (cid:115) (cid:108)

(cid:115) (cid:115)

-

(cid:115) (cid:115) (cid:108)

(cid:108) (cid:115) (cid:108)

-

(cid:108)

(cid:108)

-

-

(cid:115)

-

-

-

-

-

(cid:115) (cid:115) (cid:115) (cid:115)

(cid:115) (cid:108) (cid:115) (cid:115) (cid:108)

(cid:115) (cid:115) (cid:108)

(cid:115) (cid:115) (cid:115) (cid:115)

(cid:108) (cid:115) (cid:108)

(cid:108) (cid:115) (cid:108) (cid:115)

(cid:108) (cid:115) (cid:115) (cid:115)

(cid:115) (cid:115) (cid:108)

(cid:115) (cid:115) (cid:108)

(cid:108)

(cid:115) (cid:115) (cid:109) (cid:108)

(cid:115) (cid:115) (cid:109) (cid:108)

(cid:108)

(cid:108)

(cid:108)

(cid:108)

(cid:108)

(cid:115) (cid:108)

(cid:108) (cid:115)

(cid:109) (cid:108)

(cid:108) (cid:115)

(cid:108)

(cid:108) (cid:115) (cid:115)

(cid:115) (cid:108) (cid:115) (cid:108)

(cid:115) (cid:115) (cid:115) (cid:115)

(cid:108) (cid:115) (cid:108)

(cid:108) (cid:115)

(cid:109) (cid:115) (cid:115) (cid:115)

(cid:115) (cid:115) (cid:108)

(cid:108)

(cid:115) (cid:115) (cid:108) (cid:115)

(cid:115) (cid:115) (cid:115)

-

-

(cid:115) (cid:115) (cid:115) (cid:108)

(cid:115) (cid:115) (cid:108) (cid:115)

(cid:115) (cid:108) (cid:109) (cid:115)

(cid:115) (cid:115) (cid:115) (cid:115) (cid:115)

(cid:115) (cid:115) (cid:115) (cid:115)

(cid:115) (cid:115) (cid:108)

(cid:108)

(cid:115) (cid:115) (cid:115) (cid:115)

(cid:115) (cid:108) (cid:115) (cid:108)

(cid:108) (cid:115) (cid:115) (cid:115)

(cid:115) (cid:115) (cid:115) (cid:115)

(cid:115) (cid:115) (cid:115) (cid:108)

(cid:108)

(cid:108)

(cid:115) (cid:115) (cid:115) (cid:115)

(cid:115) (cid:115) (cid:115) (cid:115)

Selected

2017, Enigma [61], [71]

2018, Fabric [60]

2019, CCF [45]

2020, CONFIDE [37]

2016, Hawk [21]

2018, PDOs [46]

2018, ShadowEth [68]

2019, Phala [69]

2019, Ekiden [42]

2019, Fastkitten [43]

2019, Avalon [72]

2020, Hybridchain [41]

2020, COMMITEE [73]

2020, PrivacyGuard [74]

2020, TZ4Fabric [44]

(cid:115) (cid:115) (cid:115) (cid:115)

-

(cid:108) (cid:115) (cid:115)

(cid:115) (cid:115) (cid:108) (cid:115) (cid:108)

(cid:115) (cid:115) (cid:115) (cid:108)

2020, Taxa [70]

2021, Erdstall [75], [76]

(cid:115) (cid:108)

(cid:108) (cid:115)

(cid:115) (cid:115) (cid:115) (cid:115)

(cid:115) (cid:115) (cid:115) (cid:115) (cid:108)

(cid:115) (cid:115) (cid:115) (cid:115)

(cid:115) (cid:108)

(cid:108)

(cid:108)

(cid:115) (cid:115) (cid:115) (cid:115)

(cid:115) (cid:115) (cid:115) (cid:115) (cid:108)

(cid:115) (cid:115) (cid:115) (cid:108)

TEE Host Security

TEE Security

TEE Program Security

TEE Key Security

(cid:108) Considered this pitfall with offering remedy; (cid:109) Discussed this pitfall without offering remedy; (cid:63) Without reference.
(cid:115) Did not consider this pitfall; − The system is secure without this pitfall; Layer-one solutions are in Yellow background.

integrate with existing public blockchain platforms. Unfor-
tunately, this method also brings security and functionality
challenges when delegating the task of contract management
to an external TEE layer.

In addition to bringing the privacy properties,
the layer-two solution enables complex contract
executions without slowing down the consensus
process, reducing contract costs and improving
performance and scalability.

Secondly, the layer-two solution increases the attack surface
and thus becomes vulnerable to rollback attacks. There is a
high probability that an adversary node can revert transactions
where temporary forks, representing inconsistent blockchain
views, are allowed in blockchain systems with probabilistic
consensus (e.g., PoW). Since TEEs provide no guarantee on
veriﬁcation of input data; they cannot distinguish whether an
input state is fresh or not. An attacker may offer stale states
to resume a TEE’s execution. This enables rollback attacks
against randomized TEEs programs. Even worse, plugging up
these loopholes needs much effort.

Firstly, the layer-two solution complexiﬁes contract data
management. The contracts that are deployed outside the
blockchain require an external execution/storage party. A
malicious storage maintainer may reject to provide the service,
while a malicious host may abort TEE executions, terminate
enclaves or delay/drop messages. Even an honest host might
accidentally lose states in a power cycle. To solve the central-
ization issue and tolerate host failures, many countermeasures
such as the TEE network, stateless TEEs and punishment
mechanisms, are proposed. However, these solutions are not
effortless, inevitably making the system complicated and hard
to implement in practice.

VI. DISCUSSION

This section compares layer-one and layer-two solutions,

and discusses the hardware’s options and impacts.

A. L1 and L2 Comparison

Which solution is more secure? Even if we have built clear
security metrics based on threat models and give concise
security analyses in the context of layered architectures, it is
still inadequate for answering this question: Which solution is
more secure, layer-one solution or layer-two solution? This
is because system security is a multidimensional topic, and
measuring all security aspects is impractical. The security

11

ﬂaws may happen in any phase in a system [87]. Despite
some projects performing well in our evaluation, we cannot
roughly say that they are more secure. As hybrid technologies,
both layer-one and layer-two systems have unsatisfactory
security vulnerabilities in existing systems, and they must
be carefully treated when applying them to real applications.
Frankly speaking, there is a long road to achieving such a
practically secure and conﬁdential system. Our aim is not to
argue which solution is more secure. Instead, we focus on
helping developers and communities to establish a security
measurement and avoid potential pitfalls in designing TCSC.
Which solution is more efﬁcient? The layer-one solutions
require the contract to be conﬁdentially executed in a dis-
tributed TEE network, which is time-consuming and hard to
scale out. In contrast, layer-two systems only upload ﬁnal cal-
culated results from ofﬂine TEEs to online blockchains. Local
TEE hosts can execute complicated computations with high
scalability and short execution time. Assuming that the on-
chain processing time remains stable, the overall performance
gets improved by enabling parallel off-chain executions. Thus,
from the view of performance and scalability, the layer-two
solution is our recommendation.

Which solution is more adoptable? From the aforemen-
tioned discussion, we can observe that the layer-one and layer-
two solutions ﬁt different scenarios. The layer-one solution
is more adoptable in consortium blockchain systems, while
the layer-two solution well ﬁts the existing public blockchain
systems. Layer-one systems require each blockchain node to
equip a TEE, which is difﬁcult to be fulﬁlled in a public
blockchain while already in use. In a consortium blockchain,
the nodes are controllable and manageable, and the committee
can require each node to equip a TEE when joining the net-
work. On the ﬂip side, the layer-two solution does not change
the original blockchain trust assumption. Instead, it creates an
independent layer for executing the smart contract, and thus
allows developers to seamlessly integrate the TEE into existing
public blockchains without signiﬁcant modiﬁcations.

B. Hardware-anchored TEE Options

Securing smart contracts with TEEs is challenging because
we have to assume a strong attacker model, in which the
attacker has physical possession of the hardware running the
smart contract and can interfere with it in powerful ways.
This part discusses the security impact of choosing different
TEE architectures. In particular, we select Intel SGX [88], Arm
TrustZone [89] and dedicated chip [90] as examples.

Intel SGX is a system allowing one to set up protected
enclaves running on an Intel processor. Such enclaves are
protected from malware running outside the enclave, including
in the operating system. Enclaves can attest their software and
computations using a signing key ultimately certiﬁed by Intel.
Intel SGX has been marketed for desktop machines and servers
alike; Microsoft Azure [91] is a commercial cloud offering that
allows cloud customers to set up SGX enclaves in the cloud.
Many attacks on SGX have been published in the eight years
since its release. They may be categorised as side-channel

attacks [92], fault attacks [93], [94] and software attacks [95].
While some of these attacks can be solved by improvements
of SGX, it is unclear that it will ever be possible to have a
completely secure version, because the attack surface is large,
in the case of smart contracts, one has to assume that attackers
have physical possession of the hardware.

ARM TrustZone [89] is a technology widely used in mobile
phones to protect secrets, such as secrets used in banking apps.
Its ubiquity makes it an attractive option. However, it has
been attacked even more than Intel SGX, and doesn’t offer
a suitable attestation framework. Future hardware-anchored
security products from ARM may address this problem.

Dedicated chips such as the Open Titan [90] family of
chips offer a better solution. Open Titan is an open-source
design inspired by Google Titan, a chip used on Google
servers and in Google mobile phones. The fact that the smart
contract runs on a dedicated chip not shared with attacker
code means that the attack surface is much smaller. Attestation
frameworks exist for such chips, and the attestation keys can
be rooted in a manufacturer’s certiﬁcate. The kind of attacks
mentioned for SGX become much harder to mount. Neverthe-
less, even dedicated chips may succumb to a dedicated and
resourceful attacker. Researchers have succeeded in mounting
attacks based on power side-channels and electromagnetic
(EM) radiation side channels. Defences against such attacks
include masking, which consists of randomly splitting every
sensitive intermediate variable into multiple shares. Even if the
adversary is able to learn a share of the secret via side-channel,
it would need all of them in order to recover the secret. Fault
attacks such as EM and voltage glitching are also possible,
but again, there are known defences [96] at both a software
and hardware level. Software defences include making secret-
dependent computations twice (in general n times) and then
comparing results before producing any output. Countermea-
sures in hardware involve having internal voltage monitoring
circuitry, which makes sure that the input voltage remains
within a safe operation range and resets the device otherwise.

VII. RESEARCH CHALLENGES

Side channel attack. Inevitably, all types of TEEs suffer
from side-channel attacks. An attacker may observe untrusted
resources to obtain the control ﬂow and data access mode
from the running hardware to infer sensitive information.
Beyond the normal side-channel attack, an attacker can keep
track of the changes in encrypted states recorded on the
blockchain to extract secrets. The attacker carefully compares
encrypted states before and after running a particular conﬁ-
dential transaction. Even if the attacker cannot directly learn
about the plaintext, the changes of the encrypted state may
lead to a valuable side-channel attack. Come back to the e-
voting example, the changes of state c(cid:48)
b indicates a speciﬁc
sender or receiver’s invocation, and ciphertext length reveals
which method is being invoked given different arguments size.
Meanwhile, the application binary interface (ABI) [2], and the
contract path will be spied by an attacker, causing data leakage.

12

Key management dilemma. The private keys in TEE-assisted
systems are extremely crucial but hard to manage. On the one
hand, putting the application keys in a single TEE contributes
to the key security. However, it also makes the system raise the
risk of a single point of failure. On the other hand, sharing the
private key among multiple TEEs offers practical availability
but (as a sacriﬁce) increases key exﬁltration risk. Meanwhile,
key sharing technologies are too complicated to adopt and can-
not completely solve the key issues. Suppose that an attacker
steals the attestation key somehow. She might consequently
generate the attestation materials to deceive the user with a
fake fact: The contract has been executed. Even worse, if a
root key stored in the tamper-resistant hardware (e.g., Memory
Encryption Engine Key in SGX) is compromised, all key
technologies for protecting application keys become useless.

Transparency issues. Compared with cryptographic ap-
proaches backed by mathematics [22], [23], [27], the conﬁden-
tial smart contracts relied on TEEs are lack of transparency.
On the one hand, contracts are executed inside TEEs, and the
outputs are usually encrypted, which lacks public veriﬁability
inherited from traditional blockchain systems. The attestation
service can only guarantee that the encrypted outputs indeed
come from a TEE. However, neither users nor the blockchain
nodes can learn whether a TEE is compromised or executes
contracts following the predeﬁned speciﬁcations. Even if many
TEEs can re-execute the same contract with the same setup
(e.g., the same private key) to check outputs, this inevitably
increases the key exﬁltration risk in the face of a conﬁden-
tiality breach. On the other hand, the precise architectures
of chips are still unclear for some TEE products, such as
Intel SGX [80]. TEE-assisted solutions force the user to put
too much trust in the manufacturers of this hardware. Users
even argue that Intel may have reduced the security of SGX
to improve performance to cater for market demand [97].
Additionally,
the attestation service used to prove that a
program runs inside TEEs is centralized and non-transparent.
A compromised provider has the ability to insert fake IDs, and
further, steal the conﬁdential state in smart contracts.

VIII. CONCLUDING REMARKS
The technologies on how to combine smart-contract exe-
cution with TEEs are mushrooming nowadays. The absence
of systematic work confuses newcomers. In this paper, we
provide the ﬁrst SoK on TEE-assisted conﬁdential smart con-
tract systems. TEE technologies empower transparent smart
contracts with conﬁdentiality, greatly extending the scope of
upper-layer applications. We summarize state-of-the-art solu-
tions by proposing a uniﬁed framework covering aspects of
design models, desired properties, and security considerations.
Our analysis clariﬁes existing challenges and future directions
for two mainstream architectures (layer-one and layer-two
solutions). We believe that this work represents a snapshot
of the technologies that have been open-sourced and made
public in time. Our evaluation and analysis within this SoK
will offer a good guide for communities, and greatly promote
the prosperity of development for TCSC applications.

Acknowledgement. Rujia Li and Qi Wang are partially
supported by the Shenzhen Fundamental Research Programs
under Grant No.20200925154814002. We thank Xinrui Zhang
(SUSTech) for her help. Also, we express our appreciation to
anonymous reviewers for their valuable comments.

REFERENCES

[1] Nick Szabo. Formalizing and securing relationships on public net-

works. First monday, 1997.

[2] Gavin Wood et al. Ethereum: A secure decentralised generalised
transaction ledger. https:// ethereum.github.io/ yellowpaper/ paper.pdf ,
2022.

[3] Kevin Delmolino et al. Step by step towards creating a safe smart
contract: Lessons and insights from a cryptocurrency lab. In FC, pages
79–94. Springer, 2016.

[4] Hewa et al. Survey on blockchain based smart contracts: Technical

aspects and future research. IEEE Access, 2021.

[5] Maher Alharby and Aad Van Moorsel. Blockchain-based smart con-
tracts: A systematic mapping study. arXiv preprint arXiv:1710.06372,
2017.

[6] Marc Jansen et al. Do smart contract languages need to be turing

complete? In CBA, pages 19–26. Springer, 2019.

[7] Siraj Raval.

Decentralized applications: harnessing Bitcoin’s

blockchain technology. " O’Reilly Media, Inc.", 2016.

[8] Weiqin Zou et al.

Smart contract development: Challenges and

opportunities. TSE, 2019.

[9] Rui Zhang, Rui Xue, and Ling Liu. Security and privacy on blockchain.

CSUR, 52(3):1–34, 2019.

[10] Steven Goldfeder. Private smart contracts. 2018.
[11] Samuel S., Benjamin Bichsel, Mario Gersbach, Noa Melchior, Petar
zkay: Specifying and enforcing data

Tsankov, and Martin Vechev.
privacy in smart contracts. In CCS, pages 1759–1776, 2019.

[12] Karim Baghery. On the efﬁciency of privacy-preserving smart contract

systems. In AFRICACRYPT, pages 118–136. Springer, 2019.

[13] A. Unterweger, F. Knirsch, et al. Lessons learned from implementing
a privacy-preserving smart contract in ethereum. NTMS, pages 1–5,
2018.

[14] Fan Zhang, Ethan Cecchetti, Kyle Croman, Ari Juels, and Elaine Shi.
Town crier: An authenticated data feed for smart contracts. In CCS,
pages 270–282, 2016.

[15] Erik-Oliver Blass and Florian Kerschbaum. Borealis: Building block
for sealed bid auctions on blockchains. In AsiaCCS, pages 558–571,
2020.

[16] Hisham S Galal and Amr M Youssef. Trustee: full privacy preserving
vickrey auction on top of ethereum. In FC, pages 190–207. Springer,
2019.

[17] Véronique Cortier, David Galindo, Ralf Küsters, Johannes Mueller, and
Tomasz Truderung. Sok: Veriﬁability notions for e-voting protocols.
In SP, pages 779–798. IEEE, 2016.

[18] Geetanjali Rathee et al. On the design and implementation of a
blockchain enabled e-voting application within iot-oriented smart cities.
IEEE Access, 9:34165–34176, 2021.

[19] General data protection regulation. https://gdpr-info.eu/. 2020.
[20] Paul Voigt et al. The eu general data protection regulation (gdpr).
A Practical Guide, 1st Ed., Cham: Springer International Publishing,
10:3152676, 2017.

[21] Ahmed Kosba, Andrew Miller, Elaine Shi, Zikai Wen, and Charalam-
pos Papamanthou. Hawk: The blockchain model of cryptography and
privacy-preserving smart contracts. In SP, pages 839–858. IEEE, 2016.
[22] Harry Kalodner et al. Arbitrum: Scalable, private smart contracts. In

USENIX Security, pages 1353–1370, 2018.

[23] B. Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille,
and Greg Maxwell. Bulletproofs: Short proofs for conﬁdential trans-
actions and more. In SP, pages 315–334. IEEE, 2018.

[24] Benedikt Bünz et al. Zether: Towards privacy in a smart contract world.

In FC, pages 423–443. Springer, 2020.

[25] Yu Chen, Xuecheng Ma, Cong Tang, and Man Ho Au. Pgc: Decen-
In ESORICS,

tralized conﬁdential payment system with auditability.
pages 591–610. Springer, 2020.

[26] Ravital Solomon et al. smartfhe: Privacy-preserving smart contracts
IACR Cryptol. ePrint Arch.,

from fully homomorphic encryption.
2021:133, 2021.

13

[27] Guy Zyskind et al. Enigma: Decentralized computation platform with

guaranteed privacy. arXiv:1506.03471, 2015.

[28] Dayeol Lee, David Kohlbrenner, et al. Keystone: An open framework
for architecting trusted execution environments. In EuroSys, pages 1–
16, 2020.

[29] Jan-Erik Ekberg et al. Trusted execution environments on mobile

devices. In CCS, pages 1497–1498, 2013.

[30] Seongmin Kim et al. Enhancing security and privacy of tor’s ecosystem
In NSDI, pages 145–161,

by using trusted execution environments.
2017.

[31] David Kaplan, Jeremy Powell, and Tom Woller. Amd memory

encryption. White paper, 2016.

[32] Ferdinand Brasser, David Gens, Patrick Jauernig, Ahmad-Reza
Sadeghi, and Emmanuel Stapf. Sanctuary: Arming trustzone with user-
space enclaves. In NDSS, 2019.

[33] Frank McKeen, Ilya Alexandrovich, Alex Berenzon, Carlos V Rozas,
Hisham Shaﬁ, Vedvyas Shanbhogue, and Uday R Savagaonkar. Inno-
vative instructions and software model for isolated execution. Hasp@
isca, 10(1), 2013.

[34] ChongChong Zhao et al. On the performance of intel sgx. In WISA,

pages 184–187. IEEE, 2016.

[35] Jinhua Cui et al. Dynamic binary translation for sgx enclaves. arXiv

preprint arXiv:2103.15289, 2021.

[36] Rujia Li, Qin Wang, et al. An ofﬂine delegatable cryptocurrency

system. arXiv preprint arXiv:2103.12905, 2021.

[37] Ying Yan, Changzheng Wei, et al. Conﬁdentiality support over ﬁnancial

grade consortium blockchain. In SIGMOD, pages 2227–2240, 2020.

[38] Rohit Sinha et al. Luciditee: A tee-blockchain system for policy-

compliant multiparty computation with fairness.

[39] Chinese chang’an chain enterprise blockchain joins digital yuan project,

Mar 2021.

[56] Yuanzhong Xu et al. Controlled-channel attacks: Deterministic side
channels for untrusted operating systems. In SP, pages 640–656. IEEE,
2015.

[57] Mark D Hill et al. On the spectre and meltdown processor security

vulnerabilities. IEEE Micro, 39(2):9–19, 2019.

[58] Cynthia Dwork. Differential privacy: A survey of results. In Interna-
tional conference on theory and applications of models of computation,
pages 1–19. Springer, 2008.

[59] Ivan Homoliak and Pawel Szalachowski. Aquareum: A centralized
ledger enhanced with blockchain and trusted computing. arXiv preprint
arXiv:2005.13339, 2020.

[60] Marcus Brandenburger et al. Blockchain and trusted computing:
Problems, pitfalls, and a solution for hyperledger fabric. arXiv preprint
arXiv:1805.08541, 2018.

[61] Enigma – securing the decentralized web. https:// www.enigma.co/ .
[62] Juan Garay et al.

The bitcoin backbone protocol: Analysis and

applications. In EUROCRYPT, pages 281–310. Springer, 2015.
[63] Juan Garay et al. The bitcoin backbone protocol with chains of variable

difﬁculty. In CRYPTO, pages 291–323. Springer, 2017.

[64] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain
protocol in asynchronous networks. In EUROCRYPT, pages 643–673.
Springer, 2017.

[65] Juan Garay and Aggelos Kiayias. Sok: A consensus taxonomy in the

[66] Intel.

blockchain era. In RSA, pages 284–318. Springer, 2020.
Intel software guard extensions (intel sgx).

Accessi-
ble on https:// software.intel.com/ content/ www/ us/ en/ develop/ topics/
software-guard-extensions.html, 2020.

[67] Robert Krahn, Donald Dragoti, Franz Gregor, et al. Teemon: A con-
tinuous performance monitoring framework for tees. In Middleware,
pages 178–192, 2020.

[68] Rui Yuan et al. Shadoweth: Private smart contract on public blockchain.

[40] Financials. Changan chain,

the ﬁrst

independent and controllable

JCST, 33(3):542–556, 2018.

blockchain technology system in china, was released today.

[41] Yong Wang et al. Hybridchain: A novel architecture for conﬁdentiality-
preserving and performant permissioned blockchain using trusted exe-
cution environment. IEEE Access, 8:190652–190662, 2020.

[42] Raymond Cheng, Fan Zhang, Jernej Kos, Warren He, Nicholas Hynes,
Noah Johnson, Ari Juels, Andrew Miller, and Dawn Song. Ekiden:
A platform for conﬁdentiality-preserving, trustworthy, and performant
smart contracts. In EuroSP, pages 185–200. IEEE, 2019.

[43] Poulami Das et al. Fastkitten: Practical smart contracts on bitcoin. In

USENIX Security, pages 801–818, 2019.

[44] Christina Müller, Marcus Brandenburger, et al. Tz4fabric: Executing
smart contracts with arm trustzone. arXiv preprint arXiv:2008.11601,
2020.

[45] Mark Russinovich et al. Ccf: A framework for building conﬁdential
veriﬁable replicated services. Technical Report MSR-TR-2019-16,
Microsoft, April 2019.

[46] Mic Bowman et al. Private data objects: an overview. arXiv preprint

arXiv:1807.05686, 2018.

[47] Adam Young and Moti Yung. The dark side of “black-box” cryp-
tography or: Should we trust capstone? In CRYPTO, pages 89–103.
Springer, 1996.

[48] Rujia Li, David Galindo, and Qi Wang. Auditable credential anonymity
revocation based on privacy-preserving smart contracts. In CBT, pages
355–371. Springer, 2019.

[49] Rujia Li, Qin Wang, et al. An accountable decryption system based on
privacy-preserving smart contracts. In ISC, pages 372–390. Springer,
2020.
[50] Oasis lab.

https:// github.com/ oasislabs/ secret-ballot/ blob/ master/

contracts/ SecretBallot.sol.

[51] Véronique Cortier et al. Election veriﬁability for helios under weaker
trust assumptions. In ESORICS, pages 327–344. Springer, 2014.
[52] Nik Unger, Sergej Dechand, Joseph Bonneau, Sascha Fahl, H. Perl,
I. Goldberg, and M. Smith. Sok: Secure messaging. SP, pages 232–
249, 2015.

[53] Elli Androulaki, Ghassan O Karame, Marc Roeschlin, Tobias Scherer,
and Srdjan Capkun. Evaluating user privacy in bitcoin. In FC, pages
34–51. Springer, 2013.

[54] Sarah Meiklejohn, Marjori Pomarole, Grant Jordan, et al. A ﬁstful of
bitcoins: characterizing payments among men with no names. In IMC,
pages 127–140, 2013.

[55] Ferdinand Brasser et al. Software grand exposure:{SGX} cache attacks

are practical. In WOOT, 2017.

14

[69] Yin Hang, Zhou Shunfan, and Jiang Jun.
smart

A conﬁdential
https://ﬁles.phala.network/phala-paper.pdf, 2019.

network

contract

based

Phala network:
polkadot.

on

[70] Taxa. Taxa network: a universal logic layer for blockchain. Website,

2021. https://taxa.network/.

[71] Enigma.
by
the-developer-quickstart-guide-to-enigma-880c3fc4308.

developer
|

The
project

quickstart

enigma.

enigma

guide
|
https:// blog.enigma.co/

enigma

to

[72] Hyperledger.

Introducing hyperledger avalon. www.hyperledger.org/
blog/2019/10/03/introducing-hyperledger-avalon, 2019. (Accessed on
04/19/2021).

[73] Andreas Erwig, S. Faust, et al. Commitee: An efﬁcient and se-
IACR Cryptol. ePrint Arch.,

cure commit-chain protocol using tees.
2020:1486, 2020.

[74] Yang Xiao et al. Privacyguard: Enforcing private data usage control
with blockchain and attested off-chain contract execution. In ESORICS,
pages 610–629. Springer, 2020.

[75] Perun Network. Introducing erdstall: Scaling ethereum using trusted
execution environments | by perun network | perunnetwork | medium.
[76] Erdstall. Technology – erdstall. https://erdstall.dev/technology/. (Ac-

cessed on 04/17/2021).

[77] Wentao Liu. Research on dos attack and detection programming. In
Third International Symposium on Intelligent Information Technology
Application, volume 1, pages 207–210. IEEE, 2009.

[78] Roberto De Prisco et al. Revisiting the paxos algorithm. Theoretical

Computer Science, 243(1-2):35–91, 2000.

[79] Peter Gaži, Aggelos Kiayias, and Dionysis Zindros. Proof-of-stake

sidechains. In SP, pages 139–156. IEEE, 2019.

[80] Victor Costan and Srinivas Devadas. Intel sgx explained. IACR Cryptol.

ePrint Arch., 2016(86):1–118, 2016.

[81] Nico W., Pierre-Louis Aublin, and Rüdiger Kapitza.

sgx-perf: A
performance analysis tool for intel sgx enclaves. In Middleware, pages
201–213, 2018.

[82] R. Pries et al. A new replay attack against anonymous communication

networks. ICC, pages 1578–1582, 2008.

[83] Marcus Brandenburger, Christian Cachin, Rüdiger Kapitza, and
Alessandro Sorniotti. Trusted computing meets blockchain: Rollback
In SRDS, pages 324–
attacks and a solution for hyperledger fabric.
32409. IEEE, 2019.

[84] Shenbin Zhang et al. A solution for the risk of non-deterministic
In ICBC, pages 253–261. IEEE,

transactions in hyperledger fabric.
2019.

[85] Rosario Gennaro, Stanisław Jarecki, Hugo Krawczyk, and Tal Rabin.
Secure distributed key generation for discrete-log based cryptosystems.
In EUROCRYPT, pages 295–310. Springer, 1999.

[86] Adi Shamir. How to share a secret. Communications of the ACM,

22(11):612–613, 1979.

[87] Shari Pﬂeeger and Robert Cunningham. Why measuring security is

hard. IEEE SP, 8(4):46–54, 2010.

[88] Intel.

Introduction to intel® sgx sealing.
https://software.intel.com/content/www/us/en/develop/blogs/
introduction-to-intel-sgx-sealing.html.

Website, 2016.

[89] Sandro Pinto and Nuno Santos. Demystifying arm trustzone: A

comprehensive survey. CSUR, 51(6):1–36, 2019.

[90] Scott Johnson et al. Titan: enabling a transparent silicon root of trust
for cloud. In Hot Chips: A Symposium on High Performance Chips,
volume 194, 2018.

[91] Cynthia Dwork. Microsoft azure. 2021.
[92] Jo Van Bulck et al. Foreshadow: Extracting the keys to the intel sgx
kingdom with transient out-of-order execution. In USENIX Security,
pages 991–1008, 2018.

[93] Kit Murdock, David Oswald, Flavio D Garcia, et al. Plundervolt:
Software-based fault injection attacks against intel sgx. In SP, pages
1466–1482. IEEE, 2020.

[94] Zitai Chen et al. Voltpillager: Hardware-based fault injection attacks
against intel sgx enclaves using the svid voltage scaling interface. In
USENIX Security, 2021.

[95] Jo Van Bulck, David Oswald, et al. A tale of two worlds: Assessing the
vulnerability of enclave shielding runtimes. In CCS, pages 1741–1758,
2019.

[96] Eli Biham and Adi Shamir. Differential fault analysis of secret key
cryptosystems. In CRYPOTO, pages 513–525. Springer, 1997.
[97] Tu Dinh Ngoc, Bao Bui, et al. Everything you should know about intel
sgx performance on virtualized systems. POMACS, 3(1):1–21, 2019.
[98] Arvind Narayanan, Joseph Bonneau, Edward Felten, Andrew Miller,
and Steven Goldfeder. Bitcoin and cryptocurrency technologies: a
comprehensive introduction. Princeton University Press, 2016.
[99] Tsz Hon Yuen, Shi-feng Sun, et al. Ringct 3.0 for blockchain
In FC,

conﬁdential transaction: Shorter size and stronger security.
pages 464–483. Springer, 2020.

[100] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system.

Technical report, Manubot, 2008.

[101] Ying Lan et al. Trustcross: Enabling conﬁdential interoperability across
blockchains using trusted hardware. arXiv preprint arXiv:2103.13809,
2021.

APPENDIX A. KEY MANAGEMENT

A variety of different keys are used in the life cycle of
TCSC. For simplicity, we use Intel SGX as the instance. We
classify these keys into two types, namely, service keys (top
half) and SGX internal keys (bottom half).

Service keys. The keys sktx and pkm are used to sign a
transaction and encrypt a message resulting from a TEE.
Correspondingly, the keys pktx and skm are used to verify
a signature and decrypt a ciphertext, respectively. Meanwhile,
the TEE service key keytee is used to encrypt the contract
state, and the asymmetric TEE service key sktee is used to en-
crypt a voter’s input. Since the key management technologies
have signiﬁcant impacts on these service keys, we emphasize
them with the yellow background.

SGX internal keys. The MEE key is generated at boot, and
is placed in special registers, and destroyed at system reset.
The MEE key is used for memory encryption and decryption,
which plays a crucial role in protecting the conﬁdentiality and
integrity of enclaves. At the same time, different enclaves in
the same TEE platform share one function key, such as the
report key and the attestation key [88].

15

APPENDIX B. ANONYMITY AND CONFIDENTIALITY

Anonymity refers to the privacy that relates to real enti-
ties, especially for users’ identities. In a blockchain system,
anonymity indicates that users’ transaction activities will not
expose any personal information about them. Alternatively,
an attack cannot obtain the correct links between real users
and their corresponding account/address that sends the trans-
action [98]. Bitcoin and Ethereum only provide a very early
version of anonymity, using the pseudonym-based address
mechanism to protect identities. However, this cannot guaran-
tee anonymity because attackers can effortlessly map virtual
addresses to physical entities through the relationship analysis.
Conﬁdentiality in a blockchain system mainly refers to
the privacy of data and contents recorded on-chain [99], [9].
Classic blockchain systems expose all transactions (includes
amount information, addresses, amount, etc.) plainly where
anyone can read and access. Sensitive information might
unconsciously be leaked to malicious analyzers. For instance,
ERC20 tokens in the Ethereum system do not provide conﬁ-
dentiality, since anyone can observe every amount’s balance.
Adversaries can keep tracing the accounts that have a huge
amount of tokens and launch attacks such as using the phishing
website or cheating through ofﬂine activities.

APPENDIX C. BACKGROUND

Blockchain Technology. Blockchain, conceptualized by
Nakamoto [100], was proposed as a distributed and append-
only ledger, in which all committed transactions are stored in
a chain of data records (named as blocks). According to the
initial idea of Bitcoin [1], when the blockchain maintainers
reach an agreement on the newest block, related transac-
tions appearing in that time will be packaged in this block
and further stored in a distributed network to maintain a
continuously growing list. By providing a secure solution
to distribute the information and allowing all participants
the shared records, blockchain obtains many key
to audit
characteristics such as decentralization, auditability and non-
repudiation, transparency, and non-equivocation.

Smart Contract Proposed by Szabo [1], the smart contract
are widely applied in blockchain systems by Ethereum [2].
Blockchain-based smart contracts adopt Turing-complete
scripting languages to achieve complicated functionalities [6]
and execute thorough state transition/replication over consen-
sus algorithms to realize ﬁnal consistency. By the design, a
blockchain-based smart contract includes multiple functions,
methods, and a few parameters that can run on the blockchain
when speciﬁc conditions or events are met and encompass
business logic and transactions between two or more parties.
To be speciﬁc,
the source code of a contract forming as
part of a transaction is ﬁrst sent to the blockchain. Once
the transaction is included in a new block and conﬁrmed by
the majority of the participants, the contract code becomes
immutable and executable. When an external user invokes the
contract, the state will be updated under the instruction of
the preloaded source code. The neutrality of the execution

Table V: Key Types in Conﬁdential Smart Contracts: The table shows a voting example achieved by Intel SGX and Ethereum.

Keys

Purpose

Remarks

Transaction signing key (sktx, vktx)

signing a transaction

generated by a voter

A vote’s message key (skm, pkm)

encrypt a message that comes from a voter

generated by a voter

TEE service key keytee

encrypt and decrypt a blockchain state

generated inside an enclave

TEE service key (sktee, pktee)

decrypt a user’s input/encrypt a TEE’s output

generated inside an enclave

Memory Encryption Engine Key

encrypt (decrypt) the data before writing (reading)
it to (from) RAM.

stored inside a CPU; different enclaves in the same TEE platform share
the same MEE key.

Report key

generate a MAC tag for the measurement.

Attestation key

produce attestation signatures.

Sealing key

migrate secrets between enclaves.

generated by EGETKEY instruction; different enclaves in the same TEE
platform share one report key;

stored in tamper-resistant hardware; different enclaves in the same TEE
platform share one attestation key;

stored in tamper-resistant hardware; different enclaves in the same TEE
platform may share the sealing key depending on key policies.

environment among all blockchain nodes facilitates the same
execution result of the program code. Smart contracts thus en-
able unfamiliar and distributed participants to fairly exchange
without trusted third parties and present a uniform approach
to improve applications across a wide range of industries.

Trusted Execution Environments. Trusted Execution Envi-
ronment (TEE) [29] provides a protected processing area in
the main processor that runs on a separation kernel to ensure
conﬁdentiality and integrity of inside data and computations.
State-of-the-art implementations include Intel Software Guard
Extensions (SGX) [80], ARM TrustZone [89], Keystone [28],
etc. For a TEE, three main TEE features are highlighted, in-
cluding runtime isolation, sealing technologies and attestation
technologies. For simplicity, we use Intel SGX as an example
to explain these features in the following paragraphs. It has
to be mentioned that the Intel SGX design used in our paper
can also be implemented on other trusted hardware platforms
such as Keystone [28].

Runtime Isolation. The secure and isolated regions of memory
are called enclaves. Sensitive data and intermediate com-
putations run inside enclaves to provide protection against
outside programs. Besides, all the runtime enclave memories
are stored in Enclave Page Cache (EPC) [101] and encrypted
by Memory Encryption Engine (MEE). These protective
mechanisms enforced in SGX protect memories against the
access of any process outside the enclave itself, including
the operating system, hypervisors, etc.

Sealing. Sealing [88] is a process of loading enclave internal
secret state to persistent storage. Roughly speaking, using
the Sealing, the secrets can be encrypted and stored in the
untrusted memory or disk. Further, it allows such encrypted
secrets to be retrieved once the enclave is torn down
(either due to the host’s power or the application itself).
Sealing is achieved by using a private seal key [80], which
covers two types of identities: Enclave Identity and Signing
Identity. Enclave Identity is represented by the value of
MRENCLAVE, which is a cryptographic hash of the enclave
measurement. Any operation inside an enclave that changes
measurement will yield a different key. Thus, it restricts the

permission to sealed data; only the corresponding enclave
can access the sealed data. In contrast, Signing Identity is
provided by an authority and represented by MRSIGNER. It
provides the same sealing key for different enclaves, or even
different versions of the same enclave. Therefore, Signing
Identity can be used to share sensitive data between multiple
enclaves produced by the same development ﬁrm.

Attestation. Attestation mechanism [33] is used to prove to
a validator that an enclave has been correctly instantiated
and when in that condition can then proceed to further
establish a secure, authenticated connection for the data
transmission. SGX provides two types of attestation: local
attestation and remote attestation. In the former attestation,
SGX facilitates the instructions to help an enclave to attest
to another enclave on the same platform. In the latter one,
SGX enables an enclave to prove a correct loading of code
and data to another enclave that resides in a remote platform.

APPENDIX D. A TCSC-BASED VOTING PROTOCOL
In this part, we provide a detailed description of TCSC-
based voting system that utilizes the Intex SGX. The protocol
mainly consists of two sub-procedures: deployment stage and
execution stage. We give details as follows.
Deployment Stage. In the deployment stage, all the opera-
tional code and the initial state are coded into a TCSC. This
stage includes two steps.
Compile. Firstly, contract binary codes are compiled into
enclave codes. Since an enclave has only a small quantity
of trusted zones for application code and data (the protected
memory is 128MB, and only 96MB is usable for an enclave
in the current version of Intel SGX [88]), a contract has
to determine the boundary of these zones and identify
corresponding zones used for privacy-critical functionalities.
In particular, the e-voting contract needs to deﬁne: the scope
of secret states, the scope of public states, the approach to
access secret states and the approach to access external
states. Enclave Deﬁnition Language (EDL) [80] deﬁnes
trusted components, untrusted components, and correspond-
ing interfaces between them, which takes charge of trans-
lation from contract code to enclave code. It provides two

16

Figure 5: Key Usage in TEE-assisted Conﬁdential Blockchain System.

functionalities: Enclave Calls (ECALLs) and Outside Calls
(OCALLs). ECALLs deﬁne the functions inside the enclave
that are used to expose APIs for untrusted applications to
call in. OCALLs specify untrusted functions outside the
enclave where the enclave code is able to invoke. In our
example, the total number of votes cast for a candidate
cannot be revealed until the voting has ended. Thus, the total
number of votes cast is deﬁned at the access point ECALLs,
and is thereby hidden from the public, and can only be
revealed once the voting procedure has been completed.

Load. Afterwards, EDL ﬁles will load into an enclave, which
is stored in the Enclave Page Cache (EPC). From a micro
perspective, the ﬁrst step is to call the ECREATE instruction
for creating an enclave. This will allocate memory inside the
Enclave Page Cache (EPC). Then, enclave code and data are
added to pages in EPC by calling the EADD instruction.
Finally, when the instruction EINIT completes successfully,
an enclave’s IN IT attributes become true, and the above
instructions cannot be used any more. After a successful
deployment, the initial state and operational code of this
contract will be replicated among blockchain nodes. This
means the e-voting logic cannot be changed. But, the state
of functionalities can be transferred to parties who have
been granted permission with a message-call [2].

Execution Stage. In the execution stage, voters call
the
deployed TCSC to ﬁnish the voting. Firstly, an enclave needs
to fetch the current contract state from the blockchain. Then,
the CPU executes the plaintext contract in the enclave mode.

17

External attackers cannot obtain the knowledge of sensitive
information since the Memory Encryption Engine (MEE) key
never leaves TCB. A critical aspect of Intel SGX’s func-
tionality is that the code inside an enclave can access the
particular enclave state by performing additional checks on
memory semantics. Back to our example, conﬁdential state
(the encrypted number of votes cast for a candidate) will return
only when the following four requirements are fulﬁlled:

- The processor runs in enclave mode;
- The requested page is part of the same enclave;
- The page access is through a correct virtual address;
- The code semantics successfully pass the check.
In a word, the CPU is acting as a doorman in the TCSC,
providing a hardware-based access control mechanism. After
obtaining results from TEEs, the consensus algorithm starts to
reach an agreement. To be speciﬁc, when a miner receives a
newly mined block, he will re-execute all transactions inside
the block to obtain the newly transferred state. Once enough
blockchain miners receive the block and re-execute transac-
tions, the voting results and the transactions triggering the
contract execution will eventually reach the ﬁnal agreement.
When all the voting procedures have ended, the teller can fetch
the ﬁnal encrypted state and obtain the ﬁnal voting result. In
the meanwhile, the transactions can be used as evidence to
trace the voter’s behavior.

