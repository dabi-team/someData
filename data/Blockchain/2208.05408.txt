Pikachu: Securing PoS Blockchains from Long-Range Attacks by
Checkpointing into Bitcoin PoW using Taproot

Sarah Azouvi
Protocol Labs

Marko VukoliÄ‡
Protocol Labs

2
2
0
2

t
c
O
3
1

]

R
C
.
s
c
[

2
v
8
0
4
5
0
.
8
0
2
2
:
v
i
X
r
a

ABSTRACT
Blockchain systems based on a reusable resource, such as proof-of-
stake (PoS), provide weaker security guarantees than those based
on proof-of-work. Specifically, they are vulnerable to long-range
attacks, where an adversary can corrupt prior participants in order
to rewrite the full history of the chain. To prevent this attack on
a PoS chain, we propose a protocol that checkpoints the state of
the PoS chain to a proof-of-work blockchain such as Bitcoin. Our
checkpointing protocol hence does not rely on any central authority.
Our work uses Schnorr signatures and leverages Bitcoin recent
Taproot upgrade, allowing us to create a checkpointing transaction
of constant size. We argue for the security of our protocol and
present an open-source implementation that was tested on the
Bitcoin testnet.

CCS CONCEPTS
â€¢ Security and privacy â†’ Cryptography.

KEYWORDS
Blockchain, proof-of-stake, long-range attack

ACM Reference Format:
Sarah Azouvi and Marko VukoliÄ‡. 2022. Pikachu: Securing PoS Blockchains
from Long-Range Attacks by Checkpointing into Bitcoin PoW using Taproot.
In Proceedings of the 2022 ACM Workshop on Developments in Consensus
(ConsensusDay â€™22), November 7, 2022, Los Angeles, CA, USA. ACM, New
York, NY, USA, 14 pages. https://doi.org/10.1145/3560829.3563563

1 INTRODUCTION
Long-range attacks (LRA) â€” also called posterior corruption at-
tacks [9] â€” are one of the major security issues affecting permis-
sionless proof-of-stake (PoS) blockchains. These attacks rely on the
inability of a user who disconnects from the system at time ğ‘¡1 and
reconnects at a later time to tell that validators who were legitimate
at time ğ‘¡1 and left the system (by e.g., transferring their stake to
other validators, or to themselves under a different identity) are
not to be trusted anymore. In a PoS system, where the creation of
blocks is costless (i.e., does not cost physical resource such as en-
ergy), and timeless (i.e., is not rate-limited in time), these validators
could create a fork that starts from the past, i.e., at time ğ‘¡1, and runs
until the present. This is in sharp contrast to proof-of-work (PoW)
systems, where creating blocks requires time (e.g., due to Bitcoin
[26] difficulty adjustment) and physical resources (e.g., energy for
performing actual computation) and not just using cryptographic

This work is licensed under a Creative Commons Attribution
International 4.0 License.

ConsensusDay â€™22, November 7, 2022, Los Angeles, CA, USA
Â© 2022 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-9879-4/22/11.
https://doi.org/10.1145/3560829.3563563

Figure 1: Illustration of the long-range attack. After the
green validators (i.e., validators associated with the green
key on the figure) left the system, the adversary acquired
their keys. In a PoS blockchain, having access to validatorsâ€™
keys is enough to create new blocks and hence the adversary
can create a chain as long as the honest chain (perhaps even
simulating configuration change in its chain). Any user that
trusted the green key and is presented with both chains can-
not differentiate the honest from the adversarial chain.

keys. A client of a PoS blockchain would be unable to recognize the
attack as they are presented with a â€œvalidâ€ chain fork. See Figure 1
for a visual explanation of the attack.

Recently, Steinhoff et al. [30] proposed an approach to deal
with LRA by anchoring (checkpointing) the PoS membership into
Ethereumâ€™s proof-of-work blockchain (Eth 1.0), which is not vul-
nerable to this type of attack. The main idea of their work is to have
a smart contract on the Ethereum blockchain that keeps track of
the state of the membership of the underlying PoS system. For a
typical Byzantine Fault-Tolerant (BFT) protocol underlying a PoS
blockchain, the smart contract on Ethereum would only be updated
if, e.g., two thirds of the current staking power (or blockchain mem-
bers in case of uniform voting rights) instruct the smart contract to
do so. In the approach of Steinhoff et al. each validator will send a
transaction to the smart contract that indicates a vote for a new set
of validators. As soon as two thirds of the votes for the same set
have been received, the smart contract automatically updates its
state to the new set. From this moment on, the members of the new
set are in charge of voting for the next set and so forth. Every user
that needs to verify that a set of validators are indeed legitimate and
most recent ones, can do so by simply checking the smart contract.
An adversary cannot change the state of the smart contract, even
with the keys of former validators, without creating a fork on the
PoW blockchain, which is considerably more, if not prohibitively
expensive. Any user can resort to the Ethereum smart contract to
verify the correct state of the checkpointed PoS chain, effectively
preventing the LRA attack.

 
 
 
 
 
 
ConsensusDay â€™22, November 7, 2022, Los Angeles, CA, USA

Sarah Azouvi and Marko VukoliÄ‡

However, as it happens, Ethereum is abandoning PoW and tran-
sitions to PoS [11] (Eth 2.0). Hence, the approach of Steinhoff et al.
is no longer viable as PoS of Eth 2.0 cannot be used instead of PoW
for anchoring as it is itself susceptible to the LRA vulnerability. In
this paper, we design a solution to LRA, inspired by Steinhoff et
al., using Bitcoinâ€™s PoW, assuming that Bitcoin will never change
its underlying consensus mechanism. The history of altcoin forks
off Bitcoin and the Bitcoin development ethos give very realistic
assurance that this assumption will hold.1

However, the implementation and design of such a scheme on
Bitcoin is more challenging, compared to the implementation of
Steinhoff et al. on Eth 1.0, because Bitcoinâ€™s scripting language
expressivity is considerably more limited compared to smart con-
tracts on Ethereum. Besides, the approach designed by Steinhoff
et al. leverages multi-signatures for anchoring, which can quickly
bloat the transaction size, making it at worst impossible to anchor
PoS networks with large number of validators, or, at best, very
costly to do so.

To address these limitations, our approach is to use the capabili-
ties enabled by the recent Taproot upgrade [3] to Bitcoin, which
allows for more efficient Schnorr threshold signatures. Briefly, our
protocol, called Pikachu, works as follows. As Bitcoin does not
allow for stateful smart contracts, we use an aggregated public key
to represent the configuration of validators ğ¶ğ‘– in the PoS system.
When the set changes significantly enough to configuration ğ¶ğ‘–+1,
the aggregated key must be updated in the Bitcoin blockchain. This
is done by having a transaction transferring the funds associated
with the aggregated key of the previous validators ğ¶ğ‘– to the new ag-
gregated key controlled by validators in configuration ğ¶ğ‘–+1. Instead
of having each validator in ğ¶ğ‘– send a transaction to the Bitcoin
network, this transaction is signed interactively, off-chain, and all
the signatures are aggregated into one constant-size signature. Fur-
thermore, we store the Merkle root of the state of the checkpointed
PoS blockchain in the Bitcoin ğ‘‚ğ‘ƒ_ğ‘…ğ¸ğ‘‡ğ‘ˆ ğ‘…ğ‘ field of the transaction
from ğ¶ğ‘– to ğ¶ğ‘–+1. We store the data pertaining to this checkpoint off
Bitcoin blockchain. While the data pertaining to the checkpoint
could be stored anywhere (e.g., IPFS [28]) and validated against the
state root stored in the Bitcoin transaction â€” our implementation
uses a content-addressable key-value store implemented on top
of the PoS system to store the actual checkpointed state. Figure 2
illustrates the high-level protocol. We note that since our work is
based on Schnorr threshold signatures and uses Bitcoinâ€™s Taproot,
it could be of independent interest to any project looking to im-
plement threshold signing transactions on Bitcoin (for example,
sidechains [2]).

To summarize, our contribution is as follows. Starting from the
observation that PoW gives much stronger security guarantees
than PoS, we present a protocol to protect current PoS blockchains
against LRA by anchoring their state onto Bitcoinâ€™s blockchain. The
advantage of using Bitcoin unlike, for example, a website, is that it
is itself decentralized, hence our protocol does not add any single
point-of-failure to a decentralized PoS system. We implemented
our protocol on top of a delegated PoS blockchain and tested it on

1The discussion on long-term viability of energy consumption of Bitcoin is out of
scope of this paper and is available elsewhere [33].

Figure 2: High-level visualization of the Pikachu protocol.
Checkpoints from the PoS chain (in blue) are periodically
pushed to the Bitcoin blockchain (in orange) by the PoS
Validators. The checkpoints contain the Taproot address ğ‘„
(which itself contains the aggregated public key of the con-
figuration and commitment to the PoS chain ckpt) as well
as a content identifier ğ‘ğ‘–ğ‘‘ that can be used with any content-
addressable storage to retrieve information about the con-
figuration (IPFS pictured).

Bitcoin testnet storing checkpoints into a key-value store main-
tained by the PoS validators (although alternative storage method,
such as IPFS could be used).

The rest of this paper is organized as follows. We start by pro-
viding the necessary background in Section 2 and our model and
assumptions in Section 3. We present our design in Section 4 then
a security argument in Section 5. Section 6 presents the implemen-
tation of the protocol. We discuss related work in Section 7.

2 BACKGROUND
We use elliptic curve notation for the discrete logarithm problem.
Suppose ğ‘ is a large prime and ğº, ğ½ are generators of a subgroup of
order ğ‘ of an elliptic curve E. We assume that E is chosen in such a
way that the discrete logarithm problem in the subgroup generated
by ğº is hard, so it is infeasible to compute the integer ğ‘‘ such that
ğº = ğ‘‘ ğ½ .

Let ğ», ğ»1, ğ»2, ğ»ğ‘‡ ğ‘ğ‘ğ‘‡ ğ‘¤ğ‘’ğ‘ğ‘˜ be cryptographic hash functions map-
â†âˆ’ ğ‘† that ğ‘¥ is selected uniformly at

ğ‘. We denote by ğ‘¥ $

ping to Zâˆ—
random from ğ‘†.

2.1 Schnorr signature
The Schnorr signing scheme [29] works as follows. Let (ğ‘ , ğ‘Œ ) âˆˆ
Zâˆ—
ğ‘ Ã— E be a user key pair (such that ğ‘Œ = ğ‘ ğº) and ğ‘š a message to be
signed. The signer performs the following steps.

(1) ğ‘˜ $
â†âˆ’ Zâˆ—
ğ‘
(2) ğ‘… â† ğ‘˜ğº
(3) ğ‘§ â† ğ‘˜ + ğ» (ğ‘š||ğ‘…||ğ‘Œ ) Â· ğ‘  mod ğ‘

The signature is then (ğ‘§, ğ‘…) and is verified by checking that ğ‘§ğº ?=
ğ‘… + ğ» (ğ‘š||ğ‘…||ğ‘Œ )ğ‘Œ .

2.2 Secret sharing schemes
A secret sharing scheme allows one participant (a dealer) to share a
secret with ğ‘› other participants, such that any ğ‘¡ of them can recover

cidCitx1tx2Information about current conï¬gurationQ1â†’Q2Q2â†’Q3cid2cid3Pikachu: Securing PoS Blockchains from Long-Range Attacks by Checkpointing into Bitcoin PoW using Taproot

ConsensusDay â€™22, November 7, 2022, Los Angeles, CA, USA

the secret but any set of ğ‘¡ âˆ’ 1 or less of them cannot. Furthermore,
a desirable property of a secret sharing scheme is to be publicly
verifiable, i.e., anyone should be able to verify that the dealer com-
puted the correct shares and did not cheat. In this paper, we will
use Feldmanâ€™s verifiable secret sharing scheme [12] (VSS), which
we describe in steps 1-3 of Figure 5.

2.2.1 Generating a secret. Unlike Feldmanâ€™s VSS scheme, in which
only one participant generates a secret and shares it with their
peers, we consider a protocol where everyone contributes equally
to generate a common secret, such that no set of participants of
size strictly smaller than ğ‘¡ can recover the secret on their own. We
will use the scheme designed by Gennaro et al. [17] that we define
in Figure 5, and we adopt the following notation:

(ğ‘ 1, Â· Â· Â· , ğ‘ ğ‘›)

(ğ‘¡,ğ‘›)
â†âˆ’âˆ’â†’ (ğ‘Ÿ, ğ‘Œ , ğ‘ğ‘˜ğº, ğ‘†0), ğ‘˜ âˆˆ {1, Â· Â· Â· , ğ‘¡ âˆ’ 1}

to mean that ğ‘  ğ‘— is player ğ‘—â€™s share of the secret ğ‘Ÿ for each ğ‘— âˆˆ ğ‘†0.
The values ğ‘ğ‘˜ğº are the public commitments used to verify the
correctness of the shares and (ğ‘Ÿ, ğ‘Œ ) forms a key pair where ğ‘Ÿ is
a private key and ğ‘Œ is the corresponding public key. The set ğ‘†0
denotes the set of players that have not been detected to be cheating
during the execution of the protocol. This protocol is secure for
any ğ‘¡ > ğ‘›
2 (i.e., it can tolerate an adversary that corrupts up to half
of the participants).

2.3 Threshold signing
A ğ‘¡-of-ğ‘› threshold signing scheme allows any combination of ğ‘¡ par-
ticipants to sign a message while preventing any coalition of ğ‘¡ âˆ’ 1
participants or less to create a valid signature, i.e., at least ğ‘¡ partici-
pants must agree to sign the message for the signature to be valid.
We use the threshold signing protocol FROST [21], that we define
in Figure 6. This interactive protocol will either output a Schnorr
signature (ğ‘§, ğ‘…) on a message ğ‘š or a abort message, together with
a set of misbehaving participants such that the protocol can be
rerun without these misbehaving participants in the next step. The
protocol relies on a signature aggregator (SA), however, as the main
role of the SA is to choose the subset of participants designated
for signing, it can easily be removed. Instead, we can have each
participant compute the set in a deterministic way. Alternatively,
in the case of PoS chain, we could choose this set pseudo-randomly
using some randomness coming from the chain (random numbers
are often created as part of a PoS protocol as they are needed for,
e.g., leader election).

Choice of the Schnorr signing protocol. We chose to use the FROST
signing protocol because it is more efficient than alternative proto-
cols, such as the Stinson and Strobl [31] protocol, even though it
is not robust, i.e., the protocol cannot complete if one participant
aborts or misbehaves. However, misbehaving participants are de-
tectable in FROST (each public share is verifiable against a public
key), so the protocol can simply be restarted from scratch without
those malicious participants. We did not use other Schnorr signing
protocols [10, 27] as they are not compatible with threshold signing.
Note that we did not implement the key generation algorithm
presented by Komlo and Goldberg [21], used originally in FROST,
as it does not allow to detect misbehaving participants, therefore

losing the ability to re-start the protocol without the misbehav-
ing participants. Instead, we will use the scheme by Gennaro et
al. [16] and borrow only the signing scheme presented in the FROST
paper [21], as per the authorsâ€™ suggestion. The distributed key gen-
eration (DKG) algorithm by Gennaro et al. is also used by Stinson
and Strobl [31] and has the advantage of being robust (it will com-
plete despite misbehaving participants, who are detected through a
complaint process). We follow the suggestion in Gennaro et al. [17]
and use the simpler variant of the DKG, JF-DKG, as this is sufficient
for our application of threshold signing.

The main reason for preferring an efficient but non-robust sign-
ing algorithm is that our protocol will eventually be incentivized
(financial rewards will be given out to participants who perform
the signature). Therefore, it is reasonable to expect participants to
cooperate, especially when malicious behavior is detectable and
can only delay â€” not prevent â€” the signing. Because both the DKG
and the signing part of our protocol are modular, other threshold
signing protocols can be used interchangeably for different threat
models (e.g., including the robust signing protocol in [31]).

2.4 Taproot
Taproot is a recent Bitcoin network upgrade that allows transac-
tions to be signed using Schnorr signatures and that introduces a
new data-structure, Merkelized Abstract Syntax Trees (MAST), for
more advanced scripting in a privacy-preserving way. The main
advantage of Schnorr signatures over the ECDSA multi-signature
is that they enable signature aggregation, saving space in Bitcoin
blocks while also providing more privacy as it is not possible to dis-
tinguish between a â€œregularâ€ transaction, i.e., sending bitcoins from
one person to another, and a more complex one, e.g., using a thresh-
old signature. This could help hide identities in the blockchain
and thwart clustering deanonymization [24] although we are not
interested in this property for this work.

A Taproot address has two components: a single public key
(the internal key) and a script tree, identified by its Merkle root.
Either component can be used independently to spend the UTXO.
In the case of threshold or multi-signatures, the internal key can
be the aggregated public key of all the signers. The script tree can
contain an arbitrary number of different scripts, each of which
specify a condition that must be satisfied in order for the coins
to be spendable. For example, one condition can be to give the
pre-image of a hash. As the name suggests, in the script tree, the
scripts are organized in a tree (see Figure 3). The transaction can
be spent either by using the internal secret key (key path) or by
satisfying one of the conditions in the tree (script path). In this
paper, we are interested in spending a Taproot output using the
key path. It should be noted that it is possible to use the script tree
to define a threshold signature scheme [25], though less efficient as
the size of the tree would grow exponentially with the number of
participants [2].

We now detail how to spend a Taproot output using the key

path.

2.4.1 Key path spending. To prevent a potential vulnerability in
which one user of a threshold or multi-signature could steal all the
funds [4], the output key should commit to a (potentially unspend-
able) script path even if the spending condition does not require

ConsensusDay â€™22, November 7, 2022, Los Angeles, CA, USA

Sarah Azouvi and Marko VukoliÄ‡

of proof-of-storage).We call the set of weighted participants in a
configuration the power table. The power table is determined by a set
of signing keys and their associated weight: ğ¶ = {(ğ‘ƒğ‘œğ‘†.ğ‘ğ‘˜ğ‘–, ğ‘¤ğ‘– )} |ğ¶ |
ğ‘–=1.
Each signing private key ğ‘ƒğ‘œğ‘†.ğ‘ ğ‘˜ğ‘– is private to ğ‘–-th participant. For
simplicity, we consider a flat model, i.e., one participant accounts
for one unit of power in the PoS blockchain, hence we omit the
weight from our model moving forward. The flat model could be
generalized by considering that one participant with ğ‘¥ units of
power possesses ğ‘¥ public keys, one for each of their units of power.
We will discuss how this assumption impacts the scalability of
our protocol in Section 8. Furthermore, we assume that there is
some similarity between successive configurations of the system,
i.e., the set of participants does not change completely from one
configuration to another. Formally, we define the difference between
two configurations ğ¶ ğ‘— and ğ¶ğ‘– as their symmetric difference (ğ¶ğ‘– â–³ğ¶ ğ‘— ),
which corresponds to the number of reconfiguration requests that
need to be applied to ğ¶ğ‘– in order to obtain ğ¶ ğ‘— . We assume that
for two consecutive configurations ğ¶ğ‘– and ğ¶ğ‘–+1, their symmetric
difference is bounded by some parameter ğ‘.

Following [1], we define a perpetually honest participant as a
participant that follows the protocol and maintains the secrecy
of their signing keys in perpetuity (an adversary may never have
access to them). This is opposed to an eventually compromised
participant who after some time, leaks all its previous signature
keys to the adversary.

We assume that the PoS is secure, i.e., satisfies the usual security
properties of consistency, chain growth, and chain quality [14],
as long as a sufficient fraction of the participants are perpetually
honest. Let ğ‘“ be the maximum fraction of power that an adversary
can control while the protocol maintains its security when the
rest of the power table is perpetually honest (e.g., ğ‘“ = 1/3). For
simplicity, we assume that this blockchain provides instant finality,
i.e., that there are no forks. This can be achieved using some variant
of a BFT-protocol [7, 18] or relaxed by using a â€œlookbackâ€ parameter.
For example, if a block is final after ğ‘˜ confirmations, then we will
use the state of the chain ğ‘˜ blocks in the past instead of the latest
state to ensure consistent views across participants.

For the rest of this paper we will consider the security of the PoS
chain under eventually compromised honest participant as follows.
We consider an adversary A that, for each state ğ‘– of the PoS system,
controls all the keys from previous configurations (ğ¶ ğ‘— ) ğ‘— <ğ‘–âˆ’ğ¿ where
ğ¿ â‰« 1 is a parameter (assumption 1) as well as a fraction of at most
ğ‘“ participants in configurations (ğ¶ ğ‘— )ğ‘–âˆ’ğ¿ â‰¤ ğ‘— â‰¤ğ‘– (assumption 2). We
quickly note that ğ‘“ < 1
2 since there does not exist any protocol that
is secure with ğ‘“ > 1
2 .

Under this assumption, the adversary is able to mount a LRA
as follows. The adversary starts a fork of the PoS chain at height
ğ‘— < ğ‘– âˆ’ ğ¿, using the keys from configuration ğ¶ ğ‘— and that runs until
the current height ğ‘–. Since the adversary does not hold the keys
from configuration ğ‘– âˆ’ğ¿ and above, this means that from this height,
the configurations on the adversarial fork and on the honest chain
must differ. Note that under this attack, any online validator is able
to differentiate the correct chain from a chain created as part of a
LRA (since they are not part of the configurations in the adversarial
fork). In the rest of the paper we use correct chain to mean the chain
in the view of the online validators. Our protocol will ensure that

Figure 3: Taproot Output Composition

a script path (i.e., if only the key path is going to be used). There
are multiple ways to achieve this with Taproot. The most natural
way is to simply include the internal public key in the â€œtweak.â€ The
tweaked public key (i.e., outer key) is then computed as follows:
ğ‘„ = ğ‘ƒ + int(ğ»ğ‘‡ ğ‘ğ‘ğ‘‡ ğ‘¤ğ‘’ğ‘ğ‘˜ (ğ‘ğ‘¦ğ‘¡ğ‘’ğ‘  (ğ‘ƒ)))ğº
where ğ‘ƒ is the internal public key and ğ»ğ‘‡ ğ‘ğ‘ğ‘‡ ğ‘¤ğ‘’ğ‘ğ‘˜ is a hash function.
The associated tweaked private key is then:

ğ‘ = ğ‘ + int(ğ»ğ‘‡ ğ‘ğ‘ğ‘‡ ğ‘¤ğ‘’ğ‘ğ‘˜ (ğ‘ğ‘¦ğ‘¡ğ‘’ğ‘  (ğ‘ƒ)))
where ğ‘ is the private key associated with ğ‘ƒ. In order to spend the
output using the key path, one must then sign the transaction with
the tweaked private key.

Adding a commitment. Alternatively, the script path could be
used to add a commitment. For example in our case this commitment
could be the hash of the underlying PoS chain at regular intervals.
Let ğ‘ denote this commitment. In this case, the tweaked public key
becomes: ğ‘„ = ğ‘ƒ + ğ»ğ‘‡ ğ‘ğ‘ğ‘‡ ğ‘¤ğ‘’ğ‘ğ‘˜ (ğ‘ƒ ||ğ‘)ğº and the tweaked private key
ğ‘ = ğ‘ + ğ»ğ‘‡ ğ‘ğ‘ğ‘‡ ğ‘¤ğ‘’ğ‘ğ‘˜ (ğ‘ƒ ||ğ‘). The script path is still unspendable, and
the output is spent by signing using the tweaked private key.

2.4.2 Transaction notation. For any Bitcoin transaction, we use
the following notation:

, . . . , outputğ‘— with, respectively, amount1,. . . , amountğ‘— .

, . . . , inputğ‘– â†’ ((amount1, output1), . . . , (amountğ‘— , outputğ‘— ))
. . . , inputğ‘– are trans-

input1
to say that all the coins associated with input1
ferred to output1
As a reminder, since Bitcoin is UTXO based, all the coins from an
input must be transferred during the transaction, although to po-
tentially multiple addresses. Additionally, it must be the case that
.amount + Â· Â· Â· + inputğ‘– .amount
amount1 + Â· Â· Â· + amountğ‘— â‰¤ input1
where inputğ‘˜ .amount represents the total amount associated with
inputğ‘˜ . The remaining amount (in the case of a strict inequality) is
used as a transaction fee for the miner mining the block.

3 MODEL AND ASSUMPTIONS
We assume an underlying blockchain based on a reusable resource
such as PoS or proof-of-space . Each state of the PoS blockchain is
associated with a set of participants, called the configuration and
denoted by ğ¶, and their corresponding power (e.g., number of coins
staked in the case of proof-of-stake and storage space in the case

Public key
(Tweaked)Internal Key
Schnorr
(Aggregated)Merkle RootHash 1Hash 2Script 1Script 2TweakPikachu: Securing PoS Blockchains from Long-Range Attacks by Checkpointing into Bitcoin PoW using Taproot

ConsensusDay â€™22, November 7, 2022, Los Angeles, CA, USA

any user is also able to distinguish each chain even if they have
been offline, by looking at the Bitcoin blockchain. We discuss the
security properties that the protocol should achieve in Section 5.
We add another, optional, assumption: the existence of a random
beacon (RBğ‘– )ğ‘– âˆˆN that emits a new randomness for each state of
the database (i.e., at each height of the underlying PoS blockchain).
This is a standard assumption in PoS blockchains as a random
beacon is necessary for the leader election part of the protocol. This
randomness will be used by participants to pseudo-randomly select
the set of signers. Another option would be to select this set in any
deterministic manner.

Lastly, participants will use the PoS chain to broadcast the mes-
sages relative to our Pikachu protocol (although another broadcast
channel could be implemented alternatively). We assume that each
message is included in the chain (or broadcast) after a small number
of blocks.

4 PROTOCOL
4.1 Overview
The intuition behind the protocol is as follows: each configura-
tion ğ¶ğ‘– is associated with a Taproot public key ğ‘„ğ‘– that consists
of an internal key, in this case an aggregate public key ğ‘ğ‘˜ğ‘– , that
participants computed with an interactive DKG protocol (step 1
of the main algorithm protocol in Figure 4) and a tweaked part as
defined in Section 2.4.1. We chose to tweak the internal key using a
commitment to the PoS chain (i.e., the hash of the state of the PoS
blockchain). Each player ğ‘— in the configuration then knows a share
of the secret key associated with ğ‘ğ‘˜ğ‘– , ğ‘ ğ‘–,ğ‘— , such that ğ‘¡ğ‘– of the shares
are enough to compute a valid signature on any message, but fewer
than ğ‘¡ğ‘– participants cannot compute a signature. Configuration ğ¶ğ‘–
is responsible for anchoring the state of the PoS chain at this point
in time in the Bitcoin blockchain, which also includes updating
the new configuration. In order to do so, the new configuration
ğ¶ğ‘–+1 must first compute their aggregated public key ğ‘ğ‘˜ğ‘–+1 using the
DKG algorithm. This key is then tweaked using a commitment ckpt
to the PoS chain (i.e., the hash of the PoS chain at that time). The
tweaked key becomes ğ‘„ğ‘–+1 = ğ‘ğ‘˜ğ‘–+1 + ğ»ğ‘‡ ğ‘ğ‘ğ‘‡ ğ‘¤ğ‘’ğ‘ğ‘˜ (ğ‘ğ‘˜ğ‘–+1||ckpt)ğº.
Note that only the tweaked key will appear on the blockchain so the
hash ckpt will not be visible by anyone looking at the blockchain
without external knowledge. However, anyone who has access to
ğ‘ğ‘˜ğ‘–+1 and ckpt can easily reconstruct ğ‘„ğ‘–+1 to verify that their view
of the PoS chain is correct.

To update the configuration from ğ¶ğ‘– to ğ¶ğ‘–+1, a transaction from
ğ‘„ğ‘– to ğ‘„ğ‘–+1 must be included in the Bitcoin blockchain (steps 3
and 4 in Figure 4). Leveraging the recent Bitcoin Taproot upgrade
(that allows for Schnorr signatures), the transaction needs to be
signed by ğ‘¡ğ‘– participants from configuration ğ¶ğ‘– where ğ‘¡ğ‘– is chosen
to be strictly more than ğ‘“ |ğ¶ğ‘– | as this ensures that at least one
honest participant signs, preventing an adversary from signing
an illegitimate transaction. As discussed previously, we will use
the FROST algorithm for signing. Note that, the DKG requires
that ğ‘¡ğ‘– > 0.5|ğ¶ğ‘– | to ensure security so our final constraint on ğ‘¡ğ‘– is
ğ‘¡ğ‘– > max(0.5|ğ¶ğ‘– |, ğ‘“ |ğ¶ğ‘– |). Since we assume that online validators
can distinguish a LRA chain, it is enough to have the transaction
signed by ğ‘¡ğ‘– participants as no honest validators can be fooled into
signing an illegitimate transaction. If forks were allowed even in

the case of perpetually honest validators (i.e., outside of LRA forks),
this would be more problematic, as two conflicting transactions
could then be signed, and we would require at least two thirds of
the participants to sign the transaction, for ğ‘“ = 1/3 (as previously
mentioned, this can also be fixed by considering a block in the past,
i.e., one that has been finalized).

In addition to the transfer of coins from ğ‘„ğ‘– to ğ‘„ğ‘–+1, the transac-
tion spent by configuration ğ¶ğ‘– will have a second output that does
not receive any bitcoins and that is unspendable, but that contains
an identifier ğ‘ğ‘–ğ‘‘ used to retrieve the full details of the configuration.
This is done using the ğ‘‚ğ‘ƒ_ğ‘…ğ¸ğ‘‡ğ‘ˆ ğ‘…ğ‘ opcode of Bitcoin [5] that
allows storing of extra information in the chain, which we use to
store ğ‘ğ‘–ğ‘‘. This identifier will be useful in the case where a user
does not have access to the right PoS chain (i.e., does not have the
correct value for ğ‘ğ‘˜ğ‘–+1 and ckpt due to a LRA). In this case, the con-
tent identifier ğ‘ğ‘–ğ‘‘ can be used, together with a content-addressable
decentralized storage, for example IPFS [28] or Filecoin [13] (or
a content-addressable storage implemented on the PoS network
validators) to retrieve the identities of the nodes in the correct con-
figuration. The transaction updating the configuration will look as
follows:

txğ‘– : ğ‘„ğ‘– â†’ ((amount, ğ‘„ğ‘–+1), (0, ğ‘‚ğ‘ƒ_ğ‘…ğ¸ğ‘‡ğ‘ˆ ğ‘…ğ‘ = ğ‘ğ‘–ğ‘‘ğ‘–+1))

meaning that amount is transferred to ğ‘„ğ‘–+1 and 0 is transferred to
ğ‘‚ğ‘ƒ_ğ‘…ğ¸ğ‘‡ğ‘ˆ ğ‘…ğ‘ = ğ‘ğ‘–ğ‘‘ğ‘–+1 (unspendable output). This information is
then publicly available. We discuss in Section 4.3 how any user can
then use it to get the latest PoS configuration.

We add the following assumption (assumption 3): we assume that
txğ‘– is finalized in the Bitcoin blockchain before the configuration
ğ¶ğ‘–+ğ¿ is formed, where ğ¿ â‰« 1 is the parameter defined in assumption
1 (Section 3).

The high-level description of the protocol is presented in Figure 4
and the pseudocode in Algorithm 1. The pseudocode for our DKG
and signing subroutines are presented in Algorithms 2 and 3. In
all our pseudocode, the notation âŸ¨ğ‘šğ‘ ğ‘”âŸ©ğ‘– means that message ğ‘šğ‘ ğ‘”
was sent by participant ğ‘– and we use PM(âŸ¨ğ‘šğ‘ ğ‘”âŸ©, ğ‘–) to denote that a
private message ğ‘šğ‘ ğ‘” was sent to participant ğ‘–.

We make the following remarks about our protocol. First, in
steps 3b and 5 we ask that every participant ğ‘ƒ ğ‘— in configuration
ğ¶ğ‘– publishes the configuration state to the decentralized storage
provider and sends the signed transaction txğ‘– to the Bitcoin network.
We do so out of caution. In practice only one validator needs to
do so, but this validator could be controlled by the adversary and
abort instead.

Second, in step 4 of the protocol, we remark that the final signa-

ture on the transaction, ğ‘§ â€², is â€œtweakedâ€ using

ğ» (txğ‘– ||ğ‘…||ğ‘„ğ‘– )ğ»ğ‘‡ ğ‘ğ‘ğ‘‡ ğ‘¤ğ‘’ğ‘ğ‘˜ (ğ‘ğ‘˜ğ‘– ||ckpt).

This is because because the signature computed as part of the
FROST signing algorithm will verify against the key ğ‘ğ‘˜ğ‘– , computed
during the DKG but not ğ‘„ğ‘– = ğ‘ğ‘˜ğ‘– + ğ»ğ‘‡ ğ‘ğ‘ğ‘‡ ğ‘¤ğ‘’ğ‘ğ‘˜ (ğ‘ğ‘˜ğ‘– ||ckpt). For the
signature to be valid on the taproot output, the signature must
verify against the tweaked key ğ‘„ğ‘– . Because Schnorr is additive, it is
enough to add the term ğ» (txğ‘– ||ğ‘…||ğ‘„ğ‘– )ğ»ğ‘‡ ğ‘ğ‘ğ‘‡ ğ‘¤ğ‘’ğ‘ğ‘˜ (ğ‘ğ‘˜ğ‘– ||ckpt) to the
signature. Indeed one can verify that if ğ‘§ğº = ğ‘… + ğ» (txğ‘– ||ğ‘…||ğ‘„ğ‘– )ğ‘ğ‘˜ğ‘–

ConsensusDay â€™22, November 7, 2022, Los Angeles, CA, USA

Sarah Azouvi and Marko VukoliÄ‡

then
ğ‘§ â€²ğº = ğ‘§ğº + ğ» (txğ‘– ||ğ‘…||ğ‘„ğ‘– )ğ»ğ‘‡ ğ‘ğ‘ğ‘‡ ğ‘¤ğ‘’ğ‘ğ‘˜ (ğ‘ğ‘˜ğ‘– ||ckpt)ğº

= ğ‘… + ğ» (txğ‘– ||ğ‘…||ğ‘„ğ‘– )ğ‘ğ‘˜ğ‘– + ğ» (txğ‘– ||ğ‘…||ğ‘„ğ‘– )ğ»ğ‘‡ ğ‘ğ‘ğ‘‡ ğ‘¤ğ‘’ğ‘ğ‘˜ (ğ‘ğ‘˜ğ‘– ||ckpt)ğº
= ğ‘… + ğ» (txğ‘– ||ğ‘…||ğ‘„ğ‘– )(ğ‘ğ‘˜ğ‘– + ğ»ğ‘‡ ğ‘ğ‘ğ‘‡ ğ‘¤ğ‘’ğ‘ğ‘˜ (ğ‘ğ‘˜ğ‘– ||ckpt)ğº)
= ğ‘… + ğ» (txğ‘– ||ğ‘…||ğ‘„ğ‘– )ğ‘„ğ‘–

4.2 Initialization and funding
The initial key ğ‘„0 is created by having the first configuration run
the DKG, and tweak it with a hash of the genesis block of the PoS
chain. In order to fund the initial transaction, we want each partici-
pant in ğ¶0 to send a small amount of bitcoins to ğ‘„0. However it is
not possible to enforce this. A participant that does not contribute
to the fee would still hold a share of the secret key associated with
ğ‘„0. Indeed ğ‘„0 must be determined before the participants send
their transactions, otherwise they do not know where to send their
funds. But once ğ‘„0 is computed everyone who participated in the
DKG knows a share of the secret regardless of whether they send
some funds to it. We thus need to make sure that participants are in-
centivized to contribute to the fees. One way to do so is to have each
participant who sent some funds to ğ‘„0 in the Bitcoin blockchain be
rewarded, in exchange, with some PoS coins. Verifying the validity
of Bitcoin transactions is, however, not trivial. Verifying the signa-
ture only is not enough as the transaction could be double spending.
Hence, additional data is required by a verifier. More specifically, a
verifier would need to verify that the transaction is included in the
Bitcoin blockchain at least ğ‘˜ blocks deep - where ğ‘˜ is a parameter
corresponding to Bitcoinâ€™s settlement time. With this in mind, we
propose the following protocol.

We consider the following parameters: a deadline â„0 (represented
as a height in the Bitcoin blockchain); the settlement time ğ‘˜ after
which a block is considered "finalized" in the Bitcoin blockchain (e.g.
6 blocks); release expressed as a height in the Bitcoin blockchain
chain, chosen conservatively high.

(1) Each participant ğ‘ƒğ‘– in ğ¶0 submit a commitment to their Bit-
coin public key ğ‘ğ‘¡ğ‘.ğ‘ğ‘˜ğ‘– (e.g. a hash ğ»1 (ğ‘ğ‘¡ğ‘.ğ‘ğ‘˜ğ‘– )) to the PoS
chain. This is to prevent participants from later on "stealing"
each other rewards by pretending to have sent some bitcoins
that someone else sent.

(2) Configuration ğ¶0 interactively performs the DKG to create
the key ğ‘ğ‘˜0. Each participant in ğ¶0 holds a share of the secret
key associated. The key is then tweaked with a commitment
to the PoS genesis block to give ğ‘„0.

(3) Each participant ğ‘ƒğ‘– in ğ¶0 send a small amout fee from ğ‘ğ‘¡ğ‘.ğ‘ğ‘˜ğ‘–
to ğ‘„0. This transaction should be sent several heights before
height â„0. They add a timelock [6] such that if the output
is not spent after release blocks, ğ‘ƒğ‘– gains control of their
bitcoins back. We denote this transaction ğ‘–ğ‘›ğ‘–ğ‘¡ .ğ‘¡ğ‘¥ğ‘– .

(4) Once the Bitcoin chain has reached height at least â„0 + ğ‘˜ the
participants can start the interactive signing. They create the
transaction by spending all the UTXOs that were received by
ğ‘„0 before block â„0 (this ensures that everyone will sign the
same transaction). We note tx0 this transaction. Every trans-
action ğ‘–ğ‘›ğ‘–ğ‘¡ .ğ‘¡ğ‘¥ğ‘– not included in the initial transaction tx0 (e.g.
because it was included too late in the bitcoin blockchain)
can be sent back to its original sender due to the timelock.

(5) If ğ‘–ğ‘›ğ‘–ğ‘¡ .ğ‘¡ğ‘¥ğ‘– was included in the inputs of tx0, ğ‘ƒğ‘– can submit
evidence of this in the Filecoin chain using tx0 (i.e. everyone
can verify that ğ‘–ğ‘›ğ‘–ğ‘¡ .ğ‘¡ğ‘¥ğ‘– is in the list of input of tx0 and that the
signature is correct). Since no adversary can forge a signature
from ğ‘„0, due to the security of the threshold signing scheme,
no proof can be forged for ğ‘–ğ‘›ğ‘–ğ‘¡ .ğ‘¡ğ‘¥ğ‘– inclusion in tx0.

(6) If ğ‘–ğ‘›ğ‘–ğ‘¡ .ğ‘¡ğ‘¥ğ‘– was not included in the inputs of tx0, then ğ‘ƒğ‘– does

not get any reward.

(7) Every PoS miner verifies that ğ‘–ğ‘›ğ‘–ğ‘¡ .ğ‘¡ğ‘¥ğ‘– was indeed included
in tx0 (as described above), then verifies that ğ‘ğ‘¡ğ‘.ğ‘ğ‘˜ğ‘– indeed
belongs to ğ‘ƒğ‘– . If both checks pass, ğ‘ƒğ‘– is awarded an amount
of PoS coins proportional to the amount sent by ğ‘–ğ‘›ğ‘–ğ‘¡ .ğ‘¡ğ‘¥ğ‘– .
This amount should be high enough to not only compensate
the fee paid by ğ‘ƒğ‘– but also incentivized them to sent the fee
(i.e., the reward must be higher than the fee, although it is
not trivial to compare the value of two cryptocurrencies,
these values can be chosen conservatively). The reward can
be taken from the coins minted, as is usually the case in
crypto-currencies reward scheme.

For every checkpointing transaction on the Bitcoin blockchain,
we use a constant fee btc.fee chosen high enough to tolerate po-
tential congestion period in the Bitcoin blockchain. As a reminder,
thanks to the Taproot update, the size of the transaction in our
protocol is constant in the number of participant hence choosing a
constant transaction fee is enough for our purpose, although we
may end up over-paying during non-congested periods. We also
remark that our protocol is assumed to be run at a relatively low
pace (e.g., once a day) hence we can tolerate longer delays in hav-
ing the checkpointing transaction included in the Bitcoin chain in
periods of short-term congestion. For reference , as of May 2022,
the cost of a checkpointing transaction on Bitcoin mainnet would
be around $0.07 (around 200 sats).

When the funds from the initial transaction run out, a protocol

as the one described above can be used to refill them.

4.3 Verification
Once the protocol described in Figure 4 has been run by the partic-
ipants, users of the PoS system who went offline for an extended
period of time can use the Bitcoin blockchain to determine the
correct configuration and state of the chain. Informally, the verifi-
cation protocol works as follows: users, who are aware of the initial
aggregated public key ğ‘„0, which serves as an identifier of the PoS
blockchain on the Bitcoin blockchain, can follow the chain of trans-
actions from ğ‘„0 to the newest public key ğ‘„ğ‘– . The latest transaction
in the chain (i.e., from ğ‘„ğ‘–âˆ’1 to ğ‘„ğ‘– ) contains an additional output that
corresponds to the content identifier of the configuration ğ¶ğ‘– . The
user can then use this identifier to retrieve the configuration using
IPFS (or another content-addressable decentralized storage, e.g.,
one implemented on top of the PoS chain). The high-level protocol
is described below and the pseudocode is given in Algorithm 4.

(1) Synchronize with the Bitcoin blockchain (e.g., by running a

Bitcoin full node.2)

(2) Look for ğ‘„0 and follow the chain of transactions to get txğ‘–

and ğ‘ğ‘–ğ‘‘ğ‘– , i.e.,

2Bitcoin full nodes can be run on relatively cheap hardware, e.g., Raspberry Pi and
1TB disk, in a setup that costs less than $200 USD.

Pikachu: Securing PoS Blockchains from Long-Range Attacks by Checkpointing into Bitcoin PoW using Taproot

ConsensusDay â€™22, November 7, 2022, Los Angeles, CA, USA

We assume that the initial aggregated public key of participants (at genesis) ğ‘ğ‘˜0 as well as their tweaked key ğ‘„0 are trusted and known by everyone and that
it was funded as specified in Section 4.2 such that there are enough bitcoins to pay for the transaction fees of several transactions. For each round ğ‘– > 0:

1 The protocol starts after a threshold of new registrations and unregistrations has been monitored (e.g., since the last configuration, ğ‘–, there has
been ğ‘¢ new registrations or unregistrations). We call this event ğ‘ˆğ‘–+1. We note ğ‘‹ğ‘–+1 the height, in the PoS blockchain, corresponding to this event.
As soon as the parties notice event ğ‘ˆğ‘–+1, they start the distributed key generation algorithm defined in Figure 5. This algorithm is performed by
members of the new configuration, ğ¶ğ‘–+1 in order to compute the new aggregated key ğ‘ğ‘˜ğ‘–+1. We denote ğ‘†ğ‘–+1,0 the set of members in the new
reconfiguration (i.e., reconfiguration ğ‘–). (Every member knows who is part of the new configuration by property of the underlying PoS, using
the power table). At the end of the algorithm, the aggregated public key ğ‘ğ‘˜ğ‘–+1 is known by everyone and a message can be signed by ğ‘¡ğ‘–+1 out
(ğ‘¡ğ‘–+1,ğ‘›ğ‘–+1 )
of ğ‘›ğ‘–+1 of the participants using their secret share ğ‘ ğ‘–+1,ğ‘— : (ğ‘ ğ‘–+1,1, Â· Â· Â· , ğ‘ ğ‘–+1,ğ‘›)
â†âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ (ğ‘ ğ‘˜ğ‘–+1, ğ‘ğ‘˜ğ‘–+1, ğ‘ğ‘–+1ğ‘˜ğº, ğ‘†ğ‘–+1,1), ğ‘˜ âˆˆ {1, Â· Â· Â· , ğ‘¡ğ‘–+1 âˆ’ 1}. Here
ğ‘†ğ‘–+1,1 = ğ‘†ğ‘–+1,0 \ {misbehaving participants from the protocol}.
We assume that the DKG is finished by block ğ‘‹ğ‘–+1 + ğ‘Œ where ğ‘Œ is chosen conservatively. The tweaked public key of the taproot address is then defined
to be ğ‘„ğ‘–+1 = ğ‘ğ‘˜ğ‘–+1 + ğ»ğ‘‡ ğ‘ğ‘ğ‘‡ ğ‘¤ğ‘’ğ‘ğ‘˜ (ğ‘ğ‘˜ğ‘–+1 | |ckpt)ğº, where ckpt is the hash of the PoS block at height ğ‘‹ğ‘–+1.

2 Optional: Remove the misbehaving party from the power table.
3 Signing protocol. Every participant ğ‘ƒ ğ‘— of configuration ğ¶ğ‘– does the following:
(a) ğ‘ƒ ğ‘— checks that the previous reconfiguration transaction txğ‘–âˆ’1 (according to the PoS blockchain) is included in the bitcoin blockchain. If not, they

submit it before forming the new transaction.

(b) ğ‘ƒ ğ‘— first publishes the list of members in the new configuration ğ¶ğ‘–+1 to the decentralized storage and retrieves the corresponding content identifiers

ğ‘ğ‘–ğ‘‘ğ‘–+1.

(c) ğ‘ƒ ğ‘— computes transaction txğ‘– as follows. All of the coins associated with ğ‘„ğ‘– are transferred to ğ‘„ğ‘–+1 and another output that receives no coins but
contains an ğ‘‚ğ‘ƒ _ğ‘…ğ¸ğ‘‡ğ‘ˆ ğ‘…ğ‘ that contains ğ‘ğ‘–ğ‘‘ğ‘–+1 is added: txğ‘– : ğ‘„ğ‘– â†’ ( (amt, ğ‘„ğ‘–+1), (0, ğ‘‚ğ‘ƒ _ğ‘…ğ¸ğ‘‡ğ‘ˆ ğ‘…ğ‘ = ğ‘ğ‘–ğ‘‘ğ‘–+1)) where amount is the amount
associated with ğ‘„ğ‘– minus transaction fees.

(d) The members of the current configuration ğ¶ğ‘– (i.e. associated with ğ‘ğ‘˜ğ‘– ) perform the interactive signing algorithm.

(i) Set ğ‘š â† 0.
(ii) (ğ‘œ, ğ‘†ğ‘–,ğ‘š+1) â† SchnorrThresholdSign(ğ‘†ğ‘–,ğ‘š, txğ‘–, ğ‘ğ‘˜ğ‘–, ğ‘„ğ‘– ) defined in Figure 6 where ğ‘†ğ‘–,ğ‘š+1 is the set of non-misbehaving parties during the

execution of the protocol.

(iii) If ğ‘œ = (ğ‘§, ğ‘…), i.e., a signature has been successfully produced, continue to step 4.
(iv) Else (i.e., ğ‘œ = abort) set ğ‘š = ğ‘š + 1 and go to step 3(d)ii.

4 The taproot signature is then computed as (ğ‘§â€², ğ‘…) â† (ğ‘§ + ğ» (txğ‘– | |ğ‘… | |ğ‘„ğ‘– )ğ» (ğ‘ğ‘˜ğ‘– | |ckpt), ğ‘…), where ğ‘ is the hash of the PoS blockchain at height ğ‘‹ğ‘– .
5 ğ‘ƒ ğ‘— sends txğ‘– to the Bitcoin blockchain to update the configuration.
6 Participants set ğ‘– â† ğ‘– + 1 and go back to step 1.

Each participant ğ‘ƒğ‘– performs the following steps, where ğ‘¡ is a parameter and ğ‘› is the total number of participants:

Figure 4: Main Algorithm

(1) Choose ğ‘Ÿğ‘–

$
â†âˆ’ Zâˆ—
privately to ğ‘ƒ ğ‘— .

ğ‘. Let the sharing polynomial be ğ‘“ğ‘– (ğ‘¢) = (cid:205)ğ‘¡ âˆ’1
ğ‘˜=0

ğ‘ğ‘–ğ‘˜ğ‘¢ğ‘˜ where ğ‘ğ‘–0 = ğ‘Ÿğ‘– . Compute ğ‘  ğ‘—

ğ‘– = ğ‘“ğ‘– ( ğ‘—) mod ğ‘ for each ğ‘— âˆˆ {1, . . . ğ‘› } and send ğ‘  ğ‘—

ğ‘–

(2) Expose ğ‘Œğ‘– = ğ‘Ÿğ‘–ğº as follows. Broadcast ğ´ğ‘–ğ‘˜ = ğ‘ğ‘–ğ‘˜ğº for ğ‘˜ âˆˆ {0, Â· Â· Â· , ğ‘¡ âˆ’ 1}.
(3) Verify the values broadcast by other players: ğ‘“ğ‘— (ğ‘–)ğº ?= (cid:205)ğ‘¡ âˆ’1
ğ‘˜=0
(4) Answer each complaint from party ğ‘ƒ ğ‘— against ğ‘ƒğ‘– (if any) by broadcasting ğ‘  ğ‘—
ğ‘– .
(5) If any of the revealed shares fails this equation, remove that participant from the set of players ğ»0.
ğ‘Ÿ ğ‘—ğº, of which each playerâ€™s share of the secret is ğ‘ ğ‘– = (cid:205)ğ‘— âˆˆğ‘†0
(6) Extract ğ‘Œ = (cid:205)ğ‘— âˆˆğ‘†0

ğ‘ ğ‘–
ğ‘— . The secret ğ‘Ÿ = (cid:205)ğ‘— âˆˆğ‘†0

ğ‘–ğ‘˜ğ´ğ‘—ğ‘˜ . If the check fails for an index ğ‘—, complain against ğ‘ƒ ğ‘— .

ğ‘Ÿ ğ‘— mod ğ‘ is never computed.

The corresponding aggregated private and public keys are (ğ‘Ÿ, ğ‘Œ ), denoted by

(ğ‘ 1, Â· Â· Â· , ğ‘ ğ‘›)

(ğ‘¡,ğ‘›)
â†âˆ’âˆ’âˆ’â†’ (ğ‘Ÿ, ğ‘Œ , ğ‘ğ‘˜ğº, ğ‘†0), ğ‘˜ âˆˆ {1, Â· Â· Â· , ğ‘¡ âˆ’ 1}

Figure 5: Distributed Key Generation Algorithm (JF-DKG by Gennaro et al. [17])

(a) Inspect the transactions going out from ğ‘„0
(b) If there are multiple transactions going out from ğ‘„0, look
for the initial funding transaction by inspecting the UTXOs
spent and verifying that all of them are included in blocks
with height lower than â„0.

(c) Once the initial transaction tx0 has been found, look for
the transaction that spent tx0 (i.e. where tx0 is an input).
(d) For ğ‘– â‰¥ 0 get txğ‘–+1 by looking for the transaction that

spent txğ‘– .

(e) Stop when txğ‘– is unspent and get ğ‘ğ‘–ğ‘‘ğ‘– from the ğ‘‚ğ‘ƒ_ğ‘…ğ¸ğ‘‡ğ‘ˆ ğ‘…ğ‘

field.

(3) Use ğ‘ğ‘–ğ‘‘ğ‘– to get the list of current nodes from the external

storage chosen.

(4) Request the PoS blockchain state from these nodes.
(5) Verify that the aggregated public key on the PoS blockchain
ğ‘ğ‘˜ and the hash of the block ckpt are in accordance with the
Bitcoin Taproot address ğ‘„ that is the output of txğ‘– .

ConsensusDay â€™22, November 7, 2022, Los Angeles, CA, USA

Sarah Azouvi and Marko VukoliÄ‡

(6) If the checkpoint and aggregated key do not match the Bit-
coin checkpoint, roll back the PoS chain until the previous
checkpoint and go back to step 5.

5 SECURITY ARGUMENT
In this section we present the arguments for why our protocol is
secure. We need to prove two things: (1) that any checkpoint pushed
onto the Bitcoin blockchain is correct, i.e., that it corresponds to
the valid state of the PoS (according to honest online validators);
(2) that checkpoints will be pushed regularly. These two properties
correspond, loosely, to the safety and liveness properties of our
scheme.

5.1 Safety
We consider the following statement, which we prove by induction,
for ğ‘˜ âˆˆ N: An adversary as defined in Section 3 cannot create any
incorrect checkpointing transaction txğ´
for any 0 â‰¤ ğ‘– â‰¤ ğ‘˜ such that
ğ‘–
txğ´
ğ‘– will be accepted by an honest verifier that follows the verification
algorithm as defined in Section 4.3. An incorrect checkpoint trans-
action is a transaction that contains a commitment to an incorrect
chain (i.e., a chain created as part of a LRA).

Base Case. First, we show that the adversary cannot create an
alternative initial transaction tx0. At the time where the initial
transaction is created, the adversary controls at most ğ‘¡0 participants
(assumption 2) and hence, by security of the DKG and signing
algorithms, cannot unilaterally sign a transaction coming from ğ‘„0.
After ğ¿ configurations, the adversary do obtain all the keys from
ğ¶0 and is able to create transaction coming out from this address,
however, this happens after height â„0 on the Bitcoin blockchain by
assumption 3 and hence any transaction sent by the adversary from
ğ‘„0 will not be accepted by any verifier according to our verification
algorithm presented in Section 4.3 step 2b. Hence the adversary
cannot create an initial checkpoint transaction that will be accepted
by any verifier.

, . . . , txğ´

Induction step. Letâ€™s assume that our statement is true for ğ‘˜ âˆ’ 1,
i.e., the adversary cannot create any incorrect checkpointing trans-
action up to ğ‘˜ âˆ’ 1 (i.e., txğ´
ğ‘˜âˆ’1). We show that our statement
0
is then also true for ğ‘˜. It is enough to show that the adversary
cannot create any incorrect checkpointing transaction txğ´
ğ‘˜ . Letâ€™s
denote ğ‘– the current configuration number (i.e., according to online
validators). There are two cases to consider. The first case is the case
where ğ‘˜ < ğ‘– âˆ’ğ¿. Then by assumptions the adversary has all the keys
associated with ğ‘„ğ‘˜ (assumption 1) and a transaction txğ‘˜ that spent
txğ‘˜âˆ’1 has already been included in the blockchain (assumption 3).
Because txğ‘˜âˆ’1 has already been spent, txğ´
ğ‘˜ cannot include txğ‘˜âˆ’1 in
its inputs (as an input can only be spent once according to Bitcoinâ€™s
rules). Moreover by induction assumption there is no other transac-
tion txğ´
ğ‘˜ that the adversary could
create that would be accepted by any verifier. Hence, according to
our verification algorithm step 2d txğ´
ğ‘˜ will not be accepted by any
verifier.

ğ‘˜âˆ’1 to be included as an input to txğ´

The second case is the case where ğ‘˜ â‰¥ ğ‘– âˆ’ ğ¿. In this scenario, it
could be the case that transaction txğ‘˜âˆ’1 is still unspent. By design
the only spendable outputs of txğ‘˜âˆ’1 is ğ‘„ğ‘˜ . However, according to
assumption 2, the adversary only holds a fraction ğ‘“ of configuration

ğ‘˜ and hence cannot create a transaction that is spent by ğ‘„ğ‘˜ and
cannot spent transaction txğ‘˜âˆ’1.

5.2 Liveness
The reasons why an adversary cannot stop the signing from going
ahead and the checkpoints from happening are as follows. (1) The
robustness of the DKG ensures that an adversary cannot stop the
rest of the players from computing an aggregated public key. (2)
The adversary could delay the signing process by aborting; how-
ever, aborting or misbehaving players will be detected and excluded
from the signing in the next iteration. (3) The assumption about
the stability across configurations ensures that enough honest par-
ticipants will be able to perform the signing, i.e., we assume that
enough participants from each configuration will remain available
in the system long enough to sign and give the signer power to the
next configuration.

6 IMPLEMENTATION AND EVALUATION
We implement the protocol from Section 4 using the Go Program-
ming Language. For the underlying PoS chain, we forked the open-
source Eudico framework,3 developed by Protocol Labs, that pro-
vides a delegated Proof-of-stake consensus protocol option. We
used a simplified version of this, where only one PoS miners creates
blocks, as this does not impact our experiments. We used an open-
source library developed by the Taurus group4 for the DKG and
signing, that we adapted for our needs and used both Bitcoin regtest
and testnet for our experiments. For storing the data associated
with each configuration, we implemented a key-value database,
maintained by the PoS validators on top of the PoS chain.

The code is open source.5 We run the experiments on a single
virtual machine (32 GB RAM, 8 vCPUs, 640 GB SSD) on Amazon
Lightsail using a Kubernetes deployment.

We implemented the verification process, however we did not
include any metrics in this paper as this was tested only on the
Bitcoin Testnet and may not be representative of the mainnet.

We measure the execution times of the DKG and the signing
protocol in Figure 8. We only included the case where everyone
cooperates in our graphs as in the case of failures our protocol
relies on a timeout (to detect aborts) hence the execution time
of the protocol with failures is constant and only depends on the
timeout chosen. We included the graphs of the execution time in the
event of failures in the Appendix for reference.While the number
of validators in a PoS protocol varies depending on a particular
blockchain system, we show results with up to 21 validators, which
corresponds to the number of validators in a delegated PoS such
as EOSIO [23], where 21 validators are elected on a rotating basis
to run the consensus protocol. In Figure 8, we plot the confidence
interval of the execution time of the DKG and signing protocol
sampled over all the participating nodes and repeated a dozen
times.

We notice in our graph that the signing scales better than the
DKG as it increases from less than 0.1 second with 3 participants
to around 0.6 second with 21 participants whereas the DKG goes

3https://github.com/filecoin-project/eudico
4https://github.com/taurusgroup/multi-party-sig
5https://github.com/filecoin-project/eudico/tree/B2-bitcoin-checkpointing

Pikachu: Securing PoS Blockchains from Long-Range Attacks by Checkpointing into Bitcoin PoW using Taproot

ConsensusDay â€™22, November 7, 2022, Los Angeles, CA, USA

SchnorrThresholdSign(ğ», ğ‘š, ğ‘Œ , ğ‘„)
Input: ğ» is the set of players, ğ‘š the message.
Y is the aggregated public key. Each participant ğ‘ƒğ‘– holds a share of the associated secret key ğ‘ ğ‘– . ğ‘Œğ‘– is the public verification share of each participant and is
computed as ğ‘Œğ‘– = (cid:205)ğ‘— âˆˆğ‘†0
Parameter: timeOut.
PreProcess: Each participant ğ‘ƒğ‘– performs the following steps. ğœ‹ is a parameter corresponding to the number of signing operations that can be performed
before doing another pre-process step.

ğ‘–ğ‘˜ğ´ğ‘—ğ‘˜ We note ğ‘„ the tweaked key as defined in step 1 of Figure 4.

(cid:205)ğ‘¡ âˆ’1
ğ‘˜=0

(1) Create an empty list ğ¿ğ‘– . For 1 â‰¤ ğ‘— â‰¤ ğœ‹ do:
(a) Sample single-use nonces (ğ‘‘ğ‘– ğ‘— , ğ‘’ğ‘– ğ‘— )
(b) Derive commitment shares (ğ·ğ‘– ğ‘— , ğ¸ğ‘– ğ‘— ) = (ğ‘‘ğ‘– ğ‘—ğº, ğ‘’ğ‘– ğ‘—ğº).
(c) Append (ğ·ğ‘– ğ‘— , ğ¸ğ‘– ğ‘— ) to ğ¿ğ‘– . Store ( (ğ‘‘ğ‘– ğ‘— , ğ·ğ‘– ğ‘— ), (ğ‘’ğ‘– ğ‘— , ğ¸ğ‘– ğ‘— )) for later use in signing operations.

ğ‘ Ã— Zâˆ—
ğ‘.

$
â†âˆ’ Zâˆ—

(2) Publish (ğ‘–, ğ¿ğ‘– ) to the PoS blockchain.

Sign(ğ‘š)
Each participant ğ‘ƒğ‘– does the following:

(1) Compute S, the set of ğ‘¡ participants for signing using RBğ‘– as follows:

(a) Compute ğ» (ğ‘–ğ‘‘ | |RB).
(b) The smallest ğ‘¡ hashes are the id selected for signing.

(2) Fetch the next available commitment for each participant ğ‘ƒğ‘– âˆˆ ğ‘† from ğ¿ğ‘– and construct ğµ = âŸ¨(ğ‘–, ğ·ğ‘–, ğ¸ğ‘– ) âŸ©ğ‘–âˆˆğ‘† .
(3) Compute the set of binding values ğœŒğ‘™ = ğ»1 (ğ‘™, ğ‘š, ğµ), ğ‘™ âˆˆ ğ‘† and derives the group commitment ğ‘… = (cid:205)ğ‘™ âˆˆğ‘† (ğ·ğ‘™ +ğœŒğ‘™ ğ¸ğ‘™ ) and the challenge ğ‘ = ğ»2 (ğ‘š | |ğ‘… | |ğ‘„).
(4) Each ğ‘ƒğ‘– âˆˆ ğ‘† computes their response using their secret share ğ‘ ğ‘– by computing ğ‘§ğ‘– = ğ‘‘ğ‘– + (ğ‘’ğ‘– Â· ğœŒğ‘– ) + ğœ†ğ‘– Â· ğ‘ ğ‘– Â· ğ‘ using ğ‘† to determine the ğ‘–ğ‘¡â„ Lagrange

coefficient ğœ†ğ‘– as follows: if ğ‘† = {ğ‘ƒğ‘–1 Â· Â· Â· , ğ‘ƒğ‘–ğ‘¡ } represents the participants identifiers then ğœ†ğ‘– = (cid:206)ğ‘— âˆˆ{ğ‘–1,...,ğ‘–ğ‘¡ },ğ‘— â‰ ğ‘–

(5) Each ğ‘ƒğ‘– securely deletes (ğ‘‘ğ‘–, ğ‘’ğ‘– ) from their local storage and then post ğ‘§ğ‘– to the PoS chain.
(6) After all the shares from participants in S are included in the PoS chain, each participant performs the following steps:

ğ‘ƒ ğ‘—
ğ‘ƒ ğ‘— âˆ’ğ‘ƒğ‘– .

(a) Derive ğ‘… = (cid:205)ğ‘–âˆˆğ‘† ğ‘…ğ‘– and ğ‘ = ğ»2 (ğ‘š | |ğ‘… | |ğ‘„).
(b) Verify that ğ‘§ğ‘–ğº ?= ğ‘…ğ‘– + (ğ‘ Â· ğœ†ğ‘– ) Â· ğ‘Œğ‘– for each signing share ğ‘§ğ‘–, ğ‘– âˆˆ ğ‘†.

If it fails, report the misbehaving participant(s) by publishing a message on the PoS blockchain with the proof of misbehaviour(s) (i.e., ğ‘§ğ‘–ğº and
ğ‘…ğ‘– + (ğ‘ Â· ğœ†ğ‘– )ğ‘Œğ‘– for each cheating player) and abort.
(c) If no participants was misbehaving, compute ğ‘§ = (cid:205)ğ‘–âˆˆğ‘† ğ‘§ğ‘– .
(d) Compute ğœ = (ğ‘§, ğ‘…) to the PoS blockchain.

(7) If after timeOut blocks since the begining of the protocol, some shares have not been posted to the PoS chain, abort the protocol and add the

corresponding participants in the list of misbehaving players.

Output: (ğœ, ğ» ) if the protocol completed, (abort, ğ‘†â€²) else, where ğ‘†â€² is the set of players who have not misbehaved during the execution of the protocol.

Figure 6: Signing Algorithm

up to above 2.5 seconds with 21 participants. This is expected as
the signing only requires 2 broadcast messages per participants
(the pre-process and the share of the signature) whereas the DKG
requires private messages between every participants as well as
broadcast messages.

7 RELATED WORK
LRA have long been studied in the field of PoS and other types of
checkpointing have been proposed that either rely on some sort
of central authority [20] or on additional assumptions [1]. Like
the solution from Steinhoff et al. [30], this paper offers a fully
decentralized solution without additional security assumptions (as
in [1]) other than the ones needed for the security of the underlying
PoS.

Kuznetsov and Tolkih propose an alternative solution to address-
ing long-range attacks in BFT/PoS [22], using forward-secure digital
signatures. However, this solution is inapplicable in the rational ad-
versary model, in which rational nodes might simply not follow the
assumptions of forward-secure digital signatures, retaining their
old private keys to mount attacks in the future.

Babylon [32] was proposed concurrently to our work and is a
defense against LRA that is also based on leveraging the security

guarantees provided from Bitcoinâ€™s Proof-of-work. In this work,
every PoS miner can post a checkpointing transaction into the Bit-
coin blockchain which then acts as a timestamping mechanism and
thus thwarts LRA. Whenever a block is mined on the PoS chain,
PoS validators can submit a commitment for this block, and this
commitment is included in the Bitcoin PoW chain. In the case of
two conflicting blocks in the PoS chain, the one whose commitment
was submitted first in the Bitcoin chain is chosen by the fork-choice
rule. Babylon goes further and also protects the underlying PoS
chain against super-majority and censorship attacks. Their scheme
is more scalable than Pikachu, as it does not require any additional
threshold signing. On the other hand, since the checkpointing trans-
actions on the Bitcoin blockchain are not linked together, as is the
case in Pikachu, the verification algorithm is much less efficient
as one would need to search exhaustively through all the Bitcoin
transactions to find all the possible PoS checkpoints and ensure
that they have the correct PoS chain.

Lastly, on the topic of Stake-based Threshold Multisignatures,
Mithril [8] and Dfinity [19] both propose scalable and efficient
schemes that are however not compatible with Bitcoin and could
thus not be used in the context of checkpointing onto Bitcoin.

ConsensusDay â€™22, November 7, 2022, Los Angeles, CA, USA

Sarah Azouvi and Marko VukoliÄ‡

Algorithm 1 Main algorithm

import PoS
import PoS.PowerTable as PT
import BTC
import PrivateMessage as PM
import IPFS
import Signing Algorithm (Algorithm 3), Distributed Key Generation Algorithm (Algorithm 2)

Init:

if ğ‘Ÿğ‘’ğ‘ = âŸ¨ğ‘, â€œğ‘—ğ‘œğ‘–ğ‘›â€âŸ© then

ğ¶ğ‘ğ‘¢ğ‘Ÿ â† ğ¶0
ğ¶ğ‘™ğ‘ğ‘ ğ‘¡ â† ğ¶0
ğ‘ğ‘˜ğ‘ğ‘¢ğ‘Ÿ â† ğ‘ğ‘˜0
CurrentShares â† empty dictionary
ğ‘†0 â† ğ¶ğ‘ğ‘¢ğ‘Ÿ
misbehavingPlayers â† âˆ…
ğ‘– â† ğ¶ğ‘ğ‘¢ğ‘Ÿ .ğ‘šğ‘’ğ‘šğ‘ğ‘’ğ‘Ÿğ‘  [ğ‘–ğ‘‘ ].ğ‘”ğ‘’ğ‘¡ğ¼ğ‘›ğ‘‘ğ‘’ğ‘¥ ()
txğ‘™ğ‘ğ‘ ğ‘¡ â† tx0

1:
2:
3:
4:
5:
6:
7: Parameters:
ğ‘–ğ‘‘
8:
ğ‘¢
9:
10:
f
ğ‘Œ
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21: upon event receiving ğ‘ƒğ‘‡ .update(ğ‘Ÿğ‘’ğ‘) âˆ§ ğ¶ğ‘™ğ‘ğ‘ ğ‘¡ â–³ğ¶ğ‘ğ‘¢ğ‘Ÿ < ğ‘¢ do
22:
23:
24:
25:
26: upon event ğ¶ğ‘™ğ‘ğ‘ ğ‘¡ â–³ğ¶ğ‘ğ‘¢ğ‘Ÿ â‰¥ ğ‘¢
27:
28:
29: upon event PoS.CurrentHeight == PoS.Height(X)+Y do
30:
31:
32:
33:
34:
35:
36:
37:
38:
39:
40:
41:
42:
43:
44:

ğ‘†0 â† ğ¶ğ‘ğ‘¢ğ‘Ÿ .ğ‘”ğ‘’ğ‘¡ğ¼ğ‘›ğ‘‘ğ‘’ğ‘¥ğ‘’ğ‘  ()\misbehavingPlayers
ğ‘ğ‘˜ğ‘›ğ‘’ğ‘¤ â† (cid:205)ğ‘— âˆˆğ‘†0
ğ‘ ğ‘–
ğ‘ ğ‘– â† (cid:205)ğ‘— âˆˆğ‘†0
ğ‘—
ckpt â† ğ‘ƒğ‘œğ‘†.ğµğ‘™ğ‘œğ‘ğ‘˜â„ğ‘ğ‘ â„ (ğ‘‹ )
ğ‘ â† ğ‘ğ‘˜ğ‘›ğ‘’ğ‘¤ + ğ»ğ‘‡ ğ‘ğ‘ğ‘‡ ğ‘¤ğ‘’ğ‘ğ‘˜ (ğ‘ğ‘˜ğ‘›ğ‘’ğ‘¤ | |ckpt)ğº
ğ‘œ â† 0
if BTC.latestCheckpoint.UTXO â‰  txğ‘™ğ‘ğ‘ ğ‘¡ then

IPFS.push(ğ¶ğ‘ğ‘¢ğ‘Ÿ )
ğ‘ğ‘–ğ‘‘ â† ğ¼ ğ‘ƒ ğ¹ğ‘†.ğ‘”ğ‘’ğ‘¡ğ¶ğ‘–ğ‘‘ (ğ¶ğ‘ğ‘¢ğ‘Ÿ )
if ğ‘–ğ‘‘ âˆˆ ğ¶ğ‘™ğ‘ğ‘ ğ‘¡ then
do Algorithm 3
ğ¶ğ‘™ğ‘ğ‘ ğ‘¡ â† ğ¶ğ‘ğ‘¢ğ‘Ÿ
ğ‘ğ‘˜ğ‘ğ‘¢ğ‘Ÿ â† ğ‘
CurrentShares â† âˆ…

ğ‘‹ â† PoS.CurrentBlock()
Do Algorithm 2 (DKG)

ğ¶ğ‘ğ‘¢ğ‘Ÿ .ğ‘šğ‘’ğ‘šğ‘ğ‘’ğ‘Ÿğ‘  â† ğ¶ğ‘ğ‘¢ğ‘Ÿ .ğ‘šğ‘’ğ‘šğ‘ğ‘’ğ‘Ÿğ‘  âˆª {ğ‘ }

ğ¶ğ‘ğ‘¢ğ‘Ÿ .ğ‘šğ‘’ğ‘šğ‘ğ‘’ğ‘Ÿğ‘  â† ğ¶ğ‘ğ‘¢ğ‘Ÿ .ğ‘šğ‘’ğ‘šğ‘ğ‘’ğ‘Ÿğ‘  \ {ğ‘ }

if ğ‘Ÿğ‘’ğ‘ = âŸ¨ğ‘, â€œğ‘™ğ‘’ğ‘ğ‘£ğ‘’â€âŸ© then

BTC.Broadcast(txğ‘™ğ‘ğ‘ ğ‘¡ )

CurrentShares[ ğ‘— ]

âŠ² The node id
âŠ² Tolerated difference between local configuration and current configuration
âŠ² Fault tolerance of the current configuration
âŠ² Number of blocks to wait for the DKG to complete

âŠ² Current configuration
âŠ² Last configuration
âŠ² Initial public key
âŠ² Share of the aggregated public key
âŠ² Non-misbehaving participants
âŠ² Set of misbehaving participants in the DKG
âŠ² Nodeâ€™s index
âŠ² Initial transaction as defined in Section 4.2
âŠ² Configuration request received

âŠ² After ğ‘¢ (un)registrations do

âŠ² Give enough time for the DKG to complete
âŠ² set of indexes of non-cheating players in the DKG
âŠ² Compute the aggregated key
âŠ² Compute the share of the secret key

âŠ² Taproot address
âŠ² Counter for the pre-process step
âŠ² Check the Bitcoin blockchain for the previous checkpointing transaction
âŠ² Send latest checkpoint

âŠ² Members associated with ğ‘ğ‘˜ğ‘ğ‘¢ğ‘Ÿ sign tx
âŠ² Signing protocol with other members

(a) DKG with every participants honest.

(b) Signing with every participants honest.

Figure 7: Execution time of our DKG and Signing Implementation. Each vertical bar represent the confidence interval of the
execution time as seen by each different node.

3579111315171921Number of participants0.00.51.01.52.02.5Seconds3579111315171921Number of participants0.10.20.30.40.50.6SecondsPikachu: Securing PoS Blockchains from Long-Range Attacks by Checkpointing into Bitcoin PoW using Taproot

ConsensusDay â€™22, November 7, 2022, Los Angeles, CA, USA

Algorithm 2 Distributed Key Generation

import MainAlgorithm

1:
2: Parameters:
3:
4:
5:

ğ‘¡ â† 0.5|ğ¶ğ‘ğ‘¢ğ‘Ÿ | + 1

if ğ‘–ğ‘‘ âˆˆ ğ¶ğ‘ğ‘¢ğ‘Ÿ then
Timeout.Start()
$
â†âˆ’ Zğ‘ ; ğ‘ğ‘–0 â† ğ‘Ÿğ‘–
ğ‘Ÿğ‘–
for ğ‘˜ âˆˆ {1, . . . , ğ‘¡ âˆ’ 1} do

6:
7:

ğ‘ğ‘–ğ‘˜

Timeout.Restart()

if ( âŸ¨SHARE, ğ‘ ğ‘–

ğ‘— âŸ©) ğ‘— == nil then

if idâˆˆ ğ¶ğ‘ğ‘¢ğ‘Ÿ then

PM( âŸ¨SHARE, ğ‘  ğ‘—

ğ‘— âŸ©ğ‘— received for all ğ‘— do

misbehavingPlayers.append( ğ‘—)

for ğ‘— âˆˆ {1, . . . , |ğ¶ğ‘ğ‘¢ğ‘Ÿ .ğ‘šğ‘’ğ‘šğ‘ğ‘’ğ‘Ÿğ‘  | } do

ğ‘– = ğ‘“ğ‘– ( ğ‘—) âŸ©, ğ¶ğ‘ğ‘¢ğ‘Ÿ .ğ‘šğ‘’ğ‘šğ‘ğ‘’ğ‘Ÿğ‘ .ğ‘–ğ‘›ğ‘‘ğ‘’ğ‘¥ [ ğ‘— ])

if ğ‘— âˆˆ {1, . . . , |ğ¶ğ‘ğ‘¢ğ‘Ÿ .ğ‘šğ‘’ğ‘šğ‘ğ‘’ğ‘Ÿğ‘  | } and ğ‘  ğ‘—

$
â†âˆ’ Zğ‘
ğ‘“ğ‘– (ğ‘¢) â† (cid:205)ğ‘¡ âˆ’1
ğ‘ğ‘–ğ‘˜ğ‘¢ğ‘˜
ğ‘˜=0
for ğ‘— âˆˆ {1, . . . , |ğ¶ğ‘ğ‘¢ğ‘Ÿ .ğ‘šğ‘’ğ‘šğ‘ğ‘’ğ‘Ÿğ‘  | } do

for ğ‘˜ âˆˆ {0, . . . , ğ‘¡ âˆ’ 1} do ğ´ğ‘–ğ‘˜ â† ğ‘ğ‘–ğ‘˜ğº
PoS.Broadcast( âŸ¨secretCommitments, ğ´ğ‘–0, . . . , ğ´ğ‘– (ğ‘¡ âˆ’1) âŸ©ğ‘– )

8:
9:
10:
11:
12:
13:
14:
15: upon event âŸ¨SHARE, ğ‘ ğ‘–
16:
Timeout.Restart()
17: upon event TimeOut.Done() do
18:
19:
20:
21:
22: upon event PoS.Receive(âŸ¨secretCommitments, ğ´ğ‘— 0, . . . , ğ´ğ‘— (ğ‘¡ âˆ’1) âŸ©ğ‘— ) do
23:
24:
25:
26:
27: upon event PoS.Receive(âŸ¨secretCommitments, ğ´ğ‘— 0, . . . , ğ´ğ‘— (ğ‘¡ âˆ’1) âŸ©ğ‘— ) for all ğ‘— or Timeout.Done() do
28:
29:
30:
31:
32:
33:
34:
35:
36: upon event PoS.Receive(âŸ¨complaintSecret,v âŸ©ğ‘˜ ) do
for ğ‘— âˆˆ {1, . . . , |ğ¶ğ‘ğ‘¢ğ‘Ÿ .ğ‘šğ‘’ğ‘šğ‘ğ‘’ğ‘Ÿğ‘  | do
37:
38:
39:
40: upon event PoS.Receive( âŸ¨complaintAnswer, proof, ğ‘— âŸ©ğ‘™ ) do
41:
42:

if ğ‘— âˆˆ misbehavingPlayers then v.append(ğ‘“ğ‘— (ğ‘–))
else v.append(NoComplaint)
PoS.Broadcast( âŸ¨complaintSecret, vâŸ©)
Timeout.Restart()

if v[j]â‰  NoComplaint then misbehavingPlayers.append( ğ‘—)
if v[i]â‰  NoComplaint then PoS.Broadcast( âŸ¨complaintAnswer, ğ‘ ğ‘–

v = âˆ…
for ğ‘— âˆˆ {1, . . . , |ğ¶ğ‘ğ‘¢ğ‘Ÿ .ğ‘šğ‘’ğ‘šğ‘ğ‘’ğ‘Ÿğ‘  | do

if PoS.Read( âŸ¨secretCommitmentsâŸ©) ğ‘— == nil then

â† ğ‘ƒğ‘œğ‘†.ğ‘…ğ‘’ğ‘ğ‘‘ ( âŸ¨SecretCommitmentsâŸ©ğ‘— )

CurrentShares.append(ğ‘—, ğ´ğ‘— 0)

misbehavingPlayers.append( ğ‘—)

misbehavingPlayers.append(ğ‘— )

ğ‘– â‰  (cid:205)ğ‘¡ âˆ’1
ğ‘˜=0

ğ‘–ğ‘˜ ğ´ğ‘—ğ‘˜ then

ğ‘— , ğ‘– âŸ©)

else

ğ‘  ğ‘—
ğ‘™ â†Parse(proof)
(ğ´ğ‘—ğ‘˜ )ğ‘¡ âˆ’1
ğ‘˜=0
if ğ‘  ğ‘—
ğº == (cid:205)ğ‘¡ âˆ’1
ğ‘˜=0
ğ‘™
misbehavingPlayers.remove( ğ‘—)

ğ‘™ğ‘˜ ğ´ğ‘—ğ‘˜ then

43:
44:
45: upon event PoS.Receive( âŸ¨complaintSecretâŸ©ğ‘— ) for all ğ‘—âˆ§ misbehavingPlayers == âˆ… do
46:
47: upon event Timeout.Done() do
48:

return

return

âŠ² Number of parties controlled by the adversary
âŠ² Only member of the new configuration perform the DKG
âŠ² We use a timeout to detect aborting players (this can be in terms of blocks in the PoS chain)

âŠ² Send share of secret to each player

âŠ² All secret shares were received

âŠ² Some party did not send their private share
âŠ² Add aborting players to list of misbehaving participants

âŠ² All commitments were received or timeout expired

âŠ² Add aborting players to list of misbehaving participants

âŠ² Send a list of (potentially empty) complaints

âŠ² Receive other partiesâ€™ list of complaints
âŠ² Add complaints against ğ‘—
âŠ² Reply to complaint against self
âŠ² ğ‘— can answer a complaint from ğ‘™

âŠ² Get ğ‘— commitments

âŠ² All complaints (and potentially answers) were received
âŠ² Finish the protocol
âŠ² Leave enough time for answers to be received

8 CONCLUSION
We presented a checkpointing mechanism designed to secure PoS
blockchains by leveraging the security guarantees provided by Bit-
coinâ€™s PoW. Our protocol uses Taproot, allowing for the checkpoints
to be constant in the size of PoS validators and indistinguishable
from any other Taprootâ€™s transaction. We implemented a PoC for
our protocol and measured its efficiency. The main issue of our
approach is that it does not scale well. This is especially true if we
consider a flat model where each unit of power corresponds to a
different public key; we could easily end up dealing with tens of
thousands of keys, even when the number of actual participants
is much smaller, greatly increasing the latency of the protocol. Al-
though some techniques such as sampling [8] or ad-hoc threshold
multi-signature schemes [15] have been proposed to help scale
weighted threshold signature schemes, those techniques are not
currently compatible with Bitcoinâ€™s spending rules.

Another problem left for future work is that of fully incentivis-
ing the participation in the protocol, which we started doing in
Section 4.2.

ACKNOWLEDGMENTS
The authors would like to thank Nicolas Gailly and Rosario Gennaro
for very useful discussions about this paper.

REFERENCES
[1] S. Azouvi, G. Danezis, and V. Nikolaenko. Winkle: Foiling long-range attacks in
proof-of-stake systems. In Proceedings of the 2nd ACM Conference on Advances in
Financial Technologies, pages 189â€“201, 2020.

[2] M. Bell. Proof-of-stake bitcoin sidechains. https://gist.github.com/mappum/

da11e37f4e90891642a52621594d03f6, June 2021.

[3] Bitcoin. Bips/bip-0341.mediawiki at master Â· bitcoin/bips, Jul 2021.
[4] Bitcoin. Bips/bip-0341.mediawiki at master Â· bitcoin/bips, Jul 2021.
[5] Bitcoin Wiki. OP_RETURN. https://en.bitcoin.it/wiki/OP_RETURN, June 2020.
[6] Bitcoin Wiki. Timelock. https://en.bitcoin.it/wiki/Timelock, June 2020.
[7] E. Buchman. Tendermint: Byzantine fault tolerance in the age of blockchains. PhD

thesis, 2016.

ConsensusDay â€™22, November 7, 2022, Los Angeles, CA, USA

Sarah Azouvi and Marko VukoliÄ‡

Algorithm 3 Signing algorithm

ğ‘ Ã— Zâˆ—
ğ‘

if ğ‘–ğ‘‘ âˆˆ ğ‘† then

import MainAlgorithm

ğ‘†â€² â† ğ‘†â€² âˆª (ğ» (ğ‘…ğµ | |ğ‘–.ğ¼ ğ·))

1:
2: Parameters: ğœ‹
3: Timeout.start()
4: ğ¿ğ‘– â† âˆ…
5: ğ‘£ â† PoS.Height(X)
6: ğ‘…ğµ â† ğ‘…ğµğ‘£
7: for ğ‘— âˆˆ {0, . . . , ğœ‹ } do
$
â†âˆ’ Zâˆ—
(ğ‘‘ğ‘– ğ‘— , ğ‘’ğ‘– ğ‘— )
8:
(ğ·ğ‘– ğ‘— , ğ¸ğ‘– ğ‘— ) = (ğ‘‘ğ‘– ğ‘— ğº, ğ‘’ğ‘– ğ‘— ğº)
9:
ğ¿ğ‘– .ğ‘ğ‘ğ‘ğ‘’ğ‘›ğ‘‘ (ğ·ğ‘– ğ‘— , ğ¸ğ‘– ğ‘— )
10:
11: PoS.Broadcast( âŸ¨PreProcess, ğ‘–, ğ¿ğ‘– âŸ©)
12: ğµ â† âˆ…
13: ğ‘†â€² â† âˆ…
14: for ğ‘– âˆˆ ğ¶ğ‘™ğ‘ğ‘ ğ‘¡ do
15:
16: ğ‘†â€² â† ğ‘œğ‘Ÿğ‘‘ğ‘’ğ‘Ÿ (ğ‘†â€²)
17: ğ‘† â† ğ‘†â€² [: ğ‘“ |ğ¶ğ‘™ğ‘ğ‘ ğ‘¡ | + 1]
18: for ğ‘˜ âˆˆ ğ‘† do
19:
20:
21: for ğ‘™ âˆˆ ğ‘† do
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32:
33:
34:
35:
36:
37:
38:
39:
40:
41:
42:
43:
44:
45:
46:
47:
48:
49:
50:
51:
52:
53:
54:
55:
56:
57:
58:
59:
60:
61:
62:
63:
64:
65:

for ğ‘ âˆˆ ğ‘† do

else

else

upon event Timeout.done() do

if CheatingPlayersâ‰  âˆ… then

(ğ·ğ‘˜ğ‘œ , ğ¸ğ‘˜ğ‘œ ) â†PoS.Read( âŸ¨PreProcess, ğ‘˜, ğ¿ğ‘˜ [ğ‘œ ] âŸ©)
ğµ.ğ‘ğ‘ğ‘ğ‘’ğ‘›ğ‘‘ ( (ğ‘˜, ğ·ğ‘˜ğ‘œ , ğ¸ğ‘˜ğ‘œ ))

ğ‘ ğ‘—
ğ‘ ğ‘— âˆ’ğ‘ğ‘– where ğ‘ ğ‘— is the identifier of participant ğ‘—

tx â† ğµğ‘‡ğ¶.ğ‘‡ ğ‘‹ (ğ‘ğ‘˜ğ‘ğ‘¢ğ‘Ÿ â†’ (ğ‘ğ‘™ğ‘™, ğ‘), (0, ğ‘‚ğ‘ƒğ‘…ğ¸ğ‘‡ ğ‘ˆ ğ‘…ğ‘ = ğ‘ğ‘–ğ‘‘))
ğœŒğ‘™ â† ğ»1 (ğ‘™, tx, ğµ) for ğ‘™ âˆˆ ğ‘†
ğœ†ğ‘– â† (cid:206)ğ‘— âˆˆğ‘†,ğ‘— â‰ ğ‘–
ğ‘… â† (cid:205)ğ‘™ âˆˆğ‘† ğ·ğ‘™ğ‘œ + ğœŒğ‘™ ğ¸ğ‘™ğ‘œ , ğ‘ â† ğ»2 (tx| |ğ‘… | |ğ‘)
ğ‘§ğ‘– â† ğ‘‘ğ‘–ğ‘œ + (ğ‘’ğ‘–ğ‘œ Â· ğœŒğ‘– ) + ğœ†ğ‘– Â· ğ‘ ğ‘– Â· ğ‘
delete ( (ğ‘‘ğ‘–ğ‘œ , ğ·ğ‘–ğ‘œ ), (ğ‘’ğ‘–ğ‘œ , ğ¸ğ‘–ğ‘œ )) from local storage
PoS.Broadcast( âŸ¨SHARE, ğ‘§ğ‘– âŸ©)

upon event PoS.Receive( âŸ¨SHARE, ğ‘§ğ‘˜ âŸ©) from all ğ‘˜ âˆˆ ğ‘† do

CheatingPlayersâ† âˆ…
for ğ‘˜ âˆˆ ğ‘† do
(cid:205)ğ‘¡ âˆ’1
ğ‘Œğ‘˜ = (cid:205)ğ‘— âˆˆğ‘†0
ğ‘¤=0
ğœŒğ‘˜ â† ğ»1 (ğ‘˜, tx, ğµ), ğ‘…ğ‘˜ â† ğ·ğ‘˜ğ‘œ + ğœŒğ‘˜ ğ¸ğ‘˜ğ‘œ , ğ‘… â† (cid:205)ğ‘˜ âˆˆğ‘† ğ‘…ğ‘˜ , ğ‘ â† ğ»2 (tx | |ğ‘… | |ğ‘)
if ğ‘”ğ‘§ğ‘˜ â‰  ğ‘…ğ‘˜ + ğ‘ Â· ğœ†ğ‘˜ Â· ğ‘Œğ‘˜ then
CheatingPlayers.append(ğ‘˜)

ğ‘˜ ğ‘¤ğ´ğ‘— ğ‘¤

PoS.Broadcast( âŸ¨RESTART SIGNING, CheatingPlayersâŸ©)
restofplayers â† ğ¶ğ‘ğ‘¢ğ‘Ÿ .ğ‘”ğ‘’ğ‘¡ğ¼ğ‘›ğ‘‘ğ‘’ğ‘¥ğ‘’ğ‘  () \ ğ‘†
ğ‘† â† ğ‘†\CheatingPlayers
S.append(restofplayers[:|CheatingPlayers|])
ğ‘œ â† ğ‘œ + 1
Timeout.Restart()
go to line 18

ğ‘§ â† (cid:205)ğ‘–âˆˆğ‘† ğ‘§ğ‘–
ğ‘ â† ğ‘ƒğ‘œğ‘†.ğµğ‘™ğ‘œğ‘ğ‘˜â„ğ‘ğ‘ â„ (ğ‘‹ )
ğœâ€² â† ğœ + ğ» (tx | |ğ‘… | |ğ‘)ğ» (ğ‘ğ‘˜ğ‘ğ‘¢ğ‘Ÿ | |ğ‘)
BTC.Broadcast(tx, ğœâ€²)
PoS.Broadcast(tx,ğœâ€²)
return

if PoS.Read( âŸ¨SHAREâŸ©ğ‘ ) == ğ‘›ğ‘–ğ‘™ then

CheatingPlayers.append(p)

ğœŒğ‘˜ â† ğ»1 (ğ‘˜, ğ‘š, ğµ), ğ‘…ğ‘˜ â† ğ·ğ‘˜ ğ‘— + ğœŒğ‘˜ ğ¸ğ‘˜ ğ‘— , ğ‘… â† (cid:205)ğ‘˜ âˆˆğ‘† ğ‘…ğ‘˜ , ğ‘ â† ğ»2 (tx | |ğ‘… | |ğ‘)
if ğ‘”ğ‘§ğ‘˜ â‰  ğ‘…ğ‘˜ + ğ‘ Â· ğœ†ğ‘˜ Â· ğ‘Œğ‘˜ then
CheatingPlayers.append(p)

PoS.Broadcast( âŸ¨RESTART SIGNING, CheatingPlayersâŸ©)
restofplayers â† ğ¶ğ‘ğ‘¢ğ‘Ÿ .ğ‘”ğ‘’ğ‘¡ğ¼ğ‘›ğ‘‘ğ‘’ğ‘¥ğ‘’ğ‘  \ ğ‘†
ğ‘† â† ğ‘†\CheatingPlayers
S.append(restofplayers[:|CheatingPlayers|])
ğ‘œ â† ğ‘œ + 1
go to line 18

âŠ² Number of pre-process steps

âŠ² Pseudo-randomly choose set of signers

âŠ² Choose t+1 participants for signing

âŠ² Compute the transaction

âŠ² All shares were received

âŠ² add as many players as were removed

âŠ² Commitment to the blockchain
âŠ² compute taproot signature

âŠ² We implement a timeout to deal with aborting participants

âŠ² p hasnâ€™t submitted its share

âŠ² add as many players as were removed

[8] P. Chaidos and A. Kiayias. Mithril: Stake-based threshold multisignatures. Cryp-

tology ePrint Archive, 2021.

[9] E. Deirmentzoglou, G. Papakyriakopoulos, and C. Patsakis. A survey on long-
range attacks for proof of stake protocols. IEEE Access, 7:28712â€“28725, 2019.
[10] M. Drijvers, K. Edalatnejad, B. Ford, E. Kiltz, J. Loss, G. Neven, and I. Stepanovs.
In 2019 IEEE Symposium on

On the security of two-round multi-signatures.
Security and Privacy (SP), pages 1084â€“1101. IEEE, 2019.

[11] Ethereum Foundation. Proof-of-stake (PoS). https://ethereum.org/en/developers/

docs/consensus-mechanisms/pos/, July 2021.

[12] P. Feldman. A practical scheme for non-interactive verifiable secret sharing. In
28th Annual Symposium on Foundations of Computer Science (sfcs 1987), pages
427â€“438. IEEE, 1987.

[13] Filecoin. Filecoin. https://spec.filecoin.io/, November 2021.
[14] J. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis
and applications. In Annual international conference on the theory and applications
of cryptographic techniques, pages 281â€“310. Springer, 2015.
[15] P. GaÅ¾i, A. Kiayias, and D. Zindros. Proof-of-stake sidechains.

In 2019 IEEE

Symposium on Security and Privacy (SP), pages 139â€“156. IEEE, 2019.

[16] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin. Secure distributed key genera-
tion for discrete-log based cryptosystems. In Proceedings of the 17th International
Conference on the Theory and Applications of Cryptographic Techniques, pages
295â€“310. Springer, 1999.

[17] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin. Secure distributed key gener-
ation for discrete-log based cryptosystems. Journal of Cryptology, 20(1):51â€“83,

Pikachu: Securing PoS Blockchains from Long-Range Attacks by Checkpointing into Bitcoin PoW using Taproot

ConsensusDay â€™22, November 7, 2022, Los Angeles, CA, USA

Algorithm 4 Verification

tx0 â† BTC.output(ğ‘ğ‘˜0)
ğ‘– â† 0

outputâ†BTC.getOutput(txğ‘– )
ğ‘– â† ğ‘– + 1

1:
import BTC
2:
import IPFS
3:
import PoS
4: Parameters: ğ‘ğ‘˜0
5:
6:
7: while output is unspent do
8:
9:
10: cid â† output.ğ‘‚ğ‘ƒğ‘…ğ¸ğ‘‡ ğ‘ˆ ğ‘…ğ‘
11: ğ‘„ â† output.TaprootAddress
12: ğ‘šğ‘’ğ‘šğ‘ğ‘’ğ‘Ÿğ‘  â† IPFS.getData(cid)
13: for m in ğ‘šğ‘’ğ‘šğ‘ğ‘’ğ‘Ÿğ‘  do
PoSâ†query(m,PoS)
14:
15: ğ‘ â† PoS.getLatetsCheckpoint
16: ğ‘ğ‘˜ â† PoS.getLatestAggregatedKey
17:
18:
19: else
20:
21:
22:
23:

PoS â† PoS.RemoveBlocks(after c)
ğ‘ â†PoS.getLatetsCheckpoint
ğ‘ğ‘˜ â† PoS.getLatestAggregatedKey
Go to step 17

return 1

if ğ‘„ == ğ‘ğ‘˜ + ğ»ğ‘‡ ğ‘ğ‘ğ‘Ÿğ‘œğ‘œğ‘¡ (ğ‘ğ‘˜ | |ğ‘)ğº then

âŠ² Initial public key
âŠ² In the case of multiple transactions spent by ğ‘ğ‘˜0, choose the first one

âŠ² Get chain of transactions

âŠ² Get the configuration from IPFS

âŠ² get the latest PoS state from the current members
âŠ² verify checkpoint

âŠ² Verify that the state of the database is consistent with the Bitcoin checkpoint

âŠ² Roll back the PoS chain to the previous checkpoint

2007.

[18] Y. Gilad, R. Hemo, S. Micali, G. Vlachos, and N. Zeldovich. Algorand: Scaling
byzantine agreements for cryptocurrencies. In Proceedings of the 26th symposium
on operating systems principles, pages 51â€“68, 2017.

[19] J. Groth. Non-interactive distributed key generation and key resharing. Cryptol-

ogy ePrint Archive, 2021.

[26] S. Nakamoto and A. Bitcoin. A peer-to-peer electronic cash system. Bitcoin.â€“URL:

https://bitcoin. org/bitcoin. pdf, 4, 2008.

[27] J. Nick, T. Ruffing, and Y. Seurin. MuSig2: Simple two-round Schnorr multi-

signatures. Cryptology ePrint Archive, 2020:1261, 2020.

[28] Protocol Labs. IPFS powers the distributed web. https://ipfs.io/.
[29] C. Schnorr. Efficient signature generation by smart cards. J. Cryptol., 4(3):161â€“174,

[20] S. King and S. Nadal. PPCoin: Peer-to-peer crypto-currency with proof-of-stake.

1991.

https://www.peercoin.net/whitepapers/peercoin-paper.pdf, 2012.

[21] C. Komlo and I. Goldberg. FROST: Flexible Round-Optimized Schnorr Threshold

Signatures. IACR Cryptology ePrint Archive, 2020:852, 2020.

[22] P. Kuznetsov and A. Tonkikh. Asynchronous reconfiguration with byzantine
failures. In H. Attiya, editor, 34th International Symposium on Distributed Com-
puting, DISC 2020, October 12-16, 2020, Virtual Conference, volume 179 of LIPIcs,
pages 27:1â€“27:17. Schloss Dagstuhl - Leibniz-Zentrum fÃ¼r Informatik, 2020.
[23] J. Liu, W. Zheng, D. Lu, J. Wu, and Z. Zheng. Understanding the decentralization

[30] S. Steinhoff, C. Stathakopoulou, M. Pavlovic, and M. VukoliÄ‡. BMS: Secure
decentralized reconfiguration for blockchain and BFT systems. arXiv preprint
arXiv:2109.03913, 2021.

[31] D. R. Stinson and R. Strobl. Provably secure distributed Schnorr signatures and a
(t, n) threshold scheme for implicit certificates. In 6th Australasian Conference on
Information Security and Privacy, pages 417â€“434. Springer, 2001.

[32] E. N. Tas, D. Tse, F. Yu, and S. Kannan. Babylon: Reusing bitcoin mining to

enhance proof-of-stake security. arXiv preprint arXiv:2201.07946, 2022.

of dpos: Perspectives from data-driven analysis on eosio, 2022.

[33] M. VukoliÄ‡. On the future of decentralized computing. Bulletin of the EATCS,

[24] S. Meiklejohn, M. Pomarole, G. Jordan, K. Levchenko, D. McCoy, G. M. Voelker,
and S. Savage. A fistful of bitcoins: characterizing payments among men with no
names. In Proceedings of the 2013 conference on Internet measurement conference,
pages 127â€“140, 2013.

[25] Murch. 2-of-3 multisig inputs using Pay-to-Taproot. https://murchandamus.
medium.com/2-of-3-multisig-inputs-using-pay-to-taproot-d5faf2312ba3, De-
cember 2020.

2021.

A EXTRA FIGURE

14

1 EXTRA FIGURE

(a) DKG.

(b) Signing.

Figure 8: Execution time of our protocols with failures (here an aborting participant). A (conservative) timeout of 12 seconds
was chosen. In the DKG case, the timeout is repeated over the different rounds (waiting for shares of the secrets, for public
commitments, for complaints, for complaint answers). This explains the much longer execution time.

3579111315171921Number of participants0510152025303540455055Seconds3579111315171921Number of participants051015Seconds