Pikachu: Securing PoS Blockchains from Long-Range Attacks by
Checkpointing into Bitcoin PoW using Taproot

Sarah Azouvi
Protocol Labs

Marko Vukolić
Protocol Labs

2
2
0
2

t
c
O
3
1

]

R
C
.
s
c
[

2
v
8
0
4
5
0
.
8
0
2
2
:
v
i
X
r
a

ABSTRACT
Blockchain systems based on a reusable resource, such as proof-of-
stake (PoS), provide weaker security guarantees than those based
on proof-of-work. Specifically, they are vulnerable to long-range
attacks, where an adversary can corrupt prior participants in order
to rewrite the full history of the chain. To prevent this attack on
a PoS chain, we propose a protocol that checkpoints the state of
the PoS chain to a proof-of-work blockchain such as Bitcoin. Our
checkpointing protocol hence does not rely on any central authority.
Our work uses Schnorr signatures and leverages Bitcoin recent
Taproot upgrade, allowing us to create a checkpointing transaction
of constant size. We argue for the security of our protocol and
present an open-source implementation that was tested on the
Bitcoin testnet.

CCS CONCEPTS
• Security and privacy → Cryptography.

KEYWORDS
Blockchain, proof-of-stake, long-range attack

ACM Reference Format:
Sarah Azouvi and Marko Vukolić. 2022. Pikachu: Securing PoS Blockchains
from Long-Range Attacks by Checkpointing into Bitcoin PoW using Taproot.
In Proceedings of the 2022 ACM Workshop on Developments in Consensus
(ConsensusDay ’22), November 7, 2022, Los Angeles, CA, USA. ACM, New
York, NY, USA, 14 pages. https://doi.org/10.1145/3560829.3563563

1 INTRODUCTION
Long-range attacks (LRA) — also called posterior corruption at-
tacks [9] — are one of the major security issues affecting permis-
sionless proof-of-stake (PoS) blockchains. These attacks rely on the
inability of a user who disconnects from the system at time 𝑡1 and
reconnects at a later time to tell that validators who were legitimate
at time 𝑡1 and left the system (by e.g., transferring their stake to
other validators, or to themselves under a different identity) are
not to be trusted anymore. In a PoS system, where the creation of
blocks is costless (i.e., does not cost physical resource such as en-
ergy), and timeless (i.e., is not rate-limited in time), these validators
could create a fork that starts from the past, i.e., at time 𝑡1, and runs
until the present. This is in sharp contrast to proof-of-work (PoW)
systems, where creating blocks requires time (e.g., due to Bitcoin
[26] difficulty adjustment) and physical resources (e.g., energy for
performing actual computation) and not just using cryptographic

This work is licensed under a Creative Commons Attribution
International 4.0 License.

ConsensusDay ’22, November 7, 2022, Los Angeles, CA, USA
© 2022 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-9879-4/22/11.
https://doi.org/10.1145/3560829.3563563

Figure 1: Illustration of the long-range attack. After the
green validators (i.e., validators associated with the green
key on the figure) left the system, the adversary acquired
their keys. In a PoS blockchain, having access to validators’
keys is enough to create new blocks and hence the adversary
can create a chain as long as the honest chain (perhaps even
simulating configuration change in its chain). Any user that
trusted the green key and is presented with both chains can-
not differentiate the honest from the adversarial chain.

keys. A client of a PoS blockchain would be unable to recognize the
attack as they are presented with a “valid” chain fork. See Figure 1
for a visual explanation of the attack.

Recently, Steinhoff et al. [30] proposed an approach to deal
with LRA by anchoring (checkpointing) the PoS membership into
Ethereum’s proof-of-work blockchain (Eth 1.0), which is not vul-
nerable to this type of attack. The main idea of their work is to have
a smart contract on the Ethereum blockchain that keeps track of
the state of the membership of the underlying PoS system. For a
typical Byzantine Fault-Tolerant (BFT) protocol underlying a PoS
blockchain, the smart contract on Ethereum would only be updated
if, e.g., two thirds of the current staking power (or blockchain mem-
bers in case of uniform voting rights) instruct the smart contract to
do so. In the approach of Steinhoff et al. each validator will send a
transaction to the smart contract that indicates a vote for a new set
of validators. As soon as two thirds of the votes for the same set
have been received, the smart contract automatically updates its
state to the new set. From this moment on, the members of the new
set are in charge of voting for the next set and so forth. Every user
that needs to verify that a set of validators are indeed legitimate and
most recent ones, can do so by simply checking the smart contract.
An adversary cannot change the state of the smart contract, even
with the keys of former validators, without creating a fork on the
PoW blockchain, which is considerably more, if not prohibitively
expensive. Any user can resort to the Ethereum smart contract to
verify the correct state of the checkpointed PoS chain, effectively
preventing the LRA attack.

 
 
 
 
 
 
ConsensusDay ’22, November 7, 2022, Los Angeles, CA, USA

Sarah Azouvi and Marko Vukolić

However, as it happens, Ethereum is abandoning PoW and tran-
sitions to PoS [11] (Eth 2.0). Hence, the approach of Steinhoff et al.
is no longer viable as PoS of Eth 2.0 cannot be used instead of PoW
for anchoring as it is itself susceptible to the LRA vulnerability. In
this paper, we design a solution to LRA, inspired by Steinhoff et
al., using Bitcoin’s PoW, assuming that Bitcoin will never change
its underlying consensus mechanism. The history of altcoin forks
off Bitcoin and the Bitcoin development ethos give very realistic
assurance that this assumption will hold.1

However, the implementation and design of such a scheme on
Bitcoin is more challenging, compared to the implementation of
Steinhoff et al. on Eth 1.0, because Bitcoin’s scripting language
expressivity is considerably more limited compared to smart con-
tracts on Ethereum. Besides, the approach designed by Steinhoff
et al. leverages multi-signatures for anchoring, which can quickly
bloat the transaction size, making it at worst impossible to anchor
PoS networks with large number of validators, or, at best, very
costly to do so.

To address these limitations, our approach is to use the capabili-
ties enabled by the recent Taproot upgrade [3] to Bitcoin, which
allows for more efficient Schnorr threshold signatures. Briefly, our
protocol, called Pikachu, works as follows. As Bitcoin does not
allow for stateful smart contracts, we use an aggregated public key
to represent the configuration of validators 𝐶𝑖 in the PoS system.
When the set changes significantly enough to configuration 𝐶𝑖+1,
the aggregated key must be updated in the Bitcoin blockchain. This
is done by having a transaction transferring the funds associated
with the aggregated key of the previous validators 𝐶𝑖 to the new ag-
gregated key controlled by validators in configuration 𝐶𝑖+1. Instead
of having each validator in 𝐶𝑖 send a transaction to the Bitcoin
network, this transaction is signed interactively, off-chain, and all
the signatures are aggregated into one constant-size signature. Fur-
thermore, we store the Merkle root of the state of the checkpointed
PoS blockchain in the Bitcoin 𝑂𝑃_𝑅𝐸𝑇𝑈 𝑅𝑁 field of the transaction
from 𝐶𝑖 to 𝐶𝑖+1. We store the data pertaining to this checkpoint off
Bitcoin blockchain. While the data pertaining to the checkpoint
could be stored anywhere (e.g., IPFS [28]) and validated against the
state root stored in the Bitcoin transaction — our implementation
uses a content-addressable key-value store implemented on top
of the PoS system to store the actual checkpointed state. Figure 2
illustrates the high-level protocol. We note that since our work is
based on Schnorr threshold signatures and uses Bitcoin’s Taproot,
it could be of independent interest to any project looking to im-
plement threshold signing transactions on Bitcoin (for example,
sidechains [2]).

To summarize, our contribution is as follows. Starting from the
observation that PoW gives much stronger security guarantees
than PoS, we present a protocol to protect current PoS blockchains
against LRA by anchoring their state onto Bitcoin’s blockchain. The
advantage of using Bitcoin unlike, for example, a website, is that it
is itself decentralized, hence our protocol does not add any single
point-of-failure to a decentralized PoS system. We implemented
our protocol on top of a delegated PoS blockchain and tested it on

1The discussion on long-term viability of energy consumption of Bitcoin is out of
scope of this paper and is available elsewhere [33].

Figure 2: High-level visualization of the Pikachu protocol.
Checkpoints from the PoS chain (in blue) are periodically
pushed to the Bitcoin blockchain (in orange) by the PoS
Validators. The checkpoints contain the Taproot address 𝑄
(which itself contains the aggregated public key of the con-
figuration and commitment to the PoS chain ckpt) as well
as a content identifier 𝑐𝑖𝑑 that can be used with any content-
addressable storage to retrieve information about the con-
figuration (IPFS pictured).

Bitcoin testnet storing checkpoints into a key-value store main-
tained by the PoS validators (although alternative storage method,
such as IPFS could be used).

The rest of this paper is organized as follows. We start by pro-
viding the necessary background in Section 2 and our model and
assumptions in Section 3. We present our design in Section 4 then
a security argument in Section 5. Section 6 presents the implemen-
tation of the protocol. We discuss related work in Section 7.

2 BACKGROUND
We use elliptic curve notation for the discrete logarithm problem.
Suppose 𝑞 is a large prime and 𝐺, 𝐽 are generators of a subgroup of
order 𝑞 of an elliptic curve E. We assume that E is chosen in such a
way that the discrete logarithm problem in the subgroup generated
by 𝐺 is hard, so it is infeasible to compute the integer 𝑑 such that
𝐺 = 𝑑 𝐽 .

Let 𝐻, 𝐻1, 𝐻2, 𝐻𝑇 𝑎𝑝𝑇 𝑤𝑒𝑎𝑘 be cryptographic hash functions map-
←− 𝑆 that 𝑥 is selected uniformly at

𝑞. We denote by 𝑥 $

ping to Z∗
random from 𝑆.

2.1 Schnorr signature
The Schnorr signing scheme [29] works as follows. Let (𝑠, 𝑌 ) ∈
Z∗
𝑞 × E be a user key pair (such that 𝑌 = 𝑠𝐺) and 𝑚 a message to be
signed. The signer performs the following steps.

(1) 𝑘 $
←− Z∗
𝑞
(2) 𝑅 ← 𝑘𝐺
(3) 𝑧 ← 𝑘 + 𝐻 (𝑚||𝑅||𝑌 ) · 𝑠 mod 𝑞

The signature is then (𝑧, 𝑅) and is verified by checking that 𝑧𝐺 ?=
𝑅 + 𝐻 (𝑚||𝑅||𝑌 )𝑌 .

2.2 Secret sharing schemes
A secret sharing scheme allows one participant (a dealer) to share a
secret with 𝑛 other participants, such that any 𝑡 of them can recover

cidCitx1tx2Information about current conﬁgurationQ1→Q2Q2→Q3cid2cid3Pikachu: Securing PoS Blockchains from Long-Range Attacks by Checkpointing into Bitcoin PoW using Taproot

ConsensusDay ’22, November 7, 2022, Los Angeles, CA, USA

the secret but any set of 𝑡 − 1 or less of them cannot. Furthermore,
a desirable property of a secret sharing scheme is to be publicly
verifiable, i.e., anyone should be able to verify that the dealer com-
puted the correct shares and did not cheat. In this paper, we will
use Feldman’s verifiable secret sharing scheme [12] (VSS), which
we describe in steps 1-3 of Figure 5.

2.2.1 Generating a secret. Unlike Feldman’s VSS scheme, in which
only one participant generates a secret and shares it with their
peers, we consider a protocol where everyone contributes equally
to generate a common secret, such that no set of participants of
size strictly smaller than 𝑡 can recover the secret on their own. We
will use the scheme designed by Gennaro et al. [17] that we define
in Figure 5, and we adopt the following notation:

(𝑠1, · · · , 𝑠𝑛)

(𝑡,𝑛)
←−−→ (𝑟, 𝑌 , 𝑎𝑘𝐺, 𝑆0), 𝑘 ∈ {1, · · · , 𝑡 − 1}

to mean that 𝑠 𝑗 is player 𝑗’s share of the secret 𝑟 for each 𝑗 ∈ 𝑆0.
The values 𝑎𝑘𝐺 are the public commitments used to verify the
correctness of the shares and (𝑟, 𝑌 ) forms a key pair where 𝑟 is
a private key and 𝑌 is the corresponding public key. The set 𝑆0
denotes the set of players that have not been detected to be cheating
during the execution of the protocol. This protocol is secure for
any 𝑡 > 𝑛
2 (i.e., it can tolerate an adversary that corrupts up to half
of the participants).

2.3 Threshold signing
A 𝑡-of-𝑛 threshold signing scheme allows any combination of 𝑡 par-
ticipants to sign a message while preventing any coalition of 𝑡 − 1
participants or less to create a valid signature, i.e., at least 𝑡 partici-
pants must agree to sign the message for the signature to be valid.
We use the threshold signing protocol FROST [21], that we define
in Figure 6. This interactive protocol will either output a Schnorr
signature (𝑧, 𝑅) on a message 𝑚 or a abort message, together with
a set of misbehaving participants such that the protocol can be
rerun without these misbehaving participants in the next step. The
protocol relies on a signature aggregator (SA), however, as the main
role of the SA is to choose the subset of participants designated
for signing, it can easily be removed. Instead, we can have each
participant compute the set in a deterministic way. Alternatively,
in the case of PoS chain, we could choose this set pseudo-randomly
using some randomness coming from the chain (random numbers
are often created as part of a PoS protocol as they are needed for,
e.g., leader election).

Choice of the Schnorr signing protocol. We chose to use the FROST
signing protocol because it is more efficient than alternative proto-
cols, such as the Stinson and Strobl [31] protocol, even though it
is not robust, i.e., the protocol cannot complete if one participant
aborts or misbehaves. However, misbehaving participants are de-
tectable in FROST (each public share is verifiable against a public
key), so the protocol can simply be restarted from scratch without
those malicious participants. We did not use other Schnorr signing
protocols [10, 27] as they are not compatible with threshold signing.
Note that we did not implement the key generation algorithm
presented by Komlo and Goldberg [21], used originally in FROST,
as it does not allow to detect misbehaving participants, therefore

losing the ability to re-start the protocol without the misbehav-
ing participants. Instead, we will use the scheme by Gennaro et
al. [16] and borrow only the signing scheme presented in the FROST
paper [21], as per the authors’ suggestion. The distributed key gen-
eration (DKG) algorithm by Gennaro et al. is also used by Stinson
and Strobl [31] and has the advantage of being robust (it will com-
plete despite misbehaving participants, who are detected through a
complaint process). We follow the suggestion in Gennaro et al. [17]
and use the simpler variant of the DKG, JF-DKG, as this is sufficient
for our application of threshold signing.

The main reason for preferring an efficient but non-robust sign-
ing algorithm is that our protocol will eventually be incentivized
(financial rewards will be given out to participants who perform
the signature). Therefore, it is reasonable to expect participants to
cooperate, especially when malicious behavior is detectable and
can only delay — not prevent — the signing. Because both the DKG
and the signing part of our protocol are modular, other threshold
signing protocols can be used interchangeably for different threat
models (e.g., including the robust signing protocol in [31]).

2.4 Taproot
Taproot is a recent Bitcoin network upgrade that allows transac-
tions to be signed using Schnorr signatures and that introduces a
new data-structure, Merkelized Abstract Syntax Trees (MAST), for
more advanced scripting in a privacy-preserving way. The main
advantage of Schnorr signatures over the ECDSA multi-signature
is that they enable signature aggregation, saving space in Bitcoin
blocks while also providing more privacy as it is not possible to dis-
tinguish between a “regular” transaction, i.e., sending bitcoins from
one person to another, and a more complex one, e.g., using a thresh-
old signature. This could help hide identities in the blockchain
and thwart clustering deanonymization [24] although we are not
interested in this property for this work.

A Taproot address has two components: a single public key
(the internal key) and a script tree, identified by its Merkle root.
Either component can be used independently to spend the UTXO.
In the case of threshold or multi-signatures, the internal key can
be the aggregated public key of all the signers. The script tree can
contain an arbitrary number of different scripts, each of which
specify a condition that must be satisfied in order for the coins
to be spendable. For example, one condition can be to give the
pre-image of a hash. As the name suggests, in the script tree, the
scripts are organized in a tree (see Figure 3). The transaction can
be spent either by using the internal secret key (key path) or by
satisfying one of the conditions in the tree (script path). In this
paper, we are interested in spending a Taproot output using the
key path. It should be noted that it is possible to use the script tree
to define a threshold signature scheme [25], though less efficient as
the size of the tree would grow exponentially with the number of
participants [2].

We now detail how to spend a Taproot output using the key

path.

2.4.1 Key path spending. To prevent a potential vulnerability in
which one user of a threshold or multi-signature could steal all the
funds [4], the output key should commit to a (potentially unspend-
able) script path even if the spending condition does not require

ConsensusDay ’22, November 7, 2022, Los Angeles, CA, USA

Sarah Azouvi and Marko Vukolić

of proof-of-storage).We call the set of weighted participants in a
configuration the power table. The power table is determined by a set
of signing keys and their associated weight: 𝐶 = {(𝑃𝑜𝑆.𝑝𝑘𝑖, 𝑤𝑖 )} |𝐶 |
𝑖=1.
Each signing private key 𝑃𝑜𝑆.𝑠𝑘𝑖 is private to 𝑖-th participant. For
simplicity, we consider a flat model, i.e., one participant accounts
for one unit of power in the PoS blockchain, hence we omit the
weight from our model moving forward. The flat model could be
generalized by considering that one participant with 𝑥 units of
power possesses 𝑥 public keys, one for each of their units of power.
We will discuss how this assumption impacts the scalability of
our protocol in Section 8. Furthermore, we assume that there is
some similarity between successive configurations of the system,
i.e., the set of participants does not change completely from one
configuration to another. Formally, we define the difference between
two configurations 𝐶 𝑗 and 𝐶𝑖 as their symmetric difference (𝐶𝑖 △𝐶 𝑗 ),
which corresponds to the number of reconfiguration requests that
need to be applied to 𝐶𝑖 in order to obtain 𝐶 𝑗 . We assume that
for two consecutive configurations 𝐶𝑖 and 𝐶𝑖+1, their symmetric
difference is bounded by some parameter 𝑏.

Following [1], we define a perpetually honest participant as a
participant that follows the protocol and maintains the secrecy
of their signing keys in perpetuity (an adversary may never have
access to them). This is opposed to an eventually compromised
participant who after some time, leaks all its previous signature
keys to the adversary.

We assume that the PoS is secure, i.e., satisfies the usual security
properties of consistency, chain growth, and chain quality [14],
as long as a sufficient fraction of the participants are perpetually
honest. Let 𝑓 be the maximum fraction of power that an adversary
can control while the protocol maintains its security when the
rest of the power table is perpetually honest (e.g., 𝑓 = 1/3). For
simplicity, we assume that this blockchain provides instant finality,
i.e., that there are no forks. This can be achieved using some variant
of a BFT-protocol [7, 18] or relaxed by using a “lookback” parameter.
For example, if a block is final after 𝑘 confirmations, then we will
use the state of the chain 𝑘 blocks in the past instead of the latest
state to ensure consistent views across participants.

For the rest of this paper we will consider the security of the PoS
chain under eventually compromised honest participant as follows.
We consider an adversary A that, for each state 𝑖 of the PoS system,
controls all the keys from previous configurations (𝐶 𝑗 ) 𝑗 <𝑖−𝐿 where
𝐿 ≫ 1 is a parameter (assumption 1) as well as a fraction of at most
𝑓 participants in configurations (𝐶 𝑗 )𝑖−𝐿 ≤ 𝑗 ≤𝑖 (assumption 2). We
quickly note that 𝑓 < 1
2 since there does not exist any protocol that
is secure with 𝑓 > 1
2 .

Under this assumption, the adversary is able to mount a LRA
as follows. The adversary starts a fork of the PoS chain at height
𝑗 < 𝑖 − 𝐿, using the keys from configuration 𝐶 𝑗 and that runs until
the current height 𝑖. Since the adversary does not hold the keys
from configuration 𝑖 −𝐿 and above, this means that from this height,
the configurations on the adversarial fork and on the honest chain
must differ. Note that under this attack, any online validator is able
to differentiate the correct chain from a chain created as part of a
LRA (since they are not part of the configurations in the adversarial
fork). In the rest of the paper we use correct chain to mean the chain
in the view of the online validators. Our protocol will ensure that

Figure 3: Taproot Output Composition

a script path (i.e., if only the key path is going to be used). There
are multiple ways to achieve this with Taproot. The most natural
way is to simply include the internal public key in the “tweak.” The
tweaked public key (i.e., outer key) is then computed as follows:
𝑄 = 𝑃 + int(𝐻𝑇 𝑎𝑝𝑇 𝑤𝑒𝑎𝑘 (𝑏𝑦𝑡𝑒𝑠 (𝑃)))𝐺
where 𝑃 is the internal public key and 𝐻𝑇 𝑎𝑝𝑇 𝑤𝑒𝑎𝑘 is a hash function.
The associated tweaked private key is then:

𝑞 = 𝑝 + int(𝐻𝑇 𝑎𝑝𝑇 𝑤𝑒𝑎𝑘 (𝑏𝑦𝑡𝑒𝑠 (𝑃)))
where 𝑝 is the private key associated with 𝑃. In order to spend the
output using the key path, one must then sign the transaction with
the tweaked private key.

Adding a commitment. Alternatively, the script path could be
used to add a commitment. For example in our case this commitment
could be the hash of the underlying PoS chain at regular intervals.
Let 𝑐 denote this commitment. In this case, the tweaked public key
becomes: 𝑄 = 𝑃 + 𝐻𝑇 𝑎𝑝𝑇 𝑤𝑒𝑎𝑘 (𝑃 ||𝑐)𝐺 and the tweaked private key
𝑞 = 𝑝 + 𝐻𝑇 𝑎𝑝𝑇 𝑤𝑒𝑎𝑘 (𝑃 ||𝑐). The script path is still unspendable, and
the output is spent by signing using the tweaked private key.

2.4.2 Transaction notation. For any Bitcoin transaction, we use
the following notation:

, . . . , output𝑗 with, respectively, amount1,. . . , amount𝑗 .

, . . . , input𝑖 → ((amount1, output1), . . . , (amount𝑗 , output𝑗 ))
. . . , input𝑖 are trans-

input1
to say that all the coins associated with input1
ferred to output1
As a reminder, since Bitcoin is UTXO based, all the coins from an
input must be transferred during the transaction, although to po-
tentially multiple addresses. Additionally, it must be the case that
.amount + · · · + input𝑖 .amount
amount1 + · · · + amount𝑗 ≤ input1
where input𝑘 .amount represents the total amount associated with
input𝑘 . The remaining amount (in the case of a strict inequality) is
used as a transaction fee for the miner mining the block.

3 MODEL AND ASSUMPTIONS
We assume an underlying blockchain based on a reusable resource
such as PoS or proof-of-space . Each state of the PoS blockchain is
associated with a set of participants, called the configuration and
denoted by 𝐶, and their corresponding power (e.g., number of coins
staked in the case of proof-of-stake and storage space in the case

Public key
(Tweaked)Internal Key
Schnorr
(Aggregated)Merkle RootHash 1Hash 2Script 1Script 2TweakPikachu: Securing PoS Blockchains from Long-Range Attacks by Checkpointing into Bitcoin PoW using Taproot

ConsensusDay ’22, November 7, 2022, Los Angeles, CA, USA

any user is also able to distinguish each chain even if they have
been offline, by looking at the Bitcoin blockchain. We discuss the
security properties that the protocol should achieve in Section 5.
We add another, optional, assumption: the existence of a random
beacon (RB𝑖 )𝑖 ∈N that emits a new randomness for each state of
the database (i.e., at each height of the underlying PoS blockchain).
This is a standard assumption in PoS blockchains as a random
beacon is necessary for the leader election part of the protocol. This
randomness will be used by participants to pseudo-randomly select
the set of signers. Another option would be to select this set in any
deterministic manner.

Lastly, participants will use the PoS chain to broadcast the mes-
sages relative to our Pikachu protocol (although another broadcast
channel could be implemented alternatively). We assume that each
message is included in the chain (or broadcast) after a small number
of blocks.

4 PROTOCOL
4.1 Overview
The intuition behind the protocol is as follows: each configura-
tion 𝐶𝑖 is associated with a Taproot public key 𝑄𝑖 that consists
of an internal key, in this case an aggregate public key 𝑝𝑘𝑖 , that
participants computed with an interactive DKG protocol (step 1
of the main algorithm protocol in Figure 4) and a tweaked part as
defined in Section 2.4.1. We chose to tweak the internal key using a
commitment to the PoS chain (i.e., the hash of the state of the PoS
blockchain). Each player 𝑗 in the configuration then knows a share
of the secret key associated with 𝑝𝑘𝑖 , 𝑠𝑖,𝑗 , such that 𝑡𝑖 of the shares
are enough to compute a valid signature on any message, but fewer
than 𝑡𝑖 participants cannot compute a signature. Configuration 𝐶𝑖
is responsible for anchoring the state of the PoS chain at this point
in time in the Bitcoin blockchain, which also includes updating
the new configuration. In order to do so, the new configuration
𝐶𝑖+1 must first compute their aggregated public key 𝑝𝑘𝑖+1 using the
DKG algorithm. This key is then tweaked using a commitment ckpt
to the PoS chain (i.e., the hash of the PoS chain at that time). The
tweaked key becomes 𝑄𝑖+1 = 𝑝𝑘𝑖+1 + 𝐻𝑇 𝑎𝑝𝑇 𝑤𝑒𝑎𝑘 (𝑝𝑘𝑖+1||ckpt)𝐺.
Note that only the tweaked key will appear on the blockchain so the
hash ckpt will not be visible by anyone looking at the blockchain
without external knowledge. However, anyone who has access to
𝑝𝑘𝑖+1 and ckpt can easily reconstruct 𝑄𝑖+1 to verify that their view
of the PoS chain is correct.

To update the configuration from 𝐶𝑖 to 𝐶𝑖+1, a transaction from
𝑄𝑖 to 𝑄𝑖+1 must be included in the Bitcoin blockchain (steps 3
and 4 in Figure 4). Leveraging the recent Bitcoin Taproot upgrade
(that allows for Schnorr signatures), the transaction needs to be
signed by 𝑡𝑖 participants from configuration 𝐶𝑖 where 𝑡𝑖 is chosen
to be strictly more than 𝑓 |𝐶𝑖 | as this ensures that at least one
honest participant signs, preventing an adversary from signing
an illegitimate transaction. As discussed previously, we will use
the FROST algorithm for signing. Note that, the DKG requires
that 𝑡𝑖 > 0.5|𝐶𝑖 | to ensure security so our final constraint on 𝑡𝑖 is
𝑡𝑖 > max(0.5|𝐶𝑖 |, 𝑓 |𝐶𝑖 |). Since we assume that online validators
can distinguish a LRA chain, it is enough to have the transaction
signed by 𝑡𝑖 participants as no honest validators can be fooled into
signing an illegitimate transaction. If forks were allowed even in

the case of perpetually honest validators (i.e., outside of LRA forks),
this would be more problematic, as two conflicting transactions
could then be signed, and we would require at least two thirds of
the participants to sign the transaction, for 𝑓 = 1/3 (as previously
mentioned, this can also be fixed by considering a block in the past,
i.e., one that has been finalized).

In addition to the transfer of coins from 𝑄𝑖 to 𝑄𝑖+1, the transac-
tion spent by configuration 𝐶𝑖 will have a second output that does
not receive any bitcoins and that is unspendable, but that contains
an identifier 𝑐𝑖𝑑 used to retrieve the full details of the configuration.
This is done using the 𝑂𝑃_𝑅𝐸𝑇𝑈 𝑅𝑁 opcode of Bitcoin [5] that
allows storing of extra information in the chain, which we use to
store 𝑐𝑖𝑑. This identifier will be useful in the case where a user
does not have access to the right PoS chain (i.e., does not have the
correct value for 𝑝𝑘𝑖+1 and ckpt due to a LRA). In this case, the con-
tent identifier 𝑐𝑖𝑑 can be used, together with a content-addressable
decentralized storage, for example IPFS [28] or Filecoin [13] (or
a content-addressable storage implemented on the PoS network
validators) to retrieve the identities of the nodes in the correct con-
figuration. The transaction updating the configuration will look as
follows:

tx𝑖 : 𝑄𝑖 → ((amount, 𝑄𝑖+1), (0, 𝑂𝑃_𝑅𝐸𝑇𝑈 𝑅𝑁 = 𝑐𝑖𝑑𝑖+1))

meaning that amount is transferred to 𝑄𝑖+1 and 0 is transferred to
𝑂𝑃_𝑅𝐸𝑇𝑈 𝑅𝑁 = 𝑐𝑖𝑑𝑖+1 (unspendable output). This information is
then publicly available. We discuss in Section 4.3 how any user can
then use it to get the latest PoS configuration.

We add the following assumption (assumption 3): we assume that
tx𝑖 is finalized in the Bitcoin blockchain before the configuration
𝐶𝑖+𝐿 is formed, where 𝐿 ≫ 1 is the parameter defined in assumption
1 (Section 3).

The high-level description of the protocol is presented in Figure 4
and the pseudocode in Algorithm 1. The pseudocode for our DKG
and signing subroutines are presented in Algorithms 2 and 3. In
all our pseudocode, the notation ⟨𝑚𝑠𝑔⟩𝑖 means that message 𝑚𝑠𝑔
was sent by participant 𝑖 and we use PM(⟨𝑚𝑠𝑔⟩, 𝑖) to denote that a
private message 𝑚𝑠𝑔 was sent to participant 𝑖.

We make the following remarks about our protocol. First, in
steps 3b and 5 we ask that every participant 𝑃 𝑗 in configuration
𝐶𝑖 publishes the configuration state to the decentralized storage
provider and sends the signed transaction tx𝑖 to the Bitcoin network.
We do so out of caution. In practice only one validator needs to
do so, but this validator could be controlled by the adversary and
abort instead.

Second, in step 4 of the protocol, we remark that the final signa-

ture on the transaction, 𝑧 ′, is “tweaked” using

𝐻 (tx𝑖 ||𝑅||𝑄𝑖 )𝐻𝑇 𝑎𝑝𝑇 𝑤𝑒𝑎𝑘 (𝑝𝑘𝑖 ||ckpt).

This is because because the signature computed as part of the
FROST signing algorithm will verify against the key 𝑝𝑘𝑖 , computed
during the DKG but not 𝑄𝑖 = 𝑝𝑘𝑖 + 𝐻𝑇 𝑎𝑝𝑇 𝑤𝑒𝑎𝑘 (𝑝𝑘𝑖 ||ckpt). For the
signature to be valid on the taproot output, the signature must
verify against the tweaked key 𝑄𝑖 . Because Schnorr is additive, it is
enough to add the term 𝐻 (tx𝑖 ||𝑅||𝑄𝑖 )𝐻𝑇 𝑎𝑝𝑇 𝑤𝑒𝑎𝑘 (𝑝𝑘𝑖 ||ckpt) to the
signature. Indeed one can verify that if 𝑧𝐺 = 𝑅 + 𝐻 (tx𝑖 ||𝑅||𝑄𝑖 )𝑝𝑘𝑖

ConsensusDay ’22, November 7, 2022, Los Angeles, CA, USA

Sarah Azouvi and Marko Vukolić

then
𝑧 ′𝐺 = 𝑧𝐺 + 𝐻 (tx𝑖 ||𝑅||𝑄𝑖 )𝐻𝑇 𝑎𝑝𝑇 𝑤𝑒𝑎𝑘 (𝑝𝑘𝑖 ||ckpt)𝐺

= 𝑅 + 𝐻 (tx𝑖 ||𝑅||𝑄𝑖 )𝑝𝑘𝑖 + 𝐻 (tx𝑖 ||𝑅||𝑄𝑖 )𝐻𝑇 𝑎𝑝𝑇 𝑤𝑒𝑎𝑘 (𝑝𝑘𝑖 ||ckpt)𝐺
= 𝑅 + 𝐻 (tx𝑖 ||𝑅||𝑄𝑖 )(𝑝𝑘𝑖 + 𝐻𝑇 𝑎𝑝𝑇 𝑤𝑒𝑎𝑘 (𝑝𝑘𝑖 ||ckpt)𝐺)
= 𝑅 + 𝐻 (tx𝑖 ||𝑅||𝑄𝑖 )𝑄𝑖

4.2 Initialization and funding
The initial key 𝑄0 is created by having the first configuration run
the DKG, and tweak it with a hash of the genesis block of the PoS
chain. In order to fund the initial transaction, we want each partici-
pant in 𝐶0 to send a small amount of bitcoins to 𝑄0. However it is
not possible to enforce this. A participant that does not contribute
to the fee would still hold a share of the secret key associated with
𝑄0. Indeed 𝑄0 must be determined before the participants send
their transactions, otherwise they do not know where to send their
funds. But once 𝑄0 is computed everyone who participated in the
DKG knows a share of the secret regardless of whether they send
some funds to it. We thus need to make sure that participants are in-
centivized to contribute to the fees. One way to do so is to have each
participant who sent some funds to 𝑄0 in the Bitcoin blockchain be
rewarded, in exchange, with some PoS coins. Verifying the validity
of Bitcoin transactions is, however, not trivial. Verifying the signa-
ture only is not enough as the transaction could be double spending.
Hence, additional data is required by a verifier. More specifically, a
verifier would need to verify that the transaction is included in the
Bitcoin blockchain at least 𝑘 blocks deep - where 𝑘 is a parameter
corresponding to Bitcoin’s settlement time. With this in mind, we
propose the following protocol.

We consider the following parameters: a deadline ℎ0 (represented
as a height in the Bitcoin blockchain); the settlement time 𝑘 after
which a block is considered "finalized" in the Bitcoin blockchain (e.g.
6 blocks); release expressed as a height in the Bitcoin blockchain
chain, chosen conservatively high.

(1) Each participant 𝑃𝑖 in 𝐶0 submit a commitment to their Bit-
coin public key 𝑏𝑡𝑐.𝑝𝑘𝑖 (e.g. a hash 𝐻1 (𝑏𝑡𝑐.𝑝𝑘𝑖 )) to the PoS
chain. This is to prevent participants from later on "stealing"
each other rewards by pretending to have sent some bitcoins
that someone else sent.

(2) Configuration 𝐶0 interactively performs the DKG to create
the key 𝑝𝑘0. Each participant in 𝐶0 holds a share of the secret
key associated. The key is then tweaked with a commitment
to the PoS genesis block to give 𝑄0.

(3) Each participant 𝑃𝑖 in 𝐶0 send a small amout fee from 𝑏𝑡𝑐.𝑝𝑘𝑖
to 𝑄0. This transaction should be sent several heights before
height ℎ0. They add a timelock [6] such that if the output
is not spent after release blocks, 𝑃𝑖 gains control of their
bitcoins back. We denote this transaction 𝑖𝑛𝑖𝑡 .𝑡𝑥𝑖 .

(4) Once the Bitcoin chain has reached height at least ℎ0 + 𝑘 the
participants can start the interactive signing. They create the
transaction by spending all the UTXOs that were received by
𝑄0 before block ℎ0 (this ensures that everyone will sign the
same transaction). We note tx0 this transaction. Every trans-
action 𝑖𝑛𝑖𝑡 .𝑡𝑥𝑖 not included in the initial transaction tx0 (e.g.
because it was included too late in the bitcoin blockchain)
can be sent back to its original sender due to the timelock.

(5) If 𝑖𝑛𝑖𝑡 .𝑡𝑥𝑖 was included in the inputs of tx0, 𝑃𝑖 can submit
evidence of this in the Filecoin chain using tx0 (i.e. everyone
can verify that 𝑖𝑛𝑖𝑡 .𝑡𝑥𝑖 is in the list of input of tx0 and that the
signature is correct). Since no adversary can forge a signature
from 𝑄0, due to the security of the threshold signing scheme,
no proof can be forged for 𝑖𝑛𝑖𝑡 .𝑡𝑥𝑖 inclusion in tx0.

(6) If 𝑖𝑛𝑖𝑡 .𝑡𝑥𝑖 was not included in the inputs of tx0, then 𝑃𝑖 does

not get any reward.

(7) Every PoS miner verifies that 𝑖𝑛𝑖𝑡 .𝑡𝑥𝑖 was indeed included
in tx0 (as described above), then verifies that 𝑏𝑡𝑐.𝑝𝑘𝑖 indeed
belongs to 𝑃𝑖 . If both checks pass, 𝑃𝑖 is awarded an amount
of PoS coins proportional to the amount sent by 𝑖𝑛𝑖𝑡 .𝑡𝑥𝑖 .
This amount should be high enough to not only compensate
the fee paid by 𝑃𝑖 but also incentivized them to sent the fee
(i.e., the reward must be higher than the fee, although it is
not trivial to compare the value of two cryptocurrencies,
these values can be chosen conservatively). The reward can
be taken from the coins minted, as is usually the case in
crypto-currencies reward scheme.

For every checkpointing transaction on the Bitcoin blockchain,
we use a constant fee btc.fee chosen high enough to tolerate po-
tential congestion period in the Bitcoin blockchain. As a reminder,
thanks to the Taproot update, the size of the transaction in our
protocol is constant in the number of participant hence choosing a
constant transaction fee is enough for our purpose, although we
may end up over-paying during non-congested periods. We also
remark that our protocol is assumed to be run at a relatively low
pace (e.g., once a day) hence we can tolerate longer delays in hav-
ing the checkpointing transaction included in the Bitcoin chain in
periods of short-term congestion. For reference , as of May 2022,
the cost of a checkpointing transaction on Bitcoin mainnet would
be around $0.07 (around 200 sats).

When the funds from the initial transaction run out, a protocol

as the one described above can be used to refill them.

4.3 Verification
Once the protocol described in Figure 4 has been run by the partic-
ipants, users of the PoS system who went offline for an extended
period of time can use the Bitcoin blockchain to determine the
correct configuration and state of the chain. Informally, the verifi-
cation protocol works as follows: users, who are aware of the initial
aggregated public key 𝑄0, which serves as an identifier of the PoS
blockchain on the Bitcoin blockchain, can follow the chain of trans-
actions from 𝑄0 to the newest public key 𝑄𝑖 . The latest transaction
in the chain (i.e., from 𝑄𝑖−1 to 𝑄𝑖 ) contains an additional output that
corresponds to the content identifier of the configuration 𝐶𝑖 . The
user can then use this identifier to retrieve the configuration using
IPFS (or another content-addressable decentralized storage, e.g.,
one implemented on top of the PoS chain). The high-level protocol
is described below and the pseudocode is given in Algorithm 4.

(1) Synchronize with the Bitcoin blockchain (e.g., by running a

Bitcoin full node.2)

(2) Look for 𝑄0 and follow the chain of transactions to get tx𝑖

and 𝑐𝑖𝑑𝑖 , i.e.,

2Bitcoin full nodes can be run on relatively cheap hardware, e.g., Raspberry Pi and
1TB disk, in a setup that costs less than $200 USD.

Pikachu: Securing PoS Blockchains from Long-Range Attacks by Checkpointing into Bitcoin PoW using Taproot

ConsensusDay ’22, November 7, 2022, Los Angeles, CA, USA

We assume that the initial aggregated public key of participants (at genesis) 𝑝𝑘0 as well as their tweaked key 𝑄0 are trusted and known by everyone and that
it was funded as specified in Section 4.2 such that there are enough bitcoins to pay for the transaction fees of several transactions. For each round 𝑖 > 0:

1 The protocol starts after a threshold of new registrations and unregistrations has been monitored (e.g., since the last configuration, 𝑖, there has
been 𝑢 new registrations or unregistrations). We call this event 𝑈𝑖+1. We note 𝑋𝑖+1 the height, in the PoS blockchain, corresponding to this event.
As soon as the parties notice event 𝑈𝑖+1, they start the distributed key generation algorithm defined in Figure 5. This algorithm is performed by
members of the new configuration, 𝐶𝑖+1 in order to compute the new aggregated key 𝑝𝑘𝑖+1. We denote 𝑆𝑖+1,0 the set of members in the new
reconfiguration (i.e., reconfiguration 𝑖). (Every member knows who is part of the new configuration by property of the underlying PoS, using
the power table). At the end of the algorithm, the aggregated public key 𝑝𝑘𝑖+1 is known by everyone and a message can be signed by 𝑡𝑖+1 out
(𝑡𝑖+1,𝑛𝑖+1 )
of 𝑛𝑖+1 of the participants using their secret share 𝑠𝑖+1,𝑗 : (𝑠𝑖+1,1, · · · , 𝑠𝑖+1,𝑛)
←−−−−−−−→ (𝑠𝑘𝑖+1, 𝑝𝑘𝑖+1, 𝑎𝑖+1𝑘𝐺, 𝑆𝑖+1,1), 𝑘 ∈ {1, · · · , 𝑡𝑖+1 − 1}. Here
𝑆𝑖+1,1 = 𝑆𝑖+1,0 \ {misbehaving participants from the protocol}.
We assume that the DKG is finished by block 𝑋𝑖+1 + 𝑌 where 𝑌 is chosen conservatively. The tweaked public key of the taproot address is then defined
to be 𝑄𝑖+1 = 𝑝𝑘𝑖+1 + 𝐻𝑇 𝑎𝑝𝑇 𝑤𝑒𝑎𝑘 (𝑝𝑘𝑖+1 | |ckpt)𝐺, where ckpt is the hash of the PoS block at height 𝑋𝑖+1.

2 Optional: Remove the misbehaving party from the power table.
3 Signing protocol. Every participant 𝑃 𝑗 of configuration 𝐶𝑖 does the following:
(a) 𝑃 𝑗 checks that the previous reconfiguration transaction tx𝑖−1 (according to the PoS blockchain) is included in the bitcoin blockchain. If not, they

submit it before forming the new transaction.

(b) 𝑃 𝑗 first publishes the list of members in the new configuration 𝐶𝑖+1 to the decentralized storage and retrieves the corresponding content identifiers

𝑐𝑖𝑑𝑖+1.

(c) 𝑃 𝑗 computes transaction tx𝑖 as follows. All of the coins associated with 𝑄𝑖 are transferred to 𝑄𝑖+1 and another output that receives no coins but
contains an 𝑂𝑃 _𝑅𝐸𝑇𝑈 𝑅𝑁 that contains 𝑐𝑖𝑑𝑖+1 is added: tx𝑖 : 𝑄𝑖 → ( (amt, 𝑄𝑖+1), (0, 𝑂𝑃 _𝑅𝐸𝑇𝑈 𝑅𝑁 = 𝑐𝑖𝑑𝑖+1)) where amount is the amount
associated with 𝑄𝑖 minus transaction fees.

(d) The members of the current configuration 𝐶𝑖 (i.e. associated with 𝑝𝑘𝑖 ) perform the interactive signing algorithm.

(i) Set 𝑚 ← 0.
(ii) (𝑜, 𝑆𝑖,𝑚+1) ← SchnorrThresholdSign(𝑆𝑖,𝑚, tx𝑖, 𝑝𝑘𝑖, 𝑄𝑖 ) defined in Figure 6 where 𝑆𝑖,𝑚+1 is the set of non-misbehaving parties during the

execution of the protocol.

(iii) If 𝑜 = (𝑧, 𝑅), i.e., a signature has been successfully produced, continue to step 4.
(iv) Else (i.e., 𝑜 = abort) set 𝑚 = 𝑚 + 1 and go to step 3(d)ii.

4 The taproot signature is then computed as (𝑧′, 𝑅) ← (𝑧 + 𝐻 (tx𝑖 | |𝑅 | |𝑄𝑖 )𝐻 (𝑝𝑘𝑖 | |ckpt), 𝑅), where 𝑐 is the hash of the PoS blockchain at height 𝑋𝑖 .
5 𝑃 𝑗 sends tx𝑖 to the Bitcoin blockchain to update the configuration.
6 Participants set 𝑖 ← 𝑖 + 1 and go back to step 1.

Each participant 𝑃𝑖 performs the following steps, where 𝑡 is a parameter and 𝑛 is the total number of participants:

Figure 4: Main Algorithm

(1) Choose 𝑟𝑖

$
←− Z∗
privately to 𝑃 𝑗 .

𝑞. Let the sharing polynomial be 𝑓𝑖 (𝑢) = (cid:205)𝑡 −1
𝑘=0

𝑎𝑖𝑘𝑢𝑘 where 𝑎𝑖0 = 𝑟𝑖 . Compute 𝑠 𝑗

𝑖 = 𝑓𝑖 ( 𝑗) mod 𝑞 for each 𝑗 ∈ {1, . . . 𝑛 } and send 𝑠 𝑗

𝑖

(2) Expose 𝑌𝑖 = 𝑟𝑖𝐺 as follows. Broadcast 𝐴𝑖𝑘 = 𝑎𝑖𝑘𝐺 for 𝑘 ∈ {0, · · · , 𝑡 − 1}.
(3) Verify the values broadcast by other players: 𝑓𝑗 (𝑖)𝐺 ?= (cid:205)𝑡 −1
𝑘=0
(4) Answer each complaint from party 𝑃 𝑗 against 𝑃𝑖 (if any) by broadcasting 𝑠 𝑗
𝑖 .
(5) If any of the revealed shares fails this equation, remove that participant from the set of players 𝐻0.
𝑟 𝑗𝐺, of which each player’s share of the secret is 𝑠𝑖 = (cid:205)𝑗 ∈𝑆0
(6) Extract 𝑌 = (cid:205)𝑗 ∈𝑆0

𝑠𝑖
𝑗 . The secret 𝑟 = (cid:205)𝑗 ∈𝑆0

𝑖𝑘𝐴𝑗𝑘 . If the check fails for an index 𝑗, complain against 𝑃 𝑗 .

𝑟 𝑗 mod 𝑞 is never computed.

The corresponding aggregated private and public keys are (𝑟, 𝑌 ), denoted by

(𝑠1, · · · , 𝑠𝑛)

(𝑡,𝑛)
←−−−→ (𝑟, 𝑌 , 𝑎𝑘𝐺, 𝑆0), 𝑘 ∈ {1, · · · , 𝑡 − 1}

Figure 5: Distributed Key Generation Algorithm (JF-DKG by Gennaro et al. [17])

(a) Inspect the transactions going out from 𝑄0
(b) If there are multiple transactions going out from 𝑄0, look
for the initial funding transaction by inspecting the UTXOs
spent and verifying that all of them are included in blocks
with height lower than ℎ0.

(c) Once the initial transaction tx0 has been found, look for
the transaction that spent tx0 (i.e. where tx0 is an input).
(d) For 𝑖 ≥ 0 get tx𝑖+1 by looking for the transaction that

spent tx𝑖 .

(e) Stop when tx𝑖 is unspent and get 𝑐𝑖𝑑𝑖 from the 𝑂𝑃_𝑅𝐸𝑇𝑈 𝑅𝑁

field.

(3) Use 𝑐𝑖𝑑𝑖 to get the list of current nodes from the external

storage chosen.

(4) Request the PoS blockchain state from these nodes.
(5) Verify that the aggregated public key on the PoS blockchain
𝑝𝑘 and the hash of the block ckpt are in accordance with the
Bitcoin Taproot address 𝑄 that is the output of tx𝑖 .

ConsensusDay ’22, November 7, 2022, Los Angeles, CA, USA

Sarah Azouvi and Marko Vukolić

(6) If the checkpoint and aggregated key do not match the Bit-
coin checkpoint, roll back the PoS chain until the previous
checkpoint and go back to step 5.

5 SECURITY ARGUMENT
In this section we present the arguments for why our protocol is
secure. We need to prove two things: (1) that any checkpoint pushed
onto the Bitcoin blockchain is correct, i.e., that it corresponds to
the valid state of the PoS (according to honest online validators);
(2) that checkpoints will be pushed regularly. These two properties
correspond, loosely, to the safety and liveness properties of our
scheme.

5.1 Safety
We consider the following statement, which we prove by induction,
for 𝑘 ∈ N: An adversary as defined in Section 3 cannot create any
incorrect checkpointing transaction tx𝐴
for any 0 ≤ 𝑖 ≤ 𝑘 such that
𝑖
tx𝐴
𝑖 will be accepted by an honest verifier that follows the verification
algorithm as defined in Section 4.3. An incorrect checkpoint trans-
action is a transaction that contains a commitment to an incorrect
chain (i.e., a chain created as part of a LRA).

Base Case. First, we show that the adversary cannot create an
alternative initial transaction tx0. At the time where the initial
transaction is created, the adversary controls at most 𝑡0 participants
(assumption 2) and hence, by security of the DKG and signing
algorithms, cannot unilaterally sign a transaction coming from 𝑄0.
After 𝐿 configurations, the adversary do obtain all the keys from
𝐶0 and is able to create transaction coming out from this address,
however, this happens after height ℎ0 on the Bitcoin blockchain by
assumption 3 and hence any transaction sent by the adversary from
𝑄0 will not be accepted by any verifier according to our verification
algorithm presented in Section 4.3 step 2b. Hence the adversary
cannot create an initial checkpoint transaction that will be accepted
by any verifier.

, . . . , tx𝐴

Induction step. Let’s assume that our statement is true for 𝑘 − 1,
i.e., the adversary cannot create any incorrect checkpointing trans-
action up to 𝑘 − 1 (i.e., tx𝐴
𝑘−1). We show that our statement
0
is then also true for 𝑘. It is enough to show that the adversary
cannot create any incorrect checkpointing transaction tx𝐴
𝑘 . Let’s
denote 𝑖 the current configuration number (i.e., according to online
validators). There are two cases to consider. The first case is the case
where 𝑘 < 𝑖 −𝐿. Then by assumptions the adversary has all the keys
associated with 𝑄𝑘 (assumption 1) and a transaction tx𝑘 that spent
tx𝑘−1 has already been included in the blockchain (assumption 3).
Because tx𝑘−1 has already been spent, tx𝐴
𝑘 cannot include tx𝑘−1 in
its inputs (as an input can only be spent once according to Bitcoin’s
rules). Moreover by induction assumption there is no other transac-
tion tx𝐴
𝑘 that the adversary could
create that would be accepted by any verifier. Hence, according to
our verification algorithm step 2d tx𝐴
𝑘 will not be accepted by any
verifier.

𝑘−1 to be included as an input to tx𝐴

The second case is the case where 𝑘 ≥ 𝑖 − 𝐿. In this scenario, it
could be the case that transaction tx𝑘−1 is still unspent. By design
the only spendable outputs of tx𝑘−1 is 𝑄𝑘 . However, according to
assumption 2, the adversary only holds a fraction 𝑓 of configuration

𝑘 and hence cannot create a transaction that is spent by 𝑄𝑘 and
cannot spent transaction tx𝑘−1.

5.2 Liveness
The reasons why an adversary cannot stop the signing from going
ahead and the checkpoints from happening are as follows. (1) The
robustness of the DKG ensures that an adversary cannot stop the
rest of the players from computing an aggregated public key. (2)
The adversary could delay the signing process by aborting; how-
ever, aborting or misbehaving players will be detected and excluded
from the signing in the next iteration. (3) The assumption about
the stability across configurations ensures that enough honest par-
ticipants will be able to perform the signing, i.e., we assume that
enough participants from each configuration will remain available
in the system long enough to sign and give the signer power to the
next configuration.

6 IMPLEMENTATION AND EVALUATION
We implement the protocol from Section 4 using the Go Program-
ming Language. For the underlying PoS chain, we forked the open-
source Eudico framework,3 developed by Protocol Labs, that pro-
vides a delegated Proof-of-stake consensus protocol option. We
used a simplified version of this, where only one PoS miners creates
blocks, as this does not impact our experiments. We used an open-
source library developed by the Taurus group4 for the DKG and
signing, that we adapted for our needs and used both Bitcoin regtest
and testnet for our experiments. For storing the data associated
with each configuration, we implemented a key-value database,
maintained by the PoS validators on top of the PoS chain.

The code is open source.5 We run the experiments on a single
virtual machine (32 GB RAM, 8 vCPUs, 640 GB SSD) on Amazon
Lightsail using a Kubernetes deployment.

We implemented the verification process, however we did not
include any metrics in this paper as this was tested only on the
Bitcoin Testnet and may not be representative of the mainnet.

We measure the execution times of the DKG and the signing
protocol in Figure 8. We only included the case where everyone
cooperates in our graphs as in the case of failures our protocol
relies on a timeout (to detect aborts) hence the execution time
of the protocol with failures is constant and only depends on the
timeout chosen. We included the graphs of the execution time in the
event of failures in the Appendix for reference.While the number
of validators in a PoS protocol varies depending on a particular
blockchain system, we show results with up to 21 validators, which
corresponds to the number of validators in a delegated PoS such
as EOSIO [23], where 21 validators are elected on a rotating basis
to run the consensus protocol. In Figure 8, we plot the confidence
interval of the execution time of the DKG and signing protocol
sampled over all the participating nodes and repeated a dozen
times.

We notice in our graph that the signing scales better than the
DKG as it increases from less than 0.1 second with 3 participants
to around 0.6 second with 21 participants whereas the DKG goes

3https://github.com/filecoin-project/eudico
4https://github.com/taurusgroup/multi-party-sig
5https://github.com/filecoin-project/eudico/tree/B2-bitcoin-checkpointing

Pikachu: Securing PoS Blockchains from Long-Range Attacks by Checkpointing into Bitcoin PoW using Taproot

ConsensusDay ’22, November 7, 2022, Los Angeles, CA, USA

SchnorrThresholdSign(𝐻, 𝑚, 𝑌 , 𝑄)
Input: 𝐻 is the set of players, 𝑚 the message.
Y is the aggregated public key. Each participant 𝑃𝑖 holds a share of the associated secret key 𝑠𝑖 . 𝑌𝑖 is the public verification share of each participant and is
computed as 𝑌𝑖 = (cid:205)𝑗 ∈𝑆0
Parameter: timeOut.
PreProcess: Each participant 𝑃𝑖 performs the following steps. 𝜋 is a parameter corresponding to the number of signing operations that can be performed
before doing another pre-process step.

𝑖𝑘𝐴𝑗𝑘 We note 𝑄 the tweaked key as defined in step 1 of Figure 4.

(cid:205)𝑡 −1
𝑘=0

(1) Create an empty list 𝐿𝑖 . For 1 ≤ 𝑗 ≤ 𝜋 do:
(a) Sample single-use nonces (𝑑𝑖 𝑗 , 𝑒𝑖 𝑗 )
(b) Derive commitment shares (𝐷𝑖 𝑗 , 𝐸𝑖 𝑗 ) = (𝑑𝑖 𝑗𝐺, 𝑒𝑖 𝑗𝐺).
(c) Append (𝐷𝑖 𝑗 , 𝐸𝑖 𝑗 ) to 𝐿𝑖 . Store ( (𝑑𝑖 𝑗 , 𝐷𝑖 𝑗 ), (𝑒𝑖 𝑗 , 𝐸𝑖 𝑗 )) for later use in signing operations.

𝑞 × Z∗
𝑞.

$
←− Z∗

(2) Publish (𝑖, 𝐿𝑖 ) to the PoS blockchain.

Sign(𝑚)
Each participant 𝑃𝑖 does the following:

(1) Compute S, the set of 𝑡 participants for signing using RB𝑖 as follows:

(a) Compute 𝐻 (𝑖𝑑 | |RB).
(b) The smallest 𝑡 hashes are the id selected for signing.

(2) Fetch the next available commitment for each participant 𝑃𝑖 ∈ 𝑆 from 𝐿𝑖 and construct 𝐵 = ⟨(𝑖, 𝐷𝑖, 𝐸𝑖 ) ⟩𝑖∈𝑆 .
(3) Compute the set of binding values 𝜌𝑙 = 𝐻1 (𝑙, 𝑚, 𝐵), 𝑙 ∈ 𝑆 and derives the group commitment 𝑅 = (cid:205)𝑙 ∈𝑆 (𝐷𝑙 +𝜌𝑙 𝐸𝑙 ) and the challenge 𝑐 = 𝐻2 (𝑚 | |𝑅 | |𝑄).
(4) Each 𝑃𝑖 ∈ 𝑆 computes their response using their secret share 𝑠𝑖 by computing 𝑧𝑖 = 𝑑𝑖 + (𝑒𝑖 · 𝜌𝑖 ) + 𝜆𝑖 · 𝑠𝑖 · 𝑐 using 𝑆 to determine the 𝑖𝑡ℎ Lagrange

coefficient 𝜆𝑖 as follows: if 𝑆 = {𝑃𝑖1 · · · , 𝑃𝑖𝑡 } represents the participants identifiers then 𝜆𝑖 = (cid:206)𝑗 ∈{𝑖1,...,𝑖𝑡 },𝑗 ≠𝑖

(5) Each 𝑃𝑖 securely deletes (𝑑𝑖, 𝑒𝑖 ) from their local storage and then post 𝑧𝑖 to the PoS chain.
(6) After all the shares from participants in S are included in the PoS chain, each participant performs the following steps:

𝑃 𝑗
𝑃 𝑗 −𝑃𝑖 .

(a) Derive 𝑅 = (cid:205)𝑖∈𝑆 𝑅𝑖 and 𝑐 = 𝐻2 (𝑚 | |𝑅 | |𝑄).
(b) Verify that 𝑧𝑖𝐺 ?= 𝑅𝑖 + (𝑐 · 𝜆𝑖 ) · 𝑌𝑖 for each signing share 𝑧𝑖, 𝑖 ∈ 𝑆.

If it fails, report the misbehaving participant(s) by publishing a message on the PoS blockchain with the proof of misbehaviour(s) (i.e., 𝑧𝑖𝐺 and
𝑅𝑖 + (𝑐 · 𝜆𝑖 )𝑌𝑖 for each cheating player) and abort.
(c) If no participants was misbehaving, compute 𝑧 = (cid:205)𝑖∈𝑆 𝑧𝑖 .
(d) Compute 𝜎 = (𝑧, 𝑅) to the PoS blockchain.

(7) If after timeOut blocks since the begining of the protocol, some shares have not been posted to the PoS chain, abort the protocol and add the

corresponding participants in the list of misbehaving players.

Output: (𝜎, 𝐻 ) if the protocol completed, (abort, 𝑆′) else, where 𝑆′ is the set of players who have not misbehaved during the execution of the protocol.

Figure 6: Signing Algorithm

up to above 2.5 seconds with 21 participants. This is expected as
the signing only requires 2 broadcast messages per participants
(the pre-process and the share of the signature) whereas the DKG
requires private messages between every participants as well as
broadcast messages.

7 RELATED WORK
LRA have long been studied in the field of PoS and other types of
checkpointing have been proposed that either rely on some sort
of central authority [20] or on additional assumptions [1]. Like
the solution from Steinhoff et al. [30], this paper offers a fully
decentralized solution without additional security assumptions (as
in [1]) other than the ones needed for the security of the underlying
PoS.

Kuznetsov and Tolkih propose an alternative solution to address-
ing long-range attacks in BFT/PoS [22], using forward-secure digital
signatures. However, this solution is inapplicable in the rational ad-
versary model, in which rational nodes might simply not follow the
assumptions of forward-secure digital signatures, retaining their
old private keys to mount attacks in the future.

Babylon [32] was proposed concurrently to our work and is a
defense against LRA that is also based on leveraging the security

guarantees provided from Bitcoin’s Proof-of-work. In this work,
every PoS miner can post a checkpointing transaction into the Bit-
coin blockchain which then acts as a timestamping mechanism and
thus thwarts LRA. Whenever a block is mined on the PoS chain,
PoS validators can submit a commitment for this block, and this
commitment is included in the Bitcoin PoW chain. In the case of
two conflicting blocks in the PoS chain, the one whose commitment
was submitted first in the Bitcoin chain is chosen by the fork-choice
rule. Babylon goes further and also protects the underlying PoS
chain against super-majority and censorship attacks. Their scheme
is more scalable than Pikachu, as it does not require any additional
threshold signing. On the other hand, since the checkpointing trans-
actions on the Bitcoin blockchain are not linked together, as is the
case in Pikachu, the verification algorithm is much less efficient
as one would need to search exhaustively through all the Bitcoin
transactions to find all the possible PoS checkpoints and ensure
that they have the correct PoS chain.

Lastly, on the topic of Stake-based Threshold Multisignatures,
Mithril [8] and Dfinity [19] both propose scalable and efficient
schemes that are however not compatible with Bitcoin and could
thus not be used in the context of checkpointing onto Bitcoin.

ConsensusDay ’22, November 7, 2022, Los Angeles, CA, USA

Sarah Azouvi and Marko Vukolić

Algorithm 1 Main algorithm

import PoS
import PoS.PowerTable as PT
import BTC
import PrivateMessage as PM
import IPFS
import Signing Algorithm (Algorithm 3), Distributed Key Generation Algorithm (Algorithm 2)

Init:

if 𝑟𝑒𝑞 = ⟨𝑝, “𝑗𝑜𝑖𝑛”⟩ then

𝐶𝑐𝑢𝑟 ← 𝐶0
𝐶𝑙𝑎𝑠𝑡 ← 𝐶0
𝑝𝑘𝑐𝑢𝑟 ← 𝑝𝑘0
CurrentShares ← empty dictionary
𝑆0 ← 𝐶𝑐𝑢𝑟
misbehavingPlayers ← ∅
𝑖 ← 𝐶𝑐𝑢𝑟 .𝑚𝑒𝑚𝑏𝑒𝑟𝑠 [𝑖𝑑 ].𝑔𝑒𝑡𝐼𝑛𝑑𝑒𝑥 ()
tx𝑙𝑎𝑠𝑡 ← tx0

1:
2:
3:
4:
5:
6:
7: Parameters:
𝑖𝑑
8:
𝑢
9:
10:
f
𝑌
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21: upon event receiving 𝑃𝑇 .update(𝑟𝑒𝑞) ∧ 𝐶𝑙𝑎𝑠𝑡 △𝐶𝑐𝑢𝑟 < 𝑢 do
22:
23:
24:
25:
26: upon event 𝐶𝑙𝑎𝑠𝑡 △𝐶𝑐𝑢𝑟 ≥ 𝑢
27:
28:
29: upon event PoS.CurrentHeight == PoS.Height(X)+Y do
30:
31:
32:
33:
34:
35:
36:
37:
38:
39:
40:
41:
42:
43:
44:

𝑆0 ← 𝐶𝑐𝑢𝑟 .𝑔𝑒𝑡𝐼𝑛𝑑𝑒𝑥𝑒𝑠 ()\misbehavingPlayers
𝑝𝑘𝑛𝑒𝑤 ← (cid:205)𝑗 ∈𝑆0
𝑠𝑖
𝑠𝑖 ← (cid:205)𝑗 ∈𝑆0
𝑗
ckpt ← 𝑃𝑜𝑆.𝐵𝑙𝑜𝑐𝑘ℎ𝑎𝑠ℎ (𝑋 )
𝑞 ← 𝑝𝑘𝑛𝑒𝑤 + 𝐻𝑇 𝑎𝑝𝑇 𝑤𝑒𝑎𝑘 (𝑝𝑘𝑛𝑒𝑤 | |ckpt)𝐺
𝑜 ← 0
if BTC.latestCheckpoint.UTXO ≠ tx𝑙𝑎𝑠𝑡 then

IPFS.push(𝐶𝑐𝑢𝑟 )
𝑐𝑖𝑑 ← 𝐼 𝑃 𝐹𝑆.𝑔𝑒𝑡𝐶𝑖𝑑 (𝐶𝑐𝑢𝑟 )
if 𝑖𝑑 ∈ 𝐶𝑙𝑎𝑠𝑡 then
do Algorithm 3
𝐶𝑙𝑎𝑠𝑡 ← 𝐶𝑐𝑢𝑟
𝑝𝑘𝑐𝑢𝑟 ← 𝑞
CurrentShares ← ∅

𝑋 ← PoS.CurrentBlock()
Do Algorithm 2 (DKG)

𝐶𝑐𝑢𝑟 .𝑚𝑒𝑚𝑏𝑒𝑟𝑠 ← 𝐶𝑐𝑢𝑟 .𝑚𝑒𝑚𝑏𝑒𝑟𝑠 ∪ {𝑝 }

𝐶𝑐𝑢𝑟 .𝑚𝑒𝑚𝑏𝑒𝑟𝑠 ← 𝐶𝑐𝑢𝑟 .𝑚𝑒𝑚𝑏𝑒𝑟𝑠 \ {𝑝 }

if 𝑟𝑒𝑞 = ⟨𝑝, “𝑙𝑒𝑎𝑣𝑒”⟩ then

BTC.Broadcast(tx𝑙𝑎𝑠𝑡 )

CurrentShares[ 𝑗 ]

⊲ The node id
⊲ Tolerated difference between local configuration and current configuration
⊲ Fault tolerance of the current configuration
⊲ Number of blocks to wait for the DKG to complete

⊲ Current configuration
⊲ Last configuration
⊲ Initial public key
⊲ Share of the aggregated public key
⊲ Non-misbehaving participants
⊲ Set of misbehaving participants in the DKG
⊲ Node’s index
⊲ Initial transaction as defined in Section 4.2
⊲ Configuration request received

⊲ After 𝑢 (un)registrations do

⊲ Give enough time for the DKG to complete
⊲ set of indexes of non-cheating players in the DKG
⊲ Compute the aggregated key
⊲ Compute the share of the secret key

⊲ Taproot address
⊲ Counter for the pre-process step
⊲ Check the Bitcoin blockchain for the previous checkpointing transaction
⊲ Send latest checkpoint

⊲ Members associated with 𝑝𝑘𝑐𝑢𝑟 sign tx
⊲ Signing protocol with other members

(a) DKG with every participants honest.

(b) Signing with every participants honest.

Figure 7: Execution time of our DKG and Signing Implementation. Each vertical bar represent the confidence interval of the
execution time as seen by each different node.

3579111315171921Number of participants0.00.51.01.52.02.5Seconds3579111315171921Number of participants0.10.20.30.40.50.6SecondsPikachu: Securing PoS Blockchains from Long-Range Attacks by Checkpointing into Bitcoin PoW using Taproot

ConsensusDay ’22, November 7, 2022, Los Angeles, CA, USA

Algorithm 2 Distributed Key Generation

import MainAlgorithm

1:
2: Parameters:
3:
4:
5:

𝑡 ← 0.5|𝐶𝑐𝑢𝑟 | + 1

if 𝑖𝑑 ∈ 𝐶𝑐𝑢𝑟 then
Timeout.Start()
$
←− Z𝑞 ; 𝑎𝑖0 ← 𝑟𝑖
𝑟𝑖
for 𝑘 ∈ {1, . . . , 𝑡 − 1} do

6:
7:

𝑎𝑖𝑘

Timeout.Restart()

if ( ⟨SHARE, 𝑠𝑖

𝑗 ⟩) 𝑗 == nil then

if id∈ 𝐶𝑐𝑢𝑟 then

PM( ⟨SHARE, 𝑠 𝑗

𝑗 ⟩𝑗 received for all 𝑗 do

misbehavingPlayers.append( 𝑗)

for 𝑗 ∈ {1, . . . , |𝐶𝑐𝑢𝑟 .𝑚𝑒𝑚𝑏𝑒𝑟𝑠 | } do

𝑖 = 𝑓𝑖 ( 𝑗) ⟩, 𝐶𝑐𝑢𝑟 .𝑚𝑒𝑚𝑏𝑒𝑟𝑠.𝑖𝑛𝑑𝑒𝑥 [ 𝑗 ])

if 𝑗 ∈ {1, . . . , |𝐶𝑐𝑢𝑟 .𝑚𝑒𝑚𝑏𝑒𝑟𝑠 | } and 𝑠 𝑗

$
←− Z𝑞
𝑓𝑖 (𝑢) ← (cid:205)𝑡 −1
𝑎𝑖𝑘𝑢𝑘
𝑘=0
for 𝑗 ∈ {1, . . . , |𝐶𝑐𝑢𝑟 .𝑚𝑒𝑚𝑏𝑒𝑟𝑠 | } do

for 𝑘 ∈ {0, . . . , 𝑡 − 1} do 𝐴𝑖𝑘 ← 𝑎𝑖𝑘𝐺
PoS.Broadcast( ⟨secretCommitments, 𝐴𝑖0, . . . , 𝐴𝑖 (𝑡 −1) ⟩𝑖 )

8:
9:
10:
11:
12:
13:
14:
15: upon event ⟨SHARE, 𝑠𝑖
16:
Timeout.Restart()
17: upon event TimeOut.Done() do
18:
19:
20:
21:
22: upon event PoS.Receive(⟨secretCommitments, 𝐴𝑗 0, . . . , 𝐴𝑗 (𝑡 −1) ⟩𝑗 ) do
23:
24:
25:
26:
27: upon event PoS.Receive(⟨secretCommitments, 𝐴𝑗 0, . . . , 𝐴𝑗 (𝑡 −1) ⟩𝑗 ) for all 𝑗 or Timeout.Done() do
28:
29:
30:
31:
32:
33:
34:
35:
36: upon event PoS.Receive(⟨complaintSecret,v ⟩𝑘 ) do
for 𝑗 ∈ {1, . . . , |𝐶𝑐𝑢𝑟 .𝑚𝑒𝑚𝑏𝑒𝑟𝑠 | do
37:
38:
39:
40: upon event PoS.Receive( ⟨complaintAnswer, proof, 𝑗 ⟩𝑙 ) do
41:
42:

if 𝑗 ∈ misbehavingPlayers then v.append(𝑓𝑗 (𝑖))
else v.append(NoComplaint)
PoS.Broadcast( ⟨complaintSecret, v⟩)
Timeout.Restart()

if v[j]≠ NoComplaint then misbehavingPlayers.append( 𝑗)
if v[i]≠ NoComplaint then PoS.Broadcast( ⟨complaintAnswer, 𝑠𝑖

v = ∅
for 𝑗 ∈ {1, . . . , |𝐶𝑐𝑢𝑟 .𝑚𝑒𝑚𝑏𝑒𝑟𝑠 | do

if PoS.Read( ⟨secretCommitments⟩) 𝑗 == nil then

← 𝑃𝑜𝑆.𝑅𝑒𝑎𝑑 ( ⟨SecretCommitments⟩𝑗 )

CurrentShares.append(𝑗, 𝐴𝑗 0)

misbehavingPlayers.append( 𝑗)

misbehavingPlayers.append(𝑗 )

𝑖 ≠ (cid:205)𝑡 −1
𝑘=0

𝑖𝑘 𝐴𝑗𝑘 then

𝑗 , 𝑖 ⟩)

else

𝑠 𝑗
𝑙 ←Parse(proof)
(𝐴𝑗𝑘 )𝑡 −1
𝑘=0
if 𝑠 𝑗
𝐺 == (cid:205)𝑡 −1
𝑘=0
𝑙
misbehavingPlayers.remove( 𝑗)

𝑙𝑘 𝐴𝑗𝑘 then

43:
44:
45: upon event PoS.Receive( ⟨complaintSecret⟩𝑗 ) for all 𝑗∧ misbehavingPlayers == ∅ do
46:
47: upon event Timeout.Done() do
48:

return

return

⊲ Number of parties controlled by the adversary
⊲ Only member of the new configuration perform the DKG
⊲ We use a timeout to detect aborting players (this can be in terms of blocks in the PoS chain)

⊲ Send share of secret to each player

⊲ All secret shares were received

⊲ Some party did not send their private share
⊲ Add aborting players to list of misbehaving participants

⊲ All commitments were received or timeout expired

⊲ Add aborting players to list of misbehaving participants

⊲ Send a list of (potentially empty) complaints

⊲ Receive other parties’ list of complaints
⊲ Add complaints against 𝑗
⊲ Reply to complaint against self
⊲ 𝑗 can answer a complaint from 𝑙

⊲ Get 𝑗 commitments

⊲ All complaints (and potentially answers) were received
⊲ Finish the protocol
⊲ Leave enough time for answers to be received

8 CONCLUSION
We presented a checkpointing mechanism designed to secure PoS
blockchains by leveraging the security guarantees provided by Bit-
coin’s PoW. Our protocol uses Taproot, allowing for the checkpoints
to be constant in the size of PoS validators and indistinguishable
from any other Taproot’s transaction. We implemented a PoC for
our protocol and measured its efficiency. The main issue of our
approach is that it does not scale well. This is especially true if we
consider a flat model where each unit of power corresponds to a
different public key; we could easily end up dealing with tens of
thousands of keys, even when the number of actual participants
is much smaller, greatly increasing the latency of the protocol. Al-
though some techniques such as sampling [8] or ad-hoc threshold
multi-signature schemes [15] have been proposed to help scale
weighted threshold signature schemes, those techniques are not
currently compatible with Bitcoin’s spending rules.

Another problem left for future work is that of fully incentivis-
ing the participation in the protocol, which we started doing in
Section 4.2.

ACKNOWLEDGMENTS
The authors would like to thank Nicolas Gailly and Rosario Gennaro
for very useful discussions about this paper.

REFERENCES
[1] S. Azouvi, G. Danezis, and V. Nikolaenko. Winkle: Foiling long-range attacks in
proof-of-stake systems. In Proceedings of the 2nd ACM Conference on Advances in
Financial Technologies, pages 189–201, 2020.

[2] M. Bell. Proof-of-stake bitcoin sidechains. https://gist.github.com/mappum/

da11e37f4e90891642a52621594d03f6, June 2021.

[3] Bitcoin. Bips/bip-0341.mediawiki at master · bitcoin/bips, Jul 2021.
[4] Bitcoin. Bips/bip-0341.mediawiki at master · bitcoin/bips, Jul 2021.
[5] Bitcoin Wiki. OP_RETURN. https://en.bitcoin.it/wiki/OP_RETURN, June 2020.
[6] Bitcoin Wiki. Timelock. https://en.bitcoin.it/wiki/Timelock, June 2020.
[7] E. Buchman. Tendermint: Byzantine fault tolerance in the age of blockchains. PhD

thesis, 2016.

ConsensusDay ’22, November 7, 2022, Los Angeles, CA, USA

Sarah Azouvi and Marko Vukolić

Algorithm 3 Signing algorithm

𝑞 × Z∗
𝑞

if 𝑖𝑑 ∈ 𝑆 then

import MainAlgorithm

𝑆′ ← 𝑆′ ∪ (𝐻 (𝑅𝐵 | |𝑖.𝐼 𝐷))

1:
2: Parameters: 𝜋
3: Timeout.start()
4: 𝐿𝑖 ← ∅
5: 𝑣 ← PoS.Height(X)
6: 𝑅𝐵 ← 𝑅𝐵𝑣
7: for 𝑗 ∈ {0, . . . , 𝜋 } do
$
←− Z∗
(𝑑𝑖 𝑗 , 𝑒𝑖 𝑗 )
8:
(𝐷𝑖 𝑗 , 𝐸𝑖 𝑗 ) = (𝑑𝑖 𝑗 𝐺, 𝑒𝑖 𝑗 𝐺)
9:
𝐿𝑖 .𝑎𝑝𝑝𝑒𝑛𝑑 (𝐷𝑖 𝑗 , 𝐸𝑖 𝑗 )
10:
11: PoS.Broadcast( ⟨PreProcess, 𝑖, 𝐿𝑖 ⟩)
12: 𝐵 ← ∅
13: 𝑆′ ← ∅
14: for 𝑖 ∈ 𝐶𝑙𝑎𝑠𝑡 do
15:
16: 𝑆′ ← 𝑜𝑟𝑑𝑒𝑟 (𝑆′)
17: 𝑆 ← 𝑆′ [: 𝑓 |𝐶𝑙𝑎𝑠𝑡 | + 1]
18: for 𝑘 ∈ 𝑆 do
19:
20:
21: for 𝑙 ∈ 𝑆 do
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32:
33:
34:
35:
36:
37:
38:
39:
40:
41:
42:
43:
44:
45:
46:
47:
48:
49:
50:
51:
52:
53:
54:
55:
56:
57:
58:
59:
60:
61:
62:
63:
64:
65:

for 𝑝 ∈ 𝑆 do

else

else

upon event Timeout.done() do

if CheatingPlayers≠ ∅ then

(𝐷𝑘𝑜 , 𝐸𝑘𝑜 ) ←PoS.Read( ⟨PreProcess, 𝑘, 𝐿𝑘 [𝑜 ] ⟩)
𝐵.𝑎𝑝𝑝𝑒𝑛𝑑 ( (𝑘, 𝐷𝑘𝑜 , 𝐸𝑘𝑜 ))

𝑝 𝑗
𝑝 𝑗 −𝑝𝑖 where 𝑝 𝑗 is the identifier of participant 𝑗

tx ← 𝐵𝑇𝐶.𝑇 𝑋 (𝑝𝑘𝑐𝑢𝑟 → (𝑎𝑙𝑙, 𝑞), (0, 𝑂𝑃𝑅𝐸𝑇 𝑈 𝑅𝑁 = 𝑐𝑖𝑑))
𝜌𝑙 ← 𝐻1 (𝑙, tx, 𝐵) for 𝑙 ∈ 𝑆
𝜆𝑖 ← (cid:206)𝑗 ∈𝑆,𝑗 ≠𝑖
𝑅 ← (cid:205)𝑙 ∈𝑆 𝐷𝑙𝑜 + 𝜌𝑙 𝐸𝑙𝑜 , 𝑐 ← 𝐻2 (tx| |𝑅 | |𝑞)
𝑧𝑖 ← 𝑑𝑖𝑜 + (𝑒𝑖𝑜 · 𝜌𝑖 ) + 𝜆𝑖 · 𝑠𝑖 · 𝑐
delete ( (𝑑𝑖𝑜 , 𝐷𝑖𝑜 ), (𝑒𝑖𝑜 , 𝐸𝑖𝑜 )) from local storage
PoS.Broadcast( ⟨SHARE, 𝑧𝑖 ⟩)

upon event PoS.Receive( ⟨SHARE, 𝑧𝑘 ⟩) from all 𝑘 ∈ 𝑆 do

CheatingPlayers← ∅
for 𝑘 ∈ 𝑆 do
(cid:205)𝑡 −1
𝑌𝑘 = (cid:205)𝑗 ∈𝑆0
𝑤=0
𝜌𝑘 ← 𝐻1 (𝑘, tx, 𝐵), 𝑅𝑘 ← 𝐷𝑘𝑜 + 𝜌𝑘 𝐸𝑘𝑜 , 𝑅 ← (cid:205)𝑘 ∈𝑆 𝑅𝑘 , 𝑐 ← 𝐻2 (tx | |𝑅 | |𝑞)
if 𝑔𝑧𝑘 ≠ 𝑅𝑘 + 𝑐 · 𝜆𝑘 · 𝑌𝑘 then
CheatingPlayers.append(𝑘)

𝑘 𝑤𝐴𝑗 𝑤

PoS.Broadcast( ⟨RESTART SIGNING, CheatingPlayers⟩)
restofplayers ← 𝐶𝑐𝑢𝑟 .𝑔𝑒𝑡𝐼𝑛𝑑𝑒𝑥𝑒𝑠 () \ 𝑆
𝑆 ← 𝑆\CheatingPlayers
S.append(restofplayers[:|CheatingPlayers|])
𝑜 ← 𝑜 + 1
Timeout.Restart()
go to line 18

𝑧 ← (cid:205)𝑖∈𝑆 𝑧𝑖
𝑐 ← 𝑃𝑜𝑆.𝐵𝑙𝑜𝑐𝑘ℎ𝑎𝑠ℎ (𝑋 )
𝜎′ ← 𝜎 + 𝐻 (tx | |𝑅 | |𝑞)𝐻 (𝑝𝑘𝑐𝑢𝑟 | |𝑐)
BTC.Broadcast(tx, 𝜎′)
PoS.Broadcast(tx,𝜎′)
return

if PoS.Read( ⟨SHARE⟩𝑝 ) == 𝑛𝑖𝑙 then

CheatingPlayers.append(p)

𝜌𝑘 ← 𝐻1 (𝑘, 𝑚, 𝐵), 𝑅𝑘 ← 𝐷𝑘 𝑗 + 𝜌𝑘 𝐸𝑘 𝑗 , 𝑅 ← (cid:205)𝑘 ∈𝑆 𝑅𝑘 , 𝑐 ← 𝐻2 (tx | |𝑅 | |𝑞)
if 𝑔𝑧𝑘 ≠ 𝑅𝑘 + 𝑐 · 𝜆𝑘 · 𝑌𝑘 then
CheatingPlayers.append(p)

PoS.Broadcast( ⟨RESTART SIGNING, CheatingPlayers⟩)
restofplayers ← 𝐶𝑐𝑢𝑟 .𝑔𝑒𝑡𝐼𝑛𝑑𝑒𝑥𝑒𝑠 \ 𝑆
𝑆 ← 𝑆\CheatingPlayers
S.append(restofplayers[:|CheatingPlayers|])
𝑜 ← 𝑜 + 1
go to line 18

⊲ Number of pre-process steps

⊲ Pseudo-randomly choose set of signers

⊲ Choose t+1 participants for signing

⊲ Compute the transaction

⊲ All shares were received

⊲ add as many players as were removed

⊲ Commitment to the blockchain
⊲ compute taproot signature

⊲ We implement a timeout to deal with aborting participants

⊲ p hasn’t submitted its share

⊲ add as many players as were removed

[8] P. Chaidos and A. Kiayias. Mithril: Stake-based threshold multisignatures. Cryp-

tology ePrint Archive, 2021.

[9] E. Deirmentzoglou, G. Papakyriakopoulos, and C. Patsakis. A survey on long-
range attacks for proof of stake protocols. IEEE Access, 7:28712–28725, 2019.
[10] M. Drijvers, K. Edalatnejad, B. Ford, E. Kiltz, J. Loss, G. Neven, and I. Stepanovs.
In 2019 IEEE Symposium on

On the security of two-round multi-signatures.
Security and Privacy (SP), pages 1084–1101. IEEE, 2019.

[11] Ethereum Foundation. Proof-of-stake (PoS). https://ethereum.org/en/developers/

docs/consensus-mechanisms/pos/, July 2021.

[12] P. Feldman. A practical scheme for non-interactive verifiable secret sharing. In
28th Annual Symposium on Foundations of Computer Science (sfcs 1987), pages
427–438. IEEE, 1987.

[13] Filecoin. Filecoin. https://spec.filecoin.io/, November 2021.
[14] J. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis
and applications. In Annual international conference on the theory and applications
of cryptographic techniques, pages 281–310. Springer, 2015.
[15] P. Gaži, A. Kiayias, and D. Zindros. Proof-of-stake sidechains.

In 2019 IEEE

Symposium on Security and Privacy (SP), pages 139–156. IEEE, 2019.

[16] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin. Secure distributed key genera-
tion for discrete-log based cryptosystems. In Proceedings of the 17th International
Conference on the Theory and Applications of Cryptographic Techniques, pages
295–310. Springer, 1999.

[17] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin. Secure distributed key gener-
ation for discrete-log based cryptosystems. Journal of Cryptology, 20(1):51–83,

Pikachu: Securing PoS Blockchains from Long-Range Attacks by Checkpointing into Bitcoin PoW using Taproot

ConsensusDay ’22, November 7, 2022, Los Angeles, CA, USA

Algorithm 4 Verification

tx0 ← BTC.output(𝑝𝑘0)
𝑖 ← 0

output←BTC.getOutput(tx𝑖 )
𝑖 ← 𝑖 + 1

1:
import BTC
2:
import IPFS
3:
import PoS
4: Parameters: 𝑝𝑘0
5:
6:
7: while output is unspent do
8:
9:
10: cid ← output.𝑂𝑃𝑅𝐸𝑇 𝑈 𝑅𝑁
11: 𝑄 ← output.TaprootAddress
12: 𝑚𝑒𝑚𝑏𝑒𝑟𝑠 ← IPFS.getData(cid)
13: for m in 𝑚𝑒𝑚𝑏𝑒𝑟𝑠 do
PoS←query(m,PoS)
14:
15: 𝑐 ← PoS.getLatetsCheckpoint
16: 𝑝𝑘 ← PoS.getLatestAggregatedKey
17:
18:
19: else
20:
21:
22:
23:

PoS ← PoS.RemoveBlocks(after c)
𝑐 ←PoS.getLatetsCheckpoint
𝑝𝑘 ← PoS.getLatestAggregatedKey
Go to step 17

return 1

if 𝑄 == 𝑝𝑘 + 𝐻𝑇 𝑎𝑝𝑟𝑜𝑜𝑡 (𝑝𝑘 | |𝑐)𝐺 then

⊲ Initial public key
⊲ In the case of multiple transactions spent by 𝑝𝑘0, choose the first one

⊲ Get chain of transactions

⊲ Get the configuration from IPFS

⊲ get the latest PoS state from the current members
⊲ verify checkpoint

⊲ Verify that the state of the database is consistent with the Bitcoin checkpoint

⊲ Roll back the PoS chain to the previous checkpoint

2007.

[18] Y. Gilad, R. Hemo, S. Micali, G. Vlachos, and N. Zeldovich. Algorand: Scaling
byzantine agreements for cryptocurrencies. In Proceedings of the 26th symposium
on operating systems principles, pages 51–68, 2017.

[19] J. Groth. Non-interactive distributed key generation and key resharing. Cryptol-

ogy ePrint Archive, 2021.

[26] S. Nakamoto and A. Bitcoin. A peer-to-peer electronic cash system. Bitcoin.–URL:

https://bitcoin. org/bitcoin. pdf, 4, 2008.

[27] J. Nick, T. Ruffing, and Y. Seurin. MuSig2: Simple two-round Schnorr multi-

signatures. Cryptology ePrint Archive, 2020:1261, 2020.

[28] Protocol Labs. IPFS powers the distributed web. https://ipfs.io/.
[29] C. Schnorr. Efficient signature generation by smart cards. J. Cryptol., 4(3):161–174,

[20] S. King and S. Nadal. PPCoin: Peer-to-peer crypto-currency with proof-of-stake.

1991.

https://www.peercoin.net/whitepapers/peercoin-paper.pdf, 2012.

[21] C. Komlo and I. Goldberg. FROST: Flexible Round-Optimized Schnorr Threshold

Signatures. IACR Cryptology ePrint Archive, 2020:852, 2020.

[22] P. Kuznetsov and A. Tonkikh. Asynchronous reconfiguration with byzantine
failures. In H. Attiya, editor, 34th International Symposium on Distributed Com-
puting, DISC 2020, October 12-16, 2020, Virtual Conference, volume 179 of LIPIcs,
pages 27:1–27:17. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2020.
[23] J. Liu, W. Zheng, D. Lu, J. Wu, and Z. Zheng. Understanding the decentralization

[30] S. Steinhoff, C. Stathakopoulou, M. Pavlovic, and M. Vukolić. BMS: Secure
decentralized reconfiguration for blockchain and BFT systems. arXiv preprint
arXiv:2109.03913, 2021.

[31] D. R. Stinson and R. Strobl. Provably secure distributed Schnorr signatures and a
(t, n) threshold scheme for implicit certificates. In 6th Australasian Conference on
Information Security and Privacy, pages 417–434. Springer, 2001.

[32] E. N. Tas, D. Tse, F. Yu, and S. Kannan. Babylon: Reusing bitcoin mining to

enhance proof-of-stake security. arXiv preprint arXiv:2201.07946, 2022.

of dpos: Perspectives from data-driven analysis on eosio, 2022.

[33] M. Vukolić. On the future of decentralized computing. Bulletin of the EATCS,

[24] S. Meiklejohn, M. Pomarole, G. Jordan, K. Levchenko, D. McCoy, G. M. Voelker,
and S. Savage. A fistful of bitcoins: characterizing payments among men with no
names. In Proceedings of the 2013 conference on Internet measurement conference,
pages 127–140, 2013.

[25] Murch. 2-of-3 multisig inputs using Pay-to-Taproot. https://murchandamus.
medium.com/2-of-3-multisig-inputs-using-pay-to-taproot-d5faf2312ba3, De-
cember 2020.

2021.

A EXTRA FIGURE

14

1 EXTRA FIGURE

(a) DKG.

(b) Signing.

Figure 8: Execution time of our protocols with failures (here an aborting participant). A (conservative) timeout of 12 seconds
was chosen. In the DKG case, the timeout is repeated over the different rounds (waiting for shares of the secrets, for public
commitments, for complaints, for complaint answers). This explains the much longer execution time.

3579111315171921Number of participants0510152025303540455055Seconds3579111315171921Number of participants051015Seconds