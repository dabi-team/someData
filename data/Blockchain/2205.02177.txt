Tangle 2.0
Leaderless Nakamoto Consensus on the Heaviest DAG

2
2
0
2

t
c
O
2
1

]

C
D
.
s
c
[

2
v
7
7
1
2
0
.
5
0
2
2
:
v
i
X
r
a

Sebastian Müller∗†, Andreas Penzkofer†, Nikita Polyanskii†, Jonas Theis†, William Sanders†, Hans Moog†
∗Aix Marseille Université, CNRS, Centrale Marseille, I2M - UMR 7373, 13453 Marseille, France
†IOTA Foundation, Berlin, Germany

Abstract—We introduce the theoretical foundations of the Tan-
gle 2.0, a probabilistic leaderless consensus protocol based on
a directed acyclic graph (DAG) called the Tangle. The Tangle
naturally succeeds the blockchain as its next evolutionary step
as it offers features suited to establish more efﬁcient and
scalable distributed ledger solutions.

Consensus is no longer found in the longest chain but
on the heaviest DAG, where PoW is replaced by a stake-
or reputation-based weight function. The DAG structure and
the underlying Reality-based UTXO Ledger allow parallel
validation of transactions without the need for total ordering.
Moreover, it enables the removal of the intermediary of miners
and validators, allowing a pure two-step process that follows
the propose-vote paradigm at the node level and not at the
validator level.

We propose a framework to analyse liveness and safety
under different communication and adversary models. This
allows providing impossibility results in some edge cases and
in the asynchronous communication model. We provide formal
proof of the security of the protocol assuming a common
random coin.

batches or blocks of transactions and the blockchain can be
seen as a three-step process. In the ﬁrst step, a client sends a
transaction to the block producers, then some block producer
proposes the block containing a batch of transactions, and
in the last step, validators validate the block.

A more novel approach that addresses the asynchronous
setting of the distributed system has been taken by IOTA [3].
This approach eliminates the need for clustered transactions
and uses a directed acyclic graph (DAG) (as the underlying
data structure) to express simultaneous events. In this model,
individual transactions are added to the ledger, and each
transaction refers to at least two previous transactions. This
property reduces the update of the ledger to two steps: One
node proposes a transaction to the ledger and waits for the
other nodes to validate it. The removal of the intermediary of
miners or validators promises to solve (or at least mitigate)
several problems associated with them, e.g. mining races [4],
centralisation [5], miner extractable value [6], and negative
externalities [7] and allows for a fee-less architecture. How-
ever, the parallelism involved in adding new transactions to
the ledger means that consensus must be found on a “wider”
subgraph than just the longest chain or the heaviest sub-tree.

Keywords—consensus protocol, leaderless, asynchronous, fault-
tolerance, directed acyclic graph, security

1.1. Results

1. Introduction

In distributed systems, different events may happen at
the same time, but participants may perceive them in dif-
ferent orders. In contrast, distributed ledger technologies
(DLTs) such as Bitcoin [1] typically use a totally ordered
data structure, a blockchain, to record the transactions that
deﬁne the state of the ledger. This design creates a bottle-
neck, e.g. a miner or validator, through which each transac-
tion must pass. The creation of blocks can also happen con-
currently at different parts of the network, leading to bifur-
cations of the chain that must be resolved. This is typically
done by the longest–chain rule [1] or some variant of the
heaviest sub-tree [2]. To guarantee the security of the sys-
tem, the throughput of the system is artiﬁcially suppressed
so that each block propagates fully before the next block is
created, and very few “orphan blocks” spontaneously split
the chain. Another effect that limits scalability is that the
transactions are handled in batches. The miners create these

Two main problems of Nakamoto’s “longest-chain rule”
are the severely limited scalability and the lack of parallelis-
ability. The lack of parallelisability results in the underlying
communication network requiring strong assumptions about
synchronicity. We propose a consensus protocol that works
efﬁciently and fast in an asynchronous model and allows a
high degree of parallelisation. This is achieved by replacing
the “longest-chain rule” with the “heaviest-DAG rule”. As
the resulting consensus is not based on a total ordering of
the transactions, it enables the transactions to be stream
processed. An optimization that becomes more and more
relevant in the validation of smart contract updates and
optional sharding solutions.

Another disadvantage in blockchains, which is perhaps
not so well known, is the need for intermediaries in the
form of miners or validators. By enabling leaderless writing
access to the ledger we remove this dependency and reduce
the system to a dichotomy of fund owners and nodes, where
nodes take additional roles akin to validators. Nodes propose
new blocks, which contain transactions from fund owners,

 
 
 
 
 
 
and append them to the Tangle. Nodes utilise the append
process to validate and vote on previous blocks in a highly
efﬁcient implicit voting scheme.

We propose a generalisation of the voting power of
nodes in form of a generalised weight function. This gen-
eralisation allows for a high level of conﬁgurability of our
protocol, making it adaptable to the needs and security re-
quirements of the system in which it should be implemented,
such as permissionless or permissioned.

We introduce an asynchronous leaderless protocol that
employs a weight-based voting scheme on the Tangle. In this
scheme, the supporters of transactions, which are the nodes,
are tracked through implicit votes. The conﬁrmation status
of transactions can be determined using threshold criteria.
We provide the algorithms for the various core components.
More speciﬁcally, we describe how the supporter lists are
updated through the implicit voting scheme and how nodes
should attach their blocks to the Tangle. We provide theo-
rems for the convergence, as well as the liveness and safety
of the system. First, given a random, unpredictable inﬂux of
blocks, Theorem 7.1 gives guarantees that the system will
converge eventually on a consensus state if an adversary has
less than 50% of the weight, however, no safety guarantees
are given in this case. Second, we give safety and liveness
guarantees by extending the protocol and incorporating the
capability to synchronise the nodes at certain intervals with
the help of a common coin. The security guarantees for this
extended protocol are given in Theorem 10.1. Finally, we
provide an overview of simulation results that display the
performance of the protocol.

1.2. Structure of the Paper

The document is structured as follows. In Section 1.3 we
give an overview of essential aspects relevant to the design
of a DLT solution. In Section 1.4 we provide an overview
of other recent DAG-based protocols and highlight the dif-
ferences to our proposal. Section 1.5 provides an overview
of used symbols, acronyms and glossary. Section 2 gives an
overview of some of the graph-theoretical preliminaries used
in this paper. In Section 3 we provide a basic network set-
ting within which the proposed Sybil protection mechanism
operates. Section 4 describes the functionality of the Tangle
data structure and how it is utilised to conﬁrm blocks. Sec-
tion 5 introduces an overview of the Reality-based UTXO
Ledger, which forms a central component in our approach
that helps with tracking the opinions of honest nodes about
conﬂicting transactions. In Section 6, we describe the voting
protocol and conﬁrmation of transactions. In Section 7 we
deﬁne the communication and adversary models and address
the liveness and security of the system in Sections 8 and 9.
In particular, we show that certain attacks that attempt to
create a “metastable” situation, could become problematic
under speciﬁc circumstances and strong assumptions about
the adversary. In Section 10 we provide a solution to this
by introducing a synchronization of nodes at larger time
intervals. In Section 11, to showcase the performance of the
protocol, we provide results from simulation studies. Finally,

we conclude the paper with Section 12, where we describe
future research directions.

1.3. Background

Consensus protocols in general and even DLTs, in par-
ticular, are such a large research area that we have to refer
to some review articles for a more detailed introduction, e.g.
[8]–[10]. Although a consensus protocol depends on many
different aspects, we focus, in the remaining part of the
introduction, on those that are most relevant for the design
choices of our proposed protocol.

Ledger Model. Distributed ledgers (DLs) generally arrive in
two ﬂavours of balance keeping: an account-based model,
where funds are directly associated with the account of a
user, such as is the case with Ethereum [11]; and an unspent
transaction output (UTXO) model, where tokens are linked
to a so-called output, and users own the keys to the output,
as is the case with Bitcoin [1] and many of its derivatives,
as well as Cardano [12], Avalanche [13], and IOTA [14]. As
an important observation in the latter case, the UTXOs form
a DAG themselves. A total ordering of the transactions is
unnecessary for many use cases and situations, as most of
them are parallelisable. However, the append-only nature of
the UTXO ledger hinders this advantage of parallelisation in
the presence of conﬂicting transactions. In [15] we propose
an augmented UTXO ledger model that optimistically up-
dates the ledger and tracks the dependencies of the possible
conﬂicts. We construct a consensus protocol that utilises
this ledger model to enable fast and parallelisable conﬂict
resolution.

The Tangle and Partial Order. The Tangle is the DAG
that stores all transactions of the distributed ledger (DL).
Every DAG induces a partial order on the set of vertices,
the collection of transactions in our setting. This property
contrasts with a blockchain where a total order of transac-
tions is established. As in systems with crash failures, atomic
broadcast and consensus are equivalent problems, see [16],
the partial order of the DAG induces additional “difﬁculties”
in the consensus protocol. More precisely, there have been
serious limitations concerning the security of a DAG-based
DLT. In the original proposal of the Tangle, [3], the longest
chain rule was replaced by the “heaviest sub-graph”, i.e.
the sub-DAG containing the most transactions. However, it
turned out that this design is vulnerable to various types
of attacks and would rely too much on the Proof-of-Work
necessary to issue a transaction, e.g. [17]. Another critical
element of the design that is common to many other DAG-
based proposals is that it suffers a liveness problem. Honest
transactions that refer to transactions that turn out to be
malicious in the future can not be added to the ledger state.
The protocol we propose in this paper solves the security
problems by relying on a weight function for nodes and by
using the Reality-based Ledger. It also treats the problems
of liveness by separating transactions from their containers,

which are blocks,1 and by applying a new block referencing
scheme. In particular, this batch-less architecture enables a
stream process-oriented design of the DLT.

Sybil Protection. Sybil protection plays a crucial role
in a “permissionless environment” where everyone can
participate. By leveraging Proof-of-Work (PoW), Bitcoin’s
Nakamoto consensus was the ﬁrst to achieve consensus in
such an open environment. As PoW leads to enormous
energy waste and many negative externalities, a lot of effort
has been put into proposing more sustainable alternatives.
The most prominent of them is called Proof-of-Stake (PoS),
where the validators’ voting power is proportional to their
stake (i.e. in terms of the underlying cryptocurrency) in the
system.

The Sybil protection used in this paper is based on node
identities. We describe it generically as a function of a scarce
resource or an abstract reputation function. This function,
called weight assigns every node identity a positive number.
For example, this weight can correspond to an amount of
staked tokens, delegated tokens, or the “mana” described in
[14]. We want to note that the weight does not have to be
connected to the underlying token but can be replaced by
any other “weight” serving as a good Sybil protection. In
particular, our framework can also be used in a permissioned
setting, where only the pre-deﬁned validators would have a
positive weight and can apply to the situation with dynamic
committee selections.

Nakamoto Consensus. Distributed consensus allows partic-
ipants to agree on a constantly growing log of transactions. It
has been an important research topic in recent decades, and
its importance in computer science has never been disputed.
There are many ways to categorize consensus protocols.
For instance, there are the classical landmark results on
PAXOS and BFTs, and the newer Nakamoto type consensus
mechanisms.

We understand as Nakamoto consensus the rule to select
the longest sub-chain, e.g. see [10], and as a variant also
the heaviest weighted sub-chain. We extend this concept
to the heaviest sub-DAG. More precisely we consider, a
Nakamoto blockchain consensus to follow the propose-vote
paradigm and that it can be described as follows. The time
is divided into epochs, and for each epoch, there is an
“elected” leader. This leader batches transactions into a new
block and proposes this block. Then the other participants
vote on the proposed block, e.g. by extending the chain
to which the proposed block is attached. Once the number
of votes reaches a certain threshold, the proposed block
is considered part of the ledger. The speciﬁc deﬁnition of
the various elements mentioned above may vary and lead
to different variants of the Nakamoto Consensus. To some
extent, the above paradigm reduces to the necessity to agree
on a unique leader in each epoch. Once the participants have
a consensus on the leader, the linearity of the blockchain

1. Unlike many blockchain protocols, we require each block to contain
the protocol can be

precisely one transaction. However,
adapted such that blocks contain more than one transaction.

in principle,

implies consensus on the ledger state. However, the fact
that only a leader can advance the ledger state creates an
obvious bottleneck with well-known performance limita-
tions. In our proposal, we remove the role of the “leader”
entirely and allow the participants to propose their blocks
and the contained transactions concurrently. Once a block
is proposed, all participants can vote and participate in the
consensus ﬁnding. The weight of the vote is proportional to
the weight of the node, introduced above, such that the pro-
tocol adapts to different weight distributions. The protocol
is also classiﬁed as a non-binary consensus protocol since
it can decide on several transactions simultaneously and is
an ever-ongoing voting procedure forming a progressively-
growing history.2 It also relates to a probabilistic consensus
in the sense that the more supporting nodes a transaction
accumulated the more likely it is that this transaction is
eventually conﬁrmed and added to the ledger.

Voting. In our non-linear architecture, each new block ref-
erences at least two existing blocks. This results in a DAG
structure as mentioned above. As with a blockchain, a new
block not only votes on its direct references but also on
its past cone. Although this is an efﬁcient voting scheme,
there is the problem of orphanage or liveness. If a block
contains an invalid block in its past cone, it can no longer
be voted for and, thus, the contained transaction cannot be
included in the ledger. We solve this problem by introducing
two different references. The ﬁrst reference is to the Tangle
structure and the second is to the DAG structure originating
from the UTXO ledger. The last reference allows voting
for transactions that were originally orphaned and also to
change previously issued votes. Eventually, both types of
votes accumulate in a voting weight, which we call the
Approval Weight (AW). The higher this AW the higher the
probability that the transaction is eventually included in the
ledger. We refer to Figure 1 for an example of the voting
mechanism.

Generally,

the voting mechanism can be applied to
any DAG-based data structure with an append process that
allows for referencing previous blocks. It requires three
main ingredients: the ﬁrst essential ingredient is a reference
scheme that efﬁciently casts and propagates votes. The sec-
ond necessary ingredient is the construction of a generalised
invariant data structure that allows conﬂicts to coexist (see
Section 5). This feature allows to treat transactions “opti-
mistically”; every new incoming transaction is considered
“honest” unless it conﬂicts with another transaction. Con-
sequently, nodes may start to build on top of every new
transaction, even though this transaction may turn out to
be conﬂicting. The third ingredient is a voting mechanism,
dubbed On Tangle Voting (OTV), that efﬁciently votes on a
possible unbounded number of transactions simultaneously.
The efﬁciency is achieved by maintaining a low block
overhead since votes of other nodes can be piggy-backed

2. Both the ledger DAG structure and the Tangle are technically transient
data structures since they can be pruned in theory. Thus, the voting is also
transient knowledge. However, for simplicity, we assume that both data
structures are not pruned.

ˆx

double
spend

ˆy

ˆx

ˆy

ˆx

ˆy

Figure 1: The Tangle is utilised as a voting layer for nodes
to reach a consensus about the outcome of a conﬂict. Nodes
agree on the winner between conﬂicting transactions ˆx and ˆy
using a leaderless protocol. Different colours represent sig-
natures of different nodes. The number of supporting nodes,
shown on the right, increases for transaction ˆy with time.
The dashed references are so-called transaction references
and allow to “rescue” transactions that voted for the “losing
part”.

through the implicit voting mechanism. Also in contrast
to classical Byzantine fault tolerance, nodes don’t have to
be monitored for activity since the issuance of transactions
(casting of votes) is a clear sign of being functional.

Security. Since the beginning of research on consensus
protocols, the concept of security has been at the centre of
attention. Any consensus protocol aims to reach consensus
on a data. Some of the participants may be faulty or even
active in preventing a consensus, and one is interested in
the conditions under which consensus can be achieved.

The security of a propose-vote consensus protocol is
usually divided into two points; liveness and safety. Liveness
means that any correct transaction is ﬁnally accepted by all
honest participants, and safety means that all participants
ﬁnally agree on the same set of transactions. The question

of whether a given consensus protocol fulﬁls these prop-
erties depends largely on the model assumptions. Roughly,
these can be divided into the communication model and the
attacker model.

In the most restrictive communication model, the syn-
chronous model, many different solutions are known since
the landmark result [18]. However, this is not the case under
the most general communication model, the asynchronous
model, which does not assume any bounds on the transmis-
sion delay of block; commonly denoted by ∆. One of the
most famous results on consensus protocols is the FLP im-
possibility result [19] stating that in an asynchronous com-
munication model, a single faulty participant can hinder the
consensus ﬁnding. As the FLP impossibility result relies on
speciﬁc conﬁgurations of block delays, many practitioners
argued that it does not apply to real-world implementations
as these particular situations are very unlikely to occur. In
between these two extreme communications models, several
intermediary models have been proposed, and many positive
results have been obtained under stronger assumptions on
the network delay, e.g. the partially synchronous model [20],
the timed asynchronous model [21], and the asynchronous
model with failure detection [16].

Besides the communication model, the adversary model
plays an important role, especially in the security analysis of
Nakamoto protocols. The protocol’s security is commonly
expressed in the amount of scarce resources, e.g. energy or
computing power, that is necessary to attack the protocol
and revert already conﬁrmed transactions. Nakamoto [1]
analyzed this property by considering a speciﬁc attack, the
so-called private-double spend attack. Note that here the
classic communication model is the partial synchronous one.
Over the last decade, a pertinent research question was the
search for worst-case attacker strategies and the identiﬁca-
tion of the security threshold in terms of the percentage
of the scarce resource controlled by an adversary. Tight
consistency bounds were recently given in [22] and [23]
for several classes of longest-chain type protocols. While
these security thresholds do hold in the partial synchronous
situation, they fail in the asynchronous setting, e.g. [24].

There is also a line of research that studies how an at-
tacker can compensate its lower weight with more inﬂuence
on the communication level. The most prominent of such an
attack is the balance attack, [25], which consists of delaying
network communications between multiple subgroups of
nodes with balanced mining power.

This discussion is of particular interest to us because
we propose a framework for modelling the communication
level and adversarial level jointly. Unsurprisingly, we obtain
impossibility results in the asynchronous communication
model. Still, under further synchronicity assumptions, we
prove that the protocol guarantees liveness and safety (with
a very high probability) if the adversarial weight does not
exceed certain thresholds. The obtained security bounds
are established for any possible attack strategy and are
conﬁgurable by the protocol.

The situations that lead to the impossibility results in
the asynchronous model are frequently considered irrelevant

for practicable purposes, e.g. [26], [27]. The argument for
this is that in real-world applications, the randomness in the
block delays is so great that the particular situation cannot
occur. While we partly agree with this reasoning concerning
our OTV, we added a second synchronicity level to our
core voting protocol to obtain a rigorous security threshold.
For this reason, we see our consensus protocol as a two-
layer solution. The ﬁrst layer works in an asynchronous
setting and allows fast and secure conﬁrmation under normal
network conditions. The second layer is based on an optional
synchronization of the nodes that allows consensus ﬁnding
under worst-case scenarios. The synchronized level relies on
a decentralised random beacon or common coin that makes
the protocol robust against attacks similar to the balanced
attack described above. Randomization of consensus proto-
cols to circumvent the impossibility results are known since
[28], which introduces local randomness. A common coin
was introduced [29] and is used in several approaches to
increase the security in the asynchronous setting.

Performance. Deﬁning a measure for the efﬁciency of a
consensus protocol is not an easy task since it relies on many
different aspects. Natural choices are the number of blocks
sent between the participants and, in synchronous models,
the number of communication steps. In DLTs, common
measures are the number of transactions per second and the
time to conﬁrmation. As our protocol uses implicit voting
and no direct blocks are exchanged between the nodes, it is
optimal in block complexity (if votes are cast through blocks
that would have been sent anyway). We present estimates
for the time to conﬁrmation and show their dependence
on the distribution of the weights. We do not evaluate
quantitative performance measures such as throughput and
energy consumption in this work. This type of study will be
addressed in follow up research.

A common misunderstanding is that asynchronous con-
sensus protocols are not appropriate for time-critical applica-
tions [26]. The fallacy is that synchronous protocols assume
strong synchronicity assumptions; however, the security is
harmed once these assumptions are not satisﬁed. We argue
that it is even the converse and that asynchronous protocols
might be better suited for time-critical applications. Under
a good communication situation, transactions are approved
much faster than in synchronous models based on network
delay estimations with an essential security margin.

One main drawback of the leader-based architecture of
blockchains is its lack of scalability capability. To make
let ∆ be the network latency, λ the
this more precise,
block issuing rate, and q the weight of the adversary. Then,
following [2], [22], the condition for the security of the
protocol is expressed as

q <

1 − q
1 + (1 − q)λ∆

.

(1)

For the design of a system that should support resilience
against a maximum adversary weight q, this equation in-
forms about the bound on the maximum rate at which blocks

can be issued safely. A safety violation can occur, for exam-
ple, if there is disagreement about the recent leader. These
disagreements can be caused by blocks being produced in
parallel [30] or due to certain attack scenarios [31], [32].
As a consequence re-organisations of the blockchain may
occur, in particular for DLTs, where the block production
rate is high [33].

In our case there is no theoretical upper limit for the
throughput of the protocol in this paper; however, the limits
of scalability of our protocol still need to be investigated in
future work.

1.4. Related Work on DAG-Based Protocols

We already mentioned various related works in the gen-
eral introduction. This section focuses on the general archi-
tecture and mention previous proposals that use DAGs in the
underlying data structures. Blockchain-based protocols rely
on a chain or “linearisation” of blocks that create a total
order of transactions. These blocks have three purposes:
leader election, data transmission and voting for ancestor
blocks through the chain structure, see [34]. Each of these
aspects can be, individually or combined, addressed through
a DAG-based component. The various proposals differ in
how and which of these components are replaced by a DAG.
The most common approach is to use a DAG structure
for the data transmission. This is the most natural approach
since if blocks are created at a high rate compared to
their propagation time, many competing or even conﬂicting
blocks are created, leading to frequent bifurcation points of
the chain. As this results in a performance loss, a natural
proposal is to include not only the “main chain” but also
bifurcations using additional references, e.g. [2], [35]–[38].
Protocols can also achieve a higher degree of paral-
lelisation of the data transmission or writing access if all
participants can write and propose blocks. This concurrent
writing access removes considerably performance limita-
tions of traditional blockchains. In blockchains where only
a tiny proportion of participants can write to the ledger, and
these participants are randomly chosen, e.g. by PoW or PoS,
participants need to communicate the set of pending trans-
actions to all their peers. This memory pool is a considerable
performance limitation as nodes must broadcast transactions
twice. Several interesting proposals allow participants to add
concurrent blocks to the ledger and to construct a distributed
memory pool in the form of a DAG. In the following, we
give two approaches that differ in how consensus is achieved
and in the underlying Sybil protection. More speciﬁcally
the ﬁrst utilises a permissioned setting, while the second
employs a permissionless setting.

In the permissioned setting there is the following inter-
esting line of research. The aim is to construct an atomic
broadcast protocol based on a combined encoding of the
data transmission history and voting on “leader blocks”.
Such protocols allow the network participants to reach a
consensus on a total ordering of the received transactions,
and this linearised output forms the ledger. The most robust
protocols achieve Byzantine fault tolerance in asynchronous

settings and reach optimal communication complexity, see
Honeybadger [39] and [40]. Improvements are proposed,
for example, in Hashgraph [41] and Aleph [42] and more
recently in Narwhal [43] based on the encoding of the “com-
munication history” in the form of a DAG. These protocols
remove the bottleneck of data dissemination of the classical
Nakamoto consensus by decoupling the data dissemination
from the consensus ﬁnding. Promising improvements for the
consensus ﬁnding on top of the DAG-based memory pool
were recently made in DAG Rider [44] and Bullshark [45].
We also want to mention [46] that analyses and discusses
this kind of protocol from a more abstract and general point
of view.

There is a common point with our approach to mention
here. A DAG structure serves as a “testimony” of the
communication among the nodes, and new blocks are used
for (implicit) voting on previous blocks. In other words,
the DAG is used for the two purposes of data transmission
and voting. However, voting is done only over so-called
“anchor blocks”, leading to an a posteriori leader election
and total ordering of the transactions. Furthermore, and
as mentioned above, these DAG-based broadcast protocols
are designed for permissioned networks, which leads to
similar safety-liveness properties to standard BFT protocols.
A difference is, thus, that our protocol is designed for an
asynchronous network environment and is not round-based
as these proposals above.

In the permissionless setting, another route is taken by
Prism [34]. This approach explicitly decomposes the three
purposes of blocks into three types: proposer blocks, trans-
action blocks and voter blocks. Having separate transaction
blocks allows participants to issue transactions and removes
the need for a memory pool. The three types of blocks
form a structured DAG that allows a very efﬁcient way to
vote on “leader blocks” that eventually give consensus via
total ordering. Our approach is orthogonal in that we do not
distinguish between different kinds of blocks but that the
underlying DAG delivers consensus without an additional
tool. In an implementation [47] of Prism, another DAG was
used to increase the performance of the execution of the
transaction. More precisely, [47] used a scoreboarding tech-
nique to execute the (totally) ordered UTXO transactions
in parallel. In our approach, we actively construct a DAG,
called the Ledger DAG, that encodes the dependencies of the
transactions. This DAG is created before reaching consensus
and allows tracking dependencies between pending or con-
ﬂicting transactions. It was demonstrated in [48] that Prism
can also support smart contract platforms and that in their
implementation, the bottleneck is no longer the consensus
but the execution of the smart contracts.

The main difference of our proposal to all the aforemen-
tioned protocols is that consensus is found on the heaviest
DAG without the need for a “linearisation” using any leader
selection. This reduces the purposes of blocks to data trans-
mission and voting.

We want to mention another class of DAG-based and
leaderless consensus protocols. However, it is conceptually
different from the proposals above and our proposal. In this

kind of protocol, e.g. [13], [49], the voting is performed via
direct queries between the peers and hence necessities an
additional communication layer. A DAG structure is used
in Avalanche [13] to “transitively” vote on several blocks
at once. We note, however, that the authors of [13] fail to
analyze their proposed protocol properly, and the question
of whether it has the desired properties remains unclear,
e.g. [50, Section 2.3].

Finally, let us note that the above is only a selection of
previous work on DAG-based DLTs and refer the reader to
[10] for a more detailed summary.

1.5. List of Acronyms and Symbols

For the reader’s convenience, in this section, we summa-
rize important notations and acronyms that are used through-
out the paper. Furthermore, in Appendix C we provide a
glossary of the terms in use in this paper.

Symbols

Set Symbols
B
C
N
L
T
DAGs
DL
DT
DV
childV (x)
cone(f )
V (x)
cone(p)
V (x)
D=(V, E)

ρ
maxV (S)

minV (S)

NV (x)

≤V

set of branches
set of conﬂicts
set of nodes in network
ledger or set of transactions
set of blocks

Ledger DAG
Tangle DAG
Voting DAG
set of children of vertex x in DAG D=(V, E)
future cone of vertex x in DAG D=(V, E)
past cone of vertex x in DAG D=(V, E)
directed acyclic graph (DAG) with vertex
set V and edge set E
genesis or vertex with out-degree zero
set of maximal elements in set S (maximal
according to DAG D=(V, E))
set of minimal elements in set S (minimal
according to DAG D=(V, E))
set of neighbours of a vertex x in
graph G=(V, E)
partial order on set V (usually induced by
a given DAG D=(V, E))
set of parent of vertex x in DAG D=(V, E)
supporters of x in DAG D=(V, E)

parV (x)
sprtV (x)
Time Symbols
τf (·)
τcf (·)
τs(·)
Weight Functions
w(·)
AW(·)
WW(·)

time to conﬁrmation deﬁned on T
conﬂuence time deﬁned on T
solidiﬁcation time deﬁned on T

weight function deﬁned on N
Approval Weight deﬁned on L
Witness Weight deﬁned on T

Acronyms

Approval Weight

Directed Acyclic Graph
Distributed Ledger Technology
On Tangle Voting
Peer-to-Peer

AW
dRNG Distributed Random Number Generator
DAG
DLT
OTV
P2P
PoW Proof-of-Work
PoVP
TSA
TTC
UTXO Unspent Transaction Output
WW

Proof-of-Voting-Power
Tip Selection Algorithm
Time to Conﬁrmation

Witness Weight

Graph structures

We employ several graph structures as a base for the
consensus protocol. Table 1 gives an overview of the utilised
graphs.

DAGs
Tangle
Ledger DAG
Voting DAG

Vertices
blocks
transactions
blocks, transactions

Edges
references
spending relations
voting references

TABLE 1: Overview of DAGs

2. Graph Theoretical Preliminaries

In this section, we summarize basic graph theoretical
notations that are used in the remaining part of the paper.
The set of integers between 1 and m is denoted by [m].
A graph G is a pair (V, E), where V denotes the set of
vertices and E denotes the set of edges. A graph is called
directed if every edge has its direction, e.g. for an edge
(u, v), the direction goes from u to v.

Deﬁnition 2.1 (DAG). A directed acyclic graph (DAG) is
a directed graph with no directed cycles, i.e. by following
the directions of edges, we never form a closed loop.

A vertex v in a graph G = (V, E) is called adjacent
to a vertex u if (u, v) ∈ E. An edge e ∈ E is said to be
adjacent to a vertex v ∈ V if e contains v. The out-degree
and in-degree of a vertex v in a directed graph G = (V, E)
is the number of adjacent edges of the form (v, u) and,
respectively, (u, v). A vertex in a graph is called isolated if
there is no edge adjacent to it.

Deﬁnition 2.2 (Neighbours in a graph). Let G = (V, E)
be a graph. For a vertex v ∈ V , deﬁne the set of neighbours
(or G-neighbours), written as NV (v)3, to be the vertices
adjacent to v.

Deﬁnition 2.3 (Parents, children and leaves in a DAG). Let
D = (V, E) be a DAG. For a vertex v ∈ V , deﬁne the

3. In the remainder of the paper, we will often identify the graph with its
vertex set since for a given set of vertices V , we will have only one DAG
D = (V, E). Thereby, the set of neighbours NV (v) and other concepts
that use V as a subscript will be clear from the context.

set of parents, written as parV (v), to be the set of vertices
u ∈ V such that (v, u) ∈ E. Similarly, we deﬁne the set
of children, written as childV (v), to be the set of vertices
u ∈ V such that (u, v) ∈ E. A vertex v ∈ V with in-degree
zero is called a leaf.

Deﬁnition 2.4 (Partial order induced by a DAG). Let D =
(V, E) be a DAG. We write u ≤V v for some u, v ∈ V
if and only if there exists a directed path from u to v, i.e.
there are some vertices w0 = u, w1, . . . , ws−1, ws = v such
that (wi−1, wi) ∈ E for all i ∈ [s]. Furthermore, we note
u <V v if u ≤V v and u (cid:54)= v.

Note that there could be different DAGs producing the
same partial order. The DAG with the fewest number of
edges that gives the partial order ≤V is usually called the
transitive reduction of D or the Hasse diagram of ≤V .

Deﬁnition 2.5 (Minimal subDAG induced by a set of ver-
tices). Let D = (V, E) be a DAG. For a subset of vertices
S ⊆ V , we deﬁne the minimal subDAG of D induced
by S to be the DAG D(cid:48) = (V (cid:48), E(cid:48)) whose vertex set is
V (cid:48) = S and there is an edge (v, u) ∈ E(cid:48) if and only if
u, v ∈ S, v <V u and there is no w ∈ S \ {u, v} such that
v <V w <V u.

Deﬁnition 2.6 (Maximal and minimal elements). Let D =
(V, E) be a DAG and let ≤V be the partial order induced
by D. For a subset of vertices S ⊆ V , an element u ∈ S
is called D-maximal (D-minimal) in S if there is no v ∈
S \ {u} such that u ≤V v (v ≤V u). Deﬁne maxV (S)
and minV (S) to be the set of D-maximal and, respectively,
D-minimal elements in S.

Deﬁnition 2.7 (Future and past cones). Let D = (V, E) be
a DAG. For x ∈ V , deﬁne the past cone of x in D, written
as cone(p)
V (x) to be the set of all vertices y ∈ V such that
x ≤V y. Similarly, deﬁne the future cone of x in D, written
as cone(f )
V (x) to be the set of all vertices y ∈ V such that
y ≤V x.

Deﬁnition 2.8 (Past-closed sets). Let D = (V, E) be a
DAG. A subset S ⊂ V is called D-past-closed if and only
if for every u ∈ S, the past cone cone(p)
V (u) is contained
in S.

3. Nodes and Participation

At a high level, DLTs can be divided into permissioned
and permissionless networks. In a permissioned setting, only
selected parties can participate, while in the permission-
less setting, anyone can join the network at any time. In
a permissioned network, participants have either reading
access or writing (validation) rights. A “fully” permissioned
(or private) DLT selects the participants in advance and
restricts any activity in the network to these only. This
is in contrast to a permissionless network where anybody
can participate in the network and validate the ledger. Our
protocol can work in both settings using a generic weight
function on the participating nodes. In the permissionless

setting, this weight function serves as a Sybil protection, and
in the permissioned setting, this weight function regulates
the participant’s inﬂuence.

In Section 3.1, we introduce the network participants
called nodes. In Section 3.2 we describe a Sybil protection
mechanism based on assigning speciﬁc weights to nodes.
Finally, in Section 3.3 we discuss how the writing ability of
nodes is controlled by their weight.

3.1. Network

The network participants in the DLT are called nodes,
and we denote the set of all nodes by N := {1, . . . , N },
where N is the total number of nodes. A priori, different
nodes may have different perceptions of the set of nodes.
For example, in a permissionless setting, for a node to
join the network, the knowledge of a single node entrance
point is sufﬁcient. For the sake of a better presentation, we
assume that every node is aware of every other node. Nodes
directly communicate with a subset of other nodes, i.e. its
neighbours, via bidirectional channels. Thus, together all
nodes create a peer-to-peer (P2P) overlay network. Nodes
use public-key cryptography for their identiﬁcation. Their
unique node ID is derived from the public key, and all their
blocks are signed with their private keys.

In contrast to other DLTs, where nodes can be divided
into separate functional classes, we assume all nodes behave
in the same way. Speciﬁcally, all nodes have two main roles.
First, they propagate speciﬁc blocks through the network by
receiving and sending these from and to their neighbours.
Second, by creating new blocks and appending them to the
data structure, nodes implicitly vote on the state of the pre-
vious blocks and their contained transactions; this procedure
is called On Tangle Voting (OTV), see Section 6. For the
voting part, we assume a scarce resource, see Section 3.2.
This resource endows every node with a certain weight that
is used for the implicit voting procedure.

Remark 3.1. We make use of the same weights as a control
for the writing access in Section 3.3. Note, however, that the
weight for writing and validation could be different.

A common way to implement such a weight is the so-
called resource testing, where each identity has to prove the
ownership of speciﬁc difﬁcult-to-obtain resources. Since in
the cryptocurrency world, users own a certain amount of
a scarce resource, i.e. tokens, a practical Sybil protection
mechanism can be based on proving the ownership of tokens
and, thus, a certain amount of collateral.

Another way of implementing the weights is through
delegation methods. The owners of source tokens, from
which the weights are derived, can then delegate these
weights to any node of their choosing. This brings several
key advantages. For example, fund owners can delegate
weight to nodes that provide good service or revoke it when
the node does not behave as expected, thus enabling the
implementation of a “reputation” system. In the extreme
case, this even allows decoupling the weights from the token
distribution and incorporate real-world trust models.

Generally, the weight distribution in our system may
change over time due to changes in the weights or inevitable
churns (nodes join and leave). Due to the asynchronous
nature of the protocol, the perception of the weights may
then differ from node to node. The protocol design considers
this effect and allows a certain divergence in the weight
vector. This tolerance to different perceptions provides for
some additional features of the protocol. However, a more
detailed discussion of a divergence in the nodes’ view on
the weight vector is out of the scope of this paper. Thus,
for simplicity, we make the following assumption.

Assumption 3.1 (Agreement on stability of weights). All
nodes in the network perceive the weight of node i to be
precisely w(i). This weight is assumed to remain constant
over time.

3.2. Sybil Protection

3.3. Writing Access

A common problem in permissionless distributed sys-
tems is that it is easy to spawn a signiﬁcant number of nodes,
also known as the Sybil attack. Thus, any critical component
must ensure that the action of nodes is limited, otherwise, it
would be trivial for an attacker to gain a disproportionately
large inﬂuence and corrupt the protocol.

To limit or prevent Sybil attacks, we assume that each
node can be associated with a particular reputation or weight
attributing them an equivalent proportion of voting power in
the applied voting mechanism.

Deﬁnition 3.1 (Weight). For a given node i ∈ N there is an
associated weight w(i), given by a function w : N → [0, 1].
The weights are assumed to be normalised, i.e.
(cid:88)

w(i) = 1.

i∈N

The above weight function plays a crucial role in the

validation process, see Sections 4.4-6.4.

The distributed nature of the protocol and the Byzantine
environment within which it operates puts several con-
straints on the writing access. These constraints are even
more critical for our protocol since it is not leader-based
and does not rely on the intermediary of miners and block
creators. Similar to [51] we require the following conditions:
1) Consistency: if a block that is issued by an honest node
is written to the (distributed) database by one honest
node, it should eventually be written by all honest
nodes.

2) Fairness: given a weight function and a maximum
bandwidth, nodes can issue blocks at a rate proportional
to their weight.

3) Security: the above constraints are guaranteed in a

Byzantine environment.
Consequently, the protocol should ensure that in con-
gested scenarios only a limited amount of blocks are propa-
gated, i.e. the block rate is capped by a certain throughput.

Furthermore, this should happen fairly. These requirements
prevent nodes from becoming overloaded and from incon-
sistencies in the ledger being created. In principle, this could
be enabled through fees and PoW, or more novel alternatives
as the access control algorithm presented in [51].

For the safe operation of the consensus mechanism, we
assume the availability of such a mechanism. The required
tool should provide guarantees on the constraints mentioned
above. We make the following assumption.

Assumption 3.2 (Writing access). The writing access is
controlled such that consistency, security, and fairness in
writing access are guaranteed for a given weight function
w.

4. Block Structure and Witness Weight

In this section, we introduce our protocol’s data structure
concepts. To replicate a certain content over the distributed
network, a node must wrap this content in a block.4 How-
ever, when the content is simply transactions, we require a
block to contain only one transaction in its payload. This
assumption is made for sake of a better presentation and
can be relaxed, such that blocks contain more than one
transaction. Moreover, each block has to refer to at least two
blocks issued in the past. The latter requirement is motivated
by the leaderless architecture of our protocol, in which each
node can issue blocks independently of others. In addition,
we discuss a particular metric on blocks, called the Witness
Weight, that allows nodes to reliably understand when a
signiﬁcant fraction of the network has seen a given block.
In Section 4.1, we formally deﬁne a block. Section 4.2
discusses the Tangle, a DAG formed by blocks and their
references. The local version of the Tangle seen by a spe-
ciﬁc node is introduced in Section 4.3. Using the weight
function for nodes introduced in Section 3.2, we formally
deﬁne the Witness Weight of a given block in the local
Tangle in Section 4.4 and show how to use this metric as a
conﬁrmation rule for blocks in Section 4.5. The analysis of
the growth of the Witness Weight is provided in Section 4.6.

4.1. Blocks

The protocol’s goal is to replicate certain content be-
tween the nodes in the network reliably. For example, this
content could be the atomic updates of balances of fund
owners.

This content is wrapped into an object that we call block.
A node that would like to initiate the addition of certain
content to the Tangle across the network assembles such a
block, which includes the content, k references to previous
blocks and the signature of the node (see Figure 2). We
call the process of assembling and initial broadcasting the
issuance of a block. Each node that receives a new block
forwards it to its neighbours.

Transaction

Input 1

Unlock
block 1

Output 1

Unlock
block 1

Reference 1

...

...

...

...

...

Input n

Unlock
block n

Output m

Unlock
block m

Reference k

Signature of issuing node

Figure 2: Simpliﬁed block layout with a transaction as con-
tent. The fund owner provides the node with the transaction.
The node wraps the transaction into a block and signs the
block.

Deﬁnition 4.1 (Block). A reference ref(x) of block x is
a pair (ry, v), where ry = hash(y) is a unique value that
corresponds to a previously issued block y and v is the value
of a label. We deﬁne a block x as an object with content

x = ({ref 1(x), . . . , ref k(x)}, ˆx, nodeID(x)),

where the ref i(x)’s are references, ˆx is a transaction and
nodeID(x) identiﬁes the issuing node.

Remark 4.1. A collision-resistant hash function is used to
map data of arbitrary size to a ﬁxed-size binary sequence,
i.e. hash : {0, 1}∗ → {0, 1}h. Moreover, it is required that
it is practicably impossible to ﬁnd for a given sequence
x another sequence x(cid:48) such that hash(x) = hash(x(cid:48)).
Throughout the remainder of the paper, we assume that a
particular hash function is ﬁxed and used by all participants.

Remark 4.2. The label v indicates the reference or voting
type, as we will see later in Section 6.3.

The issuing node obtains the content through a service-
client relationship with the issuer of the content, which can
be facilitated through an application programming interface
(API) call. Alternatively, the node itself may also be the
issuer of the content. An essential application for the content
is the transfer of funds, i.e. the consumption and creation
of outputs. We call this type of content a transaction. In
this paper, for the sake of presentation, we will assume that
each block contains exactly one transaction in its payload.
However, in general, blocks are not limited to this use case.
As blocks will also be used to propagate votes, keeping

4. In prior works, we refer to this object as a message.

track of the issuing nodes is crucial.

Deﬁnition 4.2 (Issuer of a block). For a block x, the node
that issued x is denoted as issue(x), where issue(x) ∈ N .

4.2. The Tangle

The Tangle is a data structure built in accordance with
the following rule as stated in the original paper [3] of the
Tangle: “In order to issue a [block] 5, a node chooses two
other [blocks] to approve”.

More generally, we modify this by allowing a block to
reference up to k existing blocks. The data structure takes
the form of a DAG, where the blocks correspond to the
vertices, and the references form the edges.

Let us deﬁne this data structure more formally. We
denote the set of blocks by T . There is a special block,
called the genesis and denoted by ρ. This block does not
contain any references. Any other block has to directly refer
to at least two (not necessarily distinct) blocks. Thereby, the
reference relationship can be encoded into a DAG.

Deﬁnition 4.3 (The Tangle). The Tangle DT is a DAG
whose vertex set is the set of blocks T . There is a directed
edge from y and x in DT if and only if y directly refers to
x.

T (x) and cone(f )

Using the notation from Section 2, we write ≤T to
denote the partial order on the set of blocks induced by
DT . For a block x ∈ T , the Tangle past and future cone of
x are denoted as cone(p)
T (x), respectively.
The parents and children of x are written as parT (x) and
childT (x). If x <T y we say that block x approves or
references block y. Speciﬁcally, if x ∈ childT (y), then x
directly references y; if x (cid:54)∈ childT (y) and x <T , then x
indirectly references y. A leaf in the Tangle DAG is said to
be a tip.

Example 4.1. We refer to Figure 3 for an illustration of the
Tangle and the Tangle future and past cones of block x.

4.3. Local Tangles

Due to the distributed nature of the network, nodes can
receive blocks at differing times or even out of order. The
time at which a node ﬁrst receives a block is called arrival
time.

Blocks can also be lost during their broadcast. While,
generally, this could be problematic, the Tangle DAG allows
for an elegant solution to remedy the loss by a process
called solidiﬁcation. If a node receives a block for which
the parents are unknown,
it requests the missing block
from its peers. Upon receipt of the missing parent block,
the past cone is now complete (unless their parents are
missing - in which case the node has to repeat this procedure
recursively). Once a block’s past cone is completed, the node
ﬂags the block as solid. The time of solidiﬁcation of a block
x in node i is denoted by τs,i(x). We only consider blocks
included in the Tangle after they are ﬂagged solid.

5. The term used in the original whitepaper is transaction, however, in
this work we distinguish between the block and its contained transaction.

past cone

t
i

m
e

x

future cone

Figure 3: Future and past cones of a block x in the Tangle

As a consequence of the above, we can argue that there
is no such thing as one Tangle in the network, as every node
may have a different perception of it. Hence, at time t a node
i is aware only of the block x that satisfy τs,i(x) ≤ t. We
denote by Ti,t and DTi,t the local perception of the block set
and the Tangle DAG perceived from node i at (local) time
t. Past and future cones then are also given in their local
(x) and cone(p)
forms cone(f )
(x). We omit subscripts and
Ti,t
Ti,t
simply write DT = DTi,t if the dependence on i and t is
clear from the context.

4.4. Witness Weight and Weighted Local Tangles

In the original Tangle whitepaper [3] the cumulative
weight of a block plays a crucial role in the consensus
ﬁnding. This cumulative weight is the number of blocks
referencing a given block. In case of a conﬂict, nodes follow
the part of the Tangle that contains the largest cumulative
weight.

We adopt this fundamental idea to the setting where each
node carries some weight. In this way, the nodes’ weight
replaces the PoW in the block creation as a Sybil protection
mechanism. The nodes’ signature in each block links the
issuing node to the block (see Section 4.1). Thus, a node
can be associated with the set of blocks on the Tangle issued
by that node, and the node’s weight can be mapped to the
blocks.

Deﬁnition 4.4 (Block Supporter and Witness Weight). Let
x ∈ Ti,t be a block. Denote by sprtTi,t(x) the set of nodes
that issues a block in the future cone of x:

sprtTi,t(x) =

j ∈ N : ∃y ∈ cone(f )
Ti,t

(x) , j = issue(y)

(cid:110)

(cid:111)

We call nodes from sprtTi,t(x) supporters of x. We deﬁne
the function WWi,t : Ti,t → [0, 1] which is called the
Witness Weight (WW) of a block seen by node i at time t
as follows

WWi,t(x) :=

(cid:88)

w(j).

(2)

j∈sprtTi,t
As the total weight is normalised to 1 the WW describes
the percentage of weight approving a given block. Whenever
it is clear from the context, we omit indices i and t.

(x)

Example 4.2. In Figure 4, we give an example of the set
of nodes approving given blocks x, y and z. We use unique
colours in the bottom of blocks to represent signatures of
different issuing nodes. One can readily check that sprtT (x)
consists of nodes corresponding to brown, cyan and gray
colours.

y

z

x

Figure 4: A Tangle DAG, where the issuing node of a block
can be identiﬁed with a unique colour shown in the bottom
of the block. The colors of the supporters of blocks x, y, z
are depicted in the top-right corners.

We proceed with two trivial statements saying that the
WWs of blocks are monotonically increasing toward the
genesis and the WW of a block can only grow over time.

Lemma 4.1 (Monotonicity of the WW). For any two blocks
x, y ∈ T such that x ≤T y, it holds that sprtT (x) ⊆
sprtT (y) and, hence, WW(x) ≤ WW(y).
Lemma 4.2 (Growth of the WW). For any block x ∈ T ,
node i ∈ N and time instants t1 and t2 such that t1 <
(x) and, hence,
t2, it holds that sprtTi,t1
WWi,t1 (x) ≤ WWi,t2 (x).

(x) ⊆ sprtTi,t2

A more delicate analysis of the growth of the WW under

certain assumptions is provided in Section 4.6.

.

4.5. Conﬁrmation Rule for Blocks

The block stream is controlled by the writing access
control, see Section 3.3. A priori, this control alone may
not be sufﬁcient to guarantee that all nodes see all blocks
in the network. However, to guarantee the safety of the
system, nodes must have consensus on which blocks should
permanently be accepted in the data set T , otherwise, incon-
sistencies between the nodes could arise. If such a consensus
is achieved, we consider a block conﬁrmed. Furthermore, to
maintain consistency in the data structure DT , a block x can
only be conﬁrmed if all blocks in cone(p)
T (x) are conﬁrmed.
Tools that provide information about the conﬁrmation
status of blocks, with speciﬁc safety and liveness consid-
erations, are generally referred to as conﬁrmation rule. We
design such a tool based on the concept of WWs of the
blocks. The WW allows the nodes and users to create their
subjective conﬁrmation criterion. The larger the WW of a
block, the higher the probability that the block will be in
the ledger forever. This idea is similar to the “depth” of a
transaction in a blockchain. Therefore, the actual conﬁrma-
tion criterion may depend on the protocol environment and
the underlying use case.

Deﬁnition 4.5 (Conﬁrmed block). Let θ ∈ (0.5, 1] be a
ﬁxed threshold. We say that a block x ∈ T is conﬁrmed for
a node i ∈ N at time t if WWi,s(x) ≥ θ, for some s ≤ t.

Once a block is conﬁrmed for a node, it remains con-
ﬁrmed forever. This irreversibility of the conﬁrmation status
places some strong requirements on the convergence of this
status. More speciﬁcally, once a single node reaches the
threshold for a given block, all nodes should reach this
threshold eventually with a very high probability.

In an honest scenario, this assumption can be easily
satisﬁed since a high WW also represents that a large
proportion of nodes have “seen” a given block and issued
a block approving it. If the default tip selection algorithm
is suitably chosen and followed by sufﬁciently many nodes
all nodes will attach blocks eventually to the future cone
of that block with a very high probability (for more details,
see Section 4.6). In Section 8 we discuss the liveness and
safety of the protocol in detail.

4.6. Growth of Witness Weight

In this section, we model the block issuance and discuss
the growth of the WW and its dependencies on the protocol
environment.

We consider the following assumption.

Assumption 4.1 (Issuing rate). Each node i ∈ N issues
blocks at a Poisson rate λi (per second). The rate λi is
proportional to the corresponding weights w(i) (see Deﬁ-
nition 3.1), i.e. λi = λw(i) for some constant λ > 0. We
assume that every node issues blocks independently of the
other nodes. The rate of issuance for all nodes is then

λ =

(cid:88)

i∈N

λi.

Remark 4.3. Under Assumption 4.1 the times between two
successive blocks from a node i ∈ N are independent and
exponentially distributed with parameter λi.

To develop a heuristic for the WW we use the following
approach. We assume that there is an “omniscient observer”,
that is instantly aware of all blocks issued by all nodes.
The observer’s perception of the state may differ from the
perception of a given node, however, these differences have
no substantial inﬂuence on the heuristic result. We refer to
[52], [53] where this method has already been proven to lead
to good heuristics. This view is reﬂected in the notation by
omitting the index i. For instance, Tt denotes the set of
blocks perceived by this omniscient observer at time t and
WWt(x) denotes the corresponding WW of a block x at
time t.

Let x be a block issued at time t0 and denote by Ei(δ, x)
the event that node i issues a block in the time interval
[t0, t0 + δ] in the future cone of x. We write 1{Ei(δ, x)}
for the indicator function of this event; it is equal to 1 if the
event occurred and 0 otherwise.

For t = t0 + δ, the WW of block x perceived by the

omniscient observer satisﬁes

WWt(x) =

N
(cid:88)

i=1

w(i)1{Ei(δ, x)}.

(3)

Node i issues blocks with rate λw(i) and, thus, we have
that

P(Ei(δ, x)) ≤ 1 − exp(−δλw(i)).

(4)

Note that the equality does not necessarily hold since not
all new incoming blocks have to witness block x. Taking
the expectation in Equation (3) and applying Inequality (4)
we obtain

E[WWt(x)] ≤

N
(cid:88)

i=1

w(i) (1 − exp(−δλw(i))) .

(5)

The formula given in (3) holds in the very general
setting. For the analysis of the protocol, it is, however, im-
portant to consider a speciﬁc weight distribution. Probably
the most appropriate modelings of weight distributions rely
on universality phenomena. The most famous example of
this universality phenomenon is the central limit theorem.
While the central limit theorem is suited to describe statistics
where values are of the same order of magnitude, it is not
appropriate to model more heterogeneous situations where
the values might differ in several orders of magnitude. These
heterogeneous situations are frequently described by a Zipf
law and appear in many ﬁelds; e.g. city populations, internet
trafﬁc data, the formation of P2P communities, company
sizes, and science citations. We refer to [54] for a brief
introduction and more references, and to [55]–[57] for the
appearance of Zipf’s law on the internet, computer networks,
and DLTs.

We consider a situation with N elements or nodes. Zipf’s
law predicts that the (normalised) weight of the node of rank
r is given by

w(r) =

,

(6)

r−s
j=1 j−s

(cid:80)N

where s ∈ [0, ∞) is the Zipf parameter. Since the weights
w(·) in (6) only depends on two parameters, s and N , this
provides a convenient model to investigate the performance
of the protocol in a wide range of network situations. For
instance, a homogeneous network with N nodes having
equal weight can be modeled by choosing s = 0. With
increasing value of s the network becomes increasingly
centralised.

Example 4.3. We refer to Figure 5. The growth of the
WW depends on several factors, notably the issuing rate
λ and the distribution of the nodes’ weight. In the case
of a Zipf distribution the weight depends on two param-
the number of nodes N and the Zipf parameter
eters,
s. The upper bound (5) is a convex monotone function
in δ and λ. The dependence on the parameters N and
s is not so obvious. For this reason, we perform some
Monte-Carlo simulations for N ∈ {100, 1000, 10000} and
s ∈ {0, 0.2, 0.4, 0.6, 0.8, 1, 1.2}, and λ = 1000.6 For a given
t0 we approximate the WW at time t0+t to be the sum of the
weights of all nodes having issued a block during the time
interval [t0, t0 +t]. This provides a lower bound estimate for
the WW of a block that is issued at t0. In Figure 5 every line
corresponds to one realisation of the growth of the issued
WW (for t0 = 0).

4.7. Estimates on Time to Conﬁrmation

As discussed in Section 4.5, a conﬁrmation rule is essen-
tial for many use cases, and time to conﬁrmation (TTC) is
undoubtedly a vital performance measure of every consensus
protocol. As a thorough analysis of the TTC is out of the
scope of this paper, we give a ﬁrst “heuristic” upper bound
in this section.

Deﬁnition 4.6 (Time to conﬁrmation). We deﬁne the time
to conﬁrmation of a block x (at level θ) by a node i as

τf,i = τf,i(x) := inf{t > 0 : WWi,t(x) ≥ θ} − τs,i(x),

(7)
where τs,i(x) is the solidiﬁcation time of x (see Section 4.3).

In the remainder of this section, we omit index i ∈ N
since the provided analysis is relevant to all nodes. We
divide the TTC into two periods. During the ﬁrst period,
we wait for the conﬂuence time τc = τc(x) until a given
block x is contained in the past cone of (almost) all current
tips. During the second period, the issuance time τiss, we
let the WW grow until it reaches the threshold θ. The TTC
τf is then bounded above by

τf ≤ τc + τiss.

(8)

6. Typical values for the Zipf parameter found in popular cryptocur-
rencies for the top 100 addresses are in the range between s = 0.7 and
s = 1.2 [57].

Figure 5: Growth of the issued WW in Example 4.3 with 1000 blocks per second. We see the different behaviour for 100
nodes (left), 1000 nodes (middle) and 10.000 nodes (right). The growth depends essentially on the chosen Zipf parameter
s (in colour) and the number of nodes.

Estimates for τiss are obtained from (3) and this formula
can be simpliﬁed for speciﬁc choices of the weights (see
Example 4.5).

Example 4.4. We demonstrate the conﬂuence time and the
issuance time with the help of Figure 6. Blocks with a
solid frame are in the future cone of block x. After the
conﬂuence time, all blocks approve x. The yellow, green
and purple colours represent blocks by nodes that hold
signiﬁcant weight, i.e. the nodes have a large inﬂuence on
the conﬁrmation. Once the cumulative weight of the nodes
issued in the future cone of x reaches the threshold θ, the
block becomes conﬁrmed.

With some additional assumptions, we can obtain esti-
mates for the conﬂuence time τc similarly to [3]. Our ﬁrst
assumption is that the delay between block creation and the
moment that other nodes in the network receive this block
is constant.

Assumption 4.2 (Constant network delay). We assume that
the time between the block creation and until any other node
receives this block equals some constant h.

Deﬁnition 4.7 (Number of tips). Let L(t) be the total
number of tips of the Tangle at time t.

As mentioned in Section 4.3, there is no “objective Tan-
gle,” and every node has its own perception. Nevertheless,
previous work [52] showed that the approximation made in
this section leads to reasonable approximations for some
quantitative properties of the Tangle, such as the number
of tips and conﬂuence times. For this reason, we omit the
subscript “i” and work with a unique objective Tangle in
this section. Similar to [3] we assume the number of tips to
be in a stationary regime.

Assumption 4.3 (Constant Tangle width). We assume that
the number of tips L(t) of the Tangle is stationary and has

mean L0.

Using Assumptions 4.1, 4.2, and 4.3 we follow the
heuristics described in [3, Section 3]. A ﬁrst observation
is that at any given time t there are on average λh hidden
tips, those blocks that have been issued after t − h but are
not yet visible to the network. As in [3] we assume that
typically there are r revealed tips, those that have been
attached before t − h but are still tips. Hence, we can write
the total (average) number of tips as L0 = r + λh. By
Assumption 4.3 we consider that the number of tips L(t)
is roughly stationary. This implies that since λh tips join
the tip pool, during the same time, roughly λh blocks that
have been tips at time t − h became referenced and are no
longer tips. Hence, the tip pool of size L0 can be divided
into r revealed tips and λh blocks that are no longer tips.
This division leads to the crucial observation that a new
block (with k parents) approves on average kr/(r + λh)
(revealed) tips. Moreover, in the stationary situation where
the tip pool size L0 stays approximately constant, the mean
number of chosen tips should be equal to 1; otherwise, the
number of tips would change. Solving kr/(r + λh) = 1
leads to

L0 = L(k)

0 =

kλh
k − 1

.

(9)

This result, predicted in [3], has been conﬁrmed through
simulation studies in [52], [53] and theoretical results in
[58].

A ﬁrst consequence of (9) is that, if L0 is large, the
expected time for a block to be approved for the ﬁrst time
is approximately

h + L0/(kλ) = h +

h
(k − 1)

.

(10)

The size of the tip pool is naturally linked to the growth of
the WW of a given block; the larger the tip pool the slower
the growth of the WW.

x

c
o
n
ﬂ
u
e
n
c
e

t
i

m
e

i
s
s
u
a
n
c
e

t
i

m
e

x

x

and, hence, obtain

τc ≈

h
log k

log(L0) ≈

1
log k

h log(λh).

(12)

In Section A, we will give more details on the derivation of
the conﬂuence time.

Example 4.5. The behaviour of the issuing time τiss heavily
depends on the actual weight distribution, e.g. see Figure 5.
However, the extreme case of all nodes having the same
weight can be treated more analytically. Extreme is meant
here in the sense that the growth of the WW is to some
extent the smallest. Hence, let w(i) = 1/N for all nodes
i ∈ N and assume that we want to get a bound on the
conﬁrmation time, i.e. the ﬁrst time a given block x reaches
WWt(x) ≥ θ. Denote by Xi the ﬁrst time a block was sent
from node i ∈ N . The vector of these times (X1, . . . , XN )
can be ordered in increasing order and we obtain the so-
called order statistics X(1), . . . , X(N ). In the case where
all Xi follow the same exponential distribution Exp(γ) the
distribution of the ith order statistic is given by

X(i) ∼

1
γ

i
(cid:88)

j=1

Zj
N − j + 1

,

(13)

where the Zj are i.i.d. exponential random variables with
parameter 1. Eventually, the time it takes that (cid:100)θN (cid:101) nodes
issued a block is distributed as X((cid:100)θ·N (cid:101)). The expectation is
given by

E[X(i)] =

1
γ

i
(cid:88)

j=1

1
N − j + 1

,

Figure 6: Illustration of the Tangle to display the conﬂuence
time and issuance time. The colours in the bottom of the
blocks represents the issuing nodes with signiﬁcant weight.
We demonstrate the colours of the “heavy” supporters of
block x on the right after each time period. The dashed
blocks correspond to blocks that are not in the future cone
of x.

with i = (cid:100)θ · N (cid:101). Using a standard integral approximation
for the above sum, we obtain for large N that

E[X(i)] ≈

N
λ

(log(N ) − log(N − i)) .

Hence, for i = θN ,

Remark 4.4. For any given λ and h we can choose k
sufﬁciently large such that k > L(k)
0 . In this case, blocks are
referenced essentially immediately after they become visible,
however, at the cost of a larger block size.

We can proceed similar to [3] to obtain that

τiss ≈ E[X(i)] ≈

N
λ
Combing this result with the bound (12) on the conﬂuence
time in (8) we obtain the following asymptotic upper bound
on the TTC for large k (and the other parameters ﬁxed):

(− log(1 − θ)) .

τf (cid:46) 1
log k

h log(λh) +

N
λ

(− log(1 − θ)) .

τc ≈

h
(cid:16) (k−1)2
k

W

(cid:17) (log L0 + log ε) ,

(11)

5. The Ledger

where log denotes the natural logarithm function and W is
the principal branch of the Lambert W -function, which is
deﬁned as the inverse function to z = wew, i.e. w = W (z).
For large k, we can use the approximation

W

(cid:19)

(cid:18) (k − 1)2
k

≈ 2 log(k − 1) − log k ≈ log k

This section introduces several novel concepts to repre-
sent transactions and their interrelationships. Recall that in
the standard UTXO conﬂict-free model, transactions specify
the outputs of previous transactions as inputs and create
new outputs by spending (or consuming) the inputs. No two
transactions are consuming the same input. Such a conﬂict-
free data structure can be implemented in a network where
a consensus mechanism ﬁlters transactions. The latter is

typically done by choosing a “leader” among the partici-
pants, and the leader adds a block of transactions to the
conﬂict-free ledger. To bypass this “centralised” bottleneck,
we propose the concept of the Reality-based UTXO Ledger,
an augmented version of the standard conﬂict-free UTXO
Ledger that allows more than one output spend. We refer
the reader to the parallel work [15], where we discuss all
concepts in detail.

In Section 5.1, we recall the deﬁnition of a transaction in
the UTXO model and the ledger, which is a set of all transac-
tions. In Section 5.2, we introduce deﬁnitions of conﬂicting
transactions, conﬂicts and branches, which represent proper
subsets of “non-conﬂicting conﬂicts”. A reality is a maximal
possible branch, and restricting a ledger to a reality results
in the conﬂict-free UTXO Ledger. Finally, in Section 5.3 we
discuss how nodes could choose a reality given an abstract
weight function deﬁned on the set of conﬂicts. The selected
reality allows a node to express its opinion when issuing
new blocks and validating transactions.

5.1. UTXO Model and Transactions

In the Unspent Transaction Output (UTXO) model trans-
actions specify the outputs of previous transactions as inputs
and spend them by creating new outputs.

Thus, a transaction consists of a list of inputs and a
list of outputs, see Figure 2. Note that outputs must be
unique. The uniqueness is typically achieved by creating
the output ID with the involvement of a hash function. For
example, the output ID could be the concatenation of the
index of an output and the hash of a transaction’s content.
Every output represents a speciﬁc amount of the underlying
cryptocurrency. The value of all inputs, i.e. spent outputs,
must equal the value of all outputs of a transaction. With
each output comes a declaration by whom and under which
conditions it can be spent. Under unlock conditions, e.g. a
signature proving ownership of a given input’s address, the
transaction issuer is allowed to spend the inputs. We refer
to Figure 2 for a general transaction layout.

As said in Section 4.1, blocks contain transactions in
their payload. Hereafter, we write ˆx to denote the transaction
contained in the payload of a block x.

Let us deﬁne the transactions and ledger model more

formally. We follow the approach of [59].

Deﬁnition 5.1 (Output and input). An output is a pair of
a value v ∈ R+ and an unlock condition cond. We write
o = (v, cond) to denote the output. An input i is a reference
to an output. We say the input consumes the output.

Deﬁnition 5.2 (Transaction). A transaction ˆx is a collec-
tion of inputs in(ˆx), outputs out(ˆx), and unlock proofs
unlock(i), i ∈ in(ˆx), where
1) in(ˆx) = (i1, . . . , in) is a list of inputs, i.e. references to
unconsumed outputs. We say that those outputs are spent
or consumed by transaction x;

2) out(ˆx) = (o1, . . . , om) is a list of new outputs produced

by transaction ˆx;

3) unlock(i) is a proof which performs veriﬁcation of the
unlock conditions of each input i of transaction ˆx. This
is usually done by cryptographic proof of authorization
that ensures that the issuer of the transaction satisﬁes the
condition cond of the consumed outputs.

Deﬁnition 5.3 (Ledger). The ledger is a set of transactions
and denoted as L.

The UTXO ledger starts at the so-called genesis which
contains outputs and no inputs. We emphasize that we use
the same term for the ultimate predecessor of all blocks and
all transactions. Recall that the genesis-block is written as
ρ, whereas the genesis-transaction will be denoted as ˆρ.

Typically every output can be consumed by at most one
transaction and, hence, the value of all unspent outputs is
conserved overall. Speciﬁcally, in the standard conﬂict-free
UTXO model, the ledger can not contain a so-called double
spend, i.e. two transactions that consume the same output
of a transaction.

In the following section, we alleviate this conﬂict-free
restriction and allow the Ledger to contain conﬂicting trans-
actions.

5.2. Reality-based Ledger

In this section, we propose an augmented version of
the standard conﬂict-free UTXO ledger model that allows
containing double spends. We suggest different structures
that can be used for tracking conﬂicting transactions without
the need for consensus.

First, we explain how the transactions and their in-
and outputs result in a DAG structure. The information
contained in the Ledger DAG is split into the Conﬂict Graph,
which keeps track of the conﬂicting transactions only. Then
we introduce the concept of branches. A branch forms a
possible non-conﬂicting state of the ledger. We will then
derive a concept, called a reality, which allows us to reduce
L to a maximal subset of transactions that yield a conﬂict-
free (Reality-based) ledger.

Deﬁnition 5.4 (Ledger DAG). We deﬁne the Ledger DAG
DL to be a DAG whose vertex set is the ledger L. There is
a directed edge (ˆx, ˆy) in the edge set of DL if and only if
an input of ˆx references an output of ˆy.

We refer to Appendix B, where we demonstrate this
graph together with many other core concepts. Using the
notation from Section 2, we write ≤L to denote the partial
order on the set of transactions induced by DL. The past
cone of a transaction ˆx is denoted by cone(p)
L (ˆx), i.e. trans-
action ˆx spends value directly or indirectly from transactions
in cone(p)

L (ˆx) \ {ˆx}.

Typically, the addition of transactions to this type of
data structure is such that only transactions, which create
no conﬂict with any previously recorded transactions are
allowed to be added, i.e. the Ledger DAG is conﬂict-free.
However, this requires a consensus mechanism that pre-
selects transactions.

Now we introduce a new design for a ledger, where
this constraint is replaced by a relaxed one – namely, a
new transaction ˆx can be added to the ledger if in(x) are
references to outputs which are not already consumed in
cone(p)
L (ˆx) \ {ˆx}. In the following, we provide an overview
of some of the most important concepts of the proposed
solution that allows conﬂicting transactions to co-exist.
Thereby, we start with a formal deﬁnition of conﬂicts and
conﬂicting transactions.

Deﬁnition 5.5 (Conﬂicts). Two distinct transactions ˆx, ˆy ∈
L are directly conﬂicting if they have at least one input in
common. A transaction ˆx ∈ L is called a conﬂict if and only
if there exists a transaction ˆy ∈ L \ {ˆx} such that ˆx and ˆy
are directly conﬂicting.

Deﬁnition 5.6 (Conﬂicting transactions). Two distinct trans-
actions ˆx1, ˆy1 ∈ L are said to be conﬂicting if there exist
distinct ˆx2, ˆy2 ∈ L with ˆx1 ≤L ˆx2 and ˆy1 ≤L ˆy2 such that
ˆx2 and ˆy2 are directly conﬂicting.

The interrelations between conﬂicts can be encoded with

the help of the Conﬂict DAG and the Conﬂict Graph.

Deﬁnition 5.7 (Conﬂict DAG and Conﬂict Graph). The set
of all conﬂicts is denoted by C and dubbed the set of conﬂicts
of the ledger L. We deﬁne the Conﬂict DAG DC to be the
minimal subDAG of the Ledger DAG induced by C ∪ ˆρ (cf.
Deﬁnition 2.5). We deﬁne the Conﬂict Graph GC to be the
graph whose vertex set is C and two conﬂicts are connected
by an edge if and only if these conﬂicts are conﬂicting (as
transactions).

We can group transactions based on whether they con-

ﬂict with each other or not.

Deﬁnition 5.8 (Conﬂict-free set and conﬂicting sets). A
subset of transactions S ⊆ L is called conﬂict-free if it
does not contain any two conﬂicting transactions. We also
say that S1 ⊆ L is conﬂict-free with respect to S2 ⊆ L if
there is no ˆx1 ∈ S1 and ˆx2 ∈ S2 such that ˆx1 and ˆx2 are
conﬂicting. Alternatively, S1 is conﬂicting with S2 if S1 is
not conﬂict-free with respect to S2.

We further specialise conﬂict-free sets and introduce the

notion of branches.

Deﬁnition 5.9 (Branch and set of branches). A set of
conﬂicts B ⊆ C is called a branch if and only if the two
properties hold:

1) B is conﬂict-free (cf. Deﬁnition 5.8);
2) B is DC-past-closed (cf. Deﬁnition 2.8).
Deﬁne B to be the set of all branches. A branch that
represents the empty set is called the main branch.

We now introduce the concept of a reality which can
be deﬁned as a maximal possible branch or, equivalently,
a maximal independent set in the Conﬂict Graph. In other
words, a reality aggregates the maximal number of conﬂicts
while preserving non-conﬂicting nature.

Deﬁnition 5.10 (Maximal branch and reality). A branch
B ∈ B is maximal if there exists no other branch A ∈ B
such that B ⊂ A. A maximal branch is called a reality.

Next, we describe the notion of the maximal contained
branch of a given transaction which consists of the set
of conﬂicting transactions in the past cone of the given
transaction.

Deﬁnition 5.11 (Maximal contained branch). Let B be the
set of all branches, and branch(p)
L : L → B be a function that
for a given transaction ˆx ∈ L returns the maximal branch
contained in cone(p)

L (ˆx).

We note that there could not be two maximal branches in
the ledger past cone of a transaction. Indeed, the past cone
of any transaction is conﬂict-free and, thus, if there would
be two maximal branches, we could consider the union of
two branches, which has to be also a branch.

Deﬁnition 5.12 (Ledger of a reality). Let R ∈ B be a reality.
Deﬁne the R-ledger, written as L(R), to be the set of all
transactions ˆx ∈ L such that branch(p)

L (ˆx) ⊆ R.

Recall that a maximal contained branch of a transaction
from the R-ledger is a subset of R. Thus, the past cones of
any two transactions are conﬂict-free and so is the R-ledger.

Remark 5.1 (Local Ledger). As discussed in Section 4.3,
there could be subjective versions of the Tangle DAG. Sim-
ilarly, every node has its own perception of the Ledger.
Thereby, we will use subscripts i, t in L, DL and other
related notions if we talk about the point of view of node
i ∈ N at moment t.

5.3. Reality selection algorithm

To issue new blocks and validate transactions, each node
in the network has to choose a conﬂict-free part of the ledger
that it prefers. For this purpose, it sufﬁces for a node to
choose a preferred reality. Once a reality R is chosen, the
node can make different operations on the R-ledger.

Deﬁnition 5.13 (Preferred reality). Node i ∈ N at time t
chooses a speciﬁc reality R = Ri,t ∈ B which is called the
preferred reality for node i.

There could be different ways to choose the preferred
reality. We provide a natural reality selection algorithm that
takes as an input the Conﬂict Graph and an abstract weight
function w : C → [0, 1] satisfying two properties:
1) monotonicity: for any two conﬂicts x, y ∈ C such that

x ≤C y, it holds that

w(x) ≤ w(y);

2) consistency: let x1, . . . , xs be pairwise conﬂicting con-

ﬂicts.7 Then it holds that

s
(cid:88)

i=1

w(xi) ≤ 1.

7. We say that transactions S ⊆ L are pairwise conﬂicting if any pair

of transactions x, y ∈ S are conﬂicting.

Algorithm 1: Reality selection in Conﬂict Graph

Data: Conﬂict Graph GC = (C, E)
Result: reality R ∈ B

1 R ← ∅
2 U ← C
3 while |U | (cid:54)= 0 do
4

c∗ ← arg max{w(c) : c ∈ maxC(U )} ;
min hash(c) for breaking ties */
R ← R ∪ {c∗}
U ← U \ {NC(c∗) ∪ {c∗}}

/* use

5

6
7 end

Remark 5.2. In Section 6.4, we introduce the Approval
Weight function deﬁned on the set of all transactions, i.e.
AW : L → [0, 1]. Then the required weight function can be
obtained as the restriction of the Approval Weight to the set
of conﬂicts, i.e. w = AW|C.

In Algorithm 1 we describe the proposed procedure. In
this algorithm, we initialize R as the genesis and U as the
set of conﬂicts. Then we iteratively construct a subset R
of conﬂicts and prune transactions conﬂicting with R from
U . Speciﬁcally, we add a conﬂict to R if this conﬂict is
not conﬂicting with this set and attains the highest value
of the weight function among all DC-maximal elements
that remain in U . By construction, Algorithm 1 leads to a
maximal independent set in the Conﬂict Graph or a reality.
The number of iterations in the while-loop is bounded by
|C| and the number of GC-neighbours is also bounded by
|C|. Thus, it is possible to implement this algorithm with
complexity O(|C|2).

We refer to Appendix B, where we apply the algorithm

as part of an illustrated example.

6. On Tangle Voting

In this section, we present a voting mechanism based
on the Tangle and the Ledger DAG. This mechanism allows
for selecting realities in the Reality-based Ledger.

In Section 6.2 we give an overview of two suitable DAG
structures, which can be utilised to enable voting on the
realities. Section 6.3 combines these two structures into a
Voting DAG and introduces basic concepts that follow from
it. We also address how voting on two DAGs increases
the liveness of the protocol. Section 6.4 deﬁnes a metric
called Approval Weight which is utilised in Section 6.5 to
identify a preferred reality and vote for it using a suitable
tip selection algorithm.

6.1. Extension of Witness Weight and Liveness
Problems

In Section 4 we introduced the Witness Weight, which is
a metric used for the conﬁrmation of blocks. In this section,
we seek a similar tool for the conﬁrmation of transactions.
The Witness Weight has the property that it is mono-
tonically increasing since it expresses the percentage of the

weight that has witnessed a block’s existence. The situation
is different for transactions where we want to leverage the
node’s weight to decide between conﬂicting transactions. To
ensure liveness, nodes must have the possibility to change
their votes and withdraw their weights from the approval
weight of a given transaction.8 However, changing the opin-
ions might imply that blocks that reference (and vote for)
blocks with rejected transactions might never be conﬁrmed.
This situation creates a negative incentive to reference
new tips. More precisely, nodes may be incentivized to either
reference only blocks from trusted entities, tips of a certain
age, or in the worst case, ancient and already conﬁrmed
blocks. The last behaviour may eventually lead to no new
blocks being conﬁrmed anymore.

The problems above were until now a signiﬁcant concern
of DAG-based consensus protocols, e.g. [3]. We propose to
solve these by using the Reality-based Ledger and extending
the reference scheme.

6.2. Immutable DAGs

Blocks are the primary information carriers of the net-
work, i.e. they contain transactions and express the opinion
of the issuing nodes. The references in the blocks, together
with the signature of the nodes and the unlock proofs for
the inputs, form two immutable data structures, similar to a
blockchain.

First, the Tangle DT is constructed on the set of blocks
T . The interrelations are deﬁned by the references contained
in the blocks, which are selected and signed by the issuing
nodes (for more details, see Section 4).

Second, the Ledger DAG DL is constructed on the set
of transactions L. Their interrelations are deﬁned by the
consumption of inputs, which are the outputs of previous
transactions. The consumption and creation of outputs are
cryptographically veriﬁed by the signature of the fund owner
(for more details, see Section 5).

For nodes to objectively agree on a partial order of

events, we require the following assumption.

Assumption 6.1 (Past cone completeness). For a transaction
ˆx that spends an output created in a transaction ˆy, it holds
that the block x is contained in the Tangle future cone of
y, i.e. x ∈ cone(f )

T (y).

In other words, we have the natural assumption that the
spending of the output should happen in the future cones
the blocks “creating” these outputs.

Lemma 6.1. Under Assumption 6.1, the partial order ≤L
induced by DL is consistent with the partial order ≤T in-
duced by DT . More speciﬁcally, if for some blocks x, y ∈ T ,
we have that the corresponding transactions satisfy ˆx ≤L ˆy,
then it holds that x ≤T y.

Proof. The statement can be shown trivially by induction
on the length of the shortest path between ˆx and ˆy in DL.

8. In contrast, if weights are added but not withdrawn, it is possible that
two conﬂicting transactions gain precisely the same weight which would
result in an impasse.

The base case, when the length of the path is one, is implied
by Assumption 6.1.

6.3. Voting and Voting DAG

As a consequence of Lemma 6.1 both, the Tangle and
the Ledger DAG, are suitable for nodes to express their
opinions about which transactions they prefer among any
conﬂicting transactions. More speciﬁcally by creating and
attaching new blocks, nodes have an implicit way of voting
for the “preferred” branches and conﬂicts. Let us deﬁne this
more precisely.

We utilise the references contained in a block, which
constitute the edges of the Tangle, see Section 4, to express
a node’s opinion. As by Deﬁnition 4.1 a reference contains
two ﬁelds: rx, which is a reference to block x and v, which
is the value of a label. We call the label v the vote type
that can take values in {vT , vL}. This label gives additional
meaning to the reference to x in the Tangle and deﬁnes the
following two specialised references.

Deﬁnition 6.1 (Block reference). We say a reference
ref(y) = (rx, v) from a block y to a block x is a block
reference if y references x. In this case, we set the label
v = vT .

To overcome the liveness issues described in Section 6.1
we additionally add a reference that bypasses the block and
directly addresses the contained transaction.

Deﬁnition 6.2 (Transaction reference). We say a reference
ref(y) = (rx, v) from a block y to a block x is a transaction
reference if y references ˆx. In this case, we set the label
v = vL.

Remark 6.1. Naturally, a block references the transaction
that is the content of the block. As such, an honest node
would not issue a block with a transaction that is not in its
preferred reality (see Section 6.5).
Example 6.1. Consider Figure 7. Blocks y and y(cid:48) contain
the same transaction ˆy, but y refers to the transaction ˆx in
block x and, thus, issues a transaction reference, while block
y(cid:48) refers to the block x and, thus, issues a block reference,
instead.

Remark 6.2. The distinction into the sub-categories (trans-
action reference and block reference) is only relevant for the
purpose of voting; the deﬁnition of the Witness Weight, see
Section 4.4, remains unaffected.

We deﬁne a data structure that combines the two im-
mutable data structures in Section 6.2 into one single DAG
used for propagating the votes.

Deﬁnition 6.3 (Voting DAG). The Voting DAG DV is a
DAG whose vertex set V is the union of the set of blocks
T and the set of transactions L, i.e. V = T ∪ L. Let v and
u be two vertices in V. There exists a directed edge from
u to v in DV if and only if one of the following properties
holds:
1) u, v ∈ T and u contains a block reference to v;

Transaction ˆx

Block x

Branch Bˆx

Branch Bx

Transaction
reference

Block
reference

Transaction ˆy

Block y

Transaction ˆy

Block y(cid:48)

Branch B ˆy

Branch Bˆx

Branch B ˆy

Branch Bˆx

Figure 7: Inheritance of branches: we consider two potential
blocks y and y(cid:48) that contain the same transaction ˆy, but
have either a transaction, or a message reference to block
x. Thus, a node can vote in two ways. Speciﬁcally, block
can approve a previous block via a transaction reference or
a block reference, and inherit the branch of the referenced
transaction or the referenced block, respectively.

2) u ∈ T , v ∈ L and u contains a transaction reference to

transaction v;

3) u ∈ T and v = ˆu ∈ L, i.e. v is a transaction in block u;
4) u, v ∈ L and transaction u spends the output from

transaction v, i.e. v ∈ parL (u).

So far we described how references between blocks are
given additional meaning to construct the voting DAG. This
DAG allows nodes to express their opinions, recursively.
Following Deﬁnition 2.7 we deﬁne cone(p)
V (x) as the voting
past cone of block or transaction x in the Voting DAG.

Deﬁnition 6.4 (Voting). A node i expresses a direct vote
for a vertex x ∈ V in the voting DAG DV by referencing
x in a block y ∈ T , where issue(y) = i. We say node i
indirectly votes for any vertex in cone(p)

V (x).

Example 6.2. We illustrate the concept of a Voting DAG in
Figure 8. The Voting DAG assembles information from the
Tangle and the Ledger DAG. We assume a situation where
the node that issues block x does not approve transaction ˆy
and, thus, can vote neither for blocks y nor z. However, it
can vote for transaction ˆz by using a transaction vote. More
precisely, by creating a transaction reference to block z, the
vote of block x avoids vertices z, y, ˆy shown in grey.

We can also describe the voting past cone in terms of a

recursive equation.

Proposition 6.1. Suppose a given block x ∈ T has block
references to block y1, . . . , ys and transaction references to
blocks z1, . . . , zr with s + r = k. Then the voting past cone
of x can be written in a recursive way

cone(p)

V (x) = x ∪ cone(p)

L (ˆx) ∪ CL(x) ∪ CV (x),

ˆy

ˆz

ˆx

Block
vote

y

z

Transaction
vote
x

ˆx x

ˆy

y

ˆz

z

Ledger DAG

Tangle

Voting DAG

Figure 8: Illustration of how the Voting DAG is assembled
from the Tangle and the Ledger DAG. By creating a transac-
tion reference to block z, the vote of block x avoids vertices
z, y, ˆy shown in grey.

where

CL(x) := cone(p)
CV (x) := cone(p)

L (ˆz1) ∪ . . . ∪ cone(p)
V (y1) ∪ . . . ∪ cone(p)

L (ˆzr) ,
V (ys) .

The Reality-based Ledger introduces the concept of
branches, see Section 5. The consumption of more than
one output from different branches creates a new branch,
which is the union of the branches of the consumed outputs.
Now we extend this concept to blocks, which can combine
branches by voting for previous blocks or transactions. More
precisely we can relate a given reference in a block with a
branch. The branch of the block is then deﬁned as follows.

Deﬁnition 6.5 (Voting Branch). Given a block x ∈ T , we
deﬁne the voting branch of x to be
branch(p)

V (x) := cone(p)

V (x) ∩ C,

where C is the set of conﬂicts.

Remark 6.3. We highlight that for the correctness of the
protocol, a node has to create references for a new block x in
such a way that branch(p)
V (x) is indeed a branch as deﬁned
in Deﬁnition 5.9. The property that branch(p)
V (x) is DC-
past-closed trivially follows from the fact that cone(p)
V (x) ∩
L is DL-past-closed. However, the conﬂict-free property of
branch(p)
V (x) is not necessarily true in general and has to be
checked. We address this issue when we discuss tip selection
algorithms in Section 6.5.

Recall Deﬁnition 5.11 that introduces the maximal con-
L (ˆx).

tained branch of a transaction ˆx, written as branch(p)

Using Proposition 6.1, we relate the voting branch of block
x and the maximal contained branch of transaction ˆx in the
following statement.

Proposition 6.2 (Inheritance of branches). Suppose a given
block x ∈ T has block references to block y1, . . . , ys and
transaction references to blocks z1, . . . , zr with s+r = k. A
block x inherits the union of the branches that are associated
with these votes, i.e. the voting branch can be decomposed
as follows

branch(p)

V (x) = branch(p)

L (x) ∪ BL(x) ∪ BV (x),

where

BL(x) := branch(p)
BV (x) := branch(p)

L (ˆz1) ∪ . . . ∪ branch(p)
V (y1) ∪ . . . ∪ branch(p)

L (ˆzr),
V (ys),

Example 6.3. We follow the same example as shown in
Figure 7. We assume the maximal contained branch of the
transaction in block y is the main branch, i.e. Bˆy = ∅. Block
y votes for the transaction contained in block x and, thus,
inherits the branch Bˆx. Since Bˆy = ∅ the voting branch
of block y is Bˆx. Similarly, block y(cid:48) votes for the block
itself and inherits the voting branch Bx. We highlight that
the branch of the transaction contained in block y (and y(cid:48))
is not affected by the choice of the vote.

We can associate a given block x with a branch
BT = branch(p)
V (x). Furthermore, the content of x, which
is a transaction ˆx, also can be associated with a branch
BL = branch(p)
V (ˆx). Due to Lemma 6.1 we have that
BL ⊆ BT . Since a node may change its opinion about a
conﬂict and vote for a conﬂicting transaction to ˆx, the vote
is only valid from the point-of-view of the referencing block
y. A later change of the node’s vote is possible by issuing
another block that votes for a conﬂicting transaction to ˆx.

Deﬁnition 6.6 (Change of vote and current vote). Let ˆx be a
transaction for which node i ∈ N voted for. Let transaction
ˆy be conﬂicting with ˆx. If node i votes for ˆy after it voted
for ˆx, node i is no longer approving ˆx. We say i revokes its
vote from ˆx. If i’s most recent vote is approving ˆx, i.e. the
vote is also not revoked, we say i’s current vote is approving
ˆx.

Remark 6.4. The notion of “time” and its implications
on the meaning of “after” in Deﬁnition 6.6 are crucial.
Natural choices are the timestamp inside a transaction or
the solidiﬁcation time of a block that contains a given
transaction.

Example 6.4. The principle of Deﬁnition 6.6 is demon-
strated in Figure 1. Speciﬁcally, transactions ˆx and ˆy are
conﬂicting; block references are depicted with solid edges,
whereas transaction references are depicted with dashed
edges. Initially, brown and purple nodes voted for ˆx. How-
ever, after a while, green nodes have revoked their votes
from ˆx and their latest votes are approving ˆy. The supporters
of ˆx and ˆy are shown in the top-right corners of blocks for
each of the two periods.

6.4. Approval Weight and Conﬁrmation Rule for
Transactions

Algorithm 2: Updating transaction supporters
when new block arrives

Nodes must be able to track the progress of the accep-
tance of a transaction. We extend the concepts of Witness
Weight, introduced in Section 4.4, to the Approval Weight
(AW) of transactions. The objective is then to deﬁne a pa-
rameterisable conﬁrmation condition for transactions similar
to the one discussed for blocks in Section 4.5.

Deﬁnition 6.7 (Transaction Supporters and Approval
Weight). Let ˆx ∈ L be a transaction. Denote by sprtL(ˆx)
the set of nodes that has a current vote for ˆx. These
nodes are called supporters of ˆx. We deﬁne the function
AW : L → [0, 1] which is called the Approval Weight (AW)

AW(ˆx) :=

(cid:88)

w(j)

(14)

j∈sprtL(ˆx)

Clearly, the AW describes the percentage of the network

approving a given transaction.

Remark 6.5. The WW of a block x and the AW of its
contained transaction ˆx are related, but there is no “mono-
tonicity property”. If x is only contained in the block x we
have that AW(ˆx) ≤ WW(x). If x is contained in more
than one block 9, we can have that the AW of the transaction
is even larger than the WW of each enveloping block.

The supporter of transactions can be updated using
propagation of the supporter information through the voting
DAG. More precisely on arrival of a block x we traverse
cone(p)
V (x). We propose Algorithm 2 to update transactions
supporters when a new block is processed. The AWs are
then updated using Equation (14).

Similar to Deﬁnition 4.5 we deﬁne the conﬁrmation of
a transaction. We will use subscripts i and t such as AWi,t
if we talk about the perception of the ith node at moment
t.

Deﬁnition 6.8 (Conﬁrmed transaction). Let θ ∈ (0.5, 1] be a
ﬁxed threshold. We say that a transaction ˆx ∈ L is conﬁrmed
for a node i ∈ N at time t if AWi,s(ˆx) ≥ θ, for some s ≤ t.

We also deﬁne the AW of a branch, which will form the
base for the algorithm in the next section. The supporters
of a branch are equal to the intersection of the supporters
of the conﬂicts in the branch. More formally we have the
following.

Deﬁnition 6.9 (Branch Supporters and Approval Weight).
Let B ∈ B be a branch. We deﬁne sprtL
i,t(B) to be the set
of nodes that issued blocks that approve all conﬂicts in B.
Similarly we deﬁne the AW for B as

AW(B) :=

(cid:88)

w(j).

(15)

j∈sprtL(B)

We deﬁne the AW of the main branch, i.e. the empty set ∅,
to be 1.

9. A fund owner may request several nodes to broadcast a transaction

ˆx, or a node may issue several different blocks with ˆx contained.

Data: Tangle DAG DT , Ledger DAG DL, new
block x issued by node j, {sprtL(y)}y∈L

Result: updated {sprtL(y)}y∈L

V (x) ∩ L do

sprtL(z) ← sprtL(z) ∪ {j}

1 for ∀z ∈ cone(p)
2
3 end
4 for ∀z ∈ L that are conﬂicting with cone(p)
5
6 end

sprtL(z) ← sprtL(z) \ {j}

V (x) do

6.5. Tip Selection Algorithm

The consensus protocol relies substantially on an im-
plicit voting mechanism. Nodes express their opinions and
votes by choosing the references in their newly issued
blocks. The process that determines the references is called
the Tip Selection Algorithm (TSA) and is discussed in this
section.

With every block, a node can vote on which parts of
the Tangle and the Ledger DAG it prefers by using block
or transaction references. The preferred parts of the Tangle
and the Ledger DAG are deﬁned by the preferred reality.
Following the algorithm described in Section 5.3, a node i
at moment t keeps its preferred reality R = Ri,t up to date.
We now describe a tip selection mechanism that con-
siders both block and transaction votes. Note that due to
Lemma 6.1 the Ledger DAG induces a partial order consis-
tent with the one induced by the Tangle and, thus, voting on
the Ledger DAG allows expressing a more selective, albeit
less efﬁcient vote than on the Tangle.

Let us deﬁne some reality-dependent tip sets on the

Tangle DAG and the Ledger DAG.

Denote by TT (R) ⊂ T the tips in the Tangle DAG
whose Tangle past cones contain only transactions in reality
R. More precisely, for any x ∈ TT (R), there is no y ∈
cone(p)

T (x) such that ˆy ∈ C \ R.
Denote by TL(R) ⊂ L the tips in the Ledger DAG
whose past cones contain conﬂicts from R only. In other
words, it holds that for any ˆx ∈ TL(R), there is no ˆy ∈
cone(p)
L (ˆx) such that ˆy ∈ C \ R. A node should apply the
following tip selection and reference setting.

Deﬁnition 6.10 (Uniform Random Tip Selection on a real-
ity). To issue a new block, node i chooses tips to approve
uniformly at random from all tips in the Tangle DAG until k
references are created. For a randomly chosen tip, the node
proceeds with the following steps:

1) if the selected block is in the set TT (R), a block

reference is created;

2) otherwise, if the selected tip contains a transaction that
is in the set TL(R), a transaction reference is created;
3) if neither of the above apply, the block is discarded

instead.

Algorithm 3: Uniform Random Tip Selection re-
stricted on reality R

Data: Tangle DAG DT , Ledger DAG DL,
preferred reality R ∈ B, number of
references k

Result: tips LT ∪ LL

Choose tip x uniformly at random in DT
Set QV to be conﬂicts contained in cone(p)
Set QL to be conﬂicts in cone(p)
if QV ⊆ R then

L (ˆx)

V (x)

1 LT ← ∅
2 LL ← ∅
3 cnt ← 0
4 while cnt < k do
5

6

7

8

9

10

11

12

13

14

15

cnt ← cnt + 1
LT ← LT ∪ {x}

else

if QL ⊆ R then

cnt ← cnt + 1
LL ← LL ∪ {x}

end

end

16
17 end

We call this algorithm the Uniform Random Tip Selection
Algorithm restricted on the reality R (or R-URTS for short)
and refer to Algorithm 3 for a pseudo code.

We refer to Appendix B, where we demonstrate this

algorithm as part of an illustrated example.

A node may have voted previously for a branch that is
no longer its preferred branch. It has therefore to change its
vote. With the above tip selection nodes are allowed to vote
for branches they previously did not “prefer” (by voting for
a conﬂicting transaction) and vote “against” branches they
previously voted for. Every node must therefore keep the
supporters for each branch and their AW up to date. An
important consequence is that the AW of certain branches
may increase in time while for others it may decrease in
time.

The addition of the transaction vote demonstrates that
solutions for the Tip Selection Algorithm can be found
that mitigate or reduce liveness issues and that transactions
eventually will be considered for tip selection. Thus, in the
following, we work under the following assumption.

Assumption 6.2 (Block inclusion). Let R be the preferred
reality. The tip selection satisﬁes that for every transaction
ˆx ∈ L(R) (see Deﬁnition 5.12) we have that there is at least
one element in cone(f )
V (x) that the tip selection algorithm
can pick up. In particular, there exists at least one available
tip in the union TT (R) ∪ TL(R).

We also refer to Section 12 for a more detailed discus-

sion.

7. Communication and Adversary Models

Before stating the security requirements of the protocol,
we have to make assumptions about the underlying com-
munication model. It is common to describe the uncertainty
related to the communication by an attacker that controls the
delays of the blocks. The communication model deﬁnes the
limits the adversary can delay the communication between
the nodes. As a model, it is only a simpliﬁcation, but it
allows a systematic study of the most critical components.
For simplicity, we also analyse the voting mechanism
without details such as the TSA. We want to emphasise that
our modelling can also be applied to other consensus pro-
tocols, thus, providing a framework for comparing different
DLTs.

7.1. Communication Model

The participating nodes communicate over a peer-to-peer
(P2P) protocol or network. In this P2P protocol, nodes send
their signed blocks to their neighbouring peers. Neighbours
forward blocks from other nodes in the overlay network only
if they have veriﬁed its validity; if a transaction is invalid, the
propagation stops. The transmission of a block between two
nodes is done by sending a package containing the block.
There are three basic (or classic) models for the P2P
communication between the nodes: the synchronous model,
the asynchronous model, and the partial synchronous model,
e.g. see [60] and [61].

In the synchronous model, there exists some known ﬁnite
time bound ∆ by which an adversary can delay the delivery
of a package. In the asynchronous model, an adversary can
delay the delivery of a package by an unknown ﬁnite amount
of time. There is no bound on the time to deliver a block
but each package must eventually be delivered. In the partial
synchronous model, we assume that there is some ﬁnite
unknown upper bound ∆ on block delivery. This bound is
not known in advance and can be chosen by the adversary.
A partially synchronous system can be seen as initially
asynchronous that becomes eventually synchronous. The
time at which the system becomes synchronous is called
the Global Stabilisation Time (GST).

We also consider a probabilistic synchronous model,
see [49]. In this model we assume that for every ε > 0 and
δ ∈ [0, 1], a proportion δ of the blocks is delivered within
a bounded (and known) time ∆ = ∆(ε, δ), that depends on
ε and δ, with probability of at least 1 − ε. The probabilistic
synchronous model is similar to the asynchronous model
with crash failure faults, see [61].

The speciﬁc implementations for a consensus mecha-
nism depend heavily on the underlying synchronicity as-
sumption. It also seems appropriate to distinguish between
consensus protocols that ﬁnd consensus on one data set
and consensus protocols that ﬁnd consensus on a growing
number of decisions. The latter allows to “strengthen the
synchronicity” between the nodes if the data are related by
references.

7.2. The Tangle, Solidiﬁcation, and Synchronicity

The references that form the Tangle are essential for
the consistency of information every node has. Consider
that a package propagates to only part of the network,
e.g. lost during some of the propagation processes on the
communication layer. However, nodes that have received
the block start building on it and gossip their blocks to
the network. These new blocks contain references to the
partially missing block. Since nodes must know the past
cone of any block to have a complete Tangle history from
that blocks’ point of view, we use a mechanism called the
solidiﬁcation process. In this mechanism, nodes that receive
a given block only process it if its past cone is complete
or, otherwise, ask their peers for the missing referenced
block (for more details, see Section 4.3). In other words,
the solidiﬁcation process is a mechanism to recover lost
blocks and, hence, strengthens the “synchronicity” of the
communication model. We think that this, to some extent,
supports the assumption that all blocks are delivered within
a bound time ∆ with high probability.

7.3. Adversary Model

We distinguish between three types of nodes: honest,
faulty, and malicious. Honest nodes follow the protocol,
faulty nodes are not working properly (e.g. not sending
any transactions), and malicious nodes are trying to disturb
the protocol by not following the rules actively. In most
scenarios, we assume that the malicious nodes are controlled
by an abstract entity that we call the attacker. We assume
that the attackers are computationally limited and cannot
break the signature schemes or the cryptographic hash func-
tions involved. However, we assume that the attacker is
omniscient and “knows immediately” about all state changes
of the honest nodes.

In classic consensus protocols,

the communication
model already covers the adversary behaviours, as delaying
blocks is essentially the only way an attacker can inﬂuence
the system. This is no longer true for our consensus protocol.
Here, adversarial strategies can be divided into two main
categories: attacks on the protocol level and attacks on the
voting layer.

7.4. Conﬁguration Graph and Schedule

How events in distributed systems are triggered depends
on some external causes that are often referred to as the
environment. We follow [62] and model this environment
using the abstraction of a scheduler.

To this end, we consider a communication network on
which all communications between the nodes are carried
out. These networks are often referred to as P2P networks.
We model them using a directed graph whose vertex set is
the set of participating nodes. There is a directed edge from
i to j, if node i can send packages directly to node j.

w

y

z

6

u

2

x

1

z

z

x

x

3

y

4

y

5

Figure 9: Illustration of a network of 6 nodes. Packages
u, w, x, y, z are send along directed edges representing com-
munication channels.

We assume this graph to be connected. Along the di-
rected edges of this graph packages are exchanged by the
nodes. In our case these packages contain blocks.

Deﬁnition 7.1 (Packages and communication graph). For
each block x sent from node i to node j we add a directed
edge, called package, from i to j that is labelled by the
vector

e(x, i, j) := (x, i, j, t(x), δi,j(x)).

(16)

This label indicates that package x was sent at time t(x)
from node i and arrives at node j at time t(x)+δi,j(x). The
state space of all packages is denoted by M. We dub the
resulting graph the communication graph G of the protocol.

Essentially a node i does the following once it receives
a package e from node j. It checks if the block x that is
contained in the package e was already treated. If this is
the case, the node’s status remains unchanged, and no new
package is issued. If the block is new, the node checks its
validity and adds the block to its local Tangle. If applicable,
it updates the supporters of branches and conﬂicts and, if
the transaction contained in the block is conﬂicting, adds a
new conﬂict to the set of conﬂict. After this step, the node
forwards the block in new packages to all its neighbours
from which the node has not received the block.

A node may also create blocks. Once it creates a block
x, it attaches x to its local Tangle. Then, it creates a package
e containing block x and sends copies of this package to all
of its neighbours.10

Example 7.1. We illustrate the concept of networks and
packages in Figure 9. In this ﬁgure, the network consists of
six nodes. Directed edges exist between some of them and
show the communication channels. We point out that these

10. In this example, we use a ﬂooding protocol for the dissemination of

blocks.

communication does not necessarily have to be symmetric.
Packages containing blocks can be sent along the edges.

Every node keeps a local version of the Tangle DTi that
we consider as the (local) conﬁguration ωi of node i. For
ease of presentation, we consider the following simpliﬁed
version of the OTV that does not keep track of where the
actual blocks are attached in the Tangle but only keeps track
of the supporters of the branches or conﬂicts. The (local)
state space is therefore given by Q = 2N × . . . × 2N
, where
(cid:125)

(cid:124)

(cid:123)(cid:122)
|C|

C is a ﬁxed set of conﬂicts and 2N is the set of all possible
subsets of N = {1, . . . , N }.

Remark 7.1. The simpliﬁed version described above allows
the voting on conﬂicting
a more accessible analysis of
transactions. This comes with the cost of not describing the
conﬁrmation of non-conﬂicting transactions. We give more
details on the “liveness” of these transactions in Section 8.1.

We interpret the packages a node i receives as input
assignments with values in the space of all packages M.
Each input assignment e yields an update of the current
conﬁguration, and each conﬁguration ωi leads to an output
assignment. We therefore consider two functions

and

I(e, ωi) : M × Q (cid:55)→ Q,

O(ωi) : Q (cid:55)→ M|Ni|−1,

where Ni are the neighbours of node i in the communication
graph G. A node i runs an algorithm A = (I, O) that
reacts to incoming packages by updating its internal state
ωi and eventual sending outgoing packages indicating its
state update. We also consider the conﬁguration of the whole
system that takes values ω = {ω1, .., ωN } ∈ QN . The
corresponding algorithm is denoted by A.

The creation of blocks uses randomness (by design)
through the TSA. Moreover, issuing times of blocks may de-
pend on the interactions of the node with the environment of
our system. For this reason, we model the time between two
successive blocks of one given node by random variables.
oreover, the latency between packages of two given nodes
is described by random variables. This randomness turns
our protocol into a random protocol, and the randomness is
described by the probability measure P. As we consider a
simpliﬁed model and are only interested in the supporters
of given branches, the randomness enters only in the “time
components” of the packages or edges. Consequently, edges
become random variables.

Deﬁnition 7.2 (Conﬁguration graph). Let e be a package
sent from i to j in G and ω, ω(cid:48) ∈ QN be two (global)
conﬁgurations. We write ω e→ ω(cid:48) if and only if

i) > 0

P(I(e, ωi) = ω(cid:48)
for some i and, P(ω(cid:48)
l = ωl) = 1 for all l (cid:54)= i. We say that ω(cid:48)
is accessible from ω by e. The notation of accessibility
deﬁnes a directed graph on the set of (global) conﬁgurations
that we dub the conﬁguration graph of the algorithm.

Deﬁnition 7.3 (Valid packages). A package (or edge) e from
node i to node j is called valid given a global conﬁguration
ω if and only if

P(O(ωi) (cid:51) e) > 0.

In other words, any valid edge must be the outcome of the
algorithm A. A sequence of edges e1, e2, . . . is called valid
given an (initial) conﬁguration ω(0) if and only if e1 is valid
given ω(0) and inductively e(cid:96) is valid given ω((cid:96) − 1), where
ω((cid:96) − 1) is such that ω((cid:96) − 2)

e(cid:96)−1→ ω((cid:96) − 1).

In the following, we assume that honest nodes only issue

valid packages.

Deﬁnition 7.4 (Communication of conﬁgurations). We say
that the (global) conﬁguration ω(cid:48) is accessible from a con-
ﬁguration ω if and only if there exists a ﬁnite valid path from
ω to ω(cid:48) in the conﬁguration graph. In this case, we write
ω → ω(cid:48) We deﬁne that a conﬁguration is accessible from
itself. Two conﬁgurations ω and ω(cid:48) are said to communicate
if and only if they are accessible from each other. In this
case, we write ω ↔ ω(cid:48).

The relation ↔ deﬁnes an equivalence relation on the

set of conﬁgurations.

Deﬁnition 7.5 (Communication classes). The equivalence
classes of the equivalent relation ↔ are called the commu-
nication classes of the set of conﬁgurations. A (communica-
tion) class is called closed if and only if it has no outgoing
edges, and open otherwise.

The closed communication classes play a vital role as
they describe the outcome of the protocol. Let R ∈ B be a
reality. Then the conﬁguration with sprtLi(R) = N for all
i ∈ N is a closed class. Let us note here that we are still
assuming all nodes to be honest and behave according to
the protocol.

Deﬁnition 7.6 (Consensus state). A state ω is called a
consensus state if and only if

sprtLi(R) = N ,

∀i ∈ N ,

(17)

for some reality R.

Remark 7.2. Let us stress that the deﬁnition of “consensus
state” is only about agreeing on the preferred reality. It does
not take into account the meaning of conﬁrmation; see Def-
inition 4.6. Liveness and safety with respect to conﬁrmation
are discussed in the following sections.

We make a crucial assumption about the communication

layer.

Assumption 7.1 (Random block issuance and package de-
lay). Block issuances and package delays are random and
satisfy:

1) Nodes issue new blocks independently and distributed

according to some probability distribution µiss.

2) The delays of packages between two nodes are inde-
pendent and distributed according to some probability
distribution µpack.

3) Block issuances and package delays are independent.
4) With a positive probability packages are delivered
faster than new blocks are issued. More precisely, if
X ∼ µiss and Y ∼ µpack, then P(Y < X) > 0.
Lemma 7.1. Under Assumption 7.1, for every given conﬁgu-
ration ω there exists a consensus state ωc such that ω e→ ωc.
Proof. Let ω be a conﬁguration. We wait until all existing
packages and corresponding changes of votes are sent to
all other nodes. During this time, no new block is issued
with a positive (non-zero) probability. After every node has
seen all current blocks every node has the same perception
of the supporters of the different realities. In other words,
nodes agree on the AWs of the different branches. Now,
every node changes its opinion to its preferred reality, issues
transactions indicating their change of vote, and gossips
them using packages on the communication graph. Once
all these packages are seen by all nodes a consensus state
is reached.

There are two immediate consequences of Lemma 7.1.

Corollary 7.1. Under Assumption 7.1, a communication
class is closed if and only if it consists of one consensus
state.

Corollary 7.2. Under Assumption 7.1 (and in absence of
an adversary), the protocol converges (P-almost surely) to
a consensus state.

Deﬁnition 7.7 (Schedule). A schedule on the communica-
tion graph G is a sequence of (ﬁnite or inﬁnite) valid edges
e1, e2, . . .. A (ﬁnite or inﬁnite) execution of a sequence of
edges e1, e2, . . . by A on G is a sequence of conﬁgurations
ω(0) e1→ ω(1) e2→ · · · , where ω(0) is the initial (global)
conﬁguration.

The above deﬁnitions can naturally extend to models
that distinguish between honest and adversary nodes. We
assume that adversary nodes do not have to follow the
algorithm A but can produce messaging voting for non-
preferred realities. On the communication level, adversary
nodes may be more potent than honest nodes, i.e. issuing
blocks more frequently, and may delay the relaying of
honest packages. Nevertheless, we assume that Assumption
7.1 holds for all honest and malicious nodes. We say that
the protocol reaches a consensus state if all honest nodes
eventually prefer the same reality. Let us denote by Nh and
Na the set of honest and malicious nodes. In analogy to the
above, we obtain the following result.

Theorem 7.1 (Eventual consistency - random blocks). As-
sume Assumption 7.1 to hold for the blocks and packages
of honest and malicious nodes and let q be the weight of
the adversary. Then, all honest nodes will (P-almost surely)
eventually prefer the same reality if q < 1/2.

Proof. Since q < 1/2 a consensus state is reached if all
honest nodes have the same preferred reality and all nodes
know about it, i.e.

for some reality R. We have to prove that for every given
conﬁguration ω there exists an available consensus state.
This is proven similar to Lemma 7.1 together with the
situation where an adversary is neither issuing a block nor
can delay the honest packages, which occurs with a positive
probability under Assumption 7.1.

8. Liveness and Safety

In the previous section, we were interested in the even-
tual convergence and proved an optimal result in Theorem
7.1 under the assumption of random blocks issuance and
random package delay. This section adds the conﬁrmation
status of transactions into our considerations. We divide
security into liveness and safety to allow a more detailed
and quantitative analysis.

From a general point of view,

liveness means that
eventually, good things will happen, and safety means that
nothing wrong will ever happen. In our situation, this trans-
lates into the following. The safety condition is that any
two honest nodes should always reach an agreement and
that this decision satisﬁes the speciﬁed validity conditions.
Furthermore, no two nodes should ever conﬁrm conﬂicting
transactions. The liveness property is that each honest node
should eventually make a decision on the conﬁrmation status
of a transaction, i.e. in our case all nodes reach the conﬁr-
mation threshold θ, see Deﬁnitions 4.5 and 6.8, eventually.

Remark 8.1. In general, one requires in addition that the
consensus protocol satisﬁes integrity. Integrity requires that
the eventual outcome of the consensus protocol was initially
proposed by at least one node. Since in OTV honest nodes
always pick a maximal branch, the integrity property is
satisﬁed once the protocol terminates.

8.1. Non-Conﬂicting Transactions

Liveness of a non-conﬂicting transaction is the prop-
erty that it will eventually be included in the ledger state.
In the strongest form, it means that every non-conﬂicting
transaction will be conﬁrmed, see Deﬁnitions 4.5 and 6.8.
Therefore, the security threshold for liveness is at most a
proportion (1 − θ) of the weight, as an attacker or faulty
nodes holding a proportion (1−θ) can stop the conﬁrmation
by not issuing any blocks anymore.

Liveness is inherently linked with the TSA and the
orphanage problem. We assume the following Assumption
on the TSA11 and we refer to Section 6.1 for a discussion.

Proposition 8.1 (Liveness and safety of non-conﬂicting
transactions). We assume in the asynchronous model that
the tip pool size is stationary, and that Assumption 6.2 is
satisﬁed. The weight of the malicious nodes is q. Then,
eventually every non-conﬂicting transaction is conﬁrmed for
all honest nodes if q < 1 − θ.

Proof. Let x be a block containing a non-conﬂicting trans-
action ˆx and consider an arbitrary honest node i. Each time

sprtLi(R) ⊃ Nh,

∀i ∈ Nh,

(18)

11. Formally it is more a requirement on the deﬁnition of “tips”.

this node issues a new block, the probability that it refers
to (and votes for) x is positive, due to Assumption 6.2.
At this point, it is important to have the second type of
reference that allows to only vote for the transaction ˆx and
not the whole Tangle past cone of x. Let us denote by pj
this last probability for the jth issued block. Then, due to
the assumption on the stationarity of the tip pool size, there
exists some ε > 0 such that pj ≥ ε for inﬁnitely many
indices j. Assumption 6.2 guarantees the independence of
these events, and the Lemma of Borel-Cantelli implies that
node i eventually votes for block x. Then, since the number
of nodes is ﬁnite, all nodes eventually vote for x.

Some discussion on the validity of the stationary tip pool
size assumption is appropriate. This kind of assumption was
also made throughout Section 4.7 as Assumption 4.3. Let
us review this assumption in the light of the communication
and the adversary model.

An attacker can delay blocks with honest transactions
such that the network delay h increases. This, in turn, will
inﬂate the tip pool size and the time to conﬁrmation [63]. In
the asynchronous model, this could lead to memory overﬂow
of the nodes or halt conﬁrmation of certain transactions.
While this attack is theoretically possible in this model, it
is more of a theoretical interest than a practical issue. We
also want to note here that nodes do have an efﬁcient way
to “synchronize” their perceptions of the Tangle due to the
solidiﬁcation process; see Section 7.2.

On the Tangle layer, the “worst-case scenario” seems to
be the following. The adversary issues blocks, referencing
already referenced blocks, not removing any tips from the
tip pool. Under the assumption that nodes can issue blocks
proportionally to their weight, we obtain that q/(1−q) mali-
cious blocks are issued for each honest block. Honest nodes
can increase the number of references to keep the Tangle
width stationary. More precisely, it is sufﬁcient that the hon-
est nodes’ blocks, on average, remove K := (q/(1 − q)) + 1
tips. In other words, we can choose the number of references
k > K to guarantee robustness against this attack. For
instance, q = 1/2 leads to K = 2.

9. Impossibility Results and Metastability

Impossibility results play an essential role in the theory
of consensus protocols, as they emphasize the limitations
and critical edge cases. The most famous impossibility result
is the FLP-result, [19], which states that achieving consensus
in the asynchronous communication model is in general
impossible for deterministic protocols. From a general point
of view,
this impossibility is due to the possible delay
of packages in the P2P communication and the resulting
“symmetric” situation that hinders consensus ﬁnding.

We will consider the situation of two or more directly
conﬂicting transactions. It is the role of the consensus mech-
anism to reach an agreement on which transaction should
eventually be accepted. One may consider that keeping
conﬂicting transactions in an undecided state, i.e. violating
the liveness, is acceptable. However, this is problematic
for several reasons. For example, if nodes keep transac-
tions indeﬁnitely undecided, this could drastically inﬂate
the communication required on the voting layer and prevent
the pruning capability of the ledger. Transactions that are
undecided for a long time can also harm safety. There is
always a chance that some node conﬁrms an “undecided”
transaction. While the probability of this event might be
small, it is still positive, and hence this unlikely event will
happen at some point in time. We also note that simply
rejecting malicious transactions does not provide a solution
since this would allow delayed cancellation of transactions,
thus, violating the system’s safety.

In this section, we give examples where the liveness
and safety of conﬂicting transactions are not satisﬁed; more
complicated examples can be constructed following the
same principles. They constitute an impossibility result in
the sense that the proposed protocol does not guarantee
liveness or safety under the asynchronous communication
model. These situations rely on strong assumptions about
the attackers. We distinguish between attacks on the com-
munication level and those on the voting level. By requiring
both levels we give a theoretical result when safety cannot
be guaranteed, Lemma 9.1.

8.2. Conﬂicting Transactions

9.1. Communication Level

Theoretical results on the liveness and safety of con-
ﬂicting transactions rely heavily on the assumptions of the
underlying communication and adversary model. Moreover,
the analysis of the OTV protocol is complex: it requires
modeling of the networking part, modeling of the weight
distribution, and various (even an inﬁnite number of) ad-
versarial strategies. The following section shows that an
adversary can hinder consensus ﬁnding in speciﬁc situa-
tions or edge cases. However, we want to emphasize that
this interference only inﬂuences the liveness of conﬂicting
transactions and that an appropriate TSA guarantees liveness
8.1. In
of non-conﬂicting transactions; see Proposition
Section 10, we add a feature to the protocol that allows
us to obtain theoretical results on the liveness of conﬂicting
transactions.

We start with an example where an attacker does not take
part directly in the voting but only controls the schedule of
the honest nodes’ blocks. Let us point out that the attacker
does not need to control any weight in this scenario.

The ﬁrst adversary attack is dubbed a metastability at-
tack since it tries to keep the honest nodes in an undecided
situation. We refer to [50] for more details and analysis of
these kinds of attacks. On a conceptual level, these kinds
of attacks exploit a situation where the system is kept in
a roughly symmetric condition between two incompatible
options. Once the symmetric scenario is broken, nodes likely
converge quickly on one of the options.

Example 9.1 (Metastability Attack I). We consider N = 4
participating nodes {1, 2, 3, 4} that communicate directly;

δ

γ
−
δ

Current opinion
of a node

Local record
of votes

Figure 10: Illustration of Example 9.1. Nodes are voting
for transaction ˆx (blue) or ˆy (orange). Each node ends up
with the opposite opinion it started with, thus, creating a
deadlock.

the communication graph is the complete graph with four
vertices. We assume that every node has the same weight,
i.e. mi = 1/4 for all i ∈ N . We consider the scenario of
a simple double spend. The set of conﬂicts is, therefore,
{ˆx, ˆy}. We assume for the sake of simplicity that a node
prefers its own opinion if both conﬂicts have 50% of AW.
Nodes 1 and 2 starts with an initial
like of conﬂict ˆx
and nodes 3 and 4 prefer ˆy. At the time t0, every node i
communicates its vote to each of its neighbors by attaching
a block xi. The attacker delays these blocks (more precisely,
the corresponding packages) either by some δ > 0 or γ > δ.
More precisely, we have the following edges, as deﬁned in
Equation (16), in our communication graph:

(xi, i, 3, t0, δ), (x1, i, 4, t0, δ),

i ∈ {1, 2},

(xj, j, 1, t0, δ), (xj, j, 2, t0, δ),

j ∈ {3, 4},

and

(x1, 1, 2, t0, γ),(x2, 2, 1, t0, γ),
(x3, 3, 4, t0, γ),(x4, 4, 3, t0, γ).

At time γ this schedule leads to an inversion of the pre-
ferred conﬂicts, see Figure 10. An attacker that controls
the communication level could therefore delay consensus
ﬁnding arbitrarily. To make the description of the former
attacker more formal, we must specify the assumption on
the issuance of block and the communication model. For
instance, in the synchronous model, with a known upper
bound ∆ on the network delay, such an attack is successful if
the δ, γ < ∆ and the honest nodes issue blocks periodically.
In the asynchronous setting, an attacker can adjust the delays
δ and γ even if the honest nodes do not continuously issue
their transactions simultaneously.

Remark 9.1. The situation described above is undoubtedly
a special case and mainly of theoretical interest. However,
it raises the question under which conditions such schedules
exist and how realistic they appear in real applications.

9.2. Voting Level

In this section, we describe situations, where an at-
tacker can successfully interfere in the consensus ﬁnding
by using the voting layer. We do not need conditions to
control communication between honest nodes but relatively
strong assumptions about the adversary’s ability to issue new
blocks and reliably forward them to the honest nodes.

Example 9.2 (Metastability Attack II). We again consider
the situation of one double spend, i.e. a set of conﬂicts
{ˆx, ˆy}. In this attack, the adversary votes for the minority,
i.e. the conﬂict that has less AW. The attack is supposed
not to inﬂuence the communication layer, and we work
under the assumption of the synchronous communication
model. We assume that the propagation of blocks happens
fast, i.e. each block causes a state update in all other nodes.
Furthermore, we assume that the adversary can issue at a
high rate, such that for every other honest node’s block, the
adversary can issue a block.

We consider an even number Nh of honest nodes and
three malicious nodes, and where each node holds the same
weight. We say if a node votes for ˆx or ˆy it is in set X
and Y , respectively. The protocol starts with 1/2Nh honest
nodes initially voting for ˆx and 1/2Nh honest nodes voting
for ˆy. We refer to Figure 11 for an illustration. Next, the
adversary votes for ˆx (with all three nodes), resulting in
a vote of |X|/|Y | = (1/2Nh + 3)/(1/2Nh). Nodes in X
will continue to vote in favour of ˆx. On the other hand, an
honest node in Y will eventually change its vote and issue
a transaction in favor of ˆx, thus, changing from set Y to X.
Now, before any other honest nodes can express their vote,
the attacker switches its vote to ˆy. Hence, in total we have
|X|/|Y | = (1/2Nh +1)/(1/2Nh +2). Honest nodes will now
vote for ˆy. However, as soon as a node from X changes
its vote, the resulting situation is symmetric to the initial
condition. Thus, the adversary can repeat this ad inﬁnitum.

Remark 9.2. We want to note that in Example 9.2 the
attacker heavily relies on the capability of an adversary
to immediately adapt its opinion before more than 2 honest
nodes changed their vote to the majority.

The next example, the Bait-and-Switch Attack, depends
less on the adversaries issuance rate but requires a higher
amount of weight.

Example 9.3 (Bait-and-Switch Attack). We consider a sit-
uation where the adversary possesses the node with the
highest weight. The strategy is to switch frequently the
opinions such that the honest nodes are constantly “ chasing
the ever-changing heaviest branch”. For example, consider
Nh honest nodes with total weight wh and individual weight

Honest nodes

Malicious nodes

t
i

m
e

Figure 11: Illustration of Example 9.2. Nodes are voting for
transaction ˆx (blue) or ˆy (orange).

wh/Nh and one adversary node with weight wa. Let ncr be
the largest natural number such that

ncr ·

wh
Nh

< wa.

In the beginning, the malicious node spends an output in a
transaction ˆx1. Then, before ncr nodes with a total weight
of less than wA express their vote, the adversary spends
the same output in transaction ˆx2, i.e. creates a conﬂicting
transaction with ˆx1, and (implicitly) votes for the new
transaction ˆx2. Since ˆx2 becomes the heaviest branch, all
honest nodes will vote for this transaction. The adversary
repeats this procedure by creating additional double spends
repetitively.

9.3. Communication and Voting Level

In the previous sections, we presented examples of how
an adversary can harm the liveness of conﬂicting trans-
actions. The attacker strategies required either substantial
control of the communication layer or a high issuance rate
combined with considerable weight. In this section, we
prove an impossibility result for safety that involves an
attack strategy that uses both levels.

Deﬁnition 9.1 (Broken safety). We say that safety is broken
if and only if there exist two honest nodes i, j and conﬂicting
transactions ˆx and ˆy such that for some times s, t we have

AWi,t(ˆx) > θ and AWj,s(ˆy) > θ.

We have the following “negative” result.

Lemma 9.1. Let q > θ −0.5 be the weight of the adversary.
Assume that
the honest nodes is equally
distributed on sufﬁciently many honest nodes. Then, there
exists an adversary strategy that breaks safety.

the weight of

.

<

<

θ − q
1 − q

0.5
1 − q

Proof. Let us choose a number of honest nodes Nh sufﬁ-
ciently large such that there exists some N ∗
h < Nh such
that

N ∗
h
Nh
An attacker starts issuing two conﬂicting transactions ˆx
and ˆy. The attacker decomposes the honest nodes into two
groups X and Y such that each of these groups forms a
connected subgraph of the underlying communication layer,
while the attacker is connected to both groups. Group X
consists of N ∗
h nodes.
The attacker interferes with the schedule such that nodes
in each group only receive blocks from their group. The
attacker changes the schedule such that the nodes in X
receive transaction ˆx before ˆy and the nodes in Y receive ˆy
before ˆx. All honest nodes prepare their initial statement of
their preferred transaction (ˆx for group X and ˆy for group
Y ) and send them to their neighbours.

h nodes and group Y of Nh − N ∗

The attacker sends to X blocks that state that it prefers
ˆx. As a consequence, nodes from X conﬁrm transaction ˆx
since AW(ˆx) = (1 − q) N ∗
h
Nh

+ q > θ.
After this, the attacker sends blocks to Y (and X) that it
votes now for transaction ˆy. Without the vote of the attacker
for transaction ˆx the AW of ˆx in X reduces to AW(ˆx) =
(1 − q) N ∗
h
Nh

Next, the attacker lets X know about the preferences of
Y . At this point AW(ˆy) > AW(ˆx) and as a consequence
nodes from X update their preferred reality and vote for ˆy.
This eventually leads to AW(ˆy) > θ for all nodes. As by
Deﬁnition 9.1 safety is broken.

< 0.5.

The above proof indicates that the attacker needs very
strong control over the communication layer to conduct such
an attack. Nevertheless, it gives a reasonable theoretical
security threshold for the protocol’s safety. All the more
since we can prove safety under the assumption q < θ − 0.5
in Section 10.

9.4. Realistic Conditions

The above examples illustrate that the two dimensions,
namely the communication and voting level, may interact
either in favor of the attacker or in favor of the robustness
of the protocol. In all cases,
the attacker
needs excellent control of the communication layer of the
protocol. Randomness or uncertainty on the communication
layer may interfere with the adversary strategy and ﬁnally
lead to convergence of the honest nodes’ opinions.

it seems that

We conjecture that these strong assumptions are not met
in most reasonable real-world scenarios and that the attacks
that rely solely on the communication level are hard to
perform in practice.

With a completely random schedule of packages, the
system will eventually converge to a consensus state in sit-
uations where an attacker controls not more than half of the
total weight, see Theorem 7.1. However, this convergence
time can be impracticably long for real-world applications
and it is possible that safety (for the conﬁrmation) can be

broken as shown by Lemma 9.1. The theoretical treatment
of the inherent randomness of real-world implementation
systems is at best in an early state, and a quantiﬁcation
or even its control seems currently out of reach. We refer
to [62] for a theoretical approach to describe the entropy
related to the scheduling of the transactions.

The following section proposes a more sophisticated
variation that allows a more straightforward theoretical treat-
ment and provides the “optimal” safety thresholds.

10. Synchronized Random Reality Selection

In the previous section, we demonstrated that under
several conditions, the protocol presented so far might lead
to situations where nodes cannot come to an agreement be-
tween several valid options. This section offers a mechanism
to overcome this scenario by utilising external randomness.
As shown in [50], [64], [65] common randomness can
successfully navigate a system away from such an undesired
situation.

Pre-consensus classes are those classes from which the
network reaches a consensus eventually. The aim of the
design of the consensus protocol is, therefore, to construct
the protocol so that its global state reaches such a pre-
consensus state fast and that from there, the actual consensus
state is inevitable.

The OTV is an asynchronous protocol and comes with
advantages and disadvantages. One disadvantage is the lack
of synchronization possibilities between nodes that could be
used against adversarial attacks on the communication level.
The arguments and examples in the previous section showed
that it is theoretically possible for an attacker to keep the
honest nodes in an undecided situation for a long time. To
exclude these cases and obtain theoretical results, we use
a distributed random number generation (dRNG) process
to synchronize the nodes and interfere with a possible
adversary.

We choose a parameter D describing the length of
epochs between synchronizations times. In other words,
once in every D time units, we synchronize the nodes with
the help of a given dRNG process. This procedure is inspired
by the paper [64], where a dRNG is used to construct a
voting-based consensus protocol in a Byzantine environ-
ment. The dRNG allows the consensus protocol to reach
a pre-consensus state with a positive (non-zero) probability.
This probability is uniform in the opinions and votes of the
nodes, and hence, the protocol enters a pre-consensus class
in a geometrically distributed number of periods of length
D. In the last step, we then prove that consensus is reached
from the pre-consensus state.

We consider a system of N = Nh + Na nodes with
Nh honest nodes and Na adversarial nodes. The honest
nodes are identiﬁed with the set Nh = {1, . . . , Nh} and
the adversarial nodes with Na = {Nh + 1, . . . , Nh + Na}.

We start with stating our model assumptions.

Assumption 10.1. We make the following assumptions:
10.1.1 Every block from an honest node is received by another
honest node during time d = d(ε) with probability of

at least 1 − ε. The constant ε > 0 can be chosen arbi-
trarily small. The events for each block are independent
of each other.

10.1.2 The adversary controls a proportion q of the weight.
The adversary might have an inﬂuence on the schedule
of the blocks to the extent of 10.1.1.

10.1.3 The set of conﬂicts C is ﬁxed and does not vary in

time. All nodes perceive the same C.

10.1.4 There exists a dRNG that publishes a random variable
every D unit of times. The random variable is uni-
formly distributed on the interval [0.5, θ], where θ is
the conﬁrmation threshold; see Section 4.5. This value
is received (independently) by every given node before
time d (in every epoch) with a probability of at least
1 − ε.

10.1.5 Honest nodes of cumulative weight of at least θ issue
blocks expressing support for their preferred reality12
at least every D/2 time units with a probability of at
least 1 − ε.

Let us comment on the validity of the above assump-
tions. Assumption 10.1.1 is essentially a probabilistic syn-
chronicity assumption. The fact that the probability ε can be
chosen arbitrarily small is supported by the fact that votes
are blocks in the Tangle that can be re-broadcast or obtained
by solidiﬁcation requests; see Section 7.2. The independence
assumption is essential and the study of correlated errors is
out of the scope of this paper. Assumption 10.1.2 is natural
in a probabilistic synchronous model. Assumption 10.1.3 is
essentially for ease of presentation. As nodes will consider
only conﬂicts of a certain age, older than D, Assump-
tion 10.1.1 ensures that nodes already have the same per-
ception of the sets of conﬂicts with a very high probability.
Assumption 10.1.4 was used in previous work, [50], [64],
[65]. A sequence of such common random numbers can
be either provided by an external source or generated by
the nodes of the system themselves; see e.g. [66]–[71].
Let us stress that it is necessary that the randomness of
the dRNG is not predictable and obtained in each epoch
by the majority of the weight with a positive probability.
However, we do not require that all honest nodes agree on
this random number.13 The last Assumption 10.1.5 is an
(almost) necessary condition to ensure that transaction have
a chance to be conﬁrmed.

In the beginning, before time D, the AWs for each con-
ﬂict c ∈ C grow through votes according to the mechanism
described in Section 6.5. At the end of this initial interval,
every node has its own perception of the AW of a conﬂict
c, written as AWi,D(c).

After the arrival of the ﬁrst dRNG randomness X (be-
tween D and D+d), every honest node chooses its preferred
reality and adheres with it during the next interval of length
D.

12. In other words, for every conﬂict c in the preferred reality the node
issues at least one block stating that the node votes for this conﬂict c
and it doesn’t issue any block stating that the node votes for a transaction
conﬂicting with c.

13. The idea is that a “weak consensus” on the randomness of the dRNG

leads to an eventual “strong consensus” on the ledger state.

ﬁrst accumulation of AW
- active voting

0

D + d

D

2D + d

2D

3D

ﬁrst synchronization - one
change of vote per node

second synchronization
- one change of vote per
node

Figure 12: The different epochs in the synchronisation.

Algorithm 4: Reality selection algorithm with
common coin

Data: Conﬂict Graph GC = (C, E), common
randomness X distributed uniformly in
[0.5, θ]

Result: preferred reality R ∈ B

1 R ← ∅
2 U ← C
3 while |U | (cid:54)= 0 do
4

c∗ ← arg max{AW(c) : c ∈ maxC(U )} ; /* use
max hash(c) for breaking ties */
if AW(c∗) > X then
R ← R ∪ {c∗}
U ← U \ {NC(c∗) ∪ {c∗}}

else

break the while-loop

5

6

7

8

9

end

10
11 end
12 while |U | (cid:54)= 0 do
13

14

15
16 end

c∗ ← arg max{hash(c||X) : c ∈ maxC(U )}
R ← R ∪ {c∗}
U ← U \ {NC(c∗) ∪ {c∗}}

In Algorithm 4, we describe an iterative procedure,
inspired by [72], for choosing a preferred reality by a node.
First, it initialises set R to be the empty set and U to
be the set of conﬂicts C. At every step of the ﬁrst while-
loop, the node ﬁnds a conﬂict c∗ in U with the highest
AW. If AW(c∗) > X,
then we add c∗ to R, remove
all transactions from U conﬂicting with R and repeat this
step. We additionally require c∗ to be from maxC(U ) (see
Deﬁnition 2.6) to guarantee that after adding c∗ to R, the
updated set R is a branch. If AW(c∗) ≤ X, then we run
the next iterative procedure (while-loop) which updates R
by c∗, where c∗ is the conﬂict c in U attaining the largest
hash of the concatenation c||X 14 and proceed similarly until
U becomes empty. By construction, the resulting set R is a
maximal branch or a reality. We summarize these results in
the following proposition.

a transaction ˆx (for a similar deﬁnition of supporters, see
Deﬁnition 6.7). The honest AW of ˆx seen from node i at
time t is deﬁned as

AW(h)

i,t (ˆx) :=

(cid:88)

w(j)

j∈sprt(h)
Li,t

(ˆx)

Due to Assumption 10.1.5 and since the honest nodes
change their vote at most once, every other honest node
sees this vote with a very high probability. In other words,
every honest node has the same perception of the votes of
all other honest nodes (with high probability). In this case,
we can speak of the honest AW seen by the honest nodes of
a transaction ˆx:

AW(h)
t
if it holds that AW(h)
Nh.

(ˆx) := AW(h)

1,t (ˆx)

(19)

i,t (ˆx) = AW(h)

j,t (ˆx) for all 1 ≤ i, j ≤

Adversarial nodes may change their opinions. In partic-
ular, they can do this close to the threshold time D such
that honest nodes may have different perceptions of the
adversarial votes. However, this difference in perception is
bounded by the weight of the adversary. For every c ∈ C
we deﬁne, similar to [72], the regions (or intervals) of
adversarial control as

It(c) = [AW(h)

t

(c), AW(h)

t

(c) + q];

(20)

see Fig. 13. The lower (resp. upper boundary) of this interval
is precisely the overall AW of the conﬂict when all malicious
nodes vote against (resp. for) it.

a)

0

b.1)

no control

region of control

0.5

1 − θ

1

support of random threshold

region of control

no control

0

0.5

1 − θ

1

support of random threshold

b.2)

region of control

no control

Proposition 10.1. The resulting set R in Algorithm 4 is a
reality.

0

Denote by sprt(h)
Li,t

(ˆx) the set of honest nodes seen
from node i at time t that issued a block that votes for

0.5

1 − θ

1

support of random threshold

Figure 13: Region of adversarial control.

14. We assume that c||X can be treated as a binary string for a proper

usage of the hash function as noted in Remark 4.1

We summarize the above considerations in the following

statement.

Algorithm 5: Voting protocol for a node i
1 e ← 0;
2 Xe ← 0;
3 while the node did not conﬁrm a reality do
4

/* epochs index */
/* common random variable */

Obtain reality Ri by Algorithm 4 with Xe
Before time (e + 1)D issue new blocks with
references selected by Algorithm 3 for Ri
Before time (e + 1)D receive new blocks
e ← e + 1
Wait time d to get common r.v. Xe

5

6

7

8
9 end

Lemma 10.1. Assume that the honest nodes have the same
perceptions on the honest AWs. Then, for all i, 1 ≤ i ≤ Nh,
it holds that

AWi,t(c) ∈ It(c).

(21)

The above holds for every adversary strategy that sat-
isﬁes Assumption 10.1.2. The idea is now to choose the
support of the dRNG in such a way that independent of the
honest AWs and the adversarial strategy all honest nodes
will decide on the same reality with a positive probability.
Every D time units we have therefore also a positive prob-
ability that all nodes decide on the same reality. It takes,
hence, a geometrically distributed number of such intervals
until all honest nodes agree on the same reality.

Deﬁnition 10.1. [Convergence to a consensus state] We say
that the protocol converges to a consensus state if and only
if there exist some reality R and some (random) time T
such that

AWi,t(R) > θ, ∀i ∈ {1, . . . , Nh}, ∀t > T.

(22)

Remark 10.1. Deﬁnition 10.1 is similar to the deﬁnition
of a consensus state; see Deﬁnition 7.6. While it describes
the asymptotic behaviour of the protocol, it delivers not
a practicable criterion for conﬁrmation.15 A “conﬁrmation
rule”, as in Deﬁnition 4.6, however, is always susceptible to
possible “re-orgs”16 of the ledger state; see also Lemma 9.1.
Quantifying the probabilities that such re-orgs happen de-
pends on the precise communication and adversarial models
and is out of this paper’s scope.

This discussion can be turned into a formal protocol de-
scription written in Algorithm 5 and we obtain the following
theorem.

Theorem 10.1 (Liveness and safety - Synchronisation). Let
q < min (cid:8)1 − θ, θ − 1

(cid:9)

2

be the weight of
the adversary. Then, under Assump-
tion 10.1, the protocol (described by Algorithm 5) converges
to a consensus state.

15. The “probabilistic” reason for this is that T is not a stopping time.
16. A re-org is the procedure that a transaction that was conﬁrmed is no

longer in the preferred reality.

Proof. We start the protocol at time t0 = 0 with a ﬁxed
set of conﬂicts C of size |C| and let the nodes exchange
their votes until time D. We let ε > 0 be arbitrary but ﬁxed
and determine its value at the end of the proof. Every node
waits until time D + d. If the node received the ﬁrst random
number X1 it will perform Algorithm 4 with X1 as a random
number. If a node did not receive the random number on
time it will use Algorithm 4 with the threshold of θ (instead
of random X1). Between D + d and 2D every honest node
will not change its preferred reality. Let A1 be the event
that all honest nodes voted for their preferred reality and
that these votes are seen by all other honest nodes. Let B1
be the event that all honest nodes expressed their preferred
reality on time, see Assumption 10.1.5, and C1 that all these
blocks arrived at every other honest node before time 2D.
Since A1 = B1 ∩ C1 we have that

P(A1) = P(C1|B1)P(B1)

≥ (1 − ε)|C|Nh(1 − ε)Nh
= (1 − ε)Nh(|C|+1).

At time 2D + d with probability of at least (1 − ε)Nh the
new random number X2 is received by all honest nodes.
Hence, with probability

p(ε) := (1 − ε)Nh(|C|+1)

all honest nodes agree on the honest AWs, deﬁned in
Equation (19) and the threshold X2. We write AW(h)(c) :=
AW(h)
2D (c). Let us note here that no honest node can perceive
the honest AW. However, for the analysis, we assume a
perfect view or total information on the status of the system.
We start a recursive argument on the Conﬂict Graph
by initialising R = ∅ and U = C. Deﬁne the conﬂict
chosen by Algorithm 4 inside the ﬁrst while-loop at every
iteration c∗ := arg max{AW(h)(c),
c ∈ maxC(U )}. We
distinguish two cases.

Case A: AW(h)(c∗) > 0.5. The support of the random
threshold does lie above 0.5; see also Figure 13. More,
precisely, the probability ξA that every node will include this
conﬂict in its preferred reality (using Algorithm 4) satisﬁes
ξA > AW(h)(c∗) − 0.5 > 0. All conﬂicts that conﬂict
with c∗, i.e. the neighbours in the Conﬂict Graph NC(c∗),
are not preferred. Note here, that since every honest node
might have a different perception of the actual AWs, it may
run Algorithm 4 in a different “order”. However, as no two
neighbours in the Conﬂict Graph can have more than 0.5 of
the honest AW, the algorithm treats all “A cases“ before the
following case.

Case B: AW(h)(c∗) ≤ 0.5. In this case, all conﬂicts in
c∗ ∪ NC(c∗) have an honest AW of less than 0.5. (This is
because, in Algorithm 4, nodes treat conﬂicts in the order
of “decreasing AW”.) Since q < θ − 0.5, with a positive
probability ξB none of these conﬂicts will have AWs above
the threshold X2 and none of them will be added to the
preferred reality in the ﬁrst while-loop of Algorithm 4.

We now remove the conﬂicts c∗ ∪NC(c∗) from the set U
and continue this procedure until the set U is the empty set.

We set ξ = min{ξA, ξB}. Let K be the size of the largest
maximal independent set in the Conﬂict Graph. Eventually,
with a positive probability of at least ξK the nodes agree on
the preferred conﬂicts originating from case A. The nodes
have to ﬁll up the maximal branch with the second while-
loop in Algorithm 4. Since they agree on the value of X2
they also agree on the preferred reality.

Altogether, with a positive probability of at least p(ε) ·
ξK all honest nodes vote for the same reality during the
next epoch of length D. If this happens, an AW of more
than θ is obtained in the next epoch. Otherwise, we repeat
this procedure until it is satisﬁed. The number of epochs
necessary follows a geometric random variable.

Remark 10.2. The above proof offers a possibility to es-
timate the “consensus time” T . In fact, its expectation is
bounded above by D · (1 + (p(ε) · ξK)−1). This quan-
titative analysis is one main difference to Theorem 7.1,
where no bounds on the “consensus time” are obtained.
Another crucial difference is that Theorem 10.1 does not
require assumptions on the randomness of the packages and
issuance as in Assumption 7.1.

Remark 10.3. The assumption that the set of conﬂicts is
ﬁxed reduces to the assumption that the set of conﬂicts is
bounded during the run-time of the protocol. The results,
therefore, also apply to sets of conﬂicts that may evolve
over time. However, the quantitative bounds in the proof get
worse for larger sets of conﬂicts.

11. Performance studies

We summarize some of the performance analysis obtained in
[73] via agent-based simulations to validate the performance
of the presented concepts. The used simulator [74] is written
in Go and is open source. In this simulator, the necessary
components of the consensus protocol are implemented,
however, some of them are simpliﬁed. In the following we
give a short description but refer to [73] for more details
and further simulation results.

The simulated environment reﬂects a situation in which
network participants are connected in a peer-to-peer net-
work, where each node has the same number of neigh-
bors. Nodes can gossip, receive blocks, request for missing
blocks, and state their opinions whenever conﬂicts occur.
The underlying network topology is modeled by a Watts-
Strogatz network. In order to mimic a real world behaviour
the simulator allows to specify the network delay and packet
loss for each node’s connection.

Nodes are modeled as different independent agents that
concurrently issue new blocks. This means that different
nodes can have different perceptions of the Tangle and Ap-
proval Weights, at any given moment of time. The number of
nodes does not change during the simulation period, and all
the honest actors are actively participating in the consensus
mechanism. While the simulator allows to model different
weight distributions, we focus here on the case of a Zipf
distribution with s = 0, i.e. every node has the same weight.

Figure 14: Consensus time distributions under Bait-and-
Switch attack, without SRRS (N = 100), taken from [73].

Figure 15: Consensus time distributions under Bait-and-
Switch attack, with SRRS (N = 100), taken from [73].

Here, we focus on the robustness of the consensus pro-
tocol against the Bait-and-Switch attack, 9.3, and illustrate
the inﬂuence of the Synchronized Random Reality Selection
(SRRS) introduced in Section 5.3.

We present simulation studies with the following speciﬁc
setup. We consider N = 100 honest nodes with equal weight
and one adversary node with weight q (out of a total weight
of 1). The block issuance time interval of nodes follows
a Poisson distribution with issuance rates proportional to
the nodes’ weight. The total throughput is approximately
constant at about 100 blocks per second. The parents count
(or number of references) is set to k = 8. The default
to θ = 2/3. The peer-to-
conﬁrmation threshold is set
peer network is a realization of a Watts-Strogatz network
with rewiring probability 1 and 8 neighbors for each node.
The latency between two nodes in the peer-to-peer network
is set to be 0.1 seconds and we assume the adversary to
have no inﬂuence on the communication layer. The maximal
simulation time is set to 60 seconds.

The access to all Tangles of all nodes in the simulator
allows to “objectively” measure the conﬁrmation time as
proposed in [73] for each node. These can be combined
to extract the consensus time, which is deﬁned as the time
between the creation of a conﬂict and the time when all
honest nodes conﬁrm the same spending or branch. As
such, for any given conﬂict, it is strictly larger than the
conﬁrmation time at any node. By measuring the consensus
time, the safety and liveness of the protocol can be analyzed.
Figure 14 shows the consensus time for the Bait-and-

510152025303233Adversary Weight (%)0204060Consensus Time (s)510152025303233Adversary Weight (%)0204060Consensus Time (s)threadedness of our solution, the capability to work in an
asynchronous setting and the leaderless approach can offer
a highly performant consensus and ledger solution. Detailed
and sound performance analysis will be necessary to validate
theoretically predicted properties.

Since the ledger can be progressed without having global
knowledge of new transaction additions to the ledger, it is
possible that nodes can reach consensus with our mechanism
even without learning about all blocks. As a consequence,
the approach may enable certain sharding solutions directly
on the Tangle layer, in which nodes only observe a propor-
tion of the total ledger. However, this approach may lower
performance and potentially lower security and/or liveness.
To address the viability of our solution for a sharded sce-
nario key questions such as necessary assumptions and a
full security analysis are vital.

The weight system from which the Approval Weight is
derived can be constructed from multiple sources and in
various settings. For example, the weight may be derived
from the token value and the system can be operated permis-
sioned or permissionless. A different approach is to obtain
the weights through reputation systems, which has so far
received little attention.

By introducing the transaction reference in addition to
the block reference in Section 6, the orphanage of trans-
actions can be reduced through Algorithm 3. However, it
does not solve the problem entirely. For instance, an honest
transaction can be referenced (directly) only by eventually
rejected transactions and may never reach sufﬁcient AW to
be considered conﬁrmed. This can be improved in several
ways. First, nodes may keep their “own” transactions as
tips until they are conﬁrmed. This resembles an automated
way of reattaching blocks. Second, nodes may also retain
transactions that are in their preferred reality but for which
they have not yet voted for in the tip pool. The transactions
may then be supported via a transaction reference. Third,
one could allow block and transaction references to be
conﬂicting for a given block. The transaction can then
be prioritised over block references in a transaction. This
enables an efﬁcient way to remove parts of branches from
the referenced aggregated branch. Another possible solution
for a more accurate voting is to introduce more reference
types which would eventually allow nodes to remove more
explicitly certain branches from the supported branches of
referenced blocks. The above examples demonstrate that
solutions for the Tip Selection Algorithm can be found
that mitigate or reduce orphanage, however, they require
thorough analysis to cover edge cases.

13. Conclusion

Figure 16: Conﬁrmation time distributions of blocks with
the Zipf parameter s, taken from [73].

Figure 17: Conﬁrmation time distributions of blocks with
the number of nodes, for s = 0.9, taken from [73].

Switch strategy as a function of the adversarial weight if
SRRS is disabled. It is interesting to note that there this some
“inherent randomness” in the protocol as blocks are issued
randomly. This seems sufﬁcient to guarantee the security
against an attacker with at most 20% of total weight. In
Figure 15 we see the effectiveness of the SRRS, that makes
the protocol robust against the Bait-and-Switch attack up to
the theoretical limit of q = 1/3.

We conclude this section with a brief analysis of the
performance with the degree of decentralization and the
size of the network. This also allows to support the values
for the growth of the Witness Weight in Figure 5. Figure
16 shows the conﬁrmation time distributions for several
Zipf parameters s with N = 100. The conﬁrmation time
increases with the “decentralization” of the network, as also
discussed in Section 6.4. Nevertheless, Figure 5 shows, that
in the extreme case where all nodes have equal weight, i.e.
s = 0, transaction are still conﬁrmed within 2 seconds. In
Figure 17 we show the dependence of the conﬁrmation times
with respect to the size of the network, for s = 0.9. As
described in Section 5, the Witness Weight increases slower
with a larger number of nodes. However, as Figure 16 shows
the increase is sublinear, resulting in low conﬁrmation times
of ∼3 seconds, even for 1000 nodes.

12. Outlook - Future Research

The proposed consensus mechanism in combination with
the Reality-based Ledger supports the parallelisation of
many processes, such as processing, booking and voting.
This can lead to a signiﬁcant performance boost since it can
enable multi-threaded concurrency. The potential for multi-

We have introduced a new leaderless consensus protocol
that can be seen as a generalisation of the Nakamoto con-
sensus. Our protocol is based on the Tangle, which not only
forms a partially ordered communication record between
participants in a peer-to-peer network, but also serves as an
efﬁcient way to implicitly vote on the history of the underly-
ing ledger. These nodes are associated with reputation-based

00.20.40.60.811.21.41.61.82Zipf Parameter012Confirmation Time (s)1002003004005006007008009001000Node Count024Confirmation Time (s)weights which are used to reach consensus on the acceptance
of transactions to the ledger. The leaderless nature of the
protocol allows asynchronous and concurrent writing access
to the ledger. It also eliminates the need for shared “memory
pools” for pending transactions and the special roles of
miners or validators.

We provide formal deﬁnitions and proofs for the func-
tionalities of the protocol, as well as pseudo-code for the
various core algorithms. Furthermore, liveness and security
of the protocol are analysed and several attack scenarios
discussed in detail. We proved an impossibility result for
safety in the asynchronous communication model. However,
by introducing a synchronisation mechanism that utilises
a common random coin, we proved theoretical results on
the safety of the protocol. Finally, we presented initial
simulation studies that conﬁrm the performance of the pro-
tocol with conﬁrmation times in the order of second, and
robustness up to a theoretical upper bound of the adversary
weight of 1/3.

Appendix A.
Estimates on Conﬂuence Time

This section gives an upper bound on the conﬂuence

time τc.

In the case where the network is in a low load regime, we
can assume that the tip pool size is small. Then after several
approvals, all new transactions will indirectly reference this
transaction. In the high load regime, the tip pool size L0 (cid:29)
k and the conﬂuence time can be larger. Denote K(t) the
number of tips that approve the given transaction x at time t.
A new transaction at time t chooses k tips based on the state
of the Tangle at time t − h. Hence, the probability of a new
transaction approving at least one of the K(t − h) tips that
are approving x is given by

(cid:18)

1 −

1 −

K(t − h)
L0

(cid:19)k

.

(23)

As mentioned above, during a time interval h we have that
λh new tips arrive and λh tips are approved. Hence, the
probability that a transaction that was a tip at time t − h is
no longer a tip at time t is

λh
L0

=

k − 1
k

.

(24)

Therefore, at time t we have that (1)/kK(t − h) previous
tips are still tips and (k−1)/kK(t−h) have been referenced
and are no longer tips. We denote by A the set of the tips
referencing x that are still tips and by B the tips referencing
x that got approved in [t − h, h]. We write

pA =

K(t − h)
kL0

, resp. pB =

(k − 1)K(t − h)
kL0

(25)

for the probabilities to choose a given parent from the set
A, resp. the set B. Let p1 be the probability to approve at
least one transaction from B but not from A and let p2 be
the probability that at least two parents are chosen from the

set A. Let YA be the number of tips approved from set A.
Then, note that in the ﬁrst event, the number of tips that
reference the given transaction increases by a factor 1 and
in the second event the number of tips decreases by a factor
YA − 1.

The probability of the ﬁrst event can be described by a

binomial distribution. In fact,

p1 =

k
(cid:88)

i=1

(cid:19)

(cid:18)k
i

B(1 − pA − pB)k−i.
pi

(26)

Since pB is assumed to be small the two leading terms are
for i ∈ {1, 2} and we obtain

p1 ≈ kpB +

1
2

k(k − 1)p2
B.

(27)

The random variable YA follows a Binomial distribution

Bin(k, pA), hence,

P[Y1 ≥ 2] =

k
(cid:88)

i=2

(cid:19)

(cid:18)k
i

A(1 − pA)k−i.
pi

(28)

For K(t − h) small, and, thus, pA small, the leading term in
the above expression is for i = 2. Hence, the second event
happens with probability approximately equal to

p2 =

1
2

k(k − 1)p2
A,

(29)

and the tip pool size is reduced essentially by 1. Similarly
to [3] we can write now a differential equation for K(t).
We consider only the ﬁrst order terms of p1 and p2 since
we assume K(t) to be small:

dK(t)
dt

= (p1 − p2)λ ≈ λ

(k − 1)K(t − h)
L0

Using Equation (9) we can write

dK(t)
dt

≈

(k − 1)2K(t − h)
kh

,

(30)

(31)

with boundary condition K(0) = 1. Following the lines
of [3] we obtain a solution of the form
(cid:18) (k − 1)2
k

K(t) = exp

(cid:19) t
h

(32)

W

(cid:18)

(cid:19)

,

where W (·) is the so-called Lambert W -function. Taking
the logarithm at both sides we ﬁnd that the time when K(t)
reaches εL0 is roughly

τc ≈

h
(cid:16) (k−1)2
k

W

(cid:17) (log L0 + log ε) .

(33)

For large k we can approximate W
1) − log k ≈ log k and obtain

(cid:16) (k−1)2
k

(cid:17)

≈ 2 log(k −

τc ≈

h
log k

log(L0) ≈

1
log k

h log(λh).

(34)

Tangle

ρ

x

u

y

z

Ledger DAG

Conﬂict DAG

Conﬂict Graph

ˆρ

ˆy

ˆx

ˆu

ˆw

ˆz

ˆv

ˆρ

ˆu

ˆw

ˆx

ˆy

ˆu

ˆw

R

ˆy

ˆx

w

v

Node’s weight
0.3
0.2

0.1
0.4

ρ
1

x
0.7

Block’s Witness Weight
w
u
0.4
0.3

y
0.7

z
0.7

v
0.1

ˆρ
1

Transaction’s Approval Weight
ˆu
ˆx
0.3
0.7

ˆw
0.4

ˆz
0.7

ˆy
0.3

ˆv
0.1

Figure 18: The Tangle, the Ledger DAG, the Conﬂict DAG and the Conﬂict Graph are shown. The Tangle starts with
the genesis ρ and includes six other blocks x, y, z, u, v, w. Blocks x and y contain directly conﬂicting transactions ˆx and
ˆy. Similarly, blocks u and w contain directly conﬂicting transactions ˆu and ˆw. Weights of four issuing nodes, which are
identiﬁed with unique colors, are depicted. The WW of blocks and AW of transactions are computed. In addition, the
preferred reality R is highlighted on the Conﬂict Graph.

Appendix B.
Illustrative example

In this section, we demonstrate in Figure 18 the most
important concepts introduced in the paper using a toy
example. In this example, blocks have two references which
are identical in some cases.

The Tangle starts with the genesis ρ and six blocks are
issued in the order x, y, z, v, w, u by four distinct nodes
which are identiﬁed with unique colors (red, blue, brown,
green) and have weights 0.3, 0.1, 0.2, 0.4. In Figure 18 we
demonstrate the Tangle, the Ledger DAG, the Conﬂict DAG
and the Conﬂict Graph. Transactions ˆx and ˆy consume
the same output of ˆρ, thereby they are directly conﬂicting
transactions. Similarly, we say that ˆu and ˆw are directly
conﬂicting as their input is the same output of ˆx. Thus, the
Conﬂict DAG consists of the genesis ˆρ and ˆx, ˆy, ˆu, ˆw and
can be seen as the subDAG of the Ledger DAG induced
by its vertices (see Section 5.2). The Conﬂict Graph shows
the conﬂicting dependencies between ˆx, ˆy, ˆu, ˆw, e.g. ˆy is
connected with ˆx as they are directly conﬂicting and ˆy is
connected with all conﬂict-successors of ˆx, i.e. ˆu and ˆw.

To demonstrate the steps of our protocol we discuss
the actions from the point of view of the “green” node
for issuing block w. Before block w was issued (i.e. at
time when blocks x, y, z, v were issued only), the preferred
reality (see Algorithm 1) for the node was R = {ˆx} as
AW(ˆx) > AW(ˆy). Suppose that the node decided to issue
a block w and selected the two tips x and z by Algorithm 3.

Since the voting branch of x is branch(p)
V (x) = {ˆx} ⊆ R
and the voting branch of z is branch(p)
V (z) = {ˆy} (cid:54)⊆ R (see
Deﬁnition 6.5), the node set a block reference from w to x
only. After checking that the maximal contained branch of
transaction ˆz is the main branch (or the empty set), the node
put a transaction reference from w to z shown in Figure 18
by the dashed arrow.

We observe that the Approval Weight of transactions
is often equal to the Witness Weight of the corresponding
blocks. However, this is not always the case. For instance,
the Approval Weight of transaction ˆy is the sum of weights
of nodes supporting it. In this case, the “brown” and “blue”
nodes are the supporters of ˆy, but not the “green” node
because of the transaction reference from w to z. Therefore,
AW(ˆy) = 0.2 + 0.1 = 0.3. On the other hand, WW(y) =
0.2 + 0.1 + 0.4 = 0.7 since the “green” node witnesses the
block y.

To ﬁnd the preferred reality, a node must follow Algo-
rithm 1. Speciﬁcally, the reality R is constructed step-by-
step by looking at the Conﬂict Graph (see Figure 18). At
the ﬁrst step, one includes ˆx in R as it attains the highest
Approval Weight and it is the closest vertex to the genesis.
Then we remove ˆx and all conﬂicts which are conﬂicting
with ˆx, i.e. ˆy is removed. At the second step, we choose ˆw
as its Approval Weight is higher that the one of ˆu. After this
step, we remove both ˆw and ˆu. Since the empty set remains,
we ﬁnish with constructing reality R = {ˆx, ˆw}.

We also highlight that if at the next moment the “brown”
node, which is supposed to be honest, decides to issue a

new block and attach it to block w (with a block reference),
then it would change its vote on conﬂicting transaction ˆy
(see Deﬁnition 6.6). Speciﬁcally, the Approval Weight of ˆy
would be dropped by the weight of the “brown” node and
become 0.1. In contrast, the Approval Weight of ˆx would
gain and become 0.9.

Appendix C.
Glossary

Approval Weight A function that computes the “rela-
tive” part of the network that approves a given transaction
Conﬂict A transaction that consumes the same output

as a distinct transaction

Conﬂicting transactions Two transactions that contain
two transactions in their past cones which consume the same
output of some transaction

Cone A set of vertices in a DAG that are reachable from
a given vertex by following the directions (past cone) and
the opposite directions (future cone) of edges in the DAG.
Branch A set of conﬂicts which does not contain con-

ﬂicting transactions and is past-closed

Branch DAG A DAG that represents the relations be-

tween branches

Ledger DAG A data structure that stores all transactions

in the form of a DAG

Tangle DAG A data structure that stores all blocks in

the form of a DAG

Voting DAG An augmented DAG that represents a
combination of the Tangle DAG and the Ledger DAG and
is used for determining voting cones

Genesis The transaction that is the ultimate predecessor

of any transaction of the UTXO ledger.

Block An element of the Tangle DAG, constituted of

identiﬁed data that refer to at least two blocks

Node A machine that is a part of the network. Its role

is to issue new blocks and validate pre-existing ones

Reality A maximal branch
Solidiﬁcation The process of retrieving missing blocks
in the past cone of a given block which can be requested
by a node

Witness Weight A function that computes the “relative”

part of the network that approves a given block

Acknowledgment

The authors would like to thank the developer team of
the GoShimmer software, for supporting this study with the
prototype implementation of the IOTA 2.0 protocol. They
also thank precious staff members of the IOTA Foundation
and members of the IOTA community for their feedback
and criticism.

References

[1]

S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” 2008.

[2] Y. Sompolinsky and A. Zohar, “Secure high-rate transaction pro-
cessing in bitcoin,” in Financial Cryptography and Data Security,
R. Böhme and T. Okamoto, Eds. Berlin, Heidelberg: Springer Berlin
Heidelberg, 2015, pp. 507–527.

[3]

S. Popov, “The Tangle,” 2015.

[4] A. de Vries and C. Stoll, “Bitcoin’s growing e-waste problem,”
Resources, Conservation and Recycling, vol. 175, p. 105901, 2021.

[5]

[6]

I. Makarov and A. Schoar, “Blockchain analysis of the bitcoin mar-
ket,” National Bureau of Economic Research, Working Paper 29396,
October 2021.

P. Daian, S. Goldfeder, T. Kell, Y. Li, X. Zhao, I. Bentov, L. Breiden-
bach, and A. Juels, “Flash boys 2.0: Frontrunning in decentralized
exchanges, miner extractable value, and consensus instability,” in
2020 IEEE Symposium on Security and Privacy (SP), 2020, pp. 910–
927.

[7] D. Rosenthal, “EE380 Talk,” 2022.
//blog.dshr.org/2022/02/ee380-talk.html

[Online]. Available: https:

[8] M. Dotan, Y.-A. Pignolet, S. Schmid, S. Tochner, and A. Zohar,
“SOK: Cryptocurrency Networking Context, State-of-the-Art, Chal-
lenges,” in Proceedings of
the 15th International Conference on
Availability, Reliability and Security, ser. ARES ’20. New York,
NY, USA: Association for Computing Machinery, 2020.

[9] M. Belotti, N. Boži´c, G. Pujolle, and S. Secci, “A Vademecum on
Blockchain Technologies: When, Which, and How,” IEEE Commu-
nications Surveys Tutorials, vol. 21, no. 4, pp. 3796–3838, 2019.

[10] Q. Wang, J. Yu, S. Chen, and Y. Xiang, “Sok: Diving into dag-based
blockchain systems,” ArXiv preprint arXiv:2012.06128, 2020.

[11] V. Buterin, “Ethereum: A Next-Generation Smart Contract and De-

centralized Application Platform,” 2013.

[12] M. M. T. Chakravarty, J. Chapman, K. MacKenzie, O. Melkonian,
M. Peyton Jones, and P. Wadler, “The Extended UTXO Model,” in
Financial Cryptography and Data Security, M. Bernhard, A. Brac-
ciali, L. J. Camp, S. Matsuo, A. Maurushat, P. B. Rønne, and M. Sala,
Eds. Cham: Springer International Publishing, 2020, pp. 525–539.

[13] T. Rocket, M. Yin, K. Sekniqi, R. van Renesse, and E. G. Sirer, “Scal-
able and probabilistic leaderless BFT consensus through metastabil-
ity,” arXiv preprint arXiv:1906.08936, 2019.

[14] S. Popov, H. Moog, D. Camargo, A. Capossele, V. Dimitrov, A. Gal,
A. Greve, B. Kusmierz, S. Mueller, A. Penzkofer, O. Saa, W. Sanders,
L. Vigneri, W. Welz, and V. Attias, “The Coordicide,” 2019.

[15] S. Müller, A. Penzkofer, N. Polyanskii, J. Theis, W. Sanders,
and H. Moog, “Reality-based UTXO Ledger,” arXiv preprint
arXiv:2205.01345, 2022.

[16] T. D. Chandra and S. Toueg, “Unreliable failure detectors for reliable
distributed systems,” J. ACM, vol. 43, no. 2, p. 225–267, mar 1996.

[17] A. Penzkofer, B. Kusmierz, A. Capossele, W. Sanders, and O. Saa,
“Parasite Chain Detection in the IOTA Protocol,” in 2nd International
Conference on Blockchain Economics, Security and Protocols (Toke-
nomics 2020), 2020, pp. 8:1–8:18.

[18] L. Lamport, R. Shostak, and M. Pease, “The byzantine generals
problem,” ACM Trans. Program. Lang. Syst., vol. 4, no. 3, p. 382–401,
jul 1982.

[19] M. J. Fischer, N. A. Lynch, and M. S. Paterson, “Impossibility of
distributed consensus with one faulty process,” J. ACM, vol. 32, no. 2,
p. 374–382, apr 1985.

[20] C. Dwork, N. Lynch, and L. Stockmeyer, “Consensus in the Presence
of Partial Synchrony,” J. ACM, vol. 35, no. 2, p. 288–323, apr 1988.

[21] F. Cristian and C. Fetzer, “The timed asynchronous distributed system
model,” IEEE Transactions on Parallel and Distributed Systems,
vol. 10, no. 6, pp. 642–657, 1999.

[22] A. Dembo, S. Kannan, E. N. Tas, D. Tse, P. Viswanath, X. Wang,
and O. Zeitouni, Everything is a Race and Nakamoto Always Wins.
New York, NY, USA: Association for Computing Machinery, 2020,
p. 859–878.

[23] P. Gaži, A. Kiayias, and A. Russell, Tight Consistency Bounds for Bit-
coin. New York, NY, USA: Association for Computing Machinery,
2020, p. 819–838.

[24] R. Pass, L. Seeman, and A. Shelat, “Analysis of the blockchain
protocol in asynchronous networks,” in Advances in Cryptology –
EUROCRYPT 2017, J.-S. Coron and J. B. Nielsen, Eds.
Cham:
Springer International Publishing, 2017, pp. 643–673.

[25] C. Natoli and V. Gramoli, “The balance attack against proof-of-
work blockchains: The R3 testbed as an example,” CoRR, vol.
abs/1612.09426, 2016.

[26] R. Guerraoui and A. Schiper, “Consensus: the big misunderstanding
the Sixth
[distributed fault
IEEE Computer Society Workshop on Future Trends of Distributed
Computing Systems, 1997, pp. 183–188.

tolerant systems],” in Proceedings of

[27] M. K. Aguilera, Stumbling over Consensus Research: Misunderstand-
ings and Issues. Berlin, Heidelberg: Springer-Verlag, 2010, p. 59–72.

[28] M. Ben-Or, “Another advantage of free choice (extended abstract):
Completely asynchronous agreement protocols,” in Proceedings of
the Second Annual ACM Symposium on Principles of Distributed
Computing, ser. PODC ’83. New York, NY, USA: Association for
Computing Machinery, 1983, p. 27–30.

[29] M. O. Rabin, “Randomized byzantine generals,” in 24th Annual
Symposium on Foundations of Computer Science (sfcs 1983), 1983,
pp. 403–409.

[30] V. B. Miši´c, J. Miši´c, and X. Chang, “On Forks and Fork Char-
acteristics in a Bitcoin-Like Distribution Network,” in 2019 IEEE
International Conference on Blockchain (Blockchain), 2019, pp. 212–
219.

[31] M. Iqbal and R. Matuleviˇcius, “Exploring Sybil and Double-Spending
Risks in Blockchain Systems,” IEEE Access, vol. 9, pp. 76 153–
76 177, 2021.

[32] M. Neuder, D. J. Moroz, R. Rao, and D. C. Parkes, “Low-cost attacks

on Ethereum 2.0 by sub-1/3 stakeholders,” 2021.

[33] J. P. T. Lovejoy, “An empirical analysis of chain reorganizations
and double-spend attacks on proof-of-work cryptocurrencies,” The-
sis, Massachusetts Institute of Technology. Department of Electrical
Engineering and Computer Science, 2020.

[34] V. Bagaria, S. Kannan, D. Tse, G. Fanti, and P. Viswanath, “Prism:
Deconstructing the blockchain to approach physical limits,” in Pro-
ceedings of the 2019 ACM SIGSAC Conference on Computer and
Communications Security, ser. CCS ’19.
New York, NY, USA:
Association for Computing Machinery, 2019, p. 585–602.

[35] Y. Sompolinsky and A. Zohar, “Accelerating bitcoin’s transaction
processing. fast money grows on trees, not chains,” IACR Cryptol.
ePrint Arch., vol. 2013, p. 881, 2013.

[36] Y. Lewenberg, Y. Sompolinsky, and A. Zohar, “Inclusive block chain
protocols,” in International Conference on Financial Cryptography
and Data Security. Springer, 2015, pp. 528–547.

[37] Y. Sompolinsky, Y. Lewenberg, and A. Zohar, “Spectre: A fast and
scalable cryptocurrency protocol,” Cryptology ePrint Archive, Report
2016/1159, 2016.

[38] Y. Sompolinsky, S. Wyborski,

and A. Zohar, PHANTOM
GHOSTDAG: A Scalable Generalization of Nakamoto Consensus:
September 2, 2021.
New York, NY, USA: Association for
Computing Machinery, 2021, p. 57–70.

[39] A. Miller, Y. Xia, K. Croman, E. Shi, and D. Song, “The Honey
Badger of BFT Protocols,” in Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security, ser. CCS
’16. New York, NY, USA: Association for Computing Machinery,
2016, p. 31–42.

[40] S. Duan, M. K. Reiter, and H. Zhang, “BEAT: Asynchronous BFT
Made Practical,” in Proceedings of the 2018 ACM SIGSAC Con-
ference on Computer and Communications Security, ser. CCS ’18.
New York, NY, USA: Association for Computing Machinery, 2018,
p. 2028–2041.

[41] L. Baird and A. Luykx, “The Hashgraph Protocol: Efﬁcient Asyn-
chronous BFT for High-Throughput Distributed Ledgers,” in 2020
International Conference on Omni-layer Intelligent Systems (COINS),
2020, pp. 1–7.

[42] A. Gagol, D. Lesniak, D. Straszak, and M. Swietek, “Aleph: Efﬁcient
atomic broadcast in asynchronous networks with byzantine nodes,”
CoRR, vol. abs/1908.05156, 2019.

[43] G. Danezis, L. Kokoris-Kogias, A. Sonnino, and A. Spiegelman,
“Narwhal and Tusk: A DAG-Based Mempool and Efﬁcient BFT
Consensus,” in Proceedings of the Seventeenth European Conference
on Computer Systems, ser. EuroSys ’22.
New York, NY, USA:
Association for Computing Machinery, 2022, p. 34–50.

[44] I. Keidar, E. Kokoris-Kogias, O. Naor, and A. Spiegelman, “All You
Need is DAG,” in Proceedings of the 2021 ACM Symposium on
Principles of Distributed Computing, ser. PODC’21. New York,
NY, USA: Association for Computing Machinery, 2021, p. 165–175.

[45] N. Giridharan, L. Kokoris-Kogias, A. Sonnino, and A. Spiegelman,
“Bullshark: DAG BFT protocols made practical,” CoRR, vol.
abs/2201.05677, 2022.
[Online]. Available: https://arxiv.org/abs/
2201.05677

[46] M. A. Schett and G. Danezis, “Embedding a Deterministic BFT Pro-
tocol in a Block DAG,” in Proceedings of the 2021 ACM Symposium
on Principles of Distributed Computing, ser. PODC’21. New York,
NY, USA: Association for Computing Machinery, 2021, p. 177–186.

[47] L. Yang, V. Bagaria, G. Wang, M. Alizadeh, D. Tse, G. Fanti, and
P. Viswanath, “Prism: Scaling bitcoin by 10,000x,” arXiv preprint
arXiv:1909.11261, 2019.

[48] G. Wang, S. Wang, V. Bagaria, D. Tse, and P. Viswanath, “Prism
removes consensus bottleneck for smart contracts,” in 2020 Crypto
Valley Conference on Blockchain Technology (CVCBT), 2020, pp. 68–
77.

[49] S. Müller, A. Penzkofer, B. Ku´smierz, D. Camargo, and W. J.
Buchanan, “Fast Probabilistic Consensus with Weighted Votes,” in
Proceedings of
the Future Technologies Conference (FTC) 2020,
Volume 2, 2021, pp. 360–378.

[50] S. Popov and S. Müller, “Voting-based probabilistic consensuses and
their applications in distributed ledgers,” Annals of Telecommunica-
tions, vol. 77, no. 1, pp. 77–99, 2022.

[51] A. Cullen, P. Ferraro, W. Sanders, L. Vigneri, and R. Shorten,
“Access Control for Distributed Ledgers in the Internet of Things:
A Networking Approach,” IEEE Internet of Things Journal, pp. 1–1,
2021.

[52] B. Kusmierz, W. Sanders, A. Penzkofer, A. Capossele, and A. Gal,
“Properties of the Tangle for Uniform Random and Random Walk
Tip Selection,” in 2019 IEEE International Conference on Blockchain
(Blockchain), 2019, pp. 228–236.

[53] P. Ferraro, C. King, and R. Shorten, “Distributed ledger technology
for smart cities, the sharing economy, and social compliance,” IEEE
Access, vol. 6, pp. 62 728–62 746, 2018.

[54] W. Li, “Zipf’s Law everywhere,” Glottometrics, vol. 5, pp. 14–21,

2002.

[55] L. A. Adamic and B. Huberman, “Zipf’s law and the Internet,”

Glottometrics, vol. 3, pp. 143–150, 2002.

[56] D. Kondor, M. Pósfai, I. Csabai, and G. Vattay, “Do the Rich Get
Richer? An Empirical Analysis of the Bitcoin Transaction Network,”
PLOS ONE, vol. 9, no. 2, pp. 1–10, 02 2014.

[57] B. Ku´smierz, S. Müller, and A. Capossele, “Committee Selection in
DAG Distributed Ledgers and Applications,” in Intelligent Comput-
ing, K. Arai, Ed. Cham: Springer International Publishing, 2021,
pp. 840–857.

[58] C. King, “The ﬂuid limit of a random graph model for a shared
ledger,” Advances in Applied Probability, vol. 53, no. 1, p. 81–106,
2021.

[59] E. Dra¸sutis, “IOTA Smart Contracts,” accessed January 2022.

[60] C. Dwork, N. Lynch, and L. Stockmeyer, “Consensus in the Presence
of Partial Synchrony,” J. ACM, vol. 35, no. 2, p. 288–323, Apr. 1988.

[61] T. D. Chandra and S. Toueg, “Unreliable Failure Detectors for Reli-
able Distributed Systems,” J. ACM, vol. 43, no. 2, p. 225–267, Mar.
1996.

[62] J. Beauquier, P. Blanchard, J. Burman, and R. Guerraoui, “The
Beneﬁts of Entropy in Population Protocols,” in 19th International
Conference on Principles of Distributed Systems (OPODIS 2015),
ser. Leibniz International Proceedings in Informatics (LIPIcs), E. An-
ceaume, C. Cachin, and M. Potop-Butucaru, Eds., vol. 46. Dagstuhl,
Germany: Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, 2016,
pp. 1–15.

[63] A. Penzkofer, O. Saa, and D. Dziubałtowska, “Impact of delay classes
on the data structure in IOTA,” in CBT2021 - 5th Cryptocurrencies
and Blockchain Technology workshop, 2021.

[64] S. Popov and W. J. Buchanan, “FPC-BI: Fast probabilistic consensus
within byzantine infrastructures,” Journal of Parallel and Distributed
Computing, vol. 147, pp. 77–86, 2021.

[65] A. Capossele, S. Müller, and A. Penzkofer, “Robustness and efﬁ-
ciency of voting consensus protocols within byzantine infrastruc-
tures,” Blockchain: Research and Applications, vol. 2, no. 1, p.
100007, 2021.

[66] I. Cascudo and B. David, “SCRAPE: Scalable randomness attested by
public entities,” in International Conference on Applied Cryptography
and Network Security. Springer, 2017, pp. 537–556.

[67] A. K. Lenstra and B. Wesolowski, “Trustworthy public randomness
with sloth, unicorn, and trx,” International Journal of Applied Cryp-
tography, vol. 3, no. 4, pp. 330–343, 2017.

[68] S. Popov, “On a decentralized trustless pseudo-random number gener-
ation algorithm,” Journal of Mathematical Cryptology, vol. 11, no. 1,
pp. 37–43, 2017.

[69] P. Schindler, A. Judmayer, N. Stifter, and E. Weippl, “HydRand:
Practical Continuous Distributed Randomness,” Cryptology ePrint
Archive, Report 2018/319, 2018.

[70] E. Syta, P. Jovanovic, E. K. Kogias, N. Gailly, L. Gasser, I. Khofﬁ,
M. J. Fischer, and B. Ford, “Scalable bias-resistant distributed ran-
domness,” in 2017 IEEE Symposium on Security and Privacy (SP),
2017, pp. 444–460.

[71] B. Wesolowski, “Efﬁcient veriﬁable delay functions,” J. Cryptol.,

vol. 33, pp. 2113–2147, 2020.

[72] S. Müller, R. C. Nitchai, and S. Popov, “FPC on a set,” 2021.

[73] B.-Y. Lin, D. Dziubałtowska, P. Macek, A. Penzkofer, and
S. Müller, “Robustness of the Tangle 2.0 Consensus,” arXiv preprint
arXiv:2208.08254, 2022.

[74] IOTA Foundation. (2021) Tangle 2.0 simulator. [Online]. Available:

https://github.com/iotaledger/multiverse-simulation

