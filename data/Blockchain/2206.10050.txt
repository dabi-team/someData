2
2
0
2

n
u
J

1
2

]

R
C
.
s
c
[

1
v
0
5
0
0
1
.
6
0
2
2
:
v
i
X
r
a

Better Incentives for Proof-of-Work

Jakub Sliwinski, Roger Wattenhofer

ETH Zurich
jsliwinski,wattenhofer@ethz.ch

Abstract. This work proposes a novel proof-of-work blockchain incen-
tive scheme such that, barring exogenous motivations, following the pro-
tocol is guaranteed to be the optimal strategy for miners. Our blockchain
takes the form of a directed acyclic graph, resulting in improvements with
respect to throughput and speed.
More importantly, for our blockchain to function, it is not expected that
the miners conform to some presupposed protocol in the interest of the
system’s operability. Instead, our system works if miners act selﬁshly,
trying to get the maximum possible rewards, with no consideration for
the overall health of the blockchain.

1

Introduction

A decade ago, Satoshi Nakamoto presented his now famous Bitcoin protocol [11].
Nakamoto assembled some stimulating techniques in an attractive package, such
that the result was more than just the sum of its parts.

The Bitcoin blockchain promises to order and store transactions meticulously,
despite being anarchistic, without a trusted party. Literally anybody can partic-
ipate, as long as “honest nodes collectively control more CPU power than any
cooperating group of attacker nodes.” [11]

In Section 6 of his seminal paper, Nakamoto argues that it is rational to be
honest thanks to block rewards and fees. However, it turns out that Nakamoto
was wrong, and rational does not imply honest. If a miner has a fast network
and/or a signiﬁcant fraction of the hashing power, the miner may be better oﬀ
by not being honest, holding blocks back instead of immediately broadcasting
them to the network [2].

If the material costs and payoﬀs of mining are low, one can argue that the
majority of miners will want to remain honest. After all, if too many miners
stop conforming to the protocol, the system will break down. However, the costs
and payoﬀs of participation vary over time, and a majority of miners remaining
altruistic is never guaranteed. Strategies outperforming the protocol may or may
not be discovered for diﬀerent blockchain incentive designs. However, as long as
it is not proven that no such sophisticated strategy exists, the system remains
in jeopardy.

 
 
 
 
 
 
2

Jakub Sliwinski, Roger Wattenhofer

1.1 Blockchain Game

Typical blockchains, such as Bitcoin’s, take the form of a rooted tree of blocks.
During the execution of the protocol, players continually create new blocks that
are appended to the tree as new leaves. Creating blocks is computationally in-
tensive, so that the network creates a speciﬁc number of blocks in a given time
period, such as one block every ten minutes on average in Bitcoin. One path of
blocks, such as the longest path, is distinguished as the main chain and keeps
being extended by addition of new leaves. The network’s participants want to
create blocks that remain incorporated into the main chain, as these blocks are
rewarded. Ideally, the leaves would be added in sequence, each leaf appended
to the previous leaf. However, by chance or malice, it is inevitable that some
leaves are appended to the same block and create a “fork”. Then, it is uncertain
which one will end up extending the main chain. According to typical solutions,
one of the competing leaves is eventually chosen as being in the main chain,
and the creator of the other leaf misses out on block rewards. This approach
introduces some unwanted incentives and a potential to punish other players.
Even worse, some factors such as network connectivity start to play a role and
might inﬂuence the behaviour of players.

1.2 Our Contribution

We propose a blockchain design with an incentive scheme guaranteeing that devi-
ating from the protocol strictly reduces the overall share and amount of rewards.
All players following the protocol constitute a strict, strong Nash equilibrium.
Our approach is to ensure that creating a fork will always be detrimental to all
parties involved. Our design allows blocks to reference more than one previous
block; in other words, the blocks form a directed acyclic graph (DAG). We prove
that miners creating a new block have an incentive to always reference all previ-
ously unreferenced blocks. Hence, all blocks are recorded in the blockchain and
no blocks are discarded.

1.3 Intuitive Overview

In Section 2 we describe the terms to deﬁne our protocol.

In Section 3 we explain the protocol and how to interpret the created DAG.
In terms of security, our design is identical to known proof-of-work blockchains,
as similarly to other protocols, we identify the main chain to achieve consensus.
Intuitively, each new block should reference all previous terminal blocks known
to the miner and automatically extend the main chain. In Subsection 3.1, we
explain how to use the main chain to process and totally order all blocks [7].

In Section 4 we construct and discuss our reward scheme.
In Subsection 4.1 we explain how to label some blocks as stale, such that
blocks mined by honest miners are not labeled as stale, but blocks withheld for
a long time are labeled as stale. Stale blocks do not receive any rewards.

Better Incentives for Proof-of-Work

3

The core idea of the incentive scheme is to penalize every block by a small

amount for every block that it “competes” with.

In Section 5 we discuss related work.

2 Model and Preliminaries

2.1 Rounds

We assume a network with a message diﬀusion mechanism that delivers messages
to all connected parties (similarly to Bitcoin’s network).

Similarly to foundational works in the area [3] we express the network delay
in terms of rounds. Communication is divided into rounds, such that when a
player broadcasts a message, it will be delivered to all parties in the network in
the next round. Thus each round can be viewed as: 1) receiving messages sent in
the previous round, 2) computing (mining) new blocks, 3) broadcasting newly
found blocks to all other players.

Rounds model the network delay for the purpose of analysis. However, the
protocol itself is not concerned with the division of time into rounds in any way,
and only relies on the network delay being correspondingly bounded.

2.2 Players

To avoid confusion in how we build on previous work, we stick to the usual
terminology of honest players and an adversary. The players that conform to the
protocol are called honest. A coalition of all parties that considers deviating from
the protocol is controlled by an adversary. We gradually introduce new elements,
and eventually show that by deviating from the protocol, the adversary reduces
its share and amount of rewards. Hence, rational becomes synonymous with
honest.

The adversary constitutes a minority as described in Section 2.5, otherwise
the adversary can take over the blockchain by simply ignoring all actions by
honest players.

The adversary is also more powerful than honest players. First of all, we
consider the adversary as a single entity. The adversary does not have to send
messages to itself, so the mine/send/receive order within a round does not apply
to the adversary. Moreover, the adversary gets to see all messages sent by honest
players in round r before deciding its strategy of round r. After seeing the honest
messages, the adversary is not allowed to create new blocks again in this round.
Moreover, the adversary controls the order that messages arrive to each player.

2.3 Blocks

Blocks are the messages that the players exchange, and a basic unit of the
blockchain. Formally, a block B is a tuple B = hTB, RB, c, ηi, where:

– TB is the content of the block

4

Jakub Sliwinski, Roger Wattenhofer

– RB is a set of references (hashes) to previously existing blocks, i.e. RB =

{h(B1), . . . , h(Bm)}

– c is a public key of the player that created the block
– η is the proof-of-work nonce, i.e., a number such that for a hash function h

and diﬃculty parameter D, h(B) < D holds.

The content of the block TB depends on the application. In general, TB con-
tains some information that the block creator wishes to record in the blockchain
for all participants to see. We consider blockchain properties independently of
the content TB. The content TB is discussed in Section A of the appendix.

The creator of B holds the private key corresponding to c. The creator can
later use the key to withdraw the reward for creating B. The amount of reward
is automatically determined by the protocol, and at the core of our contribution
in Section 4.

2.4 DAG

RB includes at least one hash of a previous block, which might be the hash of a
special genesis block h∅, ∅, ⊥, 0i. The hash function is pre-image resistant, i.e. it
is infeasible to ﬁnd a message given its hash. If a block B′ includes a reference
to another block B, B′ must include h(B), and hence has to be created after B.
A directed cycle of blocks is impossible, as the block which was created
earliest in such a cycle cannot include a hash to the other blocks that were
created later. Consequently, the blocks always form a directed acyclic graph
(DAG) with the genesis block as the only root (block without any parent) of
this DAG.

2.5 Mining

Creating a new block is achieved by varying η to ﬁnd a hash value that is smaller
than the diﬃculty parameter D, i.e., h(hTB, RB, c, ηi) < D. Creating blocks in
this way is called mining. Blocks are called honest if mined by an honest player,
or adversarial if mined by the adversary.

By varying D, the protocol designer can set the probability of mining a block
with a single hashing query arbitrarily. The diﬃculty D could also change during
the execution of the protocol to adjust the rate at which blocks are created. We
leave the details of changing D to future work, and assume D to be constant.

The honest players control the computational power to mine α blocks in
expectation in one round. The computational power of the adversary is such
that the expected number of blocks the adversary can mine in one round is
equal to β. The adversary does not experience a delay in communication with
itself, so the adversary might mine multiple blocks forming a chain in one round.

Assumptions The following assumptions are made in order to satisfy the pre-
requisites of Lemma 2, which was proven in [6]. Lemma 2 links our work to tra-
ditional blockchains. Intuitively, the lemma states that a traditional blockchain

Better Incentives for Proof-of-Work

5

works with respect to the most basic requirement. If one believes a blockchain
to function in this basic way under some other assumptions, those assumptions
can be used instead, and our results would apply in the same way.

Because of the delay in communication, the eﬀective computational power of
the honest players corresponds to the probability α′ ≈ αe−α [6] that in a given
round exactly one honest player mines a block.

1. The honest players have more mining power: α′ ≥ β(1 + ǫ) for a constant

ǫ > 0.

2. The diﬃculty D is set such that the expected number of blocks mined within

one round is less than one: α + β < 1.

2.6 Action Space

The state of the blockchain is only updated through discovery and broadcasting
of new blocks, hence the adversary can only vary its behaviour with respect to
the following factors:

– the blocks being mined i.e. the contents, the included references etc.
– when to announce any of the mined blocks
– the set of agents to whom to send a given block.1

3 The Block DAG

The protocol by which the honest players construct the block DAG is simple:

– Attempt to mine new blocks.
– Reference in RB all unreferenced blocks observed.
– Broadcast newly mined blocks immediately.

Each player stores the DAG formed by all blocks known to the player. For
each block B, one of the referenced blocks Bi is the parent Bi = P (B), and B
is the child of P (B). The parent is automatically determined based on the DAG
structure. The parent-child edges induce the parent tree from the DAG.

The players use Algorithm 1 by [16] to select a chain of blocks going from
the genesis block to a leaf in the parent tree. The selected chain represents the
current state of the blockchain; it is called the main chain. The main chain of
a player changes from round to round. Players adopt main chains that may be
diﬀerent from each other, depending on the blocks observed.

Let past(B) denote the set of blocks reachable by references from B and
the DAG formed by those blocks. The protocol dictates referencing all blocks
that otherwise would not be included in past(B). Then, by creating a new block
B, the creator communicates only being aware of blocks in past(B). Based on
past(B), we determine P (B) as the end of the main chain (Algorithm 1) of the
DAG of the player when creating a new block B [7].

1 Honest agents disseminate all received blocks, so by sending a block to a subset of
agents, the adversary can delay other agents from seeing a block for only one round.

6

Jakub Sliwinski, Roger Wattenhofer

Algorithm 1: Main chain selection algorithm.

Input: a block tree T
Output: block B - the end of the selected chain

1 B ← genesis
2 while B has a child in T do
B ← heaviest child of B
3

4 return B

// start at the genesis block.

// continue with the child of B
// with most nodes in its subtree.

Deﬁnition 1 (Determining Parent). For a given block B, the block returned
by Algorithm 1 in the parent tree of past(B) \ {B} is the parent of B.

Lemma 2 by [6], encapsulates the notion that a blockchain (represented by
the parent tree in our description) functions properly with respect to a basic
requirement. Intuitively, it states that from any point in time, the longer one
waits, the more probable it becomes that some honest block mined after that
point in time is contained in a main chain of each honest player. The probability
of the contrary decreases exponentially with time.
Lemma 2 (Fresh Block Lemma). For all r, ∆ ∈ N, with probability 1 −
e−Ω(∆), there exists a block mined by an honest player on or after round r that
is contained in the main chain of each honest player on and after round r + ∆.

Lemma 2 can be proved with respect to other chain selection rules, for in-
stance picking the child with the longest chain instead of the heaviest child as
in Algorithm 1. Our work can be applied equally well using such chain selection
rules.

If the protocol designer has control over some factor x, probability of the form
e−Ω(x) can be set arbitrarily low with relatively small variation of x. Probability
of the form e−Ω(x) is called negligible.2

3.1 Block Order

We will now explain, how all blocks reachable by references will be ordered,
following the algorithm of [7]. According to the resulting order, the contents of
blocks that fall outside of the main chain can be processed, as if all blocks formed
one chain.

Deﬁnition 3. Each player processes blocks in the order Order(B), where B is
the last block of the main chain.

Note the order of executing the FOR loop in line 6 of the Algorithm 2 has
to be the same for each player for them to receive consistent orders of blocks.
Algorithm 2 processes Bi’s in the order of inclusion in RB, but the order could
be alphabetical or induced by the chain selection rule.

Based on lines numbered 5-8 we can state Corollary 4.

2 Probabilities of this form are often disregarded completely in proofs [14].

Better Incentives for Proof-of-Work

7

Algorithm 2: Order(B): a total order of blocks in past(B).

Input: a block B
Output: a total order of all blocks in past(B)

1 On the ﬁrst invocation, visited(·) is initialized to false for each block.
2 if visited(B) then return ∅
3 visited(B) ← true
4 if B = genesis then return (B)
5 O ← Order(P (B))
6 for i = 1, . . . , m do
7
8 O ← O.append(B)
9 return O

O ← O.append(Order(Bi))

// Append newly included blocks.
// Append B at the end.

// Get the order of P (B) recursively.

// Blocks are visited depth-first.

Corollary 4. Order(B) extends Order(P (B)) by appending all newly reachable
blocks not included yet in Order(P (B)).

Lemma 5. Any announced block becomes referenced by a block contained in the
main chain of any honest player after ∆ rounds with probability 1 − e−Ω(∆).

Proof. Suppose a block B is announced at round r. By Lemma 2, some honest
block A mined in the following ∆ rounds is contained in the main chains adopted
⊓⊔
by honest players after round r + ∆. Since A is honest, B ∈ past(A).

By Lemma 5 all announced blocks are eventually referenced in the main
chains of honest players. Since for the purpose of achieving consensus we rely on
the results of [6] and [7], we state Corollary 6.

Corollary 6. The protocol achieves consensus properties corresponding to [6]
and [7].

4 Reward Schemes

4.1 Stale Blocks

We now introduce a mechanism to distinguish blocks that were announced within
a reasonable number of rounds from blocks that were withheld by the miner for
an extended period of time. Such withheld blocks are called stale. Honest miners
broadcast their blocks immediately, so stale blocks can be attributed to the
adversary. In our incentive scheme, stale blocks will not receive any rewards and
will also be ignored for the purpose of determining other block rewards. Thus we
ensure that it is pointless for the adversary to wait too long before broadcasting
its blocks.

The basic deﬁnition of whether a block A is stale is termed with respect to
some other block B. We are only interested in blocks B that form the main
chain. When the main chain is extended, the sets of stale and non-stale blocks
are preserved (and extended). Hence, stale-ness is determined by the eventual
main chain.

8

Jakub Sliwinski, Roger Wattenhofer

Deﬁnition 7. Given a block B, the set of stale blocks SB is computed by Algo-
rithm 3. Then, ¯SB = past(B) \ SB. If A ∈ SB we call A stale.

The constant p of Algorithm 3 is chosen by the protocol designer. Intuitively,
given a main chain ending with block B that references another block A, we
judge A by the distance one needs to backtrack along the main chain to ﬁnd an
ancestor of A. If the distance exceeds p, A is stale.

We call P i(B) the ith ancestor of B and B is a descendant of P i(B).3 By
LCA(B1, B2) (lowest common ancestor) we denote the block that is an ancestor
of B1 and an ancestor of B2, such that none of its children are simultaneously
an ancestor of B1 and an ancestor of B2.

For blocks A and B, D(A, B) is the distance between A and B in the parent

tree, i.e. D(A, P (A)) = 1, D(A, P (P (A))) = 2, etc.

Algorithm 3: Compute SB.

Input: a block B
Output: a set SB

1 if B = genesis then return ∅
2 S ← SP (B)
3 for A ∈ past(B) \ past(P (B)) do
4

X = LCA(A, B)
Age = D(X, B)
if Age > p then
S = S ∪ {A}

5

6

7

// Copy SP (B) for blocks in past(P (B)).

// age = distance from B to LCA.

// A is stale iff age is bigger than p

8 return S

Corollary 8 shows that when the main chain is extended, the stale-ness of

previously seen blocks is preserved.

Corollary 8. If A ∈ past(P (B)) then A ∈ SB ⇐⇒ A ∈ SP (B).

Proof. Line 2 in Algorithm 3 sets SB as the same as SP (B), while the following
⊓⊔
FOR loop adds only blocks A /∈ past(P (B)).

Theorem 9 establishes the most important property of stale-ness. The prob-
ability that the adversary can successfully make an honest block stale decreases
exponentially with p, and is negligible.

Theorem 9 (Honest Blocks are Not Stale). Let B be an honest block mined
on round r. With probability 1 − e−Ω(p), after round r + O(p) each honest player
H adopts a main chain ending with a block BH such that B ∈ ¯SBH .

The proof is deferred to the appendix.

3 Note that ancestors and descendants are deﬁned based on the parent tree and not

based on other non-parent references building up the DAG.

Better Incentives for Proof-of-Work

9

4.2 Discussion of Flat Rewards

Consider coupling the presented protocol with a reward mechanism R0 that,
intuitively speaking, grants some ﬂat amount b of reward to all non-stale blocks,
and 0 reward to stale blocks. R0 is a special case of the reward scheme properly
deﬁned in Deﬁnition 12.

Corollary 10. Under the reward scheme R0, honest players are rewarded pro-
portionally to the number of blocks they mine, except with negligible probability.

Proof. By Theorem 9 honest blocks are not stale, so honest miners receive re-
wards linear in the number of blocks they mined. The adversary might only
decrease its rewards by producing stale blocks, otherwise the adversary is re-
⊓⊔
warded in the same way.

Note that R0 achieves the same fairness guarantee as the Fruitchains pro-
tocol to be discussed in Section 5.3 — honest blocks are incorporated into the
blockchain as non-stale, while withholding a block for too long makes it lose its
reward potential. Both protocols rely on the honest majority of participants to
guarantee this fairness.

The Fruitchains protocol relies critically on merged-mining [12] (also called 2-
for-1 POW [3]) fruits and blocks. While fruits are mined for the rewards, blocks
are supposed to be mined entirely voluntarily with negligible extra cost. The
reward scheme R0 avoids this complication.

Granting ﬂat amount of reward for each non-stale block leaves a lot of room
for deviation that goes unpunished. In the case of the Fruitchains protocol,
mining blocks does not contribute rewards in any way. Hence, any deviation
with respect to mining blocks (which decide the order of contents) is free of any
cost for the adversary. In the context of cryptocurrency transactions, a rational
adversary should always attempt to double-spend.

In the case of R0, the adversary can refrain from referencing some recent
blocks, and suﬀer no penalty. However, attempting to manipulate the order of
older blocks would render the adversary’s new block stale, and hence penalize.
Thus, we view even the base case R0 of the presented reward scheme as a strict
improvement over the Fruitchains protocol.

4.3 Penalizing Deviations

Central to our design is the approach to treating forks i.e. blocks that “compete”
by referencing the same parent block and not each other. Typically, blockchain
schemes specify that one of the blocks eventually “loses” and the creator misses
out on some rewards, essentially discouraging competition. However, there are
ways of manipulating this process to one’s advantage, and the uncertainty of
which block will win the competition introduces unneeded incentives. We penal-
ize all parties involved in creating a fork.

The conﬂict set introduced in Deﬁnition 11 contains the blocks that “com-
pete” with a given block. Stale blocks are excluded, as we ignore them for the

10

Jakub Sliwinski, Roger Wattenhofer

purpose of computing rewards. Like stale-ness, the conﬂict set is deﬁned with
respect to some other block A. Again, we are only interested in blocks A that
form the main chain, and the conﬂict set indicated by the eventual main chain.
The conﬂict set of a non-stale block B contains all non-stale blocks X that
are not reachable by references from B, and B is not reachable by references
from X.

Deﬁnition 11 (Conﬂict Set). For blocks A and B where B ∈ ¯SA,

XA(B) = {X : X ∈ ¯SA ∧ X /∈ past(B) ∧ B /∈ past(X)}.

Fig. 1. An example of a conﬂict set. The gray blocks constitute the conﬂict set of the
blue block. The dashed arrows are references and the solid arrows are parent references.

Intuitively, the scheme we propose awards every block some amount of reward
b decreased by a penalty c multiplied by the size of the conﬂict set. The ultimate
purpose of the properties we establish is to make sure that rational miners want
to minimize the conﬂict set of the blocks they create, following the protocol as
a consequence.

Deﬁnition 12 (Rewards). A reward scheme Rc,b is such that given the main
chain ending with a block A, each block B ∈ past(A) is granted Rc,b
A (B) amount
of reward:

Rc,b

A (B) =

0,
b − c|XA(B)|,

(

if B ∈ SA or D(A, LCA(A, B)) ≤ 2p.
otherwise.

We write Rc for Rc,b if b is clear from context, or just R if c is clear from

context.

In our reward scheme, the reward associated with a given block are decreased
linearly with the size of the block’s conﬂict set. We need to ensure that no block
reward is negative, otherwise the reward scheme would break down. Lemma
13 shows that it is only possible for the conﬂict set to reach certain size; the
probability that the conﬂict set of a block is bigger than linear in p is negligible.
Intuitively, it is because stale blocks cannot be part of a conﬂict set, and after

Better Incentives for Proof-of-Work

11

enough time has passed from broadcasting some block B, new blocks either
reference B or are stale.

As a consequence, we establish in Corollary 14 that the rewards are non-

negative.

Lemma 13. Let x ≥ p and B be a block. The probability that any honest player
adopts a main chain ending with a block A such that |XA(B)| > xp is e−Ω(x).

The proof is deferred to the appendix.

Corollary 14 (Rewards Are Non-Negative). Let B be a block. The prob-
ability that any honest player adopts a main chain ending with a block A such
that Rc,b

−Ω( b

cp ).

A (B) < 0 is e

Proof. Follows directly from Lemma 13.

⊓⊔

The conﬂict set of a block is determined based on the main chain. At some
point, the reward needs to be determined and stay ﬁxed. Lemma 15 shows that
if the main chain has grown far enough from block B, the new block A appended
to the chain will not modify the conﬂict set of B.

Lemma 15. If D(P (A), LCA(P (A), B)) > 2p then XA(B) = XP (A)(B)

The proof is deferred to the appendix.
The rewards in Deﬁnition 12 are only assigned as non-zero to blocks B such
that D(A, LCA(A, B)) > 2p, where A is the block at the end of the main chain.
By Corollary 16, these non-zero rewards are not modiﬁed by the blocks extending
the main chain and remain ﬁxed.

Corollary 16 (Rewards Are Final).

∀B ∈ past(A) : RP (A)(B) 6= 0 =⇒ RA(B) = RP (A)(B).

Proof. Rc,b
from Lemmas 8 and 15 and induction.

A (B) is non-zero only if D(A, LCA(A, B)) > 2p. The corollary follows
⊓⊔

The properties we have established so far culminate in Theorem 17.

Theorem 17. Deviating from the protocol reduces the adversary’s rewards and
its proportion of rewards Rc,b, except with negligible probability.

The proof is deferred to the appendix.

4.4 Nash Equilibria

Theorem 17 follows from Lemma 2 and hence holds for the same action space
as considered in [6], i.e. attempting to mine any chosen blocks and withholding
or releasing blocks at will. Hence, for this action space, minimizing the conﬂict
set of mined blocks is in the interest of the miner. The adversary is considered
as a coordinated minority coalition of players, hence the constants p, c, b can
be set such that all players following the protocol constitute a strict, strong
Nash equilibrium. In other words, all agents and all minority coalitions of agents
strictly prefer to follow the protocol to any alternative strategy.

12

Jakub Sliwinski, Roger Wattenhofer

Corollary 18. All players following the protocol constitute a strict, strong Nash
equilibrium.

However, there exist other Nash equilibria, such as the scenario described
in Example 20 in the appendix. The presented equilibrium is based on a player
threatening to induce penalties for other players by suﬀering penalties herself.
Intuitively speaking, we suggest all Nash equilibria where some player does not
follow the protocol are of this nature, but we do not formalize this concept. How-
ever, if the adversary wishes to spend resources solely to inﬂuence the behaviour
of rational miners, there are always ways to achieve this outside the scope of any
reward scheme, such as bribery (see Section 5.4).

4.5 Hurting Other Players

When designing a reward scheme, it might be seen as fair if each honest player is
rewarded irrespectively of the strategies of other players. Such fairness principle
is enjoyed by the Fruitchains protocol and our reward scheme R0. However,
those schemes inevitably trivialize some aspect of the game and leave potential
for deviation that goes unpunished. A relaxation of this principle is stated in
Corollary 19 based on Theorem 17 and its proof.

Corollary 19. Under the reward scheme Rc,b, by deviating from the protocol
the adversary can only reduce the rewards of other players by forfeiting at least
the same amount.

We observe that the property stated in Corollary 19 prevents the existence of
selﬁsh mining strategies such as those concerning Bitcoin and other traditional
blockchains (see Section 5.1). Such strategies pose a threat since they enable
forfeiting some rewards to penalize other players to an even bigger extent.

5 Related Work

The model of round-based communication in the setting of blockchain was in-
troduced in [3]. This paper formalizes and studies the security of Bitcoin.

5.1 Selﬁsh Mining

Selﬁsh mining is a branch of research studying a type of strategies increasing
the proportion of rewards obtained by players in a Bitcoin-like system. Selﬁsh
mining exempliﬁes concerns stemming from the lack of proven incentive compat-
ibility. Selﬁsh mining was ﬁrst described formally in [2], although the idea had
been discussed earlier [10]. Selﬁsh mining strategies have been improved [15] and
generalized [13]. Selﬁsh mining is not applicable to our incentive scheme.

Better Incentives for Proof-of-Work

13

5.2 DAG

The way we order all blocks for the purpose of processing them was introduced
in [7]. The authors consider an incentive scheme to accompany this modiﬁcation.
Their design relies on altruism, as referring extra blocks has no beneﬁt, other
than to creators of referred blocks. Hence, rational miners would never refer
them, possibly degenerating the DAG to a blockchain similar to Bitcoin’s. Some
other shortcomings are discussed by the authors.

The authors of [8] contribute an experimental implementation of the directed
acyclic graph structure and ordering of [7], in particular its advantages with
respect to the throughput.

5.3 Fruitchains

Fruitchains [14] is the work probably the closest related to ours. Fruitchains is a
protocol that gives a guarantee that miners are rewarded somewhat proportion-
ally to their mining power. The objective might seem similar to ours, but there
are fundamental diﬀerences. To achieve fairness, similarly to existing solutions,
the Fruitchains protocol requires the majority of miners to cooperate without
an incentive. In other words, in order to contribute to the common good of the
system, players must put in altruistic work. In contrast, we strive for a protocol
such that any miner simply trying to maximize their share or amount of rewards
will inadvertently conform to the protocol.

The Fruitchains protocol rewards mining of “fruits”, which are a kind of
blocks that do not contribute to the security of the system. The Fruitchains
protocol relies on merged-mining 4 also called 2-for-1 PoW in [3]. In addition to
fruits, the miners can mine “normal” blocks (containing the fruits) with mini-
mal extra eﬀort and for no reward. The functioning and security of the system
depends only on mining normal blocks according to the protocol.

Miners are asked to reference the fruits of other miners, beneﬁting others
but not themselves, similarly to [7]. The probability of not doing so having any
eﬀect is negligible, since majority of the miners are still assumed to reference
said fruits.

The resulting system-wide cooperation guarantees fairness, inevitably remov-
ing many game-theoretic aspects from the resulting game. In particular, misbe-
haviour does not result in any punishment. It is common to analyze blockchain
designs with respect to the expected cost of a double-spend attempt. In the case
of Fruitchains, while the probability of double-spends being successful is similar
to previous designs, the cost of attempting to double-spend is nulliﬁed. As a
result, any miner might attempt to double-spend constantly at no cost, which
we view as a serious jeopardy to the system.

In the absence of punishments, we also argue that not conforming to the
protocol is often simpler. Since transaction fees are shared between miners, in-
cluding transactions might be seen as pointless altogether. Mining only fruits

4 One of the ﬁrst mentions of merged-mining as used today is [12], although the general

idea was mentioned as early as [4].

14

Jakub Sliwinski, Roger Wattenhofer

with dummy, zero-fee transactions, while not including the fruits of others (or
not mining for blocks altogether), would relieve the miner of a vast majority of
the network communication.

Another game-theoretic issue of the Fruitchains protocol is that while it
prescribes sharing of the transaction fees, miners might ask transaction issuers
to disguise the fee as an additional transaction output, locking it to a speciﬁc
miner, potentially beneﬁting both parties and disrupting the protocol.

As argued in Section 4, the reward scheme R0 is an improvement over
Fruitchains in the same vein, achieving the same result while avoiding some
of the complications.

In contrast to Fruitchains protocol, the approach of reward schemes Rc,b is
to employ purely economic forces, clearly incentivizing desired behaviour while
making sure that deviations are punished.

5.4 Bribery

Recently, there have been works highlighting the problems of bribery, e.g. [1,5,9].
A bribing attacker might temporarily convince some otherwise honest players
(either using threats or incentives) to join the adversary. Consequently, the ad-
versary might gain more than half of the computational power, taking over the
system temporarily.

Such bribery might be completely external to the reward scheme itself, for
example the adversary might program a smart contract (perhaps in another
blockchain) that provably oﬀers rewards to miners that show they deviate from
the protocol [5]. Hence, no permissionless blockchain can be safe against this
type of attack.

6 Conclusions

Mining is a risky business, as block rewards must pay for hardware investments,
energy and other operation costs. At the time of this writing, the Bitcoin mining
turnover alone is worth over $10 billion per year, which is without a doubt a
serious market. Miners in this market are professionals, who will make sure that
their investments pay oﬀ. Yet, many believe that a majority of miners will follow
the protocol altruistically, in the best interests of everybody, the “greater good”.
We argue that assuming altruistic miners is not strong enough to be a foun-
dation for a reliable protocol. In this work, we introduced a blockchain incentive
scheme such that following the protocol is guaranteed to be the optimal strategy.
We showed that our design is tolerant to miners acting rationally, trying to
get the maximum possible rewards, with no consideration for the overall health
of the blockchain.

To the best of our knowledge, our design is the ﬁrst to provably allow for
rational mining. Nakamoto [11] needed “honest nodes collectively control more
CPU power than any cooperating group of attacker nodes”. With our design it
is possible to turn the word honest into the word rational.

References

Better Incentives for Proof-of-Work

15

1. Bonneau, J.: Why buy when you can rent? - bribery attacks on bitcoin-style con-
sensus. In: Financial Cryptography and Data Security - FC 2016 International
Workshops, BITCOIN, VOTING, and WAHC, Christ Church, Barbados, Febru-
ary 26, 2016, Revised Selected Papers. pp. 19–26 (2016)

2. Eyal, I., Sirer, E.G.: Majority is not enough: Bitcoin mining is vulnerable. In:
18th International Conference on Financial Cryptography and Data Security. pp.
436–454 (2014)

3. Garay, J., Kiayias, A., Leonardos, N.: The bitcoin backbone protocol: Analysis
and applications. In: 34th Annual International Conference on the Theory and
Applications of Cryptographic Techniques. pp. 281–310 (2015)

4. Jakobsson, M., Juels, A.: Proofs of work and bread pudding protocols. In: Secure

Information Networks, pp. 258–272 (1999)

5. Judmayer, A., Stifter, N., Zamyatin, A., Tsabary, I., Eyal, I., Gazi, P., Meiklejohn,
S., Weippl, E.: Pay-to-win: Incentive attacks on proof-of-work cryptocurrencies.
Tech. rep., Cryptology ePrint Archive, Report 2019/775 (2019)

6. Kiayias, A., Panagiotakos, G.: On trees, chains and fast transactions in the
blockchain. In: 5th International Conference on Cryptology and Information Secu-
rity in Latin America (2017)

7. Lewenberg, Y., Sompolinsky, Y., Zohar, A.: Inclusive block chain protocols. In:
19th International Conference on Financial Cryptography and Data Security. pp.
528–547 (2015)

8. Li, C., Li, P., Xu, W., Long, F., Yao, A.C.: Scaling nakamoto consensus to thou-

sands of transactions per second. arXiv preprint arXiv:1805.03870 (2018)

9. McCorry, P., Hicks, A., Meiklejohn, S.: Smart contracts for bribing miners. In:
Financial Cryptography and Data Security - FC 2018 International Workshops,
BITCOIN, VOTING, and WTSC, Nieuwpoort, Cura¸cao, March 2, 2018, Revised
Selected Papers. pp. 3–18 (2018)

10. mtgox:
(2010)

https://bitcointalk.org/index.php?topic=2227.msg29606#msg29606

11. Nakamoto, S.: Bitcoin: A peer-to-peer electronic cash system (2008)
12. Nakamoto, S.: https://bitcointalk.org/index.php?topic=1790.msg28696#msg28696

(2010)

13. Nayak, K., Kumar, S., Miller, A., Shi, E.: Stubborn mining: Generalizing selﬁsh
mining and combining with an eclipse attack. In: 1st IEEE European Symposium
on Security and Privacy (2016)

14. Pass, R., Shi, E.: Fruitchains: A fair blockchain. In: Symposium on Principles of

Distributed Computing. pp. 315–324 (2017)

15. Sapirshtein, A., Sompolinsky, Y., Zohar, A.: Optimal selﬁsh mining strategies in
bitcoin. In: 20th International Conference on Financial Cryptography and Data
Security. pp. 515–532 (2016)

16. Sompolinsky, Y., Zohar, A.: Secure high-rate transaction processing in bitcoin. In:
19th International Conference on Financial Cryptography and Data Security. pp.
507–527 (2015)

16

Jakub Sliwinski, Roger Wattenhofer

Appendix

A Discussion of Block Content and Transaction Fees

Depending on the use of the blockchain, miners can be rewarded for including
contents in their blocks in various ways. Typically, a transaction fee is awarded
to only one miner that ﬁrst includes the transaction in a block. As a result, the
order of processing blocks is important for determining who collects the fees, as
it indicates which block is the ﬁrst. Problematic incentives are introduced with
respect to manipulating the order.

Any particular fee-sharing scheme cannot be enforced, because the fee might
be disguised as a regular transaction output paid to the miner directly. This can
beneﬁt both the transaction issuer and the miner, incentivizing the behaviour.5
To be incentive compatible, it is not necessary that the fees are spread pro-
portionally. What we want is that the miners never have an incentive to omit a
reference to another block. As all blocks are assumed to eventually be included
in the blockchain, it is enough to ensure that suﬃciently small changes of the
linearized order of the blocks have no eﬀect on the miner rewards. This can be
achieved by allowing multiple blocks to claim the same inclusion of contents,
and having the fee be shared among the including blocks equally.

In other words, any player who wishes to include a transaction can do so
within a certain window, without an eﬀect on their incentives to reference other
blocks. Crucially, sending the fee directly to a miner as a transaction output
removes the incentive for other miners to include the transaction, as well as the
incentive to manipulate the place of the including block in the order.

The point of such a change would be to separate transaction inclusion from
referencing blocks. Transaction inclusion is a complex game in itself, similar to
the game studied by [7].

B Proofs

2(α+β)(1+ǫ) − 1

Proof of Theorem 9. Let B be an honest block mined on round r. With
probability 1 − e−Ω(p), after round r + O(p) each honest player H adopts a main
chain ending with a block BH such that B ∈ ¯SBH .
p

2 ⌋ = O(p). By Lemma 2, with probability
Proof. Let ∆ = ⌊
1 − e−Ω(∆), on and after round r, honest players have adopted main chains
containing a block C mined between rounds r − ∆ and r (or the genesis block
if r − ∆ < 1). Hence C is an ancestor of B. By Lemma 2, let D be the honest
block mined between rounds r + 1 and r + ∆ + 1 that honest players adopted in
the main chain on and after round r + ∆ + 1, again with probability 1 − e−Ω(∆).
D is honest and mined after round r, so B ∈ past(D).

5 If we disregard this vulnerability, the same fee-sharing approach as employed by the

Fruitchains protocol can be applied to our work.

Better Incentives for Proof-of-Work

17

Since C was mined on or after round r − ∆, and D was mined on or before
round r + ∆ + 1, D(C, D) is at most the number Y of blocks mined between
rounds r − ∆ and r + ∆ + 1. By the Chernoﬀ bound:

− ǫ2 (2(α+β)∆)
3

e

≥ Pr[Y ≥ (1 + ǫ)(α + β)(2∆ + 1)] ≥ Pr[Y ≥ p]

Since C is an ancestor of D, C is an ancestor of LCA(B, D), and D(C, D) ≥

D(LCA(B, D), D). By Algorithm 3:

D(C, D) < p =⇒ B ∈ ¯SD.

By union bound, the probability that such C and D exist and that B ∈ ¯SD

is at least equal

1 − 2e

−Ω(∆) − e

− ǫ2 (2(α+β)∆)
3

= 1 − e

−Ω(p).

By Corollary 8 and induction, with probability 1 − e−Ω(p), after round r + ∆ all
honest players adopt only chains ending with blocks X such that B ∈ ¯SX .
⊓⊔

Proof of Lemma 13 Let x ≥ p and B be a block. The probability that any honest
player adopts a main chain ending with a block A such that |XA(B)| > xp is
e−Ω(x).

Proof. Let r be the round B was announced. Let Pi, i ∈ {1, . . . , 2p} (respectively
Fi, i ∈ {1, . . . , p}), be an honest block mined between rounds r − xi
4 − 1 and
r − x(i−1)
4 + 1 and r + xi
4 + 1) contained in the main chain
of every honest player on and after round r + xp
4 + 1; by Lemma 2 and union
bound such blocks exist with probability 1 − e−Ω(x).

4 − 1 (resp. r + x(i−1)

Since F1 is honest, B ∈ past(F1). By Algorithm 3, if Pp /∈ past(B), then
B ∈ SF1 and XA(B) remains undeﬁned for honest players. Otherwise, assume
Pp ∈ past(B).

Let Z be a block such that Z /∈ past(B) ∧ B /∈ past(Z). Since Z /∈ past(B),
Z /∈ past(Pp). By Algorithm 3, either P2p ∈ past(Z), or Z becomes stale in the
main chains of honest players from round r− x(p−1)
4 −1 on. Assume P2p ∈ past(Z),
and hence Z is mined on or after round r − 2xp
4 − 1.

Since B /∈ past(Z), F1 /∈ past(Z). Then, either Z is announced before round
4 + 1, or by Algorithm 3, Z becomes stale in the main chains of honest

r + xp
players afterwards. Assume Z is announced before round r + xp

4 + 1.

Therefore, Z ∈ XA(B) implies that Z is mined between rounds r − 2xp

4 − 1
4 + 1. Let Y be the number of blocks mined between these rounds. By

and r + xp
Chernoﬀ bound:

Pr[Y ≥ xp] ≤ Pr[Y ≥

4
3

(α + β)(

3xp
4

+ 2)] = e

−Ω(x).

Note the bound is appliable to any main chain of an honest player before
⊓⊔

4 + 1 as well. The claim follows from the union bound.

round r + xp

18

Jakub Sliwinski, Roger Wattenhofer

Proof of Lemma 15 If D(P (A), LCA(P (A), B)) > 2p then XA(B) = XP (A)(B)

Proof. From Deﬁnition 11, XP (A)(B) ⊆ XA(B). Suppose for contradiction ∃Y :
Y ∈ XA(B)\XP (A)(B). From Deﬁnition 11, B ∈ ¯SA, therefore B ∈ past(P i(A)).
Hence, P i(A) /∈ past(Y ). Since Y /∈ past(P (A)), D(A, LCA(A, Y )) > p and
⊓⊔
Y ∈ SA, a contradiction.

Proof of Theorem 17 Deviating from the protocol reduces the adversary’s
rewards and its proportion of rewards Rc,b, except with negligible probability.

Proof. Honest blocks are not-stale, except with negligible probability (Theorem
9). Block rewards are ﬁnal and non-negative, except with negligible probability
(Corollaries 16 and 14). Hence, eventual value of Rc,b(B) for honest blocks B
depends only on |XA(B)|. Since Y ∈ XA(Z) ⇐⇒ Z ∈ XA(Y ), by increasing
|XA(B)| of an honest block the adversary can only reduce the rewards of hon-
est players (by c|XA(B)|) if the adversary forfeits the same amount. Since the
adversary constitutes a minority, its proportion of rewards decreases as well.

The adversary can also produce stale blocks, forfeiting the otherwise non-

negative reward, while not changing the rewards of honest players.

Not referencing some known honest block directly increases |XA(B)|. With-
holding a block might only prevent some honest player from referencing it, thus
increasing |XA(B)|. Hence, any strategy eﬀectively diﬀerent from the protocol
increases |XA(B)| of produced blocks, thus decreasing the amount and share of
⊓⊔
rewards of the adversary.

B.1 Example Equilibrium

Example 20. Four blockchain players with equal hashing power each adopt the
following strategies:

– Player 1 and 2: Follow the protocol.
– Player 3: Do not broadcast new blocks in the ﬁrst round, otherwise follow

the protocol.

– Player 4: If you receive three blocks of other players (child blocks of the
genesis block) at the beginning of the second round, then induce penalties
for yourself and other players as much as possible forever. Otherwise follow
the protocol.

Since Player 3 refrains from broadcasting blocks in the ﬁrst round, Player 4 can
never receive three blocks of other players in the second round, and thus the
strategy of Player 4 is identical to following the protocol.

However, Player 3 deviates from the protocol. With some constant probability
Players 1 and 2 broadcast a block each in the ﬁrst round, so if Player 3 broadcast
a block in the ﬁrst round, Player 4 could receive three blocks. Then, this action
would change the behaviour of Player 4 to cause penalties to herself and Player
3. Hence, the strategy proﬁle is a Nash equilibrium.

