ALDER: Unlocking blockchain performance by
multiplexing consensus protocols

Kadir Korkmaz∗ Joachim Bruneau-Queyreix∗ Sonia Ben Mokthar† Laurent Réveillère∗
∗ Univ. Bordeaux, CNRS, Bordeaux INP, LaBRI, UMR5800, F-33400 Talence, France
† CNRS - LIRIS. Lyon, France

2
2
0
2

b
e
F
7

]

C
D
.
s
c
[

1
v
6
8
1
3
0
.
2
0
2
2
:
v
i
X
r
a

Abstract—Most of today’s online services (e.g., social net-
works, search engines, market places) are centralized, which
is recognized as unsatisfactory by a majority of users for
loss
various reasons (e.g., centralized governance, censorship,
of control over personal data). Blockchain technologies promise
a new Web revolution (Web 3.0) through the decentralization
of online services. However, one of the key limitations for this
revolution to happen at a planetary scale is the poor performance
of today’s blockchains. We propose in this paper ALDER, a
solution for unlocking the performance of off-the-shelf leader-
based blockchains by multiplexing their consensus protocol. Our
solution leverages the existence of multiple potential leaders to
alleviate the bottleneck that exists at different levels of consensus
protocols. To illustrate the beneﬁts it brings to Blockchain per-
formance, we apply ALDER to three representative blockchains,
namely Algorand (Proof-of-Stake), RapidChain (Sharding-based)
and Bitcoin (Proof-of-Work). Our evaluation, involving up to
10,000 nodes deployed on 100 physical machines, shows that
using ALDER can provide up to a 300% improvement in both
throughput and latency reduction.

I. INTRODUCTION

Blockchains are decentralized, globally distributed, strongly
consistent replicated systems that run across networks of
mutually untrusted nodes. Since the emergence of the decen-
tralized Bitcoin protocol [1], permissionless blockchains have
demonstrated their ability to run arbitrary distributed applica-
tions [2] with the promise of supporting entire decentralized
economies [3], business ecosystems across industries [4],
decentralized service infrastructures [5] and have even the
ambition of decentralizing the entire Web [6]. Achieving the
latter use cases requires efﬁcient and performant blockchain
solutions. From the oldest blockchains (e.g., Bitcoin) to the
newest (e.g., OHIE, Red Belly), the race towards more ef-
ﬁcient and performant blockchains is still ongoing. While
some blockchains aim at replacing the others, it is commonly
admitted that there is no one blockchain that will ﬁt the needs
of the wide variety of distributed applications [7]. In this
context, solutions that aim at improving the performance of
off-the-shelf blockchains take a real sense, which is our aim
in this paper.

A key building block that is often considered a bottleneck
in blockchain performance is the consensus protocol used
to agree on the next block to append [8]. There are a
variety of these blockchain consensus protocols (e.g., Proof-of-

Identify applicable funding agency here. If none, delete this.

Work [1], [9]–[14], Proof-of-Stake [3], [15], committee-based
protocols [3], [11], [12], [14]).

In this paper, we focus on leader-based consensus protocols.
These protocols, deployed at the heart of major blockchains
(e.g., Bitcoin, Ethereum, Hyperledger, Algorand), elect a
leader that is responsible for proposing a block. In the process
of electing a single leader, consensus protocols typically
leaders. We argue that blockchain
identify many potential
protocols could directly beneﬁt from the contribution of these
candidate leaders to improve their performance by distributing
the load and sharing the use of resources between them. More
speciﬁcally, we claim that the contribution of multiple leaders
to the addition of a block to the blockchain can either reduce
conﬁrmation latency or increase the amount of data added to
a given block.
Contributions. We present ALDER a solution that empowers
existing blockchains by multiplexing their consensus proto-
cols, allowing multiple leaders to operate in parallel. Leaders
in ALDER are elected by leveraging candidate leaders who
are not exploited in the original consensus protocol. Then,
the elected parallel leaders independently propose concurrent
blocks containing disjoint sets of transactions, the union of
which constitutes a macroblock to append. Since ALDER
builds on existing blockchain protocols, the resulting proto-
cols inherit the safety and liveness properties of the parent
protocol. To assess the effectiveness of ALDER, we apply
its principles to three major blockchains: RapidChain [12],
a fast sharding-based blockchain, Algorand [3], a scalable
proof-of-stake blockchain, and Bitcoin, a well-known proof-
of-work blockchain. Our evaluation, involving up to 10,000
nodes deployed on 100 physical machines, shows that using
ALDER can provide up to a 300% improvement in both
throughput and latency reduction.
Outline. We discuss related work in Section II. We detail
our system model and assumptions in Section III. We present
ALDER and its building blocks in Section IV. We describe
the use of ALDER on three representative blockchains in
Section V. We evaluate the resulting systems in Section VI,
and conclude in Section VII.

II. RELATED WORK

The past decade acknowledges numerous solutions aiming
to improve the performance of blockchain consensus algo-
rithms. For instance, BitcoinNG [16] improves the throughput

 
 
 
 
 
 
of the Bitcoin protocol by decoupling leader election from
transaction serialization. Similarly to Bitcoin, in BitcoinNG a
leader is elected using cryptographic puzzles. The difference
resides in the fact that the latter submits blocks until a new
leader is elected. In this protocol, forks frequently happen
during the switch between one leader to another. ByzCoin [11]
also decouples leader election from transaction serialization as
in BitcoinNG. In ByzCoin, the last n puzzle solvers constitute
a committee to decide on blocks. Committee members use
communication trees to improve the communication complex-
ity, and they use CoSi [17] to have a fast consensus. Algo-
rand relies on cryptographic sortitions and veriﬁable random
functions (VRFs) to sample a subset of nodes that will act as
leaders and committee members. RapidChain [18] partitions
nodes into committees called shards that sustain disjoint
blockchains. To boost performance, RapidChain employs an
efﬁcient synchronous consensus algorithm that decreases the
cost of communication inside a committee. Similarly to Rapid-
Chain, Monoxide [19], Elastico [20] and Omniledger [21]
also employ sharding to improve the transaction processing
capacity of blockchains.

Although all these propositions improve over the perfor-
mance of existing blockchains, they remain speciﬁc solutions
that can hardly be exploited for future blockchains. Instead,
we present in ALDER a set of principles that can be applied
to a variety of off-the-shelf blockchains to improve their
performance. To reach this objective, ALDER leverages prim-
itives that have been successfully used in various consensus
protocols. Speciﬁcally, we have been inspired by the following
protocols when developing ALDER: Paxos [22] is one of the
ﬁrst crash fault-tolerant consensus algorithms, and Mencius
[23] improves the WAN performance of Paxos protocol by
dividing the available sequence numbers between replicas.
Hence, each replica leads a separate consensus instance of its
own. BFT-Mencius [24] applies the approach of Mencius to the
famous PBFT [25] protocol. Unlike Mencius, BFT-Mencius
targets the bounded delay in such a way that each client
request can be processed in a bounded time interval despite the
presence of Byzantine nodes in the system. Mir-BFT [26] is
a recent solution that employs a similar technique to improve
the WAN performance of the PBFT protocol. Unlike Mencius
and BFT-Mencius, Mir-BFT employs a novel request bucket
assignment technique to handle censorship attacks. In Mir-
BFT, client requests are partitioned into a ﬁxed number of
buckets. Then, each bucket is assigned to one of the replicas.
Assigned buckets are frequently rotated so that a replica cannot
censor requests from speciﬁc clients. ALDER’s principles are
also inspired by the bucket mechanism to partition the space
of requests between leaders as further discussed in Section IV.
OHIE [27] is a recent blockchain protocol. OHIE uses
cryptographic puzzles to elect
leaders, and its Blockchain
consists of up to 1000 parallel chains. In OHIE, nodes replicate
all parallel chains. Like ALDER, nodes in OHIE propose
small blocks that disseminate fast, and OHIE elects many
leaders by decreasing the difﬁculty of cryptographic puzzles.
In OHIE, an elected leader is assigned to one of the parallel

chains in a publicly veriﬁable manner to append a block.
Unlike ALDER, OHIE does not partition the hash space
of transactions to handle redundant transaction processing;
therefore it might suffer from appending the same transaction
several times.

Red Belly [28] is another recent blockchain proposition that
relies on a novel Democratic Byzantine Consensus (DBFT) al-
gorithm. Red Belly considers a permissioned system in which
only subset of nodes is allowed to be proposer; therefore,
proposers are not elected. As ALDER, DBFT has proposers
that propose disjoint set of transactions to append to the
ledger. All proposed disjoint transactions can be appended at
the end of consensus as a super-block. Red Belly employs a
partial validation mechanism to share the cost of transaction
validation as nodes only validate a subset of transactions.

III. SYSTEM MODEL AND OBJECTIVES

The work presented in this paper aims to improve the
performance of existing leader-based blockchain consensus
protocols by optimizing resource usage on the critical path
to consensus decisions. Our approach does not consist of
inventing new consensus protocols. Conversely, we observe
that blockchains can suffer from bottlenecks at various levels,
from the efﬁciency of block dissemination techniques, to the
average waiting time between the resolution of two crypto-
puzzles, to the communication complexity of committee-based
consensus. ALDER proposes to alleviate these bottlenecks by
multiplexing the execution of the consensus protocol, involv-
ing more leaders in the different steps leading to consensus
decisions. These additional leaders are identiﬁed from the set
of candidate leaders in the original election mechanism. In this
work, we consider a subset of blockchain protocol models that
incorporate leader election, block dissemination and consensus
rules operating under partial synchrony. Our work excludes
leaderless consensus algorithms [29] and leaderless blockchain
models such as Avalanche [30].

ALDER consists of a set of reusable principles that, when
applied to the different components of an existing blockchain
protocol, improve its performance in terms of throughput or
transaction latency. The resulting protocol inherits the safety
and liveness properties of the original consensus protocol by
holding on to the messaging, data structures, and decision
making rules of the underlying protocol.

IV. ALDER: SYSTEM DESIGN

In this section, we present the set of ALDER principles
that allow to multiplex a leader-based Blockchain Consensus
Protocol (BCP) and increase its performance. The resulting
blockchain consensus protocol is referred to as BCP++ in the
remainder. Figure 1 illustrates this transformation on a BCP
in its canonical form with: leader election, block proposal,
block dissemination and consensus. In the blockchain models
considered, the leader election mechanism identiﬁes a node
(sometimes several, either by design principle or by side
effect) that must propose a candidate block to the rest of the
nodes in the system. Once disseminated to the other nodes, an

2

Fig. 2: BCP++ macroblockchain structure

B. Transaction duplication and duplication attacks

We leverage the leader election mechanism of BCP to
involve more leaders in the blockchain consensus protocol and
increase its performance. More speciﬁcally, all elected leaders
propose candidate blocks to form the next macroblock.

However, appending multiple blocks of transactions in a
given round poses the problem of duplicate transactions and
duplicate attacks. Indeed, in a simple approach, leaders could
create blocks with any transaction they received. As a result,
some blocks could include transactions that would also appear
in some of the blocks proposed by other leaders. This would
reduce the throughput gain envisioned in our approach and
increase the complexity of the transaction execution phase.

Duplication of transaction also opens the doors for dupli-
cation attacks by an adversary controlling Byzantine nodes.
When some of these nodes get elected, the adversary may wait
to learn about blocks proposed by the honest leaders and have
its Byzantine leaders proposing blocks containing the same
transactions, thus reducing the performance gain of BCP++.
To cope with this problem, ALDER incorporates the prin-
ciples of partitioning the transaction hash space and proposing
disjoint blocks.

C. Transaction hash space partitioning and bucket assignment

Nodes partition the transaction hash space into Cl non-
intersecting buckets of equal size. Each leader is assigned a
bucket of transactions in an unforgeable and publicly veriﬁable
way during the leader election phase. To avoid duplication
attacks,
they are
leaders cannot decide on which bucket
assigned to. Each block proposed by a leader must contain
exclusively transactions whose hashes fall within the bucket
assigned to the leader. In this way, any node can validate the
correct fabrication of a received block by checking its contents
against the bucket assigned by the block proposer. Figure 3
illustrates the mapping of transactions to assigned buckets,
with Cl = 3.

V. CASE STUDIES: APPLICATION ON THREE BLOCKCHAIN
PROTOCOLS

In this section, we show the application of ALDER’s
principles on three different permissionless blockchain con-
sensus protocols: Algorand, Bitcoin and Rapidchain. Each of
these blockchains is representative of a different blockchain

Fig. 1: Multiplexing a blockchain BCP using ALDER

agreement must be reached to consider the proposed block as
a valid extension of the BCP blockchain.

ALDER extends BCP to BCP++ using the following
four principles: (1) In each round, BCP++ elects multiple
leaders by extending the election mechanism of the original
BCP, (2) leaders propose blocks that contain disjoint sets of
transactions by (3) partitioning a transaction hash space into
buckets and assigning each leader to one of the buckets in an
unforgeable and publicly veriﬁable way. Finally, (4) BCP++
runs a multiplexed version of the BCP consensus to produce a
decision on a composition of the proposed blocks. We call this
last composition macroblock. The nodes in the system wait for
this decision to aggregate the agreed-upon list of blocks and
actually add a macroblock to the chain before moving on to the
next protocol round. We now detail the principles of ALDER
and how they articulate together.

A. Multiplexed consensus and macroblocks

A macroblock is a logical composition of up to Cl blocks
of size bs bytes, with Cl a bootstrap parameter that deﬁnes the
concurrency level of BCP++. The resulting macroblock has a
size of Cl × bs bytes. Each block in the macroblock contains
the hash of the previously appended macroblock.

The consensus of BCP++ produces a decision on the
composition of the next macroblock that should be appended
to the chain. This decision consists of a vector of up to Cl
hashes of candidate blocks. Each node in the system listens for
the blocks proposed by the set of leaders, and locally builds
a macroblock based on the consensus decision produced.

Figure 2 depicts an example of a chain of macroblocks
with a concurrency level Cl of 3. Dashed lines represent
macroblocks, and solid squares indicate the composing blocks.
ALDER does not require that each macroblock contain ex-
actly Cl blocks as shown in the ﬁgure. Indeed, the blockchain
protocol model considered for BCP includes existing protocols
that can produce empty blocks, such as Algorand [3]. In
addition, consensus on some of the proposed blocks may not
be reached.

3

1 BlockALDERLeader electionBlock proposalBlock disseminationConsensus1 Macroblock of Cl blocksRound r-1...Instance of BCPRound r-1............BCPchainBCP++chainRound r+1Round r+1rr-1r-2r-3r-4rr-1r-2r-3r-4Multiple leader electionDisjoint block proposalBlock disseminationMultiplex consensusInstance of BCP++B[1]B[1]B[0]B[0]B[0]B[2]B[2]B[2]B[1]B[0]B[2]round r-1round rround r+1round r+2Fig. 3: Mapping transactions to a bucket with Cl = 3. Solid
lines represent the assigned bucket for a given node. Hash(tx1)
is mapped to the ﬁrst bucket, assigned to node 1. Hash(tx2) is
mapped to the third bucket, assigned to node 2.

family. Bitcoin is the original PoW-based blockchain protocol
described by Nakamoto [1]. Rapidchain illustrates one of the
most throughput-efﬁcient approaches for sharded blockchain
protocols. Finally, Algorand is among the most scalable stake-
and committee-based blockchain protocols achieving minimal
transaction conﬁrmation latency.

A. Algorand++: Applying ALDER to Algorand

Algorand [3] is among the most scalable PoS-based per-
missionless blockchain. To scale the consensus to many
users, it relies on a cryptographic sortition mechanism that
randomly and in non-interactive way selects committees of
nodes. Committees are charged either to propose blocks or to
contribute to a Byzantine agreement protocol called BA(cid:63) to
reach a consensus on one of the proposed blocks. Algorand
has a low transaction conﬁrmation latency of the order of a
minute. Despite the impressive performance of Algorand (125-
fold throughput
improvement compared with the Bitcoin),
this protocol still suffers from performance limitations. In
particular, its performance drops dramatically with large block
sizes. Indeed, the time of gossiping blocks in the network
largely dominates the duration of BA(cid:63). This long gossip is
an important limitation to increase throughput. Increasing the
block size would only increase the conﬁrmation latency and
keep the throughput at its highest level in the best case.

To make a better use of the network as well as the proposed
blocks, we consider ALDER’s principle as a sound approach.
1) Algorand protocol: Figure 4 depicts the ﬁve main steps
of an Algorand round. First (step (cid:182)), each node executes
a cryptographic sortition to determine whether it belongs to
some of the committees responsible for conducting the three
following steps of the protocol: the block proposal step, the
reduction and binary agreement steps of Algorand’s Byzantine
agreement BA(cid:63). In the second step (step (cid:183)), a ﬁrst committee
of nodes, i.e., leaders, proposes blocks to be appended to the
blockchain. Then (step (cid:184)), Algorand’s Byzantine agreement
procedure BA(cid:63) reduces the problem of agreeing on one of
many blocks hashes to agreeing on either a selected block
hash or a default empty block hash, and reaches consensus
via a binary agreement called BinaryBA(cid:63) (step (cid:185)) Finally
(step (cid:186)), every node counts votes cast during the BA(cid:63) phase
to learn about the outcome of the agreement procedure a
ﬁnal consensus. To prevent an adversary from learning the
identity of committee nodes and forging targeted attacks,

Fig. 4: Algorand and Algorand++ round structures. Black
texts, arrows and boxes depict the round structure of Algorand
while green elements illustrate Algorand++

nodes determine if they belong to speciﬁc committees through
an independent and non-interactive cryptographic sortition
procedure. In addition, committees are different for each step
of the protocol to prevent targeted attacks on committee mem-
bers once they send a message. Regarding communications,
Algorand relies on gossip. Each node selects a small random
set of peers to which it transmits block and protocol messages.
Cryptographic sortition (leader election): Cryptographic
sortition enables an expected fraction of nodes to be selected
at random based on their weights (i.e., their currency stake
in the system) for a speciﬁc committee of the protocol in
a publicly veriﬁable, and non-interactive manner. Each node
runs the cryptographic sortition procedure for each of the
committees by computing a has value from a Veriﬁable
Random Function [31] (VRF) 1 of its private key and seed
obtain from the last block of the blockchain. If the function’s
output indicates that the node is chosen, it returns a short proof
string that proves this node’s committee membership to other
nodes, which the node can include in its messages.

Block proposal: All nodes execute the cryptographic sorti-
tion to determine whether they are selected to propose a block
in a given round. The sortition is designed to elect an expected
number of τproposer block proposers. At a high level, the
sortition for the block proposal step ensures that an expected
τproposer number of nodes are selected at random, weighted by
their account balance. It also provides each selected node with
a priority, which can be compared across users, and a proof
of the selected node’s priority. Since the selection is random,
there may be multiple nodes selected to propose a block, and
the priority determines which block every node should adopt.

1V RF is a public-key pseudorandom function that provides proofs that
its outputs were calculated correctly. The owner of the secret key sk can
compute the (cid:104)value, π(cid:105) ← V RFsk(x) on any input x to produce a hash
value function value and an associated proof π. Any node in possession of
the associated public key can π check that this value was indeed calculated
correctly with the input x, without using the secret key.

4

MultiplexedreductionMultiplexedbinary BA★Final multiplexed consensusMany disjoint blocksMultiplexedBA★Many votesCrypto. Sort.Crypto. Sort.Round rRound r+1Round r-1Disjointblock proposalCrypto. Sort.Macroblock in round r-1Macroblock in round rGossip communicationsBucket assignmentOne vector of disjoint block hashesOne block hashMany votesBlock in round r-1Block in round rMany blocks∏<latexit sha1_base64="rdqhxpJO3Qb7KlC6bvENV2Zh4dk=">AAAC9XicjVLLSsNAFL2Nr1pfVZdugkVwVZIq2GXRjcsK9oFtkSSd1sE0CclEKaV/4bauxK3f4x8o/oRnximoxceEJGfOPefO3LnjRj5PhGU9Z4y5+YXFpexybmV1bX0jv7lVT8I09ljNC/0wbrpOwnwesJrgwmfNKGbOwPVZw70+kfHGDYsTHgbnYhixzsDpB7zHPUeAumh3edAf2eXD8WW+YBUtNcxZYGtQID2qYf6N2tSlkDxKaUCMAhLAPjmU4GmRTRZF4Do0AhcDcRVnNKYcvClUDAoH7DW+fcxamg0wlzkT5fawio83htOkPXhC6GJguZqp4qnKLNmfco9UTrm3If6uzjUAK+gK7F++qfL/vggV97A3eTK/1yygK6taOdSRYuQpeHq1VJ2erND8VL1AhgicxF3EY2BPOaf9MJUnUWcke+Co+ItSSlbOPa1N6VVWg4tgf2/7LKiXivZBsXRWKlSO9ZXI0g7t0j76fkQVOqUq1ZA7oDua0L1xa0yMB+PxQ2pktGebvgzj6R2BEpvX</latexit>π<latexit sha1_base64="nkR5ykPKIw8t2O6VFVC3X75ssRw=">AAAC9XicjVLLSsNAFL2Nr1pfVZdugkVwVZKK2GXRjcsK9oFtkSSd1sE0CclEKaV/4bauxK3f4x8o/oRnximoxceEJGfOPefO3LnjRj5PhGU9Z4y5+YXFpexybmV1bX0jv7lVT8I09ljNC/0wbrpOwnwesJrgwmfNKGbOwPVZw70+kfHGDYsTHgbnYhixzsDpB7zHPUeAumh3edAf2eXD8WW+YBUtNcxZYGtQID2qYf6N2tSlkDxKaUCMAhLAPjmU4GmRTRZF4Do0AhcDcRVnNKYcvClUDAoH7DW+fcxamg0wlzkT5fawio83htOkPXhC6GJguZqp4qnKLNmfco9UTrm3If6uzjUAK+gK7F++qfL/vggV97A3eTK/1yygK6taOdSRYuQpeHq1VJ2erND8VL1AhgicxF3EY2BPOaf9MJUnUWcke+Co+ItSSlbOPa1N6VVWg4tgf2/7LKiXivZBsXRWKlSO9ZXI0g7t0j76fkQVOqUq1ZA7oDua0L1xa0yMB+PxQ2pktGebvgzj6R2Dm5vY</latexit>∂<latexit sha1_base64="5CkInOYvJuP/HzMLecd62IWaa6c=">AAAC9XicjVLLTsJAFL3UF+ILdemmkZi4Im1dyJLoxiUm8ohATFsGnNBX2qmGEP7CLa6MW7/HP9D4E54ZS6ISH9O0PXPuOXfmzh0n8ngiDOM5py0sLi2v5FcLa+sbm1vF7Z1GEqaxy+pu6IVxy7ET5vGA1QUXHmtFMbN9x2NNZ3gq480bFic8DC7EKGJd3x4EvM9dW4C67PR4MBibFWtyVSwZZUMNfR6YGShRNmph8Y061KOQXErJJ0YBCWCPbErwtMkkgyJwXRqDi4G4ijOaUAHeFCoGhQ12iO8As3bGBpjLnIlyu1jFwxvDqdMBPCF0MbBcTVfxVGWW7E+5xyqn3NsIfyfL5YMVdA32L99M+X9fhIr72Js8md9rFtBVVK0c6kgx8hTcbLVUnZ6sUP9UvUCGCJzEPcRjYFc5Z/3QlSdRZyR7YKv4i1JKVs7dTJvSq6wGF8H83vZ50LDK5lHZOrdK1ZPsSuRpj/bpEH0/piqdUY3qyB3QHU3pXrvVptqD9vgh1XKZZ5e+DO3pHXwAm9U=</latexit>∑<latexit sha1_base64="Eo/9914/gxxK4jyBkHl/Vv7w0yE=">AAAC9XicjVLLTsJAFL3UF+ILdemmkZi4Ii0uZEl04xITeUQgpi0DTihtM51qCOEv3OLKuPV7/AONP+GZsSQq8TFN2zPnnnNn7txxI5/H0rKeM8bC4tLySnY1t7a+sbmV396px2EiPFbzQj8UTdeJmc8DVpNc+qwZCeYMXZ813MGpijdumIh5GFzIUcQ6Q6cf8B73HAnqst3lQX9sl48mV/mCVbT0MOeBnYICpaMa5t+oTV0KyaOEhsQoIAnsk0MxnhbZZFEErkNjcAKI6zijCeXgTaBiUDhgB/j2MWulbIC5yhlrt4dVfLwCTpMO4AmhE8BqNVPHE51ZsT/lHuucam8j/N001xCspGuwf/lmyv/7IlTcw97Uyfxes4SurGvlUEeaUafgpasl+vRUhean6iUyROAU7iIugD3tnPXD1J5Yn5HqgaPjL1qpWDX3Um1Cr6oaXAT7e9vnQb1UtI+KpfNSoXKSXoks7dE+HaLvx1ShM6pSDbkDuqMp3Ru3xtR4MB4/pEYm9ezSl2E8vQN+iZvW</latexit>∫<latexit sha1_base64="2N0+0Q8rW6mmPv2wJMQELFDZD94=">AAAC9XicjVLLSsNAFL2Nr1pfVZdugkVwVZIK2mXRjcsK9oFtkSSd1sE0CclEKaV/4bauxK3f4x8o/oRnximoxceEJGfOPefO3LnjRj5PhGU9Z4y5+YXFpexybmV1bX0jv7lVT8I09ljNC/0wbrpOwnwesJrgwmfNKGbOwPVZw70+kfHGDYsTHgbnYhixzsDpB7zHPUeAumh3edAf2eXD8WW+YBUtNcxZYGtQID2qYf6N2tSlkDxKaUCMAhLAPjmU4GmRTRZF4Do0AhcDcRVnNKYcvClUDAoH7DW+fcxamg0wlzkT5fawio83htOkPXhC6GJguZqp4qnKLNmfco9UTrm3If6uzjUAK+gK7F++qfL/vggV97A3eTK/1yygK6taOdSRYuQpeHq1VJ2erND8VL1AhgicxF3EY2BPOaf9MJUnUWcke+Co+ItSSlbOPa1N6VVWg4tgf2/7LKiXivZBsXRWKlSO9ZXI0g7t0j76fkQVOqUq1ZA7oDua0L1xa0yMB+PxQ2pktGebvgzj6R2GJJvZ</latexit>The selected nodes create and distribute their block of pending
transactions through the gossip protocol, along with their
priority and proof. To reduce unnecessary communications,
and because only one of the proposed blocks will be appended
to the chain, each node prioritizes blocks based on the priority
of the block proposer. Nodes wait a certain amount of time to
receive priority messages and blocks (respectively 10 seconds
and 1 minutes as empirically determined by the authors [3]). If
a node does not receive a block within this delay, it proceeds
to the protocol step considering an empty block.

In each round, block proposers add to their blocks a seed
proposal required for the sortition process in the next round.
The proposal seed is determined as the veriﬁable random hash
value of the last round seed concatenated with current round
index r, i.e., (cid:104)seedr, π(cid:105) ← V RFsk(seedr−1||r).

Consensus: Algorand relies on a Byzantine agreement
procedure BA(cid:63) to reach consensus on a single block. This
procedure is composed of two phases during which each
committee member contributes by casting a vote on block hash
value, and every node in the system counts vote results.

The ﬁrst phase is a reduction, which transforms the problem
of agreeing on one block among many to agreeing on either
an empty block hash or a proposed block hash. The reduc-
tion phase consists of precisely two steps and requires the
contribution of 2 committees. Members of the ﬁrst committee
vote for the block hash with the highest priority they have
received. If a block hash receives a majority of votes in the
ﬁrst step, then members of the second committee will vote for
this block hash; otherwise, they vote for the hash of a default
empty block. The reduction phase ensures that at most one
non-empty blocks will be selected to be sent to BinaryBA(cid:63).

The second phase consists in executing a binary Byzantine
agreement procedure BinaryBA(cid:63) on the hash value passed on
to BinaryBA(cid:63) by the reduction phase and an empty block hash
value. This phase takes a variable (but bounded) number of
steps to complete depending on the network synchrony and
the honesty of the highest-priority proposer. Nodes continue
to count votes as in the reduction phase, and the committee
members of each step cast votes on block hashes. In each
step of BinaryBA(cid:63), when a node receives more than T × τ
votes for some value, it votes for that same value in the next
step. If a block hash receives a super majority of votes, a ﬁnal
consensus is reached and nodes can move on the next round.
On the other hand, if no hash value receives a super majority,
2) Algorand++ protocol: We now apply ALDER’s princi-
ples on Algorand to create Algorand++ in which multiple lead-
ers can independently propose concurrent blocks containing
disjoint sets of transactions, and grow the chain by appending
a subset of the proposed blocks in every round. Figure 4
depicts in green color the global course of a Algorand++
round. First (step (cid:182)), each node executes the cryptographic
sortition to determine whether it is elected as a leader to
contribute to the block proposal step as well as the other
steps of BA(cid:63). When elected, each leader also learns which
bucket of transactions it should use to build a block from.
Doing so, the leaders can submit propose messages and blocks

containing disjoint sets of transactions (step (cid:183)) along with a
reference to the previous macroblock. In the reduction step
is multiplexed so that committee members will reduce the
problem of agreeing on a set of blocks to agreeing either on
a vector of disjoint block hashes or on the hash of an empty
block (step (cid:184)) in precisely two steps. Finally, the multiplexed
binary Byzantine agreement (step (cid:185)) reaches consensus one of
the inputs provided by the reduction phase. Once consensus is
reached (step (cid:186)), nodes gather the blocks Algorand++ has
agreed on and build the macroblock corresponding to the
consensus decision before appending it to the chain.

Bucket assignment and multiple leader election: Electing
multiple leaders is already part of the original protocol.
Assigning buckets in an unforgeable and publicly veriﬁable
way is performed by leveraging the original cryptographic
sortition mechanism. More speciﬁcally, the assigned bucket
index is computed from the VRF’s hash value produced during
the cryptographic sortition procedure modulo the concurrency
level Cl. Because Algorand++ decides on a vector of blocks
the number of block proposers,
and not one block only,
i.e., leaders, τproposer should be sufﬁciently large to avoid
unassigned buckets. A too low τproposer value could lead to
buckets being frequently unassigned which would not only
hinder the envisioned throughput gain, but would also lead
to transactions with speciﬁc hash being unfairly ignored for
some period. To devise an appropriate value for τproposer, we
rely on the uniform distribution of bucket assignment deriving
from the use of hash functions in the cryptographic sortition. In
other words, each node has an equal chance of being assigned
one bucket over another; a bucket is assigned to at least one
proposer with the following probability 1 − (1 − 1
Cl )τproposer ;
and all buckets are assigned to at least one proposer with
probability (cid:80)Cl

(cid:1)τproposer .

i=0(−1)Cl−i(cid:0)Cl

(cid:1)(cid:0) i
Cl

Disjoint block proposal: The block proposal step of Al-
gorand++ is very similar to that of Algorand, except that
nodes can be assigned the same transaction bucket as other
nodes. Because only one proposed block per bucket index will
be appended to the chain, Algorand++ extends the original
protocol to reduce unnecessary communications. Similarly to
Algorand, each block proposer sends two kinds of messages
to help other nodes decide on which block can be safely
discarded for each speciﬁc bucket. The ﬁrst message is the
proof of selection and a priority hash value used, this time,
to compare the proposed blocks composed of transactions
originating from the same bucket index. The priority hash is
derived from hashing the VRF hash output concatenated with
a publicly veriﬁable information of the node’s stake in the
system, and the assigned bucket index. The second message
is the block itself.

i

The seed generation mechanism is also different. Indeed,
in Algorand, block proposers add to their blocks a seed
proposal required for the sortition process in the next round.
This proposed seed is determined as the veriﬁable random
hash value of the last round seed concatenated with current
round index r, i.e., (cid:104)seedr, π(cid:105) ← V RFsk(seedr−1||r). In
Algorand++, each elected node proposes a partial seed by

5

committees. CR agrees on a reference block consisting of the
list of all active nodes for that epoch as well as their assigned
committees, and appends the latter block to each shard. To
do so, CR runs a distributed random generation protocol to
produce an unbiased random value called epoch randomness.
Once generated, the epoch randomness is used to deﬁne a
cryptographic puzzle challenge that each node wishing to join
or stay in the system should solve within 10 minutes. CR
validates the received cryptographic puzzle solutions, assigns
each member to a sharding committee, and informs other
committees by publishing a conﬁguration blocks.

Inter-committee routing and cross-shard veriﬁcation: Com-
mittee members wait for external users to submit their trans-
actions. To split transactions onto the different shards, Rapid-
chain deterministically assigns each transaction to a committee
by hashing the transaction identiﬁer to a committee number.
Nodes receiving transactions forward them to their destination
committee using a routing protocol inspired by Kademlia [32].
Committee members batch several transactions into a block
and run an intra-committee consensus in order to append
it
the
to their shard. Before the block can be appended,
committee veriﬁes the validity of every new transaction in
the block by verifying that the associated input transactions
actually record enough previously-unspent currency. Since
transactions are stored into disjoint shards held by different
committees, committee members need to communicate with
the corresponding input committees to ensure that the input
transactions exist in their shards.

Leader election: For each round and each committee,
Rapidchain deterministically elect a single leader from the
committee members by using the epoch randomness and round
number. The leader is responsible for driving the consensus
protocol. Before that, it gathers the transactions it has received
in a block and gossips it using the IDA gossip protocol.

Intra-committee consensus: In order to append one block
per shard, Rapidchain proposes an intra-committee consensus
protocol based on the synchronous protocol of Ren et al. [33],
which is resilient to f = 1/2 of the committee size. The
leader initiates the consensus on the header of the block it has
gossiped. The protocol executes the following four steps in
which all communications are signed by the sender’s private
key to provide authentication and integrity of messages. (1)
The leader submits a propose message containing the block
header, (2) all nodes receiving the propose message send an
echo message containing the same block header to the entire
committee. (3) If an honest node sees another version of the
block header in one of the echo messages it received, then
it knows that the leader is corrupt, and it gossips a pending
message containing an empty block hash. 4) Finally, if an
honest node receives mf + 1 echo messages of the same
and only block header, it decides on this block header and
submits an accept message including the mf + 1 received
echo messages.

2) Rapidchain++ protocol: We apply ALDER’s princi-
ple for the consensus protocol executed by each committee.
Figure 5 depicts the course of a Rapidchain++ round: First,

Fig. 5: Rapidchain and Rapidchain++ round structures. Black
texts, arrows and boxes depict the round structure of Rapid-
chain while green elements illustrate Rapidchain++

executing the VRF function on the concatenation of the
seeds from all blocks in the previous macroblocks. That is
(cid:104)seedr, π(cid:105) ← V F Rsk(seedr−1,1||...||seedr−1,Cl||r). Doing
so, the next round seed is only revealed when the consensus
BA(cid:63) decides on the composition of the next macroblock. Then,
the actual seed used to run crytographic sortition is the hash of
the seeds from all the blocks composing the last macroblock.
Multiplexed consensus and macroblocks: The multiplexed
BA(cid:63) agreement protocol takes as input a list of block hashes
and produces a vector of block hashes that compose the
macroblock to be appended at the end of a round. As the
ﬁnal decision could be a vector containing hashes of empty
blocks, Algorand++ grows a chain of macroblocks of possibly
different sizes. Based on this decision, each node locally builds
the agreed-upon macroblock by concatenating the associated
blocks. Block proposers in the next round will compute the
hash of this macroblock to continue the chain.

B. Rapidchain++: Applying ALDER to Rapidchain

Rapidchain is among the most efﬁcient sharded permis-
sionless blockchain protocol. Rapidchain splits the system in
k non-intersecting committees of m nodes. Each committee
is in charge of maintaining and growing a speciﬁc shard
of the blockchain. Rapidchain employs an optimal
intra-
committee synchronous consensus algorithm to achieve very
high throughput via a novel gossiping protocol for large
blocks, and a provably-secure reconﬁguration mechanism to
ensure robustness. Using an efﬁcient cross-shard transaction
veriﬁcation technique, Rapidchain avoids gossiping transac-
tions to the entire network.

1) Rapidchain protocol: Rapidchain proceeds with suc-
cessive day-long epochs consisting of multiple rounds of
consensus. At the end of each epoch, a reconﬁguration phase
is executed. Figure 5 depicts the course of a round. First a
leader is elected in each committee in a deterministic manner,
then the leader builds a block and gossip it to the committee
with a speciﬁc gossip protocol inspired from IDA. Finally, the
committee reaches consensus on the proposed block via an
intra-committee synchronous algorithm.

Reconﬁguration and epoch-based committees: At the end of
every epoch, a reconﬁguration phase driven by a speciﬁc refer-
ence committee CR allows nodes to join or stay in the existing

6

Multiple leader electionDisjointblock proposalIDA Block disseminationMultiplexedsynchronous consensusRound r-1Intra-committee consensus protocol for shard #1Round r+1Intra-committee consensus protocol for shard #2Intra-committee consensus protocol for shard #K...Rapidchain++ uses the deterministic leader election protocol
of Rapidchain to elect Cl leaders. Then, each leader builds
and gossips concurrent blocks containing disjoint sets of trans-
actions. Finally, the intra-committee synchronous consensus
protocol is executed to decide on a vector of block headers.
Bucket assignment and disjoint block proposal: Elected
leaders are assigned buckets deterministically in the order
of election: the ﬁrst leader is assigned to bucket 0, the last
leader is assigned to bucket Cl − 1. An elected leader uses
the assigned transaction bucket to build and gossip a block
with the IDA gossip protocol. Because leader election results
and bucket assignment are publicly veriﬁable, any node can
verify the correctness of the proposed blocks. The leader
submits the block message, and starts synchronous consensus
by submitting a propose message. A propose message contains
a single block header.

Multiplexed intra-committee consensus: Rapidchain++ ex-
tends the synchronous consensus algorithm of Rapidchain in
order to decide on a vector of block headers. Speciﬁcally, echo
and accept votes contains the latter vector. Each committee
member awaits up to Cl propose votes until the end of the
synchronous round timeout, and then submits echo votes that
contain for the received block headers. If it receives more
than one version of a block header from a speciﬁc leader and
bucket, it submits a pending message which contains an empty
block header. When receiving mf + 1 echo votes for the same
vector of block headers, a committee member sends an accept
message for this vector.

C. Bitcoin with ALDER: Bitcoin++

In this section, we present Bitcoin and Bitcoin++ protocols.
The latter is the improved version of the Bitcoin protocol with
ALDER.

1) Bitcoin protocol: Bitcoin is a Proof of Work (PoW)
based blockchain system that relies on hash puzzles (crypto-
graphic puzzles) to elect leaders. The global course of a round
in Bitcoin includes the following steps: (1) each node builds a
block of transactions containing in its header the hash of the
previously appended block and a nonce value of its choice.
(2) Then each node tries to ﬁnd a nonce value that satisﬁes
the following cryptographic puzzle. The hash value resulting
from the evaluation of a cryptographic hash function over the
block header should be lower than a threshold, also known
as difﬁculty. The difﬁculty is adjusted by the system so that
a single solution to the cryptographic puzzle is found every
10 minutes on average. (3) when a node ﬁnds a solution to
the cryptographic puzzle, it is considered a leader in bitcoin
and sends the block it has built via a gossip protocol to its
neighbors. (4) Upon receiving a block, each node veriﬁes
the validity of the solution and appends the block to its
blockchain. (5) If two different solutions are found for the
same cryptographic puzzle, there exists two valid candidate
blocks competing to extend the blockchain. In this case, nodes
continue trying to solve the next puzzle considering the ﬁrst
block they have received, potentially extending the chain on
two different paths, usually referred to as forks. Bitcoin’s

consensus rely on the longest chain rule to resolve forks by
considering the highest amount of the work done the nodes
in solving the puzzles and appending blocks to the chain.
In Bitcoin, nodes submit blocks of 1 MB. The small block
size and predetermined long block intervals (on average 10
minutes) deﬁned by the cryptographic puzzle difﬁculty are
the main bottlenecks that limit the throughput of the Bitcoin
system.

2) Bitcoin++ protocol: Bitcoin++ allows multiple nodes to
independently propose concurrent blocks containing disjoint
sets of transactions and grow the chain by appending a subset
of the proposed blocks in every round.

Macroblocks: Contrarily to the previous blockchains, mac-
roblocks in Bitcoin++ are composed of exactly Cl blocks.
Indeed, as the consensus termination of Bitcoin is probabilist,
and nodes cannot be sure that a given block is ﬁnal and will
never be removed from the blockchain. For this reason, nodes
in Bitcoin++ only consider that a round in terminated when
they can build a macroblock fully with Cl blocks.

Multiple leader election: Similar to its parent, Bitcoin++
relies on cryptographic puzzles to elect multiple leaders. To
elect multiple leaders within the same time interval (10 min-
utes) on average, ALDER requires to decrease the difﬁculty of
the cryptographic puzzle. More precisely, to obtain Cl leaders
at the same time interval as Bitcoin, the difﬁculty must be
divided by Cl.

Bucket assignment and disjoint block proposal: Bitcoin++
assigns transaction buckets nodes at the time they solve a
cryptographic puzzle for a macroblock. Speciﬁcally, each node
builds a macroblock of Cl blocks. The macroblock includes
a nonce value, the hash of the previous macroblock, and a
commitment scheme (a Merkle Tree) to commit each block
to the built macroblock. Then, the node tries to ﬁnd a nonce
value that satisﬁes the following cryptographic puzzle. The
hash value resulting from the evaluation of a cryptographic
hash function over the macroblock header should be lower than
a target difﬁculty. When a solution is found, the node learns
the bucket index it was assigned by computing the modulo
operation of the hash value against the concurrency level Cl.
It then gossips the block corresponding to designated bucket
along with the macroblock header used in the cryptographic
puzzle as a proof.

Adressing competing blocks Because Cl leaders are ex-
pected every 10 minutes on average and, because the bucket
assignment process may assign one bucket to more than one
leader, then the time required to obtain Cl blocks for each
bucket could be greater than 10 minutes. This could inhibit the
performance gain envisioned by ALDER. Bitcoin++ addresses
this issue by introducing a sibling mechanism that enables to
collect blocks competing for the same bucket index.

When building its block, each node adds a siblings ﬁeld
to each block header. This ﬁeld is a Cl-long byte array that
contains the hashes of blocks proposed by other nodes in the
same round. When the node receives a block for the same
bucket index of the block it produces (or of the block it
received), it looks at the siblings ﬁeld of each block. The node

7

then deterministically use the next empty slot in the siblings
ﬁeld to link the received block to the others it has.

Multiplexed longest chain consensus rule The siblings ﬁeld
decreases the probability of loosing the contribution of two
blocks competing for the same bucket index. However, it does
not eliminate it completely because the latter mechanism could
increase the likelihood of fork occurence. Indeed, different
nodes might accept different blocks for the same bucket index
in a round. To handle this case, Bitcoin++ extends the longest
chain consensus rule with a priority consensus rule. When
receiving several blocks for the same bucket index, blocks are
prioritized by their hash values (smallest wins) to help the
node decide which one to consider.

VI. EVALUATION

In this section, we evaluate the extent of ALDER’s ability
to improve performances of the three blockchains we con-
sidered. We ﬁrst present our implementation and evaluation
environment (Section VI-A) before presenting the performance
of Algorand++, Rapidchain++ and Bitcoin++ in sections VI-B,
VI-C and VI-D, respectively.

A. Implementation and evaluation environment

We implemented all baseline protocols and their multiplexed
versions using Golang. The experiments presented in this
section were carried out using the Grid’5000 [34] testbed. We
used powerful physical machines, each with 18 cores, 96 GB
of memory, and a 25 Gbps intra network connectivity link.
In all experiments, we emulate wide-area network conditions
as in major blockchain propositions [3], [12]: we cap the
bandwidth for each process to 20 Mbps, and we add a one-
way latency of 50 milliseconds (Round-Trip Time is 100 ms)
to each communication link using trafﬁc control rules2 and
control groups of the Linux operating system3.

Fanout is the number of nodes that are selected as gossip
targets by a node at each gossip step in order to retransmit the
message [35]. The fanout parameter of gossip communication
protocol is set to 8 for Algorand and Bitcoin implementations,
and 16 for RapidChain because of IDA gossip. In addition, we
relied on a custom registry service to bootstrap the system:
at startup, a node registers itself to the registry service and
receives a list of available nodes from the service. In all ex-
periments, we did not disseminate transactions in the network.
Instead, we assumed that nodes have access to pre-initialized
transaction pool to populate block payloads.

B. Algorand++ Performance Evaluation

We conducted two sets of experiments to evaluate the
performance improvements of Algorand++ compared to Algo-
rand. In the ﬁrst set of experiments described in Section VI-B1,
we compare the performance of both protocols using 1,000
nodes. In the second set of experiments described in Sec-
tion VI-B2, we deployed up to 10,000 nodes to compare the
scalability characteristics of both protocols.

2https://man7.org/linux/man-pages/man8/tc.8.html
3https://man7.org/linux/man-pages/man7/cgroups.7.html

Fig. 6: Round latency of Algorand++ with various concurrency
levels (Cl). Cl=1 is Algorand.

Fig. 7: Effective throughput of Algorand++ with various
concurrency levels (Cl). Cl=1 is Algorand.

1) Algorand++ Latency and Throughput: To evaluate the
normal case performance of Algorand and Algorand++, we
deployed 1,000 nodes on ten machines (100 nodes per ma-
chine), and we varied the macroblock size from 1 MB to
24 MB and the concurrency level of Algorand++ from 1 to 32.
For each experiment, elected leaders build blocks of size the
expected macroblock size divided by Cl. The experiments with
the concurrency level 1 (Cl = 1) exhibit Algorand’s behavior.
We start by evaluating the round latency of the two pro-
tocols, which indicates how long it
takes for a block to
be appended to the chain. Round latency is measured as
time of a block by a
the duration between the proposal
leader and the time when all nodes observe this block in
the blockchain. Results depicted in Figure 6 show that the
round latency of Algorand increases rapidly as the size of the
appended blocks becomes larger. Furthermore, we observe that
the round latency of Algorand++ largely outperforms the one
of Algorand for macroblock sizes larger or equal to 2 MB. For
instance, for 4 MB blocks, Algorand++ improves the round
latency of Algorand from 33.9% with Cl=2 to 46.4% with
Cl=8. The gap between Algorand++ and Algorand becomes
even larger with larger block sizes. Indeed, we observe a round
latency improvement varying from 40.9% with Cl=2 to 76.7%
with Cl=32 in the conﬁguration with 24 MB blocks.

In addition to round latency, we evaluate the effective
throughput of Algorand++ compared to Algorand. Since some
macroblocks may contain fewer blocks than expected, we

8

020406080100120111111122222224444444888888812121212121212161616161616162020202020202024242424242424Macroblock Size (MB)Median Latency (Seconds)Cl12481620320100200300400500600700111111122222224444444888888812121212121212161616161616162020202020202024242424242424Macroblock Size (MB)Median Throughput (KB/Second)Cl1248162032Fig. 8: Effective throughput degradation

Fig. 10: Latency of Rapidchain++ with various concurrency
levels (Cl). Cl=1 is RapidChain.

Fig. 9: Round duration increase

cannot derive throughput directly from the round latency and
the macroblock size. We deﬁne effective throughput as the
actual amount of data per second appended to the blockchain.
Results of this experiment are depicted in Figure 7. As
shown in this ﬁgure, Algorand++ outperforms Algorand in all
conﬁgurations and can reach up to 743 KB/s. That is four-fold
improvement using 24 MB blocks, and Cl=20.

Our results also highlight the limits of multiplexing Algo-
rand instances. Indeed, we reach the maximum throughput
with Cl = 20, and increasing the concurrency level does not
improve performance any further.

2) Algorand++ evaluation at scale: To evaluate how Algo-
rand++ and Algorand scale, we vary the number of machines
in the testbed from 10 to 100 with 100 nodes per machine,
allowing us to emulate up to 10,000 nodes. In Algorand ex-
periments, we use 1 MB blocks. In Algorand++ experiments,
we use 20 MB blocks and Cl = 20. We then measure
the throughput degradation and round latency increase as a
function of the number of nodes in the system compared to
the baseline with 1,000 nodes. Regarding throughput, results
depicted in Figure 8 show that similarly to Algorand, Algo-
rand++ suffers a throughput degradation when the number of
nodes increases in the system. Nevertheless, the mechanisms
brought by ALDER to Algorand do not degrade its scalability.
It rather improves it when the number of nodes increases as
illustrated by the conﬁguration with 10,000 nodes where a 6%
lower degradation difference can be observed for Algorand++
compared to Algorand.

Results related to the latency increase with respect to the

Fig. 11: Throughput of Rapidchain++ with various concur-
rency levels (Cl). Cl=1 is RapidChain.

number of nodes in the system are depicted in Figure 9. From
this ﬁgure, we observe that the gap in terms of round duration
increases between Algorand and Algorand++ with the number
of nodes. This illustrates the fact that Algorand++ exhibits
better scalability than Algorand.

C. Rapidchain++ Performance Evaluation

We conducted a set of experiments to evaluate the per-
formance of Rapidchain++ compared to Rapidchain in terms
of round latency (Section VI-C1) and effective throughput
(Section VI-C2). Because the throughput of Rapidchain is the
sum of throughput of each shard, we have considered a single
shard deployment scenario. In the original paper, Rapidchain
considers a committee size of up to 250 nodes. We applied
this conﬁguration and deployed 250 nodes on 10 machines.

In our experiments, we vary the macroblock size from 2 to
16 MB, and for each macroblock size, we vary the concurrency
level Cl from 1 to 16. Similar to Algorand, elected leaders
build blocks of size the expected macroblock size divided
by Cl. Each experiment lasted 20 rounds, and we measured
the median throughput and latency values as observed by
individual nodes.

1) Rapidchain++ round latency: Figure 10 shows the
measured round latency for Rapidchain++ with various con-
currency levels. In the ﬁgure, Cl = 1 corresponds to the
latency measurements of the original protocol. From this ﬁgure
we observe that for all macroblock sizes, the round latency

9

0%20%40%1000200030004000500060007000800090001000010002000300040005000600070008000900010000Number of NodesThroughput Degradation (%)ALGORANDALGORAND++0%20%40%60%80%100%1000200030004000500060007000800090001000010002000300040005000600070008000900010000Number of NodesRound Duration Increase (%)ALGORANDALGORAND++02040602222244444888881616161616Macroblock Size (MB)Median Round Latency (Seconds)Cl12481601002003002222244444888881616161616Macroblock Size (MB)Median Throughput (KB/Second)Cl124816provided by Rapidchain++ is 10% lower than the provided
round latency of Rapidchain. All Rapidchain++ instances
provide similar latency values.

2) Rapidchain++ effective throughput: Figure 11 shows
the throughput measurements for Rapidchain++ compared to
Rapidchain as a function of the macroblock size. From this
ﬁgure, we observe that the highest obtained throughput with
Rapidchain is 262 KB/s with the 16-MB block size. Instead,
Rapidchain++’s highest throughput is 292 KB/s obtained with
macroblock size of 16 MB and with a concurrency level Cl =
4. For all block sizes, Rapidchain++ provides a throughput
increase of approximately 10% compared with Rapidchain.

In our experiments, we can observe that Rapidchain++
provides latency and throughput results 10% better compared
to the ones of Rapidchain.

D. Bitcoin++ Performance Evaluation

Bitcoin++ reduces the difﬁculty of cryptographic puzzles
inversely proportional to Cl value to elect Cl leaders on aver-
age every 10 minutes. We conducted experiments to evaluate
the performance of Bitcoin++ compared to the ones of Bitcoin
with similar cryptographic puzzle difﬁculty. In our experiments
we vary the concurrency level of Bitcoin++ from 2 to 96.
For each concurrency level Cl, the associated cryptographic
puzzle difﬁculty is set for both Bitcoin and Bitcoin++ so as to
obtain Cl leaders every 10 minutes on average. We considered
macroblocks of size 1 MB and 500 KB. Contrarily to the
approaches in Rapidchain++ and Algorand++, we considered
smaller macroblock sizes. Indeed, keeping high macroblock
size would impact the protocol performance because of the
time it takes to gossip blocks to the entire system in compar-
ison with the frequency at which nodes ﬁnd solution to the
cryptographic puzzles. For this reason, we maintain relatively
small macroblock size (1 MB and 500 KB). The size of each
block is, as in the Rapidchain++ and Algorand++, computed
as the expected macroblock size divided by the concurrency
level Cl.

1) Bitcoin++ effective throughput: Figure 12 shows median
throughput ﬁgures for both protocols. The conﬁguration with
1-MB block size and Cl = 1 that actually represent the
original Bitcoin protocol (not represented in the plots) provides
a throughput of 1.67KB/s with a latency of 600 seconds). In
all experiments, Bitcoin++ provides superior throughput com-
pared to Bitcoin with reduced difﬁculty. For the 1-MB block
size experiments with Cl = 32, Bitcoin++ provides 47.3 KB/s,
a %65 throughput improvement compared to the associated
reduced difﬁculty Bitcoin with its 28.7 KB/s. Using 1 MB
blocks, we could not increase the Cl value further because of
the block dissemination time. Regarding the experiments with
the 500-KB block size, we observe similar trends. Bitcoin++
can provide up 70.8 KB/s with Cl = 96, a two-fold throughput
increase compared with Bitcoin and its 35.3 KB/s.

Although decreasing the cryptographic puzzle difﬁculty
seems to help Bitcoin and Bitcoin++ to increase their through-
put, it also impacts the number forks, as well as the number
of blocks appended to the chain that are then removed when

Fig. 12: Throughput of Bitcoin Reduced Difﬁculty and Bit-
coin++. Higher Cl means lower difﬁculty.

Fig. 13: Latency of Bitcoin Reduced Difﬁculty and Bitcoin++.
Higher Cl means lower difﬁculty.

forks are detected. To measure such impact, we observe
the ratio between the data produced by the leaders and the
data actually appended to the blockchain at the end of the
experiment. This measure helps understand the extent of fork
occurences in each protocol, which also represents the payload
of transactions appended to the chain and later discarded by
the nodes. Our results show that regardless of the concurrency
level of Bitcoin++, Bitcoin++ produces approximately 20%
more data than what it actually appends to the chain. As
for the Bitcoin case, when the cryptographic puzzle difﬁculty
decreases, the latter ratio increases up to 120%, meaning that
Bitcoin produces 1.2 additional blocks of transactions for each
block it appends to the chain.

2) Bitcoin++ round latency: Figure 13 shows the median
round completion times for Bitcoin++ compared to Bitcoin.
Because of the choice we made to evaluate the performance
of the Bitcoin++ protocol compared to Bitcoin with reduced
difﬁculty, it is natural that round completion time of Bitcoin
with reduced difﬁculty is lower. On the contrary, Bitcoin++
appends a single macroblock every 10 minutes, which corre-
sponds to 600 seconds round completion time.

In all experiments, Bitcoin++ provides superior throughput
compared to Bitcoin with reduced difﬁculty. Additionally,
Bitcoin++ discards signiﬁcantly fewer data and reduces the
occurence of forks in comparison with Bitcoin.

10

020406024816326496ClMedian Throughput (KB/Second)Bitcoin 1MBBitcoin 500KBBitcoin++ 1MBBitcoin++ 500KB020040060024816326496ClRound Completion Time (Seconds)Bitcoin 1MBBitcoin 500KBBitcoin++ 1MBBitcoin++ 500KB[18] M. Zamani et al., “Rapidchain: Scaling blockchain via full sharding,”
in Proceedings of the 2018 ACM SIGSAC Conference on Computer and
Communications Security, 2018, pp. 931–948.

[19] J. Wang and H. Wang, “Monoxide: Scale out blockchains with asyn-
chronous consensus zones,” in 16th {USENIX} Symposium on Net-
worked Systems Design and Implementation ({NSDI} 19), 2019, pp.
95–112.

[20] L. Luu et al., “A Secure Sharding Protocol For Open Blockchains,”
in Proceedings of the 2016 ACM SIGSAC Conference on Computer
and Communications Security, ser. CCS ’16. New York, NY, USA:
Association for Computing Machinery, Oct. 2016, pp. 17–30.

[21] E. Kokoris-Kogias et al., “Omniledger: A secure, scale-out, decentral-
ized ledger via sharding,” in 2018 IEEE Symposium on Security and
Privacy (SP).

IEEE, 2018, pp. 583–598.

[22] L. Lamport et al., “Paxos made simple,” ACM Sigact News, vol. 32,

no. 4, pp. 18–25, 2001.

[23] C.-S. Barcelona, “Mencius: building efﬁcient replicated state machines
for wans,” in 8th USENIX Symposium on Operating Systems Design and
Implementation (OSDI 08), 2008.

[24] Z. Milosevic, M. Biely, and A. Schiper, “Bounded delay in byzantine-
tolerant state machine replication,” in 2013 IEEE 32nd International
Symposium on Reliable Distributed Systems.
IEEE, 2013, pp. 61–70.
[25] M. Castro, B. Liskov et al., “Practical byzantine fault tolerance,” in

OSDI, vol. 99, no. 1999, 1999, pp. 173–186.

[26] C. Stathakopoulou, T. David, and M. Vukolic, “Mir-bft: High-throughput

bft for blockchains,” arXiv preprint arXiv:1906.05552, 2019.

[27] H. Yu, I. Nikoli´c, R. Hou, and P. Saxena, “Ohie: Blockchain scaling
made simple,” in 2020 IEEE Symposium on Security and Privacy (SP).
IEEE, 2020, pp. 90–105.

[28] T. Crain, C. Natoli, and V. Gramoli, “Red belly: a secure, fair and
scalable open blockchain,” in Proceedings of the 42nd IEEE Symposium
on Security and Privacy (S&P’21), 2021.

[29] K. Antoniadis, A. Desjardins, V. Gramoli, R. Guerraoui, and M. I.
Zablotchi, “Leaderless consensus,” in IEEE 41st International Confer-
ence on Distributed Computing Systems(ICDCS), 2021.

[30] T. Rocket, M. Yin, K. Sekniqi, R. van Renesse, and E. G. Sirer, “Scalable
and probabilistic leaderless bft consensus through metastability,” arXiv
preprint arXiv:1906.08936, 2019.

[31] S. Micali, M. Rabin, and S. Vadhan, “Veriﬁable random functions,”
in 40th Annual Symposium on Foundations of Computer Science (Cat.
No.99CB37039), Oct. 1999, pp. 120–130.

[32] P. Maymounkov and D. Mazieres, “Kademlia: A peer-to-peer informa-
tion system based on the xor metric,” in International Workshop on
Peer-to-Peer Systems. Springer, 2002, pp. 53–65.

[33] L. Ren, K. Nayak, I. Abraham, and S. Devadas, “Practical synchronous

byzantine consensus,” arXiv preprint arXiv:1704.02397, 2017.

[34] R. Bolze et al., “Grid’5000: a large scale and highly reconﬁgurable ex-
perimental grid testbed,” The International Journal of High Performance
Computing Applications, vol. 20, no. 4, pp. 481–494, 2006.

[35] J. Leitao, J. Pereira, and L. Rodrigues, “Gossip-based broadcast,” in
Handbook of Peer-to-Peer Networking. Springer, 2010, pp. 831–860.

VII. CONCLUSION

We presented ALDER, a set of reusable principles to mul-
tiplex leader-based blockchain consensus protocols in order
to improve their performance. To assess the improvements
brought by ALDER on existing blockchain protocols, we
applied its principles on three major blockchains: Algorand,
Rapidchain and Bitcoin. We presented how ALDER’s princi-
ples apply to these blockchains and evaluated the performance
of the resulting blokchains. Our evaluation, involving up to
10,000 nodes deployed on 100 physical machines, shows that
using ALDER can provide up to a 300% improvement in both
throughput and latency reduction.

REFERENCES

[1] S. Nakamoto, “Bitcoin: A Peer-to-Peer Electronic Cash System,” p. 9,

2008.

[2] E. Androulaki et al., “Hyperledger fabric: A distributed operating system
for permissioned blockchains,” in Proceedings of the Thirteenth EuroSys
Conference on - EuroSys ’18. Porto, Portugal: ACM Press, 2018, pp.
1–15.

[3] Y. Gilad, R. Hemo, G. Vlachos, and N. Zeldovich, “Algorand: Scaling
Byzantine Agreements for Cryptocurrencies,” in Proceedings of the 26th
Symposium on Operating Systems Principles - SOSP ’17.
Shanghai,
China: ACM Press, 2017, pp. 51–68.

[4] “Hyperledger – Open Source Blockchain Technologies.” [Online].

Available: https://www.hyperledger.org/

[5] R. B. Uriarte and R. DeNicola, “Blockchain-Based Decentralized
Cloud/Fog Solutions: Challenges, Opportunities, and Standards,” IEEE
Communications Standards Magazine, vol. 2, no. 3, pp. 22–28, Sep.
2018.

[6] S. Raval, Decentralized applications: harnessing Bitcoin’s blockchain

technology.

" O’Reilly Media, Inc.", 2016.

[7] R. Belchior, A. Vasconcelos, S. Guerreiro, and M. Correia, “A survey
on blockchain interoperability: Past, present, and future trends,” vol. 54,
no. 8, 2021. [Online]. Available: https://doi.org/10.1145/3471140
[8] R. Guerraoui et al., “The consensus number of a cryptocurrency,” in
Proceedings of the 2019 ACM Symposium on Principles of Distributed
Computing, 2019, pp. 307–316.

[9] G. Wood et al., “Ethereum: A secure decentralised generalised trans-
action ledger,” Ethereum project yellow paper, vol. 151, no. 2014, pp.
1–32, 2014.

[10] I. Eyal, A. E. Gencer, E. G. Sirer, and R. van Renesse, “Bitcoin-NG: A
Scalable Blockchain Protocol,” 13th USENIX Symposium on Networked
Systems Design and Implementation (NSDI ’16), p. 16, 2016.

[11] E. K. Kogias et al., “Enhancing bitcoin security and performance with
strong consistency via collective signing,” in 25th {usenix} security
symposium ({usenix} security 16), 2016, pp. 279–296.

[12] M. Zamani et al., “RapidChain: Scaling Blockchain via Full Sharding,”
in Proceedings of the 2018 ACM SIGSAC Conference on Computer and
Communications Security. Toronto Canada: ACM, Oct. 2018, pp. 931–
948.

[13] H. Yu, I. Nikoli´c, R. Hou, and P. Saxena, “OHIE: Blockchain Scaling
Made Simple,” in 2020 IEEE Symposium on Security and Privacy (SP),
May 2020, pp. 90–105.

[14] I. Abraham, D. Malkhi, K. Nayak, L. Ren, and A. Spiegelman, “Solida:
A blockchain protocol based on reconﬁgurable byzantine consensus,”
arXiv preprint arXiv:1612.02916, 2016.

[15] B. David et al., “Ouroboros Praos: An Adaptively-Secure, Semi-
synchronous Proof-of-Stake Blockchain,” in Advances in Cryptology
– EUROCRYPT 2018, ser. Lecture Notes in Computer Science, J. B.
Nielsen and V. Rijmen, Eds. Cham: Springer International Publishing,
2018, pp. 66–98.

[16] I. Eyal, A. E. Gencer, E. G. Sirer, and R. Van Renesse, “Bitcoin-
ng: A scalable blockchain protocol,” in 13th {USENIX} symposium on
networked systems design and implementation ({NSDI} 16), 2016, pp.
45–59.

[17] E. Syta et al., “Keeping authorities" honest or bust" with decentralized
witness cosigning,” in 2016 IEEE Symposium on Security and Privacy
(SP).

Ieee, 2016, pp. 526–545.

11

