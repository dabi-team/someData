Homomorphic Sortition ‚Äì
Secret Leader Election for Blockchain
Andrei Tonkikh
LTCI, T√©l√©com Paris, Institut
Polytechnique de Paris
France
tonkikh@telecom-paris.fr

Luciano Freitas
LTCI, T√©l√©com Paris, Institut
Polytechnique de Paris
France
lfreitas@telecom-paris.fr

Sara Tucci-Piergiovanni
CEA LIST, Universit√© Paris-Saclay
France
sara.tucci@cea.fr

2
2
0
2

n
u
J

3
2

]

R
C
.
s
c
[

1
v
9
1
5
1
1
.
6
0
2
2
:
v
i
X
r
a

Renaud Sirdey
CEA LIST, Universit√© Paris-Saclay
France
renaud.sirdey@cea.fr

Oana Stan
CEA LIST, Universit√© Paris-Saclay
France
oana.stan@cea.fr

Nicolas Quero
CEA LIST, Universit√© Paris-Saclay
France
nicolas.quero2@cea.fr

Adda-Akram Bendoukha
CEA LIST, Universit√© Paris-Saclay
France
adda-akram.bendoukha@cea.fr

Petr Kuznetsov
LTCI, T√©l√©com Paris, Institut
Polytechnique de Paris
France
petr.kuznetsov@telecom-paris.fr

ABSTRACT
In a secret single leader election protocol (SSLE), one of the system
members is chosen as a leader and no other member can know who
the leader is, unless she decides to reveal herself. Leader-election
oracles are known to be instrumental in designing efficient consen-
sus protocols, and one can expect that secret leader election may
help in developing long-lived blockchain systems that are secure
with respect to the adaptive adversary.

In this paper, we introduce secret leader sortition (SLS) that we
believe to perfectly match progress and security expectations of
proof-of-stake (PoS) blockchains. An SLS protocol produces an un-
predictable permutation of system members that can be fed to an
accompanying blockchain protocol in order to ensure deterministic
finality.

We describe Homomorphic Sortition, an SLS protocol based on
Threshold Fully Homomorphic Encryption (ThFHE). An interesting
novelty of our protocol is a cryptographic hash function evaluation
under ThFHE and, somewhat surprisingly, we show that all ThFHE
stimuli required for our protocol can be efficiently and proactively
constructed in a parallelizable fashion. In contrast to existing secret
leader election protocols, our SLS solution is purely asynchronous
and it fairly leverages the stake distribution among the system
members: the probability distribution for each position in the per-
mutation is proportional to the stakes of remaining candidates. As
we demonstrate, our SLS protocol seamlessly partners with a large
family of PoS blockchain implementations.

CCS CONCEPTS
‚Ä¢ Theory of computation ‚Üí Design and analysis of algorithms
Distributed algorithms;

KEYWORDS
Byzantine Fault Tolerance, Single Secret Leader Election, Sortition,
Blockchain, Deterministic Termination, Proof of Stake

1

1 INTRODUCTION
Since the advent of Bitcoin [29], blockchain systems have grown
to an entire field of study in computer science. At a high level, a
blockchain is a tamper-proof ledger of blocks of data issued by the
system members. As a baseline, the chain of data blocks keep record
of asset transfers between the participants [29], but often it offers
more general functionality [12]. To reach agreement on the order
in which data blocks appear in the chain, blockchains resort to the
fundamental problem of consensus.

Consensus is one of the most studied problems in distributed
computing. Mainstream consensus implementations follow the
classical leader-based approach [16, 25], where a single process
is selected to be the leader whose task is to propose a value and
orchestrate the agreement.
Secret leader election. Using a publicly known leader as a pro-
poser of a new block opens the door to the Denial of Service (DoS)
attack. The adversary can try bringing down the leader, which may
slow down the consensus protocol, and thus the blockchain as a
whole. This issue can be addressed in multiple ways.

First, we can allow every participant to propose a block (thus,
avoiding a single target of attack) and then use consensus to choose
one of them (this is done for example in RedBelly blockchain [19]).
However, as the blocks are publicly known, the adversary may try
alienating participants with undesired proposals.

Alternatively, following the approach of Algorand [23], one can
use verifiable random functions (VRF), to select a set of participants
as potential leaders and then pick one of them using a deterministic
tie breaker (e.g., the lowest VFR output). In this approach, how-
ever, a process cannot know for sure that it is elected before every
other candidate reveals its input, which incurs extra communication
complexity and creates a potential security breach.

Thus, one may want to hide the identity of the leader until she
makes her proposal, and then it is too late to mount a DoS attack
against her. This functionality is captured by the single secret leader

 
 
 
 
 
 
election abstraction (SSLE) introduced by Boneh et al. [6]. Besides
avoiding the DoS attack, the SSLE-based approach also preserves
the original structure of most blockchain implementations currently
in use. However, repeatedly using SSLE for each optimistic attempt
to solve consensus may only yield probabilistic progress guarantees.
Even in synchronous executions, it may take an unbounded number
of election rounds before a correct leader is picked up.
Our contributions. In this paper, we introduce a new secret leader-
election abstraction, secret leader sortition (SLS), that perfectly matches
blockchain systems relying on leader-based consensus by providing
deterministic finality (e.g., Tezos based on Tenderbake[1], or Cosmos
based on Tendermint[11]). The SLS abstraction ensures that every
process gets elected in a bounded round and, thus, the counterpart
consensus protocol is guaranteed to terminate in a bounded num-
ber of rounds. More precisely, instead of electing an independent
leader for each round of consensus, SLS constructs a permutation of
ùëõ system participants that can be used for ùëõ consecutive consensus
rounds. Moreover, the construction is unpredictable: nobody can
learn the position of a correct participant in the permutation before
she reveals herself.

Following Boneh et al. [6], our SLS implementation that we call
Homomorphic Sortition is based on Threshold Fully Homomorphic
Encryption (ThFHE). Unlike [6], however, our protocol is purely
asynchronous. Furthermore, our protocol can be efficiently used
in proof-of-stake (PoS) blockchains that rely on the assumption
that the participants controlled by the adversary can only hold a
minor fraction of the total stake, typically less than one third. SLS
fairly accounts for the stake distribution across the participants
in the permutation: the probability of a participant to be assigned
a position in the permutation is proportional to its share of stake
among the remaining candidates.

On the practical side, Homomorphic Sortition was designed to ben-
efit from multiprocessing capabilities of modern machines. When-
ever possible, different stages of the ThFHE circuits were designed
in a mutually-independent manner, which enables efficient paral-
lelization of cryptographic computations. Furthermore, once the
setup phase is complete, the protocol does not require any informa-
tion from consensus when deployed in a blockchain, which allows
us to run several instances of our protocol in a pipeline. By us-
ing precomputations, i.e., by electing the leaders in advance, the
block creation latency can thus be made comparable to that of
deterministic, insecure round-robin leader scheme.

The rest of the paper is organized as follows. In Section 2, we
formally define the SLS problem. In Section 3, we describe our
Homomorphic Sortition algorithm, explain how it can be used in
the blockchain context, and give details on our implementation.
In Section 4, we report on its performance. Section 5 overviews
related work and Section 6 concludes the paper.

2 PROBLEM STATEMENT: SECRET LEADER

SORTITION

The election protocol can be run on a blockchain system using
leader-based consensus. It has a set of processes Œ† = {ùëù1, ùëù2, . . . , ùëùùëõ }
forming a committee with stakes ùëÜ. If the underlying system pro-
vides the means to do so, the membership of the committee might

2

be dynamic, i.e. the set of processes that take part in it might change
over time.

Each next data block in the blockchain defines publicly known
stake distribution. More precisely, the total stake of the committee is
ùë†ùë° = (cid:205)ùëñ ‚àà [1..ùëõ] ùëÜ [ùëñ], where ùë†ùëì < ùë†ùë° /3 of it is controlled by Byzantine
committee members. Byzantine participants may exhibit arbitrary
behaviour. In particular, they may collaborate, trying to prevent
correct (non-Byzantine) processes from being elected. To this end,
they might omit information, send different messages to different
processes (equivocate), share not well-formed data, etc.

The communication channels are reliable: messages exchanged
by correct processes are eventually delivered. We assume, however,
that communication is asynchronous, i.e., communication delays
may not be bounded. 1

A Secret Leader Sortition (SLS) protocol outputs a list of ùëõ publicly
known vouchers ùë£1, ùë£2, . . . , ùë£ùëõ and ùëõ proofs ùúã1, ùúã2, . . . , ùúãùëõ where, for
each ùëñ, ùúãùëñ is only revealed to ùëùùëñ and no information about it is
revealed to any other process or the adversary. For each ùëü = 1, . . . , ùëõ,
a process ùëùùëñ is said to be elected in round ùëü , and we write ùëôùëü = ùëùùëñ ,
if ùúãùëñ can claim the voucher ùë£ùëü , which is confirmed via a publicly
known function verify.

An SLS protocol must satisfy the following properties:

‚Ä¢ Uniqueness: ‚àÄùëü, ‚àÉ! ùëñ : verify(ùëñ, ùúãùëñ, ùë£ùëü ) = true. Moreover,
it is computationally intractable for the adversary to pro-
duce a proof ùúã such that for ùëù ùëó ‚â† ùëùùëñ , verify( ùëó, ùúã, ùë£ùëü ) = true,
even if they know ùúãùëñ . This prevents potential front-running
attacks.

‚Ä¢ Fairness: The leader in round ùëü is selected from Œ† \
{ùëô1, . . . , ùëôùëü ‚àí1} with probability proportional to the uns-
elected amount of stakes. More formally, for all ùëùùëñ ‚àà
Œ† \ {ùëô1, . . . , ùëôùëü ‚àí1}:

Pr[ùëôùëü = ùëùùëñ ] =

ùëÜ [ùëñ]
(cid:205)ùëù ùëó ‚àà (Œ†\{ùëô1,...,ùëôùëü ‚àí1 }) ùëÜ [ ùëó]

‚Ä¢ Unpredictability: if ùëôùëü is correct, unless the proof ùúãùëôùëü

is
revealed, the adversary cannot guess the leader for the
round ùëü better than based on the information about the
stakes, the set of already revealed leaders, and the positions
of the Byzantine processes in the permutation.

‚Ä¢ Termination: If all correct processes execute the protocol,
then every correct process ùëùùëñ eventually yields all vouchers
and the proof ùúãùëñ .

Therefore, the SLS abstraction ensures that every process ùëùùëñ
computes the same list of ùëõ vouchers, one for each position (round)
ùëü in the cycle of election. In addition, ùëùùëñ computes a private proof ùúãùëñ
that matches exactly one voucher ùë£ùëü in the list, i.e., verify(ùëñ, ùúãùëñ, ùë£ùëü )
evaluates to true. Unless, ùúãùëñ is revealed, no other process can
learn who is elected in rounds 1, . . . , ùëõ ‚àí 1 (for the last round, re-
vealing ùúã1, . . . , ùúãùëõ‚àí1 implies that the only remaining process is ùëôùëõ).
Finally, the probability of of a process to be elected in a round

1Notice that an accompanying blockchain system that consumes the leader indications
produced by our protocol and establishes setup for each election cycle may make
stronger synchrony assumptions. For example, most leader-based consensus protocols
assume partial synchrony: after an unknown amount of time ùê∫ùëÜùëá all the messages
must arrive within a certain upper bound of time Œî. This, however, does not affect our
leader election mechanism.

Method

Inputs

Outputs

Circuit C‚äï

[ùë•1, ùë•2, . . . , ùë•ùëõ]

Circuit CSym [ùë•1, ùë•2, . . . , ùë•ùëõ], [ùëò1, ùëò2, . . . , ùëòùëõ]
Circuit C| |1
Circuit C| |2
Circuit Cùêª

pre, [ùë•1, ùë•2, . . . , ùë•ùëõ], pos
[ùë•1, ùë•2, . . . , ùë•ùëõ], [ùë¶1, ùë¶2, . . . , ùë¶ùëõ]

[ùë•1, ùë•2, . . . , ùë•ùëõ]

(cid:201)

ùë•ùëñ

, {ùë•2}ùëò2

ùëñ ‚àà [ùëõ]
, . . . , {ùë•ùëõ }ùëòùëõ ]
[{ùë•1}ùëò1
[pre||x1||pos, pre||x2 ||pos, . . . , pre||xn||pos]
[x1||y1, x2 ||y2, . . . , xn||yn]
[ùêª (ùë•1), ùêª (ùë•2), . . . , ùêª (ùë•ùëõ)]

Circuit C√ó
Circuit C<

Circuit C¬¨
Circuit CùëÜùëíùëô

ùë•, ùë¶

ùë•, [ùë¶1, ùë¶2, . . . , ùë¶ùëõ]

[ùë•1, ùë•2, . . . , ùë•ùëõ]

ùë• √ó ùë¶

[ùë• < ùë¶1, . . . , ùë• < ùë¶ùëõ]

[¬¨ùë•1, ¬¨ùë•2, . . . , ¬¨ùë•ùëõ]

[ùë•1, ùë•2, . . . , ùë•ùëõ], [ùë¶1, ùë¶2, . . . , ùë¶ùëõ], ‚àÉ!ùëñ : ùë¶ùëñ = 1 ‚àß ‚àÄùëó ‚â† ùëñ, ùë¶ ùëó = 0

ùë•ùëñ

TFHE.Enc

[ùë•1, ùë•2, . . . , ùë•ùëõ]

C, Inputs
ùëñ

ùëó, ùëñ

TFHE.Eval

TFHE.PDec

TFHE.Ver

TFHE.Dec

[ùë¶1, ùë¶2, . . . , ùë¶ùëõ‚àíùëì ] (shares of ùëñ)

ùëñ

Table 1: ThFHE methods

[ùë•1, ùë•2, . . . , ùë•ùëõ]

Evaluation of C applied to Inputs
1 out of ùëõ ‚àí ùëì shares of ùëñ

1 if ùëó is a share of ùëñ, 0 otherwise

ùëü is proportional to its fraction of stake among its competitors,
Œ† \ {ùëô1, . . . , ùëôùëü ‚àí1}.

3 SLS SOLUTION
Notation. First we introduce the notations used in the following
sections: scalar values are written with a single lower case letter
(e.g., ùëì ), vectors with a single upper case letter (e.g., ùêæ) and ma-
trices with double upper case letters (e.g., ùëÖùëÖ). Values which are
homomorphically encrypted are written with an underline (e.g., ùëÜ )
and sets are represented by capital greek letters (e.g., Œõ). Subscripts
might be added to variables to give more context when necessary.
A list of values enclosed in square brackets (e.g., [ùëé, ùëè, ùëê]) denotes
a column vector, (¬∑)ùëñ denotes a value signed using ùëÜùëÜùêæùëñ and {¬∑}ùëñ
denotes a value encrypted using ùëÉùê∏ùêæùëñ .

3.1 Cryptographic primitives
First of all, we need an encryption and a digital signature scheme.
Every process ùëùùëñ has a pair of public and private encryption keys
(ùëÉùê∏ùêæùëñ, ùëÜùê∏ùêæùëñ ) as well as a pair of public and private signature keys
(ùëÉùëÜùêæùëñ, ùëÜùëÜùêæùëñ ) where the private keys are only known by the process
who owns them and the public keys are globally known. Moreover,
we also need a Threshold Fully Homomorphic Encryption system
(ThHE) [7]. This type of encryption schemes allows computations
over encrypted data and guarantees that a certain threshold stake
of key holders (defined by a threshold value) are able to cooperate
to decrypt a ciphertext.

After a setup is complete, each process ùëùùëñ has access to a private
key ùëÜùëá‚Ñéùêπùêªùê∏ùëñ used to partially decrypt a ciphertext encrypted with
the joint public key PThFHE, known to every process. An encryption

3

operation is denoted ThFHE.Enc and a partial decryption operation
is denoted ThFHE.PDec. Once processes holding at least ùë†ùë° ‚àíùë†ùëì stake
issue a partial decryption operation for a given encrypted value, it
is possible to retrieve the corresponding clear-text value. Shares
corresponding to less than ùë†ùë° ‚àíùë†ùëì stake reveal no information about
the encrypted value. Additionally, before decrypting the final value
using the operation ThFHE.Dec, a process can check that the partial
decryption it receives corresponds to an encrypted value by calling
ThFHE.Ver.

The operations over encrypted data are done via operation
ThFHE.Eval using publicly known circuits presented in Table 1
along with the list of operations exported by the ThFHE system.

The circuits C‚äï and C¬¨ take as input ùëõ encrypted values ùë•1, ùë•2, . . . , ùë•ùëõ

and output the XOR of the whole input and its negation, respec-
tively. The circuit CSym takes ùëõ encrypted values ùë•1, ùë•2, . . . , ùë•ùëõ and
ùëõ encrypted symmetric keys ùëò1, ùëò2, . . . ùëòùëõ and encrypts each value
ùë• ùëó with the corresponding key ùëò ùëó , ‚àÄùëó ‚àà {1, . . . , ùëõ}. The circuit C| |1
takes a list of encrypted inputs, prepending a cleartext string ùëùùëüùëí
and appending a cleartext string ùëùùëúùë† to each of them (so, for each
ùëó, the output is ùëùùëüùëí ||ùë• ùëó ||ùëùùëúùë†, where || denotes concatenation). A
similar circuit, C| |2 takes two lists of encrypted inputs, appending
them element-wise.

The circuit Cùêª implements a cryptographic hash function ùêª .
Our results are in the random oracle model: the hash function ùêª is
assumed to be computationally indistinguishable from a random
function with the same range. Note that this implies the weaker
collision resistance assumption: it is intractable to find a pair of
values ùë• and ùë• ‚Ä≤ such that ùêª (ùë•) = ùêª (ùë• ‚Ä≤).

Variables

1 in the position of elected process for round ùëü , 0 otherwise

ùê∏
ùê∫ 1 where the random number is greater or equal to the partial sum, 0 otherwise ùëö unselected stake
ùêø
ùëÉ
ùë†ùëü
ùë†ùë°
ùë£ùëü
Œõ partial decryptions of result

1 where the random number is less than the partial sum, 0 otherwise
processes‚Äô proofs
stake of the elected process for the round
total system stake
voucher of elected process for round ùëü

number of participants
random numbers vector
processes‚Äô stakes
stake partial sum
processes‚Äô vouchers
ID of the round ùëü leader

ùë†ùëì

ùëõ
ùëÖ
ùëÜ
ùëà
ùëâ
ùëñùëü

upper bound on the Byzantine stake

Table 2: Homomorphic Sortition variables

The circuit C√ó takes two encrypted values and returns their
product. The circuit C< takes an encrypted value ùë• and a list of
encrypted values [ùë¶1, ùë¶2, . . . , ùë¶ùëõ and returns a list where whenever
ùë• < ùë¶ùëñ the ùëñ-th is set to 1, otherwise it is assigned a 0 value. Finally,
the circuit CùëÜùëíùëô receives an array such that only one position ùëñ is
set to 1 and all the others have a value 0 and a second array of
encrypted values, returning the ùëñ-th element of this array.

3.2 The Homomorphic Sortition Protocol

Algorithm 1 Homomorphic Sortition for process ùëùùëñ

1: operation sortition(P, R, ùëü )
2:

if ùëü = 1 then

3:

4:

5:

6:

7:

8:

9:

10:

11:

12:

13:

14:

15:

16:

17:

18:

19:

20:

ùëà := ThFHE.Enc( (cid:2) (cid:205)ùëó ‚àà [1] ùëÜ [ ùëó], . . . , (cid:205)ùëó ‚àà [ùëõ] ùëÜ [ ùëó](cid:3))
ùëö := ThFHE.Enc((cid:205)ùëó ‚àà [1..ùëõ] ùëÜ [ ùëó])

ùë• := the ùëè MSB of ThFHE.Eval(C√ó, ùëÖ [ùëü ], ùëö)
// MSB stands for most significant bits
// m and R[r] have ùëè bits, hence the product has 2ùëè bits

ùêø := ThFHE.Eval(C<, ùë•, ùëà )
ùê∫ := ThFHE.Eval(C¬¨, ùêø)
ùê∏ [1] := ùêø[1]
ùê∏ [2..] := ThFHE.Eval(C&, ùêø[2..], ùê∫ [1..ùëõ ‚àí 1])
ùë†ùëü := ThFHE.Eval(CùëÜùëíùëô , ùê∏, ùëÜ)
ùúãùëü := ThFHE.Eval(CùëÜùëíùëô , ùê∏, ùëÉ)
ùëñùëü := ThFHE.Eval(CùëÜùëíùëô , ùê∏, [1..ùëõ])
ùë£ùëü := ThFHE.Eval(Cùêª , ùúãùëü ||ùëñùëü )

ùê∑ := ThFHE.Eval(C&, ùë†ùëü , ùêø)
ùëà := ThFHE.Eval(C‚àí, ùëà , ùê∑)
ùëö := ThFHE.Eval(C‚àí, ùëö, ùë†ùëü )
Send ‚ü® PVoucher, ThFHE.PDec(ùë£ùëü ) ‚ü© to all

21: upon receiving ‚ü®PVoucher, ( Àúùë£ùëü ) ùëó ‚ü© from ùëù ùëó
22:

if ThFHE.Ver (ùë£ùëü , Àúùë£ùëü ) ‚àß (¬∑) ùëó ‚àâ Œõùëü then

23:

Œõùëü := Œõùëü ‚à™ ( Àúùë£ùëü ) ùëó

24: upon (cid:205)
25:

( ¬∑) ùëó ‚ààŒõùëü

ùëÜ [ ùëó] > ùë†ùë° ‚àí ùë†ùëì

ùë£ùëü := ThFHE.Dec(Œõùëü )

Figure 1: Sampling Circuit

4

  xLSBMSBU1U2U3U4mR√ó<<<<L¬¨¬¨¬¨¬¨GG1G2G3L1L2L3L4&&&ESESelectPESelectIESelectU1U2U3U4L1L2L3L4sr&&&&----U1U2U3U4msr-mirœÄrHvrcurrent cycle
ùëê
seed numbers
ùëÑ
ùë•, ùëã local rand. numbers

‚Ñé
ùëÑùëÑ,ùëáùëá
ùëå

current height
committed random values
sym. encrypted tickets

Variables
ùëùùëñ ‚Äôs symmetric key
ùëòùëñ
ùëùùëñ ‚Äôs current ticket
ùë°ùëñ
Œ¶ partial decrypt. of tickets

ùêæ
ùëá
ùúãùëñ

processes‚Äô symmetric keys
processes‚Äô tickets
ùëùùëñ ‚Äôs proof of election

Table 3: Extra variables used for integration in alphabetical order

Overview. At a high level, in our Homomorphic Sortition protocol
(presented in Algorithm 1), every process samples the vouchers one
by one in order to create an ordered list. Once a voucher is sampled,
the corresponding process‚Äô information is updated in the sampling
mechanism so that each user is selected exactly once. Once enough
correct processes execute the protocol, the voucher is subsequently
decrypted to its plain value.
Sortition. The vouchers are picked one by one following a weighted
sample. To carry this sample, processes begin by building a cumula-
tive sum of and total sum of the participant‚Äôs stake doing operations
in clear data and then storing in their encrypted form (lines 3 and 4).
After these computations are done the circuit shown in Figure 1
(for clarity, we illustrate the case when ùëõ = 4) is executed ùëõ times.
Sampling. For the moment, assume that processes have access to
an array ùëÖ of ùëõ common random numbers of ùëè bits each. Importantly,
the number of bits used to represent the total stake in the system ùëö
is also ùëè. By multiplying these two values and keeping only the ùëè
most significant bits of the result in the variable ùë• , we get a random
number between 0 and ùëö (line 5).

The following lines (9 to 12) find the position in the cumulative
sum array that contains the smallest value bigger than ùë•, which is
enough to obtain a result satisfying the randomness requirement.
This is done by first creating a vector ùêø set to 1 in all positions
such that ùë• is strictly less the value in ùëà in the same position. The
desired index will be the first one set to true, which can be obtained
by making a logical and between ùêø and its inverse shifted by one
position, i.e. ùêø[1], ùêø[2] ‚àß ¬¨ùêø[1], ùêø[3] ‚àß ¬¨ùêø[2], . . . , ùêø[ùëõ] ‚àß ¬¨ùêø[ùëõ ‚àí 1].
Once the process is selected, its stake ùë†ùëü is subtracted from the
total unselected stake ùëö, as well as from cumulative sums of its
position and of the processes who follow it. This is equivalent to a
new partial sum array in a scenario where ùëôùëü has stake zero, and
hence cannot be selected (lines 13, 18 and 19).
Vouchers. The goal of the protocol is to determine the order in
which processes become leaders, but because of the secrecy require-
ments, it must be done in a manner that only the elected process
knows about the result. For the moment, let us assume that each
participant is dealt its proof to claim the voucher and that every
process has the list of all proofs ùëÉ encrypted with ThFHE. We use
the infomation of the vector ùê∏ to determine the leader‚Äôs proof and
ID. We then append these two values and take the hash of the result
as the voucher. This guarantees that each voucher can be claimed
by at most one process, thanks to the collision resistance of the
hash function. Furthermore, since each process has access to its
proof and, prior to its reveal, no other participant has knowledge
of it, every user is able to see its position in the result but of no one
else.
Decryption. The rest of the algorithm shows how each voucher
is decrypted (lines 20 to 25). Processes first send to all processes

their partial decryptions, collecting messages of this type from
other participants. A message is only kept if it passes the partial
decryption test. Once at least ùë†ùë° ‚àí ùë†ùëì stake is validated, a final
decryption yields the plaintext value of the voucher.

3.3 Integration with blockchain and consensus

Algorithm 2 Homomorphic Sortition + consensus for process ùëùùëñ
26: The blockchain schedules consensus‚Ñé,ùëê,ùëü
27: before executing consensus‚Ñé,ùëê,ùëü
28:

if ùëü = 1 then

29:

30:

31:

32:

ùëÉ := ThFHE.Eval(C| |1, ‚Ñé,ùëá , ùëê)
ùëÉ := ThFHE.Eval(Cùêª , ùëÉ)
ùëÖ := ThFHE.Eval(C| |1, ‚Ñé, ùëÑ, ùëê)
ùëÖ := ThFHE.Eval(Cùêª , ùëÑ)

sortition‚Ñé,ùëê (ùëÉ, ùëÖ, ùëü )

33: upon sortition‚Ñé,ùëê (¬∑, ¬∑, ùëü ) = ùêª (ùêª (‚Ñé||ùë°ùëñ ||ùëê)||ùëñ)
34:

Prop. block in consensus‚Ñé,ùëê,ùëü w/ ùúãùëñ := ùêª (‚Ñé||ùë°ùëñ ||ùëê)

35: upon receiving PROPOSAL, ùúã ùëó ‚àß ùë£‚Ñéùëêùëü = ùêª (ùúã ùëó || ùëó) from ùëù ùëó
36:

Accept proposal in consensus

Orchestration. So far we have considered how to obtain one se-
quence of non-repeating leaders. Nevertheless, in order to deploy
the protocol in a blockchain, it is necessary to execute it several
times. These executions are coupled with consensus by organising
them into heights (‚Ñé), cycles (ùëê) and rounds (ùëü ). The position of a
process is determined by the triple ‚Ñé, ùëê, ùëü and all processes begin
with ‚Ñé = ùëê = ùëü = 1.

Once a block is successfully appended to the blockchain, pro-
cesses move to the position ‚Ñé + 1, 0, 0, maintaining the property that
for every height only one block is accepted.

A height is divided into an arbitrary number of cycles, which, in
turn, are divided into at most ùëõ rounds each. A round retains the
semantic given in the election protocol, having a unique proposer,
while a cycle corresponds to an instance of sortition. The consensus
protocol has an adaptive timer that stipulates how long a process
waits for a block being accepted and if this event does not happen
within the stipulated time period, the processes time out. In this
case, participants move to the next round, corresponding to the
position ‚Ñé, ùëê, ùëü + 1. However, in a partially synchronous network, it
may happen that even after ùëõ rounds, the consensus will still not
be reached. In this case, the sortition protocol must be restarted,
moving to position ‚Ñé, ùëê + 1, 0.

5

42:

43:

44:

45:

46:

52:

53:

54:

55:

56:

Algorithm 3 Homomorphic Sortition randomness
37: Generate 2ùëõ local random numbers ùë• 1
38: ùëãùëñ := [ThFHE.Enc(ùë• 1
39: Send ‚ü® RAND, (ùëãùëñ )ùëñ ‚ü© to all

ùëñ , ùë• 2
ùëñ ), . . . , ThFHE.Enc(ùë• 2ùëõ
ùëñ

ùëñ , . . . , ùë• 2ùëõ
ùëñ
)]

40: upon sortition‚Ñé,ùëê = ùêª (ùêª (‚Ñé||ùë°ùëñ ||ùëê)||ùëñ)
41:

Become leader and propose block w/ ùúãùëñ, ùëÑùëÑ,ùëáùëá :
Collect ‚ü®RAND, ùëã ùëó ‚ü© into ùëã1 ‚Ä≤, . . . , ùëãùëì +1

‚Ä≤

with at least ùë†ùëì + 1 stake
ùëÑùëÑ [1] := ùëã1 ‚Ä≤[1..ùëõ], . . . , ùëÑùëÑ [ùëì + 1] := ùëãùëì +1
ùëáùëá [1] := ùëã1 ‚Ä≤[ùëõ+1..2ùëõ], . . . ,ùëáùëá [ùëì +1] := ùëãùëì +1

‚Ä≤[1..ùëõ]

‚Ä≤[ùëõ+1..2ùëõ]

47: upon receiving PROPOSAL, ùúã ùëó ‚àß ùë£‚Ñéùëêùëü = ùêª (ùúã ùëó || ùëó) from ùëù ùëó
if ‚àÉ signatures with at least ùë†ùëì + 1 stake in ùëÜùëÜ and ùëáùëá then
48:

49:

Accept proposal in consensus

50: upon block is decided w/ ‚ü®ùëÑùëÑ,ùëáùëá ‚ü©
51:

ùëá := [ThFHE.Eval(C‚äï,ùëáùëá [1..ùëì + 1] [1])

. . . , ThFHE.Eval(C‚äï,ùëáùëá [1..ùëì + 1] [ùëõ])]

ùëÑ := [ThFHE.Eval(C‚äï, ùëÑùëÑ [1..ùëì + 1] [1])

. . . , ThFHE.Eval(C‚äï, ùëÑùëÑ [1..ùëì + 1] [ùëõ])]

ùëå := ThFHE.Eval(CSym,ùëá , ùêæ)
Send ‚ü® PTickets, (ThFHE.Dec(ùëå ))ùëñ ‚ü© to all

57: upon receiving ‚ü®PTickets, ( Àúùëå ) ùëó ‚ü© from ùëù ùëó
58:

if ThFHE.Ver (ùëå, Àúùëå ) ‚àß (¬∑) ùëó ‚àâ Œ¶ then Œ¶ := Œ¶ ‚à™ ( Àúùëå ) ùëó

59: upon (cid:205)
60:

( ¬∑) ùëó ‚ààŒ¶ ùëÜ [ ùëó] > ùë†ùë° ‚àí ùë†ùëì

ùëå := ThFHE.Dec(Œ¶)
ùë°ùëñ := Sym.Dec(ùëå [ùëñ], ùëòùëñ )

61:

hash length is also sufficiently large for security, but for clarity we
present them as 8 bit values. In our scenario, the participants have
stake 42, 3ùê∂, 17 and 6ùê¥, respectively.

Tickets and seeds. There are two types of randomness in Homo-
morphic Sortition: tickets and seeds. Tickets are used to generate
proofs and vouchers, while the seeds are used to generate the ran-
domness necessary in the sampling algorithm. We leave to the
blockchain protocol the option to issue the algorithm that creates
new tickets and seeds to be used in the Homomorphic Sortition
(line 37). This should always be done at the beginning of the proto-
col (the first set of seeds and tickets can be generated in the setup of
the ThFHE scheme) or if the membership of the committee changes.
Entering consensus. The proof of process ùëùùëñ in height ‚Ñé, cycle ùëê
is ùúãùëñ = ùêª (‚Ñé||ùë°ùëñ ||ùëê), while the voucher is ùêª (ùúãùëñ ||ùëñ). Hence, once a pro-
cess asserts that the current selected voucher is ùêª (ùêª (‚Ñé||ùë°ùëñ ||ùëê)||ùëñ), it
knows that it has been elected (line 40) and can use ùúãùëñ to convince
others (line 47). Once the leader proposes a block, the other pro-
cesses proceed normally with the consensus protocol if the election
is verified or simply discard the proposal otherwise.
Producing the random tickets and seeds. Once a new set of
random numbers is needed, every process generates 2ùëõ local ran-
dom numbers (line 37). Half of them are used to produce tickets and
the other half to produce seeds. Then the process encrypts each of
them with the ThFHE scheme (line 38). The list of encrypted values
is sent to all processes (line 39) and treated by the leader who picks
ùëì + 1 of these values corresponding to a stake of at least ùë†ùëì + 1 and
includes them in its proposal in the form of two (ùëì + 1) √óùëõ matrices
(line 44).

If there is also a Rand trigger, then the leader must also include
two matrices containing the random numbers coming from ùëì + 1
different processes which are used for producing seeds and tickets
(lines 45 to 46). The other committee members check the integrity of
the proof and random matrices and if the verification is successful,
the proposal is treated in the consensus protocol, being discarded
otherwise (lines 47 to 49).

Whenever a block is committed with the two random matrices
aforementioned, these matrices are collapsed into two vectors by
XORing them columnwise (lines 52 and 54). While the seeds are
kept encrypted, the tickets are symmetrically encrypted (under
ThFHE) with the matching process key elementwise, and then
decrypted (lines 55 to 61), with every process sending a partial
ThFHE decryption.
The vectors ùëÉ and ùëÖ. Now it is possible to understand where the
proofs and random numbers come from. At a first glance it might
seem that processes can use their tickets as proofs; this would,
however, mean that each ticket could be used only once and we
would not be able to restart the protocol for cycles beyond 1. Instead,
by prefixing the ticket by the current height and appending the
current cycle (line 29) and taking the hash of the result (line 30),
we obtain the proof used in our protocol. This proof can be easily
generated for each new instance of Homomorphic Sortition and does
not reveal any information about the ticket, making it possible
to keep using the same value. The random numbers used in the
sampling are generated from the seeds using the same strategy.

3.4 Example of a possible execution
Let us now describe in details a simple scenario with four processes
ùëù1, ùëù2 (Byzantine), ùëù3, ùëù4. In a real implementation, the size of the
random numbers and stake are in the order of billions, while the

6

Figure 2: Example of random generation

  t1t2t3t4q1q2q3q4013532968155C174x17FF42246296BD11Ax2‚Äô7EC110D0A83E106Ex2‚Äô‚Äô0000000000000000x3632D238202E9E741x4B4D949F356151CE3‚ü®RAND,[x2',x3]‚ü©‚ü®RAND,[x1,x2']‚ü©‚úîYEnc(01, Sym1)Enc(35, Sym2)Enc(32, Sym3)Enc(96, Sym3)p1p3p2·ª∏·ª∏ƒ®p4‚ü®RAND,[x2',x2'']‚ü©Figure 3: Example of sampling

Rand Trigger. As shown in Figure 2, the correct processes start
by generating 2ùëõ = 8 random numbers each, while the Byzantine
process can generate any amount of numbers and picking fixed val-
ues instead. These numbers are sent to every process and once one
of them become a leader, it can include a subset of these numbers
in its proposal. The proposal will be discarded if more than

Once a valid proposal is put forward and is subsequently commit-
ted, the participants can compute the tickets and seeds to be used.
In this example, the value committed contains ùë•3 and ùë• ‚Ä≤
4 hence the
tickets shall be ùë°1 = 7ùêπ ‚äï 7ùê∏ = 01, ùë°2 = ùêπ 4 ‚äï ùê∂1 = 35, ùë°3 = 22 ‚äï 10 =
32, ùë°4 = 46 ‚äï ùê∑0 = 96. The second part of the array yields the seeds,
following the same reasoning.

The seeds are only kept inside the ThFHE encryption, but the
tickets are distributed to their owners. To this end, every process
computes the vector ùëå , by encrypting each ticket in the symmetric
key of the corresponding process. Afterwards, they share their
partial decryptions, but the Byzantine process might try to send
an invalid partial decryption, which would be discarded by the
ThFHE.Ver function. Since there are ùëõ ‚àí ùëì = 3 correct processes in
the system, the tickets are eventually decrypted and the processes
are ready to begin sampling.
Sampling. Figure 3 shows a possible sampling execution. Let us
suppose that the protocol is currently at height 5, cycle 3. First, it is
necessary to produce the vouchers for this instance of homomorphic
sortition, as well as the random numbers necessary. This is done
using the values produced in the previous paragraphs with the step
by step computations for ùëÉ, ùëÖ and ùëâ shown in the figure.

The partial sum of stakes array ùëà is initially computed in the
clear: 42, 42 + 3ùê∂ = 7ùê∏, 42 + 3ùê∂ + 17 = 95, 42 + 3ùê∂ + 17 + 6ùê¥ = ùêπ ùêπ ,
then encrypted into the ThFHE scheme, where it will be updated
as the protocol progresses.

The first random number, given by the vector ùëÖ is 79. This value
is multiplied by the total unselected stake of the cycle, in this case
ùêπ ùêπ , yielding the result 7887. The first eight bits (78) are conserved,

while the last eight are discarded. 78 is greater or equal to 42, but
it is less than 7ùê∏, 95 and ùêπ ùêπ , hence the vector ùêø is 0, 1, 1, 1. We
conserve the first set index by creating the array ùê∫, which negates
ùêø: 1, 0, 0, 0. We build ùê∏ by conserving the first bit of ùêø and for the
other positions by taking the AND of ùêø with ùê∫ shifted one position
to the right (see Figure 1): 0, 1 ‚àß 1 = 1, 1 ‚àß 0 = 0, 1 ‚àß 0 = 0. ùê∏ can be
used to select the proof of the elected process for this round, which
in our example is the process ùëù2, whose proof is ùê∂2, then the result
of the election is the voucher ùë£1 = ùêª (ùê∂22) = ùê∏3. It is also used to
select ùëù2‚Äôs stake, and subtracting it of the partial sum of all process
with indices greater or equal than 2 via the vector ùê∑ = 0, 3ùê∂, 3ùê∂, 3ùê∂.
Therefore, the state of the partial sum array for the second round
is 42 ‚àí 0 = 42, 7ùê∏ ‚àí 3ùê∂ = 42, 95 ‚àí 3ùê∂ = 59, ùêπ ùêπ ‚àí 3ùê∂ = ùê∂3 and the
total unselected stake is ùê∂3. The second position of ùëÖ is 57, hence
the random number between 0 and the unselected stake for this
round is ùê∂3 √ó 57 = 4245. Notice that 42 is greater than equal to 42
and less than 59 and ùê∂3, hence the values of ùêø and ùê∫ for this round
are 0, 0, 1, 1 and 1, 1, 0, 0, resulting in ùê∏ = 0, 0, 1, 0. This means that
process ùëù3 is selected and the proof for this round is 2ùêµ, resulting in
the voucher ùë£2 = ùêª (2ùêµ3) = 47 and the new partial sum for the next
round shall be 42 ‚àí 0 = 42, 42 ‚àí 0 = 42, 59 ‚àí 17 = 42, ùê∂3 ‚àí 17 = ùê¥ùê∂.
The same reasoning is applied for the last two rounds.

3.5 Pipelining
One of the features of Homomorphic Sortition is the complete inde-
pendence between different heights and cycles, which combined to
a vectorised approach adopted in the circuit design results into a
highly parallelisable protocol which can be executed in a pipeline. A
blockchain that deploys our protocol must guarantee that a voucher
is produced for a specific height, cycle and round combination is
produced before executing consensus.

Let us consider a scenario where the system has already stabilised
and that the delays in communication and the performance of the
local computations create a situation where executing one round

7

  PH(5 01 3) = 9EH(5 35 3) = C2H(5 32 3) = 2BH(5 96 3) = 3CRH(5 81 3) = 79H(5 55 3) = 57H(5 C1 3) = DFH(5 74 3) = 8AS423C176Ah = 5  c = 3mFFxFF√ó79=7887U427E95FFG1000L0111E0100D03C3C3Cr = 1mC3xC3√ó57=4245U424259C3G1100L0011E0010D001717r = 2mACxAC√óDF=95D4U424242ACG1110L0001E0001D0006Ar = 3m42x42√ó8A=2394U42424242G0000L1111E1000D42424242r = 4v1H(C22)=E3œÄ2C2v2H(2B3)=47œÄ3FBv3H(3C4)=27œÄ43Cv4H(9E1)=10œÄ19EThe stream cipher Grain-128a is designed such that a MAC is
computed in parallel of the cipher computation. The computation
of a MAC is basically the computation of a keyed hash function so
the idea was to fix the key used by the MAC in order to obtain a
hash function. The construction we obtain is given below.

Figure 4: Example of pipeline

of HS takes roughly the same amount of time as executing three
rounds of consensus. Then, an adaptive scheduler can manage its
threads in the manner depicted in Figure 4. By executing the sorti-
tion protocol in parallel for every position possibly reached in three
consensus instances, the consensus protocol can be run non-stop,
yielding the same latency as a round-robin leader implementation
would.

In the figure we represent different threads vertically and time
elapsed horizontally. Timed out consensus operations are shown in
light green, positions that generate a commit in dark green, aborted
HS instances in yellow and completed sortitions in violet.

3.6 Computing Hashes in FHE
Let us first mention that even if there exists several "FHE-friendly"
keystreams (e.g. Trivium [13], Kreyvium [14]), and blockciphers
(e.g. Flip [28]), to the best of our knowledge, the hash functions
were not analysed and conceived for an efficient homomorphic
execution. In order to obtain a secure hash function that could be
used on encrypted data with homomorphic encryption, we studied
various approaches.The first one was to implement hash functions
from the lightweight cryptography standards [30]. This approach
seemed interesting at first because with homomorphic encryption,
the algorithms we want to use need to be represented by a number of
Boolean gates as low as possible especially in terms of multiplicative
depth. It turned out that most of the hash functions candidates in
lightweight cryptography had a quite high multiplicative depth
and required the use of many Bootstrapping operations to reset the
noise. With the candidates that we studied, it required several hours
to execute their hash functions on encrypted data with TFHE [18]
scheme (and even more with other FHE schemes). This result was
not efficient enough for a election protocol for the blockchain (or
any application at all) so we tried to find an approach that differs
from most hash functions.

Most hash functions nowadays use a block permutation several
times in some mode of operation. This generally implies that there
is at least one operation in the block permutation with a certain
multiplicative depth which grows as the permutation is called. In
order to obtain a more efficient hash function, we looked for a
construction which wouldn‚Äôt imply this behaviour and more specif-
ically one that would allow us to do most of the computations in
the clear. To achieve this goal, we looked for hash functions based
on stream ciphers and found Grain-128a [26] which is a stream
cipher with optional authentication.

Figure 5: Homomorphic computation of a hash function de-
rived from the Grain stream cipher

Let a message ùëÄ of ùëö bits, ùëÄ = (ùëè0, ùëè1, ..., ùëèùëö‚àí1) where each bit
ùëèùëñ is associated to ùëõ bits of a keystream of size ùëõ √ó ùëö. To compute
our hash, we multipy each bit of the keystream (0 or 1) by the
associated message, then we perform the XOR of all the resulting
multiplications.

More generally, let ùëèùëñ a bit of the message ùëÄ and let denote
(ùêæùëÜùëñ√óùëõ, ..., ùêæùëÜ (ùëñ+1)√óùëõ‚àí1) the keystream of size ùëõ associated to ùëèùëñ .
Then, ùêª (ùëÄ) = (cid:201)ùëö‚àí1
ùëñ=0 ùëèùëñ √ó (ùêæùëÜùëñ√óùëõ, ..., ùêæùëÜ (ùëñ+1)√óùëõ‚àí1).
Homomorphic evaluation of the hash. We recall that the hash
function is a keyed hash function with a fixed public key. In this
construction, the keystream is also public and ùëÄ = (ùëè0, ùëè1, ..., ùëèùëö‚àí1)
is encrypted homomorphically.

Therefore, the hash function we obtain is particularly convenient
for a homomorphic execution because most of the computation
relies on the generation of the keystream bits which can be done in
the clear when the key is public like in our case. Also, when using
homomorphic encryption, one must specifically pay attention to
the multiplicative depth of the circuit they want to use. In our case,
the multiplicative depth of the construction is in fact 0 because
the only multiplications we perform ùëèùëñ √ó (ùêæùëÜùëñ√óùëõ, ..., ùêæùëÜ (ùëñ+1)√óùëõ‚àí1)
is a clear/cipher bit multiplication. Hence, if the clear bit is 0, the
multiplication will be 0 and if the clear bit is 1, the multiplication
will be the cipher and no additional noise is added to the cipher.

This construction can be performed on any homomorphic en-
cryption scheme that allows to perform XOR between ciphers with-
out requiring multiplications. To compute a hash of ùëõ bits from a
ùëö bits message, we need to perform ùëö XOR of ùëõ bits for a total
of ùëõ √ó ùëö XOR. To compute a hash of 256 output bits from a 256

8

  TimeCons.h,1,1Cons.h,1,2Cons.h,1,3Cons.h,1,4Cons.h,2,1Cons.h+1,1,1Cons.h+2,1,1Cons.h+3,1,1Cons.h+4,1,1HSh+3,1,1HSh,2,3HSh+4,1,1¬∑¬∑¬∑HSh,1,4HSh,2,4HSh+1,1,4HSh+5,1,1HSh,2,1HSh+2,1,4¬∑¬∑¬∑HSh,2,2b0b1b2...b(m-1)KS_2n****+++=H(M)KS_0KS_2n+1KS_1KS_3n-1......KS_n-1KS_nKS_n+1KS_2n-1...H_0KS_(m-1)nKS_(m-1)n+1KS_mn-1H_1......H_n-1FHEbits input, this gives a maximum of 216 = 65536 XOR (in fact, only
around 32000 because about half of the keystream bits are zero so
the corresponding XOR will not be necessary).
Implementation We implemented the hash function on Cingu-
lata, a open-source bitwise compiler designed for homomorphic
encryption. It allows to use the BFV [20] and TFHE [18] schemes.
We naturally chose BFV because we don‚Äôt require the use of the
Bootstrapping operation which would increase the execution time
for no reason. The execution parallelized on 4 cores took approx-
imately 5 seconds which is way better than the hours it takes to
perform a more classic hash function on encrypted data.

The particular optimisation that allows us to do so little com-
putations in the encrypted domain is the ability to generate the
keystream bits in the clear and if we had to do this under homo-
morphic encryption the multiplicative depth would explode with
a secure stream cipher and the performances would be nowhere
near 5 seconds.

Figure 6: Example of batching by columns

Further optimisations. With the BFV scheme, we can use the
batching technique which consists of regrouping the rows or columns
(not both) into one vector then allowing to perform the operations
between rows or columns (respectively) all at once and optimize
the space required by the homomorphic execution. When batch-
ing by columns, we end up with O (ùëõ) operations and O (ùëö) when
batching by rows (ùëõ the size of the hash and ùëö is the size of the
message). Besides, batching by columns gives us one encrypted
batch and batching by rows gives us ùëö encrypted batches.

Figure 7: Calculation of the hash using batching by columns

Batching over the hash function hasn‚Äôt been implemented yet
but gives perspectives that could lead to even better performances
for the hash function.
Security of the construction. The construction is derived from
the Grain family of stream ciphers whose security has been widely
studied for example in [26].

3.7 Implementation
To implement the sortition algorithm we used as for the homomor-
phic hash from Section 3.6 the Cingulata compiler. In this section
we dive a little bit into its operating mode in order to discuss the
optimizations it carries on and their impact on global performances.
The Cingulata Compiler. Cingulata relies on instrumented C++
types to denote private variables, e.g., CiInt for integers and CiBit
for Booleans. Integer variables are dynamically sized and are inter-
nally represented as arrays of CiBit objects. The Cingulata envi-
ronment monitors/tracks each bit independently. Integer operations
are performed using Boolean circuits, which are automatically gen-
erated by the toolchain. Another option is to use the bit-tracker
in order to build a circuit representation of the application. The
later allows to use circuit optimization modules in order to further
reduce the Boolean circuit representation. The hardware synthesis
toolchain ABC 2 is used to minimize circuit size. It is an open-source
environment providing implementations of state-of-the-art circuit
optimization algorithms. These algorithms are mainly designed for
minimizing circuit area or latency but, currently, none of them is
designed for multiplicative depth minimization. In order to fill this
gap, several heuristics for minimizing the multiplicative depth are
available in Cingulata (please refer to [2, 15] for more details).

The optimized Boolean circuit is then executed using Cingulata‚Äôs
parallel run-time environment (RTE). This RTE is generic, meaning
that it uses a HE library wrapper, i.e. a ‚Äúbit execution‚Äù object as
defined earlier, in order to execute the gates of the circuit. The
scheduler of the run-time allows to fully take advantage of many-
core processors. Besides, a set of utility applications are provided for
parameter generation (given a target security level), key generation,
encryption and decryption. These applications are also generic, in
the same vein as the parallel RTE.

3.8 Threshold overhead
We realised our implementation using non-threshold homomorphic
encryption schemes (i.e. the single-key versions of homomorphic
cryptostems). However this is quite representative of a real-world
scenario with threshold HE. Indeed in [8], authors develop a general
approach for adding a threshold functionality that allows to split
the secret key into a number ùëõ of shares for LWE-based (Learning
with errors) homomorphic schemes, with the property that the
full decryption requires a number ùë° ‚â§ ùëõ of partial decryptions
(using secret key shares). The overhead due to a threshold scheme,
as shown by Boneh et al., comes from the set up phase and the
decryption operations while the performances of homomorphic
operations are unaffected by the "thresholdizing".

4 ANALYSIS OF THE PROTOCOL
4.1 Choice of the homomorphic scheme
As briefly discussed in Section 3.6, all homomorphic cryptosystems
that enable both addition and multiplication of ciphertexts are de-
signed with a built-in noise parameter included in the ciphertexts.
This noise is an essential security element, but grows throughout
homomorphic operations. The decryption requires the noise to be
below a certain bound in order to output the correct plaintext. Two

2http://people.eecs.berkeley.edu/alanmi/abc/

9

b0b1b2KS[2,0]*KS[0,0]KS[1,0]MKS_0 *KS_1 KS[2,1]KS[0,1]KS[1,1]KS[2,2]KS[0,2]KS[1,2]KS_2 Batch by columns=M*KS_0 +‚Ä¶+ M*KS_2totalSumMKS_0 *KS_1 KS_2 M * KS_0 M * KS_1 M * KS_2 M*KS_0 +‚Ä¶+ M*KS_2M*KS_0 +‚Ä¶+ M*KS_2approaches to deal with the noise growth gave birth to two fami-
lies of homomorphic schemes. A first one is Fully homomorphic
encryption (FHE) in which one can perform an unlimited number
of multiplications and additions at the price of an expensive boot-
strapping operation which allows to bring back a ciphertext to a
nominal noise level while keeping its security intact. Another class
of homomorphic cryptosystems are the Levelled HE. They require
to know in advance the multiplicative depth of the homomorphic
circuit so the cryptosystem‚Äôs parameters are set appropriately in
order to ensure a ciphertext (with acceptable noise level) that de-
crypts correctly at the output of the circuit. However selecting
high parameters affect the size of the ciphertexts as well as the
time it takes to perform homomorphic operations. In this work we
investigate the use of both types of homomorphic cryptosystems
using TFHE [18] and BFV [20] with a special focus on TFHE. In
addition, both cryptosystems are LWE-based and can be efficiently
"thresholdized" as described in [8].

Even though our hash function construction is perfectly suited
for levelled HE such as BFV since it has a multiplicative depth of 0,
our SSLE solution should be able to support up to 200 participants
which would make the overall multiplicative depth become hard to
manage in a levelled scheme. Consequently, we chose to implement
our solution in TFHE which scales linearly to higher numbers of
participants with the expense of TFHE‚Äôs bootstrapping operation
after every Boolean gate.

4.2 Correctness

Proposition 4.1. Homomorphic Sortition ensures uniqueness.

Proof. First, let us show that in each round at most one process

can be elected.

Suppose there are more than one voucher for any given round.
These vouchers would have to be decrypted at some point, which
requires at least ùëõ ‚àí ùëì partial decryptions. Therefore, at least ùëì + 1
participants would have to have decrypted two vouchers, which is
a contradiction since at least one of the them must be correct and
honest processes only decrypt a single voucher per round in line
25.

Moreover, because the protocol computes the voucher specifi-
cally for a single user ùëñ by appending it to the proof ùúãùëñ and taking the
hash of the result, only process ùëñ can claim the voucher (assuming
the intractability of finding collisions of the hash function).

Now, let us prove that in each round there exists at least one

process that can claim the voucher.

In order to compute the proofs, all processes perform the same
deterministic computation in the homomorphic domain based on
the same information obtained from the consensus. Therefore, all
correct processes will compute the same vector of proofs inside the
ThFHE scheme, thereafter also computing the same voucher array.
All correct processes will then issue consistent partial decryptions
for the same voucher. By the construction of a voucher, the elected
process will be able to claim it with its ticket, reproducing the proof
‚ñ°
that was used to yield it.

Lemma 4.3. The values in the partial sum array ùëà are increasing.
ùêø[ùëñ] = 1 =‚áí ‚àÄùëó ‚â• ùëñ, ùêø[ ùëó] = 1.

Lemma 4.4. ùëôùëü = ùëùùëñ =‚áí ‚àÄùëó < ùëñ, ùêø[ ùëó] = 0.

Proposition 4.5. Homomorphic Sortition ensures fairness.

Proof. The variable ùëö keeps track of the total unselected stake
in the system. This variant is maintained by initialising it with the
total amount of stake (cid:205)ùëù ùëó ‚ààŒ† $ùëó and subtracting in the end of the
round the stake of the elected process in line 19.

The window of a process ùëùùëñ is the range of values [ùëà [ùëñ ‚àí1], ùëà [ùëñ])
for ùëñ ‚àà [2..ùëõ] and [0, ùëà [1]] for ùëñ = 1. Initially, the window of
every every process ùëùùëñ has length $ùëñ , by construction. At every
round ùëü , the length of the elected process‚Äô ùëù ùëó window becomes zero,
while the other processes‚Äô remain unchanged. This invariant holds
because the partial sum is updated by subtracting the elected stake
$ùëó from every position where ùêø = 1. This means that ùëà remains
unchanged in every position less than ùëó (c.f. Lemma 4.2), keeping the
corresponding processes windows unchanged, while for positions
greater than ùëó, both sides of the window are shifted by the same
amount (c.f. Lemma 4.2), conserving the length. As for the process
ùëù ùëó , the length of its window has been kept unchanged until it is
elected, following the previous reasoning. However, at round ùëü , the
lower end of its window is fixed, while the right is moved $ùëó to the
left, so its length becomes $ùëó ‚àí $ùëó = 0.

Since a process is selected when a uniform random number
between 0 and ùëö falls within its window, the probability of a pro-
cess being selected is the size of its window divided by the total
amount of unselected stake. For processes who have already been
elected this probability is therefore zero, while for the others ùëùùëñ it
‚ñ°
is

$ùëñ
(cid:205)ùëù ùëó ‚àà(Œ†\{ùëô1,...,ùëôùëü ‚àí1 }) $ùëó

Proposition 4.6. Homomorphic Sortition ensures unpredictabil-

ity.

Proof. We have already shown that our algorithm ensures fair-

ness with respect to the probability distribution

$ùëñ

P(ùêø‚Ñé,ùëê,ùëü = ùëùùëñ ) =

(cid:205)

$ùêø‚Ñé,ùëê,ùëü ‚Ä≤

ùëü ‚Ä≤ ‚àà [1...ùëü ‚àí1]

ùëù ùëó ‚ààŒ† $ùëó ‚àí (cid:205)
An adversary is able throughout the protocol to collect a subset of
{ùêª (ùúãùëñ ‚à• ùëó) : ùëó ‚àà [1, ùëê‚Ñé]} where ùëê‚Ñé is the number of executed cycles at
height ‚Ñé. We rely on the diffusion assumption of our hash function
construction from Section 3.6 i.e., a single bit flip in input flips about
half output bits. This assumption ensures that the adversary, within
the time between election and reveal, would not be able to guess
better than a guess on the original distribution. Also, this security
property is parameterised by the frequency of the Rand Trigger
operation, since tickets (and consequently proofs) are changed after
this operation, and thus, it becomes meaningless for an adversary
to mount an attack based on storing a table of multiple hash outputs
from inputs having a relatively small hamming distance from each
other.

The following three lemmata follow directly from the algorithm:

‚ñ°

Lemma 4.2.

Proposition 4.7. Homomorphic Sortition ensures termination.

10

Proof. Since the arrays ùëÉ and ùëÖ are shared among all correct
processes, as they are computed information given by the consensus
protocol, all of them will obtain the same values for ùëâ and will
sample the vouchers in the same order. Therefore, as the progress
of the individual processes is only halted for waiting these partial
decryptions and since there will always be at least ùë†ùë° ‚àí ùë†ùëì correct
shares of them, the decryption will always be successful and the
‚ñ°
protocol will always terminate.

4.3 Communication Complexity
Let us first analyse the Homomorphic Sortition protocol from a
distributed systems perspective, that is, by measuring the number
of message round trips necessary per cycle (time complexity) and
the number of words needed to be exchanged between processes
(communication complexity). The only messages exchanged in the
system are the partial decryption messages, which have all size
ùëÇ (ùúÜ2), where ùúÜ is the size of the hash function used, because each
bit is encrypted into ùúÜ bits. Therefore the latency of the sortition per
round is of one message delay and the number of words exchanged
in total is ùëÇ (ùëõ2ùúÜ2). Since each cycle has at most ùëõ rounds, the time
complexity is ùëÇ (ùëõ) and the communication complexity is ùëÇ (ùëõ3ùúÜ2)
per cycle.

4.4 Performance
The main performance bottleneck comes from the homomorphic
computations. Computing the hashes as mentioned in Section 3.6
allows to minimise the number of effective homomorphic opera-
tions. As for the sortition circuit, the main homomorphic operations
are: the multiplication of the random numbers by the total stake
(line 5); the computation of the ùêø vector (line 9) which is equivalent
to ùëõ homomorphic comparisons; the computation of the ùê∏ vector
which consists in ùëõ ‚àí 1 homomorphic evaluations of the and gate;
the selection circuit which is ùêµ √ó ùëõ evaluations of and gates, where
ùêµ is the bit-size of the selected element (a voucher and a partial
sum); finally the update of the list of partial sums of the stakes
(homomorphic substractions). So the complexity is parameterised
by ùëõ as well as the size of the data on which the homomorphic
operations are performed. The cost of these operations varies from
the use of Levelled FHE or the use of bootstrapping-based FHE
namely TFHE.

We ran the TFHE version of our circuit in a Intel(R) Xeon(R)

Gold 6154 CPU @ 3.00GHz machine with 72 cores.

5 RELATED WORK
Algorand. To the best of our knowledge, Gilad et al. [23] were the
first to apply a secret election protocol to protect the consensus
leader. In Algorand blockchain, two subsets of the users are selected:
one to participate in the committee of users that will agree on which
block should be appended and another (much smaller) to propose
blocks ‚Äì note that this is not a single leader election protocol. This
selection is known as cryptographic sortition and it uses verifiable
random functions (VRFs) [27] as follows: each user ùëñ possesses a
pair of public and private keys (ùëùùëòùëñ, ùë†ùëòùëñ ), respectively; each user
ùëñ can take the contents already published in the blockchain as a
seed and apply a VRF to (ùë†ùëíùëíùëë, ùë†ùëòùëñ ) generating a number ùë¶, which
is indistinguishable from random and unpredictable for other users,

speedup =

sequential time
parallel time

p
u
d
e
e
p
s

30

20

10

0

1 4 8

18

36

50

72

#threads

multiplication
comparison
select
hash
partial sum update
everything else
total

1.0

0.8

0.6

Figure 8: Performance on multicore machine.

0.4

0.0

0.0

0.2

and a proof ùúã. Any other participant ùëó can then accurately verify
that ùë¶ was generated with ùëâ ùëÖùêπ (ùë†ùëíùëíùëë, ùë†ùëòùëñ ) only by analysing seed, ùúã
and ùëùùëòùëñ and without having to know ùë†ùëòùëñ . The system defines global
thresholds so that each user whose random number complies with
the verification is considered as selected. In the section, the protocol
accounts the stake distribution so that the probability of selection is
proportional to it and because the sortition is done locally, only the
elected process knows its role before revealing it. Among potential
leaders, ties are broken using a deterministic function (e.g., the
minimal VRF output). Therefore, no participant can be sure that
she is a leader before every participant reveals its output.
SSLE in synchronous blockchains. Boneh et al. [6] formally de-
fined the problem of a single secret leader election (SSLE), [6] and
described three way of solve SSLE: Obfuscation [5, 22], Threshold
Fully Homomorphic Encryption (ThFHE) [7], and Shuffling [24]. The
first technique was not proposed to demonstrate theoretical feasibil-
ity of SSLE, while the other two were designed to be implemented
in practice.

0.2

0.4

In order to employ secret leader election in Ethereum [12], Azouvi
et al. [4] proposed a synchronous protocol which could be im-
plemented by paying 0.10$ in gas per leader election once de-
ployed in the targeted blockchain. In this approach, the proto-
col advances in rounds from 1 to roundùëöùëéùë• , with each partici-
pant creating a sequence of hashes (‚Ñé1, ‚Ñé2, ¬∑ ¬∑ ¬∑ , ‚Ñéroundùëöùëéùë• ) where
‚Ñéùëñ = ùêª (‚Ñéùëñ‚àí1), publicly committing ùêª (‚Ñéroundùëöùëéùë• ). Every round
round has a threshold targetround
and the processes generate to-
gether a common unpredictable random number ùëÖround . Any pro-
cess for which (‚Ñéround ‚äï ùëÖround ) < targetround
is declared a leader
of the round and can reveal its election by publishing ‚Ñéùëüùëúùë¢ùëõùëë . In

11

0.6

0.8

1.0

400

200

s
d
n
o
c
e
s

0

200

100

s
d
n
o
c
e
s

0

s
d
n
o
c
e
s

100

50

0

s
d
n
o
c
e
s

100

50

0

8

18

36

50

72

#threads ùëá (for ùëá ‚â• 8)
(ùëõ=100, |ùëÜ [ùëñ ] |=32, |ùêª |=256)

1020 40

80 100 120

200

250

#participants ùëõ
(ùëá =50, |ùëÜ [ùëñ ]|=32, |ùêª |=256)

16

20

24

32

stake size |ùë† [ùëñ ] |

(ùëá =50, ùëõ=100, |ùêª |=256)

32

64

128

256

hash size |ùêª |
(ùëá =50, ùëõ=100, |ùëÜ [ùëñ ] |=32)

everything else
partial sum update
hash
select
comparison
multiplication

Figure 9: Parameter scalability

this system any subset, including the empty set, of the participants
can be elected; if the system requires that at most one process is
elected, the processes can agree that the participant with the lowest
local hash among the elected is the leader.
Quantifying the gains of SSLE In subsequent work, Azouvi and
Cappelletti [3] performed an in-depth analysis of potential perfor-
mance gains of using SSLE. They compared protocols that elect
one leader on expectation (that is, some rounds might elect none or
several leaders) which are known as Probabilistic Leader Election ‚Äì
PLE ‚Äì with SSLE. They found that compared to PLE, SSLE reduces
the latency of block creation by 25% when the blockchain is under
a private attack. In this attack, the adversary creates its own private
chain in parallel, not sharing it with the rest of miners and trying
to seize the longest chain.
Secrecy of stakes. Ganesh et al. [21] formulated a variation on
traditional Proof-of-Stake called Private Proof-of-Stake (PPoS) where
the identities and stake of participants are not publicly available.
Their work focuses on implementations based on VRF functions and
shows how a participant can achieve the desired results by splitting
its stake into several virtual accounts and by using an anonymised
version of VRF (AVRF). In AVRF, proofs are still verifiable but have
the property that it is extremely hard to tell whether two proofs
have been created by the same secret key or not.
Clusters of secrecy. An interesting approach to the problem was
suggested by Tan et al. [32]. In their system, the processes are
organised in clusters, so that within a cluster, the identity of the
leader is known, but processes outside it can only state which
cluster contains the leader. In this manner, processes can choose
trustworthy nodes they wish to form a cluster and form a resilient
system using simple primitives relying only on local computations.
Post-Boneh synchronous protocols. Catalano et al. [17] built
upon [6] and proposed their own protocol using a cryptographic
primitive known as functional encryption [9][31] in which given a
ciphertext ùëê encrypting a keyword ùë§ and a secret key ùë†ùëò associated
to another keyword ùë§ ‚Ä≤, the decryption allows one to learn if ùë§ = ùë§ ‚Ä≤
and nothing more. Their SSLE protocol is based on the idea that for
every election a small committee of users generates a ciphertext
ùëê that encrypts a random keyword ùëó ‚àà {1, ¬∑ ¬∑ ¬∑ , ùëÅ }, every user is
given a secret key ùë†ùëòùëñ associated to an integer ùëñ, and can claim
victory by giving a non interactive zero knowledge (NIZK) proof
that they can decrypt the election‚Äôs ciphertext. They achieved a
protocol that allows stake slashing of misbehaving nodes and, if
executed whithout faults, the complexity of the protocol becomes
sublinear on the number of participants.

6 CONCLUSION AND FUTURE WORK
In this paper we introduced the SLS problem and described Homo-
morphic Sortition, an SLS protocol that can be seamlessly integrated
in blockchains built atop leader-based consensus protocols. To vali-
date the premises of our protocol, we implemented and measured
the performance of fully homomorphic circuits used in our construc-
tions. Our solution faithfully applies the PoS approach, maintaining
that the number of blocks created by a user are proportional to
the amount of her stake. We also showed how to compute hashes
more efficiently inside FHE schemes and how our protocol can be
pipelined.

12

0.0

0.2

0.4

0.6

0.8

1.0

0.04

0.02

0.00

-0.02

-0.04

[20]

Junfeng Fan and Frederik Vercauteren. 2012. Somewhat Practical Fully Homo-
morphic Encryption. IACR Cryptology ePrint Archive 2012 (2012), 144.

[21] Chaya Ganesh, Claudio Orlandi, and Daniel Tschudi. 2019. Proof-of-stake proto-
cols for privacy-aware blockchains. In Annual International Conference on the
Theory and Applications of Cryptographic Techniques. Springer, 690‚Äì719.
[22] Sanjam Garg, Craig Gentry, Shai Halevi, Mariana Raykova, Amit Sahai, and
Brent Waters. 2016. Candidate indistinguishability obfuscation and functional
encryption for all circuits. SIAM J. Comput. 45, 3 (2016), 882‚Äì929.

[23] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zel-
dovich. 2017. Algorand: Scaling byzantine agreements for cryptocurrencies. In
Proceedings of the 26th symposium on operating systems principles. 51‚Äì68.
Johan H√•stad. 2006. The square lattice shuffle. Random Structures and Algorithms
29, 4 (2006), 466‚Äì474.

[24]

[25] Leslie Lamport. 1998. The Part-Time Parliament. ACM Trans. Comput. Syst. 16, 2

(1998), 133‚Äì169.

[26] Martin Martin √Ögren, Martin Hell, Thomas Johansson, and Willi Meier. 2011.
Grain-128a: a new version of Grain-128 with optional authentication. Interna-
tional Journal of Wireless and Mobile Computing 5, 1 (2011), 48‚Äì59.

[27] Silvio Micali, Michael Rabin, and Salil Vadhan. 1999. Verifiable random functions.
In 40th annual symposium on foundations of computer science (cat. No. 99CB37039).
IEEE, 120‚Äì130.

[28] Pierrick M√©aux, Anthony Journault, Fran√ßois-Xavier Standaert, and Claude Car-
let. 2016. Towards Stream Ciphers for Efficient FHE with Low-Noise Ciphertexts.
Cryptology ePrint Archive, Report 2016/254. https://ia.cr/2016/254.

[29] Satoshi Nakamoto. 2008. Bitcoin: A peer-to-peer electronic cash system. Decen-

tralized Business Review (2008), 21260.

[30] NIST. 2021. Lightweight Cryptography Standardization. https://csrc.nist.gov/

News/2021/lightweight-crypto-finalists-announced.

[31] Adam O‚ÄôNeill. 2010. Definitional Issues in Functional Encryption. IACR Cryptol.

ePrint Arch. 2010 (2010), 556.

[32] Teik Guan Tan, Vishal Sharma, and Jianying Zhou. 2020. Right-of-Stake: de-
terministic and fair blockchain leader election with hidden leader. In 2020 IEEE
International Conference on Blockchain and Cryptocurrency (ICBC). IEEE, 1‚Äì9.

In future work, we envision a solution for the SLS problem rely-
ing on Decisional Diffie-Hellman (DDH) assumption and random
shuffles, similar to Boneh et al. [6] that can be implemented in par-
tial synchrony, as well as integrating our protocol to Tendermint
and making it public.

Finally, our current hash computation appears to suit better BFV
executions, executing it within the TFHE scheme can be more expen-
sive. An interesting question is whether we can use of a combination
of several Ring-LWE-based homomorphic encryption schemes as
proposed in Chimera [10]. This would allow us to switch from BFV
(in which the hash computation is more affordable) to TFHE for
which the rest of the circuits required by the homomorphic sortition
are more efficient.

REFERENCES
[1] Lacramioara Astefanoaei, Pierre Chambart, Antonella Del Pozzo, Thibault Rieu-
tord, Sara Tucci Piergiovanni, and Eugen Zalinescu. 2021. Tenderbake - A
Solution to Dynamic Repeated Consensus for Blockchains. In 4th International
Symposium on Foundations and Applications of Blockchain, FAB 2021. 1:1‚Äì1:23.
[2] Pascal Aubry, Sergiu Carpov, and Renaud Sirdey. 2020. Faster homomorphic en-
cryption is not enough: improved heuristic for multiplicative depth minimization
of Boolean circuits. In CT-RSA. 345‚Äì363.

[3] Sarah Azouvi and Daniele Cappelletti. 2021. Private Attacks in Longest Chain
Proof-of-Stake Protocols with Single Secret Leader Elections. Association for Com-
puting Machinery, New York, NY, USA, 170‚Äì182. https://doi.org/10.1145/3479722.
3480996

[4] Sarah Azouvi, Patrick McCorry, and Sarah Meiklejohn. 2018. Winning the
caucus race: Continuous leader election via public randomness. arXiv preprint
arXiv:1801.07965 (2018).

[5] Boaz Barak, Oded Goldreich, Russell Impagliazzo, Steven Rudich, Amit Sahai,
Salil Vadhan, and Ke Yang. 2012. On the (im) possibility of obfuscating programs.
Journal of the ACM (JACM) 59, 2 (2012), 1‚Äì48.

[6] Dan Boneh, Saba Eskandarian, Lucjan Hanzlik, and Nicola Greco. 2020. Single
secret leader election. In Proceedings of the 2nd ACM Conference on Advances in
Financial Technologies. 12‚Äì24.

[7] Dan Boneh, Rosario Gennaro, Steven Goldfeder, Aayush Jain, Sam Kim, Peter MR
Rasmussen, and Amit Sahai. 2018. Threshold cryptosystems from threshold
fully homomorphic encryption. In Annual International Cryptology Conference.
Springer, 565‚Äì596.

[8] Dan Boneh, Rosario Gennaro, Steven Goldfeder, Aayush Jain, Sam Kim, Peter
M. R. Rasmussen, and Amit Sahai. 2017. Threshold Cryptosystems From Thresh-
old Fully Homomorphic Encryption. Cryptology ePrint Archive, Report 2017/956.
https://ia.cr/2017/956.

[9] Dan Boneh, Amit Sahai, and Brent Waters. 2011. Functional encryption: Defini-
tions and challenges. In Theory of Cryptography Conference. Springer, 253‚Äì273.
[10] Christina Boura, Nicolas Gama, Mariya Georgieva, and Dimitar Jetchev.
2018. CHIMERA: Combining Ring-LWE-based Fully Homomorphic Encryption
Schemes. Cryptology ePrint Archive, Report 2018/758. https://ia.cr/2018/758.

[11] Ethan Buchman, Jae Kwon, and Zarko Milosevic. 2018. The latest gossip on BFT
consensus. CoRR abs/1807.04938 (2018). arXiv:1807.04938 http://arxiv.org/abs/
1807.04938

[12] Vitalik Buterin et al. 2014. A next-generation smart contract and decentralized

application platform. white paper 3, 37 (2014).

[13] Christophe De Canniere and Bart Preneel. 2004. Trivium. https://www.ecrypt.

eu.org/stream/triviumpf.html.

[14] Anne Canteaut, Sergiu Carpov, Caroline Fontaine, Tancr√®de Lepoint, Mar√≠a Naya-
Plasencia, Pascal Paillier, and Renaud Sirdey. 2016. Stream Ciphers: A Practical
Solution for Efficient Homomorphic-Ciphertext Compression. (2016).

[15] Sergiu Carpov, Pascal Aubry, and Renaud Sirdey. 2017. A multi-start heuristic
for multiplicative depth minimization of boolean circuits. In IWOCA. 275‚Äì286.
[16] Miguel Castro, Barbara Liskov, et al. 1999. Practical byzantine fault tolerance. In

OSDI, Vol. 99. 173‚Äì186.

[17] Dario Catalano, Dario Fiore, and Emanuele Giunta. 2021. Efficient and Universally
Composable Single Secret Leader Election from Pairings. Cryptology ePrint
Archive, Report 2021/344. https://eprint.iacr.org/2021/344.
Ilaria Chillotti, Nicolas Gama, Mariya Georgieva, and Malika Izabach√®ne. 2018.
TFHE: Fast Fully Homomorphic Encryption over the Torus. Cryptology ePrint
Archive, Report 2018/421. https://eprint.iacr.org/2018/421.

[18]

[19] Tyler Crain, Christopher Natoli, and Vincent Gramoli. 2021. Red Belly: a secure,
fair and scalable open blockchain. In Proceedings of the 42nd IEEE Symposium on
Security and Privacy (S&P‚Äô21).

13

