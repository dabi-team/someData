2
2
0
2

r
p
A
9
1

]

C
D
.
s
c
[

1
v
0
7
6
8
0
.
4
0
2
2
:
v
i
X
r
a

Basilic: Resilient Optimal Consensus Protocols
With Benign and Deceitful Faults

Alejandro Ranchal-Pedrosa
University of Sydney

Sydney, Australia

Vincent Gramoli
University of Sydney

Sydney, Australia

alejandro.ranchalpedrosa@sydney.edu.au

vincent.gramoli@sydney.edu.au

Abstract

The problem of Byzantine consensus has been key to designing secure
distributed systems. However, it is particularly diﬃcult, mainly due to
the presence of Byzantine processes that act arbitrarily and the unknown
message delays in general networks. Although it is well known that both
safety and liveness are at risk as soon as n/3 Byzantine processes fail,
very few works attempted to characterize precisely the faults that produce
safety violations from the faults that produce termination violations.

In this paper, we present a new lower bound on the solvability of
the consensus problem by distinguishing deceitful faults violating safety
and benign faults violating termination from the more general Byzantine
faults, in what we call the Byzantine-deceitful-benign fault model. We
show that one cannot solve consensus if n ≤ 3t + d + 2q with t Byzantine
processes, d deceitful processes, and q benign processes.

In addition, we show that this bound is tight by presenting the Basilic
class of consensus protocols that solve consensus when n > 3t + d + 2q.
These protocols diﬀer in the number of processes from which they wait to
receive messages before progressing. Each of these protocols is thus better
suited for some applications depending on the predominance of benign or
deceitful faults.

Finally, we study the fault tolerance of the Basilic class of consensus
protocols in the context of blockchains that need to solve the weaker prob-
lem of eventual consensus. We demonstrate that Basilic solves this prob-
lem with only n > 2t + d + q, hence demonstrating how it can strengthen
blockchain security.

1 Introduction

The problem of Byzantine consensus has been key to designing secure dis-
tributed systems [42, 17, 24, 31]. This problem is particularly diﬃcult to solve
because a Byzantine participant acts arbitrarily [28] and message delays are
generally unpredictable [22]. Any consensus protocol would fail in this general

1

 
 
 
 
 
 
setting if the number of Byzantine participants is t ≥ n/3 [22], where n is the
total number of participants. In some executions, ⌈n/3⌉ Byzantine participants
can either prevent the termination of the consensus protocol by stopping or
by sending unintelligible messages. In other executions, ⌈n/3⌉ can violate the
agreement property of the consensus protocol by sending conﬂicting messages.
Interestingly, various research eﬀorts were devoted to increase the fault toler-
ance of consensus protocols in closed networks (e.g., datacenters) by distinguish-
ing the type of failures [17, 24, 31, 32]. Some works overcome the t < n/3 bound
by tolerating a greater number of omission than commission faults [42, 17].
These works are naturally well-suited for closed networks where processes are
protected from intrusions by a ﬁrewall: their processes are supposedly more
likely to crash than to be corrupted by a malicious adversary. In this sense,
these protocols favor tolerating a greater number of faults for liveness than for
safety.

Unfortunately, fewer research eﬀorts were devoted to explore the fault tol-
erance of consensus protocols in open networks (e.g., blockchains). In such set-
tings, participants are likely to cause a disagreement if they can steal valuable
assets. This is surprising given that attacks are commonplace in blockchain sys-
tems as illustrated by the recent losses of $70, 0001 and $18 million2 in Bitcoin
Gold, and of $5.6 million in Ethereum Classic3. Comparatively, some blockchain
participants, called miners, are typically monitored continuously so as to ensure
they provide some rewards to their owners, hence making it less likely to pre-
vent termination. To our knowledge, only alive-but-corrupt (abc) processes [35]
characterize the processes that violate consensus safety. Unfortunately, abc pro-
cesses are restricted to only try to cause a disagreement if the coalition size is
suﬃciently large to succeed at the attempt, which is impossible to predict in
blockchain systems.

1.1 Our Results

In this paper, we present a new lower bound on the solvability of the Byzan-
tine consensus problem by precisely exploring these two additional types of
faults (that either prevent termination or agreement when t ≥ n/3). Our lower
bound states that there is no protocol solving consensus in the partially syn-
chronous model [22] if n ≤ 3t + d + 2q with t Byzantine processes, d deceitful
processes, and q benign processes. These diﬀerent types of processes deﬁne the
Byzantine-deceitful-benign (BDB) failure model and are characterized by the
faults they commit. First, a deceitful process is a process that sends some con-
ﬂicting messages (messages that contribute to a violation of agreement) during
its execution. Second, a benign process is a faulty process that never sends any
conﬂicting messages, contributing to non-termination. For example, a benign
process can crash or send stale messages, or even equivocate as long as its mes-
sages have no eﬀect on the agreement property. These two faults lie at the core

1https://news.bitcoin.com/bitcoin-gold-51-attacked-network-loses-70000-in-double-spends/
2https://news.bitcoin.com/bitcoin-gold-hacked-for-18-million/
3https://news.bitcoin.com/5-6-million-stolen-as-etc-team-ﬁnally-acknowledge-the-51-attack-on-network/

2

of the consensus problem, as the property of validity can be locally checked for
correctness by correct process, while termination and agreement can be violated
in the presence of enough malicious processes.Compared to abc faults, we do not
impose the restriction on deceitful processes to know whether their attack will
succeed. This means that while a protocol might tolerate d < n/3 abc faults
along with q < n/3 benign faults, it would not necessarily tolerate d < n/3 de-
ceitful faults along with q < n/3 benign faults. The contrary direction however
always hold.

Furthermore, we show that this lower bound is tight, in that we present the
Basilic4 class of protocols that solves consensus with n > 3t + d + 2q. Basilic
builds upon recent advances in the context of accountability [14] by taking into
account key messages only if they are cryptographically signed by their sender.
If they are properly signed, the recipient stores these messages and progresses
in the consensus protocol execution. Recipients also cross-check the messages
they received with other recipients, based on the assumption that signatures
cannot be forged. Once conﬂicting messages are detected, they constitute an
undeniable proof of fraud to exclude the faulty sender before continuing the
protocol execution. Thanks to this exclusion, Basilic satisﬁes a new property,
active accountability, which guarantees that deceitful processes can not prevent
termination.

Basilic is a class of consensus protocols, each parameterized by a diﬀerent
voting threshold or the number of distinct processes from which a process re-
ceives messages in order to progress. For a voting threshold of h ∈ (n/2, n],
Basilic satisﬁes termination if h ≤ n − q − t, and agreement if h > d+t+n
. This
means that for just one threshold, say h = 2n/3, Basilic tolerates multiple com-
binations of faulty processes: it can tolerate t < n/3, q = 0 and d = 0; but also
t = 0, q < n/3 and d < n/3; or even t < n/6, q < n/6 and d < n/6. This voting
threshold can be modiﬁed by an application in order to tolerate any combina-
tion of t Byzantine, d deceitful and b benign processes satisfying n > 3t + d + 2q.
The generalization of Basilic to any voting threshold h thus allows us to pick
the best suited protocol depending on the application requirements. If, on the
one hand, the application runs in a closed network (e.g., datacenter) dominated
by benign processes, then the threshold will be lowered to ensure termination.
If, on the other hand, the application runs in an open network (e.g., blockchain)
dominated by deceitful processes, then the threshold will be raised to ensure
agreement.

2

We illustrate in Figure 1 the new resilient optimal bounds that Basilic toler-
ates if there are only deceitful and benign processes (i.e., for t = 0), compared
to the classic Byzantine fault-tolerant (BFT) bound [22]. We prove that these
bounds are resilient optimal in the Byzantine-deceitful-benign failure model.
We observe that compared to state-of-the-art accountable consensus protocols,
Basilic satisﬁes active accountability and tolerates a greater number of faults,
while maintaining the same time, message and bit complexities in synchronous

4The name “Basilic” is inspired from the Basilic cannon that Ottomans used to break
through the walls of Constantinople. Much like the cannon, our Basilic protocol provides a
tool to break through the classical bounds of Byzantine fault tolerance.

3

n

Impossibibility of consensus
BDB consensus
BFT consensus

s
e
s
s
e
c
o
r
p

2n/3

i

n
g
n
e
b

f
o

n
o
i
t
c
a
r
F

n/2

n/3

0

0

n/2
Fraction of deceitful processes

2n/3

n/3

n

Figure 1: The green area represents the bound for BFT consensus, where t <
n/3 and thus the same for d, q, i.e., d + q < n/3. The orange area is the new
fault tolerance in the Byzantine-deceitful-benign (BDB) failure model, where
d < n − 2q and q < n/2 (for t = 0). In blue, the area where it is impossible to
solve consensus in the BDB model.

periods.

Finally, we show that our impossibility results can be bypassed when con-
sidering a weaker variant of the consensus problem particularly appealing for
blockchains, called the eventual consensus problem [21] and denoted the 3-
consensus problem. We show that the Basilic class of protocols also solves
3-consensus when n > 2t + d + q, which improves our previous impossibility
results by a t and q additive factors. We refer to the variant of Basilic that
solves both consensus and 3-consensus as 3-Basilic. In particular, given a vot-
ing threshold h that deﬁnes a protocol σ from within the 3-Basilic class, then
σ solves 3-consensus if d + t < h for safety and h ≤ n − q − t for liveness.

1.2 Roadmap

The rest of the paper is structured as follows. In Section 2, we present the model
and deﬁne the problem. In Section 3, we present our impossibility result in the
Byzantine-deceitful-benign model while we prove that Basilic protocol solves
the consensus problem in Section 4 and analyze its complexities in Section 5. In
Section 6, we introduce and prove Basilic’s bounds for the eventual consensus
problem. Finally, we present the related work in Section 7, and we ﬁnally
conclude in Section 8.

4

 
 
 
2 Model & Problem

We consider a committee as a set N = {p0, ..., pn−1} of |N | = n processes. These
processes communicate in a partially synchronous network, meaning there is a
known bound ∆ on the communication delay that will hold after an unknown
Global Stabilization Time (GST) [22]. Processes communicate through standard
all-to-all reliable and authenticated communication channels [27], meaning that
messages can not be duplicated, forged or lost, but they can be reordered.

Cryptography We assume a public-key infrastructure (PKI) in which each
party has a public key and a private key, and any party’s public key is known
to all [44]. As with other protocols that use this standard assumption [44, 1],
we do not require the use of revocation lists (we will remove processes from the
committee, but not from their keys from the PKI). We refer to λ as the secu-
rity parameter, i.e., the number of bits of the keys. As our claims and proofs
require cryptography, they hold except with ǫ(λ) negligible probability [4]. We
formalize negligible functions measured in the security parameter λ, which are
those functions that decrease asymptotically faster than the inverse of any poly-
nomial. Formally, a function ǫ(κ) is negligible if for all c > 0 there exists a κ0
such that ǫ(κ) < 1/κc for all κ > κ0 [4].

Consensus A protocol executed by a committee of processes solves the con-
sensus problem if the following three properties are satisﬁed by the protocol:

• Termination. Every non-faulty process eventually decides on a value.

• Agreement. No two non-faulty processes decide on diﬀerent values.

• Validity.

If all non-faulty processes propose the same value, no other

value can be decided.

Conﬂicting messages
In order to detect faulty processes, these have to send
distinct messages to diﬀerent processes where they were expected to broadcast
the same message to diﬀerent processes [2], we refer to these messages as con-
ﬂicting. Given a protocol σ, we say that a message, or set of messages, m sent
by process p conforms to an execution σE of the protocol σ, if σE belongs to the
set of all possible executions where p sent m and p is a non-faulty process. Also,
a faulty process p sending two messages m, m′ contributes to a disagreement if
there is an execution σE of σ such that (i) suﬃciently many faulty processes
sending m, m′ (and possibly more messages) to a disjoint subset of non-faulty
processes, one to each, leads to a disagreement, and (ii) σE does not lead to
a disagreement without p sending m, m′. Two messages m, m′ are conﬂicting
with respect to σ if:

1. m, m′ individually conform to algorithm σ for some execution σE, σE′ ,

respectively, σE 6= σE′ ,

5

2. there is no execution σE′′ of σ such that both messages together conform

to σE′′ , and

3. if p sending m, m′ to a disjoint subset of non-faulty processes, one to each,

contributes to a disagreement.

When combined in one message and signed by the sender, conﬂicting mes-
sages constitute a proof of a process being faulty with the purpose of causing a
disagreement. We speak of this proof as a proof-of-fraud (PoF). An example of
two conﬂicting messages is a faulty process sending two diﬀerent proposals for
the same round (the proposer should only propose one value per round).

Our deﬁnition of conﬂicting messages diﬀers from previous similar concepts
in that conﬂicting messages allow for any process p to verify if two messages
are conﬂicting: a non-faulty process can always construct a PoF from two con-
ﬂicting messages alone, but it cannot do so with all mutant messages [25], as
p would need to also learn the entire execution, or with messages sent from an
equivocating process [16], as these do not necessarily contribute to disagreeing.

Send, receive and deliver. Messages can be sent and received, but we also
consider broadcast primitives that contain two functions: a broadcast function
that allows process pi to send messages to multiple channels accross the network,
and a deliver function that is invoked at the very end of the broadcast primitive
to indicate that the recipient of the message has received and processed the
message to be sent. There could be however multiple message exchanges before
the delivery can happen. As we will specify some of these broadcast primitives,
we attach the name of the protocol as a preﬁx to the broadcast and deliver
function to refer to a message broadcast or delivered using that protocol, such
as AARB-broadcast, AARB-deliver, ABV-broadcast and ABV-deliver, as we
detail later in this paper.

Fault model There are three mutually exclusive classes of faulty processes:
Byzantine, deceitful and benign [38], in what we refer to as the Byzantine-
deceitful-benign (BDB) failure model. Each faulty process belongs to only one
of these classes. Byzantine, deceitful and benign processes are characterized by
the faults they can commit. A fault is deceitful if it contributes to breaking
agreement, in that it sends conﬂicting messages violating the protocol in order
to lead two or more partitions of processes to a disagreement. We allow deceitful
processes to constantly keep sending conﬂicting messages, even if they do not
succeed at causing a disagreement, but instead their deceitful behavior prevents
termination. As deceitful processes model processes that try to break agreement,
we assume also that a deceitful fault does not send conﬂicting messages for
rounds or phases of the protocol that it has already terminated at the time
that it sends the messages. Deceitful processes can alternate between sending
conﬂicting messages and following the protocol, but cannot deviate in any other
way. A benign fault is any fault that does not ever send conﬂicting messages.

6

Hence, benign faults cover only faults that can break termination, e.g. by
crashing, sending stale messages, etc.

As usual, Byzantine processes can act arbitrarily. Thus, Byzantine processes
can commit benign or deceitful faults, but they can also commit faults that are
neither deceitful nor benign. A fault that sends conﬂicting messages and crashes
afterwards is, by these deﬁnitions, neither benign nor deceitful. We denote t, d,
and q as the number of Byzantine, deceitful, and benign processes, respectively.
We assume that the adversary is static, in that the adversary can choose up
to t Byzantine, d deceitful and q benign processes at the start of the protocol,
known only to the adversary.

In order to distinguish benign (resp. deceitful) processes from Byzantine pro-
cesses that commit a benign (resp. deceitful) fault during a particular execution
of a protocol, we formalize fault tolerance in the BDB model. Let Eσ(t, d, q)
denote the set of all possible executions of a protocol σ given that there are up
to t Byzantine, d deceitful and q benign processes. We say that a protocol σ for
a particular problem P is (t, d, q)-fault-tolerant if σ solves P for all executions
σE ∈ Eσ(t, d, q). We abuse notation by speaking of a (t, d, q)-fault-tolerant pro-
tocol σ as a protocol that tolerates t, d and q Byzantine, deceitful and benign
processes, respectively.

Note that, given a protocol σ, then Eσ(0, d+k, q) ⊂ Eσ(k, d, q) by deﬁnition.
Thus, if σ is (k, d, q)-fault-tolerant then σ is (0, d + k, q)-fault tolerant, and
also (0, d, q + k)-fault-tolerant. However, the contrary is not necessarily true:
a protocol σ that is (0, d + k, q)-fault-tolerant is not necessarily (k, d, q)-fault
tolerant, as Eσ(k, d, q) * Eσ(0, d + k, q), because Byzantine participants can
commit more faults than deceitful or benign. Finally, a process is non-faulty if
it is neither Byzantine, nor deceitful, nor benign. Non-faulty processes follow
the protocol.

Compared to commission and omission faults, notice that not all commis-
sion faults contribute to causing disagreements. For example, some commission
faults broadcast an invalid message that can be discarded. In our BDB model,
this type of fault would categorize as benign, and not deceitful, since invalid
messages never contribute to a disagreement, but can instead prevent termina-
tion (by only sending invalid messages that are discarded). All omission faults
are however benign faults, while the contrary is also not true (as per the same
aforementioned example). Compared to the alive-but-corrupt failure model, de-
ceitful faults are not restricted to only contribute to a disagreement if they know
the disagreement will succeed, but instead we let them try forever, even if they
do not succeed. Also, the alive-but-corrupt failure model does not deﬁne benign
faults.

We believe thus the BDB model to be better-suited for consensus, as it
establishes a clear diﬀerence in the types of faults depending on the type of
property that the fault jeopardizes (agreement for deceitful, termination for
benign), without restricting the behavior of these faults to the cases where they
are certain that they will cause a disagreement.

7

3 Impossibility Results

In this section, we extend Dwork et al.’s impossibility results [22] on the num-
ber of processes necessary to solve the Byzantine consensus problem with par-
tial synchrony by adding deceitful and benign processes. First, we prove in
Section 3.1 lower bounds on the size of the committee of any consensus proto-
col. Then, we prove in Section 3.2 some lower bounds depending on the voting
threshold of that protocol, which we deﬁne in the same section.

3.1

Impossibility of consensus in the BDB model

First, we consider the case where t = 0, i.e., there are only deceitful and benign
processes. In particular, we show in Lemma 3.1 that if a protocol solves consen-
sus then it tolerates at most d < n − 2q deceitful processes and q < n/2 benign
processes. The intuition for the proof is the same from the classical impossibil-
ity proof of consensus in partial synchrony in the presence of t0 + 1 Byzantine
processes. Lemma 3.1 extends the the BDB model the classical lower bound for
the BFT model [22], by tolerating a stronger adversary than the classical bound
(e.g. an adversary causing d = ⌈n/3⌉ − 1 deceitful faults and q = ⌈n/3⌉ − 1
benign faults). By contradiction, we show that in the presence of a greater
number of faulty processes than bounded by Lemma 3.1, in some executions all
processes would either not terminate, or not satisfy agreement, if maintaining
validity.

Lemma 3.1. Let a protocol σ and let σ solve consensus for all executions
σE ∈ Eσ(0, d, q) for some d, q > 0. Then, d < n − 2q and q < n/2.

Proof. First, we show q < n/2 by contradiction, as done by previous work for
omission faults [22]. Suppose q ≥ n/2, d = 0 and consider processes are divided
into a disjoint partition P, Q such that P contains between 1 and q processes
and Q contains n − |P |. First, consider scenario A: all processes in P are benign
and the rest correct, and all processes in Q propose value 0. Then, by validity
all processes in Q decide 0. Then, consider scenario B: all processes in Q are
benign and the rest correct, and all processes in P propose value 1. Then, by
validity all processes in P decide 1. Now consider scenario C: no process is
benign, and processes in P propose all 0 while processes in Q propose all value
1. For processes in P scenario C is indistinguishable from scenario A, while for
processes in Q scenario B is indistinguishable from scenario A. This yields a
contradiction.

It follows that q < n/2. Hence, for n = 2, and since q < 1, it is immediate
that for d ≥ 2 it is impossible to solve consensus. As such, we have left to
consider d ≥ n − 2q with n ≥ 3. We will prove this by contradiction.

Consider processes are divided into three disjoint partitions P, Q, R, such
that P and Q contain between 1 and q processes each, and R contains between
1 and d. First consider the following scenario A: processes in P and R are
non-faulty and propose value 0, and processes in Q are benign. It follows that
P ∪ R must decide value 0 at some time TA, for if they decided 1 there would

8

be a scenario in which processes in Q are non-faulty and also propose 0, but
messages sent from processes in Q are delivered at a time greater than TA,
having processes in P ∪ R already decided 1. This would break the validity
property. Also, they must decide some value to satisfy termination tolerating q
benign faults.

Consider now scenario B: processes in P are benign, and processes in R and
Q are non-faulty and propose value 1. By the same approach, R ∪ Q decide 1
at a time TB.

Now consider scenario C: processes in P and Q are non-faulty, and pro-
cesses in R are deceitful, the messages sent from processes in Q are delivered
by processes in P at a time greater than max(TA, TB), and the same for mes-
sages sent from processes in P to processes in Q. Then, for processes in P this
scenario is identical to scenario A, deciding 0, while for processes in Q this is
identical to scenario B, deciding 1, which leads to a disagreement. This yields
a contradiction.

Corollary 3.2 (Impossibility of consensus with t = 0). It is impossible for a
consensus protocol σ to tolerate d deceitful and q benign processes if d ≥ n − 2q
or q ≥ n/2.

Proof. This is immediate from Lemma 3.1 since σ is (0, d, q)-fault-tolerant if σ
solves P for all executions σE ∈ Eσ(0, d, q).

We prove the impossibility result of Theorem 3.3 by extending the result of
Corollary .26: it is impossible to solve consensus in the presence of t Byzantine,
q benign and d deceitful processes unless n > 3t + d + 2q.

Theorem 3.3 (Impossibility of consensus). It is impossible for a consensus
protocol to tolerate t Byzantine, d deceitful and q benign processes if n ≤ 3t +
d + 2q.

Proof. The proof is analogous to that of Lemma 3.1 since σ is (t, d, q)-fault-
tolerant if σ solves P for all executions σE ∈ Eσ(t, d, q), and Eσ(0, d + t, q) ∈
Eσ(t, d, q) and Eσ(0, d, q + t) ∈ Eσ(t, d, q) by deﬁnition. Thus, the bounds
in this case become d + t ≥ n − 2(q + t) and q + t ≥ n/2, which results in
n + t + d < 2n − 2q − 2t ⇐⇒ n > 3t + d + 2q.

3.2

Impossibility bounds per voting threshold

The proofs for the impossibility results of Section 3.1 (and for the classical im-
possibility results [22]) derive a trade-oﬀ between agreement and termination.
In some scenarios, processes must be able to terminate without delivering mes-
sages from a number of processes that may commit benign faults.
In other
scenarios, processes must be able to deliver messages from enough processes be-
fore terminating in order to make sure that no disagreement caused by deceitful
faults is possible. We prove in this section the impossibility results depending
on this trade-oﬀ.

9

A protocol that satisﬁes both agreement and termination in partial syn-
chrony must thus state a threshold that represents the number of processes
from which to deliver messages in order to be able to terminate without com-
promising agreement. If this threshold is either too small to satisfy agreement,
or too large to satisfy termination, then the protocol does not solve consensus.
We refer to this threshold as the voting threshold, and denote it with h. Typ-
ically, this threshold is h = n − t0 = ⌈ 2n
3 ⌉ − 1 Byzantine
faults [18, 14, 26, 45, 38]. We prove however in Lemma 3.4 and Corollary 3.5
that h > d+t+n

3 ⌉ to tolerate t0 = ⌈ n

with h ∈ (n/2, n] for safety.

2

Lemma 3.4 (Impossibility of Agreement (t = 0)). Let σ be a protocol with
voting threshold h ∈ (n/2, n] that satisﬁes agreement. Then σ tolerates at most
d < 2h − n deceitful processes.

Proof. The bound h ∈ (n/2, n] derives trivially:
if h ≤ n/2 then two sub-
sets without any faulty processes can reach the threshold for diﬀerent values
(Lemma 3.1). We calculate for which cases it is possible to cause a disagree-
ment. Hence, we have two disjoint partitions of non-faulty processes such that
|A| + |B| ≤ n − d. Suppose that processes in A and in B decide each a diﬀerent
decision vA, vB, vA 6= vB. This means that both |A|+d ≥ h and |B|+d ≥ h must
hold. Adding them up, we have |A| + |B| + 2d ≥ 2h and since |A| + |B| ≤ n − d
we have n + d ≥ 2h for a disagreement to occur. This means that if h > n+d
2
then it is impossible for d deceitful processes to cause a disagreement.

The proof of Lemma 3.4 can be straightforwardly extended to include Byzan-

tine processes, resulting in Corollary 3.5.

Corollary 3.5. Let σ be a protocol with voting threshold h ∈ (n/2, n] that
satisﬁes agreement. Then σ tolerates at most d + t < 2h − n deceitful and
Byzantine processes.

Next, in Lemma 3.6 and Corollary 3.7 we show the analogous results for
the termination property. That is, we show that if a protocol solves termination
while t = 0, then it tolerates at most q ≤ n − h benign processes, or q + t ≤ n − h
benign and Byzantine processes.

Lemma 3.6 (Impossibility of Termination (t = 0)). Let σ be a protocol with
voting threshold h that satisﬁes termination. Then σ tolerates at most q ≤ n − h
benign processes.

Proof. If n − q benign processes are less than h, then termination is not guar-
anteed, since in this case termination would require the votes from some benign
processes. This is impossible if h ≤ n − q, as it guarantees that the threshold is
lower than all processes minus the q benign processes.

Corollary 3.7. Let σ be a protocol with voting threshold h that satisﬁes termi-
nation. Then, σ tolerates at most q + t ≤ n − h benign and Byzantine processes.

10

Combining the results of corollaries 3.5 and 3.7, one can derive an impossi-
bility bound for a consensus protocol given its voting threshold. We show this
result in Corollary 3.8.

Corollary 3.8. Let σ be a protocol that solves the consensus problem with voting
threshold h ∈ (n/2, n]. Then, σ tolerates at most d+ t < 2h− n and q + t ≤ n− h
Byzantine, deceitful and benign processes.

9 for safety and q < 4n

We show in Figure 2 the threshold h to tolerate a number d of deceitful and
q of benign processes. For example, for a threshold h = ⌈ 5n
9 ⌉ − 1, we have that
d < n
9 for liveness, with t = 0. The maximum number of
Byzantine processes tolerated with d = q = 0 is the minimum of both bounds,
being for example t < n
9 ⌉ − 1. In the remainder of this paper, we
assume the adversary satisﬁes the resilient optimal bounds of h < n − q − t and
h > d+t+n
, given a particular voting threshold h. The result of Theorem 3.3
holds regardless of the voting threshold. Thus, a protocol that satisﬁes both
h < n − q − t and h > d+t+n
can set its voting threshold h ∈ (n/2, n] in order
to solve consensus for any combination of t Byzantine, q benign and d deceitful
processes, as long as n > 3t + d + 2q holds.

9 for h = ⌈ 5n

2

2

q<n/18

17n/18

q<n/9

q<n/6

q<n-h for liveness
d<2h-n for safety

d<8n/9

d<7n/9

d<2n/3

8n/9

5n/6

7n/97n/9

13n/18

2n/3

11n/18

l

d
o
h
s
e
r
h
t

g
n
i
t
o
V

q<2n/9
q<2n/9

d<5n/9
d<5n/9

q<5n/18

d<4n/9

d<n/3

q<n/3

d<2n/9

q<7n/18

d<n/9

5n/9

n/2

d=0

q<4n/9

q<n/2

0

n/9 2n/9 n/3 4n/9 5n/9 2n/3 7n/9 8n/9

n

Fraction of deceitful or benign processes

Figure 2: Number of deceitful processes d and benign processes q tolerated for
safety and liveness, respectively, per voting threshold h and with t = 0 Byzantine
processes.

4 The Basilic Protocol

In this section, we introduce the Basilic class of protocols, a class of resilient
optimal protocols that solve, for diﬀerent voting thresholds, the actively ac-
In particular, all protocols
countable consensus problem in the BDB model.

11

 
within the Basilic class tolerate t Byzantine, d deceitful and q benign processes
satisfying n > 3t + d + 2q, and, given a particular protocol σ(h) of the class
uniquely deﬁned by a voting threshold h ∈ (n/2, n], then σ(h) tolerates a num-
ber n of processes satisfying d + t < 2h − n and q + t ≤ n − h. In this section,
we ﬁrst need to introduce few assumptions and deﬁnitions in Section 4.1. Sec-
ond, we present the overview of the Basilic protocol in Section 4.2, and show its
components in sections 4.4, 4.5, and 4.3.

4.1 Additional Assumptions

Adversary In order to limit the computational power of processes to prevent
the adversary from forging keys, we model processes as probabilistic polynomial-
time interactive Turing machines (ITMs) [33, 10, 9]. A process is an ITM deﬁned
by the following protocol: it is activated upon receiving an incoming message to
carry out some computations, update its states, possibly generate some outgoing
messages, and wait for the next activation. The adversary A is a probabilistic
ITM that runs in polynomial time (in the number of message bits generated by
non-faulty processes).

Actively accountable consensus problem The accountable consensus prob-
lem [14] includes the property of accountability in order to provide guarantees
in the event that deceitful and Byzantine processes manage to cause a disagree-
ment. This property is however insuﬃcient for the purpose of Basilic. We need
an additional property that identiﬁes and removes all deceitful behavior that
prevents termination. Faulty processes can break agreement in a ﬁnite number
of conﬂicting messages, but once they send a pair of these conﬂicting messages,
they leave a trace that can result in their exclusion from the system. Our goal is
to exploit this trace to make sure that deceitful processes cannot contribute to
breaking liveness. As a result, we include the property of active accountability,
stating that deceitful faults do not prevent termination of the protocol.

Deﬁnition 1 (Actively accountable consensus problem). A protocol σ with vot-
ing threshold h solves the actively accountable consensus problem if the following
properties are satisﬁed:

• Termination. Every non-faulty process eventually decides on a value.

• Validity.

If all non-faulty processes propose the same value, no other

value can be decided.

• Agreement. If d + t < 2h − n then no two non-faulty processes decide

on diﬀerent values.

• Accountability. If two non-faulty processes output disagreeing decision
values, then all non-faulty processes eventually identify at least 2h − n
faulty processes responsible for that disagreement.

• Active accountability. Deceitful behavior does not prevent liveness.

12

We generalise the previous deﬁnition of accountability [14] by including the
voting threshold h. That is, the previous deﬁnition of accountability is the one
we present in this work for the standard voting threshold of h = 2n/3.

4.2 Basilic Internals

Basilic is a class of consensus protocols, all these protocols follow the same pseu-
docode (Algorithms 2–1) but diﬀer by their voting threshold h ∈ (n/2, n]. The
structures of these protocols follow the classic reduction [5] from the consensus
problem, which accepts any ordered set of input values, to the binary consensus
problem, which accepts binary input values.

Basilic Overview More speciﬁcally, Basilic has at its core the binary con-
sensus protocol called actively accountable binary consensus or AABC for short
(Alg. 2–3) and presented in Section 4.4. We show in Figure 3 an example ex-
ecution with n = 4 processes in the committee. First each process pi selects
their input value vi, which they share with everyone executing an instance of
a reliable broadcast protocol called actively accountable reliable broadcast or
AARB for short. Then, processes executed one instance AABCi of the binary
consensus protocol to decide whether to select their associated input value from
process pi. Finally, processes locally process the minimum input value from the
values whose associated AABC instance output 1.

This Basilic binary consensus protocol shares similarities with Polygraph [15],
as it also detects guilty processes, but goes further, by excluding these detected
processes and adjusting its voting threshold at runtime to solve consensus even
in cases where Polygraph cannot (n/3 ≤ t + q + d < n). We summarize the
comparison of Basilic with the state of the art in Table 2. Finally, the rest of
the reduction is depicted in Alg. 1 and invokes n actively accountable reliable
broadcast instances or AARB (Alg. 4) and described in Section 4.5, followed by
n of the aforementioned AABC instances.

Certiﬁcates and transferable authentication Basilic uses certiﬁcates in
order to validate or discard a message, and also to detect deceitful processes
by cross-checking certiﬁcates. A certiﬁcate is a list of previously delivered and
signed messages that justiﬁes the content of the message in which the certiﬁcate
is piggybacked. Thus, non-faulty processes perform transferable authentica-
tion [16]. That is, process pi can deliver msg from pj by verifying the signature
of msg, even if msg was received from pk, for k 6= i 6= j.

Detected deceitful processes A key novelty of Basilic is to remove detected
deceitful processes from the committee at runtime. For this reason, we refer to dr
as the number of detected deceitful processes, and deﬁne a voting threshold h(dr)
that varies with the number of detected deceitful processes. Therefore, processes
start Basilic with an initial voting threshold h(dr = 0) = h0, e.g., h0 = ⌈ 2n
3 ⌉,
but then update the threshold by removing detected deceitful processes, i.e.

13

reliably broadcast proposals

binary consensus decisions

bitmask and associated bits

decide one

Basilic’s multi-valued consensus

p0 : v0
p1 : v1
p2 : v2
p3 : v3

AARB0 : v0
AARB1 : v1
AARB2 : v2
AARB3 : v3

AABC0 : 1
AABC1 : 0
AABC2 : 1
AABC3 : 0

{v0 : 1, v1 : 0, v2 : 1, v3 : 0}

min(v0, v2)

v0

Figure 3: Basilic execution example for a committee of n = 4. First, each
process pi selects their input value vi, which they share with everyone execut-
ing their respective instance AARBi of AARB. Then, processes executed one
instance AABCi of the binary consensus protocol to decide whether to select
their associated input value from process pi. Finally, processes locally process
the minimum input value from the values whose associated AABC instance
output 1.

h(dr) = h0−dr. This way, detected deceitful processes break neither liveness nor
safety, as we will show. Certiﬁcates must always contain h(dr) signatures from
distinct processes justifying the message (after ﬁltering out up to dr signatures
from detected deceitful processes), or else they will be discarded. Recall that the
adversary is thus constrained to the bounds from Corollary 3.8 depending on the
voting threshold. As Basilic uses a threshold that updates at runtime starting
from an initial threshold h(dr) = h0 − dr, we restate these bounds applied to
the initial threshold h0 ≤ n − q − t and h0 > d+t+n
, or to the updated threshold
of h(dr) < n − q − t − dr and h(dr) > d+t+n
2 − dr.

2

4.3 The General Basilic Protocol

We bring together the n instances of the AABC binary consensus protocol with
the n instances of the AARB reliable broadcast protocol in Algorithm 1, where
we show the general Basilic protocol. The protocol derives from Polygraph’s
general protocol [12, 14], which in turn derives from DBFT’s multi-valued con-
sensus protocol [18].

Non-faulty processes ﬁrst start the AARB protocol for which they are the
source by proposing a value in line 2. Delivered proposals are stored in an
array proposals at the index corresponding to the source of the proposal. A
binary consensus at index k is started with input value 1 for each index k
where a proposal has been recorded (line 6). Notice that we can guarantee to
decide 1 on at most h(dr) proposals (line 7), where dr can be up to d, meaning
that, for the standard threshold h(dr) = ⌈ 2n
3 ⌉ − dr, the maximum number of
decided proposals is ⌈ n
3 . Once non-faulty processes decide 1 on
at lest h(dr) AABC instances, non-faulty processes start the remaining AABC
instances with input value 0 (line 9), without having to wait to AARB-deliver
their respective values.

3 ⌉, since dr < n

14

Finally, once all AABC instances have terminated (line 10), non-faulty pro-
cesses can output a decision. As such, processes take as input a list of AARB-
delivered values and their associated index and output a decision selecting the
AARB-delivered value with the lowest associated index whose binary consensus
with the same index output 1 (line 13).

repeat:

if (∃v, k : (est, hv, ki) ∈ msgs) then

if (BIN-CONSENSUS[k] not yet invoked) then

Algorithm 1 The general Basilic with initial threshold h0.
1: Basilic-gen-proposeh0 (vi):
2: msgs ← AARB-broadcast(est, hvi, ii)
3:
4:
5:
6:
7:
8:
9:
10: wait until for all k, bin-decisions[k] 6= ⊥
j ← min{k : bin-decisions[k] = 1})
11:
12: wait until ∃v : (est, hv, ji) ∈ msgs
13:

until |bin-decisions[k] = 1| ≥ h(dr)
for all k such that BIN-CONSENSUS[k] not yet invoked do
bin-decisions[k] ← BIN-CONSENSUS[k].AABC-prop(0)

bin-decisions[k] ← BIN-CONSENSUS[k].AABC-prop(1)

decide v

(cid:3) Algorithm 4

(cid:3) proposal AARB-delivered
(cid:3) Algorithm 2

(cid:3) decide 1 on at least h(dr)

4.4 Actively accountable Binary Consensus

We show in Algorithm 2 the Basilic actively accountable binary consensus (AABC)
protocol with initial threshold h0 ∈ (n/2, n], along with some additional com-
ponents and functions in Algorithm 3. First, note that all delivered messages
are correctly signed (as wrongly signed messages are discarded) and stored in
sig msgs, along with all sent messages (as we detail in Rule 3 of Alg. 2).

The Basilic’s AABC protocol is divided in two phases, after which a decision
is taken. A key diﬀerence with Polygraph is that when a timer for one of the
two phases reaches its timeout, if a process cannot terminate that phase yet,
then it broadcasts its set of signed messages for that phase and resets the timer,
as detailed in Rule 4. This allows Basilic to prevent deceitful processes from
breaking termination by trying to cause a disagreement and never succeeding.
It is important that processes wait for this timer before taking a decision for
the phase, since only waiting for that timer guarantees that all sent messages
will be received before the timer reaches its timeout, after GST. Each process
maintains an estimate (line 15), initially given as input, and then proceeds in
rounds executing the following phases:

1. In the ﬁrst phase, each process broadcasts its estimate (given as input)
via an accountable binary value reliable broadcast (ABV-broadcast) (line 26),
which we present in Algorithm 3, lines 67–85 and discuss in Section 4.4. Decision
and abv-broadcast messages are discarded unless they come with a certiﬁcate
justifying them.

The protocol also uses a rotating coordinator (line 23) per round which
carries a special coord message (lines 27-29). All processes wait until they

15

(cid:3) set timer
(cid:3) rotate coordinator

(cid:3) start timer

(cid:3) reset timer

◮ Phase 2:

◮ Phase 1:

wait until bin vals[r] 6= ∅ ∧ timer expired

wait until bin vals[r] = {w}
broadcast(coord[r], w)

r ← r + 1
timeout ← ∆
coord ← ((r − 1)mod n) + 1

timer ← timeout
if ((coord[r], w) ∈ sig msgs ∧ w ∈ bin vals[r]) then

timer ← start-timer(timeout )
abv-broadcast(est[r], est, cert[r − 1], i, bin vals)
if (i = coord) then

Algorithm 2 Basilic’s AABC with initial threshold h0 for pi.
14: AABC-proph0 (vi):
est ← vi
15:
r ← 0
16:
timeout ← 0
17:
cert[0] ← ∅
18:
bin vals ← ∅
19:
repeat:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32:
33:
34:
35:
36:
37:
38:
39:
40:
41:
42:
43:
44: Upon receiving a signed message s msg:
45:
46:
47: Upon receiving a certiﬁcate cert msg:
48:
49:
50: Upon receiving a list of PoFs pofs msg:
51:
52:
53: Rules:

decide(est )
else est ← (r mod 2)
cert[r] ← compute-cert(vals , est, r, bin vals, sig msgs)

pofs ← check-conﬂicts(cert msg, sig msgs)
update-committee(pofs )

pofs ← check-conﬂicts({s msg}, sig msgs)
update-committee(pofs )

if (verify-pofs(pofs msg)) then
update-committee(pofs msg)

if (est = (r mod 2) ∧ pi not decided before) then

if (|vals| = 1) then est ← vals[0]

◮ Decision phase:

aux ← {w}

(cid:3) if only one, adopt as estimate

(cid:3) if parity matches, decide the estimate
(cid:3) otherwise, the estimate is the round’s parity bit

(cid:3) returns ∅ or PoFs
(cid:3) remove fraudsters

(cid:3) returns ∅ or PoFs
(cid:3) remove fraudsters

(cid:3) if proofs are valid then
(cid:3) remove fraudsters from committee

else aux ← bin vals[r]
broadcast(echo[r], aux [r])
wait until (vals = comp-vals(sig msgs, bin vals, aux )) 6= ∅ ∧ timer expired

(cid:3) prioritize coordinator’s value
(cid:3) else use any received value
(cid:3) broadcast signed echo message

1. Every message that is not properly signed by the sender is discarded.

2. Every message that is sent by abv-broadcast without a valid certiﬁcate after Round 1,
except for messages with value 1 in Round 2, are discarded.

3. Every signed message received is stored in sig msgs, including messages within certiﬁ-
cates.

4. Every time the timer reaches the timeout for a phase, and if that phase cannot be
terminated, processes broadcast their current delivered signed messages for that phase
(and all messages received for future phases and rounds) and reset the timer for that
phase. These messages are added to the local set of messages and cross-checked for PoFs
on arrival.

16

deliver at least one message from the call to abv-broadcast and until the timer,
initially set to ∆, expires (line 30). (Note that the bound on the message delays
remains unknown due to the unknown GST.) If a process delivers a message
from the coordinator (line 33), then it broadcasts an echo message with the
coordinator’s value and signature in the second phase (line 36). Otherwise, it
echoes all the values delivered in phase 1 as part of the call to abv-broadcast
(line 35).

2. In the second phase, processes wait till they receive h(dr) echo messages,
as shown in the call to comp-vals (line 37), which returns the set of values that
contain these h(dr) signed echo messages. Function comp-vals is depicted in
Algorithm 3 (lines 86–95). Processes then try to come to a decision in lines 39-
43. As it was the case for phase 1, when the timer expires in phase 2, all
processes broadcast their current set of echo messages. Then, they update
their committee if they detect deceitful processes through PoFs (lines 44-52)
and recheck if they reach the updated h(dr) threshold, after which they reset
the timer.

3. During the decision phase, if there is just one value returned by comp-vals
and that value’s parity matches with the round’s parity, process pi decides it
(line 41) and broadcasts the associated certiﬁcate in the call to compute-cert. If
the parity does not match then process pi simply adopts the value as the estimate
for the next round (line 39). If instead there is more than one value returned by
comp-vals then pi adopts the round’s parity as next round’s estimate (line 42).
Adopting the parity as next round’s estimate helps with convergence in the next
round, in this case where processes are hesitating between two values.The call
to compute-cert (depicted at lines 96–105 of Algorithm 3) gathers the signatures
justifying the current estimate and broadcasts the certiﬁcate if the estimate was
decided in this round.

Detecting and removing deceitful processes Upon receiving a signed
message, non-faulty processes check if the received message conﬂicts with some
previously delivered message in storage in sig msgs by calling check-conﬂicts
(line 45). This function returns pofs = ∅ if there are no conﬂicting messages,
or a list pofs of PoFs otherwise. Then, at line 46, non-faulty processes call
update-committee (depicted at lines 54–66 of Algorithm 3) to remove the |pofs|
detected deceitful processes at runtime. In the call to update-committee, process
pi removes all processes that are proven deceitful via new PoFs, and updates
the committee N , its size n, and the voting threshold h(dr). After that, pi
rechecks all delivered messages in that phase in case it can now terminate the
phase with the new threshold h(dr) (and after ﬁltering out messages delivered
by the dr removed deceitful processes) by calling recheck-certs-termination() in
line 65 of Algorithm 3. Finally, it resets the timer for the current phase by
calling reset-current-timer() in line 66 of Algorithm 3.

17

if (new pofs 6= ∅ ∧ new pofs 6⊆ local pofs ) then

Algorithm 3 Helper Components.
54: update-committee(new pofs ):
55:
56:
57:
58:
59:
60:
61:
62:
63:
64:
65:
66:

new pofs ← new pofs \local pofs
local pofs ← local pofs ∪ new pofs
broadcast(pof, new pofs)
deceitful ← new pofs.get processes()
new deceitful ← new deceitful \local deceitful
local deceitful ← local deceitful ∪ new deceitful
N ← N \{new deceitful }; n ← |N |
dr ← |local deceitful |
h(dr) ← recalculate-threshold(N, dr)
recheck-certs-termination()
reset-current-timer()

(cid:3) function that removes fraudsters

(cid:3) consider only new PoFs
(cid:3) store new PoFs
(cid:3) broadcast new PoFs
(cid:3) get deceitful from PoFs

(cid:3) remove new deceitful
(cid:3) update number of detected deceitful

(cid:3) check termination of current phase
(cid:3) reset timer of current phase

2

⌋ − dr + 1

discard all messages received without a valid certiﬁcate

if ((bvecho, hv, ·, ·i) received from ⌊ n−q−t

Let cert be any valid certiﬁcate cert received in these messages
broadcast(bvecho, hv, cert, ii)

67: abv-broadcast(msg, val , cert, i, bin vals):
broadcast(bvecho, hval , cert, ii)
68:
if ( r = 3 or (r = 2 and val = 1)) then
69:
70:
71: Upon receipt of (bvecho, hv, ·, ji)
72:
73: distinct processes and (bvecho, hv, ·, ii) not yet broadcast) then
74:
75:
76:
77: (bvready, hv, ·, ·i) not yet broadcast) then
78:
79:
80:
81:
82:
83:
84:
85:

Let cert be any valid certiﬁcate cert received in these messages
Construct bv cert a certiﬁcate with h(dr) signed bvecho
bin vals ← bin vals.add(bvready, hv, cert, j, bv certi)
broadcast(bvready, hv, cert, j, bv certi)

bin vals ← bin vals.add(bvready, hv, cert, j, bv certi)
if ((bvready, hv, cert, j, bv certi) not yet broadcast) then

if ((bvecho, hv, ·, ·i) received from h(dr) distinct processes and

if ((bvready, hv, cert, j, bv certi) received from 1 process) then

broadcast(bvready, hval , cert, i, bv certi)

(cid:3) broadcast message

(cid:3) see Lemma .1

then return(aux set)

If ∃S ⊆ msgs where the following conditions hold:
(i) |S| contains h(dr) distinct echo[r] messages
(ii) aux set is equal to the set of values in S

86: comp-vals(msgs, b set, aux set):
87:
88:
89:
90:
91: Else If ∃S ⊆ msgs where the following conditions hold:
(i) |S| contains h(dr) distinct echo[r] messages
92:
(ii) Every value in S is in b set
93:
94:
95: Else return(∅)

then return(V = the set of values in S)

to return ← (cert : (est[r], hv, cert, ·i) ∈ bin vals)
else to return ← (∅)

if (r > 1) then

if (est = (r mod 2)) then

96: compute-cert(vals , est, r, bin vals, msgs):
97:
98:
99:
100:
101:
102:
103:
104:
105:

return(to return)

else to return ← (h(dr ) signed msgs containing only est)
if (vals = {(r mod 2)} ∧ no previous decision by pi) then

cert[r] ← h(dr) signed messages containing only r mod 2
broadcast(est, r, i, cert[r])

18

(cid:3) check for termination of phase 2

(cid:3) h(dr) with same est

(cid:3) h(dr) messages with diﬀerent est

(cid:3) else not ready to terminate

(cid:3) compute and send cert

(cid:3) broadcast decision

Termination and agreement of Basilic’s AABC We show the detailed
proofs of agreement and termination in Lemmas .13 and .16. The idea is that
removing deceitful processes has no eﬀect on agreement, while it facilitates ter-
mination, since the threshold h(dr) = h0 − dr decreases the initial threshold
h0 with the number of removed deceitful processes. Also, since all non-faulty
processes broadcast their delivered PoFs and thanks to the property of account-
ability, eventually all non-faulty processes agree on the same set of removed
deceitful processes.

Then, if a process pi terminates broadcasting certiﬁcate certi while another
process pj already removed newly detected deceitful processes new dr present in
certi, then |certi| − new dr ≥ h(dr + new dr) by construction. As such, either a
non-faulty process terminates and then all subsequent non-faulty processes can
terminate, even after removing more deceitful processes, or they all eventually
reach a scenario where all deceitful processes are detected dr = d and removed,
after which they all terminate.

Note that removing processes at runtime can result in rounds whose coor-
dinator is already removed. For the sake of correctness, we do not change the
coordinator for that round even if it has already been removed. This guarantees
that all non-faulty processes eventually reach a round in which they all agree
on the same coordinator, which is a non-faulty process.
If this round is the
ﬁrst after GST and after all deceitful processes have been removed from the
committee, then non-faulty processes will reach agreement.

Accountable Binary Value Broadcast The ABV-broadcast that we present
in Algorithm 3 is inspired from the E protocol presented by Malkhi et al. [34]
and the binary value broadcast presented in Polygraph [12, 14]. If non-faulty
processes add a value v to bin vals (lines 80 and 83) as a result of the ABV-
broadcast protocol, we say that they ABV-deliver v. Processes exchange two
types of messages during ABV-broadcast: bvecho and bvready messages.
bvecho messages are signed and must come with a valid certiﬁcate cert i justi-
fying the value, as shown in lines 68 and 75. bvready messages carry the same
information as bvecho messages plus an additional certiﬁcate bv cert contain-
ing h(dr) bvecho messages justifying the bvready message, constructed in
line 79. This way, as soon as a process receives a bvready message with a
value (line 82), it already obtains h(dr) bvecho messages too, meaning it can
ABV-deliver that value adding it to bin vals (lines 80 and 83). Non-faulty pro-
cesses broadcast signed bvecho messages for their estimate (line 68) and for all
values for which they receive at least ⌊ n−q−t
⌋ − dr + 1 signed bvecho messages
from distinct processes.

2

We prove in Lemma .1 that waiting for this many bvecho messages for a
value v guarantees that all non-faulty processes ABV-deliver v. We defer the rest
of the proofs to Appendix .1. In particular, we show that our ABV-broadcast
satisﬁes the following properties: (i) ABV-Termination, in that every non-faulty
process eventually adds at least one value to bin vals; (ii) ABV-Uniformity, in
that non-faulty processes eventually add the same values to bin vals; (iii) ABV-

19

Obligation, in that if ⌊ n−q−t
⌋ − dr + 1 non-faulty processes ABV-broadcast a
value v, then all non-faulty processes ABV-deliver v; (iv) ABV-Justiﬁcation, in
that if a non-faulty process ABV-delivers a value v then v was ABV-broadcast by
a non-faulty process; and (v) ABV-Accountability, in that every ABV-delivered
value contains a valid certiﬁcate from the previous round.

2

We show in Lemma 4.1 that Basilic’s AABC satisﬁes AABC-active account-
ability, but we defer the rest of the proofs of actively accountable binary con-
sensus to the Appendix .1.

Lemma 4.1 (AABC-Active accountability). Basilic’s AABC satisﬁes active
accountability.

Proof. We show that if a faulty process pi sends two conﬂicting messages to
two subsets A, B ⊆ N , each containing at least one non-faulty process, then
eventually all non-faulty processes terminate, or instead they receive a PoF for
pi and remove it from the committee, after which they all terminate.

First, we observe that no process gets stuck in some round. Process pi cannot
get stuck in phase 1 since, by ABV-Termination (Lemma .1), every non-faulty
process eventually ABV-delivers a value.

A process also does not get stuck waiting on phase 2. First, notice that
every value that is included in an echo message from a non-faulty process
is eventually delivered to bin vals. Then, note that all non-faulty processes
eventually deliver h(dr) echo messages, or instead, when the timer expires,
processes will exchange their echo messages and be able to construct PoFs and
remove dr deceitful processes that are preventing termination.
In the latter
case, after removing all deceitful processes from the committee and updating
the threshold, they will deliver enough echo messages to terminate phase 2,
since h(dr) < n − q − t − d − dr.

Then, we show that all non-faulty processes always hold a valid certiﬁcate
to broadcast a proper message, which could otherwise prevent termination of
a phase during the ABV-broadcast in phase 1. For an estimate whose parity
is the same as that of the ﬁnished round r − 1, process pi must have received
a valid certiﬁcate for the round (otherwise it would not have terminated such
round). If the parity matches, then it can always construct a valid certiﬁcate in
round r − 1 from the delivered estimates.

As a result, all processes always progress inﬁnitely in every round. Consider
the ﬁrst round r after GST where (i) the coordinator is non-faulty and (ii) all
deceitful processes have been detected and removed by all non-faulty processes.
In this case, every non-faulty process will prioritize the coordinator’s value,
adopting it as their echo message adding only that value. Hence, every process
adopts the same value, and hence decides either in round r or round r + 1 (by
Lemma .12).

20

4.5 Actively accountable Reliable Broadcast

Algorithm 4 shows Basilic’s actively accountable reliable broadcast (AARB). The
protocol is analogous to the secure broadcast presented in previous work [34],
with the diﬀerence that we also introduce a timer that non-faulty processes
use to periodically broadcast their set of delivered echo messages, in order
to detect deceitful processes. We refer of the process that starts the AARB
protocol as the source. The protocol starts when the source broadcast an echo
message with its proposed value v (line 107). Upon delivering that message, all
non-faulty processes also broadcast a signed echo message with v (line 109).
Then, once a process pi delivers h(dr) distinct signed echo messages for the
same value v, pi ﬁrst broadcasts a ready message (line 112) with a certiﬁcate
containing the h(dr) echo messages justifying v (constructed in line 111), and
then AARB-delivers the value (line 113). The same occurs if instead a process
delivers just one valid ready message containing a valid certiﬁcate justifying it
in lines 114-118.

As it occurs with Basilic’s AABC protocol presented in Algorithms 2 and 3,
upon cross-checking newly received signed messages with previously delivered
ones (lines 120 and 123), non-faulty processes can detect deceitful faults and
update the committee (lines 121 and 124), removing them at runtime, by calling
update-committee. This can also occur when receiving a list of PoFs (line 125).
Note that this is the same call to the same function as in the AABC protocol
shown in Algorithm 2, because non-faulty processes update the committee across
the entire Basilic protocol, and not just for that particular instance of AARB or
AABC where the deceitful process was detected. We show in Appendix .1 that
Basilic’s AARB protocol satisﬁes the following properties of actively accountable
reliable broadcast:

• AARB-Unicity. Non-faulty processes AARB-deliver at most one value.

• AARB-Validity. Non-faulty processes AARB-deliver a value if it was

previously AARB-broadcast by the source.

• AARB-Send. If the source is non-faulty and AARB-broadcasts v, then

non-faulty processes AARB-deliver v.

• AARB-Receive. If a non-faulty process AARB-delivers v, then all non-

faulty processes AARB-deliver v.

• AARB-Accountability. If two non-faulty processes AARB-deliver dis-
tinct values, then all non-faulty processes receive PoFs of the deceitful behavior
of at least 2h(dr) − n processes including the source.

• AARB-Active accountability. Deceitful behavior does not prevent

liveness.

21

broadcast(init, vi)

boadcast(echo, v, j)

Construct certi containing at least h(dr) signed msgs (echo, v, j)
broadcast(ready, v, certi, j)
AARB-deliver(v, j)

Algorithm 4 Basilic’s AARB with initial threshold h0.
106: AARB-broadcasth0 (vi):
107:
108: Upon receiving (init, vi) from pj and not having sent echo:
109:
110: Upon receiving h(dr) (echo, v, j) and not having sent a ready:
111:
112:
113:
114: Upon receiving (ready, v, cert, j), and not having sent a ready:
115:
116:
117:
118:
119: Upon receiving a signed message s msg:
120:
121:
122: Upon receiving a certiﬁcate cert msg:
123:
124:
125: Upon receiving a list of PoFs pofs msg:
if (verify-pofs(pofs msg)) then
126:
update-committee(pofs msg)
127:
128: Rules:

if (verify(cert) = F alse) then continue
Set certi to be one of the valid certs received (ready, v, cert, j)
broadcast(ready, v, certi, j)
AARB-deliver(v, j)

pofs ← check-conﬂicts(cert msg, sig msgs)
update-committee(pofs )

pofs ← check-conﬂicts({s msg}, sig msgs)
update-committee(pofs )

(cid:3) executed by the source
(cid:3) broadcast to all

(cid:3) echo value to all

(cid:3) broadcast certiﬁcate
(cid:3) AARB-deliver value

(cid:3) broadcast certiﬁcate
(cid:3) AARB-deliver value

(cid:3) returns ∅ or PoFs
(cid:3) remove fraudsters

(cid:3) returns ∅ or PoFs
(cid:3) remove fraudsters

(cid:3) if proofs are valid then
(cid:3) exclude from committee

1. Processes broadcast their current delivered signed init and echo messages once a timer
timer, initially set to ∆, reaches 0, and resets the timer to ∆.

4.6 Basilic’s fault tolerance in the BDB model

We show in Figure 4 the combinations of Byzantine, deceitful and benign pro-
cesses that Basilic tolerates, depending on the initial threshold h0. The solid
lines represent the variation in tolerance to benign and deceitful processes as the
number of Byzantine processes varies for a particular threshold. For example,
3 and q < n
3 , if t = 0 then d < n
for h0 = 2n
3 . As t increases, for example to
6 and q < n
t = ⌈ n
6 .

6 ⌉ − 1, then d < n

We compare our Basilic’s fault tolerance with that of previous works in
Figure 5.
In particular, we represent multiple values of the initial threshold
h0 ∈ {5n/9, 2n/3, 3n/4, 5n/6} for Basilic. First, we show that classical Byzan-
tine fault-tolerant (BFT) protocols tolerate only the case t < n/3 with a blue
triangle dot ( ) in the ﬁgure. This is the case of most partially synchronous BFT
consensus protocols [18, 14, 26, 45, 38]. Notice that Zero-loss Blockchain [38]
(ZLB) also tolerates instead d < 5n/9 and 3q + d < n faults, where d and q is
the number of deceitful and benign faults, but that ZLB does not solve consen-
sus for these bounds, and instead it recovers from disagreements. Second, we
represent Flexible BFT [35] in their greatest fault tolerance setting in partial
synchrony. As we can see, such setting overlaps with Basilic’s initial threshold
of h0 = 2n/3. However, the diﬀerence lies in that while Basilic tolerates all the
cases in the solid line h0 = 2n/3, Flexible BFT only tolerates a particular dot

22

n/2

t:0

11n/24

s
e
s
s
e
c
o
r
p

i

n
g
n
e
b

f
o

n
o
i
t
c
a
r
F

5n/12

3n/8

n/3

7n/24

n/4

5n/24

n/6

n/8

n/12

n/24

0

t:0
t:n/36

t:n/18

t:n/12

t:0
t:n/36

t:n/9

t:n/18

t:n/12

t:0
t:n/36

t:n/9
t:5n/36

t:n/18

t:n/12

t:0
t:n/36

t:n/6
t:7n/36

t:n/9
t:5n/36

t:n/18

t:n/12

t:0
t:n/36

t:2n/9

t:n/6
t:7n/36

t:n/9
t:5n/36

t:n/18

t:n/12

t:0
t:n/36

h0 = n/2
h0 = 5n/9
h0 = 11n/18
h0 = 2n/3
h0 = 13n/18
h0 = 7n/9
h0 = 5n/6
h0 = 8n/9
h0 = 17n/18
h0 = n

t:2n/9

t:n/6
t:7n/36

t:n/9
t:5n/36

t:n/18

t:n/12

t:0
t:n/36

t:n/4
t:5n/18
t:11n/36

t:n/3

t:2n/9

t:n/4
t:5n/18

t:n/6
t:7n/36

t:0
t:n/36
t:n/18t:0
0 n/12 n/6 n/4 n/3 5n/12 n/2 7n/122n/3 3n/4 5n/611n/12 n
Fraction of deceitful processes

t:n/9
t:5n/36

t:n/18

t:n/12

t:2n/9

t:n/6

t:n/9

Figure 4: Combinations of benign, deceitful and Byzantine processes that Basilic
tolerates, for an initial threshold h0.

of the line, set at the discretion of each client. That is, Flexible BFT’s clients
must decide, for example, whether they tolerate either ⌈2n/3⌉ − 1 total faults,
being none of them Byzantine, or instead tolerate ⌈n/3⌉ − 1 Byzantine faults,
not tolerating any additional fault. Basilic can however tolerate any range sat-
isfying both h0 > n+d+t
for safety and h0 ≤ n − q − t for liveness, which allows
our clients and servers to tolerate signiﬁcantly more combinations of faults for
one particular threshold h0 ∈ (n/2, n]. For this reason, we represent the line of
Flexible BFT as a dashed line, whereas Basilic’s lines are solid. For each initial
voting threshold h0, the maximum number of Byzantine processes Basilic tol-
erates is t < min(2h0 − n, 1 − h0), which is obtained by setting q = d = 0 and
resolving both bounds for safety and liveness.

2

4.7 Basilic’s correctness

We show in Lemma 4.2 that Basilic satisﬁes active accountability. We defer to
Appendix .1 the rest of the proofs that show that the Basilic class of proto-
cols solves the actively accountable consensus problem for the resilient optimal
bounds of the impossibility results shown in Section 3.

Lemma 4.2 (Active accountability). Basilic satisﬁes active accountability.

Proof. We show that if a faulty process pi sends two conﬂicting messages to
two subsets A, B ⊆ N , each containing at least one non-faulty process, then
eventually all non-faulty processes terminate, or instead they receive a PoF for
pi and remove it from the committee, after which they all terminate.

First, analogously to Lemma 4.1, w.l.o.g. we treat only the case dr = 0, since
all conﬂicting messages that can be sent in Basilic are messages of Basilic’s

23

 
 
 
n

s
e
s
s
e
c
o
r
p

5n/6

3n/4

2n/3

5n/9

l

a
t
o
t

Basilic, h0 = 5n/9
Basilic, h0 = 2n/3
Basilic, h0 = 3n/4
Basilic, h0 = 5n/6
Flexible BFT, qr = 2n/3

BFT protocols

n/3

f
o

n
o
i
t
c
a
r
F

0

0

n/6
Fraction of Byzantine processes

n/9

n/4

n/3
n/3

Figure 5: Fraction of total processes, compared with fraction of Byzantine pro-
cesses, for a particular initial threshold h0 of the general Basilic protocol, com-
pared with other works.

AARB or AABC, that already satisfy active accountability (see Lemmas 4.1
and .11). This means that if dr > 0, then non-faulty processes eventually update
the committee and threshold, after which they recheck if they hold enough
signed messages to terminate. Next, we prove termination. By the AARB-
Send property (Lemma .8), all non-faulty processes will eventually deliver the
proposals from non-faulty processes. Eventually all non-faulty processes propose
1 in all binary consensus whose index corresponds to a non-faulty proposer, and
by AABC-Validity decide 1. Since eventually h(dr) ≤ n − q − d − t if enough dr
prevent termination and are thus detected and removed, we can conclude that
at least h(dr) binary consensus instances will terminate deciding 1.

Once non-faulty processes decide 1 on at least h(dr) proposals, they propose
0 to the rest, and by AABC-Termination (Lemma .16) all remaining binary con-
sensus instances will terminate. Next, we show that for every binary consensus
upon which we decided 1, at least one non-faulty process AARB-delivered its
associated proposal. For the sake of contradiction, if no non-faulty process had
AARB-delivered its associated proposal, then all non-faulty processes would
have proposed 0, meaning by AABC-Validity that the ﬁnal decision of the bi-
nary consensus would have been 0, not 1. As a result, by the AARB-Receive
property (Lemma .9), eventually all non-faulty processes will deliver the pro-
posal for all binary consensus that they decided 1 upon. Finally, processes
decide the value proposed by the proposer with the lower index.

We summarize all proofs in the result shown in Theorem 4.3 to show that
Basilic protocol with initial threshold h0 solves consensus if d + t < 2h0 − n and
q + t ≤ n − h0. This result translates in the Basilic class of protocols solving

24

 
 
 
consensus if n > 3t + d + 2q, as we show in Corollary .24.

Theorem 4.3 (Consensus per threshold). The Basilic protocol with initial
threshold h0 solves the actively accountable consensus problem if d + t < 2h0 − n
and q + t ≤ n − h0.

Corollary 4.4 (Consensus). The Basilic class of protocols solves actively ac-
countable consensus if n > 3t + d + 2q.

5 Basilic’s complexity

In this section, we show the time, message and bit complexities of Basilic. We
execute one instance of Basilic’s AARB reliable broadcast and of Basilic’s AABC
binary consensus per process. We prove these complexities in the appendix .2.
We summarize the complexities of the three protocols after GST in Table 1. We
refer to the appendix .2 for an analysis of complexities before GST.

Complexity

Time
Message
Bit

AARB

O(1)
O(n2)
O(λn3)

AABC

O(n)
O(n3)
O(λn4)

Basilic

O(n)
O(n4)
O(λn5)

Table 1: Time, message and bit complexities of Basilic AARB, AABC and the
general Basilic protocol, after GST.

The complexities of Basilic after GST share the same asymptotic complex-
ity of other recent works that are not actively accountable [12, 14, 41], some of
them not being accountable either [11], as we show in Table 2. This is because
the adversary cannot prevent termination of any phase. Thus, after GST, all
processes can continue to the next phase or terminate the protocol by the time
the timer for that phase expires, resulting in an execution equivalent to that of
Polygraph (apart from one additional message broadcast in ABV-broadcast).
In this table, naive Basilic represents the protocol we show in Algorithm 1,
whereas the following row, multi-valued Basilic, shows the analogous optimiza-
tions shown in Polygraph and applicable to the Basilic protocol as well [14].
The row titled ’superblock’ is the result of applying the additional superblock
optimization [18, 19]. This optimization is only available to protocols without
a leader in which all processes propose a value [18, 14], and consists of deciding
the union of all values instead of the minimum of them. After these optimiza-
tions, the resulting normalized bit complexity (i.e. per decision) of Basilic is as
low as those of other works that are only accountable and not actively account-
able, such as BFT Forensics [41] or Polygraph [14]. Furthermore, since this is
the lowest complexity to obtain accountability [14], this means that this is also
optimal in the bit complexity. Note that other optimizations present in other
works, such as the possibility to obtain an amortized complexity of O(λ\∈) in

25

BFT Forensics per decision after n iterations of the protocol [43], is also possible
in Basilic’s consensus protocol. Finally, an advantage of Basilic, as well as of
other leaderless protocols, compared to leader-based works [41, 43], is that the
distribution of proposals scatters the bits throughout multiple channels of the
network, instead of bloating channels that have the leader as sender or recipient,
as previously noted [19].

Finally, not only are the rest of the protocols in Table 2 not actively ac-
countable, but also this means that they only solve consensus tolerating at
most t < n/3 faults in the BDB model, whereas Basilic with initial threshold
h0 = 2n/3 solves consensus where d + t < n/3 and q + t ≤ n/3 faults, hence
tolerating the strongest adversary among these proposals.

Table 2: Complexities of Basilic compared to other works.

Acc. Actacc.

Algorithm

PBFT [11]
Tendermint [6]
HotStuﬀ [43]
DBFT superblock [18]

Msgs
Bits
O(n3) O(λn4) ✗
O(n3) O(λn3) ✗
O(n2) O(λn2) ✗
✗
O(n3) O(n3)
O(n2) O(λn3) ✓
BFT Forensics [41]
O(n3) O(λn4) ✓
Polygraph’s binary [14]
O(n4) O(λn5) ✓
Naive Polygraph [14]
O(n4) O(λn4) ✓
Polygraph Multi-v. [14]
Polygraph superblock. [14] O(n3) O(λn3) ✓
O(n3) O(λn4) ✓
O(n4) O(λn5) ✓
O(n4) O(λn4) ✓
O(n3) O(λn3) ✓

Basilic’s AABC
Naive Basilic
Multi-valued Basilic
Basilic superblock

✗
✗
✗
✗

✗
✗
✗
✗
✗

✓
✓
✓
✓

6 Solving Eventual Consensus with Basilic

In this section, we adapt Basilic to solve eventual consensus in the BDB model,
and then prove that the Basilic protocol is resilient optimal. The eventual con-
sensus (3-consensus) abstraction [21] captures eventual agreement among all
participants. It exports, to every process pi, operations proposeEC1, proposeEC2, ...
that take multi-valued arguments (non-faulty processes propose valid values)
and return multi-valued responses. Assuming that, for all j ∈ N , every pro-
cess invokes proposeECj as soon as it returns a response to proposeECj−1, the
abstraction guarantees that, in every admissible run, there exists k ∈ N , such
that the following properties are satisﬁed:

• 3-Termination. Every non-faulty process eventually returns a response

to proposeECj for all j ∈ N .

26

• 3-Integrity. No process responds twice to proposeECj for all j ∈ N .
• 3-Validity. Every value returned to proposeECj was previously proposed

to proposeECj for all j ∈ N .

• 3-Agreement. No two non-faulty processes return diﬀerent values to

proposeECj for all j ≥ k.

We detail now 3-Basilic (BEC), an adaptation of Basilic for the 3-consensus

problem. Process pi executes 3-Basilic with the following steps:

1. BEC ﬁrst executes Basilic-gen-proposeh0(vi), whose output is returned by

pi as BEC’s output of proposeEC0.

2. If pi ﬁnds no disagreement between operations k and k′, then for all

operations proposeECj, k′ > j ≥ k, the output is that of proposeECj−1.

3. If pi ﬁnds a new disagreement at operation j for some index r ∈ [0, n − 1],

then:

(a) If the disagreement is between AARB-delivered values, BEC resolves it
let (est, hu, ri) be the value that diﬀers with the locally AARB-
as follows:
delivered value (est, hv, ri), then, for proposeECj, pi applies y = min(v, u) to
the disagreeing value. Next, if the output of proposeECj−1 was v, pi replaces
the AARB-delivered value with y, and outputs y instead for proposeECj.

(b) If the disagreement is between values 1 and 0 decided at AABC’s pro-
tocol, then pi sets bin-decisions [r] to 1. Then, pi recalculates if the minimum
decided value changed after adding this binary decision (i.e., re-execute lines 11-
13 of Algorithm 1), and output this decision for proposeECj.

(c) Finally, pi broadcasts the values (and certiﬁcates) of all the disagree-

ments that pi has not yet broadcast.

We show in Theorem 6.1 that 3-Basilic with initial threshold h0 solves the
3-consensus problem if d + t < h0 and q + t < n − h0, where t, d and q are
the numbers of Byzantine, deceitful and benign processes, respectively, and h0
the initial threshold. This means that the 3-Basilic class of protocols solves
3-consensus for any combination of t, d and q Byzantine, deceitful and benign
processes, respectively, such that 2t + d + q < n, as we show in Corollary 6.2.

Theorem 6.1 (3-Consensus per threshold). The 3-Basilic protocol with initial
threshold h0 solves the 3-consensus problem if d + t < h0 and q + t < n − h0.

Proof. 3-Integrity is trivial. The bound q+t < n−h0 is proven in Corollary 3.7:
3-Basilic starts by executing Basilic, which does not terminate unless q + t <
n − h0, satisfying 3-Termination. 3-Validity derives immediately from Basilic’s
proof of validity (Lemma .20).

We only have left to prove 3-Agreement. If d + t < h0 then all valid cer-
tiﬁcates contain at least one non-faulty process. This means that the number

27

of disagreements is ﬁnite. Then, since non-faulty processes broadcast all dis-
agreements they ﬁnd (and their corresponding valid certiﬁcates), all non-faulty
processes will eventually ﬁnd all disagreements. Also, all non-faulty processes
will ﬁnd all disagreements of Basilic by its accountability property (Lemma 4.2).
Let us consider that all non-faulty processes, except pi, have already found and
treated all disagreements (as speciﬁed by the 3-Basilic protocol). Suppose that
pi ﬁnds the last disagreement at the start of operation proposeECk−1 for some
k > 0. Then, for all j ≥ k, no two non-faulty processes return diﬀerent values
to proposeECk, satisfying 3-Agreement.
Corollary 6.2 (3-Consensus). The Basilic class of protocols solves 3-consensus
if n > 2t + d + q.

7 Related Work

Accountability has been proposed for distributed systems in PeerReview [23]
and particularly for the problem of consensus in Polygraph [13]. ZLB [38] ex-
tends Polygraph to tolerate up to 5n/9 deceitful faults for 3-consensus, but
tolerates only t < n/3 for consensus. This work leverages accountability to
replace deceitful processes by new processes. Unfortunately, they require de-
ceitful processes to eventually stop trying to cause a disagreement. Flexible
BFT [35] oﬀers a failure model and theoretical results to tolerate ⌈2n/3⌉ − 1
alive-but-corrupt (abc) processes. An abc process behaves maliciously only if
it knows it can violate safety, and behaves correctly otherwise. This is an even
stronger assumption than ZLB’s deceitful faults eventually behaving correctly.
Additionally, their fault tolerance requires a commitment from clients to not
tolerate a single Byzantine fault in order to tolerate ⌈2n/3⌉ − 1 abc faults, or
to instead tolerate no abc faults if clients decide to tolerate t = ⌈n/3⌉ − 1
Byzantine faults. Neu et al.’s ebb-and-ﬂow system [36] is available in partial
synchrony for t < n/3 and satisﬁes ﬁnality in synchrony for t < n/2. They also
motivate the need for the BDB model in their recent accountability-availability
dilemma [37]. Sheng et al.[41] characterize the forensic support of a variety of
Blockchains. Unfortunately, none of these works tolerate q = ⌈ n
3 ⌉ − 1 benign
and even d = 1 deceitful faults, or d = ⌈ n
3 ⌉ − 1 and even q = 1 benign fault, a
direct consequence of them not satisfying active accountability.

Upright [17] tolerates n = 2u + r + 1 faults, where u and r are the numbers of
commission and omission faults, respectively. Upright tolerates n/3 commission
faults or instead n/2 omission faults, falling short of Basilic’s q + d < 2n/3
deceitful and benign faults or t < n/3 Byzantine faults tolerated. Upright
does also not tolerate more faults for commission than the lower bound for BFT
consensus. Anceaume et al. [3] tolerate t < n/2 Byzantine faults for the problem
of eventual consensus, at the cost of not tolerating even t = 1 Byzantine fault
for deterministic consensus. Our Basilic class also tolerates this case if h0 is set
to h0 = ⌊ n
2 ⌋ + 1, but Basilic also tolerates more cases by a just changing the
initial threshold h0.

28

Although Basilic is, to the best of our knowledge, the ﬁrst protocol tolerating
n > 3t + d + 2q in the BDB model, and despite this fault tolerance deriving from
the property of active accountability, previous works already try to discourage
misbehavior by threatening with slashing a deposit or removing a faulty process
from the committee, or both. Ranchal-Pedrosa et al. propose the Huntsman
protocol [39], an accountable consensus protocol tolerating up to k rational
players and t Byzantine players causing a disagreement by threatening deviant
rationals and rewarding those who expose the deviants, for n > max( 3
2 k +
3t, 2(k+t)). Freitas de Souza et al. [20] provide an asynchronous implementation
of an accountable lattice agreement protocol. Shamis et al. [40] store signed
messages in a dedicated ledger so as to punish processes in case of misbheavior.
The Casper [8] algorithm incurs a penalty in case of double votes but does not
ensure termination when t < n/3. Although Tendermint [7] aims at slashing
processes, it is not accountable. SUNDR [30] requires cross-communication
between non-faulty clients to detect failures. FairLedger [29] requires synchrony
to detect faulty processes.

8 Conclusion

In this paper, we have shown that it is impossible to solve consensus in the BDB
model against an adversary controlling n > 3t + d + 2q, where t, d, and q are
the number of Byzantine, deceitful and benign processes, respectively. We then
present our Basilic class of protocols, the ﬁrst class of resilient optimal protocols
for the consensus problem in the BDB model. Basilic solves actively accountable
consensus tolerating any combination of t, d and q Byzantine, deceitful and
benign processes, respectively, satisfying h0 > n+d+t
for safety and h0 ≤ n −
q − t for liveness, given an initial voting threshold h0. We prove this result
to be resilient optimal per voting threshold. Additionally, for the same voting
threshold, Basilic also solves eventual consensus if h0 > d + t and h0 ≤ n −
q − t. We show that Basilic’s complexities are comparable to state-of-the-art
accountable consensus protocols that tolerate less faults.

2

References

[1] I. Abraham, P. Jovanovic, M. Maller, S. Meiklejohn, G. Stern, and
A. Tomescu. Reaching consensus for asynchronous distributed key gen-
eration. In Proceedings of the 2021 ACM Symposium on Principles of Dis-
tributed Computing, PODC’21, page 363–373, New York, NY, USA, 2021.
Association for Computing Machinery.

[2] I. Abraham, K. Nayak, L. Ren, and Z. Xiang. Good-case latency of byzan-
In Proceedings of the 2021
tine broadcast: A complete categorization.
ACM Symposium on Principles of Distributed Computing, PODC’21, page
331–341, New York, NY, USA, 2021. Association for Computing Machin-
ery.

29

[3] E. Anceaume, A. Pozzo, T. Rieutord, and S. Tucci-Piergiovanni. On ﬁnality

in blockchains. arXiv preprint arXiv:2012.10172, 2020.

[4] M. Backes and C. Cachin. Reliable broadcast in a computational hybrid
model with byzantine faults, crashes, and recoveries. In DSN, volume 3,
pages 37–46, 2003.

[5] M. Ben-Or, R. Canetti, and O. Goldreich. Asynchronous secure computa-

tion. In STOC, pages 52–61, 1993.

[6] E. Buchman. Tendermint: Byzantine fault tolerance in the age of

blockchains, 2016. MS Thesis.

[7] E. Buchman, J. Kwon, and Z. Milosevic. The latest gossip on BFT con-

sensus. Technical Report 1807.04938, arXiv, 2018.

[8] V. Buterin and V. Griﬃth. Casper the friendly ﬁnality gadget. Technical

Report 1710.09437v4, arXiv, Jan 2019.

[9] C. Cachin, K. Kursawe, F. Petzold, and V. Shoup. Secure and eﬃcient
asynchronous broadcast protocols. In J. Kilian, editor, Advances in Cryp-
tology — CRYPTO 2001, pages 524–541, Berlin, Heidelberg, 2001. Springer
Berlin Heidelberg.

[10] C. Cachin, K. Kursawe, and V. Shoup. Random oracles in constantinople:
Practical asynchronous byzantine agreement using cryptography. Journal
of Cryptology, 18(3):219–246, 2005.

[11] M. Castro and B. Liskov. Practical Byzantine fault tolerance and proactive

recovery. ACM Trans. Comput. Syst., 20(4):398–461, 2002.

[12] P. Civit, S. Gilbert, and V. Gramoli. Polygraph: Accountable byzan-
tine agreement. Cryptology ePrint Archive, Report 2019/587, 2019.
https://ia.cr/2019/587.

[13] P. Civit, S. Gilbert, and V. Gramoli. Brief announcement: Polygraph:

Accountable byzantine agreement. In DISC, pages 45:1–45:3, 2020.

[14] P. Civit, S. Gilbert, and V. Gramoli. Polygraph: Accountable byzantine
In 2021 IEEE 41st International Conference on Distributed

agreement.
Computing Systems (ICDCS), pages 403–413, 2021.

[15] P. Civit, S. Gilbert, and V. Gramoli. Polygraph: Accountable byzantine

agreement. In IEEE ICDCS, Jul 2021.

[16] A. Clement, F. Junqueira, A. Kate, and R. Rodrigues. On the (limited)
power of non-equivocation. In Proceedings of the 2012 ACM Symposium on
Principles of Distributed Computing, PODC ’12, page 301–308, New York,
NY, USA, 2012. Association for Computing Machinery.

30

[17] A. Clement, M. Kapritsos, S. Lee, Y. Wang, L. Alvisi, M. Dahlin, and

T. Riche. Upright cluster services. In ACM SOSP, pages 277–290, 2009.

[18] T. Crain, V. Gramoli, M. Larrea, and M. Raynal. DBFT: Eﬃcient leader-
less byzantine consensus and its application to blockchains. In 2018 IEEE
17th International Symposium on Network Computing and Applications
(NCA), pages 1–8. IEEE, 2018.

[19] T. Crain, C. Natoli, and V. Gramoli. Evaluating the Red Belly Blockchain.

Technical Report 1812.11747, arXiv, 2018.

[20] L. F. de Souza, P. Kuznetsov, T. Rieutord, and S. Tucci Piergiovanni.
Brief announcement: Accountability and reconﬁguration - self-healing lat-
tice agreement. In DISC, pages 54:1–54:5, 2021.

[21] S. Dubois, R. Guerraoui, P. Kuznetsov, F. Petit, and P. Sens. The weak-
est failure detector for eventual consistency.
In Proceedings of the 2015
ACM Symposium on Principles of Distributed Computing, PODC ’15, page
375–384, New York, NY, USA, 2015. Association for Computing Machin-
ery.

[22] C. Dwork, N. Lynch, and L. Stockmeyer. Consensus in the presence of

partial synchrony. J. ACM, 35(2):288–323, Apr. 1988.

[23] A. Haeberlen, P. Kouznetsov, and P. Druschel. PeerReview: Practical

accountability for distributed systems. In SOSP, 2007.

[24] M. Kapritsos, Y. Wang, V. Qu´ema, A. Clement, L. Alvisi, and M. Dahlin.
All about eve: Execute-verify replication for multi-core servers. In USENIX
OSDI, pages 237–250, 2012.

[25] K. P. Kihlstrom, L. E. Moser, and P. M. Melliar-Smith. Byzantine Fault
Detectors for Solving Consensus. The Computer Journal, 46(1):16–35, 01
2003.

[26] R. Kotla, L. Alvisi, M. Dahlin, A. Clement, and E. Wong. Zyzzyva: Spec-

ulative Byzantine fault tolerance. In SOSP, 2007.

[27] P. Kuznetsov, A. Tonkikh, and Y. X. Zhang. Revisiting optimal resilience
of fast byzantine consensus. In Proceedings of the 2021 ACM Symposium on
Principles of Distributed Computing, PODC’21, page 343–353, New York,
NY, USA, 2021. Association for Computing Machinery.

[28] L. Lamport, R. Shostak, and M. Pease. The Byzantine generals problem.

ACM Trans. Program. Lang. Syst., 4(3):382–401, 1982.

[29] K. Lev-Ari, A. Spiegelman, I. Keidar, and D. Malkhi. Fairledger: A fair
blockchain protocol for ﬁnancial institutions. Technical Report 1906.03819,
arXiv, 2019.

31

[30] J. Li, M. Krohn, D. Mazi`eres, and D. Shasha. Secure untrusted data repos-

itory (SUNDR). In USENIX OSDI, page 9, 2004.

[31] S. Liu, P. Viotti, C. Cachin, V. Qu´ema, and M. Vukolic. XFT: practical

fault tolerance beyond crashes. In USENIX OSDI, pages 485–500, 2016.

[32] M. Lokhava, G. Losa, D. Mazi`eres, G. Hoare, N. Barry, E. Gafni, J. Jove,
R. Malinowsky, and J. McCaleb. Fast and secure global payments with
stellar. In SOSP, pages 80–96, 2019.

[33] Y. Lu, Z. Lu, Q. Tang, and G. Wang. Dumbo-mvba: Optimal multi-valued
validated asynchronous byzantine agreement, revisited. In Proceedings of
the 39th Symposium on Principles of Distributed Computing, PODC ’20,
page 129–138, New York, NY, USA, 2020. Association for Computing Ma-
chinery.

[34] D. Malkhi, M. Merritt, and O. Rodeh. Secure reliable multicast protocols
in a wan. In Proceedings of 17th International Conference on Distributed
Computing Systems, pages 87–94. IEEE, 1997.

[35] D. Malkhi, K. Nayak, and L. Ren. Flexible Byzantine fault tolerance. In

CCS, pages 1041–1053, 2019.

[36] J. Neu, E. Tas, and D. Tse. Ebb-and-ﬂow protocols: A resolution of the

availability-ﬁnality dilemma. In IEEE S&P, pages 446–465, 2021.

[37] J. Neu, E. N. Tas, and D. Tse. The availability-accountability dilemma and
its resolution via accountability gadgets. arXiv preprint arXiv:2105.06075,
2021.

[38] A. Ranchal-Pedrosa and V. Gramoli. Blockchain is dead,

blockchain!
blockchain. CoRR, abs/2007.10541, 2020.

accountable state machine replication for

long live
longlasting

[39] A. Ranchal-Pedrosa and V. Gramoli. Agreement in the presence of
arXiv preprint

disagreeing rational players: The huntsman protocol.
arXiv:2105.04357, 2021.

[40] A. Shamis, P. Pietzuch, M. Castro, E. Ashton, A. Chamayou, S. Clebsch,
A. Delignat-Lavaud, C. Fournet, M. Kerner, J. Maﬀre, et al. PAC: Practical
accountability for CCF. Technical report, arXiv, 2021.

[41] P. Sheng, G. Wang, K. Nayak, S. Kannan, and P. Viswanath. BFT protocol

forensics. In CCS, 2021.

[42] A. Singh, P. Fonseca, P. Kuznetsov, R. Rodrigues, P. Maniatis, et al. Zeno:
Eventually consistent Byzantine-fault tolerance. In USENIX NSDI, pages
169–184, 2009.

[43] P. Tholoniat and V. Gramoli. Formal veriﬁcation of blockchain byzantine

fault tolerance. In FRIDA, Oct 2019.

32

[44] Y. Xue and M. Herlihy. Hedging against sore loser attacks in cross-chain
transactions. In Proceedings of the 2021 ACM Symposium on Principles
of Distributed Computing, PODC’21, page 155–164, New York, NY, USA,
2021. Association for Computing Machinery.

[45] M. Yin, D. Malkhi, M. K. Reiter, G. G. Gueta, and I. Abraham. HotStuﬀ:

BFT consensus with linearity and responsiveness. In PODC, 2019.

33

.1 Basilic Proofs

In this section, we prove the rest of the properties of Basilic, including its ABV-
broadcast, AABC and AARB protocols.

.1.1 Accountable binary value broadcast

We ﬁrst start with the properties that ABV-broadcast satisﬁes. We say process
pi ABV-broadcasts value v to refer to pi sending a bvecho message containing
v and a valid certiﬁcate justifying v. We prove ABV-termination in Lemma .1,
ABV-uniformity in Lemma .2, ABV-obligation in Lemma .3, ABV-justiﬁcation
in Lemma .4, and ABV-accountability in Lemma .5.

Lemma .1 (ABV-Termination). Every non-faulty process eventually adds at
least one value to bin vals.

Proof. Note that all non-faulty processes broadcast a bvecho message with
value v when they receive ⌊ n−q
2 ⌋ − dr + 1 bvecho messages with v. First,
let us consider that t = d = 0, in that case, non-faulty processes broadcast a
bvecho message with v if they receive ⌊ n−q−t
⌋ + 1 bvecho messages with v.
Also recall that v ∈ {0, 1}. As such, let us consider a partition of non-faulty
processes A, B ⊆ N such that A ∩ B = ∅, and let us consider that processes
in A initially sent a bvecho message with v = 0 while processes in B sent a
bvecho message with v = 1. It is clear that |A| + |B| ≥ n − q − t and thus
either |A| ≥ ⌊ n−q−t
let us assume that
|A| ≥ ⌊ n−q−t
⌋ + 1, then processes in |B| eventually receive enough bvecho
messages with value v = 0 to also broadcast a bvecho message with v = 0.
Thus, since h(dr) ≤ n − q − t − dr, eventually all non-faulty processes receive
enough bvecho messages to add at least the value 0 to bin vals.

⌋ + 1 or |B| ≥ ⌊ n−q−t

⌋ + 1. W.l.o.g.

2

2

2

2

Suppose instead that d > 0 and t = 0. Then, if the dr ≤ d deceitful
processes that behave deceitful at a particular phase are enough to prevent
termination, this means that dr processes have sent at least two conﬂicting
messages to at least two non-faulty processes. As such, when the timer expires
and non-faulty processes broadcast their received signed bvecho messages, all
non-faulty processes will eventually receive enough bvecho messages to send a
bvecho message (analogously to case d = 0). Thus, the case d > 0 is analogous
to the case d = 0 since bvecho messages are relayed when timer expires, and
we have proven in the previous paragraph that termination is guaranteed in
that case. The same analogy takes place if t > 0.

Note additionally that if dr detected deceitful processes have been removed,

then the thresholds decrease by the same factor dr, preserving termination.

Lemma .2 (ABV-Uniformity). If a non-faulty process pi adds value v to the
set bin vals, then all other non-faulty processes also eventually add v to their
local set bin vals.

34

Proof. This proof is straightforward: pi adds v to the set bin vals if it holds
h(dr) signed bvecho messages with v. In that case, it also constructs a certiﬁ-
cate bv cert with these messages and broadcasts bv cert as part of the bvready
with v before adding v to bin vals. Therefore, all other non-faulty processes will
eventually receive pi’s bvready message along with bv cert containing enough
bvecho messages to also add v to their local bin vals. Finally, recall that
all non-faulty processes broadcast their bvready message before adding v to
bin vals, which solves the case that pi is faulty and sends bvready only to a
subset of the non-faulty processes.

Lemma .3 (ABV-Obligation). If ⌊ n−q−t
broadcast a value v, then all non-faulty processes ABV-deliver v.

⌋ − dr + 1 non-faulty processes ABV-

2

Proof. This proof is analogous to that of Lemma .1.

Lemma .4 (ABV-Justiﬁcation). If process pi is non-faulty and ABV-delivers
v, then v has been ABV-broadcast by some non-faulty process.

Proof. Assume ﬁrst t = 0 and suppose the contrary: pi ABV-delivers v and
all non-faulty processes ABV-broadcast v′, v 6= v′. Since benign processes may
either send v′ to a subset of the non-faulty processes or nothing at all, this
means that d − dr > ⌊ n−q
2 ⌋ − dr + 1 for deceitful alone to be able to make
pi ABV-deliver v. But using the bound d − dr < n − h(dr) we obtain that
q ≥ 2h(dr) − n, which contradicts our assumption on the number of benign
faults (i.e. the bound q < 2h(dr) − n). As a result, it follows that at least
some non-faulty process must have ABV-broadcast v. The prove is analogous
if t > 0.

Lemma .5 (ABV-Accountability). If process pi adds value v to bin vals then
associated with v is a valid certiﬁcate cert from the previous round.

Proof. Since every bvecho and bvready message without a valid certiﬁcate is
discarded, it follows immediately that when a value v is added to bin vals then
pi has access to a valid certiﬁcate.

.1.2 Actively accountable reliable broadcast

In this section, we prove the properties of Basilic’s reliable broadcast, AARB. In
these proofs, we refer to ps as the source of the AARB-broadcast, i.e. the pro-
cess that sends the init message. We prove AARB-unicity in Lemma .6, AARB-
validity in Lemma .7, AARB-send in Lemma .8, AARB-Receive in Lemma .9,
AARB-accountability in Lemma .10 and AARB-active accountability in Lemma .11.

Lemma .6 (AARB-Unicity). Non-faulty processes AARB-deliver at most one
value.

Proof. By construction all non-faulty processes AARB-deliver at most one value.

35

Lemma .7 (AARB-Validity). If non-faulty process pi AARB-delivers v, then
v was AARB-broadcast by ps.

Proof. Process pi AARB-delivers v if it receives h(dr) messages hecho, v, ·, ·i.
Non-faulty processes only send an echo message for v if they receive hinit, vi.
Thus, since d + t < h(dr), ps AARB-broadcast v to at least one non-faulty
process.

Lemma .8 (AARB-Send). If ps is non-faulty and AARB-broadcasts v, then all
non-faulty processes eventually AARB-deliver v.

Proof. Deceitful processes either broadcast v or multicast v′ to a partition A
and v to a partition B.
In the ﬁrst case (in which all deceitful behave like
non-faulty processes), since the number of benign and Byzantine processes is
q + t < n − h(dr) it follows that at least h(dr) non-faulty processes will echo v,
being that enough for all processes to eventually AARB-deliver it.

Consider instead some dr ≤ d + t deceitful processes behave deceitful echo-
ing diﬀerent messages to two diﬀerent partitions each containing at least one
non-faulty process. Then when the timer expires and non-faulty processes ex-
change their delivered echo messages, all processes will update their committee
removing the dr detected deceitful. Thus, since processes also recalculate the
thresholds and recheck them after updating the committee, this case becomes
the aforementioned case where no deceitful process behaves deceitful. The same
occurs if one of the partitions AARB-delivers a value while the other does not
and reaches the timer (Lemma .9).

Lemma .9 (AARB-Receive). If a non-faulty process AARB-delivers v from ps,
then all non-faulty processes eventually AARB-deliver v from ps.

Proof. First, since d + t < 2h(dr) − n it follows that deceitful and Byzantine
processes can not cause two non-faulty processes to AARB-deliver diﬀerent val-
ues (analogously to Lemma 3.4). Then, before a process pi AARB-delivers a
value v, it broadcasts a ready message containing the certiﬁcate that justiﬁes
delivering v. Thus, when pj receives that ready message, it also AARB-delivers
v.

Lemma .10 (AARB-Accountability). If two non-faulty processes pi and pj
AARB-deliver v and v′, respectively, such that v 6= v′, then all non-faulty pro-
cesses eventually receive PoFs of the deceitful behavior of at least 2h(dr) − n
processes (including ps).

Proof. Non-faulty processes broadcast the certiﬁcates of the values they AARB-
deliver, containing h(dr) signed echo messages from distinct processes. There-
fore, analogous to Lemma 3.4, at least 2h(dr) − n processes must have sent
conﬂicting echo messages, and they will be caught upon cross-checking the
conﬂicting certiﬁcates. Also, some non-faulty processes must have received con-
ﬂicting signed init messages from ps in order to reach the threshold h(dr) to
AARB-deliver conﬂicting messages, meaning that ps is also faulty.

36

Lemma .11 (AARB-Active accountability). The Basilic’s AARB protocol sat-
isﬁes active accountability.

Proof. We prove here that if a number of faulty processes send conﬂicting mes-
sages to two subsets A, B ⊆ N , each containing at least one non-faulty process,
then:

• eventually all non-faulty processes terminate without removing the faulty

processes, or

• eventually all non-faulty processes receive a PoF for these faulty processes
and remove them from the committee, after which, if the source is non-
faulty, they terminate.

W.l.o.g. we consider just pA ∈ A and pB ∈ B.

If they both terminate
despite the conﬂicting messages, we are ﬁnished. Suppose instead a situation in
which only one of them, for example pA, terminated AARB-delivering a value v.
Then pA broadcast a ready message with enough h(dr) echo messages in the
certiﬁcate cert for pB to also AARB-deliver v and terminate. Let us consider
w.l.o.g. only one faulty process pi. If a signature from pi in cert conﬂicts with a
local signature from pi stored by pB, then pB constructs and broadcasts a PoF
for pi, and then updates the committee and the threshold. Then, it rechecks
the certiﬁcate ﬁltering out the signature by pi, which would cause pB to also
AARB-deliver v (since the threshold also decreased accordingly).

Suppose neither pA nor pB has terminated yet. Then, when the timer is
reached and they both broadcast the init and echo messages they delivered,
they will both be able to construct a PoF for pi, after which they update the
committee and the threshold. Then, if the source was non-faulty, non-faulty
processes can terminate analogously to the previous case.

.1.3 Basilic binary consensus

We focus in this section on the properties of Basilic’s binary consensus, AABC.
We ﬁrst prove that if all non-faulty processes start a round r with the same
estimate v, then all non-faulty processes decide v in round r or r + 1. Then,
we prove AABC-agreement in Lemma .13, AABC-strong validity in Lemma .14
and AABC-validity as Corollary .15 of Lemma .14, AABC-active accountability
in Lemma 4.1, AABC-termination in Lemma .16, and AABC-accountability
in Lemma .17. This thus makes AABC the ﬁrst actively accountable binary
consensus protocol, as we show in Theorem .18.

Lemma .12. Assume that each non-faulty process begins round r with the es-
timate v. Then every non-faulty process decides v either at the end of round r
or round r + 1.

Proof. By Lemma .3, v is eventually delivered to every non-faulty process. By
Lemma .4, v is the only value delivered to each non-faulty process. As such, v
is the only value in bin vals and the only value echoed by non-faulty processes,

37

since deceitful processes that prevent termination are removed from the com-
mittee when the timer expires (and the threshold is updated). This means that
v will be the only value in vals. If v = r mod 2 then all non-faulty processes
decide v. Otherwise, by the same argument every non-faulty process decides v
in round r + 1.

Lemma .13 (AABC-Agreement). If d+t ≤ 2h−n, no two non-faulty processes
decide diﬀerent values.

Proof. W.l.o.g. assume that the non-faulty process pi decides v in round r.
This means that pi received h(dr) echo messages in round r, and that vals =
{v}. Consider the echo messages received by non-faulty process pj in the
same round.
If v is in pj’s vals then pj adopts estimate v because v = r
mod 2. If instead pj’s vals = {w}, w 6= v, then pj received h(dr) echo messages
containing only w.

Analogously to Lemma 3.4, it is impossible for pj and for pi to receive h(dr)
echo messages for v and for w, respectively. We then conclude, by Lemma .12,
that every non-faulty process decides value v in either round r + 1 or round
r + 2.

Lemma .14 (AABC-Strong Validity). If a non-faulty process decides v, then
some non-faulty process proposed v.

Proof. This proof is identical to Polygraph’s proof of strong validity [12, 14].

Corollary .15 (AABC-Validity). If all processes are non-faulty and begin with
the same value, then that is the only decision value.

Lemma .16 (AABC-Termination). Every non-faulty process eventually decides
on a value.

Proof. This proof derives directly from Lemma 4.1.

Lemma .17 (AABC-Accountability). If two non-faulty processes output dis-
agreeing decision values, then all non-faulty processes eventually identify at least
2h − n faulty processes responsible for that disagreement.

Proof. This proof is identical to Polygraph’s proof of accountability [12, 14],
with the a generalization to any threshold h(dr) analogous to the one we make
in Lemma .10.

Theorem .18. Basilic’s AABC solves the actively accountable binary consensus
problem.

Proof. Corollary .15 and Lemmas .13, 4.1, .16, and .17 prove AABC-validity,
AABC-agreement, AABC-active accountability, AABC-termination and AABC-
accountability, respectively.

38

.1.4 General Basilic protocol

We gather all the results together in this section, showing the proofs for the
general Basilic protocol. We prove active accountability in Lemma 4.2, validity
in Lemma .20, termination in Corollary .19, agreement in Lemma .21, and
accountability in Lemma 4.2. Finally, we prove that Basilic solves the actively
accountable consensus problem in Theorem .23.

Corollary .19 (Termination). The Basilic protocol satisﬁes termination.

Proof. Trivial from Lemma 4.2.

Lemma .20 (Validity). Basilic satisﬁes validity.

Proof. This is trivial by Corollary .15 and the proofs of AARB. Suppose all
processes begin Basilic with value v. If all processes are non-faulty then every
proposal AARB-delivered was AARB-sent by a non-faulty process, and since all
processes AARB-send v, only v is AARB-delivered.

Since initially processes only start an AABC instance for which they can
propose 1, this means that eventually all processes start one AABC instance
proposing 1. By Corollary .15, this instance will terminate with all processes
deciding 1. Since the rest of the AABC instances will eventually terminate by
Lemma .16, this means that processes will terminate at least one instance of
AABC outputting 1. Upon calculating the minimum of all values (which are all
v) whose associated bit is set to 1, all processes will decide v.

Lemma .21 (Agreement). The Basilic protocol satisﬁes agreement.

Proof. The proof is immediate having Lemmas .13 and .9.

Lemma .22 (Accountability). If two non-faulty processes output disagreeing
decision values, then all non-faulty processes eventually identify at least 2h − n
faulty processes responsible for that disagreement.

Proof. The proof is immediate from Lemmas 4.1 and .11.

Theorem .23 (Theorem 4.3). The Basilic protocol with initial threshold h0 ∈
(n/2, n] solves the actively accountable consensus problem if d + t < 2h0 − n and
q + t ≤ n − h0.

Proof. Corollary .19 and Lemmas 4.2, .20, .21, and 4.2 satisfy termination,
active accountability, validity, agreement, and accountability, respectively.

Corollary .24 (Corollary 4.4). The Basilic class of protocols solves the actively
accountable consensus problem if n > 3t + d + 2q.

Proof. The proof is immediate from Theorem 4.3 after removing h0 from the
system of two inequations deﬁned by d + t < 2h0 − n and q + t ≤ n − h0.
Corollary .25 (Corollary 6.2). The Basilic class of protocols solves 3-consensus
if n > 2t + d + q.

Proof. The proof is immediate from Theorem 6.1 after removing h0 from the
system of two inequations deﬁned by d + t < h0 and q + t < n − h0.

39

.1.5 Impossibility of consensus without active accountability

In the proofs of Corollary .26 and Theorem 3.3 we considered that deceitful
faults do not prevent termination, that is, that the protocol satisﬁes active
accountability. We show in Corollary .26 the analogous result in the case where
deceitful processes can actually prevent termination, that is, if the protocol does
not satisfy active accountability. In this case, since deceitful can have the same
impact as Byzantine (in that they can prevent either agreement or termination),
then the bounds decrease to n > 3(t+d)+2q. Note that other protocols that use
authentication may also be subject to this bound if they do not satisfy active
accountability, as it is the case for Polygraph [14].

Corollary .26. It is impossible for a protocol that solves consensus without
satisfying active accountability to tolerate t Byzantine, d deceitful and q benign
processes if n ≤ 3(t + d) + 2q.

Proof. The proof is analogous to Theorem 3.3 with the diﬀerence that deceit-
ful processes can actually prevent termination by sending conﬂicting messages.
Thus, we have n + t + d ≤ 2n − 2q − 2t − 2d, which means n > 3(t + d) + 2q.

.2 Extended complexities of Basilic

.2.1 Complexities Before GST

Before GST and in the presence of an adversary controlling t Byzantine, d
deceitful, and q benign processes, let a be the number of times the timer is
reached before GST (i.e. a ≥ ⌈ GST
∆ ⌉), then the message and bit complexities of
AABC increase by a factor of a · n, thus to O(an3) and O(λan4), respectively.
The same occurs with AARB’s complexities. The time complexities are also
aﬀected by the time a to reach GST thus to O(an) for AABC and the general
Basilic, and O(a) for AARB.

Since there are n pairs of reliable broadcasts and binary consensus instances
in the Basilic general protocol, the time complexity is O(t + q + d), message
complexity O(an3) and bit complexity O(λan4). We show in Table 3 the worst-
case complexities of the three protocols.

Complexity

AARB

AABC

Basilic

Time
Message
Bit

O(a)
O(an2)
O(λan3)

O(b)
O(an3)
O(λan4)

O(b)
O(an4)
O(λan5)

Table 3: Time, message and bit complexities of Basilic’s AARB, AABC and the
general Basilic protocol, before GST.

40

.2.2 Proofs

We prove in this section the complexities of Basilic, and of Basilic’s AARB and
AABC, which we presented in Section 5.

Lemma .27 (Basilic’s AARB Complexity). After GST and if the source is non-
faulty, Basilic’s AARB protocol has time complexity O(1), message complexity
O(n2) and bit complexity O(λ · n3).

Proof. After GST, all non-faulty processes will have received a message from
each non-faulty process and from each deceitful processes by the time the timer
reaches 0. Thus, either non-faulty processes can terminate, or they broadcast
their current list of echo and init messages, after which they remove the de-
tected deceitful processes, and they can terminate too. Thus, the time complex-
ity is O(1). Then, the message complexity is O(n2), as each non-faulty process
broadcasts at least one echo and ready message, and, in some executions, a
list of echo messages that they delivered by the time the timer reaches 0. Since
both this list and ready messages contain O(n) signatures, or O(λn) bits, the
bit complexity of Basilic’s AARB is O(λn3).

Lemma .28 (Basilic’s AABC Complexity). After GST, Basilic’s AABC pro-
tocol has time complexity O(n), message complexity O(n3) and bit complexity
O(λ · n4).

Proof. After GST, the Basilic protocol terminates in the ﬁrst round (i) whose
leader is a non-faulty process and (ii) after having removed enough deceitful
faults so that they cannot prevent termination. Since t + d + q < n, we have
that (i) holds in O(n). As for every added round in which deceitful faults prevent
termination, a non-zero number of deceitful faults are removed, we have that
(ii) holds in O(n) as well. This means that Basilic terminates in O(n) rounds.
In each round during phase 1 of AABC, non-faulty processes execute an ABV-
broadcast of O(n2), obtaining O(n3) messages. The bit complexity is O(λn4) as
each message may contain up to two ledgers of O(n) signatures, or O(λn) bits.
The complexities of phase 2 are equivalent and obtained analogously to those
of phase 1, as non-faulty processes may broadcast O(n) signatures if deceitful
faults prevent termination of phase 2, or a certiﬁcate if they decide in this
round.

Theorem .29. The Basilic protocol has time complexity O(n), message com-
plexity O(n3) and bit complexity O(λ · n4).

Proof. The proof is immediate from Lemma .28 and Lemma .27 since Basilic
executes n instances of AARB and after n instances of AABC.

41

