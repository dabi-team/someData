1
2
0
2

p
e
S
8

]

R
C
.
s
c
[

1
v
0
7
8
3
0
.
9
0
1
2
:
v
i
X
r
a

Secure Blockchain-Based Supply Chain Management with
Veriﬁable Digital Twins⋆

Vincenzo Botta1, Laura Fusco1, Attilio Mondelli2, and Ivan Visconti1

1 DIEM, University of Salerno, Italy, {vbotta,visconti}@unisa.it,
2 DIEM, University of Salerno, Italy, laurafusco1995@gmail.com,
3 Farzati Tech, Italy, attilio.mondelli@farzatitech.it

Abstract. A major problem in blockchain-based supply chain management is the unclear validity of
digital twins when dealing with digital representations of physical goods. Indeed, the use of blockchain
technology to trace goods is ineﬀective if there is no strong correspondence between what is physically
exchanged and the digital information that appears in blockchain transactions.
In this work we propose a model for strengthening the supply chain management of physical goods lever-
aging blockchain technology through a digital-twin veriﬁcation feature. Our model can be instantiated
in various scenarios and we have in particular considered the popular case of food traceability.
In contrast to weaker models known in the literature that propose their own ad-hoc properties to assess
the robustness of their supply chain management systems, in this work we use the formalism of secure
computation, where processes are described through generic and natural ideal functionalities.

1

Introduction

The traceability of goods is extremely important to optimize their management and to reduce risks of frauds
and their consequences (e.g., in foodstuﬀs frauds damage economy and public health). Heterogeneous supply
chain (SC) members are interested in using tracing systems since traceability provides transparency and
helps to ﬁght counterfeiting with positive eﬀects on the reputation and business of the involved (honest)
companies [VSM+12].

However, traditional supply chain management systems are based on centralized management and data
storage. The credibility of these systems relies on the trust towards central administrators [Tia16,ATdM17].
This single point of failure due to centralized architectures is a classical issue that motivates the use of
blockchain technology, indeed blockchains can help providing an immutable, consistent, transparent, de-
centralized and highly available ledger of supply chain data. While originally focusing on cryptocurrencies,
blockchain technology is nowadays mature enough to be used in other scenarios decentralizing classic central-
ized solutions. Leveraging on blockchain technology all events in a supply chain can be digitized and stored
in a transparent and immutable manner with robust data availability. Indeed, current blockchain-based so-
lutions provide the traceability of the supply chain by recording the status of a good at each stage of the
supply chain.

Achilles’ heel: the validity of a digital twin. Unfortunately, there is a major issue to consider: the problematic
connection between data stored in a blockchain with goods in the physical world [PHJ+20]. Consider for
instance a farm producing mozzarella with milk obtained from Italian Mediterranean buﬀalo. A blockchain
is useful to transparently give information on the location and size of the farm, the number of buﬀalos and
the amounts of buﬀalo mozzarella that is daily produced and reach the stores and the ﬁnal consumers. The
use of a blockchain allows to publicly verify that the farm does not claim unreasonably high amounts of
produced buﬀalo mozzarella. While this tracing is beneﬁcial for the entire system, it still remains possible to
dishonestly mix buﬀalo milk and cow milk whenever there is shortage of buﬀalo milk, due for instance to a
virus aﬀecting buﬀaloes. This is a typical case where while data appearing in the blockchain are consistent
with expectations, they can be completely uncorrelated to the physical goods to which they refer to.

⋆

This is a preliminary version of our work. The aﬃliations of the authors correspond to their institutions while
working at this project.

 
 
 
 
 
 
1.1 Our Contribution

In this paper, we present a general model for blockchain-based supply chain focusing on the traceability
and the veriﬁcation of goods. Our goal is to enable every party in the system to retrieve full information
about the life-cycle of goods in the supply chain. Each physical good has a digital twin identiﬁed by a unique
code that appears on a blockchain along with all the relevant events describing the life of the good (e.g.,
the event that generated it, the merging and splitting as a batch). An authenticated auditing process is
required in order to strengthen consistency between the information stored on-chain and the physical goods,
therefore reducing errors and frauds. Every time an inspection is carried out by a supply chain entity some
relevant information (e.g., date, time, place, operator, veriﬁed goods, the outcome of the inspection) about
the inspected good is recorded on the blockchain.

We formalize the concept of authenticated audit through a speciﬁc ideal functionality that can be instan-
tiated in several ways. In particular our model focuses on establishing how to declare a category of goods
that will be involved in the supply chain and then how to make sure that goods that are supposed to belong
to a certain category can be tested in case of inspection. Notice that deﬁning this process is non-trivial given
the evolving nature of goods during their life-cycles (e.g., the color, hardness and ﬂavor of a banana are
expected to change day by day depending also on how they are stored).

When presenting our model we will be generic about the goods, but for concreteness we will sometimes
refer in particular to food traceability. Indeed, this use case represents a popular example where the use
of blockchains has been widely considered and bogus digital twins can severely aﬀect desired advantages
provided by the publicly veriﬁable tracing.

The formalism that we use to guarantee the robustness of the traceability provided by our model is
the golden standard in the design of secure systems: secure multi-party computation (SMPC) [GMW87].
It consists of deﬁning a natural ideal world that can be validated simply by inspection. Then a concrete
system is proven secure by showing that any successful attack to the concrete system can be translated into
a successful attack in the ideal world. Since the latter is obviously secure then the former must be secure
too.

2 System Overview

Our blockchain-based tracing system allows supply chain participants to record information on goods at each
stage of the supply chain. Each physical good has a unique digital twin that is identiﬁed by an asset on the
blockchain. The asset is associated to a current owner, a list of events and auxiliary information. The owner
of an asset identiﬁes the party that is supposed to own the physical good. The events reﬂect how the physical
good has found its way across the supply chain and the auxiliary information gives additional information
on the asset (e.g., location, type of good).

In the system, access-control policies are deﬁned to prevent non-legitimate participants, including coun-
terfeiters, from jeopardizing the ownership of assets. Moreover, access-control policies guarantee that only
legitimate manufacturers can claim the initial ownership of new assets that are introduced in the system,
and that are supposed to correspond to physical goods. The creation of an asset is possible only if the party
invoking this functionality has a legitimate role (e.g., it is enrolled in the system as farmer).

In our system, if a party wants to check the authenticity of received physical goods with respect to their
digital twins, the party can perform a veriﬁcation procedure. We abstract4 this step assuming the existence of
a device that, after a training over a given category of objects, is able to verify that a given object belongs to
the speciﬁed category. For the scope of this paper, we call this device ﬁngerprint (FP) scanner. An example
of such device for the use case of food traceability can be a biological ﬁngerprint scanner that is able to
detect if a physical good belongs or not to a speciﬁc food category (e.g., distinguishing buﬀalo mozzarella vs
cow mozzarella); obviously this requires an initial training to establish the biological ﬁngerprint of a category
and how items in this category are supposed to change over time. Therefore in our model the possibility of
validating a digital twin aﬀects already the phase in which a category of goods is enabled in the system.
4 The abstraction admits multiple real-world instantiations depending on the use case. For instance one can refer to

an external auditor, or even skip this step if not essential.

2

2.1 System Set-Up and Assets

At ﬁrst, a genesis block is created to ﬁx some system parameters, access-control policies, system smart
contracts, and so on. After the system initialization, supply chain participants (i.e., producers, distributors,
certiﬁers, . . . ) engage in an enrolling protocol to get authorizations for their subsequent interactions. From
now on, parties can record information in the system by submitting transactions.

In our system, we have ﬁve diﬀerent types of assets:

– Element: a good, that can be raw, such as olives, or the result of a transformation, such as olive oil.
– Category: a category to which goods can belong, such as “Oliva Ascolana del Piceno”.
– Batch: a batch of goods created after an Aggregation.
– Production Area: a production area on which goods are produced.
– Device: an FP scanner associated to a party.

2.2 Entities

There are seven types of participants in our system:

Registration authorities. These are privileged parties that initialize the system and register other par-
ticipants in the system with long-term credentials. The credentials tie the real-world identity of the
requester to his attributes and identiﬁer. An example of an attribute is the role (e.g., “producer”, “man-
ufacturer”, “certiﬁer”) [ACC+20]. We note that in a permissioned blockchain the initialization and the
governance are usually managed by a group of organizations. The access control or the signing policy,
(i.e., who can make what transactions in the network) and the logic of smart contracts are decided by
these organizations. Members of the governance of the blockchain may overlap or not with the registra-
tion authorities. In the last case, the registration authorities decide the criteria for adding or removing
parties and the registration authorities are responsible for authenticating, certifying, and registering
network participants.

FP scanner issuers. FP scanner issuers are the only parties capable of releasing new FP scanners to make
sure that the system is not polluted by veriﬁcation procedures that do not guarantee some desired level
of quality of service. A party that wants an FP scanner has to send a request to an FP scanner issuer.
The registration authorities decide the criteria for adding or removing FP scanner issuers. The set of
authorized FP scanner issuers must be publicly available to all parties. Having a set of authorized FP
scanner issuers enforces the parties to trust the functionality that they implement.

Producers. In the real world, a producer is an entity managing the production of raw materials. Accordingly,
in our system, they are users authorized to introduce new items, that represent some real-world assets
or to record a production area with the associated good. When a new item is created, some auxiliary
information is also stored on-chain to link the physical good with its digital twin and to reﬂect its
journey along the supply chain. Producers can introduce a new category and its benchmark, (i.e., physical
properties). A party updating this information can for instance record the transfer of an item from one
location to another or the item aggregation in a package. Producers can also perform all operations
allowed to the role of supply chain members, which is described below.

Manufacturers. Manufacturers produce goods for sale from raw materials. They are users authorized to
introduce new items obtained from scratch (e.g., a manufacturer that obtains raw materials from a
producer not registered to the supply chain system) or from the transformation of existing goods. They
can introduce a new category and its benchmark. They can register the production area used to transform
their goods. They can also perform all operations allowed to the role of supply chain members.

Certiﬁers. Certiﬁers are entities responsible for certifying the authenticity of the physical good with respect
to the information encoded on-chain. An audit recorded by a certiﬁer is diﬀerent from an audit recorded
by other parties. Indeed, certiﬁcation bodies are entities authorized by national accreditation bodies
to conduct speciﬁc types of certiﬁcation audits and award certiﬁcation to qualiﬁed companies. The
certiﬁcations verify if the goods, the systems, the personnel, and the production processes of companies
satisfy the certiﬁcation requirements.

3

Consumers. Final consumers are interested in recovering the entire history of the purchased item. To
keep the presentation simple, we have assumed that a consumer has only read access to supply chain
information. We note that a consumer might also be involved as an active participant of the supply chain
by reporting feedbacks on the purchased items.

Supply chain members. These entities are the other participants of the supply chain, (e.g., wholesaler,
retailer, distributor, repackager). They are grouped into a single category since they can perform the
same operations. These entities own items and give/receive items or aggregate/disaggregate them in
larger/smaller packages or update the item’s data.

Trust assumption. To keep the presentation simple, we assume a single trusted registration authority. The
registration authority Reg is trusted to assign correct credentials to all parties in the system and one unique
identity per participant. The registration authority is trusted to verify the correctness of the attributes of a
participant before enrolling the user in the system. Reg is also trusted in verifying that the role declared by
the parties is true. This authority can be obviously decentralized, as described in Section 7.

FP scanner issuer. For simplicity, we assume a single FP scanner issuer D , (i.e., the producer of the
devices). We assume that D issues only trusted devices, in the sense that these devices are well-formed and
implement the functionality correctly. This trust assumption can be relaxed, as described in Section 7.

Producers and Manufacturers. They are trusted to introduce new categories since the training is super-
vised by the FP scanner issuer. The presence of the FP scanner issuer is necessary since if an error occurs
in this step it might compromise the correct functioning of the scanners.

We assume that the underlying blockchain is secure. It means that an adversary cannot compromise the
data stored in the blockchain, avoid valid transactions to be appended to the ledger or make parties observe
a fake ledger.

3 The Model of Computation

To deﬁne security we follow the simulation paradigm considering ideal and real worlds. In particular we
consider the notion of universally composable (UC) secure multi-party computation [Can01]. We consider
hybrid models in which the protocol access ideal functionalities to perform the computation. Informally, a
protocol π is executed in the G-hybrid model if π invokes the ideal functionality G as a subroutine.

Let F be a functionality, and consider n players P1, . . . , Pn executing a protocol π that implements F .
Intuitively, π is secure if in an execution in the real world the adversary cannot cause more harm than
an adversary in the ideal world in which a trusted party computes the functions of the ideal functionality F
on behalf of the players. Moreover, we require that this guarantee holds even if π access functionality G as
subroutine.

The real model. In the real world, the protocol π is run in the presence of an adversary A and an environment
Z. At the outset, Z chooses the inputs (1λ, xi) for each corrupted player Pi, and gives in input to A an
auxiliary input z and inputs for corrupted parties. For simplicity, we only consider static corruptions (i.e.,
the environment decides who is corrupt at the beginning of the protocol).

The parties start running π, with the honest players Pi behaving as prescribed in the protocol, and with

corrupted parties behaving arbitrarily directed by A

At the end of the execution, Z receives the output of honest and corrupted parties and outputs a bit.

We call REALπ,A,Z(λ) the random variable corresponding to Z’s guess.

To make the description of a protocol modular, the parties of the protocol in the real world can access

an ideal functionality G as a subroutine. In this case, we say that π is realized in the G-hybrid model.

The ideal model. In the ideal world, there exists a trusted party that executes the ideal functionality F on
behalf of a set of dummy players (Pi)i∈[n]. Z chooses the inputs (1λ, xi) for each honest player Pi, and sends
to the simulator S inputs of corrupted parties together with an auxiliary input z. Honest parties send their

4

inputs to the trusted party, while the corrupted parties send an arbitrary input as speciﬁed by S. The trusted
party executes the functionality and produces outputs to give to parties.

Finally, S compute an arbitrary function of the view and gives it to Z. Z returns a bit. We denote by

IDEALF ,S,Z(λ) the random variable corresponding to Z’s guess.

Deﬁnition 1 (UC-Secure MPC). Let π be an n-party protocol that implements a functionality F . We
say that π securely realizes F in the G-hybrid model in the presence of malicious adversaries if for every
PPT adversary A there exists a PPT simulator S such that for every non-uniform PPT environment Z the
following holds:

nREALG

π,A,Z(λ)oλ∈N

≈c {IDEALF ,S,Z(λ)}λ∈N .

4 The Ideal Functionalities

In this section, we deﬁne the ideal functionality realized by our system for product tracing FSC and some
other functionalities FF P , FLedger, FSig and FSMT . FF P models the FP scanner that parties can use to
perform veriﬁcation about the item’s quality. FLedger emulates an available transaction ledger that party can
use to submit transactions or to read the current state. FSig models a secure digital signature scheme. It allows
each party to sign digital messages and verify digital signatures. Finally, FSMT models a secure channel.
This is required since our protocol, in some cases, requires a private and secure exchange of information
between transacting parties.

4.1 Supply-Chain Functionality FSC

FSC models the functionality realized by our product tracing system. Since in the real-world each supply-
chain member, according to the assigned role in the supply chain, can perform diﬀerent operations, FSC
initially requires a set of producers F, manufacturers M, certiﬁers C, at least a device issuer D and other
SC-members O to initialize. For example, a manufacturer should be able to create products, but a certiﬁer
not. To perform writing operations a party Pi ∈ {F, M, C, D , O} has to be registered.

In this functionality we do not need the model the audit and training operation as performed by a device

and we abstract the functionality of the device requiring that:

– A party Pi that wants to send a training on a product p, will send to FSC a value categoryFP that
represent the unique ﬁngerprint of p. categoryFP can be computed in many ways, a possible way is
using the FF P functionality presented below.

– A party Pi that wants to send an audit of a product p to FSC needs only to send an auditData to FSC

containing the data of the audit. This can be computed by functionality FF P or in other ways.

We assume that the data sent to the supply chain data are consistent. In particular, we assume that any

data sent to FSC are veriﬁed in a sense that

– the product stored follow rules, regulations, and standards;
– producers and manufacturers own the production area declared;
– the ﬁngerprint categoryFP produced during a training activity on a product can be updated only by

the party that produce the product with ﬁngerprint categoryFP;

– the identiﬁer of categories, production areas, and products are unique;
– a producer or a manufacturer that produce a new product must be the owner of the production area of

the product and must be the owner of the products at creation time;

– the parties performs operations only over items on which they have the rights to operate;
– aggregation and disaggregation operations can be performed only on owned products;
– the items to package in an aggregation operation must be intact;
– the disaggregation operation can be performed only on an intact batch;

5

– the update event of an item managed by the supply chain is performed only if the speciﬁc parameters

can be updated by a party that requests the update;

– the party that perform an handover is the owner of the good to transfer;
– the party designated for an handover is authorized to receive the asset;

Associated with each product there are the supply chain events just analyzed and a state. The state can

take four diﬀerent values:

– intact: indicates that the asset is ready for use.
– packaged: indicates that the asset has been packaged and is not ready to be used individually. A disag-

gregation event must occur before becoming available again5.
– trans: indicates that a handover has started between two parties.
– destroyed: indicates that the asset is no longer available for future processing it can be applied only to

intact and packaged.

FSC is parameterized by algorithms: T ransf orm and Split. We do not describe formally their behavior,

but the informal description follows:

T ransf orm: This algorithm transforms a product or a set of products in a new product. This algorithm is
used by manufacturers to transform assets in a new asset. The state of assets used in the transformation
is modiﬁed from intact to destroyed.

Split: This algorithm splits an item composed of multiple products obtaining back the separated products
associated with the data identifying the product before the aggregation. The state of the disaggregated
products pass from packaged to intact.

We call categoryFP the asset category ﬁngerprint that uniquely identiﬁes a type of asset.
The data stored by FSC are associated to a timestamp, we call this timestamp tEvent and since FSC is

a trusted functionality, we assume that FSC computes always the correct time.

FSC models the sequence of events that occurs along a supply chain. Each event corresponds to an
operation that a party can perform. The result of the operations are stored in a list L, initially empty. Before
that any operation is stored, FSC checks that data are consistent in the way speciﬁed before:

FSC stores an initially empty list L. Parties P1, . . . , Pn that interacts with FSC may be of type
F, M, C, D , O where F, M, C, D , O represent producers, manufacturers, certiﬁers, device issuers, and
other SC-members. Let A be the adversary, A may be of type F, M, C, O.

FSC Ideal Functionality

Registration. Whenever a party writes (registerSC, Pi), if Pi is unregistered, then FSC marks Pi as

registered and outputs (registeredSC, Pi) to Pi and A. Else, FSC sends ⊥ to Pi.

Register production area. Whenever a party Pi ∈ {F, M } wants to record the place of produc-
tion of a new product, writes (produceSC, Pi, areaId, categoryId). FSC stores the following tuple
(Pi, areaId,
categoryId, producing, tEvent, intact) in L. FSC sends (producedSC, Pi, areaId, ) to Pi and A.
Creation. Whenever a party Pi ∈ {F, M } wants to create a new product, writes (createSC, Pi, itemId,
areaId). FSC stores the following tuple (Pi, itemId, areaId, creation, tEvent, intact) in L. FSC
sends (createdSC, Pi, itemId, areaId) to Pi and A.

Transformation. Whenever a party Pi ∈ M wants to create a new product instance through the com-
bination of single or multiple products writes (transformSC, itemId, Pi, items, categoryId), where
items = [itemId1, . . . , itemIdl]. FSC runs T ransf orm(items, productData), storing in L a new
tuple for each itemIdi ∈ items where the only changed value is the state that passes from intact
to destroyed. Finally, FSC stores the following tuple (Pi, itemId, items, categoryId,

5 Every operation performed on an item in a batch has an impact on the entire batch, this is why we require that a

disaggregation is performed before performing any operation on an item in a batch.

6

transformation, tEvent, intact) in L. FSC sends (transformedSC, Pi, itemId, categoryId, items)
to Pi and A.

Training. Whenever a party Pi ∈ {F, M } writes (trainingSC, Pi, categoryId, categoryFP), FSC

stores the following tuple (Pi, categoryFP, training, tEvent, categoryId) in L and returns (trainedSC,
Pi, categoryId, categoryFP) to Pi and A.

Audit. Whenever a party Pi ∈ {F, M, C, O} writes (auditSC, Pi, itemId, categoryId, auditData),
where auditData is a tuple containing the outcome of the audit and additional information on
the audit, FSC stores the following tuple (audit, Pi, tEvent, auditData, itemId,
categoryId) in L and returns (auditSC, Pi, itemId, auditData) to Pi and A.

Aggregation. Whenever a party Pi ∈ {F, M, C, O} wants to physically aggregate products together
writes (mergeSC, Pi, batchId, products), where products = (p1, . . . , pl) and p ∈ {itemId, batchId}.
FSC checks that the state of each pi is intact and stores in L a new tuple for pi where intact is re-
placed with packaged. Finally, FSC stores the following tuple (Pi, batchId, productsaggregation,
tEvent, intact) in L. FSC sends (mergedSC, Pi, batchId, products) to Pi and A.

Disaggregation. Whenever a party Pi ∈ {F, M, C, O} writes (splitSC, Pi, batchId), FSC runs products ←
Split(batchId). For each pi in products, FSC stores a new tuple where the only changed value
is the state that passes from packaged to intact. FSC stores the tuple (Pi, batchId, products,
disaggregation, tEvent, destroyed). FSC sends (splittedSC, Pi, batchId) to Pi and A.

Handover. The handover operation is divided in the following actions:

– Whenever a party Pi ∈ {F, M, C, O} writes (handoverSC, p, Pi, Pj), where p ∈ {itemId, batchId},
FSC stores a new tuple associated with p, where the state is changed from intact to trans and
adds Pj in the tuple as new designated owner for p. FSC sends (handoverSC, p, Pi, Pj) to Pi, Pj
and A to indicate that a handover is in progress between Pi and Pj.

– Whenever a party Pj ∈ {F, M, C, O} writes (receiveSC, p, Pj, Pi), where p ∈ {itemId, batchId},
FSC stores the new following tuple associated to p (Pj, p, handoverEnded, tEvent, intact),
where the owner is changed from Pi to Pj, and the state is changed from trans to intact. FSC
sends (receivedSC, p, Pi, Pj) to Pi, Pj and A to indicate that a handover occurred between Pi
and Pj.

– Whenever a party Pj ∈ {F, M, C, O} writes (rejectSC, p, Pj, Pi), where p ∈ {itemId, batchId},
FSC stores the following tuple associated to p (Pi, p, handoverFailed, tEvent, intact). Finally,
FSC sends (rejectedSC, p, Pi, Pj) to Pi, Pj and A to indicate that a handover has failed between
Pi and Pj.

Update. Whenever a party Pi ∈ {F, M, C, O} writes (updateSC, Pi, p,

newstate), where p ∈ {itemId, batchId, areaId}, and newstate is the update to the state of p,
FSC stores a new tuple associated to p where the only change is the state that is updated with
value newstate. FSC sends (updatedSC, Pi, p, newstate) to Pi and A.

Read. Whenever a party Pi ∈ {F, M, C, O} writes (readSC, assetId), where assetId ∈ {itemId,
batchId, areaId, categoryId} from a party Pi or the adversary A, FSC returns a list of all records
stored associated to assetId.

The Update process in FSC is required since this process describes the update of a product instance.
This operation can be performed only by the current owner of the product and only for speciﬁc ﬁelds of
information. A particular case is the deletion of a product instance from the supply chain. A deletion event
is essentially the inverse of a creation event: an asset is invalidated and can no longer be used. It can occur
when products are sold to the end-users or there is a product recall or loss due to contamination or accident.
In case of a product recall, the product will be picked up from the market by competent authorities. Finally,
the product can be destroyed by competent authorities with an update event, which might provide also proof
of destruction. By inspecting the item’s history, it will be possible to monitor the entire recall process.

4.2 AssetFingerPrint Scanner Functionality FF P
In the following, we propose the functionality FF P that will model the physical FP scanner. We make the
following trust assumptions on the scanner.

7

– The parties can verify the authenticity of the hardware (e.g., the integrity and no-tampering of the
hardware). This means that an adversary is unable to replace the FP scanner with a malicious one.

– The FP scanner can be uniquely identiﬁed.
– The output is linked to the FP scanner used.

FF P handles the following operations.

– Initialize a device.
– Perform the training operations to allow FF P to recognize a speciﬁc category of products.
– Verify that a given item belongs to the claimed category.
– Transfer a devise from party Pi to party Pj.
– List all FP scanners issued to parties.

Moreover, we require that the training and update of a training can be performed only by the party that

creates the asset ﬁngerprint categoryFP.

We assume that an adversary has access only to the FP scanners of the corrupted parties. Each new
scanner has associated a tuple (Pi, deviceId), indicating that the scanner belongs to Pi and is identiﬁed
by deviceId. The device can be transferred from a party to another. In this case we assume that once the
handover happens, the owned of the device is updated. We assume that every time that operations of FF P
are called, the caller is the owner of the device on which the operation is performed and in the case of an
handover that the device is not jet engaged in another handover procedure.

The FF P functionality uses T raining and V erif y algorithms. T raining extracts a biochemical and
molecular mapping of a category, a kind of ﬁngerprint, based on sample products. We call the output of
T raining algorithm categoryFP and it is the speciﬁc ﬁngerprint of the category on which the training was
performed. This process is time-consuming and might make unusable the products on which it is performed.
V erif y takes an input a physical product and, thanks to some evaluations, can verify if the product belongs
to a category. V erif y has potentially a shorter process time than T raining and does not necessarily make
unusable the products on which it is performed. Since the veriﬁcation process requires that the function is
executed on a physical good, we require that also in the ideal world, the query is performed sending in input
the physical good, meaning that it is not possible to execute the V erif y algorithm, if there is no good to
check.

FF P runs with parties P1, . . . , Pn and adversary A. It begins with a list L initialized to ∅.

FF P Ideal Functionality

Init FP scanner. Whenever a party Pi ∈ {D } writes (initFF, Pi), FF P draws deviceId ← Sample(1λ).
FF P stores the following tuple in L: (Pi, deviceId, ) and sends (initializedFF, deviceId) to Pi
and A.

Training. Whenever a party Pi writes (trainFF, categoryId), then:

– If the training is successful and:

• A tuple (categoryId, ∗) does not exist, FF P stores the following tuple (categoryId, categoryFP)
in L, where categoryFP ← T raining(1λ, categoryId) and sends (initializedFF, categoryId,
categoryFP) to party Pi and A;

• A tuple (categoryId, ∗) already exists, FF P updates the following tuple (categoryId, ∗)
in L to (categoryId, categoryFP), where categoryFP ← T raining(1λ, categoryId) and
sends
(updatedFF, categoryId, categoryFP) to party Pi and A;

– If the training is not successful, FF P sends (trainingfailedFF, categoryId) to party Pi and

A.

Verify. Whenever a party Pi writes (evalFF, Pi, item, categoryId), where item is a physical product,

then FF P runs result ← V erif y(1λ, item, categoryId) and:

– If the veriﬁcation has produced a result, FF P sends (evaluedFF, result, deviceId, item, categoryId)

to party Pi and A.

– Otherwise, FF P sends (evalfailedFF, item, categoryId) to party Pi and A.

8

Handover. Whenever a party Pi writes (handoverFF, deviceId, Pi, Pj, ), FF P stores the tuple (receivedFF,
deviceId, Pi, Pj) in L and adds the tuple (Pj, deviceId) in L. FF P sends (receivedFF, deviceId, Pi,
Pj ) to Pi, Pj and A to indicate that a handover has occurred between Pi and Pj.

Device withdrawal. Whenever the party Pi ∈ {D } that creates a device deviceId writes (deleteDevice,
deviceId), FF P stores the following tuple (deleteDevice, Pi, deviceId). FF P stores the tuple
(deletedDevice, Pi, deviceId) in L and sends (deletedDevice, Pi, deviceId) to Pi and A.

Read. Upon input readFF from a party Pi or A, FF P returns to the caller a list of all records stored in

L, which matches parties to devices (e.g., of type (Pi, deviceId, ∗)).

4.3 Ledger Functionality FLedger

FLedger provides the abstraction of a transaction ledger. We assume that every submitted transaction is val-
idated before they are added to the list of transactions. The validation algorithm checks that the transaction
are not wrongly formatted and that the transaction was not submitted in the past. The validation algorithm
is required to guarantee the chain quality.

Anyone might request a read of the list L. We assume that the ledger is timestamped, live and immutable:
a valid transaction submitted to the ledger will eventually be included and cannot be deleted afterwards. In
a nutshell, valid transactions are appended, ﬁnal, and available to all parties [ACC+20]. In blockchains with
forks, a transaction can be considered ﬁnal when it has achieved suﬃcient conﬁrmations or has reached a
checkpoint. To achieve strong guarantees, a party might issue transactions relative to an account: a transac-
tion might contain an identiﬁer P, which is the abstract identity that claims ownership of the transaction.
We can represent this situation by having transactions tx be pairs (tx′, P) with the above meaning. FLedger
has a validation predicate.

FLedger runs with parties P1, . . . , Pn and adversary A. FLedger stores an initially empty list L of bit

FLedger Ideal Functionality

strings.

Submitting a transaction. Upon receiving I = (submitL, tx) from a party P, FLedger appends tx to
L and returns (submit, tx, P) to P. If P is corrupt, then FLedger returns (submit, tx, P) to A.
Reading the state. Upon receiving I = readL from a party P, FLedger returns (read, L) to P. If P is

corrupt, then FLedger returns (read, L) to A.

4.4 Digital Signature Functionality FSig

FSig models a digital signature scheme and consequently is parameterized by three algorithms KeyGen,
Sign and V erif y. We describe FSig using the same syntax of [ACC+20].

The signature scheme is unforgeability under chosen-message attack[GMR88], meaning that given an
oracle that generates valid signatures, it is infeasible for an eﬃcient adversary to output a valid signature on
a message that has not been queried to the oracle.

FSig requires sid = (Signer, sid′), where Signer is the party identiﬁer of the signer. Set C, initially
empty, speciﬁes the set of currently corrupted parties. The functionality keeps a set Σ of properly signed
messages.

FSig Ideal Functionality

Key generation. Upon the ﬁrst activation from Signer, FSig runs (pk , sk ) ← KeyGen(λ), where λ is

obtained from the security parameter tape, and stores (pk , sk ).

Send public key. Upon input pubkey from a party P, FSig outputs (pubkey, pk) to P.
Sign. Upon input (sign, m) from party Signer with m ∈ {0, 1}∗, FSig computes σ ← sign(sk , m).

Finally, FSig sets Σ ← Σ ∪ {m} and outputs σ to Signer.

9

Verify. Upon input (verif y, pk ′, m′, σ′) from a party P, FSig computes b ← verif y(pk ′, m′, σ′). If
6∈ Σ then FSig outputs (result, 0) to P. Else, FSig outputs

Signer 6∈ C ∧ pk = pk ′ ∧ b ∧ m′
(result, b) to P.

Corruption. Upon input (corrupt, P) from the adversary, FSig sets C ← C ∪ {P}. If P = Signer, then

FSig additionally outputs sk to A.

4.5 Secure Message Transmission Functionality FSM T

FSMT models a secure channel between a sender S and a receiver R. We describe FSig using the same syntax
of [ACC+20].

FSMT is for transmitting messages in a secure and private manner.

FSMT Ideal Functionality

Send message. Upon input (sendSMT, Pj, m) from a party Pi:

– If both Pi and Pj are honest, FSMT provides a private delayed output (sentSMT, Pi, Pj, m) to

– If at least one of Pi and Pj is corrupt, FSMT provides a public delayed output (sentSMT, Pi,

Pj.

Pj, m) to A.

5 The Real-World: Our System ΠSC

This section describes how our system works in the real world. Our supply chain protocol ΠSC realizes the
functionality FSC and operates with functionalities FLedger, FSMT , FSig and FF P .

As explained in Section 4.3, FLedger models a transaction ledger. To achieve strong guarantees, a party
issues transaction relative to an account. Signatures enter the picture at this level: an honest participant
of the network will issue only signed transactions on the network. Each party P has a signature key pair
(pk , sk ) obtained via FSig.

Whenever P is supposed to submit a transaction tx′, P signs it and appends the signature σ and its
party identiﬁer P. We deﬁne the transaction format as tx = (tx′, σ, P), where the ﬁrst part is an arbitrary
transaction. To verify the signature, it is important to provide the veriﬁcation key. This information must
be added in the transaction or must be possible to calculate it from the transaction data. We assume that
the public key for the signature veriﬁcation can be extracted from the party identiﬁer P. In the real world,
any blockchain system that realizes FLedger can be used. For our purpose, a reasonable choice is Hyperledger
Fabric[ABB+18], which oﬀers a membership service infrastructure [Faba] to grant long-term credentials to
network participants and supports a pluggable transaction validation [Fabb]. The functionality FSMT can be
implemented by establishing a secure communication channel between parties (e.g., via TLS protocol). FSig
can be accommodated by employing a digital scheme that secure realizes the functionality (e.g., ECDSA). In
the real world, the functionality FF P is realized by physical FP scanners that are able to verify the originality
of a product. We assume in FF P that the list of all allocated devices is available to all parties. This can
be achieved in the real world by involving an FP scanner issuer D . If a party wants to be provided with at
least one FP scanner to be able to perform quality checks on the items, the party has to request D . When
D issues a new FP scanner, it makes publicly available which FP scanner is associated with which party.

5.1 The Device Protocol ΠF P

The FF P functionality can be implemented for instance leveraging a scanner provided by a device producer
D .

10

Trust Assumptions on FP scanner. Obviously an adversary can not be forced to use well formed FP
scanners and thus we have made the following trust assumptions on the FP scanner in Section 4.2:

– Honest parties can verify the authenticity of the hardware (e.g., the integrity of its behavior). This means
that an adversary is unable to undetectably replace the FP scanner of a honest party with a malicious
one.

– The output of a genuine FP scanner can be linked to it.
– The adversary can not produce fake outputs on behalf of a genuine FP scanner.

We note that these assumptions might be reached in the real world with tamper-proof hardware. Tamper-
proof hardware has many similarities with our case study: an honest party can create a hardware token
implementing any desired polytime functionality and an adversary given the token can only observe the
input/output of this token [Kat07]. In our case study, the hardware token must be completely tamper-proof
if we want to guarantee the ﬁrst assumption. Typically (e.g., smart cards), tamper-proof hardware can
also generate digital signatures to certify the outputs that it produces. This makes a FP scanner uniquely
identiﬁable and capable of authenticating its outputs.

A FP scanner is required to support the following operations.

Training operation. Given a good, the device is able to extract the ﬁngerprint of the good that is digitally

stored. We call categoryFP the digital description of the ﬁngerprint.

Veriﬁcation. Given a physical good, and a ﬁngerprint description categoryFP, the device is able to check

that the given good belongs to the category of goods with ﬁngerprint categoryFP.

ΠF P Description. The operation performed by the protocol are stored on a ledger. The protocol ΠF P is
the following:

– Once the device is created, D submits the transaction tx = ((createFF, deviceId, D ), σ, (D , pk D , attrD , σD ))
via FLedger, to indicate that the device is created. To protect the validity of transactions, D generates
the signatures of the content of the transaction through invocation to FSig and append the received
signature together with user credentials to the transaction.

– Once the device is created, D handover the device to the party Pi that need it. To record this operation
D submits the transaction tx = ((handover, deviceId, D , Pi), σ, (D , pk D , attrD , σD )) which indicates
that an FP scanner has been sent to Pi. D generates σ through invocation to FSig.

– Any party Pi that owns the device can decide to handover the device to a party Pj. To record this
operation Pi submit the transaction tx = ((handover, deviceId, Pi, Pj), σ, (Pi, pk Pi , attrPi , σPi )) which
indicates that an FP scanner has been sent to Pj. Pi generates σ through invocation to FSig.

– Any party Pi that owns the device can perform a training on a good to obtain the ﬁngerprint categoryFP
of the category of the good. The device performs this operation using information of the good to an-
alyze. To record this operation, Pi submits transaction tx = ((categoryId, categoryFP), σ, (Pi, pk Pi ,
attrPi , σPi )). Pi generates σ through invocation to FSig.

– Any party Pi that owns the device can perform a veriﬁcation on a physical asset given the expected
category identiﬁer categoryId at which the asset belongs. The device performs this operation using
information of the good to analyze. Pi reads the ledger to obtain the ﬁngerprint categoryFP associated
to categoryId and performs the analysis with categoryFP. This operation returns a digital information
auditData.

– If the device issuer D that issues a device deviceId needs to withdraw this device from the marked (i.e.,
this device is broken), D submits the following transaction tx = ((deleteDevice, deviceId, D ), σ, (D ,
pk D , attrD , σD )) via FLedger. This transaction indicates that the device cannot be used anymore by
parties in the system.

– Every user can read the blockchain to obtain information about devices and asset categories stored.

We have the following assumption:

– the creation of devices is always performed honestly and no device issuer misbehaves;

11

– the device withdrawal of a device is always performed honestly by the device issuer that issues the device;
– the training process is always performed honestly since the process is supervised by an honest controller.

The only actions that an adversary A can try to perform in the real word is to impersonate a device
issuer to issue misbehaving devices or set to deletedDevice devices that have not really been withdrawn.
This attack cannot be performed except that A is able to break the unforgeability of the signature scheme.

5.2 The Protocol ΠSC

The building block of the protocol ΠSC is an SC-smart contract CSC , that manages the supply chain
activities. It has an initially empty state variable of form st = (assetId, assetValue), where assetId is an
asset identiﬁer and assetValue is the asset’s current state.

Each asset in the system has a unique identiﬁer. The identiﬁer is used to capture important information
on the movement of assets along the supply chain and might be of the form E2344..., where the ﬁrst character
identiﬁes the asset’s type, in this case, Element, and the remaining characters uniquely identify the asset
among this type. The remaining characters may be obtained, for example, by randomly generating a value
r ← {0, 1}λ that has to be unique. The identiﬁer may also be obtained by using existing open standards
such as the Electronic Product Code (EPC).

Access control policies must be deﬁned to model the real-world constraint where each party, according
to its role in the supply chain, can perform diﬀerent operations on an asset. As explained in Section 2.2
and 2.2, we assume the existence of a single trusty registration authority Reg responsible of register other
participants in the system with long-term credentials. Reg has a unique unforgeable identity that is available
to all nodes in the network. At setup, Reg generates a key pair corresponding to the Reg identiﬁer. The public
information of Reg is stored in the genesis block. The smart contract and the access control policies realize our
functionality FSC . They are initialized during the setup phase of the system by an authorized group member
(i.e., registration authorities). In a nutshell, the protocol’s initiation consists of the setup of the blockchain
global parameters. The CSC handles all the transaction describes below and is executed by blockchain nodes.
We assume that the smart contract correctly updates the state accordingly to the transaction retrieved by
the ledger (i.e., is trusted to execute correctly). Before applying the state changes that come with the
transaction itself, the smart contract performs various checks to be sure that the transaction satisﬁes the
access control policies and the logic that the contract implements. In short, CSC veriﬁes the authorization
of the transaction submitter and stores authenticated and veriﬁed tracing information on a product. In our
case study, for example, we have the following constraints.

– Speciﬁc transactions can be performed only by parties with a particular role (i.e., access control policies).
– Any write operation on an item can be carried out only by the current owner.
– The product data must satisfy the speciﬁcation of the validity of the product. So, CSC might perform
automated regulatory-compliance veriﬁcations by checking that all the information required by regulation
is provided.

– Speciﬁc operations can be performed only on speciﬁc types of asset (e.g., an aggregation can occur only

for Batch or Element but not for Product Area or Category).

The protocol starts with parties’ registration since registration is needed for all writing operations. When
a participant sends a registration request with attributes certiﬁcation to Reg, the registration authority
veriﬁes the received information and registers the participant in the system with long-term credentials. Let
us start by describing the protocol machine for Reg. Reg has a bit initialized ← f alse and an initially
empty list L of certiﬁed parties’ credentials. We assume private channels between the registration authority
and the parties.

– Upon input init, Reg checks if initialized is set. If set, Reg aborts. Else, Reg generates a signature
key pair (pk R, sk R) via invocations to FSig and Reg stores, pk R, sk R. The public information of the
registration authority, the identiﬁer and the public key pk R are stored in the genesis block of the ledger.
Reg sets initialized ← true and set the list of registered users L to empty.

12

– Upon receiving (register, Pi, pk i, attri) from Pi via FSMT , where attri are party’s attributes, Reg
signs (Pi, pk i, attri) and obtains the signature σi that will be used by Pi together with pk i, attri as
his credential for the system. The signature σi is computed through invocation to FSig. Reg stores
(Pi, pk i, attri, σi) in L and sends the message (registered, Pi, pk i, attri, σi) via FSMT to Pi.

The protocol for D is the following. At setup, D generates a key pair corresponding to its identiﬁer and
requests Reg for registration and attributes certiﬁcation through a secure channel. If the authentication is
successful, D receives its party credentials σD with which D can issue new FP scanners in the system. We
describe the protocol for a party D of the system. D has a bit registered ← f alse.

– Upon input register, D generates a signature key pair (pk D , sk D ) via invocations to FSig and a unique
identiﬁer D . It sends a message (register, D , pk D , attrD ) to Reg via FSMT . If all steps succeeded, then
PD sets registered ← true and stores D , pk D , sk D , attrD , σD . The registration phase is mandatory
for each party that needs to submit transactions.

– D creates new devices calling FF P with input (initFF, D ). The operation will produce a device identiﬁer

deviceId.

– If D needs to withdraw a device produced by himself from the market (e.g., this speciﬁc device type is
not working properly), D calls FF P with input (deleteDevice, deviceId). This transaction indicates
that an FP scanner cannot be used anymore by parties in the system.

Let us now describe the protocol for a party Pi not already analyzed before. At the setup, Pi generates a
key pair corresponding to its identiﬁer and requests Reg for registration and attributes certiﬁcation through
a secure channel. If the authentication is successful, Pi receives its party credentials σi with which Pi can
perform operations in the system if it satisﬁes the access control policies. Pi has a bit registered ← f alse.
Every time that a party Pi submits a transaction tx, the tuple tx′ contains the following 5 values:

1. The operation that Pi wants to perform.
2. The unique identiﬁer of the item to create.
3. The category to which the new item belongs. This parameter might be a meaningless value if the item’s

category is not deﬁned.

4. It is also possible for the party Pi that has submitted the transaction to specify, in case of a raw element
(e.g., tomato, olive, etc.), the product area from which it is produced. In this way, a user can also oﬀer
full traceability on the production phases that led to that product. This parameter is the production
area’s unique identiﬁer.

ΠSC for a party Pi is the following.

– Upon input register, Pi generates a signature key pair (pk i, sk i) via invocations to FSig and a unique
identiﬁer Pi. It sends a message (register, Pi, pk i, attri) to Reg via FSMT . The value attri contains the
role of party together with other additional information. If all steps succeeded, then Pi sets registered ←
true and stores Pi, pk i, sk i, attri, σi.

– When Pi wants to be provided with an FP scanner, Pi sends the message (device, Pi) to D via FSMT

and D sends message (handoverFF, D , Pi) to FF P .

– If Pi wants to create a new element, Pi creates the transaction tx′ = (create, itemId, categoryId,
areaId). After that, Pi can submit the transaction tx = (tx′, σ, (Pi, pk i, attri, σi)) via FLedger. The
signature σ of tx′ is obtained through invocation to FSig.

– If Pi wants to record a new product area, it submits the transaction tx = ((produce, areaId, ), σ, (Pi,

pk i, attri, σi)). The signature σ of tx′ is obtained through invocation to FSig.

– If Pi wants to create a new element, that is obtained by combining other stored items, it submits the
transaction tx = ((transform, itemId, items, categoryId), σ, (Pi, pk i, attri, σi)), where items is an
array of item identiﬁers items = [(itemId1), . . . , (itemIdl)]. The signature σ of tx′ is obtained through
invocation to FSig.

13

– If Pi performs a training on a category categoryId, Pi sends (trainFF, categoryId) to FF P . If the
training has returned a result categoryFP, Pi submits the transaction tx = ((training, categoryId,
categoryFP), σ, (Pi, pk i, attri, σi)). The signature σ of tx′ is obtained through invocation to FSig.

– Every time Pi

inspects an item using an allocated FP scanner6, Pi performs the following opera-
tion. First executes the veriﬁcation sending (evalFF, Pi, itemId, categoryId) to FF P . If the veriﬁ-
cation has returned a result (result, deviceId, itemId, categoryId), submits the transaction tx =
((audit, itemId, auditData), σ, (Pi, pk i, attri, σi)), where auditData = (deviceId, result, deviceId,
itemId, categoryId). Before accepting the transaction tx, CSC query FF P to check that the device with
identiﬁer deviceId is valid and is not withdrawn. If during the veriﬁcation phase has been chosen to
return a more complex output, such as the value of the parameters evaluated, then it is possible to save
on-chain this information for a more complete audit. If Pi is a Certiﬁer, the audit recorded will be more
accurate.

– If Pi wants to aggregate diﬀerent stored items in a single package, it submits the transaction tx =
((merge, batchId, products), σ, (Pi, pk i, attri, σi)), where products is an array containing the item iden-
tiﬁer. The signature σ of tx′ is obtained through invocation to FSig.

– If Pi wants to disaggregate a package to retrieve stored items, it submits the transaction tx = ((split,

batchId), σ, (Pi, pk i, attri, σi)). The signature σ of tx′ is obtained through invocation to FSig.

– If Pi wants to update an asset’s state, it submits the transaction tx = ((update, p, newstate), σ, (Pi, pk i,
attri, σi)), where newstate is the update of the state of the product that can be set from intact or
packaged to destroyed. The signature σ of tx′ is obtained through invocation to FSig.

– If Pi wants to transfer an asset to another party Pj, it should do this by submitting the transaction
tx = ((handover, p, Pi, Pj), σ, (Pi, pk i, attri, σi)). If Pj wants to reject an asset from Pi that was sent
to Pj, Pj can do this by submitting the transaction tx = ((rejected, p, Pj, Pi), σ, (Pj , pk j, attrj, σj)).
If Pj wants to accept an asset from Pi that was sent to it, Pj can do this by submitting the transaction
tx = ((received, p, Pj, Pi), σ, (Pj , pk j, attrj, σj)).

– The party Pi transmits only transactions. When Pi wants to retrieve an asset state, it relies upon
blockchain consensus nodes, who process transactions. In this case, Pi sends the following request
(readSC, assetId) to one or multiple consensus nodes via FSMT to obtain a list of all value changes
of assetId. As explained before, Pi can perform read operations even if is not registered in the system.

All data that a party P wants to transmit to FLedger are previously signed through invocations to
FSig. The data, together with the signature and P credentials, are submitted to FLedger. When creating a
transaction, the data entry can be automated and speed up through IoT devices, QR code scanning, and so
on.

6 Security Model

This section provides the security model of our system.

6.1 Security Analysis

Theorem 1. For all A, there exists a simulator S for non-uniform distinguisher Z protocol ΠSC securely
computes FSC in the (FF P , FLedger, FSMT , FSig)-hybrid model.

Proof. We need to show that for every PPT adversary A, there exists a PPT simulator S such that no
non-uniform PPT distinguisher Z can tell apart the experiments
REAL

(λ) and IDEALFSC,S,Z(λ).

FF P ,FLedger,FSM T ,FSig
ΠSC ,A,Z

We deﬁne a simulator S that interact with FSC. We consider only static corruptions, (i.e., the choice of
which players to attack is made before the protocol starts). S emulates functionalities FLedger, FSig, FSMT
and FF P . S initially sets initialized ← f alse.

6 The FP scanner has to be valid and not withdrawn by the market.

14

Simulating parties’ registration. Upon receiving (registeredSC, Pi) from FSC, S veriﬁes that initialized
is set to true. If the veriﬁcation fails, S ﬁrst simulates the system initialization. S creates and stores, as
the real Reg, a signature key pair pk ∗
R generated using FSig. Finally, S sets initialized ← true.
Once that initialized ← true, if Pi is honest, S generates a signature key pair (pk ∗
i , sk ∗
i ) via the
simulated FSig as the real Pi and marks Pi as registered. If Pi is corrupt, S initializes (pk ∗
i , sk ∗
i ) with
the received values. S runs the Reg algorithm with input (register, Pi, pk ∗
In both cases, S, as the real Reg, signs the message (Pi, pk ∗
and sends σ∗

i to Pi. S marks Pi as registered and internally stores (Pi, (pk ∗
Simulating honest regular parties. The actions of honest parties are simulated as follows.

i , attri) via the simulated FSig to obtain σ∗
i
i ), σ∗

i , attri).

R, sk ∗

i , sk ∗

i ).

– Upon input (createdSC, Pi, itemId, categoryId, areaId) from FSC , S creates tx = ((create, itemId,
i )) and submits it to the ledger using FLedger as the real

categoryId, areaId), σ∗, (Pi, pk ∗
Pi, where σ∗ is the signature of (create, itemId, categoryId, areaId) with key sk ∗

i , attri, σ∗

– Upon input (producedSC, Pi, areaId) from FSC, S simulates for Pi the creation and submission of

i using FSig.

the equivalent transaction as seen before.

– Upon input (transformedSC, Pi, itemId, categoryId, items) from FSC, S simulates for Pi the cre-

ation and submission of the equivalent transaction as seen before.

– Upon input (mergedSC, Pi, batchId, products) from FSC, S simulates for Pi the creation and sub-

mission of the equivalent transaction as seen before.

– Upon input (splittedSC, Pi, batchId) from FSC, S simulates for Pi the creation and submission of

the equivalent transaction as seen before.

– Upon input (handoverSC, p, Pi, Pj) from FSC, S simulates for Pi the creation and submission of the

equivalent transaction as seen before.

– Upon input (rejectSC, p, Pj, Pi) from FSC, S simulates for Pi the creation and submission of the

equivalent transaction as seen before.

– Upon input (receivedSC, p, Pi, Pj) from FSC, S simulates for Pi the creation and submission of the

equivalent transaction as seen before.

– Upon input (auditSC, Pi, itemId, auditData) from FSC. S checks if Pi owns a device. If Pi does
not own a device S generates a new device calling FF P with input (initFF, D ). Once FF P returns
(initializedFF, deviceId), S simulates the handover from D to Pi sending message (handoverFF, D , Pi)
to FF P . After that these two operations are performed, S submits the transaction tx = ((audit, itemId,
auditData), σ, (Pi, pk i, attri, σi)). σ is the signature of (audit, itemId, auditData) with key sk i us-
ing FSig.

– Upon input (trainedSC, Pi, categoryId, categoryFP) from FSC, S checks if Pi owns a device. If
Pi does not own a device S generates a new device calling FF P with input (initFF, D ). Once
FF P returns (initializedFF, deviceId), S simulates the handover from D to Pi sending message
(handoverFF, D , Pi) to FF P . S submits the transaction tx = ((training, categoryId, categoryFP),
σ, (Pi, pk i, attri, σi)). σ is the signature of (training, categoryId, categoryFP) with key sk i using
FSig.

Simulating corrupted regular parties. Let A be an adversary corrupting a party Pi.

– When A instructs the party Pi to register, Pi generates (pk , sk ) invoking FSig and sends the message
(register, Pi, pk i, attri) to S via FSMT . S writes (registerSC, Pi) to the input tape of FSC . S
generates the signature σi simulating the algorithm of Reg using the private key sk Reg . S stores
(Pi, pk i, attri, σi) and sends (registered, Pi, pk i, attri, σi) via FSMT to Pi.
When A instructs the party Pi to request an FP scanner, Pi inform D . If D has an available device
(i.e., a created device not yet sold), D send message (handoverFF, D , Pi) to FF P to inform the
functionality of the handover and gives the device to Pi. Otherwise, D sends message (initFF, Pi) to
FF P to create a new device and then performs the handover operation.

– When A instructs the party Pi to create a new production lot, Pi sends the transaction tx =
((create, itemId, categoryId, areaId), σ, (Pi, pk i, attri, σi)) via FLedger. S writes (createSC, Pi,
itemId, categoryId, areaId) to the input tape of FSC .

– When A instructs the party Pi to create a new production area, Pi sends the transaction tx =
((produce, areaId), σ, (Pi, pk i, attri, σi)) via FLedger. S writes (produceSC, Pi, areaId) to the input
tape of FSC.

15

– When A instructs the party Pi to create a new transformed product, Pi sends the transaction tx =
((transform, itemId, items, categoryId), σ, (Pi, pk i, attri, σi)) via FLedger. S writes (transformSC,
itemId, Pi, items, categoryId) to the input tape of FSC .

– When A instructs the party Pi to create a new training activity, Pi sends message (trainFF, categoryId)
to FF P obtaining back the value categoryFP associated to categoryId. Pi sends the transaction tx =
((training, categoryId, categoryFP), σ, (Pi, pk i, attri, σi)) via FLedger. S writes (trainingSC, Pi,
categoryId, categoryFP) to the input tape of FSC .

– When A instructs the party Pi to create a new audit activity, Pi sends message (evalFF, Pi, itemId,
categoryId) to FF P obtaining the result of the audit. Pi sends the transaction tx = ((audit, itemId,
auditData), σ, (Pi, pk i, attri, σi)) via FLedger. S writes (auditSC, Pi, itemId, categoryId, auditData)
to the input tape of FSC .

– When A instructs the party Pi to merge a set of products, Pi sends the transaction tx = ((merge,
batchId, products), σ, (Pi, pk i, attri, σi)) via FLedger. S writes (mergeSC, Pi, batchId, products) to
the input tape of FSC.

– When A instructs the party Pi to split a set of products, Pi sends the transaction tx = ((split, batchId),

σ, (Pi, pk i, attri, σi)) via FLedger. S writes (splitSC, Pi, batchId) to the input tape of FSC.

– When A instructs the party Pi to update a product, Pi sends the transaction tx = ((update, p,
newstate), σ, (Pi, pk i, attri, σi)) via FLedger. S writes (updateSC, Pi, p, newstate) to the input tape
of FSC.

– When A instructs the party Pi to handover a product to a party Pj, Pi sends the transaction
tx = ((handover, p, Pi, Pj), σ, (Pi, pk i, attri, σi)) via FLedger. S writes (handoverSC, p, Pi, Pj) to the
input tape of FSC.

– When A instructs the party Pi to reject a received asset from Pj, Pi sends the transaction tx =
((rejected, p, Pi, Pj), σ, (Pi, pk i, attri, σi)) via FLedger. S writes (rejectSC, p, Pi, Pj) to the input
tape of FSC.

– When A instructs the party Pi to reject a received asset from Pj, Pi sends the transaction tx =
((received, p, Pi, Pj), σ, (Pi, pk i, attri, σi)) via FLedger. S writes (receiveSC, p, Pi, Pj) to the input
tape of FSC.

– If a party P is corrupt, A can instruct P to register/request an FP scanner, as seen for PF , and

submit role-compliant transactions.

– If A instructs a corrupted party P to read the entire history of an asset assetId, S writes (readSC, assetId)

to the input tape of FSC .

Simulating corrupted parties interacting with FF P . Let A be an adversary corrupting a party Pi.

– When A instructs the party Pi to perform an audit, Pi sends message (evalFF, Pi, item, categoryId)
If Pi is the owner of itemId, S computes the veriﬁcation algorithm of FF P and returns

to FF P .
(evaluedFF, result, deviceId, item, categoryId) or (evalfailedFF, item, categoryId) to Pi.

– When A instructs the party Pi to perform an handover of a device, Pi sends message (handoverFF, Pi, Pj)

to FF P and the handover is performed.

We consider a sequence of hybrid experiments (ending with the real experiment) and argue that each
pair of hybrids is computationally close thanks to the properties of the underlying cryptographic primitives.

Hybrid H3(λ): This experiment is identical to IDEALFSC ,S,Z(λ).
Hybrid H2(λ): H2(λ) is identical to H3(λ) except that S will run the Reg algorithm to generate the
signature key pair (pk Reg, sk Reg) for the registration activities. Each party Pi that wants to use the system
needs to generate a signature key pair (pk i, sk i) using FSig. Whenever a party Pi asks for registration,
Pi sends pk i and attri. S signs (Pi, pk i, attri) calling FSig and obtains the signature σi that will be
used by Pi together with pk i, attri as his credential for the system. S stores (Pi, pk i, attri, σi) in L as
identiﬁer of Pi instead of using Pi.

Hybrid H1(λ): H1(λ) is identical to H2(λ) except that every time that a party Pi sends a command to
the system, Pi will sign the command using the signature secret key sk i and append the signature to the
command together with the party identiﬁer.

16

Hybrid H0(λ): This experiment is identical to REAL

FF P ,FLedger,FSM T ,FSig
ΠSC ,A,Z

(λ).

Lemma 1. {H3(λ) ≈c H2(λ)}λ∈N

Proof. We reduce to unforgeability of the signature scheme. Indeed A can try to impersonate a diﬀerent user
forging the signature generated by the registration authority. In this case, A knows only pk Reg, and tries to
generate a σi for a corrupted party Pi to play in the system. If Z distinguishes H3(λ) form H2(λ), we will
use Z to break the unforgeability of the signature scheme. Let Chall be the challenger of the signature scheme
and ASig the adversary that wants to break the signature unforgeability:

– Chall generates the signature key pair (pk Chall, sk Chall) and sends pk Chall to ASig;
– ASig runs the experiment using as public key for the registration authority the value pk Chall;
– if ASig receives a message from a not registered party Pi containing as party identiﬁer the tuple

(Pi, pk i, attri, σi) and (verif y, pk Chall, (Pi, pk i, attri), σi) is true, ASig returns to Chall the values (Pi, pk i, attri), σi.

This breaks the unforgeability property of the signature scheme, but the signature unforgeability can be
broken only with negligible probability.

Lemma 2. {H2(λ) ≈c H1(λ)}λ∈N

Proof. The diﬀerence between H2(λ) and H1(λ) is that in the transaction stored in H2(λ) the command is
signed. An adversary A can try to send a command for which A has no right forging the signature of another
user. A tries to send a message as Pi, where Pi is a registered party, without knowing the Pi signature secret
key sk i. If the transaction is accepted, it is possible to deﬁne an adversary ASig that breaks the signature
unforgeability against a challenger Chall:

– Chall generates the signature key pair (pk Chall, sk Chall) and sends pk Chall to ASig;
– ASig registers a party Pi to the experiment using message (register, Pi, pk Chall, attri);
– ASig can check if A is able to produce a transaction tx = (tx′, σ, (Pi, pk Chall, attri)) as user Pi, where

tx′ is a command. In this case ASig returns to Chall the values (tx′, σ).

This breaks the unforgeability property of the signature scheme, but the signature unforgeability can be
broken only with negligible probability.

Lemma 3. {H1(λ) ≈c H0(λ)}λ∈N

Proof. The only diﬀerence between H1(λ) and H0(λ) is that H0(λ) uses FLedger to store data instead of
using an internal list L. The simpliﬁed ledger functionality FLedger permits to every party to append bit
strings to an available ledger, and every party can retrieve the current ledger. FLedger is local functionality
that guarantees that transactions are immediately appended, ﬁnal, and available to all parties. Then, it is
not possible to distinguish between the two diﬀerent experiments.

This ends the proof of Theorem 1.

7

Improvements

In this section, we present and discuss issues and related improvements regarding the actual proposed system.

Decentralizable registration authority/ FP scanner issuer. To keep the presentation simple, the pro-
tocol formalizes the functionality for the case of a single trusty registration authority. This trust assump-
tion might be relaxed distributing the registration process by employing threshold signature, secret
sharing, etc. We can relax the trust assumption made on the FP scanner issuer in Section 2.2 via decen-
tralization. When we have several authorized FP scanner issuers, even if an FP scanner issuer misbehaves
by creating malicious FP scanner issuers, this behavior can be detected by other honest parties equipped
with trusted FP scanners as analyzed in Section 5.1.

17

Private data. There are cases in which a group of participants needs to store for audit purposes conﬁdential
data on-chain. This data must be kept private from other network participants. In a nutshell, a party
might want to have separate private data relationships with other parties to keep private its purchasing
and charging policies. For example, a wholesaler might want to hide the number of products purchased
from each distributor or a manufacturer might want to hide the number of raw materials used per
product. At the same time, to avoid counterfeiting, the product tracing system must guarantee that the
entities cannot introduce more products than purchased passing them as the originals. Crypto solutions
that can be used to guarantee both privacy preservation, public veriﬁability, and correctness of data
in blockchains are homomorphic encryption, commitment scheme, . . . . In homomorphic encryption the
encryption function has some properties that allow combining two encryptions into a third encryption
of a value related to the original two, (i.e., the sum), as if such operations had been performed over
the cleartext. A commitment scheme, instead, allows a party to commit to a secret value while keeping
it hidden to others (hiding), with the ability to reveal the committed value later. It is infeasible for
the committer to change the value after it has been committed (binding). The private data are stored
oﬀ-chain by authorized organizations and only a commitment, (e.g., a hash of that data) is written to the
ledgers and visible to every peer in the blockchain. The commitment serves as evidence and can be used
for audit purposes. Authorized organizations might decide to share the private data via secure message
channels with other parties if they get into a dispute or agreement. The parties can now compute the
commitment of the private data and verify if it matches the on-chain commitment, proving that the data
existed at a certain point in time.

Credentials management. As explained in Section 2.2, during the party’s registration Reg can assign
diﬀerent attributes as the role. These attributes can be used also to add further constraints on the
operations that a party can perform according to the role. In the case of Producers or Manufacturers,
they must be able to create new products only belonging to the categories that have been approved by
Reg during the registration. We keep this aspect quite general. We note that further checks should be to
verify if the speciﬁed location is consistent with the product certiﬁed for that user. Similar operations
can also be done for other roles.

8 Conclusions

In this work we have formally proposed and analyzed a system for tracing physical goods leveraging
blockchain technology. A core component of our system is the possibility of verifying the correspondence
among physical goods and their on-chain digital twins. Our system is based on a model that can be easily
adapted to accommodate additional features (e.g., secret business).

Acknowledgements. We thank Giorgio Ciardella for several remarks and explanations on the potential of food
traceability and the eﬀectiveness of biological ﬁngerprint scanning. This work has been supported in part by
a scholarship funded by Farzati Tech, in part by the European Union’s Horizon 2020 research and innovation
programme under grant agreement No 780477 (project PRIViLEDGE), and in part by a scholarship funded
by Campania Region.

References

ABB+18. Elli Androulaki, Artem Barger, Vita Bortnikov, Christian Cachin, Konstantinos Christidis, Angelo De
Caro, David Enyeart, Christopher Ferris, Gennady Laventman, Yacov Manevich, Srinivasan Muralidharan,
Chet Murthy, Binh Nguyen, Manish Sethi, Gari Singh, Keith Smith, Alessandro Sorniotti, Chrysoula
Stathakopoulou, Marko Vukolic, Sharon Weed Cocco, and Jason Yellick. Hyperledger fabric: a distributed
operating system for permissioned blockchains.
In Proceedings of the Thirteenth EuroSys Conference,
EuroSys 2018, Porto, Portugal, April 23-26, 2018, pages 30:1–30:15. ACM, 2018.

ACC+20. Elli Androulaki, Jan Camenisch, Angelo De Caro, Maria Dubovitskaya, Kaoutar Elkhiyaoui, and Bj¨orn
Tackmann. Privacy-preserving auditable token payments in a permissioned blockchain system. In AFT

18

’20: 2nd ACM Conference on Advances in Financial Technologies, New York, NY, USA, October 21-23,
2020, pages 255–267. ACM, 2020.

ATdM17. Tomaso Aste, Paolo Tasca, and Tiziana di Matteo. Blockchain technologies: The foreseeable impact on

Can01.

society and industry. Computer, 50(9):18–28, 2017.
Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols.
In 42nd
Annual Symposium on Foundations of Computer Science, FOCS 2001, 14-17 October 2001, Las Vegas,
Nevada, USA, pages 136–145. IEEE Computer Society, 2001.
Hyperledger Fabric. Membership Service Providers (MSP).
Hyperledger Fabric. Pluggable transaction endorsement and validation.

Faba.
Fabb.
GMR88. Shaﬁ Goldwasser, Silvio Micali, and Ronald L. Rivest. A digital signature scheme secure against adaptive

chosen-message attacks. SIAM J. Comput., 17(2):281–308, 1988.

Kat07.

GMW87. Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or A completeness
In Proceedings of the 19th Annual ACM Symposium on

theorem for protocols with honest majority.
Theory of Computing, 1987, New York, New York, USA, pages 218–229. ACM, 1987.
Jonathan Katz. Universally composable multi-party computation using tamper-proof hardware. In Moni
Naor, editor, Advances in Cryptology - EUROCRYPT 2007, 26th Annual International Conference on the
Theory and Applications of Cryptographic Techniques, Barcelona, Spain, May 20-24, 2007, Proceedings,
volume 4515 of Lecture Notes in Computer Science, pages 115–128. Springer, 2007.

PHJ+20. Tharangana Perera, Sithija Piyuman Thewa Hettige, Shadhini AP Jayatilake, Wickramaranga Abeygu-
nawardhana, and HMN Dilum Bandara. Blockchain-based product traceability beyond proof of existence.
In 2020 Moratuwa Engineering Research Conference (MERCon), pages 1–6. IEEE, 2020.
Feng Tian. An agri-food supply chain traceability system for china based on rﬁd blockchain technology. In
2016 13th International Conference on Service Systems and Service Management (ICSSSM), pages 1–6,
2016.

Tia16.

VSM+12. C. N. Verdouw, Harald Sundmaeker, F. Meyer, J. Wolfert, and J. Verhoosel. Smart agri-food logistics:
Requirements for the future internet. In Dynamics in Logistics, Third International Conference, LDIC
2012, Bremen, Germany, February 27 - March 1, 2012, Proceedings, Lecture Notes in Logistics, pages
247–257. Springer, 2012.

19

