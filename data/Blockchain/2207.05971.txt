Smart Red Belly Blockchain: Enhanced Transaction
Management for Decentralized Applications

Deepal Tennakoon, Vincent Gramoli
dten6395@uni.sydney.edu.au,vincent.gramoli@sydney.edu.au
The University of Sydney
Australia

Abstract
Decentralized Applications (DApps) have seen widespread
use in the recent past driving the world towards a new de-
centralized version of the web known as Web3.0. DApp-
supported blockchains like Ethereum have largely been re-
sponsible for this drive supporting the largest eco-system of
DApps. Although the low performance provided by Ethereum
has been a major impediment to realizing a decentralized
web, several high-performance blockchains have been intro-
duced recently to bridge this gap. Most of these blockchains
rely on consensus optimizations. Only a few enhance other
parts of the blockchain protocol that involves transaction
management: the validation of transactions, broadcast of
transactions, encapsulation and dissemination of blocks with
transactions, re-validation and execution of transactions in
blocks, storage of blocks, and confirmation of transaction
commits to senders upon request.

In this paper, we enhance transaction management by
introducing a novel transaction validation reduction, hash-
ing optimization to fasten the transaction execution, a per
sub-block processing to optimize the block storage, and a
caching optimization for fast retrieval of committed transac-
tions. We empirically show the performance improvements
gained by our enhanced transaction management in the
Smart Red Belly Blockchain (SRBB) VM we develop. Finally,
we integrate our SRBB VM to an already optimized con-
sensus from a known blockchain to develop the Smart Red
Belly Blockchain. Our results show that SRBB achieves a
peak throughput of 4000 TPS and an average throughput of
2000 TPS on 200 nodes spread across 5 continents. SRBB out-
performs 6 other blockchains when running the exchange
DApp featuring a real workload trace taken from Nasdaq.

2
2
0
2

l
u
J

3
1

]

C
D
.
s
c
[

1
v
1
7
9
5
0
.
7
0
2
2
:
v
i
X
r
a

1 Introduction
As the number of misuses of Internet data grows due to the
centralization of the Web [28], so does the need for decen-
tralized middleware rewarding individuals for sharing data.
This centralization has severe drawbacks: it exposes data to
leaks and hacks [26] and it facilitates user manipulation [33].
Although Ethereum [38] promised to decentralize the Web
by offering decentralized applications (DApps) written as
smart contracts, it remains inherently slow. The crux of the
problem stems from its transaction management [32].

1

The classic way of managing transactions (i.e., transaction
management) in Ethereum [38] and Bitcoin [29] consists
of miners validating each transaction upon reception, dis-
seminating a transaction to other validators, encapsulating
transactions in a block, disseminating this block to other
validators, re-validating and executing the block transac-
tions [19, 38], storing blocks and finally the sender confirm-
ing that the transaction is committed. This process has major
shortcomings such as every validator having to validate each
transaction twice, the reading of transactions, and storing of
blocks requiring expensive I/O. This is the reason, one needs
an enhanced transaction management to speedup blockchains
supporting DApps.

While various efforts focus on consensus optimizations [14,
18, 30, 42], fewer efforts focus on enhancing the transaction
management [24, 32, 39] in blockchains. Some of these ef-
forts trade-off security for improved performance [39] [32]
while others work only in test environments [27].

In this paper, we enhance transaction management by
introducing a novel transaction validation reduction, a hash-
ing optimization for transaction execution speedup, a per
sub-block storage optimization for storage of blocks, and a
caching optimization for fast retrieval of committed transac-
tions.

First, we divide the number of necessary validations by
two by not requiring all validators to eagerly validate every
transaction when it is submitted but by requiring all miners
to only lazily validate this transaction upon execution. By val-
idating twice less we reduce the validation time of Ethereum
by up to 48% when the number of validators is large. Sec-
ond, we process and store sub-blocks in a block yielding a
throughput improvement of 39.7%. Third, building upon a
consensus that commits transactions fast [17], we reduce
I/O by caching the data of freshly committed transactions
for fast retrieval by the transaction sender for confirmation.
Hence, we double the throughput of the Ethereum transac-
tion management on a machine with 8 vCPUs, and 16 GiB of
memory. Next, we changed the state data structure hashing
algorithm from Sha-256 to Blake3 to gain a throughput
improvement of up to 7%.

To illustrate the applicability of our optimizations, we im-
plemented our enhanced transaction management with the
consensus of the Red Belly Blockchain [18], a fast blockchain

 
 
 
 
 
 
that does not support DApps (i.e. smart contracts), to ob-
tain the Smart Red Belly Blockchain (SRBB) that supports
the largest ecosystem of DApps. We deploy SRBB in a geo-
distributed setting of 200 machines located across 5 conti-
nents. We compare its performance on the Nasdaq applica-
tion of the Diablo benchmark [11], featuring the real trace
of Apple, Amazon, Facebook, Microsoft, and Google stock
trades. Not only does SRBB commit all transactions but it
outperforms Algorand [25], Avalanche [34], Ethereum [38],
Libra-Diem [22], Quorum [16] and Solana [41]. Finally, SRBB
achieves a peak throughput of 4000 TPS and an average
throughput of ~2000 TPS. In summary, our technical con-
tributions include the following:

• To reduce the CPU usage of the EVM, we (i) reduced
transaction validation time by 48% without weakening
security (Section 3.2) and (ii) replaced the Sha256 hash-
ing of the Ethereum state data structure with Blake3
hashing (Section 3.4) to improve throughput by up to
a further 7%.

• To reduce the I/O delays of the EVM, we (i) broke
large blocks into sub-blocks to be processed one at
a time (Section 3.3), hence improving throughput by
39.7%, and (ii) cached blocks and transaction receipts
before chain insertion for fast retrieval (Section 3.4),
hence improving throughput by up to 45% and 100%
respectively.

• To illustrate the benefit of these optimizations in a
realistic setting, we integrated this enhanced trans-
action management into a blockchain combining the
optimized EVM (i.e., SRBB VM) with the consensus
of the Red Belly Blockchain [18] to obtain Smart Red
Belly Blockchain. Not only does SRBB show a 3.2×
speedup in throughput over the naive blockchain with
the EVM and the Red Belly Blockchain consensus sim-
ply plugged together (Section 4.4), but it also outper-
forms 6 state-of-the-art blockchains when running a
realistic exchange DApp (Section 4.6).

In the remainder of the paper, we present our background
and assumptions (Section 2). We then present SRBB transac-
tion management along with our optimizations (Section 3).
Next, we evaluate our transaction management enhance-
ments and the resulting SRBB against other recent blockchains
(Section 4). Finally, we present the related work (Section 5)
and conclude (Section 6). The consensus protocol and the
proof of correctness are presented in Appendix A.

2 Background and Assumptions
In this section, we present our background. Next, we define
the blockchain problem and present our assumptions.

2

2.1 Ethereum background

Ethereum [38] features the Ethereum Virtual Machine (EVM)
that was proposed in part to cope with the limited expres-
siveness of Bitcoin [29] and to execute DApps written in
a Turing complete programming language as smart con-
tracts. Go Ethereum, or geth for short, is the most deployed
Ethereum implementation [5].

Ethereum nodes, accounts and transactions. Ethereum
nodes are of two main types, namely client nodes and valida-
tor nodes. Client nodes send read and write requests to the
blockchain while a validator node (i.e., miner) services these
requests. Note that the term “client” is used to define imple-
mentations of Ethereum (e.g., geth client) by the Ethereum
community but we identify a “client” solely as a sender of
requests to the blockchain. More precisely, validator nodes
perform two tasks. Firstly, the validator solves consensus
to agree upon the client write requests and executes those
requests. Secondly, the validator services client read requests.
Clients can have accounts in Ethereum. An Ethereum account
contains a nonce (the number of write requests sent from this
account), an address (the identifier of the account derived
from the associated public key), and a balance (the amount
of funds in the account). Transactions are write requests sent
by client nodes to the blockchain. They are of three main
types in Ethereum: native payments that transfer funds be-
tween ethereum accounts, smart contract deployments that
upload smart contracts to the blockchain, and smart contract
invocations that invoke the functions of smart contracts. The
transaction execution costs some fee to the client. This fee
was originally calculated from gas – the amount of compu-
tational work required to execute a transaction and the gas
price – a monetary value expressed in a cryptocurrency for
one unit of gas [38]. Thus, the fee calculation was measured
by gas × gas price [38], even though a gas tip has recently
been integrated into the fee calculation.

The redundant validations of Ethereum. In order to
check that a request (or transaction) is valid, all of the geth
validators must validate twice each transaction prior to exe-
cution:

• Eager validation: This validation occurs upon recep-
tion of a new client transaction and verifies the trans-
action size does not exceed 32 kilobytes, the value
transferred is non-negative, the gas of a transaction
does not exceed the block gas limit, the transaction
is properly signed, the transaction nonce value is in
order, the sender account has sufficient coins and the
gas amount is sufficient to execute the transaction. Be-
cause of this transaction validation, the risk of denial-
of-service (DoS) attacks is reduced as an invalid trans-
action is dropped early. If the transaction is valid, geth
propagates it to other nodes.

• Lazy validation: This validation occurs before the
transactions in a block are executed and simply checks
the nonce and whether there is enough gas for exe-
cution. This lazy validation is necessary to guarantee
that transactions in a newly received block are indeed
valid. The lazy validation is thus less time-consuming
in geth than the eager validation. This is why we focus
here on reducing the number of eager validations.

Note that this double validation is overly conservative
because each to-be-executed transaction of geth is validated
twice by each server. This is unnecessary as an invalid trans-
action coming from a malicious node will either be dropped
by the lazy validation before its execution or fail to execute. It
is also interesting to note that in a system with few malicious
replicas, there is no need for all nodes to validate all transac-
tions twice. We explain in Section 3.2 how, without reducing
security, we reduce the number 𝑘 of eager validations per
validator node down to 𝑘/𝑛 to scale to a large system of size
𝑛.

Transaction blocks and receipts. A transaction block
consists of a list of transactions. In the EVM, transaction
blocks are executed after a block is followed by a branch
of 5 additional blocks (i.e., this is known as block confirma-
tion). After execution, the blocks are inserted into a chain
where each block is linked to the prior block forming a chain
of blocks, hence the name “blockchain”. Subsequently, the
blocks are written to the LevelDB (a key-value data store).
Once the data in the LevelDB exceeds a threshold of memory,
the blocks stored in memory are flushed to the disk using disk
I/O. The transaction receipts record the result of executing a
transaction. It contains the status (a boolean value indicating
whether or not the transaction execution was successful),
a block hash (the hash of the block containing the transac-
tion), a block number (the index of the block containing the
transaction), and transaction-specific fields. These include
the transaction hash, sender address and receiver address
(a null value if it is a smart contract deployment). Next, the
receipt contains additional fields such as the contract address
(the address of the smart contract created if it is a contract
deployment), cumulative gas used (the total gas consumed
by the blockchain when the transaction was executed), the
gas used (the amount of gas used by the transaction) and
an array of logs (these logs contain events generated by the
transaction).

Transaction management. The transaction management
is the process transactions go through when a transaction
is submitted to the blockchain by a client until the client
confirms the transaction has been committed. Therefore, the
typical Ethereum transaction management includes the re-
ception of transactions at the blockchain, the validation of
transactions, the broadcast of transactions to the network,

3

the encapsulation of transactions into a block, the dissem-
ination of the blocks among validators, the re-validation
of transactions in a block, the execution of transactions in
a block, the storage of blocks and finally the retrieval of
transaction data by the client to verify that transactions are
committed.

Ethereum tries. Ethereum transactions executed on val-
idator nodes update the Ethereum state – a mapping of ac-
count addresses and account state (i.e., account balances,
account nonces and smart contract variable states). The
Ethereum state, transactions and transaction receipts are
stored in a Merkel Patricia Trie (MPT) data structure [38]
first held in memory and then flushed to disk once a thresh-
old of memory exceeds. The roots of these three tries (i.e.,
state, transaction and receipt tries) reside in the header fields
of transaction blocks as the state root, transaction root and
transaction receipt root. Therefore, each block points to its
respective snapshot of the three tries allowing anyone to
traverse through the blocks to view the state, transactions
and receipts history.

Transaction confirmation. A transaction is confirmed
from the transaction issuer’s (i.e., sending client) standpoint
when the issuer verifies the transaction as committed. We
term this process as transaction confirmation. Usually, any
client including the transaction issuer knows a particular
transaction is committed by fetching the transaction receipt
(i.e., receipt polling) from the blockchain or by fetching a
block containing the transaction (i.e., block polling). There-
fore, when measuring latency and throughput of blockchains,
evaluation tools [11] [20] consider the end-to-end measure-
ment between the time when the transaction is sent from
the issuer to the time the transaction receipt or the block
containing the transaction is received back at the issuer.

2.2 Assumptions and blockchain problem

Our network consists of validator nodes that are well-connected.
We assume partially synchronous communication [21]. We
assume, out of 𝑛 SRBB validator nodes, at most 𝑓 are byzan-
tine and can act arbitrarily where 𝑓 < 𝑛/3. As outlined in
Section 3.5, SRBB requires nodes to deposit stake to become a
validator. The use of PoS (Proof-of-Stake) provides a form of
Sybil resistance as it makes it expensive for a user to join the
network with different identities as multiple validators. Also
mentioned in Section 3.5, SRBB features a reconfiguration
protocol to cope with bribery.

We refer to the blockchain problem as the problem of
ensuring both the safety and liveness properties that were
defined in the literature by Garay et al. [23] and restated
more recently by Chan et al. [15], and a classic validity prop-
erty [18].

Definition 1 (The Blockchain Problem). The blockchain
problem is to ensure that a distributed set of validator nodes

maintain a sequence of transaction blocks such that the fol-
lowing properties hold:

• Liveness: if a correct validator node receives a trans-
action, then this transaction will eventually be reliably
stored in the block sequence of all correct validator nodes.
• Safety: the two chains of blocks maintained locally by
two correct validator nodes are either identical or one is
a prefix of the other.

• Validity: each block appended to the blockchain of each
correct validator node is a set of valid transactions (non-
conflicting well-formed transactions that are correctly
signed by its issuer).

The safety property does not require correct validator
nodes to share the same copy, simply because one replica
may already have received the latest block before another
receives it. Note that, as in classic definitions [15, 23], the
liveness property does not guarantee that a client transaction
is included in the blockchain: if a client sends its transaction
request exclusively to byzantine nodes then byzantine nodes
may decide to ignore it.

3 SRBB with Enhanced Transaction

Management

In this section, we present SRBB, our blockchain compatible
with the largest ecosystem of DApps. It is optimally resilient
against byzantine failures. Firstly, we present the architec-
ture of SRBB (Figure 1) and then describe its functionality
through the transaction life cycle. Subsequently, we present
our transaction management enhancements for the SRBB
VM under Sections 3.2, 3.3 and 3.4. Finally, we discuss, the
membership of SRBB.

3.1 The transaction lifecyle

The lifecycle of a transaction goes through these subsequent
stages:
1. Reception. The client creates a properly signed transac-
tion and sends it to at least one SRBB node ➊. Once a
request containing the signed transaction is received
➋ by the transaction server of the SRBB node, the
transaction in the request is submitted to the transac-
tion pool. In the transaction pool, the eager validation
(2.1) starts. If the validation fails, the transaction is
discarded. If the validation succeeds, the transactions
are kept in the transaction pool. Unlike in Ethereum
where the transaction would be propagated to all min-
ers increasing the number of eager validations, SRBB
simply proposes it to the consensus as follows: If the
number of successfully validated transactions in the
transaction pool reaches a threshold, then the transac-
tion pool creates a new proposed block with a number
(defined by the threshold) of transactions from the
pool. It serializes and sends the proposed block to the
consensus client ➌.

Figure 1. The architecture of a SRBB node. The SRBB VM is
built from Geth enhancing its transaction management. The
consensus is the Red Belly Blockchain’s consensus [18]. ➊ A
client sends a transaction to some replica(s), ➋ at each replica,
the transaction server receives the transactions and sends
them to the transaction pool that validates transactions and
➌ sends a block to the consensus client. ➍ The consensus
client proposes it to the consensus protocol. ➏ When the
consensus outputs some acceptable blocks, ➐ all of these
blocks are combined into a superblock and sent for execution.
Each block in the superblock is validated and executed➑.
Subsequently, the block is inserted into a chain and stored
in the data store➒.

2. Consensus. Once the consensus client receives a pro-
posed block, it sends the corresponding byte array to
the consensus protocol by invoking the propose([]byte)
method ➍. The consensus sends ➎ and receives ➏ pro-
posals to reach agreement. Subsequently, the consen-
sus creates a superblock ➐ with all acceptable block-
s/proposals (The Consensus Protocol, line 30) and sends
this superblock to the SRBB VM by invoking the com-
mit([]byte) method ➑.

3. Commit. When the superblock is received by the SRBB
VM ➑ the following execution process follows: a block
is taken at a time from the superblock and deserialized
using JSON unmarshalling. Then the SRBB VM does
the lazy validation (2.1) of each transaction in the block.
Note that as opposed to the eager validation, all SRBB
nodes execute the lazy validation before executing a
transaction. Yet it does not prevent SRBB from scaling
to hundreds of nodes (4.5). After lazy validation, the
transactions in the block are executed and the state,
transaction, and transaction receipt tries are updated
in memory adding the root of these tries to the block
header. The block is then inserted/written to the chain
in the data store with a pointer to the previous block
➒. Next, the SRBB VM follows the same procedure to

4

process the subsequent block in the superblock until
the entire superblock is committed. Note that, at some
point in time, when a threshold of memory is reached
the data store held in memory is flushed to the disk.

single consensus instance outputting a superblock through
the commitChan channel which contains potentially as many
blocks as SRBB nodes (line 3).

3.2 Reducing the transaction validations

As opposed to each Ethereum validator node that validates
eagerly and lazily each of the 𝑘 transactions of the system,
each of the 𝑛 SRBB nodes eagerly validates on average 𝑘/𝑛
transactions. Specifically, only one SRBB node needs to ea-
gerly validate each transaction: the first node receiving the
transaction validates it but does not propagate it to other
nodes and simply proposes it to the consensus. As a result,
SRBB limits the redundant validations reducing the CPU
overhead, which improves performance. More precisely, if
the number of SRBB nodes is 𝑛, then each node does 1 + 1/𝑛
validations per transaction on average (one lazy validation +
1/𝑛 eager validation) compared to the two validations needed
in geth. As 𝑛 tends to infinity, SRBB nodes validate on average
half of what geth nodes validate leading to a performance
increase of 48% (Section 4.3). In the worst case, where all
clients send their transactions to 𝑓 + 1 = 𝑛/3 SRBB nodes
simultaneously, then each node will still eagerly validate
only 𝑘/3 transactions.

Note that, as a result of our optimization, a byzantine
validator node could propose transactions to the consensus
without validating them eagerly, in this case, two things can
happen: (i) The transaction is discarded at the lazy validation
if invalid (ii) The validator node attempts to execute the
invalid transaction, fails at execution and reverses the state
to what it was. Either way, there is no impact on the safety
of the blockchain. This is also not a DoS vulnerability of
SRBB, as even a byzantine node in Ethereum can propagate
invalid transactions to all nodes, forcing unnecessary eager-
validations.

3.3 Per sub-block processing

Since our consensus system is fast, it creates and delivers
superblocks at high frequency through the commit channel
to the SRBB VM. As geth does not expect to receive blocks at
such a high frequency, it raises an exception outlining that
consecutive block timestamps are identical, which never
happens in a normal execution of Ethereum. This equality
arose because geth encodes the timestamp of each block
as uint64, not leaving enough space for encoding time with
sufficient precision. Typically geth reports an error when
consecutive timestamps are identical, due to a strict check
that compares the parent block timestamp to the current
block timestamp: header.Time < parent.Time.

We changed the original check to header.Time <= parent,
which allowed for fast-paced executions of consecutive blocks.
At each index of the blockchain, the SRBB node typically
executes many more transactions as part of function exe-
cute_transaction (lines 1–17) than Ethereum. This is due to a

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

execute_transaction :

// for each superblock received
for superblock in node . commitChan do

vtxs := ∅ // set of valid transactions
for block in superblock do // each block

txs := node . txm . deserialize ( block ) // get txs
for tx in txs :

if isValid ( tx ): vtxs . add ( tx ) // lazy validation
// set the corresponding block state and order txs
updateBlockState ()
for tx in vtxs do // for each valid tx ...

executeTx ( tx ) // ... execute it

done
persist ( vtxs ) // persist valid txs to disk
vtxs := ∅

done

done

Due to this excessive execution of transactions, the SRBB
nodes consume high CPU. Typically, high CPU usage slows
down the processing of transactions in the SRBB node, which
results in the increase of pending transactions in the trans-
action pool stored in-memory increasing the memory usage.
Due to high memory usage, the garbage collection gets acti-
vated to gain memory space. Also, when the memory usage
is high the SRBB node flushes Ethereum tries to disk to save
memory causing significant I/O. This further slows down
the SRBB VM.

As a solution, we optimized the SRBB VM to fully pro-
cess one proposed block (i.e. sub-block) of the superblock
at a time allowing it to alternate frequently between CPU-
intensive (verifying signatures and transaction executions)
and memory-intensive (state trie write, receipt/transaction
tries writes) and IO-intensive tasks (flushing to LevelDB).
This resulted in a throughput improvement of 39.7% (Sec-
tion 4.2).

3.4 Caching and Hashing Optimizations

Block body caching: A block body contains the transac-
tions that are committed on the blockchain. In the EVM, the
block body is written to the LevelDB – ’an in-memory key-
value data store’, after the block is inserted to a chain. When
a client requires transaction confirmation, the block body is
retrieved from the LevelDB and checked if the transaction is
included in the block.

Because Ethereum forks, it needs to distinguish two or
more blocks appended at the same index to the blockchain be-
cause these blocks share the same block number. To uniquely
identify each block, Ethereum thus needs to derive a key for
each block body by applying the RLP (recursive length pre-
fix) encoding to the block prefix, the block number, and the
block hash before storing it under a key in the LevelDB. This
makes the block body retrieval non-optimal for the client as
the key needs to be re-derived, and I/O needs to be performed

5

to access the block body from the LevelDB to confirm the
transaction is committed.

In contrast to Ethereum, SRBB offers instant finality and it
is important for a client to be able to rapidly confirm whether
its submitted transaction is actually committed (or whether
it was simply dropped by a byzantine validator). As SRBB
does not fork, it does not need a complex key derivation of a
block body like Ethereum, and can uniquely identify a block
by its block number. Figure 2(b) depicts the caching process
of SRBB. To offer rapid access to freshly written committed
transactions, SRBB caches a block body of committed trans-
actions within a hash map data structure before inserting
the block into the chain to reduce I/O and facilitate rapid re-
trieval. To this end, we use a Golang synchronized map data
structure.1 Because the block number uniquely identifies a
block of SRBB, the block number is used as the key to retrieve
the block body in the hash map data structure. Only upon
a cache miss does the client have to perform I/O to access
the key-value data store. Through the block body caching
optimization the throughput gain was 28-45% depending on
the machine specifications (Section 4.1).

Receipt cache optimization: Figure 2(a) depicts the caching

process in Ethereum: a transaction receipt is not cached when
it is written to the LevelDB database but only when it is read
from the database. Hence, whenever a client wants to check
that its freshly submitted transaction is committed, it will
have to access the database in the first query. In contrast
SRBB caches the receipts after blocks in a transaction are
executed and before the block is inserted into the chain. This
allows a freshly submitted transaction to be retrieved fast,
reducing I/O and speeding up the transaction confirmation
at the client. Receipt caching provided a throughput gain of
35%-100% on varying machine specifications (Section 4.1).

Optimizing state trie hashing using BLAKE3: The EVM

keeps the state trie in memory for rapid access for updates
and deletes during transaction execution. As the state trie
expands, it is hashed and kept in memory to reduce perform-
ing expensive I/O [32] that writes it to the LevelDB when
the memory is exhausted. Hashing of the state trie can be
CPU intensive. The EVM currently uses a version of sha-256
known as keccak-256 to hash the state trie nodes. We re-
place keccak-256 with the 256 bit Blake hashing2 – a faster
hashing algorithm [31] [8] providing the same security guar-
antees as SHA-256 (collision resistance, pre-image resistance
and differential attack resistance). This gave us a throughput
improvement of 6%-7% (Section 4.1).

3.5 Proof-of-stake and membership change

SRBB is an open blockchain that does not require permission
for any node to join the network. An SRBB node can play two

1https://go.dev/src/sync/map.go.
2https://github.com/BLAKE3-team/BLAKE3

6

(a) Ethereum caches the
transaction receipts only
when it is read. To check
that
its freshly appended
transaction is included in
the blockchain, the client
always needs to access the
database first.

(b) SRBB caches both the transaction re-
ceipts and the block body at write time. To
check that its freshly appended transac-
tion is committed, the client would likely
hit the cache during a rapid retrieval. Only
if unsuccessful, would the cache miss re-
sult in accessing the database.

Figure 2. The difference between the caching protocols of
Ethereum and SRBB to retrieve freshly included transactions

roles, either as a client that sends transactions and reads the
state of the blockchain or as a validator node that participates
in consensus, executes transactions and keeps a full state of
the ledger to service clients. To be a validator, a SRBB node
must deposit some tokens to a reconfiguration smart contract
as stake after which the smart contract outputs a random
committee of SRBB nodes based on stake to service client
requests similar to a sortition [25]. The SRBB nodes listen
to this smart contract committee output, which is a smart
contract event with a set of IDs (static IP addresses) grouped
into a committee. Then the SRBB validator nodes that are
part of the committee receive a reward as an incentive for
deciding blocks. After a specific time (i.e., an epoch), the
validator SRBB nodes in a committee invoke a function in
the reconfiguration smart contract triggering a committee
change similar to the way the initial committee was setup.
The use of stake helps mitigate Sybil attacks while committee
rotation helps against bribery attacks from slowly-adaptive
adversaries. A detailed implementation of the membership,
reconfiguration and block reward incentives is out of the
scope of this paper and we leave it as future work.

4 Evaluation
In this section, we present our evaluation of SRBB. In sum-
mary, our transaction management enhancements result in
SRBB reaching a peak throughput of ~4000 TPS and an av-
erage throughput of 2000 TPS for 200 nodes located in 5
continents, and outperforming 6 state-of-the-art blockchains
when executing the Diablo benchmark DApp with the real
Nasdaq workload [11]. We start by evaluating each of our
optimizations (Sections 4.1, 4.2 and 4.3). Then, we show the
overall performance improvement when we combine our
optimizations (Section 4.4). Next, we evaluate the scalability

Figure 3. Throughput improvement for each transaction
management enhancement of SRBB virtual machine for vary-
ing machine specifications

of our blockchain (Section 4.5). Finally, we compare SRBB
with state-of-the-art recent high performance blockchains
(Section 4.6).

Our evaluation focuses on the latency and throughput per-
formance metrics. The latency of a transaction is the elapsed
time between the transaction send time and the transac-
tion confirmation time as seen by the sending client. The
throughput is the number of transactions committed per
second as observed by the client (recall that SRBB ensures
instant finality so the transaction is committed as soon as
it is stored in reliable storage). To display throughput time
series (Figures 5, 6 and 7) and avoid the sawtooth effect
produced by blockchains appending transactions in blocks,
we averaged the throughput at each second as the aver-
age throughput observed within a sliding window of three
seconds. Note that, we evaluate all blockchains using the
Diablo [11] tool that evaluates blockchains against speci-
fied workloads by sending pre-signed transactions. For geo-
distributed experiments, we use 10 AWS regions spanning 5
continents. Namely: Bahrain, Cape Town, Milan, Mumbai, N.
Virginia, Ohio, Oregon, Stockholm, Sydney, and Tokyo. For
all benchmarks, we use the AWS family of c5 EC2 instances.

4.1 Effects of SRBB VM optimizations

We analyzed the throughput improvement of the SRBB VM
(without the execution of consensus) for each transaction
management enhancement proposed in Section 3.4 for vary-
ing machine specifications using 15000 transactions in to-
tal. AWS c5.xlarge, c5.2xlarge, c5.4xlarge and c5.9xlarge in-
stances have 2, 4, 8, 16, 36 vCPUs and 4, 8, 16, 32, 72 GB of
RAM respectively. In Figure 3, the block body caching opti-
mization, receipt caching optimization and Blake3 hashing
optimization yielded throughput improvements of 28-45%,
35-200% and 6%-7% respectively for increasing machine spec-
ifications. The fully optimized state machine (SRBB VM),
yielded a throughput of 923 TPS for c5.xlarge and improved

7

Figure 4. Performance difference when processing each
block of a superblock at a time (optimized) and when pro-
cessing the entire superblock at once (non-optimized)

to 1437 TPS for c5.9xlarge. Therefore, our optimizations im-
proved the state machine’s performance between 2-3 times
depending on the machine specifications.

4.2 Effects of SRBB per sub-block processing

We compared the naive method which executes transactions
in an entire superblock and commits them, with an optimized
method of processing each sub-block in a superblock at a
time (Section 3.3). Note that, to form a superblock we require
SRBB to execute more than one node as it requires consensus
from multiple nodes to deliver a superblock to the SRBB
VM. Since a BFT consensus requires at least four nodes, we
evaluated the SRBB superblock processing on a c5.2xlarge 4
node setup with 15000 transactions.

Figure 4 compares the performance obtained with SRBB
(superblock optimized) and with the naive approach (su-
perblock non-optimized). The throughput of SRBB (superblock
optimized) is 1546 TPS and 39.7% higher than the through-
put of the naive approach. This is because trying to persist a
large superblock that comprises 15000 transactions leads to
high I/O congestion (Section 3.3).

Note that a single c5.2xlarge instance executing an SRBB
VM in Section 4.1 yielded a throughput of 1025 TPS, less than
1546 TPS for four c5.2xlarge SRBB nodes with the superblock
optimized benchmark (Figure 4). The improvement of the
latter is due to being able to receive more transactions con-
currently at multiple SRBB nodes allowing a large number of
transactions to be committed in a superblock per consensus.

4.3 Effects of validation reduction

In order to assess the impact of validation reduction we
measured both the total time the SRBB VM Δ𝑛
𝑆𝑅𝐵𝐵 spent
treating 𝑘 native payment transactions and the average time
𝛿𝑛
𝑆𝑅𝐵𝐵 spent eagerly validating these 𝑘 transactions on a
single SRBB node executing on 4 vCPUs and 8 GB RAM
AWS instance (c5.xlarge). As such, the time not affected
by the validation optimization is 𝛽 = Δ𝑛
𝑆𝑅𝐵𝐵. Based
on this measurement, we could deduce the time 𝛿𝑆𝑅𝐵𝐵: the
SRBB node would spend validating eagerly with the vali-
dation optimization if the number of SRBB nodes were 𝑛:
𝛿𝑆𝑅𝐵𝐵𝑣−𝑜𝑝𝑡 = 𝛿𝑛
𝑆𝑅𝐵𝐵/𝑛. We know that the SRBB VM would
spend Δ𝑆𝑅𝐵𝐵 = 𝛽 +𝛿𝑆𝑅𝐵𝐵 to treat 𝑘 transactions. By contrasts,
the validation optimized SRBB VM would spend Δ𝑛
=

𝑆𝑅𝐵𝐵 − 𝛿𝑛

𝑆𝑅𝐵𝐵𝑣−𝑜𝑝𝑡

0500100015002000Throughput(TPS)OptimizedNon-optimized11061546𝑆𝑅𝐵𝐵/𝑛. This means the SRBB VM validation optimization

𝛽+𝛿𝑛
latency improvement is:
Δ𝑆𝑅𝐵𝐵 − Δ𝑛
Δ𝑛

𝑆 =

𝑆𝑅𝐵𝐵𝑣−𝑜𝑝𝑡

𝑆𝑅𝐵𝐵𝑣−𝑜𝑝𝑡

=

𝑆𝑅𝐵𝐵/𝑛

𝛿𝑆𝑅𝐵𝐵 − 𝛿𝑛
𝛽 + 𝛿𝑛

𝑆𝑅𝐵𝐵/𝑛

.

As 𝑛 tends to infinity, we thus have a slowdown of:

lim
𝑛→+∞

𝑆 =

𝛿𝑆𝑅𝐵𝐵
𝛽

.

𝑆𝑅𝐵𝐵 = 4.27 seconds and Δ𝑛

Our measurement obtained with 𝑘 = 15000 transactions
and 𝑛 = 1 revealed that 𝛿𝑛
𝑆𝑅𝐵𝐵 =
17.87 seconds. Hence, we have 𝛽 = 17.87 − 4.27 = 13.6.
If we consider 𝑛 = 4, 𝛿𝑆𝑅𝐵𝐵𝑣−𝑜𝑝𝑡 = 4.27/4 = 1.07, so that
Δ𝑛
= 13.6 + 1.07 = 14.67. The improvement with
𝑆𝑅𝐵𝐵𝑣−𝑜𝑝𝑡
validation optimization is thus, (17.87 − 14.67) · 100/14.67 =
21.8%. As 𝑛 tends to infinity, the improvement in perfor-
mance will be 4.27 · 100/13.6 = 31.39%

Machine
specification

Improvement on
small networks

Asymptotic gain
on large networks

c5.xlarge
c5.2xlarge
c5.4xlarge
c5.9xlarge

21%
24%
28%
32%

31%
36%
42%
48%

Table 1. The validation reduction allows the SRBB VM to
scale horizontally (with the amount of resources allocated to
each node) and vertically (with the number of nodes where
it runs)

Table 1 presents the performance improvements induced
by the validation reduction when sending 15000 native pay-
ment transactions to the SRBB VM deployed on different
networks. Its second column indicates the gain obtained in
the smallest instance of our network, when 𝑛 = 4, whereas
its third column indicates the gain obtained in the largest
possible network, when 𝑛 → ∞. The validation reduction
allows the performance of the SRBB VM to scale vertically
because its gain grows from 31% to 48% (last column) with
the amount of allocated resources and horizontally because
its gain grows from 32% to 48% (last row) with the size of
the network.

4.4 Overall performance improvement

To show the performance benefit of SRBB, we evaluated
the naive EVM simply plugged to the superblock supported
DBFT consensus (i.e., non-optimized) against SRBB (opti-
mized) – the SRBB VM plugged to the superblock supported
DBFT consensus. We use a sending rate of 30,000 TPS with
60,000 transactions sent over 2 seconds to perform this eval-
uation for four c5.2xlarge nodes.

Figure 5 (top) presents the latency distribution as a cumu-
lative distribution function for all transactions for SRBB and

8

Figure 5. The latency (top) and throughput (bottom) com-
parison between SRBB (optimized) and the default geth EVM
equipped with DBFT to decide superblocks (non optimized)

the non-optimized alternative. On the one hand, we observe
that the naive EVM-DBFT blockchain takes 23 seconds on
average to commit a transaction and more than 1mn13s to
commit some transactions. The default EVM acts as a bottle-
neck: while DBFT is optimized to treat transactions fast [18],
the EVM is not. The reason is that the EVM was originally
designed for Ethereum, which anyway recommends users to
wait for about 3 minutes (12 confirmations, each taking 15
seconds in expectation) to consider their transaction commit-
ted. On the other hand, SRBB commits transactions within
9.6 seconds on average while all transactions are committed
in less than 16 seconds after they are issued. As a result,
SRBB halves the average latency of the naive blockchain and
reduces its observed worst-case latency by 4.6×.

Figure 5 (bottom) depicts the throughput over time of the
naive blockchain and SRBB. Note that even though SRBB
transaction latencies are lower than 20 seconds, the through-
put of SRBB does not drop to zero after 20 seconds: this is
because transactions are not all issued at the beginning of
the experiments, some of them are issued later. SRBB peaks
at a throughput of ~4000 TPS higher than the ~3000 TPS
peak throughput that the naive approach reaches. The naive
EVM+DBFT blockchain and SRBB deliver an average through-
put of 612 TPS and 1935 TPS, respectively. This represents an
improvement of 3.2×. Note that the overall speedup of SRBB
does not correspond to the sum of the speedups obtained by
each of our individual optimizations. This is because optimiz-
ing the transaction management of SRBB leads to delivering
superblock faster to the execution engine. As a result, its
transaction management may bottleneck by concurrently
receiving, validating, and proposing transactions to the con-
sensus protocol while executing fast-delivered superblocks.

Figure 6. Scalability of SRBB as its latency (left) and throughput (right) under varying sending rates (from 15,000 TPS to
35,000 TPS) when deployed on 200 machines spread in 5 continents

4.5 World-wide scalability

We define scalability as the ability to maintain reasonably
good performance when a blockchain has a large number
of nodes in a geo-distributed environment. To evaluate the
scalability of SRBB, we deployed 200 c5.2xlarge nodes of
SRBB in 10 regions spanning 5 continents. The benchmark
was performed with varying sending rates from 15000 to
35,000 TPS. We achieved an average throughput of 2000 TPS
over all these executions. The peak throughput was always
above 3000 TPS but showed the best performance at a send-
ing rate of 30,000 TPS, peaking at close to ~4000 TPS as can
be seen on Figure 6. Generally, with the sending rate increas-
ing the peak throughput showed an increase, although it
showed a slight dip at a sending rate of 35000 TPS due to
SRBB not processing transactions at the send rate due to a
bottlenecked CPU and memory.

The latency on the other hand increased with increas-
ing sending rates, with the best latency at a sending rate of
15000 TPS with all transactions being committed under 10
seconds. The reason for this observation is due to the way
a client confirms a transaction to calculate latency. SRBB
uses a transaction confirmation optimization using caching
to confirm a committed transaction. With low sending rates,
the memory is not bottlenecked, leaving space for the cached
block bodies to grow, allowing the client to confirm transac-
tions faster by hitting the cache. In contrast, with high send-
ing rates, the memory is heavily used constraining the block
body cache size causing more cache misses, and lessening the
performance enhancement of our caching optimization. This
results in the client having to access the LevelDB key-value
data store to confirm a transaction slowing down confirma-
tion speeds. To make matters worse, a part of the LevelDB
will reside in the disk due to disk I/O flushing memory to
the disk once a threshold of memory is reached, further
compounding the transaction confirmation times.

4.6 Comparison with other blockchains

To evaluate SRBB in a realistic setting, we evaluate the per-
formance of a realistic DApp running on SRBB and on 6
other state-of-the-art blockchains that also support DApps:

9

Algorand, Avalanche (C-Chain), Ethereum (with Clique con-
sensus), Libra/Diem, Quorum (with IBFT consensus) and
Solana. To this end, we used the Diablo benchmark [11] that
is publicly available [1] and aims at comparing blockchains
fairly. We selected the Diablo benchmark because it is, as far
as we know, the only blockchain benchmark that features
a real workload trace. More precisely, we ran the exchange
DApp available in Solidity, PyTeal, and Move in the Diablo
benchmark that executes the real Nasdaq stock trade trace
for 2 minutes (Move is the smart contract language supported
by Libra-Diem, PyTeal is the smart contract language used
to produce Teal bytecode for Algorand and the Solidity lan-
guage is supported by all the other blockchains we tested.).
Note that we did not include the Red belly blockchain in this
benchmark as it does not support smart contracts/DApps.
We used the same deployment setting as in Section 4.5 with
200 c5.2xlarge machines distributed in 10 countries on 5
continents.

Figure 7 depicts the latency distribution as the cumulative
distribution function of the latencies of transactions observed
during the experiments and the throughput as the volume
of transactions committed per second.

As expected, SRBB is much faster at committing trans-
actions than other blockchains. This happens for several
reasons. First, the validation reduction optimization reduces
the transaction validation time, allowing transactions to be
committed faster. Second, the sub-block storing optimization
significantly reduces I/O reducing the waiting time of the
CPU before processing transactions.

What is more surprising is that SRBB is the only blockchain
to not lose any request. This can be observed in Figure 7 (left)
as the ratio of committed transactions over all requested
transactions only reaches 1 for SRBB. Note that running the
benchmark for more than 2 minutes would not allow other
blockchains to commit all transactions as we can clearly de-
tect some asymptotic bounds. The reason is that the Nasdaq
workload from Diablo features the stock trades correspond-
ing to Apple, Amazon, Facebook, Google, and Microsoft
whose demand is particularly high when the market opens.
As other blockchains take longer to handle each request,

Figure 7. Comparison of modern blockchains latency (left) and throughput (right) when running the exchange decentralized
application (DApp) with the Nasdaq trace

their backlog of pending transactions increases, and they
become saturated. This is well illustrated by the throughput
graph on Figure 7 (right), where SRBB throughput peaks
well above and earlier than other blockchains.

5 Related Work
In this section, we focus on work enhancing transaction
management to improve the performance of DApps. These
works include executing transactions concurrently, introduc-
ing faster runtimes, using different language implementa-
tions of VMs, and decoupling transaction management tasks.
None to our knowledge present the same optimization as us.

Concurrent Execution of Transactions. Saraph and Her-
lihy [36] perform an empirical study on speculative concur-
rent executionsof Ethereum smart contracts by sampling
Ethereum blocks and executing smart contract transactions
in them concurrently. Failed transactions abort and exe-
cute sequentially afterward. This approach is known as an
execute-order approach. The authors estimate the speedup
of execution by the gas cost of transactions without calcu-
lating the exact performance improvement since they do
not implement an EVM using their speculative concurrent
approach. The presented speculative concurrent execution
approach is estimated to speedup performance starting from
8-fold to 2-fold when the number of conflicting transactions
gradually increases. Considering that Ethereum’s average
throughput is 15 TPS the speculative concurrent approach
would only yield an average throughput of 120 TPS whereas
our average throughput is ~x17 higher.

Block-STM [24] presents an in-memory execute-order par-
adigm smart contract parallel execution engine built on the
principles of Software Transaction Memory (STM). It dy-
namically detects and avoids conflicts during concurrent
transaction execution reaching the same final state as a se-
quential execution. Block-STM is proven safe and live and is
implemented on the Diem blockchain and delivers a through-
put of 140k TPS in a baseline benchmark and 60k TPS in a

10

contended workload. Block-STM executes conflicting trans-
actions by keeping multiple versions of transaction execu-
tions in an in-memory data structure where each version
corresponds to a unique location in the execution order of all
transactions. The correct version is selected by a validation
method and finalized. Since we do not implement concur-
rent execution of transactions, our approach does not require
maintaining duplicated transaction execution versions and
then a validation method to resolve those versions, all of
which increases the workload on the CPU.

Similar to Block-STM [24], Parwat et al. [7] proposes a
concurrent smart contract execution approach using STM.
However, in contrast, the latter follows an order-execute
paradigm where miners create a Block Graph (BG) for con-
flicting transactions in a block and validators execute the
smart contract transactions concurrently based on the BG.
By having the distinction between miners and validators
Parwat et al. [7] could have issues related to byzantine min-
ers [24]. By pre-computing a BG, there is additional overhead
compared to Block-STM. Tracking dependencies and build-
ing a BG before execution can be a tedious task and could
seriously impair performance when the percentage of con-
flicting transactions is high. Our work on the other hand can
maintain performance despite a high percentage of conflict-
ing transactions since we execute transactions sequentially
without any dependency pre-computations.

ParBlockchain [6] performs concurrent executions of dis-
tributed applications following an order-execute paradigm
coined OXII. Similar to Parwat et al. [7], ParBlockchain or-
ders transactions within a block based on a dependency
graph prior to execution. OXII is integrated into a permis-
sioned blockchain coined ParBlockchain that features three
types of nodes. Namely, 1) Clients that send requests to the
blockchain; 2) Orderers that agree on the order of transac-
tions, builds a dependency graph and executes consensus (e.g.
PBFT); 3) Executors that validate and execute transactions.
The transactions that are found to have no dependencies in
the dependency graph execute concurrently. The evaluation
reports better performance than sequential order-execute
(OX) and execute-order-validate (XOV) for workloads with

any degree of contention. ParBlockchain’s decoupling tasks
to three types of nodes reduces fault tolerance. Orderer nodes
can tolerate up to 𝑓 failed nodes s.t. 𝑁 /3 > 𝑓 but since these
nodes are connected to decoupled executor nodes, the fault
tolerance of executor nodes should be considered separately.
This could reduce the fault tolerance of the entire blockchain.
In contrast, SRBB does not have this drawback brought forth
by decoupling, and assumes a fault tolerance of 𝑓 at most
for the entire network.

Kim et al. [27] propose an off-chain concurrent execution
of Ethereum transactions for scalable testing and profiling
of smart contracts. The proposed approach lets a geth node
synchronize and record the Ethereum state prior to every
transaction execution known as the input sub-state and af-
ter the execution of every transaction known as the output
sub-state. Thus, an input and output sub-state are recorded
for each transaction in the Ethereum trace. A sub-state of a
transaction contains the information required to execute the
transaction in complete isolation from other transactions.
After the sub-state recording is complete, all transactions
in the Ethereum trace are executed in isolation of one an-
other, each transaction executing in a dedicated thread con-
currently. Each transaction is applied to its recorded input
sub-state and the resulting output sub-state is compared with
the recorded output sub-state to validate the execution. Al-
though ideal for testing purposes after recording sub-states,
unlike SRBB, this approach cannot work in a blockchain
receiving transactions in real-time. This is because recording
transaction sub-states is impossible without actually execut-
ing transactions from clients sequentially.

Other VM optimizations. Ethereum introduced eWASM
(Ethereum Web Assembly) as a runtime for transaction exe-
cutions [3]. Although eWASM bytecode is deemed as a faster
alternative to EVM bytecode for smart contract (i.e., DApp)
executions [43], recent work comparing the performance of
WASM EVMs and EVMs [2] show that eWASM integrated
VMs do not outperform geth and Openethereum. Geth shows the
best performance [43] for smart contract executions among
popular Ethereum clients. The authors claim that declined
performance of the eWASM VMs is due to additional over-
head for gas metering and inefficient context switching of
methods used for the interaction of high-level opcodes of
Ethereum with WASM.

Different implementations of Ethereum yield varying per-
formances. Rouhani and Deters [35] compare the perfor-
mance of geth and the Rust implementation of Ethereum
called Parity (now known as Openethereum) in two private
permissioned blockchains, one consisting only geth nodes
and the other only Openethereum nodes. As reported, Parity
processes transactions 89.8% faster than geth. This perfor-
mance disparity is questionable, since, in contrast, paper [2]
shows Geth’s contract execution performance to be faster
than Openethereum’s.

Popular blockchains with enhanced transaction man-
agement. RainBlock [32] enhances the transaction manage-
ment of Ethereum by introducing optimizations that remove
the I/O bottleneck in the transaction execution phase caused
by state trie updates. It removes I/O from the critical path by
decoupling transaction executions from I/O by sharding its
concurrent read-write Merkel Trie (DSM tree) into sub-trees
and storing them in the memory of separate storage nodes.
I/O helpers pre-fetch Merkel trie data from storage nodes and
submit these trie data to miners for transaction execution.
Miners update the trie data and update the storage nodes
asynchronously. While the reported performance of Rain-
Block is 20K TPS for 32 GB RAM, 8 vCPU instances spanning
4 AWS regions which include 4 miners, 16 I/O helpers, and 16
storage nodes, the decoupling made to store tries in separate
storage nodes adversely impacts its fault tolerance. If storage
nodes are byzantine or compromised with a DDoS attack,
the safety of the blockchain could be compromised as miners
will not receive the Merkel trie data required for execution.
In contrast, SRBB does not have this problem as there is no
decoupling of SRBB nodes into separate storage nodes.

Solana [39] is a high-performance blockchain provid-
ing enhanced transaction management. Perhaps the most
noteworthy of its transaction management optimizations
is Sealevel [40] – a parallel smart contract runtime made
possible by the unique transactions of Solana that describe
read and write states separately. This allows non-conflicting
transactions and transactions that read from the same state
to execute concurrently. Solana also optimizes transaction
validation by pipelining validation in a software-built trans-
action processing unit (TPU) into four stages. The signature
verification is offloaded to a GPU. However, by XORing its
state hash, Solana has been found to be vulnerable to state
hash collision attacks [4] whereas SRBB does not suffer from
this vulnerability.

6 Conclusion
In this paper, we enhanced transaction management by re-
ducing transaction validations, using Blake3 for state trie
hashing during transaction execution, processing and stor-
ing sub-blocks, and caching transaction data for fast retrieval
of committed transactions. Through these enhancements, we
developed the SRBB VM. We then rigorously evaluated the
performance increase of each of our optimizations. To apply
our contributions, we developed Smart Red Belly Blockchain
supporting the largest eco-system of DApps. Finally, we
empirically showed that SRBB outperforms recent high-
performance blockchains that support DApps.

A Consensus Protocol and Proofs of

Correctness

The protocol is divided in two procedures, start_new_consensus
at lines 24–30 that spawns a new instance of (multivalue)

11

consensus by incrementing the replicated state machine in-
dex, and consensus_propose at lines 35–49 that ensures that the
consensus participants find an agreement on a superblock
comprising all the proposed blocks that are acceptable. The
idea of consensus_propose builds upon classic reduction [9, 10]
by executing an all-to-all reliable broadcast [13] to exchange
𝑛 proposals, guaranteeing that any block delivered to a cor-
rect process is delivered to all the correct processes: any
delivered proposal is stored in an array proposals at the in-
dex corresponding to the identifier of the broadcaster.

20
21
22
23
24
25
26
27
28
29
30

index := 0 // consensus instance
blockQueue := ∅ // pending block to propose
// commit channel
commitChan := chan [] byte

start_new_consensus ():

index := index + 1 // increment round
myBlock := blockQueue . peek () // get block proposal
superblock := consensus_propose ( myBlock ) // block
if ( myBlock is in superblock ) then

blockQueue . poll () // dequeue proposal

commitChan := superblock // send to gRPC srvce

A binary consensus at index 𝑘 is started with input value
true for each index 𝑘 where a block proposal has been
recorded (line 34). To limit errors, SRBB uses the formally ver-
ified deterministic binary consensus of DBFT [17], we omit
the pseudocode for the sake of space and refer the reader to
the formal verification of the protocol [12, 37].

As soon as some of these binary consensus instances re-
turn 1, the protocol spawns binary consensus instances with
proposed value false for each of the non reliably delivered
blocks at line 42. Note that this invocation is non-blocking.
As the reliable broadcast fills the block in parallel, it is likely
that the blocks reliably broadcast by correct processes have
been reliably delivered resulting in as many invocations of
the binary consensus with value true instead. Once all the
𝑛 binary consensus instances have terminated, i.e., decided-
Count == n at line 44, the superblock is generated with all
the reliably delivered blocks for which the corresponding
binary consensus returned true (lines 45–49). At the end of
start_new_consensus, if the superblock of the consensus con-
tains the block proposed, then this block is removed from
the blockQueue at lines 28 and 29 to avoid reproposing it later.
We show that SRBB solves the blockchain problem (Def. 1).

at

one

least

1. If

SRBB

correct

Lemma
node
consensus-proposes to a consensus instance 𝑖, then ev-
ery correct SRBB node decides on the same superblock at
consensus instance 𝑖.
Proof. If a correct SRBB node 𝑝 consensus-proposes, say 𝑣, to
a consensus instance 𝑖, then 𝑝 reliably broadcast 𝑣 at line 38.
By the reliable broadcast properties [13], we know that 𝑣
is delivered at line 32 at all correct validator nodes. By as-
sumption, there are at least 2𝑓 + 1 correct proposers invoking
the reliable broadcast, hence all correct proposers eventu-
ally populate their block array with at least one common
value. All correct proposers will thus have input true for the

corresponding binary consensus instance at line 34. Now it
could be the case that other values are reliably-broadcast
by byzantine nodes, however, reliable broadcast guarantees
that if a correct proposer delivers a valid value 𝑣, then all
correct proposers deliver 𝑣. By the validity and termination
properties of the DBFT binary consensus [17], the decided
value for the binary consensus instance at line 39 is the same
at all correct SRBB nodes. It follows that all correct SRBB
nodes have the same bit array of decBlocks values at line 47
and that they all return the same superblock at line 49 for
□
consensus instance 𝑖.

31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49

blocks := ∅ // blocks delivered by reliable bcast
upon reliable_broadcast . deliver (i , block ):

blocks [i ] := block // append block to list
decBlocks [ i] := b_consensus . propose (i , true )

consensus_propose ( myBlock ):

decCount := 0 // # decided bin . cons . instances
decBlocks :=
reliable_broadcast . broadcast ( myId , myBlock )
wait until ∃ i : b_consensus . decide (i) == true

∅

for j

from 0 to n do
if blocks [j] is null then

decBlocks [j ] := b_consensus . propose (j , false )

decCount := decCount +1
wait until decCount == n

superblock := ∅
for i from 0 to n do

if decBlocks [ i] is true then
superblock . add ( blocks [i ])

return superblock

The next three theorems show that SRBB satisfies each of
the three properties of the blockchain problem (Definition 1).

Theorem 1. SRBB satisfies the safety property.
Proof. The proof follows from the fact that any block 𝐵ℓ at
index ℓ of the chain is identical for all correct SRBB nodes
due to Lemma 1. Due to network asynchrony, it could be
that a correct node 𝑝1 is aware of block 𝐵ℓ+1 at index ℓ + 1,
whereas another correct node 𝑝2 has not created this block
𝐵ℓ+1 yet. At this time, 𝑝2 maintains a chain of blocks that is
a prefix of the chain maintained by 𝑝1. And more generally,
the two chains of blocks maintained locally by two correct
blockchain nodes are either identical or one is a prefix of the
□
other.

Theorem 2. SRBB satisfies the validity property.

Proof. By examination of the code at line 8, only valid trans-
actions are executed and persisted to disk at every correct
SRBB node. It follows that for all indices ℓ, the block 𝐵ℓ is
□
valid.

Theorem 3. SRBB satisfies the liveness property.

Proof. As long as a correct SRBB nodes receives a transac-
tion, we know that the transaction is eventually proposed by
line 27. The proof follows from the termination of the con-
sensus algorithm [12] and the fact that SRBB keeps spawning
new consensus instances as long as correct SRBB nodes have
□
pending transactions.

12

References
[1] 2020. Diablo: Distributed Analytical BLOckchain Benchmark Frame-
work. https://github.com/NatoliChris/diablo-benchmark Accessed:
2022-04-12.

[2] 2020. Ethereum flavored WebAssembly (ewasm). https://github.com/

ewasm/design

[3] 2020. Ethereum WebAssembly (ewasm). https://ewasm.readthedocs.

io/en/mkdocs/ Accessed: 2022-05-12.
[4] 2020. How I broke Solana’s State Hash.

https://reading.supply/
@alexatnear/how-i-broke-solanas-state-hash-6r51RR Accessed: 2022-
05-10.

[5] 2022. Ethereum Mainnet Statistics. https://www.ethernodes.org/
[6] Mohammad Javad Amiri, Divyakant Agrawal, and Amr El Abbadi. 2019.
ParBlockchain: Leveraging Transaction Parallelism in Permissioned
Blockchain Systems. In 2019 IEEE 39th International Conference on
Distributed Computing Systems (ICDCS). 1337–1347. https://doi.org/
10.1109/ICDCS.2019.00134

[7] Parwat Singh Anjana, Hagit Attiya, Sweta Kumari, Sathya Peri, and Ar-
chit Somani. 2020. Efficient concurrent execution of smart contracts in
blockchains using object-based transactional memory. In International
Conference on Networked Systems. Springer, 77–93.

[8] Jean-Philippe Aumasson, Samuel Neves, Zooko Wilcox-O’Hearn, and
Christian Winnerlein. 2013. BLAKE2: simpler, smaller, fast as MD5. In
International Conference on Applied Cryptography and Network Security.
Springer, 119–135.

[9] Michael Ben-Or, Ran Canetti, and Oded Goldreich. 1993. Asynchronous

Secure Computation. In ACM STOC. 52–61.

[10] Michael Ben-Or, Boaz Kelmer, and Tal Rabin. 1994. Asynchronous
Secure Computations with Optimal Resilience (Extended Abstract). In
ACM PODC. 183–192.

[11] Harold Benoit, Vincent Gramoli, Rachid Guerraoui, and Christopher
Natoli. 2021. Diablo: A Distributed Analytical Blockchain Benchmark
Framework Focusing on Real-World Workloads. Technical Report 285731.
EPFL.

[12] Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana Lazic,
Pierre Tholoniat, and Josef Widder. 2021. Compositional Verification of
Byzantine Consensus. Technical Report hal-03158911. HAL.

[13] Gabriel Bracha. 1987. Asynchronous Byzantine Agreement Protocols.

Inf. Comput. 75, 2 (1987), 130–143.

[14] Daniel Cason, Nenad Milosevic, Zarko Milosevic, and Fernando Pe-
done. 2021. Gossip consensus. In Proceedings of the 22nd International
Middleware Conference (Middleware), Kaiwen Zhang, Abdelouahed
Gherbi, Nalini Venkatasubramanian, and Luís Veiga (Eds.). ACM, 198–
209.

[15] Benjamin Y. Chan and Elaine Shi. 2020. Streamlet: Textbook Stream-
lined Blockchains. In Proceedings of the 2nd ACM Conference on Ad-
vances in Financial Technologies. 1–11.

[16] JPMorgan Chase. 2019.

Quorum Whitepaper.

https:

//github.com/ConsenSys/quorum/blob/master/docs/Quorum%
20Whitepaper%20v0.2.pdf

[17] Tyler Crain, Vincent Gramoli, Mikel Larrea, and Michel Raynal. 2018.
DBFT: Efficient Leaderless Byzantine Consensus and its Application
to Blockchains. In Proc. 17th IEEE Int. Symp. Netw. Comp. and Appl
(NCA). 1–8.

[18] Tyler Crain, Christopher Natoli, and Vincent Gramoli. 2021. Red
Belly: a Secure, Fair and Scalable Open Blockchain. In IEEE S&P.
1501–1518. https://www.computer.org/csdl/pds/api/csdl/proceedings/
download-article/1t0x9nljvwI/pdf

[19] Diem. 2019. Accepting a transaction. https://developers.diem.com/

docs/core/life-of-a-transaction/

[20] Tien Tuan Anh Dinh, Ji Wang, Gang Chen, Rui Liu, Beng Chin Ooi,
and Kian-Lee Tan. 2017. BLOCKBENCH: A Framework for Analyzing
Private Blockchains. In SIGMOD. 1085–1100.

13

[21] C. Dwork, N. Lynch, and L. Stockmeyer. 1988. Consensus in the
Presence of Partial Synchrony. J. ACM 35, 2 (1988), pp.288–323.
[22] Amsden et al. 2020. The Libra Blockchain. Accessed on 2022-04-
27, https://diem-developers-components.netlify.app/papers/the-diem-
blockchain/2020-05-26.pdf.

[23] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. 2015. The
Bitcoin Backbone Protocol: Analysis and Applications. In 34th Annu.
Int. Conf. the Theory and Applications of Crypto. Techniques. 281–310.
[24] Rati Gelashvili, Alexander Spiegelman, Zhuolun Xiang, George
Danezis, Zekun Li, Yu Xia, Runtian Zhou, and Dahlia Malkhi. 2022.
Block-STM: Scaling Blockchain Execution by Turning Ordering Curse
to a Performance Blessing. https://doi.org/10.48550/ARXIV.2203.06871
[25] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nick-
olai Zeldovich. 2017. Algorand: Scaling Byzantine Agreements for
Cryptocurrencies. In Proc. 26th Symp. Operating Syst. Principles. 51–68.
[26] Mike Isaac and Sheera Frenkel. 2018. Facebook Security Breach Ex-
poses Accounts of 50 Million Users. https://www.nytimes.com/2018/
09/28/technology/facebook-hack-data-breach.html Accessed: 2020-
11-14.

[27] Yeonsoo Kim, Seongho Jeong, Kamil Jezek, Bernd Burgstaller, and
Bernhard Scholz. 2021. An Off-The-Chain Execution Environment
for Scalable Testing and Profiling of Smart Contracts. In 2021 USENIX
Annual Technical Conference (USENIX ATC 21). USENIX Association,
565–579. https://www.usenix.org/conference/atc21/presentation/kim-
yeonsoo

[28] Essam Mansour, Andrei Vlad Sambra, Sandro Hawke, Maged Zereba,
Sarven Capadisli, Abdurrahman Ghanem, Ashraf Aboulnaga, and Tim
Berners-Lee. 2016. A Demonstration of the Solid Platform for Social
Web Applications. In Proceedings of the 25th International Conference
on World Wide Web, WWW 2016, Montreal, Canada, April 11-15, 2016,
Companion Volume. 223–226.

[29] Satoshi Nakamoto. 2008. Bitcoin: a peer-to-peer electronic cash sys-

tem.

[30] Ray Neiheiser, Miguel Matos, and Luís Rodrigues. 2021. Kauri: Scalable
BFT Consensus with Pipelined Tree-Based Dissemination and Aggre-
gation. In Proceedings of the ACM SIGOPS 28th Symposium on Operating
Systems Principles (Virtual Event, Germany) (SOSP ’21). 35–48.
[31] Emanuel Onica and Cosmin-Ionut Schifirnet. 2021. Towards Efficient

Hashing in Ethereum Smart Contracts. (2021).

[32] Soujanya Ponnapalli, Aashaka Shah, Souvik Banerjee, Dahlia Malkhi,
Amy Tai, Vijay Chidambaram, and Michael Wei. 2021. {RainBlock}:
Faster Transaction Processing in Public Blockchains. In 2021 USENIX
Annual Technical Conference (USENIX ATC 21). 333–347.

[33] Jeremias Prassl. 2018. Humans as a Service: The Promise and Perils of
Work in the Gig Economy. Oxford Press. https://doi.org/10.1093/oso/
9780198797012.001.0001

[34] Team Rocket. 2018. Snowflake to Avalanche: A Novel Metastable Consen-
sus Protocol Family for Cryptocurrencies. Technical Report. Accessed:
2021-12-01.

[35] Sara Rouhani and Ralph Deters. 2017. Performance analysis of
ethereum transactions in private blockchain. In 2017 8th IEEE Interna-
tional Conference on Software Engineering and Service Science (ICSESS).
70–74. https://doi.org/10.1109/ICSESS.2017.8342866

[36] Vikram Saraph and Maurice Herlihy. 2019. An Empirical Study of
Speculative Concurrency in Ethereum Smart Contracts. https://doi.
org/10.48550/ARXIV.1901.01376

[37] Pierre Tholoniat and Vincent Gramoli. 2019. Formally Verifying
Blockchain Byzantine Fault Tolerance. In The 6th Workshop on For-
mal Reasoning in Distributed Algorithms (FRIDA’19). Available at
https://arxiv.org/pdf/1909.07453.pdf.

[38] Gavin Wood et al. 2014. Ethereum: A secure decentralised generalised
transaction ledger. Ethereum project yellow paper 151, 2014 (2014),
1–32.

[39] Anatoly Yakovenko. 2018. Solana: A new architecture for a high

performance blockchain v0. 8.13. Whitepaper (2018).

[40] Anatoly Yakovenko. 2019. SEALEVEL.

https://solana.com/news/

sealevel---parallel-processing-thousands-of-smart-contracts
[41] Anatoly Yakovenko. 2021. Solana: A new architecture for a high
performance blockchain v0.8.13. Accessed: 2021-12-06, https://solana.
com/solana-whitepaper.pdf.

[42] Maofan Yin, Dahlia Malkhi, Michael K. Reiter, Guy Golan Gueta, and
Ittai Abraham. 2019. HotStuff: BFT Consensus with Linearity and Re-
sponsiveness. In Proceedings of the 2019 ACM Symposium on Principles
of Distributed Computing. Association for Computing Machinery, New
York, NY, USA. https://doi.org/10.1145/3293611.3331591

[43] Shuyu Zheng, Haoyu Wang, Lei Wu, Gang Huang, and Xuanzhe Liu.
2020. VM Matters: A Comparison of WASM VMs and EVMs in the
Performance of Blockchain Smart Contracts. https://doi.org/10.48550/
ARXIV.2012.01032

14

