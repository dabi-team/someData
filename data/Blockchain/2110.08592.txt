2
2
0
2

p
e
S
0
1

]

C
D
.
s
c
[

2
v
2
9
5
8
0
.
0
1
1
2
:
v
i
X
r
a

Self-stabilizing Byzantine- and
Intrusion-tolerant Consensus
(preliminary version)

Romaric Duvignau ∗

Michel Raynal †

Elad M. Schiller

One of the most celebrated problems of fault-tolerant distributed computing is the
consensus problem. It was shown to abstract a myriad of problems in which processes
have to agree on a single value. Consensus applications include fundamental services
for the environments of the Cloud or Blockchain. In such challenging environments,
malicious behavior is often modeled as adversarial Byzantine faults. At OPODIS
2010, Most´efaoui and Raynal, in short, MR, presented a Byzantine- and intrusion-
tolerant solution to consensus in which the decided value cannot be a value proposed
only by Byzantine processes. In addition to this validity property, MR has optimal
resilience since it can deal with up to t < n/3 Byzantine processes, where n is the
number of processes. We note that MR provides this multivalued consensus object
(which accepts proposals taken from a set with a ﬁnite number of values) assuming
the availability of a single Binary consensus object (which accepts proposals taken
from the set {0, 1}).

This work, which focuses on multivalued consensus, aims at the design of an even
more robust solution than MR. Our proposal expands MR’s fault-model with self-
stabilization, a vigorous notion of fault-tolerance. In addition to tolerating Byzan-
tine and communication failures, self-stabilizing systems can automatically recover
after the occurrence of arbitrary transient-faults. These faults represent any vio-
lation of the assumptions according to which the system was designed to operate
(provided that the algorithm code remains intact).

To the best of our knowledge, we propose the ﬁrst self-stabilizing solution for
intrusion-tolerant multivalued consensus for asynchronous message-passing systems
prone to Byzantine failures.

1 Introduction

1.1 Background and motivation

The consensus problem is one of the most challenging tasks in fault-tolerant distributed comput-
ing. The problem deﬁnition is rather simple. It assumes that each non-faulty process advocates

∗Department of Computer Science and Engineering, Chalmers University of Technology, Gothenburg, SE-412

96, Sweden. Email: {duvignau,elad}@chalmers.se

†IRISA, University Rennes 1, France and Polytechnic University, Hong Kong. Email: michel.raynal@irisa.fr

1

 
 
 
 
 
 
for a single value from a given set V . The problem of Byzantine-tolerant Consensus (BC) re-
quires BC-completion, i.e., all non-faulty processes decide a value, BC-Agreement, i.e., no two
non-faulty processes can decide diﬀerent values, and BC-validity, i.e., if all non-faulty processes
propose the same value v ∈ V , only v can be decided. When the set, V , from which the pro-
posed values are taken is {0, 1}, the problem is called Binary consensus. Otherwise, it is named
multivalued consensus. This work studies robust solutions to the problem of multivalued con-
sensus that assume access to a single Binary consensus object. We aim at designing solutions
that have higher degrees of dependability than the existing implementations.

1.2 Byzantine fault-tolerance

Lamport, Shostak, and Pease [42] say that a process commits a Byzantine failure if it deviates
from the algorithm instructions, say, by deferring (or omitting) messages that were sent by the
algorithm or sending fake messages, which the algorithm never sent. Such malicious behavior
can be the result of hardware malfunctions or software errors as well as coordinated malware
attacks. In order to safeguard against such attacks, Most´efaoui and Raynal [52, 53] as well as
Correia, Neves, and Ver´ıssimo [19, 55] suggested the BC-no-intrusion validity requirement (aka
intrusion-tolerance). Speciﬁcally, the decided value cannot be a value that was proposed only
by faulty processes. Also, when it is not possible to decide on a value, the error symbol, Ψ, is
returned.

For the sake of deterministic solvability [36, 42, 56, 58], we assume that there are at most t <
n/3 Byzantine processes in the system, where n is the total number of processes. It is also well-
known that no deterministic (multivalued or Binary) consensus solution exists for asynchronous
systems in which at least one process may crash (or one process can be Byzantine) [37]. The
studied multivalued consensus algorithms circumvent this impossibility by assuming that the
system model is enriched with a Byzantine-tolerant object that solves Binary consensus. This
is as in the studied solution by Most´efaoui and Raynal [52], MR from now on, i.e., reducing
multivalued consensus to Binary consensus.

1.3 Self-stabilization

We study an asynchronous message-passing system that has no guarantees on the communica-
tion delay and the algorithm cannot explicitly access the local clock. Our fault model includes
undetectable Byzantine failures. In addition to the failures captured by our model, we also aim
to recover from arbitrary transient-faults, i.e., any temporary violation of assumptions accord-
ing to which the system and network were designed to operate. This includes the corruption
of control variables, such as the program counter and message payloads, as well as operational
assumptions, such as that at most t < n/3 processes are not faulty. Since the occurrence of
these failures can be arbitrarily combined, we assume that these transient-faults can alter the
system state in unpredictable ways. In particular, when modeling the system, Dijkstra [25] as-
sumes that these violations bring the system to an arbitrary state from which a self-stabilizing
system should recover, see [2, 29] for details. I.e., Dijkstra requires (i) recovery after the last
occurrence of a transient-fault and (ii) once the system has recovered, it must never violate the
task requirements. Arora and Gouda [3] refer to the former requirement as the Closure property
and to the latter requirement as the Convergence property.

2

Fig. 1: The studied architecture assumes the availability of an SSBFT protocol for Binary con-
sensus and an SSBFT mechanism for object recycling. The studied problems appear
in boldface fonts. The other layers mentioned in the text above are in plain font, i.e.,
SSBFT BRB, SSBFT BV-broadcast, and SSBFT state machine emulation.

1.4 Related work

Ever since the seminal work of Lamport, Shostak, and Pease [42] four decades ago, Byzantine
fault-tolerant (BFT) consensus has been an active research subject, see [20]. The recent rise
of distributed ledger technologies, e.g., [1], brought phenomenal attention to the subject since
Blockchain technology market worth is expected to reach 395 B USD by 2028. 1 Therefore, we
aim to provide a degree of dependability that is higher than existing solutions.

Ben-Or, Kelmer, and Rabin [7] presented the ﬁrst reduction from BFT multivalued consensus
to BFT Binary consensus. They do not consider intrusion tolerance. As mentioned, Most´efaoui
and Raynal [52, 53] as well as Correia, Neves, and Ver´ıssimo [19, 55] proposed the notion of
intrusion tolerance. Our contribution is a self-stabilizing variation on MR. In other words, we
oﬀer an algorithm for multivalued consensus that is self-stabilizing BFT, in short SSBFT.

There are (non-self-stabilizing) BFT solutions [59] and (crash-tolerant) self-stabilizing solu-
tions [10, 31, 45, 44]. Most´efaoui, Moumen, and Raynal [51, 50] presented BFT algorithms
for solving Binary consensus using common coins. Recently, Georgiou et al.
[38] proposed a
self-stabilizing variation on the one in [50] that satisﬁes the safety requirements, i.e., agreement
and validity, with an exponentially high probability that depends only on a predeﬁned constant.
Georgiou et al.’s solution can be used as the SSBFT Binary consensus object needed for our
solution.

The most related work to our includes SSBFT state-machine replication by Binun et al. [8, 9]
for synchronous systems and Dolev et al. [30] for practically-self-stabilizing partially-synchronous
systems. Note that both Binun et al. and Dolev et al. study another problem for another kind
of system settings. In the broader context of SSBFT solutions for message-passing systems, the
literature studied extensively the problems of clock synchronization [63, 57, 46, 27, 62, 22, 26, 6,
40, 33, 43, 41], storage [14, 13, 17, 16, 15, 12, 11], and gathering of mobile robots [4, 5, 24, 23].
We also ﬁnd solutions for link-coloring [47, 60], topology discovery [32, 54], overlay networks [28],
exact agreement [21] approximate agreement [18], asynchronous unison [34], communication in
dynamic networks [48], and reliable broadcast [35, 49].

1.5 Demonstrating self-stabilization in the studied architecture

Many Cloud computing and distributed ledger technologies are based on state-machine repli-
cation. Following Raynal [59, Ch. 16 and 19], Fig. 1 illustrates how total order broadcast
can facilitate the ordering of the automaton’s state transitions. This order can be deﬁned by

1www.grandviewresearch.com/industry-analysis/blockchain-technology-market.

3

Byzantine-tolerant binary consensus validated Byzantine broadcastmultivalued Byzantine-tolerant consensusByzantine-tolerant reliable broadcastemulation of state-machine replication message-passing systemobject recyclingBinary-values broadcast instances of multivalued consensus objects, which in turn, invokes Binary consensus and Binary-
values broadcast (in short BV-broadcast), such as the SSBFT one by Georgiou et al. [38] as
well as Byzantine-tolerant Reliable Broadcast (in short BRB), such as the SSBFT solution by
Duvignau, Raynal, and Schiller [35]. This work focuses on transforming the non-self-stabilizing
MR solution for Byzantine- and intrusion-tolerant multivalued consensus into one that is self-
stabilizing and Byzantine- and intrusion-tolerant.

Just as MR, we do not focus on the management of consensus invocations since we assume the
availability of a mechanism for eventually recycling all consensus objects that have completed
their tasks. Georgiou et al. use such mechanisms in [39]. In their extended version [38], they
detail the mechanism construction.

When using only a predeﬁned number of objects, the availability of the SSBFT recycling
mechanism allows for the devising of an elegant solution that is based on a code transformation of
the non-self-stabilizing BFT MR algorithm to an SSBFT one. The transformation concentrates
on assuring operation completion since once all objects have been recycled, the system reaches
its post-recycling state, which has no remanence of stale information. Thus, starting at this
state, the system behavior is similar to the one of the non-self-stabilizing BFT MR algorithm.
As mentioned, transient faults are modeled to leave the system in an arbitrary state. In order
to guarantee the operation completion when starting in an arbitrary state, we identify proof
invariants that their violation (due to state corruption) can prevent operation completion. Based
on these invariants, we transform the non-self-stabilizing BFT MR algorithm into an SSBFT
one via the inclusion of invariant tests.

Our correctness proof demonstrates recovery after the occurrence of the last transient fault
by showing that any operation, using the added invariant tests, eventually returns a value
that indicates operation completion.
In other words, we demonstrate that when starting in
an arbitrary system state, eventually, all objects become recyclable. As explained above, by
eventually recycling all of these objects, the system arrives at a post-recycling state. For the
sake of completeness, our proof also shows that, starting at a post-recycling state, the system
satisﬁes the task requirements, which is multivalued consensus.

We clarify that we do not deviate from the analytical framework proposed by Arora and
Gouda [3], which requires the demonstration of the Closure and the Convergence properties. As
mentioned, our correctness proof demonstrates Convergence by showing that the components
used and proposed by our solution always eventually become recyclable. Once they are all
recycled, the system is in its post-recycling state. Starting from that state, Closure is proved.

1.6 Our contribution

We present a fundamental module for dependable distributed systems: an SSBFT algorithm
for multivalued consensus for asynchronous message-passing systems. We obtain this new
self-stabilizing algorithm via a transformation of the non-self-stabilizing MR algorithm by
Most´efaoui and Raynal [52]. MR oﬀers optimal resilience by assuming t < n/3, where t is
the number of faulty processes and n is the total number of processes. The proposed solution
preserves this optimality.

In the absence of transient-faults, our solution achieves consensus within a constant time as in
the MR algorithm. After the occurrence of any ﬁnite number of arbitrary transient-faults, the
system recovers eventually. The communication costs of the studied and proposed algorithms
are similar in the number of BRB and Binary consensus invocations. The main diﬀerence is that
our SSBFT solution uses BV-broadcast for making sure that the value decided by the SSBFT
Binary consensus object remains consistent until the proposed SSBFT solution completes its

4

task and is ready to be recycled.

To the best of our knowledge, we propose the ﬁrst self-stabilizing Byzantine- and intrusion-
tolerant algorithm for solving multivalued consensus in asynchronous message-passing systems
that are enriched by a single SSBFT Binary consensus object and two SSBFT BRB objects. We
believe that our solution can stimulate research for the design of algorithms for the environments
of the Cloud and distributed ledger technologies that are far more robust than the existing
implementations since the latter cannot recover after the occurrence of transient faults.

For the reader’s convenience, Table 1 in the Appendix includes the Glossary, where all ab-

breviations are listed.

2 System Settings

We consider an asynchronous message-passing system that has no guarantees on the commu-
nication delay. Also, the algorithm cannot explicitly access the (local) clock (or use timeout
mechanisms). The system consists of a set, P, of n fail-prone nodes (or processes) with unique
identiﬁers. Any pair of nodes pi, pj ∈ P has access to a bidirectional communication channel,
channel j,i, that, at any time, has at most channelCapacity ∈ Z+ packets on transit from pj to
pi (this assumption is due to a known impossibility [29, Chapter 3.2]).

In the interleaving model [29], the node’s program is a sequence of (atomic) steps. Each step
starts with an internal computation and ﬁnishes with a single communication operation, i.e.,
a message send or receive. The state, si, of node pi ∈ P includes all of pi’s variables and
channel j,i. The term system state (or conﬁguration) refers to the tuple c = (s1, s2, · · · , sn). We
deﬁne an execution (or run) R = c[0], a[0], c[1], a[1], . . . as an alternating sequence of system
states c[x] and steps a[x], such that each c[x + 1], except for the starting one, c[0], is obtained
from c[x] by a[x]’s execution.

2.1 The fault model and self-stabilization

The legal executions (LE) set refers to all the executions in which the requirements of task T
hold. In this work, TMVC denotes the task of multivalued consensus, which Section 1 speciﬁes,
and the executions in the set LEMVC fulﬁll TMVC’s requirements.

2.1.1 Arbitrary node failures.

Byzantine faults model any fault in a node including crashes, and arbitrary malicious behaviors.
Here the adversary lets each node receive the arriving messages and calculate its state according
to the algorithm. However, once a node (that is captured by the adversary) sends a message, the
adversary can modify the message in any way, delay it for an arbitrarily long period or even re-
move it from the communication channel. The adversary can also send messages spontaneously.
Note that the adversary has the power to coordinate such actions without any limitation on
his computational or communication power. For the sake of solvability [42, 56, 61], the fault
model that we consider limits only the number of nodes that can be captured by the adversary.
That is, the number, t, of Byzantine failures needs to be less than one-third of the number, n,
of nodes in the system, i.e., 3t + 1 ≤ n. The set of non-faulty nodes is denoted by Correct and
called the set of correct nodes.

5

2.1.2 Arbitrary transient-faults

We consider any temporary violation of the assumptions according to which the system was
designed to operate. We refer to these violations and deviations as arbitrary transient-faults
and assume that they can corrupt the system state arbitrarily (while keeping the program code
intact). The occurrence of a transient fault is rare. Thus, we assume that the last arbitrary
transient fault occurs before the system execution starts [29]. Also, it leaves the system to start
in an arbitrary state.

2.2 Dijkstra’s self-stabilization

An algorithm is self-stabilizing with respect to LE, when every execution R of the algorithm
reaches within a ﬁnite period a suﬃx Rlegal ∈ LE that is legal. Namely, Dijkstra [25] requires
∀R : ∃R(cid:48) : R = R(cid:48) ◦ Rlegal ∧ Rlegal ∈ LE ∧ |R(cid:48)| ∈ Z+, where the operator ◦ denotes that
R = R(cid:48) ◦ R(cid:48)(cid:48) is the concatenation of R(cid:48) with R(cid:48)(cid:48). The part of the proof that shows the existence
of R(cid:48) is called the convergence (or recovery) proof, and the part that shows that Rlegal ∈ LE
is called the closure proof. Recall that in Section 1.5, we explain the connection between
convergence and closure as well as the SSBFT recycling mechanism, SSBFT recyclable objects,
and the post-recycling state.

2.3 External Building blocks

As mentioned, we assume the availability of an SSBFT recycling mechanism (Section 1.5) for
BRB and consensus objects, as the ones proposed by Georgiou et al. [39, 38] and Duvignau,
Raynal, and Schiller [35]. Recycling occurs eventually after all of the objects complete their
tasks. We specify below the object that this paper assumes to be available.

2.3.1 SSBFT Byzantine-tolerant Reliable Broadcast (BRB)

The communication abstraction of Byzantine Reliable Broadcast (BRB) allows every node to
invoke the broadcast(v) : v ∈ V and deliver(k) : pk ∈ P operations.

Deﬁnition 2.1 The operations broadcast(v) and deliver(k) should satisfy the following.

• BRB-validity.

Suppose a correct node BRB-delivers message m from a correct node

pi. Then, pi had BRB-broadcast m.

• BRB-integrity. No correct node BRB-delivers more than once.

• BRB-no-duplicity. No two correct nodes BRB-deliver diﬀerent messages from pi (who

might be faulty).

• BRB-completion-1.
from pi eventually.

• BRB-completion-2.

Suppose pi is a correct sender. All correct nodes BRB-deliver

Suppose a correct node BRB-delivers a message from pi (who

might be faulty). All correct nodes BRB-deliver pi’s message eventually.

We assume the availability of an SSBFT BRB implementation, such as the one by Duvignau,
Raynal, and Schiller [35]. Such implementation lets pi ∈ P to use the operation deliveri(k) for
retrieving the current return value, v, of the BRB broadcast from pk ∈ P. Before the completion
of the task of the deliveri(k) operation, v’s value is ⊥. This way, whenever deliveri(k) (cid:54)= ⊥, node
pi knows that the task is completed and the returned value can be used.

6

2.3.2 SSBFT Binary-values Broadcast (BV)

This is an all-to-all broadcast operation of Binary values. It uses the operation, bvBroadcast(v),
which is assumed to be invoked by all the correct nodes, where v, w ∈ {0, 1}. The set of values
that are BV-delivered to node pi can be retrieved via the function binValues i(), which returns
∅ before the arrival of any bvBroadcast() by a correct node. We specify under which conditions
values are added to binValues().

• BV-validity. Suppose that v ∈ binValues i() and pi is correct. It holds that v has been

BV-broadcast by a correct node.

• BV-uniformity. v ∈ binValues i() and pi is correct. Eventually ∀j ∈ Correct : v ∈

binValues j().

• BV-completion. Eventually ∀i ∈ Correct : binValues i() (cid:54)= ∅ holds.

The above requirements imply that eventually ∃s ⊆ {0, 1} : s (cid:54)= ∅∧∀i ∈ Correct : binValues i() =

s and the set s does not include values that were BV-broadcast only by Byzantine nodes. We
note the existing SSBFT solutions for BV-broadcast Georgiou et al. [38], which we use. Geor-
giou et al.’s implementation allows the correct nodes to repeat a BV-broadcast using the same
BV object. Our proof uses the fact that, as long as the correct nodes do not change their
BV-broadcast messages, the requirements above hold.

2.3.3 SSBFT Binary Consensus

As mentioned, the studied solution reduces multivalued consensus to Binary consensus by en-
riching the system model with a BFT object that solves Binary consensus (Deﬁnition 2.2).

Deﬁnition 2.2 Every pi ∈ P has to propose a value vi ∈ V = {False, True} via an invocation
of the proposei(vi) operation. (We prefer V = {False, True} over the traditional representation
of V = {0, 1}.) Let Alg be an algorithm that solves Binary consensus. Alg has to satisfy safety,
i.e., BC-validity and BC-agreement, and liveness, i.e., BC-completion, requirements.

• BC-validity. The value v ∈ {False, True} decided by a correct node is a value proposed

by a correct node.

• BC-agreement. Any two correct nodes that decide, do so with identical decided values.

• BC-completion. All correct nodes decide.

We assume that availability of SSBFT Binary consensus, such as Georgiou et al. [38], which
might fail to decide with negligible probability. If that failure occurs, Georgiou et al.’s solution
might return the error symbol, Ψ, instead of a legitimate value from the set {0, 1}.

3 The Studied Algorithms

The MR solution is based on a reduction of the studied problem to BFT Binary consensus. MR
guarantees that the decided value is not a value proposed only by Byzantine nodes. Also, if there
is a value, v ∈ V , that all correct nodes propose, then v is decided. Otherwise, the decided value
is either a value proposed by the correct nodes or the error symbol, Ψ. This way, an adversary
that command its captured nodes to propose the same value, say, vbyz ∈ V , cannot lead to the
selection of vbyz without the support of at least one correct node. As depicted in Fig. 1, the MR
reduction is based on a communication abstraction, named Validated Byzantine Broadcast, in
short VBB, which we present in Section 3.1 before the reduction itself (Section 3.2).

7

Algorithm 1: Non-self-stabilizing BFT VBB-broadcast; code for pi

1 operation vbbBroadcast(v) begin
BRB-broadcast INIT(i, v);
2
wait |rec|≥n−t where rec is the multiset of BRB-delivered values;
BRB-broadcast VALID(i, (equal (v, rec) ≥ n−2t));

3

4

5 foreach pj ∈ P execute concurrently do
6

wait INIT(j, v) and VALID(j, x) BRB-delivered from pj;
if x then {wait (equal (v, rec) ≥ n−2t); d ← v};
else {wait (diﬀer (v, rec) ≥ t+1); d ← Ψ};
vbbDeliver(d) at pi as the value VBB-broadcast by pj;

7

8

9

3.1 Validated Byzantine Broadcast (VBB)

This communication abstraction sends messages from all nodes to all nodes.
It oﬀers the
operation, vbbBroadcast(v) and raises the event vbbDeliver(d), for VBB-broadcasting, and resp.,
VBB-delivering messages.

3.1.1 Speciﬁcations

We detail VBB-broadcast requirements below.

• VBB-validity. VBB-delivery of messages needs to relate to VBB-broadcast of messages

in the following manner.

– VBB-justiﬁcation.

Suppose pi : i ∈ Correct VBB-delivers message m (cid:54)= Ψ from
some (faulty or correct) node. There is at least one correct node that VBB-broadcast
m.

– VBB-obligation. Suppose all correct nodes VBB-broadcast the same v. All correct

nodes VBB-delivers v from each correct node.

• VBB-uniformity.

Let pi : i ∈ Correct. Suppose VBB-delivers m(cid:48) ∈ {m, Ψ} from a
(possibly faulty) node pj. All the correct nodes VBB-deliver the same message m(cid:48) from
pj.

• VBB-completion.

Suppose pi VBB-broadcasts m, such that i ∈ Correct. All the

correct nodes VBB-deliver from pi.

We also say that a complete VBB-broadcast instance includes vbbBroadcasti(mi) invocation
by every correct node pi ∈ P. It also includes vbbDeliver() of m(cid:48) from at least (n−t) distinct
nodes, where m(cid:48) is either pj’s message, mj, or the error symbol, Ψ. The latter value is returned
when a message from a given sender cannot be validated. This validation requires mj to be
VBB-broadcast by at least one correct node. That is, to be VBB delivered from at least (t+1)
diﬀerent nodes (including its sender pj), because no node pi can foresee its prospective failures,
e.g., due to unexpected crashes.

8

3.1.2 Implementing VBB-broadcast

Algorithm 1 presents the studied VBB-broadcast.
Notation: Let |rec| denote the number of elements in the multiset rec. We use equal (v, rec)
and diﬀer (v, rec) to return the number of occurrences in rec that are equal to, and resp.,
diﬀerent from v.
Overview: Algorithm 1 invokes BRB-broadcast twice in the ﬁrst part of the algorithm (lines 1
to 4) and then VBB-delivers messages from nodes in the second part (lines 5 to 9).

Node pi ﬁrst BRB-broadcasts INIT(i, vi) (where vi is the VBB-broadcast message), and sus-
pends until the arrival of INIT() from at least (n−t) diﬀerent nodes (lines 2 to 3), which pi
collects in the multiset reci. In line 2, node pi tests whether vi was BRB-delivered from at
least n−2t ≥ t+1 diﬀerent nodes. Since this means that vi was BRB-broadcast by at least one
correct node, pi attests to the validity of vi (line 4). Recall that each time INIT() arrives at pi,
the message is added to reci. Therefore, the fact that |reci| ≥ n−t holds (line 3) does not keep
reci from growing.

Algorithm 1’s second part (lines 5 to 9) includes n concurrent background tasks. Each task
aims at VBB-delivering a message from a diﬀerent node, say, pj.
It starts by waiting until
pi BRB-delivered both INIT(j, vj) and VALID(j, xj) from pj so that pi has both pj’s VBB’s
values, vj, and the result of its validation test, xj.

• The case of xj = True (line 7).

Since pj might be faulty, we cannot be sure that vj
was indeed validated. Thus, pi re-attests vj by waiting until equal (vj, reci) ≥ n−2t holds.
If this ever happens, pi VBB-delivers vj as a message from pj, because the wait condition
implies that equal (vj, reci) ≥ t+1 since n−2t ≥ t+1.

• The case of xj = False (line 8).

For similar reasons to the former case, pi needs to
wait until reci contains at least t+1 items that are not vj, because this implies that at
least one correct note cannot attest vj’s validity. If this ever happens, pi VBB-delivers
the error symbol, Ψ, as the received message from pj.

3.1.3 Invariants that could be violated due to transient faults

The occurrence of a transient fault can violate the following invariants, which an SSBFT solution
needs to address.

1. The state of node pi must not encode the occurrence of BRB execution of phase valid

(line 4) without encoding BRB execution of phase init (line 2).

2. For a given phase, phs ∈ vbbMSG, the format of a message that is BRB-delivered must
follow the one of BRB-broadcast of phase phs, i.e., (k, v) : pk ∈ P ∧ v ∈ V for phase init
and (k, x) : pk ∈ P ∧ x ∈ {False, True} for phase valid.

3. For a given phase, phs ∈ vbbMSG, if at least n − t diﬀerent nodes BRB-delivered messages
of phase phs, to node pi, the state of pi must lead to the next phase, i.e., from init to
valid, or from valid to operation complete, in which VBB-deliver a non-⊥ value.

3.2 Multivalued Byzantine-tolerant Consensus

Algorithm 2 reduces any instance of the BFT multivalued consensus problem to BFT Binary
consensus in message-passing systems that have up to t < n/3 Byzantine nodes. Algorithm 2

9

Algorithm 2: Non-self-stabilizing BFT multivalued consensus; code for pi

10 variables: bcO := ⊥; /* Binary consensus object, ⊥ is the initial state. */;

11 macro sameValue() do return ∃v (cid:54)= Ψ : equal (v, rec) ≥ n−2t ∧ rec = {v(cid:48) (cid:54)= Ψ}

where rec is a multiset of the values VBB-delivered (line 14)

12 operation propose(v) begin
13

vbbBroadcast EST(v);
wait EST(•) messages VBB-delivered from (n−t) diﬀerent nodes;
if ¬bcO.propose(sameValue()) then return Ψ;
else wait (∃v (cid:54)= ⊥ : equal (v, rec) ≥ n−2t) return (v);

14

15

16

uses VBB-broadcast abstraction (Algorithm 1). Note that the line numbers of Algorithm 2
continue the ones of Algorithm 1.

3.2.1 Speciﬁcations

Recall the task of multivalued Byzantine- and intrusion-tolerant consensus includes the require-
ments of BC-validity, BC-agreement, and BC-completion (Section 1.1) as well as the BC-no-
Intrusion property (Section 1.2).

3.2.2 Implementation

Node pi has to wait for EST() messages from (n−t) diﬀerent nodes after it as VBB-broadcast
its own value (lines 13 to 14). It holds all the VBB-delivered values in the multiset reci (line 11)
before testing whether reci includes (1) non-Ψ replies from at least (n−2t) diﬀerent nodes, and
(2) exactly one non-Ψ value v (line 11). The test result is proposed to the Binary consensus
object, bcO (line 15).

Once consensus was reached, pi decides according to the consensus result, bcO i.result().
Speciﬁcally, if bcO i.result() = False, pi returns the error symbol, Ψ, since there is no guar-
antee that any correct node was able to attest to the validity of the proposed value. Otherwise,
pi waits until it received EST(v) messages that have identical values from at least (n−2t) diﬀer-
ent nodes (line 16) before returning that value v. Note that some of these (n−2t) messages were
already VBB-delivered at line 14. The proof in [52] shows that any correct node that invokes
bcO i.propose(True) does so if all correct nodes eventually VBB-deliver identical values at least
(n−2t) times. Then, any correct node can decide on the returned value for the multivalued
consensus object once it also VBB-delivers identical values at least (n−2t) times.

3.2.3 Invariants that could be violated due to transient faults

The occurrence of a transient fault can let the Binary consensus object decide on a value never
proposed, i.e., violates BC-validity. Any SSBFT solution needs to address this concern since
the multivalued consensus object can block indeﬁnitely if bcO decides True when for all correct
nodes, pi, sameValue i() = False holds.

10

Algorithm 3: Self-stabilizing Byzantine-tolerant VBB-broadcast; code for pi

17 types: vbbMSG := {init, valid};

18 variables: brb[vbbMSG][P] := [[⊥, . . . , ⊥], [⊥, . . . , ⊥]] /* Two phases of BRB objects.

The value ⊥ represents the post-recycling state. */

19 macros: vbbEcho(phs) do return ∃S⊆P:n−t≤|S|∀pk∈S brb[phs][k].deliver() (cid:54)= ⊥;
20 vbbEq(phs, v) := ∃S⊆P:n−2t≤|S|∀p(cid:96)∈S(v = brb[phs].deliver((cid:96)));
21 vbbDiﬀ (phs, v) := ∃S⊆P:t+1≤|S|∀p(cid:96)∈S(v (cid:54)= brb[phs].deliver((cid:96)));

22 operations: vbbBroadcast(v) do brb[init][i].broadcast((i, v));
23 vbbDeliver(k) begin
24

if brb[init][k] = ⊥ ∧ brb[valid][k] (cid:54)= ⊥ then return Ψ;
if ∃pj, pk ∈ P, phs ∈ vbbMSG : brb[phs][j].deliver() = (k, -) ∧ j (cid:54)= k then return Ψ;
if brb[init][k].deliver() (cid:54)= (k, v) ∨ brb[valid][k].deliver() (cid:54)= (k, x) then return ⊥;
else if v /∈ V ∨ x /∈ {False, True} then return Ψ;
else if x ∧ vbbEq(valid, v) then return v;
else if ¬x ∧ vbbDiﬀ (valid, v) then return Ψ;
else if vbbEcho(valid) then return Ψ;
return ⊥ ;

25

26

27

28

29

30

31

32 do-forever begin
33

if vbbEcho(init) ∧ v (cid:54)= ⊥ where v = brb[init][i].deliver() then

34

brb[valid][i].broadcast((i, vbbEq(init, v)))

4 Self-stabilizing Byzantine-tolerant Multivalued Consensus

Algorithms 4 and 3 present our self-stabilizing Byzantine- and intrusion-tolerant solution to the
problem of multivalued consensus using an SSBFT VBB-broadcast solution. They are obtained
from algorithms 1 and 2 via code transformation and the addition of necessary consistency tests
(sections 3.1.3 and 3.2.3). Note that the line numbers of algorithms 3 and 4 continue the ones
of Algorithm 2.

4.1 SSBFT VBB-broadcast

The operation vbbBroadcast(v) allows the invocation of a VBB-broadcast instance with the
value v. Node pi VBB-delivers messages from pk via vbbDeliveri(k).

4.1.1 Types, constants, and variables

We deﬁne the phase types of vbbMSG := {init, valid} (line 17) and the array brb[vbbMSG][P]
for holding BRB objects, which disseminate VBB-broadcast messages, i.e., brb[init] and
brb[valid] store the information that VBB-broadcast disseminate of INIT(), and resp., VALID()
messages in Algorithm 1. After the recycling of these objects (Section 1.5) or before they ever
become active, they each have the value [⊥, . . . , ⊥]. They become active via the invocation, say
by pi, of brbi[-][i].broadcast(v) (which also leads to brbi[-][i] (cid:54)= ⊥) or the arrival of BRB protocol

11

Algorithm 4: Self-stabilizing Byzantine- and intrusion-tolerant multivalued consen-
sus via VBB-broadcast; code for pi

35 variables: bvO := ⊥; /* Binary-values object, ⊥ is the post-recycling state. */;
36 bcO := ⊥; /* Binary consensus object, ⊥ is the post-recycling state. */;

37 macros: mcEcho() := ∃S⊆P:n−t≤|S|∀pk∈S(vbbDeliver(k) (cid:54)= ⊥);
38 sameValue() do return (∃v /∈{⊥,Ψ}∃S(cid:48)⊆P:n−2t≤|S(cid:48)|∀pk(cid:48) ∈S(cid:48)(vbbDeliver(k(cid:48)) =

v)) ∧ (|{vbbDeliver(k) /∈ {⊥, Ψ} : pk ∈ P}| = 1);

39 operations: propose(v) do vbbBroadcast(v);
40 result() begin
41

if bcO = ⊥ ∨ bcO.result() = ⊥ then return ⊥;
else if ¬bcO.result() then return Ψ;
else if ∃v /∈{⊥,Ψ}∃S(cid:48)⊆P:n−2t≤|S(cid:48)|∀pk(cid:48) ∈S(cid:48)(vbbDeliver(k(cid:48)) = v) then return v;
else if mcEcho() ∨ True /∈ bvO.binValues() then return Ψ;
return ⊥;

42

43

44

45

46 do-forever begin
47

if mcEcho() then

48

49

if bcO = ⊥ then bcO.propose(sameValue());
bvO.broadcast(sameValue());

messages, say, from pj (which leads to brbi[-][j] (cid:54)= ⊥). We clarify that once a BRB message
arrives, a call to brbi[-][j].delivery() can retrieve the arriving message.

4.1.2 The vbbBroadcast() operation (lines 22 and 33)

As in line 2 in Algorithm 1, the invocation of vbbBroadcast(v) (line 22) leads to the invocation
of brb[init][-].broadcast(v). Algorithm 4 uses line 33 for implementing the logic of lines 3 and 4
in Algorithm 1 as well as the consistency test of item 3 in Section 3.1.3; that case of moving
from phase init to valid. In detail, the macro vbbEcho(phs) returns True whenever the BRB
object brb[phs] has a message to BRB-deliver from at least n − t diﬀerent nodes. Thus, pi can
“wait” for BRB deliveries from at least n − t distinct nodes by testing vbbEchoi(init) ∧ v (cid:54)= ⊥,
where v = brbi[init][i].deliver(). Also, the macro vbbEq() is a detailed implementation of the
function equal () used by Algorithm 1.

4.1.3 The vbbDeliver() operation (lines 23 and 31)

The proposed vbbDeliver() (lines 23 to 31) is based on lines 5 and 9 in Algorithm 1 together
with a number of consistency tests, which are listed in Section 3.1.3.

The ﬁrst if-statement (line 24) considers the (inconsistent) case in which the state of node
pi encodes the fact that VBB-broadcast of the VALID() message occurred before the one of
INIT() message. This matches item 1 in Section 3.1.3.

The second, third, and fourth if-statements (lines 24 to 29) implement the logic of lines 6 to 8
in Algorithm 1. Similar to line 6 in Algorithm 1, xi is the value that line 26 uses for holding

12

the value of that pi BRB-delivers from pk via the BRB object brbi[valid]. Also, the macro
vbbDiﬀ () is a detailed implementation of the function diﬀer () used by Algorithm 1. We clarify
that lines 25 and 27 return Ψ when the delivered BRB message is ill-formatted. By that, they
ﬁt the consistency test of item 2 in Section 3.1.3; the case of transitioning from phase valid to
operation completion.

The ﬁfth if-statement (line 30) considers the case in which the variable xi is corrupted. Thus,
there is a need to return the error symbol, Ψ. This happens when pi VBB-delivered VALID()
messages from at least n−t diﬀerent nodes, but none of the if-stamemnt conditions in lines 24
to 29 hold. This ﬁts the consistency test of item 3 in Section 3.1.3, which requires eventual
completion even in the presence of transient faults.

4.2 SSBFT multivalued consensus

The invocation of the propose(v) operation VBB-broadcasts v. Node pi VBB-delivers messages
from pk via the resulti() operation. The logic of lines 12 and 16 in Algorithm 2 is implemented
by lines 39 to 48 in Algorithm 4.

Algorithm 4’s state includes the SSBFT BV object, bvO, and SSBFT Binary object, bcO.
Each has the post-recycling value of ⊥, i.e., when bvO = ⊥ (or bcO = ⊥) the object is said to
be inactive. They become active upon invocation and complete according to their speciﬁcations
(sections 2.3.1 and 2.3.2, resp.).

Just like in lines 12 and 13 in Algorithm 2, the invocation of propose(v) (line 39) leads to the

VBB-broadcast of v.

The logic of lines 14 and 15 in Algorithm 2 is implemented by line 48.

In detail, if bcO
is in its post-recycling state (Section 1.5) and there are ready-to-be-delivered VBB messages
from at least n − t diﬀerent nodes, Algorithm 4 proposes the returned value from sameValue().
Note that the macro sameValue() (line 11) implements that predicate sameValue() (line 38 in
Algorithm 2). Line 49 facilitates the implementation of the consistency test (Section 3.2.3) by
BV-broadcasting the returned value sameValue(). This way it is possible to detect the case in
which all correct nodes BV-broadcast a value that is, due to a transient fault, diﬀerent than
bcO’s decided one. We explain how this can be done when we discuss line 44.

The operation result() (lines 40 to 45) returns the decided value, which lines 15 and 16
implement in Algorithm 2. Since result() is a query-based operation (Section 2.3.1), line 41
considers the case in which the decision has yet to occur, i.e., it returns the ⊥-value. Line 44
considers the case that line 15 in Algorithm 2 deals with and returns the error symbol, Ψ.
Line 43 implements line 16 in Algorithm 2. Line 44 performs a consistency test for the case
in which there are VBB-deliveries from at least n − t diﬀerent nodes and yet the predicate
sameValue() of all correct nodes does not hold, according to the values delivered via the BV-
broadcast. This deals with the consistency test described in Section 3.2.3. Line 45 deals with
the case in which none of the conditions of the if-statements above (lines 41 to 43) hold, and
thus, ⊥ needs to be returned.

5 Correctness

We provide correctness proof for algorithms 3 and 4. The proof is organized as follows. For
every layer, i.e., VBB-broadcast and multivalued consensus, we provide proof of completion
(theorems 5.1 and resp., 5.6) before demonstrating the closure properties (theorems 5.2, and
resp., 5.9), which show the satisfaction of the requirements of every layer. The main diﬀerence
between the completion and the closure proofs is that the latter considers post-recycling starting

13

system states (Section 1.5) and complete (i.e., proper) invocation of operations. Due to the
page limit, some of the proof details appear in the Appendix.

5.1 Completion of VBB-broadcast

As explained in Section 1.5, the availability of the object recycling mechanism allows us to
focus on the completion property when demonstrating recovery after the occurrence of the last
transient fault. Once all (possibly corrupted) objects have completed their tasks, the mechanism
will bring these objects to their post-recycling state from which the closure property can be
demonstrated (Section 5.2).

Theorem 5.1 (VBB-completion) Let R be an Algorithm 4’s execution in which all correct
nodes eventually invoke vbbBroadcast(). Eventually, ∀i,j∈Correct vbbDeliverj(i) (cid:54)= ⊥.

Proof of Theorem 5.1 Let i ∈ Correct. Suppose either pi VBB-broadcasts m in R or
∃phs ∈ vbbMSG : brbj[phs][i] (cid:54)= ⊥ holds in R’s starting state. We demonstrate that all correct
nodes VBB-deliver m(cid:48)
(cid:54)= ⊥ from pi by considering all the if-statements in lines 24 to 30 and
showing that eventually one of the if-statements in lines 24 and 27 to 30 holds.

Argument 1. Suppose ∃phs ∈ vbbMSG : brbj[phs][i] (cid:54)= ⊥. ∀k,(cid:96)∈Correct : brbk[phs][(cid:96)] (cid:54)= ⊥ holds
eventually. The argument is implied directly from BRB-completion-1 and BRB-completion-2.

Argument 2. Suppose that throughout R, the if-statement condition in line 24 does not hold.
Eventually, brbi[valid][i] (cid:54)= ⊥ holds.
By the assumption that all correct nodes are active
eventually, the BRB properties (Deﬁnition 2.1) and that there are at least (n−t) correct nodes,
the if-statement condition in line 33 holds eventually. Then, pi makes sure that, eventually,
the second clause in the condition of the if-statement in line 33 does not hold by invoking
brbi[valid][i]broadcast(-) and BRB-completion.

Argument 3. Suppose brbi[valid][i] (cid:54)= ⊥ holds in R’s starting state. Eventually, either the
if-statement condition in line 24 holds or the one in line 26 cannot hold. The proof is directly
implied by the code of Algorithm 4.

Argument 4. Eventually, vbbDeliverj(i) (cid:54)= ⊥ holds.
Suppose that none of the if-statements
in lines 24 to 25 and 27 to 29 ever hold. Due to vbbEcho()’s deﬁnition (line 19), the BRB
properties (Deﬁnition 2.1), the presence of at least n−t correct and eventually active nodes,
and arguments (1) to (3), the if-statement condition in line 30 eventually holds. (cid:50)T heorem 5.1

5.2 Closure of VBB-broadcast

Theorem 5.2’s proof mostly follows the arguments used for showing MR’s correctness. But,
there is a need to show that none of the consistency tests causes false error indications.

Theorem 5.2 (VBB-Closure) Let R be an Algorithm 4’s execution in which all correct nodes
eventually invoke vbbBroadcast() and R’s starting system state is post-recycling (Section 1.5).
Execution R satisﬁes the VBB requirements (Section 3.1.1).

Proof of Theorem 5.2 VBB-completion holds (Theorem 5.1).

Lemma 5.3 (VBB-uniformity) VBB-uniformity holds.

14

Proof of Lemma 5.3 Let i ∈ Correct. Suppose pi VBB-delivers m(cid:48) ∈ {m, Ψ} from a
(possibly faulty) pj ∈ P. The proof shows that all the correct nodes VBB-deliver the same
message m(cid:48) from pj. Since R is post-recycling and pi VBB-delivers m(cid:48) from node pj, the
condition brbi[init][j] = ⊥ ∧ brbi[valid][j] (cid:54)= ⊥ (of the if-statement in line 24) cannot hold
and eventually (brbi[init][j].deliver() = (j, vj,i) ∧ brbi[valid][j].deliver() = (j, xj,i)) (line 26)
must hold due to BRB-completion-1 and since all correct nodes are active eventually. Also,
brbk[init][j] = ⊥ ∧ brbk[valid][j] (cid:54)= ⊥ cannot hold. And, (brbk[init][j].deliver() = (j, vj,k) ∧
brbk[valid][j].deliver() = (j, xj,k)) holds eventually, such that vj,i = vj,k and xj,i = xj,k. This
is because R starts in a post-recycling system state, BRB-no-duplicity, and BRB-completion-2,
which means that every correct node pk eventually BRB-delivers the same messages that pi
delivers. Due to similar reasons, depending on the value of xj,i = xj,k, the condition of the
if-statement in lines 28 or 29 must hold. I.e., pk eventually VBB-delivers the same value as pi
(cid:50)Lemma 5.3
does.

Lemma 5.4 (VBB-obligation) VBB-obligation holds.

Proof of Lemma 5.4 Suppose all correct nodes, pj, VBB-broadcast the same value v. The
proof shows that every correct node, pi, VBB-delivers v from pj. Since every correct node even-
tually invokes vbbBroadcast(v), node pj invokes brbj[init][j].broadcast((j, v)) (line 22). Thus,
the if-statement condition in line 33 holds eventually for any correct node pi, i.e., it is true
since ∃S⊆P:n−t≤|S| : ∀pk∈P : brbi[init][k].deliver() (cid:54)= ⊥ holds eventually due BRB-completion-1.
Also, there are at least (n−2t) appearances of (-, v) in the multi-set {brbi[init][k].deliver()}pk∈P .
Thus, pi BRB-broadcasts the message (valid, (i, True)) (line 34). And, for any k, (cid:96) ∈ Correct,
brbk[valid][(cid:96)].deliver() = (j, True) holds eventually (due to BRB-validity and BRB-completion-
1). This means that, eventually, none of the if-statement conditions at lines 24 to 27 holds.
However, the if-statement condition in line 28 must hold eventually and only for the value v.
Then, every correct node, pk, VBB-delivers v as the value VBB-broadcast by pj. (cid:50)Lemma 5.4

Lemma 5.5 (VBB-justiﬁcation) VBB-justiﬁcation holds.

Proof of Lemma 5.5 Let i ∈ Correct. Suppose pi VBB-delivers m /∈ {⊥, Ψ} in step ai ∈ R.
The proof shows that a correct node, pj, invokes vbbBroadcastj(v) : m = (j, v) in aj ∈ R, such
that aj appears in R before ai. Since m /∈ {⊥, Ψ}, the predicates (brbi[init][j].deliver() =
(j, v) ∧ brbi[valid][k].deliver() = (k, x)) (line 26) and x ∧ vbbEq(valid, v) (line 28) hold, because
line 28 is the only line in vbbDeliver()’s code that returns a value that is neither ⊥ nor Ψ and it
can only do so when the if-statement condition in line 26 does not hold. Since vbbEq i(valid, v)
holds and n−2t ≥ t+1, at least one correct node, say, pj that had BRB-broadcast v (both for
the init and valid phases in lines 22, and resp., 34), because R starts in a post-recycling state
and by Theorem 5.1’s Argument (2). Thus, aj appears in R before ai. (cid:50)Lemma 5.5 (cid:50)T heorem 5.2

5.3 Completion of multivalued consensus

As explained (sections 1.5 and 5.1), we demonstrate recovery from transient faults by demon-
strating completion (due to the availability of the recycling mechanism).

Theorem 5.6 (BC-completion) Let R be an Algorithm 4’s execution in which all correct
nodes eventually invoke propose(). The BC-completion property holds during R.

Proof of Theorem 5.6 The proof shows that every correct node decides eventually, i.e.,
∀i ∈ Correct : resulti() (cid:54)= ⊥.

15

Lemma 5.7 Eventually, resulti() cannot return ⊥ due to the if-statement in line 41.

Proof of Lemma 5.7 Any correct node, pi, makes sure that bcO i (cid:54)= ⊥, say, by invoking
bcO i.propose() (line 48). This is due to the assumption that all correct nodes are eventually
active, the deﬁnition of propose() (line 39), VBB-completion, and the presence of at least (n−t)
correct nodes, which implies that ∃S⊆P:n−t≤|S|∀pk∈S vbbDeliver(k) (cid:54)= ⊥ holds eventually and
the if-statement condition in line 48 holds whenever bcO i = ⊥. Eventually bcO i.result() (cid:54)= ⊥
(by the completion property of Binary consensus). Thus, resulti() cannot return ⊥ due to the
(cid:50)Lemma 5.7
if-statement in line 41.

If resulti() returns due to the if-statement in lines 42 to 44, then resulti() (cid:54)= ⊥ is straightfor-
ward. Therefore, the rest of the proof focuses on showing that eventually one of these three
if-statement conditions must hold and thus the last return statement (of ⊥ in line 45) cannot
occur, see Lemma 5.8.

Lemma 5.8 Suppose that, for any correct node, pi, the if-statement conditions in lines 42
and 44 never hold in R. Eventually, the if-statement conditions in line 43 holds.

Proof of Lemma 5.8 By VBB-completion, mcEchoi() (line 37) must hold eventually since
there are n − t correct and eventually active nodes. Thus, by the lemma assumption that the if-
statement conditions in line 44 never hold in R, we know that, for any correct node pi, eventually
True ∈ bvO i.binValues() holds, due to the proporties of BV-broadcast (Section 2.3.2). Thus,
there is at least one correct node, pj, for which sameValue j() = True when BV-broadcasting
in line 49. By VBB-uniformity, the if-statement condition in line 43 must hold eventually for
(cid:50)T heorem 5.6
every correct node pi.

(cid:50)Lemma 5.8

5.4 Closure of multivalued consensus

Theorem 5.9’s proof mostly follows the arguments used for showing MR’s correctness. But,
there is a need to show that none of the consistency tests causes false error indications.

Theorem 5.9 (MVC closure) Let R be an Algorithm 4’s execution that starts in a post-
recycling system state and in which all correct nodes eventually invoke propose(). The MVC
requirements hold during R.

Proof of Theorem 5.9 BC-completion holds due to Theorem 5.6.

Lemma 5.10 The BC-agreement property holds.

Proof of Lemma 5.10 We show that no two correct nodes decide diﬀerently. For every correct
node, pi, bcO i.result() (cid:54)= ⊥ holds eventually (Theorem 5.6). By the agreement and integrity
properties of Binary consensus, bcO i.result() = False implies BC-agreement (line 42).

Suppose bcO i.result() = True. The proof is implied since there is no correct node, pi, and
(faulty or correct) node pk for which there is a value w /∈ {⊥, Ψ, v}, such that vbbDeliveri(k) = w.
This is due to n−2t ≥ t + 1 and sameValue()’s second clause (line 38), which requires v to be
(cid:50)Lemma 5.10
unique.

Lemma 5.11 The BC-validity property holds.

16

Proof of Lemma 5.11 Suppose that all the correct nodes propose the same value, v. The
proof shows that v is decided. Since all correct nodes propose v, we know that v is validated
(VBB-obligation). Also, all correct nodes VBB-deliver v from at least n−2t diﬀerent nodes
(VBB-completion). Since n−2t > t, value v is unique. This is because no value v(cid:48) can be
VBB-broadcast only by faulty nodes and still be validated (VBB-justiﬁcation). Thus, the
non-⊥ values that correct nodes can VBB-deliver are v and Ψ. This means that ∀i ∈ Correct :
sameValue i() = True, bcO i.result() = True (Binary consensus validity), and correct nodes decide
(cid:50)Lemma 5.11
v.

Lemma 5.12 The BC-no-intrusion property holds.

Proof of Lemma 5.12 Suppose w (cid:54)= Ψ is proposed only by faulty nodes. The proof shows
that no correct node decides w. By VBB-justiﬁcation, no pi : i ∈ Correct VBB-delivers w.

Suppose that bcO i.result() (cid:54)= True. Thus, w is not decided due the if-statement line 42.
Suppose that bcO i.result() = True. There must be a node pj for which sameValue j() = True.
I.e., v is decided due to the if-statement in line 43 and since there are at least n−2t VBB-
deliveries of v. Note that the if-statement condition in line 44 cannot hold during R since R
starts in a post-recycling system state (as well as due to lines 48 and 49, which use the same
input value from sameValue()). This implies that w (cid:54)= v cannot be decided since n−2t > t.
(cid:50)T heorem 5.9
(cid:50)Lemma 5.12

6 Discussion

To the best of our knowledge, this paper presents the ﬁrst self-stabilizing Byzantine- and
intrusion-tolerant algorithm for solving multivalued consensus in asynchronous message-passing
systems. This solution is devised by layering broadcast protocols, such as Byzantine reliable
broadcast, Binary-values broadcast, and validated Byzantine broadcast. Our solution is based
on a code transformation of existing (non-self-stabilizing) BFT algorithms into the proposed
self-stabilizing Byzantine-tolerant algorithm. This transformation is achieved via careful anal-
ysis of the eﬀect that arbitrary transient faults can have on the system’s state as well as via
rigorous proof for demonstrating consistency regaining and completion. We hope that the pro-
posed solution and studied techniques can facilitate the design of new building blocks, such as
state-machine replication, for the Cloud and distributed ledgers.

References

[1] Ittai Abraham, Dahlia Malkhi, Kartik Nayak, Ling Ren, and Maofan Yin. Sync hotstuﬀ:
Simple and practical synchronous state machine replication. In IEEE Symposium on Se-
curity and Privacy, SP’20, pages 106–118, 2020.

[2] Karine Altisen, St´ephane Devismes, Swan Dubois, and Franck Petit. Introduction to Dis-
tributed Self-Stabilizing Algorithms. Synthesis Lectures on Distributed Computing Theory.
Morgan & Claypool Publishers, 2019.

[3] Anish Arora and Mohamed G. Gouda. Closure and convergence: A foundation of fault-

tolerant computing. IEEE Trans. Software Eng., 19(11):1015–1027, 1993.

[4] Yotam Ashkenazi, Shlomi Dolev, Sayaka Kamei, Yoshiaki Katayama, Fukuhito Ooshita,
and Koichi Wada. Location functions for self-stabilizing byzantine tolerant swarms.
In
SSS, volume 13046 of Lecture Notes in Computer Science, pages 229–242. Springer, 2021.

17

[5] Yotam Ashkenazi, Shlomi Dolev, Sayaka Kamei, Fukuhito Ooshita, and Koichi Wada. For-
give & forget: Self-stabilizing swarms in spite of byzantine robots. In CANDAR Workshops,
pages 188–194. IEEE, 2019.

[6] Michael Ben-Or, Danny Dolev, and Ezra N. Hoch. Fast self-stabilizing Byzantine tolerant
In ACM Principles of Distributed Computing, PODC’08,

digital clock synchronization.
pages 385–394. ACM, 2008.

[7] Michael Ben-Or, Boaz Kelmer, and Tal Rabin. Asynchronous secure computations with
optimal resilience. In ACM Principles of Distributed Computing, pages 183–192, 1994.

[8] Alexander Binun, Thierry Coupaye, Shlomi Dolev, Mohammed Kassi-Lahlou, Marc La-
coste, Alex Palesandro, Reuven Yagel, and Leonid Yankulin. Self-stabilizing Byzantine-
tolerant distributed replicated state machine.
In Stabilization, Safety, and Security of
Distributed Systems SSS’16, pages 36–53, 2016.

[9] Alexander Binun, Shlomi Dolev, and Tal Hadad. Self-stabilizing Byzantine consensus for
blockchain. In Cyber Security Cryptography and Machine Learning CSCML’19, pages 106–
110, 2019.

[10] Peva Blanchard, Shlomi Dolev, Joﬀroy Beauquier, and Sylvie Dela¨et. Practically self-
stabilizing Paxos replicated state-machine. In NETYS, volume 8593 of LNCS, pages 99–
121. Springer, 2014.

[11] Silvia Bonomi, Shlomi Dolev, Maria Potop-Butucaru, and Michel Raynal. Stabilizing
server-based storage in Byzantine asynchronous message-passing systems. In ACM Prin-
ciples of Distributed Computing, PODC’15, pages 471–479, 2015.

[12] Silvia Bonomi, Maria Potop-Butucaru, and S´ebastien Tixeuil. Stabilizing Byzantine-fault
tolerant storage. In IEEE Parallel and Distributed Processing Symposium, IPDPS’15, pages
894–903, 2015.

[13] Silvia Bonomi, Antonella Del Pozzo, and Maria Potop-Butucaru. Tight self-stabilizing

mobile byzantine-tolerant atomic register. In ICDCN, pages 6:1–6:10. ACM, 2016.

[14] Silvia Bonomi, Antonella Del Pozzo, and Maria Potop-Butucaru. Optimal self-stabilizing
synchronous mobile byzantine-tolerant atomic register. Theor. Comput. Sci., 709:64–79,
2018.

[15] Silvia Bonomi, Antonella Del Pozzo, Maria Potop-Butucaru, and S´ebastien Tixeuil. Opti-
mal mobile Byzantine fault tolerant distributed storage. In ACM Principles of Distributed
Computing, PODC’16, pages 269–278, 2016.

[16] Silvia Bonomi, Antonella Del Pozzo, Maria Potop-Butucaru, and S´ebastien Tixeuil. Opti-
mal storage under unsynchronized mobile Byzantine faults. In IEEE Reliable Distributed
Systems, SRDS’17, pages 154–163, 2017.

[17] Silvia Bonomi, Antonella Del Pozzo, Maria Potop-Butucaru, and S´ebastien Tixeuil. Op-
timal self-stabilizing mobile Byzantine-tolerant regular register with bounded timestamps.
In Stabilization, Safety, and Security of Distributed Systems, SSS’18, pages 398–403, 2018.

[18] Silvia Bonomi, Antonella Del Pozzo, Maria Potop-Butucaru, and S´ebastien Tixeuil. Ap-
proximate agreement under mobile Byzantine faults. Theor. Comput. Sci., 758:17–29, 2019.

18

[19] Miguel Correia, Nuno Ferreira Neves, and Paulo Ver´ıssimo. From consensus to atomic
broadcast: Time-free Byzantine-resistant protocols without signatures. Comput. J.,
49(1):82–96, 2006.

[20] Miguel Correia, Giuliana Santos Veronese, Nuno Ferreira Neves, and Paulo Ver´ıssimo.
Int. J. Crit.

Byzantine consensus in asynchronous message-passing systems: a survey.
Comput. Based Syst., 2(2):141–161, 2011.

[21] Ariel Daliot and Danny Dolev. Self-stabilizing byzantine agreement.

In PODC, pages

143–152. ACM, 2006.

[22] Ariel Daliot, Danny Dolev, and Hanna Parnas. Brief announcement: linear time byzantine

self-stabilizing clock synchronization. In PODC, page 379. ACM, 2004.

[23] Xavier D´efago, Maria Potop-Butucaru, and Philippe Raipin Parv´edy. Self-stabilizing gath-
ering of mobile robots under crash or byzantine faults. Distributed Comput., 33(5):393–421,
2020.

[24] Xavier D´efago, Maria Gradinariu Potop-Butucaru, Julien Cl´ement, St´ephane Messika, and
Philippe Raipin Parv´edy. Fault and byzantine tolerant self-stabilizing mobile robots gath-
ering - feasibility study -. CoRR, abs/1602.05546, 2016.

[25] Edsger W. Dijkstra. Self-stabilizing systems in spite of distributed control. Commun.

ACM, 17(11):643–644, 1974.

[26] Danny Dolev and Ezra N. Hoch. Byzantine self-stabilizing pulse in a bounded-delay model.
In SSS, volume 4838 of Lecture Notes in Computer Science, pages 234–252. Springer, 2007.

[27] Danny Dolev and Ezra N. Hoch. On self-stabilizing synchronous actions despite byzantine
In DISC, volume 4731 of Lecture Notes in Computer Science, pages 193–207.

attacks.
Springer, 2007.

[28] Danny Dolev, Ezra N. Hoch, and Robbert van Renesse. Self-stabilizing and byzantine-
tolerant overlay network. In OPODIS, volume 4878 of Lecture Notes in Computer Science,
pages 343–357. Springer, 2007.

[29] Shlomi Dolev. Self-Stabilization. MIT Press, 2000.

[30] Shlomi Dolev, Chryssis Georgiou, Ioannis Marcoullis, and Elad Michael Schiller. Self-
stabilizing Byzantine tolerant replicated state machine based on failure detectors. In Cyber
Security Cryptography and Machine Learning CSCML, pages 84–100, 2018.

[31] Shlomi Dolev, Ronen I. Kat, and Elad Michael Schiller. When consensus meets self-

stabilization. J. Comput. Syst. Sci., 76(8):884–900, 2010.

[32] Shlomi Dolev, Omri Liba, and Elad Michael Schiller. Self-stabilizing Byzantine resilient
topology discovery and message delivery. In Networked Systems NETYS’13, pages 42–57,
2013.

[33] Shlomi Dolev and Jennifer L. Welch. Self-stabilizing clock synchronization in the presence
In ACM Principles of Distributed Computing PODC’95, page 256,

of Byzantine faults.
1995.

19

[34] Swan Dubois, Maria Potop-Butucaru, Mikhail Nesterenko, and S´ebastien Tixeuil. Self-
stabilizing Byzantine asynchronous unison. J. Parallel Distributed Comput., 72(7):917–923,
2012.

[35] Romaric Duvignau, Michel Raynal, and Elad Michael Schiller. Self-stabilizing Byzantine-

tolerant broadcast. CoRR, abs/2201.12880, 2022.

[36] Cynthia Dwork, Nancy A. Lynch, and Larry J. Stockmeyer. Consensus in the presence of

partial synchrony. J. ACM, 35(2):288–323, 1988.

[37] Michael J. Fischer, Nancy A. Lynch, and Mike Paterson.

Impossibility of distributed

consensus with one faulty process. J. ACM, 32(2):374–382, 1985.

[38] Chryssis Georgiou, Ioannis Marcoullis, Michel Raynal, and Elad Michael Schiller. Loosely-
self-stabilizing Byzantine-tolerant binary consensus for signature-free message-passing sys-
tems. CoRR, abs/2103.14649, 2021. Also in NETYS’21.

[39] Chryssis Georgiou, Ioannis Marcoullis, Michel Raynal, and Elad Michael Schiller. Loosely-
self-stabilizing Byzantine-tolerant binary consensus for signature-free message-passing sys-
tems. In NETYS, volume 12754 of LNCS, pages 36–53. Springer, 2021.

[40] Ezra N. Hoch, Danny Dolev, and Ariel Daliot. Self-stabilizing byzantine digital clock
synchronization. In SSS, volume 4280 of Lecture Notes in Computer Science, pages 350–
362. Springer, 2006.

[41] Pankaj Khanchandani and Christoph Lenzen. Self-stabilizing Byzantine clock synchroniza-

tion with optimal precision. Theory Comput. Syst., 63(2):261–305, 2019.

[42] Leslie Lamport, Robert E. Shostak, and Marshall C. Pease. The Byzantine generals prob-

lem. ACM Trans. Program. Lang. Syst., 4(3):382–401, 1982.

[43] Christoph Lenzen and Joel Rybicki. Self-stabilising Byzantine clock synchronisation is

almost as easy as consensus. J. ACM, 66(5):32:1–32:56, 2019.

[44] Oskar Lundstr¨om, Michel Raynal, and Elad Michael Schiller. Self-stabilizing indulgent
zero-degrading binary consensus. In Distributed Computing and Networking, ICDCN’21,
pages 106–115, 2021.

[45] Oskar Lundstr¨om, Michel Raynal, and Elad Michael Schiller. Self-stabilizing multivalued
consensus in asynchronous crash-prone systems. In EDCC, pages 111–118. IEEE, 2021.
Also in CoRR abs/2104.03129.

[46] Mahyar R. Malekpour. A byzantine-fault tolerant self-stabilizing protocol for distributed
clock synchronization systems. In SSS, volume 4280 of Lecture Notes in Computer Science,
pages 411–427. Springer, 2006.

[47] Toshimitsu Masuzawa and S´ebastien Tixeuil. A self-stabilizing link-coloring protocol re-
silient to unbounded byzantine faults in arbitrary networks. In OPODIS, volume 3974 of
Lecture Notes in Computer Science, pages 118–129. Springer, 2005.

[48] Alexandre Maurer. Self-stabilizing Byzantine-resilient communication in dynamic net-
works. In OPODIS, volume 184 of LIPIcs, pages 27:1–27:11. Schloss Dagstuhl - Leibniz-
Zentrum f¨ur Informatik, 2020.

20

[49] Alexandre Maurer and S´ebastien Tixeuil. Self-stabilizing Byzantine broadcast.

In 33rd
IEEE International Symposium on Reliable Distributed Systems, SRDS 2014, Nara, Japan,
October 6-9, 2014, pages 152–160, 2014.

[50] Achour Most´efaoui, Moumen Hamouma, and Michel Raynal. Signature-free asynchronous
Byzantine consensus with t<n/3 and O(n2) messages. In ACM Principles of Distributed
Computing, PODC ’14, pages 2–9, 2014.

[51] Achour Most´efaoui, Hamouma Moumen, and Michel Raynal. Signature-free asynchronous
binary Byzantine consensus with t<n/3, O(n2) messages, and O(1) expected time. J.
ACM, 62(4):31:1–31:21, 2015.

[52] Achour Most´efaoui and Michel Raynal. Signature-free broadcast-based intrusion toler-
ance: Never decide a Byzantine value. In OPODIS, volume 6490 of LNCS, pages 143–158.
Springer, 2010. An extended journal version appears in IEEE Trans. Parallel Distributed
Syst., v. 27, n. 4, pp. 1085–1098, 2016.

[53] Achour Most´efaoui and Michel Raynal. Signature-free asynchronous Byzantine systems:
from multivalued to binary consensus with t<n/3, O(n2) messages, and constant time.
Acta Informatica, 54(5):501–520, 2017.

[54] Mikhail Nesterenko and S´ebastien Tixeuil. Discovering network topology in the presence
of Byzantine faults. IEEE Trans. Parallel Distributed Syst., 20(12):1777–1789, 2009.

[55] Nuno Ferreira Neves, Miguel Correia, and Paulo Ver´ıssimo. Solving vector consensus with

a wormhole. IEEE Trans. Parallel Distributed Syst., 16(12):1120–1131, 2005.

[56] Marshall C. Pease, Robert E. Shostak, and Leslie Lamport. Reaching agreement in the

presence of faults. J. ACM, 27(2):228–234, 1980.

[57] Martin Perner, Martin Sigl, Ulrich Schmid, and Christoph Lenzen. Byzantine self-
stabilizing clock distribution with hex: Implementation, simulation, clock multiplication.
In 6th Conference on Dependability (DEPEND). Citeseer, 2013.

[58] Kenneth J. Perry. Randomized Byzantine agreement. In Fourth Symposium on Reliability

in Distributed Software and Database Systems, SRDS, pages 107–118, 1984.

[59] Michel Raynal. Fault-Tolerant Message-Passing Distributed Systems - An Algorithmic Ap-

proach. Springer, 2018.

[60] Yusuke Sakurai, Fukuhito Ooshita, and Toshimitsu Masuzawa. A self-stabilizing link-
coloring protocol resilient to byzantine faults in tree networks. In OPODIS, volume 3544
of Lecture Notes in Computer Science, pages 283–298. Springer, 2004.

[61] Sam Toueg. Randomized Byzantine agreements. In Proceedings of the Third Annual ACM

Principles of Distributed Computing, pages 163–178, 1984.

[62] Shaolin Yu, Jihong Zhu, and Jiali Yang. Eﬃcient two-dimensional self-stabilizing byzantine

clock synchronization in WALDEN. In ICPADS, pages 723–730. IEEE, 2021.

[63] Shaolin Yu, Jihong Zhu, Jiali Yang, and Wei Lu. Expected constant time self-stabilizing

byzantine pulse resynchronization. CoRR, abs/2203.14016, 2022.

21

Appendix

Meaning
(non-self-stabilizing) Byzantine fault-tolerant
Byzantine-tolerant Reliable Broadcast, e.g., the SSBFT one in [35]

Notation
BFT
BRB
BV-broadcast Binary-values broadcast, e.g., the SSBFT one in [38]
MR
SSBFT
VBB

the studied solution by Most´efaoui and Raynal [52]
self-stabilizing Byzantine fault-tolerant
Validated Byzantine Broadcast, e.g., the BFT ones in algorithms 1 and 3

Table 1: Glossary

22

