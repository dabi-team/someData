2
2
0
2

g
u
A
4

]

R
C
.
s
c
[

2
v
5
1
6
1
1
.
7
0
2
2
:
v
i
X
r
a

SyncPCN/PSyncPCN: Payment Channel Networks without
Blockchain Synchrony

OÄŸuzhan Ersoy
oguzhan.ersoy@ru.nl
Radboud University
Delft University of Technology

Satwik Prabhu Kumble
s.prabhukumble@tudelft.nl
Delft University of Technology

JÃ©rÃ©mie Decouchant
j.decouchant@tudelft.nl
Delft University of Technology

Stefanie Roos
s.roos@tudelft.nl
Delft University of Technology

ABSTRACT
Payment channel networks (PCNs) enhance the scalability of block-
chains by allowing parties to conduct transactions off-chain, i.e,
without broadcasting every transaction to all blockchain partici-
pants. To conduct transactions, a sender and a receiver can either
establish a direct payment channel with a funding blockchain trans-
action or leverage existing channels in a multi-hop payment. The
security of PCNs usually relies on the synchrony of the underlying
blockchain, i.e., evidence of misbehavior needs to be published on
the blockchain within a time limit. Alternative payment channel
proposals that do not require blockchain synchrony rely on quo-
rum certificates and use a committee to register the transactions
of a channel. However, these proposals do not support multi-hop
payments, a limitation we aim to overcome.

In this paper, we demonstrate that it is in fact impossible to de-
sign a multi-hop payment protocol with both network asynchrony
and faulty channels, i.e., channels that may not correctly follow the
protocol. We then detail two committee-based multi-hop payment
protocols that respectively assume synchronous communications
and possibly faulty channels, or asynchronous communication and
correct channels. The first protocol relies on possibly faulty com-
mittees instead of the blockchain to resolve channel disputes, and
enforces privacy properties within a synchronous network. The
second one relies on committees that contain at most ğ‘“ faulty mem-
bers out of 3ğ‘“ +1 and successively delegate to each other the role of
eventually completing a multi-hop payment. We show that both
protocols satisfy the security requirements of a multi-hop payment
and compare their communication complexity and latency.

1 INTRODUCTION
Payment channel networks (PCNs) [25] allow faster, cheaper, and
more energy-efficient transactions than blockchains. Their key ad-
vantage is that most transactions can be conducted using only local
communication whereas blockchains usually require broadcasting
transactions to all participants for verification. The largest PCN,
Lightning [48], has a capacity of more than 100 million euros as of
January 29, 2022 [1].

In a PCN, two parties can open and fund bi-directional channels
using a blockchain transaction. Once their channel has been opened,
the two parties can conduct transactions by updating their shared

This document is a preprint of a paper accepted at the ACM conference on Ad-
vances in Financial Technologies (AFT 2022).

account and moving the coins from one side to the other. Further-
more, multi-hop payments allow forwarding a payment between a
sender and receiver via a path of channels, enabling transactions
between parties that have not opened a dedicated shared chan-
nel [3, 4, 18, 19, 35, 37, 38, 48]. In a multi-hop payment, parties first
lock coins of a channel with regard to a condition, then the payment
is either executed by satisfying the condition or is revoked.

1.1 Motivation
The security of bi-directional payment channels relies on the un-
derlying blockchain. In case of a dispute about the channel balance,
both parties can publish what they consider the most recent state on
the blockchain, which can then determine the correct balance. For
example, in a case where a malicious party publishes an old state of
the channel balance, the honest party has to react to the published
state. Within Î” blocks, the honest party can publish a penalty trans-
action [48] or raise a dispute [43] and claim the coins of the channel.
If the state of the honest party is not published in time â€” which
might be challenging in times where many transactions are waiting
to be validated as well as in periods of network asynchrony â€” she
can lose her rightfully owned coins. Thus, blockchain synchrony
is required to guarantee that disputes can be resolved and honest
parties do not lose their coins.

Second, for multi-hop payments in PCNs, parties lock coins in
each channel for some time. For example, in the Lightning Net-
work, the locking time is typically chosen in the order of hours
or days [39], and parties should complete the payment within this
time period. Similar to payment channels, honest parties have to
react to malicious updates within the time interval. Thus, there is
a synchrony requirement that is not always satisfied, especially
under attack [29, 47, 52]. For instance, Flood&Loot [29] congests the
underlying blockchain with channel closure requests containing
invalid states. Due to the high number of transactions competing
to be included in a block, honest parties are unable to have the
correct state included within a block in time and hence lose coins.
So, liveness faults of the blockchain layer, i.e., not being able to
publish a transaction within time Î”, cause safety faults, i.e., loss of
funds, for payment channel networks.

1.2 Related Work
Several works investigate asset transfers in asynchronous net-
works [5, 13, 26, 27, 42]. Concurrently and independently from

1

 
 
 
 
 
 
our work, Naor and Keidar showed that establishing a payment
channel with faulty parties on top of an asynchronous asset transfer
system is impossible [42]. More precisely, they demonstrate that
only a unidirectional payment channel, which in addition does not
allow the payer in the channel to initiate closure, can be realized
in this model. They suspect that it might be possible to design a
payment channel network using uni-directional channels where
only the payee can close the channel with the use of HTLCs (hash-
time lock contracts) from which the timeout component is removed.
However, from the brief discussion given in the paper, it is unclear
how to guarantee progress, i.e., how to ensure that payments are
eventually either successful or revoked, without timeouts. There
are three approaches that relate to blockchain asynchrony, i.e.,
work for blockchains without the guarantee to have transactions
included within time Î”. First, watchtowers [17] allow parties to
defer publication of the state to third parties. In this manner, parties
can become unresponsive, e.g., due to a denial-of-service attack,
without being vulnerable to a malicious act by the other party in
the channel. Yet, watchtowers are ineffective if the third parties are
also not able to publish a transaction in time. In other words, watch-
towers displace the responsibility of observing the blockchain but
do not alleviate it. Second, trusted execution environments (TEEs)
can be leveraged to prevent the publication of invalid states, thus
removing the need for a dispute period [35]. Yet, Intel SGX, the TEE
used in the existing designs, is vulnerable to various side channel
attacks [9, 50] and deprecated1. Third, Brick [6] realizes asynchro-
nous payment channels by involving a committee into the channel.
In exchange for fees, rational committee members keep track of the
state of the channel and ensure that only valid states are published
on the blockchain. However, Brick is only applicable for single-hop
channels, not for PCNs.

1.3 Our Contributions
We investigate multi-hop payments in PCNs with blockchain asyn-
chrony. By reducing the problem of a multi-hop payment to a fair
exchange, we show that multi-hop payments are only possible if
the network is synchronous or if all channels in a multi-hop pay-
ment behave according to the protocol or in favor of honest parties,
which can be enforced by a trusted third party.

We design two protocols based on BFT committees: SyncPCN
and PSyncPCN. SyncPCN assumes synchronous communication and
parties only need to trust the committees of their own channels,
not the committees of other channels possibly involved in a multi-
hop payment. SyncPCN resembles the AMHL protocol, which is
an improvement over Lightning in terms of privacy and security.
Unlike AMHL, in SyncPCN, each channel registers payments with
a committee that enables dispute resolution among the parties
without the need for blockchain synchrony.

In contrast, PSyncPCN tolerates partially-synchronous commu-
nication in addition to blockchain asynchrony, but it requires that
each committee involved in the payment acts honestly, i.e., that at
most ğ‘“ out of its 3ğ‘“ +1 committee members are faulty. We discuss
how random peer sampling or a globally trusted committee can

1https://edc.intel.com/content/www/us/en/design/ipla/software-development-
platforms/client/platforms/alder-lake-desktop/12th-generation-intel-core-
processors-datasheet-volume-1-of-2/001/deprecated-technologies/

2

OÄŸuzhan Ersoy, JÃ©rÃ©mie Decouchant, Satwik Prabhu Kumble, and Stefanie Roos

be used to obtain BFT committees with high probability. PSyncPCN
relies on a total order broadcast protocol inside committees and
on broadcasts between subsequent committees on a payment path.
Hence, it is less efficient than SyncPCN, which only relies on consis-
tent broadcast. Given the classical FLP result [21], PSyncPCN lever-
ages existing total order broadcast protocols to provide termination
if one assumes a partially synchrony [10, 16, 51], or probabilistic
termination in full asynchrony [31, 41]. We prove the security of
our protocols and provide a performance analysis. While we assume
honest and malicious parties during our analysis, our protocols can
largely leverage incentives to ensure that rational parties behave
honestly [6].

Our contributions are as follows:

â€¢ We prove that a secure multi-hop payment protocol with
asynchronous communication and faulty channel updates is
impossible.

â€¢ We design SyncPCN and PSyncPCN for payment channel
networks with blockchain asynchrony and synchronous or
partially-synchronous communication, respectively.

â€¢ We show that SyncPCN and PSyncPCN enable secure multi-

hop payments.

â€¢ We derive communication and latency complexities for SyncPCN
and PSyncPCN and compare them with the existing protocols.

Our designs are the first payment channel networks that can be
deployed without blockchain synchrony or trusted hardware.

The rest of this paper is organized as follows. Â§2 provides the
background knowledge. Â§3 proves that it is impossible to devise a
protocol for asynchronous multi-hop payment channels without
a trusted third party. Â§4 and Â§5 respectively presents SyncPCN and
PSyncPCN. Â§6 discusses incentives, the performance of SyncPCN
and PSyncPCN and compares them with existing payment channel
networks. Finally, Â§7 concludes this paper.

2 BACKGROUND
This section introduces key concepts related to synchrony, commit-
tees, and communication. Furthermore, we provide more details on
payment channels, including a discussion of Brick, an asynchronous
payment channel, and PCNs. We also formally define the security
goals of multi-hop payments.

2.1 Time and Blockchain
Nodes communicate by exchanging messages and are equipped
with loosely synchronized clocks. Communication is called synchro-
nous if there is a known upper bound ğ›¿ on message transmission
time, or asynchronous if there is no such upper bound. Messages
are not lost but can be reordered.

A blockchain is a distributed ledger of transactions that are
grouped in blocks. Time can be measured as a number of blocks
appended to a blockchain. A secure blockchain should satisfy per-
sistence and liveness properties [23, 46]. A transaction is stable if it
is unfeasible to remove it from the blockchain. Persistence means
that if a transaction is recorded as stable by an honest party, the
rest of the honest parties do not record a conflicting transaction
as stable. Liveness implies that if an honest party wants to add a
valid transaction into the blockchain, it will eventually be recorded

SyncPCN/PSyncPCN: Payment Channel Networks without Blockchain Synchrony

as stable by all honest parties. Moreover, blockchain synchrony
implies that a transaction is recorded as stable within Î” blocks.

2.2 Byzantine Committees and Broadcast
A committee is a set of nodes, each equipped with known signature
keys, that jointly take or record decisions. They provide signed mes-
sages to show their agreement to a decision. Nodes in the committee
can be honest (or correct), which means that they strictly follow
the protocol, or malicious (or faulty), which means that they might
arbitrarily deviate from it. To tolerate at most ğ‘“ faulty members,
a Byzantine fault tolerant (BFT) committee contains at least 3ğ‘“ +1
members. A committee that contains more than ğ‘“ malicious nodes
is said to be malicious. A Byzantine quorum is a set of at least 2ğ‘“ +1
replicas. A set of 2ğ‘“ +1 signatures on a message is called a quorum
certificate. We rely on the following quorum properties. First, if
nodes require a quorum certificate to update a value they store,
then it is not possible to collect a quorum certificate on a different
value. Second, when at least ğ‘“ +1 committee members declare that
they have collected a quorum certificate for a given value, then the
value returned is the one stored by correct committee members.

To obtain guarantees regarding the messages delivered by cor-
rect committee members, one can leverage consistent, reliable, or
total order broadcast. Informally, a consistent broadcast used by an
application guarantees that if a correct node broadcasts a message
ğ‘š, then all correct nodes eventually deliver ğ‘š to their application
and that if two correct nodes deliver ğ‘š and ğ‘šâ€², then ğ‘š=ğ‘šâ€² [49].

Reliable broadcast [8, 32] in addition requires that if a correct
node delivers ğ‘š then all correct nodes eventually deliver it, re-
gardless of whether the sender is correct or not. A total order (or
atomic) broadcast protocol additionally guarantees that correct
nodes deliver messages in the same order [11, 33]. Total order can
be provided by a consensus protocol [10, 51, 53].

2.3 Payment Channels and Brick
We consider bidirectional channels [15], as implemented in Light-
ning [48]. Two parties ğ‘ƒ and ğ‘„ open a payment channel by pub-
lishing a funding transaction on the blockchain, through which
they deposit ğ‘ğ‘ƒ and ğ‘ğ‘„ , respectively, coins for the channel. (ğ‘ğ‘ƒ , ğ‘ğ‘„ )
denotes the initial balances of the channel and the total amount of
coins deposited, ğ‘ğ‘ƒ +ğ‘ğ‘„ , is the capacity of the channel. The balance
is adjusted after each transaction, e.g., if ğ‘ƒ sends ğ‘¥ coins to ğ‘„, then
the balances will be (ğ‘ğ‘ƒ âˆ’ğ‘¥, ğ‘ğ‘„ +ğ‘¥) as long as ğ‘ğ‘ƒ â‰¥ğ‘¥. Transactions
are conducted off-chain, i.e., the two parties locally sign a new state
of the balance. Parties can publish the final state on the blockchain
to withdraw their coins with the latest balance.

Brick [6] allows parties to establish a single-hop asynchronous
payment channel. Each channel uses a BFT committee. State up-
dates are sent to the committee and acknowledged by it. If a party
wants to unilaterally close the channel, the committee confirms
the last valid state and hence foregoes the need to publish on the
blockchain within a certain time limit. Consistency between honest
committee members is provided by a consistent broadcast protocol.
Committee members only observe hashed payment channel states
for privacy. Brick does not require blockchain synchrony and can
tolerate an asynchronous network.

3

2.4 Payment Channel Networks
The set of all payment channels form a network where the nodes are
the parties and the edges are channels. Opening a channel requires
a blockchain transaction and is hence costly and time-consuming.
Instead, two parties that do not share a direct channel may send a
multi-hop payment along a path of payment channels [3, 4, 18, 19,
37, 38, 48] so that each party on the path pays their successor.

Let mhp be a multi-hop payment on path ğ‘ğ‘ğ‘¡â„ = (ğ‘ƒ0, . . ., ğ‘ƒğ‘˜ )
with corresponding channels (ğ›¾0, . . ., ğ›¾ğ‘˜âˆ’1). Here, ğ‘ğ‘ğ‘¡â„[0] := ğ‘ƒ0
and ğ‘ğ‘ğ‘¡â„[ğ‘˜] := ğ‘ƒğ‘˜ denote the sender and the receiver respectively,
and ğ‘ğ‘ğ‘¡â„[1 : ğ‘˜ âˆ’ 1] are the intermediarty parties. In source routing-
based multi-hop payment protocols, the sender ğ‘ƒ0 chooses the
path of the payment, and prepares a payload message ğ‘€ğ‘– for each
party ğ‘ƒğ‘– . The payload message includes the necessary information
regarding the payment, such as the amount, locking condition, the
next party in the path, etc.

Initially, the state of each channel ğ›¾ğ‘– is unlocked2. In the commit
phase, each party ğ‘ƒğ‘– locks the coins ğ‘£ğ‘– in ğ›¾ğ‘– (if they have enough
balance and ğ‘“ğ‘– =ğ‘£ğ‘–âˆ’1âˆ’ğ‘£ğ‘– , where ğ‘“ğ‘– is the fee of the intermediary
ğ‘ƒğ‘– ) with regard to a condition condğ‘– , and then the channel state
becomes locked. The locked coins cannot be used by either party
until the payment is finalized. In the payment execution phase,
there are two possible outcomes for each locked channel: if the
condition is satisfied and the payment is successful, then the final
channel state becomes paid; otherwise, the payment is revoked
(canceled), and the final channel state is revoked.

2.5 Security and Privacy Definitions
In general, the security of a multi-hop payment protocol is defined
via balance security, which often implicitly covers the correctness
and coin availability properties as well. Here, we define them sepa-
rately. Balance security implies that the total balance of an honest
intermediary party does not decrease, and the sender should pay
only if the receiver is paid [4, 20, 36]. Correctness means that the
payment is successful if all parties are honest and there is sufficient
balance. The balance security definition covers safety of the coins.
However, it does not take into account liveness, i.e., the eventual
transition from the initial to the final state. Coin availability ensures
that the payment is eventually finalized.

Definition 1 (Balance Security). Let mhp be a multi-hop pay-
ment with (ğ‘£0, . . ., ğ‘£ğ‘˜âˆ’1) coins to be paid in channels of (ğ›¾0, . . ., ğ›¾ğ‘˜âˆ’1)
such that ğ‘£ğ‘– â‰¥ğ‘£ ğ‘— for 0â‰¤ğ‘–â‰¤ ğ‘— â‰¤ğ‘˜âˆ’1. If an honest intermediary party ğ‘ƒğ‘–
pays ğ‘£ğ‘–+1 coins in ğ›¾ğ‘–+1, ğ‘ƒğ‘– receives the amount ğ‘£ğ‘– in ğ›¾ğ‘– . If the sender
ğ‘ƒ0 pays ğ‘£0 coins in ğ›¾0, the receiver ğ‘ƒğ‘˜ is paid ğ‘£ğ‘˜âˆ’1 coins in ğ›¾ğ‘˜âˆ’1. This
implies that the final states of the channels ğ›¾ğ‘– and ğ›¾ğ‘–+1 of an honest
intermediary ğ‘ƒğ‘– are identical, i.e., either both revoked or paid.

Definition 2 (Correctness). Let mhp be a multi-hop payment
with (ğ‘£0, . . ., ğ‘£ğ‘˜âˆ’1) coins to be paid in channels of (ğ›¾0, . . ., ğ›¾ğ‘˜âˆ’1) such
that ğ‘£ğ‘– â‰¥ğ‘£ ğ‘— for 0â‰¤ğ‘–â‰¤ ğ‘— â‰¤ğ‘˜âˆ’1. If the protocol is executed honestly and
each channel ğ›¾ğ‘– has a balance of at least ğ‘£ğ‘– and the locking conditions
are satisfied, then the states of the channels of mhp.path move to
locked and then to paid, otherwise, they remain unlocked.

2In practice, there would be several simultaneous multi-hop payments, and these
states are matched with the id of a multi-hop payment. For simplicity, we ignore the
corresponding ids, and focus on one multi-hop payment.

Definition 3 (Coin Availability). The channel of an honest
party never stays forever in state locked, i.e., it eventually transitions
to paid or revoked.

A secure multi-hop payment protocol satisfies these three se-
curity notions. Instead of balance security, atomicity can be the
main security goal. The difference between the two properties is
highlighted by the wormhole attack [37], which is undesired, yet
does not violate balance security. In this attack, the adversary steals
the fees of other intermediaries by skipping them during a phase
of the protocol. The attack violates atomicity, which implies that
if a channel revokes the payment all channels that precede this
channel in the payment path also revoke, but not balance security.
We define atomicity by adding an additional requirement to the
definition of balance security.

Definition 4 (Atomicity). A multi-hop payment protocol satis-
fies atomicity if it satisfies balance security (Def. 1) and the following
requirement: For an honest sender ğ‘ƒ0, if the condition condğ‘– for pay-
ment of channel ğ›¾ğ‘– is not satisfied for an honest party ğ‘ƒğ‘–+1, and the
payment is revoked, then there are no two channels ğ›¾ğ›¼ and ğ›¾ğ›½ such
that the corresponding conditions condğ›¼ and condğ›½ are satisfied, and
both channels are paid where ğ›¼ < ğ‘– < ğ›½.

Regarding privacy, we consider the privacy concepts introduced
in [36, 40]: Value privacy, endpoint (sender or receiver) privacy and
relationship anonymity. Value privacy means that the value of a
payment is only revealed to the parties involved, i.e., sender, re-
ceiver, and intermediaries. Endpoint privacy states that the sender
and receiver are not explicitly revealed to any party that is not
an endpoint. Last, relationship anonymity is a stronger notion of
endpoint privacy stating that if there is an honest party among
the intermediaries, then the corrupted intermediary parties cannot
distinguish two payments sharing a segment of the path.

We define the following games, which are formal variants of
the ones defined in [4, 36]. In each game, an adversary tries to
distinguish two different payments. Unless stated otherwise, we
assume that the payment values, fees, timelocks (if any) and path
lengths of the two payments are the same (or they would be trivially
distinguishable). Like in previous works, we do not consider side
channel attacks [34, 44]. Also, the privacy properties are defined for
the off-chain protocol and are not required to hold if the payment
goes to the blockchain.
Value Privacy Game: Let an adversary A âˆ‰ ğ‘ğ‘ğ‘¡â„ choose two pay-
ment values ğ‘£ 0 and ğ‘£ 1 for a payment path ğ‘ğ‘ğ‘¡â„ where the channels
in ğ‘ğ‘ğ‘¡â„ have sufficient capacities for both values. Let ğ‘ âˆˆ {0, 1}
ğ‘ be the corresponding multi-hop
be chosen randomly. Let mhp
payment with payment value ğ‘£ğ‘ . In case of a successful payment
of mhp

ğ‘ , A wins the game by guessing the value of ğ‘:
(cid:21)

(cid:20)
ğ‘ â€² = ğ‘ : ğ‘ â€² â† Ağ‘£0,ğ‘£1,ğ‘ğ‘ğ‘¡â„, ğ‘

ğ‘…
â† {0, 1}

.

ğ‘ƒğ‘Ÿğ‘‰ ğ‘ƒ := ğ‘ƒğ‘Ÿ

Definition 5 (Value Privacy). We say that a multi-hop pay-
ment protocol satisfies value privacy if for every PPT (probabilistic
polynomial-time) adversary A, the probability of winning Value
Privacy Game is ğ‘ƒğ‘Ÿğ‘‰ ğ‘ƒ = 1/2 + ğœ– where ğœ– is negligible.
Endpoint Privacy Game: Let an adversary A := ğ‘ƒğ‘– choose two
payment paths ğ‘ğ‘ğ‘¡â„0 and ğ‘ğ‘ğ‘¡â„1 such that (ğ‘ğ‘ğ‘¡â„0 [0], ğ‘ğ‘ğ‘¡â„0 [ğ‘˜])

4

OÄŸuzhan Ersoy, JÃ©rÃ©mie Decouchant, Satwik Prabhu Kumble, and Stefanie Roos

â‰  (ğ‘ğ‘ğ‘¡â„1 [0], ğ‘ğ‘ğ‘¡â„1 [ğ‘˜]) and (ğ‘ƒğ‘–âˆ’1, ğ‘ƒğ‘–, ğ‘ƒğ‘–+1) = ğ‘ğ‘ğ‘¡â„0 [ğ‘– âˆ’ 1 : ğ‘– + 1] =
ğ‘
ğ‘ğ‘ğ‘¡â„1 [ğ‘– âˆ’ 1 : ğ‘– + 1]. Let ğ‘ âˆˆ {0, 1} be chosen randomly. Let mhp
be the corresponding multi-hop payment with path ğ‘ğ‘ğ‘¡â„ğ‘ , and ğ‘€ğ‘
ğ‘–
ğ‘ , A
be the payload message of ğ‘ƒğ‘– . In successful payment of mhp
wins the game by guessing the value of ğ‘:

ğ‘ƒğ‘Ÿğ¸ğ‘ƒ := ğ‘ƒğ‘Ÿ

(cid:20)
ğ‘ â€² = ğ‘ : ğ‘ â€² â† Ağ‘ğ‘ğ‘¡â„0,ğ‘ğ‘ğ‘¡â„1,ğ‘€ğ‘

ğ‘– , ğ‘

ğ‘…
â† {0, 1}

(cid:21)

.

Definition 6 (Endpoint Privacy). We say that a multi-hop
payment protocol satisfies endpoint privacy if for every PPT adversary
A, the probability of winning Endpoint Privacy Game is ğ‘ƒğ‘Ÿğ¸ğ‘ƒ =
1/2 + ğœ– where ğœ– is negligible.

Relationship Anonymity Game: Let an adversary A âŠ‚ ğ‘ğ‘ğ‘¡â„[1 :
ğ‘˜ âˆ’ 1] choose a path segment ğ‘ğ‘ğ‘¡â„[1 : ğ‘˜ âˆ’ 1] such that there is
at least one honest party in ğ‘ğ‘ğ‘¡â„[1 : ğ‘˜ âˆ’ 1], and has two candi-
date senders ğ‘ 0,ğ‘ 1 and receivers ğ‘Ÿ 0,ğ‘Ÿ 1. Let ğ‘ âˆˆ {0, 1} be chosen
randomly. If ğ‘ = 0, then (ğ‘ğ‘ğ‘¡â„ğ‘– [0], ğ‘ğ‘ğ‘¡â„ğ‘– [ğ‘˜]) = (ğ‘ ğ‘–, ğ‘Ÿğ‘– ), otherwise
ğ‘– be the corre-
(ğ‘ğ‘ğ‘¡â„ğ‘– [0], ğ‘ğ‘ğ‘¡â„ğ‘– [ğ‘˜]) = (ğ‘ ğ‘–, ğ‘Ÿ 1âˆ’ğ‘– ) for ğ‘– = 0, 1. Let mhp
sponding multi-hop payment with path ğ‘ğ‘ğ‘¡â„ğ‘– , and {ğ‘€ğ‘– } A be the
payload message(s) of A for ğ‘– = 0, 1. In case of simultaneous suc-
1, A wins the game by guessing
cessful payments of mhp
the value of ğ‘:

0 and mhp

ğ‘ƒğ‘Ÿğ‘…ğ´ := ğ‘ƒğ‘Ÿ

(cid:20)
ğ‘ â€² = ğ‘ : ğ‘ â€² â† Ağ‘ğ‘ğ‘¡â„ [1:ğ‘˜âˆ’1],{ğ‘€ 0 }A,{ğ‘€ 1 }A , ğ‘

ğ‘…
â† {0, 1}

(cid:21)

.

Definition 7 (Relationship Anonymity). We say that a multi-
hop payment protocol satisfies relationship anonymity if for every PPT
adversary A, the probability of winning the Relationship Anonymity
Game is ğ‘ƒğ‘Ÿğ‘…ğ´ = 1/2 + ğœ– where ğœ– is negligible.

3 IMPOSSIBILITY PROOF FOR MULTI-HOP

PAYMENTS

We show that there is no secure multi-hop payment protocol on
an asynchronous network with faulty channels. Here, we refer to a
channel as faulty if parties or committee members cause channel
updates that are not in line with the protocol or refuse channel
updates that are in line with the protocol. We call a channel honest
if all updates happen in accordance with the protocol. An honest
channel requires that some but not all parties involved in the chan-
nel (parties or committees) behave in accordance with the protocol.
Parties (or committees) follow the protocol either because they are
honest or because they are rational and incentivized. For now, we
focus on honest parties and discuss incentives in Section 6.

3.1 Fair Exchange
A fair exchange protocol between parties ğ‘ƒ and ğ‘„ is defined as
follows [2]. Assume that ğ‘ƒ has an item ğ‘–ğ‘ƒ with the description
descğ‘ƒ and ğ‘„ has an item iğ‘„ with the description descğ‘„ . At the end
of the protocol, both parties should hold the item of the other party.
A fair exchange protocol has two phases: initialization and claim-
and-fund. During the initialization, parties agree on the descrip-
tion of the items, resulting in ğ‘ƒ having (iğ‘ƒ , descğ‘„ ) and ğ‘„ having
(iğ‘„, descğ‘ƒ ). In the claim-and-fund phase, ğ‘ƒ obtains iğ‘„ (wrt. descğ‘„ )
and ğ‘„ obtains iğ‘ƒ (wrt. descğ‘ƒ ).

A fair exchange protocol should satisfy effectiveness, fairness,

and timeliness [2, 45].

SyncPCN/PSyncPCN: Payment Channel Networks without Blockchain Synchrony

â€¢ Effectiveness: If no party misbehaves and the items match
their descriptions, then ğ‘„ obtains iğ‘ƒ and ğ‘ƒ obtains iğ‘„ ; other-
wise both parties abort.

â€¢ Fairness: If honest ğ‘ƒ does not obtain iğ‘„ , then ğ‘„ should not

obtain iğ‘ƒ , and vice versa.

â€¢ Timeliness: Every honest party eventually terminates via

either obtaining the correspoding item or aborting.

3.2 The proof
We explain the payment properties over the channels independently
of their actual implementation. The following lemma reduces a se-
cure multi-hop payment to a fair exchange protocol. The proof
builds on previous work that showed that there exists no asynchro-
nous cross-chain communication protocol with faulty nodes [54].

Lemma 8. Assume (cid:206)ğ‘†ğ‘€ğ» ğ‘ƒ is a protocol that solves secure multi-
hop payment. Then there exists a protocol (cid:206)ğ¹ ğ¸ that solves fair ex-
change.

Proof. We first describe a fair exchange protocol (cid:206)ğ¹ ğ¸ that uses
a secure multi-hop payment protocol (cid:206)ğ‘†ğ‘€ğ» ğ‘ƒ . To realize a fair
exchange between parties ğ‘ƒ and ğ‘„, we consider two consecutive
channels ğ›¾ğ‘– and ğ›¾ğ‘–+1 of the multi-hop payment. Assume that suc-
cessful execution of (cid:206)ğ‘†ğ‘€ğ» ğ‘ƒ in ğ›¾ğ‘– assigns ownership of iğ‘ƒ to ğ‘„,
and similarly ğ›¾ğ‘–+1 assigns ownership of iğ‘„ to ğ‘ƒ. The descriptions
of the exchanges can be defined in the corresponding conditions
condğ‘– and condğ‘–+1 and the existence of sufficient channel balances.
The exchange occurs if the state of the channel becomes paid and
fails if the state becomes revoked or stays unlocked. We show that
the secure multi-hop payment properties are equivalent to the fair
exchange properties.

Effectiveness in fair exchange implies that if both parties ğ‘ƒ and ğ‘„
honestly follow the protocol, and items match with the descriptions,
then the exchange succeeds, otherwise, the exchange should fail for
both parties. In a secure multi-hop payment, correctness implies
that if both channels ğ›¾ğ‘– and ğ›¾ğ‘–+1 are honest, the channels have
enough balance and the payment conditions are satisfied, then they
will both accept the payment and update the state of the multi-hop
payment with paid, otherwise, they stay unlocked. Thus, from our
description of a fair exchange protocol based on a secure multi-hop
payment above, effectiveness and correctness are equivalent.

Fairness in a fair exchange means that if an honest party does not
obtain the item, then the other party does not as well. In a secure
multi-hop payment, balance security implies that if the payment
is paid in ğ›¾ğ‘–+1, it should also be paid in ğ›¾ğ‘– , and similarly if the
payment is revoked in ğ›¾ğ‘–+1, then it should also be revoked in ğ›¾ğ‘– .
In other words, either both channels become paid (successful), or
both of them are revoked (aborted), which is equivalent to the fair
exchange fairness.

Timeliness in fair exchange states that party ğ‘ƒ (equiv. for ğ‘„)
should eventually make the exchange or abort. Coin availability
for ğ›¾ğ‘– (and for ğ›¾ğ‘–+1) states that if the channel is locked, then it will
eventually reach states paid or revoked. Also, note that if ğ›¾ğ‘– is not
locked, then it is already unlocked. In other words, the state of the
channel eventually reaches one of the final states or always stays in
unlocked. Thus, coin availability and timeliness are equivalent. â–¡

5

Theorem 9. There is no asynchronous secure multi-hop payment
protocol that tolerates faulty channels without a trusted third party.

Proof. The proof follows from the reduction given in Lemma 8
â–¡

and the impossibility proof given in [45].

4 SYNCPCN: BLOCKCHAIN-ASYNCHRONOUS

PAYMENTS ON SYNCHRONOUS
NETWORKS

This section describes SyncPCN, our multi-hop payment protocol
that assumes synchronous communication. We utilize channels
with a committee construction, which have also been used in
Brick [6]. Other than the synchronous communication assump-
tion, key differences to Brick are the introduction of timestamps for
each committee member and update as well as the closing proce-
dure. We assume that transactions to the blockchain are eventually
included but not necessarily within time Î”.

4.1 Model and Overview

Threat Model. We assume a static adversary A that corrupts
parties and committee members at the beginning of the protocol.
There is no upper limit on the number of corrupted parties, but the
adversary cannot corrupt more than ğ‘“ out of ğ‘ â‰¥3ğ‘“ + 1 committee
members of a channel of an honest party. In other words, for an
honest party ğ‘ƒğ‘– , we assume that both channels ğ›¾ğ‘–âˆ’1 and ğ›¾ğ‘– have
at most ğ‘“ malicious committee members among ğ‘ â‰¥3ğ‘“ +1. This
assumption should hold even if ğ‘ƒğ‘–âˆ’1 and ğ‘ƒğ‘–+1 are malicious. An
honest party does not have to trust the committees of other parties
for balance security and coin availability to hold.

Payment channels. Each payment channel (ğ‘ƒ, ğ‘„) involves a com-
mittee ğ‘Š (ğ‘ƒ, ğ‘„) in the channel procedures: opening, update and
closure. To establish a committee, two parties first agree on its mem-
bers. During the channel opening, the parties publish the funding
transaction, which deposits the coins and registers the committee.
The coins can be redeemed from the channel if both parties sign
the channel state, or if one party signs the state together with a
Byzantine quorum of the committee.

To update the channel state, ğ‘ƒ first computes the hash of the
new channel state together with a random value, signs the hash
and shares the state, random value and the signature with ğ‘„. Then,
after ğ‘„ has validated the state, ğ‘„ also signs the same hash value and
shares the signature with ğ‘ƒ. Then, both parties send the signatures
and the hash to the committee members via consistent broadcast.
The reason for not sharing the (unobfuscated) channel state with the
committee members is the privacy of the individual channel updates.
In this way, the committee only sees the initial and final state of the
channel. The committee members validate the signatures on the
hashed state. If both signatures are valid, they acknowledge it by
sending their signatures of the shared hash and register the state
together with the time they have received it to the parties. Once
a party has received 2ğ‘“ + 1 signatures (necessary for the state to
be available from any ğ‘“ + 1 nodes if a channel has to be closed),
she knows that the update is accepted. An honest party does not
participate in new update requests while there is an ongoing update
or the channel closure has been initiated. Note that the registration
time is necessary for our protocol because of the time conditions.

The channel update takes 4ğ›¿: exchanging signatures and states
between the two parties takes 2ğ›¿, informing the committee and
receiving their responses are another 2ğ›¿.

Closing a channel is a bit more complex than in single-hop asyn-
chronous payment channels. If both parties agree on the channel
state, they can close the channel by signing the latest state, as in
Brick. Otherwise, the party wanting to close, say ğ‘ƒ, initiates the
closure by sharing the latest state and random value used in the
hash with ğ‘Š (ğ‘ƒ, ğ‘„). ğ‘Š (ğ‘ƒ, ğ‘„) checks that it is indeed the latest state
by computing the hash and checking that it is equal to their latest
hash. Then, ğ‘Š (ğ‘ƒ, ğ‘„) informs ğ‘„ of the closure initiation. If there
are ongoing multi-hop payments, the committee waits until the
timeouts of the multi-hop payments before closing the channel.
Note that these timeouts are computed with respect to the regis-
tration time of (the hash of) the channel state corresponding to
the payment3. Once all the channel outputs are resolved, then the
committee signs the final channel state accordingly. ğ‘ƒ can close the
channel by publishing their signature together with the quorum
certificate of the committee.

Overview of the protocol. Figure 1 presents a payment example
that illustrates SyncPCN for four parties. Let us generalize the ex-
ample for ğ‘˜+1 parties where ğ‘ƒ0 is the payment sender, ğ‘ƒğ‘˜ is the
payment receiver, and parties ğ‘ƒ1, . . . , ğ‘ƒğ‘˜âˆ’1 are the intermediaries.
The payment goes through ğ‘˜ channels: ğ›¾0, ğ›¾1, . . . , ğ›¾ğ‘˜âˆ’1 where ğ›¾ğ‘– de-
notes the channels between ğ‘ƒğ‘– and ğ‘ƒğ‘–+1. In a successful multi-hop
payment, in each channel ğ›¾ğ‘– , ğ‘ƒğ‘– pays ğ‘£ğ‘– := ğ‘£ + (cid:205)ğ‘˜âˆ’1
ğ‘—=ğ‘–+1 ğ‘“ğ‘— coins to
ğ‘ƒğ‘–+1 where ğ‘£ is the value of the payment agreed by the sender and
receiver, and ğ‘“ğ‘— denotes the fee of an intermediary ğ‘ƒ ğ‘— . Here, a mech-
anism is needed to ensure balance security, i.e., to guarantee that
honest ğ‘ƒğ‘– receives ğ‘£ğ‘–+1 coins in ğ›¾ğ‘–+1 if she pays ğ‘£ğ‘– coins in ğ›¾ğ‘– . Light-
ning achieves balance security by using HTLCs (hash-time lock
contracts). However, because of the privacy concerns as well as the
wormhole attack against HTLC, we adopt the AMHL (anonymous
multi-hop lock) protocol [37].

Here, we briefly explain the concept of conditional payments that
we adopt from AMHL. A conditional payment CP between payer ğ‘ƒ
and payee ğ‘„ can be defined with a tuple of (ğ‘£,ğ‘‡ , ğ‘Œ ) where ğ‘£ is the
payment value, ğ‘‡ is the timelock 4 and ğ‘Œ is the locking condition.
The conditional payment works as follows: First, ğ‘ƒ locks ğ‘£ coins
with respect to the timelock ğ‘‡ and condition ğ‘Œ with regard to an
additively homomorphic one-way function H [37]. ğ‘„ then can
claim the amount ğ‘£ by providing a witness (preimage) ğ‘¦ satisfying
the condition ğ‘Œ , i.e., ğ‘Œ = H (ğ‘¦). If the secret is not provided before
time ğ‘‡ , ğ‘ƒ re-claims the amount.

4.2 Multi-hop Payment Protocol
We assume that the sender and receiver agree on the payment value
ğ‘£ and the path is chosen by the sender. The criteria on how to select
the path are orthogonal to our protocol and any source routing
algorithm can be used for selecting the path. To improve privacy,
we use onion routing with the Sphinx package format [14] for the

3The registration time of each committee member can be different. For the security of
our protocol, we only require that an update sent by an honest party is received by
honest committee members within ğ›¿ time.
4In AMHL, the time unit is defined over the blocks. In our protocol, we use the global
time that is available to parties and committee members.

OÄŸuzhan Ersoy, JÃ©rÃ©mie Decouchant, Satwik Prabhu Kumble, and Stefanie Roos

Figure 1: Illustration of the steps of SyncPCN.

communication between parties in the path. The layered encryption
allows intermediaries to learn the predecessor and successor on the
path as well as a per-hop payload that includes payment information
necessary such as the payment value or timeouts5.

Now, we explain our protocol in three steps: First, the sender
creates the locking conditions for each channel in the path wrt.
the AMHL protocol. Second, from sender to receiver, parties lock
the coins if they accept the conditions and there is enough balance.
In the final step, the payment is executed: either the condition is
satisfied and payment is completed or it is revoked.

Setup. First, the sender ğ‘ƒ0 chooses random values â„“0, â„“1, . . . , â„“ğ‘˜âˆ’1,
:= H (ğ‘¦ ğ‘— ) for ğ‘— = 0, . . . , ğ‘˜ âˆ’ 1.

and computes ğ‘¦ ğ‘—
Then, the sender constructs the payload of ğ‘ƒğ‘– as follows (ğ‘– â‰¥ 1):
ğ¸ğ‘ğ‘˜ğ‘– (ğ‘€ğ‘– ) := ğ¸ğ‘ğ‘˜ğ‘– (ğ‘ƒğ‘–+1, ğ‘£ğ‘–, (ğ‘Œğ‘–âˆ’1, ğ‘Œğ‘–, â„“ğ‘– ),ğ‘‡ğ‘–, ğ¸ğ‘ğ‘˜ğ‘–+1 (ğ‘€ğ‘–+1))

ğ‘–=0 â„“ğ‘– and ğ‘Œğ‘—

:= (cid:205)ğ‘—

denotes the encryption with the public key of node
where ğ¸ğ‘ğ‘˜ğ‘–
ğ‘ƒğ‘– and ğ‘€ğ‘–+1 is the payload of node ğ‘ƒğ‘–+1, which is in the same
structure as ğ‘€ğ‘– . Note that there is always a padding to ensure that
all messages have the same length, which we exclude for brevity.
Here, ğ‘‡ğ‘– = (cid:205)ğ‘˜âˆ’1
ğ‘—=ğ‘–+1 ğ‘“ğ‘—
is the amount. Like in the Lightning, we assume that timelock ğ‘‡ ğ¿ğ‘–
and fee ğ‘“ğ‘– values of a channel ğ›¾ğ‘– as well as the public key of a party
ğ‘ğ‘˜ğ‘– are publicly known. For the balance security of an honest party
ğ‘ƒğ‘– , the timelock value ğ‘‡ ğ¿ğ‘– should be greater than or equal to 6ğ›¿.
We explain the reasoning of the condition in the atomicity proof.

ğ‘—=ğ‘–+1 ğ‘‡ ğ¿ğ‘— is the timelock value and ğ‘£ğ‘– := ğ‘£ + (cid:205)ğ‘˜âˆ’1

Locking. The sender ğ‘ƒ0 initiates the payment with ğ‘ƒ1 wrt. the
conditional payment CP0 = (ğ‘£0, ğ‘Œ0,ğ‘‡0), see step 1 in Fig. 1. Note
that at this point ğ‘ƒ1 is the payee, thus she accepts the payment
if the channel balance is enough. If the update is successful, then
ğ‘ƒ0 sends ğ¸ğ‘ğ‘˜1 (ğ‘€1) to ğ‘ƒ1. Then, ğ‘ƒ1 decrypts ğ‘€1 and checks the
payment conditions for the next hop. After checking the validity of
the payment, as described below, ğ‘ƒ1 initiates the payment with ğ‘ƒ2
in ğ›¾1 (step 2 in Fig. 1). If the update is successful, ğ‘ƒ1 sends ğ¸ğ‘ğ‘˜2 (ğ‘€2)
to ğ‘ƒ2. The steps of decrypting the message, checking the validity
of the payment, and forwarding it to the successor continue until
the receiver has been reached. If all channels on the path, including
the channel of the receiver, agree to lock the payment, then the
locking phase is considered successful. However, if a channel on the

5As described in https://github.com/lightningnetwork/lightning-rfc/blob/master/04-
onion-routing.md.

6

ğ‘ƒ!	1.ğ¶ğ‘ƒ(ğ‘£!,ğ‘Œ!	,ğ‘‡!	)UpdAckUpdAckUpdAck	2.ğ¶ğ‘ƒ(ğ‘£#,ğ‘Œ#	,ğ‘‡#	)	3.ğ¶ğ‘ƒ(ğ‘£$,ğ‘Œ$	,ğ‘‡$	)4. Locked5.ğ‘¦$	6.	ğ‘¦$		7.	ğ‘¦#		8.	ğ‘¦!	ğ‘Š(ğ‘ƒ!,ğ‘ƒ")ğ‘Š(ğ‘ƒ",ğ‘ƒ#)ğ‘Š(ğ‘ƒ#,ğ‘ƒ$)ğ‘ƒ#ğ‘ƒ$ğ‘ƒ%SyncPCN/PSyncPCN: Payment Channel Networks without Blockchain Synchrony

path does not accept the payment request, then the locking phase
is aborted. All the previously locked channels can be unlocked
either by agreement of the parties to abort the payment or after the
corresponding timelocks expire.

Now, we discuss the channel update requirements for a pay-
ing intermediary party ğ‘ƒğ‘– after updating the channel ğ›¾ğ‘–âˆ’1 wrt.
CPğ‘–âˆ’1=(ğ‘£ğ‘–âˆ’1, ğ‘Œğ‘–âˆ’1,ğ‘‡ğ‘–âˆ’1). First, ğ‘ƒğ‘– decrypts ğ‘€ğ‘– and obtains (ğ‘ƒğ‘–+1, ğ‘£ğ‘–,
(ğ‘Œğ‘–âˆ’1, ğ‘Œğ‘–, â„“ğ‘– ),ğ‘‡ğ‘–, ğ¸ğ‘ğ‘˜ğ‘–+1 (ğ‘€ğ‘–+1)) where CPğ‘– =((ğ‘Œğ‘–âˆ’1, ğ‘Œğ‘–, â„“ğ‘– ),ğ‘‡ğ‘– ). Party
ğ‘ƒğ‘– accepts to lock the payment CPğ‘– =(ğ‘£ğ‘–, ğ‘Œğ‘–,ğ‘‡ğ‘– ) in ğ›¾ğ‘–+1 if:

â€¢ ğ‘ƒğ‘– has enough balance in the channel, at least ğ‘£ğ‘– coins.
â€¢ The payment value difference between CPğ‘–âˆ’1 and CPğ‘– is at

least the expected fee, i.e., ğ‘£ğ‘–âˆ’1 âˆ’ ğ‘£ğ‘– â‰¥ ğ‘“ğ‘– .

â€¢ The timelock difference between CPğ‘–âˆ’1 and CPğ‘– is at least

the expected timelock value, i.e., ğ‘‡ğ‘–âˆ’1 âˆ’ ğ‘‡ğ‘– â‰¥ ğ‘‡ ğ¿ğ‘– .

â€¢ The AMHL condition is correct, i.e., ğ» (â„“ğ‘– ) âŠ• ğ‘Œğ‘–âˆ’1 = H (ğ‘¦ğ‘– ) =
ğ‘Œğ‘– , where âŠ• denotes the homomorphic operation in the range
of H .

If all the checks are successful and both parties agree to the update,
ğ‘ƒğ‘– stores â„“ğ‘– to be utilized in the payment phase and the channel
ğ›¾ğ‘–âˆ’1 is updated by the addition of CPğ‘– . These checks are crucial for
the balance security of the honest ğ‘ƒğ‘– . The timelock check ensures
that ğ‘ƒğ‘– has enough time to react to the protocol regardless of the
actions of the other parties; the AMHL check ensures that ğ‘ƒğ‘– is
paid in ğ›¾ğ‘–âˆ’1 if she pays in ğ›¾ğ‘– . For the receiver ğ‘ƒğ‘˜ , since there is no
further channel, Party ğ‘ƒğ‘˜ only checks the timelock in CPğ‘˜âˆ’1 :=
(ğ‘£,ğ‘‡ğ‘˜âˆ’1, ğ‘Œğ‘˜âˆ’1) is greater than or equal to the expected timelock
value, i.e., ğ‘‡ğ‘˜âˆ’1 â‰¥ ğ‘‡ ğ¿ğ‘˜ . Once the last channel is updated, the locking
phase is successful.

Payment. In this phase, the payment is executed. After the re-
ceiver ğ‘ƒğ‘˜ sends Locked message to the sender ğ‘ƒ0 (step 4 in Fig. 1),
ğ‘ƒ0 reveals the witness ğ‘¦ğ‘˜âˆ’1 to ğ‘ƒğ‘˜ (step 5 in Fig. 1). The receiver ğ‘ƒğ‘˜
uses the witness ğ‘¦ğ‘˜âˆ’1 to claim the payment of CPğ‘˜âˆ’1 from ğ‘ƒğ‘˜âˆ’1
in channel ğ›¾ğ‘˜âˆ’1 (step 6 in Fig. 1). If the witness is correct, then
ğ‘ƒğ‘˜âˆ’1 can obtain witness ğ‘¦ğ‘˜âˆ’2 by using ğ‘¦ğ‘˜âˆ’1 and already known
value â„“ğ‘˜âˆ’1, i.e., ğ‘¦ğ‘˜âˆ’2 = ğ‘¦ğ‘˜âˆ’1 âˆ’ â„“ğ‘˜âˆ’1. Similarly, ğ‘ƒğ‘˜âˆ’1 can claim the
payment of CPğ‘˜âˆ’2 in channel ğ›¾ğ‘˜âˆ’2 (step 7 in Fig. 1). The same steps
are repeated and the channels are updated in the direction from
the receiver to the sender. If the witness ğ‘¦ğ‘– is not sent to ğ‘ƒğ‘– before
the timeout ğ‘‡ğ‘– , then the conditional payment CPğ‘– expires and the
parties update their channel ğ›¾ğ‘– such that ğ‘ƒğ‘– reclaims the locked
amount ğ‘£ğ‘– .

In general, upon receiving the witness ğ‘¦ğ‘– , an intermediary ğ‘ƒğ‘– ,

checks the following conditions:

?
= ğ‘Œğ‘– .
â€¢ The witness is correct wrt. the condition, i.e., H (ğ‘¦ğ‘– )
â€¢ The secret is shared before the timeout, i.e., for the time ğ‘¡ğ‘–

when receiving the secret, ğ‘¡ğ‘– < ğ‘‡ğ‘– .

If both checks are satisfied, then the parties update their channel ğ›¾ğ‘–
where ğ‘ƒğ‘– pays ğ‘ƒğ‘–+1 the amount ğ‘£ğ‘– . After receiving the valid witness
ğ‘¦ğ‘– , ğ‘ƒğ‘– computes ğ‘¦ğ‘–âˆ’1=ğ‘¦ğ‘– âˆ’ â„“ğ‘– and immediately requests the payment
from ğ‘ƒğ‘–âˆ’1 in the channel ğ›¾ğ‘–âˆ’1.

In case of a dispute when one of the parties does not accept to
update the channel, the honest party starts the procedure of channel
closing via the committee members. Here, we describe both cases
where either payer or payee is honest and the other party does not
cooperate with the channel update. If the payee ğ‘ƒğ‘– is honest and

7

has shared the witness ğ‘¦ğ‘–âˆ’1 on time but the other party ğ‘ƒğ‘–âˆ’1 does
not update the channel, ğ‘ƒğ‘– initiates the closure of the channel. The
procedure works as follows:

(1) At time ğ‘‡ğ‘–âˆ’1 âˆ’ ğ›¿, if the update is not completed, ğ‘ƒğ‘– sends
the latest state of the channel and the witness ğ‘¦ğ‘–âˆ’1 to the
committee members ğ‘Š (ğ‘ƒğ‘–âˆ’1, ğ‘ƒğ‘– ).

(2) ğ‘Š (ğ‘ƒğ‘–âˆ’1, ğ‘ƒğ‘– ) validates the state by checking whether the hash
of the state is the same as the latest hash (with the signatures
of the nodes) they have received. If the check fails, they
do not continue. Otherwise, they inform ğ‘ƒğ‘–âˆ’1 by sending a
message stating the channel closure has been initiated.
(3) Then, ğ‘Š (ğ‘ƒğ‘–âˆ’1, ğ‘ƒğ‘– ) checks if the conditional payment is satis-
fied, i.e., ğ‘¦ğ‘–âˆ’1 satisfies the condition and the time of delivery
is before the timelock ğ‘‡ğ‘–âˆ’1. If the checks hold, then they ap-
prove the payment, and sign the latest state, which includes
the payment of ğ‘£ğ‘–âˆ’1, and send their signatures to ğ‘ƒğ‘– . They
send ğ‘¦ğ‘–âˆ’1 to ğ‘ƒğ‘–âˆ’1.

(4) After receiving the signatures of ğ‘Š (ğ‘ƒğ‘–âˆ’1, ğ‘ƒğ‘– ), ğ‘ƒğ‘– signs the
new state of the channel and publishes it on the blockchain.
If the payer ğ‘ƒğ‘–âˆ’1 is honest and has not received ğ‘¦ğ‘–âˆ’1 until the
timeout and the other party ğ‘ƒğ‘– does not update the channel to allow
ğ‘ƒğ‘– to reclaim her coins, then ğ‘ƒğ‘–âˆ’1 initiates the closure of the channel.
The procedure works as follows:

(1) At time ğ‘‡ğ‘–âˆ’1, if the update is not completed, ğ‘ƒğ‘–âˆ’1 sends
the latest state of the channel to the committee members
ğ‘Š (ğ‘ƒğ‘–âˆ’1, ğ‘ƒğ‘– ).

(2) ğ‘Š (ğ‘ƒğ‘–âˆ’1, ğ‘ƒğ‘– ) validates the state by checking the latest hash
they received (as in the previous case). If the checks fail, they
do not continue. Otherwise, they inform ğ‘ƒğ‘– .

(3) Then, ğ‘Š (ğ‘ƒğ‘–âˆ’1, ğ‘ƒğ‘– ) checks if the conditional payment has
failed, i.e., the timelock ğ‘‡ğ‘–âˆ’1 has passed. If the checks hold,
then they approve the cancellation of the payment, sign the
latest state, which removes the payment of ğ‘£ğ‘–âˆ’1, and send
their signatures to ğ‘ƒğ‘–âˆ’1.

(4) After receiving the signatures of ğ‘Š (ğ‘ƒğ‘–âˆ’1, ğ‘ƒğ‘– ), ğ‘ƒğ‘–âˆ’1 signs the
new state of the channel and publishes it on the blockchain.
Note that if ğ‘ƒğ‘– is honest and ğ‘ƒğ‘–âˆ’1 has not accepted the channel
update, ğ‘ƒğ‘– should initiate the channel closure at ğ‘‡ğ‘–âˆ’1 âˆ’ğ›¿ as explained
in the first case. Thus, the committee members do not need to
validate that ğ‘ƒğ‘–âˆ’1 is honestly claiming that she did not receive the
witness as they would already have received a message from ğ‘ƒğ‘– if
ğ‘ƒğ‘–âˆ’1 was misbehaving. Also, if there are multiple ongoing multi-
hop payments, honest parties follow the same procedure for each
of them (without sharing the channel state if it is already shared).
In order to enable that state updates with timelocks about to expire
can be sent to the committee despite on-going payments, parties
do not initiate new updates for the respective channel within 4ğ›¿ of
a timelock expiring. They further ensure that there are at least 4ğ›¿
between timelocks for the same channel.

4.3 Security and Privacy Analysis
We show in the following that SyncPCN achieves atomicity (def. 4),
coin availability (def. 3), value privacy (def. 5), endpoint privacy
(def. 6) and relationship anonymity (def. 7). We omit the proof
of balance security (def. 1), as atomicity implies balance security.
Furthermore, as it is straightforward that the protocol is successful

if all parties follow the protocol and channels have enough balance,
we omit the correctness proof.

To create multi-hop payments and the corresponding payload
messages for SyncPCN, we utilize two cryptographic operations:
hashing H (Â·) and encryption ğ¸ğ‘ğ‘˜ (Â·). Thus, the security analysis
relies on the security of these primitives. More specifically, we as-
sume that H is a cryptographically secure additively homomorphic
one-way function and ğ¸ğ‘ğ‘˜ is IND-CCA secure encryption scheme.

Theorem 10. SyncPCN provides atomicity.

Proof. Our atomicity proof has three steps: (i) the balance secu-
rity for an intermediary party ğ‘ƒğ‘– , (ii) balance security of the sender
ğ‘ƒ0, (iii) atomicity requirement.

If the honest party ğ‘ƒğ‘– does not pay in ğ›¾ğ‘– , then it does not lose
any coins. Thus, we only need to ensure that if ğ‘ƒğ‘– pays in ğ›¾ğ‘– , the
party receives the payment in ğ›¾ğ‘–âˆ’1. In other words, if the channel ğ›¾ğ‘–
is updated with the acceptance of the payment, then there should
be sufficient time for the party to use the corresponding witness
on the channel ğ›¾ğ‘–âˆ’1.

If the payment for ğ›¾ğ‘– is accepted (by parties or the committee),
the latest time that ğ‘ƒğ‘– can receive the witness ğ‘¦ğ‘– occurs when the
counter party ğ‘ƒğ‘–+1 does not provide ğ‘¦ğ‘– before time ğ‘‡ğ‘– âˆ’ ğ›¿, but rather
shares it with the committee via initiating the channel closure. To
have approval of the honest members in ğ‘Š (ğ‘ƒğ‘–âˆ’1, ğ‘ƒğ‘– ), they should
receive ğ‘¦ğ‘– before ğ‘‡ğ‘–âˆ’1. They then send it to ğ‘ƒğ‘– , which is delivered
at latest at ğ‘‡ğ‘– + ğ›¿. After that, an honest ğ‘ƒğ‘– can compute the witness
ğ‘¦ğ‘–âˆ’1 = ğ‘¦ğ‘– âˆ’ â„“ğ‘– . Then, ğ‘ƒğ‘– first attempts to update the channel ğ›¾ğ‘–
before ğ‘‡ğ‘–âˆ’1 âˆ’ ğ›¿, which takes at most 4ğ›¿ (otherwise ğ‘ƒğ‘– sends the
channel state and the witness to committee). Thus, for an honest
party ğ‘ƒğ‘– to react on time, the following inequality has to hold:
ğ‘‡ğ‘–âˆ’1 âˆ’ ğ›¿ âˆ’ (ğ‘‡ğ‘– + ğ›¿) â‰¥ 4ğ›¿. This is satisfied because of the choice of
timelocks, i.e., ğ‘‡ğ‘–âˆ’1 âˆ’ ğ‘‡ğ‘– â‰¥ ğ‘‡ ğ¿ğ‘– â‰¥ 6ğ›¿. This shows (i).

Now, we show that ğ‘ƒ0 pays in ğ›¾0 only if the receiver ğ‘ƒğ‘˜ is paid
in ğ›¾ğ‘˜âˆ’1. Similar to [37], this is satisfied because of the secure one-
wayness property of H . Party ğ‘ƒ0 only pays if ğ‘¦0 = â„“0 is provided
by ğ‘ƒ1. The intermediary parties only know the â„“ğ‘– values for ğ‘– =
1, . . . , ğ‘˜ âˆ’ 2. The value ğ‘¦0 can only be obtained after ğ‘¦ğ‘˜âˆ’1 is shared
by ğ‘ƒ0, which happens after the channel ğ›¾ğ‘˜âˆ’1 is locked. In that case,
ğ‘ƒğ‘˜ can also claim the payment in ğ›¾ğ‘˜âˆ’1 using ğ‘¦ğ‘˜âˆ’1. Thus, (ii) holds.
Finally, we show atomicity: for an honest sender ğ‘ƒ0 and honest
intermediary ğ‘ƒğ‘–+1, if the condition condğ‘– is not satisfied, then both
conditions condğ›¼ and condğ›½ should not be satisfied for ğ›¼ < ğ‘– < ğ›½.
As explained for (ii), in our protocol, the payment conditions are
satisfied in the order from the receiver to the sender. It is hence
sufficient to show that condğ›¼ is not satisfied. Note that satisfying
the payment condition condğ›¼ implies knowing the preimage of ğ‘Œğ›¼ ,
which is ğ‘¦ğ›¼ = (cid:205)ğ›¼
ğ‘–=0 â„“ğ‘– . Since condğ‘– is not satisfied, party ğ‘ƒğ‘–+1 would
not know/reveal ğ‘¦ğ‘–+1 or ğ‘¦ğ‘– , and also â„“ğ‘–+1. Thus the only way to
know ğ‘¦ğ›¼ is directly from ğ‘Œğ›¼ , which contradicts with one-wayness
â–¡
of the hash function H .

Theorem 11. SyncPCN provides coin availability.

Proof. Each conditional payment has a finite timelock. In the
honest case, parties release the locked coins before the timelock
expires. In the malicious case where one of the parties does not
accept the update of the channel, the honest party can initiate the

8

OÄŸuzhan Ersoy, JÃ©rÃ©mie Decouchant, Satwik Prabhu Kumble, and Stefanie Roos

closure of the channel. Then, the committee executes the closure
of the channel after waiting for the timelocks, which also requires
â–¡
a finite amount of time.

Theorem 12. SyncPCN provides value privacy.

Proof. We need to show that the adversary A cannot win the
Value Privacy Game, i.e., cannot guess which of the values ğ‘£ 0,ğ‘£ 1
has been used in the multi-hop payment. In SyncPCN, payload mes-
sages between the parties in the path are encrypted and shared
with the onion routing mechanism. Thus, an outsider adversary
can only obtain the encrypted payload messages. Thereby, if A is
able to guess the payment value with more than 1/2 probability,
it implies that A obtained useful information from the encrypted
payload messages. However, this contradicts our assumption that
â–¡
the encryption scheme ğ¸ğ‘ğ‘˜ is IND-CCA secure.

Theorem 13. SyncPCN provides endpoint privacy.

Proof. Here, we show that the adversary A cannot win the
Endpoint Privacy Game with significantly more than a probabil-
ity of 1/2. First, A := ğ‘ƒğ‘– chooses two paths of the same length,
payment value, and timelocks, and for both paths, the neighbors
of A, ğ‘ƒğ‘–âˆ’1 and ğ‘ƒğ‘–+1 are the same. For a randomly chosen path, let
ğ‘€ğ‘– be the payload received by A. The previous party in the path
(ğ‘ƒğ‘–âˆ’1) is the same for both paths, thus, in any case, the payload
will be received from ğ‘ƒğ‘–âˆ’1, and it will include (ğ‘ƒğ‘–+1, ğ‘£ğ‘–, (ğ‘Œğ‘–âˆ’1, ğ‘Œğ‘–, â„“ğ‘– ),
ğ‘‡ğ‘–, ğ¸ğ‘ğ‘˜ğ‘–+1 (ğ‘€ğ‘–+1)). Since the next party in the path, the payment
value, and timelocks are the same, the distinguishing part of the
two potential payments would be ((ğ‘Œğ‘–âˆ’1, ğ‘Œğ‘–, â„“ğ‘– ), ğ¸ğ‘ğ‘˜ğ‘–+1 (ğ‘€ğ‘–+1)). The
adversary cannot obtain any information from ğ¸ğ‘ğ‘˜ğ‘–+1 (ğ‘€ğ‘–+1) with-
out violating the IND-CCA security assumption of the encryption
scheme. Finally, we need to show that the tuple (ğ‘Œğ‘–âˆ’1, ğ‘Œğ‘–, â„“ğ‘– ) does
not reveal any information about the actual sender or receiver pair.
Note that â„“ğ‘– values are randomly chosen by the sender of the pay-
ment and the ğ‘Œğ‘– values are computed accordingly. Since â„“ğ‘– values do
not contain any information specific to the sender and are chosen
randomly, from the perspective of A, the tuple does not give any
information regarding the path. Hence, we can conclude that the
payload does not give any information about the path other than
â–¡
the neighbors of the adversary.

Theorem 14. SyncPCN provides relationship anonymity.

Proof. Different from the endpoint case, in the Relationship
Anonymity Game, the adversary is trying to distinguish ğ‘ from
two successful payments. Initially, the adversary chooses a path
segment ğ‘ğ‘ğ‘¡â„[1 : ğ‘˜ âˆ’1] that is common in both payments. Moreover,
the adversary can include multiple adversarial intermediary parties
in ğ‘ğ‘ğ‘¡â„[1 : ğ‘˜ âˆ’ 1], so long as there is at least one honest party.

Let ğ‘ƒğ‘– be an honest party and the rest of the intermediaries be
adversarial, i.e., A := ğ‘ğ‘ğ‘¡â„[1 : ğ‘– âˆ’ 1] âˆª ğ‘ğ‘ğ‘¡â„[ğ‘– + 1 : ğ‘˜ âˆ’ 1]. Note
that this is the best case for the adversary (since it includes all
but one honest party in the path segment). Let {ğ‘€0} A, {ğ‘€1} A
be the corresponding payload messages received by A. Since the
intermediaries, payment values, and timelocks are the same fro
both paths, we can ignore them for distinguishing the paths. Thus,
the only aspects that can be used for distinguishing the paths are
the conditional payment tuples.

SyncPCN/PSyncPCN: Payment Channel Networks without Blockchain Synchrony

ğ‘— , â„“ğ‘

ğ‘—âˆ’1, ğ‘Œ ğ‘

The adversary has the tuples (ğ‘Œ ğ‘

ğ‘— ) for ğ‘ = 0, 1 and ğ‘— =
1, . . . , ğ‘– âˆ’ 1, ğ‘– + 1, . . . , ğ‘˜ âˆ’ 1. Trivially, due to ğ» being homomorphic,
the adversary can link the tuples from the sender to ğ‘ğ‘ğ‘¡â„[ğ‘– âˆ’ 1].
Similarly, A can link the tuples from the receiver to ğ‘ğ‘ğ‘¡â„[ğ‘– + 1].
Therefore, A can win the game (with more than 1/2 probability) if
and only if A can link the tuples of ğ‘ğ‘ğ‘¡â„[ğ‘– âˆ’ 1] and the tuples of
ğ‘ğ‘ğ‘¡â„[ğ‘– + 1], thereby connecting the sender and receiver pairs.

ğ‘– ) âŠ• ğ‘Œ ğ‘ 0

, otherwise ğ» (â„“ğ‘

ğ‘–âˆ’1, â„“ğ‘ 1
ğ‘–âˆ’2, ğ‘Œ ğ‘ 1
ğ‘–+1, â„“ğ‘Ÿ 0
, ğ‘Œ ğ‘Ÿ 0
ğ‘–âˆ’1 and ğ‘Œ ğ‘Ÿ 0

Let us denote the tuple of ğ‘ğ‘ğ‘¡â„[ğ‘– âˆ’ 1] linked to ğ‘ 0 with (ğ‘Œ ğ‘ 0
ğ‘–âˆ’2,
ğ‘–âˆ’1) and the one linked to ğ‘ 1 with (ğ‘Œ ğ‘ 1
ğ‘–âˆ’1, â„“ğ‘ 0
ğ‘Œ ğ‘ 0
ğ‘–âˆ’1). Similarly,
the tuple of ğ‘ğ‘ğ‘¡â„[ğ‘– + 1] linked to ğ‘Ÿ 0 is (ğ‘Œ ğ‘Ÿ 0
ğ‘–+1) and the one
ğ‘–
linked to ğ‘Ÿ 1 is (ğ‘Œ ğ‘Ÿ 1
ğ‘–+1). Here, if ğ‘Œ ğ‘ 0
ğ‘–+1, â„“ğ‘Ÿ 1
, ğ‘Œ ğ‘Ÿ 1
are linked, i.e.,
ğ‘–
belong to the same payment, then adversary can conclude that
ğ‘ = 0, otherwise ğ‘ = 1. If they belong to the same path then,
ğ‘–âˆ’1 = ğ‘Œ ğ‘Ÿ 0
ğ‘–âˆ’1 = ğ‘Œ ğ‘Ÿ 1
ğ» (â„“ğ‘
ğ‘– where ğ‘ âˆˆ {0, 1}.
ğ‘–
Therefore deriving whether ğ‘Œ ğ‘ 0
are linked or not can be
ğ‘– and â„“1
reduced to the knowledge of ğ» (â„“ğ‘
ğ‘– values
are only given to the intermediary party ğ‘ƒğ‘– , the hash values ğ» (â„“0
ğ‘– )
and ğ» (â„“0
ğ‘– ) that distinguishes the possible paths are not known
by A. More specifically, from the adversaryâ€™s perspective, both
ğ‘Œ ğ‘ 0
ğ‘–âˆ’1 âŠ• ğ‘Œ ğ‘Ÿ 0
ğ‘– values are equally likely candidates for
ğ» (â„“ğ‘
ğ‘– ) where ğ‘ âˆˆ {0, 1}. Under the assumption that the encryption
scheme ğ¸ğ‘ğ‘˜ is IND-CCA secure, and H is a cryptographically secure
hash function, the adversary cannot guess ğ‘ value with a probability
â–¡
significantly higher than 1/2.

ğ‘– ) âŠ• ğ‘Œ ğ‘ 0
ğ‘–âˆ’1 and ğ‘Œ ğ‘Ÿ 0

ğ‘– ) value. Since â„“0

ğ‘–âˆ’1 âŠ• ğ‘Œ ğ‘Ÿ 1

and ğ‘Œ ğ‘ 0

ğ‘–

ğ‘–

ğ‘–

5 PSYNCPCN: BLOCKCHAIN-ASYNCHRONOUS

PAYMENTS ON
PARTIALLY-SYNCHRONOUS NETWORKS
This section describes PSyncPCN, our multi-hop payment protocol
that assumes the availability of a BFT committee associated with
each channel but does not assume synchronous communications.

5.1 Model and Overview

Threat Model. Committees in PSyncPCN are assumed to contain
at most ğ‘“ faulty members out of ğ‘› â‰¥ 3ğ‘“ +1 members. Channel com-
mittee members can be selected randomly from a global blockchain
committee using recent works [7, 22, 24, 30], which guarantee un-
biased uniform selection and termination of the selection protocol.
Appx. A discusses the probability for a committee of size ğ‘› that is
sampled from a global committee of size ğ‘ with ğ¹ faulty members
to contain less than ğ‘“ faulty members.

Payment channels. Committee members maintain a channelâ€™s
balance, lock the amounts that correspond to on-going payments,
and eventually release or confirmed these locked amounts. To en-
sure that a payment is eventually processed or rejected, intermedi-
ary parties cannot stop a payment that uses one of their channels,
but they are kept informed of their balance. To close a channel
one of the party has to explicitly request it from the committee
members. Since the balance of a channel depends on the multi-hop
payment that it is involved it, the committee members then stop
accepting new payments on the channel. Once all pending pay-
ments have been processed, the value reported by at least 2ğ‘“ +1

9

Figure 2: Illustration of the steps of PSyncPCN.

committee members is published on the blockchain as the final
channel balance.

Message format and payment Ids. Once a channel has been cre-
ated, like in SyncPCN, the payment sender and receiver agree outside
of the protocol on the payment. The sender identifies a path to the
receiver. Messages use the same layered encryption format as in
SyncPCN with the difference that they do not include timeouts and
tuples (ğ‘Œğ‘–âˆ’1, ğ‘Œğ‘–, â„“ğ‘– ) of hashes and random numbers. A committee
member of a multi-hop payment in PSyncPCN trusts subsequent
committees on the path to process it. Upon success, the sender
eventually assembles a payment proof made of ğ‘“ +1 confirmations
from its committee. Committees use a total order broadcast to safely
process potential concurrent multi-hop payments originating from
different payment senders. PSyncPCN could leverage virtual chan-
nels [19] to use only one consensus operation per multi-hop chan-
nel creation/deletion and otherwise leverage reliable broadcast for
subsequent payments over the multi-hop channel.

A payment is given a monotonically increasing payment Id by the
nodes sending or transmitting it because messages can be reordered
by the network and to allow multiple identical payments to be
correctly processed. Initially, the payment sender uses its locally
maintained payment Id to communicate with its committee. Upon
transmitting a payment, a committee replaces the Id it received by
an Id it maintains to exchange with the subsequent committee.

5.2 Multi-hop protocol
We present pseudocode of PSyncPCN in Alg. 1. For clarity, we sim-
plify it as follows: we do not show message encryptions or de-
cryptions; the channel balance is only maintained for the payment
sender; onion paths are replaced by the full payment path so that
a payment can be identified using only the payment Id chosen by
the payment sender; payment fees are also ignored.

To start a payment, the sender sends a PAY message to the
committee of the first channel on the path towards the receiver.
PSyncPCN follows a 2-phase approach, like SyncPCN, with one phase
for locking and one for confirming/revoking a payment. Payments
implicitly belong in one of two states:

(1) locked: the payment has been locally registered and trans-

ferred to the subsequent committee for processing.

(2) done: the payment is completed for this channel.

ğ‘ƒ!	1.(ğ‘ƒğ‘ğ‘¦,ğ¼ğ‘‘,ğ‘£!)3.(ğ‘ƒğ‘ğ‘¦,ğ¼ğ‘‘,ğ‘£")ğ‘Š(ğ‘ƒ!,ğ‘ƒ")ğ‘Š(ğ‘ƒ",ğ‘ƒ#)ğ‘Š(ğ‘ƒ#,ğ‘ƒ$)ğ‘ƒ"ğ‘ƒ#ğ‘ƒ$5.(ğ‘ƒğ‘ğ‘¦,ğ¼ğ‘‘,ğ‘£#)7.(ğ‘†ğ‘ˆğ¶ğ¶ğ¸ğ‘†ğ‘†,ğ¼ğ‘‘,ğ‘£#)9.(ğ‘†ğ‘ˆğ¶ğ¶ğ¸ğ‘†ğ‘†,ğ¼ğ‘‘,ğ‘£")	2.(ğ‘™ğ‘œğ‘ğ‘˜ğ‘’ğ‘‘,ğ‘£!)	10.(ğ‘‘ğ‘œğ‘›ğ‘’,ğ‘£!)	4.(ğ‘™ğ‘œğ‘ğ‘˜ğ‘’ğ‘‘,ğ‘£")	8.(ğ‘‘ğ‘œğ‘›ğ‘’,ğ‘£")	6.(ğ‘‘ğ‘œğ‘›ğ‘’,ğ‘£#)Algorithm 1 Simplified PSyncPCN.

For party ğ‘ƒğ‘– :

ğ‘šğ‘¦ğµğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’âˆ’=ğ‘£ğ‘–

ğ‘šğ‘¦ğ´ğ‘£ğ‘ğ‘–ğ‘™ğµğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’+=ğ‘£ğ‘–

totallyOrder(PAY, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„)

totallyOrder(PAY, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„)

For members of committee ğ‘Š (ğ‘ƒğ‘–, ğ‘ƒğ‘–+1):

totallyOrder(SUCCESS, ğ¼ğ‘‘, ğ‘£ğ‘–+1, ğ‘ğ‘ğ‘¡â„)

if ğ¼ğ‘‘ â‰¥ğ‘›ğ‘’ğ‘¥ğ‘¡ğ¼ğ‘‘ (ğ‘ğ‘ğ‘¡â„ [0]) then // discard invalid Ids

ğ‘šğ‘¦ğ´ğ‘£ğ‘ğ‘–ğ‘™ğµğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’ = ğ‘šğ‘¦ğµğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’ = ğ‘£
ğ¼ğ‘‘ = 0

ğ‘ğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’ (ğ‘ƒğ‘– ) = ğ‘ğ‘£ğ‘ğ‘–ğ‘™ğµğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’ (ğ‘ƒğ‘– ) = ğ‘£
ğ‘›ğ‘’ğ‘¥ğ‘¡ğ¼ğ‘‘ (ğ‘ƒğ‘– ) = 0

ğ‘ğ‘ğ‘¡â„ = findPathTo(ğ‘‘ğ‘’ğ‘ ğ‘¡ )
ğ‘šğ‘¦ğ´ğ‘£ğ‘ğ‘–ğ‘™ğµğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’âˆ’=ğ‘£0
send(ğ‘ƒğ´ğ‘Œ , ğ¼ğ‘‘++, ğ‘£, ğ‘ğ‘ğ‘¡â„) to ğ‘Š (ğ‘ƒ0, ğ‘ƒ1)

1:
2: function initChannel(Amount ğ‘£)
3:
4:
5:
6: function pay(Node dest, Amount ğ‘£0) // Only for ğ‘ƒ0
7:
8:
9:
10:
11: upon rcv ğ‘“ +1 (REJECT, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„) from ğ‘Š (ğ‘ƒğ‘–, ğ‘ƒğ‘–+1) do
12:
13:
14: upon rcv ğ‘“ +1 (SUCCESS, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„) from ğ‘Š (ğ‘ƒğ‘–, ğ‘ƒğ‘–+1) do
15:
16:
17:
18: function initChannel(Amount ğ‘£)
19:
20:
21:
22: upon rcv (PAY, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„) from ğ‘ƒğ‘– do
23:
24:
25:
26: upon rcv ğ‘“ +1 (PAY, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„) from ğ‘Š (ğ‘ƒğ‘–âˆ’1, ğ‘ƒğ‘– ) do
27:
28:
29: upon rcv ğ‘“ +1 (SUCCESS, ğ¼ğ‘‘, ğ‘£ğ‘–+1, ğ‘ğ‘ğ‘¡â„) from ğ‘Š (ğ‘ƒğ‘–+1, ğ‘ƒğ‘–+2) do
30:
31:
32: upon rcv ğ‘“ +1 (REJECT, ğ¼ğ‘‘, ğ‘£ğ‘–+1, ğ‘ğ‘ğ‘¡â„) from ğ‘Š (ğ‘ƒğ‘–+1, ğ‘ƒğ‘–+2) do
33:
34:
35: upon (PAY, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„) ordered and ğ‘›ğ‘’ğ‘¥ğ‘¡ğ¼ğ‘‘ (ğ‘ğ‘ğ‘¡â„ [0])==ğ¼ğ‘‘ do
36:
37:
38:
39:
40:
41:
42:
43:
44:
45:
46:
47:
48:
49:
50:
51:
52:
53:
54: upon (REJECT, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„) ordered and being processed do
55:
56:
57:
58:
59:
60:
61: upon (SUCCESS, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„) ordered and being processed do
62:
63:
64:
65:

ğ‘›ğ‘’ğ‘¥ğ‘¡ğ¼ğ‘‘ (ğ‘ğ‘ğ‘¡â„ [0])++
if ğ‘ğ‘£ğ‘ğ‘–ğ‘™ğµğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’ (ğ‘ƒğ‘– ) â‰¥ ğ‘£ğ‘– then
ğ‘ğ‘£ğ‘ğ‘–ğ‘™ğµğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’ (ğ‘ƒğ‘– )âˆ’=ğ‘£ğ‘–
if ğ‘ğ‘ğ‘¡â„ [âˆ’1] == ğ‘ƒğ‘–+1 then // last committee

ğ‘ğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’ (ğ‘ƒğ‘– )-=ğ‘£ğ‘–
if ğ‘ƒğ‘– has predecessor ğ‘ƒğ‘–âˆ’1 in ğ‘ğ‘ğ‘¡â„ then

ğ‘ğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’ (ğ‘ƒğ‘– )âˆ’=ğ‘£ğ‘–
if ğ‘ƒğ‘– has predecessor ğ‘ƒğ‘–âˆ’1 in ğ‘ğ‘ğ‘¡â„ then

Inform ğ‘ƒğ‘– and ğ‘ƒğ‘–+1 of new balance
else // transfer to next committee

send(SUCCESS, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„) to ğ‘Š (ğ‘ƒğ‘–âˆ’1, ğ‘ƒğ‘– )

send(SUCCESS, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„) to ğ‘Š (ğ‘ƒğ‘–âˆ’1, ğ‘ƒğ‘– )

ğ‘ğ‘£ğ‘ğ‘–ğ‘™ğµğ‘ğ‘™ğ‘ğ‘›ğ‘ğ‘’ (ğ‘ƒğ‘– )+=ğ‘£ğ‘–
if ğ‘ƒğ‘– ==ğ‘ğ‘ğ‘¡â„ [0] then

send(REJECT, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„) to ğ‘Š (ğ‘ƒğ‘–âˆ’1, ğ‘ƒğ‘– )

send(REJECT, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„) to ğ‘Š (ğ‘ƒğ‘–âˆ’1, ğ‘ƒğ‘– )

send(PAY, ğ¼ğ‘‘, ğ‘£ğ‘–+1, ğ‘ğ‘ğ‘¡â„) to ğ‘Š (ğ‘ƒğ‘–+1, ğ‘ƒğ‘–+2)

if ğ‘ƒğ‘– has predecessor ğ‘ƒğ‘–âˆ’1 in ğ‘ğ‘ğ‘¡â„ then

totallyOrder(REJECT, ğ¼ğ‘‘, ğ‘£ğ‘–+1, ğ‘ğ‘ğ‘¡â„)

send(SUCCESS, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„) to ğ‘ƒğ‘–

send(REJECT, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„) to ğ‘ƒğ‘–

send(REJECT, ğ¼ğ‘‘, ğ‘£ğ‘–, ğ‘ğ‘ğ‘¡â„) to ğ‘ƒğ‘–

else // insufficient balance

inform ğ‘ƒğ‘– and ğ‘ƒğ‘–+1 of new balance

else

else

else

OÄŸuzhan Ersoy, JÃ©rÃ©mie Decouchant, Satwik Prabhu Kumble, and Stefanie Roos

After determining the amount and path, the sender ğ‘ƒ0 informs
the committee ğ‘Š (ğ‘ƒ0, ğ‘ƒ1) of the first channel on the path that they
intend to make a payment using a signed message that includes
their local monotonically increasing payment Id, the amount, and
the subsequent path (Lines 6â€“9 in Alg. 1, and message 1 in Fig. 2).
The committee ğ‘Š (ğ‘ƒ0, ğ‘ƒ1) then processes the payment request
(Lines 22â€“24). More precisely, the payment is added to a pool of
payment requests that are then totally ordered by the committee
members. Note that payments are not ordered according to any
particular criteria so that all payments have an equal chance of being
executed. After a payment request has been ordered, the committee
checks if i) it has the payment Id the committee is expecting from
the payment sender and ii) the channel has enough balance. If so, all
honest members decrease the available balance of ğ‘ƒ0 by the amount
of the payment. They send a signed message to the next committee
informing them that the payment has been marked as locked and
include the payment Id, the amount, and the path (Lines 35â€“53,
msg. 3 in Fig. 2). They also inform ğ‘ƒ0 and ğ‘ƒ1 that the amount of the
payment has been locked on the channel (msg. 2, Fig. 2).

Once a committee ğ‘Š (ğ‘ƒğ‘–, ğ‘ƒğ‘–+1) has received at least ğ‘“ +1 PAY
messages from members of the previous committee, the payment is
added to the local pool of payment requests of the committee, and
is eventually totally ordered (Lines 26â€“28). Once the payment has
been ordered and is the next payment generated by the payment
sender, committee members check whether the channel has enough
balance to transfer the amount. If so, they lock the amount (in the
full protocol, a committee uses a different monotonically increasing
payment counter as an Id to transfer a payment to another commit-
tee). Last, they send a PAY message to the next committee (msgs. 3
and 5 in Fig. 2).

To complete our explanation of the first (locking) phase, it re-
mains to consider the case when ğ‘ƒğ‘–+1 is the receiver. In this case,
ğ‘Š (ğ‘ƒğ‘–, ğ‘ƒğ‘–+1) does not need to wait for a further committee to de-
cide on the payment. They can simply declare the payment done
and inform ğ‘ƒğ‘–+1 as well as a previous committee (if it exists) that
the payment is completed (msgs. 6 and 7 in Fig. 2). The process is
described in Lines 39â€“45.

In the second phase, upon receiving ğ‘“ +1 SUCCESS messages
from the subsequent committee indicating that the payment has
been completed, committee members totally order the SUCCESS
message, update the balance of the two parties and send a SUCCESS
message to the previous committee if it exists (Lines 61â€“65, msg.
9 in Fig. 2). Upon receiving a SUCCESS message, committees can
inform the parties (msgs. 8 and 10, Fig. 2). Rejected payments are
also processed with total order and transmitted to the previous
committee (Lines 54â€“59). However, if a payment is rejected, only
the payment sender is informed since they can then attempt to use
a different path in the payment channel network if it exists. The
other intermediaries are also informed so that they know that the
funds are unlocked and can be used for other transactions.

Committee members and parties do not limit the time a payment
can take. They trust subsequent committees to inform them if a
payment is validated or rejected. The last channel on a payment
path does not use the locked state since it can directly approve or
reject a payment.

5.3 Security and Privacy Analysis
PSyncPCN does not provide privacy properties since the channels
are controlled by BFT committees. In the following, we show that
PSyncPCN satisfies the security properties, namely, atomicity and
coin availability. We omit the proof of correctness property.

10

SyncPCN/PSyncPCN: Payment Channel Networks without Blockchain Synchrony

Table 1: Network latencies and expected message complexi-
ties of a ğ‘˜-hop payment with committees of size ğ‘›.

Msg complexity
8ğ‘›ğ‘˜ + 3ğ‘˜ + 2
(2ğ‘˜âˆ’1)(2ğ‘›+ğ¶ğ‘šğ‘ ğ‘” (ğ‘›)+1)

SyncPCN
PSyncPCN
PSyncPCN (w. [10]) Î˜(4ğ‘˜ğ‘›2)
PSyncPCN (w. [51]) Î˜(18ğ‘˜ğ‘›)

Latency
(8ğ‘˜ + 2)ğ›¿
2ğ‘˜ğ¶ğ‘™ğ‘ğ‘¡ (ğ‘›)+2ğ›¿
Î˜(6ğ‘˜ğ›¿)
Î˜(16ğ‘˜ğ›¿)

Theorem 15. PSyncPCN provides atomicity.

Proof Sketch. If ğ‘ƒğ‘– pays in ğ›¾ğ‘– , it means that 2ğ‘“ +1 members of
the associated committee voted to totally order the payment and
execute it. At least ğ‘“ +1 correct members of this quorum send a
SUCCESS message with the payment Id to the committee members
of ğ›¾ğ‘–âˆ’1. Upon receiving ğ‘“ +1 SUCCESS messages, the correct com-
mittee members of ğ›¾ğ‘–âˆ’1 update ğ‘ƒğ‘– â€™s balance. Since all committees
tolerate ğ‘“ faulty members, the SUCCESS message is sent (starting
from the receiver) if all channels have enough balance, otherwise,
the locked channels are revoked using REJECT messages. In other
words, ğ‘ƒ0 only pays after all intermediaries have paid and the re-
ceiver ğ‘ƒğ‘˜ has been paid by ğ‘ƒğ‘˜âˆ’1. Therefore, all channels pay or
none do. Furthermore, there is no scenario where ğ›¾ğ‘– is not paid, but
â–¡
ğ›¾ğ›¼ and ğ›¾ğ›½ are paid where ğ›¼ <ğ‘–<ğ›½.

Theorem 16. PSyncPCN provides coin availability.

Proof Sketch. A payment that does not terminate remains in
state locked forever. By assumption, messages are eventually de-
livered, which means that such a payment is stalled by a committee
that does not send ğ‘“ +1 PAY messages to the next committee, or
ğ‘“ +1 SUCCESS or REJECT to the previous committee. However,
all committees contain at least 2ğ‘“ +1 honest members who upon
delivering messages from the previous or next committee react
accordingly. Due to the use of total order broadcast, the honest
committee members of the committee eventually all agree on the
state of a channel as they update it with the same messages and in
the same order. Thus, at least 2ğ‘“ +1 members eventually vote on a
payment and provide sufficient signatures to allow a payment to
â–¡
eventually terminate.

6 DISCUSSION AND COMPARISON
This section discusses how committee members are incentivized
to behave honestly. It then discusses the complexity and latency
of our two protocols. Last, it compares their security and privacy
properties to those of other payment channel networks.

6.1 Incentives
We have so far considered honest and malicious parties/committee
members. In contrast, Brick has three incentives to ensure that
rational parties follow the protocol. First, committee members are
incentivized to sign updates. To do so, members are paid an update
fee by the channel parties upfront to sign a channel update and
a channel party waits for 2ğ‘“ +1 signatures to confirm the update.
It may be argued that a committee member could simply collect
the update fee and not sign the update. However, channel parties

avoid such committee members for future updates and thus de-
crease their long-term expected rewards, meaning that rational
parties indeed sign the update. Second, it prevents rational com-
mittee members from misbehaving, e.g., by submitting an invalid
state during closure. During channel opening, committee members
deposit a collateral (at least equal to ğ¶/ğ‘“ , where ğ¶ is the channel
capacity) that remains locked until the channel is closed. If the
channel closes in the freshest state, then the collateral is returned
to committee members. However, if a channel party provides a
proof that a committee member misbehaved, then the collateral
is paid to the channel party. A malicious channel party may bribe
rational committee members to close in an invalid state. The bribe,
however, needs to be larger than the collateral locked by the com-
mittee member. The cost of such a bribe is proven to exceed the
capacity of the channel and hence is not beneficial for a channel
party. Thus, rational channel parties do not execute bribing attacks
and rational committee members only submit correct states. Third,
it incentivizes committee members to sign the closing transaction
promptly by paying a closing fee to the first 2ğ‘“ +1 signing committee
members.

These incentives can be directly included in our protocols so that
they would assume rational parties and committee members instead
of correct ones. It is also necessary to incentivize intermediaries to
forward a payment, even if they have to pay update fees to their
committee members. We can leverage the fee mechanism used
in Lightning, where intermediaries receive a fee upon successful
completion of a payment, but need to ensure that the average fee
of the intermediary exceeds the fee paid for the channel update.
Let ğ‘ğ‘† be the approximated success probability of payments (based
on previous payments) and ğ‘“ğ‘– be the fee of an intermediary ğ‘ƒğ‘– . The
expected earned fee is then ğ‘“ğ‘– Â·ğ‘ğ‘† . Note that multi-hop payments
require two updates and for each update the channel party has to
pay the update fee ğ‘“ğ¶ğ‘€ to all 3ğ‘“ +1 committee members to receive
2ğ‘“ +1 signatures in the worst case. For rational intermediaries to
forward a payment, we need ğ‘“ğ‘– Â·ğ‘ğ‘† >2(3ğ‘“ + 1)ğ‘“ğ¶ğ‘€ .

6.2 Message Complexity and Latency
Table 1 summarizes the analytical network latency and message
complexity of SyncPCN and PSyncPCN. The complexities of PSyncPCN
are evaluated under the assumption that the system is in the syn-
chronous phase of a partially synchronous network, i.e., during the
phase in which progress can be made. ğ¶ğ‘™ğ‘ğ‘¡ (ğ‘›) and ğ¶ğ‘šğ‘ ğ‘” (ğ‘›) denote
the expected network latency and msg complexity, respectively,
of the underlying total order broadcast for a committee of size ğ‘›.
Potential realizations are PBFT [10] and HotStuff [51]. Assuming
synchronous networks allow SyncPCN to have lower message com-
plexity and latency than PSyncPCN. The performance of PSyncPCN
heavily depends on the total order broadcast protocol used. With
PBFT [10], the bandwidth usage is higher than with HotStuff [51].
Inversely, the expected latency of PSyncPCN is lower with PBFT
than with HotStuff.

6.3 Comparison of Payment Channel Networks
Several protocols have considered reducing the locked time of coins
in Lightning [38], improve the payment path privacy [37], mini-
mize the communication rounds [4], and increase the efficiency of

11

OÄŸuzhan Ersoy, JÃ©rÃ©mie Decouchant, Satwik Prabhu Kumble, and Stefanie Roos

Table 2: Comparison of Payment Channel (Networks). BS&C&CA is balance security, correctness and coin availability, R. Anon.
refers to relationship anonymity, Par. Sync. is partial synchrony, and L. and G, resp. denote local and global.

Ref.

[48]
[37]
[19]
[4]
[38]

[35]
[6]

Â§ 4
Â§ 5

Protocol Multi-hop
Payment
âœ“
âœ“
âœ“
âœ“
âœ“

Lightning
AMHL
Perun
Blitz
Sprites

Synchrony
Blockchain Network
Synchronous
Synchronous
Synchronous
Synchronous
Synchronous

Secured by
HTLC
AMHL
Smart Contract
Pay-or-revoke
Smart Contract

Teechain
Brick

SyncPCN
PSyncPCN

âœ“
âœ—

âœ“
âœ“

Async.

Par. Sync.

Asynchronous

TEE
L. Committee

Async.
Async.

Sync.
Par. Sync.

L. Com. & AMHL
G. Committee

Security

Privacy

BS&C&CA Atomicity Value

Endpoint R. Anon.

âœ“
âœ“
âœ“
âœ“
âœ“

âœ“
NA

âœ“
âœ“

âœ—
âœ“
âœ“
âœ“
âœ“

âœ“
NA

âœ“
âœ“

âœ“
âœ“
âœ“
âœ“
âœ“

âœ“
NA

âœ“
âœ—

âœ“
âœ“
âœ—
âœ“
âœ—

âœ“
NA

âœ“
âœ—

âœ—
âœ“
âœ—
âœ—
âœ—

âœ“
NA

âœ“
âœ—

multi-hop payments [19]. However, the security of these protocols
relies on blockchain synchrony. Teechain [35] is the only multi-hop
payment protocol that supports partial synchrony thanks to TEEs.
Table 2 summarizes our analysis and considers multi-hop pay-
ment support, synchrony assumptions (for the blockchain and the
network), as well as the security and privacy properties we defined
in Section 2.5. These properties apply to multi-hop payments, but
we also compare to Brick [6] and use NA (not applicable) for it. For
security, we combine the basic security properties, balance security,
correctness, and coin availability, that are satisfied by all of the
protocols.

With regard to atomicity, Blitz [4] uses a common revocation
transaction to prevent the wormhole attack where some intermedi-
aries are skipped during a successful payment. Similarly, the global
manager in Sprites [38] ensures that every intermediary receives
the preimage and updates its channel. Perun [19] guarantees atom-
icity because payments involve the endpoints of virtual channels
and intermediaries do not explicitly participate. SyncPCN adapts
mechanisms from AMHL [37], whereas PSyncPCN assumes BFT
committees. One might consider providing incentives against the
attack as an alternative protection against rational behaviors.

We consider value privacy, endpoint privacy, and relationship
anonymity in the absence of side channel attacks. Our second proto-
col, PSyncPCN, does not provide any privacy since the committees
control the channels. They see the payment values and the commit-
tee of the receiver is aware of its identity. The authors of Sprites state
that their model does not provide privacy guarantees, though they
do not reveal the payment value and hence achieve value privacy.
Thereby, our analysis focuses on the rest of the protocols. Value
privacy is about hiding the payment amount from outsiders, and it
is satisfied by all protocols except PSyncPCN. Endpoint privacy can
be achieved by onion routing, which hides the sender and receiver
from the intermediaries. Lightning, AMHL, and Blitz all use onion
routing. Since the virtual channel construction in Perun reveals the
endpoints to the intermediary parties, endpoint privacy and thereby
relationship anonymity are not satisfied. Relationship anonymity
simply implies that non-connected intermediary parties should
not know if they are part of the same payment or not. Lightning
and Blitz do not satisfy this property because of the common hash
and revocation transaction shared by all channels in the payment

12

path. SyncPCN and AMHL protocols satisfy this property using the
additive hash construction, which was initially proposed in [36].
Finally, Teechain [35] also satisfies the privacy properties under
the assumption that TEEs do not collude and leak any information
about the payments, e.g., due to side channel attacks [9, 50].

7 CONCLUSION
In this paper, we have demonstrated that it is impossible to design
a multi-hop payment protocol assuming both network asynchrony
and faulty channels. We then showed that network synchrony or
correct channels allow the design of a multi-hop payment protocol
by presenting one protocol for each case. We detailed two different
committee-based multi-hop payment protocols that assume syn-
chronous communications and possibly faulty channels, or asyn-
chronous communication and correct channels, respectively. Our
protocols do not require blockchain synchrony to solve disputes
among parties. SyncPCN tolerates faulty committee and assumes
synchronous communications. PSyncPCN relies on BFT committees
that totally order payment requests, which can be implemented
using several recent consensus protocols depending on the syn-
chrony model one assumes, and trust each other to eventually
process a payment. Because it has stronger synchrony assumptions,
SyncPCN generates fewer messages and has lower latency than
PSyncPCN. In future work, we will consider using virtual channels
in PSyncPCN, which could allow committees to leverage reliable
and consistent broadcast in multi-hop payments instead of total
order broadcast. We will also work on adding privacy guarantees to
PSyncPCN. Furthermore, we want to design a version of PSyncPCN
using an accountable BFT protocol [12] to deal with committees
with more than ğ‘“ fulty nodes.

REFERENCES
[1] 1ml.com. 2021. Real-Time Lightning Network Statistics. Available at: https:

//1ml.com/statistics.

[2] N. Asokan, Victor Shoup, and Michael Waidner. 1998. Asynchronous Protocols

for Optimistic Fair Exchange. In S&P.

[3] Lukas Aumayr, Matteo Maffei, Oguzhan Ersoy, Andreas Erwig, Sebastian Faust,
Siavash Riahi, Kristina HostÃ¡kovÃ¡, and Pedro Moreno-Sanchez. 2021. Bitcoin-
Compatible Virtual Channels. In IEEE S&P.

[4] Lukas Aumayr, Pedro Moreno-Sanchez, Aniket Kate, and Matteo Maffei. 2021.
Blitz: Secure Multi-Hop Payments Without Two-Phase Commits. In USENIX
Security.

SyncPCN/PSyncPCN: Payment Channel Networks without Blockchain Synchrony

[5] Alex Auvolat, Davide Frey, Michel Raynal, and FranÃ§ois TaÃ¯ani. 2020. Money
transfer made simple: a specification, a generic algorithm, and its proof. arXiv
preprint arXiv:2006.12276 (2020).

[6] Georgia Avarikioti, Eleftherios Kokoris Kogias, Roger Wattenhofer, and Dionysis

Zindros. 2021. Brick: Asynchronous Payment Channels. FC.

[7] Edward Bortnikov, Maxim Gurevich, Idit Keidar, Gabriel Kliot, and Alexander
Shraer. 2009. Brahms: Byzantine resilient random membership sampling. Com-
puter Networks 53, 13 (2009), 2340â€“2359.

[8] Gabriel Bracha and Sam Toueg. 1985. Asynchronous consensus and broadcast

protocols. JACM 32, 4 (1985), 824â€“840.

[9] Ferdinand Brasser, Urs MÃ¼ller, Alexandra Dmitrienko, Kari Kostiainen, Srdjan
Capkun, and Ahmad-Reza Sadeghi. 2017. Software Grand Exposure:{ğ‘†ğºğ‘‹ }
Cache Attacks Are Practical. In WOOT.

[10] Miguel Castro, Barbara Liskov, et al. 1999. Practical byzantine fault tolerance. In

OSDI, Vol. 99. 173â€“186.

[11] Tushar Deepak Chandra, Vassos Hadzilacos, and Sam Toueg. 1996. The weakest

failure detector for solving consensus. JACM 43, 4 (1996), 685â€“722.

[12] Pierre Civit, Seth Gilbert, and Vincent Gramoli. 2021. Polygraph: Accountable
byzantine agreement. In 2021 IEEE 41st International Conference on Distributed
Computing Systems (ICDCS). IEEE, 403â€“413.

[13] Daniel Collins, Rachid Guerraoui, Jovan Komatovic, Petr Kuznetsov, Matteo
Monti, Matej Pavlovic, Yvonne-Anne Pignolet, Dragos-Adrian Seredinschi, Andrei
Tonkikh, and Athanasios Xygkis. 2020. Online payments by merely broadcasting
messages. In 2020 50th Annual IEEE/IFIP International Conference on Dependable
Systems and Networks (DSN). IEEE, 26â€“38.

[14] George Danezis and Ian Goldberg. 2009. Sphinx: A compact and provably secure

mix format. In S&P.

[15] Christian Decker and Roger Wattenhofer. 2015. A fast and scalable payment

network with bitcoin duplex micropayment channels. In SSS.

[16] JÃ©rÃ©mie Decouchant, David Kozhaya, Vincent Rahli, and Jiangshan Yu. 2022.
DAMYSUS: streamlined BFT consensus leveraging trusted components. In Eu-
roSys. 1â€“16.

[17] Thaddeus Dryja and Scaling Bitcoin Milano. 2016. Unlinkable outsourced channel

monitoring. Scaling Bitcoin Milan (2016).

[18] Stefan Dziembowski, Lisa Eckey, Sebastian Faust, Julia Hesse, and Kristina

HostÃ¡kovÃ¡. 2019. Multi-party Virtual State Channels. In Eurocrypt.

[19] Stefan Dziembowski, Lisa Eckey, Sebastian Faust, and Daniel Malinowski. 2019.

Perun: Virtual Payment Hubs over Cryptocurrencies. In IEEE S&P.

[20] Lisa Eckey, Sebastian Faust, Kristina HostÃ¡kovÃ¡, and Stefanie Roos. 2020. Splitting
Payments Locally While Routing Interdimensionally. Cryptol. ePrint Arch. (2020).
[21] Michael J Fischer, Nancy A Lynch, and Michael S Paterson. 1985. Impossibility
of distributed consensus with one faulty process. JACM 32, 2 (1985), 374â€“382.

[22] David Galindo, Jia Liu, Mihair Ordean, and Jin-Mann Wong. 2021. Fully Dis-
tributed Verifiable Random Functions and their Application to Decentralised
Random Beacons. In EuroS&P.

[23] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. 2015. The bitcoin backbone
protocol: Analysis and applications. In Annual international conference on the
theory and applications of cryptographic techniques. 281â€“310.

[24] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zeldovich.
2017. Algorand: Scaling Byzantine Agreements for Cryptocurrencies. In SOSP.
[25] Lewis Gudgeon, Pedro Moreno-Sanchez, Stefanie Roos, Patrick McCorry, and

Arthur Gervais. 2020. Sok: Layer-two blockchain protocols. In FC.

[26] Rachid Guerraoui, Petr Kuznetsov, Matteo Monti, Matej PavloviÄ, and Dragos-
Adrian Seredinschi. 2019. The consensus number of a cryptocurrency. In Pro-
ceedings of the 2019 ACM Symposium on Principles of Distributed Computing.
307â€“316.

[27] Saurabh Gupta. 2016. A non-consensus based decentralized financial transaction
processing model with support for efficient auditing. Arizona State University.
[28] Abdelatif Hafid, Abdelhakim Senhaji Hafid, and Mustapha Samih. 2019. New
Mathematical Model to Analyze Security of Sharding-Based Blockchain Protocols.
IEEE Access 7 (2019), 185447â€“185457.

[29] Jona Harris and Aviv Zohar. 2020. Flood & loot: A systemic attack on the lightning

network. In ACM AFT.

[30] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. 2017.

Ouroboros: A Provably Secure Proof-of-Stake Blockchain Protocol. In Crypto.

[31] Eleftherios Kokoris Kogias, Dahlia Malkhi, and Alexander Spiegelman. 2020.
Asynchronous Distributed Key Generation for Computationally-Secure Random-
ness, Consensus, and Threshold Signatures.. In CCS.

[32] David Kozhaya, JÃ©rÃ©mie Decouchant, and Paulo Esteves-Verissimo. 2018. RT-
ByzCast: Byzantine-resilient real-time reliable broadcast. IEEE Trans. Comput.
68, 3 (2018), 440â€“454.

[33] David Kozhaya, JÃ©rÃ©mie Decouchant, Vincent Rahli, and Paulo Esteves-Verissimo.
2021. PISTIS: An Event-Triggered Real-Time Byzantine-Resilient Protocol Suite.
IEEE Transactions on Parallel and Distributed Systems 32, 9 (2021), 2277â€“2290.
[34] Satwik Prabhu Kumble, Dick Epema, and Stefanie Roos. 2021. How Lightningâ€™s

Routing Diminishes its Anonymity. In ARES.

[35] Joshua Lind, Oded Naor, Ittay Eyal, Florian Kelbert, Emin GÃ¼n Sirer, and Pe-
ter R. Pietzuch. 2019. Teechain: a secure payment network with asynchronous

13

blockchain access. In SOSP.

[36] Giulio Malavolta, Pedro Moreno-Sanchez, Aniket Kate, Matteo Maffei, and Sri-
vatsan Ravi. 2017. Concurrency and Privacy with Payment-Channel Networks.
In CCS.

[37] Giulio Malavolta, Pedro Moreno-Sanchez, Clara Schneidewind, Aniket Kate, and
Matteo Maffei. 2019. Anonymous Multi-Hop Locks for Blockchain Scalability
and Interoperability. In NDSS.

[38] Andrew Miller, Iddo Bentov, Surya Bakshi, Ranjit Kumaresan, and Patrick Mc-
Corry. 2019. Sprites and State Channels: Payment Networks that Go Faster Than
Lightning. In FC.

[39] Ayelet Mizrahi and Aviv Zohar. 2020. Congestion attacks in payment channel

networks. arXiv preprint arXiv:2002.06564 (2020).

[40] Pedro Moreno-Sanchez, Aniket Kate, and Matteo Maffei. 2018. Silentwhispers:
Enforcing security and privacy in decentralized credit networks. In NDSS.
[41] Achour MostÃ©faoui, Hamouma Moumen, and Michel Raynal. 2015. Signature-free
asynchronous binary Byzantine consensus with t< n/3, O (n2) messages, and O
(1) expected time. JACM 62, 4 (2015), 1â€“21.

[42] Oded Naor and Idit Keidar. 2022. On Payment Channels in Asynchronous Money

Transfer Systems. CoRR abs/2202.06693 (2022).

[43] Raiden Network. 2022. Raiden network. Retrieved 31/01/2022 from https://raiden.

network/

[44] Utz Nisslmueller, Klaus-Tycho Foerster, Stefan Schmid, and Christian Decker.
2020. Toward active and passive confidentiality attacks on cryptocurrency off-
chain networks. arXiv preprint arXiv:2003.00003 (2020).

[45] Henning Pagnia and Felix C GÃ¤rtner. 1999. On the impossibility of fair exchange

without a trusted third party. Technical Report. TU Darmstadt.

[46] Rafael Pass, Lior Seeman, and Abhi Shelat. 2017. Analysis of the Blockchain

Protocol in Asynchronous Networks. In Eurocrypt.

[47] Jordan Pearson. 2015. WikiLeaks Is Now a Target In the Massive Spam Attack
on Bitcoin. Available at: https://www.vice.com/en/article/ezvw7z /wikileaks-is-
now-a-target-in-the-massive-spam-attack-on-bitcoin.

[48] Joseph Poon and Thaddeus Dryja. 2016. The bitcoin lightning network: Scalable

off-chain instant payments.

[49] Michael K Reiter. 1994. Secure agreement protocols: Reliable and atomic group

multicast in Rampart. In CCS.

[50] Wenhao Wang, Guoxing Chen, Xiaorui Pan, Yinqian Zhang, XiaoFeng Wang,
Vincent Bindschaedler, Haixu Tang, and Carl A Gunter. 2017. Leaky cauldron
on the dark land: Understanding memory side-channel hazards in SGX. In Pro-
ceedings of the 2017 ACM SIGSAC Conference on Computer and Communications
Security. 2421â€“2434.

[51] Maofan Yin, Dahlia Malkhi, Michael K Reiter, Guy Golan Gueta, and Ittai Abra-
ham. 2019. HotStuff: BFT consensus with linearity and responsiveness. In PODC.
[52] Joseph Young. 2017. Analyst: Suspicious Bitcoin Mempool Activity, Transaction
Fees Spike to 16. Available at: https://cointelegraph.com/news/analyst-suspicious-
bitcoin-mempool-activity-transaction-fees-spike-to-16.

[53] Jiangshan Yu, David Kozhaya, JÃ©rÃ©mie Decouchant, and Paulo Esteves-Verissimo.
2019. Repucoin: Your reputation is your power. IEEE Trans. Comput. 68, 8 (2019),
1225â€“1237.

[54] Alexei Zamyatin, Mustafa Al-Bassam, Dionysis Zindros, Eleftherios Kokoris-
Kogias, Pedro Moreno-Sanchez, Aggelos Kiayias, and William J Knottenbelt.
2019. SoK: communication across distributed ledgers. Cryptology ePrint Archive
(2019).

A COMMITTEE FORMATION IN PSYNCPCN
We assume that there is a global committee with ğ‘ members from
which a smaller committee of size ğ‘› is sampled during the channel
opening to be the channel committee. The channel committee mem-
bers can be selected randomly from the global committee based on
any of a number of recent peer selection methods [7, 22, 24, 30],
which guarantee unbiased uniform selection and termination of
the selection protocol. Assuming that the global committee has
ğ¹ faulty members, we can compute the probability ğ‘ƒğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡ for a
correct committee (ğ‘“ â‰¤ âŒŠğ‘›/3âŒ‹)) to be selected. The probability ğ‘ ğ‘“
that the selected committee has ğ‘“ faulty members follows a hyper-

geometric distribution [28] and is equal to
ğ‘ƒğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡ = (cid:205) âŒŠğ‘›/3âŒ‹
ğ‘ ğ‘“ . While selecting a bigger channel committee
ğ‘“ =1
does increase the likelihood of the committee to be correct, a bigger
channel committee also implies higher latency and bandwidth use.

. It follows that

ğ‘“ ) Â·(ğ‘ âˆ’ğ¹
(ğ¹
ğ‘›âˆ’ğ‘“ )
(ğ‘
ğ‘› )

Fig. 3 indicates the probability for a sampled channel commit-
tee to contain more than ğ‘“ faulty members. For this figure, we
assume a global committee of size ğ‘ = 1200, and vary the value of
ğ¹ âˆˆ [300, 325, 350, 375, 400, 425, 450]. One can observe that ğ‘ƒğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡
increases with ğ‘› when ğ¹ < ğ‘ /3 and increases with ğ‘› when ğ¹ > ğ‘ /3.
For ğ‘ /3, it converges. When ğ¹ = ğ‘ /4, we see that ğ‘ƒğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡ is nearly
1 for all values of ğ‘›. As the value of ğ¹ moves closer to ğ‘ /3, a higher
value of ğ‘› is required for ğ‘ƒğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡ to approach 1.

The probabilities to sample a faulty committee of size 300 with
F being 300 and 325 are almost equal to 1, namely 0.999 and 0.998,
respectively. We therefore select committees of size 300 for our per-
formance evaluation, and assume a global committee that contains
less than one-fourth of faulty members.

Large BFT committees have limited performance when used in
blockchains to process the transactions of all users. In our protocols,
a committee handles the transactions of a single channel and is
therefore not expected to provide the same performance under high
workload as a blockchain consensus algorithm. There is a small
probability for a sampled committee to be faulty (i.e., contain more
than ğ‘“ faulty members).

OÄŸuzhan Ersoy, JÃ©rÃ©mie Decouchant, Satwik Prabhu Kumble, and Stefanie Roos

Figure 3: Probability of choosing a committee ğ‘ƒğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡ when
ğ‘ =1200. We plot the variation of ğ‘ƒğ‘ğ‘œğ‘Ÿğ‘Ÿğ‘’ğ‘ğ‘¡ with respect to ğ‘› for
each ğ¹ in the set [300, 325, 350, 375, 400, 425, 450].

14

0100200300400500600n0.00.20.40.60.81.0PcorrectF300 (N/4)325350375400 (N/3)425450