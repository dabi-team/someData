2
2
0
2

l
u
J

5
2

]

R
C
.
s
c
[

1
v
2
8
4
2
1
.
7
0
2
2
:
v
i
X
r
a

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

1

AGAPECert: An Auditable, Generalized, Automated,
Privacy-Enabling Certiﬁcation Framework
with Oblivious Smart Contracts

Servio Palacios1, Student Member, IEEE, Aaron Ault2, James V. Krogmeier2, Member, IEEE,
Bharat Bhargava1, Fellow, IEEE, and Christopher G. Brinton2, Senior Member, IEEE

Abstract—This paper introduces AGAPECert, an Auditable, Generalized, Automated, Privacy-Enabling, Certiﬁcation framework
capable of performing auditable computation on private data and reporting real-time aggregate certiﬁcation status without disclosing
underlying private data. AGAPECert utilizes a novel mix of trusted execution environments, blockchain technologies, and a real-time
graph-based API standard to provide automated, oblivious, and auditable certiﬁcation. Our technique allows a privacy-conscious data
owner to run pre-approved Oblivious Smart Contract code in their own environment on their own private data to produce Private
Automated Certiﬁcations. These certiﬁcations are veriﬁable, purely functional transformations of the available data, enabling a third
party to trust that the private data must have the necessary properties to produce the resulting certiﬁcation. Recently, a multitude of
solutions for certiﬁcation and traceability in supply chains have been proposed. These often suffer from signiﬁcant privacy issues
because they tend to take a "shared, replicated database" approach: every node in the network has access to a copy of all relevant
data and contract code to guarantee the integrity and reach consensus, even in the presence of malicious nodes. In these contexts of
certiﬁcations that require global coordination, AGAPECert can include a blockchain to guarantee ordering of events, while keeping a
core privacy model where private data is not shared outside of the data owner’s own platform. AGAPECert contributes an open-source
certiﬁcation framework that can be adopted in any regulated environment to keep sensitive data private while enabling a trusted
automated workﬂow.

Index Terms—Oblivious Smart Contract, Private Automated Certiﬁcation, Certiﬁcation, Supply Chain, Blockchain.

✦

1 INTRODUCTION

R ECENTLY, many solutions for certiﬁability and trace-

ability in supply chains using blockchain technologies
have risen to prominence . For example, to provide account-
ability and visibility in the food supply, blockchain solutions
exist such as IBM Food Trust [1], BeefChain [2], Lowry
Solution’s Sonaria platform [3], ripe.io [4], OriginTrail [5],
and SAP Blockchain Service [6], to name a few.

A component of many blockchain solutions is a smart
contract: a piece of code stored in the blockchain itself
that is run by all (or most of) the nodes in the chain in
response to some on-chain event: some data is added to
the blockchain computing nodes which triggers processing.
Nodes in the network have copies of the data and the code
and achieve data integrity by checking each other’s work.
This approach suffers from signiﬁcant privacy challenges
because data and smart contract code is replicated on all
nodes in the network [7] as a means to achieve varying
levels of Byzantine fault tolerance, i.e., malicious actors are
unable to affect data integrity.

Thus, some projects have proposed the use of trusted
execution environments in the chain to provide some level
of privacy-preserving computation [7] (§2.2). A trusted ex-

1
Computer Science Department, Purdue University, 305 N University St,
West Lafayette, IN, USA {spalacio,bbshail}@purdue.edu
2Electrical and Computer Engineering, Purdue University, 465 Northwestern
Ave, West Lafayette, IN, USA {ault,jvk,cgb}@purdue.edu

. ©2022 IEEE. Personal use of this material is permitted. Permission
from IEEE must be obtained for all other uses, in any current or future
media, including reprinting/republishing this material for advertising
or promotional purposes, creating new collective works, for resale or
redistribution to servers or lists, or reuse of any copyrighted component
of this work in other works.

ecution environment (TEE) is a private, integrity-protected,
and secure computation environment built into processor
hardware1 [8], [9]. For example, Intel SGX (Software Guard
Extensions) intends to supply conﬁdentiality and integrity
guarantees to computation run in environments where the
hypervisor (virtualized environments), operating system,
or the kernel are probably malicious/adversarial [9]. TEEs
were originally intended to provide a way to keep code and
data isolated from malicious actors in a shared platform,
and they have had questionable (§4.1) success toward that
goal thus far. However, AGAPECert’s trust model simply
requires that a TEE can produce cryptographically secure
guarantees about which code it ran, not that it isolates data
from the rest of its platform.

Brandenburger et al. contributed an open-source proof of
concept for TEEs within blockchain computation on top of
Hyperledger Fabric [7]. Another example using blockchain
and Intel SGX is SDTE [10], a data processing model im-
plemented on Ethereum. A more general framework is the
Conﬁdential Consortium Blockchain (COCO) that aims to
enable scalable and conﬁdential blockchain networks [11].
In all these solutions, the computation is on-chain,
i.e.,
replicated across nodes in the network.

In many of the real use cases requiring the privacy
provided by TEEs, participants are reluctant to provide even
encrypted versions of sensitive data to a public or permis-
sioned blockchain which would preserve the encrypted data
immutably, thus giving attackers an enormous time-based

1. Throughout the rest of this paper, we use the terms TEE, enclave,

and trusted black box interchangeably.

 
 
 
 
 
 
JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

2

attack surface to ﬁnd exploits in encryption key manage-
ment.

In this paper, we address these challenges by developing
AGAPECert, which leverages privacy-preserving compu-
tation via TEEs but allows the TEEs to run in environ-
ments controlled by the data owner rather than on-chain.
AGAPECert abstains from sending data to a public or even
private blockchain network and applies restrictions to the
code that runs inside enclaves: the code or algorithm that
runs on the private data must be pre-approved by both data
owner and regulator.

Next, we more formally deﬁne the problem that
AGAPEcert is designed to solve, and then overview the
technology we develop in the rest of this paper.

1.1 Problem Deﬁnition

Fig. 1a illustrates a common user activity that we call a trust
transformation. A regulator such as the Internal Revenue
Service (IRS), an environmental agency, or even a down-
stream purchaser of a product has a form that the individual
or company being regulated needs to ﬁll out. This form
contains a request for information that is derived from other
sources. The source data is generally considered private by
the data owner, and therefore is not submitted directly to
the regulator. The transformation of the source data into
the ﬁelds on the regulator’s form can be considered a trust
transformation from more private, ﬁne-grained data to less
private, coarse-grained data.

When the regulator has cause for increased scrutiny,
such as an IRS audit or a “surprise” inspection, there is
typically a need to reproduce the private source data and re-
execute the process of the trust transformation under threat
of legal action; however, this time under the supervision
of the regulator or an independent third party. The source
data presented under audit conditions should be veriﬁable
as the same data that produced the responses in the original
form. The auditor often has little means of verifying that the
data provided by the data owner is correct. Instead, the data
owner would typically sign some legal document attesting
that the data they have provided is correct to the best of
his/her knowledge2.

The goal of AGAPECert is to enable the trusted service
provider or data owner that performs the trust transforma-
tion in Fig. 1a to be replaced or augmented with code agreed
upon by both the regulator and the data owner as shown in
Fig. 1b. This automates the process of data-centric certiﬁca-
tion. This process must not infringe on existing models for
trust transformation that society already understands and
uses, as outlined below.

1.2 Design Principles

The following features must be supported in order for
AGAPECert to ﬁt most existing certiﬁcation processes [12],
[13], [14], [15], [16], [17]:

1) The data owner should be conﬁdent that private
data will not be released to the regulator, even in
encrypted (but decryptable) form.

(a)

(b)

Fig. 1: (a) Illustration of common model of trust transfor-
mation. A person or their trusted agent will ﬁll out a form
for a regulator using private, ﬁne-grained source data that
they transform into the ﬁelds on the regulator’s form. (b)
AGAPECert replaces or augments the service provider or
data owner with a piece of software code agreed upon by
both the regulator and the data owner, thus automating the
certiﬁcation process.

2) The data owner should be able to run the code to
ﬁll out the regulator’s form as often as they like
internally without notifying the regulator.

3) The regulator must be able to verify that the private
data has not changed in the event of a subsequent
audit under threat of legal action.

4) The regulator should learn nothing more about
the data owner’s information or business processes
other than the exact features of the ﬁlled-out form.
In some cases (§1.4, Trust Level 2 and 3), the regu-
lator should be able to conﬁrm that the appropriate
code was run without requiring a full audit.

5)

6) The process need not verify the private data beyond
a legal assertion by the data owner that the data
is correct. However, the process may enable better
trust requirements around the integrity of private
source data.

This functionality leads to repeatable precision: when the
trusted software code produces the responses in the form
such as “passed” or “properly certiﬁed,” then the data
owner knows that they have passed the certiﬁcation pro-
cess, regardless of later human regulators or auditors. The
traditional model of data-centric automation has been to
ship data to the code that uses it, thus creating privacy con-
cerns. In the AGAPECert model, data-centric automation is
achieved by shipping trusted code to the data, eliminating
any needless privacy concerns, leaving only those privacy
issues required by the contents of the regulator’s report (§6).

1.3 Overview of Technical Approach

2. The data owner in question is often the sole source of that infor-

mation.

As a key component of the AGAPECert framework, we
introduce Oblivious Smart Contracts (OSCs) as a means to

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

3

achieve Private Automatable Certiﬁcations (PACs). A summary
of this approach is as follows:

1) Use a piece of standardized,

industry-trusted,
regulator-approved code that can securely access
private data using a standardized graph-based API
(§2.4).

2) Compute an aggregate resulting certiﬁcation (the
PAC) as a purely functional result from the input
data.
Store results back to the platform of choice for the
code (i.e., a blockchain, or any standardized event-
ordering scheme §2.4).

3)

4) Hash and sign all (private data, the result of the
computation, and code) so that these signatures and
hashes can be presented in the event of a legal
challenge, used to verify that the code was run
faithfully, and used to verify that the input data has
not been changed since code execution.

No information will be leaked from the private data beyond
what is produced by the pre-approved code itself. Even the
produced PAC does not necessarily have to be shared by
the data owner except in the case of a manual audit or legal
challenge. It needs not even leak that the data owner has
run the OSC if the OSC itself does not communicate with
any outside platform during execution. We can consider the
PAC as being produced by a smart contract – standard, pre-
approved code shared by participants – and consumers of
the resulting PAC as being oblivious to all features of the un-
derlying private dataset beyond the aggregate information
in the PAC, as in oblivious computation [18]. As an exam-
ple of a PAC protocol utilizing blockchain as a byzantine
fault tolerant3 data storage layer, AGAPECert can leverage
auditable computation through a Blockchain-Gateway that
allows pluggable shared ledgers (§5.1) to store anonymous
hashes computed during the PAC generation process.

AGAPECert utilizes the Trellis framework [19], a graph
datastore abstraction which specializes the Open Ag Data
Alliance (OADA) API framework [20], to provide a standard
API for automated data exchange. AGAPECert uses this
concept of having a known, standard API for any type of
data as a foundational component to build an interoperable
codebase capable of interacting with different individual
platforms (§2.4.) Without a standardizable API layer, it is
not practical to write a piece of code that one would expect
to work against many heterogeneous data sources.

AGAPECert also integrates two techniques proposed
in Intel SGX [21]: REPORT and QUOTE. A REPORT is a
unique signed structure that binds a key to the enclave
hardware, the signer of the codebase, the code itself, and
any user-deﬁned data. In the remote attestation process
(§2.2.2), the Quoting Enclave veriﬁes the REPORT and creates
and signs the QUOTE with a key that is only known to
trusted Intel SGX hardware. The QUOTE is utilized by the
Intel Remote Attestation Services to verify the identity of
particular code running inside an enclave. AGAPECert can
store the Quote_Hash (§2.1) in the PAC or a shared ledger,
serving as BFT proof of the computation result timing.

3. A Byzantine Fault Tolerant (BFT) network can continue operating

even if some of the nodes fail to communicate or act maliciously.

AGAPECert differs considerably from current edge com-
puting literature. The AGAPECert architecture includes a
graph data store node, a compute engine node, a broker,
and a validator (§3.1). This is a ﬂexible approach: OSC
code can interact with or be initiated by regular on-chain
smart contract code, various data components can be chosen
by participants as either on-chain or off-chain to support
the use case, and results and hashes can be reported di-
rectly to certifying bodies, pushed to a blockchain (or other
standardized event-ordering scheme), or held only by the
data owners. PACs can also be composed: one “meta”-PAC
can be created by an OSC which veriﬁes the validity of
many other PACs, avoiding the need to even disclose the
underlying PACs themselves.

1.4 Trust Levels

Not all use cases have the same trust requirements.
AGAPECert proposes classifying OSC structures that solve
various use cases into a hierarchy of three trust levels with
increasing trust guarantees at the expense of increasing
complexity (Table 1):

• Trust Level 1, Owner Attested (OA): Regulator or
consumer of PAC trusts the data owner to faith-
fully execute the OSC, and therefore does not re-
quire proof of correct execution provided by a TEE.
Computation is still auditable under legal challenge.
Example: One company prepares a report that uti-
lizes data from a supplier, and they would like to
automate report preparation without requiring the
transfer of private source data from the supplier
that the report preparation process would naturally
aggregate anyway.

• Trust Level 2, Enclave Attested (EA): Regulator or
consumer of PAC requires attestation that OSC code
was executed faithfully. Computation is auditable
under legal challenge, and correct code execution can
be attested without access to private data. Example:
A government regulator would like to automate
checks against a data owner’s digital data, so the
resulting PAC contains TEE attestation.

• Trust Level 3, Ordering Attested (BA): Regulator or
consumer of PAC requires proof of correct execution
as well as proof of event ordering for issues like dou-
ble spending prevention. Contains same components
as Level 2, with the addition of a Byzantine fault
tolerant shared data storage layer like blockchain.
Example: A buyer of a product wants to know that it
is from a certiﬁed set (i.e., purchase does not exceed
available certiﬁed balance), but the seller does not
wish to leak information about timing and quantity
of other sales.

1.5 Contributions

The contributions of this paper are summarized as follows:

• We develop AGAPECert, an auditable, generalized,
automated, and privacy-enabling certiﬁcation frame-
work that integrates event-ordering technologies,
trusted execution environments, and graph-based
APIs.

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

4

Level

Explanation

Requirements

Trust Level 1 TL1 Owner Attested
Trust Level 2 TL2
Enclave Attested
Trust Level 3 TL3 Ordering Attested

Intel SGX
X

Blockchain
X
X

auditable

Security Guarantees

independently attestated
X

provable sequence
X
X

TABLE 1: Summary of trust levels in terms of their requirements and security guarantees.

• As a component of AGAPECert, we introduce Obliv-
ious Smart Contracts and Private Automated Certi-
ﬁcations to automate and protect data ownership in
real use cases, i.e., certiﬁcation frameworks, in the
supply chain (§3).

• Through a handshake protocol utilizing trusted
execution environments
(§3.3),
AGAPECert contributes auditable computation for
use cases that require preserving data ownership and
privacy.

and OAuth2.0

• We analyze the implications of using trusted execu-
tion environments (§4). We also contribute possible
extensions that can enhance AGAPECert’s future
releases.

• We provide an open source implementation of our
solution (§5) that can be reused by other researchers.
With this implementation, we demonstrate the key
in the domain of
characteristics of AGAPECert
privacy-preserving food-safety (§6, §7).

1.6 Roadmap

The rest of this paper is organized as follows. Section 2
provides technical background on the components used to
build AGAPECert. Then, Section 3 describes the architec-
ture and method through which the AGAPECert system
model achieves the goal of private automated certiﬁcation.
Section 4 provides a security analysis of AGAPECert as well
as a discussion on its relationship to known vulnerabilities
in Intel SGX. Section 5 describes AGAPECert’s implementa-
tion details, and Section 6 describes real-world applications
that can be deployed using AGAPECert’s model. Section 7
presents an evaluation of the most critical of AGAPECert’s
components, such as trust levels and deployment of OSCs.
In Section 8, we compare AGAPECert against the state-of-
the-art. Finally, Section 9 concludes this paper.

2 TECHNICAL BACKGROUND
AGAPECert interacts with a trusted real-time graph-based
API (§2.4). AGAPECert computes on encrypted or access-
controlled data (conﬁdentiality), preserves the privacy and
state of the original private data (integrity, §2.1), and, for
some use cases, provides the latest record of the certiﬁca-
tion (sequence, §2.3). AGAPECert instantiates pre-approved
software code inside the compute engine (for Trust Level
2 and 3), providing proof of correct code execution us-
ing trusted execution environments and remote attestation
(§2.2).

input message m to a ﬁxed-length output h(m) referred
to as a hash [22]. The hash has the property that it is
computationally infeasible to create an input string which
produces a pre-deﬁned hash value, it is infeasible to invert
(i.e., determine the original input from the hash alone), and
it is deterministic (the same input string always produces
the same hash).

AGAPECert uses the SHA256 hashing function [23] to
create ﬁve hashes (Table 2) that uniquely characterize the
private data: the REPORT (local attestation), QUOTE (re-
mote attestation), PAC, and OSC.

2.2 Trusted Execution Environments

Trusted Execution Environments (TEEs) are an industry
innovation to enhance the privacy of data and computa-
tion [7]. Through specialized and isolated execution en-
vironments (enclaves), TEEs shield applications against
any malicious operating system, hypervisor, ﬁrmware, or
drivers [9]. TEEs include functionality to encrypt sensitive
communications, seal (encrypt) data, and verify the integrity
of code and data. TEEs implementation includes specialized
hardware instructions embedded in a machine’s processor.
Examples of TEEs include Intel SGX [21] and ARM Trust-
Zone [24].

2.2.1 Intel SGX
Intel SGX (Software Guard Extensions) aims to supply in-
tegrity and conﬁdentiality guarantees through a TEE [9].
Intel SGX creates a private and trusted execution region
in the computer’s processor called an enclave: a secure
"virtual container" or black box that contains code and secret
data [9]. The intended code and data are injected from an
untrusted region into the enclave. Then, built-in software
attestation and sealing mechanisms can provide proof that
an application is interacting with the exact/correct software
in the enclave and not an attacker’s injected malicious code
or simulator.

AGAPECert Trust Level 2 and above require an enclave
to exist in the compute engine (§3.1). The data owner trusts
the environment where they run the code on top of their
private data, and the code they choose to run there has been
pre-approved by them or their trusted service provider in
advance. In addition, the regulator has also pre-approved
the code and knows the appropriate REPORT parameters
that the code will produce when executed in a TEE. Hence,
the code injected in the enclave has been approved by both
the regulator and the data owner, which constitutes a code trust
relationship.

2.1 Cryptographic Hash Functions and Data Integrity

AGAPECert provides integrity protection of private data
and code through well-known cryptographic hash func-
tions. Formally, hash functions map an arbitrary length

2.2.2 Local and remote attestation
To prove that speciﬁc software code is running in trusted
hardware, Intel SGX relies on local and remote attesta-
tion [9], [25]. The attestation mechanism provides proofs,

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

5

Input
private_data retrieved from a Trellis data store

Hash Name
Data_Hash
Report_Hash REP ORT produced by an enclave when running the OSC
QU OT E produced by a Quoting Enclave
Quote_Hash
P ACi (JSON object) produced by the enclave interior
P ACi_Hash
OSC Software Code in the Trusted Code Repository
OSC_Hash

Objective
Integrity of Private Data
Integrity of the REPORT from the enclave
Integrity of the QUOTE from the enclave
Integrity of the PAC
Integrity of the OSC code itself

TABLE 2: Summary of the main AGAPECert cryptographic hashes.

which comprise a cryptographic signature of the enclave’s
content (code, data, and parameters) using the platform’s
secret attestation key known only to the processor. In local
attestation, the cryptographic proof is veriﬁable locally by
another enclave running in the same processor; this allows
secure collaboration to reach a result.

In remote attestation, the cryptographic signature on the
proof can be veriﬁed by a third party as having originated
from a particular piece of trusted hardware using the as-
sumption that the secret key within the processor hardware
is unknown outside of the hardware itself and the hardware
never reports that key to running software. In other words,
the only entity that could have produced the signature is a
trusted processor because it is the only entity that knows its
signing key.

AGAPECert utilizes a remote attestation mechanism as
the means by which the data owner can prove to the regu-
lator that they have faithfully executed the pre-approved
code. OSC code reads private data and produces purely
functional outputs from that data,
including additional
hashes (§2.1). This makes code execution both reproducible
and veriﬁable given the same input data.

2.2.3 Intel Enhanced Privacy ID and SGX DCAP
A critical aspect of privacy-preserving computation is attest-
ing that compute devices have not been tampered with and
are authentic. Intel’s Enhanced Privacy ID (EPID) [26] is an
implementation of ISO/IEM 2008 that handles membership
revocation and anonymity. Membership revocation exposes
methods to invalidate compromised secret keys. Anonymity
means that EPID will attest to the authenticity of devices
without identifying the particular device, i.e., the signature
was created by a key from amid a trusted group of secret
keys. However, EPID cannot distinguish which particular
key in the group created a given signature. AGAPECert
utilizes these existing remote attestation signature schemes.

EPID has some limitations, however:

• Participants are reticent to outsource trust decisions.
•
Some highly-distributed use cases require scalable
veriﬁcation points and need to avoid a single point
of failure.

• AGAPECert can run computation in controlled envi-
ronments restricting Internet access at runtime.

To overcome this, Intel allows the use of Data Center
Attestation Primitives – Intel SGX DCAP [27] – to build
customized third party remote attestation. At this point,
only servers with Flexible Launch Control (FLC) enabled
Intel Xeon E Processors are supported.

2.3 Blockchain and Event Ordering Technologies

In AGAPECert, we expose three trust levels (§1.4) that
deﬁne different trust requirements. That is, the regulator

(or consumer of a PAC) and data owner deﬁne the trust
requirements for particular use cases. For Trust Level 3, the
data owner and regulator have to agree on a technology that
serves as a reliable mechanism for the ordering of events.
A reliable system must include Byzantine fault-tolerant,
consensus, immutability, and integrity properties [7].

Our solution thus desires (for Trust Level 3) a reliable
distributed data storage layer for a reduced schema and
unique content. We consider Blockchain as the mechanism
for ordering events, given its APIs and platforms have
become popular and well-established over the past decade.
We will experimentally demonstrate AGAPECert’s perfor-
mance with Blockchain in Section 7.4, where we contribute
evidence of a use case deployed in the well-known Hyper-
ledger shared ledger fabric.

A blockchain is an immutable, decentralized digital
ledger [7], [28]. Multiple computers store ordered trans-
actions, linked together through a series of hashes that
represent all the data in the ledger up to a given block.
Immutability implies that a record in a set "chained" to-
gether by hashes cannot be changed without affecting all the
subsequent block hashes. A blockchain provides byzantine
fault-tolerant [29] independent auditability capabilities typ-
ically by placing computational constraints on block content
which make it too difﬁcult for a malicious attacker to game
since they cannot brute-force guess solutions any faster than
non-malicious participants.

A smart contract is deﬁned as code that resides in the
blockchain itself. An event can trigger some or all nodes to
execute that code. The input and output data for each run
of the contract code is also typically stored in the blockchain
to make code execution directly veriﬁable: every node uses
the same inputs, runs the same code, and veriﬁes that they
produce the same output.

The simplest forms of OSC do not require a blockchain.
However, some use cases require provable concepts of time
or event ordering. In such cases, including a blockchain
building block can be key to giving an OSC the capability
to provide collaborative interaction that respects ordering of
events. In such cases, AGAPECert can utilize a blockchain
to store hashes when building a PAC. AGAPECert currently
implements a Generalizable Blockchain-Gateway with IBM
Hyperledger Fabric as a building block, but can be extended
to other blockchain frameworks such as Ethereum [30].

Alternative solutions to Blockchain for ordering events
include employing graph databases (such as Neo4j [31] and
ArangoDB [32]), which can expose customized ordering of
events utilizing network/graph representation of transac-
tions and events. In fact, AGAPECert will employ the Trellis
Framework (§2.4) to interact with the private data store via
REST API calls, which is built on top of ArangoDB. Hence,
as an alternative to Blockchain, one could build person-
alized ordering of events or traceability modules utilizing

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

6

the Direct Acyclic Graph (DAG) model materialized on top
of ArangoDB and exposed by Trellis via a REST API. The
distributed ledger technology alternatives to Blockchain,
Tangle [33] and Hashgraph [34], are also based on DAG
models and could similarly be employed here.

2.4 Real-time Graph-based API

We utilize the Trellis Framework [19] which exposes stan-
dardized REST API semantics to interact with a user’s
private data store. The purpose of Trellis is to enable stan-
dardized, automated, permissioned, ad-hoc, point-to-point
data connections through the use of a common REST API.
It is beyond the scope of this paper to fully recount the
details of Trellis4. However, some critical features of Trellis
are important to the development of AGAPECert:

• Resource discovery: Filesystem-like graph schemas
deﬁne where data can be discovered. For ex-
ample, catch locations for a ﬁshing vessel
for
May 1, 2020 could be deﬁned as discoverable
at graph path /bookmarks/trellis/ﬁshing/catch-
locations/day-index/2020-05-01.

• Write semantics: Trellis standardizes how data within
a graph is written. All data changes are reduced to
an ordered stream of idempotent merge operations5.
Operation ordering is only guaranteed per resource,
not globally.

• Change feeds: Clients can register for real-time change
feeds for any arbitrary subgraph of data. This pro-
vides both a real-time communication channel as
well as a means of concurrency-safe 2-way data
synchronization. The change feed is comprised of the
ordered stream of idempotent merge operations.
• Authorization: Trellis standardizes how any client reg-
isters and obtains authorization tokens at any Trellis
platform.

• Permissions: Trellis standardizes how data can be

locally shared within a platform.

3 METHOD: AGAPECERT SYSTEM MODEL
3.1 AGAPECert Architecture

AGAPECert considers two primary actors: data owners and
regulators. Data owners are clients that own private and sen-
sitive data. Regulators are actors that desire some derivative
of the client’s private, sensitive data without requiring the
disclosure of that data itself. Note that the regulator may
not be only what is traditionally considered a regulator, e.g.,
from a government agency, but rather is used in a broader
sense here as any entity looking for information that may
be derived from a client’s private data. By this deﬁnition,
a regulator could be a direct customer of the data owner, a
down-stream buyer in a supply chain, or a business partner.
We deﬁne two critical components of the certiﬁcation

process:

4. Refer to https://github.com/trellisfw for more information.
5. An idempotent merge operation means that a given JSON docu-
ment is produced that only affects matching keys. Keys that do not exist
are created, existing ones are deep-replaced at overlapping key paths,
similar to a common upsert. Applying the same merge repeatedly
results in the same resource state at the mentioned key paths.

• Private Automated Certiﬁcation (PAC): The derivative
output of the client’s data (i.e., the contents of the
"form" that the regulator requires the data owner to
ﬁll out).

• Oblivious Smart Contract

(OSC): The regulator-
approved code which, given access to private input
data, produces the desired PAC (i.e., the "questions"
on the regulator’s "form").

The client (or their trusted service provider or industry
consortium) ensures that the OSC obtains only the necessary
data to produce a PAC, and that the PAC will not leak
any unauthorized information (such as copies of the private
data, or knowledge of when the OSC code was run). The
client runs the approved code and provides it access to their
private data to it to obtain a signed PAC. This PAC should
contain, at minimum, a cryptographic hash representing
the input data used in its computation. For Trust Levels 2
and above, it must also include the cryptographic hashes of
REPORT (Report_Hash) and QUOTE (Quote_Hash) from
the Intel SGX enclave. The client then provides their PAC
to the regulator upon request, at which time the regulator
may validate the PAC according to the trust level for that
use case. Should a subsequent legal challenge be necessary,
the client can produce the private data to a legal authority,
which can verify that the cryptographic hash for that data
(Data_Hash) matches that from the PAC, and can also
re-run the OSC code to produce an equivalent PAC for
comparison.

The AGAPECert architecture is comprised of six main
components, four required and two optional based on the
level of trust required, as depicted in Fig. 2:

• Compute Engine: A compute node controlled by or
trusted by the data owner that is capable of running
the OSC code. A compute engine is required for
all trust levels. For Trust Levels 2 and above, the
compute engine must be Intel SGX-enabled.

• Data Store: A Trellis-conformant data storage plat-
form that holds the private data owned by the client.
This serves as the source of the data for the OSC, as
the real-time communication channel for the broker
and the OSC, and as the destination for the PAC
produced by the OSC.

• Broker: A web application that initiates, authorizes,
provisions, moderates, monitors, and validates OSC
execution, communicating with the OSC through
the secure shared Trellis connection. This serves as
the bridge between the data owner and the OSC,
acting as a service manager; all OSC services can be
monitored through this web-app.

• Validator: A web application that can validate a PAC,
including remote attestation for Trust Level 2 and 3,
and checking a blockchain (or other event-ordering
technology) for Trust Level 3.

• Attestation Service: The Intel SGX attestation service
or DCAP (§2.2.3). Given a particular QUOTE, this
service can attest whether the QUOTE was produced
by a legitimate Intel SGX enclave or not, thus attest-
ing proper code execution. Required for Trust Levels
2 and above.

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

7

Components
Compute Engine
Data Store
Broker
Validator
Attestation Service
Blockchain-Gateway A Generalizable Blockchain Service to connect to a mix of ledgers as needed (optional).

Explanation
Compute node controlled or trusted by the data owner. Runs the OSC.
A Graph Data Store that holds the private data (Trellis).
A web-app that initiates, authorizes, provisions, moderates, monitors, validates OSC execution.
A web-app that can validate a given PAC
The Intel SGX attestation service or Data Center Attestation Primitives (DCAP)

TABLE 3: Summary of components comprising the AGAPECert architecture. The Attestation Service and Blockchain-
Gateway are only necessary for Trust Level 3.

which communicates with the enclave, and the trusted part
that includes the computation inside enclaves. Note that
while these terms make sense in the traditional environ-
ments where Intel SGX is intended to run, they are mis-
nomers in our context where the environment running the
OSC is assumed to be trusted by the data owner already. We
will instead use the term enclave exterior to describe what
Intel SGX terms the untrusted part, and enclave interior to
describe the trusted part.

Trust Level 1 does not require a TEE; this simple form of
OSC is simply any code capable of interacting with a Trellis
platform to read data and save a resulting PAC.

For the Trust Levels 2 and 3, the OSCs include native
C Bridge functions that communicate with the enclaves.
The enclave exterior of the OSC connects and retrieves
the private data from the Trellis data store and injects a
buffer into the enclave interior of the OSC. AGAPECert
includes C++ classes that implement the Trellis REST and
WebSockets APIs to communicate with the Trellis data store
through a shared resource located in the Trellis graph at
/bookmarks/OSC/Hk, where Hk can be a random string
generated at runtime by the OSC or a static feature of the
OSC and is discovered by the Broker when initiating the
connection.

The enclave interior of the OSC computes the crypto-
graphic hashes necessary to audit the computation in the
future and passes them through the enclave exterior to be
stored in the PAC, which is stored back to the data owner’s
Trellis data store. In Trust Level 3, AGAPECert also stores
the cryptographic hashes in the blockchain.

It is important to note that since AGAPECert stores
only the cryptographic hashes in the blockchain, and these
hashes cannot be linked to the source data using only the
hash, this protects the privacy of the data owner; i.e., there
is no information leakage from this process such as third
party knowledge of how many times the data owner has
run the OSC. However, storage of the hash in the blockchain
can leak the time when a given PAC was generated since a
regulator receiving the PAC in the future can check where
in the blockchain the hash was saved.

Fig. 2: AGAPECert architecture for Trust Level 3. The data
owner main components include a compute engine that
runs the OSC (exterior and interior), a data store, a service
manager for the OSCs (broker), and a blockchain-gateway
(optional, for trust level 3 only) to store the Quote_Hash
and UUID (PAC.id). The regulator includes the validator
and its data store. The validator queries the ledger to verify
a particular PAC. Also, the validator attests correct code ex-
ecution connecting to remote attestation services or DCAP.

• Blockchain (Event-Ordering) Gateway (optional):
An interface to a blockchain (or other event-ordering
scheme, see §2.3) that is trusted by the regulator and
the data owner—this component is optional and only
necessary for trust level 3.

These components are summarized in Table 3.

3.2 Oblivious Smart Contracts

An Oblivious Smart Contract (OSC) is software code that
reads private data to compute a result such as pass/fail
and generate a PAC (§3.3). OSCs run in the compute engine
node. For Trust Levels 2 and 3, this computation happens
inside a TEE on the compute engine.

As explained by Intel’s documentation [21], Intel SGX
applications (such as Trust Level 2 and above OSC’s) are
comprised of two parts: the untrusted part of the application

The typical OSC runs continuously, awaiting notiﬁcation
from the broker through the Trellis data store at shared
storage location /bookmarks/OSC/Hk to start a new PAC
generation process on a new subset of data, or until a restart
is submitted from the broker. Each run of the OSC produces
one or more PACs deterministically, after which point the
OSC returns to a listening state awaiting further signals
from the broker.

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

8

3.3 Private Automated Certiﬁcations (PAC) Workﬂow

To generate a certiﬁcation under Trust Level 3, AGAPECert
uses the following workﬂow (Fig. 3, Algorithm 1.) For other
trust levels, the respective components not used by those
levels are simply left out. Note that AGAPECert utilizes a set
of RFCs in this process (RFC7591, RFC7517, and RFC7519)
as prescribed in the Trellis authorization protocol [35].

1)

Install OSC: The data owner installs the OSC on
their compute engine. This produces a random pub-
lic/private asymmetric key pair, with the public key
saved as a JSON Web Key (jwk from RFC7517) in a
newly generated Trellis Client Certiﬁcate (Cosc).
2) Authorize Broker: The data owner logs into their
Trellis compliant node via OAuth2 to authorize a
token for the Broker.

3) Watch for OSCs: The broker opens and maintains
an active websocket connection to the Trellis data
store that watches the top-level /bookmarks/OSC
document for any connected OSCs.

4) Authorize OSC: The data owner uses the Broker to
pre-register the OSC’s Trellis Client Certiﬁcate Cosc
at their Trellis data store as an authorized OSC.
Start the OSC: The data owner starts the OSC. They
can also verify that the hash of the OSC code
OSC_Hash matches the one available in a private
certiﬁed code repository.

5)

a) The OSC Exterior performs OAuth2 dynamic
client registration by exchanging its Trel-
lis Client Certiﬁcate Cosc with Trellis for a
Client ID. It then performs OAuth2 Client
Grant ﬂow during which it proves that it has
the private key for the pre-registered certiﬁ-
cate by creating a signed jwt_bearer token
(RFC7523). This process results in a properly
scoped launch token (Tl) to access the user’s
Trellis data store at /bookmarks/OSC.
b) The OSC Exterior generates a random string
Hk that uniquely identiﬁes this instance
of OSC. The OSC uses the token received
from previous step to create a resource
(/bookmarks/OSC/Hk) in the data store. It
also puts information about itself into that
document.

c) The OSC exterior opens and maintains an
active Trellis websocket connection to the
Trellis data store watching for changes to
the new /bookmarks/OSC/Hk as the main
communication channel between the broker
and the OSC.

6) Communication Channel Opens: The broker’s active
Trellis websocket connection notiﬁes it that a new
OSC resource exists at /bookmarks/OSC/Hk.
7) Validate OSC Quote: To validate that their plat-
form has loaded the correct OSC code, the data
owner loads the credentials for the Attestation Ser-
vice §2.2.3 (IAS or DCAP) into the Broker. The Bro-
ker will initiate remote attestation to verify that the
enclave is legitimate. This remote attestation work-

ﬂow produces and validates a QUOTE (§2.2.2)6.
The data owner can store the QUOTE to expose
auditability features. The data owner can also prove
to a third party (e.g., a regulator or auditor) that a
particular OSC was run in the data owner’s plat-
form with a speciﬁc conﬁguration.

8) Provision Data to OSC: The broker then provisions a
properly-scoped data access token Td for the OSC
to use in creating its PAC. The broker writes this
token to the shared Trellis communication chan-
nel at /bookmarks/OSC/Hk along with any data
ﬁltering instructions (such as restricting the PAC
to only consider a particular day’s dataset). The
active websocket connection held by the OSC ex-
terior notiﬁes it of the newly provisioned token and
ﬁlter, triggering the OSC to begin the core PAC
generation.

9) OSC Interior Requests Data: The OSC exterior re-
ceives the data access token and ﬁltering instruc-
tions and notiﬁes the OSC interior to begin PAC
generation. The OSC interior uses its knowledge of
the known, published Trellis semantic data struc-
tures to begin requesting data it needs. Requests for
data initiated by the OSC interior are forwarded to
the OSC exterior to make the actual requests over
the active Trellis websocket connection.

10) OSC Exterior Injects Data: The OSC exterior serializes
and injects the received data into the OSC Interior
as it comes back from Trellis.

11) OSC Interior Computes PAC: The OSC interior com-
putes its core certiﬁcation result (i.e., pass/fail) from
the received input data, as well as a cryptographic
hash (Data_Hash) of all serialized data received
during the generation of one PAC. Upon completion
of all received data, the OSC interior saves this hash
of all input data to the PAC in the data store.
12) OSC Interior Hashes PAC: The OSC interior generates
a hash of the entire PAC (including Data_Hash
and a random universally unique identiﬁer for the
blockchain transaction) and saves this back to the
PAC itself in the Trellis data store through the OSC
exterior.

13) Exterior Obtains TEE Quote: The OSC exterior sees
the hash of the overall PAC and concludes that
the OSC interior has completed its work. The OSC
exterior then instructs the OSC interior to obtain a
QUOTE from a local quoting enclave, including the
hash of the PAC as the user data for a new REPORT
from the OSC interior. The OSC exterior gathers the
ﬁnal QUOTE from this process and writes it to the
PAC in the Trellis data store.

14) OSC Interior Sends Quote_Hash to Blockchain: For
Trust Level 3, the OSC exterior will then com-
municate with the Blockchain Gateway to record
the unique identiﬁer and Quote_Hash in the
blockchain, along with any further case-speciﬁc re-
quirements.

6. If the OSC cannot be validated, an exception report must be
stored in the data owner’s trusted platform. This constitutes a remote
attestation failure, in which case the process will not continue with the
next steps.

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

9

15) Data Owner Sends PAC to Regulator: Finally, at a later
time, the regulator receives the generated PAC from
the data owner and uses the Validator to check it.
The Validator sends the QUOTE from the PAC to
an attestation service to verify that the QUOTE was
indeed generated with an Intel EPID key that has
not been revoked. Note that if a processor’s key
is revoked, this either invalidates all prior PAC’s
generated by that processor, or some outside means
of providing a trusted timestamp of QUOTE genera-
tion (such as that provided by Trust Level 3 through
a blockchain) must be included in this ﬂow to
maintain validity of PAC’s generated prior to some
known revocation time. The Validator also queries
the blockchain ledger to validate the Quote_Hash
and case-speciﬁc data.

Data: data_token, f ilter
Result: P AC, QU OT E, QU OT E_HASH, U U ID
trellis ← new T rellis(data_token) ;
/* instantiates a new gateway */
blockchain_gateway ← new Blockhain() ;
/* retrieves private data */
data ← trellis.getP rivateData(f ilter) ;
/* instantiates the trusted algorithm
inside enclave (OSC interior), returns
the computed PAC */
pac ← computeAlgorithm(data) ;
if pac 6= null then

/* retrieves the

quote ← getQuote() ;
cryptographic proof of the
computation */
trellis.putP AC(pac, quote) ; /* updates PAC
in the trellis backend */
blockhain_gateway.putP AC(pac) ; /* stores
UUID and Quote_Hash in the shared
ledger */

end

Algorithm 1: AGAPECert PAC generation overview.

3.4 Blockchain-Gateway Schema

AGAPECert stores a minimal set of cryptographic hashes
(§2.1) in the shared ledger. These hashes do not convey any
identiﬁable private information to an eavesdropper of the
transactions in the blockchain nodes. We deﬁne the methods
of the smart-contract necessary to store hashes from the
OSC.

The AGAPECert proof-of-concept models the business
network utilizing Hyperledger Fabric (§5.1.) Hyperledger
Fabric requires the deﬁnition of assets, participants, and
transactions. AGAPECert utilizes a PAC as an asset in
the blockchain that we deﬁne as a "Fabric PAC" f abP AC.
We deﬁne two participants: an anonymous participant that
stores PACs in the ledger and a regulator who queries the
transactions and assets in the distributed ledger.

Property(fabPAC.)
id
quoteHash
OT K (optional One-Time-Key)

Type.
String (UUID)
String
String (Base64 encoded)

TABLE 4: PAC business network in the shared ledger.

AGAPECert’s blockchain schema is shown in Table 4. This
forms the basis for use cases in Trust Level 3.

The regulator automated software can check if the cryp-
tographic hashes in the PAC match the transaction regis-
tered in the blockchain. AGAPECert’s Blockchain Gateway
exposes a REST API to communicate with the Fabric.

4 SECURITY ANALYSIS

AGAPECert does not alter the existing real-world model of
requiring the regulator to trust the data provided to it by the
client under threat of legal recourse, as discussed in 1.2. Our
security analysis therefore only focuses on guarantees made
about computation on the private data (which is assumed
correct until audited), rather than about the private data
itself.

4.1 Side channel attacks to the Compute Engine

TEE technology such as Intel SGX can be vulnerable to "side
channel attacks:" [36], [37], [38], [39], [40], [41] malicious
code running on the same processor can learn about enclave
computation and data via round-about methods such as
tracking cache timings after an enclave is switched out of
execution. AGAPECert assumes the data owner is running
the OSC in an environment they already trust: the threat
of a malicious entity on the same processor does not apply,
hence AGAPECert is immune to traditional enclave side-
channel attacks.

However, a data owner using past side-channel attacks
against their own trusted enclaves (such as the enclave
that provides quotes) could learn the remote attestation
keys [36], [38] for their own system and use that to forge
fake QUOTE’s. Since such attacks have been discovered,
researchers have also contributed mitigation techniques to
patch those security vulnerabilities [36], [38]. Additionally,
Intel’s security advisories provide critical mitigation tech-
niques [42]. For instance, some vulnerabilities require mi-
crocode level and software mitigations.

AGAPECert runs in a controlled environment in which
standards and best practices are enforced; therefore, data
owners and participants in the protocol must have the latest
Intel SGX Software installed, the newest microcode up-
dates through BIOS updates, and any other recommended
measures such as updated operating systems and virtual
machines. Microcode updates upgrade the Security Ver-
sion Number (SVN) utilized in the implementation of Intel
SGX [42]. Microcode updates provide new sealing and at-
testation keys to the enclaves on the platform [42]. Hence,
we can track the SVN embedded in the PAC the regulator
will assess the validity of a speciﬁc PAC via a customized
attestation process using current vulnerabilities.

AGAPECert deﬁnes a simple schema of at least two
strings for a f abP AC: (unique identiﬁer, Quote_Hash)
and for some use cases a One-Time-Use-Key (OT K).

This means that at any given time, it is not known to be
possible to forge QUOTEs that contain the latest SVN until a
future vulnerability is released. In the event of catastrophic

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

10

(a) AGAPECert Workﬂow (Before PAC Generation.)

(b) AGAPECert Workﬂow - PAC Generation Overview.

Fig. 3: (a) Illustrates the OSC’s Authorization to the provisioning of data (steps 4-8) (b) AGAPECert generates a PAC (steps
8-14).

security failure of Intel SGX’s architecture, data owners may
need to refresh relevant PACs after updating their processor
microcode to produce updated SVNs. The purely functional
and auditable nature of AGAPECert’s OSCs ﬁt this model
well. In addition, if the QUOTE hash was published in a
blockchain prior to vulnerability discovery, regulators may
consider a "likely validity" date since the blockchain can
attest when the original QUOTE was signed.

Recall as well that the computation is auditable at any
time: should the regulator question a result, they can simply
trigger an audit of the private data, which could be as simple
as running the OSC again with the auditor’s oversight. Con-
sider as well that it is often vastly easier for a malicious data
owner to forge their private data (which they can do today
without AGAPECert) than it is to attempt cracking open a
CPU in an attempt to probe for highly guarded embedded
attestation keys. Once such foul play is discovered during
any audit, Intel EPID can simply revoke the key that the
malicious data owner spent so much effort attempting to
learn, providing severely diminishing returns to any such
attacker.

Therefore the traditional side-channel security vulnera-
bilities with TEE computing have little ability to impact the
security of AGAPECert in general.

4.2 Analyzing AGAPECert’s Trust Levels

4.2.1 Owner Attested

The regulator trusts the data owner to correctly execute the
OSC. Therefore, the Compute Engine, Broker, Data Store are
assumed to be trusted. In the case of an adversarial data
owner, the regulator can still validate the private data and
code execution via audits.

4.2.2 Enclave Attested

Trust Level 2 requires the correct execution of the OSC/Al-
gorithm. Therefore, Trust Level 2 relies on the attestation
capabilities of the Intel SGX Architecture. Following our
previous discussion on side-channel attacks, an adversarial

data owner can steal secrets from an outdated Intel SGX-
enabled node signing code and data as genuine compromis-
ing ultimately Trust Level 2. AGAPECert implementations
must require up-to-date remote attestation schemes, includ-
ing the latest SVN known to have reasonably uncompromis-
able attestation keys.

4.2.3 Ordering Attested
For Trust Level 3, the discussion about faithful code exe-
cution is analogous to Trust Level 2. Ordering of events
provided by a shared ledger can expose the execution
timestamp of an OSC and creation of a PAC breaking our
premise of obliviousness and revealing useful information
for an interested party. AGAPECert utilizes a Blockchain
Gateway to submit anonymous and asynchronous transactions
to a shared ledger or a mix of ledgers hiding the identity of
the participants. In the case of a compromised shared ledger,
no useful information is derived by an attacker solely from
the global state.

4.3 Discussion

There exist extremely sensitive datasets and data sources—
electronic health records, stock market, ﬁnance, etc. —in
which even the leakage of a reduced set of bits can be
catastrophic. Under adversarial environments, these use
cases require stronger cryptosystems that offer semantic
security [43], [44] (homomorphic encryption). AGAPECert
use cases and trust model limit the capabilities of an ad-
versary. For instance, a participant is limited by standards,
regulations, and audits. Moreover, the possibility of legal
action—when a deviation from the protocol is suspected—
forces the participant to maintain a good reputation.

Powerful adversaries (stronger than HBC7) that can
get access to the blockchain cannot derive any useful in-
formation from the stored cryptographic hashes and ran-
dom universal unique identiﬁers. AGAPECert does not

7. "The honest-but-curious (HBC) adversary is a legitimate partic-
ipant in a communication protocol who will not deviate from the
deﬁned protocol but will attempt to learn all possible information from
legitimately received messages" [45].

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

11

rely solely on Intel SGX attestation and sealing primi-
tives; instead, AGAPECert contributes a set of trust levels
providing adaptability features according to particular use
cases. AGAPECert’s future releases can allow homomorphic
encryption exposing Homomorphic and Oblivious Smart
Contracts (HOSC). Integrating SEAL [46] in AGAPECert
allows a richer set of devices as compute engines.

5 PROTOTYPE IMPLEMENTATION

The AGAPECert prototype implementation components are
available as open source as shown in Table 5, and documen-
tation for how to install and run the entire ﬂow can be found
at https://github.com/agapecert/agapecert.

5.1 Blockchain Gateway

For Trust Level 3, AGAPECert’s prototype implementation
interacts with a pacContract deployed in a blockchain net-
work through a custom Javascript-based Blockchain Gate-
way8. The primary purpose of the Blockchain Gateway is
to submit asynchronous (and optionally anonymous) trans-
actions to the ledger. The Blockchain Gateway is generaliz-
able and can accommodate pluggable shared ledgers. This
gateway allows the Broker, Validator, and OSC to interact
with a shared ledger (or a mix of ledgers). AGAPECert’s
Blockchain-Gateway future releases can utilize concepts
deﬁned by Agrawal et al. [47] to enhance anonymity and
privacy when interacting with a shared ledger.

5.2 Trusted Compute Engine

We implemented the OSCs utilizing C++ for the OSC exte-
rior. We utilized OpenEnclave [48] to implement C bridge
functions for the OSC interior. The compute engine exposes
a rich API (C++ driver Listing 1) to allow secure commu-
nication between the OSC, the graph-based API, and the
Broker. The C++ driver implements secure WebSockets.

1 / T r e l l i s * o b j T r e l l i s = new T r e l l i s ( ) ;
2 o b j T r e l l i s −> g e t P r i v a t e D a t a ( ) . wait ( ) ;
3 m _ p r iv at e _ r e c or d s = o b j T r e l l i s −>m _p r iv at e _r e c or d s ;
4 // AGAPECert C++ Driver - Compute Engine Methods
5 o b j T r e l l i s −>getUUID ( ) ;
6 o b j T r e l l i s −>getToken ( ) ;
7 o b j T r e l l i s −> g e t A u t h o r i z a t i o n ( ) ;
8 o b j T r e l l i s −> g e t P r i v a t e D a t a P a t h ( ) ;
9 o b j T r e l l i s −> g e t P r i v a t e D a t a ( ) ;
10 o b j T r e l l i s −>putPAC ( ) ;

Listing 1: Example OSC Exterior usage of Compute Engine
C++
driver
Trellis
(https://github.com/agapecert/compute-engine)

6 EXAMPLE APPLICATIONS

There are an enormous number of potential applications for
AGAPECert with its OSC+PAC model. This section shows a
few non-trivial illustrative examples9.

8. https://github.com/agapecert/blockchain-gateway
9. A complete description of example applications can be found at

https://github.com/agapecert/osc-deﬁnitions/wiki

6.1 Trust Level 1: Automated Sustainability Reporting

A Consumer-Facing Food Company, known as CFFC,
wishes to create periodic sustainability reports for con-
sumers to strengthen their brand. However, many of the
metrics they might report are dependent upon data sources
outside their company: i.e., their suppliers or third-party
contractors. Consider just one metric: total energy con-
sumed from renewable sources. CFFC does not want to
require its suppliers to send their energy bills to them each
month. Instead, CFFC creates an OSC that looks in Trellis
ﬁrst for an already-produced sustainability report, and if it
ﬁnds one, it produces a PAC with just the “total energy con-
sumed from renewable resources” number extracted from
the existing report. If it does not ﬁnd one, it looks for any
energy bills containing such numbers, adds them together
for the year, and then produces a PAC with the resulting
number.

CFFC asks its suppliers to run this OSC in their
AGAPECert instances and then share the resulting PAC
with CFFC via an automated Trellis connection. CFFC is able
to fully automate the creation of their own sustainability
report without requiring the release of private, sensitive
data from their suppliers. This relies on their supplier hav-
ing such information already in a Trellis-conformant data
store: in cases where it is not, the beneﬁts of automating this
process for their suppliers is incentive to achieve that goal
in ways that are difﬁcult to incentivize without such a tool.
The supplier has a trusted third party that handles
running their OSC’s, so the third party starts up this OSC
from CFFC, and an employee with the supplier uses the
AGAPECert broker app to authorize, conﬁgure, and mon-
itor the OSC as it creates the PAC’s automatically every
month. The employee creates an automated Trellis connec-
tion to CFFC so that whenever a new PAC is generated,
and that PAC has been approved internally via a rule set
or human approval, it automatically synchronizes the new
PAC to CFFC. This represents a Trust Level 1 (Owner-
Attested) PAC. The data owner is attesting that they ran
the code faithfully, and the hash of the input data is stored
in the PAC by the OSC, allowing auditability in the future
as needed.

6.2 Trust Level 2: Certiﬁed Fishing Catch Area

The global ﬁshing industry would like to eliminate over-
ﬁshing by requiring ﬁshing vessels to catch ﬁsh only in
approved areas. Fishermen consider their active catch areas
to be proprietary to their business. The industry needs a
practical zero-knowledge proof that can certify a particular
ﬁsh was caught within legal boundaries without disclosing
the actual catch locations. A sustainable ﬁshing industry
consortium creates an OSC which checks a given Trellis data
store for a list of catch locations within a certain time period
or within a certain group identiﬁer like a lot number. The
OSC pulls a set of approved geospatial catch boundaries
from an industry list, intersects the catch locations with the
boundaries, and produces a PAC with the time period or lot
number, a “true/false” answer about whether all the catch
locations ﬁt within the boundaries, an identiﬁer for the set
of boundaries used, and a QUOTE from the trusted black
box attesting that the OSC code was executed faithfully.

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

12

Component
Broker
Validator
Compute Engine
Blockchain Gateway

Repository
https://github.com/agapecert/broker
https://github.com/agapecert/validator
https://github.com/agapecert/compute-engine
https://github.com/agapecert/blockchain-gateway

Objective
OSCs’ Service Manager
PACs’ veriﬁer
Compute Engine
Anonymous and asynchronous shared ledger accesses

TABLE 5: Summary of components’ repositories for AGAPECert implementation.

The industry would like to minimize cheating, and au-
thorizes a set of trusted catch location recording devices
that are maintained and periodically tested by approved
auditors. The OSC can be augmented to verify that each
catch location contains a signature from a trusted recording
device manufacturer, and that the device is present in a
recent active audit that is digitally signed by a trusted
third-party auditor, all using the Trellis standard document
integrity signature process. This additional “true/false” an-
swer is added to the PAC, verifying that the catch locations
themselves were attested by trusted parties other than just
the ﬁsherman. The ﬁsherman uses the AGAPECert broker
and their OSC-enabled Trellis platform to authorize and run
the OSC, producing the certiﬁcation back to their Trellis
platform. Before each batch of ﬁsh can be sold at the docks,
the buyer must receive the PAC for that days’ catch. This
represents a Trust Level 2 (Enclave Attested) computation
where the global ﬁshing industry would like to know that
the code was faithfully executed by the ﬁsherman.

6.3 Trust Level 3: Organic Mass Balance

One of the more difﬁcult certiﬁcation problems is charac-
terized by a mass balance. In its simplest form, there is
some mass of product that has been certiﬁed to be produced
(either based upon the total inputs to the process, or based
upon a human auditor’s assessment), and the industry
would like to know that the seller of a product indeed
can certiﬁably produce that amount of that product. If an
organic farmer could receive a certiﬁcation that they can or
did produce 10 tons of organic apples, downstream buyers
of those apples would like to know that the farmer has not
re-used that 10-ton organic certiﬁcation multiple times with
multiple buyers, thereby selling potentially non-organic ap-
ples under an organic certiﬁcate. The farmer, on the other
hand, does not want to put a list of their transactions into
some shared database for buyers to check for validity since
this could tip off buyers about how much inventory he has
or how many sales he has made recently and to whom.
The buyer needs a zero-knowledge-style proof that the
certiﬁed product they are buying has not been sold under
this certiﬁcation to someone else.

An industry consortium agrees on one or more
blockchain platform(s) to act as a byzantine fault tolerant
shared datastore. The consortium produce an OSC which
can look at a buyer’s Trellis platform for a private ledger
of sales. This ledger should be initiated with an additive
transaction that is digitally signed by a trusted auditor (i.e.,
the auditor attests that the farmer has 10 tons of organic
apples). The signature is veriﬁed by the OSC, and the bal-
ance is computed by subtracting any subsequent veriﬁable
sales. The OSC ﬁnds a proposed new sales transaction in
the Trellis data store, digitally signed by the buyer and the
seller. The OSC veriﬁes that the amount of the sale does

not exceed the available balance, veriﬁes the signatures, and
then saves the transaction to the end of the private ledger.
The OSC produces a PAC indicating “success/failure” for
the transaction, which can be automatically saved back to
either the buyer’s Trellis data store, the seller’s, or both. If
the buyer has their own private ledger, this PAC from the
seller can serve as auditable, traceable proof to include in the
buyer’s private ledger and add to their available inventory,
all without disclosing any of the buyer’s sales to any outside
party.

As speciﬁed to this point, the protocol suffers from a
double-spending attack where the seller simply maintains
multiple private ledgers, providing different ones to the
OSC depending on which customer they are selling to, thus
enabling them to “spend” the same certiﬁed product more
than once. To alleviate this problem, we introduce the con-
cept of a one-time-use asymmetric key pair generated by the
OSC and veriﬁed by a smart contract on the OSC’s chosen
blockchain. When the OSC is evaluating a proposed trans-
action, it accesses the seller’s Trellis datastore to retrieve
the one-time-use private key from the previous transaction
and an indicator of where to ﬁnd the corresponding public
key in the blockchain storage layer. The OSC checks the
blockchain’s record for that key to see if has been marked
as “used” yet or not. If it has not been used, then the OSC
initiates a smart contract at the blockchain platform to mark
it as “used,” which is only allowed by the smart contract
when it veriﬁes that the OSC can produce a signature with
the private key corresponding to the public key in the
chain. The OSC sees this successfully ﬁnish and then asks
a different smart contract on the blockchain platform to
store a new one-time-use public key and registers it in the
blockchain along with a hash of the new ledger. The OSC
will fail the transaction if the ledger hash for the key it used
does not match the hash of the current ledger it is updating.
The OSC stores the private key for this new one-time-use
key pair for the next transaction. The OSC also checks
that each successful transaction in the private ledger has a
corresponding “used” key recorded in the blockchain with
matching ledger hashes. Note the importance of including
the hash of the ledger in the chain with the public key. We do
not want to link transactions in the chain by allowing one
key to point to the next key in the chain. However, if the
two are truly unlinkable, then it is possible for a malicious
seller to still double-spend by simply maintaining multiple
ledgers with multiple one-time-use keys. Therefore, the OSC
and smart contract must allow the link to be maintained
in the private ledger, both refusing to create and store a
new one-time-use keypair whose full ledger hash is already
present with another one-time-use key in the chain. For
maximal trust, the blockchain nodes themselves should also
be capable of performing remote attestation to validate a
QUOTE from the OSC interior. This is an example of a Trust

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

13

Level 3 (Ordering Attested) computation.

7 EVALUATION

In order to present empirical evidence of AGAPECert ef-
fectiveness, we develop three experiments to benchmark
critical components of AGAPECert. We start by evaluating
the trusted compute engine performance with a mix of
Trust Level 1 and Trust Level 2. Then, we discuss the
results of generating 1000 PACs for different input sizes
(a complete workﬂow performance evaluation). Finally, we
evaluate the Blockchain-Gateway with our pacContract
and Hyperledger Fabric performance. All experiments are
run 1000 times. All the code of experiments can be found at
https://github.com/agapecert.

7.1 Experiment setup

To show AGAPECert usability and ﬂexibility, we utilize a
commodity HP Pavilion Laptop with an Intel Core i5-8250u
CPU and 16GB of RAM running Ubuntu Linux 18.04 LTS
64-bit Operating System (serves as a compute engine, graph
data store, and Apache Spark server). We also use a trusted
edge server, Dell R340, with an Intel Xeon E-2186G and
64GB of RAM running Ubuntu Server Linux 18.04 LTS 64-
bit Operating System (utilized for data center attestation
primitives). The latter has support for Flexible Launch Con-
trol (FLC) and Data Center Attestation Primitives (DCAP.)
Serving as the Blockchain-Gateway is a MacBook Pro (15-
inch, 2017) with an Intel Core i7 2.8GHz and 16GB of
RAM running macOS Catalina Version 10.15.4 and IBM
Blockchain Platform 1.0.31 Visual Studio Code Extension.

7.2 Trusted Compute Engine Performance

We developed a computation-intensive algorithm—the
Monte Carlo approximation—as an Oblivious Smart
Contract. The Monte Carlo OSC was instantiated in
AGAPECert’s compute engines running NodeJS (TL1), in-
browser JavaScript (TL1), and C using OpenEnclace API
(TL2). Besides, we developed equivalent code in Python and
deployed it in Apache Spark version 3.1.0.

7.2.1 AGAPECert’s compute engine and Apache Spark

compute engine against
We compared AGAPECert’s
Apache Spark version 3.1.0. The goal of this experiment is
to provide a context of comparison to AGAPECert; Apache
Spark will scale and perform better at a massive scale. How-
ever, AGAPECert includes use cases in which preserving
data ownership is critical. Fig. 4 shows that AGAPECert’s
compute engine performs better than Apache Spark using
this computationally-intensive Monte Carlo OSC. It is worth
noting that Apache Spark’s poor performance with two or
four executors is due to the use of a synchronized random
function in Python, which cannot scale to multiple cores.
Nonetheless, a single executor (spark naive) provides a
better comparison against AGAPECert’s compute engine.
Future AGAPECert releases can integrate Apache Spark [49]
and Opaque [18] for scalability guarantees.

spark - naive
spark - 4 exec
spark - 2 exec
agapecert - tl1 JavaScript
agapecert - tl1 NodeJS
agapecert - tl2 C/C++

)
s
d
n
o
c
e
s
(

i
p
e
t
a
m

i
t
s
e
o
t

e
m
T

i

300

250

200

150

100

50

0

1M 2M 4M 8M 16M 32M 64M 128M 256M
Iterations

Fig. 4: AGAPECert’s compute engine (TL1, TL2) and Apache
Spark (1,2,4 executors). We developed the Monte Carlo
Approximation Algorithm for those compute engines.

Fig. 5: Compute Engine Performance. We developed the
Monte Carlo Approximation Algorithm. The Monte Carlo
OSC is instantiated in AGAPECert for Trust Level 1 (TL1) for
an in-browser compute engine, Trust Level 1 (TL1) NodeJS
compute engine, and Trust Level 2 (TL2) with Intel SGX and
OpenEnclave.

7.2.2 Trust Level 1 and Trust Level 2 comparison

In Fig. 5, we observe that the AGAPECert (TL2) compute
engine outperforms an in-browser JavaScript compute en-
gine (TL1) with equivalent source code. Hence, AGAPECert
(TL2) can offer similar performance to widely used devel-
opment frameworks such as NodeJS and JavaScript. For
some use cases, AGAPECert (TL2) can provide a better
performance than such frameworks—even computing on
top of encrypted private data. We compare the compute
time exclusively. An extensive study of ocalls and ecalls
performance is shown in [50].

7.3 Private Automated Certiﬁcations Performance

This experiment shows the total time needed to generate
a PAC using the K-means clustering algorithm deployed
as an Oblivious Smart Contract (OSC). The K-means al-
gorithm is setup with n in increments of 2i ∗ 1000 where
i = 0, 1, 2, 3, 4, 5; k is set to buckets of 250 items per
cluster (k = n/250); k centroids are determined randomly.
The total time includes enclave creation, communication
with the graph-based API, computation on private-data,
PAC generation, and PAC storage in the graph data store.
An asynchronous blockchain access stores the PAC in the
blockchain (Fig. 7).

 
 
 
 
JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

14

Fig. 6: PACs’ generation performance evaluation for Trust
Level 3 (TL3). The K-means algorithm is instantiated as an
Oblivious Smart Contract (K-means OSC or oblivious K-means
if you will).

The purpose of this K-means OSC is two-fold: (1) it
presents a widely used clustering algorithm for replicability;
(2) solves our example applications (§6.2)—certiﬁed ﬁshing
catch area and similar use cases—with a straightforward
modiﬁcation. The regulator ﬁxes the set of centroids, the
algorithm to compute the distances, and the threshold that
determines if the PAC has passed the evaluation/certiﬁca-
tion process. As mentioned before, this K-means OSC will
be agreed upon by both the regulator and the data owner.
The K-means OSC will contain all the semantics that allow
the correct validation of data to generate an objective—
according to the speciﬁcation—PAC that can be audited in
the future.

Fig. 6 shows that the PAC generation is bounded by
the input data retrieved from the graph data store. Ad-
ditionally, the running-time in the blockchain (§7.4) and
enclave creation is approximately constant (610.65 ± 230.10
ms). However, an OSC is continuously running, waiting
for signals from the broker (OSCs’ service manager.) The
overhead to initialize an enclave is suffered only once per
computation cycle, or when a restart is required.

7.4 Blockchain-Gateway Performance

AGAPECert interacts with a Blockchain-Gateway for Trust
Level 3 (§5.1). We created a test suite to measure the
Blockchain-Gateway performance using the Chai assertion
library [51] and the Mocha test framework [52] (Fig. 7).
When there exist multiple blocks in the shared ledger,
the Blockchain-Gateway takes around 2180.88 ± 38 ms to
execute an asynchronous PAC creation in the ledger. The
Blockchain-Gateway takes 27.37 ± 9 ms to execute a PAC
GET query in the ledger (when there are more than 100
blocks in the shared ledger.) The validator will use the GET
function to the Blockchain-Gateway, the Broker or OSC will
use the PUT to the Blockchain-Gateway. The Broker, OSC,
or validator will use the cached connection (83.36 ± 13 ms).

8 RELATED WORK

This section describes prominent industry solutions that
utilize Trusted Execution Environments to provide privacy-
preserving computation.

Fig. 7: Blockchain-Gateway interacting with IBM Hyper-
ledger Fabric and pacContract performance.

8.1 Microsoft’s CCF framework

The Conﬁdential Consortium Blockchain Framework (CCF,
formerly CoCo) strives to enable private and scalable
blockchain networks [11]. The CCF is meant to be open-
source and compatible with other blockchain protocols [11].
CCF augments the trust among peers/nodes executing
smart contracts inside Intel SGX enclaves. Analogous to the
CCF, we observe that traditional blockchains pose signif-
icant privacy issues; transactions, global state, and smart
contract code are visible to anyone that enters the network.
In contrast to the CCF, AGAPECert identiﬁes that not all
transactions and computation have to run in the chain for
the problems addressed in this paper.

8.2 Secure Data Trading Ecosystem

The Secure Data Trading Ecosystem (SDTE) aims to secure
the data processing utilizing Ethereum and Intel SGX [10].
Analogous to AGAPECert, SDTE identiﬁes the privacy
implications when sharing complete datasets (sellers are
data sources) with potential buyers or regulators. Instead,
SDTE shares data analysis results processed on top of SGX-
enabled nodes. Only trusted nodes execute data analysis
contracts and the buyer can deploy any contract [10]. SDTE
based their security guarantees mostly on remote attestation
and sealing derived from the Intel SGX architecture. CCF
also utilizes Ethereum and Intel SGX to provide scalable and
conﬁdential blockchain networks [11]. Both solutions com-
pute on-chain, whereas AGAPECert uses off-chain business
logic and certiﬁed pre-approved code—Oblivious Smart
Contracts—that obtain only speciﬁc results from the private
data.

8.3 Secure Energy Trading Ecosystem

Aitzhan and Svetinovic (2018) identiﬁed the problems of
centralized infrastructures [53]. They provided a peer-to-
peer decentralized token-based system that allows a se-
cure energy trading ecosystem. They rely on blockchain
technologies to build their proof of concept. Analogous
to [53], AGAPECert identiﬁes the problems of relying on
a centralized third party; instead, AGAPECert uses DCAP
(Data Center Attestation Primitives) to provide a cus-
tomized remote attestation for particular use cases. More-
over, AGAPECert offers various levels of trust, providing a
ﬂexible and generalizable framework.

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

15

8.4 DeepChain

8.9 Veriﬁable Computation

Weng et al.
introduced DeepChain, a distributed and
collaborative training framework for deep learning [54].
DeepChain relies on the decentralized nature of blockchain
technologies to provide a reward-based mechanism that
can force participants to behave honestly [54]. DeepChain’s
simulator uses Corda as a shared ledger
[54]. Un-
like DeepChain, AGAPECert does not rely entirely on
blockchain technologies to provide auditability of transac-
tions. AGAPECert’s trust model is fundamentally differ-
ent from DeepChain since AGAPECert deﬁnes a trusted
compute engine. DeepChain utilizes a ﬁxed set of smart
contracts, i.e., a trading contract and a processing con-
tract. AGAPECert is generalizable, allowing a myriad of
blockchain technologies through its blockchain-gateway —
i.e., for trust level 3— and the data owner can instantiate
multiple algorithms as OSC in the framework.

8.5 CAFE

CAFE is a cloud-based solution that utilizes hypervisor-
level mechanisms to protect the deployment and execution
of applications [55]. CAFE enables conﬁdential execution
in the cloud and is fundamentally different from Intel
SGX [55]. In contrast, AGAPECert avoids sending data or
code to the cloud; moreover, certiﬁed code—oblivious smart
contracts—controls the algorithms that are allowed to run
on top of private data, protecting data ownership.

8.6 Google’s Asylo framework

Asylo is an open-source framework that shields the in-
tegrity and conﬁdentiality of data and applications through
a conﬁdential computing environment [56]. Asylo’s most
important goal is to make conﬁdential computing easy,
and therefore could be used in future development within
AGAPECert.

8.7 Teechain

Teechain exploits TEEs to provide a layer-two payment
network [57]. Teechain contributes asynchronous blockchain
accesses. Teechain executes off-chain payments on top of
Bitcoin utilizing a peer-to-peer network of TEEs [7], [57].
Teechain is closely related to AGAPECert; however, it is
closely focused on providing an off-chain payment network
speciﬁcally and provides no private data access layer such
as the Trellis framework used by AGAPECert.

8.8 DelegaTEE

DelegaTEE aims to secure ﬁne-grained delegation of rights
and resources utilizing broker delegation on top of TEEs
without revealing access credentials to third parties [58].
Since DelegaTEE allows ﬁne-grained delegation of services
or resources by an owner to a borrower, it can be used
to enhance AGAPECert, enabling a richer interaction of
services in the Certiﬁcation model. DelegaTEE can allow the
sharing of aggregated data (checkpoints) in the case of on-
site audits to verify data and computation.

Cryptographic protocols such as Veriﬁable Computation
(VC) facilitate outsourcing expensive computation kernels
to stronger worker nodes or cloud workers so that the data
owner or client can verify the computation’s result faster
than if the data owner performs the computation itself [59],
[60], [61], [62], [63], [64].

The

objective

of VC —ofﬂoading

computation
while maintaining veriﬁable results— is different
from
AGAPECert’s goal of private automated certiﬁcation
between an owner and regulator. AGAPECert includes a
data owner that computes on its private data in its own
node (or trusted service provider) to ensure data ownership.
AGAPECert abstains from sending data to a public or even
a private network and applies restrictions to the code that
runs inside enclaves. In our model, the code that runs inside
enclaves can be considered as private as it is deployed
to known/trusted nodes. Although VC does not require
trusted hardware to ensure security against malicious
server behavior [60], [61], [62], [63], it was envisioned to
outsource computation [59], [60], and it is meant to send
the data and algorithms to a powerful outsourced/cloud
node, potentially compromising data ownership.

Due to this, VC would introduce drawbacks in the
AGAPECert setting. In particular, cryptographic-based VC
techniques such as Quadratic Arithmetic Programs [60]
and solutions that utilize Fully Homomorphic Encryption
(FHE) [60], [65] introduce large computation overhead [9],
[66] for trusted data owners that compute on their plat-
forms. To verify this, we conducted a small experiment
comparing the implementation of AGAPECert to VC for
a common matrix multiplication task (code available at
https://github.com/agapecert). For this experiment, we
prepared two identical DCsv2-series Microsoft Azure Vir-
tual Machines (VMs), and built the VC use case using
the C++ libsnark library [67]. The algorithm we compare
computes the inner product of two vectors of size n = 100,
using Rank-1 Constraint Systems (R1CS) as in arithmetic
circuit satisﬁability [60]. We ﬁnd that libsnark VC takes
1.049 × 10−1 ± 2.1 × 10−3
seconds to compute the inner
product, while AGAPECert only requires 9.287 × 10−4 ±
9.959 × 10−5
seconds. The performance beneﬁts of using
Intel SGX compared to VC cryptographic-based schemes
has also been noted in recent work [66].

8.10 Commitment schemes

Commitment schemes enable committing to a chosen val-
ue/statement (time ti) while hiding the content from oth-
ers [68]. The commitment schemes can reveal the committed
value later (time tk, where k > i). Commitment schemes
include the commit phase in which a value is chosen and
committed and the reveal phase during which the sender
reveals the value—the receiver veriﬁes its authenticity. The
commit phase can consist of a single message—called com-
mitment. To preserve the hiding property, the value chosen
cannot be known by the receiver. To safeguard the binding
property, the sender can only compute the message cho-
sen during the commit phase—this phase needs a single
message from the sender to the receiver and a veriﬁcation
check performed by the receiver. Commitment schemes can

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

16

be integrated with AGAPECert to provide proof that can be
veriﬁed later. AGAPECert utilizes group signatures schemes
to verify that a particular algorithm was executed inside an
enclave—providing a binding property to a speciﬁc set of
valid processors [26], [27]. The integration of Commitments
schemes in AGAPECert will act as a Zero-Knowledge Proof
to expose Computational Veriﬁable PACs.

An existing framework for the integration of VC with
commitments is described in [64], where Costello et al.
introduce a Commit-and-Prove scheme into their Geppetto
solution for “Versatile Veriﬁable Computation". The authors
identiﬁed the need for a protocol that ensures (i) the cryp-
tographic material respects the semantics of the original
program that they started with and (ii) that there are no
mistakes during the compilation process [69]. In many
real use cases requiring the privacy provided by TEEs, or
other solutions such as FHE and Multi-Party Computation
(MPC), participants are reluctant to provide even encrypted
versions of sensitive data to a public cloud, as would be
the case with VC and commitments. AGAPECert’s trust
model is unique from the current literature in this respect,
utilizing TEEs in a trusted environment while providing
automated code veriﬁcation and private automated certi-
ﬁcations (PACs).

8.11 Solutions based on Secret Sharing

Many protocols based on secret sharing schemes [70] can
be used to solve distributed computing securely on data,
this method signiﬁcantly differs from the trust model and
the problem that AGAPECert wants to tackle. For instance,
Secure Multi-Party Computation allows a set of parties to
perform secure distributed computing [71]. MPC utilizes
Secret Sharing as a building block. A secret sharing scheme
solves the problem of sharing a secret S amongst a set N
of n nodes/parties; the n parties have to share pieces of the
data, and any subset (threshold) of t + 1 can reconstruct the
secret S; however, no subset less than t shares can recon-
struct or learn anything about the secret S. On the contrary,
the AGAPECert Trust model includes a trusted data owner
who computes on its private data to ensure data ownership.
AGAPECert abstains from sending data to a public or even
a private network and applies restrictions to the code that
runs inside enclaves. Due to an increasing set of tools
for Secure Computation utilizing Trusted Hardware, imple-
menting algorithms inside black boxes is straightforward
and increases their deployment and utilization. On the other
hand, Multi-Party Computation requires high expertise for
the correct deployment of applications [71]. Moreover, since
MPC stores data pieces in many locations, the participants
will require communication devices, increasing deployment
costs. Also, in MPC, malicious participants in the protocol
are pre-assumed, which differs from AGAPECert’s trust
model in which the environment is regulated, and the data
owner is considered trusted under threat of a legal challenge
(if a deviation from the protocol is suspected).

9 CONCLUSION AND FUTURE WORK
This paper presented AGAPECert, an auditable, gener-
alized, privacy-enabling certiﬁcate framework that pro-
tects the conﬁdentiality of data, participants, and code.

AGAPECert utilizes a unique mix of blockchain technolo-
gies, trusted execution environments, and a real-time graph-
based API to deﬁne for the ﬁrst time Oblivious Smart
Contracts (OSCs) that generate auditable Private Automated
Certiﬁcations (PACs). AGAPECert offers pragmatic perfor-
mance and is generalizable to many use cases and data
types. AGAPECert has a signiﬁcant impact providing an
open source [72] framework that can be adopted as a stan-
dard in any regulated environment to keep sensitive data
private while enabling an automated workﬂow.

Due to AGAPECert’s malleable architecture, our tech-
nique can be easily extended to provide additional features.
For instance, AGAPECert’s Blockchain-Gateway future re-
leases can utilize concepts deﬁned by Agrawal et al. [47]
to enhance anonymity and privacy when interacting with
a shared ledger. Similarly, AGAPECert’s future releases
can allow homomorphic encryption exposing Homomor-
phic and Oblivious Smart Contracts (HOSC). Integrating
SEAL [46] in AGAPECert will allow a richer set of devices as
compute engines, i.e., sensors, IoT devices, mobile devices,
to name but a few. AGAPECert’s roadmap includes ana-
lyzing and implementing techniques such as VC and Com-
mitment schemes that can act as Zero-Knowledge Proofs.
Finally, we will also analyze the integration of an automated
source code repository for Oblivious Smart Contracts that
can preserve the privacy and ownership of the source code.

10 ACKNOWLEDGEMENT
Sponsorship for this work was provided by Foundation
for Food and Agriculture Research (FFAR) under award
534662.

REFERENCES

[1]

“IBM Food
solutions/food-trust, 2019. [Online; accessed April 16, 2019].

https://www.ibm.com/blockchain/

Trust.”

[2] B.

Pirus,

receives

ﬁrst

USDA

“BeefChain
a

cer-
https://

for

tiﬁcation
company.”
www.forbes.com/sites/benjaminpirus/2019/04/25/
beefchain-receives-ﬁrst-usda-certiﬁcation-for-a-blockchain-company/#
3f678c6c7607, 2019. [Online; accessed April 27, 2019].

blockchain

[3] Lowry, “Lowry Solutions Sonaria Blockchain Platform: Making
IIoT into Blockchain.” https://lowrysolutions.com/, 2019.

[4] Ripe, “Ripe.io: Blockchain of Food.” http://ripe.io, 2019.
[5] OriginTrail, “OriginTrail: Blockchain-powered Data Exchange Pro-
tocol for Interconnected Supply ahains.” http://origintrail.io,
2019.
SAP,
Blockchain
products/leonardo/blockchain.html, 2019.

https://www.sap.com/

Service.”

“SAP:

[6]

[7] M. Brandenburger, C. Cachin, R. Kapitza, and A. Sorniotti,
“Blockchain and trusted computing: Problems, pitfalls, and a
solution for hyperledger fabric,” arXiv, 2018.
J. Ekberg, K. Kostiainen, and N. Asokan, “The untapped poten-
tial of trusted execution environments on mobile devices,” IEEE
Security Privacy, vol. 12, pp. 29–37, July 2014.

[8]

[9] V. Costan and S. Devadas, “Intel SGX Explained,” Cryptology ePrint

Archive, Report 2016/086, 2016.

[10] W. Dai, C. Dai, K. R. Choo, C. Cui, D. Zou, and H. Jin, “Sdte: A se-
cure blockchain-based data trading ecosystem,” IEEE Transactions
on Information Forensics and Security, vol. 15, pp. 725–737, 2020.

[11] M. Russinovich,
tium Blockchain
networks.”
announcing-microsoft-s-coco-framework-for-enterprise-blockchain-networks/,
2017. [Online; accessed June 10, 2019].

the Conﬁdential Consor-
blockchain
for
https://azure.microsoft.com/en-us/blog/

“Announcing
Framework

enterprise

[12] Z. Ray, X. Xun, and W. Lihui, “Food supply chain management:
systems, implementations, and future research,” Industrial Man-
agement & Data Systems, vol. 117, pp. 2085–2114, Jan 2017.

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

17

[13] “Modern Supply Chain Management.” https://www.oracle.
com/webfolder/s/assets/ebook/scm-complete-guide/index.
html, July 2020. Oracle SCM Cloud.

[14] “Managing Performance in Food Supply Chains.” https://www.

rspo.org/ﬁle/QL-FbHU4Hpj.pdf, Feb. 2013. RSPO.

[15] “Chain of Custody Certiﬁcation.” https://us.fsc.org/en-us/
certiﬁcation/chain-of-custody-certiﬁcation, July 2020. FSC.
[16] “The GLOBALG.A.P. Chain of Custody Standard (CoC).” https://
www.globalgap.org/uk_en/for-producers/globalg.a.p./coc/,
July 2020. GlobalGAP.

[17] “Supply

chain

certiﬁcation
msc.org/en-us/for-business/supply-chain-companies/
chain-of-custody-certiﬁcation-guide, July 2020. MSC.

guide.”

https://www.

[18] W. Zheng, A. Dave, J. G. Beekman, R. A. Popa, J. E. Gonzalez,
and I. Stoica, “Opaque: An Oblivious and Encrypted Distributed
Analytics Platform,” Proceedings of the 14th USENIX Symposium on
Networked Systems Design and Implementation (NSDI), 2017.

[19] Trellis, “The Trellis Framework.” https://github.com/trellisfw,

2019.

[20] OADA, “The Open Ag Data Alliance: a API framework for auto-
mated, cross-industry data exchange.” https://github.com/oada,
2019.

[21] Intel, “Intel Software Guard Extensions Documentation.” https://
software.intel.com/en-us/articles/intel-sgx-web-based-training,
2015.

[22] A. J. Menezes, S. A. Vanstone, and P. C. V. Oorschot, Handbook
of Applied Cryptography. Boca Raton, FL, USA: CRC Press, Inc.,
1st ed., 1996.

[23] “Secure

Hash

Standard

(SHS).”

https://www.nist.gov/publications/
secure-hash-standard-shs-includes-change-notice-2252004, Aug.
2002. Federal Inf. Process. Stds. (NIST FIPS) - 180-2.

[39] A. Ahmad, K. Kim, M. I. Sarfaraz, and B. Lee, “Obliviate: A data
oblivious ﬁlesystem for intel sgx,” Network and Distributed System
Security Symposium, 2018.

[40] Y. Xiao, M. Li, S. Chen, and Y. Zhang, “Stacco: Differentially an-
alyzing side-channel traces for detecting ssl/tls vulnerabilities in
secure enclaves,” in Proceedings of the 2017 ACM SIGSAC Conference
on computer and communications security, CCS ’17, pp. 859–874,
ACM, 2017.

[41] W. Wang, G. Chen, X. Pan, Y. Zhang, X. Wang, V. Bindschaedler,
H. Tang, and C. Gunter, “Leaky cauldron on the dark land: Under-
standing memory side-channel hazards in sgx,” in Proceedings of
the 2017 ACM SIGSAC Conference on computer and communications
security, vol. 2017 of CCS ’17, pp. 2421–2434, ACM, 2017.

[42] “L1 Terminal Fault

- Security Advisory.” https://software.

intel.com/security-software-guidance/software-guidance/
l1-terminal-fault, Apr. 2020. Intel.

[43] C. Gentry, A Fully Homomorphic Encryption Scheme. PhD thesis,
Stanford University, Stanford, CA, USA, 2009. AAI3382729.
[44] P. Paillier, “Public-key cryptosystems based on composite degree
residuosity classes,” in Proceedings of the 17th International Con-
ference on Theory and Application of Cryptographic Techniques, EU-
ROCRYPT’99, (Berlin, Heidelberg), pp. 223–238, Springer-Verlag,
1999.

[45] A. J. Paverd and A. C. Martin, “Modelling and automatically
analysing privacy properties for honest-but-curious adversaries,”
2014.

[46] “Microsoft SEAL (release 3.5).” https://github.com/Microsoft/

SEAL, Apr. 2020. Microsoft Research, Redmond, WA.

[47] S. Agrawal, K. B. Bünz, M. Zamani, and D. Boneh, “Blockchain
system for conﬁdential and anonymous smart contracts,” May
2019. US Patent 20190164153.

[48] “OpenEnclave.” https://github.com/openenclave/openenclave,

[24] “Arm TrustZone Technology.” https://developer.arm.com/

2020. [Online; accessed April 20, 2020].

ip-products/security-ip/trustzone, Apr. 2020. ARM.

[25] Intel, “Intel® Software Guard Extensions (Intel® SGX) SDK for
Linux* OS.” https://01.org/intel-softwareguard-extensions, 2019.
“Intel Enhanced Privacy ID Ecosystem.” https://

[26] Intel,

intel-epid-sdk.github.io/ecosystem/, 2017.

[27] “Intel SGX DCAP (release 1.6).” https://download.01.org/

intel-sgx/sgx-dcap/1.6/linux/docs/, Apr. 2020. Intel.

[28] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system”.”

http://bitcoin.org/bitcoin.pdf, 2008.

[29] M. Castro and B. Liskov, “Practical byzantine fault tolerance,” in
Proceedings of the Third Symposium on Operating Systems Design
and Implementation, OSDI ’99, (Berkeley, CA, USA), pp. 173–186,
USENIX Association, 1999.

[30] G. Wood, “Ethereum: A Secure Decentralized Generalized Dis-
tributed Ledger,” Ethereum project yellow paper, vol. 151, pp. 1–32,
2014.

[31] “Neo4j.” https://neo4j.com/, 2020.

[Online; accessed April 16,

2020].

[32] “ArangoDB.” https://www.arangodb.com/, 2019.

[Online; ac-

cessed April 16, 2020].

[33] “An open, feeless data and value transfer protocol.” https://

www.iota.org/, Feb. 2022. Iota.

[34] L. Baird and A. Luykx, “The hashgraph protocol: Efﬁcient asyn-
chronous bft for high-throughput distributed ledgers,” in 2020
International Conference on Omni-layer Intelligent Systems (COINS),
pp. 1–7, 2020.

[35] Trellis, “Trellis Authorization Protocol.” https://github.com/
OADA/oada-docs/blob/master/rest-specs/Authentication_
and_Authorization.md#client-registration, 2016.

[36] J. V. Bulck, M. Minkin, O. Weisse, D. Genkin, B. Kasikci, F. Piessens,
M. Silberstein, T. F. Wenisch, Y. Yarom, and R. Strackx, “Fore-
shadow: Extracting the keys to the intel SGX kingdom with
transient out-of-order execution,” in 27th USENIX Security Sympo-
sium (USENIX Security 18), (Baltimore, MD), p. 991–1008, USENIX
Association, Aug. 2018.

[37] M. Lipp, M. Schwarz, D. Gruss, T. Prescher, W. Haas, A. Fogh,
J. Horn, S. Mangard, P. Kocher, D. Genkin, Y. Yarom, and M. Ham-
burg, “Meltdown: Reading kernel memory from user space,” in
27th USENIX Security Symposium (USENIX Security 18), (Balti-
more, MD), pp. 973–990, USENIX Association, Aug. 2018.

[38] G. Chen, S. Chen, Y. Xiao, Y. Zhang, Z. Lin, and T. H. Lai,
“Sgxpectre: Stealing intel secrets from sgx enclaves via speculative
execution,” in 2019 IEEE European Symposium on Security and
Privacy (EuroS&P), pp. 142–157, IEEE, 2019.

[49] M. Zaharia, M. Chowdhury, T. Das, and A. Dave, “Resilient
distributed datasets: A fault-tolerant abstraction for in-memory
cluster computing,” NSDI’12 Proceedings of the 9th USENIX confer-
ence on Networked Systems Design and Implementation, pp. 2–2, 2012.
[50] O. Weisse, V. Bertacco, and T. Austin, “Regaining lost cycles
with hotcalls: A fast interface for sgx secure enclaves,” in 2017
ACM/IEEE 44th Annual International Symposium on Computer Archi-
tecture (ISCA), vol. 45, pp. 81–93, ACM, 2017.

[51] “Chai NPM Library.” https://www.chaijs.com/, 2020.

[Online;

accessed April 20, 2020].

[52] “Mocha NPM Library.” https://mochajs.org/, 2020.

[Online;

accessed April 20, 2020].

[53] N. Z. Aitzhan and D. Svetinovic, “Security and privacy in decen-
tralized energy trading through multi-signatures, blockchain and
anonymous messaging streams,” IEEE Transactions on Dependable
and Secure Computing, vol. 15, no. 5, pp. 840–852, 2018.

[54] J. Weng, J. Weng, J. Zhang, M. Li, Y. Zhang, and W. Luo,
“Deepchain: Auditable and privacy-preserving deep learning with
blockchain-based incentive,” IEEE Transactions on Dependable and
Secure Computing, pp. 1–1, 2019.

[55] S. Park, C. H. Kim, J. Rhee, J. Won, T. Han, and D. Xu, “Cafe: A
virtualization-based approach to protecting sensitive cloud appli-
cation logic conﬁdentiality,” IEEE Transactions on Dependable and
Secure Computing, vol. 17, no. 4, pp. 883–897, 2020.
Simakov,

[56] N.

and

Porter,

J. Garms,
an open-source

“Introducing
com-
https://cloud.google.com/blog/products/gcp/

Asylo:
puting.”
introducing-asylo-an-open-source-framework-for-conﬁdential-computing,
2018. [Online; accessed May 10, 2019].

S.
framework for

conﬁdential

[57] J. Lind, O. Naor, I. Eyal, F. Kelbert, P. Pietzuch, and E. G.
Sirer, “Teechain: A secure payment network with asynchronous
blockchain access,” 2017.

[58] M. Schneider, S. Matetic, A. Juels, A. Miller, and S. Capkun,
“Secure brokered delegation through delegatee,” IEEE Security &
Privacy, vol. 17, no. 4, pp. 43–52, 2019.

[59] R. Gennaro, C. Gentry, and B. Parno, “Non-interactive veriﬁable
computing: Outsourcing computation to untrusted workers,” in
Advances in Cryptology – CRYPTO 2010 (T. Rabin, ed.), (Berlin,
Heidelberg), pp. 465–482, Springer Berlin Heidelberg, 2010.
[60] B. Parno, J. Howell, C. Gentry, and M. Raykova, “Pinocchio:
Nearly practical veriﬁable computation,” Commun. ACM, vol. 59,
p. 103–112, jan 2016.

[61] M. Walﬁsh and A. J. Blumberg, “Verifying computations without
reexecuting them,” Commun. ACM, vol. 58, p. 74–84, Jan. 2015.

JOURNAL OF DEPENDABLE AND SECURE COMPUTING, VOL. X, NO. Y, JULY 2022

18

[62] S. Avizheh, M. Nabi, R. Safavi-Naini, and M. Venkateswarlu K.,
“Veriﬁable computation using smart contracts,” in Proceedings of
the 2019 ACM SIGSAC Conference on Cloud Computing Security
Workshop, CCSW’19, (New York, NY, USA), p. 17–28, Association
for Computing Machinery, 2019.

[63] A. E. Kosba, D. Papadopoulos, C. Papamanthou, M. F. Sayed,
E. Shi, and N. Triandopoulos, “TRUESET: Faster veriﬁable set
computations,” in 23rd USENIX Security Symposium (USENIX
Security 14), (San Diego, CA), pp. 765–780, USENIX Association,
Aug. 2014.

[64] C. Costello, C. Fournet, J. Howell, M. Kohlweiss, B. Kreuter,
M. Naehrig, B. Parno, and S. Zahur, “Geppetto: Versatile veriﬁable
computation,” in 2015 IEEE Symposium on Security and Privacy,
pp. 253–270, 2015.

[65] X. Yu, Z. Yan, and R. Zhang, “Veriﬁable outsourced computation
over encrypted data,” Information Sciences, vol. 479, pp. 372–385,
2019.

[66] W. Ding, W. Sun, Z. Yan, and R. H. Deng, “An efﬁcient and secure
scheme of veriﬁable computation for intel sgx,” arXiv, 2021.
[67] “libsnark: a c++ library for zksnark proofs.” https://github.com/
scipr-lab/libsnark, 2022. [Online; accessed April 16, 2022].

James V. Krogmeier received the BSEE degree
from the University of Colorado at Boulder and
the MS and Ph.D. degrees from the University of
Illinois at Urbana-Champaign. He has industry
experience in telecommunications, is a founding
member of two software startup companies, and
is the owner-operator of a Colorado wheat and
corn farm. He is currently Professor and Asso-
ciate Head of Electrical and Computer Engineer-
ing at Purdue University in West Lafayette, In-
diana. Professor Krogmeier’s research interests
include the applications of statistical signal and image processing in
agriculture, intelligent transportation systems, sensor networking, and
wireless communications.

[68] A. P. Michael Backes, Aniket Kate, “Computational veriﬁable
secret sharing revisited,” in ASIACRYPT (D. H. Lee and X. Wang,
eds.), vol. 7073 of Lecture Notes in Computer Science, Springer, 2011.
Computation.”

[69] “Geppetto:

Veriﬁable

Versatile

https://www.youtube.com/watch?v=cftfrKc0SWw&ab_
Sept.
channel=IEEESymposiumonSecurityandPrivacy,
IEEE Symposium on Security and Privacy.

2015.

[70] A. Shamir, “How To Share a Secret,” Communications of the ACM

(CACM), vol. 22, pp. 612–613, 1979.

[71] Y. Lindell, “Secure multiparty computation,” Commun. ACM,

vol. 64, p. 86–96, Dec. 2020.

[72] AgapeCert, “AGAPECert.” https://github.com/agapecert, 2020.

Bharat Bhargava is a professor of the Depart-
ment of Computer Science with a courtesy ap-
pointment in the School of Electrical and Com-
puter Engineering at Purdue University. His re-
search focuses on security and privacy issues in
distributed systems. He is a Fellow of the Insti-
tute of Electrical and Electronics Engineers and
of the Institute of Electronics and Telecommuni-
cation Engineers. In 1999, he received the IEEE
Technical Achievement Award for his decade
long contributions to foundations of adaptability
in communication and distributed systems. He serves on seven editorial
boards of international
journals. He also serves the IEEE Computer
Society on Technical Achievement Award and Fellow committees.

Servio Palacios is a Fulbright Scholar and a
Ph.D. candidate with the Department of Com-
puter Science at Purdue University. He holds
an MSc in Computer Science from Purdue Uni-
versity, and a B.S. in Computer Systems from
UNITEC. Servio’s research interests include
graph theory, graph databases, distributed sys-
tems, edge computing, applied cryptography, op-
erating systems, computer networks, distributed
ledgers, blockchain, graph data science, conﬁ-
dential computing, and cybersecurity.

Aaron Ault is currently Senior Research Engi-
neer with the Open Ag Tech and Systems Center
(OATS) at Purdue University. He has contributed
to projects across the computing and agricultural
spectrum over the past 15 years, including signal
processing, data science, embedded systems,
software engineering, wireless sensor networks,
scalable distributed cloud architectures, and mo-
bile and web applications.

Christopher G. Brinton (SM’20) is an Assis-
tant Professor in the School of Electrical and
Computer Engineering (ECE) at Purdue Univer-
sity. Previously he was the Associate Director
of the EDGE Lab and a Lecturer of Electrical
Engineering at Princeton University. Dr. Brinton’s
research interest is at the intersection of data
science and networking, speciﬁcally in develop-
ing data-driven optimization methodologies for
communication and social networks. He is a co-
founder of Zoomi Inc., a big data startup com-
pany that has provided employee performance optimization for more
than one million users, and a co-author of the book The Power of
Networks: 6 Principles That Connect our Lives.

