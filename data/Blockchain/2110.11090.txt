1
2
0
2

t
c
O
1
2

]

C
D
.
s
c
[

1
v
0
9
0
1
1
.
0
1
1
2
:
v
i
X
r
a

Blockchain-based Result Veriﬁcation for
Computation Oﬄoading

Benjamin K¨orbel, Marten Sigwart, Philip Frauenthaler, Michael Sober, and
Stefan Schulte[0000−0001−6828−9945]

Christian Doppler Laboratory for Blockchain Technologies for the Internet of Things
TU Hamburg, Germany; TU Wien, Austria
{michael.sober|stefan.schulte}@tuhh.de
https://www.cdl-bot.at

NOTICE: This is the authors’ version of the accepted manuscript at the 19th
International Conference on Service Oriented Computing. Please cite as: Ben-
jamin K¨orbel, Marten Sigwart, Philip Frauenthaler, Michael Sober,
Stefan Schulte: Blockchain-based Result Veriﬁcation for Computation
Oﬄoading. 19th International Conference on Service Oriented Com-
puting (ICSOC), 2021.

Abstract. Oﬄoading of computation, e.g., to the cloud, is today a
major task in distributed systems. Usually, consumers which apply oﬀ-
loading have to trust that a particular functionality oﬀered by a service
provider is delivering correct results. While redundancy (i.e., oﬄoading
a task to more than one service provider) or (partial) reprocessing help
to identify correct results, they also lead to signiﬁcantly higher cost.
Hence, within this paper, we present an approach to verify the results
of oﬀchain computations via the blockchain. For this, we apply zero-
knowledge proofs to provide evidence that results are correct. Using our
approach, it is possible to establish trust between a service consumer
and arbitrary service providers. We evaluate our approach using a very
well-known example task, i.e., the Traveling Salesman Problem.

Keywords: Oﬄoading · Veriﬁcation · Blockchain.

1

Introduction

Oﬄoading of computational tasks has gained a lot of research attention in re-
cent years [18]. The basic idea of oﬄoading is that a client device outsources
resource-intensive computational tasks to providers, often in exchange for a
fee [13]. Hence, when oﬄoading tasks, two parties are involved. Task issuers
(i.e., service consumers) potentially have limited computational capabilities and
therefore are interested in outsourcing particular tasks. Conversely, task pro-
cessors (i.e., service providers) may have idle computational resources and oﬀer
their CPU-cycles and further computational resources to process these tasks.
Typical examples are the oﬄoading of data processing tasks from lightweight
Internet of Things (IoT) or mobile devices in order to decrease processing time

 
 
 
 
 
 
2

B. K¨orbel et al.

or to save energy [24]. For instance, machine learning, (combinatorial) optimiza-
tion tasks, or the application of heuristics (e.g., genetic algorithms) to solve a
complex problem require often resources not available to a potential service con-
sumer. Apart from overcoming limited computational resources, scalability and
fault tolerance are also major reasons why oﬄoading is applied [10].

Oﬄoading can be done to resources following the Infrastructure-as-a-Service
(IaaS), Platform-as-a-Service (PaaS), or Software-as-a-Service (SaaS) models,
depending on the needs of the service consumer. Traditionally, computation oﬀ-
loading leverages the cloud, e.g., [16], but more recently, oﬄoading to resources
at the edge of the network has also been widely discussed, e.g., [12].

Regardless of the technological setting, oﬄoading requires a client to trust the
service provider to deliver correct results. This is a major market entry barrier,
since service consumers naturally trust well-known service providers more than
new market participants.

In order to avoid reliance on a particular provider, the usage of blockchain
technologies for task oﬄoading has previously been discussed [23]. In such ap-
proaches (e.g., Golem or iExec—see Section 2), the blockchain is a service broker,
which brings together consumers and providers, and often delivers further func-
tionalities, e.g., automated settlement after the oﬄoading task has been carried
out. Also, the oﬄoading results are delivered through the blockchain.

However, to the best of our knowledge, none of the existing approaches per-
forms a check of the correctness of the delivered results. Ideally, before service
consumers pay the service providers for their work, they have an assurance that
the returned results can be fully trusted. Previous studies are aware of this issue
and discuss solutions based on, e.g., redundant computing, reprocessing frac-
tions of a task locally, or reputation-based systems in order to ensure correct
results [3,6,20]. While these approaches may reduce the risk of receiving wrong
results, they cannot proof that a result is correct [23]. In other, non-blockchain
solutions, the user needs to trust a third party which provides functionalities
ensuring trust in the oﬄoading results, e.g., [17].

Furthermore, it should be noted that many oﬄoading tasks do not deliver a
deterministic result. For instance, if oﬄoading machine learning tasks or heuris-
tics to solve NP-complete problems, the computation results can diﬀer. This
further complicates checking the correctness of a result, since redundant com-
puting or partial reprocessing may lead to diﬀerent results.

Within the work at hand, we address this issue by conceptualizing, imple-
menting, and evaluating a blockchain-based oﬄoading approach that can prove
the proper execution of a particular computation task. By using a blockchain,
we dissolve the dependency on a trusted third party. Using a public blockchain
also helps to achieve transparency, since information about the oﬀ-chaining pro-
cedure is publicly available. To prove the correctness of computational results,
we apply zero-knowledge proofs (ZKPs). We evaluate our approach using the
well-known Traveling Salesman Problem (TSP), showing in which use case areas
the proposed solution is beneﬁcial if compared to other alternative approaches,
and assessing the cost and time overhead of our approach.

Blockchain-based Result Veriﬁcation for Computation Oﬄoading

3

In brief, we provide the following contributions in this paper:

– We assess approaches to ensure trust in results provided by service providers.
– We discuss the utilization of ZKPs and blockchain technologies in order to

verify the results for oﬄoaded tasks.

– We design and implement a blockchain-based solution for computation oﬀ-

loading with result veriﬁcation.

– We apply the TSP as a running example and in order to evaluate the over-

head resulting from the presented approach.

The remainder of this paper is organized as follows: In Section 2, we discuss the
related work. In Section 3, we assess diﬀerent approaches to verify the results
of oﬄoaded computation tasks. Based on this, we present our design and im-
plementation in Section 4. Section 5 shows the results of the evaluation of the
presented work, and Section 6 concludes this paper.

2 Related Work

To the best of our knowledge, the ﬁeld of blockchain-based, veriﬁable task oﬀ-
loading is still a novel research area, and not too many approaches have been
presented so far.

Golem [20], iExec [6], and SONM [21] are three commercial solutions, aim-
ing at decentralizing oﬄoading to the cloud [23]. Their respective primary goal
is to provide solutions to decrease market entry barriers, by allowing arbitrary
providers to oﬀer computational resources on a blockchain, and arbitrary con-
sumers to use these resources. Notably, the intended providers of cloud resources
are not large-scale data centers, but could be anyone with idle computational
resources. Golem, iExec and SONM aim at providing marketplace and broker
functionalities, and apply a pay-per-use model, i.e., the consumer has to pay for
using computational infrastructure or for processing a particular task. Notably,
in contrast to the work at hand, which focuses on a SaaS model, these solutions
aim at providing computing power in general, i.e., on the IaaS level.

With regard to result veriﬁcation, Golem supports redundant computation,
but also allows to recompute fractions of an oﬄoaded task locally (i.e., at the
service consumer’s side), and to subsequently compare the results. Also, Golem
implements a reputation mechanism, which is based on consumer (e.g., late
payments) and provider behavior (e.g., not delivering results in time), respec-
tively [20]. iExec applies a similar approach, where the service consumer can
deﬁne the needed reliability of the results. If this value is high, a higher degree
of redundancy is applied when computing the oﬄoading tasks, and more reliable
providers, i.e., with a high reputation, are selected. Notably, iExec also allows
to support Software Guard Extension (SGX), which is a kind of enclave-based
oﬀ-chain computations (see Section 3) [6]. So far, SONM does not implement a
veriﬁcation mechanism, but names reputation management as a major enabler
to provide reliable computation results [21].

4

B. K¨orbel et al.

None of the so-far discussed approaches provides a proof that the results
of a computation are correct. Instead, redundant computations, recomputing
fractions of tasks locally, and reputation-based methods only decrease the risk
that the results are not correct. Especially redundant computations also increase
the cost by quite some degree, since all involved service providers charge a fee
for the computations. Reputation systems can be helpful, but provide market
entry barriers since new service providers need to build a reputation. Also, it
remains unclear how these solutions handle results which are not deterministic,
e.g., for machine learning or heuristic tasks.

FlopCoin [3] is a blockchain-based oﬄoading framework with a decentralized
incentive and reputation scheme. Among other metrics, the reputation of par-
ticipants is used as input for the oﬄoading decision, i.e., to which provider of
computational resources a particular task is oﬄoaded. EdgeChain [14] uses a
blockchain and smart contracts to link computational resources at the edge and
IoT devices which need to oﬄoad tasks. The blockchain is used to monitor the
oﬄoading procedure and to conduct payments. A mechanism to detect malicious
nodes based on past behavior is also introduced. Qiu et al. [15] discuss a similar
approach, but apply deep reinforcement learning to ﬁnd an assignment of tasks
and available edge resources. Very recently, another approach for oﬄoading to
the fog has been presented by Wu et al. [25]. The focus of this work is also on
the actual decision making, i.e., where to place which oﬄoaded task. In contrast,
we aim primarily on proving that computed results are valid.

To the best of our knowledge, none of the discussed research papers directly
address oﬄoading result veriﬁcation. Hence, the work at hand complements ex-
isting work, and could be used within existing solutions in order to proof that
an oﬄoaded computation provides valid results.

3 Result Veriﬁcation for Oﬄoaded Tasks

As discussed above, it is the goal of the work at hand to provide mechanisms that
can verify results of oﬄoaded computational tasks. In general, we focus on the
SaaS model, but in fact, result veriﬁcation could also be done for user-deployed
services using the IaaS or PaaS model.

To achieve result veriﬁcation, diﬀerent schemes could be applied: Veriﬁable
oﬀ-chain computation entails the provisioning of cryptographic proofs that wit-
ness correct processing. After a computation is performed, a cryptographic proof
is generated and published together with the result on a blockchain by the pro-
cessor (here: the service provider). Subsequently, the validity of the computation
can be veriﬁed on-chain using a smart contract [4].

Veriﬁable oﬀ-chain computation can be realized using ZKPs [7]. The basic
idea behind ZKPs is to convince someone that a statement is true without re-
vealing any underlying information needed to proof that the statement is true.
This allows to hide the input data for a proof and therefore supports data pri-
vacy. Importantly, in the scenario at hand, this facilitates the veriﬁcation that
the results delivered by a service provider are correct, without the need that the

Blockchain-based Result Veriﬁcation for Computation Oﬄoading

5

provider reveals its applied service or algorithm. Hence, the computation per-
formed by the service provider remains a blackbox from the perspective of result
veriﬁcation. This is even the case for non-deterministic computations, e.g., if a
heuristic is applied. As long as it is possible to deﬁne rules which describe if an
oﬄoading result is valid, ZKPs can be applied successfully.

ZKPs can be realized in the form of Zero-Knowledge Non-Interactive Succinct
Arguments of Knowledge (zk-SNARKs), Zero-Knowledge Scalable Transparent
Arguments of Knowledge (zk-STARKs), and Bulletproofs [9].

zk-SNARKs are non-interactive and provide relatively cheap veriﬁcation by
their succinctness. Before generating a proof and performing the veriﬁcation step,
a one-time setup must be carried out by a trusted party. Unlike zk-SNARKs,
zk-STARKs and Bulletproofs do not require a trusted one-time setup. In zk-
SNARKs and Bulletproofs, computations are abstracted with arithmetic cir-
cuits, while zk-STARKs leverage higher degree polynomials. Both zk-STARKs
and Bulletproofs feature growing proof-size and on-chain veriﬁcation, while zk-
SNARKs are independent of the task complexity and provide compact proves [4].
Due to the succinctness of zk-SNARKs, very short proofs (i.e., in the range of
bytes) can be provided, which is very beneﬁcial when blockchain technology is
involved. Therefore, we decided to apply zk-SNARKs for result veriﬁcation.

We have also investigated other result veriﬁcation schemes: For instance,
Secure Multiparty Computation (SMPC) protocols enable the construction of
privacy-preserving oﬀ-chain computation schemes, but are accompanied by high
overhead [4]. Enclave-based oﬀ-chain computation relies on Trusted Execution
Environments (TEEs) which enable code execution while preserving conﬁden-
tiality and integrity. The enclave-based scheme allows universal computations
but has potential security issues [8,19]. Incentive-driven oﬀ-chain computing re-
wards nodes which are doing veriﬁcation work to check if a computation is
correct. One implementation of this scheme is TrueBit [22]. A challenge when
using the described scheme is to keep nodes motivated for performing veriﬁca-
tions continuously. Also, the throughput of completed computation tasks and
the general service can be hindered by malicious veriﬁers by marking each com-
putation result as faulty [4].

The selection of zk-SNARKs allows us to make use of the ZoKrates tool-
box [5], which supports the entire process of specifying, integrating and deploying
ZKPs on Ethereum-based blockchains. The toolbox consists of a Domain-speciﬁc
Language (DSL), a compiler and generators for proofs as well as smart contracts
for veriﬁcation. In brief, ZoKrates can be used to execute a computational task
oﬀ-chain. Afterwards, the result of the computation (here: of an oﬄoading task)
and the corresponding proof are written back on a blockchain. The proof that
attests correct (or incorrect) computation can then be veriﬁed on-chain. There-
fore, the computational eﬀort on a blockchain is reduced, while privacy can be
preserved due to the usage of ZKPs.

6

B. K¨orbel et al.

Broker
Smart Contract

Verification
Smart Contract

Service Consumer

Service Provider

Blockchain

Fig. 1: Blockchain-based computation oﬄoading with result veriﬁcation

4 Design and Implementation

4.1 Overview

After having selected zk-SNARKs as the underlying approach to provide result
veriﬁcation for computation oﬄoading, we are now able to design a solution.

As discussed before, we make use of a blockchain-based approach to oﬄoad
tasks to service providers. While this has been proposed before (see Section 2),
there is lack of solutions which allow to verify the results delivered by the service
providers. Due to space constraints, we focus on this particular functionality in
the work at hand. However, we have in fact designed and implemented a frame-
work which covers the necessary functionality stack, i.e., acts as a blockchain-
based broker for service consumers (oﬄoaders) and service providers, and imple-
ments an incentive structure, so that fees can be charged and are automatically
paid if a result has been veriﬁed. Notably, while the implemented solution can
be used by traditional cloud providers to oﬀer their resources and services, it
could also be used in fog and edge settings, or by private persons who want to
oﬀer spare computational resources.

In the case of non-deterministic results, e.g., since a heuristic is applied by
a service provider (see Section 1), our framework allows to obtain results from
diﬀerent providers and to compare the result quality. The integration of methods
to assess the result quality is part of our future work (see Section 6).

Figure 1 shows the components of the software solution. As it can be seen,
the system consists of the service consumer (i.e., the client software for the
task oﬄoader), the service provider (i.e., the according client software), the bro-
ker smart contract and the result veriﬁcation smart contract. In the following
subsections, we discuss the core components with a focus on the veriﬁcation
functionalities.

4.2 Blockchain-based Brokering and Result Veriﬁcation

The blockchain serves two major purposes in our scenario: First, it acts as a
broker during the oﬄoading process, i.e., facilitates the cooperation between a
service consumer and a service provider. This includes provisioning of results to
the service consumer and payment to the service provider. Second, the blockchain

Blockchain-based Result Veriﬁcation for Computation Oﬄoading

7

delivers the result veriﬁcation (see Section 4.4). Following the approach presented
in this work, no preexisting relationship and no position of trust between a service
consumer and potential service providers need to exist.

Brokering functionalities and result veriﬁcation are implemented using smart
contracts. Within the work at hand, we use Ethereum for this, since it provides
a broad acceptance in the research community as well as industry. It should be
noted that the presented approach is per se protocol-agnostic, and could also be
implemented using a permissioned blockchain like Hyperledger Fabric. However,
we opted to use a public blockchain in the work at hand.

4.3 Broker Smart Contract

submitSolution()
getTaskRequest()

retrieveSolution()

ready

createTaskRequest()

running

endTask()

ended

Fig. 2: Simpliﬁed state diagram of the broker smart contract

Figure 2 provides an overview of the states the broker smart contract passes
through. As it can be seen in the state diagram, the contract may be in the
states ready, running, and ended. For the transition between the states, particular
functions must be called. Before any interaction is possible, i.e., any function is
callable, the smart contract needs to be deployed on the blockchain. After the
deployment, it is in state ready. At this point, a service consumer can create a
new request for oﬄoading, i.e., a new oﬄoading task, using createTaskRequest().
The necessary inputs for createTaskRequest() are a stake, which is used as
a deposit for the later payment to the service provider, information about the
oﬄoaded task, and a boolean value if the result should be veriﬁed or not. Once
this has been done, the state changes to running.

At this point of time, a potential service provider can retrieve all the neces-
sary information to process the task by calling getTaskRequest(). Notably, the
selection of the service provider could follow diﬀerent patterns, e.g., based on
reputation and/or load balancing as proposed in the related work (see Section 2),
by applying a reverse auction so that potential service providers compete for the
requests, or other allocation techniques.

Since this is not in the focus of the work at hand, we implement a simpliﬁed
approach, i.e., once a service provider has computed a result, it can be published
using submitSolution(). When calling this function, the service provider needs
to deliver the actual solution to the request. At this point, network participants
including the service consumer can see the submitted solution due to the public
nature of the blockchain. To circumvent that a service consumer reads the result
and does not pay the provider, the stake deposited by the consumer is used.

8

B. K¨orbel et al.

submit verifiable Solution

verify Solution

successful?
Y

N

store Solution on-chain

Fig. 3: High level process of the result veriﬁcation

service provider 
decides to participate

get task

compute solution 
locally

compute witness

N

Y

witness ok?

generate proof

submit solution
& proof

verify solution

N

Y

verification ok?

submission sucessful

submission failed

Fig. 4: Result veriﬁcation procedure

Any network participant (here: the service consumer or the service providers)
may close the task by using endTask(), which also means that the state changes
to ended and that the payment to the service provider is triggered. Notably, this
is only possible once a minimum duration has passed, which is also deﬁned by
the service consumer. When the task is ended, the service consumer can collect
the solution by calling the function retrieveSolution(). As written before, the
consumer could also read the result simply from the blockchain. We explicitly
foresee retrieveSolution() as the possibility to implement a more sophisticated
function here, e.g., to encrypt and decrypt the result in order to not release the
solution publicly on the blockchain, or to provide the solution via a blockchain-
external data storage like the InterPlanetary File System (IFPS) [11], in order
to save gas cost.

4.4 Result Veriﬁcation

Figure 3 gives a high level overview of result veriﬁcation within our approach.
As it can be seen, solutions of veriﬁable tasks are written to the blockchain only
if the result veriﬁcation is successful. Otherwise, the submission is discarded.
The activity verify Solution is part of the result veriﬁcation while all other ac-
tivities in Figure 3 belong to the broker smart contract discussed in Section 4.3.
The veriﬁcation is performed within a separate smart contract generated by
ZoKrates. Therefore, the broker smart contract has to trigger the veriﬁcation
function verifyTx() in the veriﬁcation smart contract. An example implementa-
tion of verifyTx() is discussed in Section 4.6.

The procedure of the result veriﬁcation is illustrated in Figure 4. First, a
service provider decides to contribute to a particular oﬄoading task, which is
the start event for the result veriﬁcation. For this, the provider retrieves all
relevant input data. Based on that, the service provider computes the task locally
(and therefore oﬀ-chain) with a service running on the provider’s computational
resources. After a solution has been found, a witness has to be computed. This
means that a program speciﬁed in DSL code is run with the service provider’s

Blockchain-based Result Veriﬁcation for Computation Oﬄoading

9

result as input; this DSL program is providing important input for the ZoKrates
toolbox as discussed in more detail in Section 4.6. If the veriﬁcation succeeds,
the DSL program returns a witness that proves proper computation. Otherwise,
it can be assumed that an error occurred during the computation phase or a
wrong result has been entered. In this case, the computation is repeated. If the
computation fails again, the procedure ends unsuccessfully (not shown in Fig. 4).
Based on the witness, a proof can be generated, which is needed for the on-
chain veriﬁcation in the next step. Both actions, compute witness and generate
proof are performed locally on the service provider’s hardware. Afterwards, the
solution and the proof can be submitted to the broker smart contract. When a
solution is submitted, the broker smart contract calls the veriﬁcation function
verifyTx() of the veriﬁcation smart contract. If the veriﬁcation function returns
true, we can assume that the computation has been executed honestly. As a
result, the solution is stored on-chain. Otherwise, if false is returned, the sub-
mission of the service provider is discarded entirely. In both cases, the procedure
subsequently ends.

4.5 Implementing Result Veriﬁcation for Speciﬁc Use Cases

Result veriﬁcation is naturally tied to speciﬁc computation problems. This means
that a certain part of the result veriﬁcation, more speciﬁcally the DSL program
implemented using the ZoKrates toolbox, is not generic and must be adapted
whenever a diﬀerent computation problem has to be served.

Accordingly, the DSL code contains appropriate checks to prove that a com-
putation is done correctly. The possibility of creating or adopting these programs
enables ﬂexibility and adds universal applicability to the result veriﬁcation. In
other words, new use cases can be added and thus potential demands of service
consumers for new computation problems can be met. The mandatory steps to
add a new use case are depicted in Figure 5.

To verify results of a speciﬁc computation problem, several one-time prepa-
ration steps have to be conducted. As indicated, a program in form of DSL code
has to be written. Within the DSL program, some logic, e.g., conditions, has
to be speciﬁed, which makes the solution for a speciﬁc problem true. The DSL
program takes a number of inputs (depending on the use case) and veriﬁes if all
speciﬁed conditions are met. Consider the oﬄoading task of calculating the sum
of two integers. In this case, the equation a + b = c must hold and has to be
encoded in the DSL. In general, an arbitrary task can be veriﬁed, as long as it is
possible to deﬁne a rule that the result has to follow. As described in Section 3,
for this, the service provider does not have to disclose any information about the
applied algorithm or method.

Then, keys and the veriﬁcation smart contract have to be generated. For
the keys, this means that a trusted setup is necessary. In the work at hand,
we assume that the trusted setup is performed by the developers of the smart
contracts presented in Section 4.2. Afterwards, the on-chain veriﬁcation for the
speciﬁc computation problem is ready for deployment. Alternatively, a multi-

10

B. K¨orbel et al.

new use case
required

new use case
added

DSL code

trusted setup

verification 
smart contract

integration 
broker smart contract

deployment

Fig. 5: Process for adding result veriﬁcation for additional use cases

party computation protocol could be applied, e.g., [2], that prevent fake proofs
as long as one participant is honest.

When the result veriﬁcation scheme is integrated into the broker smart con-
tract, the inputs of the function submitSolution(), as well as the storage format
for solutions of the new problem, should be kept in mind. Under certain cir-
cumstances, it can be useful to draw up a detached broker smart contract for
each use case. In this case, the basic functions of the broker smart contract,
e.g., getTaskRequest() can be copied, but use case-speciﬁc data, e.g., necessary
ﬁelds for the problem instance and solutions, must be considered and adapted
as well. Furthermore, the function submitSolution() that also calls verifyTx()
of the veriﬁcation smart contract has to be tailored. A separation per use case
would lead to more compact code artifacts and better maintenance. However, to
simplify the description of our solution approach, we only discuss the usage of
one broker smart contract in this paper.

When a new use case is added, the main eﬀort consists of rewriting the DSL
program and integrating the veriﬁcation smart contract into the broker smart
contract. The aforementioned trusted setup and creation of the veriﬁcation smart
contract is mainly handled by the ZoKrates toolbox. The deployment of new
smart contracts is tool-supported as well. This means that merely predeﬁned
commands have to be executed.

4.6 Example Implementation

To demonstrate how our blockchain-based oﬄoading approach with result veri-
ﬁcation can be adopted to speciﬁc use cases, we describe the process of imple-
menting an exemplary use case based on the TSP.

The TSP is selected since it is very well-known among computer scientists,
and easy to understand, but actually hard to compute. In brief, the TSP de-
scribes the problem to ﬁnd the shortest path to travel a predeﬁned number of
cities and to return back to the origin city, but visiting any other city only once.
As input, a list of cities and the distances between each pair of cities are given [1].
Once a solution to the TSP has been found, its validity can be veriﬁed in little
time, e.g., by traversing the path of a solution. Interestingly, it is also easy to
assess the quality of the solution, i.e., by comparing the computed path length.
The TSP is an NP-hard problem, which also opens interesting future research
direction (see Section 6). Notably, the TSP is merely used as an exemplary use
case in the work at hand. The presented approach explicitly allows to verify

Blockchain-based Result Veriﬁcation for Computation Oﬄoading

11

Alg. 1: Main function of the DSL program

def main (
private field [10] path , private field mapnumber , field sum ,
private field [10] cities , field [2] hashOfCities , field [2] h a s h O f P a t h
) -> ( field ):

1 == b a s i c I n p u t C h e c k( path , cities , m a p n u m b e r)
1 == c h e c k C i t i e s( path , cities , m a p n u m b e r)
sum == c a l c u l a t e S u m( path , m a p n u m b e r)

field [2] h a s h e d P a t h = hash ( concat ( path ))
h a s h O f P a t h [0] == h a s h e d P a t h [0]
h a s h O f P a t h [1] == h a s h e d P a t h [1]

field [2] h a s h e d C i t i e s = hash ( concat ( cities ))
h a s h O f C i t i e s [0] == h a s h e d C i t i e s [0]
h a s h O f C i t i e s [1] == h a s h e d C i t i e s [1]

return 1

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

other tasks as well. The according implementation including the broker smart
contract can be found at Github1.

There are some restrictions which have to be taken into account because of
the applied ZoKrates toolbox. First, the toolbox only supports numbers, i.e.,
cities in the TSP have to be represented by numbers, not by their names. Sec-
ond, ZoKrates does not support any dynamic ﬁelds. Accordingly, the size of
an array needs to be deﬁned at compile time. Both constraints complicate the
implementation a little bit, but do not lead to any signiﬁcant restrictions. We
discuss the impact of the ﬁxed array sizes also in the evaluation in Section 5.

As described in Section 4.5, the result veriﬁcation is based on a DSL which
proves program inputs against deﬁned checks. With regard to the TSP, the
result veriﬁcation has to verify whether a solution has been computed properly.
In other words, service providers need to prove that they have found a valid
solution for an TSP instance. To accomplish that, the produced path has to
be Hamiltonian (i.e., each city appears exactly once in the path) and the path
length must correspond to the sum of the connections between the cities on the
basis of the path and the given distances [1]. As input, the map of cities for
the TSP has to be deﬁned, including the cities (represented by numbers) and
the distances between the cities, i.e., a complete graph made up from vertices
(cities) and edges (distances) between the vertices. This data structure can be
stored as an array within the DSL program.

In the following paragraphs, we discuss the example given in Algorithm 1.
To verify that a service provider has computed a correct result, the following
information needs to be provided (lines 2–3): (i) The computed path, consisting
of a sequence of numbers representing cities, (ii) an ID mapnumber for the map
which has been used for solving the TSP instance (this allows to use diﬀerent
maps with the TSP), (iii) the computed length of the path sum, (iv) the cities

1 https://github.com/ben2048/blockchainBasedComputationOffloading

12

B. K¨orbel et al.

for which the minimal distance has been computed, and (v) the hashed path
hashOfPath and the hashed cities hashOfCities. As it can be seen, the example
allows a maximum of ten cities on a path, but other lengths are also possible.

The path and the map are needed to calculate the distance and to compare it
with the stated length (i.e., the result) from the service provider. Path and cities
are used to determine if all cities are covered exactly once in a path. The hashed
path is necessary to prevent malicious behavior originating from the service
provider when submitting a solution. Without the hash, it would be possible to
decouple the proof from the path. In other words, if the service provider submits
a valid proof but an invalid path, it possibly cannot be detected on-chain, i.e.,
the result veriﬁcation would succeed even though an incorrect path would be
stored on the blockchain. To recognize and prevent such scenarios, we compare
the hash and the path within the DSL program and in the broker smart contract.
As it can be seen, the main function ﬁrst performs an input check (line 6).
This is done in order to sort out solutions with invalid indices or map numbers.
Next, it is checked if the stated path contains each city exactly once (line 7),
i.e., if the path is Hamiltonian. Afterwards, it is checked if the stated path
length (ﬁeld sum in line 8) is equal to the sum resulting from the distances of
the stated path based on the distances between cities, i.e., the map. Then, it is
necessary to embed the hash of the path in the veriﬁcation procedure (lines 10–
12). Therefore, the hash of the path is needed as input. Consequently, we have to
compute the hash of the stated path and compare it with the input, to prevent
the aforementioned malicious action. For this, we utilize the implementation of
SHA256 provided by ZoKrates.

As discussed before, the DSL program shown in Alg. 1 runs oﬀ-chain, while
the veriﬁcation function verifyTx() is carried out on-chain. Notably, the number
of inputs of verifyTx() is a cost factor. With regard to our use case and the
speciﬁcation of the input parameters in the DSL program, the number of cities
scales with the instance size. This becomes a crucial cost factor, since the gas
cost rise linearly with the number of public inputs provided. Hence, we make
use of the hashed cities instead of the number of cities. This allows to make the
cities a private input, but also makes it necessary to check the hash of the cities
(lines 14–16), analogue to lines 10–12.

Based on the DSL program, ZoKrates is able to deﬁne verifyTx() as depicted
in Algorithm 2. The input array consists of the path length, hash values for
the path and the cities plus the expected return value of the DSL program
(lines 2–3). Afterwards, a new proof is instantiated (line 5). Then, verifyTx()
requires three elliptic curve points in form of the arrays a, b, c (lines 6–8). These
elliptic curve points actually make the zk-SNARKs proof and are delivered via
the DSL program by the ZoKrates toolbox. Hence, the developer who integrates
verifyTx() does not have to take care of the actual proofs, which is a major
reason for using the ZoKrates toolbox.

The array input depicts the public inputs and the expected return value of
the DSL code, and is used to ﬁll the inputValues (lines 9–12). Afterwards, the
actual veriﬁcation is carried out (line 13). In the case of a successful veriﬁcation,

Blockchain-based Result Veriﬁcation for Computation Oﬄoading

13

Alg. 2: verifyTx()

function verifyTx (
uint [2] memory a , uint [2][2] memory b ,
uint [2] memory c , uint [6] memory input
) public returns ( bool r ) {

Proof memory proof ;
proof . a = Pairing . G1Point ( a [0] , a [1]);
proof . b = Pairing . G2Point ([ b [0][0] , b [0][1]] , [ b [1][0] , b [ 1 ] [ 1 ] ] ) ;
proof . c = Pairing . G1Point ( c [0] , c [1]);
uint [] memory i n p u t V a l u e s = new uint []( input . length );
for ( uint i = 0; i < input . length ; i ++){

i n p u t V a l u e s[ i ] = input [ i ];

}
if ( verify ( inputValues , proof ) == 0) {

return true ;

} else {

return false ;

}

}

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

the boolean true is returned (line 14), else, the boolean false is returned (line
16). Thus, a service consumer can be sure that a result is valid (or not), and
the broker smart contract could carry out the payment. Notably, since only the
proof is published on the blockchain, no conclusions regarding the computation
and concrete results are possible. This ensures the privacy property regarding
the proof. However, as written above, the solution is still available on the chain.
To avoid this, a solution could be encrypted (see Section 4.3).

5 Evaluation

5.1 Evaluation Setup

In order to evaluate the presented approach, we measure the overhead (regarding
time and cost) occurring because of result veriﬁcation.

As mentioned in Section 4, the computation oﬄoading consists of an on-chain
and an oﬀ-chain part. To evaluate the on-chain activities, the smart contracts
have been deployed in a local Ethereum blockchain (using Truﬄe), while for the
oﬀ-chain activities, ZoKrates has been installed locally in a Docker container.

5.2 Overhead Analysis

The result veriﬁcation is part of the solution submission process as presented in
Sections 4.3 and 4.4. Hence, in order to evaluate the overhead with regard to
gas cost and time, we implemented a second submitSolution() function in the
broker smart contract. However, this version of the function does not verify the
submitted solution. This allows us to compare the gas and time consumption
of a benchmark with the according values of our zk-SNARKs-based veriﬁcation
approach. As a second benchmark, we conduct an on-chain result veriﬁcation,

14

B. K¨orbel et al.

submit-with-ver. (map 70)
submit-without-ver. (map 70)
submitSolution-onChain

·106

4.5

4

3.5

3

2.5

2

1.5

1

0.5

s
a
G

0

0

10

20

30

40

50

60

Instance size

Fig. 6: Gas consumption

i.e., a solution for a TSP instance is veriﬁed by a separate smart contract de-
ployed on the blockchain. We apply two maps with size 30 and 70, respectively,
in order to see how the map size (i.e., number of cities) inﬂuences the results. To
get a complete picture of the cost overhead, TSP instance sizes between 3 and
30 (map 30 ) respectively 3 and 60 (map 70 ) are used.

The results regarding the cost for map 70 are shown in Figure 6. Not surpris-
ingly, the gas consumption with veriﬁcation is higher than without veriﬁcation. If
no veriﬁcation is done, there is no diﬀerence between the two maps. Hence, there
is only one plot for the oﬄoading without veriﬁcation. Actually, this benchmark
also indicates how big the cost become if redundant computation is used (see
Section 2). In that case, based on the level of redundancy, each submitted solu-
tion leads to the same cost. In addition, some overhead for the comparison (e.g.,
majority voting) of the results needs to be taken into account. This shows that
redundant computing is not really an option with regard to the gas consumption
for the solution submission.

While not shown in the ﬁgure in order not to overload the plot, the submission
of solutions based on the smaller map (with 30 cities) is marginally cheaper than
solutions based on the larger map (with 70 cities).

It can also be seen that verifying TSP solutions on-chain (submitSolution-
onChain) is cheaper than the approach presented in this work for small instances,
but more expensive for large ones. Up to an instance size of 29, the on-chain
veriﬁcation is cheaper than applying zk-SNARKs. For instances of size 30, the
zk-SNARKs-based version should be preferred, whereby on-chain veriﬁcation is
at a lower price for an instance size of 31. Finally, the cost of on-chain veriﬁcation
exceeds the cost of the zk-SNARKs-based variant at instance size 40. Overall,
we can clearly see which version is cheaper for instances of size up to 29 and
from 40 ascending. Around the instance size 30, three intersections with regard
to the on-chain and zk-SNARKs-based variant are visible. To determine the
exact break-even point(s) between 29 and 40, we have performed further (not-

Blockchain-based Result Veriﬁcation for Computation Oﬄoading

15

compute-witness
generate-proof

]
s
d
n
o
c
e
s
[

e
m

i
t

g
n
i
n
n
u
r

200

175

150

125

100

75

50

25

0

3/ m 30

3/ m 70

10/ m 30

10/ m 70

11/ m 30

11/ m 70

20/ m 30

20/ m 70

21/ m 30

21/ m 70

30/ m 30

30/ m 70

31/ m 70

40/ m 70

41/ m 70

50/ m 70

51/ m 70

60/ m 70

Instance size/map

Fig. 7: Time overhead

depicted) measurements showing that the on-chain variant is more cost-eﬃcient
for instances of size 31–34. From instance size 35, the zk-SNARKs-based variant
should be preferred.

These results show that it is necessary to discuss the line course in more
detail: It becomes clear that the gas demand of all three variants shown in Fig-
ure 6 increases with the instance size. It is also noticeable that the cost levels
of submit-without-ver. (map 70) and submitSolution-onChain rise continuously,
while the levels of submit-with-ver. (map 70) increase step-wise. This is caused
by the partitioned veriﬁcation, due to the lack of dynamic ﬁelds and the sub-
sequent ﬁxed array sizes within the DSL of ZoKrates. For solutions of size 3 to
60, separate DSL programs with a varying number of inputs (starting with an
instance size of 10, and increased by steps of 10) are provided. For example, if
a DSL solution for 11 cities is computed, the resulting path has to be padded,
according to the expected number of inputs of the DSL program. Due to the fact
that such a padding is not necessary when no veriﬁcation is performed or the
veriﬁcation is done on-chain, the gas consumption merely rises continuously for
these options, but for the zk-SNARKs-based approach, “jumps” in the plot can
be seen. A solution to circumvent this would be to have diﬀerent smart contracts
for diﬀerent TSP instance sizes.

Second, we observe the time overhead. Figure 7 depicts the time needed to
execute the compute-witness and generate-proof step for TSP instances of sizes
3 to 60. The values on the x-axis can be interpreted as follows: 3/m30 means that
the instance is of size three and belongs to map 30. As can be seen, the overall
run-time increases with the size of instances. The step generate-proof takes on
average 3.2 (standard dev.: 0.28) times longer than the compute-witness step.
Considering the increasing runtime of the proof generation and the computation
of the witness, it becomes clear that the presented result veriﬁcation approach
should primarily be used in scenarios which are not very time-critical.

16

B. K¨orbel et al.

6 Conclusion

In order to provide solutions for fully decentralized task oﬄoading, a number of
blockchain-based solutions have already been proposed. However, to the best of
our knowledge, none of these solutions is able to verify that an oﬄoaded task is
computed correctly. Instead, redundant computing or trust models are applied,
which however cannot guarantee that a computation is valid.

We have therefore presented an approach which supports the veriﬁcation of
computation results, applying zk-SNARKs. Especially, this allows to compute
results and proofs oﬀ-chain, and to only verify the proofs on-chain. While our
solution can also be integrated into existing blockchain-based oﬄoading frame-
works, we have also provided a simpliﬁed broker solution as part of this paper.
In our future work, we want to further extend the presented approach. Es-
pecially, we want to replace the brokering functionality by a more sophisticated
one which also allows the broker to take into account quality requirements (e.g.,
a particular quality of a result), and to select based on this the best result from
a number of provided solutions. In fact, selecting the TSP as our evaluation use
case already lays the foundations for this, since service providers could deliver
diﬀerent solution qualities with diﬀerent algorithms and at diﬀerent cost to this
NP-hard problem. In other scenarios, the assessment of the result quality is a
more complex task and therefore an interesting direction of future work.

While currently our reference implementation applies a simple pricing scheme,
i.e., the service provider is paid with the consumer’s stake, more complex pricing
might be useful. For instance, a dynamic pricing scheme based on the complexity
of an oﬄoaded computational task and the number of available service providers
might be helpful. Last but not least, as has been shown in the evaluation, an on-
chain veriﬁcation is sometimes cheaper to conduct than the proposed oﬀ-chain
result veriﬁcation. Therefore, we will further investigate in which cases which of
these two approaches should be preferred.

Acknowledgments. The ﬁnancial support by the Austrian Federal Ministry for
Digital and Economic Aﬀairs, the National Foundation for Research, Technology
and Development and the Christian Doppler Research Association is gratefully
acknowledged.

References

1. Applegate, D.L., Bixby, R.E., Ch´atal, V., Cook, W.J.: The Traveling Salesman

Problem – A Computational Study. Princeton University Press (2007)

2. Ben-Sasson, E., Chiesa, A., Tromer, E., Virza, M.: Succinct Non-Interactive Zero
Knowledge for a von Neumann Architecture. In: 23rd USENIX Security Symp. pp.
781–796. USENIX Association (2014)

3. Chatzopoulos, D., Ahmadi, M., Kosta, S., Hui, P.: FlopCoin: A Cryptocurrency for
Computation Oﬄoading. IEEE T. on Mobile Computing 17(5), 1062–1075 (2018)

Blockchain-based Result Veriﬁcation for Computation Oﬄoading

17

4. Eberhardt, J., Heiss, J.: Oﬀ-chaining Models and Approaches to Oﬀ-chain Com-
putations. In: 2nd Works. on Scalable and Resilient Infrastructures for Distributed
Ledgers. pp. 7–12. ACM (2018)

5. Eberhardt, J., Tai, S.: ZoKrates – Scalable Privacy-Preserving Oﬀ-Chain Compu-

tations. In: 1st IEEE Int. Conf. on Blockchain. pp. 1084–1091. IEEE (2018)

6. Fedak, G., Bendella, W., Alves, E.: Blockchain-Based Decentralized Cloud Com-
puting. https://iex.ec/wp-content/uploads/pdf/iExec-WPv3.0-English.pdf
(2017)

7. Goldreich, O., Micali, S., Wigderson, A.: How to Play any Mental Game or A
Completeness Theorem for Protocols with Honest Majority. In: 19th Annual ACM
Symp. on Theory of Computing. pp. 218–229. ACM (1987)

8. Greenberg, A.: Hackers Can Mess With Voltages to Steal Intel Chips’ Secrets.

https://www.wired.com/story/plundervolt-intel-chips-sgx-hack

9. Kosba, A., Papadopoulos, D., Papamanthou, C., Song, D.: MIRAGE: Succinct Ar-
guments for Randomized Algorithms with Applications to Universal zk-SNARKs.
In: 29th USENIX Security Symp. pp. 2129–2146. USENIX Association (2020)
10. Kosta, S., Aucinas, A., Hui, P., Mortier, R., Zhang, X.: ThinkAir: Dynamic resource
allocation and parallel execution in the cloud for mobile code oﬄoading. In: 31st
IEEE Int. Conf. on Computer Communications. pp. 945–953. IEEE (2012)

11. Krejci, S., Sigwart, M., Schulte, S.: Blockchain- and IPFS-based Data Distribution
for the Internet of Things. In: 8th Europ. Conf. on Service-Oriented and Cloud
Computing. LNCS, vol. 12054, pp. 177–191. Springer (2020)

12. Mach, P., Becvar, Z.: Mobile Edge Computing: A Survey on Architecture and
Computation Oﬄoading. IEEE Communications Surveys & Tutorials 19(3), 1628–
1656 (2017)

13. Marston, S., Li, Z., Bandyopadhyay, S., Zhang, J., Ghalsasi, A.: Cloud Computing
– The Business Perspective. In: Decision Support Systems. vol. 51, pp. 176–189
(2011)

14. Pan, J., Wang, J., Hester, A., AlQerm, I., Liu, Y., Zhao, Y.: EdgeChain: An Edge-
IoT Framework and Prototype Based on Blockchain and Smart Contracts. IEEE
Internet of Things J. 6(3), 4719–4732 (2019)

15. Qiu, X., Liu, L., Chen, W., Hong, Z., Zheng, Z.: Online Deep Reinforcement Learn-
ing for Computation Oﬄoading in Blockchain-Empowered Mobile Edge Comput-
ing. IEEE T. on Vehicular Technology 68(8), 8050–8062 (2019)

16. ur Rehman Khan, A., Othman, M., Madani, S.A., Khan, S.U.: A Survey of Mobile
Cloud Computing Application Models. IEEE Communications Surveys & Tutorials
16(1), 393–413 (2014)

17. Santos, N., Gummadi, K.P., Rodrigues, R.: Towards trusted cloud computing. In:
2009 Conf. on Hot Topics in Computing. USENIX Association (2009), article No.
3

18. Satyanarayanan, M.: A Brief History of Cloud Oﬄoad: A Personal Journey from
Odyssey Through Cyber Foraging to Cloudlets. GetMobile: Mobile Computing and
Communications 18(4), 19–23 (2014)

19. Schwarz, M., Weiser, S., Gruss, D., Maurice, C., Mangard, S.: Malware Guard
Extension: Using SGX to Conceal Cache Attacks. In: Int. Conf. on Detection of
Intrusions and Malware, and Vulnerability Assessment. LNCS, vol. 10327, pp. 3–
24. Springer (2017)

20. Skrzypczak, A.: Golem Architecture. https://blog.golemproject.net/golem-architecture/

(2017), online, last visited at 2021-05-20

21. Sonm Pte. Ltd.: SONM – Supercomputer Organized by Network Mining.

https://whitepaper.io/document/326/sonm-whitepaper

18

B. K¨orbel et al.

22. Teutsch, J., Reitwießner, C.: A scalable veriﬁcation solution for blockchains. CoRR

abs/1908.04756 (2019), http://arxiv.org/abs/1908.04756

23. Uriarte, R.B., De Nicola, R.: Blockchain-Based Decentralized Cloud/Fog Solutions:
Challenges, Opportunities, and Standards. IEEE Communications Standards Mag-
azine 2(3), 22–28 (2018)

24. Wu, H., Sun, Y., Wolter, K.: Energy-Eﬃcient Decision Making for Mobile Cloud

Oﬄoading. IEEE T. on Cloud Computing 8(2), 570–584 (2020)

25. Wu, H., Wolter, K., Jiao, P., Deng, Y., Zhao, Y., Xu, M.: EEDTO: An Energy-
Eﬃcient Dynamic Task Oﬄoading Algorithm for Blockchain-Enabled IoT-Edge-
Cloud Orchestrated Computing. IEEE Internet of Things J. 8(4), 2163–2176 (2021)

