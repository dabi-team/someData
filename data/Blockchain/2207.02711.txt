SocChain: Blockchain with Swift Proportional Governance for
Bribery Mitigation
Deepal Tennakoon, Vincent Gramoli
dten6395@uni.sydney.edu.au,vincent.gramoli@sydney.edu.au
University of Sydney
School of Computer Science
Australia

2
2
0
2

l
u
J

6

]

R
C
.
s
c
[

1
v
1
1
7
2
0
.
7
0
2
2
:
v
i
X
r
a

ABSTRACT
Blockchain governance is paramount to lead securely a large group
of users towards the same goal without disputes about the legit-
imacy of a blockchain instance over another. As of today, there
is no efficient way of protecting this governance against an oli-
garchy. This paper aims to offer a new dimension to the security of
blockchains by defining the swift proportional governance problem.
This problem is to rapidly elect governance users that proportion-
ally represent voters without the risk of dictatorship. We then
design and implement an open permissioned blockchain called Soc-
Chain (Social Choice Blockchain) that mitigates bribery by building
upon results in social choice theory. We deploy SocChain and eval-
uate our new multi-winner election DApp running on top of it. Our
results indicate that, using our DApp, 150 voters can elect a propor-
tionally representative committee of 150 members within 5 minutes.
Hence we show that SocChain can elect as many representatives
as members in various global organizations.

1 INTRODUCTION
This paper aims to offer a new dimension to the security of
blockchain [52] by introducing a framework to define, solve and
evaluate a swift proportional governance as the problem of electing
rapidly a committee that proportionally represents voters, to cope
with bribery and dictatorship.

The notion of governance, which is generally understood as the
processes relied upon to make decisions and modify the protocol,
has become an important topic in blockchain [14, 51, 75]. The
absence of governance already led users to create dissident instances
of the two largest blockchains [42, 68]. The worst thing that can
happen is when an attacker takes control of the governance, which
is best addressed through decentralization. Recent efforts were
already devoted to applying social choice theory to distributed
systems to cope with a fixed coalition of malicious users, also called
a byzantine oligarchy [76]. Yet, such solutions do not rotate the
governance and fail as soon as the attacker manages to bribe a third
of the governance.

A pernicious threat is thus the risk of obtaining an oligarchy
that acts as a dictator. The Proof-of-Stake (PoS) design that favors
wealthy participants over others gained popularity as an efficient
replacement to Proof-of-Work (PoW) in blockchain designs. Com-
bined with the Pareto Principle [53] stating that few users own
most of the resources of the system or with bribery as the act of
offering something to corrupt a participant, the system may end
up being governed by an oligarchy. Of course, no blockchains can
be implemented if an adversary is capable of bribing all nodes in-
stantaneously, this is why a slowly adaptive adversary is generally
assumed by blockchains [36, 45, 74]. Assuming that bribing takes

time is reasonable [49]: Typically, a user can easily bribe a close
friend but will take more time to bribe an acquaintance and may
even fail at bribing a stranger (due to the fear of being exposed
as corruptible). But even under this assumption, the risk of an
oligarchy remains.

Hence, blockchains require a fast governance reconfiguration
that counteracts a growing coalition of malicious nodes by selecting
a diverse and slow-to-bribe set of governance users, a problem we
call swift proportional governance.

The first part of this problem is to select a diverse set of
governance users or governors that represent proportionally the
voters to prevent an adversary, who controls ğ‘“ < ğ‘›/3 of the ğ‘›
governors, from acting as a dictator. This ratio comes from (i) the
need for voters to reach consensus on the new set of governors and
(ii) the impossibility of solving consensus with ğ‘“ â‰¥ ğ‘›/3 malicious
participants in the general setting [55].

One may think of reconfiguring the governance by executing the
byzantine fault tolerant (BFT) consensus protocol of a blockchain
not to decide upon a new block but to decide a set of governors [15].
Most blockchain consensus protocols are, however, designed to
offer a single-winner election: they are tuned to pick one block out
of many legitimate blocks. To make things worse, this picked block
in consensus protocols is typically imposed by a winner/leader
node [5, 6, 46, 52, 54, 71, 78] that acts as a dictator. For governance,
we need instead a multi-winner election protocol so that voters
can rank candidates, and the protocol outputs a set of candidates
representative of the voted preferences. An example of a multi-
winner election protocol is the Single Transferable Vote (STV) pro-
tocol [63], used for example to elect the Australian senate [27], that
can transfer each vote between candidates in the order of the voterâ€™s
preferences. However, this protocol is synchronous and costly [7]
to run within a consensus algorithm. Another approach is thus to
implement STV in a smart contract: provided that the blockchain
is consistent, the output of the smart contract should be the same
across users, without the need for an additional consensus step.

The second part of

the problem is a fast governance
reconfiguration: the longer a proposed governance update takes
to be agreed upon, the greater the risk of the governance being
bribed. With an average latency of minutes [71] or an hour [52] to
commit a transaction agreed by all, blockchains are often subject
to congestion when the demand rises [58]. This congestion would
also delay the execution of a smart contract intended to update
the governance. The recent performance improvements of open
blockchains [24, 32, 36, 48] relying on a subset of permissioned
service providers to run consensus seems promising for reconfig-
uration [1, 9, 54, 65]. One of the most recent of these blockchains

 
 
 
 
 
 
Blockchain Election

Tendermint [40] None

Algorand [36] Sortition

Hybrid consensus [54] PoW puzzle
Zilliqa [78] PoW puzzle

OmniLedger [45] Sortition
RapidChain [74] PoW puzzle
ComChain [65] None
Libra [6] None
SmartChain [9] None

Polkadot [18] Multi-winner approval voting
EOS [31] Multi-winner approval voting
SocChain Multi-winner preferential voting

Proportionality Non-dictatorship

no
no
no
no
no
no
no
no
no
yesâˆ—
yesâˆ—
yes

no
no
no
no
no
no
no
no
no
no
no
yes

* Polkadot and EOS offer some form of â€œproportionalityâ€ but do
not satisfy the traditional definition we use [72].

Table 1: Blockchains with reconfigurable governance do not
offer both proportionality and non-dictatorship while elect-
ing governors

even offers the finality of world-wide transactions within 3 sec-
onds on average [24] but does not support smart contract exe-
cutions. The absence of fast smart contract executions is not the
only impediment. Once the execution terminates, the blockchain
service governed by the old configuration has to be shut down
before the blockchain service with the new configuration can be
started. Besides the downtime, the users who do not shut down
their blockchain service would create a split, again leading users to
create dissident instances of the same blockchain [42, 68]. Instead, if
all users initially joining agree that the blockchain self-reconfigures
upon a special smart contract execution, then no split can occur.
To achieve this, we need a new blockchain that reconfigures its
governors based on the smart contract output.

This paper defines the swift proportional governance problem
(Â§3), designs a solution for it, proves the solution correct and evalu-
ates the solution. Our proposed solution offers two practical contri-
butions: an election decentralized application, or DApp, that elects
a set of governors ensuring proportionality and non-dictatorship
(Â§4) and a blockchain (Â§5) that swiftly replaces a set of governors
by this newly elected one. In particular, Table 1 indicates why other
blockchain governance protocols do not address the same prob-
lem (the detailed comparison is deferred to Â§7). The problem our
election protocol solves NP-hard (Â§6.2.3) and, as we explain in Â§6.3,
it would be too slow to cope with bribery if executed on another
blockchain. More specifically, our contributions are as follows:

â€¢ We introduce the first byzantine fault tolerant multi-winner
election protocol, called BFT-STV, a new primitive that
augments the STV election procedure to enforce non-
dictatorship in the presence of at most ğ‘¡ < ğ‘›/3 byzantine
voters among ğ‘› voters without assuming synchrony (we de-
note by ğ‘“ â‰¤ ğ‘¡ the actual number of byzantine voters). We
implement this new protocol in a smart contract written
in the Solidity programming language to allow the users
of a blockchain to propose and rank candidates in the or-
der of their preferences. As it is impossible to distinguish
a non-responsive byzantine voter from a delayed message,
we introduce a new election quota ğ‘ğµ = ğ‘›âˆ’ğ‘¡
ğ‘˜+1 where ğ‘˜ is the
size of the committee. Interestingly, we show that our new
BFT-STV protocol preserves the proportionality and non-
dictatorship properties of STV while ensuring termination.

â€¢ This smart contract alone is not sufficient to ensure the
swiftness of the governance reconfiguration, especially with
Ethereum. Our second contribution is a blockchain, called
SocChain (Social Choice Blockchain), that reconfigures itself
by taking as an input the elected committee of governors
output by the smart contract. Similarly to the â€œopen permis-
sionedâ€ Red Belly Blockchain [24], SocChain accepts per-
missionless clients to issue transactions that permissioned
governors agree upon. The key difference is that SocChain
embeds the Ethereum Virtual Machine supporting smart con-
tracts that can modify, at runtime, the set of permissioned
nodes governing the protocol. It then reconfigures fast the
blockchain nodes in order to mitigate bribery attacks. In
particular, our protocol revokes permissions of existing gov-
ernors to select new governors before a large portion of them
could be bribed. This is done by changing the governor set
periodically and rapidly by electing new governors.

â€¢ We prove that our protocols are correct and evaluate the
time they take to reconfigure a blockchain with up to 150
voters electing governors among 150 candidates. Our results
indicate that it always takes less than 5 minutes for Soc-
Chain to elect new governors and transition from using the
old governors to using the new governors that will produce
the upcoming blocks. Finally, we also evaluate SocChain at
a larger scale, showing that it performs thousands of trans-
actions per second when deployed on 100 VMs, hence being
able to replicate the governance maintained by major global
organizations such as OECD, EU, the CommonWealth, APAC,
which all have under 100 members.

In the remainder of the paper, we present the background and
motivations (Â§2), and our goal, model, and problem definition (Â§3).
We present our new secure governance DApp (Â§4) and prove it
correct. We then present SocChain (Â§5), and evaluate it with our
new secure governance DApp (Â§6). Finally, we present the related
work (Â§7) and conclude (Â§8). We defer the proof of correctness of
our blockchain (Â§A), the discussion of our solution (Â§B) and the
Solidity code of the BFT-STV smart contract (Â§C) to the optional
appendix.

2 BACKGROUND AND MOTIVATIONS
The notion of governance, which is the processes relied on to make
decisions impacting the protocol has become an important topic
in blockchain [14, 51, 75]. The governance structure encompasses
the identity of parties capable of suggesting changes, the avenue
through which such changes are proposed, the users capable of
deciding the changes and the parties implementing these changes.
Due to the large number of users of a blockchain, governance is
especially relevant to lead this large cohort towards a common
goal. With a lack of governance, the divergence of opinions may
result in the split of the blockchain into multiple instances sharing
a common transaction history but accepting distinct transactions.
As an example, consider Figure 1, where blockchain node 1
rejects a software upgrade and keeps accepting old-formatted blocks
whereas blockchain node 2 accepts this upgrade and starts accepting
blocks in a new format, leading to a hard fork. The two largest
blockchains were victims of such splits: Bitcoin is now split into

2

Figure 1: If blockchain nodes disagree on a protocol update
then they may start accepting distinct blocks, which results
in a hard-fork with a classic version of the blockchain (e.g.,
ETC, BTC) and a new version of it (e.g., BCH, ETH). This
can be avoided if the protocol includes at start-time a pre-
determined procedure to reconfigure itself based on later
governance decisions.

BTC and BCH [68] whereas Ethereum is now split into ETH and
ETC [42]. The absence of governance can draw blockchain users
into such clashes. The solution to this problem, which we adopt
here, is to â€œhard-codeâ€ in the blockchain software a reconfiguration
(or upgrade) that executes as soon as it is voted upon. When the
blockchain is spawned for the first time, all its users implicitly
accept that it may reconfigure. Later, if a majority of voters decide
to reconfigure, then the blockchain changes the software and its
governance users, or governors, automically. There is no need for
the users to decide whether to upgrade as their blockchain node
reconfigures autonomously.

The biggest challenge is to prevent an attacker from obtaining
the control of the governance, which is usually tackled through de-
centralization. Recently, the best paper at OSDI 2020 [76] proposes
to apply social choice theory results to distributed systems in order
to guarantee that no coalition of ğ‘“ < ğ‘›/3 governors can dictate the
order of transactions. Its authors assume that the governors running
the consensus are pre-determined and do not aim at running an
election that will update this set of governors. The reason for this
assumption stems from the conjunction of two fundamental results
of distributed computing indicating that one cannot implement a
secure blockchain as soon as the oligarchy includes ğ‘›/3 participants
because (i) a blockchain needs to solve consensus in the general
setting [37] and (ii) consensus cannot be solved if network delays
cannot be predicted [34]. As soon as more than ğ‘›/3 of the governors
fail, then the governance cannot lead participants towards the same
goal anymore.

As blockchains typically handle valuable assets, several works
already noted the risk for a user to bribe other users to build an
oligarchy capable of stealing these assets [12]. As mentioned before,
it is reasonable to assume that bribing many nodes is not instanta-
neous [36, 45, 49, 74]. To reduce the chances that governance users,
or governors, know each other, Algorand [36] exploits randomness
and non-interactiveness [2], however, a random selection does not
eradicate the possibility of obtaining a byzantine oligarchy, because
in Algorand the more coins users have, the higher their chances of
being selected. Other blockchains assume exlicitly a slowly-adaptive
adversary [45, 50], assuming that the adversary can corrupt a lim-
ited number of nodes on the fly at the beginning of each consensus
epoch but cannot change the set of malicious participants during an
epoch. We build upon such an assumption to implement SocChain
(Â§5).

Traditional blockchains do not offer a representative gover-
nance [11]. Some blockchains give permissions to miners to decide
to change the gas price [58], others give the permission of deciding

3

a new block randomly [36], some prevent governors from changing
the governance size [30]. The closest work, concomitant with ours
and part of Pokaldot [14], targets proportional representation while
favoring the wealthiest users by offering an approval voting system.
Given the Pareto Principle [53] stating that few users typically own
most of the resources, care is needed to avoid falling back to an
oligarchy. In order to pursue the two conflicting goals of letting the
wealthiest participants govern while trying to avoid that they con-
stitute an oligarchy, Polkadot can only offer some approximation to
the problem solution [19]. Instead of approximating a solution that
could result in the blockchain being unusable, we offer a preferen-
tial voting system that solves exactly the problem of proportional
representation and non-dictatorship as we explain in Â§3.2.

2.1 Social choice theory with byzantine fault

tolerance

To propose meaningful properties for blockchain governance, we
draw inspiration from classic work on social choice theory. Given a
set of ğ‘› voters, each casting an ordinal ballot as a preference order
over all ğ‘š candidates, a multi-winner election protocol outputs a
winning committee of size ğ‘˜.

Arrow [3] defined non-dictatorship as a property of a voting pro-
tocol where there is no single person that can impose its preferences
on all. Our goal is to adapt this property to cope with byzantine
voters such that non-dictatorship remains satisfied even when an
adversarial person controls up to ğ‘“ < ğ‘›/3 byzantine voters (Def 1).
Non-dictatorship is however insufficient to guarantee that newly
elected governors remains a diverse representation of the voters.
Black [11] was the first to define this proportionality problem where
elected members must represent â€œall shades of political opinionâ€ of
a society.

Dummett [25] introduced fully proportional representation to
account for ordinal ballots, containing multiple preferences. Given
a set of ğ‘› voters aiming at electing a committee of ğ‘˜ governors, if
there exists 0 < â„“ â‰¤ ğ‘˜ and a group of â„“ Â· ğ‘ğ» who all rank the same â„“
candidates on top of their preference orders, then these â„“ candidates
should all be elected. However, it builds upon Hareâ€™s quota ğ‘ğ» ,
which is vulnerable to strategic voting whereby a majority of voters
can elect a minority of seats [39]. This problem was solved with the
introduction of Droopâ€™s quota ğ‘ğ· as the smallest quota such that
no more candidates can be elected than there are seats to fill [63].
Woodall [72] replaces Hareâ€™s quota with Droopâ€™s quota ğ‘ =
âŒŠ ğ‘›
ğ‘˜+1 âŒ‹ and defines the Droop proportionality criterion as a variant of
the fully proportional representation property: if for some whole
numbers ğ‘— and ğ‘  satisfying 0 < ğ‘— â‰¤ ğ‘ , more than ğ‘— Â· ğ‘ğ· of voters
put the same ğ‘  candidates (not necessarily in the same order) as
the top candidates in their preference list, then at least ğ‘— of those ğ‘ 
candidates should be elected. This is the property we target in this
paper and we simply rename it proportionality (Def.1).

It is known that the First-Past-The-Post (FPTP) single-winner
election and the Single Non-Transferrable Vote (SNTV) multi-
winner election cannot ensure fully proportional representa-
tion [33]. The reason is that voters can only reveal their highest
preference.

This property can however be achieved using the Single Trans-
. In STV,

ferable Vote (STV) algorithm with Hareâ€™s quota ğ‘ğ» = ğ‘›
ğ‘˜

candidates are added one by one to the winning committee and
removed from the ballots if they obtain a quota ğ‘ of votes. STV is
used to elect the Australian senate and is known to ensure fully
proportional representation. Unfortunately, this protocol is syn-
chronous [26] in that its quotas generally rely on the number of
votes ğ‘› received within a maximum voting period.

As one cannot predict the time it will take to deliver any message
on the Internet, one cannot distinguish a slow voter from a byzan-
tine one. Considering ğ‘› as the number of governors or potential
voters among which up to ğ‘¡ can be bribed or byzantine, our protocol
can only wait for at most ğ‘› âˆ’ ğ‘¡ votes to progress without assuming
synchrony. Waiting for ğ‘› âˆ’ ğ‘¡ prevents us from guaranteeing that
the aforementioned quotas can be reached. We thus define a new
quota called the byzantine quota ğ‘ğµ = âŒŠ ğ‘›âˆ’ğ‘¡
ğ‘˜+1 âŒ‹ such that ğ‘¡ < ğ‘›/3 and
reduce the number of needed votes to start the election to ğ‘› âˆ’ ğ‘¡.
Of course, up to ğ‘¡ of these ğ‘› âˆ’ ğ‘¡ ballots may be cast by byzantine
nodes, however, we show in Theorem 2 that no adversary control-
ling up to ğ‘¡ byzantine nodes can act as a dictator. Based on ğ‘ğµ, we
propose BFT-STV that extends STV for a byzantine fault tolerance
environment. We also show that BFT-STV satisfies proportionality
and non-dictatorship (Â§4) without assuming synchrony.

3 THE SWIFT PROPORTIONAL
GOVERNANCE PROBLEM

Our goal is to offer swift proportional governance by: (i) offering
a blockchain governance that allows distributed users to elect a
committee proportionally representative of the voters and with-
out dictatorship and (ii) guaranteeing security of the blockchain
by changing rapidly its governance. We first present the compu-
tation model (Â§3.1) before defining the BFT governance (Â§3.2) and
blockchain (Â§3.3) problems separately, and terminate with the threat
model (Â§3.4).

3.1 Byzantine fault tolerant distributed model
We consider a distributed system of ğ‘› nodes, identified by public
keys ğ¼ and network identifiers (e.g., domain names or static IP
addresses) ğ´, that can run different services: (i) the state service
executes the transactions and maintains a local copy of the state of
the blockchain, (ii) the consensus service executes the consensus
protocol in order to agree on a unique block to be appended to the
chain. Client1 nodes simply send transaction requests to read from
the blockchain (to check an account balance) or to transfer assets,
upload a smart contract or invoke a smart contract2.

As we target a secure blockchain system running over an open
network like the Internet, we consider the strongest fault model
called the byzantine model [47], where nodes can fail arbitrarily by,
for example, sending erroneous messages and we do not assume
that the time it takes to deliver a message is upper bounded by
a known delay, instead we assume that this delay is unknown, a
property called partial synchrony [26]. We also aim at implementing
an optimally resilient system: as blockchain requires consensus
in the general model [37] and consensus cannot be solved in the

1The term â€œclientâ€ is often used in Ethereum to refer to a node regardless of whether
it acts as a server. We use client in the traditional sense of the client-server distinc-
tion [60].
2Note that some smart contract invocations are considered read-only, we do not
distinguish them from those updating for simplicity in the presentation.

4

partially synchronous model with ğ‘›/3 byzantine nodes [47], we
assume a slowly adaptive byzantine adversary where the number
ğ‘“ of byzantine governors can grow up to ğ‘¡ < ğ‘›/3 within the first Î”
units of time of the committee existence (we will show in Â§6 how
Î” can be made as low as 5 minutes). A node that is not byzantine
is called correct. Finally, we assume public key cryptography and
that the adversary is computationally bounded. Hence, the issuer
of a transaction can sign it and any recipient can correctly verify
the signature.

3.2 Secure governance problem
We refer to the blockchain governance problem as the problem of
designing a BFT voting protocol in which ğ‘› voters rank ğ‘š candi-
dates to elect a committee of ğ‘˜ governors (ğ‘˜ < ğ‘š â‰¤ ğ‘›) to ensure
non-dictatorship as defined by Arrow [3] and proportionality as
defined by Dummett [25], Woodland [72] and Elkind et al. [29] (cf.
Â§2.1). The main distinction is that we adapt this problem from social
choice theory to the context of distributed computing.

Definition 1 (The Secure Governance Problem). The secure
governance problem is for a distributed set of ğ‘› voters, among which
ğ‘“ â‰¤ ğ‘¡ < ğ‘›/3 are byzantine, to elect a winning committee of ğ‘˜ gov-
ernors among ğ‘š candidates (i.e., ğ‘š > ğ‘˜) such that the two following
properties hold:

â€¢ Proportionality: if, for some whole numbers ğ‘—, ğ‘ , and ğ‘˜ satis-
fying 0 < ğ‘— â‰¤ ğ‘  â‰¤ ğ‘˜, more than ğ‘— (ğ‘› âˆ’ ğ‘¡)/(ğ‘˜ + 1) of voters put
the same ğ‘  candidates (not necessarily in the same order) as
the top ğ‘  candidates in their preference listings, then at least ğ‘—
of those ğ‘  candidates should be elected.

â€¢ Non-dictatorship: a single adversary, controlling up to ğ‘“ <
ğ‘›/3 byzantine voters, cannot always impose their individual
preference as the election outcome.

The need for these two properties stems from our goal of guar-
anteeing proportional representation (proportionality) but also dis-
allowing a coalition of byzantine nodes from imposing their de-
cision on the rest of the system (non-dictatorship). Note that the
non-dictatorship property differs slightly from the original defini-
tion [3] that did not consider a byzantine coalition. In particular,
our property considers coalitions and prevents them from imposing
their preference in â€œallâ€ cases.

3.3 Blockchain problem
We refer to the blockchain problem as the problem of ensuring both
the safety and liveness properties that were defined in the literature
by Garay et al. [35] and restated more recently by Chan et al. [20],
and a classic validity property [24] to avoid trivial solutions to this
problem.

Definition 2 (The Blockchain Problem). The blockchain prob-
lem is to ensure that a distributed set of blockchain nodes maintain a
sequence of transaction blocks such that the following properties hold:
â€¢ Liveness: if a correct blockchain node receives a transaction,
then this transaction will eventually be reliably stored in the
block sequence of all correct blockchain nodes.

â€¢ Safety: the two chains of blocks maintained locally by two
correct blockchain nodes are either identical or one is a prefix
of the other.

â€¢ Validity: each block appended to the blockchain of each correct
blockchain node is a set of valid transactions (non-conflicting
well-formed transactions that are correctly signed by their
issuer).

The safety property does not require correct blockchain nodes to
share the same copy, simply because one replica may already have
received the latest block before another receives it. Note that, as in
classic definitions [20, 35], the liveness property does not guarantee
that a client transaction is included in the blockchain: if a client
sends its transaction request exclusively to byzantine nodes then
byzantine nodes may decide to ignore it.

3.4 Threat model
As in previous blockchain work [36, 45, 50, 74], we assume a slowly
adaptive adversary with a limited bribing power that cannot, for
example, bribe all users instantaneously. More precisely, provided
that any new set of governors is elected with proportional represen-
tation, we also assume that it takes more than Î” = 5 minutes for 1/3
of new governors to misbehave as part of the same coalition. We
will show in Â§6 that Î” = 5 minutes is sufficient once the votes are
cast as SocChain reconfigures its governance in less than 5 minutes.
In comparison, once it will be available, Eth2.0 will take at least 6.4
minutes to reconfigure governance [70].

For the initial set of governors to be sufficiently diverse, we can
simply select governors based on their detailed information. This
can be done by requesting initial candidates to go through a Know-
Your-Customer (KYC) identification process, similar to the personal
information requested by the Ethereum proof-of-authority network
to physical users before they can run a validator node [56]. A set
of governors could then be selected depending on the provided
information by making sure multiple governors are not from the
same jurisdiction, they are not employed by the same company,
they represent various ethnicities, they are of balanced genders, etc.
We defer the details of how the KYC process can be implemented,
how user anonymity can be preserved and how to cope with bribery
smart contract attacks in Â§B.

3.4.1 Bribery attack. Limiting the number of nodes responsible to
offer the blockchain service as done in recent open blockchains [24]
exposes the service to a bribery attack [12], which is an act of offer-
ing something to corrupt a participant. This is because it is typically
easier to bribe fewer participants. In particular, as consensus cannot
be solved with at least ğ‘›
3 byzantine processes among ğ‘› when mes-
sage delays are unknown [26], it is sufficient to bribe ğ‘›
3 processes
to lead correct blockchain nodes to disagree on the next block ap-
pended to the blockchain and thus create a fork in the blockchain.
The attacker can then exploit this fork to have its transaction dis-
carded by the system and then re-spend the assets he supposedly
transferred in what is called a double spending. Our reconfiguration
protocol mitigates such a bribery attack in the presence of a slowly-
adaptive adversary by re-electing ğ‘› new governors that execute
the consensus protocol every ğ‘¥ blocks (by default we use ğ‘¥ = 100).
This is how we prevent the risks that ğ‘›
3 of the current governors
get bribed when the blockchain has between ğ‘˜ and ğ‘˜ + ğ‘¥ blocks.
As ğ‘¥ consecutive block creations do not always translate into the
same time interval, we detail in Â§B how one can make sure that,
periodically, exactly ğ‘¥ blocks are created.

Figure 2: The smart contract that implements the BFT-STV
protocol is on-chain âŠ, takes as an input a set of at least (ğ‘›âˆ’ğ‘¡)
ballots (each ranking ğ‘˜ candidates among ğ‘š) cast by (ğ‘› âˆ’ ğ‘¡)
voters among the ğ‘› governors â‹ and outputs a committee of
ğ‘˜ elected nodes âŒ to play the role of the new governors. Note
that the last committee of nodes elected to play the role of
governors will then vote for the next committee â‹ and so on
(one can fix ğ‘˜ = ğ‘› so that the committee size never changes).

Sybil attacks. A Sybil attack consists of impersonating mul-
3.4.2
tiple identities to overwhelm the systemâ€”in the context of votes, a
Sybil attack could result in double voting. The traditional blockchain
solution, proof-of-work [52], copes with Sybil attacks by requiring
each block to include the proof of a crypto puzzle. Proof-of-stake,
give permissions to propose blocks to the wealthiest participants
by relying on the assumption that participants with a large stake in
the system behave correctly. We adopt a third solution that consists
of providing authenticating information, in the form of know-your-
customer (KYC) data, in exchange for the permission to propose
new blocks, vote for governors, or be a governor candidate. This
authentication copes with Sybil attacks by preventing the same
authenticated user from using distinct node identities (as detailed
in Â§B).

4 BYZANTINE FAULT TOLERANT
PROPORTIONAL GOVERNANCE

In this section, we present how to elect, despite ğ‘“ â‰¤ ğ‘¡ < ğ‘›/3
byzantine nodes, a diverse set of governors. The idea is to allow a set
of ğ‘› blockchain nodes that vote to elect a committee proportionally
representing the voters. To this end, we propose the Byzantine
Fault Tolerant Single Transferrable Vote (BFT-STV) smart contract
that implements a multi-winner election that solves the governance
problem (Def. 1). We detail how to integrate it into SocChain in Â§5.

4.1 Overview
In order to guarantee that the election ensures fully proportional
representation, we designed the BFT-STV algorithm and imple-
mented it in a smart contract. In this section, we present its high
level pseudocode and defer the details of its implementation to
Â§C. To bootstrap, the initial permissions to vote are obtained by
ğ‘› initial governors after identification (KYC) to ensure diversity
and prevent Sybil attacks (Â§3.4.2). Recall that governors cannot use
the classic STV algorithm to elect a new committee as the smart

5

contract has to progress despite up to ğ‘¡ < ğ‘›/3 byzantine voters
not casting proper ballots and as the upper-bound on the message
delay is unpredictable. As depicted in Figure 2, the BFT-STV smart
contract takes, instead, as an input ğ‘› âˆ’ ğ‘¡ ballots cast by the voters.
Each ballot consists of a rank of all the candidates, hence the name
ordinal ballot. Once the threshold ğ‘› âˆ’ ğ‘¡ of cast ballots is reached, the
BFT-STV contract selects the governors based on the preference
order indicated in the ğ‘› âˆ’ ğ‘¡ ballots. Traditionally, the STV algorithm
consists of counting which candidates received a number of votes
that exceed the quota ğ‘ğ· = ğ‘›
ğ‘˜+1 where ğ‘˜ is the size of the committee
to be elected. However, as there can be at most ğ‘¡ byzantine nodes
among the voters, we introduce the byzantine quota ğ‘ğµ = ğ‘›âˆ’ğ‘¡
ğ‘˜+1
(denoted ğ‘ when clear from the context). We will explain how the
blockchain replaces the current governors by this newly elected
committee of governors in Â§5.

ğ‘˜ âˆˆ N, the size of the targeted committee.
ğ‘› âˆˆ N, the number of voters.
ğ‘¡ âˆˆ N, an upper bound on the number ğ‘“ of byzantine replicas, ğ‘“ â‰¥ ğ‘¡ .

1: Initial state:
2:
3:
4:
5: ğ‘š, the number of candidates per ballot.
6:
7:
8:
9:
10:
11:

ğ‘£, a mapping from candidates to their number of votes.
ballots, the set of received ordinal ballots, initially âˆ…
ğ¶ âŠ† ğ¼ , the set of candidates.
E âŠ† ğ¶ the set of eliminated candidates, initially âˆ….
S âŠ† ğ¶ the set of winning candidates, initially âˆ….
ğ‘ğ‘Ÿğ‘’ ğ‘“ [ğ‘ğ‘ğ‘™ğ‘™ğ‘œğ‘¡ ] = ğ‘–ğ‘›ğ‘‘ğ‘’ğ‘¥ a mapping of ballot and its current preference index

12: cast-ballot(ğ‘):
13:
14:
15:

if well-formed (ğ‘) then ballots â† ballots âˆª {b}
if (ballots has ğ‘› âˆ’ ğ‘¡ ballots from distinct voters) then

change-committee(ballots)

cast ballot ğ‘
store ballot

(cid:3)

(cid:3)
enough ballots
replace committee
(cid:3)

(cid:3)

if (b [0] = ğ‘ such that ğ‘ âˆˆ ğ¶) then v [ğ‘ ] â† v [ğ‘ ] + 1
pref [ğ‘ ] â† 0

(cid:3)

16: change-committee(ballots):
for all ğ‘ âˆˆ ballots do
17:
18:
19:
round â† 0
20:
21: while ( |ğ‘† | < ğ‘˜) do
22:
23:
24:
25:
26:
27:
28:
29:

for all ğ‘ âˆˆ ballots do

S â† S âˆª {ğ‘ }

emit ğ‘†

ğ‘† â† STVB (ğ‘£, ballots, ğ‘ğ‘Ÿğ‘’ ğ‘“ )
round â† round + 1
if ( |ğ¶ | âˆ’ |ğ¸ | = ğ‘˜) then break

for ( ğ‘— = 0; ğ‘— < ğ‘š; ğ‘— ++) do

(cid:3)

replace committee
for each received ballot
# 1st pref = ğ‘
(cid:3)
assign pref. index of ğ‘ to the first preference/index 0
first round
until the new committee is full
invoke classic STV
increment round number
stop eliminating

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

for each ballot
each candidate in decreasing pref. order
if eligible
select ğ‘
explicitly emit committee

(cid:3)

(cid:3)

(cid:3)

if ( |S | < ğ‘˜ âˆ§ ğ‘ [ ğ‘— ] âˆˆ ğ¶ \ ğ‘† \ ğ¸) then
(cid:3)

Algorithm 1: Byzantine Fault Tolerant Single Transferable
Vote (BFT-STV) - Part 1

(cid:3)

4.2 Byzantine Fault Tolerant Single

Transferrable Vote

Algorithm 1 presents the main functions of the BFT-STV smart
contract that the governors can invoke whereas Algorithm 2 is
the classic STV algorithm adapted to progress in a partially syn-
chronous [26] environment and despite the presence of up to ğ‘¡
byzantine voters, hence its name STVğµ.

Initially, the governors cast their ballots by invoking the function
cast-ballot(Â·) at line 12 of Algorithm 1. As a result, the smart con-
tract verifies that the ballots are well-formed (line 13). This involves
checking that the governors have not voted for themselves on their
ballots and there are no duplicated preferences. Although the details

6

30: Initial state:
31:
32:
33:
34:
35:
36:
37:
38:

ğ‘˜ âˆˆ N, the size of the targeted committee.
ğ‘› âˆˆ N, the number of voters.
ğ‘¡ âˆˆ N, an upper bound on the number ğ‘“ of byzantine replicas, ğ‘“ â‰¥ ğ‘¡ .
ğ‘ğµ = ğ‘›âˆ’ğ‘¡
ğ¶ âŠ† ğ¼ , the set of candidates.
E âŠ† ğ¶, the set of eliminated candidates, initially âˆ….
S âŠ† ğ¶, the set of winning candidates, initially âˆ….
X âŠ† ğ¶, the set of excess candidates, initially âˆ….

ğ‘˜+1 , the quota of votes to elect a candidate.

(cid:3)

(cid:3)

(cid:3)

if the quota is exceeded
elect candidate
save candidates that exceed quota in X
excess vote from candidate ğ‘
for each ballot
(cid:3)
if current ballot pref = one of X
(cid:3)
the number of candidates ğ‘
point to next preferred candidate
while not uneligible
try next pref. pointer

(cid:3)

(cid:3)

(cid:3)

(cid:3)
(cid:3)

(cid:3)

(cid:3)

(cid:3)

if eligible candidate found
move the preference pointer
next preferred candidate in ballot
current&next candidates
The number of candidates ğ‘§
(cid:3)
transfer excess votes
to next candidates

(cid:3)

(cid:3)
(cid:3)
if no candidates exceed the quota in the round
eliminate candidate with least votes

(cid:3)

(cid:3)

(cid:3)

reset votes of least candidate to 0

if ğ‘ [pref [b] ] = ğ‘ and ğ‘ âˆˆ X then

count [c] â† count [c] + 1
pref-next [b] â† pref [b] + 1
while ğ‘ [pref-next [b] ] âˆˆ (ğ‘† âˆ¨ ğ¸) do
pref-next [b] â† pref-next [b] + 1
if ğ‘ [pref-next [b] ] âˆ‰ (ğ‘† âˆª ğ¸) then

pref [b] = pref-next [b]
ğ‘§ â† ğ‘ [pref-next [b] ]
cand-next â† cand-next âˆª { âŸ¨ğ‘, ğ‘§ âŸ© }
count [z] â† count [z] + 1

for all unique âŸ¨ğ‘, ğ‘§ âŸ© âˆˆ cand-next do

v [z] â† v [z] + x [c] Â· (count [ğ‘§ ]/count [c])

if âˆ€ğ‘ : ğ‘£ [ğ‘ ] â‰¤ ğ‘ğµ then

ğ¸ â† (ğ¸ âˆª ğ‘¡ | ğ‘¡ = minâˆ€ğ‘ (ğ‘£ [ğ‘ ]))
transfer-vote â† ğ‘£ [ğ‘¡ ]
ğ‘£ [ğ‘¡ ] â† 0
for all ğ‘ âˆˆ ballots do
while ğ‘  < size do
if ğ‘ [ğ‘  ] = ğ‘¡ then

elimpointer â† elimpointer âˆª (ğ‘, ğ‘ )

for all (ğ‘, ğ‘ ) âˆˆ elimpointer do
if ğ‘ [ğ‘  ] = ğ‘š âˆ§ ğ‘š âˆˆ ğ¸ then
pref-next [b] â† ğ‘  + 1
count [m] â† count [m] + 1
while ğ‘ [pref-next [b] ] âˆˆ (ğ‘† âˆ¨ ğ¸) do
pref-next [b] â† pref-next [b] + 1

(cid:3)

if ğ‘ [pref-next [b] ] âˆ‰ ğ‘† âˆª ğ¸ then
ğ‘ğ‘Ÿğ‘’ ğ‘“ [ğ‘ ] â† pref-next [b]
ğ‘§ â† ğ‘ [pref-next [b] ]
cand-next â† cand-next âˆª (ğ‘š, ğ‘§)
count [z] â† count [z] + 1
for all unique (ğ‘š, ğ‘§) âˆˆ cand-next do

store ballot and preference index...
...of least voted cand.

(cid:3)

Increment preference

(cid:3)

(cid:3)

If preference ğ‘  of ballot ğ‘ is eliminated

(cid:3)

count of candidates ğ‘š in all ballots
until candidate is found
...increment pref. pointer

(cid:3)
(cid:3)

move the preference pointer

(cid:3)

least voted & next cand.
the number of candidates ğ‘§
(cid:3)
(cid:3)
transfer from least voted cand.

v [z] â† v [z] + transfer-vote Â· (count [z]/count [m])

(cid:3)

if âˆƒğ‘ | ğ‘£ [ğ‘ ] > ğ‘ğµ then

ğ‘† â† ğ‘† âˆª {ğ‘ }
X â† X âˆª {ğ‘ }
x [c] â† ğ‘£ [ğ‘ ] âˆ’ ğ‘ğµ
for all ğ‘ âˆˆ ballots do

39: STVğµ (ğ‘£, ballots, pref ):
40:
41:
42:
43:
44:
45:
46:
47:
48:
49:
50:
51:
52:
53:
54:
55:
56:
57:
58:
59:
60:
61:
62:
63:
64:
65:
66:
67:
68:
69:
70:
71:
72:
73:
74:
75:
76:
77:
78:
79:
80:

ğ‘‹ â† ğ‘›ğ‘¢ğ‘™ğ‘™
return ğ‘†

ğ‘  â† ğ‘  + 1

return the set of winning candidates

Algorithm 2: Byzantine Fault Tolerant Single Transferable
Vote (BFT-STV) - Part 2

(cid:3)

are deferred to the Appendix Â§C for simplicity in the presentation,
note that the smart contract keeps track of the public keys of the
governors casting ballots to ensure that the same governor cannot
double vote. Once the smart contract receives ğ‘› âˆ’ ğ‘¡ well-formed
ballots the change-committee(Â·) function is invoked (line 15). The
change-committee function starts by computing the score of the
valid candidates as the number of votes they receive at lines 17â€“18.
Valid candidates are initially selected through KYC (Â§3.4.2) before
being periodically voted upon by governors. A preference pointer
is initialized to the first preference of each ballot at line 19. Then
a new round of the STV election process starts (lines 20â€“23). This
execution stops once the committee of new governors is elected
(line 21). If before the targeted committee is elected, the number of

eliminated candidates has reached a maximum and no more candi-
dates can be eliminated to achieve the target committee size, then
the STV election stops (line 24). The remaining non-eliminated can-
didates are elected by decreasing order of preferences at lines 25â€“28
until the target committee size is reached. Finally, the smart con-
tract emits the committee of elected candidates (line 29), which
notifies the replicas of the election outcome.

4.3 Classic STV with the byzantine quota
Algorithm 2 presents the classic STV algorithm but using the new
byzantine quota ğ‘ğµ by electing candidates whose number of votes
exceed ğ‘ğµ (line 40). This algorithm executes two subsequent phases:
in the first phase (lines 39â€“56) the algorithm elects the candidates
whose number of votes exceeds the quota ğ‘ğµ = ğ‘›âˆ’ğ‘¡
ğ‘˜+1 ; in the second
phase (lines 57â€“79), the algorithm eliminates the least preferred
candidate if no candidates received a number of votes that exceeds
the quota. In each round of STV function call (line 22), when a can-
didate exceeds the quota (line 40), their excess votes are transferred
to the next eligible preferences of the ballots that contain the candi-
date (line 56). In each round of ballot iteration, if no candidate has
reached the quota, the candidate with the least vote(s) is eliminated
(line 58). This candidatesâ€™ excess votes are transferred to the next
eligible preference of the ballots that contain the candidate that
received the least votes (line 78). The elimination of candidates
stops when no more candidates can be eliminated to achieve the
committee size (line 24). At this point, even though the remaining
candidates did not receive enough votes to reach the quota, they
are elected as part of the committee (line 28).

4.4 Proofs of secure governance
In this section, we show that BFT-STV (Algorithms 1 and 2) solves
the secure governance problem (Def. 1). To this end, the first theo-
rem shows that the BFT-STV protocol ensures Proportionality. As
mentioned in Â§3.2, recall that ğ‘›, ğ‘š and ğ‘˜ denote the number of
voting governors, the number of candidates and the targeted com-
mittee size, respectively. As we consider byzantine nodes, note that
the proof holds even if malicious voters vote in the worst possible
way (e.g., based on what the others have voted).

Theorem 1. The BFT-STV multi-winner election protocol satisfies

Proportionality.

Proof. By examination of the code of Algorithms 1 and 2, the
only difference between BFT-STV and STV is the number of votes
needed to elect a candidate. STV typically starts with ğ‘› received
ballots whereas the BFT-STV starts the election as soon as (ğ‘› âˆ’ ğ‘¡)
ballots are received (line 14 of Alg. 1), where ğ‘¡ is the upper bound
on the number ğ‘“ of byzantine nodes and ğ‘› is the total number
of governors eligible to vote. This number of BFT-STV ballots is
distributed among a larger number of candidates. This can result in
less than ğ‘˜ candidates receiving enough votes to reach the classic
STV quota where ğ‘˜ is the size of the committee. By the Proportion-
ality definition (Def.Â§3.2), we need to show that if ğ‘— Â· (ğ‘› âˆ’ ğ‘¡)/(ğ‘˜ + 1)
voters put the same ğ‘  candidates as the top ğ‘  candidates in their
ballot preference, then those ğ‘  candidates will still be elected. The
proof follows from [41, p. 48â€“49]: line 58 of Algorithm 2 indicates
that by elimination, the votes will still be concentrated on the top ğ‘—

7

candidates such that 0 < ğ‘— â‰¤ ğ‘ . As a result, ğ‘— of those ğ‘  candidates
â–¡
will still be elected satisfying Proportionality.

The next theorem shows that the BFT-STV protocol ensures

Non-dictatorship as defined in Definition 1.

Theorem 2. The BFT-STV multi-winner election protocol satisfies

Non-dicatorship.

Proof. The proof shows the existence of an input of correct
nodes for which a single adversary controlling ğ‘“ byzantine nodes
cannot have its preference bğ‘ be the winning committee. Let bğ‘ [âˆ’1]
be the least preferred candidate of the adversary, we show that
there exist preferences ğ‘1, ..., ğ‘ğ‘›âˆ’ğ‘“ from correct nodes such that the
winning committee includes ğ‘ğ‘ [âˆ’1]. The result then follows from
the assumption ğ‘˜ < ğ‘š.

By examination of the pseudocode, the winning committee is
created only after receiving ğ‘› âˆ’ğ‘¡ correctly formatted ballots (line 13
of Alg. 1). By assumption, there can only be at most ğ‘“ â‰¤ ğ‘¡ < ğ‘›/3
ballots cast by byzantine nodes. As a result, among all the ğ‘› âˆ’ ğ‘¡
received ballots, there are at least ğ‘› âˆ’ 2ğ‘¡ > ğ‘›/3 ballots cast from
correct nodes. In any execution, an adversary controlling all the
byzantine nodes could have at most ğ‘“ ballots as the adversary
cannot control the ballot cast by correct nodes. Let ğ‘1, ..., ğ‘ğ‘›âˆ’ğ‘“ be
the ballots input by correct nodes to the protocol such that their
first preference is the least preferred candidate of the adversary, i.e.,
âˆ€ğ‘– âˆˆ {1, ğ‘› âˆ’ ğ‘¡ } : ğ‘ğ‘– = bğ‘ [âˆ’1]. Because ğ‘“ â‰¤ ğ‘¡ < ğ‘›/3, we know that
bğ‘ [âˆ’1] will gain more votes than any of the other candidates, and
will thus be the first to be elected (line 40 of Alg. 2). By assumption,
we have ğ‘˜ < ğ‘š, which means that there is a candidate the adversary
prefers over ğ‘ğ‘ [âˆ’1] that will not be part of the winning committee.
Hence, this shows the existence of an execution where despite
having an adversary controlling ğ‘“ byzantine nodes, the adversary
â–¡
preference is not the winning committee.

5 SOCCHAIN: ENABLING BLOCKCHAIN

SOCIAL CHOICE

In this section, we present the blockchain called SocChain and
how it provides the swift governance reconfiguration based on
our BFT-STV smart contract (Â§4). We show that SocChain solves
the Blockchain problem (Def. 2) in Â§3.3. The design of SocChain is
inspired by the open permissioned Red Belly Blockchain [24]: while
any client can issue transactions without permission, a dynamic
set of permissioned consensus participants decide upon each block.
As a result, SocChain ensures instant finality (by not forking), and
is optimally resilient in that it tolerates any number ğ‘“ â‰¤ ğ‘¡ < ğ‘›/3
of byzantine (or corrupted) nodes. However, SocChain differs from
the Red Belly Blockchain by mitigating bribery attacks and by inte-
grating the Ethereum Virtual Machine (EVM) [71] to support smart
contracts necessary to offer the swift proportional reconfiguration.

5.1 Reconfigurable governance with the

BFT-STV smart contract

We now present how the blockchain is reconfigured with the new
consensus committee once the BFT-STV smart contract elects
the committee. Offering proportional representation and non-
dictatorship is not sufficient to cope with an adaptive adversary.

In order to mitigate bribery attacks, we now propose a swift re-
configuration that complements the BFT-STV algorithm. Provided
that you have ğ‘› nodes, it is sufficient to have ğ‘›/3 corrupted nodes
among them to make the consensus service inconsistent. This is
because consensus cannot be solved with ğ‘›/3 byzantine nodes [47].
In particular, it is well-known that neither safety (agreement) nor
liveness (termination) of the consensus can no longer be guaran-
teed as soon as the number of failures reaches ğ‘›/3 [22]. As a result,
a coalition of ğ‘›/3 byzantine nodes can lead the set of nodes to a
disagreement about the next block to be appended to the chain. An
attacker can leverage these conflicting blocks in order to double
spend: for example if it has two conflicting transactions in those
blocks.

5.1.1 How to ensure the existence of candidates. In order to boot-
strap, an initial set of candidate nodes willing to provide the
blockchain service and voter nodes is provided as part of the
blockchain instance. Upon each block creation and as in classic
blockchain solutions [52, 71], SocChain offers a reward to each
voter. We assume that this reward incentivizes sufficiently many
nodes to be candidates at all times. There are few restrictions that
need to be enforced in order to guarantee that the elected commit-
tee will proportionally represent voter nodes. First, the voters and
the candidates set has to be large enough to represent all groups to
which blockchain users belong. Second, the voters should not try
to elect themselvesâ€”this is why we restrict the set of candidates to
be disjoint from the set of voters, as we explained in Â§4.2, Fig. 2 and
as in other blockchains [14, 31]. These candidates and voters are
typically encoded in the blockchain when the blockchain instance
is launched, either by hardcoding their public key and network
identifier (e.g., domain name or static IP addresses) in the genesis
block or by invoking a default smart contract function at start time
that records this information. The voters then participate in the
election: they cast their ballot by calling another function of the
smart contract and passing it a list of candidates ranked in the order
of their preferences. A ballot contains the network information of
candidates in the order that the voter prefers. (We will present an
implementation using static IP addresses in Â§6.)

1: upon receiving committee ğ‘†:
stop(consensus-service)
2:
for all ğ‘–ğ‘ âˆˆ ğ‘† do
3:
ğ´ â† ğ´ âˆª {ip }
4:
if my-ip âˆˆ ğ´ then
5:
configure(ğ´)
6:
start(consensus-service)
7:
udpdate(dns-service)
8:

(cid:3)

smart contract emits event at Alg.1, line 29
stop the consensus service
for IPs in committee
add the IP address

(cid:3)

(cid:3)

(cid:3)

(cid:3)

if consensus nodeâ€™s IP is in the selected committee
reconfigure node with the new committee peers
Start the consensus service
to redirect clients to the blockchain service

(cid:3)

(cid:3)

Algorithm 3: Reconfiguration of consensus service at a
blockchain node

(cid:3)

5.1.2 Reconfiguration. In this section, we present the reconfigu-
ration (Algorithm 3) of the blockchain that allows switching from
the current committee to the new committee ğ‘† elected with the
BFT-STV (Â§4) smart contract. Once the network identifiers (domain
names or static IP addresses) of the newly selected committee ğ‘†
of governors is emitted by the BFT-STV protocol (line 29 of Algo-
rithm 1), the blockchain nodes are notified with a smart contract

8

event (line 1 of Algorithm 3). The reception of this smart con-
tract event triggers the stopping of the consensus service in the
blockchain node through a web3js code (line 2 of Algorithm 3).
After the consensus service is stopped, the elected consensus ser-
vices are reconfigured with the network identifiers of the newly
elected nodes (line 6 of Algorithm 3). Finally, the blockchain con-
sensus service is restarted (line 7 of Algorithm 3) to take this new
committee into account.

5.2 The transaction lifecycle
In the following, we use the term transaction to indistinguishably
refer to a simple asset transfer, the upload of a smart contract or
the invocation of a smart contract function. We consider a single
instance of SocChain whose genesis block is denoted by ğµ0 and
whose blockchain nodes offer a consensus service depicted in Al-
gorithm 5 and a state service depicted in Algorithm 6. Although
SocChain also includes smart contracts, its transaction lifecycle is
similar to [24] and goes through these subsequent stages:

1. Reception. The client creates a properly signed transaction
and sends it to at least one SocChain node. Once a request
containing the signed transaction is received (line 1 of Al-
gorithm 4) by the JSON RPC server of our blockchain node
running within SocChain, the validation starts (line 2 of Al-
gorithm 4). If the validation fails, the transaction is discarded.
If the validation is successful, the transaction is added to the
mempool (line 3 of Algorithm 4).

(cid:3)

mempool â† mempool âˆª {tx }

1: receive(write, tx):
2:
if is-valid then
3:
4: wait until |mempool| = threshold or timer expired
5:
6:
7:
8:
9:
10:

prop.txs â† prop.txs âˆª {tx }
mempool â† mempool \ {tx }
prop.timestamp â† timestamp
superblock â† propose(prop)
exec(superblock)

for each tx in mempool do

(cid:3)

State node upon receiving a transaction
if tx is validated
add it to mempool
(cid:3)

(cid:3)

wait sufficiently

(cid:3)

create proposal
remove tx from mempool

(cid:3)

(cid:3)

add timestamp to proposal
propose to consensus, return superblock
execute superblock

(cid:3)

Algorithm 4: Selection of new transactions to decide

(cid:3)

If the number of transactions in the mempool reaches a
threshold of transactions or a timer has expired (line 4 of
Algorithm 4), then the blockchain node creates a proposal of
transactions with the transactions in the mempool (line 6 of
Algorithm 4). Consequently, a timestamp is added to the pro-
posal (line 8 of Algorithm 4) and proposed to the consensus
service (line 9 of Algorithm 4).

2. Consensus. As in the Democratic Byzantine Fault Tolerant
(DBFT) [23], upon reception of the proposal, the blockchain
node reliably broadcasts the proposal to other blockchain
nodes (line 12 of Algorithm 5) in the same consensus in-
stance. Lines 13â€“17 of Algorithm 5 present the section of
our consensus algorithm. We point the reader to [24] for
a detailed description of the consensus protocol and to [8]
for the formal verification of its binary consensus. In short,
the consensus protocol waits until all proposals have been
received for binary consensus instances that have decided 1
(line 18 of Algorithm 5) and forms a superblock out of those
proposals (line 19 of Algorithm 5). Finally, the consensus

service delivers the superblock to the state service (line 9 of
Algorithm 4).

(cid:3)

reliable-broadcast(prop) â†’ props [k]

bitmask [ğ‘˜ ] â† bin-proposeğ‘˜ (1)

starting the consensus algorithm
reliably deliver in props array

for all ğ‘˜ such that props [ğ‘˜ ] has been delivered

11: propose(prop):
12:
13: while | {ğ‘˜ : bitmask [ğ‘˜ ] = 1} | < ğ‘› âˆ’ ğ‘¡ or ğ‘¡ğ‘–ğ‘šğ‘’ğ‘Ÿ did not expire do
14:
15:
16:
17:
18: wait until bitmask is full and âˆ€â„“, bitmask [â„“ ] = 1 : props [â„“ ] â‰  âˆ…
19:
20:

âˆ€â„“ s.t. props [â„“ ] â‰  âˆ… : superblock â† bitmask & props
return superblock

for all ğ‘˜ such that props [ğ‘˜ ] has not been delivered
(cid:3)
propose 0 to ğ‘˜th binary consensus

bitmask [ğ‘˜ ] â† bin-proposeğ‘˜ (0)

input 1 to binary consensus [23]

bitwise &

(cid:3)

(cid:3)

(cid:3)

Algorithm 5: Consensus protocol

3. Commit. Once the superblock is received by the blockchain
node (Algorithm 4, line 9) the commit phase starts. Firstly,
each proposal is taken in-order from the superblock and each
transaction in it is validated, i.e., its nonce and signature are
checked as correct [71] (Algorithm 6, line 25). If a transaction
is invalid it is discarded. If a transaction is valid, the trans-
action is executed and the EVM state trie is updated (Alg. 6,
line 26). The execution of a transaction returns the updated
and a transaction receipt (Alg. 6, line 26). All
state trie Snextk
the executed transactions in a proposal are written to the
transaction trie (Alg. 6, line 30) and all the receipts are writ-
ten to the transaction receipt trie (Alg. 6, line 31). A block
is constructed (Alg. 6, line 33) with hashes returned by the
â„ function, the gas used GU by all transactions and the gas
limit GL that can be consumed during the block execution
(Alg. 6, line 32), as in Ethereum [71]. Finally the block is ap-
pended (Alg. 6, line 34) to the blockchain of the blockchain
node.

if is-valid(ğ‘¡ğ‘¥) then

for each ğ‘¡ğ‘¥ in props [k].txs do

, receipt âŸ© â† run(tx, S)
âŸ¨Snextk
receiptsk â† receiptsk âˆª {ğ‘Ÿğ‘’ğ‘ğ‘’ğ‘–ğ‘ğ‘¡ }
valk â† valk âˆª {ğ‘¡ğ‘¥ }

21: exec(superblock):
â„“ â† 1
22:
for each ğ‘˜ âˆˆ [0..] : props [k] in superblock do
23:
24:
25:
26:
27:
28:
29:
30:
31:
32:
33:
34:
35:

timestampğ‘˜ â† props [k].timestamp
TXğ‘˜ â† update-tx-trie(valğ‘˜ )
ğ‘…ğ‘˜ â† update-receipt-trie(ğ‘Ÿğ‘’ğ‘ğ‘’ğ‘–ğ‘ğ‘¡ğ‘ ğ‘˜ )
ğµâ„“ â† âŸ¨â„ (header(ğµâ„“ âˆ’1)), â„ (Snextk
nonce, timestampğ‘˜ , valğ‘˜ âŸ©

chain â† chain âˆª {ğµâ„“ }
â„“ â† â„“ + 1

(cid:3)

parse superblock to the SEVM

(cid:3)

order transactions...
...to minimize conflicts
(cid:3)
if validated
run tx, return state and receipt

(cid:3)

(cid:3)

(cid:3)

collect all receipts
collect executed txs from props [k] to valk
the ğ‘˜th timestamp
update transaction trie
(cid:3)
update transaction receipts
(cid:3)

(cid:3)

), â„ (TXğ‘˜ ), â„ (ğ‘…ğ‘˜ ), GU ğ‘˜ , GL,

(cid:3)

create block
append block to blockchain
(cid:3)

(cid:3)

Algorithm 6: Execution of a superblock by a blockchain
node

5.3 A BFT consensus for non-dictatorship
As SocChain builds upon DBFT [23] it is inherently democratic.
In fact, DBFT is leaderless which favors non-dictatorship as we
explain below: as indicated in Algorithm 5, DBFT reduces the prob-
lem of multi-value consensus (to decide upon arbitrary values) to
the problem of binary consensus (to decide upon binary values
exclusively) by executing an all-to-all reliable broadcast algorithms
(line 12) followed by up to ğ‘› binary consensus instances (lines 15

9

(a)
the
First,
byzantine leader (in
the middle) receives
transaction ballots
from correct nodes

(b) Then, the byzan-
tine leader receives
the transaction bal-
lots from the byzan-
tine nodes

(c) Finally, the byzantine leader
imposes the block with ğ‘› âˆ’ ğ‘¡ bal-
lots including ballots from the
byzantine nodes to other nodes,
hence favoring byzantine prefer-
ences

Figure 3: A blockchain running a leader-based consensus
with ğ‘› = 7 and ğ‘“ = 2 may end up favoring byzantine pref-
erences during an election if the leader is byzantine

and 17) running in parallel. As one can see, in Algorithm 5 all nodes
execute the same code and none plays the role of a leader.

By contrast, classic BFT algorithms [10, 13, 17, 38, 40, 73] used
in blockchains are generally leader-based. They proceed as follows:
A special node among ğ‘›, called the leader, sends its block to the rest
of the system for other nodes to agree that this block is the unique
decision. If the leader is slow, then another leader is elected but
eventually the block of some leader is decided by all. The drawback
with such solutions is that the leader can be byzantine and thus
propose the block with the content it chooses. This limitation of
leader-based consensus algorithms is precisely the motivation for
a recent work [76] that aims at circumventing byzantine oligarchy
by ensuring that if non-concurrent transactions are perceived in
some order by all correct nodes, then they cannot be committed in
a different order.

To place this problem in our context, consider Figure 3 depicting
an execution of BFT-STV (Algorithm 1) in one of these leader-based
blockchains with ğ‘› = 7 and ğ‘“ = ğ‘¡ = 2. (Recall that without assum-
ing synchrony, the smart contract cannot wait for ğ‘› transactions
from distinct processes as it cannot distinguish between a slow
process and a byzantine process that do not send its invocation. As
a result the smart contract can only wait for at most ğ‘› âˆ’ ğ‘¡ invo-
cations before continuing its execution to avoid blocking forever.)
Consider that in this particular execution, the ğ‘› âˆ’ ğ‘¡ correct nodes
issue a transaction (Fig.3(a)) invoking the function cast-ballot with
their candidate preferences before any byzantine node issued any
transaction invoking cast-ballot (Fig.3(b)). These transactions are
not yet committed and are still pending, when the leader creates
its block by including the transactions it has received. If the leader
is byzantine, it may wait and gather transactions issued by all the
byzantine nodes of its coalition before creating its proposed block.
Once it receives ğ‘¡ transactions from byzantine nodes it then creates
its block with ğ‘¡ transactions issued from byzantine nodes and ğ‘› âˆ’ 2ğ‘¡
transactions issued by correct nodes (Fig.3(c)), before proposing
it to the consensus. Once this block is decided, the transactions
it contains that invoke cast-ballot are executed. As a result, the
BFT-STV smart contract finally returns a committee voted upon by
ğ‘¡ byzantine nodes and ğ‘› âˆ’ 2ğ‘¡ correct nodes, whereas without the
leader the BFT-STV smart contract could have returned a committee
voted upon by ğ‘› âˆ’ ğ‘¡ correct nodes.

SocChain is immune to this dictatorship problem without as-
suming synchrony due to its democratic consensus algorithm [23].
More precisely, Algorithm 5 does not decide a single block proposed
by any particular node or leader. Instead it decides the combination
of the blocks proposed by all consensus participants, hence called
superblock (line 19) as in [24]. All nodes reliably broadcast its block
and participate in a ğ‘˜ğ‘¡â„ binary consensus by inputting value 1 if
it received the proposal from the ğ‘˜ğ‘¡â„ node. If no block is received
from the ğ‘˜ğ‘¡â„ node, then the ğ‘˜ğ‘¡â„ binary consensus is invoked with
input value 0. The outcome of these ğ‘› binary consensus instances
are stored in a bitmask (lines 15 and 17). Finally the bitmask is
applied to the array of received blocks to extract all transactions
that will be included in the superblock (line 19). Hence the inclusion
of a particular block is independent of the will of a single node, that
could otherwise act as a dictator.

6 EVALUATION OF SOCCHAIN
In this section, we evaluate the performance of SocChain on up to
100 machines located in 10 countries. We measure the performance
of reconfiguring the blockchain nodes in SocChain in terms of the
time taken to stop the blockchain service with the previous commit-
tee and re-start the blockchain service but with a new committee.
We also evaluate the execution time of the BFT-STV smart contract
depending on the number of candidates and voters. Finally, we
show that a growing number of blockchain participants marginally
impacts SocChainâ€™s performance.

6.1 Experimental settings
We now present the experimental settings of our evaluations dedi-
cated to test the performance.

6.1.1 Controlled setting. In order to evaluate SocChain, we de-
ployed SocChain on up to 100 VMs. In order to combine realistic
results and some where we could control the network, we deployed
VMs on Amazon Web Services (AWS) and an OpenStack cluster
where we control the delay using the tc command. We also mea-
sured world-wide delays using 10 availability zones of AWS located
across different countries. On AWS, we deployed up to 100 VM
instances with 8 vCPUs and 16 GB of memory connected through
Internet. On OpenStack we deployed up to 20 VM instances with
8 vCPUs and 16 GB of memory connected through a 10 Gbps net-
work where we added artificial network delays under our control to
represent the latencies observed over the Internet across different
geographical regions.

6.1.2 Client setup. In our experiments, we send a fixed number
of transactions from each client machine to keep the sending rate
constant. Each client instance sends a distinct set of transactions
to a specific blockchain node. The sending is done concurrently to
each blockchain node so as to stress-test the blockchain.

6.2 Reconfiguration performance
In this section we demonstrate that SocChain fully reconfigures
its governance with world-wide candidates in less than 5 min-
utes while ensuring proportional representation of its voters. More
specifically, we evaluate the time it takes to completely reconfigure
the blockchain by replacing a committee of blockchain nodes by

Figure 4: Restart times in seconds when changing the con-
sensus committee from 10 to target size ğ‘˜
another (cf. Algorithm 3). To this end, we capture the time it takes
to execute the BFT-STV smart contract (i.e., the execution time of
BFT-STV) and start all the newly elected blockchain nodes after
initiating a stop on the previous blockchain committee (i.e., the
restart time). We define this time as the reconfiguration time (i.e.,
reconfiguration time = execution time of BFT-STV + restart time).

6.2.1 Realistic network delays. In order to mimic realistic Internet
delays in our controlled setting, we deployed 20 VMs on OpenStack
with 2 VMs per blockchain node, each dedicated for the state service
and the consensus service (Â§5.2). We added communication delays
between the blockchain nodes taken from the AWS geo-distributed
environment latencies that we measured separately. Note that this is
to evaluate the restart time of blockchain nodes in a geo-distributed
setting.

6.2.2 Restart time. Figure 4 presents the restart time in seconds
when a committee of varying size gets started from a total of 10
consensus blockchain nodes. In particular, we evaluate the restart
time when it changes the targeted committee size starting from
10 and targeting a size ranging between 4 and 9 in order to ob-
serve whether this size affects the reconfiguration time. Note that
the lower the time the more available the blockchain is because
this time can translate into system outage during which the newly
requested transactions may not be servicedâ€”without violating live-
ness [20, 35] (Def. 2).3 We observe that the restart time varies by 5%
depending on the targeted committee size but that the maximum
time is taken when targeting a committee size of 8 nodes, while
the minimum time is taken when targeting a committee size of 7
nodes. This indicates that the restart time is not impacted by the
selected targeted committee sizes. To assess the impact of large
committee sizes, we experiment below with a larger committee,
with 150 voters ranking 150 candidates.

Impact of the complexity on reconfiguration. Unlike Ethereum
6.2.3
or Bitcoin, SocChain does not unnecessarily incentivize thousands
of participants to execute the same task, hence SocChain can re-
strict the committee size. It is well-known that voters of the STV
algorithm have to execute an NP-hard computation, so the same
applies to the BFT-STV problem. By contrast with concomitant
proposals [19] that approximate other NP-hard proportional elec-
tion problems, our solution achieves proportionality exactly (The-
orem 1). Without approximating the solution, our exact solution

3Blockchain liveness remains guaranteed despite reconfiguration as either the correct
blockchain node does not receive the transaction due to transient outages or commits
it eventually.

10

Figure 5: The execution time of BFT-STV as we vary the num-
ber of candidates (with 150 voters) and as we vary the num-
ber of voters (with 50 candidates)

could induce a cost growing super-linearly with the input size (e.g.,
number of voters and candidates) of the problem. To measure the
impact of these parameters, we varied the number ğ‘› of voters and
the number ğ‘š of candidates from 50 to 150 while executing BFT-
STV to reduce the committee of ğ‘š/2 governors. Recall that ğ‘š â‰¤ ğ‘›
(Â§3.2), so while we fixed ğ‘š = 50 while varying ğ‘›, we had to fix
ğ‘› = 150 to vary ğ‘š up to 150.

Figure 5 depicts the median execution times of BFT-STV and its
errors bars (as minima and maxima) over 3 runs for each different
pair of numbers ğ‘› and ğ‘š of voters and candidates, respectively.
To this end, for each of these three runs, we generated a random
ordinal ballot for each voter. More precisely, the top curve varies
the number ğ‘š of candidates whereas the bottom curve varies the
number ğ‘› of voters.

(1) First, we observe that the number of candidates impacts
significantly the performance with ğ‘› = 150 voters, which
confirms our expectation. However, we also observe that
the raise decreases as ğ‘š exceeds 100. We conjecture that
this is due to the way the Ethereum Virtual Machine [71]
garbage collects and alternates between CPU resource us-
age for transaction execution and I/O usage to persist the
information when the transaction increases.

(2) Second, we observe that when the number of voters increases
with ğ‘š = 50 the execution time increases sub-linearly: it
doubles while the number of voters triples. This is because
increasing the number ğ‘› of voters helps candidates reach the
quota ğ‘ğµ of votes rapidly without transferring the vote ex-
cess. Hence the committee is elected faster than expected and
raises only slightly the execution time (despite the extra loop
iterations due to the increased number of voters). Overall,
electing a committee of 75 blockchain nodes in under 4 min-
utes from 150 voters ranking 150 candidates demonstrates
the practicality of the BFT-STV smart contract.

Note that ensuring diversity by selecting governors from dif-
ferent countries limit the committee to less than 200 governors
anyway as there are only 195 universally recognized nations. The
combination of the results of Figures 4 and 5 indicates that a Soc-
Chain governed by each of the OECD members or Asian countries
or European countries could reconfigure in less than 5 minutes.

11

Figure 6: Throughput and latency, expressed as 50ğ‘¡â„, 90ğ‘¡â„ and
99ğ‘¡â„ percentiles, of SocChain when executed on from 20 to
100 nodes

Note that this is remarkably short compared to the 3-minute ex-
pected time taken to execute a single transaction in Ethereum (the
Ethereum congestion can make the transaction execution time
much longer [58]). While it was expected that the execution of the
BFT-STV would take longer as we increase the number of candi-
dates and voters (just like the complexity of STV increases with
the problem input size), it was unclear whether SocChain can scale
with the number of machines running the blockchain. To this end,
in the next section (Â§6.3), we evaluate the scalability as the impact
of the number of VMs participating in the blockchain protocol on
its performance.

6.3 Large-scale evaluation
In order to better assess the performance at large-scale, we measure
the throughput and latencies when running 100 nodes. For this
experiment we used native payment transactions of 107 bytes (we
evaluate SocChain later with our BFT-STV DApp).

Figure 6 depicts the throughput of SocChain with 20 to 100
blockchain nodes in the AWS Sydney availability zone. Each point
is the average over 3 runs and clients send 1500 transactions to
each of the SEVM nodes, each client sending at a rate of 4500 TPS.
We observe that the throughput remains above 2000 TPS up to
100 nodes and does not changes significantly. We conclude that
SocChain performs well in a network of up to 100 nodes. These
results can be attributed to the superblock optimization of SocChain.
The 50ğ‘¡â„, 90ğ‘¡â„ and 99ğ‘¡â„ percentiles show a steady rise as expected
with the increasing number of nodes. This is due to the network
overhead in the consensus caused by the increasing number of
nodes: 99% of the transactions are committed within 37 seconds for
100 nodes. These latencies are remarkably low compared to what
Ethereum already experienced: 22 seconds for the 50ğ‘¡â„ percentile
of inclusion time, 2 minutes 39 seconds for the 90ğ‘¡â„ percentile of
inclusion time and 47 minutes 34 seconds for the 99ğ‘¡â„ percentile of
inclusion time [58]. In addition, an inclusion does not guarantee a
commit in Ethereum as a transaction can be included in an uncle
block and be discarded and re-included up to 2 more times [69] later.
By contrast, the time to commit in SocChain remains low because
SocChain solves consensus deterministically before appending a
new block, hence an inclusion is a commit and its user does not
have to wait for consecutive appended blocks.

7 RELATED WORK
In this section, we present the work related to governance
for blockchains. Table 1, provides a summary of the existing
blockchains with reconfigurable governance. For the sake of brevity,
we omit in the discussion below the blockchains that assume syn-
chrony [1, 4, 45, 52, 57, 71, 74] or the ones that were shown vulner-
able in the absence of synchrony, including blockchains based on
proof-of-authority [28].

The aforementioned solutions weight each vote based on the
wealth or assets the corresponding voter owns: the more they own
the higher weight their vote gets. Given the Pareto Principle [53]
stating that few users typically own most of the resources (as an
example in 2021, the wealthiest 1% of US citizens owned about 1/3
of the total wealth4), these approaches are vulnerable as soon as
one manages to bribe the few wealthiest of all nodes as they likely
control a large part of the total stake.

7.1 Proof-of-stake blockchain governance
Algorand [36] was probably the first blockchain assuming that
bribery was not instantaneous like we do (Â§3.4). Algorand offers
governance through sortition, the act of electing governors ran-
domly among a set of candidates. This technique is similar to the
jury selection in trials. More precisely, each Algorand node returns
a hash â„ and a proof ğœ‹ by passing a publicly known pseudo random
input string to a verifiable random function locally signed. This
hash â„ helps select a node at random depending on the amount
of assets the corresponding user has at stake. The selected node
can act as a governor and participate in the consensus by piggy-
backing the sortition proof ğœ‹. To mitigate bribery attacks, Algorand
replaces governors at each step of the BA consensus protocol within
a consensus round. The key advantage of the sortition is that it is a
non-interactive cryptographic technique that prevents the adver-
sary from predicting the future governors. However, Algorand does
not aim at offering any proportional representation.

Polkadot [18] rotates its governors every era, a period that lasts
about one day, with a multi-winner election. Similarly, our BFT-
STV is a multi-winner election (Â§4) but can replace governors every
five minutes (Â§6). Another difference is that Polkadot exploits a
nominated proof-of-stake (NPOS): nominator nodes cast ballots
with their preferred candidates based on various parameters (e.g.,
security practices, staking levels and past performance). The nom-
inators are rewarded with a fraction of the governors gain upon
block creations. The key of NPOS is that the more stake a candidate
has, the more chance it has to be preferred by a candidate and to
eventually become a governor. A nice advantage over Algorand is
that Polkadotâ€™s election offers proportional justified representation
that limits under-representation. To avoid overrepresentation and
to make it expensive for an adversary to impose its candidates in
the election, Polkadot approximates a maxmin objective, but fails
at protecting against dictatorship.

EOS [31] runs a delegated multi-winner approval voting system
to elect 21 governors while ensuring some form of proportionality.
As opposed to our BFT-STV (Â§4), approval voting does not allow a
voter to indicate its preference between its preferred candidates. As
a result EOS cannot solve our secure governance problem (Def.3.2).
EOS exploits delegated proof-of-stake (DPOS) where token holders
elect governors by casting a vote whose weight is proportional to
what the tokens holders have at stake. The elected governors run
the consensus and as long as voters who own 2/3 of the stake vote
for a block proposed by governors, this block is appended to the
chain. EOS may fork in which case the longest chain is adopted
as the main one. By contrast, SocChain never forks to avoid risky
situations where conflicting transactions in different branches lead
to double spending.

7.2 Proof-of-work blockchain governance
Zilliqa [78] is a sharded blockchain that supports smart contracts
and reaches consensus using an efficient version of the leader-based
consensus protocol PBFT [17] based on EC-Schnorr multisigna-
ture [44, 59]. To shard the network and to reach consensus on
transactions, a committee of directory service (DS) nodes is elected
with a proof-of-work (PoW) puzzle. Once a candidate node finds
the nonce for the PoW, it generates a DS header and multicasts a
DS block to the current DS committee. Once the current DS com-
mittee reaches consensus on the DS block mined and multicast by
the candidate node, the new candidate node is added to the DS
committee and the oldest member of the DS committee is removed.
The protocol thus ensures that the latest ğ‘› nodes that have mined
a DS block are governors.

The hybrid consensus [54] is a theoretical consensus algorithm
for blockchain that selects the most recent â„“ block miners as gov-
ernors. Similar to Zilliqa, each governor is replaced one at a time
following a leader-based consensus algorithm. Unfortunately, we
are not aware of any implementation of the hybrid consensus.

Both approaches need as many leader-based consensus execu-
tions as there are governors to completely rotate them. By contrast,
SocChain rotates them all in a single consensus instance to mitigate
the risks of an adversary bribing progressively most of the current
governors.

7.3 BFT blockchain governance
The vast majority of byzantine fault tolerant (BFT) blockchains
assume that the list of governors is selected by an external service.
ComChain [65] lists the public keys of governors in configuration
blocks but assumes that the new lists of governors are proposed
by an external service. Similarly, Tendermint/Cosmos [62] lists the
public keys of governors in blocks but associates a voting power to
each validator based on its stake, hence risking the same bribery
attacks as other proof-of-stake blockchains (Â§7.1). SmartChain [9]
also stores the committee public keys in dedicated reconfiguration
blocks but simply grants governor credentials to every requesting
node, without requesting to go through an election. Libra [6] men-
tions a similar reconfiguration service but no details are provided
regarding the selection of governors. As far as we know other BFT
blockchains have a static set of consensus nodes, which makes them
more vulnerable to bribery attacks, including Stella [48], SBFT [38],
Concord [66] and Quorum [21].

4https://www.cnbc.com/2021/10/18/the-wealthiest-10percent-of-americans-own-a-
record-89percent-of-all-us-stocks.html.

12

8 CONCLUSION
We presented SocChain, a blockchain that solves the swift propor-
tional governance problem by electing a governance committee that
is proportionally representative of the voters and by reconfiguring
itself fast with this new governance. Its novelty lies in tolerating
ğ‘“ < ğ‘›/3 byzantine governors, preventing the adversary from act-
ing as a dictator and reconfiguring sufficiently fast to cope with
bribery attacks. Our evaluation shows that SocChain is practical
and performs efficiently at 100 nodes. This research bridges the gap
between computational social choice and blockchain governance
and opens up new research directions related to bribery mitigation
and non-dictatorship.

REFERENCES
[1] Ittai Abraham, Dahlia Malkhi, Kartik Nayak, Ling Ren, and Alexander Spiegel-
man. 2017. Solida: A Blockchain Protocol Based on Reconfigurable Byzantine
Consensus. In 21st International Conference on Principles of Distributed Systems.
25:1â€“25:19.

[2] Algorand. [n. d.].

the Algorand Blockchain.
Accessed:2021-05-28, https://medium.com/algorand/various-questions-about-
the-algorand-blockchain-ef8bf719f1f.

Various Questions about

[3] Kenneth J. Arrow. 1950. A Difficulty in the Concept of Social Welfare. Journal of

Political Economy 58, 4 (1950), 328â€“346.

[4] Vivek Kumar Bagaria, Sreeram Kannan, David Tse, Giulia C. Fanti, and Pramod
Viswanath. 2019. Prism: Deconstructing the Blockchain to Approach Physical
Limits. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and
Communications Security, CCS 2019, London, UK, November 11-15, 2019. 585â€“602.
[5] Arati Baliga, I Subhod, Pandurang Kamat, and Siddhartha Chatterjee. 2018.
Performance Evaluation of the Quorum Blockchain Platform. Technical Report
1809.03421. arXiv.

[6] Shehar Bano, Mathieu Baudet, Avery Ching, Andrey Chursin, George Danezis,
Francois Garillot, Zekun Li, Dahlia Malkhi, Oded Naor, Dmitri Perelman, and
Alberto Sonnino. 2019. State Machine Replication in the Libra Blockchain.
Accessed: 2019-10-01, https://developers.libra.org/docs/assets/papers/libra-
consensus-state-machine-replication-in-the-libra-blockchain.pdf.

[7] John J Bartholdi and James B Orlin. 1991. Single transferable vote resists strategic

voting. Social Choice and Welfare 8, 4 (1991), 341â€“354.

[8] Nathalie Bertrand, Vincent Gramoli, Igor Konnov, Marijana Lazic, Pierre Tholo-
niat, and Josef Widder. 2021. Compositional Verification of Byzantine Consensus.
Technical Report hal-03158911. HAL.

[9] Alysson Bessani, Eduardo Alchieri, JoÃ£o Sousa, AndrÃ© Oliveira, and Fernando
Pedone. 2020. From Byzantine Replication to Blockchain: Consensus is Only
the Beginning. In 50th Annual IEEE/IFIP International Conference on Dependable
Systems and Networks. 424â€“436.

[10] Alysson Bessani, Joao Sousa, and Eduardo E. P. Alchieri. 2014. State Machine
Replication for the Masses with BFT-SMaRt. In Proceedings of the 44th Annual
IEEE/IFIP International Conference on Dependable Systems and Networks. 355â€“362.
[11] D. Black. 1958. The Theory of Committees and Elections. Cambridge University

Press.

[12] Joseph Bonneau. 2016. Why Buy When You Can Rent? Bribery Attacks on
Bitcoin-Style Consensus. In Financial Cryptography and Data Security Workshops.
19â€“26.

[13] Ethan Buchman, Jae Kwon, and Zarko Milosevic. 2018. The latest gossip on BFT

consensus. Technical Report 1807.04938v3. arxiv.

[14] Jeff Burdges, Alfonso Cevallos, Peter Czaban, Rob Habermeier, Syed Hosseini,
Fabio Lama, Handan Kilinc Alper, Ximin Luo, Fatemeh Shirazi, Alistair Stewart,
and Gavin Wood. 2020. Overview of Polkadot and its Design Considerations.
Technical Report 2005.13456. arXiv.

[15] Christian Cachin, Daniel Collins, Tyler Crain, and Vincent Gramoli. 2020.
Anonymity Preserving Byzantine Vector Consensus. In Proceedings of the 25th
European Symposium on Research in Computer Security (ESORICS). 133â€“152.
[16] Christian Cachin, Daniel Collins, Tyler Crain, and Vincent Gramoli. 2020.
Anonymity Preserving Byzantine Vector Consensus. In 25th European Symposium
on Research in Computer Security (ESORICS) (Lecture Notes in Computer Science,
Vol. 12308), Liqun Chen, Ninghui Li, Kaitai Liang, and Steve A. Schneider (Eds.).
Springer, 133â€“152.

[17] Miguel Castro and Barbara Liskov. 2002. Practical Byzantine Fault Tolerance and
Proactive Recovery. ACM Trans. Comput. Syst. 20, 4 (Nov. 2002), 398â€“461.
[18] Alfonso Cevallos and Alistair Stewart. 2020. A verifiably secure and proportional

committee election rule. arXiv e-prints (2020), arXivâ€“2004.

[19] Alfonso Cevallos and Alistair Stewart. 2020. A verifiably secure and proportional

committee election rule. Technical Report arXiv:2004.12990. arXiv.

[20] Benjamin Y. Chan and Elaine Shi. 2020.

Streamlet: Textbook Streamlined
Blockchains. In Proceedings of the 2nd ACM Conference on Advances in Financial
Technologies. 1â€“11.

[21] JPMorgan Chase. [n. d.]. Quorum Whitepaper.

Accessed: 2020-12-
https://github.com/ConsenSys/quorum/blob/master/docs/Quorum%

04,
20Whitepaper%20v0.2.pdf.

[22] Pierre Civit, Seth Gilbert, and Vincent Gramoli. 2021. Polygraph: Accountable
Byzantine Agreement. In Proceedings of the 41st IEEE International Conference on
Distributed Computing Systems (ICDCSâ€™21).

[23] Tyler Crain, Vincent Gramoli, Mikel Larrea, and Michel Raynal. 2018. DBFT:
Efficient Leaderless Byzantine Consensus and its Application to Blockchains. In
Proc. 17th IEEE Int. Symp. Netw. Comp. and Appl (NCA). 1â€“8.

[24] Tyler Crain, Christopher Natoli, and Vincent Gramoli. 2021. Red Belly: a Secure,
Fair and Scalable Open Blockchain. In IEEE Symposium on Security and Privacy
(S&P). 1501â€“1518. https://www.computer.org/csdl/pds/api/csdl/proceedings/
download-article/1t0x9nljvwI/pdf

[25] M. Dummett. 1984. Voting Procedures. Oxford University Press.
[26] C. Dwork, N. Lynch, and L. Stockmeyer. 1988. Consensus in the Presence of

Partial Synchrony. J. ACM 35, 2 (1988), pp.288â€“323.

[27] ecanz21 2021. Proportional Representation Voting Systems of Australiaâ€™s Par-
liaments. Accessed:2021/06/04 â€“https://www.ecanz.gov.au/electoral-systems/
proportional.

[28] Parinya Ekparinya, Vincent Gramoli, and Guillaume Jourjon. 2020. The Attack
of the Clones against Proof-of-Authority. In Proceedings of the Network and
Distributed Systems Security Symposium (NDSSâ€™20).

[29] Edith Elkind, Piotr Faliszewski, Piotr Skowron, and Arkadii Slinko. 2017. Proper-
ties of multiwinner voting rules. Social Choice and Welfare 48, 3 (2017), 599â€“632.
[30] eos [n. d.]. BLOCK PRODUCERS RANKING - REAL TIME STATISTICS. Accessed:

2020-11-14, https://eosauthority.com/producers_rank.

[31] eos [n. d.].

EOS.IO Technical White Paper v2.

Accessed: 2020-12-
07, https://github.com/EOSIO/Documentation/blob/master/TechnicalWhitePaper.
md#consensus-algorithm-bft-dpos.

[32] eth2 [n. d.]. The ETH2 Upgrades. Accessed: 2020-11-14, https://ethereum.org/

en/eth2/.

[33] Piotr Faliszewski, Piotr Skowron, Arkadii Slinko, and Nimrod Talmon. 2017.
Multiwinner Voting: A NewChallenge for Social Choice Theory. Lulu.com.
[34] Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. 1985. Impossibility
of Distributed Consensus with One Faulty Process. J. ACM 32, 2 (April 1985),
374â€“382.

[35] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. 2015. The Bitcoin Backbone
Protocol: Analysis and Applications. In 34th Annu. Int. Conf. the Theory and
Applications of Crypto. Techniques. 281â€“310.

[36] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zeldovich.
2017. Algorand: Scaling Byzantine Agreements for Cryptocurrencies. In Proc.
26th Symp. Operating Syst. Principles. 51â€“68.

[37] Rachid Guerraoui, Petr Kuznetsov, Matteo Monti, Matej PavloviÄ, and Dragos-
Adrian Seredinschi. 2019. The Consensus Number of a Cryptocurrency. In Pro-
ceedings of the 2019 ACM Symposium on Principles of Distributed Computing.
307â€“316.

[38] Guy Golan Gueta, Ittai Abraham, Shelly Grossman, Dahlia Malkhi, Benny Pinkas,
Michael K. Reiter, Dragos-Adrian Seredinschi, Orr Tamir, and Alin Tomescu. 2019.
SBFT: a Scalable and Decentralized Trust Infrastructure. In Proceedings of the 49th
Annual IEEE/IFIP International Conference on Dependable Systems and Networks
(DSN).

[39] Jonathan Lundell & I D Hill. 2007. To advance the understanding of preferential

voting system - Notes on the Droop quota. Voting matters (2007).

[40] Kwon J. 2014. Tendermint: Consensus without Mining.
[41] Svante Janson. 2018. Thresholds quantifying proportionality criteria for election

methods. arXiv preprint arXiv:1810.06377 (2018).

[42] Lucianna Kiffer, Dave Levin, and Alan Mislove. 2017. Stick a Fork in It: Analyzing
the Ethereum Network Partition. In Proceedings of the 16th ACM Workshop on
Hot Topics in Networks. 94â€“100.

[43] Denis Kirillov, Vladimir Korkhov, Vadim Petrunin, Mikhail Makarov, Ildar M
Khamitov, and Victor Dostov. 2019.
Implementation of an e-voting scheme
using hyperledger fabric permissioned blockchain. In International Conference on
Computational Science and Its Applications. Springer, 509â€“521.

[44] Eleftherios Kokoris-Kogias, Philipp Jovanovic, Nicolas Gailly, Ismail Khoffi, Linus
Gasser, and Bryan Ford. 2016. Enhancing bitcoin security and performance with
strong consistency via collective signing. In 25th USENIX Security Symposium).
279â€“296.

[45] Eleftherios Kokoris-Kogias, Philipp Jovanovic, Linus Gasser, Nicolas Gailly, Ewa
Syta, and Bryan Ford. 2018. OmniLedger: A Secure, Scale-Out, Decentralized
Ledger via Sharding. In IEEE Symposium on Security and Privacy (S&P). 583â€“598.
https://doi.org/10.1109/SP.2018.000-5

[46] Jae Kwon. 2015. Tendermint, Consensus Without Mining. Accessed: 2020-12-04,

https://tendermint.com/static/docs/tendermint.pdf.

[47] L. Lamport, R. Shostak, and M. Pease. 1982. The Byzantine Generals Problem.

ACM Trans. Program. Lang. Syst. 4, 3 (July 1982), 382â€“401.

13

[48] Marta Lokhava, Giuliano Losa, David MaziÃ¨res, Graydon Hoare, Nicolas Barry,
Eli Gafni, Jonathan Jove, RafaÅ‚ Malinowsky, and Jed McCaleb. 2019. Fast and
Secure Global Payments with Stellar. In Proceedings of the 27th ACM Symposium
on Operating Systems Principles (SOSP). 80â€“96.

[49] Francis T. Lui. 1985. An Equilibrium Queuing Model of Bribery. Journal of

Political Economy (1985).

[50] Loi Luu, Viswesh Narayanan, Chaodong Zheng, Kunal Baweja, Seth Gilbert, and
Prateek Saxena. 2016. A Secure Sharding Protocol For Open Blockchains. In CCS.
[51] Finck Michelle. 2018. Blockchain Governance. Cambridge University Press, 182â€“

209. https://doi.org/10.1017/9781108609708.007

[52] Satoshi Nakamoto. 2008. Bitcoin: a peer-to-peer electronic cash system.
[53] Vilfredo Pareto. 1964. Cours dâ€™Ã‰conomie Politique: Nouvelle Ã©dition par G.-H.

Bousquet et G. Busino. Librairie Droz.

[54] Rafael Pass and Elaine Shi. 2017. Hybrid consensus: Efficient consensus in the
permissionless model. In 31st International Symposium on Distributed Computing
(DISC 2017). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik.

[55] Marshall C. Pease, Robert E. Shostak, and Leslie Lamport. 1980. Reaching Agree-

ment in the Presence of Faults. J. ACM 27, 2 (1980), 228â€“234.

[56] poa.network. 2022. PoA Validator DApp. Accessed: 2022-22-04 - https://validators.

poa.network/poa-dapps-validators.

[57] Team Rocket. 2018. Snowflake to Avalanche: A Novel Metastable Consensus
Protocol Family for Cryptocurrencies. Technical Report.
https://ipfs.io/ipfs/
QmUy4jh5mGNZvLkjies1RWM4YuvJh5o2FYopNPVYwrRVGV Accessed: 2021-
12-01.

[58] Michael Spain, Sean Foley, and Vincent Gramoli. 2019. The Impact of Ethereum
Throughput and Fees on the Transaction Latency during ICOs. In International
Conference on Blockchain, Economics, Security and Protocols (Tokenomicsâ€™19),
Vol. 71. Schloss Dagstuhl, 9:1â€“9:15.

[59] Ewa Syta, Iulia Tamas, Dylan Visher, David Isaac Wolinsky, Philipp Jovanovic,
Linus Gasser, Nicolas Gailly, Ismail Khoffi, and Bryan Ford. 2016. Keeping
authorities" honest or bust" with decentralized witness cosigning. In 2016 IEEE
Symposium on Security and Privacy (S&P). 526â€“545.

[60] Andrew S. Tanenbaum and Maarten van Steen. 2007. Distributed systems -

principles and paradigms, 2nd Edition. Pearson Education.

[61] Pavel Tarasov and Hitesh Tewari. 2017. Internet voting using zcash. IACR Cryptol.

ePrint Arch. 2017 (2017), 585.

[62] tendermint.com. [n. d.]. Tendermint.

Accessed: 2021-07-21 https://docs.

tendermint.com/master/.

[63] Nicolaus Tideman. 1995. The Single Transferable Vote. Journal of Economic
Perspectives 9, 1 (March 1995), 27â€“38. https://doi.org/10.1257/jep.9.1.27
[64] vec [n. d.]. VeChain Whitepaper 2.0 â€“ Governance. Accessed: 2021/06/07 â€“

https://www.vechain.org/whitepaper/#bit_dgkec.

[65] Guillaume Vizier and Vincent Gramoli. 2019. ComChain: A Blockchain with
Byzantine Fault Tolerant Reconfiguration. Concurrency and Computation, Practice
and Experience 32, 12 (Oct 2019).

[66] VMware. [n. d.]. Concord. Accessed: 2020-11-28, https://github.com/vmware/

concord.

[67] Qin Wang, Shiping Chen, and Yang Xiang. 2021. Anonymous Blockchain-Based
System for Consortium. ACM Trans. Manage. Inf. Syst. 12, 3, Article 26 (June
2021), 25 pages. https://doi.org/10.1145/3459087

[68] Nick Webb. 2018. A Fork in the Blockchain: Income Tax and the Bitcoin/Bitcoin
Cash Hard Fork. North Carolina Journal of Law & Technology 19, 4 (2018).
[69] Ingo Weber, Vincent Gramoli, Alexander Ponomarev, Mark Staples, Ralph Holz,
An Binh Tran, and Paul Rimba. 2017. On Availability for Blockchain-Based
Systems. In 36th IEEE Symposium on Reliable Distributed Systems, SRDS 2017,
Hong Kong, Hong Kong, September 26-29, 2017. 64â€“73.

[70] SJ Wels. 2019. Guaranteed-TX: The exploration of a guaranteed cross-shard trans-
action execution protocol for Ethereum 2.0. Masterâ€™s thesis. University of Twente.
[71] Gavin Wood. 2015. ETHEREUM: A Secure Decentralised Generalised Transaction

Ledger. Yellow paper.

[72] Douglas Woodall. 1994. Properties of preferential election rules. In Voting Matters.
Accessed: 04/05/2021, https://www.votingmatters.org.uk/ISSUE3/P5.HTM.
[73] Maofan Yin, Dahlia Malkhi, Michael K. Reiter, Guy Golan Gueta, and Ittai
Abraham. 2019. HotStuff: BFT Consensus with Linearity and Responsiveness.
In Proceedings of the 2019 ACM Symposium on Principles of Distributed Com-
puting. Association for Computing Machinery, New York, NY, USA. https:
//doi.org/10.1145/3293611.3331591

[74] Mahdi Zamani, Mahnush Movahedi, and Mariana Raykova. 2018. RapidChain:
Scaling Blockchain via Full Sharding. In Proceedings of the 2018 ACM SIGSAC
Conference on Computer and Communications Security (Toronto, Canada) (CCS
â€™18). Association for Computing Machinery, New York, NY, USA, 931â€“948. https:
//doi.org/10.1145/3243734.3243853

[75] Vlad Zamfir. 2019. Blockchain governance. In Ethereum Community Conference.
Accessed: 2021-05-28, https://www.youtube.com/watch?v=PKyk5DnmW50.
[76] Yunhao Zhang, Srinath Setty, Qi Chen, Lidong Zhou, and Lorenzo Alvisi. 2020.
Byzantine Ordered Consensus without Byzantine Oligarchy. In 14th USENIX
Symposium on Operating Systems Design and Implementation (OSDI 20). USENIX

14

Association, 633â€“649. https://www.usenix.org/conference/osdi20/presentation/
zhang-yunhao

[77] Zhichao Zhao and T-H Hubert Chan. 2015. How to vote privately using bitcoin.
In International Conference on Information and Communications Security. Springer,
82â€“96.

[78] zilliqa [n. d.]. The ZILLIQA Technical Whitepaper. https://docs.zilliqa.com/

whitepaper.pdf https://docs.zilliqa.com/whitepaper.pdf.

A PROOFS OF BLOCKCHAIN SAFETY,

LIVENESS AND VALIDITY

In this section, we show that SocChain solves the blockchain prob-
lem (Def. 2). For the sake of simplicity in the proofs, we assume
that there are as many nodes playing the roles of consensus nodes
and state nodes and are collocated on the same physical machine.

Lemma 1. If at least one correct node proposes to a consensus
instance ğ‘–, then every correct node decides on the same superblock at
consensus instance ğ‘–.

Proof. The propose(Â·) function is the same as in the Red Belly
Blockchain [24] except that we do not use the verifiable reliable
broadcast and reconciliation which ensure SBC-validity. Instead we
use reliable broadcast and no reconciliation. As such, following from
the proof of [24], our blockchain nodes ensure SBC-termination
that states that every correct node eventually decides on a set of
transactions and SBC-agreement that states no two correct nodes
decide on different sets of transactions. Since SocChain consensus
returns a superblock (which is a set of transactions) at each instance
of consensus ğ‘–, we can say every correct blockchain node decides
â–¡
on the same superblock at consensus instance ğ‘–.

Lemma 2. Variablesğ‘‡ ğ‘‹ğ‘˜ , ğ‘…ğ‘˜ , ğ‘†ğ‘›ğ‘’ğ‘¥ğ‘¡ğ‘˜ , timestampğ‘˜ and ğ‘£ğ‘ğ‘™ğ‘˜ become
identical after executing line 31 of iteration ğ‘˜ for any two correct
blockchain nodes ğ‘ƒ1 and ğ‘ƒ2.

Proof. From Lemma 1, every correct consensus node decides on
the same superblock at consensus instance ğ‘–. As a result, each cor-
rect blockchain node receives the same superblock from consensus
instance ğ‘– (Algorithm 6, line 21). Therefore, each props[k] for any
integer ğ‘˜ âˆˆ [0; ğ‘›) becomes identical at any two correct blockchain
nodes ğ‘ƒ1 and ğ‘ƒ2 (Algorithm 6, line 23) for consensus instance ğ‘–. As
a result, ğ‘‡ ğ‘‹ğ‘˜ , ğ‘…ğ‘˜ , ğ‘†ğ‘›ğ‘’ğ‘¥ğ‘¡ğ‘˜ , ğ‘¡ğ‘–ğ‘šğ‘’ğ‘ ğ‘¡ğ‘ğ‘šğ‘ğ‘˜ and ğ‘£ğ‘ğ‘™ğ‘˜ also become identi-
cal at ğ‘˜ for ğ‘ƒ1 and ğ‘ƒ2 for consensus instance ğ‘– (Algorithm 6, lines
â–¡
30â€“33).

Lemma 3. At each index â„“ of the chain, all correct blockchain nodes

can only append the same block ğµâ„“ .

For the next lemma we refer to ğµ0 as the genesis block of Soc-

Chain.

Proof. The proof is by induction on the index of the blocks in

the chain.

â€¢ Base case: if â„“ = 1, then â„(ğ» (ğµ0)) âˆˆ ğµ1. Since â„(ğ» (ğµ0)) is
the hash of the header of the genesis block, it is the same for
all correct nodes of SocChain. We know from Lemma 2 that
variables â„(ğ‘†ğ‘›ğ‘’ğ‘¥ğ‘¡ğ‘˜ ), â„(TXğ‘˜ ), â„(ğ‘…ğ‘˜ ), valğ‘˜ and timestampğ‘˜ are
identical after line 31 onwards for any two correct blockchain
nodes ğ‘ƒ1 and ğ‘ƒ2. Therefore, ğµ1 is identical for all correct
blockchain nodes.

â€¢ Inductive case: Let us assume that ğµâ„“âˆ’1 is identical for all
correct blockchain nodes, we show that ğµâ„“ is identical for all
correct blockchain nodes. Since ğµâ„“âˆ’1 is identical, â„(ğ» (ğµâ„“âˆ’1))
is identical for all correct blockchain nodes. Using the argu-
ment used in the base case, any variable â„(ğ‘†ğ‘›ğ‘’ğ‘¥ğ‘¡ğ‘˜ ), â„(ğ‘‡ ğ‘‹ğ‘˜ ),
â„(ğ‘…ğ‘˜ ), ğ‘£ğ‘ğ‘™ğ‘˜ and ğ‘¡ğ‘–ğ‘šğ‘’ğ‘ ğ‘¡ğ‘ğ‘šğ‘ğ‘˜ are identical after line 31 on-
wards for any two correct blockchain nodes ğ‘ƒ1 and ğ‘ƒ2.
Since ğµâ„“ â† â„(ğ» (ğµâ„“âˆ’1)), â„(Snextk ), â„(ğ‘‡ ğ‘‹ğ‘˜ ), â„(ğ‘…ğ‘˜ ), ğºğ‘ˆğ‘˜, ğºğ¿,
ğ‘›ğ‘œğ‘›ğ‘ğ‘’, ğ‘¡ğ‘–ğ‘šğ‘’ğ‘ ğ‘¡ğ‘ğ‘šğ‘ğ‘˜, ğ‘£ğ‘ğ‘™ğ‘˜ , it must also become identical for
all blockchain nodes after line 31 onwards.

Therefore, by induction on each index â„“, ğµâ„“ becomes identical for
all correct blockchain nodes when ğµâ„“ is constructed at line 33. â–¡

The next three theorems show that SocChain satisfies each of

the three properties of the blockchain problem (Definition 2).

Theorem 3. SocChain satisfies the safety property.

Proof. The proof follows from the fact that any block ğµâ„“ at
index â„“ of the chain is identical for all correct blockchain nodes due
to Lemma 3.

Due to network asynchrony, it could be that a correct node ğ‘ƒ1
is aware of block ğµâ„“+1 at index â„“ + 1, whereas another correct node
ğ‘ƒ2 has not created this block ğµâ„“+1 yet. At this time, ğ‘ƒ2 maintains a
chain of blocks that is a prefix of the chain maintained by ğ‘ƒ1. And
more generally, the two chains of blocks maintained locally by two
correct blockchain nodes are either identical or one is a prefix of
â–¡
the other.

Theorem 4. SocChain satisfies the validity property.

Proof. From Algorithm 6, line 25, only valid transactions are
executed and added only such valid transactions are added to block
ğµâ„“ (Algorithm 6 - lines 28 and 33). Therefore, âˆ€ indexes â„“, ğµâ„“ is valid
â–¡
âˆ€ correct blockchain nodes.

Theorem 5. SocChain satisfies the liveness property.

Proof. As long as a correct replica receives a transaction, we
know that the transaction is eventually proposed by line 4 of Algo-
rithm 4. The proof follows from the termination of the consensus
algorithm and the fact that SocChain keeps spawning new consen-
sus instance as long as correct replicas have pending transactions.
The consensus algorithm is DBFT [23] and was shown terminating
â–¡
with parameterized model checking [8].

B DISCUSSION
Although SocChain offers the swift governance reconfiguration by
solving the secure governance problem (Def. 1) and the blockchain
problem (Def. 2), there are few secondary aspects that need to be
detailed or addressed. Below, we discuss these aspects and propose
different extensions to SocChain.

Know-your-customer (KYC) initial selection. In SocChain, we em-
ploy a know-your-customer (KYC) process when deploying Soc-
Chain for the first time in order to assign candidate and voter
permissions to blockchain nodes. Similar to VeChain [64] or the
EOS-based Voice social network5, we require potential voters and

5https://crypto-economy.com/eos-based-social-network-voice-announces-human-
sign-up-an-alternative-for-kyc/

15

candidates to provide personal information to a decentralized foun-
dation before they can be granted the desired permissions. This
personal information can include the name of the user, their bio-
metric details and their preferred role and can be traded against a
permission to act as a candidate for election or a voter. The foun-
dation then verifies each user personal information and, when the
verification is successful, assigns the specified role to the corre-
sponding user and a one-time secret sent through a secure channel
to join SocChain. In SocChain, each voter node is given equal op-
portunity to elect a candidate to the committee of blockchain nodes.
This KYC-based solution thus copes with the risks of building an
oligarchy of wealthiest users through proof-of-stake (PoS) or of
most powerful machines through proof-of-work (PoW). Although
this KYC-based solution requires an offchain verification that is
external to the blockchain, note that it is only needed at bootstrap
time: any blockchain node deciding to run the code of SocChain (in-
cluding the BFT-STV smart contract codes) necessarily accepts that
the set of voters can automatically elect new candidates and new
voters every ğ‘¥ blocks without the control of any external company,
jurisdiction or foundation.

A possible attack is to upload a bribing smart contract that re-
wards voters if a specific set of candidates is elected. We underscore
that this cannot happen in-band, since such a malicious smart con-
tract needs to be deployed for such a process to take place, and
since we assume less than 1/3 of nodes are byzantine at all times,
such deployments are impossible as a majority would not agree
when reaching consensus.

Domain Name Service (DNS). For the sake of simplicity in the
design of our solution, we implicitly assumed that the IP addresses
were static so that nodes would simply need to subscribe to the
BFT-STV smart contract to receive an emit event informing them
of a list of IP addresses (Algorithm 1 line 29) and allowing thems
to reconnect to the blockchain nodes running the consensus ser-
vice. Although this assumption is suitable when experimenting
on a controlled set of VMs provided by a cloud provider, the IP
addresses of Internet users are often dynamically assigned, which
makes our solution unrealistic. One can easily adapt the current
implementation to support domain names instead of IP addresses.
While this solution requires a Domain Name Service (DNS) that, if
centralized, could defeat the purpose of the blockchain, note that
the hard-coded DNS server addresses are already used by classic
blockchains for node discovery [52]. SocChain can exploit DNS in a
similar fashion but to offer governance reconfiguration by updating
promptly the DNS so as to redirect all clients to the new committee
and to mitigate long-range attacks.

Gas cost of reconfiguration execution. As SocChain builds upon
the Ethereum Virtual Machine (EVM) [71], it inherits the notion of
gas that avoids the infinite execution of smart contracts. The gas
is a unit that reflects the work required for a particular sequence
of execution steps in Ethereum [71]. The more computation is
required to execute a transaction, the more gas this transaction
requires to complete. It is the clientâ€™s role to pay each unit of gas
that is consumed by the transaction it issued in the blockchain. The
price of this gas unit is known as the gas price and is considered as
the transaction fee to reward the blockchain node (called â€˜minerâ€™
in Ethereum) who mined the block containing the transaction. In

the BFT-STV smart contract, the election execution cost between
340029258 and 2347870086 gas units. The gas price depends on the
network traffic and if a client requires to have their transactions
treated as priority by miners, then they should include a high gas
price. However, if we use a high gas price, the transaction cost
becomes extremely high and almost unaffordable for a voter. To
mitigate this issue, we allow transactions that invoke the cast-ballot
function at line 12 of Algorithm 1 to be treated with equal priority
and have priority over the rest of the transactions despite using
a low gas price. This allows, voters to participate in the election
without incurring high costs.

Period of committee change. As we already mentioned in Figure 2,
SocChain starts a new configuration every ğ‘¥ blocks, where ğ‘¥ = 100
by default. However, as SocChain produces block on-demand (af-
ter receiving sufficiently many transactions), triggering the next
reconfiguration could take a very long time, if for example transac-
tions were issued rarely. Instead, we need to rapidly reconfigure
SocChain so that ğ‘› voters get re-elected before ğ‘›/3 of them get
corrupted through a bribery attack. Otherwise, an adversary could
gain progressively the control of a coalition of ğ‘›/3 or more voters
to finally dictate the decisions to the rest of the blockchain nodes.
To cope with this issue, we require every blockchain node offering
the SocChain service to spawn no-op transactions on a regular
basis (line 4 of Algorithm 4). As blockchain nodes get rewarded
based on the service they offer, this reward can be used to compen-
sate the loss associated by these no-op transaction fees. Provided
that the clock skews between correct blockchain nodes is bounded,
then these no-op transactions should ensure that reconfiguration
occurs sufficiently frequently to cope with bribery attacks.

Privacy, pseudonymity and anonymity. To maintain the integrity
of the voting protocol and to prevent users from influencing one
another, the voting protocol should remain anonymous [15]. As
the smart contract is stored in cleartext in the blockchain data
structures, a honest but curious adversary could easily map the
public key of a voter to its cast ballot. This preserves pseudonymity:
as long as this user does not link publicly its identity to its public key,
then it remains anonymous. To offer strong anonymity, SocChain
can be combined with a commit-reveal scheme [43, 77] or ring
signature [16] to reveal the voter once the election terminates, or
homorphic encryption [67] or zk-SNARK [61] on top of SocChain.

16

C BFT-STV SMART CONTRACT

pragma solidity $^0.4.0$;
pragma experimental ABIEncoderV2;

contract Committee {

string [] committee;
address public chairperson;
mapping(string => bool) hasIp;
mapping(string => bool) hasCalled;
mapping(address => string) WallettoIP;
mapping(uint => string []) ballots; // mapping between ballot number and the vote transferrable to the next round
mapping(string => uint) votes;
mapping(bytes32 => uint) rest;
mapping(uint => uint) ballot-index;
string [] public selected;
string [] surplus-current;
uint32 [] private digits;
bytes32 [] hashes;
uint member;
mapping(string => uint) transfer-vote;
mapping(string => uint) tot-surplus;
mapping(uint => uint) indexers;
uint c-ballot;
uint threshold;
uint size;
uint select;
uint transfer;
uint k;
uint rest-tot;
uint quota;
uint min;
uint eliminatedcount;
uint round;
bool val;
bool excess;
bool eliminated;
bool elect;
mapping(string => bool) elected;
event notify(string []);
constructor() public {

chairperson = msg.sender;
c-ballot = 0;

}

// initial set of node ips and the size of the committe is parse by the chairperson
function addIp (string [] memory ip, uint members, string[] memory wallets) public {

delete committee;
require(

msg.sender == chairperson,
"Only chairperson can give right to vote."

);
// committee here is the initial set of nodes -- this is equal to candidates
for (uint t = 0; t < ip.length; t++){

committee.push(ip[t]);
WallettoIP[parseAddr(wallets[t])] = ip[t];
elected[ip[t]] = false;
hasIp[ip[t]] = true;
hasCalled[ip[t]] = false;

}
size = committee.length;
member = members;
threshold = size - (size - 1)/3;
quota=(threshold/(member+1))+1;
// members is the number of participants per committee

}

17

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67

68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136

// you have to change this function according to STV
function createCommittee (string [] memory candidates) public {

// if the caller of this function is in the list of ips added by the chairperson, and if they haven't call this function
// before - because we don't want t+1 be reached by a malicious node calling this function multiple times
require(hasIp[WallettoIP[msg.sender]] == true & hasCalled[WallettoIP[msg.sender]] == false);
hasCalled[WallettoIP[msg.sender]] = true;

// check if the IPs of the candidates received are the same as the addIP candidates
for(uint i=0; i<candidates.length; i++) {

for(uint z=0; z<committee.length; z++) {

if(keccak256(abi.encodePacked(candidates[i]))==keccak256(abi.encodePacked(committee[z]))){

ballots[c-ballot].push(candidates[i]);
votes[candidates[i]]=0;
transfer-vote[candidates[i]]=0;

}

}

}
if(ballots[c-ballot].length !=0) {

c-ballot=c-ballot + 1;

}
if(c-ballot == threshold) {

// start doing stv
for(uint a=0; a<c-ballot; a++) {

ballot-index[a]=0;

}
round = 0;
eliminatedcount=0;
// first preference vote calculation
for (a = 0; a<c-ballot; a++){

votes[ballots[a][round]]=votes[ballots[a][round]]+1;

}

// do until the number of seats-members is filled
while ((selected.length < member) & round<size) {

// loop through ballot and count votes
elect = false;
excess = false;
eliminated = false;
// add changes from here //
val=next-pref();
if (val==true) {
elect = true;

}
if (elect == false) {

// remove least voted
min = 100000;
// minimum vote of all candidates (non elected) is eliminated
for (a = 0; a<c-ballot; a++) {

for(uint x=ballot-index[c-ballot]; x<size; x++) {

if((votes[ballots[a][x]] < min) & !elected[ballots[a][x]]){

min = votes[ballots[a][x]];

}

}

}
eliminate();

}
if ((size-eliminatedcount)==member) {

break;

}
round = round + 1;

}

// to add the remainder of members //
min = minimum();
while((size-eliminatedcount) >member) {

for (a = 0; a<c-ballot; a++) {

for(x=0; x<size; x++) {

if(votes[ballots[a][x]]==min & (size-eliminatedcount) >member & votes[ballots[a][x]]!=10000000){

18

137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205

votes[ballots[a][x]]=10000000;
eliminatedcount=eliminatedcount+1;
min = minimum();

}

}

}

}
// add the new section here - if the seats to be selected equals the non eliminated candidates (won and not yet elected),
// assign already non elected and non eliminated candidates to the seats and exit the loop.
if((size - eliminatedcount) == member) {

for(a = 0; a<c-ballot; a++) {

for(x=0; x<size; x++) {

if(votes[ballots[a][x]]!=10000000 & !elected[ballots[a][x]] & (selected.length)<member){

selected.push(ballots[a][x]);
elected[ballots[a][x]]=true;

}

}

}

}

emit notify(selected);

}

function minimum() returns (uint mins){

mins = 100000;
// minimum vote of all candidates is eliminated
for (uint a = 0; a<c-ballot; a++){

for(uint x=0; x<size; x++){

if((votes[ballots[a][x]] < mins) & !elected[ballots[a][x]]){

mins = votes[ballots[a][x]];

}

}

}
return mins;

}

function next-pref() public returns (bool elec){

for (uint s=0; s<committee.length; s++) {

transfer-vote[committee[s]]=0;
tot-surplus[committee[s]]=0;

}
for (s=0; s<hashes.length; s++) {

rest[hashes[s]] = 0;

}
surplus-current.length=0;
elect=false;
excess=false;

if (selected.length < member) {

for (s=0; s<c-ballot; s++) {

for (uint x=ballot-index[s]; x<size; x++) {

if (votes[ballots[s][x]]>=quota & votes[ballots[s][x]]!=10000000 & elected[ballots[s][x]] == false) {

elected[ballots[s][x]] = true;
selected.push(ballots[s][x]);
elect = true;
transfer = votes[ballots[s][x]] - quota;
votes[ballots[s][x]]=quota;
transfer-vote[ballots[s][x]] = transfer;
surplus-current.push(ballots[s][x]);
ballot-index[c-ballot]=x;
excess = true;

}

}

}

19

206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274

if (excess) {

// break the surplus ballots to those that have the same surplus elected candidate
for(uint a=0; a< c-ballot; a++) {

indexers[a] = 7000;

}
for (uint j=0; j<c-ballot; j++) {

for (k=0; k<surplus-current.length; k++) {

if (keccak256(abi.encodePacked(ballots[j][ballot-index[j]]))==keccak256(abi.encodePacked(surplus-current[k]))) {

tot-surplus[ballots[j][ballot-index[j]]] = tot-surplus[ballots[j][ballot-index[j]]] + 1;
x = 1;
if ((ballot-index[j]+x)<(size -1)) {

while((elected[ballots[j][ballot-index[j]+x]] || votes[ballots[j][ballot-index[j]+x]]==10000000)
& (ballot-index[j]+x) < (size -2)) {

x = x + 1;

}

if(!elected[ballots[j][ballot-index[j]+x]] & (ballot-index[j]+x)<size){

rest[keccak256(abi.encodePacked(ballots[j][ballot-index[j]],ballots[j][ballot-index[j]+x]))] =

rest[keccak256(abi.encodePacked(ballots[j][ballot-index[j]],ballots[j][ballot-index[j]+x]))] + 1; hashes.push(keccak256(abi.encodePacked(ballots[j][ballot-index[j]],ballots[j][ballot-index[j]+x])));

// mapping for ballot number => current indexer
indexers[j]=ballot-index[j]+x;

}

}

}

}

}
// divide and add the transfered votes
for(j=0; j< c-ballot; j ++) {
for(x=1; x<(size-1); x++) {

//maybe this might throw an error-look into it later
if ((ballot-index[j]+x) < size & rest[keccak256(abi.encodePacked(ballots[j][ballot-index[j]],

ballots[j][ballot-index[j]+x]))] != 0
& !elected[ballots[j][ballot-index[j]+x]]
& tot-surplus[ballots[j][ballot-index[j]]]!=0
& votes[ballots[j][ballot-index[j]]] != 10000000
& votes[ballots[j][ballot-index[j]+x]]!=10000000) {

votes[ballots[j][ballot-index[j]+x]] = votes[ballots[j][ballot-index[j]+x]]

+ transfer-vote[ballots[j][ballot-index[j]]]
* rest[keccak256(abi.encodePacked(ballots[j][ballot-index[j]],ballots[j][ballot-index[j]+x]))]
/ tot-surplus[ballots[j][ballot-index[j]]];

rest[keccak256(abi.encodePacked(ballots[j][ballot-index[j]],ballots[j][ballot-index[j]+x]))] = 0;

}

}

}
// moving the indexer to next //
for(a=0; a< c-ballot; a++){
if(indexers[a]!=7000){

ballot-index[a]=indexers[a];

}

}

}

}
return elect;

}

function eliminate() {

uint x;
for (uint s=0; s<hashes.length; s++) {

rest[hashes[s]] = 0;

}
for (uint a = 0; a<c-ballot; a++) {

for (uint m=ballot-index[a]; m<size; m++) {

if (votes[ballots[a][m]] == min & !elected[ballots[a][m]] & votes[ballots[a][m]] != 10000000 & !eliminated) {

// if 0 just eliminate
if (votes[ballots[a][m]] == 0) {

votes[ballots[a][m]] = 10000000;
eliminated=true;
eliminatedcount=eliminatedcount+1;

20

275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325

//if it is the current index being eliminated
x=1;
if ((m == ballot-index[a]) & (m<size-1)) {

while((elected[ballots[a][m+x]] || votes[ballots[a][m+x]]==10000000) & (m+x)<(size -1)){

x=x+1;

}
if (!elected[ballots[a][m+x]] & votes[ballots[a][m+x]]!=10000000) {

ballot-index[a]=m+x;

}

}
break;

}
// otherwise //
x = 1;
if (m<(size-1)) {

while((elected[ballots[a][m+x]] || votes[ballots[a][m+x]]==10000000) & (m+x)<(size -1)) {

x = x + 1;

}
if (!elected[ballots[a][m+x]] & (m+x)<size) {

rest[keccak256(abi.encodePacked(ballots[a][m],ballots[a][m+x]))] =

rest[keccak256(abi.encodePacked(ballots[a][m],ballots[a][m+x]))] + 1;
hashes.push(keccak256(abi.encodePacked(ballots[a][m],ballots[a][m+x])));

}

}

}

}

}
// transfer to the next preferences
for (a = 0; a<c-ballot; a++) {

x=0;
while(x<(size-1) & !eliminated){

if (rest[keccak256(abi.encodePacked(ballots[a][x],ballots[a][x+1]))] != 0

& votes[ballots[a][x]]!=10000000
& votes[ballots[a][x+1]]!=10000000
& !elected[ballots[a][x]]) {
if (votes[ballots[a][x]]!=0) {

votes[ballots[a][x+1]] = votes[ballots[a][x+1]]

+ min*rest[keccak256(abi.encodePacked(ballots[a][x],ballots[a][x+1]))]
/ (votes[ballots[a][x]]);

ballot-index[a]=x+1;

}
rest[keccak256(abi.encodePacked(ballots[a][x],ballots[a][x+1]))] = 0;
votes[ballots[a][x]] = 10000000;
eliminatedcount=eliminatedcount+1;
eliminated = true;

}
x=x+1;

}

}

}

}

21

