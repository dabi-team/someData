Zef: Low-latency, Scalable, Private Payments

Mathieu Baudet
mathieu.baudet@zefchain.com
Zefchain Labs*

Mahimna Kelkar
mahimna@cs.cornell.edu
Cornell University

2
2
0
2

r
a

M
8

]

R
C
.
s
c
[

4
v
1
7
6
5
0
.
1
0
2
2
:
v
i
X
r
a

ABSTRACT
We introduce Zef, the first Byzantine-Fault Tolerant (BFT) protocol
to support payments in anonymous digital coins at arbitrary scale.
Zef follows the communication and security model of FastPay [5]:
both protocols are asynchronous, low-latency, linearly-scalable,
and powered by partially-trusted sharded authorities. Zef further
introduces opaque coins represented as off-chain certificates that
are bound to user accounts. In order to hide the face values of coins
when a payment operation consumes or creates them, Zef uses
random commitments and NIZK proofs. Created coins are made
unlinkable using the blind and randomizable threshold anonymous
credentials of Coconut [33]. To control storage costs associated
with coin replay prevention, Zef accounts are designed so that
data can be safely removed once an account is deactivated. Besides
the specifications and a detailed analysis of the protocol, we are
making available an open-source implementation of Zef in Rust. Our
extensive benchmarks on AWS confirm textbook linear scalability
and demonstrate a confirmation time under one second at nominal
capacity. Compared to existing anonymous payment systems based
on a blockchain [24, 40], this represents a latency speedup of three
orders of magnitude, with no theoretical limit on throughput.

1 INTRODUCTION
Anonymous payment systems have been an exciting research area
in cryptography since Chaum‚Äôs seminal work [13] on e-cash. Early
e-cash schemes [12, 13, 31] however required a centralized issuer
to operate, usually in the form of a trusted commercial bank, which
hampered their adoption. In recent years, the advent of networks
like Bitcoin has sparked renewed interest in privacy-preserving
decentralized payment systems. A number of protocols [7, 23, 24]
focusing on anonymous payments are now deployed as permission-
less blockchains.

Compared to traditional global payment infrastructures (aka.
RTGS systems [6]), however, decentralized anonymous payment
systems have not yet reached performance levels able to sustain
large-scale adoption. For instance, due to high computational costs,
only 2% of Zcash [40] transactions commonly take advantage of
the privacy features offered by the platform [1].

At the other end of the performance spectrum, the FastPay pro-
tocol [5] does not support anonymous payments but offers low-
latency transfers in the range of 100-200 ms and arbitrary (linear)
scalability. FastPay operates in the Byzantine-Fault-Tolerant (BFT)
model with an asynchronous network. This makes FastPay suitable
for a deployment as a high-performance sidechain of an existing

*The main part of this work was conducted while the author was at Facebook.

Alberto Sonnino
alberto@mystenlabs.com
Mysten Labs*

George Danezis
george@mystenlabs.com
Mysten Labs and University College London (UCL)

blockchain. Remarkably, in order to scale linearly, FastPay is built
solely on consistent broadcast between validators‚Äîas opposed to
using a BFT consensus (see e.g., [10]).

In this work, we revisit the FastPay design with privacy, storage
costs, and extensibility in mind. In effect, we propose Zef, the first
linearly-scalable BFT protocol for anonymous payments with sub-
second confirmation time.

The Zef Protocol. Zef extends FastPay with digital coins that are
both opaque and unlinkable (in short anonymous). To this aim, Zef
combines several privacy-preserving techniques: (i) randomized
commitments and Non-Interactive Zero-Knowledge (NIZK) proofs
(e.g., [23]) provide opacity, that is, hide payment values; (ii) blind and
randomizable signatures (e.g., [33]) ensure unlinkability, meaning
that the relation between senders and receivers is hidden.

Technical Challenges. As FastPay, Zef achieves linear scalabil-
ity by relying only on consistent broadcast [10]. Implementing
anonymous coins in this setting poses three important challenges.

‚Ä¢ Double spending: In the absence of a consensus protocol be-
tween validators, one cannot track the coins that have been
spent in a single replicated data-structure. When coins are con-
sumed to create new ones, we must also ensure that intermediate
messages cannot be replayed to mint a different set of coins. We
address this challenge by tracking input coins in one spent list
per account and by introducing hash commitments to bind input
coins with their outputs.

‚Ä¢ Storage costs: Maintaining a spent list for each account while
sustaining high throughput raises the question of storage costs.
Spent lists must be readily accessible thus cannot be stored in
cold storage. To make things worse, user accounts in FastPay
can never be deleted due to the risk of replay attacks. To address
this challenge, we design Zef accounts so that account data are
safely removable once an account is deactivated by its owner.
Concretely, this requires changing how user accounts are ad-
dressed in the system: instead of public keys chosen by users,
Zef must generate a unique (i.e. non-replayable) address when
a new account is created. However, in the absence of consensus,
address generation cannot rely on a replicated state.

‚Ä¢ Implementation of privacy primitives: While creating NIZK
proofs on a predicate involving blind signatures, value conser-
vation, and range constraints is theoretically possible, we wish
to avoid the corresponding engineering and computational com-
plexity in our implementation. To do so, we combine the Co-
conut scheme [33] and Bulletproofs [9] to implement digital
coins directly.

 
 
 
 
 
 
Contributions. (1) To support digital coins while controlling stor-
age costs, we revisit the design of FastPay accounts: we propose a
unified protocol for scalable accounts operations where accounts
are addressed by unique, non-replayable identifiers (UIDs) and sup-
port a variety of operations such as account creation, deactivation,
transparent payments, and ownership transfer. Importantly, all
account operations in Zef, including generation of system-wide
unique identifiers, are linearly scalable, consensus-free, and only re-
quire elementary cryptography (hashing and signing). (2) Building
on these new foundations, we describe and analyze the first asyn-
chronous BFT protocol for opaque, unlinkable payments with linear
(aka ‚Äúhorizontal") scalability and sub-second latency. (3) Finally, we
are making available an open-source prototype implementation of
Zef in Rust and provide extensive benchmarks to evaluate both the
scalability and the latency of anonymous payments.

2 BACKGROUND AND RELATED WORK
FastPay. FastPay [5] was recently proposed as a sidechain protocol
for low-latency, high-throughput payments in the Byzantine-Fault
Tolerant model with asynchronous communication.
‚Ä¢ Sidechain protocol: FastPay is primarily meant as a scalability
solution on top of an existing blockchain with smart contracts
(e.g. Ethereum [37]).

‚Ä¢ Byzantine-Fault Tolerance: ùëÅ = 3ùëì + 1 replicas called au-
thorities are designated to operate the system and process the
clients‚Äô requests. A fixed set of at most ùëì authorities may be
malicious (i.e. deviate from the protocol).

‚Ä¢ Low latency: Authorities do not interact with each other (e.g.
running a mempool or a consensus protocol). Client operations
succeed predictably after a limited number of client/authorities
round trips. Notably, in FastPay, a single round-trip with author-
ities suffices to both initiate a payment and obtain a certificate
proving that the transfer is final.

‚Ä¢ Scalability: Each authority operates an arbitrary number of
logical shards, across many physical hosts. By design, each client
request is processed by a single shard within each authority.
Within an authority, communication between shards is minimal
and never blocks a client request.

‚Ä¢ Asynchronous communication: Malicious nodes may col-
lude with the network to prioritize or delay certain messages.
Progress is guaranteed when messages eventually arrive.

In a nutshell, the state of the Fastpay accounts is replicated on
a set of authorities. Each account contains a public key that can
authorize payments out, a sequence number and a balance. Account
owners authorize payments by signing them with their account
key and including the recipient amount and payment value. An
authorized payment is sent to all authorities, who countersign it if
it contains the next sequence number; there are enough funds; and,
it is the first for this account and sequence number. A large enough
number (to achieve quorum intersection) of signatures constitutes
a certificate for the payment. Obtaining a certificate ensures the
payment can eventually be executed (finality). Anyone may submit
the certificate to the authorities that check it and update the sender
account and recipient balance.

FastPay does not rely on State-Machine Replication (SMR) in
the sense that it does not require authorities to agree on a single

2

global state‚Äîas one could expect from a traditional sidechain. Doing
so, FastPay avoids the end-to-end latency cost of gathering, dis-
seminating, and executing large blocks of transactions, a de-facto
requirement for high throughput with SMR solutions [14, 19, 34, 38].
Despite the benefits listed above, until now, the FastPay protocol
has been limited to transparent payments, that is, without any pri-
vacy guarantees. In fact, to ensure fund availability in worst-case
scenarios, FastPay requires all past money transfers to be publicly
available in clear text. This contrasts negatively with traditional
retail payments (e.g. credit cards) where individual transactions
remain within a private banking network. Another technical limi-
tation of FastPay is that unused accounts cannot be deleted. In a
privacy-sensitive setting where users would never re-use the same
account twice, this means that storage cost of authorities would
grow linearly with the number of past transactions.

Existing private payment schemes. Compared to payment chan-
nels (e.g. [29]), safety in FastPay and Zef does not require any upper
bound on network delays and clients to stay connected (aka. a syn-
chrony assumption [17]). Furthermore, the reliability of the Lighting
Network [29] depends on the existence of pairwise channels, with
the success of a payment between two random nodes being at most
70%[16]. In contrast, coins delegated to a FastPay instance are al-
ways immediately transferable to any recipient that possesses a
public key (resp. an account identifier in Zef).

Several privacy-preserving payment systems have been proposed
in the past, each based on a blockchain consensus and therefore
not linearly scalable: Zcash, based on Zerocash [7], uses a zero-
knowledge proof of set inclusion which is expensive to compute
instead of an efficient threshold issuance credential scheme. As a
result most transactions are unshielded, leading to a degradation
in privacy [20]. Monero [24] uses ring signatures to ensure transac-
tions benefit from a small anonymity set. However, intersections
attacks and other transaction tracing heuristics are applicable. This
results in an uneven degree of privacy [25].

3 OVERVIEW
We present Zef, an evolution of FastPay [5] designed to support
high-volume, low-latency payments, both anonymous and trans-
parent, on top of a primary blockchain. To do so, Zef introduces a
new notion of accounts, indexed by a unique identifier (UID) so
that deactivated accounts can have their data safely removed.

Authorities and quorums. We assume a primary blockchain
which supports smart contracts (e.g., Ethereum [37]). In a typi-
cal deployment, we expect Zef to be ‚Äúpegged‚Äù to the primary chain
through a smart contract, thereby allowing transfers of assets in
either direction [3]. The Zef smart contract holds the reserve of as-
sets (e.g., coins) and delegates their management to a set of external
nodes called authorities. For brevity, in the rest of this paper, we fo-
cus on the Zef system and omit the description of transfers between
the primary blockchain and Zef. The mechanics of such transfers
is similar to "funding" and "redeeming" operations in FastPay [5].
Zef is meant to be Byzantine-Fault Tolerant (BFT), that is, tolerate
a subset of authorities that deviate arbitrarily from the protocol. We
assume an asynchronous network that may collude with malicious
authorities to deliver messages in arbitrary order. The protocol
makes progress when message are eventually delivered.

We assume that authorities have shared knowledge of each
other‚Äôs signing public keys. Each authority is also assigned a voting
power, which indicates how much control the authority has within
the system. ùëÅ denotes the total voting power, while ùëì denotes the
power held by adversarial authorities. In the simplest setting where
each authority has a voting power of 1 unit, ùëÅ denotes the total
number of authorities and ùëì denotes the number of adversarial au-
thorities tolerated by the system. In general, unequal voting powers
may be used to reflect different stakes locked by the authorities
on the main blockchain. Similar to standard protocols, we require
0 ‚â§ ùëì < ùëÅ
. The system parameters ùëÅ and ùëì , as well as the public
3
key and voting power of each authority are included in the Zef
smart contract during setup.

We use the word quorum to refer to a set of signatures by author-
ities with a combined voting power of at least ùëÅ ‚àí ùëì . An important
property of quorums, called quorum intersection, is that for any two
quorums, there exists an honest authority ùõº that is present in both.

Cryptographic primitives. We assume a collision-resistant hash
function, noted hash(¬∑), as well as a secure public-key signature
scheme. Informally, a random commitment ùëêùëö = comùëü (ùë£) is an
expression that provides a commitment over the value ùë£ (in par-
ticular, is collision-resistant) without revealing any information
on ùë£, as long as the random seed ùëü is kept secret. A signing scheme
supports blinding and unblinding operations iff (i) a signature of
a blinded message ùêµ = blind(ùëÄ, ùë¢) with blinding factor ùë¢ can be
turned into a valid signature of ùëÄ by computing the expression
unblind(ùêµ, ùë¢), and (ii) provided that ùë¢ is a secret random value, an
attacker observing ùêµ learns no information on ùëÄ.

Blind signatures will be used for anonymous coins in Section 5 to-
gether with an abstract notion of Non-Interactive Zero-Knowledge
(NIZK) proof of knowledge. We will also further assume that a pub-
lic key ùëùùëò
is set up between authorities in such a way that any
quorum of signatures on ùëÄ may be aggregated into a single, secure
threshold signature of ùëÄ, verifiable with ùëùùëò
. (See Appendix B for
a concrete instantiation.)

all

all

Clients, requests, certificates, and coins. Clients to the Zef pro-
tocol are assumed to know the public configuration of the system
(see above) including networking addresses of authorities. Network
interactions are always initiated by a client request. We distin-
guish account-based requests, i.e., those targeting a specific account,
noted ùëÖ, from free requests ùëÖ‚àó. In what follows, all requests are
account-based unless mentioned otherwise. Free requests will be
used for coin creation in Section 5.

As illustrated in Figure 1, clients may initiate a particular op-
eration ùëÇ on an account that they own as follows: (i) broadcast
a request ùëÖ containing the operation ùëÇ and authenticated by the
client‚Äôs signature to the appropriate logical shard of each author-
ity ùõº ( 1 ); and (ii) wait for a quorum of responses, that is, sufficiently
many answers so that the combined voting power of responding
authorities reaches ùëÅ ‚àí ùëì .

An authority responds to a valid request ùëÖ by sending back a sig-
nature on ùëÖ, called a vote, as acknowledgment ( 3 ). After receiving
votes from a quorum of authorities, a client forms a certificate ùê∂,
that is, a request ùëÖ together with a quorum of signatures on ùëÖ. In
the rest of this paper, we identify certificates on a same message ùëÄ

3

Account
Owner

1 Request ùëÖ

3 Vote on ùëÖ

4 Confirm cert[ùëÖ]

Zef Committee

2 Validate ùëÖ

5 Execute ùëÖ

4 Show cert[ùëÖ]

4 Confirm cert[ùëÖ]

Recipients
(if any)

Figure 1: Request and execution of an account operation

and simply write ùê∂ = cert[ùëÄ] when ùê∂ is a certificate on ùëÄ. De-
pending on the nature of ùëÄ (e.g., anonymous coins in Section 5)
and implementation choices, the quorum of signatures in ùê∂ may be
aggregated into a single threshold signature ùúé.

In addition to an operation ùëÇ, every request ùëÖ contains a se-
quence number to distinguish successive requests on the same ac-
count. When a certificate ùê∂ = cert[ùëÖ] with the expected sequence
number is received as a confirmation ( 4 ), this triggers the one-time
execution of ùëÇ ( 5 ) and allows the user account behind ùëÖ to move
on to the next sequence number. A confirmation certificate ùê∂ also
acts as a proof of finality, that is, a verifiable document proving that
the transaction (e.g., a payment) can be driven to success. In the
case of payments, recipients should obtain and verify the certificate
themselves before accepting the payment.

Finally, a third type of certificates associates a coin to an account
identifier ùëñùëë. Section 5 introduces anonymous coins of the form
ùê¥ = cert[(ùëñùëë, ùëêùëö)] for some appropriate commitment ùëêùëö on the
value ùë£ of the coin.

Accounts and unique identifiers. Zef accounts are replicated
across all authorities. For a given authority ùõº, we use the notation
ùëã (ùõº) to denote the current view of ùõº regarding some replicated
data ùëã . The features of Zef accounts can be summarized as follows:

‚Ä¢ A Zef account is addressed by an unique identifier (UID or simply
identifier for short) designed to be non-replayable. We use ùëñùëë,
ùëñùëë1, . . . to denote account identifiers. In practice, we expect users
to publish the identifiers of some of their accounts, e.g. used
for fund raising, and to keep other account identifiers secret to
conceal their own payment activity‚Äîsuch as the timing and the
number of opaque coins that they spend.

‚Ä¢ Every operation executed on an account ùëñùëë follows from a cer-
tified request ùê∂ = cert[ùëÖ] that contains both ùëñùëë and a sequence
number ùëõ. Validators must track the current sequence number
of each account ùëñùëë, so that operations on ùëñùëë are validated and
executed in the natural order of sequence numbers ùëõ = 0, 1, 2 . . .
Under BFT assumption, this ensures that all validators eventu-
ally execute the same sequence of operations on each account.
‚Ä¢ To create a new account identified by ùëñùëë ‚Ä≤, the owner of an exist-
ing parent account ùëñùëë must execute an account-creation opera-
tion. To ensure uniqueness, the new identifier is computed as
the concatenation ùëñùëë ‚Ä≤ = ùëñùëë :: ùëõ of the parent address ùëñùëë and the
current sequence number ùëõ of the parent account.

‚Ä¢ Every account includes an optional public key pk

ùëñùëë (ùõº) to au-
ùëñùëë (ùõº) = ‚ä•, the account is
thenticate their owner, if any. When pk
said to be inactive. Zef makes it possible to safely and verifiably
transfer the control of an account to another user by executing
an operation to change the key pk

ùëñùëë (ùõº).

‚Ä¢ In addition to the public balance, noted balance

ùëñùëë (ùõº), the owner
of an account ùëñùëë may possess a number of opaque coins ùê¥ =
cert[(ùëñùëë, ùëêùëö)] cryptographically linked to the account. The face
value of a coin is arbitrary and secretly encoded in ùëêùëö. Coins
that are consumed (i.e. spent) are tracked in a spent list for each
account‚Äîconcretely, the protocol records ùëêùëö in a set spentùëñùëë (ùõº).
ùëñùëë (ùõº) = ‚ä•. This
operation is final. Because identifiers ùëñùëë are never reused for
new accounts, deactivated accounts may be safely deleted by
authorities to reclaim storage (see discussion in Section 4).

‚Ä¢ An account can be deactivated by setting pk

Sharding and cross-shard queries. In order to scale the process-
ing of client requests, each Zef authority ùõº may be physically di-
vided in an arbitrary number of shards. Every request ùëÖ sent to
an account ùëñùëë in ùõº is assigned a fixed shard as a public function
of ùëñùëë and ùõº. If a request requires a modification of another target
account ùëñùëë ‚Ä≤ (for instance, increasing its balance as part of a payment
operation), the shard processing the confirmation of ùëÖ in ùõº must
issue an internal cross-shard query to the shard of ùëñùëë ‚Ä≤. Cross-shard
queries in Zef are asynchronous messages within each authority.
They are assumed to be perfectly reliable in the sense that are they
are never dropped, duplicated, or tampered with.

Transfer of anonymous coins. In Zef, anonymous coins are both
(i) unlinkable and (ii) opaque in the sense that during an anonymous
payment: (i) authorities cannot see or tracks users across coins
being created; (ii) authorities cannot see the values behind the
commitments ùëêùëö of the coin being consumed or created.

Specifically, as illustrated in Figure 2, the owner of an account
ùëñùëë may spend an anonymous coin ùê¥ùëñùëõ = cert[(ùëñùëë, ùëêùëöùëñùëõ)] linked
to ùëñùëë and create new anonymous coins ùê¥ùëúùë¢ùë°
as follows, using two
communication round-trips with validators ( 2 ‚Äì 7 ):

ùëó

‚Ä¢ Obtain the receiving accounts ùëñùëëùëúùë¢ùë°

ùëó

and desired coin values ùë£ùëúùë¢ùë°

ùëó

from recipients ( 1 ).

‚Ä¢ Compute fresh random commitments ùëêùëöùëúùë¢ùë°
ùëó
, ùëêùëöùëúùë¢ùë°
ùëó

blinded messages ùêµ ùëó = blind((ùëñùëëùëúùë¢ùë°

ùëó

), ùë¢ ùëó ).

for ùë£ùëúùë¢ùë°
ùëó

and fresh

ùëó

‚Ä¢ Using the knowledge of the seed ùëüùëñùëõ and coin value ùë£ùëñùëõ behind
the random commitment ùëêùëöùëñùëõ, construct an NIZK proof ùúã that
the ùêµ ùëó are well-formed‚Äîin particular, that the values ùë£ùëúùë¢ùë°
are
non-negative and that (cid:205)ùëó ùë£ùëúùë¢ùë°

= ùë£ùëñùëõ.

ùëó

‚Ä¢ Broadcast a request ùëÖ to spend the coin ùê¥ùëñùëõ from the account
ùëñùëë, including the hash of the proof ùúã and the public values ùëêùëöùëñùëõ
and ùêµ ùëó ( 2 ).

‚Ä¢ Aggregate the responses from a quorum of authorities into a

certificate ùê∂ = cert[ùëÖ].

‚Ä¢ Broadcast a suitable request ùëÖ‚àó containing the proof ùúã together

with ùê∂, the coins ùê¥ùëñùëõ, and the blinded messages ùêµ ùëó ( 5 ).

‚Ä¢ Obtain signature shares from a quorum of authorities for each
ùêµ ùëó ( 7 ), then unblind and aggregate the signatures shares to
form new coins ùê¥ùëúùë¢ùë°

= cert[(ùëñùëëùëúùë¢ùë°

)] ( 8 ).

, ùëêùëöùëúùë¢ùë°
ùëó

ùëó

ùëó

2 Coin spending request ùëÖ

Zef Committee

4 Vote on ùëÖ

Sender

5 Coin creation request ùëÖ‚àó

7 Blinded share

8 Unblind
& aggregate
shares

9 New coin
cert[(ùëñùëëùëúùë¢ùë°
, ùëêùëöùëúùë¢ùë°
ùëó

ùëó

)]

Recipients

1 ùëñùëëùëúùë¢ùë°
ùëó

, ùë£ùëúùë¢ùë°
ùëó

3 Validate ùëÖ

6 Verify cert[ùëÖ], input
coin certificates, and
ZK-proof.

Figure 2: An anonymous payment

Zef Committee

Broker

2 Request ùëÖ

4 Vote on ùëÖ

5 Confirm cert[ùëÖ]

3 Validate ùëÖ

6 Create new account

5 cert[ùëÖ]

5 Confirm cert[ùëÖ]

New account
owner

1 Public key ùëùùëò

Figure 3: Request and creation of a new account

‚Ä¢ Communicate each new coin ùê¥ùëúùë¢ùë°

ùëó

seed and value, privately to the owner of ùëñùëëùëúùë¢ùë°

, as well as its commitment
( 9 ).

ùëó

Section 5 further elaborates on the creation of coins from public
ùëñùëë (ùõº) and supporting multiple source accounts.
balances balance
The Zef protocol also supports the converse operation consisting
in transferring private coins into a public balance. Appendix B pro-
vides more details on an efficient cryptographic instantiation of
blind signatures and NIZK proofs using the Coconut scheme [30, 33].
For comparison, we also describe a simplified protocol for transpar-
ent coins (i.e., without blinding and ZK-proofs) in Appendix A.

Bootstrapping account generation. In Zef, creating a new ac-
count requires interacting with the owner of an existing parent
account. New identifiers are derived by concatenating the identi-
fier of such a parent account with its current sequence number.
This derivation ensures that identifiers are unique‚Äîand ultimately
accounts are removable‚Äîwhile avoiding the overhead and the com-
plexity of distributed random coin generation (see e.g., [11]).

While Zef lets any user derive new identifiers from an existing
account that they possess, it is important that users can also obtain
fresh identifiers in secret. Indeed, we expect users to regularly
transfer the funds that they receive on public accounts into secret
accounts in order to mitigate residual public information such as
the timing and the number of coins spent from an account.

Therefore, for privacy reasons, we expect certain entities to
specialize in creating fresh identifiers on behalf of other users.
We call them brokers. The role of brokers may also be assumed by
authorities or delegated to third parties. In what follows, we assume
that clients have a conventional way to pick an available broker
and regularly create many identifiers for themselves ahead of time.

4

The resulting interactions are summarized in Figure 3. To protect
their identity, clients may also wish to interact with brokers and
Zef privately, say, using Tor [35] or Nym[27] ( 1 and 5 ).

The fact that the role of broker can be delegated without risking
account safety is an important property of the Zef protocol dis-
cussed in Section 4. The solution relies on the notion of certificate
for account operations‚Äîhere used to prove finality of account cre-
ation, initialized with an authentication key chosen by the client.
In practical deployments, we expect authorities to charge a fee for
account creation and brokers to forward this cost to their users
plus a small margin. Discussing the appropriate pricing and means
of payment is out of scope of this paper.

Finally, a Zef system must be set up with a number of root ac-
counts (i.e., account without a parent). In the rest of the paper,
we assume that the initial configuration of a Zef system always
includes one root account ùëñùëëùõº per authority ùõº.

Transfers of account ownership. An interesting benefit of using
unique identifiers as account addresses is that the authentication
ùëñùëë (ùõº) can be changed. Importantly, the change of key can be
key pk
certified to a new owner of the account. This unlocks a number of
applications:

‚Ä¢ Implicit transfer of coins. Anonymous coins (see Section 5)
are defined as certificates of the form ùê¥ = cert[(ùëñùëë, ùëêùëö)] for
some commitment value ùëêùëö. Spending ùê¥ to create new coins is
an unlinkable operation but it reveals that a coin is spent from
the account ùëñùëë. Account transfers provide an alternative way to
transfer anonymous coins that is linkable but delays revealing
the existence of coins.

‚Ä¢ Generalized authentication. Account transfers opens the door
ùëñùëë (ùõº) with a variety of methods to authenticate
to replacing pk
a request made by the owner of an account. Common methods
include multi-signatures, threshold signatures, and NIZK proofs
of knowledge (see e.g. [26, 40]).

‚Ä¢ Lower account-generation latency. While transferring own-
ership of an account ùëñùëë requires the same number of messages
as creating a new account, we will see in Section 4 that it only
involves executing an operation within the shard of ùëñùëë itself (i.e.,
no cross-shard requests are used). Hence, brokers who wish to
provide new accounts with the lowest latency may create a pool
of accounts in advance then re-assign UIDs to clients as needed.

4 ACCOUNT MANAGEMENT PROTOCOL
We now describe the details of the Zef protocol when it comes
to account operations. An upshot of our formalism is that it also
naturally generalizes the FastPay transfer protocol [5]. Notably, in
Zef, the one-time effect of a transaction consists in one of several
possible operations, instead of transparent payments only. Addi-
tionally, in order to support deletion of accounts, Zef must handle
the fact that a recipient account might be deleted concurrently with
a transfer.

Unique identifiers. A unique identifier (UID or simply identifier)
is a non-empty sequence of numbers written as ùëñùëë = [ùëõ1, . . . , ùëõùëò ] for
some 1 ‚â§ ùëò ‚â§ ùëòmax. We use :: to denote the concatenation of one
number at the end of a sequence: [ùëõ1, . . . , ùëõùëò+1] = [ùëõ1, . . . , ùëõùëò ] ::
ùëõùëò+1 (ùëò < ùëòMAX). In this example, we say that ùëñùëë = [ùëõ1, . . . , ùëõùëò ] is

the parent of ùëñùëë :: ùëõùëò+1. We assume that every authority ùõº possesses
at least one root identifier of length one: ùëñùëëùõº = [ùëõùõº ] such that the
corresponding account is controlled by ùõº at the initialization of the
system (i.e., for every honest ùõº ‚Ä≤, pk
Protocol messages. A message ‚ü®Tag, arg
, . . . , argùëõ‚ü© is a sequence
of values starting with a distinct marker Tag and meant to be sent
over the network. In the remainder of the paper, we use capital-
ized names to distinguish message markers from mathematical
ùëñùëë (ùõº)), and simply write
functions (e.g. hash) or data fields (e.g. pk
, . . . , argùëõ) for a message.
Tag(arg

ùëñùëëùõº (ùõº ‚Ä≤) = ùõº).

1

1

Account operations. An operation is a message ùëÇ meant to be
executed once on a main account ùëñùëë, with possible effects on an
optional recipient account ùëñùëë ‚Ä≤. The operations supported by Zef
include the following messages:
‚Ä¢ OpenAccount(ùëñùëë ‚Ä≤, ùëùùëò ‚Ä≤) to activate a new account with a fresh
identifier ùëñùëë ‚Ä≤ and public key ùëùùëò ‚Ä≤‚Äîpossibly on behalf of another
user who owns ùëùùëò ‚Ä≤;

‚Ä¢ Transfer(ùëñùëë ‚Ä≤, ùëâ ) to transfer an amount of value ùëâ transparently

to an account ùëñùëë ‚Ä≤;

‚Ä¢ ChangeKey(ùëùùëò ‚Ä≤) to transfer the ownership of an account;
‚Ä¢ CloseAccount to deactivate the account ùëñùëë.
In Section 5, we introduce two additional account operations Spend
and SpendAndTransfer.

Account states. Every authority ùõº stores a map that contains the
states of the accounts present in ùõº, indexed by their identifiers. The
state of the account ùëñùëë includes the following data:

‚Ä¢ An optional public key pk

ùëñùëë (ùõº) registered to control ùëñùëë, as seen

before.

‚Ä¢ A transparent (i.e., public) amount of value, noted balance

(initially equal to balance
cept for some special accounts created at the beginning).

ùëñùëë (init), where balance

ùëñùëë (ùõº)
ùëñùëë (init) is 0 ex-

‚Ä¢ An integer value, written next_sequenceùëñùëë (ùõº), tracking the ex-
pected sequence number for the next operation on ùëñùëë. (This
value starts at 0.)

ùëñùëë (ùõº), an optional request indicating that an operation

‚Ä¢ pending

on ùëñùëë is pending confirmation (the initial value being ‚ä•).

‚Ä¢ A list of certificates, written confirmed

ùëñùëë (ùõº), tracking all the
certificates ùê∂ùëõ that have been confirmed by ùõº for requests issued
from the account ùëñùëë. One such certificate is available for each
sequence number ùëõ (0 ‚â§ ùëõ < next_sequenceùëñùëë (ùõº)).

‚Ä¢ A second list of certificates, written received

ùëñùëë (ùõº), tracking all
the certificates that have been confirmed by ùõº and involving ùëñùëë
as a recipient account.

In Section 5, we will also assume a set of random commitments to
track spent coins, noted spentùëñùëë (ùõº).
Operation safety and execution. Importantly, account opera-
tions may require some validation before being accepted. We say
that an operation ùëÇ is safe for the account ùëñùëë in ùõº if one of the
following conditions holds:
‚Ä¢ ùëÇ = OpenAccount(ùëñùëë ‚Ä≤, ùëùùëò ‚Ä≤) and ùëñùëë ‚Ä≤ = ùëñùëë :: next_sequenceùëñùëë (ùõº);
‚Ä¢ ùëÇ = Transfer(ùëñùëë ‚Ä≤, ùëâ ) and 0 ‚â§ ùëâ ‚â§ balance
‚Ä¢ ùëÇ = ChangeKey(ùëùùëò ‚Ä≤) or ùëÇ = CloseAccount (no additional

ùëñùëë (ùõº);

verification).

5

‚ä≤ Set up a new account if necessary

if ùëñùëë ‚àâ accounts then
ùëñùëë ‚Üê ‚ä•

Algorithm 1 Account operations (internal functions)
1: function Init(ùëñùëë)
2:
3:
4:
5:
6:
7:
8:

pk
next_sequenceùëñùëë ‚Üê 0
ùëñùëë ‚Üê balance
balance
ùëñùëë ‚Üê [ ]
confirmed
received
spentùëñùëë ‚Üê { }

ùëñùëë ‚Üê [ ]

ùëñùëë (init)

‚ä≤ 0 except for special accounts

switch ùëÇ do

9: function ValidateOperation(ùëñùëë, ùëõ, ùëÇ)
10:
11:
12:

case OpenAccount(ùëñùëë‚Ä≤, ùëùùëò‚Ä≤):

ensure ùëñùëë‚Ä≤ = ùëñùëë :: next_sequenceùëñùëë

13:
14:
15:
16:

17:
18:
19:
20:

21:
22:
23:
24:

25:

case Transfer(ùëñùëë‚Ä≤, ùëâ ):

ensure 0 < ùëâ ‚â§ balance

ùëñùëë

case ChangeKey(ùëùùëò‚Ä≤) | CloseAccount:

pass

case Spend(ùëâ , ùëêùëö, ùúé, ‚Ñé):

ensure 0 ‚â§ ùëâ ‚â§ balance
ensure ùëêùëö ‚àâ spentùëñùëë
ensure ùúé is a valid coin signature for (ùëñùëë, ùëêùëö)

ùëñùëë

case SpendAndTransfer(ùëñùëë‚Ä≤, ùúé, ùë£, ùëü ):

let ùëêùëö = comùëü (ùë£)
ensure ùëêùëö ‚àâ spentùëñùëë
ensure ùúé is a valid coin signature for (ùëñùëë, ùëêùëö)

return true

‚ä≤ ùëÇ is valid.

switch ùëÇ do

26: function ExecuteOperation(ùëñùëë, ùëÇ, ùê∂)
27:
28:
29:
30:
31:

case OpenAccount(ùëñùëë‚Ä≤, ùëùùëò‚Ä≤):
do asynchronously
run Init(ùëñùëë‚Ä≤)
‚Üê ùëùùëò‚Ä≤
pk
ùëñùëë‚Ä≤
received
case Transfer(ùëñùëë‚Ä≤, ùëâ ):

‚Üê received

ùëñùëë‚Ä≤

ùëñùëë‚Ä≤

‚ä≤ Cross-shard request to ùëñùëë‚Ä≤

‚ä≤ Activate authentication key
:: ùê∂ ‚ä≤ Update receiver‚Äôs log

ùëñùëë ‚àí ùëâ

‚ä≤ Update sender‚Äôs balance
‚ä≤ Cross-shard request to ùëñùëë‚Ä≤

ùëñùëë‚Ä≤

‚Üê balance
‚Üê received

+ ùëâ
:: ùê∂

ùëñùëë‚Ä≤

‚ä≤ Receiver‚Äôs balance

‚ä≤ Update authentication key

‚ä≤ Make account inactive

‚ä≤ Update balance
‚ä≤ Mark coin as spent

ùëñùëë‚Ä≤
ùëñùëë‚Ä≤

ùëñùëë ‚Üê balance
balance
do asynchronously
run Init(ùëñùëë‚Ä≤)
balance
received
case ChangeKey(ùëùùëò‚Ä≤):
ùëñùëë ‚Üê ùëùùëò‚Ä≤
case CloseAccount:
ùëñùëë ‚Üê ‚ä•

pk

pk

case Spend(ùëâ , ùëêùëö, ùúé, ‚Ñé):
ùëñùëë ‚àí ùëâ
ùëñùëë ‚Üê balance
balance
spentùëñùëë ‚Üê spentùëñùëë ‚à™ {ùëêùëö }
case SpendAndTransfer(ùëñùëë‚Ä≤, ùúé, ùë£, ùëü ):

let ùëêùëö = comùëü (ùë£)
spentùëñùëë ‚Üê spentùëñùëë ‚à™ {ùëêùëö }
do asynchronously
run Init(ùëñùëë‚Ä≤, ‚ä•)
ùëñùëë‚Ä≤
balance
ùëñùëë‚Ä≤
received

‚Üê balance
‚Üê received

ùëñùëë‚Ä≤

+ ùë£
:: ùê∂

ùëñùëë‚Ä≤

‚ä≤ Mark coin as spent
‚ä≤ Cross-shard request to ùëñùëë‚Ä≤

32:

33:
34:
35:
36:
37:
38:
39:
40:

41:
42:

43:
44:
45:

46:
47:
48:
49:
50:
51:
52:

When an operation ùëÇ for an account ùëñùëë is confirmed (i.e. a suit-
able certificate ùê∂ is received), we expect every authority ùõº to execute
the operation ùëÇ in following way:

6

‚Ä¢ if ùëÇ = OpenAccount(ùëñùëë ‚Ä≤, ùëùùëò ‚Ä≤), then the authority ùõº uses a cross-
(ùõº) = ùëùùëò ‚Ä≤; if necessary, a new account

ùëñùëë‚Ä≤

shard request to set pk
ùëñùëë ‚Ä≤ is created first;

‚Ä¢ if ùëÇ = ChangeKey(ùëùùëò ‚Ä≤), then the authority sets pk
‚Ä¢ if ùëÇ = Transfer(ùëñùëë ‚Ä≤, ùëâ ), the authority updates balance

ùëñùëë (ùõº) = ùëùùëò ‚Ä≤;
ùëñùëë (ùõº)
by subtracting ùëâ and uses a cross-shard request to add ùëâ to
(ùõº); if necessary, the account ùëñùëë ‚Ä≤ is created first using

ùëñùëë‚Ä≤

balance
an empty public key pk

ùëñùëë‚Ä≤

(ùõº) = ‚ä•;
‚Ä¢ if ùëÇ = CloseAccount, then the authority deactivates the account

ùëñùëë (ùõº) = ‚ä•.

by setting pk
These definitions translate to the pseudo-code in Algorithm 1.
The pseudo-code also includes the logging of certificates with
ùëñùëë (ùõº) as well as additional operations
confirmed
Spend and SpendAndTransfer that will be described in Section 5.

ùëñùëë (ùõº) and received

Account management protocol. We can now describe the pro-
tocol steps for executing an operation ùëÇ on an account ùëñùëë:

(1) A client knowing the signing key of ùëñùëë and the next sequence
number ùëõ signs a request ùëÖ = Execute(ùëñùëë, ùëõ, ùëÇ) and broadcasts it
to every authority in parallel, waiting for a quorum of responses.
(2) Upon receiving an authenticated request ùëÖ = Execute(ùëñùëë, ùëõ, ùëÇ),
an authority ùõº must verify that ùëÖ is authenticated for the current
ùëñùëë (ùõº), that next_sequenceùëñùëë (ùõº) = ùëõ, that the
account key pk
ùëñùëë (ùõº) ‚àà {‚ä•, ùëÖ}.
operation ùëÇ is safe (see above), and that pending
ùëñùëë (ùõº) = ùëÖ and returns a signature on ùëÖ to
Then, it sets pending
the client.

(3) The client aggregates signatures into a confirmation certificate

ùê∂ = cert[ùëÖ].

(4) The client (or another stakeholder) broadcasts Confirm(ùê∂).
(5) Upon receiving Confirm(ùê∂) for a valid certificate ùê∂ of value
ùëÖ = Execute(ùëñùëë, ùëõ, ùëÇ) when ùëÇ is an operation, each authority
ùëñùëë (ùõº) ‚â† ‚ä•, next_sequenceùëñùëë (ùõº) = ùëõ, then
ùõº verifies that pk
ùëñùëë (ùõº) = ‚ä•, adds
increments next_sequenceùëñùëë (ùõº), sets pending
ùëñùëë (ùõº), and finally executes the operation ùëÇ once
ùê∂ to confirmed
(see above).

The corresponding pseudo-code for the service provided by each
authority ùõº is summarized in Algorithm 2. Importantly, inactive ac-
ùëñùëë (ùõº) = ‚ä•, cannot accept
counts, i.e., those accounts ùëñùëë satisfying pk
any request (step (2)) or execute any confirmed operation (step (5)).
Note that step (1) above implicitly assumes that all authorities are
up-to-date with all past certificates. In practice, a client may need
to provide each authority with missing confirmation certificates for
past sequence numbers. (See also ‚ÄúLiveness considerations" below.)

Agreement on account operations. When it comes to the oper-
ations executed from one account ùëñùëë, the Zef protocol guarantees
that authorities execute the same sequence of operations in the
same order. Indeed, the quorum intersection property entails that
two certificates ùê∂ and ùê∂ ‚Ä≤ must contain a vote by a same honest
authority ùõº. If they concern the same account ùëñùëë and sequence
number ùëõ, the verification by ùõº in step (2) above and the increment
of next_sequenceùëñùëë (ùõº) in step (5) implies that ùê∂ and ùê∂ ‚Ä≤ certifies
the same (safe) request ùëÖ.

It is easy to see by induction on the length of ùëñùëë = [ùëõ1, . . . , ùëõùëò ]
that each authority can only execute certified operations for a
given ùëñùëë by following the natural sequence of sequence numbers

Algorithm 2 Account service (message handlers)
1: function HandleReqest(auth[ùëÖ ])
let Execute(ùëñùëë, ùëõ, ùëÇ) = ùëÖ
2:
ùëñùëë ‚â† ‚ä•
ensure pk
3:
verify that auth[ùëÖ ] is valid for pk
4:
ùëñùëë ‚â† ùëÖ then
5:
if pending
6:
7:
8:
9:

ensure pending
ensure next_sequenceùëñùëë = ùëõ
ensure ValidateOperation(ùëñùëë, ùëõ, ùëÇ)
pending
return Vote(ùëÖ)

ùëñùëë ‚Üê ùëÖ

ùëñùëë = ‚ä•

10:

ùëñùëë

‚ä≤ Lock the account on ùëÖ
‚ä≤ Success: return a signature of the request

‚ä≤ The account must be active
‚ä≤ Check authentication

verify that ùê∂ = cert[ùëÖ ] is valid
let Execute(ùëñùëë, ùëõ, ùëÇ) = ùëÖ
ùëñùëë ‚â† ‚ä•
ensure pk
if next_sequenceùëñùëë = ùëõ then

11: function HandleConfirmation(ùê∂)
12:
13:
14:
15:
16:
17:
18:
19:

run ExecuteOperation(ùëñùëë, ùëÇ, ùê∂)
next_sequenceùëñùëë ‚Üê ùëõ + 1
ùëñùëë ‚Üê ‚ä•
pending
confirmed

ùëñùëë ‚Üê confirmed

‚ä≤ Make sure the account is active

‚ä≤ Update sequence number
‚ä≤ Make the account available again
ùëñùëë :: ùê∂
‚ä≤ Log certificate

(i.e., next_sequenceùëñùëë (ùõº) = 0, 1, . . .). Indeed, by the induction hy-
pothesis (resp. by construction for the base case), at most one
operation of the form ùëÇ = OpenAccount(ùëñùëë, ..) can ever be ex-
ecuted by ùõº on the parent account of ùëñùëë (resp. as part of the initial
setup if ùëñùëë has no parent). We also note that due to the checks in
step (5), no operation can be executed from ùëñùëë while the account
ùëñùëë (ùõº) = ‚ä•. Account creation executed
ùëñùëë is locally absent or if pk
ùëñùëë (ùõº) to be up-
by the parent account of ùëñùëë is the only way for pk
dated from an empty value ‚ä•. Therefore, if an account ùëñùëë is deleted
by ùõº due to an operation CloseAccount, it is necessarily so after
OpenAccount(ùëñùëë, ..) was already executed once. The account ùëñùëë
may be created again by some operation Transfer(ùëñùëë, ùëâ ) after dele-
ùëñùëë (ùõº)
tion, but since OpenAccount(ùëñùëë, ..) is no longer possible, pk
will remain empty, thus no more operations will be executed from
ùëñùëë at this point. Therefore, due to the checks in step (5), the oper-
ùëñùëë (ùõº) ‚â† ‚ä•, follows the
ations executed on ùëñùëë, necessarily while pk
natural sequence of sequence numbers.

Agreement on account states. Let ùõº be authority and ùëñùëë be an
account such that pending(ùõº) = ‚ä• and ùõº has not executed an
operation CloseAccount on ùëñùëë yet. We observe that the state of ùëñùëë
seen by ùõº is a deterministic function of the following elements:

‚Ä¢ the sequence of operations previously executed by ùõº on ùëñùëë, that

is, the content of confirmed

ùëñùëë (ùõº), and

‚Ä¢ the (unordered) set of operations previously executed by ùõº that
caused a cross-shard request to ùëñùëë as recipient, that is, the content
of received

ùëñùëë (ùõº).

Indeed, operations issued by ùëñùëë are of the form ChangeKey(ùëùùëò),
Transfer(.., ùëâ ùëúùë¢ùë°
), and OpenAccount(..). Similarly, possible oper-
ations received by ùëñùëë are of the form OpenAccount(ùëñùëë, ùëùùëò) and
Transfer(ùëñùëë, ùëâ ùëñùëõ
). We can determine the different components of
ùëñ
the account ùëñùëë as seen by ùõº as follows:

ùëó

‚Ä¢ next_sequenceùëñùëë (ùõº) will be the size of confirmed

ùëñùëë (ùõº);

7

‚Ä¢ pk

‚Ä¢ balance

ùëñùëë (ùõº) will be the last key set by OpenAccount(ùëñùëë, ùëùùëò) (or an
equivalent initial setup for special accounts) then subsequent
ChangeKey(ùëùùëò) operations, and otherwise pk
+ balance

ùëñùëë (ùõº) = ‚ä•;
ùëñùëë (init), where
ùëñùëë (ùõº) = (cid:205)ùëñ ùëâ ùëñùëõ
ùëñùëë (init) denotes a possibly non-zero initial balance for
balance
some special accounts. (In the presentation of FastPay [5], addi-
tionally terms account for external transfers with the primary
blockchain in replacement of balance

ùëñ ‚àí (cid:205)ùëó ùëâ ùëúùë¢ùë°

ùëñùëë (init).)

ùëó

The agreement property on account operations (see above) en-
tails that whenever two honest authorities have executed the same
operations, they must also agree on the current set of active ac-
counts and their corresponding states. In other words, if for all
ùëñùëë (ùõº ‚Ä≤), then for all ùëñùëë such that
ùëñùëë, confirmed
ùëñùëë (ùõº ‚Ä≤) ‚â† ‚ä•, we have next_sequenceùëñùëë (ùõº) =
ùëñùëë (ùõº) ‚â† ‚ä• or pk
pk
ùëñùëë (ùõº) =
next_sequenceùëñùëë (ùõº ‚Ä≤), pk
ùëñùëë (ùõº ‚Ä≤).
balance

ùëñùëë (ùõº ‚Ä≤), and balance

ùëñùëë (ùõº) = confirmed

ùëñùëë (ùõº) = pk

In particular, similar to the proof of FastPay [5], balance

ùëñùëë (ùõº) ‚â•
0 holds for every ùëñùëë once every certified operations has been exe-
cuted. Indeed, consider an honest authority which accepted to vote
at step (2) for the last transfer Transfer(.., ùëâ ùëúùë¢ùë°

) from ùëñùëë.

ùëó

Liveness considerations. Zef guarantees that conforming clients
may always (i) initiate new valid operations on their active accounts
and (ii) confirm a valid certificate of interest as a sender or as a
recipient. We note that question (i) is merely about ensuring that
the sequence number of an active sender account can advance after
a certificate is formed at step (3). This reduces to the question (ii)
of successfully executing step (5) for any honest authority, given a
valid certificate ùê∂.

If the client, an honest authority ùõº, or the network was recently
faulty, it is possible that (a) the sender account ùëñùëë may not be ac-
tive yet at ùõº, or (b) the sequence number of ùëñùëë may be lagging
behind compared to the expected sequence number in ùê∂. In the
latter case (b), similarly to Fastpay, the client should replay the
previously confirmed certificates ùê∂ùëñ of the same account‚Äîdefined
ùëñùëë (ùõº ‚Ä≤) for some honest ùõº ‚Ä≤‚Äîin order to bring
as ùê∂ùëñ ‚àà confirmed
an authority ùõº to the latest sequence number and confirm ùê∂. In
the case (a) where ùëñùëë is not active yet at ùõº, the client must con-
firm the creation certificate ùê∂ ‚Ä≤ of ùëñùëë issued by the parent account
ùëñùëë ‚Ä≤ = parent(ùëñùëë). This may recursively require confirming the his-
tory of ùê∂ ‚Ä≤. Note however that this history is still sequential (i.e.
there is at most one parent per account) and the number of parent
creation certificates is limited by ùëòMAX.

Importantly, a certificate needs only be confirmed once per hon-
est authority on behalf of all clients. Conforming clients who initi-
ate transactions are expected to persist past certificates locally and
pro-actively share them with all responsive authorities.

In practice, the procedure to bring authorities up-to-date can be
implemented in a way that malicious authorities that would always
request the entire history do not slow down the protocol. (See the
discussion in FastPay [5], Section 5.)

Deactivation and deletion of accounts. We have seen that once
deactivated, an account ùëñùëë plays no role in the protocol and that
ùëñùëë will never be active again. Therefore, it is always safe for an
authority to remove a deactivated account from its local storage.

This important result paves the way for Zef deployments to
control their storage cost by incentivizing users to regularly create
new accounts and deactivate old ones. For instance, a deployment
may limit the maximum sequence number for account operations
and limit the number of opaque coins spent in each account.

Assuming that deactivated accounts are regularly produced, a
simple strategy for an authority ùõº to reclaim some local storage
ùëñùëë (ùõº) changes its
consists in deleting an account ùëñùëë whenever pk
value to ‚ä•. We note however that this strategy is only a best effort.
Effectively reclaiming the maximum amount of storage available
in the system requires addressing two questions:
(1) If an honest authority ùõº deletes ùëñùëë, how to guarantee that the

account is not recreated later by ùõº;

(2) If an honest authority ùõº deletes ùëñùëë, how to guarantee that every

other honest authority ùõº ‚Ä≤ ‚â† ùõº eventually deletes ùëñùëë.
Regarding (1), when a cross-shard request is received for an op-
eration Transfer(ùëñùëë, ùëâ ), the current version of the protocol may
indeed re-create an empty account ùëñùëë. This storage cost can be
addressed by modifying Zef so that an authority ùõº does not re-
create ùëñùëë (or quickly deletes it again) if it determines that no opera-
tion ùëÇ = OpenAccount(ùëñùëë, ..) can occur any more. This fact can be
tested in background using |ùëñùëë | ‚â§ ùëòmax cross-shard queries. Indeed,
consider the opposite fact: an inactive account ùëñùëë = ùëñùëë0 :: ùëõ can
become active in ùõº iff it holds that (i) next_sequenceùëñùëë 0 (ùõº) ‚â§ ùëõ and
(ii) the parent account ùëñùëë0 is either active or can become active.

Regarding (2), we note that sending and receiving clients in
payment operations have an incentive to fully disseminate the
confirmation certificates to all authorities‚Äîrather than just a quo-
rum of them‚Äîwhenever possible. (The incentives are respectively
to fully unlock the sender‚Äôs account and to fully increase the re-
ceiver‚Äôs balance in the eventuality of future unresponsive authori-
ties.) However, such an incentive does not exist in the case of the
CloseAccount operation. Therefore, in practical deployments of
Zef, we expect authorities to either communicate with each other
a minima in background, or to incentivize clients to continuously
disseminate missing certificates between authorities.

Security of account generation. In the eventuality of malicious
brokers, a client must always verify the following properties before
using a new account ùëñùëë ‚Ä≤:
‚Ä¢ The certificate ùê∂ returned by the broker is a valid certifi-
cate ùê∂ = cert[ùëÖ] such that ùëÖ = Execute(ùëñùëë, ùëõ, ùëÇ) and ùëÇ =
OpenAccount(ùëñùëë ‚Ä≤, ùëùùëò) for the expected public key ùëùùëò. (Under
BFT assumption, this implies ùëñùëë ‚Ä≤ = ùëñùëë :: ùëõ.)

‚Ä¢ If the client did not pick a fresh key ùëùùëò, it is important to also

verify that ùê∂ is not being replayed.
For new accounts meant to be secret, clients should use a fresh
public key ùëùùëò and consider communicating with a broker privately
(e.g. over Tor). How a client may anonymously purchase their first
identifiers from a broker raises the interesting question of how
to effectively bootstrap a fully anonymous payment system. (For
instance, a certain number of fresh key-less accounts could be given
away regularly for anyone to acquire and reconfigure them over
Tor before receiving their very first anonymous payment.)

Further comparison with FastPay. In FastPay, accounts are in-
dexed by the public key ùëùùëò that controls payment transfers from

8

the account. Such a key is also called a FastPay address. The
state of an account ùëùùëò is replicated by every authority ùõº and in-
ùëùùëò (ùõº) and a sequence number
cludes notably a balance balance
next_sequenceùëùùëò (ùõº) used to prevent replay of payment certificates.
The definition of FastPay addresses entails that an account ùëùùëò
(even with balance 0) can never be removed from the system. Indeed,
after the information on the sequence number next_sequenceùëùùëò (ùõº)
is lost, the account owner may re-create an account for the same
public key ùëùùëò and exploit next_sequenceùëùùëò (ùõº) = 0 to replay all
past transfers originating from ùëùùëò. In a context of privacy-aware
applications, users are less likely to re-use a same account ùëùùëò many
times, thus amplifying the storage impact of unused accounts. While
anonymous coins introduced next in Section 3 and 5 can easily
be adapted to FastPay-like accounts indexed by ùëùùëò, this would
cause requirements in local storage to never decrease even if some
accounts were explicitly deactivated.

In Zef, accounts are indexed by a unique identifier and deacti-
vated accounts can be safely deleted. On the downside, new users
must interact with a broker or an authority ahead of time to ob-
tain fresh identifiers. Existing users may also choose to trade some
privacy and derive identifiers from their existing account(s).

Cross-shard queries in both FastPay and Zef are asynchronous
in the sense that they do not block a client request to confirm
a certificate (see Algorithm 1). This is crucial to guarantee that
an authority with a lagging view on a particular account can be
brought up to date by providing missing certificate history for this
account and its parents only‚Äîas opposed to exponentially many
accounts. In Zef, this property results from a careful design of
the protocol allowing missing recipient accounts to be (re)created
ùëñùëë (ùõº) = ‚ä• whenever needed. The
with an empty public key pk
uniqueness property of identifiers guarantees that a deleted account
can never be reactivated later on.

5 ANONYMOUS PAYMENTS
We now describe the Zef protocol for anonymous payments using
generic building blocks. In particular, we use a blind signature
scheme, random commitments, and Zero-Knowledge (ZK) proofs
in a black-box way. A more integrated realization of the protocol
suitable for an efficient implementation is proposed in Appendix B.

Anonymous coins. An anonymous coin is a triplet ùê¥ = (ùëñùëë, ùëêùëö, ùúé)
where ùëñùëë is the unique identifier (UID) of an active account, ùëêùëö is a
random commitment on a value ùë£ ‚àà [0, ùë£max] using some random-
ness ùëü , denoted ùëêùëö = comùëü (ùë£), and ùúé is a threshold signature from a
quorum of authorities on the pair (ùëñùëë, ùëêùëö). Following the notations
of Section 3, an anonymous coin ùê¥ can also be seen as a certificate
ùê¥ = cert[(ùëñùëë, ùëêùëö)]. To effectively own a coin, a client must know
the value ùë£, the randomness ùëü , and the secret key controlling ùëñùëë.
To prevent double-spending, for every account ùëñùëë, every authority
keeps tracks of the coins that have already been spent by storing
commitments ùëêùëö in a set spentùëñùëë (ùõº).
Spending anonymous coins. We extend the account operations
of Section 4 with an operation ùëÇ = Spend(ùëâ , ùëêùëö, ùúé, ‚Ñé) meant to be
included in a request Execute(ùëñùëë, ùëõ, ùëÇ). This operation prepares the
creation of new coins by consuming one opaque coin (ùëñùëë, ùëêùëö, ùúé) and
by transparently withdrawing some amount ùëâ from the account.

The hash value ‚Ñé forces the sender to commit to specific output
coins (see next paragraph). Following the framework of Section 4:
‚Ä¢ ùëÇ is safe iff ùúé is a valid signature for (ùëñùëë, ùëêùëö), 0 ‚â§ ùëâ ‚â§

balance

ùëñùëë (ùõº), and ùëêùëö ‚àâ spentùëñùëë (ùõº).

‚Ä¢ Upon receiving a valid certificate ùê∂ = cert[ùëÖ], the execution of
ùëñùëë (ùõº) and adding ùëêùëö

ùëÇ consists in substracting ùëâ from balance
to spentùëñùëë (ùõº).

See algorithm 1 for the corresponding pseudo-code.

, ùúéùëñùëõ

, ùëêùëöùëñùëõ

, ùëêùëöùëñùëõ
ùëñ

ùëñ ) (1 ‚â§ ùëñ ‚â§ ‚Ñì) such that the ùëêùëöùëñùëõ

Creating anonymous coins. Suppose that a user owns ‚Ñì coins
ùëñ = (ùëñùëëùëñùëõ
ùê¥ùëñùëõ
ùëñ are ‚Ñì mu-
ùëñ
tually distinct random commitments, and ùúéùëñùëõ
is a coin signature
ùëñ
on (ùëñùëëùëñùëõ
. Let ùëâ ùëñùëõ
ùëñ ‚â• 0
ùëñ
be a value that the user wishes to withdraw transparently from
the account ùëñùëëùëñùëõ
to be
ùëñ
distinct but not the identifiers ùëñùëëùëñùëõ
. This allows several coins to be
ùëñ
spent from the same account.

. Importantly, we require commitments ùëêùëöùëñùëõ
ùëñ

ùëñ be the value of the coin ùê¥ùëñùëõ
ùëñ

ùëñ ). Let ùë£ùëñùëõ

We define the total input value of the transfer as ùë£ = (cid:205)ùëñ ùë£ùëñùëõ
(cid:205)ùëñ ùëâ ùëñùëõ
. To spend the coins into ùëë new coins with values ùë£ùëúùë¢ùë°
ùëñ
ùëó ‚â§ ùëë) such that (cid:205)ùëó ùë£ùëúùë¢ùë°
ùëñùëëùëúùë¢ùë°
ùëó

ùëñ +
(1 ‚â§
= ùë£, the sender requests a unique identifier

from each recipient, then proceeds as follows:

ùëó

ùëó

(1) First, the sender constructs blinded messages ùêµ ùëó and a zero-

knowledge proof ùúã as follows:
(a) For 1 ‚â§ ùëó ‚â§ ùëë, sample randomness ùëüùëúùë¢ùë°

and set ùëêùëöùëúùë¢ùë°

ùëó

=

ùëó

comùëü ùëúùë¢ùë°

ùëó

(ùë£ùëúùë¢ùë°
ùëó

).

ùêµ ùëó = blind((ùëñùëëùëúùë¢ùë°

(b) For 1 ‚â§ ùëó ‚â§ ùëë, sample random blinding factor ùë¢ ùëó and let
), ùë¢ ùëó ).
(c) Construct a zero-knowledge proof ùúã for the following state-
, ùêµ1, . . . , ùêµùëë ): I know
for each

, . . . , ùëêùëöùëñùëõ

, ùëêùëöùëúùë¢ùë°
ùëó

‚Ñì , (cid:205)ùëñ ùëâ ùëñùëõ
ùëñ
, ùëüùëúùë¢ùë°
ùëó
ùëó

, ùë¢ ùëó , ùëñùëëùëúùë¢ùë°

, ùëüùëñùëõ
ùëñ

ùëó

ùëó

ment regarding (ùëêùëöùëñùëõ
1
for each 1 ‚â§ ùëñ ‚â§ ‚Ñì and ùë£ùëúùë¢ùë°
ùë£ùëñùëõ
ùëñ
1 ‚â§ ùëó ‚â§ ùëë such that
ùëñ ) and ùëêùëöùëúùë¢ùë°
‚Ä¢ ùëêùëöùëñùëõ
(ùë£ùëñùëõ
ùëñ = comùëü ùëñùëõ
ùëó
ùëñ
‚Ä¢ ùêµ ùëó = blind((ùëñùëëùëúùë¢ùë°
, ùëêùëöùëúùë¢ùë°
), ùë¢ ùëó )
ùëó
ùëó
ùëñ = (cid:205)ùëó ùë£ùëúùë¢ùë°
ùëñ + (cid:205)ùëñ ùëâ ùëñùëõ
‚Ä¢ (cid:205)ùëñ ùë£ùëñùëõ
ùëó
ùëñ and ùë£ùëúùë¢ùë°
‚Ä¢ Each value ùë£ùëñùëõ
ùëó

is in [0, ùë£max]

= comùëü ùëúùë¢ùë°

ùëó

(ùë£ùëúùë¢ùë°
ùëó

)

(2) For every input ùëñ, the sender obtains a certificate ùê∂ùëñ for the op-
eration ùëÇùëñ = Spend(ùëâ ùëñùëõ
, ùúéùëñùëõ
, hash(ùêµ1, . . . , ùêµùëë )) then con-
ùëñ
ùëñ
firms ùê∂ùëñ . Concretely, as detailed in Section 4, this means broad-
casting an authenticated request ùëÖùëñ = Execute(ùëñùëëùëñùëõ
, ùëõùëñ, ùëÇùëñ ) for
ùëñ
a suitable sequence number ùëõùëñ , obtaining a quorum of votes on
ùëÖùëñ , then broadcasting ùê∂ùëñ = cert[ùëÖùëñ ].

, ùëêùëöùëñùëõ
ùëñ

(3) Next,

the sender broadcasts a free request ùëÖ‚àó
=
CreateAnonymousCoins(ùúã, ùê∂1, . . . , ùê∂‚Ñì, ùêµ1, . . . , ùêµùëë ) and waits
for a quorum of responses.

(4) Upon receiving a free request of

=
CreateAnonymousCoins(ùúã, ùê∂1, . . . , ùê∂‚Ñì, ùêµ1, . . . , ùêµùëë ) where ùê∂ùëñ =
cert[ùëÖùëñ ], ùëÖùëñ = Execute(ùëñùëëùëñ, ùëõùëñ, ùëÇùëñ ), ùëÇùëñ = Spend(ùëâùëñ, ùëêùëöùëñ, ùúéùëñ, ‚Ñéùëñ ,
each authority ùõº verifies the following:
‚Ä¢ Every ùê∂ùëñ is a valid certificate for ùëÖùëñ . (Under BFT assumption,

the form ùëÖ‚àó

this implies that ùúéùëñ is a valid signature on (ùëñùëëùëñ, ùëêùëöùëñ ))

‚Ä¢ The values ùëêùëöùëñ are mutually distinct.
‚Ä¢ ‚Ñéùëñ = hash(ùêµ1, . . . , ùêµùëë )).
proof
‚Ä¢ The

ùúã
(ùëêùëö1, . . . , ùëêùëö‚Ñì, (cid:205)ùëñ ùëâùëñ, ùêµ1, . . . , ùêµùëë ).

valid

for

is

the

public

inputs

9

The authority then responds with ùëë signature shares, one for
each ùêµ ùëó = blind((ùëñùëëùëúùë¢ùë°
); ùë¢ ùëó ).

, ùëêùëöùëúùë¢ùë°
ùëó

ùëó

(5) For every ùëó, the sender finally combines the signature shares
received by a quorum of authorities, then uses unblind to obtain
, ùëêùëöùëúùë¢ùë°
a signature ùúéùëúùë¢ùë°
).
ùëó
ùëó
(6) The ùëóùë°‚Ñé recipient receives (ùëñùëëùëúùë¢ùë°
, ùëêùëöùëúùë¢ùë°
ùëó

). She
ùëó
verifies that the values and identifiers are as expected, that the
commitments ùëêùëöùëúùë¢ùë°
is valid.

are mutually distinct and each ùúéùëúùë¢ùë°

on (ùëñùëëùëúùë¢ùë°

, ùúéùëúùë¢ùë°
ùëó

, ùë£ùëúùë¢ùë°
ùëó

, ùëüùëúùë¢ùë°
ùëó

ùëó

ùëó

ùëó

We note that finality is achieved as soon as the request ùëÖ‚àó is
formed by the sender. The pseudo-code for coin creation is pre-
sented in Algorithm 3.

Algorithm 3 Coin creation service

let CreateAnonymousCoins(ùúã, ùê∂1, . . . , ùê∂‚Ñì , ùêµ1 . . . ùêµùëë ) = ùëÖ‚àó
for ùëñ = 1..‚Ñì do

1: function HandleCoinCreationReqest(ùëÖ‚àó)
2:
3:
4:
5:
6:
7:

ensure ùê∂ùëñ = cert[ùëÖùëñ ] is a valid certificate
match Execute(ùëñùëëùëñ, ùëõùëñ, Spend(ùëâùëñ, ùëêùëöùëñ, ùúéùëñ, ‚Ñéùëñ )) = ùëÖùëñ
ensure ùëêùëöùëñ ‚àâ {ùëêùëöùëò }ùëò <ùëñ
ensure ‚Ñéùëñ = hash(ùêµ1 . . . ùêµùëë )

8:
9:
10:
11:

let ùëâ = (cid:205) ùëâùëñ
verify the ZK-proof ùúã on inputs (ùëêùëö1 . . . ùëêùëö‚Ñì , ùëâ , ùêµ1 . . . ùêµùëë )
let ùë† ùëó = SignShare(ùêµ ùëó ) for each ùëó = 1..ùëë
return (ùë†1, . . . , ùë†ùëë ) ‚ä≤ Return a blinded signature for each output

Redeeming anonymous coins. Suppose that a user owns a
coin ùê¥ = (ùëñùëë, ùëêùëö, ùúé). We define a new account operation ùëÇ =
SpendAndTransfer(ùëñùëë ‚Ä≤, ùúé, ùë£, ùëü ) meant to be included in a request
ùëÖ = Execute(ùëñùëë, ùëõ, ùëÇ). Following the framework of Section 4:
‚Ä¢ ùëÇ is safe iff ùúé is a valid signature for (ùëñùëë, ùëêùëö) with ùëêùëö = comùëü (ùë£)

and ùëêùëö ‚àâ spentùëñùëë (ùõº).

‚Ä¢ Upon receiving a valid certificate ùê∂ = cert[ùëÖ], the execution
of ùëÇ consists in adding ùëêùëö to spentùëñùëë (ùõº) and sending a cross-
shard request to add the value ùë£ to balance
(ùõº) (possibly after
creating an empty account ùëñùëë ‚Ä≤).
The pseudo-code for redeeming operations is presented in Algo-

ùëñùëë‚Ä≤

rithm 1.

Safety of the protocol. If ùëÇ is a transfer operation, we write
amount(ùëÇ) for the value of the transfer, source(ùëÇ) for the main
account, recipient(ùëÇ) for the recipient account. By extension, we
write amount(ùê∂) for the value of a valid confirmation certificate
containing such an operation ùëÇ.

If ùê¥ = (ùëñùëë, ùëêùëö, ùúé) is valid coin and ùëêùëö = comùëü (ùë£), we write
id(ùê¥) = ùëñùëë, cm(ùê¥) = ùëêùëö, and amount(ùê¥) = ùë£. We also write
ùëêùëö ‚àà spentùëñùëë iff there exists a certificate ùê∂ = cert[ùëÖ] with
ùëÖ = Execute(ùëñùëë, ùëõ, ùëÇ) and either ùëÇ = Spend(ùëâ , ùëêùëö, ùúé, ‚Ñé) for some
ùëõ, ùëâ , ‚Ñé, or ùëÇ = SpendAndTransfer(ùëñùëë ‚Ä≤, ùúé, ùë£, ùëü ) for some ùëõ, ùëñùëë ‚Ä≤.

Under BFT assumption, due to quorum intersection and thanks
to the logics related to the spent list in the code of Spend and
SpendAndTransfer, a coin can be spent only once. More precisely,
there is one-to-one mapping between certificates ùê∂ and coins ùê¥ that
justify cm(ùê¥) ‚àà spentùëñùëë in the definition above. In what follows,
summations over certificates range over all valid certificates for
distinct requests or coins.

We define the spendable value of an account ùëñùëë as follows:
ùëñùëë (init)

spendable

ùëñùëë = balance
‚àëÔ∏Å

+

amount(ùê∂) ‚àí

‚àëÔ∏Å

amount(ùê∂)

recipient(ùê∂)=ùëñùëë
‚àëÔ∏Å

amount(ùê¥)

+

source(ùê∂)=ùëñùëë

(cid:26)id(ùê¥) = ùëñùëë
cm(ùê¥) ‚àâ spent

ùëñùëë

We verify by inspection of the protocol that the total spend-
ùëñùëë , never
able value over all accounts, that is, ùëÜ = (cid:205)ùëñùëë spendable
increases during account operations, coin creation, and redeeming
of anonymous coins:
‚Ä¢ Account operations have been studied in Section 4.
‚Ä¢ Redeeming coins with a certificate ùê∂ for SpendAndTransfer
increases the balance of a recipient but burns a coin with corre-
sponding value (i.e. adds it to spentùëñùëë ).
free
coins with

=
requires
CreateAnonymousCoins(ùúã, ùê∂1, . . . , ùê∂‚Ñì, ùêµ1, . . . , ùêµùëë )
withdrawing public amounts and burning the source coins
corresponding to ùê∂1, . . . , ùê∂‚Ñì . Importantly, ùê∂ùëñ contains a hash
commitment of (ùêµ1, . . . , ùêµùëë ). Therefore re-reusing the certifi-
cate in a coin creation request results in the same coins as the
first time, and does not increase ùëÜ.

‚Ä¢ Creating

request

ùëÖ‚àó

a

Privacy properties. The protocol to create anonymous coins guar-
antees the following privacy properties.
‚Ä¢ Opacity: Except for the ZK proofs ùúã, the coin values under the
are never communicated publicly.
‚Ä¢ Unlinkability: Assuming that the sender during coin creation is
honest, authorities cannot trace back to the origin of an anony-
mous coin when it is spent.

commitments ùëêùëöùëñùëõ

ùëñ and ùëêùëöùëúùë¢ùë°

ùëó

ùëó

and ùëêùëöùëúùë¢ùë°

Regarding unlinkability, we note indeed that the receiver infor-
mation ùëñùëëùëúùë¢ùë°
are only communicated to authorities in
blinded form. Besides, after unblinding, the threshold signature ùúé ùëó
does not depend on values controlled by authorities, therefore is
not susceptible to tainting.

ùëó

To prevent double spending, the protocol must reveal the identi-
fiers ùëñùëë of the coins being spent. This means that the sender who
initially created the coins linked to ùëñùëë must be trusted for unlink-
ability to hold. To mitigate this concern, it is recommended that
receivers quickly transfer their new coins anonymously to a secret
account so that they can spend them privately later.

6 IMPLEMENTATION
We now sketch our prototype implementation of a multi-core, multi-
shard Zef authority in Rust. Our implementation is based on the
existing FastPay codebase1 which already implemented the Byzan-
tine reliable broadcast primitive needed for Zef. In particular, we
were able to re-use modules based on Tokio2 for asynchronous
networking and cryptographic modules based on ed25519-dalek3
for elliptic-curve-based signatures. For simplicity, data-structures
in our Zef prototype are held in memory rather than persistent
storage. Our prototype supports both TCP and UDP for transport.

1https://github.com/novifinancial/fastpay
2https://tokio.rs
3https://github.com/dalek-cryptography/ed25519-dalek

10

The core of Zef is idempotent to tolerate retries in case of packet
loss. Each authority shard is a separate native process with its own
networking and Tokio reactor core. We are open-sourcing Zef4
along with any measurements data to enable reproducible results5.

ùëñ and ùúéùëúùë¢ùë°

Cryptographic primitives for anonymous coins. We have
chosen Coconut credentials [33] to implement the blind randomiz-
able threshold-issuance signatures ùúéùëñùëõ
of Section 5. Zero-
Knowledge proofs are constructed using standard sigma protocols,
made non-interactive through the Fiat-Shamir heuristic [18]. As a re-
sult, our implementation of Zef assumes the hardness of LRSW [22]
and XDH [8] (required by Coconut), and the existence of random
oracles [18]. Appendix B presents this protocol in details. Our im-
plementation of Coconut is inspired from Nym‚Äôs6 and uses the
curve BLS12-381 [39] as arithmetic backend.

ùëñ

We have implemented all range proofs using Bulletproofs [9]
as they only rely on the discrete logarithm assumption (which is
implied by XDH) and do not require a trusted setup. Unfortunately,
we couldn‚Äôt directly use Dalek‚Äôs implementation of Bulletproofs7 as
it uses Ristretto [15] as arithmetic backend. Ristretto is incompatible
with Coconut (which requires a pairing-friendly curve). Therefore,
we have modified Dalek‚Äôs implementation to use curve BLS12-381.
This required significant effort as the curve operations are deeply
baked into the library. Our resulting library is significantly slower
than Dalek‚Äôs for two reasons: operations over BLS12-381 are slower
than over Ristretto, and we couldn‚Äôt take advantage of the parallel
formulas in the AVX2 backend present in the original library. We are
open-sourcing our Bulletproof implementation over BLS12-3818.

7 EVALUATION
We now present our evaluation of the performance of our Zef
prototype based on experiments on Amazon Web Services (AWS).
Our focus was to verify that (i) Zef achieves high throughput even
for large committees, (ii) Zef has low latency even under high load
and within a WAN, (iii) Zef scales linearly when adding more shards,
and (iv) Zef is robust when some parts of the system inevitably
crash-fail. Note that evaluating BFT protocols in the presence of
Byzantine faults is still an open research question [4].

We deployed a testbed on AWS, using m5.8xlarge instances
across 5 different AWS regions: N. Virginia (us-east-1), N. California
(us-west-1), Sydney (ap-southeast-2), Stockholm (eu-north-1), and
Tokyo (ap-northeast-1). Authorities were distributed across those
regions as equally as possible. Each machine provided 10Gbps of
bandwidth, 32 virtual CPUs (16 physical core) on a 2.5GHz, Intel
Xeon Platinum 8175, 128GB memory, and ran Linux Ubuntu server
20.04. We selected these machines because they provide decent
performance and are in the price range of ‚Äúcommodity servers‚Äù.

In the following sections, each measurement in the graphs is
the average of 2 independent runs, and the error bars represent
one standard deviation9. We set one benchmark client per shard
(collocated on the same machine) submitting transactions at a fixed
rate for a duration of 5 minutes.

4https://github.com/novifinancial/fastpay/tree/extensions
5https://github.com/novifinancial/fastpay/tree/extensions/benchmark_scripts
6https://github.com/nymtech/coconut
7https://github.com/dalek-cryptography/bulletproofs
8https://github.com/novifinancial/fastpay/tree/extensions/bulletproofs
9Error bars are absent when the standard deviation is too small to observe.

Figure 4: Throughput-latency graph for regular transfers. WAN
measurements with 10, 20, 30 authorities; 10 collocated shards per
authority. No faulty authorities.

Figure 6: Throughput-latency graph for regular transfers under
crash-faults. WAN measurements with 10 authorities; 35 collocated
shards per authority; 0, 1, and 3 crash-faults.

a single machine). Contrarily to BFT consensus systems [21], Zef
maintains a good level of throughput under crash-faults. The un-
derlying reason for the steady performance under crash-faults is
that Zef doesn‚Äôt rely on a leader to drive the protocol. The small
reduction in throughput is due to losing the capacity of faulty au-
thorities. To assemble certificates, the client is now required to wait
for all the remaining 2ùëì + 1 authorities and can‚Äôt simply select the
fastest 2ùëì + 1 votes; this accounts for the small increase of latency.
Note that the performance shown in Figure 6 are superior to those
shown in Figure 4 because the authorities run more shards.

7.2 Anonymous Payments
We benchmarked the performance of Zef when spending two
opaque coins into two new ones, as described in Section 5. When
referring to latency in this section, we mean the time elapsed from
when the client submits the request (Step 2 in Figure 2) to when
it assembles the new coins (Step 8 in Figure 2). We measured it by
tracking sample requests throughout the system.

Microbenchmarks. We report on microbenchmarks of the single-
CPU core time required to execute the cryptographic operations.
Table 1 displays the cost of each operation in milliseconds (ms); each
measurement is the result of 100 runs on a AWS m5.8xlarge in-
stance. The first 3 rows respectively indicate the time to (i) produce
a coin creation request meant to spend two opaque coins into two
new ones, (ii) verify that request, and (iii) issue a blinded coin share.
The last 3 rows indicate the time to unblind a coin share, verify
it, and aggregate 3 coin shares into an output coin. The dominant
CPU cost is on the user when creating a coin request (438.35ms),
which involves proving knowledge of each input coins (1 Bullet-
proof per coin). However, verifying coin requests (142.31ms) is also
expensive: it involves verifying the input coins (1 pairing check per
input coin) and the output coins request (1 Bulletproof per coin).
Issuing a blinded coin share (1 Coconut signature per output coin)
is relatively faster (4.90ms). Unblinding (3.37ms), verifying (9.62ms)
and aggregating (1.70ms) coin shares take only a few milliseconds.
These results indicate that a single core shard implementation may
only settle just over 7 transactions per second‚Äîhighlighting the
importance of sharding to achieve high-throughput.

Benchmark in the common case. Figure 7 illustrates the latency
and throughput of Zef for varying numbers of authorities. Every
authority runs 10 collocated shards. The performance depicted in
Figure 7 (anonymous payments) are 3 order of magnitude lower
than those depicted in Figure 4 (regular transfers); this is due to

Figure 5: Maximum achievable throughput for regular transfers,
keeping the latency under 250ms and 300ms. WAN measurements
with 4 authorities; 1 to 10 shards per authority running on separate
machines. No faulty authorities.

7.1 Regular Transfers
We benchmarked the performance of Zef when making a regular
transfer as described in Section 4. When referring to latency in this
section, we mean the time elapsed from when the client submits the
request (Step 1 in Figure 1) to when at least one honest authority
processes the resulting confirmation certificate (Step 5 in Figure 1).
We measured it by tracking sample requests throughout the system.

Benchmark in the common case. Figure 4 illustrates the latency
and throughput of Zef for varying numbers of authorities. Every
authority ran 10 collocated shards (each authority ran thus a single
machine). The maximum throughput we observe is 20,000 tx/s
for a committee of 10 nodes, and lower (up to 6,000 tx/s) for a
larger committee of 50. This highlights the important of sharding
to achieve high-throughput. This reduction is due to the need to
transfer and check transfer certificates signed by 2ùëì + 1 authorities;
increasing the committee size increases the number of signatures to
verify since we do not use threshold signatures for regular transfers.

Scalability. Figure 5 shows the maximum throughput that can be
achieved while keeping the latency under 250ms and 300ms. The
committee is composed by 4 authorities each running a data-center;
each shard runs on a separate machine. Figure 5 clearly supports our
scalability claim: the throughput increases linearly with the number
of shards, ranging from 2,500 tx/s with 1 shard per authority to
33,000 tx/s with 10 shards per authority.

Benchmark under crash-faults. Figure 6 depicts the perfor-
mance of Zef when a committee of 10 authorities suffers 1 to 3
crash-faults (the maximum that can be tolerated in this setting).
Every authority runs 35 collocated shards (each authority runs thus

11

02k5k8k10k12k15k18k20kThroughput (tx/s)02004006008001,000Latency (ms)10 nodes (10 shards)20 nodes (10 shards)30 nodes (10 shards)50 nodes (10 shards)0246810Shards per authority010k20k30kThroughput (tx/s)Latency cap: 300 ms Latency cap: 250 ms 05k10k15k20k25k30kThroughput (tx/s)02004006008001,000Latency (ms)10 nodes (35 shards)10 nodes (35 shards) - 1 faulty10 nodes (35 shards) - 3 faultyMeasure

Mean (ms)

Std. (ms)

(User) Generate coin create request
(Authority) Verify coin creation request
(Authority) Issue a blinded coin share
(User) Unblind a coin share
(User) Verify a coin share
(User) Aggregate 3 coin shares

438.35
142.31
4.90
3.37
9.62
1.70

1.10
0.24
0.01
0.05
0.04
0.00

Table 1: Microbenchmark of single core CPU costs of anonymous
coin operations; average and standard dev. of 100 measurements.

Figure 7: Throughput-latency graph for anonymous coins. WAN
measurements with 10, 20, 30 authorities; 10 collocated shards per
authority. No faulty authorities.

Figure 8: Maximum achievable throughput for anonymous coins
while keeping the latency under 500ms and 1s. WAN measurements
with 4 authorities; 1 to 10 shards per authority running on separate
machines. No faulty authorities.

the expensive cryptographic operations reported in Table 1. We
observe virtually no difference between runs with 10, 20, 30, or
even 50 authorities: Zef can process about 50 tx/s while keeping
latency under 1s in all configurations. This highlights that anony-
mous payments operations are extremely CPU intensive and that
bandwidth is far from being the bottleneck.

Scalability. Figure 8 shows the maximum throughput that can be
achieved while keeping the latency under 500ms and 1s. The com-
mittee was composed by 4 authorities each running a data-center;
each shard runs on a separate machine. Figure 5 demonstrates our
scalability claim: throughput increases linearly with the number
of shards, ranging from 5 tx/s with 1 shard per authority to 55 tx/s
with 10 shards per authority (with a latency cap of 1s).

Benchmark under crash-faults. Figure 9 depicts the perfor-
mance of Zef when a committee of 10 authorities suffers 1 to 3
crash-faults. Every authority ran 35 collocated shards (each author-
ity ran thus a single machine). There is no noticeable throughput
drop under crash-faults, and Zef can process up to 100 tx/s within

Figure 9: Throughput-latency graph for anonymous coins under
crash-faults. WAN measurements with 10 authorities; 35 collocated
shards per authority; 0, 1, and 3 crash-faults.

a second with 0, 1, or 3 faults. The performance of Zef shines com-
pared to Zcash [7] which is known to process about 27 tx/s with
a 1 hour latency [2]. Similarly, Monero [24] processes about 4 tx/s
with a 30 minute latency [2].

8 CONCLUSION
Zef is the first linearly-scalable BFT protocol for anonymous pay-
ments with sub-second latency. Zef follows the FastPay model [5]
by defining authorities as sharded services and by managing singly-
owned objects using reliable broadcast rather than consensus. To
support anonymous coins without sacrificing storage costs, Zef
introduces a new notion of uniquely-identified, spendable account.
Users can bind new anonymous coins to their accounts and spend
coins in a privacy-preserving way thanks to state-of-the-art tech-
niques such as the Coconut scheme [33].

Despite the CPU-intensive cryptographic operations required to
preserve opacity and unlinkability of digital coins, our experiments
confirm that anonymous payments in Zef provides unprecedent-
edly quick confirmation time (sub-second instead of tens of min-
utes) while supporting arbitrary throughput thanks to the linearly-
scalable architecture.

In future work, we wish to explore applications of Zef beyond
payments. To this end, one may consider generalizing account
balances using Commutative Replicated Data Types (CmRDTs) [32].
Alternatively, one could introduce short-lived instances of a BFT
consensus protocol whenever agreements on multi-tenant objects
are needed by the system.

REFERENCES
[1] [n.d.]. https://explorer.zcha.in/statistics/usage.
[2] Alphazero. 2022. What Is The Fastest Blockchain And Why? Analysis of 43
Blockchains. https://alephzero.org/blog/what-is-the-fastest-blockchain-and-
why-analysis-of-43-blockchains.

[3] Adam Back, Matt Corallo, Luke Dashjr, Mark Friedenbach, Gregory Maxwell,
Andrew K. Miller, A. Poelstra, Jorge Tim√≥n, and Pieter Wuille. 2014. Enabling
Blockchain Innovations with Pegged Sidechains.

[4] Shehar Bano, Alberto Sonnino, Andrey Chursin, Dmitri Perelman, and Dahlia
Malkhi. 2021. Twins: BFT Systems Made Robust. In Principles of Distributed
Systems.

[5] Mathieu Baudet, George Danezis, and Alberto Sonnino. 2020. FastPay: High-
Performance Byzantine Fault Tolerant Settlement. In ACM AFT. 163‚Äì177.
[6] Morten L Bech and Bart Hobijn. 2006. Technology diffusion within central
banking: the case of real-time gross settlement. FRB of New York Staff Report
(2006).

[7] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers,
Eran Tromer, and Madars Virza. 2014. Zerocash: Decentralized Anonymous
Payments from Bitcoin. In IEEE SP. 459‚Äì474.

12

0102030405060Throughput (tx/s)05001,0001,5002,0002,5003,000Latency (ms)10 nodes (10 shards)20 nodes (10 shards)30 nodes (10 shards)50 nodes (10 shards)0246810Shards per authority01020304050Throughput (tx/s)Latency cap: 1,000 ms Latency cap: 500 ms 020406080100Throughput (tx/s)05001,0001,5002,0002,5003,000Latency (ms)10 nodes (35 shards)10 nodes (35 shards) - 1 faulty10 nodes (35 shards) - 3 faulty[8] Dan Boneh, Ben Lynn, and Hovav Shacham. 2001. Short signatures from the Weil
pairing. In International Conference on the Theory and Application of Cryptology
and Information Security. Springer, 514‚Äì532.

[9] Benedikt B√ºnz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and
Greg Maxwell. 2018. Bulletproofs: Short proofs for confidential transactions and
more. In 2018 IEEE Symposium on Security and Privacy (SP). Ieee, 315‚Äì334.
[10] Christian Cachin, Rachid Guerraoui, and Lu√≠s Rodrigues. 2011. Introduction to
reliable and secure distributed programming. Springer Science & Business Media.
[11] Christian Cachin, Klaus Kursawe, and Victor Shoup. 2000. Random Oracles in
Constantinople: Practical Asynchronous Byzantine Agreement using Cryptogra-
phy. In PODC. 123‚Äì132.

[12] Jan Camenisch, Susan Hohenberger, and Anna Lysyanskaya. 2005. In EURO-

CRYPT. 302‚Äì321.

[13] David Chaum. 1982. In CRYPTO. 199‚Äì203.
[14] George Danezis, Eleftherios Kokoris Kogias, Alberto Sonnino, and Alexander
Spiegelman. 2021. Narwhal and Tusk: A DAG-based Mempool and Efficient BFT
Consensus. arXiv preprint arXiv:2105.11827 (2021).

[15] H. de Valence, J. Grigg, G. Tankersley, F. Valsorda, and I. Lovecruft. 2022. The
ristretto255 Group. http://www.watersprings.org/pub/id/draft-hdevalence-cfrg-
ristretto-00.html.

[16] Diar. 2018. Lightning Strikes, But Select Hubs Dominate Network Funds. https:

//diar.co/volume-2-issue-25/.

[17] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. 1988. Consensus in the
presence of partial synchrony. Journal of the ACM (JACM) 35, 2 (1988), 288‚Äì323.
[18] Amos Fiat and Adi Shamir. 1986. How to prove yourself: Practical solutions to
identification and signature problems. In Theory and Application of Cryptographic
Techniques. Springer, 186‚Äì194.

[19] Bingyong Guo, Zhenliang Lu, Qiang Tang, Jing Xu, and Zhenfeng Zhang. 2020.
Dumbo: Faster asynchronous bft protocols. In Proceedings of the 2020 ACM SIGSAC
Conference on Computer and Communications Security. 803‚Äì818.

[20] George Kappos, Haaroon Yousaf, Mary Maller, and Sarah Meiklejohn. 2018. An
Empirical Analysis of Anonymity in Zcash. In USENIX Security. 463‚Äì477.
[21] Hyojeong Lee, Jeff Seibert, Md. Endadul Hoque, Charles Edwin Killian, and
Cristina Nita-Rotaru. 2014. Turret: A Platform for Automated Attack Finding
in Unmodified Distributed System Implementations. In ICDCS. IEEE Computer
Society, 660‚Äì669.

[22] Anna Lysyanskaya, Ronald L Rivest, Amit Sahai, and Stefan Wolf. 1999. Pseu-
donym systems. In International Workshop on Selected Areas in Cryptography.
Springer, 184‚Äì199.

[23] Ian Miers, Christina Garman, Matthew Green, and Aviel D. Rubin. 2013. Zerocoin:

Anonymous Distributed E-Cash from Bitcoin. In IEEE SP. 397‚Äì411.

[24] Monero. 2014. Monero. https://www.getmonero.org.
[25] Malte M√∂ser, Kyle Soska, Ethan Heilman, Kevin Lee, Henry Heffan, Shashvat
Srivastava, Kyle Hogan, Jason Hennessey, Andrew Miller, Arvind Narayanan,
and Nicolas Christin. 2018. An Empirical Analysis of Traceability in the Monero
Blockchain. Proc. Priv. Enhancing Technol. 2018, 3 (2018), 143‚Äì163.

[26] Satoshi Nakamoto. 2019. Bitcoin: A peer-to-peer electronic cash system. Technical

Report. Manubot.

[27] Nym. [n.d.]. The Nym Project. https://nymtech.net.
[28] David Pointcheval and Olivier Sanders. 2016. Short Randomizable Signatures. In

[29] Joseph Poon and Thaddeus Dryja. 2015. The Bitcoin lightning network. Scalable

CT-RSA. 116‚Äì126.

o-chain instant payments (2015).

[30] Alfredo Rial and Ania M Piotrowska. 2022. Security Analysis of Coconut, an
Attribute-Based Credential Scheme with Threshold Issuance. Cryptology ePrint
Archive (2022).

[31] Tomas Sander and Amnon Ta-Shma. 1999. In CRYPTO. 555‚Äì572.
[32] Marc Shapiro, Nuno Pregui√ßa, Carlos Baquero, and Marek Zawirski. 2011. A
comprehensive study of Convergent and Commutative Replicated Data Types.
(2011).

[33] Alberto Sonnino, Mustafa Al-Bassam, Shehar Bano, Sarah Meiklejohn, and George
Danezis. 2019. Coconut: Threshold issuance selective disclosure credentials with
applications to distributed ledgers. In NDSS.

[34] Chrysoula Stathakopoulou, Tudor David, Matej Pavlovic, and Marko Vukoliƒá.
2019. Mir-BFT: High-Throughput Robust BFT for Decentralized Networks. arXiv
preprint arXiv:1906.05552 (2019).

[35] Tor. [n.d.]. The Tor Project. https://www.torproject.org.
[36] Brent Waters. 2005. Efficient identity-based encryption without random oracles.

In EUROCRYPT. 114‚Äì127.

[37] Gavin Wood et al. 2014. Ethereum: A secure decentralised generalised transaction

ledger. Ethereum project yellow paper 151 (2014), 1‚Äì32.

[38] Maofan Yin, Dahlia Malkhi, Michael K Reiter, Guy Golan Gueta, and Ittai Abra-
ham. 2019. HotStuff: BFT consensus with linearity and responsiveness. In Pro-
ceedings of the 2019 ACM Symposium on Principles of Distributed Computing.
347‚Äì356.

[39] S. Yonezawa, Lepidum, S. Chikara, NTT TechnoCross, T. Kobayashi, and T. Saito.
2022. Pairing-Friendly Curves. https://tools.ietf.org/id/draft-yonezawa-pairing-
friendly-curves-00.html.

13

2 Coin spending request ùëÖ

Zef Committee

4 Vote on ùëÖ

3 Validate ùëÖ

Sender

5 Coin creation request ùëÖ‚àó

7 Vote on (ùëñùëëùëúùë¢ùë°

ùëó

, ùë£ùëúùë¢ùë°
ùëó

, ùëüùëúùë¢ùë°
)
ùëó

6 Verify lock cert[ùëÖ],
input coin certificates,
and sum invariants.

8
cert[(ùëñùëëùëúùë¢ùë°

Transparent
, ùë£ùëúùë¢ùë°
ùëó

, ùëüùëúùë¢ùë°
ùëó

ùëó

)]

coin

Recipients

1 ùëñùëëùëúùë¢ùë°
ùëó

Figure 10: A payment with transparent coins

[40] ZCash. 2016. ZCash. https://z.cash.

A TRANSPARENT COINS
For comparison purposes, we sketch a simplified version of anony-
mous coins (Section 5) without opacity and unlinkability. At a high
level, the protocol is similar to anonymous coins in terms of com-
munication (Figure 10). Due to the absence of blinding and random
commitments, communication channels and validators must be
trusted for the privacy of every coin operation.

Transparent coins. A transparent coin is a certificate ùëá = cert[ùëÜ]
on a triplet ùëÜ = (ùëñùëë, ùë£, ùëü ) where ùëñùëë is the identifier of an account,
ùë£ ‚àà [0, ùë£max], and ùëü is some random seed value. Seed values ùëü are
used to distinguish coins of the same value attached to the same ùëñùëë.
To spend a transparent coin ùëá , a client must possess the authen-
tication key controlling ùëñùëë. Importantly, authorities do not need to
store ùëá themselves‚Äîalthough they will observe such certificates
occasionally in clear.

New account operation. Similar to Section 5, we assume a new
account operation ùëÇ = Spend(ùëâ ,ùëá , ‚Ñé) meant to prepare the cre-
ation of new coins associated to ‚Ñé, by consuming a coin ùëá and
by withdrawing an amount ùëâ publicly. Consider an operation
ùëÇ = Spend(ùëâ ,ùëá , ‚Ñé) included in a request ùëÖ = Execute(ùëñùëë, ùëõ, ùëÇ).

‚Ä¢ ùëÇ is safe iff 0 ‚â§ ùëâ ‚â§ balance

ùëñùëë (ùõº), ùëá = cert[ùëÜ] is a valid

certificate for ùëÜ = (ùëñùëë, ùë£, ùëü ), and ùëü ‚àâ spentùëñùëë (ùõº).

‚Ä¢ The execution of ùëÇ consists in adding ùëü to spentùëñùëë (ùõº) and sub-

tracting ùëâ from balance

ùëñùëë (ùõº).

, ùëüùëñùëõ

, ùë£ùëñùëõ
ùëñ

ùëñ = cert[ùëÜùëñùëõ

ùëñ ] where ùëÜùëñùëõ

Transparent coin payment protocol. Suppose that a user owns
‚Ñì mutually distinct transparent coins ùëá ùëñùëõ
ùëñ =
(ùëñùëëùëñùëõ
ùëñ ) (1 ‚â§ ùëñ ‚â§ ‚Ñì). Let ùëâùëñ ‚â• 0 be a value that the user wishes
ùëñ
to withdraw publicly from the account ùëñùëëùëñùëõ
. Similar to Section 5,
ùëñ
to be distinct but not the identifiers ùëñùëëùëñùëõ
we require certificates ùëá ùëñùëõ
.
ùëñ
We define the total input value of the transfer as ùë£ = (cid:205)ùëñ ùë£ùëñùëõ
ùëñ + (cid:205)ùëñ ùëâùëñ .
To spend the coins into ùëë new coins with values ùë£ùëúùë¢ùë°
(1 ‚â§ ùëó ‚â§ ùëë)
from

= ùë£, the sender requests an identifier ùëñùëëùëúùë¢ùë°

such that (cid:205)ùëó ùë£ùëúùë¢ùë°
each recipient, then proceeds as follows:

ùëñ

ùëó

ùëó

ùëó

(1) For every 1 ‚â§ ùëó ‚â§ ùëë, sample randomness ùëüùëúùë¢ùë°

. Let ùëÜùëúùë¢ùë°

ùëó

=

ùëó

(ùëñùëëùëúùë¢ùë°
ùëó

, ùë£ùëúùë¢ùë°
ùëó

, ùëüùëúùë¢ùë°
ùëó

).

(2) For every input ùëñ, the sender obtains a certificate ùê∂ùëñ = cert[ùëÖùëñ ]
, ùëõùëñ, ùëÇùëñ ) where ùëÇùëñ =

and executes a request ùëÖùëñ = Execute(ùëñùëëùëñùëõ
ùëñ

Spend(ùëâ ùëñùëõ
ùëñ
sequence number for the account ùëñùëëùëñùëõ
ùëñ

, hash(ùëÜùëúùë¢ùë°

, . . . , ùëÜùëúùë¢ùë°

,ùëá ùëñùëõ
ùëñ

ùëë

1

.

)), ùëõùëñ is the next available

(3) Next,

the sender broadcasts a free request ùëÖ‚àó

CreateTransparentCoins(ùê∂1, . . . , ùê∂‚Ñì, ùëÜùëúùë¢ùë°
waits for a quorum of responses.

1

, . . . , ùëÜùëúùë¢ùë°

ùëë

)

=
and

(4) Upon receiving a free request of

=
where
), each authority ùõº verifies the fol-

CreateTransparentCoins(ùê∂1, . . . , ùê∂‚Ñì, ùëÜ1, . . . , ùëÜùëë )
ùëÜ ùëó = (ùëñùëëùëúùë¢ùë°
lowing:
‚Ä¢ ùê∂ùëñ = cert[ùëÖùëñ ] is a valid certificate for a request of the form

the form ùëÖ‚àó

, ùë£ùëúùë¢ùë°
ùëó

, ùëüùëúùë¢ùë°
ùëó

ùëó

ùëÖùëñ = Execute(ùëñùëëùëñùëõ
ùëñ

, ùëõùëñ, ùëÇùëñ ) where ùëÇùëñ = Spend(ùëâ ùëñùëõ
ùëñ

,ùëáùëñ, ‚Ñéùëñ ),

ùëñ + (cid:205)ùëñ ùëâùëñ = (cid:205)ùëó ùë£ùëúùë¢ùë°

‚Ä¢ The certificates ùëáùëñ are mutually distinct.
‚Ä¢ (cid:205)ùëñ ùë£ùëñùëõ
The authority then responds with one signature for each ùëÜùëúùë¢ùë°
.
(5) For every ùëó, the sender finally combines a quorum of signatures
.

into a new coin ùëá ùëúùë¢ùë°

.

ùëó

ùëó

on ùëÜùëúùë¢ùë°
ùëó

ùëó

(6) The ùëóùë°‚Ñé recipient receives ùëá ùëúùë¢ùë°

)]. She
verifies that the values and the identifiers are as expected, that
the random seeds ùëüùëúùë¢ùë°
are mutually distinct, and that the certifi-
cates ùëá ùëúùë¢ùë°

ùëó
are valid.

= cert[(ùëñùëëùëúùë¢ùë°

, ùë£ùëúùë¢ùë°
ùëó

, ùëüùëúùë¢ùë°
ùëó

ùëó

ùëó

ùëó

Redeeming transparent coins. Suppose that a user owns a trans-
parent coin ùëá linked to the account ùëñùëë. We define a new account
operation ùëÇ = SpendAndTransfer(ùëñùëë ‚Ä≤,ùëá ) meant to be included
in a request ùëÖ = Execute(ùëñùëë, ùëõ, ùëÇ). Following the framework of
Section 4:

‚Ä¢ ùëÇ is safe iff ùëá = cert[ùëÜ] is a valid certificate for ùëÜ = (ùëñùëë, ùë£, ùëü ) and

ùëü ‚àâ spentùëñùëë (ùõº).

‚Ä¢ Upon receiving a valid certificate ùê∂ = cert[ùëÖ], the execution
of ùëÇ consists in adding ùëü to spentùëñùëë (ùõº), then sending a cross-
(ùõº) (possibly after
shard request to add the value ùë£ to balance
creating an empty account ùëñùëë ‚Ä≤).

ùëñùëë‚Ä≤

Below, we use the notation ¬Øùëã = (ùëã1, . . . , ùëãùëû) for any list of ùëû
variables ùëãùëñ (1 ‚â§ ùëñ ‚â§ ùëû). The scheme Coconut++ consists of the
following algorithms:
‚ùñ Setup(1ùúÜ) ‚Üí (ùëùùëù): Choose groups (G1, G2, Gùëá ) of order ùëù (a ùúÜ-
bit prime) with a bilinear map ùëí : G1 √ó G2 ‚Üí Gùëá . Let ùêª : G1 ‚Üí
G1 be a secure hash function. Let ùëî1, ‚Ñé1, . . . , ‚Ñéùëû be generators
of G1 and let ùëî2 be a generator of G2. The system parameters
are given as ùëùùëù = (G1, G2, G3, ùëù, ùëí, ùêª, ùëî1, ùëî2, ¬Ø‚Ñé). Parameters are
implicit in the remaining descriptions.

‚ùñ KeyGen(ùë°, ùëõ) ‚Üí (ùë†ùëò, ùë£ùëò): Pick ùëû + 1 polynomials ùë¢, ùë§1, . . . , ùë§ùëû
each of degree ùë° ‚àí 1 with coefficients in Fùëù and set ùë†ùëò =
(ùë•, ¬Øùë¶) = (cid:0)ùë¢ (0), ùë§1 (0), . . . , ùë§ùëû (0)(cid:1). Publish the verification
ùë¶ùëû
key ùë£ùëò = (¬Øùõæ, ùõº, ¬ØùõΩ) = (ùëîùë¶1
2 ). Also
, . . . , ùëî
1
issue to each authority ùëó
{1, . . . , ùëõ}, the secret key
(ùë¢ ( ùëó), ùë§1 ( ùëó), . . . , ùë§ùëû ( ùëó)) and publish
ùë†ùëò ùëó
(ùë• ùëó , ¬Øùë¶ ùëó )
the corresponding verification key ùë£ùëò ùëó = (¬Øùõæ ùëó , ùõº ùëó , ¬ØùõΩ ùëó ) =
ùë¶ ùëó,ùëû
(ùëî
2
‚ùñ PrepareBlindSign( ¬Øùëö, ùúô) ‚Üí (¬Øùëü, Œõ): Pick a random ùëú ‚àà Fùëù . Com-

, . . . , ùëî
‚àà

, ùëîùë¶1
2

ùë¶ ùëó,1
2

ùë¶ ùëó,1
1

ùë¶ ùëó,ùëû
1

, . . . , ùëî

, . . . , ùëî

, ùëîùë•
2

ùë¶ùëû
1

ùë• ùëó
2

, ùëî

, ùëî

).

=

=

pute the commitment ùëê ¬Øùëö and group element ‚Ñé as

ùëê ¬Øùëö = ùëîùëú
1

ùëû
(cid:214)

ùëñ=1

‚Ñéùëöùëñ
ùëñ

and

‚Ñé = ùêª (ùëê ¬Øùëö)

For all ùëñ = 1 . . . ùëû, pick a random ùëüùëñ ‚àà Fùëù and compute the blinded
value ùëêùëñ as follows:

ùëêùëñ = ‚Ñéùëöùëñ ùëîùëüùëñ
1
Output (¬Øùëü, Œõ) where Œõ = (ùëê ¬Øùëö, ¬Øùëê, ùúãùë† ) where ùúãùë† is defined as:

ùúãùë† = NIZK{( ¬Øùëö, ùëú, ¬Øùëü ) : ‚àÄùëñ, ùëêùëñ = ‚Ñéùëöùëñ ùëîùëüùëñ

1 ‚àß ùëê ¬Øùëö = ùëîùëú

1

ùëû
(cid:214)

ùëñ=1

‚Ñéùëöùëñ
ùëñ

B NIZK PROTOCOL
In this section, we show one possible efficient instantiation of the
anonymous payment protocol from Section 5 by opening up the
cryptographic primitives used. Our protocol here makes use of the
Coconut threshold credential scheme [33], which is based on the
work of Pointcheval and Sanders [28]. Informally, Coconut allows
users to obtain credentials on messages with private attributes in a
distributed setting using a threshold ùë° out of ùëõ authorities.

B.1 Coconut++
We start by giving an overview of a suitable variant of the Coconut
scheme, nicknamed Coconut++. This variant of Coconut is formally
proven secure by Rial and Piotrowska [30]. At a high level, Coconut
allows a user to obtain, from a threshold number of authorities,
an anonymous credential on a private attribute ùëö showing that it
satisfies some application-specific predicate ùúô (ùëö) = 1. Later, the
user can anonymously prove the validity of this credential to any
entity in possession of the verification key. While the standard
Coconut scheme works for a single attribute, [33] also includes an
extension that allows for credentials on a list of ùëû integer-valued
attributes ¬Øùëö = (ùëö1, . . . , ùëöùëû).

‚àß ùúô ( ¬Øùëö) = 1}

ùëê

ùëñ=1

ùëñ=1

ùë¶ ùëó,ùëñ
ùëñ

and output

‚ùñ BlindSign(ùë†ùëò ùëó , Œõ, ùúô) ‚Üí ((cid:101)

ùúé ùëó ): The authority ùëó parses Œõ =
(ùëê ¬Øùëö, ¬Øùëê, ùúãùë† ), and ùë†ùëò ùëó = (ùë• ùëó , ¬Øùë¶ ùëó ). Recompute ‚Ñé = ùêª (ùëê ¬Øùëö). Verify
the proof ùúãùë† using ¬Øùëê, ùëê ¬Øùëö and ùúô; if the proof is valid, compute
ùë† ùëó = ‚Ñéùë• ùëó (cid:206)ùëû
ùë† ùëó ); otherwise output ‚ä•.
ùúé ùëó = (‚Ñé,
(cid:101)
(cid:101)
(cid:101)
‚ùñ Unblind((cid:101)
ùúé ùëó , ¬Øùëü, ¬Øùõæ) ‚Üí (ùúé ùëó ): Parse
ùúé ùëó
=
(cid:101)
ùë† ùëó (cid:206)ùëû
ùõæ ‚àíùëüùëñ
, and output ùúé ùëó = (‚Ñé, ùë† ùëó ).
ùëñ
(cid:101)
This results in ùúé ùëó = (‚Ñé, ùë† ùëó ) where ùë† ùëó = ‚Ñéùë• ùëó (cid:206)ùëû
‚Ñéùë• ùëó +(cid:205)ùëû
This is similar to a Waters signature [36] related to the public
key of each authority. Verification of partial coins is used in the
implementation of Zef for clients to validate a quorum of answers
received in parallel from authorities and discard erroneous values
before running the aggregation step.

ùë¶ ùëó,ùëñ ùëöùëñ .

let ùë† ùëó

ùõæ ‚àíùëüùëñ
ùëñ

ùë† ùëó ),
(cid:101)

ùë¶ ùëó,ùëñ
ùëñ

(cid:206)ùëû

(‚Ñé,

ùëñ=1

ùëñ=1

ùëñ=1

=

=

ùëê

‚ùñ AggCred({ùúé ùëó } ùëó ‚ààùêΩ ) ‚Üí (ùúé): Return ‚ä• if |ùêΩ | ‚â† ùë°. Parse each ùúé ùëó as
‚Ñìùëó
ùëó ), where each ‚Ñìùëó is the Lagrange

(‚Ñé, ùë† ùëó ). Output ùúé = (‚Ñé, (cid:206)ùëó ‚ààùêΩ ùë†
coefficient given by:

‚Ñìùëó =

(cid:214)

Ô£Æ
Ô£Ø
Ô£Ø
Ô£Ø
ùëò ‚ààùêº \{ ùëó }
Ô£Ø
Ô£∞

(0 ‚àí ùëò)

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª

(cid:214)

Ô£Æ
Ô£Ø
Ô£Ø
Ô£Ø
ùëò ‚ààùêº \{ ùëó }
Ô£Ø
Ô£∞

( ùëó ‚àí ùëò)

‚àí1

Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£∫
Ô£ª

mod ùëù

14

This computation results in a value ùúé = (‚Ñé, ‚Ñéùë•+(cid:205)ùëû
does not depend on the set of authorities ùêΩ .

ùëñ=1

ùë¶ùëñ ùëöùëñ ) that

ùúô ‚Ä≤ is a predicate satisfied by the input and output coin values and
defined as follows: ùúô ‚Ä≤(¬Øùë£ùëñùëõ, ¬Øùë£ùëúùë¢ùë° ) = true iff

‚ùñ ProveCred(ùë£ùëò, ¬Øùëö, ùúé, ùúô ‚Ä≤) ‚Üí (Œò, ùúô ‚Ä≤): Parse ùúé = (‚Ñé, ùë†) and ùë£ùëò =
(‚Ñé‚Ä≤)ùëü ,
(¬Øùõæ, ùõº, ¬ØùõΩ). Pick at random ùëü, ùëü ‚Ä≤ ‚àà F2
(cid:206)ùëû
and ùúé ‚Ä≤ = (‚Ñé‚Ä≤, ùë† ‚Ä≤). Build ùúÖ = ùõº ùëîùëü
. Then, output (Œò, ùúô ‚Ä≤),
2
where Œò = (ùúÖ, ùúé ‚Ä≤, ùúãùë£) and ùúô ‚Ä≤ is an application-specific predicate
satisfied by ¬Øùëö, and ùúãùë£ is:

ùëù , set ‚Ñé‚Ä≤ = ‚Ñéùëü ‚Ä≤, ùë† ‚Ä≤ = ùë†ùëü ‚Ä≤

ùõΩùëöùëñ
ùëñ

ùëñ=1

ùúãùë£ = NIZK{( ¬Øùëö, ùëü ) : ùúÖ = ùõº ùëîùëü
2

ùëû
(cid:214)

ùëñ=1

ùõΩùëöùëñ
ùëñ

‚àß ùúô ‚Ä≤( ¬Øùëö) = 1}

‚ùñ VerifyCred(ùë£ùëò, Œò, ùúô ‚Ä≤) ‚Üí (ùë°ùëüùë¢ùëí/ùëì ùëéùëôùë†ùëí): Parse Œò = (ùúÖ, ùúé ‚Ä≤, ùúãùë£) and
ùúé ‚Ä≤ = (‚Ñé‚Ä≤, ùë† ‚Ä≤); verify ùúãùë£ using ùë£ùëò and ùúô ‚Ä≤. Output ùë°ùëüùë¢ùëí if the proof
verifies, ‚Ñé‚Ä≤ ‚â† 1 and the bilinear evaluation ùëí (‚Ñé‚Ä≤, ùúÖ) = ùëí (ùë† ‚Ä≤, ùëî2)
holds; otherwise output ùëì ùëéùëôùë†ùëí.
The bilinear evaluation is justified by the following equations:

ùëí (‚Ñé‚Ä≤, ùúÖ) = ùëí (‚Ñéùëü ‚Ä≤, ùõº ùëîùëü
2

ùëû
(cid:214)

ùëñ=1

ùõΩùëöùëñ
ùëñ

) = ùëí (‚Ñéùëü ‚Ä≤, ùëîùë•+ùëü +(cid:205)ùëñ ùë¶ùëñ ùëöùëñ

2

)

ùëí (ùë† ‚Ä≤, ùëî2) = ùëí (ùë†ùëü ‚Ä≤

(‚Ñé‚Ä≤)ùëü , ùëî2) = ùëí (‚Ñéùëü ‚Ä≤ (ùë•+(cid:205)ùëñ ùë¶ùëñ ùëöùëñ ) ‚Ñéùëüùëü ‚Ä≤, ùëî2)

B.2 Anonymous Transfer Protocol
We now instantiate the anonymous transfer protocol from Sec-
tion 5 using the Coconut scheme with three attributes ¬Øùëö = (ùëò, ùëû, ùë£)
consisting of a key ùëò, a random seed ùëû, and a private coin value ùë£.
From the point of view of its owner, an opaque coin is defined as
ùê¥ = (ùëñùëë, ùë•, ùëû, ùë£, ùúé) where ùëñùëë is the linked account, ùë• is an unique
index within the same account ùëñùëë, ùëû is a secret random seed, ùë£ is
the value of the coin, and ùúé denotes the Coconut credential for
ùëò = hash(ùëñùëë :: [ùë•]), ùëû and ùë£. When a new opaque coin is created,
the three attributes are hidden to authorities. The account ùëñùëë and
the index ùë• of a coin are revealed when it is spent to verify coin
ownership and prevent double-spending of coins within the same
account. We use the third attribute ùëû to guarantee the privacy of
the value ùë£ even after ùëò is revealed10.
Suppose that a sender owns
, ùúéùëñùëõ

=
ùëñ ) (1 ‚â§ ùëñ ‚â§ ‚Ñì) and wishes to create ùëë
, ùëûùëúùë¢ùë°
) (1 ‚â§ ùëó ‚â§ ùëë).
ùëó
‚â• 0 denotes a public value to withdraw from the
as in Section 5. The sender must ensure that
ùëñ = (cid:205)ùëó ùë£ùëúùë¢ùë°
, ùë•ùëúùë¢ùë°
)
ùëó

(ùëñùëëùëñùëõ
, ùë£ùëñùëõ
ùëñ
ùëñ
output coins of the form (ùëñùëëùëúùë¢ùë°
Let ùëâ ùëñùëõ
ùëñ
account ùëñùëëùëñùëõ
ùëñ
ùëñ + (cid:205)ùëñ ùëâ ùëñùëõ
(cid:205)ùëñ ùë£ùëñùëõ
are mutually distinct.

and that the coin indices (ùëñùëëùëúùë¢ùë°

input coins ùê¥ùëñùëõ
ùëñ

, ùúéùëúùë¢ùë°
ùëó

, ùë•ùëúùë¢ùë°
ùëó

, ùë£ùëúùë¢ùë°
ùëó

, ùë•ùëñùëõ
ùëñ

, ùëûùëñùëõ
ùëñ

‚Ñì

ùëó

ùëó

ùëó

Using Coconut for opaque coin transfers. We present an
overview of the changes to the anonymous transfer protocol from
Section 5 to implement opaques coins.

Recall that the sender must first construct blinded descriptions
of the desired output coins. These descriptions are meant to be
incorporated into a hash commitment ‚Ñé in the spending certificates
ùê∂ùëñ for input coins. To do so, the sender proceeds as follows. Define

10As noted in the original Coconut paper [33], if a credential contains a single attribute
ùëö of low entropy (such as a coin value), the verifier can run multiple times the
verification algorithm making educated guesses on the value of ùëö and effectively
recover its value through brute-force.

ùëô
‚àëÔ∏Å

ùëñ

ùë£ùëñùëõ
ùëñ +

ùëô
‚àëÔ∏Å

ùëñ

ùëâ ùëñùëõ
ùëñ =

ùëë
‚àëÔ∏Å

ùëó

ùë£ùëúùë¢ùë°
ùëó

‚àß ùë£ùëúùë¢ùë°
ùëñ

‚àà [0, ùë£max]

The predicate ùúô ‚Ä≤ binds the NIZKs associated with all ProveCred
proofs for the input coins and all PrepareBlindSign proofs for the
output coins. It also shows that the value on both sides of the
transfer is consistent.

For every 1 ‚â§ ùëñ ‚â§ ‚Ñì, considering ùëòùëñùëõ

ùëñ = hash(ùëñùëëùëñùëõ
ùëñ

:: [ùë•ùëñùëõ

ùëñ ]) as

public parameters, the sender calls

Œòùëñ ‚Üê ProveCred(ùë£ùëò, (ùëûùëñùëõ
ùëñ

, ùë£ùëñùëõ

ùëñ ), ùúéùëñùëõ
ùëñ

, ùúô ‚Ä≤)

Then, for every 1 ‚â§ ùëó ‚â§ ùëë, she calls

ùëó

, ùúô ‚Ä≤)

, ùë£ùëúùë¢ùë°
ùëó

, ùëûùëúùë¢ùë°
ùëó

((ùëüùëò ùëó , ùëüùëû ùëó , ùëüùë£ ùëó ), Œõ ùëó ) ‚Üê PrepareBlindSign(ùëòùëúùë¢ùë°
Define ùëÉ = (Œò1, . . . , Œò‚Ñì, Œõ1, . . . , Œõ ùëó , ùúô ‚Ä≤) and ‚Ñé = hash(ùëÉ). The
sender obtains ùê∂ùëñ = cert[ùëÖùëñ ] by broadcasting a request ùëÖùëñ =
Execute(ùëñùëëùëñ, ùëõùëñ, Spend(ùëâ ùëñùëõ
, ‚Ñé)) for some suitable sequence
ùëñ
number ùëõùëñ . The operation Spend behaves as the one described
in Section 5 except that (i) the attribute ùë• plays the role of ùëêùëö w.r.t.
the spent list spentùëñùëë (ùõº); and (ii) for simplicity, we differ the vali-
dation of each input coin credential (formerly the signature ùúé in ùëÇ)
to the next step.

, ùë•ùëñùëõ
ùëñ

ùëÖ‚àó

a

the

Next,

sender

request

submits
=
CreateAnonymousCoins(ùê∂1, . . . , ùê∂‚Ñì, ùëÉ). On receiving ùëÖ‚àó from the
sender, an authority ùúí now verifies the proofs Œòùëñ and Œõ ùëó and
the predicate ùúô ‚Ä≤ by running VerifyCred(ùë£ùëò, Œòùëñ, ùúô ‚Ä≤) for each ùëñ and
ùúéùëúùë¢ùë°
= BlindSign(ùë†ùëò ùúí , Œõ ùëó , ùúô ‚Ä≤) for each ùëó. If the proofs are valid, it
ùëó
(cid:101)
returns (cid:101)¬Øùúéùëúùë¢ùë° to the sender.

After collecting ùë° such responses, the sender can now run
Unblind and AggCred to obtain a valid credential on each created
output coin. Finally, to complete the transfer, it can send the coin
(ùëñùëëùëúùë¢ùë°
ùëó

) to the ùëó th recipient.

, ùúéùëúùë¢ùë°
ùëó

, ùë•ùëúùë¢ùë°
ùëó

, ùëûùëúùë¢ùë°
ùëó

, ùë£ùëúùë¢ùë°
ùëó

Opaque coin construction. We present the cryptographic prim-
itives used by the opaque coins transfer protocol. The Setup and
KeyGen algorithms are exactly the same as Coconut.
‚ùñ CoinRequest(ùë£ùëò, ¬Øùúéùëñùëõ, ¬Øùëûùëñùëõ, ¬Øùë£ùëñùëõ, ¬Øùëòùëúùë¢ùë° , ¬Øùëûùëúùë¢ùë° , ¬Øùë£ùëúùë¢ùë° , ùëâ ùëñùëõ
1

, . . . , ùëâ ùëñùëõ

) ‚Üí

(( ¬Øùëüùëò, ¬Øùëüùëû, ¬Øùëüùë£), Œì):
Parse ùë£ùëò = (ùõæ0, ùõæ1, ùõæ2, ùõº, ùõΩ0, ùõΩ1, ùõΩ2). For every input coin ùúéùëñùëõ
ùëñ
(1 ‚â§ ùëñ ‚â§ ‚Ñì), parse ùúéùëñùëõ
ùëñ = (‚Ñéùëñ, ùë†ùëñ ), pick at random ùëü‚Ñéùëñ, ùëüùë†ùëñ ‚àà F2
ùëù ,
and compute

‚Ñì

ùëñ = ‚Ñéùëü‚Ñéùëñ
‚Ñé‚Ä≤
ùëñ
= (‚Ñé‚Ä≤
ùëñ, ùë† ‚Ä≤

ùëñ

Then set ùúé ‚Ä≤ùëñùëõ

ùëñ = ùë†ùëü‚Ñéùëñ
ùë† ‚Ä≤
ùëñ

(‚Ñé‚Ä≤

ùëñ )ùëüùë†ùëñ

and
ùëñ ) and build:
ùúÖùëñ = ùõº ùëîùëüùë†ùëñ
2

ùõΩ

ùëûùëñùëõ
ùëñ
1

ùõΩ

ùë£ùëñùëõ
ùëñ
2

For every output coin ùëó (1 ‚â§ ùëó ‚â§ ùëë), pick a random ùëú ùëó ‚àà Fùëù , and
compute the commitments ùëêùëö ùëó and the group elements ^‚Ñé ùëó as

‚Ñé

‚Ñé

ùëú ùëó
1

ùëûùëúùë¢ùë°
ùëó

ùëòùëúùë¢ùë°
ùëó

ùëêùëö ùëó = ùëî

ùë£ùëúùë¢ùë°
ùëó
2
For all 1 ‚â§ ùëó ‚â§ ùëë, pick a random (ùëüùëò ùëó , ùëüùëû ùëó , ùëüùë£ ùëó ) ‚àà F3
the commitments (ùëêùëò ùëó , ùëêùëû ùëó , ùëêùë£ ùëó ) as follows:

and

‚Ñé

0

1

^‚Ñé ùëó = ùêª (ùëêùëö ùëó )

ùëù and compute

ùëêùëò ùëó = ^‚Ñé

ùëòùëúùë¢ùë°
ùëó
ùëó

ùëüùëò,ùëó
ùëî
1

and ùëêùëû ùëó = ^‚Ñé

ùëûùëúùë¢ùë°
ùëó
ùëó

ùëüùëû ùëó
ùëî
1

and ùëêùë£ ùëó = ^‚Ñé

ùë£ùëúùë¢ùë°
ùëó
ùëó

ùëü ùë£ ùëó
ùëî
1

15

‚Ñì

, . . . , ùëâ ùëñùëõ

‚ùñ IssueBlindCoin(ùë†ùëò ùúí , ùë£ùëò, Œì, ¬Øùëòùëñùëõ, ùëâ ùëñùëõ
) ‚Üí ((cid:101)¬Øùúé): The author-
1
ity ùúí parses ùë†ùëò ùúí = (ùë•, ùë¶0, ùë¶1, ùë¶2), ùë£ùëò = (ùõæ0, ùõæ1, ùõæ2, ùõº, ùõΩ0, ùõΩ1, ùõΩ2),
and Œì = (¬Øùúé ‚Ä≤ùëñùëõ, ¬ØùúÖ, ùëêùëö, ¬Øùëêùëò, ¬Øùëêùëû, ¬Øùëêùë£, ùúãùëü ). Recompute ^‚Ñé ùëó = ùêª (ùëêùëö ùëó ) for
each 1 ‚â§ ùëó ‚â§ ùëë.
Verify the proof ùúãùëü using Œì, ¬Ø‚Ñé‚àó, ùë£ùëò, and ùëâ ùëñùëõ
, . . . , ùëâ ùëñùëõ
. For each
1
1 ‚â§ ùëñ ‚â§ ‚Ñì, parse ùúé ‚Ä≤ùëñùëõ
ùëñ ), verify ‚Ñé‚Ä≤
ùëñ ‚â† 1, and that the
following bilinear evaluation holds:

= (‚Ñé‚Ä≤

ùëñ, ùë† ‚Ä≤

‚Ñì

ùëñ

ùëòùëñùëõ
0 ) = ùëí (ùë† ‚Ä≤
ùëñ
If one of these checks fail, stop the protocol and output ‚ä•. Oth-
erwise, compute:

ùëñ, ùúÖùëñ + ùõΩ

ùëñ , ùëî2)

ùëí (‚Ñé‚Ä≤

ùëó ùëêùëò ùë¶0

ùëó ùëêùëûùë¶1

ùëó ùëêùë£ ùë¶2

ùëó

ùë† ùëó = ^‚Ñéùë•
(cid:101)
ùúé ùëó = (^‚Ñé ùëó ,
ùë† ùëó ).
(cid:101)
(cid:101)

and output

‚ùñ PlainVerify(ùë£ùëò, ùúé, ùëò, ùëû, ùë£) ‚Üí (true/false): Parse ùúé = (‚Ñé, ùë†) and
. output

ùë£ùëò = (ùõæ0, ùõæ1, ùõæ2, ùõº, ùõΩ0, ùõΩ1, ùõΩ2). Reconstruct ùúÖ = ùõºùõΩùëò
0
true if ‚Ñé ‚â† 1 and ùëí (‚Ñé, ùúÖ) = ùëí (ùë†, ùëî2); otherwise output false.

ùõΩùëû
1

ùõΩ ùë£
2

The user then calls AggCred and Unblind over each
described in Appendix B.1.

ùúé ùëó exactly as
(cid:101)

Output (( ¬Øùëüùëò, ¬Øùëüùëû, ¬Øùëüùë£), Œì) where Œì = (¬Øùúé ‚Ä≤ùëñùëõ, ¬ØùúÖ, ¬Øùëêùëö, ¬Øùëêùëò, ¬Øùëêùëû, ¬Øùëêùë£, ùúãùëü )
where ùúãùëü is defined as:

ùúãùëü = NIZK{(¬Øùëûùëñùëõ, ¬Øùë£ùëñùëõ, ¬Øùëòùëúùë¢ùë° , ¬Øùëûùëúùë¢ùë° , ¬Øùë£ùëúùë¢ùë° , ¬Øùëüùë†, ¬Øùëú, ¬Øùëüùëò, ¬Øùëüùëû, ¬Øùëüùë£) :
ùë£ùëñùëõ
ùëñ
2
ùëòùëúùë¢ùë°
ùëó

‚àÄùëñ, ùúÖùëñ = ùõº ùëîùëüùë†ùëñ
2

ùëûùëñùëõ
ùëñ
1

ùëûùëúùë¢ùë°
ùëó

ùõΩ

ùõΩ

‚Ñé

1

‚Ñé

ùë£ùëúùë¢ùë°
ùëó
2

0

‚Ñé

‚àß ‚àÄùëó, ùëêùëö ùëó = ùëî

‚àß ‚àÄùëó, ùëêùëò ùëó = ^‚Ñé

ùëú ùëó
1
ùëòùëúùë¢ùë°
ùëó
ùëó
ùëûùëúùë¢ùë°
‚àß ‚àÄùëó, ùëêùëû ùëó = ^‚Ñé
ùëó
ùëó
ùë£ùëúùë¢ùë°
ùëó
ùëó

‚àß ‚àÄùëêùë£ ùëó = ^‚Ñé

ùëüùëò ùëó
ùëî
1
ùëüùëû ùëó
ùëî
1
ùëü ùë£ ùëó
ùëî
1

‚àß

ùëô
‚àëÔ∏Å

ùëñ

ùëô
‚àëÔ∏Å

ùë£ùëñùëõ
ùëñ +

ùëâ ùëñùëõ
ùëñ =

ùëñ
‚àà [0, ùë£max]

‚àß ùë£ùëúùë¢ùë°
ùëñ

}

ùëë
‚àëÔ∏Å

ùëó

ùë£ùëúùë¢ùë°
ùëó

16

