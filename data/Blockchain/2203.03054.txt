Veriﬁcation of Bitcoin Script in Agda using
Weakest Preconditions for Access Control

Fahad F. Alhabardi !
Swansea University, Dept. of Computer Science

Arnold Beckmann ! ˇ
Swansea University, Dept. of Computer Science

Bogdan Lazar !
University of Bath

Anton Setzer ! ˇ
Swansea University, Dept. of Computer Science

Abstract

This paper contributes to the veriﬁcation of programs written in Bitcoin’s smart contract
language script in the interactive theorem prover Agda. It focuses on the security property of access
control for script programs that govern the distribution of Bitcoins. It advocates that weakest
preconditions in the context of Hoare triples are the appropriate notion for verifying access control.
It aims at obtaining human-readable descriptions of weakest preconditions in order to close the
validation gap between user requirements and formal speciﬁcation of smart contracts.

As examples for the proposed approach, the paper focuses on two standard script programs
that govern the distribution of Bitcoins, Pay to Public Key Hash (P2PKH) and Pay to Multisig
(P2MS). The paper introduces an operational semantics of the script commands used in P2PKH
and P2MS, which is formalised in the Agda proof assistant and reasoned about using Hoare triples.
Two methodologies for obtaining human-readable descriptions of weakest preconditions are discussed:
(1) a step-by-step approach, which works backwards instruction by instruction through a script,
sometimes grouping several instructions together; (2) symbolic execution of the code and translation
into a nested case distinction, which allows to read oﬀ weakest preconditions as the disjunction of
conjunctions of conditions along accepting paths. A syntax for equational reasoning with Hoare
Triples is deﬁned in order to formalise those approaches in Agda.

2012 ACM Subject Classiﬁcation Theory of computation Ñ Hoare logic; Theory of computation
Ñ Type theory; Theory of computation Ñ Programming logic; Theory of computation Ñ Inter-
active proof systems; Theory of computation Ñ Operational semantics; Theory of computation Ñ
Denotational semantics; Security and privacy Ñ Access control; Security and privacy Ñ Logic and
veriﬁcation; Applied computing Ñ Digital cash

Keywords and phrases Blockchain; Cryptocurrency; Bitcoin; Agda; Veriﬁcation; Hoare logic; Bitcoin
script; P2PKH; P2MS; Access control; Weakest precondition; Predicate transformer semantics;
Provable correctness; Symbolic execution; Smart contracts

Supplementary Material Software (Agda Source Code):
https://github.com/fahad1985lab/Smart--Contracts--Verification--With--Agda

Acknowledgements We would like to thank the anonymous referees for valuable comments and
suggestions.

2
2
0
2

n
u
J

2
1

]

C
S
.
s
c
[

3
v
4
5
0
3
0
.
3
0
2
2
:
v
i
X
r
a

 
 
 
 
 
 
2

Veriﬁcation of Bitcoin Script in Agda

1

Introduction

Bitcoin, the ﬁrst cryptocurrency, was introduced in 2008 by Satoshi Nakamoto [38] to provide
a public payment mechanism, the blockchain, using pseudonymous keys in a peer-to-peer
network with distributed control. Many other cryptocurrencies have been introduced since.
Bitcoin’s blockchain provides a scripting system for transactions called script. Lists
of instructions in script are denoted Bitcoin scripts or simply scripts. The invention of
Ethereum [13] strengthened Bitcoin by adding full (Turing complete) smart contracts to
blockchains.
In this context, smart contracts can be seen as programs that automatically
execute when transactions are performed on a blockchain. Though not Turing complete as
Ethereum [13], Bitcoin scripts can be viewed as a weak form of smart contracts, that provide
important functionality, e.g. by governing the distribution of the Bitcoin cryptocurrency.

As smart contracts, including Bitcoin scripts, can control real world values and are
immutable once deployed on the blockchain network, a method to demonstrate their security
and correctness is needed [31, 50]. According to [4, 37, 19], there are two ways to verify
their correctness:
(1) by using mathematical methods like formal veriﬁcation, which utilise
theorem proving, model checking, and similar techniques, and (2) by employing testing.
Theorem proving provides an extremely ﬂexible veriﬁcation method that can be applied to
various types of systems including smart contracts. It can be done in interactive, automated,
or hybrid mode.

In our approach, we use the interactive theorem prover Agda [2] for the veriﬁcation of
Bitcoin scripts. Agda is designed to be both an interactive theorem prover and a dependently
typed programming language [40], therefore Agda allows us to deﬁne programs and reason
about them in the same system. This reduces the danger of producing errors when translating
programs from a programming language to a theorem prover, and allows to execute smart
contracts in Agda directly. Another advantage of Agda is to have proofs that are checkable by
hand. Other frameworks, such as Coq [43], use automatic proof search tools which usually do
not provide proof certiﬁcates that could in principle be checked by hand. Human checkable
proof certiﬁcates reduce the need to rely on a theorem prover being correct. The latter is
desirable because of potential attacks that exploit errors in theorem provers, e.g. by creating
a smart contract that contains a deliberate error together with a correctness proof that
exploits the error in the theorem prover.1 As a ﬁnal point, there are some key distinctions
between Agda and other theorem provers like Coq that suggest a diﬀerent applicability of
Agda. For example, Agda supports inductive-recursive types, while Coq does not [12]. Agda
also has a more ﬂexible pattern matching system than Coq, including support for copattern
matching [12].

Main contributions. Our main contributions in this paper are:

We argue that weakest preconditions are the appropriate notion to verify access control
for Bitcoin scripts.
We propose to aim for human-readable descriptions of weakest preconditions to support
judging whether the security property of access control is satisﬁed.
We describe two methods for achieving human-readable descriptions of weakest precondi-
tions: a step-by-step approach, and a symbolic-execution-and-translation approach.

1 See the forum discussion on [48] for a well documented list of incorrect protocols with false correctness

proofs. To hide backdoors using deliberately false correctness proofs is certainly conceivable.

F. Alhabardi, A. Beckmann, B. Lazar, and A. Setzer

3

We apply our proposed methodology to two standard Bitcoin scripts, providing fully
formalised arguments in Agda.

In the following we explain our contributions in more detail. The paper introduces an
operational semantics of the script commands used in Pay to Public Key Hash (P2PKH)
and Pay to Multisig (P2MS), two standard scripts that govern the distribution of Bitcoins.
We deﬁne the operational semantics as stack operations and reason about the correctness of
such operations using Hoare triples utilising pre- and postconditions.

Weakest precondition for access control. Our veriﬁcation focuses on the security property
of access control. Access control is the restriction to access for a resource, which in our use
case is access to cryptocurrencies like Bitcoin. We advocate that, in the context of Hoare
triples, weakest preconditions are the appropriate notion to model access control: A (general)
precondition expresses that when it is satisﬁed, access is granted, but there may be other
ways to gain access without satisfying the precondition. The weakest precondition expresses
that access is granted if and only if the condition is satisﬁed.

Human-readable descriptions. The weakest precondition can always be described in a
direct way, for example as the set of states that after execution of the smart contract end
in a state satisfying the given postcondition. However, such a description is meaningless to
humans who want to convince themselves that the smart contract is secure, in the sense that
they do not provide any further insights beyond the original smart contract.

It is known in software engineering, that failures of safety-critical systems are often due
to incomplete requirements or speciﬁcations rather than coding errors.2 The same applies
to security related software.3 It is not suﬃcient to have a proof of security of a protocol, if
the statement does not express what is required. That the speciﬁcation (here the formal
statement of secure access control) guarantees that the requirements are fulﬁlled (namely
that it is impossible for a hacker to access the resource, here the Bitcoin), needs to be checked
by a human being, who needs to be able to read the speciﬁcation and determine whether
it really is what is expressed by the requirements. Thus, the challenge is to obtain simple,
human-readable descriptions of the weakest precondition of a smart contract. This would
allow to close the validation gap between user requirements and formal speciﬁcation of smart
contracts.

Two methods for obtaining human-readable weakest preconditions. We discuss two meth-
ods for obtaining readable weakest preconditions: The ﬁrst, step-by-step approach, is obtained
by working through the program backwards instruction by instruction. In some cases it is
easier to group several instructions together and deal with them diﬀerently, as we will demon-
strate with an example in Sect. 6.3. The second method, symbolic-execution-and-translation,
evaluates the program in a symbolic way, and translates it into a nested case distinction.
The case distinctions are made on variables (of type nat or stack) or on expressions formed
from variables by applying basic functions to them such as hashing or checking for signature.
From the resulting decision tree, the weakest precondition can be read oﬀ as the disjunction

2 For instance, [32] writes: “Almost all accidents with serious consequences in which software was involved

can be traced to requirements failures, and particularly to incomplete requirements.”

3 The long list of protocols which were proven to be secure but had wrong proofs [20] demonstrates that
a proof of correctness is not suﬃcient. We assume that most of the examples had correct proofs, but
the statement shown was not suﬃcient to guarantee security.

4

Veriﬁcation of Bitcoin Script in Agda

of the conjunctions of the conditions that occur along branches that lead to a successful
outcome.

For both methods, it is necessary to prove that the established weakest precondition
is indeed the weakest precondition for the program under consideration. For the ﬁrst
method, this follows by stepwise operation. The second uses a proof that the original
program is equivalent to the transformed program from which the weakest precondition has
been established, or a direct proof which follows the case distinctions used in the symbolic
evaluation.

Application of our proposed methodology. We demonstrate the feasibility of our ap-
proaches by carrying them out in Agda for concrete smart contracts, including P2PKH and
P2MS.

Our approach also provides opportunities for further applications: The usage of the
weakest precondition with explicit proofs can be seen as a method of building veriﬁed smart
contracts that are correct by construction. Instead of constructing a program and then
evaluating it, one can start with the intended weakest precondition and postcondition, add
some intermediate conditions, and then develop the program between those conditions. Such
an approach would extend the SPARK Ada framework [1] to use Hoare logic (without the
weakest precondition) to check programs.

The remainder of this paper is organised as follows. In Sect. 2, we introduce related
work on veriﬁcation of smart contracts. Sect. 3 introduces Bitcoin script and deﬁnes its
operational semantics. In Sect. 4, we specify the security of Bitcoin script using Hoare logic
and weakest preconditions. We formalise these notions in Agda and introduce equational
reasoning for Hoare triples to streamline our correctness proofs. Sect. 5 introduces our
ﬁrst, step-by-step method of developing human-readable weakest preconditions and proving
correctness of P2PKH. In Sect. 6, we introduce our second method based on symbolic
execution and apply it to various examples. In Sect. 7, we explain how to practically use
Agda to determine and prove weakest preconditions using our library [47]. We conclude in
Sect. 8.

Notations and git repository. The formulas can be presented as full Agda code, but often
the formulas can also be presented in mathematical style. In order to switch between Agda
code and mathematical code easy, we use the functional style for application (i.e. writing
f a b c instead of f pa, b, cq) and x : A instead of x P A. s :: l denotes prepending an element
onto a list. The original Agda deﬁnitions are also available [47]. Most display style Agda
code presented in this paper has been automatically extracted from the Agda code, in some
cases it was formatted by hand based on LATEX code generated by Agda to improve the
presentation.

2

Related Work

In this section we describe research relevant to our approach. We start by discussing two
papers introducing Hoare logic, predicate transformer semantics and weakest preconditions.
We then review papers that address veriﬁcation of smart contracts, and Bitcoin scripts. We
present a number of approaches to use model-checking for the veriﬁcation of smart contracts,
and ﬁnish with work with employs Agda in the veriﬁcation of smart contracts.

F. Alhabardi, A. Beckmann, B. Lazar, and A. Setzer

5

Hoare Logic, Predicate Transformer Semantics and Weakest Preconditions. Hoare [26]
deﬁnes a formal system using logical rules for reasoning about the correctness of computer
It uses so-called Hoare triples which combine two predicates, a pre- and a
programs.
postcondition, with a program to express that if the precondition holds for a state and
the program executes successfully, then the postcondition holds for the resulting state.
Djikstra [22] introduces predicate transformer semantics that assigns to each statement in an
imperative programming paradigm a corresponding total function between two predicates on
the state space of the statement. The predicate transformer deﬁned by Djikstra applied to a
postcondition returns the weakest precondition.

Veriﬁcation of Smart Contracts. A number of authors have addressed the veriﬁcation of
smart contracts in Ethereum and similar platforms. Hirai [25] used Isabelle/HOL theorem
prover to validate Ethereum Virtual Machine (EVM) bytecode by developing a formal model
for EVM using the Lem language [36]. They use this model to prove invariants and safety
properties of Ethereum smart contracts. Amani et al. [5] extended Hirai’s EVM formalisation
in Isabelle/HOL by a sound program logic at bytecode level. To this end, they stored
bytecode sequences into blocks of straight-line code, creating a program logic that could
reason about these sequences. Ribeiro et al. [45] developed an imperative language for a
relevant subset of Solidity in the context of Ethereum, using a big-step semantics system.
Additionally, they formalised smart contracts in Isabelle/HOL, extending the existing work.
Their formalisation of semantics is based on Hoare logic and the weakest precondition
calculus. Their main contributions are proofs of soundness and relative completeness, as
well as applications of their machinery to verify some smart contracts including modelling of
smart contract vulnerabilities. Bernardo et al. [9] present Mi-Cho-Coq, a Coq framework
which has been used to formalise Tezos smart contracts written in the stack-based language
Michelson. The framework is composed of a Michelson interpreter implemented in Coq, and
the weakest precondition calculus to verify Michelson smart contracts’ functional correctness.
O’Connor [41] introduces Simplicity, a low-level, typed functional language, which is Turing
incomplete. The goal of Simplicity is to improve on existing blockchain-based languages,
like Ethereum’s EVM and Bitcoin script, while avoiding some of their issues. Simplicity
is based on formal semantics and is speciﬁed in the Coq proof assistant. Bhargavan et
al. [10] provided formalisations of EVM bytecode in F*, a functional programming language
designed for program veriﬁcation. They deﬁned a smart contract veriﬁcation architecture
that can compile Solidity contracts, and decompile EVM bytecode into F* using their shallow
embedding, in order to express and analyse smart contracts.

Veriﬁcation of Bitcoin Scripts. Klomp et al. [30] proposed a symbolic veriﬁcation theory,
and a tool to analyse and validate Bitcoin scripts, with a particular focus on characterising
the conditions under which an output script, which controls the successful transfer of Bitcoins,
will succeed. Bartoletti et al. [8] presented BitML, a high-level domain-speciﬁc language for
designing smart contracts in Bitcoin. They provided a compiler to convert smart contracts
into Bitcoin transactions, and proved the correctness of their compiler w.r.t. a symbolic
model for BitML and a computational model, which has been deﬁned as well in [7] for Bitcoin.
Setzer [46] developed models of the Bitcoin blockchain in the interactive theorem prover
Agda. This work focuses on the formalisation of basic primitives in Agda as a basis for future
work on verifying the protocols of cryptocurrencies and developing veriﬁed smart contracts.

6

Veriﬁcation of Bitcoin Script in Agda

Veriﬁcation of Smart Contracts using Model Checking. A number of papers discuss tools
for analysing and verifying smart contracts that utilise model checking. Kalra et al. [28]
developed a framework called ZEUS whose aim is to support automatic formal veriﬁcation of
smart contracts using abstract interpretation and symbolic model checking. ZEUS starts from
a high-level smart contract, and employs user assistance for capturing correctness and fairness
requirements. The contract and policy speciﬁcation are then transformed into an intermediate
language with well deﬁned execution semantics. ZEUS then performs static analysis on
the intermediate level and uses external SMT solvers to evaluate any veriﬁcation properties
discovered. A main focus of the work is on reducing eﬃciently the state explosion problem
inherent in any model checking approach. Park et al. [42] proposed a formal veriﬁcation
tool for EVM bytecode based on KEVM, a complete formal semantics of EVM bytecode
developed in the K-framework. To address performance challenges, they deﬁne EVM-speciﬁc
abstractions and lemmas, which they then utilise to verify a number of concrete smart
contracts. Mavridou et al. [33] introduce the VeriSolid framework to support the veriﬁcation
of Ethereum smart contracts. VeriSolid is based on earlier work (FSolidM) which allows to
graphically specify Ethereum smart contracts as transitions systems, and to generate Solidity
code from those speciﬁcation. It uses model checking to verify smart contract models. Luu
et al. [31] provided operational semantics of a subset of Ethereum bytecode called EtherLite,
which forms the bases of their symbolic execution tool Oyente for analysing Ethereum smart
contracts. Based on their tool they discovered a number of weaknesses in deployed smart
contracts, including the DAO bug [23]. Filliâtre et al. [24] introduced the Why3 system,
which allows writing imperative programs in WhyML, an ML dialect used for programming
and speciﬁcation. The system can add pre-, post- and intermediate conditions to it but does
not make use of weakest precondition. Why3 can generate veriﬁcation conditions for Hoare
triple, which are checked using variously automated and interactive theorem provers. Why3
is used in SPARK Ada to verify its veriﬁcation conditions.

Agda in the Veriﬁcation of Blockchains. Finally, Agda features in several papers discussing
veriﬁcation of blockchains. Chakravarty et al. [16] introduce Extended UTXO (EUTXO),
which extends Bitcoin’s UTXO model to enable more expressive forms of validation scripts.
These scripts can express general state machines and reason about transaction chains: The
authors introduce a new class of state machines based on Mealy machines which they call
Constraint Emitting Machines (CEM). In addition to formalising CEMs using Agda proof
assistant, they demonstrate its conversion to EUTXO, and give a weak bisimulation between
both systems. In [14] Chakravarty et al. introduce a generalisation of the EUTXO ledger
model using native tokens which they denote EUTXOma for EUTXO with multi-assets.
They provide a formalisation of the multi-asset EUTXO model in Agda. Chakravarty et
al. [15] introduce a version of EUTXOma aligned to Bitcoin’s UTXO model, hence denoted
UTXOma. They present a formal speciﬁcation of the UTXOma ledger rules and formalise
their model in Agda. Chapman et al. [17] formalise System Fωµ, which is polymorphic λ-
calculus with higher-kinded and arbitrary recursive types, in Agda. System Fωµ corresponds
to Plutus Core, which is the core of the smart contract language Plutus that features in
the Cardano blockchain. Melkonian [34] introduces a formal Bitcoin transaction model to
simulate transactions in the Bitcoin environment and to study their safety and correctness.
The paper presents a formalisation of a process calculus for Bitcoin smart contracts, denoted
BitML. The calculus can accept diﬀerent types such as basic types, contracts, or small step
semantics to outline a ‘certiﬁed compiler’ [35].

F. Alhabardi, A. Beckmann, B. Lazar, and A. Setzer

7

3 Operational Semantics for Bitcoin Script

We give a brief introduction of Bitcoin script in Subsec. 3.1, before deﬁning its operational
semantics in Subsec. 3.2.

3.1 Introduction to Bitcoin Script

The scripting language for Bitcoin is stack-based, inspired by the programming language
Forth [44], with the stack being the only memory available. Elements on the stack are byte
vectors, which we represent as natural numbers. Values on the stack are also interpreted as
truth values, any value ą0 will be interpreted as true, and any other value as false. script
has its own set of commands called opcodes, which manipulate the stack. They are similar
to machine instructions, although some instructions have a more complex behaviour. The
instructions of script are executed in sequence. In case of conditionals (which are not
part of this paper) the execution of instructions might be ignored until the end of an if- or
else-case has been reached, otherwise the script is executed from left to right. Execution of
instructions might fail, in which case the execution of the script is aborted. A full list of
instructions with their meaning can be found in [11], which is the defacto speciﬁcation of
script.

The operational semantics of the opcodes can be found in the source code [47]. We
introduce here a number of opcodes that are relevant to this paper. Execution of all opcodes
fails, if there are not suﬃciently many elements on the stack to perform the operation in
question.

OP_DUP duplicates the top element of the stack.
OP_HASH takes the top item of the stack and replaces it with its hash.
OP_EQUAL pops the top two elements in the stack and checks whether they are equal or
not, pushing the Boolean result on the stack.
OP_VERIFY invalidates the transaction if the top stack value is false. The top item on the
stack will be removed.
OP_CHECKSIG pops two elements from the stack and checks whether they form a correct
pair of a signature and a public key signing a serialised message obtained from the selected
input and all outputs of the transaction, and pushes the Boolean result on the stack.
OP_CHECKLOCKTIMEVERIFY fails if the time on the stack is greater than the current time.
OP_MULTISIG is the multisig instruction, which will be discussed in detail in Sect. 6.2.
There are a number of opcodes for pushing byte vectors of diﬀerents lengths onto the
stack. We write <number> for the opcode together with arguments pushing number onto
the stack. In Agda we will have one instruction opPush n which pushes the number n on
the stack.

Scripts can also contains control ﬂow statements such as OP_IF. The veriﬁcation of scripts

involving control statements is more involved and will be considered in a follow-up paper.

In Bitcoin we consider the interplay between a locking script scriptPubKey and an
unlocking script scriptSig.4 The locking script is provided by the sender of a transaction
to lock the transaction, and the unlocking script is provided by the recipient to unlock it.
The unlocking script pushes the data required to unlock the transaction on the stack, and

4 We are using the terminology locking script and unlocking script from [6, Chapt 5].

8

Veriﬁcation of Bitcoin Script in Agda

the locking script then checks whether the stack contains the required data. Therefore, the
unlocking script is executed ﬁrst, followed by the locking script.5

The main example in this paper is the pay-to-public-key-hash (P2PKH) script consisting

of the following locking and unlocking scripts:

scriptPubKey: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUAL OP_VERIFY OP_CHECKSIG
scriptSig:

<sig> <pubKey>

The standard unlocking script scriptSig pushes a signature sig and a public key pubKey
onto the stack. The locking script scriptPubKey checks whether pubKey provided by the
unlocking script hashes to the provided pubKeyHash, and whether the signature is a signature
for the message signed by the public key. Full details will be discussed in Sect. 5.

3.2 Operational Semantics

Opcodes like OP_DUP operate on the stack deﬁned in Agda as a list of natural numbers Stack.
Opcodes like OP_CHECKSIG check for signatures for the part of the transaction which is to be
signed – what is to be signed is hard coded in Bitcoin. In order to abstract away from the
precise format and the encoding, we deﬁne a message type Msg in Agda, which allows to
represent messages such as those for the transaction to be signed, and is to be instantiated
with the concrete message to be signed. Other opcodes like OP_CHECKLOCKTIMEVERIFY refer
to the current time, for which we deﬁne a type Time in Agda. Therefore, the operational
semantics of opcodes depends on Time ˆ Msg ˆ Stack which we deﬁne in Agda as the record
type StackState.6 Note that Time and Msg don’t change during the execution of a script.

The type of all opcodes is given as InstructionBasic.7 Opcodes can also fail, for instance
if there are not enough elements on the stack as required by the operation. Hence, the
operational semantics of an instruction op : InstructionBasic is given as

op

s : StackState → Maybe StackState.8
(cid:75)
The message and time never change, so

(cid:74)
s s will, if executed successfully, only change
p
(cid:75)
the stack part of s. As an example, we can deﬁne the semantics of the instruction opEqual.

(cid:74)

5 In the original version of Bitcoin both scripts were concatenated and executed. However, because Bitcoin
script has non-local instructions (e.g. the conditionals OP_IF, OP_ELSE, OP_ENDIF), when concatenating
the two scripts any non-local opcode occurring in the locking script (for instance as part of data) could
be interpreted when running as the counterpart of a non-local opcode in the locking script and therefore
result in an unintended execution of the unlocking script. As a bug ﬁx, in a later version of Bitcoin
this was modiﬁed by having a break point in between the two, where only the stack is passed on. See
Chapter 6, “Separate execution of unlocking and locking scripts” in [6, p. 136]. In this paper this
problem doesn’t occur because we don’t consider non-local instructions.

6 The idea of packaging all components of the state into one product type, which is then expanded into
a more expanded state as more language constructs are added to the language, is inspired by Peter
Mosses’ Modular SOS approach [21]. This approach was successful in creating a library of reusable
components funcons for deﬁning an executable operational semantics of language constructs, which
require diﬀerent sets of states. One outcome was a “component-based semantics for CAML LIGHT”
[18].

7 We are using in this paper a sublanguage BitcoinScriptBasic of Bitcoin, which doesn’t contain conditionals,
because they require a more complex operational semantics and state (see the discussion in the conclusion).
We make the distinction between the basic and full language in order to be compatible with the planned
follow up papers based on code under development, which will extend the basic language. We sometimes
use notations such as b to diﬀerentiate between functions referring to the basic and full language.
8 For the reader not familiar with the Maybe type, a set theoretic notation can be given as Maybe X :“
tnothingu Y tjust x | x : Xu. Here, nothing denotes undeﬁned, and just x denotes the deﬁned element x.
Maybe forms a monad, with return :“ just : A → Maybe A and the bind operation pp ąą“ q : Maybe Bq
for p : Maybe A and q : A → Maybe B deﬁned by pnothing ąą“ qq “ nothing and pjust a ąą“ qq “ q a.

F. Alhabardi, A. Beckmann, B. Lazar, and A. Setzer

9

We ﬁrst deﬁne a simpler function
Time and Msg:

_
(cid:75)

s

(cid:74)

s, which abstracts away the non-changing components

s
(cid:75)

s time1 msg = executeStackEquality

s : InstructionBasic → Time → Msg → Stack → Maybe Stack

_
s
(cid:74)
(cid:75)
opEqual
(cid:74)
The function executeStackEquality : Stack → Maybe Stack fails and returns nothing if the
stack has height ď1, and otherwise compares the two top numbers on the stack, replacing
them by 1 for true in case they are equal, and by 0 for false otherwise.

s is then lifted to the semantics of the instructions

s

_
(cid:74)

(cid:75)

liftStackFun2StackState:

s using a generic function

_
(cid:74)

(cid:75)

s

(cid:74)

op

s
(cid:75)

s = liftStackFun2StackState
(cid:75)

s : InstructionBasic → StackState → Maybe StackState
(cid:75)
op

_
(cid:74)
(cid:74)
As prerequisites for Sect 6.1, we deﬁne functions that deﬁne the operational semantics
of further Bitcoin instructions used in this paper: executeStackDup : Stack → Maybe Stack
fails and returns nothing if the stack is empty; otherwise, a duplicate of the top element
will be added onto the stack. The function executeOpHash : Stack → Maybe Stack fails
and returns nothing if the stack is empty; otherwise, the top element is replaced by its
hash. executeStackVerify : Stack → Maybe Stack fails and returns nothing if the stack is
empty or the top element is 0; otherwise, it will remove the top element of the stack.
executeStackCheckSig : Stack → Maybe Stack fails and returns nothing if the height of the
stack ď1. Otherwise it pops the two top elements from the stack, and considers them as a
signature and public key. It decides whether the message given by the argument msg : Msg
is correctly signed by these data, and pushes the Boolean result on the stack.

script has instructions with more complex behaviour, an example is the instruction
OP_MULTISIG which will be introduced in Sect. 6.2. Some instructions depend on crypto-
graphic functions for hashing and checking signatures. We abstract away from their concrete
deﬁnition and take them as parameters of the modules of the Agda code. This is not a
problem in this paper, since the weakest preconditions only depend on the results returned
by these functions, such as a check whether the part of the transaction to be signed is signed
by a signature corresponding to a given public key.

General scripts are formalised in Agda as lists of instructions, BitcoinScriptBasic. Let p be
: StackState → Maybe StackState by monadic composition, that is

a script. We deﬁne

p

[]

:“ just,

(cid:74)

(cid:75)

(cid:75)

p `` q

s ąą“
to s : Maybe StackState by deﬁning

(cid:74)
for an instruction op, script q and s : StackState deﬁne
(cid:74)
q
(cid:75)
p

It follows that @s : StackState.
(cid:74)
We lift as well
(cid:75)
Let
StackStatePred = StackState → Set,
StackPredicate = Time → Msg → Stack → Set, and
stackPred2SPred : StackPredicate → StackStatePred be the obvious lifting.

(cid:75)
(cid:74)
` s :“ s ąą“
(cid:75)

op :: q
.

s :“

s ”

(cid:74)
(cid:74)

p

p

(cid:75)

(cid:75)

(cid:74)

(cid:74)

s s ąą“

op

(cid:75)

q

.
(cid:75)

(cid:74)

p

.

(cid:75)

(cid:74)

4

Specifying Security of Bitcoin Scripts

In this section we argue that weakest precondition in the context of Hoare logic are the
appropriate notion to express security properties in Subsect. 4.1. We provide a formalisation
of weakest preconditions in Agda in Subsect. 4.2, and discuss how weakest preconditions can
be generated automatically in Subsect. 4.3, leading to the claim that we need human-readable

10

Veriﬁcation of Bitcoin Script in Agda

descriptions of weakest preconditions. To support our veriﬁcation, we develop a library for
equational reasoning with Hoare triples in Subsect. 4.4.

4.1 Weakest Precondition for Security

One widely used way to specify the correctness of imperative programs axiomatically is
Hoare logic [26]. Hoare logic is based on pre- and postconditions. It works well for safety
critical systems, where the set of inputs is controlled, and the aim is to guarantee a safe
result. An example of a commercial system for writing safety critical systems using Hoare
logic is SPARK 2014 [1].

However, when dealing with security aspects, in particular access control, Hoare logic
in general is not suﬃcient. The issue is that for security it is necessary to guard against
malicious entries to a program. We argue that weakest preconditions in the context of
Hoare logic is an appropriate notion to specify security properties. A weakest precondition
expresses that it is not only suﬃcient, but as well necessary for the postcondition to hold
after executing the program.

To explain our point, we specify the intended correctness of the locking script scriptPubKey
from Sect. 3. The intention, usually given by the user requirement, is that in order for a
locking script to run successfully, we need to provide a public key pbk and a signature sig
such that pbk hashes to the value <pubKeyHash> stored in the locking script, and that sig
validates the signed message using pbk. The values pbk and sig need to be the top elements
on the stack. If we also ﬁx their order and allow the stack to have arbitrary values otherwise,9
then we can express this condition as follows:

The two top elements of the stack are pbk and sig, pbk hashes to <pubKeyHsh>,
and sig is a valid signature of the signed message w.r.t. pbk.

(CondPBKH)

We can deﬁne the speciﬁcation of the locking script scriptPubKey as the property that
(CondPBKH) is the weakest precondition for the accepting postcondition. We will show
in Sect. 5 that (CondPBKH) is indeed the weakest precondition of scriptPubKey, which
veriﬁes that scriptPubKey fulﬁls the speciﬁcation.

Let us now consider a faulty locking script instead of scriptPubKey:

scriptPubKeyFaulty: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUAL

To see that it does not fulﬁl the speciﬁcation given above, consider the weakest precondition
for scriptPubKeyFaulty for the accepting postcondition, which can be described by the
following condition:

The top element of the stack is pbk, and pbk hashes to <pubKeyHsh>.

(CondPBKHfaulty)

By inspection we see that (CondPBKHfaulty) is not equivalent to (CondPBKH), and
therefore scriptPubKeyFaulty doesn’t fulﬁl the speciﬁcation. In fact we can identify states
which satisfy (CondPBKHfaulty) but not (CondPBKH), e.g. a malicious attacker could just
copy the public key of the sender onto the stack, which violates the user requirements of a
locking script.

We observe that this example also demonstrates the inadequacy of general Hoare logic
for the veriﬁcation the security property of access control: Using standard Hoare logic, we
can prove that (CondPBKH) is a precondition for the accepting postcondition for both
scriptPubKey and scriptPubKeyFaulty.

9 Bitcoin scripts do not put any requirements on the stack below the data required by the scripts.

F. Alhabardi, A. Beckmann, B. Lazar, and A. Setzer

11

As with all formal veriﬁcation approaches, there remains a gap between the user’s intention
expressed as requirements, and what is expressed as a formal speciﬁcation. This gap cannot
be ﬁlled in a provably correct way, since requirements are a mental intention expressed in
natural language. However, the gap can be narrowed by expressing the speciﬁcation in a
human-readable format so that the validation is as easy and clear as possible. Here, validation
means showing that the speciﬁcation guarantees the requirements, and is carried out by a
human reader.

4.2 Formalising Weakest Preconditions in Agda

We now describe how weakest preconditions can be deﬁned in Agda. Let a precondition
ϕ and postcondition ψ be given, both of type StackStatePred. In order to accommodate
Maybe, we deﬁne a postﬁx operator _`, to lift ψ to pψ `q : Maybe StackState → Set, deﬁning
pψ `q nothing “ K and pψ `q ˝ just “ ψ.

A Hoare triple, consisting of a precondition, a program, and a postcondition, expresses
that if the precondition is satisﬁed before execution of the program, then the postcondition
holds after executing it. We formalise Hoare triples as follows:
< ϕ > p < ψ > := @s P StackState.ϕpsq → pψ `q p
sq
(cid:74)

Weakest preconditions express that the precondition not only is suﬃcient, but as well

p

(cid:75)

necessary for the postcondition to hold after executing the program:
< ϕ >if f p < ψ > := @s P StackState.ϕpsq Ø pψ `q p
(cid:74)

sq

p

(cid:75)

Thus, for security the backwards direction of the equivalence in the previous formula is

the important direction.

lock

In Bitcoin we consider a locking script scriptPubKey and an unlocking script scriptSig,
see Section 3.1. Let us ﬁx an unlocking script unlock and a locking script lock. Let init be
the initial state consisting of an empty stack, and let acceptState be the accepting condition
expressing that the stack is non empty with top element being not false, i.e. ą0. The
combination of unlock and lock is accepted iﬀ running unlock on init succeeds and running
lock on the resulting stack results in a state that satisﬁes the accepting condition, i.e. iﬀ
pacceptState `q p
initqq. Note that Bitcoin does not run the
(cid:74)
concatenation of the two scripts, as it did in its ﬁrst version, but runs ﬁrst the unlocking
scripts, and if it succeeds runs the locking script on the resulting stack. Let ϕ be the weakest
precondition of lock, i.e. < ϕ >if f lock < acceptState >. Then the acceptance condition
is equivalent to pϕ`q p
initq. Thus, unlock succeeds iﬀ running the unlocking
script unlock on the initial state init produces a state fulﬁlling ϕ. Hence, by determining the
weakest precondition for the locking script w.r.t. the accepting condition we have obtained a
characterisation of the set of unlocking scripts which unlock the locking script. Note that
we do not deﬁne inductively all successful unlocking scripts, since they could be arbitrary
complex programs, but instead characterise them by the output they produce.

` p
(cid:75)

unlock

unlock

(cid:75)

(cid:74)

(cid:75)

(cid:74)

4.3 Automatically Generated Weakest Preconditions

We start by giving a direct method for deﬁning the weakest precondition for any Bitcoin
script by describing the set of states that lead to a given ﬁnal state. We then apply this
general method to a toy example to demonstrate that the description obtained in this way is
usually not helpful for a human to judge whether the script has the right properties, thus
making the case that the task must be to ﬁnd (equivalent) human-readable descriptions.

Weakest preconditions can be deﬁned by the simple deﬁnition

12

Veriﬁcation of Bitcoin Script in Agda

weakestPreConds : BitcoinScriptBasic → StackStatePred → StackStatePred
weakestPreConds p φ s = (φ `) (
(cid:74)

s)

p

(cid:75)

Consider a simple toy program which removes the top element from the stack three times:

testprog = opDrop :: opDrop :: [ opDrop ]
Its weakest precondition can be computed as
weakestPreCondTestProg = weakestPreConds testprog acceptState
We obtain the following code (we slightly reformatted it to improve readability):

weakestPreCondTestProgNormalised s =
(stackPred2SPred acceptStates `)

(stackState2WithMaybe 〈 currentTime s , msg s , executeStackDrop (stack s) 〉
ąą“ (λ s1 → stackState2WithMaybe 〈 currentTime s1 , msg s1 , executeStackDrop (stack s1) 〉

ąą“ liftStackFun2StackState (λ time1 msg1 → executeStackDrop)))

This condition is diﬃcult to understand. The reason is that each instruction may cause
the program to abort in case the stack is empty. The condition expresses: if the stack is
empty then the condition is false. Otherwise, if after dropping the top element the stack is
empty the condition is false. Otherwise, if after dropping again the top element the stack
is empty the condition is false. Otherwise the condition is true if after dropping again the
top element the stack is non empty and the top element is not false. The readable condition
would express that the height of the stack is ě 4 and the fourth element from the top is ą 0.
In this simple example simplifying the condition would be easy, but when using diﬀerent
instructions the situation becomes more complicated.

What we did using our methods to avoid this problem was to create the weakest precondi-
tion by starting from the end and improving it in each step, or by replacing the program by
an easier program (which in case of this example would return nothing if the stack has height
ď 2 and otherwise returns the result of dropping the ﬁrst three elements oﬀ the stack). An
interesting project for future work would be to automate the steps we carried out manually,
and obtain readable weakest preconditions automatically.

4.4 Equational Reasoning with Hoare Triples

To support the veriﬁcation of Bitcoin scripts with Hoare triples and weakest preconditions
in Agda, we have developed a library in Agda for equational reasoning with Hoare triples.
The library is inspired by what is described in Wadler et al. [49]. Let p, q be scripts and
φ, φ1, ψ, ψ1 : Predicate. If we deﬁne ϕ <=>p ψ :“ @s : StackState.ϕpsq Ø ψpsq, we can easily
show

< ϕ >if f p < ψ > ^ < ψ >if f q < ρ > → < ϕ >if f p `` q < ρ >
< ϕ >if f p < ψ > ^ ψ <=>p ψ1
ϕ1 <=>p ϕ

→ < ϕ >if f p < ψ1 >
^ < ϕ >if f p < ψ > → < ϕ1 >if f p < ψ >

We demonstrate our syntax by an example, assuming (using Agda postulate) programs

prog1, prog2, prog3, and proofs

proof1 : < precondition >if f prog1 < intermediateCond1 >
proof2 : < intermediateCond1 >if f prog2 < intermediateCond2 >
proof3 : intermediateCond2 <=>p intermediateCond3
proof4 : < intermediateCond3 >if f prog3 < postcondition >

F. Alhabardi, A. Beckmann, B. Lazar, and A. Setzer

13

Then the proof for the Hoare triple for prog1 `` pprog2 `` prog3q is given in Agda as

follows:10

theorem : < precondition >if f prog1 `` (prog2 `` prog3) < postcondition >
theorem = precondition

<><>〈 prog1 〉〈 proof1
intermediateCond1 <><>〈 prog2 〉〈 proof2
intermediateCond2 <=>〈
intermediateCond3 <><>〈 prog3 〉〈 proof4

proof3 〉

〉
〉

〉e postcondition ‚p

5

Proof of Correctness of the P2PKH script using the Step-by-Step
Approach

This section explains the usage of our approach by providing an example of how to prove
the correctness of the P2PKH using step-by-step to obtain the weakest precondition. The
P2PKH is the most used script in Bitcoin transactions. The locking script, which depends
on a public key hash, is deﬁned as follows:

scriptP2PKHb : (pbkh : N) → BitcoinScriptBasic
scriptP2PKHb pbkh = opDup :: opHash :: (opPush pbkh) :: opEqual :: opVerify :: [ opCheckSig ]

In this section we develop a readable weakest precondition of the P2PKH script and

prove its correctness by working backwards instruction by instruction.

Let acceptState be the accepting state where the stack is non-empty with top element
ą0. We deﬁne intermediate conditions accept1, accept2, etc, the weakest precondition
wPreCondP2PKH, and proofs correct-opCheckSig, correct-opVerify etc of corresponding Hoare
triples w.r.t. the instructions of the Bitcoin script, working backwards starting from the last
instruction opCheckSig:
correct-opCheckSig : < accept1 >if f ([ opCheckSig ]) < acceptState >
correct-opVerify : < accept2 >if f ([ opVerify ]) < accept1 >
correct-opEqual : < accept3 >if f ([ opEqual ]) < accept2 >
correct-opPush : (pbkh : N) → < accept4 pbkh >if f ([ opPush pbkh ]) < accept3 >
correct-opHash : (pbkh : N) → < accept5 pbkh >if f ([ opHash]) < accept4 pbkh >
correct-opDup : (pbkh : N) → < wPreCondP2PKH pbkh >if f ([ opDup]) < accept5 pbkh >

The intermediate conditions can be read oﬀ from the operations. We present them in
t : N
mathematical notation below, using the following conventions and abbreviations:
denotes time, m : Msg, st, st1 : Stack, x : N; for brevity we omit types after D quantiﬁers. We
use here and in the remaining paper s for operations where the StackState argument has
been unfolded into its components.

10 In the last step we use 〉e instead of 〉. This avoids concatenating the program with []. If we used 〉, the
theorem would prove the condition for program prog1``(prog2``(prog3``[])), which is provably but
not deﬁnitionally equal to the original program, requiring an additional proof step.

14

Veriﬁcation of Bitcoin Script in Agda

acceptStates t m st ô D x, st1.
accepts

1 t m st

ô D pbk, sig, st1.

^ IsSigned m sig pbk

st ” x :: st1 ^ x ą 0
st ” pbk :: sig :: st1

accepts

2 t m st

accepts

3 t m st

ô D x, pbk, sig, st1.

st ” x :: pbk :: sig :: st1

^ x ą 0 ^ IsSigned m sig pbk

ô D pbkh2, pbkh1, pbk, sig, st1.st ” pbkh2 :: pbkh1 :: pbk :: sig :: st1

^ pbkh2 ” pbkh1 ^ IsSigned m sig pbk

accepts

4 pbkh1 t m st ô D pbkh2, pbk, sig, st1.

st ” pbkh2 :: pbk :: sig :: st1

^ pbkh2 ” pbkh1 ^ IsSigned m sig pbk

accepts

5 pbkh1 t m st ô D pbk1, pbk, sig, st1.

st ” pbk1 :: pbk :: sig :: st1

wPreCondP2PKHs pbkh1 t m st ô D pbk, sig, st1.

^ hashFun pbk1 ” pbkh1 ^ IsSigned m sig pbk
st ” pbk :: sig :: st1
^ hashFun pbk ” pbkh1 ^ IsSigned m sig pbk
In Agda, these formulas are deﬁned by case distinction on the stack. As examples, the
code for the accept condition (acceptState) and the weakest precondition (wPreCondP2PKHs)
is as follows:

acceptStates : StackPredicate
acceptStates time msg1 []
acceptStates time msg1 (x :: stack1) = NotFalse x

= K

wPreCondP2PKHs : (pbkh : N ) → StackPredicate
wPreCondP2PKHs pbkh time m []
= K
wPreCondP2PKHs pbkh time m (x :: []) = K
wPreCondP2PKHs pbkh time m ( pbk :: sig :: st) =

(hashFun pbk ” pbkh ) ^ IsSigned m sig pbk

Using our syntax for equational reasoning, we can prove the weakest precondition for the

P2PKH script as follows:

theoremP2PKH : (pbkh : N) → < wPreCondP2PKH pbkh >if f scriptP2PKHb pbkh < acceptState >
theoremP2PKH pbkh = wPreCondP2PKH pbkh <><>〈 [ opDup ] 〉〈 correct-opDup pbkh 〉
〉〈 correct-opHash pbkh 〉
〉〈 correct-opPush pbkh 〉
〉
〉〈 correct-opEqual
〉〈 correct-opVerify
〉
〉〈 correct-opCheckSig 〉e

accept5 pbkh <><>〈 [ opHash ]
accept4 pbkh <><>〈 [ opPush pbkh ]
accept3
accept2
accept1
acceptState ‚p

<><>〈 [ opEqual ]
<><>〈 [ opVerify ]
<><>〈 [ opCheckSig ]

The locking script will be accepted if, after executing the code starting with the stack
returned by the unlocking script, the accept condition acceptState is fulﬁlled. The veriﬁcation
conditions and proofs were developed by working backwards starting from the last instruction
and determining the weakest preconditions “accepti” w.r.t. the end piece of the script starting
with that instruction and the accept condition as post-condition. The preconditions were
obtained manually – one could automate this by determining for each instruction depending
on the post-condition a corresponding pre-condition, where the challenge would be to simplify
the resulting pre-conditions in order to avoid a blowup in size. We continued in this way until
we reached the ﬁrst instruction and obtained the weakest precondition for the locking script.

F. Alhabardi, A. Beckmann, B. Lazar, and A. Setzer

15

theoremP2PKH is using single instructions in order to prove the correctness of P2PKH. The
proofs correct-opCheckSig, correct-opVerify, etc are done by following the case distinctions
made in the corresponding veriﬁcation conditions. The harder direction is to prove that they
are actually weakest preconditions: Proving that the precondition implies the postcondition
after running the program, is easier since we are used to mentally executing programs in
forward direction. Proving the opposite direction requires showing that the only way, after
running the program, to obtain the postcondition is to have the precondition fulﬁlled, which
requires mentally reversing the execution of programs.

6

Proof of Correctness using Symbolic Execution

In this section, we will introduce a second method for obtaining readable representations of
weakest preconditions of Bitcoin scripts. This method is based on symbolic execution [29]
of the Bitcoin script, and investigating the sequence of case distinctions carried out during
the execution. We will consider three examples: The ﬁrst will be the P2PKH script which
we analysed already. We use it to explain the method and provide a second approach to
determine and verify the already obtained weakest precondition. The second example will
consider the multisig script which is a direct application of the OP_MULTISIG instruction.
The third example will see an application of a combination of both methods.

6.1 Example: P2PKH Script

When applying the symbolic evaluation method to the P2PKH script and analysing the
sequence of case distinctions carried out, we will see that there will be exactly one path through
the tree of case distinctions which results in an accepting condition. The conjunction of the
cases that determine this path will form the weakest precondition. In examples with more
than one accepting path we would take the disjunction of the conditions for each accepting
path.11 We will prove that the precondition is indeed the weakest by developing an equivalent
program p2pkhFunctionDecoded and showing that it fulﬁls the weakest precondition.

We start by declaring (using Agda’s postulate) symbolic values pbkh, msg1, stack1, x1, etc
for the parameters (postulates are typeset in blue). This allows us to evaluate expressions
up to executeStackVerify symbolically by using the normalisation procedure of Agda and
to determine the function p2pkhFunctionDecoded. (In Sect. 7 we will elaborate how to do
this practically in Agda). Afterwards, we stop using those postulates (they were deﬁned as
private) and prove that the result of evaluating the P2PKH script for arbitrary parameters is
equivalent to p2pkhFunctionDecoded.

When evaluating

scriptP2PKHb pbkh

s time1 msg1 stack1 we obtain

(cid:74)
executeStackDup stack1
ąą“
λ stack2 → executeOpHash stack2
ąą“
λ stack3 → executeStackEquality (pbkh :: stack3) ąą“

(cid:75)

11 In our examples we got only a few accepting paths, since concrete scripts in use are designed to deal
with a small number of diﬀerent scenarios for unlocking them, so the majority of paths in the program
are unsuccessful paths. It could happen however that with more advanced examples nested conditions
result in an exponential blowup of the number of cases – if that occurs one would need to take an
approach where the nested case distinctions are preserved at least partly and the resulting extracted
formulas reﬂect those nested case distinctions rather than ﬂattening them out. This would avoid the
blowup in the size of the resulting weakest precondition.

16

Veriﬁcation of Bitcoin Script in Agda

λ stack4 → executeStackVerify stack4
λ stack5 → executeStackCheckSig msg1 stack5

ąą“

We can write it equivalently using the do notation12

do stack2 ← executeStackDup stack1
stack3 ← executeOpHash stack2
stack4 ← executeStackEquality (pbkh :: stack3)
stack5 ← executeStackVerify stack4
executeStackCheckSig msg1 stack5

At this point further reduction is blocked by the ﬁrst line of the previous expression,
because executeStackDup stack1 makes a case distinction on stack1. Therefore, we introduce
a symbolic case distinction on stack1:

scriptP2PKHb pbkh
scriptP2PKHb pbkh

(cid:74)
(cid:74)
be written as

s time1 msg1 [] evaluates to nothing.
s time1 msg1 (pbk :: stack1) evaluates to what in do notation can

(cid:75)
(cid:75)

do stack5 ← executeStackVerify (compareNaturals pbkh (hashFun pbk) :: pbk :: stack1)

executeStackCheckSig msg1 stack5

Evaluation of the latter expression is blocked by the function executeStackVerify which makes
a case distinction on the expression compareNaturals pbkh (hashFun pbk). We deﬁne

abstrFun : (stack1 : Stack)(cmp : N) → Maybe Stack
abstrFun stack1 cmp = do stack5 ← executeStackVerify (cmp :: pbk :: stack1)

executeStackCheckSig msg1 stack5

scriptP2PKHb pbkh

hence
abstrFun stack1 (compareNaturals pbkh (hashFun pbk)).

s time1 msg1 (pbk :: stack1) evaluates to

(cid:74)

(cid:75)

Next we carry out a symbolic case distinction on the argument cmp of abstrFun:
abstrFun stack1 0 evaluates to nothing.
abstrFun stack1 (suc x1) evaluates to executeStackCheckSig msg1 (pbk :: stack1).

In order to normalise further, executeStackCheckSig needs to make a case distinction on

stack1, so we carry out a symbolic case distinction on that argument:

abstrFun [] (suc x1) evaluates to nothing.
abstrFun (sig1 :: stack1) (suc x1) evaluates to
just (boolToNat (isSigned msg1 sig1 pbk) :: stack1)

We can now read oﬀ the weakest precondition. The only path which ends up in a just

result is when the stack is non empty of the form pbk :: stack1, and
compareNaturals pbkh (hashFun pbk) evaluates to suc x1, i.e. it must be ą0. Furthermore, in
this case stack1 needs to be itself non empty. For stack1 “ sig1 :: stack2, the result returned
is just (boolToNat (isSigned msg1 sig1 pbk) :: stack1), which fulﬁls the accept condition if
boolToNat (isSigned msg1 sig1 pbk) ą 0. The latter is the case if
isSigned msg1 sig1 pbk is
true.

12 The do notation is a widely used Haskell notation adapted to Agda, which provides an alternative syntax
for the same expression making it appear as an imperative program if one reads ← as assignments. It
demonstrates that we are consecutively executing the instructions, with the possibility of aborting in
each step.

F. Alhabardi, A. Beckmann, B. Lazar, and A. Setzer

17

Furthermore, compareNaturals n m returns 1 if n, m are equal otherwise 0, so it is ą0
if n “ m. Therefore the P2PKH locking script succeeds with an output stack fulﬁlling
the acceptance condition, if and only if the input stack has height at least two, and if it is
pbk :: sig1 :: stack2, then pbkh is equal to hashFun pbk, and isSigned msg1 sig1 pbk is true.
That is the same as the weakest precondition that we determined using the ﬁrst approach.
In order to prove correctness, we ﬁrst determine a more Agda style formulation of the
result of evaluation of the P2PKH script, which we derive from the previous symbolic
evaluation:

p2pkhFunctionDecoded : (pbkh : N)(msg1 : Msg)(stack1 : Stack) → Maybe Stack
p2pkhFunctionDecoded pbkh msg1 []
p2pkhFunctionDecoded pbkh msg1 (pbk :: stack1) = p2pkhFunctionDecodedAux1 pbk msg1 stack1

= nothing

(compareNaturals pbkh (hashFun pbk))

p2pkhFunctionDecodedAux1 : (pbk : N)(msg1 : Msg)(stack1 : Stack)(cpRes : N) → Maybe Stack
p2pkhFunctionDecodedAux1 pbk msg1 []
p2pkhFunctionDecodedAux1 pbk msg1 (sig1 :: stack1) zero
p2pkhFunctionDecodedAux1 pbk msg1 (sig1 :: stack1) (suc cpRes) =

= nothing
= nothing

cpRes

just (boolToNat (isSigned msg1 sig1 pbk) :: stack1)

We prove that this function is equivalent to the result of evaluating the P2PKH script.

The proof is a simple case distinction following the cases deﬁning p2pkhFunctionDecoded:

p2pkhFunctionDecodedcor : (time1 : N) (pbkh : N)(msg1 : Msg)(stack1 : Stack)

scriptP2PKHb pbkh

→

(cid:74)

s time1 msg1 stack1 ” p2pkhFunctionDecoded pbkh msg1 stack1
(cid:75)

We show that the extracted weakest precondition is a correct for the extracted program:13

lemmaPTKHcoraux : (pbkh : N) → < weakestPreConditionP2PKHs pbkh >gs

(λ time msg1 s → p2pkhFunctionDecoded pbkh msg1 s)
< acceptStates >

Afterwards, this is transferred into a proof of the weakest precondition for the P2PKH

script, using the equality proof from before:

theoPTPKHcor : (pbkh : N) → < wPreCondP2PKH pbkh >if f scriptP2PKHb pbkh < acceptState >

Carrying out the symbolic execution was relatively easy, because Agda supports evaluation
of terms very well. It only becomes relatively long in the Agda code [47] when documenting
all the steps, which we did in order to explain how this is done in detail. What matters is
the resulting program and a prove that it is equivalent, which was relatively short and easy.
Maybe Agda’s reﬂection mechanism [3], once it is more fully developed, could be of help
to ﬁnd the successful branches of the program more easily. To obtain a readable program
rather than a machine generated program, and therefore readable veriﬁcation conditions,
would however require a lot of work, and probably require delegating some programming
tasks from Agda (in which tactics need to be written) to its foreign language interface.

13 <_>g_<_> is the generalisation of <_>if f _<_> where Bitcoin scripts are replaced by Agda functions
StackState → Maybe StackState; <_>gs_<_> is the version, where the StackState is unfolded into its
components.

18

Veriﬁcation of Bitcoin Script in Agda

6.2 Example: MultiSig Script (P2MS)

The OP_MULTISIG instruction is an instruction which has a more complex behaviour: It
assumes that the top elements of the stack are as follows:

n :: pbkn :: ¨ ¨ ¨ :: pbk2 :: pbk1 :: m :: sigm :: ¨ ¨ ¨ :: sig2 :: sig1 :: dummy

OP_MULTISIG checks whether the m signatures are signatures corresponding to m of the
n public keys for the msg to be signed, where the matching public keys are in the same order
as the signatures. Observe that when pushed from a script, the public keys and signatures
appear in reverse order on the stack, as pbk1 is pushed ﬁrst onto the stack, etc. The dummy
element occurs due to a mistake in the Bitcoin protocol, which has not been corrected as it
would require a hard fork [6, p. 151-152].

The operational semantics is given by a function executeMultiSig, which fetches the data
from the stack as described before. It fails if there are not enough elements on the stack
and otherwise returns just (boolToNat (cmpMultiSigs msg sigs pbks) :: restStack), where
sigs and pbks are the signatures and public keys fetched from the stack in reverse order,
and restStack is the remainder of the stack. The function cmpMultiSigs compares whether
signatures correspond to public keys and is deﬁned as follows:

cmpMultiSigs : (msg : Msg)(sigs pbks : List N) → Bool
cmpMultiSigs msg [] pubkeys
cmpMultiSigs msg (sig :: sigs) []
cmpMultiSigs msg (sig :: sigs) (pbk :: pbks) = cmpMultiSigsAux msg sigs pbks sig (isSigned msg sig pbk)

= true
= false

cmpMultiSigsAux : (msg : Msg)(sigs pbks : List N)(sig : N)(testRes : Bool) → Bool
cmpMultiSigsAux msg sigs pbks sig false
cmpMultiSigsAux msg sigs pbks sig true

= cmpMultiSigs msg (sig :: sigs) pbks
= cmpMultiSigs msg sigs pbks

We deﬁne now a generic multisig function. First we deﬁne opPushList, which pushes a

list of public keys on the stack:

opPushList : (pbkList : List N) → BitcoinScriptBasic
opPushList [] = []
opPushList (pbk1 :: pbkList) = opPush pbk1 :: opPushList pbkList

The m out of n multi-signature script P2MS (n “ length pbkList) is deﬁned as follows:

multiSigScriptm-nb : (m : N)(pbkList : List N)(m<n : m < length pbkList)

multiSigScriptm-nb m pbkList m<n =

→ BitcoinScriptBasic

opPush m :: (opPushList pbkList `` (opPush (length pbkList) :: [ opMultiSig ]))

The locking script MultiSig script P2MS applies OP_MULTISIG to m signatures and n
public keys. It pushes the number m of required signatures, then n public keys, and then
the number n as the number of public keys, onto the stack, and executes OP_MULTISIG. If
OP_MULTISIG ﬁnds that the m signatures are valid signature for the message to be signed for
m out of the n public keys in the same order as they appear in the list of public keys, then
the script will be unlocked. As unlocking script one can use opPushList applied to a list of m
appropriate signatures. In order to verify the script we will consider the concrete example of
the 2-out-of-4 P2MS, for which we obtain a very readable veriﬁcation condition (the generic
one becomes diﬃcult to read).

F. Alhabardi, A. Beckmann, B. Lazar, and A. Setzer

19

We will use the second approach of determining a readable form of the weakest precondition
and proving correctness by symbolic evaluation for the 2 out of 4 multiSigScript2-4b. The
ﬁrst approach is diﬃcult to carry out since the instruction opMultiSig has a very complex
precondition that is diﬃcult to handle – it requires that the stack contains the number
of public keys, then the public keys themselves, then the number of signatures and the
signatures, and a dummy element, where the number of public keys and number of signatures
can be arbitrary. It is much easier to handle the full multiSigScript2-4b script, since, after the
data has been inputted, the number of required signatures is known, and the public keys are
already provided by the script.

In order to demonstrate the ﬁrst approach we will instead, in Subsect. 6.3, apply the
step-by-step approach to a combined script, of which multiSigScript2-4b is one part. This
way we obtain a readable form of the weakest precondition and can then prove its correctness.
This will demonstrate that in some cases it is beneﬁcial to interleave the two processes, and
apply the second method to sequences of instructions while applying the ﬁrst approach to
the resulting sequences of instructions instead of single instructions.
We start the symbolic evaluation by computing the normal form of

multiSigScript2-4b pbk1 pbk2 pbk3 pbk4

s time1 msg1 stack1

(cid:74)

(cid:75)

and obtain
executeMultiSig3 msg1 (pbk1 :: pbk2 :: pbk3 :: [ pbk4 ]) 2 stack1 []
Here, executeMultiSig3 is one of the auxiliary functions in the deﬁnition of executeMultiSig.
That expression makes a case distinctions on stack1 and returns:

nothing when the stack has height at most 2 (obtained by evaluating it symbolically for
stacks of height 0, 1, 2).
Otherwise, the stack has height ě 3, and, if it is of the form sig2 :: sig1 :: dummy :: stack1,
it reduces to

just (boolToNat (cmpMultiSigsAux msg1 [ sig2 ] (pbk2 :: pbk3 :: [ pbk4 ]) sig1

(isSigned msg1 sig1 pbk1)) :: stack1)

The script has terminated, because we obtain just as a result of the evaluation. We now need
to check whether the result fulﬁls the accept condition. For this the top element of the stack
needs to be ą0, which is the case if
cmpMultiSigsAux msg1 [ sig2 ] (pbk2 :: pbk3 :: [ pbk4 ]) sig1(isSigned msg1 sig1 pbk1)
returns true. Therefore, we perform symbolic case distinctions in the following way:

In case isSigned msg1 sig1 pbk1 evaluates to true, i.e. if we replace that expression by
true, the reduction continues to
cmpMultiSigsAux msg1 [] (pbk3 :: [ pbk4 ]) sig2 (isSigned msg1 sig2 pbk2),
which makes a case distinction on isSigned msg1 sig2 pbk2.
If that expression returns again true, we obtain true.
If it returns false, we obtain
cmpMultiSigsAux msg1 [] [ pbk4 ] sig2 (isSigned msg1 sig2 pbk3)
which makes a case distinction on isSigned msg1 sig2 pbk3
∗ In case of true, we obtain true.
∗ Otherwise the case distinctions continue, see the git repository [47] for full details.

In total we see that we obtain true iﬀ one of the following cases holds:

(isSigned msg1 sig1 pbk1) ^ (isSigned msg1 sig2 pbk2)
(isSigned msg1 sig1 pbk1) ^ ¬ (isSigned msg1 sig2 pbk2) ^ (isSigned msg1 sig2 pbk3)
(isSigned msg1 sig1 pbk1) ^ ¬ (isSigned msg1 sig2 pbk2) ^
¬ (isSigned msg1 sig2 pbk3) ^ (isSigned msg1 sig2 pbk4)

20

Veriﬁcation of Bitcoin Script in Agda

. . . more cases.

These cases can be simpliﬁed to an equivalent disjunction of the following cases:
(isSigned msg1 sig1 pbk1) ^ (isSigned msg1 sig2 pbk2)
(isSigned msg1 sig1 pbk1) ^ (isSigned msg1 sig2 pbk3)
(isSigned msg1 sig1 pbk1) ^ (isSigned msg1 sig2 pbk4)
. . . more cases.

We obtain the following weakest precondition as a stack predicate:

weakestPreCondMultiSig-2-4s : (pbk1 pbk2 pbk3 pbk4 : N) → StackPredicate
weakestPreCondMultiSig-2-4s pbk1 pbk2 pbk3 pbk4 time msg1 [] = K
weakestPreCondMultiSig-2-4s pbk1 pbk2 pbk3 pbk4 time msg1 (x :: []) = K
weakestPreCondMultiSig-2-4s pbk1 pbk2 pbk3 pbk4 time msg1 (x :: y :: []) = K
weakestPreCondMultiSig-2-4s pbk1 pbk2 pbk3 pbk4 time msg1 ( sig2 :: sig1 :: dummy :: stack1) =

( (IsSigned msg1 sig1 pbk1 ^ IsSigned msg1 sig2 pbk2) Z
(IsSigned msg1 sig1 pbk1 ^ IsSigned msg1 sig2 pbk3) Z
(IsSigned msg1 sig1 pbk1 ^ IsSigned msg1 sig2 pbk4) Z
(IsSigned msg1 sig1 pbk2 ^ IsSigned msg1 sig2 pbk3) Z
(IsSigned msg1 sig1 pbk2 ^ IsSigned msg1 sig2 pbk4) Z
(IsSigned msg1 sig1 pbk3 ^ IsSigned msg1 sig2 pbk4))

It expresses that the stack must have height at least 3, and if it is of the form sig2 :: sig1
:: dummy :: stack1 then the signatures need to correspond to 2 out of the 4 public keys in
the same order as the public keys. Using the same case distinctions as they occurred in the
symbolic evaluation above we can now prove:

theoremCorrectnessMultiSig-2-4 : (pbk1 pbk2 pbk3 pbk4 : N)

→ < stackPred2SPred (weakestPreCondMultiSig-2-4s pbk1 pbk2 pbk3 pbk4) >if f

multiSigScript2-4b pbk1 pbk2 pbk3 pbk4
< stackPred2SPred acceptStates >

From the theorem above, we have obtained a readable weakest precondition by symbolic
execution, which will be used as a starting template for developing a generic veriﬁcation.
The next step would be to generalise the veriﬁcation conditions and theorems to the generic
case, however that would go beyond the scope of the current paper.

6.3 Example: Combining the two Methods

In this subsection we show how to verify a combined script which consists of a simple script
checking a certain amount of time has passed and the multisig script from the previous
subsection. To determine a readable form of the weakest precondition and proving correctness
we will combine both of our techniques: The weakest precondition for the multisig script has
been determined by symbolic evaluation in the previous subsection. The weakest precondition
for the simple time checking script will be obtained directly, as it is very simple. When we
consider the combined scripts we will use the ﬁrst method of moving backwards step-by-step.
However, instead of using single instructions in each step, we now use several instructions as
a single step.

We deﬁne the checktime script as follows:

checkTimeScriptb : (time1 : Time) → BitcoinScriptBasic
checkTimeScriptb time1 = (opPush time1) :: opCHECKLOCKTIMEVERIFY :: [ opDrop ]

F. Alhabardi, A. Beckmann, B. Lazar, and A. Setzer

21

If we deﬁne

timeCheckPreCond : (time1 : Time) → StackPredicate
timeCheckPreCond time1 time2 msg stack1 = time1 ď time2

we can deﬁne its weakest precondition relative to a post condition φ only aﬀecting the

stack as in the following theorem:

theoremCorrectnessTimeCheck : (φ : StackPredicate)(time1 : Time)

→ < stackPred2SPred (timeCheckPreCond time1 ^sp φ) >if f checkTimeScriptb time1

< stackPred2SPred φ >

Now we can determine the weakest precondition for the combined script and prove its

correctness as follows:

theoremCorrectnessCombinedMultiSigTimeCheck : (time1 : Time) (pbk1 pbk2 pbk3 pbk4 : N)

→ < stackPred2SPred ( timeCheckPreCond time1 ^sp

weakestPreCondMultiSig-2-4s pbk1 pbk2 pbk3 pbk4) >if f

checkTimeScriptb time1 `` multiSigScript2-4b pbk1 pbk2 pbk3 pbk4
< acceptState >

theoremCorrectnessCombinedMultiSigTimeCheck time1 pbk1 pbk2 pbk3 pbk4 =

stackPred2SPred (timeCheckPreCond time1 ^sp

weakestPreCondMultiSig-2-4s pbk1 pbk2 pbk3 pbk4)

<><>〈 checkTimeScriptb time1 〉〈 theoremCorrectnessTimeCheck

(weakestPreCondMultiSig-2-4s pbk1 pbk2 pbk3 pbk4) time1 〉

stackPred2SPred (weakestPreCondMultiSig-2-4s pbk1 pbk2 pbk3 pbk4)

<><>〈 multiSigScript2-4b pbk1 pbk2 pbk3 pbk4

〉〈 theoremCorrectnessMultiSig-2-4 pbk1 pbk2 pbk3 pbk4 〉e

stackPred2SPred acceptStates ‚p

The weakest precondition states that the state time is ě time1, and that the weakest
precondition for the multisig script is fulﬁlled (^sp forms the conjunction of the two condi-
tions). For proving it we used a combination of both methods, the second method was used
to determine preconditions for the two parts of the scripts, and the ﬁrst method, where we
used whole scripts instead of basic instructions, was used to determine the combined weakest
precondition.

7 Using Agda to Determine Readable Weakest Preconditions

Our library provides the operational semantics for (a subset of) Bitcoin script, and a
framework for specifying and reasoning about weakest preconditions. The Agda user has to
specify the script to be veriﬁed, and then consider suitable pieces of the speciﬁed script and
provide weakest preconditions. Agda will then create goals, which are unimplemented holes
in the code. Agda will display the type of goals and list of assumptions available for solving
them, and provide considerable additional support for resolving those goals. For instance, it
allows to reﬁne partial solutions provided by the user by applying it to suﬃciently many new
goals. Agda will as well automatically create case distinctions (such as whether an element
of type Maybe is just or nothing). Agda can solve goals if the solution is unique and can
be found in a direct way. Agda’s automated theorem proving support for ﬁnding solutions
which are not unique is not very strong due to the high complexity of the language.

22

Veriﬁcation of Bitcoin Script in Agda

Agda Reﬂection [3] is an ongoing project which already now provides a considerable
library for inspecting code inside a goal and computing solutions as Agda code. The aim
is to provide something similar to Coq’s tactic language. In our code we frequently had to
consider a nested case distinction for proving a goal, where most cases were solved because
at one point one of the arguments became an element of the empty type. Automating this
using Agda Reﬂection would make it much easier to use our library.

Finding a description of the weakest precondition has to be done manually at the moment.
We plan to create a library which computes such descriptions for instructions or small pieces
of instructions. Sometimes it is easier to provide weakest precondition for small pieces of code,
for instance in case of the multisig instruction the weakest precondition for the instruction
itself is very complex, whereas the weakest precondition for the P2MS script is much easier to
display. Deﬁning and simplifying the weakest preconditions in the intermediate steps has to
be been done manually at the moment. Proofs have to be done manually in Agda, but they
are relatively easy because of Agda’s support for developing proofs. It would be desirable
to have a more automated support, where the user only needs to specify the veriﬁcation
conditions, but proofs are carried out automatically. In general our impression is that for
writing programs and specifying veriﬁcation conditions Agda is very suitable: one obtains
code which is very readable and close to standard mathematical notations. Where Agda is
lacking is in providing support for machine assisted proofs of the resulting conditions.

Regarding the question, which of the two approaches to use (working backwards step-by-
step or using symbolic evaluation), we have only some heuristics at the moment. A good
approach is that for pieces of code, where one has an intuition what the underlying program
written in Agda could be, the symbolic evaluation is more suitable. For longer code, a good
strategy is to cut the code into suitable pieces, for which one can ﬁnd a symbolic program
and weakest preconditions, and then work oneself backwards using the ﬁrst approach starting
from the acceptance condition. Note that symbolic execution can be done very fast: The
user postulates variables for the arguments, applies the functions to be evaluated to those
postulated arguments and then executes Agda’s normalisation mechanism. Then the user
needs to manually inspect the result to see which sub expression trigger the case distinction.
It would be nice project to develop a procedure which automates that process of symbolic
execution – this could be applicable to veriﬁcation of other kinds of programs as well.

8

Conclusion

In this paper, we have implemented and tested two methods for developing human-readable
weakest preconditions and proving their correctness. These methods can help smart contract
developers to ﬁll the validation gap between user requirements and formal speciﬁcation. We
have argued that weakest preconditions in Hoare logic is the correct notion for specifying
the security property of access control. We have applied our approaches to P2PKH, P2MS,
and a combination of P2MS with a time lock. The whole approach has been formalised in
Agda [47].

In future work, we will treat non-local instructions such as OP_IF, OP_ELSE, and OP_ENDIF,
and will formalise key instructions to extend our approach to the whole of Bitcoin script. The
diﬃculty is nesting of conditionals, and that Bitcoin scripts are not structured, and therefore
some additional work needs to be done to ﬁnd the matching of if-then-else instructions.
In our approach we will use an expanded state space for dealing with those conditionals.
Moreover, we plan to expand our library to support ﬁnding weakest preconditions for scripts
having conditionals in a modular way. Furthermore, we plan the make the process of script

F. Alhabardi, A. Beckmann, B. Lazar, and A. Setzer

23

veriﬁcation more user-friendly by using a text parser that can record the instructions used
for veriﬁcation.

In addition, we aim to generalise the veriﬁcation of P2MS to arbitrary m out of n
multiscripts, where the challenge is ﬁnding a suitable generic human-readable weakest
precondition.

Another route for future research is to develop our approach into a framework for
developing smart contracts that are correct by construction. One way to build such smart
contracts is to use Hoare Type Theory [27, 39].

24

Veriﬁcation of Bitcoin Script in Agda

References

1 Adacore. SPARK 2014, Retrieved 9 November 2021. https://www.adacore.com/about-spark.
2 Agda Team. Agda documentation, Retrieved 21 April 2022. URL: https://agda.readthedocs.

io/en/latest/index.html.

3 Agda Team. Agda Reﬂection, Retrieved 21 April 2022. URL: https://agda.readthedocs.

io/en/latest/language/reflection.html.

5

4 Mouhamad Almakhour, Layth Sliman, Abed Ellatif Samhat, and Abdelhamid Mellouk.
Veriﬁcation of smart contracts: A survey. Pervasive and Mobile Computing, 67:1–19, 2020.
doi:http://dx.doi.org/10.1016/j.pmcj.2020.101227.
Sidney Amani, Myriam Bégel, Maksym Bortin, and Mark Staples. Towards Verifying Ethereum
In Proceedings of the 7th ACM SIGPLAN
Smart Contract Bytecode in Isabelle/HOL.
International Conference on Certiﬁed Programs and Proofs, CPP 2018, page 66–77, New York,
NY, USA, 2018. Association for Computing Machinery. doi:https://doi.org/10.1145/
3167084.

6 Andreas M Antonopoulos. Mastering Bitcoin: Programming the open blockchain. " Second ed.

O’Reilly Media, Inc.", 2017.

7 Nicola Atzei, Massimo Bartoletti, Stefano Lande, and Roberto Zunino. A formal model of bit-
coin transactions. In Financial Cryptography and Data Security, pages 541–560, Berlin, Heidel-
berg, 2018. Springer Berlin Heidelberg. doi:https://doi.org/10.1007/978-3-662-58387-6_
29.

8 Massimo Bartoletti and Roberto Zunino. BitML: A Calculus for Bitcoin Smart Contracts. In
Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security,
CCS ’18, page 83–100, New York, NY, USA, 2018. Association for Computing Machinery.
doi:http://dx.doi.org/10.1145/3243734.3243795.

9 Bruno Bernardo, Raphaël Cauderlier, Zhenlei Hu, Basile Pesin, and Julien Tesson. Mi-Cho-
Coq, a Framework for Certifying Tezos Smart Contracts.
In Formal Methods. FM 2019
International Workshops, pages 368–379, Cham, 2020. Springer International Publishing.
doi:https://doi.org/10.1007/978-3-030-54994-7_28.

10 Karthikeyan Bhargavan, Antoine Delignat-Lavaud, Cédric Fournet, Anitha Gollamudi, Georges
Gonthier, Nadim Kobeissi, Natalia Kulatova, Aseem Rastogi, Thomas Sibut-Pinote, Nikhil
Swamy, and Santiago Zanella-Béguelin. Formal Veriﬁcation of Smart Contracts: Short Paper.
In Proceedings of the 2016 ACM Workshop on Programming Languages and Analysis for
Security, PLAS ’16, page 91–96, New York, NY, USA, 2016. Association for Computing
Machinery. doi:http://dx.doi.org/10.1145/2993600.2993611.
Bitcoin Community. Welcome to the Bitcoin Wiki. Availabe from https://en.bitcoin.it/
wiki/Script, 2010.

11

12 Ana Bove, Peter Dybjer, and Ulf Norell. A Brief Overview of Agda – A Functional Language
with Dependent Types. In Theorem Proving in Higher Order Logics, pages 73–7, Berlin, Heidel-
berg, 2009. Springer Berlin Heidelberg. doi:https://doi.org/10.1007/978-3-642-03359-9_
6.

13 Vitalik Buterin. Ethereum: A next-generation smart contract and decentralized application

platform, 2014. URL: https://ethereum.org/en/whitepaper.

14 Manuel M. T. Chakravarty, James Chapman, Kenneth MacKenzie, Orestis Melkonian, Jann
Müller, Michael Peyton Jones, Polina Vinogradova, and Philip Wadler. Native Custom Tokens
in the Extended UTXO Model. In Leveraging Applications of Formal Methods, Veriﬁcation
and Validation: Applications, pages 89–111, Cham, 2020. Springer International Publishing.
doi:https://doi.org/10.1007/978-3-030-61467-6_7.

15 Manuel M. T. Chakravarty, James Chapman, Kenneth MacKenzie, Orestis Melkonian, Jann
Müller, Michael Peyton Jones, Polina Vinogradova, Philip Wadler, and Joachim Zahnentferner.
UTXOma: UTXO with Multi-asset Support. In Leveraging Applications of Formal Methods,
Veriﬁcation and Validation: Applications, pages 112–130, Cham, 2020. Springer International
Publishing. doi:https://doi.org/10.1007/978-3-030-61467-6_8.

F. Alhabardi, A. Beckmann, B. Lazar, and A. Setzer

25

16 Manuel M. T. Chakravarty, James Chapman, Kenneth MacKenzie, Orestis Melkonian, Michael
Peyton Jones, and Philip Wadler. The Extended UTXO Model. In Financial Cryptography
and Data Security, pages 525–539, Cham, 2020. Springer International Publishing.
James Chapman, Roman Kireev, Chad Nester, and Philip Wadler. System F in Agda, for Fun
and Proﬁt. In Mathematics of Program Construction, pages 255–297, Cham, 2019. Springer
International Publishing. doi:https://doi.org/10.1007/978-3-030-33636-3_10.

17

Is

20

19

any

there

famous protocol

18 Martin Churchill, Peter D. Mosses, Neil Sculthorpe, and Paolo Torrini. Reusable components
of semantic speciﬁcations. In Shigeru Chiba, Éric Tanter, Erik Ernst, and Robert Hirschfeld,
editors, Transactions on Aspect-Oriented Software Development XII, pages 132–179, Berlin,
Heidelberg, 2015. Springer Berlin Heidelberg. doi:10.1007/978-3-662-46734-3_4.
Edmund M. Clarke and Jeannette M. Wing. Formal methods: State of the art and future
directions. ACM Comput. Surv., 28(4):626–643, dec 1996. doi:https://doi.org/10.1145/
242223.242257.
crypto.stackexchange.
that were proven se-
cure but whose proof was wrong and lead to real world attacks?, Retrieved
22 April
https://crypto.stackexchange.com/questions/98829/
is-there-any-famous-protocol-that-were-proven-secure-but-whose-proof-was-wrong-a.
Peter D and Mosses. Modular structural operational semantics. Journal of Logic and Algebraic
Programming, 60-61(0):195 – 228, 2004. URL: http://www.sciencedirect.com/science/
article/pii/S156783260400027X, doi:10.1016/j.jlap.2004.03.008.
Edsger W. Dijkstra. Guarded commands, nondeterminacy and formal derivation of programs.
Commun. ACM, 18(8):453–457, aug 1975. doi:https://doi.org/10.1145/360933.360975.
Etherscan. TheDAO smart contract 2016, Retrieved 27 March 2022. Availabe from http:
//etherscan.io/address/0xbb9bc244d798123fde783fcc1c72d3bb8c189413#code.
Jean-Christophe Filliâtre and Andrei Paskevich. Why3 — Where Programs Meet Provers.
In Programming Languages and Systems, pages 125–128, Berlin, Heidelberg, 2013. Springer
Berlin Heidelberg. doi:https://doi.org/10.1007/978-3-642-37036-6_8.

URL:

2022.

22

21

24

23

26

27

25 Yoichi Hirai. Deﬁning the Ethereum Virtual Machine for Interactive Theorem Provers. In
Financial Cryptography and Data Security, pages 520–535, Cham, 2017. Springer International
Publishing. doi:https://doi.org/10.1007/978-3-319-70278-0_33.
C. A. R. Hoare. An axiomatic basis for computer programming. Communications of the ACM,
12(10):576 – 585, October 1969. doi:10.1145/363235.363259.
IMDEA Software Institute. HTT: Hoare Type Theory, 10 March 2015. Available from
https://software.imdea.org/~aleks/htt/.
Sukrit Kalra, Seep Goel, Mohan Dhawan, and Subodh Sharma. ZEUS: Analyzing Safety of
Smart Contracts. In 25th Annual Network and Distributed System Security Symposium, NDSS
2018, San Diego, California, USA, February 18-21, 2018, pages 1–15. The Internet Society,
2018. doi:http://dx.doi.org/10.14722/ndss.2018.23082.
James C. King. Symbolic execution and program testing. Commun. ACM, 19(7):385–394,
July 1976. doi:10.1145/360248.360252.

28

29

31

30 Rick Klomp and Andrea Bracciali. On Symbolic Veriﬁcation of Bitcoin’s script Lan-
guage. In Data Privacy Management, Cryptocurrencies and Blockchain Technology, pages
38–56, Cham, 2018. Springer International Publishing. doi:https://doi.org/10.1007/
978-3-030-00305-0_3.
Loi Luu, Duc-Hiep Chu, Hrishi Olickel, Prateek Saxena, and Aquinas Hobor. Making Smart
Contracts Smarter. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and
Communications Security, CCS ’16, page 254–269, New York, NY, USA, 2016. Association for
Computing Machinery. doi:http://dx.doi.org/10.1145/2976749.2978309.
Luiz Eduardo G. Martins and Tony Gorschek. Requirements engineering for safety-critical
systems: Overview and challenges. IEEE Software, 34(4):49–57, 2017. doi:10.1109/MS.2017.
94.

32

26

Veriﬁcation of Bitcoin Script in Agda

33 Anastasia Mavridou, Aron Laszka, Emmanouela Stachtiari, and Abhishek Dubey. VeriSolid:
In Financial Cryptography and Data

Correct-by-Design Smart Contracts for Ethereum.
Security, pages 446–465, Cham, 2019. Springer International Publishing.

34 Orestis Melkonian. Formalizing BitML Calculus in Agda, 2019. Student Research Competi-
tion, Poster Session, ICFP’19. URL: https://omelkonian.github.io/data/publications/
formal-bitml.pdf.

35 Orestis Melkonian. Formalizing Extended UTxO and BitML Calculus in Agda. Master’s thesis,
Utrecht University, Department of Information and Computing Sciences, July 2019. URL:
https://studenttheses.uu.nl/handle/20.500.12932/32981.

36 Dominic P. Mulligan, Scott Owens, Kathryn E. Gray, Tom Ridge, and Peter Sewell. Lem:
Reusable engineering of real-world semantics. ACM SIGPLAN Notices, 49(9):175–188, Aug
2014. doi:https://doi.org/10.1145/2692915.2628143.

37 Yvonne Murray and David A. Anisi. Survey of Formal Veriﬁcation Methods for Smart Contracts
on Blockchain. In 2019 10th IFIP International Conference on New Technologies, Mobility and
Security (NTMS), pages 1–6, 2019. doi:http://dx.doi.org/10.1109/NTMS.2019.8763832.
Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. Decentralized Business
Review, 2008. URL: https://www.debr.io/article/21260.pdf.

38

39 Nanevski, Aleksandar and Vafeiadis, Viktor and Berdine, Josh. Structuring the Veriﬁcation
of Heap-Manipulating Programs. SIGPLAN Not., 45(1):261–274, jan 2010. doi:https:
//doi.org/10.1145/1707801.1706331.

40 Ulf Norell. Dependently typed programming in Agda.

In Advanced Functional Pro-
gramming: 6th International School, AFP 2008, Heijen, The Netherlands, May 2008,
Revised Lectures, pages 230–266, Berlin, Heidelberg, 2009. Springer Berlin Heidelberg.
doi:10.1007/978-3-642-04652-0_5.

41 Russell O’Connor. Simplicity: A new language for blockchains. In Proceedings of the 2017
Workshop on Programming Languages and Analysis for Security, PLAS ’17, page 107–120,
New York, NY, USA, 2017. Association for Computing Machinery. doi:https://doi.org/10.
1145/3139337.3139340.

42 Daejun Park, Yi Zhang, Manasvi Saxena, Philip Daian, and Grigore Roşu. A Formal
Veriﬁcation Tool for Ethereum VM Bytecode. In Proceedings of the 2018 26th ACM Joint
Meeting on European Software Engineering Conference and Symposium on the Foundations of
Software Engineering, ESEC/FSE 2018, page 912–915, New York, NY, USA, 2018. Association
for Computing Machinery. doi:http://dx.doi.org/10.1145/3236024.3264591.

43 Christine Paulin-Mohring. Introduction to the Coq Proof-Assistant for Practical Software
Veriﬁcation, pages 45–95. Springer Berlin Heidelberg, Berlin, Heidelberg, 2012. doi:http:
//dx.doi.org/10.1007/978-3-642-35746-6_3.
Elizabeth D. Rather, Donald R. Colburn, and Charles H. Moore. The Evolution of Forth,
page 625–670. Association for Computing Machinery, New York, NY, USA, 1996. doi:https:
//doi.org/10.1145/234286.1057832.

44

45 Maria Ribeiro, Pedro Adão, and Paulo Mateus. Formal Veriﬁcation of Ethereum Smart
Contracts Using Isabelle/HOL, pages 71–97. Springer International Publishing, Cham, 2020.
doi:https://doi.org/10.1007/978-3-030-62077-6_7.

46 Anton Setzer. Modelling Bitcoin in Agda. CoRR, abs/1804.06398, 2018. URL: http:

//arxiv.org/abs/1804.06398, arXiv:1804.06398.

48

47 Anton Setzer, Fahad Alhabardi,

and Bogdan Lazar.

Veriﬁcation Of Smart
from https://github.com/fahad1985lab/

Available

Contracts With Agda.
Smart--Contracts--Verification--With--Agda, 2021.
Stack Exchange Inc.
provable security - Is there any famous protocol that were
proven secure but whose proof was wrong and lead to real world attacks? , Retrieved
22 April 2022. Availabe from https://crypto.stackexchange.com/questions/98829/
is-there-any-famous-protocol-that-were-proven-secure-but-whose-proof-was-wrong-a.

F. Alhabardi, A. Beckmann, B. Lazar, and A. Setzer

27

49

Philip Wadler, Wen Kokke, and Jeremy G. Siek. Programming Language Foundations in Agda.
Online textbook, July 2020. URL: https://plfa.github.io/Equality/.

50 Maximilian Wohrer and Uwe Zdun. Smart Contracts: Security Patterns in the Ethereum
Ecosystem and Solidity. In 2018 International Workshop on Blockchain Oriented Software
Engineering (IWBOSE), pages 2–8, 2018. doi:http://dx.doi.org/10.1109/IWBOSE.2018.
8327565.

