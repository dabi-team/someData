1
2
0
2

n
u
J

8
1

]

C
D
.
s
c
[

1
v
2
6
3
0
1
.
6
0
1
2
:
v
i
X
r
a

Jolteon and Ditto: Network-Adaptive Efﬁcient Consensus with Asynchronous
Fallback

Rati Gelashvili
Novi Research

Lefteris Kokoris-Kogias
Novi Research & IST Austria

Alberto Sonnino
Novi Research

Alexander Spiegelman
Novi Research

Zhuolun Xiang∗
University of Illinois at Urbana-Champaign

Abstract

Existing committee-based Byzantine state machine repli-
cation (SMR) protocols, typically deployed in production
blockchains, face a clear trade-off: (1) they either achieve
linear communication cost in the happy path, but sacriﬁce
liveness during periods of asynchrony, or (2) they are robust
(progress with probability one) but pay quadratic communi-
cation cost. We believe this trade-off is unwarranted since
existing linear protocols still have asymptotic quadratic cost
in the worst case.

We design Ditto, a Byzantine SMR protocol that enjoys
the best of both worlds: optimal communication on and off the
happy path (linear and quadratic, respectively) and progress
guarantee under asynchrony and DDoS attacks. We achieve
this by replacing the view-synchronization of partially syn-
chronous protocols with an asynchronous fallback mechanism
at no extra asymptotic cost. Speciﬁcally, we start from Hot-
Stuff, a state-of-the-art linear protocol, and gradually build
Ditto. As a separate contribution and an intermediate step,
we design a 2-chain version of HotStuff, Jolteon, which
leverages a quadratic view-change mechanism to reduce the
latency of the standard 3-chain HotStuff.

We implement and experimentally evaluate all our sys-
tems. Notably, Jolteon’s commit latency outperforms Hot-
Stuff by 200-300ms with varying system size. Additionally,
Ditto adapts to the network and provides better performance
than Jolteon under faulty conditions and better performance
than VABA (a state-of-the-art asynchronous protocol) under
faultless conditions. This proves our case that breaking the
robustness-efﬁciency trade-off is in the realm of practicality.

1 Introduction

The popularity of blockchain protocols has generated a surge
in researching how to increase the efﬁciency and robustness
of underlying consensus protocols used for agreement. On the

∗Lead author, part of work was done at Novi Research

efﬁciency front, the focus has been on decreasing the commu-
nication complexity in the steady state (“happy path”), ﬁrst to
quasilinear [19] and ultimately to linear [15, 38]. These proto-
cols work in the eventually synchronous model and require a
leader to aggregate proofs. However, handling leader failures
or unexpected network delays requires quadratic communica-
tion and if the network is asynchronous, there is no liveness
guarantee. On the robustness side, recent protocols [2, 24, 35]
make progress by having each replica act as the leader and
decide on a leader retroactively. This inherently requires
quadratic communication even under good network condi-
tions.

We believe that in practice, we need the best of both worlds.
An efﬁcient happy path is beneﬁcial for any production sys-
tem, but for blockchains to support important (e.g. ﬁnancial)
infrastructure, robustness against asynchrony is also key. First,
unpredictable network delays are a common condition when
running in a large-scale network environment, e.g. over the
Internet. Second, the possibility of targeted DDoS attacks on
the leaders of leader-based protocols motivates the leaderless
nature of the asynchronous solutions. Thus, we are interested
if there are efﬁcient systems that have a linear happy path and
are robust against asynchrony.

This is an important question, posed as early as [22],
and studied from a theoretical prospective [30, 34], but the
existing blockchain systems still forfeit robustness for ef-
ﬁciency [15, 19, 38].
In this paper, we answer the above
question with the ﬁrst practical system, tailor-made to di-
rectly apply to the prominent HotStuff/DiemBFT [36, 38]
family of protocols. Our protocol, Ditto, combines the op-
timistic (good network conditions) efﬁcient happy path with
pessimistic (worst-case network conditions) liveness guaran-
tees with no extra asymptotic communication cost. Ditto is
based on the key observation that when there is asynchrony
or failures, the protocols with linear happy path still pay the
quadratic cost, same as state-of-the-art asynchronous proto-
cols (e.g., VABA [2] or Dumbo [24]) that provide signiﬁcantly
more robustness. Speciﬁcally, Ditto replaces the pacemaker
of HotStuff/DiemBFT (a quadratic module that deals with

1

 
 
 
 
 
 
HotStuff [38]/DiemBFT [36]
VABA [2]

partially sync SMR
async BA

sync O(n)
O(n2)

Problem

Comm. Complexity

Rounds

7
E(16.5)

Liveness

not live if async
always live

Jolteon
Ditto

partially sync SMR
async SMR with fast sync path

sync O(n)
sync O(n), async O(n2)

5
sync 5, async E(10.5)

not live if async
always live

Table 1: Theoretical comparison of our protocol implementations. For HotStuff/DiemBFT and our protocols, sync O(n) assumes
honest leaders. Rounds measure the block-commit latency. E(r) means r rounds in expectation.

view synchronization) with an asynchronous fallback.

In other words, instead of synchronizing views that will
anyway fail (timeout) due to asynchrony or faults, we fall back
to an asynchronous protocol that robustly guarantees progress
at the cost of a single view-change. Furthermore, Ditto
switches between the happy path and the fallback without
overhead (e.g. additional rounds), and continues operating in
the same pipelined fashion as HotStuff/DiemBFT.

Leveraging our observation further, we abandon the lin-
ear view-change [38] of HotStuff/DiemBFT, since the pro-
tocol anyway has a quadratic pacemaker [36]. We present
Jolteon, a protocol that’s a hybrid of HotStuff [38] and clas-
sical PBFT [9]. In particular, Jolteon preserves the structure
of HotStuff and its linearity under good network conditions
while reducing the steady state block-commit latency by 30%
using a 2-chain commit rule. This decrease in latency comes
at the cost of a quadratic view-change (O(n) messages of O(n)
size). As the pacemaker is already quadratic, as expected, this
does not affect performance in our experiments. We shared
our ﬁndings with the Diem Team who is currently integrating
Jolteon into the next release of DiemBFT.

Since Jolteon outperforms the original HotStuff in every
scenario, we use it as the basis for Ditto. As shown experi-
mentally under optimistic network conditions both Jolteon
and Ditto outperform HotStuff block-commit latency. Impor-
tantly, Ditto’s performance is almost identical to Jolteon in
this case whereas during attack Ditto performs almost identi-
cally to our optimized implementation of VABA [2]. Finally,
the throughput of Ditto is 50% better than VABA in the opti-
mistic path and much better than HotStuff and Jolteon under
faulty (dead) leaders (30-50% better) or network instability
(they drop to 0).

In Table 1 we show a theoretical comparison of our work
to HotStuff and VABA, for which we implement and evaluate
the performance experimentally in Section 6. More compre-
hensive comparisons and related work are given in Section 7.

2 Preliminaries

We consider a permissioned system that consists of an adver-
sary and n replicas numbered 1, 2, . . . , n, where each replica
has a public key certiﬁed by a public-key infrastructure (PKI).
The replicas have all-to-all reliable and authenticated com-

munication channels controlled by the adversary. We say a
replica multicasts a message if it sends the message to all
replicas. We consider a dynamic adversary that can adap-
tively corrupt up to f replicas, referred as Byzantine. The
rest of the replicas are called honest. The adversary controls
the message delivery times, but we assume messages among
honest replicas are eventually delivered.

An execution of a protocol is synchronous if all message
delays between honest replicas are bounded by ∆; is asyn-
chronous if they are unbounded; and is partially synchronous
if there is a global stabilization time (GST) after which they
are bounded by ∆ [11]. Without loss of generality, we let
n = 3 f + 1 where f denotes the assumed upper bound on the
number of Byzantine faults, which is the optimal worst-case
resilience bound for asynchrony, partial synchrony [11], or
asynchronous protocols with fast synchronous path [4].

Cryptographic primitives and assumptions. We assume
standard digital signature and public-key infrastructure (PKI),
and use (cid:104)m(cid:105)i to denote a message m signed by replica i. We
also assume a threshold signature scheme, where a set of
signature shares for message m from t (the threshold) distinct
replicas can be combined into one threshold signature of the
same length for m. We use {m}i to denote a threshold signa-
ture share of a message m signed by replica i. We also assume
a collision-resistant cryptographic hash function H(·) that
can map an input of arbitrary size to an output of ﬁxed size.
For simplicity of presentation, we assume the above crypto-
graphic schemes are ideal and a trusted dealer equips replicas
with these cryptographic materials. The dealer assumption
can be lifted using the protocol of [20].

Any deterministic agreement protocol cannot tolerate even
a single fault under asynchrony due to FLP [12]. Our asyn-
chronous fallback protocol generates distributed randomness
following the approach of [8]: the generated randomness of
any given view is the hash of the unique threshold signature
on the view number.

BFT SMR. A Byzantine fault-tolerant state machine repli-
cation protocol [9] commits client transactions as a log akin
to a single non-faulty server, and provides the following two
guarantees:
• Safety. Honest replicas do not commit different transactions

at the same log position.

• Liveness. Each client transaction is eventually committed

2

by all honest replicas.

Besides these two requirements, a validated BFT SMR
protocol must also satisfy external validity [7], requiring all
committed transactions to be externally valid, i.e. satisfying
some application-dependent predicate. This can be accom-
plished by adding validity checks on the transactions before
the replicas propose or vote, and for brevity, we omit the de-
tails and focus on the BFT SMR formulation deﬁned above.
We assume that each client transaction will be repeatedly pro-
posed by honest replicas until it is committed1. For most of
the paper, we omit the client from the discussion and focus
on replicas.

SMR protocols usually implement many instances of
single-shot Byzantine agreement, but there are various ap-
proaches for ordering. We focus on the chaining approach,
used in HotStuff [38] and DiemBFT [36], in which each pro-
posal references the previous one and each commit commits
the entire preﬁx of the chain.

2.1 Terminology

We present the terminology used throughout the paper.
• Round Number and View Number. The protocol proceeds
in rounds and views and each replica keeps track of the
current round number rcur and view number vcur, which are
initially set to 0. Each view can have several rounds and it
is incremented by 1 after each asynchronous fallback. Each
round r has a designated leader Lr that proposes a new block
(deﬁned below) of transactions in round r. Since DiemBFT
and Jolteon (Section 3) do not have an asynchronous fall-
back, the view number is always 0, but it is convenient to
deﬁne it here so that our Ditto protocol (Section 4) uses
the same terminology.

• Block Format. A block is formatted as B = [id, qc, r, v,txn]
where qc is the quorum certiﬁcate (deﬁned below) of B’s
parent block in the chain, r is the round number of B, v is the
view number of B, txn is a batch of new transactions, and
id = H(qc, r, v,txn) is the unique hash digest of qc, r, v,txn.
Note that when describing the protocol, it sufﬁces to spec-
ify qc, r, and v for a new block, since txn, id follow the
deﬁnitions. We will use B.x to denote the element x of B.
• Quorum Certiﬁcate. A quorum certiﬁcate (QC) of some
block B is a threshold signature of a message that includes
B.id, B.r, B.v, produced by combining the signature shares
{B.id, B.r, B.v} from a quorum of n − f = 2 f + 1 replicas.
We say a block is certiﬁed if there exists a QC for the
block. Blocks are chained by QCs to form a blockchain, or
block-tree if there are forks The round and view numbers
of QC for block B are denoted by QC.r and QC.v, which
equals B.r and B.v, respectively. A QC or a block of view

1For example, clients can send their transactions to all replicas, and the
leader can propose transactions that are not yet included in the blockchain, in
the order that they are submitted. With rotating leaders of HotStuff/DiemBFT
and random leader election of the asynchronous fallback, the assumption can
be guaranteed.

number v and round number r has rank rank = (v, r), and
QCs or blocks are compared lexicographically by their rank
(i.e. ﬁrst by the view number, then by the round num-
ber). The function max(rank1, rank2) returns the higher
rank between rank1 and rank2, and max(qc1, qc2) returns
the higher (ranked) QC between qc1 and qc2. In DiemBFT
and Jolteon (Section 3) the view number is always 0, so
QCs or blocks are compared by their round numbers; while
in Ditto (section 4) they are compared by their rank.

• Timeout Certiﬁcate. A timeout message of round r by a
replica contains the replica’s threshold signature share on
r, and its qchigh. A timeout certiﬁcate (TC) is formed by
a quorum of n − f = 2 f + 1 timeout messages, containing
a threshold signature on a round number r produced by
combining 2 f + 1 signature shares {r} from the timeout
messages, and 2 f + 1 qchigh’s. A valid TC should only
contain high-QCs with round numbers < TC.r, and this
will be checked implicitly when a replica receives a TC.
Performance metrics. We consider message complexity and
communication complexity per round and consensus deci-
sion. For the theoretical analysis of the latency, we consider
block-commit latency, i.e., the number of rounds for all hon-
est replicas to commit a block since it is proposed. For the
empirical analysis, we measure the end-to-end latency, i.e.,
the time to commit a transaction since it is sent by a client.
Description of DiemBFT. The DiemBFT protocol (also
known as LibraBFT) [36] is a production version of Hot-
Stuff [38] with a synchronizer implementation (Pacemaker).
For better readability, Figure 1 presents the DiemBFT pro-
tocol in our terminology, which we will refer to as HotStuff
or DiemBFT interchangeably throughout the paper There are
two components of DiemBFT, a Steady State protocol that
makes progress when the round leader is honest, and a Pace-
maker protocol that advances round numbers either due to the
lack of progress or due to the current round being completed.
The leader Lr, upon entering round r, proposes a block B that
extends a block certiﬁed by the highest QC it knows about,
qchigh. When receiving the ﬁrst valid round-r block from Lr,
any replica tries to advance its current round number, update
its highest locked round and its highest QC, and checks if any
block can be committed. A block can be committed if it is the
ﬁrst block among 3 adjacent certiﬁed blocks with consecutive
round numbers. After the above steps, the replica votes for B
by sending a threshold signature share to the next leader Lr+1,
if the voting rules are satisﬁed. Then, when the next leader
Lr+1 receives 2 f + 1 such votes, it forms a QC of round r,
enters round r + 1, proposes the block for that round, and the
above process is repeated. When the timer of some round r
expires, the replica stops voting for that round and multicast
a timeout message containing a threshold signature share for
r and its highest QC. When any replica receives 2 f + 1 such
timeout messages, it forms a TC of round r, enters round r + 1
and sends the TC to the (next) leader Lr+1. When any replica
receives a timeout or a TC, it tries to advance its current round

3

a, current
Let Lr be the leader of round r. Each replica keeps the highest voted round rvote, the highest locked round rlock
round number rcur, and the highest quorum certiﬁcate qchigh (the current view number vcur is not used and remains 0
throughout). Replicas initialize rvote = 0, rlock = 0, rcur = 1, qchigh as the QC of the genesis block of round 0, and enter
round 1.
Steady State Protocol for Replica i
• Propose. Upon entering round r, the leader Lr multicasts a block B = [id, qchigh, r, vcur,txn].
• Vote. Upon receiving the ﬁrst valid proposal B = [id, qc, r, v,txn] from Lr in round r, execute Advance Round, Lock,
and then Commit (deﬁned below). If r = rcur, v = vcur, r > rvote and qc.r ≥ rlock, vote for B by sending the threshold
signature share {id, r, v}i to Lr+1, and update rvote ← r.

• Lock. (2-chain lock rule) Upon observing any valid qcb, let qc(cid:48) be the QC contained in the block certiﬁed by qc (i.e.,

qc(cid:48) is the parent of qc), the replica updates rlock ← max(rlock, qc(cid:48).r), and qchigh ← max(qchigh, qc).

• Commit. (3-chain commit rule) Whenever there exist three adjacent certiﬁed blocks B, B(cid:48), B(cid:48)(cid:48) in the chain with consecu-

tive round numbers, i.e., B(cid:48)(cid:48).r = B(cid:48).r + 1 = B.r + 2, the replica commits B and all its ancestors.

Pacemaker Protocol for Replica i
• Advance Round. The replica updates its current round rcur ← max(rcur, r), iff
– the replica receives or forms a round-(r − 1) quorum certiﬁcate qc, or
– the replica receives or forms a round-(r − 1) timeout certiﬁcate tc.

• Timer and Timeout.

– Upon entering round r, the replica sends the round-(r − 1) TC to Lr if it has the TC, and resets its timer to count

down for a predeﬁned time interval (timeout τ).

– When the timer expires, the replica stops voting for round rcur and multicasts a timeout message (cid:104){rcur}i, qchigh(cid:105)i

where {rcur}i is a threshold signature share.

– Upon receiving a valid timeout message or TC, execute Advance Round, Lock, and then Commit.
– Upon receiving 2f+1 timeouts, form a TC.

aCorresponds to the preferred round in [36].
bMay be formed from votes (by a leader) or contained in a proposal or a timeout messsage.

Figure 1: DiemBFT in our terminology.

number given the high-QCs (in the timeout or TC) or the TC,
updates its highest locked round and its highest QC given
the high-QCs, and checks if any block can be committed.
For space limitation, we omit the correctness proof of the
DiemBFT protocol, which can be found in [36].

3 Jolteon Design

In this section, we describe how we turn DiemBFT into
Jolteon – a 2-chain version of DiemBFT. The pseudocode is
given in Figure 2. As mentioned previously, the quadratic cost
of view-synchronization in leader-based consensus protocols,
due to faulty leaders or asynchronous periods, is inherent.
While the linearity of HotStuff’s view-change is a theoretical
milestone, its practical importance is limited by this anyway
quadratic cost of synchronization after bad views.

With this insight in mind, Jolteon uses a quadratic view-
change protocol that allows a linear 2-chain commit rule in
the steady state. The idea is inspired by PBFT [9] with each
leader proving the safety of its proposal. In the steady state
each block extends the block from the previous round and
providing the QC of the parent is enough to prove safety,

hence the steady state protocol remains linear. However, after
a bad round caused by asynchrony or a bad leader, proving
the safety of extending an older QC requires the leader to
prove that nothing more recent than the block of that QC is
committed. To prove this, the leader uses the TC formed for
view-changing the bad round. Recall that a TC for round r
contains 2 f + 1 validators’ qchigh sent in timeout messages
for round r. The leader attaches the TC to its proposal in
round r + 1 and extends the highest QC among the QCs in
the TC (see the Propose rule in Figure 2).

When a validator gets a proposal B, it ﬁrst tries to advance
its round number, then updates its qchigh with B.qc and checks
the 2-chain commit rule for a possible commit. Then, before
voting, it veriﬁes that at least one of the following two condi-
tions is satisﬁed:
• B.r = B.qc.r + 1 or;
• B.r = B.tc.r + 1 and

B.qc.r ≥ max{qchigh.r | qchigh ∈ B.tc}

In other words, either B contains the QC for the block of the
previous round; or it contains at least the highest QC among
the 2 f + 1 QCs in the attached TC, which was formed to
view-change the previous round.

4

Replicas keep the same variables as DiemBFT in Figure 1.
Steady State Protocol for Replica i
Changes from DiemBFT in Figure 1 are marked in blue.
• Propose. Upon entering round r, the leader Lr multicasts a block B = [id, qchigh,tc, r, vcur,txn], where tc = tcr−1 if Lr

enters round r by receiving a round-(r − 1) tcr−1, and tc = ⊥ otherwise.

• Vote. Upon receiving the ﬁrst valid proposal B = [id, qc,tc, r, v,txn] from Lr, execute Advance Round, Lock, and
then Commit (deﬁned below). If r = rcur, v = vcur, r > rvote and ( (1) r = qc.r + 1, or (2) r = tc.r + 1 and qc.r ≥
max{qchigh.r | qchigh ∈ tc}), vote for B by sending the threshold signature share {id, r, v}i to Lr+1, and update rvote ← r.
• Lock. (1-chain lock rule) Upon seeing a valid qc (formed by votes or contained in proposal or timeouts), the replica

updates qchigh ← max(qchigh, qc).

• Commit. (2-chain commit rule) Whenever there exists two adjacent certiﬁed blocks B, B(cid:48) in the chain with consecutive

round numbers, i.e., B(cid:48).r = B.r + 1, the replica commits B and all its ancestors.

Pacemaker Protocol for Replica i
Identical to DiemBFT in Figure 1.

Figure 2: Jolteon.

Safety intuition. If the ﬁrst condition is satisﬁed then B di-
rectly extends the block from the previous round. Since at
most one QC can be formed in a round, this means that no
forks are possible, and voting for B is safe.

The second condition is more subtle. Note that by the
2-chain commit rule, if a block B(cid:48) is committed, then there
exists a certiﬁed block B(cid:48)(cid:48) s.t. B(cid:48).round + 1 = B(cid:48)(cid:48).round. That
is, at least f + 1 honest replicas vote to form the QC for B(cid:48)(cid:48)
and thus set their qchigh to be the QC for block B(cid:48) (qcB(cid:48)). By
quorum intersection and since replicas never decrease their
qchigh, any future (higher round) TC contains a qchigh that is
at least as high as qcB(cid:48). The second condition then guarantees
that honest replicas only vote for proposals that extend the
committed block B(cid:48). Full proof can be found in Appendix A.
3.1 DiemBFT vs Jolteon.

Efﬁciency. Table 2 compares the efﬁciency of DiemBFT and
Jolteon from a theoretical point of view. Both protocols have
linear communication complexity per round and per decision
under synchrony and honest leaders, due to the leader-to-all
communication pattern and the threshold signature scheme2.
The complexity of the Pacemaker to synchronize views (view
synchronization in Table 2), for both protocols, under asyn-
chrony or failures is quadratic due to the all-to-all timeout
messages. The complexity of proposing a block after a bad
round that requires synchronization (view-change communi-
cation in Table 2) is linear for DiemBFT and quadratic for
Jolteon. This is because in DiemBFT such a proposal only
includes qchigh, whereas in Jolteon it includes a TC contain-
ing 2 f + 1 qchigh. The block-commit latency under synchrony
and honest leaders is 7∆ and 5∆ for DiemBFT and Jolteon,
respectively, due to the 3-chain (2-chain for Jolteon) commit

2The implementation of DiemBFT does not use threshold signatures, but
for the theoretical comparison here we consider a version of DiemBFT that
does.

rules. Each round in the commit chain requires two rounds
trip times (upper bounded by ∆), plus the new leader multicast
the last QC of the chain that allows all honest replicas to learn
about the chain and commit the block.
Limitations. During periods of asynchrony, or when facing
DDoS attacks on the leaders, both protocols have no liveness
guarantees – the leaders’ blocks cannot be received on time.
As a result, replicas keep multicasting timeout messages and
advancing round numbers without certifying or committing
blocks. This is unavoidable [34]: communication complexity
of any deterministic partially synchronous Byzantine agree-
ment protocol is unbounded before GST, even in failure-free
executions.

Fortunately, in the next section, we show that it is possible
to boost the liveness guarantee of DiemBFT, Jolteon, by
replacing the view-synchronization mechanism (pacemaker)
with a fallback protocol that guarantees progress even under
asynchrony. Furthermore, the asynchronous fallback can be
efﬁcient. The protocol we propose in the next section has
quadratic communication cost for fallback, which is the cost
DiemBFT and Jolteon pay to synchronize views anyway.

4 Ditto Design

To strengthen the liveness guarantees of existing partially
synchronous BFT protocols such as DiemBFT [36] and
Jolteon, we propose an Asynchronous Fallback protocol. It
has quadratic communication complexity (same as Jolteon
view-change and the Pacemaker of DiemBFT) and always
makes progress even under asynchrony or DDoS attacks
on the leader. We call the composition of Jolteon with
Asynchronous Fallback Ditto. Ditto has linear communi-
cation cost for the synchronous path, quadratic cost for the
asynchronous path, and preserves liveness robustly in asyn-
chronous network conditions. The steady state protocol (sync.

5

Latency

steady state communication

view-change communication

view synchronization

DiemBFT 7 messages
Jolteon
5 messages

linear
linear

linear
quadratic

quadratic
quadratic

Table 2: Theoretical comparison between DiemBFT and Jolteon.

path) is presented in Figure 4, and the asynchronous fallback
protocol (async. path) is presented in Figure 5.
Protocol intuition. Our solution consists of a steady-state
protocol, which is similar to that of Jolteon, and an asyn-
chronous fallback protocol, which replaces the view-change
of Jolteon. An illustration of our protocol is shown in Fig-
ure 3. The idea behind our fallback protocol is that, after
entering the fallback, all replicas will act as leaders to build
their fallback chains. Once enough (2 f + 1) fallback chains
grow to a certain height, a random leader election occurs to
select one fallback chain, allowing the replicas to return to
steady state and continue with the chosen chain. It can be
shown that with constant probability, a fallback chain with
enough blocks is selected, such that at least one new block on
this fallback chain is committed by all replicas.

once n − f f-chain
complete, select
one from n chains
randomly

steady state

n f-chains,
built by each
replica

steady state
continues from the
selected f-chain

Figure 3: The high-level picture of the protocol. During the
fallback, each replica acts as a leader and tries to build a
certiﬁed fallback-chain (f-chain). When 2 f + 1 f-chains are
completed, one leader is randomly elected from n replicas,
and all replicas continue the steady state chain from the f-
chain built by the elected leader.

Since this protocol has two paths, a synchronous fast path
and an asynchronous fallback path, it is critical to ensure
safety and liveness when the protocol transfers from one
path to another. On a high level, our protocol ensures safety
by always following the 1-chain lock and 2-chain commit
rule from Jolteon. While at the fallback path, the fallback
chain selected by leader election is no different from a steady
state chain, hence we let all replicas update their local states
as if Jolteon had made progress when exiting the fallback.
As for liveness, our protocol guarantees that either the sync
path (same as Jolteon) makes progress, or enough replicas

6

timeout the synchronous path and enter the asynchronous
fallback.

Additional terminology for Ditto.
• Fallback-block and Fallback-chain. For the Asynchronous
Fallback protocol, we deﬁne another type of block named
fallback-block (f-block), denoted as B. In contrast, the block
deﬁned earlier is called the regular block. An f-block B
adds two additional ﬁelds to a regular block, formatted
as B = [B, height, proposer] where B is a regular block,
height ∈ {1, 2} is the position of the f-block in the fallback-
chain and proposer is the replica that proposes the block.
We will use Bh,i to denote a height-h f-block proposed by
replica i. A fallback-chain (f-chain) consists of f-blocks.
• Fallback-QC. A fallback quorum certiﬁcate (f-QC) qc for
an f-block Bh,i is a threshold signature for the message
(B.id, B.r, B.v, h, i), produced by combining the signature
shares {B.id, B.r, B.v, h, i} from a quorum of replicas (n −
f = 2 f + 1 replicas). An f-block is certiﬁed if there exists
an f-QC for the f-block. f-QCs or f-blocks are ﬁrst ranked
by view numbers and then by round numbers. In contrast,
the QC of regular blocks is called regular QC.

• Fallback-TC. A fallback timeout certiﬁcate (f-TC) tc is
a threshold signature for a view number v, produced by
combining the signature shares {v} from a quorum of repli-
cas (n − f = 2 f + 1 replicas). f-TCs are ranked by view
numbers.

• Leader Election and Coin-QC. As mentioned in Section 2,
we use threshold signatures to generate randomness [8]
used to elect the leader. More speciﬁcally, for any given
view, each replica signs the hash of the view number with
threshold signature as the coin share. Then any f + 1 valid
coin shares of the same view from f + 1 distinct replicas
can form a unique threshold signature (called coin-QC or
qccoin) on the hash of the view number, which can be used
as randomness to elect leader L among n replicas with
probability 1/n. The probability of the adversary to predict
the outcome of the election is at most 1/n + negl(k).

• Endorsed Fallback-QC and Endorsed Fallback-block. Once
a replica has a qccoin of view v that elects replica L as the
leader, we say any f-QC of view v by replica L is endorsed
(by qccoin), and the f-block certiﬁed by the f-QC is also
endorsed (by qccoin). Any endorsed f-QC is handled as a
regular QC in any steps of the protocol such as Lock, Com-
mit, Advance Round. An endorsed f-QC ranks higher than
any regular QC with the same view number. As crypto-
graphic evidence of endorsement, the ﬁrst block in a new

view additionally includes the coin-QC of the previous
view.

Description of Steady State. The steady state protocol is de-
scribed in Figure 4, with the differences marked in blue com-
paring to Jolteon. The blocks do not contain TC anymore,
instead, the ﬁrst block in a new view includes the coin-QC of
the previous view, in order to help all replicas exit the fallback
of the previous view and enter the new view. Each replica
additionally keeps a boolean value fallback-mode to record
if it is in the fallback, during which the replica will not vote
regular blocks. The 1-chain lock rule and 2-chain commit rule
still apply, but the two blocks in the 2-chain can be certiﬁed
regular block or endorsed fallback-block, and need to have
the same view number.
Description of Asynchronous Fallback. Now we give a
brief description of the Asynchronous Fallback protocol (Fig-
ure 5), which replaces the Pacemaker protocol in the Jolteon
protocol (Figure 2). The illustration of the fallback protocol
can be found in Figure 6, and the illustration of the message
exchanges of one replica during the fallback can be found in
Figure 7.

Just like in Jolteon, when the timer expires, the replica
tries to initiate the fallback (the equivalent of view-change)
by broadcasting a timeout message containing the highest
QC and a signature share of the current view number. When
receiving or forming a fallback-TC from 2 f + 1 timeout mes-
sages, the replica enters the fallback path: It updates its cur-
rent view number vcur, initializes the voted round number
rvote[ j] = 0 and the voted height number hvote[ j] = 0 for each
replica j. Finally, the replica starts building its fallback-chain
by broadcasting the f-TC and proposing the ﬁrst f-block which
extends the qchigh, has height 1, round number qchigh.r + 1,
and view number vcur.

Any f-block (irrelevant of height) gets veriﬁed by all repli-
cas who vote on it (updating their voted round and height
number for the fallback) by sending signature shares back to
the proposer of the f-block. Replicas build their fallback-chain
not by necessarily extending their own chain but by adopt-
ing the ﬁrst certiﬁed block of matching height they deliver
(in vcur). This boosting strategy guarantees that no honest
replica’s chain is left behind in the middle of the fallback,
hence at least 2 f + 1 chains will reach height-2 and their
leader-replica will broadcast a height-2 f-QC.

Finally, when the replica receives 2 f + 1 height-2 f-QCs,
it knows that 2 f + 1 f-chains are complete and starts the
leader election by releasing a coin share for the current
view number. When f + 1 shares are released the leader
of the view is determined through the formation of a coin-QC
qccoin. The fallback is then terminated, and the replica up-
dates fallback-mode = f alse to exit the fallback and enters
the next view, acting as if the chain of the elected leader is the
only known chain. Looking at this chain the replica updates
all relevant variables and commits any blocks that have 2-
chain support. Given that we waited for 2 f + 1 long-enough

chains, with 2/3 probability the replicas will commit a block.
Correctness of Ditto. The proof of safety and liveness for
Ditto can be found in Appendix B.

Theorem 1 (Efﬁciency). During the periods of synchrony
with honest leaders, the amortized communication complexity
per block decision is O(n), and the block-commit latency
is 5 rounds. During periods of asynchrony, the expected
communication complexity per block decision is O(n2), and
the expected block-commit latency is 10.5 rounds.

Proof. When the network is synchronous and leaders are
honest, no honest replica will multicast timeout messages. In
every round, the designated leader multicast its proposal of
size O(1) (due to the use of threshold signatures for QC), and
all honest replicas send the vote of size O(1) to the next leader.
Hence the communication cost is O(n) per round and per
block decision. For the block latency, since Jolteon adopts
2-chain commit and need one more round for all replicas to
receive the 2-chain proof, the latency is 2 × 2 + 1 = 5 rounds.
When the network is asynchronous and honest replicas
enter the asynchronous fallback, each honest replica in the
fallback only broadcast O(1) number of messages, and each
message has size O(1). Hence, each instance of the asyn-
chronous fallback has communication cost O(n2), and will
commit a new block with probability 2/3. Therefore, the
expected communication complexity per block decision is
O(n2). The latency to ﬁnish one asynchronous fallback is 7
rounds, consisting of 1 round to exchange timeouts, 2 × 2 = 4
rounds to build height-1 and 2 f-blocks, 1 round to exchange
height-2 f-QCs and 1 round to exchange randomness shares.
Since the asynchronous fallback commits a new block with
probability at least 2/3, the expected latency of the asyn-
chronous path is 7 × 1.5 = 10.5 rounds.

5

Implementation

We implement in Rust all protocols discussed in the pa-
per: 3-chain DiemBFT, Jolteon, Ditto, and 2-chain 2-
chain VABA. We use tokio3 for asynchronous network-
ing, ed25519-dalek4 for elliptic curve based signatures. We
use threshold_crypto5 to implement random coins, and
data-structures are persisted using rocksdb6. We use TCP
to achieve reliable point-to-point channels, necessary to cor-
rectly implement the distributed system abstractions. Our
implementations are between 5,000 and 7,000 LOC, and a
further 2,000 LOC of unit tests. We are open sourcing our im-
plementations of 3-chain DiemBFT7 , Jolteon8 , and Ditto

3https://tokio.rs
4https://github.com/dalek-cryptography/ed25519-dalek
5https://docs.rs/threshold_crypto/0.4.0/threshold_

crypto/

6https://rocksdb.org
7https://github.com/asonnino/hotstuff/tree/3-chain
8https://github.com/asonnino/hotstuff

7

Compared to Jolteon in Figure 2, each replica additionally keeps a boolean value fallback-mode, initialized as f alse,
to record whether the replica is in a fallback.
Steady State Protocol for Replica i
Changes from Jolteon in Figure 2 are marked in blue.
• Propose. Upon entering round r, the leader Lr multicasts a block B = [id, qchigh, qccoin, r, vcur,txn], where qccoin is the

coin-QC of view vcur−1 if B is the ﬁrst proposal in view vcur, otherwise qccoin = ⊥.

• Vote. Upon receiving the ﬁrst valid proposal B = [id, qc, qccoin, r, v,txn] from Lr, execute Exit Fallback if qccoin (cid:54)= ⊥;
otherwise execute Advance Round, Lock, and then Commit (deﬁned below). If r = rcur, v = vcur, r > rvote, r = qc.r + 1,
qc.rank ≥ qchigh.rank, and fallback-mode = f alse, vote for B by sending the threshold signature share {id, r, v}i to
Lr+1, and update rvote ← r.

• Lock. (1-chain lock rule) Upon seeing a valid qc (formed by votes or contained in proposal or timeouts), the replica

updates qchigh ← max(qchigh, qc).

• Commit. (2-chain commit rule) Whenever there exists two adjacent blocks B, B(cid:48) with the same view number in the

chain, each can be a certiﬁed block or an endorsed fallback-block, the replica commits B and all its ancestors.

Round Synchronization
• Advance Round. Upon receiving a valid qc, the replica updates its current round rcur ← max(rcur, qc.r + 1).
• Timer and Timeout. Upon entering a new round or a new view, the replica resets its timer to τ.

When the timer expires, the replica updates fallback-mode ← true, and multicasts a timeout message (cid:104){vcur}i, qchigh(cid:105)i
where {vcur}i is a threshold signature share.
Upon receiving a valid timeout message, execute Advance Round, Lock, and then Commit.

Figure 4: Steady State of Ditto

and 2-chain VABA9. We are also open sourcing all Amazon
Web Services orchestration scripts, benchmarking scripts, and
measurements data to enable reproducible results. 10

We implement a simple round-robin-based leader election
mechanism. All our implementations remove the transaction
dissemination (mempool) from the critical path of consensus
in order to fairly evaluate the consensus protocols instead
of evaluating unrelated bottlenecks [3]. We implement a
benchmark client that generates and submits transactions at
a predeﬁned input rate. The mempool subsystem receives
these transactions, collects them into batches, and dissemi-
nates them to the other nodes. The consensus module can
therefore agree on the hash of these batches and keep the
size of the block small. This obvious optimization increases
throughput more than 10x to other independent evaluations
of HotStuff [3] and DiemBFT [39], but we refrain from bold
claims and leave exploration to future work.
2-chain VABA: As a by-product of Ditto, we can improve
the block-commit latency of VABA [2] from expected 16.5
rounds to expected 10.5 rounds, through chaining and adopt-
ing the 2-chain commit rule. We refer to the improved ver-
sion of VABA as 2-chain VABA and the analysis can be
found in Appendix C. We obtain our 2-chain VABA protocol,
by simply disabling the synchronous path of Ditto. More
speciﬁcally, 2-chain VABA is obtained by never allowing any
leader-replica to propose when not in fallback, and setting

9https://github.com/danielxiangzl/hotstuff
10https://github.com/asonnino/hotstuff/tree/main/

benchmark,
main/benchmark

https://github.com/danielxiangzl/hotstuff/tree/

the timeout τ to 0 in Ditto (Figure 4 and 5). Then, whenever
the replica enters a new view, it broadcasting timeouts carry-
ing its highest QC for the new view and enters the fallback.
Therefore, the synchronous path is never executed, and the
exchange of timeout messages acts as the view-change phase
in the original VABA [2]. The correctness of 2-chain VABA
can be implied by the correctness of Ditto, as Ditto is safe
and live under asynchrony.

Ditto with exponential backoff: From the protocol design
of 2-chain VABA, we know that 2-chain VABA is exactly the
asynchronous fallback of our Ditto with the timeout thresh-
old τ set to be 0. Therefore, under asynchrony or leader
attacks, the performance of 2-chain VABA would be better
than Ditto, as 2-chain VABA immediately proceeds to the
next view without waiting for the timer to expire. To improve
the latency performance of Ditto under long periods of asyn-
chrony or leader attacks, we adopt an exponential backoff
mechanism for the asynchronous fallback as follows. We say
a replica executes the asynchronous fallback consecutively x
times if it only waits for the timer to expire for the ﬁrst fall-
back, and skips waiting for the timer and immediately sends
timeout for the rest x − 1 fallbacks. Initially, replicas only ex-
ecute asynchronous fallback consecutively x = 1 time. How-
ever, if a replica, within the timeout, does not receive from
the steady state round-leader immediately after the fallback,
it will multiply x by a constant factor (5 in our experiments);
otherwise, the replica resets x = 1. Therefore, during long
periods of asynchrony or leader attacks, the number of consec-
utively executed fallbacks would be exponentially increasing

8

During a fallback of view v, for every replica j ∈ [n], each replica records all the f-QCs of view v by replica j, and keeps a
voted round number rvote[ j] and a voted height number hvote[ j].
Async. Fallback Protocol for Replica i
• Enter Fallback. Upon receiving or forming an f-TC tc of view v ≥ vcur, update fallback-mode ← true, vcur ←
v, rvote[ j] ← 0 and hvote[ j] ← 0 for ∀ j ∈ [n], and multicast tc and a height-1 f-block B1,v,i = [id, qchigh, qchigh.r +
1, vcur,txn, 1, i].

• Fallback Vote. Upon receiving an f-block Bh, j from replica j, if h > hvote[ j], fallback-mode = true, and
– if h = 1 and Bh, j = [id, qc, r, v,txn, 1, j] such that qc.rank ≥ qchigh.rank, r = qc.r + 1, and v = vcur; or
– if h = 2, and Bh, j = [id, qc, r, v,txn, h, j] such that qc is valid, v = vcur, r = qc.r +1, r > rvote[ j] and h = qc.height +1,

sets rvote[ j] ← r, hvote[ j] ← h and vote for the f-block by sending {id, r, v, h, j}i back to replica j.

• Fallback Propose. Upon the ﬁrst height-h f-block Bh, j (by any replica j) is certiﬁed by some qc and fallback-mode =

true,

– if h = 2, replica i signs and multicasts qc;
– if h = 1, replica i multicasts Bh+1,i = [id, qc, Bh, j.r + 1, v,txn, h + 1, i].
• Leader Election. Upon receiving 2 f + 1 valid height-2 view-vcur
fallback-mode = true, sign and multicast a coin share for view vcur.

f-QCs signed by distinct replicas and

• Exit Fallback. Upon receiving a coin-QC qccoin of view ≥ vcur or f + 1 valid coin shares to form a qccoin of view ≥ vcur,
multicast qccoin. Let replica L be the elected leader by qccoin. If fallback-mode = true, update rvote ← rvote[L]. Update
fallback-mode ← f alse, vcur ← qccoin.v + 1. Execute Advance Round, Lock, and then Commit.

Figure 5: Asynchronous Fallback of Ditto

qchigh

height-1 qc

2 f + 1 height-2 qc to
trigger leader election

qccoin

Br(cid:48)

B1,L

B2,L

Brcur

round r(cid:48)

round r
height 1

round r + 1
height 2

round rcur = r + 2

steady state

f-chain of replica L

back to steady state

Figure 6: This ﬁgure illustrates one fallback-chain built by
replica L in the asynchronous fallback of view v. The ﬁrst
fallback-block B1,L of height 1 contains the qchigh, and the
second f-block contains the f-QC of the previous f-block.
2 f + 1 height-2 f-QCs will trigger the leader election to form
a coin-QC qccoin that randomly selects a replica as the leader
with probability 1/n. Replicas continue the steady state from
the f-chain by the leader.

(1, 5, 25, ...); while during periods of synchrony and honest
leaders, the number of consecutively executed fallbacks is
always 1.

6 Evaluation

We evaluate the throughput and latency of our implementa-
tions through experiments on Amazon Web Services (AWS).
We particularly aim to demonstrate (i) that Jolteon achieves
the theoretically lower block-commit latency than 3-chain
DiemBFT under no contention and (ii) that the theoretically
larger message size during view-change does not impose

Figure 7: This ﬁgure illustrates the message exchanges of
one replica during the asynchronous fallback of view v. On
timeout, the replica multicasts timeout for view v, and enters
the fallback when receiving 2 f + 1 timeouts for view v. The
replica ﬁrst proposes a height-1 fallback-block extending its
highest QC, and when receiving the ﬁrst certiﬁed height-1
f-block (by 2 f + 1 votes), the replica proposes a height-2 f-
block extending it. When receiving the ﬁrst certiﬁed height-2
f-block, the replica multicast the height-2 fallback-QC. When
receiving 2 f + 1 height-2 f-QCs, the replica multicasts a ran-
domness share which is a threshold signature on the hash of
the view number. A random coin can be formed when the
replica gathers f + 1 valid randomness shares, and it multi-
casts the random coin and exits the fallback.

a heavier burden, making Jolteon no slower than 3-chain
DiemBFT under faults (when the view-change happens fre-
quently). Additionally we aim to show that Ditto adapts
to the network condition, meaning that (iii) it behaves simi-
larly to Jolteon when the network is synchronous (with and
without faults) and (iv) close to our faster version of VABA
(2-chain) when the adversary adaptively compromises the
leader.

We deploy a testbed on Amazon Web Services, using
m5.8xlarge instances across 5 different AWS regions: N.

9

timeoutviewvsendheight-1f-blocksendheight-2f-blocksendheight-2f-QCsendrand.sharesendcoinandexitget2f+1timeoutscertifiedheight-1f-blockcertifiedheight-2f-blockget2f+1height-2f-QCsgetf+1rand.sharesin Figure 8 we run both protocol with a varying system size
(10, 20, 50 nodes). In order to remove any noise from the
mempool, this graph does not show the end-to-end latency
for clients but the time it takes for a block to be committed.
As the Figure illustrated Jolteon consistently outperforms
3-chain DiemBFT by about 200 − 300ms of latency which
is around one round-trip across the world and both systems
scale similarly. In Figure 9 this effect is less visible due to the
noise of the mempool (end-to-end latency of around 2 secs),
but Jolteon is still slightly faster than 3-chain DiemBFT in
most experiments.

Finally, in Figure 10 we run both protocols with 20 nodes
and crashed 0, 1, or 3 nodes at the beginning of the experiment.
This forces frequent view-changes due to the leader rotation
that 3-chain DiemBFT uses in order to provide fairness. This
is ideal for our experiment since we can see the overall impact
of the more costly view-change slowing down Jolteon. As
we can see, Jolteon again outperforms 3-chain DiemBFT
in most settings due to the 2-chain commit enabling more
frequent commits under faults. As a result, we can conclude
that there is little reason to pay the extra round-trip of 3-
chain DiemBFT in order to have a theoretically linear view-
change. After sharing our ﬁndings with the Diem Team they
are currently integrating an adaptation of Jolteon for their
next mainnet release.
6.2 Evaluation of Ditto

Synchronous and fault-free executions. When all replicas
are fault-free and the network is synchronous, we compare
the performances of the three protocol implementations in
Figure 9. As we can observe from the ﬁgure, the synchronous
path performance of Ditto is very close to that of Jolteon,
when the quadratic asynchronous fallback of Ditto and the
quadratic pacemaker of Jolteon is not triggered. On the
other hand, the performance of 2-chain VABA is worse than
Jolteon and Ditto in this setting, due to its quadratic com-
munication pattern – instead of every replica receiving the
block metadata and synchronizing the transaction payload
with only one leader per round in Jolteon and Ditto, in
VABA every replica will receive and synchronize with O(n)
leaders per round.
Crash faults. In this experiment, we run the three protocol
implementations with 20 nodes and crash 1 or 3 nodes from
the beginning of the execution. The throughput-latency re-
sults are summarized in Figure 10. As we can observe from
the ﬁgure, 2-chain VABA has the most robust performance
under faults, where the latency only slightly increases before
the throughput exceeds 30k tps. The reason is that by de-
sign 2-chain VABA can make progress as long as at least
2 f + 1 nodes are honest, and crashing some of the nodes
only add latency to the views when these nodes are elected
as the leader of the views. The performance of 3-chain Diem-
BFT and Jolteon are more fragile under faults, where the
peak performance degrades to 30k tps with about 10 seconds

Figure 8: Comparative block-commit latency for 3-chain
DiemBFT (HotStuff) and Jolteon. WAN measurements with
10, 20, or 50 replicas. No replica faults, 500KB mempool
batch size and 512B transaction size.

Virginia (us-east-1), N. California (us-west-1), Sydney
(apsoutheast-2), Stockholm (eu-north-1), and Tokyo (ap-
northeast1). They provide 10Gbps of bandwidth, 32 virtual
CPUs (16 physical core) on a 2.5GHz, Intel Xeon Platinum
8175, and 128GB memory and run Linux Ubuntu server
20.04.

We measure throughput and end-to-end latency as the per-
formance metrics. Throughput is computed as the average
number of committed transactions per second, and end-to-end
latency measures the average time to commit a transaction
from the moment it is submitted by the client. Compared with
the block-commit latency in our theoretical analysis, end-to-
end latency also includes the queuing delay of the transaction
when the clients’ input rate is high which helps identify the
capacity limit of our system.

In all our experiments, the transaction size is set to be 512
bytes and the mempool batch size is set to be 500KB. We
deploy one benchmark client per node submitting transactions
at a ﬁxed rate for a duration of 5 minutes (to ensure we report
steady state performance). We set the timeout to be 5 seconds
for experiments with 10 and 20 nodes, and 10 seconds for 50
nodes, so that the timeout is large enough for not triggering
the pacemaker of Jolteon and fallback of Ditto. In the
following sections, each measurement in the graphs is the
average of 3 runs, and the error bars represent one standard
deviation.

6.1 Evaluation of Jolteon

In this section, we compare Jolteon with our baseline 3-
chain DiemBFT implementation in two experiments. First

10

01020304050Committee size0.00.20.40.60.81.01.21.4Latency (s)HotStuff, Input rate: 20kHotStuff, Input rate: 30kJolteon, Input rate: 20kJolteon, Input rate: 30kFigure 9: Comparative throughput-latency performance for 3-chain DiemBFT (HotStuff), Jolteon, Ditto, and 2-chain VABA
WAN measurements with 10, 20, or 50 replicas. No replica faults, 500KB mempool batch size and 512B transaction size.

latency under 1 fault and 10k tps with about 15 seconds la-
tency under 3 faults. The reason is that whenever a round-r
leader is faulty, replicas need to wait for two timeouts, which
is 10sec since the timeout is set to be 5sec, to enter round
r + 1 from round r − 1. Ditto under faults performs better
than Jolteon but worse than 2-chain VABA. Compared to
2-chain VABA, replicas in Ditto need to wait for a time-
out of 5sec to enter the asynchronous fallback whenever the
leader is faulty; compared to Jolteon, replicas only need to
wait for one timeout (5sec) to enter the fallback, which makes
progress efﬁciently even under faults (as the 2-chain VABA
under faults suggests).

Attacks on the leaders. Figure 11 presents the measurement
results. When the eventual synchrony assumption does not
hold, either due to DDoS attacks on the leaders or adversar-
ial delays on the leaders’ messages, 3-chain DiemBFT and
Jolteon will have no liveness, i.e., the throughput of the
system is always 0. The reason is that whenever a replica
becomes the leader for some round, its proposal message is
delayed and all other replicas will timeout for that round. On
the other hand, Ditto and 2-chain VABA are robust against
such adversarial delays and can make progress under asyn-
chrony. The performance of the 2-chain VABA protocol
implementation is not affected much by delaying a certain
replica’s proposal, as observed from the previous experiment
with crashed replicas. Therefore, we use it as a baseline to
compare with our Ditto protocol implementation. Our re-
sults, conﬁrm our theoretical assumption as the asynchronous
fallback performance of Ditto is very close to that of 2-chain

VABA under 10 or 20 nodes, and slightly worse than 2-chain
VABA under 50 nodes. This extra latency cost is due to the
few timeouts that are triggered during the exponential back-
off.

Crash faults and attacks on the leaders. Figure 12 presents
the measurement results. The throughput of 3-chain Diem-
BFT and Jolteon is again 0 under leader attacks for the same
reason mentioned above. 2-chain VABA makes progress even
under leader attacks, and its performance is also robust against
1 or 3 node crashes. The performance of Ditto is very close
to that of 2-chain VABA, since our implementation adopts
the exponential backoff mechanism for the asynchronous fall-
back. One interesting artifact of the exponential backoff is
that, compared to the case under just crash faults and no
DDoS (Figure 10), Ditto has better performance under both
crash faults and DDoS (Figure 12). The reason is that under
long periods of leader attacks, the Ditto will skip waiting
for the time to expire for most of the views, and directly send
timeouts and enter the fallback.

Take away. To conclude, there is little reason not to use
Ditto as our experiments conﬁrm our theoretical bounds.
Ditto adapts to the network behavior and achieves almost
optimal performance. The only system that sometimes outper-
forms Ditto is 2-chain VABA during intermittent periods of
asynchrony as it does not pay the timeout cost of Ditto when
deciding how to adapt. This, however, comes at a signiﬁcant
cost when the network is good and in our opinion legitimizes
the superiority of Ditto when run over the Internet.

11

010k20k30k40k50k60k70k80kThroughput (tx/s)0.02.55.07.510.012.515.017.5Latency (s)HotStuff, 10 nodesHotStuff, 20 nodesHotStuff, 50 nodesJolteon, 10 nodesJolteon, 20 nodesJolteon, 50 nodesDitto, 10 nodesDitto, 20 nodesDitto, 50 nodesVaba, 10 nodesVaba, 20 nodesVaba, 50 nodesFigure 10: Comparative throughput-latency performance for 3-chain DiemBFT (HotStuff), Jolteon, Ditto, and 2-chain VABA
WAN measurements with 20 replicas. 0, 1, and 3 faults, 500KB mempool batch size and 512B transaction size.

7 Related Work

Eventually synchronous BFT. BFT SMR has been studied
extensively in the literature. A sequence of efforts [5, 6, 9,
15, 19, 38] have been made to reduce the communication cost
of the BFT SMR protocols, with the state-of-the-art being
HotStuff [38] that has O(n) cost for decisions, a 3-chain com-
mit latency under synchrony and honest leaders, and O(n2)
cost for view-synchronization. Jolteon presents another
step forward from HotStuff as we realize the co-design of the
pacemaker with the commit rules enables removing one round
without sacriﬁcing the linear happy path. Two concurrent the-
oretical works propose a 2-chain variation of the HotStuff
as well [17, 31]. However, the work of Rambaud et al. [31]
relies on impractical cryptographic primitives to preserve a
linear view-change (assuming still a quadratic pacemaker)
whereas neither protocol provides a comprehensive evalua-
tion to showcase that the extra view-change costs (which also
applies in [17]) does not cause signiﬁcant overheads. Most
importantly, both protocols fail to realize the full power of 2-
chain protocols missing the fact the view-change can become
robust and DDoS resilient.

Asynchronous BFT. Several recent proposals focus on im-
proving the communication complexity and latency, includ-
ing HoneyBadgerBFT [26], VABA [2], Dumbo-BFT [16],
Dumbo-MVBA [24], ACE [35], Aleph [13], and DAG-
Rider [18]. The state-of-the-art protocols for asynchronous
SMR have O(n2) cost per decision [35], or amortized O(n)
cost per decision after transaction batching [13, 16, 18, 24].

BFT with optimistic and fallback paths. To the best of our
knowledge, [22] is the ﬁrst asynchronous BFT protocol with
an efﬁcient happy path. Their asynchronous path has O(n3)
communication cost while their happy path has O(n2) cost per
decision, which was later extended [30] to an amortized O(n).
A recent paper [34] further improved the communication
complexity of asynchronous path to O(n2) and the cost of
the happy path to O(n). The latency of these protocols is
not optimized, e.g. latency of the protocol in [34] is O(n).
Moreover, these papers are theoretical in nature and far from
the realm of practicality.

Finally, a concurrent work named the Bolt-Dumbo Trans-
former (BDT) [23], proposes a BFT SMR protocol with both
synchronous and asynchronous paths and provides implemen-
tation and evaluation. BDT takes the straightforward solution
of composing three separate consensus protocols as black
boxes. Every round starts with 1) a partially synchronous
protocol (HotStuff), times-out the leader and runs 2) an Asyn-
chronous Binary Agreement in order to move on and run 3)
a fully asynchronous consensus protocol [16] as a fallback.
Although BDT achieves asymptotically optimal communica-
tion cost for both paths this is simply inherited by the already
known to be optimal back boxes. On the theoretical side,
their design is beneﬁcial since it provides a generally compos-
able framework, but this generality comes at a hefty practical
cost. BDT has a latency cost of 7 rounds (vs 5 of Ditto) at
the fast path and of 45 rounds (vs 10.5 of Ditto) at the fall-
back, making it questionably practical. Finally, not opening
the black-boxes stopped BDT from reducing the latency of
HotStuff although it also has a quadratic view-change.

12

010k20k30k40k50k60kThroughput (tx/s)0.05.010.015.020.025.0Latency (s)HotStuff, 20 nodesHotStuff, 20 nodes (1 faulty)HotStuff, 20 nodes (3 faulty)Jolteon, 20 nodesJolteon, 20 nodes (1 faulty)Jolteon, 20 nodes (3 faulty)Ditto, 20 nodesDitto, 20 nodes (1 faulty)Ditto, 20 nodes (3 faulty)Vaba, 20 nodesVaba, 20 nodes (1 faulty)Vaba, 20 nodes (3 faulty)Figure 11: Comparative throughput-latency performance for
3-chain DiemBFT (HotStuff), Jolteon, Ditto, and 2-chain
VABA. WAN measurements with 10, 20, or 50 replicas.
No replica faults, 500KB mempool batch size, and 512B
transaction size. Leader constantly under DoS attack.

Figure 12: Comparative throughput-latency performance for
3-chain DiemBFT (HotStuff), Jolteon, Ditto, and 2-chain
VABA. WAN measurements with 20 replicas. 0, 1, and 3
faults, 500KB mempool batch size and 512B transaction size.
Leader constantly under DoS attack.

Our protocol, Ditto, has the asymptotically optimal com-
munication cost in both the happy path and the asynchronous
(fallback) path, but also good latency: in fact, due to the
2-chain design, the latency is even better than the state-of-
the-art, (3-chain) HotStuff/DiemBFT and (3-chain) VABA
protocols. Ditto also inherits the efﬁcient pipelined design
of these protocols (that are deployed in practice [36]). In con-
trast with BDT, there is no overhead associated with switching
between synchronous and asynchronous paths. We provide
an implementation that organically combines the different
modes of operation and extensive evaluation to support our
claim that Ditto enjoys the best of both worlds with practical
performance.

Another related line of work on optimistic BFT protocols
for other network models, including partially synchrony [1,14,
21] and synchrony [10,27,29,33]. We leave the incorporation
of an optimistic 1-chain commit path to Ditto to future work.

BFT protocols with ﬂexible commit rules. Recently, a line
of work studies and proposes BFT protocols with ﬂexible
commit rules for different clients of various beliefs on net-
work and resilience assumptions, for the purpose of providing
safety and liveness guarantees to the clients with the correct
assumptions. As a comparison, our work offers multiple com-
mit paths for replicas under synchrony and asynchrony toler-
ating the same resilience threshold (one-thirds) and achieves
optimal communication cost for each path asymptotically.

Flexible BFT [25] proposes one BFT SMR solution support-
ing clients with various fault and synchronicity beliefs, but the
guarantees only hold for the clients with the correct assump-
tions. Strengthened BFT [37] shows how to strong commit
blocks with higher resilience guarantees for partially syn-
chronous BFT SMR protocols. Several recent works [28, 32]
investigate how to checkpointing a synchronous longest chain
protocol using partially synchronous BFT protocols, and offer
clients with two different commit rules.

8 Conclusion and Future Work

We present Ditto, a practical byzantine SMR protocol that
enjoys the best of both worlds: optimal communication on
and off the happy path (linear and quadratic, respectively)
and progress guarantees under the worst case asynchrony
and DDoS attacks. As a secondary contribution, we design
a 2-chain version of HotStuff, Jolteon, which leverages a
quadratic view-change mechanism to reduce the latency of the
standard 3-chain HotStuff. We implement and experimentally
evaluate all our systems to validate our theoretical analysis.
An interesting future work would be to incorporate an
optimistic 1-chain commit path in our Jolteon and Ditto,
which can further improve the latency performance of our
systems when there are no faults.

13

010k20k30k40kThroughput (tx/s)0.02.55.07.510.012.515.017.520.0Latency (s)HotStuff, 10 nodesHotStuff, 20 nodesHotStuff, 50 nodesJolteon, 10 nodesJolteon, 20 nodesJolteon, 50 nodesDitto, 10 nodesDitto, 20 nodesDitto, 50 nodesVaba, 10 nodesVaba, 20 nodesVaba, 50 nodes05k10k15k20k25k30k35k40kThroughput (tx/s)0.01.02.03.04.05.06.07.08.0Latency (s)HotStuff, 20 nodesHotStuff, 20 nodes (1 faulty)HotStuff, 20 nodes (3 faulty)Jolteon, 20 nodesJolteon, 20 nodes (1 faulty)Jolteon, 20 nodes (3 faulty)Ditto, 20 nodesDitto, 20 nodes (1 faulty)Ditto, 20 nodes (3 faulty)Vaba, 20 nodesVaba, 20 nodes (1 faulty)Vaba, 20 nodes (3 faulty)Acknowledgments

This work is supported by the Novi team at Facebook. We also
thank the Novi Research and Engineering teams for valuable
feedback, and in particular Mathieu Baudet, Andrey Chursin,
George Danezis, Zekun Li, and Dahlia Malkhi for discussions
that shaped this work.

References

[1] Michael Abd-El-Malek, Gregory R Ganger, Garth R
Goodson, Michael K Reiter, and Jay J Wylie. Fault-
scalable byzantine fault-tolerant services. In Proceed-
ings of the twentieth ACM Symposium on Operating
Systems Principles (SOSP), pages 59–74, 2005.

[2] Ittai Abraham, Dahlia Malkhi, and Alexander Spiegel-
man. Asymptotically optimal validated asynchronous
In Proceedings of the 2019
byzantine agreement.
ACM Symposium on Principles of Distributed Comput-
ing (PODC), pages 337–346, 2019.

[3] Salem Alqahtani and Murat Demirbas. Bottlenecks
arXiv preprint

in blockchain consensus protocols.
arXiv:2103.04234, 2021.

[4] Erica Blum, Jonathan Katz, and Julian Loss. Network-
arXiv preprint

agnostic state machine replication.
arXiv:2002.03437, 2020.

[5] Ethan Buchman, Jae Kwon, and Zarko Milosevic.
arXiv preprint

The latest gossip on bft consensus.
arXiv:1807.04938, 2018.

[6] Vitalik Buterin and Virgil Grifﬁth. Casper the friendly
ﬁnality gadget. arXiv preprint arXiv:1710.09437, 2017.

[11] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer.
Consensus in the presence of partial synchrony. Journal
of the ACM (JACM), 35(2):288–323, 1988.

[12] Michael J Fischer, Nancy A Lynch, and Michael S Pa-
terson. Impossibility of distributed consensus with one
faulty process. Journal of the ACM (JACM), 32(2):374–
382, 1985.

[13] Adam G ˛agol, Damian Le´sniak, Damian Straszak, and
Michał ´Swi˛etek. Aleph: Efﬁcient atomic broadcast
in asynchronous networks with byzantine nodes.
In
Proceedings of the 1st ACM Conference on Advances in
Financial Technologies (AFT), pages 214–228, 2019.

[14] Rachid Guerraoui, Nikola Kneževi´c, Vivien Quéma, and
In Pro-
Marko Vukoli´c. The next 700 bft protocols.
ceedings of the 5th European Conference on Computer
Systems (EuroSys), pages 363–376, 2010.

[15] Guy Golan Gueta, Ittai Abraham, Shelly Grossman,
Dahlia Malkhi, Benny Pinkas, Michael Reiter, Dragos-
Adrian Seredinschi, Orr Tamir, and Alin Tomescu. Sbft:
a scalable and decentralized trust infrastructure.
In
2019 49th Annual IEEE/IFIP international conference
on dependable systems and networks (DSN), pages 568–
580. IEEE, 2019.

[16] Bingyong Guo, Zhenliang Lu, Qiang Tang, Jing Xu,
and Zhenfeng Zhang. Dumbo: Faster asynchronous bft
protocols. In Proceedings of the 2020 ACM SIGSAC
Conference on Computer and Communications Security,
pages 803–818, 2020.

[17] Mohammad M Jalalzai, Jianyu Niu, Chen Feng, and
Fangyu Gai. Fast-hotstuff: A fast and resilient hotstuff
protocol. arXiv preprint arXiv:2010.11454, 2020.

[7] Christian Cachin, Klaus Kursawe, Frank Petzold, and
Victor Shoup. Secure and efﬁcient asynchronous broad-
In Annual International Cryptology
cast protocols.
Conference, pages 524–541. Springer, 2001.

[18] Idit Keidar, Eleftherios Kokoris-Kogias, Oded Naor, and
Alexander Spiegelman. All you need is dag. In Pro-
ceedings of the 2021 ACM Symposium on Principles of
Distributed Computing (PODC), 2021.

[8] Christian Cachin, Klaus Kursawe, and Victor Shoup.
Random oracles in constantinople: Practical asyn-
chronous byzantine agreement using cryptography.
Journal of Cryptology, 18(3):219–246, 2005.

[9] Miguel Castro and Barbara Liskov. Practical byzantine
In Proceedings of the third sympo-
fault tolerance.
sium on Operating Systems Design and Implementation
(NSDI), pages 173–186. USENIX Association, 1999.

[10] T-H. Hubert Chan, Rafael Pass, and Elaine Shi. Pili: An
extremely simple synchronous blockchain. Cryptology
ePrint Archive, Report 2018/980, 2018.

[19] Eleftherios Kokoris Kogias, Philipp Jovanovic, Nicolas
Gailly, Ismail Khofﬁ, Linus Gasser, and Bryan Ford.
Enhancing bitcoin security and performance with strong
consistency via collective signing. In 25th Usenix Se-
curity Symposium (Usenix Security 16), pages 279–296,
2016.

[20] Eleftherios Kokoris Kogias, Dahlia Malkhi, and Alexan-
der Spiegelman. Asynchronous distributed key genera-
tion for computationally-secure randomness, consensus,
and threshold signatures. In Proceedings of the 2020
ACM SIGSAC Conference on Computer and Communi-
cations Security, pages 1751–1767, 2020.

14

[21] Ramakrishna Kotla, Lorenzo Alvisi, Mike Dahlin, Allen
Clement, and Edmund Wong. Zyzzyva: speculative
In Proceedings of twenty-
byzantine fault tolerance.
ﬁrst ACM Symposium on Operating Systems Principles
(SOSP), pages 45–58, 2007.

[22] Klaus Kursawe and Victor Shoup. Optimistic asyn-
In International Collo-
chronous atomic broadcast.
quium on Automata, Languages, and Programming
(ICALP), pages 204–215. Springer, 2005.

[23] Yuan Lu, Zhenliang Lu, and Qiang Tang.

Bolt-
dumbo transformer: Asynchronous consensus as fast as
pipelined bft. arXiv preprint arXiv:2103.09425, 2021.

[24] Yuan Lu, Zhenliang Lu, Qiang Tang, and Guiling Wang.
Dumbo-mvba: Optimal multi-valued validated asyn-
chronous byzantine agreement, revisited. In Proceed-
ings of the 39th Symposium on Principles of Distributed
Computing, pages 129–138, 2020.

[25] Dahlia Malkhi, Kartik Nayak, and Ling Ren. Flexible
byzantine fault tolerance. In Proceedings of the 2019
ACM Conference on Computer and Communications
Security (CCS), pages 1041–1053, 2019.

[26] Andrew Miller, Yu Xia, Kyle Croman, Elaine Shi, and
In
Dawn Song. The honey badger of bft protocols.
Proceedings of the 2016 ACM SIGSAC Conference on
Computer and Communications Security (CCS), pages
31–42, 2016.

[27] Atsuki Momose, Jason Paul Cruz, and Yuichi Kaji.
Hybrid-bft: Optimistically responsive synchronous con-
sensus with optimal latency or resilience. Cryptology
ePrint Archive, Report 2020/406, 2020.

[28] Joachim Neu, Ertem Nusret Tas, and David Tse. Ebb-
and-ﬂow protocols: A resolution of the availability-
ﬁnality dilemma. arXiv preprint arXiv:2009.04987,
2020.

[29] Rafael Pass and Elaine Shi. Thunderella: Blockchains
with optimistic instant conﬁrmation. In Annual Inter-
national Conference on the Theory and Applications of
Cryptographic Techniques, pages 3–33. Springer, 2018.

[30] HariGovind V Ramasamy and Christian Cachin. Parsi-
monious asynchronous byzantine-fault-tolerant atomic
broadcast. In International Conference On Principles
Of Distributed Systems, pages 88–102. Springer, 2005.

[31] Matthieu Rambaud. Malicious security comes for free
in consensus with leaders. IACR Cryptol. ePrint Arch.,
2020:1480, 2020.

[32] Suryanarayana Sankagiri, Xuechao Wang, Sreeram Kan-
nan, and Pramod Viswanath. Blockchain cap theorem

allows user-dependent adaptivity and ﬁnality. arXiv
preprint arXiv:2010.13711, 2020.

[33] Nibesh Shrestha, Ittai Abraham, Ling Ren, and Kartik
Nayak. On the optimality of optimistic responsiveness.
In Proceedings of the 2020 ACM SIGSAC Conference on
Computer and Communications Security (CCS), page
839–857, 2020.

[34] Alexander Spiegelman. In search for a linear byzantine

agreement. arXiv preprint arXiv:2002.06993, 2020.

[35] Alexander Spiegelman and Arik Rinberg. Ace: Abstract
consensus encapsulation for liveness boosting of state
machine replication. In 23rd International Conference
on Principles of Distributed Systems (OPODIS), 2020.

[36] The LibraBFT Team. State machine replication in the
libra blockchain, 2020. https://developers.libra.
org/docs/state-machine-replication-paper.

[37] Zhuolun Xiang, Dahlia Malkhi, Kartik Nayak, and Ling
Ren. Strengthened fault tolerance in byzantine fault
In The 41st IEEE International
tolerant replication.
Conference on Distributed Computing Systems (ICDCS),
2021.

[38] Maofan Yin, Dahlia Malkhi, Michael K Reiter,
Guy Golan Gueta, and Ittai Abraham. Hotstuff: Bft
In Pro-
consensus with linearity and responsiveness.
ceedings of the 2019 ACM Symposium on Principles of
Distributed Computing (PODC), pages 347–356, 2019.

[39] Jiashuo Zhang, Jianbo Gao, Zhenhao Wu, Wentian Yan,
Qize Wu, Qingshan Li, and Zhong Chen. Performance
analysis of the libra blockchain: An experimental study.
CoRR, abs/1912.05241, 2019.

A Correctness of Jolteon

A.1 Safety

We begin by formalizing some notation.

• We call a block byzantine (honest) if it was proposed by

a byzantine (honest) replica.

• We say that a block B is certiﬁed if a quorum certiﬁcate

QCB exists.

• Bi ←− QCi ←− Bi+1 means that the block Bi is certiﬁed
by the quorum certiﬁcate QCi which is contained in the
block Bi+1.

• Bi ←−∗ B j means that the block B j extends the block
Bi. That is, there is exists a sequence Bi ←− QCi ←−
Bi+1 ←− QCi+1 · · · ←− QC j−1 ←− B j

15

Deﬁnition 1 (Global direct-commit). We say that a block B
is globally direct-committed if f + 1 honest replicas each suc-
cessfully perform the Vote step on block B(cid:48) proposal in round
B.r + 1, such that B(cid:48).qc certiﬁes B. These Vote calls invoke
Lock, setting qchigh ← B(cid:48).qc, and return f + 1 matching votes
(that could be used to form a QCB(cid:48) with f other matching
votes).

Lemma 1. If an honest replica successfully performs the
Commit step on block B then B is globally direct-committed.

Proof. By the Commit condition, there exists a chain B ←−
QCB ←− B(cid:48) ←− QCB(cid:48) with B(cid:48).r = B.r + 1. The existence of
QCB(cid:48) implies that f + 1 honest replicas did Vote for B(cid:48).

The next lemma follows from the voting rules and the

deﬁnition of global direct commit.

Lemma 2. If a block B is globally direct-committed then any
higher-round TC contains qchigh of round at least B.r.

Proof. By Deﬁnition 1, f + 1 honest replicas execute the lock
step in round B.r + 1 and set qchigh to B(cid:48).qc that certiﬁes B
(so B(cid:48).qc.r = B.r, B(cid:48) is the block proposed in round B.r + 1).
None of these honest replicas may have previously timed out
in round B.r + 1, and timing out stops voting in a round (but
the replicas voted for B(cid:48)).

Since qchigh is never decreased, a timeout message prepared
by any of the above f + 1 honest replicas in rounds > B.r
contains a high qc of round at least B.r. By quorum intersec-
tion, timeout messages used to prepare the TC in any round
> B.r contain a message from one of these honest replicas,
completing the argument.

Due to quorum intersection, we have

Observation 1. If a block is certiﬁed in a round, no other
block can gather f + 1 honest votes in the same round. Hence,
at most one block is certiﬁed in each round.

We can now prove the key lemma

Lemma 3. For every certiﬁed block B(cid:48) s.t. B(cid:48).r ≥ B.r such
that B is globally direct-committed, B ←−∗ B(cid:48).

Proof. By Observation 1, B ←−∗ B(cid:48) for every B(cid:48) s.t. B(cid:48).r =
B.r.

We now prove the lemma by induction on the round num-

bers r(cid:48) > B.r.

Base case: Let r(cid:48) = B.r +1. B is globally direct-committed,
so by Deﬁnition 1, there are f + 1 honest replicas that prepare
votes in round r(cid:48) = B.r + 1 on some block Br+1 such that
B ←− QCB ←− Br+1. By Observation 1, only Br+1 can be
certiﬁed in round r(cid:48).

Step: We assume the Lemma holds up to round r(cid:48) −1 > B.r
and prove that it also holds for r(cid:48). If no block is certiﬁed at
round r(cid:48), then the induction step holds vacuously. Otherwise,

let B(cid:48) be a block certiﬁed in round r(cid:48) and let QCB(cid:48) be its certiﬁ-
cate. B is globally direct-committed, so by Deﬁnition 1, there
are f + 1 honest replicas that have locked high qc in round
B.r + 1. One of these replicas, v, must also have prepared a
vote that is included in QCB(cid:48) (as QC formation requires 2 f + 1
votes and there are 3 f + 1 total replicas).

Let B(cid:48)(cid:48) ←− QCB(cid:48)(cid:48) ←− B(cid:48) and denote r(cid:48)(cid:48) = B(cid:48)(cid:48).r = QCB(cid:48)(cid:48) .r.
There are two cases to consider, r(cid:48)(cid:48) ≥ r and r(cid:48)(cid:48) < r. In the ﬁrst
case, by the induction assumption for round r(cid:48)(cid:48), B ←−∗ B(cid:48)(cid:48)
and we are done.

In the second case, r(cid:48)(cid:48) < r < r(cid:48) (the right inequality is by
the induction step), i.e., the rounds for B(cid:48)(cid:48) and B(cid:48) are not
consecutive. Hence, B(cid:48) must contain a TC for round r(cid:48) − 1.
By Lemma 2, this TC contains a qchigh with round ≥ r.

Consider a successful call by an honest replica to vote
for B(cid:48). The only way to satisfy the predicate to vote is to
satisfy (2), which implies B(cid:48)(cid:48).r ≥ qchigh.r ≥ B.r, which is a
contradiction to r(cid:48)(cid:48) < r.

As a corollary of Lemma 3 and the fact that every globally

direct-committed block is certiﬁed, we have

Theorem 2. For every two globally direct-committed blocks
B, B(cid:48), either B ←−∗ B(cid:48) or B(cid:48) ←−∗ B.

Let’s call a successful invocation of the Commit step by a
replica a local direct-commit. For every locally committed
block, there is a locally direct-committed block that extends
it, and due to Lemma 1, also a globally direct-committed
block that extends it. Each globally committed block deﬁnes
a unique preﬁx to the genesis block, so Theorem 2 applies to
all committed blocks. Hence all honest replicas commit the
same block at each position in the blockchain.

Furthermore, since all honest replicas commit the transac-
tions in one block following the same order, honest replicas
do not commit different transactions at the same log position.

A.2 Liveness
Lemma 4. When an honest replica in round < r receives a
proposal for round r from another honest replica, it enters
round r.

Proof. Recall that a well-formed proposal sent by an honest
replica contains either a TC or QC of round r − 1. When
an honest replica receives such a proposal message, it will
advance the round and enter round r.

Lemma 5. If the round timeouts and message delays between
honest replicas are ﬁnite, then all honest replicas keep enter-
ing increasing rounds.

Proof. Suppose all honest replicas are in round r or above,
and let v be an honest replica in round r.

We ﬁrst prove that some honest replica enters round r + 1.
If all 2 f + 1 honest replicas time out in round r, then v will
eventually receive 2 f + 1 timeout messages, form a TC and

16

enter round r + 1. Otherwise, at least one honest replica, v(cid:48) –
not having sent a timeout message for round r – enters round
r + 1. For this, v(cid:48) must have observed qc of round r and
updated its qchigh accordingly.

Since qchigh is never decreased and included in timeout
messages, if v(cid:48) times out in any round > r, then its timeout
message will trigger v to enter a round higher than r. Other-
wise, v(cid:48) must observe a QC in all rounds > r. In this case,
an honest leader sends a proposal in some round > r. That
proposal will eventually be delivered to v, triggering it to enter
a higher round by Lemma 4.

In an eventually synchronous setting, the system becomes
synchronous after the the global stabilisation time (GST). We
assume a known upper bound ∆ on message transmission de-
lays among honest replicas (practically, a back-off mechanism
can be used to estimate ∆) and let 4∆ be the local timeout
threshold for all honest replicas in all rounds.

Rounds are consecutive, advanced by quorum or timeout
certiﬁcates, and honest replicas wait for proposals in each
round. We ﬁrst show that honest replicas that receive a pro-
posal without the round timer expiring accept the proposal,
allowing the quorum of honest replicas to drive the system
progress.

Lemma 6. Let r be a round such that no QC has yet been
formed for it and in which no honest replica has timed out.
When an honest replica v receives a proposal of an honest
leader of round r, v will vote for the proposal.

Proof. The predicate in the Vote step for a proposal with
block B in round r checks that (1) round numbers are mono-
tonically increasing, and (2a) either the block extends the QC
of the previous round (B.qc.r + 1 = r), or (2b) the round of
extended qc (B.qc.r) isn’t less than the maximum high qc
round in the TC of the previous round.

For (1), by assumption none of the 2 f + 1 honest replicas
have timed out, so no TC could have been formed for round
r. Also by assumption, no QC has been formed. Hence, no
honest replica may have entered or voted in a round larger
than r. Round r has an honest leader, so when a honest replica
executes Vote step the round r proposal, it does so for the ﬁrst
time and with the largest voting round.

For (2), we consider two cases. If B.tc = ⊥, then by well-
formedness of honest leader’s proposal, the B.qc it extends
must have round number r − 1, rounds are consecutive, and
condition (a) holds.

If B.tc is not empty, then it is a TC for round r − 1,
formed based on 2 f + 1 timeout messages.
In this case,
B.qc.r ≥ max{qchigh.r | qchigh ∈ B.tc} predicate determines
whether the replica votes for the proposal. Since the leader is
honest, B.qc is the qchigh of the leader when the proposal was
generated. The predicate holds as the honest leader updates
the qchigh to have round at least as large as the qchigh of each
timeout messages it receives (separately or within a forwarded
TC).

We now show a strong synchronization for rounds with

honest leaders.

Lemma 7. Let r be a round after GST with an honest leader.
Within a time period of 2∆ from the ﬁrst honest replica enter-
ing round r, all honest replicas receive the proposal from the
honest leader.

Proof. When the ﬁrst honest replica enters round r, if it is not
the leader, it must have formed a TC for round r − 1. Let v be
the honest leader of round r. Since honest replicas forward
TC to the leader of the next round, v will receive the TC and
advance to round r within ∆ time of the ﬁrst honest replica
entering round r.

Upon entering round r, v multicasts a proposal, which is

delivered within ∆ time to all honest replicas.

Liveness follows from the following

Theorem 3. Let r be a round after GST. Every honest replica
eventually locally commits some block B with B.r > r.

Proof. Since the leaders are determined by round-robin and
the number of byzantine replicas is bounded by f , we can ﬁnd
round r(cid:48) > r such that rounds r(cid:48), r(cid:48) + 1, r(cid:48) + 2 all have honest
leaders.

By Lemma 5 honest nodes enter increasing rounds indef-
initely. Due to Lemma 7, all honest replicas receive round
r(cid:48) proposal with block B from the leader within 2∆ time of
starting their round r(cid:48) timer (by Lemma 4 triggering ones
that haven’t yet entered round r(cid:48) to do so). By Lemma 6,
honest replicas accept the proposal and vote for it. Within
time ∆ their votes are delivered to the leader of round r(cid:48) + 1,
who forms a QC extending B and sends a proposal with a
block Br(cid:48)+1. This proposal will be received by honest replicas
within another ∆ time, by Lemma 4 triggering them to enter
round r(cid:48) + 1 before the local timer of 4∆ for round r(cid:48) expires.
By Lemma 6, every honest replica accepts the proposal,
prepares a vote and sends it to round r(cid:48) + 2 leader, who is also
honest. At this point, since f + 1 honest replicas voted for B,
by Deﬁnition 1, B is globally direct-committed.

Continuing the argument, the honest leader of round r(cid:48) + 2
receives the votes to form the round r(cid:48) + 1 QC after at most
5∆ time of the ﬁrst honest validator entering round r(cid:48). It then
prepares and sends round r(cid:48) + 2 proposal that extends QCBr(cid:48)+1
.
After at most another ∆ time all honest replicas receive this
proposal, leading them to enter round r(cid:48) + 2 (before local
timer for round r(cid:48) + 1 expires11) and locally direct-commit
B.

Since we assume that each client transaction will be re-
peatedly proposed by honest replicas until it is committed
(see Section 2), eventually each client transaction will be
committed by all honest replicas.

11Analogous to round r(cid:48). Moreover, as the round r(cid:48) + 1 leader enters the

round ﬁrst, no replica spends more than 3∆ time in round r(cid:48) + 1.

17

B Correctness of Ditto

Recall that we say a fallback-block B of view v by replica i is
endorsed, if B is certiﬁed and there exists a coin-QC of view
v that elects replica i as the leader.

We say a replica is in the Steady State of view v, if
it has fallback-mode = f alse and vcur = v; otherwise if
fallback-mode = true and vcur = v, we say the replica is in
the asynchronous fallback of view v.

We use C (B) to denote the set of replicas who provide

votes for the QC or f-QC for B.

If a block or f-block B is an ancestor of another block or
f-block B(cid:48) due to a chain of QCs or endorsed f-QCs, we say
B(cid:48) extends B. A block or f-block also extends itself.

Lemma 8. Let B, B(cid:48) both be endorsed f-blocks of the same
view, or both be certiﬁed blocks of the same view. If the round
number of B equals the round number of B(cid:48), then B = B(cid:48).

Proof. Suppose on the contrary that B (cid:54)= B(cid:48). Let r be the
round number of B, B(cid:48).

Suppose that B, B(cid:48) both are certiﬁed blocks of the same
view. Since n = 3 f + 1 and |C (B)| = |C (B(cid:48))| = 2 f + 1, by
quorum intersection, C (B) ∩ C (B(cid:48)) contains at least one hon-
est replica h who voted for both B and B(cid:48). Without loss of
generality, suppose that h voted for B ﬁrst. According to the
Vote step, h updates its rvote = r and will only vote for blocks
with round number > rvote in the same view. Therefore h will
not vote for B(cid:48), thus B(cid:48) cannot be certiﬁed, contradiction.

Suppose that B, B(cid:48) both are endorsed f-blocks of the same
view. By quorum intersection, at least one honest replica h
voted for both B and B(cid:48). Without loss of generality, suppose
that h voted for B ﬁrst. Since B, B(cid:48) are of the same view with
elected leader L, according to the Fallback Vote step, after
voting for B of round r, h updates rvote[L] = r and will only
vote for blocks of round number > rvote[L]. Thus h will not
vote for B(cid:48) and B(cid:48) cannot be certiﬁed, contradiction.

Lemma 9. For any chain that consists of only certiﬁed blocks
and endorsed f-blocks, the adjacent blocks in the chain have
consecutive round numbers, and nondecreasing view numbers.
Moreover, for blocks of the same view number, no endorsed
f-block can be the parent of any certiﬁed regular block.

Proof. Suppose on the contrary that there exist adjacent
blocks B, B(cid:48) of round number r, r(cid:48) where B is the parent block
of B(cid:48), and r(cid:48) (cid:54)= r + 1. If B(cid:48) is a certiﬁed block, according to the
Vote step, honest replicas will not vote for B(cid:48) since r(cid:48) (cid:54)= r + 1,
and B(cid:48) cannot be certiﬁed, contradiction. If B is an endorsed
f-block, according to the Fallback Vote step, honest replicas
will not vote for B(cid:48) since r(cid:48) (cid:54)= r + 1, and B(cid:48) cannot be certi-
ﬁed, contradiction. Therefore, the blocks in the chain have
consecutive round numbers.

Suppose on the contrary that there exist adjacent blocks
B, B(cid:48) of view number v, v(cid:48) where B is the parent block of B(cid:48),

and v(cid:48) < v. Since n = 3 f + 1 and |C (B)| = |C (B(cid:48))| = 2 f + 1,
by quorum intersection, C (B) ∩ C (B(cid:48)) contains at least one
honest replica h who voted for both B and B(cid:48). According to
the Vote and Fallback Vote steps, h has its vcur = v when
voting for B. According to the protocol, h only updates its
vcur in steps Enter Fallback and Exit Fallback, and vcur
is nondecreasing. Hence, h will not vote for B(cid:48) since v(cid:48) <
vcur, contradiction. Therefore, the blocks in the chain have
nondecreasing view numbers.

Suppose on the contrary that there exist adjacent blocks
B, B(cid:48) of the same view number v where B is the parent block
of B(cid:48), and B is an endorsed f-block and B(cid:48) is a certiﬁed
block. Since n = 3 f + 1 and |C (B)| = |C (B(cid:48))| = 2 f + 1,
by quorum intersection, C (B) ∩ C (B(cid:48)) contains at least one
honest replica h who voted for both B and B(cid:48). According
to the Fallback Vote step, h has fallback-mode = true
when voting for B. According to the Vote step, h has
fallback-mode = f alse when voting for B(cid:48). The only step
for h to set its fallback-mode to f alse is the Exit Fallback
step, where h also updates its current view to v + 1. Then, h
will not vote for the view-v block B(cid:48), contradiction. Therefore,
for blocks of the same view number, no fallback-block can
be the parent of any regular block.

Lemma 10. Let B, B(cid:48) both be endorsed f-blocks of the same
view, then either B extends B(cid:48) or B(cid:48) extends B.

Proof. Suppose on the contrary that B, B(cid:48) do not extend one
another, and they have height numbers h, h(cid:48) respectively. Let L
be the replica that proposes B, B(cid:48) and elected by the coin-QC.
Without loss of generality, assume that h ≤ h(cid:48). According
to the Fallback Vote step, each honest replica votes for f-
blocks of L with strictly increasing height numbers. Since by
quorum intersection, there exists at least one honest replica
h that voted for both B and B(cid:48), thus we have h < h(cid:48). Since
h(cid:48) > h, and according to the Fallback Vote step, there must be
another endorsed f-block B(cid:48)(cid:48) by L of height h that B(cid:48) extends,
and B, B(cid:48)(cid:48) do not extend one another. Similarly, by quorum
intersection, at least one honest replica voted for both B and
B(cid:48)(cid:48), which is impossible since each honest replica votes for f-
blocks of L with strictly increasing height numbers. Therefore,
B, B(cid:48) extend one another.

Lemma 11. If there exist two adjacent certiﬁed or endorsed
blocks Br, Br+1 in the chain with consecutive round numbers
r, r + 1 and the same view number v, then any certiﬁed or
endorsed block of view number v that ranks no lower than Br
must extend Br.

Proof. Suppose on the contrary that there exists a block of
view number v that ranks no lower than Br and does not extend
Br. Let B be such a block with the smallest rank, then the
parent block B(cid:48) of B also does not extend Br, but ranks no
higher than Br. By Lemma 9, there are 3 cases: (1) Br, Br+1
are certiﬁed blocks, (2) Br is a certiﬁed block and Br+1 is an
endorsed blocks, and (3) Br, Br+1 are endorsed blocks.

18

• Suppose Br, Br+1 are certiﬁed blocks. By quorum in-
tersection, C (B) ∩ C (Br+1) contains at least one honest
replica h who voted for both B and Br+1. According
to the Vote and Lock step, when h votes for Br+1, it
updates qchigh to be the QC of Br.

– Suppose that B is a certiﬁed block, by Lemma 8, B
must has round number ≥ r + 2 otherwise B will
extend Br. If the parent block B(cid:48) of B has view
number < v, then B(cid:48) ranks lower than Br. If B(cid:48)
has view number v, by Lemma 9 and 8, B(cid:48) is a
certiﬁed block and has round number < r, thus
also ranks lower than Br. According to the Vote
step, h will not vote for B since B(cid:48) has rank lower
than its qchigh, contradiction.

– Suppose that B is a endorsed block, let B1 be the
height-1 endorsed block of view v, and let B(cid:48)
1 be
the parent block of B1, which ranks no higher than
Br. If B(cid:48)
1 is a certiﬁed block, by the same argu-
ment above we have B(cid:48)
1 ranks lower than Br. If
B(cid:48)
1 is an endorsed block, since B(cid:48)
1 ranks no higher
than Br its has view number ≤ v. By deﬁnition an
endorsed block ranks higher than a certiﬁed block
if they have the same view number, thus B(cid:48)
1 must
have view number < v and rank lower than Br. By
quorum intersection, at least one honest replica h(cid:48)
voted for both B1 and Br+1, and has qchigh to be
the QC of Br. However, according to the Fallback
Vote step, h(cid:48) will not vote for B1 since B(cid:48)
1 ranks
lower than its qchigh, contradiction.

• Suppose Br is a certiﬁed block and Br+1 is an endorsed

blocks.

– Suppose that B is a certiﬁed block, by Lemma 8, B
must has round number ≥ r + 1 otherwise B will
equal Br. Since B, Br does not extend one another,
by Lemma 9, there exists a round-r block B(cid:48)
r (cid:54)= Br
that B extends. By Lemma 9, B(cid:48)
r has view num-
ber ≤ v. If B(cid:48)
r has view number v, by Lemma 8,
Br = B(cid:48)
r has view number
≤ v − 1, by quorum intersection, there exists at
least one honest replica that voted for both B(cid:48)
r and
Br. According to the steps Vote, Fallback Vote,
after voting for B(cid:48)
r, h sets its rvote = r and will
not vote for regular blocks of round number ≤ r.
Hence, h will not vote for Br of round number r,
contradiction.

r, contradiction.

If B(cid:48)

– Suppose that B is a certiﬁed block. Since B, Br both
have view number v, and by deﬁnition an endorsed
block ranks higher than a certiﬁed block if they
have the same view number, B ranks lower than Br,
contradiction.

– Suppose that B is an endorsed block.

By
Lemma 10, B and Br extend one another. Since
B ranks no lower than Br and endorsed f-blocks
in the chain have consecutive round numbers, we
have B extends Br, contradiction.

Therefore, any certiﬁed or endorsed block of view number

v that ranks no lower than Br must extend Br.

r(cid:48) extends Br.

Lemma 12. If a block Br is committed by some honest replica
due to a 2-chain starting from Br, and another block B(cid:48)
r(cid:48) is
committed by some honest replica due to a 2-chain starting
from B(cid:48)

r(cid:48), then either Br extends B(cid:48)
r(cid:48) or B(cid:48)
Proof. Suppose on the contrary that Br, B(cid:48)
r(cid:48) are committed by
honest replica, but they do not extend one another. Suppose
there exist two adjacent certiﬁed or endorsed blocks Br, Br+1
in the chain with consecutive round numbers r, r + 1 and the
same view number v. Suppose there also exist two adjacent
certiﬁed or endorsed blocks Br(cid:48), B(cid:48)
r(cid:48)+1 in the chain with con-
secutive round numbers r(cid:48), r(cid:48) + 1 and the same view number
v(cid:48). Without loss of generality, suppose that v ≤ v(cid:48).

If v = v(cid:48), without loss of generality, further assume that
r ≤ r(cid:48). By Lemma 11, any certiﬁed or endorsed block of view
number v that ranks no lower than Br must extend Br. Since
v = v(cid:48) and r ≤ r(cid:48), B(cid:48)
r(cid:48) ranks no lower than Br, and thus B(cid:48)
r(cid:48)
must extend Br, contradiction.

If v < v(cid:48), by Lemma 9, there exist blocks that B(cid:48)

r(cid:48) extends,
have view numbers > v, and do not extend Br. Let B be such
a block with the smallest view number. Then the parent block
B(cid:48) of B also does not extend Br, and has view number ≤ v. By
quorum intersection, at least one honest replica h voted for
both Br+1 and B. According to the Lock step, after h voted
for Br+1 in view v, it updates qchigh to be the QC of Br. Then,
when h votes for B, according to the steps Vote, Fallback
Vote, the rank of the parent block B(cid:48) must be ≥ qchigh.rank,
and thus no lower than the rank of Br. By deﬁnition B(cid:48) has
view number ≤ v, hence B(cid:48) must have view number v. By
Lemma 11, B(cid:48) of view number v and ranks no lower than Br
must extend Br, contradiction.

Therefore, we have either Br extends B(cid:48)

r(cid:48), or Br extends B(cid:48)
r(cid:48).

– Suppose that B is an endorsed block, by Lemma 10,
B and Br+1 extend one another. By Lemma 9, no
endorsed f-block can be the parent of any certiﬁed
block of the same view, therefore B must extend
Br, contradiction.

• Suppose Br, Br+1 are endorsed blocks.

Theorem 4 (Safety). Honest replicas do not commit different
transactions at the same log position.

Proof. First we show that if blocks B and B(cid:48) are committed at
the same height in the blockchain by honest replicas, then B =
B(cid:48). Suppose that B is committed due to a block Bl of round l

19

being directly committed by a 2-chain, and B(cid:48) is committed
due to a block Bk of round k being directly committed by a
2-chain. By Lemma 12, either Bl extends Bk or Bl extends
Bk, which implies that B = B(cid:48).

Since all honest replicas commit the transactions in one

block following the same order, the theorem is true.

Lemma 13. If all honest replicas enter the asynchronous
fallback of view v by setting fallback-mode =
then eventually they all exit the fallback and set
true,
fallback-mode = f alse. Moreover, with probability 2/3,
at least one honest replica commits a new block after exiting
the fallback.

Proof. Suppose
set
that
fallback-mode = true and have vcur = v.
Let h de-
note the honest replica who has the highest ranked qchigh
when entering the fallback.

replicas

honest

all

We ﬁrst show that the height-1 fallback-block proposed
by h will be voted by all honest replicas. Suppose on the
contrary that some honest replica h(cid:48) does not vote for the
height-1 f-block proposed by h. According to the step En-
ter Fallback, Fallback Vote, the only possibility is that
qc.rank < qchigh.rank, where qc is the QC contained in the
height-1 f-block by h and qchigh is the highest QC of h(cid:48) when
voting for the f-block. However, this contradicts the assump-
tion that h holds the highest ranked qchigh. Hence, all honest
replicas will vote for the height-1 fallback-block proposed by
h.

After the height-1 f-block is certiﬁed with 2 f + 1 votes that
forms an f-QC qc1, according to the Fallback Propose step,
any replica can propose a height-2 f-block extending it. All
honest replicas will vote for the height-2 f-block according
to the Fallback Vote step, and thus it will be certiﬁed with
2 f + 1 votes. Then honest replicas will multicast the f-QC
for its height-2 f-block.

Since any honest replica i can obtain a height-2 f-QC and
multicast it, any honest replica will receive 2 f +1 valid height-
2 f-QCs and then sign and multicast a coin share of view
v in the Leader Election step. When the qccoin of view v
that elects some replica L is received or formed at any hon-
est replica, at least one honest replica has received 2 f + 1
height-2 f-QCs before sending the coin share, which means
that 2 f + 1 fallback-chains have 2 f-blocks certiﬁed. All
honest replicas will receive the qccoin eventually due to the
forwarding. According to the Exit Fallback step, they will
set fallback-mode = f alse and exit the fallback.

Since the coin-QC elects any replica to be the leader with
probability 1/n, and at least one honest replica receives 2 f +1
height-2 f-QCs among all 3 f + 1 f-chains. With probability
2/3, the honest replica has the height-2 f-QC of the f-chain
by the elected leader, thus have the 2 f-blocks endorsed which
have the same view number and consecutive round numbers.
Therefore, the honest replica can commit the height-1 f-block
according to the Commit step.

20

Theorem 5 (Liveness). Each client transaction is eventually
committed by all honest replicas.

Proof. First we show that all honest replicas keep committing
new blocks with high probability. We prove by induction on
the view numbers.

We ﬁrst prove for the base case where all honest replicas
start their protocol with view number v = 0. If all honest
replicas eventually all enter the asynchronous fallback, by
Lemma 13, they eventually all exit the fallback, and a new
block is committed at least one honest replica with probability
2/3. According to the Exit Fallback step, all honest replicas
enter view v = 1 after exiting the fallback. If at least one
honest replica never set fallback-mode = true, this implies
that the sequence of QCs produced in view 0 is inﬁnite. By
Lemma 9, the QCs have consecutive round numbers, and
thus all honest replicas keep committing new blocks after
receiving these QCs.

Now assume the theorem is true for view v = 0, ..., k − 1.
Consider the case where all honest replicas enter the view
v = k. By the same argument for the v = 0 base case, honest
replicas either all enter the fallback and the next view with a
new block committed with 2/3 probability, or keeps commit-
ting new blocks in view k. When the network is synchronous
and the leaders are honest, the block proposed in the Steady
State will always extend the highest QC, and thus voted by
all honest replicas. Therefore, by induction, honest replicas
keep committing new blocks with high probability.

Since we assume that each client transaction will be re-
peatedly proposed by honest replicas until it is committed
(see Section 2), eventually each client transaction will be
committed by all honest replicas.

C 2-chain VABA Details

The original VABA [2] is designed for single-shot value, runs
in views, and each view consists of a leader nomination phase,
a leader election phase and a view-change phase. The leader
nomination phase uses n parallel instances of 3-chain HotStuff
(with each replica as the stable leader) to broadcast and certify
its value. This phase takes 4 RTTs or 8 rounds, because
intuitively 3-chain commit needs 3 RTTs to commit a value
and 1 extra RTT to ensure every replica receives the commit
proofs. Then every replica exchanges the proofs showing
the leader nomination phase has ﬁnished, and runs the leader
election phase to decide which replica’s value to commit.
Finally, during view-change phase replicas exchange their
local information about the elected leader’s value, to ensure
safety for entering the next view if no value is committed.
With probability 2/3, each view of VABA will succeed and
consensus is reached. Therefore, the latency of VABA is
(8 + 1 + 1 + 1) × 1.5 = 16.5 rounds in expectation.

VABA can be easily turned into a chained BFT SMR pro-
tocol, by having 3-chain HotStuff instances building chained
blocks instead of just values during the leader nomination
phase. As a result, the number of blocks to certify is 4 for each
replica’s VABA chain. However, as we shown in our asyn-
chronous fallback protocol (Figure 5), the number of blocks
can be reduced to just 2, by the following observations: (1)
We adopt 2-chain commit instead of 3-chain commit, and thus
immediately reducing the latency by 1 RTT; (2) We observe
the one extra RTT during the leader nomination phase for ex-
changing commit proofs is unnecessary once we have chained
blocks, as the information is embedded in the blockchain and
replicas can learn the commit from the chain. Therefore, we
are able to reduce the latency of each view by 4 rounds (2
RTTs), and since the expected number of views VABA needs
to execute is 3/2, the reduced latency is 4 × 3/2 = 6 rounds.

21

