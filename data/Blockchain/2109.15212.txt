1
2
0
2

p
e
S
0
3

]

R
C
.
s
c
[

1
v
2
1
2
5
1
.
9
0
1
2
:
v
i
X
r
a

A formal model for ledger management systems based
on contracts and temporal logic

Paolo Bottoni, Anna Labella

Department of Computer Science - Sapienza University of Rome - Italy

Remo Pareschi

Stake Lab - University of Molise - Italy

Abstract

A key component of blockchain technology is the ledger, viz., a database that,

unlike standard databases, keeps in memory the complete history of past trans-

actions as in a notarial archive for the beneﬁt of any future test. In second-

generation blockchains such as Ethereum the ledger is coupled with smart con-

tracts, which enable the automation of transactions associated with agreements

between the parties of a ﬁnancial or commercial nature. The coupling of smart

contracts and ledgers provides the technological background for very innovative

application areas, such as Decentralized Autonomous Organizations (DAOs),

Initial Coin Oﬀerings (ICOs) and Decentralized Finance (DeFi), which propelled

blockchains beyond cryptocurrencies that were the only focus of ﬁrst generation

blockchains such as the Bitcoin. However, the currently used implementation

of smart contracts as arbitrary programming constructs has made them sus-

ceptible to dangerous bugs that can be exploited maliciously and has moved

their semantics away from that of legal contracts. We propose here to recom-

pose the split and recover the reliability of databases by formalizing a notion of

contract modelled as a ﬁnite-state automaton with well-deﬁned computational

characteristics derived from an encoding in terms of allocations of resources to

actors, as an alternative to the approach based on programming. To complete

the work, we use temporal logic as the basis for an abstract query language that

is eﬀectively suited to the historical nature of the information kept in the ledger.

Preprint submitted to Blockchain: Research and Application

October 1, 2021

 
 
 
 
 
 
Keywords: Ledger, Contract, Database, Transaction, Automata theory,

Temporal logic.

1. Introduction

Blockchains and distributed ledgers are nowadays among the information

technologies having the greatest impact.

Initial success has come to public

blockchains, starting with the mother of all of them, that of Bitcoin, which has

cleared the large-scale practicability of cryptocurrencies, i.e., currencies freed

from central issuing authorities and governed by the community of their users.

Public blockchains of the next generation, such as Ethereum, have combined the

community-based management of cryptocurrencies with the experimentation

and practice of new forms of organization and ﬁnance, such as decentralized au-

tonomous organizations (DAOs), initial coin oﬀerings (ICOs) and decentralized

ﬁnance (DeFi). Finally, private distributed ledgers, of which the best known

and most practiced are the platforms developed within the Hyperledger open-

source project, have released the potential for organizational innovation of these

technologies from the support of cryptocurrencies, thus making it possible to

involve brick-and-mortar companies in innovative business ecosystems.

At the base of all this there is a fundamental technological component, re-

ferred to here as the “digital ledger”, which is nothing more than a database

management system (DBMS) that preserves the history of all its records by

appending new versions of records to previous ones and linking them together

through identiﬁers such as hash pointers. Several DBMSs that predate the

coming of age of blockchains work that way, like the popular Hadoop ﬁle sys-

tem (HDFS) largely adopted for big data management. Distributed ledgers

are a special case of digital ledger where the validation of transactions takes

place through a consensus mechanism over a network of peer nodes. Public

blockchains, in turn, specialise distributed ledgers by grouping transactions on

records into blocks built by nodes rewarded for the construction with the native

currency of the blockchain. Private distributed ledgers are yet another special-

2

ization, as are public distributed ledgers based on data arrangements alternative

to blocks, such as the IOTA platform, aimed at supporting Internet-of-Things

applications, that uses instead directed acyclic graphs.

However, there is more, in the latest ledgers that have entered the arena in

the wake of the blockchain boom, than just decentralized validation of trans-

actions through distributed consensus protocols. There are, in fact, smart con-

tracts: conceptually introduced by the multifaceted scholar Nick Szabo (jurist,

cryptographer, computer scientist) at the end of the 1990s for computer-based

automated execution of legal contracts of a commercial nature [1], the idea

stayed dormant until it was dusted oﬀ from oblivion by Vitalik Buterin, the

founder and creator of Ethereum, in the mid-10s of this century, who transferred

it to the eponymous blockchain by equipping it for implementation with Solid-

ity, a contract-oriented programming language [2]. Ethereum’s move was soon

repeated on other platforms, both public and private, and there is now ample

opportunity for smart contracts in blockchain and distributed ledger projects.

The reason why smart contracts lend themselves particularly well to imple-

mentation on a “distributed ledger” is actually more on the “ledger” than on

the “distributed” part of the term.

In fact, the permanence of data on the

ledger makes the execution of smart contracts traceable, which of course is an

advantage for auditing purposes whenever need may arise, as in a due diligence

or a litigation. On the other hand, also distributed consensus can support trace-

ability, albeit less essentially, by multi-checking the execution of the agreements

made through many validators, which strengthens the claim to veracity of the

transcribed data in the absence, by choice or necessity, of a reliable central au-

thority. In any case, what really matters is operating in a context predisposed

to auditing, such as a digital ledger by its nature is.

However, it is precisely the choices made for the implementation of smart

contracts that have distanced the platforms that have adopted them both from

the database characteristics of ﬁrst generation distributed ledgers like the Bit-

coin and from smart contracts as originally conceived. In fact, although referred

to as a contract-oriented language, Ethereum’s Solidity is actually a scripting

3

language that can write on the blockchain. Similarly, in other environments,

such as Hyperledger, smart contracts are programs written in conventional lan-

guages that can access the ledger. These programming tools have certainly been

useful in propelling the application of distributed ledgers beyond cryptocurren-

cies, but have also created reliability problems by making possible constructs

of dubious semantics and arbitrary complexity; witness among all the notori-

ous DAO exploit of 2016 in which a still unknown hacker exploited a bug in a

Solidity smart contract to steal $ 50 million from the Ethereum common pot.

Moreover, they have weakened the relationship between smart contracts and

legal contracts as originally conceived by Szabo and taken up in intent, but not

in practice, by Buterin; indeed, there is very little in common between the text

of a commercial contract and a program in Solidity.

The purpose of this article is to deﬁne a general ledger model with contracts

seen as declarative constructs on a database, rather than as arbitrary proce-

dural programs, with well-deﬁned operational characteristics in the tradition of

advanced transaction approaches such as the renowned ACID model. To this

end, we propose a bare-bones view of contracts based on the notion of allocation

of resources to actors, so that a contract deﬁnes admissible evolutions of states

of aﬀairs deﬁned by sets of such allocations.

At the same time, our model aims to make legal contracts in textual form

eﬀectively transferable and translatable into executable contracts, thus recov-

ering the original idea of smart contract as introduced by Szabo. Hence, we

propose two forms of contract-related automata: the ﬁrst identiﬁes the possible

states of the contract with respect to the completion of some sets of obligations,

where the discharge of an obligation is modeled as the transfering of some re-

source from some actor to another one; the second provides a reﬁned view of

the ﬁrst, taking into consideration the possible orderings in which obligations

can be discharged, thus turning a ledger into a faithful record of the sequence

of transfers actually occurred during the execution of the contract.

On our way towards a model endowed with full-ﬂedged DBMS characteris-

tics, we will also deal with querying, by providing constructs to verify progress

4

in a contract execution, a functionality that is badly needed in practice, as well

as to query the ledger by scrolling it back and forth in time, with advanced query

modes ranging beyond the still rather limited solutions currently available. The

formal cornerstones of our model are the theory of automata and temporal logic,

formalisms that have been both rigorously systemized and theorized. As for dis-

tribution and centralization, we will be agnostic about the issue, since our model

can be adapted to either one of the two options. For the organization of the

data, we will maintain the minimal requirement that they are organized as in a

ledger. This does not preclude more specialized organizations, like blocks, the

model being easy to extend and adapt to ledgers structured as blockchains.

The rest of this article is structured as follows: Section 2 introduces some

background notations and deﬁnitions. Section 3 provides the fundamental no-

tions of resource, actor and transfer, so that a contract can be seen as deﬁning a

set of constraints on sequences of transfers of resources between actors. Section 4

shows how a legal contract understood as a set of interdependent obligations

can be modeled in computational terms by deﬁning admissible paths on some

contract-related automaton, where transitions are associated with the discharge,

through transfers of resources, of obligations. Section 5 then shows how contract

automata can be integrated with a ledger so that their actions are transcribed

as records into the ledger, while Section 6 builds, from the algebraic structure

of ledgers and contracts, modal/temporal logics used in Section 7 to deﬁne an

abstract query language that can be applied to extract information about both

static (the records in the ledger) and dynamic (the states of contracts whose

execution is in progress) aspects of a contract execution. Finally, Section 8

discusses related work and Section 9 concludes the article.

2. Background

We recall some basic notions and notations, useful in the rest of the paper.

For n ∈ N, the set of all integers from 1 to n is denoted by [n]. An alphabet

is a ﬁnite set A = {a1, . . . , ak}, where each element ai is called a member of A.

5

For k ∈ N, a sequence ω = (cid:104)x1 · · · xk(cid:105) of elements from A is called a word on A

of length k. We use the notation ω[i] to indicate the element xi for i ∈ [k]. We

denote the length of a sequence ω by |ω| and the unique word of length 0 by (cid:15).

Then, the set of all words on A (for each possible length) is denoted by A∗.

Given a partially ordered set (X, ≤), if (x, y) ∈≤, then x is called a preﬁx

of y and y is called a prolongation of x. Vice versa, given a preﬁx relation on a

set X, its transitive closure deﬁnes a strict partial order.

It is easy to see that the above deﬁnition translates to the standard notion

of preﬁx for the case of words. Indeed, given a word ω = (cid:104)x1 · · · xk(cid:105), for each

l ≤ k, the word ωl = (cid:104)x1 · · · xl(cid:105) is the preﬁx of ω of length l, denoted by

pref (ω, l). For any word ω, pref (ω, 0) = λ. We denote by P REF (ω) the set

{pref (ω, l) | l ∈ {0, . . . , |ω|}}. A∗ results thus partially ordered according to

the preﬁx relation, i.e. ω ≤ ω(cid:48) if and only if ω ∈ P REF (ω(cid:48)).

A partially ordered set (L, ≤) forms a meet-semilattice, L = (L, ≤, ∧, •), if

it can be equipped with a meet operation, ∧ (i.e., greatest lower bound), and

a minimum element, •. Then, a tree is a set of elements, called paths, in a

meet-semilattice with the meet operation as a gluing function between them.

Deﬁnition 1 (L-tree). Let L = (L, ≤, ∧, •) be a meet-semilattice. Then:

• A deterministic L-tree ( tree for short) is a pair X = (X, ∧X ), where

X ⊆ L and ∧X : X × X → L is the restriction to X of the meet ∧.

• An L-tree is called preﬁx-closed if it contains all the preﬁxes of its paths.

• Given two L-trees X = (X, ∧X ) and Y = (Y, ∧Y ), we say that X is a

subtree of Y, noted X ⊆ Y, if X ⊆ Y (⊆ denotes set-theoretical inclusion).

Given a meet-semilattice L = (L, ≤, ∧, •), the tree L = (L, ∧) is canonically

associated with L and formed by taking as set of paths the whole of L and

deﬁning the gluing of data between paths as given by the ∧ operation.

Proposition 1. Let L = (L, ≤, ∧, •) be a meet-semilattice and L = (L, ∧) its

canonically associated tree. Then:

1. a preﬁx-closed L-tree is a meet-subsemilattice of L;

6

2. the set of subtrees of L, Subtree(L), with set-theoretical inclusion as par-

tial order, is a boolean algebra (see [3]); and

3. given X ∈ Subtree(L), the set of subtrees contained in X , Subtree(X ), is

a boolean algebra in turn (see [3]).

We deﬁne an important property of monotonic functions between posets, by

specialising to this case the general notion of adjunction between functors.

Deﬁnition 2 (Adjoints). Given two posets, P = (X, ≤) and P (cid:48) = (X (cid:48), ≤(cid:48)),

and two monotonic functions, f : P → P (cid:48) and g : P (cid:48) → P , we say that f is

right adjoint to g (g is left adjoint to f ) whenever it happens that: for all x ∈ X

and x(cid:48) ∈ X (cid:48), x(cid:48) ≤ f (x) if and only if g(x(cid:48)) ≤ x.

In other words: f (x) is the least upper bound of the set {x(cid:48) | g(x(cid:48)) ≤ x}.

Dually, g(x(cid:48)) is the greatest lower bound of the set {x | x(cid:48) ≤ f x}. In the case

of posets, an adjunction is also called a Galois connection.

Fact 1. The following hold:

1. An adjoint to a given function, if it does exist, is unique, hence it is

characterised by this property.

2. Composition of two adjoints on the same side is still an adjoint on the

same side. We say that the ﬁrst one is preserved by the second one.

3. Boolean operators are adjoints on one side (∧, ⇒ on the right, ∨, ⊥ on

the left), so that they are preserved by operators adjoint on the same side.

In this sense a monotonic function between Boolean algebras which is a

one-side adjunction, will provide what we call a smooth translation from

one algebra to the other one, because it will preserve part of its structure;

a fortiori if it is a two-side adjunction.

3. Resources, actors, transfers

In this section, we introduce a bare-bones view of contracts, seen as con-

structs imposing constraints on admissible sequences of transfers of resources

7

(from some given set), among actors (from some given set), entitled to some

form of ownership on these resources. The proposed model was ﬁrst formulated

in [4] and fully developed within the theory of reaction systems in [5].

The deﬁnition of these sets can occur either extensionally or intensionally.

An example of a ﬁrst case is provided by a loan contract, where both the lender

and borrower parties are identiﬁed by names, the lent resource is identiﬁed by

means of some title of property, the transfer of the right to its use by the posses-

sion of a copy of the text of the contract itself, and the number of instalments to

be payed is deﬁned and timestamped. An example of the second case is provided

by bearer bonds, where the assets are identiﬁed, but the only identiﬁed actor is

the emitter of the bond, or, vice versa, by a Memorandum of Understanding,

whereby two actors commit to share future products, which are only partially

deﬁned, e.g., by mentioning their types, at the time of the contract.

The constraints set by the contract, on the other hand, range from general,

overarching conditions, such as: “an actor k cannot transfer a resource r in a

situation where k is not entitled to the use of r”, to speciﬁc ones, as in the

mentioned case of regular payments of a loan.

Another category of constraints may impose some kind of transactionality,

such that a certain set of transfers have to occur ”simultaneously” among some

actors. In the loan example, with each payment received from the borrower, the

lender must produce a receipt for it and give it to the borrower. Moreover, the

execution of some transfer can be conditional on the occurrence of some event,

for example the expiration of a deadline for payment of instalments, or a car

accident for starting a damage compensation procedure.

Regardless of these diﬀerences, we assume that the general form of a transfer

can be expressed as “actor k1 yields resource r to actor k2”, assuming that r,

k1, and k2 are all unambiguously identiﬁed at the time the transfer occurs.

Moreover, as we are interested here in the encoding of transfers on a digital

ledger, we assume that each of r, k1, and k2 is suitably represented by some

URI, corresponding, respectively, to a digital token representing the asset r, or

to (possibly encrypted) accounts in a digital store associated with the ledger.

8

Example 1. Let us consider the case of a contract binding AL to sell a house,

say house1 (i.e., to transfer some property document house1PropDoc) to PB,

and PB to pay a certain amount, say e500K, to AL. The actual payment (in

the “real” world) is mediated through some identiﬁable resource, e.g., a set of

banknotes, a cashier’s cheque from PB’s account in the name of AL, a certain

amount of bitcoins in PB’s wallet, etc., that we represent here abstractly as

the unique token PayKE500Doc1, testifying that the payment has occurred (this

is equivalent to, say, having a copy of the cheque taken in the real world and

registered by the notar). Then, the two transfers, of house1PropDoc from AL

to PB and of PayKE500Doc1 from PB to AL, constitute a transaction, as they

must occur “at the same time”, meaning that any observation of the execution

of the contract which reports the ﬁrst exchange must also be able to report on

the second exchange, and vice versa. We say that these two transfers are co-

occurent. On the other hand no transfer of PayKE500Doc1 from PB to some

k1 other than AL (since the token is produced for this speciﬁc transaction) or

of house1PropDoc from AL to some k2 other than PB (since the house cannot

be sold two times) can be co-occurrent with the previous two.

To sum up, we view any, virtual or tangible, asset or service mentioned in a

contract, and whose creation, consumption, or transfer, is relevant to the con-

tract, as a resource. More precisely, we consider that at each moment some token

representing some form of (possibly shared) ownership of a resource is allocated

to some actor also mentioned in the contract. Instances of such tokens are the

payment instrument and the property document mentioned in Example 1.

In this paper, as we abstract away from the actual form and nature of the

resources, being only interested in how the corresponding tokens are distributed

among actors at any given moment (we call such a distribution a state of aﬀairs),

we use the terms (resource) “token” or “resource”, indiﬀerently. Hence, with

each contract, we associate a nonempty set, R, of resource tokens, constituting

the overall universe of discourse.

The set R can be constructed so as to accommodate quotas of some bulk

9

resource, in analogy with shares of a company. So, for example, the right

to use 100 liters of water delivered by WaterInc.

can be represented as

[water, W aterInc, 100, R], where R is a unique identiﬁer generated on the ﬂy.

On the other hand, we see an actor as representing an individual entity

bound by a contract and participating in transfers of resource tokens, whether

at the yielding or at the receiving end. We assume that for any given contract

the actors who may participate in it cannot be also regarded as resources, so

that they are modeled as a nonempty set K, with K ∩ R = ∅.

We model the information that a token r is held by some actor k as the

allocation of r to k, noted [r, k]. A state of aﬀairs on (R, K) is then deﬁned

as a set of allocations such that each token in R is allocated to one and only

one actor in K. Hence, we model a state of aﬀairs ς as the graph of a map

sς : R → K, The set of all states of aﬀairs on (R, K) is denoted by S(R, K).

Note that, according to the discussion above, although each token is unique, we

can model joint ownership of a resource by generating a diﬀerent token for each

quota of that resource to which an actor is entitled.

A state of aﬀairs evolves through exchanges of tokens among actors, possibly

as part of complex transactions. Thus, the yielding of a token r by an actor

k1, originally holding it, to an actor k2 (cid:54)= k1, which becomes the holder of r,

constitutes a transfer, noted θ = (r, k1, k2). Then, r is the transferred resource,

denoted by res(θ). The set of all transfers on (R, K) is denoted by T RA(R, K).

Although the “real” transfer of resources may occur physically in some way

not controlled by a program, a distributed ledger trusted to maintain informa-

tion on the contract must be updated about such transfers as they occur, i.e.,

it has to maintain the record of the transfers undergone by the corresponding

tokens. At any time instant, the current allocation of a resource can thus be

reconstructed by following the sequence of transfers for its associated token(s).

To this end, we say that a transfer θ = (r, k1, k2) ∈ T RA(R, K) is applicable

in a state of aﬀairs ς ∈ S(R, K) if and only if [r, k1] ∈ ς. Then, AP L(ς) is the

set of transfers applicable in ς. Given R and K, for θ = (r, k1, k2) ∈ T RA(R, K)

and ς ∈ S(R, K), such that θ ∈ AP L(ς), the application of θ to ς, noted aplθ(ς),

10

produces ς (cid:48) = (ς \ {[r, k1]}) ∪ {[r, k2]} ∈ S(R, K).

As stated before, contracts may require a given set of transfers to be co-

occurrent. Their application must then occur in a transactional way, i.e., all

transfers in the set are applied to a given state of aﬀairs ς if they are all applicable

in ς, and no transfer in the set is applied if any of them is not applicable in ς.

Due to the overall constraint prohibiting multiple transfers of the same token

from the same actor, and the constraint that each token can be held by only

one actor at a time, the transfers in the set must refer to diﬀerent resources.

Therefore, we deﬁne a bundle to be a nonempty set of transfers Θ =

{θ1, . . . , θn} such that res(θi) (cid:54)= res(θj), for i (cid:54)= j, i, j ∈ {1, . . . , n}. The set of

all bundles for (R, K) is denoted by BU N (R, K). A bundle Θ ∈ BU N (R, K)

is jointly applicable in ς ∈ S(R, K) if, for each θ ∈ Θ, θ ∈ AP L(ς). We then de-

note the set of bundles jointly applicable in ς by JP L(ς). The joint application,

of Θ ∈ BU N (R, K) to ς ∈ S(R, K), such that Θ ∈ JP L(ς) (noted jplΘ(ς)),
produces ς (cid:48) = (ς \{[r, k1] | (r, k1, k2) ∈ Θ})∪{[r, k2] | (r, k1, k2) ∈ Θ} ∈ S(R, K).

During the execution of a contract, resources which were originally not in

the availability of any participating actor can become available, as if produced

in compliance with the contract. For example, a certain required document can

be printed and kept by a notar as legal registration of some act; or a deliverable,

required in a tender contract, hence typically not existing before the contract was

put in place, can be produced as required during the execution of the tender. On

the other hand, some resource can become no longer available for any exchange,

as for example a car crashed in an accident covered by an insurance policy. In

order to model such cases, we enrich the set K with the special symbols (cid:62) and

⊥, deemed environment actors, with the property that, for any resource r ∈ R,

both allocations [r, (cid:62)] and [r, ⊥] are admissible, while no transfer of the form

(r, ⊥, k) is admissible. We call the elements in K \ {(cid:62), ⊥} proper actors and

allocations of the form [r, k], for some k (cid:54)∈ {(cid:62), ⊥}, proper allocations.

The introduction of (cid:62) and ⊥ also provides a way to formalise the occurrence

of events relevant to a contract (e.g., the deadline for an instalment is reached,

an accident report is submitted, a cargo is delivered) in a way formally identical

11

to transfers of tokens. In particular, we deﬁne a set Ev ⊆ R of event tokens

(short, events), such that, for e ∈ Ev, any ς ∈ S(R, K) can contain only one

of [e, (cid:62)], representing a situation where the event e has not occurred yet, or

[e, ⊥], representing a situation where e has already occurred, Then, the only

possible transfer for e is (e, (cid:62), ⊥) modeling the occurrence of the event. As a

consequence, an event occurs atomically and can never occur again.

A typical usage of transfers associated with event occurrences is to insert

them into bundles, for transactions which must occur in correspondence with

speciﬁc events. For example, in the loan contract, an instalment must be payed,

and the corresponding receipt must be signed, with each 10th day of the month.

4. Modeling contracts

In this section, we show how a notion of contract, seen as a formal con-

struct deﬁning a structured collection of obligations, can be modeled in terms

of resources, actors, and transfers, as introduced in Section 3.

In particular, we show how speciﬁc bundles of transfers, whose application

transforms states of aﬀairs into states of aﬀairs related to a universe S(R, K),

correspond to transitions of a ﬁnite-state machine describing the possible execu-

tions of a contract on (R, K). This constitutes the basis for relating sequences

of transfers encoded in a ledger, as discussed in Section 5, to the evaluation of

queries on the excution of the contract, as discussed in Sections 6 and 7.

In essence, a contract must state, at least implicitly: the conditions of its

validity; the acts through which the obligations of the contract are discharged

and the conditions under which such acts can be carried out; and the situations

corresponding to the completion of the obligations set by the contract (we then

say that the contract is honoured ) as well as those corresponding to a breach

of these obligations. The latter may be associated with repair or compensation

actions, which may thus be seen as alternate ways for honouring the contract,

or as constituting the deﬁnition of a diﬀerent contract altogether.

We can then encode the legal form of a contract C in a legal contract au-

12

tomaton, a ﬁnite state machine Ml

C = (V l, El, F, sl, tl, Act, T O, λl, υ), where
conditions correspond to states and the discharge of all of the obligations lead-

ing from a state to another corresponds to transitions.

In particular: V l is

the set of state nodes (short, states); El is the set of transition edges (short,

transitions), with sl : El → V l the source map and tl : El → V l the target

map; F ⊆ V l is the set of ﬁnal states; Act is the set of obligation-discharging

actions, with T O ⊆ Act the set of timeout actions; λl

: El → ℘(Act) is a

function labeling each transition with the set of actions needed for its ﬁring;

and υ : F → {HON, BRC} is a function mapping each ﬁnal state into the

corresponding outcome (honoured or breach).

We assume that if a timeout action to is in λ(η) for some η ∈ El, then to

is the only action in λ(η), i.e., the latter is a singleton. Moreover, we assume

that C is such as to induce a strongly deterministic automaton Ml

C, in the sense
that for η1, η2 ∈ El such that sl(η1) = sl(η2), neither λl(η1) ⊆ λl(η2), nor
λl(η2) ⊆ λl(η1) hold, while the case λl(η1) ∩ λl(η2) (cid:54)= ∅ is admitted.

The usual notion of trajectory between states, as given by the sequence of

transitions leading from one to the other, can then be adapted to Ml

of all trajectories in Ml

C is denoted by Πl
(i.e., originating in the initial state of Ml

C. The set
C and the set of all initial trajectories
C) is denoted by Πl,in

.

C

We introduce a sketch of a part of an insurance policy as a running example.

Example 2. Fred has activated a comprehensive insurance policy for his car

with the company SURE!, whereby a black box has been mounted on Fred’s car.

As a part of this policy, the coverage of expenses to repair car damages, even if

due to natural causes, is provided, according to a certain procedure, deﬁning a

contract Cd. In particular, the procedure starts when a damage event occurs and

the blackbox makes a report on it available to Fred. Then Fred has the possibility

to ﬁle a claim for reimbursement on the SURE! system and to upload the report

on its server. Then, the SURE! system will issue an oﬀer for reimbursement to

Fred, who might accept or reject it. If Fred communicates that he accepts the

oﬀer, the SURE! system issues both a refund order and a communication that

13

the policy premium is increased. If Fred communicates that he rejects the oﬀer,

no further action is needed. Each act must be performed within some deadline.

We sketch here the content of states and transitions deﬁning Ml
Cd

.

1. The procedure enters the Active state when the damage event occurs AND

the damage report is produced. A deadline is set to present the claim.

2. The Claimed state is reached when the claim is ﬁled AND the report

is acquired, before the deadline expires. At this stage, an obligation for

SURE! to make an oﬀer becomes active, which must be discharged before

a set deadline, on pain of violating the contract.

3. The Oﬀered state is reached when the reimbursement oﬀer is made, so

that the obligation is discharged. An obligation for FRED to respond

to the oﬀer is activated. This can be discharged by either accepting or

rejecting the oﬀer, but also by simply letting the deadline pass, after which

the proposal becomes void (this would not constitute a violation).

4. The Accepted state is reached when FRED accepts the reimbursement

oﬀer. An obligation for the SURE! system to issue the refund AND to

apply the raise to the premium is then activated. Also this obligation is

under pain of violating the contract, if not discharged within the deadline.

5. The Refunded state is reached when the SURE! system issues the refund

AND applies the raise in the premium, before the deadline.

6. The Rejected state is reached when FRED rejects the oﬀer.

7. Each missed deadline brings into a corresponding state. Deadlines missed

by SURE! represent a violation, while those missed by FRED do not.

Figure 1 depicts the resulting legal contract automaton Ml
Cd

. Each state

from which no transition starts, namely Rejected, Refunded, and each of the

four Out states, is in F , as it represents a possible completion of the procedure.

For v ∈ F , v is depicted in green if υ(v) = HON , in red if υ(v) = BRC.

It is to be noted that the procedure above is activated in the SURE! sys-

tem each time a damage is recorded, and proceeds according to the same steps

14

Figure 1: The ﬁnite state machine for the contract from Example 2.

independent of whether the customer is FRED or any other. Moreover, the

contract might even be realised as a service and oﬀered to insurance companies

which might customise it, e.g., by setting deadlines, setting maximum refunds,

or deﬁning premiums and their raise. Without loss of generality, we can there-

fore consider that, for each insurer and customer, a fresh instance of the contract

(and of the associated state machine) is always ready to control the next proce-

dure, the state IN in Figure 1 representing the initial state for such an instance.

We now proceed to modeling contracts in terms of the approach presented

in Section 3.

Indeed, leveraging the notions of resource, actor, transfer, and

bundle, we identify all types of conditions in the contract with predicates on

states of aﬀairs and the required actions with transfers. The latter is to say

that an obligation is considered to be discharged when there is evidence that

some actor has provided some resource (which might represent a physical asset,

access to services, or execution of some task) to some other actor, i.e., a transfer

of the corresponding token has been recorded. Where the contract requires a

certain set of obligations to be completed before a diﬀerent set comes into force,

we model this in terms of a bundle of co-occurrent transfers.

Hence, the discharge of obligations in a legal contract automaton Ml

C encod-
ing a contract C realises some change in the states of aﬀairs for an underlying

system of tokens in a set RC (one for each piece of documentation mentioned

in the contract) and actors in a set KC (one for each party involved in the con-

tract). In particular, given a state of aﬀairs in S(RC, KC) holding in the initial

state of Ml

C, each sequence of discharge actions (i.e., transfers) leads to the

15

production of some state of aﬀairs in S(RC, KC). It is now important to notice

that, while a state transition is realised only when all the obligations needed are

discharged (i.e., all the transfers in a bundle have been applied), it might be the

case that other transfers, not composing a whole bundle, have been applied.

As an example, Out0 is reached whenever the event (timeOut0, (cid:62), ⊥) occurs

before both transfers corresponding to the discharge of the claim and sendDoc

obligations have been applied. Hence, once Ml
Cd

reaches the state Out0, there

are three possible corresponding states of aﬀairs: one for not having applied

either of claim or sendDoc, and one each for having applied just one of them.

Moreover, not all states of aﬀairs in S(R, K) can be mapped to some state

of a legal contract automaton on (R, K). For example, a state of aﬀairs where

a claim has been ﬁled but the report of the damage event has not been made

available, or, vice versa, such a report is available, but no claim has been ﬁled

(yet) for that accident, does not correspond to any state of Ml
Cd

, as a consistent

state will be reached only when both of the associated transfers will have been

applied (or the timeOut0 event will have ﬁred.).

The model based on Ml

state machine, univocally induced from Ml

C must therefore be integrated with a second ﬁnite
C, the contract execution automaton
C = (V e, Ee, F, se, te, Act, T O, λe, υ), deﬁned on the same sets of actions and
C, which considers all possible sequences of actions (transfers)
in a concrete execution of the contract, compatible with its legal deﬁnition. In

ﬁnal states as Ml

Me

Me

C, transitions are labeled with single actions, realised individually, and not

with a set of actions to be completely realised for the transition to occur.

In particular (and specifying only the components not inherited from Ml

C):
V e ⊇ V l is the set of states; Ee is the set of transitions, with se : Ee → V e the

source map and te : Ee → V e the target map; and λe : Ee → Act is a function

labeling each transition with the speciﬁc action needed for its ﬁring.

The derivation of Me

C from Ml

C proceeds according to Construction 1.

Construction 1. We isolate three components of the construction.

1. First, we include in V e the whole of V l. Then, for η ∈ El, we build

16

all the “intermediate” states between sl(η) and tl(η), each correspond-

ing to a nonempty proper subset of λl(η). We call Lin(η) the result-

ing set of states. For example, given the states Active and Claimed

of V l

d , Lin((Active,Claimed)) contains the states Active/Claim and Ac-
tive/Sent, corresponding to the partial realisations of the set of actions

λl((Active,Claimed)) = {claim, sendDoc}.

2. Then, for η ∈ El, we include in Ee all the transitions connecting sl(η)

to tl(η) through the states in Lin(η). That is to say that, for η ∈ El,

and for s1, s2 ∈ Lin(η) ∪ {sl(η), tl(η)}, respectively associated with sets
α1, α2 = α1 ∪ {a} for a ∈ λl(η) \ α1, Ee will include a transition between

s1 and s2 labeled with a. Note that this also includes transitions leaving
s(η) (where α1 = ∅) and transitions reaching t(η) (where α2 = λl(η)). For
example, in Ee

d a transition exists from Active to each of Active/Claim
and Active/Sent, labeled with the corresponding action, and from each of

Active/Claim and Active/Sent to Claimed, labeled with the action needed

to complement the set in the original transition from Active to Claimed

i.e., sendDoc for Active/Claim and claim for Active/Sent.

3. The two items above are subsumed under a general construction, whereby

V e and Ee include all of the states and transitions needed to account

for the possible interleaving of actions labeling diﬀerent transitions in El

originating from a given state, until the completion of one of these sets

(no two transitions from the same state are labeled with the same set

of actions), thus keeping track of the “progress” towards completion of

each such set. To this end, for a state v ∈ V l, we take all the transi-

tions in El with source in v, let this be T (v), and add to V e a node for
each set in ℘(U (v)) \ Cmpl(v), where U (v) = (cid:83){λl(η) | η ∈ T (v)} and
Cmpl(v) = {X ∈ U (v) | ((cid:64)η ∈ El)[λl(η) ⊆ X]}.

In other words, we

consider all possible subsets in the union of all the sets of actions labeling

these transitions, minus those subsets corresponding to the completion of

one transition, as only one such set can be completed. Indeed, all and only

17

the states in V l are taken to correspond to the completion of λl(η) for any

η ∈ T (v). (This also means that once a state v(cid:48) ∈ V l is reached (i.e.,

λl(η) has been completed for some η ∈ T (v), v(cid:48) = tl(η)), all the actions

representing progress towards other states become irrelevant, as a diﬀerent

set of intermediate states is constructed for transitions in T (v(cid:48))). Then,

the set Ee includes all the needed transitions between these states, one for

each action representing an increment towards completion of λl(η), for

some η ∈ T (v). Transitions are only added towards reaching a state in

V l which is the target for the corresponding transition in El, as defeasing

of actions is not admitted. Note that by deﬁnition of timeout state, each

such state is reached with just one action, so that a timeout would in-

terrupt any possible trajectory in Me

C not yet landed in a state from V l.
For example, irrespective of whether the timeOut0 event occurs in Active,

Active/Claim, or Active/Sent, it immediately completes the singleton set

of actions needed to reach Out0. Hence, in addition to a transition from

Active to Out0, generated in Item 2, Ee

d has a transition to Out0 from

each of Active/Claim and Active/Sent, both of them labeled timeOut0.

Similarly to the case for Ml
the set of initial trajectories by Πe,in
trajectories in Πe,in

C

C

C, we denote the set of trajectories in Me

C and
. The diﬀerence between considering all

C by Πe

or only those passing through only the intermediate states

built in Lin(η) for some η ∈ El, (which correspond to a trajectory in Πl

C) will

play an essential role in the deﬁnition of the logics in Section 6.

Another caveat is in order. In principle, a state of aﬀairs, even if containing

allocations for all of the resources and actors involved in a contract, might in-

clude allocations for a set of resources concerning other aspects of their rapport.

For example, and extending Example 2, some tokens in the complete model

for a car insurance policy between an insurer company and a customer might

refer to topics such as coverage of theft, extension of civil liability, deadlines for

payments, etc, not relevant to the procedures for damage management. Hence,

an automaton MCx (either legal or execution) might simply model some spe-

18

ciﬁc section Cx in a wider contract C, relative to a universe of states of aﬀairs

S(RC, KC). Then, we should regard states in MCx as inducing some relation on

(some subset of) S(RC, KC). A compositional view of contracts can then ensue,

resulting in progressive reﬁnements of this relation.

In general, for a contract C, we will identify the subset SC ⊆ S(RC, KC),

of states of aﬀairs consistent with Ml

C, in the sense that they can occur as
the combined eﬀect of a sequence of transfers which can occur as a possible

execution of the obligations in the contract, according to Me
C.

The translation of Ml

C in terms of a (RC, KC) system proceeds as follows.

1. Each party involved in C is modelled as an actor k ∈ KC.

2. Each resource to be produced or transfered in order to discharge an obli-

gation in C is modelled as a token r ∈ RC. In particular, the production

of a document corresponds to a transfer from (cid:62) to a proper actor.

3. Each accident to be documented in C is modelled as an event e ∈ EvC ⊆

RC. The expiration of a deadline is also modelled as an event. Event

occurrences are therefore modelled as transfers of the form (e, (cid:62), ⊥).

4. Each action discharging an obligation (i.e., in Act) is modelled as a trans-

fer, in a set TRAC, of the resource associated with that obligation.

5. Each set of actions collectively ensuring a transition between states in Ml
C

is modelled as a bundle, in a set BUNC, of the corresponding transfers.

We can now deﬁne the system of resources and actors modeling a contract.

Deﬁnition 3 (Resource-based contract model). Let C be a contract and

let Ml

C = (V l, El, F, sl, tl, Act, λl, υ) be the associated contract automaton. Then
a resource-based contract model is a tuple RSC = (SC, BUNC, TRAC), together
with three mappings: γ : ΠC → ℘(SC), β : El → BUNC, and ρ : Act → TRAC,

collectively enjoying the following properties:

1. For τ ∈ΠC, η∈El, Θ=β(η): (cid:104)τ · η(cid:105)∈ΠC ⇒ (∀ς∈γ(τ ))[jplΘ(ς)∈γ((cid:104)τ · η(cid:105))].

19

2. For η ∈ El: β(η) = {ρ(act) | act ∈ λ(η)}1.

We can now show the constrution of the legal contract automaton Ml
Cd

for

the contract Cd of Example 2, managing damage events (the contract execution

automaton Me
Cd

is induced according to Construction 1). Since each arrow in

El for Ml
Cd

is unique to an ordered pair of states, we identify here an edge in

El with the corresponding pair. Moreover, since, for each state in V l, there is

a unique trajectory leading to it, we identify a state v and the corresponding

trajectory, denoted by v, in the deﬁnition of γ.

Example 3. With reference to Example 2, we deﬁne:

• RCd = {oldP rem, claim, damageEv, damageDoc, oﬀer, reject, accept, raise,

refund, out0, out1, out2, out3}.

• KCd = {customer, insurer, ⊥, (cid:62)}.

• The function γ is deﬁned as follows2:

– γ(In) = {[oldP rem, customer]} ∪ {[r, (cid:62)] | r ∈ RCd \ {oldP rem}}.

– γ(Active) = {[oldP rem, customer], [damageDoc, customer], [damageEv,

⊥]} ∪ {[r, (cid:62)] | r ∈ RCd \ {oldP rem, damageEv, damageDoc}}.

– γ(Claimed) = {[claim, insurer], [damageDoc, insurer], [damageEv, ⊥],

[oldP rem, customer]} ∪ {[r, (cid:62)]

| r ∈ RCd \ {claim, damageEv,

oldP rem, damageDoc}};

– γ(Oﬀered) = {[oﬀer, customer], [damageEv, ⊥], [damageDoc, insurer],

[oldP rem, customer], [claim, insurer]} ∪ {[r, (cid:62)] | r ∈ RCd \ {oﬀer,

damageEv, damageDoc, oldP rem, claim}};

– γ(Accepted) = {[accept, insurer], [oﬀer, customer], [oldP rem, customer],

[damageEv, ⊥], [claim, insurer], [damageDoc, insurer]} ∪ {[r, (cid:62)]

|

r ∈ RCd \ {claim, accept, damageEv, damageDoc, oﬀer, oldP rem}}.

1That is, β is completely consistent with λl.
2As is customary, we will write a singleton {φ} as simply φ, for a set φ.

20

– γ(Refunded) = {[accept, insurer], [raise, customer], [damageEv, ⊥],

[damageDoc, insurer], [refund, customer], [claim, insurer], [oldP rem,

⊥]}, ∪{[r, (cid:62)] | r ∈ {reject, out0, out1, out2, out3};

– γ(Rejected) = {[damageEv, ⊥], [damageDoc, insurer], [claim, insurer],

[oﬀer, customer], [reject, insurer]}∪{[r, (cid:62)] | r ∈ RCd \{claim, reject,

oﬀer, damageDoc, damageEv}};

– γ(Out0) = {ς∈S(RCd , KCd ) | [out0, ⊥]∈ς, [outX, (cid:62)]∈ς for X∈{1, 2, 3}}.

– γ(Out1) = {γ∈S(RCd , KCd ) | [out1, ⊥]∈γ, [outX, (cid:62)]∈ς for X∈{0, 2, 3}}.

– γ(Out2) = {γ∈S(RCd , KCd ) | [out2, ⊥]∈γ, [outX, (cid:62)]∈ς for X∈{0, 1, 3}};

– γ(Out3) = {γ∈S(RCd , KCd ) | [out3, ⊥]∈γ, [outX, (cid:62)]∈ς for X∈{0, 1, 2}}.

The set BU NCd and the function β are jointly deﬁned as follows, implicitly

deﬁning also the set T RACd and the ρ function:

– β(In, Active) = {(damageEv, (cid:62), ⊥), (damageDoc, (cid:62), customer)}

– β(Active, Claimed) = {(claim, (cid:62), insurer), (damageDoc, customer,

insurer)},

– β(Claimed, Oﬀered) = {(oﬀer, (cid:62), customer)},

– β(Oﬀered, Accepted) = {(accept, (cid:62), insurer)},

– β(Accepted, Refunded) = {(refund, (cid:62), customer), (oldP rem, customer,

⊥), (raise, (cid:62), customer)},

– β(Oﬀered, Rejected) = {(reject, (cid:62), insurer)},

– β(Active, Out0) = {(out0, (cid:62), ⊥)},

– β(Active, Out1) = {(out1, (cid:62), ⊥)},

– β(Active, Out2) = {(out2, (cid:62), ⊥)},

– β(Active, Out3) = {(out3, (cid:62), ⊥)},

By construction of RSC, one can derive the sets of sequences of bundles and

of transfers leading from any given state of aﬀairs in RSC to any other state of
aﬀairs in RSC reachable from the ﬁrst, following a trajectory in Ml
C.

21

The functions β and ρ then induce the two notions of bundle and transfer

trajectory-labeling, for trajectories in Ml

C and Me

C, respectively.

Deﬁnition 4 (Trajectory labelings). Let C be a contract, let Ml

C and Me
C
be the associated legal contract and contract execution automata, and let τ l =

(cid:104)tl

1 · · · tl

n(cid:105) ∈ Πl

C, be such that all and only the states
in V l reached with τ e are also reached with τ l, in the same order. In this case,

C and τ e = (cid:104)te

m(cid:105) ∈ Πe

1 · · · te

we say that τ e is an unfolding of τ l, and we deﬁne:

• Bβ

C (τ l) = (cid:104)β(tl

1) · · · β(tl

n)(cid:105) to be the bundle trajectory-labeling of τ l;

C(τ e) = (cid:104)ρ(te

• Lρ
1) · · · ρ(te
C(τ e) is such that only states in (cid:83)

If Lρ
visited, then we say that Lρ

n)(cid:105), to be the transfer trajectory-labeling of τ e.

η∈El Lin(η) (see Construction 1) are

C(τ e) is a linearisation of Bβ

C (τ l).

Bβ
is denoted by Bβ,in

The set of all bundle trajectory-labelings for trajectories in Πl
C is denoted by
C and the set of all bundle trajectory-labelings for initial trajectories in Πl,in
. Analogously, the set of all transfer trajectory-labelings
C is denoted by Lρ
for trajectories in Πe
labelings for initial trajectories in Πe,in

C and the set of all trajectory transfer
. A preﬁx-induced

is denoted by Lρ,in

C

C

C

C

partial order is therefore deﬁned on both sets of labelings.

1. Given two trajectories τ l

1, τ l

2 ∈ Πl

C, τ l

1≤l

Cτ l

2 iﬀ τ l

1∈P REF (τ l
2)

2. Given two bundle trajectory-labelings β1 = Bβ

C (τ l

1) and β2 = Bβ

C (τ l

2),

β1≤ββ2 iﬀ β1∈P REF (β2) iﬀ τ l

1≤l

Cτ l
2.

3. Given two trajectories τ e

1 , τ e

2 ∈ Πe

C, τ e

1 ≤e

Cτ e

2 iﬀ τ e

1 ∈P REF (τ e

2 ).

4. Given two transfer trajectory-labelings ρ1 = Lρ

C(τ e

1 ) and ρ2 = Lρ

C(τ e

3 ),

ρ1≤ρρ2 iﬀ ρ1∈P REF (ρ2) iﬀ τ e

1 ≤e

Cτ e
2 .

Remark 1. Strictly speaking, bundles and transfers are complex structures, so

that in principle we should distinguish between their deﬁnition in terms of declar-

ative speciﬁcations of behaviours modifying a state of aﬀairs and their unique

names to be used in labeling. This could be achieved by associating with each

transfer θ its unique name θ and with each bundle Θ its unique name Θ. For

22

the sake of simplicity we do not introduce this distinction here, relying on the

context to clarify whether we are referring to names or to speciﬁcations.

5. Encoding transfers on ledgers

In this section, we discuss how the model of contracts presented in Section 4,

which views them as deﬁning admissible evolutions of the state of aﬀairs of a

system of resources and actors, lends itself to the recording of sequences of

contract-related actions on a ledger, making it amenable to forms of auditing

on their compliance with the constraints set by the contract. As a consequence,

we do not simply deal with the “current” set of allocations, as maintained

in traditional databases, but we aim at reconstructing the whole “history” of

transfers involving resources and actors pertaining to a contract.

Before moving on, it is important to clarify that we only consider the record-

ing of actions on a ledger, while we are agnostic regarding the deployment of

the contract which can itself reside on the ledger, as in some blockchains, rather

than on a network node, as in other cases. In either case case the contract and

its actions are at diﬀerent levels and the focus here is on actions.

The allocation history of a resource r ∈ R can then be reconstructed by

considering, in the sequence of encodings of applied transfers, those for which

res(θ) = r. We denote the set of sequences of (encodings of) transfers (irrespec-

tive of the contract for which it has been executed) in the ledger by LT . Each

sequence σ ∈ LT is called a ledger state. Note that LT is preﬁx-complete with

respect to the standard preﬁx-order ≤ (i.e., for any σ ∈ LT , P REF (σ) ⊆ LT ).

In a centralized ledger, the recording of transfers has a natural correspon-

dence with contract execution. In a distributed environment, however, as they

can originate in diﬀerent nodes, we cannot assume that a log state records trans-

fers in the exact order in which they occurred. We can assume, however, that a

resource-safeness (see Deﬁnition 5) property holds in every encoding sequence

registered in the ledger. That is, for r ∈ R, a new transfer of r is not logged

if the previous transfer of r has not yet been transferred to the ledger. This

23

property can be veriﬁed through a simple check during coding.

Besides resource-safeness, we consider other properties, providing the basis

for some form of conformance-checking on the traces of transfers associated

with a contract. Hence, compliance to a wallet-safeness property amounts to

requiring that actors can only use resources they are entitled to (e.g., no form of

double spending can be encoded in the ledger); compliance to a bundle-safeness

property provides some form of transactionality (if we observe a transfer from

a bundle Θ for some r ∈ RC, then the next transfer for r can only appear after

Θ is completed); and compliance to a contract-safeness property, with respect

to a contract C, means that the sequence of transfers encoded in the ledger is

consistent with both partial orders, ≤β and ≤ρ, induced by Ml

C and Me
C.

Deﬁnition 5 provides a formal account of these properties. From now on, we

introduce a notion of encoding of a transfer θ = (r, k1, k2) on the ledger, noted

(cid:37)(θ). An encoding is a construct maintaining information about r, k1, and k2,

together with some metadata, such as a timestamp for its creation time, the

identiﬁer of some validation authority, or of the contract to which it refers.

Deﬁnition 5 (Properties of a ledger state). Let R be a set of resources

and let σ = (cid:104)(cid:37)(θ1) · · · (cid:37)(θk)(cid:105) be a ledger state, with res(θi) ∈ R for i ∈ {1, . . . , k}.

Then, we deﬁne:

• For r ∈ R, σ is r-safe if: for any j > i ∈ [k], such that θi = (r, k1, k2), θj =

(r, k3, k4), for some k3 (cid:54)= k2, σ contains a sub-sequence (cid:104)(cid:37)(θl1) · · · (cid:37)(θlm)(cid:105),

l1 > i, lm ≤ j, such that, for s ∈ {1, . . . , m−1}, θls = (r, kls, kls+1), with

kl1 = k2, klm = k3.

• For a contract C (so that R = RC):

– σ is C-wallet safe if it is r-safe for any r ∈ RC;

– σ is Ml

C-bundle safe if it is C-wallet safe and, for Θ ∈ β(El), θ ∈ Θ,
(cid:37)(θ) appearing in σ: no encoding (cid:37)(θ(cid:48)), with res(θ(cid:48))=res(θ), appears

in σ before all transfers in Θ have been encoded in σ.

– σ is Ml

C-contract safe if it is Ml

C-bundle safe and it is a preﬁx of

24

some transfer trajectory-labeling of Ml
C.

Proposition 2. Each of the properties in Deﬁnition 5 is decidable.

Proof:[Sketch] It is easy to see that by inspecting the sequence σC, of transfers

execution automaton Me

relative to resources in some contract C, extracted from a ledger state σ, and
comparing it with the sequences of transfers in Lρ

C (using the induced contract
C), each of the considered properties can be assessed.
In particular, a ledger state is MC-contract safe iﬀ its extracted sequence for
resources in RC is in Lρ,in

. Since a ledger state is constituted of a ﬁnite num-

C

ber of transfers, the extracted sequence σC needs to be compared with a ﬁnite
(cid:3)
number of transfer trajectory-labelings3 up to the length |σC|.

The proof is then immediate for Corollary 1.

Corollary 1. All preﬁxes of a Ml

C-contract safe state are Ml

C-contract safe.

In order to deﬁne the set of sequences of transfers encoded in a ledger,

corresponding to possible contract executions, we have to go back to the consid-

erations in Section 4 on the possibility that some bundles do not get completed,
so that some of the transfers in them appear in a labeling in Lρ,in
any linearisation of a labeling in Bβ,in

, but not in

C

.

C

In particular, resuming the arguments in Construction 1, for each state v ∈

V l, the determinism of Ml

C allows us to establish a bijection between the set
T (v), of transitions leaving v, and the set Bun(v) = {β(η) | η ∈ T (v)} of bundles
labeling these transitions. Then Trf (v) = (cid:83) Bun(v) is the set of transfers in all

the bundles labeling transitions in T (v). Let σ be a ledger state such that its last

encoded transfer “completes” a bundle in Bun(v), leading to a state v(cid:48) ∈ V l.

No bundle which has not been completed in σ can then be completed in any

prolongation of σ. As a consequence, σ comprises a sparse subsequence σ(cid:48) of

(encodings of) transfers which are parts of the transfer trajectory-labeling for a

3Remember that Lρ,in

C

is preﬁx-complete.

25

trajectory τ ∈ Πe

C leading to v(cid:48), and a sparse subsequence σ(cid:48)(cid:48) of (encodings of)
transfers not on this trajectory, and consequently, not on any trajectory which

is a prolongation of τ . We say that σ(cid:48) is “useful” and that σ(cid:48)(cid:48) is “useless”.

The reasoning can be extended to sequences which proceed beyond the last

completed bundle, i.e., after reaching a state v ∈ V l. Let σ be one such sequence

and let σv the suﬃx of σ following the completion of a bundle leading to v. Then,
if a prolongation of σv, say σ(cid:48)
will be incorporated in the useful part of (cid:104)σ · σ(cid:48)

v, leads to a new state v2, the transfers in β((v, v2))

v(cid:105), while the remaining transfers

in σ(cid:48)

v will be incorporated in its useless part.

6. An algebraic model of contracts and its logic

We can now go and resume our program of constructing a suitable logic for

ledgers and contract automata based on their associated algebraic structures.

The presented theory is inspired by, but not immediately reducible to, a general

theory introduced in categorical terms in [6], used in [3] to provide a logic

for (possibly nondeterministic) processes, and adapted to the study of contracts

in [4]. In fact, the idea originated from the natural association of a Heyting ﬁrst-

order logic to a category of generalised labeled trees, proven to be a Heyting

category and extended with several modal/temporal operators in [3]. There,

the labeling of trees via a meet-semilattice was a crucial device, since we had

to deal with a non-deterministic situation, which we modeled by allowing two

diﬀerent paths to be labeled via the same element in the meet-semilattice.

When, as here, one has a deterministic situation (i.e., one path, either in

Ml

C or in Me

C can only have a unique label), the labeling machinery can be
dropped to consider the meet-semilattice itself as a tree, and the theory can

be expressed in (po)set-theoretical terms. Indeed, the structure associated with

the set of subtrees of a tree X is now that of a boolean algebra, so that, by

using subtrees as interpretations of formulas,a boolean logic is obtained, (ex-

tendable with modal/temporal operators, see [3]), in analogy with the standard

interpretation of formulas in terms of subsets of some universe of discourse.

26

In our approach, this kind of structure can be associated both with a ledger

used to register (encodings of) transfers performed under the constraints set by

(possibly more than) one pair of contract automata, the legal and the execution

one, and with the behaviour of the contract automata themselves (or more of

them). As a consequence, we are interested in two (or more) meet-semilattices

at the same time, one derived from the sequence of transfers recorded in the

ledger, the other ones derived from the admissible initial sequences of bundles

(transfers) in a bundle (transfer) trajectory-labeling for some contract (or con-

tracts) whose executions are recorded in the ledger.

Without loss of generality, we restrict ourselves to one ledger and one con-

tract with its two automata. The involved meet-semilattices correspond to sorts

in a category canonically associated with a classical many-sorted logic, namely,

the category TSL of trees derived from meet-semilattices, with monotonic func-

tions as morphisms. Indeed, for every object X of TSL, Sub(X ) is a Boolean

algebra, and morphisms allow a canonical deﬁnition of quantiﬁers, as shown

later. The logic associated with TSL will be expanded with modal/temporal

operators, again deﬁned canonically from the order relation on paths.

Given a ﬁnite alphabet of transactions T , the monoid T ∗, of freely-generated

sequences of transactions, is canonically deﬁned. This is a meet-semilattice as

well as a tree (rooted in the empty sequence (cid:15)) in our sense; all the preﬁxes of

elements in T ∗ are still in T ∗.

However, due to the condition of resource-safeness, not all possible sequences

in T ∗ can actually constitute the record, in a ledger, of a sequence of transfers.

Hence, the tree of possible ledger states forms a preﬁx-closed proper subtree

of T ∗, LT (as per the discussion in Section 5). When a new transfer is regis-

tered on the ledger, this causes the selection in LT of all and only those paths

which present that transfer at the corresponding step, and which are like-wise

consistent at all previous steps, thus eliminating all the paths which are not its

prolongations from the possible evolutions of the ledger. This is precisely the

novelty in this approach: that we consider a special subfamily of Subtree(LT ),

namely what we call the evolutions of the ledger. If we take E0 = LT to deﬁne

27

the set of ledger states which are still reachable at time 0, by repeating this oper-

ation any number of times n, we obtain a sequence of (instantaneous) evolutions

(cid:104)E0, E1, . . . , En(cid:105) (a subset of Subtree(LT )), with Ei+1 ⊆ Ei, for i ∈ {0, . . . , n−1}.

Remark 2. We observe that, in general, one has Ei+1 (cid:40) Ei The case Ei+1 = Ei

occurs only for i = n−1, in a situation where, after applying all transfers in Ei,

the only allocation of the form (r, k), for k(cid:54)=⊥, in the resulting state of aﬀairs is

such that r ∈ Ev, so that the only possible transfer left at step i+1 is (r, (cid:62), ⊥).

In this perspective, the overall ledger evolution is modeled as a sequence of

trees on (T ∗, ≤, ∧, λ), each containing the following one in the sequence: after

having established a ﬁnite set of transfer records, only those paths which are

prolongations of it are selected to generate the preﬁx-complete tree Et, repre-

senting the instantaneous evolution at time t. Figure 2 presents an intuitive

representation of this sort of pruning, occurring from one step to the next.

Figure 2: An evolving ledger.

The resulting chain of instantaneous evolutions will in turn represent the

global evolution. Every instantaneous evolution Ek contains an initial chain of

paths (the established part coloured in red in Figure 2), of length k.

On the other hand, we can easily see, on the basis of what discussed in
Section 4, that both the set of all bundle initial trajectory-labelings in Πl,in
C ,
Bβ,in
C , with

C , and the set of all transfer initial trajectory-labelings in Πe,in

C , Lρ,in

their partial orderings, are semilattices (and trees).

We will now deﬁne an occurring function for each of them: namely νl : LT →

Bβ,in
C

(resp. νe : LT → Lρ,in

C ). Intuitively, given a contract C, an occurring

28

function extracts, from a given initial sequence σ of transfers recorded on the

ledger, the subsequence σ(cid:48) of those relative to C, and associates with it the

maximal initial trajectory of states in Ml

C (resp. Me

C) reached through σ(cid:48).

Deﬁnition 6 (Occurring maps). Let C be a contract. Then, for any σ ∈ LT :

1. Let τ l

σ be the maximal trajectory in Πl,in

C

for which there exists a monotonic

function from Bβ
C(σ) = Bβ
νl

σ) into σ. Then the map νl

C : LT → Bβ,in
C , deﬁned by
σ) is called the bundle occurring map for Ml
C.

C (τ l

C (τ l

2. Let τ e

tonic function from Lρ

σ be the maximal trajectory in Πe,in
C(τ l

C
σ) into σ. Then the map νe

for which there exists a mono-
C : LT → Lρ,in
C , deﬁned
σ) is called the transfer occurring map for Me
C.

C(σ) = Lρ

by νe

C(τ e

“Maximal” here means with respect to the ordering deﬁned on trajectories,

while the existence of a monotonic function from Bβ

C (τ l) (from Lρ

C(τ e)) into σ

implies that the trajectory τ l

σ (τ e

σ) exploits the useful part of σ.

Theorem 1. Both νl

C:LT →Bβ,in

C

and νe

C:LT →Lρ,in

C

are monotonic functions.

Proof: To prove that νl

C(σ) is uniquely
determined. Indeed, consider the ﬁrst transfer in σ completing a bundle, say the

C is a function, we need to prove that νl

bundle b; then b is the ﬁrst label in the bundle trajectory labeling for the (only)

trajectory τ (cid:48) consistent with σ. In the same way, proceeding in σ to record the

bundles progressively completed by the transfers in σ (remember that a bundle

can only be completed after reaching a state in which a transition it labels is

allowed) one obtains the bundle trajectory-labeling of τ (cid:48). But now, due to the

σ. Hence we get a monotonic function from

automaton determinism, τ (cid:48) = τ l
Bβ

C (τ l

σ) into σ, which selects that part of σ which is the linearisation of the

bundles in the bundle trajectory-labeling for τ l

σ (the useful subsequence). Since

MC is deterministic, τ l

σ is uniquely determined. The proof of the monotonicity

of νl is immediate:

if σ increases, its useful part cannot decrease and it is

possible either to reach a further state in the automaton (due to determinism,

divergence is impossible) or to remain on the same state. Transfers discarded

29

in the procedure belong to the useless part of σ. The part of the proof relative

to νe

C is trivial, since this map directly relates two sequences of transfers.

(cid:3)

Being νl and νe monotonic, a smooth correspondence is established between

subtrees of LT and of Bβ,in
e : Lρ,in

monotonic function νl

C , as well as between subtrees of LT and of Lρ,in
C → Bβ,in
also exists, factorising νe through νl.

C

C . A

In this model the tree associated with the ledger will also play the role of

“making time tick” with each registration of a new transfer; the present instant

at time t is represented by the evolution Et.

Let us investigate more formally the underlying theory: for a given X which

is an object of TSL, the system Subtree(X ) is seen as a boolean algebra, ob-

tained by equipping the subtrees of X with natural inclusions between them.

Hence, we can think of a subtree as of the interpretation of some formula. In

this acception, a subtree which is the interpretation of a formula φ is denoted

by

φ

. Starting from atomic formulas, more complex ones are interpreted via

(cid:74)

(cid:75)

the boolean operators present in Subtree(X ).

We thus obtain a notion of satisﬁability, by a path π, of a logical formula φ:

• π |=X φ iﬀ π ∈

4

φ

(cid:75)
• π |=X φ ∧ ψ iﬀ π ∈

(cid:74)

• π |=X φ ∨ ψ iﬀ π ∈

(cid:74)
• π |=X φ ∧ ¬ψ iﬀ π /∈

ψ

ψ

(cid:74)

(cid:74)

(cid:75)

(cid:75)

(cid:74)

φ

φ

∩

(cid:75)

∪

(cid:75)
φ

(cid:74)

.
(cid:75)

This logical structure is inherited by every subtree, so that we can rela-

tivise the interpretation of a formula to any given subtree, by simply taking the

intersection between the extension of the formula and the subtree.

Thus, we have a rigorous tool to vary our satisﬁability relation according to

the evolution of a ledger, because inclusions between subtrees smoothly translate

satisﬁability at step t to satisﬁability at step t(cid:48) < t.

With every instantaneous evolution Et an atomic formula Φt is associated.

4Read: π satisﬁes φ if and only if π belongs to the interpretation of φ.

30

Such a formula is taken to mean “the ledger state appears in (belongs to) Et”.

For E an instantaneous evolution (i.e., a tree) and φ an atomic formula,

denotes the subtree of E providing the interpretation of φ in E.

φ

E
(cid:75)

(cid:74)

For the set of logical operators above (as well as for the temporal ones later

on) one might deﬁne a separate notion of satisﬁability for every instantaneous

evolution Et. However, since each Et-interpretation of a formula φ can be em-

bedded into E0 by taking the E0 interpretation of φ ∧ Φt (see Deﬁnition 7), we

prefer to adopt this convention and avoid a useless proliferation of operators.

Deﬁnition 7 (Satisﬁability in evolutions). Let φ be a formula, and let σ be

a ledger state in E0. We say that σ satisﬁes φ in E0, noted σ |=E0 φ, according

to the following, by induction on the structure of φ:

• σ |=E0 φ iﬀ σ ∈

E0,
(cid:75)
• σ |=E0 φ ∧ ψ iﬀ σ |=E0 φ and σ |=E0 ψ;

φ

(cid:74)

• σ |=E0 φ ∨ ψ iﬀ σ |=E0 φ or σ |=E0 ψ;

• σ |=E0 φ ⇒ ψ iﬀ σ |=E0 φ implies σ |=E0 ψ

• σ |=E0 ¬φ iﬀ it is not the case that σ |=E0 φ.

We say that σ satisﬁes φ in Et (i.e., at step t), noted σ |=Et φ, as follows:

• σ |=Et φ iﬀ σ |=E0 φ ∧ Φt.

A similar logical structure can be produced for the meet-semilattices Bβ,in

C

C , so that all the logical operators considered in this section for LT , are

and Lρ,in
also deﬁnable in Bβ,in

C

and Lρ,in
C .

We now investigate the relationships between these algebraic structures and

their associated logics. We recall that, for a tree X which is an object in TSL,

Subtree(X ) is a boolean algebra. Theorem 2 unveils a more stringent structure.

Theorem 2. Let X and Y be two trees and let µ : X → Y be a monotonic

function. Then, the following hold:

31

• There exists a monotonic function µ−1 : Subtree(Y) → Subtree(X )5.

• The left and the right adjoints to µ−1 exist, namely existential and uni-

versal quantiﬁer (∃µ and ∀µ).

• µ−1 preserves all algebraic operators.

Proof:(Sketch)

• We deﬁne µ−1 as the function such that, for Y (cid:48) a subtree of Y, µ−1(Y (cid:48)) =

{π ∈ X | µ(π) ∈ Y (cid:48)}, which is a subtree of X . Monotonicity is immediate.

• The operator ∃µ is deﬁned, for X (cid:48) an object of TSL, by ∃µ(X (cid:48)) = {η ∈ Y |
(∃π ∈ X (cid:48))[µ(π) = η]}. This is the left adjoint to µ−1, while the operator

∀µ is deﬁned, for X (cid:48) an object of TSL, by ∀µ(X (cid:48)) = {η ∈ Y | (∀π ∈
X)[µ(π) = η implies π ∈ X (cid:48)]}, which is the right adjoint to µ−1.

• Preservation of operators is a consequence of having left and right adjoints.

As all items have been proven, this concludes the proof.

(cid:3)

Hence, we can smoothly translate formulas in one logic to formulas in the

other one, the application of µ−1 maintaining their syntactical form.

As we deﬁne our logic on a tree-shaped model with a discrete structure, Deﬁ-

nition 8 introduces the modal/temporal operators of interest, which complement

the standard logical connectives.

Deﬁnition 8 (Modal/temporal operators). Let X be a preﬁx-closed tree,

let ≤ be the preﬁx relation between its paths and let π a path in X . Then:

• π |=X ♦uφ iﬀ (∃π(cid:48) ∈ X )[π ≤ π(cid:48) ∧ π(cid:48) |=X φ]. In other words: “there is a

future of π when φ becomes true”.

• π |=X (cid:3)dφ iﬀ (∀π(cid:48) ∈ X )[π ≤ π(cid:48) ⇒ π(cid:48) |=X φ]. In other words: “in all the

possible futures of π, φ is true”.

• π |=X ♦dφ iﬀ (∃π(cid:48) ∈ X )[π(cid:48) ≤ π ∧ π(cid:48) |=X φ]. In other words: “there is a

past of π when φ was true”.

5The function µ is called a substitution.

32

• π |=X (cid:3)uφ iﬀ (∀π(cid:48) ∈ X )[π ≤ π(cid:48) ⇒ π(cid:48) |=X φ]. In other words: “for all

pasts of π φ was true”6.

Using the strong partial order < canonically associated with the weak partial

order ≤, we deﬁne the conditions for the relation Succ(π(cid:48), π) to hold as: π < π(cid:48)

and there does not exist π(cid:48)(cid:48) such that π < π(cid:48)(cid:48) < π(cid:48). The following ensues:

• π |=X NXT♦φ iﬀ (∃π(cid:48))[Succ(π(cid:48), π)∧π(cid:48) |=X φ], i.e., “there is an immediate

future of π when φ becomes true”.

• π |=X NXT(cid:3)φ iﬀ (∀π(cid:48))[Succ(π(cid:48), π) ⇒ π(cid:48) |=X φ], i.e., “for all immediate

futures of π, φ becomes true”.

Analogously, if we deﬁne that the relation P red(π(cid:48), π) holds if Succ(π, π(cid:48))

holds, we have the following:

• π |=X PRV♦φ iﬀ (∃π(cid:48))[P red(π(cid:48), π)∧π(cid:48) |=X φ], i.e., “there is an immediate

past of π when φ was true”.

• π |=X PRV(cid:3)φ iﬀ (∀π(cid:48))[P red(π(cid:48), π) ⇒ π(cid:48) |=X φ], i.e., “for all immediate

pasts of π φ was true”

Theorem 3. The temporal operators in Deﬁnition 8 enjoy the following alge-

braic properties:

1. They are all monotonic functions.

2. Squares and diamonds form temporal doctrines (see [3]). In other words,

they are left (right) adjoint (and also left (right) inverse) to inclusions of

up or down completion: namely

• ♦uφ corresponds to the minimal subobject containing

w.r.t. preﬁxes.

• (cid:3)uφ corresponds to the maximal subobject contained in

w.r.t. preﬁxes.

complete

complete

φ
(cid:74)

(cid:75)

φ

(cid:74)

(cid:75)

6Note that “future” and “past” correspond to a “d”-index (for down) and to a “u”-index
(for up), respectively, for the (cid:3) operators, while it is the other way around for the ♦ operators.

33

• ♦dφ corresponds to the minimal subobject containing

w.r.t. prolongations.

• (cid:3)dφ corresponds to the maximal subobject contained in

w.r.t. prolongations.

complete

complete

φ

(cid:74)

(cid:75)

φ
(cid:74)

(cid:75)

3. Next and previous operators also form temporal doctrines: they correspond

to left (right) adjoint to inclusions of next step or previous step completion.

Proof: The results can be obtained routinely in analogy with those in [3]. (cid:3)

Corollary 2. All of the properties of the operators in Deﬁnition 8 (in particular

their interrelations) are completely deﬁned by their being associated with adjoint

functions, hence uniquely determined.

Now we are ready to show how to deﬁne a property in one tree also using

the other one. To this end, we look at the interpretation in LT of the atomic

formula corresponding to a property w.r.t. a given Ml
C.

• σ ∈ LT is bundle-complete (noted σ |= bc) iﬀ σ(cid:48) < σ ⇒ ¬(νl(σ(cid:48)) = νl(σ)).

• σ is contract-safe if it satisﬁes ♦ubc.

The ﬁrst condition means that σ reaches a stable state of the automaton,

while the second one means that σ does not contain any spurious transfer.

7. The associated language at work

The deﬁnition of the logical (modal/temporal) operators in Section 6 im-

mediately lends itself to the deﬁnition of a query language, where a query is

formulated in terms of paths in a suitable tree, satisfying a given formula. To

start with, the language contains two atomic sentences, presented in Deﬁni-

tion 9, to be interpreted in the structure LT .

Deﬁnition 9 (Atomic sentences). Let LT be the tree corresponding to the

evolution E0 for a given ledger built on an alphabet of transfers T . Then the fol-

lowing atomic sentences are deﬁned by producing the respective interpretations.

34

• For any ledger state σ, we consider the property ≤t, which is satisﬁed if

|σ| ≤ t. In LT this corresponds to identifying the subtree χt =

composed of all the sequences in LT which are not longer than t.

≤t

(cid:74)

LT

(cid:75)

• For a transfer θ ∈ T , the operator appθ is interpreted in LT as the set of

sequences in which θ appears7, i.e., it is the subtree

appθ
(cid:74)

(cid:75)

LT .

• For a transfer θ ∈ T , the operator appθ,n is interpreted in LT as the set of

sequences in which θ appears in position n, i.e., as the subtree

appθ,n
(cid:74)

(cid:75)

LT .

The following facts test the expressivity of the language built with the atomic

sentences of Deﬁnition 9 and the operators of Deﬁnition 8.

Fact 2. Given a set of ledger states LT for a given ledger and a contract C,

we can deﬁne the following subtrees as interpretations of the respective formulas

(the ﬁrst one refers to the ledger, the other ones to a contract):

1. The interpretation in LT of appLstθ,t = (cid:87)

1≤n≤t(appθ,n ∧ χn) is given by
the tree of ledger states σ, of length at most t, with θ as last transfer in σ.

2. Given a bundle initial trajectory-labeling zB in Bβ,in

C

, let ζB be the formula

interpreted into the corresponding singleton. Then the set of bundle initial
trajectory-labelings in Bβ,in
C
prolongations of zB, is the interpretation in Bβ,in

such that they start with zB, i.e. the set of

of ♦dζB.

C

3. Given a transfer initial trajectory-labeling zL in Lρ,in

C

, let ζL be the for-

mula interpreted into the corresponding singleton. Then the set of transfer
initial trajectory-labelings in Lρ,in
set of prolongations of zL, is the interpretation in Lρ,in

such that they start with zL, i.e.

of ♦dζL.

the

C

C

4. Given the translation function νl
C
(resp. zL a labeling in Lρ,in

Bβ,in
C

C

−1

(resp. νe
C

−1) and zB a labeling in

), the set of ledger states where a pre-

ﬁx of zB (resp. zL) has been performed reaching a “legal” state in Ml
C
(resp. a possibly “intermediate” state in Me
C), is the interpretation in E0

7Actually, the paths in LT contain encodings of transfers, but for the sake of simplicity in

the rest of the section we identify the two notions.

35

−1

of νl
C

(♦d(ζB)) (resp. of νe
C

−1(♦d(ζL))).

5. The set of ledger states in LT , noted hol(r,k,t), such that, as a re-

sult of the transfers in this sequence, an agent k holds a resource

r at time t (w.r.t.
mula ♦d((cid:87)

a contract C),
t(cid:48)≤t appLst(r,k(cid:48),k),t(cid:48) ∧(cid:3)d(¬ (cid:87)

(cid:87)

k(cid:48)

t(cid:48)≤t(cid:48)(cid:48)≤t appLst(r,k,k(cid:48)(cid:48)),t(cid:48)(cid:48))).
(That is to say: at time t, the token r is with the agent k, since at some

k(cid:48)(cid:48)

is the interpretation of the for-

(cid:87)

previous time t(cid:48) it was transfered to k from k(cid:48), and in no prolongation of

the state t(cid:48), namely at t(cid:48)(cid:48) which is a preﬁx of the state at t, a transfer

towards some actor k(cid:48)(cid:48) has been recorded.)

We can now express in the language (and, possibly, use as axioms in de-

ductions) the properties required in Section 3, and assume that the following
formulas are always veriﬁed when interpreted in Bβ,in

:

C

• (cid:86)

• (cid:86)

• (cid:86)

r

r

r

(cid:86)

(cid:86)

k ¬app(r,k,k), meaning: “no transfer of the form (r, k, k) occurs”;

k ¬app(r,⊥,k) meaning: “no transfer of the form (r, ⊥, k) occurs”;

(cid:86)

k(app(r,k,⊥) ⇒ (cid:3)d (cid:86)

k(cid:48)

(cid:86)

k(cid:48)(cid:48) ¬app(r,k(cid:48),k(cid:48)(cid:48))), meaning: “once (r, k, ⊥)

has occurred, then no transfer for r can appear in any future”.

Similarly, we can assume that the formula Φt+1 ⇒ Φt is always veriﬁed when

interpreted in E0, thus formalising as an axiom of the logic the fundamental

property of immutability of ledgers.

Indeed, the formula expresses that each

evolution at time t + 1 is contained in the evolution at time t, thus formalising

the fact that “once a ledger state is reached, it is reached forever”.

7.1. Formalising queries

We now give some examples of queries we can ask a ledger w.r.t. a contract.

Let us assume that, when we write σi for a ledger state, we intend |σi| = i, i.e.
σi satisﬁes χi ∧ ¬ (cid:87)
0≤k≤i−1 χk. Hence σi satisﬁes φ will mean that this fact
happens at the instant i. Recall that an evolution Ej has only one state σi for

i ≤ j (a past, established state) and only prolongations of σj as future states.

36

1. Suppose we start recording on a ledger the transfers relative to contract

Cd of Example 1 performed according its associated contract execution au-

tomaton Me

C (with the useful part reaching a state in Ml

C). The encodings
of transfers can be registered on the ledger at diﬀerent (not necessarily con-

secutive) instants of time. We can then ask “which is the state of the legal

contract (resp. contract execution) automaton for a state of the ledger σ8,

in an evolution En, with 8 ≤ n?” The answer is given by evaluating the

formulas ∃νe(Φn ∧ χ8), with respect to the contract execution automaton,

and ∃νl (Φn ∧ χ8), with respect to the contract legal automaton.

2. A simple historical query made possible by our approach is the fol-

lowing: given an interval [i . . . j] of time instants, and ﬁxed an evo-

lution Es, j ≤ s, we can ask whether a formula φ is true for each

ledger state σk with k ∈ [i . . . j] in the evolution Es. A typical exam-

ple for φ is: hol(Eiﬀel ,a,all(X[i,j])), meaning that “In the interval between
i and j, Alice (represented as a) owns the non-fungible token certify-

ing the property of Eiﬀel tower”. Note that this notation seems to use

a new universal quantiﬁcation, but it is actually syntactic sugar:

the

query can be rolled out into a ﬁnite conjunction of queries the form

hol(Eiﬀel ,a,i) ∧ . . . ∧ hol(Eiﬀel ,a,j), as we have made in other cases. Hence,
the query is answered by the satisﬁability of φ ∧ Φs.

3. Many variations on this theme are possible. For example: given σi, we

could verify whether, in the future of it there will be a state σj verifying

φ, provided that, in its past the series of transfers θ1, ..., θk, at times

j1 ≤ ... ≤ jk, has been recorded. This is equivalent to verifying the
formula: ♦u(♦d((cid:86)

1≤n≤k app(θn,jn)) ⇒ φ).

4. A further variation is a form of hypothetical reasoning: given an evolution

Ei and a formula φ which is not true in σi ∈ Ei, is there a preﬁx σk of

σi such that φ could be true in some future of σk? In this case, we are
dealing with a ledger state σi in the interpretation of ¬φ ∧ ♦d♦uφ ∧ Φi.

37

5. A simple, but interesting, type of query is about the possibility of verifying,

at given instant i, the presence of sequences of transfers registered on

the ledger. Without loss of generality, we consider sequences composed

of two transfers: (cid:104)θ1θ2(cid:105). Then the occurrence of such a sequence on a
state is expressible by the formula: ♦d(app(θ2,n) ∧ ♦d(app(θ1,n(cid:48)))). Queries
of this kind can be structured in more complex ones like ♦d(app(θ2,n) ∧
♦d(app(θ1,n(cid:48))))∧♦u(♦d(app(θ2,m))∧♦d(app(θ1,m(cid:48)))), looking for repetitions
of the same sequence later in the time. One could weaken the condition

that the transfers occurring in the two sequences are ordinately equal, by

imposing only a certain kind of similarity: e.g., the same actors, or the

same resource, etc.

Some remarks are in order.

Technically, the construction of the interpretation of the formula in Item 3 is

equivalent to a “temporal projection via regression”: transfers are not executed,

but consequences of their hypothetical execution are veriﬁed. In practice, tem-

poral regression queries must be handled adequately to ensure that meaningful

answers return and unnecessary computational burdens are avoided. In fact,

in themselves they are subject to inﬁnite answers: think of the case in which,

starting from a state of aﬀairs in which Bob is in possession of a token that

certiﬁes his ownership of the Colosseum and Alice is in possession of a token

that certiﬁes her ownership of the Eiﬀel tower, we want to verify the possibility

of switching ownerships, with Bob and Alice taking possession, respectively, of

the French Belle Epoque building and of the Roman era stadium. One way

for this to happen is by exchanging tokens, if contracts have been deﬁned that

enable such exchanges; but this may happen an arbitrary number n of times, by

sending them back and forth for cases greater than 1, while one is presumably

interested solely in the case n = 1. In a concrete ledger management system,

managing queries of this type could be delegated to the user, by allowing her

to place limits on the time jk when the hypothesized situation occurs in the

future, or to the system, by constraining it to return only the shortest answer.

38

Queries of the type discussed in Item 5 are particularly useful and interesting

because they can act as tools for auditing and process mining on the activities

of the ledger. For example, they could be used to verify the repetition over time

of the sending of quantities of money from Bob to Alice and then from Alice to

George, which could be indicative of a laundering activity. Or they could identify

the repetition, for instance, of supplies of kitchen plinths from company A to

company B, which in turn uses them to assemble kitchen furniture which then

routinely supplies to company C that produces turnkey kitchens, fully furnished

and equipped with appliances; these repetitions may suggest connecting the

three companies in a single supply chain through optimized revenue sharing

contracts as illustrated in [7, 8].

8. Discussion and related work

Not long after its inception, database technology produced several temporal

data models [9, 10, 11]. However, these models apply to data, like bank accounts

and document versions, produced in application contexts where time is treated

as an add-on to basic data models bereft of a time dimension. By contrast, in

ledgers time is not an option, but stands out as a fundamental, albeit implicit,

aspect in the overall functioning of the system. Hence, our approach diﬀers

substantially from models such as those mentioned above precisely because we

treat time as a universal factor independent of speciﬁc data types, starting from

the assumption that all data in a ledger is set in a time dimension.

Much more recently,the works in [12] and [13] describe systems that use

relational database technologies to extract information from the Ethereum and

Bitcoin blockchains by leveraging the available meta-information, such as hash

numbers of blocks and transactions. Thus, while having signiﬁcant practical

usability, they are very coarse-grained and very speciﬁc to the environments

they are meant for, hence they do not provide for generalizable data models

with a built-in management of time.

Quite closer to our approach is the treatment of time in the Situation Cal-

39

culus [14, 15], a formal framework that provides a general theory of action by

viewing the world as a succession of situations in consequence of the execution

of admissible actions.

It has in this sense inﬂuenced our elaboration of sim-

ilar formal and computational tools to support querying in ledgers. On the

other hand, the primary applications of Situation Calculus are in the areas of

knowledge representation for planning by artiﬁcial agents, thus requiring a rich

vocabulary made up of ﬂuent predicates describing various aspects of the world

relevant for the agents’ actions. This results into “frame problems” and “ramiﬁ-

cations problems” in the update of such representations that need to be tackled

whenever even seemingly minimal changes in the state of aﬀairs take place. By

contrast, our lean representation structure links actors and resources through a

single graph, thus staying at large from laborious update processes. At a logical

level, the Situation Calculus can be reconstructed through modal/temporal log-

ics [16, 17] bearing a number of resemblances with, and sharing characteristics

of, the logics used here to provide the basis to query past, present and future

state of aﬀairs of the ledger. In particular, the modal/temporal logic versions

of the Situation Calculus share with the approach we have presented here the

management of state of aﬀairs as “possible worlds” rather than as reiﬁed entities

referred to through second-order variables as in the original version of the Situa-

tion Calculus, with considerable simpliﬁcations in the technical treatment of the

underlying semantics. Temporal and dynamic logics are used in [18, 19, 20] to

address dynamic aspects of the blockchain, orthogonal to those discussed here,

such as, respectively, the guarantees given by the validation protocols to agents

involved in contractual transactions and the management of provisional blocks.

The relationships between legal contracts, smart contracts, transactions and

blockchains are wide and varied and unfold from a multiplicity of applications

and of disciplinary contexts. Long before blockchains became commonly used

technologies, and quite independently of them, the concept of smart contract

was introduced by Nick Szabo in the 1990s [1]. The focus and fundamental

motivation for this conceptualization stems from the observation made by Sz-

abo that the contracts of the legal tradition, especially those pertinent to the

40

commercial sphere, establish that transactions, in the commercial sense of the

term, must be carried out in conjunction with given events, such as the payment

deadline for a rent, mortgage or leasing contract. In the treatment given by Sz-

abo, a contract can therefore be seen as the automation of the transactional part

of a legal contract, with the guarantee that the transactions will be eﬀectively

carried out, as well as the ability to automatically manage infringements of the

agreed conditions without having to resort straight away to legal proceedings -

for example by automatically sending a warning letter in the case of an over-

due payment, or by electronically locking access to rented premises in case of

accumulation of non-payments. With this conceptualization of smart contracts,

Szabo aimed to increase the eﬃciency in the execution of the underlying legal

agreements, as well as to decrease legal disputes arising from any infringements.

However, time was not yet ripe for the concept to pass into practice and im-

plementation, and it will take more than two decades for Szabo’s pioneering

contribution to gain light and consideration.

In the meantime, the idea was born of transferring the technology of ad-

vanced DBMS transactional models beyond the fences of the single company,

so as to leverage them to support business eco-systems made possible by the

concurrent advent of technological trends such as Web services, service-oriented

architectures and, generally, of distributed systems hinging on cross-entity com-

puter interactions. Early attempts to adapt the most advanced of such mod-

els, based on the properties of Atomicity, Consistency, Isolation and Durability

(ACID), to implement complex e-commerce transactions spanning multiple busi-

nesses are described in [21, 22, 23]. However, substantial diﬃculties faced by

such models were rooted in the fact that the short-lived nature of ACID transac-

tions as conceived for single corporate domains did not ﬁt well with the longer-

life requirements of multi-business transactions. Alternatives to the timed-out

resource-locking of traditional ACID models were thus introduced, in particular

compensating transactions [24], although these too proved insuﬃcient to make

the envisaged business model ﬂy, in the absence of a trustable infrastructure for

cross-enterprise transaction execution. Meanwhile, a transaction model such as

41

BASE (Basic Availability, Soft-state, Eventual consistency)8, characterized by

weaker constraints with respect to ACID, was successful in the practice of dis-

tributed applications such as social networks and e-commerce stores, that can

be handled without taking care of demanding contractual requirements.

But the coming of age of blockchains showed that the last word had yet to

be said about the feasibility of bringing together the world of commercial con-

tracts and of digital transactions.

Indeed, second-generation blockchains like

Ethereum revived and brought all the previous attempts together, by leveraging

the digital trust aﬀorded by blockchain technology to resurrect and implement

Szabo’s proposal. Yet, here too there are a number of weaknesses to address,

as smart contracts implemented in Ethereum and other blockchains [25] bring

together basic transactions but are not inherently transactional, in the sense of

being bound by a well-deﬁned and veriﬁable set of properties that deﬁne the

eﬀects of their execution on the database, while they are instead treated as

programming constructs in dedicated or conventional programming languages.

Specialised languages and frameworks for smart contracts include Solidity on

Ethereum9 and private distributed ledgers maintaining records of all the per-

formed (atomic) transactions like Fabric from the Hyperledger software ecosys-

tem 10. As these languages and frameworks usually lack a proper formal foun-

dation, but may, on the other hand, be Turing-complete [26], problems arise

with respect to veriﬁcation, both of their behavioural properties and of the

conformity between a contract’s textual deﬁnition and its programmatical im-

plementation. This has led to a number of problems like the already mentioned

notorious concurrency bug that aﬀected the DAO smart contract through which

Ethereum itself was funded [27]. By contrast, our formalization of a contract as

an automaton forces a rigorous division of its various execution phases, so as to

provide a declarative model transparent to aspects of access to resources. Fur-

8www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing
9https://docs.soliditylang.org/en/latest/#,https://ethereum.org/en/
10https://www.hyperledger.org/use/fabric, https://www.hyperledger.org

42

thermore, the ability, intrinsic to our formalization, to impose interdependencies

between the various transactions that make up a smart contract substantially

reproduces the atomic characteristics of the ACID paradigm, without however

binding them to the release and roll-back of resources after time-out, which

would disagree with contexts of use populated by actors that can be ﬂexible on

their times to respond to requests.

At the same time, our model is suﬃciently general to be independent from

any implementation infrastructure (also the original formulation by Szabo ab-

stracted from speciﬁc execution models), and yet compatible with various de-

ployments on ledgers, distributed ledgers and blockchains. Finally, it could also

be synthesized from optimization procedures as in the case of the “intelligent

smart contracts” for innovative supply chain management illustrated in [7, 8]

with implementation, respectively, in a public blockchain (Ethereum) and a

private distributed ledger (Hyperledger Fabric).

Another aspect for which the implementation of smart contracts as programs

is unsatisfactory is that the relationship with legal contracts is substantially

weakened, if not lost altogether, a relationship whose reconstruction is a speciﬁc

objective of this work. In this sense, there are parallels and convergence with

other eﬀorts in a similar direction. The work in [28] ﬁrst recognized that to make

a legal contract computer-executable requires the availability of suitable formal

models for specifying its intended (legal) semantics. As concerns this latter

point, two proposals, both named Contract Automata and based on similar

principles, are contained in [29] and [30].

In [29], states of the automaton correspond to sets of permissions and obli-

gations to execute some actions. A state transition occurs when a permitted

action in a state is performed, giving rise to a new conﬁguration of permis-

sions/obligations. The main goal is to verify the soundness of the contract, for

example to check that any action for which there is an obligation in a given state

is also permitted in that state. The treatment is restricted to two-party con-

tracts, so that a state is annotated with a four-tuple of sets of deontic clauses,

describing, for each party, what its permitted actions and its obligations are.

43

No explicit consideration is given to the resources needed to perform the action,

as the assumption is that if a part p has permission to perform an action a, p

will succeed in performing a, if it tries. The authors suggest that the possibility

of checking the actual feasibility of a could be modeled by introducing a dif-

ferent action attempt a which then becomes the object of the permission. This

extension could open the way for an explicit discussion of the conditions, i.e.,

of the resources needed, for an attempt to be successful.

The model in [30] considers multi-party contracts, where each participant is

modeled by an automaton, and a contract describes the conditions under which

transitions in the diﬀerent automata can be synchronised. Here, each party

oﬀers or requests the execution of some action, and synchronisation is achieved

when requests by one party are matched by oﬀers from another one. In this

case, oﬀers and requests may concern resources produced by a participant and

consumed by another one. Synchronisation can also be weakened, provided that

requests and oﬀers are matched in the end, thus introducing a form of credit,

to be honoured before the end of the contract. Various logics for reasoning on

contracts are then derived and compared.

Finite-state machines are also at the basis of VeriSolid [31, 32], a tool to

specify contracts to be deployed on Ethereum. The generated contracts are

secure by design, as they do not allow some sequences of actions (invocations

of a Solidity function), thus reducing the expressiveness of Solidity. Plugins can

impose further constraints, for instance requiring that functions are invoked

according to the linear order provided by some shared program counter.

These models do not consider resources in the deﬁnition of state, and, lacking

a notion of transaction as set of actions, transitions occur on single actions.

A connection between the notion of contract (actually, the almost equiva-

lent notion of policy) and the notion of resource has been drawn in [33]. There,

policies are deﬁned in terms of admissible paths in the space state of some actor

subject to the policy. State transitions have to be synchronised with correspond-

ing transitions in the state of some resource necessary to realise the transition

(where the resource state typically describes the availability of the resource for

44

some actor). This is achieved by annotating states in a policy with resources,

and expressing synchronisation through constraints on valid annotations. The

model of allocations of resources to actors adopted in this paper can be seen as

equivalent to the form of annotation adopted there, especially since allocation

systems fully support the notion of state for both resources and actors.

9. Conclusions

The approach to reasoning on evolutions of ledgers introduced in this paper

starts from a formalisation of actions required by a contract in terms of transfers

of tokens representing speciﬁc resources between speciﬁc actors; the recording

of these transfers on ledgers marks the advancements in the contract’s execu-

tion. This provides the basis for the construction of computational solutions

that appear advantageous and appropriate for the evolution of the technolog-

ical paradigm to which these constructs are associated. These solutions have

been expressed at a level of maximum generality and abstraction so as not to

place restrictions on their transferability to a wide variety of concrete imple-

mentation contexts. Speciﬁcally, we have shown that the resulting notion of

ledger state is compatible with query mechanisms that can be translated into a

modal/temporal logic where it is possible to query the present, the future and

the past of the ledger, as well as its “present perfect” and “nearest future”, and

also to reason counterfactually with respect to what would have happened if the

course of things, that is, of transactions, had been diﬀerent. Maximum ﬂexi-

bility is thus guaranteed in the auditing of activities on the ledger. Moreover,

the formal characterization of contracts as automata allow us to treat them

as advanced transactional models, rather than as programs, as is the case in

the current practice of smart contract implementations. This model reproduces

some of the properties of the well-established ACID model in the context of

ledgers and contracts, such as consistency, atomicity in the sense of interde-

pendence between transactions, declarativeness in the access to resources used

for the completion of contractual obligations. It therefore generalizes, at an ab-

45

stract and formal level, indications and proposals for an eﬀectively transactional

treatment of smart contracts, which is desirable in order to avoid programming

errors that have plagued their practice in the past, sometimes with disastrous

ﬁnancial consequence, and to boost eﬀectiveness in contract execution. The two

contributions come together, as the query logic can be used to audit the progress

and actual execution of contracts built on the basis of these formal criteria.

Acknowledgements

Work partially supported by Sapienza, project “Consistency problems in

distributed and concurrent systems”. We thank the anonymous referees for

indication on how to improve this paper.

References

[1] N. Szabo, Formalizing and securing relationships on public networks, First

Monday 2 (9).

[2] V. Buterin, Ethereum whitepaper (2013).

URL https://ethereum.org/en/whitepaper/

[3] P. Bottoni, D. Gorla, S. Kasangian, A. Labella, A doctrinal approach to

modal/temporal heyting logic and non-determinism in processes, Mathe-

matical Structures in Computer Science 28 (4) (2018) 508–532.

[4] P. Bottoni, D. Gorla, S. Kasangian, A. Labella, Modal epistemic logic on

contracts: A doctrinal approach, in: Models, Languages, and Tools for

Concurrent and Distributed Programming - Essays Dedicated to Rocco De

Nicola on the Occasion of His 65th Birthday, Vol. 11665 of LNCS, Springer,

2019, pp. 298–314.

[5] P. Bottoni, A. Labella, Transactions and contracts based on reaction

systems, Theoretical Computer Science (2021) 1–50doi:10.1016/j.tcs.

2021.07.012.

46

[6] S. Kasangian, A. Labella, Observational trees as models for concurrency,

Mathematical Structures in Computer Science 9 (6) (1999) 687–718.

[7] P. Bottoni, N. Gessa, G. Massa, R. Pareschi, H. Selim, E. Arcuri, Intelli-

gent smart contracts for innovative supply chain management, Frontiers in

Blockchain 3 (2020) 52.

[8] P. Bottoni, N. Gessa, G. Massa, R. Pareschi, D. Tortola, Distributed ledgers

to support revenue-sharing business consortia: a hyperledger-based imple-

mentation, in: Proc. BRAIN 2021, 2021, to appear.

[9] R. T. Snodgrass, Developing Time-Oriented Database Applications in SQL,

Morgan Kaufmann, 1999.

[10] R. T. Snodgrass, The TSQL2 Temporal Query Language, Kluwer, 1995.

[11] A. U. Tansel, J. Cliﬀord, S. K. Gadia, S. Jajodia, A. Segev, R. T. Snod-

grass, Temporal Databases: Theory, Design, and Implementation, Ben-

jamin/Cummings, 1993.

[12] S. Bragagnolo, H. Rocha, M. Denker, S. Ducasse, Ethereum Query Lan-

guage, in: Proc. WETSEB@ICSE 2018, ACM, 2018, pp. 1–8.

[13] K.-B. Yue, K. Chandrasekar, H. Gullapalli, Storing and querying bitcoin

blockchain using SQL databases 17 (2019) 24–41.

[14] J. McCarthy, P. Hayes, Some philosophical problems from the standpoint

of artiﬁcial intelligence, in: B. L. Webber, N. J. Nilsson (Eds.), Readings

in Artiﬁcial Intelligence, Morgan Kaufmann, 1981, pp. 431–450.

[15] R. Reiter, Knowledge in Action: Logical Foundations for Specifying and

Implementing Dynamical Systems, The MIT Press, 2001.

[16] J. van Benthem, McCarthy variations in a modal key, Artiﬁcial Intelligence

175 (1) (2011) 428–439.

47

[17] G. Lakemeyer, The situation calculus: A case for modal logic, Journal of

Logic, Language, and Information 19 (4) (2010) 431–450.

[18] J. Y. Halpern, R. Pass, A knowledge-based analysis of the blockchain pro-

tocol, Electronic Proceedings in Theoretical Computer Science 251 (2017)

324–335.

[19] B. Marinkovic, P. Glavan, Z. Ognjanovic, T. Studer, A temporal epistemic

logic with a non-rigid set of agents for analyzing the blockchain protocol,

J. Log. Comput. 29 (5) (2019) 803–830.

[20] K. Br¨unnler, D. Flumini, T. Studer, A logic of blockchain updates, Journal

of Logic and Computation 30 (8) (2020) 1469–1485.

[21] J. Andreoli, S. Freeman, R. Pareschi, The coordination language facil-

ity: Coordination of distributed objects, Theory Pract. Object Syst. 2 (2)

(1996) 77–94.

[22] J. Andreoli, F. Pacull, R. Pareschi, XPECT: A framework for electronic

commerce, IEEE Internet Comput. 1 (4) (1997) 40–48.

[23] J. Andreoli, F. Pacull, D. Pagani, R. Pareschi, Multiparty negotiation of

dynamic distributed object services, Sci. Comput. Program. 31 (2-3) (1998)

179–203.

[24] R. Karlsen, T. Strandenæs, Trigger-based compensation in web service en-

vironments, in: Proc. ICEIS, 2003, pp. 487–490.

[25] M. Garriga, S. Dalla Palma, M. Arias, A. De Renzis, R. Pareschi, D. A.

Tamburri, Blockchain and cryptocurrencies: A classiﬁcation and compar-

ison of architecture drivers, Concurrency and Computation: Practice and

Experience e5992 (2020) 1–21.

[26] Z. Zheng, S. Xie, H.-N. Dai, W. Chen, X. Chen, J. Weng, M. Imran, An

overview on smart contracts: Challenges, advances and platforms, Future

Generation Computer Systems 105 (2020) 475–491.

48

[27] Q. DuPont, Experiments in algorithmic governance: A history and ethnog-

raphy of “The DAO”, a failed Decentralized Autonomous Organization,

in: M. Campbell-Verduyn (Ed.), Bitcoin and Beyond, Routledge, 2017, pp.

157–177.

[28] D. Magazzeni, P. McBurney, W. Nash, Validation and veriﬁcation of smart

contracts: A research agenda, IEEE Computer 50 (9) (2017) 50–57.

[29] S. Azzopardi, G. J. Pace, F. Schapachnik, G. Schneider, Contract automata

- an operational view of contracts between interactive parties, Artif. Intell.

Law 24 (3) (2016) 203–243.

[30] D. Basile, P. Degano, G. L. Ferrari, Automata for specifying and orches-

trating service contracts, Log. Methods Comput. Sci. 12 (4) (2016) 1–51.

[31] A. Mavridou, A. Laszka, Designing secure Ethereum smart contracts: A

ﬁnite state machine based approach, in: S. Meiklejohn, K. Sako (Eds.), FC

2018, Revised Selected Papers, Vol. 10957 of LNCS, Springer, 2018, pp.

523–540.

[32] A. Mavridou, A. Laszka, E. Stachtiari, A. Dubey, Verisolid: Correct-by-

Design smart contracts for Ethereum, in: I. Goldberg, T. Moore (Eds.),

FC 2019, Revised Selected Papers, Vol. 11598 of LNCS, Springer, 2019,

pp. 446–465.

[33] P. Bottoni, A. Fish, A. Heußner, F. Parisi-Presicce, Resource-aware poli-

cies, J. Vis. Lang. Comput. 38 (2017) 84–96.

49

