XLPN: Efficient and Scalable Cross-Ledger Protocols for the
Topological Consortium of Permissioned Blockchains

Dongfang Zhao
University of Nevada, Reno, United States
dzhao@unr.edu

1
2
0
2
c
e
D
0
3

]

B
D
.
s
c
[

1
v
3
8
8
4
1
.
2
1
1
2
:
v
i
X
r
a

ABSTRACT
While increasingly more application-specific blockchains, or ledgers,
are being implemented and deployed, exchanging information be-
tween these ledgers remains an open problem. Existing cross-ledger
protocols (XLPs) exhibit a variety of limitations such as scalabil-
ity, liveness, efficiency, among others. This paper proposes a new
XLP, namely XLPN-22, which introduces a global topology for the
consortium of ledgers to achieve better efficiency and scalability of
cross-ledger data exchanges. In this work, we prove the safety and
liveness of XLPN-22 and analyze its theoretical complexity. We also
implement XLPN-22 on SciChain ledgers and evaluate it on up to
128 nodes, 8 ledgers, and 16,000 transactions. Experimental results
show that XLPN-22 outperforms two baseline protocols, namely
VLDB-20 and PODC-18, by 18–50% and 64–84%, respectively.

Cross-ledger protocols (XLPs) among an arbitrary number of
blockchains have also been studied by both the distributed com-
puting and database communities. Notably, Herlihy et al. (PODC-
18 [12]) proposed an XLP by traversing the list of ledgers on a ring
topology. However, the ring topology implies that the PODC-18
protocol takes time linear in the number of ledgers, which is not
scalable and will be impractical for a large number of ledgers.

To address the limited scalability among other concerns raised
in PODC-18, Zakhary et al. (VLDB-20 [27]) proposed a two-phase
commit (2PC) protocol that views each ledger as a conventional
“node”. The 2PC coordinator’s analog in VLDB-20 is called a witness
chain. There is no co-design of intra- and inter-ledger protocols for
performance optimization, and it is unclear how VLDB-20 handles
the blocking scenario that is a well-known issue in 2PC.

1 INTRODUCTION
1.1 Motivation
While increasingly more applications (e.g., Internet of Things [24],
scientific computing [2]) are adopting permissioned blockchains, or
ledgers, as part of their data infrastructure, the technical challenge
of exchanging information between distinct blockchains arised [28].
The key challenge of such cross-ledger data exchange lies in not
only the data itself (which has been actively studied by the data-
base community for decades) but also the consensus protocols
employed by each of the ledgers that participate in the information
exchange. To make it worse, the data exchange can happen over
an arbitrary number 𝑛 of heterogeneous ledgers, essentially form-
ing an 𝑛-party distributed transaction where each party represents
a distributed system, i.e., a permissioned blockchain. Without an
efficient and scalable cross-ledger protocol (XLP) to support the
distributed transactions touching on 𝑛 permissioned blockchains,
application-specific ledgers would be restricted to a small set of
functionalities and hardly establish the highly desired consortium
of heterogeneous blockchains.

1.2 Limitations of Existing Approaches
The exchange between two distinct types of digital currencies (e.g.,
Ethereum [10] and Bitcoin [5]) has been well supported by the
underlying public or permissionless blockchain infrastructure and
services [8]. However, these techniques are ad hoc for two-party
transactions and cannot naturally be extended to an arbitrary num-
ber of parties. Moreover, the latency of such cryptocurrency ex-
changes is in the order of hours, which might be fine for financial
transactions but is not practical for many applications such as sci-
entific computing applications [1].

1

1.3 Contributions
This paper proposes a new XLP, namely XLPN-22, to overcome the
limitations of existing protocols as discussed in the previous subsec-
tion. XLPN-22 introduces a global topology for the consortium of
ledgers, which breaks the node hierarchy within and among ledgers
such that the number of communication rounds can be reduced from
a global point of view. We prove the safety and liveness of XLPN-22
and analyze its theoretical complexity in terms of both synchronous
rounds and the number of messages. We implement the proposed
XLPN-22 protocol as well as the VLDB-20 and PODC-18 protocols
on SciChain [3] ledgers, and evaluate these three protocols on up
to 128 nodes, 8 ledgers, and 16,000 transactions. Experimental re-
sults show that XLPN-22 outperforms VLDB-20 by 18–50% and
outperforms PODC-18 by 64–84%, respectively.

2 BACKGROUND AND RELATED WORK
2.1 Elementary Topology
In this paper, we will stick to the terminology and language used in
standard topology. This section gives a quick review and a handy
reference for later sections. We will only discuss the very minimal
set of concepts and tools of topology without touching its deep
theory and broad applications, such as homology groups and coho-
mology rings on manifolds. There are excellent mathematical texts
for this subject, e.g., Munkres [21].

A topology, denoted T , is defined as a subset of the superset of
a nonempty set 𝑆, such that (i) {𝑆, ∅} ⊆ T , (ii) an arbitrary union
of elements in T is in T , and (iii) a finite intersection of elements
in T is in T . Let 𝜎 ∈ T , and |𝜎 | denote the number of elements in
𝜎. We define the dimension of 𝜎 as |𝜎 | − 1, denoted by 𝑑𝑖𝑚 𝜎. A
simplex is a set whose topology includes all the nonempty subsets
of its superset. A 𝑛-simplex is a simplex whose dimension is 𝑛; by
definition, this implies that the set underlying the 𝑛-simplex has

 
 
 
 
 
 
𝑛 + 1 elements, each of which is also called a 𝑣𝑒𝑟𝑡𝑒𝑥. Any subset of
a simplex 𝜎 is called a face of 𝜎; in particular, if a vertex 𝑣 ∈ 𝜎 and
𝜎 − {𝑣 } = 𝜏, then 𝜏 is called the face opposite 𝑣 in 𝜎. A proper face
of 𝜎 is a face whose dimension is strictly less than 𝑑𝑖𝑚 𝜎. There are
two (classes of equivalent) orientations associated with a simplex
𝜎 = [𝑣0, 𝑣1, . . . , 𝑣𝑛]1: the orientation includes even permutations of
𝜎 (𝜎 is a trivial one since it has 0 permutations of itself), and the
other includes the remainder, i.e., those odd permutations of 𝜎. A
complex is a union of simplices (the plural form of simplex). The
𝑘-th skeleton of a complex C, denoted 𝑠𝑘𝑒𝑙𝑘 (C), is the union of
faces whose dimensions are less than or equal to 𝑘. An 𝑛-simplex
is of course a complex as well, usually denoted Δ𝑛. The dimension
of a complex is defined as that of its highest-dimensional simplex.
We denote D𝑛 (𝑣) the 𝑛-dimensional unit disk centered at vertex
𝑣, i.e., the set of vertices whose distances to 𝑣 are less than or
equal to 1. The distance 1 is not necessarily Euclidean distance, any
metric space will suffice. In a Euclidean space E𝑛, a D𝑛 is simply
a solid radius-1 ball at the origin 0𝑛. It is a well-known (and easy
to verify) fact that any Δ𝑛 can be continuously mapped to D𝑛,
and the map is called a homeomorphism. The outer skin, or more
formally known the boundary 𝜕, of D𝑛 is usually referred to S𝑛−1,
an (𝑛 − 1)-dimensional sphere, or simply an (𝑛 − 1)-sphere.

2.2 Cross-Ledger Protocols
In industry, production systems have been developed for exchang-
ing cryptocurrencies. One such example is Cosmos [8], which al-
lows for Bitcoin [5] and Ethereum [10]. Although Cosmos is built
upon an open cross-blockchain protocol named sidechain [25], no
practical systems exist yet for exchanging assets between arbi-
trary blockchains other than cryptocurrency. Even for Cosmos and
sidechain, criticisms have been widely received regarding the long
latency: a cross-blockchain transaction usually takes hours, if not
days [25], to complete.

For non-cryptocurrency blockchains, they are usually deployed
to a more controlled environment. Since users of these blockchains
need to be screened before being allowed to join the network, such
blockchains are usually referred to as permissioned blockchains. A
number of leading service providers such as IBM, Oracle, Azure
Blockchain Services, and SAP have made a firm commitment to
solving many of the technical challenges that currently plague
the interoperability of permissioned blockchains. For example, the
World Health Organization, in conjunction with the help of the
aforementioned companies, was deployed a platform called Mi-
Pasa [18], which was built atop Hyperledger Fabric [15], to enable
“early detection of COVID-19 carriers and infection hotspots.” [6]
In academia, researchers have been focusing on the cross-ledger
protocols (XLPs) among an arbitrary number (i.e., more than two)
of permissioned blockchains, which exhibit a variety of applications
such as the Internet of Things (IoT) [24] and scientific computing [2].
At the writing of this paper, two of the most notable protocols
were published at PODC-18 [12] and VLDB-20 [27], respectively.
In PODC-18, Herlihy et al. proposed to process the cross-ledger
transactions through a timestamp-based approach. The key idea
is to introduce a timeout mechanism, known as time lock for the
asset to be on hold until the recipient can provide a proof that it

1Note that we use [. . . ] to denote the ordered elements in set {. . . }.

Dongfang Zhao

Figure 1: Topological view of existing cross-ledger protocols
among three ledgers.

qualifies to receive the asset within a predefined period of time.
The approach was then criticized on atomicity and scalability: the
timeout approach might render some of the parties “worse off”—
an honest party who sends out its asset and cannot receive com-
pensation due to the network delay (i.e., timeout); moreover, the
timelock requires a sequence of linked smart contracts, leading to a
time complexity proportional to the number of parties involved in
the transaction. To address the atomicity and scalability challenges
of the above approach, Zakhary et al. in VLDB-20 [27] proposed
approaches based on the conventional two-phase commit (2PC)
protocol. The VLDB-20 protocol treats each ledger as a coherent
node in its own right and applies 2PC to these nodes by assigning
a whiteness chain as the coordinator. Nevertheless, it is unclear
how to overcome the blocking scenario exhibited by 2PC. Both
PODC-18 and VLDB-20 protocols remain theoretical and there is
no implementation as of 2021. We illustrate both protocols in Fig. 1
in a simple example of 3 ledgers, each of which reaches a consensus
through a Byzantine fault-tolerant (BFT) protocol.

3 THE XLPN-22 PROTOCOL
3.1 Description
We formalize the proposed protocol, namely XLPN-22, in this sec-
tion. The three communication primitives include inter-ledger one-
to-all, inter-ledger all-to-one, and intra-ledger all-to-all. An inter-
ledger one-to-all primitive implies that a single primary server
broadcasts a message to each of the primary and backup servers
in the ledger cluster. Similarly, an inter-ledger all-to-one primitive
collects a message from all primary and backup servers at a specific
primary server. An intra-ledger all-to-all primitive triggers concur-
rent executions on all ledgers, each execution on a specific ledger
involves broadcast messages from each server in that ledger.

XLPN-22 has five phases of message passing, not counting the
request from the client to the cluster of ledgers. The first phase
is VOTE-REQ, which is initiated by the primary of an arbitrary

2

BFTprimaryBFTbackup           Existing XLPs:1: Timelock (PODC'18)2: Witness chain (VLDB'20)Ledger 2Ledger 1Ledger 3User 1User 2User 3XLPN: Efficient and Scalable Cross-Ledger Protocols for the Topological Consortium of Permissioned Blockchains

ledgers in the complex induced by the ledger cluster. In fact, because
a broadcast message is considered as a communication primitive,
the nodes from all ledgers can be viewed as in the same (subset of)
set of the vertices in the complex, where each vertex represents a
specific node in the ledger cluster and the complex represents the
cohesion of the ledger cluster. Let 𝑘 denote the number of ledgers
and 𝑛 denote the (constant, for simplicity) number of nodes in each
ledger. Those inter-ledger messages essentially translate the ledger
cluster into a (𝑘𝑛 − 2)-simplex, or Δ𝑘𝑛−2. Geometrically, the ledger
cluster turns to be equal to S𝑘𝑛−2, i.e., the boundary of a (𝑘𝑛 − 1)-
dimensional disk in the Euclidean space (up to homeomorphism).

3.1.2 Phase II: VOTE-PREP. In this phase, all nodes receive the
request and prepare for the possible commit of the transaction. To
ensure the local consensus among the nodes within the same ledger,
an all-to-all communication primitive is triggered. This is illustrated
in the second column named VOTE-PREP in the three-ledger ex-
ample of Fig. 2. It should be noted that in conventional Byzantine
fault-tolerant (BFT) protocols, these votes (within each ledger) are
communicated in two rounds: PRE-PREPARE and PREPARE. In
XLPN-22, we do not need the PRE-PREPARE round because the
VOTE-REQ phase disperses the initial request to all backup servers.
As for topological properties of VOTE-PREP, because of the all-
to-all communication primitive, each ledger can be viewed as a
series of (𝑛 − 1)-simplex, up to ⌊ 𝑛−1
3 ⌋ vertices of which can be
assigned with a value of either COMMIT or ROLLBACK (due to the
Byzantine nodes). The entire ledger complex has 𝑘 such simplices,
all of which are disconnected. Eventually, all nodes in the same
ledger will reach a consensus, leading to a single (𝑛 − 1)-simplex
whose vertices are assigned with the same value (e.g., COMMIT) at
the end of VOTE-PREP. For more details of reaching a single simplex
in a consensus problem, we recommend the excellent text [13].

3.1.3 Phase III: READY. In this phase, each node replies back to
the initiator with its own decision that is agreed upon by at least
2𝑓 + 1 nodes (including itself) in the same ledger, where 𝑓 denotes
the number of faulty (Byzantine) nodes and 𝑓 < ⌊ 𝑛−1
3 ⌋. From a
communication point of view, this phase is basically the reverse of
VOTE-REQ. This phase can be also understood as the analogy of
the response phase of the conventional two-phase commit (2PC)
protocol. Indeed, the initiator (e.g., 𝐴0 in Fig. 2) works as a coordi-
nator in a 2PC protocol, and this initiator will make the final call
about whether or not to commit the transaction depending on the
votes collected from the nodes. The initiator will decide to commit
the transaction only if all nodes agree to commit it; otherwise, the
transaction will be canceled.

Speaking of topology, the all-to-one communication induces an-
other Δ𝑘𝑛−2 complex. However, if we take into account the direction
of the messages, their orientations are all changed; for example, the
oriented 1-simplex [𝐴0, 𝐴1] from phase VOTE-REQ now changes
to [𝐴1, 𝐴0] in phase READY, which is a 1-permutation of [𝐴0, 𝐴1].
There are far-reaching implications of simplex orientation, notably
the Alexander duality, though we will not discuss this subject any
further in this paper.

3.1.4 Phase IV: COMMIT-REQ. This phase is yet another one-to-
all inter-ledger communication from the initiator to all other nodes.
The purpose of this broadcast is to inform all nodes of the final

Figure 2: Cross-ledger protocols among three ledgers, each
of which comprises four nodes.

ledger. The second phase is VOTE-PREP, where each server sends
and receives a message to and from every server within the same
ledger. The third phase is called READY, representing a collection
call from all nodes to the initiator of XLPN-22. The fourth phase is
COMMIT-REQ, which broadcasts the decision from the initiator to
all nodes in the ledger cluster. The fifth phase is COMMIT, where
all nodes receive the initiator’s decision and reach a consensus to
complete the transaction.

We illustrate the three communication primitives and five phases
in Fig. 2, where XLPN-22 is executed in a cluster of 3 ledgers (i.e., 𝐴,
𝐵, and 𝐶), each ledger comprising 4 nodes (e.g., 𝐴0, 𝐴1, 𝐴2, and 𝐴3
for 𝐴). For brevity, we only detail the messages once for each of the
three communication primitives, and indicate other instances with
rectangle boxes of the same color as that of the detailed messages.
We will elaborate on the five phases of XLPN-22 in the following
subsections and refer back to this three-ledger example if needed.

3.1.1 Phase I: VOTE-REQ. The transaction requests are collected
at a specific node, say the primary server 𝐴0. If those requests are
submitted at different nodes, it is trivial to aggregate those requests
at the designated server. In the following discussion, we assume
the server 𝐴0 has all the information of the requested transaction
spanning over three ledgers 𝐴, 𝐵, and 𝐶.

Unlike the topological model assumed by VLDB-20 [23] and
PODC-18 [17] that only allows inter-ledger communication among
the primary servers, XLPN-22 allows direct communication cross
distinct ledgers. That is to say, 𝐴0 can talk to not only {𝐴1, 𝐴2, 𝐴3,
𝐵0, 𝐶0} but also {𝐵1, 𝐵2, 𝐵3, 𝐶1, 𝐶2, 𝐶3} as well. Technically, this
can be implemented using either the inter-communicator or the
global communicator that are part of the message-passing interface
(MPI) standard [19] (more details to be provided in §4.1).

From a topological point of view, the inter-ledger messages imply
that a 1-simplex is added to every pair of vertices residing on distinct

3

VOTE-REQVOTE-PREPA0B0C0A1A2A3B1B2B3C3C1C2COMMIT-REQInter-ledgerone-to-allCOMMITIntra-ledgerall-to-allIntra-ledgerall-to-allIntra-ledgerall-to-allREADYIntra-ledgerall-to-allIntra-ledger  all-to-allInter-ledger  one-to-allInter-ledger  all-to-oneIntra-ledgerall-to-alldecision of the transaction, commit or rollback. This is analogous
to the global commit/rollback message from the coordinator to
participants in the context of the conventional 2PC protocol. We
skip the topological discussion of this phase as it is identical to the
complex discussed previously in phase VOTE-REQ.

3.1.5 Phase V: COMMIT. In this last phase, every honest node
forwards its received decision from the initiator to other nodes in
the same ledger and then collects at least 2𝑓 + 1 copies (including
that of itself) of the same result. The honest node finally marks
the transaction as completed with the status that is agreed upon
by at least 2𝑓 + 1 nodes. It is the client’s job (not shown in Fig. 2)
to collect enough information (e.g., 𝑓 + 1 copies where 𝑓 denotes
the maximal number of faculty nodes) to be convinced that the
transaction is completed. The topology of this phase is identical to
the one of phase VOTE-PREP, and we skip the details here.

3.2 Correctness
The correctness of XLPN-22 relies on two factors: the intra-ledger
phases (VOTE-PREP and COMMIT-REQ) and the inter-ledger phases
(VOTE-REQ, READY, and COMMIT). For each ledger, one implicit
requirement is to ensure that the maximal number of faulty nodes
is strictly less than one-third of the total nodes. For simplicity, we
assume 𝑛 = 3𝑓 + 1. We also assume a synchronous model because
otherwise, consensus cannot be achieved [14].

Intra-ledger phases. There are three properties that need
3.2.1
to be followed in order to reach a consensus within each ledger:
agreement, termination, and validity. We will elaborate on each of
them in the following.

Agreement: All honest nodes must agree upon the same value.
This property can be proven in a similar way as that of the PBFT [7]
if we assume all messages in XLPN-22 messages are signed by
the sending nodes, e.g., ECDSA [16]. Employing the digital signa-
ture essentially rules out the possibility for the Byzantine nodes
from sending out discrepant messages, e.g., COMMIT for 𝐵0 and
ROLLBACK for 𝐵1, because such inconsistency can be immediately
detected by multiple receivers (honest nodes) in the ledger. Recall
that in both VOTE-PREP and COMMIT-REQ phases, (honest) nodes
acquire at least 2𝑓 +1 copies of the same decision. If there are two dif-
ferent values, say COMMIT and ROLLBACK, that have been agreed
by 2𝑓 + 1 nodes, then it implies that 2 × (2𝑓 + 1) − (3𝑓 + 1) = 𝑓 + 1
nodes have broadcast both COMMIT and ROLLBACK messages.
But this contradicts our assumption that up to 𝑓 nodes are faulty.
Therefore, both the VOTE-PREP and the COMMIT-REQ phases will
reach an agreement.

Termination: All honest nodes must terminate in finite time.
This is trivial to prove: the intra-ledger all-to-all messages take a
single round in VOTE-PREP and COMMIT-REQ, both of which are
in finite time under the assumption of a synchronous model.

Validity: The value that is agreed upon by all nodes must be one
of the input values. In XLPN-22, all the input values are the same
because they are either broadcast from VOTE-REQ or COMMIT-
REQ. Therefore, the validity property degenerates into the so-called
all-same validity, which mandates that the final decision must be
the same as the input value. Then the question becomes whether it
is possible for the initial value being COMMIT (ROLLBACK) and

4

Dongfang Zhao

the final decision being ROLLBACK (COMMIT). Let’s assume the
initial value is COMMIT and the final decision is ROLLBACK for
any of the intra-ledger all-to-all primitive. If the final decision is
ROLLBACK, it implies that there are at least 2𝑓 + 1 nodes who
broadcast ROLLBACK. Since the protocol ensures that all of 3𝑓 + 1
nodes receive the COMMIT input value, this means that 2𝑓 +1 nodes
are faulty, which contradicts our assumption of up to 𝑓 faulty nodes.
Therefore, the final decision must be the same as the input value.

Inter-ledger phases. Three are two properties that we need
3.2.2
to ensure for the three inter-ledger phases, namely the safety and
the liveness [4]. Safety says that either the transaction will be
committed or aborted in its entirety (atomicity), and liveness says
that the above result will be reached in finite time. We discuss each
perspectively in the following.

Safety: All honest nodes will either commit or rollback the trans-
action. In the previous subsection, we show that the agreement
property is guaranteed within each ledger; therefore, we only need
to show that the final decision among different ledgers is consistent.
Without loss of generality, let’s assume ledger 𝐵 decides to commit
the transaction while ledger 𝐶 decides to rollback the transaction,
in the example execution of Fig. 2. According to the validity prop-
erty, this means that some nodes receive a COMMIT command
from 𝐴0 while others receive a ROLLBACK command from 𝐴0. But
this would make 𝐴0 to be considered as a failed node because its
messages are digitally signed, which will trigger a re-election of
the initiator, e.g., 𝐵0. Therefore, 𝐴0 could not have sent discrepant
values, a contradiction to our assumption. This proves that the
values agreed upon by distinct ledgers are the same.

Liveness: All honest nodes will reach the final decision in finite
time. In normal cases where no failure happens, XLPN-22 obviously
finishes in finite time—within five rounds of message passing. We
need to show that the protocol will nonetheless complete within
finite rounds when a failure occurs. There are three cases to be con-
sidered: the failure of the initiator, the failure of primary servers,
and the failure of backup servers. If the initiator fails, we simply re-
assign another primary server as the new initiator; in a synchronous
model, this takes one round. If a primary server fails, a view-change
will be triggered, which takes two rounds (see [7] for details). If a
backup server fails, we take no action because the intra-ledger con-
sensus protocol can tolerate 𝑓 such failures. Therefore, the overall
number of rounds to handle failures is three, finite as required.

3.3 Complexity
For a fair comparison, we assume the intra-ledger consensus pro-
tocols in XLPN-22, VLDB-20, and PODC-18 are all PBFT [7]. We
are interested in two metrics: the number of synchronous rounds
taken by these three protocols and the overall number of messages
incurred by them. Throughout the following discussion, we denote
𝑛 the number of nodes in each ledger and 𝑘 the number of ledgers
in the consortium. In the following analysis, we do not consider the
failures for brevity; this can be easily calculated by adding a constant
number of two rounds since PBFT requires two rounds for updating
the primary servers (i.e., view numbers), namely VIEW-CHANGE
and NEW-VIEW. Each PBFT incurs (𝑛 + 𝑛2 + 𝑛2 + 𝑛) = 2𝑛2 + 2𝑛
messages all together from its four phases.

XLPN: Efficient and Scalable Cross-Ledger Protocols for the Topological Consortium of Permissioned Blockchains

Table 1: Complexity comparison of cross-ledger protocols.
Suppose there are 𝑘 ledgers, each of which runs PBFT among
its 𝑛 participating nodes.

Protocol

# of rounds

PODC-18 [17]
VLDB-20 [27]
XLPN-22 (this work)

10𝑘
12
5

# of messages
4𝑘𝑛2 + 4𝑘𝑛 + 4
4𝑘𝑛2 + 4𝑘𝑛 + 4𝑘
4𝑘𝑛2 + 3𝑘𝑛 + 4𝑘 − 3

Synchronous rounds. For PODC-18, there are 2𝑘 rounds for
3.3.1
the round trip of message passing for atomic swap between adjacent
pairs of ledgers. During each two-party swap, there is one PBFT
execution that takes 4 rounds (PRE-PREPARE, PREPARE, COMMIT,
and REPLY) in civil cases. If there So, there are totally 2𝑘 × 4 rounds
for PBFT. Overall, there are 10𝑘 rounds in PODC-18.

For VLDB-20, there are 4 rounds for standard 2PC among ledgers.
Within each ledger, one PBFT execution is launched in each phase
of 2PC, resulting in 2×4 rounds of message passing. Therefore, there
are overall 4 + 2 × 4 = 12 rounds of message passing in VLDB-20.
For XLPN-22, there are overall five synchronous rounds (see 3.1).

We summarize these results in the middle column of Table 1.

3.3.2 Number of messages. For PODC-18, each two-party swap
involves 2 messages plus one PBFT call, resulting in 2𝑛2 + 2𝑛 + 2
messages. Since there are 2𝑘 such two-party swaps, the overall
number of message is 2𝑘 × (2𝑛2 + 2𝑛 + 2) = 4𝑘𝑛2 + 4𝑘𝑛 + 4.

For VLDDB-20, the standard 2PC protocol between ledgers incurs
2 × 2𝑘 = 4𝑘 messages. Within each ledger, 2𝑘 PBFT executions
are launched, leading to 2𝑘 × (2𝑛2 + 2𝑛) = 4𝑘𝑛2 + 4𝑘𝑛 messages.
Therefore, the overall messages are 4𝑘𝑛2 + 4𝑘𝑛 + 4𝑘.

For XLPN-22, two intra-ledger phases incur 2𝑘 × (2𝑛2 + 2) =
4𝑘𝑛2 + 4𝑘 messages. Three inter-ledger phases incur 3 × (𝑘𝑛 − 1) =
3𝑘𝑛 − 3 messages. The overall number of messages is 4𝑘𝑛2 + 3𝑘𝑛 +
4𝑘 −3. We summarize the results in the right-most column of Table 1.

3.4 Recovery
The failure of the initiator would cause the transaction to rollback,
which can be easily detected by a heartbeat protocol. Unlike conven-
tional 2PC protocols, we can appoint the primary server of another
ledger as the new initiator without waiting for the recovery of
the original initiator. The detail has been discussed in the liveness
property in the previous subsection.

The failure of the primary server within each ledger will trigger
a view-change of all ledgers. This is different from conventional
BFT protocols because we now need to synchronize the new view
number across the consortium of ledgers. For brevity, we do not
explicitly formalize the view-change procedure, which can be found
in any standard text of distributed systems, e.g., [26].

4 EVALUATION
4.1 Implementation
We implement the proposed protocol (XLPN-22), as well as two
baseline protocols (VLDB-20 [27] and PODC-18 [12]), on a cluster of
SciChain instances [3]. SciChain is a blockchain prototype crafted
for scientific data management (especially for provenance), which

5

is presumably to be deployed as a permissioned distributed ledger.
SciChain was implemented with the Message Passing Interface
(MPI) through a Python language binding called mpi4py [20], which
is built on Open MPI [22] that is implemented mostly with C and
Shell script. This work contributes about 1,500 lines of code.

The original SciChain implementation did not allow inter-ledger
communication because a SciChain instance is managed by a global
communicator in its own right. When implementing the cross-
ledger protocols, we create regional communicators for different
groups of nodes, each of which represents a distinct ledger. Obvi-
ously, those groups collectively form a partition of the set of all
participating nodes managed by the global communicator. By do-
ing so, intra-ledger communication can go through the regional
communicator while inter-ledger communication can be carried
out by the global communicator. An alternative implementation
could be directly creating multiple groups of processes and using
the inter-communicator primitives for inter-ledger communication.
The latter implementation usually provides higher flexibility for
specifying the node topology but with some performance overhead.

4.2 Experimental Setup
All experiments were carried out on the CloudLab testbed [9]. We
use the c6420 servers, each of which is equipped with Intel Xeon
Gold 6142 CPUs at 2.6 GHz, 384 GB ECC DDR4-2666 memory,
and two Seagate 1 TB 7200 RPM 6G SATA HDDs. Each server is
connected via a 1 Gbps control link (Dell D3048 switches) and a
10 Gbps experimental link (Dell S5048 switches). The operating
system image is Ubuntu 20.04.3 LTS.

We use the ByShard transaction workload [11] as our bench-
mark (i.e., the cross-shard transactions are now considered cross-
ledger transactions), but do not count the execution time other
than message passing. If not otherwise stated, the default number
of transactions in the experiments is 5,000. When evaluating the
performance impact of transaction workloads, however, we vary
the number of transactions from 1,000 to 16,000. By default, there
are 4 ledgers, each of which consists of up to 32 nodes. When eval-
uating the impact of various numbers of ledgers, we set 16 as the
number of nodes in each ledger. Overall, we use up to 128 nodes
on CloudLab [9]. All experiments are repeated three times, and we
report the average numbers along with their standard errors.

4.3 Varying Numbers of Transactions
The first experiment reports the protocol performance as a function
of varying numbers of transactions. We fix the ledger environment
by processing those transactions on 4 ledgers and each ledger has
32 nodes. We expect that the overall processing time will be propor-
tional to the number of transactions unless the network bandwidth
is saturated, which should not happen to the given workload.

Fig. 3 reports the transaction processing time of three protocols.
We observe that all three protocols exhibit an approximately linear
increase in processing time when being fed more transactions. The
results suggest that XLPN-22 incurs the shortest processing time.
For example, XLPN-22 takes 22.6 seconds to process 16,000 trans-
actions, while VLDB-20 and PODC-18 take 34.9 and 113.9 seconds
to complete the same workload; this makes the XLPN-22 protocol
35% and 80% faster than VLDB-20 and PODC-18, respectively.

Dongfang Zhao

Figure 3: Performance comparison of
three protocols when processing vari-
ous numbers of transactions. There are
4 ledgers, each having 32 nodes.

Figure 4: Performance comparison of
three protocols when 5,000 transactions
are submitted to 4 ledgers, each of which
has 8, 16, 24, and 32 nodes, respectively.

Figure 5: Performance comparison of
three protocols when 5,000 transactions
are submitted to a consortium of 2, 4, 6,
and 8 ledgers; each ledger has 16 nodes.

4.4 Varying Numbers of Nodes
The second experiment investigates the performance impact from
the ledger sizes, which refer to the number of nodes admitted to a
specific permissioned ledger. For this preliminary experiment, we
assume that (i) there are 4 ledgers in total and (ii) the number of
nodes in each ledger is the same and is selected from one of the
following values: 8, 16, 24, and 32. This is equivalent to saying that
the total numbers of participating nodes are 32, 64, 96, and 128,
respectively. Also recall that the default number of transactions is
used in this experiment, which is 5,000.

Fig. 4 reports the performance of the three protocols at different
scales of nodes. As expected, all protocols show that the processing
time increases monotonically with respect to the ledger size: The
more nodes that are involved in a distributed transaction, the more
time that needs to be taken for the transaction to complete. Unlike
the performance impact from numbers of transactions, the ledger
size seems to weigh more: the constant increment (i.e., 32 nodes)
roughly implies a doubled time span of the execution (as opposed
to the case that a doubled increment implies a doubled time span).
Unsurprisingly, the proposed XLPN-22 protocol outperforms the
baseline protocols by a significant margin (we have seen this when
discussing the performance of varying numbers of transactions). At
the largest 128-node scale, for example, XLPN-22 takes 7.5 seconds
to complete 5,000 transactions while VLDB-20 takes 10.8 and PODC-
18 takes 24.8 seconds, which implies that XLPN-22 is 31% and 70%
faster than VLDB-20 and PODC-18, respectively.

4.5 Varying Numbers of Ledgers
This section reports the performance impact made by the different
numbers of ledgers to which the distributed transaction is submitted.
To isolate other factors, we fix the total number of transactions as
the default one (5,000) and we fix the ledger size as 16—each ledger
comprises 16 nodes. We vary the numbers of ledgers from the trivial
case, i.e., two-ledger transactions, to eight distinct ledgers (again,
each having 16 nodes). That is, the largest scale of experiments
involves 128 nodes.

Fig. 5 reports the performance of the three protocols when 5,000
transactions are submitted to a federation of 2, 4, 6, and 8 distinct
ledgers, each of which has 16 participating nodes. The performance
of PODC-18 shows a similar performance pattern as the one for

6

ledger sizes (cf. Fig. 4): the impact from the number of ledgers also
exhibits the pattern that a constant factor increment (i.e., 2 more
ledgers) implies doubled processing time. However, XLPN-22 and
VLDB-20 exhibit a more mild impact than PODC-18. In fact, the
performance gap between XLPN-22 and VLDB-20 on more ledgers
is narrowed. Specifically, for a two-ledger transaction, XLPN-22
completes 5,000 transactions in 1.6 seconds, VLDB-20 and PODC-18
complete the same workload in 3.2 and 4.5 seconds; for an 8-ledger
transaction, XLPN-22 completes 5,000 transactions in 4.7 seconds,
VLDB-20 and PODC-18 complete the same workload in 5.7 and
30.1 seconds. In other words, XLPN-22 outperforms VLDB-20 and
PODC-18 by 50% and 64% on two ledgers, but then the speedup
changes to 18% and 84%, respectively, on eight ledgers. This result
suggests that for those transactions involving many ledgers (e.g.,
more than 10), VLDB-20 may be a more efficient protocol (given
the condition that all other factors are equal). We leave this as an
open question and will address it in our future work.

5 CONCLUSION AND FUTURE WORK
This paper presents a new cross-ledger protocol, namely XLPN-22,
for a consortium of permissioned blockchains. XLPN-22 advances
state-of-art protocols by co-designing the intra- and inter-ledger
protocols for distributed transactions. We analyze the topological
properties of XLPN-22 and derive its theoretical complexity in
terms of both synchronous rounds and the number of messages. We
experimentally verify the effectiveness of XLPN-22 by comparing
it against two baseline protocols, VLDB-20 and PODC-18.

This work remains at an infancy stage along this line of research.
Our future work will include: (i) Conducting more extensive exper-
iments with real-world workloads, more ledgers (e.g., 1,000+), and
other metrics such as memory footprint and network utilization,
so that we can characterize XLPN-22 regarding its performance
bottleneck, applicability, and other properties; (ii) Employing more
topological tools to better understand XLPN-22 such that in the
future we could co-design the protocol with its topological features
to meet application-specific needs; and (iii) Investigating the feasi-
bility of applying XLPN-22’s inter-ledger phases to permissionless
blockchains, e.g., how to replace XLPN-22’s BFT consensus proto-
cols with proof-of-work mechanisms without compromising the
correctness and performance of XLPN-22.

100020004000800016000Number of Transactions020406080100120Time (seconds)Processing Time for Various Numbers of TransactionsXLPN-22VLDB-20PODC-18326496128Total Number of Nodes (evenly distributed to 4 ledgers)05101520253035Time (seconds)Processing Time for Various Ledger SizesXLPN-22VLDB-20PODC-182468Number of Ledgers (each has 16 nodes)051015202530Time (seconds)Processing Time for Various Numbers of LedgersXLPN-22VLDB-20PODC-18XLPN: Efficient and Scalable Cross-Ledger Protocols for the Topological Consortium of Permissioned Blockchains

REFERENCES
[1] Al-Mamun, A., Li, T., Sadoghi, M., and Zhao, D. In-memory blockchain: Toward
efficient and trustworthy data provenance for hpc systems. In IEEE International
Conference on Big Data (BigData) (2018).

[2] Al-Mamun, A., Yan, F., and Zhao, D. BAASH: Lightweight, efficient, and reliable
blockchain-as-a-service for hpc systems. In International Conference on High
Performance Computing, Networking, Storage and Analysis (SC) (2021).

[3] Al-Mamun, A., Yan, F., and Zhao, D. SciChain: Blockchain-enabled lightweight
and efficient data provenance for reproducible scientific computing. In IEEE 37th
International Conference on Data Engineering (ICDE) (2021).

[4] Alpern, B., and Schneider, F. B. Defining liveness. Inf. Process. Lett. 21, 4 (1985),

181–185.

[5] Bitcoin. https://bitcoin.org/bitcoin.pdf, 2008.
[6] Blockchain Interoperability. https://cointelegraph.com/news/blockchain-
interoperability-the-holy-grail-for-cross-chain-deployment, Accessed 2021.
[7] Castro, M., and Liskov, B. Practical byzantine fault tolerance. In Proceedings
of the Third Symposium on Operating Systems Design and Implementation (1999),
OSDI ’99, pp. 173–186.

[8] Cosmos. https://cosmos.network, Accessed 2021.
[9] Duplyakin, D., Ricci, R., Maricq, A., Wong, G., Duerig, J., Eide, E., Stoller, L.,
Hibler, M., Johnson, D., Webb, K., Akella, A., Wang, K., Ricart, G., Landwe-
ber, L., Elliott, C., Zink, M., Cecchet, E., Kar, S., and Mishra, P. The design
and operation of CloudLab.
In Proceedings of the USENIX Annual Technical
Conference (ATC) (July 2019), pp. 1–14.

[10] Ethereum. https://www.ethereum.org/, Accessed 2021.
[11] Hellings, J., and Sadoghi, M. Byshard: Sharding in a byzantine environment.

Proc. VLDB Endow. 14, 11 (jul 2021), 2230–2243.

[12] Herlihy, M. Atomic cross-chain swaps. In Proceedings of the 2018 ACM Sympo-

sium on Principles of Distributed Computing (PODC) (2018).

[13] Herlihy, M., Kozlov, D. N., and Rajsbaum, S. Distributed Computing Through

Combinatorial Topology. Morgan Kaufmann, 2013.

[14] Herlihy, M., and Shavit, N. The asynchronous computability theorem for
t-resilient tasks. In Proceedings of the Twenty-Fifth Annual ACM Symposium on
Theory of Computing (STOC) (1993), p. 111–120.

[15] Hyperledger. https://www.hyperledger.org/, Accessed 2020.
[16] Johnson, D., Menezes, A., and Vanstone, S. A. The elliptic curve digital

signature algorithm (ecdsa). Int. J. Inf. Sec. 1, 1 (2001), 36–63.

[17] Kuznetsov, P., Rieutord, T., and He, Y. An asynchronous computability theo-
rem for fair adversaries. In Proceedings of the 2018 ACM Symposium on Principles
of Distributed Computing (PODC) (2018), p. 387–396.
[18] MiPasa Blockchain. https://mipasa.org/, Accessed 2021.
[19] MPI Standard 4.0. https://www.mpi-forum.org/docs/mpi-4.0/mpi40-report.pdf,

Accessed 2021.

[20] MPI4PY. https://mpi4py.readthedocs.io/en/stable/intro.html, Accessed 2021.
[21] Munkres, J. R. Elements of algebraic topology. Addison-Wesley, 1984.
[22] Open MPI. http://www.open-mpi.org/, Accessed 2021.
[23] Rupprecht, L., Davis, J. C., Arnold, C., Gur, Y., and Bhagwat, D. Improving
reproducibility of data science pipelines through transparent provenance capture.
Proc. VLDB Endow. 13, 12 (2020), 3354–3368.

[24] Shen, H., Badsha, S., and Zhao, D. Consortium blockchain for the assurance of
supply chain security. In 27th Annual Network and Distributed System Security
Symposium (NDSS) (2020).

[25] Sidechains. https://blockstream.com/sidechains.pdf, Accessed 2021.
[26] Tanenbaum, A. S., and Steen, M. V. Distributed Systems: Principles and Paradigms.

Prentice Hall; 2nd edition, 2006.

[27] Zakhary, V., Agrawal, D., and El Abbadi, A. Atomic commitment across

blockchains. Proc. VLDB Endow. 13, 9 (May 2020), 1319–1331.

[28] Zhao, D. Cross-blockchain transactions (gong show presentation). In Conference

on Innovative Data Systems Research (CIDR) (2020).

7

