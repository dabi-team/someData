1
2
0
2

g
u
A
2
2

]

C
D
.
s
c
[

1
v
4
0
6
9
0
.
8
0
1
2
:
v
i
X
r
a

The Power of Random Symmetry-Breaking
in Nakamoto Consensus

Lili Su ∗
ECE
Northeastern University

Quanquan C. Liu
CSAIL
Massachusetts Institute of Technology

Neha Narula
MIT Media Lab
Massachusetts Institute of Technology

August 24, 2021

Abstract

Nakamoto consensus underlies the security of many of the world’s largest cryptocurrencies, such as
Bitcoin and Ethereum. Common lore is that Nakamoto consensus only achieves consistency and liveness
under a regime where the diﬃculty of its underlying mining puzzle is very high, negatively impacting
overall throughput and latency.
In this work, we study Nakamoto consensus under a wide range of
puzzle diﬃculties, including very easy puzzles. We ﬁrst analyze an adversary-free setting and show that,
surprisingly, the common preﬁx of the blockchain grows quickly even with easy puzzles. In a setting
with adversaries, we provide a small backwards-compatible change to Nakamoto consensus to achieve
consistency and liveness with easy puzzles. Our insight relies on a careful choice of symmetry-breaking
strategy, which was signiﬁcantly underestimated in prior work. We introduce a new method—coalescing
random walks—to analyzing the correctness of Nakamoto consensus under the uniformly-at-random
symmetry-breaking strategy. This method is more powerful than existing analysis methods that focus
on bounding the number of convergence opportunities.

1

Introduction

Nakamoto consensus [20], the elegant blockchain protocol that underpins many cryptocurrencies, achieves
consensus in a setting where nodes can join and leave the system without getting permission from a cen-
tralized authority. Instead of depending on the identity of nodes, it achieves consensus by incorporating
computational puzzles called proof-of-work [9] (also known as mining) and using a simple longest-chain pro-
tocol.1 Nodes in a network maintain a local copy of an append-only ledger and gossip messages to add to the
ledger, collecting many into a block. A block consists of the set of records to add, a pointer to the previous
block in the node’s local copy of the ledger, and a nonce, which is evidence the node has done proof-of-work,
or solved a computational puzzle of suﬃcient diﬃculty, dependent on the block. The node then broadcasts
its local chain to the network. Honest nodes choose a chain they see with the most proof-of-work to continue
building upon.

Previous work deﬁned correctness and liveness in proof-of-work protocols (also referred to as the Bitcoin
backbone) using three properties: common-preﬁx, chain-quality, and chain-growth [12, 15, 22]. Informally,
common-preﬁx indicates that any two honest nodes share a common preﬁx of blocks, chain-growth is the
rate at which the common preﬁx grows over time, and chain-quality represents the fraction of blocks created
In previous work, achieving these properties critically relied on the setting
by honest nodes in a chain.

∗Correspondence author. Email: l.su@northeastern.edu.
1We use ”longest chain” to mean the one with the most proof-of-work given diﬃculty adjustments, not necessarily the one

with the most blocks, though without considering diﬃculty adjustments they are the same.

1

 
 
 
 
 
 
of the diﬃculty factor in the computational puzzles. We express this as p, the probability that any node
will solve the puzzle in a given round. Previous work analyzing Nakamoto consensus has shown that for
consistency and liveness p should be very small in relation to the expected network delay and the number of
nodes [12, 22]. For example, mining diﬃculty in Bitcoin is set so that the network is only expected to ﬁnd a
puzzle solution roughly once every ten minutes.

Requiring a small p increases block time, removing a parameter for improving transaction throughput.
One way to compensate is by increasing block size, which could result in burstier network traﬃc and longer
transaction conﬁrmation times for users. Newer chains which do not use proof-of-work seem to favor short
block times, probably because users value a fast ﬁrst block conﬁrmation: in EOS, blocks are proposed every
500 milliseconds [10] and Algorand aims to achieve block ﬁnality in 2.5 seconds [19], whereas in Bitcoin
blocks only come out every ten minutes.

Common belief is that larger p fundamentally constrains chain growth (i.e., the growth of the common
preﬁx), even in the absence of an adversary, due to the potential of increased forking: nodes will ﬁnd puzzle
solutions (and thus blocks) at the same time; because of the delay in hearing about other nodes’ chains
nodes will build on diﬀerent chains, delaying agreement. Another common conjecture, explicitly mentioned
in [12], is that the choice of symmetry-breaking strategies, or ways honest nodes choose among multiple
longest chains, is not relevant to correctness.

In this paper, we show that these common beliefs are incorrect. In particular, we show that when p is
beyond the well-studied region even the simple strategy of choosing among chains of equal length randomly
fosters chain growth, especially in the absence of adversaries.

Contributions. In this work, we formally analyze Nakamoto consensus under a wide range of p including
large p. We conﬁrm previous (informal) analysis that Nakamoto consensus requires small p in the presence
of adversaries, but show that surprisingly, it does not in a setting without adversaries, even if p = 1 (all
nodes mine blocks every round) with a minor change in nodes’ symmetry-breaking strategy. Previous work
assumed the requirement of convergence opportunities, a period when only one honest node mines a block,
in order to achieve consistency [18, 22]; we show that in fact convergence opportunities are not required
for common-preﬁx and chain growth. With an additional backwards-compatible modiﬁcation to Nakamoto
consensus, we can derive a bound on the chain growth for a wider range of p (including large p) in a setting
with adversaries. Our key idea in this modiﬁcation is to introduce a veriﬁable delay function [5] to prevent the
adversaries from extending a chain by multiple blocks in a round. Our analysis is based on a new application
of a well-known technique, coalescing random walks. To our knowledge this is the ﬁrst application of
coalescing random walks to analyze the common-preﬁx and chain quality of Bitcoin and other proof-of-work
protocols. We thoroughly analyze Nakamoto consensus with the uniformly-at-random symmetry-breaking
strategy and discuss diﬀerent symmetry-breaking strategies including ﬁrst-seen, lexicographically-ﬁrst, and
global-random-coin.

In summary, our contributions are as follows:

• A new approach for analyzing the conﬁrmation time of the Bitcoin protocol under the uniformly-at-
random symmetry-breaking strategy in the adversarial-free setting via coalescing random walks. Our
analysis works for a new region of p, and shows that previous works’ requirement for convergence
opportunities was unneeded.

• New notions of adversarial advantages and coalescing opportunities to provide a more general analysis

of common-preﬁx and chain growth in Nakamoto consensus in the presence of adversaries.

Related Work. Proofs-of-work were ﬁrst put forth by Dwork and Naor [9]. Garay, Kiayias, and Leonar-
das [12] provided the ﬁrst thorough analysis of Nakamoto’s protocol in a synchronous static setting, intro-
ducing the ideas of common-preﬁx, chain quality and chain growth. Later work [15] extended the analysis
to a variable diﬃculty function. Pass, Seeman, and shelat [22] extended the idea of common-preﬁx to future
self-consistency, and provided an analysis of Nakamoto consensus in the semi-synchronous setting with an
adaptive adversary. Several additional papers used this notion of future self-consistency [18, 30]. [18, 22]
relied on convergence opportunities, or rounds where only one node mines a block, to analyze chain growth.
In this work we show that convergence opportunities are not required for chain growth, and relying on them
underestimates chain growth with high p; in the adversary-free setting we show chain growth even with p = 1

2

(no convergence opportunities; all nodes mine a block every round). Other work considered the tradeoﬀs be-
tween chain growth and chain quality [15, 17, 22, 24, 29]; however, to the best of our knowledge, none of these
works considered diﬀerent symmetry breaking strategies to enable faster chain growth while maintaining
chain quality. In our paper, we thoroughly explore this domain. Another line of work [11, 27] considers how
the uniformly-at-random symmetry breaking strategy aﬀects incentive-compatible selﬁsh mining attacks; our
analysis applies to general attacks.

Random walks have been used to analyze the probability of consistency violations in proofs-of-stake
protocols [3]; ours is the ﬁrst work that uses coalescing random walks to analyze the common-preﬁx and
chain quality of Bitcoin and other proof-of-work protocols.

2 Model and Deﬁnitions

In this section, we present the speciﬁc model we use and brieﬂy describe the Bitcoin cryptosystem. We follow
the formalization presented in [15, 18, 22].

Network and Computation Model. Following previous work [12, 14, 15, 22, 26, 30], we consider a syn-
chronous network where nodes send messages in synchronous rounds, i.e., ∆ = 1; equivalently, there is a
global clock and the time is slotted into equal duration rounds. Each node has identical computing power.
Notably, the synchronous rounds assumption is signiﬁcantly more relaxed than assuming ∆ = 0.2 Our model
operates in the permissionless setting. This means that any miner can join (or leave) the protocol execution
without getting permission from a centralized or distributed authority. For ease of exposition, we assume
the number of participants remains n. Our results can be easily generalized to handle perturbation in the
population size by a stochastic dominance argument as long as the population size does not deviate too far
from n, and the proportion of Byzantine participants does not increase due to the perturbation.

Adversary Model. Throughout this paper, we assume that all Byzantine nodes are controlled by a
probabilistic polynomial time (PPT) adversary A that can coordinate the behavior of all such nodes. A
operates in PPT which means they have access to random coins but can only use polynomial time to
perform computations. At any time during the run of the protocol, A can corrupt up to b nodes at any point
in time where b is a parameter that is an input to the protocol. The corrupted nodes remain corrupted for
the remainder of the protocol. Finally, A cannot modify or delete the messages sent by honest nodes, but
can read all messages sent over the network and arbitrarily order the messages received by any honest nodes.

2.1 Bitcoin Cryptosystem

A blockchain protocol is a stateful algorithm wherein each node maintains a local version of the blockchain
C. Each honest node runs its own homogeneous version of the blockchain protocol. Nodes receive messages
from the environment Z(1λ), where λ is the security parameter chosen based on the population size n. The
environment is responsible for all the external factors related to a protocol’s execution. For example, it
provides the value of b to the nodes. Detailed description of the environment can be found in [22].

The protocol begins by having the environment Z initialize n nodes. The protocol proceeds in synchronous
rounds; at each round r, each node receives a message from Z. In each round, an honest node attempts to
mine a block containing its message to add to its local chain. We provide formal deﬁnitions of the Bitcoin
cryptosystem below.

Blocks and Blockchains
A blockchain C (cid:44) B0B1B2 · · · B(cid:96) for some (cid:96) ∈ N is a chain of blocks. Here B0 is a predetermined genesis block
that all chains must build from. A block B(cid:96), for (cid:96) ≥ 1, is a triple B(cid:96) = (cid:104)s, x, nce(cid:105), where s, x, nce ∈ {0, 1}∗
are three binary strings of arbitrary length. Speciﬁcally, s is used to indicate this block’s predecessor, x
is the text of the block containing the message (e.g. transactions) and other metadata, and nce is a nonce
chosen by a node.

Proofs-of-Work
The Bitcoin cryptosystem crucially uses nonces as proofs-of-work for determining whether a block can be

2In fact, the analysis based on Poisson race [2,21] essentially assumes all mined blocks can be ordered in a globally consistent

way, i.e., ∆ = 0, which does not hold in our synchronous network model.

3

legally added to a chain.3 Proof-of-work (PoW) is rigorously deﬁned in previous work [12, 14, 15, 22, 26, 30]
based on the use of the random oracle model.

Deﬁnition 1 (Random Oracle Model). A random oracle H : {0, 1}∗ → {0, 1}λ on input x ∈ {0, 1}∗ outputs
a value selected uniformly at random from {0, 1}λ if x has never been queried before. Otherwise, it returns
the previous value returned when x was queried last.

Deﬁnition 2 (Bitcoin PoW). All nodes access a common random oracle H : {0, 1}∗ → {0, 1}λ. We say a
node successfully performs a PoW with proof x ∈ {0, 1}∗ if H(x) ≤ D.

Deﬁnition 3 (Valid Chain). A blockchain C = B0B1 · · · B(cid:96) = B0(cid:104)s1, x1, nce1(cid:105) · · · (cid:104)s(cid:96), x(cid:96), nce(cid:96)(cid:105) is valid with
respect to a given puzzle diﬃculty level D ∈ {1, · · · , 2λ} if the following hold: (1) H(B0) = s1 and H (B(cid:96)(cid:48)) =
s(cid:96)(cid:48)+1 for (cid:96)(cid:48) = 1, · · · , (cid:96) − 1; and (2) H (B(cid:96)(cid:48)) ≤ D for (cid:96)(cid:48) = 0, · · · , (cid:96).

Longest Chain Rule
The length of a valid chain C is the number of blocks it contains. We refer to the local version of the
blockchain kept by node i as the local chain at node i, denoted by Ci. In each round r, node i tries to mine
a block via solving a PoW puzzle with the speciﬁed diﬃculty D. If a block is successfully mined, then node
i extends its local chain with this block and broadcasts its updated local chain to all other nodes in the
network, which will be delivered at each node at the beginning of the next round. At the beginning of the
next round, before working on PoW, node i updates its local chain to be the longest chain it has seen. If
there are many longest chains, node i chooses one of them uniformly at random.

For ease of exposition, henceforth, Ci is referred to the local chain at the end of a round; Ci(t) is the
local chain of node i at the end of round t. Equivalent to using the diﬃculty parameter D, one can instead
consider p (cid:44) D/2λ. The notion of p used in lieu of D has been considered in [12, 14, 15, 18, 22, 26] to simplify
notation. Henceforth, we will quantify the algorithm performance in terms of p rather than D and λ.

We use the phrase with overwhelming probability throughout this paper. With overwhelming probability
poly(λ)c for any constant c ≥ 1. We use the phrase with all but
is deﬁned as with probability at least 1 −
negligible probability in λ to mean that the probability is upper bounded by some negligible function ν(λ)
on λ (deﬁned in Deﬁnition 4).

1

Deﬁnition 4 (Negligible Probability). A function ν is negligible if for every polynomial p(·), there exists an
N such that for all integers n > N , it holds that ν(n) < 1
p(n) . We denote such a function by negl. An event
that occurs with negligible probability occurs with probability negl(n).

2.1.1 Properties of the Protocol

In this paper, we will analyze the Nakamoto consensus in terms of two characteristics (generalized from
deﬁnitions in [12, 18, 30]). The common preﬁx is deﬁned as a sub-chain that is a common preﬁx of the local
chains of all honest nodes at the end of a round. The two properties maximal common preﬁx and maximal
inconsistency are deﬁned intuitively as: the maximal preﬁx that is the same across all honest chains and the
maximal number of blocks in any honest chain that is not shared by all other honest chains, respectively.

(cid:111)

Property 5 (Maximal common-preﬁx and maximal inconsistency). Given a collection of chains C =
(cid:110) ˜C1, · · · , ˜Cm
that are kept by honest nodes, the maximal common-preﬁx of chain set C, denoted by PC, is
deﬁned as the longest common-preﬁx of chains ˜C1, · · · , ˜Cm. The maximal inconsistency of C, denoted by IC,
is deﬁned as

max
i:1≤i≤m

(cid:12)
(cid:12)
(cid:12)

˜Ci − PC

(cid:12)
(cid:12)
(cid:12) ,

(1)

where ˜Ci − PC is the sub-chain of ˜Ci after removing the preﬁx PC and |·| denotes the length of the chain,
i.e., the number of blocks in the chain.

3Note that in practice, the nonce is eﬀectively concatenated with a miner’s public key (included in the coinbase transaction)
to ensure unique queries. The public key does not need to be veriﬁed. Importantly, this means that the miner can just generate
a (pk, sk) pair on their local computer without the need to verify that identity with a third-party authority.

4

Figure 1: Example growth of a set of chains starting with the genesis block at round r = 0. Here, in this
example p = 1, n = 4, and b = 0.

3 Fundamental Limitations of Existing Approaches

To the best of our knowledge, existing work assumes extremely small p. In fact, the seemingly mild honest
majority assumption in [13, 23] also implicitly assumes small p.

Proposition 6. If the honest majority assumption in [13] holds, then p ≤ n−2b

2(n−b)2 .

A formal statement of the honest majority assumption and the proof of Proposition 6 can be found in
Appendix B. Note that the upper bound in this proposition is only a necessary condition. Having p satisfy
this condition does not guarantee protocol correctness.

Remark 7. Proposition 6 implies that in the vanilla Nakamoto consensus protocol, unless b
bounded above from 1
See Appendix B for detailed arguments.

2 , p needs to be extremely low – even much lower than the commonly believed Θ( 1

n is non-trivially
n ).

To the best of our knowledge, most of the existing analyses focus on bounding the number of “convergence
opportunities”, which for ∆ = 1 is deﬁned as the number of rounds in which exactly one honest node mines
a block, and for general ∆, it is deﬁned as the global block mining pattern that consists of (i) a period
of ∆ rounds where no honest node mines a block, (ii) followed by a round where a single honest player
mines a block, (iii) and, ﬁnally, another ∆ rounds of silence from the honest nodes [18, 22]. Obviously,
guaranteeing suﬃciently many convergence opportunities necessarily requires p to be small; in the extreme
case when p = 1 there will be no convergence opportunities at all. An important insight from our results is
that convergence opportunities are not necessary for common-preﬁx growth. This is illustrated Fig. 1 which
depicts the chain growth when there are 4 honest nodes and p = 1. Each node mines a block every round and
each is associated with a color. In particular, blocks 1, 5, 9, 13, 17, 21, 25, 29 are mined by the pink node, blocks
4, 8, 12, 16, 20, 24, 28, 32 are mined by the blue node, etc. In each round, each node chooses one of the existing
longest chains uniformly at random to extend. As shown in Fig. 1, there are no convergence opportunities
in any of these 8 rounds and the four nodes never choose the same chain to extend. However, instead of the
trivial common preﬁx (the genesis block) the longest chains at the end of round 8 (the four chains ending
with blocks 32, 29, 30, and 31, respectively) share the common preﬁx genesis → 4 → 6 → 10 → 15. In
general, as we show in Section 4, even for the extreme case when p = 1, the common preﬁx of the longest
chains still grows as time goes by.

5

12345786101412911171613182019𝑟=0𝑟=1𝑟=2𝑟=3𝑟=4𝑟=515232421222825262732293031𝑟=6𝑟=7𝑟=84 Uniformly-at-Random Symmetry-Breaking Strategy

Bitcoin uses the ﬁrst-seen symmetry-breaking strategy; nodes will only switch to a new chain with more
proof-of-work than their current longest chain. In this section, we investigate the power of the uniformly-at-
random symmetry-breaking strategy, in which each honest node chooses one of its received longest chains
uniformly at random to extend upon – independently of other nodes and independently across rounds. We
choose to start with the uniformly-at-random strategy because (1) it is easy to implement, especially in a
distributed fashion, and (2) despite its simplicity, it is very powerful in fostering chain growth.

For ease of exposition, we ﬁrst present our results in the adversary-free setting (Sections 4.1 and 4.2) and

then in the adversary-prone setting (Section 4.3).

4.1 Warmup: p = 1 and Adversary-Free

Even the adversary-free setting (i.e., b = 0) is surprisingly non-trivial to analyze. Hence we build insights
by ﬁrst considering the simpler setting where p = 1 as a warmup.

Theorem 8. Suppose that p = 1 and b = 0. Then for any given round index t ≥ 1, in expectation, the local
chains at the honest nodes share a common preﬁx of length t + 1 − O(n).

Remark 9. In Theorem 8, the expectation is taken w. r. t. the randomness in the symmetry breaking strategy.
Theorem 8 says that large p indeed boosts the growth of the common preﬁx among the local chains kept by
the honest nodes, and that, though temporal forking exists among local chains kept by the honest nodes,
such forking can be quickly resolved by repetitive symmetry-breaking across rounds.

The following deﬁnition and theorem are useful to see the intuitions of Theorem 8.

Deﬁnition 10 (Coalescing Random Walks [1]4). In a coalescing random walk, a set of particles make
independent random walks on a undirected graph G = (V, E) with self-loops. Whenever one or more
particles meet at a vertex, they unite to form a single particle, which then continues the random walk
through the graph. We deﬁne the coalescence time, denoted by CG, to be the number of steps required
before all particles merge into one particle.

Theorem 11 ( [1] [7]). If G = (V, E) is complete, then E [CG] = O(n).

In the proof of Theorem 8, we build up the connection between the longest chains and the backwards
coalescing random walks on complete graphs, and show that the maximal inconsistency among n longest
chains turns out to be the same as the number of steps it takes n random walks on the n-complete graph to
coalesce into one. Finally, we use the existing results on coalescing random walks to conclude.

Main proof ideas of Theorem 8. We cast our proof insights via an example presented in Fig. 1.
In
this ﬁgure, there are four miners. For ease of exposition, we use the colors pink, yellow, green, and blue to
represent each of the miners, respectively. As shown in Fig. 1, there are 4 longest chains at the end of round
8 and these chains share a maximal common preﬁx ending at block 15. The maximal inconsistency of these
4 longest chains is 4; that is, these 4 longest chains are NOT inconsistent with each other until the most
recent 4 blocks of each chain. For expository convenience below, instead of using numbers to represent each
of the blocks, we use the tuple (color, r) to represent a block that is mined by a certain miner at round r.
The maximal inconsistency of the longest chains can be characterized by the coalescing time on complete
graphs. To see this, let’s consider the four longest chains held by honest miners during round 8 backwards.
Backwards-Chain #1: (blue, 8) → (pink, 7) → (blue, 6) → (yellow, 5) → (green, 4) → (yellow, 3) →
(yellow, 2) → (blue, 1) → (gray, 0), which can be read as “block (blue, 8) is attached to block (pink, 7)
which is further attached to block (blue, 6) ... attached to the genesis block (gray, 0). ”
Backwards-Chain #2: (pink, 8) → (yellow, 7) → (pink, 6) → (green, 5) → (green, 4) → (yellow, 3) →
(yellow, 2) → (blue, 1) → (gray, 0) .
Backwards-Chain #3: (yellow, 8) → (yellow, 7) → (pink, 6) → (green, 5) → (green, 4) → (yellow, 3) →
(yellow, 2) → (blue, 1) → (gray, 0).

4The original deﬁnition given in [1] assumes no self-loops, but its analysis applies to the graphs with self-loops.

6

Backwards-Chain #4: (green, 8) → (green, 7) → (yellow, 6) → (green, 5) → (green, 4) → (yellow, 3) →
(yellow, 2) → (blue, 1) → (gray, 0) .
Since p = 1 and there is no adversary, the number of longest chains received by each honest node at each
round is n. Under our symmetry-breaking rule, in each round t, each miner chooses which of the longest
chains received at the beginning of round t to extend on uniformly-at-random. Thus, neither the previous
history up to round t nor the future block attachment choices after round t aﬀects the choice of the chain
extension in round t. Reasoning heuristically5, we can view each of the backwards-chain as a random walk
on a 4-complete graph with vertex set {pink, yellow, green, blue}. In particular, Backwards-Chain #1 can
be viewed as a sample path of a random walk starting at the blue vertex, then moves to the pink vertex,
then back to the blue vertex etc., and ﬁnally to the blue vertex. Similarly, Backwards-Chains #2, #3, and
#4 can be viewed as the sample paths of three random walks starting at the pink vertex, yellow vertex, and
green vertex, respectively. These four random walks (starting at four diﬀerent vertices) are not completely
independent. For any pair of random walks, before they meet, they move on the graph independently of
each other; whenever they meet, they move together henceforth. Concretely, backwards-chains 2 and 3 meet
at (yellow, 7) and these chains are identical starting from block (yellow, 7); this holds similarly for other
pairs of backwards chains. Finally, these four backward chains all meet at the block (green, 4) and move
together henceforth. Notably, this block is exactly the last block in the maximal common preﬁx of the four
longest chains of round 8. Thus, the maximal inconsistency among the longest chains of round 8 is identical
to the number of backwards steps it takes for all these four random walks to coalesce into one. This relation
is not a coincidence. It can be shown (detailed in the proof of Theorem 8) that this identity holds for general
n. Formal proof of Theorem 8 can be found in Appendix C.

4.2 General p: Adversary-Free

The analysis for general p is signiﬁcantly more challenging than that of p = 1 in two ways: (1) we need to
repeatedly apply coupling arguments; and (2) we need to characterize the coalescence time of a new notion
of coalescing random walks (the lazy coalescing random walks), the latter of which could be of independent
interest for a broader audience.

Theorem 12. Suppose that np = Ω(1). If p < 4 ln 2
n , in expectation, at the end of round t, the local chains
at the nodes share a common preﬁx of length (1 + (1 − (1 − p)n) t) − O(
n , in expectation,
at the end of round t, the local chains at the nodes share a common preﬁx of length (1 + (1 − (1 − p)n) t) −

npe−np ). If p ≥ 4 ln 2

1

(cid:18)

O

2np

(1−2 exp(− 1

3 np))

(cid:19)

.

Remark 13. The expression of the common preﬁx length in Theorem 12 contains two terms with the ﬁrst
term (i.e., (1 + (1 − (1 − p)n) t)) being the only term that involves t. Intuitively, from this term, we can read
out the common preﬁx length growth rate w.r.t. t. The second term (which is expression in terms of Big-O
notation) can be interpreted as a quantiﬁcation of the maximal inconsistency of the honest chains.

Now we further interpret these two terms via simplifying the expression using the inequalities (1 − np) ≤

(1 − p)n ≤ exp (−np).
(1) When np = o(1), it is true that (1 − p)n ≈ (1 − np) for large n, which implies that (1 − (1 − p)n) t ≈
npe−np ) is
npt = o(t), i.e., the common preﬁx grows at a speed o(t). The maximal inconsistency bound O(
not tight. Nevertheless, via a straightforward calculation, we know that the maximal inconsistency is O(1).
(3) When np = ω(1), we have 0 ≤ (1 − p)n ≤ exp (−np) → 0 as np → ∞. Thus the common-preﬁx grows at
the speed (1 − (1 − p)n) t ≈ t = Ω(t) with maximal inconsistency O(np) for suﬃciently large np.
(4) When np = c ∈ (0, 1), it is true that (1 − p)n = (1 − c/n)n → exp (−c) as n → ∞. The common-preﬁx
grows at the speed of Θ(t) for suﬃciently large n and the maximal inconsistency is O(1).

1

Overall, when np gets larger, the common-preﬁx growth increases and the maximal inconsistency grows

at a much slower rate.

The following deﬁnition and lemma are used in proving Theorem 12. This lemma could be of independent

interest to a broader audience and its proof can be found in the appendix.

5Formally shown in the proof of Theorem 8 via introducing an auxiliary process.

7

Deﬁnition 14 (Lazy coalescing random walk). For any ﬁxed u ∈ (0, 1), we say n particles are u-lazy
coalescing random walks if for each step: with probability (1 − u), each particle stays at its current location;
with probability u, each particle moves to an adjacent vertex picked uniformly at random. If two or more
particles meet at a location, they unite into a single particle and continue the procedure. The coalescence
time is the same as that in Deﬁnition 10.

Lemma 15. Suppose that G is a complete graph of size |V | = ng (where ng ≥ 2) with self-loops. For any
u ∈ (0, 1), the coalescence time of the u-lazy coalescing random walks is CG(ng) = O(ng/u).

(cid:17)

(cid:16)

1
np exp(−np)

Proof Sketch of Theorem 12. When p < 4 ln 2
n , we can use Poisson approximation to approximate the
distribution of number of blocks in each round. A straightforward calculation shows that the probability
of having exactly one block in a round is np exp (−np). Thus, in expectation, the maximal inconsistency
. Henceforth, we restrict our attention to the setting where p ≥ 4 ln 2
and quantify the
is O
expected maximal inconsistency among the longest chains of round t. It is attempting to apply arguments
similar to that in the proof of Theorem 8 and derive a bound on the maximal inconsistency via stochastic
dominance. However, the obtained bound on the maximal inconsistency is O(n) which could be extremely
loose for a wide range of p. Nevertheless, based on the insights obtained in this coarse analysis, we can
come up with a much ﬁner-grained analysis and obtain the bound in Theorem 12. Similar to the proof of
the special case when p = 1, in our ﬁne-grained analysis for general p ∈ (0, 1), we couple the growth of
the common preﬁx in Nakamoto protocols with the coalescing time random walks on complete graphs. The
major diﬀerences from the proof of p = 1 are: (1) instead of the standard coalescing random walks, we need
to work with a lazy version of it, formally deﬁned in Deﬁnition 14; (2) there is no ﬁxed correspondence
between a color and a node – in our proof of general p, the correspondence is round-speciﬁc rather than ﬁxed
throughout the entire dynamics; (3) there is no bijection between a sample path of the Nakamoto dynamics
and that of the backwards coalescing random walks, thus, we need to rely on stochastic dominance to build
up the connection of these two dynamics.

n

4.3 General p: Adversary-Prone

Throughout this section, we assume p < 1. In this subsection, we consider adversary-prone systems, i.e.,
b > 0. Simple concentration arguments show that when bp ≥ (1 + 2c) for any given c ∈ (0, 1), using vanilla
Nakamoto consensus the chain quality could be near zero. To make larger p feasible, we introduce a new
assumption—Assumption 16—which we then remove in Section 5 by providing a construction that ensures
Assumption 16 with all but negligible probability. Speciﬁcally, we use a cryptographic tool called a VDF to
ensure that over a suﬃciently long time window, the corrupt nodes can only collectively extend a chain by
more than one block in a round with negligible probability.

Assumption 16. In each round, a chain can be extended by at most 1 block.

To strengthen the protocol robustness, we make the additional minor modiﬁcation requiring each honest

node to selectively relay chains at the beginning of a round.
Selective relay rule: At each honest node i, for each iteration t ≥ 1: Node i looks at the chains it
received in the previous round t − 1, and if any of them are longer than its own local longest chain, it not
only chooses one of the longest chains to replace its local one, it also broadcasts it to other nodes before it
begins mining in round t.

As implied by our proof, this modiﬁcation can reduce the maximal diﬀerence between the lengths of the
longest chains kept by the honest nodes and by the corrupt nodes. Intuitively, if the adversary sends two
chains of diﬀerent lengths to two diﬀerent groups of honest nodes, with the selective relay rule, only the longer
chain would survive in this round. Notably, it is possible that none of them survive in this round. Even with
the assurance guaranteed by Assumption 16, compared with the adversary-free settings, the analysis for the
adversary-prone setting is challenging. This is because the corrupt nodes could deviate from the speciﬁed
symmetry breaking rule. For example, a corrupt node can choose not to extend its longest chain, or can
choose from its set of longest chains in any way that provides advantage. In addition, a corrupt node can
hide blocks it has mined from the honest nodes for as long as it wants, or from some subset of the honest
nodes during a round.

8

For simplicity and for technical convenience, we assume that a corrupt node randomly chooses among
longest chains that end with an honest block. This assumption is only imposed in the rare event when
simultaneously both the adversary has no adversary advantage (see Deﬁnition 17) and only honest nodes
mine blocks in the most recent nonempty round.

In contrast to the adversary-free setting where the lengths of honest nodes’ local chains diﬀer by at most
1, in the presence of an adversary, such diﬀerence could be large. To precisely bound this diﬀerence, we
introduce a random process we call adversary advantage:

Deﬁnition 17 (Adversary advantage). Let {N (t)}∞

t=0 be the random process deﬁned as

• N (0) = 0, and

• for t ≥ 1,

N (t) =






N (t − 1) + 1,
max{N (t − 1) − 1, 0},
N (t − 1),

if only corrupt nodes found blocks in round t;
if only honest nodes found blocks in round t;
otherwise.

Note that the random process {N (t)}∞

t=0 is independent of the adversarial behaviors of the corrupt nodes.

To make the discussion concrete, we introduce the following deﬁnition.

Deﬁnition 18. The length of the longest chains kept by the honest nodes at round t is deﬁned as the
length of the longest local chains kept by honest nodes at the end of round t.

Lemma 19. For any t ≥ 1, at the end of round t, the length of the longest chains kept by the adversary –
henceforth referred to as an adversarial longest chain of round t – is at most N (t) longer than the length of
a chain kept by an honest node.

Proof of Lemma 19 can be found in Appendix E. From its proof, we can deduce an attacking strategy
of the adversary that meets the upper bound in Lemma 19. The following lazy random walk, referred to as
coalescing opportunities, is important in our analysis. It can also be used to quantify the chain quality.

Deﬁnition 20. Let t1, t2, · · · be the rounds in which at least one node mines a block with the understanding
that t0 = 0. Let J (m) be a random walk deﬁned as

J (m) =





0,
J (m − 1) + 1,
J (m − 1) − 1,
J (m − 1),

if m = 0;
if only honest nodes mine a block during round tk;
if only corrupt nodes mine a block during round tk;
otherwise.

Remark 21. A couple of interesting facts on the coalescing opportunities dynamics are: Among the most
recent m blocks in a longest chain, there are at least J (m) blocks mined by the honest nodes. In addition,
regardless of the behaviors of the adversary, for any two longest chains, there are at least J (m) block
positions each of which has non-zero probability of being in the common preﬁx of these two chains.

Let p+1 = P {J (m) = J (m − 1) + 1} and p−1 = P {J (m) = J (m − 1) − 1}, i.e., p+1 (resp. p−1) is the

probability for J (m) to move up (resp. down) by 1. We have
(1 − p)b (cid:16)

1 − (1 − p)n−b(cid:17)

p+1 =

1 − (1 − p)n

and p−1 =

(cid:0)1 − (1 − p)b(cid:1) (1 − p)n−b
1 − (1 − p)n

.

(2)

It is easy to see that when b > 1
P {J (t) (cid:54)= J (t − 1)} = p+1 + p−1.

2 n,

it holds that p+1 > p−1. For ease of exposition,

let p∗ =

Lemma 22. With probability at least

(cid:16)

1 − exp

(cid:16)
− (p+1−p−1)2M
16p∗

(cid:17)

− exp

(cid:16)

− (p∗)2M
2

(cid:17)(cid:17)

, it holds that J (M ) ≥

(p+1−p−1)M
4

.

9

Lemma 22 gives a high probability lower bound on the number of coalescing opportunities during M

nonempty rounds. Its proof can be found in Appendix E.

Theorem 23. For any given T ≥ 1 and M ≥
probability at least

4

β(p+1−p−1) where β = (n−b)p

2(3np)2 , at the end of round T , with

(cid:18)

1 − exp

−

(cid:19)

(p∗)2M
2

(cid:18)

− exp

−

(p+1 − p−1)2M
16p∗

(cid:19)

−

2
β

(cid:18)

exp

−

1
2

(cid:19)

(n − b)

over the randomness in the block mining, the expected maximal inconsistency among a given pair of honest
nodes is less than M , where the expectation is taken over the randomness in the symmetry breaking.

Remark 24. It is worth noting that β = (n−b)p
nodes and the total mining power of the nodes in the system.

2(3np)2 = 1

(n−b)
n

18

1
np , i.e., β is a function of the fraction of honest

Suppose that n ≥ 2 log 4

(cid:15)β for any given (cid:15) ∈ (0, 1). Let

(cid:40)

M ∗ = max

4 log 1/(cid:15)
(p∗)2

,

4
β(p+1 − p−1)

,

16p∗
(p+1 − p−1)2 log

4
(cid:15)

(cid:41)

.

From Theorem 23, we know that with probability at least 1 − (cid:15), the maximal inconsistency is less than M ∗.
Roughly speaking, when b gets smaller, M ∗ mainly gets smaller.

Proof of Theorem 23. We use Nt to denote the number of blocks generated during round t and associate
each node with a distinct color in {c1, · · · , cn}. If node i mines a block during round t, we use (ci, t) to
denote this block. The genesis block is denoted as (c1, 0). Recall that the blocks mined during round t are
collectively referred to as the block layer t. As the randomness in the block generation (i.e., puzzle solving
of individual nodes) is independent of the adversarial behaviors of the corrupt nodes and is independent of
which chain an honest node chooses to extend, we consider the auxiliary process wherein the nodes mine
blocks for the ﬁrst T rounds, and then the corrupt nodes and honest nodes sequentially decide on block
attachments. Let {i1, · · · , iK} be the set of rounds such that Nik (cid:54)= 0 for each ik ∈ {i1, · · · , iK}. Let j1
and j2 be any two honest nodes whose chains at the end of round T are denoted by C1(T ) and C2(T ),
respectively. For each of these chains, we can read oﬀ a sequence of colors

for Chain C1(T ) :
for Chain C2(T ) :

c1c(1, 2)c(1, 3) · · · c(1, (cid:96)1), and
c1c(2, 2)c(2, 3) · · · c(2, (cid:96)2),

where (cid:96)1 and (cid:96)2, respectively, are the lengths of chains C1(T ) and C2(T ), c1 is the color of the genesis block,
c(1, k) for k ∈ {2, · · · , (cid:96)1} is the color of the k–th block in C1(T ) and c(2, k) for k ∈ {2, · · · , (cid:96)2} is the color
of the k–th block in C2(T ). If (cid:96)1 (cid:54)= (cid:96)2, without loss of generality, we consider the case that (cid:96)1 < (cid:96)2; the
other case can be handled similarly. We augment the color sequence c1c(1, 2)c(1, 3) · · · c(1, (cid:96)1) to the length
(cid:96)2 sequence as

c1c(1, 2)c(1, 3) · · · c(1, (cid:96)1)c(1, (cid:96)1 + 1) · · · c(1, (cid:96)2),

by setting c(1, k) = c0 for k = (cid:96)1 + 1, · · · , (cid:96)2 where c0 /∈ {c1, · · · , cn} is a special color that never shows
up in a real block. It is easy to see that C1(T ) and C2(T ) start to be inconsistent at their k-th block if
and only if c(1, k(cid:48)) (cid:54)= c(2, k(cid:48)) for each k(cid:48) ∈ {k, · · · , (cid:96)2}. Let {ih1 , · · · , ihR } ⊆ {i1, · · · , iK} such that for each
ihr ∈ {ih1, · · · , ihR } it holds that

• Only honest nodes successfully mined blocks;

• N (ihr−1) = 0.

For ease of exposition, we refer to each of ihr as a coalescing opportunity. Recall that each of the honest
nodes extends one of the longest chains it receives. By Lemma 19, we know that each of C1(T ) and C2(T )
contains a block generated during round ihr . Let (c(cid:48)
2, ihr ) be the blocks included in C1(T ) and
C2(T ), respectively. If (c(cid:48)
2, ihr ) is also in the k-th position in
C2(T ). For each ihr , we denote the set of chains (including the forwarded chains) received by j1 and j2 at

1, ihr ) is in the k-th position in C1(T ), then (c(cid:48)

1, ihr ) and (c(cid:48)

10

round ihr , denoted by Cr
Cr
1 and Cr

1 and Cr

2 could be diﬀerent. The probability of j1 and j2 extending the same chain at round ihr is

2 . Since the adversary can hide chains to a selective group of honest nodes,

1 ∩ Cr
|Cr
2 |
1 | |Cr
|Cr
2 |

≥

NB(ihr−1)
NB(ihr−1) + AB(ihr−1) + AB( (cid:93)ihr−1)

(cid:16)

(cid:17)2

(3)

where the inequality follows from Lemma 33. By Lemma 22, we know that in the M non-empty block layers
that are most recent to round T ,

R ≥ J (M ) ≥

(p+1 − p−1)M
4

holds with probability at least
that for each of the r ensured by Lemma 22 we have

1 − exp

(cid:16)

(cid:16)

− (p∗)2M
2

(cid:17)

− exp

(cid:16)

− (p+1−p−1)2M
16p∗

(cid:17)(cid:17)

. In addition, it can be shown

max{|Cr

1 | , |Cr

2 |} ≤ NB(ihr−1) + AB(ihr−1) + AB( (cid:93)ihr−1)1{AB(ihr−1) = 0}.

let Xk be the number of blocks mined by the honest nodes during round ik such that
For any ik,
Xk (cid:54)= 0. Using conditioning and Hoeﬀding’s inequality, the following holds with probability at least
(cid:0)1 − 2 exp (cid:0)− 1

2 (n − b)(cid:1)(cid:1),

Xk ≥

1
2

(n − b)p and Xk + Yk + Yk−11{Yk = 0} ≤ 3np,

2(3np)2 (cid:44) β. On average over the random symmetry breaking,
which implies that
it takes at most 1/β coalescing opportunities backwards for chains C1(T ) and C2(T ) to coalesce into one.
Thus, we need (p+1−p−1)M

Xk+Yk+Yk−11{Yk=0} ≥ (n−b)p

Xk

4

≥ 1
β .

5 VDF-Based Scheme

In this section, we present a scheme to ensure Assumption 16. The key cryptographic tool we use in the
following scheme is the construction of the veriﬁable delay function, F(x), which we deﬁne informally below.
Please refer to [4] for the formal deﬁnition (also deﬁned formally in the full version of our paper).

Deﬁnition 25 (Veriﬁable Delay Function (informal)). Let λ be our security parameter. There exists a
function F with diﬃculty X = O(poly(λ)) where the output y ← F(x) (where x ∈ {0, 1}λ) cannot be
computed in less than X sequential computation steps, even provided poly(λ) parallel processors, with
probability at least 1 − negl(λ). The VDF output can be veriﬁed, quickly, in O(log(X)) time.

We set the diﬃculty of the VDF to the duration of a round; in other words, the diﬃculty is set such that
the VDF produces exactly one output at the end of each round. We amend default Nakamoto consensus by
adding the following procedure. We believe this could be added in a backwards-compatible way to existing
Nakamoto implementations, like Bitcoin. Backwards-compatibility is desirable in decentralized networks
because it means that a majority of the network can upgrade to the new protocol and non-upgraded nodes
can still verify blocks and execute transactions. Below we describe a scheme that, when added to Nakomoto
consensus, assures Assumption 16. The proof of the following theorem is in the full version of our paper.

Theorem 26. Assumption 16 is satisﬁed by our VDF-based scheme.

VDF-Scheme Overview. The VDF-scheme works intuitively as follows. We number the rounds beginning
with round 0. All nodes have the genesis block B0 in their local chains in round 0 and starting mining blocks
in round 1. In round 0, the VDF output is computed using 0 as the input. During each round j > 0, each
node computes a VDF output, yj, (using F) for the current round j where the input to F is the output of the
VDF, yj−1, from the previous round concatenated with the round number, j. Both inputs are necessary; the

11

output of the VDF from the previous round ensures that we cannot compute the VDF output for this round
until we have obtained the output for the previous round, and the round number is necessary to ensure that
the output is not used for a future round. Once the VDF output is computed, each honest node attempts to
mine a block using the VDF output as part of the input to the mining attempt. This also ensures that the
block generation rate of honest nodes is upper bounded by np. Then, each node which successfully mines a
block sends the new chain to all other nodes.

All honest nodes verify that each chain satisﬁes two conditions:

1. Let o1, . . . , o(cid:96) be the VDF outputs contained in blocks B1, . . . , B(cid:96), respectively, of a chain C (the genesis
block does not contain a VDF output). Let r1, . . . , r(cid:96) be the rounds where o1, . . . , o(cid:96) were computed,
respectively. Then, r1 < · · · < r(cid:96)−1 < r(cid:96).

2. oi is the VDF output computed from round ri ≥ i − 1.

The honest nodes also check all proofs included in the chains, conﬁrming that the VDF outputs are correctly
computed and the blocks are correctly mined using the VDF outputs. An honest node discards any chain
which does not pass veriﬁcation.

Pseudocode. The precise pseudocode of our VDF-based scheme is given below. Using F, each honest node
i performs the following:

1. Initially, all honest nodes use input 0 at the start of the protocol to obtain output y0 = F(0) for round

0.

2. Let dj = F(yj−1) be the output of the VDF for round j and yj = dj−1|j.6 i stores yj.

3. When i mines a block Bj, i includes the output yj−1 = dj−1|j from the previous round in Bj, ie. Bj

is mined with yj−1 as part of the input.

4. Each node which successfully mines a block adds the mined block to its local chain. Then, it broadcasts

its local chain to all other nodes.

5. For each longest chain received, each node veriﬁes the following:

(a) Let o1, . . . , o(cid:96) be the VDF outputs stored in each block in order starting with the ﬁrst block and
ending with the (cid:96)-th block. Let r1, . . . , r(cid:96) be the rounds associated with the VDF output. Then,
r(cid:96) > r(cid:96)−1 > · · · > r1.

(b) The k-th block in the chain (starting from the genesis block) is mined using yk(cid:48) from round

k(cid:48) ≥ k − 1.

(c) The proofs of the VDF output and the mining output are correct, i.e. the block is correctly mined

using the corresponding VDF output.

6. If i receives a chain where more than one block in the chain is mined with the same yj (for any j

smaller than the current round), the node discards the chain.

7. At the end of round j, i sets yj+1 ← F(yj)|j + 1 and begins computing the next value F(yj+1) using

yj+1 as input.

Due to space constraints, we do not include the proof of Theorem 26; please ﬁnd the full proofs in the full
version of our paper. However, the intuition for our proof is straightforward. Items 5a and 5b ensure that
no chain accepted by an honest node contains more than one block per VDF output. Setting the diﬃculty
of the VDF to the duration of the round ensures that at most one VDF output is produced during a round.
Together, these two observations prove Theorem 26, namely, that any chain held by an honest node can be
extended by at most one block each round.

6Here, a|b is the commonly used notation indicating concatenation between a and b.

12

6 Discussion

Validation and Communication Costs. A higher p means a faster block rate and thus more blocks. The
validation and bandwidth complexity of Nakamoto protocols are proportional to block size and the number
of blocks that are mined, since each miner validates and then communicates every mined block to all other
miners (in practice, nodes do not necessarily gossip shorter chains, and taking advantage of nodes’ memory
overlap can help reduce block transfer size [8]). One needs to determine the optimal value of p that trades
oﬀ validation and bandwidth complexity and chain growth. This work expands the space of p to consider.

Other Symmetry-Breaking Strategies. Here we consider three other symmetry-breaking strategies with
high p. First-seen is where all honest nodes take the ﬁrst chain out of the longest-length chains they see, and
lexicographically-ﬁrst is where honest nodes take the lexicographically-ﬁrst chain of the set of longest chains
according to some predetermined ordering, for example alphabetically. Intuitively, the adversary can control
the network and thus cause diﬀerent honest nodes to see diﬀerent chains of the same length ﬁrst for ﬁrst-seen,
impacting common-preﬁx, or grind on blocks to always produce the lowest lexicographically-ordered chain
for lexicographically-ﬁrst, impacting chain-quality. A third strategy is to use a global-random-coin: Suppose
that all nodes have access to a permutation oracle P that returns a permutation sampled uniformly at random
of a number of elements passed into it where any subset of elements obey the same partial ordering. With P
symmetry-breaking is trivial since all honest nodes will agree on the result of the coin ﬂip. Furthermore, if
the coin is fair, then the number of honest blocks added to the chain is proportional to the fraction of honest
nodes. However, in reality, it is diﬃcult and oftentimes infeasible to ensure such a strong guarantee.
Conclusion.
In this work we show that unlike previously thought, convergence opportunities are not
necessary to make chain progress. We use coalescing random walks to analyze the correctness of Nakamoto
consensus under a regime of puzzle diﬃculty previously thought to be untenable, expanding the space of p
for protocol designers.

References

[1] D. Aldous and J. Fill. Reversible markov chains and random walks on graphs, 2002. 6, 19

[2] V. Bagaria, S. Kannan, D. Tse, G. Fanti, and P. Viswanath. Prism: Deconstructing the blockchain
to approach physical limits. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and
Communications Security, pages 585–602, 2019. 3

[3] E. Blum, A. Kiayias, C. Moore, S. Quader, and A. Russell. The Combinatorics of the Longest-Chain

Rule: Linear Consistency for Proof-of-Stake Blockchains, pages 1135–1154. 3

[4] D. Boneh, J. Bonneau, B. B¨unz, and B. Fisch. Veriﬁable delay functions. In Advances in Cryptology -
CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August
19-23, 2018, Proceedings, Part I, pages 757–788, 2018. 11, 15

[5] D. Boneh, J. Bonneau, B. B¨unz, and B. Fisch. Veriﬁable delay functions. Cryptology ePrint Archive,

Report 2018/601, 2018. https://eprint.iacr.org/2018/601. 2

[6] C. Cooper, R. Elsasser, H. Ono, and T. Radzik. Coalescing random walks and voting on connected

graphs. SIAM Journal on Discrete Mathematics, 27(4):1748–1758, 2013. 19, 20

[7] C. Cooper, A. Frieze, and T. Radzik. Multiple random walks in random regular graphs. SIAM Journal

on Discrete Mathematics, 23(4):1738–1761, 2010. 6

[8] M. Corallo. Compact block relay, 2016.

https://github.com/bitcoin/bips/blob/master/bip-0152.

mediawiki. 13

[9] C. Dwork and M. Naor. Pricing via processing or combatting junk mail.

In Annual international

cryptology conference, pages 139–147. Springer, 1992. 1, 2

[10] EOS.

v2.0 consensus protocol, 2021.

https://developers.eos.io/welcome/v2.0/protocol/consensus

protocol. 2

13

[11] I. Eyal and E. G. Sirer. Majority is not enough: Bitcoin mining is vulnerable. In International conference

on ﬁnancial cryptography and data security, pages 436–454. Springer, 2014. 3

[12] J. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis and applications.
In E. Oswald and M. Fischlin, editors, Advances in Cryptology - EUROCRYPT 2015, pages 281–310,
Berlin, Heidelberg, 2015. Springer Berlin Heidelberg. 1, 2, 3, 4

[13] J. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis and applications. In
Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages
281–310. Springer, 2015. 5, 17

[14] J. Garay, A. Kiayias, and N. Leonardos. Full analysis of nakamoto consensus in bounded-delay networks.

Cryptology ePrint Archive, Report 2020/277, 2020. https://eprint.iacr.org/2020/277. 3, 4

[15] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol with chains of variable
diﬃculty. In J. Katz and H. Shacham, editors, Advances in Cryptology - CRYPTO 2017 - 37th Annual
International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part
I, volume 10401 of Lecture Notes in Computer Science, pages 291–323. Springer, 2017. 1, 2, 3, 4

[16] B. Hajek. Random processes for engineers. Cambridge university press, 2015. 25

[17] A. Kiayias and G. Panagiotakos. Speed-security tradeoﬀs in blockchain protocols. IACR Cryptol. ePrint

Arch., 2015:1019, 2015. 3

[18] L. Kiﬀer, R. Rajaraman, and a. shelat. A better method to analyze blockchain consistency. In Proceed-
ings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, CCS ’18, page
729–744, New York, NY, USA, 2018. Association for Computing Machinery. 2, 3, 4, 5

[19] S. Micali.

Algorand 2021 performance,

2020.

https://www.algorand.com/resources/blog/

algorand-2021-performance. 2

[20] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2009. 1

[21] S. Nakamoto et al. Bitcoin: A peer-to-peer electronic cash system.(2008), 2008. 3

[22] R. Pass, L. Seeman, and A. Shelat. Analysis of the blockchain protocol in asynchronous networks. In
J.-S. Coron and J. B. Nielsen, editors, Advances in Cryptology – EUROCRYPT 2017, pages 643–673,
Cham, 2017. Springer International Publishing. 1, 2, 3, 4, 5

[23] R. Pass, L. Seeman, and A. Shelat. Analysis of the blockchain protocol in asynchronous networks. In
Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages
643–673. Springer, 2017. 5, 17

[24] R. Pass and E. Shi. Fruitchains: A fair blockchain. In Proceedings of the ACM Symposium on Princi-
ples of Distributed Computing, PODC ’17, page 315–324, New York, NY, USA, 2017. Association for
Computing Machinery. 3

[25] K. Pietrzak. Simple Veriﬁable Delay Functions. In A. Blum, editor, 10th Innovations in Theoretical
Computer Science Conference (ITCS 2019), volume 124 of Leibniz International Proceedings in Infor-
matics (LIPIcs), pages 60:1–60:15, Dagstuhl, Germany, 2018. Schloss Dagstuhl–Leibniz-Zentrum fuer
Informatik. 16

[26] L. Ren. Analysis of nakamoto consensus. IACR Cryptol. ePrint Arch., 2019:943, 2019. 3, 4

[27] A. Sapirshtein, Y. Sompolinsky, and A. Zohar. Optimal selﬁsh mining strategies in bitcoin.

In In-
ternational Conference on Financial Cryptography and Data Security, pages 515–532. Springer, 2016.
3

[28] B. Wesolowski. Eﬃcient Veriﬁable Delay Functions (extended version). Journal of Cryptology, Sept.

2020. 16

14

[29] R. Zhang and B. Preneel. Lay down the common metrics: Evaluating proof-of-work consensus protocols’

security. In 2019 IEEE Symposium on Security and Privacy (SP), pages 175–192, 2019. 3

[30] J. Zhao, J. Tang, Z. Li, H. Wang, K. Lam, and K. Xue. An analysis of blockchain consistency in
asynchronous networks: Deriving a neat bound. In 40th IEEE International Conference on Distributed
Computing Systems, ICDCS 2020, Singapore, November 29 - December 1, 2020, pages 179–189. IEEE,
2020. 2, 3, 4

Appendices

A Additional Deﬁnitions

A.1 VDFs

The formal deﬁnition of VDFs is presented below.

Deﬁnition 27 (Veriﬁable Delay Functions [4]). A VDF V = (Setup, Eval, Verify) is a triple of algorithms
that perform the following:

1. Setup(λ, X) → pp = (ek, vk): The Setup algorithm takes as input a security parameter λ and a
desired diﬃculty level X and produces public parameters consisting of an evaluation key ek and a
veriﬁcation key vk. Setup is polynomial time with respect to λ and X is subexponentially-sized in
terms of λ. The public parameters specify an input space X and an output space Y. X is eﬃciently
sampleable. If secret randomness is used in Setup, a trusted setup might be necessary.

2. Eval(ek, x) → (y, π): Eval takes an input x ∈ X (in the sample space of inputs) and the evaluation
key and produces an output y ∈ Y (in the sample space of outputs) and a (possibly empty) proof π.
Eval may use random bits to generate π but not to compute y. Eval runs in parallel time X even
when given poly(log(X), λ) processors for all pp generated by Setup(λ, X) and x ∈ X .

3. Verify(vk, x, y, π) → {Y es, N o}: Verify is a deterministic algorithm that takes the veriﬁcation key
vk, an input x, the output y, and proof π and outputs Y es or N o depending on whether y was correctly
computed from via Eval. Eval runs in time O(log(X)).

Furthermore, V must satisfy the following properties:

1. Correctness A VDF V is correct if for all λ, X, parameters (ek, vk) R←− Setup(λ, X), and all x ∈ X ,

if (y, π) R←− Eval(ek, x), then Verify(vk, x, y, π) → Y es.

2. Soundness A VDF is sound if for all algorithms A that run in time O (poly(X, λ))






P

Verify(vk, x, y, π) = Y es
y(cid:48) (cid:54)= y

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

pp = (ek, vk) R←− Setup(λ, X)
(x, y(cid:48), π(cid:48)) R←− A (λ, pp, X)
(y, π) R←− Eval(ek, x)




 ≤ negl(λ).

3. Sequentiality A VDF is (p, σ)-sequential if no adversary A = (A0, A1) with a pair of randomized
algorithms A0, which runs in total time O(poly(X, λ)), and A1, which runs in parallel time σ(t) on at
most p(t) processors, can win the following game with probability greater than negl(λ):

pp R←− Setup(λ, X)
L R←− A0(λ, pp, X)
x R←− X

yA

R←− A1(L, pp, x).

A = (A0, A1) wins the game if (y, π) R←− Eval(ek, x) and yA = y.

15

There are many implementations in the literature of VDFs (e.g. [25, 28]). We do not provide these
implementations here as it is out-of-scope for our paper, but please refer to these papers for contructions of
VDFs that satisfy the above properties.

A.2 Tail Bounds

We use the following variant of Hoeﬀding’s inequality.

Theorem 28 (Hoeﬀding’s inequality). Let Y1, . . . , Yn be n independent, identically distributed random
i=1 Yi, then
variables drawn from a Bernoulli distribution with parameter p, Yi
Sn ∼ Binom(n, p), E(Sn) = np, and

If Sn = (cid:80)n

i.i.d.∼ Ber(p).

(cid:40)

P

1
n

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

n
(cid:88)

i=1

Yi − pn

(cid:41)

≥ ε

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

≤ 2e−2nε2

.

A.3 The Bitcoin Blockchain System

In this section, for completeness, we provide a high-level overview of the Bitcoin Blockchain System. The
below is mainly to serve as a reminder of the Bitcoin protocol for those unfamiliar with it.
High-Level Description.

The nodes in the system represent miners in the Bitcoin cryptosystem who mine blocks ﬁlled with requests
from clients. Clients represent payers who would like to fulﬁll some transactions. The client issues a write-
request whenever it wants to send a transaction to a miner. The miner then attempts to mine a block
containing the value of the transaction. Speciﬁcally, the following set of steps occur:

• The payer submits a write-request to the system with a valid transaction as the write “value” they

want to add to the public ledger.

• Every honest miner i:

– has a mempool which contains a collection of multi-cast transactions received by this miner.
Notably, due to issues such as network failures and messages delay, the mempool kept by diﬀerent
miners might not be identical, and

– keeps a local valid blockchain Ci.

• In each round, each of the miners:

1. Blockify its local mempool (i.e., creates a block of appropriate size that contains a sub-set of the

transactions in mempool) and removes those blockiﬁed transactions from mempool.

2. Try to add this new block to its local chain Ci.
3. If the miner successfully extends its local chain, it multi-casts the updated chain to other miners.

4. Wait to receive multi-casted chains from others and update its local chain to be the chain that
is the longest among the received chains and its current local chain. If there are multiple longest
chains, use a symmetry breaking mechanism to choose one of them as its new local chain.

In the Bitcoin system, oftentimes, the symmetry is broken in an arbitrary manner, i.e., if there is a tie, an
honest node chooses an arbitrary longest chain (e.g. the chain it received ﬁrst). In an adversarial setting,
this symmetry-breaking strategy could potentially lead to honest nodes choosing diﬀerent chains frequently.
It turns out that this symmetry-breaking rule, with high probability, can guarantee safety as long as it is
suﬃciently hard to successfully mine a block. However, this is not the case when the probability of successfully
mining a block is large. In fact, for such instances, it is important to consider speciﬁc symmetry-breaking
strategies and how they aﬀect the system.

16

B Honest Majority Assumption

The honest majority assumption in the seminal [13] is presented below for completeness. For ease of com-
parison, we use the same notation as that in [13] Let f0 be the probability at least one honest node succeeds
in ﬁnding a proof-of-work (pow) in a round. In [13], the notion of the advantage of honest participants is
used, denoted by δ. It is used to bound b

n−b . In particular, δ is chosen so that

b
n−b ≤ 1 − δ always holds.

Assumption 29 (Honest Majority Assumption [13]). Given an (cid:15) ∈ (0, 1), n, and p, the maximal number
of corrupted nodes b satisﬁes:

• 3f0 + 3(cid:15) < δ ≤ 1, and

• b ≤ (1 − δ)(n − b).

Notably, by deﬁnition of δ, the second bullet in Assumption 29 always holds. Hence, for ﬁxed (cid:15) ∈ (0, 1),

n, and p, the real constraint on b is the relation assumed in the ﬁrst bullet of Assumption 29.

Proof of Proposition 6. By Assumption 29, it holds that

As (cid:15) > 0, (4) implies that 3f < δ. Let f denote the probability at least one honest node succeeds in ﬁnding
a pow in a round. We have f ≥ 1 − (1 − p)(n−b). So

3f + 3(cid:15) < δ ≤ 1.

(4)

Equivalently,

(cid:16)

1 − (1 − p)(n−b)(cid:17)

3

≤ 3f < δ.

log(1 − δ/3) < (n − b) log(1 − p),

for arbitrary base of log as long as the base is ≥ 1. By Taylor expansion, we have

where the last inequality follows from the fact that δ ∈ (0, 1).

(n − b)p <

δ/3
1 − δ/3

≤

δ
2

,

On Remark 7: To see the claim in Remark 7, consider the boundary case where n = 2b + 1 – the honest
nodes barely make it to be the majority of the system. In this case, the upper bound of p in Proposition 6 is

n − 2b
2(n − b)2 =

1
2(n − n−1

2 )2

=

2
(n + 1)2 .

Thus, in expectation, it takes at least n + 1 rounds for the honest nodes to mine a block collectively. Such a
low block generating speed makes it unlikely to have multiple longest chains unless the network delay is very
serious. This observation also justiﬁes why the choice of symmetry breaking rules does not matter much
in [13, 23].

ease of illustration, let’s consider the sequence of bk for k = 1, · · · , (cid:98) n−1
loss of generality, assume that

This observation holds not only for the boundary case when n = 2b + 1 but also for more general b. For
2k+1 n(cid:99). Without
2k+1 n is an integer for all k under consideration. For a system with up to
. In a sense, the
2 n.

bk corrupted nodes, the upper bound in Proposition 6 lies in between
Honest Majority Assumption (formally stated in 29) requires the mining puzzle becomes harder as b → 1
That is, Assumption 29 requires the system to trade oﬀ liveness for tolerating more corrupt nodes.

2 (cid:99) with bk := (cid:98) k

1
2(k+1)n ,

1
(k+1)n

(cid:16)

(cid:17)

k

17

C Proof of Theorem 8

Proof of Theorem 8. We formalize the arguments of the main proof ideas in Section 4.1. Let {c1, · · · , cn}
be a set of n diﬀerent colors. We associate each node in the system with a color. We use (ci, t) to denote
the block generated by honest node i during round t and (c0, 0) to denote the genesis block. We use
(ci, t) → (ci(cid:48), t − 1) to denote the event that block (ci, t) is attached to block (ci(cid:48), t − 1), which occurs with
probability 1
n under our symmetry-breaking rule. To quantify the maximal inconsistency of the longest
chains of round T , we consider the following auxiliary random process. It can be easily shown that there is a
bijection between the sample paths of the Bitcoin blockchain protocol and the sample paths of this auxiliary
process, and that the auxiliary process and the original blockchain protocol with random symmetry breaking
have the same probability distribution.
Auxiliary random procedure: For any given T ≥ 1, do the following:
(i) Let each color generate a block for each of the rounds in {1, 2, · · · , T };
(ii) Attach each of the block (ci, 1) for i = 1, · · · , n to the genesis block (c0, 0);
(iii) For each t ≥ 2 and each (ci, t), attach it to one of the blocks {(ci, t − 1) , i = 1, · · · , n} uniformly at
random (i.e., with probability 1/n).
Connecting to coalescing random walks: Here, we formally quantify the connection between the maximal
inconsistency among the longest chains of round T with the coalescing time of n random walks on an n-
complete graph. Since p = 1 and there is no adversary, the number of longest chains received by each honest
node at each round is n. Let C(T, c1), · · · , C(T, cn) be the n longest chains of round T ending with blocks
(c1, T ) , · · · , (cn, T ), respectively. We ﬁrst show that each of these n chains can be coupled with a random
walk on the n-complete graph. Without loss of generality, let’s consider C(T, c1) which can be expanded as
C(T,c1):=(c0,0)←(ci1,1)←···←(cid:0)cit−1,t−1(cid:1)←(cit,t)←···←(cid:0)ciT −1,T −1(cid:1)←(c1,T ),

(5)

where ct is the color of the (t + 1)-th block in the chain. Note that the chain C(T, c1) is random because
the sequence of block colors c0ci1 · · · cit−1cit · · · ciT −1 c1 is random. Moreover, the randomness in C(T, c1) is
fully captured in the randomness of the block colors. We have

P(cid:8)C(T,c1) = (c0,0) ← (ci1,1) ← ··· ← (cid:0)cit−1,t−1(cid:1) ← (cit,t) ← ··· ← (cid:0)ciT −1,T −1(cid:1) ← (c1,T )(cid:9)

(a)
= P {(c0, 0) ← (ci1 , 1)}

T
(cid:89)

t=2

P (cid:8)(cid:0)cit−1, t − 1(cid:1) ← (cit, t)(cid:9)

=

T
(cid:89)

t=2

P (cid:8)(cid:0)cit−1 , t − 1(cid:1) ← (cit, t)(cid:9) ,

where the last equality is true as P {(c0, 0) ← (ci1 , 1)} = 1, and the equality (a) holds because under our
symmetry-breaking rule, neither the previous history up to round t nor the future block attachment choices
after round t aﬀects the choice of the chain extension in round t. Moreover, the probability of any realization
(cid:1)T −1
of the color sequence c0ci1 · · · cit−1 cit · · · ciT −1c1 (i.e., a sample path on the block colors in Bitcoin) is (cid:0) 1
.
Let’s consider the complete graph with vertex set {c1, c2, · · · , cn}. Under our symmetry breaking rule, the
backwards color sequence c1ciT −1 · · · citcit−1 · · · ci1 (without considering the genesis block) is a random walk
on the n-complete graph starting at vertex c1. Similarly, we can argue that C(T, c2), · · · , C(T, cn) correspond
to n−1 random walks on the n-complete graphs starting at vertices c2, · · · , cn, respectively. As argued in the
main proof ideas paragraph, these n random walks are not fully independent. In fact, they are coalescing
random walks, and their coalescence is exactly the maximal inconsistency among the longest chains of round
T .

n

With the above connection of the longest chain protocol augmented by uniformly-at-random symmetry

breaking with coalescing random walks. We conclude by applying Theorem 11.

18

D Missing proofs and auxiliary results for Section 4.2

Proof of Lemma 15. To characterize the coalescence time, similar to the analysis in [6], for any given k ∈
{1, · · · , ng}, we construct a larger graph Q = Qk = (VQ, EQ), where VQ = V k and two vertices v, w ∈ V k if
{v1, w1} , · · · , {vk, wk} are edges of G. Let Mk be the time until the ﬁrst meeting in the original graph G.
Let S ⊆ VQ denote the set of all possible conﬁgurations of the locations of the ng random walks at the ﬁrst
meeting,

Sk = {(v1, · · · , vk) : vi = vj

for some 1 ≤ i < j ≤ k} .

(6)

It is easy to see that there is a direct equivalence between the u-lazy random walks on G and the single u-lazy
random walk on Q. Since Q is a complete graph with self-loops, the limiting distribution of lazy random
walk on Q is the same as the standard random walk on Q. Let πQ ∈ R|V k| be the stationary distribution of
a standard random walk on Q and let πQ
v . By [6, Lemma 4], we know that for any 1 ≤ k ≤ k∗
πQ
Sk
where k∗ (cid:44) max{2, log ng}, it holds that

= (cid:80)

v∈Sk

πQ
Sk

≥

k2
8ng

.

Let Hv,Sk denote the hitting time of vertex set Sk starting from vertex v and let

H Q

π (HSk ) =

(cid:88)

v∈V k

πQ

v Hv,Sk

denote the expected hitting time of Sk from the stationary distribution πQ. From [1, Lemma 2.1] and the
fact we can contract the vertex set Sk into one pseudo vertex, similar to [6, proof of Theorem 2], we have
that

(cid:16)

(cid:80)∞

t=0

EπQ [HSk ] =

(Sk) − πQ
P t
Sk
St
πQ
Sk
1 − πQ
Sk

≤

(cid:17)

8ng
uk2 .

(cid:16)

≤

8ng
k2

1
u

(cid:16)

(cid:80)∞

t=0

(cid:17)

=

(1 − u)t + (1 − (1 − u)t) πQ
Sk

− πQ
Sk

(cid:17)

πQ
Sk

In addition, by conditioning on whether the particles stay at their initial locations or not, we have

E [Mk] = (1 − u) (1 + E [Mk]) + u (1 + EπQ (HSk )) ,

which implies that

Thus, for any k such that 1 ≤ k ≤ k∗ = {2, log ng}, we have

E [Mk] ≤

(cid:18)

1
u

1 +

(cid:19)

8ng
k2

= O

(cid:16) ng
uk2

(cid:17)

.

E [Ck] ≤

k
(cid:88)

s=2

E [Ms] ≤ O(ng/u).

Let Wu be a lazy random walk on the complete graph G with initial location u. In each round, with
probability (1 − u), Wu stays at its current location and with probability u it moves to one of the current
neighbors (including self-loops) uniformly at random. Let πG the limiting distribution of the location vertex
of Wu. By [6, Eq.(8)], its mixing time is tmix = 3 log ng
3 log ng
log(1/(1−u)) (cid:101),

log(1/(1−u)) , i.e., for any given u ∈ V , when t ≥ (cid:100)

(cid:107)P t

u − πG(cid:107)1 =

(cid:88)

(cid:12)
(cid:12)P t

u(v) − πG
v

(cid:12)
(cid:12)

v∈V
(cid:12)1 − πG
u

= (cid:12)

(cid:12)
(cid:12) (1 − u)t +

(cid:88)

(cid:12)
(cid:12)

(cid:0)1 − (1 − u)t(cid:1) πG

v − πG
v

(cid:12)
(cid:12)

≤ 2(1 − u)t ≤

v:v∈V,v(cid:54)=u
1
n2
g

.

2
n3
g

≤

19

Here, with a little abuse of notation, we use P t
t∗ = k∗ log ng (k∗tmix + 3EπQ (HSk∗ )). Following the arguments in [6, Section 5], we have

u to denote the distribution of the state of Wu at round t. Let

C(ng) ≤ 4t∗ + E [Ck∗ ]

≤ 4 log ng (k∗tmix + 3EπQ (HSk∗ )) + O(ng/u)

≤

4 log4 ng
log 1
1−u
4 log4 ng
u
= O(ng/u),

≤

+ 12 log2 ng

8ng
u log2 ng

+

96ng
u

+ O(ng/u)

+ O(ng/u)

where the last inequality follows from log 1/(1 − u) ≥ u.

The following lemma will be used in the proof of Theorem 12

Lemma 30. Suppose that there k balls. Let X be the number of non-empty bins if we throw each of the k
balls into b bins, where k ≤ b, uniformly at random. Let ˜X be the number of non-empty bins if we throw
each of the k balls into b + ∆ bins, where ∆ ∈ N, uniformly at random. Then ˜X ﬁrst-order stochastically
dominates X.

P {X ≤ l} ≥ P

(cid:110) ˜X ≤ l

(cid:111)

∀l.

Proof. Intuitively speaking, since b < b + ∆, collisions are more likely to occur when fewer bins are available.
Hence, X2 ﬁrst-order stochastically dominates X1. For the sake of peace of mind, a formal proof is given
below.

Let’s consider the mental process wherein we throw the balls into bins one by one. Let Yt after we throw
t balls into b bins. Similarly, Zt be the number of nonempty bins we throw t balls into b + ∆ bins. We show
Lemma 30 by induction on t.
Clearly, Y1 = 1 = Z1.
Induction hypothesis: Suppose for t ≤ k − 1, there exists a coupling between the marginal probabilities of
the above two ball throwing processes such that under this coupling

Yt ≤ Zt.

(7)

When Yt ≤ Zt −1, by Eq.(7) and the monotonicity of Y and Z, it holds that Yt+1 ≤ Yt +1 ≤ Zt ≤ Zt+1. It
remains to consider the case where Yt = Zt. It is easy to see that Yt+1 = Yt if the t+1–th was thrown into the
existing non-empty bins, which occurs with probability P {Yt+1 = Yt} = Yt
b+∆ .
For ease of exposition, let Zt+1 = Zt = γ. Consider the following coupling:

b . Similarly, P {Zt+1 = Zt} = Zt

• If the (t + 1)–th ball of the second bins-and-balls process is thrown into the Zt existing nonempty bins,
then put the (t + 1)–th ball of the ﬁrst bins-and-balls process uniformly at random into its Yt existing
nonempty bins.

probability

• If the (t + 1)–th ball of the second bins-and-balls process is thrown into an empty bin, then with
b(b+∆−γ) put the (t + 1)–th ball of the ﬁrst bins-and-balls process uniformly at random
b(b+∆−γ) , put the (t + 1)–th ball of the ﬁrst

into one existing nonempty bin. With probability 1 −
bins-and-balls process into one empty bin uniformly at random.

∆γ

∆γ

It is easy to see that in the above coupling, the (t + 1)–th ball of the ﬁrst bins-and-balls process is throw
into a bin (regardless whether it is empty or not) with probability 1
b . Moreover, with this coupling and the
induction hypothesis, we know that

Yt+1 ≤ Zt+1,

20

completing the induction proof. Hence, X = Yk ≤ Zk = ˜X. Therefore,

(cid:110) ˜X ≤ l

(cid:111)

P

≤ P {X ≤ l} , ∀ l,

i.e., ˜X ﬁrst-order stochastically dominates X.

Proof of Theorem 12. For any t, the expected length of a longest chain is 1 + (1 − (1 − p)n) t. When
p < 4 ln 2
n , we can use Poisson approximation to approximate the distribution of number of blocks in each
round. A straightforward calculation shows that the probability of having exactly one block in a round
is np exp (−np) . Thus, in expectation, the maximal inconsistency is at most
np exp(−np) . Henceforth, we
restrict our attention to the setting where p ≥ 4 ln 2
and quantify the expected maximal inconsistency among
the longest chains of round t. We ﬁrst consider a coarse analysis whose arguments are similar to the proof
of Theorem 8 and derive a bound on the maximal inconsistency via stochastic dominance. Though the
obtained bound could be very loose, based on the insights obtained in this coarse analysis, we can come up
with a much ﬁne-grained analysis, which signiﬁcantly improves the bound on maximal inconsistency.

n

1

A coarse analysis: Let {c1, · · · , cn} be a set of n diﬀerent colors. We temporarily associate each node
in the system with a color. 7 If node i mines a block during round t, we denote this block by (ci, t). In
addition, we use (c0, 0) to denote the genesis block. We use (ci, t) → (ci(cid:48), t − 1) to denote the event that
both blocks (ci, t) and (ci(cid:48), t − 1) exist and that block (ci, t) is attached to block (ci(cid:48), t − 1), which, under
our symmetry-breaking rule, occurs with probability

1{node ci mines a block during round t}1{node ci(cid:48) mines a block during round t − 1}

(cid:80)n

i(cid:48)=1

1{node ci(cid:48) mines a block during round t − 1}

.

Notably, in the Bitcoin protocol, there are two sources of randomness: (1) the randomness in generating
blocks and (2) the randomness in the block attachments. To quantify the maximal inconsistency of the
longest chains of round T , we consider the following auxiliary random process. It can be easily shown that
there is a bijection between the sample paths of the Bitcoin blockchain protocol and the sample paths of this
auxiliary process, and that the auxiliary process and the original blockchain protocol with random symmetry
breaking have the same probability distribution.
Auxiliary random procedure: For any given T ≥ 1, do the following:
(i) For each of the rounds in {1, 2, · · · , T }, let each node/color generate a block with probability p indepen-
dently of other nodes and independently across rounds. For ease of exposition, we refer to the blocks mined
in round t as the blocks in layer t.
(ii) Attach each of the block (ci, 1), if exists, for i = 1, · · · , n to the genesis block (c0, 0);
(iii) For each t ≥ 2 and each (ci, t) that exits, attach it to one of the blocks in layer (t − 1). If layer (t − 1)
is empty, let

t(cid:48) (cid:44) max {r : layer r is nonempty and r ≤ t} ,

and let each existing (ci, t) uniformly at random chooses one ancestor block in block layer t(cid:48).
Connecting to coalescing random walks: We ﬁrst build a coarse connection between the maximal inconsis-
tency among the longest chains of round T with the coalescing time of n random walks on an n-complete
graph. A much ﬁne-grained connection to coalescing random walks on 2np-complete graph in given in ﬁne-
grained analysis part of this proof. It is easy to see that the number of blocks mined in each round t, denoted
by Nt, follows the Binom(n, p) distribution. Without loss of generality, we assume that NT (cid:54)= 0. If this
does not hold, then we can replace T by the most recent round T (cid:48) such that NT (cid:48)
(cid:54)= 0 and the remaining
proof goes through. Since there is no adversary, the number of longest chains at the end of round T is NT ,
each of which ends with a block in block layer T . Let C(T, c(cid:48)
) be the NT longest chains of
NT
, T (cid:1), respectively. We ﬁrst show that each of these NT chains
round T ending with blocks (c(cid:48)

1), · · · , C(T, c(cid:48)

1, T ) , · · · , (cid:0)c(cid:48)

NT

7In our ﬁne-grained analysis, the color of a block will be re-assigned.

21

can be coupled with a process that is a variant of a random walk on the n-complete graph. Without loss of
generality, let’s consider C(T, c(cid:48)

1) which can be expanded as

C(T, c(cid:48)

1) := (c0, 0) ← (ci1, 1) ← · · · ← (cid:0)cik−1 , k − 1(cid:1) ← (cik , k) ← · · · ← (cid:0)ciK−1, K − 1(cid:1) ← (c(cid:48)

1, T ) ,

(8)

where c(cid:48)
k is the color of the (k + 1)-th block in the chain and K is the number of non-empty block layers
under event E – in the realization of block mining. Recall that for general p ∈ (0, 1) there are two sources
of randomness (1) the randomness in block generating and (2) the randomness in block attachment. Con-
sequently, the sequence of block colors c0ci1 · · · cik−1cik · · · ciK−1 c(cid:48)
1 is random in that, roughly speaking, the
“feasibility” of cik is determined by whether node ik mines a block during round k or not, and the ordering of
the “feasible” colors is determined by the attachment choices. Let E be any realization of the block mining
for the ﬁrst T rounds, which corresponds to any realization of step (i) of the auxiliary process. We have

1) | E}

P {C(T, c(cid:48)
= P (cid:8)(c0, 0) ← (ci1 , 1) ← · · · ← (cid:0)cik−1, k − 1(cid:1) ← (cik , k) ← · · · ← (cid:0)ciK−1, K − 1(cid:1) ← (c(cid:48)

1, T ) | E(cid:9)

(a)
= P {(c0, 0) ← (ci1, 1) | E}

(cid:32)K−1
(cid:89)

k=2

P (cid:8)(cid:0)cik−1 , k − 1(cid:1) ← (cik , k) | E(cid:9)

(cid:33)

P (cid:8)(cid:0)ciK−1 , K − 1(cid:1) ← (c(cid:48)

1, T ) | E(cid:9)

(cid:32)K−1
(cid:89)

=

k=2

P (cid:8)(cid:0)cik−1 , k − 1(cid:1) ← (cik , k) | E(cid:9)

(cid:33)

P (cid:8)(cid:0)ciK−1 , K − 1(cid:1) ← (c(cid:48)

1, T ) | E(cid:9) ,

1
nt

t:2≤t≤T,&nt(cid:54)=0

where the last equality is true as P {(c0, 0) ← (ci1 , 1) | E} = 1, and the equality (a) holds because under our
symmetry-breaking rule, neither the previous history up to round t nor the future block attachment choices
after round t aﬀects the choice of the chain extension in round t. Moreover, the conditional probability of
any realization of the color sequence c0ci1 · · · cik−1 cik · · · ciK−1c(cid:48)
1 conditioning on E (i.e., a sample path on
the block colors in Bitcoin) is (cid:81)
where Nt = nt for all t ∈ {2, · · · , T }. Let’s consider the
complete graph with vertex set {c1, c2, · · · , cn}. Under our symmetry breaking rule, conditioning on E, the
backwards color sequence c(cid:48)
1ciK−1 · · · cik cik−1 · · · ci1 (without considering the genesis block) is a walk, though
not the standard random walk, of length T on the n-complete graph with initial location c(cid:48)
1. Similarly, we
can argue that C(T, c(cid:48)
) correspond to (NT − 1) walks on the n-complete graphs starting at
vertices c(cid:48)
, respectively. Similar to the argument in the proof of Theorem 8, conditioning on E,
there is an one-to-one correspondence between the event of the forking of the chains C(T, c(cid:48)
)
and the event of coalescence of the backwards walks; that is, the maximal inconsistency of the longest chains
of round T is the same as the coalescence time of the NT walks on the n-complete graphs. These NT walks
are more likely to coalesce than the standard random walks whose transition probability is 1/n, whereas
under any E, Nt = nt ≤ n for t = 1, · · · , T ; this fact can be formally shown via Lemma 30. Hence, the
conditioning on E, the maximal inconsistency is upper bounded by the coalescence time of the standard
random walks on n-complete graph with n particles, which is O(n). Since this is true for all possible block
mining realization E, we conclude that the maximal inconsistency is upper bounded by O(n).

1), · · · , C(T, c(cid:48)

2), · · · , C(T, c(cid:48)

2, · · · , c(cid:48)

NT

NT

NT

A ﬁne-grained analysis: Let E any realization of the block mining for the ﬁrst T rounds. If not explicitly
mentioned, the following arguments are stated conditioning on E. To conclude the proof, towards the end
of this proof, we take average over all possible events E.

The bound on the maximal inconsistency is O(n) which could be loose for a wide value range of p. This is
because the upper bound on Nt is loose. Recall that Nt is a Binom(n, p). Thus, E [Nt] = np (cid:28) n as long as
p = o(1). Observing this, in this ﬁne-grained analysis, we ﬁrst construct a lazy version of the NT backwards
walks whose expected coalescence time is at least the coalescence time of the original NT backwards walks.
Then re-color the mined blocks so that the re-colored lazy version of the NT original walks are walks on at
most 2np colors only. Then, we connect these lazy walks with the a lazy version of random walks each of
which, if not stay at their current locations concurrently, moves to one of the neighboring colors (including
its current color) with probability 1
2np . Finally, by changing of the order of taking expectation, we show that
3 np(cid:1))-lazy
the maximal inconsistency is upper bounded by the expected coalescence time of the (1 − 2 exp (cid:0)− 1
random walks. We conclude the proof of this theorem by applying Lemma 15.
Lazy walks construction: Consider the following nT lazy version of the backwards coalescing walks. For
each s = 1, · · · , K − 1, if nK−s ≤ 2np, each of the remaining walks moves to one of the block color in layer

22

(K − s) uniformly at random. If two or more walks visit the same color, then these walks coalesce into one.
If nK−s > 2np, we let the remaining walks stay at their current color vertices. Clearly, this lazy version
of the NT backwards walks are more likely to coalesce than the original NT walks. Let Cl(E) denote the
expected number of backwards steps until all the lazy NT walks coalesce.
Color re-assignment: Next we show that, under any E, Cl(E) is upper bounded by the expected coalescence
time of max{2np, nT } lazy random walks on the 2np-complete graph. Towards this, we ﬁrst do color-
reassignment, detailed as follows. Let {˜c1, · · · , ˜cn} be a set of n diﬀerent colors. We (re-)assign a color to
each of the mined block in diﬀerent block layers as follows: Assign color ˜c1 to the genesis block. For each
t = 1, · · · , T such that Nt (cid:54)= 0, let it
be the indices of the nodes/original colors each of which
successfully mines a block during round t. Re-assign colors ˜c1, · · · , ˜cNt to blocks
re-colored blocks are denoted as (˜c1, t) , · · · , (˜cNt, t), respectively.

1 < · · · < it
Nt

. The

cit
Nt

, · · · ,

cit

, t

, t

(cid:17)

(cid:16)

(cid:17)

(cid:16)

1

Notably, diﬀerent from the color assignment we used in the proof for the case when p = 1, under the above
color re-assignment rule, the blocks mined by the same node at diﬀerent rounds could be assigned diﬀerent
colors. Fortunately, it is easy to see that the blocks attachments are independent of the color assignments.
In particular, it is still true that the maximal inconsistency among the longest chains of round T is the same
as the coalescence time of the corresponding backwards walks on those colors. Moreover, it is still true that
the expected coalescence time of the re-colored NT walks is upper bounded by Cl(E) the lazy version of the
re-colored NT walks. More importantly, the re-colored lazy NT walks, expect for their initial colors, are the
walks on at most 2np colors in each round.

Consider the following max {2np, NT } lazy coalescing random walks on the 2np-complete graph with
arbitrary but distinct initial locations. For each s = 1, ...T , if the above NT lazy version of the walks on
colors stay at their own locations concurrently (i.e., NT −s ≥ 2np) or NT −s = 0, then each of the remaining
random walks on the 2np-complete graph also stay at their current locations. If otherwise (i.e., each of the
lazy walks on colors moves to one of the colors assigned to the blocks in the proceeding non-empty layer
uniformly at random), we let each of the remaining walks on the 2np-complete graph moves to one of the 2np
vertices uniformly at random. By Lemma 30, we know the expected coalescence time of the NT lazy walks
on colors is upper bounded by that of the max {2np, NT } walks on the 2np-complete graph which is again
upper bounded by the expected coalescence time of 2np lazy walks on the 2np-complete graph, denoted by
Cl,np(E).

Next we consider averaging over all the realizations of E. For any given T , with the above arguments,

we know that the expected maximal inconsistency is upper bounded by

Cl,np(E)P {E} .

(cid:88)

E

Note that by construction, Cl,np(E) depends on E only through the number of blocks mined in each round.
In particular, it only depends on each Nt in whether 1 ≤ Nt < 2np holds or not. So we have

Cl,np(E)P {E} =

(cid:88)

Cl,np(n1, · · · , nT −1)P {Nt = nt, ∀ t ≤ T − 1}

n1,··· ,nT −1

Cl,np(n1, · · · , nT −1)P {NT −1 = nT −1}


 P {Nt = nt, ∀ t ≤ T − 2}





(cid:88)

nT −1

(Cl,np(n1, · · · , nT −1 ∈ {2np, · · · , n} ∪ {0})P {NT −1 ≥ 2np or NT −1 = 0}

(cid:88)

E

=

=

(cid:88)

n1,··· ,nT −2
(cid:88)

n1,··· ,nT −2

+ Cl,np(n1, · · · , nT −1 ∈ {1, · · · , 2np − 1} )P {1 ≤ NT −1 < 2np}) P {Nt = nt, ∀ t ≤ T − 2} .

Note that when nT −1 ∈ {2np, · · · , n} ∪ {0}, each of the 2np random walks stay at their initial locations
concurrently with occurs with probability P {NT −1 ≥ 2np or NT −1 = 0}, and when nT −1 ∈ {1, · · · , 2np−1},
each of the 2np random walks take one step standard coalescing random walks. That is, the 2np random
walks are performing one step (1 − P {NT −1 ≥ 2np or NT −1 = 0})-lazy random walk on the 2np-complete
graph. Since Nt is i.i.d. across t, we can repeat this argument for T − 1 times. In fact, we can exchange
the order taking expectation over E and taking expectation over the realization of the walks. Hence,

23

(cid:80)

E Cl,np(E)P {E} equals the expected coalescence time of 2np (1 − P {NT −1 ≥ 2np or NT −1 = 0})-lazy

random walks. By Lemma 15, we know that

Cl,np(E)P {E} = O

(cid:88)

E

(cid:18)

2np
(1 − P {NT −1 ≥ 2np or NT −1 = 0})

(cid:19)

.

In addition, we have

P {Nt ≥ 2np, or Nt = 0} = P {Nt ≥ 2np} + P {Nt = 0}

= P {Nt ≥ 2np} + (1 − p)n = P {Nt ≥ 2np} + exp

(cid:18)

−n log

(cid:19)

1
1 − p

(cid:18)

≤ exp

−

1
3

(cid:19)

(cid:18)

np

+ exp

−n log

(cid:19)

1
1 − p

(cid:18)

≤ 2 exp

−

(cid:19)

np

,

1
3

where the last inequality holds because p ≤ log 1

1−p when p ∈ [0, 1). So, it holds that

Cl,np(E)P {E} = O

(cid:88)

E

(cid:32)

2np

(cid:0)1 − 2 exp (cid:0)− 1

3 np(cid:1)(cid:1)

(cid:33)

,

proving the theorem.

E Missing proofs and auxiliary results for Section 4.3

Proof of Lemma 19. For each round τ , the following holds:

• If no blocks are mined, then the lengths of the adversarial longest chains and the honest longest chains

(longest chains kept by an honest node) are not changed.

• If both the honest and the corrupt nodes mine a block, then the lengths of the adversarial longest
chains increases by 1, and length of the honest longest chains (longest chains kept by an honest node)
increases by at least 1. To see the later, let’s denote the length of the longest chains at the honest
nodes at round (τ − 1) by (cid:96)(τ −1) and the length of the longest chains at the honest nodes at round τ by
(cid:96)τ . By the selective relay rule speciﬁed right before Deﬁnition 17, by the beginning of round τ , every
honest node has received a chain that is at least (cid:96)(τ −1). If the adversary does not release a preﬁx of
an adversarial chain of length > (cid:96)(τ −1), the length of the longest chains kept by the honest nodes at
round τ is (cid:96)τ = (cid:96)(τ −1) + 1. Otherwise, due to the longest chain policy, it holds that (cid:96)τ > (cid:96)(τ −1) + 1.

• If only corrupt nodes mine a block, then the adversary can grow the length of the adversarial longest

chains by 1. The length of the longest chains at the honest nodes is unchanged.

• If only honest nodes mine a block, then the length of the honest longest chains increase by at least 1.
The formal argument follows the same as the proof of the later part of the second bullet. The length
of the longest chains at the corrupt nodes (adversary) is unchanged.

Let t(cid:48) (cid:44) max{t(cid:48) : N (t(cid:48)) = 0 and t(cid:48) ≤ t}. Let t(cid:48) = t0 < t1 < · · · < tk be the round indices of the jumps of the
random process N (τ )∞

τ =0, i.e.,

N (t0) (cid:54)= N (t0 + 1), · · · , N (tk − 1) (cid:54)= N (tk).

By the construction of N (τ )∞
τ =0, we know that from round t(cid:48) + 1 to round t, the number of rounds in which
only corrupt nodes mine a block is N (t) larger than the number of rounds in which only honest nodes mine
a block.

Therefore, we know that as long as at round t(cid:48), the length of the adversarial longest chain is no longer
than the length of the honest longest chains, we can conclude that at the end of round t, the length of the

24

adversarial longest chains is at most N (t) blocks longer than the length of the honest longest chains. It
remains to show the following is true: “At round t(cid:48), the length of the adversarial longest chain is no longer
than the length of the honest longest chain. ”

Let N (t(cid:48)) be the k–th time starting from round 0 such that

N (t(cid:48)) = 0 and N (t(cid:48) + 1) = 1.

If k = 1, by the arguments in the above four bullets, we know the claim holds. Let’s assume this claim holds
for general r. We next prove it holds for r + 1. Let t(cid:48)(cid:48) be the r–th time starting from round 0 such that

N (t(cid:48)(cid:48)) = 0 and N (t(cid:48)(cid:48) + 1) = 1.

By induction hypothesis, we know that at round t(cid:48)(cid:48), the length of the adversarial longest chain is no longer
than the length of the honest longest chain. By the ﬁrst part of the proof of Lemma 19, we know at round
t(cid:48), the length of the adversarial longest chain is no longer than the length of the honest longest chain. Thus,
the proof of the claim is complete.

The following lemma follows from Hoeﬀding’s inequality.
(cid:17)(cid:17)

(cid:16)

(cid:16)

Lemma 31. With probability at least

1 − exp

− (p∗)2M
2

, it holds that

M
(cid:88)

i=1

1{J (m) (cid:54)= J (m − 1)} ≥

1
2

p∗M.

(9)

Next we prove Lemma 22.

Proof of Lemma 22. From [16, Chapter 4.10] we know that {J (t)}∞
t=0 has a corresponding jump process
(also referred to as the embedded chain) that describes, conditioning on state changes, how J (t) jumps
among diﬀerent states. We also know that this jump process is a simple random walk. Concretely, if
J (t − 1) (cid:54)= J (t), we say a jump occurs at t. Let Tr denote the number of rounds that elapses between the
r-th and r + 1-th jumps of J . Let ˜J (r) denote the state after r jumps. By deﬁnition,
is the
jump process of {J (t)}∞
t=0. It is easy to see that Tr is a geometric random variable with parameter p∗. Also,
T1, T2, · · · are i.i.d. distributed. By [16, Proposition 4.9], we know

(cid:110) ˜J (r)

(cid:111)∞

r=0

˜J (r) =






0,
˜J (r − 1) + 1,
˜J (r − 1) − 1,

if r = 0;
with probability p+1/p∗;
with probability p−1/p∗.

Let δr = ˜J (r) − ˜J (r − 1) for any r ≥ 1. It is easy to see that δr is a Bernoulli random variable supported
on {−1, +1} and P {δr = 1} = p+1/p∗. For a given K ≥ 0 jumps, by Hoeﬀding’s inequality, we know that
with probability at least

, the following is true

1 − exp

(cid:17)(cid:17)

(cid:16)

(cid:16)

− K(p+1/p∗−p−1/p∗)2
8

K
(cid:88)

r=1

δr ≥

(p+1/p∗ − p−1/p∗)
2

K.

Setting K = 1

2 p∗M , we have

K
(cid:88)

r=1

δr =

2 p∗M
1
(cid:88)

r=1

(cid:17)
(cid:16) ˜J (r) − ˜J (r − 1)

= ˜J (

1
2

p∗M ) − ˜J (0) = ˜J

(cid:19)

.

p∗M

(cid:18) 1
2

In addition, from Lemma 31, we know that with probability at least (1 − exp (cid:0)−((p∗)2M )/2(cid:1)), it holds that

M
(cid:88)

i=1

1{J (m) (cid:54)= J (m − 1)} ≥

1
2

p∗M.

(10)

Thus, J (M ) ≥ ˜J (cid:0) 1

2 p∗M (cid:1), proving the lemma.

25

Lemma 32. For any t > 1 round such that N (t) = 0 and at least one block is mined, let NB(t) be the
number of blocks mined by the honest nodes in round t and AB(t) be the number of blocks mined by the
corrupt nodes in round t. For ˜t (cid:44) min{t(cid:48) : t(cid:48) ≤ t − 1} such that at least one block is mined, let AB(˜t) be the
number of blocks mined by corrupt nodes in round ˜t. Then it is true that the number of longest chains at
the end of round t is at most (cid:0)NB(t) + AB(t) + AB(˜t)(cid:1). In particular, if N (t − 1) = 0, then the number of
longest chains at the end of round t is at most (NB(t) + AB(t)). Moreover, all of these longest chains end
with blocks generated in round t.

Proof. One of the following two cases hold.
Case 1: Suppose that N (t − 1) = 0. By Lemma 19, at the beginning of round t, the longest chains received
(including their own local chains) by each of the honest node are of the same length. Thus, the number of
longest chains at the end of round t is (NB(t) + AB(t)) – the number of blocks generated during round t.
Case 2: Suppose that N (t − 1) (cid:54)= 0. Recall that ˜t (cid:44) max{t(cid:48) : t(cid:48) ≤ t − 1} such that at least one block is
generated during round ˜t. By Deﬁnition 17 and the fact that N (t) = 0, we know that N (˜t) = 1. From
Lemma 19, we know that, at the end of round ˜t, the length of the adversarial longest chains of round ˜t is at
most one block longer than the local chains at the honest nodes. The adversary can choose either to hide
these longest adversarial chains to some/all honest parities or to release those chains to all of the honest
nodes. The number of such adversarial longest chains is at most AB(˜t) – the number of blocks mined by
the corrupt nodes in round ˜t. Hence the number of longest chains at the beginning of round t is at most
AN(˜t) + AB(t) + NB(t).

Lemma 33. Let i1 and i2, where i1 (cid:54)= i2, be two arbitrary honest nodes. For any (t − 1) ≥ 1 such that
at least one block is mined during round t − 1, let C1(t) and C2(t) be the sets of longest chains received by
honest nodes i1 and i2, respectively, at round t before mining (including the chains sent by others at the end
of round t − 1 and forwarded at the beginning of round t). If N (t − 1) = 0, it holds that

|C1(t) ∪ C2(t)| ≥ NB(t − 1),

and

max{|C1(t)| , |C2(t)|} ≤ NB(t − 1) + AB(t − 1) + AB((cid:93)t − 1),

where (cid:93)t − 1 : max{t(cid:48) : t(cid:48) ≤ t − 2}. Moreover, if N (t − 2) = 0, then

max{|C1(t)| , |C2(t)|} ≤ NB(t − 1) + AB(t − 1).

(11)

(12)

(13)

Proof. Since N (t − 1) = 0, both C1(t) and C2(t) are subsets of the longest chains at the end of round (t − 1).
In addition, from Lemma 32, we know that the total number of longest chains at the end of round t − 1 in
the system is at most NB(t − 1) + AB(t − 1) + AB((cid:93)t − 1), proving Eq.(12). As each of the honest nodes
who successfully mines a block during round (t − 1) multi-casts its local chain to others, both i1 and i2 will
receive all of the longest chains that end with an honest block. That is,

|C1(t) ∪ C2(t)| ≥ NB(t − 1),

proving Eq.(11). Since N (t − 1) = 0, it is easy to see that NB(t − 1) ≥ 1.

When N (t − 2) = 0, it holds that each of the honest node receives at least one longest chain up to the
beginning of round t − 1. Thus, the total number longest chains (including both the ones extended by the
honest nodes and the ones extended by the corrupt nodes) is AB(t − 1) + NB(t − 1). Since a corrupt node
can choose to not to multi-cast its local chain, it holds that

max{|C1(t)| , |C2(t)|} ≤ NB(t − 1) + AB(t − 1).

Note that as a corrupt node can arbitrarily choose, independently of others, which subset of honest nodes
to send its local chain, the honest nodes i1 and i2 can be two diﬀerent subsets of the longest chains at the
end of round t − 1.

26

F VDF-Scheme Proofs

The above VDF-based scheme presented in Section 5 gives us the following properties which will be crucial
in obtaining our bounds for the case when adversaries are present. We present the proofs omitted from
Section 5 in this section.

Lemma 34. For every round t ≥ 0, the local chain of every honest node can contain at most one block per
VDF output, with all but negligible probability in λ.

Proof. Item 5a ensures that the VDF outputs stored in the blocks are computed in strictly increasing order.
This means that no chain veriﬁed by an honest node can contain two blocks which contain the same VDF
output. Finally, with all but negligible probability in λ (by Deﬁnition 25), no two VDF outputs will be
equal. The lemma follows.

Lemma 35. The adversary can add at most one block to the same chain (that will be veriﬁed by honest
nodes) during any round r ≥ 0, with all but negligible probability in λ. In other words, let t be the current
round, any adversarial chain veriﬁed by honest nodes cannot have length greater than t.

Proof. By Lemma 34, no adversary can add two blocks with the same VDF output to the same chain. Thus,
in any adversarial chain veriﬁed by honest nodes, the adversary can add at most 1 block per round, and the
chain will have length at most t (where t is the current round).

Lemma 36. Let t be the current round. No node can add a block containing a VDF output, ot(cid:48), from a
round t(cid:48) ≥ t.

Proof. We prove this via induction. In the base case when the chain only contains the genesis block, the
adversary has access only to the genesis block and no other blocks. In this case, the adversary could not
have mined any other blocks because it did not have time to obtain the VDF output for the next block, with
all but negligible probability in λ. Let our induction hypothesis be that the adversary cannot use dt to mine
a block in round t. We assume this is true for the t-th round and prove this true for the (t + 1)-st round.

By our induction hypothesis, the adversary could not have computed any blocks for the t-th round using
dt. This means that the adversary obtained dt at the beginning of the (t + 1)-st round. Then, suppose the
adversary computes a block for the (t + 1)-st round. By Item 2 of Deﬁnition 27, the adversary could not
have computed the output in time less than the duration of a round,8 with all but negligible probability in
λ. Thus, the adversary could not have mined any blocks using dt+1 until round t + 2. Hence, no adversary
can use dt+1 in mining any blocks during any round t(cid:48)(cid:48) ≤ t + 1.

Proof of Theorem 26. Lemma 36 states that the adversary cannot mine a block with VDF output, ot(cid:48), from
a round t(cid:48) > t where t is the current round. Thus, during round t, an adversary can only use VDF outputs,
o1, . . . , ot−1. Then, Lemma 34 and Lemma 35 ensure that no two blocks in a chain can contain the same
VDF output. Then, the length of any chain accepted by an honest node has length at most t since it can
contain at most one block using each of the VDF outputs, o1, . . . , ot−1 (plus the genesis block).

8Recall we set the diﬃculty of the VDF to be the duration of a round.

27

