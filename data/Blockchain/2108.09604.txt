1
2
0
2

g
u
A
2
2

]

C
D
.
s
c
[

1
v
4
0
6
9
0
.
8
0
1
2
:
v
i
X
r
a

The Power of Random Symmetry-Breaking
in Nakamoto Consensus

Lili Su âˆ—
ECE
Northeastern University

Quanquan C. Liu
CSAIL
Massachusetts Institute of Technology

Neha Narula
MIT Media Lab
Massachusetts Institute of Technology

August 24, 2021

Abstract

Nakamoto consensus underlies the security of many of the worldâ€™s largest cryptocurrencies, such as
Bitcoin and Ethereum. Common lore is that Nakamoto consensus only achieves consistency and liveness
under a regime where the diï¬ƒculty of its underlying mining puzzle is very high, negatively impacting
overall throughput and latency.
In this work, we study Nakamoto consensus under a wide range of
puzzle diï¬ƒculties, including very easy puzzles. We ï¬rst analyze an adversary-free setting and show that,
surprisingly, the common preï¬x of the blockchain grows quickly even with easy puzzles. In a setting
with adversaries, we provide a small backwards-compatible change to Nakamoto consensus to achieve
consistency and liveness with easy puzzles. Our insight relies on a careful choice of symmetry-breaking
strategy, which was signiï¬cantly underestimated in prior work. We introduce a new methodâ€”coalescing
random walksâ€”to analyzing the correctness of Nakamoto consensus under the uniformly-at-random
symmetry-breaking strategy. This method is more powerful than existing analysis methods that focus
on bounding the number of convergence opportunities.

1

Introduction

Nakamoto consensus [20], the elegant blockchain protocol that underpins many cryptocurrencies, achieves
consensus in a setting where nodes can join and leave the system without getting permission from a cen-
tralized authority. Instead of depending on the identity of nodes, it achieves consensus by incorporating
computational puzzles called proof-of-work [9] (also known as mining) and using a simple longest-chain pro-
tocol.1 Nodes in a network maintain a local copy of an append-only ledger and gossip messages to add to the
ledger, collecting many into a block. A block consists of the set of records to add, a pointer to the previous
block in the nodeâ€™s local copy of the ledger, and a nonce, which is evidence the node has done proof-of-work,
or solved a computational puzzle of suï¬ƒcient diï¬ƒculty, dependent on the block. The node then broadcasts
its local chain to the network. Honest nodes choose a chain they see with the most proof-of-work to continue
building upon.

Previous work deï¬ned correctness and liveness in proof-of-work protocols (also referred to as the Bitcoin
backbone) using three properties: common-preï¬x, chain-quality, and chain-growth [12, 15, 22]. Informally,
common-preï¬x indicates that any two honest nodes share a common preï¬x of blocks, chain-growth is the
rate at which the common preï¬x grows over time, and chain-quality represents the fraction of blocks created
In previous work, achieving these properties critically relied on the setting
by honest nodes in a chain.

âˆ—Correspondence author. Email: l.su@northeastern.edu.
1We use â€longest chainâ€ to mean the one with the most proof-of-work given diï¬ƒculty adjustments, not necessarily the one

with the most blocks, though without considering diï¬ƒculty adjustments they are the same.

1

 
 
 
 
 
 
of the diï¬ƒculty factor in the computational puzzles. We express this as p, the probability that any node
will solve the puzzle in a given round. Previous work analyzing Nakamoto consensus has shown that for
consistency and liveness p should be very small in relation to the expected network delay and the number of
nodes [12, 22]. For example, mining diï¬ƒculty in Bitcoin is set so that the network is only expected to ï¬nd a
puzzle solution roughly once every ten minutes.

Requiring a small p increases block time, removing a parameter for improving transaction throughput.
One way to compensate is by increasing block size, which could result in burstier network traï¬ƒc and longer
transaction conï¬rmation times for users. Newer chains which do not use proof-of-work seem to favor short
block times, probably because users value a fast ï¬rst block conï¬rmation: in EOS, blocks are proposed every
500 milliseconds [10] and Algorand aims to achieve block ï¬nality in 2.5 seconds [19], whereas in Bitcoin
blocks only come out every ten minutes.

Common belief is that larger p fundamentally constrains chain growth (i.e., the growth of the common
preï¬x), even in the absence of an adversary, due to the potential of increased forking: nodes will ï¬nd puzzle
solutions (and thus blocks) at the same time; because of the delay in hearing about other nodesâ€™ chains
nodes will build on diï¬€erent chains, delaying agreement. Another common conjecture, explicitly mentioned
in [12], is that the choice of symmetry-breaking strategies, or ways honest nodes choose among multiple
longest chains, is not relevant to correctness.

In this paper, we show that these common beliefs are incorrect. In particular, we show that when p is
beyond the well-studied region even the simple strategy of choosing among chains of equal length randomly
fosters chain growth, especially in the absence of adversaries.

Contributions. In this work, we formally analyze Nakamoto consensus under a wide range of p including
large p. We conï¬rm previous (informal) analysis that Nakamoto consensus requires small p in the presence
of adversaries, but show that surprisingly, it does not in a setting without adversaries, even if p = 1 (all
nodes mine blocks every round) with a minor change in nodesâ€™ symmetry-breaking strategy. Previous work
assumed the requirement of convergence opportunities, a period when only one honest node mines a block,
in order to achieve consistency [18, 22]; we show that in fact convergence opportunities are not required
for common-preï¬x and chain growth. With an additional backwards-compatible modiï¬cation to Nakamoto
consensus, we can derive a bound on the chain growth for a wider range of p (including large p) in a setting
with adversaries. Our key idea in this modiï¬cation is to introduce a veriï¬able delay function [5] to prevent the
adversaries from extending a chain by multiple blocks in a round. Our analysis is based on a new application
of a well-known technique, coalescing random walks. To our knowledge this is the ï¬rst application of
coalescing random walks to analyze the common-preï¬x and chain quality of Bitcoin and other proof-of-work
protocols. We thoroughly analyze Nakamoto consensus with the uniformly-at-random symmetry-breaking
strategy and discuss diï¬€erent symmetry-breaking strategies including ï¬rst-seen, lexicographically-ï¬rst, and
global-random-coin.

In summary, our contributions are as follows:

â€¢ A new approach for analyzing the conï¬rmation time of the Bitcoin protocol under the uniformly-at-
random symmetry-breaking strategy in the adversarial-free setting via coalescing random walks. Our
analysis works for a new region of p, and shows that previous worksâ€™ requirement for convergence
opportunities was unneeded.

â€¢ New notions of adversarial advantages and coalescing opportunities to provide a more general analysis

of common-preï¬x and chain growth in Nakamoto consensus in the presence of adversaries.

Related Work. Proofs-of-work were ï¬rst put forth by Dwork and Naor [9]. Garay, Kiayias, and Leonar-
das [12] provided the ï¬rst thorough analysis of Nakamotoâ€™s protocol in a synchronous static setting, intro-
ducing the ideas of common-preï¬x, chain quality and chain growth. Later work [15] extended the analysis
to a variable diï¬ƒculty function. Pass, Seeman, and shelat [22] extended the idea of common-preï¬x to future
self-consistency, and provided an analysis of Nakamoto consensus in the semi-synchronous setting with an
adaptive adversary. Several additional papers used this notion of future self-consistency [18, 30]. [18, 22]
relied on convergence opportunities, or rounds where only one node mines a block, to analyze chain growth.
In this work we show that convergence opportunities are not required for chain growth, and relying on them
underestimates chain growth with high p; in the adversary-free setting we show chain growth even with p = 1

2

(no convergence opportunities; all nodes mine a block every round). Other work considered the tradeoï¬€s be-
tween chain growth and chain quality [15, 17, 22, 24, 29]; however, to the best of our knowledge, none of these
works considered diï¬€erent symmetry breaking strategies to enable faster chain growth while maintaining
chain quality. In our paper, we thoroughly explore this domain. Another line of work [11, 27] considers how
the uniformly-at-random symmetry breaking strategy aï¬€ects incentive-compatible selï¬sh mining attacks; our
analysis applies to general attacks.

Random walks have been used to analyze the probability of consistency violations in proofs-of-stake
protocols [3]; ours is the ï¬rst work that uses coalescing random walks to analyze the common-preï¬x and
chain quality of Bitcoin and other proof-of-work protocols.

2 Model and Deï¬nitions

In this section, we present the speciï¬c model we use and brieï¬‚y describe the Bitcoin cryptosystem. We follow
the formalization presented in [15, 18, 22].

Network and Computation Model. Following previous work [12, 14, 15, 22, 26, 30], we consider a syn-
chronous network where nodes send messages in synchronous rounds, i.e., âˆ† = 1; equivalently, there is a
global clock and the time is slotted into equal duration rounds. Each node has identical computing power.
Notably, the synchronous rounds assumption is signiï¬cantly more relaxed than assuming âˆ† = 0.2 Our model
operates in the permissionless setting. This means that any miner can join (or leave) the protocol execution
without getting permission from a centralized or distributed authority. For ease of exposition, we assume
the number of participants remains n. Our results can be easily generalized to handle perturbation in the
population size by a stochastic dominance argument as long as the population size does not deviate too far
from n, and the proportion of Byzantine participants does not increase due to the perturbation.

Adversary Model. Throughout this paper, we assume that all Byzantine nodes are controlled by a
probabilistic polynomial time (PPT) adversary A that can coordinate the behavior of all such nodes. A
operates in PPT which means they have access to random coins but can only use polynomial time to
perform computations. At any time during the run of the protocol, A can corrupt up to b nodes at any point
in time where b is a parameter that is an input to the protocol. The corrupted nodes remain corrupted for
the remainder of the protocol. Finally, A cannot modify or delete the messages sent by honest nodes, but
can read all messages sent over the network and arbitrarily order the messages received by any honest nodes.

2.1 Bitcoin Cryptosystem

A blockchain protocol is a stateful algorithm wherein each node maintains a local version of the blockchain
C. Each honest node runs its own homogeneous version of the blockchain protocol. Nodes receive messages
from the environment Z(1Î»), where Î» is the security parameter chosen based on the population size n. The
environment is responsible for all the external factors related to a protocolâ€™s execution. For example, it
provides the value of b to the nodes. Detailed description of the environment can be found in [22].

The protocol begins by having the environment Z initialize n nodes. The protocol proceeds in synchronous
rounds; at each round r, each node receives a message from Z. In each round, an honest node attempts to
mine a block containing its message to add to its local chain. We provide formal deï¬nitions of the Bitcoin
cryptosystem below.

Blocks and Blockchains
A blockchain C (cid:44) B0B1B2 Â· Â· Â· B(cid:96) for some (cid:96) âˆˆ N is a chain of blocks. Here B0 is a predetermined genesis block
that all chains must build from. A block B(cid:96), for (cid:96) â‰¥ 1, is a triple B(cid:96) = (cid:104)s, x, nce(cid:105), where s, x, nce âˆˆ {0, 1}âˆ—
are three binary strings of arbitrary length. Speciï¬cally, s is used to indicate this blockâ€™s predecessor, x
is the text of the block containing the message (e.g. transactions) and other metadata, and nce is a nonce
chosen by a node.

Proofs-of-Work
The Bitcoin cryptosystem crucially uses nonces as proofs-of-work for determining whether a block can be

2In fact, the analysis based on Poisson race [2,21] essentially assumes all mined blocks can be ordered in a globally consistent

way, i.e., âˆ† = 0, which does not hold in our synchronous network model.

3

legally added to a chain.3 Proof-of-work (PoW) is rigorously deï¬ned in previous work [12, 14, 15, 22, 26, 30]
based on the use of the random oracle model.

Deï¬nition 1 (Random Oracle Model). A random oracle H : {0, 1}âˆ— â†’ {0, 1}Î» on input x âˆˆ {0, 1}âˆ— outputs
a value selected uniformly at random from {0, 1}Î» if x has never been queried before. Otherwise, it returns
the previous value returned when x was queried last.

Deï¬nition 2 (Bitcoin PoW). All nodes access a common random oracle H : {0, 1}âˆ— â†’ {0, 1}Î». We say a
node successfully performs a PoW with proof x âˆˆ {0, 1}âˆ— if H(x) â‰¤ D.

Deï¬nition 3 (Valid Chain). A blockchain C = B0B1 Â· Â· Â· B(cid:96) = B0(cid:104)s1, x1, nce1(cid:105) Â· Â· Â· (cid:104)s(cid:96), x(cid:96), nce(cid:96)(cid:105) is valid with
respect to a given puzzle diï¬ƒculty level D âˆˆ {1, Â· Â· Â· , 2Î»} if the following hold: (1) H(B0) = s1 and H (B(cid:96)(cid:48)) =
s(cid:96)(cid:48)+1 for (cid:96)(cid:48) = 1, Â· Â· Â· , (cid:96) âˆ’ 1; and (2) H (B(cid:96)(cid:48)) â‰¤ D for (cid:96)(cid:48) = 0, Â· Â· Â· , (cid:96).

Longest Chain Rule
The length of a valid chain C is the number of blocks it contains. We refer to the local version of the
blockchain kept by node i as the local chain at node i, denoted by Ci. In each round r, node i tries to mine
a block via solving a PoW puzzle with the speciï¬ed diï¬ƒculty D. If a block is successfully mined, then node
i extends its local chain with this block and broadcasts its updated local chain to all other nodes in the
network, which will be delivered at each node at the beginning of the next round. At the beginning of the
next round, before working on PoW, node i updates its local chain to be the longest chain it has seen. If
there are many longest chains, node i chooses one of them uniformly at random.

For ease of exposition, henceforth, Ci is referred to the local chain at the end of a round; Ci(t) is the
local chain of node i at the end of round t. Equivalent to using the diï¬ƒculty parameter D, one can instead
consider p (cid:44) D/2Î». The notion of p used in lieu of D has been considered in [12, 14, 15, 18, 22, 26] to simplify
notation. Henceforth, we will quantify the algorithm performance in terms of p rather than D and Î».

We use the phrase with overwhelming probability throughout this paper. With overwhelming probability
poly(Î»)c for any constant c â‰¥ 1. We use the phrase with all but
is deï¬ned as with probability at least 1 âˆ’
negligible probability in Î» to mean that the probability is upper bounded by some negligible function Î½(Î»)
on Î» (deï¬ned in Deï¬nition 4).

1

Deï¬nition 4 (Negligible Probability). A function Î½ is negligible if for every polynomial p(Â·), there exists an
N such that for all integers n > N , it holds that Î½(n) < 1
p(n) . We denote such a function by negl. An event
that occurs with negligible probability occurs with probability negl(n).

2.1.1 Properties of the Protocol

In this paper, we will analyze the Nakamoto consensus in terms of two characteristics (generalized from
deï¬nitions in [12, 18, 30]). The common preï¬x is deï¬ned as a sub-chain that is a common preï¬x of the local
chains of all honest nodes at the end of a round. The two properties maximal common preï¬x and maximal
inconsistency are deï¬ned intuitively as: the maximal preï¬x that is the same across all honest chains and the
maximal number of blocks in any honest chain that is not shared by all other honest chains, respectively.

(cid:111)

Property 5 (Maximal common-preï¬x and maximal inconsistency). Given a collection of chains C =
(cid:110) ËœC1, Â· Â· Â· , ËœCm
that are kept by honest nodes, the maximal common-preï¬x of chain set C, denoted by PC, is
deï¬ned as the longest common-preï¬x of chains ËœC1, Â· Â· Â· , ËœCm. The maximal inconsistency of C, denoted by IC,
is deï¬ned as

max
i:1â‰¤iâ‰¤m

(cid:12)
(cid:12)
(cid:12)

ËœCi âˆ’ PC

(cid:12)
(cid:12)
(cid:12) ,

(1)

where ËœCi âˆ’ PC is the sub-chain of ËœCi after removing the preï¬x PC and |Â·| denotes the length of the chain,
i.e., the number of blocks in the chain.

3Note that in practice, the nonce is eï¬€ectively concatenated with a minerâ€™s public key (included in the coinbase transaction)
to ensure unique queries. The public key does not need to be veriï¬ed. Importantly, this means that the miner can just generate
a (pk, sk) pair on their local computer without the need to verify that identity with a third-party authority.

4

Figure 1: Example growth of a set of chains starting with the genesis block at round r = 0. Here, in this
example p = 1, n = 4, and b = 0.

3 Fundamental Limitations of Existing Approaches

To the best of our knowledge, existing work assumes extremely small p. In fact, the seemingly mild honest
majority assumption in [13, 23] also implicitly assumes small p.

Proposition 6. If the honest majority assumption in [13] holds, then p â‰¤ nâˆ’2b

2(nâˆ’b)2 .

A formal statement of the honest majority assumption and the proof of Proposition 6 can be found in
Appendix B. Note that the upper bound in this proposition is only a necessary condition. Having p satisfy
this condition does not guarantee protocol correctness.

Remark 7. Proposition 6 implies that in the vanilla Nakamoto consensus protocol, unless b
bounded above from 1
See Appendix B for detailed arguments.

2 , p needs to be extremely low â€“ even much lower than the commonly believed Î˜( 1

n is non-trivially
n ).

To the best of our knowledge, most of the existing analyses focus on bounding the number of â€œconvergence
opportunitiesâ€, which for âˆ† = 1 is deï¬ned as the number of rounds in which exactly one honest node mines
a block, and for general âˆ†, it is deï¬ned as the global block mining pattern that consists of (i) a period
of âˆ† rounds where no honest node mines a block, (ii) followed by a round where a single honest player
mines a block, (iii) and, ï¬nally, another âˆ† rounds of silence from the honest nodes [18, 22]. Obviously,
guaranteeing suï¬ƒciently many convergence opportunities necessarily requires p to be small; in the extreme
case when p = 1 there will be no convergence opportunities at all. An important insight from our results is
that convergence opportunities are not necessary for common-preï¬x growth. This is illustrated Fig. 1 which
depicts the chain growth when there are 4 honest nodes and p = 1. Each node mines a block every round and
each is associated with a color. In particular, blocks 1, 5, 9, 13, 17, 21, 25, 29 are mined by the pink node, blocks
4, 8, 12, 16, 20, 24, 28, 32 are mined by the blue node, etc. In each round, each node chooses one of the existing
longest chains uniformly at random to extend. As shown in Fig. 1, there are no convergence opportunities
in any of these 8 rounds and the four nodes never choose the same chain to extend. However, instead of the
trivial common preï¬x (the genesis block) the longest chains at the end of round 8 (the four chains ending
with blocks 32, 29, 30, and 31, respectively) share the common preï¬x genesis â†’ 4 â†’ 6 â†’ 10 â†’ 15. In
general, as we show in Section 4, even for the extreme case when p = 1, the common preï¬x of the longest
chains still grows as time goes by.

5

12345786101412911171613182019ğ‘Ÿ=0ğ‘Ÿ=1ğ‘Ÿ=2ğ‘Ÿ=3ğ‘Ÿ=4ğ‘Ÿ=515232421222825262732293031ğ‘Ÿ=6ğ‘Ÿ=7ğ‘Ÿ=84 Uniformly-at-Random Symmetry-Breaking Strategy

Bitcoin uses the ï¬rst-seen symmetry-breaking strategy; nodes will only switch to a new chain with more
proof-of-work than their current longest chain. In this section, we investigate the power of the uniformly-at-
random symmetry-breaking strategy, in which each honest node chooses one of its received longest chains
uniformly at random to extend upon â€“ independently of other nodes and independently across rounds. We
choose to start with the uniformly-at-random strategy because (1) it is easy to implement, especially in a
distributed fashion, and (2) despite its simplicity, it is very powerful in fostering chain growth.

For ease of exposition, we ï¬rst present our results in the adversary-free setting (Sections 4.1 and 4.2) and

then in the adversary-prone setting (Section 4.3).

4.1 Warmup: p = 1 and Adversary-Free

Even the adversary-free setting (i.e., b = 0) is surprisingly non-trivial to analyze. Hence we build insights
by ï¬rst considering the simpler setting where p = 1 as a warmup.

Theorem 8. Suppose that p = 1 and b = 0. Then for any given round index t â‰¥ 1, in expectation, the local
chains at the honest nodes share a common preï¬x of length t + 1 âˆ’ O(n).

Remark 9. In Theorem 8, the expectation is taken w. r. t. the randomness in the symmetry breaking strategy.
Theorem 8 says that large p indeed boosts the growth of the common preï¬x among the local chains kept by
the honest nodes, and that, though temporal forking exists among local chains kept by the honest nodes,
such forking can be quickly resolved by repetitive symmetry-breaking across rounds.

The following deï¬nition and theorem are useful to see the intuitions of Theorem 8.

Deï¬nition 10 (Coalescing Random Walks [1]4). In a coalescing random walk, a set of particles make
independent random walks on a undirected graph G = (V, E) with self-loops. Whenever one or more
particles meet at a vertex, they unite to form a single particle, which then continues the random walk
through the graph. We deï¬ne the coalescence time, denoted by CG, to be the number of steps required
before all particles merge into one particle.

Theorem 11 ( [1] [7]). If G = (V, E) is complete, then E [CG] = O(n).

In the proof of Theorem 8, we build up the connection between the longest chains and the backwards
coalescing random walks on complete graphs, and show that the maximal inconsistency among n longest
chains turns out to be the same as the number of steps it takes n random walks on the n-complete graph to
coalesce into one. Finally, we use the existing results on coalescing random walks to conclude.

Main proof ideas of Theorem 8. We cast our proof insights via an example presented in Fig. 1.
In
this ï¬gure, there are four miners. For ease of exposition, we use the colors pink, yellow, green, and blue to
represent each of the miners, respectively. As shown in Fig. 1, there are 4 longest chains at the end of round
8 and these chains share a maximal common preï¬x ending at block 15. The maximal inconsistency of these
4 longest chains is 4; that is, these 4 longest chains are NOT inconsistent with each other until the most
recent 4 blocks of each chain. For expository convenience below, instead of using numbers to represent each
of the blocks, we use the tuple (color, r) to represent a block that is mined by a certain miner at round r.
The maximal inconsistency of the longest chains can be characterized by the coalescing time on complete
graphs. To see this, letâ€™s consider the four longest chains held by honest miners during round 8 backwards.
Backwards-Chain #1: (blue, 8) â†’ (pink, 7) â†’ (blue, 6) â†’ (yellow, 5) â†’ (green, 4) â†’ (yellow, 3) â†’
(yellow, 2) â†’ (blue, 1) â†’ (gray, 0), which can be read as â€œblock (blue, 8) is attached to block (pink, 7)
which is further attached to block (blue, 6) ... attached to the genesis block (gray, 0). â€
Backwards-Chain #2: (pink, 8) â†’ (yellow, 7) â†’ (pink, 6) â†’ (green, 5) â†’ (green, 4) â†’ (yellow, 3) â†’
(yellow, 2) â†’ (blue, 1) â†’ (gray, 0) .
Backwards-Chain #3: (yellow, 8) â†’ (yellow, 7) â†’ (pink, 6) â†’ (green, 5) â†’ (green, 4) â†’ (yellow, 3) â†’
(yellow, 2) â†’ (blue, 1) â†’ (gray, 0).

4The original deï¬nition given in [1] assumes no self-loops, but its analysis applies to the graphs with self-loops.

6

Backwards-Chain #4: (green, 8) â†’ (green, 7) â†’ (yellow, 6) â†’ (green, 5) â†’ (green, 4) â†’ (yellow, 3) â†’
(yellow, 2) â†’ (blue, 1) â†’ (gray, 0) .
Since p = 1 and there is no adversary, the number of longest chains received by each honest node at each
round is n. Under our symmetry-breaking rule, in each round t, each miner chooses which of the longest
chains received at the beginning of round t to extend on uniformly-at-random. Thus, neither the previous
history up to round t nor the future block attachment choices after round t aï¬€ects the choice of the chain
extension in round t. Reasoning heuristically5, we can view each of the backwards-chain as a random walk
on a 4-complete graph with vertex set {pink, yellow, green, blue}. In particular, Backwards-Chain #1 can
be viewed as a sample path of a random walk starting at the blue vertex, then moves to the pink vertex,
then back to the blue vertex etc., and ï¬nally to the blue vertex. Similarly, Backwards-Chains #2, #3, and
#4 can be viewed as the sample paths of three random walks starting at the pink vertex, yellow vertex, and
green vertex, respectively. These four random walks (starting at four diï¬€erent vertices) are not completely
independent. For any pair of random walks, before they meet, they move on the graph independently of
each other; whenever they meet, they move together henceforth. Concretely, backwards-chains 2 and 3 meet
at (yellow, 7) and these chains are identical starting from block (yellow, 7); this holds similarly for other
pairs of backwards chains. Finally, these four backward chains all meet at the block (green, 4) and move
together henceforth. Notably, this block is exactly the last block in the maximal common preï¬x of the four
longest chains of round 8. Thus, the maximal inconsistency among the longest chains of round 8 is identical
to the number of backwards steps it takes for all these four random walks to coalesce into one. This relation
is not a coincidence. It can be shown (detailed in the proof of Theorem 8) that this identity holds for general
n. Formal proof of Theorem 8 can be found in Appendix C.

4.2 General p: Adversary-Free

The analysis for general p is signiï¬cantly more challenging than that of p = 1 in two ways: (1) we need to
repeatedly apply coupling arguments; and (2) we need to characterize the coalescence time of a new notion
of coalescing random walks (the lazy coalescing random walks), the latter of which could be of independent
interest for a broader audience.

Theorem 12. Suppose that np = â„¦(1). If p < 4 ln 2
n , in expectation, at the end of round t, the local chains
at the nodes share a common preï¬x of length (1 + (1 âˆ’ (1 âˆ’ p)n) t) âˆ’ O(
n , in expectation,
at the end of round t, the local chains at the nodes share a common preï¬x of length (1 + (1 âˆ’ (1 âˆ’ p)n) t) âˆ’

npeâˆ’np ). If p â‰¥ 4 ln 2

1

(cid:18)

O

2np

(1âˆ’2 exp(âˆ’ 1

3 np))

(cid:19)

.

Remark 13. The expression of the common preï¬x length in Theorem 12 contains two terms with the ï¬rst
term (i.e., (1 + (1 âˆ’ (1 âˆ’ p)n) t)) being the only term that involves t. Intuitively, from this term, we can read
out the common preï¬x length growth rate w.r.t. t. The second term (which is expression in terms of Big-O
notation) can be interpreted as a quantiï¬cation of the maximal inconsistency of the honest chains.

Now we further interpret these two terms via simplifying the expression using the inequalities (1 âˆ’ np) â‰¤

(1 âˆ’ p)n â‰¤ exp (âˆ’np).
(1) When np = o(1), it is true that (1 âˆ’ p)n â‰ˆ (1 âˆ’ np) for large n, which implies that (1 âˆ’ (1 âˆ’ p)n) t â‰ˆ
npeâˆ’np ) is
npt = o(t), i.e., the common preï¬x grows at a speed o(t). The maximal inconsistency bound O(
not tight. Nevertheless, via a straightforward calculation, we know that the maximal inconsistency is O(1).
(3) When np = Ï‰(1), we have 0 â‰¤ (1 âˆ’ p)n â‰¤ exp (âˆ’np) â†’ 0 as np â†’ âˆ. Thus the common-preï¬x grows at
the speed (1 âˆ’ (1 âˆ’ p)n) t â‰ˆ t = â„¦(t) with maximal inconsistency O(np) for suï¬ƒciently large np.
(4) When np = c âˆˆ (0, 1), it is true that (1 âˆ’ p)n = (1 âˆ’ c/n)n â†’ exp (âˆ’c) as n â†’ âˆ. The common-preï¬x
grows at the speed of Î˜(t) for suï¬ƒciently large n and the maximal inconsistency is O(1).

1

Overall, when np gets larger, the common-preï¬x growth increases and the maximal inconsistency grows

at a much slower rate.

The following deï¬nition and lemma are used in proving Theorem 12. This lemma could be of independent

interest to a broader audience and its proof can be found in the appendix.

5Formally shown in the proof of Theorem 8 via introducing an auxiliary process.

7

Deï¬nition 14 (Lazy coalescing random walk). For any ï¬xed u âˆˆ (0, 1), we say n particles are u-lazy
coalescing random walks if for each step: with probability (1 âˆ’ u), each particle stays at its current location;
with probability u, each particle moves to an adjacent vertex picked uniformly at random. If two or more
particles meet at a location, they unite into a single particle and continue the procedure. The coalescence
time is the same as that in Deï¬nition 10.

Lemma 15. Suppose that G is a complete graph of size |V | = ng (where ng â‰¥ 2) with self-loops. For any
u âˆˆ (0, 1), the coalescence time of the u-lazy coalescing random walks is CG(ng) = O(ng/u).

(cid:17)

(cid:16)

1
np exp(âˆ’np)

Proof Sketch of Theorem 12. When p < 4 ln 2
n , we can use Poisson approximation to approximate the
distribution of number of blocks in each round. A straightforward calculation shows that the probability
of having exactly one block in a round is np exp (âˆ’np). Thus, in expectation, the maximal inconsistency
. Henceforth, we restrict our attention to the setting where p â‰¥ 4 ln 2
and quantify the
is O
expected maximal inconsistency among the longest chains of round t. It is attempting to apply arguments
similar to that in the proof of Theorem 8 and derive a bound on the maximal inconsistency via stochastic
dominance. However, the obtained bound on the maximal inconsistency is O(n) which could be extremely
loose for a wide range of p. Nevertheless, based on the insights obtained in this coarse analysis, we can
come up with a much ï¬ner-grained analysis and obtain the bound in Theorem 12. Similar to the proof of
the special case when p = 1, in our ï¬ne-grained analysis for general p âˆˆ (0, 1), we couple the growth of
the common preï¬x in Nakamoto protocols with the coalescing time random walks on complete graphs. The
major diï¬€erences from the proof of p = 1 are: (1) instead of the standard coalescing random walks, we need
to work with a lazy version of it, formally deï¬ned in Deï¬nition 14; (2) there is no ï¬xed correspondence
between a color and a node â€“ in our proof of general p, the correspondence is round-speciï¬c rather than ï¬xed
throughout the entire dynamics; (3) there is no bijection between a sample path of the Nakamoto dynamics
and that of the backwards coalescing random walks, thus, we need to rely on stochastic dominance to build
up the connection of these two dynamics.

n

4.3 General p: Adversary-Prone

Throughout this section, we assume p < 1. In this subsection, we consider adversary-prone systems, i.e.,
b > 0. Simple concentration arguments show that when bp â‰¥ (1 + 2c) for any given c âˆˆ (0, 1), using vanilla
Nakamoto consensus the chain quality could be near zero. To make larger p feasible, we introduce a new
assumptionâ€”Assumption 16â€”which we then remove in Section 5 by providing a construction that ensures
Assumption 16 with all but negligible probability. Speciï¬cally, we use a cryptographic tool called a VDF to
ensure that over a suï¬ƒciently long time window, the corrupt nodes can only collectively extend a chain by
more than one block in a round with negligible probability.

Assumption 16. In each round, a chain can be extended by at most 1 block.

To strengthen the protocol robustness, we make the additional minor modiï¬cation requiring each honest

node to selectively relay chains at the beginning of a round.
Selective relay rule: At each honest node i, for each iteration t â‰¥ 1: Node i looks at the chains it
received in the previous round t âˆ’ 1, and if any of them are longer than its own local longest chain, it not
only chooses one of the longest chains to replace its local one, it also broadcasts it to other nodes before it
begins mining in round t.

As implied by our proof, this modiï¬cation can reduce the maximal diï¬€erence between the lengths of the
longest chains kept by the honest nodes and by the corrupt nodes. Intuitively, if the adversary sends two
chains of diï¬€erent lengths to two diï¬€erent groups of honest nodes, with the selective relay rule, only the longer
chain would survive in this round. Notably, it is possible that none of them survive in this round. Even with
the assurance guaranteed by Assumption 16, compared with the adversary-free settings, the analysis for the
adversary-prone setting is challenging. This is because the corrupt nodes could deviate from the speciï¬ed
symmetry breaking rule. For example, a corrupt node can choose not to extend its longest chain, or can
choose from its set of longest chains in any way that provides advantage. In addition, a corrupt node can
hide blocks it has mined from the honest nodes for as long as it wants, or from some subset of the honest
nodes during a round.

8

For simplicity and for technical convenience, we assume that a corrupt node randomly chooses among
longest chains that end with an honest block. This assumption is only imposed in the rare event when
simultaneously both the adversary has no adversary advantage (see Deï¬nition 17) and only honest nodes
mine blocks in the most recent nonempty round.

In contrast to the adversary-free setting where the lengths of honest nodesâ€™ local chains diï¬€er by at most
1, in the presence of an adversary, such diï¬€erence could be large. To precisely bound this diï¬€erence, we
introduce a random process we call adversary advantage:

Deï¬nition 17 (Adversary advantage). Let {N (t)}âˆ

t=0 be the random process deï¬ned as

â€¢ N (0) = 0, and

â€¢ for t â‰¥ 1,

N (t) =

ï£±
ï£´ï£²

ï£´ï£³

N (t âˆ’ 1) + 1,
max{N (t âˆ’ 1) âˆ’ 1, 0},
N (t âˆ’ 1),

if only corrupt nodes found blocks in round t;
if only honest nodes found blocks in round t;
otherwise.

Note that the random process {N (t)}âˆ

t=0 is independent of the adversarial behaviors of the corrupt nodes.

To make the discussion concrete, we introduce the following deï¬nition.

Deï¬nition 18. The length of the longest chains kept by the honest nodes at round t is deï¬ned as the
length of the longest local chains kept by honest nodes at the end of round t.

Lemma 19. For any t â‰¥ 1, at the end of round t, the length of the longest chains kept by the adversary â€“
henceforth referred to as an adversarial longest chain of round t â€“ is at most N (t) longer than the length of
a chain kept by an honest node.

Proof of Lemma 19 can be found in Appendix E. From its proof, we can deduce an attacking strategy
of the adversary that meets the upper bound in Lemma 19. The following lazy random walk, referred to as
coalescing opportunities, is important in our analysis. It can also be used to quantify the chain quality.

Deï¬nition 20. Let t1, t2, Â· Â· Â· be the rounds in which at least one node mines a block with the understanding
that t0 = 0. Let J (m) be a random walk deï¬ned as

J (m) =

ï£±
ï£´ï£´ï£´ï£²
ï£´ï£´ï£´ï£³

0,
J (m âˆ’ 1) + 1,
J (m âˆ’ 1) âˆ’ 1,
J (m âˆ’ 1),

if m = 0;
if only honest nodes mine a block during round tk;
if only corrupt nodes mine a block during round tk;
otherwise.

Remark 21. A couple of interesting facts on the coalescing opportunities dynamics are: Among the most
recent m blocks in a longest chain, there are at least J (m) blocks mined by the honest nodes. In addition,
regardless of the behaviors of the adversary, for any two longest chains, there are at least J (m) block
positions each of which has non-zero probability of being in the common preï¬x of these two chains.

Let p+1 = P {J (m) = J (m âˆ’ 1) + 1} and pâˆ’1 = P {J (m) = J (m âˆ’ 1) âˆ’ 1}, i.e., p+1 (resp. pâˆ’1) is the

probability for J (m) to move up (resp. down) by 1. We have
(1 âˆ’ p)b (cid:16)

1 âˆ’ (1 âˆ’ p)nâˆ’b(cid:17)

p+1 =

1 âˆ’ (1 âˆ’ p)n

and pâˆ’1 =

(cid:0)1 âˆ’ (1 âˆ’ p)b(cid:1) (1 âˆ’ p)nâˆ’b
1 âˆ’ (1 âˆ’ p)n

.

(2)

It is easy to see that when b > 1
P {J (t) (cid:54)= J (t âˆ’ 1)} = p+1 + pâˆ’1.

2 n,

it holds that p+1 > pâˆ’1. For ease of exposition,

let pâˆ— =

Lemma 22. With probability at least

(cid:16)

1 âˆ’ exp

(cid:16)
âˆ’ (p+1âˆ’pâˆ’1)2M
16pâˆ—

(cid:17)

âˆ’ exp

(cid:16)

âˆ’ (pâˆ—)2M
2

(cid:17)(cid:17)

, it holds that J (M ) â‰¥

(p+1âˆ’pâˆ’1)M
4

.

9

Lemma 22 gives a high probability lower bound on the number of coalescing opportunities during M

nonempty rounds. Its proof can be found in Appendix E.

Theorem 23. For any given T â‰¥ 1 and M â‰¥
probability at least

4

Î²(p+1âˆ’pâˆ’1) where Î² = (nâˆ’b)p

2(3np)2 , at the end of round T , with

(cid:18)

1 âˆ’ exp

âˆ’

(cid:19)

(pâˆ—)2M
2

(cid:18)

âˆ’ exp

âˆ’

(p+1 âˆ’ pâˆ’1)2M
16pâˆ—

(cid:19)

âˆ’

2
Î²

(cid:18)

exp

âˆ’

1
2

(cid:19)

(n âˆ’ b)

over the randomness in the block mining, the expected maximal inconsistency among a given pair of honest
nodes is less than M , where the expectation is taken over the randomness in the symmetry breaking.

Remark 24. It is worth noting that Î² = (nâˆ’b)p
nodes and the total mining power of the nodes in the system.

2(3np)2 = 1

(nâˆ’b)
n

18

1
np , i.e., Î² is a function of the fraction of honest

Suppose that n â‰¥ 2 log 4

(cid:15)Î² for any given (cid:15) âˆˆ (0, 1). Let

(cid:40)

M âˆ— = max

4 log 1/(cid:15)
(pâˆ—)2

,

4
Î²(p+1 âˆ’ pâˆ’1)

,

16pâˆ—
(p+1 âˆ’ pâˆ’1)2 log

4
(cid:15)

(cid:41)

.

From Theorem 23, we know that with probability at least 1 âˆ’ (cid:15), the maximal inconsistency is less than M âˆ—.
Roughly speaking, when b gets smaller, M âˆ— mainly gets smaller.

Proof of Theorem 23. We use Nt to denote the number of blocks generated during round t and associate
each node with a distinct color in {c1, Â· Â· Â· , cn}. If node i mines a block during round t, we use (ci, t) to
denote this block. The genesis block is denoted as (c1, 0). Recall that the blocks mined during round t are
collectively referred to as the block layer t. As the randomness in the block generation (i.e., puzzle solving
of individual nodes) is independent of the adversarial behaviors of the corrupt nodes and is independent of
which chain an honest node chooses to extend, we consider the auxiliary process wherein the nodes mine
blocks for the ï¬rst T rounds, and then the corrupt nodes and honest nodes sequentially decide on block
attachments. Let {i1, Â· Â· Â· , iK} be the set of rounds such that Nik (cid:54)= 0 for each ik âˆˆ {i1, Â· Â· Â· , iK}. Let j1
and j2 be any two honest nodes whose chains at the end of round T are denoted by C1(T ) and C2(T ),
respectively. For each of these chains, we can read oï¬€ a sequence of colors

for Chain C1(T ) :
for Chain C2(T ) :

c1c(1, 2)c(1, 3) Â· Â· Â· c(1, (cid:96)1), and
c1c(2, 2)c(2, 3) Â· Â· Â· c(2, (cid:96)2),

where (cid:96)1 and (cid:96)2, respectively, are the lengths of chains C1(T ) and C2(T ), c1 is the color of the genesis block,
c(1, k) for k âˆˆ {2, Â· Â· Â· , (cid:96)1} is the color of the kâ€“th block in C1(T ) and c(2, k) for k âˆˆ {2, Â· Â· Â· , (cid:96)2} is the color
of the kâ€“th block in C2(T ). If (cid:96)1 (cid:54)= (cid:96)2, without loss of generality, we consider the case that (cid:96)1 < (cid:96)2; the
other case can be handled similarly. We augment the color sequence c1c(1, 2)c(1, 3) Â· Â· Â· c(1, (cid:96)1) to the length
(cid:96)2 sequence as

c1c(1, 2)c(1, 3) Â· Â· Â· c(1, (cid:96)1)c(1, (cid:96)1 + 1) Â· Â· Â· c(1, (cid:96)2),

by setting c(1, k) = c0 for k = (cid:96)1 + 1, Â· Â· Â· , (cid:96)2 where c0 /âˆˆ {c1, Â· Â· Â· , cn} is a special color that never shows
up in a real block. It is easy to see that C1(T ) and C2(T ) start to be inconsistent at their k-th block if
and only if c(1, k(cid:48)) (cid:54)= c(2, k(cid:48)) for each k(cid:48) âˆˆ {k, Â· Â· Â· , (cid:96)2}. Let {ih1 , Â· Â· Â· , ihR } âŠ† {i1, Â· Â· Â· , iK} such that for each
ihr âˆˆ {ih1, Â· Â· Â· , ihR } it holds that

â€¢ Only honest nodes successfully mined blocks;

â€¢ N (ihrâˆ’1) = 0.

For ease of exposition, we refer to each of ihr as a coalescing opportunity. Recall that each of the honest
nodes extends one of the longest chains it receives. By Lemma 19, we know that each of C1(T ) and C2(T )
contains a block generated during round ihr . Let (c(cid:48)
2, ihr ) be the blocks included in C1(T ) and
C2(T ), respectively. If (c(cid:48)
2, ihr ) is also in the k-th position in
C2(T ). For each ihr , we denote the set of chains (including the forwarded chains) received by j1 and j2 at

1, ihr ) is in the k-th position in C1(T ), then (c(cid:48)

1, ihr ) and (c(cid:48)

10

round ihr , denoted by Cr
Cr
1 and Cr

1 and Cr

2 could be diï¬€erent. The probability of j1 and j2 extending the same chain at round ihr is

2 . Since the adversary can hide chains to a selective group of honest nodes,

1 âˆ© Cr
|Cr
2 |
1 | |Cr
|Cr
2 |

â‰¥

NB(ihrâˆ’1)
NB(ihrâˆ’1) + AB(ihrâˆ’1) + AB( (cid:93)ihrâˆ’1)

(cid:16)

(cid:17)2

(3)

where the inequality follows from Lemma 33. By Lemma 22, we know that in the M non-empty block layers
that are most recent to round T ,

R â‰¥ J (M ) â‰¥

(p+1 âˆ’ pâˆ’1)M
4

holds with probability at least
that for each of the r ensured by Lemma 22 we have

1 âˆ’ exp

(cid:16)

(cid:16)

âˆ’ (pâˆ—)2M
2

(cid:17)

âˆ’ exp

(cid:16)

âˆ’ (p+1âˆ’pâˆ’1)2M
16pâˆ—

(cid:17)(cid:17)

. In addition, it can be shown

max{|Cr

1 | , |Cr

2 |} â‰¤ NB(ihrâˆ’1) + AB(ihrâˆ’1) + AB( (cid:93)ihrâˆ’1)1{AB(ihrâˆ’1) = 0}.

let Xk be the number of blocks mined by the honest nodes during round ik such that
For any ik,
Xk (cid:54)= 0. Using conditioning and Hoeï¬€dingâ€™s inequality, the following holds with probability at least
(cid:0)1 âˆ’ 2 exp (cid:0)âˆ’ 1

2 (n âˆ’ b)(cid:1)(cid:1),

Xk â‰¥

1
2

(n âˆ’ b)p and Xk + Yk + Ykâˆ’11{Yk = 0} â‰¤ 3np,

2(3np)2 (cid:44) Î². On average over the random symmetry breaking,
which implies that
it takes at most 1/Î² coalescing opportunities backwards for chains C1(T ) and C2(T ) to coalesce into one.
Thus, we need (p+1âˆ’pâˆ’1)M

Xk+Yk+Ykâˆ’11{Yk=0} â‰¥ (nâˆ’b)p

Xk

4

â‰¥ 1
Î² .

5 VDF-Based Scheme

In this section, we present a scheme to ensure Assumption 16. The key cryptographic tool we use in the
following scheme is the construction of the veriï¬able delay function, F(x), which we deï¬ne informally below.
Please refer to [4] for the formal deï¬nition (also deï¬ned formally in the full version of our paper).

Deï¬nition 25 (Veriï¬able Delay Function (informal)). Let Î» be our security parameter. There exists a
function F with diï¬ƒculty X = O(poly(Î»)) where the output y â† F(x) (where x âˆˆ {0, 1}Î») cannot be
computed in less than X sequential computation steps, even provided poly(Î») parallel processors, with
probability at least 1 âˆ’ negl(Î»). The VDF output can be veriï¬ed, quickly, in O(log(X)) time.

We set the diï¬ƒculty of the VDF to the duration of a round; in other words, the diï¬ƒculty is set such that
the VDF produces exactly one output at the end of each round. We amend default Nakamoto consensus by
adding the following procedure. We believe this could be added in a backwards-compatible way to existing
Nakamoto implementations, like Bitcoin. Backwards-compatibility is desirable in decentralized networks
because it means that a majority of the network can upgrade to the new protocol and non-upgraded nodes
can still verify blocks and execute transactions. Below we describe a scheme that, when added to Nakomoto
consensus, assures Assumption 16. The proof of the following theorem is in the full version of our paper.

Theorem 26. Assumption 16 is satisï¬ed by our VDF-based scheme.

VDF-Scheme Overview. The VDF-scheme works intuitively as follows. We number the rounds beginning
with round 0. All nodes have the genesis block B0 in their local chains in round 0 and starting mining blocks
in round 1. In round 0, the VDF output is computed using 0 as the input. During each round j > 0, each
node computes a VDF output, yj, (using F) for the current round j where the input to F is the output of the
VDF, yjâˆ’1, from the previous round concatenated with the round number, j. Both inputs are necessary; the

11

output of the VDF from the previous round ensures that we cannot compute the VDF output for this round
until we have obtained the output for the previous round, and the round number is necessary to ensure that
the output is not used for a future round. Once the VDF output is computed, each honest node attempts to
mine a block using the VDF output as part of the input to the mining attempt. This also ensures that the
block generation rate of honest nodes is upper bounded by np. Then, each node which successfully mines a
block sends the new chain to all other nodes.

All honest nodes verify that each chain satisï¬es two conditions:

1. Let o1, . . . , o(cid:96) be the VDF outputs contained in blocks B1, . . . , B(cid:96), respectively, of a chain C (the genesis
block does not contain a VDF output). Let r1, . . . , r(cid:96) be the rounds where o1, . . . , o(cid:96) were computed,
respectively. Then, r1 < Â· Â· Â· < r(cid:96)âˆ’1 < r(cid:96).

2. oi is the VDF output computed from round ri â‰¥ i âˆ’ 1.

The honest nodes also check all proofs included in the chains, conï¬rming that the VDF outputs are correctly
computed and the blocks are correctly mined using the VDF outputs. An honest node discards any chain
which does not pass veriï¬cation.

Pseudocode. The precise pseudocode of our VDF-based scheme is given below. Using F, each honest node
i performs the following:

1. Initially, all honest nodes use input 0 at the start of the protocol to obtain output y0 = F(0) for round

0.

2. Let dj = F(yjâˆ’1) be the output of the VDF for round j and yj = djâˆ’1|j.6 i stores yj.

3. When i mines a block Bj, i includes the output yjâˆ’1 = djâˆ’1|j from the previous round in Bj, ie. Bj

is mined with yjâˆ’1 as part of the input.

4. Each node which successfully mines a block adds the mined block to its local chain. Then, it broadcasts

its local chain to all other nodes.

5. For each longest chain received, each node veriï¬es the following:

(a) Let o1, . . . , o(cid:96) be the VDF outputs stored in each block in order starting with the ï¬rst block and
ending with the (cid:96)-th block. Let r1, . . . , r(cid:96) be the rounds associated with the VDF output. Then,
r(cid:96) > r(cid:96)âˆ’1 > Â· Â· Â· > r1.

(b) The k-th block in the chain (starting from the genesis block) is mined using yk(cid:48) from round

k(cid:48) â‰¥ k âˆ’ 1.

(c) The proofs of the VDF output and the mining output are correct, i.e. the block is correctly mined

using the corresponding VDF output.

6. If i receives a chain where more than one block in the chain is mined with the same yj (for any j

smaller than the current round), the node discards the chain.

7. At the end of round j, i sets yj+1 â† F(yj)|j + 1 and begins computing the next value F(yj+1) using

yj+1 as input.

Due to space constraints, we do not include the proof of Theorem 26; please ï¬nd the full proofs in the full
version of our paper. However, the intuition for our proof is straightforward. Items 5a and 5b ensure that
no chain accepted by an honest node contains more than one block per VDF output. Setting the diï¬ƒculty
of the VDF to the duration of the round ensures that at most one VDF output is produced during a round.
Together, these two observations prove Theorem 26, namely, that any chain held by an honest node can be
extended by at most one block each round.

6Here, a|b is the commonly used notation indicating concatenation between a and b.

12

6 Discussion

Validation and Communication Costs. A higher p means a faster block rate and thus more blocks. The
validation and bandwidth complexity of Nakamoto protocols are proportional to block size and the number
of blocks that are mined, since each miner validates and then communicates every mined block to all other
miners (in practice, nodes do not necessarily gossip shorter chains, and taking advantage of nodesâ€™ memory
overlap can help reduce block transfer size [8]). One needs to determine the optimal value of p that trades
oï¬€ validation and bandwidth complexity and chain growth. This work expands the space of p to consider.

Other Symmetry-Breaking Strategies. Here we consider three other symmetry-breaking strategies with
high p. First-seen is where all honest nodes take the ï¬rst chain out of the longest-length chains they see, and
lexicographically-ï¬rst is where honest nodes take the lexicographically-ï¬rst chain of the set of longest chains
according to some predetermined ordering, for example alphabetically. Intuitively, the adversary can control
the network and thus cause diï¬€erent honest nodes to see diï¬€erent chains of the same length ï¬rst for ï¬rst-seen,
impacting common-preï¬x, or grind on blocks to always produce the lowest lexicographically-ordered chain
for lexicographically-ï¬rst, impacting chain-quality. A third strategy is to use a global-random-coin: Suppose
that all nodes have access to a permutation oracle P that returns a permutation sampled uniformly at random
of a number of elements passed into it where any subset of elements obey the same partial ordering. With P
symmetry-breaking is trivial since all honest nodes will agree on the result of the coin ï¬‚ip. Furthermore, if
the coin is fair, then the number of honest blocks added to the chain is proportional to the fraction of honest
nodes. However, in reality, it is diï¬ƒcult and oftentimes infeasible to ensure such a strong guarantee.
Conclusion.
In this work we show that unlike previously thought, convergence opportunities are not
necessary to make chain progress. We use coalescing random walks to analyze the correctness of Nakamoto
consensus under a regime of puzzle diï¬ƒculty previously thought to be untenable, expanding the space of p
for protocol designers.

References

[1] D. Aldous and J. Fill. Reversible markov chains and random walks on graphs, 2002. 6, 19

[2] V. Bagaria, S. Kannan, D. Tse, G. Fanti, and P. Viswanath. Prism: Deconstructing the blockchain
to approach physical limits. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and
Communications Security, pages 585â€“602, 2019. 3

[3] E. Blum, A. Kiayias, C. Moore, S. Quader, and A. Russell. The Combinatorics of the Longest-Chain

Rule: Linear Consistency for Proof-of-Stake Blockchains, pages 1135â€“1154. 3

[4] D. Boneh, J. Bonneau, B. BÂ¨unz, and B. Fisch. Veriï¬able delay functions. In Advances in Cryptology -
CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August
19-23, 2018, Proceedings, Part I, pages 757â€“788, 2018. 11, 15

[5] D. Boneh, J. Bonneau, B. BÂ¨unz, and B. Fisch. Veriï¬able delay functions. Cryptology ePrint Archive,

Report 2018/601, 2018. https://eprint.iacr.org/2018/601. 2

[6] C. Cooper, R. Elsasser, H. Ono, and T. Radzik. Coalescing random walks and voting on connected

graphs. SIAM Journal on Discrete Mathematics, 27(4):1748â€“1758, 2013. 19, 20

[7] C. Cooper, A. Frieze, and T. Radzik. Multiple random walks in random regular graphs. SIAM Journal

on Discrete Mathematics, 23(4):1738â€“1761, 2010. 6

[8] M. Corallo. Compact block relay, 2016.

https://github.com/bitcoin/bips/blob/master/bip-0152.

mediawiki. 13

[9] C. Dwork and M. Naor. Pricing via processing or combatting junk mail.

In Annual international

cryptology conference, pages 139â€“147. Springer, 1992. 1, 2

[10] EOS.

v2.0 consensus protocol, 2021.

https://developers.eos.io/welcome/v2.0/protocol/consensus

protocol. 2

13

[11] I. Eyal and E. G. Sirer. Majority is not enough: Bitcoin mining is vulnerable. In International conference

on ï¬nancial cryptography and data security, pages 436â€“454. Springer, 2014. 3

[12] J. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis and applications.
In E. Oswald and M. Fischlin, editors, Advances in Cryptology - EUROCRYPT 2015, pages 281â€“310,
Berlin, Heidelberg, 2015. Springer Berlin Heidelberg. 1, 2, 3, 4

[13] J. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis and applications. In
Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages
281â€“310. Springer, 2015. 5, 17

[14] J. Garay, A. Kiayias, and N. Leonardos. Full analysis of nakamoto consensus in bounded-delay networks.

Cryptology ePrint Archive, Report 2020/277, 2020. https://eprint.iacr.org/2020/277. 3, 4

[15] J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol with chains of variable
diï¬ƒculty. In J. Katz and H. Shacham, editors, Advances in Cryptology - CRYPTO 2017 - 37th Annual
International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part
I, volume 10401 of Lecture Notes in Computer Science, pages 291â€“323. Springer, 2017. 1, 2, 3, 4

[16] B. Hajek. Random processes for engineers. Cambridge university press, 2015. 25

[17] A. Kiayias and G. Panagiotakos. Speed-security tradeoï¬€s in blockchain protocols. IACR Cryptol. ePrint

Arch., 2015:1019, 2015. 3

[18] L. Kiï¬€er, R. Rajaraman, and a. shelat. A better method to analyze blockchain consistency. In Proceed-
ings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, CCS â€™18, page
729â€“744, New York, NY, USA, 2018. Association for Computing Machinery. 2, 3, 4, 5

[19] S. Micali.

Algorand 2021 performance,

2020.

https://www.algorand.com/resources/blog/

algorand-2021-performance. 2

[20] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2009. 1

[21] S. Nakamoto et al. Bitcoin: A peer-to-peer electronic cash system.(2008), 2008. 3

[22] R. Pass, L. Seeman, and A. Shelat. Analysis of the blockchain protocol in asynchronous networks. In
J.-S. Coron and J. B. Nielsen, editors, Advances in Cryptology â€“ EUROCRYPT 2017, pages 643â€“673,
Cham, 2017. Springer International Publishing. 1, 2, 3, 4, 5

[23] R. Pass, L. Seeman, and A. Shelat. Analysis of the blockchain protocol in asynchronous networks. In
Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages
643â€“673. Springer, 2017. 5, 17

[24] R. Pass and E. Shi. Fruitchains: A fair blockchain. In Proceedings of the ACM Symposium on Princi-
ples of Distributed Computing, PODC â€™17, page 315â€“324, New York, NY, USA, 2017. Association for
Computing Machinery. 3

[25] K. Pietrzak. Simple Veriï¬able Delay Functions. In A. Blum, editor, 10th Innovations in Theoretical
Computer Science Conference (ITCS 2019), volume 124 of Leibniz International Proceedings in Infor-
matics (LIPIcs), pages 60:1â€“60:15, Dagstuhl, Germany, 2018. Schloss Dagstuhlâ€“Leibniz-Zentrum fuer
Informatik. 16

[26] L. Ren. Analysis of nakamoto consensus. IACR Cryptol. ePrint Arch., 2019:943, 2019. 3, 4

[27] A. Sapirshtein, Y. Sompolinsky, and A. Zohar. Optimal selï¬sh mining strategies in bitcoin.

In In-
ternational Conference on Financial Cryptography and Data Security, pages 515â€“532. Springer, 2016.
3

[28] B. Wesolowski. Eï¬ƒcient Veriï¬able Delay Functions (extended version). Journal of Cryptology, Sept.

2020. 16

14

[29] R. Zhang and B. Preneel. Lay down the common metrics: Evaluating proof-of-work consensus protocolsâ€™

security. In 2019 IEEE Symposium on Security and Privacy (SP), pages 175â€“192, 2019. 3

[30] J. Zhao, J. Tang, Z. Li, H. Wang, K. Lam, and K. Xue. An analysis of blockchain consistency in
asynchronous networks: Deriving a neat bound. In 40th IEEE International Conference on Distributed
Computing Systems, ICDCS 2020, Singapore, November 29 - December 1, 2020, pages 179â€“189. IEEE,
2020. 2, 3, 4

Appendices

A Additional Deï¬nitions

A.1 VDFs

The formal deï¬nition of VDFs is presented below.

Deï¬nition 27 (Veriï¬able Delay Functions [4]). A VDF V = (Setup, Eval, Verify) is a triple of algorithms
that perform the following:

1. Setup(Î», X) â†’ pp = (ek, vk): The Setup algorithm takes as input a security parameter Î» and a
desired diï¬ƒculty level X and produces public parameters consisting of an evaluation key ek and a
veriï¬cation key vk. Setup is polynomial time with respect to Î» and X is subexponentially-sized in
terms of Î». The public parameters specify an input space X and an output space Y. X is eï¬ƒciently
sampleable. If secret randomness is used in Setup, a trusted setup might be necessary.

2. Eval(ek, x) â†’ (y, Ï€): Eval takes an input x âˆˆ X (in the sample space of inputs) and the evaluation
key and produces an output y âˆˆ Y (in the sample space of outputs) and a (possibly empty) proof Ï€.
Eval may use random bits to generate Ï€ but not to compute y. Eval runs in parallel time X even
when given poly(log(X), Î») processors for all pp generated by Setup(Î», X) and x âˆˆ X .

3. Verify(vk, x, y, Ï€) â†’ {Y es, N o}: Verify is a deterministic algorithm that takes the veriï¬cation key
vk, an input x, the output y, and proof Ï€ and outputs Y es or N o depending on whether y was correctly
computed from via Eval. Eval runs in time O(log(X)).

Furthermore, V must satisfy the following properties:

1. Correctness A VDF V is correct if for all Î», X, parameters (ek, vk) Râ†âˆ’ Setup(Î», X), and all x âˆˆ X ,

if (y, Ï€) Râ†âˆ’ Eval(ek, x), then Verify(vk, x, y, Ï€) â†’ Y es.

2. Soundness A VDF is sound if for all algorithms A that run in time O (poly(X, Î»))

ï£®

ï£¯
ï£°

P

Verify(vk, x, y, Ï€) = Y es
y(cid:48) (cid:54)= y

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

pp = (ek, vk) Râ†âˆ’ Setup(Î», X)
(x, y(cid:48), Ï€(cid:48)) Râ†âˆ’ A (Î», pp, X)
(y, Ï€) Râ†âˆ’ Eval(ek, x)

ï£¹

ï£º
ï£» â‰¤ negl(Î»).

3. Sequentiality A VDF is (p, Ïƒ)-sequential if no adversary A = (A0, A1) with a pair of randomized
algorithms A0, which runs in total time O(poly(X, Î»)), and A1, which runs in parallel time Ïƒ(t) on at
most p(t) processors, can win the following game with probability greater than negl(Î»):

pp Râ†âˆ’ Setup(Î», X)
L Râ†âˆ’ A0(Î», pp, X)
x Râ†âˆ’ X

yA

Râ†âˆ’ A1(L, pp, x).

A = (A0, A1) wins the game if (y, Ï€) Râ†âˆ’ Eval(ek, x) and yA = y.

15

There are many implementations in the literature of VDFs (e.g. [25, 28]). We do not provide these
implementations here as it is out-of-scope for our paper, but please refer to these papers for contructions of
VDFs that satisfy the above properties.

A.2 Tail Bounds

We use the following variant of Hoeï¬€dingâ€™s inequality.

Theorem 28 (Hoeï¬€dingâ€™s inequality). Let Y1, . . . , Yn be n independent, identically distributed random
i=1 Yi, then
variables drawn from a Bernoulli distribution with parameter p, Yi
Sn âˆ¼ Binom(n, p), E(Sn) = np, and

If Sn = (cid:80)n

i.i.d.âˆ¼ Ber(p).

(cid:40)

P

1
n

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

n
(cid:88)

i=1

Yi âˆ’ pn

(cid:41)

â‰¥ Îµ

(cid:12)
(cid:12)
(cid:12)
(cid:12)
(cid:12)

â‰¤ 2eâˆ’2nÎµ2

.

A.3 The Bitcoin Blockchain System

In this section, for completeness, we provide a high-level overview of the Bitcoin Blockchain System. The
below is mainly to serve as a reminder of the Bitcoin protocol for those unfamiliar with it.
High-Level Description.

The nodes in the system represent miners in the Bitcoin cryptosystem who mine blocks ï¬lled with requests
from clients. Clients represent payers who would like to fulï¬ll some transactions. The client issues a write-
request whenever it wants to send a transaction to a miner. The miner then attempts to mine a block
containing the value of the transaction. Speciï¬cally, the following set of steps occur:

â€¢ The payer submits a write-request to the system with a valid transaction as the write â€œvalueâ€ they

want to add to the public ledger.

â€¢ Every honest miner i:

â€“ has a mempool which contains a collection of multi-cast transactions received by this miner.
Notably, due to issues such as network failures and messages delay, the mempool kept by diï¬€erent
miners might not be identical, and

â€“ keeps a local valid blockchain Ci.

â€¢ In each round, each of the miners:

1. Blockify its local mempool (i.e., creates a block of appropriate size that contains a sub-set of the

transactions in mempool) and removes those blockiï¬ed transactions from mempool.

2. Try to add this new block to its local chain Ci.
3. If the miner successfully extends its local chain, it multi-casts the updated chain to other miners.

4. Wait to receive multi-casted chains from others and update its local chain to be the chain that
is the longest among the received chains and its current local chain. If there are multiple longest
chains, use a symmetry breaking mechanism to choose one of them as its new local chain.

In the Bitcoin system, oftentimes, the symmetry is broken in an arbitrary manner, i.e., if there is a tie, an
honest node chooses an arbitrary longest chain (e.g. the chain it received ï¬rst). In an adversarial setting,
this symmetry-breaking strategy could potentially lead to honest nodes choosing diï¬€erent chains frequently.
It turns out that this symmetry-breaking rule, with high probability, can guarantee safety as long as it is
suï¬ƒciently hard to successfully mine a block. However, this is not the case when the probability of successfully
mining a block is large. In fact, for such instances, it is important to consider speciï¬c symmetry-breaking
strategies and how they aï¬€ect the system.

16

B Honest Majority Assumption

The honest majority assumption in the seminal [13] is presented below for completeness. For ease of com-
parison, we use the same notation as that in [13] Let f0 be the probability at least one honest node succeeds
in ï¬nding a proof-of-work (pow) in a round. In [13], the notion of the advantage of honest participants is
used, denoted by Î´. It is used to bound b

nâˆ’b . In particular, Î´ is chosen so that

b
nâˆ’b â‰¤ 1 âˆ’ Î´ always holds.

Assumption 29 (Honest Majority Assumption [13]). Given an (cid:15) âˆˆ (0, 1), n, and p, the maximal number
of corrupted nodes b satisï¬es:

â€¢ 3f0 + 3(cid:15) < Î´ â‰¤ 1, and

â€¢ b â‰¤ (1 âˆ’ Î´)(n âˆ’ b).

Notably, by deï¬nition of Î´, the second bullet in Assumption 29 always holds. Hence, for ï¬xed (cid:15) âˆˆ (0, 1),

n, and p, the real constraint on b is the relation assumed in the ï¬rst bullet of Assumption 29.

Proof of Proposition 6. By Assumption 29, it holds that

As (cid:15) > 0, (4) implies that 3f < Î´. Let f denote the probability at least one honest node succeeds in ï¬nding
a pow in a round. We have f â‰¥ 1 âˆ’ (1 âˆ’ p)(nâˆ’b). So

3f + 3(cid:15) < Î´ â‰¤ 1.

(4)

Equivalently,

(cid:16)

1 âˆ’ (1 âˆ’ p)(nâˆ’b)(cid:17)

3

â‰¤ 3f < Î´.

log(1 âˆ’ Î´/3) < (n âˆ’ b) log(1 âˆ’ p),

for arbitrary base of log as long as the base is â‰¥ 1. By Taylor expansion, we have

where the last inequality follows from the fact that Î´ âˆˆ (0, 1).

(n âˆ’ b)p <

Î´/3
1 âˆ’ Î´/3

â‰¤

Î´
2

,

On Remark 7: To see the claim in Remark 7, consider the boundary case where n = 2b + 1 â€“ the honest
nodes barely make it to be the majority of the system. In this case, the upper bound of p in Proposition 6 is

n âˆ’ 2b
2(n âˆ’ b)2 =

1
2(n âˆ’ nâˆ’1

2 )2

=

2
(n + 1)2 .

Thus, in expectation, it takes at least n + 1 rounds for the honest nodes to mine a block collectively. Such a
low block generating speed makes it unlikely to have multiple longest chains unless the network delay is very
serious. This observation also justiï¬es why the choice of symmetry breaking rules does not matter much
in [13, 23].

ease of illustration, letâ€™s consider the sequence of bk for k = 1, Â· Â· Â· , (cid:98) nâˆ’1
loss of generality, assume that

This observation holds not only for the boundary case when n = 2b + 1 but also for more general b. For
2k+1 n(cid:99). Without
2k+1 n is an integer for all k under consideration. For a system with up to
. In a sense, the
2 n.

bk corrupted nodes, the upper bound in Proposition 6 lies in between
Honest Majority Assumption (formally stated in 29) requires the mining puzzle becomes harder as b â†’ 1
That is, Assumption 29 requires the system to trade oï¬€ liveness for tolerating more corrupt nodes.

2 (cid:99) with bk := (cid:98) k

1
2(k+1)n ,

1
(k+1)n

(cid:16)

(cid:17)

k

17

C Proof of Theorem 8

Proof of Theorem 8. We formalize the arguments of the main proof ideas in Section 4.1. Let {c1, Â· Â· Â· , cn}
be a set of n diï¬€erent colors. We associate each node in the system with a color. We use (ci, t) to denote
the block generated by honest node i during round t and (c0, 0) to denote the genesis block. We use
(ci, t) â†’ (ci(cid:48), t âˆ’ 1) to denote the event that block (ci, t) is attached to block (ci(cid:48), t âˆ’ 1), which occurs with
probability 1
n under our symmetry-breaking rule. To quantify the maximal inconsistency of the longest
chains of round T , we consider the following auxiliary random process. It can be easily shown that there is a
bijection between the sample paths of the Bitcoin blockchain protocol and the sample paths of this auxiliary
process, and that the auxiliary process and the original blockchain protocol with random symmetry breaking
have the same probability distribution.
Auxiliary random procedure: For any given T â‰¥ 1, do the following:
(i) Let each color generate a block for each of the rounds in {1, 2, Â· Â· Â· , T };
(ii) Attach each of the block (ci, 1) for i = 1, Â· Â· Â· , n to the genesis block (c0, 0);
(iii) For each t â‰¥ 2 and each (ci, t), attach it to one of the blocks {(ci, t âˆ’ 1) , i = 1, Â· Â· Â· , n} uniformly at
random (i.e., with probability 1/n).
Connecting to coalescing random walks: Here, we formally quantify the connection between the maximal
inconsistency among the longest chains of round T with the coalescing time of n random walks on an n-
complete graph. Since p = 1 and there is no adversary, the number of longest chains received by each honest
node at each round is n. Let C(T, c1), Â· Â· Â· , C(T, cn) be the n longest chains of round T ending with blocks
(c1, T ) , Â· Â· Â· , (cn, T ), respectively. We ï¬rst show that each of these n chains can be coupled with a random
walk on the n-complete graph. Without loss of generality, letâ€™s consider C(T, c1) which can be expanded as
C(T,c1):=(c0,0)â†(ci1,1)â†Â·Â·Â·â†(cid:0)citâˆ’1,tâˆ’1(cid:1)â†(cit,t)â†Â·Â·Â·â†(cid:0)ciT âˆ’1,T âˆ’1(cid:1)â†(c1,T ),

(5)

where ct is the color of the (t + 1)-th block in the chain. Note that the chain C(T, c1) is random because
the sequence of block colors c0ci1 Â· Â· Â· citâˆ’1cit Â· Â· Â· ciT âˆ’1 c1 is random. Moreover, the randomness in C(T, c1) is
fully captured in the randomness of the block colors. We have

P(cid:8)C(T,c1) = (c0,0) â† (ci1,1) â† Â·Â·Â· â† (cid:0)citâˆ’1,tâˆ’1(cid:1) â† (cit,t) â† Â·Â·Â· â† (cid:0)ciT âˆ’1,T âˆ’1(cid:1) â† (c1,T )(cid:9)

(a)
= P {(c0, 0) â† (ci1 , 1)}

T
(cid:89)

t=2

P (cid:8)(cid:0)citâˆ’1, t âˆ’ 1(cid:1) â† (cit, t)(cid:9)

=

T
(cid:89)

t=2

P (cid:8)(cid:0)citâˆ’1 , t âˆ’ 1(cid:1) â† (cit, t)(cid:9) ,

where the last equality is true as P {(c0, 0) â† (ci1 , 1)} = 1, and the equality (a) holds because under our
symmetry-breaking rule, neither the previous history up to round t nor the future block attachment choices
after round t aï¬€ects the choice of the chain extension in round t. Moreover, the probability of any realization
(cid:1)T âˆ’1
of the color sequence c0ci1 Â· Â· Â· citâˆ’1 cit Â· Â· Â· ciT âˆ’1c1 (i.e., a sample path on the block colors in Bitcoin) is (cid:0) 1
.
Letâ€™s consider the complete graph with vertex set {c1, c2, Â· Â· Â· , cn}. Under our symmetry breaking rule, the
backwards color sequence c1ciT âˆ’1 Â· Â· Â· citcitâˆ’1 Â· Â· Â· ci1 (without considering the genesis block) is a random walk
on the n-complete graph starting at vertex c1. Similarly, we can argue that C(T, c2), Â· Â· Â· , C(T, cn) correspond
to nâˆ’1 random walks on the n-complete graphs starting at vertices c2, Â· Â· Â· , cn, respectively. As argued in the
main proof ideas paragraph, these n random walks are not fully independent. In fact, they are coalescing
random walks, and their coalescence is exactly the maximal inconsistency among the longest chains of round
T .

n

With the above connection of the longest chain protocol augmented by uniformly-at-random symmetry

breaking with coalescing random walks. We conclude by applying Theorem 11.

18

D Missing proofs and auxiliary results for Section 4.2

Proof of Lemma 15. To characterize the coalescence time, similar to the analysis in [6], for any given k âˆˆ
{1, Â· Â· Â· , ng}, we construct a larger graph Q = Qk = (VQ, EQ), where VQ = V k and two vertices v, w âˆˆ V k if
{v1, w1} , Â· Â· Â· , {vk, wk} are edges of G. Let Mk be the time until the ï¬rst meeting in the original graph G.
Let S âŠ† VQ denote the set of all possible conï¬gurations of the locations of the ng random walks at the ï¬rst
meeting,

Sk = {(v1, Â· Â· Â· , vk) : vi = vj

for some 1 â‰¤ i < j â‰¤ k} .

(6)

It is easy to see that there is a direct equivalence between the u-lazy random walks on G and the single u-lazy
random walk on Q. Since Q is a complete graph with self-loops, the limiting distribution of lazy random
walk on Q is the same as the standard random walk on Q. Let Ï€Q âˆˆ R|V k| be the stationary distribution of
a standard random walk on Q and let Ï€Q
v . By [6, Lemma 4], we know that for any 1 â‰¤ k â‰¤ kâˆ—
Ï€Q
Sk
where kâˆ— (cid:44) max{2, log ng}, it holds that

= (cid:80)

vâˆˆSk

Ï€Q
Sk

â‰¥

k2
8ng

.

Let Hv,Sk denote the hitting time of vertex set Sk starting from vertex v and let

H Q

Ï€ (HSk ) =

(cid:88)

vâˆˆV k

Ï€Q

v Hv,Sk

denote the expected hitting time of Sk from the stationary distribution Ï€Q. From [1, Lemma 2.1] and the
fact we can contract the vertex set Sk into one pseudo vertex, similar to [6, proof of Theorem 2], we have
that

(cid:16)

(cid:80)âˆ

t=0

EÏ€Q [HSk ] =

(Sk) âˆ’ Ï€Q
P t
Sk
St
Ï€Q
Sk
1 âˆ’ Ï€Q
Sk

â‰¤

(cid:17)

8ng
uk2 .

(cid:16)

â‰¤

8ng
k2

1
u

(cid:16)

(cid:80)âˆ

t=0

(cid:17)

=

(1 âˆ’ u)t + (1 âˆ’ (1 âˆ’ u)t) Ï€Q
Sk

âˆ’ Ï€Q
Sk

(cid:17)

Ï€Q
Sk

In addition, by conditioning on whether the particles stay at their initial locations or not, we have

E [Mk] = (1 âˆ’ u) (1 + E [Mk]) + u (1 + EÏ€Q (HSk )) ,

which implies that

Thus, for any k such that 1 â‰¤ k â‰¤ kâˆ— = {2, log ng}, we have

E [Mk] â‰¤

(cid:18)

1
u

1 +

(cid:19)

8ng
k2

= O

(cid:16) ng
uk2

(cid:17)

.

E [Ck] â‰¤

k
(cid:88)

s=2

E [Ms] â‰¤ O(ng/u).

Let Wu be a lazy random walk on the complete graph G with initial location u. In each round, with
probability (1 âˆ’ u), Wu stays at its current location and with probability u it moves to one of the current
neighbors (including self-loops) uniformly at random. Let Ï€G the limiting distribution of the location vertex
of Wu. By [6, Eq.(8)], its mixing time is tmix = 3 log ng
3 log ng
log(1/(1âˆ’u)) (cid:101),

log(1/(1âˆ’u)) , i.e., for any given u âˆˆ V , when t â‰¥ (cid:100)

(cid:107)P t

u âˆ’ Ï€G(cid:107)1 =

(cid:88)

(cid:12)
(cid:12)P t

u(v) âˆ’ Ï€G
v

(cid:12)
(cid:12)

vâˆˆV
(cid:12)1 âˆ’ Ï€G
u

= (cid:12)

(cid:12)
(cid:12) (1 âˆ’ u)t +

(cid:88)

(cid:12)
(cid:12)

(cid:0)1 âˆ’ (1 âˆ’ u)t(cid:1) Ï€G

v âˆ’ Ï€G
v

(cid:12)
(cid:12)

â‰¤ 2(1 âˆ’ u)t â‰¤

v:vâˆˆV,v(cid:54)=u
1
n2
g

.

2
n3
g

â‰¤

19

Here, with a little abuse of notation, we use P t
tâˆ— = kâˆ— log ng (kâˆ—tmix + 3EÏ€Q (HSkâˆ— )). Following the arguments in [6, Section 5], we have

u to denote the distribution of the state of Wu at round t. Let

C(ng) â‰¤ 4tâˆ— + E [Ckâˆ— ]

â‰¤ 4 log ng (kâˆ—tmix + 3EÏ€Q (HSkâˆ— )) + O(ng/u)

â‰¤

4 log4 ng
log 1
1âˆ’u
4 log4 ng
u
= O(ng/u),

â‰¤

+ 12 log2 ng

8ng
u log2 ng

+

96ng
u

+ O(ng/u)

+ O(ng/u)

where the last inequality follows from log 1/(1 âˆ’ u) â‰¥ u.

The following lemma will be used in the proof of Theorem 12

Lemma 30. Suppose that there k balls. Let X be the number of non-empty bins if we throw each of the k
balls into b bins, where k â‰¤ b, uniformly at random. Let ËœX be the number of non-empty bins if we throw
each of the k balls into b + âˆ† bins, where âˆ† âˆˆ N, uniformly at random. Then ËœX ï¬rst-order stochastically
dominates X.

P {X â‰¤ l} â‰¥ P

(cid:110) ËœX â‰¤ l

(cid:111)

âˆ€l.

Proof. Intuitively speaking, since b < b + âˆ†, collisions are more likely to occur when fewer bins are available.
Hence, X2 ï¬rst-order stochastically dominates X1. For the sake of peace of mind, a formal proof is given
below.

Letâ€™s consider the mental process wherein we throw the balls into bins one by one. Let Yt after we throw
t balls into b bins. Similarly, Zt be the number of nonempty bins we throw t balls into b + âˆ† bins. We show
Lemma 30 by induction on t.
Clearly, Y1 = 1 = Z1.
Induction hypothesis: Suppose for t â‰¤ k âˆ’ 1, there exists a coupling between the marginal probabilities of
the above two ball throwing processes such that under this coupling

Yt â‰¤ Zt.

(7)

When Yt â‰¤ Zt âˆ’1, by Eq.(7) and the monotonicity of Y and Z, it holds that Yt+1 â‰¤ Yt +1 â‰¤ Zt â‰¤ Zt+1. It
remains to consider the case where Yt = Zt. It is easy to see that Yt+1 = Yt if the t+1â€“th was thrown into the
existing non-empty bins, which occurs with probability P {Yt+1 = Yt} = Yt
b+âˆ† .
For ease of exposition, let Zt+1 = Zt = Î³. Consider the following coupling:

b . Similarly, P {Zt+1 = Zt} = Zt

â€¢ If the (t + 1)â€“th ball of the second bins-and-balls process is thrown into the Zt existing nonempty bins,
then put the (t + 1)â€“th ball of the ï¬rst bins-and-balls process uniformly at random into its Yt existing
nonempty bins.

probability

â€¢ If the (t + 1)â€“th ball of the second bins-and-balls process is thrown into an empty bin, then with
b(b+âˆ†âˆ’Î³) put the (t + 1)â€“th ball of the ï¬rst bins-and-balls process uniformly at random
b(b+âˆ†âˆ’Î³) , put the (t + 1)â€“th ball of the ï¬rst

into one existing nonempty bin. With probability 1 âˆ’
bins-and-balls process into one empty bin uniformly at random.

âˆ†Î³

âˆ†Î³

It is easy to see that in the above coupling, the (t + 1)â€“th ball of the ï¬rst bins-and-balls process is throw
into a bin (regardless whether it is empty or not) with probability 1
b . Moreover, with this coupling and the
induction hypothesis, we know that

Yt+1 â‰¤ Zt+1,

20

completing the induction proof. Hence, X = Yk â‰¤ Zk = ËœX. Therefore,

(cid:110) ËœX â‰¤ l

(cid:111)

P

â‰¤ P {X â‰¤ l} , âˆ€ l,

i.e., ËœX ï¬rst-order stochastically dominates X.

Proof of Theorem 12. For any t, the expected length of a longest chain is 1 + (1 âˆ’ (1 âˆ’ p)n) t. When
p < 4 ln 2
n , we can use Poisson approximation to approximate the distribution of number of blocks in each
round. A straightforward calculation shows that the probability of having exactly one block in a round
is np exp (âˆ’np) . Thus, in expectation, the maximal inconsistency is at most
np exp(âˆ’np) . Henceforth, we
restrict our attention to the setting where p â‰¥ 4 ln 2
and quantify the expected maximal inconsistency among
the longest chains of round t. We ï¬rst consider a coarse analysis whose arguments are similar to the proof
of Theorem 8 and derive a bound on the maximal inconsistency via stochastic dominance. Though the
obtained bound could be very loose, based on the insights obtained in this coarse analysis, we can come up
with a much ï¬ne-grained analysis, which signiï¬cantly improves the bound on maximal inconsistency.

n

1

A coarse analysis: Let {c1, Â· Â· Â· , cn} be a set of n diï¬€erent colors. We temporarily associate each node
in the system with a color. 7 If node i mines a block during round t, we denote this block by (ci, t). In
addition, we use (c0, 0) to denote the genesis block. We use (ci, t) â†’ (ci(cid:48), t âˆ’ 1) to denote the event that
both blocks (ci, t) and (ci(cid:48), t âˆ’ 1) exist and that block (ci, t) is attached to block (ci(cid:48), t âˆ’ 1), which, under
our symmetry-breaking rule, occurs with probability

1{node ci mines a block during round t}1{node ci(cid:48) mines a block during round t âˆ’ 1}

(cid:80)n

i(cid:48)=1

1{node ci(cid:48) mines a block during round t âˆ’ 1}

.

Notably, in the Bitcoin protocol, there are two sources of randomness: (1) the randomness in generating
blocks and (2) the randomness in the block attachments. To quantify the maximal inconsistency of the
longest chains of round T , we consider the following auxiliary random process. It can be easily shown that
there is a bijection between the sample paths of the Bitcoin blockchain protocol and the sample paths of this
auxiliary process, and that the auxiliary process and the original blockchain protocol with random symmetry
breaking have the same probability distribution.
Auxiliary random procedure: For any given T â‰¥ 1, do the following:
(i) For each of the rounds in {1, 2, Â· Â· Â· , T }, let each node/color generate a block with probability p indepen-
dently of other nodes and independently across rounds. For ease of exposition, we refer to the blocks mined
in round t as the blocks in layer t.
(ii) Attach each of the block (ci, 1), if exists, for i = 1, Â· Â· Â· , n to the genesis block (c0, 0);
(iii) For each t â‰¥ 2 and each (ci, t) that exits, attach it to one of the blocks in layer (t âˆ’ 1). If layer (t âˆ’ 1)
is empty, let

t(cid:48) (cid:44) max {r : layer r is nonempty and r â‰¤ t} ,

and let each existing (ci, t) uniformly at random chooses one ancestor block in block layer t(cid:48).
Connecting to coalescing random walks: We ï¬rst build a coarse connection between the maximal inconsis-
tency among the longest chains of round T with the coalescing time of n random walks on an n-complete
graph. A much ï¬ne-grained connection to coalescing random walks on 2np-complete graph in given in ï¬ne-
grained analysis part of this proof. It is easy to see that the number of blocks mined in each round t, denoted
by Nt, follows the Binom(n, p) distribution. Without loss of generality, we assume that NT (cid:54)= 0. If this
does not hold, then we can replace T by the most recent round T (cid:48) such that NT (cid:48)
(cid:54)= 0 and the remaining
proof goes through. Since there is no adversary, the number of longest chains at the end of round T is NT ,
each of which ends with a block in block layer T . Let C(T, c(cid:48)
) be the NT longest chains of
NT
, T (cid:1), respectively. We ï¬rst show that each of these NT chains
round T ending with blocks (c(cid:48)

1), Â· Â· Â· , C(T, c(cid:48)

1, T ) , Â· Â· Â· , (cid:0)c(cid:48)

NT

7In our ï¬ne-grained analysis, the color of a block will be re-assigned.

21

can be coupled with a process that is a variant of a random walk on the n-complete graph. Without loss of
generality, letâ€™s consider C(T, c(cid:48)

1) which can be expanded as

C(T, c(cid:48)

1) := (c0, 0) â† (ci1, 1) â† Â· Â· Â· â† (cid:0)cikâˆ’1 , k âˆ’ 1(cid:1) â† (cik , k) â† Â· Â· Â· â† (cid:0)ciKâˆ’1, K âˆ’ 1(cid:1) â† (c(cid:48)

1, T ) ,

(8)

where c(cid:48)
k is the color of the (k + 1)-th block in the chain and K is the number of non-empty block layers
under event E â€“ in the realization of block mining. Recall that for general p âˆˆ (0, 1) there are two sources
of randomness (1) the randomness in block generating and (2) the randomness in block attachment. Con-
sequently, the sequence of block colors c0ci1 Â· Â· Â· cikâˆ’1cik Â· Â· Â· ciKâˆ’1 c(cid:48)
1 is random in that, roughly speaking, the
â€œfeasibilityâ€ of cik is determined by whether node ik mines a block during round k or not, and the ordering of
the â€œfeasibleâ€ colors is determined by the attachment choices. Let E be any realization of the block mining
for the ï¬rst T rounds, which corresponds to any realization of step (i) of the auxiliary process. We have

1) | E}

P {C(T, c(cid:48)
= P (cid:8)(c0, 0) â† (ci1 , 1) â† Â· Â· Â· â† (cid:0)cikâˆ’1, k âˆ’ 1(cid:1) â† (cik , k) â† Â· Â· Â· â† (cid:0)ciKâˆ’1, K âˆ’ 1(cid:1) â† (c(cid:48)

1, T ) | E(cid:9)

(a)
= P {(c0, 0) â† (ci1, 1) | E}

(cid:32)Kâˆ’1
(cid:89)

k=2

P (cid:8)(cid:0)cikâˆ’1 , k âˆ’ 1(cid:1) â† (cik , k) | E(cid:9)

(cid:33)

P (cid:8)(cid:0)ciKâˆ’1 , K âˆ’ 1(cid:1) â† (c(cid:48)

1, T ) | E(cid:9)

(cid:32)Kâˆ’1
(cid:89)

=

k=2

P (cid:8)(cid:0)cikâˆ’1 , k âˆ’ 1(cid:1) â† (cik , k) | E(cid:9)

(cid:33)

P (cid:8)(cid:0)ciKâˆ’1 , K âˆ’ 1(cid:1) â† (c(cid:48)

1, T ) | E(cid:9) ,

1
nt

t:2â‰¤tâ‰¤T,&nt(cid:54)=0

where the last equality is true as P {(c0, 0) â† (ci1 , 1) | E} = 1, and the equality (a) holds because under our
symmetry-breaking rule, neither the previous history up to round t nor the future block attachment choices
after round t aï¬€ects the choice of the chain extension in round t. Moreover, the conditional probability of
any realization of the color sequence c0ci1 Â· Â· Â· cikâˆ’1 cik Â· Â· Â· ciKâˆ’1c(cid:48)
1 conditioning on E (i.e., a sample path on
the block colors in Bitcoin) is (cid:81)
where Nt = nt for all t âˆˆ {2, Â· Â· Â· , T }. Letâ€™s consider the
complete graph with vertex set {c1, c2, Â· Â· Â· , cn}. Under our symmetry breaking rule, conditioning on E, the
backwards color sequence c(cid:48)
1ciKâˆ’1 Â· Â· Â· cik cikâˆ’1 Â· Â· Â· ci1 (without considering the genesis block) is a walk, though
not the standard random walk, of length T on the n-complete graph with initial location c(cid:48)
1. Similarly, we
can argue that C(T, c(cid:48)
) correspond to (NT âˆ’ 1) walks on the n-complete graphs starting at
vertices c(cid:48)
, respectively. Similar to the argument in the proof of Theorem 8, conditioning on E,
there is an one-to-one correspondence between the event of the forking of the chains C(T, c(cid:48)
)
and the event of coalescence of the backwards walks; that is, the maximal inconsistency of the longest chains
of round T is the same as the coalescence time of the NT walks on the n-complete graphs. These NT walks
are more likely to coalesce than the standard random walks whose transition probability is 1/n, whereas
under any E, Nt = nt â‰¤ n for t = 1, Â· Â· Â· , T ; this fact can be formally shown via Lemma 30. Hence, the
conditioning on E, the maximal inconsistency is upper bounded by the coalescence time of the standard
random walks on n-complete graph with n particles, which is O(n). Since this is true for all possible block
mining realization E, we conclude that the maximal inconsistency is upper bounded by O(n).

1), Â· Â· Â· , C(T, c(cid:48)

2), Â· Â· Â· , C(T, c(cid:48)

2, Â· Â· Â· , c(cid:48)

NT

NT

NT

A ï¬ne-grained analysis: Let E any realization of the block mining for the ï¬rst T rounds. If not explicitly
mentioned, the following arguments are stated conditioning on E. To conclude the proof, towards the end
of this proof, we take average over all possible events E.

The bound on the maximal inconsistency is O(n) which could be loose for a wide value range of p. This is
because the upper bound on Nt is loose. Recall that Nt is a Binom(n, p). Thus, E [Nt] = np (cid:28) n as long as
p = o(1). Observing this, in this ï¬ne-grained analysis, we ï¬rst construct a lazy version of the NT backwards
walks whose expected coalescence time is at least the coalescence time of the original NT backwards walks.
Then re-color the mined blocks so that the re-colored lazy version of the NT original walks are walks on at
most 2np colors only. Then, we connect these lazy walks with the a lazy version of random walks each of
which, if not stay at their current locations concurrently, moves to one of the neighboring colors (including
its current color) with probability 1
2np . Finally, by changing of the order of taking expectation, we show that
3 np(cid:1))-lazy
the maximal inconsistency is upper bounded by the expected coalescence time of the (1 âˆ’ 2 exp (cid:0)âˆ’ 1
random walks. We conclude the proof of this theorem by applying Lemma 15.
Lazy walks construction: Consider the following nT lazy version of the backwards coalescing walks. For
each s = 1, Â· Â· Â· , K âˆ’ 1, if nKâˆ’s â‰¤ 2np, each of the remaining walks moves to one of the block color in layer

22

(K âˆ’ s) uniformly at random. If two or more walks visit the same color, then these walks coalesce into one.
If nKâˆ’s > 2np, we let the remaining walks stay at their current color vertices. Clearly, this lazy version
of the NT backwards walks are more likely to coalesce than the original NT walks. Let Cl(E) denote the
expected number of backwards steps until all the lazy NT walks coalesce.
Color re-assignment: Next we show that, under any E, Cl(E) is upper bounded by the expected coalescence
time of max{2np, nT } lazy random walks on the 2np-complete graph. Towards this, we ï¬rst do color-
reassignment, detailed as follows. Let {Ëœc1, Â· Â· Â· , Ëœcn} be a set of n diï¬€erent colors. We (re-)assign a color to
each of the mined block in diï¬€erent block layers as follows: Assign color Ëœc1 to the genesis block. For each
t = 1, Â· Â· Â· , T such that Nt (cid:54)= 0, let it
be the indices of the nodes/original colors each of which
successfully mines a block during round t. Re-assign colors Ëœc1, Â· Â· Â· , ËœcNt to blocks
re-colored blocks are denoted as (Ëœc1, t) , Â· Â· Â· , (ËœcNt, t), respectively.

1 < Â· Â· Â· < it
Nt

. The

cit
Nt

, Â· Â· Â· ,

cit

, t

, t

(cid:17)

(cid:16)

(cid:17)

(cid:16)

1

Notably, diï¬€erent from the color assignment we used in the proof for the case when p = 1, under the above
color re-assignment rule, the blocks mined by the same node at diï¬€erent rounds could be assigned diï¬€erent
colors. Fortunately, it is easy to see that the blocks attachments are independent of the color assignments.
In particular, it is still true that the maximal inconsistency among the longest chains of round T is the same
as the coalescence time of the corresponding backwards walks on those colors. Moreover, it is still true that
the expected coalescence time of the re-colored NT walks is upper bounded by Cl(E) the lazy version of the
re-colored NT walks. More importantly, the re-colored lazy NT walks, expect for their initial colors, are the
walks on at most 2np colors in each round.

Consider the following max {2np, NT } lazy coalescing random walks on the 2np-complete graph with
arbitrary but distinct initial locations. For each s = 1, ...T , if the above NT lazy version of the walks on
colors stay at their own locations concurrently (i.e., NT âˆ’s â‰¥ 2np) or NT âˆ’s = 0, then each of the remaining
random walks on the 2np-complete graph also stay at their current locations. If otherwise (i.e., each of the
lazy walks on colors moves to one of the colors assigned to the blocks in the proceeding non-empty layer
uniformly at random), we let each of the remaining walks on the 2np-complete graph moves to one of the 2np
vertices uniformly at random. By Lemma 30, we know the expected coalescence time of the NT lazy walks
on colors is upper bounded by that of the max {2np, NT } walks on the 2np-complete graph which is again
upper bounded by the expected coalescence time of 2np lazy walks on the 2np-complete graph, denoted by
Cl,np(E).

Next we consider averaging over all the realizations of E. For any given T , with the above arguments,

we know that the expected maximal inconsistency is upper bounded by

Cl,np(E)P {E} .

(cid:88)

E

Note that by construction, Cl,np(E) depends on E only through the number of blocks mined in each round.
In particular, it only depends on each Nt in whether 1 â‰¤ Nt < 2np holds or not. So we have

Cl,np(E)P {E} =

(cid:88)

Cl,np(n1, Â· Â· Â· , nT âˆ’1)P {Nt = nt, âˆ€ t â‰¤ T âˆ’ 1}

n1,Â·Â·Â· ,nT âˆ’1

Cl,np(n1, Â· Â· Â· , nT âˆ’1)P {NT âˆ’1 = nT âˆ’1}

ï£¶
ï£¸ P {Nt = nt, âˆ€ t â‰¤ T âˆ’ 2}

ï£«

ï£­

(cid:88)

nT âˆ’1

(Cl,np(n1, Â· Â· Â· , nT âˆ’1 âˆˆ {2np, Â· Â· Â· , n} âˆª {0})P {NT âˆ’1 â‰¥ 2np or NT âˆ’1 = 0}

(cid:88)

E

=

=

(cid:88)

n1,Â·Â·Â· ,nT âˆ’2
(cid:88)

n1,Â·Â·Â· ,nT âˆ’2

+ Cl,np(n1, Â· Â· Â· , nT âˆ’1 âˆˆ {1, Â· Â· Â· , 2np âˆ’ 1} )P {1 â‰¤ NT âˆ’1 < 2np}) P {Nt = nt, âˆ€ t â‰¤ T âˆ’ 2} .

Note that when nT âˆ’1 âˆˆ {2np, Â· Â· Â· , n} âˆª {0}, each of the 2np random walks stay at their initial locations
concurrently with occurs with probability P {NT âˆ’1 â‰¥ 2np or NT âˆ’1 = 0}, and when nT âˆ’1 âˆˆ {1, Â· Â· Â· , 2npâˆ’1},
each of the 2np random walks take one step standard coalescing random walks. That is, the 2np random
walks are performing one step (1 âˆ’ P {NT âˆ’1 â‰¥ 2np or NT âˆ’1 = 0})-lazy random walk on the 2np-complete
graph. Since Nt is i.i.d. across t, we can repeat this argument for T âˆ’ 1 times. In fact, we can exchange
the order taking expectation over E and taking expectation over the realization of the walks. Hence,

23

(cid:80)

E Cl,np(E)P {E} equals the expected coalescence time of 2np (1 âˆ’ P {NT âˆ’1 â‰¥ 2np or NT âˆ’1 = 0})-lazy

random walks. By Lemma 15, we know that

Cl,np(E)P {E} = O

(cid:88)

E

(cid:18)

2np
(1 âˆ’ P {NT âˆ’1 â‰¥ 2np or NT âˆ’1 = 0})

(cid:19)

.

In addition, we have

P {Nt â‰¥ 2np, or Nt = 0} = P {Nt â‰¥ 2np} + P {Nt = 0}

= P {Nt â‰¥ 2np} + (1 âˆ’ p)n = P {Nt â‰¥ 2np} + exp

(cid:18)

âˆ’n log

(cid:19)

1
1 âˆ’ p

(cid:18)

â‰¤ exp

âˆ’

1
3

(cid:19)

(cid:18)

np

+ exp

âˆ’n log

(cid:19)

1
1 âˆ’ p

(cid:18)

â‰¤ 2 exp

âˆ’

(cid:19)

np

,

1
3

where the last inequality holds because p â‰¤ log 1

1âˆ’p when p âˆˆ [0, 1). So, it holds that

Cl,np(E)P {E} = O

(cid:88)

E

(cid:32)

2np

(cid:0)1 âˆ’ 2 exp (cid:0)âˆ’ 1

3 np(cid:1)(cid:1)

(cid:33)

,

proving the theorem.

E Missing proofs and auxiliary results for Section 4.3

Proof of Lemma 19. For each round Ï„ , the following holds:

â€¢ If no blocks are mined, then the lengths of the adversarial longest chains and the honest longest chains

(longest chains kept by an honest node) are not changed.

â€¢ If both the honest and the corrupt nodes mine a block, then the lengths of the adversarial longest
chains increases by 1, and length of the honest longest chains (longest chains kept by an honest node)
increases by at least 1. To see the later, letâ€™s denote the length of the longest chains at the honest
nodes at round (Ï„ âˆ’ 1) by (cid:96)(Ï„ âˆ’1) and the length of the longest chains at the honest nodes at round Ï„ by
(cid:96)Ï„ . By the selective relay rule speciï¬ed right before Deï¬nition 17, by the beginning of round Ï„ , every
honest node has received a chain that is at least (cid:96)(Ï„ âˆ’1). If the adversary does not release a preï¬x of
an adversarial chain of length > (cid:96)(Ï„ âˆ’1), the length of the longest chains kept by the honest nodes at
round Ï„ is (cid:96)Ï„ = (cid:96)(Ï„ âˆ’1) + 1. Otherwise, due to the longest chain policy, it holds that (cid:96)Ï„ > (cid:96)(Ï„ âˆ’1) + 1.

â€¢ If only corrupt nodes mine a block, then the adversary can grow the length of the adversarial longest

chains by 1. The length of the longest chains at the honest nodes is unchanged.

â€¢ If only honest nodes mine a block, then the length of the honest longest chains increase by at least 1.
The formal argument follows the same as the proof of the later part of the second bullet. The length
of the longest chains at the corrupt nodes (adversary) is unchanged.

Let t(cid:48) (cid:44) max{t(cid:48) : N (t(cid:48)) = 0 and t(cid:48) â‰¤ t}. Let t(cid:48) = t0 < t1 < Â· Â· Â· < tk be the round indices of the jumps of the
random process N (Ï„ )âˆ

Ï„ =0, i.e.,

N (t0) (cid:54)= N (t0 + 1), Â· Â· Â· , N (tk âˆ’ 1) (cid:54)= N (tk).

By the construction of N (Ï„ )âˆ
Ï„ =0, we know that from round t(cid:48) + 1 to round t, the number of rounds in which
only corrupt nodes mine a block is N (t) larger than the number of rounds in which only honest nodes mine
a block.

Therefore, we know that as long as at round t(cid:48), the length of the adversarial longest chain is no longer
than the length of the honest longest chains, we can conclude that at the end of round t, the length of the

24

adversarial longest chains is at most N (t) blocks longer than the length of the honest longest chains. It
remains to show the following is true: â€œAt round t(cid:48), the length of the adversarial longest chain is no longer
than the length of the honest longest chain. â€

Let N (t(cid:48)) be the kâ€“th time starting from round 0 such that

N (t(cid:48)) = 0 and N (t(cid:48) + 1) = 1.

If k = 1, by the arguments in the above four bullets, we know the claim holds. Letâ€™s assume this claim holds
for general r. We next prove it holds for r + 1. Let t(cid:48)(cid:48) be the râ€“th time starting from round 0 such that

N (t(cid:48)(cid:48)) = 0 and N (t(cid:48)(cid:48) + 1) = 1.

By induction hypothesis, we know that at round t(cid:48)(cid:48), the length of the adversarial longest chain is no longer
than the length of the honest longest chain. By the ï¬rst part of the proof of Lemma 19, we know at round
t(cid:48), the length of the adversarial longest chain is no longer than the length of the honest longest chain. Thus,
the proof of the claim is complete.

The following lemma follows from Hoeï¬€dingâ€™s inequality.
(cid:17)(cid:17)

(cid:16)

(cid:16)

Lemma 31. With probability at least

1 âˆ’ exp

âˆ’ (pâˆ—)2M
2

, it holds that

M
(cid:88)

i=1

1{J (m) (cid:54)= J (m âˆ’ 1)} â‰¥

1
2

pâˆ—M.

(9)

Next we prove Lemma 22.

Proof of Lemma 22. From [16, Chapter 4.10] we know that {J (t)}âˆ
t=0 has a corresponding jump process
(also referred to as the embedded chain) that describes, conditioning on state changes, how J (t) jumps
among diï¬€erent states. We also know that this jump process is a simple random walk. Concretely, if
J (t âˆ’ 1) (cid:54)= J (t), we say a jump occurs at t. Let Tr denote the number of rounds that elapses between the
r-th and r + 1-th jumps of J . Let ËœJ (r) denote the state after r jumps. By deï¬nition,
is the
jump process of {J (t)}âˆ
t=0. It is easy to see that Tr is a geometric random variable with parameter pâˆ—. Also,
T1, T2, Â· Â· Â· are i.i.d. distributed. By [16, Proposition 4.9], we know

(cid:110) ËœJ (r)

(cid:111)âˆ

r=0

ËœJ (r) =

ï£±
ï£´ï£²

ï£´ï£³

0,
ËœJ (r âˆ’ 1) + 1,
ËœJ (r âˆ’ 1) âˆ’ 1,

if r = 0;
with probability p+1/pâˆ—;
with probability pâˆ’1/pâˆ—.

Let Î´r = ËœJ (r) âˆ’ ËœJ (r âˆ’ 1) for any r â‰¥ 1. It is easy to see that Î´r is a Bernoulli random variable supported
on {âˆ’1, +1} and P {Î´r = 1} = p+1/pâˆ—. For a given K â‰¥ 0 jumps, by Hoeï¬€dingâ€™s inequality, we know that
with probability at least

, the following is true

1 âˆ’ exp

(cid:17)(cid:17)

(cid:16)

(cid:16)

âˆ’ K(p+1/pâˆ—âˆ’pâˆ’1/pâˆ—)2
8

K
(cid:88)

r=1

Î´r â‰¥

(p+1/pâˆ— âˆ’ pâˆ’1/pâˆ—)
2

K.

Setting K = 1

2 pâˆ—M , we have

K
(cid:88)

r=1

Î´r =

2 pâˆ—M
1
(cid:88)

r=1

(cid:17)
(cid:16) ËœJ (r) âˆ’ ËœJ (r âˆ’ 1)

= ËœJ (

1
2

pâˆ—M ) âˆ’ ËœJ (0) = ËœJ

(cid:19)

.

pâˆ—M

(cid:18) 1
2

In addition, from Lemma 31, we know that with probability at least (1 âˆ’ exp (cid:0)âˆ’((pâˆ—)2M )/2(cid:1)), it holds that

M
(cid:88)

i=1

1{J (m) (cid:54)= J (m âˆ’ 1)} â‰¥

1
2

pâˆ—M.

(10)

Thus, J (M ) â‰¥ ËœJ (cid:0) 1

2 pâˆ—M (cid:1), proving the lemma.

25

Lemma 32. For any t > 1 round such that N (t) = 0 and at least one block is mined, let NB(t) be the
number of blocks mined by the honest nodes in round t and AB(t) be the number of blocks mined by the
corrupt nodes in round t. For Ëœt (cid:44) min{t(cid:48) : t(cid:48) â‰¤ t âˆ’ 1} such that at least one block is mined, let AB(Ëœt) be the
number of blocks mined by corrupt nodes in round Ëœt. Then it is true that the number of longest chains at
the end of round t is at most (cid:0)NB(t) + AB(t) + AB(Ëœt)(cid:1). In particular, if N (t âˆ’ 1) = 0, then the number of
longest chains at the end of round t is at most (NB(t) + AB(t)). Moreover, all of these longest chains end
with blocks generated in round t.

Proof. One of the following two cases hold.
Case 1: Suppose that N (t âˆ’ 1) = 0. By Lemma 19, at the beginning of round t, the longest chains received
(including their own local chains) by each of the honest node are of the same length. Thus, the number of
longest chains at the end of round t is (NB(t) + AB(t)) â€“ the number of blocks generated during round t.
Case 2: Suppose that N (t âˆ’ 1) (cid:54)= 0. Recall that Ëœt (cid:44) max{t(cid:48) : t(cid:48) â‰¤ t âˆ’ 1} such that at least one block is
generated during round Ëœt. By Deï¬nition 17 and the fact that N (t) = 0, we know that N (Ëœt) = 1. From
Lemma 19, we know that, at the end of round Ëœt, the length of the adversarial longest chains of round Ëœt is at
most one block longer than the local chains at the honest nodes. The adversary can choose either to hide
these longest adversarial chains to some/all honest parities or to release those chains to all of the honest
nodes. The number of such adversarial longest chains is at most AB(Ëœt) â€“ the number of blocks mined by
the corrupt nodes in round Ëœt. Hence the number of longest chains at the beginning of round t is at most
AN(Ëœt) + AB(t) + NB(t).

Lemma 33. Let i1 and i2, where i1 (cid:54)= i2, be two arbitrary honest nodes. For any (t âˆ’ 1) â‰¥ 1 such that
at least one block is mined during round t âˆ’ 1, let C1(t) and C2(t) be the sets of longest chains received by
honest nodes i1 and i2, respectively, at round t before mining (including the chains sent by others at the end
of round t âˆ’ 1 and forwarded at the beginning of round t). If N (t âˆ’ 1) = 0, it holds that

|C1(t) âˆª C2(t)| â‰¥ NB(t âˆ’ 1),

and

max{|C1(t)| , |C2(t)|} â‰¤ NB(t âˆ’ 1) + AB(t âˆ’ 1) + AB((cid:93)t âˆ’ 1),

where (cid:93)t âˆ’ 1 : max{t(cid:48) : t(cid:48) â‰¤ t âˆ’ 2}. Moreover, if N (t âˆ’ 2) = 0, then

max{|C1(t)| , |C2(t)|} â‰¤ NB(t âˆ’ 1) + AB(t âˆ’ 1).

(11)

(12)

(13)

Proof. Since N (t âˆ’ 1) = 0, both C1(t) and C2(t) are subsets of the longest chains at the end of round (t âˆ’ 1).
In addition, from Lemma 32, we know that the total number of longest chains at the end of round t âˆ’ 1 in
the system is at most NB(t âˆ’ 1) + AB(t âˆ’ 1) + AB((cid:93)t âˆ’ 1), proving Eq.(12). As each of the honest nodes
who successfully mines a block during round (t âˆ’ 1) multi-casts its local chain to others, both i1 and i2 will
receive all of the longest chains that end with an honest block. That is,

|C1(t) âˆª C2(t)| â‰¥ NB(t âˆ’ 1),

proving Eq.(11). Since N (t âˆ’ 1) = 0, it is easy to see that NB(t âˆ’ 1) â‰¥ 1.

When N (t âˆ’ 2) = 0, it holds that each of the honest node receives at least one longest chain up to the
beginning of round t âˆ’ 1. Thus, the total number longest chains (including both the ones extended by the
honest nodes and the ones extended by the corrupt nodes) is AB(t âˆ’ 1) + NB(t âˆ’ 1). Since a corrupt node
can choose to not to multi-cast its local chain, it holds that

max{|C1(t)| , |C2(t)|} â‰¤ NB(t âˆ’ 1) + AB(t âˆ’ 1).

Note that as a corrupt node can arbitrarily choose, independently of others, which subset of honest nodes
to send its local chain, the honest nodes i1 and i2 can be two diï¬€erent subsets of the longest chains at the
end of round t âˆ’ 1.

26

F VDF-Scheme Proofs

The above VDF-based scheme presented in Section 5 gives us the following properties which will be crucial
in obtaining our bounds for the case when adversaries are present. We present the proofs omitted from
Section 5 in this section.

Lemma 34. For every round t â‰¥ 0, the local chain of every honest node can contain at most one block per
VDF output, with all but negligible probability in Î».

Proof. Item 5a ensures that the VDF outputs stored in the blocks are computed in strictly increasing order.
This means that no chain veriï¬ed by an honest node can contain two blocks which contain the same VDF
output. Finally, with all but negligible probability in Î» (by Deï¬nition 25), no two VDF outputs will be
equal. The lemma follows.

Lemma 35. The adversary can add at most one block to the same chain (that will be veriï¬ed by honest
nodes) during any round r â‰¥ 0, with all but negligible probability in Î». In other words, let t be the current
round, any adversarial chain veriï¬ed by honest nodes cannot have length greater than t.

Proof. By Lemma 34, no adversary can add two blocks with the same VDF output to the same chain. Thus,
in any adversarial chain veriï¬ed by honest nodes, the adversary can add at most 1 block per round, and the
chain will have length at most t (where t is the current round).

Lemma 36. Let t be the current round. No node can add a block containing a VDF output, ot(cid:48), from a
round t(cid:48) â‰¥ t.

Proof. We prove this via induction. In the base case when the chain only contains the genesis block, the
adversary has access only to the genesis block and no other blocks. In this case, the adversary could not
have mined any other blocks because it did not have time to obtain the VDF output for the next block, with
all but negligible probability in Î». Let our induction hypothesis be that the adversary cannot use dt to mine
a block in round t. We assume this is true for the t-th round and prove this true for the (t + 1)-st round.

By our induction hypothesis, the adversary could not have computed any blocks for the t-th round using
dt. This means that the adversary obtained dt at the beginning of the (t + 1)-st round. Then, suppose the
adversary computes a block for the (t + 1)-st round. By Item 2 of Deï¬nition 27, the adversary could not
have computed the output in time less than the duration of a round,8 with all but negligible probability in
Î». Thus, the adversary could not have mined any blocks using dt+1 until round t + 2. Hence, no adversary
can use dt+1 in mining any blocks during any round t(cid:48)(cid:48) â‰¤ t + 1.

Proof of Theorem 26. Lemma 36 states that the adversary cannot mine a block with VDF output, ot(cid:48), from
a round t(cid:48) > t where t is the current round. Thus, during round t, an adversary can only use VDF outputs,
o1, . . . , otâˆ’1. Then, Lemma 34 and Lemma 35 ensure that no two blocks in a chain can contain the same
VDF output. Then, the length of any chain accepted by an honest node has length at most t since it can
contain at most one block using each of the VDF outputs, o1, . . . , otâˆ’1 (plus the genesis block).

8Recall we set the diï¬ƒculty of the VDF to be the duration of a round.

27

