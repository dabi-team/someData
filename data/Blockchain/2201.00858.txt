2
2
0
2

r
a

M
3
2

]

R
C
.
s
c
[

2
v
8
5
8
0
0
.
1
0
2
2
:
v
i
X
r
a

Blockchain Nash Dynamics and the Pursuit of Compliance

Dimitris Karakostas
University of Edinburgh
d.karakostas@ed.ac.uk

Aggelos Kiayias
University of Edinburgh and IOHK
akiayias@inf.ed.ac.uk

Thomas Zacharias
University of Edinburgh
tzachari@inf.ed.ac.uk

March 24, 2022

Abstract

We study Nash-dynamics in the context of blockchain protocols. We introduce a formal
model, within which one can assess whether the Nash dynamics can lead utility-maximizing
participants to defect from the “honest” protocol operation, towards variations that exhibit
one or more undesirable infractions, such as abstaining from participation and producing
conﬂicting protocol histories. Blockchain protocols that do not lead to such infraction
states are said to be compliant. Armed with this model, we evaluate the compliance of
various Proof-of-Work (PoW) and Proof-of-Stake (PoS) protocol families, with respect to
diﬀerent utility functions and reward schemes, leading to the following results:
i) PoS
ledgers under resource-proportional rewards can be compliant if costs are negligible, but
non-compliant if costs are signiﬁcant; ii) PoW and PoS under block-proportional rewards
exhibit diﬀerent compliance behavior, depending on the lossiness of the network; iii) PoS
ledgers can be compliant w.r.t. one infraction, i.e., producing conﬂicting messages, but
non-compliant (and non-equilibria) w.r.t. abstaining or an attack we call selﬁsh signing;
iv) taking externalities, such as exchange rate ﬂuctuations, into account, we quantify the
beneﬁt of economic penalties, in the context of PoS protocols, in disincentivizing particular
infractions.

1

Introduction

The advent of Bitcoin [73] brought the economic aspects of consensus protocols to the forefront.
While classical literature in consensus primarily dealt with fail-stop or Byzantine “error mod-
els” [82], the pressing question post-Bitcoin is whether the participants’ incentives align with
what the consensus protocol asks them to do. Motivated by this, a line of work investigated if
Bitcoin is an equilibrium under certain conditions [58, 52]. Another pinpointed deviations that
can be more proﬁtable for some players, assuming others follow the protocol [29, 84, 48, 14]. The
research body also includes tweaks towards improving the blockchain protocol in various set-
tings [31, 57], game-theoretic studies of pooling behavior [61, 14, 2], and equilibria that involve
abstaining from the protocol [33] in high cost scenarios. Going beyond consensus, economic
mechanisms have also been considered in the context of multi-party computation [59, 20, 19],
to disincentivize “cheating”. Finally, various works optimized particular attacks, e.g., : i) opti-
mal selﬁsh mining strategies [84]; ii) a framework [42] for quantitatively evaluating blockchain
parameters and identifying optimal strategies for selﬁsh mining and double-spending, taking
into account network delays; iii) alternative strategies [74], that are more proﬁtable than selﬁsh
mining.

Though these works provide glimpses on these protocols’ behavior in a game-theoretic per-
spective, they oﬀer little guidance on how to design and parameterize new consensus protocols.
This problem is of high importance, given the negative light shed on Bitcoin’s perceived energy
ineﬃciency and carbon footprint [66], that necessitates alternative designs. Proof-of-Stake (PoS)

1

 
 
 
 
 
 
is currently the most prominent alternative to Bitcoin’s Proof-of-Work (PoW) mechanism. PoW
requires computational eﬀort to produce valid messages, i.e., blocks acceptable by the proto-
col. PoS relies on each party’s stake, i.e., assets they own, so blocks are created at (virtually)
no cost beyond transaction processing. Interestingly, while it is proven that PoS protocols are
Byzantine resilient [54, 15, 43] and are even equilibriums under certain conditions [54], their
security is heavily contested by PoW protocols proponents via an economic argument termed
the nothing-at-stake attack [62, 26, 67]. This argument asserts that maintainers of PoS ledgers
can maximize their expected rewards by producing conﬂicting blocks when possible.

What merit do these criticisms have? Participating in a blockchain protocol is a voluntary
action that involves a participant downloading the software and committing resources to run it.
Given the open source nature of these protocols, nothing prevents the participant from modifying
the behaviour of the software in some way and engage with the other parties following a modiﬁed
strategy. There are a number of undesirable adjustments that a participant can do, e.g., i) run
the protocol intermittently instead of continuously; ii) not extend the most recent ledger of
transactions they are aware of; iii) extend simultaneously more than one ledger of transactions.
One can consider the above as fundamental infractions to the protocol rules and they may have
serious security implications, both in terms of the consistency and the liveness of the underlying
ledger.

To address these issues, many blockchain systems introduce additional mechanisms on top of
incentives, frequently with only rudimentary game theoretic analysis. These include: i) rewards
for “uncle blocks” (Ethereum); ii) stake delegation (EOS, Polkadot, Cardano [49]), where users
assign their participation rights to delegates or stake pools; iii) penalties for misbehavior, also
referred to as “slashing” (Ethereum 2.0 [11, 13]). Unfortunately, the lack of thorough analysis
of these mechanisms is, naturally, a serious impediment to wider adoption. For instance, in
the case of penalties employing multiple replicas for redundancy, i.e., to increase crash-fault
tolerance, may produce conﬂicting blocks due to a faulty conﬁguration, if two replicas come alive
simultaneously. However, if a party employs no failover mechanism and experiences network
connectivity issues, it may fail to participate. Furthermore, software or hardware bugs can
always compromise an – otherwise safe and secure – conﬁguration. This highlights the ﬂip side
of such penalty mechanisms: participants may choose to not engage, (e.g., to avoid the risk of
forfeiting funds, or because they do not own suﬃcient funds to make a deposit), or, if they do
engage, they may steer clear of fault-tolerant sysadmin practices, which could pose quality of
service concerns and hurt the system in the long run.

The above considerations put forth the fundamental question that motivates our work: How
eﬀective are blockchain protocol designs in disincentivizing particularly adverse protocol infrac-
tions? In more detail, the question we ask is whether selﬁsh behavior can lead to speciﬁc types
of deviations, taking a blockchain protocol as the initial point of reference of honest — compliant
— behavior.

Our Contributions and Roadmap. Our main question relates to the Nash dynamics of
blockchain protocols.
In the classical Nash dynamics problem [83], the question is whether
allowing selﬁsh players to perform step-wise payoﬀ-improving moves leads the system to an
equilibrium, and in how many steps this may happen; e.g., [30] considers the case of congestion
games. In this perspective, the action space can be seen as a directed graph, where vertices
represent vectors of player strategies and edges correspond to player moves. Notably, deciding
whether the Nash dynamics converge to a (Nash or sink) equilibrium is particularly diﬃcult,
often being a NP-hard or PSPACE-complete problem [71].

This work adapts Nash dynamics to the setting of blockchain protocols, with a particular
focus on studying speciﬁc undesirable protocol infractions. Importantly, instead of asking for
convergence, we ask whether the “cone” in the directed graph positioned at the protocol contains
strategies from a given infraction set X (Figure 1). If the cone is free of infractions, the protocol
is deemed X -compliant. In turn, we also consider (cid:15)-Nash-dynamics [17], i.e., considering only
steps in the graph which represent best responses and improve the participant’s payoﬀ more
than (cid:15). Armed with this model, we investigate various protocols from a compliance perspective.
A core motivation of our work is that X -compliance enables to validate the incentive structure
of a blockchain protocol w.r.t. speciﬁc disruptive behaviors (as captured by X ), while abstracting

2

Figure 1:
protocol which is an approximate Nash equilibrium (ii).

Illustration of a compliant protocol that does not exhibit an equilibrium (i), vs a

away any deviations that avoid the infractions. In this sense, X -compliance of a protocol is a
weaker notion compared to a Nash equilibrium, allowing a variety of possible protocol deviations
as long as they do not fall into X . This also enables a two-tiered analysis where compliance
analysis rules out crucial deviations, while the set of all compliant behaviors can be analyzed
in, say, worst-case fashion. Moreover, negative results in terms of compliance are immediately
informative as they identify one or more speciﬁc infractions. This is helpful from the point of view
of mechanism parameterisation for blockchain protocols, where various penalties (e.g., reward
reduction or slashing of funds) are typically employed to mitigate speciﬁc deviant behaviors. So
far, there exists no framework that enables a formal argument as to whether a speciﬁc penalty is
suﬃcient to mitigate a certain behavior. Our work provides such framework and we illustrate its
applicability in this setting, by analyzing an array of Nakamoto longest chain protocol families.
In detail, our paper is organized as follows. Section 2 describes our model of compliant
strategies and protocols. A strategy is compliant if a party that employs it never violates a
predicate X , which captures well-deﬁned types of deviant behavior. Accordingly, a protocol
is compliant if, assuming a starting point where no party deviates, no party will eventually
employ a non-compliant strategy, assuming sequential unilateral defections. Section 3 speciﬁes
compliance for blockchain protocols, under an infraction predicate that captures abstaining
and producing conﬂicting blocks, and two types of utility, absolute rewards and proﬁt. We
then explore diﬀerent reward schemes and protocol families. Section 4 shows that resource-
proportional rewards, i.e., which depend only on a party’s mining or staking power, result in
rewards alone (i.e., when costs are negligible), but non-compliance w.r.t.
compliance w.r.t.
proﬁt (rewards minus costs). Next, we explore block-proportional rewards, using as baseline
the total blocks adopted by an impartial observer of the system. Section 5.1 shows that PoW
systems are compliant w.r.t. rewards alone. Section 5.2.1 shows that PoS systems, which enforce
that a single party participates at a time, are compliant, under a synchronous network, but non-
compliant under a lossy network (contrary to PoW). Section 5.2.2 shows that PoS systems, which
allow multiple parties to produce blocks for the same time slot, are not compliant. Notably,
our negative results show that a party can gain a non-negligible reward by being non-compliant
under a certain network routing assumption, in this way also highlighting the way the network
interacts with protocol incentives. Section 6 highlights the distinction between compliance and
Nash equilibria, by showcasing a protocol under two types of rewards that, in both cases, is
compliant w.r.t. an infraction predicate that captures realistic deviations and non-compliant
w.r.t. another realistic predicate (and hence, not a Nash equilibrium). Finally, we evaluate
compliance under various externalities, speciﬁcally the varying exchange rate of the platform’s
underlying token, which models real-world prices, and external rewards, which come as a result
of successful attacks. We show that applying a penalty would be necessary if a certain deviant
behavior is synergistic to mounting the attacks, and we provide estimations for such penalties
w.r.t. the ledger’s parameters and the market’s expected behavior.

3

2 Compliance Model

We assume a distributed protocol Π, which is executed by a set of parties P over a number of
time slots. Every party P ∈ P is activated on each time slot, following a schedule set by an
environment Z, which also provides the parties with inputs. Each party P ∈ P is associated
with a number µP ∈ [0, 1]. µP identiﬁes P’s percentage of participation power in the protocol,
e.g., its votes, hashing power, staking power, etc; consequently, (cid:80)
P∈P µP = 1. κ denotes Π’s
security parameter, negl(·) denotes that a function is negligible, i.e., asymptotically smaller than
the inverse of any polynomial, [n] denotes the set {1, . . . , n}, and E[X] denotes the expectation
of random variable X.

2.1 Preliminaries

We assume a peer-to-peer network, i.e., parties do not communicate via point-to-point connec-
tions. Instead, they use the following variant of a diﬀuse functionality (cf. [39]).

Router. We consider a special party called router A. On each time slot, A retrieves all created
In essence, A models the underlying
messages and decides their order and time of delivery.
communication network.
In this work, we consider the following three routers, which are of
interest: i) synchronous: all messages are delivered at the end of the round during which they
were created; ii) lossy: a message is omitted by A, i.e., it is never delivered to any recipient,
with probability d;1 iii) uniform: the order of message delivery is uniformly randomized.

Diﬀuse Functionality. The functionality, parameterized by a router A, initializes a variable
slot to 1, which is readable from all parties. In addition, it maintains a string ReceiveP () for
each party P. Each party P is allowed to fetch the contents of ReceiveP () at the beginning of
each time slot. To diﬀuse a (possibly empty) message m, P sends to the functionality m, which
records it. On each slot, every party completes its activity by sending a special Complete
message to the functionality. When all parties submit Complete, the functionality delivers
the messages, which are diﬀused during this slot, as follows. First, it sends all messages to
A. Following, A responds with a list of tuples (cid:104)P, lP (cid:105), where P ∈ P and lP is an ordered list
of messages. Subsequently, the functionality includes all messages in lP , following its speciﬁed
order, in the ReceiveP () string of P. Hence, the received messages contain no information on
each message’s creator. Finally, the functionality increases the value of slot by 1.

Approximate Nash Equilibrium. An approximate Nash equilibrium is a common tool for
expressing a solution to a non-cooperative game involving n parties P1, . . . , Pn. Each party Pi
employs a strategy Si. The strategy is a set of rules and actions the party makes, depending on
what has happened up to any point in the game, i.e., it deﬁnes the part of the entire distributed
protocol Π performed by Pi. There exists an “honest” strategy, deﬁned by Π, which parties may
employ; for ease of notation, Π denotes both the distributed protocol and the honest strategy.
A strategy proﬁle is a vector of all players’ strategies. Each party Pi has a game utility Ui,
which is a real function that takes as input a strategy proﬁle. A strategy proﬁle is an (cid:15)-Nash
equilibrium when no party can increase its utility more than (cid:15) by unilaterally changing its
strategy (Deﬁnition 1).

Deﬁnition 1. Let:
may employ; iii) σ∗ = (S∗
Pi; iv) S∗
an (cid:15)-Nash equilibrium w.r.t. a utility vector ¯U = (cid:104)U1, . . . , Un(cid:105) if: ∀Pi ∈ P ∀Si ∈ S \ {S∗
Ui(S∗

i) (cid:15) be a non-negative real number; ii) S be the set of strategies a party
is the strategy followed by
−i denote the n − 1 strategies employed by all parties except Pi. We say that σ∗ is
i } :

−i) be a strategy proﬁle of P, where S∗
i

−i) ≥ Ui(Si, S∗

−i) − (cid:15).

i , S∗

i , S∗

1This router aims to model the setting where a network with stochastic delays is used by an application, where
users reject messages delivered with delay above a (protocol-speciﬁc) limit. For example, various protocols, like
Bitcoin [73], resolve message conﬂicts based on the order of delivery; thus, delaying a message for long enough,
such that a competing message is delivered beforehand, is equivalent to dropping the message altogether.

4

For simplicity, when all parties have the same utility U , we say that the proﬁle σ∗ is an
(cid:15)-Nash equilibrium w.r.t. U . We also say that Π is an (cid:15)-Nash equilibrium w.r.t. U when
the strategy proﬁle σΠ = (cid:104)Π, . . . , Π(cid:105) where all parties follow the honest strategy is an (cid:15)-Nash
equilibrium w.r.t. U .

2.2 Basic Notions

A protocol’s execution EZ,A,σ,r until a given time slot r is probabilistic and parameterized by:
i) the environment Z; ii) a router A; iii) the strategy proﬁle σ of the participating parties.
As discussed, Z provides the parties with inputs and schedules their activation. For notation
simplicity, when r is omitted, EZ,A,σ refers to the end of the execution, which occurs after
polynomially many time slots.

An execution trace (cid:61)Z,A,σ,r until a time slot r is the value that the random variable EZ,A,σ,r
takes for a ﬁxed environment Z, router A, and strategy proﬁle σ, and for ﬁxed random coins
of Z, each party P ∈ P, and every protocol-speciﬁc oracle (see below). A party P’s view of an
execution trace (cid:61)P
Z,A,σ,r consists of the messages that P has sent and received until slot r. For
notation simplicity, we omit the subscripts {Z, A, σ, r} from both E and (cid:61), unless required for
clarity.

The protocol Π deﬁnes two components, which are related to our analysis: (1) the oracle

OΠ, and (2) the “infraction” predicate X . We present them below.

The Oracle OΠ. The oracle OΠ provides the parties with the core functionality needed to
participate in Π. For example, in a Proof-of-Work (PoW) system, OΠ is the random or hashing
oracle, whereas in an authenticated Byzantine Agreement protocol, OΠ is a signing oracle. On
each time slot, a party can perform at most a polynomial number of queries to OΠ; in the
simplest case, each party can submit a single query per slot. Finally, OΠ is stateless, i.e., its
random coins are decided upon the beginning of the execution and its responses do not depend
on the order of the queries.

The Infraction Predicate X . The infraction predicate X abstracts the deviant behavior
that the analysis aims to capture. Given the execution trace and a party P, X responds with 1
only if P deviates from the protocol in some well-deﬁned manner. Deﬁnition 2 provides the core
generic property of X , i.e., that honest parties never deviate. With hindsight, our analysis will
focus on infraction predicates that capture either producing conﬂicting messages or abstaining.

Deﬁnition 2 (Infraction Predicate Property). The infraction predicate X has the property that,
for every execution trace (cid:61) and for every party P ∈ P, if P employs the (honest) strategy Π
then X ((cid:61), P) = 0.

We stress that Deﬁnition 2 implies that X being 0 is a necessary but not suﬃcient condition
for honesty. Speciﬁcally, for all honest parties X is always 0, but X might also be 0 for a party
that deviates from Π, in a way not captured by X . In that case, we say that the party employs
an X −compliant strategy (Deﬁnition 3). A strategy proﬁle is X −compliant if all its strategies
are X −compliant, so the “all honest” proﬁle σΠ, where all parties employ Π, is X −compliant.

Deﬁnition 3 (Compliant Strategy). Let X be an infraction predicate. A strategy S is X -
compliant if and only if X ((cid:61), P) = 0 for every party P and for every trace (cid:61) where P employs
S.

The observer Ω. We assume a special party Ω, the (passive) observer. This party does
not actively participate in the execution, but it runs Π and observes the protocol’s execution.
Notably, Ω is always online, i.e., it bootstraps at the beginning of the execution and is activated
on every slot, in order to receive diﬀused messages. Therefore, the observer models a user of the
system, who frequently uses the system but does not actively participate in its maintenance.
Additionally, at the last round of the execution, the environment Z activates only Ω, in order
to receive the diﬀused messages of the penultimate round and have a complete point of view.

5

2.3 Compliant Protocols

To deﬁne the notion of an ((cid:15), X )-compliant protocol Π, we require two parameters: (i) the
associated infraction predicate X and (ii) a non-negative real number (cid:15). Following Deﬁnition 3,
X determines the set of compliant strategies that the parties may follow in Π. Intuitively, (cid:15)
speciﬁes the suﬃcient gain threshold after which a party switches strategies. In particular, (cid:15) is
used to deﬁne when a strategy proﬁle σ(cid:48) is directly reachable from a strategy proﬁle σ, in the
sense that σ(cid:48) results from the unilateral deviation of a party Pi from σ and, by this deviation,
the utility of Pi increases more than (cid:15) while σ(cid:48) sets a best response for Pi. Generally, σ(cid:48) is
reachable from σ, if σ(cid:48) results from a “path” of strategy proﬁles, starting from σ, which are
sequentially related via direct reachability. Finally, we deﬁne the cone of a proﬁle σ as the set
of all strategies that are reachable from σ, including σ itself.

Given the above deﬁnitions, we say that Π is ((cid:15), X )-compliant if the cone of the “all honest”
strategy proﬁle σΠ contains only proﬁles that consist of X −compliant strategies. Thus, if a
protocol is compliant, then the parties may (unilaterally) deviate from the honest strategy only
in a compliant manner, as dictated by X . Formally, ﬁrst we deﬁne “reachability” between two
strategy proﬁles, as well as the notion of a “cone” of a strategy proﬁle w.r.t. the reachability
relation. Then, we deﬁne a compliant protocol w.r.t. its associated infraction predicate.

Deﬁnition 4. Let:
i) (cid:15) be a non-negative real number; ii) Π be a protocol run by parties
P1, . . . , Pn; iii) ¯U = (cid:104)U1, . . . , Un(cid:105) be a utility vector, where Ui is the utility of Pi; iv) S be the
set of all strategies a party may employ. We provide the following deﬁnitions.

1. Let σ, σ(cid:48) ∈ Sn be two strategy proﬁles where σ = (cid:104)S1, . . . , Sn(cid:105) and σ(cid:48) = (cid:104)S(cid:48)

n(cid:105).
We say that σ(cid:48) is directly (cid:15)-reachable from σ w.r.t. ¯U , if there exists i ∈ [n] s.t. (i)
j = Sj, (ii) Ui(σ(cid:48)) > Ui(σ) + (cid:15), and (iii) for every strategy proﬁle
∀j ∈ [n] \ {i} : S(cid:48)
σ(cid:48)(cid:48) = (cid:104)S(cid:48)(cid:48)
j = Sj, it holds that Ui(σ(cid:48)(cid:48)) ≤ Ui(σ(cid:48)). (i.e., σ(cid:48) sets
1 , . . . , S(cid:48)(cid:48)
a best response for Pi)

n(cid:105) s.t. ∀j ∈ [n] \ {i} : S(cid:48)(cid:48)

1, . . . , S(cid:48)

2. Let σ, σ(cid:48) ∈ Sn be two distinct strategy proﬁles. We say that σ(cid:48) is (cid:15)-reachable from σ w.r.t.
¯U , if there exist proﬁles σ1, . . . , σk such that (i) σ1 = σ, (ii) σk = σ(cid:48), and (iii) ∀j ∈ [2, k]
it holds that σj is directly (cid:15)-reachable from σj−1 w.r.t. ¯U .

3. For every strategy proﬁle σ ∈ Sn we deﬁne the ((cid:15), ¯U )-cone of σ as the set: Cone(cid:15), ¯U (σ) :=

{σ(cid:48) ∈ Sn | (σ(cid:48) = σ) ∨ (σ(cid:48) is (cid:15)-reachable from σ w.r.t. ¯U )}.

Deﬁnition 5. Let: i) (cid:15) be a non-negative real number; ii) Π be a protocol run by the parties
P1, . . . , Pn; iii) X be an infraction predicate; iv) ¯U = (cid:104)U1, . . . , Un(cid:105) be a utility vector, where Ui
is the utility of party Pi; v) S be the set of all strategies a party may employ; vi) SX be the set
of X −compliant strategies.

A strategy proﬁle σ ∈ Sn is X −compliant if σ ∈ (SX )n.
The ((cid:15), ¯U )-cone of Π, denoted by Cone(cid:15), ¯U (Π), is the set Cone(cid:15), ¯U (σΠ), i.e., the set of all
strategies that are (cid:15)-reachable from the “all honest” strategy proﬁle σΠ = (cid:104)Π, . . . , Π(cid:105) w.r.t. ¯U ,
including σΠ.

Π is ((cid:15), X )-compliant w.r.t. ¯U if Cone(cid:15), ¯U (Π) ⊆ (SX )n, i.e., all strategy proﬁles in the ((cid:15), ¯U )-

cone of Π are X −compliant.

2.4 Compliance and Approximate Nash Equilibria

In this subsection, we show that a protocol is an (cid:15)-Nash equilibrium w.r.t. some utility if and
only if it is ((cid:15), X )-compliant w.r.t. the same utility, for any associated infraction predicate X .
We begin by proving a useful lemma stating that a protocol is an approximate Nash equilibrium
if and only if the cone of the protocol includes only the all-honest strategy proﬁle.

Lemma 1. Let:
i) (cid:15) be a non-negative real number; ii) Π be a protocol run by the parties
P1, . . . , Pn; iii) ¯U = (cid:104)U1, . . . , Un(cid:105) be a utility vector, with Ui the utility of Pi. Then, Π is an
(cid:15)-Nash equilibrium w.r.t. ¯U (i.e., σΠ = (cid:104)Π, . . . , Π(cid:105) is an (cid:15)-Nash equilibrium w.r.t. ¯U ) if and
only if the ((cid:15), ¯U )-cone of Π, Cone(cid:15), ¯U (Π), is the singleton {σΠ}.

6

Proof. (⇒): Assume that σΠ is an (cid:15)-Nash equilibrium w.r.t. ¯U and let σ = (cid:104)S1, . . . , Sn(cid:105) (cid:54)= σΠ
be a strategy proﬁle s.t. there exists i ∈ [n] s.t. ∀j ∈ [n] \ {i} : Sj = Π. We will show that
σ is not directly (cid:15)-reachable from σΠ w.r.t. ¯U . Since σΠ is an (cid:15)-Nash equilibrium w.r.t. ¯U ,
it holds that Ui(σ) ≤ Ui(σΠ) + (cid:15). Therefore, Deﬁnition 4 is not satisﬁed and σ is not directly
(cid:15)-reachable from σΠ w.r.t. ¯U . Since no strategy proﬁles are directly (cid:15)-reachable from σΠ w.r.t.
¯U , it is straightforward that there are no (cid:15)-reachable strategy proﬁles from σΠ w.r.t. ¯U . The
latter implies that the ((cid:15), ¯U )-cone of Π contains only σΠ, i.e., Cone(cid:15), ¯U (Π) = {σΠ}.

(⇐): Assume that σΠ is not an (cid:15)-Nash equilibrium w.r.t. ¯U . This means that there exists
a strategy proﬁle σ∗ = (cid:104)S∗
j = Π and
it holds that Ui(σ∗) > Ui(σΠ) + (cid:15). Among all unilateral deviations of Pi, consider the strategy
proﬁle σ∗∗ that sets the best response for Pi (that may not necessarily be σ∗). We directly get
that Ui(σ∗∗) ≥ Ui(σ∗) > Ui(σΠ) + (cid:15). Thus, by Deﬁnition 4, σ∗∗ is (directly) (cid:15)-reachable from
σΠ w.r.t. ¯U , i.e. σ∗∗ ∈ Cone(cid:15), ¯U (Π), which implies that {σΠ} (cid:40) Cone(cid:15), ¯U (Π).

n(cid:105) s.t. there exists i ∈ [n] s.t. ∀j ∈ [n] \ {i} : S∗

1 , . . . , S∗

The statement in Lemma 1 resembles the well-known statement that a pure Nash equilibrium
is a sink equilibrium that contains a single strategy proﬁle [44]. Nonetheless, there are diﬀerences
between the notions of a sink equilibrium and a cone. Recall that a sink equilibrium is a strongly
connected component of the strategy proﬁle graph that has no outgoing edges. On the other
hand, according to Deﬁnition 4, the subgraph induced by the nodes of a cone of a strategy
proﬁle σ may not even be strongly connected (e.g., the cone could be a subtree rooted at σ).

By applying Lemma 1, we prove the main result of this subsection.

Theorem 1. Let:
i) (cid:15) be a non-negative real number; ii) Π be a protocol run by the parties
P1, . . . , Pn; iii) ¯U = (cid:104)U1, . . . , Un(cid:105) be a utility vector, with Ui the utility of Pi. Then, Π is an
(cid:15)-Nash equilibrium w.r.t. ¯U if and only if Π is ((cid:15), X )-compliant w.r.t. ¯U for any associated
infraction predicate X .

Proof. (⇒): Assume that σΠ is an (cid:15)-Nash equilibrium w.r.t. ¯U . By Lemma 1, we have that
Cone(cid:15), ¯U (Π) = {σΠ}. By Deﬁnitions 2 and 3, we have that for every infraction predicate X σΠ
is X −compliant, so we deduce that Cone(cid:15), ¯U (Π) = {σΠ} ⊆ (SX )n, i.e., the protocol Π is ((cid:15), X )-
compliant w.r.t. ¯U .
(⇐): Assume that Π is ((cid:15), X )-compliant w.r.t. ¯U for every associated infraction predicate X .
We deﬁne the “all honest” infraction predicate, Xhon as follows: for every party P and every
trace (cid:61),

Xhon((cid:61), P) :=

(cid:26) 0,

if P follows Π in (cid:61)

1, otherwise

.

Clearly, Xhon satisﬁes Deﬁnition 2, i.e., it is indeed an infraction predicate. By the deﬁnition
of Xhon, for every strategy S (cid:54)= Π, it holds that Xhon((cid:61), P) = 1 for every party P and every
trace (cid:61) where P follows S in (cid:61). The latter implies that for every strategy S (cid:54)= Π it holds that
S /∈ SXhon (i.e., S is not Xhon-compliant), which in turn implies that for every strategy proﬁle
σ (cid:54)= σΠ = (cid:104)Π, . . . , Π(cid:105) it holds that σ /∈ (SXhon)n. On the other hand, it is straightforward that
σΠ ∈ (SXhon)n.

By the above, we have that (SXhon)n = {σΠ}. By assumption, we have that Π is ((cid:15), Xhon)-
compliant w.r.t. ¯U , i.e. Cone(cid:15), ¯U (Π) ⊆ (SXhon)n = {σΠ}. Besides, by Deﬁnition 4, we know that
{σΠ} ⊆ Cone(cid:15), ¯U (Π), thus Cone(cid:15), ¯U (Π) = {σΠ}. By Lemma 1, we conclude that Π is an (cid:15)-Nash
equilibrium w.r.t. ¯U .

According to the equivalence proven in Theorem 1, the property that “a protocol is an
approximate Nash equilibrium” can be interpreted as a composition of all possible statements
that “it is not in any party’s interest to be non-compliant”, however compliance is speciﬁed by
the associated infraction predicate.

7

Remark.
It is easy to see that X -compliance is a strict relaxation of the approximate Nash
equilibrium notion. For example, consider a protocol Π∗ that is not an (cid:15)∗-Nash equilibrium w.r.t.
some utility ¯U ∗ (cf. Theorem 3 for such a counterexample). Now set X ∗ to be the predicate
that always returns 0. Clearly, by Deﬁnitions 3 and 5, the protocol Π∗ is ((cid:15)∗, X ∗)-compliant
w.r.t. ¯U ∗.

3 Blockchain Protocols

In this work, we focus on blockchain-based distributed ledger protocols. In the general case, a
ledger deﬁnes a global state, which is distributed across multiple parties and is maintained via
a consensus protocol. The distributed ledger protocol deﬁnes the validity rules which allow a
party to extract the ﬁnal ledger from its view. A blockchain is a distributed database, where
each message m is a block B of transactions and each transaction updates the system’s global
state. Therefore, at any point of the execution, a party P holds some view of the global state,
which comprises of the blocks that P has adopted. We note that, if at least one valid block is
diﬀused (w.r.t. the validity rules of the protocol), then every honest party can extract a ﬁnal
ledger from its execution view.

3.1 The Setting

Every blockchain protocol Π deﬁnes a message validity predicate V. Party P accepts block B,
received during a time slot r, if V((cid:61)P
r , B) = 1. For example, in Proof-of-WorK (PoW) systems
like Bitcoin, a block is valid if its hash is below a certain threshold; in Proof-of-Stake (PoS)
protocols like Ouroboros [54], a block is valid if it was created by a speciﬁc party, given a known
leader schedule. In all cases, B is valid if its creator submits at least one query for B to OΠ.

Each block B is associated with the following metadata: i) an index index (B); ii) the party
iii) a set ancestors(B) ⊆ (cid:61)creator (B), i.e., blocks in the view of
creator (B) that created B;
creator (B) (at the time of B’s creation) referenced by B. Message references are implemented
as hash pointers, given a hash function H employed by the protocol. Speciﬁcally, each block
B contains the hash of all blocks in the referenced blocks ancestors(B). Blockchain systems
are typically bootstrapped via a global common reference string, i.e., a “genesis” block BG.
Therefore, the blocks form a hash tree, stemming from BG and index (B) is the height of B in
the hash tree. If B references multiple messages, i.e., belongs to multiple tree branches, index (B)
is the height of the longest one.

The protocol also deﬁnes the message equivalency operator, ≡. Speciﬁcally, two messages
are equivalent if their hashes match, i.e., m1 ≡ m2 ⇔ H(m1) = H(m2). At a high level, two
equivalent messages are interchangeable by the protocol.

In our analysis of blockchain systems, we will consider two types of
Infraction Predicate.
deviant behavior (Deﬁnition 6): i) creating conﬂicting valid messages of same origin, and ii) ab-
staining. We choose these predicates because they may lead to non-compliance in interesting use
cases. The former refers to the widely discussed topic in blockchain systems of one participant
extending two conﬂicting transaction histories. The latter deals with the issue of participants
who intermittently engage in the system’s maintenance, thus potentially hurting the safety of
the deployed system; in particular, the more users participate in maintenance, the higher the
level of resources that an adversary needs to reach to break a system’s security. Other infraction
predicates are of course also possible to deﬁne — see Section 8.

Deﬁnition 6 (Blockchain Infraction Predicate). Given a party P and an execution trace (cid:61), we
deﬁne the following infraction predicates:

1. conﬂicting predicate: Xconf ((cid:61), P) = 1 if there exist blocks B, B(cid:48) ∈ (cid:61) such that creator (B) =

creator (B(cid:48)) = P ∧ V((cid:61)P , B) = V((cid:61)P , B(cid:48)) = 1 ∧ index (B) = index (B(cid:48)) ∧ B (cid:54)≡ B(cid:48);

2. abstaining predicate: Xabs((cid:61), P) = 1 if there exists a time slot r such that P makes no

queries to oracle OΠ during r;

8

3. blockchain predicate: Xbc((cid:61), P) = 1 if (Xconf ((cid:61), P) = 1) ∨ (Xabs((cid:61), P) = 1).

We note that preventing conﬂicting messages is not the same as resilience against Sybil
attacks [24]. The latter restricts an attacker from creating multiple identities.
Instead, our
infraction predicate ensures that a user does not increase their utility by creating conﬂicting
messages with one of its identities. Thus, a system may be compliant but not Sybil resilient,
e.g., if a party participates via multiple identities without increasing its utility via conﬂicting
messages.

Finally, at the end of the execution, the observer Ω outputs a chain CΩ,(cid:61). Typically, this
is the longest valid chain, i.e., the longest branch of the tree that stems from genesis BG.2 In
case multiple longest chains exist, a choice is made either at random or following a chronological
ordering of messages. The number of messages in CΩ,(cid:61) that are created by a party P is denoted
by MP,(cid:61).

3.2 Utility: Rewards and Costs

For each execution, the blockchain protocol deﬁnes a number of total rewards, which are dis-
tributed among the participating parties. For each party P, these rewards are expressed via
the reward random variable RP,EZ,A,σ . For a speciﬁc trace (cid:61)Z,A,σ, the random variable takes
a non-negative real value, denoted by RP,(cid:61)Z,A,σ . Intuitively, RP,(cid:61)Z,A,σ describes the rewards
that P receives from the protocol from the point of view of the observer Ω, i.e., w.r.t. the blocks
output by Ω at the end of the execution.

Our analysis is restricted to systems where rewards are distributed to parties if and only if
the genesis block is extended by at least one block during the execution, in which case at least
one party receives a non-negative amount of rewards (Assumption 1).

Assumption 1. Let (cid:61) be an execution trace. If no block is produced during (cid:61), then it holds
that ∀P ∈ P : RP,(cid:61) = 0. If at least one block is produced during (cid:61), then it holds that ∃P ∈ P :
RP,(cid:61) (cid:54)= 0.

In addition to rewards, a party’s utility is aﬀected by cost. Speciﬁcally, the cost random
variable CP,EZ,A,σ expresses the operational cost of P during an execution EZ,A,σ. For a ﬁxed
trace (cid:61)Z,A,σ, CP,(cid:61)Z,A,σ is a non-negative real value. Our analysis is restricted to cost schemes
which are linearly monotonically increasing in the number of queries that a party makes to the
oracle OΠ, with no queries incurring zero cost (Assumption 2).
Intuitively, this assumption
considers the electricity cost of participation, while the cost of equipment and other operations,
such as parsing or publishing messages, is zero.

Assumption 2. For every execution trace (cid:61), a party P’s cost is CP,(cid:61) = 0 if and only if it
performs no queries to OΠ in every time slot. Else, if during (cid:61) a party P performs t queries,
then its cost is CP,(cid:61) = t · λ, for some ﬁxed parameter λ.

We deﬁne two types of utility. First is Reward, i.e., the expected rewards that a party receives

when the cost is 0. Second is Proﬁt, i.e., rewards minus participation cost.

Deﬁnition 7. Let σ be a strategy proﬁle and EZ,A,σ be an execution during which parties follow
σ. We deﬁne two types of blockchain utility UP of a party P for σ:

1. Reward: UP (σ) = E[RP,EZ,A,σ ]

2. Proﬁt: UP (σ) = E[RP,EZ,A,σ ] − E[CP,EZ,A,σ ]
For the computation of UP , the environment Z and the router A are ﬁxed. Therefore, the
expectation of the random variables RP,EZ,A,σ and CP,EZ,A,σ is computed over the random coins
of Z, A, OΠ, and every party P ∈ P. Intuitively, a party’s utility depends on both their strategy
choice and the underlying network (expressed via the router). As such, diﬀerent routers may
yield diﬀerent optimal strategies for parties to employ and possibly diﬀerent equilibria ceteris
paribus. Following, we evaluate the compliance of various Proof-of-Work (PoW) and Proof-
of-Stake (PoS) blockchain protocols w.r.t.
two types of rewards, resource-proportional and
block-proportional.

2We assume that the longest chain (in blocks) contains the most hashing power, which is the metric used in

PoW systems.

9

4 Resource-Proportional Rewards

As described in Section 2, a party P controls a percentage µP of the system’s participating
power. Although this is set at the beginning of the execution, it is not always public. For
instance, P could obscure its amount of hashing power by refraining from performing some
queries. In some cases, each party’s power is published on the ledger and, for all executions, can
be extracted from the observer’s chain. This is the case in non-anonymous PoS ledgers, where
each party’s power, denoted by its assets, is logged in real time on the ledger.

These systems, where power distribution is public, can employ a special type of rewards,
resource-proportional rewards. Speciﬁcally, the system deﬁnes a ﬁxed, total number of rewards
R > 0. At the end of an execution, if at least one block is created, each party P receives a
percentage ξ(µP ) of R, where ξ(·) : [0, 1] → [0, 1]; in the real world, ξ is usually the identity
function. If no blocks are created during the execution, then every party gets 0 rewards.

Intuitively, resource-proportional rewards (Deﬁnition 8) compensate users for investing in the
system. Unless no block is created (which typically happens with negligible probability when
the parties follow the protocol), the reward level depends solely on a party’s power, instead of
the messages diﬀused in the execution.

Deﬁnition 8 (Resource-proportional Rewards). For a total number of rewards R ∈ R>0 and
ξ : [0, 1] → [0, 1] such that (cid:80)
P∈P ξ(µP ) = 1, a resource-proportional reward random variable
RP,E satisﬁes the following:

∀(cid:61) ∀P ∈ P : RP,(cid:61) =

(cid:26) ξ(µP ) · R,

0,

if there is at least one valid block in (cid:61)
otherwise

As shown in Theorem 2, blockchains with resource-proportional rewards are (cid:15)-Nash equilibria
w.r.t. utility Reward (Deﬁnition 7), with (cid:15) typically small. By Theorem 1, the latter implies
that such protocols are also ((cid:15), X )-compliant w.r.t. the same utility, where X is an arbitrary
associated infraction predicate. Intuitively, a party is rewarded the same amount regardless of
their protocol-related actions, so nobody can increase their rewards by deviating from the honest
strategy.

Theorem 2. Let:
i) Π be a blockchain protocol run by the parties P1, . . . , Pn; ii) A be a
synchronous router (cf. Section 2.1); iii) ¯U = (cid:104)U1, . . . , Un(cid:105) be a utility vector, where Ui is
the utility Reward of party Pi; iv) R be the total rewards distributed by the protocol; v) ξ :
[0, 1] → [0, 1] be a resource-proportional reward function; vi) α be the probability that no blocks
are produced when all parties follow the honest strategy. Then, Π is an (cid:15)-Nash equilibrium w.r.t.
¯U , for (cid:15) := α · max
j∈[n]

{ξ(µPj ) · R}.

Proof. By Deﬁnition 8 and the deﬁnition of α, for the “all honest” strategy proﬁle σΠ :=
(cid:104)Π, . . . , Π(cid:105), we have that Pr[RPi,EσΠ
= 0] = α, for every
i ∈ [n]. Therefore, for every i ∈ [n], Ui(σΠ) = E(cid:2)RPi,EσP

= ξ(µPi) · R] = 1 − α and Pr[RPi,EσΠ

(cid:3) = (1 − α) · ξ(µPi) · R.

Assume that for some i ∈ [n], Pi unilaterally deviates from Π by employing a diﬀerent
strategy Si. In this case, we consider the strategy proﬁle σ = (cid:104)S1, . . . , Sn(cid:105) where Sj = Π for
j ∈ [n] \ {i}. Since Ui is the utility Reward under fair rewards with R, ξ(·), we have that for all
random coins of the execution Eσ, the value of the reward random variable RPi,Eσ is no more
than ξ(µPi) · R. Consequently, Ui(σ) ≤ ξ(µPi) · R, and so we have that

Ui(σ) ≤ Ui(σΠ) + α · ξ(µPi) · R ≤ Ui(σΠ) + α · max
j∈[n]

{ξ(µPj ) · R} .

If (cid:15) := α · max
j∈[n]

{ξ(µPj ) · R} and since i and Si are arbitrary, we conclude that Π is an (cid:15)-Nash

equilibrium w.r.t. ¯U .

Theorem 2 is consistent with the incentives’ analysis of [54] under resource-proportional
rewards. However, when introducing operational costs to analyze proﬁt, a problem arises: a
user can simply abstain and be rewarded nonetheless. Such behavior results in a “free-rider
problem” [7], where a user reaps some beneﬁts while not under-paying them or not paying at

10

all. Theorem 3 formalizes this argument and shows that a blockchain protocol, associated with
the abstaining infraction predicate Xabs (cf. Deﬁnition 6), under resource-proportional rewards
is not ((cid:15), Xabs)-compliant w.r.t. utility Proﬁt, for reasonable values of (cid:15).

Theorem 3. Let:
i) Π be a blockchain protocol run by the parties P1, . . . , Pn; ii) A be a
synchronous router (cf. Section 2.1); iii) ¯U = (cid:104)U1, . . . , Un(cid:105) be a utility vector, where Ui is the
utility Proﬁt of party Pi; iv) R be the total rewards distributed by the protocol; v) ξ : [0, 1] → [0, 1]
be a resource-proportional reward function; vi) α be the probability that no blocks are produced
when all parties follow the honest strategy.
i) q be the maximum number of queries that a party can
For i ∈ [n], also let the following:
make to the oracle OΠ in each time slot. ii) C be the cost of a single query to OΠ; iii) Ci be
the expected cost of Pi when Pi employs Π; iv) βi be the probability that no blocks are produced
when Pi abstains throughout the entire execution and all the other parties follow Π.
Assume that for every i ∈ [n], it holds that C > βi · ξ(µPi ) · R · q. Then, for every (cid:15) ≥ 0 s.t.
{Ci − (βi − α) · ξ(µPi) · R}, the protocol Π is not ((cid:15), Xabs)-compliant w.r.t. ¯U .
(cid:15) < max
i∈[n]

= ξ(µPi)·R] = 1−α and Pr[RPi,EσΠ

Proof. By Deﬁnition 8 and the deﬁnition of α, for the “all honest” strategy proﬁle σΠ :=
(cid:104)Π, . . . , Π(cid:105), we have that Pr[RPi,EσΠ
= 0] = α, for every i ∈
[n]. Since Π is an Xabs-compliant strategy, if Pi follows Π then it does not abstain, i.e., it makes
queries to OΠ. Therefore, by Assumption 2, the expected cost of Pi, Ci, is greater than 0 and
(cid:3) = (1−α)·ξ(µPi)·R−Ci.
for σΠ, the utility Proﬁt Ui(σΠ) is: Ui(σΠ) = E(cid:2)RPi,EσΠ
Now assume that Pi unilaterally deviates by following the “always abstain” strategy, Sabs,
which is of course not Xabs-compliant. Then, Pi makes no queries to OΠ and, by Assumption 2,
its cost is 0. Let σi be the strategy proﬁle where Pi follows Sabs and every party P (cid:54)= Pi follows Π.
= 0] = βi.
By the deﬁnition of βi, we have that Pr[RPi,Eσi
(cid:3) = (1 − βi) · ξ(µPi) ·

= ξ(µPi) · R] = 1 − βi and Pr[RPi,Eσi
(cid:3) − E(cid:2)CPi,Eσi

By the deﬁnition of Ui, it holds that: Ui(σi) = E(cid:2)RPi,Eσi
R − 0. So, for (cid:15)i < Ci − (βi − α) · ξ(µPi) · R, we have that:

(cid:3)−E(cid:2)CPi,EσΠ

Ui(σi) = (1 − βi) · ξ(µPi) · R =

= (1 − α) · ξ(µPi) · R + (α − βi) · ξ(µPi) · R ≥
≥ Ui(σΠ) + Ci − (βi − α) · ξ(µPi ) · R >
> Ui(σΠ) + (cid:15)i

Let i∗ ∈ [n] be such that Ci∗ − (βi∗ − α) · ξ(µPi∗ ) · R = max
i∈[n]

{Ci − (βi − α) · ξ(µPi) · R} and

assume that 0 < Ci∗ − (βi∗ − α) · ξ(µPi∗ ) · R. By the above, we have that

Ui∗ (σi∗ ) > Ui∗ (σΠ) + (cid:15), for every 0 ≤ (cid:15) < Ci∗ − (βi∗ − α) · ξ(µPi∗ ) · R .
The following claim will imply that the best response for Pi∗ must be non Xabs-compliant.

(1)

Claim 3.1. Let σ be a Xabs-compliant proﬁle strategy that is a unilateral deviation from σΠ for
Pi∗ . Then, it holds that Ui∗ (σ) < Ui∗ (σi∗ ).

Proof of Claim 3.1. Since σ is Xabs-compliant, it holds that Pi∗ participates in every trace as if
she were honest, with the diﬀerence that she makes at least 1 query, whereas as an honest player
she would make at most q queries per time slot. Therefore, it holds that E[CPi∗ ,Eσ ] ≥ 1
q Ci∗ .
Besides, the rewards of Pi∗ w.r.t. σ are bounded by the maximum value ξ(µPi∗ ) · R. Thus,

Ui∗ (σ) − Ui∗ (σΠ) ≤ (cid:0)ξ(µPi∗ ) · R − E[CPi∗ ,Eσ ](cid:1) − (cid:0)(1 − α) · ξ(µPi∗ ) · R − Ci∗
= α · ξ(µPi∗ ) · R + (cid:0)Ci∗ − E[CPi∗ ,Eσ ](cid:1) ≤
≤ α · ξ(µPi∗ ) · R + (cid:0)1 −

(cid:1) · Ci∗ .

1
q

(cid:1) =

Recall that

Ui∗ (σi∗ ) − Ui∗ (σΠ) = (1 − βi∗ ) · ξ(µPi∗ ) · R − (cid:0)(1 − α) · ξ(µPi∗ ) · R − Ci∗
= (α − βi∗ ) · ξ(µPi∗ ) · R + Ci∗ .

(cid:1) =

11

(2)

(3)

By Eq. (2) and (3) and given that C > βi∗ · ξ(µPi∗ ) · R · q, we have that

Ui∗ (σi∗ ) − Ui∗ (σ) ≥

1
q

· Ci∗ − βi∗ · ξ(µPi∗ ) · R > 0 .

♦

By Claim 3.1, we have that the best response σ∗ for Pi∗ is non Xabs-compliant, as it holds
that Ui∗ (σ∗) ≥ Ui∗ (σi∗ ). In addition, by Eq. (1), we get that for every 0 ≤ (cid:15) < Ci∗ − (βi∗ − α) ·
ξ(µPi∗ ) · R, it holds that Ui∗ (σ∗) > Ui∗ (σσΠ) + (cid:15), therefore σ∗ is directly (cid:15)-reachable from σΠ
w.r.t. ¯U . Thus, σ∗ is a non Xabs-compliant strategy proﬁle that is in Cone(cid:15), ¯U (Π).

{Ci −(βi −α)·ξ(µPi)·R}, it holds that Cone(cid:15), ¯U (Π) (cid:40) (SXabs)n,

Consequently, for 0 ≤ (cid:15) < max
i∈[n]

i.e., the protocol Π is not ((cid:15), Xabs)-compliant w.r.t. ¯U .

Before concluding, let us examine the variables of the bound max
i∈[n]

{Ci − (βi − α) · ξ(µPi ) · R}

of Theorem 3. We note that, in the context of blockchain systems, a “party” is equivalent to a
unit of power; therefore, a party P that controls µP of the total power, in eﬀect controls µP of
all “parties” that participate in the blockchain protocol.

To discuss α and βi, we ﬁrst consider the liveness property [38] of blockchain protocols.
Brieﬂy, if a protocol guarantees liveness with parameter u, then a transaction which is diﬀused
on slot r is part of the (ﬁnalized) ledger of every honest party on round r + u. Therefore,
assuming that the environment gives at least one transaction to the parties, if a protocol Π
guarantees liveness unless with negligible probability negl(κ),3 then at least one block is created
during the execution with overwhelming probability (in κ).

Now, we consider α and βi. The former is negligible, since consensus protocols typically
guarantee liveness against a number of crash (or Byzantine) faults, let alone if all parties are
honest. The latter, however, depends on Pi’s percentage of power µPi . For instance, consider
Ouroboros, which is secure if a deviating party Pi controls less than 1
2 of the staking power and
all others employ Π. Thus, if µPi = 2
3 and Pi abstains, the protocol cannot guarantee liveness,
i.e., it is probable that no blocks are created. However, if µPi = 1
4 , then liveness is guaranteed
with overwhelming probability; hence, even if Pi abstains, at least one block is typically created.
Corollary 1 generalizes this argument, by showing that, if enough parties participate, then at
least one of them is small enough, such that its abstaining does not result in a system halt,
hence it is incentivized to be non-compliant.

Corollary 1. Let Π be a blockchain protocol, with security parameter κ, which is run by n
parties, under the same considerations of Theorem 3. Additionally, assume that Π has liveness
µP < 1
with security threshold 1
x ,

x in the following sense: for every strategy proﬁle σ, if (cid:80)

P∈P−σ

where P−σ is the set of parties that deviate from Π when σ is followed, then Π guarantees
liveness with overwhelming (i.e., 1 − negl(κ)) probability. If x < n, then for (non-negligible)
values (cid:15) < max
i∈[n]

{Ci} − negl(κ), Π is not ((cid:15), Xabs)-compliant w.r.t. ¯U .

Proof. First, since Π guarantees liveness even under some byzantine faults, α = negl(κ).

Second, if x < n, then there exists i ∈ [n] such that µPi < 1
µPi ≥ n

∀j ∈ [n] : µPj ≥ 1
j∈[n]
participating power (cf. Section 2), where it holds that (cid:80)
j∈[n]

x then (cid:80)

µPj = 1.

x . To prove this, if n > x and
x > 1. This contradicts to the deﬁnition of the parties’

Now consider the strategy proﬁle σ where Pi abstains and all the other parties honestly

follow Π. Then, by deﬁnition, P−σ = {Pi} and therefore,

(cid:88)

P∈P−σ

µP = µPi <

1
x

.

3Recall that κ is Π’s security parameter, while negl(·) is a negligible function.

12

Thus, by the assumption for Π, we have that if the parties follow σ, then Π guarantees liveness
with 1 − negl(κ) probability. Hence, βi = negl(κ). Finally, since ξ(µPi) ∈ [0, 1] and R is a ﬁnite
value irrespective of the parties’ strategy proﬁle, the value (βi − α) · ξ(µPi) · R is also negligible
in κ.

The minimal cost C ⊥
Pi

of (honest) participation for party Pi depends on the blockchain
system’s mechanism. In PoW systems, where participation consists of repeatedly performing
computations, cost increases with the percentage of mining power; for instance, controlling
51% of Bitcoin’s mining power for 1 hour costs $1, 700, 000.4 In PoS systems, cost is typically
irrespective of staking power, since participation consists only of monitoring the network and
regularly signing messages; for example, running a production-grade Cardano node costs $180
per month5. Therefore, considering Corollary 1, the upper bound max
{Ci} − negl(κ) of (cid:15) is
i∈[n]

typically rather large for PoS systems.

The free-rider hazard is manifested in Algorand6, a cryptocurrency system that follows the
Algorand consensus protocol [15, 43] and employs resource-proportional rewards, as deﬁned
above. Its users own “Algo” tokens and transact over a ledger maintained by “participation
nodes”, which run the Algorand protocol and extend the ledger via blocks. Each user receives a
ﬁxed reward7 per Algo token they own [35], awarded with every new block. Users may also run
a participation node, but are not rewarded [34] for doing so, and participation is proportional
to the amount of Algos that the user owns. Therefore, a party that owns a few Algos will
expectedly abstain from participation in the consensus protocol.

Remark.
In summary, under resource-proportional rewards in PoS protocols, users may choose
to abstain. This can impact performance, e.g., delaying block production and transaction ﬁnal-
ization while, in the extreme case, it could result in a “tragedy of the commons” situation [64],
where all users abstain and the system grinds to a halt. Interestingly, this section illustrates
a diﬀerence between PoW and PoS. In PoS systems, each party’s power is registered on the
ledger, without requiring any action from them. In PoW, power becomes evident only after the
party puts their hardware to work. Therefore, the idea behind Theorem 3’s proof, which relies
on abstaining, does not necessarily hold in PoW systems, like Fruitchains [81], that deﬁne re-
wards (approximately) proportional to each party’s mining power, as identiﬁed by their hashing
operations.

5 Block-Proportional Rewards

The arguably most common type of rewards in blockchain systems is block-proportional rewards.
Each party is rewarded proportionally to the number of blocks it contributes to the ﬁnal chain,
at the end of the execution. Block-proportional rewards are a generalization of the proportional
allocation rule, which, for example, is employed in Bitcoin. The proportional allocation rule
states that a party P’s expected rewards of a single block are µP . As shown by Chen et al. [16],
this is the unique allocation rule that satisﬁes a list of desirable properties, namely:
i) non-
negativity, ii) budget-balance, iii) symmetry, iv) sybil-proofness, and v) collusion-proofness.

Our work expands the scope by considering proportional rewards w.r.t. blocks for the entirety
of the execution. Speciﬁcally, Deﬁnition 9 describes block-proportional rewards, where a party
P’s rewards are strictly monotonically increasing on the number of blocks that P contributes
to the chain output by the observer Ω. The deﬁnition considers a proportional reward function
(cid:37)(·, ·) that takes as input the chain of Ω and P and outputs a value in [0, 1].

Deﬁnition 9 (Block-Proportional Rewards). For an execution trace (cid:61), let CΩ,(cid:61) be the chain
output by Ω and RΩ,(cid:61) ∈ R≥0 be the total number of rewards which are distributed by the protocol,

4https://www.crypto51.app [February 2022]
5https://forum.cardano.org/t/realistic-cost-to-operate-stake-pool/40056 [January 2022]
6https://algorand.foundation
7The weekly reward per owned Algo is 0.00012 Algos.

[https://algoexplorer.io/rewards-calculator,

February 2022]

13

according to Ω. Let MP,(cid:61) be the number of blocks in the chain output by Ω which are produced
by P. A block-proportional reward random variable RP,E satisﬁes the following conditions:

1. ∀(cid:61) ∀P ∈ P : RP,(cid:61) = (cid:37)(CΩ,(cid:61), P) · RΩ,(cid:61)
2. ∀(cid:61) : (cid:80)

P∈P (cid:37)(CΩ,(cid:61), P) = 1

3. ∀(cid:61) ∀P, P (cid:48) ∈ P : MP,(cid:61) > MP (cid:48),(cid:61) ⇒ (cid:37)(CΩ,(cid:61), P) > (cid:37)(CΩ,(cid:61), P (cid:48))

5.1 Bitcoin

First, we consider the Bitcoin [73] blockchain protocol. Bitcoin is a prime example of a fam-
ily of protocols that links the amount of valid blocks, that each party can produce per ex-
ecution, with the party’s hardware capabilities, including:
i) Proof-of-Work-based protocols
like Ethereum [91], Bitcoin NG [28], Zerocash [8]; ii) Proof-of-Space [25] and Proof-of-Space-
Time [72] protocols like SpaceMint [80], Chia [1, 18].

Execution Details. Typically, protocols from the aforementioned family enforce that, when
all parties follow the protocol honestly, the expected percentage of blocks created by a party P
is µP of the total blocks produced by all parties during the execution. Along the lines of the
formulation in [39, 40], in the Bitcoin protocol, each party P can make at most µP · q queries
to the hashing oracle OΠ per time slot, where q is the total number of queries that all parties
can make to OΠ during a time slot. We note that when P follows the Bitcoin protocol, they
perform exactly µP · q queries to the hashing oracle. Each query can be seen as an independent
block production trial and is successful with probability δ, which is a protocol-speciﬁc “mining
diﬃculty” parameter.

From the point of view of the observer Ω, a party P is rewarded a ﬁxed amount R for each
block they contribute to the chain output by Ω. Then, Bitcoin implements a special case of
block-proportional rewards (cf. Deﬁnition 9), such that:

• The total number of rewards for (cid:61) is RΩ,(cid:61) = (cid:12)

(cid:12)CΩ,(cid:61)

(cid:12)
(cid:12) · R =

(cid:16) (cid:80)

ˆP∈P M ˆP,(cid:61)

(cid:17)

· R, where | · |

denotes the length of a chain in blocks.

• The proportional reward function (cid:37)(·, ·) is deﬁned as (cid:37)(cid:0)CΩ,(cid:61), P(cid:1) = MP,(cid:61)
(cid:12)
(cid:12)
(cid:12)
(cid:12)CΩ,(cid:61)

=

(cid:80)

MP,(cid:61)
ˆP∈P M ˆP,(cid:61)

.

Thus, by Deﬁnition 9, we have that:

∀(cid:61) ∀P ∈ P : RP,(cid:61) = (cid:37)(CΩ,(cid:61), P) · RΩ,(cid:61) = MP,(cid:61) · R .

(4)

In Bitcoin, on each time slot a party keeps a local chain, which is the longest among all
available chains. If multiple longest chains exist, the party follows the chronological ordering of
messages.

Following, we assume that none of the participating parties has complete control over message
delivery. Therefore, when two parties P, P (cid:48) produce blocks for the same index on the same time
slot, it may be unclear which is adopted by third parties that follow the protocol, i.e., depending
on which arrives ﬁrst.

Furthermore, the index of each block m is an integer that identiﬁes the distance of m from
BG, i.e., its height in the tree of blocks. Blocks on the same height, but diﬀerent branches, have
the same index but are non-equivalent (recall, that two messages are equivalent if their hash is
equal).

Bitcoin is an Approximate Nash Equilibrium w.r.t. Reward. We prove that under
our model, the Bitcoin protocol is a Θ(δ2)-Nash equilibrium w.r.t. the utility Reward (hence, by
Thoerem 1, it is also a (Θ(δ2), X )-compliant w.r.t. the same utility, where X is any associated
infraction predicate) and any synchronous router. By Deﬁnition 7 and Eq. (4), we have that
when parties follow the strategy proﬁle σ, the utility UP of party P is

UP (σ) = E(cid:2)MP,Eσ

(cid:3) · R ,

(5)

14

where MP,Eσ is the (random variable) number of blocks produced by P in the chain output by
Ω and R is the ﬁxed amount of rewards per block. Our analysis considers typical values of the
success probability δ, suﬃciently small such that δ · q < 1 (recall that q is the total number of
oracle queries available to all parties per slot). We say that party P is successful during time
slot r, if P manages to produce at least one block, i.e., at least one oracle query submitted by
P during r was successful. The time slot r is uniquely successful for P, if no other party than
P manages to produce a block in r. Theorem 4 is the main result of this subsection, which uses
in its proof the result of Lemma 2.

Lemma 2. Assume an execution trace (cid:61) of the Bitcoin protocol where all parties follow the
honest strategy under a synchronous router. Let B1, . . . , Bk be a sequence of blocks produced by
party P ∈ P during a time slot r that was uniquely successful for P in (cid:61). Then, B1, . . . , Bk will
be part of the chain output by observer Ω.

Proof. Let h be the height of B1. Then, for every j ∈ {1, . . . , k}, the height of the block Bj is
h + j − 1. Assume for the sake of contradiction that there is a j∗ ∈ [k] such that Bj∗ is not in
the observer’s chain. Since each block contains the hash of the previous block in the chain of
Ω, the latter implies that the subsequence Bj∗ , . . . , Bk is not in the observer’s chain. There are
two reasons that Bj∗ is missing from the observer’s chain.

1. The observer Ω never received Bj∗ . However, after the end of time slot r, Ω will be
activated and fetch the messages included in its ReceiveΩ() string. Therefore, the case
that Ω never received Bj∗ cannot happen.

2. The observer has another block B(cid:48)

j∗ included in its chain that has the same height, h+j∗−1,
as Bj∗ . Since r was uniquely successful for P in (cid:61), the block B(cid:48)
j∗ must have been produced
in a time slot r(cid:48) that is diﬀerent than r. Assume that P produced the block sequence
j∗ , . . . , B(cid:48)
B(cid:48)

k(cid:48) during r(cid:48). We examine the following two cases:

(a) r > r(cid:48): then B(cid:48)

j∗ was produced before Bj∗ , so in time slot r(cid:48) + 1 all parties received
(at least) the sequence B(cid:48)
k(cid:48). All parties select the longest chain, so the chain
that they will select will have at least h + k(cid:48) − 1 ≥ h + j∗ − 1 number of blocks in
r(cid:48) + 1. Thus, for time slot r ≥ r(cid:48) + 1 the parties submit queries for producing blocks
which height is at least h + k(cid:48) > h + j∗ − 1. So at time slot r, the party P cannot
have produced a block which height is ≤ h + j∗ − 1.

j∗ , . . . , B(cid:48)

(b) r < r(cid:48): then Bj∗ was produced before B(cid:48)

j∗ . So in time slot r + 1 all parties receive the
sequence B1, . . . , Bk. Thus, they will adopt a chain with at least h + k − 1 ≥ h + j∗ − 1
number of blocks. Thus, for time slot r(cid:48) ≥ r + 1 the parties submit queries for
producing blocks with height at least h + k > h + j∗ − 1. Therefore, P cannot have
produced a block of height ≤ h + j∗ − 1 during time slot r(cid:48).

By the above, Bj∗ is a block with height h + j∗ − 1 received by Ω and no other block with
height h + j∗ − 1 is included in Ω’s chain. Since Ω adopts the longest chain, there must be a
block with height h + j∗ − 1 that is included in its chain. It is straightforward that this block
will be Bj∗ , which leads to contradiction.

i) N ≥ κc be the number of time slots of the execution, where κ is the
Theorem 4. Let:
security parameter and c is a suﬃciently large constant; ii) ¯U be the utility vector where each
party employs the utility Reward; iii) A be a synchronous router. The Bitcoin protocol is an
(cid:15)-Nash equilibrium w.r.t. ¯U under A, for (cid:15) := N Rq2

δ2 .

2

Proof. Consider a protocol execution where all parties follow the honest strategy Π, with σΠ
denoting the proﬁle (cid:104)Π, . . . , Π(cid:105). Let P be a party and µP be its mining power. For r ∈ [N ],
let X σΠ
P,r be the random variable that is 1 if the time slot r is uniquely successful for P and 0
otherwise. By protocol description, a party P (cid:48) makes µP (cid:48) · q oracle queries during r, each with

15

success probability δ. Thus:

Pr[X σΠ

P,r = 1] =

= Pr[P is successful during r]·

· Pr[all the other parties produce no blocks in r] =

(cid:16)

1 − (1 − δ)µP q(cid:17)

=

·

(cid:89)

(1 − δ)µP(cid:48) q =

(cid:16)

1 − (1 − δ)µP q(cid:17)

=

· (1 − δ)(1−µP )q =

P (cid:48)(cid:54)=P

=(1 − δ)(1−µP )q − (1 − δ)q .

(6)

The random variable XP,EσΠ
time slots for P. By Eq. (6), X Π
of success (1 − δ)(1−µP )q − (1 − δ)q. Therefore: E(cid:2)XP,EσΠ

P,r expresses the number of uniquely successful
P follows the binomial distribution with N trials and probability

(1 − δ)(1−µP )q − (1 − δ)q(cid:17)

(cid:3) = N

(cid:16)

.

:= (cid:80)

r∈[N ] X σΠ

Let MP,EσΠ

be the number of blocks produced by P included in the chain output by the
observer Ω. In a uniquely successful time slot r, P produces at least one block, and by Lemma 2,
all the blocks that P produces during r will be included in the chain output by the observer.
Therefore, for all random coins MP,EσΠ

and so it holds that:

E(cid:2)MP,EσΠ

(cid:3) ≥ E(cid:2)XP,EσΠ

(1 − δ)(1−µP )q − (1 − δ)q(cid:17)

.

(7)

≥ XP,EσΠ
(cid:16)

(cid:3) = N

Now assume that P decides to unilaterally deviate from the protocol, following a strategy S.
Let σ denote the respective strategy proﬁle. Let ZP,Eσ be the number of blocks that P produces
by following S and MP,Eσ be the number of blocks produced by P that will be included in the
chain output by Ω. Clearly, for all random coins MP,Eσ ≤ ZP,Eσ . Without loss of generality,
we may assume that P makes all of their N µP q available oracle queries (indeed, if P made less
than N µP q queries then on average it would produce less blocks). Thus, we observe that ZP,Eσ
follows the binomial distribution with N µP q trials and probability of success δ. Thus:

E(cid:2)MP,Eσ

(cid:3) ≤ (cid:2)ZP,Eσ

(cid:3) = N µP qδ .

(8)

By deﬁnition of UP in Eq. (5) and Eq. (7) and (8), for ﬁxed block rewards R and for every

strategy S that P may follow, we have:

UP (σ) − UP (σΠ) = E(cid:2)MP,Eσ

≤ N µP qδR − N

(cid:16)

(cid:3) · R − E(cid:2)MP,EσΠ
(1 − δ)(1−µP )q − (1 − δ)q(cid:17)

(cid:3) · R ≤

R .

(9)

By Bernoulli’s inequality, we have that: (1 − δ)(1−µP )q ≥ 1 − (1 − µP )qδ. Besides, by binomial
expansion, and the assumption that δ · q < 1 we have that: (1 − δ)q ≤ 1 − qδ + q2
2 δ2. Thus, by
applying the two above inequalities in Eq. (9), we get that:

UP (σ) − UP (σΠ) ≤ N µP qδR − N

≤ N µP qδR − N

(1 − δ)(1−µP )q − (1 − δ)q(cid:17)
(cid:16)
(cid:16)

(cid:16)

1 − (1 − µP )qδ −

1 − qδ +

R ≤

δ2(cid:17)(cid:17)

R =

q2
2

(10)

= N µP qδR − N

(cid:16)

µP qδ −

δ2(cid:17)

R =

q2
2

=

N Rq2
2

δ2

By Eq. (10), Bitcoin is an (cid:15)-Nash equilibrium for (cid:15) := N Rq2

2

δ2.

16

Remark. The result of Theorem 4 is in agreement with previous works [58, 55], while similar
results exist w.r.t. proﬁt [5]. Nonetheless, there are a few remarks to be made. A well-known
implication from the selﬁsh mining attack [29, 84] is that Bitcoin is not an equilibrium w.r.t.
relative rewards. However, selﬁsh mining relies on withholding a block’s publication, which is a
compliant behavior (w.r.t. Xbc, Deﬁnition 6). Second, our analysis assumes ﬁxed diﬃculty, while
Bitcoin operates under variable diﬃculty, which is computed on regular intervals depending on
the active mining power. Various interesting result exist for the variable diﬃculty setting: i) [47]
showed that Bitcoin is not an equilibrium w.r.t. rewards, as selﬁsh mining is more proﬁtable;
ii) [33] showed that Bitcoin is not an equilibrium w.r.t. proﬁt, as miners stop performing
some hashing queries to artiﬁcially reduce the diﬃculty; iii) [46] showed that Bitcoin is not an
equilibrium w.r.t. proﬁt in some cases (depending on the cost mechanism) and seemingly also
non-compliant w.r.t. Xabs, as miners take turns shutting down and resuming operations per
diﬃculty adjustment epoch. Therefore, Bitcoin’s compliance under alternative utilities, variable
diﬃculty, and alternative infraction predicates (e.g., enabling some ﬂexibility in the amount of
hashing queries) is a promising line of future research.

5.2 Proof-of-Stake

Proof-of-Stake (PoS) systems diﬀer from Bitcoin in a few points. Typically, the execution of
such systems is organized in epochs, each consisting of a ﬁxed number le of time slots. On
each slot, a speciﬁed set of parties is eligible to participate in the protocol. Depending on the
protocol, the leader schedule of each epoch may or may not be a priori public.

The core diﬀerence with PoW concerns the power µP of each party. In PoS, µP represents
their stake in the system, i.e., the number of coins that P owns. Stake is dynamic, therefore
the system’s coins may change hands and the leader schedule of each epoch depends on the
8 As in Bitcoin, each party participates
stake distribution at the beginning of the epoch.
proportionately to their power, so the expected ratio of slots for which P is leader over the total
number of the epoch’s slots is µP .

Also, in PoS protocols, the oracle OΠ does not perform hashing as in Bitcoin. Instead, it is
parameterized by the leader schedule and typically performs signing. A signature output by OΠ
is valid if and only if the input message is submitted by the slot leader in time. This introduces
two important consequences: i) only the slot leader can produce valid messages during a given
slot; ii) the leader can produce as many valid messages as the number of possible queries to OΠ.

In the next paragraphs, we use the following notation:

• C: the cost of a single query to OΠ;

• R: the (ﬁxed) reward per block;

• e: the number of epochs in an execution;

• le: the number of slots per epoch;

• µP,j: the power of party P on epoch j.

5.2.1 Single-Leader Proof-of-Stake

As before, we analyze a representative of a family of protocols; the family is single-leader PoS
(SL-PoS) and the representative is Ouroboros [54]. The SL-PoS family includes systems like
EOS9 and Ouroboros BFT [53], while the analysis is also applicable (with minor changes) on
Gasper (cf. Appendix A). We again utilize the blockchain infraction predicates (cf. Deﬁni-
tion 6). Section 4 showed that resource-proportional rewards do not necessarily guarantee com-
pliance. Ouroboros, as a consensus protocol, does not deﬁne rewards, but the authors proposed
a complex reward mechanism that approximates resource-proportional rewards. Nonetheless,

8In reality, the snapshot of the stake distribution is retrieved at an earlier point of the previous epoch, but

we can employ this simpliﬁed version without loss of generality.

9https://developers.eos.io/welcome/latest/protocol/consensus_protocol

17

the Ouroboros implementation (in Cardano) employs block-proportional rewards, so we will also
consider ﬁxed rewards per block (cf. Deﬁnition 9).

On each slot, Ouroboros deﬁnes a single party, the “slot leader”, as eligible to create a
valid message. Speciﬁcally, the protocol restricts that a leader cannot extend the chain with
multiple blocks for the same slot, therefore all honest parties extend their chain by at most 1
block per slot. The leader schedule is public and is computed at the beginning of each epoch
via a secure, publicly veriﬁable Multi-Party Computation (MPC) sub-protocol, which cannot
be biased by any single party. To prevent long-range attacks [10], Ouroboros employs a form
of rolling checkpoints (“a bounded-depth longest-chain rule” [54]), i.e., a party ignores forks
that stem from a block older than a (protocol-speciﬁc) limit from the adopted chain’s head
(it should be noted that subsequent versions of Ouroboros did not utilize the same logic, cf.
Subsection 5.2.2).

Generalizing from the above, a SL-PoS protocol demonstrates the following properties:

• the execution is organized in epochs;

• within each epoch, a single party (the leader ) is eligible to produce a message per index;

• a party which is online considers the blocks of each past epoch ﬁnalized (i.e., does not

remove them in favor of a competing, albeit possibly longer, chain);

• no single party with power less than 1

2 can bias the epoch’s leader schedule.

Synchronous network. First, we assume a diﬀuse functionality parameterized by a syn-
chronous router (cf. Section 2.1). Theorem 5 shows that SL-PoS with block-proportional re-
wards is an (cid:15)-Nash equilibrium for negligible (cid:15) (hence, by Theorem 1, it is also ((cid:15), X )-compliant,
X being any associated infraction predicate); this result is in line with the incentives’ analysis
of Ouroboros [54]. We remark that [9] explored the same setting (synchronous, longest-chain
PoS) and identiﬁed a selﬁsh mining-like attack against so-called “predictable” protocols, like
Ouroboros. This result was later reﬁned by [32], showing that such attacks are proﬁtable for
participants controlling more than 32.5% of total stake. Nonetheless, that line of research tar-
geted relative rewards and relied on withholding a block’s publication for some time; our work
considers absolute rewards and does not consider block withholding as non-compliant behavior.

Theorem 5. Assume: i) a synchronous router A; ii) ∀P ∈ P : µP < 1
2 . SL-PoS with block-
proportional rewards (Deﬁnition 9 for ﬁxed block reward R) is an (cid:15)-Nash equilibrium w.r.t. utility
Reward and, if R > C, is an (cid:15)-Nash equilibrium w.r.t. utility Proﬁt, both for negligible (cid:15) and
under A.

Proof. To prove the statement, it suﬃces to show that, if the assumptions hold, no party can
increase its reward more than (cid:15) by unilaterally deviating from the protocol, where (cid:15) = negl(κ).
First, if all parties control a minority of staking power, no single party can bias the slot leader
schedule for any epoch (unless with negl(κ) probability). Therefore, the (maximum) expected
number of slots for which each party P is leader is (cid:80)
j∈[1,e] le · µP,j, where µP,j is the percentage
of staking power of P during the j-th epoch.

(cid:80)

Second, if all parties follow Π, then the total expected rewards for each party P are R ·
j∈[1,e] le · µP,j. This is a direct consequence of the network synchronicity assumption. Speciﬁ-
cally, on slot r the (single) leader P creates exactly one block B, which extends the longest chain
(adopted by P). At the beginning of slot r + 1, all other parties receive B and, since B is now
part of the (unique) longest chain, all parties adopt it. Consequently, all following leaders will
extend the chain that contains B, so eventually B will be in the chain output by Ω. Therefore,
if all parties follow the protocol and no party can bias the leader schedule, then no party can
increase its expected rewards by deviating from the protocol.

Regarding proﬁt, a leader creates a block by performing a single query to OΠ. Additionally,
cost depends only on the number of such queries. Therefore, if the cost of performing a single
query is less than R, then the proﬁt per slot is larger than 0, so abstaining from even a single
slot reduces the expected aggregate proﬁt; therefore, all parties are incentivized to participate
in all slots.

18

Lossy network. Second, we assume a lossy, randomized router (cf. Section 2.1).10 Theorem 6
the conﬂicting
shows that SL-PoS with block proportional rewards is not compliant w.r.t.
infraction predicate Xconf ; speciﬁcally, it shows that (cid:15) is upper-bounded by a large value, which
is typically non-negligible.

Theorem 6. Assume: i) a lossy, randomized router A with (non-negligible) parameter d (cf.
Section 2.1); ii) ∀P (cid:48) ∈ P : µP (cid:48) < 1
2 ; iii) P is the party with maximum power µP across the
execution and sP = (cid:80)
j∈[1,e] le · µP,j is the expected number of slots for which P is leader;
iv) (1 − d) · R (cid:29) C.

SL-PoS with block-proportional rewards (cf. Deﬁnition 9) is not ((cid:15), Xconf )-compliant (cf.
Deﬁnition 5) w.r.t. : i) utility Reward for (non-negligible) (cid:15) < (d − dt) · R · sP ; ii) utility Proﬁt
for (non-negligible) (cid:15) < ((d − dt) · R − (t − 1) · C) · sP , where t = (cid:98)
(cid:99), in both cases
under A.

C
R·ln(1/d) )
ln(d)

ln(

Proof. Since d is an independent probability, P cannot bias it in any way. Therefore, P can only
try to increase its rewards (beyond RH ) by performing multiple queries. To prove the statement,
we will show that a party is indeed incentivized to produce multiple conﬂicting blocks, in order
to increase the probability that at least one of them is delivered.
Following the honest model, a party’s expected rewards are

and its expected proﬁt is

RH = (1 − d) · R ·

(cid:88)

j∈[1,e]

le · µP,j

PH = ((1 − d) · R − C) · sP

Regarding utility Reward, assume a deviation St, s.t. every time P is the leader of a slot, P
creates t conﬂicting blocks. Observe that, if at least one of the t blocks is not lost, then P will
get the reward for the corresponding block (similar to the proof of Theorem 5).

The expected rewards under St are:

RSt = (1 − dt) · R · sP

As t tends to ∞, dt tends to 0, therefore RS tends to R · sP , which is the maximum possible
amount of rewards that P can hope for. Therefore, the deviation S∞ is the best response and
the utility improvement is: (d − dt) · R · sP .

When P performs t queries, their aggregate cost is t · C. Therefore, the proﬁt under St is:

PSt = ((1 − dt) · R − t · C) · sP

Since (1 − d) · R (cid:29) C, performing multiple queries yields higher expected proﬁt. However, as
more queries are performed, the increase rate of the proﬁt PSt decreases, until a point where the
expected rewards become less than the cost of performing t queries. To compute this threshold
we consider the function of the diﬀerence between the proﬁt of the honest protocol and St:

f (t) = (((1 − dt) · R − t · C) − ((1 − d) · R − C)) · sP ⇒

⇒f (t) = ((d − dt) · R − (t − 1) · C) · sP

To compute the t for which f (t) is maximized, we consider the point where the derivative of f
is 0:

f (cid:48)(t) = (− ln(d) · R · dt − C) · R − C)) · sP = 0 ⇒

⇒t =

ln(− C

R·ln(d) )
ln(d)

.

10The randomized router is an example, which will be used to prove the negative result of Theorem 7. Other
routers, which would model arguably more realistic networks, could also be considered to, possibly, achieve
compliance results.

19

The lossy network analysis is particularly of interest as it was observed in practice. On
December 2019, Cardano released its Incentivized Testnet (ITN)11, where stakeholders, i.e.,
users owning Cardano’s currency, participated in PoS by forming stake pools that produced
blocks. The ITN used proportional rewards and the SL-PoS execution model of epochs and
slots. Each pool was elected as a slot leader proportionally to its stake and received its share
of an epoch’s rewards based on its performance, i.e., the number of produced blocks compared
to the expected blocks (based on its proportional stake). Thus, pool operators were particularly
incentivized to avoid abstaining, i.e., failing to produce a block when elected. However, the
network was unstable and lossy, so forks started to form. In turn, pools were incentivized12
to “clone” their nodes, i.e., run multiple parallel instances, to increase network connectivity,
reduce packet loss, and also extend all possible forks. To make matters worse, this solution both
perpetuated forks and created new ones, as clones did not coordinate but produced diﬀerent
blocks, even when extending the same chain.

We note that, although a lossy network may render a PoS protocol non-compliant, the same
does not hold for PoW. As described in the proof of Theorem 6, a party produces multiple blocks
per slot to maximize the probability that one of them is eventually output by Ω. Notably, since
the PoS protocol restricts that at most one block extends the longest chain per slot, these blocks
are necessarily conﬂicting. However, PoW ledgers do not enforce such restriction; therefore,
a party would instead create multiple consecutive (instead of parallel, conﬂicting) blocks, as
covered in the proof of Theorem 4, which yields maximal expected rewards even under a lossy
network.

5.2.2 Multi-Leader Proof-of-Stake

We now turn to multi-leader PoS (ML-PoS) and Ouroboros Praos [21], a representative of a
family alongside Ouroboros Genesis [6], Peercoin [56], and Tezos’ baking system [88]. These
protocols are similar SL-PoS, but with a core diﬀerence: multiple parties may be chosen as
leaders for the same slot. As Theorem 7 shows, ML-PoS protocols are not compliant for block-
proportional rewards. The core idea is the same as with SL-PoS under a lossy network: a party
is incentivized to produce multiple blocks to decrease the probability that a competing leader’s
competing block is adopted over their own. We note that, although consensus doesn’t enforce
a tie-breaking policy for competing messages, parties typically opt for the message that arrives
ﬁrst. The dependency on randomized routing is also worth noting. Since alternative routers
could yield positive results, an interesting research direction is to explore the class of routers
under which compliance holds, possibly avoiding infractions via specially-crafted peer-to-peer
message passing protocols.

Theorem 7. Assume:
P : µP (cid:48) < 1
(cid:80)

i) a synchronous, randomized router A (cf. Section 2.1); ii) ∀P (cid:48) ∈
2 ; iii) P is the party with maximum power µP across the execution and sP =
j∈[1,e] le · µP,j is the expected number of slots s.t. P is leader; iv) (1 − d) · R (cid:29) C. Let pl be

the (protocol-dependent) probability that multiple leaders are elected in the same slot.

ML-PoS with block-proportional rewards (cf. Deﬁnition 9) is not ((cid:15), Xconf )-compliant (cf.
2 · R · sP ; ii) utility proﬁt for
(cid:113) pl·R
C (cid:99) − 1, in both cases under

Deﬁnition 5) w.r.t. : i) utility reward for (non-negligible) (cid:15) < pl
(non-negligible) (cid:15) < ( t−1
A.

2·(t+1) · pl · R − (t − 1) · C) · sP , where t = (cid:98)

Proof. First, we deﬁne a bad event E, during which the expected rewards of party P are less if
following Π, compared to a non-compliant strategy.

Let r be a slot during which P is leader, along with a diﬀerent party P (cid:48); this occurs with
probability pl. Also, on slot r + 1 a single leader P (cid:48)(cid:48) exists. E occurs if P (cid:48)(cid:48) receives a block B(cid:48)
from P (cid:48) before a block B from P and thus extends the former. If E occurs, the reward for slot
r is credited to P (cid:48).

Let pE be the probability that E occurs. First, pE depends on the probability pl that
multiple leaders exist alongside P. pl depends on the protocol’s leader schedule functionality,

11https://staking.cardano.org/
12https://www.reddit.com/r/cardano/comments/ekncza

20

but is typically non-negligible. Second, it depends on the order delivery of B, B(cid:48); since the
delivery is randomized, the probability pn that B(cid:48) is delivered before B is at most pn = 1
2 .
Therefore, it holds pE = pl · pn = 1
2 pl, which is non-negligible.

If all parties follow Π, the expected reward of P is at most RH = (1 − 1
The proof now follows the same reasoning as Theorem 6. Speciﬁcally, we will show a deviation
s.t. P creates multiple blocks to increase the probability that at least one of them is delivered
to the other parties ﬁrst.

2 pl) · R · sP .

Regarding utility Reward, assume a deviation St, s.t. every time P is the leader of a slot, P

creates t conﬂicting blocks. The expected rewards under St are:

RSt = (1 −

1
t + 1

pl) · R · sP

As t tends to ∞,

1
t+1 tends to 0, therefore RS tends to R · sP , which is the maximum possible
amount of rewards that P can hope for. Therefore, the deviation S∞ is the best response and
the utility improvement is: pl

2 · R · sP .

Regarding costs, the aggregate cost of t queries is t · C. Therefore, the proﬁt under St is:

PSt = ((1 −

1
t + 1

pl) · R − t · C) · sP

As in Theorem 6, our goal is to ﬁnd the maximum t s.t.

the utility increase of PSt

is

maximized. Now, the utility increase function is:

f (t) = (((1 −

1
t + 1

pl) · R − t · C) − ((1 −

1
2

pl) · R − C)) · sP ⇒

⇒f (t) = (

t − 1
2 · (t + 1)

· pl · R − (t − 1) · C) · sP

To compute the t for which f (t) is maximized, we consider the point where the derivative of

f is 0:

f (cid:48)(t) = (

pl · R
(t + 1)2 − C)) · sP = 0 ⇒

⇒t =

(cid:114)

pl · R
C

− 1 .

6 Compliant Non-equilibria

So far, our positive results w.r.t. compliance relied on showing that the protocol is an equilib-
rium. In this section, we demonstrate the distinction between the two notions via protocols that
are compliant w.r.t. a non-trivial infraction predicate, but not Nash equilibria.

Protocol speciﬁcations. To do this, we consider a simple, yet typical, Single-Leader PoS
(SL-PoS) protocol Π, which features the following characteristics:

• The slot leaders are randomly elected, directly proportional to their staking power.
• The staking power µP of a party P remains ﬁxed across the execution (this always holds

when employing resource-proportional rewards).

• Only if elected as slot leader, P will make a single query to the signing oracle OΠ and

casts the received block at the speciﬁc time slot.

• The single query cost is C, a (typically small) polynomial on the security parameter κ.

We provide two results. First, we show that, under resource-proportional rewards, Π is
compliant w.r.t. Xconf but non-compliant (hence not an equilibrium) w.r.t. Xabs. Next, we
show that, under block-proportional rewards, Π is compliant w.r.t. Xconf but is susceptible to
selﬁsh signing, an attack akin to selﬁsh mining, when it is “predictable”, i.e., the leader schedule
is known in advance [9]..

21

6.1 Proof-of-Stake under Resource Proportional Rewards

First, we consider Π under resource-proportional rewards (cf. Deﬁnition 8) and utility Proﬁt
and investigate its compliance w.r.t. the two types of attacks captured by Xconf and Xabs (cf.
Deﬁnition 6). The goal of this study is to show that, under a well-deﬁned interval of approxi-
mation factor values, the protocol, although non Xabs-compliant (hence, also non approximate
Nash equilibrium), operates in a Xconf -compliant manner. We note that non Xabs-compliance
is consistent with Theorem 3; in particular, it applies that result and assigns concrete values to
that theorem’s generic parameters.

Theorem 8. Let: i) Π be the SL-PoS blockchain protocol speciﬁed in Section 6.1; ii) A be a
synchronous router; iii) R be the total rewards distributed by the protocol; iv) ξ : [0, 1] → [0, 1] be
the identity resource-proportional reward function, i.e., ξ(µP ) = µP ; v) N ≥ κc be the number
of time slots of the execution, where κ is the security parameter and c is a suﬃciently large
constant; vi) Pmax is the party with the maximum staking power µPmax. If µPmax < 1
2 , then
i) for every (cid:15) ≥ 0, Π is ((cid:15), Xconf )-compliant w.r.t. utility Proﬁt; ii) for
the following hold:
(cid:15)max := µPmax · N · C − µN +1
· R and every (cid:15) < (cid:15)max, Π is not ((cid:15), Xabs)-compliant w.r.t. utility
Pmax
Proﬁt, in both cases under A.

Proof. We begin by introducing a useful notion. We say that a strategy proﬁle σ = (cid:104)S1, . . . , Sn(cid:105)
is Xconf -agnostic, if for every i ∈ [n], the strategy Si of Pi does not depend on the Xconf -
compliance of the other parties’ strategies. For instance, Si does not include checks such as “if
some party is creating conﬂicting blocks, then create conﬂicting blocks”, or “if Pj does not create
conﬂicting blocks, then abstain”. Clearly, σΠ is Xconf -agnostic. We note that an Xconf -agnostic
strategy proﬁle may still be non Xconf -compliant, i.e., the parties may create conﬂicting blocks
independently of other parties’ behavior.

In the following claim, we prove that it is not in the parties’ interest to deviate by creating

conﬂicting blocks, when they are behaving according to a Xconf -agnostic strategy proﬁle.
Claim 8.1. Let σ = (cid:104)S1, . . . , Sn(cid:105) /∈ (SXconf )n be a strategy proﬁle, i.e., for some party Pi ∈ P
and some trace (cid:61) where Pi employs Si, it holds that Xconf ((cid:61), Pi) = 1. If σ is also Xconf -agnostic,
then there is a strategy proﬁle σ(cid:48) ∈ (SXconf )n where Pi unilaterally deviates from σ, such that
UPi(σ(cid:48)) > UPi(σ).
Proof of Claim 8.1. We deﬁne σ(cid:48) as follows: in any execution, Pi makes only one query to OΠ
in all time slots that Pi decided to produce conﬂicting blocks w.r.t. σ. Whether Pi decides to
honestly extend the longest chain or to create a fork (e.g., by performing selﬁsh signing) remains
unchanged in any corresponding executions w.r.t. σ or σ(cid:48).

Assume that under σ, Pi is the leader for a sequence of slots r, . . . , r + d, d ≥ 0, and by
creating conﬂicting blocks it produces a tree of blocks signed by Pi, rooted at some block that
was already in the chain when r was reached. Observe that the height of the said tree is at
most d + 1 (if Pi does not abstain at any of slots r, . . . , r + d). This implies that when the
longest chain rule is applied by the other parties and Ω, d(cid:48) ≤ d + 1 blocks of Pi for that period
will be included by following a longest path of length d(cid:48) on the tree. On the other hand, if Pi
behaves w.r.t. σ(cid:48), then a single path of exactly d(cid:48) blocks of Pi will be included in the chain
during r, . . . , r + d. Given that σ is Xconf -agnostic, the other parties’ behavior in σ(cid:48) remains the
same as in σ. So, it holds that E[RPi,Eσ(cid:48) ] = E[RPi,Eσ ] and for every other party ˆP (cid:54)= Pi, it also
holds that E[R ˆP,Eσ(cid:48)

On the other hand, since σ /∈ (SXconf )n, and since creating conﬂicting blocks costs more than
making only single queries, it holds that there are traces w.r.t. σ where the cost of Pi is strictly
larger than the cost of Pi in the corresponding trace (same random coins) w.r.t. σ(cid:48). Thus, it
holds that E[CPi,Eσ(cid:48) ] < E[CPi,Eσ ].

] = E[R ˆP,Eσ

].

Given the above, we conclude that

UPi(σ(cid:48)) = E[RPi,Eσ(cid:48) ] − E[CPi,Eσ(cid:48) ] > E[RPi,Eσ ] − E[CPi,Eσ ] = UPi(σ) .

(cid:97)

22

Next, in the following claim, we show that by Π’s description, we can focus on Xconf -agnostic

strategy proﬁles.

Claim 8.2. Let σ = (cid:104)S1, . . . , Sn(cid:105) be a non Xconf -agnostic strategy proﬁle. Then, there exists a
strategy proﬁle σ(cid:48) that is Xconf -agnostic and for every Pi ∈ P it holds that UPi(σ(cid:48)) ≥ UPi(σ).
Proof of Claim 8.2. We provide a constructive proof for creating σ(cid:48); by expressing the strategy
Si as an algorithm, since σ is non Xconf -agnostic, for i ∈ [n], Si potentially contains in each
slot r checks of the form “if (A) then{cmdA} else{cmd¬A}”, where (i) A is some condition
related to the other parties’ strategies regarding Xconf -compliance, an (ii) by Π’s description,
the commands cmdA, cmd¬A are selected from the following types of commands:

1. “do nothing”;

2. “abstain from querying OΠ”;

3. “make one query to OΠ and extend the longest chain”; (honest behavior)

4. “make one query to OΠ and create a fork”; (set of commands that includes selﬁsh signing)

5. “make multiple queries to OΠ and extend the longest chain”; (set of commands that

includes creation of conﬂicting blocks)

6. “make multiple queries to OΠ and create forks”; (set of commands)

7. “make at least one query to OΠ but publish no block”; (set of commands)

8. “if (B) then{cmdB} else{cmd¬B}”; (nested if )

We show how we can “remove” checks as above, where in the case of nested if we proceed

from the inner to the outer layer.

An inner layer check contains commands of type 1-7. The crucial observation is that the
change in the utility by the behavior that derives from each of these seven types of commands
is independent from other parties’ actions regarding Xconf -compliance. Namely, the change in
rewards and cost by executing a command of type 1-7 is not aﬀected by the case that some
other subset of parties have created conﬂicting blocks or not so far (and when).

Thus, for the check “if (A) then{cmdA} else{cmd¬A}” in slot r, we consider two strategies
Si,A, Si,¬A deﬁned as follows; the party Pi behaves as in Si with the following modiﬁcation: at
slot r, Pi always executes cmdA (resp. cmd¬A) when following Si,A (resp. Si,¬A).

Now, let σi,A (resp. σi,¬A) be the strategy proﬁle where Pi follows Si,A (resp. Si,¬A) and all
the other parties follow the same strategy as σ. By the description of Si,A, Si,¬A, we show that
(cid:0)UPi(σi,A) ≥ UPi(σ)(cid:1) ∨ (cid:0)UPi(σi,¬A) ≥ UPi(σ)(cid:1) .

Intuitively, the above holds because the utility of Pi depends on which of the two commands
cmdi,A, cmdi,¬A will be executed, independently of the other parties’ strategies regarding Xconf -
compliance. Formally, we want to prove that it always holds that

UPi(σ) ≤ max(cid:8)UPi(σi,A), UPi(σi,¬A)(cid:9) .

(11)

By the deﬁnition of Si,A, Si,¬A, we have that

Pr[RPi,Eσ = x|A] = Pr[RPi,Eσi,A
P r[CPi,Eσ = y|A] = Pr[CPi,Eσi,A

= x]

= y]

Pr[RPi,Eσ = x|¬A] = Pr[RPi,Eσi,¬A
Pr[CPi,Eσ = y|¬A] = Pr[CPi,Eσi,¬A

= x]

= y]

By the above, we get that

23

UPi(σ) = E[RPi,Eσ ] − E[CPi,Eσ ] =

(cid:88)

x

Pr[RPi,Eσ = x] · x −

(cid:88)

y

Pr[CPi,Eσ = y] · y =

= Pr[A] ·

(cid:88)

Pr[RPi,Eσ = x|A] · x + Pr[¬A] ·

(cid:88)

Pr[RPi,Eσ = x|¬A] · x−

x
(cid:88)

− Pr[A] ·

y
(cid:16) (cid:88)

= Pr[A] ·

x
(cid:16) (cid:88)

+ Pr[¬A] ·

x

Pr[CPi,Eσ = y|A] · y − Pr[¬A] ·

x
(cid:88)

Pr[CPi,Eσ = y|¬A] · y =

Pr[RPi,Eσ = x|A] · x −

y

Pr[CPi,Eσ = y|A] · y

(cid:17)

+

(cid:88)

y

Pr[RPi,Eσ = x|¬A] · x −

Pr[CPi,Eσ = y|¬A] · y

(cid:17)

=

(cid:88)

y

= Pr[A] ·

(cid:16) (cid:88)

Pr[RPi,Eσi,A

= x] · x −

Pr[CPi,Eσi,A

= y] · y

(cid:17)

+

(cid:88)

y

x
(cid:16) (cid:88)

+ Pr[¬A] ·

x

Pr[RPi,Eσi,¬A

= x] · x −

Pr[CPi,Eσi,¬A

= y] · y

(cid:17)

=

(cid:88)

y

= Pr[A] · (cid:0)E[RPi,Eσi,A
= Pr[A] · UPi(σi,A) + Pr[¬A] · UPi(σi,¬A) ≤ max(cid:8)UPi(σi,A), UPi(σi,¬A)(cid:9) .

](cid:1) + Pr[¬A] · (cid:0)E[RPi,Eσi,¬A

] − E[CPi,Eσi,A

] − E[CPi,Eσi,¬A

](cid:1) =

Therefore, Eq. (11) holds. Hence, if UPi(σi,A) ≥ UPi (σ) (resp. UPi(σi,¬A) ≥ UPi(σ)), then we
can “keep” Si,A (resp. Si,¬A) that contains one less check than σ and “discard” the latter. By
continuing this process iteratively for all parties, we end up in a strategy proﬁle σ(cid:48) that contains
no checks of the aforementioned form, i.e. σ(cid:48) is Xconf -agnostic. By construction, it holds that
UPi(σ(cid:48)) ≥ UPi(σ).
(cid:97)

Given Claims 8.1 and 8.2, we prove the Xconf -compliance of Π. In particular, we show that

for every (cid:15) ≥ 0, if a strategy proﬁle σ is (cid:15)-reachable from σΠ, then it is Xconf -compliant.

For the sake of contradiction, assume that σ is not Xconf -compliant. The proof is by induction

on the length (cid:96) of the shortest path from σΠ to σ.

• Basis: (cid:96) = 1. If σ is Xconf -agnostic, then by Claim 8.1, σ cannot set a best response for
the party Pi that unilaterally deviates from σΠ. Besides, if σ is not Xconf -agnostic, then
by Claim 8.2, there is a strategy proﬁle σ(cid:48) that is Xconf -agnostic and for which it holds
that UPi(σ(cid:48)) ≥ UPi(σ). Since by Claim 8.1 σ(cid:48) cannot set a best response for the party Pi,
neither σ can set a best response for the party Pi. Therefore, σ is not (cid:15)-directly reachable
from σΠ.

• Induction step: Assume that the statement holds for every (cid:15)-reachable strategy proﬁle
with shortest path of length (cid:96). Let σΠ → σ1 → · · · → σ(cid:96) → σ be the shortest path of
length (cid:96) + 1 from σΠ to σ. Then, σ1, . . . , σ(cid:96) are all Xconf -compliant. By following the
same steps as in Basis, we conclude that, either Xconf -agnostic or not, σ cannot set a best
response for the party that unilaterally deviates from σ(cid:96), thus σ is not (cid:15)-directly reachable
from σΠ.

To prove the non Xabs-compliance of Π, we apply Theorem 3 by setting the probabilities α

and βi, Ci, i ∈ [n] according to Π’s speciﬁcation. Namely,

• α = 0, as when all parties participate in a round then certainly a slot leader will be elected

and create a block.

• βi = µN
Pi

, as if only Pi abstains throughout the entire execution while the other parties
remain honest, the only case that a block will not be produced is if Pi is always elected.

• Ci = µPi · E[CPi,Eσ ] = N · C, by Assumption 2.
• The assumption C > µN
Pi

· µPi · R · 1 holds, as µN
Pi

is typically a very small value (negl(κ)).

24

Therefore, we set (cid:15)max := max
i∈[n]

{µPi · N · C − µN
Pi

· µPi · R} = µPmax · N · C − µN +1
Pmax

· R, where

we make the reasonable assumption that R is strictly upper bounded by

typically a very large value.

By Theorem 3, we have that for every (cid:15) < (cid:15)max, Π is not ((cid:15), Xabs)-compliant w.r.t. ¯U .

N · C
µN

Pmax

, as

N · C
µN

Pmax

is

6.2 Proof-of-Stake under Relative Utilities

We now continue our study of the SL-PoS protocol Π above. In particular, we also assume that
the protocol is predictable, i.e., the slot leader schedule for the entire execution is globally known
to the parties in advance [9]. However, we can get similar results by studying (suﬃciently large)
fragments of the execution when the protocol is predictable. We now consider block-proportional
rewards (cf. Deﬁnition 9) and a diﬀerent utility function that we call Relative Proﬁt. This utility
is deﬁned as the fraction of the party’s expected proﬁt over the aggregate expected rewards of
all parties when the denominator is not 0, and 0 otherwise 13. Formally, for a party P and
strategy proﬁle σ:

UP (σ) =

=










0,

E[RP,EZ,A,σ − CP,EZ,A,σ ]

E(cid:2) (cid:80)

ˆP∈P R ˆP,EZ,A,σ

,

if E(cid:2) (cid:80)

ˆP∈P R ˆP,EZ,A,σ

(cid:3) > 0

(cid:3)

E[RP,EZ,A,σ ] − E[CP,EZ,A,σ ]
ˆP∈P E(cid:2)R ˆP,EZ,A,σ

(cid:80)

(cid:3)

,

0,

=

(12)

if E(cid:2) (cid:80)

(cid:3) = 0

ˆP∈P R ˆP,EZ,A,σ
ˆP∈P E(cid:2)R ˆP,EZ,A,σ
ˆP∈P E(cid:2)R ˆP,EZ,A,σ

if (cid:80)

if (cid:80)

(cid:3) > 0

(cid:3) = 0

.

It is easy to see that Relative Proﬁt is an extension of Relative Rewards [29, 52, 9, 55],
where the utility is the fraction of the party’s rewards over the total rewards, by now taking
non-zero costs into account. As we will shortly prove, Π is Xconf -compliant w.r.t. to Relative
Proﬁt, but it is not compliant under a type of deviant behavior that we call selﬁsh singing. In
selﬁsh signing, a party P that knows she is going to be elected for d + 1 consecutive time slots,
r, r + 1, . . . , r + d, where d is the depth of the speciﬁc selﬁsh signing event, can create a fork of
d + 1 consecutive blocks pointing to a block created d + 1 steps earlier. This results in a new
longest chain such that the last d blocks of the old chain will get discarded. Given that the
discarded blocks belonged to other parties, then selﬁsh signing strictly improves the Relative
Proﬁt of P. The selﬁsh signing behavior is described in Algorithm 1 and illustrated in Figure 2.

Algorithm 1: Selﬁsh signing of depth d ≥ 1 during time slots r, . . . , r + d.

Input: A sequence of d + 1 blocks Br−d−1 ← · · · ← Br−1.
Output: A new fork of d + 2 blocks Br−d−1 ← B(cid:48)

r ← · · · ← B(cid:48)

r+d.

1 for j ← 0 to d do
2

if j == 0 then

3

4

5

else

As leader of time slot r, create a new block B(cid:48)

r that points to Br−d−1;

As leader of time slot r + j, create a new block B(cid:48)

r+j that points to B(cid:48)

r+j−1;

Next, we describe a strategy denoted by Sself , where the party P takes advantage of Π’s
predictability and executes selﬁsh signing at maximum depth whenever possible, under the
condition that she never abstains or allows selﬁsh singing to discard her own existing blocks.

13A seemingly plausible alternative approach would be to consider the fraction of the party’s expected proﬁt

over the aggregate expected proﬁt of all parties, i.e., UP (σ) =

E(cid:2) (cid:80)

E[RP,EZ,A,σ
ˆP∈P R ˆP,EZ,A,σ

−CP,EZ,A,σ
−(cid:80)

]

ˆP∈P C ˆP,EZ,A,σ

(cid:3) . However,

in this approach, there are corner cases where the denominator becomes negative and then, the utility would
not provide intuition on the parties’ payoﬀs. By considering only the (always non-negative) aggregate expected
rewards in the fraction, we avoid such problematic cases while maintaining relativity in our deﬁnition.

25

Figure 2: Selﬁsh signing of depth d during time slots r, . . . , r + d. The blocks Br−d, . . . , Br−1
will get discarded when the longest chain rule is applied.

The strategy Sself is described in detail in Algorithm 2. For an execution of N time slots, the
input is a string scheduleP ∈ {0, 1}N deﬁned as follows: for r ∈ [N ], scheduleP [r] is 1, if P is the
leader of slot r, and 0 otherwise.

Algorithm 2: The strategy Sself for party P.

Input: A string scheduleP ∈ {0, 1}N , where N is the time length of the execution.
Output: A sequence of pairs (cid:0)(r1, d1), . . . , (rw, dw)(cid:1) indicating the time slots that selﬁsh signing will take

place at the respective depth.

1 Initialize a list strategyP ← ();
2 Set r ← 1;
3 while r ≤ N do
4

if scheduleP [r] == 0 then

else

5

6

7

8

9

10

11

12

13

14

Set r ← r + 1;

/* As no leader of time slot r, P takes no action */

Set k∗ ← max

(cid:8)k(cid:12)
(cid:12)
(cid:8)(cid:96)(cid:12)
(cid:86)(cid:96)
Set (cid:96)∗ ← max
(cid:12)
if (k∗ == 0) ∨ ((cid:96)∗ == 0) then

j=0(scheduleP [r + j] == 1)(cid:9);
(cid:86)k
j=1(scheduleP [r − j] == 0)(cid:9);

k

(cid:96)

Set r ← r + 1;

/* If no selfish signing is possible, P acts as an honest party */

else

Set d ← min{k∗, (cid:96)∗};
Add (r, d) to strategyP ;
Set r ← r + (d + 1);

/* P will execute Algorithm 1 in slot r at depth d */

15 return strategyP ;

Note that the output (cid:0)(r1, d1), . . . , (rw, dw)(cid:1) of Algorithm 2 fully determines the behavior of
P throughout the execution. Namely, P acts honestly until time slot r1 when it performs selﬁsh
signing that lasts until r1 + d1, then it acts honestly at slots r1 + (d1 + 1), . . . , r2 − 1 and at slot
r2 it performs selﬁsh signing that lasts until r2 + d2, etc.
Next, we deﬁne the infraction predicate Xself :14

Xself ((cid:61), P) :=

(cid:26) 0,

if P never performs selﬁsh signing in (cid:61)

1, otherwise

.

Having introduced Sself and Xself , we prove the following theorem. In the theorem statement,
we deploy the function δ(µ) = 5 · (1 − µ) · µ2 + 6 · (1 − µ)2 · µ3 + 3 · (1 − µ)2 · µ4 + 3 · (1 − µ)3 · µ4,
for µ ∈ (0, 1). The function δ(µ) sets a lower bound on the expected number of blocks that get
discarded every 7 consecutive time slots when a party with staking power µ unilaterally deviates
from σΠ by following Sself . It has a maximum at µ ≈ 0.64469 and δ(0.64469) ≈ 1.03001. In
Table 1, we provide some indicative values of δ(µ), for µ ≤ 1
2 . By the data in Table 1, we
conclude that the block discarding rate remains signiﬁcant even when the party’s staking power
is not particularly high, e.g., µ = 1
5 . This result is a signiﬁcant enhancement of [9], as it provides
quantitative evidence on the eﬀectiveness of the selﬁsh signing strategy against predictable PoS
protocols.

Theorem 9. Let: i) Π be the SL-PoS blockchain protocol speciﬁed in Section 6.1 with block-
proportional rewards (Deﬁnition 9 for ﬁxed block reward R), and assume that Π is also pre-

14Observe that Xself is a special case of the generic family of long-range attacks, i.e., when a party creates a

fork by extending an ancestor block, instead of the longest chain’s head.

26

µ
0.05
0.1
0.15
0.2
0.25

δ(µ)
0.01258
0.05032
0.11228
0.19624
0.29864

µ
0.3
0.35
0.4
0.45
0.5

δ(µ)
0.41462
0.53819
0.66247
0.77994
0.88281

Table 1: Evaluation of δ(µ) = 5 · (1 − µ) · µ2 + 6 · (1 − µ)2 · µ3 + 3 · (1 − µ)2 · µ4 + 3 · (1 − µ)3 · µ4
for various values of µ.

dictable; ii) a synchronous router A; iii) Pmax is the party with the maximum staking power
µPmax.

If R > C and µPmax < 1

2 , then the following hold: i) for every (cid:15) ≥ 0, Π is ((cid:15), Xconf )-compliant
w.r.t. utility Relative Proﬁt; ii) for (cid:15)max := µPmax
R , where δ(µ) = 5 · (1 − µ) · µ2 + 6 ·
7
δ(µPmax
(1 − µ)2 · µ3 + 3 · (1 − µ)2 · µ4 + 3 · (1 − µ)3 · µ4, and every (cid:15) ≤ (cid:15)max, Π is not ((cid:15), Xself )-compliant
w.r.t. utility Relative Proﬁt, in both cases under A.

) −1 · R−C

Proof. First, we express Relative Proﬁt according to the speciﬁcations of Π. Let N ≥ κc be the
number of time slots of the execution, where κ is the security parameter and c is a suﬃciently
large constant. For any party P and strategy proﬁle σ, let MP,(cid:61) be the number of blocks in the
chain output by Ω which are produced by P, and QP,(cid:61) be the number of queries that P makes
to OΠ during the whole execution. Let MP,Eσ , QP,Eσ be the corresponding random variables.
By Eq. (12), we have that if E(cid:2)M ˆP,Eσ

(cid:3) > 0, then

UP (σ) =

E[MP,Eσ ] · R − E[QP,Eσ ] · C
ˆP∈P E(cid:2)M ˆP,Eσ

(cid:3) · R

(cid:80)

.

By Eq. (9), we have that for the all honest strategy proﬁle σΠ it holds that

UP (σΠ) =

µP · N · R − µP · N · C
N · R

= µP ·

R − C
R

.

(13)

(14)

To show the Xconf -compliance of Π, we follow similar steps as in the proof of Theorem 8, yet
we adapt our analysis to the Relative Proﬁt utility. In particular, recall that a strategy proﬁle
σ = (cid:104)S1, . . . , Sn(cid:105) is Xconf -agnostic, if for every i ∈ [n], the strategy Si of Pi does not depend on
the Xconf -compliance of the other parties’ strategies.

In the following claim, we prove that it is not in the parties’ interest to deviate by creating

conﬂicting blocks, when they are behaving according to a Xconf -agnostic strategy proﬁle.
Claim 9.1. Let σ = (cid:104)S1, . . . , Sn(cid:105) /∈ (SXconf )n be a strategy proﬁle, i.e., for some party Pi ∈ P
and some trace (cid:61) where Pi employs Si, it holds that Xconf ((cid:61), Pi) = 1. If σ is also Xconf -agnostic,
then there is a strategy proﬁle σ(cid:48) ∈ (SXconf )n where Pi unilaterally deviates from σ, such that
UPi(σ(cid:48)) > UPi(σ).
Proof of Claim 9.1. We deﬁne σ(cid:48) as follows: in any execution, Pi makes only one query to OΠ
in all time slots that Pi decided to produce conﬂicting blocks w.r.t. σ. Whether Pi decides to
honestly extend the longest chain or to create a fork (e.g., by performing selﬁsh signing) remains
unchanged in any corresponding executions w.r.t. σ or σ(cid:48).

Assume that under σ, Pi is the leader for a sequence of slots r, . . . , r + d, d ≥ 0, and by
creating conﬂicting blocks it produces a tree of blocks signed by Pi, rooted at some block that
was already in the chain when r was reached. Observe that the height of the said tree is at
most d + 1 (if Pi does not abstain at any of slots r, . . . , r + d). This implies that when the
longest chain rule is applied by the other parties and Ω, d(cid:48) ≤ d + 1 blocks of Pi for that period
will be included by following a longest path of length d(cid:48) on the tree. On the other hand, if Pi
behaves w.r.t. σ(cid:48), then a single path of exactly d(cid:48) blocks of Pi will be included in the chain
during r, . . . , r + d. Given that σ is Xconf -agnostic, the other parties’ behavior in σ(cid:48) remains the
same as in σ. So, it holds that E[RPi,Eσ(cid:48) ] = E[RPi,Eσ ] and for every other party ˆP (cid:54)= Pi, it also
holds that E[R ˆP,Eσ(cid:48)

] = E[R ˆP,Eσ

].

27

On the other hand, since σ /∈ (SXconf )n, and since creating conﬂicting blocks costs more than
making only single queries, it holds that there are traces w.r.t. σ where the cost of Pi is strictly
larger than the cost of Pi in the corresponding trace (same random coins) w.r.t. σ(cid:48). Thus, it
holds that E[CPi,Eσ(cid:48) ] < E[CPi,Eσ ].

ˆP∈P E(cid:2)R ˆP,Eσ

Next, we show that the non Xconf -compliance of σ implies an important fact; namely, it holds
(cid:3) > 0, so we are not in the corner case of the branching deﬁnition of UPi(σ)
that (cid:80)
in Eq. (12). Indeed, recall that there are traces (at least one) where Pi creates conﬂicting blocks,
and one of them will be part of the longest chain. We observe that even if it gets discarded by
another party Pj that performs selﬁsh signing, this block of Pi is always replaced by blocks of
Pj. Even in the extreme case where back-to-back selﬁsh signing happens, the blocks of the last
party that performed selﬁsh signing will be included in the chain. More generally, when a party
adds a block in the chain, then we are certain that the chain will contain at least one block in
the end of the execution, so the total rewards in the traces where Pi creates conﬂicting blocks
are a positive value.

Thus, (cid:80)

ˆP∈P E(cid:2)R ˆP,Eσ(cid:48)

(cid:3) = (cid:80)

ˆP∈P E(cid:2)R ˆP,Eσ

(cid:3) > 0, we conclude that

UPi(σ(cid:48)) =

E[RPi,Eσ(cid:48) ] − E[CPi,Eσ(cid:48) ]
ˆP∈P E(cid:2)R ˆP,Eσ(cid:48)

(cid:80)

(cid:3)

>

E[RPi,Eσ ] − E[CPi,Eσ ]
ˆP∈P E(cid:2)R ˆP,Eσ

(cid:80)

(cid:3)

= UPi (σ) .

(cid:97)

Next, in the following claim, we show that by Π’s description, we can focus on Xconf -agnostic

strategy proﬁles.

Claim 9.2. Let σ = (cid:104)S1, . . . , Sn(cid:105) be a non Xconf -agnostic strategy proﬁle. Then, there exists a
strategy proﬁle σ(cid:48) that is Xconf -agnostic and for every Pi ∈ P it holds that UPi(σ(cid:48)) ≥ UPi(σ).
Proof of Claim 9.2. We provide a constructive proof for creating σ(cid:48); by expressing the strategy
Si as an algorithm, since σ is non Xconf -agnostic, for i ∈ [n], Si potentially contains in each
slot r checks of the form “if (A) then{cmdA} else{cmd¬A}”, where (i) A is some condition
related to the other parties’ strategies regarding Xconf -compliance, an (ii) by Π’s description,
the commands cmdA, cmd¬A are selected from the following types of commands:

1. “do nothing”;

2. “abstain from querying OΠ”;

3. “make one query to OΠ and extend the longest chain”; (honest behavior)

4. “make one query to OΠ and create a fork”; (set of commands that includes selﬁsh signing)

5. “make multiple queries to OΠ and extend the longest chain”; (set of commands that

includes creation of conﬂicting blocks)

6. “make multiple queries to OΠ and create forks”; (set of commands)

7. “make at least one query to OΠ but publish no block”; (set of commands)

8. “if (B) then{cmdB} else{cmd¬B}”; (nested if )

We show how we can “remove” checks as above, where in the case of nested if we proceed

from the inner to the outer layer.

An inner layer check contains commands of type 1-7. The crucial observation is that the
change in the utility by the behavior that derives from each of these six types of commands
is independent from other parties’ actions regarding Xconf -compliance. Namely, the change in
rewards and cost by executing a command of type 1-7 is not aﬀected by the case that some
other subset of parties have created conﬂicting blocks or not so far (and when).

Thus, for the check “if (A) then{cmdA} else{cmd¬A}” in slot r, we consider two strategies
Si,A, Si,¬A deﬁned as follows; the party Pi behaves as in Si with the following modiﬁcation: at
slot r, Pi always executes cmdA (resp. cmd¬A) when following Si,A (resp. Si,¬A).

28

Now, let σi,A (resp. σi,¬A) be the strategy proﬁle where Pi follows Si,A (resp. Si,¬A) and all
the other parties follow the same strategy as σ. By the description of Si,A, Si,¬A, we show that
(cid:0)UPi(σi,A) ≥ UPi(σ)(cid:1) ∨ (cid:0)UPi(σi,¬A) ≥ UPi(σ)(cid:1) .

Intuitively, the above holds because the utility of Pi depends on which of the two commands
cmdi,A, cmdi,¬A will be executed, independently of the other parties’ strategies regarding Xconf -
compliance. Formally, we want to prove that it always holds that
UPi(σ) ≤ max(cid:8)UPi(σi,A), UPi(σi,¬A)(cid:9) .

(15)

By the deﬁnition of Si,A, Si,¬A, we have that

Pr[RPi,Eσ − CPi,Eσ = x|A] = Pr[RPi,Eσi,A
Pr[RPi,Eσ − CPi,Eσ = x|¬A] = Pr[RPi,Eσi,¬A

Pr (cid:2) (cid:88)
ˆP∈P

R ˆP,Eσ

= y|A(cid:3) = Pr (cid:2) (cid:88)
ˆP∈P
= y|¬A(cid:3) = Pr (cid:2) (cid:88)
ˆP∈P

Pr (cid:2) (cid:88)
ˆP∈P

R ˆP,Eσ

By the above, we get that

E[RPi,Eσ − CPi,Eσ ] =

(cid:88)

x

Pr[RPi,Eσ − CPi,Eσ = x] · x =

= x]

= x]

− CPi,Eσi,A
− CPi,Eσi,¬A
= y(cid:3)

R ˆP,Eσi,A

R ˆP,Eσi,¬A

= y(cid:3)

Pr[RPi,Eσ − CPi,Eσ = x|A] · x + Pr[¬A] ·

(cid:88)

x

Pr[RPi,Eσ − CPi,Eσ = x|¬A] · x =

Pr[RPi,Eσi,A

− CPi,Eσi,A

= x] · x + Pr[¬A] ·

(cid:88)

x

Pr[RPi,Eσi,¬A

− CPi,Eσi,¬A

= x] · x =

− CPi,Eσi,A

] + (1 − Pr[A]) · E[RPi,Eσi,¬A

− CPi,Eσi,¬A

].

= Pr[A] ·

= Pr[A] ·

(cid:88)

x
(cid:88)

x
= Pr[A] · E[RPi,Eσi,A

and

E(cid:2) (cid:88)
ˆP∈P

(cid:88)

(cid:3) =

R ˆP,Eσ

y

Pr (cid:2) (cid:88)
ˆP∈P

R ˆP,Eσ

= y(cid:3) · y =

= y|A(cid:3) · y + Pr[¬A] ·

= y(cid:3) · y + Pr[¬A] ·

= Pr[A] ·

= Pr[A] ·

(cid:88)

y
(cid:88)

y

R ˆP,Eσ

Pr (cid:2) (cid:88)
ˆP∈P
Pr (cid:2) (cid:88)
ˆP∈P
R ˆP,Eσi,A

R ˆP,Eσi,A

= P r[A] · E(cid:2) (cid:88)
ˆP∈P

(cid:3) + (1 − Pr[A]) · E(cid:2) (cid:88)
ˆP∈P

(16)

(17)

R ˆP,Eσ

= y|¬A(cid:3) · y =

R ˆP,Eσi,¬A

= y(cid:3) · y =

(cid:88)

y
(cid:88)

y

Pr (cid:2) (cid:88)
ˆP∈P
Pr (cid:2) (cid:88)
ˆP∈P
(cid:3)

R ˆP,Eσi,¬A

For simplicity, we set x := Pr[A], a := E[RPi,Eσi,A
E[RPi,Eσi,¬A

], and d := E(cid:2) (cid:80)

− CPi,Eσi,¬A

ˆP∈P R ˆP,Eσi,¬A

− CPi,Eσi,A

], b := E(cid:2) (cid:80)

(cid:3), c :=
(cid:3). By Eq. (12), (16), (17), we have that

ˆP∈P R ˆP,Eσi,A

if x · b + (1 − x) · d > 0
if x · b + (1 − x) · d = 0

UPi(σ) =

UPi(σi,A) =

UPi(σi,¬A) =

(cid:40) x·a+(1−x)·c
x·b+(1−x)·d ,
0,
(cid:26) a
b ,
0,
(cid:26) c
d ,
0,

if b > 0
if b = 0

if d > 0
if d = 0

We study all the following possible cases:

29

• If x · b + (1 − x) · d = 0, then

– If b = 0, then 0 = UPi(σ) = UPi(σi,A).
– If d = 0, then 0 = UPi(σ) = UPi(σi,¬A).

• If x · b + (1 − x) · d > 0 ,then

– If b = 0, then a ≤ 0 and (1 − x) · d > 0. Therefore,

UPi(σ) =

x · a + (1 − x) · c
x · b + (1 − x) · d

≤

(1 − x) · c
(1 − x) · d

=

c
d

= UPi(σi,¬A).

– If d = 0, then c ≤ 0 and x · b > 0. Therefore,

UPi (σ) =

x · a + (1 − x) · c
x · b + (1 − x) · d

≤

x · a
x · b

=

a
b

= UPi(σi,A).

– If b > 0 and d > 0,

∗ If x = 0, then UPi(σ) = c
∗ If x = 1, then UPi(σ) = a
∗ If x ∈ (0, 1) and a

b ≥ c

d , then

d = UPi(σi,¬A).
b = UPi(σi,A).

(1 − x) · c · b ≤ (1 − x) · a · d ⇔ x · a · b + (1 − x) · c · b ≤ x · a · b + (1 − x) · a · d ⇔

⇔

x · a + (1 − x) · c
x · b + (1 − x) · d

≤

a
b

⇔ UPi(σ) ≤ UPi(σi,A).

∗ If x ∈ (0, 1) and a

b < c

d , then

x · c · b > x · a · d ⇔ x · c · b + (1 − x) · c · d > x · a · d + (1 − x) · c · d ⇔

⇔

x · a + (1 − x) · c
x · b + (1 − x) · d

<

c
d

⇔ UPi(σ) < UPi(σi,¬A).

Therefore, for all possible cases Eq. (15) holds. Hence, if UPi(σi,A) ≥ UPi(σ) (resp. UPi(σi,¬A) ≥

UPi(σ)), then we can “keep” Si,A (resp. Si,¬A) that contains one less check than σ and “discard”
the latter. By continuing this process iteratively for all parties, we end up in a strategy proﬁle σ(cid:48)
that contains no checks of the aforementioned form, i.e. σ(cid:48) is Xconf -agnostic. By construction,
it holds that UPi(σ(cid:48)) ≥ UPi(σ).
(cid:97)

Given Claims 9.1 and 9.2, we prove the Xconf -compliance of Π. In particular, we show that

for every (cid:15) ≥ 0, if a strategy proﬁle σ is (cid:15)-reachable from σΠ, then it is Xconf -compliant.

For the sake of contradiction, assume that σ is not Xconf -compliant. The proof is by induction

on the length (cid:96) of the shortest path from σΠ to σ.

• Basis: (cid:96) = 1. If σ is Xconf -agnostic, then by Claim 9.1, σ cannot set a best response for
the party Pi that unilaterally deviates from σΠ. Besides, if σ is not Xconf -agnostic, then
by Claim 9.2, there is a strategy proﬁle σ(cid:48) that is Xconf -agnostic and for which it holds
that UPi(σ(cid:48)) ≥ UPi (σ). Since by Claim 9.1 σ(cid:48) cannot set a best response for the party Pi,
neither σ can set a best response for the party Pi. Therefore, σ is not (cid:15)-directly reachable
from σΠ.

• Induction step: Assume that the statement holds for every (cid:15)-reachable strategy proﬁle
with shortest path of length (cid:96). Let σΠ → σ1 → · · · → σ(cid:96) → σ be the shortest path of
length (cid:96) + 1 from σΠ to σ. Then, σ1, . . . , σ(cid:96) are all Xconf -compliant. By following the
same steps as in Basis, we conclude that, either Xconf -agnostic or not, σ cannot set a best
response for the party that unilaterally deviates from σ(cid:96), thus σ is not (cid:15)-directly reachable
from σΠ.

30

Subsequently, we will prove the non Xself -compliance of Π. We denote by σi the strategy proﬁle
where Pi unilaterally deviates from σΠ by following Sself . Let DPi,Eσi
be the number of blocks
that are discarded due to the selﬁsh signing of Pi w.r.t. σi. By the description of Sself (cf.
Algorithm 2), we have that (i) E[MPi,Eσi
], and (iii)
] = E[MP,EσΠ
(cid:3) = E(cid:2) (cid:80)
E(cid:2) (cid:80)

(cid:3). Thus, by Eq. (13) and (14), we get that

], (ii) E[QPi,Eσi

] = E[QPi,EσΠ

ˆP∈P M ˆP,EσΠ

− DPi,Eσi

ˆP∈P M ˆP,Eσi

UPi(σi) =

µPi · N · R − µPi · N · C
] · R
N · R − E[DPi,Eσi
1

= UPi(σΠ) ·

.

1 −

E[DPi,Eσi
N

]

= µPi ·

R − C
R

·

1

1 −

E[DPi,Eσi
N

]

=

(18)

We will lower bound UPi(σi) by showing a lower bound for E[DPi,Eσi

]. To achieve this,
we devise a selﬁsh signing strategy, Sd≤3, that although less eﬀective than Sself , it captures a
signiﬁcant part of all possible selﬁsh signing attempts in an execution.

The eﬀectiveness of Sd≤3 relies on the fact that the probability the conditions allow for
performing selﬁsh signing of depth d drops exponentially in d. Namely, if we consider the
string schedulePi ∈ {0, 1}N as in Algorithm 2, the probability that for round r, a substring
appears (indicating conditions that allow for performing selﬁsh signing of depth
1 1 · · · 1
0 · · · 0
(cid:124) (cid:123)(cid:122) (cid:125)
(cid:124) (cid:123)(cid:122) (cid:125)
d times
d times
d), is (1 − µPi)d · µd+1
. Therefore, by searching schedulePi for substrings 011, 00111, 0001111
Pi
that correspond to selﬁsh signing at depth up to 3, we can capture a good portion of all available
cases that selﬁsh signing is possible according to schedulePi.

Given the above, Pi follows Sd≤3 by executing the following steps:

1. She fragments schedulePi into 7-bit substrings, where for simplicity we assume that the

length, N , of schedulePi is a multiple of 7.

2. For each 7-bit substring denoted by b1b2b3b4b5b6b7 ∈ {0, 1}7:

(a) She sequentially checks if b1b2b3 = 011, b2b3b4 = 011, b3b4b5 = 011, b4b5b6 = 011,
b5b6b7 = 011. When some of these checks is successful, she performs selﬁsh signing
at depth 1 during the corresponding slot.

(b) If all the above ﬁve checks fail, she sequentially checks if b1b2b3b4b5 = 00111, b2b3b4b5b6 =
00111, b3b4b5b6b7 = 00111. When some of these checks is successful, she performs
selﬁsh signing at depth 2 during the corresponding slot.

(c) If all the above three checks fail, she sequentially checks if b1b2b3b4b5b6b7 = 0001111.
If the check is successful, she performs selﬁsh signing at depth 3 during the corre-
sponding slot.

(d) After all checks are completed, she proceeds similarly with the next 7-bit substring.

Next, we compute the probabilities of the corresponding events. We get that the following

hold:

• Pr[b1b2b3 = 011] = Pr[b2b3b4 = 011] = Pr[b3b4b5 = 011] = Pr[b4b5b6 = 011] = Pr[b5b6b7 =

011] = (1 − µPi) · µ2
Pi

.

• Pr[b1b2b3b4b5 = 00111] = Pr[b2b3b4b5b6 = 00111] = Pr[b3b4b5b6b7 = 00111] = (1 − µPi)2 ·

µ3
Pi

.

• Pr[b1b2b3b4b5b6b7 = 0001111] = (1 − µPi)3 · µ4
Pi
• Pr[(b1b2b3 = 011) ∧ (b4b5b6 = 011)] = Pr[(b1b2b3 = 011) ∧ (b5b6b7 = 011)] = Pr[(b2b3b4 =
, while the probability of any other conjuction of

.

011) ∧ (b5b6b7 = 011)] = (1 − µPi )2 · µ4
Pi
events is 0.

31

Let σi,d≤3 be the strategy proﬁle where Pi unilaterally deviates from σΠ by following Sd≤3.
Let DPi,b1−7 be the number of blocks that are discarded during the 7 consecutive slots that
correspond to a single 7-bit substring due to the selﬁsh signing of Pi w.r.t. σi,d≤3. By the above,
we have that

E[DPi,b1−7] =

3
(cid:88)

j=1

j · Pr[exactly j blocks are discarded in b1b2b3b4b5b6b7] =

Pi

=1 · (cid:0)5 · (1 − µPi) · µ2
2 · (cid:0)3 · (1 − µPi)2 · µ3
Pi
3 · (1 − µPi)3 · µ4
=
Pi
+ 6 · (1 − µPi)2 · µ3
=5 · (1 − µPi) · µ2
Pi
Pi

− 3 · (1 − µPi)2 · µ4
Pi
+ 3 · (1 − µPi)2 · µ4
Pi

(cid:1)+
(cid:1)+

+ 3 · (1 − µPi)2 · µ4
Pi

+ 3 · (1 − µPi)3 · µ4
Pi

.

Let δ(µPi) := E[DPi,b1−7] Let DPi,Eσi,d≤3

be the total number of blocks that are discarded
due to the selﬁsh signing of Pi w.r.t. σi,d≤3 during the execution. Since the examination of
these events is independent across the 7-bit substrings, we have that

E[DPi,Eσi,d≤3

] =

N
7

· δ(µPi) .

(19)

By the description of Sself and Sd≤3, it is straightforward that E[DPi,Eσi

] > E[DPi,Eσi,d≤3

].

Thus, by Eq. (14), (18) and (19), we have that

UPi(σi) > UPi(σΠ) ·

1
N
7 ·δ(µPi )
N

1 −

= UPi(σΠ) ·

(cid:16)

1 +

1
δ(µPi ) − 1

7

(cid:17)

=

= UPi(σΠ) +

µPi
7
δ(µPi )−1

·

R − C
R

.

The function δ(µ) = 5 · (1 − µ) · µ2 + 6 · (1 − µ)2 · µ3 + 3 · (1 − µ)2 · µ4 + 3 · (1 − µ)3 · µ4 is
R is also increasing on
R , we have that for every (cid:15) ≤ (cid:15)max, it

increasing on the interval (0, 0.64469], therefore the function
the same interval. So, by setting (cid:15)max := µPmax
7
δ(µPmax
holds that

δ(µ) −1 · R−C

) −1 · R−C

µ

7

UPmax (σmax) > UPmax(σΠ) + (cid:15) ,

where in σmax is the strategy proﬁle that the party Pmax unilaterally deviates from σΠ by
following Sself .

It remains to show that the best response for some party Pi that unilaterally deviates from
σΠ is not Xself -compliant. In fact, we will show something stronger; for every strategy proﬁle σ
that is a Xself -compliant unilateral deviation of Pi, it holds that UPi(σ) ≤ UPi(σΠ).

By the (0, Xconf )-compliance of σΠ, we have that it is in Pi’s interest to make only one
query to OΠ, if she decides to participate at a given slot. Thus, it suﬃces to focus on strategy
proﬁles that are not Xabs-compliant. So, assume that there are execution traces w.r.t. σ where
Pi abstains at certain slots. However, each time Pi decides to abstain, she loses an amount
R − C on her overall proﬁt while, since we assumed that σ is Xself -compliant, the other (honest)
parties’ rewards remain unaﬀected. Therefore, by abstaining, Pi only reduces the contribution
to the her own utility.15. Formally, let APi,Eσ be the number of times that Pi decides to abstain.

15Note that this does not imply the Xabs-compliance of σΠ, only that it is not in the party’s interest to

unilaterally deviate from σΠ by just abstaining.

32

Since E[APi,Eσ ] > 0, we have that

UPi(σ) =

=

(µPi · N − E[APi,Eσ ]) · R − (µPi · N − E[APi,Eσ ]) · C
(N − E[APi,Eσ ]) · R
R − C
R

µPi · N − E[APi,Eσ ]
N − E[APi,Eσ ]

µPi · (N − E[APi,Eσ ])
N − E[APi,Eσ ]

<

·

=

·

R − C
R

=

= µPi ·

R − C
R

= UPi(σΠ) .

Finally, given that (i) for every (cid:15) ≤ (cid:15)max, it holds that UPmax(σmax) > UPmax(σΠ) + (cid:15) and (ii)
the best response for any party is not Xself -compliant, we conclude that for every (cid:15) ≤ (cid:15)max, the
protocol Π is not ((cid:15), Xself )-compliant w.r.t. Relative Proﬁt.

Remark. Sself , although proﬁtable, as shown in Theorem 9, is not optimal.
Indeed, one
may consider incremental improvements by combining the selﬁsh signing behavior with other
infractions, such as strategically abstaining during some slots. On that account, obtaining an
optimal attack that exploits selﬁsh signing and identifying for which infractions such attack is
non-compliant is an interesting future research direction.

7 Externalities

In practice, blockchains coexist with other systems, which may aﬀect the participants’ behavior.
This section enhances our analysis with parameters external to the ledger. We introduce an
exchange rate, to account rewards in the same unit as costs, and analyze how it should behave
to ensure compliance, assuming infractions yield an external utility, and ﬁnally take penalties
into account.

7.1 Utility

In distributed ledger systems, rewards are denominated in the ledger’s native currency, but cost
is typically denominated in ﬁat. Therefore, we introduce an exchange rate, between the ledger’s
native currency and USD, to denominate the rewards and cost in the same unit of account and
precisely estimate a party’s utility. The exchange rate XE is a random variable, parameterized
by a strategy proﬁle σ. For a trace (cid:61)σ under σ, the exchange rate takes a non-negative real
value. The exchange rate is applied once, at the end of the execution. Intuitively, this implies
that a party eventually sells their rewards at the end of the execution. Therefore, its utility
depends on the accumulated rewards, during the execution, and the exchange rate at the end.
The infraction predicate expresses a deviant behavior that parties may exhibit. So far, we
considered distributed protocols in a standalone fashion, analyzing whether they incentivize
parties to avoid infractions. In reality, a ledger exists alongside other systems, and a party’s
utility may depend on parameters external to the distributed ledger. For instance, double
spending against Bitcoin is a common hazard, which does not increase an attacker’s Bitcoin
rewards, but awards them external rewards, e.g., goods that are purchased with the double-
spent coins.

The external – to the ledger – reward is modeled as a random variable BP,Eσ , which takes
non-negative integer values. Similarly to the rewards’ random variable, it is parameterized by
a party P and a strategy proﬁle σ. The infraction utility is applied once when computing a
party’s utility and has the property that, for every trace (cid:61) during which a party P performs
no infraction, it holds that BP,(cid:61) = 0, i.e., a party receives these external rewards only by
performing an infraction.

We deﬁne a new utility function U , which also takes two forms, Reward and Proﬁt. For
the former, U applies the exchange rate on the protocol rewards and adds the external. For
Proﬁt, it also subtracts the cost. Deﬁnition 10 deﬁnes the utility under externalities. For ease
of notation, we set the following:

33

• ρP,σ = E[RP,EZ,A,σ ];
• xσ = E[XEZ,A,σ ];
• bP,σ = E[BP,EZ,A,σ ];
• cP,σ = E[CP,EZ,A,σ ].

As in Section 3.2, when computing the utility, the environment and the router are ﬁxed.

Deﬁnition 10. Let: i) σ be a strategy proﬁle; ii) Eσ be an execution under σ; iii) xσ be the
(expected) exchange rate of Eσ; iv) bP,σ be the (expected) external rewards of P under σ. We
deﬁne two types of utility UP of a party P for σ under externalities:

1. Reward: UP (σ) = ρP,σ · xσ + bP,σ;

2. Proﬁt: UP (σ) = ρP,σ · xσ + bP,σ − cP,σ.

7.2 Compliance

To evaluate compliance under externalities, we will ﬁnd a relation between the assets’ price and
external, infraction-based rewards, s.t. the former counters the latter, hence parties are incen-
tivized to remain compliant. Speciﬁcally, it suﬃces to show that the exchange rate reduction
counterbalances the external rewards. More formally, Theorem 10 analyzes SL-PoS under a
synchronous network and externalities; similar statements can be made for the positive results
of Sections 4 and 5.1.

Theorem 10. Assume i) a synchronous router A (cf. Section 2.1), ii) the conﬂicting predicate
Xconf , and iii) that ∀P ∈ P : µP < 1
2 . Also let: i) S−Xconf : the set of all non Xconf -compliant
strategies; ii) xσΠ : the (expected) exchange rate under EσΠ ; iii) xσSP
: the (expected) exchange
rate when only P employs some non Xconf -compliant strategy SP ; iv) bP,σSP
: the external utility
that SP yields for P.

SL-PoS with block-proportional rewards (cf. Deﬁnition 9, for ﬁxed block reward R) under the
aforementioned externalities is not ((cid:15), Xconf )-compliant (cf. Deﬁnition 5) w.r.t. utility Reward
(cf. Deﬁnition 7) and, if R > C, it is also not ((cid:15), Xconf )-compliant w.r.t. utility Proﬁt, in both
}}, 0}.
cases under A and if and only if (cid:15) < max{max
P∈P

− xσΠ ) + bP,σSP

{ρP,σΠ · (xσSP

{ max
SP ∈S−Xconf

Proof. Following the same reasoning as Theorem 5, if a party P deviates by only producing
conﬂicting messages, but does not abstain, its expected rewards are the same as following the
protocol; speciﬁcally, due to network synchronicity, after every round when P is leader, every
other party adopts one of the blocks produced by P (although possibly not everybody adopts
the same block), and, since all these blocks are part of the (equally-long) longest chain (at that
point), eventually one of these blocks will be output in the chain of the observer. Consequently,
it holds that ρP,σSP

Second, the maximum additional utility that a party P may receive by deviating from the
}.

honest protocol via producing conﬂicting blocks is:

= ρP,σΠ .

{ρP,σΠ · (xσSP

− xσΠ) + bP,σSP

max
SP ∈S−Xconf

Therefore, if for at least one party this value is non-negligible, (cid:15) is not small enough and so the
protocol is not compliant.

The previous sections oﬀer non-compliance, negative results in PoS systems where (a) resource-

proportional rewards are employed and (b) a party is incentivized to produce multiple conﬂicting
messages, i.e., under a lossy network or multiple leaders per slot.

Regarding (a), Section 4 shows that resource-proportional rewards ensure compliance under
utility Reward, but non-compliance regarding proﬁt. Speciﬁcally, assuming a minimal participa-
tion cost C ⊥
P , we showed that, if P abstains, they incur zero cost without any reward reduction.
To explore compliance of resource-proportional rewards under externalities, we consider two
strategy proﬁles σΠ, σSP , as before. Notably, SP is the abstaining strategy which, as shown
in Section 4, maximizes utility in the standalone setting. For the two proﬁles, the proﬁt for P
respectively. Again, in both cases the
becomes ρP,σΠ · xσΠ − cP,σΠ and ρP,σSP

+ bP,σSP

· xσSP

34

party’s rewards are equal. Therefore, since it holds that C ⊥
((cid:15), Xconf )-compliant (for some (cid:15)) if:

P ≤ cP,σΠ, P is incentivized to be

ρP,σSP

· xσSP

+ bP,σSP

≤ ρP,σ · xσΠ − cP,σΠ + (cid:15) ⇒ C ⊥

P + bP,σSP

≤ ρP,σΠ · (xσΠ − xσSP

) + (cid:15)

If the abstaining strategy yields no external rewards, as is typically the case, bP,σSP
exchange rate needs to only counterbalance the minimal participation cost.

= 0, so the

Regarding (b), we consider single-leader PoS under a lossy network, since the analysis is
similar for multi-leader PoS. We again consider two strategy proﬁles σΠ, σSP as above. Now,
under σSP , P produces k blocks during each slot for which it is leader, to increase the proba-
bility that at least one of them is output in the observer’s ﬁnal chain. Also, for simplicity, we
) if
set bP,σSP
xσSP
tion 5.2.2.

= 0. These PoS systems become ((cid:15)(cid:48), Xconf )-compliant (for (cid:15)(cid:48) =

1−dk·(1−d)2 · xσΠ + (cid:15)(cid:48) where Rmax = R · (cid:80)

i∈[1,e] le · µP,i and d, R, le are as in Subsec-

(cid:15)
(1−dk·(1−d)2)·Rmax

≤ 1−d·(1−d)2

7.3 Attacks and Market Response

To estimate the exchange rate’s behavior vis-`a-vis external infraction rewards, we turn to his-
torical data from the cryptocurrency market. Although no infractions of the type considered in
this work have been observed in deployed PoS systems, we extrapolate data from similar attacks
against PoW cryptocurrencies (Table 2).

System

Date

External Utility Rewards Reward Diﬀerence Attack Hash Rate %

5/1/19 [76]

Ethereum

1/8/20 [86]

Classic

6/8/20 [87]

Horizen

8/6/18 [92]

Vertcoin

2/12/18 [75]

Bitcoin Gold

16/5/18 [79]

23/1/20 [65]

Feathercoin

1/6/13 [68]

$1.1M
$5.6M
$1.68M

$550, 000

$100, 000

$17.5M
$72, 000

$63, 800

$12.410
$84, 059
$91, 715

$5, 756

$3, 978

$11, 447
$4, 247

$1, 203

$−2, 646
$−11, 806
$−5, 761

$−752

$−879

$−1, 404
$814

$−95.73

0.48026

0.4913

0.4913

0.461373

0.487124

0.441631

0.43991

0.48283

Table 2: Double spending attacks and the market’s response to them. External utility is
estimated as the reward from double-spent transactions. To compute the reward diﬀerence, we
multiply the rewards from reorganized blocks with the exchange rate diﬀerence, i.e., the asset’s
price 5 days after the attack minus the expected price, if an attack had not occurred (following
Bitcoin’s price in the same period).

In the considered attacks, the perpetrator M performed double spending. Speciﬁcally, M
created a fork and two conﬂicting transactions, each published on the two chains of the fork, the
main and the adversarial chain. The main chain’s transaction is redeemed for external rewards,
e.g., a payment in USD, while the adversarial chain’s transaction transfers the assets between
two accounts of M. Therefore, M both receives external rewards and retains its cryptocurrency
rewards.

The adversarial chain contains a number of blocks created by M. After this chain becomes
longest and is adopted by the network, M sells its block rewards for USD. To evaluate the
exchange rate at this point, we set the period between the launch of the attack and the (pre-
sumable) selling of the block rewards to 5 days. This value depends on various parameters. For
instance, in Bitcoin, the rewards for a block B can be redeemed after a “coinbase maturity”
period of 100 conﬁrmations, i.e., after at least 100 blocks have been mined on top of B (equiv.
17 hours).16 Furthermore, transactions are typically not ﬁnalized immediately; for instance,
most parties ﬁnalize a Bitcoin transaction after 6 conﬁrmations and an Ethereum transaction

16A Bitcoin block is created on expectation every 10 minutes.

35

after 240 conﬁrmations (equiv. approximately 1 hour). Usually this restraint is tightened [89]
after an attack is revealed.

To estimate the diﬀerence in rewards that an infraction eﬀects, we use cryptocurrency prices
from Coinmarketcap.17 First, we obtain the price PC of each cryptocurrency C 5 days after
the attack. Second, we compute the percentage diﬀerence pBT C of Bitcoin’s price, between the
end and the beginning of the 5 day period. The value PC · pBT C expresses the expected price of
the cryptocurrency, assuming no attack had occurred.18 Next, we ﬁnd the number b of blocks
created in the attack and the reward R per block. Thus, the reward diﬀerence is PC · pBT C · b · R.
As shown in [41, 22], this attack is optimal. Therefore, using the computations in [73] and
the reorganized blocks during each attack, we approximate the percentage of power needed so
that the attack’s success probability is at least 0.5.

7.4 Penalties

Historically (cf. Subsection 7.3), attacks are proﬁtable, so the market’s response is typically
insuﬃcient to incentivize compliance. Interestingly, in many occasions the external utility was
so high that, even if the exchange rate became 0, it would exceed the amount of lost rewards.
Therefore, an additional form of utility reduction is necessary to prevent any speciﬁc infraction
that is essential to mount attacks similar to those presented in Subsection 7.3. In many PoS
systems, like Casper [11, 13], Gasper [12], and Tezos [88], a form of utility reduction has been
implemented in the form of penalties. In eﬀect, each party P is required to deposit an amount
of assets gP , which it forfeits if it violates a well-deﬁned condition.

Under penalties, P’s reward is as follows. Consider proﬁles σΠ, σSP as before. With σΠ, P
receives ρP,σΠ and retains its deposit gP , both exchanged at rate xσΠ. With σSP , P forfeits
its rewards and deposit, but receives external utility bP,σSP
. Thus, under penalties a party is
incentivized to be compliant if the deposit and rewards are larger than the external utility. Note
that Theorem 11’s (cid:15) bound is tighter than that of Theorem 10, so penalties can make infractions
less appealing.

Theorem 11. Assume i) a synchronous router A (cf. Section 2.1), ii) the conﬂicting predicate
Xconf , and iii) that ∀P ∈ P : µP < 1
2 . Also let: i) S−Xconf : the set of all non-compliant strategies;
: the (expected) exchange rate when
ii) xσΠ : the (expected) exchange rate under σΠ; iii) xσSP
only P employs some non-compliant conﬂicting strategy SP ; iv) bP,σSP
: the external utility that
SP yields for P; v) and ρP,σ = E[RP,Eσ ], i.e., the expected rewards of P under proﬁle σ. Finally,
assume the block-proportional rewards (cf. Deﬁnition 9 for ﬁxed block reward R) for which it
also holds:

∀(cid:61) ∀P ∈ P : RP,(cid:61) =

(cid:26) (cid:37)(CΩ,(cid:61), P) · RΩ,(cid:61) + gP , P produces no conﬂicting blocks during (cid:61)

0,

otherwise

where gP is a protocol-speciﬁc deposit value. SL-PoS with the above rewards and under the
aforementioned externalities is not ((cid:15), Xconf )-compliant (cf. Deﬁnition 5) w.r.t. utility Reward
(cf. Deﬁnition 7) and, if R > C, it is also not ((cid:15), Xconf )-compliant w.r.t. utility Proﬁt, in both
}} − ρP,σΠ · xσΠ , 0} − negl(κ).
cases under A and if and only if (cid:15) < max{max
P∈P

{bP,σSP

{ max
SP ∈S−Xconf

Proof. When a party P employs a non-compliant strategy SP , it receives an external utility
. Also, in that case, it produces conﬂicting blocks (due to the non-compliance property
bP,σSP
= 0; in other
of SP ). Therefore, by deﬁnition of the above block-proportional rewards, RP,σSP
words, when P employs SP and produces conﬂicting blocks, P forfeits the protocol’s rewards
(which include the original rewards plus the deposit gP ). Therefore, when P employs SP and
all other parties employ Π, P’s utility is UP (σSP ) = bP,σSP

(cf. Deﬁnition 10).

We also remind that (from the proof of Theorem 5), P can bias the leader schedule with

some negligible probability negl(κ), if it controls a minority of power.

17https://coinmarketcap.com/
18Historically, the prices of Bitcoin and alternative cryptocurrencies are strongly correlated [60].

36

Therefore, for any party P and strategy SP , σSP is directly (cid:15)-reachable from σΠ if:

ρP,σΠ · xσΠ + negl(κ) + (cid:15) < bP,σSP
⇔ (cid:15) < bP,σSP

⇔

− ρP,σΠ · xσΠ − negl(κ)

Across all parties and all non-compliant strategies, the maximum such (cid:15) is:

(cid:15) < max
P∈P

{ max

SP ∈S−Xconf

{bP,σSP

}} − ρP,σΠ · xσΠ − negl(κ)

We note that, as shown in Theorem 5, SL-PoS with block proportional rewards under a
synchronous router is an equilibrium, i.e., the honest protocol yields the maximum rewards for
each party compared to all other strategies. In the present setting, the honest protocol again
yields the maximum utility, compared to all other compliant strategies. To prove this it suﬃces
to observe that, if a party does not produce conﬂicting blocks, its rewards are a linear function
of the rewards of the setting of Theorem 5; therefore, between compliant strategies, the honest
protocol yields the maximum rewards (as shown in Theorem 5).

Therefore, the given bound of (cid:15) is bounded from below and, for (cid:15) less than this bound, there
exists a party P that is incentivized to employ a (non-compliant) strategy SP and produce
conﬂicting blocks, rendering Π not ((cid:15), Xconf )-compliant.

The (cid:15) bounds in Theorems 10 and 11 depend on the external utility boost bP,σSP

. This
highlights the inherent limitations of such systems’ designers, since the bound depends on exter-
nal (to the protocol) parameters. Intuitively, these bounds show that attacks which utilize the
Xconf infraction can be prevented in two ways. First, larger deposits increase the threshold that
makes some attacks proﬁtable. However, they also shut oﬀ small parties, with inadequate assets.
Therefore, a tradeoﬀ exists in preventing such attacks and enabling participation. Second, the
longer an attack’s duration, the more blocks an adversary needs to produce, hence the larger
the rewards that it forfeits. Typically, the attack’s duration depends on the required number
of conﬁrmations for a transaction to be ﬁnalized. Therefore, diﬀerent conﬁrmation limits, e.g.,
based on a transaction’s value, could satisfy the tradeoﬀ between fast settlement and security.
Considering the latter observation, we now brieﬂy review users’ behavior in SL-PoS (cf.
Section 5.2.1) under deposits and penalties. In an SL-PoS execution, the percentage of parties
that actively participate during each epoch is identiﬁable via the block density and the number
of empty slots (when no block is diﬀused). Therefore, it is possible to estimate the level of
double-signing that a party needs to perform to mount a double-spending attack, and then
enforce a transaction ﬁnalization rule to dis-incentivize such attacks.

Let P be a user of an SL-PoS ledger. P requires k conﬁrmations, i.e., ﬁnalizes a transaction
after it is “buried” under k blocks. Let τ be a transaction, published on slot r, with value vτ .
After l slots, τ is buried under b blocks, with b = x · l for some x ∈ (0, 1). In case we have full
participation in the protocol and the adversary is bounded by 1
2 ; in the rest of
the section, we will focus on this setting. Observe that (1 − x) · 100% of slots will be – seemingly
– empty. P will (on expectation) conﬁrm τ after 1
x · k slots, i.e., when k blocks are produced; of
these, 1−x

2 , it holds x > 1

x · k are empty.

x

x · k = 2·x−1

Let M be a party that wants to double-spend τ . M should produce a private chain with
at least k blocks. Of these, at most 1−x
· k correspond to the respective empty slots, while
x
k − 1−x
· k conﬂict with existing blocks, i.e., are evidence of infraction. Let d be
a deposit amount, which corresponds to a single slot. Thus, for a period of t slots, the total
deposited assets D = t · d are distributed evenly across all slots. M can be penalized only
for infraction blocks, i.e., for slots which showcase conﬂicting blocks. In a range of 1
x · k slots,
infraction slots are 2·x−1
· k · R
in rewards that correspond to infraction blocks. Thus, if vτ > 2·x−1
·k ·(d+R), M can proﬁtably
double-spend τ . Consequently, depending on the amount d of deposit per slot, the block reward
R, and the rate (1 − x) of empty slots, for a transaction τ with value vτ , P should set the
conﬁrmation window’s size to:

· k. Therefore, M forfeits at most 2·x−1

· k · d in deposit and 2·x−1

x

x

x

x

kτ >

2·x−1
x

vτ
· (d + R)

37

(20)

Finally, the system should allow each participant to withdraw their deposit after some time.
However, it should also enforce some time limit, such deposits are adequate to enforce (possible)
penalties. Intuitively, a party P should be able to withdraw a deposit amount that corresponds
to a slot r, only if no transaction exists, such that r is part of the window of size k (computed
as above). In other words, P’s deposit should be enough to cover all slots, which P has led and
which are part of the conﬁrmations’ window of at least one non-ﬁnalized transaction.

Remark. The correctness of the penalty enforcement mechanism should be veriﬁable by only
parsing the ledger, i.e., in a non-interactive manner. Interestingly, it might be impossible to
create such (non-interactive) proofs of misbehavior for some predicates. For example, in a semi-
synchronous network, block withholding (e.g., selﬁsh mining) is indistinguishable from behavior
that occurs due to benign network delays. In those cases, the protocol’s designer cannot rely on
reward distribution and penalization to enforce compliance; instead, the utility should reﬂect
resistance to such infractions, e.g., via extra costs. Additionally, penalties are not applicable if
the block’s creators cannot be identiﬁed, e.g., as in PoW, where block producers are decoupled
from the users, and anonymous protocols [70, 8, 37, 51].

8 Conclusion

Our work explores the ability of blockchain designs to disincentivize infractions. Inspired by
Nash dynamics, we present a model for strategic compliance, i.e., rational participant behavior
that, while it does not violate well-deﬁned properties, it may potentially exhibit “compliant”
protocol deviations. We focus primarily on two blockchain-related infractions, abstaining and
same-origin conﬂicting blocks. Given two types of utility, “rewards” and “proﬁt”, we analyze
compliance of various protocols, oﬀering both positive and negative results: i) PoS blockchains
that employ resource-proportional rewards, i.e., which depend solely on a party’s power, are com-
pliant w.r.t. rewards, but non-compliant w.r.t. proﬁt, as they incentivize abstaining; ii) PoW
systems with block-proportional rewards are compliant; iii) compliance of PoS systems, which
enforce a single participant per slot, depends on the network’s lossiness; iv) PoS systems where
multiple participants per slot may act are non-compliant, under certain network routing condi-
tions, as they incentivize producing conﬂicting blocks; v) PoS systems that are compliant w.r.t.
producing conﬂicting blocks, but non-compliant w.r.t. abstaining or performing a selﬁsh signing
attack. Finally, we consider externalities, namely the assets’ market price and external proceed-
ings of a successful attack. We show that, if the market does not respond decisively when an
attack occurs, infractions that yield such proceedings may render protocols non-compliant. We
also suggest a mitigation that combines two approaches in the context of longest chain protocols:
i) deposits, which are potentially used for penalizing misbehavior; ii) an adaptive transaction
ﬁnality rule, applied by users, which increases the number of blocks an attacker has to create to
discard a ﬁnalized high-value transaction.

Our work opens various lines for future work. First, alternative infraction predicates and
utilities could be explored, e.g., to capture attacks such as selﬁsh mining and double spending.
For instance, given that Bitcoin is not an equilibrium w.r.t.
relative rewards due to selﬁsh
mining, proving compliance for this utility would be a rather promising result. Also we only
consider rewards that originate from the system; however, in real world systems, a party may
also receive assets via reward transfers from another party. Introducing transfers would enrich
the strategy set, e.g., allowing a party to temporarily reduce its rewards for long term proﬁts,
possibly aﬀecting compliance in terms of coalition forming. Finally, Section 7 assumes that
the exchange rate and protocol rewards are independent random variables; future work could
explore possible correlations between the two and produce an analysis that can be (arguably)
closer to the real world. In addition, our analysis treated changes in the market price as an
eﬀect of infractions; an interesting question is whether price volatility (e.g., as examined in [78])
can be the cause of non-compliance.

38

References

[1] Hamza Abusalah, Jo¨el Alwen, Bram Cohen, Danylo Khilko, Krzysztof Pietrzak, and Leonid
Reyzin. Beyond hellman’s time-memory trade-oﬀs with applications to proofs of space. In
Tsuyoshi Takagi and Thomas Peyrin, editors, Advances in Cryptology – ASIACRYPT 2017,
Part II, volume 10625 of Lecture Notes in Computer Science, pages 357–379, Hong Kong,
China, December 3–7, 2017. Springer, Heidelberg, Germany.

[2] Nick Arnosti and S. Matthew Weinberg. Bitcoin: A natural oligopoly. In Avrim Blum,
editor, ITCS 2019: 10th Innovations in Theoretical Computer Science Conference, volume
124, pages 5:1–5:1, San Diego, CA, USA, January 10–12, 2019. LIPIcs.

[3] Sarah Azouvi, George Danezis, and Valeria Nikolaenko. Winkle: Foiling long-range attacks
in proof-of-stake systems. Cryptology ePrint Archive, Report 2019/1440, 2019. https:
//eprint.iacr.org/2019/1440.

[4] Sarah Azouvi, Patrick McCorry, and Sarah Meiklejohn. Betting on blockchain consensus

with fantomette, 2018.

[5] Christian Badertscher, Juan A. Garay, Ueli Maurer, Daniel Tschudi, and Vassilis Zikas.
But why does it work? A rational protocol design treatment of bitcoin. In Nielsen and
Rijmen [77], pages 34–65.

[6] Christian Badertscher, Peter Gazi, Aggelos Kiayias, Alexander Russell, and Vassilis Zikas.
Ouroboros genesis: Composable proof-of-stake blockchains with dynamic availability. In
David Lie, Mohammad Mannan, Michael Backes, and XiaoFeng Wang, editors, ACM
CCS 2018: 25th Conference on Computer and Communications Security, pages 913–930,
Toronto, ON, Canada, October 15–19, 2018. ACM Press.

[7] William J Baumol. Welfare economics and the theory of the state. In The encyclopedia of

public choice, pages 937–940. Springer, 2004.

[8] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran
Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from bitcoin.
In 2014 IEEE Symposium on Security and Privacy, pages 459–474, Berkeley, CA, USA,
May 18–21, 2014. IEEE Computer Society Press.

[9] Jonah Brown-Cohen, Arvind Narayanan, Alexandros Psomas, and S. Matthew Weinberg.
Formal barriers to longest-chain proof-of-stake protocols. In Anna Karlin, Nicole Immorlica,
and Ramesh Johari, editors, Proceedings of the 2019 ACM Conference on Economics and
Computation, EC 2019, Phoenix, AZ, USA, June 24-28, 2019, pages 459–473. ACM, 2019.

[10] Vitalik Buterin. On stake, 2014. https://blog.ethereum.org/2014/07/05/stake/.

[11] Vitalik Buterin and Virgil Griﬃth. Casper the friendly ﬁnality gadget. arXiv preprint

arXiv:1710.09437, 2017.

[12] Vitalik Buterin, Diego Hernandez, Thor Kamphefner, Khiem Pham, Zhi Qiao, Danny Ryan,

Juhyeok Sin, Ying Wang, and Yan X Zhang. Combining ghost and casper, 2020.

[13] Vitalik Buterin, Dani¨el Reijsbergen, Stefanos Leonardos, and Georgios Piliouras. Incentives
in ethereum’s hybrid casper protocol. In IEEE International Conference on Blockchain and
Cryptocurrency, ICBC 2019, Seoul, Korea (South), May 14-17, 2019, pages 236–244. IEEE,
2019.

[14] Miles Carlsten, Harry A. Kalodner, S. Matthew Weinberg, and Arvind Narayanan. On the
instability of bitcoin without the block reward. In Weippl et al. [90], pages 154–167.

[15] Jing Chen, Sergey Gorbunov, Silvio Micali, and Georgios Vlachos. ALGORAND AGREE-
MENT: Super fast and partition resilient byzantine agreement. Cryptology ePrint Archive,
Report 2018/377, 2018. https://eprint.iacr.org/2018/377.

39

[16] Xi Chen, Christos H. Papadimitriou, and Tim Roughgarden. An axiomatic approach to
block rewards. In Proceedings of the 1st ACM Conference on Advances in Financial Tech-
nologies, AFT 2019, Zurich, Switzerland, October 21-23, 2019, pages 124–131. ACM, 2019.

[17] Steve Chien and Alistair Sinclair. Convergence to approximate nash equilibria in congestion

games. Games Econ. Behav., 71(2):315–327, 2011.

[18] Bram Cohen and Krzysztof Pietrzak. Simple proofs of sequential work.

In Nielsen and

Rijmen [77], pages 451–467.

[19] Bernardo David, Rafael Dowsley, and Mario Larangeira. Kaleidoscope: An eﬃcient poker
protocol with payment distribution and penalty enforcement. In Meiklejohn and Sako [69],
pages 500–519.

[20] Bernardo David, Rafael Dowsley, and Mario Larangeira. ROYALE: A framework for univer-
sally composable card games with ﬁnancial rewards and penalties enforcement. In Goldberg
and Moore [45], pages 282–300.

[21] Bernardo David, Peter Gazi, Aggelos Kiayias, and Alexander Russell. Ouroboros praos:
An adaptively-secure, semi-synchronous proof-of-stake blockchain. In Nielsen and Rijmen
[77], pages 66–98.

[22] Amir Dembo, Sreeram Kannan, Ertem Nusret Tas, David Tse, Pramod Viswanath, Xuechao
Wang, and Ofer Zeitouni. Everything is a race and nakamoto always wins. In Ligatti et al.
[63], pages 859–878.

[23] Thomas Dinsdale-Young, Bernardo Magri, Christian Matt, Jesper Buus Nielsen, and Daniel
In Galdi and

Tschudi. Afgjort: A partially synchronous ﬁnality layer for blockchains.
Kolesnikov [36], pages 24–44.

[24] John R Douceur. The sybil attack.
pages 251–260. Springer, 2002.

In International workshop on peer-to-peer systems,

[25] Stefan Dziembowski, Sebastian Faust, Vladimir Kolmogorov, and Krzysztof Pietrzak.
Proofs of space. In Rosario Gennaro and Matthew J. B. Robshaw, editors, Advances in
Cryptology – CRYPTO 2015, Part II, volume 9216 of Lecture Notes in Computer Science,
pages 585–605, Santa Barbara, CA, USA, August 16–20, 2015. Springer, Heidelberg, Ger-
many.

[26] Ethereum.

Proof

of

stake

faqs,

2018.

https://eth.wiki/en/concepts/

proof-of-stake-faqs.

[27] EthHub. Eth 2.0 economics, 2021.

[28] Ittay Eyal, Adem Efe Gencer, Emin G¨un Sirer, and Robbert Van Renesse. Bitcoin-ng: A
scalable blockchain protocol. In 13th {USENIX} symposium on networked systems design
and implementation ({NSDI} 16), pages 45–59, 2016.

[29] Ittay Eyal and Emin G¨un Sirer. Majority is not enough: Bitcoin mining is vulnerable.
In Nicolas Christin and Reihaneh Safavi-Naini, editors, FC 2014: 18th International Con-
ference on Financial Cryptography and Data Security, volume 8437 of Lecture Notes in
Computer Science, pages 436–454, Christ Church, Barbados, March 3–7, 2014. Springer,
Heidelberg, Germany.

[30] Alex Fabrikant, Christos H. Papadimitriou, and Kunal Talwar. The complexity of pure
nash equilibria. In L´aszl´o Babai, editor, Proceedings of the 36th Annual ACM Symposium
on Theory of Computing, Chicago, IL, USA, June 13-16, 2004, pages 604–612. ACM, 2004.

[31] Giulia C. Fanti, Leonid Kogan, Sewoong Oh, Kathleen Ruan, Pramod Viswanath, and
Gerui Wang. Compounding of wealth in proof-of-stake cryptocurrencies. In Goldberg and
Moore [45], pages 42–61.

40

[32] Matheus V. X. Ferreira and S. Matthew Weinberg. Proof-of-stake mining games with
perfect randomness. In P´eter Bir´o, Shuchi Chawla, and Federico Echenique, editors, EC
’21: The 22nd ACM Conference on Economics and Computation, Budapest, Hungary, July
18-23, 2021, pages 433–453. ACM, 2021.

[33] Amos Fiat, Anna Karlin, Elias Koutsoupias, and Christos H. Papadimitriou. Energy equi-
libria in proof-of-work mining.
In Anna Karlin, Nicole Immorlica, and Ramesh Johari,
editors, Proceedings of the 2019 ACM Conference on Economics and Computation, EC
2019, Phoenix, AZ, USA, June 24-28, 2019, pages 489–502. ACM, 2019.

[34] Mehdi Fooladgar, Mohammad Hossein Manshaei, Murtuza Jadliwala, and Moham-
mad Ashiqur Rahman. On incentive compatible role-based reward distribution in algo-
rand. In 50th Annual IEEE/IFIP International Conference on Dependable Systems and
Networks, DSN 2020, Valencia, Spain, June 29 - July 2, 2020, pages 452–463. IEEE, 2020.

[35] Algorand Foundation. Faqs, 2020.

[36] Clemente Galdi and Vladimir Kolesnikov, editors. SCN 20: 12th International Confer-
ence on Security in Communication Networks, volume 12238 of Lecture Notes in Computer
Science, Amalﬁ, Italy, September 14–16, 2020. Springer, Heidelberg, Germany.

[37] Chaya Ganesh, Claudio Orlandi, and Daniel Tschudi. Proof-of-stake protocols for privacy-
aware blockchains. In Yuval Ishai and Vincent Rijmen, editors, Advances in Cryptology –
EUROCRYPT 2019, Part I, volume 11476 of Lecture Notes in Computer Science, pages
690–719, Darmstadt, Germany, May 19–23, 2019. Springer, Heidelberg, Germany.

[38] Juan A. Garay and Aggelos Kiayias. SoK: A consensus taxonomy in the blockchain era. In
Stanislaw Jarecki, editor, Topics in Cryptology – CT-RSA 2020, volume 12006 of Lecture
Notes in Computer Science, pages 284–318, San Francisco, CA, USA, February 24–28, 2020.
Springer, Heidelberg, Germany.

[39] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol:
Analysis and applications. In Elisabeth Oswald and Marc Fischlin, editors, Advances in
Cryptology – EUROCRYPT 2015, Part II, volume 9057 of Lecture Notes in Computer
Science, pages 281–310, Soﬁa, Bulgaria, April 26–30, 2015. Springer, Heidelberg, Germany.

[40] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol with

chains of variable diﬃculty. In Katz and Shacham [50], pages 291–323.

[41] Peter Gazi, Aggelos Kiayias, and Alexander Russell. Tight consistency bounds for bitcoin.

In Ligatti et al. [63], pages 819–838.

[42] Arthur Gervais, Ghassan O. Karame, Karl W¨ust, Vasileios Glykantzis, Hubert Ritzdorf,
and Srdjan Capkun. On the security and performance of proof of work blockchains. In
Weippl et al. [90], pages 3–16.

[43] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zeldovich. Al-
gorand: Scaling byzantine agreements for cryptocurrencies. Cryptology ePrint Archive,
Report 2017/454, 2017. https://eprint.iacr.org/2017/454.

[44] M. Goemans, Vahab Mirrokni, and A. Vetta. Sink equilibria and convergence.

In 46th
Annual IEEE Symposium on Foundations of Computer Science (FOCS’05), pages 142–151,
2005.

[45] Ian Goldberg and Tyler Moore, editors. FC 2019: 23rd International Conference on Finan-
cial Cryptography and Data Security, volume 11598 of Lecture Notes in Computer Science,
Frigate Bay, St. Kitts and Nevis, February 18–22, 2019. Springer, Heidelberg, Germany.

[46] Guy Goren and Alexander Spiegelman. Mind the mining. In Anna Karlin, Nicole Immorlica,
and Ramesh Johari, editors, Proceedings of the 2019 ACM Conference on Economics and
Computation, EC 2019, Phoenix, AZ, USA, June 24-28, 2019, pages 475–487. ACM, 2019.

41

[47] Cyril Grunspan and Ricardo P´erez-Marco. On proﬁtability of selﬁsh mining, 2019.

[48] Benjamin Johnson, Aron Laszka, Jens Grossklags, Marie Vasek, and Tyler Moore. Game-
theoretic analysis of DDoS attacks against bitcoin mining pools. In Rainer B¨ohme, Michael
Brenner, Tyler Moore, and Matthew Smith, editors, FC 2014 Workshops, volume 8438 of
Lecture Notes in Computer Science, pages 72–86, Christ Church, Barbados, March 7, 2014.
Springer, Heidelberg, Germany.

[49] Dimitris Karakostas, Aggelos Kiayias, and Mario Larangeira. Account management in proof

of stake ledgers. In Galdi and Kolesnikov [36], pages 3–23.

[50] Jonathan Katz and Hovav Shacham, editors. Advances in Cryptology – CRYPTO 2017,
Part I, volume 10401 of Lecture Notes in Computer Science, Santa Barbara, CA, USA,
August 20–24, 2017. Springer, Heidelberg, Germany.

[51] Thomas Kerber, Aggelos Kiayias, Markulf Kohlweiss, and Vassilis Zikas. Ouroboros crypsi-
nous: Privacy-preserving proof-of-stake. In 2019 IEEE Symposium on Security and Privacy,
pages 157–174, San Francisco, CA, USA, May 19–23, 2019. IEEE Computer Society Press.

[52] Aggelos Kiayias, Elias Koutsoupias, Maria Kyropoulou, and Yiannis Tselekounis.
Blockchain mining games.
In Vincent Conitzer, Dirk Bergemann, and Yiling Chen, ed-
itors, Proceedings of the 2016 ACM Conference on Economics and Computation, EC ’16,
Maastricht, The Netherlands, July 24-28, 2016, pages 365–382. ACM, 2016.

[53] Aggelos Kiayias and Alexander Russell. Ouroboros-BFT: A simple byzantine fault tolerant
consensus protocol. Cryptology ePrint Archive, Report 2018/1049, 2018. https://eprint.
iacr.org/2018/1049.

[54] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. Ouroboros:
In Katz and Shacham [50], pages

A provably secure proof-of-stake blockchain protocol.
357–388.

[55] Aggelos Kiayias and Aikaterini-Panagiota Stouka. Coalition-safe equilibria with virtual

payoﬀs, 2021.

[56] Sunny King and Scott Nadal. Ppcoin: Peer-to-peer crypto-currency with proof-of-stake.

self-published paper, August, 19:1, 2012.

[57] Elias Koutsoupias, Philip Lazos, Foluso Ogunlana, and Paolo Seraﬁno. Blockchain mining
games with pay forward. In Ling Liu, Ryen W. White, Amin Mantrach, Fabrizio Silvestri,
Julian J. McAuley, Ricardo Baeza-Yates, and Leila Zia, editors, The World Wide Web
Conference, WWW 2019, San Francisco, CA, USA, May 13-17, 2019, pages 917–927.
ACM, 2019.

[58] Joshua A. Kroll, Ian C. Davey, and Edward W. Felten. The economics of bitcoin mining,
or bitcoin in the presence of adversaries. In The Twelfth Workshop on the Economics of
Information Security (WEIS 2013), 2013.

[59] Ranjit Kumaresan, Tal Moran, and Iddo Bentov. How to use bitcoin to play decentralized
poker.
In Indrajit Ray, Ninghui Li, and Christopher Kruegel, editors, ACM CCS 2015:
22nd Conference on Computer and Communications Security, pages 195–206, Denver, CO,
USA, October 12–16, 2015. ACM Press.

[60] Kenny L. You don’t need a diversiﬁed crypto portfolio to spread risk: Here’s why, 2018.

https://towardsdatascience.com/bitcoin-dominance-5a95f0f3319e.

[61] Yoad Lewenberg, Yoram Bachrach, Yonatan Sompolinsky, Aviv Zohar, and Jeﬀrey S.
Rosenschein. Bitcoin mining pools: A cooperative game theoretic analysis.
In Gerhard
Weiss, Pinar Yolum, Rafael H. Bordini, and Edith Elkind, editors, Proceedings of the 2015
International Conference on Autonomous Agents and Multiagent Systems, AAMAS 2015,
Istanbul, Turkey, May 4-8, 2015, pages 919–927. ACM, 2015.

42

[62] Wenting Li, S´ebastien Andreina, Jens-Matthias Bohli, and Ghassan Karame. Securing
proof-of-stake blockchain protocols. In Data Privacy Management, Cryptocurrencies and
Blockchain Technology, pages 297–315. Springer, 2017.

[63] Jay Ligatti, Xinming Ou, Jonathan Katz, and Giovanni Vigna, editors. ACM CCS 20: 27th
Conference on Computer and Communications Security, Virtual Event, USA, November 9–
13, 2020. ACM Press.

[64] William Forster Lloyd. Two lectures on the checks to population. JH Parker, 1833.

[65] James Lovejoy. Bitcoin gold (btg) was 51% attacked, 2020. https://gist.github.com/

metalicjames/71321570a105940529e709651d0a9765.

[66] Katie Martin and Billy Nauman. Bitcoin’s growing energy problem: ’it’s a dirty currency’,

2021. https://www.ft.com/content/1aecb2db-8f61-427c-a413-3b929291c8ac.

[67] Julian Martinez.
stake

at

ing
understanding-proof-of-stake-the-nothing-at-stake-theory-1f0d71bc027.

theory,

2018.

Understanding

proof

of

stake:

noth-
https://medium.com/coinmonks/

The

[68] Maxminer. Feathercoin’s 51% attack - double spending case study, 2013.

https:

//maxminer.files.wordpress.com/2013/06/ftc_51attack.pdf.

[69] Sarah Meiklejohn and Kazue Sako, editors. FC 2018: 22nd International Conference on
Financial Cryptography and Data Security, volume 10957 of Lecture Notes in Computer
Science, Nieuwpoort, Cura¸cao, February 26 – March 2, 2018. Springer, Heidelberg, Ger-
many.

[70] Ian Miers, Christina Garman, Matthew Green, and Aviel D. Rubin. Zerocoin: Anonymous
distributed E-cash from Bitcoin. In 2013 IEEE Symposium on Security and Privacy, pages
397–411, Berkeley, CA, USA, May 19–22, 2013. IEEE Computer Society Press.

[71] Vahab S. Mirrokni and Alexander Skopalik. On the complexity of nash dynamics and sink
equilibria. In John Chuang, Lance Fortnow, and Pearl Pu, editors, Proceedings 10th ACM
Conference on Electronic Commerce (EC-2009), Stanford, California, USA, July 6–10,
2009, pages 1–10. ACM, 2009.

[72] Tal Moran and Ilan Orlov. Simple proofs of space-time and rational proofs of stor-
age. In Alexandra Boldyreva and Daniele Micciancio, editors, Advances in Cryptology –
CRYPTO 2019, Part I, volume 11692 of Lecture Notes in Computer Science, pages 381–409,
Santa Barbara, CA, USA, August 18–22, 2019. Springer, Heidelberg, Germany.

[73] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008.

[74] Kartik Nayak, Srijan Kumar, Andrew Miller, and Elaine Shi. Stubborn mining: Generaliz-
ing selﬁsh mining and combining with an eclipse attack. Cryptology ePrint Archive, Report
2015/796, 2015. https://eprint.iacr.org/2015/796.

[75] Mark Nesbitt. Vertcoin (vtc) was successfully 51% attacked, 2018. https://medium.com/

coinmonks/vertcoin-vtc-is-currently-being-51-attacked-53ab633c08a4.

[76] Mark

Nesbitt.

Deep

chain

ethereum
ethereum-classic-etc-is-currently-being-51-attacked-33be13ce32de.

classic

(etc),

2019.

reorganization

on
https://blog.coinbase.com/

detected

[77] Jesper Buus Nielsen and Vincent Rijmen, editors. Advances in Cryptology – EURO-
CRYPT 2018, Part II, volume 10821 of Lecture Notes in Computer Science, Tel Aviv,
Israel, April 29 – May 3, 2018. Springer, Heidelberg, Germany.

43

[78] Shunya Noda, Kyohei Okumura, and Yoshinori Hashimoto. An economic analysis of diﬃ-
culty adjustment algorithms in proof-of-work blockchain systems. In P´eter Bir´o, Jason D.
Hartline, Michael Ostrovsky, and Ariel D. Procaccia, editors, EC ’20: The 21st ACM Con-
ference on Economics and Computation, Virtual Event, Hungary, July 13-17, 2020, page
611. ACM, 2020.

Bitcoin
[79] Charlie
$17.5
2018.
bitcoin-gold-hit-with-double-spend-attacks-18-million-lost/.

Osborne.
million

attacks,
https://www.zdnet.com/article/

double

suﬀers

spend

lost,

gold

[80] Sunoo Park, Albert Kwon, Georg Fuchsbauer, Peter Gazi, Jo¨el Alwen, and Krzysztof
In Meiklejohn and

Pietrzak. SpaceMint: A cryptocurrency based on proofs of space.
Sako [69], pages 480–499.

[81] Rafael Pass and Elaine Shi. FruitChains: A fair blockchain. In Elad Michael Schiller and
Alexander A. Schwarzmann, editors, 36th ACM Symposium Annual on Principles of Dis-
tributed Computing, pages 315–324, Washington, DC, USA, July 25–27, 2017. Association
for Computing Machinery.

[82] Marshall C. Pease, Robert E. Shostak, and Leslie Lamport. Reaching agreement in the

presence of faults. J. ACM, 27(2):228–234, 1980.

[83] R. W. Rosenthal. A class of games possessing pure-strategy nash equilibria. International

Journal of Game Theory, 2:65–67, 1973.

[84] Ayelet Sapirshtein, Yonatan Sompolinsky, and Aviv Zohar. Optimal selﬁsh mining strate-
gies in bitcoin. In Jens Grossklags and Bart Preneel, editors, FC 2016: 20th International
Conference on Financial Cryptography and Data Security, volume 9603 of Lecture Notes
in Computer Science, pages 515–532, Christ Church, Barbados, February 22–26, 2016.
Springer, Heidelberg, Germany.

[85] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate transaction processing in bitcoin.
In Rainer B¨ohme and Tatsuaki Okamoto, editors, FC 2015: 19th International Conference
on Financial Cryptography and Data Security, volume 8975 of Lecture Notes in Computer
Science, pages 507–527, San Juan, Puerto Rico, January 26–30, 2015. Springer, Heidelberg,
Germany.

[86] Aleksey Studnev. Attacker stole 807k etc in ethereum classic 51% attack, 2020. https:

//bitquery.io/blog/attacker-stole-807k-etc-in-ethereum-classic-51-attack.

[87] Aleksey Studnev. Ethereum classic attack, 8 august: Catch me if you can, 2020. https:
//bitquery.io/blog/ethereum-classic-attack-8-august-catch-me-if-you-can.

[88] Tezos. Proof-of-stake in tezos, 2020.

[89] Zack Voell. Ethereum classic hit by third 51% attack in a month, 2020. https://www.
coindesk.com/ethereum-classic-blockchain-subject-to-yet-another-51-attack.

[90] Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai
Halevi, editors. ACM CCS 2016: 23rd Conference on Computer and Communications
Security, Vienna, Austria, October 24–28, 2016. ACM Press.

[91] Gavin Wood. Ethereum yellow paper, 2014.

[92] ZenCash. Zencash statement on double spend attack, 2018. https://blog.zencash.com/

zencash-statement-on-double-spend-attack/.

44

A Hybrid PoS and Finality Gadgets

Gasper [12] is a proof-of-stake blockchain protocol that combines ideas from Casper FFG [11, 13]
and the (last message driven) GHOST fork-choice rule [85]. It is of special interest, since it is the
protocol of choice for Ethereum’s updated version, 2.0. Interestingly, Eth 2.0 aims at preventing
malicious behavior via penalties on incentives, which take the form of conﬁscating the deposit
of a (provably) misbehaving party. However, the high level of required deposit19 prevents small
investors from participating in the protocol. Therefore, compliance is a helpful property in
identifying whether infraction is viable under the plain protocol (i.e., without penalties) and,
it both incentivizes compliance and allows as
if so, how high the penalty should be set, s.t.
many parties as possible to participate. Although Gasper is a consensus protocol in itself, our
analysis applies to most systems that employ ﬁnality gadgets like Winkle [3], Afgjort [23], and
Fantomette [4].

As with the other PoS protocols (Section 5.2), in Gasper time is measured in slots and a
constant number le of slots deﬁnes an epoch. In Gasper, a slot r which has number e · le + k,
k ∈ [0, le − 1] belongs to epoch e, denoted as ep(r) = e. The view of a block B is the view
consisting of B and all its ancestors, where an ancestor of B is a block that is reachable from B
following parent-child edges on the chain.

For a block B and an epoch e there is a well-deﬁned e-th epoch boundary block of B, denoted
by EBB(B, e). In particular, EBB(B, e) is the block with the highest slot number that is ≤ e · le
in the chain determined by B. The last epoch boundary block of B is denoted by LEBB(B). Since
a block B(cid:48) can be an epoch boundary block of B for multiple epochs, an epoch boundary pair
(B(cid:48), e(cid:48)) is used. These pairs play the role of checkpoints, i.e., a party that follows the protocol
never discards a justiﬁed block (and, consequently, its ancestor block back to the genesis).

In each slot, a subset of protocol participants, called validators, forms a committee. Each
validator belongs to a single committee per epoch. The ﬁrst committee member is the proposer,
i.e., is responsible for creating a new block; similar to the protocols of Section 5.2.1, a single
proposer per slot is assigned. Then, each member of the committee attests to the block that is
the head of its chain, using a variation of GHOST. Each attestation α is deﬁned as:

α = (cid:104)rα, Bα, LJ(α) V→ LE(α)(cid:105)

where: (i) rα = e·le +k is the slot of epoch e during which the validator V makes the attestation;
(ii) the Bα block that α attests to; (iii) LJ(α) V→ LE(α) is a checkpoint edge, where LJ(α) and
LE(α) are epoch boundary pairs that will be deﬁned shortly. Therefore, α acts as a “GHOST
vote” for block Bα and as a “Casper FFG vote” for the transition from the epoch boundary
pair LJ(α) to LE(α). slot(α) denotes the slot of α and two attestations are equal if their hash is
equal (for some hash function H).

If a set of validators with weight more than 2

3 of the total validating stake attests to an edge

(B(cid:48), e(cid:48)) V→ (B, e), then a supermajority link is formed, denoted by (B(cid:48), e(cid:48)) J→ (B, e).

To deﬁne the pairs LJ(α) and LE(α), the concept of justiﬁed pairs is introduced. Given a
party P’s view of the execution trace (cid:61)P , the set of justiﬁed pairs J((cid:61)P ) is deﬁned recursively
as follows:

• the pair (BG, 0) is in J((cid:61)P ), where BG is the genesis block;

• if (B(cid:48), e(cid:48)) ∈ J((cid:61)P ) and (B(cid:48), e(cid:48)) J→ (B, e), then (B, e) ∈ J((cid:61)P ).

Now given an attestation α = (cid:104)rα, Bα, LJ(α) V→ LE(α)(cid:105), the following holds:

• LJ(α) is the last justiﬁed pair of α (in terms of epoch number) w.r.t. the view of LEBB(Bα);

• LE(α) is the last epoch boundary pair of α, i.e., LE(α) = (LEBB(Bα), eα).

Finally, with (Bk, e + k) being the last justiﬁed pair in J((cid:61)P ) (in terms of epoch number),

a pair (B, e) is k-ﬁnalized in (cid:61)P if:

19The required deposit has been set to 32ETH [27], which as of April 2021 is equivalent to $75000.

[https:

//coinmarketcap.com]

45

1. (B, e) = (BG, 0), or

2. there exist k+1 (justiﬁed) adjacent epoch boundary pairs (B, e), (B1, e+1), . . . , (Bk, e+k) ∈

J((cid:61)P ) and there also exists (B, e) J→ (Bk, e + k).

In Gasper, each protocol message m is an attestation α. As with PoS protocols, the oracle
OΠ produces a signature for a submitted attestation and a party can produce as many (valid)
signatures per round as queries to OΠ.

With the introduction of attestations, we need to slightly adapt the standard blockchain
infraction predicate (cf. Section 3.1) for Gasper. The deviant behavior for validators is expressed
by Gasper’s infraction predicate (Deﬁnition 11), which deﬁnes three clauses, based on Gasper’s
“slashing conditions” [12].
i) produces two
conﬂicting attestations for the same (attestation) epoch; ii) attempts a “long-range” attestation,
i.e., produces two attestations s.t. the ﬁrst’s edge source is older than the second’s and its edge
target is newer than the second’s; iii) does not produce an attestation for some epoch.

Intuitively, an infraction occurs if a validator:

Deﬁnition 11 (Gasper Infraction Predicate (Validators)). Given a validator party V and an
execution trace (cid:61), XGasper((cid:61)Z,A,r, V ) = 1 at slot r if one of the following conditions holds:

1. ∃α, α(cid:48) : (V((cid:61)V

Z,σ,r, α) = V((cid:61)V

Z,σ,r, α(cid:48)) = 1) ∧ (creator(α) = creator(α(cid:48)) = V ) ∧ (slot(α) =

slot(α(cid:48))) ∧ (α (cid:54)= α(cid:48));

2. ∃α = (cid:104)·, ·, (Bs, es) V→ (Bt, et)(cid:105), α(cid:48) = (cid:104)·, ·, (B(cid:48)

s, e(cid:48)

s) V→ (B(cid:48)

t, e(cid:48)

t)(cid:105) : (creator(α) = creator(α(cid:48)) =

V ) ∧ (es < e(cid:48)

s) ∧ (et > e(cid:48)

t);

3. V is a committee member for slot r and makes no queries to the oracle OΠ during r.

Regarding rewards, we assume those of Eth 2.0, which implements Gasper. Given the chain
CΩ output by the observer Ω, parties receive rewards as validators and/or as proposers. A
validator receives a ﬁxed reward20 Rv for each attestation α it produces, which satisﬁes the
following conditions: i) the block that α attests to is ﬁnalized in CΩ; ii) α is published in CΩ. A
proposer receives a ﬁxed reward Rp for each block B it produces which is ﬁnalized in CΩ.

Consequently, the analysis of Section 5.2.1 applies directly on Gasper, for the updated in-
fraction predicate (Deﬁnition 11). Speciﬁcally, when a party is chosen to participate, either as
proposer or validator, no other party may also be elected for the same role; therefore, Gasper’s
participation schedule is equivalent to single-leader PoS protocols. Additionally, Gasper re-
wards are akin to block proportional rewards, as parties are rewarded for producing attestations
which are eventually accepted by Ω. Therefore, applying the analysis of Section 5.2.1, Gasper
is compliant (w.r.t. the Gasper infraction predicate) under a synchronous network, but it is not
compliant under a lossy network.

20In practice, both the validation and proposer rewards are not ﬁxed, but depend on the total amount of stake
in the system and the number of included attestations respectively. Our simpliﬁcation though eases analysis and
expresses the setting where the total stake and the rate of produced attestations per round are ﬁxed throughout
the execution.

46

