1
2
0
2

c
e
D
1
3

]

R
C
.
s
c
[

1
v
2
2
3
5
1
.
2
1
1
2
:
v
i
X
r
a

1

An Efﬁcient and Robust Committee Structure
for Sharding Blockchain

Mengqian Zhang, IEEE Member, Jichen Li, IEEE Member, Zhaohua Chen, IEEE Member,
Hongyin Chen, IEEE Member, and Xiaotie Deng, IEEE Fellow

Abstract—Nowadays, sharding is deemed as a promising way to save traditional blockchain protocols from their low scalability.
However, such technique also brings several potential risks and huge communication overheads. An improper design may give rise to
the inconsistent state among different committees. Further, the communication overheads arising from cross-shard transactions
unfortunately reduce the system’s performance. In this paper, we ﬁrst summarize ﬁve essential issues that all sharding blockchain
designers face. For each issue, we discuss its key challenge and propose our suggested solutions. In order to break the performance
bottlenecks, we propose a reputation mechanism for selecting leaders. The term of reputation in our design reﬂects each node’s
honest computation resources. In addition, we introduce a referee committee and partial sets in each committee, and design a
recovery procedure in case the leader is malicious. Under the design, we prove that malicious leaders will not hurt the system and will
be evicted. Furthermore, we conduct a series of simulations to evaluate our design. The results show that selecting leaders by the
reputation can dramatically improve the system performance.

Index Terms—Sharding Blockchain, Reputation Mechanism, Leader Selection, Hierarchical Design, Recovery Procedure.

(cid:70)

1 INTRODUCTION

T HE blockchain revolution has established a milestone

with Nakamoto’s Bitcoin [1] during the long search for
a dreaming digital currency. It maintains the distributed
database in a decentralized manner and has achieved a
certain maturity to provide the Internet community with a
service that captures the most important features of cash:
secure, anonymity, easy to carry, easy to change hand,
and exchangeable across national boundaries. At the same
time, Bitcoin realizes the tamper proof property needed for
transactions.

Unfortunately, state-of-the-art blockchain systems (e.g.,
Bitcoin [1] and Ethereum [2]) suffer from serious scalability
problem. In the context of blockchains, a system is consid-
ered scalable if its throughput (transactions per second or tps
for short) grows with the increase of computing resources.
In most blockchain projects, all nodes in the network have to
agree on a certain set of transactions. Therefore, only a rather
ﬁxed amount of transactions can be included in a block over
a period of time, regardless of the number of nodes in the
network.

The classic design leads to a quite low throughput. The
tps of Bitcoin is 3 to 4 orders of magnitude lower than those
for centralized payment systems such as Visa. Speciﬁcally,

• M. Zhang is in the Department of Computer Science and Engineering,
Jiao Tong University, Shanghai, 200240, China (E-mail:

Shanghai
mengqian@sjtu.edu.cn).

•

J. Li, Z. Chen, H. Chen and X. Deng are in the Center on Frontiers of
Computing Studies, Computer Science Dept., Peking University, Beijing,
100871, China (E-mail: {2001111325,
chenhongyin,
xiaotie}@pku.edu.cn).

chenzhaohua,

• X. Deng is the corresponding author. M. Zhang, J. Li, Z. Chen and H.

Chen contributed equally to this work.

This work is supported by Science and Technology Innovation 2030 - “New
Generation Artiﬁcial Intelligence” Major Project No.(2018AAA0100901).

Bitcoin can process only 3.3-7 transactions per second in
2016 [3] while Visa handles more than 24,000 transactions
per second [4]. Such weakness severely limits the popular-
ization of blockchain.

Inspired by this idea,

To overcome this problem, a promising way is to borrow
the idea of sharding from the ﬁeld of database. Sharding is a
well-known technique to build the scale-out database. The
main idea is to break up large tables into smaller chunks and
spread them across multiple servers. It enables the sharing
of overall workload and greatly increases the performance.
researchers in the area of
blockchain apply sharding to improve blockchains’ scala-
bility in recent years. Similarly, we can partition nodes into
parallel committees and have each committee maintain a
subset of transactions. Under this method, the transaction
processing rate is proportional to the number of committees
rather than a constant. Therefore, less computational power
is wasted, higher processing capacity is achieved and the
system scales well.

Despite its beneﬁts,

the application of sharding in
blockchain also imposes a great deal of complexity and
potential risks. Rather than accessing and updating data
from local storage, nodes have to process transactions across
multiple shards. An improper design may cause the in-
consistency of data, which is an enormous threat to the
system. Thus, it is of great importance and urgency to
summarize and present general design process, principles
and suggestions for the sharding protocols. In addition,
cross-shard transactions make it inevitable to carry out large
amount of communications among different committees,
which unfortunately reduces the performance of the system.
This is a crucial issue that has not been properly resolved
until now.

In this paper, we identify ﬁve essential issues in sharding
blockchain, which together composite a complete protocol.

 
 
 
 
 
 
For each issue, we discuss its key challenge, give a brief
review on existing approaches, and propose our suggested
solution. By doing numerical studies, we show that cross-
shard transactions take an overwhelming fraction in the
sharding blockchain. These transactions inevitably bring
heavy overheads on communicating, which is the task of
leader in each committee. As a result, their capability be-
comes a major bottleneck of the whole protocol.

For better performance, we design a reputation mech-
anism. Speciﬁcally, the reputation of a node reﬂects its
honest computation resource. In each round, those nodes
with higher reputation will be selected as leaders. For safety
and liveness of the protocol, we introduce a unique referee
committee and partial sets in each committee. Brieﬂy, the
referee committee act as a arbitrator between opposing
parties, and partial sets take the responsibility to super-
vise the leader’s behavior. Further, we propose a recovery
procedure, which is triggered upon a malicious leader is
detected. As a consequence, the malicious leader is evicted
and a new leader is re-selected immediately, ensuring the
system running properly.

Theoretically, we prove that selecting leaders via reputa-
tion and the committee assignment scheme are secure with
overwhelming probability. Also, under such design, the
transaction processing procedure satisﬁes safety and live-
ness. Further simulation results support that the reputation
mechanism could effectively help to ﬁlter out those nodes
with abundant computational resources. By arranging these
nodes as leaders, each committee could process more trans-
actions and further improve the system performance.

This paper is organized as follows. In Section 2, we dis-
cuss ﬁve key issues in sharding blockchain. Section 3 states
system model and elaborate the problem we aim to solve.
We propose our solution in Section 4, including the repu-
tation mechanism and the recovery procedure. After that,
we give the theoretical analysis on our design in Section 5
and conduct a series of simulations in Section 6. Finally, we
review previous studies in Section 7 and conclude the paper
in Section 8.

2 ISSUES IN SHARDING BLOCKCHAINS

When it comes to sharding blockchain protocols, there are
ﬁve basic issues to consider. Like previous works, we will
analyze these problems based on the UTXO (Unspent Trans-
action Output) model. A UTXO indicates the amount of
digital currency that its owner can use later. Speciﬁcally, a
transaction will take one or multiple UTXOs as inputs, and
then output new UTXOs. And each UTXO can only be spent
once.

2.1 Issue #1: What to split?

The ﬁrst issue is to determine what to partition. Before
getting into the details, we ﬁrst distinguish a pair of essential
concepts. In the context, when referring to the term nodes,
we mean the participants who invest resources (hardware,
electricity, etc) and offer services (such as processing transac-
tions) in blockchain systems, similar to the miner in Bitcoin.
On the other hand, the participants who use services (e.g.,
generating transactions) are known as users.

In line with the original intention of the sharding tech-

nology, we answer the question as follows:

2

• Nodes. A sharding blockchain divides nodes into
disjoint groups, each of which is known as a com-
mittee. All committees work concurrently, therefore
increasing the transaction processing speed.

• Pending transactions. Instead of being kept in the
mempool of every node, pending transactions are
also partitioned into different groups, which we call
shards. It is worth noting that there is a one-to-one
mapping from shards to committees. Each shard of
transactions is only stored and processed by the
nodes in the corresponding committee.

• Blockchain history. To alleviate the full storage bur-
den on nodes, the heavy blockchain data is also split
and maintained by separated committees, in the form
of a sub-blockchain with lower volume.

2.2 Issue #2: How to split?

As a subsequence, it is important to ponder the methods
to partition the nodes, pending transactions, and blockchain
history.

Under the existence of potential Byzantine attackers,
nodes are expected to be distributed uniformly into commit-
tees. The uniform assignment keeps all committees under a
safe Byzantine fraction, and drives away the possibility for
malicious nodes to gather in and take over certain commit-
tee. To realize a uniformly random assignment, the key is
to generate a trusted randomness distributedly, which has
long been a critical task in blockchain. Several protocols [5],
[6] use an external cryptographic hash function, which
takes an unpredictable and tamper-resistant value (e.g., the
Merkle root of transactions in the previous block) as input,
and the output of the function is the randomness. Other
attempts include Veriﬁable Random Functions (VRFs) [7] in
Algorand [8], and Publicly Veriﬁable Secret Sharing (PVSS)
schemes [9], [10] in Ouroboros [11] and OmniLedger [12].

For the purposes of load balancing, the transaction is
assigned to one committee based on its id, i.e., the hash
value of the transaction. Speciﬁc designs vary among dif-
ferent protocols. One method is to use the ﬁrst k bits of
the transaction id to determine its shard, assuming there
are 2k shards (and committees) in the system. For example,
all transactions beginning with 010 in their hash belong to
shard #2 (here k = 3). We can also determine the belonging
shard of a transaction by calculating its id modulo 2k.
To prevent unbalanced loading caused by deliberate users
when generating transactions, some protocols add salt when
calculating the hash of transactions [13].

We emphasize that, under any proper sharding conﬁgu-
ration, each transaction should be precisely maintained by
a unique committee, to avoid consistency issues1. Accord-
ingly, the blockchain history is also separated, and each
virtual UTXO is exactly kept by a single committee.

1. Or else, different committees may come up with conﬂicting results

concerning the same transaction.

2.3 Issue #3: How to deal with the dynamic member-
ship?

As discussed previously, the sharding technique aims at
solving the scalability issue for permissionless blockchains,
in which nodes can join and leave freely. In this scenario,
the attackers may execute sufﬁciently many join and leave
operations to manipulate a certain committee. Thus, it is
necessary to adjust the committee assignments periodically.
A simple idea is to reshufﬂe all nodes at the beginning of
each round. Such idea has several shortcomings. First, a
full bootstrapping procedure will stop the whole system.
All nodes halt until new committees are formed. Second,
frequent reorganization brings expensive communication
overheads. Speciﬁcally, nodes have to change connection
with different sets of committee members. Also, they need
to fetch data of the new ledger from other nodes.

To balance usability and performance, replacing only a
subset of committee members is a better alternative. Such
solution deals with nodes’ joining and leaving smoothly,
and resists against the slowly-adaptive Byzantine adversary.
As a practice, RapidChain [14] borrows the idea of Cuckoo
rule [15], requiring that only a constant number of nodes
is switched to other committees in each round. Yet, this
method leaves the adversary enough room to take over a
certain committee and further cause damage to the whole
system. More speciﬁcally, at some round r, the adversary
may plan to corrupt all members in a committee during
round r + d. Afterwards, even if a constant number of
members are switched out, the majority of this committee
will be malicious.

In order to solve the dynamic membership issue prop-
erly, we propose an Expected Constant-Fraction Reshufﬂing
(ECFR) scheme with parameter α. In expectation, it requires
a constant fraction of members inside a committee to be
switched out in each round. Precisely, the α-ECFR scheme
is designed as follows: Let α ∈ (0, 1) be a constant. In each
round, we independently mark each node with probability
α, and uniformly reassign all marked nodes to all commit-
tees, assuring that all committees have the same size.

We mention that the number of reshufﬂed nodes of
α-ECFR scheme lies between total reshufﬂing and Rapid-
Chain’s solution. With little bias of notation, total reshufﬂing
is an extreme case of α-ECFR scheme with α = 1. Further,
there exists a constant α enabling that with high probability
honest nodes take the majority in all committees. We prove
this security property in Section 5.1.3.

2.4 Issue #4: How to process intra-shard transactions?

Based on the UTXO model, a transaction speciﬁes one or
more outputs of previous transactions as its input(s). For
a transaction tx charged by some committee C, if all its
referenced transactions are also maintained in C, then tx
is known as an intra-shard transaction. As a result, committee
members can verify the intra-shard transactions by them-
selves and reach a consensus afterwards. There are a lot of
options for the speciﬁc consensus algorithm. On one hand,
each committee can be regarded as a smaller blockchain
system with less nodes and transactions. Thus, the typical
blockchain consensus algorithms can be applied here, such
as Proof of Work (PoW), Proof of Stake (PoS) and so on. The

3

discussion on these consensus protocols is out of the scope
of this paper. More details can be found in [16].

On the other hand, several protocols which are not
suitable for the large-scale blockchain systems ﬁnd their
place in this scenario. A typical example is the classic Byzan-
tine Fault Tolerance (BFT) consensus protocol. As the ﬁrst
practical solution, [17] correctly survives Byzantine faults in
asynchronous networks, allowing a group of nodes to reach
agreement on some value. However, it only works in the
setting where all participants are known to each other, and
the network size is small. Speciﬁcally, Such solution does
not scale well because of its communication overhead. The
protocol creates O(n2) communication complexity, where n
is the number of nodes, which becomes unacceptable when
the size of the network increases to, for example, 10,000.
Fortunately, these problems are mitigated when applied to
each committee in a sharding design. Here are two main
reasons, (1) It is easier for nodes to know each other in a
smaller committee, and (2) the size of a committee is small
enough to enable the BFT protocols to work well. As a result,
the BFT protocols have been widely used in the sharding
blockchain systems to reach intra-committee consensus.

2.5 Issue #5: How to process cross-shard transac-
tions?

In comparison to an intra-shard transaction, for a transac-
tion tx charged by committee C, if tx has a referenced input
transaction which is not maintained by C, then tx is called
a cross-shard transaction. Facing this kind of transactions,
members of C have to ask other committees for the validity
of the inputs.

Existing studies give some solutions to this issue. In Om-
niLedger [12], before submitting a cross-shard transaction to
its assigned committee C, the user who generates it needs
to collect proof-of-acceptance from all referenced committees,
whose members process the transaction and update the
UTXOs state. RapidChain [14] transforms the cross-shard
transaction into intra-shard transactions. For each input i
outside C, a bridge transaction tx(cid:48) is created, which takes
i as input, and generates an output with the same value
as i. However, tx(cid:48) is always assigned to C. Consequently,
the leader of C replaces the original cross-shard transaction
by an intra-shard transaction which takes the outputs of all
bridge transactions as inputs. CycLedger [18] transforms the
cross-committee consensus into intra-committee consensus
by having the leader of C discussing on the relevant in-
puts with its belonged committee, and comes up with a
consistent result for all relevant committees. Such solution
resembles a two-phase commit (2PC), but in a decentralized
manner.

At last, we remark that cross-shard transactions bring
extra communication overheads, which is one of the main
disadvantages of sharding blockchains. We conduct several
numerical studies to support this idea. According to the data
from Bitcoin Visuals2, which runs a fully-validating bitcoin
node and provides extensive statistics over the network,
we visualize the information of transaction inputs over
the past ten years. Fig. 1 shows the percentages regarding
the number of transactions’ inputs in Bitcoin in the past

2. https://bitcoinvisuals.com/

4

Fig. 2. Fraction of cross-shard transactions when the number of shards
is between 20 to 100 for transactions in Bitcoin.

committees which is realistic as a committee only consists of
several hundred nodes. Meanwhile, all leaders and partial
set members are synchronously linked. Concerning other
connections, we only need to assume partially-synchronous
channels [12], [17], [21].

3.3 Threat Model

We use a Public-Key Infrastructure (PKI) to give each node a
public/secret key pair (P K, SK), which enables the digital
signature scheme in communication. We assume the exis-
tence of a probabilistic polynomial-time Adversary which
controls a f < 1/3 fraction of total nodes. Corrupted nodes
may collude and act out arbitrary behaviors. The adversary
can change the order of messages sent by non-faulty nodes
under the restriction given in our network model. Other
nodes, known as honest nodes, always follow the protocol
and do nothing outside the regulation. At the same time,
we suppose the adversary to be mildly-adaptive, such that
after appointing a corruption set, the set of nodes become
malicious after d rounds, where d ≥ 1. Also, we assume
all nodes in the network have access to an external random
oracle H which is collision-resistant.

3.4 Problem Deﬁnition

We assume that transactions are continuously sent to our
network by the users. All transactions and Unspent Transac-
tion Outputs (UTXOs), are divided to m shards, and main-
tained by the corresponding common committee. Besides,
all nodes can verify whether a transaction is valid.

As discussed in section 2.4, most sharding blockchains
adopt the classic BFT algorithm to reach consensus in a
committee, in which the leader is a key role. Cross-shard
transactions make it inevitable to carry out large amount of
communications among different committees. This, unfor-
tunately, puts huge strain on the leader of each committee
and makes the leader a bottleneck of the system efﬁciency.
In this work, we focus on this problem, aiming to improve
the performance of sharding blockchain protocols.

4 SOLUTION
In this section, we propose our solution to the problem we
discussed in Section 3.4. Speciﬁcally, in Section 4.1, we intro-
duce a reputation mechanism to select leaders and provide

Fig. 1. Percentage of the number of transactions’ inputs in Bitcoin in the
past decade.

decade. As can be seen, most transactions have two or three
inputs. Furthermore, we download the full information of
transactions from Blockchair3. As Fig. 2 shows, when split-
ting transactions randomly into 20 shards, approximately
96% of them are cross-shard transactions. When we further
increase the shard number to 100, such fraction ascends
correspondingly to above 99%.

3 SYSTEM MODEL
3.1 Notation

1 , C r

2, · · · , wr

2 , · · · , C r

The blockchain system works in rounds. In each round
r, suppose there are n nodes in the network4 and each
of them has a reputation wr
1, wr
n which develops
as the protocol executes. A unique referee committee C r
R is
selected in round r − 1 to manage nodes’ identities and
propose round r’s block Br. At the same time, all other
nodes are partitioned into m common committees which we
denote as C r
m. In our protocol, all committees
have the same size c = Θ(log2 n). Therefore we have
n = (m + 1) · c. Each common committee C r
i (1 ≤ i ≤ m)
includes a leader lr
i , λ partial set members and c − λ − 1
common members. Partial set members in C r
i (1 ≤ i ≤ m)
form the partial set of the committee, which is denoted
as C r
i,λ}. Readers can refer to Fig.3
for the hierarchical conﬁguration of the network. In the
following sections, we omit the superscript of r in notation
if there is no ambiguity.

i,par = {cr

i,2, · · · , cr

i,1, cr

3.2 Network Model

We assume the well connection within a committee. Mean-
leaders and partial set members are linked.
while, all
Furthermore, we suppose that each leader or partial set
member is connected with the whole referee committee
CR. Such assumption requires a far less amount of reliable
connection channels than other works [12], [14], [19], [20]
in which they require a reliable connection among all hon-
est nodes. We assume synchronous communication within

3. https://blockchair.com/
4. In practice, n is changing with r. However, we use n instead of nr,

for simplicity.

explicit incentive for nodes in the system. In Section 4.2,
we present a recovery procedure to ensure the safety and
liveness properties.

4.1 Leader Selection via Reputation

In a sharding blockchain, nodes in each committee are led
by the leader and work together to process transactions. In
our design, we introduce the concept of reputation which
reﬂects the honest computational resources of each node
and helps to select leaders of each committee. Here, we take
the intra-shard transactions processing as an example to go
into details about the design of node’s reputation.

Phase 1: Voting and Decision Making
Consider the following scenario: In a committee of c nodes,
the leader l collects a subset of intra-shard transactions
T XList and broadcasts it to everyone in the committee.

After receiving T XList, everyone gives its opinion on
the validity of listed transactions. More speciﬁcally, the node
votes Yes for those transactions it agrees, No for disagreed
and Unknown for the left5. Afterwards, each node forwards
its voting list back to the leader. For the nodes who fail to
reply within a certain predetermined time, they are deemed
as voting Unknown on all transactions. This is to avoid
malicious nodes from indeﬁnitely delaying.

With all voting lists, ﬁrst the leader follows the majority
rule and picks up the set of transactions with more than
c
2 Yes, which is denoted as T XdecSET . Then it integrates
everyone’s vote in a set denoted as V List. At last the leader
runs a BFT protocol (e.g.,
[17]) within this committee to
reach consensus on both T XdecSET and V List.

Phase 2: Reputation Updating
As previously described, there are c nodes in the committee
and V List contains c votes. After each voting, the leader
scores all members according to their votes and the ﬁnal
decision.

Suppose the amount of transactions to be determined is
D, and let +1, −1 and 0 represent Yes, No and Unknown re-
spectively. Subsequently, We can use a D-dimension vector
to indicate a vote, with each entry representing the opin-
ion on the corresponding transaction. Let vi = {vi,k|k =
1, 2, · · · , D} denote the vote of member i, where vi,k is the
member i’s opinion on the kth transaction. One’s score is
closely related to its voting accuracy. Here, we deﬁne one’s
accuracy as the cosine similarity between its voting vector
and the resulting vector, which is determined by the major-
ity algorithm and denoted by u = {uk|k = 1, 2, · · · , D}. Let
si be the member i’s score. We have

5

with the number of transactions processed in this voting
and its accuracy. The second part is an extra bonus to award
those nodes whose votes are totally the same with the ﬁnal
result, i.e., whose accuracy cos(v, u) = 1. Signiﬁcantly, the
bonus is a bit different for the leader and other members
and it is designed as follows:

bonusi =






σ · D − ω/D,
σ · D,
0,

cos(vi, u) = 1, i is a leader;
cos(vi, u) = 1, i is a member;
cos(vi, u) < 1.

(2)
where D is the number of transactions to be voted, σ, ω > 0
are two predetermined parameters. There are two key points
on the design of bonus function here:

• A perfect non-leader member gains more bonus than
the leader. It is based on the consideration that the
member may own higher honest computation re-
sources, yet covered up by the leader who sets an
upper line on the number of processed transactions
of the committee. A higher bonus creates the possi-
bility for the member to stand out.

• The gain difference between a perfect non-leader
member and the leader on reputation gets smaller
with the rise on the number of processed transac-
tions. As a higher number of processed transactions
implies the better ability of a leader, it is reasonable to
lessen the possibility that the well-performed leader
gets replaced.

After calculating all scores, the leader assembles them
into a ScoreList = {s1, s2, · · · , sc}, and broadcasts it with
V List to all members, waiting for the consensus. In this pro-
cess, each non-faulty member should sign on the ScoreList.
If successful, the leader sends the agreement to C r
R, together
with relevant certiﬁcation. Consequently, C r
R updates their
reputation by simply adding the listed score.

Phase 3: Discussion on Incentive

As shown in (1), as long as a node has higher honest
computational resources, it will give a more similar vote
with the consensus, thus winning a higher score in each
round. Therefore, a node’s reputation, or the accumulated
score across rounds, is a good reﬂection of its honest com-
putational resources.

In our design, reputation offers a reference for the leader
selection. At the end of any round, m nodes with the highest
reputation are selected as leaders of the next round. These
nodes are randomly assigned to m committees. As the
reputation reﬂects the honest computational resources one
node contributes, such method enhances the performance
and throughput of the system.

si = D · cos(vi, u) + bonusi
k=1 vi,kuk
(cid:113)(cid:80)D

(cid:113)(cid:80)D

= D ·

(cid:80)D

k=1 v2
i,k

k=1 u2
k

+ bonusi.

(1)

As (1) shows, the score function contains two parts. The
ﬁrst part ensures that one’s score is positively associated

5. If a malicious node refuses to give any opinion, it is presumed to
have voted Unknown. Meanwhile, when an honest node fails to judge a
transaction within the given time, it should vote Unknown.

In each round, the proﬁt of nodes is also determined by
their reputation. Considering that one’s reputation may be
negative, we ﬁrst map the reputation to a positive number
using a monotone function g(·), as (3) shows. Rewards are
then distributed proportionally to the mapped value. Such
scheme ensures that whoever works more gets more, thus
providing enough incentive for nodes to work honestly and
as hard as they can.
(cid:26)

g(x) =

ex,
1 + ln(x + 1),

x ≤ 0;
x > 0.

(3)

We also give a punishment mechanism for the misbehav-
ior. For a leader who violates the protocol, its reputation will
be decreased to the cube root. Combining the punishment
with (3), the mapped value, which is closely related to
the node’s revenue, will reduce to approximately one-third
of the original mapped value. Therefore, the higher the
reputation a leader has, the stronger the punishment it will
suffer when behaving maliciously.

4.2 Recovery Procedure

As shown above, the leader of each committee is selected
according to reputation. Such scheme enhances the efﬁ-
ciency of the whole protocol by placing computationally-
intensive nodes in high-load positions. Nevertheless, it is
risky, as malicious nodes with high computational resources
may be elected as leaders, by pretending to be honest in
early epochs and accumulating high reputation. Therefore,
we propose the following recovery procedure to make sure
that malicious leaders will not affect the safety and liveness
of the protocol. More precisely, we introduce partial set
members to always monitoring the behavior of leaders.
Once a leader is conﬁrmed to be malicious, it will be evicted
by the referee committee collaboratively, and a new leader
will be selected.

4.2.1 Partial Set and Referee Committee
In each committee, λ nodes are set to supervise the leader’s
behavior. These nodes collaboratively is known as the partial
set. In each round, the partial set of a committee is selected
uniformly at random. For safety, it is required that at least
one node is honest in each partial set. In practice, λ can be
ﬁxed to an appropriate value, like 40.

Except for the m parallel processing committees, there
is a special referee committee in the system. It is worth
noting that nodes in the referee committee are equal, in
the sense that there is neither leader nor partial set in
this committee. The referee committee acts as a mediator
to arbitrate between opposing parties. Furthermore, it will
take action when a certain leader is accused of behaving
maliciously. The detailed approach will be given in the
following sections.

Fig. 3 demonstrates the hierarchical structure of different

nodes and committees.

4.2.2 Semi-Commitment Exchanging
In this section, we propose a semi-commitment exchanging
scheme to prevent a leader from cheating on the member list.
Together with the honest partial set members, a malicious
leader cannot forge consensus results when communicating
with other committees.

The semi-commitment of a committee is the hash of the
member list. In the context of cryptography, a commitment
scheme has both hiding property and binding property.
Here, we only require the computational-binding property
of a commitment scheme. That is where the name ”semi-
commitment” comes from6. The semi-commitment exchang-
ing phase runs as follows.

6. The hiding property of the commitment is not necessary here. For a
vicious leader, even if it ﬁgures out the members of another committee
in the semi-commitment exchanging phase, it can do nothing under
our threat model as the adversary cannot get control of a trusty node
immediately.

6

Fig. 3. Hierarchical structure of the committees. All nodes in a rectangle
are fully connected. More speciﬁcally, it contains two cases: (a) all nodes
in a committee, and (b) all leaders, partial set members and the referee
committee.

list S

committee’s

each
the member

start with,
should unite

leader
1) To
=
lk
{P Kk,1, P Kk,2, · · · P Kk,c} from all key members
in the committee, and compute the committee’s
semi-commitment via the external hash function
H: Hk = H(S). Then it broadcasts the semi
to
commitment
everyone in the referee committee CR. To prevent
any means of cheating, it also delivers both to the
partial set Ck,par.

together with the member list

2) After

in CR receives

all participants

semi-
commitments from all committees, they run an
agreement process inside the committee to check (a)
any member in any list is registered; (b) all semi-
commitments are valid. They transmit the set of
valid semi-commitments to all leaders and partial
set members and expel the cheating leaders after-
wards.

3) When a partial set member ck,i gets the semi-
commitment Hk from Cr, it veriﬁes whether its
committee’s semi-commitment corresponds with
the member list S it receives from the leader. Once
a truthful partial set member notices a mismatch, it
reports the circumstance to the referee committee to
evict the current leader, to be discussed later.

We show the phase in Algorithm 1. For brevity, the
verifying process executed by partial set members as well
as all digital signatures are omitted.

4.2.3 Leader Re-Selection

In this section, we introduce the leader re-selection pro-
cedure. It is invoked when an honest partial set member
notices that its leader is malicious or any participant of CR
notice that some leader is vicious. In the semi-commitment
case, the event happens when an honest party (a partial
set member or CR) discovers inconsistency between the
member list and the semi-commitment.

Algorithm 1 Semi-commitment Exchange
Ensure: Each committee get a semi-commitment of any

Algorithm 2 Leader Re-selection
Ensure: A malicious leader is evicted and a new leader is

7

other committee.

For leader lk:

SEND (rm | SEMI COM, Hk, r, S, k)

1: S ← {P Kk,1, P Kk,2, · · · P Kk,c}
2: Hk ← H(S)
3: ComList ← 0
4: Conf List ← 0
5: for rm ∈ CR do
6:
7: end for
8: for pm ∈ Ck,par do
9:
10: end for
11: upon DELIVER (rm | SEMI COM, Hj, r, j, rm) do
12:
13:
14:
end if
15:
16: end upon

Conf List[j][Hj] ← Conf List[j][Hj] + 1
if Conf List[j][Hj] > |CR|/2 then

SEND (pm | SEMI COM, Hk, r, S)

ComList[j] ← Hj

For rm ∈ CR:

17: upon DELIVER (lk | SEMI COM, Hk, r, S, k) do
18:

SigList ← CONSENSUS (SEMI COM, r, k, lk, Hk)

for each leader l do

SEND (l | SEMI COM, Hk, r, k, SigList)

19:
20:
21:
22: end upon

end for

If a partial set member wants to accuse its leader, it
would ﬁrst broadcast a witness to all members in the com-
mittee and ask them to vote on the impeachment. Here,
a witness is a pair of messages W = (ml, m0) where ml
should be sent and signed by the leader. We say a witness is
valid if and only if the pair derives to a dishonest behavior
of the leader. (e.g., ml be the member list that the leader
sends, and m0 be the semi-commitment of the committee
where m0 (cid:54)= H(ml).) If the proposal is approved by more
than half of the members, the prosecutor will forward the
voting result as well as its witness to everyone in the referee
committee.

When any node in CR receives a witness W and a signa-
ture list Cert approving the prosecution from a partial set
member pm from committee Ck, it starts Algorithm 2 to re-
select a committee leader. Afterwards, the new leader needs
to make a new semi-commitment of the committee via the
semi-commitment exchanging scheme (Algorithm 1). When
a participant of CR receives the new semi-commitment, it
informs every committee leader the new semi-commitment
and leader’s address, so that cross-shard transaction han-
dling may start safely.

For a better understanding on how to apply the above
designs, readers are recommended to [18] for more details
on a complete protocol named CycLedger.

selected.

For rm ∈ CR:

1: SigList ← CONSENSUS (r, k, pm, W, Cert)

{pm is the partial set member who accused the leader,
with W the witness and Cert the signatures from com-
mittee members.}
2: for each i ∈ Ck do
3:
4: end for

SEND (i | NEW, pm, SigList)

5 ANALYSIS
In this section, we provide a comprehensive discussion on
the our design, showing that (1) the committee assignment
scheme is secure with overwhelming probability, and (2)
the transaction processing procedure satisﬁes safety and
liveness.

5.1 Security on Committee Assignment

5.1.1 Partial Set
We say a partial set is secure when at least one node in the set
is honest. As no more than 1/3 validators are faulty, when
the size of the partial set is set to 40, the probability that a
partial set is insecure at most:

(

1
3

)40 < 8 × 10−20.

Associated with union bound, when the number of
committees is 20, the probability that at least one partial
set is insecure is no more than 2 × 10−19.

5.1.2 Bootstrapping
We say a committee is secure when more than half of nodes
are non-faulty. Recall that committees are formed uniformly
except leaders. Let X denote the number of malicious nodes
in a committee, and c be the expected committee size.
We consider the tail bound of hypergeometric distribution
which gives the following result:

Pr[X ≥

c
2

] =

c
(cid:88)

(cid:0) t
x

x= c
2

(cid:0)n
c

(cid:1)(cid:0)n−t
c−x

(cid:1)

(cid:1) ≤ e−D( 1

2 ||f )c,

(4)

where D(·||·) is the Kullback-Leibler divergence. Here t < n
3
and f < 1

3 + 1

c , thus,

Pr[X ≥

] ≤ e− c
12 .

c
2

(5)

When the expected committee size is c = Θ(log2 n), we
derive that the probability that a committee is insecure is
, which is negligible of n.
less than n

− log n
12

Fig. 4 visualizes (5). Namely, it shows the probability of
failure calculated using the hypergeometric distribution to
uniformly sample a committee when the population of the
whole network is 4,000. The amount of malicious nodes is
1,333, exactly less than one-third of the size of the network.
Particularly, when c = 240, the error probability for a
single committee is less than 2.8 × 10−8. Applying union
bound, when m is less than 20, the error probability is no
more than 6 × 10−7.

For any 1 ≤ i < d (when d ≥ 2), We now give an upper

8

bound on Pr[¬Ei+1].

Pr[¬Ei+1]

= Pr[¬Ei+1 ∧ ¬Ei] + Pr[¬Ei+1 ∧ Ei]

≤ Pr[¬Ei] +

(cid:88)

t>γi·c

Pr[¬Ei+1 ∧ (X1 + · · · + Xi = t)]

≤ Pr[¬Ei] + Pr[Ei] · max
t>γi·c

Pr[¬Ei+1|X1 + · · · + Xi = t]

≤ Pr[¬Ei] + max
t>γi·c

Pr[Xi+1 ≤ γi+1 · c − t|X1 + · · · + Xi = t].

An important property is that γi+1 − α ≤ (1 − α)γi,
which implies that γi+1 · c − t ≤ α · (c − t) for any t > γi · c.
As E[Xi+1] = α·(c−X1 −· · ·−Xi), we can apply Chernoff-
Hoeffding bound again:

Fig. 4. Probability of failure in sampling one committee from a population
of 4,000 nodes. The amount of malicious nodes is set to 1,333.

5.1.3 Reshufﬂing

Pr[¬Ei+1] − Pr[¬Ei]

For the simplicity of expression, we say a round of a
sharding protocol is secure if all committees in this round
are secure. As we have discussed in Section 2.3, we use
α-ECFR scheme to reshufﬂe the nodes at the beginning
of each round. The following theorem shows that after
reshufﬂing with α-ECFR scheme, the round is secure with
high probability.

Theorem 1. Assume that the adversary controls f < 1/3
fraction of nodes, and the corruption requires d (d ≥ 1) rounds
to take effect. Then, there exists a constant α, such that under
α-ECFR scheme, any round is secure with high probability, given
that all previous rounds are secure.

Proof. To simplify the proof, we suppose that the adversary
speciﬁes a set of nodes to corrupt by the end of round
r (r > 1) (before it knows the committee conﬁguration of
round r + 1), and nodes in the set become malicious at the
start of round r + d. To prove the theorem, we show that
no matter how the adversary choose the set, nodes will be
sufﬁciently reshufﬂed after d rounds so that all committees
have an honest majority, with high probability.

Further, in this proof, we call a node black if it is ever

marked in d rounds of reshufﬂing, and white otherwise.

Lemma 1. For any constant β ∈ (0, 1), there is a constant α ∈
(0, 1), such that after d rounds of α-ECFR, with high probability,
for all committees, at most β fraction of nodes remain white.

Proof. Consider any committee C with size c = O(log2 n).
Let X1, · · · , Xi, · · · , Xd denote the number of newly-
marked nodes in C in round r + 1, · · · , r + i, · · · , r + d.
Let β := (1 − α2)d, and γi := (cid:0)1 − (1 − α2)i(cid:1) , 1 ≤ i ≤ d.
(Therefore, γd = 1 − β). We deﬁne the following d events:

Pr[Xi+1 ≤ γi+1 · c − t|X1 + · · · + Xi = t]

≤ max
t>γi·c

(cid:40)

≤ max
t>γi·c

exp

−

(cid:40)

−

exp

= max
t>γi·c
(cid:40)

< exp

−

(cid:26)

= exp

−

(cid:18)

1 −

(cid:19)2

γi+1 · c − t
α · (c − t)

(cid:41)

· α · (c − t)

((α − γi+1) · c + (1 − α) · t)2
α · (c − t)

(cid:41)

1
2

1
2

·

·

·

((α − γi+1) · c + (1 − α) · γi)2
α · (c − γi)

(cid:41)

· c

· (1 − α)2α(1 − α2)i · c

(cid:27)

.

1
2

1
2

Therefore, as c = Θ(log2 n), we have

Pr[¬Ed] = Pr[¬E1] +

d−1
(cid:88)

i=1

(Pr[¬Ei+1] − Pr[¬Ei])

≤

d−1
(cid:88)

i=0

(cid:26)

exp

−

1
2

· (1 − α)2α(1 − α2)i · c

(cid:27)

(cid:26)

≤ d · exp

−

(cid:26)

= d · exp

−

· (1 − α)2α(1 − α2)d−1 · c

(cid:27)

·

(1 − α)α
1 + α

(cid:27)

β · c

= Θ(n− log n).

1
2
1
2

Note that Ed is the event that at most β fraction of nodes
in committee C remain white. By a union bound on all m =
Θ(n/ log2 n) committees, the lemma is proved.

Lemma 2. Conditioning on the committee conﬁguration of round
r and the number of black nodes, the identity of these black nodes
and their belongings at round r + d is uniform.

Ei := {X1 + · · · + Xi > γi · c},

1 ≤ i ≤ d.

Proof. The lemma holds obviously according to the deﬁni-
tion of ECFR scheme.

First, notice that E[X1] = α · c. By Chernoff-Hoeffding

bound, we have

Pr[¬E1] = Pr[X1 ≤ α2 · c] ≤ exp

(cid:26)

−

1
2

· (1 − α)2α · c

(cid:27)

.

Now we come back to the main theorem. Let Y be the
number of black nodes, and Z be the number of black nodes
that are to be corrupted at round r + d. By Lemma 1, with
high probability, Y ≥ (1 − β) · n.

9

We simply disregard the negligible failure probability.
Due to Lemma 2, Z follows the hypergeomatric distribution
H(f · n, n, Y ). Therefore, we have

Claim 2. A malicious leader is always detected and thus evicted
via the leader re-selection procedure, as long as the referee com-
mittee has an honest majority.

Pr[Z ≥ f · (1 + β) · Y ]

≤ max

y≥(1−β)·n

Pr[Z ≥ f · (1 + β) · y|Y = y]

≤ exp {−D (f · (1 + β)(cid:107)f ) · (1 − β) · n} ,

according to the tail bound of hypergeometric distribution.
Now suppose Z ≤ f · (1 + β) · Y , which happens with
high probability according to the previous inequality. For a
committee C, let YC be the number of black nodes in C at
round r + d, and ZC be the number of black nodes in C
that are malicious at round r + d. Again, ZC ∼ H(Z, Y, YC),
which leads to

Pr[ZC ≥ f · (1 + β)2 · YC]

≤ max

yC ≥(1−β)·c

Pr[ZC ≥ f · (1 + β)2 · yC|YC = yC]

≤ exp (cid:8)−D (cid:0)f · (1 + β)2(cid:107)f · (1 + β)(cid:1) · (1 − β) · c(cid:9) ,

which is negligible in n. Subsequently, we assume ZC ≤
f · (1 + β)2 · YC . Let MC be the number of malicious nodes
in committee C at round r + d. Above all, with probability
1 − O(n− log n), we have

MC ≤ β · c + (1 − β) · f · (1 + β)2 · c
= (cid:0)β + f · (1 + β)2(1 − β)(cid:1) · c.

When f < 1/3, with appropriate small β (e.g., β = 1/8),
we have β + f · (1 + β)2(1 − β) < 1/2. Applying an union
bound on all m = Θ(n/ log2 n) committees, we obtain the
theorem.

5.2 Safety and Liveness on Transaction Processing

Safety and liveness are two classes of essential properties in
sharding blockchain system, with the following implication
respectively:

•

•

Safety. Each committee will never propose a block
with invalid transactions.
Liveness. By the end of each round, each committee
will propose a non-empty valid block.

In this section, we show that our design satisﬁes both

two properties.

Claim 1. A malicious leader cannot deceive a trustful leader
by forging a member list of its committee as long as the referee
committee has an honest majority.

Proof. The process of semi-commitment exchanging is un-
der the supervision of its partial set. Note that with high
probability the partial set has at least one honest node.
Therefore, each leader cannot lie and the semi-commitment
exactly corresponds to the true member list.

Owing to the collision-resistance property of the hash
function,
the semi-commitment of a committee satis-
ﬁes the computational binding property. After the semi-
commitment is released, only with negligible probability,
a probabilistic polynomial-time malicious leader can forge
a false member list which corresponds to the same semi-
commitment. Therefore, the leader cannot provide non-
accepted results by falsifying its committee signature.

Proof. According to the discussion in Section 5.1, with high
probability there is at least one honest node in the partial set
and the referee committee has an honest majority. Therefore,
as a leader’s action is always monitored by the partial set
during the execution of the system, any irregular behavior
from the leader will be detected and a witness will be
inevitably grasped by the non-faulty partial set member. At
the same time, as the evidence is signed by the leader itself,
a malicious leader can never deny the charges.

Claim 3. A trustful leader will never be framed up by a faulty
partial set member, as long as CR has an honest majority.

Proof. We mention that a witness is valid if and only if the
ﬁrst part of it is a message signed by the leader. For the
security of the digital signature scheme, a faulty partial set
member cannot counterfeit a shred of evidence which must
be a leader’s signed message. Therefore, a trustful leader
will never be unjustly accused.

As proved above, any leader can never behave badly,
such as tampering with cross-shard transactions, proposing
blocks with invalid transactions and so on. Otherwise, it
will be evicted until an honest node becomes the leader. As
a consequence, a non-empty valid block will be proposed
by the end of each round. Thus, we claim that our design
has both the safety property and liveness property.

6 SIMULATION

In this section, we conduct several simulations to evaluate
the performance of our reputation mechanism.

6.1 Setup

As discussed in Section 5, the theoretical analysis proves
that our design is secure. More speciﬁcally, with overwhelm-
ing probability, each committee has an honest majority
at any time and only valid transactions will be accepted.
For completeness, this section attaches more importance to
the performance evaluation. In practice, there is no well-
developed and proven sharding blockchain system yet, and
it is infeasible and kind of risky to apply a novel design
to real systems. As an alternative, we adopt the simulation
method to evaluate the performance of our reputation mech-
anism.

There are several basic assumptions in our simulation.

• As mentioned previously, sharding protocols work in
rounds. For convenience, we discretize the time into
time slots with a ﬁxed span.

• The resource cost of a transaction is assumed to be
linear with the number of its inputs, which is realistic
in real-life transaction-processing.

• Leaders suffer from extra resource consumption on
the decision making, reputation updating and other
additional tasks, and only a pl fraction of com-
putation resources is left to process transactions.
Meanwhile, common members are also burdened

10

Fig. 5. The ratio of average leader computer resources to the maximal
possible average leader computer resources against round number
under two types of leader selection schemes. The total node number
is 2,000 and the number of committees is 20. The orange line shows
the case of leader selection via reputation, while the blue line shows the
case of random leader selection.

Fig. 6. The ratio of accumulated number of transactions processed
under two types of leader selection schemes against round number. The
total node number is 2,000 and the number of committees is 20. The
numerator is the corresponding number for the leader selection scheme
via reputation, and the denominator is the corresponding number for the
random leader selection scheme.

with communication in reaching consensus, there-
fore with a pm fraction of computation resources left
to process transactions. We suppose that pl < pm.

Without loss of generality, we mainly consider intra-
shard transactions. Essentially speaking,
the process-
ing of cross-shard transactions also depends on the
intra-committee consensus7, And intra-shard transactions
and cross-shard transactions cause no difference on the
reputation-updating process, which happens after voting on
the transaction/input list.

In order to emphasize our focus, we neglect the possible
misbehaviors and assume that the honest computational
resources of nodes in the system follow a beta distribution,
which suits the reality well. The resource cost of a transac-
tion is assumed to be positively associated with the number
of its inputs. When processing transactions, leaders suffer
from extra resource consumption on the decision making,
reputation updating and other additional tasks.

In simulation, at the beginning of each round, 2,000
nodes are uniformly split into 20 committees, each with
size 100. In order to imitate the realistic condition better,
we crawl 208,936 transactions from Bitcoin network, and
ignore those with more than 12 inputs (which barely happen
in today’s network, seeFig. 1). Resembling reality, these
transactions are sent to the system at a certain frequency.
For each transaction tx, it is assigned to the committee, the
ID of which is tx hash mod 20.

For the speciﬁc parameters, we set the remaining fraction
of computation resources to process transactions for leaders
and common members to be pl = 0.7 and pm = 0.9
correspondingly. Further, for the two parameters in bonus
part of the reputation updating process (see (2)), we set
σ = 0.1 and ω = 0.5.

In order to observe the effect of the reputation mecha-

nism, we evaluate it using the following metrics.

7. The core step to process cross-shard transactions is the intra-

committee voting on the status of relevant inputs.

• Leaders’ computation resource: the average compu-

tation resources of all leaders in one round.

• Transactions processed per round: number of the

processed transactions in one round.

We mainly compare the outcomes of leader selection scheme
via reputation and random leader selection scheme, which is
widely adopted by other sharding blockchain solutions [12].

6.2 Results

We run the simulation for 1,000 rounds for both cases: leader
selection scheme via reputation and random leader selection
scheme. Fig. 5 shows the ratio of the average computation
resources of 20 leaders to the average computation resources
of 20 most computationally-intensive nodes against round
number under both schemes. For the random leader se-
lection scheme, the ratio ﬂuctuates with an expected value
of approximately 0.37. Meanwhile, for our leader selection
scheme via reputation, the ratio continuously rises and
reaches 1 in 1,000 rounds. There are two reasons for the
small oscillation on the ratio for our scheme: (1) leaders
suffer more loss on computation resources than common
members, and (2) leaders gain less reputation than those
common members with high computation resources. As
a result, those nodes whose computation resources are a
bit lower than maximal also have the chance to process
all transactions provided by the leader, therefore gaining
higher reputation, and becoming the leader.

Fig. 6 shows the ratio of accumulated number of transac-
tions processed under two types of leader selection schemes.
It turns out that the ratio continuously rises in 1,000 rounds.
By the end of round 1,000, the number of processed trans-
actions under leader selection scheme with reputation is
approximately 5.5× the corresponding number under the
random leader selection scheme. Such result is a direct
corollary of the previous result. As leaders are with higher
computation resources, they can include more transactions
in the consensus in each round, and therefore processing
more transactions.

Taken together, our leader selection scheme via rep-
utation successfully picks out those nodes with higher
computation resources and makes them leaders, therefore
dramatically improves the transaction-processing speed.

7 RELATED WORK

Elastico [20] is the ﬁrst sharding-based protocol for public
blockchains which can tolerate up to a fraction of 1/4 of
malicious parties. Unfortunately, it has a very weak safety
guarantee as the randomness in each epoch of the proto-
col can be biased by the adversary. Meanwhile, Elastico’s
small committees (only about 100 nodes in a committee)
cause a high probability to fail under a 1/4 adversary, and
cannot be released in a Proof-of-Work (PoW) system [22].
Speciﬁcally, when there are 16 shards, the failure proba-
bility is 97% over only 6 epochs [12]. OmniLedger [12]
also allows the adversary to take control of at most 25%
of the validators as well as assuming the adversary to be
mildly-adaptive, nevertheless, it depends on the assumption
that there is a never-absent trusty client to schedule the
leaders’ interaction when handling cross-shard transactions.
RapidChain [14] enhances the efﬁciency of sharding-based
blockchain protocols on a large scale, but the protocol guar-
antees high efﬁciency only when leaders of each committee
are honest, an unrealistic assumption in practice. Concretely,
in expectation, there is a proportion of 1/3 leaders that
are malicious in a round. Under this condition, cross-shard
transactions may hardly be included in a block. Further-
more, the protocol does not have an explicit incentive for
nodes to participate in. At the same time, all the above
postulate a good connection between any pair of truthful
nodes, which causes a huge burden in creating connection
channels.

Optchain [23] provides a transaction assignment algo-
rithm to reduce the number of cross-shard transactions,
while keeping load balance among shards. It mainly uses
a PageRank-like algorithm to assign linked transactions to
the same shard. The disadvantage is that this algorithm is
client-driven, requiring users to query information and do
much computation, but without any incentive. [24] focuses
on the processing of cross-shard transactions, which is of
vital importance to the system efﬁciency. By constructing
multiple inputs into a Merkle tree structure, the number of
BFT calls is largely reduced.

All above work fail to maintain liveness concerning
malicious committee leaders or transaction coordinators.
[25] solves this problem by involving a reference committee,
with an honest majority, and uses two-phase commit (2PC)
and two-phase locking (2PL) protocols to coordinate all
cross-shard transactions. However, such solution brings a
heavy overhead on the reference committee, which is a
major shortcoming. SSChain [26] introduces a root chain
to process cross-shard transactions. It solves the liveness
problem and ensure the system safety. However, the root
chain is easily corrupted. Furthermore, both above two
solutions cause a large reduce on the parallelism brought
by sharding, as the reference committee/root chain needs to
process cross-shard transactions sequentially.

11

8 CONCLUSION
We identify ﬁve basic issues in sharding blockchain. Specif-
ically, we analyze the challenges involved and present our
suggested solutions. In order to overcome the performace
bottlenecks caused by cross-shard transactions, we intro-
duce the concept of reputation and propose a reputation
mechanism. By scoring each node according to its historical
behavior, the term of reputation helps to locate those nodes
with more honest computational resources. By assigning
them to high-workload positions, the reputation mechanism
enhances the system’s capability to process transactions. In
addition, we introduce a semi-commitment scheme and a re-
covery procedure. They together enable users to detect and
evict malicious leaders, thus trading safely in the system.
Theoretical analysis and simulation results conﬁrm that our
design can signiﬁcantly improve the system performance,
without sacriﬁcing any safety and liveness.

REFERENCES

[1]

S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,”
Manubot, Tech. Rep., 2019.

[2] G. Wood et al., “Ethereum: A secure decentralised generalised
transaction ledger,” Ethereum project yellow paper, vol. 151, no. 2014,
pp. 1–32, 2014.

[3] K. Croman, C. Decker, I. Eyal, A. E. Gencer, A. Juels, A. E. Kosba,
A. Miller, P. Saxena, E. Shi, E. G. Sirer, D. Song, and R. Wattenhofer,
“On scaling decentralized blockchains - (A position paper),” in
Financial Cryptography and Data Security - FC 2016 International
Workshops, BITCOIN, VOTING, and WAHC, Christ Church, Barbados,
February 26, 2016, Revised Selected Papers, ser. Lecture Notes in
Computer Science, vol. 9604. Springer, 2016, pp. 106–125.
[4] Visa, “Visa’s transaction per second,” https://usa.visa.com/

[5]

run-your-business/small-business-tools/retail.html.
I. Bentov, R. Pass, and E. Shi, “Snow White: Provably secure proofs
of stake,” IACR Cryptol. ePrint Arch., vol. 2016, p. 919, 2016.
[6] B. David, P. Gazi, A. Kiayias, and A. Russell, “Ouroboros
Praos: An adaptively-secure, semi-synchronous proof-of-stake
blockchain,” in Advances in Cryptology - EUROCRYPT 2018 - 37th
Annual International Conference on the Theory and Applications of
Cryptographic Techniques, Tel Aviv, Israel, April 29 - May 3, 2018
Proceedings, Part II, ser. Lecture Notes in Computer Science, vol.
10821. Springer, 2018, pp. 66–98.
S. Micali, M. O. Rabin, and S. P. Vadhan, “Veriﬁable random
functions,” in 40th Annual Symposium on Foundations of Computer
Science, FOCS ’99, 17-18 October, 1999, New York, NY, USA.
IEEE
Computer Society, 1999, pp. 120–130.

[7]

[8] Y. Gilad, R. Hemo, S. Micali, G. Vlachos, and N. Zeldovich,
“Algorand: Scaling byzantine agreements for cryptocurrencies,”
in Proceedings of the 26th Symposium on Operating Systems Principles,
Shanghai, China, October 28-31, 2017. ACM, 2017, pp. 51–68.
[9] B. Schoenmakers, “A simple publicly veriﬁable secret sharing
scheme and its application to electronic,” in Advances in Cryptology
- CRYPTO ’99, 19th Annual International Cryptology Conference,
Santa Barbara, California, USA, August 15-19, 1999, Proceedings, ser.
Lecture Notes in Computer Science, vol. 1666. Springer, 1999, pp.
148–164.

[10] I. Cascudo and B. David, “SCRAPE: scalable randomness attested
by public entities,” in Applied Cryptography and Network Security -
15th International Conference, ACNS 2017, Kanazawa, Japan, July 10-
12, 2017, Proceedings, ser. Lecture Notes in Computer Science, vol.
10355. Springer, 2017, pp. 537–556.

[11] A. Kiayias, A. Russell, B. David, and R. Oliynykov, “Ouroboros: A
provably secure proof-of-stake blockchain protocol,” in Advances
in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology
Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceed-
ings, Part I, ser. Lecture Notes in Computer Science, vol. 10401.
Springer, 2017, pp. 357–388.

[12] E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly, E. Syta, and
B. Ford, “OmniLedger: A secure, scale-out, decentralized ledger
via sharding,” in 2018 IEEE Symposium on Security and Privacy, SP
2018, Proceedings, 21-23 May 2018, San Francisco, California, USA.
IEEE Computer Society, 2018, pp. 583–598.

[13] A. Manuskin, M. Mirkin, and I. Eyal, “Ostraka: Secure blockchain
scaling by node sharding,” in IEEE European Symposium on Secu-
rity and Privacy Workshops, EuroS&P Workshops 2020, Genoa, Italy,
September 7-11, 2020.

IEEE, 2020, pp. 397–406.

[14] M. Zamani, M. Movahedi, and M. Raykova, “RapidChain: Scaling
blockchain via full sharding,” in Proceedings of the 2018 ACM
SIGSAC Conference on Computer and Communications Security, CCS
2018, Toronto, ON, Canada, October 15-19, 2018. ACM, 2018, pp.
931–948.

[15] B. Awerbuch and C. Scheideler, “Towards a scalable and robust
DHT,” Theory Comput. Syst., vol. 45, no. 2, pp. 234–260, 2009.

[16] M. S. Ferdous, M.

J. M. Chowdhury, M. A. Hoque, and
A. Colman, “Blockchain consensus algorithms: A survey,”
CoRR, vol. abs/2001.07091, 2020.
[Online]. Available: https:
//arxiv.org/abs/2001.07091

[17] M. Castro and B. Liskov, “Practical byzantine fault tolerance,” in
Proceedings of the Third USENIX Symposium on Operating Systems
Design and Implementation (OSDI), New Orleans, Louisiana, USA,
February 22-25, 1999. USENIX Association, 1999, pp. 173–186.
[18] M. Zhang, J. Li, Z. Chen, H. Chen, and X. Deng, “CycLedger:
A scalable and secure parallel protocol for distributed ledger
via sharding,” in 2020 IEEE International Parallel and Distributed
Processing Symposium (IPDPS), New Orleans, LA, USA, May 18-22,
2020.

IEEE, 2020, pp. 358–367.

[19] C. Huang, Z. Wang, H. Chen, Q. Hu, Q. Zhang, W. Wang,
and X. Guan, “RepChain: A reputation based secure, fast and
high incentive blockchain system via sharding,” CoRR, vol.
abs/1901.05741, 2019. [Online]. Available: http://arxiv.org/abs/
1901.05741

[20] L. Luu, V. Narayanan, C. Zheng, K. Baweja, S. Gilbert, and
P. Saxena, “A secure sharding protocol for open blockchains,”
in Proceedings of the 2016 ACM SIGSAC Conference on Computer
and Communications Security, Vienna, Austria, October 24-28, 2016.
ACM, 2016, pp. 17–30.

[21] C. Cachin, R. Guerraoui, and L. Rodrigues, Introduction to reliable
Springer Science & Business

and secure distributed programming.
Media, 2011.

[22] A. Gervais, G. O. Karame, V. Capkun, and S. Capkun, “Is Bitcoin a
decentralized currency?” IEEE Secur. Priv., vol. 12, no. 3, pp. 54–60,
2014.

[23] L. N. Nguyen, T. D. T. Nguyen, T. N. Dinh, and M. T.
Thai, “Optchain: Optimal transactions placement for scalable
blockchain sharding,” in 39th IEEE International Conference on
Distributed Computing Systems, ICDCS 2019, Dallas, TX, USA, July
7-10, 2019.

IEEE, 2019, pp. 525–535.

[24] Y. Liu, J. Liu, J. Yin, G. Li, H. Yu, and Q. Wu, “Cross-shard
transaction processing in sharding blockchains,” in Algorithms and
Architectures for Parallel Processing - 20th International Conference,
ICA3PP 2020, New York City, NY, USA, October 2-4, 2020, Proceed-
ings, Part III, ser. Lecture Notes in Computer Science, vol. 12454.
Springer, 2020, pp. 324–339.

[25] H. Dang, T. T. A. Dinh, D. Loghin, E. Chang, Q. Lin, and B. C. Ooi,
“Towards scaling blockchain systems via sharding,” in Proceedings
of the 2019 International Conference on Management of Data, SIGMOD
Conference 2019, Amsterdam, The Netherlands, June 30 - July 5, 2019.
ACM, 2019, pp. 123–140.

[26] H. Chen and Y. Wang, “SSChain: A full sharding protocol for
public blockchain without data migration overhead,” Pervasive
Mob. Comput., vol. 59, p. 101055, 2019.

Mengqian Zhang received the B.S. degree
in computer science from Ocean University of
China in 2018. She is currently pursuing the
doctor’s degree at the Department of Computer
Science and Engineering, Shanghai Jiao Tong
University, China. Her current research interests
include Blockchain, Algorithmic Game Theory
and Mechanism Design.

12

Jichen Li received the B.S. degree in computer
science at School of EECS, Peking University
in 2020. He is currently pursuing the doctor’s
degree at Center on Frontiers of Computing
Studies, Peking University. His current research
interests focus on Blockchain and Mechanism
Design.

Zhaohua Chen is now a fourth-year undergrad-
uate student at School of EECS, Peking Univer-
sity. His research interest lies in various subjects
of theoretical computer science.

Hongyin Chen received the B.S. degree at
School of EECS, Peking University in 2020. He
is currently pursuing the doctor’s degree at Cen-
ter on Frontiers of Computing Studies, Peking
University. His current research interests include
Blockchain and Mechanism Design.

Xiaotie Deng got his BSc from Tsinghua Univer-
sity, MSc from Chinese Academy of Sciences,
and PhD from Stanford University in 1989. He
is currently a chair professor at Peking Univer-
sity. He taught in the past at Shanghai Jiaotong
University, University of Liverpool, City University
of Hong Kong, and York University. Before that,
he was an NSERC international fellow at Si-
mon Fraser University. Deng’s current research
focuses on algorithmic game theory, with appli-
cations to Internet Economics and Finance. His
works cover online algorithms, parallel algorithms, and combinatorial
optimization. He is an ACM fellow for his contribution to the interface
of algorithms and game theory, and an IEEE Fellow for his contributions
to computing in partial information and interactive environments.

