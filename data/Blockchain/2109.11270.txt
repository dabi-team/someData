1
2
0
2

p
e
S
3
2

]

R
C
.
s
c
[

1
v
0
7
2
1
1
.
9
0
1
2
:
v
i
X
r
a

Towards Private On-Chain Algorithmic Trading

Ceren Kocao˘gullar1, Arthur Gervais2, and Benjamin Livshits2

1 University of Cambridge
2 Imperial College London

Abstract. While quantitative automation related to trading crypto-
assets such as ERC-20 tokens has become relatively commonplace, with
services such as 3Commas and Shrimpy oﬀering user-friendly web-driven
services for even the average crypto trader, not the mention the specialist,
we have not yet seen the emergence of on-chain trading as a phenomenon.
We hypothesize that just like decentralized exchanges (DEXes) that by
now are by some measures more popular than traditional exchanges, pro-
cess in the space of decentralized ﬁnance (DeFi) may enable attractive
online trading automation options.
In this paper we present ChainBot, an approach for creating algorithmic
trading bots with the help of blockchain technology. We show how to
partition the algorithmic computation into on- and oﬀ-chain components
in a way that provides a measure of end-to-end integrity, while preserving
the algorithmic “secret sauce”. The end result is a system where an end-
user can sign-up for the services of a trading bot, with trust established
via on-chain publicly readable contracts. Our system is enabled with a
careful use of algorithm partitioning and zero-knowledge proofs together
with standard smart contracts available on most modern blockchains.
Our approach oﬀers more transparent access to liquidity and bet-
ter censorship-resistance compared to traditional oﬀ-chain trading ap-
proaches both for crypto- and more traditional assets. We show that the
end-to-end costs and execution times are aﬀordable for regular use and
that gas costs can be successfully amortized because trading strategies
are executed on behalf of large user pools. Finally, we show that with
modern layer-2 (L2) technologies, trades issued by the trading bot can
be kept private, which means that algorithmic parameters are diﬃcult
to recover by a chain observer.
With ChainBot, we develop a sample trading bot and train it on histori-
cal data, resulting in returns that are up to 2.4× and on average 1.4× the
buy-and-hold strategy, which we use as our baseline. Our measurements
show that across 1000 runs, the end-to-end average execution time for
our system is 48.4 seconds. We demonstrate that the frequency of trading
does not signiﬁcantly aﬀect the rate of return and Sharpe ratio, which
indicates that we do not have to trade at every block, thereby signiﬁ-
cantly saving in terms of gas fees. In our implementation, a user who
invests $1,000 would earn $105, and spend $3 on gas; assuming a user
pool of 1,000 subscribers.

Keywords: Blockchain privacy, Algorithmic trading, Decentralized ﬁ-
nance

 
 
 
 
 
 
1 function algoTrade ( uint numPeriods , uint periodSize , uint
upperPerc , uint lowerPerc , uint amount ) public {

2
3
4
5
6
7
8
9
10
11
12 }

require ( msg . sender == admin ) ;
uint currentTime = block . timestamp ;
uint price = Oracle . getPriceAt ( currentTime ) ;
uint movingAvg = SMA ( currentTime , numPeriods , periodSize ) ;

if ( price > ( movingAvg / 100) * (100 + upperPerc ) )

DEX . swap ( token1 , token0 , amount ) ;

else if ( price < ( movingAvg / 100) * (100 - lowerPerc ) )

DEX . swap ( token0 , token1 , amount ) ;

Fig. 1. A strawman on-chain trading algorithm example written in Solidity, which uses
the Simple Moving Average (SMA) indicator.

1

Introduction

Electronic ﬁnancial markets utilise trading algorithms to automate their trading
strategies, processing ﬁnancial data, news and such to make predictions about
the state of the market. The rise of Decentralized Finance (DeFi) have paved
the way for algorithmic trading in cryptomarkets. With assets as well as trans-
actions having presence on distributed, decentralized and public blockchains,
crypto-trading bots have the potential to provide security and integrity proper-
ties unparalleled in traditional settings.

Trading on-chain with a crypto-trading bot brings unique beneﬁts. For in-
stance, on-chain liquidity provides transparency in terms of costs and availability.
Moreover, centralized systems fall short in privacy and censor-resistance, a re-
cent example being the regulatory pressures against the prominent centralized
cryptomarket Binance [60].

This paper lays the foundation for private on-chain algorithmic trading, an
approach we call ChainBot. On-chain trading has the advantage of full trans-
parency favored by DeFi advocates and users, however, transparency kills the
competitive advantage a trading algorithm might have over its competitors. Run-
ning the algorithms oﬀ-chain, as crypto-trading bots 3Commas [1], Shrimpy [5]
and others do, may enable privacy; however, without the transparency and in-
tegrity properties of on-chain execution, users have to trust the oﬀ-chain bots
with executing trading algorithms and handling user funds correctly. The focus
of this work is an approach that combines on-chain and oﬀ-chain computation
to create on-chain trading algorithms that are trust-minimized and transparent
yet able to execute in a way that does not destroy their competitive advantage
due to privacy loss.

Strawman example of on-chain trading. Consider a simple trading algo-
rithm that estimates the price by calculating price averages within a moving

2

history, namely the Simple Moving Average (SMA), and buys (or sells) if the
actual price is lower (or higher) than a determined lower (or upper) bound [43].
The Solidity function presented in Figure 1 implements this algorithm for on-
chain execution, calculating

1. the SMA (movingAvg) starting from currentTime with a window of

numPeriods-many periodSize-second intervals;

2. lower and upper bounds lowerPerc and upperPerc below and above the

movingAvg, respectively.

Calling this function deployed on a smart contract will execute automated trades
on-chain, however, the trading algorithm, parameters it takes and the resulting
trades will be public information. Therefore, even though line 3 of Figure 1
restricts function calls to someone assigned as the administrator, anyone can
copy this function and deploy it to another smart contract or watch the trades of
this contract to mirror its actions. This simple example highlights a fundamental
problem in DeFi: if the code can be read, it can be cloned as well. While some
DeFi protocols have taken to obfuscating Solidity code and putting obfuscated
EVM code into their contracts, cloning generally remains possible. ChainBot
suggests a fundamentally better approach.

1.1 Contributions

This paper makes the following contributions:

– Combining on-/oﬀ-chain. In this paper, we propose a hybrid on-/oﬀ-chain
approach we call ChainBot that combines the beneﬁts of on-chain integrity
and transparency with the privacy beneﬁts of oﬀ-chain execution. Oﬀ-chain
integrity is maintained via zero-knowledge proofs based on Zokrates [26].
– Parametrized algorithms. We show how to use the hybrid execution strat-
egy to build automatic crypto-trading bots, where the (public) code of the
bot is parametrized by (conﬁdential) parameters derived by training on his-
torical data.

– Conﬁdential trading. We further show how to run these on-/oﬀ-chain bots
in a way that uses a private L2-based decentralized exchange and on-chain
oracles for price data.

– Experimental evaluation. We train our selected parametrized trading
algorithm on historical ETH:USDC price data and illustrate that training
can yield up to 2.4× and on average 1.4× returns compared to the buy-and-
hold strategy, eﬀectively indicating that the ChainBot approach is viable
for algorithmic traders. The experimental evaluation of our implemented
ChainBot show that end-to-end execution of each trade takes 48.4 seconds
on average. We demonstrate that trading frequency does not eﬀect returns
signiﬁcantly, signalling reduced gas fees. The cost analysis exhibits that the
system is able to sustain continuous trading with a per-trade amortized cost
of ∼$0.15 per user, assuming a user base of 1,000 people.

3

2 Background

This section discusses the trade-oﬀs of designing on- and oﬀ-chain systems that
work together in Section 2.1; Section 2.2 talks about privacy-preserving tech-
niques for public blockchains. Lastly, Section 2.3 discusses the basics of algorith-
mic trading.

2.1 On-Chain/Oﬀ-Chain Trade-oﬀs

Blockchain technology has several inherent security properties such as consis-
tency and availability enabled by decentralization; tamper-resistance through
storing chains of hashes; and resistance to double-spending by using crypto-
graphic signatures [62]. On the other hand, having a permissionless consensus
structure and propagating every state change throughout the network leads to
low transaction throughput, existence of transaction fees and lack of privacy.

Layer-2 (L2) protocols built on top of (layer-1/L1 ) blockchains can improve
scalability by carrying out transactions oﬀ-chain and submitting a smaller num-
ber of assertions or proofs to the blockchain than the number of transactions [31].
Notable L2 protocols include Plasma [44], which uses side-chains, and Lightning
Network [45], which has state channels. Another notable L2 approach is using
optimistic or ZK-rollups, where multiple oﬀ-chain transactions are batched in a
fraud or zero-knowledge proof, respectively, and submitted to the chain [18].

Despite increasing throughput and decreasing transaction costs, these solu-
tions do not fully preserve the privacy, as they keep the transaction data available
to at least some of the participants or reveal it in case of dispute. Validium-style
L2 solutions such as StarkEx [6] (the basis for DiversiFi [3] exchange) keep
both computation and data oﬀ-chain. However, this leads to a potential data
availability problem, preventing those who do not have access to the transaction
data from reconstructing the state. The current solution to this issue is passing
the responsibility of making sure that data is available to a Data Availability
Committee (DAC), falling short in providing full privacy.

2.2 Blockchain Privacy

Gudgeon et al. provide a survey of L2 blockchain protocols, so of which focus on
privacy, mainly based on submitting assertions or proofs to the chain [31].

Oﬀ-chain computation. TrueBit project provides an oﬀ-chain computation
layer where computational tasks can be outsourced in a privacy-preserving way,
however, disputed data should be made public since fraud proofs are used [55].
zkay [13,54] a high-level programming language sidesteps this issue by solely
depending on cryptographic primitives; on the other hand, the cost of verifying
zero-knowledge proofs on-chain may be high.

One way of achieving privacy with oﬀ-chain computation is by mixing cryp-
tography and incentivization, as in Hawk [38], Arbitrum [36] and Ekiden [23].

4

Nevertheless, this approach comes at the cost of losing the intrinsic trustless-
ness of blockchain: Hawk and Arbitrum have trusted managers and Ekiden de-
pends on trusted hardware. There have been eﬀorts to replace trusted entities
with secure multi-party computation (MPC) and similar mechanisms, such as
Raziel [49], zkHawk [12], Enigma [66], and ZEXE [16]; however, carrying out
computation on encrypted data is a heavyweight and costly task, as recognised
by these works.

Privacy-focused L1s. The prominent privacy-preserving payment proto-
cols such as Zerocash [50] and cryptocurrencies like Zcash [33], Solidus [20],
Monero [42] and several others [25,57,35,17,29] oﬀer conﬁdential transactions
but cannot be used for general computation. Similarly, non-privacy preserving
blockchains have seen the adoption of add-on mixers [39]. Lastly, blockchains
designed with privacy considerations, such as Dusk [40], can enable privacy, but
having a separate chain might cause complicate integration with existing plat-
forms and features. In recent years, popular privacy-focused chains have been
subjected to a number of deanonimization attacks [14,61,24,59].

2.3 Algorithmic Trading of Cryptocurrencies

Digitalization of data and operations in traditional markets have enabled the
usage of computer algorithms for making trading decisions [32]. In 2011, over 73%
of equity volume in the U.S. were handled with algorithmic trading [56]. Despite
being a highly inﬂuential portfolio and asset management tool, the inherent
competition, scantiness of expertise, and high proﬁtability cause algorithmic
trading to be an opaque subject [21,22,37,43,56].

Algorithmic trading roadmap. Determining a trading algorithm is the
ﬁrst step of algorithmic trading; Some of the basic traditional algorithms
include Volume-Weighted Average Price (VWAP), Time-Weighted Average
Price (TWAP), implementation shortfall, and arrival price [37]. Once a trad-
ing algorithm is chosen or created, it should be backtested, i.e. run on historical
data to evaluate its performance [21,22]. After a successful backtest, real-world
trading can proceed. This is a multi-step process: First, real-time or historic
ﬁnancial, economic or social/news data, should be collected, prepared, and an-
alyzed. The selected algorithm then uses the data to make a trade decision, the
trade is executed, and lastly, analyzed [56].

Blockchain automated trading. One of DeFi’s objectives, when compared
to traditional ﬁnance, is to foster ﬁnancial transparency and accountability [46],
while ﬂash loans provide novel atomic lending contracts granting instantaneously
billions of USD in debt [48]. The assets, as well as the operations being digital
in blockchain, DeFi has facilitated handling many tasks related to governance,
issuance, and order matching algorithmically [19]. The same trend is observed
in trading and portfolio management: several studies have shown that machine
learning can be used for Bitcoin price prediction [51] or directly outputting the
portfolio vector [34] to automate Bitcoin trading and execute high-frequency
trading [58]. A recent study has shown that high-frequency trading can occur in

5

adversarial form, taking advantage of the inherently deterministic Automated-
Market Maker DEXes [65] to exploit blockchain extractable value [47]. Re-
garding high-frequency trading, recurring price discrepancies among cryptoex-
changes generate arbitrage opportunities [41], enabling cross-market statistical
arbitrage [43,64] and automated tools generate proﬁtable transactions ﬁnding
arbitrage and attack vectors [63].
Crypto-bots. Besides these academic eﬀorts, commercial and community-
driven portfolio management protocols include web-based trading bots that au-
tomate simple trading strategies [1,5], savings accounts running simultaneous
investment strategies [9], rebalancing token sets [7]. Another prominent cate-
gory of automated traders is social trading platforms that copy the strategies of
experienced traders [1,2,5,8].

3 Overview

This section presents an overview of the concepts and components that form
ChainBot. Section 3.1 presents a blueprint for private on-chain algorithmic
trading. Section 3.2 describes the on- and oﬀ-chain components of the system
and their roles. Lastly, Section 3.5 discusses how integrity is preserved end-to-end
throughout on-chain/oﬀ-chain interactions and data exchanges.

3.1 Private On-Chain Algorithmic Trading

Commercial trading bots that execute trades on behalf of users in exchange for
a fee or commission require user trust to a signiﬁcant degree, therefore incom-
patible with the DeFi’s convergence towards minimal trust. Notably, the users
of an oﬀ-chain trading bot cannot verify that the bot uses a legitimate trading
algorithm to execute trades, even in the case that an algorithm is disclosed to
the users. Moreover, the users have to trust that the bot will be managing their
funds with integrity and will not steal, withhold, or lose them.

Executing the trading algorithm on-chain eliminates the need for trust, since
users of a fully on-chain bot can audit the trading algorithm and make sure that
it is being correctly executed. Moreover, the user funds can be stored in a smart
contract safely and the users can have full control over their money. On the
other hand, with the algorithm open to the public, the bot loses its competitive
advantage, as indicated by the existence of social trading platforms [1,2,5,8] that
mirror the strategies of well-performing traders.

We suggest that an optimal mix of oﬀ-chain and on-chain computation can
enable algorithmic trading with integrity, minimal trust and increased trans-
parency while conserving competitive advantage. The core idea is having the
skeleton and public parameters of a parametrized trading algorithm on-chain,
while keeping the parameters critical to the algorithm’s performance private by
storing them oﬀ-chain. These private parameters can be periodically optimized
through training the trading algorithm oﬀ-chain, adapting to changing market
conditions. Secrecy of private parameters are preserved through running the

6

On-chain bot

Oﬀ-chain bot

Proof system

Obtaining price information from
the on-chain price oracle

Calculating public parameters of
the trading algorithm, such as ﬁ-
nancial indicators
Checking the correctness of pub-
lic parameters including the price
used in each trade decision

Performing algorithmic training
to ﬁnd the optimal private pa-
rameters
Making trade decisions based on
the trading algorithm using pub-
lic and private parameters
privacy-
on
Trading
enhancing DEX once a proof has
been veriﬁed

the

Containing the Zokrates program
that bears the trading logic to be
proven
Generating the veriﬁer contract
from the Zokrates code and de-
ploying it to the chain
Creating a zero-knowledge proof
of each trading decision, without
revealing any information about
private parameters

Fig. 2. Functionalities that each ChainBot unit is responsible for. Those that need to
be customized according to the trading algorithm are colored, generic functionalities
are uncolored.

trading algorithm oﬀ-chain and using zero-knowledge proofs to verify on-chain
that the algorithm is run correctly. Once a proof is veriﬁed, the trades should be
executed privately to protect private parameters from being reverse engineered.

3.2 System Components

ChainBot consists of multiple on-chain and oﬀ-chain elements categorized un-
der three main units based on their roles in the system: (1) on-chain bot, (2) oﬀ-
chain bot and (3) proof system. In addition to these internal units, the system
requires interaction with two external entities: (1) An L2 privacy-enhancing DEX
such as DeversiFi [3] (see Appendix A.3 for implementation details of Deversiﬁ in
our system) and (2) an on-chain oracle, such as Uniswap [11] or ChainLink [27].
Data used in feeding the algorithms can be simple as price or more complex as
orderbook data, so long as the data provider is an on-chain oracle.

The main units of ChainBot are described below. Functionalities of each
unit is listed in Figure 2, classiﬁed as generic and algorithm-dependent custom
functionalities to provide direction for the developer who wants to deploy their
own ChainBot.

– On-chain bot is a smart contract that is responsible for obtaining and
calculating public parameters (price, ﬁnancial indicators, etc.) and ensuring
that they are used correctly in trade decisions.

– Oﬀ-chain bot trains the algorithm (see Section 4.1 and Appendix A.1),

stores private parameters, makes trade decisions and executes trades.

– Proof system consists of an on-chain veriﬁer and oﬀ-chain proof generator.
It keeps the private parameters hidden from all other than the oﬀ-chain
bot while ensuring the correctness of trade decisions. Zokrates3[26] or any
zero-knowledge proof system that allows on-chain veriﬁcation can be used
here. Appendix A.2 discusses the implementation details of Zokrates in our
system.

3 https://zokrates.github.io/

7

Oﬀ-chain
bot

On-chain
bot

GetPublicParams()

Veriﬁer
Contract

On-chain
Oracle

DEX

GetPrice()

price

publicParams =
(price,
CalculatePublicParams
(price))

IsEqual(publicParams,
proof.publicParams)

VerifyProof(proof)

veriﬁcationResult

publicParams

tradeDecision =
DecideTrade(publicParams,

privateParams)

proof =
GenProof(tradeDecision,
publicParams,
privateParams)

VerifyProof(proof)

veriﬁcationResult

Trade(pair, amount, price)

Fig. 3. Trading bot architecture as a sequence diagram.

Each trade is a sequence of events and interactions between these three units
as well as the two external entities, namely the privacy-enhancing DEX and
the on-chain oracle. Figure 3 describes the detailed end-to-end algorithmic trade
process that can be summarized as follows: Oﬀ-chain bot requests public pa-
rameters from the on-chain bot, which obtains the price data from the price
oracle and calculates the other public parameters if necessary. Once receiving
the public parameters, oﬀ-chain bot runs the algorithm with public and private
parameters to make a trading decision and creates a proof of it. The proof is
veriﬁed on-chain by the veriﬁer contract, while the on-chain bot checks the cor-
rectness of public parameters. Once a proof is veriﬁed, the oﬀ-chain bot executes
the trade on the privacy-enhanced DEX.

It is important to note that the diagram does not include user subscrip-
tion stages, as they are not fundamental to the trading process. We outline the
necessary conditions for user subscription as follows:

– Each user subscribes to ChainBot by sending their funds to the on-chain

bot.

– On-chain bot records the amount invested by each user.
– In each trade, on-chain bot uses the pooled user funds for trading and paying

execution fees.

8

– Once a trading epoch is complete, the on-chain bot pays each user their

share of returns.

3.3 Algorithmic Training

We implement a simple algorithmic training method using grid search to demon-
strate the process of creating parameters that can bring competitive advantage
to the bot owner, therefore she may want to keep secret. This method aims to
produce a trading algorithm that outperforms arguably the most basic of trading
strategies — buy-and-hold.

The trading algorithm. We adopt a trading algorithm that uses Bollinger
Bands (BBs) [15], a technical analysis tool that considers the “envelope” around
a simple moving average using a number of standard deviations both above
(upper Bollinger Band ) and below (lower Bollinger Band ) (see Appendix A.1,
Equation 2). Our trading algorithm signals a buy (sell) if the current price is
within a threshold percentage range below (above) of the lower (upper) Bollinger
Band (see Appendix A.1, Equation 3).

There are two main reasons behind our choice of algorithm, which we refer

to as Bollinger algorithm:

1. Through backtesting, we have observed that this trading strategy is simple
yet powerful enough to make proﬁt when buy and hold is an unproﬁtable
strategy.

2. It is suitable for parametrization as described below.

Period selection. To determine training and testing periods, we ﬁnd all 30-day
periods within a date range where buy-and-hold was an unproﬁtable strategy.
The ﬁrst half of these periods are allocated for training and the rest for testing.
It is important to note that changing how often is a trade is executed, i.e. the
trading period, may also change the trading and testing periods.

Training. Algorithmic training is based on parametrization of the algorithm
and optimizing those parameters. We parametrize Bollinger algorithm with four
parameters:

– moving average period size (N ),
– number of standard deviations (D),
– percentage threshold that the price should be from the upper Bollinger band

to sell (U ), and

– the lower Bollinger band to buy (L).

We train the algorithm through grid search, feeding it the minimum, maximum,
and mean values of each parameter. Finally, we rank the parameter conﬁgura-
tions based on performance.

Testing. Once we determine the top-performing parameter conﬁgurations, we
run the trading algorithm with each conﬁguration throughout the testing periods
and record the relative returns to buy-and-hold strategy.

9

3.4 Trust Assumptions

ChainBot makes the following trust assumptions:
A1: Blockchain security. We ignore the ramiﬁcations of blockchain forks [30],
and assume that the majority of consensus participants are honest. We further
ignore bugs and security vulnerabilities in smart contracts.
A2: Validity of the trusted setup.
In zero-knowledge proof systems using
zk-SNARKs, veriﬁcation and proving keys are created based on a trusted setup
phase. Since multiple users are interested in the correctness of the proofs in our
setting, a so-called ceremony that likely involves MPC should be used for the
trusted setup [10,13].
In ChainBot, we assume that the oﬀ-
A3: Oﬀ-chain bot fund integrity.
chain bot manages the user funds with integrity, i.e. it does not steal or withhold
but only uses assets for trading. We also assume that the bot performs algorith-
mic training honestly and favorably, feeding the trained parameters properly into
the proof. It is important to highlight that these assumptions do not include any
reliance to the oﬀ-chain bot for executing the trading algorithm correctly. More-
over, although an oﬀ-chain bot is capable of stealing or withholding user funds,
unlike in an oﬀ-chain trading bot, users can verify the ﬂow of their funds by
querying the blockchain ledger. One way to ensure that in practical terms might
be to use permissioned trading APIs of centralized exchanges such as Binance,
etc. for oﬀ-chain bot operations speciﬁcally designed to address the bot trading
scenario.
A4: DEX integrity. In terms of the external entities that ChainBot interacts
with, we assume that the privacy-enhancing DEX enables a method for ensuring
that trades are executed correctly based on the veriﬁed ﬁnancial decisions. For
instance, the DEX can provide a transaction hash that can be checked against a
Merkle root by anyone and used for verifying the mentioned information through
a zero-knowledge proof. We further assume that the DEX either provides full
privacy for trades or if it shares any trade data with any parties (such as the
DAC in DeversiFi — see Appendix A.3), they are impartial and honest.
A5: DEX privacy. We assume that the DEX is able to make trades in a way
that does not reveal trade types (i.e. asset pair), sources and destinations, as
well as amounts to blockchain observers.
A6: Oracle integrity. We assume that the on-chain price oracle provide accu-
rate data. Attacks against oracles are outside of this paper’s scope [28].

3.5 Threat Analysis

ChainBot is designed to prevent two types of threats: end-to-end integrity
threats to the trading bot and theft of the trading algorithm.
End-to-end trading integrity. More speciﬁcally, this entails the following:

1. verifying that the correct public parameter values are used in trade decisions,
enabled by the proof system’s ability to include some parameters openly in

10

Sharpe Ratio

Ranking method Parameter conﬁg. Max. Min. Mean Standard dev.
13.1852
13.1852
13.1852
13.1852
13.1852
13.1852
29.3001
27.7299
30.4554
33.0127
32.6477
30.7954

60.3300 3.9800 29.5014
1.1.-1.-1
60.3300 3.9800 29.5014
1.1.-1.30
60.3300 3.9800 29.5014
1.1.-1.14
60.3300 3.9800 29.5014
1.3.-1.-1
60.3300 3.9800 29.5014
1.3.-1.14
overall 60.3300 3.9800 29.5014
20.6.14.14 126.0000 14.0300 49.6879
20.6.14.30 121.8900 15.7400 49.3251
40.6.14.14 131.8100 9.7500 47.1009
40.6.14.30 141.2700 10.8900 50.9644
40.6.30.30 123.2500 10.6000 43.8679
overall 141.2700 9.7500 48.1893

Average Return

Fig. 4. Top ﬁve parameters’ relative returns (to buy-and-hold) with 10-minute trading
period, chosen based on Sharpe Ratio and average returns.

the proof, allowing the on-chain bot to verify that the proof indeed includes
the correct public parameters provided (see Section A.2); this uses A1 and A2
2. guaranteeing that the private parameters are included correctly in the algo-

rithm, guaranteed by the zero-knowledge proof; this uses A1;

3. ensuring that trading decisions are made based on correct asset pricing as

per A6;

4. ensuring that the trades are executed based on the trading decision, com-
bined with the assumption that the DEX provides a way to verify trades in
a way that does not damage user privacy; this uses A3, A4, and A5.

Algorithmic privacy. Algorithmic privacy stems from the fact that in Chain-
Bot we use parametrized algorithms where parameters are kept oﬀ-chain and
therefore cannot be easily stolen or replicated. Further, our reliance on a pri-
vate DEX makes reverse-engineering these parameters all but impossible. This
uses A3 and A5.

4 Experimental Analysis

In this section, we present our evaluation of algorithmic training and our Chain-
Bot implementation’s end-to-end execution. The results of the former suggest
that parametrising and pre-training trading algorithms on historical data does
improve returns signiﬁcantly, highlighting the value of hiding some parameters
for achieving algorithmic privacy. The second major concern in addition to prof-
itability is whether on-chain trading can be fast and cost-eﬀective enough. Our
time and gas costs of a single round of ChainBot, 48.4 seconds and 473,402 gas,
respectively, are acceptable in practice as we point out that there is no need to
trade, for instance, at every block. We demonstrate that trades do not have to
be placed so frequently without much loss of revenue.

11

Trading Period Parameter conﬁg. Max. Min. Mean Std. dev.

1m

10m

1h

20.3.-1.-1
20.3.-1.14
20.3.-1.30
40.3.14.14
40.3.14.30
overall

20.6.14.14
20.6.14.30
40.6.14.14
40.6.14.30
40.6.30.30
overall
40.1.14.-1
40.1.14.14
40.1.14.30
20.3.30.30
40.6.30.30
overall

51.70
381.82
63.40
281.35
63.34
281.35
32.31
100.66
32.64
102.52
381.82 -104.08 48.68

-104.08
-102.42
-102.42
5.08
5.08

126.00
121.89
131.81
141.27
123.25
141.27
130.69
131.66
131.66
126.21
117.89
131.66

49.69
14.03
49.33
15.74
47.10
9.75
50.96
10.89
10.60
43.87
9.75 48.19
48.84
9.44
49.05
9.44
49.05
9.44
40.55
0.23
14.28
47.38
0.23 46.97

105.65
86.36
86.37
21.80
22.35
74.86

29.30
27.73
30.46
33.01
32.65
30.80
30.98
31.30
31.30
30.95
25.66
30.30

Fig. 5. Comparison of relative returns (to buy-and-hold) for the top 5 strategies of 1-
hour, 10-minute and 1-minute trading periods. Top strategies selected based on average
returns.

4.1 Algorithmic Training

Setup. Algorithmic training requires an environment for implementing and
running the trading algorithm on historical data. We use Zenbot4, an open-
source oﬀ-chain cryptocurrency trading bot with backtesting features. We use
historical ETH-USDC price between 25.08.2020 and 25.08.2021, retrieved from
the Poloniex exchange.

Training. We perform grid search through the training periods and within the
space of minimum, maximum, and mean values that the parameters described in
Section 3.3 can take, with the limiting values for each parameter being: 1 ≤ M ≤
40, 1 ≤ D ≤ 6, −1 ≤ U ≤ 30, −1 ≤ L ≤ 30. Once we record the algorithm’s
performances using all parameter conﬁgurations in this space, the next step is
determining the top-performing parameters.

Since many factors such as proﬁtability and risk-aversion can be of varying
importance in diﬀerent settings, there is not a single method for determining
a trading algorithm’s success. Therefore, we use two diﬀerent approaches to
score the parameter conﬁgurations based on their performances: average return
and Sharpe ratio. Sharpe ratio, otherwise known as reward-to-variability ratio
is a well-known measure used in technical portfolio management, characterised

4 https://github.com/DeviaVir/zenbot

12

by the diﬀerence between the average return of an investment strategy and a
riskless investment, divided by the standard deviation of the former [52]:

Sa =

E[Ra − Rb]
σa

=

E[Ra − Rb]
(cid:112)var[Ra − Rb]

(1)

Testing. As Figure 4 shows, the top-ranking parameters based on average
return made up to 141% more return
compared to buy-and-hold.
Although this value

remained
at 60% for all conﬁgurations of Sharpe
ratio, this ranking strategy performed
with signiﬁcantly lower standard devi-
ation: overall less than half of average
return, at 13%.

These results are in-line with
the characteristics of two ranking
approaches: Average return strat-
egy aims to maximise returns, while
Sharpe ratio additionally takes risk
associated with the return into ac-
count. It is also important to note
that all parameter conﬁgurations per-
formed better than the buy-and-hold
strategy in all testing periods.

Fig. 6. Boxplot showing time performances
of (a) public parameter retrieval, (b) proof
generation, (c) proof veriﬁcation, (d) trad-
ing, (e) end-to-end run over 1000 trading
instances.

Summary. Our evaluation of algorithmic training demonstrates that even with
a simplistic trading algorithm and training method, parametrization and train-
ing can signiﬁcantly improve trading performance. This ﬁnding suggests that
parameter privacy can be an essential component of achieving algorithmic pri-
vacy.

4.2 End-to-End Performance

Time measurements. We evaluate ChainBot implementation’s performance
through 1000 end-to-end executions, as captured in Figure 6, which involves

1. retrieving and calculating public parameters on-chain,
2. generating the proof of trading decision,
3. verifying it on-chain, and
4. trading on DeversiFi.

The experiments were performed on a local machine (2-core Intel i5-5257U CPU
clocked at 2,7 GHz, with 8GB RAM, 256GB SSD), which is suitable for our
evaluation as the oﬀ-chain computations are not computationally intensive –

13

The results show, proof generation, which is the only calculation executed oﬀ-
chain and locally, takes the least amount of time among all operations, around 0.2
to 0.8 seconds. The time cost of end-to-end execution, is 48.4 seconds on average.
Although the time needed for the two on-chain tasks constitute the substan-
tial amount of end-to-end execution time vary signiﬁcantly (presumably aﬀected
by the network conditions), it invariably constitutes the substantial amount of
end-to-end execution time. It takes between 1.2 and 415.8, on average 22.8 sec-
onds to get public parameters, i.e. retrieve price from the oracle and calculate
the Bollinger bands. Time required to verify the oﬀ-chain bot’s trading decision
zero-knowledge proof is 1.6 to 317.2 seconds, averaging at 23 seconds. Once all
the necessary steps are complete, it takes approximately 2.3 seconds to execute
the actual trade on DeversiFi.

Interactions with three entities cost gas in ChainBot: the on-
Gas costs.
chain bot, the veriﬁer contract and the on-chain price oracle. Gas used for on-
chain bot including the gas spent on retrieving price from the on-chain oracle
is steady at 281,715 gas. Unlike these two components which perform the same
computation on each call, the veriﬁer contract’s calculations, and therefore gas
usage slightly varies among calls, with an average of 191,687 gas. As a result, the
average gas cost of end-to-end execution is around 0,04592ETH = ∼$150USD
(as of 28.08.2021).

Frequency of execution. We investigate the trading frequency’s eﬀect on re-
turns, motivated by minimizing the aggravated execution costs, since gas costs
are intrinsically (also demonstrated by our results) almost constant per trade.
We train and test the Bollinger algorithm as described in Section 3.3 with 1-
minute, 10-minute, and 1-hour trading periods. As Figure 5 shows, although
there is an inverse relationship between trading period length and mean rela-
tive returns, the diﬀerence between 1-hour and 1-minute trading periods is less
than 2%. Moreover, the results indicate that lower trading periods may lead to
higher standard deviation. Overall, trading less often might make similar returns
with lower risk, therefore can be a useful strategy for reducing gas costs.

Summary. The average 48.4 seconds time cost of end-to-end execution is dom-
inated by the on-chain operations, which show highly variable time performance
and cost around 473,402 gas. As frequency of execution does not eﬀect rate of
return signiﬁcantly, trading with lower frequencies can yield similar proﬁt as well
as reducing gas costs.

5 Limitations and Future Work

Slippage. An asset’s price change in the course of a trade, namely slippage,
and it might cause discrepancy between the trading algorithm’s expected and
realized trade decisions. Slippage’s eﬀect on trades is algorithm-dependent, since
an algorithm may compare the price at the moment of decision to various values
derived from that price. Moreover, an algorithm can use past prices, as in the case
of Bollinger algorithm, using indicators such as Simple Moving Average (SMA)

14

or Time-Weighted Average Price (TWAP), likely increasing susceptibility to
being aﬀected by slippage. Further research is needed to provide a systematic
understanding these eﬀects.

Oﬀ-Chain Integrity Concerns. Currently in StarkEx and DeversiFi, the only
way of verifying that a speciﬁc transaction was included in a proof batch is to
have access to the sequencer data. Therefore, users have no direct way of veri-
fying that the oﬀ-chain bot correctly executes the veriﬁed trade decisions. This
is not a shortcoming of our design but the systems available. To mitigate this
issue of the existing systems, a supervising committee can be appointed to ob-
serve oﬀ-chain bot’s trade decisions and executions, making a trade-oﬀ between
making conﬁdential trade information available to the committee members and
establishing end-to-end integrity.
Programming Language. ChainBot development requires implementing
and integrating multiple programs with various programming languages and
frameworks, making the process intricate and potentially fragile. A natural pro-
gression of this work is to create a programming language that is expressive
enough to cover the use cases and be compiled/transpiled to the necessary lan-
guages. Such a language may noticeably increase the robustness and practicality
of deployment and maintenance of the bot, as well as preventing data leaks with
type-checking. Although systems such as Hawk [38], Arbitrum [36], Ekiden [23],
and zkay [13,54] language aim to achieve easy development of private blockchain
programming, none of them quite provide the components required to develop
a ChainBot.

6 Conclusion

The aim of this research was to present a system for automating trading on
blockchains in a way that promotes minimized trust without losing the competi-
tive advantage. We introduce a hybrid approach, partitioning the trading process
into on- and oﬀ-chain components. Our approach uses zero-knowledge proofs to
maintain end-to-end integrity and privacy-enhancing DEXs to prevent trades
from being mirrored and private parameters from being reverse engineered.

We have presented a sample trading bot using our strategy and a simple
trading algorithm that uses Bollinger Bands. Parametrizing, training and testing
our bot on historical data has resulted in around 1.4× and up to 2.4× returns
relative to the baseline buy-and-hold strategy. In our implementation, an average
user willing to invest $1,000 with ChainBot would earn $105, while spending $3
on gas; this assumes a user pool of 1,000 subscribers.

Our measurements show that the end-to-end average execution time for our
implemented system is 48.4 seconds. We demonstrate that lowering the trading
frequency does not signiﬁcantly aﬀect the performance of the algorithm. This
result also indicates that by trading less often, gas costs can be reduced without
sacriﬁcing returns. These observation show that ChainBot is a viable and cost-
eﬀective strategy for building on-chain trading systems.

15

A Implementation Details

This section describes the implementation details of the system outlined in Sec-
tion 3. We cover algorithmic training in Appendix A.1, Zokrates details in Ap-
pendix A.2, and DiversiFi exchange interactions in Appendix A.3.

A.1 Algorithmic Training

Our algorithmic training is essentially a search function, which looks for the
top-performing parameter conﬁgurations in a past training period. These con-
ﬁgurations are then tested for their ex-post performances in a testing period.
Bollinger Bands. Below is the formula for Bollinger Bands, with a simple
moving average (of size N ) using a number (d) of standard deviations [15]

(cid:80)N

j = 1 Xj
N

X =

  (cid:80)N

j = 1(Xj − X)2
N

σ =

Upper BB = X + d ∗ σ

Lower BB = X − d ∗ σ

where X is closing price

Our trading algorithm can be formulized as:

buy : X < (Lower BB / 100) ∗ (100 + L)

sell : X > (Upper BB / 100) ∗ (100 − U )

(2)

(3)

Training. Using grid search in the space of the minimum, maximum, and mean
values that the parameters can take, results in a set C, containing all parameter
conﬁgurations obtained by the product of the sets of possible values for each
parameter:

N (cid:48) = f (N ) ∧ D(cid:48) = f (D) ∧ L(cid:48) = f (L) ∧ U (cid:48) = f (U )
C = N (cid:48) × D(cid:48) × L(cid:48) × U (cid:48)
where f (A) = {min A, max A, mean A}

(4)

Running the trading algorithm with all elements of C through the training
periods, we rank the parameter conﬁgurations based on their performance.

A.2 Zokrates Interactions

The Zokrates program. Zokrates [26] toolbox allows writing a root program
in Zokrates language, which speciﬁes the knowledge to be proven and acts as
the originator for a veriﬁer smart contract as well as a proof generator. The
Zokrates program we have implemented for verifying the trade decisions of the

16

1 def main ( field currentPrice ,
2
3
4
5
6
7

field upperBollingerBand ,
field lowerBollingerBand ,
private field buy_sell_flag ,
private field boundPercentage ) -> bool :
// buy_sell_flag is 1 for buy , 0 for sell
bool verified = if buy_sell_flag == 1 then currentPrice <

(cid:44)→ ( lowe rB ol lingerBand / 100) * (100 +
(cid:44)→ boundPercentage ) else currentPrice > (
(cid:44)→ up pe rBol li ngerBa nd / 100) * (100 - boundPercentage
(cid:44)→ ) fi

8

return verified

Fig. 7. Zokrates code in our implementation for generating veriﬁer smart contracts
and proofs.

Bollinger algorithm is presented in Figure 7. The program takes ﬁve parameters:
(1) X (the current price), (2) Upper BB , (3) Lower BB , (4) a ﬂag that tells the
code to generate a proof for a buy or sell decision, and lastly, (5) either L or
U based on the decision type. Logically, the program checks if the inputted X,
Upper BB , Lower BB , L or U values lead to the trading decision denoted by
the ﬂag. A proof generated from this root program conﬁrms that the prover has
made an undisclosed trading decision based on the Bollinger algorithm, using
some hidden parameters and the public parameters it has obtained from the
on-chain bot.
Verifying public parameters. Correctness of a proof ensures that a trading
decision is made accurately with the parameters inputted to the proof generator,
but it does not guarantee that the inputted parameters are the correct ones. In
other words, it is possible to produce a veriﬁable proof using parameter values
that are diﬀerent than the on-chain bot or the algorithmic trainer provides, as
long as the trading algorithm is executed correctly. Although the user needs to
trust the ChainBot with the correctness and integrity of private parameters,
it is necessary to implement a mechanism for ensuring that the correct public
parameters are used in proof generation.

We achieve this through utilizing a Zokrates feature: The inputs to the root
Zokrates program can be public or private; the former are included in the proof
as plaintext, while the latter are not revealed. This enables the oﬀ-chain bot
to feed the price and other public trading parameters into the proof as public
parameters and the on-chain bot to check if the values included in the proof are
the ones it has provided. This simple conﬁrmation is enough to accomplish the
desired task: if the oﬀ-chain bot uses incorrect public parameters, this will be
visible in the proof, and the proof veriﬁcation will fail.
Preventing information leaks. As mentioned in Section 3.1, using zero-
knowledge proofs to keep some parameters private is not suﬃcient for achieving
algorithmic privacy; whether the bot has decided to buy or sell should also be

17

kept secret. Unless designed properly, on-chain proof veriﬁcation can leak this
information. There are two conditions that the veriﬁcation mechanism should
hold to prevent leaking the trade decision:

1. There must be a single proof generator and veriﬁer contract for all possible
conditions that lead to a trade decision. Otherwise, the trading decision is
visible through the type of contract that the oﬀ-chain bot commands the
on-chain bot to relay the proof to.

2. Trade decision should be speciﬁed as a private input in the root Zokrates

code to prevent it from being openly included in the proof.

Validating the veriﬁer contract. The users should be able to ensure that the
veriﬁer contract is verifying what it is supposed to be verifying. The Zokrates ver-
iﬁcation system is based on Arithmetic Circuits and Rank-1-Constraint-Systems
(R1CS) [26]. Consequently, even though the veriﬁer contract is publicly visible,
what it veriﬁes is not easily understandable from the code. One way to enable
veriﬁer contract validation is making the root Zokrates code publicly accessible,
e.g. by storing it in a smart contract. This way, the users can audit the high-
level Zokrates code, compile it and compare the resulting Solidity code with the
deployed smart contract.

A.3 DiversiFi Interactions

Hiding the trade decisions of ChainBot is essential to protecting the privacy
of its trading strategy. To execute the trades privately, our implementation uses
DeversiFi [3], a self-custodial order book exchange that uses L2 for enhancing
transaction privacy and speed.
Validium and transaction privacy. DeversiFi is powered by the Validium-
based StarkEx scalabilty engine [6]. Validium is an L2 solution where multiple
transactions are batched oﬀ-chain in a single zero-knowledge proof, which is
veriﬁed on-chain. Although Validium resembles ZK-rollups in this sense, it diﬀers
in storing the entire data related to transactions oﬀ-chain.

Validium aims to solve the data availability problem by maintaining a Data
Availability Committee (DAC), where the (decentralized) members always hold
a copy of all oﬀ-chain transaction data and sign a commitment to every new state
before it can be submitted on-chain. Limiting the access to transaction data to
the members of DAC, Validium enhances the trader’s privacy, when compared
to L1 schemes or other L2 solutions that keep transaction data on-chain.
Private trading on DeversiFi. DeversiFi leverages Validium to allow its
users to hide their trades from the public. User funds are stored in so-called
token accounts (or vaults), which function as L2 wallets that can each have a
unique ID, hold a single type of asset and can be assigned to a single user at
a given time. A Merkle tree is formed from these token accounts and updated
every time a token account’s balance changes [4].

Before starting to trade on DeversiFi, the user has to deposit funds into a
StarkEx smart contract. The deposited amount is automatically recorded to the

18

user’s token account, making the funds available for trading. Trading happens
entirely oﬀ-chain, with a maker-taker model: the maker signs an order, which in-
cludes the token types and amounts being traded, as well as the maker’s account
IDs for these tokens. The taker executes the trade by signing the order along
with the IDs of their two corresponding token accounts. When a user wants to
withdraw their funds from DeversiFi, the amount is subtracted from their token
account balance and added to their “on-chain withdrawal balance,” enabling
direct withdrawal from the StarkEx smart contract [4,53].

Limitations. Despite being a “decentralised exchange” in technical terms, Dev-
ersiFi does not provide a trustless trading platform. First, keeping trades private
from other traders comes at the cost of sharing them with the DAC. The DAC
members are well-known organisations which Ethereum blockchain users already
share data with by using their services and infrastructures. In this sense, Dev-
ersiFi piggybacks on the existing implicit user trust in these organisations.

Secondly, as it is DeversiFi who operates the sequencers, which batch multiple
transactions into a single zero-knowledge proof, the users have to trust DeversiFi
with including their transaction in a proof and submitting it to the chain. In the
worst scenario, if DeversiFi attempts to censor a user’s a withdrawal request,
the user can retrieve her funds from the StarkEx smart contract if she manages
to acquire the necessary data from DAC members.

References

1. 3Commas, https://3commas.io/, Accessed: 2021-09-06
2. Coinmatics, https://coinmatics.com/, Accessed: 2021-09-06
3. DeversiFi, https://www.deversifi.com/, Accessed: 2021-09-06
works,
4. How

deversiﬁ

https://docs.deversifi.com/articles#

HowDeversiFiWorks, Accessed: 2021-09-06

5. Shrimpy, https://www.shrimpy.io/, Accessed: 2021-09-06
6. StarkEx: Powering scalable self-custodial transactions, https://starkware.co/

product/starkex/, Accessed: 2021-09-06
7. TokenSets, https://www.tokensets.com/
8. Tradelize, https://tradelize.com/, Accessed: 2021-09-06
9. yearn.ﬁnance, https://yearn.finance/, Accessed: 2021-09-06
10. Zcash parameter generation, https://z.cash/technology/paramgen/, Accessed:

2021-09-06

11. Adams, H., Zinsmeister, N., Salem moody, M., Keefer, R., Robinson, D.: Uniswap
v3 core. Whitepaper (March 2021), https://uniswap.org/whitepaper-v3.pdf
12. Banerjee, A., Clear, M., Tewari, H.: zkHawk: Practical private smart contracts

from MPC-based Hawk. arXiv preprint arXiv:2104.09180 (2021)

13. Baumann, N., Steﬀen, S., Bichsel, B., Tsankov, P., Vechev, M.: zkay v0.2: Practical

data privacy for smart contracts. arXiv preprint arXiv:2009.01020 (2020)

14. B´eres, F., Seres, I.A., Bencz´ur, A.A., Quintyne-Collins, M.: Blockchain is watching
you: Proﬁling and deanonymizing ethereum users. arXiv preprint arXiv:2005.14051
(2020)

15. Bollinger, J.: Using bollinger bands. Stocks & Commodities (1992)

19

16. Bowe, S., Chiesa, A., Green, M., Miers, I., Mishra, P., Wu, H.: ZEXE: Enabling
decentralized private computation. In: IEEE Symposium on Security and Privacy
(SP) (2020). https://doi.org/10.1109/SP40000.2020.00050

17. B¨unz, B., Agrawal, S., Zamani, M., Boneh, D.: Zether: Towards privacy in a smart
contract world. In: International Conference on Financial Cryptography and Data
Security. Springer (2020). https://doi.org/10.1007/978-3-030-51280-4 23

18. Buterin, V.: An incomplete guide to rollups (May 2021), https://vitalik.ca/

general/2021/01/05/rollup.html

19. Calcaterra, C., Kaal, W.A.: Decentralized Finance (DeFi). SSRN Electronic Jour-

nal (2021). https://doi.org/10.2139/ssrn.3782216

20. Cecchetti, E., Zhang, F., Ji, Y., Kosba, A., Juels, A., Shi, E.: Solidus:
Conﬁdential
In: ACM
SIGSAC Conference on Computer and Communications Security (2017).
https://doi.org/10.1145/3133956.3134010

via PVORM.

transactions

distributed

ledger

21. Chan, E.P.: Quantitative trading: how to build your own algorithmic trading busi-

ness. John Wiley & Sons (2021)

22. Chan, E.P.: Algorithmic trading: winning strategies and their rationale. John Wiley

& Sons (2013)

23. Cheng, R., Zhang, F., Kos, J., He, W., Hynes, N., Johnson, N., Juels, A., Miller, A.,
Song, D.: Ekiden: A platform for conﬁdentiality-preserving, trustworthy, and per-
formant smart contracts. In: IEEE European Symposium on Security and Privacy
(EuroS&P) (2019). https://doi.org/10.1109/EuroSP.2019.00023

24. Chervinski, J.O.M., Kreutz, D., Yu, J.: Floodxmr: Low-cost transaction ﬂood-
ing attack with monero’s bulletproof protocol. IACR Cryptology ePrint Archive
(2019), https://eprint.iacr.org/2019/455.pdf

25. Danezis, G., Fournet, C., Kohlweiss, M., Parno, B.: Pinocchio coin: build-
ing Zerocoin from a succinct pairing-based proof system. In: The First ACM
workshop on Language support
(2013).
https://doi.org/10.1145/2517872.2517878

for privacy-enhancing technologies

26. Eberhardt, J., Tai, S.: Zokrates - scalable privacy-preserving oﬀ-chain computa-
tions. In: IEEE International Conference on Internet of Things (iThings) and IEEE
Green Computing and Communications (GreenCom) and IEEE Cyber, Physi-
cal and Social Computing (CPSCom) and IEEE Smart Data (SmartData). IEEE
(2018). https://doi.org/10.1109/Cybermatics 2018.2018.00199

27. Ellis, S., Juels, A., Nazarov, S.: ChainLink: A decentralized oracle network (2017),

https://link.smartcontract.com/whitepaper

28. Eskandari, S., Salehi, M., Gu, W.C., Clark, J.: Sok: Oracles from the ground truth

to market manipulation. arXiv preprint arXiv:2106.00667 (2021)

29. Fauzi, P., Meiklejohn, S., Mercer, R., Orlandi, C.: Quisquis: A new de-
sign for anonymous cryptocurrencies.
International Conference on the
Theory and Application of Cryptology and Information Security (2019).
https://doi.org/10.1007/978-3-030-34578-5 23

In:

30. Gervais, A., Karame, G.O., W¨ust, K., Glykantzis, V., Ritzdorf, H., Capkun, S.:
On the security and performance of proof of work blockchains. In: Proceedings of
the 2016 ACM SIGSAC conference on computer and communications security. pp.
3–16 (2016)

31. Gudgeon, L., Moreno-Sanchez, P., Roos, S., McCorry, P., Gervais, A.: Sok: Layer-
two blockchain protocols. In: International Conference on Financial Cryptography
and Data Security. Springer (2020). https://doi.org/10.1007/978-3-030-51280-4 12

20

32. Hendershott, T., Riordan, R.,

formation. Manuscript,
https://doi.org/10.2139/ssrn.1472050

et
University

al.: Algorithmic
California,
of

trading
Berkeley

and

in-
(2009).

33. Hopwood, D., Bowe, S., Hornby, T., Wilcox, N.: Zcash protocol speciﬁca-
tion. GitHub: San Francisco, CA, USA (2016), https://zips.z.cash/protocol/
protocol.pdf

34. Jiang, Z., Liang, J.: Cryptocurrency portfolio management with deep rein-
forcement learning. In: IEEE Intelligent Systems Conference (IntelliSys) (2017).
https://doi.org/10.1109/IntelliSys.2017.8324237

35. Jivanyan, A.: Lelantus: Towards conﬁdentiality and anonymity of blockchain trans-
actions from standard assumptions. IACR Cryptology ePrint Archive (2019),
https://eprint.iacr.org/2019/373/20190604:053917

36. Kalodner, H., Goldfeder, S., Chen, X., Weinberg, S.M., Felten, E.W.: Arbitrum:
Scalable, private smart contracts. In: 27th USENIX Security Symposium (2018).
https://doi.org/10.5555/3277203.3277305

37. Kim, K.: Electronic and algorithmic trading technology: the complete guide. Aca-

demic Press (2010)

38. Kosba, A., Miller, A., Shi, E., Wen, Z., Papamanthou, C.: Hawk: The Blockchain
Model of Cryptography and Privacy-Preserving Smart Contracts. IEEE Sympo-
sium on Security and Privacy (SP) (2016). https://doi.org/10.1109/SP.2016.55
39. Le, D.V., Gervais, A.: Amr: Autonomous coin mixer with privacy preserving reward
distribution. ACM Conference on Advances in Financial Technologies (AFT’21)
(2021)

40. Maharramov, T., Francioni, E.: The Dusk network whitepaper
41. Makarov, I., Schoar, A.: Trading and arbitrage in cryptocurrency markets. Journal

of Financial Economics (2020). https://doi.org/10.2139/ssrn.3171204

42. Noether, S.: Ring signature conﬁdential transactions for Monero. IACR Cryptology

ePrint Archive (2015), https://eprint.iacr.org/2015/1098

43. Pole, A.: Statistical arbitrage: algorithmic trading insights and techniques. John

Wiley & Sons (2011)

44. Poon, J., Buterin, V.: Plasma: Scalable autonomous smart contracts. Whitepaper

(2017)

45. Poon, J., Dryja, T.: The bitcoin lightning network: Scalable oﬀ-chain instant pay-
ments (2016), https://lightning.network/lightning-network-paper.pdf
46. Qin, K., Zhou, L., Afonin, Y., Lazzaretti, L., Gervais, A.: Ceﬁ vs. deﬁ–comparing
centralized to decentralized ﬁnance. arXiv preprint arXiv:2106.08157 (2021)
47. Qin, K., Zhou, L., Gervais, A.: Quantifying blockchain extractable value: How dark

is the forest? arXiv preprint arXiv:2101.05511 (2021)

48. Qin, K., Zhou, L., Livshits, B., Gervais, A.: Attacking the deﬁ ecosystem with
ﬂash loans for fun and proﬁt. Financial Cryptography and Data Security: 25th
International Conference (FC’21) (2021)

49. S´anchez, D.C.: Raziel: Private and veriﬁable smart contracts on blockchains. arXiv

preprint arXiv:1807.09484 (2018)

50. Sasson, E.B., Chiesa, A., Garman, C., Green, M., Miers, I., Tromer, E., Virza, M.:
Zerocash: Decentralized anonymous payments from Bitcoin. In: IEEE Symposium
on Security and Privacy (SP) (2014). https://doi.org/10.1109/SP.2014.36

51. Shah, D., Zhang, K.: Bayesian regression and bitcoin. In: 52nd Annual Aller-
ton Conference on Communication, Control, and Computing (Allerton) (2014).
https://doi.org/10.1109/ALLERTON.2014.7028484

52. Sharpe, W.F.: The sharpe ratio. Journal of portfolio management (1994)

21

53. StarkWare: Starkdex deep dive:

Introduction (2021), https://medium.com/

starkware/starkdex-deep-dive-introduction-7b4ef0dedba8

54. Steﬀen, S., Bichsel, B., Gersbach, M., Melchior, N., Tsankov, P., Vechev,
M.: zkay: Specifying and enforcing data privacy in smart contracts.
In:
ACM SIGSAC Conference on Computer and Communications Security (2019).
https://doi.org/10.1145/3319535.3363222

55. Teutsch, J., Reitwießner, C.: A scalable veriﬁcation solution for blockchains. arXiv

preprint arXiv:1908.04756 (2019)

56. Treleaven, P., Galas, M., Lalchand, V.: Algorithmic trading review. Communica-

tions of the ACM (2013). https://doi.org/10.1145/2500117

57. Van Saberhagen, N.: Cryptonote v 2.0 (2013), https://www.getmonero.org/ru/

resources/research-lab/pubs/whitepaper_annotated.pdf
58. Vo, A., Yost-Bremm, C.: A high-frequency algorithmic

strat-
egy for cryptocurrency. Journal of Computer Information Systems (2020).
https://doi.org/10.1080/08874417.2018.1552090

trading

59. Wijaya, D.A., Liu, J., Steinfeld, R., Liu, D.: Monero ring attack: Recreating zero
mixin transaction eﬀect. In: 17th IEEE International Conference On Trust, Secu-
rity And Privacy In Computing And Communications/ 12th IEEE International
Conference On Big Data Science And Engineering (TrustCom/BigDataSE) (2018).
https://doi.org/10.1109/TrustCom/BigDataSE.2018.00165

60. Wilson, T.: Explainer: Binance: The crypto giant

facing pressure from
regulators. Reuters (08 2021), https://www.reuters.com/business/finance/
binance-crypto-giant-facing-pressure-regulators-2021-08-19/

61. Yousaf, H., Kappos, G., Meiklejohn, S.: Tracing transactions across cryptocur-
rency ledgers. In: 28th USENIX Conference on Security Symposium (2019).
https://doi.org/10.5555/3361338.3361396

62. Zhang, R., Xue, R., Liu, L.: Security and privacy on blockchain. ACM Computing

Surveys (CSUR) (2019). https://doi.org/10.1145/3316481

63. Zhou, L., Qin, K., Cully, A., Livshits, B., Gervais, A.: On the just-in-time discovery
of proﬁt-generating transactions in DeFi protocols. IEEE Symposium on Security
and Privacy (SP’21) (2021)

64. Zhou, L., Qin, K., Gervais, A.: A2MM: Mitigating frontrunning, transaction re-
ordering and consensus instability in decentralized exchanges. arXiv preprint
arXiv:2106.07371 (2021)

65. Zhou, L., Qin, K., Torres, C.F., Le, D.V., Gervais, A.: High-frequency trading on
decentralized on-chain exchanges. In: IEEE Symposium on Security and Privacy
(SP) (2021), https://arxiv.org/pdf/2009.14021.pdf

66. Zyskind,

G.:

Enigma:

Decentralized

Computation

Platform with
(2019).

Cybersecurity

Guaranteed
https://doi.org/10.7551/mitpress/11636.003.0018

Solutions

Privacy.

New

for

22

